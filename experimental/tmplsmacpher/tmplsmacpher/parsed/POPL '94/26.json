{"article_publication_date": "02-01-1994", "fulltext": "\n An Operational Framework for Value-Passing Processes* Rance Cleaveland Daniel Yankelevich Department \nof Computer Science North Carolina State University Raleigh, NC 27695-8206 USA tel: +1 919 515 7862 fax: \n+1 919 515 7896 e-mail: {rance, dany}~csc .ncsu. edu Abstract typically focused on modeling synchronization \nbetween, and the simultaneous execution of, processes. Appropri- This paper develops a semantic framework \nfor concur\u00adate equivalences and preorders [7, 10, 13, 15, 20, 21, 29] rent languages with value passing. \nAn operation analo\u00adhave been defined that relate concurrent systems on the gous to substitution in the \nJ-calculus is given, and a se\u00adbasis of their externally visible behavior, and the the\u00ad mantics is given \nfor a value-passing version of Milner s ories have been successfully applied to the verification Calculus \nof Communicating Systems (CCS). An opera\u00adof concurrent systems. However, relatively little atten\u00ad tional \nequivalence is then defined and shown to coincide tion haa been devoted to the operational aspects of \nthe with Milner s (early) bisimulation equivalence. We also exchange of data between proceaaes. This \nattention to show how semantics may given for languages with asyn\u00ad flow of values is central in the A-calculus, \nwhere no\u00ad chronous communication pm mitives. In contrast with tions of ~-reduction and substitution form \nthe basis for existing approaches to value passing, this semantics does defining function application. \nWhen value pasaing has not reduce data exchange to pure synchronization over been modeled in process \nalgebra, it has typically been (potentially infinite) families of ports indexed by data, done via a reduction \nto simple synchronization, with and it avoids variable renamings that are not local to data values in \nessence encoded in the name of the processes engaged in communication. ports that synchronizing processes \nuse. While adequate Introduction at an abstract level, this approach obscures details as\u00adsociated with \nensuring that the correct transmission of Process algebraa such as CCS [22], CSP [18] and data from one \nprocess to another. Consequently, it is ACP [4] have been proposed aa theories that highlight difficult \nto use these semantics to guide the develop\u00adfundamental notions in concurrency in the same way ment of \nimplementations-specifically, interpreters-ofthat the J-calculus [6] does for functional programming. \nvalue-p aasing languagea. Although the latter essentially includes only two pr~ gramming constructs, \nA-abstraction and function ap\u00adplication, it has proven very useful as a framework The goal of this paper \nis to formulate an implementable for studying numerous issues, both implementational semantics for process \nalgebras with value passing. To as well as theoretical, in functional programming lan-this end, we present \na semantics that accounts for op\u00adguages. In the search for similarly foundational oper-erational concerns \nassociated with the exchange of data ations in concurrency, process algebra researchers have between \nproceaaes while maintaining a degree of ab\u00ad straction from specific implementational details. The Research \nsupported by NSF/DARPA grant GGR-so14775, NSF grant CCR-9120995, ONR Young Investigator Award central \ndifficult y to overcome is that, in contrast to NOO014-92-.J-1582, and NSF Young Investigator Award CCR \nthe A-calculus, where the syntactic structure of a re\u00ad92579S3. ducible expression (redex) determines \nthe subexpres-Permksion to copy without fee all or part of this matarial is sions involved in a step \nof ~-reduction, the emitters granted provided thst the copies are not made or distributed for and consumers \nof values in concurrent programs may diract commercial edvantage, tha ACM copyright notica and tha be \narbitrarily separated, syntactically. Consequently, titla of the publication and its data appaar, and \nnotica ia givan exchanging a value requires, at some level, the use of that copying is by permission \nof tha Association for Computing rout ing information to determine where the datum is Machinary. To copy \notherwisa, or to rapubfish, mquirea a fOO and/or epecific permission. to be delivered. POPL 94-1194, \nPortland Orsgon,USA @ 1994 AH 0-8979163~B4/ool ..$3.~ The remainder of the paper is structured as follows. \nThe next section describes more precisely the intuitive motivation for the work presented in this paper. \nThe section following then outlines a version of Milner s CCS with value-passing, defines its operational \nsemantics ac\u00adcording to the standard approach, and introduces an associated behavioral equivalence, bisimulation \nequiv\u00adalence. Section 4 then remarks on a shortcoming of the traditional semantics, gives a semantics \nfor value\u00adpaasing designed to remedy this difficulty, and presents a new notion of semantic equivalence. \nThe section fol\u00adlowing establishes that the semantic equivalences coin\u00adcide, while Section 6 shows how \nthe semantics may be altered to model asynchronous communication. The fi\u00adnal section presents our conclusions \nand directions for future research. 2 Reduction and the Flow of Values The aim of this paper is to give \na semantics for concur\u00adrent procesaea that pass values; as we wish the semantics to be implementable, \nit should account for issues associ\u00adated with the transmission of data, while remaining ab\u00adstract with \nrespect to more concrete implementational details. In this section we outline aspects peculiar to concurrent \nlanguages that complicate the development of such a semantics, We begin by first reviewing rel\u00adevant \nintuitions from the A-calculus, some familiarity with which will be assumed on the part of the reader. \nThe A-calculus is built on the notion of $reduction, which in turn is based on the operation of substitution. \nP-reduction can be thought of as specifying how an ar\u00adgument to a function is to be distributed inside \nthe body of the function; in the reduction step (AZ.M)N+ M[iv/z], the 4 relation in essence states that \nthe expression N should be sent to all (free) occurrences of z in A4. It should be noted that this flow \nof data is local to the redex (Jz.J4)N in the sense that the places in where datum N is to be sent can \nonly be within M; any con\u00adtext that might surround the term cannot alter the pos\u00adsible destinations of \nN. This affords a syntactic charac\u00adterization of redexes a term can be a redex if and only if it is of \nthe form i14 N (i.e. M and N are syntactically adjacent) and M has the form AZ .M . Different opera\u00adtional \naccounts of the A-calculus exploit this definition of redex to define evaluation relations that have \ndirect implementations as interpreters. In concurrent languages, by way of contrast, the local\u00adity of \ndata flow present in the J-calculus is, by design, absent, since these languages are meant to model sys\u00adtems \nconsisting of entities that exchange data without necessarily being adj scent to one another. For exam\u00adple, \nconsider the following term in a putative process algebra. . ..[lax.P ll...llaQllll . . . This system \nconsists of some number of subsystems run\u00ad ning in parallel. Process ?iE.Q wishes to output expres\u00adsion \nE on port a and then behave like Q, while cuX.P is awaiting an input on port a which it will then as\u00adsign \nto X throughout P. What is notable here is the nonlocal flow of information; zE. Q and crX.P in some \nsense form a redex even though they are not syntac\u00adtically adjacent and may in fact be separated arbitrar\u00adily \nfar apart in the term. Additionally, other processes (subterms) may also wish to communicate using a, \nand these may interfere with the exchange between the two processes above. Both of these features complicate \nthe development of an implementable semantics for lan\u00adguages supporting concurrency and value passing; \nthe work reported in this paper aims at circumventing these difficulties. 3 CCS and Value Passing This \nsection presents the syntax and traditional seman\u00adtics for a language with value passing. In the intereats \nof notational simplicity, values and processes will be distinct (in contrast with the language found \nin [27]). The language-CCS with Value Passing (CCS-VP) is parameterized with respect to several sets \nof syntactic entities. Let V be a (countably infinite) set of value vari\u00adables ranged over by V, V , \nVI, . . . and ~ be a set of value expressions ranged over by E, E , El, . . .. Also let Pr be a set of \npredicate expressions ranged over by m, r , . . .. Elements of g and Pr may contain occurrences of vari\u00adables \nfrom V. We assume 2 to be a (countably infinite) set of process variables, ranged over by z, x , z 1, \n..., and A to be a set of ports, or labels, ranged over by a, ~, . . .. We use L,.L ,.L1,... to represent \nfinite subsets of A, and f to denote a (relabeling) function in A -+ A. For technical convenience we \nassume that V n A? = 0. The syntax of CCS-VP may now be given using the following grammar. P ::= nil \nICYV.PIzE.P I(T).P IP+P I PIP IP\\L IP[fl [z ]recz. P In CYV.P and rec z. P the operators aE. and recx. \nbind free occurrences of V and x, respectively, in P in the usual sense. In the sequel we restrict our \nattention to terms in which all instances of process variables are guarded, i.e., occur inside a crV. \nor zE, context. We use P to denote the set of all such guarded terms in CCS-VP, with P, Q, P , Q , PI, \nQl,... ranging over P. We sometimes refer to elements of P as processes. In order to give the standard \noperational semantics of CCS-VP we first define the following notions. We call expressions of the form \nCYE and zE, where cr E A and E G &#38;, actions. We also let r $ A denote a special internal action and \nuse A = {d31cYGAAEEE} U{7Z?lcr cAAl?6~}U{r} to represent the set of all actions. a, a , al, . . . are \nused to range over A. Intuitively, a process can perform aE when it is capable of receiving E as an input \non a from its environment, while it can perform ?iE when it may output E on a to its environment. We \nextend to actions as follows: if a = aE then z = GE, and if a=17Ethen ii=aE. Thefunction wEA ~AU{r} \nreturns the port component of an action; so CU(CYE)= ru(~E) = CY,and m(r) = r. Also, if f E A * A and \na c A, then apply (f, a) relabels the port component of a by ~; formally, this is given by f(cY)E if \na = crE apply (f, a) = f(cr)E if a = EE T otherwise (i.e. a = r) {- We assume that 8 and % are equipped \nwith notions of free variable and substitution of expressions for vari\u00adables; we use fv(E) ~ V to represent \nthe free variables in E and El [V := E2] ~ E to denote the expression El with all occurrences of V replaced \nby EZ, and sim\u00adilarly for z c Pr. We furthermore assume that for any E, lfv(E)l <00. We also use jv(P) \n~ V and fvx (P) to represent the set of free value and process variables, respectively, in P; note that \nfv (P) and fvx are finite for every P. For T c Pr, we assume the existence of a method 1= for evaluating \nr; so + T holds if n evaluates to true. If X is an infinite set, we use qx ~ 2X h X to denote a function \nwith the property that for every finite X ~ X, qX (A ) $! X . We now define substitution for CCS-VPasfollows. \nDefinition 3.1 Let W 6 V UX and R 6 &#38; UP. Then P[R/W] for P E P is defined inductively as follows. \nni~R/ W] = nil R ifx=W, REP z[R/W] = ~ otherwise { (crV.P)[R/W] = CYV.P ifW~V aV.(P[R/Wl) ifWEX { crV \n.(P[V /V] [R/W]) otherwise where V = W(fv(R)). Notice that the jinal clause handles vatiable capture \nin the usual fashion by re\u00adnaming bound variables. (EE .P)[R/W] = E(E [W := R]).(P[R/W]) if W 6 V, R \nE ~ @E .(P[R/W]) otherwise { e ((~). P)[R/W] = (r[W := R]).(P[R/W]) if W E V, R G &#38; (r).(P[R/W]) \notherwise{ o (Pl + P2)[R/W] = (Pl[R/W]) + (P,[R/W]) e (PllP,)[R/W] = (Pl[R/W]) [ (P,[R/Wl) (P\\L)[R/W] \n= (P[R/W])\\L @ (P[f j)[R/Wl = (P[R/Wl)[fl  (recz. P)[R/W] =  recx. P ifW=z rec z. (P[R/W]) ifWEV { \nrec z . (P[z /z] [R/W]) otherwise where z = ~x(fvx(P)). The final clause prevents vam able capture. \n The traditional semantics of CCS-VP is given in terms ofarelation ~~ PxAxP,whereP&#38; PIholdsifP is \ncapable of executing action a and evolving to P as a result. The formal definition of ~ appears in Figure \n1. Intuitively, CZV.P is a process waiting for an input on channel a; upon receiving an expression it \nevolves to P with occurrences of V replaced by this value. EE.P first outputs E on a and then behaves \nlike P. A pro\u00adcess (n) .P may execute an action from P only if the predicate n-is true. Operator + is \na choice operator; PI+ P2 is initially capable of the actions of either P1 or P2, with the process thereafter \nbehaving like the process whose initial action was chosen. Process PI IP2 models the parallel composition \nof PI and P2 by interleaving the actions available to each; in addition, if one of the processes is capable \nof outputting a value on a port that the other is capable of receiving on, then the two pro\u00adcesses synchronize, \nwith an internal action resulting. In P\\L the ports in L become loca~ no interaction can take place between \nP and its environment using these channels. In P[ f ] f is used to rename the labels that P interacts \non. Finally, rec z. P represents a recursive process that can be thought of as a solution to the equation \nz = P. Having defined the operational semantics of CCS-VP processes, we now present the definition of \nbisimulation equivalence [22], which is designed to relate processes on the basis of the behavior they \nexhibit to their envi\u00adronments. The definition is given in terms of bisimula\u00adtions, which are relations \nthat require related processes to have matching transitions . Definition 3.2 A relation 7? ~ P x P is \na bisimulation i~ whenever P 7? Q, then ihe following holds for all a~d. 1. If P $ P then there is aQ \nsuch that Q % Q and P ??Q . aV.P a~EP[E/Vl for any E c &#38; (prefin) ZE.P ~E P (prefout) P4P , +7 * \n(T).P 3 P (cond) P%P + P+ Q%P (Surnl) Q~Q ~ P+ Q~Q (surer) P%P a PI(J ~ P [Q (parl) Q~Q a PIQ $ PIQ \n(parr) P% P , Q%Q ~ P/Q ~ P IQ (comm) P % P , ~(a)@ L a P/L % P \\L (res) P%p * Jlfl ppYf a)P [fl (rel) \nP[recz. P/x] ~ P * recx. P J4 P (ret) Figure 1: The Traditional Semantics of CCS-VP. 2. IfQ % Q then \nthere is a P such that P % P and In this section, we develop an alternative operational P 7ZQ . semantics \nfor CCS-VP that is computable; it also aims to expose what we feel is a main operational consid-Bisimulation \nequivalence, w ~ P x P, is defined by: P N eration in the implementation of communicating con-Q if and \nonly if there is a bisimulation 1? such that current systems: the routing of data from senders to P7?Q. \nreceivers. The new semantics relies on the introduction of process addresses and an operation of routed \nsubstitu\u00adtion that channels a substitution to the process spec\u00ad 4 An Effective Semantics for Value ified \nby a given address. Intuitively, input actions will Passing now be tagged with the address of the process \nexpecting While elegant, the semantics of CCS-VP is not directly the value; when a synchronization occurs, \nthe address implementable, in a certain sense. To see this, consider borne by the input action will guide \nthe resulting sub\u00adhow one might try to implement an interpreter for CCS-stitution to the appropriate \ndestination. VP on the basis of the rules in Figure 1. Given a process Formally we define the set $ of \nprocess addreaaea using term P, such an evaluator would need first to compute the following grammar. \nthe set {(a, P )l P4P }. s ::=01s1 IS( However, this set will in general be infinite when P is capable \nof any input action and the set of value expres\u00adsions is infinite, and thus the interpreter would not, \nin Weuaes, s , sl,... to range over S. Intuitively, a pr\u00adgeneral, terminate. ceaa address describes the \nposition of a process within a larger system. An address of the form indicatesThe problem with the semantics \nis that it is too ab\u00adthe current process, while 1 and [ indicate in which stract with respect to modeling \nthe exchange of values. component left or right, respectively-of a parallel In essence, the semantics \nworks by replacing a given in\u00adcomposition P IQ the process is located. For example,put port name by a \nnumber of port names indexed by the address of Q in (P IQ) II? is (1. This syntax hasthe possible values \nthat may be received on it. For ex\u00adalrady been used in the literature to describe addressesample, suppose \nthat &#38; = Nat, the set of natural num\u00ad of subprocesses; see for instance [24]. bers, and consider \na process of the form P = aV.P . From the operational semantics given in the previous In order to specify \nthe new semantics, we first introduce section it is the case that P ~ P [i/Vl for any natu-the new set \nof actions we consider. The set din = ral number i. The same behavior could be deduced for {aV@sla 6A \nAVCVAsc S}representstheaet the following process in a non-value-passing calculus: of input actions. do \n= {@El aGAAEEg}U{r} ZiGN=t~i.P [i/Vl. This h= the effect of obscuring how contains the noninput actions \n; then A = A in U Ao. the transfer of values between P and Q ~ zE.Q should We use a,a , al,... to range \nover A , and ti to range be achieved in the system PIQ. over A.. The functions ml ~ A 4 A U {T} and apply \nc (A-+A)xA 4A are now defined by: cr if a= aV@s w (a) = a ifa=EE T otherwise { f(cY)V@s if a = cxV@s \nappiy (f, a) = ~E ifa=ZiE T otherwise (i.e. a = ~) { We now introduce the notion of routed substitution. \nIntuitively, [E/VJ@s indicates that the substitution [E/V] should be performed on the process at address \ns. For instance, applying [E/~@e [I to the process (@(v + 3).niil ~(v * 2).nz~ I a.nil sends the su~stitu. \ntion to the subterm ti(V * 2).nil, returning (@(V + 3).nil ] ti(E * 2) .nd) I a. nil. The formal definition \nis as follows. Definition 4.1 LetP,Q c P,E6~,VEV, andsc S. Then P[E/V@s is dejined inductively as follows. \ne Ifs = then P[E/~@.s = P[E/Vl. Ifs # e then P[E/Vl@s is dejined as follows. -(P@)[E/V@S = (P[E/Vl@S \n)lQ ifs= s 1 P[(Q[E/Vl@S ) ijS = S [ { -(P\\L)[E/V]@S = (P[E/V]@s)\\L. -(P[f])[E/V]@s = (P[E/VJ@S)[fl. \nni~E/V]@s = nil. -(a. P)[E/Vl@s = a.P. -(( T). P)[E/Vl@S = (r).P. -(P+ Q)[E/V@S = P+ Q. -(recz. P)[E/Vl@. \n= recz. P. Note that when s # e and P has the form nil, a. P , PI+ P2 or rec z. P , the rules for P[E/Vi@, \nindicate that the substitution is dropped. Intuitively, in this situation s represents a faulty address; \nit is fairly straightforward to show that in the rules given in Figure 2, these cases can never arise. \nThe operational semantics is given in terms of a rela\u00adtion HG (P x A x ?), the formal definition for \nwhich appears in Figure 2. Most of the rules from the old semantics remain the same; only the treatment \nof pre\u00adfixing with an input action and I need changing. The intuition underlying the rules is the following. \nIn this semantics, input actions are labeled with the ad\u00address of the process to which an incoming value \nshould be directed. The operations +, \\L, [j] and rec z. be\u00adhave essentially aa they do in the old semantics, \nas does prefixing with an output action or a predicate. The rule for input-action prefixing assigns the \naddress o to the action labeling the transition. The rules for I are slightly more complicated than before, \nsince actions must be decorated with appropriate routing information. Thus, if P requests an input on \naV at address s and evolves to P , then PIQ must add a 1 marker to s in evolving to P IQ to indicate \nthat the substitution should be sent to the left component of the [. If P wishes to perform an output \nwithout synchronizing with P, then P IQ be\u00adhaves as in the old semantics, and this is reflected in the \nform of rules (parlo ) and (parro ). Finally, if P signals a desire for an input on cxV and Q is willing \nto perform an output on the same port, then the two may synchronize, with a r resulting and the appropri\u00adate \nsubstitution being routed to P. The dual situation holds for Q. The rules implementing this are (comml \n) and (commr ). As an illustration of semantics, consider the following term. P s (aX.~X.niilf?Y. nil)lEE.niJ \nBy applying the above rules, we may deduce the follow\u00ading transitions for P. ax~l 1 P (BX.nil l~Y.nil)lEE.nil \n p pY&#38;[ 1 (cxX.FX.nillnil) lEE. nil P = (aX.~X.nilJ~Y.ni~ Jnii PA (~X~i~lPY.niOIE/X]@ol I nil E ((Px.niOIE/X]@* \nI /3Y.ni~ I nil S (7E.nillBY.niZ) lnii The last of these transitions illustrates how the [ and 1 operators \nguide incoming substitutions to the appro\u00adpriate subterm. Notice also that in the transfer of data in \nthe last transition, the routing procedure does not touch the process /3Y.ni~ no attempt is made to sub\u00adstitute \nE into it. 4.1 Implementing the Semantics That the semantics is implementable stems from the following \nresult. Theorem 4.2 LetPcP, andletT ={(a,K) IP ~ K}. Then ITI <W. On the basis of this theorem, it is \nrelatively straightfor\u00adward to implement a routine that computes the transi\u00adtions available to a term. \nGiven a term as input, the procedure would recursively compute the transitions of its subterms and combine \nthem appropriately, as in\u00addicated by the applicable rules, to obtain the transi\u00adtions of the over-all \nterm. As the theorem guarantees that these sets are finite, the routine is effectively com\u00adputable. \nRules (prefout), (cond), (suml), (surer), (res), (rel), and (ret) from Figure 1, with H replacing +. \nCYV.P a= P (prefin ) pa= p =)- P]Q R1 P IQ (parli ) PAP + P[Q &#38; P IQ (parlo ) Q a= Q ~ PIQaBrPIQ \n (parri ) Q&#38;Q ~ PIQLPIQ (parro ) pa~pt,Q~Q, ~ PIQ &#38; (P [E/V]@.)lQ (comml ) p~p/,Q ~Q, + PIQ \n~ P [(Q [E/V]@.) (commr ) Figure 2: A New Semantics for Value Passing. 4.2 A Semantic Equivalence In \nP M Q, Q may contain free occurrences of V; there\u00adfore we cannot directly apply the definition of w given \nin Section 3. Instead, we define the following. Definition 4.3 A relation R ~ (P x P) is an input\u00adsensitive \nbisimulation i~ whenever P R Q then the fol\u00adlowing hold. 1. If P ~ P , then there is aQ such that Q ~ \nQ and P R Q1, and synwnetm cally for Q. 2. IfP a= P thenYE E&#38;there areQ E P,V cVands ES suchthatQ \nVA Q and P [E/VJ@S R Q [E/V ]@S , and symmetrically for Q. P z Q if there is an input-sensitive bisimulation \n1? such that F~Q. Notice the parallel between this equivalence and the traditional extensional equivalence \non functions that r~ lates two functions iff they give the same results for all possible arguments. It \nis straightforward to establish that N is itself an input-sensitive bisimulation, and is in fact the \nlargest such relation. 5 The Equivalences Are Equivalent This section establishes that = relates exactly \nthe same CCS-VP processes as N. The importance of this result lies in the fact that it licenses the use \nof either form of operational semantics for CCS-VP. If one is not inter\u00adested in the specific mechanisms \nof data exchange, then one may use the traditional, more abstract semantics; if on the other hand one \nis interested in more imple\u00admentational considerations, then one may use the new semantics. In either \ncase, the equivalences deduced be\u00adtween processes at one level will hold at the other. The correspondence \nbetween equivalences rests on the following lemmas. Lemma 5.1 Let P c P Z P if and only if sES such that \nP * Proof. Proceeds by Pa~PlandP =Q. P,a GA, and E E 8. Then there exist Q GP, V E V and Q and P G Q[E/V]@S. \ninduction on the derivations of l Lemma 5.2 Let P E Proc and a E Ao. Then P ~ P ifand only ifP~ Pt. \nProof. Proceeds by induction on the derivations of p-%p and P&#38;P . 0 Using these lemmas, we can now \nprove the following theorem. Theorem 5.3 Let P, Q E P. Then P z Q if and only if Pfi Q. Proof. Using \nLemmas 5.1 and 5.2, one can show that every input-respecting bisimulation is also a bisimula\u00adtion and \nthat every bisimulation may be extended into an input-respecting bisimulation. The proof then fol\u00adlows. \no Early vs. Late Equivalence The traditional equivalence presented in this paper is sometimes referred \nto as early bisimulation equivalence. The intuitive explanation for this terminology is that when trying \nto match an input transition of process P, Q gets to look ahead at incoming values in order to determine \nwhich of its transitions to use. More for\u00admally, consider the form of the second condition in the definition \nof input-enabled bisimulation. VE E&#38;3Q EP, V ~V, and s S such that Q VA ~ and P [E/V]@. R Q [E/V \n]@S The universal quantification over values is done before the existential quantification over transitions. \nHence, this condition haa the form #E 3P. C. If one alters the definition of equivalence by reversing \nthe univeral and existential quantifications above, then one obtains late bisimulation equivalence. Definition \n!5.-4 A relation R ~ (P x P) is a late input\u00adsensitive bisirnulation ii whenever PR Q then the fol\u00adlowing \nhold. 1. If P ~ P , then there is aQ such that Q L Q and P 1? Q1, and symmetrically for Q. 2. If P ~ \nP then there areQ GP,V 6 V ands)GSsuchthatQ * Q and dEG &#38; P [E/V]@s R Q [E/V ]@S , and symmetrically \nfor Q. P =1 Q if there is a late input-sensitive bisimulation R such that PRQ. This equivalence has usually \nbeen presented in the liter\u00adature by giving different the operational rules together with the definition \nof bisimulation [17, 19]. In our set\u00adting, the definition is obtained solely by swapping quan\u00adtifiers, \nas is also done in [23] for the II-calculus. One immediate advantage of this formulation is that the \nfact that late equivalence implies early equivalence is a con\u00adsequence of a well-known property of quantifiers \nin first order logic. Lemma 5.5 Let P, Q ~ P. Then, P z! Q implies that P?Q. Proof. The lemma is implied \nby the property IPVE. C ~ VE3P. C. 0 The following example shows that in general, early equivalence does \nnot imply late equivalence. Assume that S includes the set of integers aa well aa the opera\u00adtions Inl \n(absolute value) and n! (factorial). Example 5.6 Assume P and Q are dejined as follows. P = aV.((V ~ \n0).j(V!).nii+ (V < 0).~V.nil) + CYV.((V < 0)./7( (-V)! ).ni(+ (V ~ O).~V. nil) Q= crV.~([V[!). nii+ c2V.~V. \nnil Then PzQbutP#l Q. 6 A Semantics for Asynchronous Com\u00admunication The semantics given above requires \nthat processes wish\u00ading to communicate must do so synchronously-senders must block until a receiver is \nready. Such a communi\u00adcation scheme is standard in process algebras, as one can model other disciplines \nusing synchronous commu\u00adnication. However, other programming notations pro\u00advide asynchronous communication \nprimitives in which senders need not block; examples include Linda [14], Linear Objects [2], Alice [28], \nGamma [5], concurrent logic languages [26], and concurrent constraint lan\u00adguages [25]. Moreover, other \nlanguages, such ss CRP [9], provide synchronous primitives but implement them over an asynchronous model; \nreasoning about these im\u00adplementations would require a semantics with asyn\u00adchrony represented explicitly. \nIn this section we show how the semantic framework developed above may be altered to cater for different \nforms of asynchronous com\u00admunication, and we study the incorporation of explicit rout ed substitutions \nin our language aa a means of ac\u00ad counting for communication costs. 6.1 Asynchronous CCS with Values \n Other semantic approaches to asynchronous message passing typically include buffers for storing messages \nthat have been sent but not received. When a sender wishes to send, it deposits its message into the \nbuffer and continues with its execution. A receiver first ex\u00adamines the buffer, retrieving a value if \none exists and blocking otherwise. In order to accommodate asynchronous communication in CCS-VP, we add \na buflen ng operator D; intuitively, izE D P represents a process that haa deposited a mes\u00adsage containing \nvalue E and destination port a in its output buffer . Formally, the syntax of ACCS-VP is given ss follows. \nP ::= nil [crV.P [iIE.P IP+P IPIP I P\\ L] P[fl\\z] recz. P[7iEDP As before, we assume that all recursive \ndefinitions are guarded. We use PA, ranged over by P, Q,.. ., to denote the set of syntactically correct \nterms. To define the operational semantics of ACCS-VP we first extend the definitions of substitution \nand routed substitution in the obvious fashion as follows. (&#38;E D P)[R/~ = EE D (P[E/Vl)  (EE ~ \nP)[E/V@s = iYE ~ (P[E/V]@S)  Our asynchronous operational semantics is given in terms of the relation \n+ introduced in Figure 3, Most of the operations inherited from CCS-VP behave aa they did before, and \nhence the rules do not change. The core of the new semantics lies in (prefout ); this rule in\u00adformally \nsays that an output prefixing zE.P does not communicate directly with other processes, but instead buffers \nits message. Notice that inserting a message in The rules from Figure 2, except (prefout). EE.P ~ EE \nD P (prefout ) EEbP~P (buffl) P~P ~ EEDP~iYEDP (butE?) Figure 3: Transition the buffer is seen as an \ninternal, unobservable operation, and thus the transition is labeled by a r. The rules for EE D P allow \nthis process either to execute its output action (Rule (bufl 1)) or perform an action available to P \n(Rule (buff2)). As an example, consider the following term. P -(EE1.~Ez.nillaV.ni~\\{~} By applying the \nrules, we deduce the following se\u00adquences of transitions for P. Our buffering operator should be compared \nwith the state operator of [12]. While both constructs are used to give a semantics to asynchronous communication, \nthey differ in that the state operator has as an argument a data structure that contains the values that \nhave been sent but not yet received. By varying the form of this data structure, one obtains different \nqueuing disciplines for message delivery. As will be shown in the next sec\u00adtion, we may obtain some of \nthe same flexibility, with lower syntactic overhead, by varying the operational rules governing D. 6.2 \nBuffering Policies Schemes for asynchronous communication typically dif\u00adfer in terms of their delivery \nscheme (i.e. is communi\u00adcation point-t~point or broadcast-based?) and h@er\u00ading policy (i.e. are messages \ndelivered in FIFO order?). While the former issue is beyond the scope of this pa\u00adper, this section shows \nhow the operational semantics given in the previous section may be altered to model different approaches \nto buffering. Rules for Asynchrony The rules for -given in Figure 3 in essence define a communication \nframework in which delivery is point\u00adto-point (Rules (comml ) and (commr )) and the buffer\u00ading policy \ndefines the communication medium to be a bag each process has an unordered, unbounded buffer of messages. \nThis behavior follows from Rule (butT2): using it, we may conclude, for instance, that process ZIE D \n~E1 b P is capable of engaging in transitions la\u00adbeled by ~E as well as by izE. This communication mechanism \nis used in one form or another in many co\u00adordination or programming languages (see for instance Linda, \nAlice, Linear Objects and Gamma). Other no\u00adtations (e.g. Estelle [11], UNIX sockets), however, pro\u00advide \nFIFO or Quasi-FIFO (i.e. buffers that are FIFO for messages on each channel) communication schemes, and \nto model these in an implementation-independent manner we would like to have the policy be built into \nthe operational semantics. It turns out that our seman\u00ad tics can be changed to support Quasi-FIFO or \nFIFO communication by adding different side conditions to Rule (buff2). Definition 6.1 The rules for \nQuasi-FIFO ACCS-VP are obtained by replacing the rule (bu@ ) by the rule P~P , a#EE * ZZEb P~i3Eb P \nThis alteration to the semantics ensures that in process ZE b Z2E1 b P, the action EE must be executed \nbefore the ?iE~ is possible. Definition 6.2 The rules for FIFO ACCS-VP are ob\u00adtained by replacing the \nrule (buff2) by the rule P~P ,V@GA.a#~E aEEb P~EEb P This change stipulates that in process EE D BE \nb P, action ZEE occurs before ~E1 (but a 7V@ action of P can be arbitrarily interleaved with them). \n6.3 Explicit Routed Substitutions In our semantics, routed substitution has played a role analogous to \nthe one played by substitution in the A\u00adcalculus. In computational terms, this operation, like substitution \nin the A-calculus, can be expensive to im\u00adplement, and leaving it as a single operation in a se\u00admantics \nprecludes the study of the relative efficiency of different system implementations. A small example serves \nto illustrate this point. Consider a system of the form P[(QIR); if we interpret [ as a communication \ndevice for linking together two systems, then we may think of this system as a tree-structured network \ncon\u00adsisting a five processors: P, Q, R, a communication processor connecting Q and R, and another commu\u00adnication \nprocessor linking this processor to P. Under this informal interpretation, communication among P, Q and \nR must flow through the relevant communication processors. Now suppose we have that P ~ PI while Q ~ \nQ ; We want to consider how E will be delivered to ~. In general, two hops would be required: one in \nwhich the (root communication processor channels E from P to the communication processor connecting Q \nand R, and one in which the second communication processor directs E to Q. On the other hand, (PIQ)IR \nrequires only one such hop to effect the transfer of the same value from P to Q. If this communication \nhap\u00adpens frequently, then, we might, for reasons of efficiency, prefer the second system configuration \nto the first, since in a certain sense P and Q are closer in the second system than in the first. However, \nour current semantic account for ACCS-VP does not permit us to distinguish these systems, as (with respect \nto the equivalence =) I may be shown to be associative. In the case of substitution and the J-calculus, \nthis short\u00adcoming of the traditional j?-reduction semantics has been addressed by including explicit \nsubstitutions [1] in the syntax of terms. Explicit substitutions may be thought of as syntactic renderings \nof closures; the op\u00aderational semantics of a language with explicit substi\u00adtutions in essence encodes \nreduction rules correspond\u00ading to the different cases in the inductive definition of substitution. Thus, \non the basis of the length of a re\u00adduction sequence one can obtain information about the cost of reducing \none term to another. In this section, we consider a similar modification to ACCS-VP by in\u00adtroducing explicit \nrouted substitutions into the language and including operational rules defining r transitions for terms \ninvolving routed substitutions. As will be seen, processes that are farther apart in a term will in general \nrequire more r-transitions to communicate than those closer together; this operational semantics may \nbe then used with a semantic preorder that is sen\u00adsitive to the number of r actions performed (see, e.g, \n[3]) to relate systems on the basis of their relative eficiency. Formally, we alter the syntax of ACCS-VP \nto include explicit routed substitutions as follows. Let s be a pro\u00adcess address. P ::= nil [cxV.P IEE.P \n]P+P [PIP [ P\\LIP[fl [zlrecz. P173EDP I P{ E/V}@S As before, we consider only guarded terms. The new \nset of processes is denoted by Te, which will be ranged over by P, Q, .... To define the semantics of \nthe altered language we first introduce rules for resolving explicit substitutions; these appear in Figure \n4. The reader should note the simi\u00adlarity between the transitions defined for terms with routed substitutions \nand definition of routed substitu\u00adtion given in Definition 4.1. We also classify the rules as normal \nrules, which drive a substitution to the place where it has to be applied, and exception rules, which \ndeal with processes containing substitutions with addresses that would not arise during the execution \nof a normal system. The complete semantics consists of the rules of Figure 4 and the ones of Figure 3 \nexcept for (comml ) and (commr ), which are replaced by the following. P =P ,Q=Q + PIQ ~ (P { E/V}@s)lQ \n(comml ) P~P ,Qa~~ ~ P[Q ~ P l(Q{E/V@) (commr ) The following property shows that the rules of Figure \n4 actually define a function. Property 6.3 The set of rules of Figure ~ is deter\u00administic: if P{ E/V}@S \nE Pe then there is at most one P GP. such that P L P . We now show that the rules for explicit substitution \nare consistent with the definition of routed substitu\u00adtion. Let P ~ P if there is a sequence of r-labeled \ntransitions from P to P , and P H* P if there is a sequence of any transitions from P to P . Theorem \n6.4 Let P EPA, V EV, E G&#38; and s~S. Then P{ E/V}@s ~ P[E/Vl@S. Proof. By structural induction on the \ndefinition of P[E/~@.. For each equation irl the definition of the form P[E/V@S = Q we have a rule P{ \nE/V}@s L Q in Figure 4 and vice versa. 0 The next result establishes that during normal opera\u00adtion , \nthe Exception rules are never used. Lemma 6.5 Let P E PA and Q E P. be.nd that p -* Q. Then there exists \nP c PA such that Q ~ P can be proved without using Exception rules. Normal Rules   P{E/v}@@ (PIQ){E/V}@sl \n(PIQ){E/V}@sr (P\\L){E/V}@. (P[fl){E/V}@s (IZE ~ P){E/V}@s Exception Rules nii{E/V}@s (a.P){E/V}@s ((7).P){E/v}@8 \n(P+ Q){E/V}@S rec z. P{ E/V}@s L P[E/Vl &#38; (P{ E/V}@S)lQ ~ P[(Q{E/V)@s) A (P{ E/v}@s)\\L A (P{ E/v}@s)[fl \nL ZYE ~(P{E/V}@s) IL nil &#38; a.P A (m).P ~ P+Q J+ recx. P if8#* ifs#o ifs#e ifs#e ifs+e ifs+. ifs+. \nifs+. Figure 4: Operational Rules for Routed Substitutions. Proof. The proof has two parts. on the length \nof ~* it is easy to cess addresses in Q always refer to desired result follows by structural To illustrate \nthis theorem, consider given by First, by induction show that the pro\u00adsubterms of Q. The induction on \nQ. O the term PI G PA PI s (csV.nil I~E .nil) IZiE.nil. The following sequence of ~-transitions, each \ndeducible using the Normal rules, is the one guaranteed by the theorem. PI ~ (ni/1 ~E .niJ)[E/V@ol I \nnil A (ni[E/Vl@. l~E .nil) I nil &#38; (ni~E/Vl l~E .ni~ I nii= (niil~E .nil)  By way of contrast, the \nlast step in the sequence of transitions for Pz S (aV.ni~~E.ni~[E /V ] @c(l requires the use of an Exception \nrule. Pz &#38; ((~ V.ni~E /V ]@.[) l~E.nio ~ (ctV.ni@E.ni~ Discussion We close this subsection by remarking \non two issues that our treatment of explicit routed substitutions has not addressed. The first concerns \naccounting for output coats. Suppose that in a term of the form (( PIQ)IR)IS, both P and R wish to perform \nan output ZE and S is willing to engage in cxV@o. Then our semantics would conclude that the communication \ncosts for the two mes\u00adsage deliveries would be the same: in both cases a se\u00adquence of two r-transitions \nwould be required to com\u00adplete the transfer from P/R to S, even though in some sense R is (closer to \nS than P. One approach to ac\u00adcounting more accurately for output costs would be to associate addresses \nto output actions as well as input ac\u00adtions. Then the semantics of communication could be changed to \nintroduce r s to model the hops needed for an output action to reach the point at which it syn\u00adchronizes \nwith an input action to yield an explicit sub\u00ad stitution. The second concerns plicit substitutions in \na process to which a til (one step of) the the fact that the semantics of ex\u00adessence suspends the execution \nof substitution is being applied un\u00adsubstitution is resolved. That is, the operational definition does \nnot include a rule of the form P &#38;P ~ P{ E/V}@s &#38; P {E/V}@s. In general, introducing such a \nrule into our semantics would lead to problems with free variables; for example, in (=. Pl(QIR)){E/V)@*l, \n the process inside the substitution is capable of a Z transition; however, this transition should not \nbe al\u00adlowed until the substitution of E for V is performed. On the other hand, not having the above rule \ncan limit the degree of concurrency exhibited by a system. Consider a process of the form (P I(Q IR)){ \nE/ V}@Ol; process P is awaiting the delivery of E, which will then be substi\u00adtuted for its free occurrences \nof V. The only transition available to this system involves the resolution of the substitution as follows. \n(Pl(QIR)){E/V}@Ol L P{ E/V}@ol(QIR) Note that even if Q and R wish to communicate, they are unable to \ndo so until the above transition takes place, even though the substitution will not affect the communication \nthey wish to engage in. With a rule such as the one above, Q and R would be allowed to engage in their \nsynchronization without having to wait for the resolution of the substitution. One approach to addressing \nthese issues would involve the introduction of an explicit suspension operator into the language. A process \nwould be suspended when it executes an input transition, and a suspended process would be incapable of \ncertain transitions (e.g. output transitions in which the value expression contains a free variable) \nuntil a routed substitution is applied to it. With this notion of suspension made explicit, one would \nthen be able to add the above rule to our operational semantics without disturbing the treatment of free \nvariables. Conclusions In this paper we have presented an alternative seman\u00adtics for a concurrent language \nwith value passing. In\u00adspired by the operational considerations that are evi\u00addent in the reduction-style \nsemantics given to the ~\u00adcalculus, this semantics attempts more faithfully to re\u00adflect abstractly the \noperations concerns associated with the exchange of values between processes distributed in space. Accordingly, \na notion of routed substitution is defined and used to model the synchronous transfer of values between \nprocesses. A notion of operational equivalence is also defined and shown to coincide with the well-known \nbisimulation equivalence of CCS. Thus the new semantics maintains consistency with the tradi\u00adtional semantics \ngiven to value-passing languages while providing more information about how data is passed between processes. \nWe then show how the semantics may be altered smoothly to support different forms of asynchronous communication \nand to provide more in\u00adformation regarding the cost associated with transfer\u00adring data between processes. \nThere are a number of directions in which this work can be extended. In this paper we only consider bi\u00adnary \ncommunication schemes. One could also alter the framework slightly to support multi-party communica\u00adtion; \none way to do so would involve the introduction of an additional indicator in the syntax of addresses \nto signal that a data value should be routed to both sub\u00adterms in a parallel composition. Developing \nan axiom\u00adatization for the equivalence proposed in Section 4 for CCS-VP and ACCS-VP would also yield \nan interesting method for establishing that processes are equivalent. In the context of explicit routed \nsubstitutions, it would also be worthwhile to examine notations for describing non-tree structured networks. \nAs the parallel comp\u00adosition operator in ACCS-VP is binary, it only permits the description of networks \norganized as binary trees. Developing a syntax for expressing more complicated graphical structures (e.g. \nrings, hypercubea) would pro\u00advide a basis for investigating the relative efficiency of different architectures \nfor different problems. Finally, it would also be interesting to extend the lan\u00adguage in this paper \nby considering different types of val\u00adues and permitting data variables to have types ascribed to them. \nOne could alter the reduction semanti~ for value-passing by introducing a sensitivity to type: input \nactions could be labeled by the type of the variable they bind, and a reduction would take place only \nif the type of the output expression matches that of the variable. In this way one could obtain a (first-order) \ntyped re\u00adduction system for concurrent processes. Several inter\u00adesting directions for further inquiry \nwould then present themselves. One would be to investigate the develop\u00adment of a higher-order typed language \nfor processes. Another would be the extraction of pure (finite-state) process algebra terms from typed \nterms that would re-, tain some of the behavioral properties of the original (infinite-state) terms. \nFor example, one could imagine taking a term of the form OV : Int .P and generating a term of the form \naI~~.Z (P), where Z (P) is the type for P. To the extent that such a procedure would yield a term reflecting \nat an abstract level the behavior and types of passed values of the original term, useful be\u00adhavioral \ninformation could be automatically computed for concurrent programs. Related Work Traditionally, researchers \nin process algebra have de\u00adfined the semantics of value-passing by reducing it to pure synchronization \nin the fashion described in Section 3 [20, 22, 27]. One approach to avoiding the attendant infinite number \nof transitions that this entails can be found in [16, 17]. There the semantics dictates that processes \nsuch as CYX.P may engage in the single tran\u00ad sition crX.P az P; when processes synchronize, then, data \ntransfer is handled via substitution in the usual sense. The approach is similar to ours, although it \ndif\u00adfers in that unnecessary substitutions can be performed, with an attendant need to rename bound variablea \non occasion. For example, consider the term CYX.PIBX.Q; note that X is free in the right-hand processes. \nIf this system is allowed to engage in the transition aX.P[~X.Q a~ PIPX.Q then X is now free in both \nthe left-hand and right-hand sides. However, since their semantics requirea that a value arriving to \nthis term as the result of a synchr\u00adonization on a be substituted X into both processes, the free occurrence \nof X in the right-hand side pro\u00adcess would incorrectly be replaced. To ensure this does not happen, the \nX in the left-hand procees must be re\u00adnamed. In contrast, our semantics would not require the renaming \nof X in here, because the routing opera\u00adtion would ensure that substitution is only performed for occurrences \nof X on the left. The Chemical Abstract Machine (ChAM) [8] represents another approach to defining the \noperational semantics of concurrent systems. The ChAM conceives of sys\u00adtems of processes as solutions \n, with individual pro\u00adcesses representing molecules that may collide to form larger processes with parallel \ncomponents which may then interact and break apart. By design, this frame work abstracts away from any \nunderlying system g~ ometry, and hence it is likely to be unsuitable for the implementation-level, efficiency-based \nanalyses that our framework, via explicit routed substitutions, can sup\u00adport. Acknowledgements. The first \nauthor would like to thank Bard Bloom and S. Purushothaman Iyer for their insightful comments on an earlier \nversion of this paper. References [1] M. Abadi, L. Cardelli, P.-L. Curien, and J.-J. L&#38;y. Explicit \nsubstitutions. In Eighteenth Annual ACM Symposium on Principles of Programming Lan\u00adguages, pages 31 46, \nSan Francisco, January 1990. Computer Society Press. [2] J.-M. Andreoli and R. Pareschi. Linear objects: \nlogical processes with built-in inheritance. In Pro\u00adceedings 00PSLA 91, pagea 1 20. ACM Press, 1991$ \n[3] S. Arun-Kumar and M. Hennessy. An efficiency preorder for processes. Technical Report 5/90, Computer \nScience, University of Sussex, Brighton, 1990. [4] J. Baetan and W. Weijland. Process Algebra, vol\u00adume \n18 of Cambridge Tracts in Theoretical Com\u00adputer Science. Cambridge University Press, Cam\u00adbridge, 1990. \n[5] J. P. Banatre and D. L. Metayer. Introduction to Gamma. In Research Directions in High-Level Par\u00adallel \nProgramming Languages, volume 574 of Lec\u00adture Notes in Computer Science, pages 197-202. Springer-Verlag, \n1991. [6] H. Barendregt, The Lambda Calculus, volume 103 of Studies in Logic and the Foundations of Mathe\u00admatics. \nNorth-Holland, Amsterdam, 1984. [7] J. Bergstra and J. Klop, Algebra of communicating processes with \nabstraction. Theoretical Computer Science, 37:77-121, 1985. [8] G. Berry and G. Boudol. The chemical \nabstract machine, Theoretical Computer Science, 96:217\u00ad248, 1992. [9] G. Berry, S. R.amesh, and R. K. \nShyamasundar. Communicating reactive processes. In Twentieth Annual ACM Symposium on Principles of Pro\u00adgramming \nLanguages, pages 85 98. Computer So\u00adciety Press, January 1993. [10] S. Brookes, C. Hoare, and A. Roscoe. \nA theory of communicating sequential processes. Journal of the Association for Computing Machiney, 31(3):560\u00ad599, \nJuly 1984. [11] S. Budkowski and P. Dembinski. An introduction to Estelle: A specification language for \ndistributed systems. Computer Networks and ISDN Systems, (14):3-23, 198 7. [12] F. de Boer, J, Klop, \nand C. Palamideaai. Asyn\u00adchronous communication in process algebra. In Seventh Annual IEEE Symposium \non Logic in Computer Science, pagea 137-147, Santa Cruz, CA, June 1991. Computer Society Press. [13] \nR. De Nicola and M. Hennessy. Testing equiva\u00adlences for processes. Theoretical Computer Science, 34:83-133, \n1983. [14] D. Gelernter. Generative communication in Linda. ACM Tkans. on Programming Languages and Sys\u00adtems, \n7(1):80-112, 1985. [15] M. Hennessy. Aigebraic Theory of Processes. MIT Press, Boston, 1988. [16] M. \nHennessy and H. Lin. Proof theories for sym\u00adbolic bisimulation. Technical report, Sussex Uni\u00adversity, \nforthcoming 1992. [17] M. Hennessy and H. Lin. Symbolic bisimulations. Technical Report 1/92, Sussex \nUniversity, 1992. [18] C. Hoare. Communicating Sequential Processes. Prentice-Hall, London, 1985. [19] \nA. Ing61fsd6ttir and B. Thomaen. Semantic models for ccs with values. In Proc. of Chalmers Workshop on \nConcurrency, Baastad, Sweden, May 1991. [20] R. Milner. A Calculus of Communicating Systems, volume 92 \nof Lecture Notes in Computer Science. Springer-Verlag, Berlin, 1980. [21] R. Milner. Calculi for synchrony \nand asynchrony. Theoretical Computer Science, 25:267-310,1983. [22] R. Milner. A Calculus of Communicating \nSystems. Prentic~Hall, London, 1989. [23] R. Milner, J. Parrow, and D. Walker. A calculus of mobile processes, \nPart I + II. Information and Conirol, 100(1):1-77, 1992. [24] U. Montanari and D. Yankelevich, A parametric \napproach to localities. In Proceedings 19$h ICALP, Vienna, volume 623 of Lecture Notes in Computer Science, \npages 617-628. Springer-Verlag, 1992. [25] V. Saraswat. Concurrent Constraint Programming Languages. \nPhD thesis, Carnegi&#38;Mellon Univer\u00adsity, 1989. Also in ACM Distinguished Dissertation Series. [26] \nE. Shapiro. The family of concurrent logic pro\u00adgramming languages. ACM Computing Surveys, 3(21):412-510, \n1989. [27] B. Thomsen. A calculus of higher-order commu\u00adnicating systems. In Sixteenth Annual ACM Sym\u00adposium \non Prt nciples of Programming Languages, pages 143 154, Austin, Texas, January 1989. Com\u00adputer Society \nPress. [28] R. Tolksdorf. Alice: Basic model and subtyping agents. Technical Report 1993/7, Graduiertenkol\u00adleg \nkommunikationsbasierte Systeme, TU Berlin, Berlin, Germany., 1993. [29] D. Walker. Bisimulation and divergence \nin CCS. In Third Annual Symposium on Logic in Computer Science, pages 186-192, Edinburgh, July 1988. \nComputer Society Press. \n\t\t\t", "proc_id": "174675", "abstract": "<p>This paper develops a semantic framework for concurrent languages with value passing. An operation analogous to substitution in the &#955;-calculus is given, and a semantics is given for a value-passing version of Milner's Calculus of Communicating Systems (CCS). An operational equivalence is then defined and shown to coincide with Milner's (early) bisimulation equivalence. We also show how semantics maybe given for languages with asynchronous communication primitives. In contrast with existing approaches to value passing, this semantics does not reduce data exchange to pure synchronization over (potentially infinite) families of ports indexed by data, and it avoids variable renamings that are not local to processes engaged in communication.</p>", "authors": [{"name": "Rance Cleaveland", "author_profile_id": "81100078111", "affiliation": "Department of Computer Science, North Carolina State University, Raleigh, NC", "person_id": "PP39026126", "email_address": "", "orcid_id": ""}, {"name": "Daniel Yankelevich", "author_profile_id": "81100584120", "affiliation": "Department of Computer Science, North Carolina State University, Raleigh, NC", "person_id": "P59549", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/174675.177941", "year": "1994", "article_id": "177941", "conference": "POPL", "title": "An operational framework for value-passing processes", "url": "http://dl.acm.org/citation.cfm?id=177941"}