{"article_publication_date": "02-01-1994", "fulltext": "\n A Generic Account of Continuation-Passing Styles * John Hat cliff Department of Computing and Information \nKansas State University t hat cliff(lcis.ksu.edu Abstract We unify previous work on the continuation-passing \nstyle (CPS) transformations in a generic framework based on Moggi s computational met a-language. This \nframework is used to obtain GPS transformations for a variety of evalua\u00ad tion strategies and to characterize \nthe corresponding admini\u00ad strative reductions and inverse transformations. We estab\u00ad lish generic formal \nconnections between operational seman\u00ad tics and equational theories. Formal properties of transfor\u00ad mations \nfor specific evaluation orders follow as corollaries. Essentially, we factor transformations through \nMoggi s computational meta-language. Mapping A-terms into the met a-language captures computational properties \n(e.g., par\u00ad tiality, strictness) and evaluation order explicitly in both the term and the type structure \nof the meta-language. The CPS transformation is then obtained by applying a generic trans\u00ad formation \nfrom terms and types in the meta-language to CPS terms and types, based on a typed term representation \nof the continuation monad. We prove an adequacy property for the generic transformation and establish \nan equational correspondence between the meta-language and CPS terms. These generic results generalize \nPlotkin s seminal theo\u00ad rems, subsume more recent results, and enable new uses of CPS transformations \nand their inverses. We discuss how to apply these results to compilation. Introduction There is a variety \nof continuation-passing styles one for each evaluation order (call-by-name, etc. ) and for each se\u00ad \nquencing order (left-to-right, etc.). In each style, contin\u00ad uations get passed from function to function \n resulting in a strikingly similar structure for all styles. However, in the literature, the formal \nproperties of each style are es\u00ad tablished independently. For example, in his seminal paper Catl-by-name, \ncall-by-value, and the A-calculus [32], Plotkin first presents call-by-value continuation-passing style \n(CPS) along with a set of correctness proofs and then he presents call-by-name CPS along with another \nset of correctness proofs. Both styles have similar structure but they are not identical. Their correctness \nproofs are also structurally sim\u00ad ilar but they are not identical We propose to exploit these This work \nwas partly supported by NSF under grant CCR\u00ad 9102625. Manhattan, Kansas 66506, USA tN ~ Munkegade, 8000 \nAarhus C, Denmark This work was initiated at Kansas State University, continued at Carnegie Mellon University \nin spring 1993, and completed at Aarhus University, Pem ssion to copy without fee all or part of this \nmaterial is granted providad that tha copies era not msde or distributed for direct commercial advantage. \nthe ACM copyright notica and tha title of the publication and its data appear, and notica is Oiven that \ncopying is by permission of the Association for Computing Machinery. To copy otherwise, or to republish, \nrequiras a fea endor apecifio permission. POPL 94-1194, Portland Oregon, USA @ 1994 ACM O-89791 -rHWh94fOOl..$3.5O \n Olivier Danvy Sciences Department of Computer Science Aarhus University $ danvyOdaimi.aau .dk similarities \nto factor the CPS transformations and their cor\u00adrectness proofs. It appears that many CPS transformations \nare built from common building blocks. We represent these building blocks abstractly by constructs of \nMoggi)s computational meta\u00adlanguage (which we refer to as A~L ) [26].1 By formally connecting the language \nof abstract building blocks and the language of CPS terms, we obtain a generic framework for constructing \nCPS transformations and for reasoning about CPS terms as opposed to dealing with each transforma\u00adtion \nindividually. To connect the (operational) semantics of the two languages, we show an adequacy property \nfor a generic transformation C from A~L to CPS terms. To con\u00adnect equational theories, we show that the \ntransformation C (continuation introduction), along with its inverse C-l (continuation elimination), \nestablishes an equational corre\u00adspondence between A~L and CPS terms. The diagram of Figure 1 summarizes \nthe situation. The result is that, given a correct encoding into AA, the construction and correctness \nof the corresponding CPS transformation follow as corollaries. Establishing a correct encoding into Aml \nis much simpler than working directly with CPS terms. This approach generalizes Plotkin s construction \nand correctness proofs for his call-by-value and call-by-name CPS transformations [32]. It also generalizes \nsimilar re\u00adsults for Reynolds s cal-by-value CPS transformation [34], and more recently for CPS transformations \ncapturing mixed evaluation orders based on strictness and totality informa\u00adtion [3, 8, 9]. Practical \nuse of CPS transformations requires one to characterize administrative reductions [7, 32, 36]. Again, \nadministrative reductions are usually characterized for each CPS transformation individually. For example, \nPlotkin gives a colon-translation that performs administrative re\u00adductions for call-by-value CPS and \nthen another colon\u00adtranslation that performs administrative reductions for caU\u00adby-name CPS. In contrast, \na certain subset of A~z reduc\u00adtions generically characterizes the administrative reductions on CPS terms. \nFor each CPS transformation, a corresponding direct\u00adstyle (DS) transformation exists that maps CPS terms \nand types to direct-style terms and types. DS transformations have stirred interest recently [6, 10, \n13, 36]. However, just like the CPS transformations, they have been studied in\u00addividually. In cent rast, \nthe continuation elimination C l serves as the core of a generic D S transformation. Finally, in situations \nwhere explicit continuations are not needed (e. g., for compiling programs without jumps), flA stands \nas an alternative language to CPS very close to GPS but without continuations. 1 Note that M~ggi>s computational \nmeta-language [26] 1s a different language than Moggi s computational J-calculus Xc [23, 24]. Reynolds \ns C13V CBN CBV -* + { * * c ~ l CBV + strictness i info \\ Evaluation Orders CPS Figure 1: Factoring transformations \nthrough the computational meta-language In Moggi s work, A*1 (without recursive functions) is given \na categoriczd semantics. The interpretation can be parameterized with categorical structures called monads \nthat abstractly capture various notions of computation. In essence, we point out that by giving a term \nrepresentation of the continuation monad, A~~ forms the basis of an el\u00adegant framework capturing the \nconstruction, correct ness, equational properties, and optimizations of CPS and DS transformations for \na variety of evaluation orders. Because the meta-language is typed, our development also gives a generic \naccount of the typing of CPS transformations. Sec\u00adtion 9 relates the present work to other recent applications \nof Moggi s framework [36, 41, 42]. The rest of the paper is organized as follows. Section 2 addresses \nthe representation of computational properties of Lterms with A~t terms. We consider in detail the standard \ncall-by-name and call-by-value reduction strategies. Sec\u00adtion 3 describes the mappings between Aml terms \nand CPS terms. Section 4 illustrates the framework with a variety of CPS transformations. Section 5 formalizes \nadministrative reductions. Section 6 addresses DS transformations. Sec\u00adtion 7 describes how data structures \nare dealt within the framework. Section 8 applies the framework to compilation, Section 9 addresses related \nwork. Section 10 concludes. 2 Representing Computational Properties of A-terms 2.1 The language A of \ntyped A-terms 2.1.1 Syntax and notation Figure 2 presents the syntax of the language A simply\u00adtyped \nA-terms with recursive functions. 2 Throughout the paper, type annotations are omitted when no ambiguity \nre\u00adsults. In such cases, the terms are assumed to be type cor\u00adrect. The same met a-variables (r for type \nassumptions, r for types, e for terms) are used in different languages. Ambigu\u00adity is avoided by giving \na different subscript for the typing judgement symbol 1-in each language. We use the meta\u00advariable $ \nto distinguish identifiers of recursive functions, For other identifiers (and where no distinction is \nnecessary) we use the meta-variable x. To simplify substitution, we follow Barendregt s variable convention \nand consider the quotient of A under a-equivalence [2]. We write el ~ e2 for a-equivalent terms el and \nez. The notation F V(e) denotes 2 We follow Tennent s presentation of abstract syntax bssed cm derivability \ny of sequents of the form 17 h e : r [40]. 3 In terms occurring in definitions and proofs etc., all bound \nvari\u00adables are chosen to be different from free variables [2, page 26]. the set of free variables in \ne and el [z := ez] denotes the re\u00adsult of the capture-free substitution of all free occurrences of x \nin el by ez. Closed terms of base type are called programs. 2.1.2 Values and computations Certain terms \nof A are designated as values. Intuitively, values correspond to terms that are irreducible according \nto the operational semantics for A given below. The sets Value% [A] and Value% [A] represent the set \nof values from the language A under call-by-name and call-by-value reduc\u00adtion respectively. Vaiue%[A] \n::= c I ~z. e I rec~(z). e I ~ Vaiue%[A] ::= c [ )z. e I r-ecf(z). e [ z Note that all identifiers are \nincluded in Vaiue% [A] since only values are substituted for identifiers under call-by-value re\u00adduction. \nOnly identifiers f for recursive functions are in\u00adcluded in Value% [A] (based on the reductions for rec \nin the following section), since arbitrary terms are substituted for identifiers in general. We use v \nto represent values and, where no ambiguity results, we ignore the distinction be\u00adtween call-by-name \nand call-by-value values. C omputatioras are non-values terms requiring addi\u00adtional computational steps \nbefore their meaning can be de\u00adtermined. Not all computations reduce to values due to the possibility \nof non-termination introduced by recursive func\u00adtions. 2.1.3 Operational semantics and equational reasoning \nThe rules of Figure 3 define single-step reduction functions over A programs. The meaning functions evak \nand evak are defined in terms of the reflexive, transitive closure (denoted **) of the single-step reduction \nfunctions. ermh(e) = v ifl e M: v evaL(e) = v ifl e +; v For reasoning about the meaning of A programs, \nwe consider calculi generated by the usual reductions @, &#38;, q, [2] as well as the reductions rec \nand ret, defined below. (ret f(z). eo) el ~rec eo[f := reef(z).eo , z := e]] (r-ec f(z). e) v are. e[f \n:= reef(z). e, z := ~] For a notion of reduction r, ---+ also denotes compatible one-step reduction, \n---+, is the reflexive, transitive closure of +,, and =, is the smallest by -4, [2]. The calculus (i.e., \nthe relation =&#38;) is I EC:L r~z:r(~) r,z:~ll-e: 7-2 rl-Ax. e:n+r2 r, r T .. .. r ::=  f:71+~2, z:71Ee:72 \n1-~ecf(x). e : T1.+T2 rt-eo:t-1+~2 171\u00ad eoel:rz rl-el:rl L I 7-1-+?-2 . I r,3:T Figure 2: Abstract syntax \nof A, the language of simply-typed X-terms Cdl-by-name: (Ax .eo)el I--+ eo[x := el] (r-cc f(x). eo) e, \n-n eo[f := reef(x).eo , x := el] eo eo el +-+n +-+ e~ , e. el Cdl-by-value: (Ax. e)v +-+. e[x := v] \n grams under call-by-name ated byR, = Figure 3: Single-step equivalence relation generated generated \nby R. = {~, q., rec}4 sound for reasoning about pro\u00ad evaluation.5 The calculus gener\u00ad {8v, %, recv } \nis sound for reasoning about programs under call-by-value evaluation. When a property P holds for both \n,8 and /3v, indifferently, we say that p holds for ,&#38; (similarly for reci, Rz, and eva4 ). 2.2 The \ncomputational meta-language A~i 2.2.1 Syntax and notation Figure 4 presents the syntax of the language \nA~t based on Moggi s computational rneta-kmguage [26]. The key feature of the language is that its typing \nsystem captures the dis\u00adtinction between computations and values (or, in Reynolds s terminology, serious \nterms and trivial terms [33]) which has often been used to justify the structure of CPS programs in\u00adtuitively \n[32, 33]. Types of the form L and ~1 ~ 7-z are called value types. Accordingly, the rules for constants \nand ab\u00adstractions are among the introduction rules for value types. Types of the form ; are called computation \ntypes. The monadic constructs are used to make the compu\u00adt ational process explicit. Intuitively, [e] \nsimply returns the value of e while let x + e] in e2 first evaluates el and binds the result to z, and \nthen evaluates 4 The reason for considering only w Section 3. 5 Soundness of calculi is formalized of \noperational equ$valerace [32] which situations throughout the paper. ez. instead of rI IS explained m \nvia a standard presentation we omit here and in similar 6 For the explicit connection to the structure \nof a monad see [26, page 61]. (r-cc f(x). e) v +--+V e[f := rec f(x). e, x := v] e~ b--+ ej (r-cc f(x). \neo) el w, (ret f(x). eo) e{ reductions for A programs 2.2.2 Operational semantics and equational reasoning \nFigure 5 presents the set of reductions Rml for the com\u00adputational meta-language A~~. Note that when \na A~i\u00adabstraction parameter is of value type, ,Bmr corresponds to /l, A~l typing ensures that only values \nwill be substituted for the parameter. When an AA abstraction parameter is of computation type, both \nvalues (coerced to trivial com\u00adputations by [.]) and computations may be substituted for the parameter. \nrecmi can be viewed in a similar manner. qml corresponds to q, reduction of Am~, e in Az ,ez must have \na The monadic reductions R~o~ are used to structure computation. property of the computational since, \nby the typing rules value type. = {let.,8,1et.q, let.assoc} In fact, an important meta-language is that \nthe reductions R~l can describe the evaluation patterns of both direct style and continuation-passing \nstyle A programs. We exploit this property when constructing correctness proofs for transformations factored \nthrough the meta-language. To capture the property formally, Figure 6 gives two sets of single-step reduction \nrules which are used to de\u00adfine operational semantics for Aml programs (closed terms of type l). In both \nsets of rules, the Rml reductions ~~i, ret, and let.9 are used to express computation. Adding the let \n.assoc reduction gives an evaluation pattern reminis\u00adcent of continuation-passing style, where the next \nredex is lifted out of a context before it is contracted. Omitting the let .assoc reduction gives the \ncharacteristic direct-style evaluation pattern where the evaluator descends into a con\u00adtext to pick the \nnext redex to contract [11]. The following property captures the fact that the direct\u00adstyle and the continuation-passing \nstyle evaluation pat\u00adterns give the same results for Aml programs. 7Moggi ~,ves a categorical semant)cs \nfor the meta-language. HOW\u00adever, an operational semantics 1s sufficient here, The rules of Fig\u00adure 6 \ndescribe two leftmost, outermost reduction strategies over Ant reductmns.  rkmic:~ r I-ml~: r(z) r,x:~ll-mle:fi \nr,~:~l-+%,x:~lkmle:fi rkmt eo :71-+Z r t-m{el :71 r+mt Az. e: 71+72 r EmIreef(z). e : 7-I -+rz r I-mIeo \ne] : r2 I +mle:r I l-miel:fi I , x:rll-mlez:% (monadic constructs) r l-m~ [e] : F rt-mtletz+=elinez:rz \nT ::= L[ ~l+fi I; r ;:= . I r,z:r Figure 4: Abstract syntax of A~l, the computational meta-language \n(A z .eo) el ~pml eo[x := el] Az. ez +Vml e z @ FV(e) (ret f(z). eo) el +recmi eo[f := reef(z). eo , \nz := el] let z + [cl] in ez +Ie,,p ez [x := el] let z -+= e in [z] +Iet.n e let z2 + (let zl + el in \nez) in es --qet,m~oc let 21 -+= e~ in (let z~ + ez in es) xl $? ~V(e3) Figure 5: The set of reductions \nRmr for Aml Direct-St yle Evahmtion Pattern: (Jz. eO) el I---+mD.D eO[z := el] (recj(z). eO) e, ++mt.D \neO[f := reef(z).eO , z := el] e] ++ml,LI ej ~et~ ~ [cl] in ez #mi.D ez[~ := el] let X~ e] in ez #m/,D \nlet X@ e; in e2 Continuation-Passing Style Evaluation Patterra: (Ax. eo)el +mI,C eO[x := e,] (reef(z). \neO) e, +d.c eO[f := reef(z).eO , x := e,] el Wmt.C ej let z ~ [cl] in ez ++ml.c e2[z := el] where el \n~ let y -&#38; ea in eb. letz-+elin ez*ml.c letx+ e;inez let X2+ (let xl + el in ez) in es Hm~.c iet \nZI + e~in (let X2-@ezin es) Figure 6: Single-step reductions for A~/ programs &#38;n (.] : A ~ A~L En( \n) Vaiuew [A] ~ A~l &#38;n{v] = [s.(0)1 ,,, zuhere v ~ Vaiue%[A]. f.(c) = c ~.{eo el] = (et zo * Z.(co} \ntn(~z.e) = As. &#38;{e} in zo C.{cl} t$n(rec f(x). e) = reef(t).tn{e} I?n(s] = z f%(f) = f t.(r] = f~) \n tn{r,z:~] = fn{r},~:tn{~] tn(~) = L sn{r,$:r) = tn{r],.f:sn(r) 4%(T1+T2) = 1%{7-1} --? En{rz} Figure \n7: CalI-by-name encoding into A~z 461 Figure 8: Call-by-value encoding in A~z Property 1 For . k~l e \n:7, e +-+%.~ [v] zfl e ~~~ c [VI Proofi One method relies on what can be thought of as a generalized \nversion of Plot kin s colon translation [32] which unrolls reductions in the continuation-passing style \npattern until a reduction corresponding to a direct-style reduction is exposed. 9 A (partial) meaning \nfunction evck for A~/ programs . l-~1 e : ~ can be defined as follows. evahl(e) = v i# e +-+>Z.D [vI \niff e X:Z ~ [v] It is straightforward to show that the calculus Rml is sound for reasoning about A~l \nprograms. 2.3 Encoding evaluation orders of A in A~/ Figures 7 and 8 present the A~t encodings of the \nst an\u00addard call-by-name and call-by-value strategies. In these par\u00adticular transformations, the double \nbrackets {.} are used when building computations and computation types. Single brackets (.) are used \nwhen building values and value types. Elsewhere, where a distinction between computations and values \nis unimportant to the structure of the transforma\u00adtion, we use {.] by default. The encodings G and 2, \npreserve typing, as captured in the following property. Property 2 e ~fr 1-e :7 then .fn[r] l-d G{e]: \nE.(r}. 0 ~jr 1-e : r then &#38;v{r} t-d &#38;v{e] : tv{~}. The two encodings differ in that call-by-name \nfunc\u00adtions receive computations as arguments (hence the typing t. {rl} ~ .5. {7z} ) while call-by-value \nfunctions receive val\u00adues as arguments (hence the typing t. (TI ) --t, (m}). The encodings also capture \nthe distinction between identifiers as computations for call-by-name and identifiers as values for call-by-value, \nas pointed out in Section 2.1.2. Correctness is captured as follows. Property 3 For cdl programs ~F e \n: t, eva&#38;(e) = v iff eoahl(~.{e}) = v c evak(e) = v ifl eval~~(tv {e}) = v Proofi The proof takes \nadvantage of the fact that XA D reductions describe direct-style evaluation. For example, for call-by-name, \nthe proof relies on the fact that e G. e implies &#38; {e} ~~~.D ~. {e }. I 2.4 Conclusion As advocated \nby Moggi and as illustrated here with call-by\u00adname and call-by-value, A~l offers a framework for encoding \nthe computational properties of A terms. Section 4 presents other practical evaluation orders. The following \nsection for\u00admally connects A~z terms and CPS terms. 3 Computations as Continuation-Passing Terms 3.1 \nIntroducing continuations Figure 9 presents the translation C from AA to contin\u00aduation-passing terms \nof A. C relies on a term representa\u00adtion of the monad of continuations [26, page 58]. We use the monad \nof continuations because it naturally accounts for passing continuations. We use a term representation \nbecause we are aiming for a program transformation. The following property captures the fact that C maps \nweKtyped A~L terms to well-typed CPS terms. Property 4 1~ r I-mi e : T, then e{r} E C{e} : C{r}. The \ntranslation on computation types ; shows that compu\u00adtations correspond to continuation-passing terms. \nWe use the notation -v-to abbreviate r 4 cms where mu is a dis\u00adtinguished type of answers. Thus Cm = \n7~C(r} = (C{r}-+ am) ~ am. The translation on terms shows that the monadic con\u00adst ruct ors [.1 and let \ncorrespond to the basic components of continuation-passing terms: [e] abstracts the application of a \ncontinuation to the result C(e), and  let x + el in ez abstracts the composition of com\u00adputations (continuation-passing \nterms) by forming the continuation A x . C{ez} k and passing it to C{el].  In the following sections, \nwe consider an optimized trans\u00ad formation C producing terms without redexes of the form (A k . e) k. \nSection 5 discusses administrative reductions in general. A fundamental property of C is that all A-terms \nin its im\u00ad age are evaluation-order independent. Furthermore, C pre\u00ad serves A~~ equational properties \nand operational semantics of A~l. 462 C{eorl-2 el j = A k-c~ z]). (C(feO}C{fa]) ~ Figure 9: Continuation \nintroduction To formalize these properties we establish an equational correspondence between the Itml \ncalculus of Am[ and CPS terms under the R, calculi. This first requires defining a translation C-1 from \nCPS terms to A~J. - Figure 10 presents the language C{AA} of CPS A-terms closed under R% reduct ion.8 \nNote that C{A~J is a sub-Ianguage of A. The judgement Fuat enforces the property that terms in the image \nof C are values (this property is dis\u00adcussed in detail in Section 3.4). The judgments +an~ and E.Ont \nrely on type assumptions that include a distinguished identifier k @ I . Figure 11 presents all possible \nR. reductions on C{A~t} terms. It is easy to show that each reduction is also a R, re\u00adduction. Also, \nreductions on CPS terms preserve synt attic categories, e.g., reducing an expression satisfying the judge\u00adment \n1-~ai yields an expression that still satisfies the judge\u00adment l-v=?. 3.2 Eliminating continuations \nFigure 12 presents the translation C-l from the language of CPS terms C{A~l} back to A~[. A key component \nof C l is the transformation of continuations to what we call reduction conteds.g Reduction contexts \nr +m~ p : ; [;] of type ;Z with holes of type ;I are described by the folIowing syntax rules.  r l-ml[] \n: 7~ (tr+kdcontexts) I?, x:rl+mle:fi (let contexts)rEd letz+ [.]in e:~2[r1] The following property captures \nthe fact that the transfor\u00admation preserves well-typed terms. Property 5 8A formal statement of correctness \nis omitted for lack of sPace 9 Felieisen and Friedman first pointed out that continuations m CPS correspond \nto ewahatton contezts in direct-style terms (e. g., terms from the language A) [1 1]. When considering \nAml terms, corl\u00adtinuations correspond to r-edwctton contests. Reduction contexts rep resent an intermediate \nstep between evaluation contexts and contin\u00aduations where, among oth&#38; things, the term in the (hole \nof a non. trivial evaluation context 1s given a name translation from AA into CPS If r l-eZP w : r \nthen C l (r] t-m, C;;p {w]: c- (7-].  If(r; k:lr)banSa:ans  . 3.3 Relating operational semantics and \nequational theo\u00adries We can now state an adequacy property for the transla\u00adtions C and C-l. The following \ntheorem recasts Plotkin s Simulation and Indifference theorems for call-by-name and call-by-value CPS \n[32, Section 6] in terms of the generic in\u00adtroduction of continuations by C. Theorem 1 (Simulation and \nIndifference) If .l-~t e:~ then etmlml(e) = v ifl ew3it(C(e] (A x . z)) = w Proofi The proof takes advantage \nof the fact that F-+A.C reductions describe continuation-passing style evalua\u00adtion. Specifically, e +-+m~.c \ne implies C {e] Q K WJ,V C {e } K for any arbitrary continuation K, where The corresponding property \nfor C-l follows. Theorem 2 If . +va/ w : lTL then ewh(c;,j{w}) = w ifl etd(w (J z . z)) = v. Proof: For \neua~, . ewL((C o C l)(W) (AZ . z)) e ~~(c;:,(w)) . . . Theorem 1 erm~(w (A z x)) . . . Theorem 3 @ soundness \nof R. Similarly for ew-z~. m Values rF ,qlw:r where w is a value I t-ualw:r Expressions r,x:rl ~val \nw: ~Tr2 r, f: T14T7T2, Z:Tl +.al W: 7TTZ  rF-eqc:L r +~zpr(x) x: r E.ZpAx. w:rl-+1-v2 r I-.zprec f(x). \nw: r] +77T2 r hva~ WO: T] +-qTz r +.~1 wl: 71 (1?; k : -r) i-an, CY: ans r~ ~zp wo WI : ~~r2 rkezp~k. \nff:77T Continuations (r,x:r, ; k : Tro) l-an. a : ans (r; k: ~r) t-cent k: ~T (r; k:lro)Econt Ax. a:=rl \n Answers r t-.$pw : =-wO (r; k : 71) I-.ont K : =ro (r; k :T) l-an, WK : am (r; k: ~ro) E.ont K : =rl \nr +v~lw : r, (r; k: -m) kan. ttw : ans Types and Assumptions .._ r .. t Irl+=vz I=-v r ,:= . I r,x:r \nFigure 10: Abstract syntax of C{A~i), the language of CPS terms (Ax . Wo) w, -pezp Wo[x := w,] (ret f(x). \nwo) W1 ---+~e~ezp Wo[f := recj(x). wo , X := Wl] (Ax . a) w --+pan$l a[z := w] (Ak .a) K +Ban, , CY[k:= \nK] .XX.WX ---+qez.,, e x @ FV(W) where w is a value ~ k .w k +QeZP, W k ~ FV(W) where w is a value Ax. \ntGz x @ FV(K) where K w a value -~cont K Figure 11: The set of reductions Rep, for C{A~l} c;;, (w] = \nC;;p {w] C;;p(c] = c c;;?(x] = x c;;. {w K] = C;;nt (t$][c;;p (w]] C;;P(A x .w] = Az .C;:,(W] c;;. {K \nw) = C:;nt {K][[c;;t(pu}]] C&#38;{rec f(z). w} = rec f(~). e~j(w} C;:p(Wo Wl) = C;;l{wo} C;;r{wl] Glt{kl \n= [ 1 CZ&#38; {A k.a} = C~&#38; {a} CJo~t {A z.a} = let z * [.] in C~~, {a] c- {,} = , C-1{rl+r2} = \nc-l{7i}+c-l{T2] c-l{r, z:T} = C-l {r}, z :C-l {r} C ] {mar} = C-~T} Figure 12: Continuation elimination \n translation from CPS back to A~l Plotkin s Translation theorems show how his call-by\u00adname and call-by-value \nCPS transformations relate equa\u00adtional theories over direct-style terms and theories over CPS terms [32]. \nWe relate the equational theories of the meta\u00adlanguage and CPS terms by showing an equational corre\u00adspondence \nbetween A~l terms under the Rmi calculus and C{Aml} terms under the llcps (i.e., R,) calcuIus. In essence, \nthis means that the equivalence classes of each theory are in a one-to-one correspondence. Theorem 3 \n(Equational Correspondence) Proofi Follows the outline of [36, Theorem 16]. However, the proof here is \nsimpler because our framework is typed and C does not perform administrative reductions on the fly . \n(see also [2, Theorem 7.3.10] and [17, Theorem 4]). ~ 3.4 Assessment Evaluation-order independence for \nall terms in the image of C holds because all C{Aml} function arguments are values. SpecificaUy, if \na Aml argument e has a value type, then C{e} is a value; and,  if a Amz argument e has a computation \ntype, then c(e) takes the form ~ k. ... (i.e., a value).  Obtaining evaluation-order independence requires \nslightly more than simply instantiating the monadic constructs [.1 and let with the continuation monad \n(witness the q-redex in C{eo el} of Figure 9). Such q-redexes are important since they suspend call-by-value \nevaluation when terms cor\u00adresponding to computations occur as function arguments, e.g., in CPS terms \nencoding call-by-name. Let C be a translation that only instantiates [.] and let. Following this strategy \ngives C {eo el} = C {eO} C {eI]. Now, if eo z A z. [CO] and el s (r-ec f(y). fy) cl, then C {eO el} (kz.z) \n= ((~z.Ak.k co) ((reef(y).fg) c,)) (kc.z) which diverges under call-by-value but terminates under call-by-name, \nand thus is not evaluation-order independent. The above example also illustrates why ~ is not sound for \nreasoning about C(A~l] terms under call-by-value evalua\u00adtion. For example, C~eO el ] (Az .z) terminates \nunder call-by\u00advalue but q-reduces to C [eo el] (kz. z which has just been 2 shown to diverge under call-by-value. \n1 In reality, problems are encountered only when one attempts to generalize qcont redexes to q all q \nredexes of the form given by Vezp, I and qexp.z are also v, redexes.11 10~i~ilar ~Xa~Ple~ of ~ &#38;~g \nunsound exist for traditkmal Un\u00ad typed call-by-name CPS terms under call-by-value evaluation. 11 SabrY \nand Felleisen shOw that the ~q calcuhIs is sOund fOr e\u00ad soning about a language of terms in the image \nof a call-by-value CPS transformation. We conjecture that q is sound there because it is call\u00adby-name \nthat requires the suspension effect given by the n-redex Furthermore, since continuations are the first \narguments to functions in them C!PS transformation, terms cent aimng the relevant q-redex Ak. (UJo WI) \nk would appear in their language as Ak. (wo k) WI a non-redex. 3.5 Generalizing the notion of value \nSuppose the types of Aml are extended as follows. This typing generalizes the notion of value to include \nap\u00adplications of functions that always terminate when applied. Such functions do not need to be passed \ncontinuations to achieve evaluation-order independence [9]. Theorem 1 and 2 hold for a language with \nthis generalized type system. A~I reductions in the generalized system induce a set of reduc\u00adtions R&#38; \non CPS terms that are sound under call-by-name and call-by-value evaluation. However, the generalized \ncal\u00ad culus R~p~ no longer equationally corresponds to R. or R, due to the generalized notion of value, \nbut it is a conserva\u00adtive extension of R. and Rv. Section 4.5 gives an application of this generalized \nno\u00adtion of value. The reader is referred to [16] for a detailed discussion. 4 CPS Transformations from \nEncodings of Computational Properties Previous applications of AA focus exclusively on call-by\u00advalue \nor call-by-name [26, 42]. 111 cent rast, the present framework allows the description of many other useful \nCPS transformations. Further, the correctness of the correspond\u00ading CPS transformation, the characterization \nof adminis\u00adtrative reductions (see Section 5), and a correct mapping from CPS back to A~i (see Section \n6) follow as corollar\u00adies from simply identifying the appropriate computational properties. We give several \nexamples below. For each evaluation order, the corresponding CPS trans\u00adformation is constructed by composing \nthe encoding &#38; (of the evaluation order into A~~ ) with the continuation intro\u00adduction C (or preferably, \nthe slightly optimized introduc\u00adtion C of Section 3 that produces terms without redexes of the form (A \nk . e) k). In general, the correctness of the con\u00adstructed CPS transformations follows from the correctness \nof an encoding &#38; and the correctness of C (Theorem 1). 4.1 Call-by-name and call-by-value CPS transformations \nWe describe in detail the construction of correct call-by\u00adname and call-by-value CPS transformations. \nAs outlined above, CPS transformations are obtained by composing the encodings of specific evaluation \norders with the generic con\u00ad tinuation introduction C . Definition 1 (Construction) /cn Af c ot. K, \nAf c ot. The fact that the transformations preserve well-typed terms follow as corollaries. Property \n6 (Type correctness) Proofi Follows from the type correctness of the encodings fn, 2, (Property 2) and \nthe type correctness of C (Property 4). E The correctness of the transformations follows as a corol\u00adlary. \nProperty 7 (Simulation and Indifference) If.l-e:L then eva~(e) = v iff ezdt(Kn(e} (Ax . z)) = v evd(e) \n= v ifl erm L(Kv(e}(Az . z)) = v Proofi Follows from the correctness of the encodings t., &#38;, (Property \n3) and the generic Simulation and Indifference theorem for C (Theorem 1). I The transformations K. and \nK constructed above are actually Plotkin s CPS transformations. Let P. and PV re\u00ad spectively denote the \ntyped version of Plotkin s call-by-name and call-by-value CPS transformations [8, 15, 22]. Proofi by \nstructural induction over e. B Thus, the construction and correctness (specifically, the Simulation and \nIndifference theorems, and type correctness) of the typed versions of Plotkin s CPS transformation fol\u00adlow \nfrom the correctness of the encodings. Relationships between equational theories for direct-style and \nCPS terms (similar to those established by Plotkin s Translation theo\u00adrems for P. and P.) follow by connecting \nequational theories over A with the theory Rml of Aml.  4.2 Reynolds s call-by-value CPS transformation \nWe obtain a typed version of Reynolds s call-by-value CPS transformation [34] by keeping the same encoding \nof vari\u00ad ables and applications in Figure 7 (the call-by-name encod\u00ading into Aml ) but by replacing the \nencoding of abstractions with the following definition. Instead of arguments being evaluated in the application \n(as in Figure 8, the call-by-value encoding into Aml ), they are passed as computations (essentially \nas thudcs[17, 18]), eval\u00aduated immediately after the function is applied, and the re\u00adsulting values are \nwrapped up again as thunks. Thus, tR captures the computational properties of call-by-value, but in a \ndifferent style than &#38;,. This corresponds to the defini\u00adtion of call-by-value in the Algol 60 report \n[30]. Turning to the CPS transformation, n =fc o&#38; Griffin, for example [15, Footnote 3], pointed \nout that the typing of the function space in RV matches the one of P. i.e., R, (T, +,2) = 7ZV(.I}+7?V(T2} \nThis typing coincidence already holds here, before introduc\u00ading continuations: and thus it is independent \nof continuations as such. In any case, this coincidence illustrates that the transforma\u00ad tion over types \ndoes not always determine the transforma\u00ad tion over terms. 4.3 Variation on Reynolds s call-by-value \nCPS transfor\u00admation One may choose to pass arguments unevaluated and to force them after the function \nis applied, but not to wrap them into computations again. This is achieved by replacing the encoding \nof abstractions and applications in Figure 8 (the call-by-value encoding into AA) with the following \ndefini\u00adtions. Thus ~~, captures the computational properties of call-by\u00advalue, but in a different style \nthan &#38; and ER. This corre\u00adsponds to the style of capturing computational properties of call-by-value \nin denot atiorml semantics [38]: (1) either using a strictness check in the applicative structure (correspond\u00ading \nto E,); (2) or forming strict functions to crest e a strict function space (corresponding to Reynolds \ns transformation and its variant). The typing of the function space in CR, still matches the one of tn \n(see Figure 7) i.e., However, the transformation on type assumptions r is the same as for &#38;, (Figure \n8). 4.4 Mixed evaluation strategies based on strictness infor\u00admation Compile-time analyses of computation \nproperties (such as strictness analysis) indicate where it is safe to mix eval\u00aduation strategies [29], \nEarlier works show how to derive the corresponding CPS transformation encoding the mixed evaluation strategy \ninto CPS terms [3, 8, 28, 31]. Such transformations can be correctly constructed by an encod\u00ading that \ncontains both call-by-value-like (capturing strict\u00adness) and call-by-name-like (capturing non-strictness) \nappli\u00adcations/ functions/identifiers. The types of such an encoding are structured as follows. These \ntypes illustrate that arguments to non-strict functions are computations while arguments to strict functions \ncan be safely reduced to values before application. This encoding is based on combining the styles of \n&#38;v and &#38;n. However, a correct encoding based on strictness information can also be obtained by \ncombining the styles of 2R and E. or of f~, and S.. Again, as long as the computational properties are \ncorrectly identified, the correct CPS transformation and ac\u00adcompanying tools follow. , 4.5 Mixed evaluation \nstrategies based on totality infor\u00admation Similarly, totality information determines when computa\u00ad tions \nare guaranteed to reduce to values. An encoding of terms with totality information obeys the following \ntype structure (capturing the possibility of partiality/totality in the domain and codomain of function \nspaces). Note that this encoding utilizes the generalized type struc\u00adture of Aml discussed in Section \n3.5. Such an encoding yields a CPS transformation where Reynolds s notion of trivial and serious expressions \nis generalized to functions functions that always produce values do not need to be passed con\u00adtinuations \nto achieve evaluation-order independence [9, 33]. Elsewhere [16], we use Moggi s existence predicate \n[26, Section 2.2] within the met a-language itself to derive such optimizations.  4.6 Other sequencing \norders Since A~l makes control flow explicit, one can construct CPS transformations with different sequencing \norders for sub-expression evaluation. For example, replacing the en\u00adcoding of application in Figure 8 \nwith the one below gives a call-by-value CPS transformation where the argument is evaluated before the \nfunction in an application. 4.7 Conclusion We have shown that a wide variety of evaluation strategies \ncan be described by simple encodings in Aml. The corre\u00adsponding (2PS transformations and correctness \nproofs fol\u00adlow. The next two sections describe how administrative re\u00adductions and the corresponding direct-style \ntransformations follow as well. 5 A Generic Account of Administrative Reductions Practical use of CPS \ntransformations requires one to char\u00adacterize administrative reductions i.e., the reduction of the extraneous \nabstractions introduced by the transforma\u00adtion to obtain continuation-passing [7, 32, 36]. In fact, ad\u00administrative \nreductions are characterized generically by the monadic reductions Rmon on Aml. In particular, let.~ \nand let .assoc correspond to the administrative reductions iden\u00adtified by Plotkin. It is straightforward \nto show that the reductions Rmo ~ are Church-Rosser and strongly normaliz\u00ad ing. Let ~ be a function mapping \nevery Am; term to its Rmon normal form and let Z denote a version of plotkin~s call-by-value CPS transformation \nthat carries out adminis\u00adtrative reductions on the fly [I, 7, 43]. A similar property also holds for \nthe corresponding one-pass call-by-name CPS transformation, and for the corresponding CPS transformations \nafter static analyses [8, 9, 31]. This staging and the account of administrative reductions prior to \nintroducing continuations have been recently noted [5, 6, 13, 21, 36]. Typically, CPS transformations \nare factored into three distinct steps: 1. naming intermediate values (captured by ~); 2. flattening \nnested let s (captured by Af); and 3. introducing continuations (captured by C).  The last step is \nprovably reversible, and Lawall antomated that proof for another meta-language than Am/ [20]. Recently, \nSabry and Felleisen have identified an addi\u00adtional optimization made possible by administrative reduc\u00adtions \non call-by-value CPS terms [36]. The optimization cor\u00adresponds to relocating evaluation contexts (reduction \ncon\u00adtexts, continuations) inside abstractions in ,&#38;redexes. The following Rml equivalence characterizes \nthis optimization:12 where p + [.] and z @ FV(p). Let let. ctxt be the reduc\u00adtion induced by reading \nthis equivalence from left to right .]3 The Church-Rosser and strong normalization property ex\u00adtends \nto Rmon U {let .ctxt } reductions, characterizing ad\u00administrative reductions (including the above optimization) \ngenerically. We have characterized administrative reductions ab\u00adstractly in terms of normalization of \nAA terms. In practice, one would define an optimized translation that performs ad\u00administrative reductions \non the fly [1, 7, 43]. This can ei\u00adther be achieved using brute force [27, 36] or with a two-level specification \n[7, 8, 31]. 6 DS Transformations from Encodings of Computational Properties Direct-style transformations \nmapping CPS terms back to direct-style A terms are potentially useful in their own right. Our transformation \nC-l forms the core of a generic DS trans\u00adformation, thus generalizing previous work in the absence of \ncomput atiomd effects other than non-termination [6, 35]. Direct-style transformations D are obtained \nby composing inverse encodings &#38;-l (mapping A~l terms to direct-style A terms) with the transformation \nC l. The transformation t l may be defined in several ways. A simple technique is to unfold let constructs \nand remove [.1 constructs thus collapsing values and computations, under some side-conditions ensuring \nthat the resulting terms remain evaluated in the same order. This is the technique used by e.g., Lawall \nand Danvy [6, 10, 19, 21]. Alternatively, one may adapt the techniques of Sabry and Felleisen [36] and \nmap reduction contexts to evaluation contexts in A. In general, transformations t 1 defined as above \nare meaning-preserving only when defined on the language of A~l terms in the image of a corresponding \nencoding &#38; (or snch a language closed under Rml reductions). Considering a more general domain for \n.5-1 usually requires additional constructs in A which explicitly direct computation (e.g., strict let \ns, thunks) without resorting to full continuation\u00adpassing style. Formal properties and details of methods \nto obtain DS transformations for specific evaluation orders are described elsewhere [16]. 7 Products \nand Co-products This section outlines how products and co-products are in\u00adcorporated into the generic \nframework. A detailed discus\u00adsion and proofs can be found elsewhere [16]. All of the results of the previous \nsections scale up to the extended language. 12 Even ~i~h ~hl~ ~Ptimization, Sabry and Felleisen s call-by-value \n CPS transformation will produce slightly more compact terms. Hav\u00ading continuations as first arguments \nto functions makes it possible for all continuations to be relocated inside the abstractions of all P-redexe.. \nHere, trwial continuatmns (z. e., identifiers k) are notdo\u00ad cated. In any case, this optimization is \nindependent of continuations in general, and in particular of psssing them first or last to CPS functions. \n13A ~imilar OptimiZatiOn ak exists fOr ec f(c) T t-ml el rhml : TI r >m~ez (el, e2): T1xr2 : r2 r +m~e \n: r1+r2 r r,zl:rl t-miel t-ml ca9ee oj(zl.el) :Y I , z2:r2t-mle2:; \\ (z2.e2) : ; i\u00ad .. ... I r, X72 I \nT,+rz Figure 13: Abstract syntax of products and coproducts for the computational meta-language A~t \nFigure 13 extends the syntax of A~~ to include products are obtained by composing the encodings f with \nC. The 14 The set of ~aiue types is extended 0 and co-products. correctness hinges on the fact that all \nCPS terms will have include types T1 x TZ and rl +~z. The reductions for products only values as constructor \narguments (i. e., either terms cor\u00adand co-products are as follows. 15 responding to met a-language values, \nor abstractions M.... corresponding to meta-language computations). This gen\u00adi7i(el, e2) +X.pt e, eralizes \nour earlier work [8], where we presented a CPS trans\u00adformation after strictness analysis, handling both \nstrict and case (in, e) of (zl.el) I (zz.ez) -+,pz e,[zt := e] non-strict products. Note that the definition \nof C in Figure 14 relies on the As with function spaces, the structure of A~l types and monadic constructs \nto structure continuation-passing proP\u00adterms provides a description of constructors with differing erly. \nHowever, the definition below gives an alternate struc\u00ad computational properties (e.g., eager or lazy). \nFor exam-ture commonly used when transforming conditional expres\u00adple, eager (i. e ., call-by-value) pairing \ncan be expressed via sions. products of values. fv(Tl XT2) = &#38;v (I(el, e2)] = in let zz @ Zv{ez} \nThe latter definition allows reduction contexts (in the in [(z1, Z2)] form of continuations) to be relocated \ninside case constructs . which duplicates the contexts. Ie Indeed, this definition ~v(~, e} = let z \n* &#38;v{e} in [7r, z] reauires adding the followimz reduction to the set of Aml re~uct~ns to o~tain \nan equat~onal correspondence with CPSLazy (i. e., call-by-name) injections can be expressed via co\u00adterms: \nrproducts of computations. V[casee of (zl.el) j (z2.e2)] -+.ctxt case e of (xl.p[el]) I (z2. p[e2]) where \nq # [.] and Z1, X2 @ FV(p). This reduction is sound with respect to the operational semantics of Am{ \nextended with products and co-products. Moreover, the framework naturally describes non-standard forms \nof products and co-products (e.g., one lazy compo-8 Compiling with Monadic Normal Forms nent, one eager \ncomponent ) such as might occur in a pro\u00adgram after strictness and/or termination analysis. In situations \nwhere explicit continuations are not needed Figure 14 extends C to products and co-products. As be-(e.g., \nfor compiling programs without jumps), A~l stands fore, correct CPS transformations for the extended \nlanguage 16This duplication can be avoided inserting a @-redex when intro\u00ad 14The ~~esentationof products \nfollows Moggi [26, Sect iOn 3 11. ducing continuations [7, 36]. 17 Sabry and FeIIe15en [36] give .s similar \nreduct]on for conditional 15A presentation including the usual x .q and + T rules fOr prOducts expressions, \n and co-products can be found elsewhere [16]. as an alternative language to CPS very close to CPS but \nwithout continuations. A language with similar prop\u00aderties ( A-normaJ forms ) has been proposed by Flanagan \net al. [13] and studied for untyped, call-by-value A-terms. In particular, A-reductions provide the following \nstandard compiler optimizations [13, page 243]: 1. code segments are merged across declarations and con\u00additions; \n 2. reductions are lifted out of evaluation contexts and intermediate results are named.  These properties \noccur naturally in A~l. The Aml reduc\u00adtions let .assoc and +.ctxt merge code segments across dec\u00adlarations \n(i. e., let) and conditionals (more generally, case statements). Encodings t into AA name intermediate \nre\u00adsults and the reduction let. assoc lifts reductions out of re\u00adduction contexts. Thus, Moggi s meta-language \nis not only a flexible for\u00admal tool, but also an attractive intermediate language for compiling. In particular, \na sub-language of A~~ that we call the language of monadic nor-mat forms gives the properties discussed \nabove for any evaluation order that can be en\u00adcoded into A~l. (The word monadic is slightly abused here \nsince +.ctxt is not a monadic reduction.) The strong normalization and confluence properties of Rmon \nreductions extend to Rmon U {+.ctxt}. Let N be a function taking a A~t term to its I?mon U {+.ctxt} normal \nform. The function ~ o &#38; maps A terms to monadic normal forms for an arbitrary encoding t, thereby \nperforming administrative reductions independently of continuations (see Section 5). Recent trends indicate \nthat types are important for in\u00adtermediate languages. For example, Burn and Le M6tayer point out that \ntypes on CPS transformations give a use\u00adful characterization of boxed and unboxed values [3]. This observation \napplies here as well  computation types cor\u00ad respond to boxed values, and value types correspond to \nun\u00ad boxed values. Related Work The framework presented here relies on a formal connection between Moggi \ns computational meta-language and CPS terms and types. Moggi proposes the meta-language as a means of \nabstractly capturing the basic computational structure of programs. Semantic definitions of programs \nare obtained by a categorical interpretation parameterized with different monads capturing various notions \nof compw tation. Moggi gives a continuation monad in the category Set as particular example of a notion \nof computation es\u00adtablishing a correspondence between the meta-language and set-theoretic continuation-passing \nfunctions [26, page 58]. Wadler illustrated the usefulness of Moggi s ideas when applied to functional \nprogramming [42]. In essence, he showed how programs written in the style of the meta-Ianguage (i. e., \nmonadic style) could be parameterized with term representations of monads thus abstractly captur\u00ading \nvarious computational effects such as side-effects on a global state, etc. In particular, he showed how \ncall-by-value and call-by-name CPS interpreters can be obtained by in\u00adstantiating call-bv-value and call-bv-name \nmonadic-stvle in\u00ad . terpreters-with a term representation of the CPS monad thereby informally relating \nthe encodings t, and t. with call-by-value and call-by-name CPS terms. In contrast, we formalize the \nrelationship between the complete meta-language Aml and CPS terms. Based on this formulation, we generically \ncapture many different aspects associated with CPS (construction of CPS transformations, correctness \nof transformations with regard to computational adequacy and preservation of equational theories, adminis\u00adtrative \nreductions, construction of DS transformations, typ\u00ading of transformations, etc.) which were previously \nhandled individually for each evaluation order. We emphasize that AA is powerful enough to describe not \nonly the standard call-by-value and call-by-name strategies but many other useful strategies appearing \nin the literature. One only needs to identify computational properties with Ami and all the aspects mentioned \nabove follow as corollaries in the frame\u00adwork. To the best of our knowledge, this is the first attempt \nof such a global investigation of CPS. Sabry and Felleisen, in their recent work [36], hint at the relationship \nbetween Moggi s computational framework and CPS terms. They derive a calculus for untyped call\u00adby-value \nDS terms which equatiomdly corresponds to call\u00adby-value CPS terms under the /?~ calculus. They note that \nthe resulting calculus equationally corresponds to an un\u00adtyped variant of Moggi s computational J-calculus \nAC [23] a calculus for call-by-value terms capturing equivalences that hold for any notion of computation. \nHowever, this correspondence seems to stem more from the emphasis on naming intermediate values present \nin both calculi rather than from any deliberate structural connection with e.g., the CPS monad. For example, \nthe terms produced by Sabry and Felleisen s CPS transformation (a curried ver\u00adsion of Fischer s transformation \n[12], where continuations occur first in functions) do not have the fundamental com\u00adputational structure \ndictated by Moggi s framework. This is most easily seen by observing the mismatch between the typing \nof function spaces in Fischer s transformation and in the transformations generated by the CPS monad \n(cur\u00adried and with continuations occurring last ). In contrast, our framework is deliberately based on \nthe structural (and equational) correspondence between AA and generic CPS terms. Using techniques analogous \nto those of Sabry and Fellei\u00adsen [36], Sabry and Field have investigated state-passing style (uncurried \nand with state occurring last), deriving calculi for an untyped language with state. In contrast, one \ncan take the state monad [26] and translate from the meta-language A~z to various state-passing styles \n(curried and with state occurring last) in the same way as we have used the continuation monad to generate \na variety of continuation-passing styles: one then obtains a state-passing transformation for any evaluation \norder, generic administra\u00adtive reductions, and the corresponding (direct-style trans\u00adformations. As for \nCPS, these tools are obt ained by showing an equational correspondence between the meta-language and \na term representation of the state monad. Thus Moggi s framework seems to provide a solid basis for studying \nboth the relation between implicit and explicit representations of control and the relation between implicit \nand explicit representations of state, in a typed setting. In particular, we are currently investigating \nhow the contin\u00aduation/st ate monad (obtained e, g., by applying the state\u00admonad constructor to the continuation \nmonad [25]) offers a generic relation between implicit and explicit representa\u00adtions of both control \nand state. We are also considerirw . to add computational effects on control (first-class continua. tions) \nand on the state (side-effects). 10 Conclusion and Issues We have characterized CPS transformations of \ntyped A\u00adterms for any evaluation order, their administrative reduc\u00adtions, and the corresponding DS transformations, \nin one generic framework based on Moggi s computational meta\u00adlanguage and using a term representation \nof the CPS monad. Plotkin s Indifference, Simulation, and Translation theorems are generalized for the \ncontinuation introduction C. Char\u00adacterizations of administrative reductions (including Sabry and Felleisen \ns optimization) are scaJed up in a typed frame\u00adwork for any evaluation order. Moggi s computational met \na\u00adlanguage appears as a generic typed intermediate language for compiling, alternatively to CPS and with \nan equivsJent expressive power, in the absence of first-class continuations. We are currently considering \nother monads for applying the methodology developed here. Preliminary investigation for the state monad \nsuggests that the same benefits hold: state\u00ad passing style for any evaluation order, uniform administra\u00ad \ntive reductions, and the corresponding direct-style trans\u00adformations. Ditto for the continuation/state \nmonad. This investigation should make it possible to come back to Griffin s connection between double-negation \ntranslation and CPS transformation [14] and to Murthy s intrepid dis\u00adplay of continuation-passing styles, \nfrom a logical standpoint [28, Chapters 9 &#38; 10]. Griffin identified Plotkin s caH-by\u00advalue CPS transformation \nas a logical embedding. Murthy identified it as a variant of the Kuroda negative transla\u00adtion, and Plotkin \ns caJ1-by-name CPS transformation as the Kolmogorov translation. In fact, looking back at Murthy s PhD \nthesis, it is striking that his slightly modified Kuroda translation providing for mixed call-by-vahe \nand call-by\u00adname evaluation [28, page 159] corresponds to the mixed CPS transformation of Section 4.4, \nand that his pervasive Kolmogorov translation [28, pages 164-167] corresponds to Reynolds s CPS transformation \nin Section 4.2. The equa\u00ad tional correspondence between A~l and CPS strongly sug\u00ad gests that the encoding \nof any evaluation order into A~l could be formalized as a logical embedding. We leave this point for \na future work. Acknowledgements We are grateful to Andrzej Filinski and Bob Harper for fun\u00addament aJ \nobservations and encouragements at an early stage of this work. Thanks are also due to Mat t hi as Felleisen, \nSergey Kotov, Julia Lawall, Peter Lee, Karoline Malmkjam, Chet Murthy, Frank Pfenning, Amr Sabry, Dave \nSchmidt, and the referees for comments. References [1] Andrew W. Appel. Compiling with Continuations. \nCambridge University Press, 1992. [2] Henk Barendregt. The Lambda Calculus Its Syntax and Semantics. \nNorth-Holland, 1984. [3] Geoffrey Burn and Daniel Le M6tayer. Proving the correctness of compiler optimisations \nbased on a global program analysis. TechnicaJ report Doc 92/20, Depart\u00adment of Computing, ImperiaJ College \nof Science, Tech\u00adnology and Medicine, London, England, 1992. [4] William Clinger, editor. Proceedings \nof the 1992 ACM Conference on Lisp and Functional Prograrnmmgj LISP Pointersj Vol. V, No. 1, San Francisco, \nCalifornia, June 1992. ACM Press. [5] Olivier Danvy. Three steps for the CPS transforma\u00adtion. TechnicaJ \nReport CIS-92-2, Kansas State Univer\u00adsit y, Manhattan, Kansas, December 1991. [6] Olivier Danvy. Back \nto direct style. Science of C orn\u00adputer Progr-amrnmg, 1993. SpeciaJ issue on ESOP 92, the Fourth European \nSymposium on Programming, Rennes, February 26-28, 1992. To appear. [7] Olivier Danvy and Andrzej Filinski. \nRepresenting con\u00adtrol, a study of the CPS transformation. In Wand [44], pages 361-391. [8] Olivier Danvy \nand John Hatcliff. CPS transformation after strictness amdysis. ACM Letters on Prograrnrninjj Languages \nand Systems, 1(3):195-212, 1993. [9] Olivier Danvy and John Hatcliff. On the transformation between \ndirect and continuation semantics. In Stephen Brookes, Michael Main, Austin Melton, Michael Mis\u00adlove, \nand David Schmidt, editors, Proceedings of the 9th Conference on Mathematical Foundations of Program\u00adming \nSemantics, Lecture Notes in Computer Science, New Orleans, Louisiana, April 1993. To appear. [10] Olivier \nDanvy and Julia L. Lawall. Back to direct style H: First-class continuations. In Clinger [4], pages 299\u00ad \n310. [11] Matthias Fe!.leisen and Daniel P. Friedman. Control operators, the SECD machine, and the A-calculus. \nIn M. Wirsing, editor, Formal Description of Pro\u00adgramming Concepts III, pages 193-217. North-Holland, \n1986. [12] Michael J. Fischer. Lambda-calculus schemata. In Tal\u00adcott [39]. An earlier version appeared \nin an ACM Con\u00adference on Proving Assertions about Programs, SIG-PLAN Notices, Vol. 7, No. 1, January \n1972. [13] Cormac Flanagan, Amr Sabry, Bruce F. Duba, and Mat thias Felleisen. The essence of compiling \nwith con\u00adtinuations. In David W. Wall, editor, Proceedings of the ACM SIGPLAN 93 Conference on Programming \nLan\u00adguages Design and Imgdementation, SIGPLAN Notices, Vol. 28, No 6, pages 237 247, Albuquerque, New \nMex\u00adico, June 1993. ACM Press. [14] Timothy G. Griffin. A formulae-as-types notion of con\u00adtrol. In Paul \nHudak, editor, Proceedings of the Seven\u00adteenth Annual ACM Symposium on Principles of Pro\u00adgramming Languages, \npages 47 58, San Francisco, Cal\u00adifornia, January 1990. ACM Press. [15] Bob Harper and Mark Lillibridge. \nPolymorphic type assignment and CPS conversion. In TaJcott [39]. [16] John Hatcliff. PhD thesis, Department \nof Comput\u00ading and Information Sciences, Kansas State University, Manhattan, Kansas, USA, March 1994. \nForthcoming. [17] John Hatcliff and Olivier Danvy. Thunks and the ~\u00adcalculus. Technical Report CIS-93-15, \nKansas State University, Manhattan, Kansas, September 1993. 470 [18] Peter Z. Ingerman. Thunks, a way \nof compiling pro\u00adcedure statements with some comments on procedure declarations. Communications of the \nACM, 4(1):55-58, 1961. [19] Julia L. Lawall. PhD thesis, Computer Science Depart\u00adment, Indiana University, \nBloomington, Indiana, USA, 1993. Forthcoming. [20] Julia L. Lawall. Proofs by structural induction us\u00ading \npartial evacuation. In David A. Schmidt, editor, Proceedings of the Second ACM SIGPLA N Symposium on \nPartial Evaluation and Semantics-Based Program Manipulation, pages 155 166, Copenhagen, Denmark, June \n1993. ACM Press. [21] Julia L. Lawall and Olivier Danvy. Separating stages in the continuation-passing \nstyle transformation. In Su\u00adsan L. Graham, editor, Proceedings of the TuJent ieth Annual ACM Symposium \non Principles of Progr-am\u00adming Languages, pages 124 136, Charleston, South Carolina, January 1993. ACM \nPress. [22] Albert R. Meyer and Mitchell Wand. Continuation se\u00admantics in typed lambda-calculi (summary). \nIn Rohit Parikh, editor, Logics of Programs -Proceedings, num\u00adber 193 in Lecture Notes in Computer Science, \npages 219 224, Brooklyn, June 1985. [23] Eugenio Moggi. Computational lambda-calculus and monads. Report \nECS-LFCS-88-66, University of Edin\u00adburgh, Edinburgh, Scotland, October 1988. [24] Eugenio Moggi. Computational \nlambda-calculus and monads. In Proceedings of the Fourth Annual IEEE Symposium on Logic in Computer Science, \npages 14-23, Pacific Grove, California, June 1989. IEEE Computer Society Press. [25] Eugenio Moggi. An \nabstract view of programming languages. Course notes ECS-LFCS-90-113, Labora\u00adtory for Foundations of \nComputer Science, Department of Computer Science, University of Edinburgh, Edin\u00adburgh, Scotland, April \n1990. [26] Eugenio Moggi. Notions of computation and monads. Information and Computation, 93:55-92, 1991. \n[27] Luc Moreau and Daniel Ribbens. Sound rules for par\u00adallel evaluation of a functional language with \ncallcc. In Arvind, editor, Proceedings of the Sixth ACM Confer\u00adence on Functional Programming and Computer \nArchi\u00adtecture, pages 125 135, Copenhagen, Denmark, June 1993. ACM Press. [28] Chetan R. Murthy. Extracting \nConstructive Content from Ckmsical Proofs. PhD thesis, Department of Com\u00adputer Science, Cornell University, \n1990. [29] Alan Mycroft. The theory and practice of transform\u00ading call-by-need into call-by-value. In \nBernard Robinet, editor, Proceedings of the Fourth International Sympo\u00adsium on Programming, number 83 \nin Lecture Notes in Computer Science, pages 269 281, Parisj France, April 1980. [30] Peter Naur (editor). \nRevised report on the algorith\u00admic language Algol 60. Communications of the ACM, 6(1):1-17, 1962. [31] \nChris Okasaki, Peter Lee, and David Tarditi. Call-by\u00adneed and continuation-passing style. In Talcott \n[39]. [32] Gordon D. Plotkin. Call-by-name, call-by-value and the A-calculus. Theoretical Computer Science, \n1:125-159, 1975. [33] John C. Reynolds. Definitional interpreters for higher\u00adorder programming languages. \nIn Proceedings of 25th ACM National Conference, pages 717 740, Boston, 1972. [34] John C. Reynolds. On \nthe relation between direct and continuation semantics. In Jacques Loeckx, edi\u00adtor, .2nd Colloquium on \nAutomata, Languages and Pro\u00adgramming, number 14 in Lecture Notes in Computer Science, pages 141 156, \nSaarbrucken, West Germany, July 1974. [35] Amr Sabry and Matthias Felleisen. Reasoning about programs \nin continuation-passing style. In Clinger [4], pages 288-298. [36] Amr Sabry and Matthias Felleisen, \nReasoning about programs in continuation-passing style. In Talcott [39], [37] Amr Sabry and John Field. \nReasoning about explicit and implicit representation of state. In Paul Hudak, ed\u00aditor, Proceedings of \nthe ACM SIGPLA N Workshop on State in Programming Languages, pages 17--3o, Copen\u00adhagen, Denmark, June \n1993. [38] David A. Schmidt. Denotational Semantics: A Method\u00adology for Language Development. Allyn and \nBacon, Inc., 1986. [39] Carolyn L. Talcott, editor. Special issue on con\u00adtinuations, LISP and Symbolic \nComputationj Vol. 6, Nos. 3/4. Kluwer Academic Publishers, 1993. [40] Robert D. Tennent. Semantics of \nProgramming Lan\u00adguages. Prentice-Hall International, Englewood Cliffs, New Jersey, 1991. [41] Philip \nWadler. Comprehending monads. In Wand [44], pages 461-493. [42] Philip Wadler. The essence of functional \nprogramming (tutorial). In Andrew W. Appel, editor, Proceedings of the Nineteenth Annual ACM Symposium \non Principles of Programming Languages, pages 1 14, Albuquerque, New Mexico, January 1992. ACM Press. \n[43] Mitchell Wand. Correctness of procedure representa\u00adtions in higher-order assembly language. In Stephen \nBrookes, Michael Main, Austin Melton, Michael Mis\u00adlove, and David Schmidt, editors, Mathematical Foun\u00addations \nof Programming Semantics, volume 598 of Lec\u00adture Notes in Computer Science, pages 294 311, Pitts\u00adburgh, \nPennsylvania, March 1991. 7th International Conference. [44] Mitchell Wand, editor. Special issue on \nthe 1990 ACM Conference on Lisp and Functional Programming, Mathematical Structures in Computer Science, \nVol. 2, No. 4. Cambridge University Press, December 1992.  \n\t\t\t", "proc_id": "174675", "abstract": "<p>We unify previous work on the continuation-passing style (CPS) transformations in a generic framework based on Moggi's computational meta-language. This framework is used to obtain CPS transformations for a variety of evaluation strategies and to characterize the corresponding administrative reductions and inverse transformations. We establish generic formal connections between operational semantics and equational theories. Formal properties of transformations for specific evaluation orders follow as corollaries.</p><p>Essentially, we factor transformations through Moggi's computational meta-language. Mapping &#955;-terms into the meta-language captures computation properties (e.g., partiality, strictness) and evaluation order explicitly in both the term and the type structure of the meta-language. The CPS transformation is then obtained by applying a generic transformation from terms and types in the meta-language to CPS terms and types, based on a typed term representation of the continuation monad. We prove an adequacy property for the generic transformation and establish an equational correspondence between the meta-language and CPS terms.</p><p>These generic results generalize Plotkin's seminal theorems, subsume more recent results, and enable new uses of CPS transformations and their inverses. We discuss how to aply these results to compilation.</p>", "authors": [{"name": "John Hatcliff", "author_profile_id": "81100281021", "affiliation": "Department of Computing and Information Sciences, Kansas State University, Manhattan, Kansas", "person_id": "PP43118402", "email_address": "", "orcid_id": ""}, {"name": "Olivier Danvy", "author_profile_id": "81100394275", "affiliation": "Department of Computer Science, Aarhus University, NY Munkegade, 8000 Aarhus C, Denmark", "person_id": "PP15031217", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/174675.178053", "year": "1994", "article_id": "178053", "conference": "POPL", "title": "A generic account of continuation-passing styles", "url": "http://dl.acm.org/citation.cfm?id=178053"}