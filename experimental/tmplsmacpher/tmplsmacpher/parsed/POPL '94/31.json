{"article_publication_date": "02-01-1994", "fulltext": "\n A Staging Calculus and its Application to the Verification of Translators (Preliminary Report) Robert \nMuller* Apple Computer One Main Street Cambridge, MA 02142 muller@lcambridge. apple.com Abstract We develop \na calculus in which the computation steps re\u00adquired to execute a computer program can be separated into \ndiscrete stages. The calculus, denoted A2, is embed\u00added within the pure untyped Xcalculus. The main result \nof the paper is a characterization of sufficient conditions for confluence for terms in the calculus. \nThe condition can be taken as a correctness criterion for translators that perform reductions in one \nstage leaving residual redexes over for sub\u00adsequent computation stages. As an application of the theory, \nwe verify the correctness of a macro expansion algorithm. The expansion algorithm is of some interest \nin its own right since it solves the problem of desired variable capture using only the familiar capture \navoiding substitutions. Introduction The /l-calculus is widely used as a metalanguage for pro\u00adgramming \nlanguage semantics because most of the complex\u00adities of real programming languages can be modeled by \nrel\u00adatively simple and well-understood aspects of the calculus. One important aspect of a programming \nlanguage that does not have an obvious analog in the A-calculus is the notion of staging the fact that \nit is usually desirable to sepa\u00adrate the computations required to execute a source program into discrete \nstages: usually translation-time and run-time. Compilers, macro expanders and partial evaluators are \nex\u00adamples of translators that perform some computations stat\u00adically and emit a residual program that \nwill perform the remaining computations in a separate run-time stage. In this paper we develop some synt \nattic theory for a cal\u00adculus in which computation stages are represented explicitly. Although the formalism \ncan account for an arbitrary num\u00adber of stages, in this report we will restrict our attention to the \ntwo-stage case: compile-time and run-time. The cal\u00adculus, denoted AZ, is embedded within the pure untyped \nA\u00ad This work was partially supported by the Defense Advanced Re search Projects Agency under grant number \nF1962S-92-C-01 13. Permission to copy without fee all or part of this material is granted provided that \nthe copies ore not made or distributed for direct commercial adventega, the ACM copyright notice and \nthe title of the publication end its dote appear, and notioe is given that copying ia by permission of \ntha Association for Computing Machinary. To copy otharwiea, or to republish, raquires a fee andlor epecific \npermission. POPL 94-1/94, Portland Oregon, USA calculus and was first motivated by the problem of verifying \nthe correctness of macro expansion. The main contribution of the paper is a characterization of sufficient \nconditions for confluence. The condition can be taken as a correctness criterion for translators that \nper\u00adform reductions in one stage leaving residual redexes over for subsequent stages when more input \nis available. As an ap\u00adplication of the theory, we verify the correctness of a simple macro expansion \nalgorithm. It is not unusual to model translation-time computation steps by ordinary ,&#38;reduction. \nA translator T E A operates on a suitable representation Jfl of a source program M and yields a representation \nM l of a residual program M . T M1 -p M l (1) In this paper we wifl restrict our attention to A-calculus \nbased source languages. The reader will recall the well\u00ad known fact that there is no R c A such that \nVM E A, RM =$rM representations of terms must be given a priori. Although a variety of representations \nwould suf\u00adfice, in th~ paper we will use Mogensen s representation [Mog92a]: rz~ ~ Aabc.az (M N)T = Aabc.brM3rN3 \n( Ax. M)l s Aabc.c(Az.rM1) The key idea of the &#38;calculus is a notion of represen\u00adtation or run-time \nreduction. We define: B = {(r(AZ.M)N , M[z := N] ) I M, N c A} (2) and consider the usual derived relations \n-+--I , ++r -I and PB =r6n. It is clear that although =rO-r identifies distinct ,0-normal-forms, =r@l \nis nevertheless a consistent theory since /31 is a mirror image of /3. AZ is obteined by combining these \nnotions of reduction: In ~z, one thinks of a representation (,lz.M)N1 as an active datatype that can \neither be reduced (that is, to M[x := N]l) or taken apart (that is, to Az.M1 and N1). The activity reflects \nwhat the represented code could do in subsequent computation stages in th~ case, run-time. ~ 1994 ACM \n0-69791 -636-0/94/001..$3.50 One of the key problems taken up in this paper is to de\u00adtermine the weakest \nconditions sufficient to ensure that the translation-time operations on the data type do not interfere \nwit h its intended run-time behavior. We take confluence to be an appropriate notion of non-interference. \nFor unrestricted A-terms the relation /3z is not confluent. For example, r(Au.w)w% (4) where TA, v, w \nand z are variables, has two distinct &#38; normal-forms: Abc.xv and Abc.br Au .V lr W1. In order to \nrule\u00adout such ill-formed terms we impose a simple type d~cipline. We define the representation t~pes \nby T ::=dlr+r We write J4 : d if there exists an N such that M =BrN1 and M :u-+ r if M maps every term \noftype ato one of type r. Intuitively, if there exists a r such that M : r then M has a reasonable shape. \nUnfortunately, we~-typedness does not suffice to ensure confluence under /3z since well-typed terms may \nnot respect the run-time equational theory. For example, taking 1, K and S to be the usual combmators, \nthe term: (5) is of type d but has two distinct ,&#38;normal-forrns: r K1 and S7. Intuitively, the problem \nis that reducing directly to a P-normal-form leads to a residual program r K whose behavior differs from \nthat obtained by first reducing the run\u00adtime redex 1P and then reducing to /3-normal-form. The key restriction \non terms, well-behavedne.w, is intended to be the weakest condition that rules-out such terms. That well-typed \nand well-behaved terms are not built up inductively from well-typed and well behaved subterms will prove \nto be a key problem for proving confluence. Our proof will rely on reasoning about /Lnormal-forms. As \nan application of the theory, we will develop a macro expansion algorithm for a simple A-calculus-based \nlanguage and verify its correctness. Th~ application is of interest because one would like to think of \nmacros as inessential ab\u00adstractions of patterns of syntax. One way to characterize this is to say that \ntheir expansion can be interleaved with term reduction without afecting the outcome. It is well\u00adknown \nthat thw property often fails for macro systems that introduce bhding occurrences of variables. As an \nexample, consider the simple Or macro: Or P Q ~ (Xz.if x then x else Q)P, (6) An unintended variable \ncapture can occur on expanding (Or MI M2) whenever x E FV(MZ ) and it is then easy to see that expan\u00adsion \ncannot be interleaved with term reduction. A concrete example is: (Xz.(Or False z)) True in which (naive) \nexpansion of the macro followed by ~\u00adreduction results in False while performing the fl-redex first results \nin True. it solves the aforementioned problems using only the familiar capture avoiding substitutions. \nThe remainder of this paper is organized as follows. In Section 2 we introduce well-behaved terms and \nillustrate some of their properties with examples. In Section 3 we prove the confluence theorem. In Section \n4 we develop the macro expansion algorithm and prove its correctness using the main theorem. In Section \n5 we compare the present work with related work, emphasizing the connection to [Bar91, Mog92b, Wan93] \nand to [Gri88]. Section 6 sketches some future lines of research. Detailed prooik can be found in [Mu193]. \n 2 Well-Behaved Terms 2.1 Preliminaries Let Var = {z1, ZZ., . . .} be a countable set of variables. We \nuse the symbol A for the set of terms: A::= z I~z.A IAA We use M z N to denote a-congruent terms. Let \nR = {(M, N) I conditions} be a reduction relation. We use R-nf(M) to denote the R-normal-form of M and \n+Jz , ++R and =R to denote the one-step, many-step and congruence relations (resp.) generated by R. Let \nP be a property of terms. We use the notation PR(M) to mean that P holds for all M un\u00adder R-reduction. \nContexts C[.] are defined in the usual way. We will often use the standard combinators 1 s Ax .Z, K = \nAzy.z, S z Azyz.z.z(yz) and $2 s (Az.zz)(~z.zz) for illustration. We use M1 to denote Mogensen s representation \nof M which is presented in Section 1. We note that r.7 is an injec\u00adtive higher-order abstract syntax, \nthat MT is a /?-normal\u00adform and that FV(rM ) = FV(Af), where FV(M) denotes the free variables of M. \nThe notion of reduction /37 is as defined in (2). From the remarks above we have the following properties \nof /37. Lemma 1 1. The relation /31 ia Church-Rosser. .2. For M, N G A, M =$N H Mq =rp~rNT. The main \nobject of interest in thw paper is /32 as defined in (3). As we illustrated in Section 1, ~2 is not confluent \non unrestricted terms. 2.2 Representation Types In thw section we develop a type discipline to rule \nout inf\u00adormed terms. The type expressions are given by: r ::=dlr+r where the type constant d denotes \ndynamic. We will use the symbol r to denote an arbitrary representation type and occasiondy TM to denote \nany type expression assignable to term M. Our expansion algorithm is of interest not only because it \nThe definition of well-typed terms is given in terms of is quite explicit about term representation but \nalso because /?-convertibtity. Definition 1 (Well-Typed) For M 6 A we define M : T as follows: 1. M :d% \n3N cA,suchthat M =p N1. 2, M:u+riff Mianotoftype dad VN:U,MN:T. We say M is well-tgped iff there exists \na r such that M :7. Given M and r, it is obviously undecidable whether M : r.  2.2.1 Examples In Figure \n1 we present several examples to illustrate prop\u00aderties of well-typed terms. In (7), XC.S has type r \n+ r for any type r. This, reflects the usual polymorphism of J-terms. (8) is an expander function for \na let macro taken from the macro system presented in Section 4. The expan\u00adsion function produces a representation \nof an application when applied to appropriate representations of the parts of a use of the macro. (9) \nis the ill-formed case from (4) that motivated the type system. (10) illustrates that well-typed terms \ncan have ill-typed subterms. (11) is the well-typed but badly-behaved case from (s). We wish to stress \nthe importance of the restriction % not of type d in the definition of higher type. The restriction is \nrequired to preserve important properties of the calculus. Without it, the subject reduction property \nfails a prop erty on which our confluence proof depends. Consider the term Az.yl s ~ahc.c(k.r~n). Without \nthe restriction it is easy to see that the term has the following incompatible types: It is straightforward \nto construct a similar term with /3l\u00adredexes (e.g., ( Az.y)(Az.y)l) whose higher type is not pre\u00adserved \nunder @T-reduction. 2.2.2 Properties of Well-Typed Terms We briefly consider some properties of well-typed \nterms. Strong normalization obviously fails for both ,8 and ~z (e.g., W_ f11i2). The same example also \nshows that M will not in general have a /32-normal-form. However, well-typed terms do have the weak-normalization \npropert y. Lemma 2 (Weak Normalization) If M : r then M has a ,&#38;normal-form. 2.3 Well-Behavedness \nAs we have stressed, well-typedness is not a strong enough condition to guarantee the integrity of staged \nexecution. The example in (5) has two distinct /32-normal-forms: K1 and ST. We now define an additional \ncriterion, well be\u00adhavedness, with the intention of ruling-out such terms. We begin by reviewing the \nnotion of a self-interpreter (or enumemtor) first introduced by Kleene [Kle36]. Theorem 1 (Kleene) 3E \ne A, s.t, VM EAe, E M?=@ M. For Mogensen s representation, such an enumerator is quite simple: E s Y(Aem.m(Az.z) \n(Am.) (Andv.e(nav))) We will make use of the enumerator in defining an equiv\u00adalence relation on terms \nof base type. Two terms will be con\u00adsidered equivalent if and only if their /3-normal-forms denote equivalent \nrun-time code. M= Niff M:d, N:dand EM=BEN. From lemma 1 (part 2) and the definition we have: Lemma 3 \nFor all M, N, if M =rPlrN1 then M z N. The converse obviously does not hold. We can now give the key \ndefinition. Definition 2 (Well-Behaved) 1. M is well-behaved at d if M : d and VC[.], N1 : d s.t. M = \nCIN1], VN2, s.t. NI x N2, CINI] = C[N2J. 2. M is well-behaved at u * r iff M :a -+ r and for all well-behaved \nN : u, MN : r is well-behaved.  M is well-behaved if M is well-behaved at r for sll r such that M :r. \nThe intuition behind 1. is that given CIN1] : d, a translator ought to be able to replace the code fragment \nIVl : d with any equivalent (and hopefully more efficient ) code fragment N2 : d. 2. reflects the naturaJ \nhigher representation type of any translator. Examples 1. k .Z is well-behaved. 2. ~z.z1 is well-behaved. \n 3. (-4rnn.Aabc.b(Aabc. ck. (n z ))rn) is well-behaved. 4. KrP(r(Ati.v)wlz) is well-behaved. 5. I ~l(kn.rI1)(hrm. \nrK1)(Am.rS1) is not well behaved.  It is obviously undecidable whether a given term M is well behaved. \nLemma 4 (Subject Reduction) If M : r is well-behaved and M ++B2 N then N :r. Ax.x T-+T (7) (Arnn.Aabc.b(Aabc. \ncAz.(n zl))m) : d+(d+d)-+d (8) r(kl.o)wlz has no type (9) Krly(k.v)zo%) :d (lo) r~ Il(Am.rIl)(Amn. rKl)(Am.rsl) \n:d (11) Figure 1: Example Terms and their Types 3 Confluence of Well-Behaved Terms We now turn to the \nmain result of the paper: confluence for well-behaved terms under &#38;reduction. Unfortunately, most \nof the usual methods for proving confluence of rewrit\u00ading systems are of no help for the &#38;-calculus. \nThe general results of Klop [K108o] for regular term rewriting systems do not apply because .L?Zis not \nregular: ~ and /31 interfere with one-another. The Hindley-Rosen lemma [Bar84], (i.e., the union of commutative \nCR reduction relations is CR) doesn t apply because, although both ,6 and /3, are CR, /31 does not commute \nwith /3 on well-behaved terms (for ex\u00adample, K r M1 (r (AU. W)WIZ). ) Similar problems arise with development \nbased proofs. The key problem is that the relations M : r and M : ~ is well-behaved are not defined in \nsuch a way that there is an obvious basis for reasoning by induction on the structure of terms or on \nthe lengths of reduction sequences. One impor\u00adtant consequence of the definitions is that the relation \n~1 is not substitutive. That is, for well-behaved M : r, M +re~ M # M[z := N] +rpl M [z := N]. The definition \nof well-behavedness is given in terms of ~-normzd-forms and so our proof of confluence relies on rea\u00adsoning \nabout P-normal-forms. We will require the following two lemmas. Lemma 5 If MO : r is well-behaved and \nMO =p, M. then M. i8 well-behaved. Proof: The proof is by induction on T and on why MO =~2 M.. Lemma \n6 If MO : r is well-behaved and Mo =~2 M. then P-nflMo) =rP@-nfiM~). Proof: (Sketch) The proof is by \ninduction on r and on why M. =P2 M.. We briefly consider the base case. Let T = d, and consider why Mo \n=B2 M.. The non-trivial case is MO =~2 M. because MO -+p2 M=. We proceed by induction on n. For n = 1 \nlet C[.], NO and N1 be such that MO s cINo] and Ml s cIN1] where (No, Nl) G 92. If (No, Nl) E ~, then \nB-nf(Mn\\ and &#38;nf(M, ) are identical and the result , is immedi~te. ,If (No, if;) z /31, then since \nMO is well\u00ad behaved, and NO % iVI, MO = Ml. Let M; E /?-nf(M,). Then MO -Ml iff EMo =pEMl iff ErM; l \n=PErM; l 3 M; =PM; iff /3-nf(Mo) =rB-i/3-nf(Ml). For n >1, MO ++~2 M.-I -p, M. and by the induc\u00adtion \nhypothesis /3-nf(MO) =rP-@-nf(M~-l ). If M.-1 -+6 M. the result follows from the induction hypothesis. \nIf Mm-1 -wbq Mm the result follows by the same reasoning aa in the base case noting that Mn-1 is of type \nd by lemma 4 and well-behaved by lemma 5. Theorem 2 (Confluence) If M : T is well behaved, then VM1, \nM2 such that M ++P2 Ml and M +p2 M2 there ex\u00adists an M3 such that Ml *P2 Ms and M2 +~2 M3. Proof: By \nlemma 2, M, Ml and Mz all have &#38;normal\u00adforms which, by lemma 6, are /31-convertible. Confluence then \nfollows by two applications of lemma 1. 4 Well-Behaved Macro Expansion In thw section we present a simple \nA-calculus based language with syntax extensions and an algorithm for expanding in\u00adstances of defined \nnotation. It seems natural to view such an algorithm as being correct if expansion of defined notation \ncommutes with reduction on terms. As we illustrated in Sec\u00adtion 1, naive expansion fails to satisfy this \ncriterion because unintended captures of free variables can occur during naive expansion. Thk problem \nhas been taken up many times be\u00adfore [KFFD86, Gri88, CR91, BA92] and [Car93]. We will compare our approach \nwith some of these in Section 5. In most respects our approach will be the usual one for macro expansion: \ninstead of the translation process depicted in (I) in which the front-end of the translator has produced \na $normal-form M 1, thefront end produces a term Mo in which definitions of macros are represented by \nexpansion functions and uses of macros are represented by applications of the expansion functions to \nrepresentations of the parts of the macro use. The translation process can then be seen as: T MO -HB \nT M1 -p M l, where all macro calls in MO can be fulIy expanded by /r\u00adeduction yielding the ~-normal-form \nr M1 and the com\u00adpiler then produces the representation of the object program i_Mll+ 4.1 Preliminaries \nThe grammar for our language C is defined in Figure 2. The symbol x denotes a set {ZI, mz,...} of object \nvariables and ... u denotes a dwjomt set of pattern variables {WI, V2, ,.. } to\u00adgether with the special \nsymbol c which denotes empty (i.e., A o\u00ad..\u00ad x I AA I Az.A lIet-syntax Din A I U I w D .. .. v WV . \n. . ~A u ::= VA . . . Figure 2: Grammar for L. no variable). The symbol z denotes either an object vari\u00adable \nor a pattern variable. D denotes a syntax dejhition and U denotes a use of the defined notation. The \nellipses A.. ? denotes a sequence of A s. The language provides for lexically nested macro definitions. \nThus, a use U will be meaningful only as a subterm of A in let-syntax D in A. Similarly, a pattern variable \nv is meaningful only in a macro definition.l Following Griffin, we use superscripts v to denote bind\u00ading \npatterns within definitions. For example, in: let vi = vzinv~ ~ (M, .V3)V2. (13) the superscript V1 \nin V3 1 indicates that free occurrences of the variable that w is bound to that occur in the expres\u00adsion \nthat V3 is bound to will ultimately be bound by the corresponding variable on the right-hand side. We \nrefer to such superscripts as scope variables. While our language al\u00adlows only a single scope variable, \nit is easy to extend the algorithm to sets of variables V{ l o k].) We are making a number of other \nsimplifying assump tions that set aside problems that we are not attempting to solve here. For example, \nconstant symbols and/or literal strings are important for making macros readable, however, we have not \nincluded them here (and use object and pattern variables informally as constants) to keep the equations \nsim\u00adple. Similarly, we are not addressing the problems of parsing the concrete syntax (but see [Car93, \nhfu189]) or problems of programmers specifying compile-time computations over represent ations backquote. \nThe algorithm will translate terms relative to an envi\u00adronment V ::= ~ I v[A/v] that binds pattern variables \nv to values A. Environments have the following behavior: c(v) =c   { f(v) d4v ](v) s %e;;ise. We \nwill find it convenient to retain to two kinds of values in v: A ::= (F~, (ii, ~l),..., (;k, ~k)) I Vv, \nwhere Fk denotes a k-ary expansion function and i, j are integers that are included to facilitate construction \nof the application that will expand a use of the macro. Finally, we will find it convenient to adopt \nthe following two conventions. First, for sJI Vvi in which vi E c, i = O. Intuitively, i is the index \nof a variable so the convention says that the empty variable has no index. Second, we use the non-standard \nnotation AM; .Mi. In such contexts M; 1StfictlY speaking, we are also using them as identifiers of m$-= \nin uses.This pun allows us to avoid introducing new syntactic cate gories and keep the equations simple. \ndenotes either a (non-empty) variable z, or, if i = O, then AMi .hfj denotes Mj. These conventions will \nsimplify the key equations of the algorithm. 4.2 The Expansion Algorithm The translation algorithm is \ngiven in Figure 3. From the definition it is easy to see that if M has no macro uses then [M]q is in \n/l-normal-form (14) through (16) yield a Mogensen representation. The translation of a Iet-syntaz form \n(17) results in the translation of M in the environment obtained by translating the definition D. The \ntranslation of a definition (18) extends the environ\u00adment by binding the leftmost symbol of the definition \nto the appropriate expansion function together with pairs of indices (ij,, jl), 1 <1< k. The body of \nthe expansion func\u00ad tion is determined by the translation of the right-hand side of the definition in \nan environment in which the k parameters of the function are bound to their scope variables. (These will \neventually be looked up in (20). ) The pairs (ijl, jI ), are packaged-up with the expansion function \nso that they can be used in translating a use of the defined notation. The index ~1 gives the position \nin a use of the lth argument to which the expansion function will be applied. If the index ij, = O then \nthe jl th term in the use is not within the scope of any variable in the macro use. If ijl # O then the \nj~th term is in the scope of the variable at index ij,. Turning to the translation of a macro use (19), \nthe algo\u00adrithm produces an application of the k-ary expansion func\u00adtion associated with the leftmost \nsymbol v to k arguments. For 1< J < k, the ith argument is written as an abstraction XM,jl .fMjl]q where \nthe formal parameter Mij, is deter\u00admined by the index * described above. When ijl # O, Mj, is in the \nscope of variable itf~jl and the abstraction will ul\u00ad timately be applied to the representation of the \nappropriate variable (thus performing the capture). When ij, -= O, no capture was specified in the definition \nand by our convention JMijl .[Mj1]7 is sirnpb [Mjl]q. Fhmlly, the last clause (20) gives the translation \nof a pattern variable v. If q(v) = v , for some v # ~ then a capture was specified for v in the corresponding \ndefinition and v is applied to the representation of v . If q(v) = c then no capture was specified and \nno application is generated. As we will show, the algorithm constructs a representa\u00adtion of the specified \nbinding pattern using only abstraction, application and the familiar capture avoiding substitution. Recall \nthat the key clause is: (Jz.M)[y := iv] s (AZ.M[Z := Z][y := N]) (21) where z + y and z is unique. The \nbasic technique was first suggested to us by Pat O Keefe [0 K92]. Aabc.az Aabc.b([M]q)([N]~) /labc.c(Az.[M]9) \n[M]([D]q) (14) (15) (16) (17) d(AvJ, 0.. vjk . [Ml(9[rv,jl /vJl] . . . rv,jk (~k AMij, .[MJ1]v . . . \n~~ijk .[M~k]I,I) where ~(V) = (Fk, (~JI , i), . . . . (~jk,~k)) if q(o) S V l then vrv l else v /v~k]),(i~i,~l), \n. . . . (~~k,~k))/v] (18) (19) (20) Figure 3: The Macro Transcription Algorithm  4.3 Example The following \nexample illustrates the algorithm s method of effecting desired captures while avoiding undesired captures. \nIn the example we will feel free to use M, N, . . .. and even z as pattern variables and we will continue \nto be rather informal with constants (using = and in for example as term constants.) We will also assume \nthe existence of a conditional M ~ M, M. D1 S letz = M inN ~ (kz.N)M D2 E or PQ~(letz = Pin(z -+z, Q)) \nu z (or(11) %) ME let-syntax D1 in let-syntax Dz in U Let let s (Amn.Aabc.b(Aabc. cAz.(n zl))m). We \ncom\u00adpute: [Dl]c = e[(let , (O, 3), (1, 5))/let]. Let or s (Apg.(let p (Xz.z +1x, q))). Then iD21(tID11L5) \n= ([~l]&#38;)[(Or , (0, 1), (0, 2))/01]. Note that the application of n to Z1 in let together with the \nabstraction over z in or jointly effect the capture specified in the definition of D1. The translation \nand expansion then proceed as in Figure 4. Note in (22) that the normal replacement rule for capture \navoiding substitution (21) prevents the capture of z in the call by the binding inst ante of z int reduced \nin the defini\u00adtion of Dn. Also note that in (23), the usual a-conversion again takes place converting \nAz.(n Z1) to ~z .(n Z l) a ~ortiori, in Mogensen s higher-order abstract syntax, a-conversion is performed \nacross representation levels. Fi\u00adnally, the book-keeping @-reduction is performed in (24) that effects \nthe capture specified in the definition of D1.  4.4 Correctness Our correctness criterion is that macro \nexpansion should commute with &#38;reduction on t-terms. Theorem 3 (Correctness of Macro Expansion) \n[.1 is cor\u00adrect. Proof: (Sketch) By the confluence theorem, it suffices to show that for all M c L, [M]c \nis well-behaved. We first show that for all M E L, [M]e : d. We then show by in\u00adduction on fM~e that \nfor all C1.1, N] : d such that CIN1l = 5 Related Work The work described here is closely related to the \nsyntactic approaches to self-interpretation studied in [Bar91] and self\u00adinterpretation and partial evaluation \ndeveIoped in [Mog92b] and [Wan93]. Following Gomard [Gom90], the latter two papers present type systems \nthat compute a binding-time analysis as a preprocessing phase of a partial evaluator. The analysis yields \na set of constraints on an annotated type inference tree. Those redexes with static annotations can be \nreduced statically whale those with dynamic annotations cause the partial evaluator to emit residual \ncode. The main result of ~an93] is a soundness theorem verifying the cor\u00adrectness of the staging transformation \nfor well-typed (well\u00ad annotated) terms. Let us outline some of the differences between this ap preach \nand that presented in thw paper. First, setting aside well-behavedness, the intention behind the type \nsystem de\u00adveloped here is that it give the weakest conditions that en\u00adsure that terms are sufficiently \nwell-structured. Over and above the requirement that terms be well-typed, we have the additional requirement \nthat ensures that a term is not only well-structured but that it also respects the run-time equational \ntheory. As we have noted, this property is also undecidable. We have not considered recursive types in \npart because our confluence result relies on weak normalization. It may be possible to obtain a confluence \nproof using logical rela\u00adtions, however, this would require a structural type system. Unfortunately, \nthe natural axiom would be i- mT : d which is obviously much weaker than our base type condition. The \napplication of the theory to macro expansion is closely related to (and to some extent was inspired by) \nGriffin s work [Gn88]. To the best of our knowledge, Griffin was the first to suggest commutativity as \na correctness criterion for macro expansion. Griffin s framework was expressed in terms of the simply-typed \nA-calculus extended with pairs. We share the use of higher-order abstract syntax to prevent unintended \ncaptures of free variables. One technical diifer\u00adence is that we have used explicit representations of \nterms whereas Griffin has adopted the representation framework from [HHP871 in which the source language \nis represented by adding an appropriate set of base types and constants. Another technical difference \nbetween our approaches is that Griffin used capture permitting substitutions to effect in\u00adtended captures \nwhereas we have used what we believe is a somewhat more dkect method. [M~ = [(or (11) z)]([~z](fm)) \n= ((,lpg.(let p (kv.z -+1 z, g))) (I 1)1 21) ~p (let (l 1)1 (Az .z +1 z , rzl)) (22) = ((hnn.~abc.b(~abc. \nc~z.(n zl))m) (I 1)1 (Az .z +1 z , Z1)) ~p ~abc.b(~abc.c~z . ((~z .z -+1 Z , 21) 2 1)) (] 1)1 \n(23) -p Aabc.b(Aabc.cAz . rz q +1 z ~, X1) (I 1)1 (24) ~ r ~zlt.zt~( + z ,z)(11)1 Figure 4: A Sample \nMacro Expansion Whale Griflin s work is in many respects more general than ours, the present work does \ncontribute a somewhat more general correctness criterion. Griffin develops an ex\u00adpansion algorithm 7: \nand proves that under the algorithm, expansion of notational definitions commutes with reduc\u00adtion on \nterms. He then takes the algorithm as a correctness criterion any other algorithm is correct if it agrees \nwith F: on all inputs. Our criterion well-behavedness is independent of any particular expansion algorithm. \nRather, it is directly tied to the notion of commutativity. Well\u00adbehavedness can therefore be used to \nprove the correctness of a larger class of macro expanders. For example, Grif\u00adfin s criterion would exclude \nany expander that attempted to perform ~-reduction statically. The notion of hygienic [KFFD86] macro \nexpansion has been widely adopted in the Scheme community as a correct\u00adness criterion for macro expansion. \nAn expansion algorithm is said to be hygienic if it respects the following hygiene condition [KFFD86]: \nGenerated identifiers that become binding in\u00ad st antes in the completely expanded program must only bind \nvariables that are generated in the same transcription step. The classical hygienic expansion algorithm \nsatisfies this con\u00addition by repeatedly a-converting variables during each tran\u00adscription step. While \nthe approach taken in the algorithm of the pre\u00adceding section using capture avoiding substitution has \na su\u00adperficial correspondence with the repeated cr-conversion of hygienic expansion, we emphasize that \nthe approaches are actually quite different. Hygienic expansion is usually used in the context of S\u00adexpression \nbased dialects of LISP. In these dialects, program fragments have no syntactical interpretation until \nall enclos\u00ading macro calls have been fully expanded. Thus, it is not clear how one can sensibly view \nmacro expansion as being interleaved with run-time reduction. Its also worth noting the connection between \nth~ prop\u00aderty of S-expression LISP and the apparent gap in the defini\u00adtion of the hygiene condition \nwhile the condition prevents capture of free variable occurrences generated in one tran\u00adscription step \nby binding occurrences generated in another step, it makes no reference to variable occurrences generated \nin different bhding contexts in the same transcription step. Let us consider a simple example. let-syntax \n(rnac a (b c d)) + (b c a) in ((lambda (x) (rnac x (lambda (x) e))) Y) Expanding the macro (hygienically) \nfirst, we get --> J4acro ((lambda (x) (lambda (x) x)) y) -->-Beta (lambda (x) x) But performing the ~-reduction \nfirst it appears that we would get: -->-Beta (Mac y (lambda (x) e)) -->-Macro (lambda (x) y) However, \nin S-expression LISP, the occurrence of the symbol x within the macro call is not taken as a variable \nand thus it is not bound by the left-most binding instance of x and both orders produce the same result. \nSo the correctness of hygienic expansion is tied in some sense to thw particular property of S-expression \nLISP. While S-expressions provide for great expressive power for macro writers in terms of picking apart \npieces of syn\u00adtax, unfortunately, it leaves the macro user with only fairly weak assurances that their \nintended binding patterns will be preserved during expansion of their notational abbrevi\u00adations. We believe \nthat the classical S-expression syntactic structure is insufficient to ensure under reasonable condi\u00adtions \nthat macro expansion does not interfere with ordinary reduction in the sense that we have emphasized. \n6 Future Work Our definition of well-behavedness requires that a term M be well-behaved at r for all \nr such that M : r. It would be desirable if the well-behavedness of a polymorphic term could be inferred \nby its well-behavedness at a particular type along the lines of [Abr86]. We would like to come to a better \nunderstanding of the connection between the type system presented here and the two-level type system \nof [NN88]. We would also like to better understand the notion of staged reduction with other representation \nschemes such as that presented in [BB92]. We hope to apply the current frame\u00adwork to the verification \nof Mogensen s self-applicable par\u00adtial evaluator. Finally, it would be interesting to consider whether \nthe equality condition could be weakened to allow a translator somewhat wider leeway in substitution \nof terms. Acknowledgements The author would like to thank Mitch Wand and the mem\u00adbers of hii semantics \nseminar for their valuable feedback. The author would rdso like to thank Tom Cheatham for hu insight \nand support. Thanks to Pat O Keefe for many long conversations about macros and valuable feedback on \nan earlier draft of th~ paper. Thanks to Allyn Dimock and Neil Jones for directing me to Mogensen s work. \nReferences [Abr86] S. Abramsky. Strictness analysis and polymor\u00adphic invariance. In Programs as Data \nObjects (H. Ganzinger and N. Jones editors), pages 1\u00ad 23. Spnnger-Verlag LNCS Vol. 217, 1986. [BA92] \nA. Bove and L. Arbtia. A confluent calculus of macro expansion and evaluation. In Proceedings of the \nACM Symposium on LISP and Functional Programming, pages 278-287, 1992. [Bar84] H. Barendregt. The Lambda \nCalculus Its Syn\u00adtax and Semantics. North Holland Press, Ams\u00adterdam, 1984. [Bar91] H. Barendregt. Self-interpretation \nin lambda cal\u00adculus. Journal of Functional Programming, 1 (2):229-234, 1991. [BB92] A. Berarducci and \nC. Bohm. A self-interpreter of lambda calculus having a normal form. In Proceedings of 1992 Conference \nof the European Association for Computer Science Logic, 1992. [Car93] L. Cardelli. An implementation \nof F<,. Tech\u00adnicsJ Report SRC Research Report 97, Digital Equipment Corporation, 1993. [CR91] W. Clinger \nand J. Rees. Macros that work. In Proceedings of the Eighteenth ACM Symposium on Principles of Progmmming \nLanguages, pages 155-162, 1991. [Gom90] C. Gomard. Partial type inference for untyped functional programs \n(extended abstract). In Pro\u00adceedings of the ACM Symposium on LISP and Functional Programming, pages 282-287, \n1990. [Gri88] T. Gritlin. Notational definition a formal ac\u00adcount. In Third Annual Symposium on Logic \nin Computer Science, pages 372-383, 1988. [HHP87] R. Harper, F. Honsel, and G. Plotkin. A frame\u00adwork \nfor defining logics. In Second Annual Sym\u00adposium on Logic in Computer Science, pages 194-204, 1987. [KFFD86] \nE. Kohlbecker, D. Friedman, M. Felleisen, and B. Duba. Hygienic macro expansion. In Pro\u00adceedings of the \nACM Symposium on LISP and Functional Programming, pages 151-161, 1986. [Kle36] [K108O] [Mog92a] [Mog92b] \n[hfu189] [Mu193] [NN88] [0 K92] [Wan93] S. Kleene. A-definabtity and recursiveness. Duke Journal of Mathematics, \n2:340-353, 1936. J. W. Klop. Combinatory Reduction Systems. PhD thesis, CWI, The Netherlands, 1980. T. \nMogensen. Efficient self-interpretation in lambda calculus. Journal of Functional Progmm\u00adming, 2(3):345 \n364, 1992. T. Mogensen. Self-applicable partisl evaluation for pure lambda calculus. In ACIU SIGPLAN \nWorkshop on Partial Evaluation and Semanticu-Based Progmm Manipulation (Charles Consel, Editor), pages \n116-121, 1992. R. Muller. M-LISP: A Representation Indepen\u00addent Dialect of LISP with Reduction Semantics. \nPhD thesis, Boston University, 1989. R. Muller. A staging calculus and its applicw tion to the verification \nof translators. Technical Report Cambridge 1, Apple Computer, 1993. F. Nielson and H. R. Nielson. Two-Level \nseman\u00adtics and code generation. Theoretical Computer Science, 56:59-133, 1988. P. O Keefe. Private communication, \n1992. M. Wand. Specifying the correctness of bmding\u00adtirne analysis. In Proceedings of the Twentieth ACM \nSymposium on Principles of Progmmming Languages, 1993. 137-143.  \n\t\t\t", "proc_id": "174675", "abstract": "<p>We develop a calculus in which the computation steps required to execute a computer program can be separated into discrete stages. The calculus, denoted &#955;<subscrpt>2</subscrpt>, is embedded within the pure untyped &#955;-calculus. The main result of the paper is a characterization of sufficient conditions for confluence for terms in the calculus. The condition can be taken as a correctness criterion for translators that perform reductions in one stage leaving residual redexes over for subsequent computation stages. As an application of the theory, we verify the correctness of a macro expansion algorithm. The expansion algorithm is of some interest in its own right since it solves the problem of desired variable capture using only the familiar capture avoiding substitutions.</p>", "authors": [{"name": "Robert Muller", "author_profile_id": "81407593283", "affiliation": "Apple Computer, One Main Street, Cambridge, MA", "person_id": "PP39030384", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/174675.177972", "year": "1994", "article_id": "177972", "conference": "POPL", "title": "A staging calculus and its application to the verification of translators (preliminary report)", "url": "http://dl.acm.org/citation.cfm?id=177972"}