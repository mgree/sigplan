{"article_publication_date": "02-01-1994", "fulltext": "\n A Needed Narrowing Strategy Sergio Antoy Rachid Echahed Michael Hanus Dept. of Computer Science IMAG-LGI \nMPI Informatik Portland State University CNRS Im Stadtwald Portland, OR 97207 F-38041 Grenoble D-66123 \nSaarbriicken U.S.A. France Germany antoy@cs .pdx. edu echahed@imag. f r michael@mpi-sb. mpg. de Abstract \nNarrowing is the operational principle of languages that integrate functional and logic programming. \nWe pro\u00adpose a notion of a needed narrowing step that, for in\u00adductively sequential rewrite systems, extends \nthe Huet and Lkvy notion of a needed reduction step. We de\u00adfine a strategy, based on this notion, that \ncomputes only needed narrowing steps. Our strategy is sound and complete for a large class of rewrite \nsystems, is op\u00adtimal w.r.t. the cost measure that counts the number of distinct steps of a derivation, \ncomputes only indepen\u00addent unifiers, and is efficiently implemented by pattern mat thing. Introduction \nIn recent years, most proposals with a sound and com\u00ad plete operational semantics for the integration \nof func\u00ad tional and logic programming languages [5, 10] were based on narrowing, e.g., [6, 1.5, 17, 19, \n37, 44]. Narrow\u00ading, originally introduced in automated theorem proving [46], solves equations by computing \nunifiers with respect to an equational theory [14]. Informally, narrowing uni\u00ad fies a term with the left-hand \nside of a rewrite rule and fires the rule on the instantiated term. Example 1 Consider the following \nrewrite rules defin\u00ad ing the operations less than or equal to and addition for natural numbers, which \nare represented by terms built with O and s; O<x -true RI s(X) < 0 -+ false R2 5(X) <S(Y) -X <Y R3 O+x+x \nR4 s(X) +Y -s(X +Y) R5 Permission to COPY without fee all or part of this material is granted provided \nthat the copies are not m8de or distributed for direct commercial adventaga, the ACM copyright notice \nend the title of the publication and ita date appear, and notice ie given that copying ia by permission \nof the Association for Computing Mnchinery. TO copy otherwise, or to republish, requires a fee end/or \nspecific permission. POPL 94-liT34, Portland Oregon, USA @ 1994 ACM 0-89791 -636-9B4fOOl ..$3.50 The \nrules of < will be used in following examples. To narrow the equation Z + s(0) N s(s(0)), rule R5 is \napplied by instantiating Z to s(X). To narrow the resulting equation, s(X + s(0)) = s(s(0)), R4 is ap\u00ad \nplied by instantiating X to O. The resulting equation, s(s(0)) w s(s(0)), is trivially true. Thus, {Z \n~ s(0)} is the equation s solution. A brute-force approach to finding all the solutions of an equation \nwould attempt to unify each rule with each non-variable subterm of the given equation. The result\u00ading \nsearch space would be huge even for small rewrite programs. Therefore, many narrowing strategies for \nlimiting the size of the search space have been pro\u00adposed, e.g., basic [25], innermost [15], outermost \n[12], outer [49], lazy [9, 36, 44], or narrowing with redun\u00addancy tests [3 I]. Each strategy demands \ncertain condi\u00adtions of the rewrite relation to ensure the completeness of narrowing (the ability to compute \nall the solutions of an equation.) Our contribution is a strategy that, for induct avely se\u00adquential \nsystems [1], preserves the completeness of nar\u00adrowing and performs only steps that are unavoidable for \nsolving equations. This characterization leads to the optimality of our strategy with respect to the \nnumber of distinct steps of a derivation. Advantages of our strategy over existing ones include: the \nlarge class of rewrite systems to which it is applicable, both the op\u00adtimality of the derivations and \nthe independence of the unifiers it computes, and the ease of its implementation. The notion of an unavoidable \nstep is well-known for rewriting. Or-thogonal systems have the property that in every term t not in normal \nform there exists a re\u00addex, called needed, that must eventually be reduced to compute the normal form \nof t~24, 30, 39]. Further\u00admore, repeated rewriting of needed redexes in a term suffices to compute its \nnormal form, if it exists. Loosely speaking, only needed redexes really matter for rewrit\u00ading in orthogonal \nsystems. We extend this fact to nar\u00adrowing in inductively sequential systems, a subclass of the orthogonal \nsystems. Restricting our discussion to this subclass is not a limitation for the use of narrowing in \nprogramming lan\u00adguages. Computing a needed redex in a term is an un\u00adsolvable problem. Strongly sequential \nsystems are, in practice, the largest class for which the problem be\u00adcomes solvable. Inductively sequential \nsystems are a large constructor-based subclass of the strongly sequen\u00adtial systems. After some preliminaries \nin Section 2, we present our strategy in Section 3. We formulate the soundness and completeness results \nin Section 4. We address our strat\u00adegy s optimality in Section 5. We compare related work in Section \n6. Our conclusion is in Section 7. Due to lack of space we omit the proofs of the theorems, but the interested \nreader will find them in [3]. 2 Preliminaries We recall some key notions and notations about rewrit\u00ad \ning. See [11, 29] for tutorials. Terms are constructed w.r.t. a given many-sorted sig\u00adnature Z. We write \nPar(t) for the set of variables occur\u00adring in a term t.Equational logic programs are gener\u00adally constructor-based, \ni.e., symbols, called constructors, that construct data terms are distinguished from those, called defined \nfuncttons or operations, that operate on data terms (see, for instance, the Equational Interpreter [40] \nand the functional logic languages ALF [19], BA-BEL [37], K-LEAF [16], LPG [6], SLOG [15]). Hence, we \nassume that K? is a constructor-based term rewrztmg system consisting of rewrite rules of the form 1 \n-+ r, where 1 is an innermost term, i.e., the root of ! is an operation and the arguments of 1 do not \ncontain any operation symbol. Substitutions and unifiers are defined as usual [1 1], where we write mgu(s, \nt) for the most general unajier of s and t. We write a < a [V] iff there is a substitution ~ with a (x) \n= ~(a(z)) for all variables z c V. Two sub\u00adstitutions n and a are independent on a set of variables V \niff there exists some z c V such that a(x) and o- (z) are not unifiable. An occurrence or positzon p \nis a path identifying a sub term in a term. t1Pdenotes the sub term oft at posi\u00adtion p, and t[s]P denotes \nthe result of replacing t 1P with s in t. A term rewriting system %? is orthogonal if for each rule 1 \n-+ r c 72 the left-hand side i does not contain multiple occurrences of one variable ( Ieft-iineartty) \nand for each non-variable subterm /lP of/ there exists no rule 1 -+ r E R such that llP and 1 unify (non-overlapping). \nA rewrite step t -+P, l-+. s is the application of the rule 1-r to the redez tlP, i.e., s = t[a(r)]P \nfor some sub\u00adstitution a with t]p= u(i).A term is in normal form if it cannot be rewritten. Functional \nlogic programs compute with partial information, i.e., a functional ex\u00adpression may contain logical variables. \nThe goal is to compute values for these variables such that the expres\u00adsion is evaluable to a particular \nnormal form, e.g., a constructor term [16, 37]. This is done by narrowing. Definition 1 A term t is narrowable \nto a terms if there exist a non-variable position p in t (i.e., t 1P is not a variable), a variant 1 \n-+ r of a rewrite rule in 7? with Var(t) n Var(l -+ r) = 0 and a unifier u of t1Pand 1 such that s= u(t[r]p).this \ncase we write t -P, In I+,, aS. If u is a most general unifier of tlpand i, the narrowing step is called \nmost generai. We write to~. tnif there is a narrowing sequence to ~p,, RI, ~1 1 P2, R2, c2 . ..+ t~withu \n=u~o. ..ouzool. P~,&#38;,u* Since the instantiation of the variables in the rule 1 -+ r by u is not \nrelevant for the computed result of a narrow\u00ading derivation, we will omit this part of a in the example \nderivations in this paper. Example 2 Referring to Example 1, A + B ~A,~,,{~W,(0),~~~} s(O + O) and are \nnarrowing steps of A + 1?, but only the latter is a most general narrowing step. Padawitz [42] too distinguishes \nbetween narrowing and most general narrowing, but in most papers narrowing is intended as most general \nnarrowing (e.g., [25]). Most general narrowing has the advantage that most general unifiers are uniquely \ncomputable, whereas there exist many independent unifiers. Dropping the requirement that unifiers be \nmost general is crucial to the defini\u00adtion of needed narrowing step, since these steps may be impossible \nwith most general unifiers. Narrowing solves equations, i.e., computes values for the variables in an \nequation such that the equation be\u00adcomes true, where an equatton is a pair t= t of terms of the same \nsort. Since we do not require terminating term rewriting systems, normal forms may not exist. Hence, \nwe define the validity of an equation as a strict equal\u00adity on terms in the spirit of functional logic \nlanguages with a lazy operational semantics such as K-LEAF [16] and BABEL [37]. Thus, a substitution \nu is a solutlon for an equation tN t iff u(t) and a(t )are reducible to a same ground constructor term. \nEquations can also be interpreted as terms by defining the symbol x as a binary operation symbol, more \nprecisely, one operation symbol for each sort. Therefore all notions for terms, such as substitution, \nrewriting, narrowing etc., will also be used for equations. The semantics of% is defined by the following \nrules, where A is assumed to be a right\u00adassociative infix symbol, and c is a constructor of arity 0 in \nthe first rule and arity n >0 is the second rule. CX5C -true C(Xl,..., Xn)XC(yl, Yn), Yn) ~ A;=l(&#38;zxfi) \ntrueAX -X These are the equalzty rules of a signature. It is easy to see that the orthogonality status \nof a rewrite system is not changed by these rules. The same holds true for the inductive sequentiality, \nwhich will be defined shortly. With these rules a solution of an equation is computed by narrowing it \nto true an approach also taken in A -LEAF [16] and BABEL [37]. The equivalence between the reducibility \nto a same ground constructor term and the reducibility to true using the equality rules is ad\u00addressed \nby Proposition 1. Our strategy extends to narrowing the rewriting no\u00adtion of need. The idea, for rewriting, \nis to reduce in a term only certain redexes which must be reduced to compute the normal form of t. In \northogonal term rewriting systems, every term not in normal form has a redex that must be reduced to \ncompute the term s nor\u00admal form. The following definition [24] formalizes this idea. Definition 2 Let \nA = t --+U,/+, t be a rewrite step of some term tinto t at position u with rule i ~ r. The set of descendants \n(or restduals) of a position v by A, denoted v \\ A, is I ifu=v, :V} ifu$v, v \\ A = {upfq such that rlP, \n= z} ifv=upq and llP=x, where z is a variable. The set of descendants of a position v by a rewrite derivation \nB is defined by induction as follows {v} if B= f), v\\B= { uve~l~ ~ \\ B if B = B B//, A position u of \na term t is called needed iff in every rewrite derivation oft to a normal form a descendant of tluis \nrewritten at its root. A position uniquely identifies a subterm of a term. The notion of descendant for \nterms stems directly from the corresponding notion for positions. A more intuitive definition of descendant \nof a position or term is proposed in [30]. Let tL t be a reduction sequence and s a sub term of t. The \ndescendants of s in t are computed as follows: Underline the root of s and perform the reduction sequence \ntL t .Then, every subterm oft with an underlined root is a descendant of s. Example 3 Consider the operation \nthat doubles its ar\u00adgument by means of an addition. The rules of addition are in Example 1. double(X) \n~ X + X R6 In the following reduction of double( O + O) we show, by means of underlining, the descendants \nof O + O. doubie(O + O) +L,~~ (O + O)+ (O&#38;O) The set of descendants of position 1 by the above re\u00adduction \nis {1, 2}.  3 Outermost-needed narrowing An efficient narrowing strategy must limit the search space. \nNo suitable rule can be ignored, but some posi\u00adtions in a term may be neglected without losing com\u00adpleteness. \nFor instance, Hullot [25] has introduced 6a\u00adsic narrowing, where narrowing is not applied at po\u00adsitions \nintroduced by substitutions, Fribourg [15] has proposed tnnermost narrowang, where narrowing is ap\u00adplied \nonly at an innermost position, and Holldobler [22] has combined innermost and basic narrowing. Narrow\u00ading \nonly at outermost positions is complete only if the rewrite system satisfies strong restrictions such \nas non\u00adunifiability of subterms of the left-hand sides of rewrite rules [12]. Lazy narrowing [9, 36, \n44], akin to lazy eval\u00aduation in functional languages, attempts to avoid un\u00adnecessary evaluations of \nexpressions. A lazy narrowing step is applied at outermost positions with the excep\u00adtion that inner arguments \nof a function are evaluated, by narrowing them to their head normal forms, if their values are required \nfor an outermost narrowing step. Unfortunately, the property required depends on the rules tried in following \nsteps, and looking-ahead is not a viable option. We want to perform only narrowing steps that are necessary \nfor computing solutions. Naively, one could say that a narrowing step t-+P,/_+r,t is needed iff p is \n~ a position of t,u is the most general unifier of t1Pand 1, and a(tlp)is a needed redex. Unfortunately, \na sub\u00adstantial complication arises from this simple approach. If t is a normal form, the step is trivially \nneeded. How\u00adever, some instantiation performed later in the deriva\u00adtion could <undo this need. Example \n4 Referring to Example 1, consider the term t = X < Y + Z. According to the naive approach, the following \nnarrowing step oft at position 2 would be needed, since X < Z is a normal form. This step is indeed necessary \nto solve the inequality if s(x), for some term x, is eventually substituted for X, al\u00adthough this claim \nmay not be obvious without the re\u00adsults presented in this note. However, the same step becomes unnecessary \nif O is substituted for X, as shown by the following derivation, which computes a more gen\u00aderal solution \nof the inequation without ever narrowing any descendant of tat 2. Thus, in our definition, we impose \na condition strong enough to ensure the necessity of a narrowing step, no matter which unifiers might \nbe used later in the deriva\u00adtion. Definition 3 A narrowing step t +P, B, ~ t is called needed or outemnost-neede \ncliff, for every q > u, pis the position of a needed or outermost-needed redex of q(t), respectively. \nA narrowing derivation is called needed or outermosi-needed iff every step of the derivation is needed \nor outermost-needed, respectively. Our definition adds, with respect to rewriting, a new di\u00admension to \nthe difficulty of computing needed narrowing steps. We must take into account any instantiation of a \nterm in addition to any derivation to normal form. Luckily, as for rewriting, the problem has an efficient \nsolution in inductively sequential systems. We forgo the requirement that the unifier of a narrowing \nstep be most general. The instantiation that we demand in ad\u00addition to that for the most general unification \nensures the need of the position irrespective of future unifiers. It turns out that this extra instantiation \nwould eventu\u00adally be performed later in the derivation. Thus we are only anticipating it, and the completeness \nof narrow\u00ading is preserved. This approach, however, complicates the notion of narrowing strategy. According \nto [12, 42], a narrowing strategy is a func\u00ad tion from terms into non-variable positions in these terms \nso that exactly one position is selected for the next narrowing step. Unfortunately, this notion of nar\u00ad \n rowing strategy is inadequate for narrowing with arbi\u00adtrary unifiers, which, as Example 4 shows, are \nessential to capture the need of a narrowing step. Definition 4 A narrowing strategy is a function from \nterms into sets of triples. If S is a narrowing strategy, t is a term, and (p, 1 --+ r, u) G S(t), then \np is a position of t,1-+ r is a rewrite rule, and u a substitution such that t-+P,/+,,.u(t[r]p)a narrowing \nstep. is We now define a class of rewrite systems for which there exists an efficiently computable needed \nnarrowing strat\u00adegy. Systems in this class have the property that the rules defining any operation can \nbe organized in a hi\u00aderarchical structure called definitional tree [1], which is used to implement needed \nrewriting. This note gener\u00adalizes that result to narrowing. The symbols branch, rule, and exempt, used \nin the next definition, are uninterpreted functions used to clas\u00adsify the nodes of the tree. A pattern \nis an innermost term contained in each node. Definition 5 T is a partial definitional tree, or pdt, with \npattern m w.r. t. a constructor-based rewrite sys\u00adtem 72 iff one of the following cases holds: 7= branch(n, \no, TI, . . . . 7k), where T is a pattern, o is the occurrence of a variable of ~, the sort of ml~ has \nconstructors cl, ..., c~, for some k > 0, and foralliin {l,..., k}, Z is a pdt with pattern 7r[c~(Xl, \n..., X~)]~, where n is the arity of Ci and XI, . . . . X~ are new variables. T= rule(~, 1 + r), where \nr is a pattern and 1-r is a rewrite rule in K! such that I = x. T= ezempt(~), where r is a pattern and \n1$ ~ for every rule 1 + r in 7?. T is a dejinitionai tree of an operation f iff 7 is a pdt with f(X1, \n. . . . X.) as the pattern argument, where n is the arity of f and Xl, ....X~ are new variables. We call \ninductively sequential an operation f of a rewrite system 72 iff there exists a definitional tree 7 off \nsuch that the rules contained in 7 are all and only the rules defining f in %?. We call inductively sequential \na rewrite system Z? iff any operation of R is inductively sequential. Example 5 We show a pictorial representations \nof def\u00adinitional trees of the operations defined in Example 1. A branch node of the picture shows the \npattern of a cor\u00adresponding node of the definitional tree. A leaf node of the picture shows the right \nsides of a rule contained in a rule node of the tree. The occurrence argument of a branch node is shown \nby emboldening the corresponding subterm in the pattern argument. Y1 + Y2 0+Y2 S(Y3) + Y2 Y2 S(Y3 + Y2) \n05X2 S(X3) < X2 true S(X3) <0 S(X3) < S(X4) I false Inductively sequential systems are constructor-based \nand strongly sequential [1]. We conjecture that these two classes are the same. Inductively sequential \nsystems model the first-order functional component of program\u00ad ming languages, euch as ML and Iilaske!i, \nthat establish priorities among rules by textual precedence or speci\u00ad ficity [28]. We now give an informal \naccount of our strategy. The patterns of a definitional tree are a finite set par\u00adtially ordered by the \nsubsumption preordering and com\u00adplete in the sense of [23]. Let t = .f(tl, . . . . t~) be a term to narrow. \nWe unify t with some maximal element of the set of patterns of a definitional tree of ~. Let T de\u00adnote \nsuch a pattern, ~ the most general unifier of tand r, and T the pdt in which ~ is contained. If T is \na rule pdt, then we narrow r(t)at the root with the rule con\u00adtained in 7. If T is an exempt pdt, then \nr(t)cannot be narrowed to a constructor-rooted term. If T is a branch pdt, then we recur on ~(t I~), \nwhere o is the occurrence contained in T and r is the anttctpated substitution. The result of the recursive \ninvocation is suitably com\u00adposed with ~ and o. The details of this composition are in the formal definition \npresented below. We derive our outermost-needed strategy from a mapping, J, that implements the above \ncomputation. A takes two arguments, an operation-rooted term t and a definitional tree T of the root \nof t,and non\u00addeterministically returns a triple, (P, R, u), where P is a position of t,R is either a \nrule 1 -+ r of Ill or the distinguished symbol ? , and a is a substitution. If R = 1 + r, then our strategy \nperforms the narrowing step t-P,I+T,O u(t[~]p).If R = ?, then our strat\u00adegy gives up, since it is impossible \nto narrow t to a constructor-rooted term. In the following definition, pattern(7) denotes the pattern \nargument of T. Definition 6 The function A takes two arguments, an operation-rooted term t and a pdt \nT such that pattern(T) and t unify. The function J yields a set of triples of the form (p, R, a), where \np is a position of t,R is either a rewrite rule or the distinguished symbol ? , and u is a unifier of \npattern(7) and t.Thus, let t be a term and T a pdt in the domain of J. The func\u00ad tion J is defined by \nstrong arithmetical induction on the number of occurrences of operation symbols in tand by structural \ninduction on 7 in Figure 1. The function A is well-defined in the third case since, by the defini\u00ad tion \nof pdt, there exists a proper subpdt ~ of T such that pattern(~) and tunify if tlois constructor-rooted \nor a variable. Similarly, A is well-defined in the fourth case since this case can only occur if t 10 \nis operation\u00ad rooted. In this case ~var(t~ is a constructor substitution since T is a linear innermost \nterm. Since tis operation\u00ad rooted and o # A, r(tlo) has fewer occurrences of oper\u00ad ation symbols than \nt.Since tlois operation-rooted, so is ~(t 10). By the definition of pdt, pattern s ~(t 10), i.e., pattern \nand r(tl.)unify. This implies that J is well-defined in this case too. As in proof procedures for logic \nprogramming, we have to apply vartants of the rewrite rules wzth fresh var~ables to the current term. \nTherefore, we assume in the fol\u00ad lowing that the definitional trees contain new variables if they are \nused in a narrowing step. The computation of A(i!, 7) may entail a non-deter\u00administic choice when 1 \nis a branch pdt the integer i when t[0is constructor-rooted or a variable. The substi\u00adtution r when tlois \noperation-rooted is the anticipated substitution guaranteeing the need of the computed po\u00adsition. It \nis pushed down in the recursive call to A to ensure the consistency of the computation when t is non\u00adlinear. \nThe anticipated substitution is neglected when t10is not operation-rooted, since the pattern in z is \nan instance of r. Hence, a extends the anticipated substi\u00adtution. Example 6 We trace the computation \nof A for the ini\u00ad tial step of a derivation of X < Y + Z, which was dis\u00ad cussed in Example 4. A(X < \nY + Z, branch(Xl < x2,1, . .)) A(X < Y + Z, branch(s(X3) < X2,2,.. .)) A(Y + Z, branch(Y~ + Yz, 1,.. \n.)) A(Y + Z, rule(O + Y2, Rq)) (A, R,, {Y ~ O,YZ E+ Z}) (A, RA, {Y i-+ O,YZ ~ Z}) (2, R4, {X * s(X3), \nX2 ~ O+Z, Y ~ 07Yz ~ Z}) (2, R4, {X ~ s(xs),xz ~ O+Z, Y w O,YZ I-+ Z}) We are interested only in narrowing \nderivations that end in a constructor term. Our key result is that if ~, on input of a term t,computes \na position p and a substitu\u00adtion u, and q extends u, then q(t)must eventually be narrowed at p to obtain \na constructor term. Eventu\u00adally is formalized by the notion of descendant, which, initially proposed \nfor rewriting [24], is extended to nar\u00adrowing simply by replacing -+U, 1+~ with +U, 1+~, m in Definition \n2. Theorem 1 Let R be an ~nductively sequential rewrite system, t an opera tzon-rooted term, and T a \ndejintttona! tree of the root oft. Let (p, R, a) G A(t, T) and q extend IY, 2.e., ~ > u. 1. In any narrowing \nderivation of q(t) to a construc\u00adtor-rooted term a descendant of q(t/P) is narrowed to a constructor-rooted \nterm. 2. If R = i + r, then t *P,R,c u(t[r]P) 2s an outer\u00admost-needed narrowing step. 3. If R = ?, \nthen ~(t) cannot be narrowed to a con\u00adstructor-rooted term.  We say that a narrowing derivation is computed \nby A iff for each step t P,R,.t of the derivation, (p, R, u) belongs to A(t, T).The function A implements \nour nar\u00adrowing strategy as discussed next. The theorem shows (claim 2) that our strategy A computes only \noutermost\u00adneeded narrowing steps. The theorem, however, does not show that the computation succeeds, \ni.e., a narrow\u00ading step is computed for any operation-rooted, hence ex\u00adpectedly narrowable, term. This \nrequirement may seem essential, since to narrow a term all the way a strategy should compute a narrowing \nstep, when one exists. In\u00addeed, in incomplete rewrite systems, A may fail to com\u00adpute any narrowing step \neven when some step could be computed. (A, R, rngu(t, m)) if T = rule(m, R); (A, ?, rngu(f, T)) if T \n= exempt(m); (p, R, o) if T = branch(~, o,T1, . . ., Tk), t and pattern(z) unify, for some i, and A(t,7-) \n3 (p, R,u) c A(t, Z); (op,R,uo~) if T = branch(fi, o, Tl, . . . . Tk), t and pattern(~) do not unify, \nfor any i, 7-= mgu(t, n), T is a definitional tree of the root of r(tlo),and (p, R, u) G A(r(tlo), T \n). Figure 1: Definition of A Example 7 Consider an incompletely defined opera\u00ad tion, j, taking and returning \na natural number. f(o) -+ o The term t= f(s(f(0))) can be narrowed (actually rewritten, since it is \nground) to its normal form, f (s(0)). The only redex position of t is 1.1, but A returns the set {(l,?,{})}. \nThe inability of ~ to compute certain outermost-needed narrowing steps is a blessing in disguise. The \ntheorem (claim 3) justifies giving up a narrowing attempt as soon as the failure to find a rule occurs \nwithout further at\u00adtempts to narrow t at other positions with the hope that a different rule might be \nfound after other nar\u00adrowing steps or that the position might be deleted [7] by another narrowing step. \nIf (p,?, m) G A(t, T), no equation having u(t) as one side can be solved. Any amount of work applied \ntoward finding a solution would be wasted. This is an opportunity for optimization. In fact a(t) may \nbe narrowable at other positions different from p and an equation with a(t) as a side may even have an \ninfinite search space. However, any amount of work applied toward finding a solution would be wasted. \nExample 8 Consider the following term rewriting sys\u00adtem for subtraction: x o-+x RI s(X) s(Y) ~ X Y R2 \n This term rewriting system is inductively sequential and a definitional tree, T, of the operation - \nhas an ez\u00adempt node for the pattern O s(X), i.e., the system is incomplete and (A, ?, {}) G A(O S(X), \nT). Therefore we can immediately stop the needed narrowing derivation of the equation O s(X) x Y Z \nwhile there would be infinitely many narrowing derivations for the right-hand side of this equation. \nThe definition of our outermost-needed narrowing strat\u00adegy does not determine the computation space for \na given inductively sequential rewrite system in a unique way. The concrete strategy depends on the definitional \ntrees, and there is some freedom to construct these. For a discussion on how to compute definitional \ntrees from rewrite rules and the implications of some non\u00addeterministic choices of this computation see \n[1]. As we will show in Section 5, this does not affect the op\u00adtimality of our strategy w .r. t. computed \nsolutions. But in case of failing derivations a definitional tree which is unnecessarily large could \nresult in unnecessary deriva\u00adtion steps. E.g., a minimal definitional tree of the operation <c in Example \n8 has an ererrzpt node for the pattern O s(X). However, Definition 5 also allows a defini\u00adtional tree \nwith a branch node for the pattern O s(X) which has ezernpt nodes for the patterns O s(0) and O S(S(X1 \n)). Our strategy would perform some un\u00adnecessary steps if this definitional tree were used for narrowing \nthe term O s(t), where t is an operation\u00adrooted term. These unnecessary steps can be avoided if all \nbranch nodes in a definitional tree are useful, i.e., there is at least one rule node in each branch \nsubpdt. However, the non-determinism of the trees of certain operations makes it possible that some work \nmay be wasted when a narrowing derivation computed by A terminates with a non-constructor term. The problem \nseems inevitable and is due to the inherent parallelism of certain operations, such as %; this issue \nis discussed in some depth in [1, Display (8)]. The problem occurs only in terms with two or more outermost-needed \nnar\u00adrowing positions, one of which cannot be narrowed to a constructor-rooted term. 4 Soundness and \ncompleteness Outermost-needed narrowing is a sound and complete procedure to solve equations if we add \nthe equality rules to narrow equations to true. The following proposition shows the equivalence between \nthe reducibility to a same ground constructor term and the reducibility to true using the equality rules. \nProposition 1 Let R be a term rewriting system with\u00ad out rules for z and A. Let R be the system obtained \nby adding the equality rules to 1?. The following propo\u00ad stt~ons are equivalent for all terms t and t!: \n1. t and t are reducible m R to a same ground con\u00adstructor term. 2. t z t M reducible in R to true , \n The soundness of outermost-needed narrowing is easy to prove, since outermost-needed narrowing is a \nspecial case of general narrowing. Theorem 2 (Soundness of outermost-needed narrow\u00ad ing) Let %? be an \ninductively sequential rewrite system extended by the equality rules. If t z tl $0 true is an outermost-needed \nnarrowing derwation, then ~ M a solutton for t $3 t . Outermost-needed narrowing instantiates variables \nto constructor terms. Thus, we only show that outermost\u00adneeded narrowing is complete for constructor \nsubstitu\u00adtions as solutions of equations. This is not a limitation in practice, since more general solutions \nwould contain unevaluated or undefined expressions. This is not a lim\u00aditation with respect to related \nwork, since most general narrowing is known to be complete only for irreducible solutions [42], and lazy \nnarrowing is complete only for constructor substitutions [16, 37]. The following the\u00adorem shows the completeness \nof our strategy, A, and consequently of outermost-needed narrowing. Theorem 3 (Completeness of outermost-needed \nnar\u00adrowing) Let R be an inductively sequential rewrite sys\u00adtem extended by the equahty rules. Let o be \na con\u00adstructor substitution that M a solutton of an equatzon t c t and V be a finite set of variables \ncontai\u00adning Var(t) U Var(t ). Then there exxsts a derivation t E t SCJ true computed by A such that a \n< CT[V]. The theorem justifies our earlier remark on the rela\u00adtionship between completeness and anticipated \nsubsti\u00adtutions. Any anticipated substitution of a needed nar\u00adrowing step is irrelevant or would eventually \nbe done later in the derivation, and thus, it does not affect the completeness. Anticipating substitutions \nis appeal\u00ading, even without the benefits related to the need of a step, since less general substitutions \nare likely to yield a smaller search space to compute the same set of solu\u00adtions.  5 Optimalit y In \nSection 3 we showed that our strategy computes only necessary steps. We now strengthen this characteriza\u00ad \ntion by showing that our strategy computes only neces\u00ad sary derivations of minumum length. The next theorem \nclaims that no redundant derivation is computed by A. Theorem 4 (Independence of solutions) Let 72 be \nan inductively sequential rewrite system extended by the equality rules, e an equation to solve and V \n= Var(e). Let e ~. true and e ~vl true be two dwttnct derwa\u00ad tions computed by A. Then, u and CT are \nindependent on V. We now discuss the cost and length of a derivation computed by our strategy. If p is \na needed po$ition of some term t,then in any narrowing derivation of tto a constructor term there is \nat least one step associated with p. If this step is de\u00adlayed and p is not outermost, then several descendants \nof p may be created and several steps may become nec\u00adessary to narrow this set of descendants, e.g., \nsee Ex\u00adample 3. However, from a practical standpoint, if terms are appropriately represented, the cost \nof narrowing tat (some descendant of) p is largely independent of where the step occurs in the derivation \noft. We formalize this viewpoint, which leads to another optimality result for our strategy. Definition \n7 Let t --+P,,a, t ,for i in some set i,+r,,of zndices I = {l,...,n}, be a narrowing step such that for \nany distinct i and j in 1, pi and @ are dis\u00adjoint and Ui ov~ = ~~ oUi. We say that t is narrow\u00adable to \nt m a multistep, denoted t -{P,,lt.+~z,o~),el t , iff t = o ~E1 ui(((t[rl]P1 )[r2]P2) . . . [rn]P~), \nwhere o ~e~ a; denotes the composition Uri 0 ...0 U2 0 al (the order is irrelevant. ) When we want to \nemphasize the difference between a step as defined in Definition 1 and a multistep, we re\u00adfer to the \nformer as elementary. Otherwise, we identify an elementary step with a multistep in which the set of \nnarrowed positions has just one element. A narrowing multistep can be thought of as a set of elementary \nsteps performed in parallel. In fact, the conditions that we impose on the positions and substitutions \nof each ele\u00ad mentary step from which a multistep is defined imply that in a multistep the order in which \nsubstitutions are composed and positions are narrowed is irrelevant. To claim that our strategy is optimal, \nwe assign a (cost to both a step and a derivation. By convention, an elementary step has unit cost. However, \nit does not seem appropriate, for practical reasons, to set the cost of a multistep equal to the number \nof positions narrowed in the step. We will justify our choice after giving our definition of cost. For \nany set 1 and equivalence relation N on 1, Ill de\u00adnotes the cardinality of 1, and 1/-denotes the quotient \nof 1 modulo -. Definition 8 Let a = . . . be a narrowing @Pwfl +(P;,%)C:)ie12 J:)(EI, (multi) derivation. \nThe symbol -n denotes the equiv\u00adalence relation on In defined as follows: for any i and j in In, i -n \nj iff the subterms identified by these indices have a common ancestor, more precisely, there exists some \nrn, less than n, such that for some position q in tm, both o ~~~.+,~~+l(t~lpi+l) and o ~~~.+,~~+l(t~lp:+,) \nare descendants of o ~~1~+1 ~~+1 tm g ( 1) We call a fami/y any maximal subset of equivalent indices. \nThe cost of the n-th step of a is the number of families in In, i.e., lln/wm 1. The cost of a, denoted \ncost(a), is the total cost of its steps. We say that a family is complete iff it cannot be en\u00adlarged, \nand we say that a step is complete iff all its families are complete, more precisely, In is complete \niff if i is in In, then for any position q of o ~~~.u~+l(t~ l) such that p: and q have a common ancestor \nin some term of a, there exists some j in In such that q = @n. We say that a derivation is complete iff \nall its steps are complete. If I is the set of indices of a narrowing step and z and j belong to I, then \ni w j iff pi and pj are, using an anthropomorphic metaphor, blood related. A complete derivation is characterized \nby narrowing complete fam\u00adilies, i.e., sets containing all the pairwise blood related subterms of a term. \nNote that the blood related sub\u00adterms of a term are all equal and that their positions are pairwise disjoint, \nthus all of them can be included in a multistep. Our choice of cost measure is suggested by the observation \nthat if t--+P,and qand p are R,.t ,blood related positions, then narrowing tat q (when t is being narrowed \nat p involves no additional computa\u00adtion of a substitution and/or a rule, and consequently no additional \ncomputation of a substituting term (the in\u00adstantiation of the right side of a rule, ) since the reducts \nof blood related subterms are all equal, too. This im\u00adplies that all the members of a family could be \nshared in the representation of t.When this is being done (as in efficient implementations of narrowing \n[19]), a multi\u00adstep entailing a whole family does not differ, in practice, from an elementary step. Theorem \n5 If a = t AO u is a complete outermost\u00ad needed narrowing muit~derivation of a term t into a con\u00ad structor \nterm u, then a has minimum cost. I.e., for any muhiderivation /3 = t <o u, cost(a) s cost(@. Elementary \nsteps are easier to understand and to imple\u00adment than multisteps. To achieve optimality, we need multisteps \nonly as far as blood related terms are con\u00adcerned. Full sharing of blood related subterms implies that \nno family ever contains more than a single member, in practice, and thus any elementary step becomes \ntriv\u00adially complete. In turn, this equates derivations of min\u00adimum cost with those of minimum length. \nTechniques for rewriting terms with shared subterms go under the name of term graph rewriting [47] and \nadapting them to narrowing, for the systems we are considering, poses no major problem [4].  6 Related \nwork There are three research topics related to our work: (1) the concept of need as the foundation of \nlaziness, (2) strategies for using narrowing in programming, and (3) implement ations of narrowing in \nProlog. 6.1 Narrowing and need Seminal studies on the concept of need in rewriting ap\u00adpear in [24, 39]. \nSubsequent variations and extensions, e.g., [7, 21, 27, 30, 33, 40, 41, 45, 48], do not address nar\u00adrowing, \nbut limit the discussion to rewriting. We have introduced a concept of need for narrowing that extends \na similar concept for rewriting. We have shown that the concept of need for narrowing is inherently more \ncom\u00adplicated than that for rewriting. In orthogonal systems, a reduction step has one degree of freedom, \nthe selection of the position, but a narrowing step has two, both the position and the unifier. We have \ndiscussed only inductively sequential sys\u00adtems. Further research will extend this class to strongly sequential \nand/or weakly orthogonal systems. The ex\u00adtension to weakly orthogonal systems would weaken our strong \noptimality result, but include additional non-determinism. Sekar and Ramakrishnan [45] pro\u00adpose necessary \nsets as a generalization of the notion of need for weakly orthogonal systems. Antoy [I] sug\u00adgests rewriting \nnecessary sets of redexes using para!lel definitional trees and a function analogous to A. This approach \ncan be extended to narrowing without major problems. 6.2 Narrowing strategies The trade-off between \npower and etliciency is central to the use of narrowing, especially in programming. To this aim, several \nnarrowing strategies, e.g., [9, 12, 13, 14, 15, 16, 18, 20, 22, 31, 35, 36, 37, 38, 44, 49] have been \npro\u00adposed. The notion of completeness has evolved accord\u00adingly. Plotkin s classic formulation [43] has \nbeen relaxed to completeness w.r.t. ground solutions (e.g. [15]) or completeness w.r. t. strict equality \nand domain-based in\u00adterpretations, as in [16, 37]. The latter appear more ap\u00adpropriate for narrowing \nas the computational paradigm of functional logic programming languages in the pres\u00adence of infinite \ndata structures and computations. We briefly recall the underlying ideas of a few major strategies and \ncompare them with ours using the follow\u00ading example. We choose a strongly terminating rewrite system \nwith completely defined operations, otherwise all the eager strategies would be immediately excluded. \nExample 9 The symbols a, b, and c are constructors, whereas f and g are defined operations. f(a)-a RI \nf(b(X)) -+ b(f(X)) R2 f(c(X)) -+ a R3 Rq g(b(X), a) + a R5 g(b(X), b(Y)) -c(a) R6 g(b(X), c(Y)) -+ b(a) \nR7 9( C(X), Y) ~ ~(a) d~,x) + b(a) R8 The equation to solve is g(X, f(X)) w c(a). Our strat\u00adegy computes \nonly three derivations, only one of which yields a solution.   9(X) f(x)) %c(a) l, R., {xwcz} b(a)= \nc(a) 9(X, f(.~)) w e(a) l, R.s, {X++. (XI)} b(a) = C(U) 9(X, f(x)) = e(a) 1 2, Rz, {X+ b(X~)} g(b(X1), \nb(f(X1))) x c(a) ~{} true  Basic narrowing [25] avoids positions introduced by the instantiation of \nprevious steps. Its completeness, and that of its variations, e.g., [20, 22, 31, 35, 38], is known for \nconvergent rewrite systems (see [35] for a sys\u00adtematic study.) This strategy may perform useless steps \nand computes an infinite search space for our bench\u00admark example. Innermost narrowing [15] narrows only \ninnermost terms. It is ground complete only for strongly terminat\u00ading constructor-based systems with \ncompletely defined operations. It may perform useless steps and it com\u00adputes an infinite number of derivations \nfor our bench\u00admark example. Outermost narrowing [12, 13] narrows outermost operation-rooted terms. This \nstrategy is complete only for a restrictive class of rewrite systems. It computes no solution for our \nbenchmark example. Outer narrowing [49] selects an inner position only when a step at an outer position \nis impossible. This strategy is complete for constructor-based systems. Outer narrowing behaves as needed \nnarrowing on the benchmark example, however the strategy is not char\u00adacterized as computing needed steps. \nFurthermore, [49] describes the enumeration of derivations for E\u00admatching, but not the computation of \nderivations for general E-unification. Lazy narrowing [9, 16, 18, 37, 36, 44], similar to outer, narrows \nan inner term only when the step is demanded to narrow an outer term. For these strategies, the qual\u00adifier \nlazy is used as a synonym of outermost or de\u00admand driven, rather than in the technical sense we pro\u00adpose. \nThe completeness of these strategies is generally expensive to achieve: [18] requires an ad-hoc implemen\u00adtation \nof backtracking, with the potential of evaluat\u00ading some term several times; [16] requires flattening \nof functional nesting and a specialized WAM-like machine in which terms are dynamically reordered; [37] \nrequires a transformation of the rewrite system which, for our benchmark example, increases the number \nof operations and lengthen the derivations. To summarize, the distinguishing features of our strat\u00adegy \nare the following: with respect to eager strategies, completeness for non-terminating rewrite systems; \nwith respect to the so-called lazy strategies, a sharp char\u00adacterization of laziness; with respect to \nany strategy, optimality and ease of computation. 6.3 Narrowing in Prolog Implementations of narrowing \nin Prolog [2, 8, 26, 32] are proposed as a prototypical and portable integration of functional and logic \nlanguages. For example, [8, 26] have been proposed as an alternative to the specialized machines required \nfor K-LEAF [16] and BABEL [37] re\u00adspectively. The most recent proposals [2, 32] are based on definitional \ntrees and appear to compute needed steps for inductively sequential systems, although both methods neither \nformalize nor claim this property. The scheme in [2] computes } directly by pattern matching. The patterns \ninvolved in the computation of ~ are a su\u00adperset of those contained in a definitional tree. This is suggested \nby claim 1 of Theorem 1 that shows a strong need for the positions computed using J not only the terms \nat these positions must be eventually narrowed, but they must be eventually narrowed to head normal forms. \nThe resulting implementation takes advantage of this characteristic and its performance appears to be \nsuperior to the other proposals. 7 Concluding remarks We have proposed a new narrowing strategy obtained \nby extending to narrowing the well-known notion of need for rewriting. Need for narrowing appears harder \nto handle than need for rewriting to compute a needed narrowing step one must also look ahead a potentially \ninfinite number of substitutions. Remarkably, there is an efficiently algorithm for this computation \nin induc\u00adtively sequential systems. We have contained our discussion to narrowing oper\u00ad [3] ation-rooted \nterms. This limitation shortens our discus\u00ad sion and suffices for solving equations. Extending our results \nalso to constructor-rooted terms is straightfor\u00ad ward. To compute an outermost-needed narrowing step \nof a constructor-rooted term it suffices to compute an [4] outermost-needed narrowing step of any of \nits maximal operation-rooted subterms. We have shown how our strategy is easily imple\u00ad mented by pattern \nmatching, and we have reported, in the previous section, its good performance in Pro\u00ad [5] log with respect \nto other similar attempts. We have also shown that our strategy computes only indepen\u00ad dent and optimal \nderivations. Although all the previ\u00ad ously proposed lazy strategies have the latter as their [6] primary \ngoal, our strategy is the only one for which this result is formalized and proved. We want to conclude \nwith a general assessment of the overall quality of the narrowing strategy used by [7] a programming \nlanguage. The key factor is the trade-off between the size of the class of rewrite systems for which \nthe strategy is complete and the efficiency of its com\u00ad putations. We prove both completeness and optimality \nfor inductively sequential systems. We believe that it is possible to extend our result to strongly sequential \n[8] systems and, in a weaker form, to weakly orthogonal systems. [9] Acknowledgement Aart Middeldorp \nsuggested us how to prove [34] our conjecture that the classes of inductively sequential sys\u00ad tems and \nconstructor-based strongly sequential systems [10] are the same. We would like to acknowledge the support \nof The Oregon Center for Advanced Technology Education (OCATE) for parts of the collaborative efforts \nthat lead [11] to the writing of this paper. The research of Michael Hanus was supported in part by the \nGerman Ministry for Research and Technology (BMFT) under grant ITS 9103 and by the ESPRIT Basic Research \nWorking Group 6028 (Construction of Computational Logics). [12] References [13] ,[1] S. Antoy. Definitional \ntrees. In ALP 92?, pages 143\u00ad 157. Springer LNCS 632, 1992. [2] S. Antoy. Lazy rewriting in logic programming. \n[14] Technical Report 90-17 , Rev, 2, Portland State University, Portland, OR, 1992. (Submitted for publication). \n S. Antoy, R. Echahed, and M. Hanus. A needed narrowing strategy. Technical report, MPI-I-93\u00ad243, Max-Planck-Institut \nfur Informatik, Saarbrii\u00adcken, 1993. H. Barendregt, M. van Eekelen, J. Glauert, R. Ken\u00ad neway, and M. \nSleep. Term graph rewriting. In PARLE 87, pages 141-158. Springer LNCS 259, 1987. M. Bellia and G. Levi. \nThe relation between logic and functional languages: a survey. Journal of Logic Programming, 3(3):217-236, \n1986. D. Bert and R. Echahed. Design and implementa\u00adtion of a generic, logic and functional programming \nlanguage. In ESOP-86, pages 119 132. Springer LNCS 213, 1986. G. Boudol. Computational semantics of term \nrewriting systems. In M. Nivat and J. C. Reynolds, editors, Aigebraac methods in semantics, chap\u00adter \n5. Cambridge University Press, Cambridge, UK, 1985. P. H. Cheong. Compiling lazy narrowing into Pro\u00adlog. \nNew Generation Computing, 1992. (to appear). J. Darlington and Y. Guo. Narrowing and unifi\u00adcation in \nfunctional programming -an evaluation mechanism for absolute set abstraction. In Proc. of the Conference \non Rewriting Techniques and Appli\u00adcations, pages 92 108. Springer LNCS 355, 1989. D. DeGroot and G. Lindstrom, \neditors. Logic Pro\u00adgramming, Functions, Relattons, and Equations. Prentice Hall, 1986. N. Dershowitz \nand J. Jouannaud. Rewrite systems. In J. van Leeuwen, editor, Handbook of Theoretical Computer Science \nB: Formal Methods and Seman\u00adtics, chapter 6, pages 243 320. North Holland, Am\u00adsterdam, 1990. R. Echahed. \nOn completeness of narrowing strate\u00adgies. In Proc. CAAP 88, pages 89 101. Springer LNCS 299, 1988. R. \nEchahed. Uniform narrowing strategies. In Pro\u00adceedings of the Third International Conference on Algebraic \nand Logic Programming, pages 259-275, Volterra, Italy, September 1992. M. J. Fay. First-order unification \nin an equational theory. In Proc. dth Workshop on Automated De\u00adduction, pages 161-167, Austin (Texas), \n1979. Aca\u00addemic Press. [15] L. Fribourg. SLOG: A logic programming lan\u00adguage interpreter based on clausal \nsuperposition and rewriting. In Proc. IEEE Internai. Symposium on Logzc Programrnang, pages 172 184, \nBoston, 1985. [16] E. Giovannetti, G. Levi, C. Moiso, and C. Palami\u00addessi. Kernel LEAF: a logic plus \nfunctional lan\u00adguage. The Journal of Computer and System Sci\u00adences, 42:139 185, 1991. [17] J. A. Goguen \nand J. Meseguer. Eqlog: Equal\u00adity, types, and generic modules for logic program\u00adming. In D. DeGroot and \nG. Lindstrom, ed\u00aditors, Logzc Programming, Functaons, Relations, and Equations, pages 295 363. Prentice \nHall, 1986. [18] W. Hans, R. Loogen, and S. Winkler. On the interaction of lazy evaluation and backtracking. \nIn Proc. of the dth International Symposium on Programming Language Implementation and Logic Programming, \npages 355-369. Springer LNCS 631, 1992. [19] M. Hanus. Compiling logic programs with equality. In Proc. \nof the %d Int. Workshop on Programming Language Implementation and Logic Programming, pages 387-401. \nSpringer LNCS 456, 1990. ~20] A. Herold. Narrowing techniques applied to idem\u00adpotent unification. Technical \nReport SR-86-16, SEKI, 1986. [21] C. M. Hoffmann and M. J. O Donnell. Implementa\u00adtion of an interpreter \nfor abstract equations. In Ilth ACM Sympostum on the Prtnciple of Programming Languages, Salt Lake City, \n1984. [22] S. Holldobler. Foundations of Equational Logtc Programming. Springer LNCS 353, 1989. [23] \nG. Huet and J .-M. Hullot. Proofs by induction in equational theories with constructors. JCSS, 25:239-266, \n1982. ~24] G. Huet and J.-J. L6vy. Computations in orthog\u00adonal term rewriting systems. In J .-L. Lassez \nand G. Plotkin, editors, Computational logzc: essays tn honour of Alan Robznson. MIT Press, Cambridge, \nMA, 1991. Previous version: Call by need com\u00adputations in non-ambiguous linear term rewriting systems, \nTechnical Report 359, INRIA, Le Ches\u00adnay, France, 1979. ~25] J.-M. Hullot. Canonical forms and unification. \nIn Proc. 5th Conference on Automated Deductzon, pages 318-334. Springer LNCS 87, 1980. [26] J. A. Jim6nez-Martin, \nJ. Mariiio-Carballo, and J. J. Moreno-Navarro. Efficient implementation of lazy narrowing into PROLOG. \nIn LOPSTR 92, 1993. Previous version: Some Techniques for the Effi\u00adcient Implement ation of Lazy Narrowing, \nTechnical Report -FIM.75/LyS/92, Facultad de Informatica, Universidad Politecnica de Madrid, 1992. ~27] \nJ. R. Kennaway. Sequential evaluation strategies for parallel-or and related reduction systems. An\u00adnals \nof Pure and Apphed Logic, 43:31 56, 1989. ~28] J. R. Kennaway. The specificity rule for lazy pattern-matching \nin ambiguous term rewrite sys\u00adtems. In Third European Symp. on Programming, pages 256 270, 1990. LNCS \n432. [29] J. W. Klop. Term Rewriting Systems. In S. Abram\u00adsky, D. Gabbay, and T. Maibaum, editors, Hand\u00adbook \nof Logic in Computer Science, Vol. II, pages 1 1 12. Oxford University Press, 1992. Previous version: \nTerm rewriting systems, Technical Report CS-R9073, Stichting Mathematisch Centrum, Am\u00adsterdam, 1990. \n[30] J. W. Klop and A. Middeldorp. Sequentiality in or\u00adthogonal term rewriting systems. Journal of Sym\u00adbolic \nComputation, pages 161 195, 1991. Previ\u00adous version: Technical Report CS-R8932, Stichting Mathematisch \nCentrum, Amsterdam, The Nether\u00adlands, 1989. [31] S. Krischer and A. Bockmayr. Detecting redundant narrowing \nderivations by the LSE-SL reducibility test. In Proc. RTA 91. Springer LNCS 488, 1991. [32] R. Loogen, \nF. Lopez Fraguas, and M. Rodriguez Artalejo. A demand driven computation strategy for lazy narrowing. \nIn Proc. of the 5th Interna\u00adtional Symposium on Programming Language Im\u00adplementation and Logtc Programming, \npages 184 200. Springer LNCS 714, 1993. [33] L. Maranget. Optimal derivation in weak lambda\u00adcalculi \nand in orthogonal terms rewriting systems. In 17thAnnual Symp. on Prznctpies of Prog. Lan\u00adguages, pages \n255 269. ACM, 1990. [34] A. Middeldorp, August 1993. Personal Communi\u00adcation. [35] A. Middeldorp and \nE. Hamoen. Counterexamples to completeness results for basic narrowing (ex\u00adtended abstract). In Proceedings \nof the Third In\u00adternational Conference on Algebrazc and Logzc Pro\u00adgramming, pages 244 258, Volterra, \nItaly, Septem\u00adber 1992. [36] J. J. Moreno-Navarro, H. Kuchen, R. M. Rodriguez-Artalejo. Lazy narrowing \nmachine. In Proc. Second International on Algebraic and Logic Programmmg, 317. Springer LNCS 463, 1990. \nLoogen, and in a graph Conference pages 298 [37] J. J. Moreno-Navarro and M. Rodriguez-Artalejo. Logic \nprogramming with functions and predicates: The language BABEL. Journa/ of Logic Program\u00adming, 12:191 \n223, 1992. [38] W. Nutt, P. R&#38;y, and G. Smolka. Basic narrowing revisited. Journal of Symbolic 317, \n1989. [39] M. J. O Donnell. by Equations. [40] M. J. O Donnell. ming Language. Computing Springer LNCS \nEquationa/ MIT Press, Computation, 7:295 in Systems Described 58, 1977. Logic as a Program\u00ad1985. [41] \nM. J. Oyamaguchi. Nv-sequentiality: A decidable condition for call-by-need computations in term rewriting \nsystems. SIAM Journal on Computation, 22(1):114-135, 1993. [42] P. Padawitz. Computtng in Horn Clause \nTheories, volume 16 of EATCS Monographs on Theoretical Computer Science. Springer, 1988. [43] G.D. Plotkin. \nBuilding-in equational theories. Ma\u00adchine Intelligence, 7:73 90, 1972. [44] U. S. Reddy. Narrowing as \nthe operational seman\u00ad tics of functional ternat. Symposium 138-151, Boston, [45] R. C. Sekar and ming \nin equational tiality. In Proceedings Symposium on Logic 230-241, Philadelphia, [46] J. R. Slagle. Automated \nories with simplifiers, languages. In Proc. IEEE In\u00adon Logac Programming, pages 1985. I. V. Ramakrishnan. \nProgram\u00adlogic: Beyond strong sequen\u00ad of the Ftflh Annual IEEE in Computer Science, pages PA, June 1990. \ntheorem-proving commutativity, and tivity. Journal of the ACM, 21(4):622-642, [47] M. R. Sleep, M. J. \nPlasmeijer, and M. C. Eekelen, editors. Term Graph Rewriting for the\u00adassocia\u00ad1974. J. D. van Theory and \nPractice. J. Wiley &#38; Sons, Chichester, UK, 1993. [48] S. Thatte. A refinement of strong sequentiality \nfor term rewriting with constructors, Information and Computation, 72:46-65, 1987. [49] J.-H. You. Enumerating \nouter narrowing deriva\u00adtions for constructor-based term rewriting systems. Journal of Symbolic Computation, \n7:319-341, 1989.  \n\t\t\t", "proc_id": "174675", "abstract": "<p>Narrowing is the operational principle of languages that integrate functional and logic programming. We propose a notion of a needed narrowing step that, for inductively sequential rewrite systems, extends the Huet and Le&#180;vy notion of a needed reduction step. We define a strategy, based on this notion, that computes only needed narrowing steps. Our strategy is sound and complete for a large class of rewrite systems, is optimal w.r.t. the cost measure that counts the number of distinct steps of a derivation, computes only independent unifiers, and is efficiently implemented by pattern matching.</p>", "authors": [{"name": "Sergio Antoy", "author_profile_id": "81100292463", "affiliation": "Dept. of Computer Science, Portland State University, Portland, OR", "person_id": "PP14108529", "email_address": "", "orcid_id": ""}, {"name": "Rachid Echahed", "author_profile_id": "81100153155", "affiliation": "IMAG-LGI, CNRS, F-38041 Grenoble, France", "person_id": "PP14063346", "email_address": "", "orcid_id": ""}, {"name": "Michael Hanus", "author_profile_id": "81100022601", "affiliation": "MPI Informatik, Im Stadtwald, D-66123 Saarbr&#252;cken, Germany", "person_id": "PP39023636", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/174675.177899", "year": "1994", "article_id": "177899", "conference": "POPL", "title": "A needed narrowing strategy", "url": "http://dl.acm.org/citation.cfm?id=177899"}