{"article_publication_date": "02-01-1994", "fulltext": "\n Combinations of Abstract Domains for Logic Programming Agostino Cortesi* Baudouin Le Charlier Pascal \nVan Hentenryckt Brown University University of Namur Brown University Box 1910, Providence 21, rue Grandgagnage \nBox 1910, Providence RI 02912 (USA) B-5000 Namur (Belgium) RI 02912 (USA) aac@cs. brown. edu ble~inf \no. fundp. ac .be pvh~cs. brown. edu Abstmct Abstract interpretation [7] is design static program analysis \nsively in the logic programming potential for optimiaations in a systematic methodology to which has \nbeen studied exten\u00adcommunity, because of the logic programming compilers and the sophistication oft he \nanalyses which require concep tual support. With the emergence of efficient generic ab\u00ad stract interpret \nation algorithms for logic programming, the main burden in building an analysis is the abstract domain \nwhich gives a safe approximation of the concrete domain of computation. However, accurate abstract domains \nfor logic programming are often complex because of the variety of analyses to perform, their interdependence, \nand the need to maintain structural information. The purpose of this paper is to propose conceptual and \nsoftware support for the design of abstract domains. It contains two main contributions: the notion of \nopen product and a generic pattern domain. The open product is a new way of combining abstract domains \nallowing each combined domain to benefit from information from the other components through the notions \nof queries and open operations. The open product is general-purpose and cam be used for other programming \nparadigms se well. The generic pattern domain Pat (!)?) automaticzdly upgrades a domain D with structural \ninformation yielding a more ac\u00adcurate domain Pat (D) without additional design or imple\u00admentation cost. \nThe two contributions are orthogonal and can be combined in various ways to obtain sophisticated do\u00admains \nwhile imposing minimal requirements on the designer. Both contributions are characterised theoretically \nand ex\u00adperimentally and were used to design very complex abstract domains such sa PAT (OProp@OHode@OPS) \nwhich would be very diiTicult to design otherwise. On this last domain, de\u00adsigners need only contribute \nabout 20% (about 3,4oo lines) of the complete system (about 17,700 lines). \u00b7 Supported by CNR, Prog. \nFin. ,~si~te~i lnformatici e CaldO Parallelo under grant n.91.00026.69. tsuppo~ed in pti by the National \nScience Foundation under grant number CCW9108O32, the Office of Naval Research under grant NOO01491-J-4052 \nARPA order 8225, and by a National Young Inves\u00adtigator Award. Permission to copy without fee atl or pert \nof this meteriel is grented provided thet the copies ere not made or distributed for direct commercial \nedventege, the ACM copyright notice end the title of the publication end its dete thet copying is by \npermission of the Machinery. To copy otherwise, or endlor specific permission. POPL 94-1/94, Portland \nOregon, USA @ 1994 ACM 0-89791 -636-9/94~1 appeer, end notice is given Association for Computing to republish, \nrequires a fee ..$3.60 2 Introduction Abstract interpretation [7] is a systematic methodology to develop \nstatic program analysis. A traditional approach to abstract interpretation consists mainly of three steps: \n(1) the definition of a fixpoint semantics of the programming language: the concrete semantics; (2) the \nabstraction of the concrete semantics: the abstract semantics; (3) the design of a fixpoint algorithm \nto compute the least fixpoint of the abstract semantics. In general, the abstract semantics and the fixpoint \nalgorithm are generic, i.e. they are pararneter\u00adized by an abstract domain and its associated operations. \nA static analysis is then obtained by defining an abstract do\u00admain and providing an implementation of \nthe operations as consistent approximations of the concrete operations. The main advantage of the approach \nis to factor out the abstract semantics and the fixpoint algorithm for various applica\u00adtions, providing \nmodularity and reusability y. Abstract interpretation has raised much interest in logic programtig because \nof the need for optirnizations in com\u00adpilers to make them competitive with procedural kmguages, the variety \nof interdependent analyses that need to be per\u00adformed, and their sophistications which require methodolog\u00adical \nand software support. The use of abstract interpre\u00adtation has led to dramatic improvements in Prolog \ncom\u00adpiler technology [27, 29]. Moreover, substantial work (e.g. [2, 10, 12, 14, 15, 18, 19]) has been \ndevoted to produce effi\u00adcient generic fixpoint algorithms and systems like GAIA1 [19] have been shown \nto yield efficient and accurate analyses. With the emergence of these generic fixpoint algorithms, most \nof the burden in developing an analysis lies in the de\u00adsign of the abstract domain and its associated \noperations. The design of abstract domains is often complex and error\u00adprone because of the variety of \ninterdependent analyses (e.g. freeness, sharing, groundless, types) that must be integrated, the necessity \nof handling structural information (i.e. infor\u00admation on the structure of the terms such aa the functor \nand the arguments) to achieve reasonable accuracy, and the desire to obtain a good tradeoff between accuracy \nand effi\u00adciency. Yet little research haa addressed the important prob\u00adlem of supporting this task adequately. \nNotable exceptions are [3, 8, 9, 14, 25]. The purpose of this paper is to propose some concep tual and \nsoftware support to build sophisticated abstract domains. It contains two main contributions: (1), a \nnew product operation: the open product; (2) a gene~c pattern domain Pat (R) for structural information. \n1GAIA is available by anonymous ftp frnm Brown University. The open product construct is a novel way \nof combining abstract domains, independent from logic programming and hence applicable to other programming \nlanguages as well. The key idea is the notion of open abstract domain which contains queries (providing \ninformation to the environment) and open operations (receiving information form the envi\u00adronment). The \nopen product improves on the direct product by letting the domains interact, since operations in one \ndo\u00admain can use queries in other domains. Its formal charac\u00adterization provides us with a precise meaning \nof consistent approximation in this open context and an automatic way of combining operations and queries. \nThe open product pro\u00advides a rich framework to express combinations of domains where the components interact, \nyielding what is called an attribute-dependent analysis [9]. It can be used as an alter\u00adnative to the \nreduced product of the Cousots [8, 9] which cannot be automated, since it depends on the concretiza\u00adtion \nfunctions, and which does not allow the components to interact. It contains as a degenerated case the \nrefinement operation proposed independently by [3]. It also shares some of the motivations behind the \nideas of R-abstraction of [5] and open semantics [1], although the technical details and practical applications \nare fundamentally different. The generic pattern domain pat (3?) is more tailored to logic programming, \nalthough its principles are general and could be used for other programming languages as well. Pat (R) \nwas motivated by the fact that structural informa\u00adtion dramatically improves the precision of the abstract \ndo\u00admain albeit at a significant increase in complexity of the domain. Its main contribution amounts to \nupgrading auto\u00ad matically a domain D to obtain a new domain Pat (D) aug\u00ad menting II with structural information. \nAs a consequence, it provides the additional accuracy without increasing the design complexity which \nis factored out in Pat ($?). The key technical idea behind Pat (?T?)is to provide a generic imple\u00admentation \nof the abstract operations of Pat(D) in terms of a few basic operations on the domain D using the notion \nof subterm that was also the basis of the pattern domain of [19, 23]. Note also that the motivations \nbehind Pat (3?) are similar to those of [14] which proposes an engine preserving structural information. \nOne of the fundamental differences between these two approaches is that our approach handles structural \ninformation at the domain level and not inside the fixpoint algorithm. As a consequence, the domain can \nbe combined with a variety of fixpoint algorithms achieving various tradeoffs between efficiency and \naccuracy. The two contributions are completely orthogord and can be combined in various ways to obtain \nsophisticated abstract domains. The main advantages of this approach are the simplicity, modularity, \nand accuracy it offers to abstract do\u00admain designers. Simplicity is achieved by abstracting away structural \ninformation and allowing designers to focus on one domain at a time. Modularity comes from the fact that \nabstract domains can be viewed as abstract data types sim\u00adplifying both the correctness proofs and the \nimplementa\u00adtion. Finally, accuracy results from structured information and from the idea of open operation \nwhich is so general that abstract domains can interact at will although through well defined interfaces. \nTo demonstrate the practicability of this approach, both cent ributions have been implemented on a large \ncollection of abstract domains which includes Pat (Prop), Pat (Type) and Pat ( 0Prop@OHode&#38;30PS ), \nwhere Prop is the groundless domain of Marriott and Sondergaard [4, 22, 21], Type is the type graph domain \nof Bruynooghe and Janssens [16], and OHode and OPS are well-known domains for modes and shar\u00ading. It \nis interesting to note that Pat (OProp@OOHode@OPS) and Pat (Type ) are some of the most complicated domains \never implemented for Prolog, yet their requirements on the designer are minimal. The rest of the paper \nis organized in four sections. Sec\u00adtions 2 and 3 present the main contributions of this paper, i.e. the \nopen product and the generic pattern domain. Sec\u00adtion 4 presents some experimental results and Section \n5 con\u00adcludes the paper. See the technicaJ version of the paper for a comprehensive coverage [6]. 3 Open \nProduct This section considers the problem of designing an abstract domain D as a combination of domains \nDI, . . . . D. and pro\u00adposes the novel concepts of open product and refinement. Subsection 3.1 gives \nan overview of our approach and a com\u00adparison with some previous work in the area. Section 3.2 formalizes \nthe concepts while Section 3.3 illustrates the ap\u00adproach for the abstract interpretation of Prolog. In \na first reading, it may be convenient to refer to Section 3.3 when reading Section 3.2. 3.1 Overview \nThe direct product is the simplest combination of abstract domains. Given two abstract domains D1 and \nDZ with con\u00adcretization functions Ccl : DI + C and CC2 : D2 * C, the direct product domain is the domain \nD = D1 x D2 with concretization function Cc((dl, dz)) = Ccl (dl ) n Ccz (dZ). Moreover, given a concrete \noperation OP, : C ~ C and two corresponding abstract operations OP1 and OPZ on D1 and Dz, a direct product \noperation can be obtained automati\u00adcally as OF ((dl, dz)) = ((lpl(dl), OpZ(dZ)). The main disadvantage \nof the direct product is its lack of precision since there is no interaction between the compo\u00adnents. \nNote also that the direct product domain may contain many redundant elements (i.e. distinct elements \nwith the same concretization) possibly implying an additional loss of precision since the operations \nare not guaranteed to work on the more precise components. The reduced product was proposed by the Cousots \n[8] to overcome some of the limitations of the direct product. Its key idea is to cluster into equivalence \nclasses the elements of the direct product having the same concretization and to work on the more precise \nrepresentative of each class. More formally, consider the function reduce : D1 x Dz + DI x D2 defined \nas reduce((dl, dz)) = fl{(el, ez) I Cc((el, ez)) = Cc((dl, dz))}. The reduced product domain is the domain \nwhile a reduced product operation over D can be defined as W((dl, dz)) = reduce((OPl (dI), OPZ(dz))). \nNote that the reduced product removes redundancies from the domain and enjoys some nice theoretical proper\u00adties \n(e.g. the reduced product of two Galois connections is a Galois connection). However, the reduced product \nhas also some inherent limit ations. On the one hand, the implemen\u00adtation of the product operations cannot \nbe obtained auto\u00admatically, since they rely on the concretization function (a semantic notion), although \nthe reduced product provides se\u00ad mantic guidance for their construction. On the other hand, ss observed \nby the Cousots themselves, additional accuracy can be obtained by defining new operations where the \nop\u00aderations on DI and Dz interact. The reduced product has been used in logic programming by [3] and \ntheir reduced product operations are of course obtained manually. The open product introduced in this \nsection remedies the limitations of the reduced product. The key features of our approach are (1) an \nautomatic derivation of the product operations; (2) possible interactions between the domains before, \nduring, and after the product operation; (3) encap\u00adsulation of the representation and implementation \nof each component. As a consequence, the open product provides a rich and widely applicable framework \nto implement and prove the correctness of various combinations of domains, in\u00adcluding the reduced product. \nIt is aleo orthogonal to other systematic methods to build abstract domains such as down\u00adset completion \nand tensor products [8, 9, 25] or the pattern domain defined in the next section. The key idea behind \nthe open product is the notion of open abstract interpretation.3 Informally speaking, an open abstract \ninterpret ation dMers from a traditional abstract in\u00adterpretation by introducing the notion of queries \nand open operations. A query is simply a function giving informa\u00adtion about the properties captured by \nthe domain. An open operation is essentially an abstract operation except that it receives one or more \nboolean functions describing addi\u00adtional properties of the concrete objects (e.g. properties not captured \nby the domain). The main benefit of open inter\u00adpretations is the fact that abstract operations are able \nto receive information from the environment to improve their accuracy. Once open interpretations are \ndefined, it is natural to define a new form of product, the open product, which is similar to the direct \nproduct except that the open operations in one domain can use some queries in other domains to improve \naccuracy. Note that all operations interact in terms of the initial abstract object, i.e. the object \nbefore executing the operation. The open product can be improved further by letting the subdomains interact \nafter the operations, i.e. in terms of the results of the operations. To capture formally this idea, \nthe concept of refinement and refined open product are introduced. Refinements are open operations which \ndo not modify the global concretization function but improve the subdomains locally. Refinements are \northogonal to the open product and lead to the notion of refined open product which is an open product \nfollowed by a sequence of refine\u00adments. Refinements are ways to compute or approximate the greatest lower \nbound operation used by the reduced prod\u00aduct. In addition, they can be used even when the domains are \nnot Galois connections or when the greatest lower bound is too expensive to compute exactly. The notions \nof open product and open interpretation are both theoretical and practical tools. On the theoretical \nside, 2 Note that the reduced product may not aPPIY if the domains Sre not Gslois connections, since \nthe greatest lower bound may not be in the same equivalence class. 3We are using the term abstract interpret \nat ion in a t ethnical sense here ss in [5]. they capture precisely the properties that need to be satis\u00adfied \nto obtain a new domain and consistent operations. On the practical side, they sUow the designer to build \na com\u00adplex domain as a set of open domains which are nothing else than abstract data types offering queries \nsad open opera\u00adtions. Moreover, there exist systematic ways of composing queries from difTerent domains \nand to complement incom\u00adplete interpretations. Finally, it is important to note that the open product \nis completely independent of logic pro\u00adgramming and can be used for any programming language. 3.2 Formalization \nIn the following we assume farniliarit y with standard notions of abstract interpretation [l l. We assume \nfor simplicity that all complete partial orders (cpo) are pointed and use the fol\u00ad lowing definitions \nfor domains and abstractions of domains. Definition 1 (domain) A domain is a cpo with an upper bound \nopemtion (not necessarily a lub opemtion). Definition 2 (abstraction of domains) Let DI, Dz be two domains \nordered by <I and <z respec\u00adtively. The domain D2 abstmcts DI if them exists a mono\u00adtone function Cc \n: DZ + DI such that Vdl E DI ld2 E D2 : dl <1 Cc(d2). The function Cc is called a concretization function \n. Additional structure can be imposed on the domains and the abstractions but this issue is orthogonal \nto our objec\u00ad tives. We also denote by Booi the set {true, f alse} and as\u00ad sume, without loss of generality, \nthe order induced by true < false on Bool. It is natural to use ~ for this order. The first important \nconcept we introduce is the notion of query which gives information about the properties of concret e \nob\u00adjects. Definition 3 (test) A testis a boolean function T : Arg + Bool. The tests on the same set Arg \ncan be partially ordered as follows: T <7 # Vh c Arg : T(h) ~ 7 (h). Definition 4 (query) A query on \nthe domain D is a mono\u00ad tone function Q : D + Arg -+ Bool which maps elements of the domain D onto tests. \n Queries give rise to the notion of query interpretations which is a slight generalization of the traditional \nnotion of interpretation [5] and was proposed independently in [24] for other purposes. In the following \nwe denote by D the tuple (D, <, (OF,,..., Opn), (Ql,..., Qrn)) and by Dh the tuple (Dh, <h, (OP~,..., \nOP~), (Q~,..., Q~)) for h = 0,1,2. Definition 5 (query interpretation) A query interpre\u00ad tation is a \ntuple D where: D is a domain; s is the par\u00ad tial order on D; OPI, . . . . OP. are opemtions of signature \nOP~:D + D;4 Q1....Q~ am queries on D. 4 we ~e~ttict our ~ttention to unary operations. A generalization \n.af the definition is straightforward. A query interpretation can be seen as an abstract data type, where \nqueries represent information about the domain D which is offered to the environment. In order to use \nqueries, we introduce the concepts of open operation (an operation parametrised by tests) and open interpretation \n(an interpretation with open operations and queries). Definition 6 (open operation) An open operation \non the domain D is a function OP : (Arg -+ Bool)m + D + D (m > O) which maps a tuple of tests onto an \noperation. OP should be monotone with respect to the tests. Definition 7 (open interpretation) An open \ninterpreta\u00ad tion is a tuple D where: D is a domain; < is the partial order on D; OPI ,. ... OP~ are open \noperations on D; and QI .... Qm are queries on D. Observe that a query interpretation can be seen as \na degenerate case of open interpretation where none of the operations depends on tests. We now consider \nthe abstrac\u00adtion of query interpretations and of open interpretations ae generalisations of the traditional \nnotions. Definition 8 (abstraction of queries) Let Q1 and QZ be two queries on domains D1 and DZ respectively \nand assume that D2 abstracts D1. We say that Q2 is an abstraction of Q1 i.f Vd c DZ : Ql(Cc(d)) e Qz(d). \nDefinition 9 (abstraction of query interpretations) Consider the query interpretations D1 and D2. We \nsay that DZ is an abstmction of D1 if: -DZ abstmcts Dl; -forl<i<n : OP~ abstmcts OP~, i.e. Vdz 6 Dz : \nop; (Cc(dz)) <1 Cc(Op~(dz)); -for 1< i < m : Q? abstmcts Q:. We now introduce the semantics of open operations \nthrough the notion of open abstraction. Definition 10 (open abstraction) Consider a query in\u00adterpretation \nD1 and an open interpretation Dz. We say that D2 is an open abstmction of D1 if: -Dz abstracts Dl; -for \n1 ~ i < n : OP~ abstmcts OP~, i.e. Vdz c Dz VdI c D1 :dl <1 Cc(dz) %\u00ad Op$(dl) <1 Cc(Op; (( Q:(dl), . \n. . . Q&#38;(dl))) (dZ)). -for 1~ i < m : Q: abstmcts Q:. We are now in position to define the notion \nof open prod\u00ad uct of domains. An important point to notice here is how the product operations and the \nproduct queries are derived automatically. Definition 11 (open product) Consider two open inter\u00adpretations \nDI and DZ. The open product DI @ Dz is the query interpretation D defined as follows. -D is the cartesian \nproduct D1 x Dz; the partial ordering ~ is the product ordering of <1 and s2; the quer~ Q, is defined \nas Q,(dl, dz) = Q: (dl)VQ~(d2). the opemtion OP, : (Dl x D2) + (Dl x Dz) is defined by: opi(dl, d2) = \n( Op:((Ql(dl, dz), . . .. Qrn(dl. dz)))(dl) , Op?((Ql(dl, dz), . . . . Qm(dl, dz)))(dz) ). The following \ntheorem is a soundness result which proves that the open product of two abstractions is itself an abstrac\u00adtion< \nTheorem 1 (consistency of the open product) Let DO be a query interpretation, and assume the existence \nof a greatest lower bound operation n on the domain of D0.5 -Let D1 and Dz be open interpretations such \nthat DI and Dz are open abstmctions of DO. The open product D1 @ Dz i~r an abstraction of DO. Proof: \nThe three conditions of Definition 9 hold. 1. Domain: Domain D1 x D2 abstracts DO through the concretization \nfunction Cc : D1 x Dz. + DO defined by Cc(dl, dz ) = Cc(dl ) il Cc(dZ). This function is monotone by \ncomposition of monotone functions. 2. Queries: Query Q, abstracts Q? since  do so Cc(dI), Cc(dz) implies \nQ~(do) + Qt(dl), Q:(dz) and thus Q!(do) ~ Q,(dl, dz). 3. Operations: Operation OPI abstracts OP~ since, \nfor l~h~2andl~j~m do <0 Cc(dl), Cc(dz) * o~(do) <0 6 c(OP~((Q;(dO), . . . . Q~(do)))(dh)) (Dh is an open \nabstraction of Do) op~(~o) <0 CC@p~((QI(C&#38;, ~z), . . . . Qrn($l, ~2)))(~h)) (Qj is an abstraction \nof Q?) l)~(do) <o nl<h<z CC(OP; (( Q1(Ctl, d2),... , Qm(dl, d2)))(dh)) (by p;o@wties of n) O~(do) <0 \nCC(OPi(dl, d 2)) (by definition of OP,). Hence, by Cc(dl, dz) <o Cc(dl), Cc(dz), OP~(CG(d~, (lZ)) <~ \nCG(OP~(d~, d.)). E 5 Note that, in general, the existence of n is trivially ensured, since Do will be \nthe concrete domain. Refined Open Product The open product enables opera\u00adtions to benefit from information \nfrom the other components in the state before the product operation. However, theop erations themselves \ncan produce additional information that may beuseful torefine the results. Asmentioned previously, refinements \ncan be used after each product operation, This idea waa proposed independently, but not formalized, in \n[3]. Definition 12 (refinement) Let Do and D1 be a query interpretation and an open interpretation such \nthat D1 is an open abstraction of DO. An operution REFI?JE: (Arg + Bool)m + D1 + D1 is a refinement \nopemtion of D1 with respect to Do if for all do G DO and d~ 6 DI, the following conditions hold. 1. dO \nso Cc(dl) + do <o Cc(RHFINE((@(do), . . . . Q%(do)))(dl)); 2. REFINE((fi, . . . ,7~))(dl) <1 dl foranyte8t \nz,...,7m.  Consider the open product D1 @ DZ, where D1 and D2 are open abstractions of the query interpretation \nDO. As\u00adsume that the refinement functions REFINE1 and REFIN&#38; are defined in D1 and D2 respectively. \nThe corresponding op eration REFINE in the open product is defined se traditional operations. Definition \n13 (refinement in the open product) In the hypotheses and notation of Theorem 1, assume that REFINE1 \nand REFINfi are refinement functions for D1 and Dz with respect to DO. The refinement function REFINE \non the open product DI @ D2 is defined by: REFINE(dl , dz) = @ZFINEl((Ql(dl, &#38;), . . . . Qm(A, &#38;))) \n(all) , REFIN&#38;((Ql(dl, dz), . . . . Qm(&#38;, d2))) (dz) ) An abstract operation in the open product \ncan now be de fined aa follows. Definition 14 (refined abstract operation) Under the hypotheses and notation \nof theorem 1, assume that REFINE1 and REFIN~ are refinement functions for D1 and D2 with respect to DO. \nThe opemtion UP, :(Dl X D2) + (Dl XD2) can be defined au; OP; (dl, dz) = REFINE(dj, dj) where (d{, d;) \n= (Op;((421(d~, d2),..., G?m(dl, d2)))(dl) , Op?((Ql(dl, dz), . . .. Qrn(dl. d2)))(d2)) It is easy to \nadapt the correctness proof to refined ab\u00adstract operations. Observe that the implement ation of the \noperations REFINE can be expressed simply by using queries. This guarantees once again the complete modularity \nof the approach, since the interpretations can be constructed in\u00addependently. Note also that the refinement \ncan be applied arbitrarily often if useful. 3.3 Application In this section, we illustrate the refined \nopen product to compose two domains for logic programming: a groundless and a sharing domain. We describe \nrespectively the con\u00adcrete semantics, the abstract domains and the open prod\u00aduct. In the following, variables \nare taken from the set V = {XI, Z2,... , Zi,...} and we use F to denote a finite subset of V. The presentation \nis intentionally simplified. 3.3.1 Concrete Domain Domain A traditional concrete domain for logic program\u00adming \nhas sets of substitutions as elements. Given it Subst the set of idl substitutions and SubstF the set \nof substitu\u00adtions whose domain is F, a concrete domain CSF is simply p(PSF ). This domain is a complete \nlattice with respect to the set inclusion ~.6 Operations The operations on the concrete domains de\u00adpend \nfrom one framework to another. As shown in [13], they need to contain at leaat projection, unification, \nand an upper bound operation. In the following, for illustration purposes, we consider only a single \noperation, the unification of two variables, whose specification is as follows (~ c CSF ): Queries For \nsimplicity, we consider only two queries, c GRomD: CSF + F + Booi and C-NOS~ARING: CSF + $ X F + BOO1 \nwhich provide information on groundless and sharing and are specified as follows: C_GROUND(@)(~;) = true \nif W c El : zi6 is a ground term false otherwise { C-NOSHARING(~)(Z,, ZJ) = true if VO c @ : zie, Xjd \ndo not share variables false otherwise {  3.3.2 The Open Abstmct Interpretation OProp We now turn to \nthe first abstract domain and specities the domain, its queries, operation, and refinement. Domain prOpF \n[4, 22, 21] is the poset of Boolean func\u00adtions that can be represented by propositional formulae con\u00adstructed \nfrom F, the Boolean truth values, and the logical connective V, A, * and ordered by implication. A truth \nassignment over F is a function 1 : F + Bool. The value of a Boolean function ~ wrt a truth assignment \n1 is de\u00adnoted 1(f). The basic intuition behind the domain PrOpF is that a substitution O is abstracted \nby a Boolean function ~ over F iff, for all instances 0 of 8, the truth assignment 1 defined by l(z;) \n= true ti 0 grounds zi (1 < i < n) sat\u00adisfies j. For instance, let F = {s1, s2}, q + Z2 abstracts the \nsubstitutions {z1 /23, ZZ/Z3 }, {zl/a, zz/a}, but neither {zl/a, 22/23} nor {s1/23, z2/z4}. The concreti.zation \nfunction for prOpF is a function Cc : prOpF + CSF defined aa follows: where assign : CSF + D + Bool is \ndefined by assign 6 z, = true % $ grounds z;. 6In the following, the notion of substitution composition \nis slightly cm-standard and makes sure that dom(bla) = dom(ll). Queries In prOpF, the queries are abstracted \nby the func\u00adtions OProp-GROUND: PropF + F + Boo! OProp-ltOSRARING: PropF + F x F -+ Bool whose definitions \nare aa follows OProp-GROUND(.f) (~i) # (.f + $,) OProp-NOSHARING( ~)(zi, Zf) # (~ + $i) V (.f + zj ) \n Opemtion The unification can be abstracted as OProp-UNIF(GROUND) (~, z,, z~) = fAz, Az, if GROUND(G) \nV GRCIUND(Z3); f A (~i ++ zj) otherwise . { Refinement The refinement in prOpF is simply the func\u00adtion \nOProp-REFINE(GROUND)(f ) = j A S,l A . . . A zip, where {Zi,,..., XiP } = {xi E F ] GROUND(~i)}.  3.3.3 \nThe Open Abstmct Interpn%ation OPS Domain The abstract domain OPS (inspired by the shar\u00ading component \ndescribed in [19]) specMes the possible pair\u00adsharing of variables between terms. The elements of OpSF \nare binary and symmetrical relations ps : F x F. The intu\u00adition is that the terms bound to ~i and ZJ \nmay share vari\u00adables only when Ps(~i, ~a) is true. The ordering between two abstract elements PSI, PS2 \nis defined as follows: PSI < psz if V(i, j) : PSI ($i, Zj ) + ps2(z,, ~j). The concretization func\u00adtion \nCc : OpSF + CSF is Queries OPS supports the sharing query: and the ground query OPS-GROUND(ps)(~i) + \n(x,, Zi) @pS. Opemtion The unification is abstracted aa OPS-UNIF(GROUND) (pS, ~:, Z,) = $ S where psi \nis defined as PS\\{(Zk, ZI) I k E {ij}v~~ {ij}} if GROUND(~i) V GROUND(Z$) ad w otherwise, where p-s denotes \nthe symmetrical closure of ps. Refinement The refinement exploits groundless informw tion. Let W = {z, \nc F I GROUND(Z,) } in OPS-REFIME(GROUND) (ps) = {(Zi, Z j) lfM(Zi, Z~)&#38;Zi # W&#38;Xj @ W}. 4 The \nGeneric Pattern Domain Pat (J?) The purpose of this section is to present the second con\u00adtribution of \nthis paper. Once again, we start by giving an overview of the approach. We then formalize it, show its \nimplementation, and discuss some applications. 41 Overview It is well-known that preserving structural \ninformation in abstract domains for logic programming is often of primary importance to achieve a rewonable \naccuracy . However, abstract domains preserving structural information are often an order of magnitude \nmore complicated to design. In this section, we define Pat (Y?), a generic abstract do\u00admain which automatically \nupgrades a domain ?Rwith struc\u00adtural information. As a consequence, the approach requires the same design \nand programming effort as the domain J?, yet it fully benefits from the availability of structural in\u00adformation. \nThe price to pay for this important function\u00adality is a small loss of efficiency for some domains (this \nis quantiiled experimentally later on). Contrary to the open product, Pat (Y?) is tailored to logic programming. \nHowever, approaches similar in spirit can be used for other program\u00adming languages as well. The key intuition \nbehind Pat (Y?) is to represent informa\u00adtion on some subterms occurring in a substitution instead of \ninformation on terms bound to variables only. More pre\u00adcisely, pat (Y?) may associate the following information \nwith each considered subterm: (1) its pattern which specifies the main functor of the subterrn (if any) \nand the subterms which are its arguments; (2) its properties which are left unspeci\u00adfied and are given \nin the domain 32. A subterm is said to be a leaf ifI its pattern is unspecified. In addition to the above \ninformation, each variable in the domain of the substitutions is associated with one of the subterms. \nNote that the d~ main can express that two arguments have the same value (and hence that two variables \nare bound together) by associ\u00adating both arguments with the same subterm. This feature produces additional \naccuracy by avoiding decoupling terms that are equal but it also contributes in complicating the design \nand implementation of the domain. The new notion of constmined mapping aims precisely at dealing with \nthis issue. It should be emphasized that the pattern information is optional. In theory, information \non all subterms could be kept but the requirement for a finite analysis makes this im\u00adpossible for almost \nall applications. As a consequence, the domain shares some features with the depth-k abstraction [17], \nalthough Pat (3?) does not impose a fixed depth but ad\u00adjusts it dynamically through upper bound and widening \nop\u00aderations. This idea ww already used in the domain Pattern defined in [19, 23] which can be viewed \nas an instance of pat (W) for some specific domains. pat (3?) is thus composed of three components: a \npattern component, a same value component, and a S-component. The first two components provide the skeleton \nwhich con\u00adtains structural and same-value information but leaves un\u00ad specified which information is maintained \non the subterms. The $?-domain is the generic part which specifies this infor\u00ad mation by describing properties \nof a set of tuples <tl, . . ..tp> 3.3.4 The Open Product OProp @ OPS 7An al~~~~tiv~ is to ~Se r.eexecution \nwhich, in practice, simulates the presence of structural information. The open product OProp @ OPS is \ndefined in Figure 1. { -The refinement is 2WEFINE(t, ps) = (f , ps ) where ~~, = OProp-REFINWD-GROUND(j, \nps))(~) = OPS-REFINF@GROUNO(~,ps ))(ps){ -The operation is ZMNIF((~,pS), z~, ~j) = %REFINE(~ , j , = \nOProp-UNIF(%GROUND(~, P~))(~, ~i, ~i) ps = OPS UNIF(D-GROUND(j, pS))(p8$ ~i, Zj) { Figure 1: The Open \n where to,..., tP are terms. As a consequence, defining the R-domain amounts essentially to define a \ntraditional domain on substitutions. The only diference is that the R-domain is an abstraction of a concrete \ndomain whose elements are sets of tuples (of terms) instead of sets of substitutions. This diference \nis conceptual and does not fundamental.ly affect the nature or complexity of the Y?-operations. The imple\u00admentation \nof the abstract operations of pat (3?) is expressed in terms of the R-domain operations. In general, \nthe imp\u00adlementations are guided by the structural information and call the R-domain operations for basic \ncases. Pat (Y?) carI be designed in two dWerent ways, depending upon the fact that we maintain information \non all terms or The open product D= oProp @ OPS = (D,<, D-REFINq D-UNIF, (D-GROUND, D-NOSHARING)) is \ndefined SS: -D is the cartesian product of the two domains and the partial order ~ is (+, ~). 27-GRouND(~,ps) \n= OProp-GROUND(~) V OPS-GROUND(PS) -The queries are: %NOSHARING(~,ps) = OProp-NOSHARING(~) V OPS-NOSHARING(ps) \nonly on the leaves. In the rest of this paper, we first approach for simplicity, although the second \nis more efficient for many domains $?. In both main difficulty in generalizing the original pattern is \nto deal properly with global information, i.e. tion which is not explicit for each subterm but adopt \nthe approach csses, the domain informa\u00adconstrains zdl subterms together. For instance, in Prop, groundless \nin\u00adformation is not associated with each subterm but rather is given through a global boolean formula. \nSpecific informa\u00adtion about a term can of course be extracted from the for\u00admula but need not be represented \nexplicitly. The handling of global information has been achieved through the introduc\u00ad tion of a number \nof novel concepts (e.g. constrained map ping), a radically new implementation of some operations (e.g. \nUNION and the ordering relation), and a generalization of many others (e.g. unification). The identification \nof subterms tween the structural component somewhat arbitrary choice. In the subterms with integer indices, \nare considered. For inst ante, the {qtt*a, z~+a, (and hence the link be\u00adand the R-domain) is a the following, \nwe identify say 1... n if n subterms substitution z~+gJ1\\[]}  willhave 7 subterms. The association of \nindices to them could be for instance {(1, t* a), ( 2,*), (3, a), (4, a), (5,91 \\ [ ]), (6, w), (7, [ \n1)}. The pattern component (possibly) assigns to an index an expression ~(il, ..., in), where ~ is a \nfunction symbol of arity ps ) where Product OProp @ UPS nandil, ..., iw are indices. If it is omitted, \nthe pattern is said to be undefined. In our example, the (most precise) pattern component will make the \nfollowing associations {(1,2 * 3), (2,t), (3, a), (4, a), (5, 6\\ 7), (7, [ ])}. The same value component, \nin this example, maps xi to 1, zzto 3,and Z3to 5. Assuming that the R-domain is intended to be the shar\u00ading \ndomain defined in the previous section, the R-component for the above abstract substitution is a relation \nps : {1...7} x {1... 7} which is true only for (5,5), (5,6), (6,5) and (6,6). Note the use of integers \ninstead of the variables of the pre vious section. This is the only difference between the 0?\u00addomain \nand a traditional domain. 42 The Abstract Domain We now turn to the formalization of Pat (32). In the \nfollow\u00ading, we denote by 1P the set of indices {1,..., p}, by STP the set of t uples of terms < tl,...,tp>,by \nST the union of all sets STP for some p >0, and by p(ST) the powerset of ST. An abstract sub~ltution \n~ over the program variables xl, ..., X. is a triple (~rm, SV, t) where ~mn is a partial function, sw \nis a total function, and J! is an element of an %&#38;domain to be specified. Pattern Component The pattern \ncomponent is defined as in [19]. It associates with f}:,..., iq), where ~ is ,.. ,iq}clp. We denote by \nFRMP for a fixed p and by FRM some of the indices in 1P a pattern a function symbol of arity g and the \nset of all partial functions frrn the union of all FRMP (p ~ 0). The meaning of an element fmn is given \nby the concretizm tion function Cc : FRMP + p(STP): Cc(fm) = {< t,, ....tp>l Vi:l~i~p: ~rm(i) = f(il, \n....iq) * ...,tiq)}. ti= j (til,  Same Value Component The second component as+ns a subterm to each \nvariable in the abstract substitution. Given a set D of program variables and a set of indices 1~, this \ncomponent is a subjective function sw : D + Im. We denote by SVD,~ the set of all same value functions \nfor fixed D and m and by SV the union of all sets SVD,m for any D and m. The meaning of an element sv \nis given by a concretization function Cc : SVD,~ + CSD that makes sure that two variables sssigned to \nthe same index have the same value: Cc(sv) = {0 Idom(6) = D and V~ij Zj c D : S U(Zi) = 9W(Zj] * Z*O \n= Zj@}. The Y&#38;component The ?R-component of the generic domain is an element of a domain !RP that \ngives information on a tuple of terms < tl,. . . . tP >. These objects (i.e. the el\u00adements of Y?P) are \ncalled Y?-tuples in the following. The domain is assumed to satisfy the requirements of Defini\u00adtion 1. \nIn the following, we denote by ?Rthe union of all 32P (P z 0). The signature of the concretization function \nCC is cc : Y?p + $9(STP). The Y&#38;domain should include a number of operations which dMer from one \nframework to another. Conceptu\u00adally, only three operations are needed: upper bound, uni\u00adfication, and \nconstrained mapping. The first two, W-UNION and WJ?JIF, are rather st audard and must be consistent abstractions \n@Z are sets of the foIlowing concrete of ptuples of terms): operations (0, @l and Upper Bound: of t uples. \nThis operation takes the union of two sets C-UNItlN(@l, @z) = % u @z. Unification: only consider This \noperation performs two simple cases.8 unification and n eeds C-UNIF(@, 9, j) = {(tla, . . . . L#Y) I \n(t,,..., t??) e o &#38; a e ?ngu(t,, tj)}; C-UNIF(@, 8, g/~) = {(t]a, . . . . %a, ~la, . . . . yPu) I \n~: ;;;;ji;f;,: . . ..yp))&#38; yl, ..., YP me fresh v~iables} The third operation, constrained mapping, \nis novel and generalizes many operations such as projection, renaming, and extension among others. It \nis motivated by one of the fundamental difficulties encountered when designing the op erations of Pat \n($?): the fact that abstract substitutions may have ditferent structures in the pattern component and \nthat equality constraints are enforced implicitly by repeated use of the same index. As a consequence, \nit is non-trivial to establish a correspondence between the elements of the re\u00adspective ~-components \nof two abstract substitutions and the need for such a correspondence appears, in one form or an\u00adother, \nin many abstract operations such as UNION and INTER9 and the ordering relation on Pat (Y?). The constrained \nmap ping provides a uniform solution to this problem and simpli\u00adfies dramatically the implementation \nof many abstract op erations. Definition 15 (Constrained Mapping) A constrained mapping on domain 3? \nmaps any function tr : lP, + lP, onto a function t# : !l?Pl + ?UP2. This mapping has to satis~ the following \nconditions: 1. id~P (1) = 1, whew idlP is the identity function on lP. The other caees come for free \nthrough Pat(R). 9~ntemection is ~~ed for e~~ple in reexecution fram=vOrkS (e.g. [20]). 2. 3. 4. Cc(t;* \n(/)) (co;sistenc~).  The intuition is as follows: an element of !J?Pis a con\u00adstraint over the set of \ntuples of the form < tl,....tp>. A function tr : 1P + Ip, contains two implicit pieces of infor\u00admation: \nfirst, a set of equality constraints for terms whose indices are mapped onto the same value by tT; second, \nit ignores terms whose indices are not the image of some index in lP. This intuition is formally captured \nby function tr# which indicates how to transform an abstract object in !l?P by removing superfluous terms \nmd duplicating some others. The ordering on domains must obviously be respected since new equal terms \nare added in the same way to all elements of the domain. The constrained mapping can be implemented in \na generic way in terms of simpler operations (see Figure 2) demonstrating that this concept is indeed \nnatural for many domains. More specitic implementations are often simpler and more efficient but they \ncomplicate somewhat the task of the designer. The Domain Pat (Y?) Let D be afinite set of variables. \nThe set of abstract substitutions Pat (k!) is the subset of FRh4 x SV x $? satisfying the following conditions: \n1) %, p 6 N,p~m&#38;l E?Rp&#38;sv ESVD,~ &#38;f TmEFRMp; 2) Vi:m<i~p: Slj:l<j~p:jrm(j)= ~(..., i)...). \nThe C oncrdization Function Formally, the meaning of an abstract substitution /3 = (~rm, m, t) is given \nby the con\u00adcretization function Cc : Pat (3?) + 9( CSD ) defined by Cc(~) ={O Idom(0) =D&#38; a(tl,..., \ntp) G Cc(t) n Cc(jrm) : Vz ~ D :X6= t+)}. The Ordering It remains to define the ordering relation. Consider \ntwo abstract substitutions ~1, P2, and assume in the following that ~rm,, m;, 1, are the components of \na sub\u00adstitution /3i, p, is the number of indices in the domains of f rmi, and m, is the number of indices \nin the codomain of 10 Conceptuwy, ~1 < PZ holds if @l imposes the Same S 01 . or more constraints on \n&#38; components than /3z does, i.e. W Cc(@l ) ~ Cc(@z). The formalization of this intuition uses the \nconstrained mapping to establish the correspondence be\u00adtween the elements of the Pat (Y?) domains. Definition \n16 /31 ~ /32 ifl them exists a function tr : IP2 + Ipl satisfying 1. t7 #(L) <s?p, /2; 2. Vz G D : \nsvl(z) = tT(W2(Z));  9. Vi C IP2 ; .f9-rnz(i) = f(il, . . . . i,) + $*ml(-tr(i)) = f(tr(il),. . . . \ntr(iq)). Note that the above relation is only a preorder, since dis\u00adtinct elements (corresponding to \npermutations of indices) may have the same concretization. Formally, the domain should be defined as \nthe quotient of Pat ( $?) by this equiv\u00adalence relation (ss in the reduced domain construction). In practice, \nit suffices to work with a canonicalform and hence we will continue working on the abstract domain Pat \n(3?). 10The dom&#38;n of ~v, is implicitly defined by the substitution. We show generic implementation \nof the constraint mapping in terms of simpler operations on the domain 3?. These operations can be provided \nby the designer instead of the constrained mapping and operations are required to be monotonic and consistent \nabstractions of the following concrete operations: Projection: This operation projects out of term tjand \ncan be easily extended to sets of indices. C-PROJ(Q, J = {<tl,...tp>l<tl,<,tp..., ,tl,tj+l,l,tp>60}. \n Renaming: This operation permutes some of the elements. Let r : 1P + 1P be a permutation of indices. \nc-RR?J(@,r) = {<tr(,),...,~p>e@}. tr(p)>l <tl,..., Duplication: This operation duplicates an element. \nC_ DUP(@, i) = tl,t,>lt,<tl,...,tP>C@}>C@}. {<to,...,tp,>l ti,  Given a sequence of indices (;1,..., \ni~), we define C-DUP(@, (ii,... ,i~)) = C-DUP(C-DUP(@, ii), (ZZ,..., in)) (n z 1) C-DUP(@, ()) = @ The \ngeneric implementation is defined as follows. Implementation 1 The constmined mapping tr# of tr : lP, \n+ Ipl can be dejined as follows. Let PZ. = #tr(Ip, ) where #A denotes the cardinality of a set A; tr(IP2) \n= {ii,...,iP3} such thatil <. ..< iP3; 1) trlis a permutation; tT~ : IP2 + lP, such that 2) tr(trl (j)) \n= ij for j C lp3; { tT2 : lP, + ~p3 such that tm(ij) = j for j G IP3 in 11 = !R-PRoJ(g lP, \\ {il,..., \n&#38;3 }) 12 = ?R-DUP(/1, (tT2(tT(tTl (P3 + 1))), . . . . tT2(tT(tTl (P2)))) tT#(t) = 0MEN(Z2, tr:l \n). As mentioned previously, the key idea is to project irrelevant terms and to introduce new terms and \nequality constraints to obtain the new domain. Note that trlinthe implementation can be defined as follows. \nv = {j I i~~p, kv~~~p, :tr(~)=tr(j)+i <~} trl(j) = rnin{k I tr(k) = ij} ifj ~ ps = kj-p, ifj>p3 wherekl \n<... <kP,_p~ &#38; VU{kl,..., kPp3}=IP2P2. Theorem 2 Implementation 1 of the constrained mapping is \nconsistent. Proof: (t,,..., tp,) c cc(l) (t,,,..., t,,, ) G cc(k) (ttr(tr,(l)), . . . . ttr(trl(p,))) \n c Wl) (Gr(tr,(l)), . . . 2 tr(trl(pg))> %r(trl(tr2(tr(trl (p3+l))))) ~. ..> %(tr, tr (tr(tri(p2)))))) \nc cc(~2) Otr(trl(l)), . . . . %r(tr1(p9))> ~tr(trl(ps+l)), . ..> h trl(pa))) c cc (!22 ) G Cc(tr ?$(/)) \n b wwm:;i ; ;:;r$~;jp ))) (%(l), ....  Figure 2: A Generic Implementation of the Constrained mapping \n4.3 Implementation of the Abstract Operations We now turn to the implementation of the Y?-domain op erations. \nSpace requirements preclude the presentation of all operations and hence only operation UNION will be \npre\u00adsented. Operation UNION illustrates well the process of build\u00ading Pat (R) operations in terms of \n3?-operations and the ben\u00adefit of the constrained mapping to overcome the difficulty encountered for \ncertain operations in presence of global do\u00admains. The unification operation is described at length in \nthe technical report and follows more closely the traditional implementation of the domain Patt ern[19, \n23]. Specification 1 Let PI, P2 be two abstract subst~tut~ons SUCh that dom(fh) = dorn(B2) = D. WNION(/&#38;, \n/32) produces an abstmct substitution ~ such that dom(i?) = D &#38; PI, /32 5 P. TO implement the function \nUNION(/%, @2) we need to build the set of pairs (i, j) of indices that are in correspondence. Let D \nbe the domain of 91 and /32. we define the set E of pairs in correspondence induced by the same value \ncomp~ nent: The remaining correspondences can be obtained from E and the pattern component. We define \nthe set F of all correspon\u00ad dences aa the smallest set satisfying 1. (i, j)~E+(i, j)6F The number of \nindices in the abstract substitution produced by the UNION operation will be exactly the size of F, i.e. \np = #F, aa these are precisely the terms corresponding in both abstract substitutions. Of course, the \nnumber of variables n is the same in /3, ih, 92. We *O need a bijective function tr:F + 1P to estabbh \nthe relation between the old ~d the new indices of the corresponding subterms. We denote by trl:Ip+ Ip, \nand tn : 1P + lP, the functions mapping elements of 1P to lP1 and lPZ respectively. trl (k) = ~ if there \nexists (i, j) E F such that tr(i j) = k, ~d an~%ousb trz(k) = j if there etits (i, j) 6 F such that tr(i) \n~) = k Implementation 2 The operation WION@, P2 J produces an abstract substitution @ = (frm, w,/) defined \nas follows. frm = {(tr(i, j), f(tr(il, jl),..., t~(in, jn))) I (i, j)~F&#38; frml(i) = f(+,... ,i=) &#38; \ntrm2(j) = f (~1,..., jn)} = 1 $J?-UNION(tr?(fl), tr$ (Z2)) Operation UNION is typical of many operations. \nIt shows that the initial computation is driven by the pattern and the same-value components to determine \nhow to apply the W-operations. The various components are then deduced independently. Note also the simplicity \ngained by the avail\u00adability of the constrained mapping.  4.4 Applications The simplest applications \nof Pat ($?) amount to upgrading a single domain. Examples are the domain Pat (Prop) for groundless analysis \nand the domain Pat (Type), upgrading the rigid type graph of Bruynooghe and Janssens [16] for type an~Ysis. \npat (prop) produces perfectly ~curate re\u00adsults for our suite of benchmarks 1, improving on the domain \nprop for programs mtipulattig difference lists. Note that it is clear that an example losing accuracy \ncan be constructed. Pat (Type ) is a very complex domain inferring automatic~y recursive and disjunctive \ntypes. For instance, the analysis of the block planning program from Sterling and Shapiro [26] with Pat \n(Type) produces the following (optimal) grammar describing the type of the planning result: T1 ::= [] \nI cons(T2, Tl) T2 ::= to.block (ground, ground, ground) I to.table (ground, ground, groumd) The advantages \nof using Pat (9?) are twofold: on the one hand, Pat (W) factorizes sure structural information, keeping \nthe sises of the type graphs smaller; on the one hand, pag takes care of all other information such as \nmodes, same\u00ad value, and sharing. Hence, the design of Type is simplified. Another applications of Pat \n($?) consists in having 3? as an open product, combtig the two contributions of this work. The domains \nPat (OProp 8 OPS) and Pat (OProp OPS @ Ol!ode ), where O!!ode is a mode domain sssigning to each subterms \na mode from { var, ground, ngv, novar, noground, gv, any } , have been built along these lines. Finally, \nmore advanced domains can be built by defining 3? as an open domain which can receive structural informa\u00ad \ntion from the pattern component. Although most domains will not need this information, a mode domain \nmaintaining information on all subterms may benefit from this interac\u00ad tion. For 3? to be an open domain \nin this case, it is necessary to generalize dighlty the open product such that its opera\u00ad tions can be \nopen operations as well. The domain OPat (Ops @ 0140de), used to quantify the 10SS of efficiency of our \naP\u00ad proach, was defined using this approach. Note also that for most of our benchmarks, the computa\u00ad \ntion times are below 10 seconds, even for complex domains such aa Pat (OProp @ OPS @ OHode) and Pat (Type). \n5 Experimental Evaluation In this section, we briefly describe experimental results to indicate the practical \ninterest of our approach. We de\u00ad scribe the reduction in development effort, discuss respec\u00ad tively open \noperations and refinements and aasess the over\u00ad head of our approach. Only a small fraction of the available \nresults are given; see the techtical version of this paper for complete tables. The results were obtained \nwith GAIA [19], all domains being implemented in C and the system being run on a Sun SS30/10. The Benchmarks \nThe programs we use are hopefully rep\u00ad resentative of pure logic programs (i.e. without the use of dynamic \npredicates). They are taken from a number of authors and used for various purposes from compiler writing \nto equation-solvers, combinatorial problems, and theorem\u00ad proving. Hence they should be representative \nof a large claas 11The bench~=k~ ~ available by SIIOnymCWJ ftp fmm Brown di\u00ad versity and are used by \nseveral research groups. of programs. In order to accommodate the many built-ins provided in Prolog \nimplementations and not supported in our current implement ation, some programs have been ex\u00adtended with \nsome clauses achieving the effect of the built-ins. Examples are the predicates to achieve input/output, \nmeta\u00adpredicates such as set of, bagof, arg, and f unct or. The clauses containing assert and retract \nhave been dropped in the one program containing them (i.e. Syntax error han\u00addling in the reader program). \nThe program kalah is a program which plays the game of kalah. It is taken from [26] and implements an \nalpha-beta search procedure. The program press is an equation-solver program taken from [26] as well. \nWe use two versions of this program, pressl and press2, the ditTerence being that press2 has a procedure \ncall repeated in the body of a pro\u00adcedure. The program cs is a cutting-stock program taken from [28]. \nIt is a program used to generate a number of configurations representing various ways of cutting a wood \nboard into small shelves. The program uses, in various ways, the nondeterminiam of Prolog. We use two \nversions of the program; one of them (i.e. c~l) assumes that the data are ground while the other one \n(i.e. CS) assumes that the data are ground lists. The program dk j is taken from [11] and is the generate \nand test equivalent of a constraint program used to solve a disjunctive scheduling problem. This is also \na program using the nondeterminism of Prolog. Once again, we use two versions of the program with the \nsame distinc\u00adtion sa for the cutting stock example. The program read is the tokenieer and reader written \nby R. O keefe and D.H.D. Warren for Prolog. It is mairdy a deterministic program, with mutually recursive \nprocedures. The program pg is a program written by W. Older to solve a specific mathemat\u00adical problem. \nThe program gabriel is the Browse program taken from Gabriel benchmadrs. The program plan is a planning \nprogram taken from Sterling &#38; Shapiro. The pro\u00adgram queens is a simple program to solve the n-queens \nprob\u00adlem. peep is a program written by S. Debray to carry out the peephole optimization in the SB-Prolog \ncompiler. It is a deterministic program. We also use the traditional con\u00adcatenation and quickeort programs, \nsay append (with input modes (var, var ,ground) ) and qsort (difference lists). On the Development Effort \nWe first give some ideaa about the effort necessary to produce the sophisticated domain OPAT (OProp@OHode@OPS \n). The overall implementation of the system is 17,712 lines of C, split in 15,759 lines in . c tiles \n(Programs) and 1,953 lines in .h files (data structure defifi\u00adtlons). The mode component requires 822 \nlines (785 + 37), the sharing component requires 800 lines (761 + 39), and the Prop component requires \n1791 lines (1766 + 25). For this application, only 19% of the overall code needs to be supplied. Domain \nOPAT (OHodet30PS ) needs only to produce about 10% of the overall code. Its domain part (1622 lines) \nproduces a reduction of about 40% over the direct imple\u00admentation (i.e. the domain Pattern [19]12) which \nrequires 2657 lines (2463 + 194). As should be clear, our approach reduces the development effort substantially. \nNote also that the above figures do not account for the support in the de\u00adsign process, which allows \ndesigners to concentrate on one domain at a time and to be liberated from structural infor\u00admation. 12we \n~hu~ have two i~plementations of the domain pattern: a l\u00ad rect one and one built using the techniques \ndescribed in this paper. These two versions will be compared later with respect to efficiency. On the \nImportance of Open Operations We now investigate the importance of open operations to find out whether \nre\u00adfinement operations can recover the loss of information com\u00ading from a direct product. The domain \nOPAT(OHode@OPS) is used for the experimental results in its standard version (denoted by S) and in a \nmodified version (denoted IUJ) where Oltode and UPS can only interact through the refinement op\u00aderations. \nThe accuracy results demonstrate the importance of open operations. As far as input patterns are concerned, \nNq loses in the average about 26% accuracy for modes, 81% for freeness, 0.42% for groundless, and has \n105% sharing with respect to S. As far as output patterns axe consid\u00adered, N(J exhibits substantially \nmore sharing thau S (e.g. up to 50 times more sharing on some of the larger programs). Although they \nare appropriate to adjust groundless infor\u00admation, refinement operations lose much precision for other \nmeasures such as freeness, input modes, and sharing. In these cases, refinements cannot recover the information \nlost during the operations. The efficiency results show that S is slightly more efficient than Nq in \nthe average, demonstrat\u00ading that open operations are particularly appropriate e. In the average, Nq is \n1.05 slower than S. Note that S is about twice faster than Nq on one of the benchmmk programs. On the \nImportance of Refinements We now investigate the import ante of refinements in conjunction with open \nopera\u00adtions to find out whether open operations are sophkticated enough to eliminate the need for refinements. \nWe use the domain OPAT(OFIode@OPS) for the experimented results in its standard version (denoted by S) \nand in a modified version (denoted NR) where no refinement operations are used. The accuracy results \nare the same for the inputs and difer only on sharing for the outputs. In this cue, NR produces about \n230% of the sharing of S. This indicates that refinement op\u00aderations can improve substantially the sharing \ncomponent on the output patterns and seem to be useful in general, al\u00adthough the gain seems much less \ndramatic than in the case of open operations. More importantly perhaps, the efficiency results indicate \nthat NR is about 1.3 times slower in the av\u00aderage than S, indicating that refinement operations can also \nimprove efficiency by reducing the number of iterations. On the Overhead of the Approach We turn to the \noverhead of our approach in OPAT (OModet30PS ) compared to a direct implementation of our pattern domain \n[19]. Of course, both domains have exactly the same accuracy. Our approach in\u00adtroduces mainly three forms \nof overheads: (1) global opera\u00ad tions: the generic pattern domain has provisions to accom\u00admodate global \ninformation on subterms which complicates the operations when only local information is used as in OPAT \n(OMode@OPS); (2) memor~ management: the approach allocates and dezdlocates memory with a much smaller \ngran\u00adularity because the domains are disconnected; (3) queries: the query mechanism introduces an additional \nlayer necee\u00adsary to combine the domain. The results indicate that the direct implementation requires \nabout 43% of the time of standard version. This is an acceptable overhead given the significant reduction \nin development time offered by the ap\u00adproach. However, the overhead should be interpreted with care, \nsince the implementation has not be tuned with the same care as the direct implementation. In particular, \nthe overhead can be sigticwtly reduced by improving mem\u00adory management, caching queries whenever appropriate, \nand specializing the implement ation when the full generality is not needed. This is obviously an important \ntopic for further resezuch. 6 Conclusion The purpose of this paper was to tackle one of the most important \nopen problems in the design of static analysis of logic programs: the building of abstract domains. This \nproblem is important, since logic program analyses are in general quite sophisticated because of the \nneed to integrate various interdependent analyses and to maintain structural information. The paper introduced \ntwo new ideas: the notion of open product and a generic pattern domain. The open product enables the \ncombination of domains where the components interact through the notions of queries and open operations. \nIt provides a rich framework to build complex combina\u00adtions of domains, including the reduced product \nconstruc\u00adtion. The generic pattern domain upgrades automatically a domain with structural information \nproviding an (often substantial) increase in accuracy at no additional cost in design and implementation. \nBoth contributions have been validated theoretically and experimentally and the experi\u00admental results \nshowed the practical benefits of our approach. Future work on the theory will focus on generalizing the \nnotion of open product in several directions. A promisi\u00adng line of research amounts of viewing all operations \nas coroutines communicating information whenever appropri\u00adate. This may allow to view Pat (Y?) as a product \nalthough the theoretical and practical consequences of this view are still to be explored. On the practical \nside, fine-tuning the implementation and a better environment for designers are the first priorities. \n7 Acknowledgments Comments and suggestions from the reviewers helped im\u00adprove the presentation. F&#38;h\u00ad \n[1] A. Bossi, M. Gabbrielli, G Levi, and M-C. Meo. Con\u00adtribution to the Semantics of Open Logic Programs. \nIn Proc. of ht. Conf. on Fifth Generation Computer Sy.+ terns, Tokyo, June 1992. [2] M. Bruynooghe. A \nPractical Framework for the Ab\u00adstract Interpretation of Logic Programs. Journal of Logic Programming, \n10:91-124, 1991. [3] M. Codish, A. Mulkers, M. Bruynooghe, M. Garcia de la Banda, and M. Hermenegildo. \nImproving Abstract Interpretations by Combining Domains. In Proceed\u00adings of the ACM Symposium on Partiat \nEvaluation and Semantics-Based Progmm Manipulation (PEPM93), Copenhagen, Denmark, June 1993. [4] A. Cortesi, \nG. Fi16, and W. Winsborough. Prop re\u00advisited: Propositional formdas as abstract domain for groundless \nanalysis. In Proc. Sixth Annual IEEE Sym\u00adposium on Logic in Computer Science (LICS 91), pages 322 327, \n1991. [5] A. Cortesi, G. Fi16, and W. Winsborough. Compari\u00adson of Abstract Interpretations. In F%oc. \n19th hterna\u00adtional; Colloquium on Automata, Languages and Pro\u00adgmmming (ICALP 92), 1992. [6] A. Cortesi, \nB. Le Charlier, and P. Van Hentenryck. Conceptual and Software Support for Abstract Domsin Design: Generic \nStructural Domain and Open Product. Technical Report CS-93-13, CS Department, Brown University, 1993. \n[7] P Cousot and R. Cousot. Abstract Interpretation: A Unified Lattice Model for Static Analysis of Programs \nby Construction or Approximation of Fixpoints. In Conf. Record of Fourth ACM Symposium on Program\u00adming \nLanguages [POPL 77), pages 238-252, Los Ange\u00adles, CA, 1977. [8] P Cousot and R. Cousot. Systematic Design \nof Program Analysis Frameworks. In Conf. Record of Sixth A Cikl Symposium on Programming Languages (POPL \n79), pages 269 282, San Antonio, Tx, 1979. [9] P. Cousot and R. Cousot. Abstract Interpretation and Application \nto Logic Programs. Journal of Logic Pro\u00adgramming, 13(2-3), 1992. [10] S. Debray. Efficient Dat aflow \nAnalysis of Logic Pro\u00adgrams. ,7A CM, 39(4):949-984, 1992. [11] M. Dincbas, H. Simonis, and P. Van Hentenryck. \nSolv\u00ading Large Combinatorial Problems in Logic Program\u00adming. Journal of Logic Progmmming, 8(1-2):75-93, \n1990. [12] V. Englebert, B. Le Charlier, D. Roland, and P. Van Hentenryck. Genetic Abstract Interpretation \nAlgorithms for Prolog: Two Optimization Techniques and Their Experimental Evaluation. Software Practice \nand Experience, 23(4), April 1993. [13] R. Giacobazzi, S. Debray, and G. Levi. A Generalized Semantics \nfor Constraint Logic Programs. In FGCS 92, Tokyo, June 1992. [14] N. Heintze and J. Ja.far. An Engine \nfor Logic Program Analysis. In IEEE 7th Annual Symposium on Logic in Computer Science, 1992. [15] M. \nHermenegildo, R. Warren, and S. Debray. Global Flow Analysis as a Practical Compilation Tool. Journal \nof Logic Programming, 13(4):349 367, 1992. [16] G. Janssens and M. Bruynooghe. Deriving Descr@\u00adtion of \nPossible Values of Program Variables by Means of Abstract Interpretation. .Tournai of Logic Program\u00adming, \n13(2-3):205 258, 1992. [17] T. Kanamori and T. Kawamura. Analysing Success Patterns of Logic Programs \nby Abstract Hybrid Inter\u00adpretation. Technical report, ICOT, 1987. [18] B. Le CharIier, K. Musumbu, and \nP. Van Henten\u00adryck. A Generic Abstract Interpretation Algorithm and Its Complexity Analysis (Extended \nAbstract). In Eighth International Conference on Logic Programming (ICLP-91), Paris (France), June 1991. \n [19] B. Le Charlier and P. Van Hentenryck. Experimen\u00adtal Evaluation of a Generic Abstract Interpretation \nAlgorithm for Prolog. ACM Tmnsactions on Pro\u00adgmmming Languages and Systems. To appear. An extended abstract \nappeared in the Proceedings of Fourth IEEE International Conference on Computer Languages (ICCL 92), \nSan Francisco, CA, April 1992. [20] B. Le Charlier and P. Van Hentenryck. Reexecution in Abstract Interpretation \nof Prolog. In Proceedings of the International Joint Conference and Symposium on Logic Progmmming (JICSLP-92), \nWashington, DC, November 1992. [21] B. Le Charlier and P. Van Hentenryck. Groundless Analysis for Prolog: \nImplementation and Evaluation of the Domain Prop. In Proceedings of the ACM Sgmposium on Partial Evaluation \nand Semantics-Based Progmm Manipulation (PEPM93), Copenhagen, Den\u00admark, June 1993. [22] K. Marriott and \nH. Sondergaard. Abstract Interpre\u00adtation of Logic Programs: the Denotational Approach, June 1990. To \nappear in ACM Transaction on Pro\u00adgramming Languages. [23] K. Musumbu. Interpretation Abstmite de Programmed \nProlog. PhD thesis, University of Namur (Belgium), September 1990. [24] A. Mycroft. Completeness and \nPredicate-Bsaed Ab\u00adstract Interpretation. In Proceedings of the ACM Sym\u00adposium on Partial Evaluation \nand Semantics-Based Program Manipulation (PEPM93), Copenhagen, Den\u00admark, June 1993. [25] F. Nielson. \nTensor Product Generalise the Relational Data Flow Analysis Method. In Proceedings of the Fourth Hungarian \nComputer Science Conference, 1985. [26] L. Sterling and E. Shapiro. The Art of Prolog: Advanced Progmmming \nTechniques. MIT Press, Cambridge, Ma, 1986. [27] A. Taylor. LIPS on MIPS: Results From a Prolog Com\u00adpiler \nfor a RISC. In Seventh International Conference on Logic Programming (ICLP-90), Jerusalem, Israel, June \n1990. [28] P. Van Hentenryck. Constmint Satisfaction in Logic Progmmming. Logic Programming Series, The \nMIT Press, Cambridge, MA, 1989. [29] P. Vim Roy and A. Despain. High-Performance Com\u00adputing with the \nAquarius Compiler. IEEE Computer, 25(l), January 1992.  \n\t\t\t", "proc_id": "174675", "abstract": "<p>Abstract interpretation [7] is a systematic methodology to designstatic program analysis which has been studied extensively in the logicprogramming community, because of the potential for optimizations inlogic programming compilers and the sophistication of the analyses whichrequire conceptual support. With the emergence of efficient genericabstract interpretation algorithms for logic programming, the mainburden in building an analysis is the abstract domain which gives a safeapproximation of the concrete domain of computation. However, accurateabstract domains for logic programming are often complex because of thevariety of analyses to perform their interdependence, and the need tomaintain structural information. The purpose of this paper is to proposeconceptual and  software support for the design of abstract domains. Itcontains two main contributions: the notion of open product and ageneric pattern domain. The <?Pub Fmt italic>openproduct<?Pub Fmt /italic> is a new way of combining abstract domainsallowing each combined domain to benefit from information from the othercomponents through the notions of queries and open operations. The openproduct is general-purpose and can be used for other programmingparadigms as well. <?Pub Fmt italic>The generic patterndomain<?Pub Fmt /italic> Pat (<inline-equation><f><ge>R</ge></f> </inline-equation>)automatically upgrades a domain D with structuralinformation yielding a more accurate domain Pat (D) without additionaldesign or implementation cost. The two contributions are orthogonal andcan be combined  in various ways to obtain sophisticated domains whileimposing minimal requirements on the designer. Both contributions arecharacterized theoretically and experimentally and were used to designvery complex abstract domains such as PAT(OProp<inline-equation><f>&otimes;</f></inline-equation>OMode<inline-equation><f>&otimes;</f><?Pub Caret></inline-equation>OPS) which would be very difficult todesign otherwise. On this last domain, designers need only contributeabout 20% (about 3,400 lines) of the complete system (about 17,700lines).</p>", "authors": [{"name": "Agostino Cortesi", "author_profile_id": "81100077606", "affiliation": "", "person_id": "PP39026106", "email_address": "", "orcid_id": ""}, {"name": "Baudouin Le Charlier", "author_profile_id": "81100163814", "affiliation": "", "person_id": "PP31084112", "email_address": "", "orcid_id": ""}, {"name": "Pascal Van Hentenryck", "author_profile_id": "81100594830", "affiliation": "", "person_id": "PP14205263", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/174675.177880", "year": "1994", "article_id": "177880", "conference": "POPL", "title": "Combinations of abstract domains for logic programming", "url": "http://dl.acm.org/citation.cfm?id=177880"}