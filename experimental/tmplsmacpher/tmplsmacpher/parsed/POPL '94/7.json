{"article_publication_date": "02-01-1994", "fulltext": "\n Higher-Order Concurrent Programs with Finite Communication Topology (Extended Abstract) Hanne Riis \nNielson Flemming Nielson Computer Science Department Aarhus University, Denmark. e-mail: {hmielson, \nfnielson}@daimi. aau dk Abstract 1 Introduction Concurrent ML (CML) is an extension of the functional \nHigher-order concurrent languages as CML [8] and Faci\u00adlanguage Standard ML (SML) with primitives for \nthe le [2] offer mechanisms for the dgnurnic creation of chan\u00addynamic creation of processes and channels \nand for the nels and processes in addition to the possibility of send\u00adcommunication of values over channels. \nBecause of the ing and receiving values over channels. To obtain an powerful abstraction mechanisms the \ncommunication e~cient implementation of programs in such languages topology of a given program may be \nvery complex and we would need information about their communication therefore an efficient implementation \nmaybe facilitated topology: by knowledge of the topology. . Does the program only spawn a finite number \nof This paper presents an analysis for determining when processes? a bounded number of processes and \nchannels will be generated. The analysis proceeds in two stages. First Does the program only create \na finite number of we extend a polymorphic type system for SML to de-channels? duce not only the type \nof CML programs but also their communication behaviour expressed as terms in a new If the answer to the \nfirst question is yes we may load the process algebra. Next we develop an analysis that given processes \non the available processors and dispense with the communication behaviour predicts the number of multitasking. \nIf additionally the answer to the second processes and channels required during the execution question \nis yes we may allocate the channels statically of the CML program. The correctness of the analysis is \nand dispense with multiplexing. This leads to consider\u00adproved using a subject reduction property for \nthe type able savings in the run-time system. system. In this paper we present an analysts of the communz\u00adcutzon \ntopology of CML programs. It proceeds in two Permission to copy without fee all or part of this material \nis stages: granted provided that the copies are not mada or distributed for direct commercial advantaga, \ntha ACM copyright notica and tha o Extract the communication behaviour of the pro\u00ad titla of tha publication \nand its data appear, and notica ia givan that copying is by permission of the Association for Computing \n gram. Machinery. To copy otherwise, or to republish, requires a foe . Analyse the topology of the \ncommunication be\u00ad ar-dor spacific permission. haviour. POPL 94-1K14, Portland Oregon, USA @ 1994 ACM \n0-89791436-0/94/001 ..$3.50  The first stage is based on the effect systems developed in [3, 10] for \npolymorphic type inference of functional languages with references. The basic insight is that a precise \npicture of the communication topology neces\u00adsitates more causality in the effects than would result from \na straightforward modification of [10] (ss done in [12]). We then establish a subject reduction property \nfor the effect system and this shows that the execution of the CML program is correctly modelled by the \nevolu\u00adtion of the communication behaviour. For the second stage we present an inference system that predicts \nthe number of processes and channels cre\u00adated during the evolution of behaviors. The analysis is proved \ncorrect with respect to the semantics of be\u00adhaviors; and using the subject reduction property the correctness \nresult carries over to CML programs. The idea of using tgpes to extract the communication behaviour of \nprograms goes back to [6] and the idea of using types and effects to extract the side effects of pro\u00adgrams \ngoes back to [3]. An application of types and ef\u00adfects to languages with concurrency constructs includes \n[12] and this may be regarded as an improvement over [6]. In [7] the approach is extended to retain the \ncausal\u00adity of the various effects and this amounts to extracting a process algebm for a mono-typed version \nof CML. Sec\u00adtions 2, 3 and 4 of the present paper can be viewed ss an eztenszon of this method to a polymorphically \ntyped version of CML: we define the process algebra of CML and its semantics and then the subject reduction \nprop\u00aderty expresses the relationship between CML and the process algebra. However, there are also some \nimportant differences be\u00adtween the present approach and that of [7]. One is that [7] uses a type system \nbased on subtyping whereas we use instantiation of polymorphic types. Another differ\u00adence is that here \nthe semantics of behaviors is defined independently of the type system: using a notion of sim\u00adulation \nclose to that of CHOCS [11] (and CCS [4]) we provide laws for those behaviors that can be used in the \ntype system; this is an improvement over [7] where the laws used in the type system are also used in \nthe specification of the semantics of the behaviors. In summary, we believe that this paper presents \nthe first proverdy correct static analysis of the communication topology of concurrent programs. Polymorphic \nBehaviors We shall follow [1, 9] and study a polymorphic subset of CML with expressions e c Exp given \nby .._ e clxlfnx=>elelez l letz=e~in e~lrecjz=>e I if e then el else e2  Here x and ~ are program variables. \nIn addition to function abstraction and function application we have a polymorphic let-construct, recursion \nand a condi\u00ad tional. The constants c G Const are given by c ::= () Itrue \\false In I pair I fst I snd \nI nil Icons Ihd Itl Iisnil I send I receive I choose 1 wrap I sync I channel I fork I +1 *1=1... We \nhave constants corresponding to the base types unit, bool and int together with operations for construct\u00ad \ning and destructing pairs and lists. There are oper\u00ad ations for sending and receiving values over channels, \nfor choosing between various communication possibili\u00ad ties and for modifying values being communicated. \nAc\u00ad tually, these primitives construct suspended communi\u00ad cations that may be enacted using synchronisation. \nFi\u00ad nally, there are primitives for creating new channels and processes. As usual we shall use types \nto classify the values that expressions can evaluate to. When executing a CML program channels and processes \nmay be created and values may be communicated and we shall extend the type system with behatiours to \nrecord this. Channels are associated with channel identifiers when programs execute and to record this \nwe introduce regions into the type system, For types t 6 Typ we take t ::= unit Ibool Iint Ia I tl+~tzlt~xt~ltlist \nI tcha.nrlt comb where a is a meta-variable for type variables, The func\u00adtion type is written tl -+b \nt2 indicating that the argu\u00adment type of the functions is tl, the result type is t2 and the latent behaviour \nis b thus when a function is supplied with an argument the resulting behaviour will be b. The type of \na channel is t than r indicating that the channel is allocated in region r and that values of type t \ncan be communicated over it. Finally, tcom bis the type of a suspended communication: when it even\u00adtually \nis enacted using sync, it will result in a value of type tand the resulting behaviour will be b. Formally, \nbehaviors b G Beh are given by b ::= elr!tlr?tltCHANrl~ I Fo~blb1;b21b1+b21REC@.b  Here c stands for \nthe non-observable behaviour. We write r!t for sending a value of type t over a channel c TypeOf(c) () \ntrue false n pair f St snd nil cons hd tl isnil send receive choose wrap sync channel fork +  Table \n1: Type Schemes for Constants in region r and similarly r?t for receiving a value of Here p denotes a \nmeta-variable for region variables and type i! over a channel in region r. The allocation of a ro, rl, \n. . . denote region constants. new channel in region r is written t CHAN r where tis The type schemes \nare obtained from types by quantify\u00adthe type of values to be communicated. The behaviour ing over type \nvariables, behaviour variables and region FORK b expresses that a process with behaviour b is variables: \nthey have the form V&#38;$#.t where G, ~ and spawned. Behaviors may be combined using sequenc\u00ad~ are lists \nof variables. Each constant has associated aing and choice and they may be recursive, We write type scheme \nas shown in Table 1. /3 for a meta-variable for behaviour variables. So for example REC ~. (t CHAN r \n+ FORK(r?t; ~)) is the be-Occasionally, the context may demand that a subex\u00adhaviour of a program that \neither will create a channel pression is given a type with a latent behaviour that is and then no more \ncommunications take place or it will larger than it really is. This is illustrated by the follow\u00adspawn \na process that inputs on some channel and then ing example: the overall process will recurse. Example \n1 Consider the program Finally, regions r G Reg are given by choose [send (ch, 7) , r ::= rolrll wrap \n(receive ch , fn x => I)] 1P tenvkc: t&#38;b if TypeOf(c) > tand e G b tenvt-x: t&#38;b if tenv(x) > \nt and c G b tenv~e tenv[xwt]l-e:t &#38;b tenvl-fn x=Ye:tdbt &#38;b :t4btf&#38;b tenvl-e2:t&#38;b2 tenv \n!\u00adel e2 : i? &#38; b ife~b if bl; b2; b ~ b tenv t\u00ad el : tl &#38; tenvl-let bl tenv[z x=e1ine2:t2 w \nts] 1-e2 &#38;b : t2 &#38; b2 if ts = gen(tenv, bl)tl and bl; b2 z b tenv tenv[f~t -+bt ][z=t] i-e :t \n&#38; b tenv 1-rec f(~)=>e : t ~b t &#38; b 1-e : bool &#38; b tenvl-el:t&#38;bl tenvl-e2: tenv F if \ne then el else e2 : t&#38; b t&#38;b ifc~b if b;(bl +b2) ~ b Table 2: Typing System where we for the \nsake of readability y write [e 1, ez1 for cons el (cons ez nil) and (el, e2) for pair el e2. The first \nelement of the list has type int com r !int (assuming ch hss type int than r) and the second el\u00adement \nhas type int com r ?bool (sssuming ch has type bool then r ). We want the list to have type int com \n(r! int + r ?bool) to record that either one of the branches may be ch~ sen at run-time. So we need \nto coerce the types int com r ! int and int com r ?bool into int corn (r! lnt + r ?bool). o Basically, \nthere are two approaches we may adopt: .&#38;de subsumption coercions can happen at any time inside \nany type, as when the type system has a general subsumption rule on types.  Early subsumption generic \ninstantiation produce the required specialised types.  In [7] we used the first approach for a mono-typed \nver\u00adsion of the language thereby obtaining a type system with subtyping. We are now in a polymorphic \nsetting and to avoid potential problems from the presence of both polymorphism and subtyping we shall \nuse the sec\u00adond approach (also taken in [10]). This means that the latent behaviour of functions and \nsuspended communi\u00adcations always must be prepared to be larger than what seems to be needed and this \naccounts for the +/3 com\u00adponents in the behaviors of the form b +/3 in Table 1. Note that only the constants \nsync, channel and fork have a non-trivial latent behaviour (i.e. have b # c). A type t isa genetic instance \nof a type scheme ts = V@f7.tO, written ts+t if there exists a substitution 0 with Dom(0) = {c@pl such \nthat 0 to= t. Here a substitution 0 is a finite mapping from type variables, behaviour variables and \nregion variables to types, behaviors and regions, re spectively, and we write Dom(0) for its (finite) \ndomain. Furthermore, a type scheme ts is an instance of ts, written ts Fts if whenever ts > t also ts \n> t. The typing judgments have the form tenv Fe:t&#38;b where tenv is a type environment mapping variables \nto type schemes, t isthe type ofeand bisitsbe\u00adhaviour, Since CML has a call-by-value semantics there \nis no behaviour associated with accessing a variable and therefore the type environment does not contain \nany be haviour component (except within type schemes). The typing rules are given in Table 2 and are \nfairly close to the standard ones with the only exception being that also behaviour information is collected. \nThe types of constants and variables are obtained as generic in\u00adstances of the appropriate type schemes. \nThe actual behaviour is c but, as mentioned earlier, we may want to use a larger behaviour and to express \nthis we intr~ duce an ordering Q on behaviors. This turns out to be a general pattern of the axioms and \nrules: it is always possible to enlarge the actual behaviour. o pre-order laws P1. b~b P2. if bl L b2 \nand b2 L b3 then bl ~ ~ e pre-congruence laws Cl. if bl ~ b2 and b3 Pb4 then bl; b3 ~b2; b4 c2. if bl \nE b2 and b3 L b4 then bl + b3 L b2 + b4 C3. if bl ~ b2 then FORK bl C FORK b C4. if bl G b2 then REC \n/3. bl ~ REC ~. b2 o laws for sequencing S1. bl; (bz; bs) G (bl;bz);bs and (bl;bz);bs Lbl; (bz; bs) s2. \n(bl+b2);bs G (bl; bs)+ (bz;bs) and (bl;bs) +(bz;bs) L (bI +b); &#38; o laws for e El. bpe; bande; bcb \nE2. b;ccbandb~b; e o laws for choice (or join) Jl, bl ~ bl + b2 and b2 ~ bl + b2 J2. b+b Gb laws for \nrecursion IU. REC p. b G b[~ w REC P. b] and b[~ w REC /3. b] G REC ,f3. b Table 3: Ordering on Behaviors \n In the rule for function abstraction we record the be\u00adhaviour of the body of the function as the latent \nbe\u00adhaviour of the function type. The construction of a function does not in itself have an observable \nbehaviour and so is e. In the rule for function application we see that the actual behaviour of the composite \nconstruct is that of the operator followed by that of the operand and then the behaviour initiated by \nthe function application itsel~ the latter is exactly the latent behaviour of the function type. One \nmay note that it is inherent in this rule that CML has a call-by-value semantics. In the rule for local \ndefinitions we generalise over those type variables, behaviour variables and region variables that neither \noccur free in the type environment nor in the behaviour; this is expressed by gen(tenv, b)t = let {d~fi \n= FV(t) \\ (FV(tenv) U IW(b)) in Vd/?~.t where FV(. ..) is the set of free type variables, behaviour variables \nand region variables of . . .. The actual be\u00adhaviour of the let-construct simply expresses that the local \nvalue is computed before the body. In the rule for recursive functions we make sure that the actual be \nhaviour is equal to the latent behaviour of the type of the recursive function. The rule for conditional \nshould be straightforward. The ordering G on behaviors is defined by the axioms and rules of Table 3. \nThus we require c to be a pre\u00adorder and a pre-congruence. Furthermore, sequencing is an associative operation \nwith c as identity and we have a distributive law with respect to choice. A consequence of the laws for \nchoice is that choice is associative and commutative. Finally, the law for recursion allows to unfold \nthe RIsc-construct. Remark The main difference between the typing sy~ tern presented here and those of \n[10, 12] is that we keep the dependencies between the individual communicat\u00adions. If we were to extend \nTable 3 with bl;bz Q bl +bz bl+~~bl; b2 RIWfl.b~b[~~e] b[~~c]~rmcfl.b then our system would degrade to \nthe level of the sys\u00adtems in [10, 12]. o Example 2 To illustrate the kind of information pr~ vialed by \nthe behaviors consider the following program. It is given a list of functions and two channels and then \ncreates one process for each function in the list and sub\u00adsequently connects all functions into a pipeline. \n let process = Operator Operand Result fn f=>fn in =>fn out => fork (ret loop d => sync (wrap (receive \nin, fn x=> sync (send (out, f x)))); loop ()) in rec pipe fs =>fn in =>fn out => if isnil fs then process \n(fn x => x) in out else let ch = channel () in (process (hd fs) in ch; pipe (tl fs) ch out) For the \nsake of readability we have written el;ez as an abbreviation for (fn dummy => e2) el. The typeof processis \n Vq, Cq,p,p~,pz.(CqJ q) + (al than pl) + (q than p~) -+b unit where b= FORK (REc@. (pl?al; P; p2!a2; \nP )) Fromthisbehaviour weseethatproces swillcreateone proceas and nochannels. Turning to the main program \nthetypeis VcY,/3,p. (a~~a)list -+C (~ chap) ~c (~ chanp) ~b unit where b = REC ~ . (FORK (REC p . (p?a; \np!a; Y)) + CYCHANP; FORK (REC /3 . (p?a; p; p!a; /3 )); P ) From this we see that any number of processes \nand any number of channels may be generated. 0 Semantics We shall now present a structural operational \nsemantics for CIvfL. The formulation is close in spirit to [9] and amounts to three inference systems: \none for sequential evaluation, one for concurrent evaluation, and to handle synchronisation we also need \none for matching the com\u00admunications against one another. This is mimicked in the specification of the \nsemantics of behaviors where isnil (cons WI WZ) false pair WI (pair WI) (pair w1) W2 (pair WI WQ) fst \n(pair WI WQ) WI snd (pair w~ WQ) W2 cons WI (cons w~) (cons WI) W2 (cons w, WZ) hd (cons WI WQ) WI tl \n(cons WI WZ) W2 isnil nil true send w (send w) receive w (receive w) choose w (choose w) wrap w (wrap \nw) + nl (+ nl) (+nl) nz nwhere n=nl +n2 Table 4: Tabulation of 6 we have one inference system for sequential \nevolution and one for wncument evolution. Matching is much simpler for behaviors than for programs so \nthere is no need for a special matching relation. Semantics of CML We begin with the sequential evaluation \nof expressions. This takes care of all primitives of CML except sync, channel and fork which are the \nconstants of Table 1 with a non-trivial latent behaviour. The transition r~ lation for sequential evaluation \nhas the form e-+e where e and e are closed expressions, i.e. they do not contain free program variables. \nTo enforce a left-to\u00adright evaluation we introduce the concept of an evalu\u00adation contezt E which specifies \nwhere the next step of the computation may take place: E ::= []1 Eelw Elletz=Eine I if E thenel else \ne2 E [ret j(z) =>e] + E [(fn z=>e)[~ w (ret ~(z) =>e)]] E[(fnz=>e)w] ~ E[e[z~@ E[letz= wine] ~ E[e[z% \nw]] E [el] if w = true E [if w then el else e2] ~ E [e2] if w = false { E [WI W2] + E [W3] if (W1, WZ, \nW3) G 6 Table 5: Sequential Evaluation Here w G WExp denotes a weakly evaluated expressio~ i.e. an expression \nthat cannot be further evaluated. The idea is that [] is an empty context (called a hole) and in general \nE specifies a context with exactly one hole in it. We shall then write E[e] for the expression E with \nthe hole replaced by e. The next step of the com\u00adputation will take place at the point indicated by the \nhole. As an example consider function application. The presence of E e means that computations in the \noper\u00adator pmition are possible whereas the presence of w E means that computations in the operand position \nonly are possible when the operator is weakly evaluated (e.g. to a function abstraction). In this way \nit is ensured that the operator as well as the operand are evaluated be\u00adfore the function application \nitself takes place (e.g. by a /3-reduction). The weakly evaluated expressions are given by .._ w .. clzlfnz=>e \nI (cw~)t... l(cwwn). wn) where n > 1. Weakly evaluated expressions of the form (c WI . . . Wi) are used \nto record the evaluation of con\u00adstants as indicated in Table 4 where we define the rela\u00adtion 6 C WEXP \nx WEXP x WEXP. The transition relation is specified in Table 5 where we write e[z w w] for the expression \ne with all free occur\u00adrences of z replaced by w. The clauses should be fairly straightforward. The first \nrule expresses the one-level unfolding of a recursive definition. Then we have ax\u00adioms for ~reduction \nand for let-reduction. The fourth axiom is an abbreviation for two axioms expressing the evaluation of \na conditional depending on the outcome of the test. Finally, there is an a~iorm for $-reduction which \ninspects Table 4 to determine the result. We shall now introduce the transition relation for con\u00adcurrent \nevaluation. Channels will be associated with channel identifiers, ci E CIdent, and processes with process \nidentifiers, pi ~ PIdent. The configurations have the form CI &#38; PP where CI is the set of channel \nidentifiers that are in use and PP is a (finite) mapping of process identifiers to expressions. The transition \nrc+ lation is written (7I &#38; PP --+2 C I &#38; PP where ev is the event that takes place and ps is \na list of the processes that take part in the event depending on the event there will be either one \nor two processes involved. An event has one of the forms ev ::= c I CHAN ci I FORK pi 1 (ci!, ci?) and \nmay record the empty event, the creation of a chan\u00adnel with a given channel identifier, the creation \nof a process with a given process identifier and the commu\u00adnication over a channel. The transition relation \nis specified in Table 6. The first rule embeds sequential evaluation within concur\u00adrent evaluation and \nthe name of the process performing the event is recorded. The second rule captures the cr~ ation of a \nnew channel. The channel is associated with a new channel identifier and the transition records the name \nof the process performing the event together with the event itself. The third rule takes care of process \ncreation and follows the same lines. Here we record the process performing the event as well as the one \nbeing created by the event. Finally, we have a rule expressing the synchronisation of communications \nand here we use the matching relation. The transition records the two processes involved in the communication \nas well as the channel used for it. Finally, the matching relation is given two weakly eval\u00aduated expressions \nthat are ready to synchronise and it specifies the outcome of the communication and records the event \nthat takes place. This is expressed by a rela\u00adtion of the form The relation is speeified in Table 7. \nThe first axiom cap\u00adtures the communication between a send and a receive CI&#38; PP~i w E[channel ()]] \n-j; c~CI U {ci} k PP~i H E[ei]] ifci#CI CI&#38;PP~zl w E[forkw]] +~,~j,ti CI&#38;PP@l I+ E[()]]@2 H \nw()] if pi2 # Dom(PP) U @il } CI&#38; PP~il w El[sync wI]]~~2 (WI , W2) &#38;K?) (cl, @ -%[sync w2]] \n+~~~ ~ ez) ) CI&#38;PP~il # ,??l[el]]~iz H Fq[ez]] ifpil #pi2 Table 6: Concurrent Evaluation ::= e IT!t \nIT?i! It CHAN ?_I FORK b ((send(pair ci w)), (receive ci)) W) (w, w) P Here e is supposed to capture \nthe sequential evaluation steps of CML expressions whereas the remaining atomic(WI, w3) ~%dz) (cl, es) \nbehaviors capture the concurrent steps. ((choose (cons WI w2)), W3) ~~d ) (cl, e,) The relation is specified \nin Table 8. The first axiom expresses that any atomic behaviour can be performed (( choose W2), W3) ~~~ \n) (ez, es) and in doing so becomes c. The second axiom expresses ((choose (cons WI w2)), w3) dLdz) (ez, \nes) that c can terminate; in fact this is the only behaviour that in one step can reaeh the terminal \nconfiguration. (WI, w3) ~~~z) (cl, es) The third axiom means that at any time any number of ((wrap(pair \nWI w2)), w~) ~~~z) (wz el, es) e actions can be performed by any behaviour (observe that the terminal \nconfiguration is excluded here /is (WI, W2) d&#38;d ) (cl, ez) a stuck configuration). This axiom reflects \nthat in the semantics of CML any number of evaluation steps can (w2, WI) %1 ) (ez, el) be performed in \nthe functional part of CML between those involving the concurrency primitives. The fourth axiom expresses \nthe unfolding of a recursive behaviour. Table 7: Matching Then we have two rules for the evolution of \nsequential behaviors: only when the evolution of the first comp~ construct. The second and third axiom \ntake care of the nent has reached a terminal configuration is it possible situation where there are several \npossible communica-to start evolution of the second component. The last tions available in the first \ncomponent. The fourth axiom two rules express the evolution of a choice between two shows how the communicated \nvalue may be modified us-behaviors. ing the wrap construct. Finally, we have a restructuring To express \nthe concurrent evolution of behaviors we in\u00adrule. troduce process identifiers as in the semantics of \nCML. The transitions have the form Semantics of Behaviors PB +;, PB We begin with the sequential evolution \nof behaviors. where PB and PB are mappings from process iden-Here the configurations of the transition \nsystem are ei\u00adtifiers to closed behaviors and the special symbol J. ther closed behaviors, i.e. behaviors \nwithout free be-Furthermore, a is the action that takes place and ps is haviour variables, or the special \nterminating configura\u00ada list of the processes that take part in the action. As tion /. The transition \nrelation takes the form in the semantics of CML, ps has one or two elements depending on the action. \nThe actions are given by b+Pb a ::= e It CHAN r I FORK b I (r!t, T?t) where b is either a closed behaviour \nor /, and where p is an atomic behaviour as given by The transition relation is specified in Table 9. \nThe first four rules embed sequential evolution in the concurrent REC ~. b=+ b[/3w REC ~. b] bl=9 b; \nbl; b2+ b~; b2 bl =# b~ b2=9 b~ bl+bz=&#38; b~ bl+b2=P b; Table 8: Sequential Evolution evolution: \nthe first rule captures the termination of a behaviour, the second rule captures when the behaviour has \na trivial atomic behaviour, the third rule when a channel is created and the fourth rule when a process \nis created. In all cases the action as well as the processes involved are recorded. The final rule captures \nthe com\u00admunication between processes. Here the matching sim\u00adply amounts to ensuring that the channels \nof the two processes are in the same region and that they agree on the type of the value being communicated. \n Subject Reduction Property We shall prove that the typing system of Section 2 has the following subject \nreduction properties: o Types are preserved during computation. o Behaviors evolve during computation. \n  The formalisation and proof of this result is in three stages: First, we prove a subject reduction \nproperty for the sequential evaluation of expressions. Then we prove a correctness property for matching \nand finally we prove the subject reduction property for concurrent evaluation. The proof of the latter \ninvolves showing that the ordering ~ on behaviors as defined in Table 3 is sound with respect to a simulation \nordering obtained from the semantics of behaviors. For sequential correctness it is natural to restrict \nat\u00adtention to closed expressions because the definition of an evaluation context is such that we never \npass inside the scope of any defining occurrence of a program vari\u00adable. However, we have to allow expressions \nto include channel identifiers that have been allocated during the computation. To formalise this we \nshall write cenv for a mapping from channel identifiers to types (so cenv ci will always have the form \nt than r). We shall say that e is closed if cenv E e : t&#38; b for some cenv, tand b. To express the \ncorrectness result we shall also need typing rules for weakly evaluated expressions. They have the form \ntenvkc:td t &#38;e tenvkw~: t&#38;c tenv \\ (cWI) :tt &#38; b ife~b tenv i--(c W1 . . . wn_l) :td tf&#38; \netenvkwn: t&#38;e tenvk(cwl . ..wn}. t &#38;b ife~b Here we rely on the fact that whenever tenv E w \n: t &#38; b then also tenv 1-w : t&#38; e.Also we have made it explicit that the latent behaviour of \nthe constants of Table 4 has the form e + b and that we always can ignore the b component. Then we have \nProposition 3 Assume e + e and cenvke: t&#38;b. Then cenvke : t&#38;b. 1 The proof of Proposition 3 \nis by induction on the infer\u00adence e4 e . The matching of two weakly evaluated expressions gives rise \nto a new pair of expressions. To formalise this we shall define cenv ci! = r!tand cenv ci? = r?t whenever \ncenv ci = tthan r. Then we have Proposition 4 Assume (WI, W2) ~~~z) (el, e2) and cenv l--WI : tlcombl \n&#38; e cenv 1-W2 :t2 com b2 &#38; c  Then there exists b; and bj such that cenv 1-el : tl&#38; b; cenv \n1-e2 :tz &#38; b~ and (cenv 4); bj G bl and (cenv dz); b~ P k. 0 The proof is by induction on the inference \nfor matching. In order to formulate and prove the concurrent cor\u00adrectness result we need to relate the \nordering L on be\u00adhaviors to the semantics of behaviors. Basically this amounts to the definition of a \nsimulation relation on behaviors and a soundness proof for the laws of Table 3. First define to mean \nthat there exists behaviors bl, ~~., b~ such that Recall that b ranges over closed behaviors as well \nas /. Thus the atomic behaviour p may be prefixed by any number of trivial atomic behaviors. We shall \nsay that S is a simulation on (closed) be\u00adhaviors if o /S bifandonlyif b=/ if bl +Pl bl and bl S b2 then \nthere exists b2 and p2 such that b2 =9z b2,PI S p2 and bl S b2. We define z as the largest simulation. \nThe simu\u00adlation ~ is extended to open behaviors as follows: tJl Z b2 holds if for all ground substitutions \n0 we have 0 bl 20 bz. This definition of simulation is inspired by the notions of bisimilarity as developed \nfor the process algebras CCS [4] and CHOCS [11]. Then we have The concurrent subject reduction property \nexpresses that each step of the concurrent evaluation of the ex\u00adpression can be mimicked by a number \nof steps in the concurrent evolution of its behaviour. Let us first relate the conjigumtions CI &#38; \nPP of the concurrent evaluation of expressions to the configura\u00adtions PB of the concurrent evolution \nof behaviors. We shall say that CI &#38; PP is cenv-related to PB if Dom(PP) = Dom(PB) and Dom(cenv) \n= CI. This ensures that we are dealing with the same processes and channel identifiers. We shall also \nneed to relate the events ev of the con\u00adcurrent evaluation of expressions to the actions a of the concurrent \nevolution of behaviors. So assume that we have two configurations CI &#38; PP and PB that are cenv-related \nas explained above. Clearly we would expect FORK pi to correspond to FORK (PB pi) and CHAN ci to correspond \nto t CHAN r when cenv ci = tthan r; this is formalised by an auxiliary function de\u00adnoted (cenv, PB). \nThe final preparation is to introduce a notation for a sequence of steps in the concurrent evolution \nof be haviours. For this we write to mean that there exists configurations PB1, . -., PB~ such that where \npil, ..., pin are process identifiers from the list ps. Thus the processes of ps are allowed to perform \nsome trivial actions before they engage in the (joint) action a. We then have Theorem 6 Assume CI &#38;PP \n+; CI &#38;PP and let cenv and PB be such that CI &#38; PP is cenv\u00adrelated to PB, and for all pi c Dom(PP) \ncenv 1-PP pi : tpi&#38; PB pi for some tp~. Then there exists cenv and PB such that where a = (cenv \n, PB )ev and furthermore CI &#38; PP is cewv -related to PB and for all pi G Dom(PP ) Proposition 5 If \nbl ~ b2 then bl ~ b2. 0 cenv 1-PPf pi : t~i &#38; bPi for some t~ and b~i with bPi L PB pi. (It is possible \nto take t&#38;= tpiwhenever tP; is defined.) 0 The proof of Theorem 6 is by induction on the rules for \nconcurrent evaluation. The soundness of the ordering defined in Table 3 is important for the proof of \nTheorem 6. However, it may be interesting to note that the laws PI, P2, Cl, C2, S1, El, E2 and J1 suffice. \n 5 Analysis of Finite Communi\u00adcation Topology We shall say that e has a finite communication topology \nif there exists n and m such that whenever O&#38;~io~e]+~;...+~~C1&#38;PP then #CHAN{evl, . . . . evk} \n< n and #FORK{evl, . . . ,evk} < m where #CHAN(X) is the cardinality of {CHAN ci I CHAN ci c X} and #FORK(X) \nis the cardinality of {FORK pi I FORK pi c X}. Thus the execution of e will cause at most n channels \nand m processes to be created. Similarly, we say that b has a finite communication topology if there \nexists n and m such that whenever b~O I-+ b] =+;:l . . . +;$, PB then #CHAN{al,. . . . ak} < n and #FORK{ \naI,.. ., a~} < m where #CHAN(X) is the cardinality of {t GHAN T I t CHAN ~ E X} and #FORK(X) is the cardinality \nof {FORK bIFORK bGX}. Example 7 Consider the following behaviors (i) REC ~. @ CHAN ~ + (~!t; @) (ii) \nRECD. (r?t+ (tCHAN r; B))  (iii) REC P. (t CHAN ~ + (T!t; ~; fl)) (iV) REC ~. (e+ (~!t; ~;/?)) (V) REC \n,8. (tCHAN r + FORK(r?t; ~)) l-t: (o,o)&#38;O, O l-?-!t:(o, o)&#38;O, O  l-?-?t:(o,o)&#38;O, O }tCHAN~:(l, \n())&#38;@, O Fb:(n, m)&#38;O, O FFORKb:(n, m+l)&#38;O, O t-bl : (nl, ml) &#38; V1, D1 !--bz : (w,mz) \n&#38; V2, D2 l-bl; b2:(n1+ n2, m1+m2)&#38;V1UV2, D if VI # 0 then (n2, m2) = (0,0) if V2 # 0 then (nl, \nml) = (0,0) if Vl=0VV2=0then D=D1 UD2 else D= VIUVz 1-bl : (nl, ml) &#38; V1,D1 l--bz : (nz,mz)&#38;Vz,llz \n1-bl + b2 : (max{nl, n2} ,max{ml, mz}) &#38; V, D if V= V1UV2and D=D1U D2 l-b:(n, m)&#38;V, D !-REC p, \nb:(n, m) &#38;v\\{P}>~\\ {P} if ~ GD then (n, m) = (0,0) ~P:(o, o)&#38;{P}, O Table 10: Test for Finite \nCommunication Topology Here (i) has a finite topology: at mcst one channel is created. Example (ii) does \nnot have a finite topology since any number of channels maybe crested. Alt bough (iii) is only a slight \nvariation of (i) it does not have a finite topology: any number of channels maybe created. In (iv) we \ndo have a finite topology and in (v) we do not since any number of proceeses may be created. To test \nwhether a behaviour b has a finite communicat\u00adion topology we shall introduce a predicate t-b:(n, m)&#38;~D \nwhich intuitively expresses that b has a finite communic\u00adation topology where at most n channels and \nm pro\u00adcesses are created. The predicate is defined in Table 10. The set V is the set of free behaviour \nvariables of b and D is a subset of V consisting of those behaviour variables that are on a path in b \nwith more than one behaviour variable. These so-called dangerous variubles need special attention when \nhandling recursion as ex\u00adplained below. Let us first explain some of the simple cases. The clauses for \ne, r!t, r?t and tCHAN r should be straight\u00adforward. For FORK b we have to ensure that b contains no he \nbehaviour variables otherwise an encapsula\u00adtion into a recursive construct (s.s in Example 7 (v)) will \ncause an unbounded number of processes to be created. For the choic~construct we simply take the maximum \nof the numbers of channels and processes created by each of the components. In order for a behaviour \nof the form REC /3. b to have a finite communication topology it must create the same number of channels \nand processes as its onelevel un\u00adfolding b[/3 + REG ~. b]. In the analysis we cannot perform this unfolding \nbecause we want the analysis to be structuml. So instead we have to consider pr~ cesses with free behaviour \nvariables and here we shall boldly claim that P creates no channels and no pro\u00adcesses. Clearly this would \nbe correct if we require all recursive behaviors not to create any channels and pr~ cesees but this is \ntoo restrictive. We shall therefore in\u00adtroduce the set D of dangerous variables to keep track of when \nit is really necessary that the behaviour of a recursive construct creates no channels and processes. \nSuch situations arise in connection with the sequenc\u00ading bl; b2. If bl contains a free behaviour variable \nthen the channels and processes created by /q can be iter\u00adated any number of times by unfolding the encapsulat\u00ading \nrecursive binding of the behaviour variable. So we must ensure that /q does not create any channels and \nprocesses. This is complicated by the possibility that bz could contain free behaviour variables which \n(maybe wrongly) have been assumed to create no channels and processes. We must therefore ensure that \nthese free be\u00adhaviour variables never can generate any channels and processes; we do this by including \nthem in the set of dangerous behaviour variables. We impose similar re\u00adstrictions in the dual situation. \nIn this way the be\u00adhaviour t CHAN r;/? of (ii) in Example 7 will classify ~ as a dangerous variable because \nt CHAN r creates a channel, whereas r!t; /3 of (i) will not classify /3 as dan\u00adgerous. The behaviour \nr!t;/3;@of (iii) and (iv) causes no problems but /3 is recorded as a dangerous variable and when anal \nysing the encapsulating REC construct, (iii) will be rejected because its body may create a channel whereas \n(iv) will be accepted. The following result expresses the soundness of the anal\u00adysis: Theorem 8 If 1-b \n: (n, m) &#38; 0,0 and To prove this result we shall first show that the property expressed by the predicate \nof Table 10 is preserved by sequential evolution of behaviors: then #CHAN{al, . . . . ak} < n and #FORK{ \nal, . . . . CW} < m. 0 Proposition 9 Asmme t-b : (n, m) &#38; 0,0. If then there exists ~, ~, n and \nm such that 1-p : (w, m) &#38; 0,0 and 1-b : (n , m ) &#38; 0,0 and fimther\u00admore nq+m <m. 1 Here we \nhave extended the predicate of Table 10 to configurations by taking FJ:(o, o)&#38;O, O The proof of \nProposition 9 is by induction on the in\u00adference of b + b. To handle recursion we rely on the following \nlemma: Lemma 10 Assume 1-b : (n, m) &#38; V,D and t-~ : (no, mo) &#38; 0,0 where ~ has no free behaviour \nvariables and D # 0 implies (no, mo) = (O, O). Then i f/3c V\\ Dthen t-b[~ w bo] : (max{n, ~}, max{m, \nme}) &#38; V \\ {~},11, i f~~i3t,hen l-b~i+bo]:(n, m) &#38;V\\{~}, D where D ~ D \\ {~}, and i f~@Vthen \n+b[/3*bo]:(n, m) &#38;V, D. 0 To prove the concurrent soundness of the analysis we define 1-.PB : (n, \nm) to mean that !-bl:(nl, ml)&#38; O,O,..., !-bj : (nj, mj)&#38;O, O  andn=nl +... +njandm =ml+. . .+mj \nwhere PB = ~il +bl, . . ..pij ++ bj]. We now have Proposition 11 If 1-PB : (n, m) and PB ~ =&#38;k PB \n p91 ... then there exists n and m such that 1-PB : (n , m ) and n + #CHAN{al, ..., a~} < n and m + #FORK{ \nal, ....ak} < m. 0 Theorem 8 then directly follows from Proposition 11. Combining Theorem 6 and Theorem \n8 we get Corollary 121 fO1-e:t &#38;band kb:(n, m) &#38;O,@ then e has a finite communication topology \nwhere at most n channels and m processes are created. 0 Example 13 Returning to Example 2 recall that \nthe latent behaviour of process is b = FORK (REC F. (~l?~l; /?; P2!GY2; P )) and it is easy to verify \nthat l-b:(o,l)&#38;O, O Together with Corollary 12 this shows that indeed only one process will be created \nwhen the function process is executed (provided that the argument does not create any processes). The \nlatent behaviour of the function pipe is b = REC ~ . (FORK (REC p . (p?a; p!a; ,LY )) + a CHAN ~; FORK \n(REC /3 . (p?a; p; p!a; /9 )); P ) and here we cannot deduce that F b : (n, m) &#38; 0,@ because /3 is \nincluded in the set of dangerous behaviour variables for the body of the FLEc-construct. However, if \nwe specialise the program to lists of fixed length then we do get a finite communication topology. 0 \n Conclusion We have presented a process algebra for a polymorphic subset of CML and have proved its \nsafety with respect to the semantics of CML. Using the process algebra we then developed a static analysis \nof the communica\u00adtion behaviour of a CML program and proved its cor\u00adrectness. The applicability of the \nanalysis is obvious: knowing that only a finite number of channels and pro\u00adcesses are to be created may \nfacilitate that the comput\u00ading resources may be used much more efficiently. Our approach is flexible: \nif, for example, only the number of processes are of interest then the analysis maybe mod\u00ad ified so as \nto allow an arbitrary number of channels. However, more research is needed on how to combine the analysis \nwith a transformation that automatically rewrites a CML program into a form where the pro\u00ad cesses can \nbe preloaded on a given architecture. There is plenty of scope for variations on the analy\u00adsis. Theorem \n8 expresses the soundness of the analy\u00adsis: if the analysis succeeds then the behaviour has a finite \ncommunication topology. One may ask whether the analysis is complete: if the behaviour has a finite communication \ntopology will the analysis say so? This is not the case as the following example illustrates: (REc .i3. \n~); (REC P. (t cHAN 7-; fl)) Here the second component causes the analysis to re ject the behaviour. \nNonetheless the behaviour has a finite communication topology: the looping of the first component prevents \nany channels from being created. Another example is FoRK(7-?t); r?t; (REC P. (t cHAN r; p)) Again the \nanalysis will reject the behaviour because of its last component. However, after forking the first pro\u00adcess \nthe behaviour will dead-lock and thereby prevent any channels from being generated. To get a complete \nanalysis (with respect to the evolution of behaviors) one may extend the analysis with some form of terminw \ntion/dead-lock analysis. Alternatively, one may study completeness only for the class of behaviors that \nat any stage of their evolution has the possibility of terminat\u00ading. We conjecture that the analysis \nis indeed complete with respect to this class. Obviously, we cannot hope for a complete analysis with \nrespect to the semantics of CML programs. The analysis does not take into account that some pr~ cesses \nmay terminate before others are started. Con\u00ad sider the following example REC ~. (6+ FORK(r!t; ~)) This \nbehaviour will be rejected by the analysis because any number of processes may be forked. However, at \nany time essentially all but one process will have ter\u00adminated so one might regard the behaviour as having \na finite communication topology. Acknowledgements We would like to thank Uffe Engberg for many fruit\u00adful \ndiscussions. Also Torben Amtoft, Kim Guldstrand Larsen, Bent Thomsen and Mads Tofte provided use\u00adful \ncomments. The research has been supported by the DART project funded by The Danish Research Coun\u00adcils. \n References [1] D. Berry, R. Milner, D.N. Turner: A seman\u00adtics for ML concurrency primitives. Proceedings \nof POPL 92, ACM Press, 1992. [2] A. Giacalone, P. Mishra, S. Prasad: Operational and Algebraic Semantics \nfor Facile: A Symmet\u00adric Integration of Concurrent and Functional Pro\u00adgramming. Proceedings of ICALP \n90, SLNCS 443, 1990. [3] J.M. Lucassen, D.K. Gifford: Polymorphic Effect Systems. Proceedings of POPL \n88, ACM Press, 1988. [4] R. Milner: Communication and Concurrency. Prentice Hall, 1989. [5] R. Milner, \nM. Tofte, R. Harper: The Definition of Standani ML. MIT Press, 1990. [6] F. Nielson: The Typed Lambda-Calculus \nwith First-Class Processes. Proceedings of PARLE 89, SLNCS 366, 1989. [7] F. Nielson, H.R. Nielson: From \nCML to Process Al\u00adgebras. Proceedings of CONCUR 93, SLNCS 715, 1993. [8] J.H. Reppy: CML: A Higher-order \nConcurrent Language. Proceedings of the ACM SIGPLAN 91 Conference on Programming Language Design and \nImplementation, ACM Press, 1991. [9] J.H. Reppy: Higher-Order Concurrency. Ph. D.-Thesis, Report 92-1285, \nDepartment of Computer Science, Cornell University, 1992. [10] J.-P. Talpin, P. Jouvelot: The Type and \nEffect Dis\u00adcipline. Proceedings of LICS 92, 1992. [11] B. Thomsen: A Calculus of Higher Order Commu\u00adnicating \nSystems. Proceedings of POPL 89, ACM Press, 1989. [12] B. Thomsen: Polymorphic sorts and types for concurrent \nfunctional programs. Technical report ECRC-931O, 1993. \n\t\t\t", "proc_id": "174675", "abstract": "<p>Concurrent ML (CML) is an extension of the functional language Standard ML(SML) with primitives for the dynamic creation of processes and channels and for the communication of values over channels. Because of the powerful abstraction mechanisms the communication topology of a given program may be very complex and therefore an efficient implementation may be facilitated by knowledge of the topology.</p><p>This paper presents an analysis for determining when a bounded number of processes and channels will be generated. The analysis proceeds in two stages. First we extend a polymorphic type system for SML to deduce not only the type of CML programs but also their communication behaviour expressed as terms in a new process algebra. Next we develop an analysis that given the communication behaviour predicts the number of processes and channels required during the execution of the CML program. The correctness of the analysis is proved using a subject reduction property for the type system.</p>", "authors": [{"name": "Hanne Riis Nielson", "author_profile_id": "81100316576", "affiliation": "Computer Science Department, Aarhus University, Denmark", "person_id": "PP43118881", "email_address": "", "orcid_id": ""}, {"name": "Flemming Nielson", "author_profile_id": "81100316685", "affiliation": "", "person_id": "P84491", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/174675.174538", "year": "1994", "article_id": "174538", "conference": "POPL", "title": "Higher-order concurrent programs with finite communication topology (extended abstract)", "url": "http://dl.acm.org/citation.cfm?id=174538"}