{"article_publication_date": "02-01-1994", "fulltext": "\n Manifest types, modules, Xavier Stanford Abstract This paper presents a variant of the SML module system \nthat introduces a strict distinction between abstract types and manifest types (types whose definitions \nare part of the module specification), while retaining most of the expressive power of the SML module \nsystem. The resulting module system provides much better support for separate compila\u00ad tion. 1 Introduction \n1.1 IVIodules and separate compilation ikfodular~zation is the process of decomposing a program in small \nunits (modules) that can be understood in isola\u00adtion by the programmers, and making the relations between \nthese units explicit to the programmers. Separate corr@a\u00adtzon is the process of decomposing a program \nin small units (compdation units) that can be typechecked and compiled separately by the compiler, and \nmaking the relations be\u00adtween these units explicit to the compiler and linker. Both processes are required \nfor realistic programming: modular\u00adization makes large programs understandable by program\u00admers; separate \ncompilation makes large programs tractable by compilers. Several languages rely on a common mechanism \nto pro\u00advide modules and separate compilation. A typical example is Modula-2 [27], where modules are identified \nwith compila\u00adtion units composed of an implementation file (source code) and an interface file (specification). \nHowever, this identifica\u00adtion is limiting. Since compilation units are usually directly mapped onto file \nsystem objects, separate compilation tends to keep the structure of compilation units simple, with the \ndependencies hard-wired inside the units. Modern mod\u00adule systems go much farther in their attempts to \naccurately express the program structure. A well-known example is the module system of SML [14], which \nis actually a small typed language of its own, with modules (also called structures) as the base data \nstructure, module specifications (signatures) as types, functions from modules to modules (functors) \nto *Dept. of Computer Science, Stanford University, Stanford CA 94305-2140. E-mail: xavier@cs. stanford \n.edu. Supported by an IN-RIA post-doctoral grant. Permission to copy without fee all or part of this \nmaterial is granted provided that the copies are not made or distributed for direct commercial advantege, \nthe ACM copyright notice and the title of the publication and its data appear. m-d notice is given that \ncopying ia by perm esion of the Association for Computing Machinery. To copy otherwiaa, or to republish, \nrequires a fea and/or specific permission. POPL 94-1/94, Portland Oregon, USA @ 1994 ACM o-89791 -636+ \n941W1 ..$3.50  and separate compilation Leroy * University represent parameterized modules, and function \napplications to connect modules all features that cannot be accounted for in the modules as compilation \nunits approach. As a consequence of this tension, SML makes no provision for separate compilation. SML \nis defined as an interactive language [17], implying that users are expected to build their programs \nlinearly in strict bottom-up order. This re\u00adquirement can be alleviated by systematic use of functors, \nat the cost of extra declarations (sharing constraints) and late detection of inter-compilation unit \ntype clashes. Re\u00adcently, Shao and Appel [24] have proposed a more free-form separate compilation mechanism \nfor SML, which infers the required constraints, but delays all type checks between com\u00adpilation units \nto the linking phase, which is much too late. Late detection of type errors increases the likeliness \nof pro\u00adgrammers writing large quantities of inconsistent code, only to discover later that major changes \nare required to bring the parts together. The work presented in this paper grew out of an attempt to \napply the Modula-2 separate compilation techniques (which ensure early detection of inter-compilation \nunit type clashes) to the SML module system. The starting idea is to abandon the identification of modules \nand compilation units, and consider compilation units as an additional layer on top of modules: just \nas Modula-2 compilation units are collections of language objects (types, variables, functions), SML \ncompilation units should be collections of module objects (signatures, structures, functors). These collections \nof modules can, then, be defined in implementation files and specified (by their signatures) in interface \nfiles, and their dependencies can be expressed by Modula-2-style import declarations. 1.2 The problem \nwith SML modules The simple approach outlined above turns out to fail, not be\u00adcause it is inherently \nflawed, but because it exposes a weak\u00adness in the SML module system: a module signature does not express \nall the typing properties that the remainder of the program can assume about the corresponding structure. \nIn other terms, SML signatures are not complete specifications with respect to typing. This is because \ntype specifications in signatures are transparent : they do not hide the actual type provided by the \nstructure. For inst ante, assume a struc\u00adture S has a signature z specifying a type component t. Even \nthough the signature does not say anything about the imple\u00admentation of t, another structure S can rely \non S. t being implemented as some particular type, say, int. If S and S are not defined in the same compilation \nunit, the implemen\u00adtation defining S cannot therefore be typechecked until the implementation defining \nS has been written: the correspond\u00ad ing interface, specifying only structure S : Z, does not suf\u00adfice \nto determine whether S is correct in assuming S. t to be int. Hence, typechecking and compilation must \nbe done in bottom-up order, just as in a toplevel-based approach. In contrast, true separate compilation, \nas in Modula-2, al\u00adlows typechecking and compilation of a program fragment at any time, based only on \nthe interfaces of the fragments it imports. The fact that type specifications in SML signatures are transparent \nis no accident: it accounts for a large part of the expressive power of SML modules. Treating type specifica\u00adtions \nas opaque, that is, making all exported types abstract, would fix the problem with separate compilation \nbut drasti\u00adcally reduce the expressiveness of the module system [15].  1.3 This work This paper proposes \na way out of this dilemma: make type specifications opaque (so that the users of a structure can only \nassume what is declared in its signature), but enrich signatures with manzfest type spectficatzons. A \nmanifest type specification of the form type t = -r not only declares a type identifier t, but also publicizes \nthat it is implemented as the type expression ~. This way, signatures become complete module specifications \nwith respect to typing, making sepa\u00adrate compilation feasible while retaining the expressiveness of the \nSML module system. (Harper and Lillibridge [10] have investigated similar ideas independently.) The two \ncomponents of this approach manifest types and opaque signatures have already been proposed as ex\u00adtensions \nto the SML module system: type abbreviation in signatures and Mac Queen s abstraction construct, respec\u00adtively. \nThe novelty of this paper is to take these two con\u00adcepts as the basic mechanisms of a module system, \nreplacing SML S transparent type specifications instead of supplement\u00ading them. The bulk of this paper \nis devoted to the study of the re\u00adsulting variant of the SML module system, with opaque type specifications \nand manifest types in signatures. This mod\u00adule system supports the SML modular programming style in a \nsatisfactory way. It provides a strong type abstraction mechanism, which guarantees interesting representation \nin\u00addependence properties [18] and easily accounts for genera\u00adtive datatypes. More surprisingly, the manifest \ntype mecha\u00adnism subsumes large parts of the SML sharing constraint machinery, an essential part of the \nSML module system: manifest types in functor argument position express sharing constraints between types, \nand the simple typing rules for manifest types suffice to check these constraints. The main missing SML \nfeature is sharing constraints between struc\u00adtures (though identity checks on structures can be encoded \nusing abstract types); we argue that this is a small price to pay for the overall simplifications resulting \nfrom this restric\u00adtion. On the technical side, the main originality of this paper is the use of what \nis essentially weak sums [19, 7] albeit with an unusual elimination construct: the dot notation [4, 5] \ninstead of the strong sums that have been used so far to give type-theoretic accounts of SML modules \n[15, 12, 13]. Unlike strong sums, weak sums provide direct support for type abstraction and make the \nphase distinction [13] obvi\u00adous. The well-known inadequacies of weak sums for modular programming [15] \nare here offset by the extra expressiveness brought by manifest types. The present paper also puts forward \na new way to ac\u00adcount for type sharing, distinct from the heavy graph-based formalism of the Dejinitzon \n[11, 17, 25] and from Aponte s record-based module algebra [1], Previous approaches to sharing focus \non structure generativity and sharing between structures; as a consequence, they require stamps over \nstruc\u00adtures and consistency conditions between structures having the same stamp. In contrast, sharing \nrestricted to types, as in this paper, can be expressed by a standard term algebra without extra consistency \nchecks. More generally, the Def\u00adtrutton uses semantic objects (richer than signature expres\u00adsions) in \nthe static semantics, while our type system uses only syntactic objects (signature and module type expres\u00adsions), \nin keeping with the typed A-calculus tradition.  1.4 Outline The remainder of this paper is organized \nas follows. Sec\u00adtion 2 introduces manifest types and illustrates how they propagate type equalities and \nexpress sharing constraints. Section 3 formalizes a small SML-like module calculus with manifest types. \nSection 4 shows the expressiveness of this calculus by encoding a first-order calculus with strong sums \nin it. Section 5 mentions some simple extensions of this work, followed by concluding remarks in section \n6. 2 Informal development 2.1 Transparency in SML The SML module language is often presented as a small \ntyped functional language, with structures as base values and data structures, funct ors as functions, \nand signatures as types. However, this module language departs significantly from most typed languages \non one point: to typecheck a module expression cent aining a free structure identifier S, it does not \nsuffice to know the signature (the type) of S; the ac\u00adtual structure (the value) bound to S is also needed \nin some cases. Consider the following code fragment: ... S.less 1 2 ... where S is assumed to have the \nfollowing signature: s : slg type t; val less: t -> t -> bool end The code fragment above is well-typed \nif S is bound to a structure that implements t as the type int of integers. But it is ill-typed if S. \nt has been implemented as another type, Both implementations of S satisfy the signature given above, \nthough. As shown by this example, signatures are not complete type specifications for structures: some \ninformation required to typecheck code that uses the structure is missing from the signature, and must \nbe extracted from the structure itself. This is because type specifications in SML signatures are transparent: \neven if the signature only says type t without any indication on how t is implemented, the actual imple\u00adment \nat ion of t shows through the signature. 110 This makes sense in the context of a toplevel-based sys\u00adtem: \nbecause of static scoping, the user must provide a definition for S before being able to enter code that \nmen\u00adtions S; hence the typechecker has access to the actual struc\u00adture bound to S when typing expressions \nreferring to S. This is no longer true in the context of separate compilation: S can be defined in a \ncompilation unit A and used in another unit B, and A might not yet be written at the time we wish to \ntypecheck and compile B. Hence, the fact that type spec\u00adifications are transparent precludes Modula-2-style \nseparate compilation, where program fragments are typed and com\u00adpiled independently, relying only on \ntheir export interfaces. In spite of these difficulties with separate compilation, transparent type specifications \nare an important feature of the SML module system, one that accounts for a large part of its expressive \npower. In the traditional view of structures as types equipped with operations over them [14], transpar\u00adent \ntype specifications makes it possible to add operations to a preexisting type, and apply these operations \nto preexisting values. A stricter interpretation of type specifications would generate a new type, incompatible \nwith the original type, therefore compromising the usefulness of the additional op\u00aderations. Consider \nfor instance the following signature for a type equipped with a total ordering function: datatype order \n= Less I Equal I Greater; signature Order = sig type t val cmp: t -> t -> order end We can define an \nOrder structure for a base type such as int: structure lntOrder: Order = struct type t =int fun cmpil \ni2 = if il = 12 then Equal else if i.1 < 12 then Less else Greater end Since the type specification \nin Order is transparent, intOrder.t is compatible with int, hence intOrder.cmp can be applied to any \ninteger. If type specifications were opaque, intOrder.t would be an abstract type, incompatible with \nany other type, and intOrder.cmp could not be applied to any value, making the structure useless. Transparency \nalso works across functors. Consider the following functor that takes an ordered type and produces an \nordering over lists of elements of that type: functor listOrder(base: Order): Order = struct type t = \nbase.t list fun cmp [] [] = Equal I cmp [1 _ = Less I cmp _ [1 = Greater I cmp (hl::tl) (h2::t2) = case \nbase.cmp hi h2 of Equal => cmp tl t2 ]C=>c end The application of listOrder to intOrder produces an Order \nstructure whose typet is compatible with int list, hence whose cmp function can be applied to preexisting \nlists of integers. Again, functors such as listOrder would be useless without transparency. 2.2 Manifest \ntypes So far, we have seen two interpretations of type declarations in signatures: the opaque interpretation, \nwhich supports separate compilation but is too restrictive, and the trans\u00adparent interpretation, which \nis expressive enough but causes dHFiculties with separate compilation. We now propose a third approach, \nwhich combines expressiveness and separate compilation. We consider type declarations as opaque, but \nallow two kinds of type declarations: abstract type declara\u00adtions, of the form type t, which give no \nclue on how t is implemented and therefore makes t incompatible with any other type (opaque interpretation); \nand mantfest type dec\u00adlarations, of the form type t = -r, which require that t be implemented as the \ntype expression T, and therefore makes t compatible with ~.1 This way, signatures become expres\u00adsive \nenough to capture the required type equivalences, and there is no need to refer to the structures to \nestablish these equivalences. Consider again the intOrder example above. The structure structure intOrder \n= struct type t =int fun cmpii i2 = if il = i2 then Equal else if il < i2 then Less else Greater end \n now has signature intOrder: sig type t =int val crop: t -> t -> order end From this signature, we can \ndeduce that intOrder.t and int are compatible; hence, the application ofintOrder.cmp to integer values \nis well-typed. Notice that we have estab-Iished this by looking at the signature only, but not at the \nactual structure bound to i.ntOrder. We can show that intOrder.cmp 1 2 is well-typed even ifintOrder \nis defined in another compilation unit and all we know about it is its signature, as provided by the \ninterface of the unit. Manifest types also work across functors. Consider again the listOrder functor \nabove. With manifest types, we can define it as: functor listOrder(base: Order): sig type t = base.t \nlist val crop: t -> t -> order l~e do not ~on~ider generative datatype declarations in sig\u00adnatures. \nsince thev can be viewed as declarations of abstract types plus injection and projection operations. \nFor instance, the type specification sig type t = A I B of mt end is equiva\u00adlent to slg type t; val inj_A: \nt; val inj-B: int->t, val elim-t: t -> (unit-> a) -> (int-> a) -> a end. end = struct type t = base.t \nlist funcmpll 12= . . . end The result signature for listOrder rnakesit apparent that the component t \nin the result structure is compatible with base. t list, where base isthe argument structure. This is \na dependent function type: the type of the result depends on the value of the argument. Then, consider \nthe application structure intListOrder = listOrder(intOrder) This application is well-typed, even though \nthe signature of intOrder is different from Order, the argument signatureof the functor: Order specifies \ntype t (an abstract type) but the signature of intOrder says type t = int (a manifest type). However, \na manifest type is a special case of an ab\u00ad stract type: we can always make a manifest type abstract \nby forgetting the additional information. We shall formalize this idea as a subtyping relation between \nsignatures. This relation will show that the signature of intOrder is a sub\u00ad type of Order, hence the \napplication listOrder(intOrder) is well-typed. According to the standard elimination rule for dependent \nfunction types (substitute the actual parameter for the formal parameter in the result type), the signature \nof intListOrder is: intListOrder: sig type t = intOrder.t list val crop: t -> t -> order end From this \nsignature, it follows that intListOrder.t is equivalent to intOrder.t list, and we already know that \nintOrder.t is equivalent to int. Since type equivalence is transitive and a congruence, it follows that \nintListOrder.t is equivalent to int list, which is the result we need to be able to apply intListOrder.cmp \nto integer lists. Again, we have reached the same conclusions as with the SML module system, but the \nreasoning is completely different: we have reasoned only at the level of signatures, while in SML we \nhad to look inside structures.  2.3 Avoiding signature duplication An apparent weakness oftheapproach \npresentedabove isthe duplication ofsignatures: intOrder, intListOrder and the result of the list Order \nfunctor all have different signatures, while in SML they share the same signature Order. Worse, the result \nsignature for the listOrder functor cannot be declared andnamed before, sinceit depends ontheargument \nof the functor. To factor out the common parts between these signatures (the val declarations, usually \n),onesolution is to introduce signatures parameterized by type expressions: signature ManifestOrder(type \n~) = Sig type t = r; val crop: t -> t -> order end so that the signature of intOrder is ManifestOrder(int), \nand listOrder can be declared as: functor listOrder(base: Order): ManifestOrder(base.t) = . . . Theremaining \nproblem is that the generic Order signature, with t left abstract, cannot be obtained by application \nof ManifestOrder and must therefore be declared separately. Another approach is to introduce the notation \nOrder with type t =T as syntactic sugar for the signature Order where the specification of t is replaced \nby type t =T, that is: sig type t = T; val crop: t -> t -> order end This style of after the fact parameterization, \nreminiscent of SML S syntax for sharing constraints, makes it possible to write the signature only once \nand use it in both abstract and manifest contexts. (Tofte [26] has proposed a similar notation toexpress \ntype abbreviations in signatures, though for different purposes.) The with construct is just a notational \nconvenience: it can always be expanded before typing as described above, as long as signatures can be \nnamed but not abstracted over nor stored in structures. A typechecker would certainly avoid this expansion \nfor the sake of efficiency, but the point is that the with construct does not complicate the formalism. \nThis is no longer true if signatures can appear as struc\u00adture components or as functor parameters: if \nS is a func\u00adtorparameter, S with type t= 7cannot be expanded be\u00adfore typing. Inthiscontext, theunrestricted \nwith construct seems to require a type system similar to those for polymor\u00adphic extensible records [6]. \nA more reasonable alternative is to restrict with to situations where the left-hand side can be statically \nreduced to a sig . . . end expression.  2.4 Sharing constraints for free! So far, we have seen that \nmanifest types in toplevel position or functor result position can replace SML s transparent type specifications. \nWe shall now see that manifest types in func\u00ad tor argument position can replace SML S sharing constraints, \nTheidea is that afunctorof the form functor F (structure S1: sig type t; . . . end structure S2: sig \ntype t = S1.t; . . . end) . . . can only be applied to structures S1 and S2 for which we can prove that \nS1.t isthe same type as S2.t just like the corresponding SML functor with a sharing constraint: functor \nF (structure S1: sig type t; . . . end structure S2: sig type t; . . . end sharing type S1.t = S2.t) \n. . . Sharing constraints are an essential feature of the SML mod\u00adule system: they guarantee that a functor \ncombining oper\u00adations from several structures will only be applied to con\u00adsistent sets of structures \ntypically, structures derived from one common structure by addition of operations. This pro\u00adgramming \nsituation, known as the diamondimport prob\u00adlem [15], arises often in practice. The following diamond \nimport example shows that manifest types suffice to ex\u00adpress and check the required sharing properties. \nWe start by a structure implementing some abstract data type, say, integer lists: signature Intlist = \n sig type t val nil: t val cons: int -> t -> t end Then, we define two functors that take an Intlist \nstructure and equip its type t with derived operations. signature Interval = sig type t; val interval: \nint -> int -> t end functor interval(intlist: Intlist): Interval with type t = intlist.t = struct type \nt = intlist.t; fun interval i j = ... end signature Sumlist = sig type t; val sumlist: t -> int end \nfunctor sumlist(intlist: Intlist): Sumlist with type t = intlist.t = struct type t = intlist.t; fun sumlist \n1 = ... end Finally, we define a functor that combines the structures returned by the functors interval \nand sumlist. functor main (structure i: Interval structure s: Sumlist with type t = it) = struct fumfn= \ns.sumlist(i. interval 1 n) end  The application of s.sumlist to the result of i.interval is well-typed \nbecause the signature of s guarantees that the types s.t and i.t are compatible. Now, wecan show that \nthe application main(interval(list) sumlist(list)) is well-typed, given a structure list of type Intlist. \nFirst, the signature of interval(list) is interval(list): Interval with type t = list.t which is included \nin the expected signature for i in main. Then, following the typing rule for functor application, we \nsubstitute the actual parameter interval (list) for the for\u00admal parameter i in the remainder of the functor \narguments: s: Sumlist with type t = interval(list).t We must now prove that the signature of thesecondargu\u00adment: \nsumllst(list): Sumlist with type t = list.t is included in the signature for s. According to the subtyp\u00adingrules \ninsection3, this amounts toshowing that the types list.t and interval(list).t are identical. This immedi. \nately follows from the signature of interval(list); again, only the signature is used. Hence the application \nofmain is well-typed. On the other hand, we will correctly reject ap\u00adplacations ofmain to inconsistent \niands structures, such as main(interval(list) sumlist(list2)) where list2 is another implementation \nof Intlist with a type tincompatible with list .t. Typing proceeds as above, but fails because interval(list).t \nand list2.t are not compatible, hence the signature of sumlist(list2) is not included in the signature \nspecified for s. Notice that we have checked the sharing constraint using only the general rules forsubtyping \nand functor application: no special typing rule is required at least for this simple diamond import problem; \nsection 3.4 shows that an addi\u00adtional type strengthening rule is sometimes necessary to establish the \nexpected sharing properties. 2.5 Expressible sharing constraints The sharing constraints expressible \nwith manifest types are Iessgeneral than those expressible inthe SML module sys\u00adtem. First, manifest \ntypes canonly express constraints of the form type Mentzjier= type expression, which are both asym\u00admetrical \nand local (constraint over atypet must appear in the signature that declares). In contract, SMLallowsshar\u00ading \nconstraints of the form long adentijier = long identifier (e.g. p.t = q.x. t), more symmetrical and non-local. \nThis difference is mostly cosmetic, however: SML-style sharing constraints can be compiled into manifest \ntypes by choosing a representative for each equivalence class of shared types, and pushing the constraints \ndown the constrained signa\u00adtures. A more substantial difference is that manifest types can only express \nthe equality of two types, while SML sharing constraints can also express the equality of two structures. \nManifest types can account for the most common use of shar\u00ading constraints over structures: to specify \nsharing between all type components of two structures in a compact way. A more advanced use of sharing \nconstraints over structures is to ensure that the value components of the structures are also identical, \nwhich is useful to deal with structures that have a local state [11]. This can beencoded to some extent \nin our calculus, by introducing an abstract type to act as a structure stamp. For instance, the SML specification \nfunctor F (structure A: sig val r: int ref . . . end structure B: sig val r: int ref . . . end sharing \nA = B) becomes functor F (structure A: sig type stamp; val r: int ref ... end structure B: sig type \nstamp = A.stemp; val r: int ref ... end)  If the stamp type fields are abstract types in all structures, \nthen the equality of stamp types guarantees the equality of the structures, bygenerativityof abstract \ntypes. This relies on programmer s discipline, however; hence the type system cannot infer that all components \nof these two structures are themselves shared. On the other hand the absence of sharing constraints over \nstructures greatly simplifies the formalism: since structures have no identity , there is no need to \nrep\u00adresent them by unique stamps, as in [17]; simple record-like terms suffice. 2.6 The problem with \ntype abbreviations in signatures Manifest types are similar to an often proposed extension of SML called \ntype abbreviations in signatures . This ex\u00adtension has been excluded from the Standard because it is \nknown to cause serious difficulties [16]: if t ype abbreviations are allowed in signatures, signature \nelaboration becomes un\u00addecidable. It is worth pointing out that this problem is not inherent to type \nabbreviations in signatures, but stems from their interaction with sharing constraints. In the simple \nap\u00adproach suggested in [16], sharing constraints may involve abbreviated type constructors, as in: sig \ntype t =T type s=u sharing type t = s end In this approach, sharing constraints are therefore no longer \nrestricted to equalities between type constructors: they can now express arbitrary equations between \ntype expressions (~ = a in the example above). Since type equations may involve abstract type constructors \n(as in int t = int where t is declared as type a t), second-order unification is re\u00adquired to elaborate \nthese sharing constraints. Our approach avoids this difficulty: since sharing con\u00adstraints are expressed \nin terms of manifest types, all express\u00adible sharing constraints are of the format long identifier = \ntype expression, where long identifier refers to an abstract type. Hence there is no way to equate two \narbitrary type expressions. For instance, the pathological signature given above is not expressible in \nour system: assuming t is chosen as representative for the equivalence class of s and t, then s would \nhave to be declared as equal to o and equal to t also, which is syntactically impossible. 3 A calculus \nof modules We now formalize the ideas presented above in a simple mod\u00adule calculus built on top of a \ntyped base language. 3.1 Syntax In the following grammar, v ranges over value names, tover type names \nand x over module names. Identifiers W,, t, and z, are composed of a name plus a stamp z taken from some \ninfinite set of stamps. Stamps are used to distinguish identifiers having the same name. We cannot allow \narbitrary renamings on identifiers, since the calculus relies on the names to extract structure fields. \nInstead, we will use renamings that only change the stamp parts of identifiers, but preserve the name \nparts of identifiers. This causes no difficulties with structure access, since access is by name, not \nby name plus stamp. Stamps are needed only during typechecking. In particu\u00adlar, they can be omitted from \nprogram texts, since they can be recovered by applying the standard scoping rules (each binding generates \na new stamp, each reference to an identi\u00adfier is given the stamp of its most recent binding). We will \nfollow this convention to make examples more legible. Value expressions: e ::= W; value identifier I \np.v value component of a structure 1 depends on the base language Type expressions: r::=tt type identifier \n\\ p.t type component of a structure depends on the base language I Module expressions: m ::= x, module \nidentifier I p.x module component of a structure I struct s end structure construction I functor(z, : \nM) m functor I ml (mz) functor application Module types: M ::= sig S end signature type I functor(c, \n: Al) A@ dependent function type Structure body: S::= olsc; s Structure components: SC ::= val v; = e \nvalue binding I type t, = 7 type binding I module z, : M module binding Signature body: S::= olsc; s \nSignature components: S= ::= val v%: r value declaration I type t, abstract type declaration Itype t, \n= -r manifest type declaration I module x, : M module declaration Access paths: p ::= z, I p.% Typing \nenvironments: E::= OIE; SC Terms are identified up to alpha-conversion. The bind\u00ading constructs are functor \n(with scope the functor result part) and val, type and module (with scope the remainder of the structure \nor signature). Alpha-conversion can rename the stamp part of identifiers, but is required to preserve \nthe name part. The components of a structure or signature are assumed to have distinct names. The base \nlanguage The base language (value and type expressions) is left mostly unspecified, since the module \ncalculus makes few assump\u00adtions about it and should accommodate a variety of base languages. (We have \nexperimented with two base languages: ML and a more Algol-like language derived from [22].) The base \nlanguage can access values and types bound earlier in the same structure (v, and t,).It can also refer \nto value and type components of other structures through the dot nota-3.2 Typing rules tion p.v and \np.t where p is an access path to a structure with av, or t,component. The module language The module \nlanguage has both structures and functors as first-class module values. We use the word module to re\u00ad \nfer to structures and functors. Functors live at the same level as structure, unlike in Tofte s system \n[25]. The module lan\u00ad guage is actually lambda-calculus with one data structure: generalized products. \nIts dynamic semantics is given by a straightforward translation to untyped lambda-calculus with products, \nby erasing the type components in structures. Structures are sequences of bindings for values, types \nand modules. To keep this paper simple, we do not formalize module type bindings (signature X = s ig \n. . . end). Sim\u00adple uses of module type bindings (as in the examples of sec\u00adtion 2) can be translated \nby duplicating module type ex\u00adpressions. Introducing module type bindings as structure components is \ntempting, as it brings considerable expressive power to the module system: polymorphic modules and even \nFW-like module type operators are definable. For instance, the polymorphic module AX.m would be expressed \nas the functor functor(x: sig signature X end) (m{x +-x.X}). However, the implications of introducing \nmodule types as structure components are not clear yet, especially with re\u00adspect to decidability of typechecking \n[10]. Access paths The main singularity of this calculus is the restriction to paths (p.v, p.x, p.t) \nwhen accessing structure components, instead of a more general projection construct (m.v, m. z, m .t)thatcould \nbe applied to any module expression m, as in DL and XML [15, 12]. For inst ante, our calculus allows \nz, .t in the scope of the binding z, = ml (mz), but not directly ml(mz).t. The reason why general projections \n(and even projections restrict ed to values, as in Harper and Lillibridge [1 O]) are in\u00adadequate is that \nwe have abstract types and therefore must account for type generat ivity. For instance, assuming j is \na functor returning a structure containing an abstract type t, then two applications of ~ to a structure \nm must return two different types t. With general projections, we would be un\u00adable to determine whether \nthe two types ~(m) .tand f(m).t are compatible (if the two occurrences of ~(m) correspond to the same \napplication of j) or incompatible (if these are distinct applications of j). This problem disappears \nif we restrict projections to paths, and put suitable restrictions on rebinding [5]. Then, the two types \np.tand p.t are always compatible, because the two occurrences of p are guaranteed to refer to the same \nstructure: paths do not contain functor applications, hence their evaluation cannot create new types. \nSimilarly, the two types p.t and p .twhere p # p are incompatible (assuming t and t are abstract types, \nnot manifest types), because p and p are assumed to be bound to different structures. In other terms, \nwe rely on name equivalence to account for generativity. We now give an overview of the typing rules, \nwhich assign module types to module expressions (E k m : M) and signa\u00adtures to structures (L? 1-s : S). \nThe typing rules for module expressions are mostly standard: EFm:M EFM <, M E 1-Z; : E(w) E1-m:M EFs:S \nE k (struct s end) : (sig S end) E + M module type z, $?Dom(E) E; module xi :M k m :M E 1-functor(x~ \n: M)m : functor(z, : M)M E t-ml : functor(x, : M)M Ekm2:M The application rule is the usual elimination \nrule for de\u00adpendent function types. Because only paths are allowed in projections, the substitution M \n{z, + m2 } is undefined if mz is not a path and x, occurs in M . In this case, the ap\u00adplication ml (mz) \nis ill-typed; an intermediate binding of mz to a module identifier must be introduced. Felleisen and \nSabry s A-normalization [23] can be used to introduce these bindings in a systematic way before typechecking. \nThe most unusual rule is the rule for module access: E + p : (sig S1; module z, : M; Sz end) E + P.Z \n: M{~i i-p.~ I L E Dom(Sl)} Here, n ranges over all three kinds of names. In the premise, we consider \nthe path p as a special case of module expres\u00adsion. The rule says that p in p.z must refer to a structure \nwith a module component named x; the type for this com\u00adponent gives the type for p.z. However, the type \nfound in the signature may refer to identifiers bound earlier in the signature, as in p: sig type tj \nmodule x,: Slg Vd Vk: tj end end  These identifiers must be prefixed by p when the type of x is extracted \nfrom the signature. In the example above, this gives p.z the correct type sig val 7&#38; : p.t end, with \np.t in place of tj. The typing of structures is straightforward. Structures are dependent products, hence \na binding must be pushed in the environment before typing the following bindings. EkO:@J Et_e: r v, @ \nDom(E) E;valvi:Tks:S E E (val v, = e; s) :(val v; :T; S) E 1-T definable type t,@ Dom(E) E;typetizrks:s \nE 1-(type t, = T; s) :(type t, = T; S) Et-m:M z, @Dom(13) E;modulex, :Mks:S E + (module z, :M = m; s) \n:(module z. :M; S) We assume given typing judgments for the base language, E F e : T and E + T definable \ntype, to assign types to expressions and to check the well-formedness of type expres\u00adsions, respectively. \n(In the case of ML, the former is defined by Damas and Milner s type system [9] with the extra re\u00adquirement \nthat -r is a closed type scheme, and the latter checks that ~ is a closed simple type and that all external \ntypes p.t in -T are valid.) The rules above make all type components manifest in the inferred signature. \nThey can be abstracted Iat er, if desired, using a module type constraint. The rules require identifiers \nto be renamed so that they are bound at most once. Rebinding lead to incorrect typings in conjunction \nwith name equivalence over paths, as shown by the following example: module x : sig type t; val v:t end \n= struct type t=int; val v=3 end; val u=xv; module x : sig type t; val v:t end = struct type t=bool; \nval v=true end; val w= xv; If both modules x have the same stamp, say, x,, then the values u and w have \nthe same type x,.t, but one is an in\u00adteger and the other a boolean. The side conditions in the rules \nabove guarantee that the two x modules have different stamps, hence that the typesofu and v are incompatible. \n 3.3 Type inclusion and equivalence Type equivalence, written =, takes into account the type equations \nencoded in manifest type specifications: EI; type tt =T; E2H, %T EFp:sig SI; type t,=-r;S2 end The remaining \nrules for type equivalence depend on the base language considered (For ML, they consist of the usual \ntransitivity and congruence rules. ) Inclusion between types (Et--r <: T ) is base language-dependent; \nthe only assump\u00adtion is that type equivalence implies type inclusion. (For ML, subtyping is subsumption \nbetween type schemes.) The inclusion rules between module types are standard. Functor types are contravariant \nin their domain. Eklvf2<:Ml E; module x, : M2 \\ M; <: M; E K functor(zt : M1)M{ <: functor(z~ : M2)M~ \nEFS<:S E Fsig S end <: sig S end Inclusion between signatures is defined as follows: E1-O <:0 EI-SC<:S; \nE; SC I--S<:S E; S.t-S<:S E1--Sc; S<: S;; S EI-SC; S<:S The rightmost rule allows skipping some components \nof the richer signature if they have no counterpart in the simpler signature. Inclusion between signature \ncomponents is de\u00adfined in the obvious way: val types and module module types must be properly included; \nmanifest type specifica\u00adtions are included in abstract type specifications; and two manifest type specifications \nare included if and only if the manifest types are equivalent. EI-T<:T Ekvalv, :r<:valu. : r EI-M<:M \nE F module x, : M <: module z, : M El-type t, = T <: type t. E 1-type t.<:type t, Et-T%T E *type t, =T \n<: type t, = r In effect, the inclusion S1 <: Sz checks that all components in SZ are present in S1, \npossibly with more general types, and possibly interspersed wit h other components. To keep the rules \nsimple, the components common to S1 and Sz must appear in the same order; in practice, it would be desirable \nto allow permutations of independent components. Whenever we skip or retain a component of S1, it is \nadded to the environment for comparing the remainders of S1 and Sz. This is useful if the component is \na manifest type (the type equation might be needed to establish an inclusion later) or a module (whose \nmodule type can contain mani\u00adfest types). Combining the inclusion rules for signatures and the typ\u00ading \nrules for structures, we can type the following three typ\u00adical examples: (1) struct type t=int; val x=1 \nend : sig type t; val x:t end  (2) struct type t=int; val x=1 end : sig type t=int; val x :t end (3) \nstruct type t=int; val x=(1 :t) end : sig val x: int end  (1) corresponds to an abstract type with associated \nopera\u00adtions being implemented as some specific type (here, int). (2) is similar, but the type is exported \nconcretely, with its implementation. (3) corresponds to a local type declaration, which is not exported \nbut is taken into account for signature mat thing.   3.4 Sharing constraints and type strengthening \nThe calculus presented above contains no special rule for checking sharing constraints at functor applications. \nThe general inclusion and application rules can show that sharing constraints are satisfied in many situations, \nespecially those deriving from the diamond import situation. However, they are not always sufficient. \nFirst, they are sensitive to the order in which sharing constraints are written: the curried functor \nmodule f = functor (a: sig type t; . . . end) functor (b: sig type t = at; ... end) ...  cannot be applied \nto structures with the following signa\u00adtures: a: sig type t = b.t; ... end b : sig type t; ... end because \nthe signature of bisnot included insig type t = at; . . . end, even though a.t and b.t are known to be \nequivalent. For the same reasons, the rules fail to recog\u00adnize that a structure always shares with itself: \nthe functor application g(c)(c), with g declared as module g = functor (a: sig type t end) functor (b: \nsig type t = a.t end) . . .  fails ifc. t is abstract. In both cases, theproblem is that we compare \nsignatures without taking into account that they are not signatures of arbitrary structures, but signatures \nof a given path. Fortunately, this fact can be expressed by introducing more manifest types in the signature: \nwhenever apathp has type p: sig type t,;... end, it also has type p:sig type ti=p.t;... end. If we \napply this transformation to the types of b and c in the examples above, the subtyping rules now recognize \nthat the sharing constraints are satisfied. For instance, when typing the application f(a)(b) above, \nwe have toshowthatb has type sig type t = at; ... end and this can be done by first considering b with \ntype sig type t = b.t; . . . end, then provingb.t = a.t from the type ofa. This operation onpathtypes \niscalled str-engthening. The corresponding typing rule is: EFp:M EFp: M/p where the strengthening operation \nM/pis defined by: (sig S end)/p = sig S/p end M/p = M if M is not a signature (val v,:r; S)/p = val v.:r; \nS/p (type t%; S)/p = type t;=p.t; S/p (type t,= T; S)/p = type t,=p.t; S/p (module x.:M; S)/p = module \nxi~M/p.z;S/p Eveninthecases formanifesttypes, noinformationis lostby strengthening: if we replace type \nt, = T by type t, == p.t in the type of p, we can still show that the t component is equivalent to ~, \nby looking up the original type of p in the typing environment. This remark can be formalized na follows: \nif p has type M in the environment E, then M/p is a subtype of M in E. Hence, it is always safe to apply \nthe st lengthening rule before checking type inclusion. Type strengthening is also useful when taking \nmultiple views of a structure while preserving type compatibility be\u00adtween the views. Assume x is bound \nto a structure with type x: sig type t; val f: r; val g: u end and we wish to view x without the g component. \nIf we define the view as module y :sig type t; val f: 7end =x then, by generativity, y. t is a new type, \nincompatible with x. t, since x and y are not the same path. To ensure com\u00adpatibility between x. t and \ny. t, we must make t manifest in the signature of y: module y : sig type t =x.t; val f: r end =x Checking \nthe type-correctness of this binding requires the strengthening rule: without prior strengthening, the \nsigna\u00adture of x would not be a subtype of the signature declared for y. 3.5 Type inference The typing \nrules presented above do not lead directly to a type checking or type inference algorithm, since the \nrules for subsumption and strengthening are not syntax-directed. However, the applications of these rules \ncan be floated downwards and combined with the functor application and module binding rules. More precisely, \nwe define a syntax\u00addirected variant of the calculus above by removing the sub\u00adsumption and strengthening \nrules, and replacing the rules for functor application and module binding by: E k rm : functor(z~ : MI)M \nEtm2:M2 E F M2/m2 <: MI E k ml(mz) : M{z, + mz} EFm:M E 1-M /m <: M x, $! Dom(E) E;modulex, :Mbs:S E \nk (module x, :M = m; s) :(module z, :M; S) Here, we write M/m for M if m is not a path, and M/p if m \nis a path p. The resulting system has the following correctness and completeness properties: 1. if E \nE m : M in the syntax-directed system, then E 1\u00ad m : M in the original system; 2. if E + m : M in the \noriginal system, then there exists M such that E E m : M in the syntax-directed system and E 1-M /m <: \nM. Moreover, the type equivalence and type subsumption re\u00adlations between module types are obviously \ndecidable (by structural induction on the type expressions) as soon as the corresponding relations on \nbase types are decidable. The de\u00adcidability problems encountered in Harper and Lillibridge s system [10] \nare avoided here because we do not have module types as structure components. From these remarks, we \neasily obtain a type inference al\u00adgorithm which, given an environment E and a module ex\u00adpression m, either \nreturns the most general type of m in E, or fails if m is ill-typed in E. At the level of the core lan-presented \nby A-abstractions and II-types (dependent func\u00ad guage, it assumes given algorithms to infer the principal \ntype of a value expression and to check equality and subsumption between core type expressions. The algorithms \nfor the core language must take into account the extra type equalities induced by the manifest types \nin the current typing environ\u00adment. In the case of ML, the principal type property and the existence \nof a type inference algorithm still hold when equations between types are introduced to take into account \nmanifest type declarations. This follows from R6my s gen\u00aderal results on type inference modulo an equational \ntheory [21]. 4 Expressiveness The aim of this section is to show that our calculus (with opaque signatures \nand propagation of type equalities through manifest types) is at least as expressive as the SML module \nsystem (with transparent signatures and propagation of type equalities through structures). Ideally, \nwe should present a type-preserving encoding of a significant fragment of SML (e.g. without structure \nsharing) into our calculus. Unfortunately, the size and complexity of the SML definition [17] are such \nthat defining this encoding and reasoning about it is hopeless. Instead, we will start from a much simpler \ncalculus based on strong sums, similar to MacQueen s DL calculus and Harper and Mitchell s XML calculus \n[15, 12]. This calculus accounts for the basic features of the SML module system except generativity \nand sharing. To keep the encoding simple, the target of the encoding will not be the module system presented \nin the previous sec\u00adtion, but a simpler calculus, closer in syntax to the strong sums calculus, but wit \nh weak sums and manifest types in\u00adstead of strong sums. The target calculus accounts for most of the \nfeatures of our module system except generativity. The fragment of the target calculus actually used \nby the translation can easily be encoded into the system of sec\u00adtion 3. 4.1 Strong sums and manifest \nsums The source and target calculi have the following syntax: Terms: m ::= z I kc:ibf. m I m,l(rnz) [ \n[t=7-, m]IOps(rn) I (z= ml, rnz) I fst(rn) I snd(m) Simple types: 7::=intlbool\\,..l7l+~zlt Ityp(m) Module \ntypes: M ::=7] 3t. Ml %=T.I!J XZ:MI. M2 [rIz:M1. M2 Structures are replaced by two simpler constructs, \n[t= -r, m] to package a type T with a module m, and (x = ml, mz), which is the dependent pair of two \nmodules. Access in pack\u00adages and pairs is by position (projections typ and ops for packages, fst and \nsnd for pairs) instead of by field names. Similarly, signatures are replaced by existential types (for \npackages) and X-types (for dependent pairs). Functors are tion types). A difference with DL and XML is \nthat we keep existen\u00adtial types distinct from E-types, instead of injecting simple types into module \nterms, which turns packages into special cases of pairs and existential types into special cases of Z\u00adtypes. \nIn our system, we have manifest existential types but no manifest Z-types, hence we cannot identify these \ntwo notions. The base language used here is simply-typed lambda-calculus (with constants represented \nas predefine identifiers). Instead of explicitly injecting the baae language into the module language, \nwe simply consider the base language as a subset of the module language: J-abstraction and application \nat the level of the base language are merged with A-abstraction and application at the level of modules. \nThis makes no semantic differenc~ [12] but further simplifies the calculus. The calculus is still stratified \nat the type level, however: base-language functions and module-level functors have distinct types, and \nexistentially quantified type variables range over simple types, not over module types. The dynamic semantics \nfor the calculus are given by the following reduction rules: (Az:M. m)(m ) + m{. 4-m } typ[t =r, m] + \n~ Ops[t =T, m] + rn{t + T) fst(z =ml, mz) + ml snd(z= ml, mz) -+ mz{z + ml} r[m] + r[m ] if m + m , \nfor any context r We write ~ for the reflexive and transitive closure of the reduction rules. Figure \n1 shows the typing rules for the two variants of the calculus that will serve as source and target for \nthe transla\u00adtion. The first variant, named S for strong sums , does not use manifest existential types \n3 = r.M and treats packages as transparent. The second variant, named M for weak sums with manifest types \n, uses manifest existential types to propagate type equalities and treats packages as opaque. The difference \nbetween S and M is apparent m the type equivalence rules for typ(rn). In M, if m does not have a manifest \nexistential type, the type expression t yp(m ) is only equivalent to t yp(m ) where m and m are syntactically \niden\u00adtical. In S, rule 6 says that typ(m) is equivalent to the type part of whatever package m reduces \nto. The introduction rules for Z differ accordingly. In S, the second component mz of the pair (a = ml, \nmz) is typed after textual substitution of c by ml, so that mz can rely on specific implementations of \nabstract types in ml. In M, only the type of ml, not ml itself, is taken mto account for the typing of \nmz. The system M also has subsumption and strengthening rules similar to those of the full module calculus. \nStrength\u00adening M/m is here defined as: T/?71 =.T (%. M)/m = % = typ(m). M/ops(m) E 1-z : E(z) (1) E,x:rll-m:r2 \nEkml:r+r Ekm2:r Ek~x:rl. m:rl+ r2 E l--ml(mz) : T E,x:A411-m:A4z EEml:IIz:A4. iW E+mz:lvf (2) E k k:M1. \nm : ILc:A41. M2 E1-ml(mz) : A4 {z + M} Ekm{t+~}:A4{t+~} Ek. m{t+r}:M{t +--r} (3) E~[t=T, m]:3t. M Ek[t=T, \nm]:%=T. M Ekm1:A41 E&#38;m2{z+ ml}: A42{z+ ml} Ekml:Ml E,x:M1kam2:M2 (4) Ek (z= ml, mz) : Dz:MI. M2 Ek \n(z=ml, mz) : ZZ:M1. MZ E1-m:3t. M Ekm:Ex:M1. M2 Ekm:Ex:M1. M2 E 1-ops(m) : M{t + typ(m)} E + fst(m) : \nMl E + snd(m) : Mz{z + fst(m)} Ehm:M EkM GM Ekm:M EkM<:M Eknm:M (5) Ekm:M Ekm:M Eknm: M/m E~.m:~t=r.M \nEkM%M E&#38;m:3t. M m~[t=r, m ] (6) (7) E k typ(m) x T E k, typ(m) Ek, M<:M w~ Ek.3t=r. M<:3t. M Ek, \nM<:M EkTs# Ek M{t +T} <: M {t +T } E k+, 3t. M <: 3t. M Ek~t=r. M<:~t=r . M EkMl<:M{ E,x:Mlt-Mz<:M4 Ek,M~<:Ml \nE,x:M~k Mz<:M~ E k ~x:M1. M2 <: ~x:M~. M; E k IIz:M1. Mz <: IIz:M:. Mj Plus the standard congruence, \ntransitivity and symmetry rules for =, and transitivity y rule for <: Figure 1: Typing rules for strong \nsums (S) and weak sums with manifest existential (M). Left: S-specific rules; right: M-specific rules; \ncenter: common rules. + stands for either $ or ~. (%= T. M)/m = % = typ(m). M/ops(m) We are going to \nshow that any term that is typable in S using only A types is also typable in M using C types. (Dc:MI. \nM2)/m = Zz:M1/fst(m). M2/snd(m) Moreover, the C types used in the M derivation correspond, (IIz:M1. Mz)/m \n= II.: Ml. M2/m(z) in a sense to be made precise below, to the A types used in the S derivation. The \ncorrespondence between A and C types is captured  4.2 The first-order fragment by the following stripping \noperation, written ~, which re-We now show that the first-order fragment of S, the calculus moves all \nmanifest type information from a C type, turning with strong sums, is included in the first-order fragment \nof it into an A type: M, the calculus with weak sums and manifest existential. T=r By Yirst-order ), \nwe mean that functors cannot take functors as arguments, as in SML. Unlike SML, we will still allow 3t=T. \nc = %.77 functors as structure components, as long as such structures . Ex:cl. C2 = Ex:cl. Cz are not \npassed to functors. Consider the following subsets rk:l? c = rIz:F.7? of module types: This operation \nis extended pointwise to typingFunctor argument types: environments. F ::= T [3t. F IZZ:F. F Proposition \n1 Let E be a typing environment containing A ::= T [3t. A IZk:A. A IIIz:F. A F and C types. Abstract \nfirst-order types: Concrete first-order types: 1. If ~ k m : A, then there exists C such that ~ = A \nand C::= r[3t=r. CIZz:C. CIHr:F. C Ek, m:C. 2. If~kA z A and A = ~, then there exists C such that A =~and \nEhC% C . Part (2) is the main difficulty of the proof: apparently, system S can derive more type equalities \n(using reductions during typing whenever necessary) than system M (where the only information available \nis the one recorded in manifest types). We will show that this is not the case, at least for the first-order \nfragment. The proof makes use of the following properties of system M: subject reduction (if E k m : \nM and m. ~ m , then E k, m ) and uniqueness of typings (if E k. m : Ml and E,E k m : Mz, then E,E kn \nMl % M2). Proofi by induction on the derivations and case analysis on the last rule used. We show the \nmain cases. (2), rule 6. FYom the left premise and the induction hypoth\u00ad esis (l), we get E k. m :3t \n= o.C with 3.G = A. Since m ~ [t = -r,m ], it follows that E k [t = T,m ] : 3t = u. C by subject reduction. \nBy uniqueness of typings, E $.0 x ~. Hence E k f st (m) N T by rule 7 and transitivity, and we can take \nC = r. (l), rule 1. If E(z) is a C type, we can take C = E(z) Otherwise, E(x) is a F type and we can \ntake C = E(x)/x. (l), rule 3. We have A = qt. A . By induction hypothesis (l), wehave E k m{t + T} :C \n{t + T} and~ = A . We can take C = (% = I-.C ). (l), rule 2. Follows immediately from_the induction hypoth\u00adesis \n(1) and the fact that E k C <: C for all C. (l), rule 4. By induction hypothesis (1) applied to the premises, \nwe get E k ml :Cl and E ~ m2{z +-ml} : C2{X + ml} (3), with m = Al and~ = A2. Wemust prove that E, x \n: Cl k m2 : C2 (4). Consider each oc\u00adcurrence of z substituted by ml in the derivation of (3). These \noccurrences correspond to sub-derivations of the for\u00admat E, E k ml : C (5) for some E and C. By uniqueness \nof typings, we have E, E $. C z Cl. Hence we can derive E, z : Cl, E k x : C (6). By substituting (6) \nfor (5) in the derivation of (3) for each occurrence of z, we obtain a derivation of (4). (l), rule 5. \nFollows immediately from the induction hypoth\u00adesis (2). 0 4.3 Higher-order functors The expressiveness \nresult above does not extend to higher\u00adorder functors. The reason is that higher-order functors are more \npolymorphic in system S than in system M. Con\u00adsider the following example (we revert to SML-like syntax \nfor clarity): signature S = sig type t . . . end; module G = functor (F: functor(X: S)S) functor (X: \nS) F(X) ; module A = G(functor(X: S) X) (struct type t=int . . . end) ; module B = G(functor(X: S) struct \ntype t=int . . . end) (struct type t=bool . . . end) ; In SML with higher-order functors [25], A and \nB are well\u00adtyped, and moreover A. t and B. t are both compatible with int. In our calculus, if we do \nnot introduce any manifest type in the definition of G, A and B are well-typed but A. t and B. t are \nincompatible with int. To make A. t compatible with int, we can define G as: module G = functor (F: functor(X: \nS) S with type t=X. t) functor (X:S) F(X) ;  but then the definition of B is ill-typed, because the \nconstant functor given as first argument has the wrong type. To make B. t compatible with int, we can \nsimilarly define G as. module G = functor (F: functor(X:S) S with type t=int) functor (X:S) F(X);  but \nthen thedefinition of A is ill-typed. Hence, our system makes it impossible to define a functor G that \ncan be used in all contexts where its SML counterpart can, From the discussion above, one might conclude \nthat higher-order functors are strictly more expressive in SML than in our system. This is not so: in \nour system, higher-order functors can specify all the sharing properties of their functorial arguments, \nsuch as the parameter F is a functor that takes astructure X with atypet and returns a structure with \na type equal to t list : functor(F: functor(X:S) S with type t = X.t list) This is not supported in \nTofte s proposal [25]: sharing con\u00adstraints in the functor specification can require that the t component \nof the result structure is identical to another type constructor such as X.t, but they cannot express \nmore gen\u00aderal dependencies as in the example above. Consequently, Tofte s system does not allow abstracting \nover any functor: the following code fragment signature S = sig type t; val x:t; val f:t->t end; functor \nF(X:S) = struct type t=X. t list; . . . end; structure G = struct structure A = struct type t=int; . \n. . end; structure R = F(A); val y = R.f [Ax] end; is well-typed, but we cannot abstract over F in G, \nbecause no functor signature for F can specify that F(X). t is equal to X.t list, nor to int list. In \ncontrast, our system al\u00adlows abstracting over any functor which is an important motivation for higher-order \nfunctors: allow arbitrary pro\u00adgram fragments to be closed by abstracting over all free identifiers. 5 \nExtensions 5.1 Type systems with kinds A useful extension of the module calculus presented in this paper \nis the introduction of kinds at the level of core types. Kinds are required to ensure the well-formedness \nof type ex\u00adpressions in the presence of type constructors, as in full ML, or type operators, as in Fti. \nKinds also provide an elegant treatment of bounded quantification [3, 4]. Introducing kinds in the module \ncalculus is straightfor\u00adward: abstract type specifications in signatures now have the form type t::K,where \nK is a kind. The modified typ\u00ading rules check that the implementation types are of the expected kinds, \nand that kinds are properly included when checking signature inclusion. (See [4] for a similar calculus.) \nHaving kinds in type specifications offers an opportunity to simplify the treatment of manifest types. \nThe idea is to introduce the kind EQUIV(r) of all types that are equivalent to T. I his way, a manifest \ntype declaration type t = -r in a signature can be expressed as the type specification type t :: EQUIV(~). \nThis trick parallels Cardelli s treatment of bounded quantification using the kind POWER(r) of all sub\u00adtypes \nof ~ [3, 4]. With the EQUIV kind, there is only one syn\u00adtactic construct to declare a type in a signature: \ntype t::K. The kind &#38; says whether t is manifest (if K = EQUIV(~)) or abstract (if IC= TYPE, where \nTYPE is the kind of all types). Besides simplifying the syntax, the EQUIV kind also clar\u00adifies the typing \nrules, by moving all manifest type-specific rules up to the kind level, making them orthogonal to the \nrules for structures and signatures. The properties of mani\u00adfest types are captured by the rules below \nfor the EQUIV kind (left column). They are surprisingly similar to the rules for the POWERkind (right \ncolumn). Et-r=u Ekr<:u E k T :: EQUIV(a) E 1-T :: POWER(O) E + T :: EQUIV(cT) E t-T :: POWER(cr) Et-TGU \nEFT<:u E F EQUIV(T) <:: TYPE E 1-POWER(T) <:: TYPE E1-Tzo E+r<:u E ~ EQUIV(T) <:: EQUIV(0) E k POWER(7) \n<:: POWER(O) As demonstrated by the rules above, once kinds are intro\u00ad duced in a type system, it is \nthen straightforward to extend it with manifest types, bounded quantification, or both at the same time. \n 5.2 First-class modules Another natural extension of the work presented here is to merge the module \nlanguage and the base language, by treat\u00ading modules as first-class values. This approach brings ad\u00additional \nexpressive power and simplifies the formalization. In the case of a module system based on strong sums, \nsuch as SML S, first-class modules raise major difficulties [12]: simply-typed lambda-calculus with strong \nsums is logically inconsistent (i.e. non-normalizing) and has no phase distinc\u00adtion (i.e. arbitrary reductions \nare required during typecheck\u00ading); as a consequence, typechecking is undecidable. Strat\u00adification into \na base language and a module language is es\u00adsential to ensure the phase distinction and decidability \nof typing [13]. First-class modules cause less difficulties in our approach because it is based on weak \nsums [19, 7]. No reductions are needed during typechecking, hence the phase distinction is obvious, whether \nmodules are first-class or not. As shown by Harper and Lillibridge [10], first-class mod\u00adules still make \ntypechecking undecidable in the presence of manifest types, but for different reasons than for strong \nsums: what is undecidable is the subtyping relation, as in F<. [20], and this is due to the combination \nof subtyping, manifest types and dependent function types at the same level. Stratification avoids this \nproblem by allowing differ\u00adent combinations of these features at the two levels: in the system presented \nabove, manifest types but no subtyping nor dependent function types at the base level, and subtyp\u00ading \nand dependent function types but no manifest types at the module level. 6 Conclusions We have presented \na variation on the SML approach to mod\u00adularity that propagates type equations explicitly through signatures \nand module types, instead of implicitly through structures and module values. While retaining the expres\u00adsiveness \nof the SML module system, our variant provides much better support for Modula-style separate compilation \nand, more generally, makes it easier to understand code frag\u00adments with free structure identifiers. The \nunderlying type theory is also simpler. A prototype batch compiler integrating the main ideas in this \npaper (type abbreviations in signatures and opaque interpretation of signatures) has been derived from \nSML/NJ 0.93 by Pierre Cr6gut [8]. The main difference with the work presented here is that both opaque \nand transparent signatures are supported, via two distinct module binding constructs. Another implementation, \nbased on the author s Carol Light system and closer to the calculus introduced in sect ions 2 and 3, \nis in progress. On the practical side, some concern has been expressed about the additional verbosity \nbrought by declaring manifest types in signatures. Previous attempts at programming in a fully functorized \nstyle, with all type equations explicit, have demonstrated a major increase in program size due to the \nextra sharing declarations required [2]. We expect this problem to be less acute in our approach, since \nmanifest types provides better support for non-fully functorized code; moreover, one manifest type declaration \n(in the definition of the signature of a module) sometimes replace several sharing declarations (one \nfor each functor that imports this module). More practical experience is required to assess this issue. \nFinally, the general idea of making the definitions of some structure components explicit in the signature, \nhere applied to the type components, could also be extended to other kinds of components: values and \nsub-structures. Defining a value in a module signature does not make much sense at first sight, but is \nactually a common programming practice (definition of constants in Modula interfaces, of macros and in-line \nfunctions in C and C++) and provides a simple yet highly practical approach to user-controlled function \ninlin\u00ading. Acknowledgments The author is grateful for conversations with Luca Cardelli, Robert Harper, \nMark Lillibridge, Pierre Cr6gut, Didier R6my and Maria-Virginia Aponte. John Mitchell, Stefan Kahrs and \nLars Birkedal suggested a number of improvements in earlier drafts. References [1] M.-V. Aponte. Extending \nrecord typing to type para\u00admetric modules with sharing. In 20th symposzum Prin\u00adciples of Programmmg Languages, \npages 465 478. ACM Press, 1993. [2] L. Birkedal, N. Rothwell, M. Tofte, and D. N. Turner. The ML kit, \nversion 1. Technical report 93/14, DIKU, 1993. [3] L. Cardelli. Structural subtyping and the notion of \npower type. In 15th symposium Principles of Program\u00adming Languages, pages 70 79. ACM Press, 1988. [4] \nL. Cardelli. Typeful programming. In E. J. Neuhold and M. Paul, editors, Formal Description of Programming \nConcepts, pages 431-507. Springer-Verlag, 1989. [5] L. Cardelli and X. Leroy. Abstract types and the \ndot notation. In Proc. IFIP TC2 working conference on pro\u00adgramming concepts and methods. North-Holland, \n1990. [6] L. Cardelli and J. C. Mitchell. Operations on records. In Mathematical Foundations of Programming \nSeman\u00adtics, volume 442 of Lecture Notes in Computer Sctence, pages 22 52, 1989. [7] L. Cardelli and P. \nWegner. On understanding types, data abstraction, and polymorphism. Computmg sur\u00adveys, 17(4):471 522, \n1985. [8] P. Cr6gut. Separate compilation in SML. Working note, Magic group, ECRC, 1993. [9] L. Damas \nand R. Milner. Principal type-schemes for functional programs. In 9th symposium Principles of Programming \nLanguages, pages 207 212. ACM Press, 1982. [10] R. Harper and M. Lillibridge. A type-theoretic ap\u00adproach \nto higher-order modules with sharing. In 2?1st sympos~um Pr~nczples of Programming Languages. ACM Press, \n1994. [11] R. Harper, R. Milner, and M. Tofte. A type discipline for program modules. In TAPSOFT 87, \nvolume 250 of Lecture Notes in Computer Sctence, pages 308 319. Springer-Verlag, 1987. [12] R. Harper \nand J. C. Mitchell. On the type struc\u00adture of Standard ML. ACM Trans. Prog. Lang. Syst,, 15(2):211 252, \n1993. [13] R. Harper, J. C. Mitchell, and E. Moggi. Higher-order modules and the phase distinction. In \n17th symposium Principles of Programming Languages, pages 341-354. ACM Press, 1990. [14] D. MacQueen. \nModules for Standard ML. In R. Harper, D. MacQueen, and R. Milner, editors, Standard ML. University \nof Edinburgh, technical report ECS LFCS 86-2, 1986.  [15] D. MacQueen. Using dependent types to express \nmodu\u00adlar structure. In 13th sympostum Principles of Program\u00adming Languages, pages 277 286. ACM Press, \n1986. [16] R. Milner and M. Tofte. Commentary on Standard ML. The MIT Press, 1991. [17] R. Milner, M. \nTofte, and R. Harper. The definition of Standard ML. The MIT Press, 1990. [18] J. C. Mitchell. On the \nequivalence of data represen\u00adtations. In V. Lifschitz, editor, Artijictal intelligence and mathematical \ntheory of computation, pages 305 330. Academic Press, 1991. [19] J. C. Mitchell and G. D. Plotkin. Abstract \ntypes have existential type. ACM Trans. Prog. Lang. Syst., 10(3):470-502, 1988. [20] B. C. Pierce. Bounded \nquantification is undecidable. In 19th symposium Principles of Programming Languages, pages 305 315. \nACM Press, 1992. [21] D. R6my. Extending ML type system with a sorted equational theory. Research report \n1766, INRIA, 1992, [22] J. C. Reynolds. The essence of Algol. In de Bakker and van Vliet, editors, Algorxthmtc \nlanguages, pages 345 372. North-Holland, 1981. [23] A. Sabry and M. Felleisen. Reasoning about programs \nin continuation-passing style. In Lisp and Functional Programming 1992, pages 288-298, 1992. [24] Z. \nShao and A. Appel. Smartest recompilation. In 20th symposium Principles of Programming Languages, pages \n439-450. ACM Press, 1993. [25] M. Tofte. Principal signatures for higher-order program modules, In 19th \nsymposzum Principles of Programmmg Languages, pages 189-199. ACM Press, 1992. [26] M. Tofte. Type abbreviations \nin signatures. Message sent to the sml mailing list, Jan. 1992, [27] N. Wirth. Programmmg in Modula-2. \nSpringer-Verlag, 1983,    \n\t\t\t", "proc_id": "174675", "abstract": "<p>This paper presents a variant of the SML module system that introduces a strict distinction between abstract types and manifest types (types whose definitions are part of the module specification), while retaining most of the expressive power of the SML module system. The resulting module system provides much better support for separate compilation.</p>", "authors": [{"name": "Xavier Leroy", "author_profile_id": "81100078576", "affiliation": "Dept. of Computer Science, Stanford University, Stanford, CA", "person_id": "PP39026141", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/174675.176926", "year": "1994", "article_id": "176926", "conference": "POPL", "title": "Manifest types, modules, and separate compilation", "url": "http://dl.acm.org/citation.cfm?id=176926"}