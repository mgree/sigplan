{"article_publication_date": "02-01-1994", "fulltext": "\n Representing Monads* Andrzej Filinski School of Computer Science Carnegie Mellon University Pittsburgh, \nPA 15213-3891 andrzej +@cs. cmu. edu Abstract WJe show that any monad whose unit and extension operations \nare expressible as purely functional terms can be embedded in a call-by-value language with composable \ncontinuations . As part of the develop\u00adment, we extend Meyer and Wand s characterization of the relationship \nbetween continuation-passing and di\u00adrect style to one for continuation-passing vs. general monadic style. \nWe further show that the composable\u00adcontinuations construct can itself be represented using ordinary, \nnon-composable first-class continuations and a single piece of state. Thus, in the presence of two specific \ncomputational effects storage and escapes any expressible monadic structure (e.g., nondet ermin\u00adism \nas represented by the list monad) can be added as a purely definitional extension, wit bout requiring \na rein\u00adterpretation of the whole language. The paper includes an implementation of the construction (in \nStandard ML with some New Jersey extensions) and several examples. 1 Introduction 1.1 Background and \noverview Over the last few years, monads have gained consid\u00aderable acceptance in the lazy functional \nprogramming world. Originally proposed by Moggi as a convenient framework for structuring the semantics \nof languages \" This research wss sponsored in part by the Defense Advanced Research Projects Agency, \nCSTO, under the title (The Fox Project: Advanced Development of S ystems Software , ARPA Order No. 8313, \nissued by ESD/AVS under Contract No. F19628-91-C-0168. NSF also sponsored this research under grant no. \nCCR-8922109 The views and conclusions contained In this document are those of the author and should not \nbe interpreted as representing the official poli\u00ad cies, either expressed or implied, of the Defense Advanced \nResearch Projects Agency or the US. Government. Permission to copy without fee all or pert of this meterial \nis granted provided that the copies we not mede or distributed for direct commercial edventege, the ACM \ncopyright notice end the title of the publication and it? date appear, and notice i$ given that copying \nis by permission of the Association for Computing Machinery. TO copy otherwise, or to republish, raquires \na fea and/or specific permission, POPL 94-li94, Portland OrWort,USA @ 1994 ACM tW39791-63WB4/Wl ..$3.~ \n[14, 16], they were quickly popularized by Wadler and others aa a technique for structuring functional \npro\u00adgrams [32, 18]. It is not hard to see the reason for this popularity: monads promise access to state, \ncontrol op\u00aderators, 1/0, etc., while retaining the strong reasoning principles valid for pure functional \nlanguages. Briefly, restricting programs to so-called monadic style (very similar in spirit and appearance \nto continuation-passing style) sets up a uniform infrastructure for represent\u00ading and manipulating computations \nwith effects aa first\u00adclass objects. It is somewhat remarkable that monads have had no comparable impact \non impure functional program\u00adming. Perhaps the main reason is that as clearly ob\u00adserved by Moggi, but \nperhaps not as widely appreciated in the purely functional community the monadic framework is already \nbuilt into the semantic core of eager functional languages with effects, and need not be expressed explicitly. \nImpure constructs, both lin\u00adguistic (e.g., updatable state, exceptions, or first-class continuations) \nand external to the language (1/0, OS interface, etc.), all obey a monadic discipline. The only aspect \nthat would seem missing is the ability for pro\u00adgrammers to use their own, application-specific monadic \nabstractions such as nondeterminism or parsers [31] with the same ease and naturality as built-in effects, \nActually, many of the useful monadic effects that are not already included can be defined in terms of \nexisting concepts in typical eager functional languages. For ex\u00adample, backtracking can be expressed \nwith call/cc and an updatable st ack of backtracking points [5]. Still, such implement ations appear \nad-hoc, require a thorough un\u00ad derstanding of the imperative features used, and have no clear connection \nto the pure monadic abstractions they implement. And although all of the usual monads seem to yield to \nthis approach, it is far from obvious that they must all do so. In the following, we will show that in \nfact any monadic effect whose definition is itself expressible in a functional language can be synthesized \nfrom just two impure ) constructs: first-class continuations and a storage cell. In other words, a language \nlike Scheme [2], or ML with first-class continuations [5], is already monadically complete in the sense \nthat any program expressible in the somewhat contorted monadic style can also can be written in direct \nstyle. Moreover, all uses of computational effects in the definition can be en\u00adcapsulated into an abstraction \ncustomarily called corn\u00adposable, functional, or partial continuations, and the re\u00admaining program contains \nno explicit references to ei\u00adther escapes or state. The rest of this section contains a very brief intro\u00adduction \nto monads (a reader unfamiliar with the con\u00adcept would be well advised to read one of the papers by Moggi \nor Wadler for a more complete presentation) and Moggi s convenient notation for monadic effects. The \nfollowing sections then derive the representation result as a succession of three steps, each of which \nis potentially useful in its own right and directly ex\u00adtends or supplements earlier work. First, we develop \na formal correspondence between monadic style and continuation-passing style. Using this, we show that \nall non-standard manipulations of the continuation in monadic CPS can be expressed in terms of two opera\u00adtors \nfor composable continuations. Finally, we show how to define these two operators using ordinary first-class \ncontinuations and a piece of state. To supplement the abstract development, section 5 presents the complete \nembedding aa executable ML code and illustrates how some common monadic effects can be uniformly repre\u00adsented \nas instances of the construction. A comparison with related work and some conclusions complete the paper. \n 1.2 Monads and monadic reflection For the purposes of monadic functional programming , a monad consists \nof a type constructor T and operations (polymorphic functions) called unit and extension, respect ivel \ny. ( Wadler uses a binary infix operator for the latter, writing m bind f or m A-f for our ~ m. His notation \nis probably superior for writing actual programs in monadic style, but the vari\u00adant above seems preferable \nfor the formal manipulations we will be performing.) The operations are required to satisfy three monad \nlaws: Monads can be used to give a semantics of various computational effects (such as state, exceptions, \nor 1/0) in applicative programming languages [14, 16]. In particular, our development is set in a simple \ncall\u00adby-value (CBV) functional language based on Moggi s principle : Computations of type a correspond \nto values of type TCY. Informally, ~a represents a pure (i.e., effect-free) computation yielding a, \nwhile flt represents the com\u00adputation consisting of t s effects followed by the result of applying f \nto the value computed by t. As also noted by Moggi, the correspondence principle can be embodied in an \nintrospective language exten\u00ad sion which could be called monadic mjlect ion (by anal\u00ad ogy to computational \nreflection [28, 34]), given by two operators: Ft-E:TcY I 1-E:a and rt-p(E):a r~[~l:zk For any E : T~, \np(E) rejlects the value of E aa an effectful computation of type a. Conversely, given a general computation \nE : a, [El reifies it as the corre\u00ad sponding effect-free value of type TCY. For example, let T be the \nexception monad, defined as Ta = cr+exn q = k. inla r = N.caset ofinla-fa[inre+inre (where exn is a \ntype of exception names). Then P(E) expresses the value of E : CY+ exn aa a computation: we get an exception-raising \nconstruct by raise E &#38;f p(inr E) (where E is an expression -typically just a value -of type exn). \nConversely, [E] turns a possibly exception\u00ad raising a-expression E into a value of type a + exn, so we \ncan define an exception-handling construct like this: El handle e a E2 a~f case [.El] of inl a + a [ \ninre +E2 (i.e., if El raises an exception, the handler E2 is invoked with e bound to the exception name; \na general pattern\u00admatching handle construct like SML s can easily be expressed in terms of this one). \nJustifying the designation as a correspondence prin\u00adciple , monadic reification and reflection are inverses \nm their respective domains. That is, for any expres\u00adsion E: @ (possibly With computational effects) and \nany value V : Ta, p([El) = E and [p(v)] = v The more general not ation p(E) can be seen as sim\u00ad ply \nshorthand for let v = E in P(v), so in practice p(.) would be provided as a function reflect : Ta + a. \nIt is not necessary to have [.] as a special form either: we can exploit the usual bijection between \ncomputations of type a and values of type 1 --+ CYto get a function reify : (1+ a) + TcY, extracting \nthe monadic representa\u00ad tion from a suspended computation. For the theoretical development in sections \n2 4, however, we will keep the more compact p(0)/ [.]-notation. 2 Monads and CPS As the first step of \nour development, let us investigate the formal connections between monadic style and continuation-passing \nstyle (CPS). As noted by Wadler and others, the two appear closely related, but the ac\u00adtual correspondence \nis quite involved and benefits from a more detailed analysis. In this section, we consider two translations \n(monadic and CPS) from a simply-typed CBV functional lan\u00adguage with monadic reflection and reification \noperators (our object language) into a purely functional meta\u00ad/anguage: a typed Apv-calculus with monadic \nunit and extension functions. We then relate the two translations, generalizing the results of Meyer \nand Wand [13] about the typed CPS transform: their method can be seen as covering the par\u00adticular case \nwhere T is the identity monad (i.e., T~ = CX, 9 = ~d) and f*= f) 2.1 The monadic t ranslat ion The monadic \ntranslation transforms an object-language term E with free variables al,. ,., Xn, Zl: al,..., xn:anl-E:~ \n into the meta-language term Zl: [al]=, ..., z.: [an]. 1-[E]T : T~]~ The translation on types is given \nby: [t]T =, [a -/&#38; = [cY]~ + T[P]T [T+ = T[a]~ Here t ranges over base types, and we use a -f? for \nthe CBV function space to distinguish it from the un\u00adderlying pure function space a + P. The extension \nto structured types (products, sums, etc.) is straightfor. ward but omitted here for brevity. The term \ntranslation is given by [z]T = qz [k. E]~ = q(Jz. [J%) [E, E,]T = (~f. f* [~2]~)* [~I]T [P(~)]~ = ~~ \n[Ell~ [[El]T = q[E]T (where the last two, perhaps less familiar-looking, equa\u00adtions are taken from Moggi \n[14].) As an example of monadic reasoning, let us quickly check that the monad laws verify the correspondence \nprinciple for [.] and p(.): k([El)]T = id [[E]]== id* (q [E]~) = (id O q) [E]= = id [E j~ = [I&#38; \n Conversely, taking z as a representative value (the other cases are analogous): 2.2 The CPS translation \nLet us now consider the CBV CPS translation for the same pair of languages, and in particular still with \nre\u00adflection and reification operators for the monad T. The translation on types looks similar: where \nKY= (Y-+ To)-To for a type o of final answers. (The key idea of making To the new answer type is due \nto Wadler [32]), To get a simple relationship be\u00adtween the two translations, we assume o to contain all \ndenotable values [22] (note that such an o does not have to be a type expressible in the source language).1 \nFur\u00adther, to avoid clutter in the term equations, we omit inject ions into and project ions from o. Now \nour source term E is translated into where the term translation is given by The first three equations \nare the usual ones [19]. We will verify that the last two really are the correct CPS analogs of their \nT-translation counterparts next. 2.3 A relation between between monadic style and CPS Let us first note \nthat we can define a type-indexed fam\u00adily of functions mediating between monadic and CPS 1Alternatively, \nwith a little more care, we can t&#38;e K-y = Vo. (-y+ To) + To; itis straightforward to check that both \nthe term translation and the operations defined in the following can in fact be typed according to this \nschema. (Meyer and Wand use the names i and j for functions analogous to $ and $, but the definition \nof $ given above is slightly more convenient when T is not necessarily the identity,) It is straightforward \nto verify that (&#38;, 07) form a retraction pair, i.e., that for any source-t ype ~, in the metalanguage. \nFor ~ = t, the result is immediate; for y=a -p: and for -y = Ta: Thus the type translations faithfully \nembed the T-Translation of a source-language type in the correspond\u00ading K-translated type. But to properly \nrelate the two translations, we want the stronger property that the T\u00admeaning of any source term can \nalways be recovered from its K-meaning, i.e., that the CPS-translation re\u00adally captures all the subtleties \nof the monadic one. The proof of this property is more complicated than might be expected: in particular, \nan attempt to prove it by induction on the term structure alone will not work. To get a feeling for what \ngoes wrong, consider the un\u00adtyped variants of the translations with T as simply the identity monad (so \nin particular, the p(.) and [.] oper\u00adations have no effect). Now let U be any atomic value, and consider \nthe term Then [~, = E = U (remember that we have full /3 in our met alanguage, even though [.]~ is nominally \na CBV translation), but since [.]K still specifies a CBV CPS transformation, [~K (Az. Z) # U, and in \nfact there is no functional way to extract U from [~ ~. More abstractly, the problem is that we have \nactu\u00adally introduced an effect (nontermination) in the source language without a corresponding modification \nof the monadic structure to encompass partiality. To rule out such surprises, we need to make explicit \nuse of the type structure. Specifically, for any source type a, we isolate a set of T-compatible CPS \nvalues V. ~ [CY]K and computa\u00adtions C. G K[a]K, defined as follows: (Where qVa is the restriction of \nq to V*; the equation in Ca means that the left-hand side is defined and equal to the right-hand side). \nPart of the result we are aiming for states that the K-meanings of all object-language values and expressions \nare in fact T-compatible in this sense. The motivation for all the specific conditions is fairly technical, \nbut we can try to give some intuition. Most importantly, if t c C@then k* (tf) = k ([AC. c* (tq~e)]f) \n= k (f (tqp)ti)) = (k o f)* (tq pe)= t (k o f) and hence in particular tk=k (tqpa) = k (t(q Oidva)) =t(k \noq oidva)= t(koidva)=tklva (i.e., a Ca-term t only invokes its continuation with a Ve-term, so that \nif k and k agree on V. then tk= t k ). The first condition for functions and the one for TCY ensure that \nlatent computations involving only V-terms (in particular, arguments of continuations) are well-behaved \nwhen activated; note that the translation of M(E) can be written as ~(E)]K = M. [E JK (Am. [At. c* m]k) \n Finally, the second condition for functions expands to which states that a well-behaved function m can\u00adnot \nitself depend on more information about its argu\u00adment n than what is preserved by conversion back to \nT-translated types. It is easy to check by induction on types that 3 Monadic Reflection from Composable \nContinuations (so in particular if w = da (4O w) then w c V~). But not every element of Va is of this \nform. For example, let T again be the identity monad and consider the source values Their T-meanings \nare equal, but their K-meanings are not, so only one of the latter can be in the image of ~. For a substitution \nu, let us write ill{a} (to avoid yet another overloading of brackets) for the capture\u00adavoiding application \nof u to a meta-language term M, and Ll{a o d} for (Af{cr}){d}. We can then state a key result relating \nCPS and monadic style. Theorem -Let zl:al, . . . . xn:cY~ k E : /3, and let u be a substitution assigning \na V~t -term to eachxi. Then and [aT{JJ@ 0 ~} = [J%{m}(v 0%) (where +fi is the substitution mapping xi \nto tia,xi for l~i <n). The proof is by somewhat tedious structural induction on E (Meyer and Wand s shortcut \nof only analyzing SK\u00ad combinators does not appear as useful in the general case). As a direct consequence, \nwe get: In particular, if E is closed of base type (so @@is the identity), we have the simple equality \n[17JT = [E] ~ q. More generally, using the above and the first half of the theorem, we get a monadic \ncongruence result: k [E]. = [ qK{&#38;} (~ d fl) For example, in the case of the partiality monad [16], \nTCY = a u {1}, with k as the strict extension of k (i.e., k a= ka for ac a; k L = L), werecover the usual \nrestriction [25] that the continuation be strict to get a congruence; the monadic characterization generalizes \nthis requirement to other computational effects. Finally, we can check explicitly that the reflection \nprinciple is satisfied when all free variables denote V\u00ad terms: [P(CEI)]K = Ak. [[El]~ k* = ~k. k ([-% \nv) = [EL and Armed with a proof that the continuation-passing characterization of monadic reflection \nand reification faithfully represents the original definitions, we can now return to the embedding result. \n The analysis in the previous section applies to an ar\u00adbitrary monad T. But let us now make the natural \nassumption that the met a-language monad functions q and * can actually be defined in the pure (i.e., \neffect\u00adfree) functional sublanguage of our object language. In other words, the definition of the monad \nmust be suf\u00adficiently algorithmic that we can write a source pro\u00ad gram in monadic style in the first \nplace! If this is the case, we say that the monad T is expressible in our lan\u00ad guage. As we have seen, \nwe can express all monadic effects in CPS instead of in monadic style. A priori, this does not leave \nus not much better off, however: to reach the non-standard CPS terms used to interpret p(.) and [.1 for \nany particular monad T, we still seem to need a T-specific translation phase (performed either manu\u00adally, \nor by compilation, interpret atim, partial walua\u00adtion, or some other automated technique). But given \nobject-language terms for q and *, it turns out that we can represent all the required CPS terms in direct \nstyle extended with two fixed operators for manipulat\u00ading the continuation aa a composable function. \nThus every expressible monad can be simulated by a single, universal effect which could be added to our \nobject language once and for all. Specifically, we extend the source language of the CPS translation \nwith operators shift and reset, defined as fol\u00ad lows: [SE]K = AK. [E]K (Af. f[Aw. AK . K (Rv)](Az.$)) \nU+WL = ~~~([ 5L (~~.~)) shift captures (and erases) the evaluation context up to the nearest dynamically \nenclosing reset (every program is run with an implicit all-enclosing reset), and passes this context \nto its argument as an ordinary function. For example: 1 + #(2 X S(Ak. k(k 10))) = l+letk= ~v.2xvink(k \n10) = 41 (For our purposes, reset coincides wit h Felleisen s prompt [6], whose #-notation we have adopted \nhere; but shift differs from prom pt s original companion cent rol (or ~) in that the continuation R \nis not given control over # in the definition of S. ) For more details on shift/reset and their relation \nto other notions of composable contin\u00ad uations, see [3, 4, 17, 33]. As with the monadic [.], the operation \n#. would typically be provided as a function on thunks rather than aa a special form. By our assumption \nthat the meta-language q can be included in the object language as a pure function of type a -TCY, we \nhave [q]~ = ~k.k(h.~~.~(qa)) Similarly, extension is expressible aa a function of type (a - T@) -Ta \n-T~ that preserves purity : [f*lK = M. k(k. k. K($O* a)) if [H ~ = Ak. k(Aa. AK. /c(pa)) Now, in the \nCPS definition of [E] we want to evaluate E with a continuation q, and only then propagate the result \nto the surrounding evaluation context. This is in fact almost what #, does we only need to add the q: \nlI#(~@L = k. /c([qE]K (Xr. z)) = k K ([q]K (~f. [E]K (~a. f a (~~. z)))) = AK. K([~K (Av. [~a. hc. %(qa)]v(h. \nz))) = AK. /c([qK (h. (Az. z)(qv))) = hc./C([lq Kq) = [[El]K Conversely, for p(E) we need to replace \nthe current continuation with its extended version, which again can be directly expressed using S: [S(/M. \nk E)]K = k. [~k. k E]K (~f. f (h. h . /C (K?J))(~Z. z)) = AK. [~k. [k E] K](kJ. hC ./(KV))(~Z~Z. c) = \nAK. [M. [k*]K (Ag. [E]x (h. ga (~c. z)))] (~V.AK . K (KtJ)) = ht. [~K (h [h. AK . K (K* W)] U(~Z. Z)) \n= k, [qK (Au. (Az. Z)(K* a)) = AK. [~K K = [P(-E)L (where k ~ FV(E)). This means that for any express\u00adible \nq and *, we can define [E] and p(E) in terms of the composable-continuation primitives: [El = #(qE) P(E) \n~ S(M. k* E) So if we only include shift and reset in our programming language, we can write all monadic \nprograms in direct style. 4 Composable Continuations from Storable Continuations In the final step of \nour construction, we will see that shift and reset can themselves be defined in terms of non\u00adcomposable \ncontinuations and a single storage cell. The trick is to view the CPS translation with continuation\u00adcomposing \ndefinitions of shift and reset as a direct\u00adstyle specification of a language (with K as just another \nhigher-order function), and obtain from it a proper con\u00adtinuation semantics using a new meta-continuation \n-y, as detailed in [3]. The result is displayed in Figure 1. (Here K is the usual call/cc-operator which \ninvokes its argument on the current continuation represented as an escaping func\u00adtion, aa seen by the \ndiscarded K .) Note in particular how the nested application K (K v) in the definition of S is sequentialized \ninto the usual J7 . K v (~w. IC wy ); likewise, the outer K in [#E]K is put onto the meta\u00adcontinuation. \nOn the other hand, all the underlined ~ s can actually be q-reduced away, so the metacontinua\u00adtion only \nreally comes into play in shift and reset. The meaning of a complete program is now $[qp,nit (Az. Ay. \n-y z) y$n~~ where Yinit is the usual top-level continuation, typically simply the identity function. \nFirst, let us note that given K, #, and the simpler operator A ( abort ) with denotation 2[AE]P = k. \n~~. c$[qp(h. kf . +V)~ [so AE is equivalent to S(M. E), where d @ IT (E)], we can express S as SE 2 \nK(Ak. A(E(Az. #(kz)))) (informally, the A erases the context once it is captured as k; and by wrapping \na reset around k z, we ensure that only the identity continuation gets discarded when k is invoked). \nThus, we only need to define A and #. (That X, A, and # together suffice for defining all pure CPS terms \nin a domain-theoretic setting was already noted by Sitaram and Felleisen [2fl). The second, key observation \nis that except for the definitions of A and # the meta-co ntinuation is threaded through the meta-continuation \nsemantics ex\u00ad actly like the global store in a Scheme-like language! This means that we we can simply \ndesignate a single, updatable location to hold 7 (represented as a procedure that ignores both the continuation \nand the metacontin\u00aduation passed to it), and only access it in A and #. Specifically, in a language with \ncontinuations and state, we have operations (where u maps locations to values; &#38;k is the location \nassigned to mk; mk := E evaluates E, stores the value, and returns (); and !mk returns the current contents \nof the cell without changing it). It is then easy to check that the following definitions give terms \nwith the right denotations: AE % let v=E in !mkv [= (Av. !mk V)E] #E % K(Jk.let m = !mk in (mk := (A~. \n(mk := rn; kT)); A.E)) (where let and ; are the usual abbreviations). Note in particular that since k \nis an escaping function, the A-abstraction stored into mk in #E does denote a pro\u00adcedure that when invoked \nuses neither its continuation nor the current cent ents of m k. We also need to ini\u00adtialize m k to the \ninitial continuation; the easiest way to do this is to simply wrap a reset around any top-level expression \nto be evaluated. This completes our embedding of any expressible monadic structure into a language with \nescapes and state, a somewhat surprising result given the deceptively general-appearing monad laws. It \nshould be stressed again, though, that the construction only applies to monads whose definitions can \nbe captured as functional programs in the first place: more esoteric effects like probabilistic computations \ndefy such a simple decom\u00adposition. Incidentally, the above definitions of shift and reset in terms of \ncall/cc and and state could well have practical applications unrelated to monads. For example, Lawall \nand Danvy are investigating applications of composable continuations for continuation-based partial evaluation \n[12]; preliminary results indicate that using the embed\u00added shift/reset instead of an explicit CPS transforma\u00adtion \nstep can give significant improvements in time and in space, when run under an efficient implementation \nof call/cc [9]. 5 Implementation anti Examples In this section we transcribe the abstract construction \npresented so far into runnable code. To emphasize the typing issues involved, we use the New Jersey dialect \nof Standard ML [1] as our concrete language, but the oper\u00ad ational content should translate straightforwardly \ninto Scheme as well (though instantiation to different mon\u00ad ads may be less convenient without a module \nfacility). We also give several examples; the reader may want to compare these with Wadler s presentation \n[32]. 5.1 Composable cent inuat ions In SML/NJ, first-class continuations have a type dis\u00ad tinct from \nthe type of general procedures. Let us there\u00ad fore first set up a representation of such continuations \nas Scheme-style non-returning functions (this is not es\u00ad sential but makes for a more direct correspondence \nwith the semantics in section 4): signature ESCAPE = sig type void val coerce : void -> >a val escape \n: (( la -> void) -> la) -> la end; structure Escape : ESCAPE = struct datatype void = VOID of void fun \ncoerce (VOID v) = coerce v fun escape f $= callcc (fn k=>f (fn x=>throw k x)) end; For example, we can \nwrite let open Escape in 3 + escape (fn k=>6 + coerce (k 1) ) end; (*val it =4:int *) (The use of void \nand coerce instead of an unconstrained type variable in escape permits storage of continuations in ref-cells \nwhile staying within the ML type system [5].) Now we can define a composable-continuations facil\u00ad ity, \nparametrized by the type of final answers: signature COETROL = sig type ans val reset : (unit -> ans) \n-> ans val shift : (( la -> ans) -> ans) -> la end; functor Control (type ans) : COHTROL = struct open \nEscape exception HissingReset val rek : (ans -> void) ref = ref (fn -=>raise Hiss ingReset ) fun abort \nx = coerce ( !mk x) type ans . ens fun reset t = escape (fn k=>let val m = !mk in mk := (fn r=>(mk := \nm; k r)); abort (t () ) end) fun shift h = escape (fn k=>abort (h (fn v=> reset (fn ()=>coerce (k v))))) \nend; For example, functor Represent (H : HOIAD) : RHOMAD = structure IntCtrl = Control (type ans = int) \n; let open IntCtrl in i + reset (fn ()=>2 * shift (fn k=>k (k 10))) end; (eval it =41 :int*) 5.2 Monadic \nreflection Building on the composable-continuations package, we implement the construction of Section \n3. The signature of a monad is simple: signature HOIAD = sig type 9a t val unit : ~a-> ~at val e~t : \n(Ja-> ~bt) -> ,at -> }b t end; (the monad laws have to be verified manually, though). Our goal is to \ndefine reflection and reification operations for an arbitrary monad H to get signature RHOHAD = aig etructure \nH : HOIAD val reflect : la H.t -> la val reify : (unit -> a) -> a U.t end; Before we can proceed, however, \nthere is one twist: our construction needs a universal type (the o of section 2.2): eignature UIIIVERSAL \n= sig type u val to-u : ~a-> u Val fr~~-u : u -> )~ end; such that f rom_u o to_u is the identity for \nany Ba. (Note that ensuring that the instances of ado in fact match up dynamically now becomes our responsibility; \nthe ML system is free to dump core on attempts to ex\u00ad ecute code like 1 + f rem-u (to-u f oo ) ). This \nsig\u00ad nature can be implemented in SML/NJ as etructure Univereal : UIIVERSAL = struct type u = System \n.Unsaf e object val to-u = System .Uneafe. cast val from.u = System .Unsaf e. cast end; where cast behaves \nas an identity function, but has the general type a -> b.2 We can now complete the construct ion: 2 \nEven ~it,hout ~ fivem~ type, we still get a usable definition if we pick a suitable concrete type of \nanswers. Then reification becomes restricted to computations of that type, but reflection remains polymorphic; \nin many cases, e.g., in an interpreter where all evaluations happen at a single type of denotable values, \nthis is suilicient. struct structure C = Control (type ans = Universal .u H .t ) structure 1! = H fun \nreflect m = C. shift (f n k=>Pl. ext k m) fun reify t = H. ext (U unit o Universal from-u) (C. reset \n(fn ()=>H unit (Universal .to-u (t () )))) end; (Recall that operationally to_u and from-u are iden\u00ad \ntities, and so is F!, ext H. unit. Also, it is worth stress\u00ad ing that only the implementation of Represent \nneeds a typing loophole; its interface remains ML-typable and safe.) 5.3 Example: exceptions The example \nfrom the introduction becomes, in concrete synt ax: structure Error? lonad = struct datat ype ~a t= SUC \nof ~a I ERR of etring val unit = SUC fun ext f (SUCa) =f a I ext f (ERR s) = (ERR s) end; structure \nErrorRep = Represent (ErrorHonad); local open ErrorMonad ErrorRep in fun myraise e = reflect (ERR e) \nfun myhendle t h = case reify t of SUC a => a lERRs=>hs end; (* val myraise = fn : string -> la val \nmyhandle = fn : (unit -> a) -> (string -> ~a) -> ~a*) fun showt= myhandle (fn ( )=> OK: -makestring \n(t () :int)) (fn s=> Error: -s) ; (e val show = fn : (unit -> int) -> etring *) shou (fn ()=>1 + 2); \n(* val it = OK: 3 : string *) show (fn ()=>1 + myraise oops ) ; (* val it = Error: oops : string *) \n 5.4 Example: state The state monad with Wadler s counting operations: functor StateHonad (type state) \n: HOEAD = struct type a t = state -> a * state fun unit a = fn sO=>(a, sO) fun ext f m=fn sO=>let val \n(a,sl) =msO in f a81end end; structure Int St at eltep = Represent (Stat eHonad (type state = int) \n) ; fun tick () = IntStateRep. ref lect (f n s=> (() ,s+1) ) fun fetch () = IntStateRep. ref lect (f \nn s=> (s ,s) ) fun store n = IntStateRep .reflect (fn s=>(() ,n)); (* val tick = fn : unit -> unit val \nfetch = fn : unit -> ?. <Parameter> state (*= int*) val store = fn : int -> unit *) 453 81 (IntStateRep. \nreif y (fn ()=> (store 5; tick () ; 2 * fetch ())) O); (* val it =12 :int *) 5.5 Example: nondeterminism \nA nondeterministic computation can be represented as a list of answers: structure ListHonad : HOEAD = \nst ruct type at= alist fun unit x = [x] fun ext f [1 =[1 lextf(h: :t)=fh Qextft end;  structure ListRep \n= Represent (ListHonad) ; local open ListRep in fun amb (x)y) = reflect (reify (fn ()=>x) @ reify (fn \n()=>y) ) fun fail () = reflect [] end; (*val ~b =fn :~la*~ia-> ~ia val fail = fn : unit -> ~ia *) LietRep. \nreif y (fn ()=>let val x = amb (3,4) * amb (5 ,7) in if x>=20then x else fail () end) ; (* val it = [21 \n,20,28] : int Listk!onad.t *) More generally, we get Haskell-style list comprehensions for free , in \nthat the schema [Elz14--El; . . ..zn+ En] (where each Z, maybe used in Ei+l, . . . . En and in E) can \nbe expressed directly as [let xl = p(E1) in ... let z. = p(li?n) in E] For example, we can compute the \ncartesian product of two lists aa let open ListRep in reify (fn ()=>let val x = reflect [3, 4, 5] ; val \ny = reflect [ foo , bar ] in (x, y) end) end; (* val it = [(3,11 foot0) , (3, bar $) , (4, foo ) , (4, \nbar ) , (5, foo ) , (5 , bar )] : (int \" string) list *) Of course, this is probably not the most efficient \nway of implementing list comprehensions in ML. As observed by Wadler [31], however, list comprehensions \ncan be generalized to arbitrary monads; similarly we get gen\u00aderal monad comprehensions in ML simply by \nsupplying the appropriate [.] and p(,) operations. 5.6 Example: continuations Finally, let us consider \nthe continuation monad (for an arbitrary but fixed answer type): functor ContFlonad (type answer) : HOEAD \n= struct type a t = ( a -> answer) -> answer fun unit x =fn k=>k x fun ext f t =fn k=>t (fn v=>f vk) \nend; structure ContRep = Represent (ContHonad (type answer = etring) ) ; local open ContRep in fun myescape \nh = reflect (fn c=>let fun k a = reflect (fn c ~=>c a) in reify (fn ()=>h k) c end) fun myshift h = reflect \n(fn c=>let fun k a = reflect (fn c>=>c~ (c a)) in reify (f n ( )=>h k) (fn x=>x) end) fun myreset t = \nreflect (fn c=>c (reify t (fn x=>x) ) ) end; (* val myescape = fn : ((~ia -> ~lb) -> ~la) -> JIa val \nmyshift = fn : (( la -> string) -> string) -> la val myreset = fn : (unit -> string) -> string *) ContRep. \nreif y (fn ( )=>3 + myeecape (f n k=>6 + k 1)) makestring; (* val it = 4 : string *) ContRep. reify (fn \n()=> a myreset (fn ()=> b -myshift (fn k=> k (k C )))) (fn x=>x) (* val it = abbe : string *) 6 Related \nWork The study of relationships between direct and contin\u00aduation semantics haa a long history. Early \ninvestigw tions [22, 25, 30] were set in a domain-theoretic frame\u00adwork where the main difficulties concerned \nreflexive do\u00admains; as a result, these methods and results seem closely tied to specific semantic models. \nOn the other hand, Meyer and Wand 8 more abstract approach ap\u00adplies to all models of (typed) A-calculi, \nbut does not encompass computational effect8 not even nontermi\u00adnation. The present extension of Meyer \nand Wand s retraction theorem to monadic effects should partially bridge this gap, and add another facet \nto our under\u00adstanding of CPS. It seems natural to expect other re\u00adsults about continuation-passing vs. \ndirect-style to 8cale up to monadic style as well; in particular, it should be possible to extend the \nresults presented here to lan\u00adguages with reflexive types, perhaps by adapting one of the semantics-based \nproofs mentioned above. A possible equivalence between monads and CPS was conjectured by Danvy and Filinski \n[3] and partially fleshed out by Wadler [32], but even the latter was quite informal since the result \ngeneralizes Meyer and Wand s, one would expect the proof to be at least as complicated. Another glimmer \nof the correspondence can be seen in Sabry and Felleisen s result [24] that l%equivalence of CPS terms \ncoincides with direct-style equivalence in Moggi s computational A-calculus [14], which captures exactly \nthe equivalences that hold in the presence of arbitrary monadic effects. Peyton Jones and Wadler [18] \nprobe the relationship between monads and CPS further, and Wadler [33] analyzes composable con\u00adtinuations \nfrom a monadic perspective, but in both cases the restriction to Hindley-Milner typability obscures the \ndeeper connections. Composable continuations have also been studied by a number of researchers [10, 8, \n3]. Many of these constructs depend on explicit support from the com\u00adpiler or runtime system, such as \nthe ability to mark or splice together delimited stack segments. However, an encoding in standard Scheme \nof one variant was de\u00advised by Sitaram and Felleisen [26]. The embedding is fairly complex, relying on \ndynamically-allocated, muta\u00adble data structures, eq?-tests, and with no direct con\u00adnection to a formal \nsemantics of the constructs. Yet an\u00adother Scheme-implementable notion of partial continu\u00adations was proposed \nby Queinnec and Serpette [20]; the code required is perhaps even more intricate. (To be fair, both of \nthese constructs are apparently more gen\u00aderal than shift/reset, though the practical utility of this \nadditional power remains to be seen.) The much simpler construction presented in this paper uses only \na single cell holding a continuation, and is directly derived from the denotational definition of shift \nand reset. Finally, recent work by Riecke [23] on effect delimiters may be somehow related to the present \npaper, as they share several concepts and techniques (specifically, mon\u00adads, prompts, and retractions). \nOn closer inspection, though, the similarities become much less apparent (for example, Riecke only considers \na few specific monads and attaches no special significance to CPS); cert airily the specific goals of \nthe two papers are quite different, and the results obtained seem incomparable. Still, there might be \nsome deeper connections to uncover, and the subject is probably worth exploring further. Conclusions \n By exploiting the correspondence between monadic and continuation-passing styles, we can embed any definable \nmonad into a language with a (composable continua\u00adtions construct, Further, such a construct can itself \nbe decomposed into ordinary first-class continuations and a storage cell. Thus, it is possible in principle \nto express any definable monadic effect as a combination of con\u00adtrol and state. In practice, of course, \nmany such effects including, obviously, call/cc and ref-cells themselves can be more naturally expressed \ndirectly, without the detour over composable continuations. However, the construction presented here \nshould still be of some practical use in experiments with, and rapid prototyping of, more complicated \nmonadic structures. The embedding approach does not incur the interpretive overhead of a monadic interpreter \nor the complexity of an explicit source-to-source monadic translation step. And perhaps even more importantly, \nit allows us to re\u00adtain with no extra effort all the conveniences of the orig\u00adinal language, including \npattern-matching, static type\u00adchecking, and module system. The efficiency of the general embedding may \nnot be quite as good as hand\u00adcoded monadic style specialized to a particular monad, especially since \nmany compilers do not attempt to track continuations across storage cells. On the other hand, if effects \nare rare, programs run at full speed without the overhead of explicitly performing the administrative \nmanipulations specified by q and *, such aa tagging and checking return values in the exception monad. \nThe embedding result is also a strong argument for inclusion of first-class continuations in practical \neager languages, especially ones like ML that already have mutable cells: providing call/cc does not \nsimply add yet another monadic effect it completes the language to all such effects! Moreover, a sophisticated \nmodule sys\u00adtem like SML S lets us expose as little or as much of this underlying raw power as we need: \nby picking the appropriate monadic structure, we can introduce effects ranging from simple exceptions \nto full composable con\u00adtinuations. But surely there is more to functional programming with escapes and \nstate than monadic effects. After all, monads provide only the lowest-level framework for sequencing \ncomputations; in practical programs, we of\u00adten need tools for expressing higher-level, application\u00adoriented \nabstractions. A strict monad-based partition\u00ading of effects may be adequate in many cases, but mon\u00adads \ncannot and should not take place of a proper module facility. In fact, it might be that the syntactic \nnoise due to writing everything in monadic (or any other) style makes it harder to recognize and exploit \norga\u00adnizational units that do not conveniently fit into the monadic mold (for example, concurrency packages \nlike Reppy s CML [21], or imperative unification using mutable data structures). The present work also \nsheds some light on the prob\u00adlem of integrating individual monads to express com\u00adposite effects. Briefly, \nthe complication is that a monad by itself is a closed package that contains too little infor\u00admation: \nwe need instead to express the monadic data as an increment to be layered on top of other possi\u00adble effects. \nHow to do this uniformly is still not quite clear; Moggi s monad constructors [15] and Steele s pseudomonades \n[29] are two possible techniques. In the composable-continuations characterization of monads, monad combination \nseems to correspond to also letting the target language of the defining translations con\u00adtain monadic \neffects, leading to the hierarchy of con\u00adtrol operators and the associated metan-continuation\u00adpassing \nstyle introduced in [3] and further investigated by Murthy [17]. However, such approaches all lead to \nan inherently vertical or {hierarchical notion of monad composi-[5] tion, because in general we must \nanswer such questions aa should backtracking undo 1/0? or should excep\u00adtions undo state mutation? (and \nperhaps also, is this really the right way to think about supposedly func\u00adtional programs? ) Yet many \nmonadic effects can in [6]fact be naturally combined in a horizontal or inde\u00adpendent way, such as different \npieces of state, or stor\u00adage and 1/0; both the monadic and the (generalized) CPS formulation seem awkward \nin such cases, but indi\u00advidually mutable cells capture this situation directly. Much recent work on monads \nin purely functional [7] languages vs. control and state in an imperative func\u00adtional setting seems \nlargely disjoint. Perhaps the con\u00adnections outlined in this paper can lead to some cross\u00adfertilization \nand help avoid duplication of effort. For example, pure functional programmers might benefit [8] from \nwork on organizing and reasoning about first-class continuations and storage cells in the imperative \nset\u00adting (e.g., [7]); noting that these are monadic effects is clearly not sufficient to actually reason \nabout them. Conversely, results about algebraic properties of partic\u00adular monads (e.g., [11]) could be \nuseful for recognizing [9]and exploiting patterns of continuation and state usage in eager languages. \nAcknowledgments I want to thank John Reynolds for support, and Olivier [10]Danvy, Matthiaa Felleisen, \nJulia Lawall, Greg Morrisett, Amr Sabry, Phil Wadler, and the reviewers for their helpful comments on \nvarious drafts of this paper. References [11] [1] Andrew W. Appel and David B. MacQueen. Stan\u00addard ML \nof New Jersey. In Third International Symposium on Programming Language Implemen\u00adtation and Logic Programming, \nnumber 528 in Lec\u00adture Notes in Computer Science, pages 1 13, Pas\u00adsau, Germany, August 1991. [12] [2] \nWilliam Clinger and Jonathan Rees. Revised4 re\u00adport on the algorithmic language Scheme. Lisp Pointers, \n4(3):1-55, July 1991. [13] [3] Olivier Danvy and Andrzej Filinski. Abstracting control. In Proceedings \nof the 1990 ACM Confere\u00adnce on Lisp and Functional Programming, pages 151 160, Nice, France, June 1990. \n [4] Olivier Danvy and Andrzej Filinski. Representing [14] control: A study of the CPS transformation. \nMath\u00adematical Structures in Computer Science, 2(4) :361 391, December 1992. Bruce F. Duba, Robert Harper, \nand David Mac-Queen. Typing first-class continuations in ML, In Proceedings of the Eighteenth Annual \nACM Sym\u00adposium on Principles of Programming Languages, pages 163-173, Orlando, Florida, January 1991. \nMatthiaa Felleisen. The theory and practice of first\u00adclass prompts. In Proceedings of the Fifteenth An\u00ad \nnual ACM Symposium on Principles of Program\u00ad ming Languages, pages 180 190, San Diego, Cali\u00ad fornia, \nJanuary 1988. Matthiaa Felleisen and Robert Hieb. The revised report on the synt attic theories of sequential \ncon\u00adtrol and state. Theoretical Computer Science, 103(2):235-271, September 1992. Matthias Felleisen, \nMitchell Wand, Daniel P. Fried\u00adman, and Bruce F. Dubs. Abstract continuations: A mathematical semantics \nfor handling full func\u00adtional jumps. In Proceedings of the 1988 ACM Conference on Lisp and Functional \nProgrammingj pages 52-62, Snowbird, Utah, July 1988. Robert Hieb, R. Kent Dybvig, and Carl Brugge\u00adman. \nRepresenting control in the presence of first\u00adclass continuations. In Proceedings of the ACM SIGPLAN \n90 Conference on Programming Lan\u00adguages Design and Implementation, pages 66 77, White Plains, New York, \nJune 1990. Gregory F. Johnson and Dominic Duggan. Stores and part ial cent inuat ions as first-class \nobjects in a language and its environment. In Proceedings of the Fifteenth Annual ACM Symposium on Prin\u00adciples \nof Programming Languages, pages 158 168, San Diego, California, January 1988. David J. King and Philip \nWadler. Combining monads. In J. Launchbury and P. M. Sansom, editors, Functional Programming, Glasgow \n1992 , pages 134 143, Ayr, Scotland, 1993. Springer-Verlag. Julia L. Lawall and Olivier Danvy. Continuation\u00adbased \npartial evaluation. Indiana University and Aarhus University. Personal communication, Octo\u00adber 1993. \nAlbert R. Meyer and Mitchell Wand. Continua\u00adtion semantics in typed lambda-calculi (summary). In Rohit \nParikh, editor, Logics of Programs Pro\u00adceedings, number 193 in Lecture Notes in Computer Science, pages \n219-224, Brooklyn, June 1985. Eugenio Moggi. Computational lambda-calculus and monads. In Proceedings \nof the Fourth Annual Symposium on Logic in Computer Science, pages 14-23, Pacific Grove, California, \nJune 1989. IEEE. [15] Eugenio Moggi. An abstract view of program\u00adming languages. Technical Report ECS-LFCS-90\u00ad113, \nLaboratory for Foundations of Computer Sci\u00adence, University of Edinburgh, Edinburgh, Scot\u00adland, April \n1990. [16] Eugenio Moggi. Notions of computation and mon\u00adads. Information and Computation, 93(1):55 92, \nJuly 1991. [17] Chetan R. Murthy. Control operators, hierarchies, and pseud-classical type systems: A-translation \nat work. In Proceedings of the ACM SIGPLAN Work\u00adshop on Continuations, pages 49-71, San Fran\u00adcisco, California, \nJune 1992. (Technical Report No. STAN-CS-92-1426, Department of Computer Sci\u00adence, Stanford University). \n[18] Simon L. Peyton Jones and Philip Wadler. Imper\u00adative functional programming. In Proceedings of the \nTwentieth Annual ACM Symposium on Prin\u00adciples of Programming Languages, pages 71-84, Charleston, South \nCarolina, January 1993. [19] Gordon D. Plotkin. Call-by-name, call-by-value and the A-calculus. Theoretical \nComputer Science, 1(2):125-159, December 1975. [20] Christian Queinnec and Bernard Serpette. A dy\u00adnamic \nextent control operator for partial contin\u00aduations. In Proceedings of the Eighteenth Annual ACM Symposium \non Principles of Progmmming Languages, pages 174 184, Orlando, Florida, Jan\u00aduary 1991. [21] John H. Reppy. \nCML: A higher-order concurrent language. In Proceedings of the ACM SIGPLAN 91 Conference on Programming \nLanguage De\u00adsign and Implementation, pages 293 305, Toronto, Canada, June 1991. [22] John C. Reynolds, \nOn the relation between direct and continuation semantics. In Jacques Loeckx, ed\u00aditor, 2nd Colloquium \non Automata, Languages and Programming, number 14 in Lecture Notes in Com\u00adputer Science, pages 141-156, \nSaarbrucken, West Germany, July 1974. [23] Jon G. Riecke. Delimiting the scope of effects. In Functional \nProgramming Languages and Com\u00adputer Architecture 1993, pages 146 155, Copen\u00adhagen, Denmark, June 1993. \nACM Press. [24] Amr Sabry and Matthias Felleisen. Reasoning about programs in continuation-passing style. \nIn Proceedings of the 1992 ACM Conference on Lisp and Functional Programming, pages 288 298, San Francisco, \nCalifornia, June 1992. Revised version to appear in Lisp and Symbolic Computation. [25] Ravi Sethi and \nAdrian Tang. Constructing call-by\u00advalue continuation semantics. Journal of the ACM, 27(3):580-597, July \n1980. [26] Dorai Sitaram and Matthias Felleisen. Control de\u00adlimiters and their hierarchies. Lisp and \nSymbolic Computation, 3(1):67-99, January 1990. [27] Dorai Sitaram and Matthias Felleisen. Reasoning \nwith continuations II: Full abstraction for models of control. In Proceedings of the 1990A CM Confer\u00adence \non Lisp and Functional Progmmming, pages 161-175, Nice, France, June 1990. [28] Brian C. Smith. Rejection \nand Semantics in a Pro\u00adcedural Language. PhD thesis, Massachusetts In\u00adstitute of Technology, Cambridge, \nMassachusetts, January 1982. MIT-LCS-TR-272. [29] Guy L. Steele, Jr. Building interpreters by compos\u00ading \nmonads. In Proceedings of the Twenty-First An\u00adnual ACM Symposium on Pn nciples of Pwgram\u00adming Languages, \nPortland, Oregon, January 1994. (To appear). [30] Joseph E. Stoy. The congruence of two program\u00adming \nlanguage definitions. Theoretical Computer Science, 13(2):151 174, February 1981. [31] Philip Wadler. \nComprehending monads. Mathe\u00admatical Structures in Computer Science, 2(4):461\u00ad493, December 1992. (An \nearlier version appeared in Proceedings of the 1990 ACM Confewnce on Lisp and Functional Programming). \n[32] Philip Wadler. The essence of functional pro\u00adgramming (invited talk). In Proceedings of the Nineteenth \nAnnual ACM Symposium on Princi\u00adples of Programming Languages, pages 1 14, Al\u00adbuquerque, New Mexico, January \n1992. [33] Philip Wadler. Monads and composable continua\u00adtions. Lisp and Symbolic Computation, 1994. \n(To appear). [34] Mitchell Wand and Daniel P. Friedman. The mys\u00adtery of the tower revealed: A non-reflective \ndescrip\u00adtion of the reflective tower. Lisp and Symbolic Com\u00adputation, l(l), May 1988.  \n\t\t\t", "proc_id": "174675", "abstract": "<p>We show that any monad whose unit and extension operations are expressible as purely functional terms can be embedded in a call-by-value language with &#8220;composable continuations&#8221;. As part of the development, we extend Meyer and Wand's characterization of the relationship between continuation-passing and direct style to one for continuation-passing vs. general &#8220;monadic&#8221; style. We further show that the composable-continuations construct can itself be represented using ordinary, non-composable first-class continuations and a single piece of state. Thus, in the presence of two specific computational effects - storage and escapes - <italic>any</italic> expressible monadic structure (e.g., nondeterminism as represented by the list monad) can be added as a purely definitional extension, without requiring a reinterpretation of the whole language. The paper includes an implementation of the construction (in Standard ML with some New Jersey extensions) and several examples.</p>", "authors": [{"name": "Andrzej Filinski", "author_profile_id": "81100252096", "affiliation": "School of Computer Science, Carnegie Mellon University, Pittsburgh, PA", "person_id": "PP39034562", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/174675.178047", "year": "1994", "article_id": "178047", "conference": "POPL", "title": "Representing monads", "url": "http://dl.acm.org/citation.cfm?id=178047"}