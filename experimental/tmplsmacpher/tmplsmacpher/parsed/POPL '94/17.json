{"article_publication_date": "02-01-1994", "fulltext": "\n Formally Optimal Boxing Fritz Henglein &#38; Jesper Jorgensen DIKU, Department of Computer Science University \nof Copenhagen, Universitetsparken 1 DK-21OO Copenhagen @ Denmark e-mail: henglein@diku.dk &#38; knud@diku.dk \nAbstract An important implementation decision in polymorphically typed functional programming languages \nis whether to rep\u00adresent data in boxed or unboxed form and when to transform them from one representation \nto the other. Using a langnage with explicit representation types and boxing/unboxing ope\u00adrations we \naxiomatize equationally the set of all explicitly boxed versions, called completions, of a given source \npro\u00adgram. In a two-stage process we give some of the equa\u00adtions a rewriting interpretation that captures \neliminating boxing funboxing operations without relying on a specific implementation or even semantics \nof the underlying lan\u00adguage. The resulting reduction systems operate on con\u00ad gruence classes of completions \ndefined by the remaining actuations E, which can be understood as moving box\u00adin g/uiLboxing operations \nalong data flow paths in the source progl am. We call a completion eopt formally optimal if ev\u00ad ery other \ncompletion for the same program (and at the same representation type) reduces to e opt under this two-stage \nre\u00adduction. We show that every source program has formally optimaJ completions, which are unique modulo \nE. This is accom\u00adplished by first polarizing the equations in E and orienting them to obtain two canonical \n(confluent and strongly nor\u00adm dizing) rewriting systems. The completions produced by L,:roY s and poulsen \ns algorithms are generafly not formally optimal in our sense. The rewriting systems have been implemented \nand ap\u00adplied to some simple Standard ML programs. Our results show that the amount of boxing and unboxing \noperations is also in practice substantially reduced in comparison to Leroy s completions. This analysis \nis intended to be inte\u00adgrated into Tofte s region-based implementation of Standard ML currently underway \nat DIK~J. Keywords Representation analysis, polymorphism, type inference. Pern-rbion to copy without \nfee all or part of this material is granted provided thet the copies ere not mede or distributed for \ndirect commercial adventage, the ACM copyright notica and the titfe of the publication and its date appeer, \nand notice is given thet copying is by permission of the Association for Computing Machinery. To copy \notherwise, or to republish, requires a fee endor specific permission. POPL 94-li94, Portfand Oragon,USA \n@ 1994 ACM 0-89791636-0/ 94/001..$3.50 1 Introduction 1.1 Representation analysis Revreseratdion analvsis \nseeks to optimize the run-time rep\u00adresentation of elements of data types in high-level program\u00adming languages. \nA problem specific to polymorphically typed languages such as Standard ML or Haskell is how to represent \nthe actual arguments to polymorphic functions. The polymorphic (generic) parts of arguments to a polymor\u00adphic \nfunction can be of any type and will usuaJly be called with actual arguments of different types. There \nare several possible ways of implementing such polymorphic functions. The predominant one is to ensure \nthat actual arguments are represented uniformly, independent of their actual type, using boxed representations. \nA boxed representation of a data structure is a pointer to some area in memory where the actuaf contents \nof the data structure reside. 1 The point of this representation is that it has the same size for all \ntypes of data structures. By passing only arguments in boxed representation a (truly) polymorphic function \ncan be correctly implemented by a single piece of code since it is guaranteed to nrwer actually inspect \nthe data structure itself. Other operations, however, such as integer addition or a conditional checking \nthe value of a Boolean expression require access to the contents of the data and are penalized by the \nadditional level of indi\u00adrection incurred by boxing, as they first have to unboz the represent ation; \ni.e., dereference the pointer. Furthermore, boxed representations require more space than unboxed rep\u00ad \nresentations thus increasing the space demand ancl garbage collection costs. Parameter passing, on the \nother hand, is generally more efficient for boxed than unboxed data repre\u00adsent ations. Thus there are \ncompeting demands on the repre\u00adsentation of dat a in a program. A boxed representation can, of course, \nbe transformed to an unboxed representation at run-time, and vice versa. These conversions cau contribute \nsubstantially to the run-time cost of a program, however, both in terms of time and space. Boxing anaiysis \nis a special representation analysis that seeks to minimize the need for run-time conversions whilst \nsatisfying the representation demands on all data in a pro\u00adgram. Boxing analysis can be facilitated by \nmaking repre\u00adsentation choices and boxing/unboxing operations in a pro\u00adgram explicit. This amounts to \na translation to a language 1The elements of small data structures such as pointer-sized in\u00adteger representations \nmay be considered simultaneously boxed and unboxed. In the following we shall think of these as two separate \nrep\u00adresentations with associated trivial boxing and unboxing operations. with explicit boxed and unboxed \ntypes and new operations denoting boxing andunboxing operations without, however, changing the underlying \nprogram. We shall call these ex\u00adplicit boxing and unboxing operations (repr-esentation) coer\u00adcions. There \nare, in principle, many different possible trans\u00adlations for the same program corresponding to different \nrep\u00adresentation choices for the data structures in the program and different needs for representation \ncoercions. We shall refer to any one of these translations as a cornpietionof the underlying program. \nThe question then is: which comple\u00adtion should be chosen for a given program? In a naive translation \nevery expression is translated to (a computation of) its boxed representation where operations that need \nto inspect the contents of snch a representation use explicit unboxing operations. The rationale for \nmaking boxing explicit is that some boxing/unboxing operations can be eliminated in the later transformational \nstages of snch a compiler [P JL91], as for example in the Glasgow Haskell Compiler. Other translations \nmay elide some of these boxing and unboxing operations directly; e.g., the type inference based translations \nof Leroy [Ler92] and Poulsen [Pou93]. 1.2 A coercion calculus for boxing Beyond offering yet another \ntranslation we seek to formu\u00ad late and answer the more fundamental qnestions that un\u00ad derlie the very \npurpose of boxing analysis and, more gener\u00adally, similar static analyses: Given two completions for the \nsame program, which of them is better? What does it mean for one completion to be better than another \ncompletion in the first place? Which programs, if any, have opti\u00admal completions; i.e., completions that \nare bet t er than any other for the same program? Can such optimal completions be computed, and how? \nOf course, it doesn t make mnch sense to compare the quality of completions on the basis of their actual \nrun-time cost on a specific computer assuming a specific language implementation. In any scenario where \nwe take the actual semantics of the langnage fully into ac\u00adcouni the answer to the last two questions \nwould be no on recursion-theoretic grounds anyway (assnming the language is universal, of course). If \nwe can pick any one of a collection of completions for a given program it is a fundamental assumption \nthat all com\u00adpletions mnst be coher-enfi i.e., they have the same observa\u00adtional behavior. Our approach \nis to assume that we know nothing eke about the programming language than that any two completions of \nthe same program are coherent. For a paradigmatic functional language we show that coherence can be axiomatized \nby an equational theory; i.e., a theory of equations of the form e =e where e , e are comple\u00adtions of \nthe same program (for a given result representation type). This axiomatization contains the equations \nbox; unbox . L and unbox; box = L, which express that first boxing and then immediately unboxing (or \nthe other way round) a value (boxed value) is observationa.lly indistinguishable from do\u00ading nothing \nat all to the value. We interpret these equations as left-to-right rewriting rules in accordance with \nour expec\u00adtation that performing a pair of coercions is operationally more expensive than doing nothing \nat all. Thk gives us a rewriting system modulo the remaining equational axioms. These remaining equations \nintuitively simply push coer\u00adcions back and forth -e.g., from actual argument to formal parameter in \na function application bnt they do not elim\u00adinate them. The rewriting system gives us a relatively simple \n and coarse notion of quality: if e =+- e then e is bet\u00adter than e , and if e =+-* e for all completions \ne of a given program then e is an optimal completion (modulo the remaining equational axioms mentioned \nabove). Unfor\u00adtunately the resulting notion of rednction is not Church-Rosser; i.e., there are two coherent \ncompletions that have no common reduct and are thns locally optimal. This is due to the fact that a box \n;unbox-redex may only be elimi\u00adnated at the expense of introducing a unbox ;box-redex, and vice versa. \n By prioritizing elimination of unbox; box-redexes over box; unbox or the other way round, however, we \narrive at two formal optimatity criteria for completions. We show that every program has a formally optimal \ncompletion at any given representation type under each of the two priori\u00adtizations. This is accomplished \nby orienting the equations E as left-to-right or right-to-left rewriting rules depending on the polarity \nof the coercions involved. (Any simple-minded orientation of E leads to nonconfluence and nontermination \nof Knuth-Bendix completion. ) The resulting two rewriting systems can be used to compute specific optimal \ncomple\u00adtions. Formulating boxing analysis in the framework of a for\u00admal coercion calculus has the advantage \nthat the results we obtain are extremely general and robust: 1. They apply to any interpretation whatsoever \nof the underlying programming language; e.g., to a call-by\u00advalue, call-by-name, or lazy interpretation \nof our func\u00adtional Iangnage. 2. They can be combined with other optimizations unre\u00adlated to boxing as \nthe calculus makes few assumptions about the underlying language or its implementation technology. 3. \nThey admit talking about optimality relative to an explicit, formally specified criterion. 4. They leave \na great degree of freedom as optimality is accomplished up to a well-defined congruence relation on completions; \nfor example, the notion of optimalit y is not overcommitted by insisting on syntactic unique\u00adness.  \n 1.3 New results The contributions in this paper are: A general framework and robust criterion for the \nqual\u00adity of boxing completions, which accounts for the costs of boxing/unboxing operations, but abstracts \nfrom other langnage properties and implementation con\u00adcerns. Proof of the existence of formally optmml \n(boxing) complets ons and their uniqueness rnodulo an equa\u00adtional theory for moving boxing and nnboxing \nope\u00ad rations along data flow paths. Our notion of formal optim.slity is independent of any specific properties \nof the underlying programming language. A rewriting-based algorithm for computing formally optim~ completions, \nwhich are uniformly better than those described in [PJL91, Ler92, Pou93] in our (for\u00admal) sense. An \nexperimental implementation of the algorithm and test results for a call-by-value language that support \nempirically that our completions are also better in practice than those reported in the literature previ\u00adously. \nThe boxing algorithm and the quality of its output is ap\u00ad parently the most immediate and practically \nmost relevant contribution of our work. It could certainly have been pre\u00ad sented, together with the empirical \nresults, independently of the coercion calculus and its formal optimality criteria. But this would have \nbeen unsatisfactory in several respects: With a proliferation of different algorithms for the same problem \nthere is a clear need for a systematic comparison between them. Using exclusively empiricaJ data is unsatis\u00adfactory \nfor this purpose as they can only report on system perform ante where the interaction of boxing with \nother sys\u00adtem properties changes frequently and is difficult to quan\u00adtify. Our optimality criterion is \nsimple, natural and facili\u00adtates a completely formal comparison of boxing completions; furthermore, it \nmakes the basis of comparison explicit and thus, if nothing else, facilitates a substantive criticism \nof its rationale. Our boxing algorithm has been developed from a system\u00adatic analysis of the coercion \ncalculus and its optimality cri\u00adterion. Without the general framework it would doubtlessly appear ad \n~OC. It would also be impossible to say anything about its robustness and global properties; for example, \nthe algorithm produces the same completion when given ei\u00ad ther one of the completions of [P JL91, Ler92, \nPou93] as its initiaJ input. This follows from the coherence of all com\u00adpletions and the Church-Rosser \nand strong normalization properties of the rewriting systems.  1.4 Notation and terminology Since most \nof the notation in this paper is fairly standard, we will only describe the notation that is not. The \nnotation [Z +di]tmeans substitute ti for the i th occurrence of z in t ,for some fixed ordering of occurrences \nof zin -t. We will also use the term [z wfi]tasa pattern. If a term t matches this pattern then the part \nof t that matches the i th occurrence of z in t will have to match ti. Ordinary substitution [z +xt ]t \nwill SJSObe used as a pattern in a similar way, except that then all the occurrences of z will have to \nmat ch the same expression. We use the notation ~ for tuples, and i!i selects the i th element of ~. \nIf E is a tuple of variables and ~ a tuple of terms of the same length then [Tfi-+atsubstitution is parallel \nof the variables iu z for the corresponding elements of ~. Free indices are always assumed universality \nquantified, i.e. if we write z,+ this means for all z ~i=tiand the range of z is assumed given by the \ncent ext. We use ~ for syntactic equality to distinguish it from provable equality =. We write A 1-e \n=+R e to indicate that e rewrites to e modulo the equational theory axiomatized by A. The rewrit i rig \nrules are given by R. Often R will be a set of equa\u00adtions E oriented uniformly from left to right or \nfrom right to left, in which case we shall write E+ or E+, respectively. 2 A functional language: Core-XML \nOur setting is a polymorphically typed higher-order func\u00adtional language. We shall restrict ourselves \nto a smsll core language with no primitive types, called Core-XML in [HM93], to develop our theory. In \nSection 6 it is shown how to extend our results to arbitrary type constructors such as integers, Booleans, \npairs and lists and to (monomorphically or polymorphically typed) constants such as a fixed point operator \nand primitive operations for other kinds of type constructors. e E Expression ; x E Variable; T c Type \nu c TypeScheme .._ e .. $I,lz:r .e]eelletz:a= eine .. T .. &#38; I 7--+ r u ::= 7-Iva.a Figure I: Syntactic \ncategories of Cor~XM.L The syntactic constructs for expressions, types and type schemes in Core-XML are \ngiven in Figure 1. We call an expression e well-formed (or simply a Core-XML expression) under type assumption \nr if P 1-e : a is derivable from the inference rules in Figure 2 for some type scheme a. It is easy to \nsee that there is at most one typing derivation for e, which SJSOdetermines a. A type normalized Core-XML \nexpression is one that sat\u00adisfies the following two conditions. Type abstractions oc\u00adcur only as the \nbound expression of let-expressions; i.e., let x = ACY1.Arxl ....Aan. el in ez. We shall abbreviate this \nto let z = AaI ...an. el in ez. Type applications are only allowed for variables; i.e., z{rl }{TZ }... \n{~,}. This will be written as t{rl ...rn}. PROVISO: Henceforth all Core-XML expressions will be as\u00adsumed \nto be type normalized. Usually ML is presented as an implicitly typed language [Mi.178, DM82]. By erasing \nall occurrences of types and type schemes in expressions (including curly brackets, colons, pe\u00adriods \nand A s) in the typing rules for Core-XML, we ar\u00adrive at the implicitly typed language of Core-ML expressions \n[HM93]. In contrast to Core-XML an implicitly typed Core-ML expression e may have many different typing \nderivations. Every one of its typing derivations, however, corresponds to a unique explicitly typed Core-XML \nexpression whose era\u00adsure is e, and vice versa. Our point of departure for boxing analysis is that we \nare given an explicitly typed Core-XML expression or, equiva\u00adlently, a Core-ML expression and a specific \ntyping derivation for it. Even though the specific nature of typing derivations is irrelevant for typability \nof implicitly typed expressions the quality of boxing analysis is very much dependent on which typing \nderivation is chosen for a Core-ML expression; i.e., one derivation may result in less boxing than another \nfor the same Core-ML expression. More on this in Section 7. 3 Explicitly boxed Core-XML Explicitly boxed \nCore-XML is a refinement of Core-XML in which representation types (boxed/unboxed types) and conversions \nbetween these are made explicit. 3.1 Representation types Representation types p are just the standard \ntypes of Core-XML, together with one additional type constructor, [.]. 17t-el:a r{z:a}l-e2:~  r{z:u}+z:u \n rt-letz:rr =elinez:~ L Figure 2: Typing rules for Core-XML Types of the form [p] are boxed t~pes; they \ndescribe ele\u00adments that have been boxed. Types with any other top\u00adlevel type constructor (in our case \nonly -+) are unboxed types; their elements are not boxed. Since doubly boxed representations are useless \nwe prohibit boxed types of the form [[p]]. Boxed types may otherwise, however, occur in\u00adside both boxed \nand unboxed types. We add type variables denoted by metavariables a, ,fl for unboxed and boxed types, \nrespectively. Type schemes are now prenex-quantified repre\u00adsentation types where the quantification is \nover boxed type variables only. Abstract syntax definitions of representation types, boxed and unboxed \ntypes, and type schemes are given in Figure 3. p e RepType; u E UnboxedTyped; rr ~ BoxedType; c G PolyType \np ::=VIT v ::= Crlp-+p n  [v] .. pl a ::= p [Vp.a  Figure 3: Representation types DEFINITION 1 The \n(rmderiging) standard type (or type er\u00ada use) IPI of representation type- p is the type-arrived--at by \nerasing all occurrences of [.] in p and treating both boxed and unboxed type variables as standard type \nvariables. We say that p represents Ipl. We say p is valid for (closed) Core-XML expression e if e has \ntype lpi. 0 3.2 Coercions Repre9entchorz coercions (or simply coercions) are opera\u00adtions that coerce \nan element from one representation to an\u00adother. The primitive coercions are box :uw [w] unbox :[V]-V \nwhere boxu coerces an unboxed element of type w to a boxed representation, and unbox. takes such a boxed \nrepresentation and coerces it back to the unboxed representation. Beyond these primitive coercions we \nadd the identity co\u00ad ercion L. (at every type r), composition of coercions c, c writ ten in diagrammatical \norder c; c and coercions induced by the type constructors. In our case these are coercions of the form \nc~c and [cl. A coercion of the form cac appli~s to functions ~ by (wrapping them with the input coercion \nc and the output coercion c . The result is an un\u00ad boxed function where c is applied to the input before \nit is passed to j and c is applied to the result of ~ before it is ret urned as the output. A coercion \nof the form [c] applies c to the underlying unboxed value of a boxed representation and ret urns a boxed \nrepresentation for the result. We will sometimes omit subscripts on coercions when these are not important \nfor the presentation. The rules for forming coercions are displayed in Figure 4. In the following we \nwill use c, c , d, etc. to denote arbitrary coercions. The formation rules for coercions are sufficient \nto con\u00adstruct coercions that can transform a value from any one of its representations to any other representation: \nPROPOSITION 2 Let PI, PZ be arbitrary representation types. Then IPII = IP21 * (3C) E C:p, -pz. Q Indeed \nthis is possible even without the [.]-coercion con\u00adstructor. We have added it solely to facilitate coercion \nfac\u00adtoring and simplification underneath boxed representa\u00adtions for ~+ EP+-reduction modulo q$ (see Section \n5), where we may introduce box; unbox-redexes in order to eliminate unbox; box-redexes. 3.3 Type inference \nrules The type inference system for explicitly boxed Core-XML is almost identical to the standard type \nsystem. See Figure 5. There are two noteworthy differences, however. 1. Quantification in type schemes \nis only over boxed type variables. The fact that these type variables indeed range over boxed types only \nis captured in the rule for type application: a polymorphically typed expression can only be applied \nto a boxed type, not an unboxed type. 2. There is an additional rule for applying coercions to expressions. \n DEFINITION 3 (Erasure, completion) The erasure (or underlying Core-XIklL ezpresszorz) Iel of an explicitly \nboxed Core-XML expression e is the (standard) Core-XML expression arising from e by erasing all occur\u00ad \nrences of coercions (including angled brackets) and replac\u00ad ing all represent ation type occurrences \np by \\p 1. We say e is a (boxing) completion of Iel at type p if e has type p. 0 4 Axiomatization of \ncompletion congruence A given Core-XML expression e can have many completions. Without going into the \nsemantics of Core-XML we assume that all completions of e at a specific representation type Ec:pl---+pl \nt-c : pz+pz I-c:p%+p I--c : p +p bLp:p-p b C+c : pl -+p2M pl-+p2 k C;c :p+ p 1-boxu : v + [v] 1-unbox. \n: [v] w v k I-c: [c]: v vv [v] - [v ] Figure 4: Coercion formation rules r{z:pl}t-e:p2 r 1-k:pl. e : \np1+p2 rkel:u r{~:a}t-e2:p I 1-letz: a=elinez:p rl-e:a if /3 @ FV(r) I 1-A/3.e : V~.U 17i-e:r Ec:p+p r \n1-(c)e : p rl-el:p1+p2 rl-e1e2:p2 r{$:a}Fz:a rl-e:b p.ff r * e{~} : [/3*lf]~ I 1-e2:p1 Figure 5: Typing \nrules for the explicitly boxed CoreML language have the same observational (input/output) behavior, but \npossibly different performance. In fact we shall assume noth\u00ad ing else about the semantics of explicitly \nboxed Core-XML, and in fact nothing at all about the semantics of standard Core-XML. DEFINITION 4 (Completion \ncongruence) Representation co\u00adercions c and c are congruent, written c ~ c , if they have the same type \nsignature p + p . Explicitly boxed expres\u00adsions e and e are congruent, written e ~ e , if they have the \nsame erasure and type (under the same type assumptions); that is, they are completions of the same expression \nat the same representation type. El In this section we shall give an axiomatization of com\u00adpletion congruence \nby a typed equality theory. The point of this is that the axioms can be grouped into a pure equality \ntheory E that moves coercions along data flow paths with\u00adout eliminating them, and a small group consisting \nof two axioms that express that boxing composed with unboxing in either order is equal to the identity \ncoercion. In Section 5 we interpret the second group as rewriting rules modulo E to capture the intuition \nthat boxing and unboxing coercions are more expensive than the identity, but that the effects of moving \nalong data flow paths are not taken into account. (Note that for any specific semantics moving coercions \ndoes make quite a difference this is the most important part of a semantics that is disregarded in our \ntreatment!) \u00ad (C;c ) ;C = c; (c ;C ) (1) C;l.= c (2) L;c=c (3) (c, + C2); (C, + c, ) = (cl ; C,) + (C2;C2 \n) (4) I,+I,=L (5) [cl] ; [C21 = [cl ;C21 (6) [Ll =L (7) C; boxv~ = box~ ; [c] (8) unbox~ ;C == CC] ; \nunboxv~ (9) box ; unbox = L (d) unbox ;boxv = $ (~) Figure 7: The ~ and $ rules for coercions 4.1 Coercion \ncoherence Consider the equality axioms in Figures 6 and 7 for coer\u00adcions. We assume that the coercions \non both sides of an equality are well-formed and have the same type signature. We denote the single equality \naxiom box; unbox = t by 4, and unbox ;box = L by $. DEFINITION .5 (Coercion equality) We say c and c \nare A-equal, written A t-c = c , if c = c is derivable from the equality axioms A and the equations in \nFigure 6 together with reflexivity, symmetry, transitivity and compatibility of = with arbitrary contexts. \n0 If A in the definition is empty we say c and c are equal and write E c = c . Note that equality is \nnot just synt attic identity; e.g., we have k La + La = Lm+.m. LEMMA 6 (Coherence of coercions) Coercions \nc and c are congruent if and only if they are W-equal; i.e., c = c iff 4+ 1-c = c l  4.2 Expression \ncoherence Let us extend the equality axioms for coercions with the equality axioms for explicitly boxed \nCore-XML expressions in Figures 8 and 9. The expressions on both sides of an equality are assumed to \nbe well-formed and to have the same type in a single type environment. In other words, the equations \nin Figures 8 and 9 should be understood as abbreviations for more complex rules for typed equality. For \nexample, rule 10 is an abbreviation for: 17 be:p rk(~o)e:p Figure 6: Equality rules for coercions I \nl-(~P)e=e:p = DEFINITION 7 (Completion equality) We say eand e are A-equal, A t-e = e , if e = e is \nderivable from the axioms A together with equations in Fig\u00adures 6 and 8 and rules for reflexivity, symmetry, \ntransitivity and compatibility of =. 0 THEOREM 8 (Coherence of completions) Explicitly boxed expressions \ne and e are congruent if and only if they are E$@equal; i.e., e ~ e ifFEq$~ Ee = e PROOF: (If) Assume \nEq$@ ~ e = e . By inspection of E we can verify that e and e have the same erasure. Since both e and \ne are completions at the same type they are congruent, i.e., e G e . (Only if) We will prove this by \ninduction on the struc\u00adture of the common erasure of e and e . We call an ex\u00adplicitly boxed Core-XML \nexpression head coercion free (cf. [CG90]) if it is not of the form (c)e. Without loss of gener\u00adality \nwe may assume that coercions are only applied to head coercion free expressions and that every head coercion \nfree sub expression has exactly one coercion applied to it. This follows from (c)(c )e = (c ;c)e, and \ne= (c)e (see Figure 8). Now assume that we have r 1-e : p and r 1-e : p: Base case 1: le 1 = z{?}. Let \ne -(c )z{~} and e = (c ) z{~}. Let r be the type of z{~} and T the type of x{~}. Note that ~ and r have \nthe same type erasure ~ = r . By Proposition 2 there exists a coercion cwith type signature r -r . Since \nc; C ~d C both have the same type signature we obtain: (c )x{T} = Lemma 6 (C; C )Z{7} = Equation (11), \nFigure 8 (c ) (c)~{~} = Equation (15), Figure 9 (C )Z{7} Base case 2: le 1 -z follows from Lemma 6. \nInductive step 1: le 1 s Xz :r~ .el. Assume that e ~ (c )h :p , el and e G (c )Ax :p .el . Since C has \ntype signature P -+P1 * p and c has type signature p -+.pl -+ p for some types PI and PI by Lemma 6 there \nexists a coercion d such that I#ti 1-c = cl -+cz ;d and g$~ F c = c1 +cZ ; d. In fact, without loss of \ngenerality d = LO or d = boxu where p=[v]. So in either cases d is completely determined by p. This \nmeans that, under E#@-equalit y, we have e = (d)~z:pd .(cz )[z+(cl )z] el and e = (d)h:pd .( Cz )[Z++(CI \n) Z]el for some type pd and by induction (cz )[z+(cl )$]el = (cz )[z++(cl ) z]el which proves that e \n=e . Inductive step 2: Ie 1 s e, ez. Let e s (c )(el ez ) and e a (c )(el ez ). We know that there exists \na coercion d such that (d)ez and ez have the same type. Let the inverse d-l of a coercion d be a coercion \nsuch that #@ t-d-l; d = L (such a coercion always exists according to Proposition 2). We then have, under \nE@&#38;equality: (c )(el e2 )  . . (L-+c )el e2 ((d- ;d)-+c )el ez (d~~)(d-l~c )el ez = (d- -+)elel \n(d)e~ = (induction) (d- -+)elel ez = (induction) (L-+c )el ez = (c )(el ez ) Inductive step 3: Ie 1 ~ \nlet x = AiY. el in ez. We will only show this in the case where the tuple @ has length one. The other \ncases are similar. So the case we prove is Ie 1 a let z = Aa. el in ez. Let e s (d )(let z = A~.el in \nez ) and e s (d )(let z = A~ .el in ez ). Since elf and el have the same type erasure there exists a \ncoercion c(~) such that (c(/3))e1 and e] have the same type. We then have: (d )(let z = A@ .el in ez \n) = let x = A@. el in (d )ez = let z = A~ .(c(/3)-l)(c(~) )el in (d )ez = let z = A,B. (c(/3))el in (d \n)([z{[v,]}~(c( ~,)-1)(~{[~]})] ez ) = (induction) let x =A/3. el in (d )([~{[~i]}t+ (c(~i)- )(~{[w,] \n})]ez ) = (induction) let z = A,B. el in (d )ez . (d )(let z = A~.el in ez ) This shows that if any two \ncongruent completions of a Core-XML expression are observationally indistinguishable a prerequisite for \nour assumption that we are aLlowed to pick any completion of a program at aLl then the observa\u00adtional \ncongruence of explicitly boxed Core-XML must satisfy E@@-equality, and vice versa. Otherwise one could \nfind two congruent completions with different observable behavior.  4.3 Positive and negative coercions \nIt is difficult to reason directly about reduction systems on congruence classes defined by an equational \ntheory. What we would actually like to do is to characterize E-equality by a canonical term rewriting \nsystem that commutes with @-reduction and q$-reduction. Finding a confluent rewrit\u00ading system for E-equality \nis not straightforward, however. In particular, the E-equations cannot simply be oriented in one direction \nor the other since they will inevitably lead to critical pairs without common reducts. Consider for exam\u00adple \nthe rules of Figure 9 oriented from left to right. In the expression ((c~c )~z.e) e both rules 12 and \n13 are applicable, and Knuth-Bendix com\u00ad pletion appears not to terminate. Note that by following one \nreduction path we might fail to eliminate a box/unbox pair using ~ or @ that could be eliminated by following \nthe other path. The main idea behind the reduction system for E@ J\u00ad equality we are about to describe \nis that coercions may be split up into two kinds of coercions that interact differently with the E-equations. \nThe two kinds of coercions are called positive and negative coercions. DEFINITION 9 (Positive and negative \ncoercions)   lsE!YYJ Figure 8: Equality rules for coercion application (c -+ d)k.e = Az. (d)([zt+(c)x]e) \n(12) ((c + d)e) e = (d)(e ((c)<)) (13) (d)let x = A~. (c)e in [z xz{~}]e = let z = A/3. e in (d)([z \nt--(c)z{~}] e ) (14) (C)Z{T} = X{F } (15) Figure 9: Equality rules for explicitly boxed expressions \nA coercion c is positive if c:+ is derivable from the rules in Figm-e 10 and negative if c: is derivable. \n0 A coercion may be neither positive nor negative. By adding a superscript + or to a coercion we indicate \nthat a coercion is in fact positive or negative. (These annotations can be regarded as side conditions \nthat have to hold before a rule may be applied. So in the equations of Figure 11 a superscript + on a \ncoercion means that the coercion has to be positive for the rule to be applicable.) However, it can be \nshown that it is always possible to factor a coercion c into a positive coercion c1 + and a negative \ncoercion C2-such that @J 1-c = CI ~ C2-, and into a negative coercion c] -and a posltlve coercion cz \n+ such that #@ E c = CI ; C2 +. C: d:+ C:+ d:+ C:+ L,:+ box.:+ c-+. d:+ c;d:+ [c] :+ C:+ d: C: d: C: \nLr: unboxu : c+.d: c;d:-[C] : Figure 10: Positive and negative coercions The positive coercions alone \ndefine a subtype hierarchy on representation types. DEFINITION 10 We define p ~ p if there exists a positive \ncoercion c+ such that !-c+ : p -p . 0 PROPOSITION 11 The representation types of any (stan\u00addard) type \nr-(i.e. , representation types whose type erasure is r) form a finite lattice under <. 0 4.4 A Polarized \nAxiomatization of congruence comple\u00adtions To define our reduction system we first define a new axiom\u00adatization \nof completion congruence which takes the polarity of coercions into account. Most importantly, the new \nequa\u00adtions can be easily oriented in one or the other direction to yield a confluent rewriting system \ntogether with @ respec\u00adtively @reduction. First we need to define notation used in our new axiom\u00adatization. \nDEFINITION 12 For every representation type p(~), i.e. with type variables ~, we define a coercion ~(F,~) \nparameterized over the tuples of coercions E and ~ in the following way: &#38;(?jF) = c!i ,@lJ2 (d) = \nh (a,q+;2 (CJ) [U](C,T) = [@,a)l 1 The equations of the new axiomatization, shown in Fig\u00adure 11, are \nthose of Figure 9 where all but the last equation have been split into two polarized equations with side \ncon\u00additions on the polarity (+ or ) of the coercions occurring in them. The only exception is the last \nequation in Figure 9. If we had chosen to treat it analogously to the other equations we would have obtained \nthe following rules: (C-)Z{T} = Z{T } (15- ) (C+)Z{F} = X{F } (15+ ) Thk would, however, not be strong \nenough to characterize E~@equality. If one examines rule 15 more closely one will notice that c must \nhave signature ~I+x]p -[@--#]p where the type of z is V,b .p (we assume without loss of generality t,hat \nthe type of x is only quantified over one type variable). Furthermore, one can show #@ E c = ~(d,d l), \nwhere i-d : rr + # and t-d-l:~ ~x. From this one can see, if we regard rules 15 and 15+ as a left-to-right \nrewrite rule, that rule 15- is more restrictive than rule 15-since it requires more of the structure \nof the coercion involved. The following lemma will be used in proving Theorem 14: LEMMA 13 Let c1, C2, \ndl, etc. be tuples of coercions. Then the following results hold: 1. 44 ~ @Zdl ~dz ) = Z_ti,~) ; ~(=,~) \n 2. r#J@!-p(c,r) ; ~(r,d) = ~(~,d) ; ~(~,r) 0  Let EP be the set of equations in Figure 11. We have \nthe following theorem: THEOREM 14 For all completions e and e : E@~Fe=e iff EP#@i-e=e PROOF: (Only if) \nThis is trivial for all equations except equations 15+ and 15-. We will therefore cover one of these \ncases here. Equation 15 -is shown by the following: (~(c-,L))~{~} (~(c-,(c-~ ;c-))z{7r} : (Lemma 13) \n(fl(Lc-))(P(c-, (c-) -l))z{T} = (13) (P(~,c-))~{~ } Equation 15-is shown similarly ((c+ + d-)}k. e = \nXz .(d-)([z~(c+)x]e) (12-) Ax. (d+)([zt+(c-)z]e) = ((c ~ d+))kz .e (12+) (d-)(e ((c+)e )) = ((c+ ~ d-)e) \ne (13-) (((c -+ d+))e) e = (d+)(e ((c )e )) (13+) (d-)let< = A~.e in [z +(c-)z{r}]e = let z = A~.(c~)e \nin (d-)( [z +z{~ }]e ) (14-) let x = A~. (c+)e in (d+)([z +z{x}]e ) = (d+)let z = A/3. e in [z ~(c+)z{~ \n}]e (14+) (~(~-, ~))~{z} = (l(T, C-)) Z{F } (15-) (P(~, ~))~{fi} = (P(e, r))z{~ } (15+) Figure 11: Polarized \nEquslity equations for explicitly boxed expressions (if) All cases except equation 15 are fairly straightfor\u00adward. \nWe will cover equations 13 and 15. First equation 13: ((c~d)e) e = (factoring) ((c+ad-)(c--d+)e) e = \n(13-) (d-)( ((c--d+)e) (c+)e ) = (13+) (d-)(d+)(e ((c-) (c+)e )) = (d)(e ((c)e )) Then on to equation \n15. We will only proof this for the case where the type of z have the form V,B. P (the proof for b ~.p \nis similar). The signature of c in equation 15 is then ~+r]p -[,B+m ]p and we may therefore prove #@ \n1-c = p(djd l) where 1-d: ~ -T and 1-d-l : r Q r. We now have: (CJx{?r} ([(dd- ))~{~} = (Lemma 13) (/JW1))(~(b))z{~} \n= (factoring) (/j@_l))(~(d-,L) = (15+) )(~(d+,~))~{~} (fl(d- ))(fl(d-, ~))(~(~,d+))z{m } = (Lemma 13) \n(/j@-l))(fl(L>d+))(~(d-,L))z{T } = (15-) (/jW1))(~(@+))M@= (Lemma 13) -))z{m } = (Lemma 13)  $$;;- \n))(~( ,d) )z{~ } 5 Reduction of completions The axiomatization of completion congruence by EP@/L equality \ngives a local characterization of congruence of completions: Any completion of a Core-XML expression \ne can be transformed to any other completion of e at the same type by substituting equals for equals; \ni.e., by replacing any subexpression that matches one side of an equation by the other side. In this \nsection we treat @ and @ as rewriting rules corresponding to improvement s of a completion, but taken \nmodulo all the remaining equations. 5.1 Optimal coercions Our aim is to find completions with a minimum \nof box\u00ad ing und unboxing operations without, however, taking the actual operational semantics of explicitly \nboxed Core-XML into account beyond the fact that it must satisfy EPq$@ equality. Let us take a look at \nthe equations for coer\u00adcions then. Clearly, @ and ~ eliminate primitive coercions when applied as left-to-right \nrewriting rules whereas the remaining-coercion equations just express differences in the presentation \nof a coercion (C;c );c = C;(c ;C ) C;L* c L;c=+c I,+L+I, (c~d); (c ~ d ) =+-(C ;C) -(d; c ) [~]= L [cl \n; [c ] a [c; c ] box;[c] =+ c;box [c] ;unbox ==+ unbox ;C box ;unbox ==+ L (d-) unbox; box ==+ L (ti+) \nunbox ;C; box ==+ [c] (*-) Figure 12: Coercion reduction DEFINITION 15 (Formally optimal coercions) A \ncoercion c is (formally) optimal if all congruent coer\u00adcions c = c can be reduced to c by @&#38;reduction. \n0 Clearly, every coercion equal to an optimal coercion is also optimal. We shall see that, for every \ncoercion type signature I--r with Irl = 1~ 1, optimal coercions exist and are unique modulo coercion \nequality. Consider the coercion reduction rules in Figure 12. We write c ==+; c if c reduces to c by \nthese rules. THEOREM 16 The coercion reduction system in Figure 12 has the fol\u00adlowing properties. 1.It \nis confluent. 2. It is strongly normalizing. 3. If c =.+~ c then 1-c =+$+ c . 4. It preserves polarity; \nthat is, if c is positive or negative and c -L c , then c is also positive, respectively negative. 5. \nIf c is a normal form then:  CEL, e C = box, . c -unbox, c G C -+C , C ~ (C +C ) ;box, 01 C E unbox; \n(c ~c ) where c and c are normal forms, or  c -[c ] where c is a normal form.  0 This theorem guarantees \nthat optimal coercions exist and are unique: COROLLARY 17 For all p, p with Ipl = Ip 1 there exists a \nunique optimal coercion R c: p ---A p . 0 By analysis of R-normal forms we can also guarantee that all \noptimal coercions can be uniquely +/ and /+ factored: COROLLARY 18 1. Every optimal coercion c has a \nunique +/ -factoring; that is, there exist unique d~, d; such that 1-c = d~;d~. 2. Every optimal coercion \nc has a unique /+-factoring; that is, there exist unique d;, d: such that E c = d~; d;. 0  5.2 Optimal \ncompletions We saw that all congruent coercions can be #@-reduced to a unique optimal coercion. For explicitly \nboxed Core-XML ex\u00adpressions we could interpret # and @ as left-to-right rewrit\u00ading rules rnodzdo (or \nunder) E; that is, on the E-congruence classes of explicitly boxed Core-XML expressions. This ex\u00adpresses \nthat we consider any two E-equal completions as indistinguishable in terms of boxing performance in a \nfor\u00admal sense whereas rewriting with # or ~ is an improvement of the boxing performance of a completion. \nUnfortunately, q$+-reduction on E-congruence classes is not Church-Rosser; that is, there are congruent \ncompletions that have no common reduct. Consider, for example, the two completions el -let id:Vp.p-8 \n= A~.Ay:~.y in (k:int .Z + (unbox) (id{[int]} (box) x)) (if ... then 2 else (unbox) (id{[int]} (box) \n5)) ez = let id:V~./3~/3 = A~ .Ay:,f3 .y in (~x:[int] . (unbox)z + (unbox) (id{[int]} z)) (if ... then \n(box)2 else (id{[int]} (box) 5))  Neither one of them is reducible to the other by @&#38; reduction \nmodulo E. The main difference between el and ez is the representation type of z. In el it is unboxed \nwhereas in ez it is boxed. By introducing a box;unbox-pair in front of the constant 2 in el we can ~-reduce \n(modulo E) el to ez. Conversely, by int reducing an unbox ;box-pair in front of (id{[int]} (box)5) in \n.2 we can q$-reduce (modulo E) ez to el. Thus we can trade off a box;unbox-redex for an unbox; box\u00adredex. \nBy prioritizing elimination of one kind of redex over the other we end up with a formal notion of optimality \nthat en\u00adtails that, for any given represent ation type, every source Core-XML expression has an optimal \ncompletion that is unique modulo EP-equality. 5.3 ~-free and q$-free completions In the example above \nwe saw that by introducing a redex of one kind (say ~) we could eliminate a redex of the other kind (@). \nThk is an improvement if redexes of the second kind are considered arbitrarily more expensive than redexes \nof the first kind. But it is not obvious which of the two kinds of redexes should be considered more \nexpensive. Thus we shall pursue two different notions of optimdity. In the first we get rid of all @redexes \nfirst even at the cost of introducing additional gi-redexes and then getting rid of all @redexes without \nletting @-redexes slip back in. In the second we, dually, get rid of all @-redexes first, possibly introducing \nnew @-redexes, and then eliminate all +-redexes without readmitting @redexes. DEFINITION 19 (@-free completions, \nqLfree completions) 1. We say a completion e is ~-}ree if every congruent com\u00adpletion e ~ e v-reduces \nto e under E@-equality; i.e, Eq$+ e *$ e. 2. We say a completion e is q$-free if every congruent com\u00adpletion \ne ~ e ~-reduces to e under E@-equality; i.e., E$ ke =+; e.  Because of the strong global requirement \nthat all congru\u00adent completions must be ~-reducible modulo Ed to c for c to be called ~-free it is not \neven clear that @-free completions (or @free completions) exist. This can be shown, however, by orienting \nthe EP-equations from right to left, treating them as rewriting steps modulo q$-equality, and combining \nthem with @&#38;reduction on coercions. We shall refer to the resulting system somewhat loosely as @-E--rewriting \nmodulo ~, even though ~-rewriting is not modulo 4. LEMMA 20 (Properties of ~+ E~-reduction modulo 4) \n@-E~-reduction modulo c# is canonical; that is, it is strongly normalizing and confluent. PROOF: Strong \nnormalization: Without loss of generality we may assume that every completion has exactly one coer\u00adcion \napplied to each subexpression in the underlying Core-XML expression, since a consecutive coercion application \n(c)(cf)e is equal to (c ; c)e and a subexpression e without a coercion is equal to (J)e. Let c1, . . \n. . c~ be the vector of all coercion occurrences in a completion in some particular order such that they \nare in one-to-one correspondence with the subexpressions of the underlying Core-XML expression. Since \ncompletion rewrit\u00ading does not change the underlying Core-XML expression, a completion rewriting step \ncorresponds to a rewriting step on this vector. A ~+-reduction step operates on a single element of the \ncoercion vector above. By Theorem 16 #@-reducing a coer\u00adcion is strongly normalizing. Thus there can \nbe only finitely many @reduction steps at the beginning of the reduction or after an EP-step is executed. \nAn E; step generally operates on several coercions in the coercion vector simultaneously. Consider the \ntype sig\u00adnatures of the coercions in the coercion vector. An E=-step rewrites at least one coercion F \nc: p --+ p to a new coercion c that has domain type or range type properly increased in the subtype hierarchy \nof Definition 10. Since the subtype hierarchy has only finite ascending chains (Proposition 11) it follows \nthat EP-steps can only be applied a finite number of times. Thus every @-EP--reduction sequence is finite. \nConfluence: Since ~+ E~-rewriting modulo i#Jis strongly normalizing it is, by Newton s Lemma, sufficient \nto show local confluence; that is, if e has overlapping redexes and reduces by single rewriting steps \nto e1 and ez then there exists a common reduct e to which both el and ez reduce, possibly in several \nsteps. Let us consider such triples e, el, e~. By Theorem 16 y@\u00adreduction on coercions is confluent. \nNote that ~-redexes do not overlap with any Ep+ -redex due to the polarization and orient ation of the \nEP rules. We only have to worry about overlaps of EP+ -rules modulo ~-equality. There are only two kinds \nof overlaps: 1. Application of the same rule to the same subexpres\u00adsion, only with different coercions; \ne.g., ((c; ~ c;); C)kz.e =+ (E)Aq.(c~)([z w (c~)z]e) and ((d; + d;); Z)kz.e ==$. (d) Az.(dJ)([z t-(d~)z]e) \nwhere ~~(c; +c; );c=(d; +d:); d. In this case it is sufficient to show that # b E_*+ C;; c; ~l-d~$d;;d: \nfor some positive c:, d: and negative c1-, d4 , where and d: have the same range type p, since then c: \nwe can apply the same rule again to each of the two different reducts to get a common reduct. By choosing \nthe maximal representation type greater than domain types of G and d for p this is easily accomplished. \n2. Overlaps due to three pairs of adj scent rules in Fig\u00adure 11: 12 /12+, 13 /13+, and 14 /14+. Let us \ncon\u00adsider 12-/12+: (c; + df)kz.(d~)([z w (c~)z]e) can be rewritten to (c; ~ d~)(c~ + d~)~z.e and to kz.(d~)(d~)([z \n+ (c~)(c~)z]e). For the first redllct we get furthermore .  = +; (+/--fact.) Similarly, we can rewrite \nthe second reduct to the same final completion above. ~z.(d~)(d~)([x + (c$)(c~)z]e) = k.(d;; df)([z t-+ \n(c;; c~)z]e) *J (+/--fact.) ku.(d~; dj)([z * (c:; c~)z]e) = ~~.(d:)(dj)([~ * (c; )(c~)~]e) *EF (c: + \nd~)k. (df)([z E-+ (c~)z]e) In these reductions we used the fact that every coer\u00adcion can be @@-reduced \nto a +/ -factored coercion by Corollary 18. The other two pairs of rules with critical pairs are han\u00addled \ncompletely analogously. This completes the proof. 0 Having a canonical reduction system for EP#@-equality \nand thus for congruence it follows that every congruence class of completions contains both @-free and \n#-free com\u00adpletions. THEOREM 21 (Existence and uniqueness of ~-, resp. q$-free completions) Let e be \na (closed) , Core-XML exrnession and let o be a valid represent ation type for e. 1. Then e has a @-free \ncompletion e at p; e is further\u00admore uniquely determined up to EP qkequalit y. 2. e has a @-free completion \ne at p; e is uniauely de\u00ad  . . termined up to EP&#38;equalit y. PROOF: We only give a proof of 1. The \nproof of 2 is similar. (It requires a lemma analogous to Lemma 20.) Consider all the (congruent ) completions \nof e at p. By Theorems 8 and 14 we know that they are all EP@@equal, By Lemma 20 ~-11~-rewriting modulo \n~ is canonical. It reduces any two congruent and thus EP~ +-equal com\u00adpletions to a normal form e.f \nthat is unique up to @-equality. Thus enf is a @free completion of e. It can be shown that any ~-free \ncompletion of e at p must be E= ~-equal to e~fi 0 Intuitively, a @-free completion prefers to keep data \nin a boxed representation and unboxes a representation only when it is sure the unboxed value is required \nby some opera\u00adtion. This way passing arguments to polymorphic functions and returning their results can \nbe expected to be efficient whereas operations requiring unboxed data such as integer operations may \nbe inefficient due to the cost of unboxing arguments and boxing the results. Dual to this, a ~-free completion \nprefers to keep data in unboxed representation; it boxes a value only when it is sure to be required \ndue to a call to a polymorphic function. Thus primitive operations will generally be executed fast as \nno coercions need to be performed for neither the arguments nor the result, but calls to polymorphic \nfunctions may be ex\u00adpensive due to the need for boxing (parts of) the arguments and unboxing (parts of) \nthe resnlt. Since the degree of polymorphism in a program tends to be greatest when higher-order functions \nare used a @ free completion will generally be better for higher-order pro\u00adgrams, especially if there \nis little ground type processing such as arithmetic operations. On the other hand, @free completions \nwill generally do best where there is little poly\u00admorphism and/or lots of operations on ground types. \n The rules for @+ E~-rewriting modulo @ suggest an ex\u00adplicit construction of ~-free completions: take \nan arbitrary completion and execute the @-reduction system until a nor\u00admal form is reached . Analogously \nfor @-free completions. An even simpler method consists of devising syntax-directed translations that \nproduce a ~-free or qLfree completion di\u00adrectly. The canonical construction of a ~-free completion con\u00adsists \nof keeping all data in their maximally boxed repre\u00adsentation (i.e., representing a standard type by the \nmaximal type in the representation type hierarchy) and boxing a un\u00adboxed value as soon as it is produced \nby some operation and unboxing it just before it is used by some operation. The canonical construction \nof a &#38;free completion con\u00adsists of keeping all data in their minimally boxed represen\u00adtation where \nan unboxed value is only boxed just before it is passed to a polymorphic function and the result of a \npoly\u00admorphic function is immediately unboxed. This is actually the construction described by Leroy [Ler92]. \n 5.4 Optimal @-free/@-free completions The two constructions above for a @-free and a ~-free com\u00adpletion \nare canonical since they use a universal standard representation (maximally boxed or minimally boxed) \nfor all data independent of their context. They are not optimal since they typically cent ain many q$-, \nrespectively +-redexes modulo EP-equality. We shall now set out to construct opti\u00ad mal @-free and ~-free \ncompletions, which have no remaining redexes and are thus @q$-normal forms modulo E. DEFINITION 22 (Optimal \n@-free/@-free completions) 1. A completion e is a (formally) optimal $-free comple\u00adtion if e is ~-free \nand every congruent ~-free comple\u00adtion e ~-reduces to e modulo E; i.e., E k e =+$ e. 2. A completion \ne is a [formally) optimal #-free comple\u00adtion if e is #-free and every congruent +-free completion e ~-reduces \nto e modulo E; i.e., E 1-e ~~ e.  u 1$ e have shown that @-free completions are EpqLequal, and ~-free \ncompletions are EP@-equaL There are canonical rewriting systems for ~-reduction and ~-reduction modulo \nEp. As a result we obtain our main theorem: THEOREM 23 (Existence of $-free and q$-free optimal com\u00adpletions) \n Let e be a (closed) Core-XML expression and let p be a valid represent ation type for e. Then e has \nboth an optimal t$free completion and an optimal ~-free completion at p. Furthermore, both are unique \nmodulo EP. !2 For the proof we employ again a rewriting system. ThE time we use q$+ E~-rewriting. This \nrewriting system oper\u00adates on equality classes defined by the coercion equations in Figure 6 and the \napplication equations in Figure 8. Note that the EP-equations are oriented from left to right, oppo\u00adsite \nto the orientation we had chosen for ~-EP+-reduction modulo @. The proof of the theorem is omitted. It \nis analogous to the proofs of Lemma 20 and Theorem 21. 6 Implementation We have written a prototype \nimplementation in Haskell of our rewriting systems. The implementation handles the Core-XML language \nextended with a conditional, pairs, a fixed-point operator and arbitrary polymorphic constants. Polymorphic \nconstants enable us to introduce lists by just adding a list type to the implementation. The implementation \nis parameterized in such a way that one can specify from what canonical completion reduction is going \nto start, and what reduction system is to be used: (4 F c =+-* +-E; c, + C =+&#38;~-C, @ t_ C ==+;-E~ \nC, or 1-c =+.$-~~ c). (Recall that reduction to an optimal completion involves two phases.) Running \nthe system will produce a normal form com\u00adpletion in the form of an SML-program in which box and unbox \noperations behave like the identity function, but also perform profiling operations. That is, besides \nreturning its input the box and unbox coercions count how many times they are called. The final result \nof running such an SML program is the actual result together with a count of the box and unbox operations \nexecuted. 6.1 Adding new type constructors Adding new type constructors like pairs, list, etc., is quite \nsimple. If we add a new type constructor (e.g., for list types p list) we also have to add a new constructor \n(e.g., map c) on coercions, and we have to extend Figure 6 with some new equations for this new coercion \nconstructor. For list these rules are map LP = Lp ttst map (c ;d) = (map c); (map d) In terms of category \ntheory type constructors can be seen as functors, and the rules above are simply the two conditions that \nmust hold for a functor. 6.2 Handling of primitives Extending our work to handle language primitives \nand poly\u00admorphic constants is straightforward and elegant. We will show how one can derive very natural \nrules for conditionals directly from rules 15-and 15+ of Figure 11. The type of the conditional is if_ \nthen_ else_: v a.(bool, cr, a)~a. Treat\u00ading the conditional as a free variable we see that equations \n15-and 15+ provide the necessary and sufficient coherence conditions. Since language primitive are implemented \nin-Iine we can dispense with the requirement that they be applied only to boxed types. Instantiating \nequation 15-to if -then -else _ yields (~~~~*P,*P~+c-)(if _ then _ else .){/}= (( Lbool,C-,C-)-+Lp) (if \n_ then_ else _){p}  for any negative coercion c : p --+ p. Applying both sides of the equation to argument \n(el, ez, e3) we obtain the natural equation (c-)if el then e, else e, = if el then (c-)ej else (c )es \n In this way one can develop specific rules for program con\u00ad structs like condition al, fix-point operator, \npairing, and primitive operations. Polymorphic constants can be han\u00addled directly by ueing rules 15-and \n15+. We give one more example to show the connection of equations (15), (15-), and (15+) to what Wadler \nhas termed free theorems (see Reynolds [Rey83] and Wadler [Wad89]). Assume that we have a function r \nsuch as reverse with type VIY. a list-+a list.If we instantiate rule 15 to this we get (t-map c-)r{p \n} = (map c--+~)r{p} but this is essentially, if we disregard the instantiation, the same as map c or=romapc \nwhich is a well-known free theorem.  6.3 Performance results Figure 13 gives results of some experiments \nperformed with our implementation. The six programs that were selected for the experiments were: insert-sort, \na insert sorting pro\u00adgram where the insert function is polymorphic; flip-list, which flips the elements \nof a list of pairs of integers; leroy, which is an almost pathological program for which Leroy s benchmark \nshows a major slow-down compared to a fully boxed implementation; pouken, a program for which Poulsen \n[Pou93] reports that his algorithm gives very poor results (30 0/300 box/unbox-operations); sieve, which \ncom\u00adputes the prime numbers between 1 and 100; and poly, a constructed example program with a lot of \npolymorphism. The example programs insert-sort, flip-list, leroy, pouken are all taken from [Pou93]. \nFor all six programs we have generated three comple\u00adtions, the optimal ~-free normal form, the optimal \nq$-free normal form and Leroy s completion. We have run the three completions and counted the number \nof box and unbox ope\u00adrations performed. Figure 13 shows the results. The results indicate that the optimal \n@-free normal form completions found by our system are generally better and oft en much better than Leroy \ns completion, especially when a lot of polymorphism is involved, like in poly. In one case, sieve, Leroy \ns completion performs fewer unbox-operations than the optimal @-free normal form we produce. The rea\u00adson \nfor this is that the optimal @free completion we produce places unbox operations as late as possible \nthus possibly duphcating unboxing operations. 7 Related work 7.1 Boxing The substantial cost of manipulating \ndata in boxed represen\u00adtation, especially for numeric programs, has been observed in both dynamically \ntyped high-level languages like LISP and statically typed polymorphic languages such as Stan\u00addard ML, \nand Haskell. Most of the efforts in LISP implementation have focused on optimizing number representations \nby keeping them in unboxed form [Ste77, BGS82, KKR+ 86]. Peterson [Pet89] uses an elaborate execution-frequency \nbased criterion for the cost of representation coercions. In this setting he shows how the optimal placement \nof coercions can be reduced to a well-known network flow problem. Common to all these ef\u00adforts is the \nintent to optimize representations of atomic data, particularly numbers. Indeed in Peterson s framework \nope\u00adrations on pairs and lists simply require boxed arguments. Program Completion insert-sort opt. @free \nnorm. rm opt. #-free norm. 289 307 Lerov 156 307 I flip-list opt. @-free norm. 20 I 20 opt. ~-free norm. \n30 35 Lerov 20 20 leroy opt. +-free norm. 709 709 opt. #-free norm. 446 446 4 Leroy 1219 1219 poulsen \nopt. @-free norm. 3 3 opt. #-free norm. 3 3 Leroy 31 31 sieve opt. @-free norm.   =T--=-l opt. @free \nnorm. 436 I 748 Leroy 411 748 poly opt. t$free norm. E  =t=l opt. #-free norm. Lerov u Figure 13: Performance: \nbenchmarks Steenkiste and Hennessy, however, have found that in a suite of ten LISP programs up to 80% \nof the representation coer\u00adcions are list tagging/untagging operations. Peyton Jones and Launchbury [P \nJL91] and Leroy [Ler92] suggested making representation types and boxing and un\u00adboxing operations explicit \nin programs. Even though there are some technical differences, the languages they use are at the core \nthe same: Core-ML with explicit boxing/unboxing coercions. Peyton Jones and Launchbury do not provide \na method of inferring a completion, but concentrate on the seman\u00adtics of their explicitly boxed language \nand on optimization of boxing by program transformation. Those optimizations are, for example, a form \nof common sub expression elimi\u00adnation that cannot be formalized in our framework as the transformations \nmay change the underlying program. Leroy describes a translation of Core-ML expressions to explicitly \nboxed Core-ML expressions. This translation is not deterministic as it depends on the specific typing \nderiva\u00adtion of the underlying Core-ML expression, but every trans\u00adlation of such a source Core-ML expression \nis a completion in our sense (not the other way round, however). The ex\u00adperimental results of incorporating \nhis boxing analysis in the Gallium compiler for CAML Light show that the result\u00ading performance can be \ndrastically different from the orig\u00adinal compiler that uses canonically boxed representations. The results, \nthough, are not uniformly better, The canon\u00adically boxed completions are +-free whereas Leroy s is @ \nfree in our terminology. The results are in line with our general considerations that indicate that monomorphic \npro\u00adgrams should generally fare better with a @-free completion whereas highly polymorphic programs are \nlikely to be bet\u00adter off with a +-free completion. Our rewriting system for @free completions will improve \nthe result of Leroy s comple\u00adtion by eliminating all @redexes, and our rewriting system for @-free completions \nwill improve the canonically boxed completion by eliminating all g$-redexes. Using Leroy s framework \nPoulsen [Pou93] presents a more involved translation, but draws on constraint solving to eliminate more \nboxing/unboxing operations than Leroy s translation in many, but not all cases. The interesting aspect \nof Poulsen s completions is that they, just like our optimzd completions, are not required to have a \ncanonically defined representation type for the types occurring in type appli\u00adcations as in Leroy s work, \nbut determines an appropriate representation type as part of the constraint solving process. On the other \nhand it appears that some boxing/unboxing operations are built into the constructors of the language \nand are not accounted for in the question of optimizing the boxing in the program. Given a Core-ML expression \nwith type r the result of a boxing analysis depends on the particular typing derivation chosen. Leroy \ns completion uses implicitly the derivation obtained by Algorithm W [Mi178] since his translation per\u00adforms \ntype inference and boxing simultaneously where let\u00adbound variables receive the principal type of the \nbound ex\u00adpression. (Peyton-Jones/Launchbury and Poulsen also ap\u00adpear to assume that type inference is \nperformed in the style of Algorithm W.) The principal type of a function is the most polymorphic type \nand thus imposes the most box\u00ading demands on the arguments to the function. A more monomorphic derivation, \non the other hand, could still yield the same type for the whole expression, but using more monomorphic \ntypes for the local variables. Bj@ner gives an algorithm called M for finding a minimally polymorphic \ntyp\u00ading derivation [Bj@92]. Minimally polymorphic derivations do not aJways exist, but his algorithm \ngenerally lowers the local degree of polymorphism in comparison to Algorithm W. Note that our boxing \nanalysis does not presuppose a specific typing derivation for a Core-ML expression, but in\u00adterfaces with \nany of its type derivations, which is represented by an explicitly typed Core-XML expression. 7.2 Coherence \nand equivalence The notion of coherence appeared first in computer sci\u00adence literature in the work of \nBreazu-Tannen, Coquand, Gunter, Scedrov [BTCGS91, BTGS90] and Curien, Ghelli [CG90, Ghe90]. They use \nit to give interpretations of sub\u00adtype based systems, where application of the subtyping rule is interpreted \nby an (explicit) coercion. Since a given pro\u00adgram with subtyping may have many different translations \nit is integral to prove that all of them are coherent for the se\u00admantics (via arbitrary translation and \ninterpretation of the target program) to be well-defined. Thatte describes a method for inferring very \npowerful implicit coercions between isomorphic types in a type in\u00ad ference system enriched with coercions \nbetween arbitrary isomorphic types. Our application can be viewed as simple variant of this problem as \narbitrary representation types of the same standard type and only those can be coerced to each other. \nOn the other hand Thatte does not deal with optimizing the coercions required in this fashion. The notion \nof completion and its congruence theory is inspired and closely related to the work reported in [Hen93], \nwhich explicates type tagging and untagging operations in dynamiczdly typed languages. The purpose of \ndoing so is completely analogous to boxing analysis: to eliminate most statically type tagging and untagging \noperations and to im\u00ad plement only the remaining ones whiIe still obtaining safe program execution; i.e., \nwell-defined program behavior. See also the work by Cartwright, Fagan and Wright on soft typ\u00ading [CF91, \nWF92]. 8 Conclusion and further work We have presented a calculus, formal optimality criteria and rewriting-based \nalgorithms for finding good representations of data as boxed or unboxed data in a polymorphically typed \nprogramming language. The word good here is to be un\u00adderstand in a very general and broad sense. What \nhas been left out is a detailed analysis of specific language properties and implementation considerations \nthat have an effect on the actual performance. This haa been done to make the results universal) and \napplicable in different settings, even different semantics of the same language. Judging by experimentation \nwith some short Standard ML programs our formally optimal completions also tend to be consistently better \nin practice than previously de\u00adscribed boxing analyses if we count only the number of box\u00ading/unboxing \noperations executed. Since no implementation decisions are made at the time the boxing analysis is con\u00adducted \nits output should combine well and without much interference with later implementation phases. The general \nframework of treating boxing analysis as a translation of a program to a language with explicit boxing \nand unboxing operations, due to Leroy [Ler92] and implicit also in Peyton Jones and Launchbury [PJL91] \nencapsulates boxing analysis as a single phase. The representation type of an explicitly boxed program \nspecifies its interface and thus allows separate compilation of program modules. There are several problems \nwith making full use of boxing-optimized programs: 1. Garbage collection often requires tagging of heap\u00adallocated \ndata with explicit type and size information. Thus an unboxed representation may well have to be tagged \n(= boxed) anyway to accommodate the garbage collect or. 2, A boxed representation is the result of an \nevaluation. In lazy languages often boxed representations are re\u00adquired since the evaluation of an expression \nis not stat\u00adically known to terminate or to be advantageous. Thus an expression determined to be best \nkept in unboxed form by our boxing analysis may still have to be boxed at run-time. For the future we \nplan to devise efficient algorithms for computing optimal boxing completions, which also take ac\u00adcount \nof control dependencies and carefully place coercions at points where they get executed with minimum \nrun-time frequency. We expect to use analyses such as Peterson s [Pet89] for this purpose. Finally, we \nintend to integrate our boxing analysis af\u00ad ter region inference has been performed into the region\u00ad \nbased implementation of Standard ML currently underway at DIKU (see [TT94] ). The use of region-based \nmemory management also obviates the need for global garbage col\u00ad lection and thus the first of the two \nrestrictions above. Acknowledgements We would like to thank Neil Jones for first pointing out the applicability \nof the framework of dynamic typing to box\u00ading analysis. Special thanks go to Eigil Rosager Poulsen from \nwhose thesis most of our test examples were taken. We would aJso like to thank the following people with \nwhom we have had interesting and fruitful discussions on formally optimaJ boxing: Anders Bondorf, Christian \nMossin, Robert Gluck, David Sands and Mads Tofte. References [BGS82] R. Brooks, R. Gabriel, and G. Steele. \nAn op\u00adtimizing compiler for lexicaJly scoped LISP. In Proc. SIGPLAN 82 Syrnp. on Compiler-Con\u00adstruction, \nBoston, Massachusetts, pages 261 275, June 1982. SIGPLAN Notices, Vol. 17, No. 6. [Bj@92] Nikolaj Bj@ner. \nMinimal typing derivations. DIKU Student Report, July 1992. [BTCGS91] V. Breazu-Tannen, T. Coquand, C. \nGunter, and A. Scedrov. Inherit ante as implicit coer\u00adcion. Information and Computation, 93(1) :172 221, \nJuly 1991. Presented at LICS 89. [BTGS90] V. Breazu-Tannen, C. Gunter, and A. Scedrov. Computing with \ncoercions. In M. Wand, edi\u00adtor, Proc. ACM Symp. on Lisp and Functional Programming (LFP), Nice, France, \npages 44\u00ad60, 1990. [CF91] R. Cartwright and M. Fagan. Soft typing. In Pr-oc. ACM SIGPLAN 91 Conf. on \nPr-o\u00adgrarnming Language Design and Irnpiementa \u00adtzon, Toronto, Ontario, pages 278-292. ACM, ACM Press, \nJune 1991. [CG90] P. Curien and G. Ghelli. Coherence of sub\u00adsumption, In A, Arnold, editor, Proc, 15th \nCoil. on Trees in Algebra and Programming, Copen. hagen, Denmark, pages 132 146. Springer, May 1990. \n[DM82] L. Damas and R. Milner. Principal type schemes for functional programs. In Proc. 9th Annual ACM \nSyrnp. on Principles of Program\u00adming Languages, pages 207 212, Jan. 1982. [Ghe90] G. Ghelli. Proof Theoretic \nStudies about a Minimal Type System Integrating Inclusion and Parametric Poigmorphisrn. PhD thesis, Uni\u00adversit \na di Piss, Dipartimento di Informatica, March 1990. [Hen93] Fritz Henglein. Dynamic typing: Syntax and \nproof theory. Science of Computer-Program\u00adming, 1993. Special Issue on European Sympo\u00adsium on Programming \n1992 (to appear). [HM93J Robert Harper and John Mitchell. On the type structure of Standard ML. ACM Transac\u00adtions \non Programming Languages and Systems (TOPLAS), 15(2):211-252, April 1993. Based on paper presented at \nPOPL 88. [KKR+86] D. Kranz, R. Kelsey, J. Rees, P. Hudak, J. Philbin, and N. Adams. ORBIT: An op\u00adtimizing \ncompiler for Scheme. In Pr-oc. SIG-PLAN 86 Symp. on Compiler Construction, pages 219-233, 1986. [Ler92] \n[Mi178] [Pet89] [PJL91] [POU93] [Rey83] [Ste77] [TT94] [Wad89] [WF92] X. Leroy. Unboxed objects and polymorphic \ntyping. In Proc. 19th Annual A CM SIGPLAN-SIGA CT Symposium on Principles of Program\u00adming gLanguages \n(POPL), Alb uquerque, New Mexico, pages 177 188. ACM Press, Jan. 1992. R. Milner. A theory of type polymorphism \nin programming. J. Computer and System Sci\u00adences, 17:348 375, 1978. J. Peterson. Untagged data in tagged \nenvi\u00adronments: Choosing optimaJ representations at compile time. In Proc. Functional Pro\u00adgramming Languages \nand Computer Architec\u00adture (FPCA), London, England, pages 89 99. ACM Press, Sept. 1989. Simon Peyton \nJones and John Launchbury. Unboxed values as first class citizens. In Proc. Conf. on Functional Programming \nLan\u00adguages and Computer Architecture (FPCA), Cambridge, Massachusetts, pages 636-666. Springer, Aug. \n1991. Lecture Notes in Com\u00adputer Science, Vol. 523. Eigil Poulsen. Representation analysis for ef\u00adficient \nimplementation of polymorphism. Mas\u00adter s thesis, DIKU, University of Copenhagen, 1993. J. Reynolds. \nTypes, abstraction and parametric polymorphism. Information Processing, pages 513-523, 1983. G. Steele. \nFast arithmetic in MacLisp. In Proc. 1977 MA CSYMA User-s Conference, NASA Scientific and Technical Information \nOficel Washington, D. C., July 1977. Mads Tofte and Jean-Pierre TaJpin. Imple\u00admentation of the typed \ncall-by-value ~-calculus using a stack of regions. In Proc. 21st An\u00adnual ACM SIGPLAN SIGA CT Symposium \non Principles of Programming Languages (P OPL), Portland, Oregon (this proceedings). ACM, ACM Press, \nJan. 1994. P. Wadler. Theorems for free! In Pr-oc. Func\u00adtional Programming Languages and Computer Architecture \n(FPCA), London, England, pages 347 359. ACM Press, Sept. 1989. A. Wright and M. Fagan. Soft typing and \nglobal represent ation optimization. Manuscript, July 1992.   \n\t\t\t", "proc_id": "174675", "abstract": "<p>An important implementation decision in polymorphically typed functional programming language is whether to represent data in boxed or unboxed form and when to transform them from one representation to the other. Using a language with explicit representation types and boxing/unboxing operations we axiomatize equationally the set of all explicitly boxed versions, called <italic>completions</italic>, of a given source program. In a two-stage process we give some of the equations a rewriting interpretation that captures eliminating boxing/unboxing operations without relying on a specific implementation or even semantics of the underlying language. The resulting reduction systems operate on congruence classes of completions defined by the remaining equations <italic>E</italic>, which can  be understood as moving boxing/unboxing operations along data flow paths in the source program. We call a completion <italic>e<subscrpt>opt</subscrpt> formally optimal</italic> if every other completion for the same program (and at the same representation type) reduces to <italic>e<subscrpt>opt</subscrpt></italic> under this two-stage reduction.</p><p>We show that every source program has formally optimal completions, which are unique modulo <italic>E</italic>. This is accomplished by first &#8220;polarizing&#8221; the equations in <italic>E</italic> and orienting them to obtain two canonical (confluent and strongly normalizing) rewriting systems. The completions produced by Leroy's and Poulsen's algorithms are generally not formally optimal in our sense.</p><p>The rewriting systems have  been implemented and applied to some simple Standard ML programs. Our results show that the amount of boxing and unboxing operations is also in practice substantially reduced in comparison to Leroy's completions. This analysis is intended to be integrated into Tofte's region-based implementation of Standard ML currently underway at DIKU.</p>", "authors": [{"name": "Fritz Henglein", "author_profile_id": "81100104232", "affiliation": "Univ. of Copenhagen, Copenhagen, Denmark", "person_id": "PP39027309", "email_address": "", "orcid_id": ""}, {"name": "Jesper J&#248;rgensen", "author_profile_id": "81100019874", "affiliation": "Univ. of Copenhagen, Copenhagen, Denmark", "person_id": "PP14020025", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/174675.177874", "year": "1994", "article_id": "177874", "conference": "POPL", "title": "Formally optimal boxing", "url": "http://dl.acm.org/citation.cfm?id=177874"}