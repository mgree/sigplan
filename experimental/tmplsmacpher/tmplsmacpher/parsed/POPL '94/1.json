{"article_publication_date": "02-01-1994", "fulltext": "\n Correctness of Trap-Based Breakpoint Implementations Norman Ramsey Bell Communications Research 445 \nSouth Street, Morristown, NJ 07960 norman@bellcore. com Abstract It is common for debuggers to implement \nbreakpoints by a combination of planting traps and single stepping. When the target program contains \nmultiple threads of execution, a debugger that is not carefully implemented may miss breakpoints. This \npaper gives a formal model of a breakpoint in a two-threaded program. The model describes correct and \nincorrect breakpoint implemen\u00ad tations. Automatic search of the model s state space shows that the correct \nimplementation never misses a breakpoint. A similar search finds an execution for which the incorrect \nimplementation does miss a break\u00adpoint. The results apply even to debuggers like dbx and gdb, which are \napparently for single-threaded pro\u00adgrams; when the user evaluates an expression contain\u00ad ing function \ncalls, the debugger executes the call in the target address space, in effect creating a new thread. \n Introduction A debugger runs as a coroutine with its target pro\u00adgram. A breakpoint at target instruction \n1 transfers control from the target to the debugger whenever con\u00adtrol reaches 1. When the debugger gets \ncontrol, it may take such actions as evaluating a condition, increment\u00ading a counter, or simply asking \nthe user for instructions. Eventually the debugger returns control to the target, which resumes execution \nat 1. At that time, 1 must be executed once, but subsequent attempts to execute I must return control \nto the debugger. Implementors can choose how to manage the trans\u00adfers of control. To get control at an \ninstruction 1, a debugger can overwrite I with a trap instruction, then handle the resulting trap (Caswell \nand Black 1990), or Permission to COPV without fee all or part of this matarial is granted provided that \ntha copies are not mada or distributed for direct commercial advantage, the ACM copyright notica and \ntha title of tha publication and its data appaar, and notice ie given that copying is by permission of \ntho Association for Computing Machinery. To copy ctherwiee, or to republish, requires a fbO andor specific \npermission. POPL 94-1194, Portiand Oregon, USA @ 1994 ACM 0-S9791-636W94~?.. $3.W it can overwrite I \nwith an instruction that branches to debugging code (Digital 1975). To resume execu\u00adtion, there are more \nchoices. A debugger can return the overwritten instruction to memory, execute it by single stepping the \ntarget machine, and re-plant the breakpoint (Caswell and Black 1990). Single stepping can be avoided \nby transforming the overwritten in\u00adstruction so that it can be correctly executed out of line (Digital \n1975), (Kessler 1990). Finally, some ma\u00adchines have special hardware that supports resumption after a \nbreak instruction (Bruegge 1985). This paper exposes a potential pitfall in the imple\u00admentation of breakpoints \nbased on trapping and single\u00adstepping. Single stepping means arranging that the target machine will trap \nagain immediately after ex\u00adecuting 1, On some machines it can be implemented only by planting traps at \ninstructions that might be ex\u00adecuted immediately after 1; these instructions are 1 s follow set. If these \ntraps are planted at the wrong time, and if the target has more than one thread of control, the debugger \ncould miss a breakpoint. Even a traditional single-threaded debugger must avoid this pitfall if it evaluates \nexpressions at the source level. Expression evaluation includes calls to user\u00addefined procedures, and \nthese procedures run in the target address space. To run such procedures, the de\u00adbugger must in effect \ncreate a second thread. If such a procedure hits a breakpoint and the expression evalua\u00adtion is abandoned, \nthe debugger may miss a subsequent arrival at that breakpoint. This paper makes several contributions. \nIt provides an abstraction and formalization of a breakpoint tech\u00adnique commonly used with compiled forms \nof impera\u00adtive programming languages. Using the formalism, the paper shows that unrestricted context \nswitching can make a debugger miss a breakpoint. It gives restric\u00adtions on context switching that prevent \nthe error; these restrictions are shown sufficient by machine checking of all possible executions. Finally, \nthe paper gives an un\u00adusual application of protocol-validation techniques to a programming-language problem. \n Debugger Target of I, undoes the trace bit or the traps at the follow set trap at I and rewrites a trap \nover 1. catch trap at I detect breakpoint restore 1 single-step I 1 refers to a bad address catch fault \nuser corrects bad address value resume execution I executes single-step completes and traps catch trap \nat completion re-write trap at 1 resume execution target continues Figure 1: Address fault in the middle \nof a breakpoint (time flows downward) 2 Breakpoints and events In a trap-based implementation, breakpoint \nhandling begins when a target thread hits the trap written over instruction 1. The description above \nsays that 1 is re\u00adturned to memory and the machine is single-stepped, after which I can be replaced with \na trap. This de\u00adscription is oversimple, because 1 need not execute successfully. For example, it may \nrefer to an invalid address, as shown in Figure 1 (time flows from top to bottom). A practical breakpoint \nimplementation can\u00adnot rely on executing a simple sequence of (a) remove trap, (b) single step, (c) replace \ntrap; it must be pre\u00adpared for other events to be inserted into the sequence, and it must create handlers \nthat respond appropriately to those events. Two handlers are relevant to the breakpoint im\u00adplementation. \nOne handles the trap that indicates a thread s attempt to execute instruction I, and the other handles \nthe notification that the execution of I (the single step) has completed successfully. These handlers \nappear in Figure 1 as the first and third ac\u00adtions of the debugger. The second action is that of a handler \nresponding to the invalid-address event; it is not part of the breakpoint implementation. Before letting \nthe target execute 1, the first handler must arrange for an event to occur when 1 s execution completes. \nThe usual choice is a trap event, which can be arranged either by setting a trace bit in the target processor \n(if available) or by planting traps at 1 s follow set. Once the bit is set or the traps are planted, \nthe execution of the target thread can be resumed. The second handler, when it sees the trap at the completion \nThis implementation is incorrect in the presence of multiple threads of execution. Figure 2 shows an \nex\u00adecution involving a debugger and two target threads in which both threads go through the breakpoint, \nbut only one is detected. As shown in the next section, the problem arises because both threads are permitted \nto execute after 1 is restored. The solution is to prevent the execution of other threads while the thread \nthat trapped executes I. The problem can arise in practice even in a single\u00adthreaded debugger. When the \nthread traps at I, the debugger may evaluate an expression before resuming execution. If a procedure \ncall is needed to evaluate the expression, the debugger must, in effect, create a sec\u00adond target thread \nto call the procedure. If this second thread hits the breakpoint at I, it will not be detected. An early \nversion of the author s debugger ldb demon\u00adstrated this problem (Ramsey 1992b). The problem cannot be \ndemonstrated with dbx (Linton 1990) or gdb (Stallman and Pesch 1991) because neither is ca\u00adpable of recovering \nif a procedure call hits a breakpoint while the main target thread is stopped at a break\u00adpoint. 3 Model \nusing communicating sequential processes The debugger, target, and breakpoint implementation are modeled \nas communicating sequential processes. The breakpoint implementation is to notify the de\u00adbugger every \ntime a thread successfully executes in\u00adstruction 1; to that end it can plant and remove traps, and it \ncan suppress or permit context switching. The model is abstract, hiding details. It does not matter whether \nthe debugger and target reside in the same address space or in different address spaces, nor does it \nmatter whether the breakpoint implementation resides in the target, the operating system, or the debugger. \nIt does not matter whether the target processor has a trace mode. The model is expressed in PROMELA, \na formal\u00adism whose original purpose was to model network protocols (Holzmann 1991). The correctness condi\u00adtion \nis given by embedded assertions, which state that the number of executions of I is equal to the num\u00adber \nof notifications of the debugger. The advantage of using PROMELA is that it comes with a checker that \nsearches a model s state space and checks for deadlocks, unreachable states, and violated assertions. \nPROMELA models need not be deterministic. When a choice is nondeterministic, the checker explores all \nalternatives, so it will find an execution leadlng to a violated assertion if one exists. Debugger thread \nO thread 1 trap at 1 catch trap at I detect breakpoint restore 1 plant trap at 1 s successor resume execution \nexecute 1 execute 1 trap at 1 s successor catch trap at 1 s successor note completion of breakpoint restore \n1 s successor plant trap at 1 resume execution execute 1 s successor executel s successor continue executing \ncontinue executing Figure2: Execution sequence showing missed breakpoint Syntactically, PROMELA models \nresemble C pro\u00adgrams. They use ! and? operators tosend andreceive messages over channels, d la CSP (Hoare \n1978). Al\u00adthough PROMELA permits models in which messages are passed asynchronously using buffered channels, \nthe model presented here uses only unbuffered channels; every send and receive is a synchronization point, \nas in CSP. Thk paper does not just describe the model; it con\u00adtains the model. The noweb system (Ramsey \n1992a) for literate programming (Knuth 1984) extracts both the paper and the model from the same source. \nThe source contains prose interleaved with definitions of named code chunks, Definitions are numbered \ncon\u00adsecutively with bold numerals. Code chunks contain source code and references to other code chunks. \nThe code chunks appear in an order suited to explanation, not necessarily in the order required by the \nPROMELA language. Chunk names appear italicized within angle brackets, e.g., (declarations 1). The 1 \nis the number of the chunk s first definition. 3.1 Processes of the model Five processes are used to \nmodel the interaction of de\u00adbugger, target, and breakpoint implementation. Two processes model threads \nof control in the target, one models the debugger, and one the breakpoint imple\u00admentation. The fifth \nprocess models the CPU, which advances the program counter, notifies the breakpoint implementation when \nit hits a trap, and notifies the active target thread when it successfully executes an instruction. The \nprocesses and communications be\u00adtween them are shown in Figure 3. Using only two threads keeps the state \nspace small; a single bit suffices to identify a thread. A small state space is necessary for exhaustive \nsearch to be practical. 1. (declarations I)= #define NTHREADS 2 #clef ine threadid bit This definition \nis continued in chunks 2-5, 8, 10, 18, 22, and 26. This code is used in chunk 29. thread(0) execute [0] \nQ ~.+me- Cent [11 thread (1) Figure 3: Processes The labels on the arcs in Figure 3 designate the fol\u00adlowing \nchannels: 2. (declarations l)+\u00adchan execute [NTHREADS] = [0] of {bit}; than cent [NTwADSl = [0] Of {bit}; \nthan trap = [0] of {threadi.d}; than resume = [0] of {bit}; than notify = [0] of {threadid}; Defines: \ncent, used in chunks 6 and 12, execute, used in chunks 6 and 12. notify, used in chunks 13, 24, and 25. \nresume, used in chunks 6, 24, and 25. trap, used inchunks6, 24, and 25. [01 is the size of the buffer \nassociated with the channel; these channels have buffers of length zero and are there\u00adfore synchronous. \n{bit } or {byte} shows the data in\u00adcluded in a message.1 The execute channels, one per thread, are used \nby the threads to ask the CPU to attempt to execute the instruction. If the attempt is successful, the \nCPU adjusts the PC and replies on the corresponding cent channel. If the attempt traps, the CPU sends \nthe unique id of the trapping thread on the trap channel to the breakpoint implementation. The breakpoint \nimplementation adjusts traps and tells the CPU to resume execution by sending on the resume channel. \nIf the trap indicates a new breakpoint event, the breakpoint implementation notifies the debugger that \na breakpoint occurred by sending the id of the breakpointing thread on the notify channel. 1resume and \nthe cent and execute channels are used only for synchronization, but PROMELA does not permit a message \nwithout data, so these channels carry the one-bit value x, which is always ignored. 3. (declarations \n1)+= bit x; /* sent/received on synch channels */ used in the model 3.2 Modeling the program counter \nand execution Also to reduce the size of the state space, the model has only one breakpoint. Modeling \nall possible values of the program counter is too expensive, but the val\u00adues partition naturally according \nto the instruction the program counter refers to: Break the breakpoint itself (instruction 1), Follow \nthe instruction(s) that can follow 1, Outs ide other instructions. The three sets are modeled by the \nfollowing constants. 4. (declarations 1)+= #define Break O/*pc at I*/ #clef ine Follow 1 }* pc in 1 s \nfollow set */ #clef ine Outside 2 /* all other PC s */ #define NPCS 3 /* no. of distinct pc s *I Defines: \nBreak, used in chunks 7, 12, 14, 17 21, 24, and 25. Follow, used in chunks 7, 17, 20, 21, 24, and 25. \nOuts ide, used in chunks 7, 9, and 12. The ability to plant traps is modeled by the array trapped, which \nrecords whether a trap instruction has been stored at a particular location: 5. (declarations l)+\u00adbool \ntrapped [lWCS] ; Defines: trapped, used in chunks 6, 17, and 19 21. The CPU repeats the following steps. \n1. Wait for a thread to attempt to execute the in\u00adstruction at p,c. 2. If the instruction is a trap, \nnotify the breakpoint implementation. When the CPU is told to resume, pc is unchanged. 3. If the instruction \nis not a trap, advance pc. 4. Ask the thread to continue executing.  There is only one debugger, but \nthere are multiple threads, and each one has its own pc and its own com\u00admunication with the CPU. When \nthe CPU notifies the debugger of a trap, it identifies the trapping thread. 6. (proctype$ 6)= proctype \nCPU() { threadid id = O; do :: execute [id] ?X -> if :: trapped [pc [id] ] -> t,r~p ! M ; resume?x :: \n! trapped [pc [id] ] -> (advance pc [id] 7) fi; cent [id] ! x; {possible context switch (change of id) \n27) od Defines: CPU, used in chunk 29. uses cent 2, execute 2, resume 2, trap 2, and trapped 5. This \ndefinition is continued in chunks 12, 13, 24, and 2.5. This code is used in chunk 29. A PROMELA proctype \ndefines the actions taken by a PROMELA process. C?x receives the due x on channel c; c ! x sends. do, \nif, and :: are comparable to the iteration, alternation, and bar (Cl) commands from Dijkstra s (1976) \ncalculus of guarded commands. Their semantics differ when all guards are false; the PROMELA if and do \nblock waiting for a guard to become true, but Dijsktra s iteration command termi\u00adnates, and his alternation \ncommand aborts. In thk example, the guards make the if command determin\u00adistic. The only significant source \nof nondeterminism in the model is represented by the chunk (possible context switch (change of id) 27). \nIf id can change after every attempt to execute an instruction, instructions from the two threads can \nbe interleaved arbitrarily. Sec\u00adtion 3.4 shows the part of the model that handles con\u00adtext switching; \nid can change only if such change is permitted by the breakpoint implementation. Since the program counter \nis an abstraction, advanc\u00ading it does not mean incrementing it. By the definition of follow set, a successful \nexecution at Break is guaran\u00adteed to be followed by an attempt to execute Follow; aside from that, any \ninstruction can follow any other. 7. (advance pc [id] 7)\u00ad if :: pc [id] == Break -> pc [id] = Follow \n:: pc [id] != Break -> /* any instruction can be next *I if :: pc [id] = Outside :: pc [id] = Break :: \npc [id] = Follow fi fi  uses Break 4, Follow 4, and Outside 4. This code is used in chunk 6. Because \nthe second if statement has no guards, an alternative is chosen nondeterministically. Thk non\u00addeterminism \nis not essential to the model, and it does not affect the correctness of the breakpoint implemen\u00adtation; \nit exists only to abstract away from the ex\u00adact sequence of instructions executed by a particular thread. \nAll threads begin execution outside the breakpoint. 8. (declarations 1)+s byte pc [NTHREADSI; 9. (initialize \nthread id s data 9)\u00adpc [id] = Outside;  Uses Outside 4. This definition is continued in chunks 11 and \n23. This code is used in chunk 30.  3.3 Counting events A correct breakpoint implementation guarantees \nthat the debugger is notified exactly once for every trip a target thread takes through the breakpoint. \nThe counter threadcount [id] counts how many times thread id has executed the breakpoint. The counter \nnot if ycount [id] counts how many times the debug\u00adger has been notified that thread id executed the \nbreakpoint. 10. (declarations 1)+S byte threadcount [NTHREADSI ; byte notif ycount [NTHSEADSI ; Defines: \nnotify count, used in chunks 11, 12, and 16. threadcount, used in chunks 11, 12, and 15. 11. (initialize \nthread id S data EI)+a threadcount [id] = O; notif ycount [id] = O; Uses not if ycount 10 and threadcount \n10. The thread model maintains threadcount []. If the program counter is Break, execution is attempted, \nand the program counter is no longer Break, then instruc\u00adtion I has been executed and the thread counter \nmust be incremented. If the program counter remains Break after the attempt, the attempted execution \nfailed, and the counter should not be incremented.2 The thread model also contains an embedded assertion \nstating that, unless the thread is in the middle of a breakpoint, the thread and debugger counts are \nthe same: 12. (p~octypes 6)+\u00ad proctype thread (threadid id) { do :: if :: pc [id] == Break -> execute \n[id] ! x; cent [id] ?X; (if pc # Break, increment thread count 14) :: pc [id] != Break -> execute [id] \n! x; cent [id] ?X f i; assert (pc [id] ! = Outside I I threadcount [id] == notif ycount [id] ) od 1 Defines: \nthread, used in chunk 29. Uses Break 4, cent 2, execute 2, notify count 10, Outside 4, and threadcount \n10. The debugger, when notified that thread id has hlt the breakpoint, increments not if ycount [id]. \n13. (proctypes 6)+\u00ad proctype debugger () { threadid id; do :: atomic { notif y?id -> (increment notif \nycount [id] 16) } od 3 Defines: debugger, used in chunk 29. Uses not if y 2. 21 discount the possibility \nthat instruction I branches to itself. Thki possibility breaks the model s assumption that Follow is \ndis\u00adtinct from Break. It also breaks real breakpoint implementations that rely on adjustment of traps \nby softwar~ only implementa\u00adtions that use a hardware trace bit can handIe such instructions. This possibility \nis unimportant in practice because the machines that have no trace blt are RISC machines, on which it \nis not useful to write programs containing instructions that branch to themselves. The PROMELA at omit \nkeyword groups actions into a single atomic action. When the debugger is notified, it atomically increments \nnot if ycount [id]. Without at omit, it might delay incrementing the counter until the thread left the \nbreakpoint, which would lead to a spurious violation of the assertion above. A thread has successfully \nexecuted Break if the pc has changed: 14. (if pc # Break, increment thread count 14)= if :: pc[id] != \nBreak -> (increment threadcount [id] 15) :: pc [id] == Break -> skip fi Uses Break 4. Thk code is used \nin chunk 12. Restricting the values of the counters to be in the range O. .3 keeps the state space small. \n15. (zncrement threadcount [id] 15)\u00adthreadcount [id] = (threadcount [id] + 1) X 4 Uses threadcount 10. \nThis code is used in chunk 14. 16. (increment notify count [id] 16)\u00adnotif ycount [id] = (notif ycount \n[id] + 1) % 4 Uses notify count 10. This code is used in chunk 13.  3.4 Implementing the breakpoint \nThe standard description of trap-based breakpoint im\u00adplementations refers to single stepping. To set \na break\u00adpoint at I, plant a trap at I. When the target program hits the trap, notify the debugger of \na breakpoint event. To resume execution after the breakpoint, restore the original instruction to 1, \nsingle step the machine to ex\u00adecute just the instruction at 1, and once again plant a trap at 1 and continue \nexecution. This model eliminates single stepping entirely, work\u00ading directly with trap instructions and \na follow set (modeled by Follow). It does not; however, preclude the use of hardware single stepping. \nOne of the opera\u00adtions in the model is planting traps at the locations in the follow set of an instruction. \nThk operation can be implemented either by computing the follow set and planting actual traps, or by \nsetting a trace bit on a machine with hardware single stepping. An active breakpoint is trapped either \non the in\u00ad struction of the breakpoint itself or the instructions in its follow set. The variable breakstat \ne keeps track of which state it is in, with the following invariant. 17. (invariant 17)Z breakstate == \nBreak &#38;&#38; trapped [Break] == 1 &#38;&#38; trapped [Follow] == O ! i breakstate == Follow ?&#38; \ntrapped [Break] == O &#38;&#38; trapped [Follow] == 1 Uses Break 4, breakstate 18, Follow 4, and trapped \n5. This code is used in chunks 20 and 21. 18. (declarations I)+\u00adbyte breakstate = Break; Defines: breakstate, \nused in chunks 17,20, 21,24, and 25. Uses Break 4. 19. (initialization 19)Z trapped [Breek] = 1; Uses \nBreek4 and trapped 5. This code is used in chunk 29. Changing the state preserves the invariant. 20. \n(fnovetraps to Break 20)S atomic { trapped [Break] = 1; trapped [Follow] = O; bre-~state = Break; assert \n(invariant 17) } Uses Bresk4, breskstate 18, Fo11ow4, and trapped 5. This code is used in chunks 24 \nand 25. 21. (move traps to Follow 21)= atomic { trapped[Brealc] = O; trapped[Follow] = 1; breskstate \n= Follow; assert (invariant 17) Uses Bresk4, breskstate 18, Follow 4,andtrapped5. This code is used \nin chunks 24 and 25. It is necessary to keep track of the state of each thread with respect to the breakpoint. \nAthreadis in the breakpoint ifit has trapped at Break, andit does not leave the breakpoint until it traps \nat Follow. Threads are initially outside the breakpoint. 22. (declarations l)+\u00adbit inbreek[NTHREADS]; \nDefines: inbresk, used in chunks 23 25. 23. (initialize thread id sdata 9)+= inbreak[id] = O; Uses inbreak \n22. The incorrect implementation described in the intro\u00adduction keeps track of the various states and \ndelivers a breakpoint event at the right time: 24. (proctypes 6)+-s proctype badbreakpointo { threadid \nid; do :: trap?id -> if :: breakstate == Break -> if :: !inbreak[id] -> notify!id; inbreak[id] = 1 ., \n.! inbreak[id] -> skip /* no event */ fi; (move traps to Follow 21) :: breakstate == Follow -> if :: \n:: inbreak[id] !inbreak[id] -> -> inbreak[id]skip = O fi; (move traps to Break 20) fi; resume ! x od \nk Uses Break 4, breekstate 18, Fo11ow4, inbreak22, notify2, resume 2, and trap 2. The two cases breakstate \n== Break and breakstate == Follow represent the two handlers described in the introduc\u00adtion. This implementation \nworks correctly with one thread, but with two threads it permits the erroneous execution sequence shown \nin Figure2. 21 To prevent such an occurrence, the processor must not be permitted to change contexts \nwhen a thread is in the middle of a breakpoint. If the processor can change contexts only when noswitch \n== 0, then the following breakpoint implementation works correctly. 25. (p~octypes 6)+= proctype breekpointo \n{ threadid id; do :: trap?id -> if :: breakstate == Break -> if :: !inbreak[id] -> notify!id; inbreak[idl \n= 1 :: inbreak[id] > assert(0) fi; noswitch = noswitch + i; (move traps to Follow 21) :: breakstate == \nFollow -> if :: inbreak[id] -> inbreak[id] = O :: !inbreak[id] -> assert(0) fi; (move traps to Break \n20); noswitch = noswitch -1 fi; resume ! x od Defines: breakpoint, used inchunk 29. Uses Break 4, breakstate \n18, Follow 4, inbreak 22, noswitch 26, notify 2, resume 2, and trap 2. When context switching is forbidden, \nbreakst ateal\u00adways reflects the informationin inbreak, and itispos\u00adsibleto take each skip from the bad \nbreakpoint imple\u00admentation and strengthen it to assert(0) in the good implement at ion. Because there \nis only one breakpoint, noswitch could be a bit, not acounter, but a counter generalizes to multiple \nbreakpoints. 26. (declarations)+= byte noswitch = O; Defines: noswitch, used in chunks 25 and 27. The \nmodel s CPU may change threads only when noswitch is zero: 27. (possible context switch (change of id) \n27)= if :: noswitch == O > (set id nondeterminzstically 28) :: noswit ch > 0 -> skip fi Uses Poswitch \n26. Thlscode is used in chunk 6. 28. (set id nondeterministically 28)= atomic { if ::id=O ::id=l fi \n > This code is used in chunk 27. When noswitchis nonzero, the nondeterministic choice of id models the \narbitrary interleaving of instructions that takes place in a multiprocessor, or the arbitrary interleaving \nthat takes place when threads are sched\u00aduled pre-emptively on auniprocessor.  4 Results For the code \nshown above to be a proper PROMELA model, the proct ype declarations must follow the other declarations, \nand there must be initialization actions that create the five processes and their associated chan\u00adnels. \n29. (PROMELA model 29)s (declarations 1) (proctypes 6) init { threadid id; atomic { (initialization 19) \n(for O ~ id< NTHREADS, initialize thread id s data 30); run thread(0) ; run thread (i) ; run debugger \n() ; run breakpoint () ; run CPU(2) 3 3 Uses breakpoint 25, CPU 6, debugger 13, and thread 12. Thk chunk \nexpands to the complete PROMELA model. 30. (for O ~ id < NTHREADS, initialize thread id s data 30)\u00adid \n=O; do :: id < NTHREADS -> (initialize thread id s data 9) if :: id == NTHREADS -1 -> break ::id<NTHFIEADS \n-1-> id=id+l fi od This code k used in chunk 29. The full model is 169 (narrow) lines long, includ\u00ading \nboth good and bad breakpoint implementations. The PROMELA checker takes about 4,2 seconds on a SPARC \n10 to check all possible executions for viola\u00adtions of the embedded assertions, By finding none, it shows \nthat the suppression of context switching in the correct implementation is sufficient to guarantee that \nall executions of 1 are reported to the debugger. If the bad breakpoint implementation is used instead \nof the good one, the checker takes less than a second to find an execution that leads to an assertion \nviolation. Such an execution was used to prepare Figure 2. The result may be stated thus: While the memory \nat I holds the original in\u00ad struction and not a trap, only the thread that trapped at I may be permitted \nto execute.  5 Related work Caswell and Black (1990) describe the implementation of a multithreaded \ndebugger. They mention that they use a breakpoint implementation based on trapping and single-stepping, \nbut they do not identify the pitfall. Redell (1989) alludes to the problem, indicating that careful design \nis necessary in the debugger s treatment of threads and events. Elsewhere, I have described in detail \na breakpoint implementation based on the model presented here (Ramsey 1992b). Much of the work on breakpoints \nhaa focused on per\u00adformance, Kessler (1990) describes a fast implemen\u00adtation of code breakpoints; Wahbe \n(1992) describes simulations of four implementations of data break\u00adpoints. In a parallel environment, \ndebugging work can be offloaded onto a second processor (Aral, Gert\u00adner, and Schaffer 1989). Alternatively, \nmonitoring and logging can be done by a special-purpose coproces\u00adsor (Gorlick 1991). All these approaches \nuse either branch or coprocessor instructions to transfer control from target to debugging code without \nkernel interven\u00adtion, avoiding the overhead of trap handling and con\u00adtext switching. The authors with \nworking implementa\u00adtions describe performance improvements of three or\u00adders of magnitude over trap-based \nbreakpoints as im\u00adplemented on Unix. 6 Discussion Breakpoints may be implemented either in the operat\u00ading \nsystem or in the debugger itsel~ the choice does not afFect the model used here, Although they use similar \nbreakpoint implementations, the Topaz teledebugger puts the breakpoint implementation in the operating \nsystem (Redell 1989); ldb, the author s Unix telede\u00adbugger, puts it in the debugger (Ramsey 1992b), The \nmodel assumes it can plant trap instructions in the in\u00adstruction stream of the target program, and that \nit will be notified when the target program encounters a trap. The model also suits a machine with a \ntrace mode that causes a trap after the execution of every instruc\u00adtion. The trap-based implementation \nof breakpoints is usually explained in terms of instruction-level single stepping. This explanation misleadingly \nsuggests that breakpoints can be implemented using simple, sequen\u00adtial code. In fact, the implementation \nmust be writ\u00adten in a kind of continuation-passing style, using event handlers to match continuations \nwith events. Thinking in terms of traps at follow sets makes it easier to un\u00adderstand the real implementation. \nIt also clarifies the relationship between an implementation that uses only traps and one that uses a \nhardware trace mode; plant\u00ading or suspending traps in a follow set is equivalent to setting or clearing \na trace bit in a program status word. The model forbids context switching when a thread is in the middle \nof a breakpoint. On a uniprocessor switched among several threads, the obvious interpre\u00adtation is to \nprevent switchhg. On a uniprocessor run\u00adning only a single thread, the interpretation is that the debugger \nmust not use the thread s stack to call a procedure (e.g., during expression evaluation) while context \nswitching is forbidden. On a shared-memory multiprocessor, only the processor running the thread that \nhit the breakpoint may be permitted to run; all the other processors must be stopped before the break\u00adpointing \nthread executes instruction 1. The debugger in the model presented here is re\u00adally monitoring, not debugging, \nbecause the breakpoint implementation always resumes execution immediately after encountering the breakpoint. \nA richer model would let the debugger decide when to resume execu\u00adtion, but it would not change the result. \nA real de\u00adbugger must enable users to evaluate expressions when the target is stopped at a breakpoint. \nSuch expressions include calls to procedures, which may themselves hit or re-enter the same breakpoint. \nTo permit context switching from primary code to expression-evaluation code, the debugger must delay \nrestoration of 1 until a suspended evaluation (or the original code) is ready to resume at 1. When this \ndelay is correctly imple\u00admented, a debugger can build up an arbitrary num\u00adber of suspended evaluations, \nall of which have hit the breakpoint at 1. The PROMELA formalism and tools were designed to help validate \nnetwork protocols, but they can be use\u00adfully employed on a wider range of problems. Designers and implementors \nof programming-environment tools should consider using PROMELA (or similar tools) to model interactions \nin their systems. 23  References Aral, Ziya, Ilya Gertner, and Greg Schaffer. 1989 (May). Efficient \ndebugging primitives for multiprocessors. Proceedings of Third International Conference on Architectural \nSupport for Programming Languages and Operating Systems, in a special issue of SIGPLAN Notices, 24:87-95. \nBruegge, Bernd. 1985 (September). Adaptability and Portability of Symbolic Debuggers. PhD thesis, Carnegie \nMellon University. Caswell, Deborah and David Black. 1990 (January). Implementing a Mach debugger for \nmultithreaded applications. In Proceedings of the Winter USENIX Conference, pages 25-39, Washington, \nDC. Digital Equipment Corporation. 1975. DDT Dynamic Debugging Technique. Maynard, MA. Dijsktra, Edsger \nW. 1976. A Discipline of Programming. Englewood Cliffs, NJ: Prentice-Hall. Gorlick, Michael M. 1991 (December). \nThe flight recorder: An architectural aid for system monitoring. Proceedings of the A CM/ONR Workshop \non Parallel and Distributed Debugging, in SIGPLAN Notices, 26(12) :175 183. Hoare, C. A. R. 1978 (August). \nCommunicating sequential processes. Communications of the ACM, 21(8):666-677. Holzmann, Gerard J. 1991. \nDesign and Validation of Computer Protocols. Englewood Cliffs, NJ: Prentice Hall. Kessler, Peter B. 1990 \n(June). Fast breakpoints: Design and implementation. Proceedings of the ACM SIGPLAN 90 Conference on \nProgramming Language Design and Implementation, in SIGPLAN Notices, 25(6):78-84. Knuth, Donald E. 1984. \nLiterate programming. The Computer Journal, 27(2):97-111. Linton, Mark A. 1990 (June). The evolution \nof Dbx, In Proceedings of the Summer USENIX Conference, pages 211-220, Anaheim, CA. Ramsey, Norman. \n1992a (August). Literate-programming tools need not be complex. Technical Report CS-TR-351-91, Department \nof Computer Science, Princeton University. Submitted to IEEE Soflware. . 1992b (December). A Retargetable \nDebugger. PhD thesis, Princeton University, Department of Computer Science. Also Technical Report CS-TR-403-92. \nRedell, David D. 1989 (January). Experience with Topaz TeleDebugging. Proceedings of the ACM SIGPLAN/SIGOPS \nWorkshop on Parallel and Distributed Debugging, in SIGPLAN Notices, 24(1):35-44. Stallman, Richard M. \nand Roland H. Pesch. 1991. Using GDB: A guide to the GNU source-level debugger, GDB version 4.0. Technical \nreport, Free Software Foundation, Cambridge, MA. Wahbe, Robert. 1992 (September). Efficient data breakpoints. \nProceedings of the Fifth International Conference on Architectural Support for Programming Languages \nand Operating Systems, in SIGPLAN Notices, 27(9):200-212.  \n\t\t\t", "proc_id": "174675", "abstract": "<p>It is common for debuggers to implement breakpoints by a combination of planting traps and single stepping. When the target program contains multiple threads of execution, a debugger that is not carefully implemented may miss breakpoints. This paper gives a formal model of a breakpoint in a two-threaded program. The model describes correct and incorrect breakpoint implementations. Automatic search of the model's state space shows that the correct implementation does miss a breakpoint. The results apply even to debuggers like dbx and gdb, which are apparently for single-threaded programs; when the user evaluates an expression containing function calls, the debugger executes the call in the target address space, in effect creating a new thread.</p>", "authors": [{"name": "Norman Ramsey", "author_profile_id": "81100300481", "affiliation": "Bell Communications Research, Morristown, NJ", "person_id": "PP14110628", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/174675.175188", "year": "1994", "article_id": "175188", "conference": "POPL", "title": "Correctness of trap-based breakpoint implementations", "url": "http://dl.acm.org/citation.cfm?id=175188"}