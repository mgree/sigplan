{"article_publication_date": "02-01-1994", "fulltext": "\n Building Interpreters by Composing Monads Guy L. Steele Jr. Thinking Machines Corporation 245 First \nStreet Cambridge, Massachusetts 02142 (617) 234-2860 gls@think. com Abstract: WJe exhibit a set of functions \ncoded in Haskell that can be used as building blocks to construct a variety of interpreters for Lisp-like \nlanguages. The building blocks are joined merely through functional composition. Each building block \ncontributes code to support a specific feature, such as numbers, continua\u00adtions, functions calls, or \nnondeterminisrn. The result of composing some number of building blocks is a parser, an interpreter, \nand a printer that support exactly the expression forms and data types needed for the com\u00adbined set of \nfeatures, and no more. The data structures are organized as pseudomonades, a generalization of monads \nthat allows composition. Functional composition of the building blocks implies type composition of the \nrelevant pseudomonads. Our intent was that the Haskell type resolution sys\u00adtem ought to be able to deduce \nthe appropriate data types automatically. Unfortunately there is a deficiency in current Haskell implementations \nrelated to recursive data types: circularity must be reflected statically in the type definitions. We \ncircumvent this restriction by applying a purpose\u00adbuilt program simplifier that performs partial evaluation \nand a certain amount of program algebra. We construct a wide variety of interpreters in the style of \nWadler by starting with the building blocks and a page of boiler\u00adplate code, writing three lines of code \n(one to specify the building blocks and two to (redundantly) specify type compositions), and then applying \nthe simplifier. The resulting code is acceptable Haskell code. We have tested a dozen different interpreters \nwith various combinations of features. In this paper we dis\u00adcuss the overall code structuring strategy, \nexhibit sev\u00aderal building blocks, briefly describe the partial evalu\u00adator, and present a number of automatically \ngenerated interpreters. Permission to copy without fee ell or part of this material is granted provided \nthat the copies era not made or distributed for direct commercial edvsntege, the ACM copyright notica \nend the title of the publication and its date appaar, and notice ia given thet copying is by permission \nof the Association for Computing Machinery. To copy otherwiee, or to republish, requires a fee end/o? \nspecific permission, POPL 94-1/94, Porlfsnd Oregon, USA @ 1994 ACM O-69791 -6364D41W1 ..$3.50 1 Introduction \nI really liked Phil Wadler s work on monads [15, 16]. But I was not entirely satisfied with the methodology \nfor constructing new interpreters by writing a single in\u00adterpreter and then plugging in various monads. \nWhile it was not necessary to modify the code of the interpreter, it was necessary to alter (by hand \nthe data structure definitions for both the input expressions and the output values. It seemed to me \nthat this could be automated. Another problem was that, while there were many monads to choose from, \nthey were one to a customer. You could have an interpreter with state, or an inter\u00adpreter with continuations, \nbut not an interpreter with continuations and state. I had a vision of building blocks, like Legos or \nTinker\u00adtoys, that could be used interchangeably and in com\u00adbination to build interpreters. It seemed \nthat if they could be combined by functional composition, then the Haskell [2] type system, or an extension \nof it, ought to be able to deduce the relevant data types automatically. It can be done. With the function \ndefinitions pre\u00adsented in this paper, the value of the Haskell expression complete (nondet erminist i.c \n( cbv i.nt erpret er) ) is in fact a complete nondeterministic call-by-value interpreter indeed, not \nonly an interpreter, but a parser and a printer as well. Similarly, the result of complete (cbn (numbers \ninterpreter)) is a complete call-by-name numbers interpreter; and the expression complete (cent inuat \nion (nondet erministic (cbv (numbers interpreter)))) produces a complete continuation nondeterministic \ncall\u00ad by-value numbers interpreter. 2 Pseudomonades We structure our interpreter building blocks by \nusing pseudomonades, a generalization of monads that permits infixl 4 k infixl 1 <<, #, >> type Unitfn \np q =p -> q type Bindfn pq=q-> (p -> q) -> q type Pseudobindfn p q = See text Monad qr->q-> (p->r) ->r \ndata Monad p q = Monad (Unitfn p q) (Bindfnp q) unit :: Monad p q -> Unitfn p q unit (Monad u b) = u \n bind :: Monad p q -> Bindfn p q bind (Monad u b) = b idmonad :: Monad p p idmonad = Monad (\\x -> x) \n(\\z k -> k z) data Pseudomonas p q = Pseudomonas (Unitfn p q) (Pseudobindfn p q) pseudounit :: Pseudomonas \np q -> Unitfn p q pseudounit (Pseudomonadu pb) = u pseudobind :: Pseudomonas p q -> Pseudobi.ndfn p q \npseudobind (Pseudomonadu pb) = pb iata Bindtempp q a b c = Bind2 (p, q) I Bind3 (a, b, c) X<<y = Bind2 \n(x, y) (Bind2 (x, y)) #z = Bind3 (x, y, z) (Bind2 (x, y)) >> f = bindy x f (Bind3 (x, y, z)) >> f = pseudobindz \ny x f m&#38;p = Monad (unit m . pseudounit p) (\\Z k > Z <<m>> (\\W -> w <<m#p>> k)) Figurel: Haskell code \nfor supporting pseudomonads composition. The theory ofpseudomonadsis described in acompanion paper [n]. \nThe support code in Figure 1 is taken verbatim from that paper. In order to convey necessary type information, \nit is convenient to reify monads and pseudomonads. We represent a monad in Haskell as an algebraic datatype \nMonad encapsulating the unit and bind operations for the monad. Note that we use the name Monad as both \natype constructor and a data constructor, a convenient pun permitted by Haskell. We then define generic \nunit and bind operations. In Wadler s style, one speaks of the type aandthe type M ato which the type \nconstructor Mmapsa; the monadin question isnot itselfan object ofthe language, but merely the conceptual \ntriple (M, unitM, bindM). In our style, a monad is an object of type Monad a b, the type ofmonads that \nmap type atotypeb; thusb cor\u00adresponds to Wadler s type M a. As anexample, the declaration ofidmonad in \nFigurel defines the usual identity monad. (A word about syntax: Wadler used Haskell infix no\u00adtation for \nthe various monad binding operations, writing x bindM f instead ofbindM x f. Our generic bind operation \ntakes three arguments: a monad, an object, and afunction. However, the infix notationis quite con\u00advenient, \nparticularly for exhibit ing the associative law for monads, so we have devised akluge: we define two \nHaskell infix operators <<and >> so that we may write bind m x f asx <<m>> f. The code for this is alsoin \nFigure 1.) A pseudomonas is only a slight generalization ofa monad. A pseudomonas encapsulates two operations \ncalled pseudounit and pseudobind. The pseudouni,t operation is identical in its nature to unit, but the \npseudobind operation takes an extra argument, before the object and the function to reapplied, that isitselfa \nmonad. The idea isthatpseudobind unwraps an object oftype q, revealing an object oftypep. This may then \nbe fed to the function, but the function need not pro\u00adducearesult oftype q; instead, itmay produce aresult \nof some other type r. The monad argument must be oftype Monad q r, thus specifying awayto take values \nof type q to type r. The motivation is that the pseu\u00addobinding operation might not invoke the function \nafter all, in which case it needs some other way to produce a result of type r. (More about syntax: The \ngeneric pseudobind opera\u00adtiontakes fourarguments. Wedefine #asyet another in\u00adfixoperator sothatwe maywrite \npseudobind p m x f as x <<m#p>> f. This syntax happens to be used only once in the code figures in this \npaper, in the definition of&#38;in Figure 1.) In short, a pseudomonas is simply a monad that has been \nparameterized by another monad, in exactly the same manner that Wadler parameterized an interpreter by \na monad. Pseudomonades are assumed (and should be proved) to obey three laws analogous to those for monads. \nThe monad laws, expressed in unit/bind form, are: Left unit: unit ma<<m>> f ~ f a Right unit: x <<m>> \nunit m 2Z x Associative: x <<m>> (\\a -> f a <<m>> g) ~ (x <<m>> \\a -> f a) <<m>> g (Remember that <<.. \n.>> has lower syntactic prece\u00ad dence than function application.) The analogous laws for pseudomonades \nare: Left unit: unit p a <<m#p>> f ~fa Right unit: x <<m#p>> (h . unit p) = h x Associative: x <<m#p>> \n(\\a -> f a <<m#p>> g) E (x <<idmonad#p>> \\a -> f a) <<m#p>> g The composition operator m&#38;p composes \namonadm and apseudomonadp to produce what mightbe anew monad. If the monad obeys the three monad laws \nand the pseudomonas obeys the three pseudomonas laws, then the composition necessarily obeys theleft \nunit and right unit monad laws. A separate proof must be sup\u00adplied that the resulting monad obeys the \nmonad asso\u00adciative law (and this is consistent with the experience of Moggi [6] and others that monads \ndo not compose in general). (We note in passing that there is in fact a more general theory of pseudmonads \nin which the first argument to a pseudobind operation is a pseudomonas rather than a monad. The composition \noperator &#38; then combines two pseudomonades to produce a third pseudomonas: pb&#38;pa = Pseudomonas \n(pseudounit mb . pseudounit pa) (\\pZ X f > X <<pz#pb>> (\\W -> w <<pz&#38;pb#pa>> f ) ) This composition \noperator is associative (here we gloss over a subtle point about infinite regress in the proof) and its \nleft and right identities are the identity pseu\u00ad domonas. This more general theory is not required for \nthe remainder of this paper but provided substantial theoretical motivation along the way.) (But hold \non, here! I have pulled a fast one! The type definition for Ps eudobindf n in Figure 1 is not a legitimate \nHaskell type declaration; it has a free type variable. True enough, and that is entirely the point: that \nis the extra hole, the escape hatch that allows an arbitrary monad (or pseudomonas, in the more general \ntheory) to be plugged in. One might try to fix the prob\u00adlem by introducing an extra type variable: type \nPseudobindfn p q r = . . . but this soon propagates throughout the code and be\u00ad comes messy. Moreover, \nin the general theory it requires yet another type variable s: type Pseudobindfn p q r = (Pseudomonas \nq r s) ->q->(p->r)->r and one gets caught in an infinite regress. This regress is part of the fundamental \nstructure of the paradigm. Another idea is to wimp out and not say exactly what that first argument is: \ntype Pseudobindfn p q r x = x->q->(p->r) >r and hope that the Haskell type inference system will be \nhappy with that; but it is not. The best solution is existential type variables; we would like to write \nthe first definition shown and to have r treated existentially. I tried this out in the Chalmers Haskell \nimplementation, which supports an experimental version of existential type variables. Unfortunately, \nthat implementation im\u00adposes a restriction to the effect that existential type vari\u00adables must not escape \n; but this application requires that they do escape. We recommend that Haskell imple\u00admentors consider \nfull support for unrestricted existential type variables. Our use of a program simplifier for the work \nreported here circumvents the restrictions of the Haskell type system.) 3 Towers of Data Types An interpreter \nuses objects of two types: terms (input expressions) and values (results). When an interpreter is extended \nwith a new capability, both of these types may require modification. For example, to add numeric processing \nto an interpreter, the value type must be ex\u00adtended to represent numbers and the term type must be extended \nto represent operations such as addition. A building block takes an interpreter that maps terms of type \nt to values of type v and produces a new inter\u00adpreter that maps terms of type t to values of type v . \nIt does this through the use of two pseudomon\u00adades, one of type Pseudomonas t t and one of type Pseudomonas \nv v . The same pseudomonades are used to construct a new parser and printer. A parser maps strings into \nterms; a printer maps values into strings. The old parser is extended to produce terms of the new type \nt . The old printer is extended to accept values of the new type v . Composing multiple building blocks \nresults in com\u00adposing multiple pseudomonades. The result is to con\u00adstruct two towers of data types. The \nfinal parser maps strings to the type at the top of the term tower; the final interpreter maps these \nterms to the type at the top of the value tower; and the final printer prints these values. See Figure \n2. So far, this is all fairly straightforward. The final fillip is that we wish both the final term type \nand the final value type to be recursive. For example, we want a term (+ z g) to be able to contain any \ntwo terms z and y, and these terms must be of the topmost type in the tower. It is no problem to express \nthis implicitly, but it causes a problem in the Haskell type checker. We deal with this problem later. \n term value tnT3 irz :: :: Monad Monad T2 T1 T3 T2 tower T,, interpr top tower Vtl P2 PI :: :: Package \nPackage T2 T1 V2 VI T T V V VE VE MT1 :: Monad To T1 P(J :: Package To lb T V VE ~? ~\\ mVz :: Monad \nV2 V3 mVz : : Monad V1 V2 -m E mVl :: Monad V. V1 .2 G $ -2 : WI G / T2 Figure 2: Towers of types Packages \nit produces a value at the current level and then, one way or another, applies the unit operation for \na monad In effect, we need to compose not just functions but sets that will project the type to the top \nof the tower. (This of functions. Haskell modules are not first-class in the monad is constructed as \na composition of pseudomonades language, so we had to invent some other representation as the building \nblocks are composed.) for sets of functions. We use a simple association-list There are eight kinds of \nroutines: representation (a list of routines, where if there is more than one routine of the same type, \nthe one earliest in ParseR the parser the list shadows the others. We call this structure a Int erpR \nthe interpreter package. ShowvalR the printer (We use an association list rather than, say, an 8-tuple \nComplainR signals an error for the sake of modularity; not all building blocks are MakenumR constructs \na number value concerned with all eight routine types. The association-MakefunR constructs a function \nvalue list structure allows us to add new routine types without Appl yR applies a function modifying \nall previously written building blocks.) NameR a string that names the interpreter The necessary code \nfor packages is shown in Figure 3. Not every package will contain a routine of every kind. In this figure \nt and v stand for the current term and For example, there is no MakenumR routine unless thevalue types, \nthat is, the types at the level of the type numbers building block has been included. These auxil\u00adtower \nto which the package corresponds; t and v iary routines provide a way for one building block to usestand \nfor the term and value types at the top of the facilities provided by another. For example, as we shalltower. \n(The type ve stands for the type of values stored see, the cent inuat ions building block uses a MakefunR \nin the environment. ) Thus the interpreter accepts a routine to construct a function representing a continu\u00adterm \nat the current level of the type tower but produces ation; of course, it cannot do this unless the cbv \nor cbn a value at the top of the type tower. It does so because lata Routine t v t v ve = ParseR (String \n-> [(t , String)]) I InterpR (t -> E(Stz-ing, ve)l -> v ) I ShoWvalR (v -> String) ComplainR (String \n->-v ) MakenumR (Int -> v ) MakefunR ((v -> v ) -> ve) ApplyR (V > V > V : NameR String i ta Package \nt v t v ve = Package-[Routine t v t>> v)) ve] Ipdate (Package pkg) new = Package (new ++ pkg) )arser \n(Package p) = parse p where parse (ParseR f:_) = f parse (_:rest) = parse rest mterpr (Package p) = \ninterp) p where interp (InterpR f:_) = f interp (_:rest) = interp rest :howvalr (Package p) = showval \np where showval (ShowvalR f:_) = f showval (_:rest) = showval rest :omplainr (Package p) = complainJ \np where complain (ComplainR f:_) = f complain (_:rest) = complain rest mlrenumr (Package p) = makenum \np where makenum (MakenumR f:_) =f makenum ( _:rest) = makenum> rest ~akefunr (Package p) = makefun p \nwhere makefun (MakefunR f:_) = f makefun (_:rest) = makefun rest Lpplyr (Package p) = apply p where \napply (ApplyR f:_) = f apply (_:rest) = apply rest mmer (Package p) = name p where name (NameR x:_) \n= x name (_:rest) = name rest Figure3: Support code for packages building block has been included to \nprovide a definition of such a routine. The update function adds a set of new routines to a package, \npossibly shadowing old ones of the same type. The various access functions parser, interpr, showvalr, \netc., extract aroutine ofthe appropriate type from a package; the result is undefined if the package \ncontains no routine of the required type. iata TermZ = Bogon iata ValueZ = Wrong interpreter tmt tmv \ntop = Package [ParseR parseZ, InterpR interpZ, ShowvalR showvalZ, ComplainR complainZ, NameR nameZ] where \nparseZ s = [(unit tmt Bogon, s)] interpZ Bogon _ = complainr top invalid expression complainZ s = unit \ntmv Wrong showvalZ Wrong = <wrong> nameZ = interpreter Figure4: The base interpreter prepackage 5 The \nBase Interpreter The base interpreter, the one on which all variants are built andon which the towers \noftypes are erected, is shown in Figure 4. It is a null interpreter. It interprets a completely boring \nlanguage: the only term is Bogon. Every attempt to parse a string fails and produces a Bogon actually \nnot Bogon, but Bogon projected tothe top of the term type tower. An attempt to interpret Bogonresults \nin a complaint. Complaining produces the value Wrong actually not wrong, but Wrong projected to the top \nof the value type tower. The value Wrong prints as <wrong> . The name of the base interpreter is Interpreter \n. How are types projected to the top of the tower? The interpreter function takes two monads asargu\u00adments: \ntmt (the Top Monad for Terms) and tmv (the Top Monad for Values). These monads preconstructed as building \nblocks are composed and then passed back down to alllevels as arguments. Theunit operations for thse \nmonads are used byparsez andcomplainzto lift terms and values, respectively, to the top of the tower. \nThe interpreter function takes a third argument, which is also passed back down from the top of the tower. \nThis is top, the completed top-level interpreter package. Note that interpZ does not call complainZ directly; \nit calls thecomplaint function of the top-level package. If any of the building blocks should shadow \nthe complaint function with a new one, interpz will use the new one, not complainz. 6 Completing the \nInterpreter The interpreter function shownin Figure 4isnotre\u00adally a complete, working interpreter; it \nis merely afunc\u00adtion that needs some argumentsto produce a package of routines. We call such a function \na prepackage; given complete prepkg = top where data Term = Bogon top = prepkg idmonad idmonad top data \nValue = Wrong type Term = TermZ --** type Value = ValueZ --** interp.pkg = complete interpreter --** \nparse = parser interp_pkg interp = interpr interp_pkg showval = showvalr interp.pkg complain = complainr \ninterp_pkg makenum = makenumr interp.pkg makefun = makefunr i.nterp_pkg apply = applyr interp.pkg name \n= namer interp_pkg Figure5: Code tocomplete a constructed interpreter two monads and a top-level package \nit will produce a new package (that may be at any point in the tower, possibly at the bottom or the top). \nWe need to feed three appropriate arguments to the prepackage. It is also handy to pull the constructed \npackageapart into individualfunctions withthe custom\u00adary names. The necessary code is shown in Figure \n5. The function complete is deceptively simple. Given a prepackage, it simply caps the tower and returns \nthe top-level package top. How is top computed? Byfeed\u00ading three arguments to the given prepackage. The \nfirst two arguments are simply the identity monad; whatever package is returned by the prepackage will \nalready beat the top of the tower, so the identity monad suffices to lift terms and values ofthat packageto \nthe top. The third argumenti stop,thetop-level package. It should now be apparent that we are depending \ncritically on the fact that our implementation language, Haskell ,is lazy. Computingthe value oftop requires \nthat top be passed as an argument. The result of the expression complete interpreter is in fact a complete \n(null) interpreter package. The re\u00admaining definitions simply name the individual routines in this package. \nFinally, it is necessary to make a working Haskell main program. The driver code in Figure 6 implements \na read-eval-print loop with an initial friendly greeting and a prompt before each interaction. Note that \nthe parse function, according to the usual Haskell style, actually produces a list of possible parses; \nread_ eval_print simply uses the first parse and discards any others. When we apply our special-purpose \nprogram simpli\u00adfier (more about this in Section 9) to all the code in Figures 1-5, the result is as shown \nin Figure 7. Here is a sample interaction with this interpreter (all sample interactions in this paper \nare transcripts of ac\u00adtual console sessions with running code using the driver parse s = E (Bogon, s) \n] interp Bogon _ = complain invalid expression complain s = Wrong showval Wrong = <wrong> name = interpret \ner Figure 7: Simplified code for the completed base inter\u00ad preter of Figure 6): Welcome to the interpreter! \n>3 <wrong> > (2+3) <wrong> > \\x. x <wrong> > Krazy Kat <Wrong> Every thing is <wrong>! How boring! 7 \nThe Numbers Building Block The numbers building block extends the term data type to include numeric constants \nCon n and addition oper\u00adations Add z y, where n k a Haskell integer and z and y are top-level terms. \nIt also extends the value data type to include numeric values Num n. See Figure 8. In the definition \nof the type TermN, t refers to the top-level term type and t refers to the term type at the next level \ndown from the numbers package. Similarly for v and v in the definition of ValueN. The pseudomonas mTN \nis used to map from type t to the type TermN t t. It augments the type t with new possibilities Con \nn and Add z y for terms. The pseudomonas mVN is used to map from type v to the type ValueN v v. It \naugments the type v with the new possibility Num n. (It may seem strange that mVNbind is not coded more \nsimply as mVNblnd m (Num x) f = unit m (Num x) mVNbind m (OtherVN x) f = f x rather than using the intermediate \nname qxfoo. It is in fact strange and a kluge. The form in the figure tricks the program simplifier into \napplying a certain transfor\u00ad mation at just the right time. It s a hack. I m sorry.) The fun~tion nnmb~rs, \nunlike interpreter, is not a prepackage; it is a building block. A building block read_eval_print s = \nshowval (interp exp [1) where ((exp, _) : _) = parse s nain = appendChan stdout ( Welcome to the ++ \nname ++ !\\n> ) abort (readChan stdin abort (\\ contents -> process (lines contents))) where process [1 \n= done process (X:XS) = appendChan stdout (read_eval_print x) abort (appendChan stdout \\n> abort (process \nXS)) Figure6: Code to drive a constructed interpreter takes an old prepackage and produces anew prepack-To \nincorporate the numbers facilities into an inter\u00adage. Thus interpreteris a suitable first argument for \npreter, all we need to do is replace the three lines marked numbers; the result, a prepackage, is a suitable \nargu- ** in Figure 5 with the following: merit to complete. This prepackage accepts the usual type Term \n= TermN Term TermZthree arguments trot, tmv, and top and returns anew type Value = ValueN Value ValueZpackage. \nThis package is produced by updating the old int erp_pkg = complete (numbers interpreter) package with \nnew routines five ofthem, in this case. And where did this old package come from? Ah, it When we then \napply our program simplifier to all the must reconstructed from the old prepackage originally code in \nFigures 1 5 plus Figure 8, the result is as shown given to the building block. The old prepackage will \nin Figure 9. need three arguments. It needs a monad that will lift A sample interaction with this interpreter: \n terms of the old package to the top. Well, tmt will lift terms from the new package to the top; and \nmTN Welcome to the numbers interpreter! will lift terms from the old package to the new package. >3 All \nwe need to do is compose tmt and mTN with the 3 pseudomonas composition operator &#38;. Voi/dYSimilarly \n> (2+3) for tmv andmVN. The top-level package top is passed 5 down unchanged. > \\x. x All this structure \nis quite stereotypical and appears <wrong> more or less unchanged in every building block. Now > Krazy \nKat let us examine the particulars of the numbers building <wrong> block. > ((1+2)+(3+(4+5))) The parser \nis bulky (as parsers are wont to be, because 15 they must distinguish badinputs from good) but quite \nIt does indeed process numerical expressions and rejectstraightforward. There are three possibilities \nparse a everything else. constant ddd to produce the term Con n, parse an ad\u00addition operation (NY) toproduce \nthe term Add z y,or parse the way the old package parses. In the first two 8 Recursive Types in Haskell \ncases, theterm islifted tothetop of theterm type tower The complete function is where the knot is tied, \nre\u00adby applying unit trot. sulting in recursive term and value types; top is a fix-The interpreter interpN \nand printer showvalN are point. Unfortunately, existing implementations of thepretty much what you would \nexpect after reading Haskell type system choke on this circularity. The lan\u00adWadler s paper [16]. Interpreting \na constant Con n re\u00adguage specification is hazy, so it is hard to determinesults in an equivalent value \nNum n, lifted to the top of the whether this is a language restriction or an implemen\u00advalue type tower \nby applying unit tmv. The code for tation deficiency. The nub of the matter is that Haskellinterpreting \nan Add operation is just like Wadler s, with allows recursive and mutually recursive datatypes, pro\u00adinterpr \ntop in place of interp, <<tmv>> in place of vided that an algebraic datatype intervenes [2]. In bindM \n, and slightly more elaborate complaining when current implementations this is apparently a static re\u00adnot \nboth operands are numbers. quirement; that is, any circularity of definition mustFinally, note that the \nname of the interpreter in the be textually apparent rather than deduced by the typenew package is constructed \nby prepending the word mechanism. If the program simplifier is not used, thennumbers to the name of the \nold package. the type checker discovers only dynamically for the type iata TermN t)) t = Con Int I Add \nt t I OtherTN t iata ValueN v v = Num Int 1 OtherVN v RTN = Pseudomonas (\\x -> OtherTN x) mTNbind where \nmTNbind m (Con x) f = unit m (Con x) mTNbind m(Add xy) f =unit m(Add xy) mTHbind m (OtherTN x) f = f \nx RVN = Pseudomonas (\\x -> OtherVN X) mvlibiml where mVNbind m = qxfoo where qxfoo (Num x) f = unit m \n(Num x) qxfoo (OtherVN x) f = f x mmbers oldprepkg tmt tmv top = update oldpkg [ParseR parseN, InterpR \ninterpN, ShowvalR showvalN, MakenumRmakenumN, NameR nameN] where oldpkg = oldprepkg (trot &#38; mTN) \n(tmv k mVN) top parseN s = (peon s ++ psum s ++ parser oldpkg s) where psum s = [(unit tmt (Add x y), \ns5) I ( ( :s1) <-[dropWhile isSpace s], (x, s2) <-parser top sI, ( + :s3) <-[dropWhile isSpace s2], (y, \ns4) <-parser top s3, ( ) :s5) <-[dropWhile isSpace s4]] peon (c:s) I (C >= o %?2c <= 9 ) =pcon s (oral \nc -ord 0 ) Where peon (c:s) n I (c >= O &#38;&#38; c <= 9 ) =pcon s (iO*n+ (oral c -ord O )) peon s n \n= [(unit tmt (Con n), s)] peon _= [1 interpN (Con x) _ = unit tmv (Num X) interpN (Add x y) env = interpr \ntop x env <<tmv>> (\\u > interpr top y env <<tmv>> (\\v -> case (u, v) of (Numj, Numk) ->unittmv (Num \n(j+k)) (_, _) -> complainr top ( shouldbe numbers: ++ showvalr top (unit tmv u) ++ , ++ showvalr top \n(unit tmv v)) )) interpN (OtherTN x) env = interpr oldpkg x env showvalN (Num x) = show x showvalN (OtherVN \nx) = showvalr oldpkg x makenumN x = unit tmv (Num x) nameN = numbers ++ namer oldpkg Figure8: The numbers \nbuilding block TermN t t that in actual use t is TermZ and that t is TermN t t. This last discovery produces \nan occurs error in both Chalmers Haskell and Glasgow Haskell, despite the fact that an algebraic datatype \n(dy\u00adnamically) intervenes. The simplifier reduces the type declarations to a form in which the circularities \nare textually manifest (see Figure 9), thus rendering them palatable to these Haskell implementations. \n9 The Program Simplifier The principal activity of the program simplifier is ju\u00addicious inlining of function \ndefinitions followed by /3\u00adreduction ofboth lambda-expressions and Haskell case\u00adexpressions. The simplifier \nalso performs a-conversion where necessary and tries todoasmartjob ofit, renam\u00ading variables by adding \nprimes; apost-pass heuristically tries to minimize the number ofDrimes in the residual . code while maintaining \nreadability. Ideally the necessary types could be deduced com\u00adlata Term = Con Int I Add Term Term I Bogon \nIata Value = Num Int I Wrong )arse ,S = peon s ++ psu.m s ++ [ (Bogon, S) ] where psum s = [ (Add X y, \ns5) I ( ( : SI) <-[ dropWhile isSpace s 1, (x, s2) <-parse sl, (>+> : s3) <-[ dropWhile isSpace S2 1, \n(y, s4) <-parse s3, ( ) : s5) <-[ dropWhile isSpace S4 1 1 peon (c : s ) I ((c >= o ) &#38;&#38; (c <= \n9 )) = peon s (oral c -ord O ) where peon (c : s ) n I ((c >= 0 ) M (c <= J9J)) = peon s ((10 * n) + \n(oral c -ord O )) peon s n= [ (Corm, s )] peon _= [1 interp (Con X) _ = NUIU x interp (Add x y) env = \ncase (interp x env, interp y env) of (Numj, Numk) ->Num(j +k) (_, -) -> complain ( should be numbers: \n ++ showval (interp x env) ++ ,, ++ s;owval (interp y env)) Lnterp Bogon _ . complain invalid expression \nnakenum x = Num x somplain s = Wrong showval (Num x) = show x showval Wrong = <wrong> lame = numbers \ninterpreter Figure 9: Simplified code for the complete number! interpreter pletely automatically, but \nfor this work we settled for ~erformin~ substitution and simplification onexDlicitlv provided type declarations \nfor Term and Value. Unin\u00adteresting wrinkle is that when two algebraic datatypes are nested: data Foo \n= Bar I Baz I OtherFoo Bletch data Bletch = Quux I Ztesch the type simplifier flattens them: data Foo \n= Bar I Baz I Quux I Ztesch and arranges for the code simplifier to eliminateapplica\u00adtionsof OtherFoo \nand to flatten nested case constructs as appropriate. (This transformation can rejustified by an appeal \nto category theory; we omit the details here.) A simple heuristic controls unrolling of recursive pro\u00adcedures: \nas the body ofa procedure is inlined, any out\u00adermost case statement is tagged with the name of the procedure; \nand it is forbidden to inline within a case statement for a procedure name that matches the tag. Thus \nunrolling continues only ifthe gating case state\u00adment can first be eliminated by partial evaluation. \nThe simplifier uses a fast and fairly effective pretty\u00adprinter after the style of Waters [18, 12]. 10 \nThe Nondeterministic Building Block The nondeterministic building block extends the term data type to \ninclude a choice construct Amb z y(surface syntax (zIY)), where xand y are top-level terms, and a failure \noperation Fail (surface syntax fail). It also alters the value data type to be a list of values. See \nFigure lO. Once again the implementation of the interpreter closely follows the work of Wadler [16]. \nFailure results in a list ofno value, but lifted to the top ofvalue type tower. Choice involves interpreting \neach of the subex\u00adpressions and then appending the two lists of results. The difference here from Wadler \ns interpreter is that thevalues from the recursive calls to the interpreter are not necessarily lists; \nthey are of the top value type and must be lowered back to the level of lists before con\u00adcatenation. \nThis is achieved by using the monad bind operation <<tmv>>. The bind operation requires that the result \nthenbe lifted back tothe top value type (us\u00adingunit tmv), which is exactly what we want anyway. We choose \nto print the multiple values one per line, followed by the line That s all! . Thename of the interpreter \nis the name from the old package preceded by the word nondeterminist ic. We can make a nondeterministic \ninterpreter in exactly thesame manner aswemade a numbers interpreter; all we need do is to replace the \nthree lines marked ** in Figure5 with the following: type Term = TermL Term TermZ type Value = ValueL \nValue ValueZ interp_pkg = complete (nondeterministic interpreter) However, it is even more interesting \nto make an inter\u00ad preter that is nondeterministic and has numbers: type Term = TermL Term (TermN Term \nTermZ) type Value = ValueL Value (ValueN Value ValueZ) interp_pkg = complete (nondeterministic (numbers \ninterpreter)) iata TermL t t = Fail i Amb t t I OtherTLt ;ype ValueL v v = [v] ~TL = Pseudomonas (\\x \n-> OtherTL x) mTLbind where mTLbind m Fail f = unit m Fail mTLbi.nd m (Amb x y) f = unit m (Amb x y) \nmTLbind m (OtherTL x) f = f x ~VL = Pseudomonas (\\x -> [x]) mVLbind where mVLbind mxf =foldr c(unit m[]) \n[f a Ia<-x] where Cxy = x <<m>> (\\q -> y <<m>> (\\r -> unit m (q ++ r))) londeterministic oldprepkg tmt \ntmv top = update oldpkg [ParseR parseL, InterpR interpL, ShowvalR showvalL, NameR nameLl where oldpkg \n= oldprepkg (trot &#38; mTL) (tmv &#38; mVL) top parseL s = (pfail s ++ pchoice s ++ parser oldpkg s) \nwhere pfail s = [(unit tmt Fail, sI) I ( f : a : i : l :sl) <-[dropWhile isSpace s]] pchoice s = [(unit \ntmt (Amb x y), s5) 1 ( ( :s1) <-[dropWhile isSpace s], (x, s2) <-parser top sl, ( ! :s3) <-[dropWhile \nisSpace s2], (y, s4) <-parser top s3, ( ) :s5) <-[dropWhile lsSpace s4]] i.nterpL Fail _ = unit tmv \n[1 interpL (Amb x y) env = interpr top x env <<tmv>> (\\u > interpr top y env <<tmv>> (\\v -> unit tmv \n(u ++ v) )) i.nterpL (OtherTL x) env = interpr oldpkg x env showvalL m = unlines [ showvalr oldpkg x \nI x <-m] ++ That>s all! nameL = 18nondeterrniniStlC ++ namer oldpkg Figure 10: Thenondeterministic \nbuilding block When we then apply our program simplifier to all the code in Figures 1 5 plus Figures \n8 and 10, the result is as shown in Figure 11. (To save space, we have chosen to elide the parser from \nthis figure. The parsers follow avery predictable pattern anyway.) A sample interaction with this interpreter: \nWelcome to the nondeterministic numbers interpreter ! > (2+3) 5 That s all! > (213) 2 3 That s all! \n> ((2+3)1(5+7)) 5 12 That s all! > ((213)1(517)) 2 3 5 7 That s all! > ((213)+(517)) 7 9 8 10 That \ns all! (Note that the two pairs of values interacted to produce four distinct sums.) > (fail15) b That \ns all! > fail That s all! > ((213)+(fail17)) 9 10 That s all! lata Term = Fail I Amb Term Term I Con \nInt I Add Term Term I Bogon jype Value = [ Value 1 lata Value = Num Int I Wrong )arses= . . . .nterp \nFail _ = [1 .nterp (Amb x y) env = interp x env ++ interp y env .nterp (Con x) _= [ Numx1 .nterp (Add \nx y) env = foldr (++) [1 [ foldr (++) [1 [ case (a, a ) of (Num j, Numk) -> [Num(j+k)] (-, _) -> complain \n( should be numbers: ++ showval [ a ] ++ 1, i-+ s;owval [ a ]) I a <-interp y env 1 I a <-interp x env \n1 .nterp Bogon _ = complain invalid expression drenumx=[Numx] :omplain s = [ Wrong ] :howval m = unlines \n[ case x of Num X -> show X Wrong -> <wrong> Ix<-m]++ That s all! Lame = nondeterministic numbers \ninterpreter ?igure 11: Simplified code for the complete nondeter\u00adninistic numbers interpreter (parser \nelided) 11 The Call-By-Value Building Block It is of particular interest that what we usually think \nof as the very soul ofan interpreter, the handling ofvari\u00adables and lambda-binding and function calls, \nis in fact just another set of features that can be separated out into a building block. The cbv building \nblock extends the term data type to include variable references Var v, lambda expressions Lam v r, and \nfunction applications App z y, where vis a string and zand yare top-level terms. It also extends the \nvalue data type to include functiona] values Fun ~ where fisafunction; the func\u00adtion maps values at the \ncurrent level of the type tower into values at the top of the type tower. See Figure 12. Once again the \nimplementation of the interpreter closely follows the work of Wadler [16]. However, we choose to nest \nthe definition oflookup within the defi\u00adnition ofone case ofinterpCBV. Note that makefunCBV accepts afunctionfandcom\u00adposes \nit with unit tmv. This is because a call-by-value Fun value must be of type v -> v but a MakefunR routine \ntakes an argument of type v -> v >. There is a reason for this difference: as we will see, the call\u00adby-name \nbuilding block uses Fun values ofa different type, but the MakefunR interface remains constants. This \nallows such clients of the MakefunR interface as the continuation building blockto be combined with either \nthe call-by-value or the call-by-name building block. Weparsethesurface syntax \\v.x for lambdaexpres\u00adsions \nand (f z) for application offunction fto argument x. We print functional values as <function> . To add \nthe call-by-value features into our nondeter\u00administic numbers interpreter, we write this code: type Term \n= TermCBV Term (TerrnL Term (TerrnN Term TermZ)) type Value = ValueCBV Value (ValueL Value (ValueN Value \nValueZ)) interp_pkg = complete (cbv (nondeterministic (numbers interpreter))) A sample interaction with \nthis interpreter: Welcome to the call-by-value nondeterministic numbers interpreter! > \\x. x <function> \n > ((\\x.\\y. (x+y) 3) 4) 7 That s all! > ((\\f.\\x. (f (f (f x))) \\q. (q+q)) 3) 24 That s all! Currying \nand functional arguments work fine. > ((\\x.\\Y. (x+Y) (213)) (517)) 7 9 8 10 That s all! So far, \nso good ... > ((\\x.xl\\y. (y+y)) 3) 3 That s all! lata TermCBV t t = Var String I Lambda String t I App \nt t I OtherTCBV t ~ata ValueCBV v v = Fun (ValueCBV v v -> v ) I OtherVCBV v \\TCBV = Pseudomonas (\\x \n-> OtherTCBV x) mTCBVbind where mTCBVbind m (Var x) f = unit m (Var x) mTCBVbind m (Lambda v x) f = unit \nm (Lambda v x) mTCBVbind m (App x y) f = unit m (App x y) mTCBVbind m (OtherTCBV X) f = f x lVCBV = Pseudomonas \n(\\x -> OtherVCBV x) mVCBVbind where mVCBVbind m = qxfoo where qxfoo (Fun x) f = unit m (Fun x) qxfoo \n(OtherVCBV x) f = f x  ;bv oldprepkg tmt tmv top = update oldpkg [ParseR parseCBV, InterpR interpCBV, \nShowvalR showvalCBV, MakefunR makefunCBV, ApplyR applyCBV, NameR nameCBV] where oldpkg = oldprepkg (trot \n&#38; mTCBV) (tmv &#38; mVCBV) top parseCBV s = (pvar s ++ plambda s ++ papp s ++ parser oldpkg s) where \n pvar (c:s) I c elem abcdefghijklmnopqrstuvwxyz = pvar s [cl where pvar (c:s) v I c elem abcdefghijklmnopqrstuvwxyz \n= pvar s (v ++ [c]) pvar . v = [(unit tmt (Var v), s)] pv&#38; _= [1 plambda s = [(unit tmt (Lambda \nv x) s4) I ()\\\\ :sl) <-[dropWhile isSpace s], (Var v, s2) <-pvar sl, ( . :s3) <-[dropWhile isSpace s2], \n(x, s4) <-parser top s31 papp s = [(unit tmt (App x y), s5) ( ( :s1) <-[dropWhile i.sSpace s], (x, (c:s2)) \n<-parser top sI, isSpace c, S3 <-[dropWhile isSpace s2], (y, s4) <-parser top s3, ( ) :s5) <-[dropWhile \nisSpace s4]] interpCBV (Var v) env = lookup v env where lookup v ((w,z) :_) I (v == w) = unit trnv z \nlookup v (_:e) = lookup v e lookup v [] = complainr top ( unbound variable: ++ v) interpCBV (Lambda \nv x) env = unit tmv (Fun (\\z -> lnterpr top x ((v,z):env))) interpCBV (App x y) env = interpr top x env \n<<tmv>> (\\u -> interpr top y env <<tmv>> (\\v -> applyr top u v )) interpCBV (OtherTCBV x) env = interpr \noldpkg x env applyCBV (Fun f) x = f x applyCBV u _ = complalnr top ( should be function: ++ showvalr \ntop (unit tmv u)) showvalCBV (Fun x) = <function> showvalCBV (OtherVCBV x) = showvalr oldpkg x makefunCBV \nf = Fun (f . unit tmv) nameCBV = call-by-value ++ namer oldpkg Figure 12: Thecall-by-value building \nblock That s strange . . . why didn t it also print the value 6? 7 > (\\x. xl\\y. (y+y)) <function> Ooh, \nweird! Trying to choose a function produces only the first one! And it didn t even print That s all! \n! (It didn t print it when we tried \\x. x , either.) But this is entirely correct. We chose to add in \nthe call-by-value building block after adding in the nonde\u00adterministic building block. So the nondeterminism \ngov\u00aderns number values Num n but it doesn t govern func\u00adtional values Fun ~ Let s look at just the definition \nof the Value type produced by the program simplifier: data Value = Fun (Value -> Value) I OtherVCBV [ \nValue 1 data Value = Num Int I Wrong Sure enough, you can represent a list of numbers but not a list \nof functions. The moral is that while you can compose any build\u00ading blocks you like, it matters in what \norder you do it. This is not to say that the call-by-value nondeterminis\u00adtic numbers interpreter is incorrect \nin any sense; it is a perfectly legitimate, working combination of the spec\u00adified building blocks into \na working interpreter. It just may not be the interpreter we want for a given purpose. Perhaps we would \nprefer the nondeterministic call-by\u00advalue numbers interpreter: type Term = TermL Term (TermCBV Term (TermN \nTerm TermZ) ) type Value = ValueL Value (ValueCBV Value (ValueN Value ValueZ) ) interp.pkg = complete \n(nondeterministic (cbv (numbers interpreter))) When we then apply our program simplifier to all the \nrelevant code, the result is as shown in Figure 13. (Again we elide the parser.) A sample interaction \nwith this interpreter: Welcome to the nondeterministic call-by-value numbers interpreter! > \\x. x <function> \nThat Js all! Ah, that s better! > ((\\x. \\y. (x+y) 3) 4) 7 That s all! > ((\\ f.\\x. (f (f (f x))) \\q. \n(q+q)) 3) 24 That s all! > ((\\x.\\y. (x+y) (213)) (517)) 9 8 10 That s all! All this stuff works as \nbefore. > ((\\x.xl\\y. (y+y)) 3) 3 6 That s all! > (\\x.xl\\y. (y+y)) <function> <function> That s all! \n Andnow we can also have choices offunctions. > (b.( x+x) (213)) 4 6 That s all! This last exchange \nindicates thatit is truly call-by-value: the two references toxin the body of\\x. (x+x) both get the same \nvalue, either both 20rboth 3. 12 The Call-By-Name Building Block The call-by-name building blockis \nquite similar to the call-by-value building block, with only some subtle dif\u00adferences in the use of the \nmonads (the five lines differing other than in the names of variables from those in Fig\u00adure 12 aremarked \n##). But this makes all the difference in the world. See Figure 14. We can specify the nondeterministic \ncall-by-name numbers interpreter: type Term = TermL Term (TermCBN Term (TermN Term TermZ)) type Value \n= ValueL Value (ValueCBN Value (ValueN Value ValueZ)) interp_pkg = complete (nondeterministic (cbn (numbers \ninterpreter))) (We forebear to show the simplified code; as you might expect, itdiffers inexactly five \nplaces from the simplified call-by-value code in Figure 13.) A sample interaction with this interpreter: \nWelcome to the nondeterministic call-by-name numbers interpreter! > \\x.x <function> That s all! > ((\\x.\\y. \n(x+y) 3) 4) 7 That s all!  data Term = I Fail App I Amb Term Term Term I Term Con I Int Var I String \nAdd Term I Lambda Term I String Bogon Term type data Value Value = [ Value ] = Fun (Value -> Value) \nI Num Int I Wrong parses= . . . interp interp interp lookup lookup lookup interp interp foldr interp \ninterp foldr Fail _ = [1 (Amb x y) env = interp x env ++ interp (Var v) env = lookup v env where V ((W, \nZ) : -) I (VJ == w) = [z ] v (_ : e) = lookup v e V [1 = complain ( unbound variable: (Lmbda v x) env \n= [Fun (\\z-> interpx (App x y) env = (++) [1 [ foldr (++) [1 [ apply a a (Con x) _ = [ Num x ] (Add x \ny) env = (++) [] [ case a of Fun x -> [ Fun x 1 x> _> y env ++ v ) ((v, z) I a <\u00adinterp : env)) 1 y \nenv 1 I a <\u00ad interp x env 1 foldr (++) [] [ case a of Fun x x >> -> -> [Funx ] case (x , x ) of (Numj, \nNumk)->[Num(j+k)] ( _, _) -> complain ( should be numbers: showval [ x> 1 ++ II +i\u00ad ++ interp I a Bogon \n<\u00ad_ I a interp x = complain <\u00adinterp env 1 invalid s;owval y env 1 expression [ x 1) apply apply (Fun \nu _ f) x = f = complain x ( should be function:  ++ showval [ u 1) makefunf = Fun (f . (\\x -> [ xl)) \nmakenumx=[Numx] complain s = [ Wrong 1 showval unlines ThatJs m = [ case x of Fun x -> <function> Num \nX -> show X Wrong -> <wrong> Ix<-m]++ all! ~me = Itnondeterministic call-by-value numbers interpreter \nFigure 13: Simplified code forthecomplete nondeterministic call-by-value numbers interpreter (parser \nelided) lata TermCBN t t = Var String I Lambda String t I App t t I OtherTCBN t lata ValueCBN v v = \nFun (v > v ) I OtherVCBN v --## LTCBN = . . . --identical to mTCBV except names have N instead of V \nlVCBN = . . . --identical to mVCBV except names have N instead of V :bn oldprepkg tmt tmv top = update \noldpkg [ParseRparseCBN, InterpR interpCBN, ShowvalR showvalCBN, MakefunR makefunCBN, ApplyR applyCBN, \nNameR nameCBN] where oldpkg = oldprepkg (trot &#38; mTCBN) (tmv &#38; mVCBN) top parseCBN s = . . . -\u00ad \nidentical to parseCBV interpCBN (Var v) env = lookup v env where lookup V ((W,Z) :_) I (V = W) = 2 --## \nlookup v (_:e) = lookup v e lookup v [] = complainr top ( unbound variable:  ++ v) interpCBN (Lambda \nv x) env = unit tmv (Fun (\\z -> interpr top x ((v,z):env))) interpCBN (App x y) env = interpr top x env \n<<tmv>> (\\u -> applyr top u (interpr top y env)) --## interpCBN (OtherTCBN x) env = interpr oldpkg x \nenv applyCBN (Fun f) x = f x applyCBN u _ = complainr top ( should be function:  ++ showvalr top (unit \ntmv u)) showvalCBN (Fun x) = <function> showvalCBN (OtherVCBN x) = showvalr oldpkg x makefunCBN f = \nunit tmv (Fun f) --## nameCBN = call-by-name  ++ namer oldpkg --## Figure 14: Thecall-by-name building \nblock (some parts identical tothose incall-by-value building block elided) > ((\\f.\\x. (f (f (f x))) \n\\q. (q+q)) 3) That s all! 24 That s all! This last exchange indicates that it is truly call-by\u00ad > ((\\X.\\y. \n(X+y) (213)) (5]7)) name: the two references to xinthe body of\\x. (x+x) 7 I each perform the calculation \n(213) anew, resulting in a 9 total of four possibilities. 8 10 13 The Continuation Building Block That \ns all! > ((\\x.xl\\y. (y+y)) 3) The continuation buildingblock extends thetermdata 3 type to include a \nconstruct Catch v y. (Wadler [16] 6 called this construct Callcc, but this was an error; it That s all! \nhas the form of the original Scheme CATCH construct [14]. > (\\x.xl\\y. (y+y)) However, his function callccK \nwas indeed a callcc \u00ad <function> type operation.) The continuation building block also <function> alters \nthevaluedata type to be aHaskell function that, That s all! when givena continuation (a Haskellfunction \nthat maps values to values) produces avalue. See Figure 15. This is all exactly as before. How do we \nknow it is The continuation building block was themostdiffi\u00ad call-by-name? cult to construct it took \na long time to get the types > 4 (\\x. (x+x) (213)) right! that Even so, problems the value type be lurk. \nWe would much prefer 5 type ValueC v v = ((v -> r) -> r) 5 --\u00ad 6 where r is a free type variable. In \nother words, we want the lifted value type to be polymorphic over var\u00adious types of continuation that \nproduce various types of result, for there are conflicting requirements. In showvalC, we need to be able \nto extract an underlying value by feeding the identity continuation to a ValueC value; here we need r \n= v. But the implementation of Catch shown in Figure 15 requires that a captured continuation return \na value at the top of the type tower; here we need r = v . The net effect is that we must have v = v \nJ. The practical effect k to limit the continuation building block to be the last (that is, lejlmost) \none applied. (If you try to build a nondeter\u00administic continuation interpreter, for example, Haskell \nwill report a type error on the simplified code; it sim\u00adply doesn t work out. A continuation nondeterministic \ninterpreter works fine. ) We can specify the continuation nondeterministic call\u00adby-value numbers interpreter: \ntype Term = TermC Term (TermL Term (TermCBV Term (TermN Term TermZ) ) type Value = ValueC Value (ValueL \nValue (ValueCBV Value (ValueN Value ValueZ) ) interp_pkg = complete (cent inuat ion (nondeterministic \n(cbv (numbers interpreter))))  When we apply our program simplifier to all the relevant code, the result \nis as shown in Figure 16. (This time we elide the parser and the interpreter case for Add. ) Inspection \nof the interpreter case for Catch reveals the expected code: x is interpreted in an environment in which \nvariable v is bound to a function that, when given a value z and a continuation cc, proceeds to ig\u00adnore \ncc and instead feeds to z the continuation q of the Catch expression. (Note that the simplifier wasn \nt smart enough to do an q-reduction on \\a -> q a.) It is also of interest to examine the first argument \nto each occurrence of foldr in the interpreter case for App. Recall that the call to foldr comes from \nthe nondetermi,nistic building block; its purpose is to append-reduce (in monad terminology, join) a \nlist of lists. Now that we have added in the continuation building block, we see that the first argument \nto foldr is none other than the continuation-passing version of ++! And its second argument is the continuation-passing \nversion \\c -> c [] of the empty list [1 A sample interaction with this interpreter: Welcome to the continuation \nnondeterministic call-by-value numbers interpret er ! > Catch v (2+3) 5 That s all ! > Catch v (2+(v \n3)) 3 That s all ! > (4+ Catch v (2+(v 3))) 7 That s all! > (4+ Catch v (21(v 3))) 7 That s all! > (41 \nCatchv (21(v 3))) 4 3 That s all! 14 The Errors Building Block  The errors building block introduces \nno new terms; its only purpose is to preserve the string argument given to the complain function rather \nthan discarding it, thereby producing an error message perhapos more useful than <wrong> ! Welcome to \nthe nondetermini.stic errors call-by-value numbers interpreter! > (3+x) Error: unbound variable: x That \ns all! > (3+(x l(51y))) Error: unbound variable: x 8 Error: unbound variable: y That s all! > (3+(x l(ly))) \nError: unbound variable: x Error: invalid expression Error: unbound variable: y That s all! > (3+(x l\\y. \ny)) Error: unbound variable: x <f unct ion> That s all! The last interaction reminds us of an unsatisfactory \nproperty of theinterpreter framework wehave used. Be\u00adcause functions are higher in the value tower than \nnum\u00adbers, attempting to add a function to a number does not produce the error message should be numbers \n. .. but merely returns the function (as dictated by the pseu\u00addobindoperation mVCBVbind in Figure 12). \n(A possible solution: the code in interpN for Add should not use pseudobinding to extract a numeric value, \nbut a related operation that calls an error thunk if it is unable to descend tothe Numrepresentation. \nTheproblem is that this operation must be provided by all pseudomonads; but it may be worth it.) .ata \nTermC t) t = Catch String t I OtherTC t ype ValueC v v=((v -> v) -> v) LTC = Pseudomonas (\\x -> OtherTC \nx) mTCbind where mTCbind m (Catch v x) f = unit m (Catch v x) mTCbind m (OtherTC x) f = f x lVC = Pseudomonas \n(\\x c -> c x) mVCbind where mVCbind mxf cc =x (\\a -> f acc) ontinuation oldprepkg tmt tmv top = update \noldpkg [ParseR parseC, InterpR interpC, ShowvalR showvalC, NameR nameC] where oldpkg = oldprepkg (trot \n&#38; mTC) qxtmv top qxtmv = tmv &#38; mVC parseC s = (pcatch s ++ parser oldpkg s) where pcatch s = \n[(unit tmt (Catchv x), s3) I ( c : Ja):Jt>:Jc/: h):cl:sl) <-[dropWhile isSpace s] , isSpace cl, (Var \nv, c2:s2) <-parser top sI, isSpace c2, (x, s3) <-parser top s2] interpC (Catch v x) env = callcc (\\k \n-> i.nterp x ((v, makefunr top (\\z -> z <<qxtmv>> k)):env)) where callcchq=h(\\bd->q b)q interpC (OtherTC \nx) env = interpr oldpkg x env showvalC x = showvalr oldpkg (X (\\q -> q)) nameC = continuation ++ namer \noldpkg  Figure 15: The continuation building block 15 Why Haskell? limitations ofboth, inmuch the same \nway that trying tohammer aset oflovely but vague thoughts into the The restrictions of the Haskell type \nsystem certainly form ofa sonnet yields great insight into the strengths caused some problems along the \nway. Several times I and limitations of the English language (for example, was sorely tempted to switch \nto Scheme or Common the wealth of synonyms but the paucity of rhymes for Lisp. Had I used a dialect of \nLisp, it would have been love ) while clarifying, not always comfortably, one s much easier to code the \nprogram simplifier, because romantic impulses. Lisp already provides aparser and pretty-printer. Then \nagain, workingin Lisp might have avoided the need fora 16 Why Monads? program simplifier altogether, \nsince the principal prac\u00adtical motivation for it was to transform the code into a More than one reviwer \nof this work has asked me, form acceptable to the Haskell type-checker. So what s the big deal about \nmonads? Isn t what Thetruth isthat (a) Wadlerhad conducted his work you have done simply good functional \nprogramming in Haskell and it seemed appropriate to preserve nota\u00ad style ? Ifeelcompelled toexplain myself \non this point. tional continuity, and (b) I was looking for an excuse Well, maybe that s all it is, merely \ngood style to gain experience with using Haskell anyway. In the (which perhaps I should simply accept \nas a compliment, end, I have to say that the type checking was more never mind that it may be back-handed!). \nBut I feel help than hindrance, especially in the construction of that Inever would have thought ofthis \nstyleof decom\u00adthe continuations building block. I had the sameex\u00ad posing interpreters without exposure \nto the structuring perience with Haskell that I had twenty years ago with ideas suggested by monads and \nthe use to which Philip E(3L [19] (which was, in effect, also a strongly-typed Wadler, Mark Jones, and \nothers have put them. The\u00ad dialect of Lisp): almost always, once Imade the type ory is not automatically \nwonderful by virtue of being checker happy, the program was correct. Moreover, the theory, but itjustifies \nitselfby leading one to pragmatic challenge oftrying force pseudomonades into the Haskell solutions that \nwould otherwise have seemed implausi\u00ad type framework taught mealot aboutthe strengths and ble. Thatis \nexactly what happpened in this instance. data Term = Catch String Term I Fai,l I Arnb Term Term I Var \nString I Lambda String Term I App Term Term I Con Int I Add Term Term I Bogon type Value = ([ Value ] \n-> [ Value ]) -> [ Value ] data Value = Fun (Value -> Value) I Num Int I Wrong parses= . . . i.nterp \n(Catch v x) env = \\ q -> interp x ((v, makefun (\\ z-> \\ cc-> z(\\ a-> qa))) : env) q interp Fail _=\\ c-> \nc[] interp (Arnb x y) env = \\ cc -> interpx env (\\ a -> interp y env (\\ a -> cc (a ++ a ))) interp (Var \nv) env = lookup v env Where lookup v ((w, z):_) l(v~ ==w)=\\c->c [z] lookup v (_ : e) = lookup v e lookup \nv [] = complain ( unbound variable: ++ v ) interp (Lambda v x) env = \\ c -> c [Fun (\\z-> interpx ((v, \nz) : env)) ] interp (App xy) env = \\ cc -> interp x env (\\ a-> foldr (\\ x y) -> \\ cc -> x (\\ a -> y (\\ \na -> CC (a ++a )))) (\\c->c cl) [ \\ cc -> interp y env (\\a -> foldr (\\ x y -> \\ cc -> ~) (\\a,,, >y (\\aJ \nl ->cc (a ++ a )))) (\\c->c [1) a) J)<_ a>J] [ apply a a cc;) la <-a] cc)  interp (Con x) _ = \\c->c[Numx] \ninterp (Add x y) env = \\ cc -> ... i.nterp Bogon _ = complain invalid expression apply (Fun f) x =f \nx apply u _ = complain ( should be function: 1! ++ showval (\\ c -> C [ U 1)) rnakefun f = Fun (f . (\\xc->c \nx). (\\x-> [xl)) rnakenum x = \\C->C[NUmX] complain s = \\c->c [Wrong] showval x = Unline$ [ case x \nof Fun x -> <function> Num X -> show X>) Wrong -> <wrong> lxJ<-x(\\q->q) ]++ That s all!  name = continuation \nnondeterministic call-by-value numbers interpreter Figure 16: Simplified code for the complete continuation \nnondeterministic call-by-value numbers interpreter (parseI and interpreter case for Add elided) ;ype \nTermE t ) t = t iata ValueE v v = Err String ! OtherVE v mTE = Pseudomonas (\\x -> x) (\\x f > f x) flVE \n Pseudomonas (\\x -> OtherVE x) mVEbind Where mVEbind m = parsequux where parsequux (Err x) f = unit m \n(Err x) parsequux (OtherVE x) f = f x ~rrors oldprepkg tmt tmv top = update oldpkg [ShowvalR showvalE, \nComplainR complainE, NameR nameE] where oldpkg = oldprepkg (trot &#38; mTE) (tmv &#38; mVE) top complainE \ns = unit tmv (Err s) showvalE (Err x) = Error: ++ x showvalE (OtherVE x) = showvalr oldpkg x nameE = \nerrors ++ namer oldpkg Figure 17: Theerrors (I draw a parallel to the changes in style of an assembly \nlanguage programmer once exposed tothe principlesof structured programming.) Moreover, I hold out some \nhope that, once the slightly ad hoc techniques I have stumbled across here have been back-translated \ninto ap\u00adpropriately mathematical language, some suitably qual\u00adified category theorist will remark, Oh, \nyes, that ssim\u00adilar to this notion we ve known about for years; it has the following marvelous properties, \nand ifyou will only do things fhisway instead you ll have amucheasier time of it. Which is an excellent \nrelation for theory to hold to practice. 17 Comparison with Other Work This paper is essentially one \nlong reformulation of Wadler swork [16] to add the crucial capability ofcom\u00adposition. It owes its roots \nto all the work that Wadler cites, of course, notably that of Reynolds [10]. It is also in the spirit \nofmyown earlier work with Sussman [13]. In this presentation I have omitted all the proofs, par\u00adticularly \nproofs of monad associativity. In some cases they do not exist; that is, some of the putative monads \nthat arise in the interpreters presented here are not re\u00adally associative. This obstructs proofs ofprogramequiv\u00adalence \nof the kind discussed by Wadler [16] but other\u00adwise seems to have little practical effect. Nevertheless, \nfurther investigation is warranted. Certain simple but important cases, such as lists and simple coproducts, \nare well-behaved; when provided as pseudomonades to the composition operator &#38; the result obeys the \nmonad associative law and therefore really is always a monad. King and Wadler [5], forexample, consider \nnot only lists 490 building block but also trees, bags, and sets. SimonPeyton Jones andWadler have investigated \nthe use of monads to perform 1/0 and other imperative tasks within a working compiler coded in Haskell \n[7]. Jonathan Rees has coded monadic interpreters in Scheme but this work apparently has not been pub\u00adlished \n[9]. Mark Jones has developed Gofer, a variant of Haskell that allows additional polymorphism through \nthe use of type classes [4]. Gofer supports programming with mul\u00adtiplemonads, includinga cleaner version \nof the monad comprehension syntax proposed by Wadler [15]. Repre\u00adsenting monads as a Gofer type class \nallows the Gofer type system to deduce which monad is intended in a unit or bind operation, avoiding \nthe need to reify monads in the manner shown in this paper. Jones has begun to explore the possibility \nof recoding the interpreters pre\u00adsented here so as to use Gofer s simpler monadic pro\u00adgramming style \n[3]. Many of the ideas presented here were anticipated by Moggi [6]: To give semantics to a complex language \nL we propose a stepwise approach, which starts from a monad (notion of computation) corresponding to \na toy sublanguage of L and then at each step applies a monad construc\u00adtor which adds one feature to the \nlanguage. Moggi then goes on to present theoretical descriptions of several useful monad constructors, \nincluding excep\u00adtions, side effects, and continuations. To the best of our knowledge, however, the work \npresented here is the first to put this idea into practice to produce actual working interpreters from \nmonad-like building blocks. Our work also factors Moggi s monad constructors in an interesting way into \ntwo parts: a pseudomonas and the composition operator t. The composition operator is a nonvarying associative \noperator with left and right identity; a pseudomonas is almost identical in structure to a monad. If \np is a pseudomonas, then (&#38;p) (which in Haskell means the same as \\x -> (x&#38;p)) is a monad constructor, \nmapping a monad into a new monad. I think that this factoring usefully structures and simpli\u00adfies the \nnecessary proofs that a composed monad will satisfy the monad laws. 18 Conclusions and Future Work The \ntitle of this paper slyly plays on an ambiguity in the use of the English verb to compose : the object \nof the verb may indicate either the inputs or the outputs of the composition operation. Indeed, you can \nt really compose (i.e., combine) two monads and get a monad as the result. But you can compose (i.e., \nproduce) a monad from two other things (not both of which are monads). Our technique does compose monads \nin this sense by applying a composition operator to pseudomonads. An important lesson from this work \nis that the com\u00adposition operation is associative but in general not com\u00admutative. The practical result \nis that it really matters in what order you combine the building blocks. Two in\u00adterpreters built from \nthe same building blocks combined in different orders may have different (perhaps mysteri\u00adously different \n) behaviors. It should be clear that, even using only the small set of building blocks presented here, \nwe can automatically construct more interpreters than you can shake a stick at. (I was sorely tempted \nto title this paper Inter\u00adpreters for Free! [17] but thought better of it.) I have constructed many more \ninterpreters than I have shown here and am working on other building blocks, for state, output, and string \ndata, for example. The building blocks shown here transform the value type in a variety of ways but all \ndo the same thing to the term type, adding a few alternatives to one big disjunc\u00adtion. What if some pseudomonas \ndid some nontrivial comput at ion on terms? Presto! We have macros. There should be a macros building \nblock. It would leave the value type alone but transform the term data type, per\u00adhaps according to some \nmacro environment. How about error messages with positions? Wadler [16] remarks, The parser will produce \n[At] terms as suit\u00adable. So the term type must be extended, but it turns out that it is easiest to modify \nthe parser so that its in\u00adput data type is not merely a string but a pair of a string (remaining to be \nparsed) and a position (of the start of that remaining string). So it is useful to have more than two \ntype towers. We should have left a hook [8] so that the input type to the parser could be changed. Indeed, \nit is unsatisfactory that the interp func\u00adtions shown here must always accept an extra envi\u00adronment argument \nenv. Environments are irrelevant in the numbers building block, for example, or in the nondet erminist \nic building block; they ought to be in\u00adtroduced explicitly by the cbv and cbn building blocks, for only \nthey are explicitly concerned with environ\u00adments. An interpreter ought to be purely a mapping from terms \nto values, with no extraneous arguments. However, it does not suffice simply to work within the value \ntower, extending it so that the call-by-value build\u00ading block lifts the value type v to env -> v. The \nprob\u00adlem is that if further building blocks are composed, such as nondet erminist ic, the environments \nwill not be in\u00adherited properly. One solution seems to be to introduce an additional hook in the form \nof a second term type tower, so that one term type represents the parser out\u00adput, the second represents \nthe interpreter input, and the main driver calls a small function (initially the identity function) to \nmap from one to the other. We suspect that a full-blown, truly modular Lisp interpreter coded in this \nstyle would need a fairly large number of types with corresponding towers. The techniques presented here \nare quite general and need not be limited to the construction of interpreters; interpreters are merely \na good subject for exposition in academic papers because their behavior is relatviely complex relative \nto the size of code needed to express it. Monads (and pseudomonads) are likely to be useful in any software \nsystem that requires easy and flexible extensibility. The use of a monad is a hook, a powerful hook, \na hook with type discipline. A monad has an eye; when you hang a monad on the hook, it uses up the hook. \nA pseudomonas has an eye on one end and a hook on the other. You can chain them. (Hm. I m mixing my metaphors. \nFirst towers, now chains.) When you hang a pseudomonas on a hook, there s still a hook left to use. I \nwonder whether the Macintosh toolbox [1] could be defined in terms of a large set of pseudomonades, lending \nsome structure to the games played by various add-on software packages to intercept system calls? 19 \nAcknowledgments I wish to thank Philip Wadler, Mark Jones, Olivier Danvy, Paul Hudak, and the conference \nreferees for their helpful remarks. Paul Hudak, Phil Wadler, Si\u00admon Peyton Jones, and Lennart Augustsson \nprovided helpful advice on the use of Haskell. I am grateful for access to four different implementations \nof Haskell: Yale Haskell, Glasgow Haskell, Chalmers Haskell, and Jones Gofer system. Jonathan Rees, Dan \nFriedman, and Mitch Wand also provided useful information and encouragement. References Jon L. Common \nLisp: The Language (Second [1] [2] [3] [4] [5] [6] [7] [8] [9] [10] [11] [12] Apple Computer, Inc. Inside \nMaczntosh (five vol\u00adumes). Addison-Wesley (Reading, Massachusetts, 1985-86). Hudak, Paul, Peyton Jones, \nSimon, and Wadler, Philip, editors. Report on the Programming Lan\u00adguage Haskel!: A Non-Strict, Purely \nFunctional Language (Version 1.1). Technical Report. Yale University and Glasgow University (New Haven \nand Glasgow (respectively), August 1991). Jones, Mark P. Personal communication to Guy Steele, September \n1993. Jones, Mark P. A system of constructor classes: Overloading and implicit higher-order polymor\u00adphism. \nIn Proc. FPCA 93: The Sixth Interna\u00adtional Conference on Functional Programming Lan\u00adguages and Computer \nArchitecture. ACM SIG-PLAN/SIGARCH and IFIP (London, September 1993), King, David J., and Wadler, Philip. \nCombining monads. In Functional Programming, Glasgow 9.2. Springer Verlag (Berlin, 1992). Moggi, Eugenio. \nAn Abstract Vtew of Program\u00adming Languages. Technical Report ECS-LFCS-90\u00ad 113. Laboratory for Foundations \nof Computer Sci\u00adence, University of Edinburgh (Edinburgh, Scot\u00adland, April 1990). Lecture notes for a \ncourse taught at Stanford University, Spring 1989. Peyton Jones, Simon L., and Wadler, Philip. Im\u00adperative \nfunctional programming. In Proc. Twenti\u00ad eth Annual ACM Symposium on Principles of Pro\u00adgramming Languages. \nAssociation for Computing Machinery (Charleston, South Carolina, January 1993), 1-14. Raymond, Eric, \neditor. The New Hacker s Dic\u00adtionary. MIT Press (Cambridge, Massachusetts, 1991). Rees, Jonathan. Personal \ncommunication to Guy Steele, October 1993. Reynolds, John C. Definitional interpreters for higher order \nprogramming languages, In Proc. ACM Natzonal Conference. Association for Com\u00adputing Machinery (Boston, \nAugust 1972), 717-740. Steele, Guy L,, Jr. How to Compose Monads. Technical Report. Thinking Machines \nCorporation (Cambridge, Massachusetts, July 1993). Unpub\u00adlished. Steele, Guy L., Jr., Fahlman, Scott \nE., Gabriel, Richard P., Moon, David A., Weinreb, Daniel L., Bobrow, Daniel G., DeMichiel, Linda G., \nKeene, Sonya E., Kiczales, Gregor, Perdue, Crispin, Pit\u00adman, Kent M., Waters, Richard C., and White, \nEditzon). Digital Press (Bedford, Massachusetts, 1990). [13] Steele, Guy Lewis, Jr., and Sussman, Gerald \nJay. The Art of the Interpreter; or, The Modular\u00adity Complex (Parts Zero, One, and Two). AI Memo 453. \nMIT Artificial Intelligence Laboratory (Cambridge, Massachusetts, May 1978). [14] Sussman, Gerald Jay, \nand Steele, Guy Lewis, Jr. SCHEME: An Interpreter for Extended Lambda Calculus. AI Memo 349. MIT Artificial \nIntelligence Laboratory (Cambridge, Massachusetts, December 1975). [15] Wadler, Philip. Comprehending \nmonads. In Proc. 1990 ACM Symposium on Lzsp and Func\u00adtional Programming. ACM SIGPLAN/SIGACT/ SIGART (Nice, \nFrance, June 1990), 61 77. To aPPear In the Journal Mathematical Structures an Computer Science. [16] \nWadler, Philip. The essence of functional program\u00adming. In Proc. Nineteenth Annual ACM Sympo\u00adsium on \nPrinciples of Programming Languages. As\u00adsociation for Computing Machinery (Albuquerque, New Mexico, January \n1992), 1-14. [17] Wadler, Philip. Theorems for free! In Proc. FPCA 89: The Fourth International Conference \non Functional Programming Languages and Com\u00adputer Architecture. ACM SIGPLAN/SIGARCH and IFIP (London, \nSeptember 1989), 347 359. [18] Waters, Richard C. XP: A Common Lisp Pretty Prznting System. AI Memo 1102. \nMIT Artificial In\u00adtelligence Laboratory (Cambridge, Massachusetts, March 1989). [19] Wegbreit, Ben, Holloway, \nGlenn, Spitzen, Jay, and Townley, Judy. ECL Programmer s Manual. Tech\u00adnical Report 23-74. Harvard University \nCenter for Research in Computing Technology (Cambridge, Massachusetts, December 1974). \n\t\t\t", "proc_id": "174675", "abstract": "<p>We exhibit a set of functions coded in Haskell that can be used as building blocks to construct a variety of interpreters for Lisp-like languages. The building blocks are joined merely through functional composition. Each building block contributes code to support a specific feature, such as numbers, continuations, functions calls, or nondeterminism. The result of composing some number of building blocks is a parser, an interpreter, and a printer that support exactly the expression forms and data types needed for the combined set of features, and no more.</p><p>The data structures are organized as <italic>pseudomonads</italic>, a generalization of monads that allows composition. Functional composition of the building blocks implies type composition of the relevant pseudomonads.</p><p>Our intent was that the Haskell type resolution system ought to be able to deduce the appropriate data types automatically. Unfortunately there is a deficiency in current Haskell implementations related to recursive data types: circularity must be reflected statically in the type definitions.</p><p>We circumvent this restriction by applying a purpose-built program simplifier that performs partial evaluation and a certain amount of program algebra. We construct a wide variety of interpreters in the style of Wadler by starting with the building blocks and a page of boiler-plate code, writing three lines of code (one to specify the building blocks and two to (redundantly) specify type compositions), and then applying the simplifier. The resulting code is acceptable Haskell code.</p><p>We have tested a dozen different interpreters with various combinations of features. In this paper we discuss the overall code structuring strategy, exhibit several building blocks, briefly describe the partial evaluator, and present a number of automatically generated interpreters.</p>", "authors": [{"name": "Guy L. Steele", "author_profile_id": "81100586340", "affiliation": "Thinking Machines Corporation, 245 First Street, Cambridge, Massachusetts", "person_id": "P100946", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/174675.178068", "year": "1994", "article_id": "178068", "conference": "POPL", "title": "Building interpreters by composing monads", "url": "http://dl.acm.org/citation.cfm?id=178068"}