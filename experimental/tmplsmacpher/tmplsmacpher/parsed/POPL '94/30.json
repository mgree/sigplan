{"article_publication_date": "02-01-1994", "fulltext": "\n Composing Tree Attributions* John Boylandt Susan IL. Grahami Computer Science Division -EECS, 571 Evans \nHall University of California, Berkeley, California 94720 Abstract Using the simple tree attributions \ndescribed in this pa\u00adper, attribute values cmthemselves be trees, enabling attribution to be used for \ntree transformations. Un\u00adlike higher-order attribute grammars, simple tree at\u00adtributions have the property \nof descriptional composi\u00ad tion, which allows a complex transformation to be built up from simpler ones, \nyet be executed efficiently. In contrast to other forma,lkms that admit descriptional composition, notably \ncomposable attribute grammars, simple tree attributions have the expressive power to handle remote references \nand recursive syntactic (tree\u00adgenerating) functions, providing significantly more gen\u00aderal forms of attribution \nand transformation. 1 introduction Many programming language tools operate on trees that represent a \nprogram fragment in some way. For exam\u00adple, early stages of a compiler may represent a program as an \nabstract syntax tree. Trees might also be used as a lower level intermediate representation, UsuaJly \nthe nodes of a tree axe annotated with attributes or attn bute values. For example, type or binding information \nmight be associated with a node designating a variable. A sequence of target machine instructions might \nbe as\u00adsociated with a subtree representing an expression or This research was supported in part by a \nfellowship from the National Science Foundation to John Boyland, by the Advanced Research Projects Agency \n(DoD) under Contract NOO039-88-Cl\u00ad0292 monitored by Space and Naval Warfare Systems Command, and under \nGrant MDA972-92-J-1028, and by the National Sci\u00adence Foundation under Infrastructure Grant CDA-8722788. \nThe content of the information doee not necessarily reflect the position or the policy of the Government. \n7email address: {boylend, grabam}Ocs, berkeley. edu Permission to copy without fee all or part of this \nmaterial is granted provided that the oopiea are not made or distributed for direct commercial advantaga, \ntha ACM copyright notica and tha titla of the publication and its data appear, and notice ia givan that \ncopying iE by perm saion of the Association for Computing Machinary. To copy otharwiaa, or to rapublieh, \nraquiras a faa and/or apacific permieaion, POPL 94-1K?4, Portland Oragon,USA @ 1994 ACM O-89791 -63GOr94/001..$3.5O \nstatement. Typically, attributes are both named and typed. Attribute values may be drawn from a wide \nva\u00adriety of types, such as integers, strings, tuples, trees, or graphs. An attribution is an association \nof the nodes of a tree with appropriately typed attribute values. Attri\u00adbutions can be determined programmatically, \nby code associated with tree construction algorithms such as parsers, or by more formal systems of attribution \nrules such as attribute grammars [12]. In attribute grammar formalisms, the rules for calculating attribute \nvahes are functionally specified and are associated with the pro\u00adductions of a context-free grammar. \nOther formal attri\u00adbution methods vary the attribute gmtnmar approach in two ways. The first is to associate \nattribution rules directly with the structure of the tree. For example, Farnum s attribute pattern sets \n[5] associate attribution rules with tree patterns. The second kind of variation is in the language in \nwhich the attribution rules are expressed. An example is Ballance s logical constraint grammars [1, 2]. \nKahn s naturai semantics [10] vzu-ies attribute grammars in both these ways. Although attributions are \noften used simply to dec\u00adorate the nodes of a tree, they can also be used to construct new trees, computing \neither a transformation within the same tree language or a translation to an\u00adother tree language. In \nthis case, the attribution rules are operations on trees that build new trees. A com\u00adpiler may, for example, \nuse attribution rules to generate intermediate code in tree form. It is possible to build up a sequence \nof transformation or translation steps by defining a set of attribution rules for each family of trees \ngenerated by an earlier attribution. For example, a compiler might use attribution rules to translate \nthe intermediate code into machine code. The contribution of this paper is to define a new tree attribution \nformalism for trtmslations, called sim\u00adple tree attributions, that admits desctiptional compo\u00adsition \nnamely, the ability to take two attribution spec\u00adifications, the second of which attributes the trees \nthat are outputs of the first attribution, and to compose the specifications into one new specification \nthat translates from the inputs for the first attribution to the outputs of the second attribution. Descriptional \ncomposition en\u00adables a translation to be structured both for modularity and for efficiency. By specifying \na tree transformation or a translation as a sequence of smaller phases , each phase is doing a smaller \njob. As a result, the specifica\u00adtion will be clearer and thus less likely to have major errors. In addition, \nit is often possible to re-use phases in different combinations. For example, compilers can share intermediate \noptimizing transformation phases, but still have separate target-specific code-generation phases. An \nimportant advantage of composition is the elimination of an explicit generation and traversal of the \ninter-phase representations. Once two translations are composed, the intermediate form that links them \ntogether has been eliminated. There have been several earlier approaches to de\u00adscribing formally such \na sequence of translations; among them are attribute coupled grammars [8, 9], higher\u00adorder attribute \ngrammars [13, 14], and composable at\u00adtribute grammars [6]. To achieve descriptional composi\u00adtion, both \nattribute coupled grammars and composable attribute grammars impose restrictions that limit the power \nof attributions. In the published reports on these approaches, a compiler written with these restrictions \ncan not use an attribute value to determine a reorder\u00ading of subtrees of a node, say for instruction \nscheduling. Neither can it generate multiple copies of a code seg\u00adment, as in loop unrolling. Neither \ncan it generate an intermediate code tree in which a use of a variable has a remote reference to the \ndefinition site in that tree. Our method, an extension of composable attribute grammars, achieves descriptional \ncomposition while pro\u00adviding significantly enhanced expressive power. The added power comes from a combination \nof the use of conditionals to determine the structure of the tree, the use of computed values to determine \nthe size of the tree, and the ability to access attributes of remote nodes. With this power, the examples \nmentioned previously can be handled. The organization of the remaining sections is aa fol\u00ad lows. We \nfirst define simple tree attributions and the tree languages that go along with them, using an ex\u00ad ample \ndrawn from compilation. We then present our composition algorithm, applying it to the example. Fi\u00ad nally, \nwe discuss the properties of our approach and relate it to other methods. 2 Simple Tree Attributions \nfor Tree Languages In attribute grammars, attribution rules are associated with productions of a context-free \ngrammar. Corre\u00adspondingly, in a simple tree attribution the attribu\u00adtion rules are associated with the \nKinds of nodes used in the tree. We use tree-based attribution rather than grammar-baaed attribution \nin order to get the full power of Farnum s attribute pattern sets[5]. However, in this paper we limit \nthe discussion to specifications in which each kind of node is associated with rules for computing the \nattributes of that node and its immediate subtrees. There is a simple mapping between such a tree-based \nspecification and a grammar-based specification. 2.1 Tree Languages A tree language, namely, a set of \ntrees, is defined by a set of phyla, and a set of constructors. The names of the constructors label the \ntree nodes. The constructors (and the node labels) are partitioned into subsets asso\u00adciated with the \nphyla defining the tree language (i.e., each constructor belongs to exactly one phylum). A constructor \nfor a node label is a function that creates a subtree rooted at a node with that label. Its parameter \nlist specifies the ordered sequence of subtrees that constitute the children of the node and the values \nassociated with the root node. Following Ganzinger and Giegerich [8], we call the subtree parameters \nsyntactic parameters and the other parameters (including remote references to subtrees) semantic parameters. \nThe set of trees in a tree language are those that can be built by repeated use of the constructors. \nIn order that there be a base case for starting tree construction, there must always be at least one \nconstructor that has no syntactic parameters. Such a constructor creates a leaf node. Constructors are \ninvoked aa ordinary functions. Phyla play the role of nonterminals in a context-free grammar in the sense \nthat phyla denote sets of subtrees, while nonterminals denote sets of substrings. Construc\u00adtors play \nthe role of grammar productions. Each phy-Ium represents the set of all possible subtrees whose roots \nare labeled by a constructor associated with that phylum. By analogy with the start symbol or root symbol \nof a context-free grammar, one phylum of each tree language may be designated the root phylum. A tree \nin the language (as opposed to a subtree) is one in which the node label of its root node belongs to \nthe root phylum. Some tree languages allow all defined subtrees in all contexts; in this case, there \nis one phylum and all node labels and constructors belong to it. More com\u00admonly in the case of abstract \nsyntax trees, there is one phylum for each nonterminal in the abstract syntax. Examples of tree languages \nFigure 1 defines two tree languages, a simple arithmetic programming language and a simple low-level \nvirtual machine language. language SIMPLE.PROGRAM begin root phylum Program; phylum Expression; phylum \nDeclaration; constructor program(e Expression) : Progrm; constructor let(d : Declaration; val, body \n: Expression) : Expression; constructor def(name : String) : Declaration; constructor plus(el,e2 : Expression) \n: Expression; constructor mi.nus(el,e2 : Expression) : Expression; constructor constant(i : Integer) \n: Expression; constructor use(d : remote Declaration) : Expression; end; language VMACHINE begin root \nphylum Instruction; phylum Register; constructor register(i. : Integer) : Register; constructor fpo \n: Regi,ster; -\u00ad frame pointer constructor constructor constructor constructor constructor constructor \nloadi.(reg load(dest add(dest addi(dest mov(dest seq(il,i2 : Register; : Register; : Register; : Register; \n: Register; : Instruction) i : Integer) : Instruction; address : Register): Instruction; s1,s2 : Register): \nInstruction; s : Register; i : Integer) : Instruction; source : Register): Instruction; : Instruction; \n-\u00adsequencing constructor nop ( ) : Instruction; end; Figure 1: Example Tkee Languages Thefirst treelanguage, \nnamed SIMPLE_PROGRAM, has three phyla, Program, Expression and Decl~ation, pro ramand seven constructors. \nThe important illustrative char- 7 acteristics ofthekmguage arethat the let constructor creates nested \nscopes and the use constructor creates a remote reference. The second tree language, named let VMACHINE, \nhastwophylaand nine constructors. The frame pointerfp will beused in the generated codeto access nonlocal \nscopes.  / -7\\ def conetant let Figure 2showsa SIMPLE.PROGWM tree. The arrows from the use s are \nremote references; semantic pararn\u00adetersto constructors appear below the node labels. 2,2 Simple Tree \nAttributions 11*I A IY3 A simple tree attribution is defined over a source tree language. For each phylum \nof the tree language, the tree attribution declares zero or more named and typed use use attribute descriptions. \nEach attribute is either synthe\u00adsized or inherited. With each constructor of the tree language, the simple \ntree attribution associates a clause that defines its attributes. We use pattern matching to sssociate \nconstructors Figure2: ASIMPLEYROGRAM tree with attribute definition clauses. Each clause is gov\u00ad attribution \nrealize.as.bytecode[VMACHINE] begin synthesized attribute bytecode(i : Instruction) : byte.string; synthesized \nattribute reg.bytecode(reg : Register) : byte-string; match ?r=register(?i) begin r.reg-bytecode := \nregnum-to.byte.string(i.) ; end; match ?r=fpo begin r.reg_bytecode := FP; end; match ?l=loadi(?reg,?i) \nbegin  l.bytecode := LOADI II reg.reg-bytecode II integer_to-byte_string(i); end; . . . Analogou.dyfor \nload, add, addi, and mov match ?s=seq(?il,?i2) begin s.bytecode := il.bytecode I I i2.bytecode; end; \nmatch ?n=nopo begin  n.bytecode := ; --no bytes generated for NOP. end; end; Figure3: Simple Code Generation \nerned by a pattern for the constructor with a pattern variable for the result and one for each parameter. \nThe clause consists of an unordered collection of attribute definitions. Synthesized attributes are defined \nfor the root of the constructed subtree; inherited attributes are defined for the syntactic parameters \nof the constructor. We give two examples to explain simple tree attribu\u00adtions, beginning with the simpler \nbytecode generation phase. Thetwoexamples canbeviewed as phases ofa compiler. We will use these examples \nlater to illustrate descriptionad composition. &#38; we explain the examples, we describe a number of \nfeatures of simple tree attribu\u00ad tions: local attributes, conditional attribution, syntac\u00ad tic attributes, \nremote references and functions. Simple tree attributions have other features that will not be dis\u00adcussed \nhere. These include variable-wit y constructors, default attribute values, private attributes, attributes \ndefined for every phylum ofatree language, and Far\u00adnum s attribute pattern sets [5]. Our first example, \ngiven in Figure 3, is a simple tree attribution named realize.as-bytecode that creates astringofbytes \nfortheVMACHINE languageinFigure l.l A synthesized attribute oftypebyte_str ingis defined for each VMACHINE \nphylum. The patterns provide acase 1Pattern variables are prefixed by ? in match expressions; I 1 denotes \nstring concatenation. We use the syntax var\u00adname. name to refer to an attritmte name of a node bound \nby the pattern match to a pattern variable varname. The integer-t o.byt e_string and regmm-t o-byt estring \nfunctions do type conversion. analysis for the constructors, defining the bytecode at\u00adtribute ofeach \nsubtree ofthe Instruct ionphylum and the reg_bytecode attribute of the Register phylum. The cases that \nare elided in the figure can be inferred from the corresponding constructors. Thesecondexample, compile-simple \nshowninFig\u00adures 4 and 5, defines a simple tree attribution for the language SIMPLE_PROGRAM. The attribution \ntranslates its source tree into a tree of VMACHINE instructions. In Figure 4, semantic attribute decl-depthis \nde\u00adfined for the Declaration phylum, and semantic at\u00adtributes scope-depth, reg_num, and reg-use are de\u00adfined \nfor the Expression phylum. Two syntactic at\u00adtributes (attributes whose values are used to construct trees) \nare defined, the attribute code for the Expression phylum and the attribute progcode for the Program \nphylum. Values for syntactic attributes are created by constructors and may freely use the values of \nsemantic attributes. The simple tree attribution compile_ simple defines a group named compilation. Agroupis \nadevice teas\u00adsociate attributes and functions that collaborate to pro\u00adduce a tree. Theattributes and \nfunctions in the group compilation produce VMACHINE trees. A simple tree attribution may define more \nthan one group, including mu~tiple groups over the same output tree language. Each syntactic attribute \nin a simple tree attribution must be included in a group. The syntactic attributes in the example each \nproduce VMACHINE subtrees of the Instruction phylum. attribution compile_simple[SIMPLE-PROGRAM] begin \n --scope.depth and decl_depth count surrounding blocks: inherited attribute scope-depth(e : Expression) \n: Integer; inherited attribute decl.depth(d : Declaration) : Integer; --reg-num is the register number \ninto which to compute the result inherited attribute reg-num(e : Expression) : Integer; --reg-use is \nthe number of registers needed to compute the result synthesized attribute reg.use(e : Expression) : \nInteger; group compilation[VMACHINE]; synthesized attribute code(e : Expression) : Instruction in compilation; \nsynthesized attribute progcode(p : Program) : Instruction in compilation . . . clause section end; Figure4: \nGeneration of VhtualM achineC ode( declarations ection) In the SIMPLE.PROGRAM tree language, ause node \nstructions. The valueoftimes is the difference in scope contains a remote reference to a def node, providing \ndepths; registhe register into whichto place there\u00adaccess to the attributes of the variable declaration. \nIn suit. The size of the generated tree is determined by simple tree attributions, attributes of a remote \nreference the semantic parameter times. may be read but not remotely defined. The syntactic Figure 5 \ngives the clauses defining the attributes for attributes of a remote node may not be passed as syn-the \nconstructors of SIMPLE.PROGRAM. Again the pat\u00adtactic parameters to constructors. terns provide acase \nanalysis for the constructors of the Syntactic attributes can be used for at least two tree language. \nTheclauses matching subtrees rooted by conceptually different purposes: to provide a simpli-plus nodes, \nand those rooted by use nodes illustrate fied view of the tree for another attribution purpose several \nfeatures of the attribution language. (such as name resolution) or to compute a transform A simple tree \nattribution clause may define an at\u00adtion (such aafor code generation, asin this example). tribute local \nto that clause. Local attributes allow the Syntactic attributes are used for the second purpose programmer \nto factor out common parts ofanexpres\u00adin attribute coupled grammars. Composable attribute sion, and are \noften initialized at the definition site. In grammars use syntactic attributes for both purposes. the \nclause for plus, a local attribute addition is used Eachsimpletree attributionmay declare helperfunc-to \nfactor out acommon part ofthe subtree being gener\u00adtions used inthe attribute definitions. Like attributes, \nated. A local attribute can be considered a synthesized functions are either semantic or syntactic. Syntactic \nattribute that cannot be defined or used outside of the functions also must be part of agroup. The bodyof \ncontext of a simple tree attribution clause. the functionis simply an expression of the same form A simple \ntree attribution clause may have attribute as those used in attribute definitions. Functions derive definitions \ninside if statements, Such conditionaJattri\u00adtheir expressiveness from recursion. butionsarewell-defined \nifeveryattribute definedwithin In the SIMPLE-PROGRAM language, abound variable one branch ofan if statement \nis defined in the other may be used in scopes nested within its declaration branch(es), and is not defined \noutside theif.3 In the scope. Every let is implemented asa full stack frame, plus clause, the definitions \nofe. reg.use, ei.reg-nmn, using a frame pointer and static links. Therefore the e2.reg-num ande.code \nare allin if statements. Note code for a variable use may need to traverse multiple that if s may be \nnested arbitrarily. Attribute values static links.2 The link traversal code is generated using also can \nbe defined by if expressions, as illustrated by the syntacticfunction followJinkdefined in Figure5. the \nsecond definition of e.reg-use. It is possible to Function follow.1 ink takes two semantic parameters \ntransform a simple tree attribution with conditional at\u00ad(times and reg) and generates a tree of VMACHINE \nin-tributions into one without it by transforming all if 2This situation arises in programming languages \nwith nested swe make the Safeassumption that each (non-identical) Con\u00adfunctions that can be passed as \narguments to other functions. ditional expression is independent. -\u00ad generate code to follow the static \nlink in register reg times times. function follow_limk(times : Integer; reg : Integer) : Instruction \nin compilation is if times = O then nop ( ) else seq(follow-link (times-l,reg), seq(addi(register (reg),r \negister (reg),S L.OFFS llZ ) , load(register(reg) ,register(reg)) )) endif; end; match ?p=progrern(?e) \nbegin e.scope-depth := 0; e.reg-num := 1; --start using registers from register 1 p.progcode := e.code; \nend; match ?l=let(?d,?v,?b) begin local depth : Integer := l.scope_depth+l; d.decl_depth := depth; v.scope-depth \n:= depth; b.scope_depth := depth; l.code := Establish a frame, elaborate declaration, perform b.code, \npop frame; l,reg_use := max(v.reg_use,b.reg-use) ; v.reg-num := l.reg.num; b.reg-num := l.reg-num; end; \nmatch ?d=def(?n) begin --nothing to do here end; match ?e=plus(?el,?e2) begin local addition : Instruction \nin compilation := add(register(e.reg-num) ,register(el.reg_num),reglster(e2.reg_num) ); if e2.reg-use \n> el.reg.use then --do e2 first e.reg.use := e2.reg-use; el.reg-num := e.reg.num+l; e2.reg-num := e.reg-num; \ne. code := seq(seq(e2.code, el.code), addition); else --do el first e.reg_use := if el.reg-use = e2.reg-use \nthen el.reg-use+l else el.reg_use endif; el.reg_num := e,reg-num; e2.reg-num := e.reg-num+l; e. code \n:= seq(seq(el.code, e2.code), addition); endif; el.scope_depth := e.scope-depth; e2.scope-depth := e.scope-depth; \nend; match ?e=minus(?el,?e2) begin . . . (Analogous to plus) end; match ?e=constant(?i) begin e.reg-use \n:= 1; e. code := loadi(register(e.reg_num), i); end; match ?u=use(?d) begin u.reg-use := Q; local depthdiff \n: Integer := u.scope-depth -d.decl.depth; u. code := seq(seq(move(register(u.reg-num) ,fpo), follow-link(depthdiff \n,u.reg-num)), load(register(u .reg_num),register (u.reg_num))); end; Figure5: Generation of Virtual Nlachine \nCode (clause section) 5?-Establish a stack frame LOADI R1 2push frame loadi Store x Establish a stack \nframe IIOADI RI 3 Store y,----\u00ad. . . . . . . . . . . . . . . . . . . . . . . . . \\ I MOVE R1 FP : ADDI \nR1 RI SL.OFFSET j ,--------~zg\u00ad7,,, L. load,, A, / reg, move, i~ nop 1 reg fp addi i ,, /\\ reg I, move \n, A1 ,,, reg fp load $,,2 nop load reg reg 22 1 12 \\ LOAD RI R1 LOAD RI R1 ~..-. . ------\u00ad--------MOVE \nR2 FP LOAD R2 R2 ADD R1 RI R2 Pop stack frame , . . . . . . . . . . . 1 - SL.OFFSET ~ , Pop stack frame \n\\ , reg reg reg reg t . . . 11.. --\u00ad------\u00ad . -----\u00ad 1 . . . . . . . . . . . . . . --------\u00ad 1 ..\u00ad ,; \n.,, Figure 6: The VMACHINE version of Figure 2, and its byt e.string realization statements to equivalent \nuses of if expressions. Alter\u00adnatively, any use of an if expression can be replaced by conditional attribution. \nIn the example, the if s are used so that the definitions of the attributes for plus minimize register \npressure by scheduling the sub\u00adtree that needs more registers before the other subtree. Figure 6 shows \nthe result of applying compile. simple to the example in Figure 2 and the result of applying realize_as-byt \ne_code to that result. The regions en\u00ad closed in use of x In the bels for sequence dotted lines show \nthe various stages for the in the input. VMACHINE tree, we omit the internal node la\u00adseq. The byte code \nis written so that each of bytes for an instruction is on one line. Descriptionai Composition Descriptional \ncomposition takes a simple tree attribu\u00adtion Al defined over a source tree language TA1 with a group \nG defined on some target tree language TA2 and composes it with a simple tree attribution A2 defined \nover TA2.4 The resulting simple tree attribution has the same effect as the functioned composition of \nAl and A2 but the intermediate tree in TA2 is never produced. Moreover, since the composed simple tree \nattribution AA~~hOU@ l-Al and TAZ are different tree languages in our example, they need not be in general. \nexposes all the computation of both Al ad A2, it can be optimized using partial evaluation. If we descriptionally \ncompose the simple tree attri\u00adbution compile_ simple in Figures 4 and 5 with the simple tree attribution \nrealize_ as_bytecode in Fig\u00adure 3, we get a simple tree attribution over the language SIMPLE_PROGRAM \nthat computes the bytecode directly. The composition is shown in Figure 7, It will be ex\u00adplained in the \nfollowing section. 3.1 Achieving Descriptional Composition In this section, we describe an zdgorithm \ntional composition. This algorithm works attributions satisfying certain properties, introduced as the \nneed for them arises. In the composed simple tree attribution include unchanged every semantic attribute \nsemantic function of Al, and every group Moreover, every function in A2 (semantic for descrip\u00adonly for \ntree which will be Al_A2, we of Al, every other than G. or syntaxtic) is carried over unchanged. Every \nsyntactic attribute and function in G is replaced by composed attributes and functions. To simplify the \ncomposition constructions, we sim\u00adplify the forms of the attribute definitions being trans\u00adformed. Nested \ncalls to constructors or functions are eliminated by introducing local attributes. All if ex\u00adpressions \nare transformed to the corresponding if state\u00ad attribution compile_simple.realize_as-bytecode[SIMPLE-PROGRAM] \nbegin . . . Semantic attrihtes ofcompile-simple remain as before. -\u00adcomposed attributes: synthesized \nattribute code-bytecode(e : Expression) : byte_string; synthesized attribute progcode_bytecode(p : Program) \n: byte-string; -\u00adcomposed function: function follow_li.nk_bytecode(times : Integer; reg : Integer) : \nbyte-string 1s if times = O then It II else followJink_bytecode(times-1 ,reg) 11 ADDI II regnum_to_byte-strlng(reg) \nIi . . . II LOAD II regnum_to_byte-strlng(reg) 1! regnu_to-byte_strlng(reg)); endif end; match ?p=progrsm(?e) \nbegin . . . p.progcode-bytecode := e.code_bytecode; end; match ?l=let(?d,?v,?b) begin . . . l.code_bytecode \n:= . . . . end; match ?d=def(?n) begin end; match ?e=plus(?el,?e2) begin local addition_bytecode : byte-string \n:= ADD II regnum_to-byte-string(e.reg-num) II regnum.to-byte-string(el.reg-num) II regnum-to-byte-stri.ng(e2.reg-num) \n; if e2.reg-use > el.reg-use then . . . e.code_bytecode := e2.code-bytecode I I el.code_bytecode II addition-bytecode; \nelse . . . e.code_bytecode := el.code-bytecode I I e2.code-bytecode 1[ addition_bytecode; endif; end; \nmatch ?e=mi.nus(?el,?e2) begin . . . Analogous to plus end; match ?e=constant(?i-) begin . . . e.code_bytecode \n:= LOADI II regnum-to-byte-string(e.reg-num) II integer-to-byte-string(i); end; match ?u=use(?d) begin \n. . . u.code-bytecode := MOV 11 regnum_to_byte_string(u.reg_num) II FP II follow_link_bytecode(depthdiff, \nu.reg_num) II LOAD II regnum_to_byte_string(u.reg_nwn) II regnum_to-byte_string(u.reg_num) ; end; end; \nFigure7: Generated Byte String Compiler ments. Then the attribute definitions have the form if condl \nthen i.f con~ then . definition endkt; endif; where definition has one of the forms attro : = attrl; \nor attro : = constructor ( attrl, attrz,. . . ); or attro := function (attr~, attr~,... );. In A1.A2, \neach attribute in G is composed with each attribute in A2 for the same phylum. Since syntactic functions \nbuild their subtrees bottom-up, for each func\u00adtion in G, a composed function is introduced for each synthesized \nattribute of the result phylum. In order to incorporate the inherited attributes of the constructed subtree, \nfor each syntactic formaJ parameter of a func\u00adtion in G, a composed function is added for each inher\u00adited \nattribute of its phylum in A2. We consider each case in turn. Since the introduction of composed functions \nalso affects their calls, consider first the two forms of at\u00adtribute definition that make no calls on \nsyntactic func\u00adtions. Suppose the definition haa the form attro : = attrl ; where attro is defined in \nG and the value of attribute attrl belongs to some phylum of TA2. For each at\u00adtribute name defined in \nA2 for that phylum, if name is a synthesized attribute, the corresponding composed definition is of the \nform attro. name : = attrl . name; If name is an inherited attribute, the corresponding composed definition \nis of the form attrl. name : = attro. name; For instance, compile. simple has the definition p .progcode \n: = e. code; When we compose this definition with the single syn\u00adthesized attribute byt ecode for phylum \nInstruction, we get the definition p. progcode. bytecode : = e. code. bytecode; Suppose the attribute \ndefinition in G has the form attro : = constructor ( attrl, attrz,. . . ) ; In A1.A2, we compose this \ndefinition with the attribute definitions for that constructor in A2, replacing each pattern variable \nfor that simple tree attribution clause by the corresponding attribute instance in the defini\u00adtion. For \nexample, the plus clause in compile_ simple includes the definition e. code : = seq(seq(e2. code, el. \ncode) , addition) ; which is replaced by two definitions such as 10C341 := seq(e2. code, el, code) ; \ne. code : = seq(loc341 ,addition) ; when nested constructors are eliminated. (Here 10C341 is the name \nof the local attribute that is introduced.) When we compose these definitions with the definition of \nattribute bytecode in realize-as. bytecode, we get the definitions 10 C341. bytecode := e2. code. bytecode \nI I el. code .bytecode; e. code .bytecode := 10 C34I. bytecode I I addition. bytecode; Finally, we name \nall attributes of A1-A2 by applying the rules: namel. namez * namel _name2 node. namel. namez + node. \nnamel .namez For example, the preceding definitions are rewritten aa p. progcode_bytecode : = e. code_byt \necode; loc341_bytecode := e2. code_bytecode I I el. code-bytecode; e. code_ byte code : = loc341_bytecode \nI I addition_ bytecode; (For simplicity, we assume no name conflicts ensue with this rule. If necessary, \nunique names can be created.) In the composition process, for each (syntactic) func\u00adtion function of \nG, a composed function is created for each synthesized attribute name of A2. The composed functions compute \nthe values those attributes would have for the subtree built by the original syntactic func\u00adtion. We \ncreate names function-name for these func\u00adtions. Since in A2, a synthesized attribute of a node may depend \n(directly or indirectly) on the inherited at\u00adtributes of that node, the composed functions must be passed \nsome of the inherited attributes of the subtree generated by function. Furthermore, if function takes \nsyntactic parameters, the synthesized attributes of each such parameter may affect the synthesized attributes \nof the generated subtree. Therefore, the composed func\u00adtions must be passed some of the synthesized attributes \nof each parameter. The inherited attributes of each syntactic paramet\u00ader must be computed in some way, \nsince the structure built around each parameter would define its inherited attributes, Therefore, Al \n_A2 must include functions for each of the inherited attributes of A2 that would be defined for that \nsyntactic parameter. We name these functions using the names of the function, the formal syntactic parameter \nand the inherited attribute: func\u00adtion_formal_name. Again these functions must passed some of the inherited \nattributes of the generated subtree and some of the synthesized attributes of each syntac\u00adtic parameter. \nThe set of attribute values that must be passed to these functions can be computed statically from the \nfunctions and A2, using analysis similar to that for computing whether an attribute grammar is strongly \nnon-circular [4]. Consider an attribute definition of the form attro := function (attrl, attrz,.. . \n) ; The subtree returned by the function will be of some phylum of TA2. For each synthesized attribute \nname defined in A2 for this phylum, we add a composed def\u00adinition of the form attro. name := function_name \n(...); The needed composed attributes are passed to the com\u00adposed function. Each syntactic parameter \nof the function belongs to some phylum. For each inherited attribute name de\u00adfined in A2 for this phylum, \nwe add a composed defki\u00adtion of the form Utt Tj . name := function_ formalj-name (... ) ; Again, we must \npass needed composed attributes. For example, in the clause for the use constructor in compile.simple, \nafter nesting haa been replaced by introduction of local attributes, our example would have a definition \nsuch as: 10cI72 := f ollow_link (depthdif f ,U. reg.num) ; In the composed simple tree attribution, this \ndefinition would be replaced eventually by loc172-bytecode : = f ollow.link.byte code (depthdif f, u. \nreg-num) ; The composed function needs no additional parameters because f ollow.link does not take any \nsyntactic pa rameters, and realize_ as-bytecode does not have any inherited attributes. Next we must \ndefine the new functions for the com\u00ad posed description. To reuse the composition rules just described, \nwe treat functions as if they were simple tree attribution clauses for pseudo constructors of TAZ. Each \nof the formal parameters to the function becomes a parameter to the pseudo constructor, and the pattern \nvariable bound to the result of the constructor is used as a local attribute. By introducing local attributes, \nthe clause can be put in the simple form used previously. The result is not a well-defined simple tree \nattribution clause; we use it only for descriptional composition. For example, if we treat follow-link \nin Figure 5 in this way, we have the clause match ?f ollow_link=pc197 (?times, ?reg) begin local 10cI98 \n: Integer; local 10C199 : Register; ... if times = O then follow-link := nopo; else 10C198 : = times-l; \n10C199 := f ollow-link(loc198 ,reg) ; 10C2OO : = register (reg) ; 10C201 := register (reg) ; 10C202 : \n= addi (1oc2OO, 10 C201, SL.OFFSET) 10C203 : = register (reg) ; 10C204 : = register (reg) ; 10C205 := \nload (loc203, 10 C204) ; 10C206 : = seq(loc202, 10 C205) ; follow-link := seq(loc199,10c206); endif; \nend; (Note that thename follow_ link is used both asa local attribute and as a function.) We then perform \ncomposition on all attributes that compute tree nodes. In our example, this gives us the composed clause \nmatch ?follow.link=p197 (?times, ?code) begin local 10C198 : Integer; local loc199_bytecode : byte-string; \n... if times = O then follow_ link_bytecode := ; else 10cI98 := times-1; loc199_bytecode := f ollow-link_bytecode \n(loc198 ,reg) ; ... follow_link_bytecode := loc199-bytecode II loc206_bytecode endif; end; Then we convert \nthe result backto a function. Since function bodies are expressions, if statements are con\u00adverted to \nif expressions, local attributes that name composed functions are converted into function defini\u00adtions, \nand local attribute uses are replaced by their defi\u00adnitions. Theconverted function follow-link-bytecode \nis shown in Figure 7. Remote node references, in which a designation of a node may be passed through \nthe attribute system and then queried for (inherited or synthesized) attributes, require special attention \nin the algorithm. Attributes or functions that have node references as wdues and function parameters \nthat take node references as values must be declared in the group of the nodes being [re\u00adferred to]. \nThe algorithm treats them much the same as syntactic attributes or functions, except that since at\u00adtributes \nof node references can only be read, never writ\u00adten, for the purposes of composition all the attributes \nof the node reference phylum in A2 can be treated as if they were synthesized. 3.2 Complications In \nthis section, we discuss the ways in which the com\u00adposition algorithm may fail, producing a simple tree \nattribution that is circular or not well-formed. Graphs If Al builds a (directed acyclic) graph, rather \nthan a tree, and A2 haa inherited attributes, the resulting sim\u00adple tree attribution will be ill-formed \nbecause there will be two competing definitions for the composed inher\u00adited attributes. Moreover, it \nis assumed that whenever a subtree is assigned to a syntactic attribute, or passed as a syntactic parameter \nto a constructor or function, the attribute or parameter is the sole consumer of that subtree. If a subtree \nis used syntactically in more than one place (other than in the two branches of an if), the algorithm \nwill fail, again by producing two competing definitions for inherited attributes. We term the restriction \nthat such a subtree may only be used once the syntactic at most one dgnamic use re\u00adquirement echoing \nthe syntactic single use requirement of Ganzinger and Giegerich [8]. We say syntactic be\u00adcause the restriction \nis only on syntactic uses. We say at most one because we permit a subtree to be unused, in which case \nthe composed inherited attributes will get default values. We say dgnamic use because our restric\u00adtion \nreflects the fact that only one branch of an if will be active each time it is used dynamically. We call \nthe restriction by its acronym (SAMODUR). Attributes Needed by Composed Functions The analysis we do \nto determine what parameters must be pawed to a composed function cannot distinguish between values that \nare used in some circumstances, and values that are always used. Sometimes, even if both Al and A2 are \nwell-formed, a composed function may (directly or indirectly) require its own result aa a parameter, \nin which case, the result of descriptional composition is circular. If we restrict A2 to belong to an \nevaluation class cor\u00adresponding to the attribute grammar evaluation class SNC [4] (also known ~ ANC [11]), \nthe summary graphs for syntactic functions will not result in cycles in the composed simple tree attribution. \nIf the functions take syntactic parameters, then, in general, A2 must belong to an evaluation class corresponding \nto the doubly non\u00adcircukar class DNC [7]. Intuitively, a simple tree attribution is SNC if it can be \nimplemented as a set of mutually recursive strict functions, each of which computes a single synthesized \nattribute of a phylum as a function of a subset of its inherited attributes. A simple tree attribution \nis DNC if inherited attributes can be computed that way aa well. Remote Node References Recall that in \nconstructing the composed functions, the use of a local attribute is replaced by its definition. If the \ndefinition invokes a constructor, then in the pres\u00adence of remote references, this transformation may \nno longer be correct, since a reference is a designation of a particular node, and each call to a constructor \nreturns a new node. Our expression language permits let bindings, which can be used instead of loccd \nattributes, so this problem does not axise unless A2 haa more than one node-valued attribute (that is, \na syntactic attribute or an attribute carrying a remote reference) that share a certain node constructed \nlocally. Even if there are multiple synthe\u00adsized node-valued attributes, but they could be evalu\u00adated \nin one pass, a modified version of the algorithm could compute them aJl together in a single composed \nfunction that returns a tuple of values. Similarly if the node-valued attributes cannot be evaluated \nin one pass, but can be ordered in multiple passes, we can construct tuples of anonymous functions that \nshare local attribute bindings and take the necessary inherited attributes. In addition, the use of remote \nnode references can lead to circularities, or at least make it very difficult to determine attribute \ndependencies statically. Strictly speaking, a simple tree attribution that reads attributes through remote \nnode references cannot be SNC because not all data dependencies into a subtree are given by the inherited \nattributes. This fact does not cause problems for the algorithm. If a function of Al creates a tree with \na node reference used by A2, it must have created the correspondkg node itself, or have the reference \npassed to it as a parameter. In either case, the dependency can be tracked easily. Nonseparability In \nsimple tree attributions, as in composable attribute grammars, attribute definitions may use the values \nof attributes of a generated node (attributes that are de\u00ad fined by a later attribution), even if an \nout-of-order attribution evaluation is required. In other words, Al may use the values of attributes \nof A2 on nodes created in the group G. However, in this case circularity may result, because Al mayusethe \nvalues read todetermine the structure to be used for the tree being built. I)escriptional compo\u00adsition \nwill only introduce circularity if the (functional) composition is intrinsically circular. Farrow, Marlowe \nand Yellin [6] define a property of Al that is sufficient for preventing circularity in the result. They \nterm this property separabdity.5 A simple tree attribution is sep\u00adarable provided no construction of \na subtree depends di\u00adrectly or indirectly on an attribute read from any other node in the same tree. \nSummary We can give a safe domain for our algorithm: descrip\u00adtional composition of Al and A2 is possible \nwhen the following conditions are met: both Al and A2 are noncircular  Al is separable.  o Al satisfies \nSAMODUR or A2 has no inherited attributes. o Al has no syntactic functions or the following hold:  \nA2 is strongly non-circular (SNC) . Al has no syntactic parameters or A2 is dou\u00adbly non-circular (DNC) \nthe node-valued attributes of A2 can be or\u00addered. In section 3.4, we put forward some ideas for removing \nthe last set of conditions. 3.3 Properties of Composed Tree Attributions To compose a whole series of \nsimple tree attributions into a single simple tree attribution, one needs to be able to use the composition \nalgorithm with composed simple tree attributions. Since the algorithm can fail outside of the safe domain \nmentioned above, it is important to see what properties of the resulting simple tree attribution can \nbe guaranteed. As it turns out, even when all the tree attributions individually have very simple depen\u00addencies, \nthe composition may be much more complex. 5For Farr~~, Marlowe and Yellin, separability is actuallY de\u00adfined \nas a property of a collection of composable attribute gram\u00admars, not an individual GAG. Superficial Circularity \nSAMODUR takes into account that the two branches of an if are mutually exclusive, but the standard defi\u00adnitions \nof evaluation clssses for attribute grammars do not. As a result, the composition may be superficially \ncircular. For examplee, if Al haa an equation such as p . out : = if cond then construct (cl. out, c2. \nout) else construct (c2. out, cl. out) endif; and A2 haa a simple dependency thread for construct with \ninherited attributes: match ?a=construct (?b, ?c) begin b.i := a.i; c.i := b.s; a.s := C.s; end;  (where \ni is always used to compute s), then A1.A2 would be considered circular under the traditional def\u00adinition, \nalthough it may not actually be circular: cl. out_i := if cons! then p. out-i else C2. out_s endif; c2. \nout_i : = if cond then cl. outs else p. out-i endif; p . out_s : = if cond then C2. out-s else cl out-s \nendi.f; (where out_i is used to compute out_s). We believe that we can redefine the standard at\u00ad tribute \ngrammar classes (such ae SWEEP, LORD, DNC and SNC) to take into axcount the nonstrictness of if. Basically, \neach constructor can be split into several otherwise identical constructors except that each han\u00ad dles \nthe case for a different value of a conditional used in an attribute definition. According to this redefinition, \nthe example composed attribution above would be in the SWEEP class (one pass, either left to right or \nright to left depending on the constructor; that is, depending on the condition). Syntactic Parameters \n If a syntactic function in Al takes syntactic or remote node reference parameters, then in the composed \nsim\u00adple tree attribution, we will have a composed function for each of the appropriate synthesized attributes \nin A2. If some of these synthesized attributes are syn\u00adtactic (i.e., A2 builds trees also), then it is \npossible bThis example is a simplified version of the definition for .s.code in the clause for plus in \nFigure 5. that SAMODUR will be violated in the composed sim\u00adple tree attribution. For example, two composed \nfunc\u00adtions could each take the same syntactic attribute as a parameter, and each use the parameter under \nmu\u00adtually exclusive conditions, Even if both Al and A2 satisfy SAMODUR, even though A1.A2 actually still \nbuilds a tree; the composition algorithm as given cannot compose it any further because SAMODUR is violated. \nSAMODUR assumes that every syntactic parameter is always used by the function to which it is passed, \nThe problem can be traced back to the fact that when we compose the function with A2, we pull apart the \ncomposed attribution clause for the pseudo-constructt ]r into separate composed functions. When we determine \nwhat parameters are used by the body of each function, we must of necessity include every parameter that \nmight be used by the composed function. This analysis suggests two lines of attack for avoid\u00ading this \nproblem. First, it seems that the condition that determines whether the parameter is used could be computed \nin advance of a call, and used to condi\u00adtion the actuaJ parameter. Second, the algorithm could be modified \nso that the composed attribution clause for the pseudo-constructor does not need to be separated into \nfunctions with parameters, and instead aJl the com\u00adposed functions would be defined together. This second \nidea is explored briefly in Section 3.4. Inherited Syntactic Attributes Giegerich gives a thorough examination \nof the closure properties of descriptional composition for attribute cou\u00adpled grammars [9]. Among other \nresults, he gives an example in which descriptionally composing three serial L-attributed attribute coupled \ngrammars gives a com\u00adposed grammar that is not only not L-attributed, but is not even strongly non-circular \n(SNC). However, if in\u00adherited syntactic attributes me not permitted, closure does result for SNC attribute \ncoupled grammaxs. In order to know that repeated composition is pos\u00adsible in the presence of syntactic \nfunctions, we need the result to be SNC. Therefore, if we want guaranteed clo\u00adsure, the simple tree attributions \ncannot have inherited syntactic or remote node reference attributes. Closure In summary, descriptional \ncomposition is closed over the set of simple tree attributions A where A is separable zmd satisfies \nSAMODUR  A is SNC  A has no node-valued function parameters  A has no inherited node-valued attributes \n where SNC is defined by splitting constructors and by ignoring attributes read from remote references \nbuilt into the tree being attributed. Giegerich s proof for at\u00adtribute coupled grammars [9] should carry \nover to sim\u00adple tree attributions, with changes to account for the if s, functions, and remote node references. \n 3.4 Further Work The restrictions given in Section 3.2 on the use of syn\u00ad tactic functions (and somewhat \nunsatisfying. ways to modify the rectly without these In the composition syntactic function parameters) \nare In this section, we suggest some algorithm so that it operates cor\u00adrestrictions. algorithm shown \npreviously, we convert a function body into am attribution clause, com\u00adpose it with A2 and then convert \nit back into a set of composed functions. The body of a function in our sys\u00adtem is simply an expression \nand thus there is no way to express a function that needs multiple passes to com\u00adpletely define its return \nvalue. However, for computing attributes in a simple tree attribution, the programmer is not forced to \ncompute all the synthesized attributes of a node as a function of the inherited ones in one pass. Instead, \nthe program\u00admer gives the definitions and a simple tree attribution compiler finds an evaluation mechanism \nthat accommo\u00addates the dependencies. The question comes to mind as to whether functions could have this \nflexibility aa well. Instead of parameters and a return value, these more powerful functions would have \ninherited and synthe\u00adsized attributes. This expressive power is similar to that of lazy evaluation. However, \nas with attribute grammars, one can define evaluation classes for these functions that restrict the generality \nand that can be checked statically. We believe all the restrictions for syntactic functions given in \nSection 3.2 would go away if the system used these more powerful functions. 4 Comparison with Related \nWork Attribute coupled grammars allow serial phases of a compiler to be defined separately, and then \neither ex\u00adecuted separately or descriptionally composed into a monolithic attribute grammar. Our interest \nin com\u00adposition is for the construction of dynamic compilers, that is, incremental compilers that patch \nrunning pro\u00adgrams [3]. Our method of constructing a dynamic com\u00adpiler requires that the entire task of \ncompilation be de\u00adscribed in a single simple tree attribution. One can consider composable attribute \ngrammars and higher order attribute grammars to be extensions of attribute coupled grammars. In composable \nattribute grammars, a glue attribute grammar may use out\u00adput attributes of a computed tree. The glue \ngrammar is aware of the attributes defined by the component [6] grammars, and uses them to compute the \nresults of the composition. With higher order attribute grammars, there is no distinction between syntactic \nand semantic values, and subtrees may be passed in arbitrary ways in arbitrary data structures to arbitrary \nfunctions. Resulting trees [7] may be grafted into the original tree, and the host attribute grammar \ncan then use synthesized attributes of the root of the grafted tree. The system described here could \nbe expanded easily to accommodate these facilities. However, simple tree attributions that use [8] thk \npower are likely to run afoul of the SAMODUR re\u00adstriction. Furthermore, since for higher order attribute \ngrammars, subtrees do not obey object identity, there is no way to fetch the inherited attribute of a \nnode at [9] the root of a subtree. In a sense, higher order attribute grammars provide so much power \nin the ways in which tree values are used that any interesting descriptional [10] composition is impossible. \nAcknowledgements We thank Robert Giegerich for sharing hk insights with [11] us and for his suggested \nimprovements to the paper. The comments of David Bacon and William Maddox were also most valuable. References \n[12] [1] BALLANCE, R. A. Syntactic and semantic checking in language-bused editing systems. PhD thesis, \nCom\u00adputer Science Division EECS, University of Califor-[13] nia, Berkeley, Dec. 1989. Technical report \nUCB/CSD 89/548. [2] BALLANCE, R.. A., AND GRAHAM, S. L. Incremental consistency maintenance for interactive \napplications. In Proc. of the Eighth International Conference on [14] Logic Programming, K. Fnrukawa, \nEd. The MIT Press, Cambridge, Massachusetts and London, England, 1991, pp. 895-909. [3] BOYLAND, J., \nFARNUM, C., AND GRAHAM, S. L. At\u00adtributed transformational code generation for dynamic compilers. In \nCode Generation -Concepts, Tools, Tech\u00adniques. Workshops in Computer Science, R. Giegerich and S. L. \nGraham, Eds. Springer-Verlag, Berlin, Hei\u00addelberg, New York, 1992, pp. 227-254. [4] COURCELLE, B., AND \nFRANCHI-ZANNETTACCI, P. At\u00adtribute grammars and recursive program schemes. The\u00adoretical Computer Science \n17 (1982), 163-191,235 257. [5] FARNUM, C. Pattern-based tree attribution. In Conference Record of the \nNineteenth Annual ACM SIGACT/SIGPLAN Symposium on Principles of Pro\u00adgramming Languages (Jan. 1992), \npp. 211-222. FARROW, R., MARLOWE, T. J., AND YELLIN, D. M. Composable attribute grammars: Support for \nmod\u00adularity in translator design and implementation. In Conference Record of the Nineteenth Annual ACM \nSIGACT/SIGPLAN Symposium on Principles of Pro\u00adgramming Languages (Jan. 1992), pp. 223-234. FILfi, G. \nClassical and incremental attribute evalua\u00adtion by means of recursive procedures. In Ilth. Coil. on \nTrees in Algebra and Programming (CAAP 86), LNCS vol. 214 (Mar. 1986), P, Franchi-Zannettacci, Ed., Springer-Verlag, \npp. 112-126. GANZINGER, H., AND GIEGERICH, R. Attribute cou\u00adpled grammars. In Proceedings of the ACM \nSIGPLAN 84 Symposium on Compiler Construction (June 1984), pp. 157-170. GIEGERICH, R. Composition and \nevaluation of at\u00adtribute coupled grammars. Acts hf. 25 (1988), 355\u00ad 423. KAHN, G. Natural semantics. \nIn STACS 87: Fourth Annual Symposium on Theoretical Aspects of Com\u00adputer Sciences (Berlin, Heidelberg, \nNew York, 1987), F. Brandenburg, G, Vidal-Nacquet, and W. Wirsig, Eds., Lecture Notes in Computer Science, \nSpringer-Verlag, pp. 22-39. KENNEDY, K., AND WARREN, S. K. Automatic gen\u00aderation of efficient evaluators \nfor attribute grammars. In Conference Record of the Third ACM Symposium on Principles of Programming \nLanguages (1976), pp. 32\u00ad 49. KNUTH, D. E. Semantics of context free languages. Math Systems Theory 2, \n2 (June 1968), 127 145. Errata Math Systems Theoy 5(1):95-96(1971). SWIESTRA, D., AND VOGT, H. Higher \norder attribute grammars. In Attribute Grammars, Applications and Systems, H. Albaa and B. Melichw, Eds., \nno. 545 in Lecture Notes in Computer Science. Springer-Verlag, Berlin, Heidelberg, New York, 1991, pp. \n256-296. VOC+T, H. H., SWIESTRA, S. D., AND KUIPER, M. F. Higher order attribute grammars. In Proceedings \nof the ACM SIGPLAN 89 Conference on Programming Language Design and Implementation (June 1989), pp. 131-145. \n \n\t\t\t", "proc_id": "174675", "abstract": "<p>Using the <italic>simple tree attributions</italic> described in this paper, attribute values can themselves be trees, enabling attribution to be used for tree transformations. Unlike higher-order attribute grammars, simple tree attributions have the property of <italic>descriptional composition</italic>, which allows a complex transformation to be built up from simpler ones, yet be executed efficiently. In contrast to other formalisms that admit descriptional composition, notably composable attribute grammars, simple tree attributions have the expressive power to handle remote references and recursive syntactic (tree-generating) functions, providing significantly more general forms of attribution and transformation.</p>", "authors": [{"name": "John Boyland", "author_profile_id": "81100598730", "affiliation": "Computer Science Division - EECS, 571 Evans Hall, University of California, Berkeley, California", "person_id": "P143028", "email_address": "", "orcid_id": ""}, {"name": "Susan L. Graham", "author_profile_id": "81452606376", "affiliation": "Computer Science Division - EECS, 571 Evans Hall, University of California, Berkeley, California", "person_id": "PP14173434", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/174675.177971", "year": "1994", "article_id": "177971", "conference": "POPL", "title": "Composing tree attributions", "url": "http://dl.acm.org/citation.cfm?id=177971"}