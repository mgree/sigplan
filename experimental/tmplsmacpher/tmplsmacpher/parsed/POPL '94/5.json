{"article_publication_date": "02-01-1994", "fulltext": "\n From Aa to AV a journey through calculi of explicit substitutions Pierre LESCANNE Centre de Recherche \nen Informatique de Nancy (CNRS) and INRIA -Lorraine Campus Scientijique, BP 23!?, F5J506 Vandowvre-l&#38;9-Nancy, \nFrance email: Pierre. Lesmnne@loria.fr Abstract (Beta) (Ja)b + a[b . d] This paper gives a systematic \ndescription of several calculi of explicit substitutions. These systems are orthogonal and (App) (ab)[s] \n-+ (a[s])(b[s]) have easy proofs of termination of their substitution cal-(Abs) (Aa)[s] + A(a[v(l) .(. \no t)]) culus. The last system, called Av, entails a very simple (Clos) a[s][t] + a[s o t] environment \nmachine for strong normalization of A-terms. (VarId) V(l)[id] + v(i) (VarCons) V(l)[a . s] --+ a (IdL) \nides -i s Introduction (ShiftId) ~oid + T (ShiftCons) T o (a. s) + s The main mechanism of A-calculus \nis @-conversion which is (AssEnv) (Sot)ou + So(tou) usually defined as (kv.a)b --+ a{ b/z}, where {b/z} \nis the substitution of the term b by the variable z. In classical (MapEnv) (a. s)ot -+ W (sot) Xcalculus \n[Bar84] the mechanism of substitution is usually described at a meta-level by a specific and external \nformal\u00adism, unlike A-calculi of explicit substitutions wKlch cent ain in the same framework both the \n&#38;rule and a description of Figure 1: The rewrite system k (Abadl et al.) the evaluation of the substitution. \nXcalculi of explicit sub\u00adstitutions are first order term rewrite systems. Such calculi allow nice and \nuniform descriptions of implementations of plus seven other structurally simple rules and a somewhat \nnaive proof of termination. We also discuss how conflu\u00adA-calculus. Three main A-calculi with explicit \nsubstitutions ent calculi, i.e., alternatives to }Ofi, can be built and wehave already been proposed: \none called the k-calculus by describe the U-machine which is an environment machineAbadi, Cardelli, Curien \nand L&#38;y [ACCL91] is confluent on derived from Jv. Although done quite independently, thk and L6vy \n[HL89, CHL92] and }~ by Rios [Rio93], are con-study is parallel to that of Asperti [Asp92] who adopts \na fluent on open A-terms, i.e., A-terms containing variables. categorical point of view. Connections \nbetween categorical All these calculi use De Bruijn notations. In this paper we machines, categorical \ncombinators and our rewrite systems consider the problem essentially from the point of view of pure A-terms. \nThe others called the AuO-calculus by Hardln should be deepened. first order rewrite systems and as a \nconsequence we system\u00adatically build new orthogonal calculi with explicit substi\u00ad 2 The problem tutions \nwhere orthogonal means linear with no superposi\u00adtion [HL91]. The approach is systematic in the sense \nthat In [ACCL91], Abadl, Cardelli, Curien and L&#38;y propose h we try first to introduce as few forms \nof substitution as pos-a calculus with explicit substitutions which is confluent on sible and second \nto design the rewrite systems by examining pure A-terms, i.e., terms without variables of type J-term. \nthe left-hand sides. Our goal is to reduce every substitution The main idea of Au is a mechanism to denote \nand to evalu\u00adwhich is amenable to a simpler form and eventually to elimi-ate substitutions. Au uses De \nBruijn notations for J-terms. nate them all. These calculi are good candidates for efficient The reader \nis supposed to be familiar with them (see [Cur93] implementations in functional programming languages \nor as for an introduction), For taking substitutions into account abstract machines. As a result of this \nquest we get a system the syntax of De Bruijn ~-terms (or kterme for short) is we call Av which is extremely \nsimple. It has a rule (Beta) slightly modified. A substitution part is added and a calcu\u00adlus with three \nsorts Terms, Substitutions and Naturals Permission to copy without fee ell or part of this material is \nis crested. At erms have the following grammar: granted provided that the copies are not made or distributed \nfor direct commercial advantage, the ACM copyright notice and the Terms a ::= V(n) I ab [ Ja I U[S] title \nof the publication end its date eppeer, and notice ie given Subatitutiona s ::= idl T]a. s[ sot ::= \nthat cop~ ng is by pwmiasion of the Association for Computing Naturals n 1 Machinery. To COPY otherwiee, \nor to republish, requiree e fee andlor epecific permission, POPL 94-1134, Portland Oragon,USA @ 1994 \nAChf 0-89791 &#38;rj-9/94/001 ..$3.50 60 (Beta) (Aa)b + a[b . id] (App) (ab)[s] + U.[s]b[s] (Lambda) \n(~a)[~l ~ ~(a[ll(~)l) (Clos) a[s][t] + a[s o t] (VarShift 1) V(n)[~] + V(S(n)) (VarShift2) V(n)[T 0s] \n-+ V(S(n))[s] (FVarCons) V(l)[a . .9] ~ a (FVarLiftl) V(l)[fi( )1 + v(l) (FVarLift2) v(l)[~.) o t] + \nV(l)[t] (RVarCons) V(S(n))[a . s] + V(n)[s] [RVarLift 1) V(S(n))[fi(s)] + V(n)[s o ~] ~RVarLift2) V(S(n))[~s) \no t] + V(n)[s o (t o ~)] ~AssEnv) (Sot)ou -+ So(tou) ~MapEnv) (a. s)ot -+ cz[t]. (sot) ,ShiftCons) To \n(a..) + s (ShiftLiftl) to~s) --) SOT (ShiftLift2) To(ft(s)ot) -+ So(tot) (Liftl) fi(s)o tit) + ~s o t) \n(Lift2) ll(~)o(fl (t)o u) + ll(sot)ozt (LiftEnv) O(s) o(a. t) ~ a.(sot) (IdL) ides + S (IdR) soid ~ s \n(LiftId) ~id) + id (Id) a[id] ~ a [V(n)k [S(n)ll [1], [ab]l [Aa]l [a[s] ], [a. s], [Tnl [id], [s0 t], \n[0 (s)11 [V(n)], UXn)12 ~1], [ab]z [Ja]z [a[s] 12 [a. S]Z [T12 [id]z [so t], [l? (5)12 = = = . = \n. .   . =  2 [s], [t], [s]1 [nib [n]2 2 [a]z +[b]z+1 2[a]z ([a]z[s]z) + [cz]2 [a]z +[s]2 +1 2 t[s]z[t]z) \n+ [s], 4[s]z I Figure 2: The rewrite system Aufi (Hardin and L&#38;y) a[s] is called a closure and is \nthe result of applying the sub\u00adstit ution s to the term a. Thus every variable is represented by V(n)l \nwhere n is a positive natural number. In their Au\u00adcalculus, Abadl et al. propose two constant substitutions, \nidentity denoted by id and shifl denoted by T. t assigns to the variable V(i) the term V(S(i)), that \nis T: V(1)+ V(2), V(2) M V(3),..., V(i) H V(S(i)),... Notice that since V(i)[~] = V(S(i)) there is no \nneed for natural number notations, in particular S is not necessary. The Ja-calculus also has a cons \noperation that modifies a substitution as follows. If a is a term and s a substitution, then a . s is \nthe substitution as: V(l)Ha v(2) l-+ S(v(l)) V(S(i)) i+ s(V(i)) Substitutions need also to be composed, \nand so the operator o is proposed for this, The rules of ,b are given in Figure 1. The system u, i.e., \nk\\ {Beta}, is confluent (with 10 conver\u00adgent critical pairs) and strongly normalizing. However Ja is \nnot confluent on open A-terms, but only on pure closed A-terms. 1We introduce this V explicitly for at \nleast two reasons. First for proving termination we give an interpretation of this operator: it is therefore \nuseful to write it explicitly. Seecmd, a. we will see later, natural numbers will be used elsewhere in \nthe calculus, Figure 3: interpretations for the termination of rrfi A confluent calculus called Jut \nwas proposed by Hardin and L&#38;y [HL89, CHL92] (Figure 2). A new operation on substitutions called \nLifi and denoted by fi is introduced as n(s) : v(i)++ v(i) v(2) t+ s(v(l))[~] V(S(i)) * s(V(i))[~] fi \n(s) can be seen as an abbreviation of V(i). (s o T). It makes the rule Abs structurally simpler. The \ngrammar of ~ufi is Terms a ::= V(n) Iab I Au I a[s] Substitutions s ::= idl~jfj(s)la. sl sot Naturals \nn ::= S(n) I 1 The sub-system Ufi, i.e., Aafi \\ {Beta} is strongly normaliz\u00ading. Its proof of termination \nis an easy game for ORME [Les92] which uses its implementation of elementary interpretations (see below \nthe discussion on the proof of termination of 4). Here we use a lexicographical composition of two elementary \ninterpretations (Figure 3). Using this, the proof of conflu\u00adence of at can be fully mechanized in the \ncompletion pro\u00adcedure implemented in ORME [Les90]. 59 critical pairs are computed. 3 The kj-calculus \nIn this section we start constructing systematicfly a ca.lcu\u00adlus called # for substitutions. To guide \na systematic con. struction we apply two principles. First, since the goal of 61 (Beta) (App) (Lambda) \n(VarId) (FVarCons) (RVarCons) (FVarLift) (RVarLift) (VarPhiId) (VarPhiPhi) (FVarPhiCons) (RVarPhiCons) \n(FVarPhiLift) (RVarPhiLift) (Phlsl) (Phlss) (~a)b (ab)[s] (Aa)[s] V(n)[zd] V(l)[a . s] V(S(n))[a . \n9] V(i)[fi (s)] V(S(n))[fi (9)] V(n)[@(id, p)] V(n)[@(@(s, q), p)] V(l)[@(a. s,p)] V(S(n))[@(a. s,p)] \nV(i)[qfi (S),p)] V(S(n))[@(fi (s), p)] n+l n+S(m) ab. id -+ -+ -+ + + --) -+ 4 + + -i -+ -i a[s]b[s] \nJ(a[tis)]) V(n) a V(n)[s] v(1) V(n)[@(s, V(n + p) V(n)[@(s, a[@(id, p)] V(n)[@(s,p)] V(s(p)) V(n)[@(s, \n1)] q+p)] S(p))] -+ -+ S(n) S(n + m)  Figure 4: The rewrite system Aq$ r [(/:)}: = [n]l u&#38;y22 = \n[n], [n]l = [n]z + 1 [1], = 2 [1]2 =2 [ab]l = [a]l + [b], [ab]z = [a]z + [b]z + 1 [Ja]l = [a]l + 1 [Aa]z \n= [a]z [a[s] ]1 = [a]l[s]l [a[s] ]2 = [a]z([s]z + 1) [a. 5]1 = [a]l + [s], [a. s], : y], + [s], [id], \n= 2 [id]z [f-r (s)11 = [s]1 [II (5)12 = 4[s]2 [@(s,P)ll = [SI1([PI1 -1) [@(5,P)12 = l1512(b12 + 1) [p+ \nq], = b], + [9]1 -2 up+ q]2 = b]z + 2[q]2 Figure 5: Interpretations for proving the termination of+ \nApp o S2>0 [Lam~da) S1 l>o (VarId) nl>o (FVarCons) al-1\u00ad 2sl>0 (RVarCons) nlal >0 (FVarLift) 2s1 2>0 \n(RVarLift) o n292-t-4s2+l>o (VarPhiId) 2nlpl 3nI pI+2>0 (VarPhiPhi) nl$l(pl 2)(ql 2) ~ o n2s2p2(q2 \n 1) >0 (FVarPhiCons) 2sl(pl -1) >0 (RVarPhiCons) nlal(pl -1)> O (FVarPhiLift) 2slpl 2s1 pl >0 (RVarPhiLift) \no h2 S2P2 + 2nz S2 +h2Pz-+b2+l>o (Plusl) o 3>0 (Pluss) o 1>0 Figure 6: Inequalities occurring in the \nproof of termination of@ 62 a calculus is to build normal forms that do not contain any substitution, \n@ provides a reduction for every term that con\u00ad tains a substitution. This may require introducing new \nop\u00ad erators, but this is the second principle we do this only when necessary, in other words when \nalready introduced op\u00ad erators do not allow us to describe a reduced form. We will see that actually \nboth u and UO contain superfluous opera\u00ad tors, namely o and t. A systematic successful construction should \nprovide an orthogonal rewrite system, i.e., a linear rewrite system without superposition, This is the \ncase for ~. Since a non reduced form is a term that contains a substitu\u00ad tion part, we have to consider \nfor reduction only terms of the form cz[~ and provide a reducing rule for each pattern. At first we have \nfour operators for terms, namely application, abstraction, closure and variable naming, and two opera\u00adtors \nfor substitutions introduced by the Beta rule, namely o and id. We proceed by case. We design left-hand \nsides by pattern refinement and right-hand sides according to the underlying semantics as described in \nSection 2 or that given by the system a. g is an application. This means that the term has the form \n(ab)[s], and naturally we get the rule: (App) (ab)[s] -+ (a[s])(b[s]).  g is an abstraction. Thk means \nthat the term has the form (Ja)[s]. To reduce it one needs to introduce a new operator that transforms \ns and produces a new substitution H (s) to be put under ). After Hardin et al., we denote this operator \nO. We get their rule: (Lambda) (X.Z)[s] -~(a[fj-(s)]).  g is a closure. This means that the term has \nthe form a[s][t]. In this case there is no need for a rule. In\u00addeed we introduce the induction hypothesis \nthat the system reduces any term with a substitution part, so by induction it must reduce a[s].  q is \na variable. This will now constitute the rest of this paragraph.  We consider terms of the form V(n)[sj \nand work by case on patterns for substitutions. Two cases may arise: for a pattern s the effect of ~ \non V(n) can be described by a unique rule with left-hand side V(n) [~ (prefixed by Var in ho terminology) \nor thk description requires two rules with left\u00adhand sides V(i)~ (prefixed by FVar in Jan terminology) \nand V(S(n))[~ (prefixed by RVar in Jofi terminology) . 0 g is just id. one rule is enough, which is simply: \n(VarId) V(n)[id] ~ V(n). o s has the form a . s. Two rules are necessary namely: (FVarCons) V(l)[a. \ns] ~ a (RVarCons) V(S(n))[a . s] ~ V(n)[s]. o g has the form fi (s). Two rules are necessary, the first \nrule is trivially:  (FVarLift) V(l)[fi (s)] ~ V(l). The second rule cannot be expressed directly, as \nits right-hand side would be s o ~ in u. This requires the introduction of a new operator temporarily \ncalled p. Then we get the rule (RVarLift ) V(S(n))[fl (s)] -+ V(n)[p(s)]. Let us further consider patterns \nof the form V(n)[P(s)l and more specifically a pattern of the form V(n)[p(yr(s))] which would represent \nV(n)[(s o ~) o ~]. Since we have no way to describe the reduction of such a pattern, we decide (eureka!) \nto represent s o TP by a unique operator @(s, p) and we forget p. As\u00adperti [Asp92] denote this tp (s) \nand calls it a shift combinator. We get the rule: (RVarLift) V(S(n))[fi (s)] ~ V(n)[@(s, 1)] Now we have \nto reduce patterns containing @. o g has the form @(@(s, p), q). We get the rule: (VarPhiPhi) V(n)[@(@(s,p), \nq)] -V(n)[@(s,p + q)]. This will later requires us to introduce rules for +. o g has the form @(id, p). \nWe get the rule: (VarPhiId) V(n)[@(id,p)] -+ V(n + p). It is interesting to notice that we exploit the \nfact that @ and V use the same naturals, hence the need for a special notation V for variables. o g has \nthe form @(a c s, p). We get the two rules: (FVarPhiCons) V(l)[@(a. s, p)] ~ a[@(id, p)] (RVarPhiCons) \nV(S(n))[@(a . s, p)] ~ V(n)[@(s, p)]. o g has the form @(fi (s), p). We get the two rules: (FVarPhiLift) \nv(l)[@(fi (S), p)] + V(s(p)) (RVarPhiLift) V(S(n))[@(fi (s), p)] + V(n)[@(s, S(p))]. All the patterns \nhave been exhausted, but we now need two rules for + in positive natural numbers: (Plusl) n+l ~ S(n) \n(PIusS) n+S(m) -+ S(n + m). Then we get the orthogonal system of fifteen rules for # given in Figure \n4. A+ is the system @ U {Beta}. The grammar of A+ is: Terms a .. V(n) Iab Ila .. ] a[s] Substitutions \ns ::= idla.s / O(s) l@(s, n) Naturals n ::= S(n) I 1 63 Termination of + and confluence of k#I his calculus \n(Figure 14). Indeed he introduces a new opera- Before speaking about proofs of termination, let say a \nfew words about the interpretation method. It relies on the naive idea that for proving termination of \nrewrite systems it is natural to associate a natural number [t] with each ground term t and to prove \nthat rewriting always decreases thk number. But since the rewrite relation is usually a rela\u00ad tion between \nopen terms (terms with variables) the best we can do is to associate with a term t(zl, . . . , zW) a \nfunction over the naturals [t(z,,..., zn)](x,, xn), xn) that we call an interpretation. Interpretation \nare extended to terms from interpretations given for basic operators: A, @, id, etc. in our case. Proving \nthat a rewrite system (1, -T;) terminates boils down proving that the function [l,] bounds the function \n[~;], i.e., for all its values. If we allow any kind of interpretation, this may be a hard problem, but \nmost of the time one restricts the interpretations to be polynomi\u00ad als or polynomials and exponential \n(elementary functions). The problem remains undecidable, but heuristics, imple\u00ad mented in ORME, cover \na large scope and most of the known examples of proof of termination based on polynomial or el\u00ad ementary \ninterpretations fall in that scope [Les92]. This is the case for an. Note that an extension of the interpreta\u00ad \ntion method has been devised by Hans Zantema [Zan93] to provide a proof of termination of a (a hard problem). \nThe proof of the termination of ~ is simple and can be made using the polynomial interpretations of Figure \n5 sug\u00adgested by Paul Zimmerman. We see that for each term t and for i = 1, 2, [t]; > 2. The array of \nFigure 6 gives for each rule the sign of the difference between the interpretation of the left-hand side \nand that of the right-hand side with the conventions [n]l = 721, [s] I = sl, ~]1 = pi..., [n]z = n2, \n[s], = 5,, etc. The proof of the confluence of Ao on closed terms is ex\u00adactly like that of JO proposed \nby Abadl et al. [ACCL91] ex\u00adcept that in their Proposition 3.1 one should write U(O al . J az ..... am \n.@(id, p)]) instead of a(a[al .a2 .....am. T )]). The ,@calculus With . and the operator @ at hand it \nis possible to g~t rid of O. This can be done in the calculus that we call +. In this calculus we rename \nthe rule Lambda as LambdaPhi and we state it as: (LambdaPhi) (kz)[s] -+ A(a[I . @(s, I)]) Then rules \nApp, Varld, FVarCons, RVarCons, VarPhiId, VarPhiPhi, F VarPhzCons, RVavPhiCons are the same and we also \nget the rewrite system orthogonal (Figure 7). ~ with The only eleven grammar of rules X? is: which is \nTerms a Substitutions s Naturals r-l ::= ::= ::= V(n) I ab \\ k. id Ia. s I+(s, S(n) \\ 1 I a[s] n) Its \n#, proof which of is termination relies given in Figure 8. on a similar interpretation as 4 The A@-calculus \nOur principle of introducing operators by need was not ap\u00adplied to rule (Beta). However Rios [Rio93] \nhas done that in tor he calls / and the rule becomes: (Beta. ) (Ja)b ~ a[b/] and a systematic construction \ncan again be done. As pre\u00adviously the rule Lambda requires the introduction of an operator O eliminated \nby the rules F VarLijt and RVarLift which in turn introduces the operator @. Two rules FVar and RVar \neliminate /. The rule F VarPhiSl with left-hand side V(l) [@(a/, p)] requires introducing an operator \nV (~(p) means t=), which is eliminated by one rule namely: (VarPsi) V(n)[V(p)] 4 V(n + p). We still \nhave the rule FVarPhiLifl, RVarPhiLifi, VarPhiPhi and we need a new rule we call Varphipsi for eliminating \nV inside @. The grammar of Ai is: Terms a ::= V(n) Iab I~a Ia[s] Substitutions s ::= a/ I f! (~) I @(sjn) \nI T(n) Naturals n ::= S(n) I i For proving the termination we take an interpretation very similar to \nthat of Ad (Figure 10). We give the same array as for ~~ with only the new rules (Figure 11). 5 The Av-calcuh.rs \nIn Av, @ was introduced to eliminate ~ in V(S(n))[fi (s)]. Six rules were necessary to eliminate @, \nbut these rules in\u00adtroduced V and + for which respectively one and two rules were necessary. In thk section \nwe propose a very simple calculus that uses a trick in describing the right-hand side of V(S(n))[fi (s)] \n(rule RVarLift ). As before we keep the rules Bet~, (App), (Lambda), (FVar), (RVar) and (RVar-Lift). \nFor the rule (RVarLzjt) we remember p and we rein\u00adtroduce the rule (RVarLift>) V(S(n))[fi (s)] -+ V(n)[p(s)]. \nThk leads to the rule (FVarphiSl) V(i)[p(a/)] ~ a[f] where the newly introduced operator is naturally \nwritten t and called shift. Shift is naturally associated with the rule: (VarShift) V(n)[T] -+ V(S(n)). \nHere now is the trick. Since T would be introduced anyway, let us try to minimize the number of operators \nby replacing (RVarLifl ) by: (RVarLift ) V(S(n))[fi (s)] + V(n)[s][t]. We then get the very simple system \ngiven in Figure 12 that we call Au (read lambda-upsilon). It has only 7 + 1 rules, 3 substitution operators \nand its left-hand sides are elegantly simple. Its proof of termination checked by ORME is given by the \nelementary interpretations of Figure 13. / can take any interpretation and the second interpretations \nare only for orienting (RVarLijt ) and (VarShift] and therefore need to be known on .[.], fi, t, V and \nS. 64 (Beta) (Aa)b -+ a[b . id] (App) (ab)[s] --+ a[s]b[s] (LambdaPhi) (Aa)[s] -+ ~(a[V(l) . @(s, 1)]) \n(VarId) V(n)[id] -+ V(n) (FVarCcms) V(l)[a . s] -+ a (RVarCons) V(S(n))[a . 9] + V(n)[s] (VarPhiId) \nV(n)[@(id, p)] -+ V(n + P) (VarPhiPhi) V(n)[Q(@(s, q), p)] + V(n)[@(s, q + p)] (FVarPhiCons) V(l)[@(a \nos,p)] + a[@(id, p)] (RVarPhiCons) V(S(n))[@(a . s,p)] + V(n)[@(s, p)] (Plllsl) n+l -+ S(n) (Plus.s) \nn+S(m) S(n + m) Figure 7: The rewrite system Ad Figure 8: Interpretations for proving the termination \nof ~ (Beta. ) (Aa)b ~ a[b/] (App) (ab)[s] + a[s]b[s] (Lambda) (Aa)[s] + A(a[tis)]) (FVar) V(l)[a/] *a \n(RVar) V(S(n))[a/] -+ V(n) (FVarLift) V(i)[fi (s)] + v(i) (RVarLift) V(S(n))[fi (s)] + V(n)[@(s, i)] \n (FVarPhiSl) V(i)[@(a/, p)] ~ a[~(p)] (RVarPhiSl) V(S(n))[@(a/, p)] ~ V(S(n + p)) (FVarPhiLift) v(l)[@(fi \n(S), p)] + V(s(p)) (RVarPhiLift) V(S(n))[@(fi (s), p)] ~ V(n)[@(s, S(p))] (VarPhiPhi) V(n)[@(4?(s, q), \np)] ~ V(n)[ % (s, q + p)l (VarPhiPsi) V(n)[41(V(q),p)] ~ V((n + q) + P) (VarPsi) V(n)[iI?(p)] + V(n \n+ p) (Plusl) n+i -+ S(n) (Pluss) n+S(m) -+ S(n + m) Figure 9: The rewrite system A$ 65 I Z[n], pun], \n[V(n)]2 = V(n)]l = [nj, [n], + 1 [S(n)]2 = [n]2 + 1 S(n)]l = [n], 2 :1]1 =2 ab]l = [a], + [b], ~a]l = \n[a]l + 1 [a[s] ]2 = [a]z[s]z a[s] ]1 = [a]~[s]l IIfi ( 3)12 = [s]2 + 1 ,fl (s)], = [s]1 [T], = 2 :l (s, \np)]l = [SI1(IIPII 1) any -p+q]l = bnl + [qnl I 2 :V(p)j, = [Pll a/]1 = [a], +1 Figure 13: Interpretations \nfor the termination of v [V(n)]2 = [rl]2 [S(n)]2 = [n]z + 1 (BetaT) (Aa)b -+ 7m----\u00ad [1]2 =2 = [a], \n+ [b]2 + 1  [ab]z (App) (ab)[s] -+ a[s]b[s] = [a]z [Aa]z (Lambda) (Aa)[s] -+ ,l(a[fi(s)]) [a[s] ]2 = \n[a]z([s]2 + 1) (Clos) a[s] [t] --+ a[s o t] = 4[.]z [t ( )12 (AssEnv) (Sot)ou -+ So(tou) [@(s,p)]2 = \n[S]2(UP]2 + 1) (MapSl) a/es -+ O (s) o a[s]/ 1P+ 0 = k]2 + 2[f7]2 (FVar) V(l)[a/] -+ a = 5P]2 = [a]2 \n(FVarLiftl) v(l)[~s)] + v(1) u~(P)I12 [allz (FVarLift2) V(i)[fi(s) o t] + V(l)[t] (shift) ~oa/ id \n(ShiftLift 1) t o ~s) sot Figure 10: Interpretations for the termination of@ (ShiftLift2) ~ o (~s) o \nt) So (tot) (Lift 1) fls) o tit) ~s o t) (Lift2 ) ~s) o (tit) o u) ~sot)ou (IdL) ides s (IdR) soid s \nFVar al+2>0 (LiftId) 11$] id (RVar) nla~ >0 (Id) a (FVarPhiSl) alpl+2pl 2al 2>0 (RVarPhiSl) nlalpl \nnlal +nlpl 2nl pl +2 >0 (VarPhiPsi) nlglpl nlql nl ql pl+ 4>0 (VarPsi) 7zl P1-7m-Pl+2>o L Figure 14: \nThe rewrite system Jr Figure 11: Inequalities occurring in the proof of termination The grammar of Av \nis: of $ Terms a ::= V(n) \\ ab I ~sz ] a[s] Substitutions s ::= all fr(s)l t Naturals n ::= S(n) I 1 \nSection 7 gives a machine for strong reduction of A-calculus (Aa)b ~ a[b/] derived from Jv. (Beta.) \n (App) (ab)[s] ~ u[s]b[s] 6 A systematic construction of confluent calculi (Lambda) (Aa)[s] ~ ~(a[~.s)]) \nV(l)[a/] ~ a [m] As sketched in [ACCL91] it is also possible to use systematic V[S(n))[a/] ~ V(n) methods \nfor computing confluent calculi. The main idea is (FVarLift) V(i)[fi (s)] + v(1) to introduce the rule \n(Beta) and to complete the system in (RVarLift ) V(S(n))[fT (s)] -+ V(n)[s][~] order to make it at most \nlocally confluent. Without interac\u00ad tion with the user, the completion process usually diverges, (VarShift) \nV(n)[t] A V(S(n)) but based on the intended semantics, there are ways to avoid such a divergence (see \n[Her88]), Let us give some principles used in the case of Acalculus. Figure 12: The rewrite system ~v \n Generalize any rule of the form a[s] ~ a[t] or fi (s) -+ O(t) to arule s~ t,indeed if a substitution \nhas the 66 (Beta) (Aa)b -+ a[b. id] (App) (ab)[s] + a[s]b[s] (Lambda) (Aa)[s] --+ A(a[~s)]) (Clos) a[.s] \n[t]+ a[s o t] (AssEnv) (Sot)ou + So(tou) (MapEnv) (a. s)ot ~ a[t] . (s o t) (FVarCons) V(l)[a . s] +ir \n(ShiftCons) ~o(a. s) +s (FVarLift) --+ v(1) V(l)[fi (s)1 (FVarLift ) V(l)[fi ($) o t] + V(l)[t] (ShiftLift \n1) To fi(s) + sot (ShiftLift2) t o (fi(s) o t) + so(~ot) (VarPhiId) V(n)[@(id, p)] -+ V(n + p) (VarPhiId \n) V(n)[@(id, p) o t] -+ V(n + p)[t] (PhiPhi) @(@(s, q), p) + @(s, q + p) (FVarPhiCons) V(l)[@(a. s,p)] \n~ a[@(id, p)] (FVarPhiCons ) V(l)[@(a. s,p) o t] ~ a[@(id, p) o t] (VarPhiCons) ~o~(a. s,p) + @($, p) \n(VarPhiCons ) To(@(a. s,p)ot) + @(s, p) o t (FVarPhiLift) v(l)[@(~s), p)] -+ V(s(p)) (FVarPhiLift ) v(l)[lq~s), \np) o t] + V(s(p))[t] (VarPhiLift) t o @(~.s), p) -+ *(S, s(p)) (VarPhiLift ) T o (i$(~s),p) o t) + @(s, \ns(p)) o t (ShiftPhi) ~ o @(id, p) + @(id, S(p)) (ShiftPhi ) ~ o (@(id, p) o t) -+ @(id, S(p)) o t (Liftl) \nfls)o fit) + ~sot) (Lift2) ff (s) o (tit) o u) + ~$ot)ozs (LiftEnv) ~s) o (a. t) + a. (sot) (IdL) ides \n+s (IdR) soid +s &#38;tId) Mid) + id a[id] -a (Plusl) n+l -S(n) (Pluss) n+S(m) -+ S(n + m) (PIusA) n+(m \n+ p) ~ (n+ m)+p Figure 15: The rewrite system ~~fi same effect on any terms we can declare that they \nare equal and that O is one-to-one. Actually due to rules (App) and (Lambda) we may also generalize rules \nof the form V(n)[s] --t V(n)[t] to s -+ t. Similarly, rules of the form Aa ~ Jb are generalized to a \n+ b. Divergences are often generated by terms of the form a[s][t] = b[~ ][t ] when s o tor s ot or both \ncan be reduced by rules (AssEnv) and other rules that include o. Therefore in an attempt to get a confluent \nsystem by completion introduce o and rules (Clos) and (A ssEnv). c Replace variables V(S(n)) by V(n)[T]. \n If we apply this method to Av we get Ar of Rios (Fig\u00adure 14) and if we apply this method to Ao, we get \nthe system ~q$fi (Figure 15). -\u00ad 7 The U-machine This journey will be a success if it ends with the con\u00ad \nst ruction of an abstract machine for normalizing ~-terms. Actually in A-calculus there are two kinds \nof normalizations: weak and strong. Weak normal forms are terms with no ,f3\u00adredex at the root. Weak normalization \nis a process to get weak normal forms, it is typically the reduction in functional programming languages \nlike ML or HASKELL. In addition to the above mentioned ,&#38;redexes strong normalization al\u00adlows also \nreduction of @redexes occurring under A, i.e., in the subterm a of a term of the form Au or of ,B-redexes \noc\u00adcurring in the parameter part of a variable function, i.e., in a subterm a, of a term V(n)al . . . \naP. In a strong normal form there is no @redex at all. Strong normalization is an interesting tool for \nmanipulating functional programs in par\u00adticular for simplifying them. It is also used in higher order \ntheorem proving. Strong normalization is usually harder to describe. In our case, it requires recursively \ncreating new in\u00adstances of the machine. These machines are called to reduce a specific term, say t,in \na specific environment, say e. Such calls are writ ten nf (a, e) in the sequel. The called machines produce \nresults used by the calling machine. To perform a somewhat faithful strong normalization, it is essential \nto design a machine that does a reduction only when necessary. For designing our machine that we call \nthe U-machine, we proceeded from the following natural idea. If Jv is sim\u00adple then it should entail a \nconceptually simple machine for (weak and strong reduction) normalization of A-calculus. We did not start \nform scratch since the U-machine has simi\u00adlarities with a former machine due to Krivine and described \nby P.L. Curien in his book [Cur93] (see also [Cr490]). The U-machine is easy to explain since it sticks \nclosely to Au and relies on normalization in this calculus. Since its basic transitions are strongly \nrelated to the rules of Av, we keep the same name for them.z The U-machine is an environment machine. \nIt has states made of three components: a term, an environment and a stack. Each non-final state is matched \nby one instruction or transition (the machine is deterministic) and the state is modified according to \nthe right-hand side of the correspond\u00ading transition. Environments in the U-machine are lists of actions \nto perform on variables. These actions are pairs of the form (c, i), where the index i is the number \nof Lift s to do before performing more elementary actions, and c is ei\u00adther a shift ~ or a closure that \nis a pair (a, e) of a term and an environment. Closure (a, e) corresponds more or less to the substitution \na[s,]/ where s, is associated with the envi\u00adronment e (see the function < below). The action ((a, e), \nO) on the top of the current environment should be understood either as Evaluate the term tin the environment \ne and return it as value if the term in the state is the variable V(l) or as Skip this action and decrease \nthe number of this variable if the term in the state is a variable which is not V(l). This corresponds \nto rules (FVar) and (RVar) in Au. In transition (APP) applied to term ab the evaluation of the term b \nin the current environment is delayed. A clo\u00adsure is created and put on a stack for further evaluation \nif necessary. A state of the U-machine has three components and therefore its structure is: state = term \nx env x stack env = ((~ U closure) x IN) list closure = term x env stack = closure list 2 except for \nthe transit ion (LEA -BE T) which is a combination of (Lambda) and (Beta.). 67 (ah, e,p) -~ (a, e,(b, \ne) ::p) (APP) (k., e, (b, e ) :: p) -~ (a, Lift.env(e) @ [(b, e ), o],p) (LBA -BET) (V(l), (c, i + 1) \n:: e,p) ~ (V(l), e,p) (FVARLIFT) (V(S(n)), (c, i + 1) :: e,p) -... (V(n), (c, z) :: (T, O) :: e,pj (RVARLIFT \n) (V(l), ((a, e), O)::e , p) ~ (a)e @e , p) (FVAR) (V(S(n)), ((a, e), O)::e , p) ~ (V(n), e , p) (RVAR) \n(V(n), (T, O)::e,p) -; (V(S(n)), e,p) (VARSHIFT) Figure 16: The U-machine reference confluent orth. subst. \nOPS. size id. to 10 x 23 thas paper x 15 thu paper x 11 thas papev x 15 thts papeT x 7 ? F [Rio93] \n17 thts paper 34 ? Figure 17: Summary of calculi of explicit substitutions term s are De Bruijn s pure \nlambda-terms, i.e., they have no from nf(a, [ ]). The interpretation f of a state is substitution part \nand use De Bruijn s notations. Elements of stack are denoted byp (for the French word pile ). An f(a, \ne,[(bl, ei),..., (bq, eq)]) = a[e]h[ e,]... bq[eq] operation Lift-env transforms environments by adding \n1 to every index. It is used in the transition (LBA-.BET) where where a[e] = a[sl; . . . ;sgl means a[sl] \n. . . [s~], a[(b, e), i] means one needs to lift a whole environment. It is defined by a[fi (~[e]/)] \nand a[~, i] means a[ff (~)]. The same holds for the b, s, therefore each state describes a A-term with \nsub\u00ad Lift-env([]) ~ [] stitution of the Au-calculus. A proof of correctness of the Lift_env((c, i) :: \ne) -+ (c, i+l)::Lift_env(e) U-machine is based on Av and comes from the facts that The operator _@ . \nappends one environment to another. ~(a, e,[(bl, el),..., (bg, e~)]) It is used in transitions (LBA-BET) \nand (FVAR). In a * good implementation, both Lift-env and _@. are called by need, that is they are evaluated \non just the part of the en\u00ad ((a , e , [(bj,e~~, . . . . (b~,e~)l) vironment that is necessary for enabling \na further transi\u00adtion. The U-machine has seven transitions (see Figure 16). iff This way, it performs \nweak normalization. In particular, (a, e,[(b~, e~),..., (bg, eg)]) if (a, [ ],[ ])~(b, [ ],[ ]) and no \nmore transition can apply, * then b is the weak normal form of a. Two kinds of state are not reducible \nby any transition, namely states of the form (a , e , [(b~, ej~,..., (b~, e~)]) (AI-z, e[ ]) and states \nof the form (V(n), [ ],p) Strong nor\u00ad and malization reduces those states. For that we also introduce \ntwo inference rules that correspond to recursive calls to the nf(a, [ ]) .$ b iff a~b iff a~b machine. \nXv s (a,e,[ ]) -.!.+ (Ab,ef,[ ]) 8 Conclusion (L)nf(~,~l _ A nf(b, Llft-env(eJ)J Although systematic, \nthis paper rests on some intuitions. -f Basically we can say that the creation of the adequate op\u00ad (a,e,[ \n]) ~ (V(n),[ ],[(bi,el); ....(bq.eq)]) erators, the design of left-hand sides and their reduction is \n(v) nf(a,. ) -v(m) nf(bl,el)... nf(bq,eg) systematic whereas the design of the right-hand sides (rule \nnt (RVa~Lift ) for instance), the proof of termination and the generalization of operators (from ~ to \n@ for instance) The strong normal form of a term a is the value computed by require invention. This paper \ncent ains many tables, but we nf(a, [ ]), i.e., the term we get when all the nf s are eliminated 68 feel \nthat a final one (Figure 17) would be useful to summa\u00ad rize the results obtained. It gives for each system \nits name, a reference to a paper where it is presented, its confluence on open terms (x means proved, \n? means conjectured), its orthogonality, the operators it uses to describe substitutions and its size, \ni.e., the number of its rules not including (Beta). Currently we are examining the design of concrete \nma\u00adchines for efficient evaluation of A-calculus, derived from the U-machine, and we are comparing our \napproach with cat e\u00adgorical machines. Acknowledgment: 1 would like to thank people who helped me during \nthis research: Paul Zimmerman, Jocelyne Rou\u00adyer, Alejandro R.ios, Roberto Amadio, Wayne Snyder, Pierre-Louis \nCurien, Miki Hermann, Jean-Luc R6my, Christian Guyot, the research group EURECA in Nancy and the GDR \nProgrammation. References ~ACCL911 M. Abadi, L. Cardelli, P.-L. Curien, and J.-J. L6vy. Explicit substitutions. \nJ. of Functional Programming, 1(4):375-416, 1991. [Asp92] A. Asperti. A categorical understanding of \nen\u00advironment machines. J. of Functional Program\u00adming, 2(1):23-59, January 1992. [Bar84] H. P. Barendregt. \nThe Lambda-Calculus, its syntax and semantics. Studies in Logic and the Foundation of Mathematics. Elsevier \nScience Publishers B. V. (North-Holland), Amsterdam, 1984. Second edition. [CHL92] P.-L. Curien, Th. \nHardin, and J.-J. L6vy. Conflu\u00adence properties of weak and strong calculi of ex\u00adplicit substitutions. \nRR 1617, INRIA, Rocquen\u00adcourt, February 1992. [Cr690] P. Cr&#38;gut. An abstract machine for the normal\u00adization \nof X-calculus. In Proc. Conj. on Lisp and Functional Programming, 1990. [Cur93] P.-L. Curien. Categorical \nCombinators, Sequen\u00adtial Algorithms and Functional Programming. Birkhauser, 1993. 2nd edition. [Har92] \nT. Hardin. Eta-conversion for the languages of explicit substitutions. In H. Kirchner and G. Levi, editors, \nProc. 3rd Int. Conf. on Alge\u00adbraic and Logic Programming, Volterra (Italy), volume 632 of Lecture Notes \nin Computer Sci\u00adence, pages 306 321. Springer-Verlag, September 1992. [Her88] M. Hermann. Vademecum \nof divergent term rewriting systems. Research report 88-R-082, Centre de Recherche en Informatique de \nNancy, 1988. [HL89] Th. Hardin and J.-J. L&#38;y. A confluent calcu\u00adlus of substitutions. In France-Japan \nArtificial Intelligence and Computer Science Symposium, Im, 1989. [HL91] G. Huet and J.-J. L&#38;y. Computations \nin orthog\u00adonal rewriting systems, I. In J.-L. Lassez and G. Plotkin, editors, Computational Logic, chap\u00adter \n11. The MIT Press, 1991. [Les90] P. Lescanne. Implementation of completion by transition rules + control: \nORME. In H. Kirch\u00adner and W. Wechler, editors, Proc. 2nd lnt. Conf. on Algebraic and Logic Programming, \nNancy (France), volume 463 of Lecture Notes in Com\u00adputer Science, pages 262 269. Springer-Verlag, 1990. \n[Les92] P. Lescanne. Termination of rewrite systems by elementary interpretations. In H. Kirchner and \nG. Levi, editors, Proc. $rd Int. Cont. on Alge\u00adbraic and Logic Programming, Volterra (Italy), volume \n632 of Lecture Notes in Computer Sci\u00adence, pages 21 36. Springer-Verlag, September 1992. [Rio93] A. Rios. \nContributions b 1 Ltude des A-calculs avec des substitutions explicates. Th&#38;se de Doc\u00adtorat d Universit&#38;, \nU. Paris VII, 1993. [Rit92] E. Ritter. Categorical Abstract Machines for Higher-Order Typed Lambda Calculi. \nPhD thesis, Cambridge U., IXnity College, September 1992. [Zan93] H. Zantema. Termination of term rewriting \nby in\u00adterpretation. In M. Rusinowitch and J.L. R&#38;my, editors, Conditional Term Rewriting Systems, \nproceedings third international workshop CTRS\u00ad92, volume 656 of Lecture Notes in Computer Sci\u00adence, pages \n155 167. Springer, 1993. Full version appeared as report RUU-CS-92-14, Utrecht Uni\u00ad versity. 69 \n\t\t\t", "proc_id": "174675", "abstract": "<p>This paper gives a systematic description of several calculi of explicit substitutions. These systems are orthogonal and have easy proofs of termination of their substitution calculus. The last system, called &#955;v, entails a very simple environment machine for strong normalization of &#955;-terms.</p>", "authors": [{"name": "Pierre Lescanne", "author_profile_id": "81100225321", "affiliation": "Centre de Recherche en Informatique de Nancy (CNRS), and INRIA -Lorraine, Campus Scientifique, BP 239, F54506 Vandoeuvre-l&#232;s-Nancy, France", "person_id": "PP39074960", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/174675.174707", "year": "1994", "article_id": "174707", "conference": "POPL", "title": "From &#955;&#963; to &#955;&#957;: a journey through calculi of explicit substitutions", "url": "http://dl.acm.org/citation.cfm?id=174707"}