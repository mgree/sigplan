{"article_publication_date": "02-01-1994", "fulltext": "\n Combinatory Representation of Mobile Processes Kohei Honda * Nobuko Yoshida kohei@mt. cs.keio. ac.jp \nyoshida@mt.cs.keio .ac.jp Department of Computer Science, Keio University 3-14-1, Hiyoshi, Kohoku-ku, \nYokohama 223, Japan Abstract A theory of combinators in the setting of concurrent pro\u00adcesses is formulated. \nThe new combinators are derived from an analysis of the operation called asynchronous name passing, just \nas an analysis of logical substitu\u00ad tion gave rise to the sequential combinators. A sys\u00adtem with seven \natoms and fixed interaction rules, but with no notion of prefixing, is introduced, and is shown to be \ncapable of representing input and output prefixes over arbkrary terms in a behaviorally correct way, \njust as SK-combinators are closed under functional abstrac\u00ad tion without having it as a proper syntactic \nconstruct. The basic equational correspondence between concur\u00ad rent combinators and a system of asynchronous \nmobile processes, as well as the embedding of the finite part of n-calculus in concurrent combinators, \nis proved. These results will hopefully serve as a cornerstone for further investigation of the theoretical \nas well as pragmatic pos\u00ad sibilities of the presented construction. Introduction The notion of combinators \n[23, 5, 9] which was inde\u00adpendently discovered by Schonfinkel and Curry and has been studied extensively \nby the latter and his school as well as by other researchers for decades, provides a means of rigorous \nanalysis of the procedure of logical substitution, and, as such, has turned out to be signif\u00adicant in \ntheories and practices of computing. This is because many notions of programming and computa\u00adtion involve \nthe treatment of substitution in essential ways. A typical example can be found in the paradgrn of computing \nbased on the idea of functions. While \u00b7 Partially supported by JSPS Fellowships for Japane= Junior Scientists. \n Permission to copy without fee 811or part of this meterial is granted provided that the copies era not \nmade or distributed for direct commercial advantage, the ACM copyright notice and the titia of the publication \nand ita date appeer, and notice ia given that copying ia by permission of the Association for Computing \nMachinerv. To copy otherwise, or to republieh, requires a fae endor specific permission. POPL 94-li94, \nPorUand Oragon,USA @ 1994 ACM O-89791433~B4~l ..$3.50 the A-notation provides a neat way of writing down \nhigher-order functions, and consequently becomes a ba\u00adsis of programming language methodologies, combina\u00adtors \ngive another way of representing the same thing in terms of finite atoms and their combination, enjoying \nnotable conceptual/mechanical simplicity; an elemen\u00adtary, yet culminating, fact tells us that the only \ntwo atoms, named S and K , suffice for representing arbitrarily complex applicative behaviour. This ulti\u00admately \nled us to the notion of combinatory algebra as a semantic foundation of typed and untyped A-calculi. \nAt the same time, the decomposition of the application\u00ad substitution process into finite dynamics in \ncombinators has had a profound impact on the execution schemes of modern functional programming languages. \nTruly, par\u00ad allel developments in the study of A-calculi and that of combinators are essential to our \ncurrent practice of se\u00ad quential programming, both theoretical and pragmatic. Such parallel developments, \nhowever, have not been known in the world of concurrent processes. Nor, at least until recently, has \none agreed upon the existence of such an essential operation as /3-reduction in the concur\u00adrency setting. \nYet nowsdays we find, especizdly among researchers on concurrency, growing interest in one sim\u00adple yet \npowerful primitive, which, when coupled with basic operators like concurrent composition and name hiding, \ncan represent quite versatile structures of con\u00adcurrent computation. The operation is name passing, where \na process passes the names of communication channels to another process in its message, and the enunciation \nof its power was done, for example, in a recent work by Robin Milner, where he showed that @-reduction \nof certain J-calculi can be concisely rep\u00adresented as combination of synchronous monadic name passing \n[20]. He called the calculus he used r-calculus, originally developed with Joachim Parrow and David Walker \n[19], which is essentially a non-trivial simplifi\u00adcation of ECCS [6]. Based upon the preceding work, \nhowever, a further simplification was done by one of the present authors [10] and, independently, by \nGer\u00adald Boudol [4], without sacrificing any expressive power. Now the following simple idea of reduction \nemerges. UZ.P, tab _ P{b/x} . In the above, az.P denotes a process which receives a name through a \nport a and then launches P after appr~ priate substitution, + ab is a message carrying a name b to a, \nand , denotes concurrent composition. Thus, in the simplified system, which is now called v-calculus \n[11, 13], the output prefix has been taken away. What is significant is that this asynchronous construct \ncan en\u00adcode synchronous communication quite concisely [10, 4], and thus is capable of doing all that \ncan be done by synchronous name passing, representing versatile inter\u00adaction structures in a clean framework. \nPerhaps more essential to the present context, however, is the observa\u00adtion that this operation seems \nso simple and tractable, that it would allow us to perform an analysis similar to what has been done \nfor f?-reduction, the analysis which, in exchange for a finite number of atoms, should make it unnecessary \nto have an explicit syntactic construct for any prefixing (so the input prefix would also be taken away), \njust as S and K make it unnecessary to have ~-abstraction in the functional setting. We shall show in \nsubsequent sections that such an analysis can indeed be performed; that the traditional technology for \ndecomposing logical substitution is use\u00adful even in the concurrency setting; and the analysis actually \nresults in seven atoms which embody the basic units of behaviour of processes, reminiscent of such el\u00adementary \ncombinators as S, K and I in some aspects. Atoms, however, arise somewhat differently in this set\u00adting, \nsince the composition of atoms is done not only at the level of terms but also by connection of chan\u00adnels \n(or by sharing of names). Thus atomic agents are formed from atoms by connecting ports to real lo\u00adcations \n. For example, if M is an atom for a message, and if we connect its target port to a and its value port \nto b, we get M (ah), a message carrying a value b to a. Interaction rules are specified between atoms, \nin a way reminiscent of Lafont s Interaction Net [18], from which the reduction relation is formed. Coracur\u00adrent \ncomposition and name hiding are identified as the essential glues to combine atomic agents, partly for \nsimplicity and partly for their genuine expressive power (cf. [20, 10]). We shall show, in this framework, \nthat this system of combinators is capable of representing input and output prefixes over arbitrary terms \nin a be\u00adhaviorally correct way (ss indicated in Section 6, we can even represent replication with a handful \nof addi\u00adtional atoms, but we shall not go that far in the present exposition). Finally, we establish \nthe essential equiva\u00adlence between the finite part of v-calculus and concur\u00adrent combinators in the equational \nsetting, as well as the embedding of the finite r-calculus in the latter. We hope that these basic results \nwill provide a cornerstone for further theoretical as well as pragmatic investigation of the presented \nformal framework, giving a positive im\u00adpact on the principles of concurrent programming such as formally \nfounded execution schemes, semantic anal\u00adysis/verification, and optimization technologies. Outline of \nthis pape~ Section 2 introduces the asyn\u00adchronous v-calculus (without replication) and its equa\u00adtional \ntheory. Section 3 introduces the system of concur\u00adrent combinators with seven atoms. Behavioral equiv\u00adalences, \nnaturally equipped with the notion of dyadic interaction, are formulated and studied. Section presents \nthe representation of input prefiing in con\u00adcurrent combinators and verifies its correctness. Sec\u00adtion \n5 is devoted to the correspondence results between combinators and (finite) name passing calculi, namely \nthe u-calculus and monadic x-calculus. Section 6 gives comparisons with related work, and points out \nfurther topics. Many proofs are given only in outline. Details are found in [15]. 2 The Asynchronous \nv-calculus 2.1 Terms and Reduction v-calculus, an offspring of r-calculus [19, 20], is a small formalism \nof concurrency using the notion of asyn\u00adchronous name passing as the interaction primitive [10, 11]. \nThe simple primitive, coupled with the capa\u00adbility to generate new names, gives v-calculus enough power \nto construct versatile structures of interaction, just as the simple operation called application in \nX calculus gives it enough power to construct any imag\u00adinable applicative behaviour. Below we introduce \nbasic constructions of the calculus without replication, since this is all we need for our present purpose. \nDefinition 2.1 (u-terms) Let N be a countable set of names and V be a countable set of (name) variables,l \nranged over by a, b, c,.. and by z, y, Z, ... respectively. U, V, W7.. range over their union, the set \nof identifiers. We suppose that N and V are mutually disjoint. Then the set of v-terms Pv, ranged over \nby P, Q, .... is given by the follow ng grammar. Among terms, t UV denotes a message to a target u carrying \na value v, while ux.P denotes a receptor which receives a message and instantiates the value in its body. \nIn UX.P, the variable z binds free occurrences of z 1Variables for names are dissuaded by e.g. [19], \nbut are found, especially in thepresent context, to be essential to distinguish two kinds of binding \nconstructs. The technical results, however, can be carried over to systems without variables, ss can \nbe easily seen. 349 in P (like z in Az. J4). We may call the abstraction over x in UX. P, u-pointed name \nabstraction. Here %x is a prefix or an input guard. a >P is a scope restriction of a in P, showing that \na in P is local to P. Here the initial a binds its free occurrences in P. P, Q is a concurrent composition \nof P and Q. A (to be read nil ) is a syntactic convention used to denote nothing. The set of free (resp. \nbound) names in P is denoted by 7N(P) (resp. BN(P)). The set of free (resp. bound) variables in P is \ndenoted by ~(P) (resp. Z3V(P)). We also assume the usual notion of (multiple) substitutions, written \n{ ti/ii} where ii and G are strings of identifiers (names or variables) with the same length and all \niden\u00adtifiers in ii are distinct. In the present exposition, a substitution should always map a variable \nto a name, a variable to a variable, or a name to a name, but not a name to a variable. u, &#38; etc., \nrange over the set of substitutions. -w denotes a-convertibility in terms of both names and variables. \nClosed and open terms are defined as usual (with respect to name variables). Thus + ab and ax. + xb are \nclosed but + yc and ax. + cz are open. Then, for an open term P, CTfrom variables to names is a closing \nsubstitution if FV(Pa) = 0. Some conventions: ab -P denotes a >(b PP); , is the weakest in association, \ne.g. a ~P, Q ~f (a PP), Q, and associates to the left. In spite of these conventions, parentheses will \nbe used freely to make syntactic struc\u00adtures explicit. Henceforth, terms are often considered modulo \nthe following structural congruence, following Milner [20] (cf. [3]). Definition 2.2 = is the smallest \ncongruence relation over v-terms generated by the following rules. (i) P=Qif P=. Q (ii) P, QsQ, P (P, \nQ), RsP, (Q, R) P,As P  (iii) aa~P = awP ab~P z ba~P atiA z A a~P, Q -a>(P, Q) ifa @fM(Q) The reduction \nrelation provides the basic notion of com\u00adputing in the formalism. The underlying idea is a primi\u00adtive \nnotion of interaction where a piece of information is simply consumed by a computing entity which, in \nturn, generates a new term after substitution. Definition 2.3 (reduction relation) One step redtic\u00adtion \nrelation over v-terms, -, is the smallest relation generated by: (COM) UZ.P, -UV -P{v/z}. (PAR) P-Q * \nP,R -Q,R. (RES) P-Q +-a~P -a>Q. (STR) PEP P --+ QZQZQ *P-Q. Then multi-step reduction relation, -H, is \ndefined bg: _ d~f _* u =.  2.2 Agents and their Reduction Some important agents are listed below. Note, \nby (3), we gain the power of the output prefix, together with that of multiple name passing. Note also, \nin the same example, how private names are used to make the in\u00adtermediate interactions safe. (1) (Forwarder) \nThe left-hand side agent forwards a message.2 ax. -bx, tae -+&#38; (2) (Switcher) The left-hand side \nagent sends back a value it holds to the name it receives. ax. + xb, i-se _ i--eb (3) (Synchronous, \nmultiple name passing) Assume that z, c, and y are all fresh.  a : (zl..zn).P dgf ay. c>(+yc, czl. \ncb(+yc, ..cp(+-yc, czn. P)..)) a : [vl..vn].P &#38;f c>(-ac, cz. (-zvl, cz.(.., cz,(+zv~, P)..))) Then \nwe have: a : (zIzZ).P, ~ : [v1v2].Q --H P{v1v2/z1z2}, Q  2.3 Equality over Agents .. Equality over v-terms \nhas been studied extensively in [11, 13]. Here we employ a construction which is natu\u00adrally applicable \nto both v-calculus and concurrent com\u00adbinators in general, inducing behaviorally significant equality \nover agents in each case with little technical overhead. The formulation is based on reduction-closure \nfor equality [13] as well as action predicate which is a refinement of convergence predicate in the line \nof e.g. [1, 4, 22] in the scheme of dyadic interaction. Below we naturally assume that any congruence \n(say $%) satisfies the usual proviso for open terms, i.e. if P = Q with P or Q open, then P{v/x} ~ Q{v/x} \nfor any v and x. We first stipulate what we regard as one of the essen\u00adtial criteria for meaningful equality \nover processes, just as the inclusion of @-convertibility is essential for any A-theories. We say that \na congruence 2 over v-terms is reduction-closed M, whenever P = Q, P + P im\u00adplies, for some Q , Q -+ \nQ and P Z Q . In essence, we require that the notion of equality should be consistent with state changes \ninduced by reduction. Since the ~-equality, i.e. P _ P + P = P , sat\u00adisfies the closure property vacuously, \nwe would say that the property generalises the @-equality into the stateful regime (the usage of _ instead \nof + is essential in z rhe ~~~~ f~War&#38;r comes from a similar agent in the Context of Hewitt s actors \n[8]. 350 this aspect; think of 11 =6 1 with 1 ~f kc.z). Note also that the congruent closure of the \nunion of a family of reduction closed congruences is again reduction-closed. As argued in [13], the notion \nby itself may not induce a behaviorally significant congruence. Thus we intro\u00adduce another element into \nour equational construction, and form the notion of soundness in equality combining the two. Let a E \nW+(P) iff P s ZF(tav, R) with a @ {Z} and a E N.(P) iff P s Z F(az.Q, R) with a @ {?} where {E} is the \nset of names in L Then, with 0 ranging over + and , let us define a family of (un\u00adtyped) action predicates \nover closed v-terms, as follows. P$., $$ 3P . P ~ P A a EM@(P ) The soundness criterion follows. Definition \n2.4 We say a congruence % is JJae-sound, or simply sound, if it includes =, is reduction closed, and, \nrno~eove~, ~ respects #ae, i.e. if P ~ Q and P $.. then Q $.,. The first condition tells us that we are \nessentially work\u00ading with the terms modulo =. According to this and the last condition, a sound congruence \nis automatically non\u00adtrivial (i.e. neither universal nor empty). Moreover we can easily verify that the \ncongruent closure of a family of sound congruences is again sound. Then, by taking the congruent closure \nof the whole family of sound con\u00adgruences, we immediately know: Proposition 2.5 There is a maximum sound \ncongru\u00adence m thin the family of all sound congruences. We call this maximum sound equality = . We will \nbe using =V as the representative notion of equality over v-terms.3  3 Concurrent Combinators (l): \nBasic Construction 3.1 Combinators in a Concurrency Set\u00adting Concurrent combinators are based on the \nnotion of dyadic interaction. The basic idea is that two atoms interact via a common interaction port \nto generate new nodes and a new connection topology. To represent mul\u00adtiple interaction points and their \nconnection topology in a general way, the notion of names is introduced from process calculi. As mentioned \nin the Introduction, thk means that we have to, at least syntactically, param\u00adetrize atoms with names \nto denote how the internal 3We note that, using the equfllty notions as presented in [13, 22], the main \nresults in this paper still hold. ports are connected to real locations. But behaviour is constant, and \nthe present way of representation seems inevitable, as long as we rely on syntactic formulation (cf. \n6.1). Thus M(ab) would mean a message with its target port connected to a and a value port to b, while \nFW(ab) would be a forwarder with an input port con\u00adnected to a and an output port to b. Then we may have \nan interaction of the form 7W(ab), M(ae) + M(be) . This is actually a rule schemata (as KMN -M), saying \nthat any forwarder and any message with the common initizd port would interact in this way. Here , denotes \nconcurrent composition, and we shall also allow E , the scope restriction, as another basic connective, \nbut that is all. We begin with seven basic atoms. They arise in the course of analysing away the input \nprefix, as will become clear later. Definition 3.1 (atoms) We assume a set of atoms, A = {M, D, 3W, K, \nt31, L%, S}, ranged over by C, c ,. ... with two associating functions aT : A * N+ and pol : A -{+, }, \nwhose values are: (i) a~(M) = a~(7W) = ar(B1) = ar(l?r) = 2, ar(D) = a7-(S) = 3, ar(K) = 1.  (ii) pol(M) \n= +, for others pol(C) = -.  aT (C) and pol(C) aTe called the arity and the polarity of C, respectively. \n6,0 ,.. Tange over {+, }. The functionalities of polarity and arity will be ex\u00adplained later. Now we \nform terms. We use the sets N and V in the previous section, and the same symbols denote their elements. \nDefinition 3.2 (cc-terms) The set of of terms, P.=, is dej%ed by the following gTammar. P, Q, R,.. again \nTange over the set. P ::= C(ilt )) I P,Q I a>P [ A wheTe C G A, aT(C) = n, and ii(n) is a sequence of \nidentified of length n. We assume , to be weaker in association than F, as in v-terms. Terms are sometimes \ncalled agents. An agent of the form C(il) is called an atomic agent. The polarity of an atomic agent \nis the same as its associated atom. We sometimes write Ce(ti), C(n) (ti), or Co(n) (ti), to inform the \narity and/or the polarity of atom. The name or the variable in the leftmost position a>> in M (ah), is \ncalled its in an atomic agent, e.g. subject. Other names/variables are called objects. The subject is \nthe location at which atomic agents with op\u00adposite polarities interact, thus CT (u6) and C; (uti) may \ninteract. The only binding is by the operator D(tww ), M(uIJ) -M(w), &#38;t(w v) Bl(uw), M(w) -W(m)) \nFW(UW), M(m) -&#38;f(wv) ~r(uw), M(w) -~(WV) K(u), M(m)) -A ~(uww ), M(m) -~(WW ) Figure 1: Reduction \nRules for Atomic Agents >. a-convertibility, ~a, is defined in the standard way. P.M(P), BAf(P), 7V(.P) \nare defined in the same way as in v-terms (we have no bound variables). Open terms are those with free \nvariables, while closed terms are those without free variables. The notion of closing substitutions is \ndefined as in u-terms. Finally, M+(P) (resp. W-(P)) is the set of free names occurring at the subject \nposition of atomic agents whose polarity is + (resp. ), where we say that such occurrences are active. \nThe basic algebra over terms is defined using exactly the same set of rules as in Definition 2.2, and \ndenoted by ~. The definition of reduction relation starts from fixed rules of interaction between atomic \nagents.4 Definition 3.3 (reduction relation) One-step ~educ\u00ad tion relation, +, is the smallest relation \ngenerated by the rules in Figure 1, together with (PAR), (RES) and (STR) in Definition 2.3. Then multi-step \nreduction re\u00ad lation, *, is defined by ~ ~f - U Z. Note that there is one and only one rule for each \npair of atoms with opposite polarities, and, moreover, that the set of free identifiers in the right-hand \nside term is a subset of that in the original term. These properties would naturally be considered to \nbe part of the criteria for reduction rules of (untyped) concurrent combinators in general (note that \nwe regard polarities as one of the essential elements of computation, cf. [18]). Let us give some illustrations \non the behaviour of each atomic agent: firstly, M (ah) is a message carrying a name b to a name a, D(abc) \nis a duplicator, which du\u00adplicates a received message and sends it to two different locations. Then 7W(ab) \nis a forwarder which simply forwards a message to another location (cf. 2.2). K(a) is called a killer, \nwhich kdls a message.5 The next two agents, called binders, are more complex. Each binder generates a \nnew forwarder using the name it receives in its own way. Bl (ah), a left binder, uses the received name \nat the left of a forwarder, while B. (ah), a right 4The rules for atomic agents can be formed only by \nusing atoms in the nameless format, which has its own advantages. We believe, however, that the present \nformulation is much easier to grasp. 5FW and K are, in fact, definable from D, in exchange for a certain \n(manageable) syntactic issue in Theorem 4.4 later. See [15]. binder, uses it at the right. The fired \natom is a syn\u00adchroniser, S(abc), used for pure synchronisation without value passing, often necessary \nin interaction scenarios. Note that binders and a synchroniser change the topol\u00adogy of communication \nby generating a new link (a forwarder) after  3.2 Agents Some agents with low. Specifically, can be \ndone only bination. Note make intermediate (1)Let Ds(abcd) interaction in their own ways. and their Reduction \ninteresting behaviors, are given be\u00ad (3) shows how multiple name passing by using atomic agents and their \ncom\u00ad again how private names are used to interaction safe. &#38;f e ~(D(abe), D(ecd)). Then: M(av), \nIk(abcd) _ M(bv), e b(M(ev), D(ecd) -M(bv), M(cv), M(dv) D4, D5, .. can be defined similarly. (2) Let \nSW(ab) ~f c P(B.(at), M(cb)). Then: SW(ab), M(ad) ~ ~[.7JV(cd), M(cb)) This is a switcher, already introduced \nin 2.2. (3) Let us define SW (C1VCC2) %* dd @(cldd ), SW(dv), S(d ccz)) %?(elezue{ej) ~f d1d2d3 ~(D(ele{dl), \nD(ez&#38;), S(d2d1d3), SW(dse~)) . Assuming these notations, the following defines agents, the first \nof which sends n names consec\u00adutively, while the second receives them and trans\u00admits each to different \nlocations (we write ~~=1 Pi for PI, Pz, .... Pm). * a*: Vlvz..vn ~f Ccl..cn P(M(ac), FYV(CCI), ~~~11 \ns~ (ci~icci+l), Sw(cnwn)) +a*: uluz..un = def eOell..en2 P(D(aeOen), 0V(e0e12), n~.~ ~(eilei2uie(i+l) \nle(i+l)2), S(en~en2un)) Then, by tracing the reduction, we get ta*:vlvz.. vn, 4a*:uluz..un ~ M(ulvl), \nM(UZVZ), ... M(unvn) . Thus values are successfully transmitted in the ex\u00ad pected order.  3.3 Equality \nover Agents We formulate the notion of equality over agents in the same way as we did for u-terms. Since \nthe formulation of a Iabelled transition relation itself seems far from ob\u00advious in the present setting, \na construction based on the reduction relation is essential. Equality over open terms is understood as \nfor v-terms. Firstly, we have the notion of reduction closure in ex\u00ad actly the same way as before. The \nnotion of the action predicate is given by: P v., %f ~P . P _ P A a E tie (P ). Then, as before, a congruence \n% is $ae \u00adsound, or simply sound, iff it includes =, is reduction closed, and, moreover, P ~ Q and P \nl,lae implies Q $.ae. The following proposition is again easily obtained. Proposition 3.4 There is a \nmaximum sound congru\u00adence among the family of all sound congruences. We call this maximum sound equzdity \n=... The scheme of having a canonicsl notion of equality as the representative of a family of meaningful \nsmall equalities is often useful. As a tractable subset of =CC, we introduce ~-equality, which is extensively \nused in subsequent sections. Firstly, we need a notion called pointedness. A closed term P is ae -pointed, \niff P satisfies the following condition (d is the inverse of 0). (i) tie(p) = {a} and tia(l ) = 0. (ii) \nAbove a is the unique active occurrence in P?  (iii) P ~. Pointedness of a term tells us that there \nis only one interacting point in a given term (possibly unfolding further points after interaction). \nAn open term is ue\u00adpointed iff, for each closed substitution, the above con\u00addition is satisfied by a \nname substituted for u. We often write P(UOj etc. to denote a ue-pointed term P. Note that atomic agents \nare always pointed in this sense. We also note that pointedness is a linearly decidable prop\u00aderty for \nany cc-term. We are now ready to formulate the /?-equality to\u00adgether with related reduction relations. \nDefinition 3.5 The one-step /lI-reduction, 4P, is de\u00adjined by the rule: (COMP) c E(P(c-), Q(c+)) +P c~~ \n6Behav&#38;r~ly we ~an Chage this CkW3e~Y CT? ~ MEfor (P, CT(.Z)) + QI and (P, C5(IZZ))+ Q2 then QI \ns QZ. if P(c-), Q(c+) _ R, together with (PAR), (RES) and (STR) of Definition 2.9. -p ~f -~ U z, while \n=p is the symmetric closure of +p. To show that =@ is sound, the following is crucial. Un\u00adderlying is \nthe insight of Cliff Jones [16] that the essen\u00adtial role of name hiding in a name passing scenario lies \nin prevention of interference, Lemma 3.6 (non-interference) Suppose P *9 Q1 and P -++ Q2. Then there \nexists Q s.t. Q1 + Q and Q2 -p Q . PROOF. By argument in terms of one-step reduction, i.e. P -p Q1 and \nP_ Q2 with Q1$ Qz then there exists Q s.t. Q1 _ Q and Q2 -p Q , es\u00adtablished by the syntactic analysis \nof residuals. D Proposition 3.7 =@ is a sound congruence, hence P =fl Q implies P === Q. PROOF. By induction \non the derivation of =p, we can show that PI =p P2 implies that there exists P such that P *P P1 and \nP++P Pz, soPI ~ Q1 implies P Q1. Using Lemma 3.6, we get, for some Q , Pz --H Q and QI ~p Q . Immedi\u00adately \nQ1 =6 Q , which shows the reduction-closure of =6. To prove that =@ respects the action predicate, we \nfirst show that P .$ae and P +@ Q imply Q .$Ce, using Lemma 3.6. Then the property easily follows, again \nus\u00ading Lemma 3.6. l As an application of =@, let us take a close look at the reduction in (3) of 3.2. \nThen we get: 4-a*: vlvz..vn, *a*: UIUZ ..un -+ p M(ulvl), M(UZVZ), ... M(UnVn) which tells us that the \nreduction after the initial step is safe .  4 Concurrent Combinators (2): Representing Prefix 4.1 Analysis \nof Prefix (1) If we view J in A-abstraction as a kind of interaction point (cf. [1]), the decomposition \nof functional abstrac\u00adtion in comblnatory logic may have a natursl analogue in the world of concurrency. \nPrefix in concurrent pro\u00adcesses, however, has an important role not eminent in the A-abstraction. It \nis concerned not only with the communication of values but also with the control of synchronisation in \nthe setting of concurrency. This fact composition (I). U*Z.(P, Q) ~f C1C2F(D(~cIcz), c:~.p, c~z.Q) c1, \nC2 fresh. (11). u*x.cb P :f c >u*ZP{c /c} c fresh. (III). u*x.A %%f K(u) synchronization (IV). U z.c(v+ti) \nAf c F(S(UCV), C(c+ti)) z $! {vti}, c fresh. (v). U s.c(v ti) =f c F(S(UVC), C(c-ti)) z @ {vIZ}, c fresh. \n binding-I (VI). u*z.M(vz) =f Fw(uv) z#v (VII). U* Z. FW(ZV) %f B1(UV) X+v (VIII). U z.m(vz) Sf Z3r(uv) \nx#v binding-II (IX). u*zc(tilz+ti2) =f c W* Z.(FW(CZ), C(ljc+tiz)) z @ {vI}, c fresh. binding-III (x). \nu*&#38;c($-i) Af c PU* Z.(FW(ZC), C(c-fi)) c fresh. (XI). U* Z.B, (VZ ) ~f C1CZC3PU*Z.( D(VCICZ), S(CIZC3), \nB.(CZC3)) Z # V c1,C2,C3fresh. (XII). U z.s(vz-w) =f C1C2PU* Z.(S(VCICZ), M(clz), B2(C2W)) z#v c1, C2 \nfresh. Figure 2: Name Abstraction makes decomposition of name passing into finite dynam-Note that the \nannotated ~olarities are vreserved un\u00adits more complex, yet it is indeed possible. The meta-der reduction, \ne.g. D&#38;-v;v;), M~u+v ) \u00adnotation for an input guard is written u*x.P, where * M(v~v ), M(v/v ) etc. \nshows that this is not a formal construct in the system of concurrent combinators, but a meta-level notation \nto Some commentaries on the translation follow, be mapped to a cc-term (cf. [9]). The resulting term, \n (i) h (I), we distribute the received message into twohowever, is expected to act as if it had the input \npre\u00ad(decomposed) pointed abstractions, safely usingfix ux until it receives a message it should make \nthe private names. Note that not only the value butbody inert, while, once it does, it should activate \nthe also the activation is transmitted. The construc\u00adbody, after appropriate substitution, for further \ninter\u00adtion is clearly reminiscent of the usage of S in com\u00adaction with the outside. The mapping follows. \nbinatory logic when decomposing the abstraction of two applied terms. The next two rules, (11) and Definition \n4.1 (name abstraction) FOT P being any (III), may need no explanation (in (II) we assume cc-term, we \ninductively form the agent denoted by that fresh names are found uniquely). By rules (I)u*z.P, called \na u-pointed abstraction of x over P, in to (III), we have dealt with the cases where the pre-Figure 2, \nwhere rules are applied from (I) to (XII) in fixed body is either composite or nil, as well as the this \norder, and we assume the following annotations, origins of D and K which denote how each name is wed \nin the rules of in\u00ad(ii) When the prefixed body is an atomic agent whichteraction. does not contain any \nabstracted name variable, the M(u+v+), ~(U-V+lO+), ~(U-), prefixing actusly plays functions as nothing \nbut Fw(u-v+), fiz(u-v+), Z3r(u-v-), S(U-V-70+) the control of synchronisation. This is the origin of \nS, the synchroniser, see Rules (IV) and (v). Note that the existence ~f a forwarder is already assumed \nby S. (IV) is straightforward. In (v), an interac\u00adtion of the mapped term with a message results in c \nE (7W(VC), C (cti)) which is not syntactically the same as C (vti) but which has essentially the same \nbehaviour (cf. Theorem 4.4). (iii) When the prefixed atom contains abstracted vari\u00addef ables, unlike \nin combinatory logic, i.e. A*z.x = 1, we should deal with abstracted variables which may occur in various \nplaces in each atomic agent, result\u00ading in the seven rule schemes shown in the figure. In (Ix) and (x), \none pushes out the abstracted name variable using the forwarder. Take the case of U* Z. M(Z+V), which \ncorresponds to rule (IX). This becomes w z.c P(7W(cZ), M(cv)). Thus, when a message arrives at u , the \nforwarder is launched to forward the waiting message. (x) acts in the op\u00adposite direction. Rules (VII) \nand (VIII) explain the origins of the left and right binders (note that these form the base cases for \ntransformations by (Ix) and (x)). Finally, abstracted names with negative po\u00adlarities but not at subject \npositions, (xI) and (XII), cannot be done easily using forwarders as in (x), due to the control of the \ntiming of synchronisation (note that e.g. 13r(ab) and c P(B,(ac), 3W(bc)) are essentially different). \nListed mappings seem justi\u00adfiable only behaviorally. While complex in several cases, (I) to (VIII) always \ndi\u00adminish the size of the prefixed body, and all the posi\u00adtively abstracted variables are pushed out \nby (IX). For negatively abstracted variables, (x) boils down to (VII), (XI) and (XII), while (XI) is \nreduced to (XII), and (XII) is reduced to (IV) or (VI) (note w in Z31(C2W)occurs pos\u00aditively), which, \nas a whole, tells us that the mapping is well-defined. We also note that the mapping satisfies expected \nel\u00adementary syntactic properties such as 3V(a*z.P) = 3W(P) \\ {z}, a*x.P Za a*y.P{y/z} and (a*z.P){w/u} \n-a a{v/u}*z.P{v/u} if u # z. 4.2 Analysis of Prefix (2) In the following, we will show that the behavior \nof a*x.P is essentially as we expect it to be, i.e. (a*z.P, M(ab)) would reduce to the behaviour corre\u00adsponding \nto P{v/x}, and also a*x.P freezes the body P. The latter property can be easily verified, using the notion \nof pointedness we introduced in the previous sec\u00adtion. 7This ~Ome~from the asymmetric character of forw=d=s. \nA symmetric. alternative is possible, although this raises its own complications. See [15]. Proposition \n4.2 (Pointedness) FOT any a, x, and P, a*x.P is a--pointed. PROOF. Firstly we show, by rule induction, \nthat a with the negative polarity is the only active occurrence in a*x.P. Using this, inductive reasoning \nagain shows that no redex is formed at any stage of translation, in\u00ad cluding the bottom cases. D The \nvalidation of whether (a*z.P, M(ab)) reaJly re\u00adduces as we expect it to, however, is not straightforward. \nIn fact, as we already saw, a*z.3W(b1&#38;), M(ab) + c >(7W(hlc), ~W(cb2)) ~ 7W(bI b2). Thus, it cannot \nalways be the case that a*z.P, M(ab) ~ P{b/z}. This is due to the issue of sgmchronisation we discussed \nat the outset of this section. Take the above example. To freeze the body YW(Zq k ) by a prek, it cannot \nbe preserved in this form since we only have concur\u00adrent composition as a mode of combining two terms \n(cf. A z.s Af KS). Thus we hide the subject bl until necessary, preventing it from interaction. With \nthis complication, however, one can easily see that, if a*z.P, M (ah) -Q then Q behaves essentially in \nthe same way as P{b/z}. To clarify this point, we de\u00adfine >~, a series of strongly syntactic behavioral \npre\u00adorders, inductively as follows, where we write P Jp P iff P -up P +P (note that such P! is unique \nup to s). (i) >, ~fa. (ii) a. P l.+l Ce(uti) iff P JD P/U,), and, for any CT, we have:  P , CT(uti) \n_ Q a (Ce(Wti), C3(U@ -Q A Q >. Q), Ce(@, CF(uti) -Q a (P ,Cr(@ -Q A Q >. Q). b. >-is the compatible \nand transitive closure of k. Then P + Q iff, for some n, we have P % Q. Intu\u00aditively, P > Q means that \nany atomic agent in Q has its close simulator in P, whose interactive behaviour is essentially the same \nas the original agent. Now we have the following. Proposition 4.3 P > Q ~ P =.= Q. PROOF. We construct, \nfor each n, the symmetric clo\u00adsure of >n, + >n, and show that it is sound by rule in\u00adduction on the formation \nof +>n (including the rules for congruence), assuming >~ G === for the case of < +n+l. The proof is tedious \nbut elementary. See [15]. l Note that > is much stronger (more restrictive) than =CC, or stronger than \nany weak canonical equalities we 255 may apply to the present formalism. The main theorem follows. Theorem \n4.4 (Reduction Theorem) For any a, v, z, and P, we have: a*x.P, M(av) +> P{v/x}. PROOF. By induction \non the rules given in Figure 2, inspecting each case. Note that we can use induction on the size of cc-terms \nfor rules (I) to (VIII), while, for the remaining rules, we safely hypothesize on decomposed abstractions \nand reason about the whole expression. Case (I), Let k.P @ v ~f c P(c*z.P, M(cv)) with c fresh. Then: \na*x.(P, Q), M(av) + Ax.Pov, AX.QOV +8 P , Q but by inductive hypothesis, P + P{v/x} and Q > Q{v/x}. With \ntransitivity and compatibility of +, P , Q > (P, Q){v/z}, as required. Case (II). Easy by inductive hypothesis \non P{c /c}. Case (III,VI,VII,VIII), Straightforward. Case (IV). Note that C(v+il) is a message. Then: \nM(av ), a*x.C(v+ti) _ cb(7W(cv), C(c+ti)) -i@ C(vti), sa required. Case (v). We first show, with c @ \n{e, ti}, c b(fW(e-c+), C(c-ti)) > C(e-7i) (1) Then we have M(av ), a*z.C(v-ti) + C>(7W(VC), C(c-ti)) \n> C(vti), For the remaining cases, we use the following claim. CLAIM. l~c*x.Ci(@~), M(cv) -> Ci(tii){v/x} \nwith 1 < i ~ n, and, moreover, :* n?=, Ci(tii) > C (ti ), then, for any u and x, we have bu z.~:=, Ci(ti,) \n> U x.c (ti ), This is easily established in the same way as we did for (I) and (II) above. Now the remaining \nrules are in\u00ad spected. Case (IX). It is clear that the symmetric property of (1) holds, i.e. with c @ \n{e, ti, t}, we have: cp(7W(c-e+), C(tic+ti)) )-C(tie+ti) (2) Then this case is obvious from the Claim. \nCase (x). Use (1) together with the Claim. Case (XII). By the Claim, a z.$(vlxvz), M(aw) x> C1C2P(S(V1C1C2), \nM(clw), BZ(C2V~)) ~f S (vlwv; ) with =f v2{w/z}. But (~ (VIWV~), .&#38;t(vIw )) \u00ad V2 Clcz P(~(cIcz), \nM(clw), f$(czvj)) ~p ~W(WVj), as required. Case (XI). We have a x.fi?r(vz), M(aw) +> C1C2C3P(D(VCl C2), \nS(C1WC3), &#38;( C2C3)) by the Claim and (XII). Let the resulting term be denoted by B;(VW). Then: B;(vW), \nA/ f(vW ) ++p C3P(YW(c3w ), FW(WC3)) > 7W(WW ) by (2), hence the result. D This concludes the validation \nof behaviour of a*x.P.  4.3 7r-Prefix In the following we show that we can easily generalise the above \nresults to the synchronous prefix in the line of the polyadic r-calculus [21] (thus subsuming monadic \ncommunication), using the notation given in 3.2. Proposition 4.5 We dejine a*: (XI... XnP.P def = C1..Cn+I \n(~a*: C1..cn+l, C;xl. c;xz ....c.+lxn+l. (M(X~+I), P)) def ii*: [vlv2..vn].P = c E(+ a*:vlv2..vnc, C*.P) \n with C,CI, .... Cn+l fresh and distinct from each other, and M(y) and c* .P understood as in v-calculus. \nThen a*: (xl... xnP. P is a -pointed and ~*: [v1v2..vn]. P is a+\u00adpointed. itIoreover: a*: (x1x2 ..zn).P, \n~ : [v1v2..vn].Q + > P{v1v2..vn/z1x2 ..xn}, Q PROOF. Pointedness is straightforward. The correct\u00ad ness \nof reduction is verified by using the property of reduction between * a* : V1V2..Vn and ~a* : u1u2..un \nmentioned at the end of 3.3, together with Theorem 4.4. D Thus our combinators are closed under those \nprefixes which we usually associate with processes. Our [14] fur\u00adther extends the notion of prefix to \nembody the com\u00adplex operational structures including branc~lng, which can also be treated in the same \nway. See [15] for details.  5 Correspondence between Two Systems This section establishes the basic \ncorrespondence be\u00adtween u-calculus and concurrent comblnators. By the result, we know, modulo equalities \n=CC and =V, two systems are equivalent. We also mention the embedding result of the finite n-calculus \nin concurrent combinators (1) Translation from PC. to Pv. Cl=d[A4(W)]. =f + Uv p(uvw)]v %f 74Z.(+VZ, \n+Wz) [S(uvw)]v Uz.vy. +Wy p-kv(uv)]v *f UZ. +Vx p,(m)] ~f Ux.vg. +Xy [&#38;3,( uv)]v %f Uz.zy. +Vy [K(u)] \n~f UZ.A [P, Q] *f [P]v, [Q]v [a>l ]. %f aE[P]. [A]v %f A (2) Translation from Pv to PCC. [+wr]cc :f M(w) \n[UZ.Q]CC d=f U* Z.[Q]CC [P, Q].. ~ti ~P]~,, [Q]c~ [a PP]cc ~ a P[P].c [A].c %f A Figure 3: Translation \nbetween PC= and Pv at the end. To avoid ambiguity, here and henceforth we (ii) P+. Q * 3Q .(Q -v Q A \n[p].. +..> [Q ]..), often write 4CC (resp. a.) and =CC (resp. -V) to de-and ~P]CC +.. R + 3 Q. (R > [Q]cc \nwith note the reduction and the structural congruence over P -v Q). P=. (resp. Pv). Translations between \nthe two systems are given be-PROOF. (i) is mechanical. For the first half of (ii), low. The map from \ncc-terms to v-terms is quite straight-we use Theorem 4.4 and the fact: ax. P, + ab -v forward. The reverse \ntranslation uses the mapping of Q * Q -V P{b/z}. For the second half, one uses u*x.P we gave in the previous \nsection. Theorem 4.4 and Proposition 4.2. D Definition 5.1 (translation between v-terms and From this, \ntogether with Proposition 5.2, we obtain the combinators) We dejine two functions, [*]V : PCC + correspondence \nin terms of the action predicate. PV, and [.]CC : PV + PCC, in Figure 3. Proposition 5.4 Note that both \nmaps are injections. The syntactic cor\u00adrespondence follows. (i) P J.oo 4$ [P]v J1.e for P G P==. Proposition \n5.2 (syntactic correspondence of trans-(ii) P JaO e [P]cc Jl=e for P E P.. lations) In the following, \n[P] denotes either [P]v or To study equational properties of the translations, the [P]cc, and relational \nand other symbols are interpreted following property of =.C is fundamentals accordingly. (i) %~~&#38;), \n= 7 .M([P]), 7V(P) = %V([P]), Proposition 5.5 P =.. Q a a*z.P =.. a*z.Q, = N,([P]). (ii) For any substitution \na, [Pa] SO [P]a. The property is established by constructing a congru\u00adence which includes both =CC and \nthe above equations, (iii) P s.. Q * [P]. -~ [Q]., and and showing that it is reduction-closed and respects \ntheP -v Q ~ [P]cc <> [Q]cc where <> is the action predicate. See [15] for details. symmetric closure \nof >. Now we can show that the translations are equation-PROOF. For (i) and (ii) we use induction on \nthe struc-ally adequate , in the following sense. ture of terms. For (iii), we use rule induction on \nderiva\u00adtions of -. D Theorem 5.6 (i) P=CcQ @ [P]v =V ~Q]V for P,Q6PCC. We need <> for the second half \nof (iii) in Proposition 5.2 because we have P GV Q ~ az.P EV az.Q (see (ii) P=. Q ~ [P]cc =.= IQ].. for \nP, Q E P.. footnote 8). The next result gives us the correspondence in terms of the reduction relations. \nPROOF. (i) is obtained by constructing a relation = such that P = Q iff [P]v = . IIQ1.,and showing that \nit Proposition 5.3 (operational correspondence) SContrwy to possible expectations, s is not closed in \nthe WaY, (i) P +.. Q * [P]v +V [Q]v, and e.g. (P, A) z P but a*z.(P, A) ~ a*z.P. For further discussions, \n[P]. + R a R s [Q]. with P +CC Q. see [15]. 357 is congruent, reduction-closed, and respects the predi-(az.az.A)cC \n#cc (az.A, az.A)cc. This is essentially cate $Oe, each of which is easily inferred from Proposi-because \nterms with illegal protocols can discriminate tions 5.2, 5.3, and 5,4, The proof of (ii) issimilar, using \nfiner differences than those in the original world (cf. Proposition 5.5 to verify congruence. D [20]). \nAn interesting open question is whether the ad\u00ad dition of new atoms with new behaviors, e.g. syn-Based \non the result, we are now ready to state the chronous output, can solve the issue, while retaining equivalence \ntheorem for two systems (cf. Theorem the closure property under prefix, as we have in the 7.3.10 in [2]). \npresent system. Theorem 5.7 (equivalence between two systems modulo equality) 6 Discussion (i) [P].,.c \n=CC P. 6.1 Lafont s construction (ii) [P]CC,V =. P. Lafont s Interaction Net [18] is a generalisation \nof Gi. (iii) P =.c Q @ [P]v =. [Q]v. rard s proof nets [7]. It provides a graph-based formal\u00ad(iv) P=. \nQ ~ [P]cc =.= [Q]cc. ism for a computation scheme similar to ours. While independent in inception, Lafont \ns construction can be PROOF. (outline) For (i) and (ii), we prove, by in\u00adconsidered to be a precursor \nto our work. Below we list duction on the structure of terms, the corresponding some similarities and \ndifferences. stronger statements; [P]V,CC > P and ~P]CC,V > P where > is defined for PV just as >, regarding \nmessages (1) The computational frameworks of both systems are and receptors as atomic agents. The only \nif direction quite similar. Lafont s polarity corresponds to our of (iii) follows from Theorem 5.6 (ii) \ntogether with (i) polarity, his principal ports correspond to our no\u00ad above, in the way: tion of subjects, \nand his port connection corresponds to name connection with hiding (so our operationP === Q * [P]V,CC \n=.. P === Q =CC [Q]V,CC (i) is finer in this aspect). Specifically, cut becomes * [P].=. [Q]v (Theorem \n5.6 ii) our forwarder. In fact there is a clean embedding of an important family of hls systems in concur-Similarly \nfor (iv), using (ii) above and (i) of Theorem rent combinators with the replication mentioned in 5.6 \ninstead. D  6.3, for details of which the reader may refer to the authors coming exposition. Such an \nembeddingWe finally refer to the result concerning the transla\u00adalso suggests how our construction can \nbe given ation of a system of monadic synchronous communica\u00adgraph-based formulation (cf. [15]). tion, \nwhich is essentially the monadic r-calculus given in [20], but without replication, into our combinators. \n(2) In Lafont s system, if agents are connected to one The set of terms of the caJculus, denoted by Pm, \nis given location, one positive agent and one negative agent by: always share it, and, after interaction \noccurs, the lo\u00adcation is never used again (hence rewriting becomes P ::= ZV.P I UZ.P I P,Q I aEP I A \nconfluent). Such a restriction would be useful for some purposes, but there are situations where we Translation \nfrom cc-terms to n-terms is equally straight-need more general descriptive power (cf. [17]). We forward \nas [.]v except that we use iiv.A instesd of+-w. also note that, as far as we know, there is no cal-The \nreverse translation is given using the mapping in culus counterpart to Lafont s system, and that, in \nProposition 4.5, in exactly the same way as [ ]... If we this connection, no proposal for basic comblnators \nwrite the maximum sound congruence in the r-calculus is done in [18]. Incorporation of the typing frame\u00ad=fi, \nthe similar path as we had before lets us prove: work developed in [18] into our formalkm would be an \ninteresting topic for further research. P =.. Q # (P)r =7 (Q)m where (.)F is the mapping from PCC to \nPr. Similarly, 6.2 Combinatory Logic if we write the translation from r-terms to concurrent The clasical \ncombinators were born from logics, whilecombinators ( )CC, we get: the present construction is derived \nfrom the theoretical investigation of concurrency. Whether we can in fact  P =x Q e (p).. =.. (Q).. \n call the present construction an analogue of the original Interestingly, the converse of the above statement \ndoes one is a difficult question. It is thus instructive to pick not hold, e.g. ax.ax.A =r ax.A, ax.A \nbut out similarities and differences between the two notions. (1) Both are based on decomposition of \nsimple, yet pointed name abstraction, The representation has a powerful, reduction schemes in their respective \nset-non-trivial consequence in that, by this, we gain the tings, into finite dynamics. We expect, specif-representability \nof not only the full v-calculus and Mil\u00adically in this aspect, that ours would have the ner s m-calculus \nwith replication in [20], but also any same application to the pragmatic of computing (untyped) systems \nof concurrent combinators with fi\u00adas the sequential combinators, namely, the execu-nite atoms. Full explication \nof the topic is left to [14]. tion scheme of programming languages, but now in a concurrency setting. \n Acknowledgements (2) As we discussed in Section 3, one essential differ\u00adence is found in the notion \nof atoms. Here atoms  The authors wish to thank Makoto Kubo for his sug\u00adshould be connected to locations \nto become ac\u00adgestions and advice. They also thank Professor Mario tive as agents. This seems inevitable, \neven if we do Tokoro for his encouragement and support. not use names to denote locations (cf. [18]), \nas far as we want to represent multiple interaction points and their connection topology, which we believe \nto  Referencesbe essential elements of concurrency. (3) Our understanding of the present construction \nis [1] Abrarnsky, S., The Lazy Lambda Calculus. D. still in its infancy, when compared to that of clas-Turner, \neditor, Research topics in Functional P~o\u00ad sical combinators. Further investigation is needed gramming, \nAddison Wesley, 1990. to clarify the basic constructs of the formalism, e.g.  essential connective (how \nabout summation?), the [2] Barendregt, H., The Lambda Calculu: Its Syntax necessity for polarities, the \ntype-theoretic founda-and Semantics. North Holland, 1984. tions, as well as the general semantic framework. \nThese will provide important subjects for future [3] Berry, G. and Boudol, G., The Chemical Ab\u00ad study. \nstract Machine. Theoretical Compater Science, 96, pp.217-248, 1992. 6.3 Replication [4] Boudol, G., Asynchrony \nand r-calculus. INRIA Re\u00adport 1702, INRIA, Sophia Antipolis, 1991. The present work only gives a combinatory \nrepresenta\u00adtion of a finite part of v-calculus. Though it is possible [5] Curry, H. B. and Feys, R., \nC ombinatory Logic, Vol. to add the construct !P to the system to gain unbounded I North Holland, 1958. \nbehaviour (and hence full computational power) with some addition to the mapping shown in Figure 2, it \n[6] Engberg, U. and Nielsen, M., A C alculus of Com\u00ad would be more satisfactory to obtain the same effect \nmunicating Systems with Label Passing. Research simply by adding finite atoms. Thus a natural next step \nReport DAIMI PB-208, Computer Science Depart\u00ad is the representation of full v-calculus by finite atoms, \nment, University of Aarhus, 1986. or, more concretely, for any combinator P, to represent !a*z.P such \nthat [7] Girard, J.-Y., Linear Logic. Theoretical Computer Science, 50, pp.1-102, 1987. !a*z.P, +ab -+2 \n!a*z.P, P{b/z} [8] Hewitt, C., Bishop, P., and Steiger, R., A Universal by utilising a finite number \nof atoms and their com- Modular ACTOR Formalism for Artificial Intelli\u00adbinations (the usage of a lazy \nreplicator results in no gence. Proc. of the 3rd International Joint Confer\u00adloss of expressive power; \n~ is a certain extension of>). ence on Artificial Intelligence, pp.235 245, 1973. Perhaps surprisingly, \nthis is indeed possible, by adding a handful of atoms, which are systematically derived from [9] Hindley, \nJ. R. and Seldln J. P., Introduction to the seven basic atoms. There are two essential points. Cornbinators \nand ~-Calculus. Cambridge Univer\u00adsity Press, 1986. (1) Introduction of the name generator, which creates \na new name each time it interacts. [10] Honda, K. and Tokoro, M., An Object Calculus for Asynchronous \nCommunication. ECOOP 91, LNCS atomic agent (with different instantiations) each (2) Introduction of \ntemplates, which make a new  512, pp.133 147, Springer-Verlag 1991. time it is requested. [11] Honda, \nK., Two bisimilarities in v-calculus. Keio Using these and other persistent atoms, a system with CS report \n92-002, Department of Computer Sci\u00ad(at most) 28 atoms is closed under usual and replicated ence, Keio \nUniversity, 1992. [12] Honda, K., Types for Dyadic Interaction. CON-CUR 93, LNCS 612, PP.504 523, Springer-Verlag, \nApril 1992. [13] Honda, K. and Yoshida, N., On Reduction-Based Process Semantics. FSTTCS 13, LNCS 761, \nSpringer-Verlag, 1993. [14] Honda, K. and Yoshida, N., Replication in Concur\u00adrent Combinators. To appear \nin TA CS 94, LNCS, Springer-Verlag, 1994. [15] Honda, K., Kubo, M., and Yoshida, N., Combina\u00adtory Representation \nof Mobile Processes: Part I. To appear as a Keio CS report. [16] Jones, C. B., Constraining interference \nin an object\u00adbased design method. TAPSOFT 9$, LNCS 668, pp.136 150, Springer Verlag, 1993. [17] Jones, \nC.B., Process-Algebraic Foundations for an Object-Based Design Notation. UMCS-93-1O-1, Computer Science \nDepartment, Manchester Uni\u00adversity, 1993. [18] Lafont, Y., Interaction Nets, POPL 90, pp.95-108, ACM \nPress, 1990. [19] Milner, R., Parrow, J.G. and Walker, D.J., A Cal\u00adculus of Mobile Processes. Information \nand Com\u00adputation, 100(1), pp.1-77, 1992. [20] Milner, R., Functions as Processes. Mathematical Structure \nin Computer Science, 2(2), pp.119-146, 1992. [21] Milner, R., Polyadic T-Calculus: a tutorial. Logic \nand Algebra of Specification, Springer-Verlag, 1992. [22] Milner, R. and Sangiorgi, D., Barbed Bisimula\u00adtion. \nICALP 92, LNCS 623, pp.685 695, Springer-Verlag, 1992. [23] Schonfinkel, M., Uber dle Bausteine der mathe\u00admatischen \nLogik. itlath. Annalen 92, pp.305-316, 1924. Engl. trans. in J. van Heijenoort, editor, From Frege to \nG6del, pp,355 366, Harvard Univ. Press, 1967.  \n\t\t\t", "proc_id": "174675", "abstract": "<p>A theory of combinators in the setting of concurrent processes is formulated. The new combinators are derived from an analysis of the operation called <italic>asynchronous name passing</italic>, just as an analysis of <italic>logical substitution</italic> gave rise to the sequential combinators. A system with seven atoms and fixed interaction rules, but with no notion of prefixing, is introduced, and is shown to be capable of representing input and output prefixes over arbitrary terms in a behaviourally correct way, just as SK-combinators are closed under functional abstraction without having it as a proper syntactic construct. The basic equational correspondence between concurrent combinators and a system of asynchronous mobile processes, as well as the embedding of the finite part of &#960;-calculus in concurrent combinators, is proved. These results will hopefully serve as a cornerstone for further investigation of the theoretical as well as pragmatic possibilities of the presented construction.</p>", "authors": [{"name": "Kohei Honda", "author_profile_id": "81100624236", "affiliation": "Department of Computer Science, Keio University, 3-14-1, Hiyoshi, Kohoku-ku, Yokohama 223, Japan", "person_id": "PP39071025", "email_address": "", "orcid_id": ""}, {"name": "Nobuko Yoshida", "author_profile_id": "81100632656", "affiliation": "Department of Computer Science, Keio University, 3-14-1, Hiyoshi, Kohoku-ku, Yokohama 223, Japan", "person_id": "PP39051644", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/174675.177953", "year": "1994", "article_id": "177953", "conference": "POPL", "title": "Combinatory representation of mobile processes", "url": "http://dl.acm.org/citation.cfm?id=177953"}