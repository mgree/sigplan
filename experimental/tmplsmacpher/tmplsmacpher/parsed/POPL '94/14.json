{"article_publication_date": "02-01-1994", "fulltext": "\n Automated Synthesis of Interface Adapters for Reusable Classes Satish R. Thatt6 Department of Mathematics \nand Computer Science (llarkson University, Potsdam, NY 13699-5815. E-mail: satish@sun. mcs. clarkson. \nedu Abstract thing ranging from different languages/hardware plat\u00ad forms to different sources for code \ncomponents. This The need to fit together reusable components and sys-problem has been recognized and \npartly addressed, tem designs in spite of differences in protocol and rep-e.g., in the CORBA [OMG92] \nstandard for distributed resent ation choices occurs often in object-oriented soft-components, and in \nIBM s SOM [IBM92] library man\u00adware construction. It is therefore necessary to use agement system for \nclass libraries. However, neither adapters to achieve an exact fit between the available CORBA nor SOM \nadequately deal with the inflexibility socket for a reusable part and the actual part. In of the interfaces \n(signatures) offered by objects to the t hls paper we discuss an approach to the construction out side \nworld. I believe that such inflexibility is at least of tools that largely automate the synthesis of \nadapter a serious nuisance and could become a real problem code. Such tools are import ant in reducing \nthe effort whether the objects are connected statically by being involved in reuse since adapter synthesis \ncan be chal-compiled together or are dynamically connected using, lenging and error-prone in the complex \ntype environ-say, CORBA S notion of a dynamic invocation interface. ment of an object-oriented language. \nOur approach is Focusing on the static casez first, note that in the applicable to statically typed languages \nlike C++ and typical lifecycle of a large component-based system, 13iffel, and is based on a formal notion \nof adaptability there are likely to be many rebuilding episodes in which which is related t o but distinct \nfrom both subtyping and some of the old components are replaced by functi~\u00ad inherit ante. ally equivalent \n(or superior) new components. For in\u00adstance, in replacing an old library of container classes with a \nbetter one, or in accommodating an upgrade for Introduction a database system which also results in \na rationa~lza\u00adtion of the API. In both cases, there is liiely to be aThis paper starts from the position \nthat object tech\u00adprotocol mismatch between the expect ed and actual in\u00adnology is the most promising vehicle \nfor reahzing the terfaces for the new objects. The application program\u00adgoal of large-scale software reuse. \nThis is now a com\u00admer is now faced with the task of somehow adapting mon perception that provides much \nof the motiva\u00adthe new objects to bridge the difference between theirtion for the current industry-wide \nshift towards object\u00adexpect ed and available int erfaces -the obvious solutionoriented software design \nmethods. An obvious poten\u00adis to create stubs to connect the old interfaces to thetial bottleneck in the \npractical realization of this vi\u00adnew ones3. The task is not difficult in principle; in fact sion is the \nweakness of current component integration in most practical cases it is conceptually trivial. How\u00adtools \nespecially in the context of heterogeneous systems, ever, if a number of interdependent (and perhaps \nmu\u00adwhere heterogeneity is broadly understood to mean any\u00adtually recursive) interfaces are involved, along \nwith the Permission to copy without fee all or part of this material is 1Although the main motivation \nfor CO RBA comes from ~s\u00ad ~ranted provided that the copies are not made or distributed for tributed systems \nintegration, CO RBA-complitmt ORB s may of direct commercial advantage, the ACM copyright notica andtha \ncourse be used for integrating objects located on the same node title of the publication and its date \nappaar, end notice is given or even in the same address space. that copying is by permission of tha \nAssociation for Computing 2Besides evolutiorr/replacement of class libraries, this also in-Machinary. \nTOcopy otherwisa, or to rapubtish, requires a faa cludes versioning of object types in object-oriented \ndatabases. and/or spacific parmisaion, 3 Eveu when the functiou~lty of a reused class needs to be POPL \n94-li94, PortJand Oregon, USA extended to fulfill the requirements of the application, the prob\u00adlem can \noften be factored into a stub generation problem and an @ 1994 ACM O-S9791-636-9/!341001 ..$3.!50 extensiou \nproblem. complications of genericity, inheritzmce and overload\u00ading, the technical difficulty and opportunity \nfor error are likely to be substantial. Conceptual triviality and technical complexity is a very uninviting \ncombination for most people, and as such the task of synthesizing interface stubs is likely to be unwelcome \nand an obsta\u00adcle to the optimal evolution of both class libraries and component-based systems. At the \nsame time, its rela\u00adtively mechanical nature makes it an inviting target for automatic inference. The \nstub generation problem also occurs in both the static and dynamic invocation interfaces of a CORBA\u00adcompliant \nobject request broker (ORB). In the context of static invocation, the interface repository is used in \na way that resembles the use of a class (or stub) library and the remarks above about class libraries \napply. In using dynamic invocation, the alternatives for an appli\u00adcation are either to write complex \ncode that can analyze and use an interface found in the repository in the form of what amounts to a data-structure \nat run-time, or to assume a generic interface for the required server and rely on the ORB to supply a \ndynamic stub-generation service to bridge the protocol gap4, possibly with some interactive help. The \nlatter is obviously the more at\u00adtractive option. Conceptually there are two somewhat orthogonal is\u00adsues \nin stub generation. One is the formalization of compatibility y between interface types that is a gen\u00aderalization \nof the notion of substitutability in the usual subtyping relation, and allows functionality preserving \nchanges in method names, parameter order, etc. The other is both built-in and user-definable mechanisms \nfor type isomorphlsm between parameter and result types of methods that would allow data and object inter\u00adchange \nbetween client and server objects in spite of dif\u00adferences in representation and structure. This paper \nproposes a simple approach to the first problem based on an extension of Amadio and Cardelli s results \non subtyping with recursive types [AC91]. Intuitively, in order to realize the vision of classes that \npresent flexible external interfaces, we need to for\u00admalize an adaptability relation (denoted by ~ ) \nbetween interface types, where T ~ T means that objects of type T can emulate those of type -r . Moreover, \nadaptabil\u00adity must be a coercibility relation, and in fact the in\u00adference of such coercions is our primary \npractical goal since the coercions required for adaptability are pre\u00adcisely the adapters we wish to synthesize. \nWe are there\u00adfore interested in reasoning about judgments of the form Z h T~ # s c where Z is a set of \n(subtyping and adaptability) assumptions, and c is the adapter needed 4 Of course, there is theoretically \nthe thhd option of hand\u00adcoding a stub interactive y once the required interface is found, but this would \nrequire all users to be system experts. to convert an object of type T to the corresponding ob\u00adject of \ntype T . The main conceptual difficulty in formu\u00adlating inference rules for adaptability is the misleading \nsimilarity of the concept with subtyping. Clearly, if a class A can emulate l?, then an A-object can \nbe used (with some disguise) where a B-object is needed. Treat\u00ading the disguise as a coercion, this sounds \nexactly like the normal notion of structural subtyping. However, a formal application of this intuition \nleads to an im\u00adpasse where obviously compatible interfaces cannot be shown to be related. The quality \nthat distinguishes sub\u00adtyping from adaptability is that the coercions involved in adaptability are necessarily \nreversible whereas those used in subtyping are not. For instance, the (record) types {x: int, y :bool} \nand {x: int, z: char} are sub\u00adtypes of (and coercible to) {x: int } but these coercions obviously cannot \nbe undone. However, if a class A is adapted to implement the specification of a class B, then every B-object \nis created by attaching an adapter to an A-object, and this coercion can be easily reversed simply by \ndetaching the adapter. As a result of this difference, adaptability is a more liberal relation be\u00adtween \ninterface types than subtyping. Of course, the need for an adapter arises in part from another dif\u00adference \nbetween the two concepts adaptability allows functionaht y preserving interface transformations, i. e., \nit is indifferent to differences in method names, para\u00admeter order, and also to some extent to the number \nof parameters for a method5. These ideas can be formalized in a natural way in the form of a logic of \nadaptabilky and adapter infer\u00adence. The inference process can also be automated us\u00ading an algorithm that \nmodifies and extends the subtype inference algorithm of Amadio and Cardelli [AC91] for recursive types. \nSome interesting issues arise in extending adaptabil\u00adity to generic classes. The main dhliculty (assuming \nthat their instantiation is user-specified) is the repre\u00adsentation of their interface types since the \ntype para\u00admeters of such classes are typically constrained by (of\u00adten implicit ) assumptions about their \nfunctionWlty for instance they may be used in the implementation as though they support certain operations. \nIt has been found that representing such constraints with full generality requires F-bounded polymorphism \n[CCH+89] which is significantly more complex than ordinary bounded polymorphism [CW85]. However, since \nthe reusable generic class and the actual parameters it is used with often have different origins, it \nis natural to use adaptability rather than subtyping bounds for the para\u00admeters, and the proof-theoretic \nsimilarity of adaptabil\u00adity to subclassing permits the use of ordinary bounded sExtra parameters in an \nemulator operation can often be elim\u00adinated using default values. polymorphism without loss of generality. \nIt is worth noting that the adaptation of even a single generic class can be quite complex since the \nactual parameters for it oft en need adapters, besides the adapter needed for the generic class itself. \nFinally, it may be argued that the concept of adapt\u00adability discussed above is a purely syntactic one \nthat is concerned only with signatures and ignores seman\u00adtic issues, whereas the latter are the most \nimportant and difficult. This is undoubtedly true, but represent\u00ading behavior requires the use of full \nformal specifications written in a specification language such as Z [DDRS89], VDM-SL [PL92], or Larch \n[GHW85]. Apart from the question of the maturity of this technology for routine use on an industrial \nscale, the effort required to produce formal specifications often equals or exceeds the effort required \nto produce the code being specified, even if one assumes that the ordinary system designer is trained \nto produce or at least to follow such specifications. For routine applications, treating interface types \nas light\u00adweight specifications-and relying on the user for judg\u00adments about functionality-offers the \nmost benefits at the least cost at the present state of development of automated reasoning techniques. \nA major advantage of this approach is that it is user ~riendly----it expects very little extra effort \nand no new skills from users. Assuming that we are working with a statically typed language, the interface \ntype of every component and socket (or requirement ) can be extracted automatically. Moreover, as the \nrest of this paper makes clear, for\u00admal inference of the compatibility of interface types in the presence \nof differences in protocol choices is already quite intricate even for a simplified theoretical language \nsuch as the A-calculus dialect used here. It is even more so in a realistic language like C++ due to \nthe presence of genericity, overloading, atomic subtype relations, de\u00adfaults, and complex relationships \nbetween, e.g., array, pointer, and reference types. The complexity is fur\u00adt her increased by the fact \nthat, since classes are rarely self-contained, the compatibility with requirements of a whole collection \nof reusable classes will in general have to be considered in parallel. Automation of adapter syn\u00adthesis \ntherefore offers very real reduction in the effort involved in component reuse. Adaptability Inference \nWe now present a formal system of rules to give precise meaning to adaptability inference and adapter \nsynthe\u00adsis for nongenetic classes. As is usual in formal stud\u00adies of object-oriented type systems, we \nwork with a simple functional language with (possibly recursive) la\u00adbeled record types. Thk is especially \nappropriate in our case since the functional/imp erat ive distinction has no effect on interface matching, \nexcept that imperative languages typically support a somewhat more complex type structure -e.g., our \ntype language will not have pointer or reference types, in contrast to C++. We also do not consider product \nor disjoint union types, but an extension of the following system with these additional types presents \nno special problems. Note also that the semantics of our types is routine. We begin with a lan\u00adguage \nof monotypes (ranged over by ~) .. 7-.. a I T+-r I p I Obj(a). p ::= {1, : r,,... ,~~:T~} I ()&#38;{l:T} \nP that includes o Type variables a which are used both for recur\u00adsion and (as free variables) for primitive \nand user\u00addefined atomic types in the environment. Function types ~ --+ # used primarily for methods. \n Labeled record types p which allow a record type extension operator &#38; that is meaningful only if \nthe new label it adds is not present in the record type being extended,  o Object (i. e., interface) \ntypes Obj (a). p which for purposes of adaptability inference are just the usual recursive types6 pap, \nwhere p is a labeled record type representing the methods of the object, and a is the type of self. We \ndo not allow other kinds of recursive types, such as recursive function types, for conceptual economy, \nnot because of any techni\u00adcal problems. The language of expressions given below does not include class \nexpressions and types since we do not deal explicitly with inherit ante-the object types we deal with \nmay originally have been created via inheritance but the adaptability of such types has nothing to do \nwith the history of their construction. e ::=3 I Az:7-. e I e e I {ll=el, . . ..t~=e~} I eel I ewithl=e \nI self The language is an extension of the simply typed ~\u00adcalculus with object types and expressions. \nThe form e ~ 1 is often written as e.1 instead (it is the result of sending the message 1 to object e). \nThe infix opera\u00adt or with is the record extension operator corresponding to the type operator &#38;. \nThere is no explicit provision 6The notation pap denotes the canonical solution of the equation a = \np, where a may occur in p. See [AC91] for a more detailed dkcussion. for recursion but appropriate typed \nfixedpoint operators can be assumed to be part of the environment. Thk language is meant to be used for \nall programs including the coercions inferred in the subtyping and adaptability rules given below. However, \nfor simplicity, the coercions in the rules are given as untyped terms. It is also possi\u00adble to construct \nthem as typed terms, however this is a little tricky for the more complex rules and makes them hard to \nread. As we argued in the introduction, adaptability im\u00adplies tw~way rather than one way convertibility, \nand therefore the form of emulated types cannot be arbi\u00adtrary. If Z 1--r ~ T 7, then each object of type \n# must contain an emulator of type ~ which can be extracted in some way. We use the notation (-r) Adapt \n(a). p to represent the type of an adapter object with interface type Obj (a). p which uses an underlying \nemulator of type -r. Technically, (~) Adapt (a). p is a derived form which stands for Obj (a). (p &#38; \n{emulator : -r})8. In a judgment Z F ~ ~ r , the type # must always be of the form (~) Adapt (a). p, \nunless T and # are distinct vari\u00adables and -r ~ T is an assumption in Z. We also make the natural assumption \nthat the type T of the emulator is independent from the type Obj (a). p it is emulating. In other words, \nT does not contain free occurrences of a. Adaptability Rules Now consider the inference of adaptability. \nIntuitively, we would like to prove a single relationship such as 2 i-LibString p String s StringAdapter \nat a time. If the relationship is part of a complex of many rela\u00adtionships, the others can be assumed \nas part of Z. Of course, the definition of the String interface has to be modified to include the emulator \nas we discussed above. To illustrate how we reach the formal rules, we use a version of the standard \nexample of points classes which is used frequently in foundational stud\u00adies of object-oriented type systems. \nSuppose we have retrieved a reusable class LibPoint as a likely candi\u00addate to satisfy the requirements \nfor an application class Point. The two interfaces are represented by the fol\u00adlowing equations: 1 Point \n= Obj(P) .{1oc: int, name:String, eq: P+ bool, move: int + P} LibPoint = Obj(LP) .{1OC: int, name:LibString, \nc: color, eq: LP-) bool, move: int + LPl 7In informal discussion,we often omit the coercion/adapter \naspectof thesejudgments when convenient. 6Obj (a). p &#38; {emulator : -r} would be wrong since self \n+ emulator is meaningful. Although LibPoint is not a subtype of Point, and it turns out that the type \nLibPoint can be adapted to implement Point by emulation, i.e., LibPoint ~ Point assuming that LibString \n~ String. Formally, if we clmnge the definition of Point to show its emulator type: Point = (LibPolnt \n) Adapt (P). iloc: int, name: String, eq: P4bool, move: int-+P } then we would like to infer {LibString \nG String* StringAdapter] ~ LibPoint G Point =$-PointAdapter  Actually, we would like an algorithm which, \ngiven the definitions of Point and LibPoint, will both prove the relationship and synthesize the required \nPoint Adapt er as a witness. For now, we supply the definition of PointAdapt er to be used in the proof \n(using untyped notation): PointEmulator P = P + emulator PointConvert LP = { 10C = (Lp+ 10C), name = \nStringAdapter (LP -4= name) , eq = (Lp + eq) . pointErmlator, move = PointAdapter (LP ~ move) } PointAdapt \ner LP = (PointConvert LP) with emulator= LP It is essential that the class Point is defined by adapta\u00adtion \nof LibPoint, which means that every Point object is emulated by a LibPoint object. Given that each new \nLibPoint object will have the same default color value, the eq (equality) and move functions will work \nas expected for Point. The main rule for adaptability of object types is ex\u00adactly analogous to the main \nrule for subtyping with recursive types [AC91]. The latter, written using our notation, is: Given the \nrestrictions on the form of emulated types, the adaptability version of the rule must reach the conclusion \nZ 1-T ~ (T) Adapt (a2 ). p2 rather than D 1-Obj(al). pl ~Obj (a2). p2, where 7-= Obj(al). pl. Therefore, \nthe analogous adaptability rule (with coer\u00adcions) is: X h T ~ (T) Adapt (aZ). p2 + Y(XZ. Az. c z with \nemulator= z) Although the derived form (~) Adapt (az). p2 is short for Obj (4). (PZ &#38; {emulator \n: ~}), only the P2 part of the interface is being emulated by PI, therefore it is enough to show that \nPI < PZ. The coercions are also easy to ex\u00adplain. The variables al and cq represent the emulator and \nemulated types respectively. Therefore, the vari\u00adable z in the assumption al Paz * z represents the adapter \nneeded to convert an emulator object to the corresponding emulated object. In the points example, x would \nbe PointAdapter. The adapter name must be assumed since it is required in the function c which con\u00adverts \nthe body (of type pl ) of the emulator to the body (of type pz) of the emulated type. In the points exam\u00adple, \nc is Poi.ntConvert, and it uses PointAdapter in its definition. Finally, the actual adapter simply converts \nthe body of the emulator and then extends the resulting body of the emulated object with the label emulator \nto allow extraction of the emulator object. Thus, the actual adapter is the solution of the recursive \nequation where z corresponds to the parameter LP in the defin\u00adition of PointAdapter. Y is used again \nto obtain the solution. The rule above permits the conclusion {LibString ~ String+ StringAdapter} 1-LibPoint \nQ Point * PointAdapter based on the premise {LibString ~ String* StringAdapter, LP ~ P + PointAdapter} \n~ LibPointBody < PointBody + PointConvert where PointBody = {1OC: int, name: String, eq: P + bool, move: \nint + P} LibPointBody = {1OC: int, name: LibString, c: color, eq: LP + bool, move: int + LP} Since there \nare no clashes of method names or proto\u00adcols between the two record types, the only difficulty in proving \nthe required premise using the usual subtyping rules for function and record types is in the use of the \nassumptions LibString G String ~ StringAdapter and LP ~ P = PointAdapt er to infer subtyping rela\u00adtions \nbetween the types involved. Recall that adapt\u00adability implies two way convertibility, i.e., T ~ T imphes \nboth ~ < T and T ~ ~ . In fact, in this example, both these implications of LP ~ P are needed. For the \ncovari\u00adant relationship between G and <, the following rule is obvious: since c needs to convert between \nthe same types for both relationships. For the coercion needed for the con\u00adtravariant relationship, we \nmust rely on the assumption that an emulated type is always a record type which includes the label emulator. \nWe therefore use the rule It is perfectly appropriate to use thk rule with type variables since these \nvariables either represent object types in the environment (e.g., LibString ~ String), or are recursion \nvariables representing object types in\u00advolved in the current proof (e.g., LP G P). In both cases the \nemulated types must have the required structure. It is easy to check that these two rules together with \nthe standard subtyping rules for record and function types allow us to prove the required premise. Due \nto the restrictions on the structure of T in a re\u00adlationship ~ G T , adaptability is clearly neither \nreflexive nor transitive in the formal sense9. The three rules for G given above therefore formalize \nadaptability, given a suitable formalization of subtyping. Subtyping Rules Subtyping rules in the context \nof adaptability are in\u00adtuitively similar to the standard rules includlng the rules for recursive types \nstudied by Amadio and CardeWl [AC91]. One new technical problem is independence from method names and \nprotocols. A similar problem has been solved using equational laws in the context of using types as search \nkeys in function libraries [Rlt91]. In our context it is possible to solve it in a much sim\u00adpler way \nwith a straightforward change in the subtyping rule for record types. Since we care only about match\u00ading \nmethod types but not method names, we could use the rule: ~+{~1 :Tl,. ... Uk :Tk, Uk+l :Tk+l,. ... U~+m \n:Tk+m} <{bl:T{, . . .. b~. T~} ~k. {bl=cl (Z+al),. ... bk=ck (Z~Uk)} in which the correspondence between \nlabels has been eliminated. Clearly, this rule is not deterministic in the sense of being uniquely applicable \nas a Horn clause. The conclusion of the rule could match a sequent to be proved in many ways, corresponding \nto all possible permutations of the methods, and in general several of the nondeterministic choices may \nlead to success in the overall proof of adaptability whenever there is an amb\u00adiguity at the level of \ntypes about whkh method in the 9Although it is obviously both reflexive and transitive at the practical \nlevel where interfaces without emulator extensions are compared. reusable class is to be used to emulate \none of the meth\u00ad ods specified for the required class. Such ambiguities clearly require user intervention \nfor their resolution. In an interactive environment where the user decides a pri\u00adori which reusable method \nwill emulate each required one, the rule can be applied deterministically at much lower cost. All of \nthese considerations also apply to achieving or\u00adder independence for method parameters. The parame\u00adt \ner list can obviously be seen as a labeled record instead of a tuple, except that a function with extra \nparamet\u00aders is more general since extra parameters can be eliminated by using default values (possibly \nwith help from the user). Generality for labeled records works the other way (a record type with fewer \nlabels is more general), hence we extend the language of types with the new notion of parameter record \ntypes denoted by [1, : T,,...,lk : ~k] (with the corresponding notation [l~=e~,..., zk = ek] for expressions) \nand the rule ~~~l~T~~cl,...,~>T~~T~ ~ck ~F[al:Tl,... ,ak:Tk]< [bl :T~,..., bk :Tj, bk+~ :Tj+l..., bk+m \nT~+m]m] + kc. [bl = c1 (z~ al),..., b~ = c~ (z eak), bk+l = dk+l, . . . ,bk+m = dk+m] where dk+l, . . \n. , dk+m are default values  The subtyping rules for recursive types themselves carry over unchanged \nfrom [AC91] the complete set of rules for adaptability and subtyping is given in Appen\u00addix A. Due to \nthe presence of nondeterministic subtyping rules for record types, our inference rules obviously can\u00adnot \nbe coherent in the sense of allowing unique con\u00adversions for subtyping and adaptability relations be\u00adtween \nspecific types. In the absence of the nondeter\u00adminism, the uniqueness of coercions carries over in a \nstraightforward way from [AC91] (The absence of a transitivity rule for ~ helps). An Al~orithm Amadio \nand Cardelli point out that the main problem in both the rules and the algorithm for subtyping with recursive \ntypes is to account for a sufficiently general notion of equality. The basic subtyping rule for recur\u00adsive \ntypes (called (Obj< ) above) does not account for subtyping via equivale~ce. For instance, it does not \nallow us to infer that pal.int + (int + al) < pa~.int + (int + (int + a~)) even though the two types \nare equivalent. The rule for equivalence can be expressed somewhat informally as T = C[T] T = C[T ] if \nC is a contractile context r= f which expresses the idea that if two types are fixed\u00ad points of the \nsame contractile function (expressed by the cent ext ) then they must be the same types since contractile \nfunctions in complete metric spaces have unique fixedpoints, and recursive types constitute such a space \n(see [AC91] for details). Unfortunately, unlike (Obj< ), the equality rule can\u00adnot be used in a syntax-dlre;ted \nway (like a Prolog clause) in subtyping proofs. Amadio and Cardelli have worked out an ingenious way \nto avoid this problem. Their idea is to transform all recursive types into so\u00adcalled regular systems \nof equations in canonical form that represent an encoding of recursive types in a spe\u00adcial map from type \nvariables to their (recursive) unfold\u00adings. For inst ante the types pal. int + (int -+ al) and pcr2.int \n+ (int + (int + cr2) ) would be represented by the (recursive) equations C12 = int +a4 (21= int +a3 c14 \n= int -+a5 a3 = int+al a5 = int+az which correspond to a data structure representation with circular \npointers (each type variable occurs at most once on the left-hand side and corresponds to a memory cell \n). It turns out that this represent a\u00adtion elegantly captures equivalence relations that can\u00adnot be captured \ndirectly by the usual subtyping rule for recursive types. Another interesting aspect of the Amadio-Cardelli \nsystem is that their subtyping algo\u00adrii$hm is given in the form of a set of deterministic syntax-directed \ninference rules that are meant to be used like a Prolog program. For instance, the follow\u00ading set of \nrules constitutes such an algorithm for re\u00adcursive function types (assuming some atomic types oc\u00adcur \nas free variables). We have assumed that all recur\u00adsive types are encoded in a regular system of equations \nwhich is represented by a function E that maps the type variable on the left-hand side of each equation \nto the corresponding right hand side. Eu{a<p}, cba<fl The subtyping judgments treat the encoding E of \nrecur\u00adsive types as an additional assumption . The rule for a < ~ when a, ~ are in the domain of E is \nthe new rule for recursive types (where the variables are the roots of their respective regular type \ntrees). The algorithm for inference of adaptability is rela\u00adtively easy to derive by extending the Amadio-Cardelli \nalgorithm for subtyping with recursive types. The main extension is to reformulate the new rules for \nadaptabil\u00adity given above. The full adaptability inference algo\u00adrithm is given in Appendix B. The only \npotential source of difficulty in preserving the properties of the original algorithm is the nondeterministic \nnature of the record subtyping rules. Note that these rules are nonrecursive and there is only a finite \nnumber of possible matches. The nondeterministic rules therefore do not destroy the crucial termination \nproperty of the rest of the rules, although they do add to the cost of the algorithm sub\u00adstantially. \nRethinking Equality Amadio and Cardelli consider (sound and complete) equality and subtyping rules relative \nto a semantics based on regular trees, where the underlying structure is a partial order on trees. Their \nrules for equality can therefore be independent from their rules for subtyp\u00ading. In particular, there \nis no need to infer a = @given a < ~ and ~ < a. In the context of adaptability, in contrast, it is common \nto have pairs of constraints of the form a < /3 and ~ < a that can be satisfied even when both variables \nare not bound to the same tree. Such equivalence relationships ought to allow us to conclude that, for \ninst ante (using the usual notation for recursive types), However, this is not possible using the Amadio-Cardelli \ntyping rules. Interestingly, their algorithm does allow this conclusion. This does not detract from its \nsound\u00adness, which applies only to closed types. To overcome this problem, we need to change equality \nrules to equiv\u00adalence rules that denote mutual convertibility rather than identity. For instance, the \nbasic rule for convert\u00adibility and the congruence rule for record types might be expressed as: fz 7 2 \nk. rl(Z) withk.fl(%-~) Unlike the equality rules in [AC91], these rules need an environment Z of subtyping \nand adaptability as\u00adsumptions , and are obviously not independent from rules for the latter relations. \nThe main problem in for\u00admalizing this extended notion of equality is to find a properly justified generalization \nfor the critical rule for equality in contractile cent exts. This remains an open problem for the moment. \nAs noted above, the generahzation is not a problem for the subtype inference algorithm -the natural gener\u00adalization \nof the Amadio-Cardelli algorithm already ac\u00adcounts for mutual convertibility. An Example with Extended \nEquality To show that the problem outlined above in the dis\u00adcussion on the new form of equality rules \nis real and not a contrived pathological situation, we con\u00adsider a simple example involving mutually \nrecursive classes10. Although uncommon in simple examples, mutual recursion among interfaces is common \nin com\u00adplex frameworks for instance between the Window and Canvas classes, and between the Sensor and \nInteract or classes in the InterViews framework for graphical user interfaces [LVC89]. Consider the two \nli\u00adbrary classes class LibWindow { void mapToCanvas (LibCenvas* ) ; LibWindow* makeSubWindow(Li.bCenvas* \ninterior) ; }; class LibCanvas { LibWindow* mergeInterior(LibCanvas*) ; 3; which are to be used to emulate \nclass Window { Window* subWindow (Canvas* interior) ; }; class Canvas { Window* mergelnterior (Canvas*) \n; }; The corresponding interfaces can be expressed by 10 Mutually ~ecur~ive classes also make for interesting \nand in\u00adtricate examples of adaptability without the extension. LibWindow = Obj(LW). { mapToCenvas: LibCenvas+ \nvoid, ~tT<T +C. mekeSubWindow: LibCenvas+LW } LibCanvas = Obj(LC) .{mergeInterior:LC +LibWindow} Window \n= Obj(W).{ subWindow:Canvas+W ] Canvas = Obj(C).{mergeInterior:C+ Window} Wewould liketo conclude that \n@k LibWindowcWindow ~ WindowAdapter with no additional adaptability assumption about the Canvas classes \nsince these are essentially the same given thatLibWindow andWindowwill bemutuallycon\u00advertible. Thlsisexactly \nanalogous tothe situation men\u00adtioned above which the Amadio-Cardelli rules areun\u00adable to handle. The \nadaptability inference algorithm of Appendix B allows the required inference. In fact, WindowAdapter \nhas a straightforward definition: WindowEmulator W = WindowConvert LW = {subWindow = CanvasRevert C = \n{mergeInterior WindowAdapter LW = (WindowConvert CanvasConvert LC = 3mergeInterior W + emulator WindowAdapter \n (LW~mekeSubWindow)  CanvasRevertj  = CanvasRevert (C~mergeInterior)  WindowAdapter}  LW) with emulator=LW \n= CanvasConvert (LC-@mergeInterior) WindowEmulator] where CanvasConvert converts a LibCanvas object \nto aCanvas object andCanvasRevert goestheotherway. Neither conversion requires an adapter. Note that \nthe function CanvasConvert is required to implement Canvas, not in the definition of the WindowAdapter. \nThis simple example also illustrates the potential intri\u00adcacy of adapter synthesis for realistic libraries \nsuch as the Interviews library. Other Issues Thebasic subtyping rule forrecursive types (Obj<) (see above) \nhas an interesting consequence for situ-ations where ons of classes with inheritance relationships are \nbeing emulated, Given that emulator types do not con\u00ad ta.in free occurrences of the corresponding recurgive \ntype variables (i. e., self types), an interesting and straight\u00adforward consequence of this rule is the \nderived rule Xu{a<a +x}kp<p +cp Z 1-(T) Adapt (a). p < (T ) Adapt (a ). p +Y(Az. A(e with enmlator= o). \n(CP e) with emulator= CT o) whkh follows by applying Obj< to the derived forms (~) Adapt (a). pand (#) \nAdapt[cJ). p . Leaving coer\u00adcions aside, this is equivalent to XI-T<T X F Obj (a). p < Obj (cx ). p X \n1-(T) Adapt (a). p < (T ) Adapt (a ). p In other words, if two application interfaces Obj (a). p and \nObj(a ). p are related by subtyping, and they are implemented byadapting reusable types Tand# which arealso \nrelatedly subtyping inthe same way, then the resulting adapter-based types remain subtypes as well., \nThis is important in realistic situations where entire application frameworks, or substantial parts thereof, \nare implemented by adaptation, The frameworks often consist of classes with many inheritance relationships \namong them, which must be maintained even if they are implemented by adaptation. The rule above says \nthat so long as the subtype relationships among the emula\u00adtors are parallel to those among the application \ntypes, the adapter-based versions of the application types will retain their original relationships. \nMore precisely, con\u00adsider a closed set {Obj (al). T1, . . ., Obj (an). r~} of ob\u00adject types from the \napplication world which are ex\u00adpected to be implemented by adaptation using reusable object types T], \n. . . , T:, respectively. By a closed set I mean that no type used in the interface of any Obj (ai ). \nTi is implemented by adaptation unless it also belongs to the set. If T; < T; whenever Obj (ai). Ti < \nObj (aj ). Tj, then by the derived rule above we will have (T;) Adapt (ai). Ti < (T;) Adapt (aj ). Tj \nwhenever Obj(a~),T~ ~ Obj (aj). Tj. Note that (7) Adapt (a). p is in general technically independent \nfrom Obj (a). p in the subtype hierarchy (it is neither a subtype nor a supertype) although the only \ndifference between the two types is the presence of the emulator method in the former. However, if application \ncode has been written using a type def\u00adinition T = Obj (a). p then that code will continue to typecheck \nwhen the old definition is replaced by T = (T) Adapt (a). p if subtyping among object types is identified \nwith the relationships produced by inheri\u00adtance, which is common practice (e.g., in C++, Elffel, Trellis/Owl), \n, class Printable { public: virtual void print(ostreamk) = 0; }; template<claes a, class b> class Map \n: public Printable { public: void update(a,b); b lookup(a); Map merge(Map&#38;); void print(ostream% \no=cout) < rep.print(o); } private: struct Pair : public Printable { a index; b value; // no vay to say \na, b must be Printable void print(oetreamk o) { index.print(o); value.print(o); } int operator==(Pair&#38; \np) { index = p.index; } 3; List<Pair> rep; }; Figure 1: A Library Class: Map 3 Extending Adaptability \nto Generic Classes Clearly, areusable class very often needs to bec~s\u00adtomizable. A common and powerful \nway to adleve this is to make the class generic. In this section we dis\u00adcuss the extension of adaptability \ninference to generic classes. We assume that the actual type parameters used to instantiate a generic \nreusable class are supplied bytheuser. Aclassrequiredfor anapplication mayalso be generic, but it obviously \nis not instantiated since it must be emulatedin full generality. Its type parameters can be treated as \nnew type constants in adaptability inference 1, and it can therefore be treated formally as a nongenetic \nclass. In attempting to extend the ideas of theprecedlng sections to generic classes, the first problem \nwe need to solve is to find a suitable formal representation for the types of generic interfaces. Generic \nclasses are co\u00advariant type constructors that are represented byquan\u00adtified types. Consider for instance \nthe generic class Map given in Figure 1. The type parameters a and b of Map are not free. The way they \nare used in the implementation ~tructure Pair implies that the oper\u00adation print : ostream + void is defined \non all ob\u00adjectsoftypes aandb, and== : a + intis definedon all objects of type a. In representing such \nconstraints on parameters one must choose among several options. Perhaps the most widely accepted method \nistouie F\u00ad 11 some ~on~traint8 on these parameters maybe assumed> whi~ could be useful in validating \nthe instantiation of the reusable class used in the emulation. bounded polymorphic types [CCH+89] which \nconstrain parameters to be subtypes of a (possibly recursive) up\u00adper bound type. Recursive bounds mayarise \nfrom the fact that the assumptions for a parameter may them\u00adselves involve the parameter. For instance \nthe type of required operation =for a objects itself involves a. An F-bound for a might therefore be \ngiven as a < F(a) where F(a) = {==: a+int}. This constraint only says that an actual parameter a must \nsupport the given operation, with a type that involve a itself. This is suf\u00adficient for type safety and \nis also the way most actual languages (such as C++) check for valid instantiation. Note that such a parameter \nwould not necessarily be a subtype of the recursive type pa. {== : a -+ int3 and so an F-bound is weaker \n(less restrictive) than using a recursive type in an ordinary bound. The main observation we need to \nmake is that while the actual type parameters (which will often be taken from the application domain) \nmust provide operations that are functionally adequate to cover the requirements expressed in the bounds, \nthere is no reason to assume that they must also match the required protocols ex\u00adactly. Consider for \ninstance the interface for a required class Table in Figure 2. It seems likely that the in\u00ad stance Map<Point, \ni.nt> of Map can emulate Table 12. Although Point does not support a== operator, it does support an equivalent \nfunction called eq which can be used to emulate it. Moreover, subtyping and inheri\u00adtance are often identified \nin practical languages, and an inheritance relationship between an actual parame\u00ad 12 A8su~i~~ that point \nis extended to supPOrt ~ OutPut operation. class Table { public: void change (int, Point&#38;); int \nfind(Point&#38;); void output (ostream&#38;); } Figure2: Specification of a Required Class: Table tertypesuch \nas Point and an abstract bound suchas pa. {== : a+int} is clearly impossible. This suggests that the \nbounds should be expressed as adaptability rather than subtyping bounds. Technically, if a parameter \nhas an adaptability bound T, the corresponding constraint cannot be ex\u00adpressed as b G r. First of all \nbecause ~ will not have the required form (b) Adapt (a). p. More importantly, the possibility that the \nactual parameter used in place of b will in fact be a subtype of ~ cannot be excluded. It is therefore \nconvenient to use a new relation ~ defined aa follows ZI-T<T *C El-T< T *c Z 1-~p(~)Adapt(a). p + c \nZ1-TSObj(a). p~c An interesting side-effect of the decision to use adaptability bounds is that in practice \nit eliminates the need for F-bounds given the proof-theoretic sim\u00adilarity of adaptability and sub classing, \nthe use of F\u00adbounds would not add any useful power over using recursive types in ordinary bounds. In \nmost cases, it is easy to show that given an actual parameter T where the formal parameter a must satisfy \nthe F\u00adbound a < l (a), the constraint T < F(r) is equiva\u00adlent to ~ ~ (~) Adapt (a). F(a), which in turn \nimplies T ~ Obj (a). ~(cr). For instance, consider a para\u00admeter T = Obj (b) . {f: b + b, other: c + c] \nsubject to an F-bound defined by F(a) = {f: a + al. Clearly, T < Obj (a) .F(a), but T < F(T), and therefore \nT satis\u00adfies the F-bound expressed by a < F(a). In this typi\u00adcal case where T is an object type, and \nF(a) is a record type which captures the operations that need to be sup\u00adported by parameter a, the relation \nT<F (T) expresses the constraint that the body of T (say, T ) must sup\u00adport all the operations in F(a) \nassuming that the pa\u00adrameter a is replaced by the recursive type T. The key observation is that in T \n> the recursive type T is actually represented by the recursion variable b, whkh reduces the constraint \nto T <F (b). In the example used above, this becomes {f :b+-b, other:c+c> 5 <f: b-+ b>, whkh is obviously \ntrue. Equivalently, the same con\u00adstraint could be expressed as T <F ( a) assuming that a=b, i. e,, a \n< b and b < a simultaneously. But note that the assumption b ~ a is equivalent to assuming that a < b \nand b < a simultaneously. Therefore T<F (T) is equivalent to T ~ (T) Adapt (a) .F(a). Finally, multiple \nbounds on a single parameter can be reduced to a single bound consisting of their inter\u00adsection (denoted \nby the A operator). With these con\u00adsiderations we can give a complete interface type for Map13: Map = \nForall< a < {print : ostream -) void} A Obj(cz) .{== : a-+ imt} , b ~ {print : oetream + void}> update \n: [lnd:a, val:bl + void, lookup : [ind: a] + b, merge : [addon: Map<a,b>] + Map<a,b>, print : [out: ostream] \n+ void } Note that due to the constraints on the two para\u00admeters of Map, adapting Map<Point, int> to \nemulate Table actually involves three adaptability proofs (and adapters) one each for the two parameters \nand one for map itself. Moreover, int ~ {print : ost ream -+ void} cannot be proved automatically and \nuser interven\u00adtion will be required to allow emulation of print by operator<<. This problem occurs not \nonly for primit\u00adive types but also for user-defined classes in C++ since operator<< cannot be defined \nas a member and must be a friend for syntactic reasons. The problem is just a reminder that we can only \naim for computer aided rather than fully automatic adaptability inference in practice. Once the instantiation \nof Map is validated, the proof of Map<Point, int > ~ Table is straightforward. So far we have assumed \nthat the instantiation of generic classes will be suggested by the user. It is conceivable that we could \ninfer possible instantiations of generic parameters by gathering the constraints on them. There will \nin general be multiple upper and lower bounds on a given parameter, whose solution will re\u00adquire at least \nsome form of intersection types, which can be reahzed through multiple inheritance if the individ\u00adual \nupper bounds are classes. Unfortunately, due to the nondeterminism of the inference algorithm of Section \n2, a very large number of mostly bizarre possibilities are likely to be offered to the user in practice. \nFor instance, one way to emulate Table with Map is to instantiate a 13Depend@ on the language, representing \nParaIUeter con\u00adstraints could be tricky, e.g.,if, like C++, the languageallows dual interpretations of \noverloadedoperators. We do not address suchidiosyncrasiesof specific.languagesin this paper. by the intersection \nof the types int and string and b by a type that can emulate both int and String. Such advice is more \nlikely to be resented than appreciated. Perhaps some heuristics can be developed to rank the possibilities \nfor instantiation by reasonableness , but this remains to be investigated. Related Work We are not aware \nof any previous work on auto\u00admated compatibility checking and adapter synthesis for reusable classes. \nThe closest analogy is with the work on using nonrecursive polymorphic types to search func\u00adtion libraries. \nTyped functional languages commonly support sufficiently sophisticated types to make it fea\u00adsible to \nuse types as keys in searching function libraries. Just as in the case of our nondeterrninistic adaptability \nrelations, the match between the required and available types does not have to be exact; there are several \nfunc\u00adtionality preserving interface transformations that can be used to effect a match. Rlttri [Rit91] \nhas shown the feasibility of using (one-sided) unification in an equa\u00adtional theory to deduce equivalent \nforms of a type used as a search key. Runciman and Toyn [RT89] have performed empirical studies for a \nsimilar scheme which also includes a generality order on types they report encouraging results for both \nrecall and precision. It is of course widely recognized that software com\u00adponent integration often requires \nadaptation of inter\u00adfaces (among other things) via glue code . There are many examples of integration \napproaches based on sep\u00adarate manually synthesized glue components. Pintado and Junod [PJ92] describe \na design idea for facilitati\u00adng reuse which they call gluons . They discuss ap\u00adplications of gluons in \nan environment of active (con\u00adcurrent ) and possibly distributed objects that may be connected in client-server \nrelationships dynamically. A similar model is described by Konstantas [Kon92] where each distributed \ncomponent consists of a nucleus that communicates with the outside world through a mem\u00adbrane (a kind \nof ORB) and the entire system has a multicellular structure. An interesting aspect of membranes is that \nthey contain interface type man\u00adagers that negotiate type compatibility with foreign membranes. This \nappears to call for adapter genera\u00ad tion techniques of the kind I propose, A related no\u00adtion of mediators \nis described in {SN90]. The relation\u00adship of our approach with SOM [IBM92] and CORBA [OMG92] is mentioned \nin the introduction. 5 Conclusions and Directions for Future Work We have described a new formal notion \nof adaptability and an algorithm for adaptability inference that allow us to decide at the level of interface \ntypes whether a reusable class can be used to fulfill the requirements for a class required for an application \nwithout insisting on an exact interface match. We have shown that the idea can be applied to both generic \nand nongenetic classes so long as the instantiation of the generic reusable class is specified by the \nuser. Many issues relating to adapt\u00adability have yet to be addressed properly. An impor\u00adtant theoretical \nissue is the extension to frameworks which can be thought of as collections of classes re\u00adlated by subtyping \nand/or inheritance. The existing logic ensures that the application classes can be related by any structural \nsubtyping relation consistent with the subtyping relations among the reusable classes used to implement \nthem. However, there are many unresolved semantic issues. Another important problem is the coercion of \nobject and data representations to accommodate internal dif\u00adferences between components. This is a multifaceted \nproblem with many existing approaches. An excel\u00adlent survey of the current state of the art is given \nby Wdeden, et al [WWRT91]. Most current systems sup\u00adport what one might call data structure isomorphism \n(DSI) which is used in data transport among compo\u00adnents based on different platforms (languages, proces\u00adsors, \noperating systems). The typical solution is to de\u00adfine a universal data type definition notation (e.g., \nIDL [OMG92] or XDR [Sun90]) along with language bind\u00adings to translate data to and from the standard \nformat. Data transformations necessary for transport can then be automated typical RPC stub generation \ntechniques already automate such transformations during trans\u00adport for distributed client-server interactions \n[Sun90]. The main shortcoming of DSI is its lack of support for bridging the differences between alternative \nrepresenta\u00adtions of abstract types, such as the polar and cartesian representations of points in a plane. \nWe need abstract type isomorphism (ATI) to fully support data mobility in a heterogeneous environment \nwhen data formats dif\u00adfer in more than platform-specific idiosyncrasies. I am interested in exploring \nan approach where user knowl\u00adedge about the equivalence of various representations can be expressed declaratively \nin the form of equa\u00adtional laws (seen as bisections with two-way coercions) between representation types. \nThe problem of estab\u00adlishing equivalence between representation types then reduces to the word problem \nin algebraic theories for which there are well-established automated techniques based on canonical term-rewriting. \nThere are good re\u00ad search tools available to experiment with these tech\u00adniques [KZ88, GG91]. Inefficiencies \ndue to multistage transformations can be eliminated by using techniques such as deforestation [Wad88] \nif the transformations are themselves expressed declaratively using a functional language. Note that \nsuch transformations are of interest whether or not encapsulation of data-representation is important. \nFor a discussion of a closely related problem in the context of type reconstruction in functional lan\u00adguages, \nand the associated equationzd unification the\u00adory, see [Tha91, Tha93]. References [AC91] Roberto M. Amadio \nand Luca Cardelli. Sub\u00ad typing recursive types. In Proceedings of Eigh\u00ad teenth POPL Symposium, pages \n104 118. ACM Press, January 1991. [CCH+89] Peter Canning, William Cook, Walter Hill, Walter Olthoff, \nand John C. Mitchell. F\u00ad bounded polymorphism for object-oriented pro\u00ad gramming. In Proceedings of Fourth \nIn\u00ad ternational Conference on Functional Pro\u00ad gramming Languages and Computer Architec\u00ad ture (FPCA 89), \nLondon, U.K. ACM Press, Addison-Wesley, 1989. [CW85] Luca Cardelli and Peter Wegner. On under\u00ad standing \ntypes, data abstraction and polymor\u00ad phism. Computing Surveys, 17(4), 1985. [DDRS89] David Duke, Roger \nDuke, Gordon Rose, and Graeme Smith. Object-Z: an object oriented extension to Z. In Proceedings of FORTE89 \n-International Conference on Formal Descrip\u00ad tion Techniques, Vancouver, December 1989. North Holland. \n[GG91] Stephen J. Garland and John V. Guttag. A guide to LP, the Larch prover. Technical Re\u00ad port 82, \nDEC Systems Research Center, 1991. [GHW85] J.V. Guttag, J.V. Horning, and J.M. Wing. The Larch family \nof specification languages, IEEE Software, 2(5), 1985. [IBM92] IBM Corporation. 0S/2 2.o technical library \nsystem object model guide and reference. IBM Document S1OG63O9, 1992. [Kon92] Dimitri Konstant as. The \nimplementation of the Hybrid cell. In D. Tsicluitzis, edi\u00ad tor, Object Frameworks. Centre Universitaire \nd Informatique, Universit6 de Genbve, 1992. [KZ88] D. Kapur and H. Zhang. RRL: A rewrite rule laboratory. \nIn Proceedings of 9th Conference on Automated Deduction (CA DE-9), Argonne, Illinois, USA. Springer-Verlag, \n1988. LNCS 310. [LVC89] [OMG92] [PJ92] [PL92] [Rit91] [RT89] [SN90] [sun90] [Tha91] [Tha93] [Wad88] \n[WWRT91] Mark A. Linton, John M. Vlissides, and Paul R. Calder. Composing user interfaces with Inter-Views. \nComputer, 22(2), 1989. Object Management Group. The common ob\u00adject request broker: Architecture and specifi\u00adcation. \nOMG Document 91.12.1 Revision 1.1, 1992. Xavier Pintado and Betty Junod. Gluons: sup\u00adport for software \ncomponent cooperation. In D. Tsichritzis, editor, Object Frameworks. Cen\u00adtre Universitaire d Informatique, \nUniversit6 de Genkwe, 1992. Nico Plat and Peter Germ Larsen. An overview of the 1S0 VDM-SL standard. \nSIGPLAN No\u00adtices, 27(8), August 1992. M. R,ittri. Using types as search keys in func\u00adtion libraries. \nJournal of Functional Program\u00adming, l(l) :71-89, 1991. (Earlier version in Func. Prog. Lang. and Comp. \nArch. 1989, ACM Press.). C. Runciman and I. Toyn. Retrieving reusable soft ware components by polymorphic \ntype. In Proceedings of Fourth International Confer\u00adence on Functional Programming Languages and Computer \nArchitecture (FPCA 89), Lon\u00addon, U.K. ACM Press, Addison-Wesley, 1989. Kevin Sullivan and David Notkin. \nReconcil\u00ad ing environment integration and component independence. In Proceedings of ACM SIG-SOFT 90: \nFourth symposium on software de\u00advelopment environments (SDE~), pages 22 33. ACM Press, 1990. Sun Microsystems. \nNetwork programming guide. Part Number: 800-3850-10, 1990. Satish R. Thatt&#38; Coercive type isomorphism. \nIn Proceedings of the Fifth Conference on Func\u00adtional Programming Languages and Computer Architecture \n(FPCA 91), pages 2949. ACM Press, 1991. Satish R. Thatt&#38; Finite acyclic theories are unit ary. Journal \nof Symbolic Computation, 15(2), February 1993. Philip Wadler. Deforestation: Transforming programs to \neliminate trees. In Proceedings of Second European Symposium on Programming. Springer-Verlag, 1988. LNCS \n300. Jack c. Wlleden, Alexander L. Wolf, Wllliarn R. Rosenblatt, and Peri L. Tarr. Specification-level \ninteroperabil\u00ad i$;y~9;~nicatio?ss of the ACM, 34(5) :72 87, 185 A Adaptability Inference Rules The \nequivalence relation ( > ) used in the first rule reflects the extension discussed in Section 2 in place \nof the standard equality relation % [AC91] (augmented with obvious extensions for record types). The \nnew relation is expect ed to be quite similar to the standard one, but, as discussed in the body of the \npaper, its formalization is not yet completely understood. B The Adaptability Inference Algorithm The \nalgorithm below is an adaptation of the subtype inference algorithm in [AC91]. The rules are meant to \nbe used as a backward-chaining Prolog-like program. Unlike the algorithm in [AC91], some of the rules \nbelow are not deterministic. However, the nondeterministic rules are nonrecursive and there is only a \nfinite number of possible matches. These rules therefore do not destroy the termination property of the \nrest of the rules. In an interactive environment where the user decides a priori which reusable method \nwill emulate each required one, the rules can be applied deterministically at much lower cost. Note that \nthe nondeterministic rules are usually inappropriate for structural subtyping within the reusable-component \nor application domains, but we do not attempt to formalize that distinction (it can be easily enforced \nby a practical implementation). The environment # used in the sequents below is an encoding of the recursive \ntypes that maps type variables to their unfoldings. al, 04 e Dom(s) T = Obj (CYI). E(cq) ~U{CYI~C12 +X}, \nehe(CXI) <E(@)+C Xl, e b T ~ (T) Adapt (cz2). e(a2) + Y(kc. Az. c z with emulator= z) ~,&#38;~Tl<T;+Cl,...,~,ChTk< \nTj*Ck ~,&#38;* [al: Tl,... ,U~:Tk]<[bl :T{, . . .. b~. T~, b~+l :T~+l. ... bk+m:Tj+m] +Az.[bl =cl(xeal),... \n?b.4!= ck (~-ak)>bk+l ~k+l, . ..> bk+rn = dk+m] where dk+l, . . . , dk+m are default values \n\t\t\t", "proc_id": "174675", "abstract": "<p>The need to fit together reusable components and system designs in spite of differences in protocol and representation choices occurs often in object-oriented software construction. It is therefore necessary to use <italic>adapters</italic> to achieve an exact fit between the available &#8220;socket&#8221; for a reusable part and the actual part. In this paper we discuss an approach to the construction of tools that <italic>largely automate</italic> the synthesis of adapter code. Such tools are important in reducing the effort involved in reuse since adapter synthesis can be challenging and error-prone in the complex type environment of an object-oriented language. Our approach is applicable to statically typed languages like C++ and Eiffel, and is based on a formal notion of <italic>adaptability</italic> which is related to but distinct from both subtyping and inheritance.</p>", "authors": [{"name": "Satish R. Thatt&#233;", "author_profile_id": "81100465788", "affiliation": "Clarkson Univ., Potsdam, NY", "person_id": "PP31099279", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/174675.177850", "year": "1994", "article_id": "177850", "conference": "POPL", "title": "Automated synthesis of interface adapters for reusable classes", "url": "http://dl.acm.org/citation.cfm?id=177850"}