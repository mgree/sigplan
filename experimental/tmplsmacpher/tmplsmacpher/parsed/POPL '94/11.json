{"article_publication_date": "02-01-1994", "fulltext": "\n A type system for prototyping languages* Dinesh Katiyar David Luckham John Mitchell t {kat iyar, luckharn \n,mitchell}t?cs. stanf ord. edu Stanford University California, USA Abstract RAPIDE is a programming language \nframework designed for the development of large, concurrent, real-time systems by prototyping. The framework \nconsists of a type language and default executable, specification and architecture languages, along with \nassociated programming tools. We describe the main features of the type language, its intended use in \na protot yping environment, and rationale for selected design decisions. Introduction RAPIDE is a programming \nlanguage framework with an as\u00adsociated toolset. The framework consists of a set of lan\u00adguages, while \nthe toolset provides related program develop\u00adment and diagnostic tools. The framework includes a type \nlanguage, a default executable language, a default specifi\u00adcation language, and an architectwe language. \nAlthough these languages together provide a complete programming language, RAPIDE is intended to accommodate \nadditional implementation and specification languages, besides the de\u00adfault ones provided by the framework. \nThe constant of the framework is the type language, which is intended to be gen\u00aderal enough to allow \nthe types of relevant implementation languages to be expressed within it. In a sense, the type system \nprovides a minimal lZngu a f m n ca for assembling or experimenting with multi-language systems. The \narchitec\u00adture language collects together those features of the type and executable languages that are \ntypically used in defining the interfaces of system components and the datailow connec\u00adtions bet ween \nthem. This document gives an overview of the RAPIDE type system and describes some of the motivation \nand rationale for the design. Full language reference man\u00ad This research was supported by DARPA under \nONR contract NOO014-92-J-1928 and by the Air Force Office of Sclentltic Research under Grant AFOSR-91-0354 \nAlso supported by an NSF PYI Awardj with matching funds from AT&#38;T, Digital Equipment Corporation \nand the Powell Foundation, NSF Grant CCR-9303099 and the Wallace F. and Lucille M Davis Faculty Scholarship \n Permission to copy without fee ell or pert of this material is granted provided that the copies are \nnot made or distributed for direct commercial edventege, the ACM copyright notice and the title of the \npublication and its dete appoer, and notice is given that cop~ng ia by permission of the Association \nfor Computing Machinery. To copy otherwise, or to republieh, requires e fee artd/or specific permission. \nPOPL 94-IN, Portland Oregon, USA @ 1994 ACM 0-69791-636-0/94/001 ..$3.50 uals for the type, executable, \nspecification and architecture languages are available separately. The central construct of the RAPIDE \ntype system is the in\u00ad ter~ace type. An interface type lists the visible types and objects of a set of \nmodules. While the word module may suggest a static grouping of related declarations, the word is used \nto refer to any aggregation of objects, functions, types, or other definable program entities. In the \ndefault executable language, for example, modules ser~ e as both compile-time groupings of related types \nand operations, re\u00adsembling Ada packages [US 80], for example, and as run\u00adtime objects of the form found \nin C++ [ES90] and other object-oriented languages. A central, unifying idea is that all types in RAPIDE \nare expressible using interface types and function types. In addition to interface types, the main concepts \nof the RAPIDE type system are several forms of parameterization, interface derivation mechanisms, and \nthe use of subtyping. Parameterization may be used to define a family of related types, depending on \neither type parameters or value (such as integer) parameters. A type parameter in an interface or function \ndeclaration may be constrained by requiring it to be a subtype of some given type. The derivation mecha\u00adnisms \nof the type language allow interfaces to be combined and reused; they are essentially a form of inheritance \nmech\u00adanism appropriate for defining related interfaces. Besides its unified view of type, the RAPfDE \ntype system has several novel and interesting features. (i) It separates types of components from their \nmodule implementations. This is a direct consequence of the framework having separate types and executable \nlanguages. (ii) The subtyping hier\u00adarchy is independent of the inheritance mechanisms and is purely structural \n it can be inferred by examining the types. (iii) Subtyping constraints can be imposed on type param\u00adeters \nof functions and interfaces, giving rise to a very useful and powerful form of polymorphism. Similar \nconstraints can be imposed on t ype constituents in interfaces, allowing par\u00ad tially abstract types. \n(iv) Type constituents in interfaces can also be specified completely, giving RAPIDE the expres\u00adsiveness \nof languages such as Standard ML [MTH90] while still allowing modules to be first-class. (v) The derivation \nmechanisms of the language can be applied to parametenzed interfaces as well. Section 2 summarizes general \nconcepts and design decisions in the RAPIDE framework and Section 3 gives an overview of the type system. \nSection 4 describes how the prede\u00adfine types of the RAPIDE framework are defined as inter\u00adface types, \nand summarizes the semantics associated with action and reference types. Section 5 describes extensions \nto interfaces that enhance their expressiveness. Section 6 illustrates the type system through larger \nexamples. Ap\u00adpendix A briefly summarizes the underlying calculus that is chosen as the medium for theoretical \nstudies of the RAPIDE type system. Current Status: Over the past four years, the RAPIDE design has been \ntested, modified and evaluated in a variety of ways. An early 1 0.2\u00b0 implementation, based on a translation \nto Ada, was com\u00adpleted in 1991. Since then, severaf programming tools have been implement ed, including \na graphical interface to allow component interfaces and connections to be defined easily, a graphical \nbrowser to facilitate navigating through module hierarchies and to check subtype relationships and a \nsep\u00adarate tool to inspect the partially-ordered set of events in several ways. This allowed experimentation \nwith the con\u00adcurrent aspects of the language and some evaluation of the program-structuring mechanisms. \nSeveral large systems, in\u00adcluding the ADAGE avionics system [T C93], the X-open distributed transaction \nprocessing architecture [Ken93], a trusted X-windows definition, as well as many small ones, have been \nexpressed in the RAPIDE type system. The diag\u00adnostic information provided by the tools significantly \ncon\u00adtributed to the refinement of the framework design, includ\u00ading the type system. The second generation \nlanguage and tool implementations, now welf underway, are being done in c++. 2 Prototyping in RAPIDE \n2.1 Rapid prototyping The primary goal of RAPIDE is to support rapid construction of prototypes of large \nconcurrent and distributed real-time systems. Prototyping is the incremental development of systems by \nan iterative design and development process. In a typical project, partial system components, called \nprototype com\u00adponents, are built. These are analyzed separately and com\u00adbined into a sgstem prototype, \nwhich is analyzed to deter\u00admine the adequacy of the design, to refine the specifications of the components, \nand to estimate system performance. The analysis of a prototype provides useful feedback for subsequent \nrevision and refinement of the system design or of individual components. Prototyping is often an experi\u00admental \nactivity. Alternate system designs can be evaluated by building prototypes for each and analyzing and \ncompar\u00ading them. This allows crucial design decisions to be made as early in the design process as possible. \nAn advantage for software development under contract is that the pur\u00adchaser may obtain early information \nabout the functionality of the system before committing to full-scale development of production-quality \ncode. A prototyping framework must (i) provide the capability to confitruct large components easily, \noften by reusing or adapt\u00ading exist ing components, (ii) provide tools to perform quick and meaningful \nanalyses of the execution of protot ypes, and (iii) support easy revision and refinement of prototypes. \n 2.2 The languages of the RAPIDE framework The RAPIDE language framework consists of a type language \nto define the interfaces of components, a spec@aticm lan\u00adguage to specify and constrain the behavior \nof components, and an executable language to construct modules that im\u00adplement system components. The \npattern language is used by the executable and specification languages to character\u00adize the execution \nof RAPIDE programs. The architecture ianguage provides features for easily wiring up prototype components \n-i. e,, for detining explicitly the (possibly dy\u00adnamic) communication links bet ween modules. Some languages \nof the RAPIDE framework are better un\u00adderstood in the context of the computational model associ\u00adated \nwith the default executable language. Computations are viewed as partially ordered sets of events (posets). \nThe synchronization, concurrency, and timing aspects of a pro\u00adtotype are explicitly represented in such \ncomputations. Re\u00adquirements on computations can be specified formally as constraints on these posets, \nand violations of these can be detected automatically. This model is described in greater detail in [LVB+93]. \nThe standard languages of the framework are summarized below. The type language: This language provides \nconstructs for defining the interfaces of components and for deriving new interfaces from prior ones. \nIt also provides typ\u00ading rules which are checked automatically to safeguard against common mistakes that \narise while using such a language. The notion of subtyping adds flexibility to these conformance rules. \nThe executable language: The executable language is a concurrent reactive programming language in which \none defies the executable behavior of components. Its principle constructs are independent (or concur\u00adrent) \nreactive processes that activate when patterns of events occur during execution. The executable lan\u00adguage \nalso provides standard kinds of Algol control structures, subprograms, exception raising and han\u00addling \nconstructs, and timing feat ures. The result of executing a RAPIDE program is a set of events with various \npartial orderings (such as time and causality) relating the events. This is referred to as the poset \nexecution model. The specification language: This language provides con\u00adstructs for abstract specification \nof the behavior of a distributed system, including timing requirements. It is based on the poset execution \nmodel. The constraint\u00adbased specification language supplies a rich set of con\u00adstructs for defining patterns \nof events that should or should not occur in any computation of a distributed system. It is also designed \nso that straightforward al\u00adgorithms can be used to check any actual execution of a prototype for violations \nof pattern constraints. The pattern language: This sublanguage of the default specification and executable \nlanguages provides a con\u00advenient notation for characterizing posets. This ca\u00ad pability is used in the \nspecification language to im\u00ad pose constraints on event-based behaviors, andin the executable language \nto generate, detect and react to certain patterns of events. It is used by the architec\u00ad ture language \nto define communication between com\u00ad ponents. The architecture language: This language provides ba\u00adsic \nmechanisms to wire together system components by defining the connections between them. Archit ec\u00adtures \nare sets of component interfaces and connections. Connections allow components to synchronize and to \ncommunicate data. The need for this language is mo\u00adtivated by the prototyping of large distributed real\u00adtime \nsystems, where the early stages of prototyping concentrate on system architecture. The separate ar\u00adchitecture \nlanguage allows the prototyping process to be started without the full knowledge of the rest of the framework. \nThe RAPIDE toolset provides several design and diagnostic tools to aid program development and refinement. \nThe ar\u00ad chitecture language has a graphical interface to allow compo\u00ad nent interfaces and connections \nto be defined easily. Graph\u00ad ical browsers facilitate navigating through module hierar\u00ad chies. A separate \ntool allows inspection of the output of simulations (z. e. partially-ordered set of events) in several \nuseful ways. Constraint checkers detect violations of con\u00ad straints during execution of RAPIDE programs. \n 2.3 Interaction between the languages The languages of the framework must satisfy certain com\u00ad patibility \nrequirements and conventions. These constraints are of different kinds: Certain restrictions apply globally. \nThe languages of the framework must share certain visibility, scoping and naming rules. (These are just \nthe rules of block\u00adstructured, statically-stop ed languages. ) The type system imposes syntactic and \nsemantic re\u00adstrictions on any executable or specification language used within the framework. The synt \nattic constraints essentially guarantee that the grammars of the frame\u00adwork languages can be combined \nto form an unambigu\u00adous context-free grammar. The semantic conditions ensure that the operations provided \nby the executable language behave in a manner that is, loosely speaking, consistent with respect to the \ntype system. The specification and executable languages may im\u00adpose additional constraints on each other, \nindependent of the types language. For instance, in the default set of languages, the executable language \nuses a compu\u00adtation model based on partially ordered sets of events. In this context, a specification \nlanguage is most usefuf if it can meaningfully refer to partially-ordered compu\u00adtations. This is achieved \nin the default executable and specification languages by sharing a pattern language for defining and \nrecognizing partially-ordered patterns of events. A formal study of these interactions is a subject \nof current research. 3 Main concepts of the RAPIDE type system RAPIDE has a strong static typing discipline. \nThe key no\u00adtions associated with the type system are interface types (Section 3.1), two reuse mechanisms \n-parameterization (Sec\u00ad tion 3.2) and derivations (Section 3.3), and the subtyping discipline (Section \n3.4). Other details of the type system are discussed in Section 4.  3.1 Interface types An inter-face \nis defined by a list of declarations. These may be declarations of object names (where an object is either \na module or function) or types. A declaration of an object name associates a type with the name, but \ndoes not give an implementation. A type declaration in an interface may give only a type name, a type \nname with a subtype designation, or a complete type declaration. A type name only declares a hidden private \ntype, while a complete type declaration results in a public type, to use Ada terminology. When a subtype \ndesignation is used, the result is a form of partially hidden type. Overall, an interface is similar \nin spirit to an Ada package specification (except that packages are not types in Ada) [US 80], the signature \npart of a C++ class [ES90], or a Standard ML signature [MTH90] (except that Standard ML modules are only \ncompile-time entities, and cannot be used as run-time values). The objects of an interface type are modules \ncent aining type and object constituents mat thing the declarations listed in the interface. (We use \nthe term constituent for components of a module to avoid contlict with the term component for component \nof a system or architectme. ) All object con\u00adstit uents must have the type indicated in the interface. \nA type constituent may be (z) any type when the interface contains only a type name declaration, (ii) \nany subtype of the type given in the interface, if a subtype designation is used, or (iii) must be exactly \nthe type given explicitly in the interface. The interface of a module governs access to its constituents. \nThe constituents that correspond to declarations in its in\u00adterface are visible, which means that they \nmay be referred to outside the module. If a module declares identifiers that do not occur in the module \ninterface, then these are hidden, t. e., not accessible from outside. In the case of visible type constituents, \nthe subtype or type equality information given in the interface determines whether the type constituent \nwilf be considered a subtype of or equal to any other type in the program. This is discussed briefly \nbelow and addressed in more detail in Section 3.4. Example: A Point interface type Point is interface \nX_Val : Integer; Y=Val : Integer; Distance : function(P: Point) return Integer; end interface; 140 \nf : function(x:T) return T; The interface type Point contains three name declarations. Mod\u00adules of type \nPoint must have two integer constituents, called X_Val and Y_Val, and a function constituent called Distance. \nA function computing the distance between two points requires only one argument, since the function belongs \nto a particular point and therefore may compute the distance between the point passed as an actual parameter \nand the particular point to which the function belongs. In other words, the intended use of the Distance \nfunction constituent ofapoint object xis to compute the distance betweenx and another point object y, \nby a call of the form x. Distance(y). Ofcourse, since theinterface gives oniy signature information, \nthe Distance constituent is not forced to compute the distance between two points. If the user wishes \nto specify that Distance must compute distance, this maybe added to theinterface using thespecification \nsublanguage. n As mentioned briefly above, a type declaration in an inter\u00adface may be (i) a declaration \nof a type name only, (ii) a type declared to be a subtype of some designated type, or (iii) a type specified \nexactly by declaring that a type name is equal to some type. This three-level flexibility allows rel\u00adatively \nfine control (in the interface) over the information that will be exported from modules. Type name declarations \nare used for complete information hkling, as with traditional abstract data types. Example: A Stack package \ntype Int_Stack_Package is interface type Stack; New: functiono return Stack; Push: function (X: Integer, \nS : Stack) return Stack; Pop: functions: Stack) return Stack; Top: functions: Stack) return Integer; \nend interface; This interface illustrates the traditional abstract data type style. An object of Int_Stack_Package \nmust have a type constituent Stack and the function constituents listed above. It is intended that these \nconstituents provide the standard operations on stacks. Since only the type name, Stack, is given in \nthe interface, the type constituent of an object of type Int_Stack_Package will be hidden. More specifically, \noutside a module Stack_Impl of type Int_Stack_Package, the type Stack_Impl. Stack will not be recognized \nas equal to or a subtype of any other type in the program. Using Ada terminology, the type Stack will \nbe a private type of any Int_Stack_Package module, o Full type declarations permit the type-checking \nof incremen\u00ad tal definitions of related types, as in the style developed for Standard ML [Mac86, Tof89]. \n(The relationship between Standard ML type constituents, which are considered pub\u00adlic by default, and \nfull type declarations in interfaces is discussed in [HL94, Ler94].) Example: Extending the functionality \nof abstract types type T_Package is interface type T; end interface: type Ext_T_Package(t :T_Package) \nis interface type T is t.T; g : function(x:T ) return T ; end interface; The type T_Package defines an \nabstract type and a function on that type. Given an instance t of this package, one can define values \nof type t.T and apply the function t.f to them. Now suppose we wish to extend the functionality of the \nT~ackage type with another function g such that the new function can be applied to instances of the old \npackage type. This can be done as shown above using a full type declaration. For each imple\u00admental ion \nof T_Package, Ext_T_Package defines an interface with a type constituent that is equal to that of the \nparticular T_Package. (Note that one couldn t define Ext_T_Package us\u00ading the interface derivation mechanisms \nof Section 3.3, since that would result in a new independent abstract type.) u Subtype designations provide \nan intermediate level of infor\u00admation hiding that allows certain operations on the type to be revealed. \nWhen a type constituent of an interface is not declared fully in the interface, that type may only have \nsubtypes if another type in the same interface is declared a subtype or equal to it. Such non-subt ypeable \ntypes are discussed in more detail in Section 3.4. In addition to name declarations, an interface may \nalso con\u00adtain specifications. These are constraints on the behavior of the executable objects, and are \nwritten in the specification language. The purpose of specifications in interfaces is to document the \nintended semantics of modules formally and more precisely than can be achieved by types alone e.g. in\u00adput/output \nconstraints on parameter values of operations or restrictions on the order in which the operations can \noccur. The examples in Section 6 illustrate some uses of specifica\u00adtions. Executions can be checked for \nviolations of specifica\u00adtions by an automated checker at runtime. In all of the examples given in this \nsection, all interface dec\u00adlarations are pubiic. In general, a RAPIDE interface may also declare names \nas private or erternal. These are described in Section 5. Interface types have been used to write the \ninterfaces for all the predefine types supported by the executable language of the framework (details \nin [RPr] ). These include several types with interesting semantics such as action and reference types \n(Section 4.1). The exercise of specifying these prede\u00adfine types as interfaces has illustrated the expressiveness \nand flexibility of the type system. 3.2 Type constructors It is useful to define functions that work \nuniformly over many types of objects for instance, a quicksort routine that works for all types whose \nobjects can be compared with each other. Similarly, one often needs to define in\u00adterfaces uniformly for \nvarious types consider writing stack packages for integers, for reals, for strings, and so on. This \nmay be done in Ada using generics, or in C++ with tem\u00adplates. RAPLDE has a similar capability that is \nmore flexible in two ways. The fist is that type parameters need not be known at compile time. The second \nis that type parameters may be constrained to be subtypes of given types. Subtyp\u00ading constraints involving \ntype constructors provide a very flexible and useful form of polymorphism. This technique is illustrated \nin Section 3.4. A generic set interface uses a type parameter as the type of elements of the set. Example: \nA Set package type SetType(type Elem) is interface Insert : function(E: Elem); Delete : function(E: Elem); \nUnion : functions: SetType(Elem)); Is_Member: function (E: Elem) return Boolean; end interface; The above \ndeclaration defines a type constructor. When applied to a particular type T, this gives an interface \ntype SetType(T). Each object of type SetType(T) will have the four function con\u00adstituents listed above. \nThe type of each function constituent may be computed by substituting for Elem in the declaration above. \nFor example, if S has type SetType(T), then the type of S. Insert is function (E: T), meaning that S. \nInsert is a function that re\u00adquires an actual parameter of type T and returns no result. The intended \nuse of this type constructor is to give the general form of set type, where each module implements a \nsingle set in the usual object-oriented way. u  3.3 Reuse and Interface derivation mechanisms RAPIDE \nderivation mechanisms provide a flexible form of reuse. The purpose of a derivation (or inheritance) \nmech\u00adanism is to allow a declaration made in one place for one pqose to be used in another place for \na similar, related, or perhaps even different purpose. In RAPIDE, interface deriva\u00adtion declarations \ndefine textual dependencies between inter\u00adfaces. Any change to an interface imposes similar changes to \nall interfaces derived from it. This is an important feature for rapid prototyping since it simplifies \nprogram modifica\u00adtion and maintenance by reducing the amount of redundant or repeated code, but it must \nbe used carefully to avoid une-xpected changes. In contrast with Smalltalk [GR83], C++ and other object\u00adoriented \nlanguages, RAPIDE has dktinct inheritance mecha\u00adnisms for interfaces and implement ations. This has proven \nvery useful, for the general reason that interface and imple\u00admentation inheritance are often used independently \nand/or in opposite ways. For inst ante, one would want to define the interface for double-ended queues \nby extending that for simple queues, whereas the latter can be easily implemented from the former [Sny86]. \nSimilarly, the Smalltalk library shows several cases of conflict between the implementation hierarchy \nand a reasonable interface hierarchy [CO092]. Essentially, A declaration include A inside an interface \ntype B has the effect of inserting all the declarations of A into B. Since this requires knowing the \ninterface A com\u00adpletely, the type expression that is included must denote an interface type that can \nbe determined completely at com\u00adpile time. A simple example is the derivation of the interface for col\u00adored \npoints from the Point interface given in Section 3.1. Example: Deriv~ng Colored Point from Point type \nColored_ Point is interface include Point; Col: functiono return Color; end interface;; Colored points \nare derived from points using an include decla\u00adration. The result is that the Colored_ Point interface \nhas four function constituents, X_Val, Y_Val, Distance and Col. D It is often useful to be able to include \nonly a part of a pre\u00adviously declared interface. RAPIDE provides the following forms of derivations for \nthis purpose include t ype_expression only identifier_list include t ype_expression except identifier_list \nwhich include only the listed constituents, or include all con\u00adstituents except those listed (respectively). \nUnlike other languages that allow a single entity to be de\u00adrived from more than one other (i. e., multiple \ninheritance), RAPIDE does not have any standard or default rules for re\u00adsolving conflicts. One reason \nis that such rules are generally complicated, and unpredictable in certain cases. Moreover, it is anticipated \nthat the RAPIDE type system will be used in conjunction with multiple executable languages, and these \nmay each have their own conflict resolution rules for mod\u00adules. However, RAPIDE makes it possible to \navoid conflicts by renaming included constituents. For instance, one can write include A only x,y rename \nx to new_x, y to new~ It is often useful to include constituents of an interface that is defined using \na type constructor. By applying a type constructor to the interface that is being defined, one may specialize \nthe types of included constituents. This, in fact, gives RAPIDE the power to program so-called mixins \n(in the terminology of CLOS [Kee89]) without requiring a separate concept. This is illustrate in the \nfollowing example, which adds equality to points. Example: Potnts with Equaltty type Equality (type T) \nis interface function Eq(X : T) return Boolean; end interface; type Eq_Point is interface include Point; \n The simplest form of derivation declaration is include Equality (Eq_Point ); include type_expression \nend interface; type Eq_Point_Elab is interface function X_Val return Integer; function Y_Val return Integer; \nfunction Eq(X: E~Point_Elab) return Boolean; end interface: The type constructor Equality (type T) returns \nan interface with one function constituent. The type of this constituent contains the formal type parameter \nT, and therefore will depend on the actual parameter of the type constructor. Interface Eq_Point in\u00ad \n cludes the constituents of Point and Equality (Eq_Point ). Since Equality is applied to the actual type \nparameter Eq_Point, the resulting Eq function constituent has type function (X : Eq_Point) return Boolean \n obtained by replacing the formal parameter T with the actual parameter Eq_Point. Therefore, the Eq function \nconstituent of an Eq_Point object accepts another Eq_Point as an argument. The interface Eq_Point is \nequivalent to Eq_Point_Elab, which is written directly without any derivation declarations. !3 Another \nuse for type constructors in derivation declarations arises when specializing recursively-defined interfaces. \nIn languages without derivations, interface definitions can sim\u00adply use the name of the interface being \ndefined to make recursive interface definitions. However, when one permits these definitions to be reused \nin defining new interfaces, one would like the recursive occurrences of the interface name to now refer \nto the new interface being defined. Hence, such languages typically provide a separate keyword for these \nref\u00aderences for example, Eiffel [Mey92] uses the term like crm\u00ad rerst . In RAPIDE, however, we can use \ntype constructors to overcome the need for a new feature. More specifically, in\u00adstead of writing type \nT is interface . . . like current...; one would write type TGen(type t) is interface ,..t...; type T \nis TGen(T); Derivations are then done using the constmctor TGen in\u00adstead of T. Since RAPIDE has no special \ntype symbol like current, there is no need for special typing rules of the form found in Eiffel, for \nexample, or the concomitant typing diffi\u00adculties (see [C O089] ). The constructor TGen is also useful \nfor imposing subtype constraints, as described in Section 3.4. There is an important restriction on the \nuse of derivation declarations. In RAPIDE, types may be formal parameters to functions and other constructs. \nHowever, as mentioned earlier, derivation must be resolved at compile time. There\u00adfore, formal parameters \nmay not be used in derivation dec\u00ad larations. For instance, type TGen(type t) is interface include Foo(t); \n... end interface; is considered illegal. If a type name T is used in a derivation declaration, then \nthe interface named by T must be determined at compile time. 3.4 Subtyping and subtype constraints The \nfundamental relation between RAPJDE types is the sub\u00adtype relation. The constraint that A is a subtype \nof B is written as lA <: B . The main principle associated with subt yping is substitutiuity if A is \na subtype of B, then any expression of type A may be used without type error in any cent ext that requires \nan expression of type B. The primary motivation for subtyping in a prototyping lan\u00adguage is to allow \nfunctionality to be added to a prototype with minimal modification to the system. This is widely ap\u00adpreciated \nin the object-oriented programming community. In short, if objects of some type B have some behavior \nwhich crudely approximates part of the system being prototype, then it may be desirable to replace objects \nof type B with objects of another type A that have more realistic or accu\u00adrate behavior. In many cases, \nthe type A will be a subtype of B. By designing the language so that substitutivit y is allowed, one \nmay add functionality in this way without any modification to the original program. An example illustrating \nthe use of subtyping is in prototyp\u00ading an airport scheduling system. In an early prototype, one would \ndefine an interface airplane with constituents such as position and orientation and accelerate that would \nallow a control tower module to affect the approach of an airplane. In a later prototype, it is likely \nthat different types of air\u00adplanes would be used. If one adds interfaces for Boeing 757 s and Beechcrafts, \nthese would be subtypes of airplane, con\u00adtaining extra constituents reflecting features specific to these \naircraft. By virtue of this subt yping relation, all Beechcrafts are now instances of airplanes and all \nof the general con\u00adtrol algorithms that apply to all airplanes could be used for Beechcrafts without \nmodification or recompilation. Another advantage of subtyping is uniform operation over various types \nof data, regardless of whether these types are added incrementally. In particular, subtyping makes it \npos\u00adsible to have heterogeneous data structures containing ob\u00adjects that belong to different subtypes \nof some type. For example, one could have a queue containing airplane mod\u00adules, each belonging to different \nsubtypes of airplane. This is generally not possible in strongly typed languages without subt yping. \nRAPIDE provides rules for determining, by compile-time anal\u00adysis of the structure of the types, if one \ntype is a subtype of another. RAPIDE chooses this implicit structural approach over two other prevalent \ntrends (i) determining the sub\u00adtype relationships directly from the derivation hierarchy, and (ii) requiring \nalf subtype relationships to be explicitly stat ed. This is done for the following reasons: The subtyping-from-inheritance \napproach either com\u00adpromises the substitutivity principle or places strong restrictions on the derivation \nmechanisms [CHC90]. It afso causes the subtyping relationship to be greatly af\u00adfected by the order in \nwhich the program components are written. The explicit subtyping approach is rather cumbersome, since \nmany obvious relationships would have to be made explicit. Also, it is hard to fit a new type into an \nexisting hierarchy. This approach does avoid the problem of accidental subtyping (caused when one type \nis determined to be a subtype of a completely unrelated type simply because they happen to have similar \nstructures). However, accidents do not seem to be troublesome enough to warrant the added respon\u00adsibility \non the programmer. Some circumstantial evi\u00addence for this is provided in the work of [Rit91, RT91], where \nit is shown that types can be used to search for functions in libraries, generating very few accidental \n(hits The RAPIDE approach makes it easier to reorganize code and to combine independently constructed \nsub\u00adprograms. There is no need to change or introduce any subtyping relationships -they are all automatically \nde\u00adtermined from the program text. subtyping problem is fairly crucial to the Process of t ype-chec~ng-&#38;d \nis the topic-of recent resear~h [Pie92, KS92, Kat92, GP94]. 3.4.1 Subtyping and type parameters The following \nexamples illustrate the flexible style of poly\u00admorphism support ed by subtype constraints. The examples \nshow a general pattern that may be applied in several situa\u00adtions. The main idea is to identify the required \noperations on objects of the type parameter and formulate its constraint accordingly the interface containing \nexactly these opera\u00adtions is used as a subtype bound on the type parameter. In the simple case where \nthe type of the required operations does not depend on the type parameter, one can use a sim\u00adple interface \ntype as in the fist example. If the type of a required operation does depend on the type parameter, then \na type constructor is used in the subtype bound instead, as illustrated in the second example. Example: \nPrintable Objects type Printable_ Object is interface Print : functiono return String; end interface: \nDisplay : function(type T<: Printable_ Object, X: T) return ... ; This example shows how one might write \na general function Display that displays objects on a screen, Given an object, such a func\u00adtion must \nsomehow determine an appropriate representation of it that is printable. For this, it must invoke some \noperation on the objects passed to it. For simplicity, assume that each object to be displayed has a \nPrint constituent that returns a string represen\u00adtation of the object. Then one would like to explicitly \nstate this restriction that each actual parameter must have a Print con\u00adstituent. This constraint on \nactual parameters is expressed by constraining the type of objects that can be passed to Display. One \nfirst defines a type Printable_ Object as above. The param\u00adeters passed to Display are now restricted \nto be of a type that is a subtype of Print able_ Object. The definition of subt yping guarantees that \nif T is a subtype of Printable_ Object (written T <: Printable_,Object ), then every X : T will have \na func\u00adtion constituent Print returning a string. m u Example: Generic Sorting Naive_Sort : function(type \nT; compare : function (X,Y: T) return Boolean; L: List(T)) return List(T); type Ordered(type T) is interface \ncompare : function (X: T) return Boolean; end interface; Sort : function (type T<: Ordered(T); L: List(T)) \nreturn List(T) This example illustrates the use of type constructors in subtype constraints. It is required \nto sort a list of elements of some type. The elements of any such type have some ordering relation on \nthem. A simple solution would be to define a function that takes both the list of elements as well as \nthe ordering relation as arguments, and returns the sorted list. This is the Naive_Sort function type \ndefined above. However, in a language where objects may carry a comparison operation as one of their \nfunction constituents, it is possible to write the sort function such that the comparison operation does \nnot have to be passed as an argument. To do this, one must make sure the actual type parameter is a type \nwhose objects have a compare function constituent. But the type of compare is not the same for all types \nof ordered objects. For this reason, one needs to use the type constructor Ordered whose type param\u00adeter \nappears in the type of compare. For any type T, the in\u00adterface Ordered(T) will have a comparison function \ncompare of the type function (X : T) return Boolean. Consequently, if Y, Z : T, then Y.compare(Z) determines \nwhether Y is less than Z. One then defines the Sort function using Ordered(T) as the bound for the type \nargument T. o  3.4.2 Subtyping and type constituents of modules When a type in an interface is declared \nas a type name only, the corresponding type constituent of any module is highly abstract, in the sense \nthat outside the module, this type is not equal to nor related by subtyping to any other type in the \nprogram. Such non-subt ypeable types have an important pragmatic consequence. An implementation of such \na type can assume that all objects of that type will be represented in exactly the same way, and therefore \ncan implement the operations of the object more efficiently. Consider, for example, an interface definition \nof the prede\u00adfine type for integers. If integers are defined as an explicit interface, the integer operations \nhave to be implemented as interface calls to module constituent functions. While this allows a event_id:integer; \nuser to define his or her own integers and have them work event_name:string; interchangeably with the \npredeiined integers, it does result precedes:funct ion (E: Time_Stamped_Event ) in an inefficient implementation \nof integers. If the integer return boolean; type were declared in the manner specified above, then its \nend interface; implementation could assume that all integers will be rep-new_event:function( Name: string) \nresented in the same way, and could use stzmdard machine return Time_ Stamped_Event is operations to \nimplement the integer operations efficiently. module event_id:integer = System. Clocko; However, there \nis a slight inconvenience with such abstract event_name:string = Name; types by virtue of their not having \nany supertypes either. precedes: function (E: Time_Stamped_Event) Since nothing is known about their \nrepresentation, objects return boolean = of such types cannot be used in any context but of the oper\u00ad \nreturn(event_id < E.event_id); ations on the abstract type. The use of subtype constraints end module; \n on type constituents provides a useful compromise. In this end module; case, the types are only partially \nhidden, since some infor\u00admation about the operations on the type is specified in the This example illustrates \nhow non-subtypable types can lead to subtype designation. This makes the type non-subtypeable, more efficient \nimplementations. Event_Impl is an implemen\u00adwhile still allowing supert ypes, and hence permitting its \nuse tation of Event_ Spec. As explained earlier, one cannot define in contexts that are satisfied with \nthe partial information subtypes of Event_ Impl.Time_Stamp ed_Event. This allows about the type. This \nis illustrated in the following example: Event_Impl to assume that the argument E of the precedes function \nhas the same unique internal representation for events. Example: Partially hidden clock type Therefore, \nthe precedes function can access the internal repre\u00adsentation of its argument in this case, this is \ndone through the type Clock_Spec is interface event_rep constituent. type Clock <: interface 1 tick: \nfunctiono; read: functiono return integer; Non-subtypeable types are analogous to the sealed classes \nend interface; of Dylan [App92]. new_clock : functiono return Clock; end interface; 4 Interfaces for \nspecific types This example shows how to specify some constituents, without giving an explicit type definition. \nThe interface declares a type 4.1 Predefine types Clock together with a function new_clock that returns \na new clock. If Clock_Impl is a module with interface Clock_Spec, then Clock_Impl. Clock is a type that \nis known to be a sub-The predejined types and predejined type constructors of RAPIDE type of the interface \ngiven explicitly above. Therefore, if C is are described in [RPr]. These types include integers, booleans, \nan object of type Clock_ Impl. Clock, we can call function con-strings, arrays, records, and other common \ntypes of Pascal\u00adstituents C.ticko and C.reado, the first returning no value and like languages. They \nare presented in a separate document, the second returning an integer. Since the type Clock is not rather \nthan as a basic part of the type language, because given explicitly in the interface, one cannot define \na type that is these are all particular examples of interface types. More\u00ada subtype of Clock_ Impl. Clock. \nTherefore, the only elements over, different executable languages will require different sets of type \nClock_ Impl. Clock will be those produced by calls to of predefine types, and specific application domains \nmay Clock_ Impl.new_clock. merit specialized types. Therefore, the predefine type def\u00adu initions are \npresented as a type preamble, expressible in the core type language, rather than as an essential, fixed \npart of the language itself. The preamble also defines the spe- Example: Time-stamped events cial syntax \nfor predefine types. It also makes use of spec\u00adifications to define the normal semantics of objects of \nthe type Event=Spec is interface predeflned types. type T1me_Stamped_Event <: interface Sections 4.2 \nand 4.3 describe two of the more interesting pre\u00adevent_name: st ring; define types that are provided \nwith the default executable language. return boolean; end interface; new_event:function( Name: string) \nret urn Time_Stamped_Event; end interface; precedes: funct ion(E:Time_Stamped_Event ) module Event_Implo \nreturn Event_Spec is type Time_ Stamped_ Event = 4.2 Action types 5 Private and external interfaces \nActions provide a mechanism for asynchronous communi\u00adcation between components. Communication takes place \nthrough entities called events. An event can be thought of as a tuple of objects. An action name declares \na type of events and two associated operations generate and read. An action call generates an event \n-the contents of the tuple are the parameters to the call, plus other information about the caller, the \ncurrent time, etc. Events aredetected by pat\u00ad terns. Patterns can be used to match sets of events. The \npattern matching process relies oncalls to the readoperation on events. As mentioned above, an action \ndeclaration corresponds to two operations on the corresponding event type. However, there is a slight \nsubtlety in this, depending on where the action declaration is located. o If an action name is declared \nin the public interface, this is taken to indicate that events of that type may be generated either by \nthe component itself or its con\u00adtaining module, but these may be read only by the component itself. This \nmeans that a public action is essentially declaring a public generate operation and a hidden read operation. \n An action declaration in the private interface behaves similarly, except that it is visible to modules \nof the same interface type.  An action appearing as an external constituent de\u00adclares a public read \nand a hidden gen emt e operation. In other words, events of the corresponding type can be generated only \nby the component itself but can be read by the containing module also.   4.3 Variables and reference \ntypes It becomes hard to provide type safety when objects may change state while executing concurrently. \nThis is apparent in Ada, where task types are limited private types that do not have an assignment operation \nor an equality test this leads to two kinds of types, normal types and limited types. The RAPIDE types \nlanguage permits the executable language of the framework to distinguish between variables and con\u00adstants \nof the same type. A simple, uniform view of variables that works for all types of objects (including \nmodules with changing states and multiple threads) is that a variable de\u00adnotes a reference to an object. \nSo when a variable is changed by assignment, the variable refers to a different object. Giv\u00ad ing variables \na different type from constants also meshes well with the subtyping since the operations possible on \na variable are different from those on a constant. There is a predeiined type constructor called reference. \nFor each type A, ref(A) is the type of references to objects of A. RAPIDE references are identical to \nML references [MT91, MTH90, Pau91], and are almost the same as pointers of Pascal and related languages, \nexcept for the difference in testing for reference or pointer equality. In Section 3.1, it was said that \ninterface types consist of a list of declarations. This was a slightly simplified view of interfaces. \nThe constituents mentioned there are part of what is called the public interface. Constituents of the \npublic interface are visible to the entire system. Interfaces can contain two other subparts -a private \ninterface and an external interface. 5.1 Private interfaces The private interface contains a list of \ndeclarations similar to that in a public interface. However, these constituents are visible only within \nmodules of this interface type, The need for this arises from the difficulty in implementing bi\u00adnary \noperations in the ob j ect-onent ed style of programming. Usually implementing a binary operation efficiently \nrequires some information about the representation of the two argu\u00adments. However, in the object-oriented \nstyle, binary opera\u00adtions only have access to the internals of their first implicit argument; they can \nonly use the publicly available functions to look at the second. Private interfaces provide a means of \nleaking as many details of the internal representation as may be required, but only to objects of the \nsame type. This is made clear in the following example: Consider an interface for sets of int egers. \ntype IntegerSetType is interface Insert : function (N: Integer); Delete: function (N: Integer); Union: \nfunctions: IntegerSetType); Is_Member: function (N: Integer) return Boolean; end interface: Now consider \nhow one might implement the union function. The natural and efficient way of doing it requires the ability \nto iterate over the elements of the set passed as an argument. But the publicly available functions on \nsets don t provide an apparent way of doing this. The most realistic solution would be to add a new function \nin the interface which re\u00adturns a list of all the members of the set. However, this means making more \noperations public than required. Also, adding a new constituent during program development may require \nchanges in certain derived interfaces. Using the pri\u00advate interface. one can write: type IntegerSetType \nis interface public Insert : function (N: Integer); Delete : function (N: Integer); Union : functions: \nIntegerSetType); Is_Member: function (N: Integer) return Boolean; private List_ of_Members : functiono \nreturn Integer_List; end interface; Now, only other integer sets can invoke the List_of_Members functions. \nPrivate interfaces are similar in spirit to the C++ friend concept. 5.2 External interfaces Aninterface \nmay also have an external part which consists of a set of external declarations. This is a list of object \nnames with specified types that modules belonging to this interface can assume to be visible. The executable \nlanguage is expected to provide means of associating actual objects with these declarations. The use \nof external declarations is strongly motivated by the use of the RAPLOE type system to specify architectures \nand their connections. Consider the interface Timer that describes timing devices. A timer can provide \nvarious timing utilities as long as it has access to some clock. This may be specified by using the external \ndeclarations to require that a clock be made available to every instance of the type Timer. type Timer \nis interface public Start: functiono; Stop: functiono; Reset : functiono; Time_Elapsed : functiono return \nTime; extern Clk : Clock; end interface; 6 Illustrative examples 6.1 An example from the predefine type \nlibrary As a more comprehensive example, this section presents the interface definitions that lead to \nthe complete definition of the interfaces for the numeric types in the predelined types library. These \ndefinitions, in their full glory, would contain several constraints that are imposed on the type definitions. \nSince the reader may not be familiar with the specification language, these examples will use simple \nEnglish statements to describe the constraints wherever necessary. First, since equality and other ordering \nrelations are part of several predefied types, these are defined as separated interfaces, and included \nwherever they are needed. Note that the Boolean predefine type is being assumed in these examples. The \ninterface for the equality relations defines two functions -one for checking equality and the other for \ninequality. type Equality (type T) is interface = : function(X : T) return Boolean; con~~aint~nction(x \n: T) return Boolem; . reflexive, transitive and symmetric eguality and inequality are complementary \nend interface; The interface for ordering relations includes the equality op\u00aderations and then defines \nthe usual four comparison opera\u00adtors that one might expect. type Order(type T) is interface include Equality(T); \n<= : function(X : T) return Boolean; < : function(X : T) return Boolean; >: function(X : T) return Boolean; \n>= : function(X : T) return Boolean; constraints  r-efiexive, transitive and anti symmetric axioms \nfor the interdependencies between the operations end interface;  Using these interfaces, one now defines \nthe numeric types integers, naturals and positive integers. type Numeric_Pkg is interface type Integer-<: \ninterface include Order(Integer); Pred : functiono return Integer; Succ : functiono return Integer; + \n: functiono return Integer; : functiono return Integer; + : function(N : Integer) return Integer; : function(N \n: Integer) return Integer; * : function(N : Integer) return Integer; : function(N : Integer) return Integer; \n~: function(N : Integer) return Integer; % : function(N : Integer) return Integer Abs : functiono return \nInteger; Iszero : functiono return Boolean; IsPositive : functiono return Boolean; constraints an integer \nis greater than its pred and less that its succ pred and SZJCC are inverse operations axioms for the \nbehavior of zero with the various operators axioms for the interaction of succ/pred with the different \noperators end interface; MaxInt : Integer; MinInt : Integer; type Natural <: Integer constraints  all \nnaturals are greater than or equal to zero type Positive <: Integer constraints  all positives are greater \nthan zero end interface;  6.2 An architectures example This next example attempts to give a feel for \nthe kind of expressive interfaces that may be built using the RAPmE type system. It uses action types, \nwhich are described briefly in Section 4.2, and other architecture-language dependent keywords that will \nbe elaborated to the extent required to illustrate their use. The example describes how the interfaces \nof an automobile and a driver might be specified, and how the two could be hooked to get an operational \nvehicle. First, the interface for the controls of an automobile is de\u00adscribed. type AutoControls is interface \npublic Speedometer : functiono return MPH; Gas_ Gauge : functiono return Gallons; action Steering_ Wheel(A \n: Angle); action Accelerator(P : Position); act ion Brake(P : Pressure); extern action Warning_ Light \n(S : Status); ... end interface; The instruments Speedometer and Gas_ Gauge are specified as public functions, \nwhich, in effect, output their readings when asked. Controls such as Steering_ Wheel, Accelerator and \nBrake are specified as public actions. An AutoControls module can receive (and react to) events defined \nby these actions. The component that uses such a module must generate ex\u00adternal events containing position, \npressure or angle data. These external actions of a user should be connected by the containing architecture \nto the public actions so that the Auto controls component receives the data in its pub\u00adlic events. One \nway of doing this is mentioned later. Auto Controls assumes the presence of Warning_ Light as an action \nwhose events it can generate with appropriate status data. This allows AutoControls to send out warning \nevents; the assumption is that the containing architecture will do something useful with them. An automobile \ninterface can be defined using different subin\u00ad terfaces, including the one for the automobile controls. \ntype Automobile is interface public service Controls : AutoControls; service Do ors_and_ Windows : Auto \nPorts; ... end interface: Declaring Controls and Doors_ and_Windows as public ser\u00ad vices is a way of \nindicating that the constituents of these interface are /waiting to be hooked up externally through the \nconnection mechanisms of the architecture. For instance, the Aut oControls service of an Automobile can \nnow be connected, using a single declaration, to any other object whose interface contains AutoControls \naa an eztern service. Such an object would be capable of using the speedometer and gas gauge readings, \nand of generating events corresponding to changes in steering, acceleration, and braking. An automobile \ndriver, as one might anticipate, is one such object. The interface of an automobile driver would look \nas follows: type Driver is interface public include Person; Permit : Driving_ License; ... extern service \nDrivingSkills : AutoControls; ... end interface; Given the interfaces for automobiles and drivers, one \ncan define an architecture that takes an instance of each and connects them correctly as follows. architecture \nVehicle_Test is Dummy : Driver; TestCar : Automobile; connect Dummy. DrivingSkills to TestCar.Controls; \n... end architecture; The connection in Vehicle_Test is shorthand for a set of basic connections between \neach pair of constituents with the same name, one in the publtc service and the other in the external \nservice. So, for example, whenever Dummy calls its Speedometer function, the call is connected to the \npublic Speedometer function in Test Car. Similarly, when\u00adever the Dummy generates an ezterrzal SteeringWheel(angle) \nevent, Test Car will receive a public event with an identi\u00adcal tuple. When TestCar generates Warning_Light \nevents, Dummy will receive them as public warning light events. 7 Conclusions This document describes \nsome of the salient features of a type system designed for use in a prototyping environment. The design \nhas been based on recent and ongoing research in the theory of type systems as well as on implementation \nexperience. As mentioned earlier, any effective prototyping environment must provide the capability \nto construct large components easily, and must also support easy reuse and refinement of prototypes. \nRAPIDE S interface types provide a very conve\u00adnient language to define components. The different flavors \nof type constituents, the parameterization mechanisms cou\u00adpled with the subtyping constraints on type \nparameters, and the private and external interfaces add to the expressiveness of the types language. \nThe interface derivation mechanisms provide flexible means of reuse, while the inferred structural subtyping \ndiscipline permits code to be used for a prototype and its refinements. Acknowledgements: We are thankful \nto all the members of the RAPIDE project for continuing insightful comments and criticisms. References \n[App92] Apple dynamtc Computer language, Inc. Nov Dylan, 1992. an object-oriented [CHC90] William Cook, \nWalt Hill, and Peter heritance is not subtyping. In Proc. Symp. on Principles of Programming pages 125-135, \n1990. Canning. In\u00ad17-th ACM Languages, [CO089] W .R. Cook. A proposal safe. In European Conf. grammmg, \npages 57 72, for making Eiffel on Object-Oriented 1989. type-Pro\u00ad [CO092] W.R. Cook. Interfaces and specifications \nfor the Smalltalk-80 collection classes. In ACM Conf. Object-oriented Programming: Systems, Languages \nand Applications, pages 1-15, 1992. [ES90] M. Ellis Reference and B. Stroustrop. Manual. Addison- The \nAnnotated Wesley, 1990. C++ [GP94] Castagna Giuseppe and Benjamin Pierce. Decid\u00adable bounded quantification. \nIn Proc. 21-st ACM Symp. on Principles of Programming Languages, 1994. [GR83] A. Goldberg language and \nley, 1983. and its D. Robson. implementation. Smalltaik 80: Addison The Wes\u00ad [HL94] Robert Harper and \nMark Lillibridge. A type\u00adtheoretic approach to higher-order modules with sharing. In Proc. .21-st A CM \nSymp. on Principles of Programming Languages, 1994. [Kat92] Dinesh Katiyar. Subtyping F-bounded types. \nIn ANSA Workshop on F-bounded quantification, Cambrzdge, Sept 1992. Position paper. [Kee89] S.E. Keene. \nCommon Lisp. Object-oriented Addison-Wesley, programming 1989. in [Ken93] John. as a J. Kenney. Banking \nStanford University on X/Open. To Technical Report, appear 1993. [KS92] D. Katiyar quantification Workshop \nand S. Sankar. is decidable. on ML and its Completely In ACM Applications, bounded SIGPLAN 1992. [Ler94] \nXavier Leroy. Manifest types, modules rate compilation. In Proc. 21-st ACM Principles of Programming \nLanguages, and sepa-Symp. on 1994. [LVB+93] David C. Luckham, James Vera, Doug Bryan, Larry Augustin, \nand Frank Belz. Partial order\u00adings of event sets and their application to pro\u00adtot yping concurrent, timed \nsystems. Journal of Systems and Software, 1993. [Mac86] D.B. MacQueen. Using dependent types to ex\u00adpress \nmodular structure. In Proc. 13-th ACM Symp. on Principles of Programming Languages, pages 277-286, 1986. \n[Mey92] B. Meyer. Eiflel: The Language. Prentice-Hall, 1992. [MT91] R Milner and M Tofte. Commentary \non Standard ML. MIT Press, 1991. [MTH90] Robin Milner, Mads Tofte, and Robert Harper. The Defirution \nof Standard ML. MIT Press, 1990. [Pau91] L.C. Paulson. ML for the working programming. Cambridge Univ. \nPress, 1991. [Pie92] Benjamin Pierce. Bounded quantification is un\u00addecidable. In Proc. 19-th ACM Symp. \non Princi\u00adples of Programming Languages, pages 305-315, 1992. [Rit91] M. Rittri. Using types as search \nkeys in function libraries. J. Functional Programming, 1(1):71-90, 1991. [RPr] The PAVG group, Stanford \nUniversity. The Rapide Predefine Types Reference Manual. [RT91] C. Runciman and 1. Toyn. Retrieving reusable \nsoftware components by polymorphic type. J. Functional Programming, 1(2):191-212, 1991. [Sny86] A. Snyder. \nEncapsulation and inheritance in object-orient ed programming languages. In Proc. I-st ACM Symp. on Object-Oriented \nProgram\u00adming Systems, Languagesl and Applications, pages 38 46, October 1986. [TC93] W. Tracz and L. \nCoglianese. An adaptable soft\u00adware architecture for integrated avionics. In Pro\u00adceedings of NAECON 93, \npages 1161 1168, Day\u00adton, Ohio, May 1993. IEEE. [Tof89] M. Tofte. Four lectures on Standard ML. Tech\u00adnical \nReport EC S-LFCS-89-73, Lab. for Founda\u00adtions of C. S., University of Edinburgh, 1989. [US 80] US Dept. \nof Defense. Reference Manual for the Ada Programming Language. GPO 008-000\u00ad00354-8, 1980. A Type-theoretic \nfoundations for RAPIDE lt is rather tedious to study and prove properties of the RAPIDE type system if \none works with the framework in its entirety. Instead, a relatively simple and concise calculus that \nembodies the key concepts of the type system is cho\u00adsen, and is made the focus of such theoretical studies. \nThis section describes the types of this calculus. The calculus has function types and record types that \ncor\u00adrespond rather loosely to the function types and interfaces of the RAPIDE type system. However, functions \nin RAPIDE can be polymorphic and their type arguments can be con\u00adstrained using subtyping. Similarly, \ninterfaces can be poly\u00admorphic and can also contain type constituents that may or may not be abstract. \nThese extra notions are captured rather nicely by the polymorphic and abstract types of the calculus. \nThe details are summarized briefly below. The grammar for the types of the language is as follows: T \n::= t type uamables \\ T, -+T, functton types I pt.T recu~stve types [ {ll:T,,..., &#38;:Tn} r-eco r-d \ntypes [ Vt<:F (t).T polymor-ph%c types I %<: F(t).T abstract types I % = T, .Tz transparent types I fst(e) \ntype selectzon I Top super-type of all types The function type T1 -+T2 is the type of all functions \nthat take arguments of type T1 and return values of type Tz. e The type pt. T denotes type definitions \nthat are recur\u00adsive in the type variable t. c The record type {11 : T1, . . . . 1~ : T~} is the type \nof all records with fields 11 ,..., ~.~ having types Tl, . . ..T~ respectively. o Types of the form Vt< \n:F(t) .T denote bounded poly\u00admorphic types. These types denote expressions that are polymorphic over \nall the subtypes of a given type. The bounds imposed on the polymorphic type variable can contain the \nvariable itself these are the so-called F-bounds. e Abstract types in this calculus have the form 3< \n:F(t).T. It is easy to view such terms as being pairs (the first component being the hidden type and \nthe second the term over which the type is abstracted). Once again, bounds can be imposed on the type \nvariable that is being abstracted on. A slightly different variant of abstract types are types where \nthe type component is not really hidden, and is known and visible outside the type. These types have \nthe form =t= T. T .  For abstract and transparent types, one needs a way to extract the type component, \nand this is done us\u00ading the term f st (e ). (Correspondingly, the expression language uses the term snd(e) \nto select the value com\u00ad  ponent) c Top is the supertype of all types. This type allows one to write \nunbounded polymorphic types and completely opaque abstract types as special cases of bounded poly\u00admorphic \ntypes and bounded abstract types respectively (by using Top as the bound in each case). Top also has \nramifications on the decidability of subtype checking, and these have been studied in [KS92]. 150  \n  \n\t\t\t", "proc_id": "174675", "abstract": "<p>RAPIDE is a programming language framework designed for the development of large, concurrent, real-time systems by prototyping. The framework consists of a type language and default executable, specification and architecture languages, along with associated programming tools. We describe the main features of the type language, its intended use in a prototyping environment, and rationale for selected design decisions.</p>", "authors": [{"name": "Dinesh Katiyar", "author_profile_id": "81100046363", "affiliation": "Stanford University, California", "person_id": "P67310", "email_address": "", "orcid_id": ""}, {"name": "David Luckham", "author_profile_id": "81406592939", "affiliation": "Stanford University, California", "person_id": "P62685", "email_address": "", "orcid_id": ""}, {"name": "John Mitchell", "author_profile_id": "81338490160", "affiliation": "Stanford University, California and AT&T, Digital Equipment Corporation and the Powell Foundation", "person_id": "PP39076064", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/174675.177838", "year": "1994", "article_id": "177838", "conference": "POPL", "title": "A type system for prototyping languages", "url": "http://dl.acm.org/citation.cfm?id=177838"}