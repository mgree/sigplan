{"article_publication_date": "02-01-1994", "fulltext": "\n An Incremental Algorithm for Maintaining the Dominator Tree of a Reducible Flowgraph G. Ramalingarn \nIBM T.J. Watson Research Center Yorktown Heights, NY 10598 rsma@ watson.ibm.com Abstract We present a \nnew incremental algorithm for the problem of maintaining the dominator tree of a reducible flowgrsph \nas the flowgraph undergoes changes such as the insertion and deletion of edges. Such an algorithm has \napplications in incremental dataflow analysis and incremental compilation. 1. Introduction The contribution \nof this paper is a new incremental algo\u00adrithm for the problem of maintaining the dominator tree of a \nreducible flowgraph as the flowgraph undergoes changes such as the insertion and deletion of edges. The \ndominator tree plays an important role in several algorithms for pro\u00adgram analysis and program optimization, \nand the need for updating the dominator tree of a flowgraph arises in various contexts. For instance, \nCarroll and Ryder [Car88] present an incremental dataflow analysis algorithm that makes use of dominator \ntrees-it is necessary as a part of this algo\u00adrithm to update the dominator tree of the flowgraph. The \nneed to update the dominator tree carI arise even in the con\u00adtext of batch compilation. For instance, \ndominator trees are used in the construction of the static single assignment (SSA) representation of \nprograms [Cyt89, Cyt91]. As an optimizing compiler repeatedly applies optimizing transfor\u00admations, it \nmay be necessary to update the SSA representa\u00adtion of the program after each transformation. The algorithm \npresented in this paper works only for reducible flowgraphs, but does identify edge insertions that introduce \nirreducibility. The idea behind our algorithm is to formulate the problem of constructing the dominator \ntree of a reducible flowgraph as a pseudo circuit value problem the circuit value problem is essentially \nthe prob\u00adlem of computing the fixed point of a collection of non\u00adrecursive equations [Alp90]. Thk lets \nus borrow some This work wasdone while the first author was at the University of Wiscon\u00adsin, and was \nsupported in part by a David and Lucile Packard Fellowship for Science and Engineering, by the Nationat \nScience Foundation under grant CCR-9 100424, and by the Defense Advanced Research Projects Agency under \nARPA Order No. 8856 (monitored by the Office of Naval Research under contract NOO014-92-J-1937). Permission \nto copy without fee all or part of this material is granted provided that the copies are not made or \ndistributed for direct commercial advrmtage, the ACM copyright notice and the title of the publication \nend its dete appeer, and notice is given that copying is by permission of the Association for Computing \nMachinery. To copy otherwise, or to republish, requires a fee end/or specific permission. POPL 94-li?)4, \nPorUand Oragon,USA @ 1994 ACM O-89791 -W3_9194/@31..$3.50 Thomas Reps University of Wisconsin-Madison \n1210 W. Dayton Street Madison, WI 53706 reps@cs.wise.edu ideaa from previous incremental algorithms \nfor the circuit value problem. However, as we show in Section 3.1, the problem of constructing the dominator \ntree diffem consid\u00aderably from the circuit value problem and, consequently, we cannot directly use an \nincremental circuit evaluation algorithm for the dominator-tree update problem. What we do use is an \nincremental algorithm due to Alpem et al. [Alp90] for maintaining priorities in the dag induced by the \nforward edges of the flowgraph. Another key aspect of our algorithm is that the dominator tree is maintained \nusing the link-cut-tree data structure due to Sleator and Tarjan [Sle83]. This dynamic data structure \npermits a number of operations to be performed efficiently. The only previous algorithm for the problem \nof main\u00adtaining the dominator tree of a (reducible) flowgraph is due to Carroll and Ryder [Car88]. The \nalgorithm given in this paper has a better worst-case complexity than the Carroll-Ryder algorithm. There \nare also good reasons to believe that our algorithm will be more efficient in practice also. A comparison \nof the two algorithms is given in Section 4. The remainder of this paper is organized as follows. In \nSection 2 we review relevant terminology and notation. In Section 3 we present the incremental algorithm. \nWe con\u00adclude in Section 4 with a comparison with previous work and a discussion of possible extensions. \n2. Terminology and Notation A @wgraph is a directed graph with a source vertex. We initially consider \nflowgraphs in which every vertex is reachable from the source vertex. A vertex u is said to dominate \na vertex v in a flowgraph with source s iff every path froms to v passes through u. If u dominates v \nand u # v then u is said to be a proper dominator of v. Domination is a special kind of relation that \ncart be concisely represented by a tree, the dominator tree, in which a vertex u is an ancestor of a \nvertex v iff u dominates v. The parent of a vertex u in the dominator tree will be referred to as the \nimmediate dominator of u and will be denoted by Worn(u). An edge x + y in a flowgraph is said to be a \nback edge if vertex y dominates vertex x and it is said to be a forward edge otherwise. A flowgraph is \nsaid to be a reducible jhnvgraph if the set of all forward edges induces an acyclic graph. Otherwise, \nit is said to be irreducible. (There are other equivalent characterizations of reducibility see [Aho86].) \nThe usual definition of a reducible flowgraph assumes that all vertices are reachable from the source \nvertex. We relax this restriction and consider a flowgraph to be a redu\u00adcible flowgraph if the set of \nvertices reachable from the source is a reducible flowgraph according to the above definition. This relaxation \nis useful in the context of incre\u00admental computation-in changing one reducible flowgraph into another \nreducible tlowgraph by inserting and deleting edges it may be necessary to temporarily introduce unreachable \nvertices. However, the concept of domination still applies only to reachable vertices. In particular, \nthe rdgorithm we outline in this paper will maintain the domi\u00adnator tree of the subgraph induced by the \nreachable ver\u00adtices. Also, the classification of an edge as a back edge or forward edge is meaningful \nonly if the endpoints of the edge are reachable. By the status of an edge we mean its status as a back \nedge or forward edge. Recall that an edge u ~ v is a back edge iff v dominates u. Thus, any path from \nthe source vertex s that contains a back edge u + v must be a cyclic path since it contains at least \ntwo occurrences of the vertex v. This implies that the set of reachable vertices does not change if a \nback edge u ~ v is removed from the graph, since a vertex is reach\u00adable iff there exists an acyclic path \nfrom the source vertex to that vertex, Similarly, the domination relation of a flowgraph does not change \nif a back edge is removed from the graph, since domination can be defined in terms of acy\u00adclic paths. \nHence, the problems of maintaining the reacha\u00adbility information and the dominator tree of a reducible \nflowgraph are closely related to the problems of maintain\u00ading the reachability information and the dominator \ntree of a dag (the dag of forward edges), provided we have a way of identifying the forward edges and \nback edges of the graph. We now show that the status of an edge as a forward edge or back edge does not \nchange as edges are inserted into and deleted from the graph as long as the graph remains reduci\u00adble \nthroughout this sequence of modifications. (We are talking only of edges whose endpoints remain reachable \nin the flowgraph.) Proposition 2.1. Let G ~ and G ~ be two reducible flowgraphs such that ,E(GZ) = E(GI) \nu {u +v}. The status of an edge that is reachable in both graphs is the same. Proof. It follows easily \nfrom the definition of domination that the insertion of an edge can only shrink the domination relation \nhence, if x dominates y in graph G z then x must dominate yin graph G ~, too. Consequently, a back edge \nin graph G2 must be a back edge in graph G ~ too (assuming that the edge under consideration is not u \n+ v). Equivalently, every forward edge in G ~ is a forward edge inG2. Going the other way, a back edge \nin G, must be a back edge in G z also, for the following reason: if x + y is a back edge in G,, then \nthere is some path consisting only of forward edges from y to x in G ~; hence, there exists a path of \nforward edges from y to x in Gz alsq if x + y were a forward edge in G z, then the set of forward edges \nin G ~ would induce a cycle, contradicting the assumption that G z is reducible. 0 Let us now consider \nthe status of a newly inserted edge u + v. Since domination can be defined in terms of acy\u00adclic paths, \ninsertion of an edge u + v does not change the set of dominators of vertex u. Consequently, u + v is \na back edge iff v dominates u in the new graph iff v dom\u00adinates u in the old graph. This is useful since \nwe can deter\u00admine the status of a newly inserted edge from the domina\u00adtion information about the original \ngraph. 3. The Dynamic Dominator Tree Problem in Reducible Flowgraphs In this section we present an incremental \nalgorithm for maintaining the dominator tree of the subgraph of reach\u00adable vertices of a flowgraph under \nthe assumption that this subgraph remains reducible as the flowgraph undergoes modifications. We also \noutline a method for checking if the graph ever becomes irreducible during a sequence of modifications. \n3.1. The Dominator Tree of a Directed Acyclic Graph We saw in Section 2 that the dominator tree of a \nreducible flowgraph is the same as that of the dag of forward edges of that flowgraph. We will first \npresent a simple batch algo\u00adrithm for constructing the dominator tree of a dag. Linear time algorithms \nthat construct the dominator tree of a dag are known [Har85, 0ch83], but the reason for the following \npresentation is that it suggests a possible way of incremen\u00adtally maintaining the dominator tree of a \ndag. We will then use this idea for maintaining the dominator tree of a reduci\u00adble flowgraph, Consider \na dag with a source vertex. Consider a vertex u in the dag with predecessors v 1 , . . . . v~. A vertex \nw will properly dominate u iff it dominates all the }ertices v, through v~. In other words, Dom (u) = \n{u) u ,~lDom (vi), where Dom (x) denotes the set of dominators of vertex x. Thus, if we have identified \nthe set of dominatom of v ~ through v~, then the set of proper dominators of u can be obtained by intersecting \nthese sets. In particular, the immediate dominator of u has to be the least common ancestor of v 1 through \nv~ in the dominator tree. The previous paragraph suggests the following scheme for constructing the dominator \ntree of a dag in an incremen\u00adtal fashion. The vertices in the dag are visited in topologi\u00adcal order and \nadded to the dominator tree one by one. Ini\u00adtially the dominator tree consists only of the source vertex \ns. When a vertex u is visited, the least common ancestor w of all the predecessors v 1 through v~ of \nu in the partially constructed tree is identified. Now, u is made a child of w. Thus, the construction \nof the dominator tree of a dag can be A /( b /d G G , obtained by inserting an edge into G Ah ea b \nI d The dominator tree for G The dominator tree for G Figure 3.1. An example to show how the problem \nof constructing the dominator tree of a dag differs from a circuit value problem. An edge b + c is inserted \ninto the dag G. The affected vertices in the resulting dag G , indicated by the shaded region, do not \nform a connected region. considered to be a pseudo circuit value probleml, where every vertex u other \nthan the source vertex is associated with the equation parent(u) = lca (VI, . . . ,v~), where we use \nlca as an abbreviation for least common ancestor . The value computed for every vertex (other than the \nsource) is its parent in the dominator tree. Note that the above problem is not a true circuit value \nproblem because the right-hand side of the above equation is not a pure function of the values associated \nwith the predecessors of vertex u. Hence, the output value of a ver\u00adtex (that is, its immediate dominator) \ncan change even though the output value of none of its predecessors have changed. Consider, for example, \nthe dag G shown in Fig\u00adure 3.1. This dag is modified into dag G by the insertion of an edge b + c. The \nvertex c is affected. (We say a ver\u00adtex is affected if its immedate dominator changes.) The only successor \nof c, namely d, is not affected-its immedi\u00adate dominator is still c. However, vertex e is affected, even \nthough none of its predecessors are affected. The above problem prevents us from using any incre\u00admental \ncircuit evaluation algorithm directly. However, if In the circuit vatue problem the input consists of \na dag in which every vertex has an associated equation that specifies the output value to be com\u00adputed \nfor that vertex as a function of the output vatrres of its predecessor vertices. we have a conservative \napproximation to the set of all affected vertices, then we can use ideas from the circuit value problem \nto update the dominator tree, In particular, we can visit all vertices that might possibly be affected \nin topological order, and determine their immediate domina\u00adtors using the above equation. We can use \npriority\u00adordering to visit vertices in a topological sort order, and use the incremental algorithm of \nAlpern et al. [Alp90] for updating the priority-ordering when the graph undergoes changes. (A priority-ordering \nassociates a priority with every vertex of a dag such that if there is a path from a ver\u00adtex u to a vertex \nv then priority(u) < p-iori~ (v).) We can represent the dominator tree using the link-cut tree data structure: \nThe link-cut tree data structure, due to Sleator and Tarjan [Sle83], is a representation of a dynamic \nforest (collection of trees) that allows a number of operations to be performed efficiently. The only \noperations that are of interest to us are: a maketree operation that creates a new tree consisting of \na single newly inserted vertex; a link operation that adds an edge from some vertex u in a tree T1 to \nthe root of another tree T2, making T2 a subtree of T1; a cut operation that removes an edge from a tree, \nbreaking it into two trees; an operation that returns the least common ancestor of two vertices, which \ncan also be used to check for the ancestor-descendant relationship between two ver\u00adtices. Each of these \noperations runs in O (log n) time, where n is the number of vertices in the forest. 3.2. The Dynamic \nDominator Tree Problem for Reduci\u00ad ble Flowgraphs We now return to the problem of maintaining the domina\u00ad \n tor tree of a reducible flowgraph. Let G denote the reduci\u00adble flowgraph for which the dominator tree \nhas to be main\u00adtained, The algorithm will maintain the following data structures and information: (a) \nThe reachability status of every vertex will be maintained. (b) Let R (G) denote the subgraph induced \nby the reachable vertices. The status of every edge in R (G )-whether it is a forward edge or back edge \nwill be maintained. (c) Let F (G ) denote the acyclic subgraph of R(G) induced by the forward edges. \nBoth F(G) and a correct prioritization of F(G) will be main\u00adtained. (d) The dominator tree llT(G) of \nF (G), which is the same as the dominator tree of R (G) and G, will be maintained as a link-cut tree. \n 3.2.1. The Insertion of an Edge We now consider the problem of updating all the above information when \nan edge u + w is inserted into the graph. We will assume that the vertex u was originally reachable from \nthe source vertex, since nothing needs to be done otherwise. We will first consider the simpler case \nwhere the vertex w was already reachable, which means that there is no change in the reachability status \nof vertices. A Special Case: No Change in Reachability In this case the set of vertices in R(G) remains \nthe same, while u + w is added to the set of edges. We know from Proposition 2.1 that the insertion of \nu ~ w does not change the status of any other edge in R(G). Conse\u00adquently, maintaining edge statuses \nrequires only that we determine the status of the newly inserted edge. If vertex w dominates vertex u \nin the original graph, then the edge inserted is a back edge. Otherwise, it is a forward edge. We can \ncheck if v dominates u in the original graph in O (log n) time, since a representation of the dominator \ntree as a link-cut tree enables us to check for the ancestor\u00addescendant relation between two vertices \nin O (log n) time. If the edge u ~ w is a back edge, then neither F (G) nor llT(G) changes, and nothing \nmore needs to be done. If the edge is a forward edge, then we insert it into F(G), and update the prioritization \nof F(G) using the algorithm presented in [Alp90]. This algorithm also determines if the insertion of \nan edge into a dag introduces a cycle. Hence, we can determine at this point if the insertion of the \nedge u ~ w makes the graph G irreducible. Updating the prior\u00adities takes O (y logy) time, where y is \na measure of the size of the change in the priorities. (A dag can have a number of valid priority-orderings. \nConsequently, when the dag is modified, its priority-ordering can be updated in a number of different \nways, each of which might require updating the priorities of a different set of vertices. y is the size \nof the smallest set of vertices updating whose priorities yields a valid priority-ordering, where the \nsize of a set of vertices is the sum of the number of vertices and the number of edges incident on those \nvertices.) We now consider the problem of updating DT(G) itself. Let us now consider how the dominator \ntree can change following the insertion of a forward edge into the flowgraph. Proposition 3.1. (See Figure \n3.2.) Consider the insertion of an edge u ~ w into a flowgraph where both u and w are already reachable. \nIf a vertex y is affected by the insertion of the edge, then idom (y ) must properly dominate w and idom \n(y ) must be properly dominated by lca (u, w ). Further, the new immediate dominator of every affected \nvertex must be lca (u,w). Proof. We have assumed that vertex w was already reach\u00adable in the flowgraph. \nHence, w must occur in the domina\u00adtor tree of the original flowgraph. Let v denote idom (w). Consider \nthe least common ancestor of u and w. Consider an affected vertex y, that is, a vertex y whose immediate \ndominator changes. Let x denote idom ( y) in the original graph. We noted earlier that the insertion \nof an edge can only shrink the domination relation. Hence, y s new immediate dominator must have been \na dominator of y in the original graph too-that is, y s new immediate domina\u00adtor must bean ancestor of \ny in the original dominator tree. What can we infer from the fact that x no longer dom\u00adinates y? The \ninsertion of the edge u + w must have created a path froms to y that avoids x. It follows that the original \ngraph must contain a path P 1 from s to u and a path P2 from w to y both of which avoid vertex x. This \nimplies that x cannot have been a dominator of u in the ori\u00adginal graph, since otherwise the required \npath P 1 could not have existed. This also implies that x must have been a proper dominator of w in the \noriginal graph~therwise, there must exist a path P3 in the original graph froms to w that avoids x. Concatenating \npaths P3 and P2 yields a path froms toy in the original graph that avoids x, contradicting the assumption \nthat x dominates y in the original graph. Hence, x must be a proper ancestor of w, but cannot be an ancestor \nof u. In other words, x must be a proper ances\u00adtor of w and a proper descendant of lca (u, w)--that is, \nit must lie in the shaded region S shown in Figure 3.2. This establishes the first claim in the proposition. \nNow, consider the second claim. Assume that y is an affected vertex. Note that lca (u, w ) dominates \ny even in the new graph, since there exists no path from s to u that avoids lca (u, w). On the other \nhand, no ancestor tof y in the original dominator tree that is a proper descendant of lca (u, w ) can \ndominate y in the new graph-there exists a path P2 from w to y that avoids t (since y is assumed to be \nan affected vertex), and there exists a path P 1 from s to u that avoids t.Consequently, the new immediate \ndominator of an affected vertex y must be lca (u, w). l For any two vertices p and q define PossiblyAffected \n@,q) to be the set { r I idom (r) is a proper ancestor of q and a proper descendant of lca (p,q) }. The \nabove proposition shows that PossibleAflected (u, w ) is a s \\ lca (u.w) v ,..- Path Pzin the flowgraph \n!  ------+;A . ,. ... Figure 3.2. The change in the dominator tree of a flowgraph when an edge u + \nw is inserted. Solid wavy lines in the figure indicate paths in the dominator tree, while solid straight \nlines indicate edges in the dominator tree. Dashed lines indicate edges and paths in the flowgraph. For \nany affected vertex y, idom (y) must lie in the shaded region of the original dominator tree. Further, \nthe new immediate dominator of any affected conservative approximation to the set of affected vertices \nwhen an edge u + w is inserted, provided both u and w are reachable in the original graph. We can re-evaluate \nall these vertices in increasing order of priority to determine the set of affected vertices and to update \nthe dominator tree. The re-evaluation of vertices in PossibleA&#38;ected (u,w) is necessary only to determine \nthe vertices that are actually affected, since, as the above pro\u00adposition shows, the new immediate dominator \nof every affected vertex y is lca (u, w). This step takes time O ( IIPossibleAffected (u,w) II + log \nn), where, for any set X, IIX II + denotes the sum of the number of vertices in X and the number of edges \ncoming into vertices in X. The General Case Consider the insertion of an edge u + w where u is reachable \nbut w may or may not be reachable. This can be processed very easily using a worklist algorithm that \nrepeatedly invokes the special-case updating algorithm, as follows. Create a worklist that initially \nconsists of just u + w. Every edge x + y in the worklist will be pro\u00adcessed as follows: If y is already \nmarked reachable, we pro\u00adcess edge x + y using the special-case algorithm previ\u00advertex is lca (u, w). \nously outlined. (Except for the particular case where the edge x -+ y is the newly inserted edge u + \nw, the edge x + y would have already been in the graph, but would not have been previously processed \nsince vertex x was pre\u00adviously unreachable. Hence it is being processed now.) If y is marked unreachable \nthen we do the following: y is marked reachable; the edge x + y is marked as a forward edge; y is assigned \na priority greater than x y is made a child of vertex x in the dominator tree and, finally, all the edges \ngoing out of y are added to the worklist. However, it is possible to do the update somewhat more efficiently \nin the general case. Observe that the edges pro\u00adcessed in the above worklist algorithm are of two types: \nedges of the form x + y where y was already reachable, and edges of the form x + y where y was not previously \nreachable. The algorithm presented below first identifies all the edges and vertices that need to be \nprocessed, and partitions them into these two classes, and processes them separately. The algorithm is \npresented in Figure 3.4. The major steps involved in the algorithm are: (1) Determining the set R of \nvertices that become reachable. (2) Processing the subgraph 4?> induced by R. (3) Determining the set \nX of reachable dominator tree for reac6able Edge Set X vertices subgraph induced by R FLOW-GRAPH DOMINATOR \nTREE Figure 3.3. The change in the dominator tree of a flowgraph when an edge u + w is inserted such \nthat w becomes reachable. The flowgraph is shown on the left side. The tree on the right side shows how \nthe new dominator tree would look like ~ there was no edge from a newly reachable vertex to a previously \nreachable vertex-+hat is, lJ set X was empty. If X is not empty, then the-new dominator tree can be obtained \n&#38;om the ~ominator tree on the right by processing the insertion of edges in F . edges of the form \nx + y, where x e R and y E R. (4) vertices can be processed as before (i.e., in order of Processing the \nset X of edges. increasing priorities). The set R of vertices that become reachable is obtained The overall \ncomplexity of the algorithm consists of two easily enough from a simple graph traversal starting from \ncomponents: the time spent on updating priorities, which is w. Processing the subgraph cR> can be done \nusing a batch O (ylog y),2 and the time spent on the remaining steps, algorithm as follows: The dominator \ntree D of @>, with w which is O (l! WSZTED II + log n), where WSZTED is the as the source vertex, is \ncomputed using a batch algorithm. approximation to AFFECTED identified by the algorithm. The status of \nedges in .@> can be computed using a simple traversal of the dominator tree D. The tree D is made a 3.2.2. \nThe Deletion of an Edge subtree of the original dominator tree by making w a child We now consider the \nproblem of updating the dominator of u. Priorities can be assigned to vertices in R using a sim\u00adtree \nand the auxiliary information after the deletion of an ple batch algorithm-we just need to ensure that \nthe new edge u + w. Again, we first consider the special case priorities are all greater than prioriry \n(u). where the edge-deletion does not change the reachability The above steps are sufficient as long \nas there is no edge status of any vertex. The vertex w becomes unreachable from a vertex in R to some \npreviously reachable vertices. following the deletion of u + w iff u + w was the only If there is such \nan edge, we identify the set X of edges from vertices in R to vertices outside R. Now we need to process \n%e Alpem et al. algorithm can take time O (~ log y) to update priorities the insertion of the edges in \nX using the special-case after the insertion of a number of edges into the dag. The sitnation that ar\u00ad \nalgorithm outlined previously. We could process these ises in our afgorithm is, however, a special one \nand can be. processed in edges one by one, but that is not necessary. We know that O (ylogj time. u PossibleAffected \n(x, y) is an approximation to the X-+YEX set of affected vertices. This approximation to the affected \n procedure InsertEdge~OminarOr~r,e(G, u + w) declare G: a directed graph u + w an edge to be inserted \ninto G begin [1] [2] [3] [4] [5] [6] [7] [8] [9] [10] [11] [12] [13] [14] [15] [16] [17] [18] [19] [20] \n[21] [22] [23] [24] [25] end Insert edge u + w into E(G) if reachable(u) then if not reachable(w) then \nCompute the set of newly reachable vertices R and mark them as reachable Compute the dominator tme D \nof &#38;>, the subgraph induced by R, with w as the source vertex Make D a subtree of u by performing \nlink (u, w) Determine the status of all edges in cR> Correctly prioritize the dag induced by the forward \nedges of ~>, ensuring that the priorities assigned are greater than priority(u) Insert all forward edges \nin .@> into F (G) Compute X, the set of edges from vertices in R to vertices outside R else X:={ zl+w} \nfi Determine the status of all edges in X Insert all the forward edges in X into F(G) and update the \nprioritization of F (G) s .- u PossibleAffected (x,y) X+yex for every x e S in increasing order of priority \ndo y := the least common ancestor of all predecessors in F (G) of x if y # idom (x) then cut(idom (x),x) \n/ink(y,x) fi od fi Figure 3.4. An outline of the algorithm for updating the dominator tree of a reducible \nflowgraph after the insertion of an edgev+ winto graph G. \u00ad forward edge coming into w. A Special Case: \nNo Change in Reachability We know there is no change in the reachability status of w if there is some \nother incoming forward edge at w. In this case, we remove the edge u + w from F(G) if the edge is a forward \nedge. Since the previous prioritization of F(G) continues to be a correct prioritization of F (G), no \nupdating of priorities is required, The only non-trivial work is in updating the dominator tree. We can \nvery easily determine a good approximation to the set of affected vertices after the deletion of the \nedge V+w. Proposition 3.2. Consider the deletion of an edge u + w from a flowgraph, where both u and \nw remain reachable in the new graph too. If a vertex y is affected by the deletion of the edge, then \ny must be a sibling of w in the original dominator tree-that is, idom (y)= idom (w) in the original dominator \ntree. Proof. Assume we obtain graph G z from graph G 1 by deleting edge u + w. The insertion of the deleted \nedge back into G2 will restore the dominator tree to its original form. In other words, the set of affected \nvertices when u + w is inserted into G z is the same as the set of affected vertices when u + w is deleted \nfrom G 1. We know from Proposition 3.1 that if a vertex y is affected by the insertion ofedge u+ winto \nGzthenitmust beasibling ofwinthe dominator tree for G 1. El The General Case The general-case updating \nalgorithm for processing the deletion of an edge u + w is similar to the general-case updating algorithm \nfor processing an edge insertion. The algorithm performs the following steps: (1) Determine the set R \nof vertices that have become unreachable, (2) Deter\u00admine the setF of edges of the form x+ y, where x \ne R and y e R, and (3) Process the set F of edges, by essen\u00adprocedure DeleteEdgeDOmi~a~OrT,e,(G, U *W] \ndeclare G: a directed graph u ~ w an edge to be deleted from G begin [lj- Remove edge u ~ w from E(G) \n[2] if u -+ w is a forward edge then [3] Remove edge u ~ w from F(G) [4] if w has no incoming forward \nedges then [5] Let R be the descendants of w in the dominator tree [6] Mark vertices in R unreachable \n[7] Let X be the set of forward edges from vertices in R to vertices outside R [8] Remove X and all forward \nedges in dl> from F (G) [9] else [10] X:={ u+w] [11] fi [12] s .- U X+yex siblings (y) [13] for every \nx ~ S in increasing order of priority do [14] y:= the least common ancestor of all predecessors in F \n(G) of x [15] if y # idom (x) then [16] cut(idom (x),x) [17] link(y,x) [18] fi [19] od [20] fi end Figure \n3.5. An outline of the algorithm for updating the dominator tree of a reducible flowgraph after the deletion \nof an edge v ~ w from graph G. tially working as though these edges have been deleted from the graph. \nNote that the set R of vertices that have become unreach\u00adable is precisely the set of vertices dominated \nby w, that is, the set of vertices in the subtree T rooted at w in the origi\u00adnal dominator tree. The \nset F of edges is essentially the set of edges x ~ y with x in the subtree T and y not in T this set \nof edges is obtained easily by traversing the subtree T. The deletion of the edges in F is processed \nas follows: U Siblings(y) is an approximation to the set of ,X+y EF affected vertices, which can be processed \nusing previously explained techniques. The overall complexity of the edge-deletion procedure is O (II \nVISITED II + log n), where VISITED is the approxi\u00admation to the set of affected vertices used by the \nalgorithm. 4. Conclusion In this paper we have presented an incremental algorithm for the problem of \nmaintaining the dominator tree of a reducible flowgraph. The only other algorithm we are aware of for \nthis problem is due to Carroll and Ryder [Car88, Car88a]. We now briefly compare these two algo\u00adrithms \nand argue that the new algorithm is more efficient than the Carroll-Ryder algorithm. Our algorithm has \na better worst-case time complexity than the Carroll-Ryder algorithm. In the worst case, the algorithm \npresented in this paper can take O (m log n) time, where m is the number of edges and n is the number \nof ver\u00adtices in the flowgraph. Note that m is O(n) for typical flowgraphs. Carroll and Ryder do not describe \nthe worst\u00adcase complexity of their algorithm in terms of n and m. In Carroll s thesis, the complexity \nof the Carroll-Ryder incre\u00admental algorithm is described in terms of rotations (see below): their algorithm \ncan perform G2(n2) rotations in the worst case (even with sparse flowgraphs), and the cost of a rotation \nin the worst-case is O ((f +1 ) x g x d2), where ~ is the maximum number of children of any vertex in \nthe dom\u00adinator tree, g is the maximum degree of any vertex in the control-flow graph augmented with certain \nrepresentative edges (see below), and d is the height of the dominator tree. In the worst case, J g, \nand d can each be O(n), though f will usually be a small constant for typical flowgraphs, It is not obvious \nif the worst case for the number of rotations and the parameters f, g, and h can be simultaneously achieved, \nbut the above clearly demon\u00adstrates that our algorithm has a better worst-case complex\u00adity. However, \nwor~-caae analysis with the complexity expressed as a function of the (current) input size often does \nnot characterize the complexity of incremental algo\u00adrithms accurately, and the relative merits of incremental \nalgorithms cannot be established by directly comparing their worst-case complexity measures. For example, \nthe linear-time batch algorithm for constructing the dominator tree has a better complexity than both \nour incremental algo\u00adrithm and the Carroll-Ryder incremental algorithm, which have a non-linear worst-case \ncomplexity, though the incre\u00admental algorithms are arguably better than the batch algo\u00adrithm, In his \nthesis, Carroll presents experimental results showing that the Carroll-Ryder algorithm is faster than \nthe almost-linear batch algorithm due to Lengauer and Tarjan [Len79]. There are two reasons why we believe \nthat our algorithm will perform better in practice than the Carroll-Ryder algo\u00adrithm. The first is that \nthe Carroll-Ryder algorithm utilizes certain representative edges as auxiliary information, and maintaining \nthis auxiliary information can be expensive both in time and space. (For every edge u ~ v in the flowgraph, \nand for every vertex w that dominates u but not v, a representative edge w ~ v needs to be maintained. \nIn terms of the dominator tree, every flowgraph edge u ~ v requires a representative edge w ~ v for every \nvertex won the path from u to lca (u,v), excluding the end-points.) For example, a single edge-deletion \n(from a sparse flowgraph) that is processed in O (log n) time by our algorithm can result in the introduction \nof S2(n2) new representative edges, forcing the Carroll-Ryder algorithm to take Q(n 2, time. The second \nreason is that the Carroll-Ryder algo\u00adrithm restmctures the dominator tree using local rotation operations, \nwhich move a subtree up or down one level at a time in the dominator tree. (In particular, an upward \nrota\u00adtion makes a vertex the child of its original grandparent, while a downward rotation makes a vertex \nthe child of one of its original siblings.) In contrast, our algorithm deter\u00admines the new immediate \ndominator of vertices and moves each subtree only once, but such a move can take O (log n) time because \nof the use of link and cut operations. Conse\u00adquently, one can easily create input modifications that \nare processed in O (log n) time by our algorithm for which the Carroll-Ryder algorithm performs Q(n) \nrotations, each rotation requiring Q(n) time. One of the differences between our approach and the approach \nof Carroll and Ryder is that to handle graphs with unreachable vertices they extend the definition of \ndomina\u00adtor tree to that of a dominator J_oresc they consider a decomposition of the whole graph into \na collection of flowgraphs, each with its own source vertex, such that every vertex is reachable from \nthe source of the flowgraph it belongs to, the collection of the dominator trees of these flowgraphs \nconstitute a dominator forest. If the graph has a unique minimal decomposition, then this approach is \nmean\u00ad ingful. However, a graph need not have a unique minimal decomposition, in general, and the dominator \nforest is not uniquely defined, Since the advantages of maintaining such a dominator forest are unclear, \nwe have restricted our attention to the problem of maintaining the dominator tree of the reachable vertices. \nFinally, we should mention that the algorithm described in Carroll s thesis is capable of handling the \nsimultaneous insertion and deletion of edges from the flowgraph. The algorithm presented in this paper \ncan be adapted to handle the deletion of multiple edges or the insertion of multiple ed?$s. An arbitrary \nchange can be handled by processing all the deleted edges in one step, and then processing all the inserted \nedges in a second step. Further work is required to explore if the algorithm can be adapted to handle \nthe inser\u00adtion and deletion of edges simultaneously. Another interesting direction for future research \nis sug\u00adgested by a generalization of the link-cut tree data structure due to Cohen and Tamassia [Coh92, \nCoh92a]. Consider a tree in which each vertex is associated with some attributes, each of which is defined \nin terms of attributes of adjacent vertices. Cohen and Tarnassia show how to efficiently maintain such \nan attributed tree dynamically when the attri\u00adbute equations are linear expressions involving operators \nthat form a semiring. Their algorithm performs link and cut operations in O (log n ) time. Attribute \nvalues are not maintained but can be computed on demand in logarithmic time. Carroll and Ryder show that \nmonotonic dataflow analysis problems can be reduced to an attribute evaluation problem -over the dominator \ntree, and use Reps s [Rep82, Rep83] incremental attribute updating algorithm to perform incremental dataflow \nanalysis. Since the function spaces of distributive dataflow analysis frameworks form a semiring with \nrespect to function composition and meet, it seems worthwhile exploring the possibility of using the \nCohen and Tamassia algorithm, in conjunction with our incremental dominator tree algorithm, to perform \nincre\u00admental dataflow analysis, References AhoS6. Aho, A.V., Sethi, R., and Unman, J.D., Compilers: Principles, \nTech\u00ad niques, and Tools, Addkon-Wesley, Reading, MA (19S6). Alp90. Alpem, B., Hoover, R., Rosen, B.K., \nSweeney, P.F., and Zadeck, F.K., Incremental evaluation of computational circuits; pp. 32-42 in Proceedings \nof the First Annual ACM-SIAM Symposium on Discrete Algorithms, (Sarr Francisco, CA, Jan. 22-24, 1990), \nSociety for Industrial and Applied Mathematics, Pbiladelphi&#38; PA (1990). Carss. Carroll, M. and Ryder, \nB., Incremental data flow update via attri\u00ad bute and dominator uvdates, VP. 274-2S4 in ConferenceRecordof \nthe Fifteenth ACM Symposi;rn on Principles -of Programming Languages, (San Diego, CA, January 13-15, \n1988), ACM, New York, NY (19SS). Carssa. CarroU, M.D., Data flow update via dominator and attribute \nupdates; Ph.D. dksertation, Rutgers University, New Bmnswick, NJ (May 198S). Coh92a. Cohen, R.F., Combine \nand Conquer: Ph.D. dissertation, Technical Report No. CS-92-45, Department of Computer Science, Brown \nUniversity, Providence, RI (October 1992). Coh92. Cohen, R.F. and Tamassia, R., Combine and Conquer: \nTechnical Report No. CS-92-19, Depmtment of Computer Science, Brown University, Providence, RI (April \n1992). Cyt89. Cytron, R., Ferrante, J., Rosen, B. K., Wegrnan, M.N., and Zadeck, K., An efficient method \nof computing static single assignment form; pp. 25-35 in Conference Record of the SixteenthACM Syntpo\u00adsium \non Principles of Programming Languages, (Austin, TX Jan. 11-13, 1989), ACM, New York, NY (1989). cyt91. \nCytron, R., Ferrante, J., Rosen, B.K., Wegman, M.N., and Zadeck, F.K., Efficiently computing static single \nassignment form and the controI dependence graph, ACM Trans. Program. Lxzng. Syst. 13(4) pp. 451-490 \n(October 1991). Har85. Harel, D., A linear time afgorithnr for finding dominators in flow graphs and \nrelated problems; pp. 185-194 in Proceedings of the Symposium on Theory Of Computing, (1985). Leni 9. \nLengauer, T. and Tarjan, R.E., A fast algorithm for tinding domina\u00adtors in a flowgraph: ACM Transactions \non Programming Languages and Systems l(l) pp. 121-141 (July 1979). Och83. Ochranov% R., Finding dominatorsfl \npp. 328-334 in Proceedings of the Founhtions of Computation Theory, (1983). Rep82. Reps, T., Optimal-time \nincremental semantic analysis for syntax\u00addmcted editors, rm. 169-176 in Conference Record of the Ninth \nACM Symposium ;; Principles of Programming L.ungu&#38;es, (Albu\u00adquerque, NM, January 25-27, 1982), ACM, \nNew York, NY (1982). Rep83. Reps, T,, Teitelbaum, T., and Demers, A., Incremental context\u00addependent analysis \nfor language-based editors: ACM Trans. Pro\u00adgram. Lung. Syst. 5(3) pp. 449-477 (July 1983). Sle83. Sleator, \nD.D and Tarjan, R.E., A data structure for dynamic trees, Journal of Computer and System Sciences 26 \npp. 362-391 (1983).  \n\t\t\t", "proc_id": "174675", "abstract": "<p>We present a new incremental algorithm for the problem of maintaining the dominator tree of a reducible flowgraph as the flowgraph undergoes changes such as the insertion and deletion of edges. Such an algorithm has applications in incremental dataflow analysis and incremental compilation.</p>", "authors": [{"name": "G. Ramalingam", "author_profile_id": "81100519054", "affiliation": "IBM T.J. Watson Research Center, Yorktown Heights, NY", "person_id": "PP31045870", "email_address": "", "orcid_id": ""}, {"name": "Thomas Reps", "author_profile_id": "81100117392", "affiliation": "University of Wisconsin-Madison, 1210 W. Dayton Street, Madison, WI", "person_id": "PP40023877", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/174675.177905", "year": "1994", "article_id": "177905", "conference": "POPL", "title": "An incremental algorithm for maintaining the dominator tree of a reducible flowgraph", "url": "http://dl.acm.org/citation.cfm?id=177905"}