{"article_publication_date": "02-01-1994", "fulltext": "\n Dominators, Super Blocks, and Program Coverage Hiralal Agrawal Bellcore 445 South Street Morristown, \nNJ 07960 hira@bellcore. com Abstract In this paper we present techniques to find subsets of nodes of \na flowgraph that satisfy the following property: A test set that exercises all nodes in a subset exercises \nall nodes in the flowgraph. Analogous techniques to find subsets of edges are also proposed. These techniques \nmay be used to significantly reduce the cost of coverage testing of programs. A notion of a super block \nconsisting of one or more basic blocks is developed. If any basic block in a super block is exercised \nby an input then all basic blocks in that super block must be exercised by the same input. Dominator \nrelationships among super blocks are used to identify a subset of the super blocks whose coverage implies \nthat of all super blocks and, in turn, that of all basic blocks. Experiments with eight systems in the \nrange of 1-75K lines of code show that, on the average, test cases targeted to cover just 29% of the \nbasic blocks and 32% of the branches ensure 100% block and branch coverage, respectively.  Introduction \nCommon sense dictates that a program be tested on enough inputs that exercise each of its statements \nat least once, as a statement must be exercised before a fault in it may be exposed [5, 14]. In other \nwords, a program should be executed on enough inputs during testing so each node in its flowgraph gets \nvisited. A tester, therefore, is faced with the task of creating test cases targeted to cover all nodes \nin the flowgraph of the program being tested. In this paper, we present a technique to find a small subset \nof these nodes with the property that if the subset is covered, the remaining Perrnkion to copy without \nfee all or part of this material is granted providad that tha copies ere not made or dictributad for \ndirect commercial advantage, the ACM copyright notice end the titla of the publication and its dete appeer, \nand notica is given that copying is by permiesiem of the Association for Computing Machinary. To copy \notherwise, or to republish, raquires a fee and/or specifio permission. POPL 94-1194, Porlfand Oregon, \nUSA @ 1994 ACM 0-S9791-63$094JOOl.. $3.5O nodes are automatically covered. Thus the tester only needs \nto develop test cases targeted to cover the nodes in the subset rather than the entire set. The problem \nthat all nodes in a flowgraph be covered is referred to as the bioclc coverage problem as nodes in a \nflowgraph represent basic blocks in a programl. A more stringent problem than the block coverage prob\u00adlem \nis the branch coverage problem which requires all control transfers or branches among basic blocks to \nbe exercised. In other words, it requires that the pro\u00adgram should be executed on enough inputs so all \nedges in its flowgraph get visited at least once. The techniques presented in this paper apply equally \nwell to the branch coverage problem. They may be used to identify a small subset of edges such that if \nthe subset is covered then other edges are automatically covered. Besides saving the user time, these \ntechniques may also be used to reduce the space and time overhead imposed by the coverage testing tools \nby reducing the number of probes that need to be placed in a program. Many optimal program profiling \ntechniques are avail\u00adable in the literature [4, 7, 11, 15, 17] that may also be used to reduce this overhead \n(see Section 8, Related Work). Unfortunately none of these techniques help re\u00adduce the number of test \ncases the user must develop to achieve the desired coverage. These techniques help us find a small subset \nof nodes/edges in a flowgraph with the property that if we know how many times the nodes/edges in the \nsubset are visited, then we may infer how many times the remaining nodes/edges are visited. If all nodes/edges \nin the subset are visited, however, we may not conclude that the remaining nodes/edges are visited too. \nThe subsets of nodes/edges determined by the techniques presented in this paper, on the other hand, enable \nthe latter inference to be made. Pre-and postdominator relationships among flow\u00adgraph nodes are used \nto partition the set of nodes into super blocks with the property that if any node in a super block is \ncovered then all nodes in that super 11~ is ~=e ~ the .+tatcmentproblem a$ covering coverage ~ basic \nblocks implies covering all statements, and vice versa. el; while (e2) { switch (e3) { case 1: e% break; \ncase 2: e5; while (e6) e7; default: if (;3) { ho elO; while (en); e12; } e13; } el 4: Figure 1: An example \nC program block are covered. Super blocks are different from basic blocks in that a super block may contain \nseveral basic blocks. A dominator relationship among super blocks is defined and used to identify a subset \nof the super blocks such that covering the subset implies covering all super blocks and, in turn, covering \nall basic blocks. Analogous techniques are developed to partition the set of edges and determine a subset \nof the partitions such that covering the latter implies covering the former. Experiments using these \ntechniques on eight systems varying in size from a 1,000 to 75,000 lines of C code indicate that these \ntechniques are quite promising (see Section 7, Experimental Results). It was found that, on the average, \ntest cases targeted to cover just 29% of the basic blocks and 32% of the branches chosen by these techniques \nensure 100~o block and branch coverage, re\u00adspectively. Moreover, these techniques also provide an ordering \namong the targeted basic blocks so covering the first one third of the targeted blocks, on the aver\u00adage, \nimplies covering more than two thirds of all blocks. In the next section, we briefly review the terminology \nused in the this paper. In Section 3, we discuss tech\u00adniques to identify a subset of the basic blocks \nwhose coverage implies that of all basic blocks. Then, in Sec\u00adtion 4, we describe how to find the order \nin which the basic blocks identified should be covered. Section 5 dis\u00adcusses how these techniques may \nbe used to reduce the time and space overhead involved in computing the cov\u00aderage attained by a given \ntest set. In Section 6, we present how the analogous techniques may be used to expedite branch coverage. \nSection 7 includes the results of our preliminary experiments and Section 8 compares our work with the \nrelated work in the literature.  Background A control flowgraph, or simply, a flowgraph, of a pro\u00adgram \nis a four-tuple (N, E, entry, exit) where N is exit Figure 2: Control flowgraph the set of nodes that \ncorrespond to basic blocks in the program, E is the set of directed edges between nodes, and entry and \nexit are two distinguished nodes in N. Every node in N is reachable from the entry node and the ed node \nis reachable from every node by following edges in E. Figure 2 shows the flowgraph of an example C program, \nshown in Figure 1, where el, e2, . . . . e14 are blocks whose contents are not relevant for our purposes. \nA node, u, predominates a node, ,, v, denoted as u ~ v, if every path from the entry node to v con\u00adtains \nU2. A node, w, postdominates a node, v, denoted as w = v, if every path from v to the ezit node con\u00adtains \nw. For example, in Figure 2, nodes 1, 2, and 3 pre\u00addominate node 8 and nodes 2 and 14 postdominate it. \nPre-and postdominator relationships can be expressed in the form of pre-and post dominator trees, respec\u00adtively. \nu C v ifl there is s path from u to v in the predominator tree. Similarly, w ~ v ifl there is path from \nw to v in the postdominator tree. Figures 3 and 4 show the pre-and postdominator trees of the flowgraph \nin Figure 2. Many algorithms have been developed to find pre\u00addominator relationships among nodes of a \nflowgraph [3, 9, 12, 16]. As the postdominator relationship is the same as the predominator relationship \nin the reverse flowgraph, the same algorithms may also be used to find postdominator relationships. The \npredominator tree of a flowgraph may be built in O(N + E) time, where N and E denote the number of nodes \nand edges in the flowgraph, respectively [9]. The same applies for the post dominator tree. 2The predominator \nrelationship is also referred to as the dom\u00adinator relationship at other places in the literatme. In \nthis paper, we refer to it as the predominator relationship to clearly distin\u00adguish it from the postdorninator \nrelationship. We use the term dominator relationship here to mean either pre-or postdorninator relationships. \n 1 o m 6 10 b9 87 11 i 12 Figure 3: Predominator tree 3 Expediting Block Coverage 3.1 Pre-and Postdominators \nA node, u, in a flowgraph is said to be covered by a test case, t, denoted as covered( u, t), if the \ncontrol reaches the corresponding basic block at least once when the program is executed on t. If u = \nv and v is covered by tthen u must also be covered by t, as every execution path from the entry node \nto v cent ains u. In other words: Zf u ~ v then covered(o, t) ~ covered(u, f) (1) Equivalently, whenever \na node in a flowgraph is covered then all its ancestors in the predominator tree are also covered. Thus, \nif all leaves in the predominator tree are covered then all other nodes in the flowgraph are automatically \ncovered. A tester, therefore, only needs to develop test cases meant to exercise the leaves of the predominator \ntree. The same arguments hold if we substitute the post\u00addominator relationship wherever the predominator \nre\u00adlationship was used in the previous paragraph, provided the program execution terminates normally \non all test cases supplied. Thus we also have the following, pro\u00advided the termination condition holds: \ni$ u ~ v then covered(v, t) ~ covered(u, t) (2) The condition that the execution normally terminate \non all test cases supplied does not cause any adverse problems for our purposes here. The goal of testing \nis to detect faults in a program. If the tester supplies a test case on which the execution does not \nterminate, or terminates abnormally, it is indicative of a fault in the program. The fault should then \nbe fixed so the corrected program terminates normally on the same test case3. 3Changes to a program may \nrequire that its flowgraph as well as the pre-and postdominat or trees be rebuilt. 10 o Figure 4: Postdominator \ntree Therefore, in the remainder of this paper we assume that the program execution terminates normally \non all test cases supplied by the tester. A coverage testing tool may build both the pre-and postdominator \ntrees of the program under test, compare the number of leaves in the two trees, and have the tester cover \nthe smaller of the two sets. For example, for the flowgraph in Figure 2, the predominator tree in Figure \n3 has six leaves whereas the postdominator tree in Figure 4 has seven leaves. Thus, in this case, a tester \nonly needs to develop test cases targeted to cover the six leaves in the predominator tree. 3.2 Super \nBlock Dominators We say that a node, u, dominates a node, v, denoted as u + V, if every path from entry \nto exit, via v, contains u. Clearly, u dominates v iff u pre-or post dominates v, for if this were not \ntrue, we would have a path from the entry to the exit node via v bypassing u altogether. In other words: \nu+vifl(u JUvoru P~v) (3) Thus, the dominator relationship among flowgraph nodes is the union of pre-and \npostdominator relation\u00adships. It may be represented graphically by merging the pre-and postdominator \ntrees of the flowgraph. We call the union of the pre-and postdominator trees as the basic block dominator \ngraph of the corresponding flow\u00adgraph. Figure 5 shows the basic block dominator graph of the flowgraph \nin Figure 2, obtained by merging the pre-and postdominator trees of Figures 3 and 4, re\u00adspectively. A \nnode, u, dominates another node, v, in a flowgraph ifl there is a path from u to v in its basic block \ndominator graph. As the name suggests, a basic block dominator graph may not necessarily be a tree. Moreover, \nit may not be acyclic either. A strongly connected component of a basic block dominator graph has the \nproperty that every node in Figure5: Basic block dominator graph A 1,2,14 Q B c D 6 L- 8  Figure 7: \nSuper block dominator graph with the initial weights associated with the leaves. the component dominates \nall other nodes in that compo\u00adnent. For example, nodes {1, 2, 14} form a strongly con\u00adnected component \nof the basic block dominator graph in Figure 5. Strongly connected components of a graph may be found \nin O(N + E) time where N and E denote the number of nodes and edges in the graph, respec\u00ad tively [2]. \nAssertions (1), (2), and (3), in turn, imply: if u -v then covered(w, t) =+ covered(u, t) (4) This, \ncoupled with the fact that each node in a strongly connected component dominates all other nodes in that \ncomponent, implies that whenever any node in a com\u00ad ponent is covered by a test case then all other nodes \nin that component must be covered by the same test case. We refer to the strongly connected components \nof a basic block dominator graph as super blocks, as they are made up of one or more basic blocks. Any \none basic block in a super block may be designated as the repre\u00ad sentative of that super block. D F6 \n7 Figure 6: The graph obtained by merging the strongly connected components of the basic block dominator \ngraph D w 3 Figure 8: Highlighted blocks show the covered blocks after the initially heaviest leaf is \ncovered. New weights of the remaining leaves are also shown. Unlike basic blocks super blocks need not \nbe contigu\u00adous. They may have multiple entry and multiple exit points. If a program instruction inside \na basic block is executed, all other instructions in that basic block must be executed before the control \nleaves that basic block. On the other hand, if a program instruction in a super block is executed, all \ninstructions in that super block must be executed before the exit node is reached. Just as with basic \nblocks, we also define dominator relationships among super blocks. A super block, U, dominates another \nsuper block, V, denoted as U + V, if e~ery path from the entry to the exit node via V in the flowgraph \nalso cent ains U. Thus we also have: if U + V then covered(V, t) * covered(U, t) (5) Recall that if \na path contains any basic block in a su\u00adper block then it cent ains all basic blocks in that super block. \nDominator relationships among super blocks may be represented graphically in the form of a super block \ndom\u00ad 6 3 6 13 10, 11 o Figure 9: Super block dominator graph involving a sub\u00adset of basic blocks. inator \ngraph. It is obtained by merging the nodes in the strongly connected components of the corresponding \nba\u00ad sic block dominator graph and removing the composite edges from the resulting graph4. An edge, e, \nfrom a node, u, to a node, v, is said to be a composite edge if v is also reachable from u without going \nthrough e. In case there are multiple edges from one node to another, all but one of them are considered \ncomposite edges. In other words ~a composite edge represents a composition of one or more other edges. \nFigure 6 shows the graph obtained by merging the strongly connected components of the graph in Figure \n5. It has several composite edges, e.g., the edges from node A to nodes C, D, and H are all composite \nedges. One of the two edges from node A to node B is also a com\u00ad posite edge. Figure 7 shows the super \nblock dominator graph of the basic block dominator graph in Figure 5, obtained by removing the composite \nedges in the graph in Figure 6. Note that unlike a basic block domina\u00ad tor graph a super block dominator \ngraph is an acyclic graph. But unlike pre-and postdominator trees it need not be a tree. It can be shown \nthat each basic block dominator graph has a unique super block dominator graph. Assertion (5) implies \nthat covering all the leaves in the super block dominator graph implies covering all other super blocks \nas well. A tester, therefore, only needs to develop test cases aimed at covering one basic block from \neach leaf in the super block dominator graph. For example, for the flowgraph in Figure 2, one only needs \nto create test cases that cover basic blocks 4, 7, 9, and 10 one each from the leaf nodes in its super \nblock dominator graph in Figure 7. 3.3 Selective Coverage Sometimes a tester may need to cover a set \nof specific basic blocks rather than the set of all basic blocks. In this case a new dominator graph \nmay be obtained by projecting the program s super block dominator graph 4 Equivalently, the super block \ndorninat or graph of a flowgraph may be obtained by findng the condensed graph of its basic block dominator \ngraph and obtaining the minimum equivalent graph of the condensed graph [13]. ,rJOO/ot. ................................. \n.. .....................    iijw +--fl > 8 ~ 600/0 o E .=? 40% m -i E 2.70 : 3 v IT v1 1 1 10 7 \nbasic-block coverage order Figure 10: The order in which the targeted basic blocks are covered and the \ncorresponding cumulative coverages achieved. over the given basic blocks. The tester then only needs \nto develop test cases that cover the leaves of the pro\u00ad jected dominator graph. For example, suppose \nwe need to develop test cases that cover nodes 3, 6, 10, 11, and 13 in the flowgraph in Figure 2. Figure \n9 shows the super block dominator graph obtained by projecting that in Figure 7 over the above five blocks. \nAs the projected graph has only two leaves, we only need to develop test cases that cover the corresponding \ntwo basic blocks 6 and 10, or alterna\u00ad tively, 6 and 11. 4 Deciding the Right Order Oftentimes, due to \nthe lack of time and other resources, testers are content with attaining some desired fraction of 100% \ncoverage, e.g., 70% or 80Y0. In such situations, how does one find the smallest subset of the leaves \nof the super block dominator graph whose coverage implies the desired overall coverage? The above problem, \nin general, is an NP-complete problem [6]. But we can use the greedy approach to get good approximate \nanswers. We can associate weights with the leaves of the super block dominator graph. Weight of a leaf \nis defined to be the total number of basic blocks in the leaf and all its uncovered ancestors in the \nsuper block dominator graph. Initially, all super blocks are marked as uncovered. Figure 7 also shows \nthe initial weights associated with the leaves of the su\u00adper block dominator graph. We select the leaf \nwith the largest weight to be cov\u00adered first as covering it implies maximum number of basic blocks to \nbe covered. If there are more than one heaviest leaves any one of them may be selected. Then the selected \nleaf and all its ancestors are marked as covered, Next, the weights of the remaining uncovered Probe(U) \n{ If U has fewer than two children in the super block dominator graph Then return true; 1* check if \nthere exists a path via U that bypasses all super blocks dominated by U */ Mark all nodes in the flowgraph \nas unvisited Mark a representative basic block, r, of U as visited Mark representatives of the children \nof U in the super block dominator graph as visite~ Vlsit_predecessors(r); Visit_successors(r);  If \nboth the entry and the exit nodes of the flowgraph are marked as visited Then return truq Else return \nfalse; ) Visit_predecessors(n) Visit_successors(n) {{ For each immediate predecessor, p, For each immediate \nsuccessor,s, of node n in the flowgraph Do of node n in the flowgraph Do If p is not marked as visited \nThen Ifs is not marked as visited Then {{ Mark pas visitd, Marks as visited; Visit_predecessors(p); Visit_successors(s); \n11 }} Figure 11: An algorithm to check if a super block should be probed leaves are recomputed and the \nheaviest leaf among these is selected to be covered. This process continues until the desired coverage \nlevel has been achieved. Figure 8 shows the super block dominator graph with covered blocks highlighted \nafter the initially heaviest leaf is cov\u00adered. It also shows the new weights of the remaining leaves. \nThe graph in Figure 10 shows, along its horizontal axis, the order in which the desired basic blocks \nof the flowgraph in Figure 2 should be covered5. Along the vertical axis, it shows the cumulative overall \ncoverage after each of these blocks is covered. Note that cov\u00adering just two (14 To) of the basic blocks, \nviz., 10 and 7, gives us more than 85% coverage and covering two more (29Yo) ensures that all fourteen \nbasic blocks are covered. This means at most four test cases need to be developed to cover all basic \nblocks. In practice, how\u00adever, even fewer test cases may be needed as a test case developed to cover \na leaf may cover other blocks besides the leaf and its ancestors. In particular, techniques de\u00adscribed \nin [8] may be used to further reduce the number of test cases needed to cover the basic blocks identi\u00adfied \n(see Section 8). For example, for the flowgraph in Figure 2, it may be possible to create a single test \ncase that covers all basic blocks. Thus, the curve in Figure 10 5 Alternatively, the order 10, 7, 4, \n9 may be used. Multiple orderings are possible whenever at any step in the process more than one leaves \nhave the largest weight. gives us a lower bound on the cumulative coverage levels achieved by following \nthe above technique.  5 Selecting the Right Probes In order to determine which basic blocks are covered \nby a test set, coverage tools insert probes at various pro\u00adgram locations, usually one per basic block \n(see, how\u00adever, Section 8) [10]. Probes obviously increase the size of the program s object code as well \nas its execution time. If we reduce the number of probes inserted in a program we also reduce its object \ncode size and the runtime overhead. In Section 3.2, we saw that a basic. block in a super block is covered \nifl all basic blocks in that super block are covered. Thus, it is sufficient to place one probe per super \nblock instead of placing one probe per basic block. It is, however, not necessary to probe all super \nblocks. A super block, U, need not be probed if it satisfies the following condition: A test case that \ncovers U must also cover one of its children in the super block dominator graph, i.e.: covered(U, -t) \n=+-3V 3 U ---+ V, couered(V, t) (6) We need not probe U above because its coverage maybe inferred from \nthat of V. Super blocks that do not satisfy the above condition, however, must be probed. As a Figure \n12: Edge predominator tree a s  E2?w @Y-w Figure 14: Edge dominator graph leaf in a super block dominator \ngraph has no children, it may never satisfy the above cond;tion. Thus it must be probed. An internal \nnode, on the other hand, may or may not satisfy the above condition. For example, super block B in Figure \n7 satisfies the above condition as it is impossible to cover it without also covering one of its two \nchildren super blocks C and H. Thus super block B need not be probed. Super block E, on the other hand, \nmust be probed as it is possible to cover it without covering any of its children we may have a test \ncase that covers basic blocks 5 and 6 but not 76. The flowgraph in Figure 2 shows that that this is indeed \npossible. As in the case of a leaf node, an internal node that has just one child node may never satisfy \nCondition (6). If it did then every time it is covered its unique child node would be covered as well. \nThis would imply that GNote that ~tho~gh it is desirable to develop test cases that cover one or more \nleaves in the super block dorninat or graph, the tester may supply test cases that do not cover any. \nThey should, nevertheless, be able to find the true overall coverage irrespective of whether or not the \ntest cases cover any leaves in the dorninat or graph. n om Jil Figure 13: Edge post dominator tree a,s \nQ b e,f,i k,I r j g,h c,d m,n,p, C% Figure 15: Edge partition dominator graph the child node dominates \nthe parent node. As a parent node always dominates a child node, it would mean both the parent and the \nchild node are in the same super block a contradiction. Thus all nodes that have just one child node \nmust be probed. Most nodes with two or more children do satisfy Con\u00addition (6) and thus they need not \nbe probed. There may, however, be exceptions. Fortunately, they are relatively few in number (see Section \n7) and we can identify them. Figure 11 includes a simple algorithm to check if a node in a super block \ndominator graph should be probed. It takes O(N+ E) time where N and E denote the number of nodes and \nedges in the graph. The super block dominator graph in Figure 7 does not have any nodes with two or more \nchildren that need to be probed. It does, however, have two internal nodes with one child node each that \nmust be probed super blocks A and E. Thus, in this example, we only need to probe six basic blocks 1, \n4, 5, 7, 9, and 10 one each from the four leaves and the two internal nodes mentioned above. Whenever \na probe is reached during the program 31 program basic blocks super-block leaves block probes edge-partition \nleaves edge probes required Sorl 455 138 30% 152 33% 195 zl~o 197 32\u00b0h spiff 1266 361 29% 404 32% 458 \n290/. 462 29% mgr 3848 1043 27% 1233 327. 1579 31% 1602 Zlyo ion 4886 1280 26% 1507 31% 1697 27~o 1740 \n28 XO atac 8737 2574 29% 2971 34?40 3553 30% 3645 31~o odin 9870 2344 zdyo 2944 30% 3575 29% 3623 30% \nxlib 15580 5111 3370 6016 39% 7435 36% 7525 36?40 tvo 17680 6267 35?!0 8150 46V0 11783 45~o 11796 4570 \nTable 1: Experimental results execution, all basic blocks in the corresponding super block and all its \nancestors in the super block dominator graph are marked as covered. The coverage achieved at any given \ntime, then, maybe computed by counting the number of basic blocks marked as covered at that time. Consider, \nagain, our example flowgraph in Fig\u00adure 2. Suppose the very first test case developed causes the path \n<1, 2, 14> to be executed7. This causes the probe at basic block ltobemarked as covered, which, in turn, \ncauses basic blocks 2 and 14 to be marked as covered as they belo~g to the same super block as basic \nblock 1. Thus coverage at this time may be correctly computed as 3/14, or 21~o. Next, suppose another \ntest case causes the execution path <1, 2, 3, 8, 10, 11, 12, 13, 2, 14> to be executed. As the probe \nat basic block 1 was already marked covered by the previous test case, this test case causes the probe \nat basic block 10 to be marked as covered. This, in turn, causes five new basic blocks to be marked as \ncovered 3, 8, 11, 12, and 13 raising the count of covered basic blocks to 9. Therefore, the coverage \nat this time is again computed correctly as 9/14, or 64?lo. Expediting Branch Coverage The techniques \ndescribed so far may also be used to expedite branch coverage we only need to find pre\u00adand postdominator \nrelationships among edges instead of nodes. Figures 12 and 13 show the edge pre-and post dominator trees, \nrespect ively, of the flowgraph in Figure 2. Figure 14 shows the edge dominator graph obtained by merging \nthe two trees. As in the case of a basic block dominator graph, we may also find the strongly connected \ncomponents of an edge dominator graph. We refer to these components as edge partitions. An edge in an \nedge partition is covered by a test case zff 7Note that this t~~t c~e does not exercise any leaves in \nthe super block dominator graph. A tester should be able to find out the correct coverage achieved at \nany time regardless of whether or not any leaves have been covered. all edges in that partition are covered \nby that test case. Figure 15 shows the edge partition dominator graph ob\u00adtained by merging the strongly \nconnected components of the edge dominator graph in Figure 14 and removing the composite edges from the \nresulting graph. In this example, the edge partition dominator graph is a tree but, in general, it maybe \na directed acyclic graph. Note that a tester only needs to develop test cases targeted to cover five \nedges, one each from the five leaves in Fig\u00adure 15. The remaining fourteen edges are automatically covered \nby the same test cases. As in the case of block coverage, space and time over\u00adhead of measuring branch \ncoverage may also be reduced by placing one probe per leaf and certain internal nodes where covering \nthe corresponding edge partition does not imply covering at least one of its children. 7 Experimental \nResults To evaluate the effectiveness of the techniques proposed here, we incorporated them into a prototype \ntool, SPY-DER [1], that provides dynamic program slicing facilities for C programs. We used it to find \nthe number of leaves and internal nodes in the super block dominator graph and the edge partition dominator \ngraph that need to be probed for eight diverse systems and library packages whose source codes were locally \navailable. These sys\u00adtems varied in size from about 1,000 to 75,000 lines of C code. Table 1 lists the \nresults. Note that the num\u00ad ber of leaves in a super block dominator graph, on the average, is about \n29% of the number of basic blocks. This means, in order to achieve 100% block coverage, testers testing \nthese systems only need to develop test cases targeted to cover, on the average, 29~0 of the ba\u00adsic blocks. \nIn case an automatic test case generator is used, it only needs to generate test cases to cover 29 % \nof the basic blocks. Also note that the number of probes required is, on the average, 3570 of the number \nof basic blocks. Thus, only 6% internal nodes need to be probed 100% -L in addition to the leaf nodes. \n.- Similarly, the number of leaves in an edge partition dominator graph, on the average, is about 32% \nof the number of edges. This means, in order to achieve 100~0 branch coverage, testers testing these \nsystems only need to develop test cases targeted to cover, on the average, 32% of the branches. Also, \nthe number of edge probes required is, on the average, 33% of the number of edges. Thus only l% additional \nbranches, besides the leaves in the edge partition dominator graph, need to be proved. Figure 16 shows \nthe analogue of Figure 10 for the sort program. Note that the first one third of the 30% tar\u00adgeted blocks \nprovide more than 75% coverage. Recall that the curve in this graph gives us a lower bound on the cumulative \ncoverages achievable. The actual curve, represented by the dotted curve, depends on the par\u00adticular test \ncases developed but it always lies above the solid curve. Thus the actual savings in the number of test \ncases that need to be developed are always higher than that implied by the solid curve. As coverage testing \nis generally performed during the unit testing phase, the numbers presented above are computed assuming \nthat each program unit is tested in isolation. In other words, they are computed based on intraprocedural \ncontrol flow analysis. But oftentimes, multiple units are tested together even during unit test\u00ading. \nIn these situations, we may further increase the savings by performing interprocedural analysis, as cov\u00ad \nering a block in one unit may imply covering several blocks in other units as well.   Related Work \nWe are not aware of any reference in the literature that addresses the problem discussed here although \nseveral references are available on the related problem of opti\u00admal program profiling [4, 7, 11, 15, \n17]. Program pro\u00adfiling involves determining the frequency counts of flow\u00adgraph nodes and edges when \nit is executed on a given test set. Clearly, if we have the frequency counts of all nodes and edges we \nknow which of them are covered and which not. Optimal profiling techniques are aimed at finding small \nsubsets of nodes/edges in a flowgraph such that if the frequency counts of the nodes/edges in the subset \nare known, the frequency counts of other nodes/edges may be inferred from them. Note, however, that cover\u00ading \nthe nodes/edges in a subset identified by these tech\u00adniques does not imply covering all other nodes/edges. \nIt simply means we can find out whether or not other nodes/edges are covered if know the frequency counts \nof those in the subset. Thus we may not use these tech\u00adniques to reduce the time spent developing test \ncases. Also note that with optimal profiling techniques, sim\u00ad ,,. F 800/0 --/ ~ a > 0 0 +j 600/0 --, \n 0 , z , .g 40% --; ~ 5 I! I I\\ !I 50/. t O% 15% 20% 25~o 30~o target basic-blocks Figure 16: Coverage \nrate for sort ply knowing whether or not nodes/edges in the sub\u00adset are covered is not sufficient to \ninfer whether or not others are covered we must capture how many times the nodes/edges in the subset \nare executed. With the techniques presented in this paper, on the other hand, simply knowing whether \nor not the nodes/edges in the subset are covered is enough to find out whether or not others are covered. \nTherefore, with our techniques, a probe may be removed after the first time it is reached. It need not \nbe executed every time the control reaches the corresponding program location. We know of only one other \nreference, [8], that also addresses the selective coverage problem discussed in Section 3.3 although \nin the context of automatic test case generation. It uses a generalization of the post\u00addominator relationship \nbetween nodes to that between sets of nodes to guide the generation of test cases that cover a given \nset of nodes. A sequence VI, V2, . . . . V~ of sets of nodes is determined such that u+ I post dom\u00adinates \nJj, 1 ~ i < n 1, and each ~ contains at least one node from the relevant set of nodes to be covered. \nFirst a test case that covers one or more relevant nodes in VI is generated. Then, if possible, it is \nextended so it also covers one or more relevant nodes in V2; and so on. The process is continued until \nall relevant nodes have been covered. The above approach is complimentary to the ap\u00adproach taken in \nthis paper. The latter may be used first to find a subset of the relevant nodes such that covering the \nsubset would imply covering all the rele\u00advant nodes. Then, the above approach may be used to find as \nfew test cases as possible to cover this subset. For instance, in the case of the example in Section \n3.3, instead of applying the above approach to the relevant set of five nodes, {3, 6, 10, 11, 13}, we \nonly need to apply it over a relevant set of two nodes, {6, 10}.  Summary In this paper we have presented \nsome techniques that may help expedite both block and branch testing of pro\u00adgrams. For large programs, \nthe number of basic blocks and branches that must be covered may be overwhelm\u00ading. The techniques presented \nhere help us identify a significantly smaller subset of relatively high effi\u00adciency blocks and branches \nsuch that covering them implies that other blocks and branches are automati\u00adcally covered. The same techniques \nmay also be used to reduce the number of probes pIaced in a program in order to find out which blocks \nand branches have been covered. This helps reduce the object code size and the runtime overhead imposed \nby coverage testing tools. Preliminary experiments have shown that these techniques may indeed be very \neffective in saving both the user and the system time spent during coverage test\u00ading of programs. More \nexperimentation is required to evaluate how well testers are able to exploit these tech\u00adniques in reducing \nthe number of t est cases they develop. Also, it would be interesting to determine how well these techniques \nperform compared to a heuristic approach, such as covering the most deeply nested blocks first. Acknowledgements \nWe would like to thank Bob Horgan and Norman Ram\u00adsey for their helpful comments on an earlier draft of \nthis paper. We would also like to thank the anony\u00admous referees for their useful suggestions on improving \nits present ation. References [1]H. Agrawal, R. A. DeMillo, and E. H. Spafford. Debugging with dynamic \nslicing and backtracking. Software Practzce and Experience, 23(6):589-616, June 1993. [2] A. V. Aho, \nJ. E. Hopcroft, and J. D. Unman. Data Structures and Algorithms. Addison-Wesley, 1983. [3] A. V. Aho, \nR. Sethi, and J. D. Unman. Compd\u00aders: Principles, Techniques, and Tools. Addison-Wesley, 1986. [4] T. \nBall and J. R. Larus. Optimally profiling and tracing programs. In Conference Record of the Nineteenth \nACM Symposium on Principles of Programming Languages (POPL 92), pages 59-70. ACM Press, Jan. 1992. [5] \nR. A. DeMillo, W. M. McCracken, R. J. Martin, and J. F, Passafiume. Sofiware Testzng and Evalu\u00adation. \nBenjamin/Cummings Publishing Co., 1987. [6] M. R. Garey and D. S. Johnson. Computers and Intractability: \nA Giude to the Theory of NP-Completeness. Freeman, 1979. [7] S. L. Graham, P. B. Kessler, and M. K. McKusick. \nAn execution profiler for modular programs. Soft\u00adware Practice and Experience, 13:671 685, 1983. [8] \nR. Gupta. Generalized dominators and post\u00addominators. In Conference Record oj the Nine\u00adteenth ACM Symposium \non Principles of Program\u00adming Languages (POPL 92), pages 246 257. ACM Press, Jan. 1992. [9] D. Harel. \nA linear time algorithm for finding dom\u00adinators in flow graphs and related problems. In Proceedings of \nthe 17th ACM Symposium on The\u00adory of Computing, pages 185 194, May 1985. [10] J. R. Horgan and S. L. \nLondon. ATAC: A data flow coverage testing tool for C. In Proceedings of the Symposium on Assessment \nof Quality Software Development Tools, pages 2 10. IEEE Computer Society Press, May 1992. [11] D. E. \nKnuth and F. R. Stevenson. Optimal mea\u00adsurement points for program frequency counts. BIT, 13:313-322, \n1973. [12] T. Lengauer and R. E. Tarjan. A fast algorithm for finding dominators in a flowgraph. ACM \nTrans\u00adactions on Programming Languages and Systems, 1(1):121-141, July 1979. [13] D. M. Moyles and G. \nL. Thompson. An algorithm for finding a minium equivalent graph of a digraph. Journal of the ACM, 16(3):455-460, \nJuly 1969. [14] G. J. Myers. The Art of Software Testzng. John Wiley &#38; Sons, 1979. [15] R. L. Probert. \nOptimal insertion of software probes in well-delimited programs. IEEE Transa etions on Software Engineering, \nSE-8(1):34-42, Jan. 1982. [16] P. W. Purdom, Jr. and E. F. Moore. Immediate predominators in directed \ngraphs. Communica\u00adtions of the ACM, 15(8):777 778, Aug. 1972. [17] C. V. Ramamoorthy, K. H. Kim, and \nW. T. Chen. Optimal placement of software monitors aiding sys\u00adtematic testing. IEEE Transactions on Software \nEngineering, SE-1(4):403-411, Dec. 1975.  \n\t\t\t", "proc_id": "174675", "abstract": "<p>In this paper we present techniques to find subsets of nodes of a flowgraph that satisfy the following property: A test set that exercises all nodes in a subset exercises all nodes in the flowgraph. Analogous techniques to find subsets of edges are also proposed. These techniques may be used to significantly reduce the cost of coverage testing of programs. A notion of a super block consisting of one or more basic blocks in that super block must be exercised by the same input. Dominator relationships among super blocks are used to identify a subset of the super blocks whose coverage implies that of all super blocks and, in turn, that of all basic blocks. Experiments with eight systems in the range of 1-75K lines of code show that, on the average, test cases targeted to cover just 29% of the basic blocks and 32% of the branches ensure 100% block and branch coverage, respectively.</p>", "authors": [{"name": "Hiralal Agrawal", "author_profile_id": "81452609139", "affiliation": "Bellcore, Morristown, NJ", "person_id": "P110654", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/174675.175935", "year": "1994", "article_id": "175935", "conference": "POPL", "title": "Dominators, super blocks, and program coverage", "url": "http://dl.acm.org/citation.cfm?id=175935"}