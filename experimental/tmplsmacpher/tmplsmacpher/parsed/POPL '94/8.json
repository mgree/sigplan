{"article_publication_date": "02-01-1994", "fulltext": "\n Proving Concurrent Constraint Programs Correct Frank S. de Boer* Maurizio Gabbriellit Free University \nCWI Abstract We develop a compositional proof-system for the par\u00adtial correctness of concurrent constraint \nprograms. Soundness and (relative) completeness of the system are proved with respect to a denotational \nsemantics based on the notion of strongest postcondition. The strongest postcondition semantics provides \na justifica\u00adtion of the declarative nature of concurrent constraint programs, since it allows to view \nprograms as theories in the specification logic.  Introduction Concurrent constraint programming ([24, \n25, 26]) (ccp, for short) is a concurrent programming paradigm which derives from replacing the store-as-valuation \nconception of von Neumann computing by the store\u00adas-constraint model. Its computational model is based \non a global store, represented by a constraint, which expresses some partial information on the values \nof the variables involved in the computation. The con\u00adcurrent execution of different processes, which \ninteract through the common store, refines the partial informa\u00adtion of the values of the variables by \nadding (teliing) constraints to the store. Communication and synchro\u00adnization is achieved by allowing \nprocesses also to test (ask ) if the store entails a constraint before proceeding in the computation. \nOne of the most characteristic features of the ccp paradigm is a formalization of the basic operations \n*Free University, de Boelelaan 1081, 1081 HV Amsterdam, The Netherlands. e.mail: frankbCQcs.vu.rd t CWI, \np,o, BOX 94079, 109o GB Amsterdam, The Nether\u00adlands. e.mail: gabbri@cwi.nl $CWI, P.O. Box 94079, 1090 \nGB Amsterdam, The Nether\u00adlands. e.mail; elena@cwi.nl ~Dip. di Informatica e Scienze dell kformazione, \nVia Benedetto XV, 3, Geneva, Italy. e.mail: catuscia@Mi.unipi.it Permission to copv without fee all \nor part of this material is granted providad that the copies are not made or distributed for, direct \ncommerci.s! advantaga, tha ACM copyright notica and tha title of the publication and its data appear, \nand notice is given that copying is by permission of the Association for Computing Mac+rinary. To copv \notharwise, or to republish, raquirea a fae andor specific permission. POPL 94-l&#38;4, Portland Oregon, \nUSA Elena Marchiori$ Catuscia Palamidessi$ CWI DISI which allow to update and to query the common store, \nin terms of the logical notions of consistency, conjunc\u00adtion and entailment supported by a given underlying \nconstraint system. An intriguing question however is to what extent the incorporation of synchronization \nmechanisms that are intended to describe flow of con\u00adtrol features, still allows a declarative interpretation \nof ccp programs, i.e. to view a program as a logical theory and the output of its computations as its \nlogical consequences. From a purely semantical point of view, there is no clear evidence of a declarative \ninterpretation. Indeed the semantic structures needed to give compositional (fully abstract) models for \nthe standard input/output behaviour of ccp programs are similar to those used, for example, for imperative \nlanguages bas~d on asyn\u00adchronous communication mechanisms ([6] ) and are es\u00adsentially more complicated \nthan those used for pure (constraint) logic languages ([3, 17]). It should be noted that for the deterministic \nfragment of ccp there exists an elegant denotational semantics based on clo\u00adsure operators [26], which \nin [21] are shown to be in\u00adtimately related to the logic of constraints. The main result of this paper \nis the introduction of a proof-theory for ccp, i.e. a calculus for proving correctness of ccp programs \n(or, in other words, an axiomatic semantics) which does provide a declarative interpretation of ccp. \nThe issue of the design of proof systems appropriate to proving correctness of ccp pro\u00adgrams has received \nno attention so far. For logic lan\u00adguages like Prolog the proof techniques of Hoare-Logic ([16]) have \nbeen applied in [10] to reason about prop\u00aderties of the flow of control and a process algebra for ccp \nhas been developed in [8] along the lines of ACP ([5]). The focus of this paper concerns more generally \nthe development of calculi for the correctness of ccp programs with respect to a first-order specification \nof what the program is supposed to compute. A proof-theory for a concurrent imperative language in general \nrelates the how , that is, the flow of con\u00adtrol described by a program, to the what , a speci\u00adfication \nof the program in some (usually first-order) logic. To relate these two different worlds, the store\u00adas-valuation \nsemantics (or state-based semantics, for short) of an imperative program is lifted to a pred\u00adicate transformer \nsemantics based on the notion of @ 1994 ACM O-89791 -636-9t94/ool ..$3.50 the weakest precondition or, \nequivalently, the stTongest postcondition ([12]). Since the standard semantics of ccp can already be \nviewed as a predicate (i.e., store-as\u00ad constraint) transformer semantics it is rather natural to expect \nthat the semantics itself can be used to prove correctness of programs. This then would provide a strong \nevidence for the declarative nature of ccp. Unfortunately one can argue that the above sug\u00ad gested expectation \nis not justified. Consider the fol\u00ad lowing simple ccp program: (ask(z = O) ~ Mt(y = 1)) + (ask(z = 1) \n~ tell(y = 1)) This program adds y = 1 to the store in case the initial store either entails z = O or \nz = 1 (otherwise it sus\u00adpends). Thus one would like to state that the above program satisfies the specification \n(z = O V z = 1) -+ y = 1, i.e. every terminating computation results in a store such that whenever x \n= Oor z = 1 then y = 1 is guaranteed to hold. However this correctness state\u00adment cannot be justified \nsemantically: Intuitively the tell operation -tell(z = O V z = 1) satisfies the spec\u00adification z = O \nV z = 1. Thus one would expect the parallel composition ( (adc(z = O) --+ tell(y = 1)) + (ask(z = 1) \n+ tetl(y = 1)) ) II teil(z = OV z= 1) to satisfy (tz=OVz =l)A((z =OVz=l)+y=l) which would imply y = \n1. However the above parallel program does not satisfy y = 1 since z = OV z = 1 nei\u00adther entails z = \nO nor z = 1, so the program will sus\u00adpend after the tell action. This simple example shows that one cannot \nreason about the non-deterministic choice in terms of the disjunction of the underlying constraint system. \nIn this paper we introduce a specification logic to reason about the correctness of ccp programs in terms \nof properties of constraints. A property is described in terms of constraints themselves and the usual \n(classi\u00adcal) logical operations of negation, conjunction and existential quantification. A property described \nby a constraint is interpreted as the set of constraints that entail it (here the entailment relation \nstems from the underlying constraint system). The logical op\u00aderations of disjunction, negation et c, \nthen are inter\u00adpreted in terms of the corresponding set-theoretic op\u00aderations. This definition of the \nspecification logic al\u00adlows a direct correspondence between the program\u00adming constructs of ccp and their \nlogical counterparts: For example, action prefixing corresponds to implica\u00adtion, non-deterministic choice \nto disjunction and par\u00adallel composition to conjunction. From a semantical point of view this nice correspon\u00addence \nderives from the compositionality of a notion of observable which associates to a ccp program the set \nof all its possible outputs (of terminating computa\u00adtions). This notion of observable is generally known \nin the imperative tradition as the st?ongest postcon\u00addztion of a program given the precondition tme (the \nset of all initial states). The strongest postcondition semantics of a program supports the concept of \npar\u00adtial correctness: A program P is said to be partially correct with respect to a (first-order) specification \n4 iff all terminating computations of P result in a state (or constraint) satisfying 4, i.e. the strongest \npost\u00adcondition of P is contained in the meaning of 4. A compositional axiomatization of this notion of \npar\u00adtial correctness for concurrent imperative programs requires in general the introduction of some \nkind of history variables which encode the sequence of inter\u00adactions (or communications) of a process \nwith its en\u00advironment ([30]). In contrast, the monotonic compu\u00adtational model of ccp allows to incorporate \nthe rele\u00advant assumptions about the parallel environment in the intial store, and to express logically \nthe interac\u00adtive behaviour of a process in terms of implication: A specification 4 -+ + can be interpreted \nas stating that if the environment provides 4 then $ is guaranteed to hold. The strongest postcondition \nof a ccp program pro\u00advides an abstraction of the standard input foutput behaviour of ccp programs and \nas such it allows a simple compositional semantics (parallel composition is modelled by set-theoretic \nintersection and non\u00addeterministic choice by union). Thus the strongest postcondition semantics supports \na declarative inter\u00adpretation of ccp programs, i.e. they can be viewed as theories in the specification \nlogic. The remaining of the paper is organized as follows. In the next section we introduce some basic \nnotions on ccp languages. In section 3 we formalize the concept of partial correctness for ccp programs \nby introducing a specification logic. Section 4 contains the strongest postcondition semantics and the \nproof system for ccp. In section 5 we show how the proof system can be used for the transformational \ndesign of ccp programs along the lines of [19]. Section 6 concludes. 2 Preliminaries In this section \nwe give the basic definitions of ccp lan\u00adguages following [25]. We refer to that paper for more details. \nThe ccp languages are defined parametrically wrt to a given constraint system. The notion of con\u00adstraint \nsystem has been formalized in [25] following Scott s treatment of information systems ([27]). The basic \ningredients are a set of primitive constraints D, each expressing some partial information, and a com\u00adpact \nentailment relation E defined on D. This gives basically an information system with the consistency structure \nremoved. Then, following the usual con\u00adstruction, a constraint system is obtained by consider\u00ading sets \nof primitive constraints and by extending the entailment relation on it in such a way that the re\u00ad sulting \nstructure is a complete a/ge/wait lattice. This ensures the effectiven ess of the extended entailment \nrelation. Here we only consider the resulting struc\u00ad ture. Definition 2.1 A constraint system is a complete \nal\u00adgebraic lattice (C, <, u, tree, false) where U is the lub operation, and tme, false are the least \nand the great\u00adest elements of C, respectively. Following the standard terminology and notation, instead \nof < we will refer to its inverse relation, de\u00adnoted by 1-and called entailment. Formally, Vc, d E C. \nc 1-d e d s c. In order to treat the hiding op\u00aderator of the language a general notion of existential \nquantifier is introduced which is formalized in terms of cylindric algebras ([15]). This leads to the \nconcept of cyhiTic constraint system. In the following, we as\u00adsume given a (enumerable) set of variables \nVar with typical elements z, y, z, . . .. Definition 2.2 Let (C, <, U, true, fake) be a con\u00adstraint system. \nAssume that for each z E VaT a func\u00adtion 3Z : C -+ C is defined such that for any c, d c C: (i) c t-3Z(c), \n (ii) if c f d then E&#38;(c) k 3Z(d),  (iii) %(c U %(d)) = %(c) u i(d), (iv) %(3V(C)) = 3Y(%(c)). Then \nC = (C, <, U, true, fake, VaT, ~) is a cylzndTzc constraint system. In the sequel we will identify a \nsystem C with its underlying set of constraints C. Finally, in order to model parameter passing, diagonal \nelements ([15] ) are added to the primitive constraints: We assume that, for x, y ranging in Var, D contains \nthe constraints dZY which satisfy the following axioms. (i) tme t-d==, (ii) if z # z,y then d~y = 3~(d~~ \nU d.v),  (iii) if z # y then d.v U3=(c Udm~) Rc. Note that if C models the equality theory, then the \nelements d=v can be thought of as the formulas x = y. In the following 3Z (c) is denoted by 3ZC with \nthe convention that, in case of ambiguity, the scope of 3Z is limited to the first constraint subexpression. \n(So, for instance, 3=C U d stands for 3Z(C) U d.) Definition 2.3 Assuming a given cylindric con\u00adstraint \nsystem C the syntax of agents is given by the following grammar: where the c, c% are supposed to be jinite \nconstraints (i.e. algebraic elements) in C. A ccp pTocess P is then an object of the form D.A, where \nD is a set of procedure declarations of the form p(z) :: A and A is an agent. The deterministic agents \nare obtained by imposing the restriction n = 1 in the previous grammar. The standard operational model \nof ccp can be described by a transition system T = ( Conf, --+). The configu\u00adrations (in) Conf are pairs \nconsisting of a process, and a constraint in C representing the common store. The transition relation \n+~ Conf x Conf is described by the (least relation satisfying the) rules R1-R6 of table 1. The agent \nStop represents successful termination. The basic actions are given by tel/(c) and ask(c) con\u00adstructs \nwhich act on the common store. Given a store d, as shown by rule Rl, the execution of tell(c) up\u00addate \nthe store to c U d. The action ask(c) represents a guard, i.e. a test on the current store d, whose ex\u00adecution \ndoes not modify d. We say that ask(c) is en\u00adabled in d iff d 1-c. According to rule R2 the guarded choice \noperator gives rise to global non-determinism: the agent ~~=1 ask (ci ) -i Ai nondeterministically se\u00adlects \none ask(ci ) which is enabled in the current store, and then behaves like A,. The external environment \ncan then affect the choice since ask (c) is enabled iff the current store d entails c, and d can be modified \nby other agents (rule RI). If no guard is enabled, then the guarded choice agent suspends, waiting for \nother (parallel) agents to add information to the store. The situation in which all the components of \na system of parallel agents suspend is called global suspension or deadlock. The operator II represents \nparallel compo\u00adsition which is described by rule R3 as interleaving. The agent 3zA behaves like A, with \na considered local to A. To describe locality in rule R4 the syntax has been extended by an agent 3dzA \nwhere d is a local store of A containing information on x which is hid\u00adden in the external store. Initially \nthe local store is empty, i.e. dzA = 3t UexA. Rule R5 treats the case of a procedure call when the actual \nparameter differs from the formal parameter: It identifies the formal pa\u00adrameter as a local alias of \nthe actual parameter. For a call involving the formal parameter a simple body re\u00adplacement suffices (rule \nR6) since we are dealing with a call by name parameter mechanism.  3 Properties as (sets of) con\u00adstraints \nIn this section we formalize the concept of partial cor\u00ad rectness of ccp programs. Definition 3. I Given \na constraint system C the syn\u00adtax of properties of constraints is given by the follow\u00ading grammar: Properties \nare built up from constraints and the usual logical operations. Logical disjunction (V) and implication \n(-+) are defined in the usual way: @V@ =df =(~~ A =+) and @ -+ ~ =df =4 V ~. A constraint c viewed as \na property will be interpreted as the set of constraints d that entail c, i.e. as the upward closure \nt c of c in C (wrt the < ordering). Thus a constraint d satisfies the (basic) property c iff d c T c. \nThe logical operations of conjunction and negation are interpreted in the classical way: a constraint \nc satisfies a property #A+ iff it satisfies both $ and $, a constraint c satisfies a property 14 iff \nc does not satisfy +. Furthermore, a constraint c satisfies a property 3z~ iff there exists a constraint \nd satisfying @ such that 3*c = ~zd. It is shown below that the syntactic difference between 3Z and 3Z \nindeed corresponds to a semantical differ\u00adence. Formally, the semantics of a property is defined as follows: \nDefinition 3.2 A property will be interpreted as the set of constraints which satisfy it: [cl =Tc where \nT c = {d \\ c < d}, and, for a set of constraints f, the set ~x(f) denotes {d I there exists c E ~. 3ZC \n= ~md}. Note that the semantics of ~1# is justified by observ\u00ading that in the lattice of properties, \nordered by ~, the meaning of the property false is the set {false} which acts as the greatest element, \nWe have the following theorem: Theorem 3.3 Given a (cylindrical) constraint sys\u00adtem C the set of its \nproperties is a complemented dis\u00adtributive cylindrical constraint system. Definition 3.4 A property @is \ncalled valid, notation 1= ~, iff every constraint c (of the given constraint system) satisfies the property, \ni.e. [~] = C, where C denotes the underlying constraint system. Example 3.5 A constraint e satisfies \nthe property cvd iff e entails c or e entails d. A constraint e satisfies the property 7C iff e does \nnot entail c. Note that c u d and c A d are equivalent properties, however the logical operations of \nnegation, disjunction and quantification do not in generally correspond with the operations of complement, \ngreatest lower bound, and quantification of the underlying constraint system. For example, if c n d denotes \nthe greatest lower bound of c and d then (c V d) ~ (c n d) is easily seen to be a valid property. But \nsince c n d does not entail c or d, the reverse im\u00adplication is not valid in general. A similar observation \nholds for a complemented constraint system. Also it is not difficult to see that 3XC -+ 3ZC is valid, \nbut that the reverse implication does not hold. Definition 3.6 Partial correctness assertions are of \nthe form P sat + where P is a process and ~ is a property. The semantics of an assertion P sat @, with \nP closed (namely, every procedure occurring in P is declared), is given as follows: ~ P sat@ iff SP(P) \n~ [~] where SP(P) =~,~ {d 6 C I there exist cc Cand Q s.t. (P, C) -+* (Q, d) ++ } Intuitively P sat \n4 holds iff every terminating compu\u00adtation of P (for any input c) results in a constraint d which satisfies \nthe property ~, The set SP(P) actu\u00adally describes the st?ongest postcondition of the pro\u00adgram P with \nrespect to the precondition twe (ev\u00adery constraint satisfies the property true ). The fi\u00adnal store of \na terminating computation is often called resting point because, essentially for the monotonic\u00adity of \nthe tell operation and the fact that once an ask operation is enabled it cannot be disabled, we have: \n(P, c) ---+ (Q, d) ~ iff there exists a ~derivation (P, d) +* (Q, d) j%. Then SP(P) can equivalently \nbe characterized as follows: Proposition 3.7 FOT any closed process P, S.P(P) = {d E C I there exists \nQ s.t, (P, d) + (Q, d) ~}. 4 A calculus for CCP . In order to obtain a calculus for partial correctness \nassertions, we first introduce a compositional charac\u00adterization of the operational semantics SF (P). \nTech\u00adnically such a denotational semantics is used to prove 101 RI (D.tell(c), d) -(D. Stop, c u d) \nR2 (D. ~~=lask(c, )-+ A,, d) -(D. Aj, d) j E [l, n] and d E C, ()( ) 3 (D.A{ $ ~) = (g:j: l:B, c ) (D.B \nII A,c) ---+ (D.B II A , c ) (D.A, du ~zC) ---i (D. B,d ) 4 (D.3 zA, C) + (D.~ zB, C U ~zd ) R5 (D.P(y), \nC) ---+ (D.3dwzA, C) P(z): As D,z+Y R6 (D.p(z), c) + (D.A, C) p(z) : A E D Table 1: The (standard) transition \nsystem. soundness and completeness of the calculus. More in-of the agent 2xA are all those constraints \nwhich are terestingly, it turns out that we can obtain the rules equal to a resting point of A up to \nthe information on for the proof system by simply mirroring the equa-x. Finally recursion is modelled, \nas usual, by a least tions of the denotational semantics. This is due to fixpoint construction. In rule \nD5 the variable y is as\u00adthe fact that the operators of the language are mod-sumed to be different from \nthe formal parameter and elled in these equations by simple set theoretic notions in rule D6 on the other \nhand z is assumed to be the (e.g. parallel composition as intersection) which in the formal parameter. \nspecification logic can be replaced by the correspond-For deterministic agents the semantics [P](e) co\u00ading \nlogical notions (e.g. intersection by conjunction). incides with the denotational semantics of [26], \nwhich This simple compositional structure of the SP seman-associates with each deterministic agent its \nset of rest\u00adtics gives a strong evidence of the declarative nature ing points and which is a fully abstract \ncharacteriza\u00adof this paradigm since, as shown in detail in the fol-tion of its input/output behaviour. \nIt is worth noting lowing, it allows to view a program as a theory of the that also in the case of nondeterministic \nprocesses the specification logic. operational semantics SP is compositional since it is well known that \nthe input/output behaviour of non-Definition 4 1 Given a program $ ! [~l(e) : deterministic processes \nis not compositional ([26, 7]). Processes -+ p(C) is defined by the equations in ta-As shown by the previous \ntheorem, once we abstract ble 2 where ~ denotes the least fixpoint wrt subset from the first components \nof the i/o pairs we obtain inclusion of elements of p(C) containing fake. Here e compositionality at \nthe price of a loss of information. is an environment which assigns a set of resting points Indeed, while \nfor deterministic agents we can extract to each procedure name. the i/o behaviour of P from SP(P), this \nis not possible for non-deterministic agents. However, as previously Theorem 4.2 For any closed program \nP we have discussed, SP (P) provides the information we are in\u00ad SP(P) = [P](e), e arbitrary. terested \nin also for non-deterministic agents since it defines exactly the strongest postcondition wrt true. The \nfirst two equations of table 2 state that the The above theorem allows also an interpretation of agents \nstop and tell(c) have as resting points all the assertions P sat ~, with P arbitrary (thus including \nconstraints and all the constraints which entail c, re\u00adnon-closed processes). Namely, we can now define \n~ spectively. Equation D2 states that c1 is a resting P sat @ iff e ~ P sat #1, for every environment \ne, point of a guarded choice agent ~~=1 ask(c, ) -+ A, where e ~ P sat @ iff [P](e) ~ [~]. if either \nit enables the guard ask (cl) and additionally it is a resting point of A$, or it does not enable any \nIn table 3 we define a calculus for assertions P sat @ guard (and hence the agent suspends). Equation \nD3 using the usual natural deduction style. The rules CO\u00adis based on a simple semantic property: d is \na rest-C4 are obtained essentially by a procedural reading ing point of A II B iff d is a resting point \nof both A of equations Do-D4 in table 2 and by a translation of and B. According to equation D4, the \nresting points the set-theoretic notions into the corresponding logical DO [D.stop](e.) = c D1 [D.tell(c)](e) \n=T c D2 [D.D, Iwk(cz) --+Ai](e) = f)t(C\\ ~c,) u U,(tc, n [lI.A,](e)) D3 UD.A [1 l?](e) = [D. A](e) n \n[D..B](e) D4 [D.3zA](e) = {d I there exists c E [D. A](e) s.t. 3Zd = 3ZC} D5 [~.p(y)](e) = [~.am(p(z) \nII ~elz(dzy))](e) D6 [D.p(z)](e) = e(p) p@D D7 [D.p(z)](e) = pil! where ~(~) = [D\\ {p}. AJJ(e{f/p)-)), \nP(Z) :: A 6 D Table 2: Strongest postcondition semantics of CCP ones. Thus ~ (which for properties is \ngiven by their A formal justification of the above calculus con\u00adinterpretation) is deleted, U is turned \ninto V and fl sists in establishing its soundness and completeness. into A. Soundness means that every \nprovable correctness as- More precisely, from DO and D 1, which are not in-sertion is valid: whenever \n1-P sat ~ then ~ P sat #. ductively defined, we obtain two axioms. The agent Completeness on the other \nhand consists in the deriv\u00adstop satisfies the weakest property true (CO) and the ability of every valid \ncorrectness assertion: whenever agent tell(c) satisfies the property c (Cl). The cor-+ P sat # then F \nP sat #. responding operational intuitions are clear from those Theorem 4.3 (Soundness) The proof system \ncon\u00ad given for DO and D 1. sisting of the rules CO-C7 is sound. More precisely, The rule for non-deterministic \nchoice (C2) can be whenever PI sat 41, .... Pn sat ~. F P sat q5 and justified by considering equation \nD2: a resting point e+ P,sat#z, fo~i=l, . . ..n. then e~Psat~. of ~$ ask (ci ) ~ At either does not entail \nany of the asked constraints c%, in which case it satisfies the prop-Proof erty ~% -ICa, or it entails \nc, and is a resting point of A,, Induction on the length of the derivation. We treat the so by the premise \nit satisfies ~, and thus it will satisfy case when the last rule applied is the recursion rule. Ci A \n~,. Note that for deterministic agents, rule C2 Since the proof D\\ {p}.p(x) sat 4 t D \\ {p}.A sat ~ is \nreduces to shorter than the current one the induction hypothesis says that for every environment e such \nthat e ~ D \\ {P}.P(z) sat 4 we also have that e ~ D \\ {p}.A sat ~. D.A sat ~ D.ask(c) ~ A sat (c -+ ~) \nLet us take a particular e. We have to show that e > since (c A ~) V TC is logically equivalent to c \n--i ~. D.p(z) sat ~, or, in other words that [D.p(z)](e) < The rules for parallel composition and hiding \ncan [~]. NOW [D.p(z)](e) = pW, where pfl = Ui f i, with be obtained in a similar way from the correspond\u00ad~o \n= {.fa~se} and ~,+1 = [D\\{p}.All(e{fi/p}). Thus it ing equations. Note that 3Z both in the languages \nsuffices to prove by induction that for all n ~n ~ [I#J]. of properties and agents has the same meaning, \nwhich The base case is obvious. Suppose that jn z [#J]. is different from the one of 3Z in the constraint \nsystem. So we have e{~n/p} ~ D \\ {p}.p(z) sat #, and thus Reasoning about recursion is formalized in \nterms we infer that e{j~/p} + D \\ {p}.A sat ~, that is, of a meta-rule (Scott-induction [28] ) which \nallows to f~+l = [D\\ {p}. Al(e{~Jp}) G J@]. conclude that the agent p(z) satisfies a property @ o whenever \nthe body of p(z) satisfies the same property assuming the conclusion of the rule. Finally, we have We \nprove completeness of the system in the sense of the consequence rule C7 which states that if the pro-Cook \n([11]): we assume given as additional axioms gram P satisfies # and ~ implies + in the underlying all \nthe valid properties and we assume the expressibil\u00adlogic of properties then P satisfies 1. ity of the \nstrongest postcondition of a process P, i.e. CO D.stop sat true Cl D.tell(c) sat c D. A,satq5, Vie{l,..., \nn} C2 D. ~ aslc(c, ) -+ A, sat ~ -IC, V V(C, A #t) % za D.A sat~ D.B sat~ C3 D. All Bsat#A@  D.A sat \n~ C4 D.4xA sat dx~ C5 D \\ {p}.p(x) sat 1#1t-D \\ {p}.A sat # p(z) ::A ~D D.p(z) sat # D.%(p(z) II tetl(z \n= y)) sat # C% D.p(y) sat #J c w Table 3: A calculus for CCP that there exists a property ~ such that \nSP(P) = [~]. In general SP(.P) can be expressed in an extension Completeness then follows from an application \nof the of the first-order logic of properties which includes re\u00adrecursion rule and from the following \nlemma: cursively defined properties. Interpreting procedure identifiers as property variables the rules \nCO-C4 of Lemma 4.4 Let D = {pl(zl) :: Al,.. .,pn(zm) :: the calculus allow to translate an agent into \na re-An]. For every agent A in which there occur only calls cursively defined property. Note that the \nresulting of procedures of D, if ~ D.A sat ~ then property contains only positive occurrences of prop\u00aderty \nvariables, thus its meaning can be defined as the 01, ..., @. t A sat q5. least fixed point of a monotonic \noperator on the lat\u00adtice of properties. Note also that the recursion rule where, fori = 1, ..., n, @; \n= p,(z; ) sat SP(D.pi(z, )). for procedures corresponds with the following rule for recursively defined \nproperties:Corollary 4.5 (Completeness) Whenever /= P sat ~, with P closed, then t P sat ~. 4[#/Pl + \n# p(z) +@Proof Let P = D.A, then by the lemma above it suffices to assuming the property p(z) to be (recursively) \ndefinedshow that p(z) sat SF (p(a)), p declared in D. Again by v. The substitution [~/P] applied to p(z) \nresultsby the above lemma we have into ~, and applied to p(y), y distinct from z, into 3z(#AdzY). @ \nl, ..., @w k-A; sat SP(D.p(Q)) where, for z = 1 , . . .,n, @i = pi(z, ) sat SP(D.pi(z, )) 4.1 Local \nnon-determinism and p(z% ) :: A, 6 D (note that SP(D.Ai) = SP(pz (z,))). Now a repeated application of \nthe re-In order to illustrate the generality of our ap\u00adcursion rule gives us 1-pi (z~ ) sat SP (pz (z, \n)). proach for ccp languages we consider now a modifi\u00ad o cation of the standard ccp operational model \nwhere Note that (if there exists a @ such that SP(P) = guarded choice is modelled by local (i.e. internal) \nnon\u00ad [d]) the rules CO-C6 give a calculus for the strongest determinism. The transition system Tl = ( \nConf, --+1) postcondition of -P wrt true, and rule C 7 allows to is then obtained by adding rule R21 \nto rules Rl\u00adobtain weaker properties. R.tl. The agent ~~=1 ask(cz ) + Ai can now non\u00ad R2z (~~=1 ask(c, \n) + A,, d) -(ask(cj) ~ Aj, d) j E [l, n], n >1 Table 4: The transition rule for local non-determinism. \ndeterministically select one j E [1, n] and hence be\u00adhave like ask(cj) + Aj (which is a shorthand for \nz~=lask(cj) + Aj) even if ask(cj) is not enabled in the current store. The external environment then \ncannot control the choice any more. The denotational semantics now is obtained by sub\u00adstituting equation \nD2 in table 2 by the equation D2Z given in table 5. Accordingly (writing -IC, V @$ as an implication), \nthe new proof system is obtained from table 3 by replacing rule C2 by the rule C21 given in table 6. \nSoundness and (relative) completeness of this calculus can be proved analogously to the previous case. \nNote that the semantics resulting from table 2 mod\u00ad ified by equation D2Z is the one introduced in [18] \nfor angelic ccp. The same semantics was used in [13] to approximate the operational semantics obtained \nfrom rules R1-R6 (i.e. with global choice) by observing the upward closure of the set of the resting \npoints of a process P for a given input c. D21 [D. xi ask(c,) -+ A;](e) = lJi(C\\ ~c, U [A,](e)) Table \n5: The equation for local non-determinism Table 6: The rule for local non-determinism  4.2 Hoare logic \nWe have presented a calculus for assertions of the form P sat ~. This allows to describe properties of \nthe final states of ccp computations without considering any assumption on the initial store. A natural \nextension would be to consider arbitrary preconditions, i.e. to give a calculus for triples of the form \n{~} P {#J} in the classical Hoare-logic style, with the intuitive meaning that if the computation of \nP starts in a store which satisfies ~ and terminates in a state d, then d satisfies $. If preconditions \nare de\u00adscribed by upward closed properties then triples are not more expressive than the assertions considered \nin previous sections. Indeed let us formally define the meaning of a triple as follows: {4} 1 {d} iff \nSPY(P) G [41 where SPW (P) denotes the set {d I -there ezis-t c G [~] and Q s.t. (P, C)+* (Q, d) j+ \n} (the strongest postcondition wrt ~). Then, assuming that T [~] = [~], it is easy to show that for \nany P, SPY (P) = SP(P) n [+] and hence, from the interpre\u00adtation of -+, {$} P{~}ifi Psat*+~ Upward closed \nproperties can be syntactically char\u00adacterized as formulas constructed from constraints using conjunction \nand disjunction only. The above equivalence shows that for these properties the sat sys\u00adtem is expressive \nenough. Introducing preconditions containing negation is not straightforward since it can easily be shown \nthat in this case the stronger postcondition semantics SPiZ (P) is not any more compositional (counterex\u00adamples \ncan be obtained by slight modifications of the usual ones which show that the input/output seman\u00adtics \nis not compositional). A calculus for the strongest postcondition semantics in the general case then \nwould require additional proof-techniques similar to those used for imperative languages (e.g. test for \ninter\u00adference freedom [20], cooperation test [4]). But even more basically, allowing arbitrary preconditions \ndoes not even permit an axiomatiriation of the tell opera\u00adtion; namely, it can be argued that there does \nnot ex\u00adist a logical cent ext C[Z, y] such that for any property ~ and constraint c the strongest postcondition \nof the tell operation tell(c) wrt to 4 is described by C[4, c]. Note, for example, that simply adding \nthe constraint c to the precondition is incorrect: It would yield jalse as the strongest postcondition \nof tell(c) with respect ~c. Moreover, it is not clear how such a generality would really improve the \nexpressive power of the calculus, for ccp languages, from the point of view of applications.  5 The \ntransformational design of ccp programs In this section we show how the programming logic of ccp can \nbe used for the design of ccp programs by means of refinement techniques. The main idea underlying the \ntransformational ap\u00adproach to the design of programs is the stepwise trans\u00adformation of specifications \ninto programs. To express the stepwise construction of a program it is convenient to introduce the formalism \nof miced terms ([19]), i.e. terms that are constructed out of programs and spec\u00adifications. In the case \nof ccp programs the strongest postcondition semantics allows to view a program as a property of constraints. \nFormally we define the lan\u00adguage of mixed terms of programs and properties as follows: The semantics \nof a mixed term is given with respect to a set of procedure declarations D and is obtained from the semantics \n[ ] as previously defined. In fact, note that [ ] as defined in table 2 for agents and [ ] in definition \n3.2 coincide if we identify II with A and tell(c) with c. In the mixed term formalism a partial correctness \nassertion P sat @ then corresponds to the implication P ~ ~. Implication itself thus models the satisfaction \nor implementation or refinement relation: A mixed term @ satisfies or implements or refines a mixed term \nW iff @ 4 V holds. Note that the refinement relation, which is modelled by set-inclusion, corresponds \nwith a decrease in non-determinism. An interesting example illustrating the above is the validity of \nthe following implication (with a slight abuse of notation): (te//(c) + tell(d)) + i!ell(c n d) (Here \nm denote the glb of the given underlying con\u00adstraint system. ) So in the strongest postcondition se\u00admantics \nthe non-determinism present in telt(c TI d) is reduced by tell(c) + tell(d) since in the latter program \nwe know that either c or d is told. A derivation of a ccp program P from a specification ~ in this approach \ncorresponds with a sequence of implications between mixed terms 01, . . . On where 01 is the given specification \n~ and @n denotes the de\u00adrived program. Furthermore each of the implications @a+l --i $% is generated \nby an application of a transfor\u00admational rule. Such a rule either consists of some log\u00adical reasoning \nor a rule which allows the introduction of programming constructs. For example a rule which allows the \nintroduction of non-deterministic choice is easily derived from the corresponding proof rule of the above \nproof system for partial correctness: 2 t z Note that the proof rules for parallel (i.e. A), the hiding \noperator and the consequence rule reduce to purely logical rules, and that the proof rule for proce\u00addures \ncorresponds with the logical rule for recursively defined predicates,  6 Conclusions We presented a \ncompositional proof system which al\u00adlows to prove partial correctness of concurrent con\u00adstraint programs \nand we proved its soundness and (relative) completeness. The rules of the calculus are obtained from \nthe definition of a simple deno\u00adtational semantics which describes the set of all the resting points \nof a ccp process. Indeed, such a notion of observable turns out to be compositional also for the non-deterministic \ncase and is informative enough for partial correctness since it corresponds exactly to the strongest \npostcondition wrt the precondition true. Our results should be considered as the starting point of a \nstudy of ccp languages which involves both theo\u00adretical and practical aspects. From a theoretic point \nof view, one of our main contributions is to clarify the declarative nature of ccp languages and its \nadvantages wrt other concurrent programming paradigms. Indeed the proof-theory we have defined allows \nto consider a ccp program as a logical theory in the specification logic by means of a direct translation \nof the language operators in their classical logical counterparts. An immediate outcome of this logical \nreading of ccp programs is the sim\u00adplicity of the calculus, especially if compared to proof systems for \nconcurrent imperative languages which in\u00advolve complicated notions as, for example, a test for interference \nfreedom. Another interesting point is the close correspon\u00addence between program denotations and logics \nfor ccp (actually they can be viewed as different faces of the same coin). A very relevant line of research \nhas been devoted in the past few years to establish closer links between denotational and axiomatic semantics \nof pro\u00adgramming languages, via a better understanding of the relations between topology (and domain-theory) \nand logics [22, 27, 29, 23]. The significance of such a line was eventually made clear by Abramsky [1] \nwho exploited a seminal idea in [29]: the classic Stone rep\u00adresentation theorem for Boolean algebras \nis the key to establish a correspondence (actually a duality of categories) between denotational semantics \n(spaces of points which are denotations of computational pro\u00ad cesses) and program logics (lattices of \nproperties of processes). The simplicity of our construction is essentially due to the explicit logical \ninterpretation of the basic pro\u00ad gramming constructs. Further investigation should clarify the relations \nbetween the logics of the con\u00ad straints system and the programming logic. More pre\u00ad cisely we aim at \nacomplete axiomatization of the logic of properties. The advantages of obtaining a programming logic \nfroma denotational semantics are self-evident in our case (consider for example the soundness and com\u00adpleteness \nproofs). On the other hand, proof systems for imperative concurrent languages are often designed by using \nan ad hoc ingenuity and their soundness and completeness are proved wrt an operational se\u00admantics using \nelaborate techniques [2]. From a pragmatic point of view, for any real pro\u00adgramming language the importance \nof formal tools to reason about the correctness of programs is ev\u00adident. The concurrent constraint paradigm \nhas al\u00adready proved its usefulness in several implementations, including a commercial one [14]. Techniques \nbased on abstract interpretation have been used to analyze properties of ccp computations ([9, 13]), \nbut as far as we know, our is the first attempt to develop a for\u00admal calculus for (partial) correctness. \nSuch a formal system should be viewed as a first step towards the realization of formal methods for the \nverification and the synthesis of ccp programs. Further directions which we are currently working on \ninclude an extension of the calculus to infinite com\u00adputations and to the more general case of Hoare-triples \nwit h negative preconditions, and the development of a refinement calculus for program synthesis along \nthe lines suggested in section 5.  References [1]S. Abramsky. Domain Theory in Logical Form. Proceedings, \nAnnual Symposium on Logic in Computer Science, pp. 47-53, IEEE C S, 1987. Extended version in Annals \nof Pure and Applied Logic, 51: 1-77, 1991. [2] K.R. Apt. Formal justification of a proof system for Communicating \nSequential Processes. Journal of the ACM, 30:197 216, 1983. [3] K. R. Apt. Introduction to Logic Programming. \nIn J. van Leeuwen, editor, Handbook of Theoret\u00adical Computer Science, volume B: Formal Mod\u00adels and Semantics. \nElsevier, Amsterdam and The MIT Press, Cambridge, 1990. [4] K.R. Apt, N. Francez and W. P. de Roever. \nA proof system for Communicating Sequential Pro\u00adcesses. ACM Transactions on Programming Lan\u00adguages and \nSystems, 2:359-385, 1980. [5] J.A. Bergstra and J.W. Klop. Process algebra: specification and verification \nin bisimulation se\u00admantics. In Mathematics and Computer Science H, CWI Monographs, pp. 61-94. North-Holland, \n1986. [6] F.S. de Boer, J.N. Kok, C. Palamidessi, and J .J .M.M. Rutten. The failure of failures: Towards \na paradigm for asynchronous communication. In proceedings of Concur 91, Lecture Notes in Com\u00adputer Science, \nVol. 527, Amsterdam, The Nether\u00adlands, August 1991. [7] F.S. de Boer and C. Palamidessi. A Fully Ab\u00adstract \nModel for Concurrent Constraint Program\u00adming. In S. Abramsky and T.S.E. Maibaum, editors, PTOC. of TAPSOFT/CAAP, \nLNCS 493, pages 296-319. Springer-Verlag, 1991. [8] F.S. de Boer and C. Palamidessi. A process alge\u00adbra \nof concurrent constraint programming. Pro\u00adceedings of the Joint International Conference and Symposium \non Logic Programming, JIC-SLP 92. [9] M. Codish, M. Falaschi, K. Marriott, and W. Winsborough. Efficient \nAnalysis of Concur\u00adrent Constraint Logic Programs. In A. Lingas, editor, Proc. of the 20th International \nColloquium on Automata, Languagesl and Programming, vol\u00adume 700 of Lecture Notes in Computer Science, \npages 633-644. Springer-Verlag, Berlin, 1993. [10] L. Colussi, E. Marchiori. Proving Correctness of \nLogic Programs Using Axiomatic Semantics. Pro\u00adceedings of the 8th International Conference on Logic Programming, \nThe MIT Press, pp. 629-644, 1991. [11] S.A. Cook. Soundness and completeness of an axiom system for program \nverification. SIAM J. Computation, 7(1):70-90, 1978. [12] E.W. Dijkstra. A discipline of programming. \nPrentice-Hall, 1976. [13] M. Falaschi, M. Gabbrielli, K. Marriott, and C. Palamidessi. Compositional \nAnalysis for Con\u00adcurrent Constraint Programming. In Proc. Eighth IEEE Symp. on Logic In Computer Science, \npages 210 221. IEEE Computer Society Press, Los Alamitos, California, 1993. [14] I. Foster and S. Taylor. \nStrand: New concepts in parallel programming. Prentice Hall, 1989. [15] [16] [17] [18] [19] [20] [21] \n[22] [23] [24] [25] [26] [27] [28] [29] [30] L. Henkin, J.D. Monk, and A. Tarski. Cylindric Algebras \n(Part I). North-Holland, 1971. C.A.R. Hoare. An axiomatic basis for computer programming. Communications \nof the ACM, 12(10):576-580,583, 1969. J. Jaffar and J.-L. Lassez. Constraint Logic Pro\u00adgramming. In \nProc. Fourteenth Annual ACM Symp. on Principles of Programming Languages, pages 111-119. ACM, 1987. \nR. Jagadeesan, V.A. Saraswat, and V. Shanbhogue. Angelic non-determinism in concurrent constraint programming. \nTechni\u00adcal report, Xerox Park, 1991.  E.-R. Olderog. Nets, Terms and Formulas. Cam\u00adbridge Tracts in \nTheoretical Computer Science 23, Cambridge Univ. Press, 1991. S. Owicki and D. Gries. An axiomatic proof \ntech\u00adnique for parallel programs. Acts Informatica, 6:319-340, 1976. P. Panangaden, V.A. Saraswat, P.J. \nScott and R.A. G. Seely. A Hyperdoctrinal View of Con\u00ad current Constraint Programming. In Proc. REX Wo? \nkshop, LNCS 666, pages 457-476, 1992. G. Plotkin. Dijkstra s predicate transformers and Smyth s powerdomains, \nLNCS 86, 1980. E. Robinson. Logical aspects of denotational se\u00admantics, LNCS 283, 1987. V.A. Saraswat. \nConcurrent Constraint PTogTam\u00adming Languages. PhD thesis, Carnegie-Mellon University, January 1989. Published \nby The MIT Press, U. S. A., 1991. V.A. Saraswat and M. Rinard. Concurrent con\u00adstraint programming. In \nProc. of POPL, pages 232-245, 1990. V.A. Saraswat, M. Rinard, and P. Panangaden. Semantics foundations \nof Concurrent Constraint Programming. In Proc. of POPL, 1991. D. Scott. Domains for denotational semantics. \nIn Proc. of ICALP, 1982. D. Scott and J.W. de Bakker. A theory of pro\u00adgrams. Technical Report Unpublished, \nNotes of the IBM Vienna Seminar, 1969. M. Smyth. Powerdomains and Predicate Trans\u00adformers: A Topological \nView. Automata, Languages and Programming, Proceedings 1983, LNCS 154, pp. 662-675, 1983. J. Zwiers. \nCompositionalty and Partial Correct\u00adness. LNCS 321, Springer-Verlag, 1989.   A Appendix As an example \nof application of the proof system, we show a derivation of the partial correctness assertion p(z, v)sut(z=OVz>O)4y= \nz!, for the procedure p(z, y) declared as p(z, y) :: A where A = ask(z = O) +teli(y = 1) + ask(z > O)+ \nA2 and A2 = 3u, z(teZl(u = z 1) II tell(y = z *z) II p(u, z)). (we use + as a shorthand for ~~=l). \nAccording to the above specification, this procedure computes the factorial of a given integer z. Here \nwe assume that the underlying constraint domain allows to express numerical constraint on the domain \nof (neg\u00ad ative and positive) integers. In the proof we use the short notation x ~ Ofor x = OV x > 0. \n1. P(~!Y)sa~~20-+v=~! { assumption ] 2. P(z1 Y) II~4~ = ~)IIWY = 2))$a~ (z> O-+ Y= Z!) AZ= UAY=Z { from \n1, tell(z = u) sat z = u, tell(y = z) sat y= zand by C3 } 3. 3z, g (p(%, g) II tell(z = u) II tell(y \n= z)) sat U> O--Z=U!  { ~y C4 and C7: Note that 3z, Y((z>O-+ Y=z!)Az=u AY =z)+ (u~O~z=u!)isvalid}  \n4. P(u, z)sat (u z O)+ z= u! { from 3and by C6 }  5. te~t(u = z 1) II tell(y = z *z) II p(u, z) sat \n (u~O+Z= IJ!)Au=Z-l AY=Z*Z { from 4, by Cl and C3 } 6. A2satx>O~y=z! { from 5, by C4 and C7 } 7. telz(y \n= 1)sat y= 1 {by Cl}  8. Asat(z~O)-+y=z! { from 6, 7 and by C7: Note that ( (=(z = O)A 7(z > O)) V \n (z= OAY=l)V (Z> OA(Z>O+Y=Z!))) -+(z~O-+y=Z!) isvalid} 9. p(z, y)satz~O-+y=z!  { from 8and by C5 } \n 108  \n\t\t\t", "proc_id": "174675", "abstract": "<p>We develop a compositional proof-system for the partial correctness of concurrent constraint programs. Soundness and (relative) completeness of the system are proved with respect to a denotational semantics based on the notion of strongest postcondition. The strongest postcondition semantics provides a justification of the declarative nature of concurrent constraint programs, since it allows to view programs as theories in the specification logic.</p>", "authors": [{"name": "Frank S. de Boer", "author_profile_id": "81100652634", "affiliation": "Free Univ., Amsterdam, The Netherlands", "person_id": "P86271", "email_address": "", "orcid_id": ""}, {"name": "Maurizio Gabbrielli", "author_profile_id": "81100230344", "affiliation": "CWI, Amsterdam, The Netherlands", "person_id": "PP39033597", "email_address": "", "orcid_id": ""}, {"name": "Elena Marchiori", "author_profile_id": "81100272123", "affiliation": "CWI, Amsterdam, The Netherlands", "person_id": "PP35026878", "email_address": "", "orcid_id": ""}, {"name": "Catuscia Palamidessi", "author_profile_id": "81100635039", "affiliation": "DISI, Genova, Italy", "person_id": "PP40029290", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/174675.176925", "year": "1994", "article_id": "176925", "conference": "POPL", "title": "Proving concurrent constraint programs correct", "url": "http://dl.acm.org/citation.cfm?id=176925"}