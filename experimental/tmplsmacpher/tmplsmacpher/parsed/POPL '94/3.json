{"article_publication_date": "02-01-1994", "fulltext": "\n The Typed Polymorphic Label-Selective kCalculus Jacques Garrigue Hassan Ait-Kaci garrigue@is .s. u-tokyo. \nac. jp hak@prl.dec .com DepartmentofInformation Science Digital Equipment Corporation TheUniversityofTokyo \nParisResearchLaboratory 7-3-1 Hongo, Bunkyo-ku 85 Avenue Victor Hugo Tokyo 113, Japan 92500 Rueil-Mahnaison, \nFrance Abstract. Formal calculi of reeord structures have recently been a focus of active mearch. However, \nscamely anyone has studied formally the dual notion-+. e., argument-passing to functions by keywords, \nand its harmonization with currying. We have. Recently, we introduced the label-selective A-calculus, \na conservative extension of A-calculus that uses a labeling of abstractions and applications to perform \nunordered cttmying. In other words, it enables some form of commutation between arguments, This improves \nprogram legibility, thanks to the presence of labels, and efficiency, thanks to argument commuting. In \nthis paper, we propose a simply typed version of the calculus, then extend it to one with ML-like polymo~hic \ntypes. For the latter calculus, we establish the existence of principal types and we give an algorithm \nto compute them. Thanks to the fact that label-selective A-calculus is a conservative extension of A-calculus \nby adding numeric labels to stand for argument positions, its polymoqhic typing provides us with a keyword \nargument-passing extension of ML obviating the need of I-CCO*. In this contex~ conventional ML syntax \ncan be seenas a restriction of the mo~ geneml keyword-oriented syntax limited to using only implicit \npositions instead of keywords. Introduction The use of symbolic labels in programming languages is \nnot new, This has been done in two ways. The first one, common to nearly all languages, is as field designators \nin record structures. Relatively recently, formalisms for records have been proposed. This started with \nCardelli [6], was later extended to a second order calculus [7], and was followed by a number of record-type \ninference systems compatible with ML-style polymorphic type inference [22, 20, 13, 19]. Even more recently, \na compilation method was proposed by Ohori [18], for an extension of )-calculus containing polymorphically \ntyped records, Another way to use labels in progr amming languages has been as keywords for parameter-passing \nin procedure or function calls. This is the case in Common LISP [21], ADA [15], and LIFE [4], However, \nin Common LISP or ADA, currying is not supported, which makes the situation rather mild. Although currying \nis supported in LIFE, even with keywords given in a different order, it is restricted nonetheless and \ndoes not accommodate implicit positions as it should. Indeed, fully flexible currying with the presence \nof keywords as well as explicit and implicit positions was until Permission to copy without fee all or \npart of this material is granted provided that the copies are not made or distributed for direct commercial \nadvantage, the ACM copyright notice and the title of the publication and its date appear, and notice \nis given that copying is by permission of the Association for Computing Machinery. TO copy otherwise, \nor to republish, requires e fee and/or specific permission. POPL 94-1/94, Portland Oragon,USA recently \na still unexplored issue. Some proposals do offer this convenience of parameter-passing withoutmodifying \nthe core calculus [14, 17]. However, these are based on using a notion of storq that is, bindings from \nnames to values. This introduces another parameterizing system, independent from J-calculus. Even so, \nto our knowledge, no typing system has been proposed for them. Our own proposal, as originally reported \nin [2], is to support this new convenience of labeling argumenta directly in A-calculus and accommodate \nselective unordered currying through commutation of arguments. In our view, the role of arguments is \ndetermined by their labels, which interact with their order, Selective A-calculus introduces two types \nof commuta\u00adtions. The first, and most immediate, is between sym\u00adbolic labels. By analogy with tuples, \nwhen currying an expression f (p + a, q * b, ...) we obtain an expression ((f(p + a))(q * b))(.. .). \nBut since there is no reason to apply f in this specific order, using the freedom pro\u00advided by labels \nallows to curry in a different ordeq e.g., (V(q + b))(p + a))(.. .). Suppressing superfluous paren\u00adtheses, \nand limiting our consideration to two arguments, we obtain that the following equahty must hold in our \ncalculus: f(p+a)(q+b) =f(q+b)(p+a). However, this is true under a restriction: p and q must be distinct \nlabels. Successive applications on the same label must not commute. Indeed, if the labels are equal, \nthe order of these applications must be obeyed to be unambiguous. @ 1994 ACM O-69791 -636-0B41001 ..$3.50 \nHere is an example of the use of these symbolic labels for the list constructor, in an ML-like language, \ntogether with inferred types, 1 #let cons car=>a cdr=>b = a: :b; ; cons : {car= > a, cdr=> a list} -> \na list #cons cdr=>[ll; ; it : {car=xint} -s int list Thesecondcmmmtation equalitycomesfrom areversion \nof the analogy with tuples That is, we can see atuple as a record labeled with numbers: (a, b,...) = \n(l+a,2+ b,...), Ifweapplied theequality used forsymbolic labels, wewould obtain~(l+a)(2 +-b) =~(2+b)(l+ \na). But, since it is better to see unary application as implicitly using the label 1 and keep conventional \ncurrying, we would rather Wrimf(l=a)(l+ b), orsimply, ~ u b as usual. To make this possible, we must \ndefine commutation differently on numbers: namely, ~(2+b)(l+a) =~(l+a)(l+b). This can be generalized \nas: f(m~a)(n+b)=f(n l+a)(m+b) if m< n. For instance we can use it as follows, (omitting explicitly labeling \nwith 1.>): #let sub x y . x-y;; sub : {I=>int, 2=>int} -z int #let minus15 = sub 2=b15; ; minus15 : {l=>int} \n-s int This second commutation equality is in fact orthogonal to the tirst one. Commutation on symbolic \nlabels expresses the intuitive possibility of taking input on multiple channels, while the numeric form \ngives a control on the relative precedence order of input on a given channel. Selective A-calculus provides \nthe above equalities for symbolic and numerical labels for both application and abstraction, As an untyped \ncalculus, its confluence has been established [3], along with fundamental properties of A-calculus like \nBohrn s theorem [12]. Similarly, the introduction of label-selective types provid\u00ading simple types for \nselective ~-terrns is done in the same manner as that of simple types in classical A-calculus. The essential \ndifference is that, in order to emphasize the intrinsic cmrnnutativity, we will put on the same level \nall argument types to a function. For instance, the cons,., operator, namely consi.t(car + h: in~ cdr \n+ t: int list) = (h :: t) for integer lists, should get type {car + int,int list} + int list, cdr + Such \na notation shows that it is possible to apply consi.t on both car and cdr labels, and that the result \nis a list of integers. Then we build a polymorphic typing system d la ML for selective A-calculus, As \nfor ML-style polymorphism, Iwe ~W ~ ~o~m CIOW to CAML [10]. 1 et denotes a definition, :: thelist constructor.Since \n=> is left unused (abstraction uses -> ), we use it for labeling. a type inference algorithm exists, \nwhich obviates the need for explicit typing. In other words, this means that we can integrate labeled \nparameters in any ML-like programming language. Continuing with the previous example, for the definition \ncons(car+ h, cdr+ t) = (h :: t), we can infer the type VCY.({car+ CY,cdr+ a list} -+ CYlist). Such a \ntype system is particularly well-adapted to selective ~-calculus, thanks to the incrernentality of typing, \nwhich goes together with application. On the other hand a second order type system, separating type application, \nwould limit commutation possibilities by introducing new dependencies between abstractions. Section 2 \ngives a practical and theoretical motivation for our type system. We then define symbolic and numerical \nlabel-selective A-calculus in Section 3 and 4, combining them in a product system in Section 5. Sections \n6 and 7 present respectively simple typing and polymorphic typing of the sel=tive A-calculus. To avoid \ncluttering the casual reader s attention with unnecessary details, we have relegated all proofs to the \nappendix. 2 Motivation The calculus we present has practical and theoretical moti\u00advations. In practice, \nthe use of labels for argument selection enhances clarity and and obviates the need of argument\u00adshuffling \ncombinators. From a theoretical perspective, the commutation laws of labeled arguments readily render \nnatu\u00adral type isomorphisms in ~-calculus. 2.1 Keywords: an enhancement for clarity We start here by \ngiving some examples of how the use of keywords, and their appearance in types, may help the programmer, \nOur view is already partially proven by the ubiquitous use of records as data structures. While theoret\u00adically \neverything could be done with tuples, one will often prefer using a resord, gaining abstraction over \na representa\u00adtion using explicitly ordered formats. Here are some examples of functions written in an \nML-like syntax, with their inferred types. #let rec map function=>f = fun # [1 -> [1 # I [h It] -> (f \nh) : :map function=~f t;; map : {1=> a list, function= >{l=> a} -> lb} -> lb list #map function=> (add \n1) ; ; it : {l=>int list} -s int list #ITBP [1;2;3]; ; {function= >{l=jint} -> a} -> a list The advantage \nof this labeling system is twofold: it is more expressive and it allows doing partial application selectively \non any label. One could argue that in the functions above, order is clear enough so that, even without \nlabels, there is no possibility for error. However this becomes less systematic for functions of three \narguments or more, Moreover, it is not so natural in some two-argument functions. This is the case, for \ninstance, of mem (membership in a list) or as soc (retrieval from an association list), whose respective \ntypes are: mem : a -> a list -> bool assoc : a -> ( a * b) list -> b There is no special reason for them \nto respect this particular order. In fact, the opposite order of arguments would appear more natural, \nsince currying with a given list is more likely. Here, a quick glance at the type eliminates any ambiguity. \nHowever, this is not always sufficient. Even if such was the case, the following types would certainly \nbe more perspicuous: mem : {l=> a, in=> a list} -> bool assoc : {l=> a, in=> ( a * b) list} -> b With \nthis, one can define such a function as: #let digit = mem in=>[O; l;2;3;4; 5;6;7;8; 91;; digit : {I=>lnt} \n-> bool This clearly improves legibility. Still, one may shrug this argument off since with two arguments, \nthere are only two possibilities of order. Wkh more arguments, however, this quickly becomes irksome. \nClearly, remembering arguments order for functions of more than three arguments-and those are not so \nuncommon-is out of the question. Let us give some more examples. Consider, for instance, it-list and \nlist-it (fold left and right), with types: it_list : (Ja -> lb -> la) -> a -> b list -> a list_it : ( \na -> b -> b) -> a list -> b-> b An explicit labeling such as: it_list : {1=> a list, function= s{l=> \nb, 2=z a} -> b, zero=s b} -> b list_it : {l=z a list, function= >{l=> a,2=~ b} -> b, zero=> b} -> b would \nbe more expressive, making the types easier to under\u00adstand. We have deliberately restricted our examples \nto generic functions, for which currying is useful. If we consider functions interfacing a window manager, \nfor example, the number of arguments per function is such that the use of labels is a necessity. In that \ncase, however, one could do with r-rds, since currying iri pot so important. Nevertheless, the trend \nin functional languages is towards a systematic use of currying. Standard ML is a notable exception, \npreferring uncurried functions, but CAML is an example of an ML dialect preferring currying,  2.2 Relative \npositions versus combinators If the main benefit from using symbolic labels is expres\u00ad siveness, that \nof relative positions is in conciseness-and efficiency. Consider, for example #let cons ab =a::b; ; cons \n: {1=> a,2=> a list} -> a list #maP function=> (cons 2=> [1;21 ) ;; it : {l=>int list} -z int list list \n#maP function= >(sub 2=>10) [11; 12;131 ;; it = [1;2;3] : int list Of course, the same effect can be \nobtained using the C wmbinator defined as: #let Cfxy=fy x;; (la -> ~b-> c) -> lb-> a-> C c: #lllap (C \nsub 10) [11;12;131; ; it = [1:2;3] : int list But, besides legibility, the hidden loss is efficiency: \na mmbinator is an explicit closure to build and reduce, whereas label commutation enables direct access \ninto the argument stack with offsets. Moreover, for more than two arguments, currying on the kth argument \nwould necessitate k 1 such swaps, or use a special combinator for each position-just as expensive. Jn \naddition to this obviously practical benefit, relative position labels provide a coherent bridge connecting \nclassical currying and record currying.  2.3 A generic commutation capability With respect to types, \nwe can see these extensions as the integration into J-calculus of the natural isomorphisrn Ax BzBx A, \nwhich, combined with currying, Ax B-+ CNA+(B+C), gives: A-+(B+C)HB+(A-+C). This isomorphism becomes \nclearer when using indexed products, as in category theory, with explicit projections T1 and Ir2: (T1+A) \nX (T2+B) = (w+B) X (TI+A), and thUS: (ml+-A) --+ ((m2+B) + C) H (TZ+B) + ((m+A) --+ C) Therefore, we \nobtain a type system in which these isomor\u00adphisms, which are part of those described in [5], are directly \nincluded. If we want to keep a confluent calculus, however, it is nec\u00adewiry to sacrifice either generality \n(two identical keywords may not commute) or referential stability of positions (new projections after \ncommutation). For this reason positions are necessary to allow commuting in arty case. They ensure that \nassociation between an abstraction and an application is inwiriant even if their respective positions \nchange,. This is important operationally as they allow direct access to distant arguments (i.e., deep \nin the stack). While symbolic labels are a useful extension of currying, numerical ones are similar to \nde Bruijn indices [9].  3 A-Calculus with multiple channels To meet the behavior that we illustrated \nwith keywords, we define an extension of the J-calculus, the symbolic selective ~-calculus, with symbolic \nlabels. Selective ~-terms consist of variables, taken from a set V, and two labeled constructions: abstraction \nand application. We shall assume a non-empty, totally ordered, set of symbols S, to use as labels. We \nwill denote variables by x, y, labels by p, q, and ~-expressions by capital letters. The syntax of selective \nA-terms is then given as: M .._.. x (variables) I ~#.M (abstractions) I M;Mf (applications). We will \nsay to abstract x on p in M , to apply M to M through p . These terms will always be considered modulo \na -wnversion. To make this compatible with the classical ~-calculus, we shal~ distinguish a special label, \nwritten L, to use as default.q That is, arty unlabeled abstraction or application is interpreted as being \nlalxkl by L. In other words, classical ~-calculus is the special case when $ = {~}. The reduction rules \nfor this calculus are given in Figure 1. ~-Reduction only happens on abstraction-application pairs with \nthe same label.3 Otherwise they commute by rule (3), Rules (1) and (2) simply normalize the order of \nabstractions and applications. For convenience, we will sometimes use a variant syntm using record notation. \nA record is m, expression of the form (P1 +Ml, . . . ,P. + M.) the pis are labels and the MJS are terms. \nWe shall use these expressions with the following syntactic equivalence A(pl% xl,... ,pn*xn).M G AP, \nXI. . . . .APnXn.M M(PI=MI, ,.., pn+Mn) E (... (Mfi MI)... &#38;MJ. 21twill beConvenimt,though not necessiuy, \nto aSSUmethat ~ is the l-t element of S. 3~e ~ohtion [N/X]M deno~s the term obtained from M @er substi~t\u00ad \ning all the free occurrences of variable x with the term N. Reduction: (P) (&#38;xM;~ + [~/xlM Reordering: \n(1) Apx.&#38;y.M + ~qy.&#38;x.M p > q (2) M;N;P + M;P;N p>q (3) (~pxJf);N + @@f;W P #q, x f? WN)  \nFigure 1. Reduction rules for symbolic selective ~-calculus Example: We suppose thatp < q < r < s: +3 \n(ApX.((Aqy.ArY.M) -W));~;Q -+z (APX.((A,Y.A,Y.M) W));Q;P -+6 (Aqy.Lz. [Q/x]M);NTP -+3 (Jqy.((Jrz.[Q/x]M) \n;N));P +p (~qy.([Q/xl[N/zlM) ):p -+3 &#38;y.(([Q/x][N/z]M) TP) We call symbolic selective A-calculus \nthe free wmbination of these rules and iwwnversion. Theorem 1 The symbolic selective A-calculus is confluent. \nProof: Consequence of the proof for selective A-calculus, in [2] 4 A-Calculus with relative positions \nThis calculus is very similar to the previous one, Its syntax is identical; the only difference is that \nthe labels are positive natural numbers: Again, for compatibility with the classical }-calculus, we shall \nuse position 1 as default, That is, any unlabeled abstraction or application is interpreted as being \nlabeled by 1. In other words, classical }-calculus is the special case when N={l}. The reduction rules \nare also similar, but with a twist. They are are given in Figure 2. The main idea here is to preserve \nwherence between argument position numbers and the property used for currying that all functions are \nunary. Hence, it is necessary to adjust a position number relatively to the form on its left. Similarly \nto what we do for symbolic labels, we will also use a number-labeled rewrd-syntax variant of the raw \nsyntax for convenience, However, unlike the freely wmmuting 5 The selective A-calculus Reduction: (P) \n(AZ~.Jq;N+[N/x]M Reordering: (4) Amx.A y.M -+ Any.Am_,x.A4 nl>rl  (5) M; N;P+M;P~N m>n (6) (&#38;x.M)$N \n+ &#38;-lX.(M$N) m > n,x @FV(N) (7) (Jnx.M)~N ~ &#38;x.(Mn~l N) m < .,x@ W(N)  Figure 2. Reduction \nrules for numerical selective A-calculus symbolic labels, the numbers used as labels in record notation \ndo not correspond directly to the relative position labels of the raw syntax. Namely, translating from \nthe record syntax to raw syntax must readjust an argument s position index by subtracting an offset equal \nto the number of arguments of lesser position indices on ita left. More precisely, let (n~ *MI,..., nk \n+ ikf~) be a record expression where nietifori= 1,, ,., k. Then, for anyi= 1,..., kin this expression, \nits rekztivepositimt offset is the number o(i) of labels in the set {nl, ..., ni. 1} that are StliCtly \nleSS thtln n~. For example, the relative position offsets of the record expression (4+ M1,1+MZ,5+MS,2+ \nM4,2+MS) are o(l) = 0,0(2) = 0,0(3) = 2,0(4) = 1,0(5) = 1. Hence, the syntactic equivalence is given \nby: A(nl +x1,..., n~+x~).M s &#38;xl . . . . .A,~-O(~)x@ M(nl*f141,..., nk*fl4k) E (... (A4; M1) . . \n. &#38;@)M). Example: (A(2ax,l~y,4~z) .M)(4aA ,6sP,2aQ) z (A*x.A,y.A2z.h4) ;N3P:Q +4 (A1y.}lX.AZZ.M) \nTN~P~Q (A1y.((J1X.A2Z.M) SN))~PTn3 +5 (}ly.((A1X.A2Z.M) ;N))ZQIP -t, (A1y.~lX.((J2Z.M) ;N))ZQIP +@ (A1y.A1x.[N/z]M) \n~QzP +, (A1y.((&#38;X.[N/Z]M) TQ))2P -+@ (Jly.[Q/X][N/ZJM)IP +7 Aly.([Q/xl[lv/m@lq The selective ~-calculus \ncombines orthogonallythe symbolic and the numerical selective J-calculi by using L = S x N as set of \nlabels.4 Thus its syntax is: M::=x [ Al,fk? I A4~f14 where l=pn EL= SxAf. The reduction system is the \ncombination in Figure 3. Applying these rules simply amounts to applying indepen- Reduction: (@) (~Ix.M) \nIN + [N/x]M Symbolic reordering: (1) &#38;nx.&#38;Y.M + &#38;ny.&#38;nx.M p>q (2) M@aN&#38;P+M~P~N p>q \n (3) (&#38;x.M) ZN + &#38;nx.(M&#38;N) P # 9,X@ Ww  Numeric reordering: (4) &#38;nX.~pnY.M + ~pny+im-IX.M \nm>n (5) MGNGP + MGPPZI N rn>n (6) (&#38;~x.M) &#38;N + &#38;n-lx. (MfiN) m > n,x @FV(N) (7) (&#38;mx.M) \n&#38;N + &#38;mX.(MPVI N) m < n,x @FV(N)  Figure 3. Reduction rules for selective )-calculus dently \nthe symbolic and numeric systems. One may see reordering rules as stmctural equalities, and @xhwtion \nas unique reduction rule. Since the combination is orthogonal, it inherits cmlluence from both systems. \nTheorem 3 The selective A-calculus is conjluent. Proof: This is a consequence of the proof for the sum \nsystem in [2]. We extend easily the use of numerical indices, which can be seen as being limited to a \nonly one keyword in the sum system, to all keywords thanks to channel independence. # To let this system \ninclude the symbolic calculus and nu\u00admerical calculus as sub-calculi, we will identify a symbolic keyword \npin the former with the label (p, 1), and a numeric index n in the latter with the label (~, n). Thus, \nthe classical unlabeled J-calculus is also syntactically embedded in se\u00adlective ~-calculus by taking \n(L, 1) as the default label of all abstractions and applications. 4111[2] this pwticular variant was \ndefied as a product system,and Theorem 2 The numerical selective A-calculus is confluent. whstwecalledthereselectiveXcalcoks \nasthesumsystemC = 5 u hf. Pmpetties of the two systemsbeing similar, we work here on the most Proof: \nConsequence of the proof for selective }-calculus. ~ generalone. 6 Simple types As in classical ~-calculus, \nwe introduce simple types. There are two benefits. Fimt, we gain a better understanding of the label-selective \ncalculus itself by explicating the type structure that it needs. Second, simply typed selective A\u00adcalculus \ngains the same nice expected properties; e.g., strong normalization of well-typed terms. 6.1 Syntax and \ntypes The original syntax of terms is extended to: M::=x I Alx:t.Ml MTM . which requires abstracted variables \nto be explicitly typed. We define the syntax of label-selective simple types with the following gramrrw \n1 ::= pn (labels) u ::= U1 \\ u? I ,.. (base types) r ::= {1+ t, . ..} (record types) .._  t .. ulr--iu \n(general types) where the expression {1 + t,...}denotes a finite partial function from L to types, including \nthe empty function {}. We shall identify a functional type of the form{} + u with the base type u. Note \nthat record types are not types of expressions of our term language. They are used exclusively as the \nleft subexpremion of function types. The idea behind this syntax of types is to convey that an application \ncan be done indifferently through any label that is present in the type, on a value of corresponding \ntype. 6.2 Record concatenation We shall provide a simple-type inference system as expected. In order \nto do so, we must define a record-type concatena\u00adtion operation needed for extending the domain type \nof a functional type. Before we give it formally, it is preferable to build some preliminary intuition. \nWe will illustrate the essential mechanism on an example. To simplify the discussion, let us first restrict \nourselves to numeric labels only. Consider the two record types r= {2+t1,4+t2} ands = {2+u1,3+uZ}. Extending \nthe type r ontheright withs must be done such that the relative positions be kept in wherence. Now, r \nexpects tlin second position and t2in fourth position. In other words, positions 1, 3,5 and up, are free \nin r in the sense that if more arguments were to be expected by an extension of r, they could use these \nfree slots in sequence. Consider now extending r with s. The first argument s position in s is 2. Hence, \nin r s context, this argument corresponds to the second free slo~ i.e., position 3. The following one \nims is in position 3, and hencs corresponds to the third free slot in n i.e., position 5. Thus, the record \ntype resulting from the concatenation of randsis r.s={2+t1, 3+-ti1,4+tz, 5~uz], The case of multiple \nchannels is not more complicated since the above scheme is to be used on each channel independently. \nIntuitively, this operation reminds of stream merging. In fact, this is exactly what is happening as \nthe indices on a given channel in a record indicate the expected positions, but only relative to this \nspecific record. Extending the record with more indices on this channel necessitates adjusting the new \nindices by taking their positions with respect to the sequence of indices unused by the initial record. \nWe now proceed to defining formaIly this record\u00adtype concatenation operation. Letr={/l~tl, ..., Z.+ t.} \nbe a record type. We shall denote by D, = {11, . . . . 1.} the set of labels defined in r. Recall that \nour record labels are not simple symbols, but pairs of the formpn, a symbol and a position index. Definition \n1 (occupied position) The nrhposition on p in a record type r is said to be occupied if r is such that \npn E Dr. Given a record type r, we denote by o,(pn) the offset of n on p in r to be the number of occupied \npositions on symbol p in r with index less than or equal to n. That is, o,@m) = 1(-@} x [1, n]) n 2),1. \nFor example, consider the two following record types: r= -@2*tl, p4*tz, ql*t3, q2*t4, q5*t5], S = ~2+ul,p3+ \nW, q2+uJ, q3+ud). Theoffseta of the labels ofs in r are, respectively, or(p2) = 1, o,@3) = 1, 07(q2) \n= 2, and or(q3) = 2. Given a record type r and a given symbol p, we need to identify the least index \nof p in r that is not an occupied position. More precisely, it is useful to know the nth such free position \nfor symbolp in r. Definition 2 (free position) The nzk !&#38; position for p in r is given by #,,P(n) \n= rnin{i c Af I i or(pi) = n}. For example, given the two previous example s record types, the free \npositions in r available for the indices in s are, respectively, #,,P(2) = 3, #,,P(3) = 5, &#38;,~(2) \n= 4, and &#38;,~(3) =6. For fixed r, this function is extended to work also on a record type by distributing \nit on each label. Namely, for any S = @[ni + ti}f= 1, A(s) = @i@r,pi (ni) + i}!= I o For example, for \nthe types r and s used above, we have #r(s) = @3+ ul, P5 %-u?, # +-u3, q6+ u~}. It is not coincidental \nthat the label domain of the 47(s) is disjoint from that of r. It is easy to show that this is true in \ngeneral. Definition 3 (concatenation) Record-Dpe concatenation is dejinedas r.s = rti #r(s), where w \ndenotes union offunctions with disjoint domains. Going back to the two record types r and s used in the \nexamples above, we have r. s = @2+ tl, p3 + ul, p4 + t2, p5~uz, ql+tq, q2*tA, q4+u3, q5*t5, q6+ud}. Proposition \n4 Label-selective record-types form a monoid; r[x HT]Fx:T (I) i.e., concatenation is associative with \nneutral element {}. Proof: This is because #,.. = &#38; o ~s (see appendix). H 6.3 Record matching It \nis essential for a syntax-directed inference system, like the typing system that we are about to give, \nto be able to solve syntactic equations of the form r. x = s. More specifically, to extract a subexpression \nr out of a record type expression it is convenient to write the latter as r Ws (i.e., splitting it), \nand let that be the result of an expression r. x, solving for x. Remarkably, there is an inverse to record-type \nconcatena\u00adtion that allows solving such an equation and thus may be used to identify a given record type \nas the result of the con\u00adcatenation of two other record types. We call this operation record-type matching. \n5 It will be used with great benefit in typing rules as well as for polymorphic type unification and \ntype inference as shown in the next section. Let r ands be two record types with disjoint label domains \n(i.e., such as could be obtained by partitioning one into two). Let pi be a label in s. For p, the position \ni can be seen as the result of having concatenated r with the same type originally at position i or(pi). \nIn fact, for all the label indices i of p ins, this defines an inverse function for &#38;,p ~ @(i) = \ni Or(Pi). That is, #;_(i) ~mput~ the index corresponding to ion channel p slapping the occupied positions \non p in r that are less than or equal to i. As before, for fixed r, #-1 is extended to record types. \nNamely, for tUIy s = @ini + ?i}~=l such that Pini @ D, for tii=l ,..., k, d; l(s) = ~id~~,(ni) + ti}f=l. \n Definition 4 (matching) Record-~pe matching is defined as r w s = r. #F i (s), where w denotes union \nof functions with disjoint domains. Letr= -@l+-tl, q2+tz)ands= ~2+u1, q3+uz}, The unique solution to \nthe matching equation r Ws = r. x is x= #;l(s) = @l*ul, q2*u2}. 6.4 Typing rules We now have all we \nneed to define well-typedness. We will denote by T a typing environmen~ i.e., a mapping from term variablea \nto types. The notation T [x ++ r] denotes the typing environment that coincides with 1 everywhere, except \non x for which it gives the type r, Definition 5 A term M is well-typed if there is a mapping r from \nthe free variables of M to types and a type T such that r 1-M : r is derivable in the type inference \nsystem of Figure 4. Simply typed selective J-calculus verifies the two funda\u00admental properties of typed \nA-calculi. T[x+-+6]PM:r-+r (II) rt-~lx:O.M: {l+t9]. r-+r rt-M:{(+6}. r-+r FFN:6 (III) TFM~N:r+r Figure \n4. Typing of simply-typed label-selective calculus Proposition 5 (subject reduction) Reduction preserves \nthe types; i.e., if T 1-M : T and M -+ N then I 1-N :r. Theorem 6 (strong normalization) The simply-typed \nlabel-selective ~-calculus is strongly normalizing.  7 Polymorphic selective A-calculus While there \nexist typing systems that are more powerful than ML s (e.g., second-order polymorphic A-calculus), the \nstyle of polymorphism used in ML is much simpler. This is essentially due to restricting type quantification \nto appear only at the outset of type type expressions, which facilitates type instantiation to be done \nimplicitly following applica\u00adtions. The principal advantage of this type system is that, for A-calculus, \nany term has a principal (i.e., most general) type that can be reconstructed from the shape of the term \nalone. This obviates explicit type declarations: a simple type unification algorithm synthesizea missing \ntypes. We show here that this form of polymorphism is valid also for label-selective ~-calculus. This \nmeans that, horn a typing point of view, the addition of labels is coherent with polymorphically typed \nA-calculus. 7.1 Syntax and types The syntax is that of untyped selective A-calculus with a Iet construct \nto introduce polymo@ism, types being provided by inference. Thus, the syntax of terms is given by M::=x \nI ~tx.M I M~M I Ietx= Min M and the reduction rule corresponding to the new construct is: letx =MinN \n+ [x/AiqN. As in Damas and Milner s definition [8], typea are par\u00adtitioned into monotypes, ranged over \nby t,and polytypes, ranged over by a, Thus, the language of types is given by: .. Ulv w .. (return types) \nr ::= {Z+t,...} (record types) .. t .. w I r + w (monotypes) o ::= t I VV.C7 (polytypes) where return \ntypes u stand for base types and v for type vari\u00ad ables. Here again, record types are not types of expressions \nof the tam language.  7.2 Type substitution The distinction we introduce here between return types \nand monotypes is specific to selective A-calculus. Indeed, as we shall see, the principal difficulty \nin our system, when compared to 2-calculus with ML-style polymorphic types, is that function types are \nalways kept flat. Observe, indeed, that function types are not return types. For example, {1+ a} + ({Z \n+ /3} --+ T) is not a valid type expression in our type language. It is possible, however, to obtain \nsuch an expression as the result of substituting a valid type for a type variable in another valid. For \nexample, doing a direct substitution with {1 ~ y} -i 6 for,8 in type {1 + ~} -+ /3 would result in{l+({l+~} \n+ 6)} + ({l+T} + 6). This means that when we substitute a variable that appears as return type with a \nfunctional type, we will need to modif y the structure of the type. The solution is to detine type substitution \nwith a built-in flattening of the domain type. We will denote this operation as [T \\cY]r (i.e., substitute \ntype T for type variable CYin r) and it is performed as expressed by the following simple rule [(r + \nu)\\cY](r --+ CY)= (([(r + w)\\a]r) . r ) --+ w. WMI this rule, our example above results in the valid \ntype {1*({ 1+ y}+6),2*-f}-+6 This illustrates how our domain of types is radically different from the \nconventional Herbrand universe with the arrow and base type constructors, whose well-known term unification \nis exploited for ML-type inference. We shall thus need to provide our explicit unification algorithm. \nIt is a nice property of our system that unique most general unifiers exist for our type terms. As we \nshall see, this is essentially due to the well-foundedness of normalization to flattened types which \ndoes not change the size of types. 7.3 Typing rules The typing rules are given in Figure 5, It is interesting \nto remark that Rules (IV)-(W) are in no way specific to selective ~-calculus. Since type quantifiers \nare external, they are independent of the structure of monotypes. Thus, these rules are exactly the same \nused in classical A-calculus. Their roles are generalization (IV), instantiation (V), and let-introduction \n(VI), The only, but important, difference between these rules and the classical ones is hidden in the \nuse of our flattening type substitution [T\\rx]a in Rule (V). Again, all the desirable properties hold \nfor the polymor\u00adphically typed selective A-calculus, as expressed by the two following propositions. \nProposition 7 (subject reduction) Zf r !-M : T in po/y\u00admorphically typed selective A-calculus, and M \n--+ N, then rtN; T. l [x++O]EM:r-+r (II) rl-Alx.M:{l*e]. r+T rtM:u a not free in r (w) rFM:vcY.o rFM:vcl.ff \n(v) r!-M : [T\\a]cJ rl-M:r r[x Hu]t N:r (VI) rt-letx=Min N:T Figure 5. Typing rules for polymorphic selective \n,1-calculus Theorem 8 (strong normalization) Polymorphic selective A-calculus is strongly normalizing. \n 7.4 Type unification The key for type synthesis is unification, We give here a unification algorithm \nfor the label-selective monotypes de\u00adfined above. It can be expressed as a simpIe E-unification problem \n[11], where the equational theory is that deciding equality of record types. Then, our type substitution \nopera\u00adtion using record-type concatenation constitutes a complete set of reduction for this theory. We \nnext give this unifica\u00adtion procedure as a complete set of equivalen~-preserving transformations on a \nset of type equations. A set of type equations p is said to be in solved form if every equation in it \nis of the form a = T such that the type variable Q ocmrs only once in p; viz., as this equation s Iefklmnd-side. \nAs usual, such a solved-form detlnes a variable substitution that can be applied to type expressions. \nFigure 6 contains the complete set of transformations for the unification of label-selective monotypes. \nWe use the notation CYfor type variables, w for return types, and -r or@ for any type expression, (Recall \nthat {} + u is identified with u.) These rules work on a set (a conjunction)of type equations, transforming \nit into another such set, Upon termination, having started from a set p of equations, the resulting equation \nset is either 1-, the inconsistent equation indicating (Base type) p,u=v u#v u, v base types L (Variable \nrecurrence) $0, CY=T T#CI a G var(T) -1\u00ad (Variable orientation) ~, T=(Y ct variable T not variable $0, \nQ==T (Decomposition) P, {l*d}.r+u ={l?+e }. f+w p,8=0 , r+w=r +w (Label completion) Figure 6. Equation-rewriting \nrules for type unification that no solutions exist, or sol(p), a set of equations in solved form equivalent \ntop. In either case, this process can be seen as returning a substitution. In the first case, it is the \nfailing substitution J-such that 1 (~) =1 for all types r, where 1 denotes the inconsistent type, In \nthe second case, the solved form sol(w) is the most general unifier (MGU) of p (up to variable renaming). \nThe rules are written as rewrite rules using a comma as an associative and commutative set constructor, \nan the equal sign as a commutative equation constructor. That is, in these rules the particular order \nof equations in the set as well as the orientation of an equation are irrelevant, As established by the \nfollowing theorem, they are solution\u00adpreserving and there is a deterministic strategy that makes them \nalways terminate, Theorem 9 (label-selective type unification) There is an algorithm that computes the \nmost general unijier of a set of equations on monotypes or reports failure if there is none.  7.5 Type \ninference It is now easy to derive a type inference algorithm by combining type unification with the \ntyping rules of Figure 5. It is sufficient to following the syntactic structure of a given term, accumulating \nnew equations in a set, as shown in Figure 7. The function Tp takes a typing environment 1 (a (Function \ntype) p,u=r+u u base type -L r#{} (Variable elimination) p,a=l\u00ad a C Var(~) Var(~) if ~ variable,then \nT E Var(~) [7-\\cY]p, a = T (Redundancy) yJ, e=e Y function from from term variables to types) and a \nselective A-term M, and returns a pair (p, r) where p is a set of type equations in solved form (i.e., \na type substitution), and ~ is the principal type of M. The function strip applies to a type expression \nVQ1. . . .Va~.r, where n > 0, and returns the expression obtained from -r where all the ~is, if any, \nare replaced with fresh names,c The expression IT(r) is the set of free variables in T, and by extension \nW(T) = UX FV(l (x)), The expression SOI(P), where p is a set of type equations, is the solved form of \nq (i.e., the MGU of ~). It is the result of applying the transformation rules of Figure 6 to p until \nnone applies. The expression p(~) is the result of applying the substitution p to the type expression \nT. By extension, q(~) is the function defined by   POW)=%@@)). - This algorithm constructs a derivation \ntree whose root is P FM: r, where r and Mare given. Since there is only one way to construct this tree, \nby induction on the structure of M, this algorithm is complete and correct. This is because only necessary \nequations are added, except for generalization and instantiation, which are handled in the most general \nway in the variable and let caaes. 61f n = O there is no quantifier, and thus strip n4ums the given type \nexpression as is. Tp(l , x) = (0, strip(~(x))) Tp(r, A~x.M) = ($0, [T\\@] ({l.* a} -+ /3)) T (l_ , letx \n= M inlkf ) = (sol(p u P ), T ) Figure 7. me inference algorithm 8 Conclusion and further work We have \nproposed two typing systems for label-selective A\u00adcalculus: simple types and ML-style polymorphic types. \nThe latter are smoothly accommodated thanks to the existence of a simple but flexible record-type concatenation \noperation that facilitates building label-selective currying right into type substitution and unification. \nIntegrated into a polymor\u00adphic functional progr atnrning language with currying, this provides a powerful \ntool, extending currying facilities and helping to memorize multi-argument functions. An interesting \nsubject is how to mix record operations and selective ,1-calculus. The idea comes from the natural encoding \nof records in the untyped calculus, as: {l~+al,..., 4!.*an} ---+ ~..p.(s~ al . . . ~ a.) where sel is \na distinguished fixed channel ands is a function selecting a label and dkcarding the others individually \n(we have no way to dkcard them at once), like ~~,xl. . . . .~~mx..xk. We can even have function using \nmore than one label. This is in fact the basic idea for a transformation calculus. However, there are \nsome essential differences between a classical definition of records and this encoding as it accommodates \nnumerical indices, We suspect that type inference of such a calculus with useful operations might turn \nout to be rather complex, Another application of this calculus might be found in parallel processing. \nIf we now see labels on a stream as identifying threads, the commutation capability duectly interprets \na concurrent evaluation. This is an idea very close to the dataflow paradigm, but we hope to replace \nflow analysis by type synthesis. Another, but not contradictory, view is to see labels as names, like \nfor process communication. It shows a link, which can easily be made more evident, with (p, T)= Tp(l \n[x ++ aJ, M) where cq~fresh{ (Y-1~)= ~P(~>w (p , +)= Tp(l , M ) a fresh (9, 7)= Tp(T, M) where ($0 , \nT ) = Tp(r , M ) r = r[x i-i V(FV(T) FV($7(I ))) .7] [ calculi like Milner s mcalculus [16]. The conjunction \nof those two views seems an interesting prospective. The last, but more immediate, concern is compilation. \nTwo differentversions of selective A-calculus using de Bruijn indices, through explicit substitutions \n[1], have been devel\u00adoped. They reflect two different levels of compilation one that is faithfd to label \nnames, and one where they can be replaced by numeric stack offsets. This might k the basis for an efficient \ncompilation method, which should be built on a completely curried vision, That is, there should be no \noverhead caused by currying. The eflicient compilation method given by Ohori for a record calculus [18] \ngives us some evidence .that this is possible. Acknowledgements The authors are indebted to Atsushi \nOhori for invaluable discussions. Appendix: Proofs of theorems Proposition 4 Record-~pe concatenation \nis associative. Proof: Let us show that&#38;o ~. = 4ti@r(,). We proceed with inverses: ~&#38;,(.J,P(i) \n= i -~tior($)(pi) = i or(pi) o~(~~~(i)) = d~~(d~~(i)). We then have r. (s. t) = rw qi,(s W ~.(t)) \n= r W #,(s) W @,(#.(t)) = r U d,($) ~ &#38;U@rtS)(~) =(r. s). t, 1 Proposition 5 (subject reduction) \nIf r t-M: ~ and A4 + Nthen T1-N:r. Proof: We only need to prove this property when M is a redex and \nN is the result of this reduction. We can then generalize by substitution and repetition. If M is a @xiex, \nit is of the form (ltx: 6.P) ~Q. Then, the basis of the proof tree is: ~[x++6]hP:r+~  rtQ:e P1-Alx:O.P: \n{la6). r+r rkkl:r-+r After reduction the result is N = [x/Q]P. We obtain a derivation tree for r k [x/Q]P \nfrom those of r [x w 6] FP:r+rand T1-Q:tJasfoIlows: (l) doing all a-conversions necessary to the substitution \nof x by Q; (2) suppressing x in the environments (except where it is redefined by an abstraction); (3) \nwhere x appears without being defined in the environment, replacing P f x: 0 by the derivation tree of \nr h Q :6. This poses no problem since VYEW(Q) r(y) = r (y). If the reduction is a reordering, we have \nseven cases. We will only work out in detail cases (3), (6) and (7). Case (3): If the reduction is (3), \nthen the derivation tree must have the following form r[x+6]t-M:{qn+6 }. r--+~ rFN; O rkAPA:O.M: ~m+0,qn~6 \n}. r+r r b (&#38;&#38;6.M)&#38;N: @?2*6} r+ T Since x @ FV(N), we can obtain the following derivation \ntree after reordering: r[xtid] t-M:{qn+O }. r+~ r[xl+6]}N:e r 1-2Pd:6.(M@N) : @m&#38;8}. r+ r Case (6): \nIf the reduction is (6), then n < m, and the derivation tree must have the following form: 1 [x+8] l-M:@z+O \n}. r+r rt-N:e rkAP~x:8.M: @na6 , pm+ O). r+r r 1-(2P~x:0.M)&#38;N: @(m 1)>6}. r + ~ Since x $? FV(N), \nwe can obtain the following derivation tree after reordering: r[xw@]t-M:@n+O }. r+~ r[x He]h N:6 r[x \nH8]k M&#38; N:r+r r ~ &#38;~-lJX:O. (MfiN): -@(m l)*@}. r+ ~ Case (7): If the reduction is (7), then \nm < n, and the derivation tree must have the following form I [x~O] l-M:@(n-l)a&#38;}. r+~ rl-N:O rk \nAP~x:6.M: @m~O, pn~6 j. r+r r 1-(Apmx:O.M);.N: @ma OJ. r--+ r Since x @ FV(N), we can obtain the following \nderivation tree after reordering: r[x++O] l-M:@(n-l)a6 }. r+~ r[x~6]t-N:6 l [xW6]t-MP~l)N:r+~ r F APmX:6.(M&#38;fv):@???*I_+ \n e} T Theorem 6 The simply typed selective A-calculus is strongly normalizing. Proof: The idea is to \nconstruct a function that gives the longest reduction of a term in function of its input. By reduction \nsteps, we only mean here @ductions, since we already know that reordering is Noetherian. First, let us \ndefine zero functions, and the operation of rech fication of a function. h fact, we use Selecti vefinctions \nin place of classical functions, labeling arguments. They are only a practical notation since we know \nthat selection is deterministic by the confluence theorem, and we could translate them to classical functions \nusing their types and the order on labels. Let T={~l +71,.,,, &#38; * r.} + u be a simple type. The zero-function \nfor T, noted 07, is the function ~(11 % xl : T;, ..,, l ~ X. : rJ).0, of type r , where * is defined \nby induction as ({11 a rl, .,.} +u) ={ll +r; ,...}+int (we replace every base type with int). 45 To \nrectify a iimction ~ of type r = {11 + T1, ..., &#38; ~ rn}.r -+ u to r -+ u one simply applies it to \nthe corresponding zero-functions: rect(r + u,f : I-) = f(ll * Or], . ...&#38; + 07 ) . We define our \nfunction Tr (M) by induction on the structure of the term M, annotated with types in some typing environment \nr. We suppose that keywords S and variables V are independent, and use Y U S as symbols for the respective \nselective functions. For a variable T h x: r, the associated function is ~xx: T .x. For an abstraction \nr t ALX: 0.M : {1+ 0} . r --+ T, the associated function is Alx: 0 .Tr[&#38;el (M). For an application \nr k MTN : r -+ T, with r h N :6, the associated function is: Tr(M2N) = AXIX1. . . . . &#38;x~.( (Tr(M)2xl \n. . . XX~TNa) + rec[(int, N : O*) + 1 ) where. 1. FV(N) = {Xl, . . .. XI/}. 2. FV(M)n FV(N) = {Xi,...,Xk},O< \nk< n; 3. Na=Tr(N)~xl... ~;.; 4. for~ : {11 301, . . ..lnaOn }--+intanda.int,  This sum of three terms \nexpresses that N may be reduced after substitution in M, or before, and that there maybe one step of \n~-reduction. In this function we make two approximations. The first one is that we count one step for \neach application, whether or not there is an abstraction to reduce. The second one is that we take the \nsum of the call-by-name and tail-by-vaiue strategies, and not their maximum. Since these are only over-estimations, \nour function gives an upper-bound of the longest reduction path. Ifrk M:{ll+ @l,..., /. + 6.} + T ~d \nrlw@j = {XI I-+ TI,... , Xm +-+ rm}, then TF(M) is a total function from f3; x.. .xO~x~~x ~~tointo This \nmeansthat that on any complete input that is coherent with its typing, M will terminate. Moreover, an \nupper bound of its longest reduction path is given by rect(int, Tr (M) : (r -+ ~) ). I Proposition 7 \n(subject reduction) Z~r 1-M : T in poly\u00admorph ically typed selective ~-calculus, and M + N then rFN:T. \nProof: Since polymorphism can only be used in injunction with let, the proof for simple types is enough \nexcept for let-reduction. In this last case, the derivation tree starts with ~Eletx=Min N:T We first \nperform ail a-conversions necessary to the sub\u00adstitution of x by M. After reduction, we obtain a tree \nwith root T I [x/M]N : T from the derivation tree of r [x ~ u] F N : ~ by replacing every occurrence \nof the ax\u00adiom I /[x F-+a] t-x: o by the derivation tree of I f F M: a; observing that Yye W(M) r(y) = \nT (y). 1 Theorem 8 Polymorphic selective J-calculus is strongly normalizing. Proof: We find an upper \nbound of the longest evaluation of M by that of M, which is M where all occurrences of let are suppressed \nby transforming let x = P in N into K; ([x/P]N)YP, where K = Alx.A lY.x. We need K for the case where \nx does not appear in N. Since the result is monomorphic everywhere, the argument for the simply typed \ncalculus holds. 1 Theorem 9 (label-selective type unification) There is an algorithm that computes the \nmost general unifier of a set of equations on monotypes or reports failure if there is none. Proof: We \nfirst prove the correctness of the rewriting system of Figure 6. That is, for each rewrite rule, any \nsolution of the denominator is a solution of the numerator, and conversely, any solution of the numerator \ncan be extended into a solution of the denominator, possibly by introducing new variables missing in \nthe numerator. The rules labeled Base type, Variable recurrence, Function type detect inconsistencies \nin the equations. That is, respec\u00adtively, equation between two different base types, between a type variable \nand a type containing it, or between a base type and a functional type. When one of these rules applies, \nthe system has no unifier. The Variable elimination rule substitutes variables (using flattening type \nsubstitution), while keeping their referents. Let a be a solution of the numerator. Then, by construction, \nU(Q) = CT(T), thus it is also a solution of the denominato~ and wnversely. The Variable orientation rule \nsimply reorients an equation. It is not really necessary and is provided oniy to obtain the solved form \nwith all solved variables on the left. Clearly, it leaves unchanged the set of unifiers. So does the \nRedundancy rule which just suppresses tautological equations. Decomposition takes a label already present \non the two sides of an equation, and equates the types. Correctness is clear. Whenever a label appears \nonly on one side of an equation, it is necessary to introduce it in the other side. This is done by the \nLabel completion rule using record-type matching. Any unifier of the denominator is also a solution of \nthe numerator, sin= {[q O}uti+~= fl. ~~l{!~$}+~, wtichis by unification equal to / --+ u . Conversely, \nif u is a unifier of the numerator, then it maps w to a functional type of the form q$~1{1+ c(6)} ./ \n--+ u , which can be extended for the denominator by adding a(a) = / + w . We next prove that there \nis a terminating strategy. Ter\u00admination follows for the well-foundedness of a decreasing measure. A variable \nis solved when it appears only once, and as the lefthand-side of an equation. We exhibit a strategy that \nreduces the lexicographical measure (number of unsolved variables,sum of sizes), where the size of a \ntype is the total number of labels, variable occurrences and base types it contains. The three failing \nrules terminate. Redundancy, and Decom\u00adposition reduce the sum of sizes. Variable elimination and Variable \norientation reduce the number of unsolved variables. Label completion by itself does not reduce the measure, \nBut if it is always used it in wmbination with Decomposition on the same equation, eliminating or failing \nas soon as possible, this always reduces the number of unsolved variables. If u is not a variable, we \nfail immediately. Otherwise, it is solved, but we create a new variable CZ.We repeat this until we can \nsolve a successor of a with the left hand side (which may suppose creating a lineage to u too, if completion \nis mutual). This sequence terrninatea, since there is only a finite number of labels on each side. Last, \nwe must show that our result is in solved form. First, in every equation, at least one side is a solved \nvariable, If the two sides are functional types, then either Decomposition or Completion applies, If \none side is a base type, then the other side is a solved variable, otherwise Elimination, Redundancy \nor some failure applies. If the two sides are variables, then at least one is solved. We construct the \nsubstitution a by taking for each equation CY= T, CYsolved, cr(cY) = ~. a is a most general unifier of \nthe final system, and, as a consequence, if we suppress definitions for all variables introduced by completion, \n&#38; is a most general unifier of the original system. B  References 1. Martfn Abadi, Luca Cardelli, \nPierre-Louis Curien, and Jean\u00adJacquesL&#38;y. Explicit substitutions. In Proceedings of ACM Symposium \non Principles of Programming Languages, pages 31-46 (1990). 2. Hassan kit-Kaci and Jacques Garrigue. \nLabel-selective ,4\u00adcalculus. PRL Research report 31, Digital Equipment Corpo\u00adration, Paris ResearchLaboratory \n(May 1993). 3. Hassan /fit-Kaci and Jacques Garrigue. Label-selective A\u00adcalculus: Syntax and confluence. \nIn Proceedings of the 13th International Conference on Foundations of So@are Technol\u00adogy and Theoretical \nComputerScience (Bombay, India), LNCS  761. Springer-Verlag (December 1993). 4. Hassan Aiit-Kaci and \nAndreas Podelski. Towards a meaning of LIFE. Journal of Logic Programming, 16(3 -4]195-234 (July-August \n1993). 5. Kim Bruce, Roberto Di Cosmo, and Giuseppe Longo. Prov\u00adable isomorphisms of types. Technical \nReport LIENS-90-14, LIENS (July 1990). 6. Luca Cardelli. A semantics of multiple inheritance. Informa\u00adtion \nand Computation, 76:138-164 (1988). 7. Luca Crmielli and Peter Wegner. On understanding types, data \nabstraction, and polymorphism. Computing Surveys, 17(4):457-522 (1985). 8. Luis Damas and Robin Milner. \nPrincipal type-schemes for functional programs. In Proceedings of ACM Symposium on Principles of ProgrammingLanguages, \npages 207-212 (1982). 9. N. G. deBruijn. Lambda calculus notation with namelessdum\u00admies, a tool for \nautomatic formula manipulation. Indag. Math., 34:381-392(1972). 10. Pierre Weis et al. The CAML Reference \nManual, version 2.6.1. Projet Fennel, INRIA-ENS (1990). 11. Jean Gailier and Wayne Snyder. Designing \naniiication proce\u00addmes using transformations: a survey. In Y. N. Moschovakis, editor, Logicfiom Computer \nScience, pages153 215.Springer-Verlag (1989). 12. Jacques Garrigue. Label-selective J-calculus. Rapport \nde D.E.A., Universit6 Paris VII (1992). 13. Lalita Jategaonkar and John Mitchell. ML with extended pattern \nmatching and subtypes. In Proceedings of ACM Con\u00adference on LISP andFunctionalProgramming, pages 198-211 \n(1988). 14. John Lamping. A untied system of parameterization for progmmming languages. In Proceedings \nof ACM Conference  on LISP and Functional Programming, pages 316-326 (1988). 15. Henry Ledgard. ADA: \nAn Introduction, Ada Reference Manual (July 1980). Springer-Verlag (1981). 16. Robin Milner. The polyadic \nx-calculus: A tutorial. LFCS Re\u00adport ECS-LFCS-91 -180, Laboratory for Foundations of Com\u00adputer Science, \nDepartment of Computer Science, University of Edinburgh (October 1991). 17. Martin Odersky, Dan Rabin, \nand Paul Hudak. Call by name, assignmen~ and the lambda calculus. In Proceedings of ACM Symposium on \nPrinciples of Programming Languages, pages 43-56 (1993).  18, Atsushi Ohori. A compilation method for \nML-style polymor\u00adphic Kcords. In Proceedings of ACM Symposium on Principles of Programming Languages, \npages 154-165 (1992). 19. Didier R6my. Typechecking records and variants in a natural extension of ML. \nIn Proceedings of ACM Symposium on Principles of Programming Languages, pages 77-87 (1989). 20. R. Stansifer. \nType inference with subtypes. In Proceedings of ACM Symposium on Principles of Programming Languages, \npages 88 97 (1988). 21. Guy L. Steele. Common LISP, The Language. Digital Press (1984). 22. Mitchell \nWand. Complete type inference for simple objects. In Proceedings of IEEE Symposium on Logic in Computer \nScience (1988).  \n\t\t\t", "proc_id": "174675", "abstract": "<p>Formal calculi of record structures have recently been a focus of active research. However, scarcely anyone has studied formally the dual notion&#8212;i.e., argument-passing to functions by keywords, and its harmonization with currying. We have. Recently, we introduced the label-selective &#955;-calculus, a conservative extension of &#955;-calculus that uses a labeling of abstractions and applications to perform unordered currying. In other words, it enables some form of commutation between arguments. This improves program legibility, thanks to the presence of labels, and efficiency, thanks to argument commuting. In this paper, we propose a simply typed version of the calculus, then extend it to one with ML-like polymorphic types. For the latter calculus, we establish the existence of principal types and we give an algorithm to compute them. Thanks to the fact that label-selective &#955;-calculus is a conservative extension of &#955;-calculus by adding numeric labels to stand for argument positions, its polymorphic typing provides us with a keyword argument-passing extension of ML obviating the need of records. In this context, conventional ML syntax can be seen as a restriction of the more general keyword-oriented syntax limited to using only implicit positions instead of keywords.</p>", "authors": [{"name": "Jacques Garrigue", "author_profile_id": "81100518834", "affiliation": "Department of Information Science, The University of Tokyo 7-3-1 Hongo, Bunkyo-ku Tokyo 113, Japan", "person_id": "PP17010225", "email_address": "", "orcid_id": ""}, {"name": "Hassan A&#239;t-Kaci", "author_profile_id": "81100103770", "affiliation": "Digital Equipment Corporation, Paris Research Laboratory, 85 Avenue Victor Hugo, 92500 Rueil-Malmaison, France", "person_id": "P108272", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/174675.174434", "year": "1994", "article_id": "174434", "conference": "POPL", "title": "The typed polymorphic label-selective &#955;-calculus", "url": "http://dl.acm.org/citation.cfm?id=174434"}