{"article_publication_date": "02-01-1994", "fulltext": "\n Decidable Bounded Quantification Giuseppe Castagna* LIENS(CNRS)-DMI 45, rue d Ulm 75005 Paris, France \ncast agnaQdmi.ens.fr Abstract The standard formulation of bounded quantification, system F<, is difficult \nto work with and lacks impor\u00adtant synt;ctic properties, such as decidability. More tractable variants \nhave been studied, but those studied so far either exclude significant classes of useful pro\u00adgrams or \nlack a compelling semantics. We propose here a simple variant of F< that ame\u00adliorates these difficulties. \nIt has a natural ;emantic in\u00adterpretation, enjoys a number of important properties that fail in F<, and \nincludes all of the programming examples for which F< has been used in practice. Introduction Since \nits introduction by Cardelli and Wegner [CW85], the idea of bounded qwwatification has become a fun\u00addamental \ntool in the study of statically typed pro\u00adgramming languages combining subtyping and polymor\u00adphism. Systems \nwith bounded quantification are formed by enriching a typed ~-calculus, such as System F [Gir72, Rey74] \nor Fw [Gir72], with a subtype relation on type expressions, 17 h S < T, and extending the introduc\u00adtion \nand elimination rules for polymorphic types so that each quantifier mentions a bound for the variable \nit in\u00adtroduces. The standard formulation of second-order *Supported by grant no. 203.01.56 of the Consiglio \nNazionale delle Ricerche, Comitato Nazionale delle Scienze Matematiche, Italy t Supported by funding \nfrom the U.K. Science and Engineer\u00ad ing Research Council and the ESPRIT Basic Research Actions TYPES \nand CONFER. This work was begun while the author was a visitor at INRIA-Roquencourt. Permission to copy \nwithout fee 811or part of this material is granted provided that the copies are not made or distributed \nfor direct commercial advantege, the ACM copyright notice and the title of the publication and its data \nappaar, and notica is given that copying is by permission of the Association for Ccmputing Machinery. \nTo copy otharwise, or to republish, requires a fee and/or specific permission. POPL 94-lr 94, Portland \nOregon,USA @ 1994 ACM O-69791 +336-9t94~l ..$3.50 Benjamin C. Piercet LFCS, Univ. of Edinburgh King s \nBuildings Edinburgh, EH9 3JZ, U.K. bcpQdcs.ed.ac.uk bounded quantification, often called F< ( F-sub )), \nwas given by Curien and Ghelli [CG92]. Its subtype relation includes the following rule for comparing \npolymorphic types: rl-Tl<sl r,(X<T1) 1-S2 <Tz (V-orig) r t-v(x< s1)s2 s v(xs T1)T2 Intuitively, this \nrule may be read as follows. A type T of the form V(X < T1 )T2 describes a collection of poly\u00admorphic \nvalues (functions from types to values) each mapping subtypes of T1 to instances of T2. If T1 itself \nis a subtype of S1, then the domain of T is smaller than that of S = V(X < S1 )S2, so S1 is a weaker \nconstraint and describes a larger collection of polymorphic values. Moreover, if, for each type U that \nis an acceptable ar\u00adgument to the functions in both collections (i.e., one that satisfies the more stringent \nrequirement U < T1 ), the U-instance of T2 is a subtype of the U-instance of Sz, then T is a (pointwise \nweaker constraint and again describes a larger collection of polymorphic values. In other terms the two \nfunctions are pointwise compared only on their common domain. (For brevity, we elide the standard well-formedness \ncondition that the bound variable X should not already occur in the context I . ) Though semantically \nquite natural, this rule is re\u00adsponsible for the loss of numerous desirable synt attic properties in \nF<, To begin with, the subtype relation is undecidable [Pi;93, Ghe93b], which implies the undecid\u00adability \nof the typechecking problem even for explicitly typed terms. Even more seriously, F< lacks greatest lower \nbounds for compatible (i.e. lower-bounded) sets of types [Ghe90], which blocks certain useful forms of \nargument by induction on the subtype relation. The most natural extension of F< with bounded existential \ntypes [GP93] even fails to po;sess a minimal type for ev\u00adery typeable term! In all these cases, it is \nthe quantifier subtyping rule that appears as the principal culprit. The crux of the problem is that \nthe upper bound of the bound variable X in Sz changes from S1 in the rule s conclusion to T1 in the right-hand \npremise. This re\u00adbounding of variables is syntactically rather bizarre; in particular, it invalidates \na whole class of arguments based on structural induction on types, where the case for a type variable \nnormally requires applying the in\u00adduction hypothesis to its upper bound, The weaker equal-bounds subtyping \nrule from Cardelli and Wegner s original Fun calculus [CW85] r,(x<u) F S2 < T2 (V-Fun) r t-V(X< U)S2 \n< Y(X< U)TZ avoids this confusion and yields a system for which the subtyping problem can easily be shown \nto be decidable, at the cost of introducing an ugly syntactic restriction that the bounds of the two \ntypes must be identical with no natural semantic motivation. Other variants of (V-orig) have been proposed \nin the literature. Katiyar and Shankar [KS92] describe a re\u00adstriction in which the bounds on polymorphic \ntypes may not contain Top. In this way they obtain a decidable subtype relation, but at significant expense \nin expres\u00adsiveness. Another obvious variation uses the bound S1 of the smaller type in place of T1 in \nthe right-hand premise: I I-TI<S1 r,(x<sl)~ Sz <T2 (V-local) r F V(X< S1 )S2 < V(X< T1 )T2 But Giorgio \nGhelli has pointed out [Ghe93c] that this variant is algorithmically impractical, although the problem \nof its decidability remains open. We propose a simple and appealing alternative: a quantifier subtyping \nrule rtTl<sl r, (X< Top) 1-S2 < T2 (v-top) r F v(xss1)s2s V(XST1)T2 in which the right-hand premise requires \nthat the bod\u00ad ies be (covariantly) related under no assumption about the bound variable. This essentially \namounts to consid\u00ad ering the subtyping relation relative to an unchanging context, since the type variables \nadded to the context always have trivial bounds; the only type variables with interesting bounds will \nbe those already present in the environment at the point where a subtyping check is required. (These \nare introduced, as usual, by the quan\u00ad tifier introduction rule.) Clearly, the proposed rule is strictly \nweaker than (V\u00ad orig). The system with (V-top) in place of (V-orig) we call it F: and give its full \ndefinition in in Section 2 cannot b eused to prove F< -inequalities like However, as we we show in Section \n3, this difference in power does not matter in any of the situations where bounded quantification has \nbeen applied. Moreover, the rule (V-top) is arguably more natural than the other variants we have mentioned, \nsince it embodies a notion of pointwise subtyping familiar from the treatment of other type constructors \n[Mit90, BM92, Bru93, PT93]: it simply says that VF < VG (with F, G : Type-+ Type) iff dorn(G) c dorn(F) \nand F is pointwise smaller than G. F: enjoys many syntactic properties missing from F<. -First and foremost, \nits subtyping problem is de\u00adci~able, as we show in Section 4; moreover, the system has least upper bounds \nfor all pairs of types and, for all lower-bounded pairs, greatest lower bounds. The easier syntactic \nformulation also leads to a sig\u00adnificant simplification of the proofs for this system. For example, Curien \nand Ghelli prove the admissibil\u00adity of the rule of transitivity [CG92] using a rewiting technique similar \nto Gentzen s cut-elimination theorem, whereas here a simple induction on proofs suffices. In the same \nway, we obtain a simpler proof of coherence of the semantic framework for bounded quantification pro\u00adposed \nby Breazu-Tannen, Coquand, Gunter, and Sce\u00addrov [BTCGS91], which we sketch in Section 5; indeed, the \nexistence of meets and joins in our subtype relation permits us to prove the coherence of a stronger \nsystem including variant types. ([BTCGS91] established a sim\u00adilar result for the variant of F< with variant \ntypes and the (V-Fun) rule.) One of the principal benefits of the simpler formula\u00adtion of bounded quantification \nis the ease with which its basic properties may be extended to richer systems. We illustrate this in \nSection 6, which shows how a simple kind of recursive types form a conservative extension of F:, another \nproperty that fails in F< [Ghe93b]. 2 Syntax In what follows, we work modulo a-conversion for type variables, \nwith the convention that bound variables are silently a-converted as necessary so that contexts and types \nappearing in instances of the rules are well formed. (Equivalently, we follow deBruijn [dB72] in regarding \nthe connection between occurrences of variables and their binders as part of the syntax of the calculus, \ncon\u00ad sidering poorly scoped terms as not even parseable. ) It easy to check that, for example, the rules \nbelow pre\u00ad serve the well-formedness of judgments, i.e. the j udg\u00ad ments in the premises are well formed \nif and only if the one in the conclusion is. 0 is a type context with dorn(0) =0. If r is a context, \nX @ dom(r), and for every Y E FV(T), Y E dom(17), then 17,(X< T) is a type context and dorn(l?, (X< T)) \n= cio@ ) u {X}. We write I (X) for the upper bound assigned to X by I . (In every situation where we \nuse this notation, it will be clear that r includes a binding for X.) The types of F: are: T::=X I Top \nI T+T I V(X<T)T Since the change in our definition of the subtype relation does not affect the treatment \nof terms, we will focus only on types and subtyping in the body of the paper. (Typing rules for F< terms \nare given in appendix Al) We use = to denote syntactic identity. There are two kinds of judgment: the \nsubtyping re\u00adlation 17F T < T and the typing relation r F a: T. A judgment I + A is said to be well-formed \niff, for every type T appearing in A, FV(T) ~ dorn(17). In the rest of the paper we consider only well-formed \njudgments. The F: subtype relation is the least three-place rela\u00adtion clos=d under the following rules: \n(refl) rl-T<T rl-Tl<T2 rtT2<T3 (trans) rt-T1<T3 (taut) (Top) I h T< Top rt-Tl<sl rts2<T2 (-+) rkS1-i \nS2<T1-+T2 rFTl<sl r, (x< ToP) I-S2 < T2 (v) 17 F V(X< S1 )S2 < V(X<T1 )T2 (When no ambiguity can arise, \nwe denote the rule (V\u00adtop) simply by (V).) Expressiveness There are some values of S and T for which \nr 1-S ~ T is provable in F< but not in F:. For inst ante, the con\u00adstruction used to show the un~ecidability \nof F< [Pie93] depends crucially on the form of F< s original quanti\u00adfier subtyping rule; similar example~can \nbe built using techniques studied by Ghelli [Ghe93a] in his analysis of the possibility of nontermination \nin the standard semi\u00addecision procedure for the F< subtype relation. But these examples were designed-specifically \nto illustrate pathologies in F<. Are there any useful examples that lie between F< aid F:? We believe \nnot. For example, one of the areas where bounded quan\u00ad tification has been most intensively applied \nis in static type systems for object-oriented languages. One recent study by Pierce and Turner [PT93] \npresents a statically typed model of the core of Smalltalk using an extension of F< with the higher-order \npolymorphism of Girard s Syst=m FW [Gir72]. All of the terms in this model have exactly the same types \nin F: as in F<. Similarly, all the example programs in Ca~delli s implementation of F< [Car93] also typecheck \nin F:, apart from the inten\u00adti&#38;ally pathological cases cite~ above [Luca Cardelli, personal communication, \n1993] Another fairly complex application of bounded quan\u00adtification is Cardelli s translation of a calculus \nof ew tensible record operations into pure F< [Car92]. Again, since each of the row variables in the \n~igh-level calculus is translated into a row of type variables bounded by Top, F: appears to work just \nas well. The _difference in expressive power between F< and F: can be understood by observing the behav~or \nof th>ir standard algorithms for checking the subtype relation. (For F<, the standard algorithm [CG92] \nis a semi-decision procedure; the algorithm for F: pre\u00adsented in Section 4.1 below is a decision proc~dure.) \nThe two algorithms are identical at all points, except for the cases for comparing two quantified types, \nwhich are just the rules (V-orig) and (V-top), respectively. In both cases the left-hand premise is the \nsame; the only differ\u00adence lies in the recursive call corresponding to the right\u00adhand premise, which \nextends the environment with a nontrivial bound for the new variable in the case of F< and, for F~, with \na trivial bound. If the F< algorith~ later enco&#38;ters this variable on the left-h~nd side of the <, \nit has two choices: either it can check that the expression on the right of the < is the same variable \nand immediately succeed, or it can promote the variable on the left to its upper bound from the context \nand try to show that this bound is less than the right hand side. The F; algorithm has only one choice: \nif the expression on the right of the < is not the same variable (or Top), it must fail. F: types strictly \nfewer terms than F<. On the other han~, F: and Cardelli and Wegner s ~riginal Fun are not stric~ly comparable. \nThe assertion F V(x< S)x < V(x< S)s is true in Fun and false in F;, while F V(X< Top)X < V(X< S)X \nis true in F: and false in Fun. But in practical situa\u00adtions, this d~fference does not appear to be very \nimpor\u00adtant. It is principally the more natural semantic intu\u00adition of [V-top] that leads us to prefer \nit over ~-Fun]. There is one intriguing difference, however. Consider the standard enconding of existential \nquantifier: 3(X<S)T = VY.(V(X<S) T -+ Y) + Y This encoding in F: give rise to the following derived subt \nyping rule for e~istential types: rl-s~<Tl 17,(X< Top) 1-S2 < T2 (3-top) r t-3(X< SI)S2 < 3(X< T1)T2 \nIn Fun, on the other hand, this encoding leads to a de\u00adrived rule in which S1 and T1 are required to \nbe the same. r, (x<u) 1-s~ < T2 (3-Fun) r I-3(XS ?3s2 s 3(xs U)T2 It is not too difficult to imagine \nan application where the former rule would be preferable: intuitively, it corre\u00adsponds to the observation \nthat one package implement\u00ading an abstract data type may be more refined than another either when the \nfirst provides more (or more refined) operations than the second, or when the first publically reveals \nmore of the structure of its hidden witness type. This may also have an impact on the use of F< s polymorphism \nas the basis for a language of modules, where the types exported by a module are modeled as existentially \nquantified type variables. 4 Basic Properties In this section we explore the fundamental properties \nof F<. We show the decidabilit y of the subt yping relation, th~ existence of a least upper bound (lub) \nfor every finite set of types and a greatest lower bound (glb) for every finite and downward-bounded \nset of types. 4.1 Subtyping algorithm It is easy to adapt Curien and Ghelli s algorithm [CG92] to F$. \nOnly the rule (AlgV) is different: here it is iden\u00ad tical to (V-top), whereas in the algorithm for F< \nit coin\u00ad cides with (V-orig). We use b~ to denote the al~orithmic system. (AlgRefl) rk. xg rk-r(x)s T \n(AlgTrans) rFAx<T (AlgTop) I h~T <Top r\\ATl<sl r, (x<TOp) ~. SZ < T2 (AlgV) r F. v(xss1)s2s V(XST1)T2 \nNote that the algorithm defined by these rules is de\u00adterministic, since the form of the input unequivocally \ndetermines the rule that must be used not true in the original system because of (refl) and (trans) \n and all the parameters of any recursive calls not true in the original system because of (trans). \n4.1.1 Soundness and completeness We now show that every judgment provable in the algo\u00adrithmic system \nh~ is also provable in the original system F (soundness of the algorithm) and that every relation provable \nby 1-is provable also by h~ (completeness of the algorithm). Finally, we show that the algorithm actually \nhalts on every input and hence constitutes a decision procedure. A first lemma give us the shape of the \nsequents that are provable by kA: Lemma 4.1 Let I bA S < T. Then: 1. IfS=Top, thenT=Top. 2. If S is \na variable X, then either T = X orT = Top, or eke r hAI (X) < T.  3. IfS=S1-+S2,then either T=ToporelseT= \nTI-+Tz wzth17~ATl <S1 and I kA SZ <T2. ~. If S = Q(X < S1)S2, then ezther T = Top or else T = V(X< T1)T2 \nwith r KA T1 < S1 and r, (X< TOP) ~A 5 2< Tz. Moreover, the imptied subtyping judgments care proved by \nsubdertvattons of the origznals. Proof. By inspection. End of proof. To prove the completeness of the \nalgorithm we need two simple lemmas, which show that the relation de\u00adfined by F~ is reflexive (lemma \n4.2) and transitive (lemma 4.3); in other words the two rules that belong to the definition of 1-and \nnot FA are derived rules in tA. The proofs are straightforward inductions on the lengths of derivations. \nLemma 4.2 For each context r and type T (well\u00adformed in r), the judgment r I--AT < T M provable. Proof. \nStraightforward. End of proof. Lemma 4.3 For each context ~ and well-formed types S1, S2, and S3, ifr \nt-S1 < S2 and17 tAS2 < S3, then rtA S1s S3. Proof, If S3 z Top, then the result follows from (Al\u00adgTop). \nThus we can restrict our attention to those cases in which S3 ~ Top; note that by lemma 4.1 S2 must also \nbe different from Top. Let d~ denote the depth of the proof of r F* S~ < Si+l for i = 1,2. We proceed \nby induction on (dl +d2), with a case analysis on the last rule of the proof of 17F~ S1 < S2 (AlgRefl) \nr h-SI~ S2 < SS is satisfied by hypothesis. (AlgTrans) SI s X. By applying the induction hy\u00adpothesis \nto the first main premise s second premise and the second main premise, we obtain that r t~ I (X) < S3; \nthe result follows by (AlgTrans). (AlgTop) Cannot occur, since we assumed S2 # Top. (Alg+) S1 s SI + \nS; and Sz = Sz -+ Sj, and, since Sa#Top, bylemma 4.1S3~ S3~ S:. By the induction hypothesis, r t.4 &#38; \n~ S1 and r t. S; < S:; by (Alg~) we obtain the result. (AlgV) Similarly, we have by assumption that S1 \n= V(X < S1)S{ and Sz s V(X < SZ)SJ, and, since S374Top by lemma 4.1 S3 -V(X<S3)S4. By the induction hypothesis, \nr F~ S3 < S1 and r, (X< Top) h.. S{ < S:; the result follows by (AlgV). Note that this case causes significant \ndifficulty in the proofs of Curien and Ghelli [CG92] and Breazu-Tannen et al. [BTCGS91]. End of proof. \n Theorem 4.4 (Soundness and completeness) For each context r and well-formed types S1 and S2 ~ Proof. \nWe start by proving soundness (~) by induc\u00ad tion cm the depth of the proof of I FA S1 < SrJ. At each \nstage of the induction, we proceed by cases on the final rule used in the proof. The cases for (AlgRefl) \nand (AlgTop) are immediate; (Alg~) and (AlgV) follow by straightforward use of the induction hypothesis. \nFor (AlgTrans), we have Sl= X. By the induction hypoth\u00adesis, r F I (X) < S2; by (tvar) 171-X < I (X); \nthus by (trans) we obtain the result. Completeness (<) follows from lemmas 4.2 and 4.3. End of proof. \n This establishes that the systems E and E~ are equiv\u00adalent and we can eliminate the A indexing the turnstyle \nsymbol. In particular this implies that the lemma 4.1 is also valid for t-. Note that in a proof of subtyping \nwe are now allowed to mix rules of the two systems since, by induction, for every subproof there exists \nan equivalent proof using only rules of the same system. Thus in the proofs of the theorems that follow \nwe will freely use rules from both systems. In particular we will refer to algorithmic or full transitivity, \naccording to our needs. 4.1.2 Termination We first define the wetght of a type T with respect to a type \ncontext r (with T well formed in I ): 7(Top). = 1 fix)r = 7(r(x)), -t 1 ~s, + S2?)17 = 7(Sl)r + 77S2)r \n7(V(X<Sl)S2)r = 77Sl)r + Xsz)r,(xSI) In the final case, the variable X is added to the con\u00adtext with \nthe bound S1 instead of Top so that it will have the same bound on the left as on the right. This is \nused in the following proof to define an ordering that depends on the bounds of a variable. Katiyar and \nShankar [KS92] give a similar proof of termination for their variant of F<. Lemma 4.5 For each type \nT well formed in a context J7, the weight 7(T)r is jinite and positive. Proof. First, it is obvious that \nthe weight 7(T)r is al\u00adways positive. Now, we give a well founded rank for 7(T)r (i.e. we define a rank \nfor the definition of the weight itself) and we show that it decreases at each stage in the definition \nof T. To define the rank of 7(T)r consider all the variables that appear in T and 17 (no matter whether \nthey appear free or bound, only in a quantifier or in a bound). Since T is well formed in r, every variable \nis associated to a unique bound (either in r or in T); furthermore it is also possible to totally order \nthese variables in a way that if Xi is defined in the bound of Xi then Xi precedes Xj (since T is well \nformed in r, loops are not possible). If there is more than one order satisfying this condition then \nchoose one arbitrar\u00adily. Define the depth of each variable as the number of variables that precede it \nin this order. Then the rank of fiT)r is the lexicographical size of the pair (D, L), where D is the \nmaximum depth of any of the variables that appear in T, and L is the textual length of T. This rank is \nwell founded (the least element is (O, 1)). It easy to see that for the subproblem on the right-hand \nside of 7(S1 ~ S2)r and 7(V(X< Sl)S2)r, the component D either is the same or it decreases, while the \nL compo\u00adnent always strictly decreases; for the case 7(X)r, the component D strictly decreases. End of \nproof. The weight function is extended to type judgments in the obvious way: fir F S1 < S2) = 7(Sl)r \n+77 S2)r. Now we can show the termination of the algorithm. Theorem 4.9 Let S and T be well-formed types \nin a context r. Lemma 4.6 For all types S and T well formed in 17, (a) There is some U such that I_ t-S, \nT < U and such 77T)r,fxg~pJ S fl~)r,(xs.y that r t U < U whenever r 1-S, T < U . Proof. By the previous \nlemma we are now allowed (b) If there as any V such that 17 t V < S, T, then to prove this lemma by induction \non 7(T)r,(x~OPJ + there w some L such that r t L < S, T and such End of that I b L < L whenever r t L \n< S,T. flT)r,tx~J. The proof is straightforward. proof. Proof. In this proof we consider derivations \nin t~. We prove both cases simultaneously by induction on 7(S)r+ Theorem 4.7 At every step of the subtyping \nalgorzthm, 7(T)r. the weight of each of the premases is strictly smaller than First, note that the theorem \nis immediate when one of the two types is Top: the lub is Top and the glb is the Proof. The verification \nis easy in most cases. The only other type. Also trivial is the case when S= T. Thus, we non-trivial \ncase is (AlgV), which is proved by the follow-may assume that T and S are two distinct types both ing \ninequalities: different from Top, and consider the remaining cases: the weight of the conclusion. 1. \nBoth S and T are variables. For part (a) we have J(C, (X<Top) F Sz < Tz) two cases: either the two variables \nare related, and = fll$ z)c,(xgop) + 7(T2)C+%Z-I-OP) by lemma 4.6 in that case the greater of them is \nthe lub; or the s Tsz)c,(x%) + 7T2)C, (W1) two variables are unrelated and we can apply the< 7(Sl)c +7-( \nT l)C + 775 2)c, (xg1) + 77~2)c, (xg1) induction hypothesis to I (S) and r(T), obtaining = ~V(X<SI)Sz)C \n+ 7(V(X<T1)T2)C that there exists a type U which is their lub. Now, = Xc 1-V(x<s,)s, < V(X<T,)T2). every \nupper bound of I (S) is an upper bound of End of proof. S too, and every proper upper bound of S is an \nupper bound for I (S). Thus the set of proper up-Corollary 4.8 The algorzthm terminates. per bounds of \nS coincides with the set of upper bounds for I (S); the same holds for T. Since the two variables are \nunrelated the set of their common  4.2 Meets and joins upper bounds coincides with the set of their \ncom-Decidability of subtyping is clearly a desirable property, mon proper upper bounds, which is equal \nto the set but in practice the undecidability of F< has been much of common upper bounds of r (S) and \nr(T). less problematic than the nonexistence of least upper For part (b), simply note that by lemma 4.1 \nif S bounds and greatest lower bounds in the subtype rela\u00adand T have a common lower bound Z then it is \na tion. Ghelli [Ghe90] observed that, in F<, the types variable. If a variable is provably smaller than \nan\u00adother variable then the proof consists only of rules SZV(Z<X+Y)X+Y (AlgTrans) (this can be obtained \nby a trivial induc-T a V(Z<X -+ Y ) X ~ Y tion on the depth of the derivation). Consider the proofs of \nr F Z < S, T. Since they both start fromin the context Z and always use the same rule (AlgTrans), which \nr ~ {X<Top, Y<Top, X <X, Y <Y} is deterministic, then the shorther proof must ap\u00ad pear as a subproof \nof the longer one; thus using full have two lower bounds namely U s V(Z < X ~ transitivity either r \nt-S < T or r b T < S holds. Y) X ~ Y and V R V(Z<X + Y) Z but that The lesser is the glb. there is no \ngreatest lower bound of S and T, since U 2. Both S and T are arrow types: S = S1 -S2 and and V have no \ncommon supertype that is also a subtype T= TI--+T2. of S and T. From this, it is easy to show that F< \nalso lacks lubs. For example, S + Top and T + To; have For part (a), if S1 and T1 have a common lower \nno lub. bound then by the induction hypothesis there exists Here, by contrast, a simple induction on \nthe weight S1 m T1, the glb of S1 and T1 with respect to r. defined in the previous section shows that \nevery pair of Then it is trivial to show that the lub of S, T is types in F~ does possess a least upper \nbound, and that SI n T1 -+ S2 U T2 where S2 U T2 is the lub of every pair ~f types with any lower bound \nat all possesses Sz and Tz with respect to l_ (which exists by the a greatest lower bound. induction \nhypothesis). If S1, T1 have no common lower bound then it is clear that the lub of T and S is Top. For \npart (b), suppose that there exists V satisfying the hypothesis of the lemma. Then by lemma 4.1, either \nV ~ VI + V2or V isavariable. If V = VI + V2 then 17 1-V? < S2, T2; thus by the induction hypothesis there \nexists S2 n T2, the glb of Sz and T2 with respect to I . As in part (a) it is then easy to showthat S1u \nT1~ S2n T2isthe glbofT,S where S1 u T1 is the lub of S1 and T1 with respect to r, which exists by the \ninduction hypothesis. If V is a variable then consider the following defi\u00adnition of B(T)r: 1.B(T)r = \nT if T is not a type variable. 2. B(X)r=13(I (X))r. Clearly, r 1-V < B(V)r, and, by induction on the \nsize of this derivation, I t-l?(V)r < S, T. By lemma 4.1 Z?(V)r = V1 ~ V2. Thus it suffices to apply \nthe induction hypothesis as above, using B(V)r in place of V, to obtain the result. 3. Both S and T \nare universally quantified types. This case is similar to the previous case, but since this is where \nthe induction hypothesis fails if we try to use the same argument for F<, let us examine the critical \npassage in more detafi. Consider part (b) of the statement when V is not a variable; let S= V(X<SI)S2, \n=V(X<SI)S2, and VSV(X< V1)V2. Then by rule (V) we have I :S1,T1<V1 r, (X<Top) F V2 < S2, T2 By the definition \nof T we can apply the induction hypothesis on both judgments, obtaining L1 and L2 such that andsuchthat \nrFWI <L1andr,(X< Top) F WZ < L2 whenever rt-sl, sl<wl r, (X<Top) 1-W2 < SZ, TZ. It is then clear that \nV(X< L1)L2 is the glb. 4. One of the two types, say S is a type variable and the other not. Then for \npart (a) we can apply the induction hypothesis to I (S) and T. For part (b) we must have 171-S < T (by \nthe same observation as in case 1). End of proof.  5 Semantics TO give Sel-nantics to F: we recast \nthe technique de\u00adfined in [BTCGS91] for tie semantics of F<. In this pa\u00adper, a semantics for F< plus \nrecord and recursive types is given by translating the system into an extension of System F for which \nsound semantic interpretations are already defined; thus the semantics of a typing judg\u00adment of F< is \ngiven by the semantics of its translation in F. Actually the translation is defined for the deriva\u00adtions \nof judgments of F<; because of the subsumption rule a judgment in F< have different derivations; the \nsoundness of the meth~d is given by a coherence result, according to which different derivations of the \nsame F<\u00adjudgement are translated into provably equal terms ~f F and therefore have the same semantic \ninterpretation. The key idea of [BTCGS91] is to consider the rule of subsumption as the use of an implicit \ncoercion: the translation makes this coercion explicit. For example, given a term a: S with S< T, the \nterm (kz~ .b) a is trans\u00adlated into (kz?~ .b ) (Cs,T (a* )), where cs,T is a coercion from S to T and \na*, b are the translations of a and b. Thus the language TARGET into which we translate F~will be an \nextension of Girard s System F [Gir72] by (r=cursive types, records, and) coercion spaces, denoted by \nT o-+ T. The translation of a term AX< T.a takes as parameters both a type X and a coercion function \nfrom X to T; this coercion will be explicitly used in the translation of a to replace the implicit use \nof subsump\u00adtion in a. More precisely we give a translation * that translates the type V(X< S)T into VX. \n(X o+ S*) -+ T* and translates a term a: T into a term a*: T*. A subtyping judgment S < T will be translated \nas a coercion function in (S* O+ T*). This coercion will de\u00adpend on the derivation of the judgement. \nA derivation is coded by composing some coercion combinators, each combinator corresponding to the translation \nof a differ\u00adent subtyping rule. For example the rules (trans) and (V) are translated by the combinators \ntrans and forall in the following way: :VX((XG ST) -+ s;) o+ VX((Xc+T~) -+TJ) The second rule is where \nour translation differs from the one of [BTCGS9 1], both for the definition of the combinator forall \nand for the types used in the rule. The precise behavior of each combinator is determined by a function \nLs,l : (S@ T) + (S ~ T). Let us show it for the most interesting combinator, i.e. forall: L(forall(a)(b)) \n= Azvx(x~s )+s .Ax.Axx -s . L(6(X)(top[X])) (.z(X)(trans(t) (a)), where a:T1 o+ S1 and b: VX. (Xo+ 1) \n-+ (S2 o+ T2). Note that, unlike the translation in [BTCGS91], the term interpreting forall is linear \nin the parameter z. We have translated types and subtyping derivations; to complete the translation it \nstill remains to translate typing derivations. The most import ant translations are the following ones: \nf *, X,(z:Xc+ T*) F a: T * [VINTRO]* I * } LYAzX ~ .a: dX(X O+ T*) ~ T/* An abstraction on a bounded \ntype variable also takes -. as argument a coercion from the type variable to (the translation of) its \nbound. r*t-a:VX(Xe S*)~T* r l-b:s o+s [VELIM]* r F a(S *)(b):T*[X := S *] When we pass a type to a bounded \nquantification we also have to pass the coercion function from that type to the bound I * h a: T * f \n h b:T * o+ T [SUB]* r \\ (~(a))(b): T* Whenever we use subsumption on a term we explicitly coerce that \nterm. Finally we have the coherence result, following essen\u00adtially the argument of [BTCGS91]. Theorem \n5.1 (Coherence) If Al, AZ are two F~ derivations of the same typing judgment, then the~r translations \nyield provably equal terms in TARGET. [BTCGS91] also considered an extension of their system with variant \ntypes. There, the proof of coherence fails for full F<, but succeeds for F< with the weaker (V-Fun) rule.-It \nis not hard to check that the same proof technique also works for F: when variants are present in addition \nto recursive typ es and records. For a review of the models of TARGET see section 6 of [BTCGS91].  6 \nConservativity of Simple Recursive Types In Section 5, the only rule for comparing recursive types was \nreflexivity. Here we study a more interesting for\u00ad mulat ion of recursive types. 1 We add to the subtyping \nrules of section 2 the following rules r k S[X := /uX.Sl < T (Unfold-L) rtpx.s<T r 1-T < S[x := px.q \n(Unfold-R) rtT<px.s Let us denote the new system by F~P and write its judgments with ~. In [Ghe93b] it \nis shown that adding these two rules to F< leads to a non-conservative ex\u00adtension i.e. that th~re is \na subtyping judgment in F< which is not provable in the original system but whic~ is provable with the \nextended system. In that same pa\u00adper a characterization is given for the pairs of type for which the \nconservativity does not hold. Here we can show that F~P is a conservative extension of F:. Unfortunately \nwe cannot use Ghelli s chara~teriza\u00ad tion of the non-conservative judgments to prove this, since the \nset of non-provable judgments in our sys\u00ad tem is strictly larger than in F<; thus there might be a judgment \nthat makes conservativity fail in F:, but that is provable in F< and hence hence would-n t be taken into \naccount by ~his method. Therefore we prove conservativity directly, by showing that if a judgment not \ncontaining recursive types is provable in F< P then it is provable in F;. More exactly, we prove-that \nif r $ S < T is pro~able and r, S, and T do not con\u00adtain recursive types then r 1-S < T is provable, \ntoo. This can be obtained very straightforwardly by replac\u00ading in h. the full transitivity rule by transitivity \nonly on variables. r+r(x)<T (Alg~ans) rl-x<T We denote the corresponding proof system by t~. Let us see \nmore precisely the types we take into ac\u00adcount; they are those of F: plus the recursive types: T::=X \nI T~T I Y(X<S)T I ~X.T As in [Ghe93b], we forbid recursive types whose body is either Y, Top, or pX.T; \nthis will simplify the proofs without changing the power of the system: the first two 1It is known that \neven this formulation is insufficiently flexible for some situations in which recursive types can be \napplied. For a deeper treatment of the combination of recursion and subtyping see [Ama91]. It is not \nknown whether the proof of conservativ\u00adity given here can be extended to a second-order variant of that \nsystem. can be forbidden since pX.Y (Y ~ X), and pX.Top de\u00adnote just Y and Top; pX.X is meaningless \n(this is the only real restriction); and pX.pY.T can be forbidden since it has the same unfolding as \npX.T[Y := X]. From a formal point of view we have to distinguish syntacti\u00adcally between recursion variables \nand universally quan\u00adtified variables, since only the latter have upper bounds, but this is not essential \nfor the purposes of this section. Lemma 6.1 If there is a proof of 1? kti S ~ T and no recursive type \nappem-s in the ~udgment then no unfold rule appears in the proof. ProoJ A trivial induction on the depth \nof the proof of rt&#38;s<T. End of proof, In order to shorten the statement of the lemma that fol\u00adlows, \nwe introduce the notion having the same shape. Definition 6.2 Two types have the same shape if they are \nboth type variables, or both Top, or both arrow types, or both parametric types quantified over the same \ntype variable, or both recursive types quantified over the same type variable. Now we can to prove a \nlemma which roughly corre\u00adspends to Lemma 4.1: Lemma 6.3 Let f Fd T1 < T2. Then 1. If T1 is not a variable \nthen one of these cases holds: -T2 M Top -T2 has the same shape as T1 -T1zpX.T and T2 has the same shape \nas T -T2spX.T and T1 has the same shape as T 2. If T2 is not Top then one of these cases holds: -T1 \nis a variable -T1 has the same shape as T2 -T2= pX.T and T1 has the same shape as T -T1zpX.T and T2 has \nthe same shape as T   Proof. By induction on the depth of the proof of r F&#38; T1 < T2. We perform \na case analysis on the last rule of the proof when the last rule is (refl), (+) or (V) then the result \nfollows since T1 and T2 have the same shape. When the last rule is (Top) or (VarTrans) both the points \nof the lemma are satisfied, too. Suppose that the last rule is (unfold-L): then T1 = pX.T and r F@ T[X \n:= T1] < T2. By assumption, T can be neither a variable nor a recursive type. Thus by part 1 of the induct \nion hypothesis, there remain three sub cases: a) T2-Top and the result is immediate. b) T[X := Tl] has \nthe same shape as Tz. But since T is not a variable this implies that also T has the same shape as Tz \nwhich gives the result. c) T2 is a recursive type, but then it has the same shape as T1. The case for \n(unfold-R) is similar: use the hypothesis that T cannot be Top. End of proof. Finally we have transitivity \nelimination: Lemma 6.4 For each context r and types T1, T2, and T3 well-formed in 17, if 17 kti T1 < \nT2 and r F&#38; Tz < T3 then 17 Fti T1 < T3. Proof. The proof is very similar to the one of lemma 4.3. \nAgain we prove the lemma by induction on the sum of the depths d~ of the proofs of 17 bd Ti < Ti+l (i \n= 1, 2), considering only the cases in which T2 and T3 are different from Top. Moreover, we can suppose \nthat the last rule of r F@ T2 < T3 is different from (refl), since in that case the result trivially \nholds. Proceed by case analysis on the last rule of the proof of r Fd T1 < T2: (refl) the result then \ngets r bp TIE T2 < T3 satisfied by hypothesis. (AlgTkans) T1 E X. By the induction hypothesis we obtain \nr F@ I (X) < T3; by applying (AlgTrans) we obtain the result. (Top) Not possible by assumption. (+) T1 \nE T; -+ T; andTzs T; ~ T;. Thereare two subcases and both of them are proved by ap\u00adplying the induction \nhypothesis on r F@ T; < T; and r Fti T; < T;. Since T3 $ Top, by lemma 6.3 either: 1.T3E T;~ T:. BytheformofT1,T2,andT3 \nand the definition of hd, there are smaller deriva\u00adtionsofrFtiT; <T; s T{ and r ~ti T; 5 T; < T;. The \ninduction hypothesis then yields I tti T; < T; and r tti T{ < T;, from which the result follows by (-+). \n2. T3 = pX.T1 -+ T . Similar, except that the right-hand subderivation must end with (unfold-RJ preceded \nby (+), yielding subderivations of I t~ T~[X := T3] s T; < T; andr F&#38;T; < T; < T([X := T3]. The result \nthen follows from the induction hypothesis, (-+), and (unfold-R). (V) Similar. (unfold-L) By the induction \nhypothesis and (unfold-L). (unfold-R) T2 R pX.T. Then there are two possible subcases: 1. The last rule \nof r F@ T2 < T3 is (unfold-L). Then we apply the induction hypothesis on 17F@ T1 < T[X := T2] and 17Eti \nT[X := T2] < T3. 2. The last rule of 17Ffi T2 < T3 is (unfold-R), so T3E pY.T . Thus we can apply the \ninduction hypothesis to r td T1 < T2 and r ~ti Tz < T [Y := T3]. By applying (unfold-R) again, we obtain \nthe result. End of proof. Corollary 6.5 If I ~ S < T is provable then I hd S < T is also provable. Proof. \nBy induction on the depth of the proof of r ~ S < T. Apply lemma 6.4 when the last rule is (trans). End \nof proof.   Conclusions We have presented a new formulation of bounded quan\u00adtification, enjoying many \nproperties that the usual for\u00admulation, F<, lacks. This system also has a high tol\u00aderance for extensions, \nas we showed in the case of re\u00adcursive types. This leads us to believe that F: should also retain the \nminimal typing property when =xtended by bounded existential types. (This property has been established \nin [GP93] for F< with (V-Fun) instead of (V\u00adorig) by showing the completeness of a type synthesis algorithm \nsuggested by Dezani, which can perhaps be adapted to (V-top). ) The investigation of extensions of F: \nwith higher-order polymorphism is also underway. Acknowledgments Special thanks go to Luca Cardelli, \nwithout whose en\u00adcouragement this paper would not have been written. Giorgio Ghelli joined us in enlightening \nconversations about the relation of F: to its neighbors. The obser\u00advation that the Penn-stile semantics \nis linear is due to Martin Abadi.  References [Ama91] R. Amadio. Recursion and Subtyping in Lambda Calculi. \nPhD thesis, Universit~ degli Studi di Piss, 1991. [BM92] Kim Bruce and John Mitchell. PER models of subtyping, \nrecursive types and higher-order polymorphism. In Proceedings of the Nz ne\u00ad teenth ACM Symposium on Principles \nof Pro\u00adgramming Languages, Albuquerque, NM, Jan\u00aduary 1992. [Bru93] K. B. Bruce. Safe type checking in \na statically typed object-orient ed programming language. In 20th Ann. ACM Syvnp. on Principles of Pro\u00adgramming \nLanguages. ACM Press, 1993. [BTCGS91] V. Breazu-Tannen, T. Coquand, C. Gunter, and A. Scedrov. Inheritance \nas implicit coer\u00adcion. Information and Computation, 93(1) :172 221, July 1991. [Car92] Luca Cardelli. \nExtensible records in a pure cal\u00adculus of subtyping. Research report 81, DEC Systems Research Center, \nJanuary 1992. To appear in [GM93]. [car93] L. Cardelli. An implementation of F<. Techn\u00adcal Report 97, \nDigital Equipment Corporation, February 1993. [CD80] M. Coppo and M. Dezani-Ciancaglini. An ex\u00adtension \nof the basic functionality theory for the ,Lcalculus. Notre-Dame Journal of Formal Logic, 21(4) :685-693, \nOctober 1980. [CG92] P. L. Curien and G. Ghelli. Coherence of sub\u00adsumption, minimum typing and the type \ncheck\u00ading in F<. Mathematical Structures in Com\u00adputer Scz&#38;ce, 2(l), 1992. [CW85] L. Cardelli and \nP. Wegner. On understand\u00ading types, data abstraction, and polymorphism. Computing Suroeys, 17(4):471-522, \nDecember 1985. [dB72] Nicolas G. de Bruijn. Lambda-calculus nota\u00adtion with nameless dummies: a tool for \nau\u00adtomatic formula manipulation with application to the Church-Rosser theorem. Indag. Math., 34(5):381-392, \n1972. [Ghe90] G. Ghelli. Proof Theoretic Studies about a Minimal Type System Integrating Inclusion and \nParametric Polymorphism. PhD thesis, Di\u00adpartimento di Informatica, Universit&#38; di Piss, March 1990. \nTech. Rep. TD-6/90. [Ghe93a] G. Ghelli. Divergence of F< type-checting. Technical Report 5/93, Dipartl~ \nmento d Informatica, Universit5 degli Studi di Piss, 1993. [Ghe93b] G. Ghelli. Recursive types are not \nconserva\u00adtive over F<. In M, Bezem and J.F. Groote, editors, In~ernational Conference on Typed Lambda \ncaiculi and Applications, number 664 in LNCS, pages 146 162, Utrecht, The Nether\u00adlands, March 1993. Springer-Verlag. \nTLCA 93. [Ghe93c] G. Ghelli. S-AWLOC is not transitive. Mail to the TYPES mailing list, February 1993. \n[Gir72] J-Y. Girard. Interpretation fonctionelle et elimination des coupures clans l arithm~tique d ordre \nsup&#38;ieur. Th&#38;e de doctorat d &#38;at, 1972. Universit6 Paris VII. [GM93] Carl A. Gunter and John \nC. Mitchell. Theoret\u00adical Aspects of Ob~ect-Oriented Programming: Types, Semantics, and Language Design. \nThe MIT Press, 1993. To appear. [GP93] [KS92] [Mit90] [Pie91] [Pie93] [PT93] [Rey74] [Rey88] [Rey91] \nG. Ghelli and B. Pierce. Bounded existential and minimal typing. Draft report, Diparti\u00admento d Informatica \nUniversit~ di Piss, 1993. Unpublished. D. Katiyar and S. %nkar. Completely bounded quantification is \ndecidable. In Proceedings of the ACM SIGPLAN Workshop on ML and its Apphcations, pages 68 77, San Francisco, \nJune 1992. John C. Mitchell. Toward a typed foundation for method specialization and inheritance. In \nProceedings of the 1 lth ACM Symposium on Principles of Programming Languages, pages 109-124, January \n1990. To appear in [GM93]. B.C. Pierce. Programming with Intersection Types and Bounded Polymorphism. \nPhD thesis, Carnegie Mellon University, December 1991. Available as School of Computer Science tech\u00adnical \nreport CMU-CS-91-205. B.C. Pierce. Bounded quantification is undecid\u00adable. In .20th Ann. ACM Symp. on \nPrinciples of Programming Languages. ACM-Press, 1993. B.C. Pierce and D.N. Turner. Simple type\u00adtheoretic \nfoundations for object-oriented pro\u00adgramming. Journal of Functional Program\u00adming, 1993. To appear; a \npreliminary version appeared in Principles of Programming Lan\u00adguages, 1993, and as University of Edinburgh \ntechnical report ECS-LFCS-92-225, under the title Object-Oriented Programming Without Recursive Types \n.  J.C. Reynolds. Towards a theory oft ype struc\u00adtures. LNC S, 19:408 425, 1974. J .C. Reynolds. Preliminary \ndesign of the pro\u00adgramming language Forsythe. Technical Report CMU-CS-88-159, Carnegie Mellon University, \nJune 1988. J.C. Reynolds. The coherence of languages with intersection types. In T. Ito and A. R. Meyer, \neditors, Theoretical Aspects of Computer Sojt\u00adware (Sendai, Japan), number .526 in LNCS, pages 675 700. \nSpringer-Verlag, September 1991. A Summary of Typing Rules A.1 1?< typing rules [Vars] r t-~: r(z) [~INTRO] \n[+. ELIM] 17,(cT) 1-a:T r t\u00ad(AZT.CJ):T + T rl-a:S+T rkb:s 17+a(b):T [ToP] r t-top: Top [VINTRO] [VELIM] \nr r, (x<T) r t-AX<T.a: 1-.: V(X<S)T r t-~(sf): t-~: T V(X<T)T rks <s T[x:=s] [SUBSUMPTION] I ka:T I \nt-.:T rkT <T A.2 Record, variant and recursive types [(()) INTRO] [(())ELIM] [DINTRO] [ HELIM] [,UINTRO] \n[.LJELIM] r+ rkal:T1... FP:TPTP r+(ll= al,...; lP=aP): ((ll:Tl,...; lP:TP)) I \\a:((l,: T,,...; tP:TP)) \n17k a.l,:T, rl-a; T, 17E[ll:Tl,.. .; f2, =a, &#38;: TP]:[ll:Tl,:Tl, . . ..&#38;. T,, . ..&#38;. b:[ll:Tl,. \n..t?P:Tp]:Tp] rkal:Tl+T...r+aP:TP+T rt-case bofll+al, . . ..tP+ .P:T r F a: T[X := ,uX.~ r } intrO@.T(a): \nP-Y.T r 1-a: pX.T r t-elim(a): [X := pX.Tl TP]  \n\t\t\t", "proc_id": "174675", "abstract": "<p>The standard formulation of bounded quantification, system F&#8804;, is difficult to work with and lacks important syntactic properties, such as decidability. More tractable variants have been studied, but those studied so far either exclude significant classes of useful programs or lack a compelling semantics.</p><p>We propose here a simple variant of F&#8804; that ameliorates these difficulties. It has a natural semantic interpretation, enjoys a number of important properties that fail in F&#8804;, and includes all of the programming examples for which F&#8804; has been used in practice.</p>", "authors": [{"name": "Giuseppe Castagna", "author_profile_id": "81100388576", "affiliation": "LIENS(CNRS)-DMI, 45, rue d'Ulm, 75005 Paris, France", "person_id": "PP31040104", "email_address": "", "orcid_id": ""}, {"name": "Benjamin C. Pierce", "author_profile_id": "81100303310", "affiliation": "LFCS, Univ. of Edinburgh, King's Buildings, Edinburgh, EH9 3JZ, U.K.", "person_id": "PP14111353", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/174675.177844", "year": "1994", "article_id": "177844", "conference": "POPL", "title": "Decidable bounded quantification", "url": "http://dl.acm.org/citation.cfm?id=177844"}