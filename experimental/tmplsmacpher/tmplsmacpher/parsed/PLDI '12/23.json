{"article_publication_date": "06-11-2012", "fulltext": "\n Engage: A Deployment Management System Je.rey Fischer Rupak Majumdar Shahram Esmaeilsabzali genForma \nCorp, USA MPI-SWS, Germany MPI-SWS, Germany jeffrey..scher@genforma.com rupak@mpi-sws.org shahram@mpi-sws.org \n Abstract Many modern applications are built by combining independently developed packages and services \nthat are distributed over many machines with complex inter-dependencies. The assembly, instal\u00adlation, \nand management of such applications is hard, and usually performed either manually or by writing customized \nscripts. We present Engage, a system for con.guring, installing, and managing complex application stacks. \nEngage consists of three components: a domain-speci.c model to describe component metadata and inter\u00adcomponent \ndependencies; a constraint-based algorithm that takes a partial installation speci.cation and computes \na full installation plan; and a runtime system that co-ordinates the deployment of the application across \nmultiple machines and manages the deployed system. By explicitly modeling con.guration metadata and inter\u00adcomponent \ndependencies, Engage enables static checking of appli\u00adcation con.gurations and automated, constraint-driven, \ngeneration of installation plans across multiple machines. This reduces the te\u00addious manual process of \napplication con.guration, installation, and management. We have implemented Engage and we have used it \nto success\u00adfully host a number of applications. We describe our experiences in using Engage to manage \na generic platform that hosts Django applications in the cloud or on premises. Categories and Subject \nDescriptors D.2.9 [Software Engineer\u00ading]: Management; K.6.2 [Management of Computing and Infor\u00admation \nSystems]: Installation management General Terms Design, Languages, Management Keywords Application deployment, \ndeclarative languages, cloud computing 1. Introduction Many modern applications are built from components \nwhich are inter-dependent, distributed, and created independently. By com\u00adbining existing components \nin a loosely-coupled architecture, ap\u00adplications delivering signi.cant functionality in a scalable manner \ncan be quickly created. However, the assembly, installation, and management of such systems in a consistent \nand e.ective way is currently a di.cult and resource-intensive problem. Packages and services have dependencies \nthat have to be satis.ed, and miscon- Permission to make digital or hard copies of all or part of this \nwork for personal or classroom use is granted without fee provided that copies are not made or distributed \nfor pro.t or commercial advantage and that copies bear this notice and the full citation on the .rst \npage. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior \nspeci.c permission and/or a fee. PLDI 12, June 11 16, 2012, Beijing, China. Copyright &#38;#169;c2012 \nACM 978-1-4503-1205-9/12/06. . . $10.00 .gurations between individual components and services can cause \nthe application to become unstable or corrupted. While there are tools that automate portions of this \nprocess for speci.c packages, e.g., package managers on Linux distributions, there are few tools that \nprovide end-to-end functionality for the en\u00adtire software stack, especially for distributed applications \nrunning on many nodes (e.g., in a private or public cloud infrastructure). In practice, large-scale software \nstacks are often managed using custom script-based tools and manual techniques. This process is error-prone, \nas upgrades to individual packages can break existing and implicit dependencies in the system. It is \nalso labor-intensive, since the process must be performed manually by system admin\u00adistrators, developers, \nand end-users, and e.ort may be duplicated within the same organization. In fact, application administration \noverhead is mentioned as one main barrier to the adoption of free and open-source software [13]. The \nchallenge of dependency management in software package installation is well-studied, and constraint-based \ntools to manage package installations on single machines have been developed [12, 17, 19]. However, none \nof the available tools consider additional factors that come up in managing a distributed application \nstack: 1. Physical context: Components may be distributed across mul\u00adtiple machines. Certain dependencies \n(e.g., libraries) have to be resolved within the context of a single machine (e.g., each ma\u00adchine running \na Java component must install (possibly di.erent versions of) the Java Runtime Environment), and certain \nde\u00adpendencies must be resolved across machines (e.g., an applica\u00adtion server and a back-end task processor \nmay live on di.erent servers but connect to the same database). Existing tools do not consider multi-machine \ndependencies. 2. Con.guration management: Additionally, each component of an application may have its \nown collection of con.guration set\u00adtings. Such settings may be maintained in a con.guration .le or database \nor passed to a component through command line parameters or environment variables. These settings may \nde\u00adtermine how a component interacts with its dependencies. One must ensure that all selected components \nof an application have been con.gured to connect to each other as required by their dependency relationships. \nFor example, an application depend\u00ading on a database must be con.gured to connect to the host and port \nnumber on which the database is listening, and may need to know the database user s name and password. \nCurrently, it is the user s responsibility to connect the con.guration options between components (e.g., \nby manually setting the values in the application s con.guration .le). 3. Application management: Many \napplication components use long-running processes (e.g. services or daemons) that need to be explicitly \nstarted, restarted, or stopped. Startup/shutdown of the full application stack can be deceptively di.cult \nto auto\u00admate due to timing issues between dependent services. If a com\u00adponent is started without .rst \nensuring that all of its dependen\u00ad   cies have completed their startup, it might intermittently fail \ndue to connection errors. Most package management tools do not consider service startup/shutdown, and \ndo not provide ways to express dependencies in the application stack. We present Engage, a system for \nmanaging application stack con.guration, installation, and maintenance. Engage has three components. \nThe .rst is a declarative framework for specifying component metadata such as con.guration parameters \nas well as dependencies between di.erent components and services. The sec\u00adond is a constraint-based algorithm \nthat takes a partial installation speci.cation (a list of the main application components to be in\u00adstalled) \nand automatically produces a full installation speci.cation (a list of all components to be installed). \nFinally, a runtime system co-ordinates the installation of components in an installation spec\u00adi.cation \nand manages the deployed system locally or on the cloud. In Engage, a component, called a resource, is \nmodeled using two parts: a type and a driver.A type for the resource describes con\u00ad.guration options \nand dependencies associated with a component. The con.guration options specify required con.guration \nparame\u00adters for the components, including input con.guration options that are provided by components \nthat the current resource depends on, and output con.gurations that the con.gured resource exports to \ndownstream dependencies. The dependencies specify other com\u00adponents the current resource depends on, \nsuch as the machine in which it executes, other libraries and services that must be present on the same \nmachine, and other services (possibly on di.ferent ma\u00adchines) that it requires. A driver for the resource \nspeci.es a state machine that manages its lifecycle at runtime (e.g., installation, startup, shutdown, \netc.). Together, the type and the driver specify completely the dependencies and the con.gurations required \nto in\u00adstall and use a resource. A subtyping mechanism ensures that each resource can be developed independently \nand reused in many dif\u00adferent contexts. A resource instance is a speci.c instantiation of a resource \nthat is deployed, for instance, a speci.c server or a speci.c instance of a MySQL database. An application \nis described by compositions of resource instances (an installation speci.cation), and it can be checked \nstatically to ensure that all dependencies are met, there are no circular or con.icting dependencies, \nand that con.guration parameters between dependent components are passed correctly. For example, we can \ncheck that, if an application component has a dependency on a database, there is a resource instance \nin the in\u00adstallation speci.cation corresponding to a database component, and the application component \ngets its input con.guration options for the database from the outputs of the database component. Since \nre\u00adsources can model the physical context of a machine, we can stati\u00adcally reason about the physical \ncontext; for instance, checking that certain libraries exist on the same machine. Additionally, the re\u00adsource \ndrivers ensure that the runtime system has enough informa\u00adtion to start up and shut down services according \nto their dependen\u00adcies. Thus, the resource types enable static checking of application stacks for dependencies \nand con.icts, for con.guration and phys\u00adical context management, and the types together with the drivers \nenable runtime application management. Rather than writing the entire installation speci.cation, which \ncan be long and tedious, Engage allows the user to only specify a partial installation speci.cation, \nwhich outlines the main ap\u00adplication components and the machines they should be installed on. A con.guration \nengine takes the partial installation speci.\u00adcation and produces a full installation speci.cation by \ncomputing the transitive closure of dependencies of the components, resolving choices between components \nthrough Boolean constraint solving, and adding component dependency links to form a directed acyclic \ngraph of resource instances. The Engage runtime system then takes this full installation spec\u00adi.cation \nand deploys it (locally or on the cloud), using the de\u00adpendency order on resource instances and the actions \nin the re\u00adsource drivers to order the sequence of installations and startups. The drivers specify the \norder in which operations can be performed on a resource instance, and also implement each operation \nusing an underlying programming language. The runtime system moni\u00adtors the application as it runs, and \ncan manage the application stack (e.g., to stop the application) based on the dependency order spec\u00adi.ed \nin the install speci.cation. At the end of this process, the user should have a full application installed, \ncon.gured, and running, potentially across multiple machines. We have implemented the Engage system and \nhave used Engage as the deployment and management tool for a number of case stud\u00adies. The core of Engage \ncontains about 26K lines of Python code, 6K lines of OCaml code, and about 5K lines of metadata. Engage \nis integrated with both Rackspace and Amazon Web Services and can deploy applications on these services. \nEngage has been used as the core technology behind a commercial platform-as-a-service com\u00adpany for application \nstacks written in Django and using standard components such as Python packages, databases (MySQL), key\u00advalue \nstores (Redis, MongoDB), message queues (RabbitMQ, Cel\u00adery), and web caches (Memcached). It has e.ciently \nmanaged the con.guration, deployment, and upgrades of complex third-party applications. In addition, \nwe have used Engage to con.gure and manage Java-based and pure Python applications. Related Work Engage \nis di.erent from an operating-system-level package manager (OSLPM), such as dpkg for Debian, RPM, or \napt. These tools manage dependencies among packages on a single machine, but do not provide support for \ncon.guration management, application management (e.g., server startup), or multi-machine de\u00adployments. \nHowever, they form the building blocks for Engage: a driver for a resource can use an OSLPM to install \nthe required pack\u00adages on a machine. Thus, Engage is complementary to OSLPM, and uses OSLPM s to provide \nsupport for higher-level issues in ap\u00adplication deployment and maintenance for each platform. Constraint-based \ntools [11, 17 19] manage individual software packages at a single machine level, but do not provide support \nfor con.guration management, multi-machine deployments, or appli\u00adcation management. A constraint usually \nspeci.es pre-requisites (and con.icts) for a package, but does not model con.guration pa\u00adrameters or \nservice startup/shutdown requirements. The constraint\u00adbased con.guration in Engage is inspired by these \ntools, but in addition, Engage provides support for con.guration and applica\u00adtion management across multiple \nphysical contexts (machines). The distribution editor of the EDOS project [17] provides a means to check \nthe consistency and installability of a set of interdepen\u00addent packages. However, in the distribution \neditor, this informa\u00adtion is not used for analysis or for application-level installation. Model-based \nformalisms are used to detect compatibility and up\u00adgrade problems [10, 11], but not across physical contexts, \nnor tar\u00ad geted toward application stack management. The input/output/con.guration ports of Engage s resource \ntypes were inspired by module systems for more general purpose lan\u00adguages, including Units [14], nesC \n[15], and ArchJava [7]. Un\u00ad like these systems, the connections between modules (resources) in Engage \nare implicit, using dependency constraints to instanti\u00adate resources and establish connections. Engage \ns resource de.ni\u00adtion language provides a combination of traditional module sys\u00adtems (importing/exporting \nde.nitions, subtyping of individual val\u00adues and structures) and constraint languages. Engage is similar \nto con.guration management systems such as Puppet [1], Chef [2], LCFG [8], and CfEngine [9], which provide \na domain-speci.c language to model the desired state for a ma\u00adchine, e.g., .les that should be present \nand services that should be running. These systems use a client-server model in which a server holds \nthe model of the desired state for a machine, and the client en\u00adsures this con.guration is met. Engage \nimproves upon the design of existing con.guration management systems in the following ways. First, Engage \nseparates the declarative speci.cation of resources (resource types) and the imperative details of their \ninstallation (in\u00adstances and drivers). This enables type-checking for con.gurations and to detect con.guration \nor dependency problems statically. Sec\u00adond, through the constraint-based con.guration engine, Engage \nal\u00adlows the compact speci.cation of application stacks, usually over an order of magnitude smaller than \nthe full installation speci.cation required by other systems. In practice, we have found the combina\u00adtion \nof instance/type separation and a contraint-based dependency model result in very .exible install speci.cations. \nWe can take an application and deploy it on multiple platforms (e.g. MacOSX and Linux) and in multiple \ncon.gurations (e.g. development, testing, and production) without signi.cantly more work than is required \nfor a single con.guration. This is not possible with traditional con\u00ad.guration management systems, which \nare optimized for keeping large numbers of nearly identical systems in a given standard con\u00ad.guraiton. \n Finally, while con.guration management systems can be used to support resource management over multiple \nservers, each client is usually managed in isolation with no coordination between servers. Engage provides \na means to coordinate and con.gure between services across machines according to their dependencies. \nSmartFrog [16] supports distributed application deployment by modeling the components of a system and \nproviding a framework for lifecycle managers to manage individual components and their coordination. \nEngage s deployment engine uses a similar approach, with drivers in lieu of lifecycle managers. Engage \nadditionally uses the dependency relationship information it obtains from the con.guration phase to determine \nthe sequencing of deployment actions. The use of constraint-based con.guration is also novel.  2. Overview \nWe now describe Engage through an example. As noted before, Engage has three main components: 1. A declarative \nlanguage to describe resources. A resource is a generic term for a software package (e.g., the Apache \nweb server), operating system (e.g., Ubuntu 10.4), or a virtual or physical machine. Its description \nconsists of a type (the con\u00ad.guration parameters and dependencies) and a driver (a state machine for \nmanaging the component). 2. A con.guration engine that takes a database of resources and a partial installation \nspeci.cation and produces a full installa\u00adtion speci.cation that describes how a collection of software \ncomponents should look when installed and con.gured. 3. The Engage runtime, consisting of a deployment \nengine and runtime services that install and manage components in a de\u00adployment. It calls the drivers \nof each component in the full in\u00adstallation speci.cation and starts services in dependency order.  OpenMRS \nWe demonstrate how Engage can be used to install and manage OpenMRS, an open source enterprise medical \nrecords system [20]. OpenMRS is written in Java, and runs as a servlet con\u00ad tained within the Apache \nTomcat webserver. It depends on Java, version 5 or greater. Either the Java Developer Kit (JDK) or Java \nRuntime Environment (JRE) may be used. The Tomcat distribution should be at least version 5.5 but before \n6.0.29. OpenMRS talks to a MySQL database in the backend, where the MySQL distribution should be version \n5 or greater. In a production setting, the database will run on a separate machine from the application \nserver. Open-MRS itself does not have any speci.c operating system dependen- Server Java Figure 1: Resource \ntypes for OpenMRS installation  { \"id\": \"server\", \"key\": \"Mac-OSX 10.6\", \"config_port\": { hostname=\"localhost\", \nos_user_name=\"root\" } }, { \"id\": \"tomcat\", \"key\": \"Tomcat 6.0.18\", \"inside\": { \"id\":\"server\" } }, { \"id\": \n\"openmrs\", \"key\": \"OpenMRS 1.8\" \"inside\": { \"id\":\"tomcat\" } } Figure 2: Partial installation speci.cation \nfor OpenMRS cies. Thus the operating systems are limited by the availability of Java and MySQL. This \nincludes Windows XP/Vista, Linux, Solaris, and Mac OSX. Di.erent executables for Java and MySQL are re\u00adquired \nfor each platform. A single-machine installation for OpenMRS is described on the OpenMRS web page, and \nconsists of a 10-page document. This document gives a list of the software components which must be installed \nin order to install OpenMRS, in their dependency or\u00adder. It points to a di.erent document for installing \nand con.gur\u00ading MySQL. Moreover, the document gives separate conditions for Windows and for Ubuntu (after \n10.10 and before 10.10). The instal\u00adlation requirements and dependencies in the installation are given \nas comments in the document. We give two examples: Java must be installed before installing Tomcat. \n [When starting OpenMRS] Ensure that Tomcat is started by checking to see if icon in the tray is green \n(Windows install).  It is the user s responsibility to troubleshoot the installation if some of these \nconditions are not met. When moving from one deploy\u00adment (e.g., test) to another (e.g., production), \nthe user must man\u00adually reconstruct all the installation steps (or write ad hoc scripts to automate the \nsteps). Moreover, the instructions are sometimes incomplete (for example, how to check if Tomcat is started \non Ubuntu? How to check it programmatically?). Our intent is not to deride the OpenMRS installation document \n(indeed, OpenMRS has a very readable set of instructions), but to point out that these are common issues \nin many installation speci.cations. Engage We now describe how the OpenMRS installation is man\u00adaged in \nEngage. For simplicity, we only describe the con.gura\u00adtion for a Mac OSX 10.6 server with Tomcat 6.0.18. \nSoftware or hardware components, called resources, are represented in Engage using two parts: a resource \ntype describes the con.guration meta\u00addata and dependencies on other resources, and a resource driver \nde\u00adscribes a state machine that manages the lifecycle of the resource. We assume resource types and drivers \nare written by the component developer, not the end user installing the application. We .rst describe \nresource types. Figure 1 shows the resource types that are relevant to the OpenMRS installation (simpli.ed \nfor readability). (We omit describing a concrete syntax for resources.) Each resource description has \na (unique) key identifying the re\u00adsource, sets of typed con.guration, input, and output ports, and de\u00adpendency \nspeci.cations on other components. Typically, the key consists of the name of the package and its version. \nThe ports spec\u00adify attributes (key-value pairs) internal to the component s con\u00ad.guration (the con.guration \nports), attributes derived from other components on which the component depends (input ports), and attributes \nthat the component exports to downstream components (output ports). For example, the resource type for \nkey MySQL 5.1 (MySQL version 5.1) has a con.guration port called port that speci.es the default port \n(3306), and has an output port, also called port, that copies its value from the con.guration port for \ndown\u00adstream components connecting to it. The dependencies come in three types. An inside dependency speci.es \nthe container resource in which the current resource must execute. In general, this is a physical or \nvirtual machine, or a con\u00adtainer like Tomcat which contains other packages. If a resource does not have \nan inside dependency, it corresponds to a virtual or physical machine. For example, the (abstract) resource \nServer and its subclasses Mac OSX 10.6 and Windows-XP refer to machines. On the other hand, the resource \nTomcat 6.0.18 has an inside de\u00adpendency on a Server, meaning that in a deployment, Tomcat runs inside \na sub-class of resource type Server (since Server is ab\u00adstract and cannot be instantiated). The resource \nOpenMRS 1.8 has an inside dependency on Tomcat 6.0.18, since it executes as a servlet inside the Tomcat \nserver. An environment dependency speci.es other resources that must be present (and possibly execute) \non the same machine as a pre\u00adcondition for the installation and execution of the current resource. For \nexample, both Tomcat and OpenMRS have environment depen\u00addencies on Java, which means that an instance \nof a subclass of re\u00adsource type of Java must be installed on a machine before Tomcat or OpenMRS can be \ninstalled on that machine. In addition, an envi\u00adronment dependency also speci.es how con.guration options \nfrom the output ports of a resource .ow into the input ports of the current resource. For example, the \noutput port java in the Java resource type is an input to OpenMRS 1.8 A peer dependency speci.es resources \nmust be present, but not necessarily on the same machine. For example, OpenMRS 1.8 has a peer dependency \non the MySQL 5.1 database, meaning that an instance of MySQL 5.1 must be deployed before OpenMRS 1.8 \ncan be deployed, but possibly on a machine di.erent from that of OpenMRS. When a resource type A depends \non a resource type B,the resource A can obtain the value of an output port of B by using a port mapping. \nA port mapping relates an output port of a resource type to an input port of another. For example, OpenMRS \n1.8 maps the output port mysql of MySQL 5.1 into its input port that has the same name. Well-formed sets \nof resource types ensure that the union of all dependency relations is acyclic, and that each input port \nis mapped exactly once by the set of dependencies. Given a resource, we call the set of resources that \nit transitively depends on its set of upstream dependencies and the set of resources that transitively \ndepend on it its set of downstream dependencies. Resource types correspond to the classes in an OO language, \nresource instances represent speci.c resources instantiations (e.g. acopyof MySQL 5.1 installed on server \ndemotest and listening on port 3306) and correspond to objects. An instance of a resource has a globally \nunique identi.er, .lls in concrete values for all ports, and replaces each dependency in the resource \ntype with a concrete instance. A full installation speci.cation provides a list of each instance required \nto deploy an application. For example, given resource types for each component required by OpenMRS, the \nuser can write an installation speci.cation describing all the components that are required to install \nOpenMRS. Engage s type system can check the installation speci.cation to make sure all required dependencies \nare present in the correct physical context and that each instance is correctly con.gured. Writing full \ninstallation speci.cations can get tedious. Engage s con.guration engine allows the end user to provide \npartial instal\u00adlation speci.cations, and automatically determines what other re\u00adsources must be instantiated \nto deploy the system. Figure 2 shows the partial installation speci.cation written by a user for Open-MRS. \nIt consists of three resource instances: an instance server for a machine running Mac OSX version 10.6, \nan instance tomcat of Tomcat running inside server, and an instance openmrs for the OpenMRS application \nrunning inside tomcat.Inparticular,the user does not have to explicitly give the other dependencies on \nJava and MySQL. The partial installation speci.cation may also de.ne values for individual con.guration \nport properties. In our example, the hostname and os user name properties have been assigned values. \nUnassigned con.guration properties will take the default values de.ned in the associated resource types. \n The con.guration engine takes this partial installation speci.\u00adcation and expands out all the dependencies \nto generate a set of Boolean constraints such that the Boolean constraints are satis.\u00adable i. there is \na full installation speci.cation which includes all of the resource instances mentioned in the partial \ninstallation speci.\u00adcation. The atomic propositions in the Boolean constraints consist of instances of \nresources: the proposition is true in a satisfying as\u00adsignment i. the corresponding resource instance \nmust be deployed. For the partial installation speci.cation of Figure 2, the con.gura\u00ad tion engine generates \nthe following constraints: server . from install spec tomcat . from install spec openmrs . from install \nspec openmrs . .{jdk, jre}. env dep tomcat . .{jdk, jre}. env dep openmrs . mysql . peer dep tomcat . \nserver . inside dep openmrs . tomcat . inside dep mysql . server . inside dep jdk . server . inside dep \njre . server inside dep where .S is the exactly one predicate that asserts that exactly one proposition \nfrom the set S is true. The .rst three constraints arise from the partial installation speci.cation (each \ninstance there must be deployed). The next three arise out of environment (and peer, for the last one) \ndependencies, and state that the deployment of the l.h.s. implies the deployment of the r.h.s. The .nal \n.ve arise out of inside dependencies. Note that the peer dependency of Open-MRS on MySQL could be resolved \nby creating a new machine instance and installing MySQL on that machine. However, our con\u00adstraint generation \nprocess assumes that no new machines should be created. Thus, unless explicitly speci.ed, a peer dependency \nis de\u00adployed at the same machine as the machine of its dependent. The constraints are satis.ed, e.g., \nby setting server, jdk, tomcat, mysql,and openmrs to true, and jre to false. This cor\u00adresponds to a deployment \nwhere a Java development kit, a Tomcat server, a MySQL database instance, and the OpenMRS applica\u00adtion \nare all installed on a server running Mac OSX 10.6. Given this solution, we can also tie together the \ninput and output ports by traversing the resource instances in topological order of depen\u00addencies, starting \nwith the output ports of server, and using the de.nitions of output ports of preceding resource instances \nto get values of input ports according to the port mappings speci.ed in the dependencies. Valuations \nto the input ports then determine the con.guration and output ports of the instance. In this way, we \ncan propagate con.guration options along the application stack. The re\u00adsult of this process is a full \ninstallation speci.cation, that details the components that must be installed, their con.guration parameters, \nand the order of their installation. The last is obtained via the partial order imposed by the dependencies \nof the resource instances. Finally, the Engage deployment system takes an install spec\u00adi.cation and deploys \nthe components in the order of dependen\u00adcies. The deployment system uses the corresponding driver for \neach resource instance. A resource driver is a state machine with special states uninstalled, active,and \ninactive (the latter two pos\u00adsibly the same state), with guarded actions between states. Fig\u00ad [. active] \nrestart install start uninstalled inactive active uninstall stop [. inactive] Figure 3: Resource driver \nfor Tomcat ure 3 shows an example resource driver for Tomcat. An action (e.g., install) is implemented \nin an underlying programming lan\u00adguage and performs some modi.cation of the system state. For example, \nthe install action can call an OS-level package man\u00adager to download and install a package. A guard describes \na pre\u00adcondition for the action, and is omitted if an action can be per\u00adformed at any time. A guard of \nthe form . s (respectively, . s) states that an action can be performed only when the state machines \nof all upstream (respectively, downstream) dependencies are in state s .{uninstalled, active, inactive}. \nThe actions on the state machines are performed by the Engage runtime system. The runtime system manages \nthe state machines of all installed components and can check the status of guards. The runtime system \ncan also monitor a deployment and shut it down (by shutting down services in the reverse order of dependencies). \nEngage ameliorates the problems of manual deployment in the following ways. First, dependencies among \nresource types ensure that required packages are installed when a resource instance is being installed \n(e.g., Java has already been installed before in\u00adstalling Tomcat). Second, the resource drivers and the \nruntime ensure that required services are already started when starting an application (e.g., Tomcat \nand MySQL daemons are already started when OpenMRS is started: their resource drivers are both in active \nwhen starting OpenMRS). While there is work involved in devel\u00adoping resource types and drivers, they \nare done once by the pack\u00adage developer, and any subsequent installation scenario involving the resource \nis completely automated. In contrast to ad hoc cus\u00adtom scripts, the declarative language enables static \ndetection of con.guration problems, e.g., cyclic dependencies between compo\u00adnents, or unsolvable constraints \nin installation. In contrast to con\u00ad.guration management systems, the con.guration engine signi.\u00adcantly \nreduces user input: in our implementation, the (unsimpli.ed) OpenMRS partial installation speci.cation \ntook 22 lines, and the full installation speci.cation was 204 lines. Note that resource descrip\u00adtions \nare reusable and can be used in di.erent installations; e.g, the MySQL resource can be used in any deployment \nthat requires a MySQL database.  3. Resource Types In Engage, the fundamental abstraction for software \nand hardware components is a resource. A resource consists of a description of the metadata required \nto con.gure, install, or upgrade a compo\u00adnent (its resource type)anda driver consisting of code that \nreads the metadata and manages the lifecycle of the component (installa\u00adtion, upgrade, rollback, etc.). \nWe explain resource types here, and explain drivers in Section 5.  3.1 Resource Types A resource type \nis an abstraction to model how a component may be instantiated. A resource instance is an instantiation \nof a resource type that describes how a speci.c resource will be (or has been) con.gured and installed. \nIn analogy with object-oriented program\u00adming, a resource type is a class and a resource instance is an \nobject of that class. Each resource type has a unique identi.er (usually, name of the component and its \nversion) in a global name space. In addition, a resource type has ports and dependency constraints. \n Ports Con.guration data for a component are described in ports. A port has a name and a type. We assume \nan (unspeci.ed) set of base types. For a port p, we write p.name and p.type to refer to the name and \nthe type, respectively. Communication of con.guration data between components is performed by connecting \nappropriate ports of two components. Dependencies Dependencies between resource types specify or\u00addering \nconstraints between components, and determine how ports of a resource get their values. Engage speci.es \nthree types of de\u00adpendencies. An inside dependency speci.es that an instance of a resource type can exist \nonly inside an instance of another resource type; e.g., Tomcat can exist only inside a Server. Each resource \ntype has ei\u00adther zero inside dependencies, in which case it must represent a physical machine, or exactly \none inside dependency. Inside depen\u00addencies can be nested: e.g., a servlet can be inside Tomcat, which \nin turn is inside a server. For any resource type, one can walk the in\u00adside dependencies to eventually \nreach a physical machine, and this is the machine on which the component gets installed and run. A resource \ntype R1 has an environment dependency on a re\u00adsource type R2 if it depends on a resource of type R2 to \nbe installed in an enclosing resource. As an example, Tomcat requires that the Java runtime environment \nbe installed on the machine it is installed on. (However, Tomcat is not installed inside Java.) A resource \ntype R1 has a peer dependency on a resource type R2 if it calls services provided by an instance of R2. \nIn this case, unlike environment constraints, an instance of R2 need not be installed on the same machine \nas the instance of R1. For example, OpenMRS has a peer dependency on MySQL, and OpenMRS can make calls \nto the database over TCP/IP. Formal Model Formally, a resource type R = (key, InP, ConfP, OutP, Inside, \nEnv, Peer) consists of a (globally unique) key key (usually consisting of a name and a version), three \ndisjoint sets of input ports InP, con.guration ports ConfP,and output ports OutP, an optional inside \ndependency Inside or null,asetof environment dependencies Env,andaset of peer dependencies Peer. We assume \neach port p . ConfP is either a default constant or de.ned as a function of the ports in InP, and each \nport p . OutP is either a default constant or de.ned as a function of the ports in InP .ConfP.For akey \nkey,wewrite [[key]] to denote the (unique) resource type for that key. For a resource type R,wewrite \nR.key, R.InP, etc. to denote the components of the resource type. The input ports are used to receive \ndata from other resources. The output ports are used to a.ect the behavior of other resources by providing \ncon.guration data. The con.guration ports are used to store resource-speci.c metadata used in con.guration \nand installa\u00adtion. A con.guration port of a resource can read from an input port of the same resource, \nand an output port of a resource can read from an input or con.g port of the resource. Each dependency \n(inside, environment, or peer) is a pair (key', pmap), where key' is a key to a resource and pmap is \na par\u00adtial mapping from [[key']].OutP to R.InP. Inside, environment, and peer dependencies induce ordering \nrelations on resource types. Let R and R' be resource types. We write R 5iR' (the inside ordering) if \nR.Inside = (R'.key, \u00b7). We write R 5eR' (the environment ordering) if (R'.key, \u00b7) . R.Env.We write R \n5pR' (the peer ordering) if (R'.key, \u00b7) . R.Peer. A machine is a resource whose inside dependency is \nnull. Well-formedness A .nite set of resource types is called well\u00adformed if the following conditions \nhold: 1. Each key appearing in an inside, environment, or peer depen\u00addency is mapped to a resource type \nin the set (no pending de\u00adpendencies). 2. If a resource does not have an inside dependency, it does \nnot have any input ports. Such resources usually correspond to physical machines. 3. Each input port \nis mapped exactly once in the port mappings of the inside, environment, and peer dependencies. Each output \nport is assigned a value. That is, the range of port mappings in two dependencies is disjoint, and the \nunion of ranges is the set of all input ports. 4. The ordering 5i .5e .5p on resource types is acyclic. \n For any resource type R in a well-formed set of resource types, one can follow inside constraints to \na machine. This represents the physical context in which an instance of R will be installed.  3.2 Abstract \nResources and Subtyping We extend the core language with inheritance and abstract resource types. A resource \ntype can be marked abstract or concrete.An abstract resource type cannot be instantiated, but can be \nused for inheritance. For example, in Section 2, we de.ned an abstract resource type Server for a server, \nand subclasses for Mac OSX and Windows servers. The generic Server cannot be instantiated, but its subclasses \nspecifying the OS can be instantiated. Instances of concrete resource types can be deployed. By default, \nwe assume resource types are concrete and omit the concrete quali.er. Sub-resource types extend base \nresource type de.nitions by adding ports and dependencies. Fields from a super-resource type are implicitly \nreplicated in the sub-resource type, or overridden as explained below. Figure 4 presents the subtyping \nrules to ensure well-formedness of the sub-resource tree. The rules de.ne subtyping relations =in, =conf \n,and =out for input, con.g, and output ports, respectively, their extensions to sets of ports and port \nmappings, and a =RT relation that checks for subtyping between resource types by checking sub\u00adtyping \nof the corresponding resource types of their inside, environ\u00adment, and peer dependencies. We assume an \n(unspeci.ed) subtyp\u00ading relation = on the base types over which ports are de.ned. Note that the subtyping \nrelation on base types go on opposite directions for input ports and for con.g and output ports. This \nis related to the usual co-variance and contra-variance of method arguments. Sub-resource types extend \nbase resource types by de.ning more input, con.g, and output ports, subtyping the inside dependency, \nand adding additional environment and peer dependencies.  3.3 Resource Instances A resource instance \nis created from a resource type by assigning concrete values to its con.guration ports and by replacing \ndepen\u00addency constraints with directional links to other resource instances. In addition to the components \nof a resource type, each resource in\u00adstance has a globally unique resource identi.er that uniquely iden\u00adti.es \nthe resource instance. The identi.er helps distinguish two in\u00adstances of the same resource type in a \ndeployment, e.g., two servers both running Mac OSX 10.6. Deployment information for an application can \nbe provided by giving a set of resource instances obtained from corresponding re\u00adsource types, such that \nfor every instance in the set, each depen\u00addency is instantiated with a concrete link to another resource \nin\u00adstance, and the values in the output ports and mapped input ports for the resource instances match. \nSuch a document is referred to as an installation speci.cation.  Input ports Config ports Output ports \n' '' '' ' p .name = p.name p .type = p.type p .name = p.name p .type = p.type p .name = p.name p .type \n= p.type '' ' p =inp p =conf p p =out p Sets of input ports Sets of config ports Sets of output ports \n'''' '' .p . P \u00b7.p . P '\u00b7 p =in p .p . P \u00b7.p . P '\u00b7 p =out p .p . P \u00b7.p . P '\u00b7 p =out p P ' P ' P ' =IN \nP =CONF P =OUT P Port mappings Refl Trans ''' ' R ' R ' R '' .(p, q) . m \u00b7.(p , q ' ) . m \u00b7 (p =out p \n. q =in q) R =RT =RT ' R '' m =pmm R =RTR R =RT Resource types R ' .InP =IN R.InP R ' .ConfP =CONF R.ConfP \nR ' .OutP =OUT R.OutP ([R ' .Inside.key ' ] =RT [R.Inside.key ' ] . [R ' .Inside.key ' ] = [R.Inside.key \n' ] = null) . (R ' .Inside.pmap =pm R.Inside.pmap) .(I, m) . R.Env \u00b7.(I ' , m ' ) . R ' .Env \u00b7 ([I ' \n] =RT [I] . m '=pm m) .(X, m) . R.Peer \u00b7.(X ' , m ' ) . R ' .Peer \u00b7 ([X ' ] =RT [X] . m '=pm m) R ' \n=RT R Figure 4: The rules for subtyping between two resource types. 3.4 Syntactic Sugar and Extensions \nFor brevity, we introduce some syntactic sugar in the language and in our examples. We allow a port to \nbe a structure with named .elds. We allow disjunctions in the descriptions of inside depen\u00addencies, and \npositive Boolean combinations of resource types in environment and peer dependencies. For example, we \ncan express that a resource type R (e.g., Tomcat) is inside either resource type R1 (e.g., Mac-OSX 10.6) \nor resource type R2 (e.g., Windows 7), and a resource type R (e.g., OpenMRS) has an environment depen\u00addency \non resource type R1 (e.g., Java) as well as one of R2 (e.g., MySQL) or R3 (e.g., Postgres). The use of \ndisjunctions is a conve\u00adnient shorthand, and can be simulated by de.ning the appropriate super-resource \ntypes and their sub-resource types. To simplify the check for well-formedness, we require the ranges \nof two port map\u00adpings that are disjunctively combined to be identical. To model a common idiom in which \na resource depends on one of a number of versions of a di.erent one (e.g., OpenMRS depends on versions \nof Tomcat before version 6.0.29), we add syntactic sugar to allow specifying ranges of versions for the \nsame pack\u00adage, which are internally expanded to disjunctions of the di.erent versions satisfying the \nrange. The implementation of Engage also has some extensions that we do not model here. Each port of \na resource type in our imple\u00admentation has a static or dynamic binding. A static port is assigned a value \nat the instantiation time of a resource of that type. For ex\u00adample, these can be default values. A dynamic \nport is assigned a value at the installation time of a resource. By default, we assume all ports are \ndynamic (and we omit mentioning the binding explic\u00aditly). Only con.guration and output ports can have \nthe static bind\u00ading. A static con.guration port must be a constant. A static output port is either a \nconstant or a function of static con.guration ports. Inside, environment, and peer dependencies are extended \nwith two port maps: in a dependency of resource R on R' , one port map maps output ports of R' to the \ninputs of R (as before), and the other maps static output ports of R to input ports of R'. Static ports \nare useful to .ow con.guration parameters in the reverse direction of depen\u00addencies. For example, when \ninstalling OpenMRS, we need to pass a server con.guration .le back to Tomcat. In our implementation, \nwe use static ports to achieve this. However, by the nature of static ports, all con.guration values \n.owing in the reverse direction can be resolved statically, and these con.gurations will be known when \ninstalling R' even though R has not been installed yet.  4. Con.guration In practice, writing the entire \nset of resource instances in an instal\u00adlation speci.cation can be tedious. Instead, Engage allows the \nuser to specify a partial installation speci.cation. A partial installation speci.cation is a set of \npartial resource instances, that is, a set of resource instances for which only a subset of dependencies \nare in\u00adstantiated by concrete resource instances. For example, Figure 2 shows a partial installation \nspeci.cation with instance server ob\u00adtained from a resource of type Mac OSX 10.6, a resource instance \ntomcat for a resource of type Tomcat 6.0.18, and a resource in\u00adstance openmrs for OpenMRS 1.8. An installation \nspeci.cation extends a partial installation speci.cation if each resource instance in the partial speci.cation \nis also present in the installation speci\u00ad.cation. Engage automatically generates a full installation \nspeci.\u00adcation extending the partial speci.cation, by using the dependency relations in the resource types \nand automated constraint solving. The con.guration engine takes as input a collection of resource types \nand a partial install speci.cation (a collection of partial re\u00adsource instances) and produces as output \na set of complete resource instances (called the (full) installation speci.cation) such that: (1) for \nevery resource instance, and for every inside, environment, or peer dependency of its corresponding resource \ntype, there exists a resource instance that satis.es the inside, environment, or peer dependency, respectively, \nand (2) each input port of a resource in\u00adstance is mapped to exactly one output port of a di.erent resource \ninstance. Given a partial instantiation speci.cation, I, the con.guration engine computes a set of Boolean \nconstraints using the following two steps. In the following, we assume that there is a .xed, well\u00adformed \nset of resource types, R, in the system and that every re\u00adsource instance in the partial install speci.cation \nis an instantiation of some resource type from this set. Hypergraph Generation The hypergraph generation \nphase takes a partial install speci.cation and constructs a directed resource in\u00adstance graph whose nodes \nare resource instances, and whose hyper\u00adedges represent dependencies between resource instances. Without \nloss of generality, we assume that for each resource instance, the inside dependency is either null or \na disjunction of resources, and the environment and peer dependencies are a set of disjunctions of resources. \n inside / inside Server inside inside JDK JRE MySQL peers env env Tomcat Open MRS inside / / Figure \n5: Hypergraph for partial installation speci.cation in Figure 2 . If a resource type has a dependency \non an abstract resource r, we replace the dependency to r with a disjunction of concrete resources in \nthe following way. We traverse the subtypes of r in the subclassing tree for r, starting at r and stopping \nwhenever we see a concrete subtype of r. In this way, we get a frontier F of subtypes of r of concrete \nresources. We replace the dependency on r by a disjunction of the concrete resources in F. For example, \nif there is a dependency on the abstract resource Java (see Figure 1), it is replaced by the disjunction \nof the concrete resources JDK 1.6 and JRE 1.6. After this transformation, there are no dependencies on \nabstract resources. (If such a frontier cannot be found, that is, if there is an abstract resource at \nthe leaf of the subclassing tree rooted at r, we stop with an error.) The hypergraph generation algorithm, \nGraphGen(R, I), is a worklist-based algorithm to process instances. It proceeds as fol\u00adlows. First, for \nevery resource instance in the partial install speci.ca\u00adtion, we create a node in the hypergraph and \nadd it to the worklist. Recall that in addition to the key of the resource, each resource instance is \nglobally uniquely identi.ed by an additional identi.er. Second, we iteratively process partial resource \ninstances from the worklist until the worklist is empty. Suppose we are processing resource instance \nr of resource R. We go through the dependencies of r. We assume that the partial installation speci.cation \nresolves inside dependencies of each resource instance in it by providing a resource instance on which \nr is inside-dependent (that is, the system does not generate new machines automatically). Given r, we \ncheck that there is an existing resource instance which matches the inside dependency. For each inside \ndependency, we create a directed edge labeled inside from the node in the graph that represents r to \nthe node that represents its container. Now consider environment dependencies of r. By assumption, the \nenvironment dependencies are a set of disjunctions. For each dependency in the set, we create a hyperedge \nwith source r,and targets as follows. Suppose the dependency is a disjunction of resource keys k1, ..., \nkn, and consider the processing of key k1. If we can already .nd a node r1 in the graph with key k1 ' \nsuch that [[k' [[k1]] andsuchthat r1 is inside the same machine as r, 1]] =RT we add the node r1 as a \ntarget of the hyperedge. If there is no such node, we instantiate a new resource instance rnew with key \nk1, inside the same machine as the machine of r, add the node for rnew to the graph as well as the worklist. \n(We add rnew to the worklist to ensure its dependencies are processed in the future.) At the end of this \nprocess, we construct a hyperedge with source r and n targets, one for each disjunct in the dependency, \nand label it environment . For peer dependencies of r, we proceed similarly. The only di.erence is that \nwe look for a matching resource that is a subtype of the key, but need not be on the same machine. If \nwe .nd such a node in the graph, we add it as the target of the hyperedge. If we do not .nd a matching \nresource, we add a new instance, but conservatively assume that the new instance resides in the same \nmachine as r. Figure 5 shows the dependencies generated when processing the partial instantiation speci.cation \nof Figure 2. We have marked the resource instances that were present in the speci.cation with a / . Lemma \n1. Let R be a set of well-formed resource types and I a partial install speci.cation. Then procedure \nGraphGen(R, I) creates a directed hypergraph G = (V, E), such that: (i) for each resource instance r \n.I, we have r . V, and for each resource instance r . V, either r .I or there is some resource instance \nr '.I that is transitively dependent on the key of r; (ii) for each resource instance r . V, if r.Inside \nis not null, then there is a resource instance r'.I such that there is an inside edge from r to r'; (iii) \nfor each resource key k such that there is an environment dependency from k to r, there is an hyperedge \nwith source r containing a target resource instance with key k such that this resource instance is on \nthe same machine as r; (iv) for each resource key k such that there is a peer dependency from k to r, \nthere is an hyperedge with source r containing a target resource instance with key k. Intuitively, this \nlemma states that the generated graph correctly encodes the dependencies of all resource instances in \nI. Constraint Generation Given the directed hypergraph GraphGen(R, I), we generate Boolean constraints \nas fol\u00adlows. An atomic proposition is of the form rsrc(id), where id is a resource instance identi.er; \nit states that the resource instance with identi.er id is installed in the machine obtained by following \nits inside dependencies. We generate two kinds of constraints from the graph. First, for each vertex \nin the constraint graph that represents a resource instance speci.ed in the partial install speci.cation, \nwe add the constraint rsrc(m, id). This constraint ensures that each resource instance mentioned in the \npartial install speci.cation is indeed instantiated in the deployment. Second, we generate dependency \nconstraints for each node v as follows. For each hyperedge e with source v and targets {v1,..., vn}, \nwe generate a constraint rsrc(v) . .{rsrc(v1),..., rsrc(vn)} (1) where .S is the Boolean predicate that \nis true i. exactly one proposition from S is true. Formally, .S = (pi) . (p .\u00acq) p.Sp.Sq.S,q*p We denote \nthe conjunction of the set of all above predicates for a set of well-formed resource types R and a partial \ninstall speci.cation I as Generate(R, I). Theorem 1. Let R be a set of well-formed resource types and \nI a partial install speci.cation. There exists a full installation speci\u00ad.cation extending the partial \ninstall speci.cation i. the formula Generate(R, I) is satis.able. A satisfying assignment to the Boolean \nconstraints determines a full installation speci.cation extending the partial installation spec\u00adi.cation. \nWe can compute the values of all input, con.guration, and output ports of all resource instances by a \nlinear pass in topological order of dependencies, .lling in the input ports of each resource instance \nbased on the already-computed values of output ports.  5. Deployment Engage s deployment engine takes \na full installation speci.cation and automatically deploys the application. It provides runtime sup\u00adport \nfor provisioning servers, co-ordinating installations, as well as generic monitoring, shutdown, and upgrade \nservices for appli\u00adcations. The deployment engine uses drivers for each resource to co-ordinate its actions. \n 5.1 Resource Drivers In addition to a type, a resource speci.es a driver that implements a state machine \nfor the lifecycle management of the instances of that type. A driver state machine consists of a set \nof states and aset of transitions between them. Each state machine has three special states, uninstalled, \ninactive,and active, called the basic states. Initially, a state machine resides in its uninstalled. \nEach transition has a guard and an action. The guard of each ac\u00adtion is either true or a conjunctive \ncondition about the basic states of all the resource instances that the driver s associated resource \nin\u00adstance depends on (i.e., the upstream resource instances) or the re\u00adsource instances that depend on \nthe driver s resource instance (i.e., the downstream resource instances). Basic state predicates are \nof the form . s or . s,where s .{uninstalled, inactive, active}.Aba\u00adsic state predicate . s (respectively, \n. s) is true if the state machines for all upstream (respectively, downstream) resource instances are \nin state s. Each guarded action is implemented in an underlying programming language (Python in our implementation). \nA resource instance starts its life in its initial state, uninstalled, and proceeds through various states \nin the state machine depending on transitions invoked by the deployment engine. If the guard of a transition \nis true, then the action can be performed at any time. Otherwise, the transition blocks until the guard \nbecomes true, at which point the action is executed and the state is updated. Formally, the driver for \na resource type R is a state machine (Q, uninstalled, inactive, active, A,d) consisting of a set of states \nQ with {uninstalled, inactive, active}. Q,asetof actions A,and a (partial) transition function d : Q \n\u00d7 (BasicStatesPred \u00d7A) . Q, where BasicStatesPred is a conjunction of basic state predicates. Figure \n3 shows the state machine for the Tomcat server. The server starts in the initial uninstalled state. \nThe action install takes it to the inactive state. From the inactive state, the action start takes it \nto the active, and has the precondition that all upstream dependencies are active. From the active state, \nthe stop action takes it back to the inactive state and has the precondition that all downstream dependencies \nare inactive. In the active state, the server can be restarted. Each guarded action carries out system \nchanges and commands required to install, start, or stop the server, as well as additional book-keeping. \n 5.2 Runtime Services Provisioning The starting point of a deployment is the set of physical or virtual \nservers on which the application software will be installed. Engage provides a set of runtime tools to \ndetermine prop\u00aderties of servers, such as hostname, IP address, operating system, CPU architecture, etc. \nThese tools automatically create a resource instance for the server, and in practice, are used to start \nwriting a new partial installation speci.cation when the servers are known. In addition, Engage provides \nintegration with cloud servers through the libcloud APIs [3]. If a machine resource instance in the partial \ninstallation speci.cation does not include con.guration details, and Engage is being run in a cloud environment, \na new virtual server is provisioned to perform the role of that machine in the deployment. In this case, \nthe additional host con.guration details (obtained from the cloud infrastructure) are added to the installation \nspeci.cation before passing it to the con.guration engine. Engage currently in\u00adtegrates with Rackspace \ncloud services and Amazon AWS. Installation, Monitoring, and Shutdown Given a full installation speci.cation, \nthe deployment engine executes commands on the resource drivers for each resource instance in the speci.cation \nsuch that every driver state machine is in its active state. At this point, the system is de.ned to be \ndeployed. The deployment engine orders resource instances according to dependencies. Since the dependency \nordering is acyclic, this is always possible. In the beginning, the resource driver for each resource \ninstance is in its initial state. The deployment engine executes driver transitions to bring each driver \nto its active state. The process can be performed in parallel, as long as the dependency ordering is \nmet, and the precondition for each transition is satis.ed. Since the deployment engine tracks the states \nof each resource instance, it can co-ordinate the calls. In the multi-host case, we must coordinate the \ninstall across multiple hosts. The implementation of a multi-host install can be simpli.ed if one can \npartially order the machines such that for ev\u00adery two machines m1 and m2, m1 is before m2 if there is \nsome re\u00adsource instance to be installed in m2 that depends on some resource instance in m1 but no resource \ninstance to be installed in m2 depends on some instance in m1. We have found this assumption to be valid \nfor all the systems that we have modeled thus far, and our imple\u00admentation makes this simplifying assumption. \nIn this case, we can break the overall install speci.cation into per-node speci.cations and run a slave \ninstance of Engage on each target host. The entire deployment is then coordinated from a master host, \nwith each slave running with no awareness of the others. Slave deployments can run in parallel when the \nslaves have no inter-dependencies. The runtime includes a plugin framework for the automatic in\u00adtegration \nwith monitoring and management tools. For example, En\u00adgage integrates with monit [4], a process monitoring/restart \nservice. The runtime system adds an instance of monit to the installation speci.cation for each target \nhost, ensuring that monit itself will be installed. After the deployment completes, the resource type \nis used by the plugin to generate a monit con.guration .le registered with monit. Users can view the \nstatus and resource usage of each in\u00adstalled service. If the process associated with a service fails, \nit will be automatically restarted by monit using a set of runtime services provided by Engage. Shutting \ndown an application goes in the reverse dependency order, and applies transitions of each resource driver \nto bring each state machine to an inactive state. Again, the runtime co-ordinates this activity since \nit knows the dependencies and tracks the states of the resource drivers. Upgrades Initial deployment \nof an application stack is only one part of its lifecycle. Changes after initial deployment may incude \nbug .xes, enhancements, infrastructure updates, security patches, and updates to Engage itself. Given \nthat Engage has a full descrip\u00adtion of the deployed system, multiple upgrade strategies are possi\u00adble. \nCurrently, we require that the user (or a utility program, as in the case of Django) provide a partial \ninstall speci.cation describ\u00ading the desired new state of the system. This is used to compute a full \ninstall speci.cation for the deployed system. The current sys\u00adtem is then backed up, and any components \nthat will be removed or that cannot be upgraded in-place are uninstalled. The new sys\u00adtem is now deployed, \nper the install speci.cation, upgrading and adding components as needed. If the upgrade fails, the partially \ninstalled components are uninstalled and the old version restored from the backup. This upgrade approach \nis relatively easy to im\u00adplement, supports rollback in the case of errors, and can handle changes to \nany layer of the stack, including Engage. However, all upgrades using this approach experience the worst \ncase upgrade time, even if there are only minor di.erences between the old and new con.gurations. We \nleave optimizations of the upgrade frame\u00adwork as future work, possibly extending [11].  App name Description \nSource Comments Areneae Simple test app Beta tester Deployed by a third party Buzz.re Twitter bookmark \nand ranking app Open source Uses Redis key-value store Codespeed Web application performance monitor \nOpen source Django-Blog Blogging platform Beta tester Deployed by a third party; Installs 18 Python package \ndependencies Django-CMS Content Management System Open source FA Manage faculty, student, and postdoc \napplications Beta tester Application used in production Feature Collector Gather software feature requests \nDeveloped internally WebApp Run production web site for Django hosting company Developed internally Application \nused in production Table 1: Django applications. Beta testers are independent application developers \nwho used the service.  6. Evaluation We have implemented the Engage system and we have used it in active \ndeployment in providing platform-as-a-service support for Django applications. The front-end for the \ndeclarative frame\u00adwork and the con.guration engine are written in about 6K lines of Ocaml. We use the \nthe MiniSat satis.ability solver to solve Boolean constraints. The runtime system (provisioning and deployment \nen\u00adgine) and resource drivers are written in about 26K lines of Python. In addition, we have about 5K \nlines of resource types in our re\u00adsource library. We allow deployments to be performed either on a given \nset of servers or on dynamically provisioned servers from Rackspace or Amazon Web Services (AWS). The \nentire system, including the resource types, is open source and (for Django appli\u00adcations) available \nthrough a web service. We have installed several open source applications, including OpenMRS (described \nin Section 2). In the following, we give two case studies that we have performed using the system. The \n.rst (JasperReports) was used as a case study to compare times for a manual install versus the time needed \nto automate an installation by developing the required resource types and drivers in Engage. The second \n(Django applications) describes our experience hosting third party applications on the cloud. 6.1 JasperReports \nThe Jasper Reports Server [5] provides a web user interface and web service APIs for generating, viewing, \nand managing reports. It runs in a servlet container (e.g., Apache Tomcat) and requires a database (e.g., \nMySQL). The installation guide is 77 pages long, with 8 pages dedicated to the speci.c approach we used \nfor in\u00adstalling Jasper. We compared the time for installing Jasper manually with the time to automate \nthe installation of Jasper in Engage. The manual installations were performed by one of the authors, \nwho had not attempted to install Jasper previously. It took him 5 hours the .rst time, 2 hours 15 minutes \nthe second time, and converged to around 1 hour in subsequent tries. Much of the learning curve was due \nto imprecise instructions that led to incorrect actions (followed by debugging sessions and rolling back), \nenvironment issues, and locating/downloading the required prerequisite software. Engage already included \nresources for Tomcat and MySQL. To automate Jasper installation, we created two new resources: one for \nJasper Reports Server itself and one for a MySQL JDBC connector required as a dependency for Jasper. \nSpecifying the resource type for the JDBC connector required 40 lines. No additional Python code was \nrequired for the driver as we were able to reuse existing generic driver code for downloading and extracting \narchives. The resource for Jasper was 69 lines of types and 201 lines of Python code (including comments). \nThe automated installation of Jasper Reports Server via En\u00adgage performs environment checks (e.g., required \nTCP/IP ports are available), downloads required application packages, installs the components in dependency \norder, and starts the database, web server, and reports server. After installation, the reports server \ncan be managed (start, stop, status check) via Engage, or automatically integrated with 3rd party management \ntools. The development time for Engage support of Jasper Reports Server was 3 hours 56 minutes. This \ntime was broken down into 47 minutes for resource type design, 81 minutes for driver develop\u00adment, and \n108 minutes for debugging and testing. Running the automated install of Jasper Reports Server takes 17 \nminutes if the required software packages are downloaded from the internet and 5 minutes if they are \nobtained from a local .le cache. The automation of the Jasper install via Engage ensures a repeatable \nprocess, supports both local and cloud-based targets, and can be used as a part of a larger deployment \n(e.g., where the reports server can be used as a service to a web application). The partial installation \nspeci.cation for Jasper is 26 lines long. The full installation speci.cation generated by the con.guration \nengine is 434 lines long.  6.2 Django Applications We implemented resources and drivers for installation \nand man\u00adagement of applications developed in Django [6], a web applica\u00ad tion framework written in Python. \nA goal of our Django support was to enable Django developers to deploy their existing applica\u00adtions on \ndi.erent environments (local test environments and pro\u00adduction environments on the cloud) with little \nchanges and no need to understand the internals of Engage. To achieve this, we built an application packager \nthat validates a Django application, extracts some metadata used by Engage, and packages the application \ninto an archive with a pre-de.ned layout. This application can then be deployed by Engage to the cloud \nor a local machine. We provide pre-de.ned partial installation speci.cations for the same appli\u00adcation \nto be deployed in di.erent con.gurations (e.g., debug or production, local or cloud), supporting the \nmigration of changes through the full development lifecycle: from development to QA to staging to production. \nDjango support involves 37 resources, of which 14 are speci.c to Django applications. Engage allows the \nfollowing (independent) con.guration choices for Django applications: OS: MacOSX (two versions) or Ubuntu \nLinux (two versions)  Web server: Gunicorn or Apache HTTP server  Database: SQLite or MySQL  Optional \ncomponents: RabbitMQ/Celery (message queu\u00ading), Redis (key-value store), and memcached (caching)  Optional \nmonitoring: Monit   Thus, we currently support 256 distinct deployment con.gurations on a single node. \nFurthermore, many topologies of these com\u00adponents are permitted by the Engage architecture: everything \nde\u00adployed to the same node, a separate node for each component, multiple application nodes, etc. Finally, \nour Django driver supports the declarative enumeration of Python packages available from the Python package \nindex (http://pypi.python.org) to be installed as a prerequisite to the Django application. Evaluating \ninstalls We have evaluated Engage s Django support by testing it with Django applications developed by \nus, obtained as open source applications, and provided by third party beta testers. Table 1 summarizes \neight of the applications we deployed. All eight applications were deployable by Engage without requiring \nany application-speci.c deployment code. Areneae and Django-Blog are particularly interesting, as they \nwere developed and de\u00adployed by beta customers (who had no prior contact with the paper authors), using \nonly our documentation and a few email exchanges. WebApp is the production infrastructure that runs a \ncommercial PaaS (Platform as a Service) site. It is about 4K lines of code, and uses asynchronous messaging, \ncron jobs, and caching. The partial installation speci.cation for the production site is 61 lines long \nand has seven resources. The full installation speci.cation generated by the Engage con.guration engine \nfrom this spec is 1,444 lines long and has 29 resources. Evaluating upgrades To evaluate application \nupgrades, we took two snapshots of the FA application about four months apart. Both snapshots represented \nproduction versions of the application. Be\u00adtween the two snapshots, the user interface, application logic, \nand database schema all changed. We use South, a database migra\u00adtion framework, in the Engage Django \ndriver to support applica\u00adtion upgrades involving database schema changes. Using South, we were able \nto automatically upgrade from the old version to the new version of the application, while preserving \nthe content in the database. If we introduce an error in the second application version that causes the \nupgrade to fail, Engage automatically rolls back to the prior application version.  7. Conclusion We \nhave presented Engage, a novel system for deployment of com\u00adplex multi-component, distributed applications. \nOur contribution in this paper is twofold. First, we introduce a domain-speci.c lan\u00adguage that provides \nthe necessary syntax to impose a set of com\u00admon structural dependencies between a set of inter-dependent \nre\u00adsources succinctly and explicitly. Second, we present a tool suite that exploits the language: (i) \nto provide e.ective static checks to identify speci.cation .aws and incompatibilities; (ii) to identify \na full installation speci.cation of a system from an input partial in\u00adstallation speci.cation; (iii) \nto carry out an installation speci.ca\u00adtion automatically; and (iv) to manage the life cycles of installed \nresources automatically.  References [1] Puppet at Puppet Labs: http://www.puppetlabs.com/. [2] Chef \nat Opscode: http://www.opscode.com/chef/. [3] Apache Libcloud: http://libcloud.apache.org/. [4] Monit: \nhttp://mmonit.com/monit/. [5] JasperReports Server: http://www.jaspersoft.com/reporting-server/. [6] \nDjango: https://www.djangoproject.com/. [7] J. Aldrich, C. Chambers, and D. Notkin. Architectural reasoning \nin ArchJava. In ECOOP 02, pages 334 367. Springer, 2002. [8] P. Anderson and A. Scobie. LCFG: the next \ngeneration. In UKUUG Winter Conference. UKUUG, 2002. [9] M. Burgess. A site con.guration engine. Computing \nSystems, 8(2):309 337, 1995. [10] A. Cicchetti, D. Di Ruscio, P. Pelliccione, A. Pierantonio, and S. \nZa\u00adcchirol. A model driven approach to upgrade package based software systems. In Evaluation of Novel \nApproaches to Software Engineering, pages 262 276. Springer, 2010. [11] R. Di Cosmo, D. Di Ruscio, P. \nPelliccione, A. Pierantonio, and S. Za\u00adcchiroli. Supporting software evolution in component-based FOSS \nsystems. Science of Computer Programming, 2010. [12] R. Di Cosmo and J. Vouillon. On software component \nco-installability. In SIGSOFT FSE 11, pages 256 266. ACM, 2011. [13] R. Di Cosmo, P. Trezentos, and S. \nZacchiroli. Package upgrades in FOSS distributions: Details and challenges. In HotSWup 08, 2008. [14] \nM. Flatt and M. Felleisen. Units: Cool modules for HOT languages. In PLDI 98, pages 236 248. ACM, 1998. \n[15] D. Gay, P. Levis, R. von Behren, M. Welsh, E. Brewer, and D. Culler. The nesC language: A holistic \napproach to networked embedded sys\u00adtems. In PLDI 03, pages 1 11. ACM, 2003. [16] P. Goldsack, J. Guijarro, \nS. Loughran, A. Coles, A. Farrell, A. Lain, P. Murray, and P. Toft. The SmartFrog con.guration management \nframework. Operating Systems Review, 43(1):16 25, 2009. [17] F. Mancinelli, J. Boender, R. di Cosmo, \nJ. Vouillon, B. Durak, X. Leroy, and R. Treinen. Managing the complexity of large free and open source \npackage-based software distributions. In ASE 06, pages 199 208. IEEE Computer Society, 2006. [18] P. \nTrezentos, I. Lynce, and A. L. Oliveira. Apt-pbo: solving the software dependency problem using pseudo-Boolean \noptimization. In ASE 10, pages 427 436. ACM, 2010. [19] C. Tucker, D. Shu.elton, R. Jhala, and S. Lerner. \nOPIUM: Optimal package install/uninstall manager. In ICSE 07, pages 178 188. IEEE Computer Society, 2007. \n[20] B.A. Wolfe, B.W. Mamlin, P.G. Biondich, H. Fraser, D. Jazayeri, C. Allen, J. Miranda, and W.M. Tierney. \nCooking Up an Open Source EMR for Developing Countries: OpenMRS A Recipe for Success\u00adful Collaboration. \nIn American Medical Informatics Association An\u00adnual Symposium, pages 529 533. AMIA, 2006.  \n\t\t\t", "proc_id": "2254064", "abstract": "<p>Many modern applications are built by combining independently developed packages and services that are distributed over many machines with complex inter-dependencies. The assembly, installation, and management of such applications is hard, and usually performed either manually or by writing customized scripts. We present Engage, a system for configuring, installing, and managing complex application stacks. Engage consists of three components: a domain-specific model to describe component metadata and inter-component dependencies; a constraint-based algorithm that takes a partial installation specification and computes a full installation plan; and a runtime system that co-ordinates the deployment of the application across multiple machines and manages the deployed system. By explicitly modeling configuration metadata and inter-component dependencies, Engage enables static checking of application configurations and automated, constraint-driven, generation of installation plans across multiple machines. This reduces the tedious manual process of application configuration, installation, and management.</p> <p>We have implemented Engage and we have used it to successfully host a number of applications. We describe our experiences in using Engage to manage a generic platform that hosts Django applications in the cloud or on premises.</p>", "authors": [{"name": "Jeffrey Fischer", "author_profile_id": "81452610588", "affiliation": "genForma Corporation, Sunnyvale, USA", "person_id": "P3471218", "email_address": "jeffrey.fischer@genforma.com", "orcid_id": ""}, {"name": "Rupak Majumdar", "author_profile_id": "81100319213", "affiliation": "MPI-SWS, Kaiserslautern, Germany", "person_id": "P3471219", "email_address": "rupak@mpi-sws.org", "orcid_id": ""}, {"name": "Shahram Esmaeilsabzali", "author_profile_id": "81300243401", "affiliation": "MPI-SWS, Kaiserslautern, Germany", "person_id": "P3471220", "email_address": "shahram@mpi-sws.org", "orcid_id": ""}], "doi_number": "10.1145/2254064.2254096", "year": "2012", "article_id": "2254096", "conference": "PLDI", "title": "Engage: a deployment management system", "url": "http://dl.acm.org/citation.cfm?id=2254096"}