{"article_publication_date": "06-11-2012", "fulltext": "\n Automated Synthesis of Symbolic Instruction Encodings from I/O Samples Patrice Godefroid AnkurTaly \n* Microsoft Research Stanford University pg@microsoft.com ataly@stanford.edu Abstract Symbolicexecutionisakey \ncomponentof precise binary program analysis tools.We discuss how to automatically boot-strap the con\u00adstruction \nof a symbolic execution engine for a processor instruction set such as x86, x64 or ARM. We show how to \nautomatically syn\u00adthesize symbolic representations of individual processor instruc\u00adtions from input/output \nexamples and express them as bit-vector constraints. We present and compare various synthesis algorithms \nand instruction sampling strategies. We introduce a new synthesis algorithm based on smart sampling which \nwe show is one to two orders of magnitude faster than previous synthesis algorithms in our context.With \nthis new algorithm, we can automatically synthe\u00adsize bit-vector circuits for over 500 x86 instructions \n(8/16/32-bits, outputs, EFLAGS) using only6synthesis templates andin less than two hours using the Z3 \nSMT solver on a regular machine. During this work, we also discovered several inconsistencies across \nx86 processors, errors in the x86 Intel spec, and several bugs in previ\u00adous manually-written x86 instruction \nhandlers. Categories and Subject Descriptors D.2.3[Software Engineer\u00ading]: Coding Tools and Techniques; \nD.2.4 [Software Engineer\u00ading]: Software/Program Veri.cation; D.2.5[Software Engineer\u00ading]:Testing and \nDebugging; F.3.1[Logics and Meanings of Pro\u00adgrams]: Specifying andVerifying and Reasoning about Programs \nGeneral Terms Languages,Veri.cation Keywords Program Synthesis, Symbolic Execution, x86 1. Introduction \nSymbolic execution is a key component of precise binary pro\u00adgram analysis tools, for test generation \n[6, 17], program veri.\u00adcation [2, 20], malware analysis [1, 23], and other applications. Symbolic execution \nengines are traditionally written by hand [1, 2, 6, 17, 20, 23]: the effect of executing each individual \ninstruc\u00adtion is described by a symbolic constraint, called symbolic instruc\u00adtion encoding, written manually \nand derived by reading the proces\u00adsor instruction manual. Unfortunately, the semantics of the instruc\u00adtion \nset of general-purpose processors such as x86, x64 or ARM * The work of this author was done mostly while \nvisiting Microsoft. Permission to make digital or hard copies of all or part of this work for personal \nor classroomuseisgrantedwithout feeprovidedthat copies arenot madeordistributed forpro.torcommercialadvantage \nandthatcopiesbearthisnoticeandthefullcitation onthe .rstpage.To copy otherwise,to republish,topostonserversorto \nredistribute tolists, requirespriorspeci.cpermission and/ora fee. PLDI 12, June11 16,2012, Beijing, China. \nCopyright c &#38;#169; 2012ACM978-1-4503-1205-9/12/06. . .$10.00 is very complex. For instance, x86 includes \nhundreds of instruc\u00adtions whose semantics is described in more than 2,000 pages di\u00advided in 3 volumes. \nThis complexity makes the manual develop\u00adment of symbolic-execution engines tedious (many instructions), \nerror-prone (many corner cases), partial (not all instructions are usually covered) and imprecise (approximations \nare often used). Moreover, the of.cial reference manual is often under-speci.ed and may itself contain \nerrors. In this work, we explore a radically different approach to devel\u00adoping symbolic-execution engines: \nwhat if most symbolic instruc\u00adtion encodings could be synthesized automatically? To do this, we study \nhow to adapt and extend recent advances on automatic program synthesis. Given a functional speci.cation \nand a set ofbuilding blocks, called components, possibly combined to\u00adgether as described in a solution \ntemplate or program sketch (i.e., a program with holes), automatic program synthesis consists of searching \nthe space of all possible template completions for a fully\u00adde.ned program (i.e., with no holes left) \nthat satis.es the speci.\u00adcation. In our context, we do not have access to a full functional speci.cation \nof individual processor instructions such a speci.\u00adcation is precisely what we want to infer. But we \nhave access to a cheap andfast speci.cation oracle: we can execute instructions on a processor and observe \ntheir input/output behaviors. Program synthesis from I/O samples has been recently investi\u00adgated in [13]. \nThere, an I/O oracle-guided synthesis algorithm is presented for loop-free programs. This algorithm consists \nof com\u00adputing a set of I/O samples, then synthesizing a candidate program that satis.es those samples \n(to check whether such a program ex\u00adists), then computing a distinguishing input that distinguishes this \ncandidate program P from some other non-equivalent candidate program P ' (to check whether P is unique), \nand if such an input ex\u00adists, then query the I/O oracle with this distinguishing input to elim\u00adinate \neither P or P ' as a possible solution. This counter-example\u00adguided iterative synthesis process is repeated \nuntil one unique so\u00adlution remains, or no solution exists if the synthesis template is too constrained. \nThe algorithm assumes the existence of a veri.cation oracle which can determine whether a solution is \ncorrect . In our context,wedo nothave access to suchaveri.cation or\u00adacle. For instructions with small \nI/O signatures, such as 8-bit in\u00adstructions,exhaustive testing can provideaveri.cation oracle,but exhaustive \ntesting does not scale to 16-bit or 32-bit instructions. Another practical hurdle is that the counter-example-guided \nitera\u00adtive synthesis algorithm of [13] can be very expensive when many iterations are needed, as we will \nshow with results of experiments in Section 6. To improve on this, we propose a new synthesis algorithm \nbased on smart sampling which we show is one to two orders of magni\u00adtudefaster than previous synthesis \nalgorithms in our context. Given a speci.c template, the main idea is to generate upfront a set of distinguishing \ninputs which uniquely determine each possible so\u00adlution re.ning the template. This way, our new synthesis \nalgorithm converges faster to the unique solution, without requiring any ad\u00additionalexpensive synthesis-re.nement \nsteps. Synthesis with smart sampling is more ef.cient when a template is repeatedly used for manyinstructions, \nas is the case in our context.  In this work, we want to automatically generate concise yet pre\u00adcise \nsymbolic instruction encodings that can be used for bit-precise symbolic execution of large programs \nand long execution paths. Conciseness is important for scalability, while precision is key to detect \nsubtle programbugs (for instance due to integerover.ows). For these reasons, we adopt bit-vector constraints \nsupported by SMT solvers as synthesis components. For automatic synthesis to be practical, synthesis \ntemplates should be constrained enough to de.ne a tractable search space, yet abstract enough to allow \na simple representation of many pos\u00adsible solutions. Perhaps surprisingly, we show that the I/O behavior \nof over 500 x86 instructions (8/16/32-bits, outputs, EFLAGS) can be precisely captured with only6 synthesis \ntemplates. Using these templates and our new smart sampling synthesis algorithm, we can automatically \nsynthesize bit-vector circuits for all those 500+ in\u00adstructions in less than two hours using the Z3 SMT \nsolver on a regular x86 machine. Moreover, the size of the synthesized cir\u00adcuits is either constant or \nlinear in the number of input/output bits, satisfying our conciseness requirement. This paper is organized \nas follows. In Section 2, we precisely de.ne the problem addressed in this work. Then, we review in Sec\u00adtion \n3 existing automatic synthesis approaches and discuss their applicabilitytoour context.We introducein \nSection4 ournewsyn\u00adthesis algorithm based on smart sampling. In Section 5, we present 6 synthesis templates \nthat together abstract the semantics of over 500 x86 instructions, and we discuss properties of those \ntemplates. Next, we comparein Section6the performanceof several synthesis algorithms with those templates.We \ndiscuss ouroverall results for x86, lessons learned and limitations in Section 7. We then discuss other \nrelated work in Section 8, and conclude in Section 9. 2. Problem De.nition We consider a processor which \ncan execute a set of instructions. In this work, we focus on ALU instructions and will not consider .oating \npoint and SIMD instructions. We will also ignore speci.c addressing modes and assume that an instruction \nhas some inputs and outputs,but we will not distinguish where those inputs or out\u00adputs are being stored, \ne.g., in a register or a memory location. How\u00adever, we do consider the sizes of the input and output \narguments of an instruction, which we assume are known (i.e., are not inferred automatically). Formally, \nwe de.ne an instruction instance I as a function that takes a known .xed ordered set ii of inputs, each \nof a known .xed size, which may be read during the execution of the instruction, and returns a known \n.xed ordered set io of outputs, each of a known .xed size, which may be written during the execution \nof the instruction. We thus assume that the execution of each instruction instance is deterministic and \nalways terminates. In what follows, we will treat each output o in io separately, abuse notation by writing \no = f(ii), and calling such a function an instruction instance. For instance, SHL is an x86 instruction, \nwhile SHL8 is an in\u00adstruction instance that takes two 8-bit values as inputs and returns an 8-bit value \nas output representing the main result, and SHL8CF is another instruction instance that takes again two \n8-bit values as inputsbut returns a boolean value representing thevalue of the CF .ag (part of the x86 \nEFLAGS ) after executing the instruction. The problem we consider in this work is to automatically syn\u00adthesize \na (concise and precise) representation of function f for a given instruction instance.We call sucha representationa \nsymbolic representation, or symbolic encoding, or instruction handler. However, function f is unknown. \nAll we are given to learn about f is a processor P implementing the instruction instance, which we can \nsample by providing some input values, executing the instruction instance, and then observing the output \nvalue. In other words, processor P is a black-box input/output oracle for instruction instance I. This \noracle is denoted F(P,I) in what follows. Because we want to generate concise and precise symbolic representations, \nwe will represent inputs and outputs by bit-vectors, and functions by logic expressions using the theory \nof bit-vectors as de.ned by modern SMT solvers. We will sometimes call such function representations \ncircuits. If ii represents two inputs i1 and i2 , each of size s, we will write i1 [j]with 0 = j<s to \ndenote the jth bit of i1 . In summary, the problem considered in this work is: Given a black-box processor \nP and an instruction instance I, how to automatically synthesize a function f that is semantically equivalent \nto the oracle F(P,I)? 3. Synthesis Procedures In this section, we review prior synthesis approaches to \nthe function synthesis problem given a black-box I/O oracle f = F(P,I). We present two procedures ExhaustVal \nand DInputVal and discuss their correctness and scalability. Both procedures involve three stages: a \nsampling stage, a syn\u00adthesis stage, and a veri.cation stage. In the sampling stage, the I/O oracle is \nqueried on an initial set of inputs and a set of I/O sam\u00adples S is obtained. In the synthesis stage, \na function is synthesized whose behavior respects the samples S. This is done by using a template-based \napproach (see below) to .nd a function f that sat- V is.es if(ii)= o. The synthesized function f is then \npassed i,o.S totheveri.cation stageto check whetherit matchestheI/O oracle on other samples outside S. \nSamples thatfail theveri.cation check are sent back to the synthesis stage, and the procedure is repeated \nuntil the veri.cation check succeeds.The two procedures differ in the speci.cveri.cation checks used. \nBefore presenting the two procedures in more details, we review the motivation for template-based synthesis. \n 3.1 Template-Based Synthesis A direct approach for synthesizing a function f satisfying the samples \nS is to check the satis.ability of the formula ^ .f : f(ii)= o ii,o.S Unfortunately, this second-order \nlogic formula can be expensive or even impossible to check. A common approach to get rid of the quanti.cation \nover functions is to use a function template. Infor\u00admally, a function template T is a function with some \nfree variables ic called coef.cients. Instantiating the coef.cients with concrete val\u00adues de.nes a closed \n(i.e., fully-de.ned) function T(ic), called con\u00adcretization. The set .(T)of all possible concretizations \nof a tem\u00adplate T is thus de.ned as the set {C |.ic : C = T(ic)}. By re\u00adplacing the function f in the \nsynthesis formula above by a function template T and by existentially quantifying its coef.cients, the \nsyn\u00adthesis problem is reduced to satis.ability checking of a .rst-order logic formula ^ SYNT,S(ic):= \n.ic : T(ic,ii)= o ii,o.S where T(ic,ii)denotes application of function T(ic)with inputs ii.  ExhaustVal(f,T,nsyn \n) 1. I := nsyn valid inputs for f picked randomly 2. Iex := All valid inputs for f 3. S := Sample(I,f) \n 4. Sex := Sample(Iex,f) 5. ai:= SAT(SYNT,S(ic)) // returns .if UNSAT 6. if (ai= .)return Insuf.cientTemplate \n 7. C := T(ai)  8. Sfail := Verify(C,Sex) 9. if (Sfail == \u00d8)return C 10. S := S.Sfail 11. goto step \n5  Figure 1. Procedure ExhaustVal: ExhaustiveValidation If the template T is expressed as a quanti.er-free \nformula us\u00ading the theory of bit-vectors and if the set of possible values for the coef.cients is .nite, \nchecking the satis.ability of the formula SYNT,S(ic)is decidable. If the above formula is unsatis.able, \nthen the template cannot be used to synthesize a function that satis.es the samples S. We de.ne this \nproperty of template suf.ciency as follows. DEFINITION 1. [Template Suf.ciency] A template T is suf.cient \nfor abstracting a function C if C . .(T). We now describe the two proceduresExhaustVal and DInputVal \nfor ef.ciently solving the template-based synthesis problem. In what follows, Sample(I,f)for a set of \ninputs I and an I/O oracle f = a,f(ii F(P,I)denotes the set {(ia)) |a .I}of samples (I/O pairs) obtained \nby executing each input by the oracle. Moreover, Verify(C,S)for a function C and a set of samples S denotes \nthe set {(ii,o).S|C(i.o}of samples which do not agree with C i)= (if any).  3.2 Procedure ExhaustVal \nThe procedure ExhaustVal is described in Figure 1. It takes as input an I/O oracle f, a template T and \na number of synthesis samples nsyn . During the sampling stage (lines 1 - 4), nsyn valid inputs are chosen \nrandomly to de.ne the set I, while the set Iex contains all possible valid inputs. Next, two sets S and \nSex of I/O samples are constructed by querying the oracle f on inputs in I and Iex respectively. During \nthe synthesis stage (lines 5 -8), the synthesis formula SYNT,S(ic)is checked for satis.ability. If the \nformula is unsatis.\u00adable then the procedure returns Insuf.cient Template , otherwise the satisfying assignment \naifor all the template coef.cients is used to construct the function C := T(ai). The veri.cation stage \n(lines 9-11)checks whether the synthe\u00adsized function C agrees with all possible I/O samples Sex using \nthe procedure Verify. The procedure returns the set Sfail of all sam\u00adples thatfail. If Sfail = \u00d8then \nthe function C is returned, else the set offailed samples Sfail are added to the set of synthesis samples \nS and the procedure loops back to the synthesis stage (line 3). Note that the synthesis stage is more \nexpensive (NP-hard) than the veri.cation stage (linear in the size of each sample), which ex\u00adplains why \nthe procedure ExhaustVal does not consider immedi\u00adately the Sex in its synthesis stage.We now state the \nmain proper\u00adties of the procedure ExhaustVal. DInputVal(f,T, nsyn , nver ) 1. I := nsyn valid inputs \nfor f picked randomly 2. S := Sample(I,f) 3. ai:= SAT(SYNT,S(ic)) // returns .if UNSAT 4. if (ai= \n.)return Insuf.cientTemplate 5. C := T(ai) 6. Iver := nver valid inputs for f picked randomly  7. \nSver := Sample(Iver,f) 8. Sfail := Verify(C,Sver)  9. if (Sfail == \u00d8) 10. ii := SAT(DISTINCTT,C,S(ii)) \n 11. if (ii = .)return C 12. S := S. Sample({ii},f) 13. goto step 3 14. S := S.Sfail 15. goto step \n3  Figure 2. Procedure DInputVal: Distinguishing-Input basedVal\u00adidation THEOREM 1. Given a template \nT, an oracle f, and any nsyn > 0, the following holds: 1. If the template T is suf.cient for abstracting \nthe oracle f, then the procedure ExhaustVal(f,T, nsyn )returns a function semantically equivalent to \nf; 2. Else theprocedurereturns Insuf.cientTemplate .  In other words, procedure ExhaustVal is both \nsound and com\u00adplete, thanks to its exhaustive validation. Unfortunately, exhaustive validation does not \nscale to large inputs, such as 16-bit and 32-bit instructions. For instance, any 16-bit instruction instance \nwith two 16-bit inputs requires an exhaustive sample set of 232 samples, that is, more than a billion \nsamples to verify.  3.3 Procedure DInputVal We now present the procedure DInputVal, described in Figure \n2 which offers weaker veri.cation guarantees but scales to larger input signatures. Besides an I/O oracle \nf and a template T, this procedure takes two additional inputs nsyn and nver denoting the number of synthesis \nand veri.cation samples, respectively. This procedure assumes that the input template T is suf.cient \nfor abstracting the I/O oracle f. Its goal is to search through all functions abstracted by the template \nand to return one that is seman\u00adtically equivalent to the oracle. If this assumption is right, the pro\u00adcedure \nreturns a correct function. But if the assumption is wrong, it may either detect that the template is \nnot suf.cient, or return a wrong function. Similarly to the procedure ExhaustVal, the sampling stage \n(lines 1 - 2)computesa set of synthesis samples S by querying the oracle f ona set I of nsyn inputs chosen \nrandomly. The synthesis stage (lines 3 - 5) checks for a satisfying assignment for the formula SYNT,S(ic). \nIf the formula is unsatis.able then the procedure returns Insuf.cientTemplate , otherwise the satisfying \nassignment aifor all the template coef.cients is used to construct the function C := T(ai). The procedure \ndiffers from ExhaustVal in its veri.cation stage (lines 6-15).Weexplain the main idea .rst and then present \nthe details.  Intuitively, if we assume that the template T is suf.cient for ab\u00adstracting the oracle \nf, and if we can show that all the concretization functions for T that satisfy samples S are all semantically \nequiv\u00adalent, then the synthesized function C is semantically equivalent to the oracle. In order to show \nthis, we make use of the distin\u00adguishing input check, introduced in [13]. A distinguishing input DISTINCTT,C,S(ii)for \na function C, a template T and a set S of samples is an input iithat can be used to distinguish C from \nanother function that also concretizes the template and satis.es all the sam\u00adples in S.Formally, we de.ne \nDISTINCTT,C,S(ii)as ^ .ic :( T(ic,ij)= o) . T(ic,ii)=.C(ii) i j,o.S If an input ii satis.es the above \nformula, then there are at least two non-equivalent functions that concretize the template and sat\u00adisfy \nthe samples in S;therefore, by querying the oracle withii and adding the resulting I/O sample to S, we \ncan strictly reduce the number of non-equivalent functions that concretize the template and satisfy all \nprevious samples. Otherwise, if the formula is unsat\u00adis.able, then C is guaranteed to be equivalent to \nall other functions that concretize the template and satisfy all previous samples. We now describe the \npseudo-code for the validation stage. The .rst step (lines 6-8)is to samplenver inputs at random and \nquery the oracle on them, thereby building the set of I/O samples Sver. Next the synthesized function \nC is veri.ed against the samples Sver, and the samples that fail are collected in the set Sfail. If Sfail \n.\u00d8, then the samples are added (line 14) to the set = of synthesis samples S and the procedure loops \nback to the synthesis stage (line 3). If Sfail = \u00d8, then the formula DISTINCTT,C,S(ii) is checked for \nsatis.ability. If it is unsatis.able, then the function C is returned; otherwise, the oracle is queried \nwith the satisfying assignment ii, the sample Sample({ii},f) is added to the set of synthesis samples \nS, and the procedure then loops back to the synthesis stage. The reason for the veri.cation stage with \nthe samples Sver is to reduce the number of expensive satis.ability checks of formulas DISTINCTT,C,S(ii). \nIf the template is suf.cient for abstracting the oracle, anyinput that distinguishes the synthesized \nfunction C from the oracle is also a distinguishing input. Thus, checking C against a set of randomly \nchosen samples provides a cheap way of searching for distinguishing inputs. We now state the main property \nof the procedure DInputVal. THEOREM 2. Given a template T, an oracle f, and any nsyn , nver > 0, if T \nis suf.cient for abstracting f, then the procedure DInputVal(f,T, nsyn , nver ) returns a function C \nsemantically equivalent to f. A useful corollary is that, if the procedure DInputVal returns In\u00adsuf.cient \nTemplate for any nsyn , nver , then the template T is in\u00addeed insuf.cient for abstracting f. However, \nthis theorem is weaker than Theorem1 as it does not guarantee that the procedure returns Insuf.cientTemplate \nwhenever the template is insuf.cient. Just like procedure ExhaustVal, DInputVal provides a satis\u00adfactory \nsolution to the instruction handler synthesis problem pro\u00advided we can .nd a template that is suf.cient \nfor abstracting the oracle F(P,I). Although the procedure DInputVal scales to in\u00adstruction instances \nwith large inputs, the running time can still be very long for some templates, as we will see in Section \n6. The most expensive step in the procedure is checking the satis.ability of for\u00admulas DISTINCTT,C,S(ii). \nSince the satis.ability of each such for\u00admula depends on a set S of random samples, the running time \nof the procedure can vary signi.cantly across various invocations. In the next section, we present a \nnew synthesis procedure that pro\u00advides the same correctness guarantee as the procedure DInputVal, but \nalleviates the above limitations. 4. Smart Sampling In this section, we present a new template-based \nsynthesis proce\u00addure SmartVal that provides the same correctness guarantee as procedure DInputVal but \ndoes not require any distinguishing in\u00adput check. As a result, the procedure has a signi.cantly better \nand more predictable running time than the procedure DInputVal. As with procedure DInputVal, the procedure \nSmartVal also assumes that the given template is suf.cient for abstracting the given I/O oracle. Given \na speci.c template, the main idea is to generate upfront a set of distinguishing inputs which uniquely \ndetermine each pos\u00adsible solution re.ning the template. This way, the new synthesis algorithm converges \ndirectly to the unique solution, without re\u00adquiring any other expensive synthesis-iteration and distinguishing\u00adinput \nsteps. Recall from section 3.3 that the distinguishing input check is performed to guarantee that for \na template T and a set of synthesis samples S, the synthesized function C is semantically equivalent \nto all functions that concretize template T and satisfy all the samples in S. In order to avoid the distinguishing \ninput check, we want to run a (unique) synthesis step with a set of samples obtained with an input set \nI such that all the functions that concretize template T and satisfy all the samples in Sample(I,f), \nare all semantically equivalent. We call such an input set I smart for the template T and oracle f.Formally, \nwe have the following. DEFINITION 2. [Smart Inputs] A set I of inputs is smart for a template T and an \noracle fif ^ .ic :( T(ic,ij)= o).\u00ac DISTINCTT,T(ic),S(ii) i j,o.S with S = Sample(I,f). When a set I of \ninputs is smart for a template T and an oracle f, we write SmartT,f(I). The previous de.nition depends \nona speci.c oracle f.We can generalize it and de.ne a stronger property on input sets, which we call \nuniversal smartness for a template T independently of any speci.c oracle f. A set I of inputs is universally \nsmart for a template T if any two functions that concretize the template and agree on all the inputs \nin I are semantically equivalent. Formally, we have the following. DEFINITION 3. [Universally Smart Inputs] \nA set I of inputs is universally smart for a template T, denoted by USmartT(I), if V .ic,d,ii :( ic,i= \nd,iT(ii)= T(ii) ij.I T(ij)T(ij)) . c,id,i By de.nition, a universally smart input set for a template \nis also smart for the template and anypossible oracle f. LEMMA 3. USmartT(I)..f : SmartT,f(I) Thus, for \na .xed template, and given a set of universally smart inputs for that template, we are then guaranteed \nthat, irrespective of the oracle, all functions synthesized by sampling those inputs do not require anydistinguishing \ninput check. The procedure SmartVal is described in Figure 3. It takes as input an I/O oracle f, a template \nT and a set I of inputs such as SmartT,f(I). The procedure has only one sampling and one syn\u00adthesis stage. \nThe sampling stage (lines 1)computes a set of samples for the smart set of inputs I by querying the oracle \nf. The synthesis stage (lines 2-4)checks the formulaSYNT,S(ic)for satis.ability. If the formula is unsatis.able, \nthen the procedure returns Insuf\u00ad.cient Template ; otherwise, the satisfying assignment aide.nes  SmartVal(f,T,I) \n1. S := Sample(I,f) 2. ai:= SAT(SYNT,S(ic)) // returns .if UNSAT 3. if (ai= .)return Insuf.cientTemplate \n 4. return T(ai)  Figure 3. ProcedureSmartVal the concrete function T(ai), which is then returned. We \nprove the following. THEOREM 4. Given a template T, an I/O oracle fand a smart set I of inputs for T \nand f, if T is suf.cient for abstracting f, then the procedure SmartVal(f,T, I) returns a function C \nsemantically equivalent to f. Like procedure DInputVal, SmartVal is guaranteed to return a function semantically \nequivalent to the oracle fonly if the template T is suf.cient for abstracting f;if this assumption is \nwrong, it may either detect that the template is not suf.cient, or return a wrong function. As will be \nshown in Section 6, SmartVal can be much faster thanDInputVal. But it also requires a set of smart inputs. \nWe now discuss several approaches to compute smart or univer\u00adsally smart inputs.Trivially, the set of \nall possible inputs is univer\u00adsally smart for any template, but we want smart input sets to be as small \nas possible so that the synthesis step isfast. Brute-force approach. Using De.nition3 for USmartT(I), \nwe can compute a set I by checking the satis.ability of the formula ^ iT(iT(i .I : .ic, d,ii :( T(ic,ij)= \nd,ij)) . T(ic,ii)= d,ii) i j.I If such a set I exists, then it is universally smart for T, by de.ni\u00adtion. \nTherefore, a straightforward procedure for synthesizing uni\u00adversally smart inputs is to check the satis.ability \nof the above for\u00admula for any set I of size 1, then 2, then 3, and so on. This ap\u00adproach can return a \nuniversally smart input set of minimum cardi\u00adnality. Its drawback is that checking satis.ability of a \n.. formula can be expensive. Greedy approach. Here is a straightforward greedy procedure for constructing \na universally smart set of inputs: 1. I := \u00d8 2. If USmartT(I)holds then return I 3. Else there exist \ncoef.cients ic, diand an input ii such that  V T(iT(i ( ij.I T(ic,ij)= d,ij)) .T(ic,ii).= d,ii) Add \nii to the set I and go to step (2) Unlike the brute-force approach, this approach may not return a universally \nsmart input set of minimum cardinality. But checking the validity of USmartT(I)can be cheaper because \nit avoids the existential quanti.er on I. Manual approach. Universally smart input sets can be inferred \nfrom the structure of a template. Therefore, they can also be de\u00ad.ned manually while designing the template. \nA manually de.ned set I can be veri.ed for universal smartness using the predicate USmartT(I)andanSMT \nsolver.Iftheveri.cationfails, thenthe set can be used as the initial set for the greedy approach described \nabove, which would then iteratively enlarge it and eventually return a universally smart input set. Note \nthat universally smart input sets need to be constructed only once for each template, and can then be \nre-used for all the instruction instances (oracles) covered by each template. Synthesis with smart sampling \nis thus especially attractive when a template is repeatedly used for manyinstructions instances, as is \nthe case in our context. 5. SynthesisTemplatesfor x86 We discuss in this section how to partially automate \nthe construc\u00adtion of a symbolic execution engine for the x86 processor instruc\u00adtion set using the synthesis \ntechniques described in the previous sections. Speci.cally, we present 6 synthesis templates that to\u00adgether \nabstract the semantics of over 500 x86 instruction instances. These templates are expressed using bit-vector \nconstraints for the conciseness and precision requirements discussed in Section 2. The x86 processor \nhas a complex instruction set architecture (CISC) with 8, 16 and 32 bit instructions. The instructions \ncan be divided into three broad groups: ALU instructions, .oating-point instructions and SIMD instructions. \nIn this work, we only focus on ALU instructions since modern SMT solvers supporting the theory of bit-vectors \nprovide the required building-blocks for expressing their semantics (concisely and precisely). Each x86 \nALU instruc\u00adtion takes from0to3inputs and has0to2outputs, all being stored in either registers or memory \nlocations. The size of the register and memory locations determines the size of the individual inputs \nand outputs. Typically, most instructions are overloaded and can be executed with 8, 16 or 32 bit inputs. \nMoreover, the execution of each instruction can also set or reset special boolean .ags, called EFLAGS. \nIn this work, we consider the 5 most commonly used .ags: the carry .ag CF, the over.ow .ag OF, the zero \n.ag ZF, the sign .ag SF, and the parity .ag PF. As explained in Section 2, when de.ning instruction instances, \nwe ignore where the inputs and outputs are stored, and only con\u00adsider their sizes. For any instruction \ninstance, all its inputs are of size either 8, 16 or 32 bits. The output of each instruction instance \nis either one of the main outputs, whose size is either 8, 16 or 32 bits, or one of the .ag outputs, \nwhich are all 1-bit in size. As an example, the instruction SHL corresponds to 3\u00d76 =18 instruction instances: \nfor each sizeof8,16 and32 bits, there are6instances,1 for the main output and5 for each of the .ag outputs. \nIn order to de.ne a few tractable synthesis templates that are ab\u00adstract enough to cover the semantics \nof manyx86 ALU instructions, we .rst consulted the Intel x86 instruction set reference manual. Based \non a preliminary study, we partitioned the ALU instructions into3 groups, basedon similaritiesin theirexecution \nsemantics. 1. Bit-wise group (BW) contains instructions that perform bit-wise operations, such as AND, \nOR, and XOR. 2. Arithmetic group (ARI)includes instructions that perform arith\u00admetic operations, such \nas ADD, SUB, and MUL. 3. Bit-Shift group (BS)contains instructions that perform shift, ro\u00adtate and bit-.ip \noperations, such as SHL, ROL, and BTS.  For each instruction group, we de.ne two templates: one for \nthe main output instruction instances, called the main template, and the other for the .ag output instruction \ninstances, called the .ag template. Since, for a particular instruction, there are different instruction \ninstances for the different sizes of inputs and outputs, we de.ne synthesis templates that are parametric \non the input and output size. From the Intel x86 speci.cation, we learn that the .ag outputs of an instruction \noften depend on the main output. For example, the zero .ag is often set when the main output is zero.For \nthis reason, we de.ne each .ag template as an extension of the main template for the corresponding instruction \ngroup: the .ag template for an instruction is de.ned using a symbolic instruction encoding (a circuit) \nCmain for the main output of the same instruction, and this circuit Cmain is synthesized .rst. We now \npresent the6templates. Throughout the description, we use i1 , i2 , i3 to denote inputs, and omain, oflag \nto denote the main and .ag outputs, respectively. To simplify the presentation, each template T is speci.ed \nas a relation over the coef.cients, inputs and output. In each case, the output is a (deterministic) \nfunction of the other parameters.  5.1 Templatesfor BW instruction instances We now describe the main \nand .ag templates for instruction in\u00adstances in theBWgroup, which is the simplest of all3groups. The \nmain and .ag outputs depend only on two inputs i1 ,i2 , which are both of the same size s. The main output \nomain is also always of size s. Main template. For all BW instructions, we guess that theith bit of the \nmain output is the result of a certain bit-wise operation per\u00adformed on the ith bits of the two inputs. \nSince there are at most 16 different bit-wise operations, i.e., 16 possible functions from 2-bit inputsto \n1-bit output,the search spaceis small.Foragiven size s, each of the 16 bit-wise operations can be expressed \nas functions in the theory of bit-vectors, which we denote by BW0 [s],..., BW15 [s]. Thus, we design \nthe main template such that its concretizations are exactly the set {BW0 [s],..., BW15 [s]} of functions. \nThe template -BWmain formula T(c,i1 ,i2 ,o)is formally de.ned as _ (c = a.omain = BWa[s](i1 ,i2 )) 0=a=15 \nIt has one coef.cient c which ranges over {0,..., 15}. When c = a, the template behaves as the concrete \nfunction BWa[s]. The coef.cient c can thus be viewed as a non-deterministic choice; once the value of \nc is .xed, the nondeterminism disappears. Note that we .rst guessed the above template from a super.\u00adcial \n(i.e., non detailed) reading of the Intel x86 spec. Later, the ap\u00adplication of the synthesis algorithms \ndiscussed in the previous sec\u00adtions, including their sampling stages, con.rmed in an automated way (see \nSections6and7) that the above templatewas indeed suf\u00ad.cient to abstract BW instructions. Flag template. \nWe now de.ne the .ag template using the circuit Cmain previously synthesized for the main output. From \nthe spec\u00adi.cation manual, we learn that the .ag output depends on the truth value of certain predicates \nover the inputs i1 ,i2 and the main out\u00adput omain = Cmain(i1 ,i2 ). We call each such predicate a factor. \nAnexample ofafactor is msb(i1 )=0which denotes that the most signi.cant bit of the .rst input i1 is 0. \nGiven all thefactors Fi:= F1 ,...,Fn, the .ag circuit is essen\u00adtially some functionfromthe truthvaluesof \nsomeofthefactorsto the set {0, 1}. Thus, we de.ne the .ag template such that its con\u00adcretizations are \nall the possible functions from the truth values of thefactors to the set {0, 1}.Ageneral de.nition of \nsuch a template for the .ag output oflag and coef.cients ic := c0 ,...,cN-1 , where 2ni N = , is given \nby the formula ENUM(ic,F,oflag), de.ned as (\u00acF1 .... .\u00acFn .oflag = c0 ) .(\u00acF1 .... .\u00acFn-1 .Fn .oflag \n= c1 ) .(\u00acF1 .... .Fn-1 .\u00acFn .oflag = c2 ) . ... .(F1 .... .Fn .oflag = cN-1 ) We now de.ne the factors \nFiBW := F1 ,...,F3 used in de.ning -BWflag the .ag template TforBW instructions. F1 := msb(Cmain(i1 ,i2 \n)) =1 F2 := Cmain(i1 ,i2 )=0 F3 := parity(Cmain(i1 ,i2 )) =1 Here msb and parity are the most-signi.cant-bit \nand parity oper\u00adators provided by the theory of bit-vectors. The template formula -BWflagi T(ic,i1 ,i2 \n) is formally de.ned as ENUM(ic,FBW,oflag) and makes use of 23 =8coef.cients ranging over {0,1}.  5.2 \nTemplatesfor ARI instruction instances We now describe the main and .ag templates for instruction in\u00adstances \nin the set ARI. The main and .ag outputs for these instruc\u00adtions only depend on the .rst two inputs i1 \n,i2 , which could be of different sizes, denoted by s1 ,s2 respectively. We use so for the size of the \nmain output. The .ag outputs of ARI instructions not only depend on the main outputbut also on an internally \ncomputed over.ow output, which gets discarded at the end of the computa\u00adtion.For instance, the carry \n.ag afterexecuting an ADD instruction isset whenevertheover.ow outputis strictly greaterthan zero.We \nuse oof to denote the over.ow output, whose size is also so. In order to de.ne the .ag template, we design \nour main tem\u00adplate such that for each concrete value of the coef.cients, we syn\u00adthesize two functions \nCmain and Cof for the main and over.ow outputs respectively. This is done by .rst extending the inputs \nto size smax := 2max(s1 ,s2 ,so)and then applying them to some arithmetic operation (depending on the \ncoef.cients), as discussed below. This generates an output of size smax, whose bits 0to so -1 are considered \nas the main output while bits so to 2so - 1 de.ne the over.ow output. Main template. All ARI instructions \nperform standard arithmetic operations: addition, subtraction, multiplication and division. How\u00adever, \nthey differ in whether the inputs are considered signed or un\u00ad -ARImain signed.We design the main template \nTsuch that its con\u00adcretizations cover all these possibilities. The template has 5 coef.cients denoted \nby ic := c0 ,...,c4 . Coef.cients c0 and c1 range over {1, 2, 3}and determine whether the inputs i1 , \ni2 respectively must be sign-extended (case 1), zero\u00adextended (case 2) or replaced with a constant (case \n3). The con\u00adstants used for the third case are the values of the coef.cients c2 max and c3 , which both \nrange over {0,..., 2s-1}. The extended value of inputs i1 ,i2 are given by the expressions iext 12 de.ned \n,iext as iext 1 := ITE(c0 =1, zExt(i1 ,smax), ITE(c0 =2, sExt(i1 ,smax),c2 )) iext := ITE(c1 =1, zExt(i2 \n,smax), ITE(c1 =2, sExt(i2 ,smax),c3 )) Here ITE, zExt and sExt are, respectively, the if-then-else, \nzero\u00adextend and sign-extend operators provided by the theory of bit\u00advectors. Coef.cient c4 ranges over \n{1,..., 7}and determines the arith\u00admetic operation that must be applied to the two inputs. The op\u00aderations \nprovided by the theory of bit-vectors are: addition bvadd (case 1), subtraction bvsub (case 2), multiplication \nbvmul (case 3), unsigned division bvudiv (case 4), unsigned remainder bvurem (case 5), signed division \nbvsdiv (case 6), and signed remainder bvsrem (case 7).For convenience, we write ARI1 ,..., ARI7 to re\u00adfer \nto these operations. If c4 = k, then operation ARIk is applied to the extended inputs, and bits 0 to \nso -1 of the output are con\u00adsidered as the main output of the instance. Thus, in summary, the 2 -ARImain(i \ntemplate Tc,i1 ,i2 ,omain)is de.ned as _ ext ext c4 = a . omain = ARIa(i1 ,i2 )[0,so -1] 1=a=7 Once the \ncoef.cients ic for the main template have been synthe\u00adsized, we de.ne the function for the over.ow output \nas ext ext Cof (i1 ,i2 ):= ARIa(i1 ,i2 )[so, 2so -1] ,iext by instantiating the concrete values of the \ncoef.cients c0 ,...,c3 .xed in ic. Flag template. As mentioned earlier, the .ag template is built upon \nthe circuits Cmain and Cof for the main and over.ow output -BWflag Here ais the value of coef.cient c4 \nin ic, and iext 12 are obtained respectively. Like T, the .ag outputs for ARI instructions also depend \non the truth value of certain factors de.ned over the inputs i1 ,i2 , the main output omain = Cmain(i1 \n,i2 )and over.ow output oof = Cof (i1 ,i2 ). We therefore make use of the construc\u00ad  i tion ENUM(ic,F,oflag)de.ned \nfor .ag output of BW instructions. Thefactors FiARI := F1 ,...,F7 used in de.ning the .ag template -ARIflag \nTfor ARI instructions are de.ned as follows: F1 := msb(i1 )=1 F2 := msb(i2 )=1 F3 := msb(Cmain(i1 ,i2 \n)) =1 F4 := parity(Cmain(i1 ,i2 )) =1 F5 := Cmain(i1 ,i2 )=0 F6 := Cof (i1 ,i2 )=0 2so F7 := Cof (i1 \n,i2 )= -1 -ARIflag The template T(ic,i1 ,i2 )is formally de.ned as i ENUM(ic, FARI,oflag) and makes use \nof 27 = 128 coef.cients ranging over {0, 1}.  5.3 Templatesfor BS instruction instances We now describe \nthe main and .ag templates for BS instructions. The main and .ag outputs for these instructions depend \non all three inputs i1 ,i2 ,i3 . While describing BS instructions we will call the inputs i1 ,i2 as the \nshift inputs and i3 as the count input. The size of the shift inputs and the main outputs is the same \nand is denoted by s. The size of the count input is always8 bits. Main template. From the speci.cation \nmanual, we learn that the execution of all BS instruction instances share the following common properties. \nFirst, the count input is always used after bit-masking to the lower 5 bits (equivalent to a modulo(%) \n32 operation). Second, for a .xed value of the count input, each bit of themain outputis either.xedto0 \nor1,orisa speci.cbitofoneof the two shift inputs.We use these two properties to design the main -BSmain \ntemplate T. The main idea is to case split on the count input i3 bit-masked to the lower 5 bits and then, \nfor each value a .{0,..., 31}, use coef.cients ica := ca,0 ,...,ca,s-1 , each ranging over {0,..., 2s \n+1}, to determine the mapping between each of the s bitsofthe outputandthebitsofthe shift inputs.Fora \n.xed value aof the (bit-masked) count input, the mapping is given by the relation Pa(ica,i1 ,i2 ,om)de.ned \nbelow 89 > . (0 = ca,\u00df = s -1 . om[\u00df]= i1 [ca,\u00df ]) > <=_ . (s = ca,\u00df = 2s -1 . om[\u00df]= i2 [ca,\u00df -s]) > \n. (ca,\u00df =2s . om[\u00df]=0) > :; 0=\u00df=s-1 . (ca,\u00df =2s +1 . om[\u00df]=1) -BSmain(i Template Tc,i1 ,i2 ,i3 ,om)is \nformally de.ned as _ i3 %32 = a . Pa(ica,i1 ,i2 ,om) 0=a=31 It uses 32s coef.cients, each ranging over \n{0,..., 2s +1}. Flag template. We now de.ne the .ag template using the circuit Cmain for the main output. \nFrom the speci.cation manual, we learn that all the BS instructions set the .ag output in a similar way: \nfor a .xed count input value, the .ag output is either a speci.c bit of one of the shift inputs, or is \nset based on the parity or zero\u00adness of the main output, or the xor of the most-signi.cant bits of the \n.rst shift input and the main output, or is one of the constants -BSflag 0 or 1. Thus we de.ne the .ag \ntemplate Tsuch that its concretizations cover all the above cases. For a .xed valueaof the (bit-masked) \ncount input, the template uses a coef.cient ca ranging over {0,..., 2s +4}, to de.ne the mapping between \nthe shift inputs i1 ,i2 and the .ag output oflag. This mapping is given by the relation Paflag (ca,i1 \n,i2 ,oflag)de\u00ad.ned as 0 = ca = s -1 . oflag = i1 [ca] .s = ca = 2s -1 . oflag = i2 [ca] .ca =2s . (oflag \n=1 . Cmain(i1 ,i2 )=0) .ca =2s +1 . (oflag =1 . parity(Cmain(i1 ,i2 )) =1) .ca =2s +2 . (oflag =1 . (msb(i1 \n).msb(Cmain(i1 ,i2 ))) .ca =2s +3 . oflag =0 .ca =2s +4 . oflag =1 -BSflag The template formula T(ic,i1 \n,i2 ,i3 ,oflag)is formally de\u00ad.ned as _ i3 %32 = a . Paflag (ca,i1 ,i2 ,oflag) 0=a=31 Altogether, the \ntemplate uses 32 coef.cients ic := c0 ,...,c31 , ranging over {0,..., 2s +4}.  5.4 Smart Inputs and \nSummary We presented 6 templates(3 for main outputs and 3 for .ag out\u00adputs) which abstract the semantics \nof a large number of x86 ALU instructions.In this section,we discuss somekeypropertiesof these templates. \nWe start by discussing universally smart input sets, fol\u00adlowed by a summary of the search space (size \nof the concretization set) and the circuit size (size of the circuits generated) for each tem\u00adplate. \nSmart inputs. We now present universally smart inputs for the -BWmain -BSmain main templates Tand T, \nand smart inputs for -ARImain the main template Tand a large subset of ARI instruc\u00adtions. Those input \nsets were inferred manually from the structure of the corresponding template. As will be discussed in \nthe next two sections,experiments with the procedure DInputVal show that this procedure performs reasonably \nwell on all the .ag templates, even for instructions with large (32 bits) input sizes, because of the \nstructural simplicity (DNF formulas with few disjuncts) of the .ag templates; therefore, we do not discuss \nsmart inputs for those. In contrast, the procedure DInputVal has the worst performance -BSmain on the \nTtemplate, for which the use of smart inputs is much more important. As an illustration, we explain the \nmethodol\u00adogy used for arriving at a (single!) universally smart input for the -BWmain template T. The \nmethodology for the other templates is similar. As discussed in Section 5.1, the concretizations of the \ntem\u00ad -BWmain plate Tare all the 16 possible bit-wise operations BWi, which each take two bits as inputs \nand return one bit as out\u00adput. How many inputs are needed to uniquely identify any of those 16 BWi functions? \nThe answer is 4 provided the 4 inputs cover all four possible combinations of 0 and 1, namely is the \nset {(0, 0), (0, 1), (1, 0),(1, 1)}. Therefore, if a single pair of (bit\u00ad -BWmain vector) inputs i1 ,i2 \n, each of size s, for the template Tcovers these4 boolean combinations, this single input pair (i1 ,i2 \n) is universally smart for the template.Asuf.cient condition for .nd\u00ading such an input pair is that there \nexist bit indices k1 ,k2 ,k3 ,k4 such that the set of bit pairs {(i1 [k1 ],i2 [k1 ]),..., (i1 [k4 ],i2 \n[k4 ])} is equal to the set {(0, 0), (0, 1),(1, 0), (1, 1)}. A pair of inputs that satis.es the above \ncondition is i1 = 12,i2 = 10. Indeed, the bit-vector representations of these decimal numbers are i1 \n=12 = 0... 01100, i2 = 10 =0... 01010, for any input size s> 4. Clearly the condition above is satis.ed \nby the bit indices 0,..., 3. Thus, the input set IBW := {(10, 12)}is universally smart for the -BWmain \ntemplate T. We now give a set of universally smart inputs for the template -BSmain T. For brevity, we \nonly give the input set IBS8 for the template instantiated with size 8 bits. Recall from Section 5.3 \nthat BS instructions take3 inputs and therefore the set IBS8 isa setof Figure 4. Templates summary  \n triples (i1 ,i2 ,i3 ). It is de.ned as follows: {(255, 0,a)|0 = a = 31} .{(1, 1,a)|0 = a = 31} .{(170, \n170,a)|0 = a = 31} .{(204, 204,a)|0 = a = 31} .{(240, 240,a)|0 = a = 31} The total number of inputs in \nthe set IBS8 is 32 \u00d7 5 = 160. In general for size parameter s, we de.ne a universally smart set of inputs \nof size 32 \u00d7 (log(s)+ 2). -ARImain For the template T, we de.ne a set IARI of inputs which is smart for \na large subset of ARIinstructions. The set IARI is de.ned as {(17, 5), (200, 59), (170, -59)} -ARImain \nThis set is not universally smart for the template Tbe\u00adcause the set was designed for an earlier version \nof the template which did not use the operations bvsdiv and bvsrem, which since then have been added \nand are currently handled by the values 6 and 7of coef.cient c4 . The earlier template was extended so \nthat it could cover the main output of the instruction IDIV and a few other instructions. For the current \ntemplate, we veri.ed by running the smart inputs check (De.nition 2) that the set IARI is still smart \nfor the current template and all ARI instructions except IDIV, DIV,CWD, CWDE, CDQ. In practice, as validated \nby our experiments, the set IARI is a good initial set for seeding the DInputVal procedure for those \nremaining instructions, and suf.cient for our purposes (see Section 7). We also performed preliminary \nexperiments to automatically generate sets of universally smart inputs. For instance, the set IARI can \nbe augmented to a universally smart input set using the greedy approach described in Section 4: in the \n8-bit case, this results in a (not necessarily minimal) set of 10 universally smart inputs obtained in8 \nsecs. In contrast, generating universally smart input sets with the brute-force approach (see Section \n4) is much more computationally expensive. This topic should be investigated further in future work (see \nalso the discussion in Section 8 on related work in machine learning). Template summary. In Figure 4, \nwe present a summary of the Search space and Circuit size for all the templates. The values for each \nof these properties are expressed as functions of the size s. -BWmain For the main template T, the size \nof the search space is 16, which is the number of possible bit-wise operations, and the circuits generated \nare always of constant size as they are just -BWflag one of the bit-wise operations. The .ag template \nThas a search space of size 28 , which is the number of functions from 3 bits (from the 3 factors) to \n1 bit. The circuits generated are again of constant size, in particular equal to the size of the formula \n-ARImain i ENUM(ic, FBW,oflag). The main template Thas a search space of size 21 \u00d7 22s, the 22s factor \ncomes from the third and fourth coef.cients which vary over {0,..., 2s - 1}. The circuits -ARIflag generated \nare of constant size. The .ag template Thas a search space of 28 , which is the number of functions from \n7 Instr nsyn S-Iters Time (ms) AND8 10 1 26,808 AND8 102 1 26,478 AND8 103 1 26,692 MUL8 10 1 32,462 \nMUL8 102 1 33,581 MUL8 103 1 40,730 SHL8 10 41 1,171,060 SHL8 102 18 542,963 SHL8 103 1 181,857 Figure \n5. Synthesis using Procedure ExhaustVal bits (from the 7 factors) to 1 bit, and the circuits generated \nare -BSmain again of constant size. The main template Thas a search space of size (2s+2)32s, since it \nhas 32s coef.cients ranging over {0,..., 2s +1}. The circuits generated are of size O(s)as each bit of \nthe output is described individually using a separate circuit. -BSflag The .ag template Thas a search \nspace of size (2s + 5)32 , as there are 32 coef.cients ranging over {0,..., 2s +4}, and the circuits \ngenerated are of constant size. 6. Experimental Results We report results of experiments performed with \nthe synthesis algorithms and templates presented in the previous sections. All experiments were performed \non a x86 HP xw4400 PC with a 32-bit 2.4GHz IntelCore2 processor, 2Gb of RAM and runningWindows Vista. \nWe used the Z3 [3] SMT solver for implementing all the synthesis algorithms. We present results of detailed \nexperiments for 3 instructions, each covered by a different synthesis template: AND with template -BWmain \n-ARImain T, MUL with template T, and SHL with template -BSmain T. For each instruction, we consider their \n8-bit, 16-bit and 32-bit versions to measure the impact of I/O sizes. In all the followingexperiments, \nthe maximum numberoffailedveri.cation samples (i.e., |Sfail|in Figure 1) is set to 10: when 10 samples \nhave failed to be veri.ed, the veri.cation stage stops and those samples are fed back to the synthesis \nstage. Figure5presents results obtained using the synthesis algorithm ExhaustVal and for various synthesis \nsample set sizes nsyn as de.ned in Figure 1. The exhaustive veri.cation part of Procedure ExhaustVal \ndoes not scale to the 16-bit and 32-bit versions of those instructions (which each take two inputs of \nthat size), so no results are presented for those cases. The number S-Iters of synthesis iterations is \ngiven in the third column. The overall time (in msecs) required to synthesize a veri.ed circuit is given \nin the last column. The best runtime for an instruction is highlighted in boldface. For MUL8, the best \nruntime is obtained with nsyn = 10 as 10 random synthesis samples are suf.cient to identify the correct \ncircuit, so more samples are not necessary.For SHL8, starting with 10 or 100 random synthesis samples \nrequires several expensive synthesis iterations, while nsyn = 103 converges faster to the correct circuit. \nFor AND8, all the runtimes are very close, and the differences are insigni.cant with respect to the overall \nruntime. Figure6presents results obtained with the Procedure DInputVal of Section 3.3, for various numbers \nof synthesis samples nsyn andveri.cation samples nver . The number of distinguishing-input checks is \ngiven under the column D-Iters. The best overall time for anygiven instruction is again highlighted in \nboldface. For AND and MUL, a small set of 10 random synthesis sam\u00adples is suf.cient to synthesize the \ncorrect circuit in one iteration (S-Iters=1) with a single passing distinguishing-input check(D\u00ad  SHL8 \nSHL8 10 10 10103 14 16 4 3 82,184 62,569  SHL32 103 104 1 1 4,707,855 SHL32 104 102 - - OOM SHL32 104 \n103 - - OOM SHL32 104 104 - - OOM  Figure 6. Synthesis using ProcedureDInputVal Iters=1), and thefastest \nruntimeis achieved with thefewestveri.\u00adcation samples(nver = 102 ). Note that for MUL16 and MUL32 with \nnsyn = 103 , the synthesis algorithm runs out of memory (denoted by OOM ) and is unable to generate a \ncircuit. For SHL, the best times are achieved with nsyn = 103 and the smallest numberofveri.cation samples(nver \n= 100)we consider. For smaller numbers of synthesis samples, the DInputVal synthe\u00adsis algorithm requires \nseveral synthesis stages and sometimes feed\u00adback from several distinguishing-input checks, which are \nexpensive and increase overall runtime. (As an extreme example not shown in the .gure, with nsyn =0 and \nnver = 100, the DInputVal algo\u00adrithm times out after 12h for SHL32.)Witha larger setof synthesis samples(nsyn \n= 104 ), the DInputVal algorithm takes more time, or runs out of memory in the SHL32 case. Figure 7 presents \nin its last column the runtimes obtained with the smart sampling synthesis algorithm SmartVal of Section \n4. These results are compared to the best times obtained with the two other algorithms as reported in \nFigures 5 and 6. The speed-up obtained by an algorithm compared to the one to the immediate left is indicated \nby the symbol \u00f7. In our experiments, the SmartVal algorithm is between 11 to 68 times faster than the \nbest time obtained with the DInputVal algorithm, which is itself between9 to 551 timesfaster than the \nExhaustVal algorithm when the latter is applicable (i.e., in the 8-bit case only). 7. Overall Results, \nLessons Learned, Limitations Using the 6 templates presented in Section 4 and their associated smart \ninputs, we can automatically synthesize bit-vector circuits for 534 x86 instruction instances (8/16/32-bits, \noutputs, EFLAGS) in less than two hours on the regular machine described in the previous section (2Gb \nof RAM, 2.4GHz processor). We used the SmartVal algorithm whenever possible, i.e., whenever a set of \nuniversally smart inputs is available, and used the DInputVal Figure 7. Synthesis using Procedure SmartVal: \nruntime (in msecs) and comparison Instr Exhaust DInput Smart Sampl AND8 26,478 48 (\u00f7551) 3 (\u00f716) AND16 \n- 55 4 (\u00f714) AND32 - 71 4 (\u00f718) MUL8 32,462 189 (\u00f7172) 17 (\u00f711) MUL16 - 609 20 (\u00f730) MUL32 - 1,997 29 \n(\u00f768) SHL8 181,857 21,501 (\u00f79) 867 (\u00f725) SHL16 - 250,105 8,064 (\u00f731) SHL32 - 4,382,472 303,970 (\u00f714) \n algorithm otherwise (e.g., for all EFLAGcircuits) still seeded with the smart inputs de.ned for that \ninstructionfamily.We also useda veri.cation stage with 1000 random veri.cation samples for each circuit. \nInstructions covered include SHL, SHR, SAR, SAL, SHLD, SHRD, ROL, ROR, RCL, RCR, BT, BTR, BTS, BSWAP, \nAND, OR, XOR, TEST, NOT, NEG, XADD, ADD, SUB, INC, DEC, MUL, IMUL, DIV, IDIV, CWD, CWDE, CDQ, CBW, MOVZX, \nMOVSX, CMPXCHG. During the course of this work, we discovered several interest\u00ading and sometimes surprising \ndetails about the semantics of x86 instructions. The Intel x86 reference manual often de.nes the semantics \nof x86 instructions partially, leaving some corner cases unde.ned . In contrast, our automatic synthesis \napproach gives a precise se\u00admantics to all x86 instructions on the processor which is sampled, uncovering \nsometimes seemingly bizarre behaviors. As an exam\u00adple, the Intel speci.cation says that the carry .ag \nCF is unde.ned after a ROR8 instructionwhenthe countargument modulo8is0;on an Intel XEON3.7 processor, \nthe CF .ag is actually set to 0 when the count argument is 0, and to 1 when the count argument is 16, \n24 or 32. As another example, the Intel spec says that the OF .ag of an ADD instruction is set according \nto the result (i.e., the output); however, on an Intel XEON3.7 processor, the OF .agis1only when the \nXOR of the most-signi.cant bit of the two inputs is the negation of the most-signi.cant bit of the output. \n We also discovered cases where observed behaviors contradicts the x86 reference manual (which is unsurprising \ngiven the size and complexity of the spec).For instance, we discovered while debug\u00ad -ARImain ging our \ntemplate Tthat the over.ow OF .ag should be set to0 afterexecuting IMUL8 with 65 and 254 as inputs according \nto the Intel spec, while the OF .ag is actually set to 1 after the ex\u00adecution of this instruction with \nthose inputs on an Intel XEON3.7 processor. Moreover, we discovered that the semantics of instructions \nvaries across Intel processors. For instance, on an Intel XEON3.7 or Core2 or i7 M620 processors and \nin accordance with the x86 spec, executing instructions ROL, SHL or SHR does not set the over.ow OF .ag \nif the count argument is not 1. However, on an In\u00adtel i7-2620M processor (HP EliteBook 2760p, 2.7Ghz, \n8Gb RAM, 64-bit) processor, the OF .agis setto1 even for certain cases when -BSflag the count argument \nis greater than 1. Our template Tis actually unable to capture this behavior, which is why we detected \nthese corner cases. Finally, and unsurprisingly, we also discovered several errors in previous manually-written \nx86 instruction handlers used in the whitebox fuzzer SAGE [6]. Our current implementation has several \nlimitations. First, in\u00adstructions like DIV crash (trigger an error) on certain inputs, for instance when \nthe quotient is larger than the output range. Cur\u00adrently, we use manually-written input preconditions \nto prevent such cases from occurring during synthesis. Such preconditions should be usedas active checkers \n[5] during symbolicexecutionto check whether those error cases can be triggered during program analy\u00adsis. \nIn the future, those preconditions could be synthesized auto\u00admatically by generating a special additional \nERROR output. Second, instructions like SHL leave the .ags ZF, PF and SF unchanged when the count operand \nis 0, therefore those .ags should also be considered as inputs in those cases. This is not currently \nhandled -BSflag by our template T. 8. Other RelatedWork Synthesizing transfer functions for embedded \nprocessors. The closest work to our work is [19] which presents a system for auto\u00admatically synthesizing \ntransfer functions for embedded processor instructions, which can be used for static analysis of embedded \nob\u00adject code. This prior work synthesizes transfer functions in a given abstract domain (like intervals \nor bit-wise domain) and therefore performs a sound over-approximation of the concrete semantics. In contrast, \nour goal is to automatically synthesize a bit-precise sym\u00adbolic representation of the concrete semantics. \nThe approach used in [19] involves building a complete truth table by exhaustively sampling the processor, \nlifting the table to the abstract domain and then encoding it using BDDs. Due to the exhaustive sampling, \nthis approach does not scale beyond 8-bit instructions. Moreover, the BDD encodings are often too large \n(several Kbs) to satisfy our con\u00adciseness requirement, which is imperative in our context to allow for \nbit-precise symbolicexecutionof long programexecution traces as is needed for whitebox fuzzing [6]. In \nfollow-up work, [18] de\u00advelops another technique that assumes a structural constraint on the function \nbeing synthesized (analogous to template-based syn\u00adthesis) and scales to larger instructions. However, \nthe synthesized functions are again for certain abstract domains. Another differ\u00adence with our work is \nthat [18] generates abstract transfer functions using a simple custom brute-force solver, whereas we \nencode our templates as logic formulas in the theory of bit-vectors and carry out the search using an \nSMT solver. Connection to machine learning. There is a close connection be\u00adtween the notion of universally \nsmart inputs for a template and the notion of teaching dimension for a concept class [7]. Informally, \nthe teaching dimension of a concept class (consisting of classi.ers) is the minimum number of samples \nthat a teacher must reveal in order to uniquely identify any concept in the class. The paper [7] investigates \nupper and lower bounds on the teaching dimension and its relation to structural properties of a concept \nclass. Function tem\u00adplates can essentially be thought of as concept classes (concepts being the functions \nrepresented as relations over inputs and out\u00adputs). These results on teaching dimension shed light on \nthe con\u00adnection between templates and the set of universally smart inputs, and on the complexity of automatically \nsynthesizing the smallest set of universally smart inputs. Another interesting (and related) connection \nthat we plan to explore further in the future is that be\u00adtween the descriptive complexity [11] of a template \nand the size of the smallest set of universally smart inputs. Template-based synthesis. In the last few \nyears, there has been a large amount of work on automated synthesis using deductive techniques.Acentral \nthemeofall these techniquesistoexpressthe synthesis problem as a search problem over a restricted space. \nThe restricted space is de.ned either using a template [24, 25], or using asketch[21,22],orusingasetofbuilding \nblocks[9,13],orusing a restricted language [8, 12]. The synthesis techniques used in this paper are inspired \nfrom andbuild upon this priorwork. The unique challenges associated with our speci.c application domain \nwere the lack of an initial speci.cation and the lack of a .nal veri.cation oracle. Black-box analysis \nof processors/assemblers. Another area of recent related work is work on designing and testing CPU emula\u00adtors \n[14 16], especially for x86 processors. The goal of this work is to test whether an emulator faithfully \nmimics all aspects of the processor, including various addressing modes, privilege levels and clock cycles \nper instruction. [14] uses the architecture speci.ca\u00adtion as the starting point for determining what \ninstruction operand combinations are valid, and then intelligently modifying and test\u00ading each combination \nwith various possible edge case values. On the other hand, [15] uses the CPU as the oracle to determine \nwhat byte sequences represent valid instructions and how instructions are encoded. The valid byte sequences \nare then run with various mem\u00adory and register states. In the same spirit, [10] presents a technique \nfor testing and reverse engineering assemblers for a given architec\u00adture, by testing them with permutations \nof assembly code and then decoding the output. The main relation with our work is the idea of analyzing \na black-box system by strategically testing its inter\u00adface and then inferring internal properties of \nthe system from the outputs. 9. Conclusion We showed that automatic synthesis of precise and concise \nsym\u00adbolic representations of individual processor instructions is possi\u00adble for a complex processor like \nx86. The main practical advan\u00adtage of automatic synthesis is the gain in manual labor: instead of de.ning \nmanually (probably incomplete and incorrect) detailed in\u00adstruction handlers for 534 x86 ALU instruction \ninstances, synthe\u00adsis allowed us to de.ne only 6 abstract instruction handlers (tem\u00adplates), from which \n534 correct and precise instruction handlers were generated automatically, from input/output examples \nand ex\u00adpressed concisely as bit-vector constraints.  In this work, we focused on ALU instructions since \nthose are used in virtually all programs. When symbolically executing a pro\u00adgram, each instruction is \nexecuted symbolically using the corre\u00adsponding symbolic instruction handler. Sequences of instructions \nare handled by combining the symbolic encodings (circuits) of in\u00addividual instructions. Conditional statements \n(jumps) are handled using the .ag circuits. For instance, a jz <addr> jump instruc\u00adtion is simply mapped \nto a constraint ZF == 1 where ZF is the zero-.ag circuit synthesized for the instruction immediately \nprior to the jump insturction. The circuit for regular memory operations such as ld (load), mov (move), \netc. is simply the identity function. Handling all those operations (ALU, conditional jumps and regular \nmemory operations) is already useful for (partial) symbolic execu\u00adtion of manyapplications, like whitebox \nfuzzing of .le and packet parsers [6]. We believe our templates could be extended to cover x86 SIMD instructions, \nsince they are essentially ALU instructions applied to vectors of registers. In contrast, extending our \napproach to .oating\u00adpoint instructions seems more challenging since most SMT solvers do not currently \nhandle .oating-point arithmetic. Fortunately, for the purpose of whitebox fuzzing, precise symbolic execution \nof .oating-point instructions can often be avoided [4]. It would be interesting to design instruction \ntemplates for other processors such as x64 or ARM. Our general synthesis-based ap\u00adproach should be applicable \nto those processors as well,but details of the templates for those could be signi.cantly different. Acknowledgments \nWe thank David Molnar for suggesting the problem addressed in this work, Sumit Gulwani for helpful comments \non program syn\u00adthesis, and Ella Bounimova for interesting discussions on x86 se\u00admantics.We also thank \nthe anonymous reviewers for their construc\u00adtive comments to improve the presentation. References [1] \nD. Brumley, I. Jager, Th. Avgerinos, and E. J. Schwartz. BAP: A Binary Analysis Platform. In CAV 2011,July \n2011. [2] A. Chlipala. Modular Development of Certi.ed Program Veri.ers with a Proof Assistant. In ICFP \n2006, September 2006. [3] L. de Moura and N. Bjorner. Z3: An Ef.cient SMT Solver. In TACAS 2008, April \n2008. [4] P. Godefroid andJ. Kinder. Proving Memory Safety of Floating-Point Computations by Combining \nStatic and Dynamic Program Analysis. In ISSTA 2010,July 2010. [5] P. Godefroid, M.Y. Levin, and D. Molnar. \nActive Property Checking. In EMSOFT 2008, October 2008. [6] P. Godefroid, M.Y. Levin, and D. Molnar. \nAutomated Whitebox Fuzz Testing. In NDSS 2008, February 2008. [7] S. A. Goldman and M. J. Kearns. On \nthe Complexity of Teaching. Journal of Computer and System Sciences, 50:303 314, 1992. [8] S. Gulwani. \nAutomating String Processing in Spreadsheets using Input-Output Examples. In POPL 2011,January 2011. \n[9] S. Gulwani,V. A.Korthikanti, and A.Tiwari. Synthesizing Geometry Constructions. In PLDI 2011, May \n2011. [10] W. C. Hsieh, D. R. Engler, and G. Back. Reverse-Engineering Instruc\u00adtion Encodings. In USENIX \n2001,June 2001. [11] N. Immerman. Descriptive complexity. Springer, 1999. [12] S. Itzhaky, S. Gulwani, \nN. Immerman, and M. Sagiv. ASimple Induc\u00adtive Synthesis Methodology and its Applications. In OOPSLA 2010, \nOctober 2010. [13] S. Jha, S. Gulwani, S. A. Seshia, and A. Tiwari. Oracle-Guided Component-Based Program \nSynthesis. In ICSE 2010, May 2010. [14] W. Ma, A.Forin, andJ. Liu. Rapid Prototyping and CompactTesting \nof CPU Emulators. In Proceedings of the 21st IEEE International Symposium on Rapid System Prototyping,June \n2010. [15] L. Martignoni, R. Paleari, G. Fresi Roglia, and D. Bruschi. Testing CPU Emulators. In ISSTA \n2009,July 2009. [16] L. Martignoni, R. Paleari, G. Fresi Roglia, and D. Bruschi. Testing SystemVirtual \nMachines. In ISSTA 2010,July 2010. [17] D. Molnar, X. C. Li, and D. Wagner. Dynamic Test Generation To \nFind Integer Bugs in x86 Binary Linux Programs. In Proc. of the 18th Usenix Security Symposium, August \n2009. [18] J. Regehr and U. Duongsaa. Deriving AbstractTransfer Functions for Analyzing Embedded Software. \nIn LCTES 2006, 2006. [19] J. Regehr and A. Reid. HOIST:A System for Automatically Deriving Static Analyzers \nfor Embedded Systems. In ASPLOS 2004, 2004. [20] S. Sarkar, P. Sewell, F. Zappa Nardelli, S. Owens, T. \nRidge, Th. Braibant, M. O. Myreen, and J. Aglave. The Semantics of x86-CC Multiprocessor Machine Code. \nIn POPL 2009,January 2009. [21] A. Solar-Lezama, R. M. Rabbah, R. Bod\u00b4ik, and K. Ebcioglu. Program\u00adming \nby Sketching for Bit-Streaming Programs. In PLDI 2005, May 2005. [22] A. Solar-Lezama, L. Tancau, R. \nBod\u00b4ik, S. A. Seshia, and V. A. Saraswat. Combinatorial Sketching for Finite Programs. In ASP\u00adLOS 2006, \n2006. [23] D. Song, D. Brumley, H. Yin, J. Caballero, I. Jager, M. G. Kang, Z. Liang,J.Newsome,P. Poosankam, \nandP. Saxena. BitBlaze:ANew Approach to Computer Security via Binary Analysis. In ICISS 2008, December \n2008. [24] A. Taly, S. Gulwani, and A. Tiwari. Synthesizing Switching Logic Using Constraint Solving. \nIn VMCAI 2009,January 2009. [25] A.Taly andA.Tiwari. Switching Logic Synthesis for Reachability. In EMSOFT \n2010, October 2010.   \n\t\t\t", "proc_id": "2254064", "abstract": "<p>Symbolic execution is a key component of precise binary program analysis tools. We discuss how to automatically boot-strap the construction of a symbolic execution engine for a processor instruction set such as x86, x64 or ARM. We show how to automatically synthesize symbolic representations of individual processor instructions from input/output examples and express them as bit-vector constraints. We present and compare various synthesis algorithms and instruction sampling strategies. We introduce a new synthesis algorithm based on <i>smart sampling</i> which we show is one to two orders of magnitude faster than previous synthesis algorithms in our context. With this new algorithm, we can automatically synthesize bit-vector circuits for over 500 x86 instructions (8/16/32-bits, outputs, EFLAGS) using only 6 synthesis templates and in less than two hours using the Z3 SMT solver on a regular machine. During this work, we also discovered several inconsistencies across x86 processors, errors in the x86 Intel spec, and several bugs in previous manually-written x86 instruction handlers.</p>", "authors": [{"name": "Patrice Godefroid", "author_profile_id": "81100504535", "affiliation": "Microsoft Research, Redmond, WA, USA", "person_id": "P3471293", "email_address": "pg@microsoft.com", "orcid_id": ""}, {"name": "Ankur Taly", "author_profile_id": "81388601002", "affiliation": "Stanford University, Stanford, CA, USA", "person_id": "P3471294", "email_address": "ataly@stanford.edu", "orcid_id": ""}], "doi_number": "10.1145/2254064.2254116", "year": "2012", "article_id": "2254116", "conference": "PLDI", "title": "Automated synthesis of symbolic instruction encodings from I/O samples", "url": "http://dl.acm.org/citation.cfm?id=2254116"}