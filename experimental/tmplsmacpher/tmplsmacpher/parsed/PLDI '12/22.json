{"article_publication_date": "06-11-2012", "fulltext": "\n Race Detection for Web Applications Boris Petrov Martin Vechev Manu Sridharan Julian Dolby So.a University \nETH Z\u00a8urich IBM T.J. Watson Research Center boris.petrov.petrov@gmail.com martin.vechev@inf.ethz.ch {msridhar,dolby}@us.ibm.com \n Abstract Modern web pages are becoming increasingly full-featured, and this additional functionality \noften requires greater use of asyn\u00adchrony. Unfortunately, this asynchrony can trigger unexpected con\u00adcurrency \nerrors, even though web page scripts are executed sequen\u00adtially. We present the .rst formulation of a \nhappens-before relation for common web platform features. Developing this relation was a non-trivial \ntask, due to complex feature interactions and browser differences. We also present a logical memory access \nmodel for web applications that abstracts away browser implementation de\u00adtails. Based on the above, we \nimplemented WEBRACER, the .rst dy\u00adnamic race detector for web applications. WEBRACER is imple\u00admented \natop the production-quality WebKit engine, enabling test\u00ading of full-featured web sites. WEBRACER can \nalso simulate cer\u00adtain user actions, exposing more races. We evaluated WEBRACER by testing a large set \nof Fortune 100 company web sites. We discovered many harmful races, and also gained insights into how \ndevelopers handle asynchrony in practice. Categories and Subject Descriptors D.2.4 [Software Engineer\u00ading]: \nSoftware/Program Veri.cation Reliability; D.2.5 [Soft\u00adware Engineering]: Testing and Debugging Monitors,Testing \ntools; F.3.1 [Logics and Meanings of Programs]: Specifying and Verifying and Reasoning about Programs \nKeywords concurrency, asynchrony, web, race detection, non\u00addeterminism 1. Introduction Modern web pages \nare increasingly becoming full-featured web applications, with rich user interfaces and signi.cant client-side \ncode and state. The web platform has signi.cant advantages for application development, including quick \ndeployment of updates, easier portability across desktops and mobile devices, and seamless client-server \nintegration. Due to the increasing popularity and complexity of web appli\u00adcations, there is a growing \nneed for programming tools and reason\u00ading techniques that match those for more mature platforms. This \npaper presents techniques to help developers make safer use of asynchronous constructs in the web platform. \nWeb applications are Permission to make digital or hard copies of all or part of this work for personal \nor classroom use is granted without fee provided that copies are not made or distributed for pro.t or \ncommercial advantage and that copies bear this notice and the full citation on the .rst page. To copy \notherwise, to republish, to post on servers or to redistribute to lists, requires prior speci.c permission \nand/or a fee. PLDI 12, June 11 16, 2012, Beijing, China. Copyright c &#38;#169; 2012 ACM 978-1-4503-1205-9/12/06. \n. . $10.00 making greater use of these constructs as their functionality be\u00adcomes richer. For example, \nuser interactions and completion of cer\u00adtain network requests can be processed in an asynchronous, event\u00addriven \nstyle. Also, sites are making increasing use of delayed or asynchronous loading of JavaScript code itself, \nto speed initial page rendering and increase perceived responsiveness [24]. Use of asynchrony can lead \nto serious concurrency errors in web applications. Since the JavaScript code in web pages runs sequen\u00adtially, \nthere is less awareness of these concurrency errors than for languages like Java that have shared-memory \nmulti-threading. Nev\u00adertheless, such errors can arise, due to non-determinism in event dispatch, network \nbandwidth, CPU speed, etc. (we give concrete examples in Section 2). Such errors have caused serious \nbugs in real-world web ap\u00adplications. Developers at Mozilla noticed that many of the non\u00addeterministic \nfailures in their regression test suite were due to race conditions in the unit test inputs [20], leading \nto documentation on how to avoid such problems [19]. The Hotmail email service was broken in the Firefox \nweb browser for some time due to a race, with the bug causing a loss of message content.1 Race conditions \nlead\u00ading to data loss have been discovered in this paper and have also been reported in previous work \n[25]. To clarify the behavior of asynchrony in web applications, we present the .rst formulation of a \nhappens-before relation [16] for the most commonly-used JavaScript and HTML features. While various types \nof web-application concurrency errors have been dis\u00adcussed previously [15, 19, 24, 25], we are unaware \nof any discus\u00adsion that formulates these issues over a common model. Further\u00admore, while there are ongoing \nefforts to specify the web platform more carefully [10], de.ning a useful happens-before relation is \nstill non-trivial, due to complex interactions between JavaScript and standard HTML features and browser \ndeviations from the spec\u00adi.cation. The happens-before relation presented here was devel\u00adoped based on \nan in-depth study of relevant speci.cations, browser behaviors, and how constructs are used in practice. \nAnother key contribution of our work is a model of which logi\u00adcal memory locations are being accessed \nby various web platform features, necessary for building tools like a race detector. Typi\u00adcally, memory \naccesses can simply be de.ned as those reads and writes occurring at the machine or virtual-machine level. \nHowever, for web applications, there is no obvious de.nition of machine\u00adlevel accesses, as operations \nmay access JavaScript heap loca\u00adtions, browser-speci.c native data structures, or both. Our model of \nlogical memory locations enables reasoning about these memory\u00adaccess operations in a browser-independent \nmanner. Based on our models of the happens-before relation and logical memory locations, we implemented \nWEBRACER, a dynamic race detector for web applications.2 The dynamic approach lets WEB\u00ad 1 https://bugzilla.mozilla.org/show_bug.cgi?id=538892 \n2 Apart from dynamic race detection, our models are also a suitable basis for other concurrency analyses, \ne.g., static race detection or atomicity checking.  RACER precisely handle many complex features of \nweb applica\u00adtions that would be dif.cult to handle with static analysis alone. The JavaScript language \nhas many dif.cult-to-analyze constructs, like prototype chains and eval, that are used frequently in \nreal-world applications [22]. WEBRACER can simply observe the relevant ef\u00adfects of these constructs, \nside-stepping dif.cult static analysis is\u00adsues. Further, WEBRACER precisely handles interactions between \nJavaScript and HTML via the Document Object Model (DOM) data structure, a tree representation of the \nHTML often queried via string matching of node identi.ers. WEBRACER is able to .nd races at the level \nof concrete DOM tree nodes (i.e., individ\u00adual HTML elements) by observing accesses to memory addresses. \nWEBRACER is also able to simulate certain user interactions, ex\u00adposing more races. We implemented WEBRACER \natop WebKit [3], a robust ren\u00addering engine used in many production browsers (e.g., Safari3 and Google \nChrome4). Using a production engine allowed for WEB-RACER to be tested on full-featured, real-world web \nsites. In an experimental evaluation, we ran our tool on a large set of Fortune 100 company web sites \nand detected thousands of race conditions. A manual inspection of a subset of reported races showed that \nmany of them re.ected real bugs. We also gained insights into how web developers manage asynchrony in \npractice, applicable to future tools. Note that .nding real bugs on deployed web sites was quite a challenging \ntest for WEBRACER due to our unfamiliarity with the sites code and frequent code obfuscation; we expect \nWEBRACER to be even more effective for a developer debugging her own site. This paper makes the following \ncontributions: We give the .rst formulation of a happens-before relation to capture the asynchronous \nbehaviors of most commonly-used web platform constructs.  We de.ne a model of how operations in web \napplications access logical memory locations, independent of browser implementa\u00adtion details.  We present \nWEBRACER, a dynamic race detector based on our models and built on the production-quality WebKit engine. \n We describe an evaluation of WEBRACER on a large set of production web sites, in which we discovered \nmany harmful races and gained insights into how asynchronous constructs are used in practice.  This \npaper is organized as follows. Section 2 gives examples of web site concurrency errors. Section 3 presents \nour happens-before relation. Section 4 shows our logical memory access model. Sec\u00adtion 5 describes our \nrace detection algorithm and implementation. Section 6 presents our evaluation. Section 7 discusses limitations. \nSection 8 discusses related work, and Section 9 concludes. 2. Motivation In this section, we explain \nin more detail how data races can arise in web applications, give several motivating examples illustrating \npossible types of races, and show the potential harm caused by such races. We also use the examples to \nillustrate the happens\u00adbefore relationships and logical memory accesses that our model must include. \n2.1 Sources of Races For our purposes, the execution of a web application can be roughly seen as consisting \nof two types of activities: (1) conversion of HTML into a DOM tree [1] and (2) execution of scripts containing \n3 http://www.apple.com/safari/ 4 http://www.google.com/chrome <script>x = 1;</script> <iframe src=\"a.html\" \n/> <iframe src=\"b.html\" /> <!--a.html --> <script>x = 2;</script> <!--b.html --> <script>alert(x);</script> \n Figure 1. On the left is a simple example containing a race on x. On the right is an execution of the \ncode showing the race on x. JavaScript code. In most modern browsers, these activities are always interleaved \nin a single thread of execution, prohibiting many types of true concurrency (e.g., two distinct scripts \ncannot execute concurrently).5 So, the traditional de.nition of a data race involving two unordered memory \naccesses (one of which must be a write) from distinct execution threads does not apply directly. Instead, \nraces in web application arise from environmental asynchrony, typically triggered via event dispatch. \nThe web plat\u00adform employs an event-based programming model to handle a va\u00adriety of external events pages \nmay register handler code to be executed after user interactions (e.g., a mouse click) or the comple\u00adtion \nof some page loading operation, etc. Scripts may also explic\u00aditly queue functions to execute after some \namount of time via the setTimeout or setInterval methods [2]. These event handler func\u00adtions may execute \nin a non-deterministic order due to a variety of factors, e.g., variation in network bandwidth, CPU resources, \nor the timing of user input events. Asynchronous events often lead to race conditions in conjunc\u00adtion \nwith a web browser s rendering of a partially-loaded page. During the page load process, modern browsers \naggressively at\u00adtempt to render the HTML and JavaScript code downloaded so far, thereby improving perceived \nbrowser performance. When a partially-loaded page is rendered, user interactions may be inter\u00adleaved \nwith the remainder of the page load process in an unex\u00adpected manner, leading to race conditions. Furthermore, \nweb appli\u00adcation authors often exploit partial page rendering by deliberately delaying the download and \nexecution of certain script code. In such cases, the page appears to load quickly, but some code required \nfor user interaction may not yet be loaded, again leading to races. We shall now illustrate these issues \nwith examples of four types of data races. We start with standard data races on JavaScript mem\u00adory locations, \nsimilar to those seen in other languages like Java. We then illustrate three types of races which are \nmore speci.c to the web platform: HTML races, function races, and event dispatch races. These race types \nare worth distinguishing since the racing accesses do not always appear as standard memory accesses in \nthe JavaScript code.  2.2 Variable Races As in many other languages, web applications may have data \nraces on program variables, i.e., JavaScript memory locations. A very simple example appears on the left \nside in Fig. 1. Here, a variable x is set to 1 in the global scope. Then, two iframe elements are created; \n5 The Opera web browser (http://www.opera.com) may execute scripts from different frames concurrently; \nwe do not consider this case in the current work, as all other major browsers avoid such behavior.  \n<input type=\"text\" id=\"depart\" /> ... <script type=\"text/javascript\"> // add a hint to the box document.getElementById(\"depart\").value \n= \"City of Departure\"; // code to remove hint when user clicks ... </script> Figure 2. Southwest: A data \nrace on a form .eld value. <script type=\"text/javascript\"> function show(emailTo,EmailC) { ... EmailC.value \n= emailTo; v = $get( dw ); v.style.display = \"block\"; } </script> .... <a href= \"javascript:show( x@x.com \n, a)\"> Send Email </a> ... <div id=dw style=\"display:none\"> // HTML form to send email </div> Figure \n3. On the left is an example containing an HTML race on dw. On the right is an execution of the code \nshowing the race on HTML element dw that causes a JavaScript error (crash). an iframe contains the content \nof some other HTML .le, loaded asynchronously. In this case, the iframes cause a.html and b.html to be \nloaded asynchronously. The script in b.html may display 1 or 2 depending on when the script in a.html \nis executed, a clear data race on variable x. The trace shown on the right in Fig. 1 illustrates the \ncase where b.html displays 1. Note that in Fig. 1, the .rst write x=1 does not race with the write x=2 \nin a.html, since the .rst script will always execute be\u00adfore the iframes are loaded. Our happens-before \nrelation accurately captures such orderings between HTML element parsing and script execution. Data races \nmay also occur on properties of a DOM node (repre\u00adsenting an HTML element), potentially making them more \ndirectly visible (and annoying) to the user. Consider the example of Fig. 2, a simpli.ed version of a \nreal bug discovered in the southwest.com web site.6 First, an input element is created in which the user \ncan type their departure city for a .ight search. Later in the page, a script sets the value in the input \nbox to City of Departure , as a hint to the user, and adds code to make the hint text disappear when \nthe user clicks in the box (not shown). Here, the non-determinism stems from partial page rendering: \nthe user may see and interact with the input text box before the script loads and runs, and if this occurs, \nthe script will simply overwrite any text that the user has entered! Our race detection tool is able \nto discover this type of bug automatically by simulating certain user interactions (details in Section \n5.2.2).  2.3 HTML races Certain web application data races are more unique to the semantics of the web \nplatform and JavaScript. An HTML race occurs when an 6 This bug appears to have been .xed in the latest \nversion of the site. <iframe id=\"i\" src=\"bug413310-subframe.html\" onload=\"setTimeout(doNextStep, 20)\"> \n... <script type=\"text/javascript\"> ... function doNextStep() {...} </script> Figure 4. An example of \na function race. access of a DOM node representing an HTML element may occur before or after its creation. \nConsider the left side of Fig. 3, based on code with a race from valero.com discovered by our tool. Here, \nthe div at the end of the example with id dw holds an HTML form for sending email, hidden by default \n(since the value of the style attribute is display:none). When the user clicks the Send Email link, the \nshow() JavaScript function executes and the style of dw is changed, making the form appear. (The $get \nfunction employed by show() is essentially equivalent to the document.getElementById() function.) Here, \nthe problem arises if the user clicks the Send Email link before the dw element has loaded, as shown \nin the trace in the right part of Fig. 3. In this case, the show() function will attempt to set the style \nof a non-existent element, leading to an exception being thrown and termination of JavaScript execution. \nWeb browsers are designed to hide many bad JavaScript behaviors, and in this case, the JavaScript crash \nwill not be shown to the user the link will simply appear to do nothing when clicked, and subsequent \nscripts will continue to be executed. These hidden crashes can mask more serious problems, as mutations \nto global JavaScript state preceding the crashes persist, possibly leaving objects in an inconsistent \nstate. In Fig. 3, the effect of the statement EmailC.value = emailTo in show() will remain even if the \nsubsequent statement accessing dw crashes, potentially affecting execution of subsequent scripts on the \npage. Note that for this case, it is not obvious which memory loca\u00adtion the operations race upon. Within \na browser implementation, the concrete memory location(s) involved may depend on how ex\u00adactly the DOM \ndata structure is implemented. In our model, we de.ne a logical HTML element location l for the dw element, \nwith the JavaScript $get call reading l and the browser s parsing of the div node writing l. In this \nmanner, the data race can be modeled independent of browser implementations.  2.4 Function races Similarly \nto an HTML race, a function race occurs when an in\u00advocation of function f may occur before or after the \nparsing of f .7 Fig. 4 gives an example of a function race, extracted from a Mozilla Firefox unit test \nthat was failing non-deterministically. Here, we have an iframe whose onload handler (executed after \nthe src HTML .le is loaded) uses setTimeout() to perform a delayed invocation of doNextStep(), declared \nin the later script tag. The problem is that even with the 20ms delay, doNextStep() may be invoked be\u00adfore \nits declaring script is loaded if the iframe s HTML loads too fast. Invoking a non-existent function \nin JavaScript causes an ex\u00adception, which in this case would cause the corresponding unit test to fail. \nIn general, these exceptions may lead to the same types of problems described in Section 2.3 with HTML \nraces, due to JavaScript code possibly being terminated in an inconsistent state. Here, the race can \nbe .xed by moving the script element above the 7One site we ran WEBRACER on contained this code comment, \nindicating awareness of function races: /* Duplicated the JS function to get rid of race condition happening \nin the dashboard page. */ We do not endorse their solution.  <iframe id=\"i\" src=\"a.html\" /> ... <script> \ndocument.getElementById(\"i\").onload = function() {...} </script> Figure 5. An example of an event dispatch \nrace. iframe, in which case our happens-before relation would show that doNextStep() is always parsed \nbefore being invoked.  2.5 Event dispatch races An event dispatch race occurs when an event may .re \nbefore or after some handler for that event is added. Fig. 5 gives a small example of such a race. Here, \nthe onload handler for an iframe is set in a separate script, rather than directly in the iframe tag \nvia the onload attribute. Third-party scripts often add event handlers in this way, since they cannot \nmodify attributes in the HTML source directly. With this example, it is possible that the iframe s load \nevent will .re even before the script executes (if the iframe loads very quickly), in which case the \ninstalled onload handler will never run. Note that for this example, one racing access is the read of \nthe iframe s onload attribute by the browser when the iframe s load event is dispatched this read is \nnot explicit in the HTML or JavaScript code. Our model of happens-before and logical memory can both \nexpose this race and also show that there is no race if the iframe s onload attribute is set in the tag \nitself. 3. Happens-Before In this section we formulate a happens-before relation that captures key ordering \nconstraints for the most common web-platform fea\u00adtures. First, we give a brief background on the relevant \nHTML and script constructs. Then, we de.ne operations that comprise (atomic) execution. Finally, we de.ne \nthe happens-before relation between operations. We note that de.ning the happens-before relation can \nbe quite challenging because relevant speci.cations can be vague and some\u00adtimes browsers differ on how \nthey implement the speci.cation. This section represents our best effort to de.ne a happens-before relation \nthat agrees with both the speci.cation [10] and how most major browsers work. In cases, where the speci.cation \nwas unclear or be\u00adhavior differed signi.cantly across browsers, we erred on the side of not adding happens-before \nedges in order to not miss races. 3.1 Background First, we give some brief, informal background on the \nweb platform constructs discussed in this section. Due to space constraints, we cannot give a complete \ntreatment of all relevant features; the reader should consult online documentation and speci.cations \nfor further details [10, 17]. HTML An HTML page consists of a tree of elements. Each element is typically \ndelimited with an opening and a closing tag, e.g., <p>...</p> for a paragraph element. Within an HTML \npage,we say that element e1 precedes element e2 if e1 s opening tag appears syntactically earlier than \ne2 s opening tag. For instance, in the example below, element a precedes elements b and c, and element \nb precedes element c: <div id=\"a\"> <div id=\"b\"></div> </div> <div id=\"c\"></div> A static HTML element \nis declared syntactically in the page; elements may also be inserted by scripts, as discussed below. \nScripts and the DOM JavaScript code is added to a page via <script> elements. A static script element \nis inline if its code is declared in its body, e.g., <script>x = 10;</script>. Otherwise, a script element \nis external, and its code resides in a .le speci.ed via the src attribute, e.g., <script src=\"code.js\"></script>. \nWe elide a detailed description of the JavaScript programming language for space; see external resources \nfor further details [6, 17]. The Document Object Model (DOM) tree [1] is a parsed rep\u00adresentation of \na page s elements that gets rendered by the web browser and possibly accessed or mutated by scripts. \nEach node in the DOM tree has attributes to hold meta-data, including at\u00adtributes that mirror those seen \nin the corresponding HTML tag (e.g., a node representing a <script> element may have a src attribute).8 \nScripts can add or remove nodes from the DOM, leading the web browser to update its page rendering. Scripts \nmay also insert new script nodes into the DOM to make the browser load and execute new code (possibly \nasynchronously); we say a script added in this manner is script-inserted. As with static <script> elements, \na script\u00adinserted script is inline if its code is present as a child node and external if the code location \nis in its src attribute. Asynchronous and deferred scripts Both static script elementsand script-inserted \nscripts may be declared as asynchronous or de\u00adferred via attributes. Intuitively, a deferred script should \nrun afterall static HTML elements have been parsed, while an asynchronousscript may run at any time (we \ncapture the constraints more pre\u00adcisely in Section 3.3). An asynchronous script has a boolean async attribute \nwith value true, and a deferred script has a similar defer attribute, e.g.: <script src=\"code1.js\" async=\"true\"></script> \n<script src=\"code2.js\" defer=\"true\"></script> Asynchronous and deferred scripts must be external (i.e., \ntheir src attribute must be set), and a script cannot be both asynchronous and deferred. An external \nscript that is neither asynchronous nor deferred is a synchronous script. Frames HTML pages may be embedded \nin inline frames in other pages via the <iframe> tag, e.g.: <iframe src=\"nested.html\"></iframe> The HTML \nin an inline frame is loaded asynchronously, making iframes interesting from a happens-before perspective. \nThe root HTML page and each (transitive) inline frame has its own win\u00addow object, and each window has \nan associated document object, essentially the root of the corresponding DOM tree. Events and Handlers \nWeb applications must be written in an event-driven style, registering handler scripts to be executed \nwhen various types of events occur. Events are dispatched, e.g., for user interactions (clicks, typing, \netc.) and the completion of loading various elements (images, scripts, etc.). Every event has a target \ndenoting the object upon it was dispatched (e.g., for a click event, the DOM node for the button that \nwas clicked). Asynchronous networks requests (so-called AJAX requests) are made by invoking send() on \nsome XmlHttpRequest object o. At various stages of the request (including completion), the readystate\u00adchange \nevent is dispatched with target o. For simplicity, we ignore two features of event dispatch in this section \n(though they are fully handled by our implementation): 1. Inline event dispatch, where a script explicitly \n.res an event via a method call. 2. Propagation of events through a DOM tree, via capturing and bubbling \n[5].  These features, and corresponding minor modi.cations to the happens-before rules, are discussed \nfurther in Appendix A. 8 Strictly, elements have content attributes, while DOM nodes have IDL attributes; \nwe call both attributes here.  DOM content and window load Two events of particular interest are the \nDOMContentLoaded event on a document, indicating (roughly) that the static HTML for the document has \nbeen parsed, and the load event on a window object, .red after resources like images and inline frames \nhave fully loaded. Scripts very often register han\u00addlers on these events to perform additional computation \nonce other resources have been loaded, so capturing their happens-before re\u00adlationships precisely is \nimportant. Timed execution The setTimeout and setInterval functions can be used to perform delayed execution \nof some script code. A call setTimeout(f,i) causes f to be executed i milliseconds or later. setInterval(f,i) \nis similar, but it executes f every i milliseconds. Due to their timing-dependent behavior, capturing \nhappens-before for these functions is crucial.  3.2 Operations Next, we de.ne the kinds of operations \nwe consider in this work. These operations will be used to specify the happens-before rela\u00adtion in Section \n3.3. Each operation has a unique identi.er taken from the set OpId. Strictly speaking, we have only two \ntypes of atomic operations during web page loading: (1) parsing of HTML or (2) execution of script code. \nWe write parse(E) for the operation that parses a static HTML element E. For convenience, we separate \nscript execution operations into several types: exe(E): the operation executing the source in a script \nelement E (either static or script-inserted).  The execution of an event handler due to an event dispatch. \n cb(E): the execution of the callback script E resulting from a setTimeout(E, _) call.  cbi(E): the \nexecution of the i th invocation (i = 0) of a callback script E resulting from a setInterval(E, _) call. \n We also introduce some helper functions related to operations:  create(E) denotes the operation that \ninserts an element E into a document (i.e., a DOM tree). If E is a static HTML element, then create(E)= \nparse(E). Otherwise, create(E) is the operation associated with the script that inserts E.  dispi(E, \nT ) denotes the set of operations that execute all event handlers for the ith dispatch of event E at \ntarget T .  ld(T ) denotes disp0(load,T ), if T has a load event.  dcl(D) denotes disp0(DOMContentLoaded,D) \nfor a document D.   3.3 Building the Happens-Before Here, we give a complete de.nition of our happens-before \nrelation for the web features described in Section 3.1. As stated earlier, we developed this relation \nbased both on studying the speci.cations [5, 10] and common browser behaviors, aiming to only introduce \nrules where all of them mostly agreed (with fewer happens-before edges, more possible races are exposed). \nThe happens-before relation, denoted -, is a binary relation on operation identi.ers, i.e. -. OpId \u00d7 \nOpId. As a shortcut we use A -B to mean (A, B) .-and A -B to mean (A, B) .-. When we say that that two \noperations are in the happens-before, we mean the identi.ers of these operations. Sometimes we need to \nde.ne a happens-before between an operation A and all operations found in a set B. In that case, we overload \nA -B to mean .(a, b) .{A}\u00d7 B. a -b. The de.nitions of A -B when A is a set and B is an operation or when \nboth A and B are sets is similar. In the rules below, only the identi.ers disp0, ld and dcl represent \nsets. We group our rules for constructing the happens-before in roughly the same order as the order in \nwhich the corresponding features are described in Section 3.1. Static HTML Elements in static HTML are \nessentially processed in syntactic order, i.e.: 1. Let E1 and E2 be two static HTML elements in the same \ndocument, such that E1 precedes E2 (see Section 3.1). Then: (a) parse(E1) -parse(E2). (b) if E1 is an \ninline script, exe(E1) -parse(E2). (c) if E1 is a synchronous script, ld(E1) -parse(E2).  Script Parsing, \nExecution, and Loading The following basic rules govern all script elements E: 2. create(E) -exe(E) \n3. exe(E) -ld(E) (except for inline scripts, which have no load event).  Note that script-inserted inline \nscripts execute synchronously and their code does not execute as part of a new operation.9 Asynchronous \nand Deferred Scripts Static deferred scripts ex\u00adecute in syntactic order after the DOM content has been \nloaded, captured with the following rules. 4. Let E be any element in a document D such that create(E) \n\u00addcl(D) and let S be a static deferred script element in D. Then create(E) -exe(S). 5. If E1 and E2 \nare static deferred script elements, and E1 pre\u00adcedes E2, then ld(E1) -exe(E2).  Asynchronous scripts \nand external script-inserted scripts may ex\u00adecute in any order. Apart from rules 2 and 3, such a script \nis only governed by rule 15, relating its load event to that of the containing window. Inner Frames The \nHTML nested in an iframe element I loads asynchronously, with the following constraints: 6. For any element \nE in the nested document for I, create(I) \u00adcreate(E). 7. I s load event .res after the load event for \nthe nested window WI , i.e., ld(WI ) -ld(I).  Event Handlers Some basic rules apply to event handler \nexecu\u00adtion. Consider A . dispi(e, T ) for some i = 0, event e, and target T . 8. The target must have \nbeen created previously: create(T ) -A. 9. For any B . dispj (e, T ), where 0 = j<i, B -A.  We also \nhave the following rule for AJAX requests: 10. Let A be the operation invoking send() on an XmlHttpRequest \nobject T . Then, A -disp0(readystatechange,T ). DOM Content and Window Load These rules de.ne happens\u00adbefore \nrelationships for the DOMContentLoaded event on a document and the load event on a window (in addition \nto rule 7). We begin with a basic rule relating the two:  11. Let D be the document of a window W . \nThen dcl(D) \u00adld(W ).  The following rules indicate which operations must happen before the DOMContentLoaded \nevent for a document D: 9 Recent browser versions adhere to this rule, but older versions of Firefox \ndid not [23].  12. Let E be a static HTML element in D. Then parse(E) \u00addcl(D). 13. Let E be a static \ninline script element in D. Then exe(E) \u00addcl(D). 14. Let E be a static synchronous or deferred script \nelement in D. Then ld(E) -dcl(D). Finally, this rule shows which events must precede the load event \nfor a window W :  15. Let E be an element in the document of W s.t. create(E) \u00adld(W ) holds and E has \na load event (e.g., an img or script element). Then ld(E) -ld(W ).  Note that due to rule 3, rule 15 \nalso relates the execution of scripts and the window load event. Timed Execution The following two rules \ngovern setTimeout and setInterval executions: 16. Let A be an operation which calls setTimeout(B, _). \nThen A \u00adcb(B). 17. Let A be an operation which calls setInterval(B, _). Then A -cb0(B) and .i = 0.cbi(B) \n-cbi+1(B).  Finally, we note that the happens-before relation is transitive: if A -B and B -C, then \nA -C. Hence, the .nal relation -is built by taking the transitive closure of all pairs given above. 4. \nMemory Accesses In this section, we describe the shared memory accesses that an operation can perform. \nThe notion of memory access is compli\u00adcated by the fact that the web platform has no natural de.nition \nof machine-level accesses, as common operations manipulate both JavaScript heap locations and browser-internal \ndata structures (e.g., DOM operations). Here, in addition to the usual JavaScript vari\u00adables, we identify \nHTML elements in the DOM and event handlers as key logical locations accessed by operations. We de.ne \naccesses to these locations in a browser-independent manner, easing high\u00adlevel reasoning. We discuss \neach type of location in turn. 4.1 Accesses on Variables Let JSV ar be the set of JavaScript variables \nthat could potentially be shared among different operations. Such variables may include: Local variables \n(which could be shared between different oper\u00adations via a closure).  Object properties (instance .elds \nand array element).  Global variables (which are technically properties of a global object ).  By JSV \nar we mean the set of concrete runtime memory ad\u00addresses corresponding to these JavaScript variables. \nReads and writes of these addresses are potential shared memory accesses. Functions We treat a declaration \nof a function named F (i.e. not a lambda function) in JavaScript scope S as a write of an anonymous function \nwith F s body to a local variable named F , where the local variable assignment is placed at the beginning \nof scope S, in accordance with JavaScript semantics. For example, the following: { // scope S some_statements \nA; function foo() { some_statements B; } some_statements C; function bar() { some_statements D; } } is \ntreated as: { // scope S var foo = function() { some_statements B; }; var bar = function() { some_statements \nD; }; some_statements A; some_statements C; } Additional Cases The following accesses are modeled as \nwrites to properties of DOM objects in the JavaScript heap: Adding/removing a child element B to/from \nan element A (whether statically or dynamically) is considered a write to B s parentNode property and \na write to A s childNodes[i] property, where i is the index of B in the childNodes list.  Modi.cation \nof an HTML form element is treated as a write to the corresponding DOM node attribute. For example, the \nuser typing into an input or textbox element is considered a write to the element s value attribute, \nclicking a checkbox writes its checked property, etc.  4.2 Accesses on HTML Elements Let HElem denotes \nthe set of HTML elements. Then: Write Accesses The following write to an HTML element e: Inserting e \n(either via static parsing or dynamic JavaScript in\u00adsertion) into a document. Dynamic insertion of an \nHTML el\u00adement also dynamically inserts all of its child elements. The appendChild and insertBefore functions \nin JavaScript are exam\u00adples of ways to dynamically insert elements.  Removing e (dynamically via JavaScript) \nfrom a document (which also removes its child elements). The removeChild func\u00adtion in JavaScript is an \nexample of a way to dynamically remove an element.  Read Accesses JavaScript code can perform a logical \nread of an HTML element e via accessor methods or direct reads. Examples include: document.getElementById, \ndocument.body, document.getElementsByName, document.forms[i], document.getElementsByTagName, document.images[i], \ndocument.childNodes[i], document.anchors[i], document.links[i], document.scripts[i]  4.3 Accesses on \nEvent Handlers The combination of a target element el, event e and event handler h de.nes a logical event \nhandler location (el, e, h) . Eloc. Note that by having h in the logical location instead of only el \nand e we allow accesses that manipulate disjoint handlers for the same event e to not interfere. Write \nAccesses The following accesses write an event handler location: Parsing of an element with an event \nhandler content attribute [10, Section 6.1.6.1], for example: <img id=\"g\" onload=\"doWorkA()\"></img> Writing \nthe event handler attribute of an element, for example: document.getElementById(\"g\").onload = \"doWorkB()\" \n Invoking the addEventListener function on an element  Invoking the removeEventListener function on \nan element  Read Accesses An event handler location (el, e, h) is read when executing event handler \nh due to an event dispatch of event e with current target el. An event dispatch could be initiated by \na user (e.g. clicking a button) or programmatically (e.g. calling el.focus() to dispatch a focus event \non element el).  5. Race Detection In this section, we de.ne the notion of a data race based on our \nhappens-before relation (Section 3) and memory access model (Section 4), describe our race detector, \nand .nally discuss WEB-RACER, our WebKit-based race detector implementation. 5.1 Race Detector We next \nde.ne what a race is, and then we present our dynamic race detector. De.nition of a Race From the de.nition \nof happens-before and memory accesses, we de.ne a race as follows. Let A, A' . {read, write}\u00d7 OpId be \nmemory accesses to some logical loca\u00adtion m in an execution. A race exists between A and A' if: op(A)= \nop(A') (accesses performed by different operations). op(A) -op(A') and op(A') -op(A) (the operations \nare not in the happens-before). kind(A) = write or kind(A') = write (one of the accesses is a write). \nIn the above, op gives the operation identi.er for an access, and kind gives the access type (read or \nwrite). Algorithm Next, we de.ne our race detector at the declarative level. We maintain two auxiliary \nmaps LastRead and LastW rite for instrumenting read and write accesses respectively: LastRead . Loc . \nId LastW rite . Loc . Id Here, Loc = HElem . JSV ar . Eloc and Id = {.} . OpId. We use . to denote a \nspecially designated value used for initialization. For each location, the map maintains two .elds: the \n.rst .eld is the identi.er of the operation that last read the location, and the second is the identi.er \nof the last operation that wrote the location. For convenience we de.ne a function CHC to mean Can-Happen-Concurrently \nas: CHC . OpId \u00d7 OpId . Bool CHC(A, B)= A = .. B = .. A -B . B -A Intuitively, two operations A and B \ncan happen concurrently when both are not equal to . and (A, B) and (B, A) are not in the happens-before \nrelation. Our race detection algorithm works as follows: at the start, all entries in both maps are initialized: \n.e . Loc, LastRead[e] := . and LastW rite[e] := .. Then, upon an access A to an element e . Loc: If \nkind(A) = read: 1. Report a race if CHC(LastW rite[e], op(A)) = true. 2. LastRead[e] := op(A).   \nIf kind(A) = write: 1. Report a race if: CHC(LastW rite[e], op(A)) = true, or CHC(LastRead[e], op(A)) \n= true  2. LastW rite[e] := op(A).   That is, on a read, we check whether the last write (if a write \noccurred) can happen concurrently with the read. If this is the case, we report a read-write race. Similarly, \non a write, we check whether the last read (if a read occurred) or the last write (if a write occurred) \ncan happen concurrently with the current write, and if so, we report a read-write or a write-write race \nrespectively. Note that our race detector only keeps a constant amount of auxiliary information per memory \nlocation: a read or a write access will always overwrite its corresponding slot in the location. One \nadvantage of this is that the algorithm will scale well with the number of operations. Limitation A limitation \nof our race detector is that it may some\u00adtimes miss races. Consider the following example with three \nopera\u00adtions each performing a single access to location e (for convenience the operation identi.er is \nshown next to the memory access): 1: read e || 2: write e || 3: read e Assume that 1 -2, but that otherwise \nthe operations are unrelated by -. If the following sequence of operations occurs: 3 \u00b7 1 \u00b7 2, the algorithm \nwill not report the race between 2 and 3, since when 2 executes, the detector only has information about \nthe most recent read 1 of e. We plan to address this limitation in future work.  5.2 Implementation \nHere, we describe WEBRACER, which includes an implementation of our race detector in WebKit as well as \nautomatic exploration of functionality for simulating user interactions. We note that although we describe \na particular race detector, our framework is .exible and allows us to plug in any dynamic race detector \n(for instance, one could implement an adapted version of FastTrack [7]). 5.2.1 Instrumentation It was \nquite dif.cult to .nd all relevant instrumentation points in WebKit required to capture the happens-before \nand memory ac\u00adcesses needed for our race detector. The reason is that WebKit has no single intermediate \nrepresentation (IR) where all relevant oper\u00adations are exposed (this is in contrast to say JVM bytecodes, \nwhere .nding the right bytecodes to be instrumented is straightforward). While WebKit s JavaScript interpreter \ndoes have an IR, our detec\u00adtor also requires intercepting HTML parsing, event dispatch, pars\u00ading of new \nJavaScript functions, and so on. Adding instrumenta\u00adtion required careful study of the WebKit code base. \nWe believe that in the future, it would be useful to have a well-de.ned, stan\u00addard instrumentation interface \nfor browsers that analysis tools like WEBRACER could be built upon. Our instrumentation code communicates \nevents directly to the race detector, rather than generating a separate event trace. Inter\u00adnally, the \nrace detector represents the happens-before relation rather directly as a graph structure. While this \nrepresentation is simple, repeated graph traversals contribute to the high overhead of our im\u00adplementation \n(see Section 6); we plan to employ a more ef.cient vector-clock representation in the future.  5.2.2 \nAutomatic Exploration WEBRACER allows for manual browsing and interaction with web sites to discover \nraces. To further automate this process, we also im\u00adplemented automatic exploration, which systematically \ndispatches events corresponding to user actions. Automatic exploration was quite useful for our experiments, \nas it avoided having to manually trigger each event on each site (a tedious process). Automatic exploration \nworks by generating any event of certain types for which an event handler was registered by the page. \nWe do all automatic dispatch of events together after the window load event is dispatched, simplifying \nreasoning about WEBRACER s output (since all automatically-dispatched events are together). The events \nwe dispatched automatically were: mouseover, mousemove, mouseout, mouseup, mousedown, keydown, keyup, \nkeypress, change, input, focus and blur. Additionally, we also generated clicks on links which had JavaScript \nas protocol in their href s.  We also augmented automatic exploration to expose races on the contents \nof text boxes and input .elds (like the race in Fig. 2). Exposing such races was non-trivial, since simply \ntyping in a text box does not modify the value property of the corresponding DOM object (the location \nthat can be accessed by scripts). We solved this problem by adding a handler for the input event to all \ntext boxes and input .elds which effectively contained the code this.value := this.value. With this handler, \nany typing in a text box immediately updates the corresponding DOM node s value property. Finally, we \nadded code to simulate typing into all text boxes. Overall For instrumentation purposes, we changed roughly \n30 .cpp and .h .les in the WebKit source. The changes were not very intrusive we were able to fairly \neasily port WEBRACER across several WebKit versions.10 The total source code for WEBRACER after all modi.cations, \nincluding the race detector was around 2000 lines of C++ code.  5.3 Filters We also implemented a system \nfor easily adding post-processing .lters to WEBRACER s output, to heuristically .lter out certain races. \nSuch .lters can be useful, e.g., for helping to focus atten\u00adtion on races more likely to re.ect application \nbugs. In running WEBRACER on production web sites written by others, we found the following two .lters \nto be particularly useful: Focus on form races This .lter suppressed all variable races that did not \ninvolve the value of some HTML form .eld, e.g., the value in an <input> text box. Races on form .eld \nvalues have a high potential to be harmful, as they involve potential side ef\u00adfects of user inputs (see \nFig. 2). As an additional enhancement, we further .ltered out races on HTML form .elds in which the operation(s) \nwriting the form .eld value v had a read of v pre\u00adceding the write. Such reads often check to ensure \nthat the user has not modi.ed the .eld, which makes the race harmless. Focus on single-dispatch events \nThis .lter retained only event dispatch races involving events that dispatch at most once, e.g., the \nload event for a window. Races on such events are more likely to be harmful since once the event is dispatched, \nan added handler will never be run. In contrast, a click event on a button may dispatch multiple times, \nand missing one of those clicks is less likely to be a serious issue. Note that we found these .lters \nto be useful speci.cally for .nding harmful races in deployed web sites (see Section 6.3). In a scenario \nwhere a developer or tester is checking her own web site for races, alternative .ltering may be more \nsuitable. 6. Evaluation Here we describe an experimental evaluation of our prototype race detector, WEBRACER. \nIn our evaluation, we wanted to test the hy\u00adpothesis that WEBRACER could be used to .nd bugs in real \nweb sites, without overwhelming the user with benign race reports. We also wanted to understand better \nwhat techniques web developers use to manage asynchronous operations in practice. After describ\u00ading our \nexperimental con.guration (Section 6.1), we present both raw WEBRACER results (Section 6.2) and results \nwith the .ltering of Section 5.3 enabled (Section 6.3). 10Theevaluatedversionof WEBRACER wasbuiltatopWebKitSVN91698. \nRace type Mean Median Max HTML 2.2 0.0 112 Function 0.4 0.0 6 Variable 22.4 5.5 269 Event Dispatch 22.3 \n7.0 198 All 47.3 27.0 278 Table 1. The mean, median, and maximum number of races of each type across \nour test web sites. 6.1 Experimental Con.guration We ran WEBRACER on a set of 100 web sites, comprised \nof home pages of Fortune 100 companies,11 and manually inspected the output to .nd harmful races (to \nbe de.ned shortly). We ran WEBRACER with automatic exploration enabled (see Section 5.2) to simulate \nuser interaction with each site. This experiment was quite a challenging test, as we were attempting \nto .nd bugs in well\u00adtested, deployed web sites whose code was unfamiliar to us. A key issue in our evaluation \nwas how to determine if a re\u00adported race was harmful, i.e., whether it indicated a web site bug. In general, \nmaking this determination requires knowing the desired semantics of the web site s code. However, we \nfound that discover\u00ading relevant semantics by reading a site s code was often infeasible, due to use \nof complex JavaScript libraries and obfuscating code\u00adcompression techniques (e.g., shortening of variable \nand function names).12 Given this dif.culty, we conservatively classi.ed races as harmful only when they \ncould lead to behavior that was likely to be undesirable independent of application semantics. We de.ned \nan HTML race (see Section 2.3) as harmful if it could lead to an attempted update of a yet-to-be-created \nDOM node, causing a run\u00adtime exception. Similarly, a function race (Section 2.4) was harmful if it could \ncause an invocation of a yet-to-be-parsed function. We discuss harmful variable and event dispatch races \nin Section 6.3.  6.2 Raw Results Table 1 gives the mean, median, and maximum number of races of each \ntype reported by WEBRACER across the test web sites, without any .ltering.13 The average number of HTML \nand func\u00adtion races per site was quite low, making manual inspection man\u00adageable. (We discuss the results \nof that inspection in Section 6.3.) While the median number of variable and event dispatch races per \nsite was still low, several sites had a large number of these races, raising the average number of races \nper site to 47.3.14 Via manual inspection, we found that for many variable races on these sites, the \ncorresponding code was dif.cult to understand, making it hard to determine if the races were harmful. \nThe dif.culty in code understanding stemmed primarily from obfuscation and sophisticated use of asynchronous, \ndelayed script loading, often via complex JavaScript libraries like jQuery.15 We believe that if a developer \nwere using WEBRACER on their own (un-obfuscated) code, inspection of these variable races would be signi.cantly \neasier. 11 At http://www.srl.inf.ethz.ch/webracer, we have made avail\u00ad able the complete list of the \nsites that we tested. 12 Such compression techniques are often used to speed up script down\u00adloads. 13Notethatlikemanyotherdynamicracedetectors, \nWEBRACER reportsat most one race per location in a given run. 14 The races reported across different \nruns for the same site had little vari\u00adance; our numbers are taken from a typical run. 15 http://jquery.com/ \n Website HTML Function Variable EventDisp Allstate 6 (6) 2 (0) 0 0 AmericanExpress 41 (1) 0 0 0 BankOfAmerica \n4 (0) 1 (1) 0 0 BestBuy 0 2 (0) 0 0 CiscoSystems 0 1 (0) 0 0 Citigroup 3 (0) 3 (2) 0 1 (0) Comcast 0 \n6 (1) 0 0 ConocoPhillips 0 2 (1) 0 0 Costco 3 (3) 0 0 0 FedEx 1 (0) 0 0 0 Ford 112 (0) 0 0 0 GeneralDynamics \n0 1 (0) 0 0 GeneralMotors 0 1 (0) 0 0 HartfordFinancial 1 (1) 0 0 0 HomeDepot 0 1 (0) 0 0 Humana 0 0 \n0 13 (13) IBM 16 (0) 0 1 (1) 0 Intel 0 3 (0) 0 0 JPMorganChase 3 (3) 5 (0) 0 0 JohnsonControls 1 (1) \n0 1 (0) 0 Kroger 1 (0) 0 0 0 LibertyMutual 0 4 (0) 0 1 (0) Lowes 1 (0) 0 0 0 Macys 0 0 1 (1) 0 MassMutual \n1 (0) 0 0 0 MerrillLynch 1 (1) 0 0 0 MetLife 0 0 0 35 (35) MorganStanley 1 (1) 0 0 0 Motorola 1 (0) 0 \n0 1 (0) NewsCorporation 1 (0) 0 0 0 Safeway 0 0 1 (1) 0 Sunoco 11 (11) 0 0 0 Target 2 (2) 0 1 (1) 0 UnitedHealthGroup \n0 0 0 1 (0) UnitedTechnologies 2 (1) 0 0 0 ValeroEnergy 5 (1) 4 (1) 2 (0) 0 Verizon 0 1 (1) 0 0 WalMart \n0 0 1 (1) 0 Walgreens 0 0 0 35 (35) WaltDisney 1 (0) 0 0 0 WellsFargo 0 0 0 4 (0) Total 219 (32) 37 (7) \n8 (5) 91 (83) Table 2. Races reported by WEBRACER on the test web sites, after .ltering (see Section \n6.3). Sites with no races are elided. The number of harmful races is shown in parenthesis. We also found \nthat many event dispatch races arose due to deliberate delays in script loading, making those races benign \nwith respect to the desired semantics. For example, consider a site s that shows a pop-up menu when the \nuser hovers the mouse over an image i. If s delays loading of the script implementing the pop-up menu \n(to speed loading of the rest of the page), i may be displayed long before the pop-up menu is available. \nWEBRACER reports such behavior as a race, and it may indeed be annoying to a user to have degraded functionality \nas the page is loading (particularly over a slow connection). However, given that the developer must \nmake a deliberate decision to delay script loading, we do not classify such races as harmful.  6.3 Results \nwith Filtering Table 2 shows the number of races reported by WEBRACER after the .lters described in Section \n5.3 were enabled, with the number of harmful races shown in parentheses. With the .lters enabled, the \nnumber of variable and event dispatch races were dramatically reduced, making manual inspection more \nfeasible. Harmful races We discuss the discovered harmful races of each type in turn. HTML We found 32 \nraces on HTML elements that could lead to a runtime exception due to access of a non-existent DOM node. \nThey were mostly similar in form to the example in Fig. 3. In some cases, the script performing the DOM \nnode access was loaded asynchronously, making the race less obvious. Function The seven harmful races \nwere similar to the example of Fig. 4. However, the handler invoking a possibly-unde.ned func\u00adtion was \ntypically attached to mouse hover or click events, rather than load events. Hence, our automatic exploration \n(which simu\u00adlated the clicks and mouse events) was key to exposing these races. Variable We considered \na variable race to be harmful if it could cause user input to be erased, as in the example from Fig. \n2. We found .ve such harmful races on HTML search boxes, and in each case veri.ed that user input during \npage load would be deleted by a script executing later. The low false-positive rate for this race type \n(with .ltering enabled) indicates that WEBRACER is already an effective tool for .nding these high-severity \nbugs. Event Dispatch We considered an event dispatch race to be harm\u00adful if due to the race, a handler \nattached to an event might never be executed, in accordance with the intuition behind the corresponding \n.lter (see Section 5.3). All the harmful races in this category were due to use of the Gomez performance-monitoring \nscript.16 Gomez attempts to monitor image load time by checking for new images in the DOM every 10ms \n(via setInterval) and attaching an onload handler to each image as it is added. The problem is that if \nan im\u00adage loads very quickly, Gomez may add its handler after an image s load event has .red. Gomez may \nhave some separate code to com\u00adpensate for this issue, but we could not tell from the obfuscated versions \nwe were able to inspect. Benign races The primary cause of benign race reports was syn\u00adchronization between \nscripts via data dependence. A canonical ex\u00adample was the Ford site, where all the 112 benign HTML racesstemmed \nfrom a single pattern, similar to the following: function addPopUp() { if (document.getElementById(\"last\") \n!= null) { // mutate many DOM nodes } else { setTimeout(addPopUp,250); } } Via setTimeout, the code repeatedly \nchecks if the DOM node last has been created, and if so, many other DOM nodes are mutated. The HTML for \nthe page is constructed such that if last has been created, all the DOM nodes possibly mutated by the \nscript must exist. We observe that this commonly used pattern (and variants) operationally encodes a \nform of ordering between operations: an operation can successfully proceed only if some other operation \nhas executed. To aid human and automated reasoning about such code, it would be very useful if the web \nplatform had an explicit ordering construct for expressing such dependencies in a more declarative manner. \nIn conclusion, WEBRACER is already an effective tool for .nd\u00ading certain types of harmful races. Further, \nour data show that be\u00adnign races are mostly due to either deliberate delays in adding page functionality \n(see Section 6.2) or synchronization via data depen\u00addencies, suggesting directions for future tool improvement. \nWe ex\u00adpect that WEBRACER would be even more effective when used as part of the development process. Performance \nWEBRACER was not optimized for performance; we focused instead on achieving good coverage of the many \nbrowser instrumentation points required (see Section 5.2). Web\u00adKit s just-in-time (JIT) JavaScript compiler \nwas disabled in WEB\u00ad 16 http://www.gomez.com/  RACER (as only the interpreter was instrumented), causing \na sig\u00adni.cant slowdown even without instrumentation. WEBRACER s performance was suf.cient for .nding \nraces in the web sites that we looked at, handling pages with tens of thousands of operations in less \nthan a minute in most cases. However, heavy JavaScript usage incurred signi.cant overhead we observed \na roughly 500X slowdown for the SunSpider benchmarks17 compared to running with the JIT compiler and \nno instrumentation. In future work, we plan to develop an optimized implementation that employs more \nef.cient data structures in the race detector (see Section 5.2) and that does not require disabling the \nJIT compiler. 7. Limitations Although we have added instrumentation for most commonly-used web features \nin WEBRACER, we have not yet handled all relevant features (a dif.cult task, as new features are being \nadded to the webplatformrapidly). Forinstance, WEBRACER sinstrumentation does not yet add all relevant \nhappens-before edges corresponding to rule 10 from Section 3.3 for AJAX requests. Also, we have not instrumented \ncalls to clearTimeout and clearInterval calls [2], which may race with the execution of handlers installed \nvia setTimeout and setInterval. In general, missing happens-before edges may lead to false positives. \nAlso, our instrumentation does not yet detect DOM node mutation due to application of rules from stylesheets. \nIn some cases, it is unclear whether certain interactions should be classi.ed as a race. For instance, \none can move elements with the function appendChild (i.e. move an element that is already in the document). \nIf an element is accessed (e.g., via getElementById) in parallel with being moved, then WEBRACER will \nreport a race. However, it is plausible that this interaction should not be classi.ed as a race, since \nthe element existed in the document at all times and was only moved. Finally, WEBRACER may report false-positive \nevent handler races in cases where the .ring of certain events is disabled. For instance, say that a \nbutton b is inserted into a document with its visibility set to hidden, disabling clicks. Later, operation \n1 adds an onclick handler for b and makes b visible, and operation 2 represents a user clicking on b. \nSince our happens-before relation does not consider the visibility of buttons, we have 1 -2 according \nto our rules, and WEBRACER will report a false-positive race. In general, detecting disabled events is \nnon-trivial (e.g., clicks may in effect be disabled by shrinking a button), and more robust handling \nis left for future work. 8. Related Work Several of the concurrency issues we address were identi.ed \nin\u00adformally in a position paper by Ide et al. [11], including races from asynchronous data exchange between \na rich client and a Web server and from interleaved HTML parsing and event handler execution (all of \nwhich we capture). They advocate higher-level abstractions to handle these issues, but they do not implement \neither such ab\u00adstractions or any error-checking tool. Perhaps the closest work to our own is Zheng et \nal. s work on statically detecting races caused by uses of asynchronous re\u00adquests (so called AJAX calls) \nin JavaScript code [25]. Their sys\u00adtem acquires an application s JavaScript code by extracting it from \nthe server-side code (currently, PHP is handled). Their static tech\u00adnique is able to detect AJAX races \nwithout having to exercise pro\u00adgram behaviors, unlike WEBRACER. Also, their system has special handling \nfor cookie state that we have not implemented; adding such handling to WEBRACER would be straightforward. \nWEB-RACER detects a signi.cantly broader class of races than their sys\u00ad 17 http://www.webkit.org/perf/sunspider/sunspider.html \ntem (it can catch AJAX races since separate handlers will have no happens-before edges between them). \nAlso, since WEBRACER is implemented entirely in a browser, it works for any server-side technology and \nfor deployed web sites; their current approach re\u00adquires separate work for each server-side technology. \nIn the future, we plan to investigate how WEBRACER could be enhanced by in\u00adcorporating static analyses \nlike theirs. In general, precise detection of the same races found by WEB-RACER would be very dif.cult \nin a purely static approach like that of Zheng et al., due to pervasive DOM usage (including mutation \nthat may add new scripts) and hard-to-analyze JavaScript features (see discussion in Section 1). The \nmost precise static DOM model we know of is that in Jensen et al. [13], which uses a single ab\u00adstract \nrepresentative for all DOM nodes with the same tag (e.g., a single representative for all <div> nodes). \nThis abstraction would cause many false positives in a race detector. There have been several other efforts \nto detect bugs in JavaScript programs (e.g., [8, 12, 14, 21]), but we are not aware of any pre\u00advious \nsystems aimed at detecting races besides the Zheng et al. work [25] discussed above. Recently, a number \nof novel race detectors for Java-like lan\u00adguages have been developed. For example, FastTrack [7] is a \nstate\u00adof-the art race detector using vector clocks augmented with various optimizations to reduce the \nspace overhead per memory location in the common case to a constant. In our setting, the language is \nmore restrictive as it does not support locks (JavaScript execution is an atomic operation), enabling \nus to implemented a more specialized race detector. However, in the future, it may be possible to optimize \nour detector even further. Our automatic exploration mode (see Section 5.2.2) is similar to the Artemis \nsystem [4], which performs feedback-directed exe\u00adcution of event handlers, aiming to maximizing code \ncoverage. Our technique currently does a shallower exploration than Artemis, suf\u00ad.cient for exposing \nmany races. We plan on pursuing deeper auto\u00admatic exploration techniques like Artemis in the future. \nOther previous work has focused on better programming mod\u00adels that enable developers to more easily avoid \ncertain races. Flap\u00adjax [18] provides abstractions for reasoning about and composing event streams and \nbehaviors, allowing for code that, e.g., handles a series of updates from a server without having to \nmanage low\u00adlevel details of XMLHttpRequests. The Flapjax programming model should help programmers avoid \nsome of the data races that we de\u00adscribe. Mobl [9] takes a somewhat different approach by providing a \nmore synchronous interface to creating Web applications, again abstracting away some of the race-prone \nfeatures of the web plat\u00adform. While these systems hold promise for future applications, they do not \naddress the problem of .nding races in existing code. 9. Conclusion The Web platform poses a particular \nchallenge to analyzing con\u00adcurrency: there are multiple speci.cations and implementations de.ning the \nplatform, concurrency is introduced in implicit, event\u00addriven ways, and many different features and APIs \nare relevant to concurrency. In this environment, we provide the .rst core tools for reasoning about \nconcurrency: a happens-before relation over com\u00admon HTML and JavaScript constructs, and a logical model \nof mem\u00adory accesses for capturing state interactions. We show the value of these tools with WEBRACER, \nthe .rst dynamic race detector for Web applications. WEBRACER found numerous races across top Web sites, \nincluding harmful ones capable of causing anomalies like lost input. Future work includes further automating \nthe detection and pos\u00adsibly remediation of data races in Web applications. Also, at the level of speci.cations, \na precise de.nition of what concurrent in\u00adteractions are meant to be allowed would be very useful (we \nfound de.ning a reasonable happens-before relation to be surprisingly challenging). Such a de.nition \nmust provide more clarity to devel\u00adopers, but also not overly restrict the concurrency that has become \ncrucial to performant web applications.  Acknowledgements We thank Robert O Callahan for pointing out \nthat concurrency issues can occur in client web applications and for suggesting Firefox test cases as \ncandidates for analysis. We also thank Max Sch\u00e4fer and the anonymous reviewers for their detailed comments. \nReferences [1] HTML5 DOM tree. http://dev.w3.org/html5/spec/Overview. html#dom-trees. [2] setTimeout \nspeci.cation. http://www.whatwg.org/ specs/web-apps/current-work/multipage/timers.html# dom-windowtimers-settimeout. \n[3] WebKit. http://www.webkit.org/. [4] Shay Artzi, Julian Dolby, Simon Holm Jensen, Anders M\u00f8ller, and \nFrank Tip. A Framework for Automated Testing of JavaScript Web Applications. In ICSE, May 2011. [5] Document \nObject Model (DOM) Level 3 Events Speci.cation. http: //www.w3.org/TR/DOM-Level-3-Events/. [6] ECMA. \nECMAScript Language Speci.cation, 5th edition, 2009. ECMA-262. [7] Cormac Flanagan and Stephen N. Freund. \nFastTrack: ef.cient and precise dynamic race detection. In PLDI, 2009. [8] Salvatore Guarnieri and V. \nBenjamin Livshits. Gatekeeper: Mostly static enforcement of security and reliability policies for JavaScript \ncode. In USENIX Security Symposium, pages 151 168, 2009. [9] Zef Hemel and Eelco Visser. Declaratively \nprogramming the mobile web with Mobl. In OOPSLA, 2011. [10] HTML5 speci.cation. http://www.w3.org/TR/html5/. \n[11] James Ide, Ratislav Bodik, and Doug Kimelman. Concurrency con\u00adcerns in rich Internet applications. \nIn Workshop on Exploiting Con\u00adcurrency Ef.ciently and Correctly (EC2), 2009. [12] Dongseok Jang, Ranjit \nJhala, Sorin Lerner, and Hovav Shacham. An empirical study of privacy-violating information .ows in JavaScript \nweb applications. In ACM Conference on Computer and Communica\u00adtions Security, pages 270 283, 2010. [13] \nSimon Holm Jensen, Magnus Madsen, and Anders M\u00f8ller. Modeling the HTML DOM and browser API in static \nanalysis of JavaScript web applications. In ESEC/FSE, 2011. [14] Simon Holm Jensen, Anders M\u00f8ller, and \nPeter Thiemann. Interproce\u00addural Analysis with Lazy Propagation. In SAS, 2010. [15] Olav Junker Kjaer. \nTiming and synchronization in JavaScript. http://dev.opera.com/articles/view/ timing-and-synchronization-in-javascript/. \nAccessed 03-November-2011. [16] Leslie Lamport. Time, clocks, and the ordering of events in a dis\u00adtributed \nsystem. Commun. ACM, 21:558 565, July 1978. [17] Mozilla Developer Network. https://developer.mozilla.org/. \n[18] Leo A. Meyerovich, Arjun Guha, Jacob Baskin, Gregory H. Cooper, Michael Greenberg, Aleks Brom.eld, \nand Shriram Krishnamurthi. Flapjax: a programming language for Ajax applications. In OOPSLA, 2009. [19] \nMozilla Developer Network. Avoiding intermittent oranges. https://developer.mozilla.org/en/QA/Avoiding_ \nintermittent_oranges. Accessed 18-October-2011. [20] Robert O Callahan, December 2010. Personal communication. \n[21] Joe Gibbs Politz, Spiridon Aristides Eliopoulos, Arjun Guha, and Shri\u00adram Krishnamurthi. ADsafety: \nType-based veri.cation of JavaScript sandboxing. In USENIX Security Symposium, 2011. [22] Gregor Richards, \nSylvain Lebresne, Brian Burg, and Jan Vitek. An analysis of the dynamic behavior of javascript programs. \nSIGPLAN Not., 45:1 12, June 2010. [23] Henri Sivonen. HTML5 script execution changes in Firefox 4. http://hsivonen.iki.fi/script-execution/. \nAccessed 05\u00adNovember-2011. [24] Steve Souders. Even Faster Web Sites: Performance Best Practices for \nWeb Developers. O Reilly Media, 2009. [25] Yunhui Zheng, Tao Bao, and Xiangyu Zhang. Statically locating \nweb application bugs caused by asynchronous calls. In WWW, 2011. A. Happens-Before for Events Here, we \ndescribe how event dispatch works in detail and give some additional (or re.ned) rules for handling events. \nHow Events Work Here we brie.y sketch event .ring; more de\u00adtails can be found in [10, 15]. Firing an \nevent E is done on an ele\u00adment or object T (called a target). Some events can have different phases associated \nwith it: Capturing, At-Target, Bubbling and De\u00adfault. The Capturing phase goes through all targets starting \nat the top of the DOM tree (at the document/window object) and moving down towards the event target T \n. At each target, all handlers which are registered for that type of event are executed. After the Captur\u00ading \nphase, the At-Target phase follows, which dispatches all han\u00addlers on the event target T . Following \nis the Bubbling phase which works from the target T up towards the document/window object and dispatches \nthe event on all targets on the way. At last, there is the default action which kicks in and dispatches \non the target T . For example, on a link element, the href may be followed or executed if it is JavaScript \ncode (i.e., of the form href=\"javascript:...\"). To de.ne the happens-before, we .rst need some de.nitions. \nAn inline event dispatch is the act of programmatically .ring an event from JavaScript. An example would \nbe the call element.click() in JavaScript code, which .res a click event on element. Anything else is \nconsidered as a non-inline event dispatch. An example would be the mousemove event .ring due to the user \nmoving her mouse, the load event for a window .ring or the readystatechange event dispatching on an XMLHttpRequest \nobject. Splitting Happens-Before Since script execution is atomic, the browser will not preempt a script \nin order to execute a different script, parse more HTML, etc. However, event-handler execution could \nactually be triggered in the middle of JavaScript code due to an inline event dispatch. Let A be such \na JavaScript operation that is interleaved with event-handler execution. Given an execution A, we de.ne \nA[i:j) to mean the subsequence of A starting and including the i th transition in A and ending with but \nnot including the j th transition (if i< 0, j =|A|, or i = j, then A[i:j) = E). Then, given an execution \nA interrupted by an inline event dispatch, let the event dispatch invocation be the k th transition in \nA s execution. Let B be the set of operations generated by the inline event dispatch. Then: A[0:k) -B \nand B -A[k+1:|A|). When using A[i:j) in the happens-before, we mean that a unique operation identi.er \nis created for this sequence of transitions. Then, in the happens-before as discussed in Section 3.3, \nwe replace an interleaved operation A with the set {A[0:k),A[k+1:|A|)}. B (dealing with sets in the happens-before \nwas already explained earlier). Event Phasing Happens-Before We denote hop(E, ET, P, T )i as the set \nof all operations that are the executions of all handlers for the ith dispatch of event E dispatched \non target ET in phase P with current target T . Let A . hop(E1,ET1,P1,T1)i and B . hop(E2, ET2,P2,T2)j \n. If E1 and E2 are both non-inline events, ET1 = ET2, E1 = E2, and (i<j or (i = j and (P1 = P2 or T1 \n= T2))), then A -B.    \n\t\t\t", "proc_id": "2254064", "abstract": "<p>Modern web pages are becoming increasingly full-featured, and this additional functionality often requires greater use of asynchrony. Unfortunately, this asynchrony can trigger unexpected concurrency errors, even though web page scripts are executed sequentially.</p> <p>We present the first formulation of a <i>happens-before relation</i> for common web platform features. Developing this relation was a non-trivial task, due to complex feature interactions and browser differences. We also present a logical memory access model for web applications that abstracts away browser implementation details.</p> <p>Based on the above, we implemented WebRacer, the first dynamic race detector for web applications. WebRacer is implemented atop the production-quality WebKit engine, enabling testing of full-featured web sites. WebRacer can also simulate certain user actions, exposing more races.</p> <p>We evaluated WebRacer by testing a large set of Fortune 100 company web sites. We discovered many harmful races, and also gained insights into how developers handle asynchrony in practice.</p>", "authors": [{"name": "Boris Petrov", "author_profile_id": "81502659680", "affiliation": "Sofia University, Sofia, Bulgaria", "person_id": "P3471214", "email_address": "boris.petrov.petrov@gmail.com", "orcid_id": ""}, {"name": "Martin Vechev", "author_profile_id": "81100269652", "affiliation": "ETH Zurich, Zurich, Switzerland", "person_id": "P3471215", "email_address": "martin.vechev@inf.ethz.ch", "orcid_id": ""}, {"name": "Manu Sridharan", "author_profile_id": "81100641428", "affiliation": "IBM T.J. Watson Research Center, Hawthorne, USA", "person_id": "P3471216", "email_address": "msridhar@us.ibm.com", "orcid_id": ""}, {"name": "Julian Dolby", "author_profile_id": "81100506419", "affiliation": "IBM T.J. Watson Research Center, Hawthorne, USA", "person_id": "P3471217", "email_address": "dolby@us.ibm.com", "orcid_id": ""}], "doi_number": "10.1145/2254064.2254095", "year": "2012", "article_id": "2254095", "conference": "PLDI", "title": "Race detection for web applications", "url": "http://dl.acm.org/citation.cfm?id=2254095"}