{"article_publication_date": "06-11-2012", "fulltext": "\n Proving Acceptability Properties of Relaxed Nondeterministic Approximate Programs Michael Carbin Deokhwan \nKim Sasa Misailovic Martin C. Rinard MIT CSAIL {mcarbin, dkim, misailo, rinard}@csail.mit.edu Abstract \nApproximate program transformations such as skipping tasks [29, 30], loop perforation [21, 22, 35], reduction \nsampling [38], multiple selectable implementations [3, 4, 16, 38], dynamic knobs [16], syn\u00adchronization \nelimination [20, 32], approximate function memoiza\u00ad tion [11], and approximate data types [34] produce \nprograms that can execute at a variety of points in an underlying performance ver\u00adsus accuracy tradeoff \nspace. These transformed programs have the ability to trade accuracy of their results for increased performance \nby dynamically and nondeterministically modifying variables that control their execution. We call such \ntransformed programs relaxed programs because they have been extended with additional nondeterminism \nto relax their semantics and enable greater .exibility in their execution. We present language constructs \nfor developing and specifying relaxed programs. We also present proof rules for reasoning about acceptability \nproperties [28], which the program must satisfy to be acceptable. Our proof rules work with two kinds \nof acceptability properties: relational acceptability properties, which characterize desired relationships \nbetween the values of variables in the original and relaxed programs, and unary acceptability properties, \nwhich involve values only from a single (original or relaxed) program. The proof rules support a staged \nreasoning approach in which the majority of the reasoning effort works with the original program. Exploiting \nthe common structure that the original and relaxed pro\u00adgrams share, relational reasoning transfers reasoning \neffort from the original program to prove properties of the relaxed program. We have formalized the dynamic \nsemantics of our target pro\u00adgramming language and the proof rules in Coq and veri.ed that the proof rules \nare sound with respect to the dynamic semantics. Our Coq implementation enables developers to obtain \nfully machine\u00adchecked veri.cations of their relaxed programs. Categories and Subject Descriptors D.3.2 \n[Programming Lan\u00adguages]: Language Classi.cations Nondeterministic languages; F.3.1 [Logics and Meanings \nof Programs]: Specifying and Verify\u00ading and Reasoning about Programs; F.3.2 [Logics and Meanings of Programs]: \nSemantics of Programming Languages General Terms Languages, Performance, Theory, Veri.cation Keywords \nCoq, Acceptability, Relaxed Programs, Relational Hoare Logic Permission to make digital or hard copies \nof all or part of this work for personal or classroom use is granted without fee provided that copies \nare not made or distributed for pro.t or commercial advantage and that copies bear this notice and the \nfull citation on the .rst page. To copy otherwise, to republish, to post on servers or to redistribute \nto lists, requires prior speci.c permission and/or a fee. PLDI 12, June 11 16, 2012, Beijing, China. \nCopyright c &#38;#169; 2012 ACM 978-1-4503-1205-9/12/06. . . $10.00 1. Introduction In recent years \nresearchers have developed a range of mechanisms for dynamically varying application behavior. Typical \ngoals include maximizing performance subject to an accuracy constraint, maxi\u00admizing accuracy subject \nto a performance constraint, or dynami\u00adcally adjusting program behavior to adapt to changes in the char\u00adacteristics \nof the underlying hardware platform (such as varying load or clock rate) [16, 17]. Speci.c mechanisms \ninclude skip\u00ad ping tasks [29, 30], loop perforation (skipping iterations of time\u00ad consuming loops) [21, \n22, 35], sampling reduction inputs [38], multiple selectable implementations of a given component or \ncom\u00adponents [3, 4, 16, 38], dynamic knobs (con.guration parameters that can be changed as the program \nexecutes) [16], synchronization elimination (forgoing synchronization not required to produce an acceptably \naccurate result) [20, 32], approximate function memo\u00ad ization (returning a previously computed value \nwhen the arguments of a function call are close to the arguments of a previous call) [11], and approximate \ndata types [32, 34]. All of these mechanisms can produce a relaxed program a program that may adjust \nits execution by changing one or more variables subject to a speci.ed relaxation predicate. For example, \na perforated program may dynamically choose to skip loop itera\u00adtions each time it enters a given loop. \nA relaxed program is there\u00adfore a nondeterministic program, with each execution a variant of the original \nexecution. The different executions typically share a common global structure, with local differences \nat only those parts of the computation affected by the modi.ed variables. 1.1 Acceptability To use these \nrelaxation mechanisms, a developer must ensure that the resulting relaxed program is acceptable. We formalize \naccept\u00adability as acceptability properties that the program must satisfy to be acceptable. Acceptability \nproperties include integrity properties that the program must satisfy to successfully produce a result \nand accuracy properties that characterize how accurate the produced result must be. For example, an integrity \nproperty might state that a function must return a value greater than zero (otherwise the pro\u00adgram might \ncrash), while an accuracy property might state that the relaxed program must (potentially only with high \nprobability) pro\u00adduce a result that differs by at most a speci.ed percentage from the result that the \noriginal program produces [21, 38]. 1.2 Reasoning About Relaxed Programs We present language constructs \nfor developing relaxed programs and stating acceptability properties. We also present proof rules for \nverifying the stated acceptability properties. Our language and proof rules support a staged approach \nin which the developer .rst develops a standard program and uses standard approaches to rea\u00adson about \nthis program to determine that it satis.es desired accept\u00adability properties. We refer to the dynamic \nsemantics of the pro\u00adgram at this stage as the original semantics of the program. Either the developer \nor an automated system (such as a com\u00adpiler that implements loop perforation) then relaxes the program \nto enable additional nondeterministic executions. We refer to the dynamic semantics of the program at \nthis stage as the relaxed se\u00admantics of the program. Finally, the developer uses relational reasoning \nto verify that the relaxation maintains the desired acceptability properties. Speci.\u00adcally, the developer \nspeci.es and veri.es additional relational as\u00adsertions that characterize the relationship between the \noriginal and relaxed semantics. These relational assertions facilitate the over\u00adall veri.cation of the \nrelaxed program. This approach is designed to reduce the overall reasoning effort by exploiting the common \nstructure that the original and relaxed programs share. With this ap\u00adproach the majority of the reasoning \neffort works with the original program and is then transferred via relational reasoning to verify the \nnondeterministic relaxed program.  1.3 Relaxed Programming Constructs Basic relaxed programming constructs \ninclude nondeterministic variable assignments (via the relax statement), relational asser\u00adtions that \nrelate the relaxed semantics to the original semantics (via the relate statement), unary assertions (via \nthe assert state\u00adment), and unary assumptions (via the assume statement). The Relax Statement. The relax \n(X) st (P) statement speci\u00ad.es a nondeterministic assignment to the set of variables X. Speci.\u00adcally, \nthe relax statement can assign the variables in X to any set of values that satis.es the relaxation predicate \nP. When added to the program, the relax statement affects only the relaxed semantics of the program; \nin the original semantics it has no effect. The Relate Statement. The relate P statement asserts that \nthe predicate P must hold at the program point where the statement appears. The predicate P is a relational \npredicate it may refer\u00adence values from both the original and relaxed executions. So, for example, the \nstatement might require the value of a variable x in relaxed executions to be greater than or equal to \nthe value of x in the original execution. The Assert Statement. The assert P statement states that P \nmust hold at the point where the statement appears. In contrast to the relate statement, P is a unary \npredicate it only references values from a single execution (original or relaxed) as in a stan\u00addard \nassertion. In the original semantics, our proof rules generate an obligation to prove that an assert \nstatement holds for all exe\u00adcutions. To ensure that the assert statement remains valid in the relaxed \nsemantics, our proof rule in the relaxed semantics gener\u00adates an obligation to prove that if the assertion \nis valid in the orig\u00adinal semantics, then the current relation between the original and relaxed semantics \nestablishes that the assertion is valid in the re\u00adlaxed semantics. For example, it may be possible to \nprove that all the variables referenced in an assertion have the same values in the original and relaxed \nsemantics i.e., the relaxation does not inter\u00adfere with the assertion. In this way, relational reasoning \nserves as a bridge to transfer properties of the original program over to the relaxed program. The Assume \nStatement. The assume P statement states that the unary predicate P holds at the point where the statement \nappears. In the original semantics the assume statement does not generate any proof obligations the \nproof system simply accepts that P holds. To verify that the relaxation does not interfere with the reasoning \nbehind the assumption, the proof rules for the relaxed semantics generate an obligation to prove that \nif the assumption P holds in all original executions, then it holds in all relaxed executions. The proofs \nwork in much the same way as for the assert statement except that the proof rules do not generate an \nobligation to verify that P holds in the original semantics.  1.4 Key Properties of Acceptable Relaxed \nPrograms Our approach makes it possible to formalize key properties that are critical to the development \nand deployment of acceptable relaxed programs. Integrity and Noninterference. Essentially all programs \nhave basic integrity properties that must hold for all executions of the program. Examples include the \nabsence of out of bounds array ac\u00adcesses or null pointer dereferences. Developers typically use either \nassert or assume statements to formalize these integrity proper\u00adties. Because successful relaxations \ndo not typically interfere with the basic integrity of the original program, the reasoning that es\u00adtablishes \nthe validity of the integrity properties typically transfers directly from the original program over \nto the relaxed program. Re\u00adlational assertions that establish the equality of values of variables in \nthe original and relaxed executions (i.e., noninterference) often form the bridge that enables this direct \ntransfer (see Section 5). Accuracy. Relaxed programs exploit the freedom of the compu\u00adtation to, within \nlimits, produce a range of different outputs. Ac\u00adcuracy properties formalize how accurate the outputs \nmust be to stay within the acceptable range. For example, a perforatable loop may produce a range of \nacceptable results, with (typically depend\u00ading on the amount of perforation) some more accurate than \nothers. Because it is often convenient to express accuracy requirements by bounding the difference between \nresults from the original and re\u00adlaxed executions, developers can use relate statements to express accuracy \nproperties (see Section 5). Debuggability. The assume statement provides developers with the ability \nto state (formally unveri.ed) assumptions that they be\u00adlieve to be true in the original program. But \nif an assumption is not valid, the program may fail or exhibit unintended behaviors. Relaxation without \nveri.cation can therefore complicate debug\u00adging it may cause the relaxed program to violate assumptions \nthat are valid in the original program (and therefore to exhibit un\u00adintended behaviors that are not possible \nin the original program). Our proof rules, by ensuring that if the assumption is valid in the original \nprogram, then it remains valid in the relaxed program, sim\u00adplify debugging by eliminating this potential \nsource of unintended behaviors. Note that our proof rules can work together effectively to prove important \nacceptability properties. For example, the developer may use a relate statement to establish a relationship \nbetween values in variables in the original and relaxed executions, then use this relationship to prove \nthat the property speci.ed by an assert or assume statement holds in all relaxed executions. 1.5 Proof \nRules and Formal Properties We structure our proof rules as a set of Hoare logics: Axiomatic Original \nSemantics: The original Hoare-style se\u00admantics models the original execution of the program wherein relax \nstatements have no effect.  Axiomatic Relaxed Semantics: The relational Hoare-style se\u00admantics relates \nexecutions in the relaxed semantics to execu\u00adtions in the original semantics. The predicates of the judgment \nare given in a relational logic that enables us to express prop\u00aderties over the values of variables in \nboth the original and re\u00adlaxed executions of the program. A proof with the axiomatic relaxed semantics \nrelates the two semantics of the program in lockstep and, therefore, supports the transfer of reasoning \nabout the original semantics to the relaxed semantics by enabling, for example, noninterference proofs. \n  One key aspect of the axiomatic relaxed semantics is that it must also give an appropriate semantics \nfor relaxed programs in which the original and relaxed executions may branch in dif\u00adferent directions \nat a control .ow construct (at this point the two executions are no longer in lockstep). In particular, \nwe do not support relational reasoning for program points at which the executions are no longer in lockstep \n(relate statements do not have a natural semantics at such program points). Our relaxed semantics therefore \nincorporates a nonrelational axiomatic in\u00adtermediate semantics that captures the desired behavior of \nthe relaxed execution as it executes without a corresponding orig\u00adinal execution. We also appropriately \nrestrict the location of relate statements to program points at which the original and relaxed programs \nexecute in lockstep. Our proof rules are sound and establish the following semantic properties of veri.ed \nrelaxed programs: Original Progress Modulo Assumptions: If the program ver\u00adi.es under the axiomatic \noriginal semantics, then no execution of the program in the dynamic original semantics violates an assertion. \nBy design, a program may still terminate in error if a speci.ed assume statement is not valid.  Soundness \nof Relational Assertions: If the program veri.es under the axiomatic relaxed semantics, then all pairs \nof execu\u00adtions in the dynamic original and relaxed semantics satisfy the relate statements in the program. \n Relative Relaxed Progress: If the program veri.es under the axiomatic relaxed semantics and no executions \nin the dynamic original semantics violate an assertion or an assumption, then no execution in the dynamic \nrelaxed semantics violates an as\u00adsertion or an assumption.  Relaxed Progress: If the program veri.es \nunder both the orig\u00adinal and relaxed axiomatic semantics and no execution in the dynamic original semantics \nviolates an assumption, then no ex\u00adecution in the dynamic relaxed semantics violates an assertion or \nan assumption.  Relaxed Progress Modulo Original Assumptions: If the pro\u00adgram veri.es under both the \noriginal and relaxed axiomatic se\u00admantics, then if an execution in the dynamic relaxed semantics violates \nan assertion or an assumption, then an execution in the dynamic original semantics violates an assumption. \n These properties assure developers that veri.ed relaxation pro\u00adduces a program that satis.es the stated \nacceptability properties. Our design supports a development process in which developers can use the full \nrange of standard techniques (veri.cation, testing, code reviews) to validate properties that they believe \nto be true of the original program. They can then use assume statements to for\u00admally state these properties \nand incorporate them (via relational reasoning) into the veri.cation of the relaxed program. This veri.\u00adcation \nensures that if the relaxed program fails because of a violated assumption, then the developer can reproduce \nthe violated assump\u00adtion in the original program.  1.6 Coq Veri.cation Framework We have formalized \nthe dynamic original and relaxed semantics with the Coq proof assistant [1]. We have also used Coq to \nformal\u00ad ize our proof rules and obtain a fully machine-checked proof that the rules are sound with respect \nto the dynamic semantics and pro\u00advide the stated semantic properties. Our Coq formalization makes it \npossible to develop fully machine-checked veri.cations of relaxed programs. We have used our framework \nto develop and verify sev\u00aderal small relaxed programs. Our Coq implementation contains approximately \n8000 lines of code and proof scripts, with 1300 lines devoted to the original se\u00admantics and its soundness \nproofs and 1900 additional lines devoted to the relaxed semantics and its soundness proofs. A large portion \n(approximately 3500 lines) is devoted to formalizing the semantics of our relational assertion logic \nand its soundness with respect to operations such as substitution. 1.7 Contributions This paper makes \nthe following contributions: Relaxed Programming: It identi.es the concept of relaxed programming as \na way to specify nondeterministic variants of an original program. The variants often occupy a range \nof points in an underlying performance versus accuracy trade-off space. Current techniques that can produce \nrelaxed programs include skipping tasks [29, 30], loop perforation [21, 22, 35], reduction sampling [38], \nmultiple selectable implementations [3, 4, 16, 38], dynamic knobs [16], synchronization elimination [20, \n32], approximate function memoization [11], and approximate data types [34].  Relational Reasoning and \nProof Rules: It presents a basic reasoning approach and proof rules for verifying acceptability properties \nof relaxed programs. With this approach, the major\u00adity of the reasoning effort works with the original \nprogram and is transferred to the relaxed program through relational reason\u00ading.  Coq Formalization \nand Soundness Results: It presents a for\u00admalization of the dynamic semantics and proof rules in Coq. \nWe have used this formalization to prove that the proof rules are sound with respect to the dynamic original \nand relaxed se\u00admantics. We note that our Coq formalization contains a reusable implementation of our \nrelational assertion logic that is, in prin\u00adciple, suitable for other uses such as verifying traditional \ncom\u00adpiler transformations [7, 31, 36, 39].  Veri.ed Programs: It presents several relaxed programs for \nwhich we have used the Coq formalization to develop fully machine-checked veri.cations.  Relaxed programs \ncan deliver substantial .exibility, perfor\u00admance, and resource consumption bene.ts. But to successfully \ndeploy relaxed programs, developers need to have con.dence that the relaxation satis.es important acceptability \nproperties. This pa\u00adper presents a foundational formal reasoning system that leverages the structure \nand relationships that the original and relaxed execu\u00adtions share to enable the veri.cation of these \nproperties. 2. Language Syntax and Dynamic Semantics Figure 1 presents a simple imperative language with \ninteger vari\u00adables, integer arithmetic expressions, boolean expressions, condi\u00adtional statements, while \nloops, and sequential composition. For generality, we support nondeterminism in the original seman\u00adtics \nvia the havoc (X) st (B) statement which nondetermin\u00adistically assigns the variables in X to values that \nsatisfy B. The relax (X) st (B) statement supports nondeterministic relaxation in the original semantics \nit has no effect; in the relaxed seman\u00adtics it nondeterministically assigns the variables in X to values \nthat satisfy B. The language also supports the standard assume and assert statements. A main point of \ndeparture from standard languages is the addition of relational integer expressions (E *) and relational \nboolean expressions (B *). Unlike standard expressions, which involve values from only the current execution, \nrelational ex\u00adpressions can reference values from both the original (x(o)) and iop ::= + |-|* | / | \n... cmp ::= < | > | = | ... lop ::= .|.| ... X ::= x | x,X E ::= n | x | E iop E E * ::= n | x(o)| x(r)| \nE * iop E * B ::= true | false | E cmp E | B lop B |\u00acB * ***** B ::= true | false | E cmp E | B lop \nB |\u00acB S ::= skip | x= E | havoc (X) st (B) | relax (X) st (B) | if (B) {S1} else {S2}| while (B) {S} \n| assume B | assert B | relate l : B * | S ; S Figure 1. Language Syntax [E] . S . Z [n](s)= n [x](s)= \ns(x) [ E1 iop E2](s)= [E1](s) iop [E2](s) [E *] . S \u00d7 S . Z [n](s1,s2)= n [x(o)](s1,s2)= s1(x) [x(r)](s1,s2)= \ns2(x) *** * [E1 iop E2 ](s1,s2)= [E1 ](s1,s2) iop [E2 ](s1,s2) [B] . S . B [true](s)= true [false](s)= \nfalse [E1 cmp E2](s)= [E1](s) cmp [E2](s) [B1 lop B2](s)= [B1](s) lop [B2](s) true, [B](s)= false [\u00acB](s)= \nfalse, [B](s)= true [B *] . S \u00d7 S . B [true](s1,s2)= true [false](s1,s2)= false *** * [E1 cmp E2 ](s1,s2)= \n[E1 ](s1,s2) cmp [E2 ](s1,s2) *** * [B1 lop B2 ](s1,s2)= [B1](s1,s2) lop [B2 ](s1,s2) *true, [B *](s1,s2)= \nfalse [\u00acB ](s1,s2)= false, [B *](s1,s2)= true expr [e](s)= n bexp [b](s)= v (e, s).E n (b, s).B v Figure \n2. Semantics of Expressions relaxed (x(r)) executions. These relational expressions enable relate statements \nto specify relationships that must hold between the original and relaxed executions. For example, the \nstatement relate l : x(o) = x(r) asserts that at the current program point (with label l), x must have \nthe same value in both executions. 2.1 Semantics of Expressions Figure 2 presents the semantics of expressions \nin the language. The denotations of expressions are functions mapping a state or pair of states to either \nan integer (Z) or boolean value (B).A state(s) is a .nite map from program variables, Vars, to integers, \nZ, and is .n an element of the domain S= Vars . Z, which is the set of all .nite maps from variables \nto integers. The semantic function [E] de.nes the semantics for integer expressions, which are composed \nof the standard integer opera\u00adtions (e.g., +, -, *,/, ...) on integer operands. The semantic func\u00adtion \n[B] de.nes the semantics of boolean expressions, which are composed of the standard comparison operators \non integers (e.g., <, =,>, ...) and the standard boolean operators (e.g., ., ., ...). The semantic function \n[E *] de.nes the semantics for relational integer expressions as a function mapping a pair of states \n(s1,s2) to an integer number. Our convention is to have the .rst component of the state pair be a state \nfrom the original semantics and the second component a state from the relaxed semantics. Therefore, a \nreference to a variable in the original semantics, x(o), is equivalent to s1(x) whereas a reference to \na variable, x(r), in the relaxed semantics is equivalent to s2(x). The semantic function [B *] likewise \nextends the semantics for boolean expressions with the capability to express boolean properties over \nrelational integer expressions. 2.2 Dynamic Original Semantics Figure 3 presents the dynamic original \nsemantics of the program in a big-step operational style. The evaluation relation (s, s).o f denotes \nthat evaluating the statement s in the state s yields the output con.guration f. An output con.guration \nis an element in the domain F= {ba}.{wr}. (S \u00d7 .). The distinguished element ba ( bad assume ) denotes \nthat the program has failed at an assume statement in the program. The distinguished element wr ( wrong \n) denotes that the program has failed due to another error, such as an unsatis.ed assert statement. An \nelement in the domain S \u00d7 . indicates that the program has terminated successfully, yielding a .nal state \ns and an observation list, . . ., which is the sequence of observations emitted by relate statements \nduring the execution of the program. An observation (l, s) is an element in the domain L \u00d7 S. L is the \n.nite domain consisting of all the labels speci.ed in relate statements in the program the execution \nof each relate statement emits an observation consisting of its label along with the current state of \nthe program. The structure of an observation list is given by the standard constructors for lists: .= \n\u00d8| (l, s) :: .. We also use the notation .1..2 to denote the result of appending two lists. Evaluation \nRules The rules for skip, assignment, if, sequential composition, and while statements follow the standard \nsemantics for these con\u00adstructs. The semantics for nonstandard constructs are as follows: Havoc. The \nhavoc (X) st (e) statement nondeterministically as\u00adsigns values to the set of variables in X such that \ntheir values satisfy the statement s predicate e. All variables not speci.ed in X retain their previous \nvalues. If there does not exist an assignment of values to X that satisfy e, then the statement evaluates \nto wr. Assert. The assert e statement checks that the state satis.es its predicate e. If e evaluates \nto true, then execution continues; other\u00adwise, the statement evaluates to wr. Assume. The assume e statement \nchecks that the state satis.es its predicate e. If e evaluates to true, then execution continues; otherwise, \nthe statement evaluates to ba. Relax. The relax (X) st (e) statement does not modify the state of the \nprogram in the original semantics. Because we require the (e, s).E n skip assign (s, s).o f (skip,s).o \n(s, \u00d8) (x = e, s).o (s[x . n], \u00d8) (e, sI).B true .x .X \u00b7 s(x)= sI(x) \u00ac.s1 \u00b7 ((e, sI).B true ..x .X \u00b7 \ns(x)= sI(x)) havoc-t havoc-f I (havoc (X) st (e),s).o (s, \u00d8) (havoc (X) st (e),s).o wr (e, s).B true \n(e, s).B false (e, s).B true assert-t assert-f assume-t (assert e, s).o (s, \u00d8) (assert e, s).o wr (assume \ne, s).o (s, \u00d8) (e, s).B false (assert e, s).o f assume-f relax relate (assume e, s).o ba (relax (X) st \n(e),s).o f (relate l : e * ,s).o (s, (l, s)) (b, s).B true (s1,s).o f (b, s).B false (s2,s).o f (s1,s).o \n(sI,.1)(s2,sI).o (sII,.2) if-t if-f seq (if (b) {s1} else {s2},s).o f (if (b) {s1} else {s2},s).o f (s1 \n; s2,s).o (sII,.2..1) (b, s).B false (b, s).B true (s, s).o (sI,.1)(while (b) {s},sI).o (sII,.2) while-f \nwhile-t (while (b) {s},s).o (s, \u00d8) (while (b) {s},s).o (sII,.2..1) Figure 3. Dynamic Original Semantics \n(s, s).r f (havoc (X) st (e),s).r f relax (relax (X) st (e),s).r f Figure 4. Dynamic Relaxed Semantics \noriginal execution to be one of the relaxed executions, the dynamic original semantics requires the relaxation \npredicate e to hold in the original execution. Relate. The relate l : e * statement is a relational assertion \nover original and relaxed executions of the program. The dynamic se\u00admantics emits an observation consisting \nof the statement s label l along with the current state of the program. This semantics enables us to \nde.ne and verify a relation on the observation lists emitted by the original and relaxed programs (see \nSection 4). We omit the standard rules for propagating errors (ba and wr) through the program. However, \nthe reader can refer to our previous technical report for further details [9].  2.3 Dynamic Relaxed \nSemantics Figure 4 presents an abbreviated version of the dynamic relaxed semantics. The relation (s, \ns).r f denotes that evaluating the statement s in the state s yields the output con.guration f. The dynamic \nrelaxed semantics builds upon the original seman\u00adtics. It differs only in that relax statements modify \nthe state of the program. We therefore omit the presentation of all the rules that are either reused \n(skip, assignment, havoc, assert, and assume) or adapted to refer to the relaxed dynamic semantics in \ntheir premises (i.e., sequential composition, if, and while). Relax. The relax (X) st (e) statement nondeterministically \nmodi.es the state of the program in the relaxed semantics so that it satis.es the statement s predicate \ne. The rule implements the modi.cation by reusing the rule for havoc statements. 3. Axiomatic Semantics \nWe next present axiomatic semantics for relaxed programs. Axiomatic Original Semantics. The proof rules \nmodel the dynamic original semantics of the program. If the program veri.es with these rules, then no \nexecution of the program in the dynamic original semantics violates an assertion (i.e., evaluates to \nwr). However, the program may dynamically violate an assumption (i.e., evaluate to ba). P ::= true | \nfalse | E cmp E | P lop P |\u00acP |.x \u00b7 P * ***** P ::= true | false | E cmp E | P lop P |\u00acP |.x(o) \u00b7 P * \n|.x(r) \u00b7 P * Figure 5. Relational Assertion Logic Syntax [ P ] .P(S) [ true] =S [ false] = \u00d8 [ E1 cmp \nE2] = {s | [E1](s) cmp [E2](s)} [ P1 lop P2 ] = {s | s . [ P1] lop s . [ P2] } [ \u00acP ] = [ true] \\ [ P \n] [ .x \u00b7 P ] = {s | n . Z,s . [ P [n/x]]]} [ P * ] .P(S \u00d7 S) [ true] =S \u00d7 S[ false] = \u00d8 ** ** [ E1 \ncmp E2 ] = {(s1,s2) | [E1 ](s1,s2) cmp [E2 ](s1,s2)} ** ** [ P1 lop P2 ] = {(s1,s2) | (s1,s2) . [ P1 \n] lop (s1,s2) . [ P2 ] } [ \u00acP * ] = [ true] \\ [ P * ] [ .x(o) \u00b7 P * ] = {(s1,s2) | n . Z, (s1,s2) . [ \nP * [n/x(o)]]]} [ .x(r) \u00b7 P * ] = {(s1,s2) | n . Z, (s1,s2) . [ P * [n/x(r)]]]} Figure 6. Relational \nAssertion Logic Semantics Axiomatic Relaxed Semantics. The proof rules model pairs of executions of the \nprogram in the dynamic original and dynamic relaxed semantics. If the program veri.es with these rules, \nthen if all executions in the original semantics execute without error (i.e., do not evaluate to wr or \nba), then all executions in the relaxed semantics execute without error. A proof with these rules also \nguarantees that pairs of original and relaxed executions satisfy all of the relate statements in the \nprogram. 3.1 Relational Assertion Logic Figure 5 presents the concrete syntax of our relational assertion \nlogic. This logic extends a nonrelational assertion logic with rela\u00adtional formulas, which then allows \nus to reason about the validity of relational boolean expressions in relate statements. Its presen\u00adtation \nfollows the style of Benton s Relational Hoare Logic [7]. fo {P } s {Q} fo {P } s1 {R}fo {R} s2 {Q} \nskip seq assign fo {P } skip {P }fo {P } s1; s2 {Q}fo {Q[e/x]} x= e {Q} [(.X1 \u00b7 P [XI/X]) . e] fresh(XI) \n= \u00d8 havoc assert fo {P } havoc (X) st (e) {(.X1 \u00b7 P [XI/X]) . e}fo {P . e} assert e {P . e} assume fo \n{P } assume e {P . e} relax fo {P } assert e {Q}fo {P } relax (X) st (e) {Q} iffo {P . b} s1 {Q} fo {P \n. \u00acb} s2 {Q}fo {P } if (b) {s1} else {s2} {Q} relate fo {P } relate l : e * {P } while fo {P . b} s {P \n}fo {P } while (b) {s} {P . \u00acb} conseq |= P . P I fo {P I} s {QI} |= QI . Q fo {P } s {Q} Figure 7. \nAxiomatic Original Semantics 3.1.1 Syntax The syntactic category P gives the syntax for formulas in .rst\u00adorder \nlogic with integer expressions and existential quanti.cation. The syntactic category P * gives corresponding \nsyntax for writing relational formulas. P * extends P by allowing formulas to refer to relational integer \nexpressions.  3.1.2 Semantics Figure 6 presents the semantics of formulas in the logic. The deno\u00adtation \nof a nonrelational formula [ P ] is the set of states that satisfy the formula. [ P ] reuses the semantic \nde.nitions for integer expres\u00adsions from Figure 2 to construct a de.nition for each formula. The denotation \nof a relational formula [ P * ] closely follows that of non\u00adrelational formulas: it is the set of pairs \nof states that satisfy the re\u00adlation. References to the original semantics (e.g., x(o)) refer to the \n.rst component of the pair and references to the relaxed semantics (e.g., x(r)) refer to the second component. \nInjections. We de.ne injection functions injo(P ) and injr(P ), which construct a relational formula \nin P * from a nonrelational formula in P . Conceptually, injo(P ) constructs a relational for\u00admula where \nP holds for the original semantics by replacing vari\u00adables (e.g., x) in P with the relational original \nvariables (e.g., x(o)); injr(P ) does the same with the relational relaxed variables such that P holds \nfor the relaxed semantics. This means that injo(P ) (resp. injr(P )) creates a formula representing all \nstate pairs where the .rst (resp. second) component satis.es P : [ injo(P )]] = {(s1,s2) | s1 . [ P ] \n}[ injr(P )]] = {(s1,s2) | s2 . [ P ] } We also de.ne the notation (P1 \u00b7 P2) for combining a predicate \nP1 over the original semantics with a predicate P2 over the relaxed: (P1 \u00b7 P2)= injo(P1) . injr(P2) Projections. \nWe de.ne two semantic functions prjo(P * ) and prjr(P * ). Each function projects a relational formula \nin P * to the set of states corresponding to either the .rst (prjo) or second (prjr) component of each \nstate pair in the denotation of the formula: prjo(P * ) ={s1 | (s1,s2) . [ P * ] } prjr(P * ) ={s2 | \n(s1,s2) . [ P * ] } The projection functions allow us to decompose a relational for\u00admula over the original \nand relaxed semantics into the set of states that satisfy the relation for either the original or relaxed \nsemantics individually. We use projection to de.ne the following relations be\u00adtween relational and nonrelational \nformulas: P * |= o P = prjo(P * ) . [ P ] P * |= r P = prjr(P * ) . [ P ]  Fresh Variables and Substitution. \nThe predicate fresh(x), de\u00adnoting that x is a fresh variable in the context of an inference rule, is \ntrue if x . Vars and x does not appear in the rule s premises or consequent. Our proof rules also use \nthe standard capture-avoiding substitution P [e/x]. We denote multiple substi\u00adtution P [e1/x1] \u00b7\u00b7\u00b7 [en/xn] \nas P [e1, \u00b7\u00b7\u00b7 ,en/x1, \u00b7\u00b7\u00b7 ,xn]. We de\u00ad.ne substitution over P * similarly. Auxiliary Notations. We also \nde.ne the following judgments for later use in both the rules of our program logics and the discussion \nof their semantics: s |= P = s . [ P ] (s1,s2) |= P * = (s1,s2) . [ P * ] ** * |= P1 . P2 = [ P1] . \n[ P2] |= P1 . P2 = [ P1 ] . [ P2]  3.2 Original Semantics Figure 7 presents a manual translation of \nour Coq formalization of the axiomatic original semantics of the program. The Hoare\u00adstyle judgment fo \n{P } s {Q} models the original execution of the program wherein relax statements have no effect. The \nintended meaning of the semantic judgment |= o {P } s {Q} is: for all states s, if s |= P and (s, s).o \n(sI,.), then sI |= Q. In other words, if s satis.es P and an original execution of s from s yields a \nnew state sI, then sI satis.es Q. We note that this de.nition asserts only partial correctness and not \ntotal correctness. We have elided a discussion of the rules for standard constructs (i.e., skip, assign, \nsequential composition, if, while, and conse\u00adquence) because their de.nitions are the same as in standard \npre\u00adsentations (e.g., Floyd [14] and Hoare [15]). We de.ne the nonstan\u00addard rules as follows: The havoc \nrule requires in its premise that e must be satis.able by adjusting only the variables in X while retaining \nthe values of other variables. A havoc statement evaluates to wr only if there is no way to transform \nthe current state into a new state satisfying e just by changing the variables in X. The assert rule \nrequires the predicate e to hold in the precondition. The rule therefore requires a proof of e. The assume \nrule differs from the assert rule in that it assumes the validity of e and then makes e part of the postcondition. \nBecause there is no obligation to prove e for an assume statement, e may not hold for all states that \nsatisfy P and, as a result, the assume may evaluate to ba. However, by design, we allow assume statements \nto fail in the dynamic original semantics. The relax rule speci.es that a relax statement is a no-op \nthat does not change the program s state in the original semantics. Our de.nition of relaxation, however, \nrequires that the original execution must still satisfy e. To enforce this constraint, the rule reuses \nthe rule for the assert statement. fr {P * } s {Q * } P * |= o Po P * |= r Pr fo {Po} s {Qo}fi {Pr} \ns {Qr} no rel(s) diverge fr {P * } s {(Qo \u00b7 Qr)} [(.X1(r) \u00b7 P * [XI(r)/X(r)]) . injr(e)] = \u00d8 fresh(XI) \nrelax relate fr {P * } relax (X) st (e) {(.X1(r) \u00b7 P * [XI(r)/X(r)]) .(e \u00b7 e)} fr {P * . e * } relate \nl : e * {P * . e * } |= P * . injo(e) . injr(e) |= P * .(b \u00b7 b) . (\u00acb \u00b7\u00acb)fr {P * .(b \u00b7 b)} s1 {Q * }fr \n{P * . (\u00acb \u00b7\u00acb)} s2 {Q * } assert if fr {P * } assert e {P * .(e \u00b7 e)} fr {P * } if (b) {s1} else {s2}{Q \n* } |= P * . injo(e) . injr(e) |= P * .(b \u00b7 b) . (\u00acb \u00b7\u00acb)fr {P * .(b \u00b7 b)} s {P * } assume while fr \n{P * } assume e {P * .(e \u00b7 e)} fr {P * } while (b) {s}{P * . (\u00acb \u00b7\u00acb)} Figure 8. Axiomatic Relaxed Semantics \nThe relate rule gives relate statements the same semantics as skip because, unlike the axiomatic relaxed \nsemantics (see Sec\u00adtion 3.3), the axiomatic original semantics references only a single execution of \nthe program and does not use relational reasoning.  3.3 Relaxed Semantics Figure 8 presents a manual \ntranslation of our Coq formalization of the axiomatic relaxed semantics of the program. The proof rules \nfor the relaxed semantics are relational in that they relate exe\u00adcutions of the program under the dynamic \nrelaxed semantics to executions under the dynamic original semantics. The intended meaning of each judgment \n|= r {P * } s {Q * } is the partial cor\u00adrectness assertion: if (so,sr) |= P * , (s, so).o (soI ,.1), \nand (s, sr).r (srI ,.2), then (soI ,srI ) |= Q * . The rules are designed to transfer the reasoning from \nthe ax\u00adiomatic original semantics to prove properties about the axiomatic relaxed semantics. Speci.cally, \nthe axiomatic relaxed semantics need not re-prove properties about the dynamic original semantics (e.g., \nthe validity of assert statements). It can instead simply as\u00adsume that these properties are established \nby the axiomatic original semantics and then transfer their validity to the relaxed semantics via relational \nreasoning. We have elided discussions of most of the standard rules. The nonstandard rules operate as \nfollows: The relax rule distinguishes the semantics of relaxation in the original and relaxed semantics \nof the program. The rule is similar to the havoc rule in the axiomatic original semantics except that \n1) it deals with a relational formula and 2) the rule only modi.es (i.e., substitutes) relaxed variables, \nsuch as x(r), whereas variables over the original semantics x(o) are not modi.ed. We use a shorthand \nX(r)={x(r)| x . X} to denote the syntactic extension of a set of variables in X to relaxed variables. \nThe relate rule enables us to reason about relate statements in the program. Similar to a nonrelational \nassertion, the rule requires e * to hold in the precondition. This ensures that e * holds for all pairs \nof original and relaxed executions that reach the statement. The assert rule demonstrates how we can \nuse relational reasoning to prove assertions in the relaxed semantics. Speci.cally, we can .rst assume \nthat the assertion is true in the original semantics (i.e., injo(e)) because it has been veri.ed with \nthe axiomatic original semantics. If P * . injo(e) implies injr(e), we can then conclude that the assertion \nis true in the relaxed semantics (i.e., injr(e)). For example, if the precondition of the statement assert \ne re\u00adquires all of the free variables in e to be the same in both semantics (i.e., for all x . free(e), \nx(o) == x(r)), then because the axiomatic original semantics proves that the assertion is true in the \ndynamic original semantics, we can conclude that the assertion is also true in the dynamic relaxed semantics. \nThe assume rule demonstrates how relational reasoning allows us to use relations between the original \nand relaxed semantics of the fi {P } havoc (X) st (e) {Q} relax fi {P } s {Q} fi {P } relax (X) st (e) \n{Q} assume fi {P . e} assume e {P . e} Figure 9. Axiomatic Intermediate Semantics program to reason \nabout assumptions in the relaxed semantics in the same way as we do for assertions i.e., if the assumption \nis true in the original semantics of the program, then it is also true in the relaxed semantics. Convergent \nand Divergent Control Flow. An important aspect of relaxed programs is that the original and relaxed \nexecutions of a program may branch in different directions at a control .ow con\u00adstruct. Speci.cally, \nif two executions branch in the same direction, then we can continue to reason about them relationally \nin lockstep. However, if the two executions diverge, then the executions execute different statements \nand, as a result, we lose our relational reason\u00ading power. We note that it is possible for two executions \nto diverge at a control .ow construct and then converge again at the end of the construct, allowing us \nto regain our relational reasoning power. The relaxed axiomatic semantics captures this property via \na set of proof rules for convergent control .ow constructs (i.e., the orig\u00adinal and relaxed executions \nalways branch in the same direction) and another set for divergent control .ow constructs. 1 3.3.1 Convergent \nControl Flow The if rule allows us to continue to use relational reasoning inside an if statement if \nit has convergent control .ow. We establish this convergence by checking that for all s1,s2, if (s1,s2) \n|= P * then the conditional s boolean expression either evaluates to true in both the original and relaxed \nsemantics or it evaluates to false in both semantics. If so, then in all cases, the original and relaxed \nsemantics take the same branch together. Otherwise control .ow may diverge and the rule cannot be applied. \nThe while rule is similar in form to the if rule in that it requires that control .ow be convergent to \nallow us to continue to use relational reasoning within the body of a while statement. 3.3.2 Divergent \nControl Flow The diverge rule enables a proof to proceed if the original and relaxed semantics diverge \nat a control .ow construct. The rule establishes the postcondition of the statement by independently \nestablishing that fo {Po} s {Qo} for the original semantics and that fi {Pr} s {Qr} for the relaxed semantics, \nwhere Po and Pr are left and right projections of P *. The judgment fi {Pr} s {Qr} 1 We provide a detailed \nformalization of convergent control .ow in the supplementary material of this paper on the ACM Digital \nLibrary. is a set of proof rules for the axiomatic intermediate semantics of the program. Figure 9 gives \nan abbreviated presentation of the program logic for the intermediate semantics of the program. The axiomatic \nintermediate semantics is a nonrelational char\u00adacterization of the dynamic relaxed semantics and is very \nsimi\u00adlar to the axiomatic original semantics. The intended meaning of the judgment |=i {P } s {Q} is: \nfor all states s, if s |= P and (s, s).r (sI,.), then sI |= Q. This semantics differs from the axiomatic \noriginal semantics in two ways: The relax rule speci.es that relax (X) st (e) may apply any modi.cation \nto the variables in X as long as the new values satisfy e. In the axiomatic original semantics the relax \nstatement is a no-op.  The assume rule requires (just as for assert statements) a proof that e holds \nin relaxed executions. The goal is to ensure that the relaxation does not invalidate the reasoning used \nto establish that e holds in the original program. In the axiomatic original semantics there is no such \nproof obligation e is simply assumed to be valid.  We conclude the presentation of the diverge rule \nby noting that it is also guarded by the predicate no rel(s), which evaluates to true if no relate statements \nappear within s. This predicate therefore prevents relate statements from appearing in divergent control \n.ow statements where we are unable to use relational reasoning to establish that the relate statement \nis satis.ed. We also note that the use of projections by |= o and |= r in this rule means that all relationships \nbetween the two semantics are lost and must be reestablished at the end of the statement. Relationships \nthat are not modi.ed by the statement, however, can be preserved via a relational frame rule. 4. Properties \nWe now present the technical de.nitions, lemmas, and theorems that establish the semantic properties \nof programs in the language. The key property of our language and proof rules is Relative Relaxed Progress \n(Section 4.3), which states that our proof rules guarantee that if the original program executes without \nerror, then the relaxed program executes without error. This property enables a developer to combine \na proof in the axiomatic original seman\u00adtics with formally unveri.ed assumptions to demonstrate that \nthe original program is error free. The developer can then augment this reasoning with a proof in the \naxiomatic relaxed semantics to therefore show that the relaxed program is error free. An impor\u00adtant consequence \nof this formulation is that if a formally unveri.ed assumption is not valid and produces unintended behaviors \nin the program, then these behaviors can be reproduced and debugged in the original program. In our formalization, \nwe restrict ourselves to terminating re\u00adlaxed programs. Also, while we only present brief proof sketches, \nthe full sources of our Coq formalization and proofs are available online at http://groups.csail.mit.edu/pac/acceptability \n 4.1 Original Semantics Our axiomatic de.nition for the original semantics is sound and can be used \nto establish a weak form of the traditional progress theorem for programs. Speci.cally, if you can write \na proof in the axiomatic original semantics and an execution in the original semantics termi\u00adnates, then \nthe resulting state is not wr. This differs from a strong form of progress that establishes the same \nfor all programs (includ\u00ading nonterminating programs), which would require a small-step or coinductive \nformalization of our dynamic semantics. Lemma 1 (Soundness). If fo {P } s {Q}, then |= o {P } s {Q} \n This lemma establishes that our axiomatic de.nition is sound with respect to the dynamic original semantics \nof the program. More speci.cally, given a proof fo {P } s {Q}, it is the case that for all states s |= \nP , if (s, s).o (sI,.), then sI |= Q. Proof Sketch. This proof proceeds by induction on the rules of \nfo {P } s {Q}. A large portion of the proof effort involves proving the semantics of substitution in \nthe case of the assignment rule and the havoc rule. The case of the havoc rule also requires mutual induction \non the lists of modi.ed and fresh variables to establish that the post-condition holds. The cases for \nstructural rules (if and sequential composition) follow from induction and the case for the while statement \nproceeds by nested induction on derivations of the evaluation relation. Lemma 2 (Original Progress Modulo \nAssumptions). If fo {P } s {Q}, and s |= P , and (s, s).o f , then f = wr This lemma establishes the \nprogress property that we desire for the original semantics. Speci.cally, given a proof in the original \naxiomatic semantics, then for all states that satisfy P , if execution terminates, then the execution \ndoes not yield wr. By design, the judgment does not preclude the program from evaluating to ba (indicating \nthat it has violated an assumption). Proof Sketch. This proof proceeds by induction on the rules of fo \n{P } s {Q}. We only need to consider three primitive state\u00adments where the program may evaluate to wr: \nhavoc (the satis\u00ad.ability check in the premise guards against this), assert e (the fact that e must hold \nin the precondition guards against this), and relax (follows by induction because execution of a relax \nstate\u00adment reduces to execution of an assert statement). 4.2 Intermediate Semantics The axiomatic relaxed \nsemantics establishes several progress prop\u00aderties about the relaxed execution of the program. However, \nto prove progress for the axiomatic relaxed semantics, we need to .rst prove the same for the axiomatic \nintermediate semantics. The de.nition for the axiomatic intermediate semantics is sound and, also, establishes \na form of progress for the relaxed semantics of the program. Speci.cally, the intermediate semantics \nmodels the behavior of a relaxed execution after it has branched at a control .ow construct in a different \ndirection than an original execution. When this happens, the relaxed execution must not violate asser\u00adtions \n(evaluate to wr) or violate assumptions (evaluate to ba). Lemma 3 (Soundness). If fi {P } s {Q}, then \n|=i {P } s {Q} This lemma establishes that our axiomatic de.nition is sound with respect to the dynamic \nrelaxed semantics: given a proof fi {P } s {Q}, it is the case that for all states s |= P , if (s, s).r \n(sI,.), then sI |= Q. Proof Sketch. This proof proceeds by induction on the rules of fi {P } s {Q}. Because \nthe axiomatic intermediate semantics reuses a large portion of the axiomatic original semantics, and \nthe de.nition of the dynamic relaxed semantics is very similar to that of the dynamic original semantics, \nthe vast majority of the proof follows from the proofs in Lemma 1. Lemma 4 (Progress). If fi {P } s \n{Q}, and s |= P , and (s, s).r f, then \u00acerr(f) where err(f) = f = wr . f = ba This lemma establishes \nthe progress property that we desire for the axiomatic intermediate semantics. Speci.cally, given a proof \nfi {P } s {Q}, it is the case that for all states that satisfy P , if execution terminates, then the \nexecution does not yield an error. Note that this guarantee is stronger than that for the axiomatic original \nsemantics in that it does not allow a relaxed execution to violate an assumption whereas an original \nexecution may do so. Proof Sketch. The proof proceeds by induction on the rules of fi {P } s {Q}. As \nin the proof of soundness (Lemma 3), the vast majority of the proof follows from our proofs about the \nax\u00adiomatic original semantics; in this case most of the proof follows directly from Lemma 2 (Original \nProgress Modulo Assumptions). The proof differs for two statements: relax (the proof follows by induction \nbecause execution of a relax statement reduces to the execution of a havoc) and assume (the proof also \nfollows by induction as execution of an assume reduces to an assert).  4.3 Relaxed Semantics Lemma 5 \n(Soundness). If fr {P * } s {Q * }, then |= r {P * } s {Q * } This lemma establishes that our axiomatic \nde.nition is sound with respect to the original and relaxed semantics of the pro\u00adgram. Speci.cally, given \na proof fr {P * } s {Q * }, it is the case that for all states (so,sr) |= P *, if (s, so).o (sI ,.1) \nand (s, sr).r (srI ,.2), then (soI ,srI ) |= Q * . o Proof Sketch. The proof proceeds by induction on \nthe rules of fr {P * } s {Q * }. The proof is largely similar to that for the orig\u00adinal axiomatic semantics \nin that much of the work lies in proving the semantics of substitution for the relax statement, which \nhas a proof that is similar to havoc in the original axiomatic semantics. The cases for structural rules \n(if and sequential composition) fol\u00adlow from induction and the case for the while statement proceeds \nby nested mutual induction on derivations of the original and re\u00adlaxed execution of the statement. The \nmost distinct case is the rule for diverge: this proof uses the soundness of the original axiomatic semantics \n(Lemma 1) and the soundness of the intermediate ax\u00ad iomatic semantics (Lemma 3) to establish the soundness \nof the rule for executions in which the original and relaxed executions branch in different directions \nat a control .ow construct. Theorem 6 (Soundness of Relational Assertions). If fr {P * } s {Q * }, and \n(so,sr) |= P * , and (s, so).o (soI ,.1), and (s, sr).r (srI ,.2), then G f .1 ~ .2 This theorem establishes \nthat given a proof in the relaxed ax\u00adiomatic semantics, if the original execution of the program termi\u00adnates \nsuccessfully and the relaxed execution of the program termi\u00adnates successfully, then the observation \nlists generated by the exe\u00adcutions (.1 and .2, respectively) satisfy the observational compat\u00adibility \nrelation G f .1 ~ .2. Observational compatibility implies that the original and relaxed executions of \nthe program satisfy all executed relate statements; we de.ne the relation as follows: [G(l)](s1,s2)= \ntrue G f .1 ~ .2 G f\u00d8~\u00d8 G f (l, s1) :: .1 ~ (l, s2) :: .2 The symbol G represents a .nite map from relate \nlabels to relational boolean expressions (i.e, G . L . B *). We de.ne this map by structural induction \non the syntax of the program, where the label of each relate statement in the program maps to its relational \nboolean expression. We require that relate statements in well-formed programs be uniquely labeled. The \nrules specify that if two observations lists are empty, then they are compatible. Otherwise, any two \nlists are compatible if 1) the labels in the head are the same (indicating that they are generated by \nthe same relate statement), 2) the relational boolean expression for the label evaluates to true for \nthe states in the head, and 3) the tails of the two lists are also compatible. Proof Sketch. This proof \nproceeds by induction on the rules of fr {P * } s {Q * }. The two interesting cases are the diverge rule \nand the rule for relate statements. For the diverge rule, we use the fact that the rule requires no rel(s) \n(which requires that no relate statements appear inside s). We can therefore conclude that the observation \nlist for the statement is empty and, therefore, original and relaxed executions of the statement are \ntrivially compatible. In the case of the relate rule, the proof uses the rule s precondition to establish \nthat the two emitted observations satisfy the relate statement s condition. Theorem 7 (Relative Relaxed \nProgress). If fr {P * } s {Q * }, and (so,sr) |= P * , and (s, so).o fo, and \u00acerr(fo), and (s, sr).r \nfr, then \u00acerr(fr) This theorem establishes the relative progress guarantee for the relaxed semantics \nof the program. Speci.cally, given a proof fr {P * } s {Q * } , it is the case that for all pairs of \nstates (so,sr) that satisfy P *, if an original execution terminates and does not produce an error, then \nif a relaxed execution terminates, it also does not produce an error. Proof Sketch. This proof proceeds \nby induction on the rules of fr {P * } s {Q * }. The most important cases are the assert and assume statements \nand the diverge rule. The proofs for assert and assume are similar in that the premise ensures that if \nthe original execution evaluates to true, then the condition also evaluates to true in the relaxed execution. \nWe do not have to consider the case where the original execution evaluates to false because this would \nimply that fo = wr .fo = ba, which is inconsistent with the assumption that \u00acerr(fo). The diverge rule \ndemonstrates the utility of our design of the ax\u00adiomatic intermediate semantics. For this rule, we can \nno longer use facts about the original execution to prove facts about the relaxed execution. Therefore, \nthe relaxed execution must be inherently er\u00adror free. The proof uses the progress guarantee of the axiomatic \nintermediate semantics (Lemma 4) to establish exactly that. Theorem 8 (Relaxed Progress). If fo {P } \ns {Q}, and fr {P * } s {Q * }, and P * |= o Po, and (so,sr) |= P * , and (s, so).o fo, and fo = ba, and \n(s, sr).r fr, then \u00acerr(fr). This theorem combines the multiple proofs and assumptions in our programming \nmodel to establish the main progress guarantee for relaxed programs: given 1) a proof in the original \naxiomatic semantics, 2) a proof in the relaxed axiomatic semantics, and 3) that executions in the original \nsemantics terminate and do not violate an assumption, then if a relaxed execution terminates, it does \nnot produce an error. Proof Sketch. This proof follows directly from our assumptions, Lemma 2 (Original \nProgress Modulo Assumptions), and Theo\u00adrem 7 (Relative Progress). Our assumptions and Lemma 2 establish \nthat if an original execution terminates, then it does not terminate in error. By Theorem 7, we can conclude \nthat if a relaxed execution terminates, it does not produce an error. Corollary 9 (Relaxed Progress Modulo \nOriginal Assumptions). If fo {P } s {Q}, and fr {P * } s {Q * }, and P * |= o Po, and (so,sr) |= P * \n, and (s, sr).r fr, and err(fr), If (s, so).o fo, then fo = ba This corollary of Theorem 8 captures an \nimportant aspect of how our programming model incorporates assumptions, which may cause errors in both \noriginal and relaxed executions. Given proofs in the original and relaxed axiomatic semantics, if an \nerror occurs in a relaxed execution and the original execution terminates, the orig\u00adinal execution must \nviolate an assumption. Errors in the relaxed program therefore correspond to invalid assumptions in the \norigi\u00adnal program. To debug an error in a relaxed execution, a developer should therefore look for invalid \nassumptions in the original pro\u00adgram. 5. Example Relaxed Programs Inspired by programs that researchers \nhave successfully relaxed in prior work, we developed several example programs designed to capture the \ncore aspects of the successful relaxations. We then formalized key acceptability properties of the relaxations \nand used our Coq formalization to prove these properties. 5.1 Dynamic Knobs Swish++ is an open-source \nsearch engine. We work with a success\u00adful relaxation that uses Dynamic Knobs to reduce the number of \nsearch results that Swish++ presents to the user when the server is under heavy load [16]. The rationale \nfor this relaxation is that 1) users are typically only interested in the top search results and 2) users \nare very sensitive to how quickly the results are presented even a short delay can signi.cantly reduce \nadvertisement revenue. Relaxation. The transformation targets a loop that formats and presents the search \nquery results. The loop keeps track of the number of search results, which we denote by N. The loop also \nhas a control variable max_r which is a threshold on the number of elements that should be presented \nto the user: if N is smaller than max_r, then all results will be presented; otherwise, only the .rst \nmax_r results will be presented. A relaxed program can nondeterministically change max_r to reduce the \nnumber of iterations of this loop while still returning the most important results: original_max_r = \nmax_r; relax (max_r) st (original_max_r <= 10 &#38;&#38; max_r == original_max_r) || (10 < original_max_r \n&#38;&#38; 10 <= max_r); This code .rst saves the original value of the control variable max_r in original_max_r. \nIt then relaxes max_r. There are two cases: if the original value of this control variable was less than \nor equal to 10, then the relaxed execution should be the same as the original execution it presents \nthe same number of results, since the value of max_r does not change. If, on the other hand, the original \nvalue was greater than 10, the only constraint is that the value of max_r is not smaller than 10, meaning \nthat it should return at least the top 10 results when available. The relax statement nondeterministically \nchanges max_r subject to these constraints. Acceptability. One acceptability property is that the relaxed \nexe\u00adcution must present either all of the search results from the original execution to the user (if \nthe number of search results in the original execution is less than or equal to 10), or at least the \n.rst 10 results (if the number of results in the original execution is greater than 10). The following \nrelate statement captures these constraints: relate (num_r<o> < 10 &#38;&#38; num_r<o> == num_r<r>) || \n(10 <= num_r<o> &#38;&#38; 10 <= num_r<r>); The loop that formats and presents the search results maintains \na count num_r of the number of formatted and presented results. This statement therefore uses the value \nof num_r in the original program (denoted num_r<o>) to determine how many search re\u00adsults the original \nexecution presents. The relate statement uses num_r<o> and the (potentially different) value of num_r \nin the re\u00adlaxed execution (num_r<r>) to formalize the desired relationship between the two executions. \nVeri.cation. The proof of the relate statement involves 330 lines of Coq proof scripts. Because the relaxation \nchanges the number of loop iterations, the proof uses the divergent control .ow rule to reason about \nthe loop in the original semantics and relaxed semantics separately. The key proof steps establish that \nthe condition of the relax statement holds before entering the loop and that original_max_r<o> == original_max_r<r> \nand N<o> == N<r>. The loop invariant in both the original and relaxed execution is num_r <= max_r &#38;&#38; \nnum_r <= N. Once control .ow converges after the loop, the relate state\u00adment s precondition can be deduced \nvia a proof by cases or, as in our proof environment, veri.ed by an automated theorem prover. 5.2 Statistical \nAutomatic Parallelization Our next example is drawn from a parallelization of the Water com\u00adputation \n[8] with statistical accuracy bounds [20]. In this computa\u00adtion a control variable determines whether \nto execute a loop se\u00adquentially or in parallel. To maximize performance, the paralleliza\u00adtion eliminates \nlock operations that make updates to an array RS execute atomically. The resulting race conditions produce \na parallel computation whose result may vary nondeterministically (because of CPU scheduling variations) \nwithin acceptable accuracy bounds. Relaxation. We model the relaxation nondeterminism by relax\u00ading each \nelement in RS with no constraints:2 relax (RS) st (true); In a loop that executes after the parallel \nloop, the Water computa\u00adtion compares RS[K] to a cutoff variable gCUT2 and, if it is less than the cutoff, \nuses RS[K] to update an array FF (here EXP(RS[K]) is an expression involving RS): while (K<N){ if (RS[K] \n< gCUT2) { FF[K] = EXP(RS[K]); } K= K+1; } Acceptability. A key acceptability property is that K stays \nwithin the bounds of the array FF.3 The array bounds are stored in the variable len_FF. We assume that \nthe developer establishes, via some standard reasoning process, that the original execution does not \nviolate the array bounds and therefore inserts the statement assume (K < len_FF) inside the if statement \njust before the assignment to FF[K]. 2 Although we do not present our treatment of arrays in this paper, \nour Coq formalization supports reasoning about arrays, which is a straightforward extension of our presented \nframework. 3 We note that K must also be within the bounds of RS; the proof is similar. Veri.cation. \nRecall that the veri.cation of the relaxed program must verify that the condition in each assume statement \nholds in the relaxed execution. One approach is noninterference verify that relaxation does not affect \nthe values of the variables in the predicate. However, this is a relational property and because the \nassume statement appears at a divergent control .ow point (it depends on the value of the relaxed variable \nRS), this approach does not work. The developer therefore inserts another assume statement, assume (K \n< len_FF), just before the if statement. It is pos\u00adsible to verify this statement using noninterference, \nthen propagate the condition through the if statement to verify the second assume statement. The Coq \nveri.cation of this program consists of approximately 310 lines of proof script. The key proof step veri.es \nthe relational loop invariants K<o> == K<r> and len_FF<o> == len_FF<r>. These invariants enable us to \nprove that the relaxation does not interfere with the assumption.  5.3 Approximate Memory and Data Types \nOur third example is drawn from the LU decomposition algorithm implemented in the SciMark2 benchmark \nsuite [2]. Researchers have demonstrated that lower-power, approximate memories and CPU compute units \ncan be used to lower the energy consumption of this computation at the expense of a small loss in accuracy \n[18, 34]. We focus on the part of the computation that computes the pivot row p for each column j in \na matrix A. The pivot row is the row that contains the maximum element in the column. i = j + 1; while(i \n<N ){ a = A[i][j]; if (a> max){max= a;p=i;} i=i+ 1; } Relaxation. Following the assumptions on errors \nin approximate memories described in [25], if A is stored in approximate memory, then we can model the \nrange of errors when reading a value from A with a relaxation that nondeterministically adds a bounded \nerror e to the result: original_a = a; relax (a) st (original_a -e <= a &#38;&#38; a <= original_a + \ne); Acceptability. One acceptability property for this computation is that the value in the selected \npivot row (max) in the relaxed execution does not differ from the result in an original execution by \nmore than e. We can specify this with a relate statement: relate max<o> -max<r> <= e &#38;&#38; max<r> \n-max<o> <= e We note that this relate statement asserts the Lipschitz\u00adcontinuity of the computation: \nsmall changes in the inputs lead to proportionally small changes in the output. Veri.cation. The Coq \nveri.cation of this program consists of approximately 315 lines of proof script. The key proof step veri.es \nthat max<o> -max<r> <= e &#38;&#38; max<r> -max<o> <= e (the relation speci.ed by the relate statement) \nis loop invariant. 6. Future Work Termination. Our proof rules are designed to support the veri.ca\u00adtion \nof acceptability properties that can be described with assert statements which must hold independently \nfor both original and relaxed executions and relate statements, which relate original and relaxed executions. \nWhile such properties establish a partial correctness guarantee (as in standard Hoare logic), other accept\u00adability \nproperties may also prescribe total correctness: proofs of termination as well as partial correctness. \n Because relaxed programs may contain additional nondetermin\u00adistic and dynamically varying control .ow, \nproving termination for a relaxed program may be more challenging than proving nontermi\u00adnation for the \noriginal program. One approach is to use relational reasoning to transfer the termination proof from \nthe original pro\u00adgram to the relaxed program (in much the same way as for our cur\u00adrent set of acceptability \nproperties). And while our proof machinery is not designed to support termination proofs, the rules in \nour ax\u00adiomatic relaxed semantics do establish a relative termination guar\u00adantee for convergent while \nloops (whose termination conditions are proved to be equivalent in the original and relaxed semantics). \nRel\u00adative termination for such convergent loops ensures that if the loop terminates in the original program \nthen it also terminates in the relaxed program. We anticipate that such a notion of relative termi\u00adnation \n(akin to our relative progress) will be a fruitful direction for future work. Completeness. We have omitted \na formal statement of the com\u00adpleteness of the logic because we believe that there are additional acceptability \nproperties of relaxed programs that interact with ter\u00admination, divergent control .ow, and the semantics \nof errant exe\u00adcutions in which the original or relaxed semantics can evaluate to ba or wr. We intend \nto explore the meaning of completeness and its interactions with these properties in future work. 7. \nRelated Work Executable Speci.cations. Executable speci.cations, via tech\u00adniques such as re.nement and \nconstraint solving, produce concrete outputs that satisfy the speci.cation [13, 19, 23, 27, 33, 37]. \nAp\u00ad plications include recovering from errors in existing code and pro\u00adviding alternate implementations \nfor code that may be dif.cult to develop using standard techniques. The research in this paper differs \nin that it promotes nondeter\u00administic relaxation to obtain semantically different but still accept\u00adable \nvariants of the original program. Our focus is therefore on en\u00adabling developers to specify and prove \nacceptability requirements that involve relational properties between the original and relaxed programs. \nUnreliable Memory and Critical Data. Researchers have pro\u00adposed techniques for enabling programs to distinguish \ndata that can be stored in unreliable low-power memory from critical data whose values must be stored \nreliably [10, 18, 34]. These systems focus on data values (such as the values of pixels in an image) \nthat can, in principle, legally take on any value. While the techniques presented in this paper support \nthe veri.cation of this class of programs, they also support the veri.cation of a more general class \nof programs whose legal data values are constrained by relaxation predicates. Relational Program Logics. \nOur program logic for the relaxed semantics of the program builds on previous work on the Rela\u00adtional \nHoare Logic (RHL) [7]. RHL itself was inspired by Cred\u00ad ible Compilation [31] and Translation Validation \n[26] and and has since inspired other forms of relational reasoning. Researchers have also de.ned relational \nseparation logic [5, 36], probabilistic Hoare logic [6], and have used relational reasoning to verify \nthe correct\u00ad ness of semantics-preserving compiler transformations [12, 31, 39], Lipschitz-continuity \n[12], access control policies [24], and differ\u00adential privacy mechanisms [6]. While the majority of previous \nresearch has focused on prov\u00ading that transformed programs retain the semantics of the original program, \nour goal is different speci.cally, to prove that relaxed executions (which typically have different \nsemantics) preserve im\u00adportant acceptability properties. We adapt RHL to prove properties that relate \nthe original and relaxed executions and extend RHL to reason about assertions (which reference only the \ncurrent execu\u00adtion) and assumptions (which are assumed to hold in original exe\u00adcutions but must be shown \nto hold in relaxed executions). 8. Conclusion The additional nondeterminism in relaxed programs enables \npro\u00adgrams to operate at a variety of points with different combina\u00adtions of accuracy, performance, and \nresource consumption char\u00adacteristics. It is possible to exploit this .exibility to satisfy a va\u00adriety \nof goals, including trading off accuracy for enhanced per\u00adformance or reduced energy consumption [3, \n4, 11, 16 18, 20 22, 29, 30, 32, 34, 35, 38] or responding to load spikes or other .uctuations in the \ncharacteristics of the underlying computational platform [16, 17, 29, 34]. We present formal reasoning \ntechniques that make it possible to verify important acceptability properties of relaxed programs. Stan\u00addard \nveri.cation techniques reference only the current execution of the current program under veri.cation. \nOur techniques, in contrast, aim to reduce the veri.cation effort by taking a relational approach that \nexploits the close relationship between the original and relaxed executions. Our goal is to give developers \nthe veri.ed acceptability properties they need to con.dently deploy relaxed programs and exploit the \nsubstantial .exibility, performance, and resource con\u00adsumption advantages that relaxed programs offer. \nAcknowledgments We would like to thank Fan Long and our anonymous review\u00aders for their insightful comments. \nWe also note our earlier tech\u00adnical report on reasoning about relaxed programs [9]. This research was \nsupported in part by the National Science Foundation (Grants CCF-0811397, CCF-0905244, CCF-1036241, and \nIIS-0835652), DARPA (Grants FA8650-11-C-7192 and FA8750-12-2-0110), and the United States Department \nof Energy (Grant DE-SC0005288). References [1] The Coq Proof Assistant. http://coq.inria.fr. [2] Scimark \n2.0. http://math.nist.gov/scimark2. [3] J. Ansel, C. Chan, Y. L. Wong, M. Olszewski, Q. Zhao, A. Edelman, \nand S. Amarasinghe. Petabricks: a language and compiler for algo\u00adrithmic choice. PLDI, 2009. [4] W. Baek \nand T. M. Chilimbi. Green: a framework for support\u00ading energy-conscious programming using controlled \napproximation. PLDI, 2010. [5] G. Barthe, J. Crespo, and C. Kunz. Relational veri.cation using product \nprograms. FM, 2011. [6] G. Barthe, B. K\u00a8 eguelin. Probabilistic opf, F. Olmedo, and S. Zanella B\u00b4 reasoning \nfor differential privacy. POPL, 2012. [7] N. Benton. Simple relational correctness proofs for static \nanalyses and program transformations. POPL, 2004. [8] W. Blume and R. Eigenmann. Performance analysis \nof parallelizing compilers on the Perfect Benchmarks programs. Transactions on Parallel and Distributed \nSystems, 3(6), 1992. [9] M. Carbin, D. Kim, S. Misailovic, and M. Rinard. Reasoning about Relaxed Programs. \nTechnical Report MIT-CSAIL-TR-2011-050, MIT, 2011. [10] M. Carbin and M. Rinard. Automatically Identifying \nCritical Input Regions and Code in Applications. ISSTA, 2010. [11] S. Chaudhuri, S. Gulwani, R. Lublinerman, \nand S. Navidpour. Proving Programs Robust. FSE, 2011. [12] J.M. Crespo and C. Kunz. A machine-checked \nframework for rela\u00adtional separation logic. SEFM, 2011. [13] B. Demsky and M. Rinard. Data structure \nrepair using goal-directed reasoning. ICSE, 2005. [14] R. W. Floyd. Assigning meanings to programs. Mathematical \naspects of computer science, 19(19-32), 1967. [15] C. A. R. Hoare. An axiomatic basis for computer programming. \nCommun. ACM, 12(10), October 1969. [16] H. Hoffman, S. Sidiroglou, M. Carbin, S. Misailovic, A. Agarwal, \nand M. Rinard. Dynamic knobs for responsive power-aware computing. ASPLOS, 2011. [17] H. Hoffmann, S. \nMisailovic, S. Sidiroglou, A. Agarwal, and M. Ri\u00adnard. Using Code Perforation to Improve Performance, \nReduce En\u00adergy Consumption, and Respond to Failures . Technical Report MIT\u00adCSAIL-TR-2009-042, MIT, 2009. \n[18] S. Liu, K. Pattabiraman, T. Moscibroda, and B. Zorn. Flikker: Saving dram refresh-power through \ncritical data partitioning. ASPLOS, 2011. [19] A. Milicevic, D. Rayside, K. Yessenov, and D. Jackson. \nUnifying execution of imperative and declarative code. ICSE, 2011. [20] S. Misailovic, D. Kim, and M. \nRinard. Parallelizing sequential pro\u00adgrams with statistical accuracy tests. Technical Report MIT-CSAIL\u00adTR-2010-038, \nMIT, 2010. [21] S. Misailovic, D. Roy, and M. Rinard. Probabilistically Accurate Program Transformations. \nSAS, 2011. [22] S. Misailovic, S. Sidiroglou, H. Hoffmann, and M. Rinard. Quality of service pro.ling. \nICSE, 2010. [23] C. Morgan. The speci.cation statement. Transactions on Program\u00adming Languages and Systems, \n10(3), 1988. [24] A. Nanevski, A. Banerjee, and D. Garg. Veri.cation of information .ow and access control \npolicies with dependent types. SP, 2011. [25] J. Nelson, A. Sampson, and L. Ceze. Dense approximate storage \nin phase-change memory. ASPLOS-WACI, 2011. [26] A. Pnueli, M. Siegel, and E. Singerman. Translation validation. \nTACAS, 1998. [27] D. Rayside, A. Milicevic, K. Yessenov, G. Dennis, and D. Jackson. Agile speci.cations. \nOOPSLA, 2009. [28] M. Rinard. Acceptability-oriented computing. OOPSLA Onwards 03. [29] M. Rinard. Probabilistic \naccuracy bounds for fault-tolerant computa\u00adtions that discard tasks. ICS, 2006. [30] M. Rinard. Using \nearly phase termination to eliminate load imbalances at barrier synchronization points. OOPSLA, 2007. \n[31] M. C. Rinard and D. Marinov. Credible compilation with pointers. RTRV, 1999. [32] Martin Rinard. \nA lossy, synchronization-free, race-full, but still ac\u00adceptably accurate parallel space-subdivision tree \nconstruction algo\u00adrithm. Technical Report MIT-CSAIL-TR-2012-005, MIT, 2012. [33] H. Samimi, E. Aung, \nand T. Millstein. Falling back on executable speci.cations. ECOOP, 2010. [34] A. Sampson, W. Dietl, E. \nFortuna, D. Gnanapragasam, L. Ceze, and D. Grossman. Enerj: approximate data types for safe and general \nlow\u00adpower computation. PLDI, 2011. [35] S. Sidiroglou, S. Misailovic, H. Hoffmann, and M. Rinard. Managing \nPerformance vs. Accuracy Trade-offs With Loop Perforation. FSE 11. [36] H Yang. Relational separation \nlogic. Theoretical Computer Science, 375(1-3), May 2007. [37] J. Yang, K. Yessenov, and A. Solar-Lezama. \nA language for automat\u00adically enforcing privacy policies. POPL, 2012. [38] Z. Zhu, S. Misailovic, J. \nKelner, and M. Rinard. Randomized accuracy-aware program transformations for ef.cient approximate computations. \nPOPL, 2012. [39] L. Zuck, A. Pnueli, and R. Leviathan. Validation of optimizing com\u00adpilers. Technical \nreport, Weizmann Institute of Science, 2001.    \n\t\t\t", "proc_id": "2254064", "abstract": "<p>Approximate program transformations such as skipping tasks [29, 30], loop perforation [21, 22, 35], reduction sampling [38], multiple selectable implementations [3, 4, 16, 38], dynamic knobs [16], synchronization elimination [20, 32], approximate function memoization [11],and approximate data types [34] produce programs that can execute at a variety of points in an underlying performance versus accuracy tradeoff space. These transformed programs have the ability to trade accuracy of their results for increased performance by dynamically and nondeterministically modifying variables that control their execution.</p> <p>We call such transformed programs <i>relaxed</i> programs because they have been extended with additional nondeterminism to relax their semantics and enable greater flexibility in their execution.</p> <p>We present language constructs for developing and specifying <i>relaxed</i> programs. We also present proof rules for reasoning about <i>properties</i> [28] which the program must satisfy to be acceptable. Our proof rules work with two kinds of acceptability properties: <i>acceptability properties</i> [28], which characterize desired relationships between the values of variables in the original and relaxed programs, and <i>unary</i> acceptability properties, which involve values only from a single (original or relaxed) program. The proof rules support a <i>staged</i> reasoning approach in which the majority of the reasoning effort works with the original program. Exploiting the common structure that the original and relaxed programs share, relational reasoning transfers reasoning effort from the original program to prove properties of the relaxed program.</p> <p>We have formalized the dynamic semantics of our target programming language and the proof rules in Coq and verified that the proof rules are sound with respect to the dynamic semantics. Our Coq implementation enables developers to obtain fully machine-checked verifications of their relaxed programs.</p>", "authors": [{"name": "Michael Carbin", "author_profile_id": "81319489479", "affiliation": "Massachusetts Institute of Technology, Cambridge , MA, USA", "person_id": "P3471185", "email_address": "mcarbin@csail.mit.edu", "orcid_id": ""}, {"name": "Deokhwan Kim", "author_profile_id": "81485643254", "affiliation": "Massachusetts Institute of Technology, Cambridge, MA, USA", "person_id": "P3471186", "email_address": "dkim@csail.mit.edu", "orcid_id": ""}, {"name": "Sasa Misailovic", "author_profile_id": "81330495396", "affiliation": "Massachusetts Institute of Technology, Cambridge, MA, USA", "person_id": "P3471187", "email_address": "misailo@csail.mit.edu", "orcid_id": ""}, {"name": "Martin C. Rinard", "author_profile_id": "81100087275", "affiliation": "Massachusetts Institute of Technology, Cambridge, MA, USA", "person_id": "P3471188", "email_address": "rinard@csail.mit.edu", "orcid_id": ""}], "doi_number": "10.1145/2254064.2254086", "year": "2012", "article_id": "2254086", "conference": "PLDI", "title": "Proving acceptability properties of relaxed nondeterministic approximate programs", "url": "http://dl.acm.org/citation.cfm?id=2254086"}