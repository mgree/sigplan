{"article_publication_date": "06-11-2012", "fulltext": "\n Self-Stabilizing Java Yong hun Eom and Brian Demsky University of California, Irvine {yeom,bdemsky}@uci.edu \nAbstract Self-stabilizing programs automatically recover from state corrup\u00adtion caused by software bugs \nand other sources to reach the correct state. A number of applications are inherently self-stabilizing \nsuch programs typically overwrite all non-constant data with new input data. We present a type system \nand static analyses that to\u00adgether check whether a program is self-stabilizing. We combine this with \na code generation strategy that ensures that a program contin\u00adues executing long enough to self-stabilize. \nOur experience using SJava indicates that (1) SJava annotations are easy to write once one understands \na program and (2) SJava successfully checked that several benchmarks were self-stabilizing. Categories \nand Subject Descriptors D.2.4 [Software Engineer\u00ading]: Software/Program Veri.cation Reliability General \nTerms Languages, Reliability Keywords Self-Stabilization, Software Robustness 1. Introduction Software \nbugs have long plagued software systems. Proving soft\u00adware systems correct remains a di.cult problem. \nPractitioners have instead relied on extensive testing to verify that programs operate correctly in the \nscenarios that they are likely to be used (i.e., their comfort zones [14]). Despite extensive testing \ne.ort, it is common for unusual inputs to trigger a bug that corrupts the program s state. After a bug \ncorrupts a program s state, the program can in general behave arbitrarily. Self-stabilizing systems, \nhowever, are guaran\u00adteed to reach the correct state after a .nite number of steps [6]. This paper presents \na combination of a type system and static analyses that together check that a software application is \nself\u00adstabilizing with respect to rarely-triggered software bugs and cer\u00adtain types of transient hardware \nfailures. The self-stabilization property checked by SJava is very powerful it ensures that if a user \nreturns to using a software system in the ways it was tested for, the software system will resume working \ncorrectly. 1.1 Basic Approach SJava checks that program executions eventually transition from incorrect \nstates to the correct state by showing that incorrect values eventually leave the execution and are replaced \nby correct values. Permission to make digital or hard copies of all or part of this work for personal \nor classroom use is granted without fee provided that copies are not made or distributed for pro.t or \ncommercial advantage and that copies bear this notice and the full citation on the .rst page. To copy \notherwise, to republish, to post on servers or to redistribute to lists, requires prior speci.c permission \nand/or a fee. The approach targets programs that have a main event loop that ac\u00adquires new inputs at \neach iteration. SJava partitions both the heap and variable memory locations into abstract locations \nusing loca\u00adtion types. Location types form a lattice. SJava checks two prop\u00aderties that together ensure \nthat a program self-stabilizes. The .rst property is that values only .ow from higher to lower abstract \nlo\u00adcations (hence referred to as the .ow-down rule). Like information .ow [12], SJava must enforce the \n.ow constraint on both the ex\u00ad plicit .ows caused by assignments and the implicit .ows caused by branching \non a value and then storing a value. SJava leverages a lin\u00adear type system to prohibit aliases that could \npotentially subvert the .ow-down rule. The second property is that values can only remain at a location \nfor a bounded time. Figure 1 presents a graphical depiction of the e.ect of these two properties on an \nexecution whose state is corrupted by a bug. The red \u00d7 s indicate corrupted values while the green / \ns indicate correct values. These two properties together ensure that after a bounded time, memory locations \nwith the highest location types have the same value in both the correct execution and the buggy ex\u00adecution. \nAs the execution progresses, memory locations with lower location types have their corrupted values overwritten \nwith correct values. Eventually, all memory locations have correct values and the buggy execution has \nself-stabilized into the correct state.  1.2 Error Model SJava checks that applications self-stabilize \nin response to errors that occur inside the event loop. We make the assumption that the application successfully \nreaches the entrance to the event loop. We believe that this is a reasonable assumption; a human can \noften intervene for systems that fail to start up. Furthermore, we assume that all input reads are performed \nunconditionally in every iteration of the event loop, to eliminate the possibility of framing errors. \nSJava primarily targets rarely-triggered software bugs. We as\u00adsume that code is mostly correct with the \npossibility that rare input sequences may cause the program to behave incorrectly. We model these errors \nas incorrect state transitions to an incorrect state. The SJava system guarantees that if a program in \na bad state is fed a  PLDI 12, June 11 16, 2012, Beijing, China. Copyright &#38;#169;c2012 ACM 978-1-4503-1205-9/12/06. \n. . $10.00 Figure 1. Trace of the Program State  previously tested input sequence longer than the self-stabilization \nperiod, the program will reach the exact state as in the test. Our basic approach is also applicable \nto certain types of hard\u00adware errors. For example, SJava can guarantee self-stabilization for hardware \nerrors that create faulty inputs to an application. In gen\u00aderal, SJava can handle transient hardware \nerrors if the hardware errors (1) do not a.ect the termination of loops, (2) do not corrupt event loop \ninvariant values in variables or memory, (3) do not vio\u00adlate type safety, and (4) do not cause the execution \nto jump to arbi\u00adtrary statements. Compiler and hardware implementations can en\u00adsure these types of guarantees \nthus preserving the self-stabilization property [7 9].  1.3 Usage Scenarios We envision several usage \nscenarios focusing on embedded con\u00adtrollers and stream decoders. We describe a few scenarios in more \ndetail below: Multimedia Streaming: Unexpected values can easily cause video and audio decoders to crash \nor misbehave and prevent playing the remainder of a multimedia stream. Self-stabilizing decoders might \nfail to decode short periods of a stream due to software bugs, but these failures will only be transient \nand the remainder of the stream will be correctly decoded.  Embedded Controllers: Many embedded controllers \nare in\u00adtended to operate for long periods without human intervention. Software bugs can cause these controllers \nto enter states where they fail to perform as intended. In some cases, it may take sig\u00adni.cant time for \nhumans to recognize that the controller is mis\u00adbehaving and reset the software systems. Self-stabilizing \ncon\u00adtrollers are guaranteed to return to correct operation.  Safety Critical Code: A concern with safety \ncritical systems is that possibly undetected bugs might transition a software system to a corrupted state \nthat prevents further operation. While self\u00adstabilizing systems do not guarantee the absence of bugs, \nthey bound the time frame that even undetected errors can a.ect the correct operation of a system. Self-stabilization \nis not intended to replace the rigorous validation processes that are currently used to ensure correctness, \nbut rather to complement these processes to limit the consequences of bugs that inevitably slip through. \n  1.4 Contributions This paper makes the following contributions: Basic Approach: It presents a basic \napproach for checking whether programs are self-stabilizing.  Types for Self-Stabilization: It presents \na type system that en\u00adsures that values eventually .ow out of a program to return the program to the \ncorrect state.  Implementation: It presents an implementation of an SJava compiler including the type \nsystem and static analyses.  Experience: It presents our experiences using SJava to check that several \napplications are self-stabilizing.  The remainder of the paper is organized as follows. Section 2 presents \nan example. Section 3 presents the location type abstrac\u00ad tion. Section 4 presents the type checking \nrules. Section 5 presents the static analysis that checks that corrupted values are eventually evicted. \nSection 6 presents our approach for ensuring that event loop iterations terminate. Section 7 presents \nour approach to code generation. Section 8 overviews the basic correctness argument. Section 9 evaluates \nour approach on several benchmark applica\u00ad tions. Section 10 presents related work; we conclude in Section \n11. 1 @ LA T T I C E ( \" DIR < TMP , TMP < BI N \" ) 2 p u bli c c l a s s W D S e n s o r { 3 @LOC ( \n\" BI N \" ) p ri v at e W in d Re c w in d Re c = n ew W in d Re c (); 4 @LOC ( \" DI R \" ) p ri v at e \nin t dir ; 5 6 @ L A T T I C E ( \" STR < WDOBJ , WDOB J < IN \" ) 7 @ T H I S L O C ( \" W D OBJ \" ) 8 \npu b lic void w i n d D i r e c t i o n (){ 9 S JAVA : 10 w hile ( t r u e ){ // m a i n even t loop \n11 @LOC ( \" IN \" ) i nt i n D ir = D e vi c e . r e ad S e n s o r () ; 12 // move old w i n d d i r \ne c t i o n s one step d o w n 13 w in d Re c . dir2 = w in d Re c . d i r 1 ; 14 w in d Re c . dir1 \n= w in d Re c . d i r 0 ; 15 // a dd a ne w w i n d d ir e c t i o n 16 w in d Re c . dir0 = i n D ir \n; 17 @LOC ( \" STR \" ) St r i ng s t r Di r = c a l c ul a t e (); 18 b r o a d c a s t C h a n g e ( \ns t rD i r ); 19 } 20 } 21 22 @ L A T T I C E ( \" OUT < CA O B J \" ) 23 @ T H I S L O C ( \" C A OBJ \" \n) 24 @ R E T U R N L O C ( \" OUT \" ) 25 pu b lic S t r in g c al c u l a t e ( ){ 26 @ L O C ( \" CAOBJ \n, T MP \" ) in t m a j o r Di r ; 27 @ L O C ( \" OUT \" ) S t r in g s t r Di r ; 28 // c a l c u l a t \ne t he m a j o r i t y 29 ... 30 t h i s . d ir = m a j o r D i r ; 31 s tr D i r = c o n v e r t T o \nS t r i n g ( m a j o r D ir ); 32 r et u r n s tr D i r ; 33 } 34 } 35 36 @ LA T T I C E ( \" DIR2 < \nDIR1 , DIR1 < DIR0 \" ) 37 c l a s s W in d Re c { 38 @LOC ( \" DIR0 \" ) p u bl i c in t d i r 0 ; 39 @LOC \n( \" DIR1 \" ) p u bl i c in t d i r 1 ; 40 @LOC ( \" DIR2 \" ) p u bl i c in t d i r 2 ; 41 } Figure 2. \nWind Direction Sensor Example 2. Example We present a Java weather station example to illustrate SJava. \nThe weather station processes sensor inputs and broadcasts them. Fig\u00adure 2 presents the main event loop \nfor the weather station. The loop reads sensor data from a device in Line 11, adds it to the WindRec \nobject that stores the most recent three directions in Line 16, and determines the wind direction by \ncalling the calculate() method. To compensate for sensor errors, the calculate() method exam\u00adines the \nprevious three directions and computes the median to dis\u00adcard invalid direction values. 2.1 Self-Stabilization \nSoftware bugs or hardware failures can corrupt an application s state, causing problems during its subsequent \nexecution. In our ex\u00adample, there are many possible ways of arriving at an incorrect state. In one possible \nscenario, the device returns an erroneous value, which is not one of the 16 possible directions. This \nvalue is stored in and corrupts the windRec data structure. Next, the convertToString() method throws \nan uncaught null pointer ex\u00adception due to the corrupted value in windRec. Finally, the program fails \nto show the current wind direction. Once a bug occurs, the system potentially has unde.ned and possibly \nundesirable behavior because the program s state may contain corrupted values. Our observation is that \nthe system will resume normal behavior if the execution eventually arrives at the correct state. In the \nexample, after any erroneous value enters the windRec data structure the program would return to the \ncorrect execution after at most three iterations of the main loop. SJava only computes whether a program \nself-stabilizes and not when it self\u00adstabilizes. However, it is possible to compute bounds by analyzing \nthe lattice.  SJava analyzes programs that employ the main event loop pat\u00adtern: an outer loop retrieves \na new input, processes it, and produces the output. The goal is to check that all e.ects of a value disappear \nafter a .nite number of main event loop iterations. To show that the program cannot remain inde.nitely \nin incorrect states, we .rst establish an ordering relation on the memory loca\u00adtions in the program. \nThe ordering relation forms a location hierar\u00adchy that constrains how values .ow through the program. \nPrecisely, it ensures that values .ow in one direction: from higher locations to lower locations. Therefore, \nassignments are only allowed if the location of the left-hand side of an assignment is lower than the \nlocation of the value to be stored. However, forbidding assignments that violate ordering con\u00adstraints \nis not su.cient to obtain the desired property because it does not force values in the program s memory \nto be evicted within a .nite number of steps. Therefore, the SJava compiler ensures that non-loop invariant \nvalues that are live are evicted within one loop iteration. Our analysis is designed to check eviction \nof memory lo\u00adcations within one loop iteration as checking longer eviction times is unlikely to provide \nsigni.cant bene.ts but requires more sophis\u00adticated techniques that can reason about predicates. Even \nif a program does not store any values inde.nitely, it may crash before it reaches a legal state. Given \nthe guarantee that the system will return to the correct state, the developer may choose to have the \nprogram log and then ignore uncaught exceptions. SJava optionally supports ignoring uncaught exceptions \nto ensure that the program will execute long enough to self-stabilize.  2.2 SJava Annotations Line 1 \nof Figure 2 de.nes the location hierarchy for the .elds in the WDSensor class. The ordering relation, \nas de.ned by the < operator, allows values to .ow from the location type that appears after the operator \nto the location type that appears before the operator. The example location hierarchy constrains values \nto only .ow down from locations with the BIN location type to locations with the TMP location type to \nlocations with the DIR location type (.ows directly from the BIN location to the DIR location that skip \nthe TMP location are allowed). We use the annotation @LOC to declare that the .eld windRec has the location \ntype BIN in Line 3. Line 22 de.nes the location hierarchy for the calculate() method. Local variables \nhave composite locations, where a com\u00adposite location consists of a location in the method s hierarchy \nfol\u00adlowed by any number of locations from .eld hierarchies. The or\u00addering of composite locations is given \nby comparing the elements of the two composite locations in lexical order. Line 26 declares the composite \nlocation type LOC(CAOBJ, TMP) for the majorDir variable. This location is lower than (CAOBJ, BIN) and \nhigher than (CAOBJ, DIR) since the .eld hierarchy has the ordering relations DIR c TMP and TMP c BIN. \nDevelopers must assign a location in the hierarchy to the this variable using the annotation @THISLOC. \nLine 23 assigns the CAOBJ location to the this variable. The special label SJAVA in Line 9 speci.es that \nthe while loop in the next line is the main event loop. We next discuss how the compiler checks that \nthe program statements evaluated through the iteration of the main event loop do not violate the .ow \nconstraints.  2.3 Checking Self-Stabilization The SJava compiler checks the parts of the program that \nare callable from the main event loop. First, it checks that every .eld, variable, and parameter accessed \nin the main event loop has been annotated with a location type. Next, it checks that all assignments \nrespect the ordering relation. Speci.cally, an assignment is only allowed if the left-hand side s location \nis lower than the value being assigned. For example, the assignment to this.str in line 30 is valid because \nthe location type (CAOBJ, TMP) of the source value is higher than the location type (CAOBJ, DIR) of the \ndestination. For every call site, the compiler must check that value .ows cre\u00adated by the callee do not \nviolate the caller s ordering constraints. Location lattices in SJava are not global each method instance \nhas its own locally-scoped location lattice. SJava s method local location lattices allow a single method \nto be used in several di.er\u00adent contexts in which the arguments do not have the same location types. \nIt also makes our type system composable the SJava loca\u00adtion type system captures the behavior of a method \nand not how the method happens to be used in the overall system. SJava must ensure that the location \nlattice of the callee enforces the .ow constraints of the caller s argument. Alternatively, this check \ncan be viewed as verifying that the caller and callee lattices can be merged into a single combined lattice. \nSpeci.cally, the compiler (1) checks that the ordering constraints of the arguments in the caller satisfy \nthe ordering constraints required by the location types of the callee s parameters and (2) computes the \nhighest caller location for the re\u00adturn value that is consistent with the callee s ordering constraints. \nFor example, the compiler processes the location annotations for the calculate method to determine that \nits return value is lower than its receiver object, and then checks that this is consistent with the \ncaller s lattice (i.e., that the variable strDir has a lower loca\u00adtion than the this variable). The SJava \ncompiler also checks that all memory locations ac\u00adcessed by the event loop are either loop invariant \nor were overwrit\u00adten in either the current or previous loop iteration. In the example, all variables \nand .elds are obviously overwritten by each iteration of the event loop. A termination analysis (Section \n6) ensures that each iteration of the event loop terminates by prohibiting recursive calls 1 and checking \nthat inner loops terminate. 3. Location Type System In SJava, every memory location has a location type \nin addition to its Java type. A location type constrains which types can be stored in the corresponding \nmemory location. The compiler checks that every assignment moves values from memory locations with higher \nlocation types to memory locations with lower location types. 3.1 Location Types A program execution \nmay create a statically unbounded number of concrete memory locations. We therefore map the concrete \nmem\u00adory locations to a .nite set of location types. Location types are as\u00adsigned by the developer to \n.eld declarations, variable declarations, and parameter declarations.  3.2 Location Type Lattice The \nlocation hierarchy is de.ned by the lattice (LSET , [), where LSET is the set of location types and the \nbinary relation [ establishes an ordering between location types. It is useful to note that we use both \nthe re.exive partial ordering ([) and the corresponding strict partial ordering (c). We make use of the \nre.exive partial ordering to support the standard lattice machinery while our type checking rules rely \non the strict partial ordering. For example, low c high means that the location high is higher than low, \nspecifying that values can legally .ow from memory locations with the location type high to memory locations \nwith the location type low. The location lattice includes the top and bottom locations. The top location \nT is the highest location, whose values 1 Note that the type system and other static analyses currently \nhandle recur\u00adsive calls. The restriction against recursive calls is only due to limitations in our termination \nanalysis.  Annotation Role Applied to @LATTICE @METHODDEFAULT @LOC @THISLOC @PCLOC @GLOBALLOC @RETURNLOC \n@DELEGATE @TRUST De.nes a location hierarchy De.nes the class-wide default method hierarchy Assigns a \nlocation to a declaration Selects a location for the this reference Selects a location for the program \ncounter Selects a location for static references Selects a location for a return value Transfers ownership \nIndicates that a method was manually inspected Classes and Methods Classes Fields, Variables, and Parameters \nMethods Methods Methods Methods Method Parameters Methods Figure 3. Annotations can .ow anywhere. The \nbottom location . is the lowest location, any value can .ow to such locations. The location lattice has \nthe meet operator n, which computes the greatest lower bound (GLB) of any two location types in the lattice. \nOur GLB operation is the standard lexicographic GLB.  3.3 Method and Field Location Lattices SJava has \na separate location hierarchy for each class and method. Each class has a .eld hierarchy lattice that \nde.nes an ordering be\u00adtween .elds of the same object instance. Each method has a method hierarchy lattice \nthat is used to establish an ordering between the di.erent variables in the method. Both the .eld and \nmethod hier\u00adarchies are de.ned as lattices. The next section discusses how the elements of method and \n.eld hierarchies are combined into a com\u00adposite location that orders all memory locations in a program. \n 3.4 Composite Location Types A composite location type is a sequence of location elements the .rst element \nof the composite location is a method location from the current method s method hierarchy lattice, followed \nby a sequence of zero or more .eld locations. Consider the .eld ac\u00adcess expression foo.bar.z. It has \nthe composite location type (FOO, Foo.BAR, Bar.Z), where the local variable foo has the loca\u00adtion type \nFOO, the .eld bar has the location type BAR in the .eld hierarchy of class Foo, and z has the location \ntype Z in the .eld hierarchy of class Bar. For every .eld access, the compiler computes the composite \nlocation that describes the position in the ordering of the .eld by combining the composite location \ntype of the reference variable with the .eld location element. Developers have the option to declare \nany level of the composite location for local variables. This enables a developer to set the local variable \ns ordering relative to speci.c .elds so that a local variable with a composite location can take a value \nfrom one .eld, and then store it back to another .eld in the same object. 3.4.1 Comparison The comparison \nof two composite locations is based on lexico\u00adgraphical ordering of the location elements. The comparison \nbegins with the .rst elements of the two composite locations. If the .rst elements are not identical, \nthen the lattice for the .rst location de\u00adtermines the ordering relation of two locations. If the .rst \nelements are identical, the comparison continues onward to later elements in the composite location types. \nThe composite location with n location elements has a set of partial orders {[1, [2, ..., [n}. The partial \nordering relation of the composite location is de.ned as follows: (a1, a2, ..., an)[C (b1, b2, ..., bn). \n. j .{1, ..., n}.(aj cj bj . ( j = n . aj = bj)) ..i < j.ai = bi Location elements at position i come \nfrom a lattice that de.nes a partial ordering relation [i. If two .eld elements are from di.erent classes, \nthen the composite location types are incomparable. Lexicographical ordering addresses the following \nissue with implicit information .ows through heap paths. Consider a heap path to a primitive .eld (e.g., \nx.f, where f is a primitive .eld) if a value is high enough to .ow to a reference along the path to the \nobject with .eld (e.g., the variable x), with lexicographical ordering it is also high enough to legally \n.ow to the .eld (e.g., f). The ordering therefore simpli.es the typing rules because such .ows cannot \nviolate the ordering relation.  3.5 Inheritance As a subclass inherits .elds and methods from its parent \nclass, it must preserve the ordering hierarchy from the parent class. The compiler checks that every \nlocation de.ned in the parent is included in the subclass s .eld hierarchy. The subclass can of course \nde\u00adclare new locations in its hierarchy. The compiler checks that the value .ows allowed by the subclass \nare the same in the parent to prevent the ordering constraints from being subverted by an over\u00adridden \nmethod or a cast. Checking the hierarchy of an overridden method is exactly the same as the .eld hierarchy \ncheck with the ad\u00additional constraint that the parameters must have the same declared locations.  3.6 \nLocation Type Annotations SJava s location type annotations are written using standard Java annotations. \nFigure 3 summarizes the basic types of SJava annota\u00ad tions. The annotation @LATTICE de.nes a location \nhierarchy and can be applied to both class and method declarations. Figure 4 presents the grammar for \nlattice declarations and location declara\u00adtions. The value in the @LATTICE annotation consists of a series \nof binary relation entries that de.ne the ordering relation. The binary relation uses the inequality \nnotation <, x < y means that a value can .ow from y to x. latticeDecl := @LATTICE ( orderDecls,sharedLocDecls \n) orderDecls := orderDecls, orderDecl | orderDecl orderDecl := location < location sharedLocDecls := \nsharedLocDecls, location* | location* compositeLoc := @LOC ( locationList ) deltaLoc := @DELTA ( locationList \n| deltaLoc ) locationList := locationList, locElement | locElement locElement := location | ClassName.location \nFigure 4. Location Declaration and Annotation Grammar  Every method must have a method hierarchy, but \ndeclaring a lattice for every method can be labor intensive. Therefore, the SJava provides a default \nlattice for the method. The @METHODDEFAULT annotation on the class declaration de.nes a class-wide method \nlattice. If a method is not annotated with a method hierarchy using the @LATTICE annotation, the method \nuses the default lattice for the class. When many methods behaviors are similar, the default lattice \ncan signi.cantly reduce the annotation burden. The developer speci.es the location types of variable, \n.eld, and parameter declarations using the annotation @LOC followed by a parenthesized composite location. \nThe @THISLOC annotation designates a location in the method hierarchy for the this variable. This allows \nthe compiler to derive the proper composite location for a value accessed through the this variable and \ncompute its ordering relations relative to other local variables. Assigning a location to the static \n.eld references is done in a similar manner to the this variable. The @GLOBALLOC annotation speci.es \nthe location of static .elds in the method lattice. The type checker ensures that method lattices consistently \norder globals relative to arguments using the checks that we use to preserve ordering between arguments. \nAt this point, SJava does not support de.ning an ordering relation between static .elds from di.erent \nclasses. Instead, we envision that static .elds will be primarily used to store constants, and therefore \ncan be assigned to a very high location. However, static .elds could be supported by partitioning them \ninto groups, using annotations to describe the locations of groups, and checking that di.erent methods \nuse these locations consistently. The program counter location tracks implicit .ows. If a method can \nbe safely called when the program counter location is lower than one of the parameter locations, the \ndeveloper can use the @PCLOC to declare the initial location for the program counter. Otherwise, the \nprogram counter has the top location. As noted, developers can assign any composite location to lo\u00adcal \nvariables and parameters. For example, on Line 26 from Fig\u00ad ure 2, the annotation @LOC(\"CAOBJ,TMP\") int \nmajorDir in\u00addicates that the variable majorDir has the composite location type (CAOBJ, TMP). For method \ndeclarations, the annotation @LOC speci.es the location type for a parameter and the annotation @RETURNLOC \nspeci.es the location type of the return value. 4. Flow-down Rule SJava s type checking is independent \nfrom the standard Java type checking, so this section will focus only on the location type check\u00ading \nrules. In SJava, every memory location has a location type that captures how values can .ow into and \nout of that memory location. We de.ne the following notations: The symbol L represents a composite location \ntype, which is a sequence of location ele\u00adments. The symbol l represents a location element. The elements \nof a composite location are (l0, l1, ..., ln-1). The function size(L) re\u00adturns the size of the sequence \nrepresentation of the location type L. The static environment G provides a mapping from identi.ers to \nlocation types, Gm provides a mapping for the callee m. The callee init env function returns the initial \ntype environment at the beginning of the method body. The notation G(x) gives a mapping from the identi.er \nx to either the location type L or the location element l bound to the .eld. One of the identi.ers is \nthe program counter location pc that represents the current context constraint that restricts the location \ntype of the destination of any assignments. The purpose of the program counter location is to track implicit \nvalue .ows. 4.1 Location Type Checking Rules Figure 5 presents the type checking rules. There are two \nkinds of type judgment rules. The judgment G r e : L states that the true G r e0: L0 G r e1: L1 L = L0 \nn L1 (LITERAL)(OP) G r literal : T G r e0 De1: L G(x) = L G r e : Le G r L c Le G r L c G(pc) (ASSIGN) \nG r x = e : L G(x) = L G r e : Le G( f ) = lf L = Le . lf (VAR)(FD R) G r x : L G r e. f : L G r e0: \nL0 G( f ) = lf G r e1: L1 L = L0 . lf G r L c L1 G r L c G(pc) (FD W) G r e0. f = e1: L G r c : Lc G[pc \n=G(pc) n Lc ] r ei.{1,2} (IF) G r if(c) e1 else e2 G r c : Lc G[pc =G(pc) n Lc] r e (WHILE) G r while(c) \ne G r a : La G r i : Li L = La n Li (ARRAY VAR) G r a[i]: L G r a : La G r i : Li G r e : Le G r La c \nLi G r La c Le G r La c G(pc) (ARRAY ASG) G r a[i] = e : La Gm = callee init env(@RETURNLOC(Vrv )@THISLOC(Vt \n)@PCLOC(Vpc) m(@LOC(Vp1)p1 , ..., @LOC(Vpn)pn)) Gm r p0: Lm ... Gm r pn : Lm G r a0: L0 ... G r an 0 \nn : Ln .i, j .{0, ..., n} Gm r Lm c Lm . G r Li c Lj ij Xi = i 0) then ii ) else . ) (if (sub(Lm , 0, \n1) = Lm L0 . sub(Lm , 1, size(Lm .i .{1, ..., n} G r (Xi c Li . Xi = Li ) = {i |.i .{0, ..., n}, Gm \nr (Lm c Lm . Lm = Lm = Ir rv i rv i )} Lr Li i.Ir .i .{0, ..., n} c Gm(pc) . Li c G(pc) Lm i call is \nvirtual w/ multiple targets . Gm(pc) c Lm (CALL SITE)0 Gr a0.m(a1, ..., an): Lr (l0, l1, ..., ln ). lm \n= (l0, l1, ..., ln, lm) sub((l0, l1, ..., ln ), i, j) = (li , ..., lj-1) Figure 5. Location Type Checking \nRules expression e has the location type L in the G environment. The judgment G r e states that the expression \ne is well-typed with respect to the environment G. The notation G[pc = v] represents the same environment \nexcept that the program counter pc is bound to new value v. We next describe the basic checking rules: \nLiteral: Every literal value has the highest location type TOP in the location hierarchy, denoted by \nT. Therefore, all constant values in a program can .ow to any memory location. Operation: The operation \nrule derives the location type of an arithmetic expression of the form e0De1. The derived location type \nis the greatest lower bound of the location types of two operands. Variable Assignment: A variable assignment \ncauses a value .ow from its right-hand side to its left-hand side. The ASSIGN rule checks that the destination \ns location type is lower than the source s location type. The last premise tracks implicit .ows by checking \nthe context constraints due to control .ow. Field Read: For a .eld read expression e.f, a new composite \nlocation is derived by appending the location type of the .eld f to the location type of the base expression \ne. The binary operation . adds a new location element to the end of the composite location. Field Assignments: \nThe .eld assignment rule is similar that for variable assignments except that the composite location \ntype of the left-hand side is derived from the .eld access expression.  4.2 Arrays The na\u00a8ive approach \nto handling arrays is to assign all the elements of an array to the same location type. This approach \nprohibits value .ows between elements of the same array and is therefore too restrictive for most real-world \napplications.  SJava supports two di.erent approaches to arrays. In the .rst approach, the array have \na special shared location type that allows value .ows between array elements provided that the entire \narray is cleared out (or lowered) at the same time at some point in each iteration of the event loop. \nSection 4.7 presents more details on shared locations. Alternatively, SJava can assign unique locations \nto each array element. In this case, the array elements are ordered in sequence with the .rst element \nhaving the lowest location and the last having the highest. The SJava library then provides an insert \nmethod that shifts all the elements down by one index and assigns a new value to the last position. The \ntype system assumes that this method moves all values in the array one step down. The eviction analysis \nensures that the insert method is called at least once in each loop iteration. To ensure that a value \n.ow between an index value and an array does not violate ordering constraints, SJava has two separate \nrules for array expressions. The ARRAY VAR rule checks that an array access expression has a location \ntype that is the greatest lower bound of both the location type of the array and the location type of \nthe index. The array assignment rule ARRAY ASG has to consider the relative ordering of an array and \nthe index value used for that array. The location type of the array should be lower than the location \ntype of the index since the value of the array index a.ects how values .ow into the array. The rule also \nchecks that the location type of an array variable is lower than the value expression being assigned. \n 4.3 Implicit Flow Conditional branches may cause implicit value .ows that could vi\u00adolate the ordering \nconstraints. The example code below introduces an implicit .ow. The value of the variable a in the if \ncondition statement a.ects the value assigned to the variable b. As a result, if the location type of \nthe variable b is higher than the location type of the variable a, it is a violation of the ordering \nconstraint since there exists a value .ow between them. if (a>0) b=1; else b =0; To prevent implicit \n.ows that violate ordering constraints, the IF and WHILE rules update the program counter location with \nthe location type of the if condition or while condition, respectively. This ensures that any conditional \nassignments in the body of the if statement or loop prohibit implicit .ows that are not permitted. For \nthe example, after evaluating an if statement, the pc is set to the location type of the condition expression \n(A), then the compiler checks that the left-hand side of the assignment b has a location type lower than \npc s location type. The compiler also ensures that a method call in a conditional branch respects implicit \n.ows. The callee s program counter loca\u00adtion re.ects the location type of the call site s context constraint. \n 4.4 Method Invocation Location type annotations in method declarations impose restric\u00adtions that both \nthe caller and the callee must respect. When argu\u00adments are passed to the parameters of the call site, \nthe caller must respect the callee s restrictions on the relative orderings of the ar\u00adguments and the \nreturn value. The callee must in turn respect the constraints its declared interface places on its internal \nvalue .ows. The two sets of restrictions together guarantee that method invoca\u00adtion respects the ordering \nconstraints of the caller and the callee. Alternatively, the call site checks can be viewed as checking \nthat the collection of method lattices can be transformed into one global method lattice that is consistent \nwith the program s value .ows. 4.4.1 Call Site Checking The parameter s location type describes how the \nlocation type of an argument in the caller is transferred into the method hierarchy Figure 6. Method \nInvocation of the callee. From the perspective of the callee, relative orderings between parameters establish \nordering constraints on the location type of a value passed in, which the caller must respect when it \nassigns values to arguments. Type checking the call site ensures that the caller provides ar\u00adguments \nthat respect the callee s ordering constraints, which re\u00adquires the type checker to check the mapping \nof location types from the caller s arguments to the callee s parameters. For each call site ms(a0, a1, \n..., an) to the corresponding method declaration m(p0, p1, .., pn), the rule CALL SITE checks that for \nany two pa\u00adrameters pi and pj if the callee has the ordering relation pi c pj between parameters, then \nthe caller has to have the correspond\u00ading ordering relation ai c aj between its arguments. If the callee \ndoes not have any ordering relation between two parameters, the caller does not need to respect any ordering \nconstraints on the cor\u00adresponding two arguments because it implies that the callee will not have a value \n.ow between two parameters. Figure 6 illustrates how the compiler checks constraints of the caller and \nthe callee. The callee has two ordering relations among parameters, ENV c IN and DAOBJ c IN in its hierarchy, \nand therefore the callee imposes two ordering constraints on the caller s arguments. The caller must \nguarantee that the corresponding arguments have same relation in its hierarchy, in this case ENVC c VA \nand DATA c VA. If the .rst element of a parameter location type matches the location type of the current \nobject this and a .eld element is in the next position, the callee establishes ordering constraints relative \nto the .eld lattice of the current object. This provides more speci.c constraints on the ordering relations \nof .elds in the current object; the caller needs to satisfy constraints on not only the ordering relations \nbetween arguments, but also the ordering relations of .elds given by the .eld hierarchy of the object \nreferenced type of this. For example, suppose that the parameter has the location type (IOBJ, F) and \nthe receiver object has the location type IOBJ. The corresponding argument in the caller is required \nto be higher than or equal to (O, F) if the object whose method is being invoked has the location type \n(O) in the caller.  4.4.2 Return Value Location The call site rule uses the location types of the parameters \nand the return value to conservatively compute the set of .ows that the callee may produce. The rule \nthen computes a caller location type that allows all of these .ows in the callee context. This check \ncan be viewed as checking that it is possible to combine the callee and the caller lattices in a way \nthat allows all existing information .ows. The CALL SITE rule in Figure 5 computes the caller s return \nvalue location as follows. First, it computes the set of parameter lo\u00adcation types that are higher than \nor equal to the declared return lo\u00adcation type. Parameters that are not higher than the return location \ntype are irrelevant because the ordering constraints prevent value .ows from these parameters. In Figure \n6, the compute method pro\u00advides a set of parameter location types {IN, DAOBJ} for calculating the return \nvalue location. Next, the rule creates a set of argument location types in the caller that correspond \nto this set of parameters and then computes the greatest lower bound of the location types of these arguments. \nThe caller in Figure 6 computes the greatest lower bound of VA and DATA since the callee locations IN \nand DAOBJ cor\u00adrespond to the locations VA and DATA, respectively, in the caller s hierarchy. In this \ncase, the location type of the return value is DATA, which means that the caller must not return a value \nthat is lower than the location type DATA. If the return value of the method is the right-hand side of \nan assignment, the rule ASSIGN then checks that the return value location is higher than the left-hand \nside. The last assignment in the right column of the Figure 6 satis.es the ordering constraints with \nthe location type of the return value DATA.   4.5 Objects Non-static .elds are always accessed through \nan instance reference variable. The location types of instance reference variables pro\u00advide a way to \ncompute the relative ordering between other local instances. In the case of copying .eld values from \none instance to another instance, the static checking checks that the location of the source instance \nis higher than the destination. The current imple\u00admentation of SJava prohibits recursive data structures. \nFuture work could relax this constraint. One approach is to require programs to delete all references \nto a recursive data structures within some loop iteration bound. 4.5.1 Aliasing Aliasing refers to the \nsituation in which multiple references point to the same object. In SJava, if two aliased references \nto the same object were allowed to have di.erent location types, this would open the possibility of values \n.owing from the lower locations to higher locations through the aliased references in violation of the \n.ow-down rule. For example, suppose that a program creates two references with di.erent location types \nto the same object. The static checking as described would allow the program to use the higher reference \nto access a value from a .eld that was written to using the lower reference. One approach to ensuring \nthat aliasing is safe is to ensure that all aliases to an object have the same location type. SJava uses \nlinear types to restrict aliasing. SJava s linear type system prohibits multiple heap aliases from referencing \nthe same object. This implies that the heap that can be updated by the event loop in SJava must be a \nforest of objects (multiple disjoint trees). SJava allows limited aliasing from local variables and parameters \nvariable aliases are allowed as long as all aliases have the same location type. A side e.ect is that \nif an alias exists to any object in a tree, the location type of all objects in that tree cannot be changed. \n 4.5.2 Ownership Transfer In some cases, a method may need to lower the location type of an object passed \nin as a parameter. SJava supports ownership transfer to allow a caller method to transfer ownership of \na non-aliased reference to a callee method. The method acquires ownership of a non-aliased reference \nthrough parameters with the @DELEGATE annotation. Exclusive ownership allows the method to lower the \nlocation type of a refer\u00adence, to transfer its ownership to other methods, to create heap ref\u00aderences \nto the object, and to remove subtrees from the heap reach\u00adable from the object. Ownership transfer guarantees \nthat a given reference must be owned by only one method and no aliases to the object exist in other scopes. \nIn this respect, the caller has the responsibility to pass a unique reference argument to the callee. \nStatic checking of the caller checks that all references to the object are dead after the call site. \nMethods can only returned owned ref\u00aderences. Returning aliased references could be supported with an \nannotation that declares that the return value is aliased and gives the parameter from which the alias \nwas obtained. The ownership status of a variable can be either (1) a parent method owns the tree (i.e. \nthe object is aliased), (2) in the case of temporary variable used to traverse a locally own tree, the \nlocal variable that contains the owned reference to the tree s root, or (3) the current local variable \nowns the reference. We only allow changing the level of a reference if (1) the reference owns the tree \nand (2) no other local variables refer to objects in the same tree. We allow transferring ownership of \na component object of a tree only if (1) the current method owns the tree and (2) the temporary variable \nused to remove the reference is the only reference other than the owning reference.   4.6 Delta Locations \nCode often uses temporary variables to access data structures. In\u00adcluding location types for all of these \ntemporary variables would greatly complicate both the method and .eld hierarchies. Instead, SJava provides \na special function delta that takes a composite lo\u00adcation and generates a new composite location, called \na delta loca\u00adtion, which is lower than the input composite location and higher than everything that is \nlower than the input composite location. The delta function is applied to a whole composite location. \nThe delta function can be applied to the output of itself to generate a descend\u00ading series of composite \nlocations. Consider a code segment that copies a value from an object .eld to a local variable, computes \na value using the local variable, and then stores the value to a di.erent, lower .eld of the same object. \nThis value .ow involves a variable, so it requires the variable to have a location between the two .elds \nin the .eld hierarchy. With the delta function applied to the composite location of the source .eld, \nit is straightforward to generate a composite location for the local variable that is lower than the \nsource .eld and higher than the destination .eld. In the example from Section 2, the composite lo\u00ad cation \n(CAOBJ, TMP) can be replaced with delta((CAOBJ, BIN)) in Line 26. It generates a new location that is \nlower than (CAOBJ, BIN)and higher than all locations below (CAOBJ, BIN). For correctness purposes, delta \nfunctions are syntactic sugar that introduces new elements into the hierarchy of the last component of \nthe composite location and updates the lattice appropriately.  4.7 Shared Locations The .ow-down rule \nensures that every assignment lowers the lo\u00adcation type of the value being assigned. This constraint \nprohibits common computations that read from a set of memory locations, perform computation, and store \nthe results into the same set of memory locations. This constraint also prohibits simple for loops, e.g., \nfor(int i=0;i<10;i++) ;, as the increment operation vi\u00adolates the standard .ow-down rule. SJava provides \nshared location types for primitive types to al\u00adlow developers to specify a set of memory locations with \nthe same composite location that values can .ow freely between. The devel\u00adoper can assign the same shared \nlocation to multiple locations, and then freely .ow values between those locations. Shared location are \nexplicitly listed in the lattice annotation with a *. SJava must ensure that a program actually clears \nout all mem\u00adory locations with the same shared location type and does not merely shu.e corrupted values \nbetween memory locations. A shared memory location is cleared when a value from a higher loca\u00adtion is \nwritten and remains cleared until the program overwrites that memory location with a value with the same \nshared location type.  SJava checks that all memory locations with the same shared loca\u00adtion type are \nsimultaneously in the cleared state at least once per an event loop iteration (or before every use). \nTherefore, the program cannot use a shared location to store values inde.nitely (and cir\u00adcumvent self-stabilization) \neven though a shared location may keep values through assignments. In the next section, we describe how \nSJava uses static analysis to check this constraint. Among other uses, shared locations are useful for \nallowing index variables in for loops. 5. Eviction of Values Although the .ow-down rule ensures that \nall value .ows respect the ordering constraints, it does not ensure that values leave a memory location \nin a bounded time period. For example, suppose that a vari\u00adable is written by one event loop iteration, \nand all future iterations of the event loop read that value. In this scenario, a corrupted value can \nremain inde.nitely and the execution may never self-stabilize. This section presents a static analysis \nthat ensures that a memory location does not store values inde.nitely. 5.1 De.nitely-Written Analysis \nThe de.nitely-written analysis ensures that reads inside the event loop either read (1) a value written \noutside of the event loop or (2) a value written by the current or the immediately preceding event loop \niteration. This ensures that corrupted values cannot remain live in the same memory location inde.nitely. \nThe analysis checks that for each memory location M that the event loop either (1) overwrites M or (2) \noverwrites a reference that lies on the heap path to M (thus lowering M or making it unreachable). The \nanalysis operates in two stages. In the .rst stage, it computes read and write sets. In the second stage, \nit checks that the event loop body respects the de.nitely-written constraints. 5.1.1 Computing Read and \nWrite Sets The analysis generates the read set Rm, the may-write set OWm, and the must-write set WT m \nfor the main event loop and each method m that is callable from the main event loop. Elements of these \nsets are represented by heap paths, which are n-tuples of references that describe the sequence of heap \naccesses to reach a memory location from one of the method s parameters. For example, accessing the .eld \nf of an expression x that is reachable from the parameter p1 through a sequence of references r1, ..., \nrn generates the heap path (p1 , r1, ..., rn, f). The analysis computes a mapping HP that maps a variable \nto the heap path that describes the sequence of references from the parameter to the object the variable \nreferences. The analysis can safely ignore reads and writes on local variables as they will go out of \nscope when the method exits. Our analysis uses a standard .xed-point algorithm. Figure 7 presents the \ntransfer functions for computing read and write set. We de.ne the helper function HP(x)={hp |(x, hp). \nHP}. Read: The set Rm contains the heap paths that must either be never written in the loop or overwritten \nbefore the method m is called in a di.erent iteration of the event loop. The .eld read statement x=y.f \ngenerates a new heap path for x by appending the .eld f to the heap path HP(y). The read statement also \nadds the corresponding heap path to Rm if it or a pre.x may not have been overwritten since the method \nentry. Write: The .eld write statement x.f=y adds the heap path through f to the set WT and the set OWm. \nNote that it is not neces\u00adsary to ensure that we update existing heap paths when creating a new heap \npath. The reason is that the .ow-down rule ensures that reference involved in new heap paths must .ow \ndown. Call Site: For the call site c(a0, ..., an), the callee s read and write e.ects are propagated \nto the caller. The analysis .rst com\u00adputes the sets OWc and Rc for all possible callees. bound , WT c \nbound bound st x=y.f HP' = HP . {(x, p . f ) | p . HP(y)} Rnew = {p . f | p . HP(y), .p' . WT . \u00acPre(p \n. f, p')} Rm' = Rm . Rnew x.f=y WT ' = WT . {HP(x) . f } OWm' = OWm . {HP(x) . f } call c(a0 , ..., an \n) Rc bound = c.calleeS et(c),i.{0,...,n}{HP(ai ) 0 r | r . Rc . Eq(r, pi)} OWc bound = c.calleeS et(c),i.{0,...,n}{HP(ai \n) 0 r | r . OWc . Eq(r, pi)} WT c bound = c.calleeS et(c),i.{0,...,n}{HP(ai ) 0 r | r . WT c . Eq(r, \npi )} Rnew = {p | p . Rc bound , .p' . WT . \u00acPre(p, p')} Rm' = Rm . Rnew OWm' = OWm . OWc bound WT ' \n= WT . WTc bound merge WT' = i.pred(st)WTi exit WT m = i.pred(st) WTi Figure 7. Transfer Functions for \nComputing Read and Write Sets (a0, a1, ..., an). b = (a0, ..., an, b) (a0, a1, ..., an)0(b0, b1, ..., \nbn) = (a0, ..., an, b1 , ..., bn ) Eq((a0, ..., an), (b0, ..., bn)) = (a0 = b0) Pre((a0, ..., an), (b0, \n..., bk )) = k = n . ((a0, ..., ak ) = (b0 , ..., bk )) Figure 8. Auxiliary Operators and Functions The \noperator 0 converts the e.ects of the callee to the caller by replacing a parameter reference with the \ncorresponding argument heap path. For example, the argument has the heap path (d, g) that is passed as \nthe parameter x to the callee c. If the callee has the two read tuples (x, y, a) and (x, y, b) in its \nset Rc, the correspond\u00ading caller context read tuples (d, g, y, a) and (d, g, y, b) are added to the \nset Rc . The set Rc and OWc are the union of all boundbound bound possible callees, and the set WT c \nis the intersection of all possi\u00ad bound ble callees. Then, the set Rm of the caller gains an element \nof Rc bound if that element or some pre.x has not been written by the caller m. The set OWm and WT also \ngain write e.ects from OWc and bound WT c , respectively. bound Control Flow Join: The join operation \nof the must-write set WT is intersection because memory locations must be overwritten on all possible \nprogram paths. Method Exit: Without loss of generality, we assume the method exit node appears after \nall return nodes of the method. The set WT m is the intersection of the set WTi for all predecessors \ni. Arrays: Arrays are handled in a similar fashion to .elds with special support for the array speci.c \ncalls in the SJava library.  5.1.2 Checking the Main Event Loop We next describe the operation of the \nde.nitely-written analysis on the event loop. The de.nitely-written analysis must ensure that all memory \nlocations that the event loop reads are either (1) loop invariant, (2) overwritten in the current loop \nbefore the read, or (3) overwritten in every loop iteration. For reads from local variables, we check \nwith a straightforward data.ow analysis that either (1) all reaching de.nitions are from outside the \nevent loop, (2) the variable must be overwritten in the current loop before the read statement, or (3) \nthe variable must be overwritten in every loop iteration.  For reads from the heap, we check the condition \nin the main event loop at each call site and each .eld dereference. For each newly read heap path p in \nthe set Rnew for the statement st, we check that either: 1. that the heap path p is never written in \nthe event loop, i.e., p r OW, 2. that the heap path p or some pre.x is overwritten in the cur\u00adrent event \nloop before executing the statement st, i.e., .p '. WTst, Pre(p, p '), or 3. that the heap path p or \nsome pre.x is overwritten in every loop iteration, i.e., at every loop backedge statement st '.p '. WTst \n' , Pre(p, p ').   5.2 Shared Location Extension Recall that all memory locations with the same shared \nlocation must be overwritten with values from a higher location at the same time. Our analysis for shared \nlocations checks that one of following conditions is satis.ed for all memory locations with the same \nshared location type at the same program point: (1) the value in the memory location was written in the \ncurrent loop iteration from a higher memory location or (2) one of the references in the heap path that \nleads to the memory location was written in the current loop iteration. The shared location analysis \nis an extension to the de.nitely\u00adwritten analysis. The analysis computes a mapping from a shared location \nto a set of heap paths or variables that belong to the same shared location. When a program statement \nwrites a shared memory location, the analysis adds the memory location to the set only if the value being \nassigned to is from a higher location. If the value has the same shared location type, the memory location \nis removed from the set. Whenever all memory locations with the same shared location type are cleared \nout, the de.nitely-written analysis adds the shared location type to the currently cleared shared locations \ntypes set for the current program point. The analysis then uses this set to compute at each statement \nwhich shared locations must be cleared in the current loop iteration before reaching a given statement. \nIt then uses the shared locations must be cleared set in an analogous fashion to the set WT. 6. Termination \nof Event Loop Iterations SJava ensures that values .ow out of a program after a bounded number of iterations \nof the main event loop. It is of course possible for an iteration of the main event loop to fail to terminate \ndue to memory corruption, a software bug, or by design. In this situation, an application could fail \nto self-stabilize because it never .nishes an iteration of the main event loop and therefore the corrupted \nvalues never leave. We must therefore assure that every loop iteration of the main event loop terminates. \nThe halting problem is of course known to be undecidable. The proposed termination analysis instead targets \nchecking common terminating loop patterns. In the next section, we describe how SJava checks that the \nexecution of inner loops terminates. SJava addresses the possibility of looping recursive calls by prohibiting \nrecursive calls. 6.1 Loop Termination Analysis We implemented a simple loop termination analysis. Our \nanalysis veri.es loop termination if a loop both (1) has an index variable and at each iteration the \nindex variable is incremented by a constant value and (2) every iteration of the loop evaluates at least \none inequality of the appropriate form for the increment statement and that consists of the index variable \nand a guard value that does not change over the iterations. The most common type of for-loop follows \nthis pattern. For every nested loop in the event loop, the compiler .rst com\u00adputes the set of induction \nvariables and then checks that every loop iteration evaluates at least one conditional loop exit that \nis com\u00adposed of an appropriate inequality of an induction variable and an invariant value. This check \nguarantees that the loop terminates be\u00adcause at each iteration, the induction variable proceeds toward \nthe termination condition by increasing its value.  6.2 Loop Termination Annotations This simple analysis \ncannot always determine that a loop termi\u00adnates. Prohibiting the remaining loops is unlikely to be practical. \nTo support loops where the SJava compiler cannot statically reason about termination, SJava provides \ntwo loop annotations: the maxi\u00admum loop annotation and the unchecked annotation. The maximum loop annotation \nmodi.es the original loop to en\u00adforce a developer-speci.ed loop iteration bound. When the com\u00adpiler .ags \na possible in.nite loop, the developer can simply anno\u00adtate the loop with a maximum loop annotation to \nforce the loop to terminate within a given iteration bound. The compiler then gener\u00adates code to enforce \nthis bound. It can be di.cult to specify a maximum iteration bound for cer\u00adtain types of loops. In this \ncase, developers can manually analyze the loop. If the developer manually checks that the loop terminates, \nthe developer can apply a special unchecked annotation to the loop. Unchecked loops are indicated with \na Java loop label that starts with the string TERMINATE . The compiler then trusts that the de\u00adveloper \nhas checked that the annotated loop always terminates. 7. Code Generation for Self-Stabilization SJava \nchecks that if an execution continues, it will self-stabilize into the correct state. However, an uncaught \nexception can cause the program to terminate before it self-stabilizes. There are two dif\u00adferent approaches \nfor handling such errors. In many cases, it may be appropriate to simply restart the program. Even in \nsuch cases, checking that the program is self-stabilizing ensures that silent soft\u00adware bugs cannot leave \nthe program in incorrect states inde.nitely. In other cases, the restart time may be signi.cant. In these \ncases, the developer may choose to ignore uncaught exceptions. Note that the period of incorrect behavior \ncaused by ignoring the error is lim\u00adited because SJava ensures that the execution will self-stabilize \ninto the correct state. Our compiler therefore implements an option to eliminate uncaught exceptions \nwe simply generate code that logs the error and then gives the error cases de.ned behavior. For exam\u00adple, \nunder this option dereferencing a null pointer simply produces another null pointer. Virtual method calls \non null receiver objects pose a related problem self-stabilization may rely on code inside one of the \ntargets of the call executing. In this case, the execution would choose one of the possible method targets \nto execute. 8. Correctness We next sketch the basic correctness argument for SJava. Lemma 1 (Top Values). \nIf an SJava program type checks and passes the static analyses, then memory locations with the top location \ntype have the correct values after one loop iteration. Proof Sketch: After one loop iteration, memory \nlocations with the top location cannot be corrupted as they are either constants or input data for the \ncurrent loop iteration.  Lemma 2 (Propagation). If SJava type checks a program and all memory locations \nwith location types with a maximum distance of n from the top value in the lattice have correct values \nat the beginning of a non-erroneous loop iteration, then all live memory locations with locations types \nwith a maximum distance of n + 1 from the top value in the lattice must have correct values at the end \nof the loop iteration. Proof Sketch: If a memory location has a location type with a maximum distance \nof n + 1, then all memory locations that are higher than it must have correct values (they have lower \nmaximum distances) by assumption. If a value in a memory location is live (there is a read that could \nread this value before it is overwritten), then SJava requires each loop iteration to overwrite the memory \nlocation. The new value must be correct as all locations higher than this memory location have correct \nvalues. Theorem 1 (Self-Stabilization). If an SJava program type checks and passes the static analyses, \nthen it self-stabilizes. Proof Sketch: The location type lattice has a .nite height, there\u00adfore by induction \non Lemmas 1 and 2 all non-constant memory locations will eventually have the correct values. 9. Evaluation \nWe implemented a compiler for SJava and evaluated it by annotat\u00ading three existing Java applications: \nJLayer, an MP3 decoder; LEA, an eye-tracker; and Sumo Robot, a robot controller. We conducted experiments \nin which we randomly injected er\u00adrors to measure the self-stabilizing behavior of each benchmark. Our \ncompiler generated error injection code that randomly selects memory and mathematical operations, and \nreplaces the original value with a random value. 9.1 MP3 Decoder JLayer is an MP3 decoder and is available \nat http://www. javazoom.net/javalayer/javalayer.html. MP3 .les are composed of a sequence of frames. \nIn JLayer, every event loop it\u00aderation retrieves a BitStream object that corresponds to a frame. The \nBitStream object reads and returns one frame from the in\u00adput audio .le and maintains persistent state \nto store the .le o.\u00adset. The BitStream object was carefully manually designed to be self-stabilizing \nby resyncing to MP3 frames, and we annotated the BitStream object as trusted to self-stabilize. We focused \nour e.orts on automatically checking that the more complex decoder is self-stabilizing. The decoder is \nself-stabilizing because the event loop .ushes out all non loop-invariant state within a bounded time. \nAs long as the event loop retrieves new valid audio frames, it will resume the normal behavior from an \narbitrary state of the non-loop invariant storage. We modi.ed the program to minimize interactions between \ntrusted components and checked components. Interactions between trusted and checked components (i.e., \nmore than one method call per loop iteration or inputs to trusted components) make manu\u00adally checking \ntrusted code more di.cult. For example, if a trusted method takes parameters from the self-stabilization \ncode, the de\u00adveloper must reason about the behavior of the trusted code with potentially corrupted parameter \nvalues. We found that the last two steps in the original code, the IMDCT and the Synthesis Filter Bank, \nuse the results from the previous frame. In the original code, the results from two di.erent loop iterations \nare stored in the same array, which makes it di.cult to reason about value .ows. Therefore, we use two \nseparate arrays one to store the merged results and one to forward results from the current loop iteration \nto the next loop iteration. Our experiments were designed to qualitatively evaluate how the program self-stabilizes \nafter an error corrupts its state. We ran\u00addomly injected an error during the program s execution and \nmea\u00adsured the time until the program resumes outputting the correct values. We performed 1,000 trials \nof the experiment and observed 466 trials with corrupted outputs. Figure 9 shows the distribution of \nthe number of output samples from when the error is injected un\u00adtil the point at which JLayer returned \nto outputting normal values. JLayer returned to normal behavior in less than 500 output sam\u00adples when \nan error was injected into the transformation to generate PCM samples, which is the .nal step of the \ndecoding process. The large peak at 1,700 samples occurs when an error is injected into the frequency \ndomain transformations for one of the two granules that comprise a frame. Because the frequency transformation \ncom\u00adputations involve many operations, such error injections are likely. The corrupted results of the \ncomputation then continue to a.ect the output for approximately 1,700 samples. In general, errors that \ncor\u00adrupted an internal data structure, for instance the bu.er index of the BitStream,a.ected more output \nsamples. In all cases, errors a.ected fewer than 2,208 output samples. Figure 10 shows a section of JLayer \ns decoded audio signal output from one of the trials. The normal output of JLayer is plotted in blue. \nThe output from the execution with error injection is plotted in red. The red box is due to the signal \nfor the error execution deviating from the normal execution by oscillating at high frequency between \n-32,767 and 32,767. After 1,630 samples the program behavior returned to normal until termination. Figure \n9. Distribution of the number of output samples required for the program to return to the normal behavior \nafter an error injection.  Benchmark Location Lattice Method Default Lines MP3 Decoder Eye Tracking \nRobot Control 690 143 77 54 33 15 24 21 13 15,634 4,571 3,201 Figure 11. Number and Type of Annotations \n  9.2 Eye Tracking LEA is a lightweight eye tracking algorithm library and is available at http://sourceforge.net/projects/lea-eyetracking/. \nAt each iteration, LEA takes an input image from a web cam, tracks eye movements, and returns relative \nmovements in 8 direc\u00adtions (i.e., up, left, down, ...). The algorithm .rst detects a face in the input \nimage, which allows it to localize the search region for eye detection. When an eye position is detected, \nLEA determines movement by computing the deviation from the last three eye posi\u00adtions. LEA stores the \nlast three eye positions in the array to provide a better estimation. Every iteration inserts a new position \nat the be\u00adginning of the array and shifts the previous results down by one. All memory locations except \nthe array of previous positions are overwritten in each iteration. The previous positions are not used \nto compute new positions while the direction result is derived from the three previous positions. Thus, \nthe program returns the correct execution within three iterations of the event loop. We annotated LEA \nand checked that it self-stabilizes. We mod\u00adi.ed the original code to convert multi-threaded code to \nsingle\u00adthreaded code. No other modi.cations were necessary to verify self-stabilization. We performed \n100 executions with injected errors and observed 8 executions with changed output samples. For each trial, \nwe ran\u00addomly injected errors at 10 consecutive instructions and compared eye positions and direction \ndecisions with the correct output gener\u00adated by the non-instrumented version. In our 8 trials, LEA returned \nto outputting correct values in the next iteration of the main event loop. While the SJava annotations \nimply a longer worst-case self\u00adstabilization period, in practice it is hard to trigger this behavior \nthrough randomized error injection. 9.3 Robot Control Sumo Robot controls robots and is available at \nhttp://java. net/projects/sumorobots/. The goal of a Sumo Robot is to push the opponent out of a ring \nwhile staying away from the ring edge. A robot is equipped with two types of sensors: a sonar sensor, \nwhich detects the opponent, and a line sensor, which detects the ring edge. Each iteration of the event \nloop reads data from the sensors, selects a movement type and speed, and then generates a motor controller \ncommand. The StrategyMgr object implements the analysis of the sensor input and the selection of the \nmovement type. Once a motor control command is sent to the hardware, the command persists until another \ncommand is sent. We do not attempt to automatically analyze the motor controller because it is not stateless. \nWe annotated the motor controller as trusted code, and modi.ed the original code to make sure that every \niteration overwrites the command arguments to the motor controller. We evaluated the behavior of the \nSumo Robot controller using simulated sensor inputs. We performed 100 error-injected execu\u00adtions. For \neach execution, we recorded the movement decisions of the strategy controller at every iteration of the \nevent loop, and then compared the movement decisions with the output from an error\u00adfree execution. In \nthe presence of the injected errors, we observed 54 trials with changed outputs and observed that the \nSumo Robot controller resumed the normal behavior in the next iteration of the main event loop after \nthe error occurred.  9.4 Annotation E.ort In SJava, the developer must annotate all variable, .eld, \nand method declarations accessed by the event loop. We found the location type errors from the compiler \nhelpful in correctly annotating the code. Figure 11 summarizes our annotation e.ort. For each bench\u00admark, \nwe list the number of location assignments using @LOC in the Location column, the number of lattice de.nitions \nusing @LATTICE in the Lattice column, the number of default method lattice de.ni\u00adtions using @METHODDEFAULT \nin the Method Default column, and lines of code including libraries. We found de.ning the structure of \nlattices to be straightforward. The default method lattice reduces the number of annotations because \nmany methods share a similar structure and therefore we simply reused the same lattice. While the annotations \ndo require extra developer e.ort, we found that this e.ort was small for our benchmarks, especially when \ncompared to the e.ort of manually checking self-stabilization. In our experience, SJava required minimal \ndevelopment e.ort once we understood the overall design of the program because value .ows often re.ect \ninteractions between individual modules in the design speci.cation. If a developer intends to develop \na new software system for SJava, our experience leads us to believe that e.ort involved in annotating \ncode will marginally exceed the amount of e.ort required to write Java types. 10. Related Work Self-stabilization \nwas initially suggested by Dijkstra in the context of robust distributed algorithms [6]. There has recently \nbeen work by Dolev et al. [7 9] that proposes techniques to ensure that the underlying layers (processor, \noperating system, and compiler) pre\u00adserve the self-stabilizing nature of an application. Their work does \nnot check that the actual application is self-stabilizing. Therefore, our work on SJava to check that \napplications self-stabilize is com\u00adplementary to this work. Language-based information .ow employs type \nsystems to check that information .ows in an application do not violate the desired requirements[12, \n15, 16]. Our approach is similar in some aspects. The key di.erences are that our approach must support \nmuch .ner-grained divisions of data and must check that values only remain in a given location for a \nbounded time. Linear types have been leveraged in programming languages[10, 11, 19] for various purposes \nincluding safe concurrent programming, resource management, and protocol checking. SJava uses a modi.ed \nlinear type system to avoid soundness problems from aliasing. Termination analysis plays an important \nrole in verifying safety critical systems. Even though it is not possible to have a sound and complete \nter\u00admination analysis, several proposed techniques are mature enough to analyze termination in many cases \n[1 4, 18]. If necessary, we could easily replace our termination analysis with more sophisti\u00adcated approaches. \nFailure-oblivious computing [13] enables programs to continue execution past memory errors by manufacturing \nvalues for reads or discarding writes. This approach works well for applications with short error propagation \ndistances. Our work is complementary in that it can guarantee that a program has short error propagation \ndis\u00adtances. Other work detect bugs and tries re-execution in a slightly di.erent environment [17]. Data \nstructure repair [5] takes an in\u00ad terventional approach; upon detecting data structure corruption, it \nrepairs them with respect to a speci.cation. Data structure repair only guarantees that a program will \nreach some consistent state, while our work guarantees that all e.ects of the bug eventually dis\u00adappear. \nMoreover, our approach does not require a speci.cation and therefore eliminates the need to precisely \nde.ne correct behavior.  11. Conclusion Self-stabilization has long been proposed as an approach for \nfault tolerance. Wide scale guarantees of self-stabilization have the po\u00adtential to signi.cantly improve \nthe safety and user experience of software systems. SJava is the .rst system for checking that ap\u00adplications \nare self-stabilizing. A developer simply annotates the source code to capture the .ow of values. The \nSJava compiler then checks that incorrect values will eventually leave the program re\u00adturning the program \nto the exact correct state. Our experience indi\u00adcates that this approach can successfully check self-stabilization \nof our benchmark applications. Acknowledgments This research was supported by the National Science Foundation \nunder grants CCF-0846195 and CCF-0725350. We would like to thank Patrick Lam, Harry Xu, Philip Reames, \nPhilippe Suter, and the anonymous reviewers for their helpful comments. We would like to thank James \nJenista for help with the experiments. References [1] A. Bradley, Z. Manna, and H. Sipma. Termination \nof polynomial pro\u00adgrams. In Proceedings of Veri.cation, Model Checking, and Abstract Interpretation, \nvolume 3385, pages 113 129. 2005. [2] J. Brotherston, R. Bornat, and C. Calcagno. Cyclic proofs of program \ntermination in separation logic. pages 101 112, 2008. [3] B. Cook, A. Podelski, and A. Rybalchenko. Termination \nproofs for systems code. In Proceedings of the 2006 ACM SIGPLAN Conference on Programming Language Design \nand Implementation, pages 415 426, 2006. [4] B. Cook, A. Podelski, and A. Rybalchenko. Proving thread \ntermi\u00adnation. In Proceedings of the 2007 ACM SIGPLAN Conference on Programming Language Design and Implementation, \npages 320 330, 2007. [5] B. Demsky and M. Rinard. Data structure repair using goal-directed reasoning. \nIn Proceedings of the 27th International Conference on Software Engineering, pages 176 185, 2005. [6] \nE. W. Dijkstra. Self-stabilizing systems in spite of distributed control. Communications of the ACM, \n17:643 644, November 1974. [7] S. Dolev, Y. Haviv, and M. Sagiv. Self-stabilization preserving com\u00adpiler. \nACM Transactions on Programming Languages and Systems, 31:22:1 22:42, August 2009. [8] S. Dolev and Y. \nA. Haviv. Self-stabilizing microprocessor: Analyz\u00ading and overcoming soft errors. IEEE Transactions on \nComputers, 55:385 399, 2006. [9] S. Dolev and R. Yagel. Toward self-stabilizing operating systems. In \nProceedings of the 15th International Conference on Database and Expert Systems Applications, pages 684 \n 688, 2004. [10] M. Fahndrich and R. DeLine. Adoption and focus: practical linear types for imperative \nprogramming. In Proceedings of the 2002 ACM SIGPLAN Conference on Programming Language Design and Imple\u00admentation, \npages 13 24, 2002. [11] P. Haller and M. Odersky. Capabilities for uniqueness and borrowing. In Proceedings \nof the 24th European Conference on Object-Oriented Programming, pages 354 378, 2010. [12] A. C. Myers. \nJFlow: Practical mostly-static information .ow control. In Proceedings of the Symposium on Principles \nof Programming Lan\u00adguages, pages 228 241, 1999. [13] M. Rinard, C. Cadar, D. Dumitran, D. M. Roy, T. \nLeu, and W. S. Bee\u00adbee, Jr. Enhancing server availability and security through failure\u00adoblivious computing. \nIn Proceedings of the 6th Symposium on Oper\u00adating Systems Design and Implementation, 2004. [14] M. C. \nRinard. Living in the comfort zone. In Proceeding of the 22nd ACM SIGPLAN Conference on Object-Oriented \nProgramming, Systems, Languages, and Applications, 2007. [15] A. Sabelfeld and A. Myers. Language-based \ninformation-.ow secu\u00adrity. IEEE Journal on Selected Areas in Communications, 21(1):5 19, January 2003. \n[16] A. Sampson, W. Dietl, E. Fortuna, D. Gnanapragasam, L. Ceze, and D. Grossman. EnerJ: Approximate \ndata types for safe and general low-power computation. In Proceedings of the 2011 ACM SIGPLAN Conference \non Programming Language Design and Implementation, pages 164 174, 2011. [17] S. Sidiroglou, M. E. Locasto, \nS. W. Boyd, and A. D. Keromytis. Build\u00ading a reactive immune system for software services. In Proceedings \nof the USENIX Annual Technical Conference, 2005. [18] F. Spoto, F. Mesnard, and E. Payet. A termination \nanalyzer for Java bytecode based on path-length. ACM Transactions on Programming Languages and Systems, \n32:8:1 8:70, March 2010. [19] P. Wadler. Linear types can change the world! In Proceedings of the International \nConference on Programming Concepts and Methods, 1990.     \n\t\t\t", "proc_id": "2254064", "abstract": "<p>Self-stabilizing programs automatically recover from state corruption caused by software bugs and other sources to reach the correct state. A number of applications are inherently self-stabilizing---such programs typically overwrite all non-constant data with new input data. We present a type system and static analyses that together check whether a program is self-stabilizing. We combine this with a code generation strategy that ensures that a program continues executing long enough to self-stabilize. Our experience using SJava indicates that (1) SJava annotations are easy to write once one understands a program and (2) SJava successfully checked that several benchmarks were self-stabilizing.</p>", "authors": [{"name": "Yong hun Eom", "author_profile_id": "81470644632", "affiliation": "University of California, Irvine, Irvine, CA, USA", "person_id": "P3471226", "email_address": "yeom@uci.edu", "orcid_id": ""}, {"name": "Brian Demsky", "author_profile_id": "81100338144", "affiliation": "University of California, Irvine, Irvine, CA, USA", "person_id": "P3471227", "email_address": "bdemsky@uci.edu", "orcid_id": ""}], "doi_number": "10.1145/2254064.2254099", "year": "2012", "article_id": "2254099", "conference": "PLDI", "title": "Self-stabilizing Java", "url": "http://dl.acm.org/citation.cfm?id=2254099"}