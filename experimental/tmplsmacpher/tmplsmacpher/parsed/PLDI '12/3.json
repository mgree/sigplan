{"article_publication_date": "06-11-2012", "fulltext": "\n The Implicit Calculus ANewFoundationfor GenericProgramming Bruno C. d. S. Oliveira Tom Schrijvers Wontae \nChoi Seoul National University Universiteit Gent Seoul National University bruno@ropas.snu.ac.kr tom.schrijvers@ugent.be \nwtchoi@ropas.snu.ac.kr Wonchan Lee Seoul National University wclee@ropas.snu.ac.kr Abstract Generic \nprogramming (GP) is an increasingly important trend in programming languages. Well-known GP mechanisms, \nsuch as type classes and the C++0x concepts proposal, usually combine two features: 1) a special type \nof interfaces; and 2) implicit instan\u00adtiation of implementations of those interfaces. Scala implicits \nare a GP language mechanism, inspired by type classes, that break with the tradition of coupling implicit \ninstantia\u00adtion with a special type of interface. Instead, implicits provide only implicit instantiation, \nwhich is generalized to work for any types. This turns out to be quite powerful and useful to address \nmanylim\u00aditations that show upin other GP mechanisms. This paper synthesizes the key ideas of implicits \nformally in a minimal and general core calculus called the implicit calculus (a.), and it shows how tobuild \nsource languages supporting im\u00adplicit instantiationontopofit.A noveltyofthe calculusisitssup\u00adport for \npartialresolution and higher-order rules (afeature that has been proposed before,butwas never formalized \nor implemented). Ultimately,the implicit calculusprovidesaformal modelof implic\u00adits, which can be used \nby language designers to study and inform implementations of similar mechanisms in their own languages. \nCategories and Subject Descriptors D.3.2[Programming Lan\u00adguages]:Language Classi.cations Functional Languages, \nObject-Oriented Languages; F.3.3[Logics and Meanings of Programs]: Studies of Program Constructs GeneralTerms \nLanguages Keywords Implicit parameters, type classes, C++ concepts, generic programming, Haskell, Scala. \n1. Introduction Generic programming (GP) [23] is a programming style that de\u00adcouples algorithms from \nthe concrete types on which they oper\u00adate. Decouplingis achieved through parametrization.Typical forms \nPermission to make digital or hard copies of all or part of this work for personal or classroom use is \ngranted without fee provided that copies are not made or distributed for pro.t or commercial advantage \nand that copies bear this notice and the full citation on the .rst page.To copyotherwise, to republish, \nto post on servers or to redistribute to lists, requires prior speci.c permission and/or a fee. PLDI \n12, June 11 16, Beijing, China. Copyright c . 2012ACM 978-1-4503-1205-9/12/06...$10.00. KwangkeunYi Seoul \nNational University kwang@ropas.snu.ac.kr of parametrization include parametrization by type (for example: \nparametric polymorphism, generics or templates)or parametriza\u00adtionby algebraic structures (such asa monoid \nora group). A central idea in generic programming is implicit instantia\u00adtion of generic parameters. Implicit \ninstantiation means that, when generic algorithms are called with concrete arguments, the generic arguments \n(concrete types, algebraic structures, or some other form of generic parameters) are automatically determined \nby the com\u00adpiler. The bene.t is that generic algorithms become as easy to use as specialized algorithms.To \nillustrate implicitinstantiation and its bene.ts consider a polymorphic sorting function: sort [.]:(. \n= . = Bool) = List . = List . with3 parameters: the type of the elements in the list(.); the comparison \noperator; and the list to be compared. Instantiating all 3 parameters explicitly at every use of sort \nwould be quite tedious. It is likely that, for a given type, the sorting function is called with the \nsame, explicitly passed, comparison function over and over again. Moreover it is easy to infer the type \nparameter .. GP greatly simpli.es such calls by making the type argument and the comparison operator \nimplicit. isort : ...(. = . = Bool) . List . = List . The function isort declares that the comparison \nfunction is implicit by using . instead of =. It is used as: implicit {cmpInt : Int = Int = Bool } in \n(isort [2, 1, 3], isort [5, 9, 3]) The twocalls of isort each takeonly oneexplicit argument: the list \nto be sorted. Both the concrete type of the elements(Int)and the comparison operator(cmpInt)areimplicitly \ninstantiated. The element type is automatically inferred from the type of the list. More interestingly, \nthe implicit comparison operator is automatically determinedinaprocess called resolution. Resolution \nis a type-directed process that uses a set of rules, the implicit (or rule)environment, to .nd a value \nthat matches the type required by the function call. The implicit construct extends the implicit environmentwithnew \nrules.In otherwords, implicit isa scoping construct for rules similar to a conventional let-binding. \nThus, in the subexpression (isort [2, 1, 3], isort [5, 9, 3]), cmpInt is in the local scope and available \nfor resolution. 1.1 ExistingApproachesto GenericProgramming The two main strongholds of GP are the C++ \nand the functional programming (FP) communities. Many of the pillars of GP are based on the ideas promoted \nby Musser and Stepanov [23]. These ideas were used in C++ libraries such as the Standard Template Library \n[24] and Boost [1]. In the FP community, Haskell type classes [42] have proven to be an excellent mechanism \nfor GP, although their original design did not have that purpose. As years passedtheFP community createditsown \nformsofGP[14,10,21].  Garcia et al. s [9] comparative study of programming language support for GP was \nan important milestone for both communi\u00adties. According to that study many languages provide some sup\u00adport \nfor GP. However, Haskell did particularly well, largely due to type classes.A direct consequenceofthatworkwastobringthe \ntwo main lines of work on GP closer together and promote cross\u00adpollination of ideas. Haskell adopted \nassociated types [4, 3], which was the only weak point foundin the original comparison.For the C++ community, \ntype classes presented an inspiration for develop\u00ading language support for concepts [23, 11, 35]. Several \nresearchers started working on various approaches to concepts (see Siek s work [34] for a historical \noverview). Some re\u00adsearchers focused on integrating concepts into C++ [7, 11], while others focused on \ndeveloping new languages with GP in mind. The work on System F G [35, 36] is an example of the latter \nap\u00adproach: Building on theexperience from the C++ generic program\u00adming community and some of the ideas \nof type classes, Siek and Lumsdaine developed a simple core calculus based on System F which integrates \nconcepts and improves on type classes in several respects. In particular, System F G supports scoping \nof rules1. During the same period Scala emerged as new contender in the area of generic programming. \nMuch like Haskell, Scala was not originally developed with generic programming in mind. However Scala \nincluded an alternative to type classes: implicits. Implicits were initially viewed as a poor man s type \nclasses [26].Yet, ulti\u00admately, theyproved to be quite .exible and in some ways superior totype classes.Infact \nScala turnsouttohaveverygood support for generic programming [28, 29]. A distinguishing feature of Scala \nimplicits, and a reason for theirpower,isthat resolutionworksfor any type. This allows Scala to simply \nreuse standard OO interfaces/classes (which are regular types) to model concepts, and avoids introducing \nanother type of interface in the language. In contrast, with type classes, or the various concept proposals, \nresolution is tightly coupled with the type class or concept-like interfaces.  1.2 Limitations of Existing \nMechanisms Twentyyears of programming experience with type classesgave the FP community insights about \nthe limitations of type classes. Some of these limitations were addressed by concept proposals. Other \nlimitations were solvedby implicits.However, asfar as we know, no existing language or language proposal \novercomes all limitations.We discuss these limitations next. Global scoping: In Haskell, rules2 are global \nand there can be only a single rule for anygiven type [18, 2, 6, 8]. Locally scoped rules are notavailable.Several \nresearchershavealready proposedto .xthis issue:withnamedrules[18]orlocallyscoped ones[2,6,8]. However \nnone of those proposals have been adopted. Both proposals for concepts and Scala implicits offer scoping \nof rules and as such do not suffer from this limitation. Second class interfaces: Haskell type classes \nare second-class constructs compared to regular types: in Haskell, it is not possible to abstract over \na type class [13]. Yet, the need for .rst-class type classesis realin practice.Forexample,L\u00a8 ammel and \nPeyton Jones [21] desire the following type class for their GP approach: 1In the context of C++ rules \ncorrespond to models or concept maps. 2In the context of Haskell rules correspond to type-class instances. \nclass (Typeable ., cxt .) . Data cxt . where gmapQ :: (...Data cxt . . . = r) = . =[r ] In this type \nclass, the intention is that the ctx variable abstracts over a concrete type class. Unfortunately, Haskell \ndoes not support type class abstraction. Proposals for concepts inherit this limitation from type classes. \nConcepts and type classes are usually interpreted as predicates on types rather than types, and cannot \nbe abstracted over as regular types. In contrast, because in Scala concepts are modeledwithtypes,itispossibleto \nabstractover concepts.Oliveira and Gibbons [28] show how to encode this example in Scala. No higher-order \nrules: Finally type classes do not support higher-order rules. As noted by Hinze and Peyton Jones [12], \nnon\u00adregular Haskell datatypes like: data Perfect f . = Nil | Cons . (Perfect f (f .)) require type class \ninstances such as: instance (...Show . . Show (f .), Show .) . Show (Perfect f .) which Haskell does \nnot support, as it restricts instances (or rules) to be .rst-order. This rule is higher-order because \nit assumes another rule, ...Show . . Show (f .), that contains an assumption itself. Also note that this \nassumed rule is polymorphic in .. Both concept proposals and Scala implicits inherit the limitation of \n.rst-order rules.  1.3 Contributions This paper presents a., a minimal and general core calculus for \nimplicitsanditshowshowtobuilda source language supporting implicit instantiation on top of it. Perhaps \nsurprisingly the core calculus itself does not provide implicit instantiation: instantia\u00adtion of generic \narguments is explicit. Instead a. provides twokey mechanisms for generic programming:1)atype-directed \nresolution mechanism and 2) scoping constructs for rules. Implicit instantia\u00adtionisthenbuiltasaconvenience \nmechanismontopof a. bycom\u00adbining type-directed resolution with conventional type-inference. Weillustrate \nthis onasimple,but quiteexpressivesource language. The calculus is inspired by Scala implicits and it \nsynthesizes core ideas of that mechanism formally. In particular, like Scala implicits, a key idea is \nthat resolution and implicit instantiation work for anytype. This allows those mechanisms to be more \nwidely useful and applicable, since they can be used with other types in the language. The calculus is \nalso closely related to System F G , and like System F G, rules available in the implicit environment \nare lexically scoped and scopes can be nested. Anovelty of our calculus is its support for partial resolution \nand higher-order rules. Although Hinze and Peyton Jones [12] havedis\u00adcussed higher-order rules informally \nand several other researchers noted their usefulness[40,31,28],noexisting languageor calculus provides \nsupport for them. Higher-order rules are just the analogue of higher-order functions in the implicits \nworld. They arise natu\u00adrally once we take the view that resolution should work for any type.Partial resolution \nadds additional expressivepower anditis especially useful in the presence of higher-order rules. From \nthe GP perspective a. offers a new foundation for generic programming. The relation between the implicit \ncalculus and Scala implicits is comparable to the relation between System F G and various concept proposals; \nor the relation between formal calculi of type classes and Haskell type classes: The implicit calcu\u00adlus \nis a minimal and general model of implicits useful for language designers wishing to study and inform \nimplementations of similar GP mechanisms in their own languages.  In summary, our contributions are \nas follows. Our implicit calculus a. provides a simple, expressive and general formal model for implicits. \nDespite its expressiveness, the calculus is minimal and provides an ideal setting for the formal study \nof implicits and GP.  Of particular interest is our resolution mechanism, which is signi.cantly more \nexpressive than existing mechanisms in the literature. It is based on a simple (logic-programming style) \nquery language, works for any type, and it supports partial resolution as well as higher-order rules. \n The calculus has a polymorphic type system and an elaboration semantics to SystemF. This also provides \nan effective imple\u00admentation of our calculus. The elaboration semantics is proved to be type-preserving, \nensuring the soundness of the calculus.  We presenta small,but realistic source language,built on top \nof a. via a type-directed encoding. This language features implicit instantiation and a simple type of \ninterface, which can be used to model simple forms of concepts. This source language also supports higher-order \nrules.  Finally, both a. and the source language have been imple\u00admented and the source code for their \nimplementation is avail\u00adable at http://ropas.snu.ac.kr/~bruno/implicit.  Organization Section2presentsan \ninformaloverviewofourcal\u00adculus. Section 3 shows a polymorphic type system that statically excludes ill-behaved \nprograms. Section 4 shows the elaboration semantics of our calculus into System F and correctness results. \nSection5presents the source language and its encoding into a.. Section6discusses comparisons and relatedwork. \nSection7 con\u00adcludes. The companion technical report [30] provides additional technical material and proofs. \n2. Overview of the Implicit Calculus .. Our calculus a. combines standard scoping mechanisms (abstrac\u00adtions \nand applications) and types ` a la System F, with a logic\u00adprogramming-style query language. At the heart \nof the language is a threefold interpretation of types: types .= rules = propositions . Firstly, types \nhave their traditional meaning of classifying terms. Secondly, via the Curry-Howard isomorphism, types \ncan also be interpreted as propositions in the context of GP, the type proposi\u00adtion denotes the availability \nin the implicit environment of a value of the corresponding type. Thirdly, a type is interpreted as a \nlogic\u00adprogramming style rule, i.e.,aProlog rule or Horn clause [19]. Res\u00adolution [20] connects rules \nand propositions: it is the means to show (theevidence) thata propositionis entailedbya setof rules. \nNext we present thekeyfeaturesof a. and how these features are used for GP.For readability purposes we \nsometimes omit re\u00addundant type annotations and slightly simplify the syntax. Fetching values by types: \nAcentral construct ina. is a query. Queries allow values to be fetched by type, not by name. For example, \nin the following function call foo ?Int the query ?Int looks up a value of type Int in the implicit environ\u00adment, \nto serve as an actual argument. Constructing values with type-directed rules: a. constructs values, using \nprogrammer-de.ned, type-directed rules (similar to functions). A rule (or rule abstraction) de.nes how \nto compute, from implicit arguments,avalueofa particular type.Forexample, here is a rule that computes \nan Int \u00d7Bool pair from implicit Int and Bool values: (|(?Int +1, \u00ac ?Bool): {Int, Bool }. Int \u00d7Bool|) \nThe rule abstraction syntax resembles a type-annotated expression: theexpression (?Int +1, \u00ac ?Bool) to \nthe left of the colon is the rule body, and to the right is the rule type {Int, Bool }. Int \u00d7Bool. A \nrule abstraction abstracts over a set of implicit values (here {Int, Bool }),or, more generally, over \nrulestobuildvalues. Hence, when a value of type Int \u00d7Bool is needed (expressed by the query ?(Int \u00d7Bool)), \nthe above rule can be used, provided that an integer and a boolean value are available in the implicit \nenvironment. In such an environment, the rule returns a pair of the incremented Int value and negated \nBool value. The implicit environment is extended through rule application (analogous to extending the \nenvironment with function applica\u00adtions). Rule application is expressed as, for example: (|(?Int +1, \n\u00ac ?Bool): {Int, Bool }. Int \u00d7Bool|) with {1, True } With syntacticsugar similartoalet-expression,arule \nabstraction\u00adapplication combination is denoted more compactly as: implicit {1, True } in (?Int +1, \u00ac \n?Bool) which returns (2, False). Higher-order rules: a. supports higher-order rules.Forexam\u00adple, the \nrule (|?(Int \u00d7Int): {Int, {Int }. Int \u00d7Int }. Int \u00d7Int|), when applied, will compute an integer pair \ngiven an integer and a rule to compute an integer pair from an integer. Hence, the following rule application \nreturns (3, 4): implicit {3, (|(?Int, ?Int +1) : {Int }. Int \u00d7Int|)} in ?(Int \u00d7Int) Recursive resolution: \nNote that resolving the query ?(Int \u00d7Int) involves applying multiple rules. The current environment does \nnot contain the required integer pair. It does however contain the integer 3 and a rule (|(?Int, ?Int \n+1) : {Int }. Int \u00d7Int|) to compute a pair from an integer. Hence, the query is resolved with (3, 4), \nthe result of applying the pair-producing rule to 3. Polymorphic rules and queries: a. allows polymorphic \nrules. For example, the rule (|(?., ?.): ...{.}. .\u00d7.|) can be instantiated to multiple rules of monomorphic \ntypes {Int }. Int \u00d7Int, {Bool }. Bool \u00d7Bool,... Multiple monomorphic queries can be resolved by the same \nrule. The following expression returns ((3, 3), (True, True)): implicit {3, True, (|(?., ?.): ...{.}. \n.\u00d7.|)} in (?(Int \u00d7Int), ?(Bool \u00d7Bool)) Polymorphic rules can also be used to resolvepolymorphic queries: \nimplicit {(|(?., ?.): ...{.}. .\u00d7.|)} in ?(...{.}. .\u00d7.) Combining higher-order and polymorphic rules: \nThe rule (|(?((Int \u00d7Int)\u00d7(Int \u00d7Int))) : {Int, ...{.}. .\u00d7.}. (Int \u00d7Int)\u00d7(Int \u00d7Int)|) prescribeshowtobuildapairofintegerpairs, \ninductivelyfroman integer value, by consecutively applying the rule of type ...{.}. .\u00d7.  twice: .rst \nto an integer, and again to the result (an integer pair). For example, the following expression returns((3, \n3), (3, 3)): implicit {3, (|(?., ?.): ...{.}. .\u00d7.|)} in ?((Int \u00d7Int)\u00d7(Int \u00d7Int)) Locally and lexically \nscoped rules: Rules can be nested and res\u00adolution respects the lexical scope of rules. Consider the following \nprogram: implicit {1} in implicit {True, (| if ?Bool then 2: {Bool }. Int|)}in ?Int The query ?Int is \nnot resolved with the integer value 1. Instead the rule that returns an integer froma booleanis appliedto \nthe boolean True, because those two rules can provide an integer value and they are nearer to the query. \nSo, the program returns 2 and not 1. Overlapping rules: Two rules overlap if their return types inter\u00adsect, \ni.e., when they can both be used to resolve the same query. Overlapping rules are allowed in a. through \nnested scoping. The nearest matching rule takes priorityover other matching rules.For example consider \nthe following program: implicit {ax.x : .... = .} in implicit {an.n +1: Int = Int } in ?(Int = Int)1 \n In this case an.n +1: Int = Int is the lexically nearest match in the implicit environment and evaluating \nthis program results in 2. However, if we have the following program instead: implicit {an.n +1: Int \n= Int } in implicit {ax.x : .... = .} in ?(Int = Int)1 Then the lexically nearest match is ax.x :.... \n= . andevaluating this program results in 1. 3. The .. Calculus This section formalizes the syntax and \ntype system of a.. 3.1 Syntax This is the syntax of the calculus: (Simple)Types . ::= . | Int | .1 = \n.2 | \u00df RuleTypes \u00df ::= ..\u00df . . Expressions e ::= n | x | ax : ..e | e1 e2 | ?\u00df | (|e : \u00df|) | e[.. ] | \ne with e : \u00df Types. are either typevariables .,the integer typeInt,function types .1 = or rule types \n\u00df.A rule type \u00df = ..\u00df . . .2 ..\u00afis a type scheme with universally quanti.ed variables ..and an (implicit) \ncontext \u00df\u00af. This context summarizes the assumed implicit environment. Note that we use .o to denote an \nordered sequence o1,...,on of entities and o\u00afto denote a set {o1,...,on}. Such ordered sequences and \nsets can be empty, and we often omit empty universal quanti.ers and empty contexts froma rule type. The \nbase case of rule types is when \u00af..{} . . or, \u00df is the empty set (that is ..more compactly, .. ...). \nExpressions include integer constants n and the three basic typed a-calculus expressions (variables, \nlambda binders and appli\u00adcations).A query ?\u00df queries the implicit environment foravalueof type \u00df.A rule \nabstraction (|e : ..\u00df . .|) builds a rule whose type is ..\u00df . . and whose body is e. Without loss of \ngenerality we assume that all variables x and type variables . in binders are distinct. If not, they \ncan be easily renamed apart to be so. Notethat,unlikeSystemF,our calculusdoesnothaveaseparate . binder \nfor type variables. Instead rule abstractions play a dual role in the binding structure: 1) the universal \nquanti.cation of type variables (which binds types), and 2) the context (which binds a rule set). Therefore,a \n. bindercanbe encodedusingarulewithan empty context: . .= ...|) ..(e : . ) def (|e : .. The design choice \nof making rules double binders is due to our interpretation of rules as logic programming rules3. After \nall, in the matching process of resolution, a rule is applied as a unit. Hence, separating rules into \nmore primitive binders(` a la System F stypeandvalue binders)wouldonly complicatethe de.nitionof resolution \nunnecessarily. However, elimination can be modularized into two constructs: type application e[\u00af.] and \nrule application e with e : \u00df. Using rule abstractions and applications we can build the implicit sugar \nthat wehave usedin Sections1and2. def implicit e : \u00df in e1 : . =(|e1 : \u00df . . |) with e : \u00df For readability \npurposes, when we useimplicit we omit the type annotation . . As we shall see in Section5this annotation \ncan be automatically inferred. For brevity and simplicity reasons, we havekepta. small. In examples we \nmay use additional syntax such as built-in integer operators and boolean literals and types.  3.2 Type \nSystem Figure1 presents the static type system of a.. The typing judg\u00adment . | . . e : . means that expression \ne has type . under type environment . and implicit environment .. The auxiliary resolu\u00adtion judgment \n. .r \u00df expresses that type \u00df is resolvable with respect to .. Here, . is the conventional type environment \nthat captures type variables; . is the implicit environment, de.ned as a stack of contexts. Figure 1 \nalso presents lookup in the implicit environment(... .)and in contexts(\u00df\u00af.. .). We will not discuss the \n.rst four rules ((TyInt), (TyVar), (TyAbs)and(TyApp)) because they are entirely standard.For now we also \nignore the gray-shaded conditions in the other rules; they are explained in Section 3.3. Rule(TyRule)checks \na rule abstraction(|e : ..\u00df . . |) by checking whether the rule sbody e actually has the type . under \nthe assumed implicit type context \u00df\u00af. Rule(TyInst)instantiates a rule type s type variables ..with the \ngiven types .. , and rule(TyRApp) instantiates the type context \u00df\u00afwith expressions of the required rule \ntypes e : \u00df. Finally,rule(TyQuery)delegates queries directly to the resolution rule(TyRes). Resolution \nPrinciple The underlying principle of resolution in a. originates from resolution in logic. Following \nthe Curry-Howard correspondence, we assign to each type a corresponding logical interpretation with the \n(\u00b7) function: De.nition 3.1 (Logical Interpretation).  Int= Int = (.1 = .2)= .1 .2 . (..\u00df . . )= ... \n\u00df. . .*.\u00af Here, typevariables . mapto propositionalvariables . and the primitive type Int maps to the \npropositional constant Int . Unlike 3In Prolog these are not separated either.  Type Environments . \n::= \u00b7| .; x : . Implicit Environments . ::= \u00b7| .; \u00af\u00df . | . . e : . (TyInt) . | . . n : Int (x : .) = \n. (TyVar) . | . . x : . .; x : .1 | . . e : .2 (TyAbs) . | . . ax : .1.e : .1 . .2 . | . . e1 : .2 . \n.1 . | . . e2 : .2 (TyApp) . | . . e1 e2 : .1 \u00df = ....\u00df\u00af. . unambiguous(\u00df) (TyRule) . | .; \u00af\u00df . e : . \n... ftv(., .) = \u00d8 . | . . (|e : \u00df|): \u00df . | . . e : ..\u00df . . (TyInst) . | . . e[..]:[......](\u00af\u00df . .) . \n| . . e :\u00af\u00df . . (TyRApp) . | . . ei : \u00dfi (.ei : \u00dfi = e : \u00df) . | . . (e with e : \u00df): . (TyQuery) . .r \n\u00df unambiguous(\u00df) . | . .?\u00df : \u00df . .r \u00df .... = \u00af\u00df ' . . (TyRes) . .r \u00dfi (.\u00dfi = \u00af\u00df ' - \u00af\u00df) . .r ....\u00af\u00df . \n. \u00df\u00af... = \u00df no overlap(\u00af\u00df, .) (.; \u00af\u00df)... = \u00df \u00df\u00af... = . .... = \u00df (.; \u00af\u00df)... = \u00df . ' \u00df '' ' \u00df = \u00df\u00af\u00df = \n...\u00af. . .. = . \u00df\u00af... = .\u00af. . \u00df ' Figure 1. Type System Curry-Howard, we do not map function types to \nlogical implica\u00adtions; we deliberately restrict our implicational reasoning to rule types. So, instead \nwe also map the function arrow to an uninter\u00adpreted higher-order predicate = . Finally, as already indicated, \nwe map rule types to logical implications. Resolution in a. then corresponds to checking entailment of \nthe logical interpretation.We postulate this property asa theorem that constrains the design of resolution. \nTheorem 3.1 (Resolution Speci.cation). If . .r \u00df, then . |= \u00df . Resolutionfor SimpleTypes The step from \nthe logical interpre\u00adtation to the(TyRes)rule in Figure1is non-trivial. So, let us .rst look at a simpler \nincarnation. What does resolution look like for simple types . like Int? \u00df ' ... . =\u00af. . (SimpleRes) \n. .r \u00dfi (.\u00dfi ~ \u00df\u00af' ) . .r . First,it looksupa matching ruletypeinthe implicitenvironmentby means of the \nlookup function ... . de.ned in Fig. 1. This partial function respects the nested scopes: it .rst looks \nin the topmost context of the implicit environment, and, only if it does not .nd a matching rule, doesit \ndescend.Within an environment context, the lookup function looks for a rule type whose right-hand side \n. ' can be instantiated to the queried . usingamatching uni.er .. This rule type is then returned in \ninstantiated form. The matchingexpresses that the looked-up rule producesavalue oftherequiredtype.Todoso,thelooked-uprulemay \nitselfrequire other implicit values. This requirement is captured in the context \u00df\u00af', which must be resolved \nrecursively. Hence, the resolution rule is itself a recursive rule. When the context \u00df\u00af' of the looked-up \nrule is empty, a base case of the recursion has been reached. Example Consider this query for a tuple \nof integers: Int; ...{.}. . \u00d7 . .r Int \u00d7 Int Lookup yields the second rule, which producesa tuple, instantiated \nto {Int}. Int \u00d7 Int with matching substitution . =[. .= Int]. In order to produce a tuple, the rule requires \na value of the compo\u00adnent type. Hence, resolution proceeds by recursively querying for Int. Now lookup \nyields the .rst rule, which produces an integer, with empty matching substitution and no further requirements. \nResolutionfor RuleTypes Sofar, so good. Apart from allowing any types, recursive querying for simple \ntypes is quite similar to recursive type class resolution, and a. carefully captures the expected behavior. \nHowever, what is distinctly novel in a., is that it also provides resolution of rule types, which requires \na markedly different treatment. ... . = \u00df\u00af. . (RuleRes) . .r ..\u00df . . Here we retrieve a whole rule from \nthe environment, including its context. Resolution again performs a lookup based on a matching right-hand \nside . ,but subsequently also matches the context with the one that is queried. No recursive resolution \ntakes place. Example Consider a variant of the above query: Int; ...{.}. . \u00d7 . .r {Int}. Int \u00d7 Int Again \nlookup yields the second rule, instantiated to {Int}. Int \u00d7 Int. The context {Int} of this rule matches \nthe context of the queried rule. Hence, the query is resolved without recursive resolution. Uni.ed Resolution \nThe feat that our actual resolution rule(TyRes) accomplishes is to unify these seemingly disparate forms \nof resolu\u00adtion into one single inference rule. Infact, both(SimpleRes)and (RuleRes)are special cases \nof(TyRes), which provides some ad\u00additional expressiveness in the form of partial resolution (explained \nbelow). The .rst hurdle for(TyRes)is that types. and rule types \u00df are different syntactic categories. \nJudging from its de.nition,(TyRes) only covers rule types. How do we get it to treat simple types then? \nJust promote the simple type . to its corresponding rule type ..{} . . and(TyRes)will do what we expect \nfor simple types, including recursive resolution. At the same time, it still matches proper rule types \nexactly, without recursion, when that is appropriate. Choosing the right treatment for the context is \nthe second hur\u00addle. This part is managed by recursively resolving \u00af- \u00df\u00af. In the \u00df ' ... . = \u00df \u00df\u00af... = \n\u00df \u00df '  case of promoted simple types, \u00df\u00afis empty, and the whole of \u00afis \u00df ' matches \u00df\u00af, no recursive \nresolution takes place.Again this perfectly corresponds to what we have set out above for proper rule \ntypes. However, there is a third case, where \u00df\u00af' - \u00df\u00afis a non-empty proper subset of \u00df\u00af'.Wecall this \nsituation, where part of the retrieved rule s context is recursively resolved and part is not, partial \nresolution. Example Here is another query variant: recursively solved; which is exactly what we want. \nIn the case \u00af Bool; ...{Bool,.}. . \u00d7 . .r {Int}. Int \u00d7 Int The .rst lookup yields the second rule, instantiated \nto {Bool, Int}. Int \u00d7 Int, which almost matches the queried rule type. Only Bool in the context is unwelcome, \nso it is eliminated through a recur\u00adsive resolution step.Fortunately, the .rst rulein the environmentis \navailable for that.  3.3 AdditionalType System Conditions The gray-shaded conditions in the type system \nare to check lookup errors(no overlap)and ambiguous instantiations(unambiguous). Avoiding Lookup Errors \nTo prevent lookupfailures, we have to check for two situations: Alookup has no matching rule in the \nenvironment.  Alookup has multiple matching rules which have different rule typesbut can yieldvaluesof \nthe same type(overlapping rules).  The former condition is directly captured in the de.nition of lookup \namong a set of rule types. The latter condition is captured in the no overlap property, which is de.ned \nas: def no overlap({\u00df1,...,\u00dfn},. )= .i,j. \u00dfi = ...i.\u00df\u00afi . .i ...i..i.i = . . \u00dfj = ...j .\u00df\u00afj . .j ...j \n..j .j = . =. i = j Avoiding Ambiguous Instantiations Weavoid ambiguous instan\u00adtiations in the same way \nas Haskell does: all quanti.ed type vari\u00adables(..)ina rule type(..\u00df . .)must occur in . .We use the unambiguous \nconditionto checkin(TyRule)and(TyQuery): unambiguous(....\u00df\u00af. .)= ... ftv(. ) ..\u00dfi ~ \u00af \u00df.unambiguous(\u00dfi). \nIf there is a quanti.ed type variable not in type . , the type may yield ambiguous instantiations (e.g. \n...{.}. Int). 4. Type-DirectedTranslation to SystemF In this section we de.ne the dynamic semantics of \na. in terms of System F s dynamic semantics, by means of a type directed trans\u00adlation. This translation \nturns implicit contexts into explicit parame\u00adters and statically resolves all queries, much likeWadler \nand Blott s dictionary passing translation for type classes [42]. The advantage of this approach is that \nwe simultaneously provide a meaning to well-typed a. programs and an effective implementation that re\u00adsolves \nall queries statically. 4.1 Type-DirectedTranslation Figure2presents the translation rules that convert \na. expressions into onesofSystemFextendedwiththeintegerandunittypes.This .gure essentiallyextends Figure1with \nthe necessary information for the translation,but for readability we have omitted the earlier gray-shaded \nconditions. The syntaxof SystemFis as follows: Types T ::= . | T . T |...T | Int | () Expressions E ::= \nx | a(x : T ).E | EE | ...E | ET | n | () Type Environments . ::= \u00b7| .; x : . Translation Environments \n. ::= \u00b7| .; \u00df : x . | . . e : . . E (TrInt) . | . . n : Int . n (x : .) = . (TrVar) . | . . x : . . \nx .; x : .1 | . . e : .2 . E (TrAbs) . | . . ax : .1.e : .1 . .2 . ax : |.1|.E . | . . e1 : .2 . .1 \n. E1 (TrApp) . | . . e2 : .2 . E2 . | . . e1 e2 : .1 . E1 E2 (TrQuery) . .r \u00df . E . | . .?\u00df : \u00df . E \u00df \n= ....\u00af\u00df . . .. . ftv(., .) = \u00d8 (TrRule) . | .; \u00df : x . e : . . E \u00afx fresh . | . . (|e : \u00df|) : \u00df . ....a(.x \n: |.\u00df|).E (TrInst) . | . . e : ....\u00af\u00df . . . E . | . . e[..] : [......](\u00af\u00df . .) . E |..| . | . . e : \u00af\u00df \n. . . E (TrRApp) . | . . ei : \u00dfi . Ei (.ei : \u00dfi = e : \u00df) . | . . (e with e : \u00df): . . E E. . .r \u00df . E \n.(.)= \u00df\u00af' . . : Ex\u00affresh { . .r \u00dfi . Ei ,\u00dfi .= \u00df\u00af \u00df ' (TrRes) .\u00dfi = \u00af: Ei = xi ,\u00dfi = \u00df\u00af . .r ..\u00df . . \n. ..x : |\u00df.|).(E E.) ..\u00af..a(.\u00df : x... = \u00df : E .... = \u00df : E (.; \u00df : x)... = \u00df : E \u00df : x... = . .... = \n\u00df (.; \u00df : x)... = \u00df . ' \u00df '' (\u00df : x) = \u00df : x\u00df = ...\u00af. . ' . ' .. = .. =[... ..] \u00df : x... = \u00df : E \u00df : \nx... = .\u00af\u00df ' . . : x |..| |.||Int| |.1 . .2| |....{\u00df1, \u00b7 \u00b7 \u00b7 , \u00dfn} . .||.| |.| = = = = = = . Int |.1| \n. |.2| ....|\u00df1| . \u00b7 \u00b7 \u00b7 . |\u00dfn| . |.|{(x : |.|) | (x : .) = .} {(x : |\u00df|) | (\u00df : x) = .} Figure 2. Type-directedTranslation \nto SystemF  The main translation judgment is . | . . e : . . E, which states that the translation of \na. expression e with type . is SystemF expression E, with respect to type environment . and translation \nenvironment .. The translation environment . relates each rule type in the earlier implicit environment \nto a System F variable x;this variable serves as value-level explicit evidence for the implicit rule. \nLookup in the translation environment is de.ned similarly to lookup in the type environment, except that \nthe lookup now returns a pair of a rule type and an evidence variable. Figure2also de.nes the type translation \nfunction |\u00b7| from a. types . to SystemFtypesT.In orderto obtaina unique translation oftypes,we assumethatthetypesinacontextarelexicographically \nordered. Variables, lambda abstractions and applications are translated straightforwardly. Queries are \ntranslatedby rule(TrQuery)using the auxiliary resolution judgment .r,de.nedbyrule(TrRes).Note that rule(TrRes) \nperforms the same process that rule(TyRes) performs in the type system except that it additionally collects \nevidence variables. Rule(TrRule)translates rule abstractions to explicit type and value abstractionsinSystemF,andrule(TrInst)translates \ninstan\u00adtiation to type application. Finally, rule(TrRApp)translates rule applicationto applicationin \nSystemF. Example We have that: \u00b7 | \u00b7 . (|(?., ?.) : ...{.} . . \u00d7 .|) . ...a(x : .).(x, x) and also: \n(Int : x1), (...{.}. . \u00d7 . : x2) .r Int \u00d7 Int . x2 Int x1 Forbrevity,Figure2omitsthecasewherethe contextofaruletype \nis empty.To properly handle empty contexts, the translationof rule type should include |{} . . | = () \n=|. | and the translation rules(TrRule),(TrRApp)and(TrRes)should be extended in the obvious way. Theorem \n4.1 (Type-preserving translation). Let e bea a. expres\u00adsion, . be a type and E bea SystemFexpression.If \n\u00b7|\u00b7. e : . . E, then \u00b7. E : |.|. Proof. (Sketch) We .rst prove4 the more general lemma if . |. . e : \n. . E, then |.|, |.|. E : |. | by induction on the derivation of translation. Then, the theorem trivially \nfollows.  4.2 Dynamic Semantics Finally,we de.ne the dynamic semantics of a. as the composition of the \ntype-directed translation and System F s dynamic semantics. Following Siek s notation [35], this dynamic \nsemantics is: eval(e)= V where \u00b7|\u00b7. e : . . E and E =. V with =. the re.exive, transitive closure of \nSystem F s standard single-step call-by-value reduction relation. Now we can state the conventional type \nsafety theorem for a.: Theorem 4.2 (Type Safety). If \u00b7|\u00b7. e : ., then eval(e)= V for some SystemFvalue \nV . The proof follows trivially from Theorem 4.1. 4in the technical report interface Eq . = {eq : . . \n. . Bool } let (.): ... {Eq .}. . . . . Bool = eq ? in let eqInt1 : Eq Int = Eq {eq = primEqInt } in \nlet eqInt2 : Eq Int = Eq {eq = axy.isEven x \u00d8 isEven y } in let eqBool : Eq Bool = Eq {eq = primEqBool \n} in let eqPair : .. .. {Eq ., Eq . }. Eq (., .)= Eq {eq = axy.fst x . fst y \u00d8 snd x . snd y } in let \np1 :(Int, Bool) = (4, True) in let p2 :(Int, Bool) = (8, True) in implicit {eqInt1 , eqBool, eqPair } \nin (p1 . p2, implicit {eqInt2 } in p1 . p2) Figure 3. Encoding the EqualityType Class Interface Declarations \ninterface I .. = u : T Types T ::= . TypeVariables | Int IntegerType | I T.InterfaceType | T . T Function \n. ::= ... . . T RuleType Expressions E ::= n Integer Literal | x LambdaVariable | ax.E Abstraction | \nE1 E2 Application | u LetVariable | let u :. = E1 in E2 Let | implicit u in E2 Implicit Scoping | ? Implicit \nLookup | Iu = E Interface Implementation Figure 4. Syntax of Source Language 5. Source Languages and \nImplicit Instantiation Languages like Haskell and Scala provide a lot more programmer convenience than \na. (which is a low level core language) because of higher-level GP constructs, interfaces and implicit \ninstantiation. This section illustrateshowtobuilda simple source languageon top of a. to add theexpected \nconvenience.We should note that unlikeHaskell this language supports local and nested scoping, and unlike \nboth Haskell and Scala it supports higher-order rules. We present the type-directed translation from \nthe source to a.. 5.1 Type-directedTranslation toa. The full syntax of the source language is presented \nin Figure 4. Its use is illustrated in the program of Figure 3, which comprises an encoding of Haskell \ns equality type class Eq. The example shows that the source language features a simple type of interface \nI T.(basically records), which are used to encode simple forms of type classes. Note that we followHaskell \nsconventions for records: .eld names u are unique and they are modeled as regular functions taking a \nrecord as the .rst argument. So a .eld u with type T in an interface declaration I .. actually has type \n.\u00af. = T . ..{} . I.There are also other conventional programming constructs (such as let expressions, \nlambdas and primitive types). Unlike the core language, we strongly differentiate between simple types \nT and type schemes . in order tofacilitate type in\u00adference. Moreover, as the source language provides \nimplicit rather than explicit type instantiation, the order of type variables in a  Type Environments \nG ::= \u00b7| G, u : . | G, x : T G . E : T . e (TyIntL) G . n : Int . n G(x)= T (TyVar) G . x : T . x G, \nx : T1 . E . e (TyAbs) G . ax.E : T1 . T2 . ax : .T1..e G . E1 : T1 . T2 . e1 (TyApp) G . E2 : T1 . e2 \nG . E1 E2 : T2 . e1 e2 ' G(u)= ... . . T ' . =[. .. T ] T = .T (TyLVar) qi = (?...i.): ...i. (..i = .) \nG . u : T . u[.T..] with q . = .... . T1 G . E1 : T1 . e1 (TyLet) G, u : . . E2 : T2 . e2 G . let u : \n. = E1 in E2 : T2 . (au : ....e2)(|e1 : ...|) G . E : T . e G(ui)= .i qi = ui : ..i. (.ui = u) (TyImp) \nG . implicit u in E : T . (|e : ... . .T .|) with q (TyIVar) G .?: T . ?({} . .T .) with {} { G(ui)= \n.\u00af. . Ti ..{} . I.(TyRec) .i : G . Ei : .Ti . e. =[.... T.] G . Iu = E : I T.. Iu = e .Int. = Int .T1 \n. T2. = .T1. . .T2. .I T.. = I .T.. ..... . T . = ......... . .T . Figure 5. Type-directed Encoding of \nSource Language ina. quanti.erisnolongerrelevant.Hence,theyare representedbyaset (..\u00af).We also distinguish \nsimply typedvariables x from let-bound variables u with polymorphic type .. Figure5presents the type-directed \ntranslation G . E : T . e of source language expressions E of type T to core expressions e, with respect \nto type environment G. The type environment collects both simply and polymorphic variable typings. The \nconnection between source types T and . on the one hand and core types . and \u00df on the other hand is captured \nin the auxiliary function .\u00b7.. Note that this function imposesa canonical ordering ..on the set of quanti.ervariables \n.\u00af(based on their precedence in the left-to-right pre.x traversal of the quanti.ed type term).For the \ntranslation of records, we assume that a. is extended likewise with records. let and let-bound variables \nThe rule(TyLet)in Figure5shows the type-directed translation for let expressions. This translation binds \nthe variable u using a regular lambda abstraction in an ex\u00adpression e2, which is the result of the translation \nof the body of the let construct(E2). Then it applies that abstraction to a rule whose rule type is just \nthe corresponding (translated) type of the de.nition (.1), and whose body is the translation of the expression \nE1. The source language provides convenience to the user by infer\u00adring type arguments and implicit values \nautomatically. This infer\u00adence happens in rule(TyLVar), i.e., the use of let-boundvariables. That rule \nrecovers the type scheme of variable u from the environ\u00adment G.Thenit instantiatesthetype schemeand .resthenecessary \nqueries to resolve the context. Queries The source language also includesa query operator(?). Unlike \na. this query operator does not explicitly state the type; that informationis provided implicitly through \ntype inference.For example, instead of using p1 . p2 in Figure 5, we could have directly used the .eld \neq as follows: eq ? p1 p2 Whenusedinthisway,the query actslikeaCoq placeholder( ), which similarly instructs \nCoq to automatically infer a value. The translation of source language queries, given by the rule (TyIVar),isfairly \nstraightforward.To simplify type-inference, the query is limited to types, and does not support partial \nresolution. In the translated code the query is combined with a rule instantiation and application in \norder to eliminate the empty rule set. Implicit scoping The implicit construct is the core scoping construct \nof the source language. It is .rst used in our example to make eqInt1 , eqBool and eqPair available for \nresolution at the expression (p1 . p2, implicit {eqInt2 } in p1 . p2) Within this expression there is \na second occurrenceof implicit, which introduces an overlapping rule(eqInt2 )that takes priority over \neqInt1 for the subexpression p1 . p2. The translation rule(TyImp)ofimplicit into a. alsoexploits type-information \nto avoid redundant type annotations. It is not necessary to annotate the let-boundvariables usedinthe \nrule set u since that information is recovered from the environment G. Higher-order rules and implicit \ninstantiationfor any type The followingexample illustrates higher-order rules and implicit instan\u00adtiation \nworking for anytype in the source language. let show : ... {. = String }. . = String =? in let showInt \n: Int = String = ... in let comma : ... {. = String }.[.] = String = ... in let space : ... {. = String \n}.[.] = String = ... in let o : {Int = String, {Int = String }.[Int ] = String } . String = show [1, \n2, 3] in implicit showInt in (implicit comma in o, implicit space in o) For brevity, we have omitted \nthe implementations of showInt, comma and space; but showInt renders an Int as a String in the conventional \nway, while comma and space provide two ways for rendering lists. Evaluation of the expression yields \n(\"1,2,3\", \"1 23\"). Thanks to the implicit rule parameters, the contexts of the two calls to o control \nhow the lists are rendered. This example differs from that in Figure 3 in that instead of using a nominal \ninterface type like Eq, it uses standard functions to model a simple concept for pretty printing values. \nThe use of functions as implicit values is similar to structural matching of concepts, since only the \ntype of the function matters for resolution.  5.2 Extensions Thegoalof ourworkisto presentaminimaland \ngeneral framework for implicits. As such we have avoided making assumptions about extensionsthatwouldbe \nuseful for some languages,but not others.  Inthis sectionwe brie.y discuss someextensionsthatwouldbe \nuseful in the context of particular languages and the implications that they would have in our framework. \nFull-blown Concepts The most noticeable feature that was not discussed is a full-blown notion of concepts. \nOne reason not to commit to a particular notion of concepts is that there is no general agreement on \nwhat the right notion of concepts is. For example, following Haskell type classes, the C++0x concept \nproposal [11] is based on a nominal approach with explicit concept re.nement, while Stroustrupfavorsa \nstructural approach with implicit concept re.nement becausethatwouldbe morefamiliartoC++ program\u00admers \n[38]. Moreover, various other proposals for GP mechanisms have their own notion of interface: Scala uses \nstandard OO hierar\u00adchies; Dreyer et al. use ML-modules [8]; and in dependently typed systems (dependent) \nrecord types are used [37, 5]. An advantage of a. is that no particular notion of interface is imposed \non source language designers. Instead, language design\u00aders are free to use the one theyprefer. In our \nsource language, for simplicity, we opted to add a very simple (and limited) type of in\u00adterface. But \nexisting language designs [29, 8, 37, 5] offer evidence that more sophisticated types of interfaces, \nincluding some form of re.nementor associated types, canbebuiltontopof a.. Type ConstructorPolymorphism \nand Higher-order Rules Type constructor polymorphismis an advanced,but highlypowerfulGP feature available \nin Haskell and Scala, among others. It allows abstracting container types like List and Tree with a type \nvariable f ;and applying the abstracted container type to different element types, e.g., f Int and f \nBool. This type constructor polymorhism leads to a need for higher\u00adorder rules: rules for containers \nof elements that depend on rules for the elements. The instance for showing values of type Perfect f \n. in Section 1, is a typical example of this need. Extending a. with type constructor polymorphism is \nnot hard. Basically,weneedtoaddakind systemandmovefromaSystem F likelanguagetoa System F. like language. \nSubtyping Languages like Scala or C++ have subtyping. Subtyp\u00ading would require signi.cant adaptations \nto a.. Essentially, in\u00adsteadoftargetting SystemF,wewouldhavetotargetaversionof SystemFwith subtyping.In \naddition,the notionof matchinginthe lookup function ... . would have to be adjusted, as well as the no \noverlap condition. While subtyping is a useful feature, some language designs do not support it because \nit makes the system more complex and interferes with type-inference. Type-inference Languages without \nsubtyping (like Haskell or ML) make it easier to support better type-inference. Since we do not use subtyping, \nit is possible to improve support for type\u00adinference in our source language. In particular,we currently \nrequire a type annotation for let expressions,but it should be possible to make that annotation optional,bybuilding \nonexistingwork for the GHC Haskell compiler [33, 41]. 6. RelatedWork Throughout the paper we have already \ndiscussed a lot of related work. In what follows, we offer a more detailed technical compar\u00adison of a. \nversus System F G and Scala implicits, which are the closest to our work. Then we discuss the relation \nwith other work in the literature. System F G Generally speaking our calculus is more primitive and general \nthan System F G. In contrast to a., System F G has both a notion of concepts and implicit instantiation \nof concepts5. 5Note that instantiation of type variables is still explicit. This has the advantage that \nlanguage designers can just reuse that infrastructure, instead of having to implement it. The language \nG [36] is based on System F G and it makes good use of these built-in mechanisms. However, System F G \nalso imposes impor\u00adtant design choices. Firstly it forces the language designer to use the notionof concepts \nthatisbuilt-into System F G. In contrast a. offers a freedom of choice (see also the discussion in Section \n5.2). Secondly,.xing implicit instantiation in the core prevents useful al-ternatives.Forexample, Scalaandseveral \nother systemsdoprovide implicit instantiationbydefault,butalsooffertheoptionofexplicit instantiation, \nwhich is useful to resolve ambiguities [29, 18, 6, 8]. This cannot be modeled on top of System F G, because \nexplicit instantiation is not available. In contrast, by taking explicit instan\u00adtiation (rule application) \nas a core feature, a. can serve as a target for languages that offer both styles of instantiation. There \nare also important differences in terms of scoping and resolution of rules. System F G only formalizes \na very simple type of resolution, which does not support recursive resolution. Furthermore, scoping is \nless .ne-grained than in a..Forexample, System F G requiresabuilt-in construct for model expressions, \nbut ina. implicit (which plays a similar role) is just syntactic sugar on top of more primitive constructs. \nScala Implicits Scala implicits are integrated in a full-blown lan\u00adguage,but they have only been informally \ndescribed in the liter\u00adature [29, 27]. Our calculus aims at providing a formal model of implicits,but \nthere are some noteworthydifferences between a. and Scala implicits. In contrast to a., Scala has subtyping. \nAs dis\u00adcussed in Section 5.2 subtyping would require some adaptations to our calculus. In Scala, nested \nscoping can only happen through sub\u00adclassing and the rules for resolution in the presence of overlapping \ninstances are quite ad-hoc. Furthermore, Scala has no (.rst-class) rule abstractions. Rather, implicit \narguments can only be used in de.nitions. In contrast a. providesamore general and disciplined account \nof scoping for rules. Type Classes Obviously, the original work on type classes [42] and the framework \nof quali.ed types [15] around it has greatly in.uenced ourownwork, as well as thatof SystemFG and Scala. \nThere is a lot of work on Haskell type classes in the literature. Notably, there have been some proposals \nfor addressing the limita\u00adtions that arise from global scoping [18, 6]. However in those de\u00adsigns, type \nclasses are still second-class and resolution only works for type classes. The GHC Haskell compiler supports \noverlapping instances [17], that live in the same global scope. This allows some relief for the lackof \nlocal scoping.A lotof recentwork on type classes is focused on increasingly more powerful type class \nin\u00adterfaces. Functional dependencies [16], associated types [4,3] and type families [32] are all examples \nof this trend. This line of work is orthogonal to our work. Other Languages and Systems Modular type \nclasses [8] are a language design that uses ML-modules to model type classes. The main novelty of this \ndesign is that, in addition to explicit instantia\u00adtion of modules, implicit instantiation is also supported. \nIn contrast to a., implicit instantiation is limited to modules and, although local scoping is allowed, \nit cannot be nested. Instance arguments [5]areanAgdaextensionthatis closely re\u00adlated to implicits. However, \nunlike most GP mechanisms, implicit rules are not declared explicitly. Furthermore resolution is limited \nin its expressive power, to avoid introducing a different computa\u00adtional model in Agda. This design differs \nsigni.cantly from a., where resolution is very expressive and the scoping mechanisms allow explicit rule \ndeclarations. Implicit parameters [22] are a Haskell extension that allows named arguments to be passed \nimplicitly. Implicit parameters are resolvedby name, notby type and thereis no recursive resolution. \n GP and Logic Programming The connection between Haskell type classes and Prolog is folklore. Neubauer \net. al. [25] also explore the connection with Functional Logic Programming and consider different evaluation \nstrategies to deal with overlapping rules.With Constraint Handling Rules,Stuckeyand Sulzmann [39] use \nConstraint Logic Programming to implement type classes. 7. Conclusion Our main contribution is the development \nof the implicit calculus a.. This calculus isolates and formalizes thekey ideas of Scala implicits and \nprovidesasimple model for language designers inter\u00adested in developing similar mechanisms for their own \nlanguages. In addition, a. supports higher-order rules and partial resolution, which add considerable \nexpressiveness to the calculus. Implicits provide an interesting alternative to conventional GP mechanisms \nliketype classes or concepts.Bydecoupling resolution froma particulartypeof interfaces, implicitsmake \nresolution more powerful and general. Furthermore, this decoupling has other ben\u00ade.ts too.Forexample,by \nmodeling concept interfaces as conven\u00adtional types, those interfaces can be abstracted as anyother types, \navoiding the issue of second class interfaces that arise with type classes or concepts. Ultimately, all \nthe expressiveness offered by a. offers a wide\u00adrange of possibilities for new generic programming applications. \nAcknowledgements We are grateful to Ben Delaware, Derek Dreyer, Jeremy Gibbons, Scott Kilpatrick, PhilWadler, \nBeta Zil\u00adiani, the members of ROPAS and the anonymous reviewers for their comments and suggestions. Thisworkwas \npartially supported by Korea Ministry of Education, Science and Technology/Korea Science and Enginering \nFoundation s ERC grant R11-2008-007\u00ad01002-0, Brain Korea 21, Mid-career Research Program 2010\u00ad0022061, \nand by Singapore Ministry of Education research grant MOE2010-T2-2-073. References [1] The Boost C++ \nlibraries. http://www.boost.org/, 2010. [2] C. Camar ao and L. Figueiredo. Type inference for overloading \nwithout restrictions, declarations or annotations. In FLOPS, 1999. [3] M. Chakravarty, G.Keller, and \nS. L. Peyton Jones. Associated type synonyms. In ICFP, 2005. [4] M. Chakravarty, G. Keller, S. L. Peyton \nJones, and S. Marlow. Associated types with class. In POPL, 2005. [5] D. Devriese and F. Piessens. On \nthe bright side of type classes: Instance arguments in agda. In ICFP, 2011. [6] A. Dijkstra and S. D. \nSwierstra. Making implicit parameters explicit. Technical report, Utrecht University, 2005. [7] G. Dos \nReis and B. Stroustrup. Specifying C++ concepts. In POPL 06, pages 295 308, 2006. [8] D. Dreyer, R. Harper, \nM. Chakravarty, and G.Keller. Modular type classes. In POPL, 2007. [9]R.Garcia,J.Jarvi,A. Lumsdaine,JeremySiek,andJ.Willcock. \nA comparative study of language support for generic programming. In OOPSLA, 2003. [10]J. Gibbons.Patternsin \ndatatype-generic programming.In The Fun of Programming, Cornerstones in Computing.Palgrave, 2003. [11] \nD. Gregor, J. J\u00a8arvi, J. G. Siek, B. Stroustrup, G. Dos Reis, and A. Lumsdaine. Concepts: linguistic \nsupport for generic programming in c++. In OOPSLA, 2006. [12] R.Hinze and S. L. Peyton Jones. Derivable \ntype classes. Electronic Notes in Theoretical Computer Science, 41(1):5 35, 2001. [13] J. Hughes. Restricted \ndata types in Haskell. In Haskell, 1999. [14] P. Jansson and J. Jeuring. Polytypic programming. In AFP. \nSpringer-Verlag, 1996. [15] M.P. Jones. Simplifying and improving quali.ed types. In FPCA, 1995. [16] \nM.P. Jones. Type classes with functional dependencies. In ESOP, 2000. [17]S.L.PeytonJones,M.P.Jones,andE.Meijer.Type \nclasses:exploring the design space. In HaskellWorkshop, 1997. [18] W. Kahl and J. Scheffczyk. Named instances \nfor Haskell type classes. In HaskellWorkshop, 2001. [19] R. Kowalski. Predicate logic as a programming \nlanguage. In Proceedings of IFIP Congress, 1974. [20] R.Kowalski, Donald, andKuehner. Linear resolution \nwith selection function. Arti.cial Intelligence, 2, 1971. [21] R.L\u00a8ammel andS.L.Peyton Jones. Scrap your \nboilerplate with class: extensible generic functions. In ICFP, 2005. [22] J. Lewis, J. Launchbury, E. \nMeijer, and M. Shields. Implicit parameters: dynamic scoping with static types. In POPL, 2000. [23] D. \nMusser and A. Stepanov. Generic programming. In Symbolic and algebraic computation: ISSAC88, pages 13 \n25. Springer, 1988. [24] D. R. Musser and A. Saini. The STLTutorial and Reference Guide: C++ Programming \nwith the StandardTemplate Library. Addison WesleyLongman Publishing Co., Inc., 1995. [25] M. Neubauer, \nP. Thiemann, M. Gasbichler, and M. Sperber. Functional logic overloading. In POPL, 2002. [26] M. Odersky. \nPoor man s type classes. http://lamp.epfl.ch/ ~odersky/talks/wg2.8-boston06.pdf, July 2006. [27] M. Odersky. \nThe Scala language speci.cation, version 2.8, 2010. [28] B. C. d. S. Oliveira and J. Gibbons. Scala for \ngeneric programmers. Journal of Functional Programming, 20, 2010. [29] B. C. d. S. Oliveira, A. Moors, \nand M. Odersky. Type classes as objects and implicits. In OOPSLA, 2010. [30] B. C. d. S. Oliveira, T. \nSchrijvers, W. Choi, W. Lee, and K. Yi. Extended report: The implicit calculus. http://arxiv.org/abs/ \n1203.4499, 2012. [31] A. Rodriguez, J. Jeuring,P. Jansson, A. Gerdes, O. Kiselyov, and B. C. d. S. Oliveira. \nComparing libraries for generic programming in haskell. In Haskell, 2008. [32] T. Schrijvers, S. L. Peyton \nJones, M. Chakravarty, and M. Sulzmann. Type checking with open type functions. InICFP, 2008. [33] T. \nSchrijvers, S. L. Peyton Jones, M. Sulzmann, and D. Vytiniotis. Complete and decidable type inference \nfor GADTs. In ICFP, 2009. [34] J. Siek. The C++0x Concepts Effort. http://ecee.colorado. edu/~siek/concepts_effort.pdf, \n2011. [35] J. G. Siek and A. Lumsdaine. Essential language support for generic programming. In PLDI, \n2005. [36] J. G. Siek and A. Lumsdaine. Alanguage for generic programming in the large. Science of Computer \nProgramming, 76(5), 2011. [37] M. Sozeau and N. Oury. First-class type classes. In TPHOLs, 2008. [38] \nB. Stroustrup. Simplifying the use of concepts. Technical report, Technical Report N2906, ISO/IEC JTC1SC22 \nWG21, 2009. [39] P. J. Stuckeyand M. Sulzmann. Atheory of overloading. In ICFP, 2002. [40]V.Trifonov. \nSimulating quanti.ed class constraints.In Haskell,2003. [41] D. Vytiniotis, S. L. Peyton Jones,T. Schrijvers, \nand M. Sulzmann. OUTSIDEIN(x): Modular type inference with local assumptions. Journal of Functional Programming, \n21(4 5):333 412, 2011. [42]P.L.WadlerandS. Blott.Howtomake ad-hoc polymorphismlessad hoc. In POPL, 1989. \n   \n\t\t\t", "proc_id": "2254064", "abstract": "<p><i>Generic programming</i> (GP) is an increasingly important trend in programming languages. Well-known GP mechanisms, such as type classes and the C++0x concepts proposal, usually combine two features: 1) a special type of interfaces; and 2) <i>implicit instantiation</i> of implementations of those interfaces.</p> <p>Scala <i>implicits</i> are a GP language mechanism, inspired by type classes, that break with the tradition of coupling implicit instantiation with a special type of interface. Instead, implicits provide only implicit instantiation, which is generalized to work for <i>any types</i>. This turns out to be quite powerful and useful to address many limitations that show up in other GP mechanisms.</p> <p>This paper synthesizes the key ideas of implicits formally in a minimal and general core calculus called the implicit calculus (&#955;&#8658;), and it shows how to build source languages supporting implicit instantiation on top of it. A novelty of the calculus is its support for <i>partial resolution</i> and <i>higher-order rules</i> (a feature that has been proposed before, but was never formalized or implemented). Ultimately, the implicit calculus provides a formal model of implicits, which can be used by language designers to study and inform implementations of similar mechanisms in their own languages.</p>", "authors": [{"name": "Bruno C.d.S. Oliveira", "author_profile_id": "81310493622", "affiliation": "Seoul National University, Seoul, South Korea", "person_id": "P3471139", "email_address": "bruno@ropas.snu.ac.kr", "orcid_id": ""}, {"name": "Tom Schrijvers", "author_profile_id": "81100049265", "affiliation": "Universiteit Gent, Gent, Belgium", "person_id": "P3471140", "email_address": "tom.schrijvers@ugent.be", "orcid_id": ""}, {"name": "Wontae Choi", "author_profile_id": "81443595067", "affiliation": "Seoul National University, Seoul, South Korea", "person_id": "P3471141", "email_address": "wtchoi@ropas.snu.ac.kr", "orcid_id": ""}, {"name": "Wonchan Lee", "author_profile_id": "81486643380", "affiliation": "Seoul National University, Seoul, South Korea", "person_id": "P3471142", "email_address": "wclee@ropas.snu.ac.kr", "orcid_id": ""}, {"name": "Kwangkeun Yi", "author_profile_id": "81493644271", "affiliation": "Seoul National University, Seoul, South Korea", "person_id": "P3471143", "email_address": "kwang@ropas.snu.ac.kr", "orcid_id": ""}], "doi_number": "10.1145/2254064.2254070", "year": "2012", "article_id": "2254070", "conference": "PLDI", "title": "The implicit calculus: a new foundation for generic programming", "url": "http://dl.acm.org/citation.cfm?id=2254070"}