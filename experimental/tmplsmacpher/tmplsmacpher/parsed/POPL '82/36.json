{"article_publication_date": "01-25-1982", "fulltext": "\n On the Expressive Power of Query Languages for Relational Databases Eric C. Cooper Computer Science \nDivision -EECS University of California Berkeley, CA 94720 ABSTRACT The query languages used in relational \ndatabase systems are a special class of programming languages. The majority, based on first-order logic, \nlend themselves to analysis using formal methods. Fhst, we provide a definition of relational query languages \nand their expressive power. We prove some general results and show that only a proper subset of first-order \nlogic formulas may be used as a practical query language. We characterize this subset in both semantic \nand syntactic terms. We then analyze the expressive power of several real query languages, including \nlanguages based on the relational calculus, languages with set operators and aggregate functions, and \nprocedural query languages. Since the partial ordering is more expressive than determines a lattice among \nrelational query languages, the results of the paper may be viewed as determining some of the structure \nof this lattice. We conclude with some applications of the results to the optimiza\u00adtion problem for query \nprocessing. 1. Introduction There have been several studies of the expressive power of relational query \nlanguages. Codd [C21 proved the equivalence of relational algebra and relational calculus, and suggested \nthat languages with thk degree of expressive power be termed complete. Aho and Unman [AU] showed the \nexistence of a computable query (the transitive closure of a relation) which relational algebra is incapable \nof expressing, and proposed an extension of relational algebra with a least fixed point operator. Chandra \nand Horel [CHI redefined complete to mean capable of expressing all computable queries. They introduced \na complete query language QL, which is an extension of relational algebra with iterative and conditional \ncapabilities. In this paper, we introduce a formal method of comparing the expressive power of query \nlanguages. We define a partial ordering by expressive power that makes the set of query languages into \na lattice. The results cited above determine two points in this lattice: one point corresponds to languages \nequivalent to relational algebra, and the other corresponds to complete languages. The results of this \npaper establish additional lattice points corresponding to languages based on the relational calculus, \nlanguages with set operators and aggregate functions, and pro\u00ad cedural query languages. Permission to \ncopy without fee all or part of this material is granted provided that the copies are not made or distributed \nfor direct commercial advantage, the ACM copyright notice and the title of the publication and its date \nappear, and notice is given that copying is by permission of the Association for Computing Machinery. \nTo copy otherwise, or to repubfish, requires a fee and/or specific permission. @ 1982 ACM 0-89791-065-6/82/001/0361 \n$00.75 2. Query languages and expressive power We adopt the formal definitions of relational database, \nquery, and query language essentially as stated in [Cl+]. Definition 2.1. (1) The universe is the set \nof natural numbers, denoted N. (2) A re/ation of rank m is a finite set R C Nm. (3) Let n = (n J,..., \nrr~). A database of type n is a set of relations (R1,...,Rk), such that for each i, R, is of rank n. \n (4) The set of all databases of type n will be denoted DB . (5) A query of type n is a partial function \nq such that for each DB ~ DB , q (DB) of finite rank.  (6) A query /anguage meaning function of type \nn. (7) A sublanguage of LOCLandpO=~~LO.  of type K such (L, p) We can now formalize the Definition \n2.2. (1) The expressive power of L is either undefined or else a finite relation n is a set L of expressions \nand a that for each c ~ L, 1A(e) is a query is a query language (Lo, ~ ~) with notion of expressive power. \nis the set w[L II= [w(e) I e~L]. (2) L, ise9uivalenc toL2(LI= L2)iffMIIJL J=P2[L 21. (3) L I is less \npowerjld thm L 2 (L, < L J ifl~ IL ,[L J CW2[L ~l. (4) L,< L2iffwJLJGwJL21.  The next result is simple \nbut useful. Theorem 2.3. Suppose L 1< L j. Then them exists a sublanguage LOCLzsuch that LO=L1. Proofi \nLet Lo= AC; WJLII. l 3. Complete languages The next definition is similar to one in [CH]. Dethrition \n3.1. Let (1,, ~) be a query language. Then L is: (1) bounded above iff for every e 6 L, p(e) is computable. \n (2) bounded below iff for every computable query q, there exists an expression e ~ L such that P(e) \n= q.  (3) complete iff it is bounded above and below. The following theorem follows immediately. Theorem \n3.2. If L 1 and L z are complete, then L,= L*. Since it is proved in [CH] that complete languages exist, \nlet Q denote such a query language. The next result is an immediate consequence of the definition. Theorem \n3.3. (1) L I is bounded above iff L1 < Q. ( 2) L z is bounded below iff Q < L*. The final result of this \nsection is analogous to the unsolvabil\u00adity of the halting problem. Theorem 3.4. If L > Q, then no algorithm \nexists which can decide for all expressions e EL whether or not the induced query w(e) is a total function. \n4. RC-based languages In thk section, we study general properties of query languages based on the relational \ncalculus of [Cl]. Definition 4.1. An RC-based language is a first-order language L whose predicate symbols \ninclude the relations R,,.,. ,Rk. In practice, L will also include other functions and predicates, such \nas arithmetic operations and comparisons, whose usual interpretation is clear. Therefore, a database \nDB determines a unique structure for L, which we also refer to as DB. Definition 4.2. Let @ be a wff \nof L with free variables xl,...,x~. For each database DB, define p (@J) to be the set {X,,...,Xm I O(XA...,XJ) \nDE) of elements of N m which satisfy @ in the structure DB. w(4) is thus a function q (DB) defined on \nDBn But q is not necessarily a query, because q (DB) may not be a finite relation for all databases DB. \nFor example, if @ is the wff x = x, then p(0) is the constant function q (DB) = N, and N is not a finite \nrelation. . One solution to this problem is to agree to call q (DB) undefined whenever it is not a finite \nrelation. Since a query need only be a partial function, any RC-based language L may be regarded as a \nquery language L*. Theorem 4.3. If L is an RC-based language which includes arith\u00admetic, then L \u00b7 > Q. \nProof A result due to Godel states that the first-order language of arithmetic is capable of representing \nall recursive functions, and hence by Church s thesis, all computable queries. 0 The previous theorem \nand Theorem 3.4 show that for an RC-based language to be used in a real database system, not all wffs \nof the first-order language may be allowed in the query language. We now define a class of formulas, \ncalled permissible wfls, whose induced queries may be evaluated in finite time. Because several later \ntheorems will make use of syntactic properties of these per\u00admissible wffs, the definition is rather detailed. \nDefinition 4.4. Let @ be a wff in prenex normal form, with matrix in disjunctive normal form VAI# ... \n!, (1) A direcccorrstrairrton x isaformula R(...,x),..), where R isa relation. (2) An indirect constraint \non x is a formula x = t, where t is a term and all variables occurring in tare directly constrained \n(see below). (3) A free or existentially quantified variable x is constrained iff in every dkjunct A+ \n,j in which x occurs, some I#J~ is a dkect or  indirect constraint on x, The total conslrairrr on x \nis the dis\u00ad junction of these constraints. (4) A u niversali y quantified variable x is constrained iff \nin some disjunct A@~ in which x occurs, every @ij in which x occurs J is the negation of a direct or \nindhect constraint on x. The toral constraint on x is the disjunction of these (positive) con\u00adstraints. \n(5) ~ is permissible iff every variable in @ is constrained (or else appears free in a set term--see \nDefinition 5.3). This definition gives a syntactic characterization of the seman\u00adtic notion of safe formtda \nin [U], since the truth or falsehood of a permissible wff @ may be determined from the truth values of \na finite number of instances of the matrix of @. More specifically, suppose @ is (Q MJ... (QmXJIJ(Xl,Xm,Xm+ \nl,m,xJ...,xJ Let Dj be the finite domain which satisfies the total constraint on xi. Then the truth of \n@ depends only onthe truth of $ in the finite universe Dlx . . xDn. Theorem 4.5. If @ is a permissible \nwff, then the query p(+) is a total function. Proof With the notation as above, we have (Xm+l,...,Xn \nI @(Xm+l,...,Xn)] GDm+lX . . . XDn, which is finite. 0 The following lemma will be useful later. Lemma \n4.6. Let (Vy ~)... (VyJ@ be a permissible wff. Then there exist permissible wffs @j and 1$2 in which \ny ~,... ,.Yk occur free, such that (Vyl)... (VjJk)~ is equivalent to +] ~ @z. Proof We prove the result \nonly when 1#1is quantifier-free; the gen\u00ad eral case follows easily by induction. Let P. be the conjunction \nof the total constraints in @ on the Yi, and define p inductively to be the conjunction of the total \ncon\u00ad straints in # on the variables which occur in Pn_l. Clearly there exists some n such that P._l is \nequivalent to Pn, Let @* be PO A.. . APfl_l, and let @z be @* A*. Then @~* @~ is equivalent to 1$, + \n~, which is equivalent to (Vy J -O(Vyk)$ by the remarks following Definition 4.4. 0 5. Specific RC-based \nlanguages In this section, several RC-based languages will be presented. The definitions will actually \nspecify only the underlying first-order language; in each case, the corresponding query language is formed \nfrom the set of permissible wffs. We first define the language RC, an extended domain rela\u00adtional calculus \nin the terminology of [U]. Definition 5.1. RC is the first-order language of arithmetic (+, , =, <) together \nwith constant symbols 0,1,2,... and reration symbols Rl,...,Rk , It also convenient at this point to \ndefine a family of sub\u00adlanguages of RC. Definition 5.2. For n >0, RC. consists of all wffs of RC with \nno more than n blocks of universal quantifiers in their prenex normal forms. (A block is a string of \nadjacent quantifiers of the same type.) We note that RCO consists of the existential wffs of RC. Also, \nfor m < n we have RCm CRC., and thus RC = ~ RCn. =0 At this point, we wish to introduce the language \nQUEL of [HsW into our framework. In order to do so, we assume that QUEL consists only of retrieve statements \nfrom relations over N, so that it conforms to the definition of query language in 2.1. Also, we restrict \nthe arithmetic of QUEL to addition and multiplication, so that it will be comparable to RC. Finally, \nwe give QUEL a pro. duct aggregate, analogous to sum, so that the aggregate functions are consistent \nwith the arithmetic ones. It is proved in [U] that pure domain relational calculus is equivalent to pure \ntuple relational calculus. The same proof shows, mutatis mutandis, the equivalence of QUEL as defined \nin [HSW] with the version we now define. We adopt the more set-theoretical notation of [CB]. Definition \n5.3. (1) If ~ is a set term of rank rr (see below), then for each i, 1< i < n, eourst, (.S), sum, (S), \nand product are aggregates of QUEL.  (2) If t is an aggregate of QUEL, then r is a term of QUEL. If \nt is a term of RC, then r is a term of QUEL. (3) If $ is an atomic formula of RC, then &#38;J is an \natomic formula of QUEL. If S ~and S ~ are set terms of equal rank, then the set comparison S ~= S ~is \nan atomic formula. (4) If@ is an atomic formula of QUEL, then @ and W#Jare wffs of QUEL. If @ is a wff, \nthen 3v@ is a wff. If @l and 42 are WKS, then ~ lV~ zand $ I A+ zare wffs. (5) If R ia a relation of \nrank n, then R is a set term of rank n. If @ is a wff with free variables Xl,...,xn, then  (xj,...,xn \n14(xI,...,)))) is a set term of rank n. Stricly speaking, QUEL is not a first-order language, since \nit allows set terms. We should therefore specify how a set com\u00adparison is to be interpreted, This is \nan obvious extension of the usual definition of interpretation in a structure, which we dkpense with. \nNote that (3) above allows only existential quantifiers to occur in QUEL wffs. We also define a family \nnf sublanguages of QUEL. Definition 5.4. For n >0, QUEL, consists of all wffs nf QUEL with no more than \nn levels of nested set terms. Thus, (2) [R J(X)VR JY,Z)l is a QUEL o wff, while R](x) A (y t i?z(x,y)/l{z \nI R~(x,y,z)) -(Z I R4x,z)}) = R5 is a QUEL2 wff. The remarks preceding Definition 5.3 apply here: we \nwill con\u00ad sider the languages QUEL defined above to be equivalent to the corresponding languages in \n[HSW]. As ~tith RC, we have QUELm CQUELn for rn < n, and QUEL = U QUELfl. n-O We note in passing that \nthe occurrence of a free variable in a set term corresponds to a by clause in [HSW]. 6. The lattice \ndetermined by expressive power Our first theorem follows directly from the definitions of the previous \nsection. Theorem 6.1. RCO = QUELO The next result is more interesting. It is true, but will not be proved \nuntil later, that QUEL is more powerful than RC, There\u00adfore, by Theorem 2.3, there exists a sublanguage \nof QUEL which is exactly as expressive as RC. We now characterize such a language, which we call QUEL \nf. Definition 6.2, (1) QUEL* consists of all wffs of QUEL which do not contain any aggregate functions. \n (2) For n >0, QUEL~ ~ QUELfl flQUELx .  QUELw does however allow set terms to be compared for equality \n(whence the name.) Theorem 6.3. (1) For n >0, RC. = QUEL~! (2) RC = QUEL*  Proofi Since (1) implies \n(2), we prove only the former, by induc\u00adtion on n. For n = O, the result follows from Theorem 6,1. Assume \nthe result true for n 1. Let $ be a wff of RCn. It may be written (3 J...(3j) (V~O(Vy~)l@l@ where @ \nis a wff of RCn..l. Let ~ be an equivalent QUEL~<l wff. We now invoke Lemma 4.7 to obtain QUEL~l wffs \n+ ~ and @J such that (Vyl).-(VyJ$ is equivalent to @~ * ~+. Let $ be the QUEL; Wff (%l)oo (+j)[(Yl,...,Ykl \n@I 1= lYJ*...klkl 42 )1 Then ~ is equivalent to ~, which establishes lRCn < QUEL~! For the other direction, \nlet V be a wff of QUEL#! ~ may be written where + is quantifier-free but may contain set term comparisons \n{Y,,...A i 6;) = bh..,h I @2 ) where @~ and @~ are wffs of QUEL ~<l. Apply the inductive hypothesis \nto obtain equivalent RCfl_l wffs r$I and 42; the above set comparison is then equivalent to ~ 1-@2. Let \nI#Jbe the result of substituting @J,~ @* for the original set comparison in @ . Then the RCn wff (*1)..(%j)(V~})...(Vy~)l# \n is equivalent to $ , and the theorem is proved. 0 Let us introduce two more QUEL sublanlguages, which \nwe call QUEL, countand QUEL counr,sum. Definition 6.4. (1) QUEL ou Um consists of all wffs of QU13L \nwhich do not con. tain any product aggregates or set comparisons. (2) Fnr n >0, QUELfl um ~ QUEL n QUELcO \n ,$wm. (3) QUEL co consists of all wffs of QUEL {~$wm which do not contain any sum aggregates. (4) \nFor n >0, QUELflU ~ QUEL. n QUE.LcOu .  Thus, QUEL C  allows only the calunt aggregate, and QUEL Ou \n, um allows only tlhe count and sum aggregates. We may use count tosimulate universal quantifiers, but \nnnt vice versa, as we now show. Theorem 6.5. (1) For n >0, RCC < QUEL~! (2) RC < QUELcO n  Proof First \nwe show that for all n >0, RC,, < QUEL~( This is very similar to the first part of the proof of Theorem \n6.3. The only difference is that we construct a QUEL ~ wff of the form (* J(3cJ)[count(ly j,...,yk I \nOil) = connt((y~,...,yk I @2 ))1 To show strict inequality, it suffices to let the database consist \nof a single relation R of rsmk 1, and then to show that there is no RC wff @(x) equivalent to the QUEL \n~ wff .x = count(R). Sup\u00adpose there exists such a @(x) in order to derive a contradiction. i:~ Then \nthe total constraint on x of the form x = t(yl,...,ym) V R (x), and the total constraint on each y, is \njust R (yi). We may consider tas a polynomial over N in the variables y ,,...,yfl. Since @(x) is equivalent \nto x = count(R), itmust be the case that either count (R) CR or else count(R) = r (Y 1,...,yfl) for some \ny/,. ..,Y. ER. Our strategy will be to chclose an R such that count (R) t R, and infer various properties \nof the polynomial r. We will then vary R until we obtain contradictory properties of t. First, let R \n= (O]. Since count(R) = 1, we must have t (O,... ,0) = 1, which shows that t must have a constant term \nequal to 1. Now, let R = {2). Again count(R) = 1, so we must have t(2,!,.,2) = 1. But this shows that \nt is identically equal to 1. This contradiction proves the theorem. 0 The language QUEL CoU is less powerful \nthan QUEL couo~,s m Theorem 6.6. (1) For n >0, QUEL~ < QUEL~ , Um (2) QUELC  < QUELtWKW~  Proof Since \nQUEL ~ is a sublanguage of QUEL ~ n ,wm, we have QUEL~ < QUEL~ um To show strict inequality, we proceed \nas in the proof of the previous theorem. Let the database consist of just R, as before. In order to derive \na contradiction, suppose @(x) is a QUELcOUn~ wff coutit,stirnwff ~ = sum(R). The total that is equivalent \nto the QUELI constraint on x is again x = r(y ~,...,yfl) V R (x), but here t may involve count (R). We \ntherefore consider t as a polynomial over N in the variables y 1,... ,.JJnand count(R). First, let R \n= (m+l, m+2,...,2m]. We have ~ m(m+l)sum(R) = m + 2 and so mz< sum(R) < 2m2 Now count(R) = m, and for \neach y, we have m < y, < 2m, so by varying m we can conclude that: (1) tis of degree 2, (2) c has only \none term of degree 2, and its coefficient is 1.  Now, let p be a prime, and let R = {p ,2p ,,..,p?. \nWe see that p divides sum(R), and p divides all the variables occurring in r (including count (R)). We \nconclude that p divides the constant term of t. But thk is true for all primes p, so the constant term \nmust be 0. Next, let R = {1,2}. Since sum(R) = 3, t is forced to have either one or two linear terms. \nFinally, let R = {2,3]. We see that f is always greater than 5, which is a contradiction. Therefore no \nsuch @(x) exists. 0 The language QUELcOun ,s m is in turn less powerful than QUEL. Theorem 6.7. (1) For \nn >0, QuEL~C, V~ < QUELfl. (2) QUEL Ou @m < QUEL  Proof Since QUEL ~ ,s m is a sublanguage of QUEL., \nwe have QUEL~ , < QUELn. To show strict inequality, we proceed as before. Suppose q5(x) is a QUEL  \nSUM wff that is equivalent to the QUEL 1 wff x = product(R). The total constraint on x is x = t(.y ~,...,).) \nV R (x), where t is a polynomial over N in the variables y ~,...,yn,count (R ), and sum(R). Let R = {m+l,...,2m], \nso that product(R) > mm. Now count(R) = m, sum(R) < 2m2, and for eachy, we havey, < 2m. Itfollows that \nfor sufficiently large m, t < (2m~ +1, where k is the degree of t. But m may be chosen large enough so \nthat (2m ? +1 < m , which yields the desired contradiction. 0 The final theorem of this section shows \nthat QUEL is not complete. Theorem 6.8. QUEL < Q Proof If QUEL > Q, then by Theorem 3,4 the problem of \ndecid\u00ading whether a QUEL query is a total function would be unsolvable. But this contradicts Theorem \n4.5. 0 The above proof is non-constructive, because we did not exhibit a particular query which QUEL \nis incapable of expressing. A con\u00adstructive proof. analogous to the proof in [AU] of the impossibility \nof expressing the transitive closure query in relational algebra, would provide a tighter upper bound \nthan just Q on the expressive power of QUEL. The results of thk section may be summarized as follows: \nRC = QUELX < QUEL co ~ c QUEL count, < QUEL < Q RC = QUEL~r < QUEL ~r < QUEL~rJum < QUEL, ~ RC ~ = \nQUEL &#38; = QUEL&#38; == QUELfOu ,su == QUELO 7. Procedural query languages In section 6, it was shown \nthat various extensions of RC by aggregate functions and set operations were all strictly less powerful \nthan the complete language Q, It follows from Theorem 2.3 that each of these QUEL-like languages may \nbe translated into a sub\u00ad language of Q. This translation requires a more precise specification of Q \nthan that provided by Theorem 3.2. For instance, by Theorem 4.3 we might take Q to be the set of all \n(not just permissible) wffs in an RC-based language with arithmetic, In this section, we will adopt a \nprocedural definition for Q, and we will be interested in the procedural sublanguages corresponding to \nQUEL-like languages. Several complete procedural languages have appeared in the literature ([AU], [CB], \n[CH]). We base our specification of Q on the language introduced in [AU, ii 7]. Definition 7.1. The following \nare programs of Q: (1) x := t, where x is an individual variable and t is a term of RC. (2) R := S, \nwhere R is a relation variable and S is a relation variable or constant.  (3) insert ((to,..., t ),R) \nand delete((fl,..., tn ,R), where tl,...,are  tn terms of RC and R is a relation variab )e of rank \nn. (4) begin Pl; . ~ . ;P end, where P1,...,P. are programs of Q. (5) if q$ then PJ else P* where @ \nis a qua~tifier-free wff of RC and P, and P2 are programs of Q. (6) where x ~,...,x. are individual \nvari\u00ad  or (x~x.)in .do ables, R is a relatlon variable of rank n, and P is a program of Q. (7) while \nI#Jdo P, where 1#1is a quantifier-free wff of RC and P is a program of Q. Unlike the language of [AU, \n$ 7], Q allows both individual variables and relation variables to change during a for loop. We must \ntherefore specify the semantics of (6) carefully. For instance, we wish the following program to compute \n{sum(R)} in the rela\u00adtion variable S. begin s := o; s := 0; for (x)inRdo s := S+x; insert ((s),S) end \nThis means that the program for (x) in R do P must execute P successively for each element of R. However, \nthe result may be dependent on the order in which this is done, as is the case with the following program. \nbegin n := O; s := 0; for (x)inRdo if n = Othen begin insert ((n ), S); n ;= 1 end end One solution \nwould be to define the effect of for x) in R do P to be the union of the effects of serial iteration \nover i a 1 possible order\u00adings of R. Another approach is to specify that the meaning of order-dependent \nprograms is undefined. This simpler interpretation is sufficient for our purposes. The query language \nQ consists of the programs together with the meaning function determined by the semantics of the language. \nSince rule (7) gives Q the power of a Turing machine, we have the following result. Theorem 7.2. Q is \ncomplete. Let us now define a sublanguage of Q. Definition 7,3. RQ consists of all programs of Q which \ndo not con\u00adtain the while construct of rule (7). Since all programs of RQ halt, we have the following. \n Theorem 7.4. RQ < Q The next theorem follows immediately from [AU, Theorem 31. Theorem 7.5. RC < RQ \nThe main result of this section shows that in fact, RQ is more than powerful enough to express the aggregate \nfunctions of QUEL. Theorem 7.6. QUEL < RQ Proof We first show QUEL < RQ. By the previous theorem, it \nsuffices to show how to simulate the QUEL aggregate functions count, sum, and product in RQ. We do this \nfor count; the method for sum and product is similar. There are two cases to consider. Case 1: The argument \nof count is a set term with no free variables. Example: count(lx I I#J(x))) Solution: By the previous \ntheorem, we may let P be a program of RQ which computes {x I +(x) ) and leaves the result in the rela\u00ad \ntion variable R, say. Then the following program computes the above example in the individual variable \nn. begin P; ~ := 0; for (x)in R do n := tr+l end Case 2: The argument of count is a set term some of \nwhose variables are free (corresponding to a by clause in [HSWI.) Example: [x I count({y i @(x,y))) = \n1) Solution: Let P be a program of RQ which computes {x,y I ~ (x,y) ) and leaves the result in R. The \nfollowing program computes the above example in the relation variable X. begin P; x := 0; for (x,y} in \nR do hegin ~ := o for (x ,y ) in R do ;fx=x then n:= n+l; if n = 1 then insert((x),X) end end We have \nindicated the general technique whereby an arbitrary QUEL wff may be translated into an equivalent RQ \nprogram, and so established QUEL < RQ. Strict inequality follows from Theorem 4.5 and the fact that not \nevery RQ program induces a query which is a total function. 8. Conclusions The comparative study of \nexpressive power as outlined in this paper can be used in the design of new quer,y languages. A result \nwhich relates the expressive power of a new language to that of an existing one provides a valuable criterion \nfor judging the new language. Some of the reatdts of section 6 are also applicable to the problem of \nquery optimization. The proofs of Theorems 6.3, 6.5, 6.6, and 7.6 actually yield algorithms for translating \na given expres\u00adsion of one query language into an equivalent expression in another. These might be used \nby an optimizer to change a query with universal quantifiers or set comparisons, for example, into an \nequivalent query which involves only the more efficient connt operation. One promising direction for \nfurther research in this area would be to incorporate results on the computational complexity of evaluating \nvarious classes of queries. Acknowledgment This paper originated as a final project in Philip Bernstein \ns course in database systems at Harvard. I gratefully acknowledge his many helpful comments amd suggestions. \nThanks are also due to Joseph Halpern for discussions concerning the model theoretic aspects of this \nwork. An earlier version of this paper appeared as Technical Report TR-14-80, Aiken Computation Laboratory, \nHar\u00advard University, August 1980. References [AU] Aho, A. V, and J. D. Unman. 1.hiversa]ity of Data Retrieval \nLanguages. Proc, 6th ACM Symposium on Princi\u00adples o/Programming Languages. (January 1979), 110-120. [CB] \nCasanova, M. A. and P. A. Bernstein. A Formal System for Reasoning about Programs Accessing a Relational \nDatabase. ACM Transactions on Programming Languages and Systems 2:3. I(JUIY 1980), 386-414. [CH] Chandra, \nA. K. nnd D. Harel. Computable Queries for Relational Data Bases. Proc, Ilth ACM Symposium on the Theory \nof Computing. (May 1979), 77-90. [cl] Codd, E. F. A IRelational Model for Large Shared Data Banks. CACA4 \n13:6. (June 1970), 377-387. [C21 Codd, E. F. Relational Completeness of Data Base Sub-Ianguages, in Data \nBase Systems, R. Rustin, ed. Prentice Hall (1972), 65-98. [HSW] Held, G. D,, M. IK Stonebraker, and E. \nWong. INGRES -A Relational Data Base System. Proc. 1975 National Computer Conference. (May 1975), 409-416. \n[u] Unman, J. D. Principles of Da[abase Systems. Computer Science Press (1980).  \n\t\t\t", "proc_id": "582153", "abstract": "The query languages used in relational database systems are a special class of programming languages. The majority, based on first-order logic, lend themselves to analysis using formal methods. First, we provide a definition of relational query languages and their expressive power. We prove some general results and show that only a proper subset of first-order logic formulas may be used as a practical query language. We characterize this subset in both semantic and syntactic terms. We then analyze the expressive power of several real query languages, including languages based on the relational calculus, languages with set operators and aggregate functions, and procedural query languages.Since the partial ordering <i>\"is more expressive than\"</i> determines a lattice among relational query languages, the results of the paper may be viewed as determining some of the structure of this lattice. We conclude with some applications of the results to the optimization problem for query processing.", "authors": [{"name": "Eric C. Cooper", "author_profile_id": "81100365049", "affiliation": "University of California, Berkeley, CA", "person_id": "P78003", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/582153.582190", "year": "1982", "article_id": "582190", "conference": "POPL", "title": "On the expressive power of query languages for relational databases", "url": "http://dl.acm.org/citation.cfm?id=582190"}