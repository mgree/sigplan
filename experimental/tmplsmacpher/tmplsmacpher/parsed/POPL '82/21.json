{"article_publication_date": "01-25-1982", "fulltext": "\n Building Friendly Parsers Fahimeh Jalili, Jean H. Gallier Department of Computer University Philadelphia, \nand Information of Pennsylvania Pennsylvania Sciences 19104 Abstract One of the key concepts used in \nAn essential part of any interactive minimizing reparsing is the notion of a programming development \nsystem is an yreceding node. This concept can be defined incremental parser capable of error recursively \nas follows. A node m in a parse recovery. This paper presents a general tree has preceding node n, if \neither n is incremental parser for LR(l) grammars the left brother of m or n is the preceding allowing \nseverallany form of modifications node of the father of m. All nodes having n in program. The parser \nis the input as preceding node are called the nodes supplemented with error recovery routines adjacent \nto n. The key to the reparsing using an error automaton. Errors can be algorithm is that, if t%e preceding \nnode corrected automatically by recovery changes , then this change affects routines, or by the user \nat his request. immediately the adjacent nodes. The condition for reusing a subtree of the parse 1. Introduction \ntree obtained previously, is that the state in the preceding node matches the state on This paper describes \na new incremental top of the stack (after modifications). If LR-parser which allows the user to make \nthe matching condition fails or the yield of several modifications (insertions/deletions / the subtree \ncontains a modification, then replacements) to an already (partially or the subtree is divided into smaller \nsubtrees completely) parsed input and minimizes the and each new subtree is reconsidered in amount of \nreparsing. The parser also turn. This subtree division procedure is provides facilities for error recovery. \nalso used in stack reinitialization . Permission to copy without fee all or part of this material is \ngranted provided that the copies are not made ordistributed for direct Upon detection of an error, the \nparser commercial advantage, the ACM copyright notice and the title of the publication and itsdate appear, \nandnotice isgiven that copying is by comes back to the user and offers two permission of the Association \nfor Computing Machinery. To copy otherwise, or to republish, requires a feeand/or specific permission. \ndifferent error correction modes: (1) unassisted mode: the user is fully @ 1982 ACM O-89791-065-6/82/OOl/O196 \n$00.75 responsible for making corrections and for restarting the parser. (2) assisted mode the parser \nperforms a forward move , using an error automaton (as in Pennello and DeRemer [81), prompts the user \nfor a repair, and then consumes the repaired forward context and reports on the success of the correction. \nIf the correction has failed, the user is prompted again. This process continues until either the repair \nis successful or the user gives UP and lets the parser complete the parse using automatic error correction. \nNote that in any case, unless the user decides to abort, the parse will be completed. Related research \nis listed below. M. Kahrs [6] describes a top-down approach to incremental parsing. Ghezzi and Mandrioli \n[3,41 describe a shift/reduce incremental parser for LR(0), Celentano [2], and Wegman [10] describe a \nshift/reduce incremental parser for LR(l) grammars. However, these incremental LR parsers are limited \nto a single insertion or deletion of a substring. In contrast, the parser described here gives the user \ncomplete freedom during program modification. It allows multiple modifications including the insertion \nof BEGIN END, or the addition of else-clause to an IF THEN. Furthermore, no syntactic or structural information \nis required from the user. 2. Review of Shift/Reduce Parsers augmented et G = (VN,VT,P,S ) be an LR(l) \ngrammar with V the set of N 197 nonterminals, V ~ the set of terminals, P the set of production rules \nand s the start symbol, The following notation for describing LR-parsers will be used. Let S be the set \nof states with so as the initial atate. Let each entry in the parsing stack be of the form (g,s) where \ng ~ VN U VT and a 6 s. Each entry in the stack will eventually become a node in the parse tree and we \ntherefore assume that each entry also contains pointers to ita descendent nodes in the parse tree. Initially, \nentry (~,so) is pushed onto the stack. Define the following two functions: (1) action function f:sx(vT \nU $)--->{accept, shift, error reduce pilpif3P } (2) goto function gt:sx(vN u VT) ---> S U {error}  \nThe shift/reduce actiona are defined as usual [1]. 3. Incremental Shift/Reduce Algorithm Let w be an \ninput string, T the parse tree (or a sequence of subtrees if parsing was not completed) of w and w a \nmodification of w. To construct T , the parse tree of w , the incremental parser recognizes substrings \ncommon to both w and w whose corresponding subtree structures remain the same and uses those subtrees. \nReparsing of such aubstrings is therefore avoided. Essential to our parser ia a simple mechanism for \nrecognizing these substrigs. The following concepts are both cases. Note that each pair (g,s) is necessary \nto the description of the the root of a subtree . The longest incremental parsing algorithm. substring \ny satisfying the above conditions is the substring resulting from a) Let w = XY be a string generated \nby concatenation (from left to right) of the grammar G, and let w = XY be a yields of subtrees whose \nroots are the right * modification of w with x# ~ and y,Y ~ VT . brothers of node (gm,sm) in the Old \nParse A deterministic LR(l) parser will parse both tree. We now have a simple mechanism for w and w identically \nup to the point recognizing substructures not affected by immediately after last(x) has been pushed the \nmodifications and can therefore avoid onto the stack, i.e. before any reduction reparsing them. is carried \nout using first(y) Or first(y ) as the lookahead symbol. First(y) may c) For every stack entry (or node) \ndiffer from first(y ) and result in n :(gn,sn), we define the set of its different reductions. The reparsing \nadjacent nodes as follows: algorithm can then start at the point where adj(n) = {k I k is an entry k: \n(gk>ah) that has been pushed on t e a new terminal symbol was inserted or stack next to n at some point \nduring the parse} deleted and avoid reparsing of x. adj(n) may be empty. For each node k b) Let w=XYZ \n(Y,Z #g) be an input adj(n) we call n the preceding node of k, string and let and s the preceding state \nof k. The n { (g,so), (gl>sl), . . ..(gm.sm)} be the stack preceding node of every tree node n (except \ncontents just prior to pushing first(y) onto the root) can be determined by recursive the stack in parsing \nw. Let w = X YZ be a application of the following process: The modification of w and let preceding node \nof n is its immediate left {(s,s.), (g l,s l), . . . . (g n,s n)} be the brother if there is one. Otherwise, \nthe stack contents just prior to pushing preceding node is the preceding node of the first(y) onto the \nstack in parsing w . father of n. If S=s and mn {(s,s.), (gl>sl), . . . . (gm>sm)) (gm+l!sm+l)> the Graphically, \nadj(n) corresponds to . . . . (!3 the stack resulting set of nodes in the parse tree consisting of m+k \nsm+k)} s from parsing xy in w, then the stack node k, the immediate right brother of n and obtained by \nparsing X Y in w is every descendent of k along the leftmost {(~,so), (g l>s l), . . . . (g n>s n), branch \nin the subtree rooted at k. Note (g:+l,s;+l)> . . . . (g~+k,s~+k)}, with that V k 43 adj(n) Sk = .gt(sn,gk) \nand ,/ g = gn+i ! m+i = n+i > i = 1,.. . , k. therefore, if Sn changes, all nodes in m+ i In other words, \ny will be parsed the same in adj(n) will also change. The incremental paraer searches for the largest \nsubtree not affected by the modifications and therefore uses a top down approach. It begins by examining \nT and proceeds in left to right order. For each subtree t, the parser checks the substring A which is \nthe yield of t. If A has been modified then, rather than reparsing the entire substring, the parser divides \nthe subtree t along a path from root to the point of leftmost modification. This division results in \na sequence of smaller subtrees that are reconsidered again. If A has not been modified, the parser determines \nwhether the structure of t is affected by the modifications. If the preceding node of the root of t in \nT is the same as the state on top of the parsing stack, t matches the stack and can be used in T . However, \nt may have been affected by reductions upon reading the input symbol following A. If this symbol is still \nthe same, t is pushed onto the stack. Otherwise, the parser proceeds to undo those reductions and then \npushes the resulting sequence of subtrees onto the stack. If the matching condition for t fails, t is \nreplaced by a sequence of smaller subtrees obtained by deleting all the nonterminal nodea along the leftmost \nbranch of t. The new subtrees are reconsidered again in turn. If t consists of a single terminal node, \nit is removed from the pool of subtrees. The incremental parser continues the parse in its normal mode \nusing this terminal symbol. The incremental parser processes the existing subtrees in left to right order, \nand the division and replacement operations are alwaya applied to the leftmost subtree. Therefore, a \nsecond stack called subtree stack is used by the parser for sequencing and manipulation of such aubtrees. \nBefore presenting the incremental parsing algorithm , we describe the subtree operations used. 3.1. Subtree \nOperations Let t be a subtree, A=(ai ,a. ,...,a im) 1 12 an ordered sequence of terminal symbols such \nthat ai a, . ..a yield of t,and t t i ql q2112 m two sequences of subtre~s obtained from t. Define the \nfollowing functions: divide: t X A---> t ql x tq2 The two sequences t are obtained as ql tq2 follows: \nVisit the nodes of subtree t along a path from root to the terminal node containing a. for some k<= m. \nFor each _k node n along this path, subtrees whose roots are left brothers of n are added to the end \nof sequence t in left to right order. All ql right brothers of n are added to the beginning of sequence \nt in right to left q2 order. The terminal node containing a. ia Ik added to the end of sequence t It \nshould ql be noted that the preceding state of every subtree in t can be determined during ql tqz this \nassumed associated traversal. that with In every the this subtree preceding paper, in state it t q2 of \nis le its This when undo-reduction: function is the path a t--->t special followed ql case is of along \ndivide the root node. rightmost branch of the subtree t. Application of this function results in undoing \nall the reductions which may have occured on the input symbol following ai . m t: A /\\ A //\\D E F Figure \n1 : t ql,tq2 of divide obtained operation. by application Figure 2 . : t ql obtained undo-reduction \nby application operation. of The sequence entries of a t ql parsing corresponds stack to immediately \nthe top after This delete: function t is X A ->t used q2 when the substring shifting performed following \ntree parsing a. and before any reduction is lk using the terminal symbol a. . If t is the entire parse \nlk then ql corresp~nds to the entire stack. This operation constitutes a. a. . ..a. ,k<m is 11 12 Ik \nstring. The computation as in divide. The operations divide and can be used to delete deleted from of \nt is q2 application delete in a substring the input the same of two succession that is the core of the \nstack initialization not a prefix of the yield of a subtree. algorithm. eliminates stack Mandrioli approach \nIt the recovery [4], described is easy to implement need of extra pointers as suggested by Ghezzi or \nthe trial and by Wegman ~10]. and for and error replace: t-- >t q2 The sequence tq2 is obtained deleting \nall the nonterminal nodes leftmost branch of t. These nodes are precisely those in the from t along nonterminal \nset adj(n ) by the where n is the preceding node of the root of t. 200 t: A describing the incremental \nparser. P-STACK; Parsing stack whose entries are of the form (g)s) i.e. tree nodes. R-STACK; A push-down \nstack whose entries are of the form (s,n) where n is a pointer to the root of a subtree and s is the \npreceding state of its rootnode. This stack is constructed such that the string obtained by concatenation \nof the yields of its subtrees in top down, left to right order corresponds to a suffix of the old input \nstring. YIELD(t); Ordered set of terminal symbols corresponding to yield of aubtree t. T; Old parse tree. \nFigure 3 : t q2 obtained by replace operation. appl cation of w=a . 11 ..a. lm ;Input string. REST(w); \nSuffix of w not yet parsed. This operation does not affect the terminal t qi; Sequence of subtrees. nodes \nor their relative ordering. The yield of t and the sequence of subtrees are Assume the first input modification \ntherefore the same. occurs after aik i.e. a. 11 . ..a. Ik (k<m) is not modified, and that every subtree \nin 3.2 Incremental Parsing Algorithm sequence t q2 1s paired with the preceding The following conventions \nare used in state of ita root node. ALGORITHM begin INCRP {Initialize P-STACK and R-STACK. } (tql,tq2)<--\u00adpush \nt on ql divide(T,a. P-STACK; lk ); push t q2 on R-STACK; repeat case-1 REST(w) begins begin parse the \nnew end {case-l}; with an subst.ring; inserted subatring: case 2 REST(w) begins begin t<---aubtree pop \nR-STACK; with on top a of deleted R-STACK; substring a. ljl  ai. Jk : if YIELD(t) is deleted then delete \nsubtree t else begin ; ~2<---delete(t, ai, ); . k push tq2 on R-STACK; end; end {case-2}; case-3 REST(w) \nbegins with an already parsed substring. begin perform all possible reductions using first symbol of \nREST(w); t<---subtree on top of R-STACK; poP R-STACK; if preceding state of t in T is the same as the \nstate on top of P-STACK then begin if YIELD(t) is not modified then begin if input symbol following YIELD(t) \nis modified then begin t <---undo-reduction(t); ql push tql on P-STACK; end else push t on P-STACK; \nend else begin (tq1>tq2)< ---divide(t,a. ); Ik {a. denotes the terminal symbol prior lk to leftmost modification \nin YIELD(t) } push tql on P-STACK; push tq2 on R-STACK; end end else begin < ---replace(t); q2 t <t \nwith t , the first element of t removed; q3 --q2 q2 {t consists of a single terminal node} push t on \nR-STACK; q3 a<---grammar symbol of t ; continue the parse using at! for the input symbol until a is \nshifted on P-STACK; end end case 3; until end of input; end {ALGORITHM INCRP} 4. Error Recovery let \nT= { f(q,c)l q 6 Q}. A powerful syntactic error recovery (1) If T # {error} and T-{error} facility is \nessential for an interactive contains only shift moves, then a shift is compiler. The Interactive Error \n~ecovery performed on input c and the new set of ~lgorithm (IERA) described here is designed states R \n= {gt(q,c)lq e Q} -{error} is to achieve this goal. The IERA is inspired pushed on top of the stack. \nNote that from research reported in [5,7,8]. Our states in Q resulting in an error are algorithm continues \nthe parse after the ignored as long as there are other legal point of error to accumulate some forward \nmoves. context. It then attempts to correct the (2) If T -{error} = {reduce pn} then a error by insertion/deletion \nof a terminal reduction by production pn is performed. If symbol at the point of error. this move causes \nstack underflow , the parser stops in the overdefined state . 4.1. Accumulation of Forward Context . \n(3) If T -{error} contains both shift Let us describe briefly the error and reduce moves, or reduce \nmoves by automaton used for accumulating forward different productions, the parser stops in context. \nThe states of the error automaton the overdefined state. are subsets of the states of the original LR-automaton \nand a slightly modified version (4) If T= {error}, input c is a of the shift/reduce algorithm is used \nas subsequent error which is reported. explained below. In (2) and (3), the parallel simulation Given \nthat an error occurs in state s of all legal moves is inconsistent. This on input a, starting from a \nnew stack does not necessarily imp. y that input c is containing K (the set of all parser states) in \nerror. Therefore the parser is as initial state, a (forced) shift is restarted in the error mode, and \nfrom performed on b (the input immediately initial error state K. The pieces of stack following a) for \nevery state in K from which accumulated during each subparse in error the transition is possible. The \nresulting mode are saved to be used for error recovery set of states Q is pushed onto the stack. (see \nPennello and DeRemer [8]). The This first move on the input b is performed concatenation of these pieces \nof stack form to make sure that some input is consumed the forward context. whenever the error automaton \nis entered. The paraer proceeds in the error mode The subsequent moves are determined as as above until \neither a subsequent error is follows: Let Q be the top aubaet of states detected, or the amount of forward \ncontext on the stack, let c be the next input, and accumulated exceeds a predefined value. This value \nis adjusted experimentally by trial and error. For an interactive parser, this value tends to be small. \nDue to reductions , the forward context c is usually much shorter than the input fragment u scanned during \nits accumulation. Therefore, in order to verify that a repair is successful, it is sufficient to check \nthat the repaired forward context can be consumed. Reparsing of u is therefore avoided. During reparsing \nof a modified input, the parse tree (or partially constructed parse tree) of the input is available. \nThe ~orward &#38;ontext ~ccumulation procedure (FCA) uses the subtrees already constructed and avoids \nreparsing of the corresponding substrings. During forward context accumulation by FCA, the following \ncases may arise: (1) The substring being processed is a new insertion. In this case, FCA continues as \nusual. (2) The substring being processed is not new, i.e. subtrees corresponding to the substring exist. \nThe FCA examines the error state Q on top of the error mode parsing stack. State Q corresponds to a set \nof states and entry Q in the parsing table has a pointer to the list of states which constitutes Q. If \nthe grammar symbol stored at the rootnode of the subtree under consideration is accepted by the FCA and \nthe preceding state of the rootnode is among the  states of Q, then reparsing of the substring is avoided. \nThe FCA does no t construct subtrees. Firstly, the FCA uses error states which are not useful in normal \nparsing mode and cannot be used as preceding states. Secondly, tree building by the FCA destroys the \nalready existing subtrees that can be used after the appropriate correction is made and the algorithm \nis back to normal mode. However, the operations divide and delete are applied to the existing subtrees \nwhenever necessary. 4.2. Error Correction A common weakness of all the error recovery methods reported \nto date, is their inability to recover from stack damages resulting from chains of reductions upon reading \nthe erroneus symbol. As a result, recovery may not be possible, even when the right correction is made. \nOur recovery algorithm is capable of completely recovering from such damages. The top entry of the normal \nmode parsing stack is examined. If this entry is a terminal node, no damage is done. Otherwise, the function \nundo-reduction is applied to this top entry. The result is the stack contents prior to any reductions \non the erroneus input symbol. This recovery method also eliminates the need for correction attempts with \nnonterminal symbols and consequently reduces the error recovery computation time by a substantial amount \n. Additional time saving is achieved by considering for correction, the set of terminal symbols Line \nnumbers are assigned in increasing {tltevT, stack and top f(s top is t) the is state defined}. on top \nof This the set order input. from The the line beginning status to indicates the end whether of a of \nterminal symbols is easily obtainable new line has been inserted or an existing from the parsing table. \nline has been deleted during the latest follows: entry The corrections If the obtained as state the are \nof result evaluated as the topmost stack of a particular editing to the the editor phase. user, and The \nbut the line status is used and parser. is reset invisible by both correction is the same as the preceding \nOur parse tree is constructed in binary state of the appropriate subtree, then this form with the following \nnode structure: correction Otherwise, is the considered correction to be the consuming best. the N: Ill \nlglsll-no Ill I I lr-nolp ptr I I I [ Id-ptrlr ptrl I I I I longest forward context accumulated by the \n.!3: grammar symbol FCA is chosen. s: parsing state In the implemented system the user can l-no : line \nof number subtree of leftmost rooted at n terminal . node interact with the The programmer can indicate \nwhether accumulated for error recovery routines. enter the corrections forward context should evaluation \nof and be the r-no p ptr: : line number of rightmost node of subtree rooted at pointer to parent node \nof the leftmost descendent of node,otherwise pointer to left brother of n. terminal n . n when n its \nparent immediate is corrections. d ptr: pointer to leftmost descendent of n. 5. Implementation of Incremental \nParsers r-ptr: pointer n. to immediate right brother of The implementation by Jalili consists Line numbers \nstored at each node and of an editor and an incremental parser with the line status associated with each \ninput error handling routines written in PASCAL line provide a simple mechanism for and running on a \nVAX. Our test language is detecting any modification in the yield of a the full language PASCAL. T!Le \nparsing subtree. Also, line numbers provide an tables were obtained using an LALR(l)-parser efficient \nguideline for traversing a path to generator incorporating a construction of a specific node in the parse \ntree. error K. states are line each states due to Gallier, and written by Schimpf [9]. The parser has \n369 normal and 161 error states. Modifications in the form of insertion/deletion of a of input. The editor \nassociates with line a line number and a line status. Error and allow programmer indicate accumulated \ncorrections. handling routines are interactive any degree of user control. can enter the corrections \nwhether forward context should for evaluation of Ultimately, the user The and be the may 205 request \nautomatic error recovery and return the control to the system. Acknowledgment: We would like to thank \nThomas Pennello and Frank DeRemer for providing us with the extended version of their paper on error \nrecovery. References [1] At,o,A. V. and Ulman, J. D., Theory of Parsing, Trans lation and Compiling \n, Vols. I, II,Prentice Hall, Englewood Cliffs, N. J., 1972, 1973. [21 Celentano, A., Incremental LR \nParsers , Acts Informatica 10,307-321 (1978). [31 Ghezzi,Carlo, and Dino Mandrioli, Incremental Parsing \n, ACM Transaction on Programming Languages and Systems, vol. l,No. 1,58-70(1979). [4] Ghezzi, Carlo, \nand Dino Mandrioli, Augmenting Parsers to Support Incrementality , Journal of ACM, vol. 27,N0. 3,564-579(1980). \n[5] Graham, Susan and Rhodes, Steve, Practical Syntactic Error Recovery , Communications of ACM Vol. \n18, No. 11, 639-650(1975). [6] Kahrs, Mark, Implementation of an Interactive Programming System , Sigplan \nNotices, vol. 14, No. 8, 76-82(1979). [7] Mickunas, M.Dennis and Modry, John A ., Automatic Error Recovery \nfor LR Parsers , Communications of ACM, vOl.21, NO.6, 459-465(1978). [8] Pennello, Thomas J. and Frank \nDeRemer, A Forward Move Algorithm for Error Recovery , Fifth Annual ACM Symposium on Principles of Programming \nLanguages 241-254(1978). [91 Schimpf, Karl, Construction Methods of LR Parsers , Master s theais, Tech. \nRep. No. MS-CIS 80-40, Comptr. Sci. Dept., Univ. of pennsylvania( 1981). [10] Wegman, Mark, Parsing for \nStructural Editors ,2lst Annual Symposium on Foundations of Computer Science, 320-327(1980).  \n\t\t\t", "proc_id": "582153", "abstract": "An essential part of any interactive programming development system is an incremental parser capable of error recovery. This paper presents a general incremental parser for LR(1) grammars allowing several/any form of modifications in the input program. The parser is suplemented with error recovery routines using an error automaton. Errors can be corrected automatically by recovery routines, or by the user at his request.", "authors": [{"name": "Fahimeh Jalili", "author_profile_id": "81100289178", "affiliation": "University of Pennsylvania, Philadelphia, Pennsylvania", "person_id": "PP39036160", "email_address": "", "orcid_id": ""}, {"name": "Jean H. Gallier", "author_profile_id": "81100504149", "affiliation": "University of Pennsylvania, Philadelphia, Pennsylvania", "person_id": "P136113", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/582153.582175", "year": "1982", "article_id": "582175", "conference": "POPL", "title": "Building friendly parsers", "url": "http://dl.acm.org/citation.cfm?id=582175"}