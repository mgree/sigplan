{"article_publication_date": "01-25-1982", "fulltext": "\n SEMANTICS AND CORRECTNESS OF A QUERY LANGUAGE TRANSLATION (preliminary version) E. Gansner, J.R.Horgan, \nC. M. R. Kintala, D.J.Moore and P.Surko Bell Laboratories Murray Hill, New Jersey 07974 ABSTRACT This \npaper proves the correctness of a translation from HISEL, a relational database query language, to HI, \na hierarchical query language. The four components of Morris [7] program are established. Appropriate \nsemantics for the two languages are defined. A translation function is defined and an L\u00adattributed grammar \ncapturing the translation function is exhibited. The transformation of database trees into database relations \nk specified. 1. INTRODUCTION This paper, following Morris suggestion for showing compiler correctness \n[7], defines the formal semantics of two database query languages and proves the correctness of a translator \nbetween them. Morris method requires one to establish the commutativity of the following diagram: Source \nCompile Target Language Y Language L~ T Source Target Semantics @ * Semantics &#38;J R~ H Source 8 Target \nMeanings Encode Meanings Figure 1 Permkskm to copy without fee all or part of this material k granted \nprovided that the copies are not made or distributed for direct commercial advantage, the ACM copyright \nnotice and the title of the publication and its date appear, and notice is given that copying is by permission \nof the Association for Computing Machinery. To copy otherwise, or to republish, requires a fee and/or \nspecific permission. @ 1982 ACM 0-89791-065-6/82/001/0289 $00.75 289 A considerable amount of work describing \nthe theoretical variations on this theme exists [7,8]. Gaudel [3] uses abstract data types to represent \nthe meanings of programs and prove the correctness of compilers generated by the PERLUETTE compiler-generator. \nThatcher, Wagner, and Wright [11 ] present an algebraic version of this idea. The observation that relational \nquery languages are to hierarchical query languages as programming languages are to target languages \nmotivates our variation of this theme. It is often desirable, for a better end-user interface, to provide \na relational view of an existing hierarchical database. Providing such a conceptual view, which differs \nlogically from the underlying physical database, requires techniques for parsing and translation adapted \nto preserve the natural semantics of both the relational and the hierarchical language. Systems such \nas EXPRESS [3] perform some aspects of such a translation. The development of the HISEL-to-HI translator \nrequired consideration of every aspect of the Morris program. This paper explicitly defines formally \ncorrect and intuitively adequate semantics for the relational language HISEL and the hierarchical language \nHI. Given these semantics, the decoding of hierarchies into relations becomes clear, and the translation \nof HISEL to HI is defined to preserve the meanings of the two languages, By analogy with the techniques \nfor specifying denotational semantics of programming languages, we define a domain R and a semantic evaluation \nfunction @ from HISEL to R. The formal semantics of HI is similarly defined by giving a domain H and \nan evaluation function +. A translation from HISEL to HI, ~, is then defined which is expressed by means \nof an attributed translation grammar. The decoding of hierarchies into relations is achieved by ~. Following \nMorris suggestion, we then prove the correctness of this translation by showing the commutativity of \nthe following diagram: 4 That is, we show that for a given q c HISEL, and a database T ~ H 4(q>6(T)) \n= ~(#(7(q,T),T)). Clearly, the selection of T, a particular database tree, dominates the translation \nprocess and determines the evaluation of the HISEL query q and its translation, T(q,T), into HI. Formal \ntreatments of database systems, particularly proofs of correctness are, excepting those for concurrency \nprotocols, rare in the literature. Not only does our proof give confidence in the correctness of the \nquery translation system HISEL, but it is also evidence of the usefulness of Morris suggestion for practical \ntranslation systems. The paper consists of four sections: the semantics of HISEL; the semantics of HI; \nthe definition of the translation functions; and proof of correctness. An appendix contains the translator, \npresented as an L\u00adattributed translation grammar. 2. SEMANTICS OF A RELATIONAL QUERY LANGUAGE HISEL is \na relational query language which presents a conceptual view of a hierarchy as a single, or universal \n, relation. Because HISEL is a tuple calculus language to be evaluated on a single conceptual relation, \nits semantics differ from those of tuple calculus languages like QUEL, which may be evaluated on multiple \nrel~tions, and relational algebra languages like ISBL, in which variables range over relations but not \ntuples. 2.1 The Syntax of HISEL The HISEL language may be informally specified by the following grammar: \nQUERY + select LIST where CONDS LIST + LIST , FIELD ! empty FIELD + Cursr . Fld CONDS --+ CONDS A COND \nI CONDS V COND I COND COND + FIELD Op Const I Const Op FIELD I FIELD Op FIELD I empty where Cursr is \na metasyntactic variable for variables ranging over tuples in a relation, Const similarly ranges over \nconstants, Op c {=, # ,<,>, =,=,in], and Fld ranges over database field names. 2.2 The Domain of HISEL \nHISEL presents a universal relation view of a hierarchical database. Let { X.F I X in Cursr and F in \nFld ] be the set of all field names. Although field names are always of the form X. F , that is Cursr.Fld \n, we shall often use simple variables to represent them. If F is a field name, DOM(F) is the domain of \nvalues of F. NA is the null value, not applicable . Given field names X.F and X .F , we require that \nDOM(X.F) = DOM(X .F ) if F = F . By prefixing distinct cursors to the same fields we obtain distinct \nfield names. This convention is a considerable technical convenience. A tuple is a set of field (name, \nvalue) pairs where the values are from the domain of values of the field name, or NA. NO field name may \noccur more than once in a tuple. The type of a tuple is the set of field names in the tuple. A relation \nis a set of tuples all of the same type. The relational domain of HISEL, R, k the set of all relations. \nLet R 6 R and t c R, then we define val(t(F)) to be the value of the field name F in tuple t. In HISEL \nthe usual relational projection operation is captured in the select LIST portion of a query. Relational \nselection is achieved by the where CONDS part of a query, and joins may be formed by comparisons on different \ncursors, i.e. different tuple variables. Query conditions, CONDS, involve quantifier-free, first-order \nformulas over the predicates in Op. The meanings of these predicates are extended to include NA in a \nstraightforward way. For @ c Op, and VI, V2 c (J { DOM(F)I F is a field name) (J { NA ] , we extend the \nmeaning of 0 by the rule: VI O V2 is false if VI or V2 is NA; otherwise it has the usual truth value. \nIn other words, 1O = 10 is, as usual, true, but 1O = NA and NA = NA are false. An intended consequence \nof this rule is that, for instance, atomic query conditions evaluated on NA are false. Consider a condition \nQ generated by CONDS in the HISEL grammar and a relation R . R such that .11 field names in Q are fields \nin R. We say that t satisfies Q, denoted t k Q, if and only if (i)Qisoftheform F@C or C@F or F@ F and \nval(t(F)) @ C or C @ val(t(F)) or val(t(F)) @ val(t(F )) respectively is true, or (ii) Qisofthe form \nQl AQ; and t1=QI and t 1= Q2, or (iii) Qis oftheform Ql VQ2 andtb QIort+ Q2. Let R ~ R. The schema for \nR, designated Rs, is the set of field names in R, and for q c HISEL and R c R, we say that R is a possible \nrelation for q if and only if all the field names in q occur in R~. A query q c HISEL is evaluated by \nthe evaluation function @ in the domain R, where ~ is defined inductively on the structure of q. Let \nq e HISEL be of the form select Xl .F1, . . . , Xn.Fn where Q and let R c R be a possible relation for \nq. Then we define @(q,R) by induction on Q: (i) If Q is empty, 4(q,R) = {{(X1 .F1,val(tl(Xl.F1 ))),..., \n(Xn.Fn,val(tn(Xn. Fn)))} Iti cRand,ifXi = Xkthen ti= tk}, (ii) if Q is not em~ty and q is tfie query \nobtained from q by replacing Q by the empty condition, 4(q>R) = {tltt@(q ,R) andt+ Q},  (i) is the \njoin-projection of relation R in which distinct cursors range over tup~es from which field values are \nprojected. (ii) selects only those tuples of (i) which satisfy query condition Q.  3. SEMANTICS OF A \nHIERARCHICAL QUERY LANGUAGE Hierarchical query languages are related to relational languages in the way \nthat procedural programming languages are to applicative ones. Hierarchical languages consist of data \nselection statements, which correspond to assignment and input/output statements, and navigation statements, \nwhich correspond to control statements. The semantics of the relational language HISEL are declarative, \nand thus are easily defined in the way, for instance, those of the propositional calculus are defined. \nThe semantics of a hierarchical language, on the other hand, are similar to those of a procedural language, \nand require more complicated constructions. HI is a language for querying a hierarchy of records, In \nthis hierarchy, each record has a set of field (name, value) pairs, and sets of pointers to child records. \nThere is a current position pointer in the hierarchy manipulated by navigation statements. 3.1 Lexicsl \nand Syntactic Description of HI HI has three navigational statements: root, down(i), and up. root moves \nthe current position pointer to the first record of the root node in the hierarchy. down(i) moves the \ncurrent position pointer to the first instance of the specified child record under the current record \nin the hierarchy. up moves the current position pointer to the parent record of the current record. HI \nhas three control statements: loop, cond(f,c,fl), and comp(iJ, @), where @ e Op. loop causes iterated \nexecution of the entire string of commands from the loop itself to the end of the query. It is executed \nfor each instance of the current record type under the current parent in the hierarchy until an up statement \nis encountered. cond has parameters field-name f, operator-symbol @, and a constant c. The field value \nf is compared to the constant c according to 0. If the result is true, the current record pointer is \nmoved to the next statement in the current 100D; otherwise execution of the innermost loop is disconti~ued. \ncomp is paired with temp statements. temp(f,i) extracts the contents of the field f of the current record \ninto a global buffer position numbered i. After the occurrence of temp(f,i) and temp(g,j), the statement \ncomp(i,j,@) compares by 0 the values set aside from records f and g. The execution of a comp statement \nalters the flow of control in the manner indicated for the cond statement. The data extraction statement \nis extract (s, f). It saves the contents of the field f of the current record as the output pair (s,value \nof f), where s is a tag string. The syntactic description of HI is simple since the HI system uses a \ncommand interpreter in which improper execution of a statement results in a null response carried through \nthe rest of the query. Thus, a HI program can be said to consist of any sequence of the above statements \nseparated by semicolons. An example of a semantic event that results in a null response is the attempted \nextraction of a value for a nonexistent field.  3.2 The Semantic Domain for HI The semantic domain for \nHI is the set of data base trees obtained from the general linked structure of all fields and values, \nwith elements (nodes) indexed by the natural numbers. Let H be the set: { (( F1+Vl),...,(Fp, VP), Pp,CHpl,CHPk)HPk) \nI Fi is a field name, Vi c DOM(Fi) U {a] for Osisp; PP c N, CHPm C N, IsmSk]. a is a null value. PP is \na pointer to the parent, and each CHP is a set of pointers to child nodes. The type of a node with field \n(name, value) pairs (FI,V1),...,(FP, VP) is the sequence Fl,...,FP, and the type of a pointer is the \ntype of the node to which it points. Let T c H. Then the schema of T, T,, is the set of types of nodes \nin T in which two types are linked by pointers if and only if two nodes of those types are similarly \nlinked in T. Any T c H is a database tree if i. T is a finite set; and ii. T~ is a tree in which no \nfield name occurs twice; ... 111. every CHP C of every node in T satisfies a. if m c C, then the node \nof H with pointer m isin T; and b. if m, n cC, then the type of m isthe same as the type of n.  iv. \nT is a tree whose root node has no field (name, value) pairs (p= O), one set of child pointers (m= 1), \nand a PP pointer to itself. The semantic domain for HI is H = {T c H IT isa database tree ]. The semantics \nof a HI query h are defined on any T c H. A null tree T is taken as a starting point. h guides a traversal \nof T during which attributes and values encountered may be copied from T into T with data selection statements. \nThe result is a new data base tree ~(h,T) into which certain field (name, value) pairs have been copied. \nThis tree holds the answer to the query in a nicely structured way. To obtain a tuple of values for a \nrelational answer, the tree is traversed from root to a leaf as described by the function 6, defined \nin section 4. The relational representation, b(~(h,T)), of the resulting tree +(h,T) is obtained by gathering \nthe tuples associated with each leaf. Because HI is a procedural language, it has continuation semantics \nand therefore an environment is necessary. G: N + U DOM (F) is a global environment of temporarily stored \nvalues. Updating of G is indicated as follows: G[v/i] is the function G where G (i) = v and G (j) = G(j) \nfor j # i. Initially, G* = {(i,a) I i , N } is the environment. ~ : HIXHXNXG + HXNXNXG is first defined \nby induction on the structure of query h. Then # :HI X H + H is derived. The range of ~ is a quadruple: \nan element of H (the partially built answer tree), an integer (a pointer to the current node in this \ntree), an integer (a pointer to the node in the data base tree reached by a partial execution of the \nquery, called the current node pointer), and G. A query is straight-line if it contains no loop, comp, \nor cond statements. A query is rootless if it contains no root statement. The semantic routine GRAFT \n: HXNXH -+ H takes a tree T, a node n in T, and another tree T as arguments. The result is a new version \nof tree T in which T has been grafted below node n. To make the result a valid data base tree, a new \nCHP set is established in node n. Certain semantic routines are defined as they are needed. We use the \nfollowing notation: if f is a function whose range is n-tuples, fil,.,i~(x) is the usual k-tuple projection. \nWe now define ~(h,T,c,G) inductively on the structure of h. For this discussion h c HI, T ~ H, c c N \n(a current node pointer), and G is the environment of stored values. Case O: h is the empty string. ~(h,T,c,G) \n= (*, 1 ,c,G). No new tree is needed. -1 is the null pointer. The current node pointer in T, and G remain \nunchanged. Case 1: h is the query h root; h . Let ROOT(T) be the index of the first child of the root \nnode of T. VROOT(T) is the root node of T. Let ARG be the string h ,T,ROOT(T), ~4(h ,T,c,G) . Then 4 \n(h,T,c,G) = (GRAFT(W,(h ,T,c, G), VROOT(# l(h ,T,c, G)),~l(ARG)), ~ 2,3,4(ARG)). Two trees are constructed \nand grafted under a common node. Case 2: h is the query h down(i); h , and h and h are rootless, h is \nstraight line, and 1sis the number of CHP sets in ~ 3(h ,T,c,G). Let DOWN(n,i) be the smallest element \nof the i-th CHP entry of node n. Let ARG be the string h , T, DOWN(+ 3(h ,T,c, G),i),~4(h ,T,c, G) . \nThen # (h,T,c,G) = (GRAFT(~l,2(h , T,c,G),tJ l(ARG)), * 2,3,4 (ARG)). The work of answering h is done, \nthen the current node pointer is reset, and the work of h is done. Case 3: h is the query h up; h , and \nh and h are rootless, and h is straight-line. Let UP(n) be the parent node of node n. Let ARG be the \nstring h ,T, UP(V 3(h ,T,c,G)) ,4 4(h ,T,c,G)n. Then ~(h,T,c,G) = (GRAFT(+ 1,2(h , T,c,G),~ l(ARG)), \n* 2,3,4 (ARG)). The work of answering h is done, the current node pointer is reset to the parent, and \nthe work of h is done. Case 4: h is the query h extract(s,f); h , and h is straight-line, h and h are \nrootless, and 1=f= the number of field (name, value) pairs of y! 3(h ,T,c,G). Let COPY(T,n,m,s,f) be \na version of tree T in which node n has obtained the pair (s, value of f) from node m. Let ARG be the \nstring h , T,+ 3(h ,T,c,G), ~ 4(h ,T,c,G) . Then ~ (h,T,c,G) = (GRAFT (COPY(~ l,2,3(h ,T,c,G) ,s,f) , \n+ 2(h ,T,c,G),+ l (ARG)) , ~2,3,4(ARG)). Form the tree for h and copy the appropriate field (name, value) \npair from T. Then graft on the tree for h . Case 5: h is the query h temp(f,i); h , and h is straight-line, \nh and h are rootless, and 1=f< the number of field (name, value) pairs of ~3(h ,T,c,G). Let VALUE(n,f) \nbe the value component of the field (name, value) pair for field f of node n. Let ARG be the string \"h'',T,~3,4(h', \nT,c,G[VALUE(+'3( h',T,c,G), f)/i])\". Then ~(h,T,c,G) = (GRAFT(tJ 1,2(h , T,c,G),~l(ARG)), ~ 2,3,4(ARG)). \nForm the tree for h , store the temporary value, then graft on the tree for h. Case 6: h is the query \nh cond(f,v,@); h , and h is straight-line, h and h are rootless, and 1 <f= the number of field (name, \nvalue) pairs of # 3(h ,T,c,G). Let TE.ST(W, O,V) be true if the expression w 0 v is true, and false otherwise. \nLet MARK be a data base tree consisting of a single node whose field values are . Let ARG be the string \nh ,T,~ 3,4(h , T,c,G) . T%en # (h, T,c,G) = (GRAFT(~ 12(h ,T,c,G), # (ARC)), # 2,3,4 (ARG)), if TE.ST(VALUE(~ \n3 (h , T,c,G),f),@,v); = (GRAFT(~1,2(h~, T,c,G),MARK), # 2,3,Jh >T,c,G)), otherwise. Form the tree for \nh . Test the condition. If true, graft on the tree for h . Otherwise, stop. Case 7: h is the query h \ncomp(i,j,@); h , and h is straight-line, and h and h are rootless. Let ARG be the same string used in \ncase 6. Then ~ (h,T,c,G) = (GRAFT(~ ,,2(h ,T,c, G),# (ARG)), + 2,3,4(ARG)), if TEST(~ 4(h ,T,c,G) (i) \n,@,~ 4(h ,T,c,G) (j)); = (GRAFT(~1,2(h , T,c,G),MARK), otherwise4 2 3,4 (h T,c,G)), Form the tree for \nh . Test the condition. If true, graft on the tree for h . Otherwise, stop. Case 8: h is the query h \nIoop;h , and h is straight\u00adline, and h is rootless. Let ARG = h , T,c,G . The base case is LOOP(h ,h \n,T,c,G, 1) = (GRAFT(# 1,2(h , T,c,G),~l (ARG)), ~2,3,.4(ARG)).  Let NEXT(n) be the next sibling of node \nn, with some appropriate value for the last sibling. Let ARG be the string h , h , T,c,G,n l . The inductive \npart of the definition is, for n > 1, LOOP(h ,h ,T,c, G,n) = (GRAlW(LOOP1,2(ARG), I/l (h, T,NExT(LooP3(ARG) \n), LooP4(ARG))), LOOP2(ARG) ,NEXT(LOOP3(ARG) ), LOOP4(ARG)) Let #SIB(n,T) be the number of siblings \nof node n in T. Then ~(h,T,c,G) = LOOP(h ,h ,T,c,G, #SIB(/3(h ,T,c, G),T)).  The semantics of loop are \nas difficult to define as those of similar control structures in any language. We give an inductive definition \nof a semantic routine LOOP. It guides the construction of a forest of trees, one for each iteration through \nthe loop. These are grafted at the appropriate position in the previously constructed tree. Case 9: h \nis covered by none of the previous oases. ~(h,T,c,G) = (@, l,c,G). This is the end of the definition \nof ~ . Let PRUNE(T) be a data base tree derived from T as follows: replace every node in T all of whose \nchild nodes contain only the value a with a node having only values of a; then remove from the tree all \nsubtrees whose root node contains any value a. Let #(h,T) = PRUNE(~l(h,T,VROOT(T), G@)). 4. THE TRANSLATION \nFUNCTIONS 4,1 The Encoding Function b The data translation from trees in H to relations in R is defined \nby an encoding function 6: H -+ R. Given a tree T in H, let 6(T) = { t (n) IJ t (n) I where n is a leaf \nnode in T and t (n) is the set of all field (name, value) pairs appearing on the nodes encountered on \nthe path from the root of T to n and t (n) is the set of all pairs (field name, NA) where the field name \ndoes not occur in t (n) but occurs in T}. That 8(T) is a member of R follows from the proof of correctness \nof our translation. 4.2 The Translation Function T We describe a translation function, -y, which is implemented \nin the HISEL system by an L-attributed translation grammar [5] from queries in HISEL to command sequences \nin the target language HI. Appendix A contains the attributed grammar. Some preliminary definitions are \nnecessary to define T. Let T be a database tree. Recall that the schema of T, T,, is the hierarchy of \nnode-types of T. That is, T, is derived from T by replacing every node by its type and coalescing siblings \nof the same type. For a field name F in T, PATH(F,T) is the sequence of HI commands down(il);loop; ....down(ik). \nloop; where i~,...,ik is the sequence specifying the path from the root node to the node containing F. \nLet h,h t HI. We designate by NAV(h) the sequence of navigational commands in h. If NAV(h) is a prefix \nof NAV(h ) or vice versa, then h + h is the string of HI commands obtained by inserting the non\u00adnavigational \ncommands into their appropriate places in the longer of NAV(h) and NAV(h ). We denote by COMN(X,q,T) \nthe longest substring of ~(q,T) (defined later) of the form Ioop;h;h ;up; where h has no occurrences \nof up and every field name in h begins X and h is a sequence of up s. If F is a field of depth n in T, \nUPS(F,T) is the n-long string of commands up;...; up; . Finally, for h c HI and strings of commands S1 \nand S2, denote by REPLACE(h,s1,s2) the result of replacing the first occurrence ofs] in h by S2. Suppose \nthat T c H and q c HISEL is of the form select S where Q where S is X1.F1, . . . , Xn. Fnn and Q is a \nquery condition, then we define -y(q,T) by induction on the structure of q. Note that the Fi s are names \nof fields in T. Concatenation of strings is implicit throughout the following. Case O: S is empty and \nQ is empty. Y(q,T) = root; Case 1: Q is empty but S is not. Let S = X1.F1, . . , , X. l .Fn_l n and \nq = select S where Q . Then, by induction, -y(q ,T) is defined. There are two subcases. (i) Xn does not \noccur in S . Then ~(q,T) = ~(q ,T) ;PATH(Xn.Fn,T) extract( Xn.Fn , Fn)UpS(Xn.Fn,T) (ii) Xn occurs in \nS . Then COMN(Xn,q ,T) occurs in ~(q ,T). -y(q,T) = REPLACE(Y(q ,T) ,COMN(Xn>q >T) , COMN(Xn,q ,T)+[pATH(%F. \n>T) extract ( Xfl.Fn ,FJ ;ups(xn.Fn!T) J ) Case 2: Neither S nor Q is empty. Throughout this case i \nand j name unique locations in G. There are four subcases. (i) Q is of the form X.F @ C or C @ X. F . \nWithout loss of generality we consider only the first alternative. Let q = select S where @ , then, by \ninductive definition, ~(q ,T) is defined. If X occurs in -y(q ,T), then y(q,T) = REPLACE(T(q ,T) ,COMN(X,q \n,T) , COMN(X,q ,T) +[PATH(X. F,T) cond(X.F,C,@);UPS( X. F,T)]) If X does not occur in ~(q ,T), then \n-y(q,T) = 7(q ,T)PATH(X. F,T) cond(X.F,C, @); Ups(X.F,T) q is as in case 2(i). Without (ii) Q is X.F \n@ X .F . loss of generality, we assume COMN(X,q ,T) precedes COMN(X ,q ,T) in ~(q ,T) if both OKUr and \nCOMN(X,q ,T) occurs if only one does. If X and X both occur in S, then Y(q,T) = REPLACE(REPLACE( y(q \n,T) ,COMN(X,q ,T) > COMN(X,q ,T) +[PATH(X.F,T)temp(i, X. F); Ups(X.F,T)]), COMN(X ,q ,T),COMN(X ,q ,T) \n+[PATH(X .F ,T) temp(j,X .)comp( i,j,@); ); UPS(X.F ,T)])) If X occurs in S but X does not, then -Aq, \nV = REPLACE(7(q ,T) PATH(X .F ,T)temp(j, X .);); comp(i,j, @) ;UPS(X .F ,T), COMN(X,q ,T) ! COMN(X,q \n,T) +[PATH(X.F,T)temp(i, X. F); Ups(X.F,T)l) If neither X nor X occur, then ~(q,T) = 7(q ,T)PATH(X. F, \nT)temp(i,X.F); UPS(X.F,T)PATH(X . F ,T)tempG,X .);); comp(i,j, @); Ups(X .F ,T) (iii) Q is Ql A Q2 , \nwhere Q2 is atomic, and S is not empty. Let ql = select S where Ql . Then if Q2 = X.F @ C or C @ X. F \n, ~(q,T) is defined as in case 2(i) with ql replacing q . But if Q2 = X.F @ X .F , ~(q,T) is defined \nas in case 2(ii) with ql replacing q . (iv) Q is Ql V Q2 , where Qz is atomic, and S iS not empty. Let \nql be as in case 2(iii). Then If Q2 = X.F 0 C (Q2 = C @ X.F is similar), then T(q,T) = ~(ql ,T)root;PATH(X. \nF,T) cond(X.F,C, O); UPS(X.F,T) If Q2 = X.F @ X .F , then -r(q,T) = ~(ql,T)root;PATH( X.F,T) temp(i,X.F);UPS( \nX.F,T) PATH(X,F,T)temp(j,X. F ); comp(i,j, @); UPS(X .F ,T) This definition of the translation function \nY is realized by a small L-attributed grammar presented in Appendix A.  5. CORRECTNESS OF THE TRANSLATION \n The main result of the paper is the proof that T, the translation function from HISEL to HI, is correct. \nWe do this by showing that the diagram in Fig. 2 commutes. Of course this only establishes what we call \nthe abstract correctness of the HISEL system. Two additional results not given in this paper are necessary \nto establish the concrete correctness of the HISEL system. They are Claim 1: The attributed grammar for \nHISEL implements Y. and Claim 2: The HI interpreter correctly implements the evaluation function $. \nGiven the truth of these two claims and the main theorem of this paper, HISEL is correct. It may appear \nthat either claim is difficult to establish; however, it may be noted that the attributed grammar for \nthe HISEL translation is small. Furthermore, its semantic routines are regular and well-understood tree-building \nand tree\u00ad traversal routines. If T, T c H then T * T is the GRAFT of T onto each of the leaf nodes of \nT. Notice that since tuples are sets of unique pairs, the eartesian product of relations, denoted R X \nR , is achieved with componentwise union. Also, because the HI interpreter is a simple command interpreter, \nwe are confident that it realizes the semantic function ~. It is nonetheless true that we choose to allow \nour confidence in the faithfulness of the implementation to the ideal to stand in place of a proof of \neither claim. Some notational conventions and definitions will ease the statement of necessary lemmas \nand the main result. Let q c HISEL be of the form select S where Q and let T ~ H be possible for q. If \nXl, . . . . Xk are the cursors of S, then SXj, 1Sj<k, denotes the sequence of select terms involving \nXj in increasing order of field depth in T. The following lemma states the obvious about the structure \nof HLSEL queries translated by ~. Lemma-~: If q and T are as described above, then -y(q,T) is of the \nform root ;COMN(X1 ,q,T) . . . COMN(Xn,q,T) Proof By induction on the structure of q. Case O: S and Q \nare empty. In this case, ~(q,T) = root; . Case 1: Q is empty but S is not. If S = S ;X.F , then let \nq be q with S replaced by S . If X occurs in S , then T(q ,T) is defined and, by the inductive hypothesis, \nsatisfies the lemma. The definition of T assures us that y(q,T) is ~(q ,T) with COMN(X,q,T) replaced \nCOMN(X,q,T) + [PATH(F) extract( X.F ,F) ;Ups(F,T~~. On the other hand, if X is not in S , ~(q,T) is -y(q \n,T) with PATH(F) extract( X.F ,F); UPS(F,T) inserted. So T(q,T) is of the desired form. Case 2: S and \nQ are non-empty. Let q be q with Q replaced by the empty condition. By hypothesis, T(q ,T) is defined \nand satisfies the lemma. There are four sub-cases. (i) If Q is of the form X,F @C or C @ X,F and X.F \noccurs in S, then ~(q,T) is -y(q ,T) with a single term comp(X.F,C,,@) inserted before the occurrence \nof extract( X.F , F). If X.F is not in S but X occurs in S, then ~(q ,T), by hypothesis, satisfies the \nlemma, and, by the definition of T, T(q,T) is obtained by replacing COMN(X,q,T) by COMN(X,q,T) + [PATH(F) \n;comp(X.F,C,@);UPS( F,T);ln. If X does not occur in S, PATH(F) ;comp(X.F,C,@) ;UPS(F,T) ; is appropriately \ninserted into T(q ,T) to obtain ~(q,T). Thus, -y(q,T) satisfies the lemma. (ii) If Q is of the form X.F \n@ X ,F , then if X,F (or X .F ) does not occur in S, -y(q,T) is obtained by inserting PATH(F)n (or PATH(F \n) , augmented by the appropriate temp and comp, into ~(q ,T). If X.F (or X. F ) occurs in S, then -y(q,T) \nis obtained by +\u00ad  concatenating PATH(F) (or PATH(F )), again augmented by the appropriate temp and \ncomp commands, with COMN(X) (or COMN(X )) in ~(q ,T). In any of these cases, ~(q,T) satisfies the lemma. \n(iii) If Q is Ql A Q2 and ql is select S where Ql and q is select S where @n, then, by hypothesis, ~(ql \n,T) and T(q ,T) are defined and satisfy the lemma. W~thout loss of generality, we may assume Q2 to be \n atomic. Then Qz is of the form X. F @ C or C @ X.F X/. F/ or X.F 0 . If COMN(X,ql ,T) (or COMN(X ,ql \n,T)) does not occur in T(ql ,T) then PATH(F) (or PATH(F )), again appropriate ely augmented by cond, \ncomp and temp commands, are inserted into -y(ql ,T) to obtain ~(q,T). If COMN(X,q ,T) (or COMN(X ,q ,T)) \ndoes occur in T(ql,T), then T(q,T) is the +-concatenation of the augmented PATH expressions to COMN(X,q \n,T) (or COMN(X ,q ,T)) in 7(%>V. (iv) If Q is Ql V Q2 and q, = select S where Ql and q2 = select S where \nQ2 , then r(q,T) = ~(ql,T)~(q2,T) Then, since, by hypothesis, T(ql ,T) and T(q2,T) both satisfy the lemma, \n~(q,T) does also. Lemma-#: If h e HI and h is of the form root; hlUPS(hl ,T) ... hnUPS(hn,T) where the \nhi have no occurrences of UP , then ~(T,h) = ~(root,T) * ~(hl,T) * ... * ~(hn,T). Proof By induction \non the structure of h. If h = root; , then the hi are empty and the lemma holds. Ifh= h ;hnUPS(hn,T) \nand h = root; hlUPS(hl,T) ... hn lUPS(hn-l,T) , then, by the inductive hypothesis, #(h ,T) is defined \nand satisfies the lemma. But, by the definition of * and the definition of t! ~(h,T) = ~(h ,T) * #/( \nhnUPS(hn) ,T) and the lemma is proved. The main theorem may now be proved. Theorem: Let q c HISEL and \nT e H be a possible tree for q, then @(q>6(T)) = 6( W-Aq,T),T)) Proof The proof is by induction on the \nstructure of q. Recall that q is of the form select S where Q , T is possible for q, and as before, S \nis of the form SX1 ...SXn. Case O: S and Q are empty. Then #(q,6(T)) = @ = 6(4(~(q,T),T)) Case 1: Q \nis empty but S is not. Let qj = select SXj where @ for 1SjSn, By the definition of@: d(q,6(T)) = {{ \n(X~.F~, val(t~(F~ ))) ,..., (Xn.Fn, val(t (Fn))) } I for 1<j<n, ~ e 6(T) and if Xj=Xk, then tj=tk ]. \nThus @(q,6(T)) = @(q1,6(T))) X ... X @(q.> NT)). BY the definition of T and lemma-~, ~(q,T) is of the \nform root; COMN(X1 ,q,T) ... COMN(Xn,q,T) Thus ~(q,T) meets the conditions of lemma-~ and t(~(q,T),T) \n= ~(ROOT,T) * ~(COMN(X1,q,T),T) * ... * #(COMN(Xn:q,T),T). A branch in 6(~(COMN(Xj,q,T), T)) contains \nthe extracted field (name, value) pairs { (Xj.Fj,Vj)l Vj ~ DOM(Fj) U { NA } and extract( Xj.Fj , Fj) \nis in COMN(Xj,q,T) }. Thus 6(#(T,7(q,T))) is formed by making up tuples {{tl,...,tn } I tj E ~(t(T,COMN(Xj,q, \nT))) ]. But this is precisely as if 6(~(~(q,T),T)) = 6(~(COMN(X1,q,T) ,T))X...X6(#(COMN(Xn,q,T) ,T)) \nSince @(qj,6(T)) describes a selection of pairs from individual rows of 6(T) for fields of Xj ,and 8(~(T,COMN(Xj,q, \nT))) is the set of pairs from individual branches of T for fields of Xj ,and 8 translates branches of \nT uniquely to tuples of 6(T), it follows that @(qj,~(T)) = 6(#(COMN(Xj,Y(q,T),T),T)) for 1=j=n. Thus \n@(q>~(T)) = d(ql,J(T)) X ... X d(qn,6(T)) = 8(~(COMN(X1,y(q,T),T),T)) X ... X 6(~(COMN(Xn,T(q,T),T),T)) \n= 6(~(T(q,T),T)) Case 2: Q = Ql A Q2 where Q2 is atomic. Let ql be select S where Ql . Then, by hypothesis, \no(ql,~ (T)) = J(r(T(ql,T),T)) IfQ2= X.F @C orQ2= C @X.F orQ2= X.F @ X .F then if X.F (or X .F ) occurs \nin S, @(q,~(T)) = { tlt c @(ql,6(T)) and t 1= Q2 } ~(q,T) is obtained from T(ql ,T) by adding the appropriate \nCosld, comp or temp commands to COMN(X,q,T) (or COMN(X ,qjT)). If COMN(X,q,T) (or COMN(X ,q,T)) does \nnot occur, PATH(X.F)cond(X. F, C,@) (or PATH(X .F ) ; temp(X .F ,C,@) or PATH(X.F ); temp(i,X. F ); comp(i,j, \n@); , etc.) is added. In either case, ~(T,6(q,T)) is obtained by eliminating branches in ~(T,~(ql ,T)) \nwhich do not satisfy the added cond condition, thus ti(~(T(q,T),T)) = { t I t e 6(#(T(q1,T),T)) and t \n~ Q2 ] Therefore, 6(*(T q, T),T)) = 6(~(~(q1,T),T)) (_) { t \\ t is a tuple and t ~ Q2 ] = 4(ql,~(T)) \nn { tlt is a tuple and t 1= Qz ] = dXq,6(T)). The argument is similar to case 2 with temp and comp commands \nand the necessary PATH expressions added to COMN(X,q,T) or COMN(X ,q,T) as needed. Case 3:Q = Ql VQ2 \n Let ql = select S where Ql and qz = select S where Q2 . By the definition of ~ @(q, J(T)) = @(q], ~(T)) \nu O(qz,~(T)) = 6(~(~(q1,T),T)) U 3(~(T(q2,T),T)). By the definition of y, T(q,T) = T(ql ,T)T(qz.T) so \n~(-y(q,T),T) = #( T(q1)T(q2,T) ,T) and, as T(q2,T) begins root , *(T(ql>T)~(qz,T),T) = GRAFT(t#(y(ql \n,T),T) , ROOT(~(T(ql,T), T)),~(T(q2,T),T)). Therefore, O(#(T(q,T),T)) = 6( GRAFT(#(T(ql,T), T), ROOT(#(~(ql,T),T) \n),#(~(q2,T),T)) = 6(~(T,-y(ql,T))) U 6(~(T,~(q2,T))). This proves the theorem. The chain of reasoning \nmay now be summarized as follows. Since any arrangement of lexical units in HI is a query, if q c HISEL \nand T c H, then -y(q,T) c HI. Also if T cH and h cHI, then ~(h,T) cH. If T cH, then, by a straightforward \nflattening of a database tree into a table, 8(T) c R. The definitions of @ and T yield that if q c HISEL, \nthen q5(q,6(T)) c R. Finally, @(q,T) and 5(~(T(q,T) ,T)) are the same relations in R. For a tuple produced \nby &#38;(#(T(q) ,T),T), induction on the structure of the HI program shows that the evaluation of the \nHISEL query produces the same tuple. That is, for a tuple t, t c @(q,6(T)) if t ~ ?i(~(-y(q,T),T)). These \nresults establish formally correct and intuitively adequate semantic relationships between HISEL and \nits semantic domain and HI and its semantic domain. 6. CONCLUSION In this paper, we have defined the \nformal semantics of a database query language HISEL and of a hierarchical query language HI in a fashion \nsimilar to that of denotational semantics of programming languages. An L-attributed translation grammar \nis given to describe a translation system from HISEL to HI. The correctness of this translation is then \nproved by establishing the commutativity of the diagram in Fig. 2. A practical version of this translation \nsystem has been built and is in use. We believe that this systematic analysis will increase the understanding \nof translations between query languages with different models and may help in building translator-generators \nfor database systems similar to parser-generators such as YACC [4] and compiler\u00adgenerators such as PERLUETTE \n[3]. Considering the many tailor-made user interfaces built on database systems, such interface (translator) \n-generators will be v~ry helpful. REFERENCES [11 Donahue, J. E.: Locations Considered Unnecessary, Acts \nInformatica, vol. 8, pp. 221-242, 1977. [2] Gansner,E. J. R.Horgan, C. M.R.Kintala, D.J.Moore, P.Surko: \nRelational Queries on Hierarchical Data -an Experiment, Bell Labs internal memorandum, 1981. [3] Gaudel,M.C.: \nSpecification of Compilers as Abstract Data Type Representations, Workshop on Semantics\u00addirected Compiler \nGeneration, pp. 140-164, 1980. [4] Johnson, S. C.: YACC -Yet Another ComPiler-Compiler, Bell Labs internal \nmemorandum, 1978. [5] Lewis, P.M., D. J. Rosenkrantz and R. E. Stearns: Attributed Translations, Jour. \nof Comp. and Syst. Sci., vol. 9, pp. 279-307, 1974. [6] Lien, Y. E.: Hierarchical Schemata for Relational \nDatabases, ACM Trans. on Database Systems, vol. 6, no. 1, pp. 48-69, 1981. [7] Morris, F. L.: Advice \non Structuring Compilers and proving Them Correct, Proc, of ACM Symp. on Principles of Prog. Languages, \npp. 144-152, 1973. [8] Mosses, P.: A Constructive Approach to Compiler Correctness, Workshop on Semantics-Directed \nCompiler Generation, pp. 189-210, 1980. [9] Shu,N., B. Housel, R. Taylor, S. Ghosh, V.Lum: EXPRESS -A \nData Extraction, Processing and REMructuring System, ACM Trans. on Database Systems, vol. 2, pp. 134-174, \n1977. [10] Tennent,R.D.: Language Design Methods Based on Semantic Principles, Acts Informatica, vol. \n8, pp. 97-112, 1977. [111 Thatcher,J.W., E. G.Wagner, J.B.Wright: More Advice on Structuring Compilers \nand Proving them Correct, Workshop on Semantics-directed Compiler Generation, pp. 165-187, 1980. APPENDIX \nA 1 Production 1 / Following Lewis, Rosenkrantz and Stearns [LRS], we describe an L-attributed translation \ngrammar G to construct T defined above. The LL(k) input grammar for Gr is HISEL and the target language \nis the set of proper command sequences in HI. In the grammar G, A stands for a global attribute array \nA[O:4] of pointers pointing to a field table, a cursor table, a navigation forest an error flag and a \ntemporary-variable table. An illustration of this global environment follows: AIO] RR I A[l]. A[2] Cursor-Table \nNavigation Forest cursor tree name x *Y A navigation tree is a set of nodes of the following structure: \nFig. 3 G contains 9 productions. Subscripts on nonterminals, terminals and action symbols denote attributes. \nLower ease. letters a,b,...,h denote inherited attributes while letters p,q,...,w denote synthesized \nattributes. Terminal attributes are denoted by x,y and z. The list of productions now follows: QUERYA \n+ SekCt L~Ta,b,~,t,A where CONDSC ~ ~ , ~ * <OUTPUT>P .,, ,,, { i*Rules for computing the attribute \nvalues in 1*I a-A[l]; b-A[2]; c-s; d-t; e-A[4]; Perform Traverse(IN:a,u,A; OUT:p); p is as determined \nby the Traverse routine. 1 The inherited attribute a is assigned the first location available in the \ncursor table for the first cursor generated from the nonterminal LIST. The synthesized attribute s denotes \nnext available location in the cursor table after entries have been made in that table for all the cursors \ngenerated from LIST. The pair of attributes (b,t) correspondingly denotes such a (first, next) pair of \nlocations for the tree paths to be planted in the navigation forest representing the database fields \ngenerated from LIST. The synthesized values s,t are then respectively assigned to c,d of the nonterminal \nCONDS. The pair (c,u) is the (first, next) pair of locations in the cursor table for the cursors generated \nfrom CONDS. The pair (d,v) is the (first, next) pair of locations in the navigation forest for trees \nrepresenting the database fields generated from CONDS. The pair (e,w) is the (first, next) pair of temporary \nlocations available to the target query. Recall the global environment A as depicted in figure 1. AIO] \nis a pointer to the field-table initialized for the given database. A[l ] is a pointer to the cursor-table \nwhich is initially empty, A[2] is a pointer to the navigation forest -which is initially empty. In the \nabove program text, first a and b are computed as specified. Then the nonterminal LIST is expanded recursively \nreturning the values for s and t and new values for A. These are then used to compute c,d and e. Then \nthe nonterminal CONDS is expanded recursively returning values for U,V and w and new values for A. The \nresulting values for A and v are then used to perform the Traversal procedure. The idea behind the above \nproduction is this: first the cursors and the tree-paths corresponding to the fields generated from the \nnonterminal LIST are planted in the cursor table and the navigation forest respectively. These trees \nare then labeled and/or grafted as required by conditions generated from the nonterminal CONDS. All the \ntrees in the navigation forest are traversed at the end to produce a string of target commands. A pointer \nto this string is then provided to the action symbol OUTPUT. / Production 2 / BTa,b,s,t,A ~ lELDa,b,p,q,r,u,A \n> ETf,g,v,w,A { /*Rules for 2 / Perform Label(IN:r,mkextr(u), u,A; OUT:A) f-p; g-q; s-v; t-w; } / Production \n3 / L~Tab,tA + 6 ,,>> { /*Rules for 3 / s+a; t-b; 1 / Production 4 / Cursrx . FldY lELDa,b,p,q,r,u,A \n\u00ad { /*Rules for 4 / x-nextokego; y+nextokeno; Perform Install(IN:x,a, y,b,A; OUT: V, W, A); p+v; q+w; \nr+x; u~y; } / Production 5 / cONDsabcstu,,, ,,, A + cONDa,b,c,p,q,r,A J cONDsd !,,!,e fs t u,A { /*Rules \nfor 5 / d+-p; e-q; f+r; ) / Production 6 / c cONDsabcstu,,, !>, A + { /*Rules for 6 / s+a; teb; u~c; \n1 / Production 7 / COND + a,b,c,p,q,r, A lELDa,b,p,q,u,v,A Opy ConstZ { /*Rules for 7* I y-nextoken(j; \nz-nextokeno; Perform Label(IN:u,mkcond( v,y,z),v,A; OUT: A). r-c; 1 / Production 8 / + ConstZ OpY FIELDa,b,p,q,u,v,A \n cONDa,b,c,p,q,r,A { /*Rules for 8 / rtc; z+nextokeno; y+nextokeno; Perform Label(IN:u,mkcond(z,y, v),v,A; \nOUT:A). 1 / Production 9 / FIIXIla,b,Pr,q , u,v,A OPYcONDa,b,c,p,q,r,A \u00adFIELDa ,b/,P,q, u ,v/,A { /*Rules \nfor 9 / y-nextokeno; r-next (next(c)); a +p ; b tq ; Perform Label(IN:u,mktemp(v,getname(c)),v,A; OUT: \nA); Perform Label(IN:u , mktemp(v ,getname( next(c) )),v ,A; OUT: A); Perform Label(IN:u , mkcomp(c,getname( \nnext(c)),y) ,v ,A; OUT: A); Perform Combine(IN:u,u ,A; OUT: A). } Descriptions of the procedures used \nin the above productions and further details discussions on this grammar are available in [21 . The actual \nG for the practical version of HISEL is more elaborate incorporating some code optimization.  \n\t\t\t", "proc_id": "582153", "abstract": "This paper proves the correctness of a translation from HISEL, a relational database query language, to HI, a hierarchical query language.The four components of Morris' [7] program are established. Appropriate semantics for the two languages are defined. A translation function is defined and an L-attributed grammar capturing the translation function is exhibited. The transformation of database trees into database relations is specified.", "authors": [{"name": "E. Gansner", "author_profile_id": "81100458792", "affiliation": "Bell Laboratories, Murray Hill, New Jersey", "person_id": "PP14160908", "email_address": "", "orcid_id": ""}, {"name": "J. R. Horgan", "author_profile_id": "81100641649", "affiliation": "Bell Laboratories, Murray Hill, New Jersey", "person_id": "PP43122279", "email_address": "", "orcid_id": ""}, {"name": "C. M. R. Kintala", "author_profile_id": "81100120098", "affiliation": "Bell Laboratories, Murray Hill, New Jersey", "person_id": "P37107", "email_address": "", "orcid_id": ""}, {"name": "D. J. Moore", "author_profile_id": "81100042485", "affiliation": "Bell Laboratories, Murray Hill, New Jersey", "person_id": "PP14026691", "email_address": "", "orcid_id": ""}, {"name": "P. Surko", "author_profile_id": "81100111232", "affiliation": "Bell Laboratories, Murray Hill, New Jersey", "person_id": "P396957", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/582153.582184", "year": "1982", "article_id": "582184", "conference": "POPL", "title": "Semantics and correctness of a query language translation: (preliminary version)", "url": "http://dl.acm.org/citation.cfm?id=582184"}