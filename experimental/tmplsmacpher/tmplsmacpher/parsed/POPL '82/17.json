{"article_publication_date": "01-25-1982", "fulltext": "\n Maple: A Programming Language and Operating System. P. J. Voda Department of Computing Science, University \nof Alberta, Edmonton, Canada T6G 2H1. Abstract. Maple is a statically typed language system, with very \ngeneral generic facilities. It incorporates its own pro\u00adgramming environment and provides parallel processing \nwith synchronization. the direct outgrowth tion facility. a new The of method synchroits nization data \nof process is abstrac\u00ad 1. Introduction. The integrated language system Maple is an attempt to combine \nan operating system with a programming language. The tradi\u00adtional objects of operating systems such as \nprograms and files are simply Maple functions and variables. By combining an operating system with a \nprogramming language into one unit one automatically obtains the programming environment sup port system \n(APSE of Ada [81). The Maple system -used to be tentatively called H03 system -is the result of five \nyears of design effort as direct continua\u00ad tion of the author s previous language system BPS [12] which \nconsisted of a modu\u00ad lar language and its environment but did not contain parameterized modules (generic \nconstructs), a necessity in modern pro gramming. Maple system consists of the Maple pro\u00ad gramming language, \nthe Maple tree, and Maple editor. The Maple tree is a struc ture expressed in the Maple language resembling \nthe file hierarchy of Unix [9]. The Maple editor is for entering, modifying and executing Maple expressions \nwhich are part of the Maple tree. The paper covers the Maple language which has two forms: strict and \nextended. Both Permission to copy without fee all or part of this material is granted provided that the \ncopies are not made or distributed for direct commercial advantage, the ACM copyright notice and the \ntitle of the publication and its date appear, and notice is given that copying is by permission of the \nAssociation for Computing Machinery. To copy otherwise, or to republish, requires a fee and/or specific \npermission. @ 1982 ACM 0-89791-065-6/82/001/0157 $00.75 forms are described in a 32 page defining document \na~J3]. The strict language is minimal contains only three data structuring constructs (groups, sorts, \nand records) and six clauses.. The clauses are: declaration clauses (use), parallel clauses (par), conditional \nclau$ies (case), selection clauses, and two exception han\u00addling clauses: fail to cause the evalua\u00adtion \nto fail, and attempt to recover from a failure. The extended form is defined as a set of abbreviations \nof the strict language which introduces the programming comfort needed in practice. Maple is a fully \ntyped language. The language, however, does not contain any traditional primitive types other than records. \nAll other types are merely part of the initial setting of the Maple tree. 2. Generic constructs and type \nchecking. The term generic usually applies to such objects (functions or packages) which are parameterized \nby a type. In Ada generic objects are obtained by special primitive constructs whose syntax is similar \nto function abstraction but have different semantics. Such generic objects are essentially compile time \nmacros. The rea\u00adson for this is that types in Ada are not values which may be passed to and/or yielded \nby functions. Since Ada adopts traditional type checking of the Pascal [16] style, types as arguments \nand results would violate static type checking. Static type checking requires that the types of objects \ncan be always derived, in finite time, during the compilation. When non-standard type checking, such \nas used in the programming language Russell [3], is applied to the framework of Pascal (as sketched in \n[14]) then types can be allowed as arguments and results. Generic constructs are obtained through the \nnormal mechanism of function abstraction with no need for new semantic primitives. Static type checking \nis done purely by the inspection of the structure (i.e. the text) of programs. The essence of such non-standard \ntype checking is to allow dependencies among types. This can be illustrated with a Pascal-like example \nof flexible arrays. Consider the following functions: procedure max(n: integer; a: array[l .On] of integer \n); ... function create(n: integer): array[ 1 ..n] of integer; ... Function max exhibits a dependency \namong the types of its arguments. There is a dependency between the argument and the result type in the \nfunction create. This substi\u00adis resolved by performing textual tutions for the dependent objects. The \nfunction invocation max(7,b) is valid iff the type of the array b is array[l ..7] of integer . The actual \nargument n is sub\u00ad stituted without any evaluation in the type of the formal argument a. If the invocation \nmax(7rb) is legal then the invocation max(c+3,b) is illegal since the type of b cannot be array[l ..C+3] \nof integer at the same time. The invocation create(c) yields an object of the type integer . The textual \narray[l. .c] of substitution without evaluation makes the type checking intentional since the type of \nthe invocation create(8) (array[l ..8] of integer) will be different from the type of create(c) even \nif the value of c is known to be 8. The standard type checking of Pascal requires that the type of the \nactual argu\u00adment to a function is the same as the type of the formal argument. The non-standard type \nchecking of Maple, which will be called substitutional, relaxes this condi\u00ad tion. The type of the actual \nargument must be covered by the type of the formal argument (after substitutions) . Type covering is \nan ordering relation on the types of Maple. Maple is an expression language, and therefore, the result \nof a function invocation is the result of the evaluation of its body after the arguments have been bound. \nHere again, the type of the body must be covered by the type of the function result. Each expression \nin Maple has a unique, static, type. The possible types are classified as element, group and sort types. \nElements, i.e. the expressions having element types, are introduced by classes with the help of sorts. \nSorts are constructs which turn types into values (see section 5). Groupsr which are values of a group \ntype, are discussed in the next section. 3. Groups. Groups are Maple values constructed from elements \nand sorts. For instance [size: 6; sq with int: argxarg; limit: sq(8); 1 is a group with 3 fields. The \nfields size and limit are called proper fields whereas the the field Sq is a function field. Fields of \na group are enclosed in the brackets [ and ] . Assume that the name of the above group is n . The field \nselection n.size denotes the constant 6. The field sq is selected by function selections (function invoca\u00ad \ntions), for instance by n.sq(5). A func\u00ad tion is thus invoked by selecting a func\u00ad tion field and supplying \nit with a value of the appropriate type as the actual argument. The result of nosq(5) obtained by evaluating \nthe function fie~~ (function body) arg*arg with the formal argument arg bound to the value 5. All functions \nhave exactly one argument called arg. This means that the parentheses around arguments in function selections \nare not necessary, for instance n.sq 5 . A chain of proper field selections is called a name. Thus n.limit \nand n.size are names. Both proper and function selections can be abbreviated, in non\u00adambiguous situations, \nby dropping the leading qualification . Thus n.size can be selected just by size . Field selec\u00adtion nolimit \n(or just limit) denotes the value which is obtained as the result of the function selection n.sq(8). \nThe strict syntax of a field is: selector {with type] is type : value When the type of a field (is type) \ncan be derived from its value then the type may be omitted. This is case with the fields in the group \nn. The group n with explicit types is: [size is int: 6; sq with int is int: argxarg; limit is int: sq(8); \n1 Each group value has a type which is obtained from the strict value by omitting the value part (: value) \nof each field. Thus n has the following group type: [size is int; s~:.with int is int; llmlt 1s int; \n1 The empty group, [], is a group with no fields; its type is again []. Groups may be used as field \nvalues. Similarly, the type of a formal argument can be a group type: The abbreviations used in the above \ngroup [addc with [x,y is [re,im is real]] is [re,im is real]: [x.re+y.re; x.im+y.im]; i: [re: 0.0; im: \n1.0]; cl: [re: 1.0; im: 0.01; a: addc[i; [6.0; 7.511; b: addc[cl; a]; c: addc[y: a; x: b]; 1 need some \nexplanation. For instance, the strict form of the field i is: i is [re is real; im is real]: [re is real: \n0.0; im is real: l.O1; Thus , i is a field having a group as its value. Types of both fields re and im \ncan be deduced to be real . And so, the type of field i is: [re is real; im is real] This can be abbreviated \nto [re,im is real] . Since this type can be derived from the field value it need not be speci\u00adfied explicitly. \nThe field addc is a function field with a group as the type of its argument. It is by the use of such \ngroup arguments that the effect of functions with several argu\u00adments is achieved. The function addc takes \ntwo complex numbers and delivers a complex number as its result; the two arguments are referred to as \narg.x and arg.y. The effect of addc is to add two complex numbers and return their sum as the result. \nNote that in the body of addc the leading qualification as in arg.x.re is dropped. Also note the omission \nof explicit field selectors re and ire . The selectors can be automatically inserted since the type of \nthe body is known to be a complex number. For the same reason, the actual arguments in the function selections \nused in the fields a and b (which are known, from con\u00adtext, to be pairs of complex number) can be given \nwithout selectors. On the other hand, the arguments in the function selec\u00adtion used in the field c can \nbe given in reversed order by specifying each argument field name. The above group with complex numbers \nis given in order to demonstrate the flexi bility of combining objects into larger units. It should also \nbe clear from this example that the abbreviations introduce a user-friendly syntax. Without these abbreviations \nmany redundant specifica\u00adtions would be necessary due to the simple syntax and semantics of groups. The \nabove example should not be taken as the recommended form of introduction of COmpleX numbers. Improved \nnotational con\u00advenience, type safety, and elegance can be obtained by introducing complex numbers as \nelements of a class (see section 5). Groups with function fields can be both function arguments and results. \nConse\u00adquently, it is possible for a function to yield a group which contains functions, i.e. a packager \nas its result. Likewise, functions can be parameterized by pack\u00adages: [combine with [a with int is int; \nb with int is int [Kab with i~~: a(arg); Bab with int: a(b(arg ); Baa with int: a(a(arg ); Bbb with int: \nb(b(arg ); 1; ..... 1 The function combine takes two functions The Maple tree group corresponds to the \nfile system of the operating system Unix. However, the significant difference is that the file hierarchy \nof Unix is a file system and thus belongs to the operating as arguments and yields a package of new functions \nwhich are combinations of the argument functions a and b. 4. Maple Tree. The most important group in \nMaple is the Maple tree. It can have, for instance, the following structure: [prog: [formatter with formtext \nis printfile: . . . . date with [1 is string: . . . . . . . . 1; standard: [order: rec[l<; l=; 1>1; precision: \nrec[lsingle Idouble Imany]; boolean: . . . . fixed with precision: . . . . int: fixed single; float with \nprecision: . . . . real: float single; char: . . . . array with [...1: . . . . seqwithsort[ ...]: . . \n. . string: seq(char); heap with []: . . . . . . . 1; nonstandard: [formtext: [type: sort[. ..l; . . \n. 1 ; . . . 1; user: [joe: [data is var formtext: . . . . projectA: [modl: . . . . . game with []: . \n. . . . . . 1; . . . 1; frank: [ . . . 1; . . . 1; 1 system. The Maple tree is a group directly accessible \nfrom the Maple language. A directory in Unix is simply a nested group in the Maple tree. A file of Unix \ncorresponds to a Maple variable element (see below), for instance .user.joe.data. A Unix program corresponds \nto a Maple function, for instance .prog.formatter. The correspondence of operating system objects (files, \nprograms) with objects of programming languages (variables, func\u00ad tions) has been known for some time. \nThere has been some effort to remove such dupli\u00ad cation by integrating the operating system with the \nprogramming language. Two of the best known attempts are Interlisp [11] and Smalltalk [4]. Unfortunately, \nboth systems are typeless. To the author s knowledge, Maple is the first design of an integrated system \nwithin the framework of static type check ing. The typing in such an environment not only enhances the \ncomprehension and secu rity of data structures and functions, but takes over the role of protection in \nthe operating system. For instance, the file .user.joe.data is of type formtext and therefore may be \nused only by such func\u00ad tions where formatted texts are accepted as arguments. The program formatter \nis such a function. The group . standard does not have a dual object in operating systems. It is simi\u00ad \nlar to the prelude of Algol-68 [15] and its descendants. The group standard con\u00ad tains the definition \nof standard classes ( types ) and generic functions ( type constructors ). The Maple tree is a combination \nof a file system and an Algol-68-like prelude. Note that the preludes of programming languages are not \nstructured (groups), they do not normally contain variable objects, nor can they be modified on-line \nby editors as is the case in Maple. 5. Classes. A group can be viewed as a loose way of combining objects \n(both data and func\u00ad tions). This is enhanced by the fact that groups need not be declared. The type \nof a group iS given either explicitly with every field or implicitly when the field type can be derived \nfrom the field value. Classes of Maple are used to define both storage and data structures. Their use \nis similar to the use of classes in Simula [11. Maple classes introduce: however, a large degree of type \nsecurity In the sense that the actual form of a storage or data structure is not directly accessible \nfrom outside of the class. Values introduced by classes in Simula are called class instances. In keeping \nwith the established meaning of the term class in logic, values from a class are called elements in Maple. \nA class of Maple is a group containing one or more sort fields. A sort is a slight extension of the type \nconstruct of Pascal. Sort serves the dual purpose of giving a name to a type and converting the type \nto a value so it can be used by generic func\u00adtions. Here is a class which implements the natural numbers \nwhich are perfect squares: [square: [type: sort[l as int; first is square.type: 1; next with square is \nsquare: arg+l; sqroot with square is int: arg; toint with square is int: arg*arg; 1: sql is square.type: \nfirst; sq4 : next next next first; .... 1 This example shows the simplest possible sort, the field \ntype of the class square is almost the same as if it were declared in the Pascal fashion: type square.type \n= int; The name square.type , when used as a type inside the group square, denotes the same type as int \n. However, from outside square.type is a type unto itself and is not known to be related to int . In \nfact, from the outside square.type is neither covered by nor covers any other type. Any expression which \nhas the type square.type (sql and sq4) is an element of the class square. Because of the uniqueness of \nsquare.type there is no way to know from outside of the class that elements of the type square.type are \nrepresented by integers which are their square roots (see the function sqroot). Until now the names (generally \nexpres\u00ad sions) which lead to sorts have been used to denote types in the so-called type positions (after \nwith or is). Sorts are, however, values and have types themselves. The name square.type , used as a value, \ndenotes a distinguished value of the type sort[ 1. It may be used, for instance, in the following generic \nidentity function: [id with [type is sort[]; el is arg.type 1 is arg.type: el; idfirst: id[square.type; \nfirst]; ... 1 The actual argument to id in the field idfirst has the type [type is sort[l; el is square.typel \nThe formal argument of id, after the sub\u00adstitution of the actual argument, is: [type is sort[l; el is \n[type: square.type; el: first ].type which, after the simplification, becomes [type is sort[l; el is \nsquare.typel. This type is identical to the type of the actual argument. Since type covering is a reflexive \nrelation, the invocation of id is legal. The type of the field idfirst is derived, by a similar substitution \nand simplification, to be the type square.type . In Pascal any name (i.e. any identifier) which denotes \na type (i.e. it is declared in the section type) can be used as a type. Similarly, in Maple, any name \nor expression which denotes a sort (has a type of a sort) may be used in type posi\u00adtions to denote types \nof elements. Note that a class may contain more than one sort. If it contains a sort with the field selector \ntype then the trailing type in selections can be dropped in the con\u00adtext where a sort is expected; the \nselec\u00ad tor type is automatically inserted. Therefore square.type used as a type may be abbreviated to \nsquare . The function .standard.fixed yieldsg~n~~~~s defining fixed point arith\u00admetic. It is used in \nthe definition of the class of single >recision integers .standard.int. The type of the class int is \ngiven here explicitly although it can be derived from the type of the function fixed (which is not given \nhere). ... int is [type is sort[:= with int is [] var; +,-, *, /, mod with int is int; ? with int is \norder; real is float(single); char is char 1; , abs with int is int; coerce with string is int new with \nint is var int; ]: fixed(single); ... The general form of a sort value is sort Sort-group as Element-type \nA sort group is a slight extension of a group. The value of a sort is, essen tially, the value of its \ngroup. Elements generated by a sort are of the element type given after the symbol as which is called \nthe implementation type. More specifically, assume that the expression t denotes a sort sort g as p . \nThen the type of t is sort gt where gt is the type of g. If an expression e is of the element type t \nthen the value of the expression e is of the type p. This fact is unknown from the outside of its class. \nFrom the outside of its class e looks as though it were of type gt. Thus only those field selectors in \ngt may be selected from e. The element denoted by int.coerce(5) (which can be abbreviated to int(5) or \neven to 5 if one works only with single precision integers) is of the element type int.type . Therefore \nIt looks as if it were a sort group from int.type. The function selection int.coerce(5).+ int.coerce(7) \nis again of the type int . The syntax of Maple is designed in such a way that the selection operator \n. can be omitted from function selections without introducing any ambiguity. The above selection may \nbe ,,5+711. abbreviated to The connection to the classes of Simula should be now obvi\u00ad ous. Integer element \n5 looks as if it con\u00ad tained a unary function + adding 5 to its argument. All fields of a sort group, \neven if they have the form of a proper field, are actu\u00ad ally function fields. Each function body can \nrefer to the special name elem which represents the value from which that field was selected. For instance, \nthe selection e.char, where e is of the type int , is evaluated by the evaluation of the func\u00ad tion field \nchar from the sort int with elem bound to e. The result is the char\u00ad acter corresponding to e. Similarly, \ne.*e (or simply e*e ) is evaluated by the evaluation of the function field * with elem bound to e and \narg bound to e . Classes are generally used for the intro\u00ad duction of storage structures. Storage structures, \nas opposed to data structures, can be modified. Elements of a type t can be either constant or variable \nele\u00ad ments. Constant elements are of type t whereas variable elements are of type var t . [va is int: \n9; vb is var int: int.new(5); vc is int: va+vb; 1 As usual the explicit field types are shown only for \nillustration since they can be automatically derived. The field va is a constant of type lnt (int.coerce(y)). \nField vb is an integer variable. The selection vb:=7 returns the empty record itne equivalent of void \nin Algol-68) but as a side effect it changes the value of the storage structure vb to 7. The fact that \nthe assignment field := has a side effect on its element (elem) is indicated by the qualifier var after \nthe type of the field := . All fields of a sort can be selected from variable element. However, any fields \n~ualified by var have side effects on ele\u00adments and, so, cannot be selected from constant elements. In \nother words, the constant element va looks like the sort group of int but without the field := . There \nis yet another difference between constants and variables which will be demonstrated with arrays below. \nThe type var t is covered by the type t for any sort expression t. As a conse\u00adquence the selection va+vb \nin the field vc is legal. The (second) argument of the sort field ,+ requires a constant but a variable \nvb may be given because its type is covered by the type int . Note that type covering in Maple makes \nthe implicit dereferencing coercion of Algol\u00ad68 superfluous. Similarly, there is no need for the explicit \ndereferencing opera\u00adtion ValueOf of Russell. Variable elements of Maple are a refinement of the Pascal \nphilosophy that variables and constants have the same types. In summing up, it should be said that the \nsorts in Maple are again a refinement of the type construct of Pascal, The essence of the refinement \nis that while the ele\u00adments generated by a sort are always of the implementation type, this fact is known \nonly within its class. Elements out\u00ad side of a class look as if they had the type of the sort group. \nSort groups in Maple effectively introduce infix and postfix operators on elements, 6. Arrays. Maple \nclasses are groups and can be values of functions. Functions yielding classes are typical examples of \ngenerics. A com parable construct in Pascal is the array constructor array[i] of t which is supplied \nwith an index and an element type to yield a new type. Array constructors are primitive constructs in \nPascal . Arrays in Maple are simply obtained by a generic function ... array with [size is int; et is \nsort[:= with et is [] var; ? with et is order 1; 1 is [type is sort[:= with type is [1 var; ? with type \nis order; coerce with int is var et; 1; new with [] is var type; 1: ... An array class can be obtained \nafter a generic instantiation in the field myarr (the actual sort et must have at least the operations \nof assignment and comparison): [up: 100; myarr is [type is sort[:= with type is [] var; ? with type is \norder; coerce with int is var int; 1; new with [] is var type; 1: array[up; intl; arrl is var myarr: \nmyarr.new[]; maximum with myarr is int: use [max: int.new(arg( l))] do for i:= 2to up if arg(i)>max then \nmax:= arg(i); end; max; end; 1 The explicit types of myarr and arrl are given just for illustration. \nThe reader might try to derive the type of the class myarr by performing the substitutions. On the other \nhand the type (of the result) of the function maximum must be given expli\u00adcitly to override the derived \ntype var int of its function body. The class myarr corresponds to the Pascal definition type myarr= array[l \n..100] of integer; The storage structure arrl is a normal array variable of the type var myarr . Note \nthat the name rmyarr.type or simply myarr (in type positions) denote the same type as type or even array[l \nOO;int]. type . The last type demonstrates the use of a sort expression as a type. A sort expression \nmay be used as a type only if it always evaluates to the same sort. In other words, it must be a pure \nexpression. Subscription on arrays is done by a selec tion like arrl.coerce(7) which yields an integer \nvariable. All integer operations (including the assignment) are available for the subscripted variable. \nThere is a certain degree of automatic coercion built into the extended Maple. Consider the selection \nb.s . The type of b must be a group (a sort group in case b is an element). If this group contains the \nselector s then the selection is per\u00adformed. Otherwise the group must have a field coerce and the selection \nb.coerce.s is performed (by inserting coerce). This is is not a coercion in the Algol-68 sense since \nonly one coercion at a time is considered without any back\u00adtracking. Using the automatic coercion the \nselection arrl.coerce(7) can be abbreviated to just arrl (7) leading to the usual style of working with \narrays. Function maximum requires a constant ele\u00adment of the type myarr . It has already been mentioned \nthat the sort group for constant elements is obtained from the sort group for variable elements by omit\u00ad \nting all fields which have a side effect on the element. In addition to that, all fields yielding a variable \nelement are changed into fields yielding constants. Thus constant elements cannot be modified. The sort \ngroup for the argument arg to maximum is: [? with myarr is order; coerce with int is int 1 The only \noperations which can be performed on a constant array are subscription (yielding an integer constant) \nand com\u00adparison for equality. 7. Records. Records in Maple are storage structures obtained by the record \nconstruct rec. A record construct yields a class for the construction and access of records with variants. \nIn the following example the explicit type is given, as usual, although it can be derived from the record \ncon\u00adstruct itself: [pair is [type is sort[:= with pair is [] var; ? with pair is order; hd is var int; \ntl is var real; 1; coerce with [hd is int; tl is real; 1 J is pair; new with [] is var pair; 1: rec[hd \nis int; tl is real]; mypair: pair[6; 3.14]; pairvar: pair.new[]; 1 The class pair corresponds to the \nPascal type type pair= record hd: integer; tl: real end In addition to Pascal-like records there is \na record constructor for pairs (as illustrated in the field mypair) which yields a constant pair. Note \nthat the sort group for constant pairs is: [? with pair is order; hd is int; tl is real 1 AS with arrays, \nthis makes the operations on records look conventional. In the opin\u00adion of the author the adherence to \naccepted standards of working with storage structures makes the classes of Maple very attractive. Russell \nprovides equivalent constructs but with a less satisfactory syntax. The records of Maple can have variants: \n[male is [type is sort[:= with male is [] var; ? with male is order; age is var int; Isingle; Imarried \nagewife is var int 1; single with int is Isingle male; married with [age,agewife is intl; is Imarried \nmale; new with [] is var male; 1: rec[age is int; Isingle; Imarried agewife is int 1; john: single; \npaul: married[31; 26]; steve: male.new[]; 1 The records of the type male have the field age in the fixed \npart and two variants with tags single and married . The married variant has an associated field agewife \n. Instead of having only a single constructor, the class male has two, one for each variant. The use \nof both is illustrated by the definition of fields john and paul. Sort groups with variants allow a finer \nform of typing. The type of john is lsingle male , whereas paul is a lmar\u00adried male . Both finer types \nare covered by the type male . The type male is actually the abbreviation for the type case Steve in \nlsinglelmarried male . Case clauses of Maple are used to discrim\u00ad inate on the variants of elements gen\u00ad \nerated by sorts with variants: I single .... .... ... Imarried .... steve.agewife:= steve.agewife+l; \nend The discriminant in a case clause must be an element having variants (not neces\u00adsarily a record). \nThe field agewife of steve can be accessed only if it can be statically proven that steve is married. \nRecords with variants do not need to have any fixed or variant fields: [t~~f~~~:;ght is sort[:= with \ntrafficlight is [] var; ? with trafficlight is order; Igreen; lamber; Ired; J; green is Igreen trafficlight; \namber is lamber trafficlight; red is Ired trafficlight; new with [] is var trafficlight; 1: rec[lgreen; \nIamber; Ired]; .... 1 Note that the three constructors green, amber and red are, in the absence of \nany fields, reduced to constants. Records without any fields are called enumerated records. The understanding \nof the enumerated types as records, not only requires one less primitive notion, but also solves the \nopen problem of Pascal and Ada: What happens if the same identifier is used in two different enumerated \ntypes? In Maple is the problem reduced to the simple problem of having an identical selector in two different \ngroups: [tl: rec[la; lb]; t2: rec[lc; la; Id]; usel: tl.a; use2: t2.a; 1 Now the class .standard.order \nas well as fields ? of the sorts given as examples can be explained: case vc ? Oin 1< ,,*; 1= .... 1> \n.... end The variable vc is compared to O and a Fortran-like three way decision is made. Note that the \nstandard use, say in Pas\u00adcal, of the six relational operators makes the three-way decision both less \nelegant and efficient. The class boolean (together with logical operators) is fully definable within \nthe language. As epected the implementation type for its sort is rec[ [false; Itrue].type. Relational \noperators, if statements, and while statements are defined only in extended Maple: case vc ?6in 1<1= \ntrue; 1> false; end can be abbreviated to vc<=6 . Whereas case bl in Itrue 51; 52; I false case b2 in \nItrue s3; s4; Ifalse s5; end end is abbreviated to if bl then s1; 52; elsif b2 then s3; s4; else S5 end \n8. Remaining Constructs of Strict Maple. Five primitive constructs of strict Maple have already been \npresented: groups, sorts, records, selections, and case clauses. The remaining four are use, parallel, \nfail, and attempt clauses. Use clauses correspond to blocks of Algol [71. A use clause has the following \nform: use Local_value in Body Both local values and bodies are expres\u00ad sions. A use clause is evaluated \nby first evaluating the local value. The name loc is bound to the result. This name can be used in the \nbody which is then evaluated, yielding the result of the use clause. As with function arguments, local \nvalues may be groups. Maple adopts the block principle of Algol, allowing references to declared entities \nto occur only within their use clauses. Similarly, formal arguments can be refer\u00ad enced only within function \nfield values. Algol scope rules (entities live only in their blocks) are considered to be a seri\u00adous \nlimitaki5n ef bo+-h Algol and of Algol-68 (see the complications in its defining report [15]) and are \ndropped. Thus it is possible to have values which remain bound to local (own) values by evaluating a \nuse clause. This and other properties of use clauses are demonstrated by an example which can\u00adnot be \nomitted from any serious discussion of abstract data types : [stack with [size is int; et is sort[:= \nwith et is [] var; ? with et is order; 1 1: use [imp: rec[ltop is int; st is array[size; et] 1; state: \nrec[lempty; [ok]; 1 in [type: sort[push with et is [] Iok var: use elem if ltop<size then ltop:= ltop+l; \nst[ltop]:= arg; else fail fullstack; end; tag is state: if elem.ltop=O then empty else ok; end; I empty; \nIok top is et: elem.st[ltop]; pop is [1 var: use elem in ltop:= ltop-l; 1 as imp; coerce with [] is Iempty \nvar type: use imp.new[] do ltop:= O; 10C; end; 1; mystack: stack[ 100; int]; St: mystack[l; tp: do st.push[7]; \nst.push[ 12]; st.push[ 14]; st.top; end; ttop with mystack: case mystack in Iempty -7777; Iok st.top; \nend; tp2 : ttop(st); 1 This group requires some explanation. The generic function stack accepts an integer \nand a sort (with assignment and com\u00adparison); it yields a class which defines stacks as variable elements. \nAlterna\u00adtively, stack could have been declared as a generic function yielding a package: [stack with \n[size is int; et is sort[:= with et is [] var; ? with et is order; 1: use [ltop; int.new(O ; st: array[size; \netl.new[l; 1 in [push with int is []: .... top with [] is et: .... pop with [] is []: .... isempty with \n[] is boolean: . . . . 1; st2: stack[ 100; int]; 1 l he function stack, yielding a package, is less desirable \nthan the one yielding a class for several reasons. First of all, there is more type security when using \nstacks as elements. Such stacks must be obtained via the class (through the func\u00adtion coerce), whereas \nstacks as packages are just groups of functions. When a package is passed as the argument to some other \nfunction, any package having the same functions may be passed instead. Second, functions of the package \nstack are more complicated to invoke: st2.push(6); st2.pop[l; st2.toP[l than the same functions from \nthe class: st.push(6); st2.pop; st2.top; It can be ascertained by static type checking that empty stacks \nfrom the class version cannot be popped. This cannot be enforced with the package version. The package \nversion needs an explicit function (isempty) to test the state of a stack, whereas in the class version \nthis is done automatically when stacks are discrim\u00ad inated upon in case clauses (see the func\u00adtion ttop)o \nThe field tag cannot be selected explicitly, it is automatically selected in the case clauses. Tag fields \nare omitted from the types of sort groups. The class version is an example of an ele\u00adment with variants \nwhich is not a record. When the first use clauses in both ver\u00ad sions of function stack are evaluated \nthe local objects remain bound to the returned values. In the class stack, the use clause is required \nto remember the record classes imp and state. The use clause is required in the package stack to retain \n,1own II variables ltop and st implementing the stack. As mentioned above, this is not possible in classical \nblock\u00ad structured languages. Use clauses of Maple extend the lifetimes of their local values (if required) \nwithout the need for the primitive notion of a module. Modules were hailed by Hansen [5][6] as the greatest \ninnovation of the seventies in the field of programming languages and by Barnes [2] (in the form of packages) \nas the greatest contribution of Ada. Actually, modules (packages) are rather complicated constructs to \nbe accepted as primitive. They consist of many parts such as export part specifica\u00adtion, local declarations, \nand initializa\u00ad tion. Maple is orthogonally designed and handles these parts via types, use clauses, \nand do clauses respectively (all of these are needed anyway). Note that the package stack initializes \nthe representation of the stack by ini\u00adtializing ltop during its creation. If a more complicated initialization \nwere required a do clause could have been inserted: use ..local entities . . . in do . . . initialization. \n..; [ . . . returned package...]; end; Do clauses are introduced only in extended Maple in the form: \ndo el; e2; ..... en; end as the abbreviation for case rec[la].a in Iael; e2; .... en; end The value \nof a do c ause is the value of its defining case clause, i.e. the value of its last express on. Extended \nMaple allows the omission of the symbol in of a use clause if it is fol\u00ad lowed by a clause starting with \na reserved symbol (see the sort field push ). Such omission is available also with some other constructs \n(for, while, etc.). As the last example of orthogonality in Maple, note the use clause in the sort fields \npush and pop: use elem in ... The occurrences of lot.st and lot.ltop in the use bodies are, of course, \nabbrevi\u00ad ated to just st and ltop . This effec\u00ad tively opens the scope of the name elem (which is of \ntype imp). In other words, the effect of the (primitive) with statement of Pascal is achieved. The sort \nfield push of the first stack raises an exception when the stack is full. Evaluation of the fail clause \nfail fullstack causes the evaluation of the selection of push to fail, causing failures in the chain \nof nested expressions until the exception is caught by an attempt clause: attemDt el; e2; ... en else \nfullstack . . . . indexrange . . . ; .. end If all expressions el, e2 ,... en evaluate without a failure, \nthe result of the attempt clause is the result of en. Other\u00adwise, the exception can be caught and pro\u00adcessed \nin the else part. There is no need to elaborate more on the exception han\u00addling in Maple because it is \nquite similar to that of Ada, except the exceptions are not declared. 9. Parallel Processing. Processes \nare introduced by parallel clauses: par pl; p2; .... pn; end Each of the processes pl, p2, . ..pn is \nan expression (of type []). The processes are evaluated in parallel. The parallel clause terminates (yielding \n[1) when all its processes terminate. Synchronization of parallel processes is achieved by the use of \nshared elements which are protected against simultaneous access by the competing processes. Shared elements \nare introduced by shared sorts: [semaphore: us~tj~~[ldown; Iup] in : shared sort[up is [] Iup var: elem:= \nelem+l; tag is lot: if elem>O then loc.up else loc.down end; Idown; IUP down is [] var: elem:= elem-l; \n1 as int; coerce with int is var semaphore: intonew(arg); 1: reso~rce: semaphore(l); 1 Records with \nvariants combine cartesian products with enumerated types and discriminated unions. Records are, thus, \nperhaps not the minimal (orthogonal) con\u00adstructs, but very useful from the pragmat\u00adical point of view \nbecause of their versa tility. General sorts with variants intro\u00adduce some syntax sugar into the use \nof elements (see the stack example), as well as increasing the possibilities of static type checking \n(a form of path expres\u00adsions). It is the shared sorts which make the variants on elements indispensable. \nA selection from a shared element is delayed until no other process performs an operation on it and the \nelement is in the state in which the selection is legal. When these conditions are met the selec\u00adtion \nis performed (there must be a side effect on the element by every selection), possibly changing the state \nthus allowing a delayed process to perform its operation. The selection resource.up l (releasing Of a \nresource) can be performed any time no other process selects from the element resource. The selection \nresource.down (acquiring of a resource) must wait until the element resource is both available and in \nthe state up . [singlebuff with sort[:= with arg is [] var; ? with arg is order: 1: use rec[lempty; \nIfull el is arcj; 1 in[type~ shared sort[ Iempty put with singlebuff.arg is [] I full var: elem:=full(arg); \nI full get is singlebuff.arg [empty var: use new[] do 10C:= elem; elem:= empty; loc.el: end; 1 as 10C; \ncoerce with [] is Iempty var type: use new[l do loc:~-empty; 10C end; 1; intbuff: singlebuff(int); mybuff: \nintbuff[]; 1 The generic function singlebuff yields a class defining single element buffers. A producer \nprocess may select mybuff.put(7). The selection will be delayed until the shared element mybuff is in \nthe state empty . After the selection the state of mybuff changes into full . Conversely, a consumer \nprocess can select mybuff.get and will be delayed until the shared element mybuff is full, emptying the \nbuffer in the process. The careful reader has perhaps noted the absence of the explicit discriminator \nfield tag from the sort. Discriminator fields are required only if the state is computed (stack, semaphore). \nThey are not required when the variants of the sorts coincide with the variants of the implementing types. \n10. Conclusions. It is quite surprising how much can be achieved in a small language with only 9 basic \nconstructs and a handful of exten\u00ad sions. Moreover, from the pragmatical point of view, the work with \ndata struc\u00ad tures seems to be perfectly standard . Yet there is a price to pay. Maple is so general that \nthere are no standard com\u00adpiler construction techniques to build an efficient processor. The traditional \nvehicle for the implementation of the block structured languages -stack -can\u00adnot be used because the \nresults vary in size and local entities of use clauses continue to live. The extreme solution of placing \neverything on a heap stretching over the entire vir\u00adtual memory (required to store the Maple tree) seems \nto be very costly. Yet it was tried, and shown feasible, by Smalltalk. But a block structured language \nwith full typing should have better storage manage\u00adment than a full heap with a garbage col\u00adlector (which \nis so necessary for typeless languages)! Fortunately there is a language design called Lawine [10] which \nhas the generic capabilities of Maple and Russell. Nei\u00adther Lawine nor Russell integrate the environment \nor provide parallel processes. The present author and Rick Gillespie adapted the storage management model \nof the Lawine machine to the needs of the virtual storage and parallel processing. Rick Gillespie is \npresently implementing a pilot version of Maple. On the basis of this implementation it will be decided \non a suitable machine and storage model. Obviously, there is a lot of research to be done. I would also \nlike to acknowledge the con\u00adtribution of Chris Gray to the design of Maple. We spent many hours together \nreviewing and rejecting different alterna\u00adtives. References [1] O. Dahl et al, The Simula Common Ba se \nLanguager Norwegian Computing centre, Oslo 1968. [2] Barnes J. G. P, An overview of Ada; Software -Practice \nand Experience, vO1. 10, 1980. [ 3 1 A. Demers, J. Donahue, Revised Re\u00adport on Russell, Technical Report \nCornell University, Ithaca 1979. [4] A. Goldberg et al, Smalltalk-80, Byte, August 1981. [5] P. Brinch \nHansen, Edison -a Multi\u00adprocessor Languager Software Practi\u00adce and Experience, April 1981. [61 P. Brinch \nHansen, The Desiqn of Edisol , Software Practice ~nd Exper: ence, April 1981. [71 P. Naur (Ed.), Revised \nReport on the System (BPS), Machine Oriented High Algorithmic Language Algol 60, Level Languages Bulletin, \nParis ~egnencentralen, Copenhagen, 1962. 1977. [8] Reference Manual for the Ada [13] P. J. Voda, Maple: \nA total Modular Programming Languager United States Environment, Maple Language; Dept. of Defense, July \n1980. Technical Report, University of Alberta, 1981. [91 D. M. Ritchie, Time-Sharing K. Thomson, System, \nCACM The vol. Unix 17, ,..\u00ad114] P. J. Voda, A view of generic con 1974. structs and modules, submitted \nto The Software Practice and [10] Swiestra S. D., Lawine an Experiment Experience. in Language and Machine \nDesign, Phd\u00ad thesisr University of Twente, 1980. [15] A van Wijngaarden (Ed.), Revised Report on the \nAlgorithmic Language [11] Teitelman W, Masinter L; The Inter- Algol 68, Sigplan Notices, vol. 12, lisp \nProgramming Environment; May 1977. Computer, April 1981. [16] N. Wirth, The Programming Language [12] \nP. J. Voda, Bratislava Programming Pascal, Acts Informatica, vol. 1, 1971. \n\t\t\t", "proc_id": "582153", "abstract": "Maple is a statically typed language system, with very general generic facilities. It incorporates its own programming environment and provides parallel processing with a new method of process synchronization. The synchronization is the direct outgrowth of its data abstraction facility.", "authors": [{"name": "P. J. Voda", "author_profile_id": "81100354178", "affiliation": "University of Alberta, Edmonton, Canada", "person_id": "P218371", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/582153.582171", "year": "1982", "article_id": "582171", "conference": "POPL", "title": "Maple: a programming language and operating system", "url": "http://dl.acm.org/citation.cfm?id=582171"}