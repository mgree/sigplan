{"article_publication_date": "01-25-1982", "fulltext": "\n A Type Declaration and Inference System for Smalltalk Alan H. Borning Computer Science Dept., University \nof Washington Daniel H. H. Ingalls Xerox Palo Alto Research Center Abstract An experimental system \nfor declaring and inferring type in Smalltalk is described. (In the current Smalltalk language, the programmer \nsupplies no type declarations.) The system provides the benefits of type declaration in regard to compile-time \nchecking and documentation, while still retaining Smalltalk s flexibility. A type hierarchy, which is \nintegrated with the existing Smalltalk class hierarchy, allows one type to inherit the traits of another \ntype. A type may also have parameters, which are in turn other types. 1. Introduction Smalltalk is a \npowerful interactive language based on the idea of objects that communicate by sending and receiving \nmessages [Ingalls 78, LRG 81, Goldberg 81]. In Smalltalk, the user supplies no type declarations. This \nresults in greater flexibility than in a typed language such as Pascal; however, in almost all cases, \nthe programmer in fact knows what sorts of objects are expected as the arguments of a message, and what \nsort of object will be returned, Since at present one must glean this information from comments, external \ndocumentation, or by inspecting the code, a type declaration mechanism would provide a valuable form \nof machine-checkable documentation. While Smalltalk is a type\u00ad safe language in the sense that encountering \nan object of an *------------. - .. --- This research was funded primarily by the Xerox Corporation, \nwith additional funding from the National Science Foundation under Grant No. MCS-80041 I I. Permission \nto copy without fee all or part of this material is granted provided that the copies are not made or \ndistributed for direct commercial advantage, the ACM copyright notice and the title of the publication \nand its date appear, and notice is given that copying is by permission of the Association for Computing \nMachinery. To copy otherwise, or to republish, requires a fee and/or specific permission. @ 1982 ACM \n0-89791-065-6/82/001/0133 $00.75 133 inappropriate class will only result in a run-time error of the \nform message not understood , it is nevertheless advantageous for the programmer to be informed of such \na problem when the code in question is being compiled, rather than later when it is being used. In this \npaper we present an experimental system for declaring and inferring ripe in Smalltalk. In adding type \ndeclarations to the language, we do not wish to give up its current flexibility. The principal feature \nof our scheme that allows it to retain this flexibility is the hierarchical description of types, and \nthe integration of this hierarchy with the existing Smalltalk class hierarchy. The type of the actual \ncontents of a variable or field may be the same as or any subtype of its declared type. (In contrast, \nin e.g. Pascal the types would have to match exactly.) For example, one might have a declaration for \na message addWlndow: that specified that its argument was to be of type Window. When actually sending \nthe message addWindow: , any subtype of Window--a code editing window, a debugging window, a painting \nwindow, or whatever-would be acceptable as the actual argument. Correspondingly, in the code that implements \nthe addWindow: method, the programmer could only send to that argument messages that all windows understand. \nAnalogously, one could declare that the argument of some other message was of type Object. Since every \ntype is a subtype of Object, the argument could be any object--but in the code for that method, the programmer \ncould send it only messages that all objects understand. In the sections that follow, we describe the \nnotions of type, subtype, and parameterized type in Smalltalk, along with techniques for declaration, \nchecking, and infe~ence of type. In addition, we present a user interface that allows a programmer to \nview and edit type declarations conveniently. The type system is written in the Smalltalk-80 version \nof the language. 2. Definition of Type in Smalltaik A type specifies the messages that an object of that \ntype understands. Thus, a type is abstract: it describes an object s interface with the outside world, \nbut not its internal representation. Each type specifies a set of message declarations. In turn, each \nmessage declaration gives the name of the message, the formal argument names, the types of the arguments, \nand the type of the result. Types come in hierarchies, so that one type maybe declared as being a subtype \nof another, A subtype inherits the message declarations of its supertype, and may add additional declarations \nof its own. In addition, it may refine an inherited message declaration by indicating that the result \nis some subtype of what was previously declared, At the top of the hierarchy is type Object, which declares \nmessages such as = , copy , and printOn: that are understood by all objects. Types can have parameters. \nFor example, rather than just saying that something is of type Collection, it may be described as being \na collection of some other type of object, e.g. as being of type Co//cc/ion of: Window. 3. Implementation \nof Types We define a Smailtalk class Type. This class is abstract: it declares no instance state, but \nonly serves as a superclass for other classes. One subclass of Type is class Class --a class is a perfectly \ngood specification of a type.l ParameterizedType is another subclass of Type, which is used to hold copies \nof existing types with new parameters substituted for the original ones. For example, the type Collection \ndeclares that it has a single parameter named e/ernen(Type, which is the type of the elements in the \ncollection. A type such as Co//ecf(on of: Window is represented as an instance of ParameterizedType. \n(The type Co//ection itself declares that its element type is Object.) We leave open the possibility \nof additional subclasses of Type, for example, a class Protocol that would describe a collection of related \nmessages independently of any concrete implementations. In the default, the type of an object will be \nthe same as its class, but this is not universally the case. For example, the Smalltalk class Integer \nhas three concrete subclasses: Small Integer, Larg@Negativelnteger, and LargePositiveInteger, but the \ntype of instances of any of these is simply /nfeger. On the other hand, if c is a collection of windows, \nits type will be Co//ection of: Window, but its class will be Collection. 4. Making Declarations As mentioned \nabove, a message declaration gives the name of the message, the formal argument names, the types of the \narguments, and the type of the result Here, we will give an informal description of the ways in which \nthe argument and result types can be specified, followed by some examples. A formal BNF description \nis given in Appendix 1, The type of an argument maybe specified as the gfobal name of some type, such \nas Integer or Window, or by the name of a parameter, e.g. as e/ementType for a method defined by Collection. \nIn addition, an argument type specification may be 1For emphseie, in this paper we italicize all expressions \ndesignating types. However, when we simply name a class without using it in its role as a type, we leavethe \nnamein the normaltypeface. constructed by giving new parameters to one of the above expressions, or by \ngetting a parameter from one of them. The algebra of types for specifying the type of a result is somewhat \nricher. A result type specification may be any of the possibilities for an argument type. In addition, \nthe result type may be specified as self, meaning the type of the object that is executing the method, \nas being the same as the type of one of the arguments to the method, or as being the nearest common supertype \nof two other result type expressions. (The nearest common supertype of two types is that type which is \na supertype of each and which is closest to them in the type hierarchy. The algorithm for finding nearest \ncom mon supertypes is given in Section 5). In addition to the declarations for messages, the programmer \ncan declare the types of temporary, instance, class, and global variables. The types of temporary variabfea \ncan be inferred by the compileL for the others, declarations are required. We now present some examplea \nof type declarations. (These aren t the complete type definitions for any of the types listed; rather, \nwe list only some representative message declarations.) The type of each argument is declared by writing \na type expression in angle brackets after the argument name, while the type of the result is decfared \nby an uparrow folfowed by a type expression in angle brackets. Comments are surrounded by double quotes. \nObject ssrpertype: none AS previously mentioned, Object is the super type of all other types. x <Object> \nam I equal to x? t<Bool can> copy return a copy of myself t<self> Here, the type of the object returned \nis the same as that of the receiver. The specification of the object that is returned is evaluated in \ntype space rather than ordinary object Spa Ce , so that self here means the receiver s type. printOn: \nstrm <Stream of: Character> This is the standard message asking an object to print itself Streams on \nan output stream. are parametrized by the type of object in the stream. ~<self> type return my type \nt<Type> class Every types is regarded as being parametrized by its class. tsself class> Number supertype:Object \nA!urnber is a supertype for numbers of all sorts: integers, fractions, floating point numbers, etc. abs \nreturn my absolute value *<self> aslnteger convert to an integer ?<Integer> asFloat convert to a real \nnumber t<Float.> + n<Number> *<self nearestCommonSupertype: n> As far as the type system is concerned, \n3+4 yields something of type Integer, while 3.14+4 yields something of type Number. (In fact, the result \nin the latter case will be of class Float, but the type system only knows, that it will be some subtype \nof Number.) Collection supertype:Object parameters: elementType  e/ernentType is the type of the elements \nof the collection. The elements in a given instance can be subtypes of e/errrent7 ype; however, users \nof the collection can only count on the elements being of type e/ernerrtType. The class Collection responds \nto the message of: by returning a new instance of ParameterizedTypa with the parameter elementType set \nappropriately. add: x<elementType> ?<self> remove: x <elementType> tzselfz addAll: c<Collection of:elementType> \ntzsel f> do: b <Block from: elementType to: Object> This message takes a block as an argument, and evaluates \nthe block for each element in the collection. The results of the evaluation are discarded. (A block is \nan object representing a piece of code to be evaluated at an appropriate time; in this example the block \ntakes one argument. The type Block is discussed further in Section 7.1.) t<sel f> collect: b< Block from: \nelementType to: Object> This nfessage takes a block as an argument, evaluates the block for each element \nin the collection, and returns a new collection consisting of tha Pesult$ 6f evaluating the block. Lisp \nfans: this is similar to mapcar , ?Zself of: b resultType> Boolean supertype:Object &#38;b<Boolean> tzBooleanz \nand:aBlock<Block to: Boolean> This version of and evaluates its argument only if necessary, t<Boolean> \nifTrue: t <Block to: Object> if False: f <Block to: Object> t<t resultType nearestCommonSupertype: f \nresultType> ifTrue: t <Block to: Object> ?<t, resultTypez If the receiver is false , then the result \nis nil. (As described in Section 5, nil is allowed as an instance of any type, and hence it satisfies \nthe declaration tresu/tType.) if False: f <Block to: Object> ?Zf resultType> Type supertype:Object A \ntype is itself an object that can respond to various messages. parameters Return a dictionary of my parameters. \nr<Dictionary keys: Symbol values: Type> supertype answer with my supertype tsType~ Class supertype:Type \nnew create a new instance The type Class is regarded as being parametrized by the type of instance that \nit creates. t<self instanceType> 5.TypeChecking andTypelnference This section describes the type checking \nand inference mechanism. When the user compiles a method, the system checks at compile time that the \nmessages that might be sent during execution of the method body would be understood by their receivers, \nthat the message arguments will be of the correct types, that only objects of the correct type will be \nassigned to variables, and that an object of the correct type will be returned. Part ofthisprocess requires \ntype inference aswellaschecking, since the types of expressions must be inferred, and the system specifications \nallow the types of temporary variables to be inferred if the user so desires. A fundamental operation \nin type checking ismatchinq, that is, checking that anactual type matches a declared type, An actual \ntypef matches adeclared typed if t isthesame type asor isa subtype of d. Ifdhasparameters, then for each \nparameter of d, thecorresponding parameter oftmust match it. Finally, the type Ur?defirredObject matches \nany type. (UndefinedObject istheclass of nil, to which all variables are initialized in Smalltalk. ) \nAnother operation required in type checking is finding the nearest common supertype of two types t7 and \nf2. To find this nearest common supertype, t7 searches upitschain of supertypes until it finds the first \nsupertype s that is also a supertype of t2. (Such a supertype always exists, since all types are subtypes \nof Object.) Ifshasparameters, thevalues of each parameter of the nearest common supertype is found by \ncomputing the nearest common supertype of the corresponding parameters from f7 and ?2 Thetype checking \nand inference mechanism isinvoked by the compiler. The types of the arguments, result, and instance variables \nare obtained from the user s declarations. Aftera parse tree has been generated, an executionf ortype \nof the parse tree is performed in the following fashion. Each kind of parse tree node understands the \nmessage executeForType . When anode receives this message, it returns the type of the object that it \nwould return at run time. Some nodes also perform checks: variable nodes check that the type of any value \nassigned to that variable matches the declared type of that variable; message nodes check that the receiver \ncan understand the message, and that the types of the actual arguments match those of the formal arguments. \nTo find the type that is returned when a message is sent, the declaration for that message must be consulted. \nThe system evaluates the result type expression (using the types of the actual arguments in the computation), \nand returns this result as the value of the message node. Smalltalk control structures are described \nas messages to some object. This is very convenient from the point of view of the type system, in that \nthe algorithms for checking such things as conditionals and looPs can be described simply by the declarations \nfor these control structure messages; no additional mechanism is needed. (See the declarations for Collection \ndo: and Boolean ifTrue: ifFalse: in Section 4, and the declarations for Block whileTrue: and Block whileFalse: \nin Section 7.1.) Type inference is integrated with the type checking process. For expressions, the type \nof the expression is returned when executeForType is sent to the message node. For a temporary variable \nwhose type has not been declared by the user, the corresponding variable node will keep track of the \ntypes of objects assigned to that variable. If an object of type /7 is assigned to the variable, the \ninferred type will be t7. If an object of a different type t2 is subsequently assigned, the new inferred \ntype will be the nearest common supertype off 7 and ?2. Type inference for parameterized types is handled \nin an analogous fashion, For example, when inferring the type of a collection, the type of e/emenf7 ype \nis the nearest common supertype of the types of each element inserted into the collection. On occasion, \ntype inference may yield more specific information than is available from the programmer s declaration. \nFor example, the programmer might declare that a temporary variable t is of type Number, but the type \ninference mechanism could infer that in fact t must be an integer. In such a case, the type system does \nnot refine the declaration; thus, sending a message to t that is understood by integers, but not numbers \nin general, would yield an error during type-checking. If the programmer wants to send such messages \nto t, he or she should declare t to be of type Integer, or else let the system infer its type.2 2 Th6 \nway of handllng the mterachon between type inference and declaration for variables IS consistent with \nthe treatment of declarations for message arguments. In type checking a method, it is the declaration \nof the formal arg ~ent that is ~ed, even though when the method is invoked, the actual argument may be \nsome more specifw type.  6. The User Interface The user interface to the type system has been constructed \nby simple modifications to the Smalltalk class browser described in [Tesler 81], The old pane of the \nbrowsing window that displays the code for a given method is divided into two parts: a declaration pane \nthat contains the keywords, arguments, and declarations; and a code pane that contains the code proper, \n(See Figure 6-1.) Compilation is done in Smalltalk on a method-by-method basis; type checking is performed \nwhenever a method is compiled. The system checks that all the messages sent inside the code body have \ncorrect argument types, that the value returned matches the declared type of the result, and that assignments \nto variables match the declarations for that variable, notifying the user of any violations, In our experimental \nprototype, we hatie added declarations for only a small proportion of the methods in the Smalltalk system. \nTherefore, in this version, there may be no declaration for some message used in a body of code being \nchecked. In this case, the system informs the user, and assumes that the result type is UndefinedObject \n(which matches anything). 7. More about Type Declarations 7.1. Declaring the Type of Blocks As previously \nmentioned, a block is an object representing a piece of code to be evaluated at an appropriate time, \nperhaps with arguments, To evaluate the block, the programmer sends it the message value , value: , value: \nvalue: , or value: value: value: , depending on whether the block takes zero, one, two, or three arguments \nrespectively.3 In Smalltalk, all blocks are instattces OF the same class. However, it is appropriate \nto send the message value only to a block taking zero arguments, the message value: only to a block taking \none argument, and so forth. To allow this to be verified during type-checking, we define separate subtypes \nof B/ock for blocks that take zero, one, two, and three arguments. All these types are parameterized \nby the types of the arguments to be supplied to the block and the type of the result. Further, it is \nappropriate to send the control-structure messages whileTrue: and whileFalse: only to a block that \ntakes zero arguments and Blockl that also evaluates to a Boolean; to represent this, a subtype supertype: \nBlock /300/earrB/ock of the type of blocks taking zero arguments is parameters: arglType resultType \ndefined. This type of block takes one argument. Block value: arg<arglType> supertype: Object t<resultType> \nparameters: resultType The type of any actual block will be some subtype of this type. new Process \nCreate a new process. All blocks can do this, so this message is declared in B/ock. t<Process> Block2 \nsupertype: Block parameters: arglType arg2Type resultType This type of block that take two arguments. \n value: argl <arglType>value: arg2<arg2Type> tzresultType> Biock3 supertype: Block 3It would of course \nbe easy todefinefurrher measages for blocks taking four parameters: arglType resuitType arg2Typearg3Type \narguments, and so forth. This type of block that take three BlockO supertype: Block parameters: resultType \n This type of blocks takes no arguments. value: argl <arglType>value: value: arg3<arg3Type> *<resultType> \narg2<arg2Type> arguments. value In writing type declarations, the programmer makes use of a set r<resultType> \nof messages understood by the class Block. BooleanBlock supertype:BlockO to: rType returns a BlockO parameterized \nby the parameters: resultType resultType rType. As a special case, if rrype This is a subtype of BlockO \nwith matchesBoo/ear?, this returns a BooleanBlock resultType set to Boolean, (B/ockO instead. just declares \nthat it produces something whileTrue: of type Object.) anotherBlock <Blockto: Object> from: al Type to: \nrType ?<self> whileFalse: rfself> anotfserBlock <Block to: Object> returns argument a Blockl parametrized \ntype a7Type and the by the resultType r Type 137 from: al Type and: a2Type to: rType returns a Block2 \nparameterized by the argument types alType and a2Type, and the resultType rType from: al Type and: a2Type \nand: a3Type to: rType returns a Block3 parameterized by the argument types al Type, a2Type, and a3Type, \nand the resultType rType It would be possible to represent the types of blocks in a more general way. \nForexample, ParameterizedType could allow tuples of types as parameters, and also allow message de~larations \nto be associated with particular instances. This would permit the use of a single type /3/ock, with blocks \ntaking zero arguments, blocks producing booleans, and so forth represented simply as parameterizationsof \nthis type. We did not do this in the present system because these capabilities, which would be used only \nfor blocks, would require making the parameterization mechanism significantly more complex.  7.2. An \nExample Using Blocks To illustrate type-checking in the presence of blocks and collections, consider \nchecking the following method. exampleMethod I pt setl set2 I create a new point with x=5 and y=l O pt \n+ 5@lcl. setl + Set new. setl add: pt. Make a new set tha collects the results of sending each element \nin Setl the message asString . set2 + setl collect [:x I x asString]. The type of pt is inferred to \nbe oint from the declaration for the @ message to Number. Next, the type of csetl is inferred to be Set. \n(Set isoneof thesubclasses of Collection.) However, its e/errrent Type is not yet known. The following \nstatement (<setl add: pt ) allows the type checker to infer that the e/ernenfType of setl is Poinf. Inchecking \nthe final statement, the type checker checks that the actual argument to collect: matches the declaration \n<Block from:elementType to: Object>, which itdoes, andthat itislegal tosendthe message iasString'to instances \nof Poirrf. The declaration for asString also allows the system to infer that the type of set2 is Set \nof: String.  7.3. Run-timeType Checking At the start of this project, we anticipated the need to perform \nrun.time type checking in a number of places, but as the design of the system has developed, nearly all \nof these places have disappeared (and the system has become cleaner in the process). If itshould beneeded, \nitisactuallyquite simpletoinclude arun\u00adtime type check by using the message be: , The declaration for \nthis message is: Object supertype:none be:aType<Type> tzaType> The corresponding method simply checks \nif the receiver s type matches aType . If it does, it returns the receiver; otherwise, it notifies the \nuser that atype error has occurred (and then returns nil if the user chooses to proceed). The messages \nwhose uses can often not be type-checked at compile time are Object perform: , which sends a message \nusing adynamically computed selector4, and instfield: gets: , a message for use by systems hackers that \nassigns into the ith field of an instance. There may beafew others. As an aside, at least for now it \nwouldn t be disastrous if the type checking system were breached: the worst that will happen is that \nthere will bea run-time message not understood error. In any event, ifdeclarations were added for all \nmethods, the type system would be able to inform the user whenever there was a possibility that a run-time \nerror of the message not understood variety could occur. 41t maybe worth getting rid of therun.time check \nfor perform by adoptinga scheme analogous to that employed for blocks, where selectors would have different \ntypes, depending on the number and types of their arguments and the typeoftheresult.  8. Relation to \nOther Work One of the principal ancestors of Smalltalk is Simula[Dahl &#38; Nygaard 66], which was one \nof the first systems to use the concepts of classes, subclasses, and instances, The use of objects and \nmessages for information hiding is closely related to the data abstraction mechanisms in languages such \nas Mesa, CLU, Alphard, and Ada [Mitchell 79, Liskov 77, Wr.rlf 76, DOD 80], These languages separate \nthe interface specification of a type from its internal implementation, just as Smalltalk distinguishes \nthe external message protocol of an object from its internal aspects. Suzu}i has recently described an \nalgorithm for inferring types in Smalltalk-76 [Suzuki 81], and has used it to infer types in the Smalltalk \nsubset concerned with numbers. The algorithm is an extensioo of Milner s algorithm used to determine \ntypes for the ML language of LCFIMilner 78]. Suzuki s program produces asetof equations and inequalities \nfrom a collectionof Smalltalkmethods, and solves them using unification and a transitive closure algorithm, \nThere are a number of important differences in the approaches taken in this system and ours. Suzuki s \nsystem deals with Smalltalk asitis, and isthus concerned with inferring typesin the absence of declarations, \nwhereas we modify the language by the addition of explicit declarations. One consequence of thisis that \nSuzuki s program must examine code throughout the Smalltalk system to infer types, since here the types \nof arguments passed into a method can only be discovered by examining all users of that method. Bycontrast, \noursystem checks one method at a time, and need only examine the declarations for the messages that it \ninvokes, but not their code. This simplifies our program considerably, and makes type checking in the \npresence of edits to a running system much easier, A less important difference is that Suzuki s system \nuses unions of types, whereas we use a single type, taking the nearest common supertype as necessary. \nFor example, Suzuki s system would infer that the type of the expression x = y ifTrue: [3] ifFalse: [3.1416] \n was {/rNeger, F/oaf}, whereas ours would infer it to be Number, the nearest common supertype of /rrteger \nand F/oat. Finally, Howard Cannon has developecf the flavors system for the MIT Lisp Machine Lisp [Cannon \n80]. The flavors system adds to Lisp the capability for making objects that can interact by sending messages, \nand has received extensive use in defining window packages. An important feature of the flavors system \nis that it allows an object to be defined using several flavors. In Smalltalk, this would correspond \nto allowing a class to have multiple superclasses (and a type to have multiple supertypes). While we \nhave experimented with such a capability in Smalltalk (see e.g. [Borning 81]), we have not included it \nin the system described here, 9. Conclusions and Further Work The type declaration and inference system \nhas been implemented and tested; however, we have not yet used it during the implementation of a large \nproject, nor has it been used by people other than its implementors. The next step is thus to carry out \na significant project within our system. Further work on the user interface is needed, Also, the current \nsystem does not handle dynamic updating of message declarations. The obvious thing to do if a declaration \nis changed is to check all users of that message to see if they are still using it correctly, but this \nwould be a very time-consuming operation, and would disrupt the flow of user interaction. We have designed \n(but not implemented) a scheme that spreads this load over a longer time, and also avoids the problem \nof needlessly re-checking the same method when making a series of edits. We have been encouraged by the \nresults so far. It has been gratifying to be able to make changes of this sort to a running Smalltalk \nsystem without great difficulty. Most of the work in building the system has gone into the design of \ntypes, type hierarchies, generic types, and the relation between types and classes, as opposed to the \nactual coding of the program. Of this code, most consists of new classes and methods; the modifications \nneeded to interface with the existing compiler and browser are small. No changes to the Smalltalk virtual \nmachine were required, may aid in the production of faster, more compact code by allowing better factoring \nof information. Also, the type system may help in tracing control flow, thus making it possible to produce \napplication modules containing just the code needed to run a particular application, Acknowledgements \n We would like to thank all the members of the Learning Research Group at Xerox PARC for help and suggestions, \nin particular Peter Deutsch and Phil Klein. It has not been an immediate goal of this research to improve \nrun-time efficiency. In the longer term, however, the type system 1. A BNF Description of Type Declarations \nIn this appendix we present a formal definition of type declarations in our system, using the human engineered \nvariant of BNF described in [Ledgard 81]. Terminals in the grammar are underlined, optional items are \nsurrounded by square brackets, and repetition is denoted by .,. . type-declaration ::= type-name suDertv \nDe: type-name [parameters: - \u00ad parameter -name... ~] message-declaration. . message-declaration ::= \npattern-part ~result-type> ;:= pattern-part unary-selector I binary-part I keyword-part. ., binary-part \n::= binary-selector argument-name <argument-type2 keyword-part ::= keyword argument-name gargument-typez \n..= argument-type . . simple-type result-type ::= simple-type Iti I argument-name I result-type nearestCommonSuDertyPe: \nresult-type simple-type ::= type-name I parameter-name I new-parameters I get-parameter ;:= type-name \nidentifier ::= parameter-name identifier new-parameters ::= type-name parametrization. . . parameterization \n::= keyword simple-type ..= get-parameter . . simple-type parameter-name The category names urtary-se/ecfor, \nbinary -selector, and keyword are as in Smalltalk-80; definitions maybefoundin[LRG 81]. [Liskov 77] \n References [LRG 81 ] [Borning 81 ] Borning, A.H. The Programming Language Aspects of ThingLab, A ConstraintOriented \nSimulation Laboratory. ACM Transactions on Programming Languages and Systems 3(4):353.387, October, 1981. \n[Milner 78] [Cmno~ 80] Cannon, HI. F/avers. Technical Report, Lab, 1980. MIT Artificial Intelligence \n[Mitchell 79] [Dahl &#38; Nygaard 66] Dahl, O-J, and Nygaard, K. SIMULA --An ALGOL. Based Simulation \nLanguage. Communications of the ACM 9(9):671-678, September, 1966. [Suzuki 81] [DOD 80] United States \nDepartment of Defense. Reference Manual for the Ada Programming language 1980. [Tesler 81] [Goldberg \n81] Goldberg, A.J., Robson, D., and Ingalls, D.H,H. Smalltalk-80: The Language and its Implementation. \n1981, Forthcoming book. [Wulf 76] [Ingalls 78] Ingalls, D.H.H. The Smalltalk-76 Programming System: Design \nand Implementation. In Proceedings of the Fifth Annua/ Principles of Programming Languages Symposium, \npages 9-16. ACM, January, 1978. [Ledgard 81 ] Ledgard, H.F. A Human Engineered Variant of BNF. S/GPLAN \nNotices 15(10):57-62, October, 1981, Liskov, B., Snyder, A,, Atkinson, R, and Shaffert, c. Abstraction \nMechanisms in CLd. Communications of the ACM 20(8):564-576, August, 1977. The Xerox Learning Research \nGroup. The Smalltalk-80 System. Byfe 6(8):36-48, August, 1981. Milner, R. A Theory of Type Polymorphism \nin Programming. Journal of Computer and System Sciences 17:346-375, 1978. Mitchell, J., Maybury, W., \nand Sweet, R. Mesa Language Manual. Technical Report CSL-79-3, Xerox Palo Alto Research Center, April, \n1979. Suzuki, N. Inferring Types in Smalltalk. In Proceedings of the Eighfh Anrrua/ Principles of Programming \nLanguages Symposium. ACM, 1981. Tesler, L. The Smalltalk Environment. Byte 6(8):90.147, August, 1981. \nWulf, W., London, R., and Shaw, M. An Introduction to the Construction and Verification of Alphard Programs. \nIEEE Transactions on Software Engineering SE\u00ad2(4):253-264, December, 1976. \n\t\t\t", "proc_id": "582153", "abstract": "An experimental system for declaring and inferring type in Smalltalk is described. (In the current Smalltalk language, the programmer supplies no type declarations.) The system provides the benefits of type declaration in regard to compile-time checking and documentation, while still retaining Smalltalk's flexibility. A type hierarchy, which is integrated with the existing Smalltalk class hierarchy, allows one type to inherit the traits of another type. A type may also have parameters, which are in turn other types.", "authors": [{"name": "Alan H. Borning", "author_profile_id": "81100164129", "affiliation": "University of Washington", "person_id": "P12275", "email_address": "", "orcid_id": ""}, {"name": "Daniel H. H. Ingalls", "author_profile_id": "81100449281", "affiliation": "Xerox, Palo Alto Research Center", "person_id": "P58915", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/582153.582168", "year": "1982", "article_id": "582168", "conference": "POPL", "title": "A type declaration and inference system for smalltalk", "url": "http://dl.acm.org/citation.cfm?id=582168"}