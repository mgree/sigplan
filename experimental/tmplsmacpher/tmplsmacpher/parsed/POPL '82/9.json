{"article_publication_date": "01-25-1982", "fulltext": "\n Optimal Code for Control Structures by M. V. S. Ramanath University of Western Ontario Londonr Ontario, \nCanada and Marvin Solomon Universiv of Wisconsin Madiso~, Wisconsin In a directed graph a collection \nof pair\u00ad1. INTRODUCTION wise disjoint simple paths that covers all We consider the problem of generating \ncode the nodes is called a dissection. Given a for a program so that the number of uncon\u00adsource program \nand a translation for it, ditional branch instructions, or jumps , any jump-free segment of object code \nin the object code is minimized. Figure 1 determines a simple path in the flowgraph; shows an example \nof a program and the the translation therefore determines a machine code that is normally produced for \ndissection for the flowgraph. Conversely, it; all six jumps therein can be eliminat\u00adgiven a dissection, \nwe can find a ed by reordering the blocks of machine corresponding translation such that each code.*) \nIn this paper, we present an al\u00adpath of the dissection yields a jump-free gorithm that finds an ordering \nof the code segment. In each case, the number of basic blocks of a program that is optimal jumps in the \ntranslation equals the number with respect to the number of jumps, pro\u00adof paths in the dissection. Finding \na vided the program is constructed using minimal-jump translation for a program, only the structured \ncontrol structures therefore, corresponds to finding a if then-else, loop, and exit. (The prob\u00ad minimal-cardinality \ndissection for the lem for arbitrary, unstructured programs flowgraph of the program. The flowgraph is \nNP-complete.) The running time of the of the program in Figure 1 and the dissec\u00ad algorithm is quadratic \nin the size of the tions corresponding to the two transla\u00ad program, provided the maximum number of tions \nare shown in Figure 2. loops exited by any exit statement is bounded by a constant. We confine our-The \nproblem, in its most general form, can selves to techniques that preserve the be stated as: flowgraph \nof the program exactly; tech- THE DISSECTION PROBLEM (DP) Given a di\u00ad niques such as code duplication \nare out\u00adgraph G and a positive integer K, does G side the scope of this paper. have a dissection of cardinality \nat most K? Permission to COPYwithout fee all or Part of this material k granted provided that the copies \nare not made or distributed for direct commercial advantage, the ACM copyright notice and the title of \nthe publication and its date appear, and notice is given that copying is by permission of the Association \nfor Computing Machinery. To copy otherwise, or to republish, requires a fee and/or specific permission. \n *) The statement exit i means break out of i enclosing loops and is obviously equivalent to the more \nfamiliar labeled exit statement. @ 1982 ACM 0-89791-065-6/82/001/0082 $00.75 Since a special case of \nDP (K=l) is the Hamiltonian Path problem (HP) which is known to be NP-Complete [1] even for the restricted \nclass of planar digraphs with both the indegree and the outdegree of each node bounded by two [2], DP \nitself must be NP-Complete for that class. The only other previous attempt to solve DP is [3] where a \npolynomial-time algorithm for dags and a heuristic for general di\u00adgraphs are presented. By an SFG (Structured \nFlow Graph) we mean the flowgraph of a structured program; the equivalence of SFGS and RFGs (Reducible \nFlowgraphs) follows from [4]. Our result shows that DP is solvable in polynomial\u00ad time for each class \nSFG(r) , the class of all SFGS that can be expressed using at most r-level exits. The classes SFG(r) \nfor r in {0,1,2 ,...} form a strict linear order under containment as can be seen from [5]. The question \nremains open whether DP or even HP is NP-Complete fOK RFGs . We consider programs (in a language like \nAda or Pascal) composed of simple state\u00ad ments and Boolean expressions using the following operations \n(P and Q are pro\u00ad grams, possibly null): (a) P;Q (Concatenation) (b) if B ~ P else Q endif (B is a Boolean \nexpression) (c) loop P endloop (P may have multilev\u00ad el exit statements of the form exit 1 where i>O \nis an integer specifying the number of nested loops to be ex\u00ad ited. ) Analogues of these operations \nfor flow\u00adgraphs are shown below: As is evident from these figures, the flowgraphs must include specifications \nof start!! and finish nodes; for instance in (a) new arcs are drawn from the finish nodes of P to the \nstart node of Q. The start and finish nodes of the new graph are easily specified in (a) and (b); in \ncase (c), specifying the finish nodes is more involved: they should be all nodes from which an exit of \nthe newly created loop is possible. Our model specifies, for each i~O, a set of level-i exit nodes. Treating \nfinish nodes as simply level-O exit nodes, we can now describe the pre\u00adcise effect of (c): o draw arcs \nfrom the old finish nodes to the old start node. o the new start node is the old start node. o the \nnew level-i exit nodes are the old level (i+l) exit nodes.  We specify the level-i exit nodes of a flowgraph \nby labeling each node with a set of integers, since a single integer is inadequate because a node may \nbe both a level-i exit node and a level-j exit node as in if B then exit i else exit j endif. The input \nto our algorithm is a descrip\u00adtion of how the flowgraph was constructed by operations (a), (b) and (c). \nSuch in\u00adformation can be obtained from a parse tree of the corresponding source program. 2. NOTATION \n@ i,s the empty set; ~ is a symbol used to label the start node of a flowgraph; 1= {0,1,2,...}; 1+ = \nIU{~}; P(Y) denotes the power set of Y; IYI denotes the cardinality of Y. The terms: relation, function, \ndomain, range, inverse and composi~ (of rela\u00ad tions) are used in the usual set-theoretic sense. AXB denotes \nthe Cartesian pro\u00adduct of sets A and B. f o g denotes com (b) Suppose El and E2 are expressions, position \nof relations f and g. The following special relations will be useful later: For any set Y, idY = {( Y,Y) \nIYGY } For any i~l, z.=(idI+) -{(0,0)}) U {(O,i)] 1 For any k e1+, delk = (idI+) -{(krk } Finally, deer \n= {(~,~) U {(i+l,i) I i~I) 3. THE FORMAL MODEL Implicit in what f!. 11OWS is the assumption that nodes \nare associated with the atomic actions of a program (simple statements or Boolean expressions). A Flowgraph \nG is a triple (N,A,L) where: N is a non-void finite set of nodes. A~NxN i,s a set of di,rected arcs. \nL~ N x 1+ is a relation that associ\u00adates with each node zero or more la\u00adbels from 1+ such that IL-l(?) \n1=1 (that is, exactly one node is la\u00adbeled by ~). -1 The unique element of L (~) is denoted by s(G) and \ncalled the start node of G. The -1 elements of L (i) are called the level-i exit nodes for each i~O \n, and the set L-l(0) is denoted by F(G) and its members are also called finish nodes of G. A program \nexpression (or simply expres\u00adsion) E, and its flowgraph G = (N,A,L) are defined recursively: (a) For \nany iG1, and any node n, E=EXIT(i,n) is an expression and N={n}, A=@, L={n}x{t,O,i}. [If i=o , this expression \ncorresponds to the simple statement associated with n; if i.~1, it corresponds to either of: if B then \nexit i endif or ~ B~ ~ ex~endif where B is the Boolean expression as\u00adsociated with n.] G1=(N1,A1,L1) \nand G2=(N2,A2,L2) are their respective flowgraphs, Nln N2=@r t is a node not in N1 U N2, and i ~ I, i~l. \nThen, E and G=(N,A,L) as defined by the five operations below are respectively an expression and its \nflowgraph. [See Figure 3] BREAK E= BREAK(i,El), N = Nl, A= Al, L=Zi oL1 [If El is a program this corresponds \nto the new program El;exit i . Since control can reach the exit i only from the finish nodes of Gl, we \nsimply replace all O-labels with i-labels using the relation Zi. We do not create new nodes for state\u00ad \nments of the form exit i .] LOOP E = LOOP(E1), N = Nl, A = Al U (F(Gl)x{s(Gl)})r L = deer o L1. [If El \nis a program, this corresponds to the new program loop El endloop . The deer T relation is used to specify \nthat the new level-i exit nodes are the old level-(i+l) exit nodes; the new arcs are given by F(G1) x \n{s(G1)}] CAT E = CAT(E1,E2), N = N1 UN2, A = Al m A2 U (F(Gl)x{s(G2)}), L = (delo o Ll) U (del o L2) \nT [This corresponds to concatenating two programs El and E2. The two parts of the labeling relation L \nspecify respectively that the finish nodes of G1 are no longer finish nodes and that the start node of \nG2 is no longer the start node; all other labels are unaltered.] IF E = IF(t,El), N = N1 U {t}, A= AI \nU{(t,s(Gl)}, L = ({t}x{~,O}) U (delTo Ll) [This corresponds to either of: if B then else El endif orfiB~~lse \n~ . where B is the Boolean expression associated with t.] ELSE E = ELSE(t,El,E2), N = N1 UN2, A=A1 UA2 \nU ({t}x{s (Gl),s(G2) }), L = (delto(Ll tUL2)) U {(t,~)} [This corresponds to the statement if B then \nEl else E2 endif] ._ _ A flowgraph is called a Structured Flow Graph (SFG) iff it is the flowgraph of \n_ some expression; the six operations listed above are called SFG operations. The size of an expression \nE is the number of SFG operations used in E; the rank of E is max{ i I EXIT(i,n) or BREAK(i,-) occurs \nin E}; that is, the rank is the maximum depth of nested loops that are exited by an exit i statement \nin the program. NOTES : 1. L is always a finite relation. 2. Each node of an SFG can have at most two \nnumeric labels; that is, /L(n)-{~}1 s 2 for all nodes n. 3. An SFG can have any number of finish\u00ad  \nnodes but can have most one start node. Several features of our model are noteworthy: 1. We do not explicitly \nlabel the TRUE and FALSE branches; this information, though easy to incorporate, is superfluous for our \npurposes since randomly inter\u00adchanging the TRUE and FALSE branches leaves the underlying digraph, and \nhence the minimal-cardinality dissection, un\u00adchanged. 2. We only deal with graphs where the outdegree \nof each node is bounded by two. 3. Other models in the literature create individual nodes for the statements \nexit i or for the keywords loop and endloap  (sometimes called repeat and end respec\u00ad , tively in the \nliterature) [5,6,7]. we diverge from this practice for several reasons: Firstly, these statements (or \nkeywords) merely represent control infor\u00admation like the keywords then and else in an if statement and \ndo not constitute atomic actions as we understand them. Secondly, creating nodes for them destroys the \ncorrespondence between paths in the flowgraph and jump-free segments in the object code. Thirdly, what \nis merely graph isomorphism in our model becomes the more obscure very strong equivalence in the other \nmodels [7]. 4. Even though we have not formally de\u00adfined the relationship between a program and the expression \nfor it, it should be clear that we can get an expression for a program from a parse tree for it. 5. If \ndigraphs are to model programs ac\u00adcurately, it is essential that they in\u00adclude specifications of start \nand finish nodes, as our model does, since the same underlying digraph could represent dif\u00adferent programs \ndepending on the start/finish specifications. For in\u00adstance, the digraph: /4\\ c ------B represents the \nfollowing program if A is the start node and B is the finish node: if A then C else endif ; B However, \nif B and C are both required to be finish nodes, a more complex program is necessary: loop if A then \n if C then exit 1  else endif  else endif;  B; exit 1 end loop  6. We make no assumptions about whether \nor not Boolean expressions may have side effects; that is, we permit the case where the evaluation of \na predicate modifies the values of the other variables of the pro-Yram via, for example, function calls. \nThe models of [5] and [71 assume that predicate evaluation can have no side\u00adeffects. 4. DEFINITIONS \nSuppose G=(N,A,L) is an arbitrary but fixed SFG. A path in G is a simple directed path (in the usual \ngraph\u00adtheoretic sense) in the underlying digraph of G. Two paths Y1 and Y2 are disjoint iff they have \nno nodes in common and may be joined (by simply concatenating them) to get a new path iff they are disjoint \nand there is an arc from the end of Y1 to the beginning of Y2. A collection v of paths in G is a dissection \niff every node of G occurs in exactly one path of v. A dissection v of G is said to be optimal iff no \nother dissection of G has cardinal\u00adity lower than Ivl. The signature of a path Y that begins at the node \na and ends at b is denoted by sg(y) and de\u00adfined by: sg(y) = (L(a) ri {~}) U (L(b) -{~}); that is, the \nsignature consists of all the labels of b except ~ together with ~ if it labels a . A path )/ is called \na T-path iff sg(Y)=T, a start path iff it begins at the start node (i.e. iff ? G sg(Y)) and a finish \n_path iff it ends at a finish node. From NOTE 3 it can be seen that a dissection of G can have any number \nof finish paths but no more than one start path. If v is any dissection, we define a func\u00ad tion fv with \nrange in 1 and domain P(I+)-{@} by: fv(T) = min{lTl, the number of T-paths inv} This function is called \nthe character of the dissection v. It yields an equivalence relation . on dissections de\u00adfined by: V.w \niff fv(T) = fw(T) for all T~ 1+, T#@. That is, tWO dissections are equivalent iff they have the same \ncharacter. Figure 4 illustrates some of these concepts. For any collection D of dissections we de\u00adfine \nan optimal choice set of D to be any ... collection of dissections Y obtained by choosing from each \nequivalence class C of D, exactly one dissection whose cardinali\u00adty is minimal in C. We now define several \noperations on dissections; each operation is the analo\u00ad gue of an SFG operation and produces a set of \ndissections for a composite graph from dissections of the component subgraphs. Figure 5 illustrates these \noperations. Suppose E,E1,E2 are expressions, G,G1,G2 are their respective flowgraphs and V1 and V2 are \ndissections for G1 and G2 respec\u00ad tively. Any set whose definition below assumes the existence of certain \nstart paths or finish paths is understood to be void if such paths fail to exist. 1. If E=BREAK(i,El) \nthen BREAK(i,vl) = {Vi}. 2. If E=LOOP(E1) then LOOP(V1) = {Vi} Uw where W = All dissections of G that \ncan be obtained by joining a finish path of V1 to its start path. 3. If E=CAT(E1,E2) then CAT(V1,V2) \n= {v1 UV2} IM W where W = All dissec\u00adtions of G that can be obtained by joining a finish path of V1 \nto the start path of v2.  4. If E=IF(t,El) then IF(t,vl) = {Vlu {t}} u w where W = The single  di.ssecti.on \nfor G obtained by joining t to the start path of v1. 5. If E=ELSE(t,El,E2) then ELSE(t,vl,v2) = {vllJv2 \nU{t}} u Wwhere W=All dissections for G that Could be Ob\u00ad tained by joining t to the start path of V1or \nv2. We use the notation CAT1(V1,V2) to mean the dissection {v1 U v2} and CAT2(V1,V2) to mean the rest \nof the dissections (those obtained by joining a path from VI to a path from v2; the set called W in the \nabove definition). Similar definitions apply to the other operations. we will use OP(i,t,vl.v2) to mean \nany one of BREAK(i,vl) , LOOP(V1) , CAT(V1,V2) , IF(t,vl) or ELSE(t,vl,v2) . Likewise, 0P(i,t,El,E2) \nwill denote any of the corresponding five SFG operations. 5. THE MAIN ALGORITHM For each SFG the algorithm \nkeeps track of an optimal choice set of the class of all dissections of that SFG. Using a dynamic programming \napproach, we construct the choice set for a composite graph from the choice sets of the component graphs. \nThe size of this choice set grows exponential\u00ad ly in the rank of the program expression but does not \ndepend on the size of the program. For any fixed rank, the algorithm has quadratic time-complexity in \nthe size of the program. Since exits from more than one or two levels of loops are rare in practice, \nour algorithm is feasib e on a large class of programs. ALGORITHM OPT-DISSECTION INPUT An expression \nE. OUTPUT An optimal dissection v for the flowgraph of E. METHOD Call DISSECT(E,Y) and let v= rein(Y) \n, where rein(X) denotes an arbitrary minimal-cardinality member of X. DISSECT is the procedure in Figure \n6. The principal properties of our algorithm are summarized by the following theorems whose proofs are \npresented in the next section. THEOREM ~ The output v of the algorithm is an optimal dissection for the \nflowgraph of E. THEOREM ~ The r~nning time of OPT\u00ad3 O(r )n2 h DISSECTION is w ere r is the rank of Eand \nnis size of E. 6. PROOFS OF THEOREMS We require a few technical lemmas to prove these theorems. In what \nfollows, we will use graph-theoretic terms in connection with an expression; it is to be under\u00adstood, \nin these cases, that the terms refer to the flowgraph of the expression. Thus, if E is an expression, \nphrases such as the nodes of E, the arcs of E, the start node of E, the finish nodes of E, a path in \nE and a dissection of E, all refer to the flowgraph of E. LEMMA 1 SUpPOSe E, El and E2 are arbitrary \n. expressions and v is any dissection for E. (a) If E = EXIT(i,n) then v is the only dissection for \nE and Ivl = 1.  (b) If E = BREAK(i,El) then (i) For any dissection W1 of El, v G BREAK(i,wl) ==> Ivl=lwl/ \n (ii) There is a dissection W1 of El such that v g BREAK(i,wl).  (c) If E = LOOP(E1) then (i) For \nany dissection W1 of El, V f? LOOP1(W1) ==> IVI=IWII V ~ LOOP2(W2) ==> Ivl=lwll-1 (ii) There is a dissection \nW1 of El such that v CS LOOP(W1)  (d) If E = CAT(E1,E2) then (i) For any dissections w1, W2 of El, \nE2 respectively, v e CAT1(W1,W2) ==> IVI=IW11+IW21 v e CAT2(W1,W2) ==> IVI=]W1[+IW21-1 (ii) There are \ndissections w1, W2 of   El, E2 respectively such that v e CAT(W1,W2) (e) If E = IF(t,El) then (i) \nFor any dissection W1 of El, V G IFl(t,wl) => IVI=IW1 +1 v ~ IF2(t,Wl) => lvl=lwl (ii) There is a dissection \nW1 of El such that v ~ IF(trwl) (f) If E = ELSE(t,El,E2) then (i) For any dissections w1, W2 of El, E2 \nrespectively, V ~ ELSEl(t,wl,w2) ==> /vl=lwl\\+lw21+l V G ELSE2(t,wl,w2) => IVI=IW11+IW21  (ii) There \nare dissections Wlr W2 of  Elr E2 respectively such that V f2 ELSE(t,wl,w2) Proof: The proof is very \nsimple in all cases and we illustrate the general idea by proving (d). Suppose E=CAT(E1,E2); the conclusions \nof (d) (i) follow directly from the definitions of CATl and CAT . (Section 4). For (ii) there are tw: \ncases: Case 1. Every path of v is contained en\u00ad . tirely either in El or in E2. Hence we can write v \n= V1 U V2 where the paths of V1 are entirely from El and those of V2 entirely from E2. Setting W1 = V1 \nand W2 = V2 we see that (ii) follows. Zase 2. . There is a path p in v which is the concatenation of \npaths ql and q2 with J1 entirely in El and q2 entirely in E2. ~e can therefore write v = VI UV2 u {p} \nflhere the paths of V1 are entirely in El and those of V2 entirely in E2. we set #l =V1u{ql} and W2=V2u{q2} \nand now (ii) follows. LEMMA (2) Suppose E, El and E2 are expres\u00adsions, V1 and wl are dissections for \nEl, and V2 and W2 are dissections for E2. (a) If E = BREAK(i,El) and V1 -W1 then we BREAK(i,wl) => v \n-w for some Ve BREAK(i,vl). (b) If E = LOOP(E1) and V1 . WI then we LOOP1(W1) => v -w for some Ve  \noopl(vl); w ~ LOOP2(W1) => V -W for some v G LOOP2(V1), (C) If E= CAT(E1,E2) , V1 -W1 and V2 -w2, then \nw G CAT1(W1,W2) => v -w for some v e CAT1(V1,V2); w e CAT2(W1,W2) ==> v -w for some v e CAT2(V1,V2). \n (d) If E = IF(t,El) and V1 -w1, then WG IF1(t,wl) ==> V.w for some Ve IF1(t/vl);w @ IF2(t,wl) ==> V \n-W for some v G IF2(t,vl).  (e) If E = EL5E(E1,E2), VI -WI and  V2 . W2 , then w ~ ELSEl(t,wl,w2) ==> \nv-w for some v G ELSE (t,vl,v2) 1> W G ELSE2(t,Wl,w2) =. >V. w for some V G ELSEo(trvl/v2). We illustrate \nthe idea of the proof by proving (c); the others are similar. Suppose E = CAT(E1,E2), V1 -W1 and V2 -w2. \nIn the following, it must be borne in mind that the signature of a path in El may not be the same as \nits signature in E since the two SFGS have different la\u00adbeling relations. It should be clear from the \ncontext which signature is meant. There are two cases to consider: Case 1 w G CAT1(wl,w2) Let v be the \nunique element of CAT1(V1,V2) . NOW i for any T, we claim that fw(T) = O iff fv(T) = O. Suppose p is \na T-path of v; we will show that w must contain at least one T-path. This proves one implication in our \nclaim; the other follows by symmetry. There are two cases to consider depending on whether p is con\u00adtained \nin VI or in v2. Suppose p is a path in V1 (the other case is similar). Since V1 -w1, there must be a \npath p in W1 with the same signature as p in El. This path p therefore is a T-path of w and our claim \nis proved. We now claim that fw(T) = 2 iff fv(T) = 2. Suppose fv(T) = 2. Then, v has at least two T-paths, \nsay, pl and p2. Four cases arise depending on whether each is from V1 or v2. Suppose, P1 is in VI and \nP2 in V2 (the other cases are similar) . Since V1 -W1 and V2 . w2, there must be paths $ pl in WI and \np2 in W2 with the same sig\u00adnatures as pl and p2 respectively. There\u00adfore pl and p2 are two T-paths in \nw and so, one implication of our claim is proved. The other follows by symmetry. These two claims together \nprove that v and w are equivalent under . . Case 2 w G CAT2(W1,W2) - By the definition of CAT2, we can \nwrite w = (Wl -{pi}) u (W2 -{P2}) u {PI P2} for some finish path pl of WI and the start path p2 of w2. \nSince V1 . W1 and V2 -w2, there are paths ql in V1 and q2 in V2 with the same signatures as pl and p2 \nrespectively. Let v be the element of CAT2(V1,V2) defined by: v= (Vl -{ql}) u (V2 -{q2}) u {ql q2} As \nbefore we can prove that v and w have the same character by proving the two path in V1 (the other case \nis similar). Since V1 -w1, there must be a path p* in W1 with the same signature as p in El. This path \np-therefore is a T-path of w and our claim is proved. We now claim that fw(T) = 2 iff fv(T) = 2. Suppose \nfv(T) = 2. Thenr v has at least two T-paths, say, pl and p2. Four cases arise depending on whether each \nis from V1 or v2. Suppose, P1 is in V1 and p2 in V2 (the other cases are similar). Since V1 . W1 and \nV2 -w2, there must be paths pl in wl and p2 in W2 with the same sig\u00ad natures as pl and p2 respectively. \nThere\u00ad fore plp and p2 are two T-paths in w and so, one implication of our claim is proved. The other \nfollows by symmetry. These two claims together prove that v and w are equivalent under -. Case 2 w G \nCAT2(W1,W2) - BY the definition of CAT2, we can write w= (Wl -{Pi}) u (W2 -{P2}) u {Pl P2} for some finish \npath pl of W1 and the start path p2 of w2. Since V1 . W1 and V2 . w2, there are paths ql in V1 and q2 \nin v2 with the same signatures as pl and p2 respectively. Let v be the element of CAT2(V1,V2) defined \nby: v= (Vl -{ql}) IJ (V2 -{q2}) IJ {ql q2} As before we can prove that v and w have the same character \nby proving the two claims : fv(T) = O iff fw(T) = O fv(T) = 2 iff fw(T) = 2 The proof of these claims \nfollows directly from the facts that V1 . w1, V2 -w2, sg(pl) = sg(ql) and sg(p2) = sg(q2). This completes \nthe proof of lemma 2. For any r ~ I and any TQ1, let max(T) = the largest element of T and Q(r) ={XL21+ \nmax (X-{ }) <r and lx-t} S2} LEMMA (3) (a) For any r G1, IL(r)l = r2 3r-3 (b) If E is any expression \nof rank r, then  I{f z I w is a dissection of E}I = ~o(l! ). Proof: (a) A simple combinatorial argument \nshows that lQ(r)l = 2[(r~1)+ ~r~l)l + 1  (b) From NOTE (2) and the definition of rank it follows that \n fw(T)+O ==> max(T-{~}) ~ r and [T-{~}1 s 2. Using this fact and NOTE (3) we see that Os fw(T) s 2 for \nall T and w. The result now follows from part (a). LEMMA (4) If Y is the output of PROCEDURE DISSECT \nand r is the rank of the input ex\u00adpression, then (a) Distinct elements of Y have distinct characters.2 \n (b) IYI = 3\u00b0[r . Proof:  (a) To form Y we choose exactly one ele\u00adment from each equivalence class \nof D. (b) This follows from (a) and Lemma 3.  Proof of Theorem 1: . The statement of the Theorem is \na simple consequence of the following assertion: If Y is the output of DISSECT(E,Y) and w is a dissection \nfor E, then v. w and Ivl s Iwl for some veY. (*) We now prove assertion (*) by induction. Suppose Y \nis the output of DISSECT(E,Y) and w is a dissection for E. Then, either E = EXIT(i,n) in which case w~D \nand the result follows directly. or E = 0P(i,t,El,E2) for some expressions Elr E2 and some op e {BREAK, \nLoop, IF, ELSE, CAT]. In this case, by LEMMA 1, there are dissections wl and W2 for El and E2 respectively \nsuch that w ~ 0P(i,t,wl,w2). Assuming inductively that assertion (*) holds for the smaller expressions \nEl and E2 we see that there are dissections V1 and V2 for El and E2 respectively such that: V1 -Wlr VI \ne Yl, \\vll s Iwll, V2 . W2, V2 e Y2, IV21 ~ IW21. Using Lemmas 1 and 2 we see that Iv 1 s Iwl and v \n-w for some v ~ 0P(i,trvl,v2). From the way D was created we see that v ~ D. The conclu\u00adsion of assertion \n(*) now follows since a minimal-cardinality member from the equivalence class of v must have been included \nin Y. Proof of Theorem 2. The cost of a single call to DISSECT is (exclusive of recursion): Cost to \ncompute D + Cost to compute Y from D. Since IYll = IY21 = 3\u00b0(r2) from Lemma 4, it follows that the cost \nto compute D (from 31 and Y2~ is: ~O(r ).30(r ). O(n) = 3\u00b0(r2)n The last for loop of Procedure DISSECT \ncan be rewritten: for each v in Ddo _ for each win Ydo ._ ifv-w then if [vI < \\wl then Y := (Y -{w}) \nu{v} end ~; exit (* start next iteration of outer loop *) end if; end for  . Y := Yu {v} end for (* \nof outer loop *) The outer loop is executed 3\u00b0(r2)n times (ID12 times); the inner loop is executed 3\u00b0(r \n) times (IYI times), and each itera\u00ad tion involves a comparison of two charac ters, fv and fw (the other \nsteps take con\u00adstant time) . By Lemma 3(a) , the comparis\u00adon of two characters involves no more than \n0(r2) elementary comparisons. Hence the cost of computing Y from D is the product three quantities which \nis still $(r?;:se . Since there can be at most n calls to DISSECT, the total running time of the algorithm \nis as asserted by the theorem. 7. DISCUSSION AND CONCLUDING REMARKS We have provided an algorithm that \nfinds a minimum-jump translation for programs built using if-then-else, loop-endloop, and multi-level \nexit statements. A wide variety of control structures, such as the repeat-until and while loops of Pascal \nand when. ..exit of Modula are subsumed as spe\u00ad cial cases by our model. Our algorithm can be used to \nperform jump minimization in any object module, regardless of the compiler that produced it, provided \nit represents a reducible flowgraph; one need only apply the program structuring algo\u00adrithm of [4] or \n[8] to get a structured program from the flowgraph and use this as input to our dissection algorithm. \nObvi ously the efficiency of this procedure depends on the efficiency of the program structuring algorithm \nand also on the rank of the program it produces. The problem of producing a minimum-rank program from \na given flowgraph needs further investiga\u00ad tion. Our jump minimization algorithm can also provide a good, \nthough not necessarily op\u00adtimal, translation for irreducible flow\u00adgraphs. We identify a set of arcs that \ncan be deleted to leave a reducible flow\u00adgraph which has all the nodes of the ori\u00adginal irreducible flowgraph \nand then find an opt imal dissection for this residual flowgraph. Obviously, the smaller the number of \narcs deleted, the better the chance that the result of this procedure is close to optimality. Finding \nsuch a set of arcs to delete is not hard (we could, for instance, do a depth first search and delete \nall back arcs) though finding one with the smallest number of arcs could be. This suggests a question \nanalogous to the problem of finding a minimum feedback-edge set for digraphs: Given a flowgraph G and \na positive integer K, does G have a set of K or fewer arcs which, when deleted, leave a reducible flowgraph \n? Whether the Dissection Problem is NP\u00adcomplete for reducible flowgraphs is an open question. We conjecture \nthat the Hamiltonian Path problem is NP-complete even for the restricted class of flow\u00adgraphs which are \nacyclic except for a sin\u00adgle incoming arc to the start node. Performing jump minimization could affect \nother code improvement procedures. For instance, preliminary evidence suggests that generating code for \nmachines that have long and short branch instruc\u00ad tions [9] after performing jump minimiza\u00ad tion is likely \nto yield better code than doing it before. Another related issue that will bear investigation is the \nimpact of jump minimization on the dynamic behavior of the program in a multiprogram ing environment: \nit appears likely that the number of page faults and cache misses will be favorably affected. of theoretical \ninterest are the connec\u00ad tions between the cardinality of an op\u00ad timal dissection of a digraph and certain \ngraph theoretic parameters. Let d(G) denote the cardinality just adverted to. Two nodes x and y in a \ndigraph G are called sc independent iff neither (xry) nor (y,x) is an arc of G; they are called path \nindependent iff there is no (direct\u00aded) path from x to y and there is no directed) path from y to x in \nG. The maximum number of arc independent nodes in G is called the stability number of G, denoted d(G) \n[101. The maximum number of path independent vertices in G is called the path independence number of \nG, i(G) . Thenr we have: i(G) s d(G) <c.((G). The first inequality is easy to see; the second is proved \nin [11] (an English translation of the proof appears in [10]). It is easy to show by means of simple \nex\u00adamples that all three of these parameters could , in general, be distinct. Whether, and under what \nconditions, equality ob\u00adtains remains to be investigated. Finallyr the time bounds of Theorem 2 can probably \nbe improved. For example, we have a linear-time algorithm for programs that do not use exit statements \nand con\u00adtain only if-then-else and repeat-until structures [12]. A more complicated, but still linear \nalgorithm can also handle while structures. It appears likely that even in the general case, a llnear \nalgo\u00adrithm is possible provided rank is bouned by a constant. 8. REFERENCES [1] M. R. Gag:? and D. S. \nJohnson, Com\u00adputers Intractability -A GiiiZi6 - to the T~ry of NP-Completeness, W. ~ ~e-a~Ftincisco (1979). \n[2] J. Plesnik, The NP-completeness of the Hamiitonian cycle-problem in planar digraphs with degree bound \n2, Information Proc. Letters 8_, 4, pp. 199-201 (Apri~79). [3] F. T. Boesch and J. F. Gimpel, cov\u00ad ering \nthe points of a digraph with point-disjoint paths and its applica\u00adtion to code optimization, Journal \nof the ACM 24, 2, pp. 192-198 (April 1977).  [4] T. Kasami, w. W. Peterson, and N. Tokura, On the capabilities \nof while, repeat, and exit statements , CACM 16, 8, pp. 503-512 (August 1973). [51 S. R. Kosaraju, Analysis \nof struc\u00adtured programs, Journal of Comp. and . Sci. ~, 3, pp. 232-255 (1974). =. [6] J. C. Cherniavsky, \nP. B. Henderson, and J. Keohane, On the Equivalence of . URE Flowgraphs and Reducible F l= Graphs, Proc. \n197~onf. on Inf. Sci. and Sys., Johns Hopkins University (). [7] H. F. Ledgard and M. Marcotty, A Genealogy \nof Control Structures, Comm. of the ~ ~ , PP. 629-639 m5).  [81 B. S. Baker, An Algorithm for Struc\u00adturing \nFlowgraphs, Journal of the ACM 24, 1, pp. 98-120 (January ~77).  [9] T. G. Szymanski, Assembling code \nfor machines with span-dependent instruc\u00adtions, CACM 21, 5, pp. 300-308 (April 19T [10] C. Berge, Graphs \nand Hypergraphs, North Holland, Amsterdam (1973). [11] T. von Gallai and A. N. Milgram, Verallgemeinerung \neines Gra\u00adphentheoretischen Satzes von Redeir Acts. Sc. Math. ~ , pp. 181-186 -(-I!T6O )T-- [12] M. V. \nS. Ramanath and M. H. Solomon, Generating optimal code from flow\u00adgraphs, Computer Languages, (1982) To \nappear. loop if B1 then S1; exit 1 endif; mop if B2 then S2; exit 1 endif; E if B3 then S3; exit 1 \nendif. ~ B4 then exit 1 endi~ = B5 then ~ 3 endif; endl~p;  if B6 then exit 1 endif; ~ B7 ~ ~ 2endlf \n endl~p; if B8 then exit 1 endif; _ a  endloop; _ S5 (a) The Source Program START:ifnBl then L2 S1 \njump M5 L2:if~B2 then L3 S2 jump L8 L3:if7B3 then L4 S3 jump L6 L4:if B4 then L6 if B5 then M5 jump L3 \nL6:if B6 then L8 if B7 then M5 jump L2 L8:if B8 then M5 S4 jump START !45;s5 (b) The standard translation \nL4:if B4 then L6 if B5 then M5 L3:ifq B3 then L4 S3 L6:if B6 then L8 if B7 then M5 L2:iflB2 then L3 S2 \nL8:if B8 then ?45 S4 START:iflBl then IL2 sl M5:S5 (c) An optimal translation FIGURE 1 A program and \ntwo translations Loo? (MT E1.sE t ? S(GN )(!!)GI i%i) m FIGURE 3 SFG Operations E = ELSE (nl,ELSE(n3rEXIT(2 \nBREAK(EXIT(l,n5) ,n7),n6),CAT(IF(n2, ,3) ),EXIT(2,n4))) if nl then if n3 then if n~en exit 2 ~dif  else \nn6 endif else if n2 then ~ n-en exit. endif ; exit 3 endif ; ~ then exit 2 ~dif  endif 1 FIGURE 2 Jiia13{ \nT} nl ($) n2 $ n3 n4 n5 n6 n7 {0,2} {1,3} h} {0,2} The dissections FIGuRES corresponding lb and lC to \nAn FIGURE 4 expression, its program, and its flow graph 93 v = {pi, p2, p3, p4} procedure Dissect(E;var \nY) ; (* E is an expression ; the procedure pl = (nl,n3,n6) Sg(pl) = {1,0} returns an optimal choice set \nin Y. *) p2 = (n2,n4) sg(p2) = {0,2} begin p3 = (n5) sg(p3) = {1,3} if E is of the form EXIT(i,n) then \n p4 = (n7) sg(p4) = {0,2} Let D = {u} where u is the unique 2 if T = {0,2} dissection of the flowgraph \nof E; fv(T) = 1 if T = {1,3} or {0,~} else O for all other T. (* E = 0P(i,t,El,E2) for some expressions \nEl, E2 and some SFG FIGURE 4 (Continued) A dissection of E and its character operation OP, other than \nEXIT. *) Dissect(El,Yl); Dissect(E2,Y2); Let D = { v \\ v G 0P(i,t,vl,v2) , * for some V1~Y1and V2~Y2} \nendif; :=  ((/ i Y ~: __ for each equivalence class C of D (under .) doLOOP(VI) Y := Y Umin(C) b \nt Y-i L_/-Q A end for A/ ,/ / / A/ A\\ end; (* of procedure Dissect *) A_ ~ l-\u00ad p)~/d)  - \\-  FIGURE \n6 \\ \\_- /\\ / jt) -J. r\\ \\ The procedure DISSECT b* v /\\ / \\ /1 c- > !/ /\\ ,/ , / j, L-) L--) (-.) \n,l\\,/\\ t i--.--, 1#\\ L . . ..-. L---.; CAT(V1,V2)  A/,\\S/2A 1~ /\\ E \\ \\ \\ I -j\\ L-; L_ ! L.__.-l ELSE(t,Vl,V2) \nQ Ii IF(t,vl) FIGURE 5 Operations on dissections 94  \n\t\t\t", "proc_id": "582153", "abstract": "", "authors": [{"name": "M. V. S. Ramanath", "author_profile_id": "81100515502", "affiliation": "University of Western Ontario, London, Ontario, Canada", "person_id": "P182969", "email_address": "", "orcid_id": ""}, {"name": "Marvin Solomon", "author_profile_id": "81452606415", "affiliation": "Universiy of Wisconsin, Madison, Wisconsin", "person_id": "PP43136723", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/582153.582163", "year": "1982", "article_id": "582163", "conference": "POPL", "title": "Optimal code for control structures", "url": "http://dl.acm.org/citation.cfm?id=582163"}