{"article_publication_date": "01-25-1982", "fulltext": "\n Programming Aspects of VLSI (Preliminary Version) Richard J. Lipton Department of Electrical Engineering \nand Computer Science Princeton University Princeton, NJ Roberf Sedgewick Computer Science Department \nBrown University Providence, Rl Jacobo Valdes Department of Electrical Engineering and Computer Science \nPrinceton University Princeton. NJ Abstract: Two components of a VLSI design environment being built \nat Princeton are described. The general theme of this effort is to make the design of VLSI circuits as \nsimilar to programming as possible. A conscious attempt is being made to apply experi\u00adence in the design \nof large software systems to the creation of an appropriate environment for VLSI circuits. The two components \ndescribed are a procedural language to specify circuit layouts and a switch-level circuit simulator for \nlayout produced with this language. They have been chosen for presentation because many issues in their \ndesign are very similar to the issues that arise in the design of programming languages and software \nenvironments. 1. Introduction In this paper we describe two of the most important components of a VLSI \ndesign environment: a layout language and a switch level circuit simulator. Both systems grew out of \nan effort to create an integrated environment for VLSI design (including layout systems, device and switch \nlevel simulators and testing facilities) currently under way at Princeton. Our main thesis is that the \nVLSI design task can be profitably thought of as a programming task, and that much is to be gained by \nconsciously attempting to apply knowledge about of programming to this new activity, Thus we have given \nmuch weight to principles learned dur\u00ading the travel from absolute machine language program\u00adming to the \nuse of high level languages, such as working in as high level a language as the efficiency of the final \npro\u00adduct permits, creating tools in which the division of tasks among designers can be easily done, and \nmaking sure that Permission to copy without fee all or part of thu material is granted provided that \nthe copies are not made or distributed for dkect comntereid advantage, the ACM copyri@t notim and the \ntide of tie publication and its date appear, and notice is given that copying is by permission of the \nAssociation for Computing MachhmV. To copy otherwise, or to repubtish, mqui~ a fee and/or sP~inc Wmti*ion. \n@ 1982 ACM 0-89791-065-6/82/001/0057 $00.75 the tools are extensible. We feel that this approach has \nhelped us create better tools for some of the central tasks of VLSI design. We also know that there is \nmuch room for improvement and would like to help convince the community of people interested in programming \nlanguage design that there are fresh and important challenges in this relatively new direc\u00adtion. The \nremainder of this paper is divided into two main sections. The section that follows is devoted to describe \nALI, our layout specification language. This is the one tool in our system where most of the familiar \nprogram\u00adming issues arise so more space is devoted to its descrip\u00adtion, A shorter section describes a \nswitch level simulator for layouts generated with the aid of ALI. 2. ALI: an overview ALI is a procedural \nlanguage to describe VLSI iay\u00adouts. It differs radically in its basic philosophy from most current systems \nfor this task in that it simultaneously (i) makes the layout task more like programming than editing. \n(ii) eliminates the need for design rule checking after the layout is generated, (iii) permits the creation \nof truly flexi\u00adble and general purpose libraries of frequently used layout pieces and (iv) provides the \ndesigner with the mechanisms to describe a layout hierarchically so that objects at one level of the \nhierarchy are truly hidden from other levels. Many of these advantages are gained through a delayed binding \napproach: the user may not specify the absolute location or the size for any element of the layout. These \npositions and sizes are determined after the whole layout has been completely specified at a conceptual \nlevel. In the sections that follow we review the principles on which the language is based, describe \nits operation and provide a short discussion of why we feel that our approach to layout design has advantages \nover those of other procedural layout languages and over the more popu\u00ad lar graphics-based systems. \n2.1. General principles The basic principles of ALI are quite simple. A lay\u00adout is regarded as a collection \nof rectangular objects with their sides oriented in the direction of the axis of a carte\u00adsian coordinate \nsystem, and a set of relations among these rectangles. The ALI user specifies a layout by declaring the \nrectangles of which it is composed, and stating the relations that hold between them. To declare a rectangle \nthe ALI user specifies its name and its type. The types of ALI have the same structure as the Pascal \ntypes. A rectangle can be of a simple ~pe (hav\u00ading no internal structure) or of a smuctured &#38;pe. \nThere are a small number of standard types for rectangles, all of them simple, The structured types are \nthe array (a collection of rectangles of the same type) or a bus (a collection of rec\u00adtangles of heterogeneous \ntypes), which correspond directly to the array and record structured types of Pascal. ALI, like Pascal, \npermits the creation of new user defined types that can be either simple or structured. Also like Pascal, \nit is a s(rongly typed language, The relations between the rectangles that make up a layout are specified \nin ALI through calls to a small set of primitive operations. All such operations take as argu\u00adments rectangles \nof simple types. As an example, one such operation is touches. which indicates that its two argu\u00adments \n(which must be of the same simple type) have a certain amount of area in common. There are other opera\u00adtions \n(such as above, below, /eft, and right) which allow the user to state that two rectangles (of any simple \ntype) are separated in the direction of the cartesian axes by a minimum distance (supplied by ALI) that \ndepends on their types. Other primitive operations allow the user to connect rectangles of different \ntypes, to create pass transistors or implanted transistors, specify minimum sizes for rectangles and \nso on. It is not important to know the actual primitive operations of the current version of ALI to understand \nits operation, As a gross measure of its complexity we can say that our current prototype, which is based \non NMOS, has about twenty primitive relations. Most of these primi\u00adtives are dictated by peculiarities \nof NMOS. A much smaller set of primitive operations (maybe six) are truly needed; all the others can \nbe written in terms of the more basic ones. It is important however to know that ALI expects any two \nrectangles in a layout to be related in some way, and will make no inferences beyond those implied by \nthe transitivity of some primitive operations (i.e., if a is above b and b above c it need not be expli\u00adcitly \nstated that a is above c). Notice that ALI does not allow its user to spect~ abso\u00adlute positions or dimensions \nfor any rectangle. All the rectan\u00adgles of a layout can be stretched and compressed (up to a minimum size \nwhich depends on their type) and all can float in any direction. If one single characteristic is to used \nto separate ALI from all otner layout systems we know ot. this must be it. Most of the power of ALI and \nmost of the problems one faces while implementing ALI are conse\u00adquences of this fact, Perhaps the most \npowerful feature of ALI is its procedure-like mechanism for the definition and creation of cells. By \na cell we mean a rectangle which has some internal structure more complex than that of an array or bus. \nA cell is a collection of related rectangles enclosed in a rectangular area. Rectangles that are inside \na cell are of two types: /oca/ which are invisible to the outside, or parameters which ean interact in \na simple and well defined manner with rectangles outside the cell. A cell is defined by specifying its \nlocal objects. its for\u00admal parameters and the relations between them. Once a cell has been defined, it \ncan be instantiated as many times as desired by specifying the actual parameters for the instance, much \nthe same way as one invokes a procedure or function in a procedural language. The result of instan\u00adtiating \na cell is to create a brand new copy of the prototype described in the cell definition with the formal \nparameters g/ued (another primitive operation) to the actual parame\u00ad ters. A pictorial oversimplification \nof the relationship between a cell definition and an instantiation is shown in Fig. 1. a m Definition: \ncell f (left a : II; top b : t2); ... end; Y b xiih 43 Creation: create J (x, y ) named n; Fig, 1 A \nsimple representation of a Cell definition and of an instance of the cell. When an instance of a cell \nis created it can be given a name, provided that the name given has been declared as a rectangle of the \nstandard simple type virrua/. The rela\u00adtionship of the rectangle bounding a newly created cell to any \nother rectangle of the layout can be specified in the standard manner by calls to the primitive operations. \nThis is a powerful mechanism since in many cases (i.e., above, be/o w...) specifying a relation between \ntwo cell instances c1 (4) The cell definitions (see the definitions of whife and and C2immediately implies \na relation between every pair of rectangles rl and rl such that rl is part of c1 and rz part of Cz. Other \nways in which cell instantiation helps define implicit relations between layout elements is explained \nin the next section. The cell mechanism gives the ALI user the ability to describe layouts in a truly \nhierarchical manner, A proper design, very much like a well structured program, will con\u00adsist of a hierarchy \nof cell instances with only a small amount of information at a given level (the parameters of the cell \ninstances at that level) being visible from the immediately higher level. Much of the power and generality \nof the cell mechanism of ALI comes from the absence of absolute positions and sizes in a layout specification. \nIn particular, two instances of the same cell may have radically different sizes depending on the actual \nparameters used to create them. We believe that no cell mechanism can be said to be truly general unless \nthe sizes of its arguments and local rectangles, as well as their relative distances are deter\u00admined \nat the time the cell is instantiated. 2.2. An AL1 program In an attempt to make the description of the \nprevi\u00adous section a little more concrete we will now exhibit a simple ALI program and discuss some of \nits features. Our current prototype system has been implemented as a superset of Pascal t and therefore \nALI programs look very much like Pascal programs as exhibited by the sample pro\u00adgram of fig. 2. The ways \nin which this program differs from a Pascal program and some details of the semantics of ALI not described \nearlier are explained briefly in the following para\u00adgraphs. (1) The header is trivially different from \na Pascal pro\u00adgram header. (2) The boxvpe section is an addition to Pascal. In this section user defined \ntypes for rectangles are described. In our example mera/ and POO are stsn\u00addard ALI types (corresponding \nto the NMOS layers of metal and polysilicon) and power, ground, vrp and htp are user defined types. \n(3) The boxvar section is an addition to Pascal. In it the symbolic names of the rectangles that make \nup the layout are defined and given a type. Thus, in our example hc, vc and squares are created, each \none a structured rectangle having several component rec\u00adtangles which can be accessed through the standard \narray indexing and record field extraction mechan\u00adisms of Pascal. The type virtua/ is a standard ALI \ntype used to indicate that those variables will become cell instances.  tThis wasdone to speed up implementation. \nNo lasting commitment to Pascal as a base language has been made. Muck) are also additions to Pascal. \nWe have not given bodies for the cells of our example to avoid making it too long, but cell bodies have \nthe same general form as ALI programs. Note that the header of a cell definition not only specifies what \nparameters and of what type are required to instantiate the ceil but also specifies where (on which side \nof the rectan\u00ad gle that encloses the cell) the actual parameters are to be located (i.e., left, right, \ntop or bottom). When more than one parameter is specified for a cell side, the convention is that the \norder in which the param\u00ad eters are given determines their left-right (for the top and bottom sides) \nor top-bottom (for the left and right sides) order. Although not used in the example, this is a very \npowerful convention which can be used to implicitly define relations between many rectangles by simply \nusing them as arguments in a cell instantiation. Another convention that allows the implicit specification \nof many relations among rectangles in an intuitive way is the following. When a rectangle of a structured \ntype is passed as a parameter, as in our example, a left-to-right or top\u00adto-bottom order for its component \nrectangles is implicit. This order is the one generated by applying the following two rules recursively: \narray elements are ordered from lower bound to upper bound and record fields in the order in which they \nare listed. (5) The use of creare in the executable part of the ALI program is another addition to Pascal. \nThe effect of create is to instantiate a cell definition, possibly giv\u00ading a name to the instance being \ncreated. An impor\u00adtant effect of instantiating a cell is that the actual parameters given are related \nto the resulting rectan\u00adgle by the fact of being passed as parameters. Thus the instantiation aeate white \n(nt, nb, nl, nr) named sil!v would immediately imply that nt is above silly. It is quite common that \nmost of the relations between rectangles in a well structured layout are specified in this implicit way. \n (6) Finally, our example contains calls to the procedures obove and left which are not defined. These \nare ALI primitive operations. [ This program lays OU(a checkerboard-like pattern made up of two dflerem \ntypes of cells like the one pictured below ] chip checkerboard; const nrows = .... { number of rows ) \nncols = .... { number of columns 1 n boxtype . . power = metal; ground = metal; Vtp = array [1..21 of \npoly; { vertical links) htp = bus ( horizontal links} vdd: power; gnd: ground; data : metal; end; boxvar \nhc : array [0.. nrows, O..ncols] of htp; { vertical connectors] vc : array [0.. nrows, O..ncolsl of vlp; \n( horizontal connectors) squares : array [1.. nrows, 1.. ncolsl of virtual; { the squares of the board) \n Var row, col : integer; function samepari(y (x, y : integer) : boolean; begin samepariw: = not odd \n(x -+ y ) end; NCt\u00ad cell white (top t:vtp; bottom b : vtp; left 1: htp; right r: htp ); I-i71 { ...Here \ngoes the dejnition of the bo~ of a white cell... j end; cell black (top t:vtp; bottom b : vtp; left \nI: htp; right r : htp ): { ...Here goes the definition of the body of a black cell... ) end;  begin \n( lay out the checkerboard pattern) for row := 1 to nrows do for COI: = 1 to ncols do if sameparitv (row, \ncol) then create white ( vc[row-1, COI-1], vc[row, COI-1], hc[row-1, COI-11, hc[row-1, coIl) named squares[row, \ncot] else create black ( vc[row-1, cot-l], vc[row, COI-11, hc[row-1, COI-11, hc[row-1, coil) named squares[row, \ncoIl; end. An AL] program and a pictorial 2.3. From ALI program to layout The semantics of an ALI program \nare the following. Every time a call to a primitive operation is encountered during the execution of \nan ALI program, a few linear ine\u00adqualities that involve the coordinates of the corners of the rectangles \nare generated. These inequalities consfrain the sizes and relative positions of the rectangles that make \nup the layout. The solution of the set of linear inequalities generated during the execution of an ALI \nprogram consti\u00adtutes the layout described by the program. The linear ine\u00adqualities are generated and \nsolved so that the resulting lay\u00adout will have the bounding rectangle of smallest dimen\u00adsions among all \nthose that satisfy the relations stated in the program. The inequalities generated by the primitive relations \nbetween rectangles are selected to guarantee that the resulting layout will satisfy some set of design \nrules [9]. These rules are, in principle, sufficient to guarantee that the circuit represented by the \nlayout can be fabricated. Fig. 2 representation of the layout it defines. The fact that the layout process \nis design rule driven means that there is no need for a costly design rule check step to verify the validity \nof a layout generated by ALI. Not every possible ALI program specifies a realizable layout. A trivial \nway in which an ALI program may fail to do so is by describing an impossible situation such as a is above \nb, b above c and c above a . An ALI program which is free from errors of this type will be said to be \ncon\u00adsis~ertt. Another way in which an ALI program may fail to specify a valid layout will be to have \ntwo objects in the ALI program that are not related in any way (i.e.. they do not touch , neither one \nis above or below the other, nor are they related by any other primitive opera\u00adtion). An ALI program \nis comp/ete if it does not contain any errors of this kind. A consistent and complete ALI program specifies \na layout. We clearly would like to be able to determine whether an ALI program is consistent and complete \nefficiently. We also need to solve efficiently the large number of linear inequalities that ALI programs \nwill gen\u00aderate. A brief description of the computational complexity issues that these problems pose and \nour solutions for them can be found in the next section. 2.4. Complexity issues in the implementation \nof ALI We have just described three non trivial computa\u00adtional problems that had to be solved in any \nALI imple\u00admentation: determining whether an ALI program is con\u00adsistent and complete, and solving the \npossibly very large system of linear inequalities generated by an ALI program. We will now describe briefly \nhow these problems are han\u00addled. Before discussing the details however, it is important to realize that \nVLSI circuit layout is one area where the asymptotic behavior of an algorithm is truly important. The \nnumber of objects that have to be manipulated is quite large (106 or more rectangles may be part of a \nlarge commercial layout today) and is growing rapidly, Perhaps less obvious is the fact that the space \nrequirements of an algorithm can be more critical than its running time. Linear time algorithms may not \nbe acceptable if they require also linear space: storing 106 objects approaches the limits of the address \ncapabilities on most of today s medium size machines and solutions that use secondary storage in a substantial \nway will in all likelihood be too S1OW.It is therefore essential for the tool designer to keep in mind \nthe time and space complexity his or her tools. We will discuss fust the problem of testing con\u00adsistency \nand completeness and then describe how to solve the systems of linear inequalities produced by ALI pro\u00adgrams. \nConceptually, the solutions to completeness and con\u00adsistency checking are simple: testing consistency \ntranslates into checking whether a directed graph is acyclic, and test\u00ading completeness involves finding \nthe transitive closure of two graphs, taking their union and testing a simple predi\u00adcate on the resulting \ngraph. There are however some practical problems. The most severe is that transitive closure is too expensive \nan operation to consider in this case since it requires roughly O (n3) time and O (n2) space, and n can \nbe very large. Even the test for a cycle which may appear to be as simple a solution as one could ask \nfor (requires linear time) may require too much space (linear space is needed in the worst case). Fortunately \nthese problems can be solved efficiently in most practical cases by observing that they can be tested \non a cell by cell basis. This observation leads to a solution that checks the consistency and completeness \nof a layout generated by an ALI program by checking it level by level along the hierarchy of cell instances \nthat defines the layout. Thus the n in the time and space complexities of the pro\u00adcess turn out to be \nthe maximum number of rectangles in a cell, a distinct improvement over the total number of rectangles \nin the whole layout for well structured lay \u00adouts. Hierarchical designs are therefore favored in ALI \nfor reasons other than readability or aesthetics. This idea of hierarchical solutions appears to us a \npromising paradigm for dealing with problems of this type in which the total number of objects to be \nmanipulated is enormous but they are --in most practical cases --reason\u00adably well organized in a tree-like \nhierarchy with small depth and a reasonably small branching factor. We turn now to the question of how \nto solve the very large systems of linear equations that ALI programs will produce, At the moment we \nsolve this problem by avoiding it: our set of primitive relations between rectan\u00adgles is rich enough \nto specify a layout and restricted enough so it will only generate linear equations of the form (~,hxj)> \nd (d>O) or x,-x, A set of equations of this type can be solved in linear time using techniques similar \nto those employed in solving PERT problems (variations of topological sort [81). Note that the solution \nto this problem requires again linear space making a hierarchical solution highly desirable. We are far \nfrom having solved all our problems in this area. The set of primitive relations that we currently use \nto guarantee that the linear inequalities generated can be solved efficiently is sufficient to specify \na layout. but can hardly be called convenient. Quite a few important proper\u00adties of a layout (such as \ncurrent densities on wires or mak\u00ading the dimensions of certain rectangles be fixed ratios) can be captured \nin linear equations that do not permit as simple and efficient a solution as those produced by our reduced \nset of primitive relations. We are quite far from a general solution to the ques\u00adtion of what are the \nuseful properties of a layout that can be captured in systems of linear inequalities allowing a hierarchical \nsolution. Most of the work published on the solution of special systems of linear equations (such as \nthose with only two variables per inequality [2] ) is of no use to us because the memory requirements \nof the algo\u00adrithms described are far too big given the size of our prob\u00adlems and the possibility of hierarchical \nsolutions is not con\u00adsidered. Progress in this area would make ALI a better tool that it is now. 2.S. \nAn apprisal of ALI ALI was conceived as a system which would lack the more obvious shortcomings of other \nlayout systems we were familiar with ([1 1. [41, [101, [121), namely (i) the need for rule checking and \ncompaction, (ii) lack of true modularity and (iii) lack of extensibility. In this section we quickly \nreview these problems and point out what we believe to be the contributions of ALI towards their solu\u00adtion. \n2.5.1. Design rule checking .nd compaction Ail layout systems that we are aware of. let the user specify \nlayouts that violate the design rules of the technol\u00adogy being used. This implies that some effort has \nto be made later on to validate layouts produced with their help. Most systems (graphics based systems \nin particular), force the user to worry about minimizing the area of a iay \u00adout as it is being generated. \nTo ease this burden, the design process in many of these systems includes a com\u00adpaction step in which \nan attempt is made to automatically reduce the size of the layout generated without violating the design \nrules. Compactors and checkers are invariably large pro\u00adgrams ([3], [61) requiring hours of CPU time \nin a large machine to compact or verify medium sized layouts. The asymptotic time complexity of these \nprograms is O (n3/2) or worse in the average case and they require linear space (or use secondary storage \nheavily). Clearly, this approach will not scale well as the number of components per circuit continues \nto increase. The possibility of performing these two operations hierarchically has not been considered \nuntil fairly recently. This may be due in part to the sheer complexity of the checkers and compactors, \nbut undoubtedly is also related to the lack of a flexible cell mechanism in most of these systems. Note \nthat since the checking and compaction process occur after the layout has been produced, informa\u00ad tion \nabout hierarchical relationships between elements of the layout would have to be given to these programs \nseparately. A complete ALI program will never produce a layout with a design rule violation so no rule \nchecking is neces\u00adsary, The process of solving the linear inequalities gen\u00aderated by an ALI program is \nthe equivalent of compaction. We have however two advantages in this process: (i) that of having the \nhierarchical information used to generate the layout available and (ii) that of having designed the con\u00adstraints \nso they can be solved hierarchically. Design rule checkers and automatic compactors spend most of their \nrunning time trying to extract semantic information from the layout. This information is some\u00adthing which \nthe designer must have had very clear in his or her mind when producing the layout but that either was \nnever communicated to the system or has been discarded. It seems more reasonable to ask the designer \nto make this information explicit and saving it than spending much time and effort trying to recreate \nit at a later time. In contrast, ALI requires all semantic relations in a layout to either be given explicitly \nor to be easily obtain\u00adable through transitivity. This information is then used to guarantee that the \nlayout produced will satisfy the design rules and be of minimum overall size among those which satisfy \nit. 62 2.5.2. Modularity How easy is it to divide cleanly a design task among several designers? This \nseems to be a key question when considering how modular a layout system really is, and for just about \nall the systems we know about the answer seems to be not easy at all . The reason is their lack of a \nflexible cell mechanism and their requiring absolute sizes and locations for most of the layout elements. \nIn these systems, it is necessary for individuals in a design group to know the absolute location and \nsize of those elements that are common to two or more of the pieces into which the layout has been decom\u00adposed. \nIn many cases any change in the sizes and posi\u00adtions of these common elements, no matter how small, will \nforce several designers into redoing a substantial part of their work. The same characteristics that \nmakes cooperation between several designers hard also precludes the creation of libraries of frequently \nused cells in most of these sys\u00adtems. Because of the reliance on absolute sizes and posi\u00adtions, different \ninstances of the same cell definition can differ only in whichever manner the person that deftned the \ncell allowed. Such cell definitions would most likely be either too particular to be of any use or so \nparametrized so as to be too hard to use. In contrast ALI offers the possibility of dividing a layout \nmuch as one divides a large software project. Indi\u00advidual workers need only agree on the header of the \ncells they have to define much as they would only have to agree on the header of the procedures in a \nsoftware effort. To pursue the analogy to programming. we feel that most layout systems available today \nare like absolute assemblers without a general subroutine mechanism, ALI is, at least, a relocatable \nassembler with a subroutine call instruction. 2.5.3. Layout systems . s parts of larger systems If one \nenvisions an environment where VLSI design is akin to programming, tools more sophisticated than those \navailable today will have to be built. It is therefore relevant to ask how current systems stack up when \ncon\u00adsidered as possible stepping stones for future tools. A tremendous inherent disadvantage of graphics\u00adbased \nsystems in this respect is that they are an evolution\u00adary dead end: no way to further automate the layout \npro\u00adcess is considered. Most procedural systems are open tools to a certain extent: one can conceive \nof adding a front end to them which would translate functional specifications into layouts, for instance, \nfarfetched as it may sound today. Such a front end for a graphics based system is hard to envision since \nit will need to process visual information like a human. The original work on ALI dates back to the time \nwhen the authors were looking for an intermediate language into which high level descriptions of VLSI \nalgo\u00adrithms could be compiled. Although we will not yet claim success on this endeavor, the fact that \nALI had to be usable as part of a larger system has been kept in mind throughout its design. 2.5.4. \nSome final eomments Another aspect of ALI in which we believe it to be superior to most other procedural \nlayout languages is in its type structures and strongly typed nature. It is not com\u00admon for procedural \nsystems to allow the definition of arrays or records of standard types and even less common to have user \ndefined types and to provide type checking for them. Most of them simply deal with standard types. We \nfeel that type checking at the layout specification time will prove to be as useful as it is in the specification \nof pro\u00adgrams. CM the other side of the coin. several procedural languages provide their users with facilities \nthat are not available in ALI. The most common one is automatic routing, where pairs of points to be \nconnected (absolute positions) are given to the system which automatically con\u00adnects them. It is not \nat all clear how such facilities fit with the overall philosophy of ALI and therefore not clear that \nthey could easily be added to it. Another weakness of ALI is its lack of a graphics interface. At the \nmoment, a graphical representation of the layout produced by an ALI program is used much as one would \nuse the listing produced by a program to verify its correct operation. Clearly there is much room for \nimprovement in this respect, but we are not yet certain which approach fits better with the overall philosophy \nof ALI. 3. A simulator for ALI The ALI language allows the VLSI designer to create layouts. While those \nlayouts are guaranteed to satisfy the NMOS design rules there still is the issue of the correct\u00adness \nof the layout. By this we mean whether or not the layout correctly implements the desired circuit. One \nof the key complications in VLSI is that a layout may be incorrect for a wide range of reasons. These \nrange from purely digi\u00adtal errors to layouts that are digitally correct but misbehave due to analog errors. \nIn order to check that such a wide range of errors, VLSI designers use a number of circuit simulators. \nA clas\u00adsic kind of simulator is the logic-/eve/ simulator. This simulator models the circuit as a connection \nof gates and memoryless one-way wires. These gates, of course, com\u00adpute one of a number of standard boolean \nfunctions: typi\u00adcal gates include and s, or s, nand s, and so on. While such simulators are simple and \nuseful, they do not capture the bidirectional nature of NMOS. Another important class of simulator is \nthe ana/og\u00ad/eve/ simulator such as SPICE [7]. This kind of simulator accurately captures the detailed \nnature of NMOS circuits. It does this by operating at a very low level; hence, such simulators require \ngreat amounts of computing resources. Therefore, it is rare to use such simulators on entire VLSI circuits. \nA third type of simulator studied here is the so called swirch-/eve/ simulator. These simulators such \nas MOSSIM [5] lie mid-way between the above two kinds. They attempt to correctly model the bidirectional \nnature of NMOS circuits, and yet they retain the conceptual simpli\u00adcity of logic-level simulators. Such \nsimulators appear to be quite useful to VLSI designers in catching a variety of errors. The simulator \nfor ALI is a switch-level simulator. It differs from previous simulators in a number of critical ways. \nFirst, and most important, it does nor operate on all possible NMOS circuits. It will reject any circuit \nthat does not satisfy what we call the clocking axiom. Roughly. this axiom forces the VLSI circuit to \nuse its clock phases so that on each clock phase the circuit divides into acyclic pieces. It appears \nto be the case that most well struc\u00adtured circuits will satisfy it. Most common VLSI circuits, such as \nPLA s and shift registers, do indeed satisfy it. Second, our simulator is guaranteed to run in essen\u00ad/ia/(y \n//near time. By this we mean that it runs in time O (TCS( ~, T)) where T is the number of transistors \nin the layout and as usual a (n ,n ) is the Ackermann Inverse function. (Recall a (n ,n ) is less than \n5 for all possible values of n [111.) We have an initial version of the simu\u00adlator written in Pascal \nrunning on a VAX 11/750 which processes circuits having several thousand transistors in only a few seconds \nof CPUtime. Third, our simulator also guarantees that for the cir\u00adcuits that satisfy the clocking axiom, \nthe final state exists and is unique. By this we mean that for such circuits not only will the simulation \neventually stop. but moreover. the final answer is the unique final answer. Since NMOS cir\u00adcuits can \nin general, contain hazards and race conditions this seems to be a critical advantage to our approach. \n3.1. The model We represent as in [51 each NMOS circuit as a set of nodes that are connected by pass \ntransistors. There are input nodes. pull-up nodes, and normal nodes. Input nodes provided a strong externally \ngenerated value. while normal nodes can only store a charge but cannot generate a value. Pull-up nodes \nare connected via a pull-up resistor to a vol\u00adtage source. They are at a high value unless they are con\u00adnected \nto ground. Pass transistor act as switches that connect such nodes. A pass transistor is described by \na triple: (gore, source, drain). Source and drain are not distinguished. Such a device acts as a switch: \nif the gate is high+ then the source and drain are connected; otherwise, the source and drain are not \nso connected. 3.2. The clocking .xiom Let C be an NMOS circuit. Also, let @ be a set of input nodes to \nC. Then @ is a clock set for C provided that at most one node in @ is ever high at a time. Note, this \nproperty is nor a function of the circuit C, but instead reflects how we use the circuit. In many circuits \nO is sim\u00adply the two input nodes @I and 42 that control the two clock phases. We now will state precisely \nthe clocking axiom that is central to our approach to switch-level simulation. In order to do this, we \nneed afew simple definitions. Let @ be in the set~. Let T+ be the set of transis\u00adtors in C with their \ngates either equal to @ or not in 0. Theimportance ofthisclass oftransistors is that when@ is high only \nthese transistors can potentially be on. We say that two nodes x and y are +-connected provided there \nare nodes xl,...,xk so that x= x,, y= x~ and for each I<i<k-1, there is a transistor @i, Xi,xi+l) in \nT4. Clearly, ~-connecrivi!y is an equivalence relationship, and so it partitions the nodes of C into \nequivalence classes, in a natural way. We further define a directed graph on these equivalence classes \nas follows: if (g,x,y) is a transistor in T+, then place an arc from the equivalence class of g to that \nof x. (Note, this is well-defined since x and y lie in the same such class.) Let us call this graph the \ncontrol graph of ~. We are now in position to state the clocking axiom. A circuit C with clock set @ \nsatisfies the clocking axiom provided for each @ in ~, the control graph is acyclic. Recall this means \nthat as a directed graph there is no directed cycle. Roughly, this axiom means that all feed\u00ad back is \ncontrolled by clocks from 0. The conse\u00adquences of this axiom are discussed in the next section. 3.3. \nThe simulation method The stare ofa circuit isthearray ofvalues associated with its nodes. Given a circuit \nand a state S we say that S is a next state provided the circuit can eventually reach S simply by the \nactions of its pass transistors. Such a state S is a jinal state provided further that no additional \nchange can occur without external changes to the nodes. Clearly, not all states ever reach a final state: \nit is quite possible for a circuit to oscillate forever. However, we can prove the following: Theorem: \nAny circuit that sati$fies the clocking axiom always has a unique final state. This then is the primary \nmotivation for the clocking axiom. Such circuits are guaranteed to be well behaved . Not only can they \nnever oscillate, but in addition they always reach the same final state. Clearly, this is critically \nimpor\u00adtant to a VLSI designer. Without such a basic theorem it would be possible for a circuit to work \nsome times but not others. The proof of the theorem is actually quite construc\u00adtive and it supplies a \nvery fast way of finding final states. Let us fix one of the nodes from O as being on, say @. Since @ \nis a clocking set there always is at most one such node. (If no such node exists then we can trivially \nmodify the method that follows.) Now recall that the control graph of @ is acyclic; therefore, we can \nby topological sort, order its vertices into a list so arcs only go from earlier vertices to those later \nin the list. Now since each of these vertices represents a set of nodes from the circuit we can in a \nnatural way order the nodes of the circuit. Our simulator then proceeds as follows: it fires each transistor \nonce in the order induced by the above ordering of the nodes. More exactly...-if (g .s .d) is a transistor \nand @ .s ,d ) is also a transistor, then fire (g,s, d) first provided g occurs before g in the node ordering. \nIf g equaIs g then the order of the transistors is immaterial. An induction shows that this always yields \nthe unique final state of the circuit. Since each transistor fires at most once the algorithm runs in \nT times the cost of each such firing where T is the number of transistors. But it is easy to see that \nthe firing of a transistor involves merging two equivalence classes. This operation can be performed \nusing the operations described in [9], yielding the claimed time bound of O ( TCY( T, T)). On an example \nwith about 3,000 transistors the current simulator takes about 3 seconds of CPUtime on a VAX 11/750. \nNote, the topological sort and hence the transistor ordering can also be done as a preprocessor step. \nThe application of our simulation method depends of course on the clocking axiom. We have observed that \nmany classes of circuits satisfy it. These include shift registers, PLA s, and more generally combinatorial \nlogic. However, many simple circuits will not satisfy our clocking axiom. A typical such circuit is one \nin which the clock is anded together with another control line. While it is true that this will lead \nto circuits that do not satisfy the clocking axiom, it is easy to extend our ideas to such cir\u00adcuits. \nThe key to this extension is to observe that as long as the interaction of the clock lines and the control \nlines is without feedback, then our methods will generalize. Acknowledgements We would like to thank \nJose Mata. Steve North. Vijaya Ramachandran and Jerry Spinrad for their help in the implementation of \nALI and the simulator. Jean Vuille\u00admin and Scot Drysdale for their comments. We also wanl to thank Bruce \nArden for his advice and support. Special thanks are due to G. Vijayan for his probing questions. ingenious \nsolutions and tireless work in the implementa\u00adtion of the prototype of ALI. The work of Richard Lipton \nhas been partially sup\u00adported by grants MCS8023-806 from NSF and NOOO14\u00ad81-K-0681 from ONR. Robert Sedgewick \ns work was par\u00adtially supported by NSF grant MCS80-17579. The work of Jacobo Valdes has been supported \nby NSF grant MCS79\u00ad05524 and ONR grant NOO014-81-K-0681. 4. References [11 Ackhmd, B., Weste, N., A pragmatic \napproach to topological symbolic IC design. design, VLS1 81. PP 117-129, ed. John P. Gray, Academic Press. \n[21 Apsvall, B. and Shiloach Y., A Polynomial Time Algorithm for Solving Systems of Linear Inequali\u00adties \nwith Two variables per Inequality , pp 205-217, Proc. of the twentieth IEEE Symp. on Foundations of Computer \nScience, 1979. [31 Baker, C. M., Artwork Analysis TooIs for VLSI Circuits, M. S. Thesis, MIT, EECS Department, \nJune, 1980. [41 Batali, J,, Mayle, N., Shrobe, H.. Sussman, G., Weise, D., The DPL/Daedalus Design Environ\u00adment, \nVLSI 82, pp 183-192. [51 Bryant, R. E., MOSSIM: A switch-Level Simulator for MOS LSI, pp 786-790, 18th \nDesign Automation Conference, 1981. [61 Corbin, L, V., Custom VLSI Electrical Rule Check\u00ading in an Intelligent, \nPP 696-701, 281h Design Auto\u00admaton Cor@erenceProceedings, 1981. [71 Fan, S. P., Hsueh, M. Y., Newton, \nA. R., Peterson, D. O., MOTISC: A new circuit simulator for MOSLSI circutis, IEEE Proc. Int. Symp. Circuits \nand System, pp 700-703, 1977. [81 Knuth, D. E., The Art of Computer Programming, vol. 1, Fundamental \nAlgorithms, Addison-Wesley, 1971. [91 Mead, C., Conway, L., Introduction to VLSI Systems, Addison-Wesley, \n1980, [101 Mosleller, R.C., REST: A leaf cell design system, VLSI 81 pp 163-172. [111 Tarjan, R. E., \nEfficiency of a Good but Not Linear Set Union Algorithm , JACM. vol. 22, no.2. pp 215-225, 19750 [121 \nTrimberger, S., Combining Graphics and a Layout Language in a Simple Interactive System, 18th Design \nAutomaton Conference Proceedings, 1981.  \n\t\t\t", "proc_id": "582153", "abstract": "Two components of a VLSI design environment being built at Princeton are described. The general theme of this effort is to make the design of VLSI circuits as similar to programming as possible. A conscious attempt is being made to apply experience in the design of large software systems to the creation of an appropriate environment for VLSI circuits. The two components described are a procedural language to specify circuit layouts and a switch-level circuit simulator for layout produced with this language. They have been chosen for presentation because many issues in their design are very similar to the issues that arise in the design of programming languages and software environments.", "authors": [{"name": "Richard J. Lipton", "author_profile_id": "81100546583", "affiliation": "Princeton University, Princeton, NJ", "person_id": "PP15035881", "email_address": "", "orcid_id": ""}, {"name": "Robert Sedgewick", "author_profile_id": "81100048297", "affiliation": "Brown University, Providence, RI", "person_id": "PP39024789", "email_address": "", "orcid_id": ""}, {"name": "Jacobo Valdes", "author_profile_id": "81100435239", "affiliation": "Princeton University, Princeton, NJ", "person_id": "PP31042152", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/582153.582160", "year": "1982", "article_id": "582160", "conference": "POPL", "title": "Programming aspects of VLSI: (preliminary version)", "url": "http://dl.acm.org/citation.cfm?id=582160"}