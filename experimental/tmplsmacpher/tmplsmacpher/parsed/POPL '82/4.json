{"article_publication_date": "01-25-1982", "fulltext": "\n EXTENDED NAMING CONVENTIONS FOR COMMUNICATING PROCESSES* Nissim Francez Department of Computer Science \nTechnion -Israel Institute of Technology Haifa, Israel SUMMARY We present two extensions of Communicating \nsequential Processes [H0781: computed communi\u00adcation targets and unspecified communication targets, as \nwell as corresponding extensions tO the system of cooperating proofs [AFR80] for verifying distributed \nprograms. These extensions are important for the natural expressibility of many distributed programs. \nExamples of the use of these extensions are discussed and verified. I. INTRODUCTION The purpose of this \npaper is to introduce two extensions of the CSP process naming conve?ztions [H078] together with their \nassociated proof rules. The suggested extensions permit a more natural expression of many distributed \nprograms, and the lack of these features in CSP has been widely criticized. The proof rules are presented \nas an extension of the proof system known as cooperating proofs, introduced in [AFR801 and proved to \nbe sound and (relatively) complete in [AP81] . A basic feature of CSP is its naming eonve? tion.s, which \nrequire that every communication command have a target Of communication, i.e. a process that is explicitly \nnamed in the command and determinable syntactically at compile time. Thus, for the language as described \nin [H0781, a target process must be named either by a simple name, as in p~inte??!zine, or by an indexed \nname, as in phil [i + 1 @ 5] ? leftfork ( ) (aPPearin9 in phil[il) , in which case the index must be \na compile time constant. These conventions have been criticized as being very ~estrictive for distributed \napplications in which the establish\u00adment of communication is dynamically determined. Permission to copy \nwithout fee all or part of this material is granted provided that the copies are not made or distributed \nfor direct commercial advantage, the ACM copyright notice and the title of the publication and its date \nappear, and notice is given that copying is by permission of the Association for Computing Machinery. \nTo copy otherwise, or to republish, requires a fee and/or specific permission. @ 1982ACM0-89791-065-6/82/001/0040 \n$00.75 The contribution of this paper is the intro\u00adduction of the following two extensions of the CSP \nnaming conventions 1. Computed targets of communication, and 2. Unspecified targets of communications, \n accompanied by appropriate proof-rules which axiomatically define their semantics. An informal description \nof these extensions follows : 1. Computed Target of Communication As a typical application where this \nextension is needed we consider routing protocols. Assume that a fixed network structure is given. Also \nassume that in the solution to some problem a process p[il has to send a message m to a process p[jl \n, to which it is not connected in the network. On the other hand, p[kl is connected to both p[i] and \np[j]. We would like to be able to express the simple routing strategy whereby p[il sends a pair(m,j) \nto p[kl and when p [k] receives the pair, it sends m to p[jl. Here p[kl has to communicate with a process \nwhose identity is dynamically determined (in the example considered, as a result of a communication) \n. This pattern of communication is not simply expressible in CSP. 2. Unspecified Target of Communication \nHere, a typical application is a service process (e.g. , a process implementing a library procedure or \na data-structure). Several critics of CSP (e.g. [BH78]) have observed that such a process cannot be elegantly \ncoded in CSP. The reason for this inelegance is that the service process has to know the identities of \na~~ poten\u00ad tial users, and explicitly refer to them in its code. Typical code might look as follows: \nserver: :* [user l?requesto + <service-l> o D user n?requesto + <service-n>] . * This work was partially \nsupported by NSF Grant &#38;lcS81-05553 during the author s stay at the Center for Research in Computing \nTechnology, Aiken Computation Laboratory, Iiarvard University, Cambridge, VA 02138. Note that whenever \na user of a server is added or deleted, the server process must be reprogrammed. In addition, it is necessary \nto have many copies of the <service> code. We consider an extension in which the target of a commun~cation \n1s left unspecified, and matches a complementary cormand in any process in the network. We define th~s \nextension by means of extending COOpeTatincJ proo~-s. The complexity of these extensions may shed some \nlight on the practicality of adding them to any actual implementation of CSP. However, even if one comes \nto the conclusion that such exten\u00adsions are too expensive or Inefficient, they still could play a useful \nrole in the verification of various protocols expressed as programs m this extended version of CSP. In \na forthcom~ng compan\u00adion paper, we shall verify a nontr~vial protocol for remote procedure ca~h which \nuses these ex\u00adtensions. The extensions to cooperating proofs also serve as a first approximation to proof \nrules for the rendezvous construct in ADA [IC79]. II . COMPUTED COMMUNICATION TARGETS 11.0 The Extension \nIn this section we introduce the extension of CSP allowing for a (dynamically) computed target of communication. \nWe shall remain within the framework of [H078] by considering arrays of pro cesses as the basic structuring \ntool. However, the results apply also to other structuring methods; e.g. trees of processes, We also \nretain the constraint that the network structure is fixed, i.e. processes are not dynamically created \nor destroyed. Whenever a process is a member of an array of processes p we refer to It as a p-process. \nWe use the following syntax for communication commands: p[e]?x, p[e] !y where e is any expression yielding \na value of the index type of p, and referring only to variables local to the process in which the command \nappears. The intuitive meaning of such commands is to input from (or to output to) the process whose \nindex is the current value of e. By the dis]ointness of variable sets of different processes, the value \nof e may not be changed by another process. We shall assume that the evaluation of e always terminates. \n(Furtlier\u00admore, if e s value is outside the boundary of the array of processes, the whole program fails.) \nIn a more general setting, one would need operators producing process names as values; however, we shall \nnot consider this generality here. 11.1 Partial Correctness Proofs To make the paper more self-contained, \nwe briefly review the main features of cooperating proofs. The proof system has two levels. In the first \nlevel, separate proofs are constructed for each process. TO obtain in the second level a proof for the \nconcurrent composition, the separate proofs are shown to cooperate. The standard proof rules for guarded \ncommands are used in the separate proofs, and in addition, the following two i/0 axioms: (A) {P]a{Q} \nwhere a is p[il?x p[jl!y. P and Q are any assertions referring to the local variables of the process \nin which the assertions appear. We assume some fixed first order language with equality as the assertion \nlanguage. The input axiom may be used to guess the input value sent by another process. Note that the \npostcondition Q cannot really be arbitrary since it must pass a cooperation test. For a further explanation \nof the output axiom, the reader is referred to [AFR90] . As can easily be seen, the soundness of these \naxioms does not depend on the fact that i IS a compile time constant. We shall also use the axioms for \ncomputed communication targets. For the cooperation tests a global invariant I (possibly referring to \nvariables of atz. processes and auxiliary variables) is introduced. Every process lS annotated with brackets \nin such a way that a bracketed section contains at most one communication command. The invariant is only \nre\u00adquired to hold outside bracketed sections. Since communication targets are syntactically determined, \nit is possible to use the notion of a syntactic matchixg between a pair of i/0 commands in the original \nformulation of cooperating proofs. The cooperation test has to establish the post\u00adcondltlons of the matching \nsections and the in\u00advariant, given that the precondition and the in\u00advariant hold inltlally. The invariant \nis also used to rule out all syntactically matching pairs of bracketed sect~oms which do not semantically \nmatch. The basic cooperation test is: (cl) {pre1Apre2 AI} S111S2{post1A post2 AI} where {prel}S1{postl} \nand {pre2}S2{post2} are syntactically matching bracketed sections, and the preconditions and postconditlons \nare taken from the corresponding separate proofs. In case sl and S2 do not semantically match, the con]unctlon \nof the precondition and the invariant will be inconsistent. In [AFR80] additional rules are introduced \nto reduce (Cl) to a sequential proof; the most important is the communication axiom: (CA) {true} p[]l?xllq[il!y \n{x=Y} prOvided PIJI?X and q[ll !y are taken from q[l] and p[jl, respectively. We now extend (cl) to the \ncase of computed communication targets. Definition 1. Two communication commands of the form p[e]?x and \nq[e ] !y are potentially matching iff they appear in a q-process 41 and p-process, respectively. (Hence, \np[e]?X and p[e ]!y are always potentially matching.) 2. Two bracketed sections {pre }S1{postl} {Pre }S2{p0st2} \nare potentzkzlty matefizng if t i? e corresponding communication commands are. The notion of potential \nmatching replaces that of syntactic matching. A potential match will be an actual match provided the \nfollowing two conditions hold : and S2 are taken from a. The sections S1 q[il and p[j], respectively. \n b. There is a time instant during execution when the controls of q[i] and p[jl are about to execute \nS1, S2 respectively, and the current values of e and e are and i, respectively. j As a consequence, we \nobtain the following extension of the cooperation test Cl: (DC1) {prelApre2AIAe =jAe 1 =i}S111S2{postlAp0st2AI} \nwhenever and s~ are potentially S1 matching bracketed sections taken from q[il and p[jl, respectively. \nNote that when e and e are both compile time determined, potential matching coincides with syntactic \nmatching, and the rule (DC1) reduces tO the original rule (Cl)- The new cooperation test involves every \npair of potentially matching bracketed sections; hence the proof burden may be heavier. However, in \nI will bemany practical cases the invariant consistent with only one pair of values for e and e , and \nmost of the cooperation tests will vacuously succeed.  11.2 Deadlock Freedom Proofs To show that a \nprogram is deadlock free it is necessary to identif~ all b20cked situations (N-tuples of assertions \nthat hold when a program is in a deadlock state. See [AFR80] for a vigorous definition.) and show that \nthey are not consistent with the Invariant I. The CSP convention of distributed termination, by which \na process may exit a loop if all processes referred to (by guards with a true boolean part) have themselves \nterminated, causes some situa\u00adtions to be unblocked which would otherwise be blocked. To cope with this \nconvention, the propositional variables ENDp [ 1 I are introduced. q[jl ~NDp [i ] will become true whenever \n p[i] exits q[jl a loop due to this convention and the termination of q[jl. For simplicity of notation, \nwe assume just one array p and the corresponding variables END;. Since I may refer to END ; , we need \nan extra cooperation test to establ~ J h that I holds after loop exit due to the above convention. Consider \na program section of the form S: :* [D(j=l, . . ..m)bj.aj +Sj] . Let A~{l, . . ..m} be any set of guard \nindices, and let C be the set of all process indices referred to by a, j CA. Also, let 3 pre(S,A) ~f \npre(S) A A bjAA -b, . j EA j@A Then, we have the following second cooperation test: (c2) ( A post(p[j] \n)Apre(S,A) AI) jtC ~ (post(S) AIITruelWND;] ) . J JEc Here I[truelEND~] is the assertion obtained J JEc \nfrom I by substituting true for all free occurrences of END? in I corresponding to jEC. Intuitively,]this \nclause states that when p[i] exits the loop (modelled by post(S) becoming true) due to termination of \nall processes referred to in guards indexed by A (modelled by post(p[j]), j~c) , the invariant is reestablished. \nIn order to extend this rule to the context of computed targets , let ej be the computed ~j target Of \n(in S). Let A~{l,. ..,m} and let Cc{l,. ..rn} be such that ICI <lAl. The roles 0 f A and C are as in \n(C2) . Then, we must show (DC2) ( A ekCCA A post(p[jl )Apre(S,A) AI) kCA jCC z (post(S) AI [truelEND+] \n] ]Ec) The meaning of the rule is as above, but we must show that all the e s,are indeed in C. Since \nc is a finite set, say C={il, . . ..im}. the notation ek E, C is just a shorthand for ek=lv Q !,=1 ,...,m \nNext present a theorem stating the condition for freedom of deadlock. In order to show that deadlocl: \nis impossible, we must show that no blocked situation is consistent with the global invariant. This is \nthe idea of Theorem 1 in [AFFU301. With dynamic targets of communication, blocked situations can no longer \nbe syntactically determined, since they depend on the runtime values of process indices. Hence, in order \nfor a n-tuple of appropriate assertions to be blocked, it has to satisfy the following condition (no \ndgnamic matching): (NDM) For any pair of assertions qi and qj belonging to potentially matching communica\u00adtion \ncommands P[2]?x, p[e ] !Y taken from bracketed sections (in p[jl) and S1 S2 (in p[il) respectively, qiAqj+{e+i \nVe #j) holds. Using this modified definition of a blocked situation, we may now restate Theorem 1 of \n[AFR801 TEEOREM. Given a proo~o~ {P}[p[l]ll . . . llp[n]] {Q} IJith a gzobal invariant 1, p is deadlock \nfree if, for every blocked situation <P 1 ,.. ., Pn>, ( A PiAI) i=l, n holds. The proof burden is \nclearly heavier for the case of dynamic targets, since more situations must be considered as (possibly) \nblocked. 11.3 Soundness and (Relative) Completeness In order to justify the proof rules for the suggested \nextension, we show that the soundness and (relative) eompzeteness are reducible to the corresponding \nproperties for the unextended system, which were proved in [AP811 . We, in fact, show that these language \nextensions can be simulated within the original CSP, and the required properties are deducible from that \nsimulation. One could, of course, argue that such extensions are not needed if they can be simulated. \nOur argument is that it is better to show such a simulation only once, in a metatheorem, and program \nusing the extensions, thereby avoiding a lot of code copying. A similar justification applies to the \nusage of while or i~\u00ad then-else, even though they can be simulated using goto , Consider an input command \nserving as a guard in p[e]?x+S (a similar agument applies for Out\u00ad put guards) . In order to simulate \nthis command, we rely on the fact that the network structure is fixed. Assume that p is declared with \nindex bounds l..np. We replace the input-guarded command by the guarded selection command shown below: \n[D(k=l, . . . ,np) e=k; p[kl?x+Sl . In other words, since e may vary over a finite range only, we replace \nthe computed target by a nondeterministic choice of every element in this range, provided it is the current \nvalue of e. If the value of e is not in range, all the equalities e=k are false and the whole construct \nfails. If the original command contains a boolean part b, it is repeated in every branch in the simulating \nnondeterministic selection. We omit it to simplify the notation. In order to prove that the simulation \nis correct, we bracket the simulating sections in a way we call the naturally induced bracketing of \np[e]?x+S is repeated for each k in the simulating selection. Consider any (fixed) proof {P}S{Q} using \nan invariant I, for S a program using the computable target extension. We prove the following: THEOREM \n. Any tuo potentially matching bracketed sections satisfy the cooperation tests DC1, DC2 (with respect \nto an invariant I and some bracketing) iff the corresponding simulating select\u00adions satisfy Cl, C2 (with \nrespeet to the same in\u00advariant I and the naturally -induced haeketing). Proof. Let L1::{prel}Sl{POstl} \nand be two potentially matching bracketed sections taken from q[iol and p[jol , respectively. Let the \ncorresponding potentially L2; ; {p_2{pOSt2} matching communication commands be p[el?x+=, and q[e l!y+i, \nrespectively. Also, let L~::{prel}[n(k=l, . . . . np) e=k; p[kl?x+=l{postl} and L;: :{pre2}[a(k =1 ,.. \n.,nq) e =k; q[k ]!y+~] {post2} be the corresponding simulating selection. a. DC1+C1 Suppose cooperate \nby DC1. Hence 1 2 {prel Apre2A IA e= joAe =io}Sl\\\\S2{p0st1 (*)A post2 AI} holds . In the two simulating \nselections, the corresponding branches with k=jo and k =io are syntactically matching, and (*) reduces \nto Cl for that case. A similar argument applies to any other pair of indices (i; ,j;) which may cause \n(*) to hold. C1+DC1b. The branches for k=jo and k =io are syntactically matching and satisfy (*) in \ncase Cl applies, which implies DC1 applies for Sl, S2. No other values for k, k may satisfy (*). Note \nthat if none of the equalities e=k (or e = k ) hold, Cl will trivially fail for alz branches in the selection. \nIn this case, e is out of range, and S is indeed semantically invalid. Next, consider an iteration of \nthe form L: :{pKe}*[n(J=l, . . ..m)bj. aj+Sj] . Clj After replacing each containing a computed target \nby its simulating selection (all embedded in the same loop) J we 9et L ::{pre}*[n(j=l, . . ..m.ij=l, \n. . ..np)bj.ej=ij; u, +Sjl1, 3 (where the sequential numbering of the lines is according to a lexicographic \norder) . Here np is the length of the process array (we again deal with a single array for simplicity), \ne.is the computed target index of and Ui 1 Ctj results from u. by replacing e. by i.. 1 11 c. DC2+C2 \n Suppose that for some A, C (as above) DC2 is satisfied by L. Define for L an index set A including indices \nfor these lines of L con\u00adtaining the boolean part ij=a for Then ace.. the set of addressed processes \n(by members]of A ) is again C, and clearly L satisfies C2 with repsect to A and C. c2+DC2d. Follows directly \nfrom the observation that if L satisfies C2 with some A and C, A contains at most one occurrence of \neach i, , 43 11.4 An Xxample We next present a simple example which will serve as an abstraction of \nmore complicated routing protocols. In this example, each process p[il sends the value of its local variable \nai to process A. A, in turn, sends (ai,i) to B, and B responds by sending the value back to p[i] . The \nvalue that is returned is received by p[i] in the local variable bl. Thus, we must show that A, b, =a, \nholds upon termination. We give b;~~hnth~ anfiotated-text of the program, including all local assertions, \nand the global invariant. The variables ~, g and k are aUXiLiarY and are only needed for the proof. All \nassertions and auxiliary statements are typed in italics. {true}RECYCLER: :[AllF [i=l, . . ..n]llH {i=; \n~ ~i=~i} > A::{k=;,n ?-l[kl=o} *[{ ~=;n l z[kl#l} , n(k=l, . . ..n)<p[kl ?x+h[k]. =l; > {h[kl=~} <B! \n(x,k) ;h[k1:=2>{h[k1=2}1 {true} p[i] : ;{gZ=~} [<A!ai+gi:=l ;>{g~=l } <B?b, ;gi:=2>{gi=2 Abi=ai} 1 {bi=cZi} \n1 B: :{f=Q}*[{~=O} <A?(y,id) +~~=l~>{~=z} <p[id] !Y;~:=O> {~=0}1 {true} 1 ~ {lz[i]=laz =ai (1) A k[i]=2~y \n=aiAid=i (2) (3)A.f=l~gi=2Ak[i]=2 A h[i]=13gi=lAf=0 (4) (5) A 9i=03f=o~ The role of the invariant I in \nthis program is to encode the route that message al follows and is typical of such protocols. We next \npresent in detail one of the co operation tests (DC1) . The only case that does not reduce to (Cl) is \nthe cooperation between the second bracketed section of B and the second bracketed section in a p-process. \nWe first consider the positive cooperation between B and p[il. We must show that (after substituting \nthe appropriate pre-and post-conditions): {~=~Agi=~Aid=iA~}B?bi ;gi:=2\\lp[idl!y; f:=O{f=OAbi=ai AI} We \nuse informal reasoning which can easily be trans\u00adformed into a formal proof using the rules of formation \nand the communication axiom, gi en in [AFR80] and the standard rules for sequential programs 1. f=O is \nestablished directly by a local assignment. 2. Since f=lAI holds initially, so  h[i] =2 holds by clause \n3 of I. By ~ we ~et y=ai, and by the clause 2 of communication axiom with id=i, we see that bi=ai holds \n. 3. Next, we establish that the invariant is preserved. 3.1 Since h[i] =2 is derived as in (2) above, \nthe clause holds vacuously. 3.2 is derived as in (2) and is Yi =ai not affected by the bracketed sections; \nid=i is a precondition which also remains unchanged. 3.3 Holds vacuously, since f=o. 3.4 Holds vacuously, \nsince h[il =2. 3.5 Trivial, since f=O holds. Next, we consider a neqative proof of co\u00adoperation as above \nwith p[j~ for ~+i. We have to show [f=lAgj=lAid=j Aj#i AI]3false. By clause 3 of I, gi=l holds, as well \nas h[i] =2. Hence, by clause 2 of I id=i holds, contradicting icl=j+i. Thus, the cooperation is established \nfor this two groups of potentially matching sections. As noted above, the rest of the (DC1) tests reduce \nto (Cl) and are skipped. Since we have no guard with a computed target as a loop guard, all the (DC2) \ntests reduce to (C2) tests. Howeverr we shall show that one of the blocked situations, involving a computed \ntarget, contradicts the invariant. The rest are similar. Consider a state in which B waits to commu\u00adnicate \nwith p[id] with id=i, but p[i] is still at its initial state, waiting to communicate with A, while A \nitself has terminated. Also , p[jl, j#ir all wait to communicate with B. This situation is given as the \nfollowing (conjunction of the) tuple of assertions: trLIeA A 9j=lAgi=OAf=l . j #i We have to show that \nthis conjunction contra\u00addicts the invariant I. This, however, is immediate, since by clause 5 of I and \ngi~O, f=O follows, contradicting f = 1 in the con\u00adjunction. Note that the NDM condition was incorpo\u00ad \nrated by assuming id=i, while gj=l only for j+i.   III. UNSPECIFIED TARGET FOR COMMUNICATION This section \ndescribes another extension of CSP S process naming convention: the unspecified target of communication. \nThe purpose of this extension is to permit communication between one Process, say P, and any other process \nthat might 44 wish to communicate with p, without forcing p to be aware Of the identities of the other \nprocesses. As mentioned in the Introduction, a typical application for this extension is the service \nprocess which may communicate with any process in the system that needs the particular service it provides. \nThe following notation will be used: ?X: Receive a message (of the type of x) from an~ process ready \nto send one to the process containing the command. Assign the contents of the message to x. !y: Send \nthe value of y to any process ready to receive a message (of the type of y) from the process containing \nthe command. Note that after such a communication has taken place, the process containing the command \nmay not know the identity of the process with which it has communicated (compare with [BH78b], where \na build-in function provides this information). This is similar to what happens in the ADA entry Cazz \n[IC79] , where the process containing an entry does not know the identity of the caller during the rendezvous. \nIn case the identity is needed for a follow-up communication with the same target, itmust be included \nwith the message. Thusr a typical service process will have the form shown below: server: :*[? (request, \nid) +<service>(id); id!result] The (informal) meaning of the distributed termination convention in this \ncontext is as follows : An occurrence of ?X or !Y in a guard is considered false iff azz processes con \ntaining a complementary command addressing the first process have terminated. We use instead extension \nof CSP S distributed termination con vention suggested in [FR801 where a loop is ter minated once a predefine \nset of processes addressed in the loop guards have all terminated. Thus, it is not necessary for a~~ \nprocesses addressed by loop guards to have terminated in order for a loop to terminate. The reason for \nthis generalization is to avoid the situation in which a program containing two (or more) service processes \nne?Jer terminates, since each process will wait for the others to terminate. Potential matching is now \ndefined as follows : DEFINITION. ?X (or !Y) appearing in a process p[il , potentially matches any process \nhaving the complementary command addressing a p-process, i.e. p[e]!u (p[el?v) or !U (?V) . For this notion \nof potential matching, we get the following extension of the first cooperation test: (uCl) a. {prel Apre2 \nAIAe =i}SlllS2{p0st1 A post2AI} whenever and are pO*.n&#38;ially 1 2 matching bracketed sections in different \nprocesses, S1 is taken from p[i] and contains ?X (!y), and S2 contains p[e l!n (p[e ]?v). b. same as \nCl (the original rule) whenever contains ?x and S2 contains 1 [Y. With this cooperation test the burden \nof proof is even heavier than in the case of the computed target, since matching can occur with any process-\u00adnot \njust those within the boundaries of a given array of processes. The second cooperation test (UC2) for \nloop exit due to distributed termination will be given in the full paper. Both tests are justified with \nthe obvious simulation of ?X+S by [procl?x+s o o procp?x+s 1 where prOcl, ..-,prOcp is the list of a~l \nother processes in the system. REFERENCES [Ap81] K.R. Apt, Formal justification of a proof system for \ncommunicating sequential prO\u00adcesses. Submitted for publication, 1981. [AFR80] K.R. Aptr N. Francez, \nW.P. de Roever: A proof system for communicating sequential processes. ACM-T~PL~~ ~, 3, July 1980. [BH78] \nP. Brinch-Hansen: Private communication, 1978. [BH78b] P. Brinch-F;ansen: Distributed processes, CACM \n&#38;, 11, November 1978. [FR80] N. Francez: Distributed termination, AL M-TOPLAS ~, 1, January 1980. \n[H078] C.A.R. Hoare: Communicating sequential processes, CACM~, 8, August 1978. [IC79] J.D. Ichbiah et \na~.: 1. Rationale for the design of the ADA programming lanquaqe. 2. Preliminary ADA reference manual. \nACM-SIGPLAN Notices ~, 5, June 1979.  \n\t\t\t", "proc_id": "582153", "abstract": "We present two extensions of Communicating Sequential Processes [HO78]: computed communication targets and unspecified communication targets, as well as corresponding extensions to the system of <i>cooperating proofs</i> [AFR80] for verifying distributed programs. These extensions are important for the natural expressibility of many distributed programs. Examples of the use of these extensions are discussed and verified.", "authors": [{"name": "Nissim Francez", "author_profile_id": "81100052373", "affiliation": "Israel Institute of Technology, Haifa, Israel", "person_id": "PP17013153", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/582153.582158", "year": "1982", "article_id": "582158", "conference": "POPL", "title": "Extended naming conventions for communicating processes", "url": "http://dl.acm.org/citation.cfm?id=582158"}