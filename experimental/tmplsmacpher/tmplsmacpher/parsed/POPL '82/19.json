{"article_publication_date": "01-25-1982", "fulltext": "\n PRACTICAL ERROR RECOVERY IN LR PARSING Seppo Sippu and Eljas Soisalon Soininen Department of Computer \nScience, University of Helsinki Tukholmankatu 2, SF-00250 Helsinki 25, Finland Abstract. An automatic \nsyntax error handling tech\u00adnique applicable to LR parsing is presented and analyzed. The technique includes \na phrase-level error recovery strategy augmented with certain addi\u00adtional features such as local correction \n. Atten tion has also been paid to diagnostic aspects, i.e. the automatic generation of error message \ntexts. The technique has been implemented in the compiler writing system HLP (Helsinki Language Processor), \nand some promising experimental results have been obtained by testing the technique with erroneous student-written \nAlgol and Pascal programs. 1. Introduction Syntax error handling in compilers has received a great deal \nof attention in computer science lit\u00aderature (see the bibliographies by Ciesinger [4] and Sippu [15]). \nThis is partly due to the in\u00ad creasing interest being shown in developing practi\u00adcal translator writing \nsystems (Aho [11). A method for generating programs for syntax error handling is included in almost all \nsystems. In this paper we discuss the method used in HLP (Helsinki Lan guage Processor, [141), and we \nreport on experi ments in which the method was analyzed by means of erroneous student written Algol and \nPascal prog\u00ad rams. Permission to copy without fee all or part of this material k granted provided that \nthe copies are not made or distributed for direct commercial advantage, the ACM copyright notice and \nthe title of the publication and its date appear, and notice is given that copying is by permission of \nthe Association for Computing Machinery. To copy otherwise, or to republish, requires a feeand/Or specific \nPermission. The parsing method chosen in HLP is LR parsing, more specifically LALR(l) parsing, and our \ngoal in syntax error handling was to develop an efficient and completely automatic method with good diagnos\u00adtic \nand recovery properties. As is the case with many practically oriented recovery techniques, that of HLP \nincorporates features from several differ\u00adent strategies. The starting point in the develop\u00adment of the \nrecovery generator of HLP was the phrase-level strategy of Leinius [8]. The defi\u00adciencies found in the \noriginal technique and its successors [7,11] gave rise to various improve\u00adments and additions, including \nlocal correction . The improvements and additions finally led to the somewhat mixed recovery strategy \nnow used in HLP. Our experiments show that the method used in HLP produces error recovery comparable \nin quality to the most sophisticated methods recently devel\u00adoped. This is especially noteworthy because \nour method does not apply the forward move recovery, which has been considered superior to phrase-level \nrecovery. The idea of forward move recovery was made popular by Graham and Rhodes [6,12], who used it \nin connection with precedence parsing, In spite of some obvious difficulties, forward move recovery has \nalso been applied to LR parsing e.g. by Pennello and DeRemer [10] and by Druseikis and Ripley [5]. Our \nresults are of importance because phrase level recovery with local correction is easy to implement in \nLR parsers and can even be handled theoretically (see [17]). 2. Phrase-level recovery in LR parsing We \nassume that the reader is familiar with @ 1982ACM0-89791-065-6/82/001/0177 $00.75 context-free grammars \nand LR parsing as presented e.g. in [2]. We stipulate that grammars are aug\u00admented with the start production \nS + $S$. A configuration of an LR parser is a string of the form qoql. . .qmlsoal. ..an( Here the sequence \nto the left of the vertical bar is the contents of the parsing stack with qm at the top; qo...qm corresponds \nto a path in an LR parsing machine starting at the initial state q ~. The se\u00adquence to the right of the \nvertical bar is in turn the remaining input str~flg. The symbol a is the o eu~rent input symbol and a \nn the end marker= !$. The parsing of terminal string w begins at the corresponding initia2 configuration \nqolw$, where q. is the initial state. The string w is in the lan\u00adguage if and only if the accepting configuration \nqOqfl$ is reached. Here qf is the successOr state GOTO(qo, S) . If at a non-accepting configuration no \nparsing action is possible, then this configuration is an error configuration. If the terminal string \nto be parsed is not in the language, then the parser in due time detects an error, i.e. enters an error \ncon\u00adfiguration. In an error configuration the current input symbol is not aeeeptabZe at the topmost state \nin the stack, i.e. the topmost state has no parsing action on the current input symbol. Phrase-1evel \nrecovery Phrase-level recovery is based on the isolation of an error phrase , which is then replaced \nby a suitable reduction goal . If (2.1) qoql.. .qmlaoal. ..an is an error configuration, we say that \na substring (2.2) qi+l.. . qmlao. aj-l of (2.1) is an error phrase in (2.1) if there is a nonterminal \nA such that q = GOTO(qi, A) # 0 and A the terminal aj iS aCCQDtablQ at qA. Here i may equal m and j may \nequal O, i.e. both the stack por\u00ad tion and the input portion of the error phrase may be empty. We say \nthat qi, A, qA and aj are the T@ eovery state, (reduction) goal, goaZ state and ~e COVSry symbol, respectively. \nThe effect of the phrase-level recovery action implied by the error phrase (2.2) and its reduction goal \nA is to replace (2.2) by the string qAl, i.e. the error configuration (2.1) is transformed into the non-error \nconfiguration (2.3) qo... qiqAlaj. ..an. Important reduction goals The requirements imposed by the general \ndefini\u00adtion on error phrases and their reduction goals are not, as such, sufficient to guarantee unique \nrecOv\u00adery actions. Even a fixed error phrase has usually more than one reduction goal. For example, in \nthe Pascal language an error phrase consisting of a partially parsed erroneous statement has as its reduction \ngoals, besides the nonterminal Statement, all the special cases of Statement, i.e. Unlabeled-Statement, \nAssignment Statement, Compound-State ment, etc. However, the overall effect of the re covery action is \nthe same no matter which reduction goal is chosen: after zero or more reduce actions the parser will \nenter the configuration in which a state with entry symbol Statement is on top of the stack. This motivates \nthe following concept: a reduc\u00adtion goal A of error phrase ~lx in error configu\u00adration a~lxy is important \nif ~lx has no reduction goal B that can nontrivially derive A by using only unit productions (i.e. productions \nof the form C + D, where D is a single nonterminal) , The important reduction goals are precisely those \nconsidered by Leinius [8] and Peterson [11]. Their strategy is to find an error phrase that has only \none important reduction goal. This uniquely defined reduction goal is then used to replace the error \nphrase. Feasible reduction goaZs The definition of important reduction goals in no way takes into account \nthe already correctly parsed portion ~ of the error phrase ~lx in ques\u00adtion. If we take the usual hypothesis \nthat the con\u00adtents of the stack are correct, then it is natural to require that ~ should correspond to \na prefix of some string derivable from the chosen reduction goal A. Clearly, only then can Rx be regarded \nas an erroneous instance of A. Formally, we say that reduction goal A of error phrase qi+l... is feasibZe \nif there is qmlao. ..aj_l ,a terminal string z such that A can nontrivially Experimental results have \nshown that it is ad\u00adrightmost derive ~i+l.. .~mz, where ~k denotes the vantageous to use a search order \nthat is oriented entry symbol of qk for each k = i+l, . . ..m. There is to consuming stack states slightly \nmore than input an algorithm that determines the feasible reduction tokens. The following order is used \nin HLP unless goals in an error configuration, but it is not pre-the user specifies otherwise: (m,O), \n(m-l,O),(m-2,0), sented here because in the current version of HLP (m,l), (m-3,0), (m-l,l),(m-4,0) ,.. \n.,(O,n). we have resorted to a weaker and easier-to-imple- Restart actions ment form of true feasibility. \nOur experiments have shown that in practice the The feasibility requirement may sometimes have feasibility \nof a reduction goal can very often be the effect of making any recovery action impossible. decided by \ninspecting only the first state qi+l in This kind of situation occurs e.g. when the parser the stack \nportion of the error phrase. In other has recognized a complete sentence in the language, words, the \nproperty that A can nontrivially right-but the remaining input string is still non-empty. most derive \na string of the form ~i+lz usually suf-The length of the input buffer of the parser also fices to make \nA feasible. We call this simpler prop-limits the set of potential recovery actions. In erty of A weak \nfeasibility. Of course, in the gen the current version of HLP a very straightforward eral case weak feasibility \ndoes not imply true feas-procedure, called a restart action, is applied ibility. It seems, however, that \nweakly feasible re-whenever no normal recovery action is possible: the duction goals that are not truly \nfeasible tend to topmost element in the stack is deleted. occur only in cases in which the error phrase \nin Guaranteeing termination question stretches down very deep into the stack. Note that the weakly feasible \nand truly feasfble re An error recovering parser should naturally be duction goals coincide when the \nlength of the stack an algorithm, i.e. it should be able to process any portion of the error phrase is \nAt most one. terminal string of the grammar and to terminate correctly. It is clear that a cano?ricaz \nLR(l) pars- Selection strategy for error phrases er augmented with phrase level recovery always ter\u00ad \nPhrase-level recovery in HLP relies on error minates: recovery symbols are always guaranteed to phrases \nwith unique important weakly feasible reduc-be shifted. The same does not, however, need to tion goals. \nThe recovery routine searches the error hold if a reduced variant of the canonical parser, configuration \nfor an error phrase ~lx that has ex-such as SLR(l) or LALR(l), is used: a recovery sym\u00adactly one important \nweakly feasible reduction goal bol may, after one or more reduce actions, turn out A, and then replaces \n~lx by Al. The search for f3\\x to be in error (see [17]). begins with the shortest possible error phrase, \ni.e. In HLP, the problem is solved by regarding a that consisting only of the vertical bar, and pro-phrase-level \nrecovery action as a potential recov\u00adceeds with larger and larger segments of the error ery alternative \nonly if the corresponding recovery configuration. symbol is shiftab Ze at the goal state, i.e. the The \nultimate recovery decision thus depends on goal state has a shift action on the recovery sym\u00adthe order \nin which the search for the error phrase bol. is performed. Let us denote by pair (i$j) the seg\u00adment \nqi+l... qmIaO. ..aj_l. Then (m,O) means the sole 3. Local correction in LR parsing vertical bar, and \n(O,n) means the whole error con\u00adfiguration (without the surrounding q. and an). We Experimental results \nshow that the quality require that in any search order the pair (m,O) ap\u00ad of phrase-level recovery actions \ndepends undesira\u00adpears as tbe first and (O, n) as the last, and that bly strongly on the form of the \nproductions in the grammar. Seemingly simple errors, e.g. single mis whenever (il,jl) precedes (i2,j2) \nthen either no error phrase can precede sing or wrong delimiter symbols, are often handled 11 > 2 r jl \n<32 (i e any of its subphrases in the search order). unsatisfactorily even if the most natural grammatical \nconstructions are used. For example, if statement lists are produced in Pascal by means of the pair of \nproductions Statement-List + Statement I Statement-List ; Statement, .then a mis\u00adsing semicolon between \ntwo statements most probably causes the deletion of the whole of the latter statement. However, if the \nproduction Statement-List + Statement List ; Statement were replaced by the pair of productions Statement-List \n+ Statement List <;> Statement and <;> + ,>.then the missing semicolon could be handled very nicely, \ni.e. by replacing the error phrase by <;zI. This recovery action amounts to what is called local correction. \nBy introducing for each terminal symbol a the new production <a> + a we can within our phrase level recovery \nscheme simulate local corrections that are either insertions or replacements of ter\u00ad minals. If we develop \nthe grammatical transforma\u00adtion a little further and use instead of production <az + a the production \n<a> + <&#38;>a, in which <&#38;> is a new nonterminal deriving only the empty string &#38;, then we can \nalso simulate deletions. In practice, there is no need to apply the transformation explicitly to the \noriginal grammar. The effect of the transformation can be obtained directly by extending the concept \nof an error phrase so that in addition to nonterminals, both terminals and the empty string are allowable \nreduc\u00adtion goals. In the case of a terminal reduction goal the goal state and the recovery symbol are \nde\u00adtermined as in the case of a nonterminal reduction goal, whereas in the case of an empty reduction \ngoal there is no goal state, and the recovery sym\u00adbol must be a shiftable terminal at the recovery state. \nSelection strategy for local eomeetions The introduction of local corrections greatly increases the \nnumber of potential recovery actions. Therefore , a careful selection strategy is neces sary for local \ncorrections. Firstly, we restrict the error phrases serving as bases for local cor\u00adrections so that only \nthe three simplest kinds of local correction can be simulated: insertion of a single terminal, deletion \nof a single terminal, and replacement of a single terminal by another. Secondly, we evaluate the respective \ncost of each allowable local correction, and then choose one with the lowest cost. The total cost of \na lo\u00adcal correction is the sum of two components. The first, called the modification cost, measures the \namount of changes inflicted upon the error config\u00aduration. Following Graham and Rhodes [6,12], we assign \neach terminal of the grammar both a deZe\u00adtion and an insertion cost. The modification cost of a local \ncorrection that is a replacement of terminal a by terminal b is obtained as the sum of the deletion cost \nof a and the insertion cost of b . The second component of the total cost, called the sa~et~ cost, in \nturn measures the reliability of the local correction by means of the recovery symbol used. Determination \nof the deletion and insertion costs, as well as the safety cost, could in prin\u00adciple be left to the compiler \ndesigner. However, in the current version of HLP the costs are fixed and only depend on the type and \nlength of the ter\u00adminal. The deletion costs are high for long key\u00adwords and low for short token classes, \nwhereas the insertion costs are low for short keywords and higher for token classes (and long keywords). \nAc\u00adcordingly, the deletion of the Pascal keyword PROCEDURE is very expensive, whereas the insertion of \na semicolon is cheap. The safety cost, in turn, is low for long keywords and high for short token classes \nso that e.g. PROCEDURE is a considerably cheaper recovery symbol than a one-letter identi\u00ad fier. In determining \nthe total cost of a local cor\u00ad rection that is a replacement of token class a by keyword b we also take \ninto account the pos\u00adsibility that a is a misspelling of b . In that case the total cost of the replacement \nis set to the lowest possible value. String a is considered a misspelling of string b if the number of \nmini\u00admum distance errors in a with respect to b does not exceed a designated maximum. The elementary \nerrors considered are insertions, deletions and replacements of single characters, and transposi\u00adtions \nof two adjacent characters. The maximum num\u00adber of errors allowed depends on the lengths of a and b , \nand can, in principle, be changed by the user. 4. Error reporting In the design of the error handling \npart of HLP special attention has been paid to the automatic generation of error message texts. In the \ncase of each error detected, an error recovering parser produced by HLP issues two error messages, a \ndec\u00adlarative and an operational one (cf. [12]). Both messages have their individual, complementary roles \nin error reporting. The declarative message pin points the location of the error and describes the nature \nof the error from the viewpoint of the parser before any recovery has been tried, whereas the operational \nmessage indicates the particular recov\u00adery action performed. The declarative message depends on the topmost \nstate in the parsing stack in the error configura\u00adtion, more specifically, on the essential LR items \nin the topmost state. We recall that a state q in an LR parsing machine is obtained as the closure (under \nthe descendant relation ) of the set of es\u00adsential LR items in q, i.e. of LR items [A+ o..B, y] in which \na is non-empty. The declarative message associated with q contains a reference to the first symbol X \nof (3 and is either of the form No X can start with this or of the form X expected , depen ding on whether \nX is a true nonterminal (i.e. one that generates more than a set of single terminals) or a terminal (or \na nonterminal generating only a set of terminals). The parsers produced by HLP are designed to perform \ndefault reductions (i.e. re\u00adduce actions involving no checking of the current input symbol) so that no \nreduce state with reduce actions by non-empty productions can ever appear on top of the stack. This means \nthat in the essen\u00adtial items the string ~ is always non-empty. The operational message in turn simply \ndisplays the changes made by the recovery action on the er\u00adror configuration. If the recovery action \nhas the effect of replacing error phrase alx by string sly, then the associated operational message is \nThe re covery action was to replace 6.x by ~y , provided that both 8X and By are non empty (here ; and \n~ de\u00adnote the strings of entry symbols of the states in a and ~). If ax is empty, the form The recovery \naction was to insert ~y V is used, and if Ey is empty, the form The recovery action was to delete ;x \nis used. 5. Experiments with B6700 Extended Algol In the following we -report some experimental results \nobtained by applying the error handling technique of HLP to a large programming language, the Burroughs \nB6700 Extended Algol [3]. Since the installation of the Burroughs computer at the Uni versity of Helsinki \nin 1970, Extended Algol has been the principal language used by computer sci\u00ad ence students as well as \nresearchers at the Uni\u00adversity. During the spring term of 1980, we collected a sample of 55 erroneous \nExtended Algol programs written by students at the lower and intermediate level of their computer science \nstudies. The prog\u00adrams amount to 13404 cards and 72191 tokens, so that the average size of a program \nis 243.7 cards and 1313 tokens. The total number of actual syntax errors is 500, which means 9.1 errors \nper program (all lexical errors, such as missing string delim\u00aditers, were corrected before any further \nanalysis). The LALR(l) grammar used in our experiments consists of 512 productions, and it generates \na large subset of Extended Algol [16]. The error re\u00ad covering LALR(l) parser produced by HLP for the \ngrammar comprises 19181 program lines, and its compiled version 32.4 K words of B6700 machine code. The \nrecovery routine comprises about 40 % of the total. Missed errors and extraneous messages Of the total \nnumber of 500 errors, our error recovering Extended Algol subset parser missed 29, i.e. 5.8 %. That \nas many as 94.2 % of the er\u00ad rors were detected and reported is certainly prom\u00ad ising. Moreover, in 42 \nprograms all the errors were detected. In 9 cases the missing of an error was due to a phrase-level recovery \naction from another actual error: the error happened to lie inside the error phrase, and was therefore \nleft unnoticed. The remaining 20 errors were missed because of re\u00ad covery actions from extraneous errors \ncaused by unsuccessful recovery actions. Of the total of 846 messages issued by the parser, 375 messages, \ni.e. 44.3 %, can be consid\u00ad ered extraneous. This means that for every actual error detected there were \n1.8 messages on the aver\u00ad age. As many as 52 % of all extraneous messages were caused by unsuccessful \nlocal corrections, whereas 40 Z were caused by phrase-level actions and 8 % by restart actions. The average \nnumber of extraneous messages caused by a recovery from an actual error was 0.87 for local corrections, \n0.67 for phrase-level actions and 1.25 for restart ac\u00ad tions . Performed reeoverg actions The recovery \nactions performed by the error re covering parser were divided into local corrections, phrase-level actions \nand restart actions as follows: Of the 471 recoveries from actual errors, 47.3 Z were local corrections, \n47.6 % phrase-level actions and 5.1 % restart actions. Considering all the 846 recoveries (i.e. including \nrecoveries from extra neous errors), the percentages were 45.3, 45.5 and 9.2. The total number of input \ntokens skipped by recovery actions was 1137 (obtained by summing up the lengths of input portions of \nerror phrases taken over all the recovery actions). This represents 1.6 % of the total program text. \nThus as much as 98.4 Z of the program text was processed in the normal parsing mode. Of course, some \nportions of the 98.4 Z were not processed in exactly the way the prog\u00ad rammer had intended, because of \nthe effects of the extraneous errors. Nevertheless, we can regard the percentage as promising. Quality \nof recovery actions Some authors (e.g. [9,1 O]) have classified the recovery actions performed by their \nerror recovering parsers into different categories, such as excel\u00adlent , good and poor , according to \nthe oueraZZ quaLit~ of the actions. We have used four categor ies: excellent, good, fair, and poor. These \ncate\u00ad gories only apply to recoveries from actual er\u00ad rors, whereas recoveries from extraneous errors \nare not classified at all. We classify a recovery action from an actual error as excelZe?zt if it clearly \ncorresponds to what the programmer intended. In addition, we re\u00adquire that it neither causes extraneous \nmessages nor the missing (or even the possibility of missing) of another actual error. If a recovery \naction prob\u00adably does not correspond to what the programmer in tended but still gives rise to neither \nextraneous messages nor missed errors, we classify it as good. For a fair recovery action we allow one \nextraneous message or one missed error (but not both at the same time) . If a recovery action does not \nmeet the requirements of a fair recovery action, we classi\u00adfy it as poor. (See the sample run depicted \nin Figure 1.) The 471 recoveries from actual errors perform\u00ad ed by our error recovering Extended Algol \nsubset parser were divided up into the four categories as follows: 40.1 % were excellent, 27.0 Z good, \n16.6 Z fair, and 16.3 Z poor. Recovery speed The total B6700 CPU time spent by the parser on processing \nthe 55 programs was 458 seconds, 89 seconds (19.4 %) being spent by the recovery rou\u00adtine. The average \nspeed of the parser was 29.3 cards and 157.6 tokens per second when processing erroneous text, and 192.6 \ntokens per second when processing error free portions of it. The average time spent by a single recovery \naction was 0.11 seconds, whereas the total time needed for the eventual recovery from a detected actual \nerror was 0.19 seconds (this latter figure includes the time spent on the extraneous errors). 6. Experiments \nwith Ripley s and Druseikis error sample Ripley and Druseikis [13] have collected and analyzed a sample \nof erroneous student-written Pascal programs. The original sample comprised 237 erroneous programs amounting \nto 12000 cards. A re\u00adduced version of the sample, consisting of 127 er roneous program fragments (artificially \naugmented to make them complete programs), have been used by some authors (e.g. [5,9,10]) to evaluate \ntheir re\u00ad covery techniques. Recently, we have received from Professor Ripley this reduced sample and \ntested our technique with it [181 . The size of the reduced sample is 901 cards and 3717 tokens. According \nto our interpretation, there are in all 182 syntax errors (with respect to a syntax generating lists \nof Pascal programs). In 15 programs there are also lexical errors (our scanner reported 26). Thus there \nare 0.056 syntax and lexical errors per token, which means a VAR L,N: REAL; >>>>>>(3001>>>>>> * No Program \ncan start with this. E >>>>>>>>>>>>>>>> The recovery action was to insert Program-Heading. FUNCTION GETELEMENT(VAR \nX: INTEGER); BOOLEAN; >>>>>>(3002>>>>>> * : expected. E >>>>>>>>>>>>>>>> The recovery action was to replace \n; by : . BEGIN IF NO IF NOT GETELEMENT(LOC) THEN  >>>>>>0(303>>>>>> * THEN expected. G >>>>>>>>>>>>>>>> \nThe recovery action was to insert THEN . WRITELN THERE IS AT LEAST ONE LOOP IN THE RELATIONS ); >>>>> \n>0004>>>>>> ( expected. * E >>>>>>>>>>>>>>>> The recovery action was to insert ( . END; (* GETELEMENT \n*) PROCEDURE FACTORIAL(X: INTEGER; VAR FACT: INTEGER): INTEGER; 1.1 * >>>>>>0005>>>>>> expected. VAR \nFFACT,FSTIRLDREAL; X,M:IN;EGER; G >>>>>>>>>>>>>>>> The recovery action was to replace PROCEDURE Identifier \nFormal Parameter-Part : >>>>>>>>>>>>>>>> INTEGER ; by Routine Heading. >>>>>>0006>>>>>>  * ! f or f \n: t expected. > G >>>>>>>>>>>>>>>> The recovery action was to replace Identifier-List by Variable-Declaration \nList. TYPE ORDER= ARRAY [1 . . MAXRELATIONS, 1 . . 2] OF INTEGER; >>>>>>0007>>>>>> * Neither Routine-Declaration-Part \nnor Variable Declaration can start with this. F >>>>>>>>>>>>>>>> The recovery action was to insert Routine-Heading. \nTYPE SORTED ARRAY [1 . . MAXELEMENTS] OF INTEGER; >>>>>>0008>>>>>> * Neither Variable-Declaration-Part \nnor Type-Definition can start with this. F >>>>>>>>>>>>>>>> The recovery action was to insert Routine-Heading. \n>>>>>>0009>>>>>> * = expected. E >>>>>>>>>>>>>>>> The recovery action was to insert = . BEGIN ; PROCEDURE \nFACTR(N: INTEGER; VAR FACTOR: INTEGER); >>>>>>0010>>>>>> * No Statement can start with this. F >>>>>>>>>>>>>>>> \nThe recovery action was to replace TYPE Type-Definition-List ; BEGIN >>>>>>>>>>>>>>>> Statement-List \n!; by Routine-Body. M IF COUNTILISTDATAISUB] :=O THEN x >>>>>>0011>>>>>> * No Routine-Body can start \nwith this. >>>>>>>>>>>>>>>> The recovery action was to insert BEGIN . * !], or f,! expected. >>>>>>0012>>>>>> \n END; (* FACTR *) F >>>>>>>>>>>>>>>> The recovery action was to replace Variable [ Expression-List := \n O by >>>>>>>>>>>>>>>> Boolean-Expression. BEGIN FFACT (POWER(M,X)*EXP(-M)) DIV (FACT(X)); L >>>>>>0013>>>>>> \n* Illegal character. >>>>>>0014>>>>>> * I;I or fENDr expected. G >>>>>>>>>>>>>>>> The recovery action \nwas to replace Statement-List . . . ) by Statement List. END; (* FACTORIAL *) BEGIN IF Y[N; = Y[M] >>>>> \n>0015>>>>>>  * 1 or . expected. P >>>>>>>>>>>>>>>> The recovery action was t: replace IF Variable [ \nExpression-List by Statement-List. .X >>>>>>0016>>>>>> * No Statement can start with this. >>>>>>>>>>>>>>>> \nThe recovery action was to delete !=! . THEN X:= 1 *1,  x >>>>>>0017>>>>>> . , [ , + or := ewected. \n>>>>>>>>>>>>>>>> The reco ery action was to replace Variable THEN X1 by Variable. END. (* PROGRAM *) \n X >>>>>>0018>>>>>> * ; expected. >>>>>>>>>>>>>>>> The recovery action was to replace VAR Variable-Declaration-List \n; Routine-Heading >>>>>>>>>>>>>>>> Routine-Body Routine Heading Block by Block. 1 2 3 4 5 6 7 8 9 10 \n11 12 13 14 15 16 17 18 19 20 21 22 considerably higher error density than in our un\u00ad Figure 1. Sample \nrun of the HLP-produced Pascal parser. The errors in the program have been selected from the student \nprograms collected by Ripley and Druseikis [13]. Key to the markings: E stands for excellent, G for good, \nF for fair, and P for poor recovery, x for extraneous message, M for missed error, and L for lexical \nerror. seduced Algol sample (0.007). The percentage of syntax errors missed by our error recovering \nPascal parser was 7.7 (14 errors out of the total of 182) , which is slightly higher than in the Algol \nsample. The percentage of extra neous messoges, in turn, was distinctly lower than in the Algol sample, \ni.e. only 29.7 (71 extraneous messages out of the total of 239 syntax error mes\u00ad sages issued). Thus, \nfor each actual syntax error detected there were only 1.4 messages on the aver\u00ad age. Of the total of \n239 recovery actions per~orrned, 56.9 Z were phrase-level actions, and the rest were all local corrections \n(thus, there were no restart actions) . The percentage of tokens skipped was 8.3, which is higher than \nin the Algal sample and re\u00adflects the high error density. Of the total of 168 recovery actions from actu\u00adal \nerrors, 36.3 Z were rated exeellezt, 31.0 % good, 22.6 % fair, and 10.1 Z poor. Comparing other authors \nresults with ours is difficult because the evaluation principles used are not known. Pai and Kieburtz \n[9] report that their error recovering Pascal parser (an LL(l) parser augmented with a global context \nrecovery scheme) found all of the errors that were visually detected in the program texts and that out \nof the total of 189 recovery actions performed, 52 % were excel\u00adlent, 26 Z good, and 22 % either fair \nor poor. The percentage of extraneous messages is not given. Pennello and DeRemer [10] in turn report \nthat out of the total of 76 recovery actions performed by their error recovering Pascal parser (an LALR(l) \nparser augmented with a forward move technique), 42 % were excellent, 28 % good, 12 % fair, and that \n18 Z resulted in error unrepaired . References 1. Aho,A.V. , Translator writing systemsi Where do we \nstand? Computer 13 (1980), 9-14. 2. Aho,A.V. , and J.D.Ullman, Principles of Compiler Design. Addison-Wesley, \n1977. 3. Burroughs Corporation, Burroughs B6700/B7700 AZgoZ Language Reference Manual. 4. Ciesinger, \nJ., A bibliography of error handling. SIGPL.4V Notices 14 (1979), 16-26.  5. Druseikis,F.C. , and G.D.Ripley, \nError Recovery for Simple LR(k) parsers. In: ACM 76, Proceed ings of the Annual Conference,1976, 396-400. \n 6. Graham,S.L. , and S.P.Rhodes, Practical syntac tic error recovery. CACM 18 (1975), 639-650.  7. \nJames,L.R. , A syntax directed error recovery method. Technical Report CSRG 13, Computer Sys\u00adtems Research \nGroup, Univ. of Toronto, 1972. 8. Leinius,R.P. , Error detection and recovery for syntax directed compiler \nsystems. Ph.D.Thesis, Univ. of Wisconsin, 1970. 9. Pai,A.B. , and R.B.Kieburtz, Global context re covery: \nA new strategy for syntactic error re\u00adcovery by table-driven parsers. Z OPL.4S 2 (1980), 18-41.  10. \nPennellojT.J. , and F.DeRemer, A forward move algorithm for LR error recovery. In: Conf. Rec. of the \n5th Annual ACM Symposium on Principles of Programming Langzlages, 1978, 241 254. 11. Peterson,T.G. , \nSyntax error detection, correc\u00adtion and recovery in parsers. Ph,D.Thesis, Stevens Institute of Technology, \n1972. 12. Rhodes,S.P. , Practical syntactic error recovery for programming languages. Technical Report \n15, Dept. of Comp. Sci., Univ. of California, Berkeley, 1973. 13. Ripley,G.D. , and F.C.Druseikis, \nA statistical  analysis of syntax errors. Computer Languages 3 (1978), 227-240. 14. R~iha,K-J. , M.Saarinen, \nE.Soisalon-Soininen and M.Tienari, The compiler writing system HLP (Helsinki Language Processor). Report \nA-1978-2, Dept. of Comp. Sci., Univ. of Helsinki, 1978. 15. Sippu,S. , Syntax error handling in compilers. \nReport A-1981-1, Dept. of Comp. Sci., Univ. of Helsinki, 1981. 16. Sippu, S., The error handling part \nof HLP: a program description. Internal Report C-1981 6, Dept. of Comp. Sci., Univ. of Helsinki, 1981. \n 17. Sippu,S. , and E. Soisalon-Soininen, A scheme for  LR(k) parsing with error recovery. Part I: LR(k) \nparsing, Part II: Error recovery, Part III: Error Correction. Intern. J. of Computer Mathematics 8 (1980), \n27-42, 107-119, 189-206. 18. Sippu,S. , Experiments with an error handling technique. Dept. of Comp. \nSci., Univ. of Hel\u00adsinki (to appear) .  \n\t\t\t", "proc_id": "582153", "abstract": "An automatic syntax error handling technique applicable to LR parsing is presented and analyzed. The technique includes a \"phrase-level\" error recovery strategy augmented with certain additional features such as \"local correction\". Attention has also been paid to diagnostic aspects, i.e. the automatic generation of error message texts. The technique has been implemented in the compiler writing system HLP (Helsinki Language Processor), and some promising experimental results have been obtained by testing the technique with erroneous student-written Algol and Pascal programs.", "authors": [{"name": "Seppo Sippu", "author_profile_id": "81100033950", "affiliation": "University of Helsinki, Finland", "person_id": "P261799", "email_address": "", "orcid_id": ""}, {"name": "Eljas Soisalon-Soininen", "author_profile_id": "81100634467", "affiliation": "University of Helsinki, Finland", "person_id": "P76898", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/582153.582173", "year": "1982", "article_id": "582173", "conference": "POPL", "title": "Practical error recovery in LR parsing", "url": "http://dl.acm.org/citation.cfm?id=582173"}