{"article_publication_date": "01-25-1982", "fulltext": "\n UNIFIED DIALOGUE MANAGEMENT IN THE CAROUSEL SYSTEM by Erik SandewaIl Software Systems Research Center \nLinkoping University Linkoping, Sweden Abstract: The paper describes the design for a software environment \nwhich unifies the dialogue management support of a number of existing software tools, such as command-language \nhandlers, shells, operating-system transition diagram interpreters, and forms management systems. The \nunification is accomplished without undue complexity: the resulting design is clean and inspectable. \nA key notion in the design is the use of three orthogonal abstraction hierarchies, for interaction contexts, \nfor interactive operations (roughly = commands), and for data types. These orthogonal hierarchies are \nused for obtaining multi-dimensional inheritance, i.e. mappings of several arguments, which may be stored \nin the system s data repository, and which inherit their values along the hierarchies represented in \nthe arguments. Mappings with multi-ctimensional inheritance are used in the invocation mechanism, i.e. \nfor selecting the appropriate procedure to be executed in various situations. Currently used programming \nlanguages and software tools only use single-dimensional inheritance. A working implementation called \nthe CAROUSEL system, is available. 1. Conventional approaches to dialogue management. It is well known \nthat the design and implemecmtion of the dialogoe with the mer, is a substantial part of the irl]p!ementation \neffort for software that is to be used interactively (see e.g. ref. IJOE80 and WAS81). A large number \nof efforts have been made to provide relief. We distinguish the following approaches: Permission to copy \nwithout fee all or part of this material k granted provided that the copks are not made or distributed \nfor direct commercial advantage, the ACM copyright notice and the title of the publication and its date \nappear, and notice k given that copybrg is by permksion of the Association for Computing Machinery. To \ncopy otherwise, or to republish, requires a fee and/or specific permksion. ThiJ research was supported \nby the Swedish Board of Technical Development under contract Dnr 80-3918. 1. Software environments, i.e. \nsoftware systems which communicate directly with the user, and which contain a number of application \nprograms, procedures, and/or modules which the user can invoke. This includes both command handlers for \noperating systems, and incremental programming systems. In its simplest form, the command handler of \nan operating system merely allows the user to select one out of a number of different application programs \n. The UNIX shell (ref. BOU78) is an example of a more powerful software environment, where the command \nlanguage contains control primitives and a procedure mechanism. Interaction by command lines, which is \nnatural in many applications, can then be implemented in the command language, rather than in the programming \nlanguage that is used for the detailed processing. Dolotta and Mashey have reported that the command \nlanguage often serves as the primary programming tool (ref. DOL80). Incremental programming languages, \nsuch as LISP (ref. SAN78, WIN81, TE178), APL, and Smalltalk (ref. BYT81) go one step further by completely \nintegrating the programming language into the computing environment. LISP systems, in particular, contain \na data repository which is used both for storing application data, and for storing procedure definitions, \nand all software management services such as editing, compiling, and generation management are done in \nthat uniform software repository. ~ Both kind of software environments support one significant aspect \nof computer dialogue, namely the need for frequent revision, or in the words of Wasserman: Our goal was \nto create a tool that would facilitate the rapid prototyping of the interactive dialogue in such a way \nthat a user could interact with the system at an early phase of system development and so that lhe developer \ncould easily modify the dialogue and present a revised interface. (ref. WAS81). @ 1982 ACM 0-89791-065-6/82/001/0146 \n$00.75 2. So ftroare tools for dialogue management: By software tools we mean software which perform \nspecific functions, and which are intended to be used by the programmer in the engineering of an application \nsystem. The following are some groups of software tools for dialogue management 2.1. Navigational too/s, \nwhich maintain a topological model of a universe in which the user moves in the course of the interaction. \nMost frequently tire universe is a network (as in the following syste~]s: IDECS: ref. I-AG75, HAG80; \nZCX: ref. RoB78, and its predecessor PRCMWS: ref. SCH79; the Transition Diagram Interpreter ref. WAS8~ \nand the design proposed by Carlson and Metz: ref. CAR80). Nievergelt (ref. NIE79) gives a discussion \nof such systems. Systems for computer-aided instruction (e.g. TUTOR: ref. GHE75; Gour-.sewriter: ref. \nMAR73) also maintain such models, but there the movement through the network is under the control of \nthe system rather than the user. The universe may also be a tree (as in the PRESTEL system: ref. FOR79), \nor it may allow continuous movement for zooming in on significant data (Spatial Data Management System: \nref. HER79). In all these systems, the user navigates in a fixed universe. There are also systems where \nthe universe is the user s information structure, particularly in~ormation management systems such as \nPIE (ref. GOL81) and ED3 (ref. STR81). 2.2. Language tools, which simplify the implementation of a set \nof commands or a command language. This includes query languages for data bases, where different ~PPlicatlons \nare realized as different information structures (e.g. using data base schemata), but the query language \nas such is a fixed resource. The I.WFID system (ref. KAM78, BUR80) is a representative example of this \nlarge group of systems. The query language approach is not sufficient when the apP~ication emphasizes \nactive manipulation of data, rather than mere access to an existing data base. Office automation systems \nis one of the applications where active data manipulation plays a major role (see e.g. Morgan s survey \narticle, MOR80). The interactive command language for an operating system has also that character. For \nsuch applications, one may use a syntax analysis tool (JOH78), but if the desired command language for \nthe application merely consists of a command verb followed by one or a few arguments (or equivalent uses \nof function keys or of pointing into menues), one may prefer a tool which parses the command line in \na standard way, and administrates the mapping from the command verbs to the procedures that define them. \nFacilities for macro expansion of commands and for help style user support are more important than a \nrich syntax: The INTRAC system (ref. WIE79) is a good representative of this wide class of systems. 2.3. \nLayout tools, which support the presentation of data on the output medium. The major interactive layout \ntool is the forms management system, which supports presentation, entry, and editing of data in forms \nwhose characteristics have been defined by the user. Forms management systems are available from the \nmajor manufacturers, and more sophisticated systems have been developed as parts of research projects, \ne.g. in the Odyssey system (ref. FIK80). In the System for Business Automation (ref. JONG80) and the \nDIAL system (ref. HAM80), forms management is available as a standard routine together with a procedural \nlanguage and a data base. These systems as well as LOIS (ref. SAN79) and the system of Tsichritzis and \nLadd (ref. LAD80) support forms flow between multiple user stations. The classical report program generator \nwas another kind of layout tool, but oriented towards the presentation of data on wallpaper listings. \nThe Qrsery-by-Example system (ZL075) has demonstrated that layout tools provide an alternative method \nfor formulating queries, instead of using syntax-rich query languages. Graphic systems (ref. NEW79) form \nanother large group of layout tools, but they are not considered in the work reported here. Martin (ref. \nMAR73) has specified a catalogue of 23 different dialogue methods. Our three main groups seem to cover \nmost of them. One may argue that these groups of tools merely reflect three important aspects of interactive \napplication programs, namely the language aspect (which accounts for how messages to the system are composed), \nthe navigational aspect (which makes it possible to have context-dependent interpretation of commands \nor other messages), and the presentation aspect (which controls the layout of the communication medium, \ne.g. the screen). Each tool provides support for one such aspect of the intended application system. \nBesides environments and tools, a third line of approach is: 3. Programming language features which facilitate \nwriting dia!ogues. The Smalltalk language and system (ref. BYT81) demonstrates how the class concept \noriginally developed in Simula can be helpful for window management. String processing and interface \nto a data base management system are also significant features in programming languages that are to be \nused for programming dialogues (ref. WAS81). A common characteristics of these three lines of approach \nis that they provide a st?ucttme within which procedure or olher program entities are stored, or what \nwe shall call a so@oa~e structure. In the operating-system shell, it is the file directories that constitute \nthe software structure; in the programming languages the software structure is defined by the global \nstructuring concepts Of t~~e language: blocks, procedures, classes, abstract data types, and the like. \nIn the interactive software tools, finally, the software structure is special-purpose a node in a transition \ndiagram, or a field in the description of an electronic form, are often associated with one or several \nprocedures, which are triggered when the respective entity is used. This observation explains why there \nare two standard ways of implementing software tools, depending on the host programming language. Incremental \nprogramming languages (e.g. LISP) allow the programmer to introduce new software structures, which means \nthat the tool can be implemented in an interpretive way: the software structure can be available at run-time. \nConventional programming langtsages, oriented towards compilation and static type checking, require the \nuse of a pre-processor which compiles the software structure, and the procedures attached to it, into \none single program or module. Johnson and Lesk (ref. JOH78) describe compiling language tools in Unix. \nThe conventional programming language preempts the choice of software structures. 2. Support of dialogue \nmanagement in office systems. The main result in the present work is tAe design of a softroare tool for \ndialogue management which is unified in the sense that it provides the essential services of the three \ngroups of tools above, and co?tct$e in the sense that it has a dean structure and an inspectable definition. \n(The key idea for combining the simplicity and the generality is a new way of using abstraction hierarchies, \nwhich will be described in latex sections). An upper bound on the complexity of the system is provided \nby the present implementation, which is 30 pages (1500 lines) of pretty printed Lisp expressions. (The \nprocedural kernel of the system is less than 100 lines). The system is called CAROUSEL (ref. SANM), and \nis available as a paper listing from the author. As for all other kinds of software, the challenge has \nnot merely been to provide all kinds of services in one single system, but to preserve the conceptual \nsimplicity of the system as the various services are included. The need for a unified and concise design \nbecame apparent in our own work on the LOIS Linkoping Office Information System (ref. SAN80), where a \nnumber of dialo~ue n?anage~ment tools were used extensively, both for implementation of various application \nservices, and as a basis for office modelling took, particularly for moclelling and implementiiwg information \nflow between workstations. The took were quite useful, but the software maintenance problems for the \ntools, and the interface problems between the various tools, caused us to look for a more concise global \ndesign. Similar experience has been reported by other researchers, in informal discussions and sometimes \nin publications. Winograd has written: It is in the domain of interaction that there is currently the \nmost to be gained from developing bodies of descriptive structures to be shared by system builders. There \nare already many pieces that can be incorporated, ... Currently each of these is in a rvorld and formalism \nof its own. Given a sufficiently flexible tool foY describing and integrating interaction packages, this \nlevel of description will be one of the basic building blocks for all systems. (ref. WGR19). Before we \nproceed to a description of the unified design, we must however first review the character of office \ninformation systems, and the applicability of the currently available tools. Office information systems \nare characterized by a relatively large number of moderately complex services, such as the familiar computer \nmail, personal calendar, personal agenda ( tickler file ), text-file management, and personal data base. \nIn what follows, we shall assume that the reader is familiar with such application programs through his \nor her own use of them. Other and more specific services are also important, such as for travel management, \nscheduling of rooms and equipment, project management, etc. In fact, most of the applications can be \ncharacterized as XX management systems , where XX ranges over messages, appointments, text files, trips, \nrooms, and so forth. Query-language tools are clearly not adequate for the construction of such office \napplications, since the emphasis in the applications is on customized sets of simple commands, and on \nvery good help services, rather than on complex queries in a rich and flexible language. Navigational \ntools create a dilemma. If the network structure is simple, then the user who is action oriented and \nwants to get a specific thing done, may easily feel constrained by the fixed structure of the available \ntopology, This problem is often met by allowing the navigation space to grow, so that all conceivable \nuser needs can be met: the PROMIS system has 35.000 nodes ( frames ) in its network (ref. ROB79). However, \nbuilding such a network requil-es a lot of work, And carries with it a darr$er of costly redundancy in \nWe network, and costly maintena~]ce. Finally, a significant problem for the users is reportedly that \nthey lose their orientation in such a vast space. Layout tools are often useful, but solve only a part \nof the whole problem. Tools which support application-specific command languages seem to be the most \nnatural ones to use, since conventional 01S services (such as mail systems) carry on a simple command \ndialogue with the user. The problem is that such took (in their usual, fairly simple form) will only \nhandle one application service at a time. A more general solution is desirable, particularly since most \nof these services have largely similar command sets: there is a create object command, a print command, \nan edit command, commands for storing away objects in various files , etc. The similarity is a natural \nconsequence of the applications beiikg XX management systems . When the users of the system complain \nthat the same thing is called different names in different services , the complaint means that the similarity \nhas not been exploited in the implementation of the total system. That is not only a disadvantage for \nthe end user; it is also a symptom of costly software redundancy. Although many of the important commands \nare analogous throughout the various application services, we also have commands which are specific for \none application, or a limited class of applications. For example, mail systems is an example of browsing \napplications where the concept of the current object is defined (e.g. the mail message that is presently \nbeing looked at). Operations such as next are restricted to such applications. It follows, therefore, \nthat a simple extension of the query language strategy would not be adequate: a general-purpose command \nlanguage, complemented by a data definition for each application, would not make it possible to have \napplication-specific commands. Besides the simple, command-driven services which are xx management systems \n, there are also substantial services which do $O??cetfiing (e.g. computations) be5ides data management, \nHowever, when such services are to be used interactively, the management of the user interaction often \naccounts for a surprisingly large part of the software volume (in terms of both lines-of-code and programmer-hours). \nBoehm reports experiments where the parts of the program which really perform the task at hand, accounted \nfor only 2-3 % of the software (BOE80). The same considerations as we have discussed for XX nmnagement \nsystems also apply when tools are to be used for the interaction part of S!.lbstantial services. 3. The \nunified design. We shall describe the basic ideas of the generalized tool in terms of an interpretive \nimplementation, where the tool is a software environment which may be used by an end user, and whose \ndetailed behavior is determined by application descriptions of various kinds, which are stored in the \nsystem. The extension to a compiling strategy does not seem to offer any problems in principle, but only \na lot of extra work. (Our own implementation, the CAROUSEL system, is interpretive). The basic behavior \nof the software environment is to repeatedly make interactions with the user. In each interaction, the \nuser specifies an operation, e.g. print , enter , or delete . He may also specify parameters for the \noperation. The methods for specifying operations and parameters may vary: operations may be entered by \ntyping a command verb, pressing a. function key, or pointing at a menue; parameters may be typed in, \nor derived from the current state of the machine. For example, the current cursor location may be a parameter. \nAt each interaction, the current state of the machine and the system determines that it is in a particular \ncontext, e.g. mail management or address directory management . Thus different applications are realized \nnot as separate programs, but as separate contexts within the generalized tool. The methods for inputting \noperations and parameters may be defined for each context. For each interaction, the system looks up \nthe definition of the specified operation in the present context, and executes it. Thus there is an operation-defining \nmapping Od contexts * operations ..> procedures which is stored in the data repository of the system. \nAlthough each combination of arguments for od may have its own value stored separately, the $ystem obtains \nits power from the observation that the values of od may very often be specified for abstractions of \nthe ftrst and lhe second arguments. The use of abstractions for the first argument realizes the observation \nthat we made above, namely that analogous operations may occur in several applications (= contexts). \nThus we have a partial ordering -> on contexts so that c -> cc means that cc is an abstraction of c (while \nc is a partictslarization of cc), and we make the rule that if the data repository contains c -> cc M(cc,op) \n= p  but no definition for od(c,op), then the listed value p will be used instead ( inherited ). The \nrule is extended transitively, Since the major difference between applications is that they use different \ndata structures, the context-independent definition p of the operation op, must often be directed by \nthe data description ( declaration ; schema ; we shall use the word prototype ) that is associated with \nthe specific context c. For example, the operation for entering a new object will characteristically \nprompt the user for the successive fields or properties that should be defined for objects in the current \ncontext. A necessary prerequisite for this arrangement is that the various applications or contexts use \na common data base structure for application data. It is convenient to use the same data repository for \nboth application data and system data (such as the od mapping), and we shall discuss the structure of \nthe data repository in more detail below. Let us remark here, however, that the data base allows tree \nstructured objects, where e.g. a conventional record can be a node in the tree, with the record s fields \nas daughter nodes, and a sequence of records can be a higher level node, with the successive records \nin the sequence as daughters. Quite often, different contexts require the definitions of operations to \nbe a~mo$~ the same. The enter operation, again, may have to ask the user for the desired type of the \nnew objects (in contexts where objects of several types are maintained in parallel]), and may have to \ninsert the object into one or more files (e.g. into the current file, in a browsing-type context). Thus \nbesides the operation-definition mapping od, there are other mappings from contexts (or other kinds of \nobjects, such as operations, or types) to auxiliary procedures which are invoked by the operation s main \nprocedure. The same mechanism turns out to be quite useful for abstraction on operations as well. When \nthe basic OPerations such as print , enter , edit , etc. are re]ieved of their context-specific details, \nthe remainder is in most cases a tree traversal, which is performed in parallel over the current object \nand the prototype for the current object. We can therefore extend the use of abstractions to the second \nargument of the operation defining mapping od: the standard operations have a common abstraction traverse \n, and all cases of standard operations in standard contexts are accounted for by one single entry in \nthe data repository, ocl(cwnmnn-cx, traverse) = travproc where travproc doe,s a tree traversal, and invokes \nboth context-specific and operltion-sp?cific procedures at well-defined points. The most important operation \nspecific procedure is the teat procedure, i.e. the procedure which determines what the operation is to \ndo whenever it reaches a leaf. A print operation prints out the current value; an enter operation prompts \nthe user for a new value, etc. Other operation specific procedures are needed for various kinds of exception \nconditions, for example the rrrisstng dezu$hter procedure: if the tree traverser expects to see a branch \nto a particular daughter, which however does not exist in the current data base, the action of the traverser \ndepends on the choice of operation: a get and a delete operation will bypass the missing subtree, whereas \nan enter operation will cre~te an appropriate subtree in this place. The various operation-specific procedures \nare often shared between groups of operations. Thus we do not need to define each such procedure for \neach operation; instead we define an abstraction hierarchy on the operations, and associate the operation \nspecific procedures with nodes on different levels in that hierarchy, with inheritance in the obvious \nway. For example, operations which act on one single term in a record ( get , put ,...) often have counterparts \nwhich do the same operation on the whole record ( print , enter ,...). Corresponding pairs in these sets \nof operations can share abstractions, and beyond it they need only one single procedure to define them \n-a procedure which is invoked in the process of identifying the tree structure that is going to be traversed. \n We can see how concepts from programming languages carry over to the generalized interaction tool, but \nihey re-appear in new forms. As could be expected, the concept of type is also significant. It comes \nin most importantly as follows: among the leaf operations for the various operations or operation abstractions, \nseveral must also depend on the type of the value in the leaf. Printout, data entry, editing, etc. is \ndone differently depending on the current type. Such leaf operations therefore use another mapping of \ntwo arguments, the type-leaf definition tld: operation * type --> procedure which spec!fies a procedure \nfor doing that operation on leaves containing a value of that type. As for od, the possibility of inheritance \nin each of the two arguments turns out to be very useful. Besides the instances of tree traversal, there \nare also other kinds of operations. Some, such as the operation for switching contexts, or t?le operation \nfor asking for help, are defined in all contexts, and depend on context-specific information, but do \nnot particinatd in WIy operation abstraction, and do no% usc the traversal proccl]urc, CMhcrs, such \nas the operation for moving to the next item in the browsing sequence, are defined over a more restricted \ncontext abstraction, and use no operation abstraction. Again others, such as the operations for maintaining \ncatalogs (such as mailing-lists, or sets of particular groups of messages in a computer mail system) \ncan be implemented as temporary shifts into an alternative context (which is derived frolm the current \ncontext), and performing one of the standard operations Some additional examples of operations will be \ndiscussed in section ~, The traversal procedure captures the fact that several operations share the same \ncontrol structure: it is ana]ogou5 to the mapcar-type functions in LISP, and an example of a control \nabstraction in the sense Of Liskov (LIS77). (Hagglund (HAG80) has extended the concept of control abstraction \nto the case when one descriptive structure allows several different interpreters). In the CAROUSEL implementation, \nthe use of the control abstraction has led to the following proportion between various types of inforrnafion \nin the source file: the traversal procedure is about 90 lines of pretty printed procedures, the pretty \nprinted representations of the information for the central contexts and commands is about 500 lines, \nand low-level procedures for manipulating the data representation and miscellaneous interface procedures \nis about 800 lines of pretty printecl procedures. Since the information in the latter two groups can \nbe specified and analyzed on a procedure-by-procedure or definition-by-definition basis, and only the \nexecutive procedure need be analyzed as a single chunk, this represents a successful modularization. \n4. The structure of the data repository in CAROUSEL. The data repository should be able to store both \nthe information in the applications, and the information required by the system itself. In particular, \nit should be able to store the abstraction hierarchies for contexts, operations, and value types, and \nthe various mappings from these kinds of entities to procedures (such as od and tld). Presumably, most \ndata base structures would be able to represent this information. In our CAROUSEL implementation, the \ndata repository is organized around entities and frames. The entity concept is used as in Chen s original \npaper (CHI?76), i.e. entities are representations in the data repository, of concrete or abstract objects \nwhich bear a significance for the computer user. Persons, cars, c~~prr~er t~r~i~a[s, op~r~~~n~s, and \ncont?xt.s are examples cf entities. Entities are organized in a taxonomical structure using the -> relation. \nBesides its use for the system information, which has already been described, it is well known that such \nstructures are also useful for modelling application data (see e.g. ref. QU169 and MYL80). The CAROUSEL \nsystem contains not only a transitive -> relation, but also a set membership relation =>. The latter \nis however not necessary for the purposes described in the present paper. Each entity is associated with \na frame, i.e. a tree structure where the terminal nodes may contain a value (e.g. a string, a number, \na text file, another entity, or a set of entities), and where norl-terminal nodes have a number of daughters, \nwhich are again frames, recursively. Each arc from a non-terminal node to a daughter is marked with a \ntag. 150 Access to information in the data repository is usually specified as the name of an entity, \nwhose frame is to be accessed, and a sequence of tags which are to be used for selecting the appropriate \ndaughter in the successive steps down into the frame. As usual in such systems, the -> relation on entities \ndefines an inheritance condition for the frames, i.e. if a value or subtree corresponding to a certain \ntag sequence is missing in the frame for a concept c, and c -> cc, then a default is provided by the \nleaf or sub-tree in the frame of cc under the same tag sequence. When a mapping m of n arguments XL x2, \n... xn is to be stored in the data repository, it is convenient to store the value in the frame of xl, \nunder the tag sequence m, x2, ... xn. The inheritance rule for frames then accounts for the use of abstractions \nin the first argument of m. For mappings such as od which use abstractions in both arguments, additional \nmachinery is required. In CAROUSEL that is arranged by allowing the tags in the frame to be not only \nentities, but also pairs (r, e) where r is a relation symbol such as ->, and e is an entity. If a non-terminal \nnode in the data repository has a daughter whose tag is (->, e), and an access is made where the access \nchain requires the tag c, then that daughter is selected iff c -> e. The scheme is generalized to other \nrelations in the obvious way; tags without a relation symbol are considered m contain the equality relation. \nCombined with the inheritance rule for entities, this mechanism is sufficient for representing miippings \nwhich use abstractions in more than one ar~ume!!t. c,eneralized tags may 21s0 be occur in the access \nchain, which is very useful. The tree traversal operations usually do not want to traverse the whole \nframe (tree structure) that is actually stored in the data repository, but only a selection of it which \nis described by the current view (in the usual data-base sense of that word) of the data repository. \nThis is conveniently arranged, in many cases, by defining the view as an access chairr where some of \nthe hnks have the form (->, e), which means that it matches all actual tag values in the corresponding \nplace in the data repository, which agree with or are particularizations of e. The actual system allows \nother relations besides = and -> in the tags, including tags which cause the match condition to be computed \nby a procedure. Propositional connective on the tags would be a straight-forward extension. Such faciliti&#38; \nare needed for mo~e complex applications, but what has been described so far is sufficient for the information \nrequired by the system itself. The information structure described here is of course not new. Sibley \nhas remarked (ref. SIB80), possibly with some exaggeration, that virtually all current ideas with respect \nto data modelling have been fairly well described already in the 1960 s, and some even in the 1950 s. \nThe entity concept is very widespread, under various names. Frame structures as described above, i.e. \ndiscrimination trees which interact with a taxonomical (= abstraction) hierarchy, have been particularly \nmuch used in artificial intelligence research. Carbonell (ref. CAR80B) discusses inheritance from an \nA.I. viewpoint, and provides additional references. The choice of such a widely used representation makes \nit likely that it is satisfactory for common applications. The use of the data repository for system \npurposes is not restricted to the storage of procedures as leaves in the frames: there is an analogous \nneed to store brief verbal descriptions of entities, to be used for documentation and for on-line user \nassistance ( help information ). The structure for the procedures that has just been described, applies \nequally well for descriptions: just as procedures can be shared among the members of an abstraction, \nso can the corresponding textual description, and just as some subordinate parts of an inherited procedure \nmay need to be specified separately for each participant of the abstraction, the same applies for some \nparts of the inherited text. For example, the brief description of the abstract add operation may be \nadd one more member to the <field> field in the <item> . When this string is inherited to the cc command \nin the mail context, the local information fills in the slots to create add one more member to the CC \nfield in the message . The substitution of message for <item> WJS defined by the mail context, and the \nsubstitution of CC for <field> was because we have cc -> Ownadd -> add where ownacid is the abstraction \nof commands which add one more member to the field whose tag equals the command name. 5. Relationships \nto conventional programming languages, .4 conventional programming language contains modes of expression \nboth for procedural behavior (such as conditional expressions and loops), and for what we have called \nsoftware structures above. The design described here, as well as its implementation in the CAROUSEL system, \nonly considers the software structure, and can be used together with any reasonable language for procedural \nbehavior. In that respect it is similar to 0.S. shells and to software tools. However, we have seen how \nfamiliar concepts in programming languages, such as data abstraction (ref. LIS74), and inheritance of \ninformation in a hierarchy (ref. DAHL72) have carried over to the design described here. In this way \nit continues the trend that was formulated by Jones (JON77), namely increasing the number of concepts \nthat are shared between programming languages and operating systems. Our software structure has been \nexplained in terms of the -> relation, and the mappings od and tld which identify a procedure definition \nin the data repository, and which allow inheritance in both their arguments. The similarities and differences \nwith the software structures of conventional programming languages, are most easily seen if they also \nare presented as similar mappings, instead of the usual BNF-oriented notation. In algol 60 (ref. NAU62), \nthe significant entity for software structure is the block. If we let -> be the inclusion relation between \nblocks, so that bb -> b means that the block bb is enclosed within the block b, then algol uses a procedure-defining \nmapping pd: blocks * procedure-names --> procedure-definitions where pd allows inheritance in its first \nargument, just like od, but not in its second argument (where the -> relation is not defined). Since \nour intention is only to give a cue about the similarities and differences between the CAROUSEL design \nand a few programming languages, we restrict the discussion to the identification of Procedures. The \nSmalltalk language (ref. 13YT81) contains a class hierarchy, where -> is the relation from a class to \nits superclass. Each class has a number of met~od~ (roughly: procerttrres), each characterized by a stkxtor. \nPvfethocls are invoked when a message is sent to an cbjtct which is a member of a class. Let mc(rsbj) \nbe the smallesi class of which the object obj is an instance. The methods which are given in a class \ndefinition express a method-defining mapping md: classes * selectors --> methods With this notation, \nthe appropriate method to be invoked when a message with the selector s is sent to an object obj is md(mc(obj), \ns), where again we notice that md inherits in its first argument, but not in the second one. composite \nobject may inherit properties along the hierarchies of its arguments, e.g. the enrollment of a particular \nstudent in any CS course ; the enrollment of a foreign student in any course . Hewitt s ACTOR system \nis reported (informal discussion) to ~llow two-dimensio nal inherit-ante in the following way: it is \nsimilar to Smalltalk (ref. BYT81), but every message is an object, and has a position in the abstraction \nhierarchy which was determined when It was created, When a message is sent to (or rather, arrives at) \nan object, the resulting event is determined by inheriting for both the message and the receiving object. \n-Both TAXIS and ACTOR are of course highly experimental systems or designs. Smalltalk has inherited the \nclass concept from the !Mmula language (ref. BIR73), where cc -> c is expressed syntactically as c class \ncc ... followed by the rest of the description for CC. However, since it remained in the algol 60 tradition, \nSimrrIa has its class hierarchy within a block hierarchy, which means that the Simrrla counterpart of \nthe mc mapping is defined using inheritance in the block hierarchy, and that we must separate between \nthe name and the definition. of a class (since the same identifier may have several definitions as a \nclass, in different blocks). In summary, the rules for identifying procedure definitions (or what closely \ncorresponds to them) in a number of programming languages, are similar to CAROIJSEL S rules since they \nare defined over a hierarchy of some kind of entities, and allow inheritance in that hierarchy, but at \nleast the programming languages considered here only allow inheritance in one argument of the identification \nmapping: one-d irnen~ional inheritance. Inheritance mechanisms in other areas also tend to favor one-dimensional \ninheritance. Carbonell s classification of inheritance mechanisms (ref. CAR80B) focuses on the inheritance \nof properties between objects (while we prefer to think of inheritance characteristics for rnappin~s). \nOne then has a choice between allowing a single superior for each object, which results in quite rigid \nstructures, or allowing several superiors, which may be too general (leading to a lack of structure). \nFocusing instead on inheritance for mappings, provides in fact a structured and restricted way of allowing \ninheritance from several superiors. Many operating systems allow a path technique for arranging locality \nof files, commands, etc. Bourn (ref. BOU78 p. 1981) and Dolotta (ref. DOL80 p. 47 f.) have discussed \nthe use of such structures among Unix users, and remark on the use of paths through directories that \nrepresent successively larger organizational structures: assignment, programmer, small group of programmers, \nwhole project. The resulting, single-dimensional inheritance pattern reflects the organizational hierarchy. \nSome cases of true multi-dimensional inheritance also exist in the literature. The TAXIS system (ref. \nMYL80B) allows the user to define composite objects using functions (in the predicate calculus sense \nof the word), e.g. the enrollment of a particular student in a particular course , and such a Returning \nto conventional programming languages, we have noticed that single-dimensional hierarchies are often \nexpressed using textual inclusion. If textual representations of programs are considered significant, \nit would be a straight-forward exercise to design a notation along the lines of algol 60 or Simula for \nexpressing the od and tld mappings in CAROIJSEL, However, in a computing environment which is interactive \nboth for development and for production use of programs, the textual representation of the whole pro~ram \nis of marginal significance, and the primary realization of the software structure is in terms of mappings \nand, implementation-wise, as structures in the software repository. A variety of different methods may \nbe used for displaying excerpts of the structure to the user. 6. Realization of various services. The \nclaim for this work is that the services of traditional software tools have been unified and generalized, \nWe have already shown how that works with respect to the implementation of the command language, and \nthe possibility of defining commands across applications. We shall now discuss how the other types of \napplications are handled. Navigational systems based on state-transition models can clearly be easily \naccommodated by letting each state be a context, It IS advantageous to let all nodes in state tr~. nsltion \nnetworks be particularizat~. ons of one common abstraction, which serves as the range for the opera t~ons \ntlmtmanage the context-switching. If one wants to have contexts (nodes) whose primary purpose is to ask \none question to the user, get the answer, and proceed to the next node, then the command parsing procedure \nfor such contexts should assume that there is one standard, default operation ANSWERIS , and that what \nthe user types in is the single parameter for that operation. (In the MEDICS application system built \non IDE,CS, such nodes are often used; ref. ELF80). Exception-creating commands whereby the user can ask \ne.g. what is the purpose of this question or what are the allowable answers can be easily accommodated: \nthe parsing procedure should recognize them as ways of overriding the default operation. Among layout \ntools, we consider particularly forms management systems. Such systems should consist of two parts: a \ndesigvr tool for entering a forms description, and a production tool for data entry, data editing and \ndata presentation using an existing form. The production-tool services are conveniently set up by embedding \nthe formatting information (such as the X and Y coordinates of each field) in the prototype. When the \ngeneral-purpose traverser procedure traverses the current frame and its prototype in parallel, it is \nthe latter that determines the choice and order of frames. This is natural both because the prototype \ndefines the current view, and because the current frame may sometimes be empty, e.g. during data entry. \nThe prototype also contains the information about the types of the values in the leaves. For these reasons, \nwe can obtain layout descriptions simply by extending the type hierarchy downwards into instances which \ncontain coordinate information. For example, if a standard prototype for an address-directory service \nstipulates that the name field should have the type string, we-may compose an alternative prototype where \nthe type in the name field is string4, where string4 -> string tld(string4, print) = pri4 where pri4 \nmight be a procedure which prints its argument in position (X = 4, Y = O) on the screen. (More likely, \nit will be a procedure which does a cursor movement to a position given as another leaf in the frame \nof string4). All other information for string4 is inherited from string. By creating a prototype from \nsuch further instantiated types, we obtain what is effectively a forms description that can be understood \nby the general-purpose traverse procedure. The rmuking forms descriptions are somewhat elaborate, and \nit is not convenient to enter them man,.] ally. IHmvever, the most convenient way of entering a new form \nis anyway to paint it: the user moves the cursor around the terminal icreen, and makes commands such \nas create a data field here or delete that data field when the cursor is in ~PProPriate Positions, and \npreferably using control keys or functions keys on the keyboard. Thus the characteristic commands are \nput , delete , move , add information to , and so on, just as in the other applications. Form entry is \ntherefore gracefully accommodated using contexts which OpiWit.S Otl a fixed frame (viz. the forms description \nthat is currently being edited), in which the node for the whole form has the individual form fields \nas daughters, and discriminates between them using the X/Y coordinates as a tag. This allows us to treat \nthe characteristic form editing operations (insert field, delete field, etc.) as particularizations of \nthe general operations put, delete, etc., while the parameter is an X/Y coordinate which is defined by \nthe present position of the cursor. By contrast, the representation of the form as a modified prototype \nfor production use, requires that the record s field name be used as a tag, and the X/Y coordinates be \nrepresented as values in leaves. The transformation between the design tool s representation and the \nproduction-time representation, is a simple and symmetric reversal of the tag and one of the leaves, \nin each of the nodes that represent a form field. Data base queries can be expressed in several ways. \nIf a query is to be formulated as one single, complex expression !ising e.g. Boolean connective, then \nthe facilities described in this paper are not adequate (unless the context mechanism is used to implement \nan ATN parser). However, the design does support the case where the query is expressed as a succession \nof short commands which make restrictions, joins, and other operations on a working relation . Also, \nsince design of forms is accommodated, it should be possible to state queries in the present system using \nQuery-by-Example-like techniques (ref. ZL075). Operating system shells provide a command dialogue with \nthe user. The design described here has all three characteristics of a shell: it maintains a data repository \n(of which the file directory is a special case); it performs a command dialogue; and it is able to invoke \nprograms or procedures that are stored in the data repository. Thus it is a generalization of the conventional \n0.S. shell. Although the presentation here has by necessity been brief, it has hopefully been sufficient \nto demonstrate in principle how the services of conventional software tools and software environments \nhave been unified. 7. Discussion. Many authors have emphasized the need for systematic and powerful methods \nfor dialogue management, for example Terry Winograd as quoted in section 2 above, A statement by Hoare \n(as cited in ref. WEG79) also applies very well: In many applications, algorithms play almost no role, \nand certainly present almost no problem. The real problem is the mass of detailed requirements; and the \nonly solution is the di~covery or invention of general rules and abstractions uhich cover the many thousandx \nof cases roith as few exceptions as possible. The present work has been done in the same spirit as both \nthose quotations express. We have shown that interactive user services which are traditionally provided \nby operating systems and a number of software tools, can be provided in a unified way by a simple and \nconcise interactive system. Operating systems and software tools are usually considered to be on a level \nabove the programming language. This is particularly true from the viewpoint of classical algorithmic \nlanguages, which maintain strict separation of programs and data, where the software tools must be implemented \nas program generators. The results presented here suggest that concepts and services can and should be \nmoved upwards , from the realm of the procedural programming language, to the realm of a software environment \nthat combines the salient features of operating systems and software tools. In the traditional division \nof responsibility between the software environment (realized by the operating system) and the application \nprogram (expressed in the programming language), the software environment provides a fairly narrow and \nwell-defined set of services, and all the application-specific things as well as the continous dialogue, \nhappen within each application program. The application is realized as a monolithic program at least \nat execution time when the end user has passed through the operating 5ystem shell into the application \nprogram, he or she has no contact with the operating system (except for low-level data management and \ncommunication services that are clearly below the level of the application program). The present work \nsuggests a development where the computing environment takes over much more of what is presently done \nin the application program: it takes responsibility for the user dialogue, and for data rnarzagement \nor moving data around in the words of Boehm (ref. BOE80). Furthermore, through the use of the control \nabstractions, the context machinery, and the embedding of directive information in prototypes, it takes \nresponsibility for a large part of contm?, which in the definition of Salter (ref. SAL76) is rhe mechanism \nthat activates functions in the desired sequence , or (in interactive situations, we might add), the \nmechanism that activates functions at the desired time. Instead of having a large monolithic application \nprogram, encapsulated in the thin shell provided by the operating s!istem, we therefore see having an \napplication description which consists of number of separate entity descriptions (in our case, frarrtes), \nwhich are individually stored in the data repository provided by the software environment, and whose \nrole is to steer the general-purpose behavior of the system, rather than to define the behavior from \nscratch for each application. This viewpoint provides an different perspective on the relationship between \nprogramming languages and programming environments. Speculatively, we argue that it is wrong to design \na programming language first, and think about the design of the programming environment afterwards, as \nhas been the case in the ADA effort. Since hierarchical structures are needed both in the programming \nlanguage and in the programming environment, it would be reasonable to use the same hierarchy and a uniform \nrepresentation for both purposes. A software repository which can represent hierarchies, and accommodate \nvarious kinds of software structures, may allow and encourage representations of programs which do not \nappear easily when language design is done in the framework of the classical algol 60 syntax tradition. \nThe two-dimensional inheritance that plays a crucial role for the generality and simplicity of the CAROUSEL \ndesign, emerged in the data repository representation of the software. However, the issue is not only \nabout whether the textual representation or the data-base representation of a program should be the primary \none. It is also concerned with what kinds of entities should be used in the hierarchy for the software \nstructure. deRemer and Kron (ref. REM76) have made the distinction between programming in the small (i.e. \nwriting individual procedures) and programming in the large (i.e. organizing the global structures where \nthe procedures are components). We agree about that distinction, but disagree with their view of what \nprogramming in the large is about. deRemer and Kron describe a module interconnection language, MIL 75, \nfor programming in the large, and write: T,ie universe of discourse of MIL 75 consists of three sets: \nresources, mod?des, and systems. Resources are atomic, . e.g. uariabiex, constants, procedures, data \ntypes, etc. (third page of paper). We believe instead that the universe of discourse for programming-in-the-large \nshould be en$i?ies in the sy:tem s behavtcr as seen b? the end user: opfirations, conte}tts, forms, data \nfiles, features thatcan be turned cm and off, printers where the output may appear, etc. These are the \nthings that it is important to describe. In the course of describing them, it is frequently necessary \nto associate procedures or other program objects with them, but that is a secondary circumstance. In \naddition to describing the system s behavior, programming-in-the-large should also be concerned with \nbuiiding models of the application. That issue has not been addressed by the present paper, but previous \nprojects in our laboratory (ref. ELF80, SAN80) indicate that once we have tools for modeiling the system \ns behavior, the next higher level of modelling the application domain can be built with considerable \nconvenience. Acknowledgements. Sture Hagglund has stfongly influenced the work described here, and a \nIso given valuable remarks about earlier drafts of the manuscript, and a ntsmber of valuable references. \nAnders Strom has argued for a long time that data abstraction should be incorporated into our software \ntools. Implementation. The present implementation of the design described here, (14R0USEL, is written \nin Interlisp for the DEC-20 computers. With the exception of the scetch for a query facility, all services \ndescribed in this paper have been implemented in the existing CAROUSEL system. References. Auerbach, \n1973. 131R73 Graham Birtwistle et al: Simu/a begin. Develo@in F Small-scale .A+plication Software Productx: \nSome Ex~er~mental Results. In S.I-I. Lavington (cd): Information Processing 80. North-Holland, 1980. \nM3EN3 Barrv W. Boehm: BOU711 S.R. Bourne: The UNIX Shell. The Bell System Technical journal, Vol. 57, \nNo. 6, July-August 1978, pp. 1971-1990. EUR80 John F. Burger: Semantic Database Ma fiping in .Eufid, \nProceedings of the AnM-SIf>MO D 1980 Intermitinnal Conference on Management of DRta (7\u00b0eter P. Chen, \ncd.), pp. 67-74. ACM, 1980. BYT81 BYTE Magazine, Vol. 6, No. 8, August 1981: special issue on Smalkalk. \nCAR80 Eric D. Carlson and Wolfgang Metz: Integrating Dialog Management and Data Bale Management. In S.H. \nLavington (cd): Information Processing 80. North-Holland, 1980. CAR80B Jaime G. Carbonell: Default Reasoning \nand Inheritance Mechanisms on Type Hierarchies. Proceedings of the Workshop on Data AbstractIon, Databases, \nand Conceptual Ivfodelling. SIGPLAN Notices, Vol. 16, Nr. 1, January 1981. CHE76 Peter P. Chen: The Entity-Relationship \nModel -Towards a Unified View of Data. ACM Transactions on Data Base Systems, Vol. 1, No. 1, (1976). \nDAEIL72 Ole-Johan Dahl and C.A.R. Hoare: Hierarchical program Structures. In O.-J. Dahl, E.W. Dijkstra, \nand C.A.R. Hoare: Structured Programming. Academic Press, 1972. DOD80 U.S. Department of Defense: Requiremerus \nfor Ada ,nr ogr~?nming Support Environments - Sloneman . 3DI079 Pentagon, February 1980. DOL80 T.A. Dolotta \nand J.R. Mashey: U$ing a Command Language ax the Primary Programming Tool. In D. Beech (cd): Programming \nLanguage Di~ection~, pp. 35-55 North-Holland, 1!380. ELF80 Johan Elfstrom et al.: A Customized Programming \nEnvironment for Patient Mar2agement Simulations. Proceedings of 3rd World Conference on Medical h-iformatics, \nTokyo, 1980. WKNI Richard E. Fikes: Odyssey: A Knoruledge-Based Personal Assistant. To appear in Artificial \nintelligence. FOR79 M. Ford: PRESTEL -The British Posz Office Yiewdatcs Service. Proceedings of the 19?9 \nInternational Conference on Communications. IEEE, June 1979. GHE75 J, Ghesquiere, C. Davis, and C. Thompson: \nIntroduction to TUTO U. Report, Computer-Based Research Laboratory, University of Illinois, 1975. !HAG75 \nSture Higghrnd and CM-en Oskarsson: {Di?CS2 Users Guide. Report DLU 75/3, Datalogilaboratoriet, Uppsala \nUniversity (Sweden), 1975. HAG80 Sture Higglund et al: Sfieci~ying Contro/ and Data in the Design of \nEducational Software. Proceedings, CAL81 Symposium on Computer Assisted Learning, Leeds, 1981. HAM77 \nM. Hammer, W.G. Howe, V.J. Kruskal, and I. Wladawsky; High Level Progranc?ning Language for Data Processing \nApplications. Communications of the ACM, vol. 20, no. 11, 1977, pp. 832-840. HAM$O Michael Hammer and \nBrian Berkowitz: DIAL: A Programming Language for Data lntensi.ve Applications. Proceedings of the ACM-SIGMOD \n1980 International Conference on Management of Data (Peter P. Chem, cd.), pp. 75-92. ACM, 1980. HER80 \nChristopher F. Herot: Spalial Management of rJa,~~. ACM Transactions on Database SySCet?)S, VOI. &#38; \nNr. 4, pp. 493-513 (December, 1980). JC?H78 S.C. Johnson and M. E. Lesk: UNIX Time-Sharing System: Language \nDevelopment Tools. The Bell System Technical Journal, Vol. 57, No. 6, July-August 1978, pp. 2155-2176. \nJON77 Anita K. Jones: The Narrowing Gap Between ~anguage systems and operating Systems. in B. Gilchrist \n(cd): Information Processing 77, pp. 869-873. North-Holland, 1977. JOI$JG80 S. Peter deJong: The System \nfor Business Automation (SBA): A Unified Application Development System. in S.H. Lavington (cd): Information \nProcessing 80, pp. 469-474. North-Holland, 1980. HER79 Christopher F. Herot: Spatial Management of Data. \nACM Transactions on Database Systems, 1979. KAM78 I. Kameny et al.: Z UFID: The End-User Friendly Interface \nto Data Management Systems. Proceedings of the Fourth International Conference on Very Large Data Bases, \nBerlin, September 1978. LAD80 Ivor Ladd and DC. Tsichritzis: An Office Fo~m Flow Model. Proceedings of \nthe 1980 National Computer Conference, pp. 533-539. AFIPS Conference Proceedings, vol. 49. !LIS74 Barbara \nH. Liskov and Steve Zil!es: Prog rczrnming mii h Abstract Data Types. Proceedings of the ACM Conference \non Very High Level Languages, SIGPLAN Notices, Vol. 9, April 1974, pp. 50-59. LIS77 B. Liskov, A. Snyder, \nR. Atkinson, and C. Scaffert: Abstraction Mechanisms in CLU. Communications of the ACM, Vol. 20, Nr. \n8, pp. 564-576 (August 1977) MAR73 James Martin: The Design of Man-COm@teT Dialogues. Prentice-HaII, \n1973 MOR80 Howard Lee Morgan: Research and Practice in office Automation. Invited paper, in S.H. Lavington \n(cd): Information Processing 80. North-Holland, 1980. MYL80 John My]opoulos, Philip A. Bernstein, and \nHarry K.T. Wong: A Lmguage Facility for Designing Database-intensive Applications. ACM Transactions on \nDatabase Systems, Vol. 5, No. 2, June 1980, pp. 185-207. MYL80B John MY1OPOUIOS and H.K.T. Wong some \nfeatures of the TAXIS data model. Proc. 6th Annual Conf. cm Very Large Data Bases, Montreal, Sept. 1980 \nNAU62 Peter Naur (cd): Revised Report on the Algorithmic Language Algol 60. Re3necentralen, Copenhagen, \n1962. NEW79 W. Newman and R. SprOUll: principles of interactive Computer Graphics. McGraw-Hill, 1979. \nNIE79 J. Nievergelt and J. Weydert: Sites, modes and trails: tellinf the, user of an interactive system \nwhere he is, what he can do, and how to get to places. Proceedings of lFIp Conference on the Methodology \nof Interaction. North-Holland, 1979. Qu168 M.R. Quillian: Semantic Memory. in: M. Minsky (cd): Semanltc \nInformation Processing, pp. 216-270. MIT Press, 1968. REM76 Frank deRemer and Hans H. Kron: Program ming-in-the-La~ge \nVersus Programming-in-the-Small. IEEE Transactions on Software Engineering, June 1976. ROB78 G. Robertson: \nSome Design Considerations for the ZOG Man-Computer lntei face. Proceedings of the Third NATO Advanced \nStudy Institute on Information Science, Chania, Greece, 1978. R0B79 G. Robertson, D. McCracken and A. \nNewell: The .ZOC App? each to Man-Machine Communication. Report CMU-CS-79-148, Carnegie-Mellon 7Jni rersit~, \n1.979. WdL7ti Kenneth G. Salter: A Melhodolog y for Decomposing System Requirements into Data processing \nRequirements. Proceedings of the 2nd International Conference on Software Engineering, IEEE, 1976. !JAN7!3 \nErik .$2atidewall: Pvog?ammifig in an lnteructlne Environment: The LISP Experience. ACM Computing Surveys, \nVol. 10, Nr. L pp. 35-72, March 1972 SAN79 Erik Sandewall: A Description Lartgwge and Pilot-System Executive \nfor information-Transport Systems. Proceedings of the Fifth International Conference on Very Large Data \nBases, Rio de Janeiro, 1979. SAN80 Erik Sandewall, Goran Hektor et al.: Provisions for Flexibility in \nthe Linh6pin,g Offtce information System (LOIS). Proceedings of the 1980 National Computer Conference, \npp. 569-577. AFIPS Conferefice Proceedings, vol. 49. SANf!l Erik $andewall: SCREBAS Provisional Reference \nMantd. Internal report, Software Systems Research Center, Linkoping University (Sweden), March, 1981. \n.MX179 J. Schultz and L. Davis: The Technology of PROMIS. Proceedings of the IEEE, September, 1979 SIB80 \nE.H. Sibley: Dalabase Management Systems _Past and Present_ Proceedings of the Workshop on Data Abstraction, \nDatabases, and Conceptual Modelling. SIGPLAN Notices, Vol. 16, Nr. 1, January 1981. STR81 Ola Stromfors \nand Lennart Jonesjo: Tke Implementation and Experience of a Structure-Oriented Text Editor. Proceedings \nof ACM SIGPLAN/SIGOA Symposium on Text Manipulation, 1981. 1 E178 Warren Teitelman et al.: {nterlisp \nReference Manual Xerox Palo Alto Research Center, Palo Alto, CA, 1978 WAS81 Anthony I. Wasserman: User \nSo ftruare Engineering and the Design of lntera~tive Systems. Proceedings of the 5th International Conference \non Software Engineering, IEEE, 1981. WEG7!l Peter Wegner: Research Directions in Softtoare Technology. \nMIT Press, 1979. WIE79 Johan Wieslander: Interaction in Compute? Aided Analysil and De~ign of Control \nSystems. Thesis, Department of Automatic Control, Lund University (Sweden), 19 79. WGR~9 Terry Winograd: \nBeyond Programming Languages. Communications of the ACM, Vol. 22, Nr. 7 , pp. 391-40i (July 1979) WIN81 \nPatrick Henry Winston and Berthold Klaus Paul [Horn: LISP. Addison-Wesley, 19S1. ZL075 M. M. Zksof: Query \nby Example. Proceedings of the 1975 National Computer Conference, pp. 431-437. AFIPS Conference Proceedings, \nVol. 44.  \n\t\t\t", "proc_id": "582153", "abstract": "The paper describes the design for a software environment which unifies the dialogue management support of a number of existing software tools, such as command-language handlers, operating-system shells, transition diagram interpreters, and forms management systems. The unification is accomplished without undue complexity: the resulting design is clean and inspectable.A key notion in the design is the use of three orthogonal abstraction hierarchies, for interaction contexts, for interactive operations (roughly = commands), and for data types. These orthogonal hierarchies are used for obtaining multi-dimensional inheritance, i.e. mappings of several arguments, which may be stored in the system's data repository, and which inherit their values along the hierarchies represented in the arguments. Mappings with multi-dimensional inheritance are used in the invocation mechanism, i.e. for selecting the appropriate procedure to be executed in various situations. Currently used programming languages and software tools only use single-dimensional inheritance.A working implementation called the CAROUSEL system, is available.", "authors": [{"name": "Erik Sandewall", "author_profile_id": "81100424768", "affiliation": "Link&#246;ping University, Link&#246;ping, Sweden", "person_id": "PP39042174", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/582153.582170", "year": "1982", "article_id": "582170", "conference": "POPL", "title": "Unified dialogue management in the carousel system", "url": "http://dl.acm.org/citation.cfm?id=582170"}