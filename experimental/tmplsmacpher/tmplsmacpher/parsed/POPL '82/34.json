{"article_publication_date": "01-25-1982", "fulltext": "\n Axiomatic Definability and Completeness for Recursive Programs Albert R. Meyer and John C. Mitchell \nLaboratory for Computer Science Massachusetts Institute of Technology Cambt irfge, MA 02139  Abstract \nThe termination assertion p<S>q means that whenever the formula p is true, there is an execution of the \npossibly nondeterministic program S which terminates in a state in which q is true. Termination assertions \nare more tractable technically than the partial correctness assertions usually treated in the literature. \nTermination assertions are studied for a programming language which includes local variable declarations, \ncalls to undeclared global procedures, and nondeterministic recursive procedures with call. by-address \nand call. by.vaiue parameters. By allowing formulas p and q to place conditions on global procedures, \nwe provide a method for reasoning about programs with calls to global procedures based on hypotheses \nabout procedure input\u00adoutput behavior. The set of first-order termination assertions valid over all interpretations \nis completely axiomatizable without reference to the theory of any interpretation. Although uninterpreted \nassertions have limited expressive power, the set of valid termination assertions defines the semantics \nof recursive programs in the sense of Meyer and Halpern [10]. Thus the axiomatization constitutes an \naxiomatic definition of the semaniics of recursive programs. Introduction Many formal systems for proving \nproperties of programs consist of rules for deriving partial correctness assertions. The first. order \npartial correctness assertion p{S}q means that if the first. order formula p holds initially, and if \nthe possibly nondeterministic Permission to copy without fee all or part of this material is granted \nprovided that the copies are not made or distributed for direct commercial advantage, the ACM copyright \nnotice and the tide of the publication and its date appear, and notice is given that copying is by permission \nof the Association for Computing Machinery. To copy otherwise, or to republish, requires a fee and/or \nspecific permission. @ 1982ACM 0-89791-065-6/82/001/0337 $00.75 program S halts, then the first-order \nformula q holds after each possible halting computations of S. For even a very simple set of programs, \nthe set of valid partial correctness assertions is not recursively enumerable [i ]. In contrast, the \nset of valid termination assertions about while programs has a simple axiomatization [10]. The termination \nassertion p<S>q means that if p is true initially, then there is a possible computation of S which terminates \nin a state Fr which q is true. If S is deterministic, then the termination assertion p<S>q is equivalent \nto the partial correctness assertion p{S}q along with the assurance that S halts whenever p is true initially. \nTermination assertions are statements of tots/ correctness for deterministic programs. A natural approach \nto the modular design of software is to specify the input. output behavior of all procedures. The correctness \nof a procedure P should then follow from the assumption that the procedures called by P meet their specifications; \nit should not depend on how these procedures might be written. We consider recursive programs with calls \nto undeclared global (accessible everywhere) procedures. We propose as a reasonable specification language \nfor proving first. order termination assertions about recursive programs the class of first. order formulas \nextended to include termination assertions about global procedure calls. We present a complete axiomafization \nof termination assertions about programs which include local variable declarations, calls to undeclared \nglobal procedures, and nondeterministic recursive procedures with call-by-address and call. by-value \nparameters, The axioms and rules of inference are sufficient to prove all termination assertions which \nare valid over all interpretations. In this respect, our completeness theorem contrasts with the usual \nrelative completeness theorems for partial correctness assertions (e.g. [3]). We consider only assertions \ntrue of all structures and do not assume that the first. order theory of any structure is given as axioms. \nAs a result, Theorem 1 (completeness) demonstrates that the valid termination assertions for recursive \nprograms are recursively enumerable. This theorem extends the similar completeness theorem (Theorem 6.4) \nof Meyer and Halpern [10] for while programs without procedures. The fact that the valid terminations \nassertions are so constructive suggests that they may suffer limitations in providing information about \nprograms. The following example suggests the uses and shortcomings of first. order termination assertions. \nLet AX denote the conjunction of axioms for addition, proper subtraction and multiplication for natural \nnumbers using constants O and 1. Let ~ denote the numeral for n, i.e. n= 1 + 1 + ...+ 1 where 1 appears \nn times. For any natural number n, the assertion (AX A X=fj <Sfact>(Y =~) is provable from the axioms \nof Theorem 1, where Sfact is the recursive program proc P(u,v) = (if u= Othen v:= 1 else P(u-l,v); v: \n=V*U fi); call P(x,y). However, the more general termination assertion SJltin9 that Sfact computes the \nfactorial function cannot be derived from these axioms and indeed is not valid under any set of first-order \nhypotheses about natural numbers. That is, let p be f(0) = 1 A Vx[i(x + 1) =(x+1 ) f(x)]. Then the termination \nassertion (AXAP) <SfaC1>(y = f(x)) is valid whenever the variables are interpreted as ranging over natural \nnumbers and the arithmetic operations are given their usual meaning. But this assertion is not valid \nover arbitrary interpretations, even if AX is allowed to be any infinite set of first-order formulas \ntrue about natural numbers. In particular, there is a nonstandard interpretation that satisfies all first. \norder formulas true of natural numbers, but in which x maybe an infinite integer. In this interpretation, \nthe program SfaCt will not terminate since it cannot produce O by subtracting 1 from x anyJinite number \nof times. Hence (AXAP) <SfaCt>(Y= f(x)) cannot be proved using sound inference rules. This inherent limitation \nof uninterpreted firstorder assertions is emphasized in the well. known paper of Hitchcock and Park [8]. \n Despite their shortcomings, valid uninterpreted termination assertions express many useful properties \nof programs. In particular, Theorem 2 shows that termination assertions suffice to define the semantics \nof recursive programs in the sense of Meyer and Halpern [1O]. This theorem extends Theorem 5.1 of [10] \nto programs with calls to global procedures and lends support to the thesis that practical programming \nlanguages may be defined axiomatically. Furthermore, the relative simplicity of our proofs when compared \nwith proofs of analogous theorems for partial correctness assertions suggests that termination assertions \nare more suitable than partial correctness assertions for axiomatic definitions of semantics. 1. Global \nProcedures First-order hgic with global procedures will be seen to be a syntactic variant of standard \nfirst-order logic. A first-order ~lgnafure is a set of function symbols f, ,f2,.. and relation symbols \nR1,R2,.., each of some specific arity. A signature for first-order /ogic with g/oba/ procedures, or more \nsimply signature, is a first. order signature augmented with a disjoint set PI ,P2,... of procedure variab/es. \nEach P has an associated number of value parameters VP and address Parameters ap. First-order assertions \nabout global procedure caks q are defined by the grammar q:: = first order~mti f-I qlvqz I w I Vx[cl,l \nI Wt,x)xl where P is a procedure variable, t = t, ,...,tvp are first. order termS, and x = Xl,...,xap \nare variables. The construct <P(t,x)>q is intended to express that formula q is true after calling global \nprocedure P with value parameters t and address parameters x. Additional symbols such as A, 3, ~ and \n3 are considered abbreviations for the appropriate combinations of V, _I and V. A few words cf motivation \nare in order before presenting the formal semantics of assertions about procedure calls. To demonstrate \nthe axiomatizability of termination assertions about programs with recursive procedures with parameters, \nwe have chosen to consider recursive procedures with call-by-value and cal 1.by-address parameters. Axioms \nfor assertions about programs which declare procedures with other parameter passing mechanisms such as \ncall-by-value/result and call-by-name may be obtained by making slight changes in the macro-expansion \nrule presented in Section 2. To be consistent in the design of our programming language, we also provide \ncall. by.vakre and call-by address parameters to undeclared global procedures. The possible meanings \nof undeclared procedures should be as general as possible so as to include procedures written in any \nreasonable language. However, in order to prove common properties of procedures with value and address \nparameters, it is necessary to restrict the ways in which procedures may depend upon their parameters. \nIt might be possible for a procedure in some language to test the length of an identifier passed as a \nparameter or to determine the lexicographical ordering between a pair of actual parameter names, If a \nprocedure can recognize the names of its parameters, then simple properties such as Vx<P(x)>true 3-Vy<P(y)>true \nmay fail. Such capabilities go beyond the apparent intentions of call-by-value and call. by-address, \nand we prohibit them, For simplicity, we also insist that undeclared global procedures be explicitly \nparametrized, i.e. the meaning of a procedure call is independent of the values of any variables other \nthan the actual parameters, Thewaythe behavior ofaprocedure maydependon its address parameters indifferent \nfrom the wayitmay depend on its value parameters. Forexample, suppose procedure Phas~.vocall.by value \nparameters, andthe contents of x1 and x2areequal to the contents of y, and Y2, respectively. Then the \ncall P(x1,x2) should have the same effect as P(y1,y2), To see that call. by.address is different, consider \nthe procedure proc P(u,v) = (u:=O; v:= 1; if U= 1 then v:=O) If both parameters are passed by address, \nthen the call P(x,y) returns with y = O iff x and y share the same location. This shows that a procedure \nmay detect and hence may depend arbitrarily upon which of the call-by-address actual parameters share \nlocations. In summary, we assume that the behavior of a procedure call depends only on the values of \nthe actual call-by\u00advalue parameters and the values and sharing of addresses of the actual call-by-address \nparameters. The ~osaible behavior of procedures with address parameters may be characterized using equivalence \nrelations on finite sets of integers, For any vector of variables x =x1 ,.,.xk (not necessarily distinct), \ndefine the address sharing re/ation Ex on { f ,.,.,k} by i Ex j iff xi and xi are the same variable. \nIt is also useful to define the congruence of vectors of variables x =Xl,...,Xk and Y= Yl,...,ym by XSY \niff k=mand EX=EY. The number of distinct variables in x is the number of equivalence classes of Ex, i.e. \nthe index of Ex, If procedure P has k address parameters and x and y are both vectors of variables gf \nlength k, then P(x) necessarily produces the same result ss P(y) iff E, = EY and xi has the same value \nas yi for 1~i~k. When x = X1,...,XaPiS a vector of distinct variables and t = tl ,...,tvF,a vector of \nterms, the possible results of a call P(t ,x) to a nondeterministic procedure P may be characterized \nby an input-output relation. Informally, a tuple <t,x,y>, where YN:K, is in the input-output relation \nof P iff the call P(t,x) can return with the address Parameters equal to Y. Since a procedure P can distinguish \nbetween any pair of possible address sharing pattern% we use a set of input-output relations to describe \nthe behavior of P, one for each possible address sharing relation among the add ress parameters. The \nprecise semantics of first-order logic with global procedures is most easily defined by associating a \nfirst. order signature with each signature that contains procedure names.. Let P be a procedure name. \nThe as.sociafed set of input-output relations 3JP = {PE I E is an equivalence relation on {1 ,...,aP}} \nis a set of first. order relation symbols, one for each address sharing relation. The arity of each pE \nis Vp + 2ap. If pl and pz are procedure names in signature L, then %Pl and %P2 are assumed to be disjoint. \nFurthermore, each is disjoint from the first. order relations in L. If L is a signature, then the associated \nfirst-order signature I.p consists of all function and relation symbols of L, together with all relations \nin %P for each F) in l.. Note that LP contains no procedure names. A first-order state U1 for a first. \norder signature is a domain D&#38;l with functions f l and relations Rot of appropriate arities on D \nl corresponding to each function and relation symbol of the signatut e, and with elements X l for each \nvariable symbol x. A state with procedure environment (or more simply state) m for a signature L with \nProcedure names is a first-order state for the associated first-order signature -Lp, with the added restriction \nthat If <b, c,d>6PE with Icl = Idl =aP, then iEj+di=diandci=ci. We use a{d/x} to denote the state u that \nis identical to u except possibly at x and such that X9 = d. Satisfaction of a first. order assertion \nq about global procedure CSIIS by a state u is defined inductively as usual, with &#38;=<P(t,x)>q iff \n3d =d ,,...,daPCDO such that (t ,xU,d)CPEX and o{d/x] f= q Note that if <P(t,x)>q is interpreted as \nmeaning that q is true after calling P with t and x, then this definition forces the output of P(t, x) \nto depend only on the values of explicit parameter s Lx and address sharing pattwn Ex and only allows \nP(t,x) to alter me values of address pm amelers x. As for ordinary predicate calculus, the axiomatization \nof assertions about global procedure calls includes a universal instantiation axiom which involves substitution \nof terms for variables The substitution of terms in first. order assertions about global procedure calls \nraises a few extra complications. Since the construct <P(t,x)>q is well. formed only if x is a.vector \nof variables, it is impossible to substitute terms for address parameters directly. In addition, substituting \nsome address parameter xi for another, xi, may change the address sharing relation. As a consequence, \nrep/acemerrf of one address parameter by another has a different semantic effect frolm first. order subsfitufior?. \nFor example, Vx,yR(x,y) 3 VXR(X,X) is a valid first. order sentence. But since a procedure P may detect \nsharing, Vx,y<P(x,y)>true does not imply Vx<P(x,x)>true if both parameters are call-by-address. We circumvent \nthis problem by defining a substitution on assertions with global procedure calls which differs from \nstrict syntactic replacement but which has the same semantics as regular firstorder substitution. The \nsubstitution of a term t for a variable z in an assertion q about global procedure calls, written q[t/z], \nis defined inductively on assertions as usual for all cases other than <P(s, x)>q. If t is a simple variable \nnot among x = xl,...,xk or Z is not among xl,...,xk then substitution is straightforward replacement, \ni.e. (s1) (<P(s,x)>q)[t/z] = <P(s[t/z],x[t/z])>(q[t/z]). Otherwise, we define (s2) (<P(s,x)>q)[t/z] = \nVw(t = w 3 (<P(s,x)>q)[w/z]) where w is a fresh variable which does not occur in t or <P(s,x)>q. By choice \nof w, the substitution (<P(s.x)>q)[w/z] may be done according to rule (S1). Note that in general q[t/z] \nmay have more connective:? and quantifiers than q, However, if v is a variable which does Iiot appear \nin q, then the assertion q[v/z] is the same length as the assertion q. l-his is critical to proofs by \ninduction on the length of assertions. Furthermore, if v does not occur in q, then q[v/z][z/v] = q. This \nis easily proved by induction on formulas, A straightforward consequence of the definition of substitution \nis Lerwtna 1 ! (Substitution) Let q be a first-order assertion about global procedures, t a term and \nz a variable. Then for any state u, u*q[t/z] iff u{tu/x}l=q! This lemma is critical to soundness of the \ninstantiation and substitution axioms presented in Lemma 2 as well as the assignment axiom in Theorem \n1. The axioms for first. order logic of Enderton [5], for example, may be augmented to a complete system \nfor first. order logic with global procedures. Lemma 2: All generalizations of the following axioms, \ntogether with inference rule modus ponens, form a sound and complete proof system for first-order logic \nwith global procedures. PI, Propositional Tautologies. P2. Vxq 2 q[t/x] whenever no variable of t becomes \nbound in q[t/x] P3. Vx(p 3 q) 3 (Vxp 3 Vxq) P4. q3 Vxq for xnotfreeinq P5. x=x P6. x = y 3 (r ~ r ) \nwhere r is a first-order atomic formula and r is the formula r with zero or more occurrences of x replaced \nby y P7, (s=t Ax=y Au=v A<P(s,x)>x=u) 3 <P(t,y)>y = v where XRY, P8. <P(t,x)>q e 3y(<P(t,x)>x = y A \nq[y/x])) where y is a vector of variables which are not free in t,x orq and y m x. The proof of Lemma \n2, given in the appendix, follows the usual Henkin.style construction of a state satisfying a given set \nof formulas. 2. Recursive Programs Recursive programs have abstract syntax s::= x:= t I p? I P(t,v) \nI sl;s~ I S,US* I decl Ddo Send where declaration D is given by D::= (xinitt) I Pt=B and procedure abstract \nB has form B ::= ((val x, addr y): S}. The statements are assignment, test, procedure call, concatenation, \nunion and declaration. Union denotes nondeterministic choice of S1 or S2 (i.e. do S1 or SZ but not both) \nand p? denotes the test which allows execution to continue iff P is true. Many statements common to Algol-like \nlanguages may be considered syntactic sugar for recursive programs. For example, the statement if..then.. \nelsfi.fi maybe written if p then S1 else S2 fi -(P W1) t-J(l P ?S2) Thus the axioms of Theorem 1 may \nbe considered complete for recursive programs with if ..then..else. .fi in addition to the statements \nlisted in the grammar above. The declaration decl D do S end declares a local variable or recursive procedure \nwith scope S. Variable declaration (x ir?it t) defines a new local variable x with initial value t. Procedure \ndeclaration P -((val x, addr y) : S) declares a possibly recursive procedure P with formal value parameters \nx = Xl,...,xvp formal address parameters y = yl,.., ,yap and body S. A procedure declaration P==B is \nconsidered syntactically well-formed only if B has exactly VPvalue parameters and ap address parameters. \nThe while statement may be expressed using recursion by while pdo Sod s decl P G ((P?;S;P) U 7P) do P \nend  Other iterative ccmstructs such as repeat S until p may also be considered abbreviations for similar \nrecursive programs. In addition, declarations may be nested as deeply as desired so that any number of \nlocal variables and procedures may be defined. A statement declaring variables Xl,.,.,xn with initial \nvalues tl ,...,tn may be considered an abbreviation for a sequence of nested declarations, i.e. decl \n(Xl,...,Xn init tl,...,tn) do Send = decl (ZI init t,) do decl (Z2 init t2) do ,,, decl (zn init tn ) \ndo s end ,,. end end. Although somewhat more involved, mutually recursive procedures may also be declared \nas nested procedures. For example, the program with mutually recursive procedures decf PIC=(S1),P2C=(S2) \ndo S end may be written as decl P, ~=-(decl P2 c= (S2) do S1) do d-eel P2 = (decl PI -(St) do S2) do \ns end end. As a result, Theorems 1 and 2 apply to recursive programs with mutually recursive procedures. \nThe meaning m(S) of a nondeterministic program S is a mapping from initial states to sets of final states \nas in Harel [6]. We define the meaning of programs inductively as usual, with m(P(t,x))ff = {u{a, x} \nI (t , x ,a) C PEX } and m(decl (x init t) do S end)u = (m(S) u[t /x}){xU/x}. The right hand side of \nthe variable declaration definition denotes the set of states m(S)u{t /x} with the replacement {x /x} \napplied to each one. It should be noted that our state semantics are entirely consistent with the more \nusual environment and store semantics as in deBakker [4] and Apt [1]. However, the proof of Theorem 1 \nand, especially, the statement and proof of Theorem 2 are simplified by choosing state semantics. Following \nApt [1], we treat procedure calls by syntactic means. In keeping with the convention for Algol-like languages, \nrecursive programs have statically scoped vat-iables. Dynamic scoping, as well as alternative parameter \nmechanisms such as call-by\u00advalue/result and call-b~-name may also be handled using variations of the \nmacro. expansion definition below. The definitions of program S with variable x substituted for y and \nwith procedure name PI substituted for P2, written S[y/x] and SIP1/P2] respectively, are straightforward \n(see deBakker [4]). We define the rnacro-exparrsion of CaKS to Pin S using procedure abstract B = ((vat \nx, addr y) : S,l), written S<<B/P>>, by induction on program structure: (i) (x : = t)<< B/P>> = (x:= \nt). p? is similar. (ii) P(t,v)<B/P>> = decl (z init t) do So[z/x][v/y] end where z, ,...,zVPdo not appear \nin t, v or B.  (iii) S1;S2<B/P> = S1<<B/P> ; S2<<B/P;>. S1US2 is similar. (iv) decl (x init t) do S \nend< B/p>> = decl (z init t) do S[z/x]<<B/P> end where z is not free in S or B,  (v) clecl P, e S1 \ndo S end -@3/P> = decl P2 == S1 do S[P2/P1]<<B/P> end where P2 is not free in S or B.  The declaration \nof a vector z of new variables with initial value tin (ii) produces call-by .value. Value/result may \nbe obtained by resetting the actual parameters (which must then be variables) to z before block exit. \nOther mechanisms may also be handled by altering (ii) (see Apt [1]). Renaming of bwnd variables and procedure \nnames in (iv) and (v) give static scoping. Dynalnic scoping in recutsive Drograms can be treated by changing \n(iv) to get dynamically scoped variables or (v) to get dynamically scoped procedure names. The syntacric \nexpansions of a procedure abstract B = (val x, add r y : S) with respect to P are defined inductively \nby BO = (val x, addr y : fake?) B + = (val x, addr y : S<<B /P> } The (i+ 1)-st expansion of B with \nrespect to P is the procedure abstract whose body is the macro-expansion of P in S using Bi. The meaning \nof a program with procedure declaration is then defined using macro-expansions by m(decl (P~B) do S end)u \n= Ui m(S<<Bi/P>>)u This syntactic definition suggests inference rule A? used in Theorem 1. 3. Completeness \n The termination assertion pC3q means that if some state u satisfies p, then some computation of S from \nu halts in a state that satisfies q. More precisely, a state o satisfies p<S>q, written ol=p<S>q, if \nU*P implies Efu Em(S)u such that u ~q. The termination assertion p<S>q is valid, written f=p<S>q, if \nevery state u satisfies p<S>q It is a straightforward consequence of the definitions that a state u satisfies \nthe termination assertion <P(t,v)>q iff u satisfies the first. order assertion about global prOCedLlre \ncalls <P(t,v)>q. Thus the use of identical syntax for first\u00ad order assertions about procedure calls and \ntermination assertions about procedure calls should not be confusing. All valid termination assertions \nabout recursive programs are provable using the axirxms and rules of inference of Theorem 1 befow. Theorem \n1: The following axioms are sound and complete for proving termination assertions p<S>q where p,q are \nfirst. order assertions about global procedure calls and S is a recursive program. Axioms Al. Q[t/x] \n<X := t>q A2, (rAq) <r?> q A3. (<P(t,v)>q) <P(t,v)> q Rules of Inference A4. p<S1 >r, r<S2>q > p<S, ;S~>q \nA5. (a) p<Sl>q t--p<Sl~JS2>q (b) p<S1>q f-p<S.#S1>q A6. p<y: = t; S[y/x]>q i--p<ctecl (x init t) do S \nend>q where y does not occur in p,t,S or q. A7. p<s<<Bi/P~,>q f--p<decl (P~B) do S end>q A8. p<S>q 1-r<S>q \nwhenever f-r~p by the rules of Lemma 2. A9, p<S>q, r<S>q f--(pVr) <S>q Note that Theorem 1 is not a \nrelative completeness theorem of the sort typical for partial correctness assertions, If a termination \nassertion is valid, i.e. true under all interpretations of the function, predicate and global procedure \nvariables, then it is provable from axioms PI.8 of Lemma 2 and Al.9 above without appeal to further axioms. \nIn particular, the valid termination assertions are recursively enumerable, whereas the vafid partial \ncorrectness assertions are not. Theorem 1 generalizes Theorem 6.4 of Meyer and Halpern [1O]. The proof \nof Theorem 1 uses Lemma 3: For every recursive program S and formula q, there is a set {qi} of first-order \nassertions about procedure calls such that C3>qa Viqi. Furthermore, if S has no procedure declarations, \nthen there is a single such assertion q with <S>qsq . The lemma is ploved by induction on programs, using \nthe fact that decl (P,sB) do S end is equivalent to the union of programs S<<Bi/P>> and hence to the \ndisjunction of the corresponding formulas, As a consequence of Lemma 2, we also have a compactness theorem \nfor first-order logic with global procedure calls. Thus if p<S>q is valid, and <S>q-Viqi, then there \nis some firrite disjunction q = qlV... Vqm such that p 2 q is vafid. This fact is critical to the proof \nbelow. Proof of Theorem 1: Suppose f=p<S>q. We show that p<S>q is provable from Al -9 by induction on \nthe structure of S. (a) ff p<x : = t>q is valid, then uf=p implies u{t /x}f==q, By the Substitution Lemma, \nf=p3q[t/x] and therefore kp3q[t/x] by the rules of Lemma 2. By Al, we have l-q[x/t]<x : = t>q and so \nt--p<x : = t>q by A8, (b) If f=p<r?>q, then f==p3(rAq) and hence f-p2(rAq). Since t-(rA@<r?>q by A2, \nwe have I--p<r?>q by A8. (c) Assume b=p<P(t,x)>q. Then the first-order asserPon about global procedure \ncalls p~(P(t, x)>q is valid and hence provable by the rules of Lemma 2. Therefore l-p< P(t,x)>q by A3 \nand A6. (d) Suppose k=p<Sl ;S2>q. There exist sets of formulas {pi} and {qi,j) such that ~<S2>qG Vjpj \nand l==<S1>pia Viqi,j. Since l=p2Vi,iqi,i, it fellows from the compactness theorem of first-order Ioglc \n(with global  procedure cafls) tnat there is some finite set M = MiXMj SUCh that t= p3V(i,j)eMqi,j. \nLet r denote Vi<rdipj. Then since for any j, 342 bvi~MiqiJ ~ Viqi,jand ~(viqi,)<sl>pj we have b(v(i,j)CMq,,j \n..) <S,>r and hence t=p<S1>r. By similar reasoning we obtain *r<S2>q, From the inductive assumption we \nhave f-p<S1>r and l-r<S2>q which allow us to conclude hP<S1 ;S2>q by A4. (e) Union is similar to composition. \nAssume k=p<S1US2>q. As above, there is a set of formulas {qi,i}j>o,i= 1,2 with ~ <Si>q ~ Vjqi,j. Then \n~p~Vi,j%,j and so by compactness there is a finite set M with Since l==qi,j<Si>q, we have kp~vj<M, i= \nl,2qi,j. kqi,J<Si>q and so by A9 and A5, vj6M, i . I,zqj,l<sl US2>q Thus by A8, Kp<S1US2>q. (f) Assume \n+p<decl (x init t) do S end>q. A simple induction on programs shows that for any variable y that does \nnot occur in p, t, S or q, I=p<decf (x init t) do S end>q iff !=p<y : = t s[y/x]>q Therefore f-p<y: = \nt; S[y/x]>q by the inductive hypothesis. Thus I--p<decl (x init t) do S end>q by A6. (g) SuPPOse f=p<decf \n(Pc=B) do S end>q. Then by definition of m(decl (P-B) do S end), we hrwe F=pS/,<S<Bi/P>>q, As above, \nthere is a set of formulas {qi,i} with <S<<Bi/P>>q e Vjqi,i for each i. From compactness, we know that \nthere must be a finite set M with and so  *p3v(i,i)EMqi,i *Po~ (i,i)~MqL,i from PI -8. Since f=qi,i \n<S< Bi/P>>q for any i and j, it follows from the inductive hypothesis that I-qi,j <S<<Bi/P>>q. By A7, \n1-qi,j<decl (PGB) do S end>q and so from A9, t-V(i,i)cMqi,j< decl (Pc=B) do S end>q. Therefore, by A8, \nI-p<decl (P=B) do S end>q. E  4. Axiomatic Semantics Many useful properties of programs may be proved \nusing uninterpreted termination assertions, In particular, termination assertions determine the semantics \nof programs in the sense discussed in Meyer and Halpern [10], Namely, the termination assertions valid \nfor a program distinguish it from al! inequivalent programs. More precisely, for any program S, the termination \ntheory of S, written T(S), is the set of all pairs (p,q) of first-order assertions about procedure calls \nsuch that p<S>q is valid. Two programs have the same termination theory precisely when they are equivalent, \ni.e. Theorem 2: (Semantical Determination) For any programs S and T, !J (S) = 9 (T) iff m(S) = m(T). \n Thecrrem 2 generalizes Theorem 5.1 of [1 O] to programs with CaIIS to global procedures and the proof \nis a straightforward reformulation of that in [1 O]. The theorem holds, In fact, for any programs S and \nT which are equivalent to arbitrary unions of schemes, provided thi~t for each scheme Si and first-order \nassertion about procedure ca!ls q, <Si>q is equivalent to another such assertion. In pailicular, Theorem \n2 holds for any set of arbitrary, not even recur sivel y enumerable, infinite flowcharts (see [10]). \nThe main idea of the proof of Theorem 2 is that if u C m(S)u m(T)u, then we can find some pair of formulas \np and q with the property that for any program To, p<TO>q is valid iff there is some u Cm(TO)u which \nis identical to u on the free variables of SUT. It follows that p<S>q is valid but p<T>q is not. Therefore \nS and T have different termination theories. Proof of Theorem 2: We may assume without loss of generality \nthat mlS) m(T)*O. Let o Em(S)u-m(T)u and let x = Xl,...,xn include all free variables of SUT. Since S \nis equivalent to a union of Iprograms without procedure declarations, UiSi, there is some such program \nSk with u Cm(Sk)u, Let x =X1 ,,,,,Xn be a vector of fresh variables. By Lemma 3, there is a formula p \nwith p = <Sk>x = x . Since m(Sk) ~ m(S), we have f=p<S>x = x . It remains to be shown that W p<T>x = \nx , Let u. = u{x /y} and note that since thq variables of x do not appear in S or T, m(S)ao = (m(S) u){x \n/x } and similarly for T. In particular, Uo = u {x /x } is in m(Sk)uo but differs from each state in \nm(T)ao on some variable of x, By choice of (x ) o, we have Uof=p but Oo~ <T>x = x . Therefore p<T>x = \nx fails at U. and the theorem is proved, I  5. Conclusion We have shown that the semantics of uninterpreted \nrecursive programs may be defined axiomatically using first-order termination assertions. The set of \nvalid termination assertions defines program semantics, and all valid termination assertions are derivab!e \nfrom axioms: This provides support for the general thesis that practicaf programming languages may be \ndefined axiomatically, The fact that first-order termination assertions are easily axiomatized depends \nheavily on the compactness of first-order logic. Compactness ensures that whenever a first-order assertion \np implies that a program S halts, it is because p implies a fixed bound on the depth of recursive procedure \ncalls in S in all interpretations. As a consequence, there are many termination assertions p<S>q which \nare valid over specific interpretations such as the integers, but which cannot be proved in 9eneral since \nS may not always terminate, Nonetheless, uninterpreted first\u00adorcter termination assertions provide enough \ninformation about programs to distinguish between any pair of inequivalent programs. The extension of \nfirst-order logic to include calls to global procedures has several applications. In addition to providing \na convenient specification language for procedures called by recursive programs, first-order logic with \nglobal procedures may be used as a starting point for stronger Iogics of programs such as full Dynamic \nLogic [6]. Lemma 2 suggests that firstorder reasoning about programs with calls to undeclared global \nprocedures is essentially no more difficult than for programs without global procedures. A possible direction \nfor further work might be to extend our system to include specifications for more complicated black.box \nmodules such as abstract data types. Our completeness theorem shows that all valid termination assertions \nare provabie. A stronger statement would be a deductive completeness theorem, i.e. if any set of assertions \nr semantically implies p<S>q, then p<S>q is provable from I . As a consequence of compactness, this is \npossible if I contains only first-order assertions, More precisely, if l%p<S>q for any set r of first-order \nassertions about global procedure calls, then there is a single first-order assertion r which is a conjunction \nof assertions from r such that f-(pAr)<S>q by the axioms presented in Theorem 1, However, if r is a set \nof termination assertions, then it will not in general be possible to prove all consequences of r from \nany recursively enumerable set of axioms. In fact, even if we consider only single termination assertions, \ndeductive completeness is not ~ossible. This is because the assertion true<S>lrue semantically implies \nfa/se iff the program S never halts. Since the set of totally divergent programs is not recursively \nenumerable [9], the set of termination assertions p<S>q such that (p<S>q)#=false is not recursively enumerable. \nTwo directions for further investigation are to enrich the programming language and to expand the assertion \nlanguage. Programs with procedures as parameters or more complicated data objects are two possibilities. \nOur assumption that all undeclared global procedures are explicitly parameterized might also be relaxed \nby adding predicates to the assertion language which allow the global variables used by a procedure to \nbe identified, For example, a predicate INDEPP(x) might be used to state that the behavior of procedure \nP is independent of x. This is an adaptation of the interference concePt discussed by Reynolds [11 ]. \nAnother possibility, following the direction of Trachtenbrot [12]. is to add relations to the language \nwhich would allow sharing of addresses to be treated explicitly. We do not foresee any fundamental difficulties \narising from these possible extensions.  References I. Apt., K.R. Ten Years of Hoare s Logic, ASurveY, \npart 1,Proceedings 5th Scandinavian Logic Symposium, 1979, Pp. 1 44. 2. Chang, C.C.and H.J. Keisler. \nrVodel Theory. North. Holland, 1973.  3. Cook, S.A, Soundne% and Completeness ofan Axiom System forprogram \nVerificatiorl. SIAM J. Computing 7(1978). PP129\u00ad  147. 4. deBakker, J.ltilatheinatical Tl]eory of Progr(~n] \nCor/ecfness. Prentice-Elan, 1980.  5. Enderton, l-f.Fl. AMaf/]enlti/ica/ /nftod~lcfion fo Logic. Academic \nPress, 19 72.  6. Harel, f3. Lecture Notes in Computer Science. VoL68: First- Order Dynamic Logic. Springer-Verlag, \n1979.  7. Harel, D., A. R. Meyer and V. Pratt. Computability and Completeness in Logics of Programs: \nPreliminary Report. 9-th ACM Symposium on Theory of Computing, Boulder, Colorado, May, 1977 JpP. 261-268. \nRevised version, M.l.TLab.f orComputer Science TM.97, (Feb. 1978) 16 pp.  8. Hitchcock, P.and D. Park. \ninduction Rules and Termination Proofs, lnM. Nivat, Ed., Automata, Languages and Programming, American \nElsevier, New York, 1973, pp. 225-251.  9, Luckham, D.C., D.M Park and M.S. Patterson. On Formalized \nComputer Programs, J. Computer System Sciences , 4(1970). PP 220-249. 10. Meyer, A.R. and Halpern, J.Y. \nAxiomatic Definitions of programming Languages: A ?I?eore!ical .ksessmcrlt (Preliminary Report). Proc. \n7-th Annucd POPL Conf., January, 1980. Massachusetts Institute of Technology Tech. Report MIT/LGS/TM-l \n63 (April 1380); to appear JACM (le81 ). 11. Reynolds, J.C. Idealized Algol and its Specification Logic, \nTech. Rep. 1-81, School of Computer and Information Science, Syracuse University, 1981.  12. Trachtenbrot, \nB.A. On Denotational Semantics and Axiomatization of Partial Correctness for Languages with Procedures \nas Parameters and with Aliasing. Unpublished Manuscript.  344 Appendix 1. Global Procedure Calls We \nshow that axioms PI -8 are complete by showing that any consistent set of assertions is satisfiable. \nTwo important preliminaries are Lemma 4: (Generalization) Let r be a set of assertions and q an assertion. \nIf t%q and z is not free in r then lV-Vzq. and Lemma 5: (Deduction) If W{p} l--q, then rf-(p 3 q). \n Both are proved by induction on proofs (cf. Enderton [5]). Let r be a set of first. order assertions \nabout global procedure calls such that X*X is not provable from r using PI-8 and modus ponens. Let L \ndenote the signature of r and -Lp the associated first-order signature. We can construct a state satisfying \nr from constanls following the usual Henkin-st le procedure for first\u00ad order logic (see Enderton [5] \nor Chang and Keisler [2]). The construction consists of the following five steps. (1) Select an infinite \nset Tof fresh variables, The state o satisfying r will have equivalence classes of variables from T as \nits domain. Usually constants are used, but since constants may not occur as address parameters in procedure \ncalls, variables work better for assertions about global procedures calls. (2) Construct a set of formulas \nr Q r such that for each formula q of the expanded language (with variables from i j, r contains formulas \n(a) lVxq37q[v/x] (b) <P(t,x)>q 3 (<P(t,x)>x = V) A q[v/x] where v and v = Vi,,..,vk are new variables \n(from Step 1) and VC%X. As each variable vET is added to r , an infinite set of formulas {v= Vj]j>o for \nfresh vj~~is also added. This is done in such a way that V is not exhausted by any finite number of additions. \nThe purpose of the formulas {v= Vj}jzo are to provide infinite equ~(alence classes of variables from \nK i.e. each equivalence class will have infinitely many representatives in the model we construct. The \nconstruction proceeds in stages, starting from I . = r. Let ri be the result of the i.th stage q, x, \nP, t and x be the Lth formula, variable, procedure variable, vector of terms and vector of variables \nin some enumeration in which all necessary combinations appear. Then to construct ri + I, pick variables \nv and v =Vl,...,Vk (with vmx) from ~which do ,not occur in ri or q, p or t. For each variable ~w~{v,vl,...,vk}, \nalso form a set of formulas r3W= {W = Wj}j>o such that SW has infinitely many fresh variables wj~~and \nno Wj occurs in ri, p, t, x, q or any previous t3w, Let 8 = UW Sw and let ri+; = ri U {(a),(b)} U g. \nIf ri is consistent, then so is ri +, as follows. Suppose I iU{(b)} is inconsistent. Then by the Deduction \nLemma and propositional reasoning, riI-<p(t ,x)>q and rif--q<p(t,xpx = v A q[v/x]). But since v is a \nvector of variables which do not appear in ri, it fol!ows by Generalization (Lemma 4) that rit-13v(<p(t,x)>X: \n= v A q[v/x]), Therefore, by P8, ri~~(<p(t,x)>q), which contradicts the assumption that ri is consistent. \nBy a similar argument (see [2]), the consistency of rib{,} maybe reduced to that of riU[(b)}. Clearly \nadding sets of the form {w= Wj} does not destroy consistency since none of the Wj s appear in rib{,}. \n(If some set r u{w =wk]is inconsistent, then r f--qw = w~) and .s0 by Generalization rw~vwkq(w = wk)f \ni.e. r is inconsistent.) Thus if r is consistent, so are r,, r2,... and therefore I = Uiri must be consistent. \n(3) Extend r to a maximally consistent set A, i.e. for any formula q, either qEA or -q CA. This is done \nin the usual manner [2]. (4) Define a state u whose domain D is the set of equivalence classes of variables \nfrom K Define functions f and relations R according to the formulas in A.  For any terms t and t , define \nt = = t iff (t = t ) E A and let [t] denote {t It= =t }. Let D = {[v] I v6V. Define v = [v] and to = \n[t]. Note that t CD since 3y[t = y) is provable from P1 -6 and (Efy(t= y) 2 t = v)EA for come vET by \nconstruction of A. For functions and relations, define (a) f ~vl],...,[vn]) = (fvl...vn) (b) qV1],...,[Vn]> \nC Fl iff RvT...vn C A for R in L, and (c) <b,c,d> C PE iff there exist vectors of variables u, v and \nw from Twith Ev= EW= E, b = [u], c = [v] and d=[w] such that (<IP(u,v)>v = w)6A. Here [u] denotes [Ul],...,[Uvp]. \n  It is straightforward to verify that f and R are well-defined by (a) and (b) as usual (see [2]). To \nsee that (c) meets the restriction posed in Section 1, note that if <b,c,d>EPEO then In general, if &#38;=<P(t,x)>q, \nthen 3vE1 with vmx and iEj*vi=vjandwi=wj and so iEj-ci=cianddi=dj (5) Show that ub=q iff qCA by induction \norI the length of formulas. For first-order atomic formulas, this is immediate from the definition of \nO. The connective cases are also straightforward. Forexampfe, uk=nq iff ui#q iff q $ A iff ~q C A. Consider \nVxq. Note that there is some formula 7Vxq 3 lq[vq/x] in A with vqCT not appearing in q. If u@Vxq then \ncertainly By the substitution lemma, ul=q[vq/x]. Since VqfJ{[vql/xl%. does not appear in q, the formula \nq[v@] has the same length as q and so by ihe inductive hypothesis q[~q/x]EA. It follows that Vxq must \nbe in A since otherwise ~Vxq would be in A and hence -W[L@ For the converse, suppose uWVxq. Then for \nsome vET u{[v]/x]b$ q. Therefore, by the substitution lemma, uf# q[v/x]. Since every equivalence class \n[v] is infinite by construction of r (Step 2), it may be assumed that v does not occur in q and hence \nq[v/x] has the same length as q. Thus q[v/x] @A by the inductive hypothesis. Therefore ~q[v/x]CA and \nVxq cannot be in A by P2. The final case is <P(t,x)>q, We first consider q of the form x = y with XSY. \nIt follows from the definition of satisfaction that uF=<P(t, x)>x = y iff (t ,x ,yu)6PEx0. By definition \nof o, (tO,x ,yC)EPEx iff (*) There exist vectors of variables u, v and w with [u]= [t], [v]= [x], [w]= \n[Y] and Ev= EW= Ex such that (<P(u,v)>v = w) 6 A It remains to be shown that (*) is equivalent to (**) \n(<P(t,x)>x = y) C A If (*), then by definition of the equivalence classes [ ] of terms, A!-u=t Av=x Aw=y. \nThus from P7, Ai-(< P(!,x)>x = y) which implies (* *). Conversely, if (* *), then since 3Z(Z = t) is \nprovable from PI -6 for any term t, the construction of A ensures that there exist vectors of variables \nu, v and w with vcxx such that A1-u=t Av=x Aw=y. Therefore, from P7, we conclude (*). Thus &#38;=(<P(t,x)>x \n= y) iff (<P(t, x)>x = y) E A, (ta,xO,v )ePExa and u{v /x}!==q Since each equivalence class of variables \nin Vis infinite, each vi may be chosen so as not to occur in q. By the Substitution Lemma, al=q[v/x] \nand so by the inductive hypothesis, q[v/x]EA. Since uf=(<P(t,x)>x = v), we have (<P(t,x)>x = v)CA and \ntherefore A1-<P(t,x)>q by P8. Since A is deductively closed, <P(t,x)>q C A. For the converse, assume \n<P(t,x)>q CA. Then by the construction of A, <P(t,x)>x = v A q[v/x] C A for some vE1 _not occurring in \nt, x or q and with vnx. Therefore uF=<P(t,x)>x = v and so (ta,xm,v~)cPExO By the inductive hypothesis, \nul=q[v/x] and so by the Substitution Lemma, u{rv]/x}+q. Thus u&#38;< P(t,x)>q, This shows that for any \nfirst. order assertion about global procedures q, uf=q iff qEA. From (5) and r ~ A it follows that al=r. \nThus every consistent set is satisfiable and the axiomatization is complete, ~ \n\t\t\t", "proc_id": "582153", "abstract": "The termination assertion p&lt;S&gt;q means that whenever the formula p is true, there is an execution of the possibly nondeterministic program S which terminates in a state in which q is true. Termination assertions are more tractable technically than the partial correctness assertions usually treated in the literature. Termination assertions are studied for a programming language which includes local variable declarations, calls to undeclared global procedures, and nondeterministic recursive procedures with call-by-address and call-by-value parameters. By allowing formulas p and q to place conditions on global procedures, we provide a method for reasoning about programs with calls to global procedures based on hypotheses about procedure input-output behavior. The set of first-order termination assertions valid over all interpretations is completely axiomatizable without reference to the theory of any interpretation. Although uninterpreted assertions have limited expressive power, the set of valid termination assertions defines the semantics of recursive programs in the sense of Meyer and Halpern [10]. Thus the axiomatization constitutes an axiomatic definition of the semantics of recursive programs.", "authors": [{"name": "Albert R. Meyer", "author_profile_id": "81100572937", "affiliation": "Massachusetts Institute of Technology, Cambridge, MA", "person_id": "PP15036546", "email_address": "", "orcid_id": ""}, {"name": "John C. Mitchell", "author_profile_id": "81338490160", "affiliation": "Massachusetts Institute of Technology, Cambridge, MA", "person_id": "PP42051427", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/582153.582188", "year": "1982", "article_id": "582188", "conference": "POPL", "title": "Axiomatic definability and completeness for recursive programs", "url": "http://dl.acm.org/citation.cfm?id=582188"}