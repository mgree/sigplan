{"article_publication_date": "01-25-1982", "fulltext": "\n AN AXIOMATIC TREATNENT OF EXCEPTION HANDLING Shaula Yemini Department of Computer Science Courant Institute \nof Mathematical Sciences New York University 1. INTRODUCTION zero denominator in division, an empty \nstack in pop . This paper presents an axiomatic treatment of exception handling, based on the replacement \nmodel [16]. The replacement model, in contrast to other exception handling proposals, supports all the \nhandler responses of resumption, termination, retry and exception propagation, within both statements \nand expressions, in a modular, simple and uniform fashion. The main result presented in this paper is \nthat the semantics of all these handler responses can be captured using a simple axiomatic definition \ninvolving only two proof rules in addition to the rules defining the other aspects of the embedding programming \nlanguage; these rules place no restrictions on allowable handler effects except for those resulting from \nscope rules. The model is suitable for any block-structured programming language. A For maximal usefulness \nof a module construct that encapsulates objects and related operations, an invoker of an operation should \nbe notified of the detection of an exception, to allow it to determine an appropriate action. This also \nsupports modular decomposition: the detection of an exception is done by the operation supplied by the \nmodule, but the response, which is application specific and cannot therefore be determined in the module, \nis left to the invoker. Not if ying the invoker of an operation that an exception has been detected is \ncalled signaling the exception, and the operation is called a aignsller of its exceptions. The program \nsupplied by the invoker for responding to the detection of an exception is called the handler. syntactic \naxiomatic replacement in [16]. extension and semantic definitions model in ALGOL both operational and \nfor embedding the 68 ([15]) are presented The replacement model oriented view: a program is expression; \nexceptions subexpressions that cannot adopts an expression considered a composite correspond to be fully \ncomputed in their signaller. Operations (procedures and functions), are required to declare the identifier \nz. EXCEPTION RANDLING IN THE REPLACEMENT MODEL and data type of each exception they signal. Any generalized \nexpression (i.e., closed construct Operations language, whether provided primitive by or a programming \nprogram-defined such as a a signaller, block, by loop or declaring conditional), its exceptions. may \nbecome (functions and procedures), defined only on a subset domain of definition. This an assertion that \nwe call aasertion of the operation. of an operation a atate in can often be usefully of the states in \ntheir subset is defined by the normal case input We c~~eption that operation s domain Exception handling \nconsists of computing returning replacement 1. either the (after which in the replacement model replacement \neffects and values for: signaling of the exception the signsller may resume), or ~%lrt~~~. empty (or \n ;xa~~~~fyofth~xc~yols ended) file for the read c;;lu~~pl~ operation, a 2. the invocation exception of \nthe signaller of the Since in 1. signaling hss the effect of a normal procedure call to the designated \nhandler, Permission to copy whhout fee aU or part of this material k granted no new keyword is required \nfor supporting provided that the copies are not made or dktributed for direct resumption; an end terminating \na handler has commercial advantage, the ACM copyright notice and thethle of the exactly the inten~ semsntica. \nThus our only publication and hs date appear, and notice k given that copying k by permission of the \nAssociation for Computing Machinery. To copy otherwise, or to republish, requkes afeeand/or specific \npermksion. lSince exceptions can be propagated, an exception of one operation may also be a result of \nanother operation used in its implementation not having its normal case input assertion satisfied. o \n1982 ACM0-89791-065-6/82/001 /0281 $00.75 281 syntactic extension, apart from extensions to the type \nsystem, is the completer (a piece of punctuation similar to a closing bracket) replace, allowed within \nhandler bodies. Replace completes an expression in a handler. The value of this expression will serve \nas a replacement for the value that the signaller would have returned in the normal case. The addition \nof replace suffices to support all of the structured handler responses considered useful in previous \nexception handling proposals (e.g. [3], [11, [51, [71, [4] and [9]): replacing the immediate signaling \nof the exception yields resumption; replacing the signaller invocation yields termination; signaling \nan exception within a handler yields propagation; having a new invocation of a signaller within a handler, \nto replace a signaling invocation, yields retry; signaling an exception of a closed construct, in the \nhandler for the original exception, with the handler for this propagated exception replacing the invocation \nof the construct, yields termination of the construct as a result of the original exception. None of \nthe proposals we are aware of, can support all of these handler responses in a structured fashion. As \nan example consider the procedure convert , which takes an array-of-integers variable as a parameter, \nand returns the string of the integers character representations, signaling an exception badcode when \nan integer for which there is no corresponding character is found. The procedure is written in ALGOL \n68, modified to include the extensions required for our exception handling mechanism. Ex?Ec n ert = (.Esu-EEc \nde) SEz.!E signals (exe (int) (~ string) badcode): begin Q-&#38;L&#38;s = ; for i from lb code to \nub code . do ~:= s + repr code[i] # append to s the char represented by code[i]# od ~ nochar = (char, \nchar): ~when repr s~ls nochar, # badcode(i) replace # signal ba~ no;  s end Convert invokes the operator \n~, . which returns the character represented by an integer if one exists. Repr has been modified here \nto signal the exceptio~ nochsr if its argument does not represent any character. Convert handles nochar \nof repr by signaling convert s own exception badcode, thus propagating nochar. A signaling of an exception \nhas the same syntactic form as a call. The value returned by a handler for badcode will replace the value \nthat would have been returned by repr, had ~ not signalled an exception. On e=h no postfixed to a closed \nconstruct (here= loop~designates the handler expression h for all signalings of the exception e in that \nconstruct. In ALGOL 68, a procedure denotation is headed by the list of the types and identifiers of \nits formal parameter, and its return type. The same is done here for handler denotations. In general, \nh can be any expression yielding a handler. In the following, we use only handler denotations. Exc is \nthe type constructor for exceptions. Excep~ns are typed by the type of their parameters and their two \nreturn types. An exception (and any handler designated for it), has two return types (e.g., (~, string) \nfor badcode), since a handler may either resume, or replace the signaller invocation, and each case may \nrequire the handler to deliver a value of a different type. By convention, the first type listed in the \nreturn type pair is that for resumption, the second that for replacement. For example, the type of repr \nis: ~ (int) char ~nals ( exc(char, char) nochar) . The identifier and data type of badcode are declared \nin convert s heading, and are considered part of convert s data type, in order to enable a compiler to \ncheck that handlers of the proper types have been designated in the static scope of each invocation of \nconvert , as required in the replacement model. Exceptions are not passed up the calling chain unless \nexplicitly propagated by a handler. The following examples demonstrate how the various handler responses \nare supported in the replacement model. 1. Resumption: supply a ? as a replacement for the char corresponding \nto badcode. Convert then resumes. The result is therefore a string in which the characters corresponding \nto unconvertible codes are ? . do . . . print(convert(nums)) . . . od ~ badcode = (int i) (char, stri~): \n? no . 2.i Termination of the signaller: supply the the empty string as a replacement for the string \nreturned by convert. Note that the replace type of an exception is always the type returned by that exception \ns signaller. do . . . print(convert(nums)) . . . od ~ badcode = (int i) (char, stri~): replace no \n Since replace completes the expression whose value is intended to serve as a replacement for the ~alue \nreturned by the signaller, its semantics are: return the value to the point (label) following the invocation \nwhich signalled the exception this handler was designated for. This is the return label for the signaller \ninvocation, and can therefore be statically determined. 2.ii Retry: retry after changing the badcode \nto a zero. The string returned by the new invocation of convert will be returned as (a replacement for) \nthe value of the initial invocation. ~ . . . print(convert(nums)) . . . od ~ badcode = (int i) (char, \n_ stri~): &#38;k@ nums[i] := O; convert (nums) replace # call convert again, to replace the result of \nthe previous call # end no To support replacing subexpressions at ~nY level uniformly, without coupling \nthe effects made by a handler to the flow control required after the handling is completed (as in [4, \n7]), anY closed construct in the embedding programming language is allowed to become a sigMller of exceptions. \nThis is done by the construct declaring its exceptions in a signals clause following the opening bracket \nof the construct. Thus for example, a block, loop or conditional can become a sigmller of exceptions. \nThe rules for resumption and replacement uniformly to procedure sigmllers and any closed construct sigmllers. \napply The following example will demonstrate two of the handler responses supported by the replacement \nmodel: termination of a closed construct containing the invocation signaling an exception (as in [4, \n71), and exception propagation. In order to obtain termination of the loop after badcode has been detected, \nthe loop iS made a signaller of a parameterless exception called finish . This is done by attaching a \nsignals clause after the @, declaring finish. The two types appearing in finish s heading are its resume \nand replace types respectively. Finish is signalled in the handler for badcode (i.e., it is the propagation \nof badcode). When the handler for finish replaces finish s signaller s invocation \u00ad the 100P invocation, \nthe loop will be terminated, as required: 3. Termination of a closed construct and . exception propagation~ \nw do signals (exe (char void) finish) . j_ w Pri t( = nvert(n ms)) E??!l on bedcode = (int i) (char, \nstring): finish no z enT ~ finish = (char, void): ~ replace no # when finish is raised, replac~i~mller \ns invocation by the value yielded by skip # Skip in Algol 68 yields an undefined value of whatever type \nis required by the context. For further details and examples of the replacement model see [16]. 3 AXIOMATIC \nSEMANTICS Our axiomatic treatment of exception handling follows the axiomatic approach proposed by Schwartz \nfor Algol 68 in [13]. We find this approach most suitable for axiomatizing the replacement mechanism, \nsince it contains rules of inference for procedures that allow parameters of arbitrary types including \nprocedures, and contains no restrictions on side effects in expressions. It should be noted that side \neffects occur mturally in exception handling, since any effect made by a handler (including the printing \nof an error message) is a aide effect of invoking the signaller. Sentences in the extended logic used \nin [13] have the formN / P {s} Q I=v. S is an expression or statement. 1 represents the value yielded \nby s (empty if s is a statement). P and QA1=v are the input and output assertions respectively. N is \na NESTL, which maps the set of all identifiers and derived modes known at each point in the program, \ninto their declared modes. The NESTL provides the static properties of the program necessary for the \nproof. The axiomatization assumes that programs to be verified are compile-time correct, i.e., all type \nchecking and mode equivalencing have been done, and all grammar imposed restrictions have been met. The \nabove sentence is to be read as if P is true with respect to N, and if the evaluation of s halts, then \nQ is true with respect to N after evaluating s, and the value yielded by s is v . The axiomatic definition \nof exception handling requires: 1. a form for specifying a signaller together with the exceptions it \nsignals, independently of any specific choice of handlers, 2. a definition of correctness of a signaller \nwith respect to a specificat~on of the above form, 3. a form for specifying the independent effect of \na handler, and 4. an adaptation style proof rule that combines the specification of a signaller, together \nwith the specifications of the handlers designated for an invocation of that signaller, in order to derive \nthe effect of that invocation.  3.1 Specifying Signalers and their Exceptions Let s be a signaller \nof one exception e with formal parameters ~. We use the following notation for an input/output specification \nof s: (1) N / {P, QA1=v, e(~) <E(z), R(~)A~=u>} P is the input assertion. QA1=v is the normal case output \nassertion which will be satisfied if no exceptions are signalled. E iS the exception condition corresponding \nto the exception e, describing the state when e is signalled. RA1=u iS the resumption condition, which \nis required to be satisfied by a handler for e before resumption, in order to ensure that the normal \ncase output assertion, Q Al=v , will be satisfied if and when s halts. The above specification states \nthat if the input state satisfies P, and if the execution of the specified construct halts, then either \nQA1=v holds, or the exception e is signalled and the state then satisfies E. RAI=u must be satisfied \nbefore resumption. This notation reduces to {P, QA1=v} when there are no ~xceptions, but in that case \nwe will uae the conventional notation: P {s} QA1=v. We say s is y artially correct with respect to the \nspecification above, or a PC wrt N/ {P, QA1=v, e(~) <E(z), R(~)Al=u>] iff for any handler h for e N/ \nE(z) {h(~)} R(~)Al=u N/ P {S } QA1=v i.e. , iff the assumption N/ E {h} RA1=u, enables proving that \nN/ P {s} QA1=v. This enables us to use the procedure proof rules to push assertions through a signaling \nin the process of verification, even though the handler is not known within the signaller body. The rule \nfor an invocation of a signaller will ensure that a handler does indeed satisfy the resumption condition \nbefore resumption. In the general case, a specification may include several (P, QA1=v) pairs, which may \neach have several associated exceptions. The extension to this case is straightforward (see [16]). 3.L \nSpecifying Handler Effects Since resumption is obtained by the same mechanism as procedure calls, and \ntermination of a construct enclosing an invocation is obtained by simply generalizing the notion of a \nsignaller, we need onlY one additional rule (to the rules in [13]), in order to specify handler eemantics. \nThis is the rule for the site of the completer replace. &#38;2. i Rule for Replace Replace completes \nan expression in a handler body . The value of this expression is yielded at the program location (label) \nto which control is transfered by replace. This label is the return label of the invocation the handler \nwas designated for, and is statically determinable. Replace has the effect of preserving both the state \nand the returned value, except that control is transferred to the label determined by the invocation. \nThe interpretation of this label therefore haa to be adapted to the context of each invocation for which \nthe handler is designated, aa will be seen in the rule for the site of an invocation given below. The \nrule for replace is: N/P{e}QAl=v N / P {e replace} replace: QA1=v The notation here is borrowed from \ntemporal logic ([12]), which uses assertions of the form <label>: <predicate> to specify that the predicate \nis to hold at the specified label in the program. The replace: in the consequent is an uninterpreted \nlabel, which will be interpreted (adapted) in the rule for the site of an invocation, for each specific \ninvocation. 3.2.2 Rule for a Signaller Invocation This rule combines the independent specification of \na signaller, and the independent specification of the handlers designated for a particular invocation \nof this signaller, to derive the effect of the invocation. Since the signaller, and the handlers for \na given invocation of it, are likely to have different accessing environments, an invocation maY have \nside effects on objects in the environment containing the invocation, which are not accessible to the \nsignal ler. Let T.NV be an assertion about objects in this environment which holds true before the invocation, \nand is preserved by the elaboration of the actual parameter expressions. If INV is preserved by all handlers \ndesignsted for that invocation (for all the exceptions that may be signal led by the invoked signaler), \nwe will conclude that INV remains true after the signaller has completed. In [13], a unique special variable \nIi is associated with each occurrence of each expression layer in the program, representing the value \nyielded by evaluating that expression. In order to be able to maintain a normal form: l=v for assertions \nabout lis when pushing assertions through successive expression layers, the domain of formal values was \nenlarged to include conditional values of the form (P Iv) (intuitively: if P then v ) , and vl@v2 (intuitively: \nVI or V2 ), where P is a predicate in the underlying logic, and v, Vl, V2 are themselves formal values. \nWe first give a special case of the rule for the case where the expressions yielding the sigmller and \nthe handler are both identifiers (p and h respectively), bound to values of the corresponding types (aa \nopposed to arbitrary expressions) . This is probably the most common case, and is most likely to be supported \nin programming languages that are not expression oriented. For brevity, we assume that p may signal only \none exception ex. The rule is: 1. N/ TAINV {COLLAT(el, . . ..en)} PAINVAle=~ 2. Ifp/ p(~) PC wrt {P, \nQA~=V, ex(~)~, RA~l=u>} 3. N/ EAINV {h(~)} RAINVA1l=U V replace: SA12=y  N/T A INV {p(el, ... en) w \nex=h ~} (Q v s) AINV A1=(QIV)O(SIY) Premise 1 accounts for the effects of the collateral elaboration \n(evaluation in an unspecified order) of the actual parameter expressions el,...en. This elaboration may \nhave side effects. (Rules for collateral elaboration can be found in [13]). Premise 2 is the specification \nof p, in the form described earlier. Premise 3 is the specification of the handler h. The input assertion \nfor the handler naturally involves the exception condition for the exception the handler is designated \nfor. A handler may either cause resumption of the signaller after handling (indicated by terminating \nthe handler by end, without any preceding replaces); in this case ~must be shown that the handler established \nthe resumption condition, in order to be able to conclude that the normal caae output assertion holds \nafter p terminate; alternatively, it may cause replacement of the signaller (indicated by an expression \nfollowed by replace); in this case the result of the invocation will be the result of evaluating the \nreplacement expression. There can also be more than one replace in the handler, or a conditional choice \nbetween resumption and termination. Thus in general, the output assertion of a handler contains both \nan assertion for the resumption case and an assertion for the replacement case. The consequent statea \nthat if all the premises hold before the invocation, then after the invocation, either the normal case \noutput assertion or the handler s replacement output assertion hold. The syntactic rules for designating \nhandlers allow an on clause designating handlers, to be postfixed to a closed construct, thus designating \nthe handlers in the on clause for all invocations within the construct. In the proof rules it is a=sumed \nthat all handler designations have been copied to immediately postfix the associated invocations. This \ncopying transformation can be determined statically. The rule for a signaller which is a closed construct \n(e.g. block) is a special case of the rule for a signaller invocation, where there are no parameter expressions \nand INV=true: 1. N/ s pC wrt {P, QAIO=V, ex(~) C3, RAll=wJl 2. N/ E {h(z_)] RAll=w V replace: SA12=Y \n N/ P {s ~e~h~} (Q V S) A1=(QIv)O(SIY) In the general case, in an expression oriented language both \nthe invoked signsller and the designated handlers can be yielded by arbitrary expressions. In this case, \nthe proof rule needs to consider all the signaller values that could possibly be yielded by these expressions. \nEach of these signalers maY be partially correct with respect to different input, output, and exception \nspecifications (though they will all have exceptions With identical identifiers and data types, since \nthese are considered part of the data type of the signsller). In order to not complicate the rule further, \nwe assume that the invoked signaller may signal only one exception ex. The rule is thus: 1. N/TAINV{COLLAT(ep,el, \n. . ..en.eh)} [~, (Pi Alp=@l A \\~l(Pj A~=hj)]A INV A1e=~ ,_ 2. V i, I<i<m N/ wi(~) PC wrt {Pi, QiA~l=vi, \nex(y) <Ei, RiA12=Zi>}  3. v i,j, l<i<rq l<j<k  [N/ EiAINv {hj(y)} RiAINVA~=Zi V replace: sij AI~All=uijl \nN/TAINV {ep(el,...,en) ~ex=eh~} INV A [((i~LQi) All= (Q1lvl)@...@(Qml vm)) V (i~l~,sij) ll=(sll lull)$ \n @(smklumk))] Premise 1. accounts for the side effects of the (collateral) evaluation of the expressions \nyielding the invoked procedure value, the parameters to the invocation, and the designsted handler. \nml are potentially conditional values. However, for both the invoked procedure and the designated handlers, \nit iS necessary to distinguish all the individual values comprising the conditional value in order \nto examine all the individual specifications. Thus , assuming that the procedure expression ep may \nyield any one of the routine values w , instead of writing lp=p where p is a condit i oml value involving \nm (P~lw~)s, P is separated into the m (piAl~i)s. The same is done for $. le=~ is shorthand for le =v~, \ni=l, . . ..n the -actual (conditioml) pa$ameter values. Premise the possible 2. includes signellera \nthe specifications thatcould be yielded of all by e. P premise the possible by .h. 3. includes handler \nva the luee specifications that could be of yielded all In the following we outline the use of our proof \nrules in proving the correctness of convert. Since convert contains an invocation of a signaller, this \nwill demonstrate both proving correctness with respect to a specification of the form we have introduced, \nand applying the rule for an invocation. In order to keep the notation less cluttered, the NRSTLS are \nomitted. We assume repr(n) has been proven correct with respect to the following specification: {P repr(n)= \ntrue # repr assumes nothing about its argument # Qrepr(n)s cl<n<ch Al=char rep(n), # repr returns the \ncharacter represented by its argument when its argument is in the range (cl,ch). # nochar <EnocharS \nn>ch V n<cl, # when repr signals nochar, its argument is out of range # RQrepr(n)>} nochar= # in order \nto ensure that repr satisfies Q~epr(n), a handler must satisfy Qrepr(n) before resuming repr # It is \nassumed that the mapping char rep has been defined appropriately. The rules also assume that that all \ntype checking has already been performed. Rnochar in effect specifies that resumption of repr after nochar \nhas been signalled cannot possibly lead to repr satisfying its normal case output assertion, since n \nis a value parameter. The specification of convert makes use of the Algol 68 ascription relationship, \nwhich associates identifiers with the values to which they are hound. Since code is a variable identifier, \nit is bound to a location of an array-of-integers The contents of this location are obtained code by \nthe mapping T, and are denoted here by code. (Ascribed and T are close to the notions of environment \nand store in denotational semantics). We assume the following specification of convert: {P = ascribed(code,dcode) \nA~(dcode)=vcode convert\u00ad # aasuming that Vcode is the value at the location bound to convert s argument, \n# QConvert(code) SPconvert A .(d~) = ub code + [(Cl<vcode(i)<Chl char rep(vcode(i))) i=lb code . @ \n(CIJVcode(i) v vcode(i)>chl replchar)] A MS when convert terminates, the argument will be unchanged, \nand the returned value will be the location of the result of the successive concatenation of character \nrepresentations and replacement characters, corresponding to the cases of character and noncharacter \ncodes respectively # (i)sPA Ebadcode convert (cljvcode(i) V vcode(i))ch) # when badcode is signalled \nan unrepresentable code has been encountered, # badcode(i)= Ebadcode Al= replchar>} # and the handler \nmust provide a replacement character in order to enable convert to satisfy Qconvert # We define string(l,u) \n~ ~ [(cl<vcode(i)<chl char rep(vcode(i))) i=l @ (C1>VC de(i) V vcode(i)>chlrepl char)] string(l,u? is \nthe string resulting from the successive concatenation of the corresponding character representation \nfor character codes of code, and repl char for non character codes of code. The major step in the proof \nof correctness of convert with respect to its specification is in proving: Pc A ascribed(s,ds) A T(ds)= \n?~:;rt i from lb code to ub code  do S := s + repr code[i] nd.\u00ad x nochar = (char,char): . badcode(i) \nreplace  no } P conv~t Aascribed(s,ds) A ~(ds)=string(g code,~ code) Al=empty This requires using the \nrule for a loop. We use the following notation for intervals on the integers: [l,u]={jl l<j<u, j&#38;INT} \n[I,u)={jl l<j<u, jsINT} The rule for a loop which we need to apply is: 1. N/P =>1([]) 2. N /i E[l,u] \nAI([l, i )) {body } 1([1, i ])  N/P{for i from 1 to u do body od} . _ I([l,u]) A l=empty I in the above \nis the looD invariant. Let: holds after the invocation of repr. p= Therefore S=p sw%%= @cribed(s ds) \nI([l,u]) ~ S A c(ds)=string(l,u) I([lb code,i )) The proof of premise 1. is immediate. In order to show \n2., (the inductive step), we need to use the rule for an invocation of a signaller, in order to get the \neffect of repr given the supplied handler. We want to show that I([lb code,i )) {re~code[i] on nochar \n= (char, char): . badcode(i) replace no } I([lb~ode,i ]) Al= +~cl~vcode(i)~chl char ep(vcode(i))) e \n(cl>vcode(i) V vcode(i))chlreplchar)] We use the rule for an invocation with T~I([lb code, i )). Since \nthere are no side . effects in evaluating code[i], we have for premise 1. of the rule for an invocation: \n1. N/ I([lb code,i )) {code[i]} . I([~code,i )) ATWcode(i) For premise 2. of the rule for an invocation, \nwe assume repr has been proven correct with respect. to the given specification. The output assertion \nof 1. trivfally inipiles the input assertion of repr. For premise 3. of the rule for an invocation, we \nneed to get the characterization of the handler for nochar. This handler propagates repr s exception \nnochar as the exception badcode of convert. Our definition of partial correctness allows to assume in \nproving the correctness of a signaller (here convert), that any handler for an exception signalled in \nthe signaller s body, is partially correct with respect to that exception s specified exception and resumption \nconditions. Thus, if it can be shown that just before the signaling of barcode, the exception condition \n(i) holds, it may be assumed that badcode immediately after the signaling, the corresponding resumption \ncondition badcode(i)holds . Since for code[i] E (i), nochar > badcode we may assume (i) holds after the \nbadcode sigmlling of badcode. Thus : 3. EnocMr {(char, char): badcode(i) replace } replace: PA (cl>vcode(i) \nV Vcode(i)>ch) convert A 1= replchar Applying the rule for an invocation, we can conclude that: I([lb \ncode,i ]) A 1= ((cl<vcode(i)~chl char rep(vcode(i)) @ (cl>vcode v vcodejchl rePlchar)) {s ~ a += code[i] \non nochar = (char, char): badcode(i) replace no } I~lb code,i ]) A l=ds so ~hat the rmoof of uremise \n2. of the rule for a loop immediately follows. Applying the rule for a loop, we can now conclude the \nrequired output assertion for the loop : I([lb code,ub code]) ~ P A~cribed(s,ds) c~n%~~)=string(g code,~ \ncode) The last expression in convert is the evaluation of s, whose value is returned as the value of \nconvert. I[lb code,ub code]) {Sy P Aascribed(s,ds) c~n%~~~)=string(~ code,~ code, code, replchar) A \nl=d~ The proof of the above immediately follows from the rule for elaborating an identifier. Since the \nabove immediately implies Qconvert(code), this concludes the proof of correctness of convert with respect \nto its specification. 4. CONCLUSIONS Adopting an expression oriented approach, and generalizing the concept \nof a signaller, enabled us to support all the structured handler responses that were considered useful \nin various proposals for exception handling, with minimal additional mechanism. The uniformity of the \nmechanism, contributes to the simplicity of its axiomatic semantica. In contrast, the only other exception \nhandling proposals supporting both resumption and termimtion of the signaller, [1] and [91, require a \nmuch more complex syntactic and semantic extension, though neither one supports all the handler responses \nsupported in the replacement model. The mechanism can be adapted to any of the block-structured programming \nlanguages modulo their specific restrictions, with little loss of expressive power. It is interesting \nto note that addressing exception handling in the context of modularity and program verification providea \ninsights that contribute to simplifying the mechanism. Modularity requires both the exception state and \nthe resumption state to be be consistent or possible states in the sense of [11], otherwise they cannot \nbe specified externally without compromising modular information hiding. This eliminates the problem \nof exceptions which must be resumed in order to restore the state to a consistent atate. Exceptions which \ncannot, or must not, be resumed, should be signalled just before a logical end of the signaller, after \nwhich there is nothing left to be done in the signaller even if resumption is attempted. This eliminates \nthe need for constructs such as the SIGNAL and NOTIFY in [1], and SIGNAL and ERROR in Mesa ([9]), and \nthe main argument of [5] for supporting only resumption. References 1. Goodenough, J. B. Exception Handling: \nIssues and a Proposed Notation , Comm. ACM, 18,2 December 1975. 2. Hoare, C. A. R. An Axiomatic Basis \nfor Computer Programming , Comm. ACM 12,10 October 1969. 3. IBM OS PL/I Checkout and Optimizing Compilers: \nLanguage Reference Nanual SC33 0009 2 IBM Corp. 1973. 4. Ichbia, J. et al Rationale for the Design of \nthe ADA Programming Language SIGPLAN Notices 14,6 June 1979. 5. Levin, R. Program Structures for Exceptional \nCondition Handling . PhD Thesis, Carnegie Mellon University, June 1977. 6. Liskov, B. H. and S. N. Zilles, \nSpecification Techniques for Data Abstractions , IEEE Trans. Software Eng. 1,1 March 1975. 7. Liskov, \nB. H. and A. Snyder, Structured Exception Handling Computation Structures Group Memo 155, MIT December \n1977. 8. Luckham, D. C., and W. Polak ADA Exception Handling: An Axiomatic Approach , ACM TOPLAS 2,2 \nApril 1980. 9. Mitchell, J. G., W. Maybury and R. Sweet MESA Language Manual , Xerox Research Center, \nPalo Alto March 1979. 10. Parnas D. L., A Technique for the Specification of Software Modules , Comm. \nACM 15,5 My 1972. 11. Parnas D. L., Response to Detected Errors in Well-Structured Programs , Computer \nScience Dept., Carnegie-Mellon University 1972.  12. Pnueli, A. The Temporal Logic of Programs , 19th \nAnnua 1 Symp . on Foundations of Computer Science, Providence R.I. November 1977. 13. Schwartz, R. L., \nAn Axiomatic Semantic Definition of ALGOL 68 , PhD Thesis, UCLA 1978. 14. Schwartz, R. L., An Axiomatic \nTreatment of Algol 68 Routines , Proc. 6th International Conf. on Automata, Languages and Programming, \nGratz Austria July 1979. 15. van Wijngaarden, A. et al Revised Report on the Algorithmic Language Algol \n68 , Acts Informatica 5 1975.  16. Yemini, S. The Replacement Model for Modular Verifiable Exception \nHandling , PhD Thesis, UCLA 1980.   \n\t\t\t", "proc_id": "582153", "abstract": "", "authors": [{"name": "Shaula Yemini", "author_profile_id": "81100348939", "affiliation": "New York University", "person_id": "PP39038802", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/582153.582183", "year": "1982", "article_id": "582183", "conference": "POPL", "title": "An axiomatic treatment of exception handling", "url": "http://dl.acm.org/citation.cfm?id=582183"}