{"article_publication_date": "01-25-1982", "fulltext": "\n LITHE: A LANGUAGE COMBINING A FLEXIBLE SYNTAX AND CLASSES* David Sandberg Department of University Seattle, \nComputer Science of Washington WA 98195 The syntax of a program greatly influences its readability. \nA good syntax suggests the meaning attached to a construct and suppresses irrelevant details. In most \nprogramming languages, the user s control over syntax is limited to the choice of identifier names and \nt be overloading of some operators. This paper introduces an experimental programming language, Lithe, \nthat allows the user to freely choose his own syntax. Lithe combines two ideas that have been used successfully \nbefore: syntax-directed translation and classes. Although these ideas are old, they are combined in a \nnew way that results in a remarkably simple yet powerful language. 1. Classes and Syntax-directed Translation \nThe class model has been used in Simula 67, Smalltalk, and other programming languages. In an overview \nof Smalltalk [4] , John Shoch gives a characterization of the class model: 1. Every entity, no matter \nwhat its name or funct ion, is an object. 2. Every object is an instance of a -, and behaves in a manner \nprescribed by that class. *This research was supported in part by the Nationsl Science Foundation under \ngrant number MCS 7826285. Permission to copy without fee all or part of this material k granted provided \nthat the copies are not made or distributed for direct commercial advantage, the ACM copyright notice \nand the title of the publication and its date appear, and notice is given that copying is by permksion \nof the Association for Computing Machinery. To copy otherwise, or to republkh, requires a fee and/or \nspecific permission. 3. Each object may maintain its own local state, or memory; some aspects of this \nmemory are unique to the instance, while others may be common to all members of the class. The class \nmodel does not specify a mechanism by which to manipulate objects. Smalltalk uses message passing to \nperfotnr this function. Lithe uses syntax-directed translation (SDT). SDT ia a method of translating \na string into a sequence of actions. It involves attaching an action to each rule of a grammar. Parsing \na string produces a sequence of applications of rules. Since each rule is paired with an action, this \nsequence is easily converted into a sequence of actions. This is a standard method used in compiler construction. \nLithe merges SDT with the class model by using the classes as the non-t erminal alphabet of the grammar. \nMesssge passing in Smalltalk-72 allows some new syntax to be introduced but is limited in its ability \nto express syntax. For example, postfix notation can not be expressed and prefix notation can only be \nexpreased by creating auxiliary, degenerate classes [4]. Furthermore, in the code for the class the programmer \nmust explicitly decode the message on a token-by-token basis. This provides a very poor description of \nthe syntax. Smalltalk-80 provides a better description but is more limited in it s ability to express \nnew syntax [1]. On the other hand ,. a grammar 1S the preferred method of describing syntax. Since the \ngrammar class used by Lithe properly contains all context\u00ad free grammars, a wide variety of syntax can \nbe described. SDT also provides a simple way to attach semantica to the syntax. @ 1982 ACM 0-89791-065-6/82/001/0142 \n$00.75 2. Rule-action Pairs and Classes Programming in Lithe consists of defining rule\u00ad action pairs \nand classes. For example, a rule\u00ad action pair for taking the absolute value is defined in Lithe by: rule \n1 <i:int> l return int; {if i<O then return -i else return i end} After this pair has been defined, it \ncan be freely used, for example in lx-yl+3. In the definition, the first line defines the grammar rule \nand the second line defines the action. The equivalent grammar rule in BNF is: <int> ::= 1 <int> 1 (1) \nThe Lithe description interchanges the left and right eides of the BNF and adds a name to each nonterminal \nin the right-hand side. These names are used in the definition of the action. The action is expressed \nas a string that is translated into a sequence of actions by using other rule\u00ad act ion pairs. Some of \nthese rule-action pairs will have primitive actions. Lithe has two kinds of classes: normal and value. \nInstances of normal classes are represented by a pointer to a record. The assignment operator for these \ninstances copies the pointer. Objects in value classes are represented by a record. Assignment for value \nclasses copies the record. Value classes are more appropriate for implementing data types such as rational \nnumbers and complex numbers. Normal classes are used for constructing linked structures such as trees \nand lists. 3. Packages The package is the unit of modularity in Lithe. A package is divided into two \nparts: the first part defines classes and the second part defines rules. Only those rules and classes \nprefixed with export are visible outside the package. Rules exported from other packages are visible \nin a package only if the names of the other packages are included in the with clause of the package. \nFigure 3-1 contains a package that implements rational numbers. This package defines expressions like \nwrite 1/2-1/3 . The first rule defines the greatest common divisor of two integers and is used in expressions \nsuch as gcd of 15 and -35t1. The action of this rule is defined recursively; that is, the syntax defined \nby the first rule is used in the definition of the action of the firat rule. The action also uses a temporary, \nt, in the same package rational classes { with base, io $ Allows standard rules to be used. export value \nclass rational ; { num:int; den:lnt; ) ) rules { ~~e !Igcd,l ,,of,, <x: fnt> land! <y: int> return int; \nt:int; { x gets 1x1; y gets IYI; if x<y then return gcd Of Y and x else t get SXmod y if t-O then return \nY else return gcd nf Y and t end end } 00/8, <y: int> return rational; export rule <x: int> r: rational; \n{ num of r gets x; den of r gets Y; return r 1 rule simplified <r:rational> return rational; { i;:~~~ \nof r -0 then return 0/1 else ggets gcdof num of r and den of r return numof rdiv s/denof rdiv g end } \n ,f(t, <r:rat~onal> I)tt return ratkmd: export rule { return r } ,,*,, <Y: rational> return rational; \nexport rule <x: rational> (return numof x*numnf y/den nf x*den of y } export IUle <x: rational> + <y: \nrational> return rational; { return(num of x * den of y)+(num of Y * den of x) /denofx*denofY} export \nrule <x:rational> - <y,; rational> return rstional; { return(num of x * den Of y)-(num nf Y * den Of \nx) /denofx*denofy} export rule <x:ratinnal> l <y: rational> return rational; [return mmofx*denofYIdenOfx*numOfY) \n export rule write <r: rati Onal> i { r gets simplified r; write num of r; write / ; write den Of r } \n) Figure 3-1: Definition of Rational Numbers manner as a local variable is used in a procedure. The \nwrite rule in Figure 3-1 has no return clause. A return statement is supplied by default. The grammar \nin Figure 3-1 allows ambiguous expressions like 1/2-1/3-1/4 which may mean l/2\u00ad (1/3-1/4) or (1/2-1/3)-1/4 \n. Such an expression has an ambiguous meaning and is not permitted in Lithe programs. In this case equivalent \nexpressions can be written thatare not ambiguous, for example 1/2-(1/3-1/4) . Ambiguous expressions are \neasily detected by a compiler for Lithe. h. Parametrized Classes Parametrized classes were derived from \nCLU S parameterized clusters [3] . Parametrized classes allow one class to be used where many classes \nwould be required otherwise. For example, a parameterized class defines the concept of a name in Lithe. \nA name is a container for a single object. There is a different type of name for each class. The type \nof a name can not change and determines the class of the object in the name. This behavior could be obtained \nby defining a different class for each type of name, but instead a single parameterized claas, name of \n? , is used . . !, .,,,.! .7. . .<.. wnere cne parameter, , aecermlnes cne type or the name. Rule-action \npairs are provided to put an object in a name and to obtain the contents of a name. These rules have \nthe non context-free syntax: rule <n:name of ?> gets <value:?>; (2) rule <n:name of ?> return ?; (3) \nWhen one of these rules is applied, the question marks in the rule are replaced with some class. To give \nsome idea of how these non-context-free rules work, consider the derivation of x gets IX[ in the gcd \nrule of Figure 3-1. The value of the first parameter is contained in a name, x. A rule\u00ad action pair is \nautomatically created that returns this name: rule x return name of int; (4) The rightmost derivation \nof x gets 1x1 is: statement ==> <name of int> gets <int> (2) ==> x gets <int> (4) ==> x gets I <int> \nI (1) ==> x gets I <name of int> I (3) ==> x gets 1x1 (4) The number to the right is the rule that is \nused. In applying rules (2) and (3), the question marks were replaced with the class int . Figure 4-1 \ncontains an example of a user-defined parameterized class. This example defines linked lists of objects \nof a given class. An iterator like CLU S [3] is defined by the third rule in this example. The addition \nof the word delay on the last parameter of this rule causes the parameter to act like an Algol-60 call-by-name \nparameter. The last rule in this package is used to remove ambiguity. It is used in the other rules to \nforce the value of a name to be assigned instead of the name itself. The action for this rule is defined \nusing rule (3). package lists classes { with base, io $ Allows 6tandard rules to be used. export class \nlist of 7; { value:?; link: list of 7; } } rules { lItoU QXpOrt rule add <V:?> <L!name of list of ?>; \nk:llst of 7; { k gets create ; link of k gets L; value of k gets v; .1, gets k } export rule reverse \n<L:name of list of 7>; t: list of ?; r: list of ?; { t gets nil; while not L==nll do r gets link of \nL; link of L gets t; t gets L; .L gets r end .Lgets t } export rule for each <i:name of ?> in <L:list \nof ?> do <delay s:statementlist> end ; ( while not L=-nil do .i gets value of L; .9 ; L gets link of \nL end } export rule empty return list of ?; { return nil } rule . <k:name of ?> return ?; { return k \n) } Fignre 4-1: Definition of Lists A simple rule action pair that uses lists is: rule test lists ; \nL:list of int; i:int; { L gets empty for i from 1to 10do add i to Lend for each i in L do write i; write \n end reverse L for each i in L do write i; write  end } This action will write 1O 987 6543 21123 45678910 \n. 5. Discussion Allowing the user to choose syntax has two potential problems. Nothing constrains the \nprogrammer to choose a good syntax over a poor syntax except his good judgement. This is not a sufficient \nconstraint to guarantee that an acceptable syntax will be used. Furthermore, a programmer may isolate \nhimself and develop a dialect that no one else understands. Encouraging sharing, for example by providing \na good library of program modules, should discourage the development of such dialects. In addition to \ngeneral programming, Lithe appears well suited for applications that require the definition and use of \nnew syntax. Many times these applications also require basic programming language constructs such as \ncontrol structures and common data types. Examples of these applications are command interpreters, editors, \nformatters, and compilers. To uae Lithe for a command interpreter, new rule-actions pairs are defined \nthat describe the syntax and semantics of the commands. The Lithe system can then parse and execute these \nnew commands along with any other rules in the Lithe system. Thus Lithe provides tbe baaic programming \nlanguage constructs with no addition work. A compiler for Lithe has been written in Lithe for a VAX-11/780. \nSeveral examples have been successfully run including the examples in this paper, a simple graphics interface \nto a raster device including turtle graphics , a package to test for membership of a string in a regular \nexpression, and a Polish postfix interpreter. Experience with this compiler has shown that the speed \nof compilation and the quality of code produced ia acceptable. The major inefficiency in the compiled \ncode ia introduced by implementing each use-defined action as a procedure. This results in many short \nprocedures which a better implementation would replace with in-line code. Current ly work is being done \non improving the compiler and evaluating Lithe s usefulness as a programming tool. The most pleasing \ncharacteristic of Lithe is its simplicity. This is reflected in the compiler. Most compilers have five \nmajor parts: a scanner, a paraer, a semantic analyzer, a code generator, and a symbol table. Although \na parser for Lithe is more complex since it must work for a constantly changing, non-cent ext-f ree grammar, \nthe Lithe compiler has only three parts: a scanner, a parser, and a code generator. The functions of \nthe semantic analyzer and the symbol table have been encoded in the grammar. This simplicity is reflected \nin the small size of the Lithe compiler-\u00adabout 3000 lines of Lithe. Extensible languagea of a decade \nago recognized that classes and SDT could be used separately as extension mechanisms. Simula 67 used \nthe class model to extend the semantic to new areas of application [2] and the language PPL used SDT \n[5], but none of the extensible languages used both mechanisms in the same language. More developed forma \nof both of these mechanisms are used in Lithe. One of the problems of the early extensible languages \nwa a their complexity. The extension mechanism added more complexity to an already complex language base. \nThe resulting complexity made them difficult to understand and extend in a useful fashion and is probably \nwhy interest in extensible languages has waned [6]. Lithe demonstrates that extensibility can be provided \nwith a level of complexity below that found in most other programming languages. ACKNOWLEDGMENT I would \nlike to thank Alan Shaw for encouraging me to write this paper and for his careful reading of it. REFERENCES \n[1] Adele Goldberg and Joan Ross. Is the Smalltalk 80 System for Children? BYTE 6(8):348-68, August, \n1981. [2] Jean D. Ichbiah. Extensibility in Simula 67. SIGPLAN Notices 6(12):84-86, December, 1971. \n[3] Barbara Liskov, Alan Snyder, Russell Atkinson, and Craig Schaffert. Abstraction Mechanisms in CLU. \nCommunication of the ACM 20(8):564-576, . August, 1977. [4] John F. Shoch. An Overview of the Programming \nLanguage Smalltalk-72. SIGPLAN Notices 14(9):64-73, September, 1979. [5] Thomas A. Standish. Some Features \nof PPL, A Polymorphic Programming Language. SIGPLAN Notices 4(8):20-26, August, 1969. [6] Thomas A. \nStandiah. Extensibility in Programming Language Design. SIGPLAN Notices 10(7):18-21, July, 1975. \n\t\t\t", "proc_id": "582153", "abstract": "", "authors": [{"name": "David Sandberg", "author_profile_id": "81100042698", "affiliation": "University of Washington, Seattle, WA", "person_id": "P63632", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/582153.582169", "year": "1982", "article_id": "582169", "conference": "POPL", "title": "Lithe: a language combining a flexible syntax and classes", "url": "http://dl.acm.org/citation.cfm?id=582169"}