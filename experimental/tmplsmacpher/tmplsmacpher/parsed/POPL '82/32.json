{"article_publication_date": "01-25-1982", "fulltext": "\n On Effective Axiofnatizations of Hoare Logics Edmund M. Clarke, Jr.l, Steven M. Germanl 3, and Joseph \nY. Halpernl 2 1. Aiken Computation Laboratory, Harvard University, Cambridgg MA02138 2. Laboratory \nfor Computer Science, M.I. Z, Cambridge, MA02139 3. Compu{er Systems Laboratory, Stanford University, \nStanford CA94305  Abrtrr?ct: For a wide cless of programming languages P and expressive interpretatiorrs \n1, we show that there exist sound and relatively complete Hoara-tike Iogica for both partial correctness \nand termination aasertiona. In fact, under mild assumptions on P and I, we show that the assertions true \nfor P in I are uniformly decidable in the theory of I (l h(I)) iff the halting problem for P is decidable \nfor finite interpretations. Moreover termination assertions are uniformly r.e. in T%(I) even if the halting \nproblem for P is not decklable for finite interpretationa. Since totat correctness assertion9 coincide \nwith termination a.wertiona for deterministic programming lartguege.s. this last result unexpectedly \nsuggests that the class of tanguages with good axiom systems for total correctness may be wider than \nfor partial correctness. 1. Introduction 1.1. Background Because Hoare Logic, or axiomatic semantics, \nis one of the most widely used approaches to defining programming language semantics and proving properties \nof programs. it is impor~nt to undera~nd lN limitations and their causes. The question of the existence \nof good Hoare Axiom systems for programming ksnguageswas first raised by Clarke in [C176/79], where it \nwas shown that languages with certain featores cannot have axiom systems that are sound and relatively \ncomplete in the sense of Cook [C078]; natural examples of such features include: call by name parameter \npassing in the presence of recursive procedures, functions, and global variables, and coroutines with \nlocal rccursivc procedures that can access global variables. TIN incompleteness rcsuhs arc established \nby observing that if a programming language P has a sound and rc12tivcly complctc proof .-. ------------------------------ \nThis researchwassupported in part by NSF Grants MCS79-08365 and MCS8O-107O7, Advanced Research Projects \nAgency contract MDA903-80-C-0159, and a grant from the National Science and Engineering ResearchCouncil \nof Canada. Permission tn copy without fee all or part of this material is granted provided that the \ncopies are not made or distributed for direct commercial advantage, the ACM copyright notice and the \ntitle of the publication and its date appear, and notice is given that copying is by permission of the \nAssociation for Computing Machinery. To copy otherwise, or to republish, requires a fee and/or specific \npermission. @ 1982 ACM 0-89791-065-6/82/001/0309 $00.75 system for all expressiveinterpretations, theu \nthe halting problem for P must be decidable for finite interpretations. Lipton Wi77] considered a form \nof converse: If P is an uccep@ble programming language and the halting problem is decidable for finite \ninterpretations, then P has a sound and relatively complete Hoare logic for expressive and effectively \npresented interpretations. The acceptability of the programming language is a mild technical assumption \nwhich ensures that the language is closed under certain reasonable programming constructs, and that given \na program, it is possible to effectively ascertain its step-by-step computation in interpretation I by \nasking somequantifier-free questions about L Lipton actually proved a partial form of the converse. He \nshowed that given a program P and the effective presentation of I, it is possible to enumerate all the \npartial correctness assertions of the form o-ue{P}@lse which are true in L From this it easily follows \nthat we can enumerate all tnre quantifier-free partial correctness assertions, since we can encodequantifier-free \ntestsinto the programs. But it does not follow that we can enumerate all first-order partial correctness \nassertions, since an acceptable programming language will not in general allow first-order tests(cf. \nSection 2). A number of other researchers ([Me78], &#38;a80]) have since attempted to clarify Lipton \ns proof and to extend it to handle first\u00adorder pre-and post-conditions and a wider range of acceptable \nprogramming languages. 1.2. New Results of This Paper We consider acceptable programming languages which \npermit recursive pmccdurc calls. Wc also require, for technical reasons, that every element of the domain \nof I correspond to some term in the assertion language. (These requirements seem quite reasonable; cf. \nSections 2 and 4.) Under these assumptions we are able to sj~njficantly Cxtend thc results of [C]76/79] \nand [Li77]: 1. We are able to eliminate the requirement that pre-and post-conditions be quantifier-free \nand that the interpretation be effectively prescmed, Under the assumption that the halting problem for \nP is decidable for finite interpretations, we show that, for all expressive interpretations, P has a \nsound and relatively complete Hoare axiom system for partial correctness assertions with arbitrary first-order \npre-and post-conditions. 2. We show, in fact, that the set of partial correctness assertions true in \nI is actually (uniformly) decidable in the theory of I (Th(l)) proyidcd that the halting problem for \nP is decidable for finite interpretations. Lipton s proof, on the other hand, produces an enumeration \nprocedure for partial correctnessassertionsand,thus,showsonlythatthe setoftruepartial correctnessassertionsisr.e.inTh(I). \n 3. We extend the decidability result to termination assertions (which coincide with total correctness \nassertions for deterministic programming languages). Here even stronger results can be obtained. The \nset of true termination assertions is (uniformly) decidable in Th(I) iff the halting problem for P is \ndecidable for finite  interpretations. Moreover, &#38;c set of true termination assertions is (uniformly) \nr.e, in Th(l) even if the halting problem for P is not decidable for finite interpretations. This last \nresult unexpectedly suggeststhat good axiom systemsfor total correctness may exist for a wider spectrum \nof languages than is the casefor partial correctness. In particular, it may be possible to find a sound \nand relatively complete total correctness proof system for a language with call by name parameter passing, \nrecursive procedures, functions, and global variables, even though no corresponding partisd correctnessproof \nsystemcan exist. 1.3. Outline The paper is organized as follows. In section 2 we give precise definitions \nfor all our terms; in particular, we carefully specify the conditions that a programming language must \nsatisfy in order to be acceptable. In section 3 we state and prove our main results, contrasting thcm \nwith those of I,iptnn. As in I.ipton s papm, our rw-rlts split into two casesdepending on whether there \nis for every I rograrn P E P a number M such that P n:ver accessesmore than M elements of the domain \non any input In casesuch a bound exists we show that it is possible to enumerate the true termination \nassertions even if the halting-problem for P is not decidable. For partial correctnessour proof in this \ncaseis similar to Lipton s. In case some program can access an unbounded number of different program \nstates,our approach is different from that of Lipton. We show that if the interpretation I is expressive, \nthen it is possible to effectively find formulas which make I into a standard model of arithmetic. (Lipton \nis able to prove the existence of a standard model of arithmetic embedded within the interpretation, \nbut is not able to find it effectively.) We usethe standard model of arithmetic to encode partial and \ntotal correctness formulas as first-order formulas over 1. The oracle for Th(I) is then used to determine \nthe truth of the encoded partial correctnessassertions(resp. termination assertions), The paper concludes \nin section 4 with a statement of some open problems and a discussion of the philosophical implications \nof our results. 2. Basic Definitions   2.1. Interpretations and Valuations A ~ypeor signature is a \nset of function and predicate symbols, each with an associatedarity. (Constants arejust function symbols \nof anty zero.) An irr[erprefatiun I (over a type X) consists of a domain; dom(I), and an assignment to \neach function (resp. predicate) symbol of 2, a function (rcsp. predicate) over dorn(l) of the appropriate \narity. Th(I) is the setof all first-order sentcnccs(over Z) true in 1. In all that follows, we assume \nwe are working over a fixed finite type X For technical reasons+we always assume the constant a is an \nclcmcnt of Z. Throughout this p:ipcr we will assume for case of exposition that X = {a,b,f,g,Ao}, where \na and b are constants, f is a urrmy function symbol, g is a binary fun;tion symbol, and AO is a binary \npredicate symbol. We also assume a fixed set of variables, var = {Xo,xl,,..}. For a term ~ let var(t) \n= {y 6 varl y appears in t}. Similarly, for a quantifier-free formula A, let var(A) = {y 6 varl y appeam \nin A}. For each interpretation I, a valuufion over I is a mapping u: var -i dom(I). We can extend a valuation \nto a mapping u: Terms --+ dom(I) in the obvious way. To represent a diverging computation we introduce \nonc special valuation, J-, such that L(x) is undefined for all variables x. The valuation u[x/a] is identical \nto u on all variables except x, and u[x/a](x)= a, 2.2. Acceptable Programming Languages with Recursion \nAn acceptable programming language P must satisfy the four criteria given below. 1. For each program \nP E P we can effectively find finite subsets CV(P),dep(P) ~ var satisfying certain constraints given \nbelow. Intuitively, CV(P) corresponds to those variableswhosevaluesmaygetchangedaswerun program P, while \ndep(P) includes input variables, output variables, and any additional variables (such as those that appear \nin tests) upon whose values the behavior of P depends. Dctine var(P) = CV(P) U dep(P), In each interpretation \n1 we can also associate with each P E P a set of Irrrjec[ories, ! J(P), where each trajectory 76 T(P) \nis a finite sequence of valuations (Uo,ul,...) such that 1, if it appears at all, only appears as the \nlast valuation. There is no trajectory of the form (1). These trajectories must also satisfy: a. If \ny t cv(P), then for all i, al(y) = uo(Y). (Ilis corresponds to our intuition that the only vtiriables \nwhich get changed as we run program P are those in CV(P).) b. If y E CV(P). then for i >0, Ui(y) = a, \nb, Uj(x), f(uj(x)) or g(uj(x),ffk(z)), for some j, k < i and x, z 6 var(P), c. 1f uo(dcp(P)) = uo (dcp(P)) \nthcrr there is a tmjcctory T = (Uo,ul ,...) C 9;(P) such that u,(dcp(P)) = u~(dep(P)) for all i. This \nconfim is the intuition that the computation of P depends OMYon the variables in dep(P). 2.Thesetof(codesof)programsin \nPisrecursive,andwecan effectively compute the possible i* steps of running a program P 6 P on any input \nby asking a finite number of atomic questions about I. (Note we are allowing boundedly nondeterministic \ncomputations here). More formally, given a (code for) program P and i, we can effectively find a finite \nset of quantifier-free formulas Al, .,,, Ak with var(Aj) Q var(P) = {Yl,...yn} such that by knowing the \ntruth value of Aj in I,uo, we can effectively compute a finite number of sets of terms {{~l,...,~ }1 \nm = 1,2,...} over {a,b,f,g,yl,,.,ya} which represent &#38;e possible values of the variables in var(P) \nat the iti step of any trajectory in ~I(P) starting with rro That is, u is the i* step of such a trajectory \niff. for some m, U(yj) = Uo(kj) for J = L...n, and u(x) = Uo(x) for x ff var(P). We can also effectively \ncnmpute which (if any) of the sets {~l,...,~n} represent output values; i.e. whether there ]s some trajectory \n(uo,...,ui) in 5;(P) with for j = Ui(J j) = uo(~j) 1,...,n. 3. P is effectively closed under variable \nsubslituliong that is, given P C P with dep(P) = {x ~l,...,xim} and any set of m variables {YI,...,YJ \nwe can effectively find a program P C P such that dep(P) = {yl,...,ym} and (Uo,ul,...) ~ %(P) iff for \nsome (u~,ul ,...) E ~(p ) we have uj(xik) = uj (yk) fork = 1,..,,m. 4. P is effectively closed under \nflowchart operations, subroutine calls, and run time checks. To make this last notion precise, let P \nbe the least set of programs containing P such that if P, Q 6 P and A is a quantifier-free formula, then \ntbc following programs arc all in P. (Note that the programs in P will not necessarilybe in P. Ilcrc \nwill just be programs in P which simulate them.) 1,basicassignmentsx:=a, x:=b,x:=y,x:= KY),x:=g(y,z), \n2. ~Q, 3.ifA thenPelseQ, 4. while A do P, 5. run P until A, 6. after eachstep of P do all of Q. 7. \nbegin local Xii,...,xh; P end  We extend z CV, and dcp to P below. Given a trajectory r = (uo,...,uk), \ndefine firSt(T) = U. and laSt(T) = Ok; and for trajectories ITo and 71, define 70071 = ( O,@k,ul . ...) \nif TO = (%..,%), T~ = (O(,O1 ,.,.), and uk = Uo , undefined, otherwise. L If t is a term, CV(X:=t) = \n{x}; dep(x: =t) = {x} U volt); %(x: = t)= {(c,u[x/u])l u # 1, u(t) = u C dom(I)}. 2. cv(P;Q) = CV(P)U \nCV(Q);dep(P;Q) = dep(P) U dep(Q); ~(P;Q) = {70\u00b0T~l TO 6 f(p)> TI ~ %(Q)}  3. cv(if A then P else Q) \n= CV(P)U CV(Q); dep(if A then P else Q) = dcp(P) U dcp(Q) U var(AJ ~(if A then P else Q) : {TI (], fk(T) \nk= A, , 6 %(P)), or (I,first(r) 1= -A, r E %(Q))}  4. cv(while A do P) = CV(P); dep(while A do P) = \ndep(P) U var(A); ~(while A do P) = Ui>l~(Wi); where WO = ~, Wi+l = if A then P, Wi AC N&#38;)P, NOOP \nis the program which  has no effect T1(NOOP) = {(u)I u * 1], and w is the diverging program: %(Q) = \n{(u, J-)1 o # -L]; 5. cv(run P until A) = CV(P); dcp(run P until A) = dcp(P) U var(A); ~(run P until \nA) = {T ~ ~(P)l ~ = (uo,ul,...), and for all i, I.rJi 1= _rA} U {*I  r = (Oo,..,,Ok),7 is a prctix \nof some T C 7,(P), if i < k then I,ui 1= -A, and Uk = -1 or I,uk 1= A}. Essentially, we car think of \nrun P until A as inserting a test for A before every st:)~cmcnt of p. As soon as tic test is satisfied, \nfie computation halts. 6.cv(aftcreachstepofPdoallofQ) = CV(P)UCV(Q): dcp(iiftcr each step of P do all \nof Q) = dcp(P) U dcp(Q); If var(P) fl CV(Q) * 0, tbcn ~(aftcr each step of P do all of Q) = ~. (We consider \nafter cwh step of P do all of Q syntactically incorrect unless var(P) fl CV(Q) = @; thus we do not allow \nthe computation of Q to affect the variables of P.) If var(P) fl CV(Q) = 0, ~(after each step of P do \nall of Q) = {~1 ~ = (cr&#38;rsl,...) suchthatforsomesubsequenceu. <ail< ...<crikwehave 43 (JO = a. a. \nw b. last(r) = Oik c. ifrrij+l # -L, (ut+l,...,uij+~ 6 Z(Q) d. for some (UO ,UT ,.,.,uV ) 6 T,(P), \nwe have either  k= k or (k~ k &#38;rd u~k = J-), and uj (dep(P)) = uij(dep(P)) for all j~k. 7. cv(begin \nlocal xil .....xim. P end) = CV(P); ep(begin local xii,....x~m:P end) = dep(p). {Xii,,.,,x%}; %begnr \nlocaI xii,...,xim; P end) = {(uO,ul)o To(last(7),CJ uO[xil/a,...,xi /a], 7 C l(p), and 02 = al = laSt(7)[Xil/O~(Xi, \n),...,Xim /uo(xi )]]. (Thus the local variables xii,...,~ are set to #e constant value a when the block \nis entered,mand reset to their previous values when the block is exited.) Note that the programs in P \nstill satisfy constraints 1 and 2 above. Now we formally define P to be effectively closed under flowchart \noperations, subroutine calls, and nmtime checks if for all P E P and all interpretations I, we can effectively \nfind a Q C P which simulates P in I. That is, CV(P) C CV(Q), dcp(P) C dcp(Q), and for all r C %(P) (resp. \nI(Q)) with last(T)* 1 there exists a r E %(Q)(rfw %(p)), such that first(7)(dep(P)) = first(7 )(dep(P)) \nand iast(~)(dep(p)) = last(r )(dcp(P)). Tlnrs we only require of a program like after each step of P \ndo all of Q that it can be simulalcd by a program inP,possiblyusingsomeextravarioblcsasflags.lt iseasytoseethat \nflowcharts, PASCAL, ALGOL, and almost any ALGOI.-likc language will :ill constitute acccpthlc progmmming \nLmguagcs. Our definition of acceptable progranhng language seems to coincide with the rather vague definition \ngrv:tr in Lipton ~i77]. In any case, as we shall see below, it certainly gives us languages which are \nsufficiently rich to contain all the programs required by Lipton to prove his results. But for our stronger \nresults, we seem to require that our programming languages be acceptable with recursion, which we define \nto mean acceptable and effectively closed under (possibly recursive) procedure calls. To make this precise, \nwe use semantics similar to those of [Mi81]. Let plab = {Zo, Zl, ...} be some set of program labels \nand let P be the smallest language containing P, plab, and all the programs described above, such that \nif P E P and Z E plab, then pZ~] is a program in P. We extend z CV,and dep to P as follows: 1. CV(Z) \n= dcp(Z) = @ for all Z < plab; %(z) = ~(ti) = {(u, l)Iu # 1} for all Z 6 plab. 2. cv(pZ[P]) = dep(pZ[P]) \n= dep(p): ~(P z[pl) = Ui>o~(P1), where PO=P, and #+1 = P[Z/Pi] (i.e. we s~ntactically replace all jiree \noccurrences (where free and bound occurrence have the fhrnihr meaning) of Z in P by P ). Essentially, \npZ[P] acts as a least fixed point operator. Note that ~(while A do P od) = ~(pZ~f A then P;Z else NOOP]) \nFinally, we define P to be effectively closed under recursive cafls, (as WC1las flowchart operations, \nsubroutine calls, and rrrntime checks) if for every program P E P and interpretation I, there is a program \nQ C P which simulates P in I in the sense defined above. (The observant reader will have noticed that \nwc have not dealt with issues such as the copy rule and naming conflicts between global and local variables. \nBut since we only require that every program P E P with the semantics that wc have giwr can be simulated \nby some program in P whatever the semantics of P are, such problems will not concern us here.) A program \nP is de/ern/i~/i~zic iff for all valuations u there is at most onti trajectory 7 E %(P) with first(r) \n= u and last(?) * 1. The programming language P is cfctcnninistlc ifi all programs P E P are. 2.3. Partial \nCorrectness and Termination We expand the ty~e 2 to 2P by adding. for each P E P, a predicate symbol \nAp of arity 2k, where k = ldcp(P)l. In any interpretation I, I * Ap(U,V) iff for some trajectory (Uo.....uk) \nE %(p) with uk # 1. we have uo(dep(P)) = u and uk(dep(p)) = v. (Note we use italics to indicate a vector \nof variables.) Thus Ap defines the input-output semantics of program P. We say P halls on input u (in \ninterpretation 1) if there is a trajectory ~ E rI(p) such fiat first(7)(dep(p)) = u and last(r) * 1. \nOtherwise we say P diverges on input u. A (jirst-order) partial correctness (resp. ferminution) assertion \nis a triple U{P}V (resp. U<P>V) where U and V are first-order formulas (over ~) and P E P. By definition \nII= U{P}V iff 11= VX,J{U(X) A AP(.UY) * WY)) Ii= U<P>V iff 1k= VX3J(U(X) * AP(X,Jl A V(y)) lIUS I * \nU{P} V (resp. U<F2V) iff, if U(x) then for all (rcsp. some) y which are possible outputs of p on input \nx, wc have J J==V(y). Note ckrat in the case of deterministic programs, total correctness and termination \ncoincide. 2.4. Expressiveness An interpretation 1 is weakly expressive for P iff for every P C P there \nis a formula BP (of type 2) such that IF= BP(.x) iff 1 * Z.KAP(.C,Y)) Thus I != BP(x) iff there is a \nhalting computation of P on input x. Note that we do not assume wc can effectively find such a III,; \nonly that it exists. In Dijkstra s terminology [1X76], 1]), corresponds to the weakest prccmrdition of \nP.with respect to true, or the negation of the weakest libcml precondition of P with respect to-false. \n2.5. I!xpressive-Herbrandand Expressive-Zffective Interpretations An interpretation I of type X is eflecfively \npresen[ed if there is a tuple of integers pres(I) = <n~om,na,nb,nf,n9nAo>, where ndom is a code for dom(I), \na recursive subset of X (the integers), na, nb 6 dom(~) are the interpretations of a and b, and nf, ns, \nand nAo are codes for recursive functions and predicates of the right anty which interpret L g, and A. \nrespectively. I is Herbrand dejkable iff for all i E dom(I), there is a term t in the Herbrand Universe \nof {a,b,f,g} such that 11= t = i. Finally, we say an interpretation I is expressive-Herbrand with respectto \nprogramming language P iff it is weakly expressivefor P and either Herbrand definable or finite. I is \nexpressiveeflecfive if it is wreaklyexpressiveand either recursively presented or finite.  2.6. Strongly \nand Weakly Arithmetic Interpretations I is said to be strongly uri(hmetic if there exist first-order \nformulas Z(x), S(x,y), A(x,y,z), and M(x,y,z), and a bijection ~: dom(I) -+ N such that 1. I i= Z(x) \niff ~(x)= O 2. I b S(x,y) iff q(x)+ 1 = ffr(y) 3. 11= A(x,y,z) iff rp(x) + T(Y) = rp(z) 4. 11= M(x,y,z) \niff T(X) X rp(y) = rp(z)  Note we do not assumethat we can find Z, S; A, M effectively. I is weakly \narithmetic if we can find first-order formulas N(x), F~.x,y),Z(x), S(.x,y),A(.x,y,z), and M(x,y,z) (with, \nrespectively, k, 2k, k, 2k, 3k, and 3k free variables for some k) such that E defines an equivalence \nrelation cm dom(l)k, and if [x] = {y C dom(l)kl I 1= E(x,y)}, there is a bijcction v: {[x] I 1 l== N(x)] \n-+ X such that conditions 1-4 ahovc hold (when restricted to N) with [r] rcj>lacing x as the argument \nto rp. (Thus, for ex~ple, con~ti~n 2 becomes 1i= N(X) A N(y) A S(X,Y) iff P(lxJ + 1 = ?(M).) Thus the \nnatural numbers are embedded in a weakly arithmetic interpretation as equivalence classesof domain elements, \nwhile in a strongly arithmetic interpretation, every nsttural number corresponds to some distinct domain \nelemerk 3. Main Results 3.1. Statements of Theorems With all these definitions in hand, we can now state \nour main theorems precisely: Theorem 1; Let P be a deterministic, acceptable programming language with \nrecursion. Then the following areequivalent 1. P has a decidable halting problem for finite interpretations; \n(i.e. there is an effective procedure which, when given I with dom(l) finite, a program P E P with ldep(P)l \n= k, and u E dom(l)k, decides if P halts on input u in domain I.) 2. There is an effective procedure, \nwhich, for expressive-Herbrand interpretations I, will decide which tirst-order partial correctness (resp. \ntermination) assertions are true in I what given an oracle for TMI). Thus the set of first-order partial \ncorrectness (resp. termination) assertions true in I is unl~omrly recursive in Th(l) for cxpressive-Herbrand \ninterpretations L  Moreover, even wifhou( the assumption that P has a decidable halting problem for \nfinite interpretations, wc can show that the set of first-order termination assertions true in I is uniformly \nr.e. in Th(l ) for expressive-Hcrbrand L Similar techniques allow us to prove a variant of this theorcm. \nBy exchanging Hcrbrand definability for cffccti!e presentation, we can drop the assumption that the \nprogramming kmgoage allows recursive tails, but at the price of losing uniformity. Thrsswe get Theorem \n2: Let P be a detmninistic, acceptable programming language, Then the following are equivalent 1. P has \na decidable hahing problem for finite interpretations. 2. The set of first-order partial correctness \n(resp. termination) assertions true in I is recursive in <pres(I),Th(I)> if I is expressive-effective. \n Moreover, the set of first-order termination assertions true in I is r.e. in <pres(I),Th(I)> for expressive-effective \ninterpretations I. By way of contrast, Lipton showed (in [Li771): Theorem (Lipton): Let P be a deterministic, \nacceptable programming language. Then the following are equivafen~ 1. P has a decidable halting problem \nfor finite interpretations. 2. The true quantifier-free partial correctness assertions are uniformly \nr.e. in <pres(I),Th(I)> for expressive-effecti4e interpretations I.  Lipton s proof only showed how \nto enumerate the true partial correctnessassertionsof the form /rue{P}J71se.Iiowever, note that 11= A{P}B \niff 1 != oue{if 7A then Q; P; if B then u]~ulse (recall Q is the program which always diverges). Moreover, \nif A and B are quanti ficr-free, this modified program (or one that simulates it) is in P. Thus it is \neasy to extend Lipton s proof to quantifier-free partial correctness assertions. But this trick does \nnot extend to first-order formulas. If A is first-order, then the program (if =,1 then u) cannof in general \nbe simulated by a program in an acceptable programming language, since the simulating program would violate \ncondition 2 of Definition 2.2. Thcorcrn 1 uscstic fbllowing Icmma, which is interesting in its own right \nand iuyiin garcralizcs om! of l.ipton s rcsuhs: I.cmmu 1: If P is i]~~~p[;]blc with recursion and 1 is \nexpressive-Herbrand with respect to P hen either: 1. I is strongly arithmetic, or 2. VPCP3n(P reaches \nat most n distinct valuations in any computation) (i.e. for all 7 E T(P), {Oil Ui C T} has ~ n elements). \n We will abbreviate condhion 2 of the lemma by (~) since we refer to it so often below. Lipton proved \nthe same result with acceptable with recursion replaced by acceptable , expressive-Herbrand replaced \nby expressive-effective , and strongly arithmetic replaced by weakly arithmetic . However we can actually \nget a stronger result. As a corollary to the proof of Theorem 1, we will show that if I is strongly arithmetic \nand expressive-Herbrand, we can ejlecfive[y jrrd the formula s which make I strongly arithmetic. We will \nrederive Lipton s result in the course of our proof of Lemma 1, and use it in proving Theorem 2. 3.2. \nProof of Theorem 1 The fact that (2) -(1) in the first half of Theorem 1 was proved by Clarke [C176/79]. \nThe proof in fact goes through under much weaker hypotheses: P does not have to be acceptable or deterministic. \nTo prove the remainder of Theorem 1, we will describe five effective procedures, Ml, .... MJ When given \nan oracle for I%(I) of an expressive-Herbrand interpretation I each of thcm outputs first-order partial \ncorrectness or termination assertions, or their negations. They arc all sound thatis.awrtionisisinL If \nIis w which outputtrUC strongly arithmetic, then M, is corrurlefe for Partial c~rrcctness assertions; \nthat is, it outputs U{P}V or 7U{P}V for each partiaf correctness triple, depending on whether it is true \nor false in L Similarly, M2 is complctc for termin:ltion assertions if 1 is strongly arithmetic. If P \nhas a dccidabic halting prublcm for finite interpretations and (~) holds, ~CTI I~f~ (rcsP. M4) is comPlcte \nfor partial corrccmess(resp. terminatmn) asscrtior,s. Finally, MJ is similar t J M4, but it just enumerates \nall the true terti.fiation assertions UC9V if (~) holds (but not the negations of the false ones), and \ndoes not require the assumption that P has a decidable halting problem for finite interpretations. Theorem \n1 then follows from Lemma 1 (which we will prove below). To decide first-order partial correctness assertions \nwe run Ml and M3 in parallel. To decide first-order termination assertions we run M2 and M4 in parallel. \nTo enumerate first-order termination assertions without the assumption that P has a decidable halting \nproblem for finite interpretations, we run M2 and M5 in parallel. 3.2.1.Construction of M, andM2 Consider \nthe following set of axioms for arithmetic: AXL -(s(x) = O) AX2. S(X) = S(Y)-x= Y AX3. x+O = X AX4. X+ \nS(y) = S(x+Y) AX5. Xxo= o AX6. Xxs(y) = Xxy + x AX7. -(x<O) AX8. X<s(y) = (X<y v X=y) AX9. X(YVX= yVY(X \nOf course, these do not constitute a complete set of axioms for arithmetic. However, an interpretation \nwhich satisfies these axioms has a standard part (cf. [SH67]), consisting of those elements in the domain \nof the form Sk(0) for some integer k. In general there is no first-order formula which defines the standard \npart, but under certain stronger hypotheses,we will show that it can be defined. First we inductively \ndefine an encoding of Herbrand terms of type z: ral =0 Finally we need rbl =1 rft=2 rg7 =3 r[t)l = <rfl,rtl> \nrg(t,u)7 ~ <rgl,<rtl,rul>> where <> denotesthe pairing firnction <x,Y> = %(x+ Y)(X+Y + 1)+x, Let H be \na binary predicate symbol (whose intended meaning is H(x,d) iff x is the kmcoding of a Herbrand term \nequal to d) and consider the following encoding axiom, which we abbreviate by Eric: Vx,d[H(x,d)s (x=ral \nAd =a)V(x =rbl Ad =b) v (3y,c(Pr(x,rfl,y) A H(y,e) A d = f(e)) V (3y,dl,d2,zl,z2(Pr(x, rg7,y) A (Pr(y,zl,zJ \nA H(zl,dl) A H(zfid2) A d = dtfl,d$l where Pr(z,x,y)s Y<ZA X<ZA z = %(x+ Y)(X+ y + 1)+ x We now show \nH works right on standard elements: Lemma 2: If I satisfies AX1-9 and Enc. then I != H(Sk(0),d) iff k \nia the encoding of a Hcrbrand term whose value in I is d. Proof By induction on k. ~etails appear in \nthe final paper. Now we show how to use H to define the standard part in a nonstandard model of arithmetic. \nLemma 3: If 1satisfiesAX1-9 and Enc. then Std(x) -3dVz(H(z,d) * x <z) defines the standard part of L \nProofi We begin by showing that the nonstandard elements, if there arc any, come after all of the standard \nelements in the ordering<. That is, if x is standard and y nonstandard, 1 1= x<y. This in turn is provcc! \nusing induction on k to show that if y is nonstandard, then 11= Y(Y<Sk(0)). The desired result then follows \nimmediately by AX9, The biisc case nf the induction is just AX7, and the inductive step follows using \nAX8, the inductive hypothesis, and the fact that we cannot have y= Sk(0) since y is nonstandard. \\ Je \nwill now show that 11= Std(x) iff x is d standard element. If x iS standard, lemma 2 implies that Std(x) \nholds. Because dom(I) is infinite, for any standard x there exists an element d all of whose encodings \nare greater than x. For this d, I + Vz(H(z,d) ~ x<z), because if z is either a standard value encoding \nd or a nonstandard value, it must be greater than x. Thus I 1= Std(x). On the other hand if x is nonstandard, \nthen for every d E dom(I), there exists a standard encodtng z of d such that I 1= H(z,d) A =(x<z). Therefore, \nI &#38; _lSM(x), Lemma 4: Suppose we can effectively find formulas Z(x), S (x,y), A (x,y,z), and M (x,y,z) \n(of type X) which make I strongly arithmetic. Then, for eachP C P, we can effectively find a formula \nAP of type X which is equivalent to AP in I. Proof Deferred to the final paper. Now we can define M, \nto decide partial correctness assertions. It systematically guesses formulas Z (x), S (x,y), L (x,y), \nA (x,y,z), M (x,y,z), and H(x,y) and checks (by consulting its oracle for Th(I)) that z defines a unique \nelement of I (i.e. I * 3x(~(x) A VY(-?IY) * Y= x)), S , A and M detioc functions (i.e. 1 1= VX3Y(S (X,Y) \nA VZ(S (X,Z) -y= z)), etc.), and that AX1-9 and Ezrchold in I when written in terms of these formulas. \n(For example, AX2 becomes (S (x,z) A S (Y,Z))~ x= Y.) Now using these formulas, wc can define Std(x) \nas in Lemma 3, and check if 11= Vx(Std(x)). If not, their Ml continues grzcssing. But if Vx(Std(x)) doci \nhold in I, then we have effec(ive~ found the formulas which make I strongly arithmetic, and the hypotheses \nof Lemma 4 arc satisfied. Then for every pair of tirst\u00adordcr formulas U, V and wry program P E P, Ml \nconstructs the formula PCu,p,v: VX,J{U( .X)A AP (X,J])* WY)) By consulting the oracle for l h(l), Ml \ncan tell if this formula is true in I. lfso, Ml outputs U{P}V; otherwise it outmm 7U{P}V. From Lemma \n4, it follows immediately that Ml is sound. And if I is strongly arithmetic, M, will eventually find \nfirst-order formulas Z , S , L , A , M , and H which satisfy all the conditions, and hence will also \nbe complete. (Here we are using the fact that the formula H is definable in strongly arithmetic domains. \nThe construction is straightforward but technical, using coding of sequences, and is omitted here.) For \ntotal correctnessassertions,M2 proceedsjust asJ#l, but instead of using PCU,P,V it usesTu,p,v: VX3J(U(X) \n* Ap (x,y) A V(-Y)) I Note dzat in constructing Ml and IU2 we did not need the foil strength of the assumption \nthat I is strongly arithmetic. We could have weakened it to I is weakly arithmetic and there is a formula \nH which satisfies (Eric) . In this case, we would also have to guess a formula N(x) for natural number, \nand formula E(x,JJ)for equivalence. AX1-9 would also have to be appropriately modified to restrict everytldng \nto N. For example, AX2 would read: A<K,cj(x) such that N(x) A W) A N(z)=+ [WLY) A s(w) + E&#38;z)] 11= \nA<K,C~(u) iff I is isomorphic to <K,c> on IM(~) We also would also have to include axioms to check that \nE is an equivalence relation, and that N, S, and Z interact correctly. Tln.rs we wou!d also have to check \nthat the following two formulas held in I: E(w) A (F{XJ) * Ffi,-x)) A (E(-x>Y)A W,z) * E@)), (Z(x) -N(x)) \nA ((N(x) A S(X,Y))~ NW). 3.2.2. Construction of M3, M4, and MJ We extend the techniques of [1.i77] to \nthe first-order case. Given an interpretation I, M C Al a program P C P with dep(P) = <U1,...,u~l 6 dom(l)k, \nwe make the following x = xii,...,Xik), and ~ = definitions: 1, UM(X) = {terms ofdcpth ~ M ovrr {f,g,a,b,x}}. \n2. IM(u) = {values obtained by substituting uj for xij in the terms of UM(x)}. 3. KM = {domains of size \n~ N, where N = 1+ 11-f~(.x)l}We also assumeeach K E KM has one distinguished element A. 4. PM(x) is \nthe program which actsjust like P(x) except that on input u it halts at any valuation u such that u(y) \n@IM(u) for any y C CV(P). PM is just  run P(X) until -T[Ay~a(P)(VLCuM(xp = t)]. If y E CV(P),T = (UO,U1,...) \nC Z(P), and On(y) is the k* distinct valuation in T, then it is straightforward to show using condition \n1 on acceptable programming languages and induction on k that on(y) C Ik(uo(x)). From this observation \nwe get Lemma 5: (Lipton ~i77]) If(~) holds in I, then there exists an M such that for all y E CV(P),all \nT C $(P), and all n, we have Un(y) 6 IM(u~(x)), We say that I is isomorphic o <K,c> on TM(u) (where K \nE KM and c E dom(K)k) iff there exists a map ~: IM(u) -+ dom(K) -{A} such that L l(ui) = ci, for i = \n1,...,k. 2,1 != Ao(tl,t2) for tl, t2 C IM(u) iff K * AO(44t1),t(t2)). 3. If tl f IM(u) and f(tl) @ IM(u), \nthen K 1= Ky(tl))= A. Similarly for g. 4. Iftl, f(tl) E I@), then K t= fl$(tl)) = +(f(tl)). Similarly \nfor g.  Note that tlhere are only finitely many pairs <K,c> for a given M. Moreover, for each such pair \nwe can find a tirst-order formula Call a pair <K,c> diverging if PM(x) diverges when run in interpretation \nK on input c, Call a pair clean!v hcr//ing if PM(x) halts with output d when run in interpretation K \nurr input c, and no ~= A. Let U<K,,>be the vector in IM(~) corresponding to d. It is easyto check that \nif<K,c> is diverging and I ~ A<K,C>(~),then P diverges in I on input u. If <K,c> is cleanly halting and \nI k= A<K ,>(u) men I # AP(u,u<K,C>). Thus we define the two first-order sentences ~M,(J,f+i VX{U(X)= \ndiv,@@<K,c>(x) (V<K,C>v V<K,C>~]eanlyhalting(A<K,~>(x)A (X<K,C>)))I  FPC M,PJJ, : ~x[u(x) A V<K,c>cleanly \nhalting (A<K,,(x) A lWX<K.C>))l M3 proceeds as follows. For each M, U, P, and V, it constructs the sentencesPC \nM,U,p,v and Fp~M,p,U,~ This can be done effectively. By assumption the halting problem is decidable for \nfinite interpretations so we can effectively find all the diverging pairs <K,c>. (Note we do not need \nthe halting problem to be decidable to recursively enumerate the cleanly halting pairs. BY condhion 2 \nof acceptable programming language we can simply simulate PM on input c in interpretation K simultaneously \nfor each pair <K,c>. Eventually we will find all the cleanly halting pairs, although we will not know \nwhen we have found all of them.) If (by consulting its oracle for fh(I)) &#38;fj discovers that PC M,U,P,V(rcsp. \nFpC M,P,u,V) holds in I for anY M> it outputs U{P}V (resp. _IU{P}V). The procedure is sound by the comments \nabove, and complete if(~) holds for I by Lemma 5. Md is identical to Mj but replacespC M,u,P,v and Ff \n~M,p,U,V by M,U,P,V: VXKJ(X) = A V<K,C>cleanlyhamE(A<K.c>(X) A (X< K,C>))I ~M,U P,V: ~x[U(X) A (V<K,c> \ndiver6in/<K,c>(X) v <K.c>c]canlyha]ting(A<K,c>(X) A lV(X<K,.>))] Finally, for Jffi note that wc do not \nneed drc assumption that the hahing prob]cm is dccidablc for finite intt rprctatiorrs to compute T M,U,P,V, \nsince we only need the cleanly h:d!ing pairs <K,c> and not ti,e diverging pairs. Thus &#38;fj starts \nsimulautg PM on input c in interpretation K simultaneously for each pair <K,c>. Every so often it discovers \nthat another pair <K,c> is cleanly halting. Let J be those pairs which it has so far discovered to be \ncleanly halting. hf5 checks if IF= V@(x) * V<K,c)tCJ(I&#38;JX) A WK,JI begin local inil, x< x Ifso,itoutputsU<P>V. \nBythesameargumentsasaboveM5issound, and it is complete if(~) holds in I. Note that we cannot effectively \nfind all the pairs <K,c> which are diverging, but we do not need them to enumerate the true termination \nassertions. 3.2.3. Proof of Lemma 1 Assume that (f ) does not hold for I. Then there is some program \nP C P with dep(P) = x such that card(<P(.x)>)is unbounded; i.e. for all M there exists r C ~(P), T = \n(uo, al, ...) such that{ui(~)lui67} has at least M distinct elements. We show how to define programs \nwhose weakest preconditions (the BP of Definition 2.4) define the formulas necessarytomakeIarithmetic. \nO~rinitial stepsarcmuchlikethoseof Lipton. We use his technique for representing integers in I and show \nhow to write programs that perform arithmetic operations on this notion of integer. However, we go much \nfurther than Lipton in that we usc these primitive programs to write more complicated programs, and ultimately \nto construct a program which translates the encoding of a Herbrand term into its corresponding value. \nThe programming details are themselves interesting. It turns out that under this representation of integers \nwc can compute a predecessor function, but no successorfunction. But we can compute a houndedsuccessorftmction. \nand that is sufficient for our needs. In the constructions below, wc assumefor caseof exposition that \nP = P , so that programs Iikc after each S(CPof P do all of Q really arc in P. In gcncml, of course, \nwc would IMVCto replace the programs below by the programs in P which sirmhtc thcm. We write P(x) to \nindicate dcp(l)) = x. P(). )isjust PwiLhthevaliablc x sutrstilutcd forx. We first construct a program \nQ(x) such that if we run Q(x) on any i]pu~ x takes on the same values as whe~, we run P(x) on the same \n.. inpu~ but without repetmon; I.e. lf ~ = (uo, al, ...) C %(P) and # = (u~, U1 , ...) E %(Q) with U. \n= u~ then {u;(x) I i>O} = {Ci(X)l i>(l} and if ~~(x) = Uj (.r) for i<j, then u~(x) = u;(x) for all k, \ni~k~. Essentially this is done by keeping track of the initial and current values of x, and then running \na copy P with input the initial value and looking for the next new value it reaches after the current \nvalue (see [L177] for more details). The code for Q(x) is given in Figure 3-L init: = x; x := x, after \neach step of P(x ? do all of R(x,x~Y,in@; end where R(x,x ~y,init) is the program if x # x then begin \ny:= inic run P(y) until (y = x V y = x); ify = xtbenx:=-x~ end Figure 3-1: The program Q(x). The pair \nx = (X1,X2)will represent tie integer k iff X2 is r-bekh distinct value reached by Q on input XP We write \n[x] = k to indicate fiat the pair x = (X1,X2)represents k. Choose two Herbrand terms tt and ff which \nget distinct values in I, to represent owe and false respectively. Then using Q it is straightforward \nto write programs which meet the following specifications. (1) CHECKING: hahs with x unchanged if x represents \nan iutcger; otherwise CHECK INT will diverge. (2) ~Q(J ,y,allS): if x and y do not both rcprcscnt integers, \nHQ wiB  diverge. Olhcrwisc EQ will terminate with x, y unchanged and ans= tt if [x] = ly] ff otherwise \n (3) LESS(x,y,ans): if x and y do not both represent integers, LESS will diverge. Otherwise LESS will \nterminate with x, y unchanged and ans= tt if [x]< ~] ff otherwise  (4) NUMk(x,ans): if x doesnot correspond \nk an integer NUMk will diverge. Otherwise, NUMk will terminate witi x unchanged and  ans= tt if[x] =k \nff otherwise  The idea for computing EQ(x,y,ans) is to compute the successive values reached by Q starting \nfrom x, and yl and check that we reach X2 andy2atthesametime. (Recallthatweassumexisoftheformxl, X2 and \nlikewise y.) We give the code in Figure 3-2; the codes for CHECKINT, LESS, and NUMk are similar and will \nnot be given. CHECKING; CHECKINT(y); begin local u, v, u , v ; U;=xl; V:= y,; while u * X2V v# Yzdo \nbegin u := u; v := v: t3NEMORESTEPQ(xl,u ,U); ONEMORESTEPQ(Y1, V ,V); end; ifu=x2A v=y2thrmans:= ttelseans:=tl \nend ONEMORESTEPQ(X,Y,Z) computes z such that [AZ] = [x,Y1 + 1: hcgiu local flag; flag:= X Z:=y.; run \nQ*@,z,flag) until (flag = tt A y * z); end where Q*(-v,z,flag) is ~ftcr,::ic}) stL,l)O(Q(2) do uII Of \n(if: = j, then flag : = tt). l igrm 3-2: lhc program FQ(x,y,ans). In more detail, the program works as \nfd 10WS. The initial calls to C .lECKINT check that x and y are integers, and diverge otherwise. We get \nONEMORESTEPQ(X,Y,Z) by using Q*(-v,z,flag) to compute successive values taken on by z when we run Q(z) \nstarting with x, setting flag to tt when y = z, and then continuing the computation one more step. In \ngeneral, it does not seem possible to construct a program SUC(X,Y) which will compute a y such that ~] \n= [x] + L If [x] = k, it may be the casethat only k distinct elements of dom(l) are reachable from XI \nby the program Q. The program ONEMORESTEPQ above only worked because at the point when it was called \nwe were guaranteed that a next element existed. However, it is possible to generalize this idea and construct \na bounded successorprogram, as well as the bounded addition and multiplication programs described below. \n(4) SUC(b,x,y,ofl): if b, x, and y do not all initially represent integers, SUC will diverge. Otherwise \nSUC will terminate with b, x unchanged and ~]= [x] + Lofl = K if[x]<[b] Ofl = tt if[b] ~ [x]  (6) \nADD(b,x,y,z,ofl): if b, x, y do not all initially represent integers, ADD will diverge. Otherwise, ADD \nwill terminate with b, x, y  unchanged and [z] = [x] -t M, ofl = ff if[xl + [Y]< [b]; Ofl= tt if[b]<[x]+ \n~] (7) MULT(b,x,Y,z,ofl): similar to (6) above except mat [z]=[x]X~], otl = ff if[x] X~]< [b] Ofl=tt \nif[b]<[x]X~]. 1 hc code for SUC(b,x,y,Ofl) is given in Figure 3-3. Tbc idea is to initialize y to b \nand then increasey (using ONEMORl?SFEPQ) until x < y. The code for ADI) and MUI.T is straightforward \nto write using Sb-C and is omitted here. It is, however, kIIf50rLlIrt to ensure that no intermediate \ninteger value ever exceed the alue determined by b. begin local ans, y ; LESS(x,b,ans); if ans = ff therr \nofl := tt elsehegin YI := bl; y~ := bI; while ans = ff do begin Y : = Y2: 0NEMOREST~@l,y ,y2); LESS(x,y,acts); \nend; end; end Pigure 3-3: The program SUC(b,x,y,ofl). By slightly modifying the programs written above \nso that they compute predicates instead of functions (e.g. we would modify ADD so that it halts on input \nX,Y,Ziff [z] = [x] + ~]) and taking weakest preconditions we could already define formulas N, Z, E, S, \nL, A, and M which satisfy Definition 2.6. We note that none of the above programs required recursive \ncalls. Thus it follows that if (f ) does not hold, P is an accephble programming language (but not necessarily \nacceptable with recursion), and 1is expressive-Herbrand or expressivc\u00ad effective with respect to P; then \n1 is weakly arithmetic. This is exactfy Lipton s result. But we require more; we need a formula H which \nsatisfies the axiom (Eric). We get H by using the programs defined above to construct a program HRBD \nwhich relates the encoding of a Herbrand term as an integer to its corresponding value. We use the encoding \nof 1ierbrand tcnns described in 3.2.1. The formal specification for HRBD is given below, (8) HRBI>(x,cnc,d): \nif x dots not rcprcscnt an integer, HRBD will fail to tcnninate. Otherwise, fill IN) will terminate with \nx unchanged and enc = tt, d = h (in I) if [x] encodes flerbrand term h, cnc = ff otherwise Thus, for \nexample, if [x] = rf(a)l (= (2,0) = 5), then atler the pHPegin execution of HRBD(x,enc,d), we will \nhave enc = tt and d = f(a). Note that a true pairing function cannot be programmed using the above techniques. \nGiven only x and y, it is not in general possible to compute z with [z] = <[.x],~]>, since the value \nto be computed will be larger dran both of the input values, The corresponding projection function, on \nthe other hand, is relatively easy to compute and is sufficient for programming HRBD. Thus we need a \nprogram PR which satisfies (9) PR(z,x,y): if z does not represent an integer, then PR diverges. Otherwise, \nPR will terminate with the final value of z unchanged and the final valuesof x and y will satisfy the \nrelationship M = 4([~1 + b]) ([xl+ b] + 1) + [X]c The program for PR simply tests all [x], ~] ~ [z] until \nit finds [x], Lv] which satisfythis relationship, It usesthe identity 1+2+ ...+(n 4-m) = %(n + m)(n + \nm + 1) to ensure that no intermediate value for the right choice [x] and ~] exceedsthe initial value \nof [z]. The code for PR will not be given; the code for HRBD is given in Figure 3-4. A straightforward \nmodification of HRBD(x,enc,d) gives us HRBD (x,d) which halts iff d is equal to the Herbrand term encoded \nby x. Now, by raking weakestpreconditions, we can already show that I is weakly arithmetic and has a \nformula H which satisfies Enc. AS we remarked in 3.2.1, this would already be crrotrgh to enable us to \ndefine the procedures Ml and M2 and prove our main theorem. However, with a little more work, wc can \nshow that I is strongly arithmetic. List the kmns in the Hcrbriurd universe (of {a,b,f,g}) in order of \nincreasing encoding: a, b, l(a), Nb), g(a,a),,.... Using this encoding and our old wry oflooking at tuplcs \nin dom(l) as integers, we,can define a new way of looking at tuplcs in dom(I) as iltegers. We use the \nnotation [v] to contra<t with the [v] used before. Define [v] = m, if, for some k: 1. [V]= k, 2. k is \nthe encoding of some Herbrand term t (i.e. rtl = k), 3. there is no term t with rt 1 < k such that 1 \n!= t = L 4. the Herbrand terms t with I_t 1 < k take on m distinct values in L  If the conditions \nabove do not hold, then [v] is undefined. local ini[, ans,ficl arg, frrg{ arg { i: inil: = K enc: = tt \n NUMra-@,ans); ifans = ttthen cl:= a else begin NUMrb7(x,ans); ifans= ttthend: = b else begin PR(xJ?d,arg~ \nNUMr ~-@7, ans~ if ans =, tt then begin x:= arg, H; d:= fid); x:= inil; end; else begin NIJMrg@f,~s); \nif arts = tl then begin PR(arg, arg: arg ); x:= arg ; H; d :=~ if cnc = tt then begin x:= arg ; H; d:= \ng(d , d); end; x:= ini~ end; else enc: = ~, end; end; end; end] Figure 3-4: The program HRBD(x,enc,d). \n For example, suppose drat in I we have a = fla), but a, b, and f(b) are all distinct. It is easyto check \nthat ra 7 = O,rb 7 = 1, r~a) 1 = S, rf(b) 1 = 8. fhus, if[vol = 0, [VII = 1, [V21 = 2, [V31= 5, [v41 \n= 8, then Ivo] = O, [vl] = 1, [}>] is undefined, [V3] is undefined (since there is a Herbrand temt, r!mmely \na, with ral < rf(a)l but I 1= a = f(a) by assumption), and [vf] = 2. We can use this listing of Herbrand \nterms to define a bijection V: dom(I) -+ N. For u E dom(I), p(u) = miff, if t is the first term on the \nfist such that I 1= t = u, then m different values are taken on by the terms on the list before t. So \nin our example above, ~(a) = 0, q(b) = 1, cp((f(b)) = 2. Since I is Fferbrand definable (by assumption) \nand has an infinite domain (otherwise (~) would hold), ~ is indeed a bijection. his not hard to define \nprograms similar to the onesabove Which do arithmetic on this notion of integers. Wc can chcn usc their \nweakest preconditions to show 1 is strongly mithrnetic. WC leave dctiils to the full paper, This complctcs \ndrc proof of 1cmma 1, and with it the proof of Ilcorcm 1. 3.2.4. Remarks We have used two of our hypotheses \non P --that P is deterministic and that P allows recursive procedure calls --in a weak way, In particular, \nnote that the construction of Ml, M2, and J{J are unaffected if P has nondetenninistic programs. For \n&#38;fj and A44to work in the presence of nondeterministic programs, we need to strengthen the hypothesis \nrhat P has a decidable halting problem for finite interpretations to P has a decidable input-output relation \nfor finite interpretations ; i.e. if I is finite, then for all P E P, we can decide for which u, v C \ndom(I) we have I 1= Afiu, v). Note that the two hypotheses are equivalent if P is deterministic. It \nis only in the proof of Lemma 1 that we really needed determinism, because we needed to know that if \n(f) does not hold, then there is a deternrinis[ic program P such that card(<P(.x)>) is unbounded. Butoncethepresenceofonesuchprogramisguaranteed, \nthe programming language could certainly have other nondcrwrrrinistic programs. Similarly, the only \nplace in which we used recursive calls was in the construction of the program HRBD of the previous section, \nwhich in turn was necessaryto show that I was strongly arithmetic. We could remove this condition by \ninsisting, for example, that there be some program P C P and some x E var(P) such that if we run P on \nsome inpuJ u, x takes on every value in dom(I). In particular, under our assumption that I is Hcrbrand \ndefinable, having a deterministic program which would generate all the Hcrbrand terms would be a sufficient \ncondition to remove both of thesehypotheseson P. It is also worth noting tiat our decision procedures \nfor partial correctness and termination also extend to decision procedures for the full first-order \ndynamic logic (cf. [Pr76,Ha79]) of any acceptable programming language with recursion. 3.3. Proof of \nTheorem 2 By the comments made in the proof of Lemma 1, since I is expressive-effective, I is either \nweakly arithmetic or (~) holds. If(~) holds, then the procedures A43, A44, and 145 defined above work \nperfectly well in this casetoo. If 1 is weakly arithmetic, we show below that given tie formulas N, Z, \nS, A, M. and E which make I weakly arithmetic, we can effectively find a formula AP of type X (analogous \nto the formula AP of Lemma 4) which is equivalent to AP in I. Since I is expressive-effective, and hence \neffectively presented, it follows that Ap defines an r,e, subset of dom(I) *k C _ ~k (where k = ldep(P)l). \nThus by a well-known result of recursive function theory (cf. [Sh67]), given (the code for) P, we can \neffectively find a first-order formula AP* of number theory (i.e. over the type {0, + ,X, S}) such that \n.N 1= AP*(x,y) iff 11= AP(x,y). But by a straightforward syntactic translation using N, Z, S, A, M, and \nE, for any formula of number theory we can find a formula B of type Z such that I 1= B(z) iff ~-i= B(z). \nApplying this syntactic translation to the AP*, we get the desired formula Ap . Now we can construct \nMl and J4~ which are identical to Ml and M2, except they replace the A~ of Lemma 4 by the Ap constructed \nabove. Note this procedure is not uniform in L in contrast to Theorem 1, we have no effective way of \nfinding the formulas N, 2!, S, A, M, and E; all we know is that they exist. 4. Conclusions and Open Problems \nWe believe that this paper raises a number of open questions of both technical and philosophical interest. \nPerhaps the most important technical qucstimzsconcern to what extent the various hypotheses that wc rrscd \nin Theorem 1 can bc eliminated or rcplaccd by weaker conditions. In particular, the hypotheses Lhat the \nprogramming language bc deterministic and allow rccursivc calls do not appear cssclitial (cf. 3.2.4), \nand wc conjecture that our rcsuhs can bc cxtcndcd to a wider class of languages. On the other hand, the \nassumption of Herbrand definability, or something like it (perhaps the existence of a pairing function, \nso that sequencesof values can be coded up by one value) does seem necessary. Moreover, both Herbrand \ndefinability and effective presentability (used in Theorem 2) seem to be very natural conditions. The \nfirst fimits the values of the domain to those which can be effectively described, while the second limits \nthe interpretations to those which can be effectively described. A second open question concerns the \nrelationship between an axiomatization of the kind given by Floyd and Hoare (consisting of a finite number \nof axiom schemes),and a decision procedure of the sort provided by Theorems 1 and 2. In order for a decision \nprocedure to be a realistic analogue of a F toyd-Hoare axiom system, it should, in some sense, be uniform; \ni.e. independent of the particular interpretation tiat is being used. For this reason, Theorem 2 is \nperhaps not all that usefirl. But it still might have application when we have a fixed interpretation \nin mind. A third question concerns the relationship between the uninterpreted case considered in [MH80] \nand the interpreted case discussed here. It is interesting to note that termination assertions were shown \n(in [MH80]) to be somewhat more tractable than partkd correctnessassertionsin the uninterpreted case. \nThis leads us to our last point: the relationship between partird correctness and tcrrnination, and our \nability to find good axiom systems for complicated programming languages. One conclusion we can draw \nis that under the assumption that the halting problem is decidable for finite interpretations, partial \ncorrectness and tmrnination seem to have essentially the same complexity. However, for more complicated \ndeterministic programming Ianguagcs such as those discussed in [C176/79] which do not have a dccidablc \nhalting problem for tinite interpretations, twrrrinatiurr assertions, and hence total correctness asscrtiorrs, \narc effcctivclv axiornatizable. while ~artial correctness assertions are not, This suggests the use of \na tottd c!}~ectne$sproof $ystemwhich, unlike mcstcurrentIy available, does not require the establishment \nof partial correctness as an essential first step. References [C176/79] Clarke, E.M. Programming language \nconstructs for which it is impossible to clbtain good Hoare axiom systems. .L4CM 26:1, January, 1979 \nPh.D. Thesis, Cornell, 1976. [C078] Cook, S.A. Soundness and completeness of an axiom system for program \nverification. SIAM Journal on Computing %1, pp. 70-90, February, 1978. [Di76] Dijkstra, E. W, A Discipline \nof Programming. Prentice-Hall, 1976. [Ha79] Harel, D. Firs/-Order Dynamic Logic. Lecture Notes in Computer \nScience,68. Springer-Verlag, N.Y., 1979. [La80] Langmaack, H.A. Proof of a theorem of Lipton on Hoare \nLogic and Applications. Institut fur Informatik und Praktische Mathematik bericht 8003, June, 19g0. [L080] \nLangmaack, H.A. and E.R. Olderog. Present day Hoare\u00adlike systems for programming languages with procedures \nPower, limits, and most likely extensions. In: Proceed, 7th Conf, Automata, Lmrguagcs, and Programming, \nNordwijkcrhout 1980, Eds: J. W. de Bakker, J. van Leeuwen, LNCS 25, pp. 363-373, June, 1980, [Li77] Lipton, \nR.J. A necessaryand sufficient condition for the existence of Hoare Iogics. h s: 18th IEEE Symp. on Found. \nComp. Science, pp. 1-6, October, 1977. [Me78] Meyer, A.R. Notes on Lipton s generalization of the theorems \nof Cook and Clarke on expressiveness. Privately circulated notes. [MH80] Meyer, A.R. and J.Y. Halpern. \nAxiomatic definitions of programming Ianguagcs: a theoretical assessment. In: Proceed. 7th ACM Symp. \non Princip]cs of Programming Languages. pp. 202-212, .iamrary, 1980(to appear in .JACM). ~i81] Mitchell, \nJ.C. Axiomatic Definability and Completeness for Recursive Programs. S.IVLThesis. M. I.T., 1981. ~r76] \nPratt, V.R. Sernantical Considerations of Floyd-Hoare Logic. In: 17th IEEE SymP. on Found. Comp. Science, \nPP. 109-121, October, 1976. [Sh67] Shoenfield, J. R. Mathematical logic. Addison Wesley, 1967. 321  \n \n\t\t\t", "proc_id": "582153", "abstract": "For a wide class of programming languages P and expressive interpretations I, we show that there exist sound and relatively complete Hoare-like logics for both partial correctness and termination assertions. In fact, under mild assumptions on P and I, we show that the assertions true for P in I are uniformly decidable in the theory of I (Th(I)) iff the halting problem for P is decidable for finite interpretations. Moreover termination assertions are uniformly r.e. in Th(I) even if the halting problem for P is not decidable for finite interpretations. Since total correctness assertions coincide with termination assertions for deterministic programming languages, this last result unexpectedly suggests that the class of languages with good axiom systems for total correctness may be wider than for partial correctness.", "authors": [{"name": "Edmund M. Clarke", "author_profile_id": "81100393517", "affiliation": "Aiken Computation Laboratory, Harvard University, Cambridge", "person_id": "P74800", "email_address": "", "orcid_id": ""}, {"name": "Steven M. German", "author_profile_id": "81342495156", "affiliation": "M.I.T., Cambridge, and Stanford University, Stanford", "person_id": "PP43126312", "email_address": "", "orcid_id": ""}, {"name": "Joseph Y. Halpern", "author_profile_id": "81100537160", "affiliation": "Harvard University, Cambridge, and Stanford University, Stanford,", "person_id": "P149011", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/582153.582186", "year": "1982", "article_id": "582186", "conference": "POPL", "title": "On effective axiomatizations of Hoare logics", "url": "http://dl.acm.org/citation.cfm?id=582186"}