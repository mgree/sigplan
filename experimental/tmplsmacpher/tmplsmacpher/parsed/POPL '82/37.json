{"article_publication_date": "01-25-1982", "fulltext": "\n ON THE ABILITY OF STRUCTURES Adrienne Department of The University Iowa City, 1. Introduction Recursion \nis a control structure and, as such, it has been compared with other control structures, such as iteration, \nin terms of efficiency, facili tating proofs of correctness, and power. (Paterson and Hewitt, in their \nclassic paper introducing Comparative Schematology, established the valid\u00adity of the intuitive notion \nthat recursion is more powerful than iteration. ) Arrays are data structures and with the great interest \nin data abstraction, the results of com parative schematology which showed how certain data structures \ncould be used to implement other data structures (e.g. , see [1] and [2]) are of continued interest. \nIn [2], Constable and Gries compared these seemingly different types of structures, recursion and arrays \n, to determine their relationship in terms of functional power. The method of compari\u00adson was comparative \nschematology. *Work partially supported by a University of Iowa Old Gold Summer Fellowship. Permksion \nto copy without fee all or part of this material is granted provided that thecopies are not made ordistributed \nfor direct commercial advantage, the ACM copyright notice and the title of the publication and itsdate \nappear, andnotice isgiven that copying is by permission of the Association for Computing Machinery, To \ncopy otherwise, or to republisb, requires a feeand/or specific permission. @ 1982ACMO-89791-065-6/82/OOl/0366 \n$00.75 TO STORE AND ACCESS INFORMATION Critcher* Computer Science of Iowa Iowa 52242 1.1. Comparati~e \nSchematology Comparative schematology is a type of sche matic study initiated by Paterson and Hewitt \n[6] in the theory of program schemata. Program sche\u00admata deals with abstract programs called program \nschemes which, in general, are ALGOL-like and con\u00adsist of assignment , if-then-else , go to, and halt \nstatements. In progrsm schemes the domain and basic functions and predicates are left unspeci\u00adfied until \nan interpretation is applied to the s theme. Two program schemes are considered e quiv alent if and only \nif they halt with the same value for all interpretations. In comparative schema\u00adtology, typically two \nclasses of program schemes are considered where one class has a feature not available to the other. Any \ndifference in the two classes is then attributed to this extra feature. Definition: A class of progrsm \nschemes C is as powerful as a class of program schemes C, C<(! , if for every program scheme S6C, there \nexists an equivalent program scheme s EC . Definition: A class of program schemes d is equivalent to \na class of program schemes C , C=cj if C<c and c sc. , Definition: A class of program schemes C is strictly \nmore powerful than a class of program schemes C, C<c , if CSC and there exists some program scheme S \nC C for which no equiva lent program scheme exists in C. Definition: Two classes of program schemes C \nand C are incomparable if C $ C and C # C. 1.2. Comparison of Recursion and Arrays As s cated earlier, \nConstable and Gries [2] compared the control strut cure recursion and the data structure array using \ntechniques of compara\u00adtive schemakology. Recursion was allowed in a class of program schemes PR whose \nonly data structure was the simple variable. Parameters were transmitted by value. Arrays were allowed \nin a class of program schemes whose only control A structures were sequence and iteration. It comes as \nno surprise that Constable and Gries found the class as powerful as the A class when we consider that \nPA utilizes R one-way infinite arrays, We commonly chink of re\u00adcursion as being implemented via a pushdown \nstack which in turn can be simulated by an infinite array [2]. The functional leaftest was then used \nto show that , in fact, was not only as A powerful as, but more powerful than Leaftest R was first described \nby Paterson and Hewitt [6] and its behavior can be stated as follows: u(x) if there exists u6{r,l]* such \nthat p(u(x)) is true leafiest = { Lundefined otherwise where r and 1 are basic functions and p is a basic \npredicate. Leaftest requires a search for a domain element satisfying some predicate where the domain \nmay be thought of as a binary tree. Pater\u00adson and Hewitt claim that leaftest cannot be com\u00ad puted by \nrecursive functions using call by value based on the intuitive notion that recursive equa\u00adtions (using \ncall by value) can scan only a bounded number of nodes in the binary tree and an interpre\u00adtation may \nbe specified for which some crucial node does not get tested. Using this idea, we subse\u00adquently proved \nthis claim establishing that leaf\u00adtest cannot be computed by recursive functions transmitting parameters \nnot only by value but also by copy, value/result, or reference [3,4]. Constable and Gries specified \na program scheme in which computes leaftest. The ability of A infinite arrays to simulate recursion with \nparam\u00ad eters transmitted by value, the existence of a pro\u00ad gram scheme in A to compute leaftest, and \nthe inability of a program scheme in R to compute leaftest yielded the relationship of A being strictly \nmore powerful than R 1.3. An Analysis of the Comparison of Recursion and Arrays Constable and Gries \nfound Lhe class to be A more powerful than the class however subse\u00ad R quent works by Snyder [7] and \nLeinbaugh [5] pre\u00adclude us from concluding simply that arrays are more powerful than recursion (or that \narrays and iteration are more powerful than recursion). We are forced to take a closer look. The relationship \nPR <PA implies that there is a weakness in the mechanism c>f recursion, yet Snyder s work [7] shows \nthat the weakness lies not in the recursive mechanism as a ccmtrol structure but rather in the mechanism \nfor evaluating and transmitting parameters. Snyder gives a recursive program scheme which computes leaftest \nthe parame\u00ad ters are passed by name. An examination. of the program schemes and proofs in [2], [3], [61, \nand [7] aid us in ~ analysis of the salient features of infinite arrays and recursion. Infinite arrays \nnot only allow an infinite amount of information to be stored, but they also allow access to any of that \ninfinite amount of information at any time. Even though infinite depths of recursion allow am un\u00adlimited \ncomputation time-wise, recursion does not necessarily allow unrestricted access to an infi\u00ad nite amount \nof information. Using any of the pa\u00adrameter passage mechsmisms mentioned here, recur\u00adsive schemes can \naccumulate an infinite amount of information via the contents of parameters at infi\u00adnite levels of recursion, \nbut at any particular level of recursion only information accessible through the most recent actual parameters \n(or through constants) is available. The actuals cor\u00adresponding to formal parameters transmitted by value, \ncopy, value/result, or reference are effec\u00adtively bound at the time of call (simple variables are the \nonly data structure considered in our re\u00adcursive schemes) and since the number of parameters is finite, \nonly a fixed finite amount of informa\u00adtion can be transmitted from one level of recursion to the next. \nHowever, when parameters are passed by name, actual parameters are not evaluated at the time of call, \nbut rather their evaluation is not only postponed but repeated upon each encoun\u00adter of their corresponding \nformals, Hence, when a recursive function itself along with its parameter list is passed as an actual \nparameter to a recur- SiVe function, the evaluation of the actual can occur within environments of previous \nlevels of recursion, giving access to information outside the scope of the current instance of the recursive \nfunction. It is not clear even with passing param\u00adeters by name, whether recursion has the same power \nas infinite arrays. The ability to reach back into previous enviromnents via the by-name parame\u00adters \n, while giving access to the potentially infi\u00adnite amount of information accumulated in these environments \n, may not give unrestricted access to all of this information. Snyder [7] shows that the class with \nparameters passed by name is R close to being a universal class (PA is a uni\u00adversal class) since the \naddition of only one mark\u00ader makes it universal. The single marker, however, cannot be effectively eliminated, \nand Snyder dis\u00adcusses the difficulties associated with solving the question of whether or not the class \nof recursive schemes transmitting parameters by name is univer sal, i.e., equivalent in power to the \nclass A It appears that the ability to access any of the infinite amount of information which can be \nstored in infinite arrays gives the class its A power. Since arrays in actual programming lan\u00adguages \nare not infinite, we must ask how much of the power of infinite arrays transfers to finite arrays . Clearly, \nstatic finite arrays have less power than infinite arrays, but how close are dynamically-allocated finite \narrays to infinite arrays ? 1.4. Finite Arrays Leinbaugh considered the power of finite arrays in [5]. \nHe introduced several classes of program schemes with dynamically-allocated finite arrays. These classes \nof program schemes are de\u00ad fined from a basic grsmnnar G [5] which is based on Constable and Gries grammar \nin [2]. Note that subscript values can be generated during execution only by the statements v&#38;Oand \nVtw+l. Constable and Gries show that with the above two statements, the predecessor function = 1 can \nbe simulated. So during program execution, both the successor function, + 1, and the predecessor function, \n* 1, can generate new subscript values. Leinbaugh s four classes of program schemes allocate dynsmic \narrays according to the following variations : (1) Finite arrays are allocated upon entry into and deallocated \nupon exit from one-entry, one-exit allocation blocks. These allocation blocks may contain any statements \ngenerated by the grmar producing program schemes in this class. (2) Finite arrays are allocated upon \nentry to and deallocated upon exit from one-entry, multiple\u00adexit allocation blocks. (3) A finite array \nis allocated by a create state\u00adment. If the name of sm existing array ap\u00adpears in a create statement, \nthe existing array is removed and the array name refers to a new array. (4) A finite array is allocated \nwhenever an allo\u00adcate statement is encountered. If the name of am existing array is used in an allocate \nstate\u00adment then the current array is stacked. The most recent allocation of an array is freed when a \nfree statement for that array is  encountered. In each case above, the statement allocating an array \nspecifies the size of the array. The size can be specified through a variable. Upon alloca\u00adtion, each \narray cell is initialized to the unde\u00adfined value. Leinbaugh suggests several reason\u00adable options for \nwhat he terms index-exceeded behavior, i.e., action occurring when a reference is made to an array cell \nwhose index is outside the bounds of the array: (1) terminate program scheme with undefined value; (2) \nloop forever; (3) use cell O in place of the nonexistent array cell; (4) use undefined value if a value \nis required from the nonexistent array cell; otherwise, ignore the reference.  Each of these actions \ncan be explicitly coded by statements generated by the grammars for each of the classes of finite array \nschemes, but the built\u00adin behavior that c>ccurs when a nc,nexistent cell is referenced appears to have \nthe potential to add power to a class. We will say here that an index\u00adexceeded condition has occurred \nwhen a nonexistent cell is reference d,. Leinbaugh showed that the four classes of program schemes allocating \nfinite arrays were all equivalent . However, he was not able to determine the relationship of these finite \narrays classes to the infinite array class A Leinbaugh had greater success in comparing his finite array \nclasses to the infinite array class when the index equality test was allowed. The index equality test \nis a predj.cate test which compares two variables to determine if they con\u00adtain the same array index. \nAdding the index equal\u00adity test to a class of schemes is similar to adding the same interpreted binary \npredicate to every s theme. Leinbaugh showed that his finite array classes and the infinite array class \nwere all equivalent with the inclusion of the index equality test. For notation purposes, since each \nof the fi\u00adnite array classes is equivalent to the other fi\u00adnite array classes, we will use PFA to referto \n any one of the equivalent classes of program leaftest must eventually enter a loop that repeat\u00ad schemes \naugmented with finite arrays. We will use edly executes the same sequence of statements until the subscript \ne to indicate the inclusion of the index equality test. 2. The Relation Between PFA and PFh If we could \ndetermine whether or not the index equality test adds power to the classes and FA then we might be closer \nto determining the re\u00ad A lationship between and PA (particularly if FA we find that the index equality \ntest adds no power since we know that P FAe = Ae) Intuitively, the addition of the index equal\u00adity test \nto a class of schemes appears to add power. Yet, Constable and Gries [2] have shown that the index equality \ntest adds no power to the class PA. Their proof, however, depends on basic functions and predicates being \ntotal, leaving this as an open question (which we answer in section 3) when basic functions and predicates \nare partial. Leinbaugh conjectured in [5] that the index equality test does add power to the class He \nFA correctly speculated that leaftest could not be computed by any scheme in PFA since any such scheme \ncould simultaneously retain only a fixed num\u00adber of values, and would enter a fixed loop until a two-valued \npredicate was found. We showed in [3] that recursive functions using call by value (or copy, value/result, \nor reference) could not compute leaftest for these very reasons. So we use leaf\u00adtest here the same way \nwe used it in [3], to show this time that regardless of whether basic func\u00adtions and predicates are total \nor partial, the index equality test does add power to the class P FA Any scheme in PFA which attempts \nto compute a node on which the predicate p tests true is found. Information is carried from one execution \nof the loop to the next in dynamically-allocated finite arrays. The behavior of this scheme is parallel \nto the behavior that we found any recur\u00adsive scheme, using call by value, computing leaf\u00adtest must have. \nIn the recursive scheme we also eventually entered a loop a loop of recursive calls from which no call \ncould return until a node was found on which predicate p tested true. In\u00adformation was carried from one \nrecursive call to the next in parameters passed by value. There were only a fixed finite number of parameters \n, so as discussed earlier in this paper, only a fixed fi nite amount of information could be transmitted \nfrom one call to the next. Now even though finite arrays are dynamically-allocated and hence capable \nof growing successively larger on each repetition of a loop, they still are capable of transmitting only \na fixed finite amount of information from one loop to the next. So the method of proof in [3] used to \nshow that leaftest cannot be computed by any recursive scheme using call by value serves as a PrOtOtYTe \nfor our method of proof here used to show that lea ftest cannot be computed by any finite array scheme. \nIn fact, the method of proof in [3] is a prototype that can be used to show that not only schemes in \nbut any scheme attempting to FA compute leaftest which finds its behavior musk exhibit the combination \nof (1) fixed flow of control in which the same se\u00adquence of statementa are executed repeatedly, and \n (2) fixed finite amount of information transmitted from one repetition of the statements in (1) to \n the next repetition will, in fact, be unable to compute leaftest. We give here a brief sketch of the \nproof for the class P and refer the reader to [3] or [4] for the FA analogous details. Theorem 1: FA \n< FAe Proof: Since PFAe ~ PAe and since leaftest can be computed by a scheme in PA (and hence in PAe), \nthen leaftest can also be computed. by a scheme in P FAe Now assume there exists a scheme S E PFA which \ncomputes leaftest. Without loss of general\u00adity, assume that S contains only basic functions r and 1 and \nbasic predicate p, and that S allocates finite arrays with the create statement, Wow consider the computation \nof S on an interpre\u00adtation where all p(x) are false. S must enter a loop if leaftest is computed, and \nsince p = false, the same sequence af statements will be executed on each pass through the loop. Before \nthe loop is entered, a fixed finite number of variables (simple and/or subscripted) are accessible, and \nonly a fixed finite number of variables are acces\u00adsible during each pass of the loop since any state\u00adment \nof the form, CREATE A[v], inside the loop creates a new array A of size v with each cell of A initially \nundefined, Let n be the number of variables accessible during each pass of the loop . If we think of \nthe domain of leaftest orga\u00adnized as a binary tree, then the domain elements are nodes of the tree, hence \nthe values of the n variables accessible during each pass of the loop are nodes of the tree. We first \nshow that the val ues of variables accessible in each pass of the loop are descendant nodes of the values \nof vari\u00adables accessible in the previous l?ass of the loop. We next characterise the form of the values \nof the n variables accessible in each pass of the loop so that we can then determine levels LandT in \nthe binary tree and pass I of the loop such that: (1) L>n, (2) a subset of th<? n values is always above \nlevel L on each pass of the loop, (3) the remainder clf the n values descend the  tree as the computation \nproceeds, and are on ~th. at least level L by the pass through the loop, and are on at most level T, \nT2L, ~th from the first through the passes through the loop. Since n < L S, T there exists at least \none node on level T that is not the value of any ~th variable accessible in the pass of the loop. We \nthen show chat there exists such a node q such that neither q nor any of its descendants th is the value \nof any accessible variable in the I or any subsequent pass of the loop. Since only a finite number of \nvalues can already have been tested in S befors pass I of the loop, then a path in the tree from node \nq includes at least one proper descendant of q that (could not have been tested before pass I of the \n100P. But this umtested node cannot be tested during or after pass I of the loop since by pass I it is \nnot even a descendant of a value of a variable acces\u00adsible in pass I Of the loop. Th<?refore, this proper \ndescendsmt of node q is n(?ver tested by p. Now if we consider another interpretation which differs only \nby making predicate p true on this untested node alone, then the computation of S will never test that \nnode and will diverge, (2) performs a predicate test p on A[j], and whereas leaftest should halt on this \ninterpreta (3) increments j, tion. Hence S does not compute leaftest. while p(A[j]) is true, for j ~0. \nS halts with the value of the first array cell on which p So when basic functions and predicates are \nis false. (Note, throughout this proof for con\u00ad total, we have venience we will sometimes use A[j] to \ndenote PFA Thm. 1 <p FAe [51 = PAe [2] = PA the value because of that the is stored complexity in of \narray that cell value.) A[j] The hence value which is computed and stored in each array FA <P A cell \nA[j+l], j ~ 1, has the form, tial, 3. The Relation Between pA and When basic functions and predicates \nas Leinbaugh considers them in [5], PAe are par\u00adthen, as (*) where ~(g(:. 3 A[l] Assume ,.g(A[l],A[j \n]),A[j-l]),A[j-2 = f(AIO]) = f(v). there exists a progrsm 1),. 00),AIII) scheme mentioned previously, \nP does not hold. Ae open question which the proof Leinbaugh we answered in [2] that leaves this in [4]: \nPA ~ as an S ~ loss basic p(A) such of generality, predicate that p S that and = S . S basic And assume, \ncontains only functions f without the and g. Theorem 2: When basic functions and predicates are Now S \n can use only domain elements v, f(v) , partisl, PA < PAe. and domain elements of the form of (*) as \nargu- Proof: A (v): Clearly Consider AIO]tv; the A 2 Ae We now following program k+O; i+O; show that \nscheme S PAe $ E PAe: ments tO p; otherwise, interpretation for 11 P is defined only at elements of the \nwe can choose which v, f(v), and form of (*), i and domain an do. while p(A[i]) j+i; X +f(AIO]); do\u00adj@k \nx + g(x,A[j ]); j+j~l p(A[i]) is false for all q<i, and then under I ~ A[i], while under tests only the \nsame and p(A[q]) is true, S halts with the value 11 t diverges. so domain elements as S, of s and ~; \nassume, without loss of generality, that S i +i+l; stores these domain values in the same array cells \nA[i] ex Of array A that S does. end Similarly, we show that before S even ~ (A[i]). begins to compute \nthe value to be stored in A[j], Now S repeats a cycle which for all j >1, it must compute the value that \nis (1) computes A[j], a value and stores it in an array cell stored with in p. array cell A[j-1] and \ntest thib value 372 Next we show that since S contains a finite would be trivial to show that P ~ P \nwere it FA A number of statements that there exist integers m not for the default behavior which occurs \nin and n, m<n, such that A[m] and A[n] are schemes in when a reference to a nonexistent FA both tested \nwith p by the same statement in S . array cell is made. In order to show FA < A The code which follows \nthis test should compute the we would have to show that this index-exceeded be\u00ad next value of the form \n(*) which will be either the havior can be simulated in even though no A value of A[m+l] or the value \nof A[n+l]. How-index equality test is available to detect the ever, under interpretation I ~ the same \nsequence illegal reference,, If a two valued predicate* of statements will be executed to compute this \nnext could be found, it could be used by schemes in A value, hence the function g will be invoked the \nto detect index-exceeded conditions and simulate same number of times to compute the values to be the \nindex-exceeded behavior [5]. However, before stored in A[m+l] and A[n+l]. It then follows the two-valued \npredicate is fetid it is question\u00adthat one of the values in A[m+l] or A[n+l] was able whether schemes \nin A can simulate the con\u00ada value not computed or tested by the scheme stant predicate behavior of schemes \nin FA Ue s <PAe. Therefore, we can choose an interpreta-to the implicit predicate test in the detection \nof tion under which this value would not bedefined for an index-exceeded condition in schemes in PIf \nFA predicate p, causing S to diverge when p schemes in Pcan simulate the constant predicate A tests \nthis value, while under this same interpre-behavior of schemes in PFA befca-e a two-valued tation, S \nwould not diverge. predicate is foun6., in spite of the default detec-Hence S # S and there exists no \nprogram tion of an index-exceeded condition, then we could scheme S C P such that S ~ S . use the locator/simulator \nproof technique intro- A duced by Constable and Gries in [2] to show that Now when basic functions and \npredicates are P <P We do precisely that. Given a program FA A partial, we have scheme S C PFA, we specify \nan equivalent scheme [51 S E PA, where S consists of one locator and aP = PAe FAe Pi-simulator for each \npredicate Pi in scheme S. Thin.1 V VThin.2 Each Pi-simulator is a scheme in which uses FA A A two-valued \npredic%te Pi to simulate S. S be 4. The Relation Between Pm. and P. gins execution in the locator which \n(1) attempts to locate a two-valued predicate among When basic functions and predicates are total, the \npredicates of S. If it finds such a pred\u00ad we established in section 2 that P~A< PA. Now we icate P, it \ntransfers control to the P\u00ad consider the relation between and P when FA A simulator. basic functions \nand predicates are partial. (2) halts with the same value that S does , orSince a scheme in can compute \nleaftest A [2] while Theorem 1 shows that no scheme in *A two valued predicate is a predicate P for \nFA which two distinct domain values rt and rf exist, can compute leaftest , we know that pA + pFA. It \nsuch that P(rt) = true snd P(rf) = false. diverges as S does, if no two valued predi\u00ad cate is located. \n Leinbaugh [5] has shown that a two valued predicate can be used to simulate the index equal\u00adity test. \nHe has also shown that PFAe = PAe. Hence we have, Theorem 3: For any scheme S 6 PFA we can con struct \na P-simulator P n A f Now , if we can find a locator in P. for A SEP then we will have PFA <p FA A \n Theorem 4: Let S E PFA have locator in A Then there exists a scheme S A such that S=s . Proof: S \nis as described above. See the proof of Theorem 5.5 [2] for details. So in order to show P <P it will \nbe FA A sufficient to show how to construct a locator in for any scheme in A FA Theorem 5: Any scheme \ns c PFA has a locator S1 in A Construction: Assume, without loss of generality, ... that the predicates \nP, ,P used in S have Ln rank 1, and that finite arrays are allocated by the create statement . In specifying \nthe locator 1 we will first be concerned with locating a two\u00ad valued predicate in an environment of \npartial func\u00ad tions and predicates. (We will later specify how our locator detects an index-exceeded \ncondi\u00ad> 1 tion before locating a two-valued predicate. ) Until a two valued predicate is found, our scheme \nS exhibits constant predicate behavior; however, since basic functions and predicates are partial, our \nlocator cannot first perform a series of 1 tests on each predicate in S (as in [2]) to determine initially \nhow S behaves when predicates are constamt. Instead, must perform only the 1 same predicate tests that \nwould have been performed in S, so S must have the form of Leinbaughls 1 locator [5] to gradually determine \nthe constsmt predicate behavior of S while, at the sane time simulating S. This locator is completely \ndescribed in [5]. It consists of 3n sublocators, each of which assumes a different constant predi\u00adcate \nbehavior for S, where each sublocator is given a unique designation of k1k2, ..kn, for each ki E {T,F,?~. \nSublocator klk2. ..k is a n copy of S in which if [T then P: is assumed always true L ki = F then P \nis assumed always false {i ? then no assumption is made about P. . [1 begins execution in sublocator \n?? ?. In 1 general, a sublocator executes until it lk2  kn halts or umtil it encounters an IF statement \nin\u00ad volving P.. If ki = ?, then Pi tests as 1 v f {T,FI, and control passes to sublocator kl.s.ki ~vki+l-. \n-kn. If ki # ?, then P. 1 tests as v E {T,F) and if v = ki, then control remains in sublocator k k . \nkn. If ki+?, 12 then P. tests as v < {T,F] and if v # ki, then 1 control transfers to the P.-simulator \nfor S in 1 Pn which uses two-valued predicate P< to simu\u00ad  fi . late the index equality test. Now, \nup to this point, our locator S1 is a locator in That is, our FA or Chemes n FA locator finds a two-valued \npredicate in a scheme s EPFA if S would have encountered a two-valued predicate during execution; however, \nS1 is still a scheme in We must now eliminate finite FA arrays from S . This would be trivial were it \nnot 1 for the index-exceeded condition which is automati\u00ad cally detected in schemes in P but must be \nFA explicitly detected in our locator S~ before it locates a two-valued predicate. Note, at any point \nin the execution of a sub\u00adlocator, we are either in a loop (which can be terminated only by locating \na two-valued predicate), or are executing straight-line code. If we are not in a loop, then the straight-line \ncode we have exe\u00adcuted previously is the first statement through the current statement of the current \nsublocator (ignor\u00ading predicate tests which merely transfer us to smother sublocator or to a Pi-simulator) \neven though parts of that straight-line code may have been executed in other sublocator~. (TWO sublo\u00adcators \nwhich differ only in that, for one i, one sublocator assumes Pi ? and the other assumes P. T or F, execute \nthe same sequence of state\u00ad 1 ments until P is tested. ) i So each sublocator begins with straight-line \ncode from which we either: (1) halt, or (2) transfer to another sublocator, or  Same straight- line \ncode  ~1 {~ - . - .  change sublocators Sublocator Sublocator XX . ..X?X. ..XX XX. -.X YXX..XX where \nx E[?,T.FI (3) locate a two-valued predicate P. and transfer i  to the Pi-simulator, or (4) enter a \nloop which can be exited only by locat\u00ad  ing a two-valued predicate. Note, we consider that a loop has \nbeen entered if and only if no nested loop can be entered in\u00ad side this loop. At most one such loop can \nmeet this criterion, amd due to the constant predicate behavior of each :sublocator, this loop can be \nidentified. Ifow the index exceeded condition may occur in the straight-line code, or if a loop is entered, \nin the loop. Clearly, it is decidable if this con\u00addition will occur in the straight line code of each \nsublocator. If an array reference is made to a nonexistent array cell, then code which implements the \nindex-exceeded behavior is substituted in place of the statement containing the nonexistent array reference. \nIf a sublocator contains a I.00P, it is also decidable if and when the index-exceeded condition will \noccur in the loop. Without loss of general\u00adity, assume that at most one CREATE statement occurs in the \nloop and that it is at the beginning of the loop. Now unwind the first two passes through the loop. Since \nthe same sequence of statements is executed during each pass of the loop, then for each statement in \nthe loop contain\u00ading am array reference A[v], we can use the val\u00adues in v on passes 1 and 2 of the loop \nto specify a linear function, v(k) , to determine the value of v on pass k of the loop, for k ~ 1. Simi\u00adlarly, \nfor the statement, CREATE A[j], we can use the values of j on passes 1 and 2 of the loop to specify a \nlinear function, size(k) , to determine the value of j, i.e., the size of array A, on pass k of the loop. \nNote, if J denotes a con\u00adstant , or if there is no CREATE statement in the loop, then size(k~l will be \na constant. Then we can solve the linesr inequality, size(k) 2 v(k), to determine on which pass of the \nloop, if any, the index-exceeded condition would occur in the state\u00adment we are considering. If the \nindex-exceeded condition would occur on pass q of the loop, then the loop would be unwound q-1 times. \nPasses q on could remain in the loop with code implementing the index-exceeded behavior replacing the \nstate\u00adment with the illegal array reference. We continue this analysis and, when necessary, additional \nunwinding of the loop, until each statement in the loop has been considered. If the index-exceeded behavior \nis HALT(fJ) or LOOP , and if the index exceeded condition occurs on pass q, then if pass q of the loop \nis reached then the sublocator will halt or diverge. Hence no loop is necessary since the sublocator \nwill not execute beyond pass q of the loop. If the index-exceeded behavior is to use cell O, then the \nsublocator should loop beginning with pass q of the original loop. In this loop, the ille gal array reference \nwill be replaced by a reference to cell O of the array. Note, that if the ille\u00adgal array reference were \nmade in pass q of the original loop, then it will be made again in each subsequent pass through the loop \n(under constant predicate behavior). If the index-exceeded behav\u00adior is to use 0 in place of a value \nrequired from a nonexistent array cell, and to ignore assignments to nonexistent array cells, then the \nsituation is analogous to the previous case. It still remains for us to remove the CREATE statements \nfrom each subloeator. Remember, the statement , CREATE A[v], creates a new array A of size v with each \ncell containing the undefined Talue, ~. For each array A in S f PFA, we will use the same array name \nA to denote that array in each sublocator. Since A in each sub\u00ad locator denotes an infinite array, then \na new block of cells in A will be used each time a new finite array A is created in S. At the begin ning \nof each sublocator we include for each array A the statement, begin A-base o; A-size * O end, where A-base \nand A-size are new vari \u00adables. In each sublocator, each statement of the form, CREATE A[j], is replaced \nby the statement, begin A-base + A-base + A-size; A-size + j end. Each array reference A[v] is replaced \nby the ref erence A[A-base +v] . Hence, each time an array A is created in S, a new block of cells (whose \nvalues are undefined) of infinite array A in each sublocator will represent that finite array. This completes \nour construction of the locator. Theorem 6: FA < A Proof: <p follows from Theorems 4 and 5. FA A PA $ \nPFA since no scheme in computes leaf\u00ad FA test. From the proof of Theorem 5 we obtain the fol lowing corollaries: \nCorollary 1: Under constant predicate behavior, it is decidable for a scheme s E PFA whether or not an \nindex-exceeded condition will occur. Corollary 2; For any scheme S < PFA there exists an equivalent scheme \nS E PFA without default index-exceeded behavior. The second corollary follows since detecting an index-exceeded \ncondition and simulating the de\u00adfault index-exceeded behavior did not require arrays to be infinite. \nCorollary 3: When basic functions and predicates to the corresponding proof in [2] for schemes in the \nclass since we can detect if the index\u00ad are total, it is decidable whether or not s 6 PFA In the case \nof recursion, it was not the mechanism halts or diverges under constant predicate behavior. of recursion \nas a control structure, but rather the mechanism in recursion for data control that The proof of this \ncorollary follows similarly proved limiting. Wnen parameters were passed by A exceeded condition will \noccur, perhaps causing our scheme to unexpectedly halt or diverge (depending on which index-exceeded \nbehavior is the default). When basic functions and predicates are par\u00adtial, we finally have, [51 P PAe \n FAeThin.1 V VThin.2 <P FA A Thin. 6 5. Conclusions Consideration of partial basic functions and predicates \nforces a stricter notion of equivalence between program schemes than consideration of total basic functions \nand predicates. When basic func\u00adtions and predicates are partial, equivalent schemes are almost computationally \nequivalent since values must be computed and tested, for the first time, in the same sequence in each \nscheme. On the other hand, when basic functions andpredi\u00adcates are total, equivalent schemes are simply \ninput-output equivalent. It is thus significant to note that regardless of whether basic functions and \npredicates are partial or total, P <p andP=P FAA FAe Ae Finite arrays and recursion using call by val\u00adue \nexhibited similar limitations which were exposed in attempts to compute leaftest. The limitations involved \nthe storing and accessing of information. nsme to allow more complete access to the (poten tially infinite) \namount of information stored, the limitations exposed by leaftest, were removed. With regard to arrays, \nwhen a new instance of a finite array was created dynamically so that the finite array could claim more \nstorage, access to the information stored in the previous instance of the array was lost. The only information \nthat could be accessed from a previous instance (in the absence of a two-valued predicate) was a fixed \nfi\u00adnite amount of information that could be trans\u00adferred via assignment statements in straight-line code \nfrom one instance of the array to the next. (This situation, as noted in section 2, is analo\u00adgous to \nwhat happens in recursive schemes when new instances of procedures are created. ) When an in\u00addex equality \ntest is added, finite arrays become as powerful as infinite arrays because the index equality test allows \nfinite arrays to grow dynami\u00adcally to claim virtually an infinite amount of storage, and to retain access \nto the information previously stored in the finite array by allowing a simple transfer, via a loop, of \nt he entire con tents of the previous instance of the array to the new instance of the array. Hence tlle \nindex equal\u00adity test allows finite array schemes to access any of the potentially infinite amount of \ninformation which at amy time is stored in dynamically allo\u00adcated finite arrays. It was precisely this \nability that we stated earlier appeared to give the class of infinite arrays its power. Hence the index \nequality test adds significant power to the class In fact, when basic func\u00ad FA tions and predicates \nare partial, PA < PFAe, since P and P ~ P The index equal- FAe z Ae A Ae ity test can control loops, \nand in the class PA in a scheme under constant predicate behavior such a ioop cannot always be simulated. \nNow the implic\u00adit index-exceeded predicate in the class PFA is a restricted index equality test. It is, \nhowever, a sufficient restriction of the index equality test that it adds no power to the class PFA. \nThis is because even though the implicit test and its associated index-exceeded behavior can cause a \nscheme to unexpectedly halt or diverge it cannot control loops, and hence does not have the power of \nthe index equality test. References 1 Brown, J.S., Gries, D~vid, and Szymanski, Thomas, Program schemes \nwith pushdown stores, SIAM J. Comput. 1, 1972, 2~2-268. 2. Constable, R.L., and Gries, David, On classes \n of progrsm schemata, SIAM J. Comput. 1, 19~2, 66-118.  3. Critcher, A., The functional power of parameter \npassage mechanisms, Proceedings of the Sixth ACM Symposium on Principles of Programming Lan\u00adguages, 1979, \n158-168. 4. Critcher, A., Function schemata, Ph.D. Thesis, The University of Iowa, TR 78-o5, 1978. \n 5. Leinbaugh, D.W., Finite array schemata, Ph.D. Thesis, The University of Iowa, TR 75-05, 1975.  6. \nPaterson, M.S., and Hewitt, C.E., Comparative schematology, Conference Record of Project MAC, Conference \non Concurrent Systems and Parallel Computation, ACM, New York, 1970, 119-128.  7. Snyder, L., An analysis \nof parameter evaltiation for recursive procedures. Ph.D. Thesis. Carne~ie- Mellon Univers~ty, 1973. \n  Erratum The treatment of index-exceeded behaviors: use cell O in place of the nonexistent array cell; \nuse undefined value if a value is required from the nonexistent array cell; otherwise, ignore the reference; \nin Theorem 5 is either oversimplified or the result does not hold in these cases. Hence, the relation \nof PA to P~A with these index-exceeded behaviors remains an open question. \n\t\t\t", "proc_id": "582153", "abstract": "", "authors": [{"name": "Adrienne Critcher", "author_profile_id": "81100159744", "affiliation": "The University of Iowa, Iowa City, Iowa", "person_id": "PP39030255", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/582153.582191", "year": "1982", "article_id": "582191", "conference": "POPL", "title": "On the ability of structures to store and access information", "url": "http://dl.acm.org/citation.cfm?id=582191"}