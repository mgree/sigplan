{"article_publication_date": "01-25-1982", "fulltext": "\n On the Composition of Processes V.R.Prdtt Sanford [University Abstract We describe a model of net-connected \nprocesses that amounts to a reformulation of a model derived by Brock and Ackerman from the Kahn-McQueen \nmodel of processes as relations on streams of data. The reformulnlion leads directly to a straightforward \ndefinition of process composition. Our notion of processes and their composition constitutes a natural \ngeneral iza~ion of the notion of functioi IS and their composition. We apply this definition of process \ncomposition to the development of an algebra of processes, which we propose as supplyilig a formal semantics \nfor a language whose domain of discourse includes nets of interconnected processes. This in turn leads \nLIS to Iogics of such nets, about which we raise three open and fundarnertla] problems: existence of \na finite basis for the operations of the language, finite axiomatizability of the equational theory, \nand decidability of this theory. A natural generalization of the model deals with the time complexity \nof computations. Introduction We begin with some motivation in this section, and proceed to an informal \nintroduction to our model in the next section. The reader preferring to go straight to the formal definitions \nshould skip to Section 3. Permission to copy without fee all or partof this material is granted provided \nthat the copies are not made or distributed for direct commercial advantage, the ACM copyright notice \nand the title of the publication and its date appear, and notice is given that copying is by permission \nof the Association for Computing Machinery. To copy otherwise, or to republish, requires a fee and/or \nspecific permission. @ 1982 ACM 0-89791-065-6/821001/0213 $00.75 This paper deals with both modelling \nand logic of processes. The former is in the spirit of work with similar goals by Petri [15], Hewitt \n[6], Kahn [9], and Milner [12,13]. The latter is in the spirit of work by Dijkstra [3], Pratt [17], Parikh \n[14], Pnueli [16], Abrahamson [1], Harel-Kozen-Parikh [5], and many others, Applications for such models \nand logics include semantics for concurrent programming languages such as those of Hoare [7], Ackerman \nand Dennis [2], and others. This research was originally motivated by the problem of specifying software \nfor the distributed computing environments at MIT and Stanford; in the absence of a definition of process \nsuch specifications are unsatisfactorily y vague. In [11] D. MacQueen offers valuable insights into the \ngoals of work on modelling distributed computation, as well as a nice account of the work of Hewitt, \nKahn, and Milner. We offer here our own set of goals motivating the present research. A model of one \ns environment is of value for day-to\u00adday survival in the environment, long-range planning within the \nconstraints of the environment, and redesigning the efl vironment. When the environment is a distributed \ncomputing system, these considerations apply respectively to the system s users, its programmers, and \nits architects. The use of logic in proving one s programs correct is part of the methodology of the \nsecond consideration. Formal models of just the sort presented below play a central role in conventional \napproaches to determining soundness of proof systems, and the direction of the present work is substantially \ninfluenced by our interest in this application. We firmly believe that the first step in developing a \nformal system of logic for any domain is to have a mathematical model of that domain. However models \nare not just for formal logical systems. A user of a system inevitably develops an informal model of \nthat system, whether or not with guidance from any official or formal model. We believe that the user \nwill find it easier to use the system when the user s model of the system is in g~od agreement with that \nof other users and of the system s implementors. The characteristics one looks for in a model include \nthe foi!owing. 1. Simplicity. A simple model means shorter user training, greater ease of use, and reduced \nprobability of error in use. A complex model may also leave its users in doubt as to its fidelity to \nwhat it purports to model. 2. Comprehensiveness. The model should be powerful enough to capture all \nthe essentials of the  system. 3. Abstractness. Facilities for detail management should be supplied. \nIt should be possible to suppress whatever detail is considered irrelevant at a given place or time. \nThe ability to close off or abstract the detailed operation of a system component as a module leaving \nonly its external behavior is particularly valuable, permitting both heterarchical and hierarchical decomposition \nof complex systems into many relatively simple components. In our model, as in Milner s, heterarchy is \nprovided by nets and hierarchy by algebra. 4. Denotational semantics. A model whose semantics is denotational \nmay be viewed as a collection of objects. This concretization or externalization of the model has both \nlinguistic and psychological value in simplifying the modes of use of the concepts of the model. In addition \nit has mathematical value in permitting the application of stanclard algebraic methods.  5. Effective \nIogics. There should exist Iogics for reasoning about various aspects of the system, and possibly decision \nmethods for usefully large fragments of the language. 6. Nondetertninism, Race conditions are an unavoidable \nfeature of practical clistributed systems. They are the source of most of the noncleterminism of distributed \ncomputation. Accordingly the model must be able to represent nondeterminism arising at least from this \nsource. 7. Nongloba] state. The undefinedness of global simultaneity is not merely a relativistic curiosity, \nit is a practical engineering problem. Given two microprocessors on two ocean liners 100 miles apart, \nthe relative temporal order of execution of individual instructions on the two machines is for all practical \npurposes undefined. As anoLher example, two fragmented packets arriving at the same port overlapped in \ntime have lheir relative order undefined. For such reasons our model works with partially ordered rather \nthan totally ordered sets of events. In this respect we join sides with Petri and Hewitt, among others. \n These logics must provide language for these aspects, semantics for the language, possibly axiomatizations \nfor proofs within the language, In some models a partial order is equivalent to the set of all completions \nof the order to a total order. This corresponds to interpreting incomparable as meaning in either order. \n The fragmented\u00adpacket example illustrates the inappropriateness of this interpretation; indeed, with \nsuch an assumption a fallacious correctness proof may be possible since it would imply that all the fragments \nof one packet preceded all those of the other. A common counter to this objection exciudes the packet \nitself from the domain of discourse and attributes entityhood only to its atomic fragments; however this \nis inimical to objective 3, where we would like to be able to reason about the arrival of a packet independently \nof how it arrived, whether as a unit or in fragments. Another reason for wanting to maintain a ptirtial \norder is that it generalizes to cost matrices, which we discuss at the end in the section on time complexity. \nThe set of completions of a pwlial order to total orders do not permit such a generalization at all conveniently. \nThe problem is that the notion of the critical path among several parallel paths is missing from a totally \nordered mu]tiset of events. In this paper we shall present a model of processes which takes into account \nall these criteria, We describe first the basic model, then extend the model to deal with networks of \nprocesses. The model is then algebraicized, with the processes forming the elements of an algebra and \nthe nets supplying the operations. Finally we dkCUSS the prospects for an equational logic of this model, \nand raise some natural open problems. Though we shall not attempt a thorough review of the ex~ant literature, \nwe may at least summarize here our dissatisfaction with each of the most prominent models. Petri s model \n[15] emphasizes controi to the exclusion of data, so that it fails the comprehensiveness test. It also \nlacks any notion of hierarchical clecomposition, primarily because it is not appropriate to view the \nexternal behavior of a Petri net as a single transition. Hewitt s actor model [6] is not abstract. I-Iewitt \ndoes have a notion of the behavior of an actor, but this embraces all activity subsequent to the arrival \nof a message at the actor. This may be attributed to the emphasis on input at the expense of any notion \nof output, an asymmetrical view that is not well matched to modular denotational semantics, Attempts \nat a denotational semantics of actors have led to models that are far from simple. The model of Lynch \nand Fischer [lOa] has the right denotational character. However it emphasizes total orders, which we \nfind less satisfactory. In particular the introduction of time complexity into their model is handled \nmuch more awkwardly than in ours. The Kahn-McQueen model [8,9] is very appealing, moclelling a process \nas a function of its history. History is represented by the sequence of data at each port. Formally a \nKahn-McQueen process may be described as a set of n-tuples of sequences, where n is the number of ports \nin the process. Unfortunately the model only coincides with intuition in the deterministic case, and \ncannot be generalized to the nondeterministic case, as shown by a nice counterexample due to Brock and \nAckerman [3,3a]. The key to our model can be found in Brock and Ackerman s proposed cure, the addition \nof interstream ordering information. Our mode] amounts to a repackaging of the Brock\u00adAckerman-modified \nKahn-McQueen model. On its own the repackaging represents a relatively minor step forwards in process \nmodelling, primarily contributing elegance. The substantively new part of this paper is the definition \nof process composition, which is far from obvious using the Kahn-McQueen-Brock-Ackerman model but which \nbecomes an obvious extension of ordinary function composition when our account of this model is used. \nThe material on algebra and logic that follows represents a central application of such a notion of composition. \nThe Milner model [13] is more appealing than the Kahn-McQueen model in having an algebraic theory worked \nout in greater deLail, and in coping with nondeterminism. Our model improves on Milner s in two ways. \nFirst it is closer in spirit to the standard ordered-pairs model of a function, whose elementary set-theoretic \norientation would appear to motivate the Kahn-McQueen model; in fact we shall derive our process model \nincrementally from the standard function model without damage to its set-theoretic character. The semantics \nof process composition, which is the central contribution of this paper, flows very naturally from such \na definition. Second we eliminaLe Milner s elaborate system of introducing, changing, and hiding names \nof ports from the basic theory of process composition. This system could if desired be superimposed on \nour system, in the form of a derived set of operations, as one approach to obtaining a finite basis for \nprocess algebra, but we would prefer Lo see something considerably simpler. 20 Informal Introduction \nto the Process Model The usual way to define a function set-theoretically is to identify it with its \ngraph, a set of oderecl pairs over some domain. Let Lis call this the graph model of a function. Functions \nwith the same graph are considered to be the same function, the extensiorrality property, capturing the \nidea that there is no more to the function than its external behavior. (We are not interested here in \ndeterminism or totality, and really have in mind binary relations; think of function as connoting a multiple-valued \npartial function.) Our process model amounts to a three-step generalization of the graph model of a function. \nIf the reader is willing to intuit for the moment the notions of port, event, and trace, we can summarize \nthe generalization without further ado, We shall clrop the condition that there be exactly two ports. \nWe shall let there be other than two events in a trace. And we shall only partially order each trace. \nThese notions of port, event, and trace are not part of the usLJal language for describing functions, \nbut make sense when applied to functions, and provide us with the necessary perspective on functions \nto make the transition from functions to processes. Let L[Stherefore introduce them first in the context \nof functions, where their intended usage should be apparent, and then reintroduce them as the basic concepts \nof our process model. The traces of a function are its ordered pairs. Thus we can say that a function \nis a set of traces. Each trace can be considered to represent a sequence of two events: the arrival of \na datum at the input port of the function, and the departure of another datum from l@ output port. An \nexplicit notion of port is redundant in the case of fLnctions since the ordered pair (a, b) invariably \nassociates datum a with the input port and datum b with the output. Since the traces of our process moclel \nare less constrained we must make the datum-port association explicit in the definition of event. Now \nlet LIS repeat our three-step upgrading of functions to processes in more delail. We relax the condi~ions \nfor functionhood in the following three ways. (a) Vary the number of ports. Functions always have exactly \ntwo ports. This is inappropriate for processes, which may have many temporally independent ports. We \nshall fix the set of all possible port names at the outset rather than make it a parameter of the theory, \nand take it to be two copies of the positive integers, denoting input ports by 11,12, etc. and output \nports by 01,02, etc. No ordering among ports is intended to be implied by this convention. All processes \nwill be considered to have all ports, although many processes will only have events at finitely many \nof those ports. (b) Vary the number of events in a trace. A function h-ace always has two constituent \nevents. We shall let a process trace be a finite multiset of events. (A trace may include more than one \narrival of a given datum at a given port,) (c) Vary the trace order. A function trace is totally ordered. \nWe shall let a process trace be partially ordered. (Partially ordered multisets should be defined LIP \nto isomorphism of partial orders; interchanging two equal events clearly should not change the identity \nof the trace.)  3. Formal Definition of the Process Nlorlelo The preceding cliscussion of upgrading \nfunctions to processes should be considered as informal preparation for the following folmal definitions, \nwhich themselves make no reference to a notion of function bUt can be taken as the starting point in \na more concise account of our model, The definitions proper are in italics; the rest is interpretation. \nWe postulate a set D of data, a set I = {11,12,...} of input ports, and a set O = {01,02,...} of output \nports. We let P = I U O denote the set of all ports. An event is a port-datum pair, that is, an element \np:d of PXD. intended interpretation: a datum d arrives at or leaves a port p. We say that p:d is (or \nhappens) at p. A trace is a par[ially ordered rnultiset of evenls. Intended interpretation: a trace is \na computational history, with the order denoting necessary temporal precedence in that history. Incomparable \nelements are considered to have undefined temporal order, which is not necessarily the same as saying \nthat either may precede the other. A process is a set of traces, intended interpretation: the traces \nrepresent all possible computations of the process. In general these will be incomplete computations, \nin that extensions (supersets, or more accurately supermultisets) of those traces may also be in the \nprocess, The notion of an infinite computation does not appear explicitly in the theory, though an infinite \nchain of extensions of a trace could be interpreted as representing an infinite computation. The omission \nof explicit infinite traces is a simple and practical alternative to imposing a continuity condition \non processes that admit explicit infinite traces. Many processes will reference at most the first m input \nports and first n output ports, for some nonnegative integers m and n. Such a process will be said to \nbe of sort (m,n). The notion of sort plays no syntactic role, but merely acts as an upper bound on processes. \nA process of sort (m,n) is also of sort (m+ l,n) and (m,n -t 1). The notion of restriction of a trace \nto a port p will frequently be convenient; it is just the submultiset of the trace consisting of those \nevents with port p. It includes the corresponding restriction of the partial order on the trace. This \ncompletes the formal definition of the model. 4. Examples of Processes The following examples will all \ntake the data domain to be the integers. This should not be interpreted as excluding other domains, e.g. \nlists, a type hierarchy analogous to that for functions, or even domains of self-applicable functions. \nHowever the concepts of this paper are adequately exemplified with simple domains. A buffered adder is \na process of sort (2,1). Each trace consists of three sequences of events, namely two input sequences \n11 and 12, and one output sequence 01, All sequences are finite, The sequence of data in 01, of length \n1011, must be the sum of the length 1011 prefixes of the sequences of data in 11 and 12, The trace order \nis minimal subject to each of the three sequences being totally ordered, and in addition having the ith \nevent of 01 being preceded by the ith events of 11 and 12. The buffered adder consists of all traces \nmeeting these conditions. The next example illustrates that, although we can model elements with bUfferS, \nwe do not assume them. This is important for example in verifying network protocols that are explicitly \ndesigned to cope with limited buffers. An unbuffered adder differs from a buffered adder in that while \nit is adding two inputs it will reject (discard) further inputs. There may however be a delay between \ncompletion of addition and appearance of output. We may then infer that any lost input must lie between \nan accepted input and the corresponding output. We may also infer that if each pair of inputs is only \nsupplied after the preceding output has appeared, no data will be lost. If inputs are supplied faster \nthan outputs appear, no guarantee can be made as to which inputs are accepted; in particular the first \ninputs to arrive after an output appears may be rejected in favor of some earlier inputs. An unbuffered \nadder may therefore be defined as a buffered adder in which the condition for being a trace of the adder \nis weakened to permit the interpolation of events at port 11 between an event at 11 and the corresponding \nevent at 01, and similarly for 12. No constraints are placed on the data in the interpolated events, \nsince these are the rejected events. There is no need to add rejects beyond the last output of a trace \nbecause the trailing inputs are already all potential rejects. A memory is a process of sort (2,1) such \nthat inputs arriving at 11 replace the contents of memory while inputs arriving at 12, regardless of \ntheir value, cause the contents to be read out nondestructively. Initially the memory is empty, meaning \nthat 12 inputs have no effect. A memory may then be defined as consisting of all traces such that (i) \nthe ith output event, O~:x, is preceded by exactly i+j 12 events where j is fixed for the whole trace \nand gives the number of initial 12 events ignored, (ii) each output evetil Ol:x is preceded by its source \nevent 11:x responsible for loading x into the memory, (iii) the order Of OLltpLltS k COrLSktt3TIt with \nthat of their sources (thus if Ol:x precedes Ol:y, the former s source 11:x must precede the latter s \nsource l~:y), and (iv) the restriction of the trace to any porl is totally ordered. An arbiter has no \nfixecl sort and simply merges its input streams into one output stream, at 01. A trace will therefore \nconsist of finitely many streams of inputs and one stream of outputs, with the output stream having e]emcnts \nmerged from prefixes of the input streams and being ordered so that efich output follows its cc)rresponding \ninput, with each stream being totally ordered. A fall-out process has sort (1,2). Each output stream \nis a prefix of lhe input slream, wilh each output event preceded by its source. The identity process \nhas sort (1,1); lhe output is a prefix of the input, with each output event preceded by its source. It \ncan be viewed as a degenerate fan-out process or a degenerate arbiter. A free source has sort (0,1), \nand consists of all traces for processes of that sort. Likewise a free sink has sort (1,0) and also consists \nof al I traces for processes of that sort. 5. The Semantics of Process Composition In this section we \nmove from consideration of pure processes, which are represented by their external behavior, to composite \nprocesses, which are built 11P from their COnSLILUent processes using nets. A simple net is a multiset \nof processes together with a partial bipartite matcking from outpu Ls to inputs of those processes. That \nis, there are a number of conl?eclions made each from an oLltp ut port to an input port, with no two \nconnections sharing a port. Not 811ports need to be so connected. We shall also require of simple nets \nthat each connection be between two distinct processes, a harmless restriction that can be met by interposing \nan identily process and that slightly simplifies our account. We now wish to set LIp a parallel between \nthe behavior of processes and that of nets. The basic parallel is between net connections and process \nports. So far we have encountered process events, process traces, and process behaviors (which we identified \nwith processes). We define a net event to be a connection-datum pair, a net trace to be a partially ordered \nmultiset of net events, and a nel behavior to be a set of net traces. The restriction of a net trace \nto a process is obtained by renaming the connection component of each net event incident on that process \nto be the port associated with that connection. This port is well-defined thanks to the definition of \na simple net. Net events not incident on the process are discarded. The res~riction inherits the partial \norder of the net trace. It should be remembered that a partial order is transitive. For example if three \nevents a,b,c are linearly ordered and restriction discards b, then lhe remaining events a and c are still \nlinearly ordered. If one follows the convention of representing this order as a~b~c then it is easy to \nmake the mistake of discarding both arrows when discarding b and inferring that a and c are unrelated. \nSuch a representation should be closed up transitively before performing a restriction. A consistent \nnet trace is one whose restriction to a process is a trace of that process. Such a process trace can \nnever involve a port that is not connected in the net. For example if an adder s 11 port is left disconnected \nin a net then no net trace of that net can be consistent. The behavior realized by a net is the set of \nits consistent net traces. Net behaviors are of interest both in their own right, as when studying nets, \nand in their role in net abstraction, which we now treat. Net abstraction converts a net into a process. \nIt is the means whereby implementation details are hidden. It amounts to the generalization to processes \nof the existential quantification part of the definition of funclion composition, and completes our definition \nof process composition. For a net to implement a process it must have ports, We will introduce these \nby viewing the outside world, as perceived through any given port, asjust another process. A net input \nis a free source that is distinguished as an input, while a net output is a free sink distinguished as \nan output. (It is possible for free sources and sinks not LObe inputs or OLltPUtS.) It is now easy to \ndefine net abstraction. The process obtained by net abstraction from a net is the restriction 10 lhe \nnel ports of ~he behavior realized by lhe net. This straightforward definition solves the problem of \nthe meaning of composition of processes, by specifying exactly what process is obtained by connecting \nprocesses together. It is the central contribution of the paper; without it the following logical and \nalgebraic explorations could not be pUrSLLed. Function composition may be recognized as simply a special \ncase of process composition, namely for processes all of whose traces are (totally) ordered pairs. One \ncan define the composition off ancl g in two steps, the first of which talks in terms of triples (x,y,z) \nsuch that (x,y) and (y,z) are pairs in f and g respectively, and the second of which projects the set \nof such triples onto the first and third coordinates. The triples correspond to net behaviors, and projection \ncorresponds to the restriction performed during net abstraction. This connection with classical composition, \nin which our process composition is viewed as a straightforward generalization of function composition, \nis proposed as a major virtue of our model. It is worth pointing out that no notion of least fixed point \nis necessary in our definition of composition. This is a fringe benefit of adding ordering information \nbetween events belonging to different ports. In the Kahn-McQueen model it is necessary to take least \nfixed points to rule out traces that could not happen in practice. In our definition such impossible \ntraces have cycles in their ordering relation, contradicting the antisymmetry condition on a partial \norder; hence they are ruled out. 6. Composition as an Abstraction So far we have cliscussed the meaning \nof connecting individual processes together to form a new process. We now wish to extinct from this an \nabstract notion of composition analogous to the composition operator for funclions. Accordingly wc inlroduce \nthe nolion of an n-ary net schema. This is simply a general net of uninterpreted processes numbered from \n1 to n, A net schema S defines an n-ary operation on processes, namely the operation rearming the n\u00adtuple \nal,...,an to the process obtained by net abstraction from the net resulting from instantiating the ilh \nprocess of S with ai, Net schema are rather uninteresting when based on simple net$. More useful operations \non processes are obtained if we permit some basic processes to be left interpreted. A natural way to \ndo this is to inLroduce the notion of general nets. General nets permit fan-in and fan-out of connections, \ncon nections between ports of the same process, and unattached process ports. The question of the meaning \nof a general net is reduced to that of a simple net by translation: fan-ins are translated to arbiter \nprocesses, fan-outs to fan-out processes, and intraprocess connections have an identity process inserted. \nA net schema is a general net of uninterpreted processes. Given any set of processes, a nel opera[ion \nis an n\u00adary operation on processes definable by some n-ary net schema. The existence of many nets leads \nus naturally to consideration of algebras based on nets. 7. Net Algebras We would like an algebra of \nprocesses which has a reasonable supply of operations on processes. To this end we define a net algebra \nto be a set of processes together with a set of net operations on those processes. A complete net algebra \nis one having all net operations. A complete net algebra forms a clone or closed nest of operations, \nin the sense that its operations are closed under composition, or more accurately forming of polynomials, \nsince nets themselves can be composed to form new nets. This is analogous say to a Boolean algebra which \ncontains all Boolean operations ancl is therefore closed under forming Boolean polynomials. Clones have \nthe advantage of permitting the finite basis issue to be finessed (since closure under formation of polynomials \neliminates the distinction betwen basic and derived operations). but the disadvantam of requiring infinitely \nmany operation symbols in the language. This leads LIS then to our first open problem. {~ Is ~here a \njlnite basis for every net algebra? The analogous question for Boolean algebras is answered in the affirmative: \nA and 1 constitute a very small basis from which all other Boolean functions can be formed as polynomials, \nand Scheffer stroke (nor) provides an even smaller one. For regular algebras we have Kleene s theorem \nthat all operations definable with graphs (in a way that can be made precise) may be obtained from the \nthree regular operations of union, sequence, and star. R, Pale~son and J. Staples have pointed out [14a] \n(for an earlier formulation of net algebras that was heterogeneous in that it respected type syntactically) \nthat this question is trivially answered in the negative, by observing that forming polynomials cannot \nyield new sorts from old, whence any finite basis must refer only to finitely many process sorts. Even \nfor the heterogeneous case the thrust of our question may be restored by asking it for the case of an \narbitrary finite subset of the possible operation types. For example is there a finite basis for the \noperations definable with processes of at most two inputs and two outputs? However, in our homogeneous \nformulation the argument leading to the negative answer no longer holds. 8. Logics for the Model In this \npaper we will content ourselves with equational Iogics. The rationale for an equational logic is partly \nthat reasoning with equations between terms is a natural form of logic, but also that it is a canonical \nlogic in that other kinds of logic can readily be reduced to it: propositional calculus to Boolean algebra, \nfirst order logic to cylindric algebra, dyn~amic logic to dynamic algebra, and so on. At a later stage \nit may become appropriate to introduce quantifiers over processes, and a variety of predicates on processes, \nsuch as safe and live, A major advantage of equational logic is that the definition of the language is \ncomplete as soon as the similarity type of the class of algebras has been settled. In the case of net \nalgebras the similarity type has as its operations all the net operations. These supply the operation \nsymbols for a language of terms over a domain of processes. With the addition of a supply of variables \nand the equality predicate, the logical language is complete. The similarity type settles the language, \nbut the class of algebras of interest settles the semantics. An equation is an identity when for every \nalgebra in the class it evaluates to true for any values of its variables chosen from that algebra. The \nidentities of the language with respect to that class form the equational theory of that class. We raise \ntwo natural questions, (ij) Is the equational theory of net algebra j7nitely axiomatizable? That is, \nis there some finite subset of the theory which has the same class of models as the whole theory? (Due \nto a celebrated completeness result of Garrett Birkhoff this may also be stated syntactically in terms \nof provability of the whole theory from a finite axiom base.) (iit) Is lhe equational theory of net algebra \ndecidable? For this question to be well-defined we require a constructive representation for net operations. \nThis presents no problem however; the defining net itself provides such a representation. A positive \nanswer to (i) would yield an even better representation, particularly if the similarity type were reduced \nto the finite basis. To see that these are natural questions, consider their analogues for what amounts \nto the von Neumann computer model. Viewed in process terms a von Neumann computer can be considered to \nbe a net in which one datum, representing the processor state, circulates. lf we know that this condition \nholds, we can, to sufficient accuracy for our purposes here, view a net as a finite state automaton, \nthe one-program-counter case of nets in general. A finite state automaton with edges labelled with numbers \n1 to n corresponds to a net schema, and so may be called an fsa schema. Two edges Iabelled 1 and 2 and \nconnected in parallel defines the regular operation of union; two similar edges but connected in series \ndefines composition; and one edge looped back to itself defines closure. in general any fsa schema defines \nsome regular operation, just as any net schema defines some net operation. For fsa schemata all the above \nquestions, including the finite basis question, have been answered a long time ago. Their answers are \nas follows, (i) Yes. This is Kleene s celebrated representation of regular sets with regular expressions. \nIn terms of fsa schemata it means that only three fsa schemata, union. sequence, and loop. define operations \nwhose polynomials yield all regular operations. This is the algebraic equivalent of the more common statement \nof the theorem, that all sets accepted by finite-state automata are representable as regular expressions \nover the given alphabet. (ii) No, This was shown by Redko [19]. Much search for a finite set of axioms \nfor regular expressions preceded this result, which is quite  deep. one might then leap to the conclusion \nthat a richer domain such as net algebras woLl\\d be even less tractable. However a nice counterexample \nto this is provided by the equational form of the Segerberg axioms for propositional dynamic logic [20], \nwhich can be regarded as being about regular expressions denoting predicate &#38;ansformers. By extending \nthe domain to include the predicates a finite equational axiomatization becomes possible, because it \nthen becomes possible to talk about induction, cf. [18]. It is by no means clear whether the additional \npower of general nets over finite state automata can also be used to yield a finite axiomatization, though \nwe are inclined to conjecture in the negative. There may however be some generalization of dynamic logic \nthat supplies a positive answer. (iii) Yes. This follows from the deciclability of equality between regular \nexpressions, by cxanding each net operation into a regular expression. Though we offer answers for none \nof these questions in the more general case of net algebras, at least the questions have been formulated \nin a well-defined way. A positive answer to any one of the three questions would be of considerable importance \nin the development of logics of distributed computation, 9. Time Complexity Our model may be generalized \nto take time complexity into account in a manner that exactly parallels the passage from binary relations \nto cost matrices, that is, from Boolean matrices to integer matrices. A trace, being a partial order \non events, is of course a binary relation R on events that is reflexive (1 E R), transitive (R2 = R), \nand antisymmetric ((R-1)2 is irreflexive). If we replace binary relations with cost matrices, whose entries \nmay be reals, and replace Boolean matrix multiplication (with V und A for the exterior and interior operations \nrespectively) by rnax/-t multiplication (with rnax and i-for the exterior and interior operations respectively), \nthen we may still talk about a matrix being reflexive (zero diagonal) and transitive (R2 = R). in this \ncase the events are considered to be not merely temporarily related but to be separated by a given time. \nTime is additive along a chain of temporal dependencies. When there is more than one chain between a \npair of events, the longest chain (as measured by the sum of the times along it) provides the critical \npath, whence the choice of max for the exterior operation. Acknowledgments J. Staples and P. Pritchard \nprovided helpful commentary, I am indebted to N. Lynch for prompting me to consider time complexity. \nBibliography [1] Abrahamson, K., Modal Logic of Concurrent Nondeterrninistic Programs, Preprints of the \nInternational Symposium on Semantics of Concurrent Computation, Evian-les-Bains, July 1979. [2] Ackerman, \nW.B. and J.B. Dennis, A Value\u00ad (1-iented Algorithmic Language. MIT LCS TR\u00ad218, June 13, 1979. [3] Brock, \nJ.D. and W.B. Ackerman, An Anomaly in the Specifications of Nondeterminate Packet Systems, Computations \nStructures Group Note CSG-33, MIT-LCS, NOV. 1977. [3a] Brock, J.D. and W.B. Ackerman, Scenarios: A Model \nof Non-Determinate Computation. In Lecture Notes in Computer Science, 107; Formalization of Programming \nConcepts, J. Diaz and I. Ramos, Eds., Springer-Verlag, New York, 1981, 252-259. [4] Dijkstra, E., Guarded \nCommands, Noncleterrninacy and Formal Derivation of Programs, CACM 18, 8, 1975. [5] Harel, D., Kozen, \nD., Parikh, R., Process Logic: Expressiveness, Decidability, Completeness, IBM Research Report, April \n1980. [6] Hewitt, C. and H.G. Baker, Laws for Communicating Parallel Processes, IFIP 77, 987\u00ad992, North-Holland, \nAmsterdam, 1977. [7] Hoare, C. A. R., Communicating Sequential Processes, CACM, 21, 8, 666-672, ALlgLU3t, \n1978, [8] Kahn, G., The Semantics of a Simple Language for Parallel Programming, IFIP 74, North-Holland, \nAmsterdam, 1974. [9] Kahn, G. and D.B. MacQueen, Coroutines and Networks of Parallel Processes, IFIP \n77, 993-998, North-Holland, Amsterdam, 1977. [10] Kleene, S.C., Representation of Events in Nerve Nets, \nin Automata Studies, (eds. Shannon, C.E. and J. McCarthy), 3-40, Princeton University Press, Princeton, \nNJ, 1956. [lOa] Lynch, N.A. and M.H. Fischer, On Describing the Behavior and Irnple~menhation of Distributed \nSystems, Theoretical Computer Science, 13, 17-43, 1981, [11] MacQueen, D. B., Models for Distributed \nComputing, Technical Report 351, INRIA, Paris, 1979. [12] Milner, R., Synthesis of Communicating Behavior, \n7th Symp. on Math. Found. of Computer Science, Zakopane, Poland, Sept. 1978. [13] Milner, R., A Calculus \nof Communicating Behavior, Springer-Verlag Lecture Notes in Computer Science, 92, 1980. [14] Parikh, \nR., A Decidability Result for a Second Order Process Logic. Proc. 19th 1EEE Symp. on Foundations of Computer \nScience, 177-183, Ann Arbor, Oct. 1978, Also M.I.T. Laboratory for Computer Science Technical Memorandum \nNo. 112, September 1978. [1.4a] Paterson, R. and J. Staples, An algebra of processes with a finite basis, \nTechnical Report No. 29. Dept. of Comp. Sci., U. of QLD, St. Lucia, QLD., Australia, June 1981. [15] \nPetri, C.A., Introduction to General Net Theory, Springer-Verlag Lecture Notes in Computer Science, to \nappear 1981. [16] Pnueli, A., The Temporal Logic of Programs, 18th IEEE Symposium on Foundations of \nComputer Science, 46-57. Oct. 1977. [17] Pratt, V. R., Process Logic, Proc. 6th Ann. ACM Symp. on Principles \nof Programming Languages, 93-100, San Antonio, Texas, Jan, 1979. [18] Pratt, V. R., Dynamic Algebras \nand the Nature of induction, Proc. ACM Symposium on Theory of Computation, Los Angeles, May, 1980. [19] \nRedko, V. N., On Defining Relations for the Algebra of Regular Events, (Russian), Ukrain. Mat. Z., 16, \n120-126, 1964. [20] Segerberg, K., A Completeness Theorem in the Moclal Logic of Programs, Preliminary \nreport. Notices of the AMS, 24, 6, A-552. Oct. 1977.\n\t\t\t", "proc_id": "582153", "abstract": "We describe a model of net-connected processes that amounts to a reformulation of a model derived by Brock and Ackerman from the Kahn-McQueen model of processes as relations on streams of data. The reformulation leads directly to a straightforward definition of process composition. Our notion of processes and their composition constitutes a natural generalization of the notion of functions and their composition. We apply this definition of process composition to the development of an algebra of processes, which we propose as supplying a formal semantics for a language whose domain of discourse includes nets of interconnected processes. This in turn leads us to logics of such nets, about which we raise three open and fundamental problems: existence of a finite basis for the operations of the language, finite axiomatizability of the equational theory, and decidability of this theory. A natural generalization of the model deals with the time complexity of computations.", "authors": [{"name": "V. R. Pratt", "author_profile_id": "81100298352", "affiliation": "Stanford University", "person_id": "PP39036584", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/582153.582177", "year": "1982", "article_id": "582177", "conference": "POPL", "title": "On the composition of processes", "url": "http://dl.acm.org/citation.cfm?id=582177"}