{"article_publication_date": "01-24-1983", "fulltext": "\n Permission to make digital or hard copies of part or all of this work or personal or classroom use is \ngranted without fee provided that copies are not made or distributed for profit or commercial advantage \nand that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, \nto post on servers, or to redistribute to lists, requires prior specific permission and/or a fee. &#38;#169; \n1983 ACM 0-89791-090-7 $5.00 generated by a binary relation like those used in the logics of [FL79] and \n[BMP811. We give a more refined basis for comparing expressive power that avoids these technical difficulties. \nIt does turn out. that expressibility results corresponding to Lamport s still hold. However, it should \nbe emphasized that these results apply only to the two particular systems that he defines. Sweeping conclusions \nregarding branching versus linear time logic in general are not justified on this basis. We will argue \nthat there are several different aspects to the problem of designing and reasoning about concurrent programs. \nWhile the specific modalities needed in a logic depend on the precise nature of the purpose for which \nit is intended, we can make some general observations regarding the choice between a system of branching \nor linear time. We believe that linear time logics are generally adequate for verifying the correctness \nof pre-existing concurrent programs. For verification purposes, we are typically interested in properties \nthat hold of all computation paths. It is thus satisfactory to pick an arbitrary path and reason about \nit. However, there are applications where we need the ability to assert the existence of alternative \ncomputation paths as provided by a branching time logic. This arises from the nondeterminism -beyond \nthat used to model concurrency -present in many concurrent programs. In order to give a complete specification \nof such a program, we must ensure that there are viable computation patha corresponding to the nondeterministic \nchoices the program might make. (h example is given in section 6.) Neither of Lamport s aystema is entirely \nadequate for such applications. In order to examine these issues more carefully, we define a language, \nCTL*, in which a universal or existential path quantifier can prefix an arbitrary linear time asaertion. \nCTL* is an extension of the Computation Tree Logic, CTL , defined in [CE81] and studied in [EH82]. This \nlanguage subsumes both of Lamport s interpretations and allows us to compare branching with linear time. \nMoreover, the syntax of CTL* makes it clear which interpretation is intended. The paper is organized \nas follows: In section 2 we summarize Lamport s approach and discuss its limitation. In section 3 we \npresent the syntax and semantics of CTL*. We also define some natural sublanguages of CTL* and compare \ntheir expressive power in Section 4. In particular, we show that (cf. Theorem 4.1) a language substantially \nless expressive than CTL* still subsumes both of Lamport s interpretations. Section 5 then shows how \nCTL* can be embedded in MPL [AB80] and PL [HKP80]. Finally, section 6 concludes with a comparison of \nthe utility of branching and linear time logic. 2. LAMPORT S APPROACH AND ITS LIMITATIONS For the reader \ns convenience we summarize Lamport s approach here (we do take the liberty of slightly altering his notation): \n 2.1 Definition. A structure M = (S,X,L) where ----- - . S is a nonempty set of states, X is a nonempty \nset of .-paths, i.e., a .- . nonempty aet of nonempty sequences of states, and L is a labelling which \nassigns to each state a set of atomic propositions true in the state. We use s,t,s ,tl, . . . etc. to \ndenote states in S and / X,Y9X >Y1*... etc. to denote sequences of states (with repetitions allowed) \nover S. A path x is a . - nonempty sequence of states. We say that a path is of length k, and write [xl \n= k, if it consists Of 1 + k states. Thus , if x is finite then [xl = k for some k ~ O, and x has the \nfOrm (50, .. ..sk ). If x is infinite then [xl = @ and has the form (so, s~, s~,... ). If x can be either \nfinite or infinite it is sometimes convenient to write x = (sO, . . ..sk.. ) or even x = (si) where, \nimplicitly, O <i < 1+1x1. We use first(x) to denote the first - state, of x, and last(x) to denote the \nlast o> . state, sk, o f x. If x is infinite, last(x) does not exist. If [Xl > 0, we define x = (sl, \n. . ..sk) .); 0= otherwise x = x. We define the suffixes of x, x x, xm+l = (Xm) . If y # x is a suffix \nof x then y is a prope~_ suffix of x. The prefixes and proper prefixes of x are defined similarly. If \nx is a . finite sequence and y is a sequence, then the concatenation of x and y, written XYY ia the \n sequence obtained by appending Y to x. (E.g., if x = (al,s2) and y = (s3,s4,s5) then xy = (s1,s2,s3,s4,s5). \nSimilarly, if x = x s is a finite path and y = SY is a path then the fusion . of x and y, written X Y, \nis the path X SY (the fusion is undefined if last(x) # first(y)). Remark: Various constraints can placed \non the set of paths X. In particular, Lamport [LA80] requires that X be suffix closed meaning that if \nx . - - -. <X then x f&#38; X. Similarly, we say that X is fusion closed (cf. [PR79]) if Xlsyl < X and \nx2sy2 -. k-X imply xlsy2 ~ X, We also say that X is limit - . closed (cf. [AB80]) provided that if there \nis an - --\u00adinfinite sequence of paths YOXO, YOYIXI, YOYIY2X2, . . . ~X and each yi is nonempty then \nthe limit path c x. In the subsequent sections, we shall alao consider the case where X is required to \nYOY1Y2. . . be ~ ~nerable meaning that there is a (total, .. -\u00adnonempty) binary relation R such that \nX consists precisely of the infinite sequences (s0,s1,s2, . . . ) such that (s i,si+l) ~ R for all i. \nThis is a natural condition which has been assumed in many previous papers including [FL79], [EC80], \n[BMP81], and [EH82]. It is shown in [EM81] that the above three closure properties are exactly equivalent \nto R-generability. These closure properties are important in ensuring that certain commonly accepted \nidentities are valid (see sections 4,5 and [Eli81]). 2.2 Syntax. Lamport inductively defines the syntax \nof a class of temporal formulae: - .- - --\u00ad 1. Any atomic proposition P is a temporal formula. 2. \nIf p,q are temporal formulae then so are pAq ( conjunction ), and p ( negation ). 3. If p is a temporal \nformula then so are  []p (meaning always p ) and >p (meaning sometimes p ).  2.3 Semantics. A temporal \nformula s meaning depends on whether it is interpreted as a formula of branching time or a formula of \nlinear time. For the branching time interpretation, we write M,s I=B p to indicate that formula p is \ninterpreted as true in structure M at state s. We define I B inductively: P iff PC L(s) 2. M,s . BP~ \nqiff M,s [=B Pand M,s (=Bq M,s p iff not( M,s [=B p) . B 3. M,s [1P iff d path XE Xwith first(x) = s \nB ~n~O, M,first(xn) I=Bp M,s ->p iff V path X6 X with first(x) = s B %~0, M,first(xn) I=BP Similarly, \nfor the linear time interpretation we write M,x I=L p to indicate that in structure M formula p is true \nof path x. Again, we define I=L inductively: 1. M,x I=L P iff Pc L(first(x)) 2. M,x [7P ~ q iff M,x \n[=L PandM,x l% q M,x I=L p iff not (M,x I=L P)  3. M,x /=L []p iff Vn~O, M,xn IT p M,x [=L >p iff % \n>0, M,xn I=L p . For both interpretations, the modality <>p is introduced as an abbreviation for []-p \nand the other logical connective are introduced as abbreviations in the usual way. Note that in the branching \ntime interpretation, a formula is true or false of a state whereas in the linear time interpretation, \na formula is true or false of a path. Thus, we cannot directly compare the expressive power of linear \ntime with branching time. In an attempt to overcome this difficulty, Lamport extends I=B and I L to entire \nmodels: 2.4 Definition. Given structure M = (S,X,L) temporal formula p is ~-valid under the b-ranching \n. time integretation, written M I=B p, provided that - ----\u00adfor every state s ~ S, M,a I=B p. Similarly, \np is M-valid under the linear time interpretation, --- --- ----- ______ ____ _______ . . . . . \u00adwritten \nM I=L p, provided that for every path x CX, M,x l=Lp. Next, Lamport defines his notion of equivalence: \n2.5 Definition. Formula p under interpretation X is strongly gqu&#38;v:Ae_n~-to formula q under interpretation \nY, written p ss q, provided that for every structure M, M I=xp iffM [=yq Using this formalism, Lamport \nargues that linear time and branching time have incomparable expressive power: 2.6 Theorem ([LA80]). \n<>P in branching time is not strongly equivalent to any assertion of linear time. 2.7 Theorem ([LA80]). \n->[]P in linear time is not strongly equivalent to any assertion of branching time. We have several criticisms \nof the formalism. Note that defining a formula as true or false of an entire model causes useful information \nto be lost. For example, in the branching time interpretation although there is a model M with states \nS,S such that M,s I=B ->P ~ P and M,s I=B -(->P A -P), there is no model M such that M I=B ->p ~ p. Similar \nremarks apply for the linear time interpretation. Thus, we get 2.8 Proposition. In linear time or in \nbranching time, ->P ~ P s~ ~a@~. This shows that s 1s too coarse an equivalence relation in that it \nclassifies satisfiable formulae as equivalent to false. Moreover, since the same notation is used for \nboth branching and linear time formulae, it is not clear from the syntax which interpretation is intended. \nThis has the effect of obscuring the essential difference between the two interpretations, namely, that \nlinear time formulae make assertiona about paths and branching time formulae make assertions about states. \nIt also causes difficulties when translating from English into the formalism. We also disagree with Lamport \ns conclusion that linear time logic is superior to branching time logic for reasoning about concurrent \nprograms. Lamport gives two specific arguments to justify this claim: 1. To establish certain liveness \nproperties of a concurrent program, it is frequently necessary to appeal to some sort of fair scheduling \nconstraint such as strong eventual fairness (which means that if a process is enabled for execution infinitely \noften, then eventually the process must actually be executed). This constraint can be expressed in linear \ntime logic by the formula (->[] ENABLED) V ->EXECUTED. However, it is not expressible in branching time \nlogic. 2. In proving  a Program correct, it is often helpful to reason using the principle that, along \nany path, either property P is eventually true or is always false. This amounts to assuming an axiom \nof the form ->P V []-P wh~ch is M-valid for all models M under the linear time interpretation, but not \nunder the branching time interpretation. The first observation is certainly true for the particular systems \nthat Lamport has defined. However, by using a branching time logic with appropriate operators (such as \nthe infinitary quantifiers used in [EC801) these assertions can be easily expressed. Indeed, by adding \nenough modalities to a branching time logic, any assertion . of Lamport s linear time can be expressed \nas described in section 4. In regard to the second point, it is true that the given formula is valid \n(i.e., true in all models) under the linear time interpretation but not under the branching time interpretation. \nHowever, the formula is not a correct translation of the principle into the formalism under the branching \ntime interpretation. We believe that this is an instance of the confusion caused by the use of the same \nsyntax for both interpretations. Again, it is possible to write a formula in a branching time system \nwhich accurately renders the principle as shown in section 3. 3. A UNIFIED APPROACH In this section \nwe exhibit a uniform formalism for comparing branching with linear time that avoids the technical difficulties \nof Lamport s and allows us to examine the issues more closely. To illustrate our approach, we describe \na language, CTL*, which subsumes Lamport s branching and linear time systems as well as UB [BM??81] and \nCTL ([EH82], [cE81]). CTL* is closely related to MPL [AR80]. (CTL* is also used in [cEs831. ) In CTL* \nwe allow a path quantifier, either A ( for all paths ) or E ( for some paths ), to prefix an assertion \np composed of arbitrary combinations of the usual linear time operators G ( always ), F ( sometimes ), \nX ( nexttime ), U ( until ), as well as the infinitary state quantifiers of [EC80], ? ( infinitely often \n), ~ ( almost everywhere ). 3.1 Syntax. We inductively define a class of state formulae (true or false \nof states) and path formulae (true or false of paths): S1. Any atomic proposition P is a state formula. \nS2 . If p,q are state formulae then soare p~ q, p S3 . If p is a path formula then Ap, Ep are state formulae \nPI. Any atomic proposition P is a path formula P2 . If p,q are path formulae then soare p~ q, p P3a. \nIf p is a state formulae then Gp, Fp are path formulae P3b. If p is a path formulae then Gp, Fp are path \nformulae P4a. If p,q are state formulae then Xp, (p U q) are path formulae P4b. If p,q are path formulae \nthen Xp, (p U q) are path formulae P5a. If p &#38;s a state formula then Fp, Gp are path formulae P5b \n. If p is a path formula then~p, tip are path formulae Remark: The other truth-functional connective \nare introduced as abbreviations in the usual way. As we shall see, .we could take the view that Ap  \nabbreviates E-p, Fp abbreviates (true. U p), Gp abbreviates F-p, %~fa:breviates G@}~~~ ~ Fp), and 8P \nabbreviates -. Thus , we could give a substantially more terse syntax and semantics for our language \nby defining all the other operators in terms of just the primitive operators E, X,U, -, and A. Also, \nwe could consider state formulae as a special case of path formulae whose truth value depends on the \nfirst state of the path and thus view all formulae as path formulae. This is essentially what is done \nin PL (cf. [HKP80]) and also leads to a slightly easier formulation of the syntax and semantics. Howe \nve r, like Abrahamson [AB80] , we consider the distinction between quantification over states and over \npaths an important one that should be maintained. Moreover, this approach makes it easier to give the \nsyntax of each of the sublanguages that we consider. The set of state formulae generated by the above \nrules forms the language CTL*. We, also consider a number of other languages generated by some combination \nof the above rules: The set of path formulae generated by rules Pl,2,3b gives the language L(F, G), and \nthe set of state formulae generated by rules S1-3, P3a yields the language BT. As tie shall see, L(F,G) \ncorresponds precisely to Lamport s linear time interpretation and BT corresponds precisely to Lamport \ns branching time interpretation. The set of path formulae generated by rules Pl,2,3b,4b corresponds to \nthe language L(F,G,X,U) used in many applications (cf. [GPSS80], [Mw81]). The set of state formulae generated \nby rules S1-3, P3a,4a corresponds to the language CTL used in [CE81]. We define the language ECTL to \nbe the set of state formulae generated by rules S1-3, P3a,4a,5. We can then define BT , CTL+, and ECTL+ \nto be the set of state formulae generated by adding the rule P2 to the rules for BT, CTL, and ECTL, respectively. \nCTL+was considered in [EH821 and ECTL+ is essentially the language studied in [EC80] . Both ECTL and \nECTL+ provide us with an ability to make assertions about fair computations. 3.2 Semantics. We write \nM,s 1= p (M,x {= p) to mean that state formula p (path formula p) is true in structure M at state s (of \npath x, respectively). When M is understood, we write simply s 1= p (x 1= p). We define 1= inductively: \nS1. s 1=Piff P6 L(s) S2 . s I=p A q iffsl=pandsl=q s [=-p iff not (s 1= p) S3 . s /=Ap iff for every \npath xE X with first(x) = s, X[=p s 1= Ep iff for some path x~ X with first(x) S,x[=p . P1. x 1= p \niff P e L(first(x)) P2. x 1=P~ qiff x 1=pand X[=q x l=-P iff not (X I=p) P3a. x 1= Gp iff for all i \nLO, first(xi) 1= p x 1= Fp iff for some i~O, ~irst(xi) 1= p P3b. x [= Gpiff for all i >0, X1 I=p x I=FP \niff for some i > 0, xi [=p P4a. x 1= Xp iff [xl > 0 and first(xl) 1= p x 1= (P U q) iff for some i > \n0, first(xi) 1= q and for all j J_O [ j<i implies first(xj) 1= p] P4b. x [= Xp iff Ix( >0and X1 1=p x \n1= (PfJq) iff for some i >0, xi I=q -. and for all j >0 [ j<i implie; xj [=p] P5a. x I=Yp iff 1x1 =@and \nfor infinitely many distinct i, first(xi) [= p x l=~piff for all but a finite number of i, first(xi) \n1= p P5b. x [=~p iff 1x1 =~and f or infinitely many distinct i, xi [= p x I=%p iff for all but a finite \nnumber of i, Xil=p , It is easy to check that all the equivalences mentioned in the remark in section \n3.1 hold. Observe that the following equivalences establish the claimed correspondences between Lamport \ns linear time and L(F,G) and between Lamport s branching time and BT: M,x l~L [1P iff M,x [= GP M,x [=L \n->p iff M,x 1= Fp M,S {=B []P iff M,S 1= AGp M,s I=B ->P iff M,s 1= AFP Note that under the linear time \ninterpretation the formula discussed in the previous section, ->P v [I-P, corresponds to the L(F,G) formula \nFP V G-P which is clearly valid. Under the branching time interpretation it corresponds to AFP V AG-P \nwhich is not valid. However, the valid BT+ formula A(FP V G P) (obtained by simply prefixing the L(F,G) \nformula with A) does capture the intended principle. Clearly, a direct comparison of linear time (i.e. \npath) formulae with branching time (i.e. state) formulae is impossible. As we have seen, Lamport s approach \nof defining a formula as true or false of an entire structure leads to technical problems . How then \ncan we compare linear time with branching time? Since in program verification applications, there is \nan implicit universal quantification over all possible futures when a linear time assertion is used, \nwe associate with every path formula p the state formula Ap and ask whether this is expressible in a \ngiven branching time logic. Thus, we have the following definition: 3.3 Definition Given any language \nL of path formulae we define the language of associated state formulae B(L) = {Ap : p 6 L}. (Note that \nB(L) is not closed under negation or disjunction (cf. [AB80] ).) On this basis, we can compare any linear \ntime logic L with branching time logic B by first converting L into the associated branching time logic \nB(L). This time, however, equivalence of the branching time formulae is measured by the usual notion: \n 3.4 Definition. Given state formulae p,q we say that p is equivalent to q, written p z q, provided that \nfor every structure M, for every state s of M, M,. (=P iff M,s I=q. It is easy to check that z is an \nequivalence relation which refines ~g and avoids the problems of Proposition 2.8. In fact, we have the \nfollowing results which clarify the relation between s and =s : 3.5 Proposition. For any path formula \np, p SS Ap. Proof : Let M = (S,X,L) be an arbitrary structure. We show M [= p iff M [= Ap. If M [= p \nthen for all x6X, M,x [=p. Sofor all s~S, M,. 1= Ap and thus M [= Ap. Conversely, if M [= Ap then for \nall ae S, M,. [= Ap and for all XC X starting at s, M,x 1= p. Since each x &#38; X starts at some s s, \nM,x [=P for all x6X. Thus, M 1= P. O 3.6 Proposition. For any state formulae p,q, p ~a q iff AGp E AGq. \n Proof: (=>:) Assume P s q. It will suffice to show that M,s 1= AGp implies M,. 1= AGq because, by a \nsymmetric argument, we can then conclude AGp E AGq. So suppose M,s 1= AGp where M = (S,X,L) is an arbitrary \nstructure and s < S. Define X = {x ~ X : x starts at s}. If X is empty, then trivially M,s 1= AGq as \ndesired. Otherwise, define M = (S ,X ,L ) with S = {s ~ S : s appears on some x e X } and L = L/S. Note \nthat for any state formula r, M,. /= AGr iff M ,s != AGr iff Vs e S , (M ,s [= r). Taking r=p, we get \nkfs ~S , M ,s 1= P. Since p ~s q, VS &#38; S , we have M , s I=q. Now take r=q, to see that M,s 1= AGq \nas desired. (<=:) Assume AGp ~AGq, i.e. M,. 1= AGp iff M,. [= AGq for all M and s in M. It will suffice \nto show that M 1= p implies M 1= q as a symmetric argument will yield p SS q. NOW suppose M 1= p where \nM = (S,X,L). Then Vs &#38; S, we have M,s 1= p whence ~s E S, we also have M,s 1= AGp. Since AGp = AGq, \n~S ~S, M,s [= AGq and M,s 1= q. Thus M 1= q as desired. D 3.7 Corollary. For any path formula p and state \nformula q, p ES q iff AGAp s AGq. Finally, we compare the expressive power of two branching time languages \nas follows: 3.8 Definition. We say that L2 is at least ~s\u00adex~ressive as L1, written Ll ~ L2, provided \nthat .-. ----. for every p 6 LI there exists q~ L2 such that p s q. We say that LI is exactly as expressive \nas L2, . written Ll = L2, provided L1 ~ L2 and L2 ~ L1. Finally, LI is strictly Qss_ expressive ~~:. \nL2 , written L1 < L2, provided L1 ~ L2 and L1 ~ L2. Using this formalism, in the next section we compare \nthe relative expressive power of the branching time languages defined above. We show that the following \npicture describes their relative expressive power: B(L(F, G,X,U)) < ~CTL* B(L(:G)) <AECTL+ ECTL BT+ BT \n where any two languages not connected by a chain of < a and s s are of incomparable expressive power. \n4. EXPRESSIVENESS EESULTS In proving our expressibility results, we asaume that all structures are R-generable. \nWithout such an assumption even rudimentary equivalences such as EFEFP s EFp do not necessarily hold. \nOur inexpressibility results are stronger than those Lamport obtains in that ours apply in the case of \nR-generable structures as well as a~ffix-clOsed structures whereas his apply only to suffix-closed structures. \nOur first result shows that Lamport s linear time system is expressible in the branching time logic ECTL+: \n 4.1 Theorem. B(L(F,G)) ~ECTL+. Proof: This proof involves a complicated induction on the structure \nof B(L(F,G)) formulae. Details are left to the appendix . 0 However, if we add the nexttime operator \nthe situation changes: 4.2 Theorem. The formula A[F(P ~ XP)] is not equivalent to any formula q ~ ECTL+. \nProof: We inductively define two sequences M1,M2,M3, . . . and Nl, N2, N3, . . . of models as follows. \nDefine Ml,Nl to have the grapha shown below d,&#38; where in Ml, al I=P, bl I=P, dl l=-p and inNl~ al \n1=P, and dl 1= P. Suppose we have defined Mi and Ni. Then Mi+] and Ni+~ have the following graphs where \nin both Mi+l and Ni+l, ai+l 1= p> bi+l 1= p> and M~, N; are copies of Mi, Ni, respectively. It should \nbe clear that (1)for all i, Mi,ai I= AIF(P ~ XP)] and Ni,ai 1= A[F(P A XP)]. We will also show that (2) \nFor any ECTL+ formula p there is a CTL formula q which is equivalent to p over these two sequences of \nmodels. That is, for all i and all states s in Mi, Mi,s [= p s q, and similarly for Ni. (3) For any \nCTL formula p, with Ipl < i, Mi,ai I=P iff Ni,ai I=P. To see that the result follows, auppoae that A[F(P \nA XP)I is equivalent to some ECTL+ formulae p. Then by (2) above, there is a CTL formula p equivalent \nto p over these models. Now (pJl = i for some i. Then Mi,ai 1= A[F(P A XP)] which, by supposition and \n(2), implies Mi,ai [= p . By (3) this implies Ni,ai (= p , which implies, again by supposition and (2), \nthat Ni,ai [= A[F(P A Xp)]. But this contradicts the fact (1) above that Ni,ai [=-A[F(P A XP)]. The details \nof the proof for (2) and (3) are provided in the appendix. D Similar combinatorial techniques can also \nbe used to prove tbe following two theorems: + formula E[fp A ~Ql s 4.3 Theorem. The ECTL not equivalent \nto any formula q &#38; ECTL. Proof: Left to the appendix. o 4.4 Theorem. The ECTL formula E~P is not \nequivalent to any formula q ~ CTL+. Proof: Left to the full paper. o Theorem 4.4 also follows from the \nresults of [EC80] which depend on recursion-theoretic techniques. Howe ve r, such techniques will not \nsuffice to establiah Theorem 4.3. Thus , the combinatorial proof techniques used here seem to provide \na sharper tool than does recursion theory in applications such as this. The following theorem shows that \nexistential quantification over paths cannot be expressed with only universal quantification as provided \nin the languages of the form B(L(-)): 4.5 Theorem. The BT formula EFp s ot equivalent to any B(L(F,G,X,U)) \nformula. Proof: Suppose EFP s Aq for some linear time formula q over F,G,X,U. Since EFp is satisfiable, \nit must be that q is satisfiable. Thus M,x 1= q for some structure M = (S,X,L) with X = {x}. Add a successor \ns to s = first(x) which satisfies P to get a new structure. That is, let M = (S ,X ,L ) where S = s u \n{s }, x = x ~ {ss }> L (s) = L(s) for se S and L (s ) = {P}. Then M ,s 1= EFP eince blocking will not \nconcern us here. and, by the supposed equivalence, M ,s 1= Aq. But The syntax of MPL is as follows: then \nM ,x [= q and also M,x 1= q, a contradiction. 1. Any atomic proposition is a formula. o portion of the \ndiagram below CTL + follows The 2. If p,q are formulae then so are p, p ~ q, <>P, from the results in \n[EH82]. Xp, and p U q. We take []p to be an abbreviation for <>-p. 5. RELATION TO PL AND MPL A structure \nM is a triple (S,X,L) as before. We assume that the reader is familiar with PL An MPL formula is true \nor false of a triple M,x,y (see [HKP80] for details). We can translate CTL* where M is a structure (S,X,L), \nx ~ X, and y is a into PL in the following way: To each CTL* finite prefix of x (called a stage). If \ny,z are .- -\u00ad structure M = (S,X,L), we associate the PL stagea or paths, we write y < z if y is a prefix \nof structure Mt = (S, (=,R) where the set of paths of z. We define (= inductively as follows: atomic \nprogram A, RA , is equal to X, and for any 1. M,x,y I=P iff PC L(last(y))atomic proposition P, Mt,s 1= \nP iff M,s [=P. We 2. M,x,y 1= p ~ q iff M,x,y I=p and M,x,y [=q can then give a translation of a CTL* \nformula p into an equivalent PL formula pt. We define the M,x,y 1= p iff not(M,x,y 1= p) translation \ninductively, taking the primitive 3. M,x,y I=p U q iff ~z(y~z~x and M,x,z l=q* temporal connective of \nCTL to be E, X, and U and ~w(y <w <z => M,x,w 1= p)) (c,f. the remark in Section 3.1): M,x,y 1= Xp \niff 3z(M,z,x 1= p and y~z~xand-~(y<w <z))Pt = p for atotic propositions p 4. M,x,y [= <>p iff 3x (x E \nX, y~x , (-P)t =-(et) and M,x ,y 1= P)t=pt~qt (PA q) (p Uq)t = qt v (Pt ~f.qt) While no restrictions \nare placed on the set of (Ep)t =:-(<A>pt) paths X in defining the semantics of MPL, we must (Xp) t = \nfalse ~f_ p t to that are --- restrict our attention structures (Note this is equivalent to suffix closed \nas well as fusion closed in order to (~pt)) translate CTL* into MPL. These reatrictiona are necessary \nsince there are CTL* formulae (e.g., Then by a straightforward induction on the EGXtrue ~ EXEGXtrue ~ \nEFEFp A EFp) which are satisfiable only in structures that are neither structure of CTL+ formulae we \ncan show \u00ad  5.1 Proposition. For all x ~ X, M,x 1= p iff Mt,x whereas every suffix closed nor fusion \nclosed MPL l=pt and forallsc S, M,s l=piff Mt, (s) [= pt. formula is satisfiable in a structure that \nis both Note (p U q)t s qt or (pt suf qt) since the U suffix closed and fusion closed. This latter fact \n. operator considers the current path while the sufarises from the use of stages in defining the . 7. \noperator only depends on proper suffixes. Ep is a semantics of MPL and is proved in state formula; since \nin PL we have only path 5.2 Lemma. An MPL formula is satisfiable iff formulae, we force the truth of \nthe formula to it is satisfiable in a structure that is suffix depend only on paths starting at the first \nstate. closed and fusion closed. Since MPL has not been widely discussed in the Proof: Left to the \nappendix. D literature, we briefly review its syntax and If y is a stage of x, write x/y to indicatesemantics \nhere before describing the translation the suffix of x obtained by deleting all but thefrom CTL* into \nMPL (see [AB80] for more details). last state of the prefix y, i.e. y (x/y) = To simplify the exposition, \nwe take the liberty of x. Then we get elightly altering Abrahama on s notation. In particular, we use \nthe temporal connective <>, U, 5.3 Lemma. If M = (S,X,L) and X is suffix and X instead of their duals \n[1, w, and y, closed and fusion closed then for all MPL formulae respectively. We also omit the H operator \nand view pandx~X all paths as simply sequences of states corresponding to legal sequences of transitions \nM,x,y 1= p iff M,x/y, first(x/y) 1= P Proof: A straightforward induction on the structure of p suffices. \nNote that we need fusion closure of X in order to show that M,x/y,first(x/y) 1= <>P imPlies M,x,Y [= \n<>P. Details are left to the reader. n The preceding lemma shows khat, in a suffix closed and fusion \nclosed structure, we can essentially omit mention of the stages. Thus, we will write M,x (= p as an abbreviation \nfor M,x,first(x) [= p. We can then translate a CTL* formula p to an MPL formula pt simply by replacing \nall occurrences of E by <>. We now get: 5.4 Theorem. Given a structure M = (S,X,L) where X is suffix \nclosed and fusion closed, and path xGX, if p is a CTL* path formula then M,x 1= p iff M,x 1= pt and if \np is a CTL* state formula then M,first(x) 1= p iff M,x 1= pt~ What do these translations tell us about \nthe existence of decision procedures for CTL*?. Note that a CTL* formula p is satisfiable in a structure \nM iff the corresponding PL formula pt is satisfiable in the structure Mt. Moreover, by the definition \nof Mt in terms of M, p is satisfiable in a structure M meeting certain restrictions on its set of paths \nX (e.g., suffix closure or R\u00adgenerability) iff iff pt is satisfiable in~ a structure Mt where RA meets \nthe same restrictions. However, the definition of PL allows arbitrary sets of paths in the structure, \nand the original work [HKP801 on decidability of PL formula does not consider the question of restrictions \non the sets of paths. It is true that we can modify the algorithm given in [HA821 to check if a formula \nis satisfiable in a structure where RA iS suffix closed and/or fusion closed. Alternatively, using Lemmas \n5.2 and 5.3 and Theorem 5.4 together with the fact ([AB80]) that there is an algorithm for testing satisfiability \nof MPL formulae which runa Zcn in deterministic time 0(2 ), we get 5.5 Theorem There is an algorithm \nto decide if a CTL* formula p is satisfiable in a structure which is suffix closed, fusion closed, and \nfor harder. It is the limit closure constraint which causea difficulties. For instance, there is no analogue \nof lemma 5.2 for limit closure in the case of MPL. Consider the formulas <>GXtrue and ;;;;hr::r;n ;;:eeo~22 \nih~ p irst)0 tate f ome ath , Proof: We simply check if pt is satisfiable. But , the problem of \ndeciding if a formula is satisfiable in an R generable structure seems much . - . []G<>Xtrue given by \nAbrahamson ([AB80], p. 110). . --If M = (S,X,L) then M,x,y 1= <>GXtrue iff there is --\u00adan infinite path \nin X extending y and M,x,y 1= []G<>X~ru_e_iff every finite path extending y can in turn be extended by \nanother path in X. It is eaey to check that _____ []G<>Xtrue is <>GXtrue~ satisfiable in a structure \nthat is suffix closed and fusion closed but not limit closed. However, as Abrahamaon points out, his \ndecision procedure will generate structures that are not limit closed for certain formulae satisfiable \nin limit closed structures, and there is no obvious modification of his algorithm for MPL to force it \nto generate limit closed models whenever possible. Similarly, there is no obvious modification of the \n[HA82] algorithm to force RA to be limit closed. Thus, the problem of finding an elementary time algorithm \nto decide if the CTL* formula p is satisfiable in a limit closed (or R-generable model) remains open. \nWe remark that in [AB80] a complete axiomitization is given for MPL which also applies to CTL*, provided \nwe restrict our attention to structures which are suffix closed and fusion closed. The problem of finding \na complete axiomatization which applies to R-generable structures remains open. 6. CONCLUSION We believe \nthat linear time logics are generally adequate for verifying the correctness of pre-existing concurrent \nprograms. For verification purposes, we do not usually care which computation path is actually followed \nor that a particular path exists because we are typically interested in properties that hold of all computation \npaths. It is thus satisfactory to pick an arbitrary path and reason about it. Indeed, Owicki and Lamport \n[OL80] give convincing evidence of the power of this approach. In these situations, the simplicity of \nlinear time logic is a strong point in its favor, and we see only one advantage in considering the use \nof a branching time logic. Namely, linear time logics, as interpreted over branching time structures, \nare not closed under negation. While it may be possible to prove that a property holds for all executions \nof a correct program, if a program is incorrect because the property does not hold along some execution, \nit will be impossible to disprove the property for the program as a whole. As Abrahamson [AB80] notes \nIt is out of the question to attempt to disprove a property when we can t even state its negation. Furthermore, \nthere are other situations for which we want the ability to explicitly assert the existence of alternative \ncomputation paths and must use some system of branching time logic. This arises from the nondeterminism \n-beyond that used to model concurrency -present in many concurrent programs. Consider an instance of \nthe mutual exclusion problem where each process Pi is functioning as a terminal server. At any moment, \nPi (nondeterministically) may or may not receive a character. A key attribute of a correct solution is \nthat it should be possible for one particular Pi to remain in its noncritical section, NCSi, forever \n(awaiting but never receiving a character from the keyboard) while other Pj continue to receive and process \ncharacters. It should also be possible for Pi to receive a character and then enter its trying region, \nTRYi. From there it eventually enters the critical section, CSi, where the character is processed before \nreturning to NCSi. But, no matter what happens, once Pi is in NCSi it either remains there forever or \neventually enters TRYi. To express this property. one can use a branching time logic formula involving \na term (intended to hold whenever is in NCSi) of the form EGi_n_N~_S-i ~ EFinTRYi pi ---\u00ad ~ A(GinNCSi \nV FinTRYi). However, using Theorem 4.5, this is provably not expressible in linear time logic, i.e., \nin a language of the form B(L(-)). , The natural candidate formula, A(GinNCSi .. ... V F$KCQ\\i), allows \na degenerate model where all paths satisfy FinTRYi and no path satisfies . ----GinNCSJ. . - . This ability \nto existentially quantify over paths is particularly useful in applications such as automatic program \nsynthesis from temporal logic specifications (cf. [CE81], [EC82]) where very precise and thorough specifications \nare needed. Of course, it is possible to successfully synthesize a wide class of interesting programs \nusing only linear time logic (cf. [MW81], [w082]); but, as the remarka above demonstrate, some means \nexternal to the logic must be used if we wish to ensure the existence of alternative computation paths. \nWe also note that explicit path quantification can be helpful in ensuring that a program exhibits an \nadequate degree of parallelism (i.e., that it can follow any one of a number of computation paths and \nis not a degenerate solution with only a single path). 7. APPENBIX Proof of Theorem 4.1: We firat define \nthe set of basic formulae, B, as follows: 1. Any propositional formula (i.e. boolean combination of atomic \npropositions) is a B formula. 2. If pl, . . ..pn are propositional formulae then  P1 U (P2 U ... (pn_l \nUGPn). ..) is a B formula which we abbreviate [PI, . . ..Pnl. Intuitively, [Pi,...,Pnl means that there \nis a finite segment (possibly of length O) where PI holds , followed by a segment where p2 holds, ..., \nfollowed by a segment where pn_l holds , and then pn holds ever after. 3. If p is a propositional formula \nthen GFp ia a B formula. 4. If p is a propositional formula,and  [Pg, . . ..po no 1,..., [P&#38;.. \n.,P:ml, [cl~>. ..)q:ol$ Frl, ..., Frn are B formulae, then F(p A [p:, . . ..p.ol A...A [P~>..., P:ml \nA x[q~, . . ..q~ol /l Frl A...A Frn) is also a B formula. (hy of the terms in the conjunction may or \nmay not be present.) Let ~+ be the closure Of B under conjunction and disjunction. Note that the formulae \nof B+ can be written in conjunctive or disjunctive normal form, where the literals are formulae of B. \nClaim. For every linear time formula over F and G, there is an equivalent formula of B+. Proof of Claim: \nFirst note that given any linear time formula over F and G, we can use deMorgan s laws and duality (e.g. \nFp = G-P) to drive the negations inward until only the atomic propositions appear negated. Since B+ contains \nthe propositional formulae and is closed under conjunction and disjunction, it then suffices tO show \nthat if p C B+, then Fp and Gp are equivalent to some B+ formula. For Fp note that, since F(ql V q2) \nE Fql V Fq2, it suffices to ahow Fp is equivalent to some +B formula just when p is a conjunction of \nformulae in B. This follows directly from 4 above  of terms in [PO A qo, . . ..pi that F(ql ~ GFq2) \n= Fql and the observation k A qjk~. >pn A qm] is consistent provided that if p ik A qjk appears ~ \nGFq~. before pih A qjh then ik ~ ih and jk ~ jh. NOW Similarly, since G(ql ~ q2) ~Gql ~ Gq2~ it observe \nthat suffices to show GP is equivalent 0 ome formula just when p is a disjunction of formulae in [PI), \n. . ..Pnl A [qo, . ..>qml = (where V {[PO A qo, . . ..pik A qjk, . . ..en A qml ~+ B. This follows using \nthe observation below with consistent ordering of terms}. p and the q~ are Propositional Ormulae): Thus \n, we can aasume (if p has no F s) that p G(p V Vi[P~,...~P~i 1 V VjFqj V VkGFq~ ) is of the form q A \n[po, .. ..pn] A Ai GFri by ~ again using the fact that E[q V q ] e Eq V Eq . Gp V Vi[P , P$>. ..~P: \n1 VVkGFq~ V But VXFq: V i V~,j[i(qj A XGP ) V F(qj ~ X[P ,P&#38;,P~i] E[q A [Po, ..., Pnl A Ai GFri] \ns q A E[po U EIPl U . . . EIPn_l U E[GPn A Ai Glki] ...]]. Intuitively, the first line of the right \nhand side takes care of the case that no qj is ever This is an ECTL+ formula as desired since GF s ~. \ntrue, and the second line covers the case that some In general, p has the form is true infinitely often. \nThe third line j corresponds to all qj being true onlY finitelY q A [Po,..., enl A Frl A... A Frm A \nAh GFsh often: the last time any qj is true, either GP or where q is propositional. Observe that one \nof the [pi, ..., pi.] will be true at the next state. This would be ~ B+ formula except that q = Ep \ns qj in some GFqj may not be a propositional formula. qA If q in GFq is not a propositional formula, \nv. EIPO U EIPI U . . . E[pj U E[Pjs.. .,Pn] A ri Ipj note that q still must be in the form of 4 above \nA Ak+i Frk A Ah GFShl...ll since it is the argument to F. Note also the (Intuitively, we are disjuncting \nover which ri gets equivalence below: satisfied first and in which segment pj this occurs.) E([pj, . \n. ..Pn] A ri A Ak+zi rk A Ah GF(P ~ [pO, O..,P~o] ~...~ [P&#38;O .,P;ml ~ 8GFsh) has one fewer F so we \nare almost ready to k:>ooo)qkol~ Frl ~...~ Frn) = apply the induction hypothesis. Only one problem GFp \n~ F([p~, . . ..p~ ]) ~...~ F([P&#38;.. .,P~m]) ~ remains: one of the conjuncts forming ri might be a \nF([q~, . . ..q~o]! ~ GFrl ~...~ GFrn formula of the form X[qo, . . ..qm]. Note that the following equivalences \nhold: By repeatedly applying this equivalence, we can get down to the case where GF only takes a propositional \nformula as an argument. This GFs s XGFS completes the proof of the claim. D [Po, . . ..Pnl ~ Vj(pj A \nX[pj>..., pnl) It remains to show that if p is a B+ formula, Fr.arj V XFrj then Ep is equivalent to \nan ECTL+ formula. Since Xql A xq2 = x(ql A q2). E(q V q ) E Eq V Eq , it suffices to Prove the By repeatedly \napplying these equivalences, we can result in the case where p is a conjunction of B rewrite [pj, ..., \nPn] A ri A Ak+ Frk A Ah Fsh formulae. We proceed by induction on the number of as a disjunction of formulae \nof the form p A Xq formula of the form Fr (corresponding to rule 4 where p is a propositional formula \nand q is a B+ above) which appear as any subformula in p. formula. But E(P A Xq ) s P A ExM , and q \nIf p has no F s, then it is of the fOrm will have less F s than the original p. By q A [P~, . . ..P~ol \n/1. .A [P~J...~P~ I ~ i GFri induction, we are done. O where q is propositional. We fir~t show that a \nproof of Theorem 4.2 (continued:) We now conjunction of formulae of the form [Po, . . ..Pnl is argue \nby induction On IPI, that fOr all CTL equivalent to a disjunction of such formulae. Given formulae p, \n[Po, . . ..enl. [ql), . . ..qm] we say that the ordering (*) if IPI <i then (Mi,ai I=P iff Ni,ai I=P). \nNote that (*) trivially implies if Ipl < i then - (Mi+l,ai 1= P iff Ni+l,ai 1= p) which in turn can be \nseen to imply (**) if [PI ~ i then (Mi+l, bi+l 1= P iff Ni+l, bi+l 1= P). We take EXq, E[q U r] and \nA[q U r] aa our primitive operators in the induction since any CTL formula is equivalent to one using \nonly these modalities. The argument proceeds in cases based on the structure of the CTL formulae p. \nThe cases where p is an atomic proposition, a conjunction q ~ r, or a negation q are easy and left to \nthe reader. If p is of the form EXq then, Mi+l,ai+l [=EXq iff . Mi+l!bi+l l=qor Mi,ai I=q orNi,ai q iff \nNi+l,bi+l 1= q (by **) or Mi,ai 1= q o: Ni,ai [=q iff Ni+l,ai+l 1= EXq. If p = E[q Ur] then, Mi+l,ai+l \nl= E[q Url iff (1) Mi+l,ai+l I=r or (2) Mi+l,ai+l [= q, Mi+l,bi+l 1=r or (3) Mi+l,ai+l l=q, Mi+l,bi+l \n!=q, Mi, ai I= E[q Ur] or (4) Mi+l,ai+l I=q, Mi,ai l=E[q Url or (5) Mi+l,ai+l l=q, Ni,ai l= E[qUrl \n iff (1) Ni+l,ai+l I=r (by (*)) or (2) Ni+l,ai+l l=q, Ni+l,bi+l I=r (by (*), (**) resp. ) or  (3) \nNi+l,ai+l [= q> Ni+l>bi+l 1= q (by (*), (**) resp.), Mi,ai l= E[qUr] or  I = q (by (*)), Mi,ai 1= E[q \nu r] or (4) N i+l,ai+l (5) Ni+l,ai+l [=q (by (*)), Ni,ai l=E[q Url  iff i+l,ai+l l= E[q Ur]. In the \nlast case, if p = A[q U r] then, A[q U r] iffMi+l,ai+l ! (1) Mi+l,ai+l [= r or (2) Mi+l,ai+l 1= q, Mi+l,bi+l \n1= r, Mi,ai l=A[q U r], Ni,ai [=A[q Ur] or  (3) Mi+l,ai+l 1= q, Mi+l,bi+l 1= q, Mi,ai l= A[q Url, Ni,ai \nl=A[q Ur]  iff (1) Ni+l,ai+l 1= r (by (*)) or (2) Ni+l,ai+l I=q, Ni+l,bi+l l=r (by (**)), Mi,ai 1=A[q \nUr], Ni, ai 1=A[q u r] or  (3) Ni+l,ai+l 1= q, Ni+l, bi+l /= q (by (**)), i,ai /=A[q Ur], Ni,ai I=A[q \nUr]  iff i+l ai+l 1= [q u ] It remains to establish our claim that CTL and ECTL+ are of equivalent \nexpressive power on the two sequences of models. For any ECTL + formula Eq, q can be placed in disjunctive \nnormal form. Since E(q V q ) s Eq V Eq and 6P ~ bp s &#38;(P ~ P ), it suffices to show the equivalence \nfor any ECTL+ formula of the form pl = E[p ~ $ ql A . ..A ~qn /1 %] where Ep,ql, . . ..qn are CTL+ formulae. \nTO show this, we observe that every maximal path in one of the structures M~ or Ni ends in a self-loop \nat the state d. Using c to denote either ai or bi, we thus have that Mi,c 1= pl iff Mi,c 1= Ep and Mi,d \n1= ql /1... A qn A r. Moreover, Mi,d [= ql A...A qn A r iff M.i,c l= EFAG(ql A... A qn A r). Thus, Mi,c \n1= PI iff Mi,c [= Ep A EFAG(ql A...A qn A r) and similarly, for Ni. The latter formula is in CTL+. By \n[EH82], we know that for any CTL + formula q there exists an equivalent CTL formula q. So we are done. \nO Proof of Theorem 4.3: We inductively define two sequences of models Ml,M2,M3, . ..e and N1,N2,N3, . \n. . such that for all i, Mi,ai 1= E[FP A ?Q] and Ni,ci l=-E[%P /l~Q1. We show that ECTL iS unable to \ndistinguish between the two sequences of models, i.e. for all ECTL formulae P with IPI < i, Mi,ai 1= \np ~ff Ni,ci 1= p. The result follows since if E[f! p A FQ] were equivalent to some ECTL formula P of \nlength i then we would get a contradiction: Mi,~ [= P iff Ni,ci 1= p while Mi,ai 1= E[~p A FQ] and Ni,ci \n[=-E[~P A ~Q]. We define Ml, Nl to have the graphs shown below: 138 that L (t) = L(h(t)). Now define \nM = (T ,X ,L ). M,; to ~ c, c\\* olba, ~d, b, where al [=P~ Q; bl [= P ~ Q,c1 I=P ~ Q, and dl 1= p ~ Q. \nAssume we have defined M{ ,N+ . Then Mi+l, Ni+l have the graphs below: where ai+l l= PA-Q, b i+~ l=-p \nA Q, ci+~ 1= P A Q, and di+l 1= P A Q. Details are given in the full paper. o Proof of Lemma 5.2: Suppose \nM = (S, X,L) and M,x,y 1= p. Let Xl {z~X[y~z}andMl= (S,X1,L). It is easy to check that Ml,x,y [= p. TO \nsimplify the notation, assume for now that Xl is countable (the case where Xl is uncountable is considered \nbelow) and consists of the distinct paths x=x0,xl,x2,x3, . . . . We now unwind Ml into a tree-like model. \nDefine a set T = {tij I i,j ~ O} fresh of states distinct from S. we WiII inductively define a set of \npaths X = {YO, Yl, Y2, ...} over T which is fusion closed along with a mapping h:T --> S as follows: \nSuppose X. = (so, s1, . . ..sk.. ) (which could be finite or infinite) . Then define y. = (tO(),t()l, \n. ..tOk).) and . h(toj) = sj for all j. We can extend h so that if y = (Uo, . . ..um.. ) then h(y) = \n(h(uo), . . ..h(um)) .). Note that h(yo) = XO, Now suppose we have constructed the paths yi for all j \n< i so that h(yj) = xi. We now define yi = (tk:,j) where for all j < 1-+ [xil kj is the least k such \nthat the length j stage of Xk is also a stage of xi. Now , extend h so that h(yi) = Xi. Let T consist \nof those states of T which occur in yi fOr sOme i. Also let L be a labelling of states in T such Then \nwe can show, by a straightforward induction on the structure of formulae, that for any formula q, if \n[wI ~_ [yl then M ,z,w I=q iff M,h(z),h(w) I=q. Next define X = {xi I xc X }. Using the observations \nthat no state occurs twice along any path, and that two paths have a state in common iff they have a \ncommon prefix including the state, it is easy to check that X is fusion closed and suffix closed, Let \nM = (T ,X ,L ). Then we can argue by induction on the length of formulae q, that for x~X , M ,x,y 1= \nq iff M ,x,y 1= q. Thus, M,, is a fu,ion closed and suffix closed model of P. If xl is not countable, \na similar argument goes through (although we seem to need the well ordering principle -which is equivalent \nto the axiom of choice -to order the paths first). O  8. REFERENCES [AB80] Abrahamson, Expressiveness \nPhD Thesis, K., of Univ. Decidability Logics of of Washington, and Processes, 1980. [BMP81] Ben-Ari, \nM., Manna, The Temporal Logic of Annual ACM Symp. Programming Languages, Z., and pnueli, Branching Time. \non Principles 1981. A 8~~ of [cE81] Clarke, and Skeletons E. M., Synthesis using and Emerson, of Branching \nE. A,, Design Synchronization Time Temporal Logic, Logics Lecture 1981. Proceedings of the of Programs, \nNotes in Computer IBM Workshop on Springer-Verlag Science //131, [cES83] Clarke, E. M., Emerson, E. A., \nand Sistla, Finite Practical 1983. A. P., Automatic State Concurrent Approach, this Verification Programs: \nPOPL conference, of A [EC80] Emerson, E. A., and Clarke, E. M., Characterizing Correctness Properties \nof Parallel Programs as Fixpoints. Proc. 7th Int. Colloquium on Automata, Languages, and Programming, \nLecture Notes in ComPuter 1981. Science #85, Springer-Verlag, [EC82] Emerson, E. A., Branching Time Synchronization \nTR-208, Univ. of in SCP) and Clarke, Logic to Skeletons, Texas, 1982. E. M., Using Synthesize Tech. Report \n(to appear [EH82] Emerson, E. A., Decision Procedures the Temporal Logic 14th Annual ACM Computing, 1982. \nand Halpern, J. Y., and Expressiveness in of Branching Time. Symp. on Theory of [EM81] [FL791 [GPss80] \n[HA82] [H081] [HKP80] [LA80] [MW81] [0L801 [PN77] [PN81] [PR57] [PR671 [RU71] [w081] [W082] Emerson, \nE. A., Alternative Semantics for Temporal Logics, Tech. Report TR 182, Univ. of Texas, 1981. (To appear \nin TCS) Fischer, M. J., and Ladner, R. E, propositional Dynamic Logic of Regular Programs, JCSS VO1. \n18, pp. 194-211, 1979. Gabbay, D., Pnueli, A., et al., The .. Temporal Analysis of Fairness. 7= Annual \nACM Symp. on Principles of Programming Languages, 1980. Halpern, J. Y., Deterministic Process Logic is \nElementary, to appear in FOCS, 1982. Hailpern, B., and Owicki, S., MOdular Verification of Concurrent \nPrograms Using Temporal Logic, Stanford TR, 1981. Harel, D., Kozen, D., and parikh, R., Process Logic: \nExpressiveness, Decidability, and Completeness, 12th Annual ACM Symp. on Theory of Computing, 1980. Lamport, \nL., Sometimes is Sometimes Not Never. 7th Annual ACM Symp. on Principles of Programming Languages, 1980. \nManna, Z., and Wolper, P., Synthesis of Communicating Processes from Temporal Logic Specification, IBM \nWorkshop on Logics of Programs, Springer Verlag Lecture Notes in Computer Science #131, 1981. Owicki, \nS., and Lamport, L., Proving Liveness Properties of Concurrent Programs, Computer Systems Laboratory, \nStanford Univ., 1980. Pnueli, A., The Temporal Logic of Programs, 19th Annual Symp. on Foundations of \nComputer Science, 1977, Pnueli, A., The Temporal Logic of Concurrent Programs, Theoretical Computer Science, \nV13, pp. 45-60, 1981. Prior, A., Time and Modality, Oxford Univ. Press, London, 1957. Prior, A., Past, \nPresent, and Future, Oxford Univ. Press, London, 1967. Rescher, N., and Urquhart, A., Temporal Logic, \nSpringer-Verlag, Berlin, 1971. Wolper, P., Temporal Logic can be more Expressive, 22nd Annual Symp. on \nFoundationa of Computer Science, 1981. Wolper, P., Specification and Synthesis of Communicating Processes \nUsing an Extended Temporal Logic (Preliminary Version) , 9th Annual ACM Symp. on Principles of Programming \nLanguages, 1982.   \n\t\t\t", "proc_id": "567067", "abstract": "<p>Temporal logic ([PR57], [PR67]) provides a formalism fordescribing the occurrence of events in time which is suitable forreasoning about concurrent programs (cf. [PN77]). In definingtemporal logic, there are two possible views regarding theunderlying nature of time. One is that time is linear: at eachmoment there is only one possible future. The other is that timehas a branching, tree-like nature: at each moment, time may splitinto alternate courses representing different possible futures.Depending upon which view is chosen, we classify (cf. [RU71]) asystem of temporal logic as either a linear time logic in which thesemantics of the time structure is linear, or a system of branchingtime logic based on the semantics corresponding to a branching timestructure. The modalities of a temporal logic system usuallyreflect the semantics regarding the nature of time. Thus,in a logicof linear time, temporal operators are provided for describingevents along a single time path (cf. [GPSS80]). In contract, in alogic of branching time the operators reflect the branching natureof time by allowing quantification over possible futures cf.[AB80],[EC80]).</p><p>Some controversy has arisen in the computer science communityregarding the differences between and appropriateness of branchingversus linear time temporal logic. In a landmark paper [LA80]intended to \"clarify the logical foundations of the application oftemporal logic to concurrent programs,\" Lamport addresses theseissues. He defines a single language based on the temporaloperators \"always\" and \"sometimes\". Two distinct interpretationsfor the language are given. In the first interpretation formulaemake assertions about paths, whereas in the second interpretationthey make assertions about states. Lamport associates the formerwith linear time and the latter with branching time (although itshould be noted that in both cases the underlying time structuresare branching). He then compares the expressive power of lineartime and branching time logic. Based on his comparison and otherarguments, he concludes that, while branching time logic issuitable for reasoning about nondeterministic programs, linear timelogic is preferable for reasoning about concurrent programs.</p><p>In this paper, we re-examine Lamport's arguments and reachsomewhat different conclusions. We first point out some technicaldifficulties with the formalism of [LA80]. For instance, thedefinition of expressive equivalence leads to paradoxicalsituations where satisfiable formulae are classified as equivalentto false. Moreover, the proofs of the results comparing expressivepower do not apply in the case of structures generated by a binaryrelation like those used in the logics of [FL79] and [BMP81]. Wegive a more refined basis for comparing expressive power thatavoids these technical difficulties. It does turn out thatexpressibility results corresponding to Lamport's still hold.However, it should be emphasized that these results apply only tothe two particular systems that he defines. Sweeping conclusionsregarding branching versus linear time logic in general are notjustified on this basis.</p><p>We will argue that there are several different aspects to theproblem of designing and reasoning about concurrent programs. Whilethe specific modalities needed in a logic depend on the precisenature of the purpose for which it is intended, we can make somegeneral observations regarding the choice between a system ofbranching or linear time. We believe that linear time logics aregenerally adequate for verifying the correctness of pre-existingconcurrent programs. For verification purposes, we are typicallyinterested in properties that hold of all computation paths. It isthus satisfactory to pick an arbitrary path and reason about it.However, there are applications where we need the ability to assertthe existence of alternative computation paths as provided by abranching time logic. This arises from the nondeterminism - beyondthat used to model concurrency - present in many concurrentprograms. In order to give a complete specification of such aprogram, we must ensure that there are viable computation path acorresponding to the nondeterministic choices the program mightmake. (An example is given in section 6.) Neither of Lamport'ssystems is entirely adequate for such applications.</p><p>In order to examine these issues more carefully, we define alanguage, CTL*, in which a universal or existential path quantifiercan prefix an arbitrary linear time assertion. CTL* is an extensionof the Computation Tree Logic, CTL, defined in [CE81] and studiedin [EH82]. This language subsumes both of Lamport's interpretationsand allows us to compare branching with linear time. Moreover, thesyntax of CTL* makes it clear which interpretation is intended.</p><p>The paper is organized as follows: In section 2 we summarizeLamport's approach and discuss its limitation. In section 3 wepresent the syntax and semantics of CTL*. We also define somenatural sublanguages of CTL* and compare their expressive power inSection 4. In particular, we show that (cf. Theorem 4.1) a languagesubstantially less expressive than CTL* still subsumes both ofLamport's interpretations. Section 5 then shows how CTL* can beembedded in MPL [AB80] and PL [HKP80]. Finally, section 6 concludeswith a comparison of the utility of branching and linear timelogic.</p>", "authors": [{"name": "E. Allen Emerson", "author_profile_id": "81452614401", "affiliation": "University of Texas, Austin, TX", "person_id": "PP43119618", "email_address": "", "orcid_id": ""}, {"name": "Joseph Y. Halpern", "author_profile_id": "81100537160", "affiliation": "IBM Research Laboratory, San Jose, CA", "person_id": "P149011", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/567067.567081", "year": "1983", "article_id": "567081", "conference": "POPL", "title": "Sometimes and not never revisited: on branching versus linear time (preliminary report)", "url": "http://dl.acm.org/citation.cfm?id=567081"}