{"article_publication_date": "01-24-1983", "fulltext": "\n Permission to make digital or hard copies of part or all of this work or personal or classroom use is \ngranted without fee provided that copies are not made or distributed for profit or commercial advantage \nand that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, \nto post on servers, or to redistribute to lists, requires prior specific permission and/or a fee. &#38;#169; \n1983 ACM 0-89791-090-7 $5.00 A term rwwr~t~ng sgstem is a set of oriented equations or rewrite rules \nthat are always used from left to right. In this framework, the method of proving an equational theorem \nlike A=B is to rewrite A and B using the rewrite rules until one gets irreducible terms A* and B::. If \nA* and B~c are the same then A=B is valid (see [8) for more details). The following question naturally \narises: Is this method a decision procedure? lo answer that, two problems must be addressed. 1. Is the \nirreducible expression A*, asso\u00adciated with A , unique? 2. Does the process of rewriting an expres sion \nA always terminate?  1.2. Proving confluence of term rewriting systems A positive answer to the second \nquestion follows from the confhence of the term rewriting system (also called the Church-Rosser property \nor diamond lemma property). That means that if A rewrites to B and C, there exists an expression D such \nthat B and C rewrite to D (using the relation of the term rewriting system zero or more times). A computer \nprogram checking for confluence was developed by Knuth and Bendix (111 based upon the work of Evans [2]. \nA term rewriting system is locally confluent if for any A which rewrites to B and C by using a rewriting \nrelation once in each case, there exists a D such that B and C rewrite to D, We can deduce confluence \nfrom local conflu ence if we have uniform termination. A term rewri ting system is uniformly terminating \nif there exists no infinite chain AO >A1 > . .. >An > . . . where -> is the rewriting relation. Therefore, \nuniform termination is a central issue in term rewriting systems and in proof systems for equational \ntheo\u00adries, not only because of the first question above, but also because of its necessity in gua\u00adranteeing \nthat confluence follows from local confluence. We says that a term rewriting system is eonve~gent if \nit is uniformly terminating and confluent. A finite convergent term rewriting system is the basis of \na decision procedure for its associated equational theory. Given a set of equations, the corresponding \nset of rules is not always convergent . For ins\u00adtance, the set of equations x*e =Z, x$i (x) ze, (Z*y)*Z \n= z*(y*z), and z/y = c*i (y), which defines the class of all groups with right division, may be converted \ninto the term rewriting system X.%e > z .r*i(z) > e (G.+y) %3 + &#38;.(y..z) x/y > x*i (y) which is \nnot convergent, as are none of the systems obtained by orienting these four equations in various ways \n. For example e and z*(y*i (x*y) ) are two irreducible terms obtained by rewriting the term (z*g) *i(x*y). \nThe Knuth Bendix algorithm attemps to transform a set of equations into an equivalent convergent term \nrewriting system. Equivalent means that the reduction method based on the convergent term rewriting system \nproves the same equational theorems as the method based on the original set of equations. In other words, \nthe resulting term rewriting system is a decision pro cedure for the original equational theory. The \nKnuth Bendix algorithm generates new equations which are oriented to make new rules . The orienta tion \nof an equation is done by a specific algorithm which checks that the rule preserves the uniform termination \nof the entire system. By using these new rules some old rules may be modified or even collapse and disappear. \nFor example, with the above group equations, the algorithm generates the rule z*(y*i(x*y)) > e which \nwill disappear when the rule i(z*y) >i(y) ai(x) is generated. It turns out that we can generate two distinct \nbut equiva lent convergent term rewriting systems from the above example depending on which operation, \n+ or /, plays the main role (see Fig.1, Fig. 2and Appendix II for a proof of termination). The second \none is new and was generated by REVE. x+e >x e*s >z xtii(z) >e i (x) .+x > e (z*y) *Z -> Z*(y*z) z.+(i(x)~y) \n> y i(x)*(x*y) >y i(e) +e i(i(x)) +x i(x~y) > i(y) *i(z) x/Y + x+i (Y) Fig. 1. The Knuth Bendix Convergent \nSystem for Group Theory with Right Division. x/e +x e/z + i(x) x/x >e x/(.y/a ) + (x/i(Y))/ z (x/y) \n/i (y) -> x (x/i (y) )/y -> x i(e) > e i(i(x)) +x i(x/y) >y/x x*y > x/i (y) Fig. 2. A New Convergent \nSystem for Group Theory Based Upon Right Division. 1.3. Proving uniform termination of term rewriting \nsystems The uniform termination problem for term rewriting systems is an undecidable problem (Huet and \nLankford [6) , Lipton and Snyder [14]), but we want REVE to provide powerful and mechanized tools that \ncan be used in most practical situations, and which do not require that the user know much about how \ntermination algorithms work. In most cases, REVE does the proof automatically without intervention from \nthe user. The method is based on simplification orderings. A partial ordering on terms is a simplification \nordering if it satisfies the following two properties, for all A, Al, A2: ,!hbtmm Property: A < f(. ..,A) \n...). 100 CompatLb~l~ty Property: A1<A2*f(. ... A1,, )<)< f(, ... A2,. ..). Dershowitz [1] proved the \nfollowing theorem: A term rewriting system X = {li >rili 61} with a finite number of symbols is uniformly \nterminating if there exists a simplification ordering < such that for all i in 1 and for all substitutions \no of ground terms for va riables, O(li) > o(ri). In REVE there are actually two uniform ter mination \nalgorithms. One is based on the ~~ecursive path o~~deving (written ~ here) derived from the work of Plaisted \n(17), Dershowitz [11, and Kamin &#38; L6vy (10), and the other on a recursive deeomposi t;on ordering \n(written ~ here) developed by Jou2nnaud, Lescanne and Reinig (91. Let us now give an informal description \nof them. Both are exten\u00adsions of a precedence that is an ordering on the basic symbols. In addition, \nthe recursive path ordering requires knowledge of the status of the operator symbols. The status can \nbe multiset , left-to-right or righkto-left . Typically with a left-to-right symbol we first look at \nthe left\u00ad most direct subterrss, so we consider a right\u00adleaning term to be less than another with the \nsame s~bOls and variables. Thus, if + has a left-to\u00adright status, ,then for the associative equation \nwe have (cc+y)+z ~ x+(y+z). The right to left status is symmetric: if + has a right to left status we \nhave X+(y+!zj) j (X+y)+z. With a multiset status we look at all the direct subterms in any order to find \nthose to be compared. For example, with a multiset status for +, (tr+u)+~ and &#38;+(y+z) are not ordered \nwith respect to ~, but we do have c+(y+z) j Z+C. The recursive path ordering compares the terms by first \nexamining their root symbols and then recur sively comparing terms and their direct subterms according \nto a strategy determined by the value of that comparison. The decomposition ordering works in a different \nmanner. It first processes the terms in order to build their decompositions. A decomposition records \nthe results of a careful analysis of a term; it determines which symbols, called Zeaders, play significant \nroles with res pect to their positions in the term and to a given precedence. Then it compares the decompositions \nfollowing a specific strategy. In general, the recursive decomposition ordering and the recursive path \nordering yield similar results when comparing two terms. However, there exist some pairs of terms that \ncan be com pared with ~ and not ~ when all symbols have multi set status (as in the original Dershowitz \ndefini tion); the reverse is true when right to left and left-to-right status is permitted. However, \nthe main advantage of the recursive decomposition ordering over the recursive path ordering lies in a \nproperty that the authors call incrementa~ity. Indeed, when the recursive decomposition method fails \nto orient terms, it suggests enlargements of the precedence. These enlargements are a set of ordered \npairs of symbols, which are extracted from the leaders of both terms. In many cases, REVE decides to \nadd all the suggestions to the prece\u00addence; in others, it asks the user to indicate which one it must \nkeep. Thus, the precedence is built up step by step by REVE and in general requi\u00ad res no intervention \nfrom the user. The orderings ~ and ~ are monotonic with respect to the prece\u00ad dence; i.e., when a new \npair is added to the pre\u00adcedence, new pairs of terms may be added to ~ and ~, but none are removed or \nchanged. Because of this monotonicity, the enlarged ordering is consis\u00adtent with the previous ordering, \nand so the final decomposition ordering can be built incrementally. In our experiments with abstract \ndata types, user help is only needed before starting the Knuth- Bendix compl etion algorithm (except \nfor changing the status of an operator). He or she is asked to give: 1. a presentation of the equations \nin the direc tion that should yield a uniformy terminating term rewriting system of rule, (the user just \nfollows his or her intuition in doing this), and 2. a declaration of the constructors of the data types \nREVE can then initialize a precedence by assuming that each constructor is less than each non constructor. \n Intuitively an operation ~ is less than another operation g with respect to the precedence if f is \ncomputationally less complex than g. In this hierarchy the constructors are at the bottom because they \nare not defined in terms of other operations. k its current formulation, the recursivedecom position \nordering cannot be used to prove the uniform termination when some equations describe the asso ciativity \nof an operation or a related property. Onthe other hand because of its incremental property it can construct \nthe precedence which will prove the uniform termination of the rules. In REVE it is possible to combine \nthe recursive decomposition ordering and the recursive path ordering in such a way that the recursive \npath ordering is used to orient the equations and the recursive decomposition ordering is called for \nhelp; i.e., for enlarging the precedence when the recursive path ordering fails. The recursive decomposition \nordering then provides the suggestions that the recursive path ordering needs . 1.4. Proof of inductive \ntheorems Huet and Hullot (7) developed a method to prove inductive theorems without explicitly invo\u00adking \ninduction that simplifies the work of Musser (15] and Goguen (3). They used a modified version of the \nKnuth-Bendix completion algorithm. Their inductionless induction works as follows: To prove an inductive \ntheorem, you add the statement to a given convergent set and try to generate a new convergent set while \nchecking that a few simple form conditions are satisfied. If the algorithm succeeds, your statement is \na theorem. If it fails by generating a forbidden equation (like a relation between the constructors) \nyour statement is not a theorem. If it runs forever you can say nothing; perhaps by presenting your theorem \nin a different way or adding lemmas you could succeed. A justifi\u00adcation of this method is based on the \nassumption that the non-constructors are well defined . Intuitively, that means that the equations comple\u00adtely \ndefine these operations without ambiguities. The easiest way to check this well definition is based onthe \nuniform termination associated with confluence and some syntactical properties of the left-hand side \nof the rules. These ideas are gene ralized by Lanlcford (131 to congruence class term rewriting systems \nwhose congruence classes are all finite. He also says, In our opinion, proving the finite termination \nproperty for a set of reductions claimed to be complete may turn out to be the most difficult part of \nthe inductionless induction approach. (It is obviously the part that many term rewriting researchers \ncontinue to neglect in their experiments. ) . In REVE we have given special atten tion to the uniform \ntermination problem. 2. OTHER ASPECTS OF REVE AND CONCLUSION 1. REVE was used to prove results in algebra \nthat were never before done by computer; e.g. ,that the equation z/((((z/x)/y)/z)/(((x/x)/z)/z) ) = y \ndetermines groups (Higman and Neuman (4)). The proof provided by REVE is conceptually simpler than that \nof Higman and Neuman, but could not be done by hand. REVE was also able to solve a problem posed by Knuth \nand Bendix [111, about Taussky s axioms for groups (191. Indeed it generated the con fluent rewriting \nsystem of Figure 1 from these axioms. 2. Other unification algorithms will be im\u00adplemented, for example, \nto handle equational theo\u00adries with commutative or associative and commuta tive operators, and more generally \nunification that can be described by rewriting systems and sets of equations as proposed by J.P. Jouannaud, \nC.Kirchner and H. Kirchner (20]. 3. REVE is written in CLU, so it consti\u00adtutes an interesting application \nfor object oriented languages based on abstract data types and modularity. Advantages for reliability, \nreadability and maintenance will be described in a forthcoming report.  As we have emphasized the uniform \ntermination is an important and often neglected aspect of deci sion and proof methods based on rewriting. \nAmong softwares that manipulate rewriting systems, the originality of REVE lies in its ability to easily \nprove uniform termination. Especially, the incre mental increase of the operator precedence derived from \nproperties of the recursive decomposition ordering needs little intervention from the user, and requires \nlittle knowledge about how the temi nation algorithm works. The examples that follow in Appendix I partially \nillustrate REVE S ease and flexibility in proving and disproving properties of abstract data types. . \n Acknowledgements: I would like to thank Dallas Lankford and Randy Forgaard who read care fully a preliminary \nversion of this paper and pro\u00advided useful comments. John Guttag welcomed me at MIT Laboratory for Computer \nScience and without him this work would never be done. I am grateful to Paul Johnson, Jean-Pierre Jouannaud, \nBob Sheifler and Jeannette Wing for their friendly help and also to Nachum Dershowitz, Samuel Kamin, \nJean-Jacques L6vy and Fernand Reinig for discussions about their algorithms. 3. REFERENCES 1. Dershowitz \nN., Orderings for Term Rewriting Systems, Proc. 20th Symposium on Foundations of Computer Science, (1979), \n123-131. Also, Theoretical Computer Science 17 (1982), 279\u00ad 301. 2. Evans T., On Multiplicative Systems \nDefined by Generators and Relations, I. Normal Form Theorems, Proc. Cambridge Philos. Sot. 47 (1951), \n637-649. 3. Goguen J.A., How to Prove Algebraic Inductive Hypotheses Without Induct ion, 5th Conf. On \nAutomated Deduction, Lectu?e Notes in ComputeY Science, 87 (1980), 356-373. 4. Higman G., Neumann B. \nH., Groups as Groupoids with One Law, Publ. Math. Debreeen. 2 (1952), 215-221.  5. Huet G., A Complete \nProof of Correctness of the Knuth-Bendix Completion Algorithm, J. Comp. S$S. SC. , 23 (1981), 11-21. \n 6. Huet G., Lankford D., On the Uniform Halting Problem for Term Rewriting Systems, RCZPPOYZ Laboria \n283 (mars 1978).  7. Huet G., Hullot J., Proofs by Induction in Equational Theories with Constructors, \nPPoe. 21st Symposium on Foundations of Compute? Science (1980).  8. Huet G., Oppen D.C., Equations and \nRewrite Rules: A Survey, in Formal Languagee: Pe? speetives and Open Problems, Ed, Book R., Academic \nPress (1980). Also, Technical Report CSL 11, SRI International (Jan. 1980).  9. Jouannaud J.P., Lescanne \nP., Reinig F., precur\u00adsive Decomposition Ordering, Conf. on Formzl Description of Pi?ograiwning Concepts, \nGarmisch, (1 982). 10. Kamin S., L&#38;y J.J., Attempts for Generalizing the Recursive Path Ordering, \n(Feb. 1980). 11. Knuth D. E., Bendix P. B., Simple Word Problems in Universal Algebras, in Computational \nPTO blems in Abstract Algebra, Ed. Leech J., Perga\u00admon Press (1969), 263-297. 12. Lankford D., Research \nin Applied Equational Logic, Louisiana Tech. Univ., Math. Dept., repOrt MTP-15, (Dec. 1980). 13. Lankford \nD., A Simple Explanation of Induction\u00adless Induction, Louisiana Tech. Univ., Math. Dept. , report MTP-14, \n(August 1981). 14. Lipton R., Snyder L., On the Halting Problem for Term Replacement Systems, Proe. \nConf. on Theoretical Comp. Sci. , Univ. of Waterloo,  (ju ly 1977), 43-46, 15. Musser D.L., On Proving \nInductive Properties of Abstract Data Types, P?~oc. 7th ACW Sympo sium on PYi?leipl@ of Programming \nLanguages  (1980), 154-162.  16. Novikov P., The Algorithm Unsolvability of the World Problem for Group \nTheory, Tr. Mut. Inst. Steklov. 44 (AMS Translations Se~ ies 2 9 (1955) 1-124). 17. Plaisted D., A \nRecursively Defined Ordering for Proving Termination of Term Rewriting Systems, Dept. of Computer Science, \nReport 78-943, Univ. of Illinois at Urbana-Champaign, (sept. 1978). 18. Post E., Recursive Unsolvability \nof a Problem of Thue, J. Symb. Logic 12 (1947), 1-11. 19. Taussky O., Zur Axiomatik der Gruppen , Ergebnisse \neines Math. Ko~~oquiums Wien 4 (1963), 2-3. 20. Jouannaud J.P., Kirchner C., Kirchner H., Incremental \nUnification in Equational Theo\u00adries. Proc. Z@h Allerton Conf. on Communi\u00adcation, Control and Computing, \n(oct. 1982)  WpENDIX I -TWO EXAMPLES Italic comments are added by the author. Under ined parts are \ncommands entered by the user. EXAMPLE 1 -------\u00ad reve Hello! My name is REVE (dream in french). I am \na rewriting system laboratory. What do you want to do now? (Type ? for help) read Which one? set A \nspecification of sets of natzcral numbers uith has and < ( subset). Your system is now: 1 if(tt, x,y) \n== x 2 if(ff,x,y) == y 3 if(x,y,y) == y 3 and 4 are inductive theorems L if(x,tt,ff) == x of boo2eans. \n5 (0=0) == tt o is the operator correspon 6 (O=s(x))== ff ding to zero. 7* (S(x)=o) == ff s is the operator \nsuccessor. 8 (s(x)=s(y))==(x=y) llquations 5,6,7 and 8 define 9 has(empty set,x)==ff an operator = used \nin the Equation 10. 10 has((u+x),y)==if((x=y),tt,has (u,y)) + is inse~t. 72as(21, z) means u has 2: \nor x belongs to aft. 11 (empty_set<v)==tt < is for subset. 12 ((u+x)<v)==if(has(v,x) ,(u<v),ff) REVE \ninitializes the precedence and deela~es the eonstnctors, REVE will use this in proofs of induction theo~ems. \nThe constructors are ff, tt, o, s empty set, +.  What do you want to do now? (Type ? for help) cons \n~ me a list of symbols ff tt 0 s empty_set-+ What do you want to do now? (Type ? for help) kb i Knutlz \nBendi.c uith incremental decomposition ordej~ing is used. In a first part REVE orients the equations \ninto rules. New rule added if(tt,x,y) ->x New rule added if(ff,x,y) >y New rule added if(x,y,y) ->y \nNew rule added if(x, tt, ff) >x New rule added (0=0) ->tt New rule added (O=s(x)) ->ff New rule added \n(S(x)=o) ->ff New rule added (s(x)=S(y)) ->(X=Y) New rule added has(empty_set,x) ->ff New rule added \n(empty_set <v) >tt REVE adds tuo nou pairw. I suggest that the following ordered pairs beaddect if < \nhas REVE S suggestions. = < has to validate the rule has((u+x),y) -> if((x=y),tt,has(u,y)) New rule added \nhas((u+x),y) -> if((x=y),tt,has(u,y)) REVE adds again two neu pairs. I suggest that the following ordered \npairs bealded: if<< has<< . to validate the rule ((u+x) <v) -> if(has(v,x), (u<v),ff) New rule added \n((u+x) <v) -> if(has(v,x),(u<v),ff) In a second part REVE looks for er-ztieal pairs and it does not \nfind any. I am computing the critical pairs with (0=0) ->tt I am computing the critical pairs with has(empty \nset,x) >ff I am computing the critical pairs with (empty_set <v) ->tt I am computing the critical pairs \nwith if(tt, x,y) >x I am computing the critical pairs with if(ff, x,y) >Y I am computing the critical \npairs with if(x,y,y) >y I am computing the critical pairs with if(x,tt,ff) ->x I am computing the critical \npairs with (O=s(x)) ->ff I am computing the critical pairs with (S(x)=o) ->ff I am computing the critical \npairs with (s(x) =S(Y)) ->(x=y) I am computing the critical pairs with has((u+x),y) -> if((x=y),tt,has(u,y)) \nI am computing the critical pairs with ((u+x) < v) ->if(has (v, x), (u<v), ff) The system is consistent \nand the Knutlz Bendix algorithm has transformed tlze previous set of equations into a confluent and noethe \nrian (convergent) set of rwles. Your convergent system is now : 1 if(tt,x,y) ->x 2 if(ff, x,y) -> y 3 \nif(x, y,y) ->Y 4 if(x,tt,ff) ->x 5 (0=0) ->tt 6 (O=s(x)) ->ff 7 (S(x)=o) ->ff 8 (s(x) =S(y)) -> (X=y) \n9 has(empty set,x) >ff 10 (empty_se~ <v) ->tt 11 has((u+x), y) ->if((x=y), tt, has(u, y)) 12 ((u+x) <v) \n->if(has (v, x), (u<v), ff) PROOF OF A THEORRM ----------------- What do you want to do now? (Type ? \nfor help) a The user adds the identity to be proved. cf. $ 1.3 Type your new rules or equations. It or \nthey must be terminated by a , has((u+x) ,x) == tt. Your system is now: 1 if(tt,x,y) >x 2 if(ff;x,y) \n>y 3 if(x,y,y) >y 4 if(x,tt,ff) >x 5 (0=0) ->tt 6 (O=s(x)) ->ff 7 (S(x)=o) ->ff 8 (s(x) =S(y)) ->(x=y) \n9 has(empty set, x) ->ff 10 (empty se~<v) ->tt 11 has((u~x),y) -> if((x=y),tt,has(u,y)) 12 ((u+x) <v) \n-> if(has(v,x), (u<v),ff) 13 has((u+x) ,x) == tt What do you want to do now? (Type ? for help) kb i \nThe Left-hznd side of the gi~len equation is ?educed and the neu created equation is transformed. into \na rule. New rule added if((x=x), tt,has(u,x)) ->tt I am computing the critical pairs with if((x=x),tt,has(u,x) \n) ->tt New rule added if((x=x),tt,has(y,s(x) )) >tt New rule added (x=x) ->tt is an inductive theorem \nof the natural numbaw. The left hand side of the following rule is now reducible (0=0) ->tt The left \nhand-side of the following rule is now reducible if((x=x),tt,has (u,x)) >tt The left hand-side of the \nfollowing rule is now reducible if((x=x),tt,has(y,s(x) )) ->tt I am computing the critical pairs with \n(x=x) -~tt Your convergent system is now: 1 if(tt,x,y) >x 2 if(ff, x,y) >y 3 if(x,y,y) ->y 4 if(x,tt,ff) \n>x 5 (O=s(x)) ->ff 6 (S(x)=o) ->ff 7 (s(x)=S(Y)) ->(x=y) 8 has(empty_set,x) ->ff 9 (empty_set <v) ->tt \n10 has((u+x),y) -> if((x=y),tt,has(u,y)) 11 ((u+x) <v) -> if(has(v,x), (u<v),ff) 12 (x=x) ->tt PROVING \nTHAT A STATEMENT IS NOT A THEOREM - -- -- -- - ---- - - ---- -- What do you want to do now? (Type ? \nfor help) a The user adds tha identity to be proved (OY disproved!). Type your new rules or equations. \nIt or they must be terminated by a . ((u+x) < (v+x)) == (u < v), Your system is now: 1 if(tt,x,y) >x \n2 if(ff,x,y) ->y 3 if(x,y,y) ->y 4 if(x,tt,ff) ->x 5 (o=.(x)) ->ff 6 (S(X)=O) ->ff 7 (s(x)=S(y)) ->(x=y) \n8 has(empty set,x) ->ff 9 (empty se; < v) ->tt 10 has((u~x),y) -> if((x=y),tt,has(u,y)) 11 ((u+x) <v) \n-> if(has(v,x), (u<v),ff) 1~ (x=x) ->tt 13 ((u+x) <(v+x)) == (u<v) What do you want to do now? (Type \n? for help) kbi New rule added (u < (v+x)) -> (u < v) The left hand side of equa tion 13 is reduced \nby 11, 10, 12, 1 and is transformed into a rule. I am computing the critical pairs with (u<(v+x)) ->(u<v) \n New rule added if(if((y=z),tt,has (x, z)), (u<x),ff) -> if(has(x,z), (U<x),ff) I am computing the critical \npairs with if(if((y=z),tt,has(x,z) ),(u<x),ff) > if(has(x,z),(u <x),ff) New rule added if(if((x=y),tt,has(z,s \n(y))), (u<z),ff) -> if(has(z,s(y) ),(u<z),ff) New rule added if((x=y), (z<empty_set) ,ff) ->ff New rule \nadded if((x=y),tt,has(z,y)) ->has(z,y) The left hand-side of the following rule is now reducible if(if((y=z),tt,has(x,z) \n),(u<x),ff) > if(has(x, z), (u<x), ff) New rule added if(has(x,y), (z<x),ff) ->(z<x) I am computing \nthe critical pairs with if((x=y),(z <empty set),ff) ->ff New rule added (X=y) ->ff The left hand side \nof the following rule is now reducible (O=s(x)) ->ff The left hand-side of the fo lowing rule is now \nreducible (S(x)=o) ->ff The left hand side of the fo lowing rule is now reducible (s(x) =S(Y)) ->(X=Y) \nThe left hand-side of the following rule is now reducible (x=x) ->tt The left hand-side of the following \nrule is now reducible if(if((x=y),tt,has(z,s (y))), (u<z),ff) > (u<z) The left hand side of the following \nrule is now reducible if((x=y),(z <empty set),ff) >ff The left hand-side of the following rule is now \nreducible if((x=y),tt,has(z,y)) >has(z,y) The rule (z=y) ->ff is incompatible uitk the rule (x=x) ->tt. \n **Your theorem is false, or your specification is not consistent** I deduced the following equation \nff ==tt A PROOF RUNNING FOREVER -------- -- - -.- - what do you want to do now? (Type ? for help) \na Type your new rules or equations. It or they must be terminated by a . (u<(u+x)) == tt. Your system \nis now: 1 if(tt,x,y) >x 2 if(ff,x,y) ->y 3 if(x,y,y) ->y 4 5 6 7 8 9 10 11 12 13 if(x,tt,ff) >x (O=s(x)) \n->ff (S(x)=o) ->ff (s(x) =S(Y)) ->(X=Y) has(empty set,x) ->ff (empty se~<v) ->tt has((u~x),y) -> if((x=y),tt,has(u,y)) \n((u+x) <v) -> if(has(v,x), (u<v),ff) (x=x) ->tt (u<(u+x)) == tt What kbi do you want to do now? (Type \n? for help) New rule (u<(u+x)) added ->tt I am computing (u< (u+x)) ->tt the crit cal pairs with New \nrule added (X<((x+y)+z)) ->tt I am computing (X<((x+y)+z)) the ->tt crit cal pairs with New rule added \n(X<(((x+y)+z)+u)) ->tt I am computing (x< (((x+y)+z)+u)) the critical ->tt pairs with New (X< rule added \n(((x+y)+z)+u)+v)) ->tt I am computing the critical (X<((((x+y) +z)+u)+v)) ->tt pairs with EXAMPLE 2 \n- - - \u00ad reve Hello! My name is REVE (dream in french). I am a rewriting system laboratory. What do \nyou want to do now? (Type ? for help) read Which one? fib A specification of the natural nurnbezw and \ntwo definitions of the Fibonaeci function. Your system is now: 11011is the operator correspon ding to \nzero. 2 (S(x)+y) == S((x+y)) 3 ((x+Y)+z) == (x+(y+z)) czssociatiivitg is an i.nductiue theorem. 4 fib(o) \n== o 5 fib(s(o)) == s(o) 6 fib(s(s(x))) == (fib(x) +fib(s(x))) the classi cal definition of the Fibonacci \nfunction. 7 dfib(o,y) == y 8 dfib(s(o),y) == s(y) 9 dfib(s(s(x)),y) == dfib(s(x),dfib(x,y)) another definition \nof the Fibonacci function @ithout reference to addition. 1 (0+x) == x %eonstrueto~~s of the natural numbers \nare oand s. What do you want to do now? (Type ? for help) cons Give me a list of symbols 0s What do \nyou want to do now? (Type ? for help) libri Knuth Bendix with recursive path ordering helped by the ~ecumi~~e \ndecomposition ordering fo~ adding paim of symbols to the precedence. New rule added (0+x) ->X New rule \nadded (S(x)+y) ->s((x+y)) New rule added fib(o) >0 New rule added fib(s(o)) -> s(0) New rule added dfib(o,y) \n->y New rule added dfib(s(o),y) ->s(y) dfib is decla?ed as having a left-to-right status. Notice that \ntiith a multiset status, the equation uould be oriented in the oppo site direction. REVE takes the presentation \ninto account. Would you like to set the status of an operator to validate the equation? (YIN) dfib(s(s(x)),y) \n== dfib(s(x),dfib(x,y)) Y ~ive me a symbol or ask for help(?) dfib Give the status RL or LR lr ~ you \ndon t change the ordering for the other rules. New rule added dfib(s(s(x)),y) -> dfib(s(x),dfib(x,y)) \n I cannot suggest any ordered pair to validate the equation ((X+Y)+Z) == (X+(y+z)) + is declared as \nhaving a left to right status. Would you like to set the status of an operator? (YIN) Y Give me a symbol \nor ask for help(?) + ~ive the status RL or LR lr ~ you don t change the ordering for the other rules. \n New rule added ((x+y)+z) ->(x+(y+z)) REVE adds the pair + < fib, I suggest that the following ordered \npair be added: + < fib to validate the rule fib(s(s(x))) -> (fib(x)+fib(s(x))) New rule added fib(s(s(x))) \n-> (fib(x)+fib(s(x))) I am computing the critical pairs with fib(o) ->0 I am computing the critical \npairs with (0+x) ->X I am computing the critical pairs with fib(s(o)) -> s(0) I am computing the critical \npairs with dfib(o,y) ->y I am computing the critical pairs with (S(x)+y) ->s((x+y)) I am computing the \ncritical pairs with dfib(s(c),y) ->s(Y) I am computing the critical pairs with fib(s(s(x))) -> (fib(x)+fib(s(x))) \nI am computing the critical pairs with dfib(s(s(x)), y) ->dfib(s (x), dfib(x, y)) I am computing the \ncritical pairs with ((x+y)+z) ->(x+(y+z)) Your convergent system is now: 1 (0+x) >X 2 (S(x)+y) ->s((x+y)) \n3 fib(o) >0 4 fib(s(o)) -> s(0) 5 dfib(o,y) ->y 6 dfib(s(o),y) ->s(Y) 7 dfib(s(s(x)),y) -> dfib(s(x),dfib(x,y)) \n8 ((X+y)+Z) >(X+(y+Z)) 9 fib(s(s(x))) -> (fib(x)+fib(s(x))) PROOF OF DFIB(X Y) == (FIB(X)+Y) _-- _ -- \n------2---------------- What do you want to do now? (Type ? for help) a ~-ype your new rules or equations. \nIt or they must be terminated by a . dfib(x,y) == (fib(x)+y). the user adds the equation to be proved. \nYour system is now: 1 (c)+x) ->X 2 (S(x)+y) -> S((X+Y)) 3 fib(o) ->0 4 fib(s(o)) -> s(0) 5 dfib(o,y) \n>y 6 dfib(s(o),y) ->s(y) 7 dfib(s(s(x)),y) -> dfib(s(x),dfib(x,y)) 8 ((X+Y)+Z) ->(x+(y+z)) 9 fib(s \n(s(x))) ->(fib(x) +fib(s (x))) 10 dfib(x, y) == (fib(x)+y) What do you want to do now? (Type ? for help) \nkbri REVE proposes the psir fib < dfib. I suggest that the following ordered pair be added: fib < dfib \nto validate the rule dfib(x, y) -> (fib(x)+y) New rule added dfib(x,y) ->(fib(x)+y) The left hand-side \nof the following rule is now reducible dfib(o,y) ->y The left hand-side of the following rule is now \nreducible dfib(s(o),y) ->s(y) The left hand-side of the following rule is now reducible dfib(s(s(x)),y) \n-> dfib(s(x),dfib(x,y)) New rule added (fib(s(x))+(fib(x)+y)) -> (fib(x)+(fib(s(x))+y)) I am computing \nthe critical pairs with dfib(x,y) ->(fib(x)+y) I am computing the critical pairs with (fib(s(x))+(fib(x)+y)) \n-> (fib(x)+fib(s(x))+y)) The theorem is proved. Your convergent system is now: 1 (0+x) >X 2 (S(x)+y) \n-> S((X+Y)) 3 fib(o) ->0 4 fib(s(o)) ->s(0) 5 ((x+y)+z) -> (X+(y+z)) 6 fib(s(s(x))) -> (fib(x)+fib(s(x))) \n7 dfib(x,y) ->(fib(x)+y) 8 (fib(s(x))+(fib(x)+y)) -> (fib(x)+(fib(s(x))+y)) 8 is an inductive lemma r \nadded by REVE tihiclz has a flavor of commutativity, PROOF OF THE SAME THEOREM - - WITH A DIFFERENT PRESENTATION \n What do you want to do now? (Type ? for help) a Type your new rules or equations. It or they must \nbe terminated by a . (fib(x)+y) == dfib(x,y). the use? adds the same equation but he per\u00adrmtes left \nhand-side and right-hand side. Your system is now: 1 (0+x) >X 2 (S(x)+y) ->s((x+y)) 3 fib(o) ->0 4 \nfib(s(o)) -> s(0) 5 dfib(o,y) ->y 6 dfib(s(o),y) ->s(y) 7 dfib(s(s(x)),y) -> dfib(s(x),dfib(x,y)) 8 \n(( X+ Y)+Z) > (X+(y+Z)) 9 fib(s(s(x))) -> (fib(x)+fib(s(x))) 10 (fib(x)+y) == dfib(x,y) What do you \nwant to do now? (Type ? for help) kbri REVE p~oposes the pair dfib < ~[b. I suggest that the following \nordered pair be added: dfib < fib to validate the rule (fib(x)+y) ->dfib(x,y) It is not enough; REVE \nproposes dfib < +. I suggest that the following ordered pair be added: dfib <+ to validate the rule \n(fib(x)+y) ->dfib(x,y) New rule added (fib(x)+y) ->dfib(x, y) I am computing the critical pairs with \n(fib(x)+y) ->dfib(x,y) New rule added (dfib(x, y)+z) ->dfib(x, (y+z)) New rule added dfib(s(x),dfib(x,y)) \n-> dfib(x,dfib(s(x),y)) I am computing the critical pairs with (dfib(x,y)+z) ->dfib(x, (y+z)) I am computing \nthe critical pairs with dfib(s(x),dfib(x,y)) -> dfib(x,dfib(s(x),y)) Tile theorem is p~oved. Compare \nuith the previous proof. Your convergent system is now: 1 (0+x) ->X 2 (S(x)+y) -> S((X+Y)) 3 fib(o) \n>0 4 fib(s(o)) ->s(0) 5 dfib(o, y) ->y 6 dfib(s(o),y) ->s(Y) 7 dfib(s(s(x)), y) ->dfib(x, dfib(s(x), \ny)) 8 (( X+y)+Z) >(X+(y+Z)) 9 fib(s(s(x))) ->dfib(x, fib(s(x))) 10 (fib(x)+y) ->dfib(x, y) 11 (dfib(x, \ny)+z) ->dfib(x, (y+z)) 12 dfib(s(x),dfib(x,y)) -> dfib(x,dfib(s(x),y)) What do you want to do now? (Type \n? for help) q APPENDIX II . Proof of the termination of the examples Fig.1 and Fig.2. The example of \nFig.1 is proved using the recursive path ordering with left-to-right status for *, and with the precedence \ne < * < i < f. The example of Fig.2 is proved using the recursive path ordering with right-to-left status \nfor /, and with the precedence e < i m / < *. APPENDIX 111 Sketch of the definition of the recursive \ndecompo sition ordering (91. A decomposition of a term is a multiset (for all paths in the term) of \nsets (for all occurrences on the paths) of elementary decompositions. An ele mentary decomposition is \na quadruplet <Leader: symbol, main fol~ower: set (elemen tary decomposition), other-followers; multi \nset(term), context: set(elementary decompo sition)> The elementary decomposition of t (Fig.3) along \nthe path 21 at the occurrence 2is<~~,{<y,{},{} ,{}>},{z},d> where d is the set of elementary-decompositions \nof t along the path 2.   t= / NQ / \\. /*\\d/*:k.. =/+\\ x YYlz~ x Y ,. . ..-. Fig. 3. A term and a context \nThe ordering on two terms is the ordering on their decompositions, and the ordering on decompo sitions \nis obtained by set and multi set extension of the ordering on elementary decompositions. The or\u00addering \non elementary decomposition is given lexi cographically, recursively using orderings on set (elementary-decomposition) \nand multiset (terms). NBI : The decomposition of o is the empty multiset. NB2: Because set(set(elementary~ecomposition)) \ncontains enough information about the terms , we do not need multiset(set(elementary decomposition) ) \nin the definition. So only set extensions of the orde\u00adring are necessary. \n\t\t\t", "proc_id": "567067", "abstract": "A term rewriting system generator called REVE is described. REVE builds confluent and uniformly terminating term rewriting systems from sets of equations. Particular emphasis is placed on mechanization of termination proof. Indeed, REVE is one of the few such systems which can actually be called automatic because termination is fully integrated into the algorithms. REVE uses an incremental termination method based on recursive decomposition ordering which constructs the termination proof step by step from the presentation of the set of equations and which requires little knowledge of termination methods from the user. All examples from this paper are taken from abstract data type specifications.", "authors": [{"name": "Pierre Lescanne", "author_profile_id": "81100225321", "affiliation": "Centre de Recherche en Informatique de Nancy, Campus scientifique - B.P. 239, 54506 Vandoeuvre les Nancy Cedex, France", "person_id": "PP48023630", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/567067.567078", "year": "1983", "article_id": "567078", "conference": "POPL", "title": "Computer experiments with the <i>REVE</i> term rewriting system generator", "url": "http://dl.acm.org/citation.cfm?id=567078"}