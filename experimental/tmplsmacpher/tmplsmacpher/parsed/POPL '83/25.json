{"article_publication_date": "01-24-1983", "fulltext": "\n Permission to make digital or hard copies of part or all of this work or personal or classroom use is \ngranted without fee provided that copies are not made or distributed for profit or commercial advantage \nand that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, \nto post on servers, or to redistribute to lists, requires prior specific permission and/or a fee. &#38;#169; \n1983 ACM 0-89791-090-7 $5.00 The concepts discussed in this paper are taken from the programming language \nNIL, w}lich Ilas been designed and implemented at IBN s T.J. Watson Research Center and is being used \nto develop proto\u00adtypes for communications subsystems and distributed operating systems. NIL s design \nobjectives include (1) information hiding, (2) support for concurrency, (3) feasibility of secure implementations \nwith mini\u00admal run-time cost, (4) cfiicient implementation on a wide range of machine architectures, (5) \nconceal merit of the underlying operating system by st]pport. ing process creation , access control , \nand modl]le inter\u00adconnection as language prjmitivcs. NIL is more ful\u00adly described in [NIL 82], [PAR 81], \n[P,U? 8?], [HAL 82], [PAR 83].  BY contrast, the ri~strllcti~-t: scrld semantics allows flexibility \nin LILC choice of im;,lementation. A very efficient implementation, on a uniprocessor imple\u00adments a message \nvariable as a pointer to a block of storage containing: (1) the data fields, and (2) a chain pointer \nused when the message is cnqueued on a port. The allocate operation initializes the pointer by obtaining \nstorage from a heap or a quickcell list. Access. to sc:lectcd comI,olLcILts involves deref \u00aderencing \nthe pointer. Sending and reccit,ing involt,e updating tl:e chaitl poiILtcr fields without physically \ncopying any data. TYPESTATE HIDING POINTERS: EXAMPLE DEFINITION AND EXAMPLE The NIL approach to secllrity \ncan be illustrated by studying the design of the message type constructor, The message type constructor \ndefines individual mes\u00ad sage types. Each message type consists of a number of fields, which may themselves \nbe of any type. Fields in messogcs may be named using the standard selected componen I notation. In this \nrespect, NIL messages are just like records in PASCAL, ADA, or ALGOL-68. However, in these other languages, \nthe user builds records dynamically by using pointers. The pointer has a different name from the record \nitself and may be assigned to other pointer vari\u00adables, thereby introducing potential aliasing within \na process, or sharing of data between processes. In NIL, messages may likewise be built dynamically, \nbut no pointer is visible to the programmer. It is guar\u00adanteed that no two message variables reference \nthe same data. The following operations are applicable to NIL message variables: allocate obtains resources \nfor an empty message receive dequeues a message sent from another proc\u00adess over a @ (another NIL type \nconstructor) . send FIFO-enqueues a message to another process via a port. discard disposes of an empty \nmessage It is not permitted to read or update fields of a message after it has been sent. This rule ( \nde\u00adstructive sending), was deliberately chosen over an alternative eemantics of send in which the sender \ncould retain access to the message data. A language taking an alternative viewpoint must define either \n(1) that the sender keeps an independent copy of the data, or (2) that both sender and receiver share \nthe message. Both definitions are unattractive: The first alternative requires that send copy the mes\u00adsage, \nwhich on most hardware will be needlessly expensive. In addition, if the language hos vari\u00adables of types \nfor which copying is not supported, these variables could not be passed in messages. The second alternative \ninvolves the introduction of shared data, and the dangar that both sender and receiver may choose to \ndiscard the same message. The above definition of message semantics makes sense only if the above operations \nare performed in a particular sequence. For example: a field may not be written until the message has \nbeen allocated; a field may not been read until it has been written; a message once sent may not be read, \nwritten, or sent again, etc. It is undesirable to attempt to define the results of ocher orders of execution \nof the operations, such as send of an already sent message or update of a field in a message which has \nalready been sent. In fact, the suggested efficient implementation of send will fail in the event that \nthe seine message is sent twice. In NIL, @estate rules explicitly define the legal operation sequences. \nConformity to the typestate rules is checked at compile time as follows: For every type in the language, \nthere is a finite-state grammar (called a typestate grammar) which defines the valid operation sequences \non variables of that The states of SUCI) a grammar are called its tyIJe. Eve]-y variable has a typcstate \nwhich 9QS!lE ma>-vary fj-om statement t.o statement within the pro\u00adgram. The typestate of each variable \nis required to be a program invariant at each statement. I,, itially the typestate is l.1 ISITiALIZELl. \nTypcstatcs of suc\u00adcessive statements can be determined hy applying tile rules of the typestatc grammar \nto the program, If the typestate on entry to a statement A is known, thea the typestate on entry to statement \nB imme\u00addiately following A can be determined by applying the typestate transition for the operation associ\u00adated \nwith statement A. If two statements have the same successor, then the statements must yield iden\u00adtical \ntypes tates for all variables. A program is illegal i.f either (1) it contains a statement con\u00adtaining \nan operation which is not permitted in the typestate known to hold on entry to that statement, or (2) \nsome pair of statements S1 and S2 yield dis\u00ad tinct typestate ouLcomes but have the identical suc\u00ad cessor \nstatement. For example, Figure 1 illustrates the typestate grammar for a typical message type containing \ntwo scalar fields, F1 and F2. The typestates are UNINI-TIALIZED, EMPTY, F1 INIT, F2 INIT, and ALL INIT. \nThe state transitions are labeled with operations on a sample message variable N and its fields M.Fl \nand A II R/U/ M.F1 II I R/WW2 -ascard M.F2 nit discard M.F1 nit F RAN M.F1 F1 INIT F2 INIT init M.F1 \ninit M.F2 discard M.FI discard M.F2 send M rec ~ive M I  EMPTY discard M aiiocate M ~<: ~> > UNINITIALIZED \nFigure 1, Representative Typestate Diagram: This typical typestate ~ diagram shows the transitions possible \nfor a variable M of a message type containing two fields, Fl, and F2, each of scalar type (e.g. integer \nor string), M.F2. For example, a message must be ALL INIT before it is sent, and the send operation changes \nthe ,. typestate to UNINITIALIZED. Typestate transitions Porttype is port type of Mestype; associated \nwith exception outcomes of operations are ?lestype is message type not shown on this diagram, but are \ndiscussed in a (Fl: Charstring, subsequent section. It should be noted that discard F2: integer); operations \nare provided for the scalar fields F1 and ... F2 as well as for message M, even though in a typical declare \nimplementation space for F1 and F2 is preallocated (A_message: Mestype, with the message, A_port: Porttype \nsender); and these discard operations generate no code. The abstract operations exist in ... order to \npermit greater implementation flexibility, allocate A message; and to provide a useful model of process \nA_message~Fl = kLell O ; termination, which will be discussed in a later sec\u00ad A_message. F2 = 5; t ion, \nsend A_message to A port; !.. The definition of a sample message type, a sample port type, and the code \nwhich declares message and Figure 2. Typical message type correctly port variables and WUP1OYS a valid \n.aquenca of oper \u00ad used: The above program segmentations is illustrated in Figure 2. Examples of defines \na message type, a port type, illegal sequences are illustrated in Figure 3. In and objects Of those two \ndefined the particular representation of messages discussed types . The segment code allocates earlier, \nthese illegal sequences, if not explicitly the message variables, assigns its excluded, would result \nin the dereferencing of unin\u00ad two fields, and sends the message off itialized pointers. unreclaimed storage, \ndan.zling to another process. It is assumed references , or damaged free space lists, each of that the \nport variable has been which can cause a security breach or a failure to itself initialized earlier in \nthe reclaim resources \\iit n other choices of implemen\u00ad program.tations of the operations, the effects \nof the ille\u00ad gal sequences may be different. Segment (1) ..----..--\u00ad allocate A mw, sa:c; A_message~Fl \n= hclloi ; A message.F 2 = 5; send A mssoge to :\\_l, OI-I ; discard ~ message;  Segment (2) ---------a\u00ad \nllocate A mcsstige; allocate A-.mcss:,~c; Segment (3) allocate A_message; A_message. F2 = length (A_message. \nFl); send A_message to A_port; Figure 3, Illegal uses of message variables: These examples illustrate \nprogram segments which, though not violating any strong typing rules, misuse the message type by executing \noperations in the wrong order. In the absence of typestate checking, execution of these segments could \ncause program crashes in typical implementations, Segment (1) discards a message which ia in use in another \nprocess. Segment (2) overlays a pointer and hence produces an unreclaimable message, Segment (3) accesses \nan uninitialized string, which If strings are implemented with pointers to the heap, may cause a program \ncheck.   RATIONALE FOR INVARIANCE OF TYPESTATES NIL enforces security at compile time by: Forbidding \nall direct access to pointers, and supporting access to dynamic data only through the message types (and \nother secure data types).  Requiring that the typestate of all variables be known as an invariant associated \nwith each statement in th~ program, and guaranteeing that operations are Issued only from correct typestates. \n In order for typestates to be program invariants, whenever two-or more branches of a program converge, \nthe typestates immediately prior to the join must be the same. Programs which, for example, initialize \na variable in the then branch of a conditional state\u00adment and fail to initialize that variable in the \nelse branch, are illegal. Although security could be guaranteed by run-time checking of typestate, the \nchoice to check typestate at compile time has several advantages: . It rejects at compile time programs \nwhose erro\u00adneous code might not otherwise be detected until they had been widely distributed and used \nas components of a critical application. . It avoids the space and time overheads associ\u00adated with storing, \nchecking, and updating typestate information. It rejects certain pzograms with dubious prOgram structures \n The last point bears additional rilscusslon, 5iUce It reflects thL, NIL dc>ignrl-s bias that so ftwtire \nreli\u00adability can he gainc:d LY rc:stl-i~~ing he set f prO \u00adgrams Khicb a programmer is permitted tO write. \nconsider the program segment in Flgurc 4 xllich would be rejected as illegal under the tYPestate invar\u00adiance \nrule, even though a clever compiler might be able tO pro~.e that no typcstate vi Olati Oll cnuld ever \noccur. This progrlm create~ a half-inltiali~cd mes\u00adsage w-benever x bas the \\-alue 2, and creates no \nmes\u00adsage otherwise. The p.ths then Join (making the message s typestate ambiguous and therefore illegal \nNIL) . Some time later, theaccording to half-initialized message is processed, provided it is known \nto exist, which is determined by checking whether X has the value 2. ,.. ifX=2 then allocate A mc55age; \n,J_message-.Fl = hello ; end if; ,------middle part of program if~=2 then A_messagt:.F2 = ~; send A_message \nto A_port; end if; ambiguoua Figure 4. Program with typQstate: Assuming the middle Part is kell-i~chaved, \nthis prografi] will ne~,er execute an operation from an illegal ~ype~tatc. liuwever, It will still be \nrejected by NIL s strict interpretation Of the invariance the designers rule. It is contention that the \nexcluslon of such programs does no harm and could even encourage better program structuring. It is our \ncontention that thcr~ 1S always a clearer way to wrltc this. program, Winch b-ill provide better guidance \nto someone tryurg to mOdify it, and which will be typestate correct. Under one interpretation of the \nprogram, it is intended to execute the second then clause whenever the first then clause was execllted. \nSince in this case, the middle part cannot possibly alter the mes\u00adsage, it would be safer to combine \nthe two if blocks into a single test. The middle part can either be executed after the if block, or could \nbe enclosed in a subroutine invoked from both branches. As cur\u00ad rently written, it would be fatal to \nmodify the val\u00ad ue of X from within the middle part. (A programmer wishing to insert X = X + 1 into the \nmiddle part, and to replace the second test by if X = 3 deserves, in our opinion, to have his or her \nprogram rejected by even the smartest compiler.) On zl,e other halrl, if the midrile. part of the program \n. If c]ecnrlp oper~tions such as discard could contains code which conditionally re-al locates or conditionally \ndiscards the message, updating the value of X to reflect its choice, then the program mer xould do well \nto replace the message by a variant (discrimir,ated union) variable, in which one ~ase of the variant \ncontains a mrssage and the other is ern~\u00adty , The program theu reads more clearly, since tile programmer \ns test is explicitly askiag whether the message exists, rather than asking some other ques\u00adtion whose \nanswer is presumed to correlate with the existeace of the message. By replacing direct use of pointers \nby indirect use via the type construct or-s mess~~, table, and others not discussed here, ond by enforcing \ntypestate invariance, securit~-can be maintained h itliout impacting program cffi.ciclncy 01-I-e.affability. \nPARTIAL ORDERINGS ON TYPESTATES The interaction bet{;ecn Lhc invariance rule and !iIL s treacmcr,t of \ncx..copt ion !Iandlil!g and program termination lead to the additional requirement of a partial ordering \nrelation on types tate transition graphs . Consider the program fragment shown in Figure 5. The clause \nbeginning with on (I)epletion) receives control whenever the excep~ion collditiun named Depletion is \nraised within the begin block. The Depletion exceptioa is r~ised whenever storage is no t available to \nperform the allocate operation. When Depletion is raised, the message remains in typestate UNINITIALIZED \nrather than making the tran\u00adsition to EMPTY, Since typestate must be a compile-time invariant, the program \nfragment under discussion would be ille\u00adgal if exceptions generated direct branches to the exception \nhandler. A typestate ambiguity would occur since on the branch from statement [1] mes$age M is UNIN ITIAI, \nIZED and on the branch from statement [2] message M is ALL INIT. This ambiguity could be eliminated by \nproviding a separate exception handler for statement [2]. This exception handler would discard variable \nJ, the fields of M, and M itself, and then reraise the Depletion exception. There are several difficulties \nwith such a proposal: In a language with abstract semantics, nearly every statement has the possibility \nof raising an exception, even though in some implementa\u00adtions the exception will never be raised. For \nexample, the semantics of striugs is flexible enough to permit implementations in which large string \nvalues are allocated dynamically from the heap,, rather than being preallocated. In such implementations \n, string assignment could raise Depletion. Requiring separate begin blocks to contain the cleanup actions \nassociated with every possible exception could cause the code to become so clat~ered with excepticn handlers \nthat the maiu path throagh tl)e program] could become obscured themselves raise exceptions , therl there \nis a danger of an infinite rr:gr(ess of exception han\u00ad dlers, since each handler k,ould require another \nhandler to deal with the possible failure of one of its cleanl]p actions Both of the above protJIQms \nare solved by distirl\u00adguishing between higher and lower typestates. Intuitively, moving to higher typestates \ncommits machine resources and mot,ing to lower typestates releases resources. The typestate graphs for \nall possible types can be partially ordered, with UNINI-TIAI, IZED a anique state lower than all other \ntypes tates In Figure 1, the typQstates cioser to the top of thp page ore the higher typcstatcs. The \norderilng is exploited in the following way: Guaranteed Downhill Operations: Between any pair of types \ntates A and B such that A is higher than B, there exists a sequence of one or more operations to convert \nan object in typestate A to typestate B. These operations do not require additional operands, may never \nraise exceptions, and may never deadlock. Greatest Lower Bound: Two or more statements may generate control \ntransfers to the same exception handler even though some variable has different typestates in the exception-raising \nstatements . The typestate used on entry to the exception handler will be the highest value which is \nlower than or equal to the typestates at the exception-raising statements. Typestate lowering OperatiQns \n(called typestate coercions ) are inserted automatically between the exception-raising and the exception-handling \nstatements whenever neces\u00adsary to make the typestates agree. I = 3; begin allocata :!; ---statement [1] \nJ=5; 21.F1 = i]el]o ; ?~,F~ = 3. allocate ;; ---statement [2] N.FI = M.F1 II M.F1; N.F2 = ?l.F2 + 10; \nsend !I to A port; send x to A port; on (Depletion~ call Print ( insufficient storage ); end begin; Figure \n5, Program with exception handler: Statements [1] and [2] can Lott, raise the Gepletion exception, ,and \nsrnrl contl-ol to the Depletion handier at [3]. Makiag the types tates invariant at handler [3] would \nrequire inserting additional cleanup code associated with statement [2]. This example motivates the automatic \ngel~eration of downhill types tate coercions on entry to exception handlers. In the language subset of \nour examples (only mes\u00adsages and scalars) , the ordering rules arc very sim\u00adple. The typestate of a scalar \nis either UNINITIALIZED or INITIALIZED. The typestate of a message is either UNINITIALIZED or it is ALLOCATED \n (tS(l), ts(2), . ..). where ts(i) is the typestate of the i-th field. (In the example, the states called \nmnemonically EMPTY. F1 INIT, F2 INIT, and ALL INIT would be called r~spectively #.LLOCATED (USIKi-TIAL-IZED, \nUNINITIALIZEII), AL1,OCATED (TNTTIALIZED. UNIN- ITIALIZED), ALLOCATED (USI!ilTIALIZED, INITIAI,l ZED), \nand .4LLOCAT ELJ[ I NI TI AL1 ZED , lNITIALIZEDj ) The ordering, of scalars is simply that L!NIX IT IAL,IZELI \nis lower than INITIALIZED. For m~ssages, typestate A is lower than or equal co B if: A is UNINITIALIZED \nor ~ is ALLOC.4TED(tsa( l), tsa(2), . ..). B is ALLO\u00ad CATED(tsb(l), tsb(2), . ..). and for all i, tsa(i) \nis lo~{er than cr equal to tsb(ij. The discard operation serves as the coercion opera\u00adtion. In our example \nof Figure 5, the typestate at the handler for Depletion will have variables J and M LNINITIAL12ED. klleil \ncontrol is ~ransferred from statement [2], the. coercions necessary to discard J, M.F1, }l. F2, al,d \nl lf~ill bc gsmerated automatically. Program termination in NIL involves coercing all declared variables \nto typestate UNINITIALIZED. These coercions can all be generated by the compiler. The usual hazards involved \nin generating cleanup code do not exist in NIL: Since no aliases can be generated, the programmer cannot \ndeallocate storage which is being referenced elsewhere under a different name. The programmer may not \ngenerate unretrievable storage by deallocating storage con\u00adtaining a pointer, since the types tate rules \nguaran\u00adtee that messages may not be discarded until all the fields have been discarded. Any field implemented \nby a pointer (e.g. a long string, or another message) will automatically be discarded first if the containing \nmessage is coerced to UNINITIALIZED. There is no need for an implementation to rely on a garbage collector. \nImplementations do have to be careful, however, that downhill coercions never raise exceptions ---for \nexample, if discard is implemented by a call to a FREEMAIN service, some provision has to be made to \navoid failing due to ovQrflow of the call stack, for instance, by using the message itself to hold any \ntemporary storage required by FREENAIN. When a process is terminated, all its variables are coerced to \nUNINITIALIZED after the process has exe\u00ad cuted its last wishes. The semantics of this ~oercion depends \nupon the type ---messages are uninitialized and d~scardad, message ports are unbound after discarding \nany waiting messages, ren\u00addezvous calls are wturned to their caller, proc\u00adesses are terminated. As a \nresult of this semantics, the programmer CarL ~-nO~ that canceling a process will guarantee to return \nits resources with\u00adin a finite Lime, and that nO black holes (inac\u00ad cessible data} or wbi~e holes (active \nuncancelable processes) are possible within a NIL system. OTHER TYPES Although typestate checking was \nillustrated using NIL s message and scalar types, similar ideas are carried out in all the type constructors. \n TABLES For example, the table type constructor ie an abstraction for homogeneous collections of arbitrary \nsize ---usually implemented in conventional lan\u00adguages with arrays when the a maximum fixed bound can \nbe determined, and with lists or trees using pointers otherwise. Once again, in NIL the pointers are \nhidden and access is only permitted through table operations. The following operations are supported \non tables: insertion and deletion of rows, and read-only and read-write access to rows, (Table operations \nother than those operating a row at a time are not dis\u00adcussed in this paper, ) The typestate grammar \nfor rows in tables is shown in Figure 6. The insertion sequence proceeds as follows: 1. An allocate operation \nis issued specifying key attributes, if called for by the table type definition. If the key does not \nduplicate an existing key in the table, and if storage depletion does not occur, then the row variable \nbecomes DETACHED EMPTY. The non-key fields become uninitialized but writable. 2. Non-key fields are \ninitialized until the row becomes DETACHED FULL. 3. An insert operatior places the row into the table. \nThe fields of the row are now nO longer a~cessible, and the row variable itself is UN~N - ITIALIZED. \nTO access the data, a retrieval Oper~tiOIL is reqllired. Deleting a row follrxcs the reverse sequence: \nthe row is first detached , then the data in the row is discarded, and finally the row is itself discarded. \nThere are two ways of accessing data without detach\u00ad ing it from the table: find with the read option \ncauses tho data in the row with the selected key to become readable as the value of the row fields. Find \nfor update causes the selected data to be read\u00adable or writable but not deletable. After examining or \nupdating the data, the programmer issues the lose operation. After this operation, the data remains in \nthe table, but is no longer accessible via the row variable, which becomes again UNINITIALIZED. T&#38;70 \nnew typestates: CONSTANT (read-only permitted), and PERNANENT (read or write only permitted), apply to \nfields in row variables. Under certain circumstances a run-time check is required to avoid alias ing. \nKO two distinct row variables may access the same table item unless both row variables are inspecting \nfor read-only. The compiler s typestate analysis can determine when such a check is needed. The example \nin Figure 7 illustrates one of the rare cases in which a run-time check must be generated. The check \nis Read I?.F1 --. = [ DETACHED FULL .- I lose R  ) IR allocate R 1  UNINITIALIZED Figure 6. Typestate \ngrammar for Rows in Tables : Possible transitions are shown for a row variable R having a single scalar \nfield Fl, The upward bend in the transition for insert indicates that an exception may be raised by this \noperation, whereas the operations shown by arrows pointing directly downward are downhill ~oercions!t \nand may not fail required on the find R2 operation, since another row of the same table has a typestate \nother than UNINI-VARIANTS TIALIZED at the time of a find for update. In a tyP\u00ad ical implementation, RI \nand R2 will be implemented aS pOinters or as array s~lbs~rlPt~, and the run. time Variants are collections \nof fields partitioned into check involves merely checking for equality of the disjoint sets calle,d ~ases, \nThe types tate ~ramlnar . __ pointers or subscripts. for a typical variant containing two casea, Red \nand Blue, each with one field named RI and B1 respec\u00ad declare tively, is shown in Figure 8. T Tabletype; \n RI row inT; The case is known at compile time and is part of the R2row in T; types tate under two circumstances: \n(I) during theI: integer; initialization of tile variant fields following arlJ: integer; expljcit allocation \neithpr to the Red or Blue cose; . (2) In the Red or Blue branch outcome of a select operation ~thicll \nqueries the current state, TWO 0th\u00ad GetInputs(I, J);  find RI in T key(I); find R2 in T key[J) update; \ner tYPestateS exist: ~~I\\IT1.AT,IZED, in which the variant has no case, and INITIALIZED, in which the \ncase is pert of the t-alu(l, b,]t is not kr,owIl at com-R2.F1 = R2.F1 + RI.F1; Print (R1. Fl); lose RI; \n pile time, Feitber the RI nor the B1 field may be accessed from this types tate. lose R2; Figure 7. \nPotential Aliasing: Because RI is INSPECTING when the find operation is performed on R2 for update, a \nPROCEDURE CALLS run-time check will be needed to insure that RI and R2 do not refer to tile same row. \nIn the absence of such Typestate interacts with procedure call semantics in a check, modifications to \nR2. F1 could the following ways: (in some implementations) change the value of variable R1.F1. CTED \n(RED) SELECTED (BL LJE) R/W V.B I ~w outcome (red) outcomo (blue) end select V end select V ,Tgg.. \ndetach V setvariant V setvariant V /   R/W V%l FULL(BL UE) H V.RI hit ~.Rl discard V.B1 init V.B1 \ni  TY (RED) o discard Vallocate V (red) discard V allocate V (blue) Figure 8. Typestate Grammar for \nVariants: This graph illustrates the permissible operations on a variable V of a variant type, containing \nthe cases RED and BLUE. The RED case contains a field V. RI, and the BLUE case a field V.R2. . Procedure \ncall ports (entry variables) may be discolmected dynamically o~lcl reconnected to oth\u00ader procedures of \ncon forrngble type. Tracking each port as either t}-pestate UNINITIALIZED or RELATED WORK INITIALIZED \nmakes it possible to insure that uninitialized call ports will not be called. Other authors have used \nfinite-state models to rep\u00ad . Each procedure type definition must contain not resent the sequencing constraints \ninherent in the only the types of each formal parameter, but example: path semsntics of a type (For also \nthe typestate of each parameter on entry, express ions ([CAH 74]), access path constraints and on normal \nand exception returns from the [[CON 79], [KIE 79])). Khat is different in NIL is -procedure. This specification \nis useful for that each primitive data type is defined so that the documentation, and is essential to \npermit the typestate can be a compi le time invariant. compiler to track typestate changes resulting \nTypestates are program assertions which are simple from calling a procedure. enough that thQy can be \nautomatically generated and proved invariant by a compiler, and yet powerful Typestate information on \ninterfaces helps the enough that proving them is adequate to avOid the compiler to guarantee that procedure \ncalls do !1erroneous programs which lead to insecurity. not introduce aliasing. (As a result of the complete \nelimination of alias ing, either call by The notion of partial orderings and downhill opa\u00adreference or \ncall by value-result are valid It has been of implementations of the semantics. ) at ions appears to \nbe unique to NIL, Two actual enormous practical value in guaranteeing that param~ters with ov~rlapping \nnames (e.g. M and aborted or cancelled processes clean UP their Pri-M.A) may not both be passed in the \nsame proce\u00ad vate resources, including any processes which theydure call unless both formal parameters \nexpect may themselves own. CONSTANT typestate. RE~~REN~Es STATUS A full to meet compiler design set \nof type the general is available to produce constructors is available in needs of systems programming. \nfor VN/370, and an interpreter compact code for microprocessor NIL A [AMB 761 Ambler, A.L., Report on \nICSCA-CW-1, Austin. 1976. Good, D.I., Burger, W.F. the Language Gypsy . IIIC L niversity of Texas at \nenvironments is under development. [CAM 741 The specification of process Prototype systems are being \ncoded in NIL. The s:;llchroniz~tion b>-path expressions Lec\u00ad application well-suited areas include: to \nwhich NIL appears particularly t]~re York, !iotes 1974, in Com~ccr Science 16, NeW open layered systems, \nsuch as communications [CON 79] Process Synchronization by Behavior Con\u00ad systems, in which users of \na system may be trollers , Ph. D. thesis, University of expected to add their own versions of certain \nTexas at Austin, December 1979. layers, version, desired such as screen formatting, or link control, \nand to protect vendor-supplied protocol in which layers con\u00adit is from [DAH 70] Dahl, -.h .) O. -J., \nSI!lbLA-67 Myhrbaug, Common B., and Nygaard, Base Language , errors in user-supplied layers. Norwegian \nComputing Center, Oslo, Norway, 1970. . Highly ty to portable conceal subsystems the underlying in which \nNIL s data structures abili\u00adand [EGG 81] Eggert, P. R,, Detecting Software Errors the underlying operating \nsystem is very useful. Before Execution, UCLA Computer Science Department, Report No. CSD-8104O2, April \n1981, ACKNOWLEDGEMENTS [HAL 82] FIalim, N., and Pershing, J., A New Lan\u00adguage for Writing Portable and \nSecure Sys\u00adtems , IBN Research Report RC 9650 Francis Parr collaborated with the author in the original \neffort to turn NIL from a set of concepts C. A. R,, The Emperor s old [HOA 81] Hoare, clothes , rQprinted \nin Comm. ACM, vol. 24, into a viable lanryage. Wilhelm Burger, ?like Conner, Nagui Halim, and John Pershing \ncontributed PP. 75-83, February 1981. to the subsequent design Effort leading to ths cur\u00ad [KIE 79] Kieburtz, \nR., and Silberschatz, A, , Ac\u00adrent tiIL language, Shau]a Yemini reviewed the cess-Right Expressions , \nUniversity ofdrafts of this paper and contributed significant Texas, Technical Report, 1979. stylistic \nand teCILniCal imprc.., ements , as k-en as valuable critiques of our ]anguage design effort. [NIL 82] \nNIL Rcicrence Manual, IBY T. J. Watson Research Laboratory, internal document, [pAR 81] Parr, F. N., \nand Strom, R. E., Portable, Secure, Comnmnications Software . ._ FrO \u00adceedings, Internatiollal Conference \non Communications, Denver, _&#38;e, 1981, also IBM Research Report RC 8875. [PAR 82] Parr, F. N., and \nStrom, R, E,, NIL: A Programming Language for Software Archi\u00adtecture , Proc, IEEE 6th International Conference \non Software Engineering, Tokyo, expanded version also available as IBM Research Report RC 9227. [PAR \n83] Parr, F. N., and Strom, R. E., A Righ Level Langllage for Distributed Systems programming , to ,lppear \nin IBM sy~t~ms ~ournal, special issue on communication, 1983. [POP 77] popek, G. J., Horning, J. J., \nLamps on, B. h . , Xi.tchcll, J. G., and London, R, L, Notes on the design of EUCLID , Proc, ACN Conf. \nOn Language Design for Reliable Software, March, 1977,  \n\t\t\t", "proc_id": "567067", "abstract": "This paper discusses features of a secure systems programming language designed and implemented at IBM's Watson Research Lab. Two features of the language design were instrumental in permitting security to be enforced with minimum run-time cost: (1) Language constructs (e.g. pointer variables) which could result in aliasing were removed from the programmer's direct control and replaced by higher level primitive types; and (2) traditional strong type checking was enhanced with typestate checking, a new mechanism in which the compiler guarantees that for all execution paths, the sequence of operations on each variable obeys a finite state grammar associated with that variable's type. Examples are given to illustrate the application of these mechanisms.", "authors": [{"name": "Robert E. Strom", "author_profile_id": "81100300843", "affiliation": "IBM Thomas J. Watson Research Center, Yorktown Heights, N.Y.", "person_id": "P246621", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/567067.567093", "year": "1983", "article_id": "567093", "conference": "POPL", "title": "Mechanisms for compile-time enforcement of security", "url": "http://dl.acm.org/citation.cfm?id=567093"}