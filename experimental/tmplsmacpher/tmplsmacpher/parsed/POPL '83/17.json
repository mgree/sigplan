{"article_publication_date": "01-24-1983", "fulltext": "\n Permission to make digital or hard copies of part or all of this work or personal or classroom use is \ngranted without fee provided that copies are not made or distributed for profit or commercial advantage \nand that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, \nto post on servers, or to redistribute to lists, requires prior specific permission and/or a fee. &#38;#169; \n1983 ACM 0-89791-090-7 $5.00 A(I:1OO) =A(I:IOO) + C However, the translation process is not quite that \nsimple, because the semantica of vector assignment in Fortran 8X require fetch before store. That is, \nwhile a scalar assignment in a loop intermixes loads acid stores. a vector assignment behaves as if all \ncomponents of the right hand side are fetched before any component of the left hand side is stored. The \nfollowing loop illustrates this difference. DO100 I = 1, 100 A(I) =A(I-1] + B(I) 100 CONTINUE  Since \nthe intent is that the component of A com\u00adputed on one iteration be used as input on the next,B the statement \ncannot be simulated by a vec\u00ad tor statement of the form A(l:IOO) =A(O:99) + B(I:1OO) with fetch before \nstorew semantics. By contraa.t, the statement in our first example loop did not intermix losds and stores \nin the same array, so its effe(ct can be simulated with vector aemantica. Thufs, a statement that computes \na value on one iteration of the loop that is used directly or indirectly by the same statement on another \nitera\u00adtion. cannot be vect.orized by tranaliterati.on; oth\u00ad erwise, the statement may be ve.ctorized. \nCorrectly distinguishing between these two casea requires a study of the flow of values between uses \nand definitions. classical~~~ models the rela\u00ad tionship between definitions and uses ~f variables as \na directed graph in which each vertex represents a statement and each edge a data flow link from definition \nto use.; these links are often called fii-~ W [Keun 78]. However, follow\u00ad ing Kuck [Kuck 77]. the term \n~ demotes the relationship between a statement S2 that uses the value that S~ might have created. S2 \n&#38;r.QcLQ &#38;2f211h WQll S1 if the value computed by S1 might be an input to SZ at xun. time. S2 \n~ uimn S1 if there exists a se.quenco of statements Xl . ....*Xn such that XO=S1, Xn=529 and Xi+l depends \ndirectly upon Xi for all i., OS i~n. In these terms, a statement can b.e vectorized only if it does \nnot depend upon itself. ?FC employs a ali.ghtly wore sophisticated concepts called ~-cazx.id dependence.. \nwhich associates each dependence with the ite.rati.on of a part iculsr loop. For example, the dependence \nof S1 on itself in DO100 I =1, 10 DO90J=1, 10 SI A(I,J) = A(I-l,J) + . . . 90 CONTINUK 100 CONTINUE \nia clearly due to the loop on I. Within any specific iteration of the I loop. S1 does not use its own \nreeults; only when I ia incremented does S1 fetch from a location of A that it haa also stored in. Since \nthe dependence (and hence the cycle) disappears when the I loop is run sequen\u00ad tially, S1 can be correctly \nvectorized in the J loop to produce DO100 I =1, 10 51 A(I,l:IO) = A(I-1,1:10) + . . . 100 CONTINUE Using \nthe concept of loop-carried dependence, Ken\u00adnedy developed a recursive algorithm to vectorize statements \nin the maximum number of dimensions permitted hy its dependence relations. [Kenn 801. 1.2. Control Depemience \nData dependence alcne is not sufficient to describe all important considerations in vectori\u00adzation. Consider \nthe following 100P: DOIOOI=l. N S1 IF (A(I).GT.0) GO TO 100 S.2 A(I+l) = B(I) + 10 100 CONTINUE The \ntheoxy of data dependence would not preclude vectorization of S2. Certainly S1 directly depends on s2. \nBut S2 does not depend on itself ox on S1 for any of its inputs. Nevertheless. neitiler 51 nor S2 can \nbe correctly vectorized because of the existence of a ~ @&#38;udeQw of Sl on S2. That is.. the outcoute \nof the test in S1 determines whether S2 will be executed. When the control depeudcnce ia considered, \nboth SI and S2 depend on themselves indirectly. unfortunately, control dependence does not fit nicely \ninto the dependence machinery of PFC because .the dependence is not associated with any variable. When \nthe same loop is rewritten as DOIOOI=l, N BR1 = A(I).G T.O IF (BR1) A(I+l) = B(I) + 10 100 CONTINUE (thereby \nassociating the dependence xith the vari\u00ad able 5R1) the problem becomes much simpler. By viewing. the \nvariables in the conditi.o.n. controlling S2 a.a inputs to the statement, the re.lationehip. of these \ntwo s.tatementa ia now clear in ..terms of data flow.. Control dependence has been completely con\u00ad verted \nto data dependence. The beauty of this scheme is that conditional assignments are straightforward to \nvectorize if the scalar condition are expanded into arrays. For example, consider a slight variation \non our example loop. DOIOOI=l, N BR1 = A(I).GT.O IF (BR1) A(I) = B(I) + 10 100 CONTINUE This version \ncould be transformed to vector form by using the Fortran 8x WHERR statement. BR1(l:N) = A(l:N).GT. O \nwHEM (BR1(l:N)) A(I:N) = B(l:N) + 10 Many vector machines have hardware to support con\u00ad ditional vector \noperations, usually via a logical mask to select the positions in which the computa\u00adtion ia to be applied. \nBy generalizing this idea into a method for converting cor@rol dependence to data depen\u00addence. PFC can \nvectorize statements in loops which cent a in conditional transfera. The ~ ~ phaae of PFC is responsible \nfor this transf ormat ion. 2. Fundamentals of IF Conweraion Central to IF conversion is the notion that \nFortran Statements can be classified into four groups: (1) ~ ~ --statements which cause some change in \nthe atate of the computation or produce some important side effect. Exam\u00adples: assignment, read, write, \ncall. (2) ~~ --statements which make an explicit transfer of control t,o another loca-  Eion in the \nprogram. Examples: goto, com\u00adputed goto, assigned goto. Note that call is crested ae an action statement \nbecause within a given module it may be viewed aa a macro\u00adaction. (3) ~ -staLement$ which cause another \nstatement or a block of state\u00adments to be iterated. Example: DO statement.  (4)  Qa@lQkX@itQwMa --statements \nwhich take no action but which cao be used as placeholdere for the computation. Example: CONTINUE . \nNotice that the Fortran IF statement has no place in our classification. The reason is that we view the \nIF clause as a qual,itier that can be attached to any action or branch statement, In other words, every \naction or branch etatement can be viewed as a conditional statement. Zhe IF conversion phase of PFC attempts \nto eliminate all goto statements in the program. The execution order of the original program is main\u00ad \ntained by computing a logical condition for each action statement. This condition ia called a WarJi. \n... ~: The @ for an action or conditional action statement is a Boolean expression which represents \nthe conditions under which the statement is executed. That is, when control reaches the statement, the \noriginal statement ie executed if and only if ite guard evaluates to true. c1 The original program is \ntransformed by replacing simple action statements with conditional action statements of the form: IF \n(guard) statement IF statements (other than conditional branches) can be replaced by IF statements in \nwhich the guard is conjoined to the original condition. If the guard of a statement is identically true, \nit can be written without the IF qualifier. For the purpose of analysis. branches can be categorized \ninto three types: (1) ti ~: a branch that terminates one or more loops. aa in DO100 I =1, 100 IF (ABS(A(I)-B(I)) \n.LE. DEL) GOTO 200 ... 100 CONTINUE ... 200 CONTINUE  (2) ~~: a branch whose target occurs after the \nbranch but at the same loop nesting level. Note that since branches into the range of a DO loop are not \npermitted. a branch to a label after the branch must be eit,h.er a forward branch (if the label is at \nthe same nesting level) or an exit branch (if the label is outside the loop in which the branch occurs). \nDO100 I =1, 10 IF (A(I).EQ.0.0) GOTO 100 B(I) = B(I) /A(I) 100 CONTINUE (3) b.adwwi ~ an branch to a \nstatement occurring lexic,ally before the branch but at the same nesting level. as in 1=1+1 A(I) =A(I) \n+ B(I) IF (1 .LE. 100) GOTO 10 10 In accordance with this cl.assificat.ion, II? conver\u00ad sion uses two \ndifferent transformations to elim\u00adinate branebee within the program. (1) Br.aluhzduatim moves branchee \nout of loops until the branch and its target are nested in 179 the same number of DO loops. This procedure \nconverts each exit branch into either a for\u00ad wsrd branch or a backward branch. (2) ~ ~ eliminates forward \nbranches by computing guard expressions for action state\u00ad ments under their control and conditioning \nexecution on these expressions. Backward branchea are left in place. The following sections present these \ntwo tech\u00adniques in more detail. 3. Exit branches Exit branches differ from other branches in that exit \nbranches sffect the execution of state\u00ad ments both before and after the branch. That ia. since a branch \nout of a DO loop terminates execu\u00ad tion of the loop, it affects all the statement in the loop. Consider \nthe following example: DO100 I = 1,100 S1 IF (X(I)) GOTO 200 S2 100 CONTINUE S3 200 S4 Once the jump \nis taken. the DO loop is terminated and neither statement S1 nor S2 will be executed thereafter. If the \nDO loop were not present, pro\u00ad ducing S1 IF (X(I)) GOTO 200 S2 S3 200 S4 statement S1 is completely unaffected \nby the branch. Thus. exit branches are more complicated than forward branches. since eliminating them \nrequires modification of the guarda of all atate\u00admenta within the loop exited. If all exit branches can \nsomehow be converted into forward or backward branches. then the prob\u00ad lem of IF conversion becomes much \nsimpler. In other words, if PFC can ~ the branches so that every branch is nested in exactly the same \nDO loops as its target. branch remnval will then eliminate these branchea naturally with forward branches. \nJhe basis proc,eduxe used in branch relocation and elimination is the computation of a Boolean !iu3.cd \nexpression for each statement. This guard evaluates t.o true if and onl,y if the statement would be executed \nin the original program. By converting the guard to a logical expression in Fortran and using it as a \ncondition in an IF clause. PFC can then test for vectorization using only data dependence. Guards in \nPFC are based on a system of formal logic. The atoms of this logical system are predicates expressing \nconditions that may hold at various points in the program. For example, one possible predicate is p = \nA(I).LT.O was true on the most recent execution of statement 300.W If A(I).LT.OW is the condition for \na jump past statement 350. the predicate p should certainly be part of the guard for that statement. \nThe opera\u00adtion which may he applied to predicates are con\u00adjunction (A). disjunction (V) and negation \n(-t). Hence a guard might be the conjunction of several predicates, e.g. P1 AP2 A~P3 In order to separate \nthe issue of correctness from the iae.ue of simplification, we will distinguish between the logic used \nto represent guards inter\u00ad nally and their actual appearance in the output language. In our logic, we \ncan compute a provably correct guard for a particular statement; however, this doea not imply that we \ncan find, in a reason\u00ad able time. the moat concise Fortran representation for that guard. The duality \nof the logic of conditions and their external representation is mirrored by our implemental ion. We represent \nthe guards inter\u00adnally in a form quite different from the external representation (ace Section 7). Rotationally, \nwe will use the function ~ to map the internal rep,re,een,tation of conditi~~s to a realization in the \nlanguage being genexated. An internal condi\u00adtion may haye many external representations; we therefore \nas.swne that ~ will choose one that is suitably concise. Far example. ~ might employ the Quine-McCluskey \nprime implicant simplification procedure to generate a simple external represen\u00ad tation of a given int \nerp.a 1 guard [Quin 52,. McC1 5610 The use of ~ allows us to delay con\u00adsi.d.eration of any simplification \nissues until Sec\u00ad tion 6. .Rsturning to branch rehcakicnh movement of an exit b.r.anch out of a lc@p \nxeq,uir,ea. that .th,e execution of each statement in che loop be guarded by an expression which will \nbe true in the modi\u00adfied pr,o.gram only while the branch haa not been taken in the original program. \nMore generally. each statement will be guarded by an expression which is the conjunction of sxk..~s denoted \nexi., w~ere an ~ f&#38;g is a Eoolean variable associat.e.d with a particular branch in the origi\u00adnal \nprogram T.h,e, exit fla,g e~i is defined to be true at a statement if the br.anc.h associated. with the \nflag would not have been taken before control reached the statement in the original program. In order \nto compute a realization for exis we will introduce a corresponding logical variable EXi into the program. \nEXi will be used to capture the condition controlling the loop exit each time that condition is evaluated. \nso that ~(exi) = EXi. We will uae the convention that lower caae variables represent conditions and upper \ncase variables represent their realizations as Fortran logical variables. In the case of branchea out \nof a single loop, there is one exit flag for each exit branch. Upon entry to the loop. all exit flaga \nare true, since the loop has not yet been exited. Each exit branch of the form IF (P) GOTO S1 within \nthe loop is associated replaced by an assignment of the form EXi = .NOT. P which capturea the condition \nexi = nthe exit branch would not have been taken at ita moat recent execution.w A new branch of the form \nIF (.NOT. EXi) GOTO S1 is generated immediately following the loop to simulate the effect of the branch \nin the loop. Note that this branch will be taken only if the exit branch would have been taken in the \noriginal program. Finally, the guards of all statements within the loop (including the newly generated \nassignment) are modified by conjoining each exit flag for that loop: exl Aex2A . . . Aexn. The overall \neffect is to arrange the modified program so that an exit flag ia set to false when\u00adever the corresponding \nexit branch in the original program would have been taken, Thus, once an exit flag becomes false, no \nother etatement in the loop will be executed, even though the DO statement will cent inue to run iterations. \nHere is the previous example after reloca\u00adtion: EX1 = .TRUE. DO 100 I = 1,100 IF (EX1) S1 IF (EX1) EX1 \n= .NOT. X(I) IF (EXI) S2 100 CONTINUE IF (.NOT. EX1) GO TO 200 S3 200 S4 This method is easily extended \nto multiple loops by treating a branch out of more than one loop as a branch out of the outermost loop. \nCon\u00ad sider the following more complicated example: DO 200 I =1,100 50 S1 DO 100 J=l,IOO S2 IF X(I,J) \nGO TO 300 S3 IF Y(I,J) GO TO 50 S4 100 CONTINUS S5 200 CONTINUE 300 S6 After the branch relocation, \nthis code becomes EX1 = .TRUE. DO 200 I =1,100 50 IF (EXI) S1 IF (EX<) EX2 = .TRUE. DO 100 J=1,1OO IF \n(EX1 .AND. EX2) S2 IF (EX1 AND. EX2) EX1 = .NOT. XI I,J) IF (EX1 .AND. EX2) S3 IF (EXI .AND. EX2) EX2 \n= .NOT. Y I,J) IF (EXI .AND. EX2) S4 100 CONTINUE IF (EX1 .AND. .NOT. EX2) GOTO 50 IF (EX1) S5 200 CONTINUE \nIF (.NOT. EXI) GOTO 300 300 S6 This transformation is effected by applying the eimple method to the first \njump with respect to the outer loop and the second jump with respect to the inner loop. Note that the \nexit flags are mutually exclusive; that is, once any exit flag is set to falae (indicating that an exit \nbranch has been taken), no other exit flag in any loop that the corresponding jump would have left can \nbe set to false. Hence, if a loop is implicitly ter\u00adminated by an exit branch. that branch can be identified \nby scanning the exit flags for the one which is false. The algorithm for branch relocation is given in \nFigure 1. The guard on every statement other than an IF is initially true. The algorithm proceeds by \ncouputing the loop guard for this looPs aPPIYing itself recursively to nested DO loops (which computes \nguards for the statements in those loops) then conjoining the loop guard for the curxent loop to the \nguard of every statement under its control. After the procedure is called on every DO statement at the \noutmost level, no exit branches will remain in the program. To demonstrate the corxec.tnesa of branch \nrelocation. we must show two things: (1) the algorithm removes all exit branches. and (2) the modified \nversion performs exactly the same computation as the original.  The first point follows rather trivially \nfrom statement S1 of the algorithm. The body of loop procedure relocate_branches (x); /* x is the DO \nstatement for the loop *I /* loop_guard will be the conjunction of */ /* all exit flags for the loop \n*I loop_guard = true; S1:for each exit branch IF (P) GOTO S1 that exits the loop headed by x do begin \ncreate a new unique exit flag eXi with realization EXi; insert the assignment WXi = .TRUE.W prior to \nx; loop_guard = loop_guard A exi; insert the branch IF (.NOT. EXi) GOTO Sln after the loop; S2: replace \nthe exit branch by the assignment %Xi = .NOT. P* end for each DO statement y contained in x do relocate_branches \n(y); S3:for each non-DO statement y contained in x do guard(y) = guard(y) A loop_guard; end relocate_branches; \nFigure 1: Branch Relocation S1 converts a particular exit brarwh to an assign\u00ad ment. Since no new exit \nbranches are created by the procedure. (the generated branchea _ be at t ne same level as their targets), \nand since S.1 is executed for each exit branch in a loop, the modi\u00adfied code will contain no exit branches. \nThe second point follows from two observa\u00ad tions about the transformations being applied. (1) The only \ndifference between action statements. in the original program and the .ruodified pro\u00adgram ia that all \nexit flags for lo~pa in which the statement is contained are con\u00ad joined to its guard.  (2) Each exit \nbra~ch is replaced by an asei~nnent $tatement that acts the corresponding exit flag to false if the condition \ncontrolling the branch ia txue in other words, if Lbe branch would have been taken the exit flag becomes \nfalse.  One imporLant concern about correctrmss is thaL the tran.s.forma.t.ion might have introduced \nside effects that would .nQt. have occurred in the or.igi,\u00adnal program. A p~ssible source of such side \neffects is the comp.u,tation of guard values. The branch removal algorithm is very careful to ccw\u00adpute. \nbranch conditions at Lhe point where they would have taken place in the original program and save them \nin logical variables. The computation of guards then amounts to evaluating logical expressions in these \nlogical variables, thereby avoiding the problems of aide effects. Since all branches out of the loop \nhave been eliminated, every DO loop in the modified program, once entered, will run its course -even \nthough some exit flag ia false and no real computation ia being done. This is an essential part of the \ntransformation, but it may have the unfortunate effect of unexpectedly long running times when the purpose \nof the DO loop iteration is to provide a bound large enough to insure that the loop would be terminated \nby a brancb on detection of a spe\u00adcial condition. Hopefully, the speedup gained from vectorization will \nmore than offset this inefficiency. Branch relocation is an elegant prepaas to branch removal for many \nreaaona. First. it makes no distinction between backward branches and for\u00adward branchea. Second, it allowa \nthe identifica\u00adtion of branches and targets, thus providing information necessary for branch removal. \n4. Forward Branches The simplest type of control dependence results from forward branches. Since the \nexecu\u00adtion of the statement between the branch and its target clearly depend on the value of the vari\u00adables \nin the branch expression, IF conversion must determine guard.e that correctly reflect this dependence \nOnce the guarda are in place, the jump isunnecessaxy and is umoved. The process of...eliminating fw#ard \nbranches is known as ~ wa?JihLan.Ch Zem$Z!d. Fundamental to all phas.e.s of branch rersoval is the idea \nof a. a.ueI&#38;~o which is sim\u00adply a logical expression (guard.) reflecting the conditions under which \nthe statement pre$.ently under consicle.ration wi.1.l .be executed. As branch removal moves from atateuent \nto statement in the pxogram, it cuujoin> or d.isjoiua Eo~Lean variables with the current co.nditioi i \nLO generate the guard for the nut s.tatcxoent.. These Boo,lean variables represe,lt facts abo.ub the \nforward branches of tbe progzam (euch as whether or not they would be taken). A forward bronch. affects \ncontrol flow a.t two loc.atious: at the branch, where ccmtrol flow can diverge from oixliu...ry sequential \nflow; and at the target label, where ti~e split rejoins sequential flow. Thus, tile curren~ coudit.ion \n(~r cc) must.be modified at these points to remove forward branches. (1) &#38; -~: In the absence of \nother ton\u00adtrol flow changes, the statement immediately following a forward branch is executed only when \ncontrol flow reaches the branch and the branch is not taken. Thus , if the current condition at the forward \nbranch is ccl and the predicate controlling the branch is p. the guard for the following statements will \nbe ccl Aap. (2) AL Lku2 ~: Similarly, control flow can reach the target of the branch either sequen\u00adtially \nfrom the previous statement or via the branch itself. Under the previous assump\u00adtions, if the guard on \nthe statement prior to the target is CC2. the guard on the target should be CC2 V (ccl A p). In the absence \nof other changes in control flow (so that CC2 = ccl A -tp), the guard on the target statement is (CCI \nA -!p) v (ccl A p) which simplifies to ccl. In other words, if control flow reaches the branch, control \nflow will reach the tar\u00adget regardless of which execution path is taken. An example should make these \nideas clearer. DO100 I = 1, 100 IF (A(I).GT.10) GO TO 60 S1 A(I) =A(I) + 10 IF (B(I).GT.1O) GO TO 80 \nS2 B(I) =B(l) + 10 S3 60 A(I) =B(I) +4(1) S4 80B(I) =A(I) -5 100 CONTINUE We introduce two Boolean variables \nbrl and br2 to capture the two branch conditions in the loop. Such variables are called ~ ~. The branch \nflag brl is defined to be true if and only if NA(I). GT.1011 evaluates to. .true .in the first IF statement. \nWe use the Fortran logical variables BR1 and ,BR2 to capture the values of brl and br2, so BR1 = ~(brl) \nand BR2 = ~(bz2),. In the program text this is accomplished by inserting the assign\u00adments: BR1 = A(I).GT.1O \nBR2 = B(I).GT.1O in place of the two IF statements, By using logi\u00ad cal variables to capture the values \nof conditions. at the original point of evaluation. PF.C ensures that later assignments in the program \ncannot accidentally change the conditions controlling statements. Following the conventions for forward \nbranch removal described above. we find that the s,tate\u00adments in the loop are controlled by the following \nconditions. statement controlling condition .51 lbrl S2 -tbrlA-tbr2 S3 brlV(wbr1Awbr2) S4 brlV(mbrlAbr2)V(-?br1A*br2) \n In order to prevent the proliferation of long expressions involving logical variables like BRl and BR2, \nthe IF conversion procedure must be able to recognize identities and simplify logical expressions. For \nexample, it should surely recog\u00adnize that the condition controlling S4 is always true. Thus, simplification \nis an important aspect of IF conversion. With simplification, the IF conversion procedure in PFC would \nconvert the example loop above into the following. DO100 I =1, 100 BR1 = A(I).GT.10 S1 IF (.NoT. BR1) \nA(I) =A(I) + 10 IF (.NOT. BR1) BR2 = B(I).GT.1O S2 IF (.NOT. BR1 .AND. .NOT. BR2) x B(I) = B(I) + 10 \nS3 IF (BRI .OR. .NOT. BR2) x A(I) =B(I) +A(I) S4 B(I) = A(I) +5 100 CONTINUS Note that the condition \ncontrolling S3 is dif\u00adferent from what one would initially expect. When we first ran this example on \na pxototype PFC sys\u00adtem that used the Quine-McCluskey prime implicant simplif,iex [Quin. 5.2,..McC1 56], \nwe. thought the sim\u00adplifier was incorrect. After some thought how\u00adever. we realized that the simplifier \nhad indeed produced a correct (and simpler) version of this condition. Figure 2 outlines the algorithm \nused to elim\u00adinat e forward branches. The procedure forward-convert is called on each statement in the \noriginal code. cco is initialized to TRUE before the first call, and is then reset by each succeed\u00ading \ncall. The algorithm assumes the.existence of a set of queues (in the array predicate_list) and basic \nqueue primitives. Note that only forward branches are converted; therefore all the expres\u00adsions to be \ndisjoined at a target must be in ita predicate list at the time the guard for that tar\u00adget is created. \n5. Backward Branches While. branch removal can eliminate forward branches quite handily, it cannot remove \nthe last type of control dependence -backward branches. In fact. backward branches cannot be directly \ne.liminat.ed from a program, because a backward branch creates an implicit loop. A looping con\u00adstruct \ncannot be simulated with guarded state- PWIWS; thus backward branches cannot be directly eliminated. \n100 is taken. procedure forward_convert (x, cc-o) returns condition; /* x is the stat~~ent under ~on~id~ration \n*/ /* cco ia the condition prior to x. */ /* ccl will be the condition guarding x */ /* predicate_list(x) \nis a queue of all */ 1* predicate that must be disjoined */ /* at x becauae of branchea to x. *I ccl \n+ Cco; while not_empty ( predicate_list(x) ) do begin P -get-from-queue ( predicate list(x) ); ccl +ccl \nvp end case statement_type(x) in /* IF(P) GOTO y (forward to same level) */ begin create a new branch \nflag bri with realization BRi; replace x with IF (~(ccl)) BRi = P; ; add_to_queue (predicate_list(y), \nCC1 A bri); ccl + ccl A -tbrl end /* GOT O y (forward to same level) */ begin add_ko_queue (predicate_list(y). \nCC1 ); ccl +-false; delete statement x end /* All other type statements */ begin guard x by ccl end esac; \nreturn (ccl) end forward_convert; Figure 2. Forward Branch Removal. Backward branches create more problems \nthan just implicit loops. hawever. Forward branch removal in the presence of backward branches can-DOL \nbe handled by the a~gorithm in Figure 2. because of code like the following: IF (X) GO TO 200 100 S1 \n... 200 S2 ... IF (Y) GO TO 100 Forward branch removal aa illustrated in Figure 2 would set the guard \nfor S1 to -tX. This guard is ~ becauae it would prevent S1 from being executed when X is true and the \nbackward branch to One possible approach to IF conversion that avoids the complications of backward branches \nia to isolate these branchea, leaving the code under their control (known as an ~ ~ a) untouched. Of \ncourse, this approach inhi\u00adbits removal of any forward branches into an implicitly iterative region. \nThis limitation seems quite severe, ao we must consider the problem more carefully. A guard for S1 must \nreflect two alternatives: (1) S1 ia executed on the first pass through the code only if X is false. \n(2) S1 is ahtaya executed any time that backward branch ia taken.  These alternativea suggest a generalized \napproach: one set of conditions ia used to guard the firat paas through an implicitly iterative region \nand a different set is used to guard subsequent passes. These guard conditions can be established by \nusing a Boolean variable which ia false on the first pasa through the region and true whenever the backward \nbranch has been taken. In other words, a bx.ax&#38;h k@2.k flag bb (with realization BB) will denote \nthe fact that the backward jump has been taken. Applying this idea to the previous example would produce: \nStatement Guard BR1 =X true ... ?br~ BB1 = .FALSE. true 100 S1 -tbrl v (brl A bbl) . . . mbrl v (bz~ \nA bbl) 200 S2 true ... IF (Y) THEN BBI = .TRUE. GOTO 100 ENDIF One noteworthy point is that BB1 is set \nto true only if a branch back occurs. Corresponding to our two alternatives. there are two ways that \nthe target y of a backward branch can be reached from the atart of the pro\u00adgram. (1) EdlthKough: control \ncan fall through from the statement before y. The condition under which this path is taken is ccunplete.ly \nencoded by the Curs.nLmditizn on exit from the predecessor. (7-) BackMad krau.11: control can enter the \nimplicitly iterative region by a branch with branch flag bIi and branch backward (flag bbj) to y. The \ncondition under which this can happen is bri A bbj. Since bb. is set to J true when the branch occurs, \nit incorporates the condition that the backward branch was reached from the target of the forward branch \nand the backward branch condition was true. Hence, the guard at the target of the backward branch is \nCCY V (bri A bbj) If there ia more than one jump into the iterative region. the second term should be \nthe disjunction of the each branch condition conjoined with bbj. l he condition generated at the target \nmust alao be slightly modified. Conaider the following example. IF (X) GO TO 200 100 S1 GO TO 300 200 \nS2 IF (Y) GO TO 100 300 53  The correct guard for S2 must be bzl A -tbbI, since S2 ia executed if and \nonly if the forward branch to 200 wae taken and the backwards branch baa not been taken, In order to \nremove the branch preced\u00ad ing S2, the term mbbl must be in the target condi\u00ad tion. In general, the target \ncondition for a for\u00ad ward branch into multiple implicitly iterative regions .is the conjunction of the \nbranch flag and the negation of the branch back flag for each region. The negationa of the branch back \nflags in the target condition aignifiea that coutr.ol may pasa to the target statement only on the first \niteration of these regions. The previous example after complete branch removal becomes BR1 =x 100 IF \n(.NOT.BR1 .C)R. BBI.AND.BRI) 51 /* GO TO 300 has been eliminated */ 200 IF (.NOT. BBl .AND. BRI) S2 IF \n(.NOT. BB1 .AND. BR1 .AND. Y) THEN BB1 = .TRUE. GO TO 100 ENOIF 300 S3 At S3, the :urrent condition.of \n-tbbl A brl is dis\u00ad joined with. the target condition -tbrl v bb.1 A bx.1.. The result after .simplif.ication \nis true which ,mir \u00adrors the fact that S3 should alwaya be executed. Figure. 3 contains the genezal branch. \n,remo.val algorithm which incorp.or.ate.s these observations. The only major modification to the al.gor.ithm \nin Figure 2 is the check. encapsulated in pr.oceas._branc.h (Figure 4), on whether forward branches jump \n.into implicitly iterative regions. Also. note that block IF statements are. not gene\u00adrated at the backward \nbranch, ,ai.n.c.o these svould defeat the purpose .of IF ,conv.er.sion. Ina.tead, a sequence of equivalent \nassignment is generated. procedmre remove_branches (x, CCO) returns condition; /* x ia the statement \nunder consideration. */ /* cco is the current condition prior to x */ /* ccl is the current condition \nafter x */ ccl + Cco; while not_empty ( predicate_list(x) ) do begin P get-from-queue ( predicate_liat \n(x) ); ccl +ccl vp end c*ee statement_type(x) in /* IF (P) GOTO y (forward to same level) */ begin create \na new logical guard bri with realization BRi; replace x with IF (y(ccl)) BRi = PW; process_branch (x. \ny, ccl A bri); CC1 + CC1 A -tbri end /* GOTO y (forward to same level ) *I beg in proceaa~bzanch (x. \ny, ccl); ccl + falee; delete statement x end +* ~F--(p) GOTOY (~ to same level)*/ begin let bb. be branch \nback flag aeaociated wit~ this branch (realization: BBj ); insert %Bj-= .FALSE-.N before y; let TPk be \na new eemporary variable; replace x with the atatementa ~Pk = (CC1)W IF (TP!)TPk =Pw IF (TPk) BBj = ..TRUE.n \nIF (TPk) GO TO yn end; f*--kl4 other statements */ begZn guard (x) +guard (x) A ccl ad esac; return (ccl) \n end remove branches; Figure 3: Conplete branch removal .The branch removal ptocedur.e used in E!PChas \nseveral advantages. First. no special. cases are needed for backward b.ranchea unless there ia .a branch \ninto the region under the control of that backward branch. Without the prea,ence of another branch. .Che \nbranch back flag never enters the .c.u.rrent conditi~n. Second, the branch back flag simplifies out of \nthe current condition after the target of the last forward branch into the impli\u00adcitly iterative region. \nThis simplification reflects the fact that the condition for execution of all Statements afiter the last \np.o.ssible external entry to the backwards branch should be independent of any specific iteration of \nthe back\u00ad wards branch. Most important, however. is the ability of the algorithm to handle any pathologi\u00adcal \ncombination of backwards branches with minimal effort. 6. Boolean Simplification In developing the conceptual \nbasis for IF conversion. we have purposely attempted to factor out issues of representation. We have \nreferred to two representations. one internal and one exter\u00adnal, for the conditions constructed by IF \nconver\u00ads ion. The basic method insures that the guards attached to the output program will be correct, \nbut we need some mechanism to insure that the out\u00adput program will be clean and readable. In other worda, \nwe need to find external representations for the conditions which are as simple as possi\u00adble. The simplification \nfunction is built into the operator ~ which maps internal representations to external representations. \nInternally, the guards are maintained in a form suitable for quickly per\u00adforming the fundamental operations \nof branch remo\u00adval --creating a new branch flag and merging two conditions at a label. The actual simplification \nis performed by applying a version of the Quine-McCluskey prime implicant simplifier [Quin 52, McC1 56]c \n  6.1. Prelimin*r iea We begin with a bit of notation for the ensu\u00ading discussion. Ln a Boolean formula. \nvariables and negations of variable.e will b.e referred to as . A conjunction of literala is known as \na ~ Quaul.a if no variable appears in i.t twice. Any alternation of fundamental formulaa is a (~ ).~iimaula \nand the fundamental formulaa of which it is an alternation are called &#38;rlU.. Let Y be a eet of. variables. \nWe denote by nf(Y) the. aet of. all normal formulaa over Y. A fundamental formula t. is.a mi,n@nn over \nY if each variable in Y occurs in it, exactly .rmce,, If there are n,var.i.ab.les in..Y, there are 2? \nminterms,. .s.ince each minterm can contain either a variable or ita negation, Every Boolean fo.rmula, \ncam,be, .written, ,aa the alternation, of miuterms; we refer to this, rep.r.esentat.ion. as.., the Qr \n~ .. . ~..~ ~.. .The Qu.ine- McCluakey pzo.cedur.e .simpli.fies .Boolean formulas by reducing t.hers \nt.o canonical disjunc.tive.. normal form and then finding a.miuimal set .of..-,~ for the aet of rointerms, \nA fundamental formula @ is-~ of a formula Z if @a 1 and there exists no shorter conjunction of a subset \nof the literals in @ that aleo implies ~. Hence the Quine-McCluskey procedure contains three phases: \n(1) Reduction to of the formula 1 to canonical form. (2) Construction of the set E of all prime impli\u00ad \n cants for the formula. If V~ is the alterna\u00adtion of all members of E, then W = ~. (3) Selection of \nthe shortest set S CE such that VP e!$.  Phase 3 is of combinatorial complexity in the number of prime \nimplicants. but since the best simplification is not strictly necessary, a good heurietic to select S \nis acceptable. Phase 2 can to nl.5~ be implemented in time proportional where n is the number of minterms \nand m ia the number of variables used in I [AIKW 82]. However, the method requires 0(3m) storage, so \nit is impractical for m larger than eight or nine. How \u00adever, there exist slightly slower methods which \nhave much smaller storage requirements. McCluskey~s original technique is one such [McC1 561. Phase 1 \nis also potentially exponen\u00ad tial since a few short formulas in m variables can give rise to 2m minterma. \n 6.2. Simplification in PFC In PF.C, we avoid phase 1 of the Quine-McCluskey procedure by internally \nmaintaining the guards as a set of minterms over the.set of branch flags active at the time the guard \nis created. This representation allowa us to take advantage of the observation that c.o.ndit.ions are \nmodified dur\u00ading branch removal in only two ways: (1) At a forward branch a. new, bxanch flag is created \nand two new conditions are formed from it b.y conjoining it and its negation to the current condition \nat the. branch. Inter\u00adnally, this result can be effected by con\u00adjoining the new flag and its negation \nto every mintern. in. the current condition col\u00adlection.. . The, one,e with the negation comprise the \ncurrent condition for the next etatement while. the ones with the unnegated flag comprise the condition \nattached to the branch. (2) At. a target some collection of conditions must be disjoined.. This disjunction \nis. han\u00addled by extending the minterms to be over. the same set of variables-then simply taking the union \nof all minterms in the various collec\u00adtions. Conditions in PFC are actually represented by two parts. \nThe first part (the ~ ~ m) is a list of branch flags present in the condition, maintained in the order \nthat the forward branches they represent were encountered. The second part is a set of minterma. The \ndisjunction of these minterms repreaenta the actual condition. A simple example should clarify the method \nused. Consider the following code: IF (X) GOTO 300 ... IF (Y) GOTO 100 ... IF (Z) GOTO 200 100 CONTINUE \n200 CONTINUE ... 300 CONTINUE As each of the branches are passed, the current condition is conjoined \nwith the branch, flags to produce a single minterm nbrl A -sbr2 A =br3 as the current condition after \nall branchea. The expression to be disjoined at statement 100 is nbrl A br2. Since the current condition \nincludes br3, which ia not in the target condition, we expand the target condition by rewriting it as \nthe disjunction Qf two minterms: (mbr~ A br2 A br3) V (-tbrl A brz A -tbr3).. When this expression is \ndis\u00adjoined with the current conditiou, no simplifica\u00ad tion can be performed (other than reversing the \ntransformation made in the target condition). Thus the current condition after statement 100 is procedure \nprocess_branch (x, y, br); /* x is the branch *I /* y is the target */ /* br is the condition on the \nbranch */ stmt~tta-rd + true; for each implicitly itera~ive region that x jumps into do begin let bb. \nbe the branch back flag con t rolling the region; let xj be.the target of. the backward branch; add_to_queue \n(predicate_list(xj), brAbbj); stmt~uard + stmt_guard A mbbj e md add_to_queue (predicate_liat(y), br \nA atmt_guard); end process_branch; Figure 4. Forward Branch ?roeessiag (-sbr1A-rbr2A=br3)v(*brlAbr2Abr3)v(-tbrlAbr2A-br3) \nAt statement 200, the expression brl A br2 A br3 is disjoined with the current condition, giving: (IbrlAmbr2Awbr3)V(wbrlAbr2Abr3)V \n(mbrlAbr2A=br3)V(-tbrlAmbr2Abr3) The first and laat minterma simplify to -tbrl A abr2. The second and \nthird minterms simplify to *brl A br2. These minterms combine to produce =brl. Finally, at statement \n300, the flag -tbrl is simplified out. resetting the current condition to true. This example leada to \nseveral new obsena\u00adtions. (1) Once a branch flag is simplified out of the current condition, it never \nreenters the con\u00addition. The disappearance of a flag implies that all possible execution patha since \nthe branch associated with the flag have merged together. Whether or not the branch was taken will have \nno effect on the execution of subsequent statements. (2) The order in which branch flags may be sim\u00adplified \nout of the condition is exactly the reverse. of the order in which the branch flags are introduced. The \nprevious example demonstrates this point clearly, since br3 must be removed from the current condition \nbefore br2 can be removed.  The proof of these statements is straightforward but not obvious. In the, \ninterest of space, we will omit it here. The. interested, reader is referred to a technical report on \nsimplification in PFC [AIKW S2]. The minterm representation for,guards. can be exponentially larger than \nthe shortest r.epreaenta\u00adtic!n, as our. earlier dia.cussions indicate. How\u00adever, this growth occurs o.nly,when.the \nlast branch .jumpa around.a section of code containing the.t.ar\u00adgets of all p.revious ..branchea. F.o.r \nlocal,-struc\u00adtured, branches. branch flags siu@ify. o,u.t .v.e.ry shortly after entry. Since the. growth \nof. minterms can be, exp.o.nenti.al in the woret case,, regardless o.f the represen,tatian, we. chose.. \nthis method in order. to optimize the time required to. simplify structured code. Note .,that s.imp,l.ification \nwith this. representation merely involvea teeting the set. .of. mipterms t.o see if each element . ..Abrn \nhas a partner . ..Anbrm. If ao. brn may be removed frmu. the mint,erm, and its p.redeceasor. checked. \nfor the.. same condition ;..othe,rwis,e,,. the. c.ondi.ti.on. is in simplest terms. By carefully ordering \nthe min\u00adtexms aa they are added to the condition, .we can insure that simplification is acceptably effi\u00adcient. \nAfterwards the simplified condition may be normalization modifies all loops to run from one generated \nusing phases 2 and 3 of the Quine -to some upper bound by increments of one. In McCluskey procedure. \nThese phases are required doing SO, new loop induction variables are gen\u00ad only when the actual current \ncondition is altered. erated which allow easy identification of the loop This scheme can also be expanded \nto handle back- controlled. Additionally, the nesting level of wards branch flaga by adding the backward \nbranch every statement is noted, thereby allowing easy flag to the current conditions branch flag list \ndetermination of jumps out of loops. and expanding when the first branch into the Basic block analysis \nis not important to IF implicitly iterative region ia encountered. conversion directly, but it is vital \nto the global optimization phase following IF conversion. Note ?. Implementation that b~ explicitly \nguarding every statement in the IF conversion in PFC is performed in three program, IF conversion greatly \nincreases the separate pasaes over the program. The first pass Specifi\u00ad number of baaic blocks in a program. \nanalyzes the branches in the code, marking back-cally, every guard and every statement has become ward \nbranches and exit branchea. Next branch a block to itself. If these blocks were used in relocation is \nperformed, followed by branch remo\u00ad global optimization, the analysis would be horren\u00adval. These passes \nare basically as described dously slow, and in many cases. far less accurate above, although the algorithms \ndiffer slightly in than possible. However, by making use of the fact order to promote efficiency and \nsimpler condi\u00ad that IF conversion does not change the execution t ions, Simplification using the abstract \norder of the program, we are able to use the basic representation described previously is performed blocks \nconstructed before IF conversion to suc\u00adonly during branch removal. Afterwards, the cessfully optimize \nthe program as it exists after guards axe converted .to the same intermediate form IF conversion. In \naddition, the use of basic as. .al.l other expressions.. A final pass over the blocks can facilitate \nthe incorporation of unvec\u00adprogram unlocks backward branches and converts torized IF statements into \nblock IF constructs. them to WHILE 100pa. At this point, all branches After IF conversion. PFC applies \nglobalhave been removed from the program. opt, imizatiou transformations to the program. Figure 5 briefly \noutlines the structure of These transformations include dead code elimina\u00adPF.G.. prior to IF conversion, \nPFC normalizes DO tion, constant propagation. and i.dudsm wui.abk loops and analyzes the. program to \nuncover its . In addition to replacing implicit basic block structure [Kenn 811. DO loop induction variables \nwith functions of the true induction variables, induction variable substitu\u00ad tion propagates certain \nexpressions forward within . loops (within the limi.t.s set by the basic block aoalysis). This propagation \nwill replace flags that are constant within a .1OOP by the actual expression assigned .to the flag. This \ntransforma-   HiE!!34t!2E_l-] tion is advantageous for two reasons. First, scalars inside DO loops \neither inhibit or greatly &#38; increase the cost of vectorization. Second.,. the re.zulting code is. \nmuch closer in.appearance to the original. .code, making the transformations easier IF Conversion  to \nunderstand. Another important transformation performed by Pl?C is. ~ ~, which is part of a recurrence \nbreaking phase during parallel code generation, As described earlier, the use. of scalar flags inaide \nDO 100PS can cause scalar dependence,. thereby inhibit. ing vectori,zation. tire-w Scalar expans.icm \nwill replace scalar v.ariabl.es. by equivalent array variables. thereby breaking. some of the ,dependences. \nThere are three. dis.t.inct Figure 5: Structure of PFC advantages to using scalar flags in IF conversion, \n rather tha~ using logical arrays directly. First. this approach allo.wa IF conversion to focus strictly \non the problem of converting control References dependence -\u00ad it need not be concerned with tbe tedious \ndetails of converting scalars to arrays. [ANSI 811 Second, this approach guarantees that arrays are not \ncreated unless some vectorization is gained by the approach. Strictly expanding every scalar can greatly \nincrease the amount of storage required by [Bane 76] a program. without necessarily permitting any vec\u00ad \ntorization at all. Scalar expansion, however, will not expand a scalar unless some vectorization results. \nThird, arrays created in IF conversion [BohJ 661 are tested for dependence in the dependence analysis \nphase of PFC. Unfortunately. dependence testing is not exact in PFC; PFC may determine that two array \nreferences are dependent when in [Burr 77] actuality they are independent. In particular. the expansion \nof exit flags gives rise to false [GibK 811 recurrences when tested by the.dependence analysis phase. \nScalar expansion is sophisticated enough to recognize that these dependence are false. however, and ignores \nthem. thereby permitting more [Hare 801 vector ization. [Kenn 801 s. Conclusions IF conversion has proved \nto be an extremely valuable transformation ip PFC because it permits [Kuck 771 Vectorization of sections \nof code that PFC must Qtherwise leave untouched. The present implemen\u00ad tation of IF conversion is complete \nas described here, with two exceptions. First. simplification [KKLP 811 is not yet c.omp.leted. As a \nresult. IF conversion can only be run on short examples. since the current condition tends to rapidly \nbecome unwieldy, Second, we have only briefly explored the possibilities of converting guards in unvec\u00ad \ntorized code to block IF constructs. [KKLW 801 IF c.onverwion has implications far beyond the applications \nto vectoxization. By converting con\u00ad trol depend.ences to data dependence. IF conver\u00ad sion is useful \nin such application as data flow languages, code structuring, and goto elimination. More generally, it \ndeumnstrates in a practical [McC1 56] program transformation system that any branching construct can \nbe. successfully converted to a [Quin 52] structured construct. This result, though well known [BohJ \n66, Hare 801, ia intellectually pleas\u00ad ing as well as practically useful. [Towl 76] [A1lK 821 J.R. Allen \nand K. Kennedy, ~FC: a pro\u00adgram to convert Fortran to parallel form,w Report MASC TR 82-6, Department \n[Wolf 78] of Mathematical Sciences~ Rice Univer\u00adsity, Houston, Texas, March. 1982. [AIKW 821 J.R. Allen, \nK. Kennedy~ and J. Wa*ren, nSimplifieatien of. Boolean fe-ulas in PFG,n Dept. Mathematical Sciences, \nRice University, Houston, Texas, November 1982. American National Standarda Institute, Inc., Wroposals \napproved for Fortran 8X,W x3J3/s6.80 (preliminary document), November 30, 1981. U. Banerjee, ~ata dependence \nin ordi\u00adnary programs,n Report 76-837. Depart\u00adment of Computer Science, University of Illinois at Urbana-Champaign. \nUrbana, Illinois, November 1976. c. Bohm and G. Jacopini, Tlow diagrama, Turing machines, and languages \nwith only two formation rules,n hnnuAGM 9, 5, May 1966. Burroughs Corporations, Implementation of FORTMN,W \nBurroughs Scientific Pro\u00adcessor brochure, 1977. C. Gibbons, and K. Kennedy. Simplifi\u00adcation of functions,w \nRice Technical Report 476-029-10, Rice University, January 1981. D. Harel, On folk theorems.w Gfunu AGM \n23, 5, July 1980, 379-389. K. Kennedy. Automatic translation of Fortran programs to vector form. Rice \nTechnical Report 476-029-4, Rice University, October 1980. D.J. Kuck, A survey of parallel machine organization \nand programming.w ~ 9, 1, March 1977, 29-59. D.J.-Kuck. R.H. Kuhn, B. Leasure, D.A. Padua, and N. Wolfe. \nCompiler transformation of dependence graphs, Gi2nL. ReU2r.&#38; Qf&#38;.hfili@Lh AGM -f&#38;WI Qll IkiU&#38;@l \nd Fs Williamsburg, Vs.. January D.J. Kuck, R.H. Kuhn, B. Leasure. and M. Wolfe, ~he structure of an \nadvanced vectorizer for pipelined processors. lM2s2. *CalWt&#38;LSWiS4~ Sd&#38;alX% and  GQUL. * IEEE \n, Chicago, October 1980. E<J. McCluskey. Minimization of Boolean functions,n U Sy&#38;tem M. L. 35, 5, \nNovember 1956, 1417-1444. W.V. Quine, ~he problem of simplifying truth functions, Am. M&#38;h. Mn.thly \n599 8, October 1952, 521-531. R.A.. Towk!, t~Gentrol and data depen\u00addence for program transformations, \nPh-.D . Dissezt. ation. Report 76--788s Dept. of Computer Science, University of Illinois at Vrbana-Champa \nign. Urbana, Illinois, March 1976. M.J. Wolfe, ~eehniques for improving the inherent parallelism in programs.n \nReport 78-929, Dept. of Computer Sci\u00adence, University of Illinois et Uzbana-Champaign, Urbana, Illinois. \nJuly 1978. \n\t\t\t", "proc_id": "567067", "abstract": "Program analysis methods, especially those which support automatic vectorization, are based on the concept of interstatement dependence where a dependence holds between two statements when one of the statements computes values needed by the other. Powerful program transformation systems that convert sequential programs to a form more suitable for vector or parallel machines have been developed using this concept [AllK 82, KKLW 80].The dependence analysis in these systems is based on data dependence. In the presence of complex control flow, data dependence is not sufficient to transform programs because of the introduction of control dependences. A control dependence exists between two statements when the execution of one statement can prevent the execution of the other. Control dependences do not fit conveniently into dependence-based program translators.One solution is to convert all control dependences to data dependences by eliminating goto statements and introducing logical variables to control the execution of statements in the program. In this scheme, action statements are converted to IF statements. The variables in the conditional expression of an IF statement can be viewed as inputs to the statement being controlled. The result is that control dependences between statements become explicit data dependences expressed through the definitions and uses of the controlling logical variables.This paper presents a method for systematically converting control dependences to data dependences in this fashion. The algorithms presented here have been implemented in PFC, an experimental vectorizer written at Rice University.", "authors": [{"name": "J. R. Allen", "author_profile_id": "81100653484", "affiliation": "Rice University, Houston, Texas", "person_id": "PP39052634", "email_address": "", "orcid_id": ""}, {"name": "Ken Kennedy", "author_profile_id": "81100453545", "affiliation": "Rice University, Houston, Texas", "person_id": "PP40027435", "email_address": "", "orcid_id": ""}, {"name": "Carrie Porterfield", "author_profile_id": "81100311565", "affiliation": "Rice University, Houston, Texas", "person_id": "P382836", "email_address": "", "orcid_id": ""}, {"name": "Joe Warren", "author_profile_id": "81100611449", "affiliation": "Rice University, Houston, Texas", "person_id": "PP14210854", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/567067.567085", "year": "1983", "article_id": "567085", "conference": "POPL", "title": "Conversion of control dependence to data dependence", "url": "http://dl.acm.org/citation.cfm?id=567085"}