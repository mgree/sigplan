{"article_publication_date": "01-24-1983", "fulltext": "\n Permission to make digital or hard copies of part or all of this work or personal or classroom use is \ngranted without fee provided that copies are not made or distributed for profit or commercial advantage \nand that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, \nto post on servers, or to redistribute to lists, requires prior specific permission and/or a fee. &#38;#169; \n1983 ACM 0-89791-090-7 $5.00 -2- A particular situation where such choices may bc ascflll is where a \npi-occdurc has a formal parameter intended to range over some data structure (trees of scqucnccs of objects \nof type 1, say), a data struc\u00adture that has ii number of acccptcd rcprcscntations by formal di~ta types, \nIt seems dcsirab]c to permit the definition of a polymorphic proccdurc tbi]t would accept as valid a \nnumber of such formal rcprcscntations, branching on thcm internally. 1 his kind of facility would clcvatc \nthe polymorphism of a proccdurc from the ICVC1of uscs within a single program, to the Icvcl of transportability \nfrom onc set of data structure specifications to another. 1 his kind of usc of types as arguments is \ncompatible with Rcyrmld s discipline of type abstrac\u00adtion, but not with the quantificational discipline \nof [MS] (cf. [1.ci83], $4.2). While the two disciplines, as urrintcrprctcd and unexpanded calculi, arc \ncombinatorially isomorphic t.hc difference bctwccn their intended semantics bccomcs apparent when primitive \nfunctions over types (such as discriminators over main type-constructor) arc ctmsidcrcd. I hc examples \nwc have given of uscs of types as arguments arc fairly restricted in nature: all that is used of a type \nis its syntactically rcprcscnt.able structure. l his is not merely an c!mpirical observation on our limited \nperception at present time. In a typed discipline of programming each object carries its type (explicitly \nor not), and all types of dcnotablc objects arc thcmsclvcs dcnotablc. It follows that any question that \nonc may ask about the type of a dcnotablc object rcduccs to a question about type\u00adcxprcssion(s) denoting \nthat type. The issue of semantically modeling Rcynold s rich discipline of type abstraction is thcrcforc \nrcduccd, from a pragmatic point of view, to a modeling in which questions about types are all cxprcssiblc \nas questions about type expressions. Existing approaches to the semantic modeling of data types are, \nin onc form or another, concep\u00adtual continuations of the dcnotational semantics approach to data objects. \nMcCracken [McC], follow\u00ading [Sco], defines types as retracts of the universal domain. In Shamir and Wadge \n[SW], M ilncr [Mil] and MacQuccn and Sethi [MS] types are modeled as some kind of ideal, where an ideal \nis a subset of the object-domain that satisfies certain closure conditions. In both approaches types \narc being defined via the properties that they must satisfy, as sets of objects, so as to become compatible \nwith their use. (This may be compared with the algebraic appr~ach to types, where each parficu2ar type \nis defined via. its algebraic properties rather than its intended conception). Our modeling of types \ntoo is grafted on top of a denotational semantics for the object language, However, it has a life of \nits own, and cati bc explained in isolation, or combined with, for instance, an operational semantics \nfor the object language. The point wc arc trying to make is that the semantics of types has little to \ndo with the issues of self-application and continuity which motivate dcnotational semantics. Rather than \namalgamate objects and types, as in [SW] (where types as sets of objects are treated on an equal footing \nwith objects as sets of approximations), we separate the two radically. We make no claim, of course, \nthat our approach should supplant the modeling of types as retracts or as ideals. Rather, wc believe \nthat tbc semantics we propose is related to types-as-ideals in much the same way as operational semantics \nis related to dcnotational semantics: it is closer to pro\u00adgramming practice, permits a smaller set of \nobjects, and is sensitive to the choice of formal ffamcwork (which for us is the type discipline). We \ntherefore feel that the two approaches should shed light on each other and, in combination, enhance our \nunderstanding of complex data-types and and their proper use, In particular, wc believe that even putting \ndown the dctinitions and proving basic cxistcncc theorems provides some insight about the design and \nusc of datii types. For one, our modeling of types suggests a feasible controlled usc of types as arguments \nof data objects. For another, it points to directions in setting very rich type disciplines evolving \nnaturally from a strllcttlr:il-colnptlt[~tit)l~al view of types. For instance, it may bc useful and feasible \nto consider types bllilt as certain rccursivc Sets of other types, Following preliminaries in sections \n1 and 2 wc define in section 3 what is a model of the pure polymorphic lambda calculus. A term model \nis constructed in $4, in $5 wc show how to construct a non-extensional model through the solution of \na domain equation, and in $6 wc construct an exten\u00adsional model through such a solution. 1 hc Iattcr \nconstruction involves breaking the circularity in the conditions underlying polymorphic typing, by a \nmethod akin to Girards in the proof theory of higher order logic [Gir], Wc plan to extend this work in \ntwo directions. Onc is the treatment of more general type discip\u00adlines, ofthckinds dcfincdby McCraclw~ \n[McC] and fhrthcrstudicdby MacQuccn and Scthi [MS]. 1 hccrucia] issuchcrc is that, in contrast to Rcynold \ns discip]inc, distinct typccxprcssions rnaydcnotc the same type. However, each type expression has a \nnormal h-m, which may bc viewed as its value (this view has been advocated in greater generality by Pcr \nMartin-Lof [Mar], on somcwbat more philo\u00adsophical grounds). A second direction, incorporating aspects \nof the first, is the treatment of recursively defined data types in a polymorphic context, and possibly \nmore general notions of types. 1. The Reynolds-Giri~rd systcm of type abstraction: a mathematical setting \nfor full polymorphism. 13xamplcs motivating and illustrating the use of generic and fully polymorphic \nprocedures can be fbund in [McC, ODO, FOL, 1.ci81]. 1 hc second order (or polymorphic) lambda calculus \nis a mathematical setting for expressing and investigating full polymorphism, It was invented indepen\u00addently \nby Jean-Yvcs Girard [Gir] and John Reynolds [Rey]. Its main features as compared to the sim\u00adply typed \nlambda calculus arc the constructs of type abstraction and application, If e is an expres\u00adsion (denoting \nan object) with free type variable t, then A (,e is an expression denoting the fimction that assigns \nto each type u the object e[u/f]. If the type of e is T, then the type of Ate is Al.7 (/ must not bc \nfree in the type of any free variable in e). Similarly, if e is an expression of type Al .7, and u is \na type, then e u, the result of applying e to the type expression a, is an expression of type 7[u/f] \n(More detail can bc found in these proceedings in [Lei83,$4.1]). The ~-reductions of the simply typed \ncalculus arc likewise extended to type abstraction and application: (Af.e)cr rcduccsto e[cr/1]. Write \ne=>1e if e canbcobtained from e byreplac\u00ading a subcxprcssion by its ~-rcduct (either object-or type-reduction), \nand renaming bound variables. Write s for the rcflcxivc, symmetric and transitive closure of = >1. Let \nT be the set of polymorphic type expressions, generated ind;ctivcly from a set A of atomic types and \nan unlimited list of type variables, using the type constructors ~ and A. Let CT be the set of closed \ntype expressions. 2. Whiit is u model of the lambda calculus?  The last fcw years have seen some discussion \nover what is a model of the untyped lambda cal\u00adculus, since, as HindIcy and Longo put it [HL], people \nassumed that the definition is too obvious to -4\u00ad nccd stating while at the salnc time disagreeing on \nwhat the dcfi nition should bc. Dana Scott, Peter Aczcl, lHcnk Barcndrcgt, Albert Meyer, and others have \ndiscussed the matter at Icngth [Acz, Rar, Coo, Hi., Key, MCY, Obt etc.]. A definition of what is a model \nof the simply typed A-calculus can bc readily given: the objects of type a +~ may bc chosen to bc the \nfunctions from the set of objects of typc o to the set of objects of type T. A A-expression Ax . e can \nthen bc intcrprctcd as an appropriate function of that type. l his straightforward approach, of interpreting \nobjects by functions, is no Iongcr possible for the untyped lambda calculus, where an argument to a function \nmay contain the entire (graph of the) func\u00adtion itsclfi as in the A-expression .xx. Models arc defined \nthcrcfmc via coding: objects code fhnctions, and the interpretation of an application expression ef is \nobtained by applying the fl]nction coded by e to the argument f. Of course, only sclcctcd functions can \nbc coded, but these would include the functions defined by A-expressions. ([Fri] defines also models \nof the simply typed lambda calculus via coding,) The problcrn in defining what is a model of the A-calculus \nlies in stating the intended closure rcquircrncnts on the set of functions for which a code must bc given. \nThe intention is that a code should bc given to all fhnctions that can bc defined by A-expressions over \nthe given domain. How\u00adever, spelling out this rcquircrncnt explicitly, as part of an axiomatic definition \nof models of the 1.ambda Calculus, is rather unappealing. 1 raditionally, the axiomatization of an algebraic \nstructure dots not involve the syntax of formal expressions. An alternative is to isolate closure conditions \non the set of functions in question, which imply the codability of all A-expressions. Aczcl s definition \n[Acz] supp]ics such conditions directly; some other definitions [Sco] detour via comb inators: A-abstraction \nis intcrprctablc by cornbinatom, for which algebraic closure conditions arc simple to give. Nonetheless, \ndefinitions involving evaluation directly arc often easier to understand and verify. Onc approach is \nto define an evaluation function on expressions via operations that arc part of the definition, The structure \nis then required to satisfy some equations on these values. This is the approach adopted in Barcndregt \ns A-algebras [flar] and Meyer s environment models [Mcy], An even bolder approach is to make the evaluation \nfunction itself part of the primitives, and to impose on the structure conditions linking that Iimction \nto the other primitives. This method is pursued by Friedman [Fri] (for the simply typed lambda calculus), \nIt is easy to prove that all definitions arc equivalent, with minor exceptions (compare [Coo]). Just \nas for the untyped lambda calculus, and unlike the situation for the simply typed calculus, the definition \nof what is a model of the polymorphic lambda calculus is complicated by the potential circularity of \nthe application operation. E.g., if L denotes t.hc type A(. t +/ and e is an expression of type t (say \ne = At. AXC.X) then el is an expression of type L-+1, and so e~e is a legal expres\u00adsion (of type t), \nTo set the style, wc start with a definition of what a model of the untyped lambda calculus is. Wc mention \nthe two cxtrcmcs: Aczcl s purely algebraic definition, and Friedman s heavily syntactic one (adapted \nto the untyped calculus). Wc basically follow Aczcl s approach [Acz]. It is interesting, and relevant \nto the choice of definition of what is a model of the untyped lambda calculus, that approaches based \non combinators can not bc used for the polymorphic calculus, at least not in a straightforward manner: \nthere is no simple intcrprctiition of type abstraction by combinators, because type variables may occur \nin expressions both within the types of variables and in type-arguments, 5\u00ad 1;ct D bc a set, D* the set \nof all n-place functions over D (~~~0), D # the set of simply typed functional over /~. 1.ct F ~ D u: \nthen [1 ] ([1 ]1) is the set of functions (unary functions) in D defined explicitly from 1: (using also \nabstraction). For CXillllplC, if 1S D D. j-l-l, ~D+l, ~ ~ E 1; C D #, then AJ:~(Ax.g(x)(d)) E [II ]. \nClearly, if F ~ D* then [II ] is gcn\u00adcratcd without abstraction, 1; ~ />+ D is explicidy close(i if [1 \n]1 = 1; (i.c,, all unary functions cxpl icitly defined from F arc already J ). Let f ED#, i ~ D#. f is \nconservative over F if [F,f] = [/ ], Dcfinkion 1. A kmbda sfrucw-e (a la Aczcl) is a non-empty structure \n<D ,F, Q, K>, where (1.1) 1+ Q D is explicitly closed; (1.2) 1 hc functions e : D X D + D (used in infix), \nrcprcscnting dccodcd application, and K : (D+ D )+ D, rcprcscnting function coding as objcc~ arc crmscrvativc \nover l ; (1.3) (~f ).d = fd for all unary f <F, and all dCI), The structure is infensional if F is a \nmulti-set, and the domain of K admits multiple occurrences (as distinct objects). It is clear that the \nvalue assigned by K to an argument f not in F is immaterial, since (1.3) applies only to f CF, Obscrvat.ion \n1. Condition (1.2) is equivalent to (i) e E F; and (ii) Adl o  d. 6~.K(~X.f (;, X)) < F, whenever f \n6 F.  Proof. (i) and (ii) arc special cases of (1.2). 10 prove (L2) from (i,ii) procccd by induction \non the length of the explicit definition of f < F from e and K.N In fac~ (i) and (ii) arc the conditions \noriginally stated by Aczel. As we have pointed out, the gist of the definition is that F should contain \nall the fimctions over D defined by A-expressions, via coding and decoding of abstraction and application, \nso that to each A-expression e a value [e]P (with respect to an assignment p of values in D to free variables) \ncan bc faithfully assigned by induction on e. Namely, [Ax.e]P is defined as K(AdED. [e]P[~/~l), and [ee \n], is defined as [e]P.[e ]P. It then follows, by (L3), that [(Ax.e)e ]P = [e)Plp,lPtXl = [e[e /.xllp, \nasintended. I)cfinhion 2. A lambda slrucfur-e (a la Friedman) is a structure <D, ., val>, where (LF1) \ne:DXD+D (LF2) val: Exp + Env + D where Ex# is the set of A-expressions, and Env is the set of environments, \ni.e. assignments of values in D to variables. We write [e]P for va2(e,~). (LF3) [ab]p = [a]po[b]p, [Ax.e]P.d \n= [e]P[~iX1. The structure is extensional if dl = d2 whenever dpa = dpa for all a. Proposition 2. (i) \nThe notions of an Aczcl structure and an extensional Friedman structure are equivalent. (ii) 1 hc notions \nof an intcnsional Acz,cl structure and a Friedman structure arc cquivillcnt. Proof. Clearly, an Aczcl \nstructure with the valuation dctincd above is a Friedman structure. Con\u00adversely, given u Friedman structure, \ngcncratc an Ac~,cl structure by letting F bc the set of functions of the form A~~[e]~,~l, and defining \nK(Ad[e][,l, Xl) = [Axe]. (1,3) follows from (1.t~3) by cxtcn\u00adsionality. l hc proof of (ii) is similar. \n3, What k a model of the polymorphic lambda calculus. Wc define the notion of a model of the polymorphic \nlambda calculus in the style of Aczcl and in the style of Friedman. Let D = {D },,Cr bc a family of sets. \nF is a poly~norphic family of funclions over 1) if each function in 1: is in D +D fbr some u, 7 C Cl \n, or in HoC~~D l rl ~ ~: C~+D I fu C D+ 11 for all a < C~ }, (that is, a fLmction taking each type expression \na C Cr into a value in D I tI). I.ct e be a polymorphical]y typed expression, with constants from 1) \nand l . 1 hc value [e]]) p s [e] of e is defined by induction on e; e.g., [A.x .e ] = Ad6D .[e[d/x]], \nand [A[. e ] = AuEC1 ,[e [o/~]]. F is explicitly polymorphicully closed i f all the unary functions defined \nby polymorphica]ly typed expres\u00adsions with constants from 1) and F arc already in F. I)cfinkion 3. A \npolymorphic lambda wucture (a la Aczcl) is a non-empty structure <{D } ,,m, F, e, K, *, 0, where (PL1) \nF is an explicitly polymorphically closed set of tlmctirms over D = {D },,m; (PL2) The following functions \nare conservative over F, Here e and K are as in (L2) above, except that types are required to match. \nThe functions * and d arc similarly decoding and coding functions for IToeaD l 1. . : DT+UXD7+DU, 7, \nu ~ CT (i.e. we use. as a generic notation for a family of functions .,.); K : (IY+ZY)-+D +U, *: IjAL. \n+~ .cmD [ 1 (used generically for a family of fimctions *t,), d : l_l.,aD l rl + DAtO . (PL3) (~f)od \n= fd for all f C F, f : DU+D , all d 6 D andall 7,a CCT, (@f) * u = fu for all f 6 F, f : IToccTDTIuI~l \nThe structure is irzferrsiorrcd if F is a multi-set, and the domains of o and of * admit multiple occurrences, \nNote that D may be made disjoint from D for distinct types r,u trivially, by replacing each D by D X{T}. \nObservation 3. Condition (PL2) is equivalent to (i) O, * EF,and (ii) AdlCD l s. Adk6D kA6ECT.~(Ax ED \n.f (~,?i,x)) C F whenever f C F,  1; whcncvcr ~ E J . Kxwnplc. A special case of an intcnsional structure \nis when f is allowed to bc spccificd by values for argumcn~$ not in the /)7 intended as its domain. More \nprcciscly, D ~ D for all r, and ftmctions in DO+ D arc spccificd as restrictions of functions in D + \nD, where the restriction of distinct fhnc\u00adtions is considered distinct. The closure conditions (PL2) \narc then equivalent to: (i)., *EF, (ii) A; El~.AFEC1 ,~(Nx6 D.~(~,6,x)CF whcncvcr f CF; here A x ED.A4 \ndcnotcs t.hcoccurrcnccof A.xCD ,M that correspond stot. hcfullcxtcnsi onofM: different M s will givcrisc \ntodistinct occurrences. Next we show, inproposition4, the sense in which astructurcofthc kind above \nisarnodcl of thcpolymorphic ltimbda calculus. Dcfkthcvaluc [e]t,p in the structure by induction on e, \nwhere ~ is an assignment of closed types to type variables, and p is an assignment of values to variables, \nsatisfying pXT C D( , simultaneously showing that this value is a continuous function of the values assigned \nby &#38; and p, The definition and the continuity statcrncnt arc trivial when e is a free vari\u00adable. \nFor compound e, procccd by cases, [Ax . a ]t,P = Ic(~d< D .[u]t,P[~lX1), which is well defined by (P1.1), \n(1)1.2) and induction assump\u00adtion, [ablt,p= [alf,ps[~lt.po [A[.a]t,, = d(Acr6C ~.[a]ti~itl,P )-, this \nis WC1ldefined bccausc t cannot occur free in the type of x (by the syntactic restriction on tic formation \nof polymorphic expression, mentioned in $1), and so p is not affcctcd by the change in the substitution \n~, [au]t,p = [a]t,p*$u. Proposition 4. (i) [oixo,a )b]t,p = [a[b /x]]t,P; and [(ALaAr9U]t,P = [a[rrllllt,p. \n (ii) [e ](,P 6 D , 9  Proposition 5. (Complctcncss) Suppose S is a polymorphic structure over D, and \nlet e and e be closed polymorphic expressions, 1 hcn [e]l) = [e ]1) whcncvcr e a e . Proof, Immediate, \nsince reductions prcscrvc values. Corollary 8 below is a converse to proposition 5, The definition of \na model of tic polymorphic lambda calculus in the style of Fricdrnan is straightforward. Definition 4, \nA polymorphic lambda structure (a la Friedman) is a structure <{ DT}r6cr, . ~,r, *C,,, val>, where (PL.F1) \ne ,,O:D + XD +D , and f,:w xcl+u 1) with d*u ~ D l tl for d E D*tT; 161 (~]1.1:2) v~7/: ];x1) + Tfiuv \n+ h tlV + D where IJxI) is the set of polymorphic cxpi cssions, TL Hv is the set of assignments &#38; \nof closed typo expressions to type variables, and L }lv is the set of assigmncnts p of objects to variables, \nwith px C D , Again. wc write [e]t,P for val(e,(,p). 0 lJ:3) [~J - JOlf,p= [~l(,p.o,[blf,p: [Ax.e]t,pod \n= [e]tp[djxl (with matching types); [aAf u]~,p = [fll~,p ,,,((0); [At.u ]t,P*,,, u = [ult[o/rI,p. 1 \nhc structure is ex/emio??al if, for dl, d2 E DO+ , dloa = d20a for all a C D implies that dl = d2; and \nfor d1,d2 C l)At , dl%u = d2*u for all u E C~ implies that dl = d2. Proposition 6. (i) The notions of \nan Aczcl polymorphic structure and an extensional Friedman polymorphic structure arc equivalent. (ii) \nfhc notions of an intcmional ACZCI polymorphic structure and a Friedman polymorphic structure arc equivalent, \n4. A term model for the polymorphic liitnbd~ calculus. 1 hc construction of ,tcrtn structures is a standard \nmethod in the model theory of the untyped A\u00adcalculus [Bar]. l-hc rncthod has also been applied to the \nsimply typed A-calculus [Fri]. Although the interest of such models is lirnitcd, as argued convincingly \nin [Mcy], the simplicity of tic construction makes it worth mentioning. Lcrnma 7. Suppose that el[~l \nt] -e2[~/ I], where ~ is any (closed) type. Then el s e2, Proof. Clearly, if a[~ / ~] /1-rcduccs to b \n[~/I] then a /1-rcduccs to b (contrary to object substitu\u00adtion, type substitution can generate no ncw \nredcx, because type expressions arc never applied to any\u00adthing). The lemma immediately follows by induction \non the number of ~-reductions needed to justify el[7/1] -ez[7/1]. 9 For an expression e of the polymorphic \nlambda calculus let E denote the equivalence class of e with respect to =. I)cfine a structure <{ Dr},~Cr, \nF, o, K, *, d> as follows. OD = { g I e is an expression of type 7}; O F = the set of polymorphic functions \nover D = {D,}7~a defined by polymorphic A\u00ad cxprcssions (as in 53); o a - eb = ~; O If ~ is defined by \na polymorphic expression Ax.a then let Kj = h. This is well defined, bccausc if f is also defined by \n?ix.b, then fx = Q = 4 (where x is a variable of the appropriate type), and so b = &#38;b; c) (gA~ y(J \n= ~; O If f is defined by a polymorphic expression Ate, then let $f = A.&#38;. This is well defined by \nlemma 4. Theorem 8. The structure <{ D,}rcm, F, ., K, *, 0> is a extensional polymorphic lambda structure. \n162 -9- Proof. Straightforward from the definitions (compare [Bar] for the untyped calculus, and [I:ri] \nfor the simply typed calculus). H C~rolliiry 9. If e # e then there is a cxtcnsiorml structure S oycr \na polymorphic family D = {D, },cCr such that [e]l) * [e ]l).* 5. Intcnsiomrl models through domain equations, \nWc mentioned that the purely syntactic nature of term models limits their interest (as for term models \nof the untyped lambda calculus). Here wc outline a method for constructing polymolThic models by domain \nequations, with the additional property that the model function-coding agrees with the domain fhnction-coding. \nAssume, for simplicity, that there is only onc atomic type /l, and Ict bc the set of objects of type \n~. l.ct D bc a solution of the rccursivc domain equation 1) ~ 1) + (D-f)) + (CI +D) where, again, Cl \nis the set of closed type expressions, pcrccivcd as a discrctc domain. Let isbasic, mtesolj lakwype bc \npredicates over D such that, for instance, /akesoLjld) states the membership of d 6 D in the second summand. \nSimilarly, let in and OUI bc the natural injcctkm and projec\u00adtion operations for the functional summarlds. \nThe A-T-expressions arc gcncratcd inductively from (untyped) variables, by A-abstraction (over object-variables), \nA-abstraction (over type variables), object application and type application. Thus, a A-T-expression \nis a polymorphic expression without type superscripts, If e is a A-T expression, $ an assignment of closed \ntype expressions to type variables, and p an assignment of clcmcrrts of D to object variables, then wc \ndefine the value [e ](,P by induction on e, simultaneously showing that fiis value is a continuous fimction \nof the values assigned by ~ and p. The definition and the continuity statement arc trivial when e is \na free variable. For compound e, pmcecd by cases. (1) [Ax,a]t,, = in(AdCD. [a]t,PI~/~l), which is WCI1defined \nsince the function in the scope of in is continuous by induction assumption; this value is continuous \nin ~ and p, since tic projection of a continuous flmction is continuous.  (2) [ab]g,P = oti/([alg,PXbl{,P \n(where lakesobj(a) holds since ab is a well-formed expression); continuity is immediate by induc\u00adtion \nassumption.  (3) [Af.alt,p= in(ATECT.[alt[,WC]] defined by induction assumption; con\u00ad  ttl,p),whichagain,is \ntinuity is assured as in (l). (4) [au]&#38;,p = Ofmlg,p)u. Ddinc D (? E CT), F, e, K, * and d as follows, \nODB=B, O D = { [e] I e is a closed A-T expression obtained by stripping a polymorphic expression of \ntype T of type superscripts }, for 74 ~. O define F by conditions (i) and (ii) of the example in S3, \nwith 0 UJ = in(f) ft)r f:ll+ll and O df = in(f) where f :CI +D; O [a -+ ].[b ] = oul([u])[b]; O [eA[ \n]*O = OUI([c])O. It is easy to SCC,from the definition of [e] for a A-rl expression e, that the the clauses \ndefining K, e, 6 and * can bc rcplaccd by clauses similar to the ones defining the term model in $4, \nwithout changing the structure. For example, K may bc defined by K(~d~D. [e][d,,l) = [Lx. e], and s may \nbc defined by [a]o[b] = [ub]. Theorem 10. The structure <{ D7}TCCT, F, ., K, *, $> is an intcnsional \npolymorphic lambda struc\u00adture. Proof. Straightforward from the definitions. 9 6. lktcnsiomd models through \ndomain equations, Consider again a solution D of tic domain equation D =B+(D+D)+(cr+D) The pmblcm in \ndefining an extensional model over D is that it is not possible to assign a tight value to a polymorphic \nA-expression, as long as the subdomains D (7 C CI ) arc not defined. On the other hand, delineating the \nDT s cannot be done by a straightforward induction on 7, because to dctcrrninc membership of d 6 D in \nDAr r one needs to have already defined tic subdomains D,[IJft] Definition 5. An assignment J of subsets \nof D to closed type expressions is an interpretation if for any d < J(u+T) and d E Ju, ou[(d)d C Jr. \nFor each subset S of D, let &#38; be a distinct constant. The generalized closed (ypes are the closed \ntype expressions over tic atomic types /3 and S. For each generalized closed type T, define a set of \nvalues {7} ~ D, by induction on 7, {~j =B; {Sj =s; d C {~+u} iff kzkesobj(d), domain (ou[(d)) = {7}, \nand oul(d)d E {u} for each d E {T}; d E {At.?} iff fake.stype(d), and OU1(d)u 6 {~[~/ []} for each u \nC CT and each interpreta\u00ad tion J. Lemma 11. (Substitution), {T~/1]} = {T[ai[]}o Proof. Straightforward \nby induction on T. Lemma 12. Define JO by JOU = {u} (u < CT). Then JO is an interpretation. Proof, lmmcdiatc \nfrom the ddlnition of {}, I,ennllil 13. Let ~ be a vector of interpretations. [e ]t,p c { T&#38;]} where, \nif ~ = [al//l]  . [ok //k] then ~ denotes the substitution [.llul//l]  [~llk]. Proof. 13yinduction \non e. The closure condition in t.hc definition of interpretations is used here. lxx D = {7} (T c cl), \nD = {D,},ccp For a polymorphic A-expression e define tic value [e]:, by induction on e, where ~ and p \narc as in $3. [M .a ]&#38; = i/r(AdE/~O.[a]~,pldfXl); [d]:, = Ouml::pwl?p; [Af.aT]~~P = i/~(AaeC~.[a]~l~/tl,P); \n[au];:, = Oul([(z]::p)((a). I.ct now the clcmcnts of the set F bc all the unary functions defined explicitly \nover D by polymorphic A-expressions, i.e. the functions of the form AdCD .[e ]I~lXl, where X, of type \na, is the only free variable in e, or AoEC1.[e ][alll, where I is the only free variable in e, Finally, \ndefine the constant ., K, * and 0 by clod = uut(d)d . where d 6 D - , d <D ; Kf = in(f), W here (akesobj(.f), \nf ~~; d u = out(d)u, where d C DAL ; @f = in(f), where lakes fype(f), f CF. Theorem 14. The structure \n<{ Dr}Tcm, F, ., K, *, d> is an extensional polymorphic lambda struc\u00adture. Proof. The only things to \ncheck which are not already implicit in the definitions are the ranges of the constants ., *, K and f?. \nIf d C D - and d E D then indeed clod = ow(d)d 6 D = {u}, by the definition of D + = {7~g}. Suppose that \nd 6 D*t = {A f.T}. Then d*u = ou[(d)u E {r[lQ/ I]} for all u C Cr and all interpretations J, by the definition \nof {At ,7}. In particular, for the interpretation Jo, itfollows from lemma 12 that d 6 {7~/ 1]}, and \nthe last set is equal to {7[0/1]} by lemma 11. If f C F, [akesobj~), then f = AdCD .[e ][~,Xl, and Kf \n= inf. we have then Kf 6 ~ + = {u+T} by definition of {}. If f C F, [akeslype(f), then f = Au CCT.[e \n][.,q, and df = inf. We have then Of e {A;. T} by definition of {} and Icmrna 13. Rcfcrcnces. [Acz] P. \nAczel, Frcgc Structures and the notions of proposition, truth and SC4\u00b0 The K2eene Sympo\u00adsium, Ilarwisc \nct als., eds., North Holland, Amsterdam, 1980, 31-60. [Rar] H.P. Rarcndrcgt, The Latnb(ia Calculus, 1/s \nSyntax and Semun(ics, North Holland, Amsterdam, 1981, xiv+615pp, [Coo] D. Coopcmtock, Alternative axiomatizations \nof models of lambda-calculus, 1 cchnical Report 151/81, Department ~f Computer Scicncc, University of \n1 oronto, 1981, 72pp. [FI.0] S. Fortune, D. I.civant, and M. O l)onncll, The cxprcssivcncss of simple \nand second order type structures, IBM Research Report RC 8542, 1980, 73pp; to appear in the Jow-nal of \n(he ACM. [Fri] H. Friedman, F,quality bctwccn functional, i.ogic Co/loquiutn (Procccdings of a symposium \non Logic held at Boston, 1972-1973), (editor R. Parikh), Springer-Vcrlag (1.ccturc Notes in Mathematics \n453), Ilcrlin, 1975, 22-37. [Gir] J.-Y. Girard, Intcrpretalion jlmctione[le et elimination des coupures \nclans l ariihrnetique d m-dre superieu~ These dc Ihctorat dMat, 1972, Paris. [HI,] ~1. Hindlcy and G. \nLongo, I .arnbda calculus models and cxtcnsicmality, Zeit. f Ma/h. l.ogik u. Grund der h4alh. 26, 1980, \n289-310. [Key] CY.J. Koymans, Models of the l,ambda calculus, Preprint Nr 223, Department of Mathemat\u00adics, \nUniversity of Utrccht, 1981, 45pp. [1.ci81 1>. Leivant, The complexity of parameter passing in polylnorphic \nproccdurcs, Thirteen/h Annual Symposium on Theoiy of Computing (SIGACT), 1981, 38-45, [1.ci83] D. Leivant, \nPolymorphic type infcrcncc, these Proceedings. [Marl P. Martin-Lof, Constructive mathematics and computer \nprogramming, Proceedings OJ lje .. Sixlh In(erna[ional Congress for I.ogic, MelhodojoW a)jd lihilosophj \nof Science (-Hanover, 1979). North-Holland, Amsterdam, 198?. [McC] N.J. McCracken, An Invesligalion of \na Programming Language with a Polymorphic Type Su-uclure, PhD Disscration, Syracuse University, 1979, \n125pp. [MS] D.]]. MacQuccn and R. Set.hi, A semantic model of types for applicative languages, ACM Symposium \non LISP and Punc[ional Programming, 1982. [Mey] A. Meyer, What is a model of the Lambda Calculus (expanded \nversion), Technical Repor~ MIT, 1981, 40pp. [Mil] R. Milncr, A t.hcory of type polymorphism in programming, \nJournal of Computer adn System Sciences 17 (1978), 348-375. [Obt] A. Obtulowicz, Functorial semantics \nof the type free A-~q claculus, Fundamentals of Compu\u00ad/a/ion Theoty, Lecture Notes in Computer Science \n56, Springer Vcrlag, Heidelberg, 1977, 302-307. [ODO] M.J. O llonncll, A programming language theorem \nwhich is independent of Pcano Arith\u00admetic, .Weverrth Annual ACM Symposium on Theory of Compuling, 1979, \n176-188. [Rey] J.C. Reynolds, Towards a theory of type structures, in Pro2ramminR Symposium (CoIloque \nsur la ~ rogrammaliofi Paris), Springci (Lecture Notes in ~omputcr-Sc_icncc 19), Ilcrlin: 1974, 408-425. \n[Sco] D. Scott, Data types as lattices, SIAM Journal of Computing 5 (1976), 522-578. [SW] A. Shamir and \nW.W. Wadgc, Data types as objects, Proceedings of the Fourlh ICALP Confer\u00adence, Turku, Finland, 1977, \n465-479. \n\t\t\t", "proc_id": "567067", "abstract": "<p>The semantic modeling of data types has been the subject ofincreased interest over the last few years, enhanced by thedevelopment of applicative languages such as Edinburgh's ML andHOPE, by the need for flexible highly structured languages thatwould nonetheless be amenable to verification, and by ongoinginquiries on polymorphism in programming languages. In particular,there has been a growing interest in generic type structures suchas the Reynolds-Girard discipline of full polymorphism, furtherextended by McCracken [McC] and MacQueen and Sethi [MS], and inuser-defined and recursively-defined types.</p><p>Our aim here is to model semantically the notion of type so asto encompass full polymorphism, but in a very controlled way whichon the one hand allows the modeling to remain simple, and on theother hand conveys as much of the notion of type as seems feasiblyrelevant to programming languages.</p><p>Our leading idea is that a type is a structural condition ondata objects rather than a collection of objects which satisfiescertain closure properties. Roughly, we argue that such structuralconditions are fully conveyed by syntactic expressions, not inisolation of course, but within a syntax-oriented <i>typediscipline. In other words, we treat types as discrete objects,which merely code the ways data objects are allowed to interact (asin applying functional object</i> a to object <i>b</i>). Once atype discipline is set to delineate a set of type expressions, andonce the meaning of the type-constructs is imposed on the ways thedata objects relate, the meaning of each type expression isconveyed by the expression itself (reduced to a canonical form ifnecessary). This conception of types permits a strikingly simplemodeling of the use of types as arguments of data objects, a usecentral to Reynolds' polymorphic type system [Rey].</p><p>The use of types as genuine arguments of procedures is notdevoid of practical interest. E.g., one may wish to treat objectsof type &#244; generically, except for an initial choice dependingon the principal type-constructor of &#244;, that is, according towhether &#244; is an atomic type, a functional type, a cartesianproduct, etc.</p><p>A particular situation where such choices may be useful is wherea procedure has a formal parameter intended to range over some datastructure (trees of sequences of objects of type <i>t,</i> say), adata structure that has a number of accepted representations byformal data types. It seems desirable to permit the definition of apolymorphic procedure that would accept as valid a number of suchformal representations, branching on them internally. This kind offacility would elevate the polymorphism of a procedure from thelevel of uses with in a single program, to the level oftransportability from one set of data structure specifications toanother.</p><p>This kind of use of types as arguments is compatible withReynold's discipline of type abstraction, but not with thequantificational discipline of [MS] (cf.[Lei83], &sect;4.2). Whilethe two disciplines, as uninterpreted and unexpanded calculi, arecombinatorially isomorphic the difference between their intendedsemantics becomes apparent when primitive functions over types(such as discriminators over main type-constructor) areconsidered.</p><p>The examples we have given of uses of types as arguments arefairly restricted in nature: all that is used of a type is itssyntactically representable structure. This is not merely anempirical observation on our limited perception at present time. Ina typed discipline of programming each object carries its type(explicitly or not), and all types of denotable objects arethemselves denotable. It follows that any question that one may askabout the type of a denotable object reduces to a question abouttype-expression(s) denoting that type. The issue of semanticallymodeling Reynold's rich discipline of type abstraction is thereforereduced, from a pragmatic point of view, to a modeling in whichquestions about types are all expressible as questions about typeexpressions.</p><p>Existing approaches to the semantic modeling of data types are,in one form or another, conceptual continuations of thedenotational semantics approach to data objects. McCracken [McC],following [Sco], defines types as retracts of the universal domain.In Shamir and Wadge [SW], Milner [Mil] and MacQueen and Sethi [MS]types are modeled as some kind of <i>ideal,</i> where an ideal is asubset of the object-domain that satisfies certain closureconditions. In both approaches types are being defined via theproperties that they must satisfy, as sets of objects, so as tobecome compatible with their use. (This may be compared with thealgebraic approach to types, where each <i>particular</i> type isdefined via its algebraic properties rather than its intendedconception).</p><p>Our modeling of types too is grafted on top of a denotationalsemantics for the object language, However,it has a life of itsown, and can be explained in isolation, or combined with forinstance, an operational semantics for the object language. Thepoint we are trying to make is that the semantics of types haslittle to do with the issues of self-application and continuitywhich motivate denotational semantics. Rather than amalgamateobjects and types, as in [SW] (where types as sets of objects aretreated on an equal footing with objects as sets ofapproximations), we separate the two radically.</p><p>We make no claim, of course, that our approach should supplantthe modeling of types as retracts or as ideals. Rather, we believethat the semantics we propose is related to types-as-ideals in muchthe same way as operational semantics is related to denotationalsemantics: it is closer to programming practice, permits a smallerset of objects, and is sensitive to the choice of formal framework(which for us is the type discipline). We therefore feel that thetwo approaches should shed light on each other and, in combination,enhance our understanding of complex data-types and and theirproper use.</p><p>In particular, we believe that even putting down the definitionsand proving basic existence theorems provides some insight aboutthe design and use of data types. For one, our modeling of typessuggests a feasible controlled use of types as arguments of dataobjects. For another, it points to directions in setting very richtype disciplines evolving naturally from a structural-computationalview of types. For instance, it may be useful and feasible toconsider types built as certain recursive sets of other types.</p><p>Following preliminaries in sections 1 and 2 we define in section3 what is a model of the pure polymorphic lambda calculus.A termmodel is constructed in &sect;4,in &sect;5 we show how to constructa non-extensional model through the solution of a domain equation,and in &sect;6 we construct an extensional model through such asolution. The latter construction involves breaking the circularityin the conditions underlying polymorphic typing, by a method akinto Girard's in the proof theory of higher order logic [Gir].</p><p>We plan to extend this work in two directions. One is thetreatment of more general type disciplines, of the kinds defined byMcCracken [McC] and further studied by MacQueen and Sethi [MS]. Thecrucial issue here is that, in contrast to Reynold's discipline,distinct type expressions may denote the same type. However, eachtype expression has a normal form, which may be viewed as its\"value\" (this view has been advocated in greater generality by PerMartin-Lof [Mar], on somewhat more philosophical grounds). A seconddirection, incorporating aspects of the first, is the treatment ofrecursively defined data types in a polymorphic context, andpossibly more general notions of types.</p>", "authors": [{"name": "Daniel Leivant", "author_profile_id": "81100590610", "affiliation": "Carnegie-Mellon University", "person_id": "PP43121688", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/567067.567083", "year": "1983", "article_id": "567083", "conference": "POPL", "title": "Structural semantics for polymorphic data types (preliminary report)", "url": "http://dl.acm.org/citation.cfm?id=567083"}