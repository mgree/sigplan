{"article_publication_date": "01-24-1983", "fulltext": "\n Permission to make digital or hard copies of part or all of this work or personal or classroom use is \ngranted without fee provided that copies are not made or distributed for profit or commercial advantage \nand that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, \nto post on servers, or to redistribute to lists, requires prior specific permission and/or a fee. &#38;#169; \n1983 ACM 0-89791-090-7 $5.00 Balance(a) Returns the balance of the account 2. LOCALIZATION UNDER CURRENT \nPROGRAMMING whose acc# is a. LANGUAGES To demonstrate the need for localization of power in computer \nsystems, and the degree to which it E supported by current programming languages, corroder the following \nexample. Suppose that a large fmanclal institution decided to computerize Its operations The controller \nof this mstitut! on, being fearful of losing control over the accounting process to a large, incomprehensible \nand unrehable computer system, gave the following drrective to the system designer: 1 know better , said \nthe controller, than to expect the system to work perfectly at all times and in every small detail But, \nthere are a few properties which I consider crucial for the system. I want you to design the system in \nsuch a way that at least these properties can be confidently relied upon, In fact, I want you to be ah/e \nto prove to me that your system indeed satisfies these properties . Suppose that the first requirement \non the controller s list has been that all financial transactions should conform to the fundamental principle \nof double entry accounting That is, money credited to one account should always be debited to another. \nA particular consequence of this principle, assuming that new accounts are always opened with zero balance, \nis that the formula E Balance (a,) = O must be satisfied at all times, where Balance(a) is the number \nof dollars m account a, and the sum is taken over all accounts in the system. The requirement, then, \nis that this law of conservation of money be established as a provable property of the system4 We shall \npresently see that even this seemingly modest requirement cannot be satisfied unless the programming \nlanguage being used supports some kind of localization of power. 2.1: A Case of no Locality Assuming, \ninitially, that the system IS to be written in the machine language of a conventional Von Neumann computer, \nhere is a reasonable, but as we shall see, unsatisfactory, attempt to satisfy the controller. We first \ndesign a data structure in which all the accounts in the system are to be stored Secondly, we write the \nfollowing set of procedures to manipulate and access this structure Open(acc-type,name) This procedure \nis designed to create a new account with zero balance, returning a unique identifier for it, which we \nwill call acc#. (The parameters of this procedure serve to characterize the account being opaned.) More \nelaborate version o< this law, which deals expllcttly with the flow of money mto the system and out of \nL, IS dtscussed m [171. Move(d,a 1,a2) Credits d dollars to account a2 and debits account al correspondingly. \nThus moving, m effect, d dollars from al to a2 (It is to be noted that the balance of either account \ncan be negatwe before this operation takes place, or afterwards.) Close(a) Closes account a, provided \nthat it has a zero balance. Finally, we instruct the programmers participating in the proJect not to \naccess the data structure for accounts, except by means of these four procedures. At this point we might \nargue as follows. Assuming that the code which implements these procedures is small enough, it should \nbe easy to verify, directly from this code, that these procedures work as explained above Given that \nthese are the only procedures which access directly the representation of accounts, it follows that our \nlaw of conservation of money is satisfied. Indeed, new accounts are opened with zero balance, and are \nclosed only if their balance is zero. Moreover, the only way to change the balance of an account is by \nmeans of the Move procedure, which ieaves the sum of all balances unchanged Unfortunately, this is a \nfallacious argument. Even if none of the programmers would intentionally attempt to access the account \ndata structure directly, which is by no means certain, such an access might in fact take place inadvertently. \nIndeed, an error in the code, anywhere in the system, can cause, directly or indirectly, a destructive \naccess to the accounts data structure. To prove that such an access never happens one would have to do \na complete analysis of the entire system, and to repeat such an analysis after every change to the system, \nhowever minute, This failure to establish conservation of money as a provable property of the system \nis not the fault of the specif!c design described above Rather, it is the result of the fact that (most) \nmachine languages do not have any provmon to limit the power of any part of a program, as can be demonstrated \nby the following example Consider a program R written m machine language. Suppose that we are allowed \nto see the entire text of the program, except of a small part of it, which may be as small as a sing/e \ninstruction (see Figure 2 l). The question is what can we say with certainty about the behavior of this \nprogram? The answer to this question is that in spite of the almost complete knowledge we have about \nthe program R, there is almost nothing we can say about it with confidence. Indeed, fr~m the moment that \ncontrol gets to the hidden mstructlon , almost anything can happen, depending on what this mstructlon \nreally is. In some sense, then, the hidden instruction has an unlimited power with respect to the rest \nof the system. 5 This moment can be determmed from the vtsrble part of rhe program Figure 2-1: The possible \neffect of a hidden mstructlon on the behavior of a program is quite unpredictable We can conclude, that \nas long as our accounting system IS to be written m conventional machme language, the controller can \nnever be really confident that the system conserves money, no matter how well the system has been designed, \n2.20 A Simple Cese of Localization of Power Suppose now that our accounting system IS to be wrttten entrely \nin the Ada Isnguage [10], The approach described above for the Implementation of conservation of money, \nwhich has been shown not to be auf fwent m the context of a mschme language, can now be reinforced by \nmeans of the package construct of Ada, as follows, Consider a package called Accountlngl wh!ch encapsulates \nthe data structure for accounts, together with the procedures Open, Balance, Move and Close, designed \nto operate on accounts, as noted above The body of this package is not shown here, but Its specification \npart is as follows peckege Accounting, ia Function Dpen(name, class: Symbol) return Integer; Function \nBalance (a: Integer) return Integer; Procedure Move (d, al, a2:lnteger); Procedure Close (a:lnteger); \nend Account ingl Package; Assummg that the Ada compiler is correctly implemented, the rules of the Ada \nlanguage guarantee that the Internals of the package cannot be accessed from the outside, except via \nthe four procedures defined above to be visib/e. Therefore, all one has to do to prove that the system \nconserves money IS to show that the procedures defined m the body of the package are built according \nto We WIII have several versions of th!s package, thus the index 1 our speclflcatlon Moreover, if this \nis indeed the case then the conservation of money cannot be affected by anything which might happen outside \nof this package It is, in short, just what the controller ordered 2.3. The Concept of Support Note that \nthe property which we called conser vatlon of money E supported by the Accountmgl package, m the sense \nthat Its vahd!ty IS quke independent of the rest of the system, as long as the system IS written entirely \nm Ada This observation motwates the following definition Gwen a programming language L, a property P \nIS said to be supported by a ptece of code R If and only If the following condltlon ts satwfled (W) [RCS \n+ P(S)] where the universal quantifier ranges over all systems S which can be written in L (We also say \nm this case that R !s the Support of P, and that P is localized In R] Two conditions must be satwfled \nfor a property P to be thus supported by a piece of Code R F!rst, tt IS obviously necessary for P to \nbe somehow estabhshed by R, Just as the conservation of money E presumably estabhshed by the body of \nour Accountingl package The second, and far more d} fflcult, condition IS that the rest of the system, \nany system which includes R, wou/d no? have the power to violate P. In other words, the power to affect \nP must, somehow, be /oca/ized lrr t?, This, m turn, IS posstble only If the programming language m question \nimposes an appropriate dlsclplme on all programs written m m In our example above, the Ada language indeed \nlocalizes the power to violate the conservation of money mslde the Accountmgl package, by preventing \nall other parts of the system from accessing the internals of the package We also saw that conventional \nmachine languages do not support any such localization Moreover, it turns out that many hjgh level languages \nsuch as FORTRAN, PL/1, Pascal and COBOL, do not allow for strict localization of power, in spite of their \nexplicit modularization capabilities For example, It is well known that one procedure of a FORTRAN program \ncan affect, in an unpredictable way, the behawor of another procedure, even if the two procedures are \ncompded separately and have no variables in common, simply by means of an out of bound reference to an \narray Furthermore, as we shall see later, even the localization capability provided by Ada leaves much \nto be desired Two aspects of the definmon above are worth po!nting out Frst, The region R which serves \nas the Support of P does not have to be a consecutwe set of instructions It can consmt of several modules, \nor even several parts of modules Secondly, the property P, being supported by R, does not have to be \na local property of this region As we shall see m the following section, P may be a property of the entre \nsystem, even If It w supported by R alone 2.4. A More Sophisticated Case of Locality Let us cons!der \nan alternaiwe implementation of accounts, by means of a package called Accourrring2, which does not store \nthe actual representation of all accounts wlthm Its own body Instead, this package defines a type Account \n(whose instances are meant to represent mdwdual accounts) together with the procedures destgned to operate \non them The type Account itself IS not made vmble to the outside, but the package Accountmg2, spec!fled \nbelow, does make vmble the type Ace, defined as access Account , (1.e pointer to Accounts) Package Accounting \nis end typp Acc function procedure procedure function Account accesa Account; Open (acc-type, Move (d:lnteger, \nClose (a: Acc); Balance (a: Acc) ingz package; name: al, return Symbol) a2:Acc) Integer; return ; Ace; \n The Open operator is now assumed to create a new Account object, on the heap, returrvng a pointer to \nIt The other three operators are defined to operate on objects of type Ace, that is, on pointers to accounts, \nrather than on integers which identify them Since the type Account Itself ts hidden within the Accounting \npackage, there is nothing one can do with Account o i Jects, outside of th!s package, except by means \nof these procedures It follows then, that If these procedures operate essentially as spec!f+ed in section \n21, then the law of conservation of money E. satisfied It M notable, however, that since accounts are \nto be distributed throughout the system, the conservation of money is now truly a property of the entire \nsystem, and not, as before, of the local data structure of the package m question Although both Implementations \nmanage to support our conservation of money, the latter one has a notable advantage over the former, \nas N fachtates the support of additional, related properties. Indeed, suppose that we have a certain \npoltcy concerning a gwen account a, which we wish to localize in some small region of the system Such \na policy, to be denoted by P may specify the a circumstances under which money IS allowed to be movad \nInto this particular account or from It; It may also prescribe certain additional acttons to be employed \nwhenever such movement of money takes place. If accounts are being implemented by the Accountmg2 package \nthen the policy P, can be localized as follows let M be a module, say a package, m which the account \na IS cr%ated by means of a statement Actually, the law of conservation can b violated If an account wtth \nnon-zero balance IS garbage-collected There IS a s$mple f!x to this problem which IS discussed In [18] \nq= := Open (...), which stores a pointer for the newly created account m the variable q If Ma IS programmed \nnot to provide any a other part of the system with a copy of the pointer qa , then tm other part of the \nsystem would be able to access a, because pointers cannot be forged m a strongly typed language like \nAda The package Ma can therefore be designed m such a way that K, together with the package Accountmg2, \nwould support the pohcy Pa Moreover, it IS possible, in thm way, to Iocallze several policies, concerning \ndifferent accounts, in separate modules On the other hand, such a localization would be quite impossible \nIf the Accountmgl package IS being used Indeed, recall that in thm case accounts are being identified \nby their acc#, which is simply an Integer Now, suppose that the pohcy m question concerns an account \nwhose acc# IS 31415. For this pohcy to be Iocahzed m some module, say M, it is necessary that the rest \nof the system would not be able to do anything with this account However, any part of the system which \nhas access to the Move operator, which IS the entire scope of the Accounts module, can revoke an operation \nHove (d,31415, a2) thus debkmg this account by $d, m possible wolation of the policy at hand It is, of \ncourse, possible to Implement and localize any given pollcy Pa , inside the Accounting, package Itself \nThis would mean, however, that pohcles concerning d! fferent accounts cannot be Iocal!zed separately \nMoreover, such an Implementation would inflate the size of the Accounting, package, which serves as the \nSupport of the law of conservation itself. The importance of the Size of the Support of a property IS \ndiscussed in the following sect+on  2.5. The Principle of Minimal Support As has been !mphed prewously, \nthe provability and the stab{/lty of a gwen property P of a system, depend, m some sense, on the size \nof Its Support Indeed, since, by defmmon, the Support of P IS the only part of the system wh!ch IS relevant \nto this propertv, it should, m general, be caster to prove P If Its Support IS smaller For axample, It \nIS the presumably small size of our Accounting package which should allow us to verify whether or not \nthe system conserves money, It does not matter m this context If the proof E to be an informal or a formal \none Both should benefn from the small s[ze of the Support Moreover, it can be argued that the size of \nthe Support of a property P can be used as a reasonable, even if crude, measure for its jnstab//ify Given \na system S which satisfies a property P, we can equate the instability of P with the probability that \na random change in the system would violate th!s property Now, since P can be affected only by changes \nm its Support, there IS some )ustlflcat!on to the following formula for the instabdity of P Instability(P) \n= l$upport(P)l where lSupport(P)l stands for the size of the Support of P. These observations suggest \nthe following heuristic prmcipie for the des!gn of large scale systems important properties of a system \nshould have a minimal Support. This pnnctple of mmimal Support IS related, but as we shall see not identical, \nto the well known principles of hiding [21, 22, 23] and of abstraction [12, 11, 11 Note, m particular, \nthat from the point of view of data abstraction there E httle difference between the packages Accounting, \nand Accounting Both implement accounts as abstract objects, prowdmg operators for them, and ensuring \nthat they satwfy certain mvarlant properties, such as our law of conservation of money. From the point \nof view of localization, on the other hand, the two packages are quite dtfferent Indeed, as has been \nargued in section 24, the package Accountng2 allows for smaller Support for policies for indwldual accounts, \nthan IS possible when Accounting, is being used (Some additional differences between the principle of \nabstraction and that of mmmal Support wdl become apparent later on) 2.6. Limitation of the Localization \nCapability in Ada Unfortunately, the localization capabhtles provided by the scope rules of programming \nlanguages, augmented by such constructs as the packages of Ada, and by analogous devises m languages \nsuch as Simula-67 [2] and CLU [13], are not sufficient to satisfy the above principle of mmmal support, \nas we will try to show by the following example Contm.mg with the accounting system, suppose that our \ncontroller has certain pohcies m mmd concerning the opening and closing of new accounts The policy concermng \nopening, to be denoted by PoPen , could spfscify the condmons under which accounts should be opened, \nand possibly some act!ons which should be taken whenever a new account is opened. The analogous policy \nconcerning the closing of accounts will be called PCl,~e. For these policles to be Implemented m a provable \nand stable way, each of them should have a mmlmal Support Moreover, It is reasonable to require that \nthe Implementation of these Dohcles should not increase the size of the Support of the law of conservation \nof money. Unfortunately, as we shall see below, these requirements cannot be satisfied under the Ada \nlanguage. Suppose that the policy PoPen is to be Implemented in a module OpenAcc, m such a way that \nIts Support consists of the pair of packages. OpenAcc and Accountmg28 What Note that any Support of P \nmust include the package open Accmmtmg2, m wh!ch the operator Open Itself IS defined should be the relatlonsh!p \nbetween these two packages? Since we do not want to increase the size of the Support of our law of conservation, \nIt IS clear that OpenAcc cannot be nested mslde Accounung2 The problem is that It cannot be disjoint \nof Accountmg2 either Indeed, for PoPen to be supported as specified above, the package OpenAcc must have \nthe excluswe aixhty to use the Open operator Unfortunately, however, Open IS made vmble to the entire \nsystem, or more precisely, to the entire scope of the Accountmg2 package It can, therefore, be used anywhere \nwithin thts scope, m a way which could be mconslstent with the gwen pohcy, whtch means that the Support \nof POPen must include the entire scope of Accounting It follows, then, that the only solutlon to our \nproblem IS to have Accountmg2 nested wlthm the package OpenAcc. The latter package could then make wsible \neverything made visible by Accountmg2, except for the procedure Open itseif In the same vein, the policy \nPclo$e can be localized in a package CloseAcc which encloses OpenAcc, and does not allow the procedure \nClose to be visible anywhere else, as IS Illustrated m Figure 2-2 (The symbols in this diagram name the \nresou rces wh!ch are vwible in tha enclosing environment.) cloxe II /J  Ir IhArce Mote CA.. @wII t \nlltT ib..lwxAM.?close cy /4 CC* % H -II I C!ONACC Figure z-2: Nested Iocahzatlon of three related properties \nUnfortunateIv, this solutlon Is not satisfactory either The problem now is that the Support of the PClo~e \npolicy !s unnecesaardy large, since !t includes the package OpenAcc which IS free to Invoke the Close \nprocedure That IS to say, the piece of code designed to deal wtth the opening of accounts IS able to \nclose accounts as well. This clearly . violates our prmclple of mmlmal Support, which suggests that we \nshould be able to support the PCIO~, pohcy by means of e module which does not include any unrelated \ncode or data structures The underlying reason for this awkward and clearly unsatisfactory Iocahzatlon \nm Ada IS the following Resources which are made visible by an Ada package are vmde to the entu e scope \nof the package, whereas, as clearly suggested by our examples, effectwe localization implles that some \nresources should be provided only to speclflc parts of the system It should be pointed out that thcs \nhm!tatlon of the Iocahzatlon capabdlty of the Ada language E shared by other modern languages, such as \nSlmula and CLU, which support package-hke constructs and data abstraction In the following section we \nwill Introduce an approach for the removal of these, and some additional Iimltatlons of these languages, \nand we wItl discuss some of the Implications of the resulting Iocahzatlon capability. 3. LOCALIZATION \nBY MEANS OF PROTECTION TECHNIQUES We have seen that our abillty to m!mmize the Support of several interrelated \nproperties of a system, depends on the nature of the power structure which can be Imposed on the system \nby the programming language m which it is wr!tten That IS to say, on the way that power can be distributed \nthroughout such a system, In most conventional programming languages such dlstrlbutlon of power E effected \npnmardy by means of name scop;ng, which creates essentially hierarchical power structures, even m a language \nhke Ada, Unfortunately, as has been argued m section 26, hierarchical power structures are too restnctwe \nfor our purposes Because of this, and other hmltatlons of scope rules wh!ch WN be dwcussed later, we \nWIII employ m this paper a different, and more general, approach to the d!strlbutlon and localization \nof power m a computer system Broadly speaking, our approach E based on the theory of ,oro?ec?ion (see \n[3, 25] for example) Protection can be wewed, m our context, as a dlsclplme under which the power of \na module to operate on the rest of the system IS determmed by the set of prlwleges which [t possesses, \nrather than by its placement relatwe to the system A pnwiege w, essentially, an expllclt permission for \none module to use resources, such as procedures, types and data objects, defined by another ProtectIon \ntechniques have been used quite successfully for the construction of operating systems, but m spite of \nseveral attempts [20, 6], they have not been systematically applled to general purpose programming languages, \nand thus had Iktle mlpact on software engineering m general Our approach E based specrflcallyg on the \nOperation-Control scheme for protection, proposed by the author [14, 15, 19] g No prior fam!llarlty with \nthis scheme, or with protection In general, IS assumed Although this approach can be applleci to a number \nof exlstmg languages, we will, for speclflclty, present It as a varlat!on of the Ada language, referring \nto the resulting language simply as L It should be pointed out that there are some alternate approaches \nto the d!stnbution and Iocallzat!on of power m large scale systems, based mostly on the concept of Module \ninterconnection language [51 We wtll compare these approaches to ours, later on m the paper 3.1. The \nPower-Structure of an L System language L, to be mtrodlc;Y3te;er~ cX% lev% as a collection of modu/es, \neach of which IS a pair <f rame, body> The body of a module E structurally identtcal to the body of an \nAda-package, whale the frame E somewhat analogous to the package-speclflcatton m Ada Each frame E a triple \n<name, profi le, interface>. The profi/e has no counterpart in Ada R IS a set of attributes which serve \nto characterize the various modules of a system, and to relate them to each other These attributes, Just \nlike the name of the module, are not to be accessible to the run-hme computmg processes They WIII be \nused, as we shall see below, for dlstrlbutlon of prwdeges throughout the system The structure of the \nprofile may differ from system to system It might, for example, consist of two attributes class and builder, \nwhere c/ass serves to partition the modules of the system according to certain functional considerations, \nand bu//der names the person who is responsible for thm module The /nterface of a module E analogous \nto, but far more general than, the specification of the vlslble part of a package Its mam function IS \nto dwtnbute prwlleges for resources, such as operators (1.e procedures), types and varlable$i which have \nbeen defined Irwde the body of the module This IS done by means of what we call export statements, which \nhave the following form 10 Th(s language IS introduced here as a means for discussing our Iocallzatlon \ntechnique, and should not be v!ewed as a complete de flntt(on of any speclf)c language Two speclflc uerwons \nof th(s language, which are based on Ada and on COe OL, WIII be descr! bed In forthcoming papers 11 It \nwould be useful, although oat strmtlv necessary for Ih)s paper, 10 assume thai butlder IS a prImtt Ive \ncomponent of the profile of modules, and that L systems are being developed under an enwronment which \nallows only the person named as the butlder of a module to wr!te a~d update Its Interface and Its body \nMore WIII be said later about such a programming enwronmen: 12 Later we WIII ZIIOW also for other k(nds \nof mtvlleges to be exported by a module export pl, . . ..pk to t. Briefly, this statement exports the \nprivileges pl,...,pk for resources, which we assume, for now, to be defined in the body of the module, \nto the target-modules characterized by t. The target-field t, of an export statement, could be one of \nthe following. 1. a list M1,...,Mk of module-names 2 a specification {ml Q(m)] of the set of modules \nwhich satisfy the condition Q(m), defined over the profile of the modules in the system. 3. the phrase \nALL, which means all the modules of the system.  or a reasonable combination of the above. For example, \nthe export statement export p to M, {m I builder(m) = Jones } would export the privilege p to the module \nM and to all modules built by Jones. Note that this statement has a declarative semantics , in the sense \nthat every module built by Jones which will ever exist in the system would get the privilege p. A privilege \nis essentially a permission to use a certain resource in a certain way. We will have several types of \nsuch privileges, depending on the kinds of resources whose use they authorize. The most important of \nthese are the activators, which authorize the use (i. e. activation) of operators, Specifically, an activator, \nwhich has the following form. can O(al:Tl, . . ..an.Tn ; TO) if Q(al, . . ..an) authorizes the application \nof an operator O, to arguments al,...,an of the specified types, provided that the condition Q(al,...,aJ~w \nhichch we call the qualifier, is satisfied. (The phrase , TO is used only when O is a function procedure, \nin which case this activator also authorizes the caller to receive the value (or outcome) of type T ~, \nof the function 0 3.) For example a module which received the activator can flove(d: lnt,al,a2:Acc) if \ndSBalance(al), by means of an export statement, would be allowed to move money from one account to another, \nbut not more than the current balance of the account being debited. 13 Note that the walif[er O !s not \ndefined over th(! outcome of an operator. Th!s is because Q IS essentially a pre-condition, wh!ch m evaluated \nbefore the operator IS called. In prmclple, It IS pos$!ble to further qualify an activator by means of \na post-conditmn, but this will not be done m this paper. In general, different modules may receive in \nthis way different activators for a given operator O, which represent different privileges for this operator \nOne can define a partial order on the set of all such O-activators (short for activators for the operator \nO), as follows An O-activator Al is considered weaker than another O-activator A2, if the qualifier Q1 \nof Al is a tighter condition than the qualifier Q2 of A2. For example, the above Move\u00adactivator is weaker \nthan the following one can Move (d:lnt, al, a2:Acc) which imposes no conditions on the arguments of \nMove, beyond the condition imposed by the operator Move itself. The latter is, in fact, the strongest \npossible activator for the Move operator, and will be called the primary Move activator. (For more details \nabout the partial order between privileges, and its significance, see [15].) In addition to activators, \nwe will have privileges which authorize the use of types, variables and such. In particular, the privilege \ncan use type T/q permits the use of type T, subject to the restriction imposed by the optional qualifier \nq, In this paper, we will admit only two values for the qualifier: It can be either null, which means \nthat the unrestricted use of the type T is being authorized; or it can be the symbol blackbox which means \nthat instances of the type T, which we call T\u00adobjects, are to be used essentially as black boxes (or, \nas what is often called abstract objects ). That is to say direct update or examination of such objects \nis not being authorized. Moreover, the instantiation of the type T, i.e. creation of new T-objects, is \nnot allowed in this case 4. Additional qualification on the authorization for types could be useful, \nbut will not be discussed in this paper. Also, we will not discuss here privileges which authorize the \nuse of specific variables. Before completing the definition of the export\u00adstatement, let us illustrate \nits use by means of an example Consider the following module, whose body is assumed to be identical to \nthe body of the package Accounting of section 2.4. The interface of this module, which contains 5 export-statements, \nis designed to illustrate several aspects of the proposed facility. 14 Th!s IS a stronger restriction \non the use of a type than the one prowded by the prwate Ilmlted qual!flcat!on (n Ada. 305 Module Accountings \nis Profile is class= financial , builder= SysMgr ; Interface is export can uaa tvpe Acc access Account \n/blackbox; can Balance(a:Acc ; Integer) ; to ALL; export can ttove(d:lnteger, al,a2:Acc) to {m I class(m)= \nfinancial 1 ; export can close (a: Acc) to Close Acc; export can Open (acc-type:Symbol, . . ..Acc) if \nace-type = sav n9\u00b0 to OpenSaving; export can Open (acc-type:Symbol ,.. .;Acc) if ace-type = check n9\u00b0 \nto OpenChecking; body is ... end; The first exDort statement ex~orts the riaht to use the type Acc as \nan abstract (or biackbox) type: as well as an activator for the operator Balance, to A// the modules \nin the system. The effect of ttis particular statement is similar to making things visible in an Ada \npackage. The second statement exports a Move-activator, but only to modules which are classified, by \ntheir profile, as financial modules . This means that no other kind of module would ever be able to invoke \nthe Move operator directly. The third export-statement exports the Close\u00adactivator to the module CloseAcc \nonly, thus localizing the power to close accounts in this module, Finally, two qua/ified Open-activators \nare being exported to the modules OpenChecking and OpenSaving, This would localize the power to open \nnew checking-accounts in tha first module, and new saving-accounts m the second. Figure 3-1 depicts the \nresulting power-structure of the system at hand. (The symbols inside the ovals in this figure, represent \nthe privileges being exported as indicated by the arrows.) Note that the interface of our modules differs \nfrom the specification part of Ada packages in two important weys. 1. Instead of broadcasting resources \nto its entire scope, as it is done by the package in Ada, our module can provide the power to use such \nresources to selected modules, or to classes of modules identified by their profile. 2. What is being \nexported are not names of resources, but privileges for them, which may provide different regions of \nthe system with different powers with respect to a single resource Although such selective export of \nprivileges does provide Figure 3-1: An example of the power structure of an L system us with powerful \nmeans for distribution and localization of power, the reader may object to it on the following grounds: \nIt can be argued that in the context of a large scale system, the programmer of a single module may not \nbe in the position to decide which parts of the system need, and should be allowed to use, which of the \nresources created by this module. It may seem far better to use the following mechanism for the distribution \nof privileges: Firstr each module would broadcast a set of privileges to the entire system, in analogy \nto making things visib/e in Ada, However, for a privilege p, thus exported by module M, to be available \nto another module M, the latter module mast alao have the following statement in its frame import p from \nM Indeed, such import statements are being used in several module-i nterconnection-languages , although \nin a somewhat weaker form than the above, as we will see in section 34. Unfortunately, however, this \nmechanism does not quite satisfy our requirements, as we will see next Consider a property P which can \nbe violated by any module which has the power to invoke an operator Q. The question is: what could be \nthe Support of P? First, note that Support(P) must include the bodies of all modules which import the \nright to use the operator Q. But in order to identify these modules one must examine the frames of all \nthe modules in the system, which means that Support(P) must include all the frames in the system. This \nis quite a large Support, but it may be considered manageable since it may contain only a few bodies. \nUnfortunately, the situation is much worse than that. Strictly speaking, even the entire system, at a \ngiven Module Accounting is moment in time, cannot be considered to be the Support of P; because there \nis nothing to prevent a new module, which imports the operator Q, to be added to the system. Such a module \nwould be able to violate the property P, contrary to our definition of the concept of Support. This means \nthat P can have no definite Support. We can conclude, therefore, that if we wish to facilitate Iocahzation, \nm the sense of this paper, then the distribution of privileges must be effected primarily by means of \nexport rathe[ than by import statements. 5 This brings us back to the above mentioned difficulties with \nour distribution mechanism. We propose to alleviate these difficulties by providing, what we call, redistribution \ncapability, which would allow one module M to grant some privileges to another module M , allowing M \n, or, in fact, its builder, to redistribute these privileges as he sees fit. Such a capability is introduced \nnext. 3.1.1. Redistribution of Privileges We now extend our concept of privilege as follows a privilege \np that resides in a module M can be in either a portab/e or an unportab/e state, p is portable m M if \nit originates in this module (i.e. it is a privilege for a resource defined by the body of the module) \nor if it had been exported into it in a portable state. Now, if a privilege p is portable in M then M \ncan export p, or a weaker version of p, 16 in either portable or unportable state. Syntactically, p is \nexported in a portable state if It is prefaced by an * in the export statement. Suppose, for example \ntttat a module M has the following statement in its interface export PI, *p2, p3 to Ml This statement \nattempts to export the three privileges PI, p2, p3 to Ml, which would be valid only if M has all these \nprivileges in a portable state. The * which precedes p2 in this statement means that p2 is being exported \nto Ml in a portable state. Thus, Ml would be able to reexport p2 to other modules, while it will not \nbe able to reexport PI and p3 To illustrate the use of this capability, suppose that the system manager, \nor SysMgr, wishes to delegate to somebody else, say the accounting-manager, or AccMgr. the decision as \nto which part of the system should be involved with the opening and closing of various accounts, and \nwhich part should be allowed to use the GetAcc operator. Conse quently, he wrote the following version \nof the Accounting module 15 II should be pointed out that there are strong methodological reasons for \nthe use of import-statements in conjunction w)th our export-statements. Both kinds of statements are, \nm fact, included m the full fledged vers[on of our language, But the tmport statements are Ignored here \nfor slmpllc!ty. 16 This is consistent with what IS called the prmclple of attenuation [4. 161. prOfile \niS Class= financial , builder= Syst tgrr ; Interface is export type Acc access Account/blackbox; can \nBalance(a:Acc ; Integer) ; to ALL; export can Move (d:lnteger, al,a2:Acc) to {m I class(m)= financial \n) ; export $:can Close (a: Acc) *can Open (acc-type:Symbol, . . ..Acc) : to AccSwitch: body is ... end; \nThe first two export statements of Accounting are repeated hers, but the other four are replaced by a \nstatement which exports activators for the operators Open and Close, in a portable state, to a module \ncalled AccSwitch (for Accounting Switch) being built by AccMgr. This module could, in particular, be \nas follows Module AccSwitch ia Profile is class= f inancial , builder= AccMgr ; Interface is export \ncan Close(a:Acc) to CloseAcc; export can Open (acc-type:Symbol, . ..;Acc) if type = saving to OpenSaving; \nexport can Open (acc-type:Symbol, . ..; Ace) if type = ~lcheck ingll to OpenChecking; end; resulting \nin a similar power structure to the one we had before. (Note that such a module might have no body.) \nIt should be pointed out that the proposed technique can be practical only if it is used in the context \nof an appropriate programming environment . Such an environment should, in particular, maintain a database \nwhich represents the power-structure of the system, and it should facilitate the transport of privileges \nbetween its various modules. One design for such an environment, which also helps to control the evolution \nof the system, will be described in a forthcoming paper. 3.2. Methodological Comments One of the merits \nof the proposed technique for imposing a power structure on a system is that this technique supports \na wide range of policies of system design This range can be delimited by its two extreme cases, which \nwe call decentralized and cerrtra/ized policies Under the decentralized policy every module exports non \ntransportable privileges, for resources defined in it, directly to other modules in the system. This \nmeans that the builder of every module decides which part of the system is to be able to use which of \nits resources. Under the centralized policy every program module exports all its privileges, in a portable \nmode, to a single module, called SystemSwitch say, thus delegating to the builder of this module the \ntask of distributing these privileges among the various modules of the system, Neither of these extreme \npolicies is very good The problem with the decentralized policy has already been pointed out: it assumes \nthat the builder of every module has the knowledge and authority to decide which part of the system should \nbe able to get which of its privileges, which is clearly an unwarranted assumption. The fully centralized \npolicy, on the other hand, suffers from all the drawbacks of over centralization. The person, or persons, \nwho control the content of the SystemSwitch module must be familiar with the structure of the entire \nsystem, and must be involved directly in most changes to it, Moreover, such a person possesses enormous \npower with respect to the system, which one may not be willing to grant to anybody. Finally, it is easy \nto see that the SystemSwitch module, which is likely to be quite large, would belong to the Support of \nevery property whose implementation spans more than one module, rendering these properties less provable \nand more unstable. Fortunately our mechanism for distribution of privileges allows one to combine centralization \nand decentralization in the same system, and in a variety of ways, For example, one may have several \nSwitch\u00admodules , each of which would be responsible for the distribution of a certain type of privileges. \nFor example, in a financial system one may have one such Switch for the distribution of accounting-related \nprivileges, another Switch for privileges which allow auditing, a third one for user interface, etc. \nMoreover, in the same system, some modules might exchange privileges by means of direct export, as in \nthe uncentralized case. It should, therefore, be possible to accommodate a wide variety of system design \nmethodologies and policies.  3.3. A Note About Implementation Ideally, the L-language described in this \npaper should be supported by a compiler. In the absence of such a compiler, however, we are currently \nplanning an implementation of this language by means of a precompiled which has been designed to generate \nan Ada program from a set of L modules. A similar technique can be used to implement a COBOL based L \n1anguage. The details of these precompilers are beyond the scope of this paper.  3.4. A Note About Related \nWork The need for sophisticated techniques for specification of interfaces between the modules of a large \nscale system, has been recognized by several authors; starting with the seminal paper entitled Programming-in\u00adthe \nlarge VS. Programming in the small by DeRemer and Kron [5], which introduced the concept of Module interconnection \nLanguage. Several such languagea have been designed and implemented, such as MESA [8], PROTEL [7], ADAPT \n[9] and INTERCOL [26]. We will use here the latter one as a representative of this body of work. INTERCOL \nis a Module Interconnection Language designed by Tichy in the context of the Gandolf project in CMU. \nIt is a declarative language which, among other things i 7, specifies which modules of a system can use \nwhich resources defined by other modules. This E done by means of two kinds of statements. First, there \nis a provide statement exemplified by the statement module A provide rl, r2, r3 which essentially broadcasts \nthe resources rl, r2 and r3, just like the specification part of an Ada package. However, for a module \nB to be able to use one of these resources, say rl, the INTERCOL program must contain the following require \nstatement module B require . ..rl . . . which specifies which resourses defined by other modules can \nbe used in module B. Although this mechanism allows for the formation of quite sophisticated power structures, \nit suffers from several serious weaknesses. First, note that INTERCOL accomplishes selective distribution \nof privileges by means of the require statement rather than by the provide statement. Since the former \nis analogous to the import-statement mentioned before, it follows from our previous discussion that /NTERCOL \ndoes not permit localization of properties, in the strict sense of this term. Secondly, INTERCOL allowa \nmainly for the distribution of names of resources rather than of privileges for them. Although INTERCOL \ncan provide a module with a read-only access to a given resource, it has nothing approaching the concept \nof an activator which allows us to provide different modules with different power with respect to a single \noperator. Thirdly, INTERCOL lacks our concept of the profi/e of modules, whose use for the distribution \nof privileges can greatly simplify the formation of complex power structures. Finally, the lack of redistribution \ncapability m INTERCOL means, in effect, that it can support only the extreme centralized or decentralized \nsystem design-policies discussed in section 3.2. 4. IMPLICATIONS AND APPLICATIONS In this section we \nwill discuss briefly a few of the 17 INTERCOL also prowdes Version control. which IS Irrelevant to this \npaper most important implications of the proposed localization technique to various issues of software \nengineering such as data-abstraction, reasoning, control, and the evolution of large scale systems 4.1. \nNew Perspective on Data-Abstraction and on the Principles of Hiding The importance of being able to deal \nwith an abstraction of any given component of a system, ruther than having to be aware of all its details, \nis universally appreciated. This is the reason for the justified popularity of the various linguistic \nconstructs, such as the package of Ada and the c/uster of CLU, whose main purpose is the support of what \nis known as data-abstraction . Unfortunately, an Ada package is capable of presenting a single abstraction \nfor any given type created in it; abstraction which is effectively defined by the set of operators applicable \nto this type that are made visible to the outside. The problem is that one often needs different abstractions \nof the same type of entities for different purposes, and therefore, in different parts of a system. A \ncase in point is the well recognized need to present dif f erant users of a database with different views \n, or abstractions, of it. The failure of conventional techniques for data abstraction to support multitude \nof abstractions is, therefore, what limits the applicability of these techniques to database management. \nFortunately, multitude of abstractions, for the same data type, can be formed using our more flexible \nexport mechanism, by presenting different parts of the system with different sets of oparators for the \nsame type. ( Another serious limitation of conventional implementations of data-abstraction has to do \nwith what we call interactions betwaen different abstract types , which will be discussed elseware) The \nParnas principle of hiding, which is closely related to the notion of abstraction, states that a module \nshould hide all of its details which are irrelevant to the outside. But why should the same details be \nhidden from al I parts of the system? As have bean shown in this paper, different parts of the system \nmay, in fact, need to be aware of different details of a module. Or, in our terminology, different parts \nof the system may need to have different privileges with respect to the module. Thus, the question which \nshould concern the designer of a module is not just which privilege to hide, and which to export to the \nrest of the system. The question should be 18: which privilege to hide from whom , Moreover, our principle \nof minimal support provides us with some criteria for what is a good answer to this question. Note however \nthat the resmmsibiiw m answe! this westjon can be delegated by the module-deslsmer to somebody else, \nas has been explained in sections 3. 1.1 and 3.2 4.2. Control by Starvation It is well known that physical \nsystems are sometime easier to deal with than computer software systems, even if the former are more \ncomplex than the latter, Part of the reason for that is the abikty of one part of a physical system to \nactually control the behavior of another of its parts. In particular, we will be interested here in what \nwe call control by starvation , which can be characterized as follows Consider a subsystem dS of a system \nS. Suppose that dS is involved in a process P for which it needs a certain amount of resource R, which \nit consumes but is unable to generate by itself. In this case it is possible to control the ability of \ndS to engage in this process, simply by controlling the amount of the resource R being supplied to it. \n For example, it is possible to put out a fire by stopping the supply of oxygen, given that the subsystem \non fire is not able to generate the oxygen by itself, Note that this control capability is based on the \nlimited power of dS. Such a control should therefore be supportable by our L-language, as is illustrated \nby the following example Consider a module M which defines a type R, and two operators MakeR and P. The \noperator MakeR is designed to create new R-objects. The oparator P(r), on the other hand, consumes the \nobject r of type R supplied to it as an argument; either by destroying it, or by changing its state in \nsuch way that it will refuse to operate on it again. One can also assume that P carries out some sensitive \noperation, whose identity is irrelevant for us here. As is evident from the following frame of M, Module \nII is Profile ia. . . Interface is export can uae type R/b I ackbox to ALL; export can MakeR(. ..; R) \nto I ll; export can P(r; R) ; to M2: Body is. .. end N module; the type R is exported to the entira \nsystem in a blackbox mode; which mean s that outside of the module M it is impossible to access the internals \nof R-objects, or to create new objects of this type. This means, in particular, that the operator MakeR \nis the only means for the generation of R-objects, available outside of the module M. Since an activator \nfor this operator is being exported only to module Ml, it follows that Ml is the only module in the system, \nwith the exception of M itself, which is able to create R objects. Finally, note that the operator P \nis being exported to another module M2. Now since the operator P expects an R-object as its argument, \nand since M2 itself is unable to create such objects, it follows that iM2 cannot invoke the operator \nP unless it gets an R object from the outside. This, together with the fact that Ml is the only subject \nin the system which is able to create R objects, means that V17 has control over the invocation of P \nby rW2 Specifically, IM2 can invoke P only on the R object given to it by Ml, and only once for every \nsuch object, (see Figure 4 1 for illustration.) Figure 4-1: Ml can control the ability of M2 to Invoke \nthe operator P by controlhng the supply of R-objects. Note that this control, which Ml has over M2, is \nsupported completely by module M, and is, in particular, quite independent of the bodies of Ml and M2 \nthemselves. It should be pointed out, however, that this type of control is limited in two ways First, \nM 1 has no control over actions of M2 which do not involve the op&#38;ator P. Secondly, M 1 cannot force \nM2 to do anything It can only limit M2 s ability to invoke the operator P, by not providing it with R \nobjects, which is why we call it control by starvation . 4.3. Reasoning about Large Scale Systems Throughout \nthis paper we have been arguing that localization of power facilitates reasoning in the following sense: \nIf a system S has been designed in such a way that a property P is localized in a region R of S, then \nR is the only part of the system which has to be analyzed in order to verify P. However, the effect of \nlocalization on our ability to reason about a system may go far beyond the verifiability of several properties, \nwhich had been Specifically designed to be supported by a small region. Consider, for example, our law \nof conservation of money . Once this property has been verified, by studying the body of the modules \nAccounting, it can be treated as a /aw of the system, in some analogy to the law of conservation of energy \nin the physical world. We are usin9 this analogy advisedly just as the law of conservation of energy \ngreatly facilitates reasoning about physical systems, our law of conservation of money should facilitate \nreasoning about our financial system The point of this example is that general reasoning about a system \ncan be greatly simplified if some well chosen properties are implemented in provable and stable ways. \n(It is to be admitted, in this context, that the law of conservation of money discussed in this paper \nis too simplistic to be of much help in a real accounting system. A more realistic law is discussed in \n[181, together with more detailed discussion of reasoning about financial systems and about auditing \nthem.) There is another mode of reasoning enabled by Iocakzation of power< which we will call black-box \nreasoning. Conventional reasoning about programs requires the complete knowledge of the program being \nreasoned about. However, given some knowledge about the power of a certain module, we can make certain \nstatements about its behavior without knowing anything about its body. An example of such black-box reasoning \nis provided by our example in Section 4.2 which allowed us to make statements about the invocation of \nthe operator P by module M2, which were independent of the actual code in M2. 4.4. Locality in interactive \nand Evolving Systems Finaly, the proposed technique for imposing a power\u00adstructure on a system, provides \nus with a means for dealing with some of the problems involved in the management of interactive and/or \nevolving systems. The difficulty with such systems is that they cannot be viewed merely as collections \nof program modules. Any analysis of the dynamic behavior of such a system must take into account the \neffect that the users, or even the builders, of the system might have on it. Let us take up the case \nof an interactive system first. Consider, for example, an information system which IS written in an interactive \nlanguage. The users of such a system would be capable of operating on it, i.e. updating its data base, \nsimply by using commands in the language at hand. If we are to localize a certain property P in some \nmodule M, we must make sure not only that other modules cannot violate P, but that none of the users \ncan do It either. This clearly requires that the users of a system should be subject to the same kind \nof discipline which we imposed on its modules, which can be done by a natural extension of our L language, \nas follows Let us introduce the concept of a subject, which is to cover the modules as well as the users \nof a system, A subject is defined to be a pair <frame, actor>. The frame is identical to the frame of \na module, while the actor can be viewed, in general, as a generator of instructions. In particular, the \nactor of a module IS simply its body, i.e., a Pro9ram text which would generate a sequence of instructions \nwhenever executed. In the case of a user, on the other hand, the actor ts a person who issues the instructions. \nBoth kinds of actors would be subject to the fundamental discipline of our language: which is that an \nactor can do only what it is allowed to do, by means of the privileges available to it. (Thus, a user \ncan be viewed as a module whose body is unknown) Our concept of power IS particularly apt in this context. \nWe can talk about the power of a user just as we did about the power of a module, because, even in the \nlatter case , power is an abstraction which is independent of the body. Using localization of power we \ncan, for example, control some of the activities of a user, and reason about his possible effect on the \nsystem, just as we were able to do so with modules, without having any knowledge of their bodies Moreover, \neverything which has been said previously about Iocahzation of properties of a system is still valid, \neven if the actions of people are taken into account. In our Accounting example, in particular, the PClo~e \npolicy is still localized in the module CloseAcc, because, as is evident from the interface of the Accounting \nmodule, no other subject in the system, including users, has the power to use the Close operator. Moreover, \nCloseAcc itself may be the frame of a user, rather than of e module. In this case, the person who operates \nfrom this frame would have the exclusive power to invoke the Close operator, and would, therefore, be \nthe one who determines, or supports , the P policy. Such localization is useful, even though in tt%%ase \nthere is no formal way for us to figure out what this policy really is. We can, at least, place the responsibility \nfor the closing of accounts on the shoulders of specific individuals lg. If we wish to extend our treatment \nto evo/ving systems, it would be necessary for the system to be developed within a programming environment \nwhich subjects the bui/ders of the system to the same kind of discipline imposed on the users of the \nsystem and on its own modules. Under such an environment a builder can be viewed as a user who is given \nthe power to add modules to the system, change existing modules, or delete them. Moreover, each builder \nmight be allowed tcl create and manipulate only modules of a specified profile. As a simple case of such \na discipline, one may have a rule which states that a builder B can change only modules which have B \nas the value of the builder attribute of their profile In our accounting example this would mean that \nonly SysMgr is able to change the Accounting module This, in turn, means that the Support of the law \nof conservation of money, in the evolutionary sense of this term, consists of two subjects the module \nAccounting, and its builder SysMgr. It should be pointed out, however, that the control over the evolutionary \nprocess of a system is considerably more involved than what may be implied from the above comments. The \ndetailed discussion of such a control is beyond the scope of this paper. 5. SUMMARY AND CONCLUSIONS \nThis paper is based on the assertion that for a property P of a large scale system S to be provab/e \nand stable it is necessary for P to be localized in, or supported by, a small region of S. Indeed, such \nlocalization is the basis for several well known techniques and principles of software engineering, such \nas modularization, abstraction and the hiding principle However, as has been shown m section 2, current \nprogramming languages, such as Ada, provide only limited support for localization, which is not sufficient \nfrom the viewpoint of our principle of minimal support . In an attempt to provide for a stronger localization \ncapability, we have proposed in this paper a technique for distribution of power among the various modules \nof a system, which replaces the standard scope-rules of programming languages with explicit distribution \nof privileges . This technique appears to be beneficial for software engineering in several ways. In \nparticular It facilitates reasoning about large scale systems.  It contributes to the robustness and \nstability of systems.  It allows us to present different parts of a system with different abstractions \nof the same type of objects.  It allows US to provide one part of a system with the ability to control \nthe activity of another part (which is what we called control by starvation).  It should be pointed \nout, however, that the localization technique described in this paper ia really a simplification of 8 \ntechnique designed to be used in the context of a system development environment . This, more general, \ntechnique and it affect on the evolution of large scale systems will be discussed in a forthcoming paper. \nAcknowledgments I wish to express my gratitude to Laszlo Belady, Alex Borgida, Burt Leavenworth, Abe \nLockman, Yair Minsky and Irv Rabinowitz for reading previous versions of this paper and for their many \nuseful comments. We .re assuming the ex,.tence of a mechan, sm vvh, ch allows only certain mdivlduals \nto operate from a gwen user frame. [1] [21 [31 [4] [51 [6] [7] [8] [91 [101 [11] [12] [131 References \nBelady, L A Modlflabdny In Proc. of Operating 1980 the of Large 14-th Systems., Software Computer pages \nSystems, Scence 170184. Sympos. June, on Birtwistle, G, DECsystem-70 Endenn, Simula L, Ohlm, Language \nM and Palme, J Handbook Part 1 Technical Report C8398, Swedish National Defense Research Institute, \nMarch, 1976 Dennmg, P.J and Graham, G S ProtectIon Principles and Practice in AFIPS 7972 Spring Joint \nComputer Con f., pages 417-429 AFIPS, 1972 Denning, P. J. Fault tolerant operating systems Comput. Surv. \n8(4)359-389, Dec., 1976 DeRemer, Frank and Kron, Hans H Programming m-the-Large vs Programmmg-in-the-Small \nIEEE Transactions on Software Engineering SE-2, 2 :80-86, June, 1976 Jones, A K and Llskov, B. H A language \nextension mechamsm for controlling access to shared data In Proceedings of the 2nd Int. Conf. Software \nEngineering, pages 62-68 1976. Lasker, D M Module Structure in an Evolving Famdy of Real Time Systems \nIn Proceedings of the 4th Int. Conf. on Software Engineering, pages 22 28. IEEE, September, 1979. Lauer, \nH C and Satterthwaite E H The Impact of Mesa on System DEslgn In $th I Nternational Conference on Software \nEngineering, pages 174182 IEEE, September, 1979 Leavenworth B ADApT Reference Manual ? 19 , IBM, August, \n1979 Ledgard H ADA An Introduction and Reference Manual. Sprmger-Verlag, 1980 Linden, T A The Use of \nAbstract Data Types to Simplify Program Modifications Llskov, B The Design of the Venus Operating System \nLlskov, B., Snyder A, Atkinson R and Scaffert C AbstractIon Mechanism m CLU Comm. of the ACM 20(8), August, \n1977 [141 Minsky, N H Intentional Resolution of Prwacy Protection Database Systems Communication of \nthe ACM 19(3) 148:159, 1976 m March, [151 Minsky, N H. An operatton control scheme for authorization \ncomputer systems I nt, J. of Computer and Information Sci. , 1978 m June, [16] Minsky, N H The Principle \nof Attenuation of Prwileges and Ramifications In Demillo, Dobkin, Jones and Lipton (edtor), Foundations \nof Secure Computation, pages 255 278 Academic Press, 1978 Its [17] Minsky, N H SynergMc Authorization \nIn Seventh International Data Bases, IEEE 1981 in Database Systems Conference on Very Large Computer \nSociety, September, [18] Minsky, N H Localization of Technical Report September, Power in Software Systems \nLCSR-TR-29, Rutgers Umverslty, 1982 [19] Minsky, N H Locally Controlled ACM Transactions Systems , to \nTransport of Pnviieges on Programming Languages be pubhshed, 1983 and [20] Morns, J Protection Comm. \nof H in Programming Languages. the ACM 16(1)15:21, January, 1973, [21] Parnas, D L A Technique for Module \nSpecification Examples, Comm of the ACM 15(5), May, 1972 with [22] Parnas, D L On the Criteria to be \nused m Decomposmg Systems mto Modules Comm, of the ACM 15( 12),DEcember, 1972 [23] Parnas, Use of of \nD L and Slewlorek, D L the Concept of Transparency m Hierarchically Structured Systems the Design [24] \nRoss, D Software Computer T, Goodenough J B Engineering Process, , MAY, 1975, and Irvine prmclples C \nA and Goals [25] Saltzer, J H. and The ProtectIon of Schroeder, mnformatlon M D m computer systems Proc \nIEEE 63(9) 1278 1308, Sept. 1975 [26] Tlchy, W F Software Development InterconnectIon Based on Module \nIn 4th Int 29 4 Conf on Software 1 IEEE, September, Engineering, 1979 pages 312   \n\t\t\t", "proc_id": "567067", "abstract": "This paper proposes a technique for what we call <i>localization of power</i> in computer systems, which can be viewed as a generalization of such linguistic disciplines as <i>scope rules, strong typing</i> and <i>data-abstraction.</i> Although the proposed technique is conceptually based on the theory of protection, it is presented as a rather simple extension of the <i>package</i> construct of the Ada language. This technique is expected to be beneficial for software engineering in several ways. In particular:&#8226; It facilitates reasoning about large scale systems, by allowing one to ignore most of the details of the system when reasoning about specific aspects of it.&#8226; It provides us with a generalization of the conventional concept of data-abstraction, by allowing the formation of several different abstractions for the same type of objects, and by supporting \"interactions\" between the abstractions of different types.&#8226; It allows us to provide parts of a system with a certain ability to <i>control</i> the activity of the rest of it.&#8226; It supports a broad spectrum of policies for the design and management of large scale, evolving systems.", "authors": [{"name": "Naftaly H. Minsky", "author_profile_id": "81100125160", "affiliation": "Rutgers University, New Brunswick NJ", "person_id": "P206589", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/567067.567095", "year": "1983", "article_id": "567095", "conference": "POPL", "title": "Locality in software systems", "url": "http://dl.acm.org/citation.cfm?id=567095"}