{"article_publication_date": "01-24-1983", "fulltext": "\n Permission to make digital or hard copies of part or all of this work or personal or classroom use is \ngranted without fee provided that copies are not made or distributed for profit or commercial advantage \nand that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, \nto post on servers, or to redistribute to lists, requires prior specific permission and/or a fee. &#38;#169; \n1983 ACM 0-89791-090-7 $5.00 In this report we show an example natural language specification and dkcuss \nstrategies used in that specification. We then discuss two examples of novice programming difficulties \nstemming from an inappropriate use of natural language specification strategies. These examples are illustrated \nwith video tape transcripts. We conclude with a brief discussion of the implications of this work. 2. \nA Natural Language Specification Consider the following problem: Problem 1: Please write a set of explieit \ninstructions to help a junior clerk collect payroll information for a factory. At the end of the next \npayday, the clerk will be sitting in front of the factory doore and has permission to look at employee \npay checks. The clerk is to produce the average salary for the workers who come out of the door. This \naverage should include only those workers who come out before the first supervisor comes out, aad should \nnot include the supervisor s salary. The following natural language specification for this problem, written \nby one of our interview subjects, is typical of those found on a separate written study of this problem: \n1. Identify worker, check name on list, cheek wages 2. Write it down 3. Wait for next worker, identify \nnext, check name, and so on 4. When super comes out, stop 5. Add number of workers you ve written down \n 6. Add ail the wages 7. Divide the wages by the number of workers  Miller [1981] studied similar \ndescriptions. In that study he was looking at the psychological feasibility of programming in a natural \nlanguage. Miller concentrated on relatively low level components of the descriptions. We have focused \non how those components fit together into overall novice strategies. There are several natural language \nspecification strategies used here. Note how steps 1 through 4 specify a loop: steps 1 to 3 describe \nthe first iteration of the loop, indicating a repetition of these steps with the phrase and so on . Step \n4 adds a stopping condition, assuming that thk condkion will act as a demon . The specification also \nassumes canned procedures for counting inputs, step 5, and for summing a series of numbers, step 6. Note \nhowever, that these two procedures are both denoted with the word add . Focusing on the loop specified \nin steps 1 through 3, we describe the strategy of this loop as perform the first step, then do the rest \nin the same way . (Step 4 additionally modifies the loop by adding a exit test). Such a strategy is quite \ncommon in this sort of description. In contrast, most programming languages use a loop with the strategy \nfor each value of the variables, perform the following steps . (Again, this is often modified by the \naddkion of an exit test.) The programming language strategy is diffsrent primarily in that it specifically \ndiscusses how to vary the values through each iteration. There are two kinds of differences between this \nspecification and a program in a typical programming language. Fimt, the strategies used here are different \nfrom those used in most programming languz~ges. Below we focus on a subject who has difficulty with a \nstrategy for implementing the body of the loop. The second difference concerns ltrow many details of \nthe computation are implicit and must be filled in by human knowledge about the world. The steps of this \ndescription are at a relatively high level compared to what would be needed in a standard programming \nlanguage. 3. Examples of Novice Programming Diftlculties To show how the conflict in strategies effects \nnovice programmers, consicler a problem analogous to problem 1, but simpler and explicitly of a programming \nnature: Problem 2: Write a program which repeatedly reads integers until it reads they integer 99999. \nAfter seeing 99999, it should print out the correct average. That is, it should not count the final 99999. \n In a language like Pascal, a correct programming solution to this problem will have the loop body repesent \na middle case of the iteration. Novices are much more likely to attempt a perform the first step, then \ndo the rest in the same way strategy, even though it is inappropriate in Paecal.3 Consider the following \nnovice program fragment: repeat Sum:= O+ I N:=l SUIS:= I + :[ N:E2 untii I = 99999  Now consider the \ntranscript of the subject developing this program. He underrltands that for each iteration, the program \nwill need to increment the counter variable N and produce a new Sum by addhg in the latest valus for \nI. Here, though, he implements that by showing how the first iteration will look ( Sum := O + 1 and N \n:= 1 ) and then how to repeat ( Sum := I + I and N := 2 ). SubJect: [Writes Sum := O + 1 ] Aad then integer \n[the way the subject refers to tbe variabie I], or tbe sum equals integer, ah, equ ab zero plus integer, \n.,. The sum is going to be O pius the integer and the number is gonna be, ah, number equals 1 [writes \nN := I ], aad then , aad then Sum equais integer pius integer [writes Sum := I + 1 ] and [pause] 3The \nmost common PIscal strategy involves a loop body which looks like: Sum := Sum t, NeM; Count := Count \n+ 1; Read (Neu)  11 Interviewer: What are you thinking? Subject . Ah, Num equals 2 [writes Num := 2 \n], and it will go on, it would repeat [pokts to all the statemen~ in a sweeping motion]. If this [pOints \ntO Sum := I + I ] continnes to repeat, this [points to Nnm := 2 ] will increase. I m assuming for the \nmoment that this is sufficient input. Interviewer: OK, sufficient input ? SubJect: Input to [pausel so \nthat the computer will know that, for each [pausel for each integer entered, you add 1, you add the integer \nto the sum [points to Sum := O + 1 1, and that this is the first format of that, zero plus integer, N \nequals 1, sum equals integer plus integer, number = 2, until ,.. Even though the subject seems fairly \nconfused about how to express the program in Pascal, he has a very clear idea about the actions needed \nfor a correct solution. We have found that thk is typical --novice programmers are not totally confused \nabout what needs to be done, just about how to express that need. This confusion can occur even when \nthe novice appears to fully understand a program fragment. Consider, for example, the following novice. \nShe is writing pseudo-code for the following problem: Problem 3: Write a program which reads in 10 integers \nand prints the average of those integers. After working on the problem for a few minutes, she had written \nthe following: Repeat (1) Read a number (Num) (la) Count := Count+ 1  (2) Add the number to Sum (2a) \nSum := Sum + Num  (3) until Count := 10 (4) Average := Snm div Num (5) writ.dn ( average = , Average) \n  Leaving aside some incoosistant pseudo-code notation, this is correct, At this point, the interviewer \nasks whether the statement on line la is the same kind of statement as that on line 2a. The subject seems \nto understands the role these two lines play in the program. S-he also recognizes the need for other \nassociated statements to carry out those roles. Nonetheless, it appears that she thinks the Pavcal translator \nknows far more about thess roles than it does: Interviewer: Steps la and 2a: are those the same kinds \nof statements? Subject: How s that, are they the same kind. Ahhh, ummm, not exactly, because with this \n[la] you are adding -you initialize it at zero and you re adding one to it [points to the right side \nof la], which is just a constant kind of thing. Interviewer: Yes SubJect: [pointe to 2a] Sum, initialized \nto, uhh Sum to Sum plus Num, ahh -thats [points to left side of 2a] itoring two values in one, two v \nariablss [points to Snm and Nnm on the right side of 2a]. Thats [now points to la] a counter, thats what \nkeeps the whole lnnp under control. Whereas this thing [points to 2a], this WM probably the most interesting \nthing about Pascal when I hit it. That you could have the same, you sorts have the same thing here [points \nto la], it was interesting that you could have, you could save space by having the Sum restoring information \non the left with two different things there [points to right side of 2a]j so I didn t need to have two. \nNo, they re different to me. Interviewer: So -in summary, how do you think of la ? SubJect: I think of \nthis [point to la] as just a constant, something that keeps the loop under control. And this [poiuts \nto 2a] has something tu do with wmetbing that you are gonna, that stores more kinds of information that \nyou are going to take out of the loop with you. This interview explains a result we have from an earlier \nwritten study. We found 100% of novices working on problems like 2 and 3 were able to correctly write \nthe counter variable update statement ( Count := Count + I ), whlIe only 83% could correctly write the \nrmnuing-tatal variabIe update ( Sum := Sum + Num ) [Soloway et al, 1982a] . Why this difference with \nstatements syntactically and semantically so similar? With this transcript, we now have some insight \ninto the problem. Our subject seems to be keying on the role --the pragmatic --of the statements, noticing \nbut concentrating on the syntactic and semantic regularity. The running-total variable update is more \ndifficult because it stores information that you are going to take out of the loop with you . That is, \nit has implications outside the loop body. 4. Concluding Remarks It is not clear exaetly how to reset \nto the bugs we have uncovered in novice understanding of programming. In some cases it may be appropriate \nto design new languages or constructs. Often, better instruction would take care of the problem. The \nintent of our studies is to better understand the source of the mismatches and misconceptions that canes \nnovice bugs. Only once a bug is uncovered and understood are we ready to create a remedy for that bug. \nWe find it quite interesting that novices seem to understand the role or strategy of statements more \nclearly than the standard wmantics. Such roles dkcussed here include counter variable , running total \nvariable , running total loop , and first, then ~st loop . (See Soloway et al [1982b] for a detailed \ndiscussion of novice looping strategies.) Much work in programming languages is concerned with allowing \na programmer to more accurately express his or her intentions in the program. Perhaps we can learn something \nfrom novices here --our programming systems should support recordkg the roles the programmer intends \nfor various statements and variables. As we better understand common roles, we can even 12 expect our \nprogramming systems to provide automated support for these roles. Waters [1982] is developing a system \nwhich does attempt to capture and use role information. A number of programming languages and systems \nhaye been deveIoped for the novice. Notable examples include BASIC [Kurtz, 1981] and LOGO [Paper4, 1980]. \nEach language represents many good intuitions about how to place programming power into the hands of \nnon-experts. Our results show that it is time to move beyond intuitions --the experience and understanding \nof a novice are available for analysis. In particular, our results suggest that the knowledge people \nbring from natural language has a key effect on their early programming efforts. Our work suggests that \nwe need serious study of the knowledge novices bring to a computing system. For most computerized tasks \nthere is some model that a novice will use in hk or her first attempts. We need to understand when is \nit appropriate to appeal to this model, and, when necessary, how to move a novice to some more appropriate \nmodel. Acknowledgements We would like to thank Jeff Conklin and Bev Woolf for their helpful comments \non earlier drafts. S. References Bonar, J. [1982] Natural Problem Solving Strategies and Programming \nLanguage Constructs , appears in the Proceedings of the Fourth Annual Conference of the Cognitive Science \nSociety. August. Kurtz, T. E. [1981] BASIC , appeared in History of Programming Languagm, ed]ted by \nRichard L. Wexelblat, Academic Press, New York. Miller, L. A. [1981] Natural language programming Styles, \nstrategies, and contrasts , IBM S@em8 .Jaurnal, 202, pp. 184-215. Papert, S. [1980] Mind8torms, Children, \nComputers and Powerful Ideas, Basic Books, Inc., New York. Soloway, E., J. Bonar, P. Barth, E. Rubin, \nand B. Woolf. [1981] Programming and Cognition: Why Your Students Write Those Crazy Programs , Proceedings \nof the National Educational Computing Conference, pp. 206-219. Soloway, E., J. Bonar, J. Greenspan, K. \nEbrlich, [1982a] What Do Novices Know About Programming? , to appear in LXrectione in Human-G omputer \nInteraetiona, edited by B. Shneiderman and A. Badre, Ablex Publishing Company. Soloway, E., Bonar, J., \nEbrlich, K. [1982b] Cognitive Strategies and Looping Constructs: An Empirical Study; Communications oj \ni!he ACM, in press. Waters, R. A. [19811] A Knowledge Based Program Editor , appears in Proceedings \nof the 7th International Joint Conference on Artificial Intelligence, Voll. II, pp. 926-926. 13 \n\t\t\t", "proc_id": "567067", "abstract": "It is widely known that programming, even at a simple level, is a difficult activity to learn. Why is this so? Are novice difficulties really inherent in programming or are they related, to the nature of the programming tools currently given to novices? To answer this question we have used novice Pascal computer programs collected from their terminal sessions, controlled clinical studies focusing on specific aspects of novice programming techniques, and video-taped interviews of novice programming [Bonar, 1982]. In each we focused on bugs and buggy programs. Bugs and errors illuminate what a novice is actually thinking -- providing us a window on the difficulties as they are experienced by the novice.In previous reports we presented evidence that current programming languages do not accurately reflect the cognitive strategies used by novice programmers [Soloway et al, 1981]. Instead, we have found that novice programmers possess knowledge about and experience with step-by-step specifications in natural language. This knowledge and experience gives them powerful intuitions for using a programming language. Programming languages, however, are, not designed to appeal to these intuitions. On a semantic and pragmatic level, there are incompatibilities between the way, natural and programming languages are used. Many novice programming bugs can be directly traced to an inappropriate use of natural language specification style or strategy.As an example of these incompatibility bugs consider the \"while demon\" bug. Novices with this bug assume that the actions in the body of the while loop are continuously monitored for the exit condition to become true. This interpretation is consistent with the English language usage of the word while: e.g.\"while the highway is two lanes, continue, north\". In an earlier written study [Soloway et al, 1981] found that 34% of the students in an introductory programming course thought the test in a Pascal while loop was performed, as a demon. Furthermore, a later interview study showed that novices could even describe the implementation mechanism for such a demon:\"&#8230; everytime I [the variable tested in the <b>while</b> condition] is assigned a new value, the machine needs to check that value &#8230;\"In this report we describe our use of video-taped interview studies for understanding how novices use a programming system. Interviews provide valuable information not available through statistical analysis of written studies. Written studies allow us to manipulate specific factors and guage the results to performance or style. Furthermore, we can have statistical confidence in those results. An interview study, on the other hand, allows us to examine the source of performance or style differences uncovered. Interviews give us an \"execution trace\" while written studies give us the final output. We use both kinds of studies, depending on the kind of information needed.We have interviewed seventeen novice programmers. Four were interviewed regularly for the first 8-10 weeks of their introductory programming course. For these regular subjects we have about 15 hours of interviews tracing their learning and maturation through the course.In this report we show an example natural language specification and discuss strategies used in that specification. We then discuss two examples of novice programming difficulties stemming from an inappropriate use of natural language specification strategies. These examples are illustrated with video tape transcripts. We conclude with a brief discussion of the implications of this work.", "authors": [{"name": "Jeffrey Bonar", "author_profile_id": "81100062334", "affiliation": "University of Massachusetts, Amherst, Massachusetts", "person_id": "PP43124328", "email_address": "", "orcid_id": ""}, {"name": "Elliot Soloway", "author_profile_id": "81332528788", "affiliation": "Yale University, New Haven, Connecticut", "person_id": "PP43124847", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/567067.567069", "year": "1983", "article_id": "567069", "conference": "POPL", "title": "Uncovering principles of novice programming", "url": "http://dl.acm.org/citation.cfm?id=567069"}