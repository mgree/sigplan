{"article_publication_date": "01-24-1983", "fulltext": "\n Permission to make digital or hard copies of part or all of this work or personal or classroom use is \ngranted without fee provided that copies are not made or distributed for profit or commercial advantage \nand that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, \nto post on servers, or to redistribute to lists, requires prior specific permission and/or a fee. &#38;#169; \n1983 ACM 0-89791-090-7 $5.00 Our model of Allen/Cocke interval analysis traces the solution of a sequence \nof progressively smaller systems of hnear equations By incrementalizing this model, we developed incremental \nupdate algorithms ACINCF and ACINCB for forward and backward data flow problems, respectively [Ryder \n82c] We stud+ed the performance of ACINCF and ACINCB on a robust, Algol iike structured programming language \nL, with loop exit structures similar to those of Sail [Reiser 76], We identified program structures that \naffect the complexity of incremental updating and established the extent of this effect offered by combinations \nof such structures, Specifically, for rediicible digraphs we have shown that the elimination phase of \nACINCF updates on each linear system in the derived sequence, a set of interval head equations and at \nmost the equations in one interval A similar result holds for ACINCB. The depth of loop nesting directly \naffects the complexity of incremental updating; it also is a key element in the calculation of the worst \ncase complexity of Allen/Cocke interval analysis, We showed that for a reducible flow graph with loop \nnesting depths bounded by a constant, disregarding the work of interval finding, Allen/Cocke interval \nanalysis has an O(n) worst case complexity bound [Ryder 82a]. Carrying the analysis of our incremental \nalgorithms further, we considered program changes within one interval in a nested loop in a program in \nL and characterized the set of all variables whose equations may be affected, m terms of each variable \ns corresponding program structure and its relation to the original change site Our result enables us \nto analyze a flow graph in f w~th a set of possible program changes identifying a priori nodes whose \nequations will be affected by these changes. Thus, we ascertain all the data flow solutions affected \nby We also model led Hecht/Ullman T1-T2 analysis [Unman 73] and Tarjan interval analysis [Tarjan 74, \nTarjan 79] and designed HUINC, an incremental algorithm based on the Hecht/Ullman algorithm, which was \ncom~ared with ACINCF. tne changes At the outset of this research, we found no previous published work \nm incremental data flow analysis; communication with F. Allen conf rmed this fact [Allen 7 91. At the \nEighth Annual ACM Symposium on the Principles of Programmmg Languages in 1981, B Rosen emphasized the \nneed for incremental update algorithms m general; he used global data flow algorithms for illustration. \nWe concur in his opinion of the inappropriateness of the conventional worst case error bounds for these \nalgorithms. Our theoretical studies of algorithm performance on L provide better insight into incremental \nalgorithm complexity. There are many applications for incremental global data flow algorithms. Interprocedural \ndata flow analysis, in which the call graph of a program is analyzed with respect to data flow in global \nvariables and parameters is an obvious application area [Allen 74, Ryder 74]. Interval analysis based \ninterprocedural data flow algorithms exist [Allen 73, Sharir 79]. Often in the development of large software \nsystems, the set of procedures remains constant while the data flow characteristics of some procedures \nchange. ACINCF and ACINCB can be adapted to handle these changes and to perform incremental interprocedural \ndata flow analysis. Source to-source transformation systems depend on data flow information to validate \nthe triggering of certain transformations that subsequently change the source code and may change its \ndata flow characteristics [Burstall 71, Kibler 77, Loveman 77, Paige 77]. Currently, ad hoc methods are \nused to accommodate data flow changes, incrementalizing data flow algorithms that use a parse tree representation \nof the program would be preferable [Babich 78a, Babich 78b, Rosen 77] as in [Reps 82]. Interactive programming \n environments are popular useful tools for software development [Alberga 8 1]. Here, data flow information \ncan ad m debugging and documentation. In the remaining sections of this paper, first we present an overview \nof our linear equations model of Allen/Cocke interval analysis. Second, we summarize the derivations \nof ACINCF and ACINCB. Third, we show why worst case error analysis is inappropriate for incremental \nanalysis Fourth, we explain our results on the performance of our algorithms on reducible flow graphs \nin general and on flow graphs of programs in f in particular Fifth, we outline our plans for the implementation \nof our algorithms. Finally, we summarize the results presented here which appear in detail in [Ryder \n82a]. 2. Alien/Cocke Interval Analysis Model In this section we define the linear data flow equations \nof Interest. Then we describe our model of Allen/Cocke interval analysis which shows how Gaussian elimination \ntechniques are used to solve the system of linear data flow equations [Ryder 82 b]. We are interested \nin those data flow problems that are defined by a system of linear equations involving the binary operators \nof union and mtarsection. We use the term linear to refer to a system of equations defined using two \nbinary operators whose properties enable us to apply Gaussian elimination techniques to obtain a solution \n[Paull 82]. Depending upon the implementation, the solution of these equations can involve bit vector \nor set operations. Each variable in the linear system of n equations is associated with a unique node \nin the digraph 2 Each edge in the digraph corresponds o aof n nodes. term in tha linear system, The \ngeneral form of a forward data flow equation is {amjn XJubmj}ucm (1 I m = j=pr$d {m} ~ where # can be \nunion or intersection, a b c are mI m~ m constants relating to data flow through nodes m and j, and pred \n{m] is the set of immediate predecessor nodes of m in the digraph. For every term X, in equation 1 there \nis a corresponding edge (j,m) in the digraph, The general form of a backward data flow equation is similar \nto equation 1; the difference is that the limit on $ is jesucc {m} where 2Because of this one to one \nrelation between nodes and variables, we can use these terms interchangeably. aucc {m] is the set of \nIrnmed;ate successor nodes of m in the digraph. The following description of our model of Allen fCocke \ninterval analysis shows how a system of these linear data flow equations is solved. We partition the \nvariables into subgroups called intervals [Allen 7 1]. Each equat!on in an interval is reduced by variable \nsubstnutlons to a linear function of one variable, the interval head variable. The interval headed by \nnode h IS denoted Ih, When the equations in an interval are written according to a hnear order of the \nvariables called interval order [Allen 7 1], their coef f Icient matrix has a lower triangular structure \nfor a forward data flow problem and an upper triangular structure for a backward data flow problem. Thus, \nforward substitution or backward substitution within an interval accomplishes the reduction of the equations \nin that interval The equation Of each interval head variable is reduced by variable substitutions to \na linear function of other interval head variables. We form the derived linear system defined by these \nreduced interval head variable equations. We define intervals and repeat this process which is analogous \nto the variable substitution phase of Gaussian elimination. Finally, one variable remains; the solution \nfor this variable ia found and then we begin a process which is analogous to the back substitution phase \nof Gaussian elimination.3 We identify each solution with an . interval head variable in the previous \nlinear system and then use its value to back substitute in the reduced equations in the previous system. \nIn a forward data flow problem, this process involves substituting the solution for the interval head \nvariable into all reduced equations of that interval In a backward data flow problem, this process involves \nsubstituting the solution for each interval head variable into all reduced equations which are dependent \nupon it In the latter case, the solution for a variable is a hnear 3We assume the digraph is reducible; \nirreducible graphs are rare and can be handled by node splitting techniques [Hecht 77, Kennedy 74]. combination \nof interval head variable solutions rather than a linear function of one interval head variable solution \nas in the former case. We repeat this back substitution process until all solutions in all the linear \nsystems have been obtained 3. Overview of ACINCF end ACINCB Given a localized set of program changes, \nour incremental update algorithms ACINCF and ACINCB consist of two phases corresponding to the two phases \nof our model in Section 2,. First, all coefficients and constants in all data flow equations affected \nby the changes are recalculated. Second, all affected solutions are recalculated. in Figure 1 we show \nthe coefficient structure of the equations of a forward data flow problem for the variables in Ih assuming \nthe variables are ordered in an interval order. Possibly non-zero coefficients are indicated by x or \n$: Given a change at node m=lh the $; indicate the region in which coefficients are possibly affected, \nWe must recalculate the reduced equations in this region when necessary. Then we must check to see if \nthere has been an interval head variable equation . affected by these changes. If no interval head variable \nequation has been affected, we are finished tracing coefficient/constant changes. Otherwise, there is \nan interval head variable Xj, such that the reduced equation for XJ is the equation for XY, where y represents \nIJ in the derived linear system. In that system, we find the interval containing y, Ir. Then we can find \nthe reduced equations in 1, that are affected by this change in the equation for XY as previously We \nmust iterate this process through the sequence of systems of linear equations until all coefficient/constant \nchanges have been propagated as far as possible Eventually, ether we will find a linear system where \nno interva! head variable equation is affected, or we will reach the last system of equations. In the \nformer case, we can re-perform the back substitutions in the changed reduced equations in this system, \nobtaining new solutions. In the latter case, we can solve the equation for the last variable in the system, \nobtaining a new solution. In either columns <hm n .i rows h X.. .xox . . . Xx. ..x o ... Oxo ,.. . 00 \n...0 0 ,., Oxxo. ..oo. ..o .,. .. .. .. .. .. m o ,.. Ox. .,xo, ..oo. ..o o .,.0 ) (, ,,*> :(l. .. (JO \n. ..0 ., .. .. ... .. .. . 0 *$C*, .. *$: 00 ...0 ... -i o Figure 1: Affected Coefficients, Forward Problem \n case, we identify each changed solution in the final system with an interval head variable solution \nin the previous system. We substitute each changed interval head solution in the reduced equations for \nall variables within that intervsl, obtaining all solutions in the interval. This back substitution process \ncontinues through the sequence of linear systems in the reverse of derived order, updating all solutions \ncorresponding to changed equations and/or changed interval head variable solutions. Our incremental update \nalgorithm ACINCB is similar to ACINCF; the differences deal with the dissimilarities in the coefficient \nmatrix structure and the reduced equation form. Figure 2 IS analogous to Figure 1, showing the coefficient \nstructure of the equations of a backward data flow problem for the variables in Ih, assuming the variables \nare ordered in an interval order, Given a change at node m=ln the ~~ indicate the region in whtch coefficients \nare possibly affected. We must recalculate the reduced equations in this region when necessary. Then \nwe must check to see if there has been an interval head variable equation affected by these changes. \nBecause an interval i$ a single-entry, connected subgraph there can be only one interval head equation \naffected by these changes, namely the equation of Xb. AS in the forivard case, the reduced equation for \nX h is the equation of XY where y represents 10 in the derived linear columns 1 a= 1h n j rows h Xo. \n..oxoo. .oo $: . . . *X O.. .O Xo. ..oxoxcloxcl )t . . . *X O.$. O Xo. ..oxox. .ox 00: :... >Ixo. ..() \n. . . . . . . . . . . . . . . . . . . . . . . . m Xo. ..oxoxo. oxo . ..o. :. .. ft x,(),() . . . . . \nOx. .,x , . . . . ,.. . . . . . . . . . . . Xo. ..oxox. .ox () . . . Xxo. ..o -i Xo. ..oxox. .ox 0.. \n. Oxo. ..o Figure 2: Affected Coefficients, Backward Problem system. We find the interval containing \ny in the derived system, 1,. Then we can find the reduced equations in I r that are affected by this \nchange in the equation for XY as previously. We must iterate this process through the sequence of systems \nof linear equations until all coefficient/constant changes have been propagated as far as possible. Finally, \nwe reach the last linear system and solve for the final variable. We identify this solution with an interval \nhead variable solution in the previous system, Then we must recalculate all solutions in the previous \nsystem corresponding to reduced equations containing that interval head variable. We also recalculate \nall solutions in the previous system corresponding to an equation whose coefficients/constants have been \nchanged by the change propagation phase. This back substitution process continues through the sequence \nof linear systems in the reverse of derived order, updating all solutions corresponding to changed equations \nand/or changed interval head variable solutions. 4. Complexity Worst case error analysis is inappropriate \nfor incremental update algorithms. There are pathological digraphs on which incremental updating is tantamount \nto re-performing the data flow analysis algorithm, Unman presented such a digraph of n nodes [Unman 73] \nshown in Figure 3 for n=8; the annotations represent definitions of /+ a \\  fg>i) Figure 3: Pathological \nDigraph for Allen/Cocke Algorithm variable a (a=) and uses of variable a (=a). Consider applying ACINCF \nto update the solution of the reaching definitions problem [Hecht 77] on this digraph. Deletion of the \ndefinition of variable a at node requires the recalculation of all the reduced equations in all the linear \nsystems associated with this example, it also causes all the solutions to be recalculated. On a graph \nof this type with n nodes, the worst case complexity of ACINCF and that of Allen/Cocke interval analysis \nis bounded above by 0(n2). However, such heavily nested loop structures are uncommon in modern programming \nlanguage usage [Allen 79, Elshoff 76, Kennedy 77, Knuth 71, Robinson 76], Therefore, this is not an appropriate \nmeasure of the complexity of ACINCF. We have shown that on a reducible digraph of n nodes with loop nesting \ndepth bounded by a constant, the equation solution work of Allen/Cocke interval analysis exhibits linear \nworst case performance (i.e., O(n)) [Ryder 82al. .5nce a loop IS a strongly connected component of the \ndigraph, it is reasonable that a program change in a loop may affect every solution jn that loop The \nback substitution work necassary to obtain those new solutions is proportional to the number of nodes \nin the loop The Given anyequation update work is bounded as well. reducible digraph with a localized \nset of changes (I.e.. all changes within one interval in the original linear system), the effects generated \nby these changes on any of the derived systems of equations are hm!ted That is, for a forward data flow \nproblem in any derived system the equations affected consist only of a set of interval head equations \nand, at most, the equations in one interval in the system For a backward data flow problem m any derived \nsystem the equations affected consist only of an interval head equation and, at most, the equations in \none interval in the system [Ryder 82c]. To refine our understanding of the equation updating Process \nwe defined a robust, structured programming language L which conwsts of straight-line code (e.g., assignment, \ni/o statements), while statements, compound if statements, done <label> statements and continue <label> \nstatements. We assumed semantics for these statements similar to those in Sail [Reiser 76]. The done \n<label> statement causes control to pass to the statement following the while loop labeled <label> or \nfollowing the syntactically innermost while loop containing the done statement, if <label> is null. The \ncontinue <label> statement causes control to pass to the test of the while loop labeled <label> or to \nthe test of the syntactically innermost while loop containing the continue statement, if <label> is null. \nIn order to state our complexity results, we used the term g-loop to refer to an interval in a program \nwritten in L noting that virtually but not all intervals correspond to while loops. If g-loop h is syntactically \nnested within loop w, then g-loop h is a descendant g-loop of loop w; by syntactic nesting we mean that \nthere is a path from the entry node of loop w to the entry node of g loop h in the digraph and a path \nfrom the entry node of g loop h to the entry node of loop w. Likewise, loop w is a parent loop of g loop \nh, If g-loop h is syntactically nested within loop w and is not nested within any other loop that is \nnested in loop w, then g loop h is an immediate descendant g-loop of loop w; loop w ts the immediate \nparent loop of g loop h If two g-loops have the same !mmediate parent loop, they are sibling g-loops \nA g-loop q is a right (left) sibling g-loop of g loop h, if both are sibling g-loops such that there \nis a path from an exit of g-loop h(q) to the entry node of g-loop q(h). We abbreviate these terms rsib \nand Isib. We categorized g loops with respect to when all their variables are eliminated from the sequence \nof linear systems G loop s is a right greater (equal to) sibling of g loop h if g loop s is an rsib of \ng loop h and all the variables m g loop h are eliminated before (at the same time as) all the variables \nin g loop s We abbreviate these terms rgsib and resib. Corresponding definitions exist for Igsib and \nIasib. In Figure 4, loop w is a parent loop of g-loops h, s, t and q and an Immediate parent loop of \nall but g-loop t. G loop q is an resib of g loop h, g-loop h is an Iesib of g loop q. g loop s IS an \nrgsib of g loop h and g loop s is an Igsib of g-loop q. As seen in Figure 4, these sibling relations \nroughly correspond to a measure of the loop nesting depth within a g loop. When all of the variables \nin a g-loop have been eliminated from the linear system. we call that g loop collapsed in that system. \nL Figure 4: Examples of G-1oops Given a program written in L with a forward data flow problem solution \nand a set of localized program changes, we characterized the equations affected by these changes in terms \nof their corresponding program structures and the sites of the original changes. Also, we indicated the \ndegree of increased complexity introduced by loop exit statements used singly or in concert. Figure 5 \ndepicts cwr results for ACINCF on a k nested g-loop in a program r L Each triangle with top vertex Iabelled \np represents a set of paths through the interval 1~. The entry nodes of the nested loops are Pk , . . \n..p.=r. =r ordered from outermost to innermost. If program changes occur in I, then the variables whose \nequations may be affected correspond to nodes along the dashed paths in Figure 5 If no done statements \noccur 3. If there are done and continue statements in loop pkr then possibly affecled variables correspond \nto entry nodes of rgsibs of g !oop q a subset of {pn+ ,, Pn+2.. . .,Pk} and/or nearest rsibs of a subset \nof {Pn+ ,P +2. . .?PJ , 6;) ;;~, P~<. -,L.-. , /-.,--,,  L L!\\ .F. J. P2.; ::. !.?k- , , P~-l, ,--. \n // :-- \\ pi=r-~:= /r/ \\ \\ P +* (-P-n:; ~ J! _-_> ---.x /-. . . ,------_ -.h Figure 5: ACINCF on a k-nested \nLoop 5 L !,PJ:l,$ .&#38;Jk. \\ A within the loop pk, these variables correspond to the entry Pn=q - - \n\u00ad $ P =@l --> nodes of: rgsibs or resibs of g loop r, parent loops of g-loop r, or rgsibs or resibs \nof parent loops of g-loop r. If done statements do occur, the variables correspond to the entry nodes \nof: rsibs of g-loop r, parent loops of g-loop r, or rsibs of parent loops of g-loop r. (i.) (ii.) (iii.) \nFigure 6 shows the same k nested loop structure as Figure 6: Snapshot of ACINCF Figure 5. Itillustrates \nthe behavi~r of ACINCF during a step of the change propagation phase. Nodes Figure 7 is analogous to \nFigure 5 and depicts our corresponding to variables with affected equations are results for ACINCB on \na k nested g loop in a program in indicated by dashed circles or lie on dashed paths. Assume L. If program \nchanges occur in Ir then the variables whose the equation of Xq was changed in the previous linear equations \nmay be affected correspond to nodes along the system and that g loop q is collapsed in the current linear \ndashed paths m Figure 7. Any variables affected system. Consider which equations can be affected by the \ncorrespond to the entry nodes of a parent loop of g loop changes in the equation for Xq.4 There are three \ncases r, an Igsib or Iesib of a parent loop or an Igsib or Iesib of 1. If there are no done or continue \nstatements g-loop r itself, In this case, the presence of done and in loop pk, then variables corresponding \nto continue statements does not affect our result entry nodes of the immediate parent loop of g-loop \nq, loop p + ,, or rgsibs of q can be affected. Figure 8 shows the same k-nested loop structure as Figure \n7. Itillustrates the behavior of ACINCB during a 2. If there are no done statements, but there are continue \nstatements, then possibly affected step of the change propagation phase. Assume the variables correspond \nto the entrv nodes of rgsibs of g loop q and a subset of equation of XG is changed in the previous linear \nsystem and g loop q is collapsed in the current linear system{p +1rPn+2,. . .jPkl. Irrespective of the \ntype of loop exit statements in loop ph, the same variables can be affected as a result of this 4The \ncode in loop Pk determines which of these change because the data flow Information travels m the possibly \naffected variables are actually affected by this change. Figure 7: ACINCB on a k nested Loop direction \nwhich is the reverse of the control flow. The nodes corresponding to these affected variables are indiceted \nby dashed circles or lie on dashed paths in Figure 8. They are the entry nodes of pn+, the immediate \nparent loop of g-loop q or Iesibs or Igsibs of g-loop q, /.,;:;,> .. .---, * :---pn=q . 1 Figure 8: Snapshot \nof ACINCB The analytic results described in this section enable us to perform a priori analysis of the \ndata flow effects of program changes. They limit the variable substitution work of ACINCF and ACINCB \nto a prescribed set of equations related to the g loop structure of the program near the changes [Ryder \n82c], 5. Future Work The obvious next step in our work is to implement ACINCF and ACINCB for a widely \nused high level programming language such as Pascal or C and gather empirical average complexity reformation \non algorithm performance We also can gather more current information on programming language usage to \naugment the emprical studies cited here. This will enable us to concentrate our attention on program \nchanges whtch occur sufficiently often to insure that our efforts to accommodate them in incremental \nupdating will pay off We envision the use of our incremental update algorithms as part of an interprocedural \ndata flow analysis tool. Our experience with the PFORT Verifier attests to the need for even the most \nrudimentary data flow information with respect to interprocedural analysis of software systems [Ryder \n74, Ryder 79]. In software maintenance there is a need to delineate the scope of a system change; today \noften a let s try it and see attitude prevails. Large applications often maintain histories of source \ncode changes during system development and maintenance. Studies of these histories would yield information \nabout the kinds of changes large systems are likely to undergo. This information alone would be valuable \nto software designers, as the transformation of a set of algorithms and data structures into a working \nsoftware system is not well understood in large practical applications, although various software design \ntechniques exist. 6. Summary We have presented incremental update algorithms for data flow analysis based \non Allen/Cocke interval analysis. We have shown the mappropriateness of worst case error bounds for these \nincremental algorithms. We have complexity results for our algorithms on a robust, structwed programming \nlanguage L, which enable us .s priori to characterize those variables whose equations are affected by \na set of localized progrem changes with respect to their corresponding program structures and the original \nsite of the changes. These results verify the desirability of incremental update algorithms for data \nflow Allen, F. E. A Basis for Program Optimization. In Proceedings of 1971 I FI P Congress,  [Burstall \n71] Burstall, R. and Darlington, J. A Transformation System for Developing Recursive Programs. Journal \nof the ACM 24(1)44-67, January, 1971. [Elshoff 76] Elshoff, J. A Numerical Profile of Commercial Programs. \nSoftware Practice and Experience 6(4)505-525, 1976. PL/1 [Farrow 75] Farrow, R,, Kennedy, K. and Zucconi, \nL. Graph Grammars and Global Program Data Flow Analysis. In Proceedings of Seventeenth Annual IEEE Symposium \non the Foundations of Computer Science, pages 42-56. Institute of Electrical and Electronics Engineers, \nInc., November, 1975. [Hecht 77] Hecht, M. S. Flow Analysis of Computer Programs. Elsevier North-Holland, \n1977. [Kennedy 74] Kennedy, K, Schaeffer s Node Splitting Algorithm SETL Newsletter # 125, February 6, \n1974, Courant Instituta of Mathematical University. Sciences, New York [Kennedy 77] Kennedy, K. and Zucconi, \nL. Application of a Graph Grammar for Program Control Flow Analysis. In Con feretrce Record of the Fourth \nAnnual ACM Symposium on Principles of Programming Languages, pages 72-85. Association for Computing Machinery \n-SiGPLAN, January, 1977. [Kibler 77] Kibier, D, F,, Neighbors, J, M, and Standish, T. A. Program Manipulation \nVia Efficient Production Systems, SIGPLAN Notices 12(8)163-173, August, 1977. [Knuth 711 Knuth, D, E. \nAn EmDirical Studv of FORTRAN Programs. Software Practice 1:105 133, and 1971. Experience [Loveman 77] \nLoveman, D. Program Improvement Source-to-source by Transformation. Journal of January, tha ACM 1977. \n24(1)121 -145, [Paige 771 Paige, R. and Schwartz, Expression Continuity Differentiation of In Conference \nRecord J. T. and the Formal Algorithms. of the Fourth Annuat ACM Symposium on Principles of Programming \nLanguages, pages 58-71. Association for Computing Machinery SIGPLAN, January, 1977 . [Alberga 811 [Allen \n71] [Allen 73] [Allen 74] [Allen 77] [Allen 79] [Babich 78al [Babich 78b] analysis. We have indicated \nareas of application of these methods. We have outlined our implementation plans for continuing work \nin this area. 7. Acknowledgments We acknowledge the help and support of Marv Paull, our thesis adviser, \nthroughout our research. We also thank F. Allen, J Ferrante, B. Rosen and M Wegman for their helpful \ncomments on this presentation. References Alberga, C. N., Brown, A. L., Leeman, G. B., Mikelsons, M. \nand Wegman, M, N. A Program Development Tool In Conference Record of the Eighth Annual ACM Symposium \non Principles of Programming Languages, pages 92-104. Association for Computing Machinery SIGPLAN, January, \n1981. pages 385-390. Institute of Electrical and Electronics Engineers, Inc., North Holland Publishing \nCompany, Amsterdam, Holland, 1971. Allen, F. E. and Schwartz, J. T. Determining the Data Relationships \nin a Collection of Procedures. 1973. Allen, F. E. Interprocedural Data Flow Analysis. In Proceedings \nof 1974 IF I P Congress, pages 398-402. Institute of Electrical and Electronics Engineers, inc., North \nHolland Publishing Company, Amsterdam, Holland, 1974. Alien, F. E. and A Program Data Procedure. Communications \n19(3)137-147, Allen, F. E. Cocke, J. Flow Analysis of the ACM 1977. private communication. Babich, W. \nA. and Jazayeri, M. The Method of Attributes for Data Flow Analysis, Part I Exhaustive Analysis. Acts \nIn formatica 10:245-264, 1978. Babich, W. A. and Jazayeri, M. The Method of Attributes for Data Flow \nAnalysis, Part II Demand Analysis. Acts In formatica 10:265-272, 1978. [Reps 821 [Paull 82] [Reiser \n76] Paul!, M C. Design of Algorithms. in preparation, 1982. Reiser, J. (editor) SA IL. Stanford Artificial \nIntelligence Laboratory Memo AIM-289, Stanford University, Auw.rst. 1976 Reps, T. Optimal time Incremental \nSemantic Analysis for Syntax directed Editors. In Conference Record of the Ninth Annual ACM Symposium \non Principles of Programming Languages, pages 169-176 Association for Computing Machinery -SIGPLAN, January, \n1982. [Tarjan [Tarjan [Unman 74] 79] 73] Tarjan, R, E. Testing Flow Graph Reducibility, Journal of Computer \nand System Sciences 9.355-365, 1974 . Talr!an R E Fast Aigorit.hrns for Solving Path Proh!errx Compmer \nScience Department Technical Report STAN CS 7% 734, Stanford Urxversity, April, 1979 Unman, J D. Fast \nAlgorithms for the Elimination of Common Subexpresslons Acts In formatica 2(31:191 -213. 1973 [Robinson \n76] Robinson, S K. and Torsun, 1. S. An Empirical Analysis of FORTRAN Programs Computer Journal 19(1)56-62, \n1976 [Rosen 77] Rosen, B. K, High-level Data Communications Flow Analysis, of the ACM 20(10 ).7 12-724, \nOctober, 1977. [Ryder 74] Ryder, B G. The PFORT Verifier. Software Practice and 4359-377, 1974 Experience \n[Ryder 79] Ryder, B. G. Constructing the Program. IEEE Transactions Call Graph of on Software a Engineering \n1979, SE 5(3):2 16 225, May, [Ryder 82al Ryder, B. G. Incremental Data on a Unified Flow Model Analysis \nBased of Elimination Algorithms. PhD thesis, Department of Computer Science, Rutgers University, 1982 \nalso available as Department of Computer Science Technical Report #DCS-TR\u00ad117. [Ryder 82b] Ryder, B. \nG, and A Unified Model Paull, M, C. of Ellmmation Algorithms, 1982 in preparation. [Ryder 82cI Ryder, \nB G. and Paull, M. C A Comparison of Incremental Analysis Algorithms 1982. Data Flow in preparation. \n[Sharir 79] Sharir, M. Interprocedural Variable 1979. Analysis Usage, of Global  \n\t\t\t", "proc_id": "567067", "abstract": "In this paper we present ACINCF and ACINCB, incremental update algorithms for forward and backward data flow problems, which are based on a linear equations model of Allen/Cocke interval analysis [Allen 77, Ryder 82a]. We have studied their performance on a robust structured programming language <i>L.</i> Given a set of localized program changes in a program in <i>L,</i> we can identify <i>a priori</i> the nodes in its flow graph whose corresponding data flow equations will be affected by the changes. We can characterize these affected nodes by their corresponding program structures and their relation to the original change sites.", "authors": [{"name": "Barbara G. Ryder", "author_profile_id": "81100632248", "affiliation": "Rutgers University, New Brunswick, New Jersey", "person_id": "PP14217204", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/567067.567084", "year": "1983", "article_id": "567084", "conference": "POPL", "title": "Incremental data flow analysis", "url": "http://dl.acm.org/citation.cfm?id=567084"}