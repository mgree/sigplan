{"article_publication_date": "01-24-1983", "fulltext": "\n Permission to make digital or hard copies of part or all of this work or personal or classroom use is \ngranted without fee provided that copies are not made or distributed for profit or commercial advantage \nand that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, \nto post on servers, or to redistribute to lists, requires prior specific permission and/or a fee. &#38;#169; \n1983 ACM 0-89791-090-7 $5.00 the interconnections among them. These system models are analyzed by a program \ncalled the system modeller that automates the program development cycle by tracking changes to modules \nand controlling the compiling and loading of systems. A system model is a stable, unambiguous representation \nfor a system. It is easily transferred among programmers and file systems. It has a readable text representation \nthat can be edited by a user at any time. Finally, it is usable by other program utilities such as cross-reference \nprograms, debuggers, and optimizers that analyze inter-module rela\u00adtionships. 1.2 Organization of the \npaper The remainder of this introduction contains a summary of the basic ideas behind the design and \nimplementation of the SML language; each idea is explained in detail in its proper place later in the \npaper. Then comes an example of a model for a small but rather intricate Cedar system ($ 2). The next \ntwo sections give the syntax and semantics of SML ($ 3) and explain the many uses of functions and function \napplication ($ 4). Then a number of pragmatic issues are discussed: the treatment of files containing \nsystem elements, the implementation of the SML evaluator, and experience with the language ($ 5). A conclusion \n($6) is followed by an appendix with the model for a significant component of the Cedar system. 1.3 \nBasic ideas System modelling is based on a few simple ideas which are applied uniformly. Because the \nsemantics are very simple, it is easy to determine the meaning of a model. Concise\u00adness and expressive \npower come from lambda abstraction and hierarchical naming. Models are functional. A system is described \nby a model, which is a functional program, i.e., a program that is ex\u00adecuted only for its result and \nhas no side-effects. The result of executing the model is the desired system. Every~hing is a value. \nThe primitive values are inherited from Cedar (or any language in which the elements are programmed). \nSML has three kinds of composite values: Functions. Bindings, or sets of [name, type, value] triples. \nDeclarations, or sets of [name, type] pairs. An element may have a composite value. In addition, such \nvalues can be constructed in SML. Abstrac~ion is done with functions. A function can take any kind of \narguments and return any kind of results. Any SML expression can be turned into a function by X\u00adabstraction; \nsome of the many uses of this mechanism are given in $4. Struclure is expressed by bindings. Any collection \nof [name, value] pairs can be aggregated into a single value called a binding. Because the values can \nthemselves be bindings, any amount of detail can be subordinated hierarchically. A binding can provide \na context for interpreting a hierarchi\u00adcal name such as Cedar. Compiler. Parser. NextState Checking is \ndone with iypes. The type of a function is an ar\u00adrow type (7 + U), which specifies the types its arguments \nmust have and the types of its results. In each application the arguments are checked to ensure they \nmeet the func\u00adtion s requirements. In addition to providing type-check\u00ading for SML programs, this also \nallows any type-checking in the elements to be extended to their interconnections. The type of a binding \nis a declaration. In a A-expression, the required types of the arguments are given by a declara\u00adtion. \nThis allows the body to be type-checked only once, before the A-expression is applied. A model is complete. \nAbstractly, it contains the entire text of all the elements of the program. In an implementation, the \ntext may be stored in separate files and referenced by name, but the text associated with such a name \nmust never change, so this separation is strictly an implementation technique and does not affect the \nsemantics. Of course a model with parameters is not complete until it is applied. Only source text is \nreal. The object files output by trans\u00adlators etc. are an implementation technique for accelera\u00adting \nthe rebuilding of a system after minor changes. 2. An example This section gives a small but rather intricate \nexample of a model for a Cedar program. For the sake of concreteness, it explained entirely in Cedar-specific \nterms, rather than in the more general terms of SML. The interfaces, implemen\u00adtations and instances described \nhere are identical to those in Mesa; these structuring methods have been used for several sizable systems, \nin the range of lOOk to 500k lines of source code [9, 10, 12]. A Cedar system consists of a set of modules. \nThere are two kinds of module: implementation (PROGRAM) modules, or interface (DEFINITIONS) modules. \nAn interface module contains constants (numbers, types, inline procedures, etc.) and declarations for \nvalues to be supplied by an imple\u00admentation (usually procedures, but also types and other values). A \nmodule &#38;fl that calls a procedure in another module &#38;f2 must IMPORT an instance Ins/ of an interface \nz that declares this procedure. Inst must be ExPoRTed by the PROGRAM module Jf2. For example, a procedure \nSort-List declared in a module SortItnpl would also be declared in an interface Sort, and Sor?impl would \nEXPORT an in\u00adstance of Sort. A PROGRAM calls SortList by IMPORTing this instance of Sort and referring \nto the SorlList component of the instance. We call the importer of Sort the client module, and say that \n~ortImpl (the exporter) implemen~s Sort. Of course SortImp[ may itself IMPORT and use interfaces that \nare defined elsewhere. of items from the interface used by a client (CiierrtImpl) are determined by the \nspecific version of the interface (Sort-Points or SortNames). The actual argument supplied for the Sort \nparameter is determined by the model for the pro\u00adgram; see below. SortPoints,cedar SortNames.cedar These \ninterconnections are shown in Figure 1, with filenames for each module shown in bold above the mod\u00adule \ntext. The interface Sort defines an Object composed of a pair [x, y] of coordinates. The exporter, SortImpl, \ndeclares a procedure SortList that takes a list of these objects and sorts them. ClientImp/ defines a \nprocedure Test that calls SortList to sort a list of such objects. Sort. cedar S orCDEFINITIONS-{ Object \nTYPE-RECORD[ Ay: INT]; CompareProc: TYM-PROC ~t~is?~~CRETuRNs [BOOL]; [LIST OF Object, ComparePmc] RETURNSILIST \nOF Objea]; }. ClientIrnpLcedar SortImpLcedar DIRECTORY DIRECTORY Soq SO% ClientImpl: PROGRAM SortImpl: \nPROGRAM IMPORTSsort-{ EXPORTSsort-{ Test PROCIL LIST OF Object]-{ SortLis~ PUBLIC PROC[ --CallSortList \nwith thislist. L LISTOFObject, t +SorrSor~Lis~[/, Compare]: Compare: COmpareProc] . . . RLW_JRNSIIILLIST \nOF Object] --{ }: --Codetosortthelist1, Compare:CompareProc-{ eliminatingduplicates --Comparesthetwoobjeets, \n... --returns/ess,equal or grealer. }; ...  }. }: }. Figure 1: An interface, an implementor and a client \n 2.1 Several interfaces Usually there is only one version of a particular interface in a Cedar program. \nSometimes, however, it is useful to have several versions of the same interface, especially when the \ninterface defines some constants, On the left in Figure 2 is the Sort module from Figure 1, and on the \nright a similar module that defines an Object to be a string instead of a pair of coordinates. A module \nthat uses Sort must be compiled whh one of the two versions, since the compiler must know the type of \neach name in an interface. This is interface parame{eriza{ion, since the types Sort: DEFINITIONS-{ .SorC \nDEFINITIONS-{ Objec[: TYPE-RECORD[ Objecc TYPE-RECORD[ x, y: INT ]; x: STRING]; Compareproc: TYPE-PROC \nCompareProc: TYPE-PROC [a. b: Objecl] RETURNS [BOOL]; [a, b: Objecz] RETURNS [BOOL]; SorlLisc PROC SorlLisK \nPROC [LIST OF Objecf, ComparePrac] [LIST OF Object, CompareProc] RmuRNSILIST oF Object]; RETURNSILIST \nOF Object]; }. }. Figure 2: Two versions of the same interface The parameterization can be arranged \ndifferently, to re\u00adflect the fact that most of the SortPoints and SortNames interfaces are identical. \nOn top in Figure 3 is a single Sort interface which takes an ObjectType interface as a param\u00adeter. Below \nare two versions of ObjectType. Sorl[Points] is the same as SortPoints in Figure 2; Sort[Names] is the \nsame as SortNames. A model using these modules is given in Figure 7. Sort.cedar DIRECTORY ObjectType \nUSING [Object]; Sore DEFINITIONS-{ CompareProc: TYPE-PROC JO~f2iS?~jCRETuRNs [BOOL]: [LIST OF Object, \nCompareProc] RETURNSILIST OF Object]; }. Points. cedar Names.cedar Objec[Type: DEFINITIONS-{ ObjectType: \nDEFINITIONS-{ Objecc TYPE--RECORD[ Objecc TYPE-RECORD[ x,y: INT]; x: STRING]; }. }. Figure 3: A parameterized \ninterface It might be argued that this example should be done with instance parameters, like the ones \nin $2.2 below, and that interface parameters are needed only because part of the implementation (namely \nthe actual value of the type Ob jec~) was improperly put in the interface. If the interface were a pure \ndeclaration, with all values supplied by an im\u00adplementation, there would be only one Sort interface as \nin Figure 4. Cedar does allow type declarations (rather than actual values such as RECORD[, , ,]) to \nappear in interfaces, and the Sort of Figure 4 would actually be tine, because the client does not depend \non the type value, In general, however, constant values in interfaces cannot be avoided in Cedar, because \nthe only way to supply an argument value (such as a type) at compile-time is to put it in an in\u00adterface \n(Ada goes half-way by allowing it to be in the private part of the package specification). This is probably \na deficiency in the Cedar implementation. From the point of view of this paper, however, it illustrates \nthe ability of system modelling to handle an imperfect programming lan\u00adguage. Sort. cedar Sore DEFINITIONS-{ \nObjecc TYPE; CompareProc: TYPE-F ROC [U b: Objecf] RETURNS [BOOL]; SorfLisc PROC [LIST OF Object, CompareProc] \nREP.JRNSILIST OF object]; 1. Figure 4: A single Sort interface with a type declaration Quicksort.cedar \nHeapsort.cedar DIRECTORY DIRECTORY Sorg so% Quicksort: PROGRAM Heapsort: PROGRAM EXPORTSSorl-{ EXPORTSSort-{ \nSorLLisC PUBLIC PROC[ SortList: PUBLIC PROC[ L LIST OF Object, 1: LIST OF Object, Compare: CompareProc] \nCompare: CompareProc] RE KJRNS[ttL LIST OF Object]-{ RITIWRNS[tIL LIST OF Objecf]-{ --Code to sort the \nlist/, --Code to sort the list/, eliminatingduplicates. eliminatingduplicates --UsesQuicksort --UsesHeapsort \n... ... }: }; }. 1. C1ientImpl.cedar DIRECTORY SOrC ClientImpl: PROGRAM lhiPORTS Quickson: Sort, Heapsort: \nSon-{ Tesr: PROCIL LIST OF Objecl]-{ --Quicksortthelist. quickL: LIST OF Object -Quicksor~SortLis~f, \nCompare]; --Now try Heapsort. beapL: LIST OF Objecl HeapsorLSortLis~l, Compare]; IF NOT ListEqua(quickL, \nheapL] THEN . . . ... 1: Compare: COmpareProc-{  --Comparestbetwoobjects;returnsless,equalor greater. \n... }.  2.2 Several instances When there is only one interface, it may have several im\u00adplementations. \nFor example, a system that uses the left ver\u00adsion of the Sort interface in Figure 2 might use two differ\u00adent \nversions of the module that EXPORTSsort, one using the Quicksort algorithm and the other using the Heapsort \nalgorithm to do the sort. Such a system includes both implementors of Sort, and must specify which SortList \nrou\u00adtine the clients get when they call Sort.SorlListfl. In Cedar a client module can IMPORT both versions, \nas shown in Figure 5. In Figure 5, Quicksort and Heapsort each EXPORT a SortLis~ procedure to the Sort \ninterface: Quicksort.SortList uses Quicksort to sort the list; Heapsort.SortList uses Heapsort. C/ienUmpl \nimports each version under a different name, in this case the same names (Quic&#38;ort and Heapsor~) \nused for the implementation modules. The client procedure Test calls each SortLis~ in turn by specifying \nthe name of the interface and the name of the procedure (e.g. Quick- sort.SortList[. . .]). This client \nhas three parameters: an in\u00ad terface Sort and two instances of Sort (Quicksort and HeapSort), A reasonable \napplication in a model which uses this client might be something like C[ientImp(Sort, Quicksort, Heapsort] \nClientImpl.cedar DIRECTORY SorlPoiritK INTERFACE Sort, SortNames: INTERFACE SorL Clierrllmpl: PROGRAM \nIMPORTS QuicksortP: SortPoint$ HeapsoriP: SortPoints QuicksortN: SortNames, HeapsortN: SortNames-{ LP \nTYPE-LIST OF SortPointxObjec~ LN TYPE-LIST OF SortNamexObjecq Test: PROC[lP: LP, In: LN]-{ --Quicksort \ntl,e list of points. quickLP LP-QuicksortP.SortLis~@, Compar P]; --Now try Heapsort. heapLR LP-HapsortP.SortLisdkJ, \nCompareP]; IF NOT ListEqudFfquickLP, heapLP] THEN . . . .. --Nowdo it for names. quickLN LN-QuicksortP.SartLisd16 \nCompareN]; heapLN LN-HeapsortP.SortLis~ln, CompareN]; 1~ NOT LisrEqual~quickLN, heapLN] THEN. . . .,. \n}; CompareP SortPOintsComparePrOC-{ --Compares the two objects; returns less, equal or greater. ... }: \nCompareN SortNamezComparePrad  }. }; Figure 5: Two implementations of an interface Figure 6: A client \nwith two interfaces and four instances This would not be legal in SML because of the rules for binding \nfunction parameters (see $ 3.4), but the model for a slightly more complicated system than this one is \ngiven at the end of this section. We can put the examples of Figures 3 and 5 together to get the somewhat \ncontrived client program in Figure 6, which has two interface parameters and four instance pa\u00adrameters. \nIt soifi both lists of Points and lists of Coords, using both Quicksort and Heapsort. Thus there are \ntwo in\u00adterfaces, for the two types of lists being sorted, and four in\u00adstances, one for each combination \nof type and sorting method. 2.3 Paramelerizalion in SML We are now in a position to understand the model \nwithin which the interface modules of Figure 3, the Sort imple\u00admentations of Figure 5, and the client \nof Figure 6 can be embedded; it is given in Figure 7, Client.model 5 orlTesf -[ --Interfaces Points: \nINTERFACE ObjectType -@Poinls.ceciafl; Names: INTERFACE ObjectType -@.Names.ceda~; Sort: [lNTI?RFACE \nObjeclType]+[INTERFACE .son] -@~orLcedan ,SorlR INTERFACE Sort .Sor@oinls]; SorlN INTERFACE Sort -Sor/[Names]; \n--Implementations Quicksorc [L INTERFACE S orr]+[lnsc J -@?QrdcksorLce&#38;n Heapsort: [L INTERFACE Sort]+ \n[Insl: I] -@Heapsort.ceoh< --Now the instances and the client. Client CONTROL -@ClientImplce&#38;~ SortPoinrs*SorrP, \nSorlNames-SorrN, QuicksortP-Quicksor@SorlP~ QuicksortN-Quicksor@ortfl HeapsortP--Heapsor~SortP]. HcapsorlN-Heapsor@ort~ \n] 1 Figure 7: A system model with several of everything This model is a binding, which gives values to-eight \nnames: Points, Names, Sort, SortP, SortN, Quicksort, Heap\u00adsort, and Client. The first three are bound \nto the corres\u00adponding Cedar modules (the module stored on file F is referred to by the expression @F, \nas in @Points.cetir). Note that Sort is a function, since it takes a partieter (the type of the objects \nto be sorted) and returns a Sr,w inter\u00adface. The type INTERFACE N is the type of the vahIe re\u00adturned \nby a Cedar module which begins IV DEFINITIONS; it acts as the bridge between the SML type system and \nthe Cedar type system, which SML does not understand, Then SortP and SortN are bound to the Sort interfaces \nfor points and names, obtained by applying the function Sort to the interfaces Points and Names. They \nhave the same type (INTERFACE Sort). Next the two Sort implementations are bound to Quicksort and Heapsort. \nBoth of these are functions, since they depend on the Sor[ interface; note that they return (EXPORT) \nan interface whose type is given by their argument. Finally, the client can be applied to its six argu\u00adments, \nThis model does not give names to the four in\u00adstances of Quicksor/ and Heapsort, although it could have \ndone so and then used those names for the arguments to Clien~. Alternatively, we could have refrained \nfrom naming Points and Names,writing instead SortP: INTERFACE Sorl Sorf[@?Poirrts.cedafl]; SortN: INTERFACE \nSorl -Sori[@Namesceaisfl]. We used a binding for the arguments of Client to make the correspondence \nof arguments and parameters clear, If all the arguments have unique types, the parameter names can be \nomitted in an application; this is the usual case, but this example is different. In addition, any argument \ncan be defaulted to the name of the corresponding parameter; defaulting is specified by writing a * between \nthe function and the arguments, This model would normally be written [... SorlPoinfs: INTERFACE sort \nSorf[pdnts]; SorfNames: INTERFACE .%m -.ror~Narrses]; ... C1ienCCONTROL -@?ClientImpl.ccohF[ QuicksortP-Quicksor~Sor~Points], \nQuicksortN-Quicksor4SortNamesl HeapsortP-Heapsor@ortPoin@ HeapsortN-Heapsor@ortNames] ] 1 with the interface \nparameters to Client defaulted. If we named the instances of Sort with the names used in the domain declaration \nof ClientImpl, we could default those parameters also, getting simply C[ienf: CONTROL -@.clienfImpl.ceais#D \nfor the client. The kinds of values in SML follow naturally from the ob\u00adjects being represented. The \nvalue of @Poirrts.ceda~ is the file for the inter\u00adface module Points.cedar. Wheq SortTest is built, this \nmodule will be compiled, and it is actually the result\u00ading object file that is passed as the Points argument \nwhen Sort is compiled; it is possible to think of this object file as the value of @Poirrtsceda~. The \nvalue of @Quicksort.cedar can only be the source file, since the Cedar implementation requires all the \ninterface arguments to be supplied at compile time. The value of Quicksort[SortP] is the instance of \nSortP returned by Quicksort. To run the program, we need a representation of this instance which is a \nrecord of procedure descriptors produced when the object file gotten by compiling Quicksort[SorfP] is \nloaded. Note there are two object files for Quicksort in this exam\u00adple; one corresponds to Quicksort[SortP] \nand exports SortP, and the other corresponds to Quicksor@ortN] and exports SortN. Itis instructive to \ndistinguish the two kinds of arguments by the difference in implementation. An interface argu\u00adment is \nsupplied to the compiler, which checks the types of the various objects and procedures. An instance argu\u00adment \nis supplied when a module is loaded and the imports of other modules are resolved. The reader who is \nfrustrated by this rather unrealistic ex\u00adample may wish to examine the more realistic one in $4.3, and \nthe real system model in the Appendix. 3 .The SML language In this section we describe the polymorphic \napplicative lan\u00ad guage SML which was illustrated SML wds devised to serve two pur in the poses: previous \nsection. It is a notation for describing tem from its elements, the composition of a sys- It is roughly \nthe applicative subset of the Cedar Kernel language. The Kernel is a small, precisely defined and intuitively \nsimple language, with the property that any Cedar program can be straightforwardly rewritten as a Kernel \nprogram. The Kernel program may invoke some proce\u00addures from a fixed library; e.g., i+j is rewritten \nas IN-TEGER.PLUS[i,J. Eventually, the Kernel will be a subset of Cedar. When this happens, Cedar programmers \nwill write programs and describe systems in the same underlying lan\u00adguage. Thus SML is both independent \nof Cedar, in the sense that it can be used to compose elements written in any language, and very closely \nrelated to it, in the sense that it is a subset of an evolved Cedar language. l%is paper views SML primarily \nas a subset of Cedar, but its general utility is discussed in $3.2 and $5. 3.I Concepts The SML language \nis built on four concepts: Application offunclions; Any expression can be made into a function by A-abstraction. \nApplication is the basic method of computing. There are no side-effects; hence an expression can be replaced \nby its value with\u00adout changing the meaning of a program. Valuw Everything is a value, including types \nand functions. Bindings [Name, value] pairs can be grouped into sets called bindings; the values are \nidentified by their names. Every name is interpreted by looking it up in some binding. Types Every name \nhas a type, and strong type-check\u00ading ensures that the value of the name has that type. Function bodies \nare checked independently of applica\u00adtions. 3,I. I Application The basic method of computation in SML \n(as in Lisp) is by applying a function to argument values. A function is a mapping from argument values \nto result values. A function is implemented either by a primitive supplied by the language (whose inner \nworkings are not open to inspection) or by a closure. A closure is the value of a A-ex\u00adpression whose \nbody in turn consists of applications of functions to arguments, e.g. A[x: INT] IN x+ y+ 3 where x: INT \nis a (typed) parameter, y is a free name, and x+ y+ 3 is the body. A closure is a triple: parameters \na declaration; environment a binding equal to the current environ\u00ad ment of the A-expression; body: an \nexpression, the body of the A-expression. It is helpful to think of a closure as an expression together \nwith values for all its free names except the parameters; hence the term closure. Evaluation always terminates \nin SML because there are no conditionals; thus an equivalent way to evaluate a A-expression is to replace \nall the free names in the body with their current values, and make a closure with an empty environment, \nA A-expression that doesn t return values is useless, since there are no side effects. Application is \ndenoted in pro\u00adgrams by expressions of the form ~[arg, arg, ...]. 3.1.2 Values An SML program manipulates \nvalues. Anything that can be denoted by a name or expression in the program is a value. Thus strings, \nfunctions, interfaces, and types are all values, In the SML language, all values are treated uniform-IY, \nin the sense that any can be passed as an argument bound to a name, or returned as a result. These operations \nmust work on all values so that applica\u00adtion can be used as the basis for computation and A-expres\u00adsions \nas the basis for abstraction. In addition, each partic\u00adular type of value may have its own primitive \nfunctions; e.g., equality for most types, plus for integers, etc. None of these operatioris, however, \nis fundamental to the language. SML has very few types of values, since it is not intended for general-purpose \ncomputing. The primitive types are STRING, TYPE, and INTERFACE n for any name n. Strings are useful for \ncompiler options and as components of file names. SML also has string literals. E.g., the binding [x: \nSTRING - lit , y: STRING -xl gives x and y the string value lit . TYPE is the type of a type, i.e. of \nSTRING, TYPE, lNIERFACE n, or a declaration; h is seldom needed in models. INTERFACE n is the type of \nthe value returned by a Cedar interface module named n; thus INTERFACE Sort is the type of the Sort interface \nreturned by the Sort modules in $2. Every value has to have some type, and there isn t any\u00ad thing more \nspecific to say about the type of the Sotv inter\u00ad face. It would be slightly simpler to have a single \ntype IN-TERFACE which is the type of every interface value. In practice, however, an interface is usually \nidentified by its name, and the more specific type provides a useful check, This point is treated in \nmore detail in $5. In addition to values of these primitive types, there are two kinds of composite values: \nfunctions, whose types are arrow types, e.g., T*G bindings, whose types are declarations.  3.1.3 Bindings \nand scope A binding is an ordered set of [name, type, value] triples, often denoted by a constructor \nlike this: [x: STRING N S , y: STRING u t ] or simply [x- s , y- t ]. individual values can be selected \nfrom a binding using the , operation, which is like Pascal record selection: if b is the binding above, \nthen b.x denotes s and has the type STRING. Since the values in a binding can also be bindings, it is \npos\u00adsible to have a single binding which is a multi-level, hierar\u00adchically named set of values, This \nis exactly the same power provided by a hierarchical file system, e.g., the one in Unix. Any amount of \ninformation can be denoted by a single name. For example, in the Appendix Cedar is a bind\u00ading which contains \na large set of Cedar system interfaces. There are two useful operators for combining bindings, If bl \nand b2 are bindings with no names in common, then bl + b2 is the union; if there are names in common, \nthis ex\u00adpression is an error. This also works for declarations. The expression bl THEN b2, on the other \nhand, k never an er\u00adror; if n appears in both bindings, it has the value bl.n in the result. Some other, \nmore esoteric operators on bind\u00adings are described in $4.1. A scope is a region of the program in which \nthe value bound to a name does not change. For each scope there is a binding that determines these values, \ncalled the current environment. A new scope is introduced by IN following a LETor A,orbya [.. . ] constructor \nfor a binding. LET adds the names in a binding to the current environment: LETb IN exp changes the current \nenvironment for exp to b THEN ENV, where ENV is the current environment for the LET expres\u00adsion. Thus \nit makes the names in b accessible in exp with\u00ad out qualification. A A does the same thing when it is \nap\u00ad plied, using the arguments as the first binding: ! (~ dIN exp)[args] is equivalent to LET d-args \nIN exp. In a binding constructor b, the current environment is b THEN ENV; thus expressions in the constructor \nsee all the names being bound. LET expressions are useful for giving names to cumber\u00ad some expressions. \nFor example, a set of standard Cedar in\u00ad terfaces can be defined in the file Cedar.modeL [ Rope: INTERFACE \nRope -@Ropeceda#U, IO: INTERFACE IO.-@IO.cedo~fl, #pace: INTERFACE space -@.Spaccceda?u ] Then a LET \nexpression like LET C-@ Cedar.ModellN [.,. C.Rope,. . ] is equivalent to [... (@Cedar. Made~.Rope.,. \n] which in turn is equivalent to [... @Rope. cedar... ] Itis also possible to make a prepackaged set \nof definitions directly accessible. For instance, the previous expressions are also equivalent to LET \n@Cedar. Modef IN [ . ..]Rope.. (provided Rope is not bound in the [ . . . ]). After the IN the identifiers \nRope, IO, and Scope can be used without qualification. A declaration is the type of a binding. It is \nan ordered set of [name, type] pairs, often denoted [x: STRING,Y:STRING]. If d is a declaration, a binding \nb has type d if it has the same names, and for each name n the value b.n has the type ah. 3.1.4 Types \nA type in SML is a predicate on values: a function which maps a value into a Boolean. If T is a type \nand T[X] is true, we say that x has type T. A fhnction f has an arrow type D+ U, where D is a declaration. \nWhen Jis applied to an argument x, we require that x have type D; thus an ar\u00adgument must be a binding. \nThis is called a type check if it fails, there is a type error, The type offlx] is U. For a func\u00adtion \nin which the result type depends on the arguments (e.g., an implementation module, which maps an interface \n1 into an instance of type I), U is itself a function, which must be applied to the arguments to yield \nthe result type. Thus in this case the type of fix] is u[x], Rather than writ\u00ading the function explicitly, \nwe infer its presence whenever U has a free name declared in D; thus [x: q+u is shorthand for [X: ~]+(~ \n[x: i @VPj? IN @ If ~ is primitive (e.g., if it is the value of a Cedar module, rather than of a )i-expression \nin SML) the type check en\u00ad sures that the primitive is getting the kind of arguments it expects. For \nexample, when a module imports an instance of the SortPoints interface (see Figure 2), the type check \nen\u00adsures that it will actually get an instance of SortPoints, rather than an instance of SortNames, or \nof BesselFunctions. Since Cedar itself is strongly typed, it chooses the types of its modules so that \nthis check is sufficient to ensure that the individual procedures and other values in the instance have \nthe proper types. Thus the type-checking of SML ex\u00adtends the type-checking of Cedar to the composition \nof an entire program. Within SML itself the main role of types is in the declara\u00adtions in a A-expression. \nIn the expression A dl+~ 1?4exp the types of the parameters in dl area pre-condition for t?p\u00adplying the \nfunction: the arguments must have those types. The types of the results iri d2 are a post-condition: \nthe results are guaranteed to have those types. Thus: The caller must establish the pre-condition (supply \nar\u00ad guments of the right types) and may assume the post\u00ad condition (count on the types of the results). \nSymmetrically, the A-body may assume the pre-condi\u00ad tion (count on the types of the parameters), and \nmust establish the post-condition (supply results of the right types). Like any pre-conditions and post-conditions, \nthe purpose of the declarations is to allow the body and the application to be checked independently \nof each other. Once the body has been checked (assuming the declared types for the parameters) it is \ncertain that if an application doesn t cause a type error, then the expression which results from sub\u00adstituting \nthe arguments for the parameters will not cause a type error. A secondary use of types in SML is in bindings. \nThe binding n: T-e is a type error unless e has type c if it checks, n has type Tin the binding. This \nis a form of redundancy which is of\u00adten useful, but it is entirely optional. If T is omitted, then n \nhas the type of e. To do the type-checking, it is necessary to be able to com\u00adpute the type of each expression. \nThis is done by the usual induction on the structure of expressiotis. Every name has a type, because \nthe name is introduced either in a binding or in a declaration. Every literal has a type derived from \nits syntax; e.g., the type of abc is STRING. Every Cedar module has a type, whose derivation is discussed \nin the next section. The type of an application is computed as described above. The type of a A-expression \nA d1*d2 IN e is d1+d2. The type of a binding is the corresponding declaration; the type of a declaration \nis TYPE. 3.2 Values of Ceahr modules SML allows the text of system elements written in any lan\u00adguage \nto be included in a model, as long as there are pro\u00adcedures to: Turn this text into an SML value. If \nit is a function value, apply it to arguments. These prOCedllreS are specific to the language in which \nthe element is written. This language must be identified some\u00ad how. A conceptually straightforward way \nof doing this is to treat the text as a string, and provide a primitive func\u00ad tion for each language \nwhich converts the string into an SML value. With this convention the expression CEDARf -%X DEFINITIONS-{ \n.. . }. ,,1 is the way to include Sort.ce&#38;r from Figure 1 in a model. In fact, SML includes text \nfrom other languages by naming a file containing the text. The previous example would be written @Sortcedar \nwhere Sort.cedar has the contents given in Figure 1. The language is identified by the last component \nof the file name. This is logically identical to the previous mech\u00adanism; its pragmatic are discussed \nin $5. The SML value of a module is always a function, When this function is applied, the result is one \nOE another function, with an arrow type; an interfaCe, With INTERFACE ~ as its type fOr some n; a binding \nwhose values are instances, each with some interface as its type, Interfaces and instances are opaque \nin SML; i.e., there is nothing to do with them except to hand them around as uninterpreted values, or \npass them as arguments to some function derived from a Cedar module. The functions are also opaque, in \nthe sense that the implementation of ap\u00adplication is outside the province of SML, and depends on the \nimplementation of Cedar. The only requirements im\u00adposed by SML are that there be no side-effects visible \nin the model, and that the types supplied for Cedar modules correctly express the Cedar rules for what \narguments can properly be given to each function. The operations of com\u00adpiling and loading modules and \nestablishing linkages are the result of applying these opaque functions to interface and instance arguments. \nIn order to make the interface between SML and Cedar clearer, we will describe in some detail exactly \nhow opaque SML values are derived from Cedar modules, and how Cedar implements application of opaque \nfunctions. When a Cedar module M is compiled, any interface 1 needed by M (as an argument for a parameter \ndeclared in its DIRECTORY statement) must be compiled first, and the compiler must have access to the \nobject file for 1. All the compile-time external dependencies of a module are speci\u00adfied in this way. \nWhen a module is loaded, any instance needed by M (as an argument for a parameter declared in its IMPORTS \nstatement) must be satisfied by filling in links in the compiled code with procedure descriptors exported \nby other modules. All the load-time external dependencies of a module are specified in this way. These \nrelations are expressed in SML by passing as arguments to M the values corresponding to an interface \n(for compilation) or an instance with procedure descriptors (for loading), Interface parameters Consider \nan interface that depends on no other interfaces, i.e. its DIRECTORY statement is empty, and hence it \ncan be compiled without reference to any other modules. SML treats the module containing the interface \nas a function value, Its type is an arrow type with no parameters and one result, e.g. n + [INTERFACE \nSort] where Sorl is the name of the interface, as in Figure 1. The application of this function (to no \narguments) will result in an object of type INTERFACE Sort. SortInter$ace: INTERFACE Sorl -@Sor!Moduleceaizfl \ndeclares a name SortInterjace that can be used to specify the dependency of other modules on this interface, \nAn in\u00adterface BTree defined in the module BTree.ceaiv that de\u00adpends on Sort would have a type like [SortPararme/er: \nINTERFACE Sort] + [INTERFACE BTree] To express this dependency in the model, we apply the BTree module \nvalue to the Sort interface value: BTreeInteface: INTERFACE BTree \u00ad@BTreeModule.ceda~SorlParameier-SorlInte$ace]; \n In this example we used different names for various en\u00adtities having to do with the Sort and B7 ree \ninterfaces: SortInterJace and BTreeInterface for the SML names to which the interface values are bound; \nSort and BTree for the names of the interface types: INTERFACE Sort and INTERFACE BTree; SortModule.cedar \nand BTreeModule.ce&#38;r for the names of the (files containing the) Cedar modules which define the interfaces; \nSortParameter for the name of the parameter to BTreeModule which has type INTERFACE Sort. Normally the \nsame name is used for all these purposes, so the two bindings in the last paragraph would be Sore INTERFACE \n.$orc -f@!Sort.cedafl BTree: INTERFACE BTree -@BTreeceda~Sort--Sort]; Instance parameters An instance \nof an interface that is ExPoRTed is represented as a record that contains procedure descrip\u00adtors, etc. \nThese procedure names are declared in the inter\u00ad face being exported and bound in the exporting PRO-GRAM \nmodule, We can think of the interface module as a declaration for this record. Consider the implemen-tation \nmodule SortImpl in Figure 1. SortImpl exports an instance of the Sort interface and calls no procedures \nin other mod\u00adules (i.e. has no imports). This module has the arrow type [Sort INTERFACE sort] + [&#38;rrtlrW \nsort] and can be used as follows: Sort: INTERFACE sort -@?Sorf.cedafl; SorlInrc Sort -@SorlImpl.ceda~Sorl-Sorl]; \nwhich declares first a name Sort of type INTERFACE Sort whose value is the interface defined by Sort.cedzr, \nand then a name SortInst of type Sort, whose value is the instance ex\u00adported by SortImpl.cedar. If SortImpl \nimported an instance for BTree, then the type would be [Sore INTERFACE Sort, BTree: INTERFACE BTree, \nBTreeInsc B7 ree] + [SortInsC Sort] and the exported instance would be computed by SortInsc Sorl -@SortImpLceab~Sorl, \nBTree, BTreeInsl]. Here in the argument [Sort, BTree, BTreeInst] we have omitted the parameter names; \nsee $4.1 for the semantics of this. 3.3 Syntax SML is described by the BNF grammar below. Whenever x, \n.,. appears, it refers to O or more occurrences of x separated by commas. l separates different productions \nfor the same non-terminal. Words in which all letters are capitalized are terminal symbols which are \nreserved words in the language; punctuation symbols other than ::=, I and ... are also terminals. Words \nthat are all lower case are non-terminals; the definitions for the following non-ter\u00adminals are omitted: \nname, which stands for an name, string, which stands for a string literal in quotes, and filename, which \nstands for a string of characters that are legal in a file name. Subscripts are used to identify specific \nnon-terminals, so they can be referenced without ambiguity in the accom\u00adpanying explanation. exp ::= \nA expl -exp2 IN exp3 I LET expl IN exp2 I expl exp2 I expl * exp2 ] expl infixOp exp2 I expl. name I \n[ewl,...1 I [decl ] I [binding] I name I string I ENV I INTERFACE name I STRING I TYPE I expl -D expz \n @! filename decl ::= declElement, ... declElement ::= name: exp binding ::= bindElement, ... bind Element \n::= [ decl ] -exp2 I name: expl -exp2 name -exp2 / [ name, ...] -exp2 infixOp ::= +l l/l\\ltl THEN  3.4 \nSemantics The value of an SML expression is defined by induction on the syntax, The evaluation rules \nare those of the A-cal\u00adculus, together with definitions of the primitives for han\u00addling types, declarations \nand bindings. In this section ENV stands for the current environment. Lamb&#38; exp ::= A expl -expz \nIN exp~ The expl is evaluated and must yield a declaration d. The value of exp is a closure, consisting \nofi the parameters, which are the declaration ~ the environment binding, which is ENV; the body, which \nis the expression exp3. The type is expl + exp2. The exp type-checks if in every environment P THEN \nENV, where P is a binding of typed, exp2and exp3type-check, and exp~has the type exp2. In other words, \nthe result and body must type-check for any arguments which satisfy the parameter declaration, and the \nbody must have the type specified as the result type of the A-expression. This check is implemented by \nconstructing a P with each name bound to a value differ\u00adent from any other value. LET exp ::= LET expl \nIN exp2 The expl is evaluated and must yield a binding b. The type and value of exp are the type and \nvalue of exp2 in the en\u00advironment b THEN ENV. Application exp ::= expl expl I expl* exp2 The expl and \nexp2 are evaluated to yield a function f of type D+ U and a value x; usually exp2 has the form [ bind\u00ading \n]. Then for the first alternative, the expression D-x is evaluated to yield a binding args; of course \nthis expression must type-check. For the second alternative, the expres\u00adsion x+ (ENVt(D x)) is evaluated \nto yield a binding args; see $4.1 for the meaning of these operators. The type of exp is U, or U[args] \nif U is a function (see $3.1.4 for a dis\u00adcussion of this case). For the value there are two casesto consider: \n1. The function j is a closure, i.e., the value of an SML A-expression. If the closure has environment \nE and body body, then the value of exp is the value of LET (urgs THEN J?) IN bcdy 2. The function is \na primitive, either built-in or more likely, derived from a Cedar module (see $ 3.2). The value is whatever \nresult the primitive computes from the argument args; a primitive is responsible for ensur\u00ading that the \nresult has the proper type. Inj2x operators These are discussed in $4.1. Dot, group, declaration and \nbinding exp :: = expl. name The expl must evaluate to a binding b, whose type is a declaration d, The \ntype of exp is the type of the name in d, and the value is the value of the name in b, exp ::= [ expl, \n... ] This is a constructor for a group, which is a binding with anonymous names for the elements. exp \n::= [decl] decl ::= declElement, ... declElement ::= name: expl The type of exp is TYPE. Its value is \nthe set of [name, type] pairs obtained by evaluating the expl expressions in the declElements, and pairing \nthem with the corresponding names. If a binding is used where a declaration is required (e.g., in a A, \nor after a colon), then it is coerced to a declaration in the obvious way. Thus [x-T, y-U] is coerced \nto [x: ~, y: U]. Of course, this fails unless each component in the bind\u00ading is a type, exp ::= [binding \n] binding ::= bindElement, ,., bindElement ::= [ decl ] -exp2 I name: expl -exp2 I name -expz I [ name, \n...] -expz In the first alternative for bindElement, decl is evaluated to a declaration d and exp2 must \nevaluate to a binding or group b with type 4 the bindElement binds each name n in d to the value of n \nin b. If n does not appear in b there is a type error. If b is a group its elements must all have different \ntypes, the elements of d must all have different types, and the bindElement binds each name n in d to \nthe value in b with the same type; if there is no such value, there is a type error. The second alternative \nallows the brackets around a single\u00ad component declaration and group to be omitted. If only a name appears \nbefore the --, as in the third alternative, the type is inferred from that of exp2. The fourth alternative \nis the same, except that exp2 must evaluate to a binding or group with the same number of components \nas there are names in the brackets, much like the first alternative. Note that because of the definition \nof application, these rules are also used for binding arguments to function parameters. Names and literals \nexp ::= name The type and value of exp are the type and value of ENV.name, exp ::= string A string literal \nlike abc is a primitive value. exp ::= INTERFACE name This literal primitive type is discussed in $3.2. \nNote that name here is part of the literal, and is m-x looked up in ENV. exp ::= STRING I lYPE Literals \ndenoting primitive types. exp ::= expl ~ exp2 The exq must evaluate to a declaration d. The value of \nexp is a function type T, If fhas type T, ittakes values of type expl, and the type of fix] is (A d+TYPE \nIN exp)[x]; see $3.1.4. If g has type T+Ll then DOMAIN[g] is T and RANGE[g] is U. exp ::= @ filename \nThis expression is shorthand for the text stored in file jilename. If the file contains a model, then \nexp can be replaced by the contents of the file. If it contains a Cedar module, then the type and value \nof exp are derived from that module as described in $3.2. 4. Functions and arguments In addition to providing \nthe basic abstraction mechanism of SML, functions and function application play a number of important \nroles in the practical use of models: They allow the interconnections among modules to be expressed, \neven when there are multiple versions of in\u00ad terfaces and instances: see 52 for examples. They allow \nthe relation between a model and the en\u00ad vironment it depends on to be expressed: a model with free names \ncan easily be converted by A-abstrac\u00adtion into one with no free names, in which all depen\u00addence on the \nenvironment is explicit in the parameter declaration, and the nature of the model s value is ex\u00adplicit \nin the result declaration. An application of the function makes the choice of environment explicit. See \nthe l?Tree models later in this section, and the Appendix, for examples. They allow different configurations \nof a system to be produced. For instance, by parameterizing a model with a DiskDriver instmce, different \nconfigurations of the system which use different disk drives can be pro\u00adduced by applying the model to \ndifferent DiskDriver instances. They allow the choice of translator for a system ele\u00adment to be made \nexplicit, and make it easy to specify parameters of the translation (e.g., target machine, op\u00ad timization \nlevel, etc.). See $5 for further discussion of this point. In this section we present some SML facilities \nfor manip\u00adulating functions and their applications which are not gen\u00aderally needed for ordinary computation, \nbut are useful in writing models. We begin by reviewing the rules for binding arguments to parameters \ngiven in $3.4. When the argument is a bind\u00ading, its elements are matched by name with the parame\u00adters. \nThus if P is bound by P x ~[X: STRING, y: lNrERFACE Y] = [z: INrERFACE Z] IN [...] then P takes two arguments. \nSuppose we also have y bound by Y:INTERFACE Y-@?Y.ceuizfl, The arguments to P may be specified as a binding: \nZ: INTERFACE Z -P [X- lit , Y-Y] Alternatively, since the types are all distinct (and this is the normal \ncase; multiple versions of interfaces or in\u00adstances are not too common), the arguments may be speci\u00adfied \nas a group: z: INTERFACE Z -P ~lit , y] and they are matched by type to the parameters. In both cases \nthe elements of the argument bhding or group are matched to the elements of the parameter declaration \nbased on some distinguishing property; the order of lit and y does not matter in either example. The \nreason for the absence of binding by position in the binding is that ar\u00adgument lists are often rather \nlong. 4.1 Defaulting Another feature of SML which is motivated by long argu\u00adment lists is the defaulted \nform of application: exp1*exp2 Defaulting allows the programmer to omit many param\u00adeters; a missing parameter \nnamed n is supplied as ENV.n, where ENV is the current environment. Thus with the binding for y above, \nand X: STRING  lit in ENV, the expression ~*u is equivalent to P [x, y]. Of course, if there is no binding \nfor n in ENV, or if it has the wrong type, there is an error, since this is just a shonhand. The model \nat the end of this section gives other examples of defaulting. Note that in a model consisting of a single \nlarge binding with all the elements as its values, defauhing all the argu\u00adments corresponds to the interconnection \nrule used by most linkers, which connects all the external references to a name n with the single definition \nof n. To define the defauking rule precisely, we need to intro\u00adduce a few operators on declarations and \nbindings. The union operator + was defined in $ 3.1.3; it combines two declarations or bindings with \nno names in common. The restriction operator ~ takes a binding as the first operand and removes all the \nnames which do nol appear in the declaration which is the second operand. Thus [x: STRING lit , y: INTERFACE \nY Defi] T [x: STRING] is equal to [x: STRING- lit ]. There is an error unless the resulting binding btd \nhas type d, i.e., unless each name in d actually appears in b with the corresponding type. The same operator \nalso works with a declaration as the first operand, removing all the names which do not appear 4.2 Splitting \n SMI. also provides two operators \\ and / which split a func\u00adtion that takes several arguments into \none that takes some of the arguments and returns a function that takes the others. Thus P : [x: STRING, \ny: lNrIRFACE Y]~[2: INTERFACE z]-... can be split to yield PSPiif: [x: STRING]+(~ INTERFACE Y]+: INTERFACE \nz])\u00ad t \\[x: STRING] The split function can then be applied once, leaving a curried function which takes \nfewer arguments than the original one, because some of the argument values have been fixed. For example, \nwith the bindings for y and Psplit given above, Pl: w INTERFACE Y] -+ [z: INTERFACE Z] -PSpk~ Iit ], \n z: INTERFACE Z -Pl~] binds z to the same value as before, but does it in one ex\u00adtra step. The main application \nof splitting and subsequent currying is to fix the interface arguments of a Cedar module with\u00adout fixing \nthe instance arguments. This makes for a clearer model when modules are applied to several implements \ntions of the same interface. It also reflects the realities of the implementation, in which compilation \nautomatically fixes the interface arguments, but instances are bound only on loading. in the binding \nwhich is the second operand. Thus [x: STRING, y: INTERFACE Y] T [x: STRING lit ] is equal to [x: STRING]. \nIn this form b must have type dtb; i.e., each name n in b must actually appear in d, and b,n must have \nthe type declared for n in d. The exclusion operator takes a declaration as the first operand and removes \nall the names which do occur in the declaration or binding which is the second operand. Thus [X: STRING, \ny: INTERFACE Y] [X: STRING] is equal to b: INTERFACE ~ and so is [x: STRING, y: INTERFACE Y] [1: STRING- \nlit ]. LLke dtb, d b is an error unless b has type d?b, or equivalently d= (d b)+(fib) Similarly, dl \n d2 is an error unless JI= (dl-d2)+d2. Now we can define application with defaulting in terms of ordinary \napplication: Y b is equal to J XLI+(ENV T (DOMAIN~]\u00ad b))) where DOMAIN~] is the domain declaration for \nthe func\u00ad tion f(see $ 3,4). There are two splitting operators. f\\ d is a function of type d+((DOMAIN~] \nd) +RANGEV]): it leaves d on top . Symmetrically, f / d has type (DOMAIN~] d)+d+RANGEV]); it leaves \nd underneath, and can be pronounced -fkeep\u00ading d. Both require that DOMAIN~] d be legal, i.e. that \nthe splitting declaration be a subset of the function s do\u00admain, The precise definition off/ d is A DOMAINV] \nu =(d+RANGEv]) IN (h d= RANGE~] INf*O) The defaulted application collects the argument values for f \nfrom the argument bindings of the two nested A-expres\u00adsions. There is a similar definition for f \\ d, \nbut more en\u00adlightening is this one: f/ (DOMAIN~-f$ Splitting and defaulting can be used together, of \ncourse, so that the last example with PI is equivalent to: PI: ~ lNrERFACE Y] + [z: INTERFACE Z] -(P/~ \nINTERFACE Y])*O, z: INTERFACE Z -P1*D In fact, the declaration for PI is unnecessary: we can write this \nas: Pl -(P/~ INTERFACE Y]~u, Z: INTERFACE Z -PI*U The / operator makes explicit the parameters remaining \nfor PI; the other way of writing it is less clear without the declaration: PI -(P\\ [x: STRING]) *U. \n 4.3 A more realistic example The value of BTreel.model is a binding of BTreeProc to a The B-tree package \npresented in this section is a small sys\u00ad tem, but one which displays most of the features of larger \nones. It consists of an implementation module in the file BTreeImpl.cedar and an interface BTree that \nBTreeImpl ex\u00ad ports. There is no client of BTree in the example; the model returns a function which, \nwhen given suitable argu\u00ad ments, returns the BTree interface and an instance which implements it. A client \nmodel would have a reference to this model and a client for the interface. The BTree interface uses some \nconstants found in .4scii, which contains names for the ASCII character set. The BTreeImpl module depends \non the BTree interface (since it exports it), and it uses three standard Cedar interfaces: Rope defines \nprocedures to operate on immutable, garbage collected strings. IO defines procedures to read and write \nformatted data to a stream. Space defines procedures to rd- Iocate Cedar virtual memory for large objects, \nin this case the B-tree pages. Figure 8 is a first version of the package. BTreel.model LET [ Asci~ INTERFACE \niisc/i -@AsclLcedafl, Rope: INTERFACE Rope -@Rope. cedad fl, 10 INTERFACE 10-@lo.cedo#O, Space: INTERFACE \nSpace -@?Space.cedaFn ] IN BTreePrac \u00ad ~ [RopeInsK Rope, IOInsc IO, SpaceInst: Space] = [BTree: INTERFACE \nBTree, BTreeZnsc Bi ree] IN [ BTree: INTERFACE BTree -@BTree.ceda~Asdi], BTreeInsK BTree -@BTreeImpl.ce&#38;r \n~BTree, Rope, 10, Space, RopeInst. IOInst, SpaceInst] 1 Figure 8: The fully-expanded B-tree model This \nmodel, stored in the file BTreel.model, describes a B\u00ad tree system composed of one interface BTree and \na single implementation module for it, The first four lines declare four names used later. Ascii just \ndefines some constants, and needs no arguments; the arguments to the other inter\u00ad face modules are defaulted \nto reduce clutter. Note that the types are optional; these lines could read: Ascii -@Asciicedafl, Rope \n-(@ Ropececidfl, IO -@tO.cedaPH, Space -@?Space.ceda@fl since the types can be determined from the values. \n_Next we bind a name BTreeProc to a function with three in\u00ad stances as parameters. If those are supplied, \nthe function will return an interface for the B-tree package, and an in\u00ad stance of that interface. Within \nthe. body of the A-expres\u00ad sion which defines this function, there are bindings for the identifiers BTree \nand BTreeInst. Here again the types could be omitted. function. Another model might refer to the B-tree \npackage by [BTree, BTreehtst] \u00ad(@?BTreel.mode[).BTreeProc[RopeInsf, IOInst, SpaceInsr] The individual \ntreatment of Ascii, Rope, IO, and Space is clumsy, and it would be even more clumsy if there were twenty \nsuch interfaces instead of four. To make this neater, we can construct a binding for these names, and \nrefer to it in BTree.model. Figure 9 shows this, together with defaulting of the interface arguments \nto BTreeImpl. Cedar.model [ Ascit INTERFACE Ascii -@Ascii.ceda~, Rope: INTERFACE Rope -@Rope. ceda#o, \nIO: INTERFACE 10-@IO.ceda@fl, Space: INTERFACE Space -@Space.ced.~fl ] BTree2.model LE? @Cedar. model \nlN BTreeProc \u00ad ~ fRopeInst: Rope, IOlnsc IO, SpaceInst: Space] e [B Tree: INTERFACE BTree, BTreeInsr \nBTree] IN [ BTree: INTERFACE BTree -@BTree.cedaflAscii], BTreeInsK BTree -@BTreelmpl,cedar lRopeInsl, \nIOInst, SpaceInstl ] Figure 9: The B-tree model with interfaces separated The prefix of BTreeI is split \ninto a separate file called Cedar.model. Now BTree2.model contains a LET statement that makes the values \nin Cedar accessible in BTree. Divid\u00ading BTreel into two models like this makes it possible to establish \nstandard naming environments, such as a binding that names the commonly-used Cedar interfaces. The Ap\u00adpendix \nhas a bigger example. Programmers are free to redefine these bindings in their models; the operators \non bindings defined in $4.1 make this easy. The idea can be carried further by defining another bind\u00ad \ning with the standard implementations of the interfaces. Figure 10 shows how this is done, If also replaces \nthe inclu\u00ad sion of the standard models in BTree with parameters, so that the dependence of BTree on the \nenvironment is made explicit. BTree3 has in its text (inChlding text incorporated by the @ construct) \nonly the B-tree package itself. We can apply BTree3 to get a BTree interface and instance: L!? r[ln~erfaces-f@Cedar. \nmodel] IN @8Tree2.mode~Interfaces, @CedarInstsmode~Inte faces] ] This is still clumsy in two ways: the \nfour-component type for the Interfaces parameter of BTreeProc, and the three separate instance parameters \nto BTreeImpL both of these would be much longer in a larger system. The first problem cannot be solved \nwithout giving up the idea of type-checking a A-expression independently of its applications. 1f we write \na more general type for Interfaces, Cedar.model [ Intefaces -[ Ascit INTERFACE Ascii -@!AsciLcedafl, \nRope: INTERFACE Rope -@Ropeceda@fl, I@ INTERFACE IO -@?IO.ceda#[], Space: INTERFACE Space -@Space.ceda~U \n] ] CedarInsts.model A [Intefaces: [Ascit INTERFACE Ascii, Rope: lNTF.RFACE Rope, 10: INTERFACE IO, \n&#38;ace: INTERFACE Space]]+ lrf/e~ace$IN [Ascii Rope, IO, Space] -LET Inlefaces lN [ @?AsciiImpl.ceab~, \n@RopeImpLceais@~, @IOImpLceda?[, @Spacetmpl.cedaP~ ] BTree3.model [ BTreePmc \u00ad ~[ Inte$aces: [Ascii-INTERFACE \nAscii, Rope-INTERFACE Rope, IO-INTERFACE IO, Space-INTERFACE Space], Insc Interfaces] s [BTree: INTERFACE \nBTree, BTreeInsC BTree]lN LET Interfaces lN [ BTree: INTERFACE BTree -@?BTree.cedafiAscii], BTreeInsl: \nBTree -@!BTreetmpLcedar*[Insl. Rope, Inst.10, InsLSpace] ] ] Figure 10: Standard interfaces and instances \nasparameters such as DECLARATION, then there is no way to check an expression like Intet--aces.Ascii \nwithout the argument. This problem also arises in Cedar itself, where a vague type (at the Cedar level) \nlike INTERFACE Rope prevents type-check\u00ading of a module like BTreeImpl until the argument is supplied, \ne.g., as @!Rope. cedar*U. This is the main reason that compilation, which includes type-checking, requires \naccessto all the interfaces used by a module. Thus Cedar in effect has two kinds of A-expression: the \nordinary kind, written as an ordinary procedure body, or as the IMPORrS statement of a module; an unchecked \nkind, written as the DIRECTORY state\u00adment of a module. Currently SML does not have an unchecked A-expression. \nThe second problem cannot be solved by prefixing LET Inst and defaulting the instance argurnentssince \nthey have the same names in Inst as the interfaces; if the elements of Znst are given different names \nit won t have Interfaces as its type. An attractive solution is to move down into Cedar modules the notion \nof collecting interface and instance parameters into bindings. Thus instead of a BTreeZmpl with seven \nparameters (BTree, Rope, 10, Space, RopeInst, IOInsl and SpaceIrzst), we would have one with three parameters \n(BTree, [nterjaces, and Instances). To make it clear which parts of these large bindings are actually \nused, we can modify the DIRECTORY statement according to this example: DIRECTORY[Rope, IO, Space] Interfaces \nUSING Cedar already has this facility for specifying which names in a particular interface are used, \nso this is a natural exten\u00adsion. 5. Pragmatic This section discusses a number of pragmatic issues in \nthe use and implementation of SML, and summarizes our ex\u00adperience with a preliminary version of the Modeller, \n 5.1 Files We take the view that the software of a system is com\u00adpletely described by a single unit of \ntext. An appropriate analogy is the way a card deck was used to run a program on a bare computer or under \nan operating system like FMS that had no file system. Everything is said explicitly in such a system \ndescription: there is no operator interven\u00adtion to supply compiler switches or loader options after the \nGCI bUttOn is pressed, and no dependence on a chang\u00ading environment. In such a description there is no \nques\u00adtion about when to recompile something, and version con\u00adtrol is handled by distributing copies of \nthe deck with a version number written on the top of each copy, and a diagonal stripe of marker which \nmakes it easy to tell whether the deck has been changed. The monolithic nature of a card deck makes it \nunsuitable for a large system. In 1982 a system is specified by text which is stored in tiles. This provides \nmodularity in the physical representation: a file can name other files instead of literally including \ntheir text. In Cedar, these files hold the text of Cedar modules or system models. This represen\u00adtation \nis convenient for users to manipulate; it allows shar\u00ading of identical objects, and facilitates separate \ncompila\u00adtion. Unless care is taken, however, the integrity of the sys\u00adtem will be lost, since the contents \nof the named file may change. To prevent this, we abstract files into objecfs, which are simply pieces \nof text. We require that names be unique and objects be immu[able. By this we mean that Each object has \na unique name, never used for any other object. The name is stored as part of the object, so there is \nno doubt about whether a particular collec\u00adtion of bits is the object with a given name. A name is made \nunique by appending a unique iden@er to a human-sensible string. The contents of an object never change \nonce the ob\u00adject is created. The object may be erased, in which case the contents are no longer accessible. \nIf the file system does not guarantee imm Utability, it can be en\u00adsured by using a suitable checksum \nas the unique identifier of the object. These rules ensure that a name can be used instead of the text \nof an object without any loss of integrity, in the sense that either the entire text of a system will \nbe correctly as\u00adsembled, or the lack of some object will be detected. With these conventions, a model \ncan incorporate the text of an object by using the name of the object. This is done in SML by writing \nan object name preceded by an @. The meaning of an SML expression containing an @-expression is defined \nto be the meaning of an expression that replaces the (Z! expression by its contents. For example, if \nthe file inner. model contains lit which is an SML expression, the binding [x: STRING --@2inner.sm, y: \nSTRING - lit ] has identical values for x and y. As discussed ;n $3,2, if the object O is not an SML \nexpres\u00adson but a Cedar module, or an element written in some other language, it is turned into an SML \nexpression by con\u00adceptually surrounding it with a text-to-SML value conver\u00adsion fUnCdOn, e.g., CEDAR~ \n0 ]. It is not essential that the text of a system element be source text; all that is needed is a way \nto turn it into an SML value. For a Cedar source module, this is done by parsing the DIRECTORY, IMPORTS \nand EXPORTS statements at the start of the module. But it can also be done for a Cedar object module, \nwhich is the output of the compiler and has all its interface parameters bound; object modules have enough \ninformation (originally for the benefit of the loader) to allow an SML INTERFACE or function value to \nbe derived. This is sometimes convenient when dealing with a system in which some elements come from \nan outside organization in object form only. S.2 Miscellaneous prob[ems SML provides straightforward \nsolutions to a number of problems which have arisen in constructing Cedar systems. Translators Cedar \nprogrammers may use a number of programs that analyze a source program written in some language, and \nproduce new source programs. For example, an LALR(l) parser generator called PGS takes a Cedar source \ntile with a grammar embedded in it as stylized comments, and produces: Tables, a Cedar source file for \nan interface which defines the structure of the parsing tables for this grammar. TabfesImpf, a Cedar \nobject tile containing paining tables that can be loaded. Actions, a Cedar source file which is a modification \nof the input, containing: code for the semantic actions, which is copied from the input code to call \nthe parser, supplied by PGS to supplement replace the comments, which contained the grammar. Another \nexample is a remote procedure call stub generator [14] that takes the source for a Cedar interface, and \npro\u00adduces four source tiles that must all be compiled. In each of these cases the output tiles depend \non the input file, and if the input file were modified, the preprocessor would have to be run again. \nFor each language in which a system element is written, we need a way to derive an SML value from an \nobject in the language. For example, a pgs object is a function with the type n~[~ubles: []+[z INTERFACE \nPGSTubles], TablesImpk Tables, Ac{ions: ActionsInterface+ OtherParameters + [ T INTERFACE PGSTables, \nTImpL T, Parser: INTERFACE Parser, ParserImpk Parser] -[AI Adions[nterface] ] Here ActionsIn(erJace k \nexported by the Aciions module, and OtherParameters is a declaration for any other param\u00ad eters of that \nmodule. Actions also has the tables and the parser itself as parameters. Such a function might be applied \nlike this: [ PascalTables: OAIT INTERFACE PGSTables], PascalTableslmpL PascalTables, PascalActions: (PascaIParse< \nINTERFACE PP, X INTERFACE X, XL X, T INTERFACE PGSTables, TImpL T, Parser: lN1 ERFACE Parser, ParserImpk \nParser] ~ [PascafParserImpL PascalParser ] ] \u00ad@!PascalGrammar.pgfl Here the types are redundant and included \nfor clarity; we could have written [ PascalTables, PascaiTablestmpl, PascalActions]-@PascalGrammar.pgfl \nwith the same effect. In either case, the model can now proceed to apply PascalActions. Supposing we \nhave a suit\u00adable binding for PascalParser, the interface implemented by this parser, and for Parser, \nParserImplj X and X1, we can default these and write PascalParserInslarsce: PascalParser -PascalActions*[ \nT-PascalTablefl, TImpl-PascalTablesImpll which leaves us with an instance PascalParserInstance of the \npascalparser, which can be returned from the model, or passed to another component. The code that derives \nSML values from PGS objects gets control when @2PascalGrammar. pgs is applied. It is respon\u00adsible for \ninvoking the PGS preprocessor and deriving SML values from the tiles that PGSproduces. Since these are \nor\u00addinary Cedar files, code to derive SML objects from them atready exists. . In some cases, when a single \nobject can be translated in several ways, it may be better to apply a translation func\u00adtion to it explicitly \nin the model. This is the case for the RPC stub generator, since it processes an ordinary Cedar interface \nmodule, which might also be treated in the usual way. So we might write RPCSlubGeneralot{@! Upa2zieFilesstring] \nCompiler Options Certain aspects of the Cedar compiler s execution can be controlled by specifying compiler \noptions. When the com\u00adpiler is run from the operating system s command proces\u00adsor, these options are \ngiven as command line swifcAes con\u00adsisting of a single letter. For example, j instructs the com\u00adpiler \nto perform a cross-jumping optimization on the code it generates, b instructs it to check for bounds \nfaults, etc. Since the behavior of a system depends on these options, they are treated like any other \nparameters. The function type of a Cedar module includes a STRING parameter op\u00adtions which can be specified \nexplicitly; e.g., QuicksortPoints: SortPoints \u00ad @QUicksoFf.cedadoptions- j .Sort-SortPoints] If op[ions \nis missing, it is defaulted automatically, in a slight departure from normal SML semantics. The model \ncan supply a binding; if it does not, there is a global bind\u00ading for this name. Mul[ip[e Exports We have \ndescribed systems where there is one exporter of an interface and one or more importers. It is possible \nto split the implementation of an interface among several modules, and merge the exported instances together. \nThis often happens when the implementation becomes very large and is split by the programmer. Because \ninstances are actually bindings in Cedar, with essentially the same semantics as SML bindings, it is \nconvenient to extend the + and THF,N operators ($ 3.1.3) to them. Usually the in\u00adstances export disjoint \nnames, so that + is the proper operator: BTreeImpL BTree -@2BTreeImplA.cedar~ + @BTreeImplB.ce&#38;rfl \nS.3 Imp[ementat ion The*implementation of the Modeller has three quite dis\u00adtinct parts: The language \nimplementation: parsing, prettyprinting and evaluation of SML expressions. The bridges to the programming \nlanguages for ele\u00adments. The Cedar bridge, for example, derives an SML value from a Cedar module, and \nwhen this value is a function knows how to apply it by invoking the Cedar compiler or loader. The adminis[razor, \nwhich retrieves the value of an ob\u00ad ject from the file system, manages the cache of object tiles, notices \nchanges to elements and updates the mo\u00ad dels accordingly, etc. We will discuss only the language implementation \nhere. Since SML has no iteration constructs and no recursively\u00addetined functions, the evaluator can expand \neach applica\u00adtion of a closure by /?-reduction, replacing it by the clo\u00adsure body with formals replaced \nby actuals. Similarly, an @ reference to a sub-model can be replaced by the text of the referent. This \nprocess of substitution must be applied recursively, as the expansion of a A-expression may in\u00advolve \nexpansion of inner A-expressions. The evaluator does this expansion by copying the body of the A-expres\u00adsion, \nand then applying itself recursively after adding the argument binding for the application to ENV. ENV \nis maintained as a tree of bindings in which each level corresponds to a [ . . . ] binding constructor, \na bind\u00ading added by a LET statement, or an argument binding. Bindings are represented as lists of triples \nof [name, type, value]. A closure is represented as a quadruple [parameter declaration, result declaration, \nbody, environment]. As ex\u00adplained in $3.4, in an application the body is evaluated with ENV equal to \nargs+ E, where args is the argument binding and E is the environment from the closure. An @\u00adexpression \nis represented by a pointer to the disk file named, together with its type and, for a function, a procedure \nfor applying it. A interface value is represented as a pair [module name, pointer to module file], and \nan in\u00adstance value as a pair [pointer to procedure descriptors, pointer to loaded module]. The substitution \nproperty of Russell [4] guarantees that variable-free expressions can be replaced by their values without \naltering the semantics of Russell programs. Since SML programs have no variables and allow no recursion, \nthe substitution property holds for SML programs as well. This implies that the type-equivalence algorithm \nfor SML programs always terminates, since the value of each type can always be determined statically. \n 5.4 Experience The SML language, in a somewhat different form, has been used by about five programmers \nin the past year, and sup\u00adports the development of systems ranging from lk to 50k lines of code. Some \nof these systems, and in particular the Cedar compiler, exist in numerous versions. The implementation \nand use of this old SML language un\u00adcovered a number of problems. The language has been redesigned and \nthe evaluator is being rewritten to take ad\u00advantage of the more solid foundations of the language described \nin this paper. The largest improvements have been in the uniform treatment of declarations and bind\u00adings \nas first-class values, the systematic derivation of SML values from elements, and the use of /3-reduction \nfor evaluation. During the next year we expect to use SML and the Mod\u00adeller to control the development \nof the entire Cedar sys\u00adtem. which is now about 500k lines of source code. 6. Conclusion SML is used \nto describe a system assembly and module in\u00adterconnection scheme in which polymorphism occurs naturally, \nSML consists of the applicative subset of the Cedar Kernel language, with values that correspond to types, \ndeclarations and bindings, as well as the interfaces and instances which characterize Cedar modules. \nSML is based on the A-calculus; it uses Algol scope rules, The most common vahre is a Cedar interface \nor instance. Each Cedar interface defines a single INTERFACE vaftte in SML; each implementation has a \nfunction type that depends on the interfaces it uses and implements, The in\u00adterconnections among modules \nare expressed by treating each module as a function which returns instances of the interfaces it implements, \nand passing each interface or instance as an argument to the modules that use it, The arguments also \ninclude any other information needed to run the module in the system, such as character strings that \nspecify the compiler options. A model logically includes the entire text of the system it describes. \nIn fact, however, the text of a module is stored in a file which must be immutable, and is referenced \nfrom the model by a file name followed by a unique identifier for the particular version of the module. \nThe filename is used as a hint since the unique-id identifies the module un\u00adambiguously. An object file \nis a source file that has been compiled with interface types filled in. A module is recom\u00adpiled only \nwhen one of its interfaces changes. A system model is thus a stable, unambiguous representa\u00adtion for \na system, It is easily transferred among program\u00admers and file systems. lt has a readable text representation \nthat can be edited by a user at any time. Finally, it is usable by other program utilities such as cross-reference \nprograms, debuggers, and optimizers that analyze inter\u00admodule relationships, Acknowledgements System \nmodelling began with ideas developed jointly with Charles Simonyi, and grew out of the discussions of \na working group which included Bob Ayers, Phil Karlton, Tom Malloy, Ed Satterthwaite and John Wick. Many \nconversations with Rod Burstall clarified the notions of binding rmd declaration. Ed Satterthwaite has \ngiven us a lot of helpful comments and advice. References [1] Avakian,A,e~al.,Thedesignofanintegratedsupportsoftwaresys\u00adtem. \nProc.SIGPLAN 82 Syrqr. Compi/er Consmucfiorr, June1982, 308-317. [2]Cooprider,L.W., The Represema[ion \nof Families of Sojiware Sys(ems. PhD Thesis, CMLI-CS-79-1 16, Computer Science Dept., CMU, April 1979. \n [3] Cristofor, E. e( al., Source control + tools = stable systems. Proc. 4th Computer SoJware and Applications \nConj!, OCL, 1980,527-532. [4] Demers.A. and Donahue, J,, DaLa types, parameters, and tvpe check\u00ading, \nProc. 7th Symp. Principles of Programming Languages, Ias Vegas, 1980,12-23. [5] DeRcmer, F. and Kron, \nH, Programming-in-the-large versus programming-in-the-small. IEEE Trans. Sojlware Eng. SE.2, 2, June \n1976,80-86. [6] Deutsch, L.P. and Taft, E,A., Requirements for an Experimental Programming Environrnen(. \nCSL-8O-1O, Xerox PARC, 1980. [7] Goldstein, I.P. and Bobrow, D.G,, Descriptions for a programming environment, \nProc. 1s1Ann. Conj Natl. Assoc. Artl~cial Intelligence, Stanford, Aug. 1980. [8] Habermann, A.N. et al., \nThe Second Compendiunr of Ganda~ Docunren/a[ion, Computer Science Dept., CMU, May 1982. [9] Harslem. \nE. and Nelson, L.E., A retrospective on the development of Star, Proc. 61h [tul, C onf Soflware .Eng,,Tokyo, \nSept. 1982. [10] HorsIcy, T.R. and I.ynch, W.C., Pilot: A software engineering case study. Proc. 4/h \nInd COIIJ Sojware Eng., Munich, 1979,94-99. [11] l.ampson, B.W. and Schmidt, E., Organizing software \nin a dis\u00adtributed environrncnt. In preparation. [12] Lauer, H.C. and Satterthwaitc, E. H., The impact \nof Mesa on system design. Proc. 41h Ind. Co/f Soj7ware Eng., Munich, 1979,174-182. [13] Mitchell, J,G, \ne[ al., Mesa Language hfanual. CSL-79-3, Xerox PARC, April 1979. [14] Nelson, B.J., Renlo/e Procedure \nCall. CSL-81-9, Xerox PAR~ May 1981. [15] Schmidt, E., Con(rolling Large Sojiware Development in a Distributed \nEnvironment. PhD Thesis, EECSDept., Univ. of Calif. Berkeley, Dec. 82. [16] Tichy, W. F., Design, implementation, \nand evaluation of a revision control system. Proc. 6th In/l. Conf Software Eng., Tokyo, Sept. 1982. Appendix: \nA real example This model describes the BringOver program, which is a substantial component in the Cedar \nsystem. First, we present the model with its environment aggregated into separate models, and with defaults \nfor all the parameters. Then we give a fully expanded version, to show the entire dependency structure. \nThere are seven implementation modules within this model (C WFImpl, ComParseImpl, SubrImpl, STPSubrImpl, \nDFSubrImpl, DFParserImpl, BringOverImpl). All the rest are interfaces, First we define the two environment \nmodels. One is a big binding for the Pilot interfaces on which BringOver and many other parts of Cedar \ndepend. The other is a declaration for the instances of these interfaces. This declaration is rather \nrepetitive, but it is needed to provide the proper names for defaulting the instance arguments of the \nBringOver models. $4.3 explains how to avoid this declaration by passing the entire interface binding, \nand a corresponding binding for the instances, as two big arguments to the client modules, Cedar currently \ndoes not permit this, however, and we do not show it here. Pilot. model [ Ascii -(@lA$cii.cedafifl; CIFS \n--@!CIFS.ceda# [: COnvertUnsafe -@?ConverlUnxafe.cedaPu; Dale -@Date. ceda#[]; DCSFileTypes -@DCSFileTypes,ceaizFU; \nDirectov -@!DirecZow.cedaPfl; Envirckmem -@Environment. ceoizP[]; Exec -@?Exec.ceda#l]; File -@File.cedaFfl; \nFileSlream -@FileStrearn.ceairP[]; Heap -@Heap, cedaP~; Irdine -@Inline.ceda#D; KernelFile -@?KernelFile.cedaPU; \nLongSming -. @LongString,ce&#38;P~; NameAndPasswordOps -@NameAndPasswordOps. cecri.#fl; Process -@?PrOcess.cedaPfl; \nRope -@.Rope.ceda@~; RopeInline -@RopeInline,ceaW fl; Runlime -@Runtime.ce&#38;PH; Segments -@Megmenls.cedaP~; \nSpace -@Space.cedaP~; Storage -@Slorage.cetslsF fl; STP -@?STP.cedzPfl; STPOps -. @STPOps.cecskPfl; Slream \n-@S@eam.cedaPfl; Siring -@String.ce&#38;P~; System -@?Syslem.cedaPH; System[mernal -. @SyslemIniernal. \nceoizFn; Time -@Time.cedafln; Transaction -@?Transaction. cedaPo; lTY -@?TTY.ceaizPB; UserTerminal -@?UserTerminal.ceaisPH \n] PilothrstancesDecl.modeI LET @PilotInterfaces. model IN [ CIFSImpl: CIFS, ConverlUnsafeImpt ConvertUnsafe, \n--23 declarations are omitted for brevity-- TTYImpL TTY, UserTerminalImpL UserTerminal ] The models \nabove are part of the working environment of a Cedar programmer; they are constructed once, as part of \nbuilding the Pilot operating system. Now we can write the model for BringOver. It picks up the two Pilot \nmodels above, and then gives a single binding of BringOverProc to a function which takes the instances \nas an argument, and returns two interfaces and an instance of each. The body of the function has one \nLET to make all the Pilot interface and instance names directly accessible for defaulting; a second t,ET \nto bind all the internal interfaces and instances of BringOve< a binding to construct the two interfaces \nand two instances which are the result of applying BringOver Proc. BringOver.model LET [Inter faces-@Pilot.model, \nInslancesDecl-@Pilo(InslancesDeclmodel IN [BringOverProc -A [Instances: InstancesDecll+ [BringOver: INTERFACE, \nBringOverImpk BringOvec BringOverCalL INTERFACE, BringOverCallImpt BringOverCal~ IN --Make the Pilot \ninterface and instance names accessible LET Interfaces+ Instances IN LET [ --These are the internal interfaces \nand instances CWF -@CWF.cedaPU; CWFImpl -@?CWFImpl..cedcrPfl; CornParse -@COmParse.cedar*u; CorrrParseImpl \n-@ComParseImpl.ceda~ fl; Subr -@?Subr.cedaPI; SubrImpl -@LSubrlmpLcedaP U; STPSubr -@STPSubr.cedaFl; \nSTPSubrImpl -@STPSubrImpl,ceai?P fl; DFSubr -@DFSubr.cedaP~; DFUser -@DFUser.cedaFn; DFSubrImplA -@DFSubrImpl.ceakz \nflD; DFSubrImplB -@.DFParserImpl. ceal@~; DFSubrImpl -DFSubrImpli-DFSubrImplB ~ [N [ --These arc the \nexported interfaces and instances BringOver-@BringOver.ce&#38;?d; BringOverCall -@BringOverCaI1. cedaP~; \n[BringOverImpP BringOver, BringOverCallImpL BringOverCal~ \u00ad @BringOverImpl.cedaPU ]] To atmly this model. \nwe need instances for the Pilot inter~a~e~, We can get them from the following model; its type is @PilotIns(ancesDecl, \nmodel. PilotInstances. model LET Inter faces@PiIot.madel IN [CIFSImpL CIFS -CIFSImpl.cedaP[, ConvertUnsafeImpk \nConverlUnsafi -ConverNJnsafeImpl. cedaP~, DateImpk Date -DaleImpl.ceda@U, --23 bindings are omitted for \nbrevity-- TTYImpl: li Y -TTYImpl.cedaFo, UserTerminalImpL UserTerminal -UserTerminalImpl. cerizP[ ] \nUsing this binding, we can compute the exported inter\u00adfaces and instances of BringOver: ~BringOver, BringOverImpl, \nBringOveiCall, BringOverCalUmpfl \u00adBringOverProc[@PilolInslances.mode~ Making the arguments explicit In \nthe previous version, we defaulted all the arguments, since the modeller can supply for each parameter \nan actual with the same name. We also omitted the types in bindings. Here is a version with everything \nwritten out explicitly. LET [Inter faces-@Pilot. model, lnstancesDecl-@PilolInslancesDecLmodel IN [BringOverProc \n-k [Instances: InszancesDecl]~ [BringOver: INTERFACE, BringOverImpL BringOver, BringOverCalL IIW?RFACE, \nBringOve&#38;allImpL BringOverCalil IN LET Interfaces+ Instances IN LET [ --These are the internal interfaces \nand instances CWR INTERFACE --@CWF.ceda#U; CWFImpL C WF -@C WFImp/.cedoP[[HeapImpl, InlineImpI, LongStringImpl, \nTimeImpI], CornParse: INTERFACE -@ComParse.cedar, ComParseImpk CornParse -@ComParseImpLceda~Ascii, CornParse, \nExec, Sromge, String, lTY, ExecImpL SlorageImpI, SwingImpl, TTYImpfl, Subr: INTERFACE -@JSubr.cedarfFile, \nSpace, Stream, n~, SubrImp~ Subr -@SubrImpLceda~Ascii, C WF, DCSFileTypes, Directory, Environment, Exec, \nFile, FileSlream, Heap, hdine, LongString, NameAndPasswordOps, Runtime, Segmenls, Space, Slream, Subr, \nSystem, TTY, CWFImpL Directory[mpl, ExecImpl, FileImpL FileStreamImpl, HeapImpI, InlineImpL LongSlringImpI, \nNameAndPasswordOpsImsd, RunlimeImpl, SegmentsImpl, SpoceImpl, StreamImpl, TTYImp~, STPSubr: INTERFACE \n-@STPSubr.ceda~File, STP, Stream, System, 7TY], STPSubrImpk STPSubr -@STPSubrImpl.ceolz~CIFS, ConverKJnsafe, \nC WF, Date, DCSFileTypes Directory, Environment Exec, File. FileSlream, Inline, LongSlring NameAndPasswordOp$ \nProces$ Space, Storage, STP, STPOPS. STPSubr, STPSubrExtra$ Slreanr. String, Subr, Tl% UserTerminal CIFSImpl \nConverlUnsafeImpl, CWFImpl, Datel~pI, DirectocvImpl Exec{mpl FileImpij FileStreamImpl, InlineImpl, LongSiringImp.! \nNameAndPasswordOpsImpl. ProcessImpl SpoceImp~ STPImpl STPOpsImpl, S~orageImpl, StreamImp~ SlringImpl \nSubrImpl UserTerminalImpil, DFSubr: lNTERFACE -@DFSubr.ceda~File, Stream TTY], DFUser: INTERFACE -@DFUser.cedat~DFSubr, \nTTfl, DFSubrImplA: DFSubr -@DFSubrImpLceda~CWE DFSubr, DFUser. Directory, Environment. Exec. Heap. Inline, \nLongString Space, STPSubr, Stream Siring. Subr. SyhiemInternai, TIZ C WFImpl. DFSubrImpl, DirecloryImpl, \nExecImpl HeapImpL Inlinelmpi, LongSlringImpl. Spacelmpl, STPSubrImpL SmeamImpl S1ringImpl, SubrImpl nYImP~. \nDFSubrImplB: DFSubr -@DFParserImpl.ceda!~C WE Date, DFSubr, Exec, LongSwing. Stream. String. Subr, Time \nC WFImpl DateImpl DFSubrImpl ExecImpi, LongStringImpi, Slreamtmpl StringImpl SubrImp~ TimeImpfl, DFSubrlmpk \nDFSubr -(DFSubrImpiA) + (DFSubrImplB) ] IN [ --These are the exported interfaces and instances BringOver: \nINTERFACE -@2BringOver.ceabr, BringOverCaIk INTERFACE -@BringOverCaii.ce&#38;@ope, ~, [BringOverImpL \nBringOver, BringOverCaiiImpL BringOverCal~ \u00ad @BrbrgOverImpi.cedar [BringOverCall, BringOverInte~ace CIFS, \nComParsc C WE Date DFSubr, Directory Exec, Fiie, FileStream KerneiFile. LongString, Rope. RopeIniine \nRuntime, Space, Stam.z STP, STPSubr, STPSubrExlms, Stream Siring. Subr, Ttie 7TLi CIFSImpl, ComParseImp/, \nCWFImpi. Daletmpl DFSubrImpl DirecloryImpl ExecImpl FiieSlreamImpl KernelFil@mpl LongS!ringImpl RurrtimeImpi. \nRopeImpi. RopeInIineImpi, SpaceImpl ,$lorageInrpi.STPImpl STPSubrImpl, STPSubrkxtrasImpl Streamimpl SmingImpi. \nSubrImpl TimeImpl lTYImp~ 1 1     \n\t\t\t", "proc_id": "567067", "abstract": "Assembling a large system from its component elements is not a simple task. An adequate notation for specifying this task must reflect the system structure, accommodate many configurations of the system and many versions as it develops, and be a suitable input to the many tools that support software development. The language described here applies the ideas of &#955;-abstraction, hierarchical naming and type-checking to this problem. Some preliminary experience with its use is also given.", "authors": [{"name": "Butler W. Lampson", "author_profile_id": "81100081662", "affiliation": "Xerox Palo Alto Research Center, Palo Alto, CA", "person_id": "PP39026299", "email_address": "", "orcid_id": ""}, {"name": "Eric E. Schmidt", "author_profile_id": "81100587631", "affiliation": "Xerox Palo Alto Research Center, Palo Alto, CA", "person_id": "PP14202952", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/567067.567090", "year": "1983", "article_id": "567090", "conference": "POPL", "title": "Practical use of a polymorphic applicative language", "url": "http://dl.acm.org/citation.cfm?id=567090"}