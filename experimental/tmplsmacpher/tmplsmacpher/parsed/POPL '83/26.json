{"article_publication_date": "01-24-1983", "fulltext": "\n Permission to make digital or hard copies of part or all of this work or personal or classroom use is \ngranted without fee provided that copies are not made or distributed for profit or commercial advantage \nand that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, \nto post on servers, or to redistribute to lists, requires prior specific permission and/or a fee. &#38;#169; \n1983 ACM 0-89791-090-7 $5.00 mechanism. Virtual patterns are descibed in section 4, Section 5 describes \nthe generalization of the virtual concept. In section 6 the remaining elements of BETA not mentioned \nin the previous sections are described. Finally the syntax of BETA is given in the appendix. Each section \nstarts with a brief introduction of the relevant language elements whereafter a number of exa\u00admples are \ngiven. Most of the examples are extended versions of Hoare s Small IntSet [Hoare 72]. There is a distinction \nbetween the base language (called basic BETA) and $tandard BETA. Standard BETA is basic BETA extended \nwith a number of commonly used constructs. These additional constructs may all be regarded as patterns \nin basic BETA, but will often be given a special syntax. This paper will mainly focus on basic BETA. \nOccasionally we shall use parts of a standard BETA, but this will be stated at the appropriate place. \n2. Basic Constructs The area of study of informatics is in.omnatz cm processes, as e.g. program executions. \nThe state of an information process at a given stage has three basic qualities: substance, the objects, \nrecords, entities etc., which then are materialized, dues that are currently measurable properties of \nthe sub\u00ad stance, and actions that are occuring at that stage. The structure of an information process \nis the restrictions on its set of possible states. Structure is imposed upon a program execution by the \nprogram, which may be regarded as a descrip\u00adtion of the structure of an information process. A program\u00adming \nlanguage must thus be able to describe the structure of substance (e.g. SIMULA s class declaration), \nmeasurable values (ALGOL s predefine types) and actions (imperative sequences, procedure declarations). \n2.1 Entities, patterns and imperatives A BETA-system (or BETA program execution) is a collection of entities, \nthe substance of the system. An entity consists of an attribute-part and an action-part. Entities execute \nactions and interacts in variuos ways. The structurean entity is described of by an associated (entity-) \ndescn@or. The association of a name, called the title, and a descriptor is called a pattern. Patterns \nmay be denoted by their title and used to generate entities that have their properties described by the \ndescriptor, A pattern declaration may have the following form: l?: pattern (f Dl; D2; . ..Dn enter <Vi, \nV2, ,.., Vv> do Il;12; . ..Im exit @l, R2, .,., R~> #)  Dl, D2. . . Dn are declarations of attributes. \nAn attribute may be either a data-item or a pattern. 11, Zz, .,., In is a sequence of imperatives (the \naction-part) that may be executed. The enter-list VI, V2, . . . . V, is a list of evaluations (see section \n2.3 below). The exit-list Rl, R2, . . . . R, is a list of evaluations. fhe enter-list corresponds to \na list of value-parameters and the exit\u00ad list corresponds to a list of result-parameters. A BETA-system\u00ad \ndescrz~tor (a BETA-pro,gram) is itself a descriptor without a name and has the form (11... enter... \ndo... exit... #) The interaction with the BETA programming system using enter/exit will not be discussed. \n 2.2 Data-items A pattern may be used to declare a data-item in the following way: E:P E is an entity \n(called an in@) generated according to the pat\u00ad tern P. Such an infixed entity is an integral part of \nthe entity (the surrounding entity) of which it is an attribute. A declaration may specify a sequence \n(an array) of infix entities, called an infix-repetition: x : [1OO]P X consists of the P-infixes X[l], \nX[2], ,.., X[1OO]. 2,3 Etduation An evaluation is a unified approach to assignment, function\u00ad call and \nprocedure call. Before the general form of an evalua\u00ad tion is presented, we shall present two special \ncases. The following example shows the use of an evaluation as an ordinary (multiple) assignment imperative. \n3+ I*J; 3 is assigned to 1 and then 1 is assigned toJ. The pattern P above may be used as a procedure \ncall in an imperative -=1, E2, !.., E,>* P* +41, A2, ,.., A5> An execution of this imperative implies \nthat El ,E2, f..., Er are evaluated and assi~ed to VI, V2, .,,, VT respectively. The sequence 11, 12, \n. . . . Zm is then executed. Fkally R1, R2, . . . . R~ are evaluated and assigned to A ~, A2, . . . . \n/l$. This use of P in an action-part implies that a P-entity (called an insertion) will be an integral \npart of the surrounding entity and executed when control reaches the insertion. The state of this P-entity \nwill be undefined prior to each execution of it. Thus no new P\u00adentity will be generated for each execution. \nThus it resembles an inline procedure call. Standard BETA will contain a number of predefine patterns \nfor commonly used data types such as Integer, Boolean, Character and Real and their operations. The patterns \n+ , , *, etc. will denote the usual operations on integers. Similarly for the other predefine patterns. \nConsider the following declara\u00adtion of Integer-entities I,J, K : Integer Procedure calls using the standard \noperations may be as follows: <1,1>* + * fi<4,J>* *,12>= + = K 2.4 Control structures As usual we shall \nuse a standard infix notation for Integer The for-t rn~eratirre has the following form: expressions: \n(for Index: Range repeat Imperative-1ist for) where Index is a name, Range is an Integer-evaluation. \nRange is evahsated prior to the execution of the for-imperative andThe general form of an evaluation \nis: determines the number of times that Imperative-list is executed. E1*E2* . ..*En Index will step through \nthe values 1, 2, . . . . Range. The scope of Index is the Imperative-fist. Index cannot be assigned to. \nwhere n >0. Each Ei is either an entity denotation (infix or pattern) or an evaluation list @l, F2, . \n. . . Fm> where each ~ is The t~-imperative has the following form: an evaluation. The execution of an \nevaluation takes place as follows: (if EO = //El then 11 El is executed, // E.2 then 12 -a ualue transfer \nfrom El to E2 is carried out, ,,. E2 is executed, //En then In if) En_ ~ is executed -a r-due transfer \nfrom En_ ~ to En is carried out, where EOT El, E2, . . . . En are evaluations. I?. is first evaluated, \nEn is executed. and that value is tested for equality with El, ~, . . . . En in an arbitrary order. If \nEO = Ej then $ may be selected for Execution of Ei means executing the action-part of Ei if Ei is an \nexecution. If one or more alternatives are selectable, then oneentity-denotation If Ei is an evaluation \nlist then it is the empty of these is chosen randomly. If no alternative may be selected,action. A value-transfer \nfrom Ei to Ei +, means assignment of the execution continues after if) . the elements of the exit-list \nof Ei to corresponding elements of the enter-list of Ez + ~, If one or both of Ei, Ei + ~ are evahsation-Eqvdty \ntest between two evaluations is carried out as follows: lists, then these lists take the place of enter/exit-lists, \nA value-Consider the evaluations E of the form Al * . . . s An and transfer from Ei to Ei + ~ is legal \nif the correspondhg elements E of the form Bl + . . . = Bm. Corresponding elements of of their enter/exit-list \nare assignable. For the predefine pat-the exit-lists of An and Bm are tested for equality. If all these \nterns, we have that Integer-entities are assignable to Integer-elements are equal then E = E . entities \netc. Note that the recursive definition of assignment means that the action-part of entities being assigned \nduring a An imperative maybe labelled value-transfer are also executed. L: Imperative Consider the following \nexample where L is a name. The scope of the label is Imperative. 1.e. lx, ly,sx,sy: Real; L may only \nbe referred to within Imperative. The execution Translate: pattern of a labelled imperative may be terminated \nby executing a (# -Z Y: Real leaue-or restart-im@eratizre within it. If leave L is executed, enter <X, \nY> the execution continues after the imperative labelled by L. If exitc X+ Lx, Y+ly> restart L is executed, \nthe execution continues at the imperative #) ; labelled by L, i.e. the execution of the labelled imperative \nis repeated. Scale: pattern Consider the following example: (# X, Y: Real enter <X, Y> L: exit < X *SX, \nY *sy > (if .... #); // then M: (*2 ) (% This is a comment, *) (for repeat (* Settirtg of lx, ly, SX, \nsy ) (if <A, B> * Translate * Scale + <A)B> // then leave L The result of evaluating Translate is passed \non to Scale and // . . then restart M if) for) the result of Scale is returned in A, B. There is thus \nno distinc\u00adtion between a procedure returning result parameters and a // ... then ...... if) (*1 *) function \nreturning a single value. An execution of leave L implies that execution continues at (*1*). An execution \nof restart M implies that-execution con\u00adtinues at (*2*) The next example defines the pattern Register, \nwhich is similar to Hoares Small IntSet: (# Regirter: pattern (# Table: [100] Integer; ToP: Integer; \n Has: pattern (# Key: Integer; Result :Boolean; enter ~ey> do False > Result; Search: (for in.x: Top \nrepeat (if (Table[irtx] = Key) 4 Result = // True then leave Search if) for) exit d?esult> #) ; Insert: \npattern (# New: Integer; enter <New > do (if ~ew>a Has = // False then Top+ 1 + Top; (if (Top < 100) \n= // True then New + Table[Top] // False then ~ Ouer-ow ) if) if) #); Remove: pattern (# Key :Integer; \nenter <Key > do Search: (for in.x: Top repeat (if (Table[iir.x] = Key) = // True then (for i : Top \nii-w repeat Table[ikx +t j= Table[ikx +i l]; for) ; Top 1= ToP; leave Search if) for) #) ; do O= ToP; \n#) ; (* end Regirter *) R: Re@ter; (% declaration of a Register-infix ) do R; (* initialize R ) <5> \n* R. Insert; (* iksert 5 into R *) + (if (<5>* R. HCW) = //true then... ~5tiin R *) if) #) The pattern \nRegister describes a category of entities. Each Register-entity consists of the attributes Table, Top, \nHas, Insert and Remove. The action part of a Register-entity is the single evaluation O * Top. Has-entities \nconsist of the attributes Key and Result. The action-part of the program consists of an execution of \nthe evaluation R, which has the effect of initializing the Register\u00adinfix R. Then the element 5 is inserted \ninto R. Attributes in entities are denoted by a dot: entity. attribute. Thus R. Insert denotes the Insert \nattribute of R. Finally it is tested if 5 is a member of R.  2.5 Singalar entities When declaring a \ndata-item or making an insertion it is pos\u00adsible to specify the entity without first declaring a pattern. \nThis corresponds to specifying the type together with a variable in PASCAL ([ PASCAI ]) and to inner \nblocks in ALGOL 60 and SIMULA 67 and the prefixed blocks of SIMULA 67. An entity specified together with \nits descriptor is called a singular entity. An entity declared by means of a pattern is called a category \ndefined entity. Consider the following example. (# (*a singular infti ) aPoint: (# X, Y: Real #) ; do \n5.0 * aPoint. X; 3.0 ~ aPoint. Y; ( a singular insertion *) (# Z: Real do ~ swdch the coordinates *) \naPoint. X- Z; aPo2nt. Y* aPoint. X; Z* aPoint. Y #) #) 3. Entity Hierarchies An entity may be given \na prefix described by a @efti-pattern or super-pattern. This specifies that the entity has all the properties \nof the prefix-pattern. A prefixed pattern is specified in the following way: Pl: pattern P (# D l; D \n2; . ..n(. (; enter <V l, V 2, . . . . V rl> do Z l; 1 2; . . ..m.; ,; exit@ (l, R 2, . . ..~.>, > #) \n; where P is the prefix-pattern of P1, P1 is also said to be a sub\u00adpattern of P. Any Pi-entity will then \nhave the same properties as P-entites in addition to those specified between (# #) , called the main-part \nof P1. A PI -entity will thus have attributes corresponding to the declarations D1, . . . . Dn and D \n1, . . . . D n(. The entry-list of a Pi-entity is Vl, . . . . V?, V ~, . . . ?7 ,,. The exit-list of \na Pi-entity is RI, . . . . R$, R l, . ..R ~. The action part of a Pi-entity is 11, . . . lm and 1 1, \n,,., I m combined by means of the inner-imperative: The execution of a PI-entity starts by execution \nof the imperative-list 11; . . . ;lm in the prefix. Each execution of an inner-imperative in this list \nimplies an execution of the imperative-list 1 ~; . ..1 ~, in the main-part. The pattern P1 is said to \nbe qualified by a pattern A if Ais Plor the prefix-pattern P of PI is qualified by A. I.e. P is qualified \nby P, P1, a possible prefix of P1, etc. Below is given some pattern declarations illustrating the use \nof sub-patterns. All Record-, Person-, Employee-, Student-, and Book-entities may be viewed as Record-entities \nand they all posses the attribute Key. Similarly Person-, Employee-, and Student-entities may be viewed \nas Person-entities and they all posses the attributes Key, Name, and Sex. Record: pattern (# Key: Integer \n#) ; Person: pattern Recovd (# Name: String; Sex: Sex Type #) ; Employee: pattern Person (# Salay:Integer; \nPosition: PositionType #) ; Student: pattern Person (# Status: StatusType #) ; Book: pattern Record (# \nAuthor: Person; Title: Title TyPe #) ; The next example illustrates the combination of action-parts. \nAmong others, this gives the possibility to construct control abstractions. Cycle: pattern (# do Loop: \n(#do inner; restart Loop #) #) ; CountCycle: pattern Cycle (# ik.x:hteger enter <inx> doiitx+l+Inx; \n inner #) An imperative (note that CountCycle (# . . #) is a singular insertion, see section 2.5) L< \nI>* CountCycle (# do (if k = //10 then leave L if) ; Imp #) will then have the same effect as: L:<l>~ \n(# in.x: Integer; enter <irrx> do .Loo~: (# do (if iitx = //10 then leave L if) ; Imp; restart Loop \n#) #) The pattern ForAll may be added as an attribute to pattern Register. It defines a control abstraction \nthat makes it possible to perform an operation upon each element in the register. ForA lk pattern (# \nCurrent: Integer; do (for hx: Top repeat Table[in,x] + Current; inner for) #) TM operation maybe used \nin the following way: R. ForAll (# do Current * DoSomething #) Current will then step through the values \nof R and each value will one by one be assigned to DoSomething. Finally we introduce some pseudo names \nthat are useful in connection with prefixing. Consider an entity E prefixed by P. Whhin the P-prefix \nof E, the entity E may be denoted by the pseudo name this P. Similarly the descriptor associated with \nE may be denoted by the pseudo name # this P. Consider the following example. 1? pattern (# (* use of \nthis P and # this P*) #) Pl: pattern P(#... #) ; R: pattern P (# #) ; A: Pl; B: P2; Within the P-prefix \nof A, this P denotes A, and # this P denotes PI. Similarly for the entity B. Prefixed classes originates \nfrom SIMULA 67. In [Vaucher 75] the concept of prefixed procedures is proposed. 4. Virtual patterns The \nvirtual concept was introduced in SIMLJLA 67, as was the subclass mechanism. A large number of languages \nhave introduced constructs based on the SIMULA class construct. However the potential of the virtual \nconcept and the subclass mechanism is frequently not exploited as it might be. (A notable exception is \nSMALLTALK). A SIMULA procedure is specified by declaring its uirtualtitle within a class declaration \nand deferring the declaration(s) of its (alternative) body (bodies) and parameters to the main part of \nsubclass declarations. In BETA the SIMULA virtual concept is generalized and is through the pattern concept \navailable for all kinds of entities, not only procedure activation records. A further stage of generalization, \nalso presented in this paper, includes the subclass mechanism as a special case. A pattern attribute \nmay be declared as virtual. This implies that only a part of the properties of the virtual pattern is \nknown and that the full specification of it may be deferred. The known properties will correspond to \na prefix of the virtual pattern. A virtual pattern may thus be viewed as a pattern parameter of the surrounding \npattern. A virtual pattern declaration has the following form: V :< A; V is declared as a virtual pattern \nwith qualfying categoy A. A is the name of a pattern. The pattern may be bound to any sub-pattern of \nA. In case that the virtual pattern is not bound then it has a default-binding, which is its qualifying \ncategory. Consider the following example: KeyMax: pattern (# Rec :< Record; M: Ret; enter -=M > do \n(if (M. Key > MaxKey) = // True then M. Key ~ MaxKey; inner if) #) The pattern Rec in KeyMax-entities \nis virtual and know to be prefixed by Record (defined in section 3). Any Ret-entity in KeyMax is then \nknown to have all the properties of Record\u00adentities. E.g. M. Key is legal since/any Record-entity has \na Key attribute. The effect is that Rec may be regarded and used as as pattern-parameter . The virtual \npattern attributes of a pattern P may be bound in sub-patterns of P. A binding of a virtual pattern may \nhave the form of a~ikal binding Either V:: Al or V:: A(#... #) Assume that this declaration appears \nin a descriptor that is prefixed by pattern P. V then must be a virtual pattern at\u00adtribute of P. Al must \nbe a pattern that is prefixed by the qualifying title of V. The binding has the effect that the pattern \nV is identical to Al (or A (# ,., #) ). Entities generated accord\u00ading to V will be Al -entities (or A \n(# #) -entities), even if the generation is specified in the prefix, Consider the following continuation \nof the previous example: PersonCount: pattern KeyMax (# Rec :: Person; do (ifM. Sex = // Male then Male \nCount + 1 * MaleCount // Female then FemaleCount i-1 ~ FerrudeCount if) #) The bind-construct in PersonCount \nrefers to the virtual pattern Rec in the prefix KeyMax. The qualifying category of Rec is Record and \nRec is bound to the pattern Person. This means that Rec is an ordinary pattern attribute in all PersonCotrnt\u00adentities, \ni.e. any Rec-entit y in a PersonCount -entity is known to be Person-entity. In the specification of the \nprefix pattern KeyMax, however, only properties of Rec specified in its Record-prefix may be assumed. \nBelow is given an example of a control abstraction using a virtual pattern. This Find pattern may be \nadded as an attribute to pattern Register. Find will search for an element identical to Key. If such \nan element is found an inner will be executed, Otherwise the entity specified according to the virtual \npattern NotFound will be executed. The predefine pattern Entity used in Not Found :< Entity is assumed \nto p-refix any $attern, thus NotFound may be bound to any pattern. (On the other hand Entit y has no \nattributes and no actions, so that no information is given about a virtual prefixed by Entity .) Find: \npattern (# Key, index: Integer; NotFound :< Entity; enter -dYey> do 1 a index; Search: (if index <Top) \n= // True then (if Table[iix] = // Key then inner,. leave Search if) ; index + 1 -index; restart Search \n// False then NotFound; if,) #) ; Find may e.g. be used to implement pattern Has: Has: pattern Find (# \nResult: Boolean; NotFound :: (#do Fake * Result #) ; do True * Result exit d?esult> #) ; In the following \nexample Register has been revised by adding two virtual pattern attributes: Content and Overflow. Pattern \nRegister may then be used to define Registers consisting of elements prefixed by Record Register: pattern \n(# Content :< Record; Ouerjlow :< Exception; Table: [100] Content; Top: Integer; Has: pattern (# Subject: \nContent; Result: Boolean; enter <Sub~ ect> do.FaLse * Result; Search: (for ikx : Top repeat (if (Table[ikx]. \nKey= Subject. Key) + Result = // True then leave Search if) for) exit <Result > #) ; Insert: pattern \n(# New: Content; enter --Wew> do (if &#38;ew>* Has = // Fake then Top+ 1 * Top; (if (Top c1OO) = // \nTrue then New + Table [To~] // False then Ouer-ow if) if) #) ; Remove: pattern ; ForA 11: pattern ; Find: \npattern ,,. ; do O+ ToP; #) ; Note that in pattern Has it is being used that Content-entities have a \nKey attribute. A Student register maybe declared in the following way StudentReg: pattern Regsiter (# \nContent :: Student; Ouerjlow :: Excefits on (# . . . . . #) ; U@iuteStatzm pattern Find (# Status: StatusType; \n NotFound :: (# . . #) enter <Status> do Status * Table[index]. Status #) #) Suppose that the pattern \nRecord in addition to Key has a pattern attribute Dkplay, to dkplay the value of Key in some form. Whhin \nRegister it would then be possible to have the register dkplayed by (for zkx: Top repeat Table[inx]. \nDzs@!ay for) Tbk will, however, only display the Key, even if the Register is a Person or Book register. \nIf the Display attribute instead is declared as a virtual pattern Record: pattern (# Key: Integer; RecDisp \npattern (# do ( dtkp.!ay the Key value *) inner#) ; Dis@zy :C RecDisp #) Then the for-imperative above \nwill have the effect that the actual binding of Dkplay is executed. A binding in Person will be Person: \npattern Record (# Name: Strzng; Sex: Sex Type; Dz s@zy :: RecDzsp (# do (* dirplay Name and Sex *) #) \n#) Ms binding of Display is fikul in the sense that Dkplay is no longer virtual, It would be desirable \nto be able to extend the specification of Display in e.g. Student and EmPloyee to get such entities displayed \ntoo. This is possible by using the further binding construct V;;<A1 The rules for using a further binding \nare the same as for using a final binding. In a further binding the specification of the virtual pattern \nV is extended to be a virtual pattern qualified by Al. V is thus still a virtual pattern and may be further \nspecified in subpatterns of the surrounding pattern. Dkplay may then be specified in the following way \nPerson: pattern Record (# Name: String; Sex: Sex Type; PersDisp: pattern RecDisp (# #) ; Disjdq :;< PersDisp; \n #) Now Display is bound to PersDisp, but it is still a virtual pat\u00adtern. A new further binding may then \nbe added in e.g. Student and Employee. 5. Generalized Virtual Patterns The use of pattern/sub-patterns \nmakes it possible to construct a broad variety of abstractions. There are however certain limitations/disadvantages \nof this approach. E.g. there is an asymmetry bet ween the use of inner and virtual patterns to construct \ncontrol abstractions. C.f. the pattern Find where if the desired element is found, inner is executed, \notherwise the virtual pattern NotFound is executed. The pattern/sub-pattern mechanism is furthermore \nnot general enough to cover all kinds of desirable abstractions, We shall elaborate on this below. In \nmost programming languages it is possible to simulate certain constructs in other programming languages. \nLet language L1 have the construct pip(x, y,z). In language L2, an application pip(al ,bl ,c1) might \nthen e.g. be simulated by the following piece of code: aal(3bl~c18, The code pieces a, ~, ~, 8 may be \nlong and if you have to include another application pip(a2, b2, b3) then you may have to repeat a, @, \n~, 6. The ideal solution would be to define an abstraction pip(x,y,z) =(2! x p y ~ z &#38; and then apply \nthk abstraction. The problem with this is that in general a, ~, -y, 6, x, y, and z may be arbitrary code\u00adsequences. \nVery few programming 1anguages allow abstraction over arbitrary code-sequences and with arbitrary parameters, \nIt is possible to make that kind of abstractions by means of a powerful macro-generator. However, you \nthen loose the advan\u00adtages of higher level languages. \\ The pattern/sub-pattern mechanism does not contain \nthk generality. Suppose that we want to construct the following control structure while Condl do Impl \non Cond2 exit L Imp2 endwhile L is supposed to be a label that is visible at that point of the control \nstructure. The meaning of thk control structure is defined by the following BETA code, which thus is \na simulation of it. (# do Loop: (if Condl = // True then Impl; (if Cond2 = // T?we then leave Loop // \nFalse then Zmp2; restart LOO* if) if) #) It is possible to make a pattern abstraction using inner and \nvirtual patterns to stand for Condl, Cond2, Impl, Imp2 and L. This is however very awkward. We shall \nnow describe a generalization of the virtual concept that makes it more con\u00advenient. 5.1 Virtual Nontermiiuzh \nThe idea is that it should be possible to parametrize a pattern with any syntactic category of the language. \nThis is made pos\u00adsible as follows: Let the syntax definition of BETA be a part of BETA and available \nfor use in BETA descriptions, and let X be a nonterminal of the BETA grammar. At any place in an entity \ndescriptor where a string derived from X may appear, it is allowed to insert a vz}tual nontermiiuzl in \nthe form named X nontermihal. A named X nonterminal has the following syntax: <nume: X > In sub-patterns \nof a given pattern it is then possible to bind the virtual nonterminals of the prefix to a string of \nthe appropriate category. The following example shows how to define the above mentioned control structure: \nWhile: pattern (# do LooP: (if < Cond: Evaluation > = // True then < PreImp: Imperative >; (if < On: \nEwrluation > = // True then leave <Exit: Label> // False then < PostImp: Imperative >; restart Loop if) \nif) #) The While pattern may then be used in the following way L: While (# Cond :: aList. Empty;[ PreImp \n:: aLrd. (k-rent = Key; On :: Key = Subject ; Exit :: L; PostImp ;; aList. Next #)  5.2 Sub-patterns \nrevisited The use of virtual nonterminals gives rise to an alternative view of the pattern/sub-pattern \nmechanism. One may abandon the usual sub-pattern mechanism in which it is possible to add new declarations, \nenter/exit -lists and imperatives. Instead this may be handled by using virtual nonterminals. In a sub-pattern \nit is then only possible to bind virtual nonterminals. Consider the following example. E pattern (# .xjy: \nInteger; @eel: Declaration> do3 *x; -==Jnner: Imperative>; SubOjl? pattern P (# Decl:: Z: Boolean; Inner:: \nx *x + x; #)  The pattern P has two virtual nonterminals, Decl and Inner, which makes it possible to \nadd new declarations and imperatives to subpatterns of P. The Find pattern may be specified in the following \nway using virtual nonterminals. Find: pattern (# Key, Index: Integer; @eel: Decimation> enter &#38;ey> \ndo 1+ Index; Search: (if (Index <Top) = // True then (if Table[Index]. Key = // Key then 4ound: Imperative>; \nleave Search; if) ; Index + 1 ~ Index; restart Search // False then c7VotFound: Imperative> ifl exit \n< <Return: Ezduztionlist > > #) ;  Pattern Has may then be specified as follows: Has: pattern Find (# \nDecl :: Result: Boolean; Found:: True > Result; NotFound:: False + Result; Return:: Result #)  5.3 \nVirtual patterns revisited A virtual pattern as described in section 4 maybe interpreted as a pattern \nwhere the main-part is given as a virtual nonterminal: V: pattern A W: Main-part> V is a pattern where \nonly the prefix-pattern has been specified. The main-part may then later be specified in subpatterns \nof the surrounding pattern. A binding of V may then be specified as M:: (#,... #) This is however not \nenough to cover all possibilities of the vir\u00adtual concept in section 4, Here it is possible to specify \nbindings using names of other patterns, and some structural rules must be obeyed. E.g. v:: .41 (or V \n::< Al) cannot be expressed using virtual nonterminals. It is however only a technical matter to decide \nwhether to keep the virtual concept of section 4, or to introduce a notation for referring to the main-part \nof a pattern, like M :: <A 1. Main-part >  5.4 Virtual lists The BETA if-imperative is similar to the \nguarded if-command in [Dijkstra 75]. Suppose that one wants to define a control\u00adabstraction similar to \nthe guarded do-command. In order to do thk, it is necessary to be able to define a list of virtual nonterminals, \nsince such an abstraction must be parametrized by a list of alternatives, This can done by means of a \nviitual-lrit of the form { 6 }i-list{ ~ } The iist is indexed by i. 6 and ~ are arbitrary BETA language \nelements. Thestring 6maycontain zero ormoreindexedwktWi nonterrniizak of the form < name(i): X>. Suppose \nthat 6 has the form ty <name(~: X> (j where CYand/3 again are arbitrary BETA elements. The virtual\u00adlist \nthen stands for a <name(l): X> fi y a <name(2): X> (1 y Y cy <nume(n): X > /3 The construct may appear \nin a BETA descriptor at any place where a string derivable from a! <x> O -y...y a <x> (3 is legal. The \nindexed virtuals in a virtual-list may be bound in sub\u00adpatterns of the surrounding pattern. We may now \nspecify an abstraction similar to the guarded do\u00adcommand. NyGuard: pattern (# do Loop: (if Tme = { //< \nCond((): Ewluation > then < Command(~: Imperative>; restart Loop } i-list{} if) #)  Pattern NyGuard \nmaybe used in the following way NyGuard (# Cond(l) :: N >0 ; Command(1) ;: Impl ; Cond(2) :: N = O ; \nCommand(2) :: Im@2; Cond(3) :: N <0 ; Command(3) :: Imp3; #) 6. Other Elements of BETA 6.1 Scope rules \nand vsiibility The scope rules of BETA are ALGOL 60 like with respect to visibility of global names. \nFrom an entity E all global names are thus visible. In addhion there is a rule in connection with remote \nacces. k is only possible to go one level down in the static nesting using remote acces. This means that \nthe attributes of entities at the same level as E are accessible, while attributes of entities internal \nto these are inaccessible, Consider the following example (# 11: Integer; PI: pattern (# 12: Zntege~ \n#) ; P2: pattern (# D: Integer; 14: Pl; 15: (# 16: Integer #) 17: P3; P?: pattern (# 18: Integer #) (*at \nthti point the following*) (* remote names are legal: ) ( 14.12, 15.16, 17.18 ) #) ; E: l+; ~ at this \npoint the following *) ( remote names are legal: *) ~ E.13,E.14,E.15,E.17, ) .  ( E. P3 and E. 14.12 \n) #) Note e.g. the difference between the entities E. 14 and E. 17. E. 14 is at the same level as E \nwhereas E. 17 is internal to E. The Table and Top attributes of pattern Register may be protected from \nremote acces by declaring Register in the fol\u00adlowing way: Register: pattern (# Private: (# Table: [100]Record; \nTop: Integer #) ; ( rodhin Register Table and Top may now be ) ( denoted by Pnkzte. Table and Prizrzte. \nTop, *) ( but not from outside by e.g. R. Prti.kzte. Top ) #) The scope rules for prefixing are similar \nto those in SIMULA 67. I.e. within the main-part of a descriptor, names declared in the main-part overrides \nnames declared in the prefix, which again overrides globally declared names. The above mentioned rule \nconcerning remote-access is inter\u00adpreted in the following way: Let E. X be a remote name and let D be \nthe descriptor of E. X. If D has a prefix-pattern declared outside E, then the names in this prefix may \nbe accessed using remote-access. Consider the following example: (# Pl: pattern (# II :Integer #) ; E \n(# P2: pattern P1 (# 12: Integer #) ; X: P2 (# 13: Integer #) #) ; (*at this #oint E. X. 11 is legal, \n) (* since P1 is declared outside E, ( but E. X. 12 and E. X. D are not legal, ~ ( since P2 and the rnnin-part \nof X are *) ~ declared internul to E )  #) X and an anonymous one generated during the evaluation by \nIn [BETA c] an alternative method for protecting attributes have been proposed. This method is general \nin the sense that attribute protection is not a part of the language but a feature of the programming \nsystem. 1.e. the language is made simpler on behalf of the programming system. 6.2 Dynamic entities \nThe infix-entities and insertion-entities described in the previous sections are static in the sense \nthat they are generated at the same time as and as a permanent, inseparable part of the entity in which \nthey are declared. It is possible to generate entities dynamically during a program execution. The following \ndeclaration specify data-items, which are references to such entities: x, Y:#P P is the qualification \nof the references. It specifies that X and Y may denote (refer to ) a P-entity, a sub-entity of P (see \nsection 3) or NONE, which means no entity. A reference is thus similar to a reference in SIMULA 67. A \nP-entity may be generated by the imperative instance P, An entity generated in this way is called an \nih.starzce. A reference may be given a value in the following way: instance P @> X (Q?> Y; (*a P-entity \nis generated and denoted by X and Y ) instance P @> X ; ( another P-entity is generated and denoted by \nX *) The @> specifies that a reference transfer is carried out. The transfer operators a and @> are \nthus similar to : = and :-in SIMULA 67, References may appear in enter/exit lists, An entity denoted \nby a reference may be executed by using the dot-operator (. ) and appear in evaluations. Ckmsider (# \nPI pattern (# IJ: Integer enter c I,J> do I +J=Iexit<IJ> #); E: P; (* declaration of an infix *) X: #P; \n( declaration of reference ) N, M: Integer; do ( generation of a P-ik.rtance denoted by x *) instance \nP (@ X ; ( an ewlwtion involving infti-*) ( insertion. and irutance.entities *) <3,4> +E+P *E* instancep. \n= X. * P * <N, M>; #)  The above evaluation involves two executions of the infix E, execution of two \ndifferent insertions (specified by the two Ps), and execution of two different instances (the one denoted \nby instance P). An evaluation of the form instance P. is similar to a procedure call in ALGOL 60. References \nmay be compared in an if-imperative of the follow\u00ad ing form: (i fX@//Y then.... // NONE then . . ..if) \n I.e. = and @ are similar to = and = = in SIMULA 67 To sum up, entities may so far be generated in three \ndifferent ways: AS a statically allocated data-item, called an infix As a statically allocated action, \ncalled an insertion. As a dynamically allocated data-item or action, called an instance. We have mentioned \nthe similarities between insertions and in\u00adline procedure calls and instances and ALGOL-like procedure \nactivation records. We also note that an infix may be used as a static subroutine. In addition another \nkind of entity called an object may be generated. Objects are carriers of individual action sequences. \nSee also section 6.4. 6.3 Assi~ment In the above examples we have assumed that assignment is defined \nas an operation on all sub-entities of Record. It is however necessary to explicitly specify if assignment \nis defined on a given category of entities. We say that a pattern T is sel~\u00adassignable if for all T-entities \nX, Y the evaluation X = Y is legal. In the following we shall thus dkcuss the possibilities of defining \nself-assignable patterns. As demonstrated by Tennent, [Tennent 77], the assignment operation presents \na series of difficult and important prob\u00adlems, Tennent introduces the notion of the re@esentation type \nof a data type and three constructs for defining new types: class, data and index, A new data type may \ninherit operations from its representation type. E.g. a new data type may inherit assignment from its \nrepresentation type if assignment of the new data type is defined as assignment of its representation. \nT~es defined by class inherits no operations from the represen\u00adtation type. Types defined by data inherits \nassignment and consequently assignment must be defined on the representation type. Types defined by index \nmust have the usual relational operations defined on the representation type and the new type inherits \nthese. A limited @n iate type in Ada [Ada] corresponds to class and a @ @e tYfle to data, but in addition \nequality is defined. A more elaborate hierarchy of types may be used to specify the properties of type \nparameters in Ada s generics. In some situations it is not meaningful that assignment of a data type \nis just an assignment of the representation type, It is then necessary that the meaning of assignment \nis defined explicitly. With Tennents class and Ada s limited private it is necessary to define assignment \nas any other operation on the new type. Such types may be used as parameters of parameterized data types \n(or generics in Ada). In addition to the type parameter it is necessary to specify a parameter for each \ndesired operation of the type. When instantiating a parameterized type, the actual type and operations \nof the type must then be specified. It would be desirable to be able to include new elements consisting \nof types with certain operations in the hierarchy. If assignment is defined explicitly then it is not \npossible in Ada to use the usual assignment syntax since assignment cannot be overloaded. An alternative \nto copying is to let variables be references to entities. Thk is e.g. used in CLU ([CLU 77]) and Smalltalk \nand possible in SIMULA 67 using ref. This is also possible in BETA as described above. However, thk approach \nhas all the problems of sharing. In [BETA a,b] the possibility of an addkional zulue-clause has been \nproposed. The purpose of this clause should be to define the notion of a P-value associated with a pattern \nP. Tlis approach is however not presently acceptable and will not be described here. Below we describe \nthe current BETA approach to assignment. It is intermediate between copying of the representation and \nexplicitly defining the assignment. As it may appear from the description of enter/exit-parts and evaluations \nin section 2, it is possible to define a value-transfer between entities using these constructs. If the \nexit-list of an entity is assignable to the entry-list of the entity, then assigrr\u00adment is defined between \nsuch entities. Consider the following example Point: pattern (# Local: (#X, Y: real #); enter <Local. \nX, Local. Y> exit < Local. X, Local. Y>; #) ; A, B: Point; A-and B-entities may now be assigned by the \n= operator and X an Y are protected from remote-access. The problem with this method, is the possibility \nof using knowledge of the representation of a given data-type. It is possible to encode values through \nthe entry-list and similar to decode values from the exit-list as shown by the following example: In \norder to avoid thk, it is possible to define restrictions upon the predecessor and/or successor of a \ngiven entity in an evalua\u00adtion. This can be achieved by means of enter/exit crztegon es. The enter-category \nof an entity limits the predecessor of an entity to be one that is qualified by the enter-category. Similarly \nfor the exit-category. A pattern with enter/exit categories has the following form: R pattern (# from \nA enter <.,. > do to Befit<.,.> #) where A (called the enter-catego~) and B (called the exit\u00adcategory) \nare names of patterns or the pseudo name # this T (see section 3). The meaning of A and B are: Let E \nbe a T\u00adentity. Then Any A-entity must be assignable to E. Only A-entities may be assigned to E. E must \nbe assignable to B-entities. E may only be assigned to B-entities. I.e, is legal if and only X is an \nA-entity and Y is a B-entity. Possible enter/exit-categories in the main-part of a prefixed pattern may \nfurther restrict the the possible enter/exit-catego\u00adries specified in the prefix-pattern. The enter-category \n(exit\u00adcategory) specified in the main-part must be qualified by the enter-category (exit -category) of \nthe prefix-pattern. The following example shows the use of enter/exit-categories: lx, ly,sx,sy: real; \nTranslate: pattern (# X, Y: real enter <X, Y> to Scale exit< X + lx, Y+ ly > #) ; Scale: pattern (# \nX, Y: real from Translate enter <X, Y> exit < X *SX, Y*sy > #) ; (* setting of lx, ly, sx, sy *) <A, \nB> =S Translate * Scale a <A, B> Translate-entities can now only be assigned to Scale-entities and Scale-entities \ncan only be assigned from Translate-entities. We may now define the pattern Point in the following way: \nPoint: pattern (# Local: (#X, Y: real #) from Point enter <Local. X, Local. Y> to Point exit <Local. \nX, Local. Y> #) ; The use of the pseudo name # this T (see section 3) makes it possible to specify a \npattern such that any sub-pattern of it is self-assignable. Consider a redefinition of the pattern Record \nof section 4. Record pattern (# Key: Integer; from # this Record enter< Key> to # this Record exit< Key> \n#) Pattern Record is self-assignable. In addition any sub-pattern of Record must be self-assignable \nin order to satisfy the enter/\u00ad exit -type specification. This is the e.g. the case with the pat\u00adtern \nPerson below, provided that String and SexType are self\u00adassignable. Person: pattern Record (# Name: String; \nSex: Sex Type enter <Name, Sex > exit <Name, Sex> #) In order that pattern Register of section 4 is \nlegal it is thus necessary that pattern Record is defined in the above way. 6.4 Concurrent @ocessing \nin BETA It is possible to specify concurrent execution of entities. Such entities are called o bj ects. \nA data-item may be an object or a reference to an object. Objects may communicate by means of the request-and \naccept-imperatives, which specify synchronized execution of remote-entities. Execution of a remote -entit \ny is similar to a remote procedure call in SIMULA, but the execu\u00adtion must be synchronized, like in CSP \n[Hoare 77] and Ada. However, nondeterminsm is handled by means of interleaved execution of objects , \nand not handled by means of guarded commands like in CSP and Ada. For a further description of concurrent \nprocessing in BETA see [BETA b]. 7. References [ADA] ADA Reference Manual. Proposed Standard Document, \nUnited States Department of Defense, July 1980. [ALGOL] P. Naur (cd.): Revised Report on The Algorithmic \nLunguage ALGOL 60, Regnecentralen. Copenhagen, 1962. [ BETA a] B,B, Krktensen, O.L. Madsen, B. MOller-Pedersen, \nK. Nygaard: BETA Project Working Notes 1-8. Nor\u00adwegian Computing Center, Oslo, Computer Science De\u00adpartment, \nAarhus University, Aarhus, 1976-1982. [BETA b] B.B, Kristensen, O,L. Madsen, B. Moller-Pedersen, K. \nNygaard: A Suroey of the BETA Programming Language, Norweigan Computing Center, Oslo, 1981. [BETA c] \nB.B Kristensen, O.L Madsen, B. Moller-Pedersen, K. Nygaard: Syntax Directed Program Modularization, In: \nInteractive Computing Systems (cd. P. Degano, E. Sandewal), Nort-HolIand, 1982.  [CLU] B. Liskov, A. \nSnyder, R. Atkinson, C. Schaffert: Ab\u00adstraction Mechanisms in CLU. Comm ACM 20, 8 (1977), 564-576. [DELTA \na] E. Holbaek Hansen, P. Haandlykken, K. Nygaard: System Descrt$tion and the DELTA Language, Norwei\u00adgan \nComputing Center, Oslo, 1975. [DELTA b] P, Haandlykken, K. Nygaard: The DELTA System Descrt$tion Language: \nMotizxztion, Main Concepts and Expeirence from use. In: Software Engineering Environ\u00adments (cd. H. Hunke), \nGMD, North-Holland, 1981. [ Dijkstra] E. W. Dijkstra: Guarded Commands, Nondeterm \u00adnacy, and Formal Derimtion \nof Programs COmm. ACM 18, 8 (1975), 1-82. [Hoare a] C. A. R. Hoare: Proof of Correctness of Data Representation \nActs Informatica 4 (1972), 271-281, [Hoare b] C. A. R. Hoare: Communicating Sequential Proces\u00adses . Corn. \nACM 21, 8 (1978), 666-677. [PASCAL ] N. Wirth: The Programming Language PASCAL Acts Informatica 1 (1971), \n35-63. [SIMULA] O.-J. Dahl, B. Myrhaug, K. Nygaard: SZMULA 67, Common Base Language. Norweigan Computing \nCenter, Oslo, 1970. [SMALLTALK] The Xerox Learning Research Group: Col\u00adlection of articles on SMALL TALK-80. \nBYTE, August 1981. [Tennent] R. D. Tennent: On a New Approach to Represen\u00adtation Independent Data Classes \nActs Informatica (1977), 315-324. [Vaucher] J. Vaucher: Prefixed Procedures: A Stracturzizg Concept for \nOperations Infor, vol. 13, no. 3, October 1975. Appendix. BETA Grammar In this appendix the contex-free \ngrammar of BETA is given. The whole grammar is given despite that only sequential BETA has been described \nin this paper. The purpose is to give an impression of the total size of basic BETA. The notation for \ndescribing the gramar is an extended BNF notation. A production may have an optional label of the form \n: erame> which may be viewed as a comment, Within a right-side of a production the following addkional \nmetasymbols are used: list, W*, {,and }, which have the following meaning. The construct <A>::= ~{w~zl... \nDn}l means <A>:: =CY(3171Cr /3271... Iapny The construct <A>:: =a{(3}kst{~}(3 means <A>:: =a(381a~y~ \n81..., The construct <A>:: =ct{(3}ltit*{y)6 means <A>::= <empty> Icf { ~ }list{ y } 6 The construct \n<A>:: =cro@t{/3}y means <A>:: =aTlcY/3y The following productions relate to concurrent and co-sequential \n(interleaved) execution of objects: ObjDecl, ObjRef, Request, Accept, With, Concurrent, Co-sequential \nand ObjectGen. The remaining productions have with few exceptions been described in the previous sections. \nThis paper should however not be regarded as a complete definition of (even sequential) BETA. Entities \nand patterns cBETA-system-descriptor> :: = centity-descriptor> :SYsDesc centity-descriptor> :: = cprefix> \n<main-part> :Descriptor <main-part> :: = (# <attribute-part> <action-part> #) :MainPart <entity-specification> \n:: = <entity-descriptor> I <pattern-denotation> Preftiing cpreflx> :: = <empty> :NoPrefix [ <pattern-denotation> \n:Prefix I ( <prefix-decl> : <jxzttern-denotation> ) :NamedPrefix Attn butes <attribute-part > ::= { \n<data-item-declaration> I <pattern-declaration> }Ust { ; } Data-item-declaration cdata-item-declaration> \n:: = <name-list> : <data-specification> :Simple I <name-list>: [<index> ]<data-specification> :Repetition \n<index> :: = <integer-evaluation> :NoIndex I <index-decl> : <integer-evaluation> :Index <data-specification> \n:: = <entity-specification> :InfixDecl I # <pattern-dtmpotation> :InstanceRef <data-specification> :: \n= object @ <entity-specification> :ObjDecl I object # <pattern-denotation> :ObjRef Pattern-declarations \n<pattern-declaration> :: = <pattern-decl> : pattern <entity-descriptor> :PattemDecl I <~ir-tual-decl> \n:<-<Patters--denotation> :VirtualDecl I <virtual-zrppl> :: <entity-specification> :FinalBind I <virtual-appl> \n::< cfiattem-denotation> :FurtherBind Action-part <action-part> :: = opt{ <enter-part> } opt { <with-part> \n} opt{do <imperative-list> } opt { <exit-part> } :ActionPart Enter-and exit-part <enter-part> :: = opt \n{from <fiattern-denot ation> }enter <transfer> :Enter <exit-part> :: = opt{to<fxzttem-denotation> } \nexit ctransfer> :Exit <transfer> :: = < <evaluation-list> > : LktTrans Imperatives <imperative-list> \n:: = { <label> <imperative> }&#38;t*{ ; } <label> :: = <empty> :NoLabel I <label-decl> : :Label <imperative> \n:: = (for <index> repeat <imperative-list> for) :ForImp <imperative> :: = (if <evaluation> <equality-kind> \n{ <selection> then cimperative-list>} ltit{ } if) :SelectionImp ..= <equality-kind> .. :ValueEq :SubstEq \nl; :DescEq1# <selection> :: = { //<evaluation> }ltit{ } :Case List I // is <Pattern-denotation> :IsCase \n// in <@ttem-denotation> :InCase <imperative> :: = restart <label-appl> :Restart Imp I leave <label-appl> \n: LeaveImp <imperative> :: = inner :InnerImp Communication- imperatives <request> :: = <ob~ ect-denotation> \n! <infix-denotation> :Request <imperative> :: = ? <infix-denotation> :Accept <with-part> :: = with { \n<ob~ ect-denotation> I some <Pattern-denotation>} :Whh Object execution-imperatives <imperative> :: = \n(concurrent <object-list> concurrent ) :Concurrent I (attached <object-list> attached) :Co-sequential \ncobject-list> :: = { <object-denotation> } list{ // } Eruluation <imperative> :: = <evaluation> <evaluation> \n:: = { <transaction> }kst {} <transfer-quality> :Evaluation <transfer-quality> ..== :ValueTrans   \nl (@ :SubstTrans ctransaction> :: = <infix denotation> : InfixEva] <entity-specification> : Insertion \n< <evaluation-list> > :ActionLkt <instance -reference> . :InstanceEval <request > I <reference> <evaluation-list> \n::= { <evaluation> }krt{ , } I <re~etition-denotation> <reference> :: = none :None I <reference-denotation> \ninstance <entity-specification> :InstanceGen ~ object <entity-specification> :ObjectGcn Denotations \nNonterminals like <denotation> and <name> are often used in the form <T-denotation> and <T-name>, where \nT is a qualification of the denotation or name. E.g. <~attern-denota\u00adtion> is a denotation of a pattern-attribute, \n<a!uta-item-name > is the name of a data-item. However these rules are all informal. <denotation> :: \n= {<data-item-name> }list { .}<attn bute-name> <name> :: = <name-appl> I <re@tition-narne-appl> [<integer-evaluation> \n] <name-list> ::= { <name-decl> } list {,} For all N in { prefix, infix, instance, object, objectref, \nlabel, index, title, virtual, system}, there are rules: <N-decl> :: = <name-decl> <N-appl> :: = <name-appl> \n<name-decl> :: = <identifier> <name-appl> :: = <identifier> \n\t\t\t", "proc_id": "567067", "abstract": "<p>The BETA programming language is developed as part of the BETAproject. The purpose of this project is to develop concepts,constructs and tools in the field of programming and programminglanguages. BETA has been developed from 1975 on and the variousstages of the language are documented in [BETA a].</p><p>The application area of BETA is programming of embedded as wellas distributed computing systems. For this reason a major goal hasbeen to develop constructs that may be efficiently implemented.Furthermore the BETA language is intended to have a few number ofbasic but general constructs. It is then necessary that theabstraction mechanisms are powerful in order to define morespecialized constructs.</p><p>BETA is an <i>object oriented</i> language like SIMULA 67([SIMULA]) and SMALLTALK ([SMALLTALK]). By this is meant that aconstruct like the SIMULA class/subclass mechanism is fundamentalin BETA. In contrast to SMALLTALK, BETA is a language in the ALGOL60 ([ALGOL]) family.</p><p>SIMULA 67 is a system description and a programming language.The DELTA language ([DELTA]) is a system description language only,allowing description of full concurrency, continuous change andcomponent interaction, developed from a SIMULA conceptual platform.BETA started from the system concepts of DELTA, but is aprogramming language, drawing upon a large number of contributionsto programming research in the 1970s. A basic idea in BETA is tobuild the language upon one, general abstraction mechanism --- the<i>pattern</i> ([BETA a 77]) --- covering both data, procedural andcontrol abstractions, substituting constructs like class,procedure, function and type.</p><p>Correspondingly objects, procedure activation records andvariables are all regarded as special cases of the basic buildingblock of program executions: the <i>entity.</i> A pattern thusdescribes a category of entities with identical <i>structure.</i>An entity consists of a set of <i>attributes</i> and an<i>action-part.</i> An attribute may be a <i>data-item</i> or apattern. The action-part is a sequence of imperatives that may beexecuted.</p><p>A <i>data-item</i> may be an entity or a reference to an entity.A pattern may be used in a procedure like manner in the sense thatan entity (procedure activation record) described by the patternmay be generated and executed as a part of the action sequence ofanother entity. A pattern may be used to generate entities thatexecute their action-part in concurrency with other entities. Suchentities may also execute their actions interleaved in a coroutinelike manner.</p><p>Entities may be organized hierarcically by means of ageneralization of the SIMULA subclass mechanism. This givespossibilities for grouping common properties of entities ofdifferent patterns.</p><p>In SIMULA 67 a class may have <i>virtual</i> attributes(procedures, labels, and switches). This is a powerful parametermechanism that gives the possibility to delay the specification ofan attribute to a subclass specification. However, SIMULA 67 lacksthe possibility to have virtual class attributes. Furthermore it isnecessary to have a runtime check on the parameters of virtualprocedures, since it is not possible to specify the parameter listof a virtual procedure. The virtual patterns of BETA is ageneralization of the virtual concept in SIMULA 67.</p><p>In this paper the sequential part of BETA will be presented. Themain purpose is to demonstrate the use of the pattern/subpatternmechanism with virtual patterns as a powerful abstractionmechanism. In addition, a further generalization of the virtualconcept based on <i>syntactic categories</i> will be described.</p><p>Work has been initiated to design and implement an integratedprogramming system for BETA. The approach to <i>separatecompilation</i> of BETA modules is described in [BETA c].</p><p>This paper is organised as follows: Section 2 describesentities, patterns and imperatives. Section 3 describes thesubpattern mechanism. Virtual patterns are described in section 4.Section 5 describes the generalization of the virtual concept. Insection 6 the remaining elements of BETA not mentioned in theprevious sections are described. Finally the syntax of BETA isgiven in the appendix. Each section with a brief introduction ofthe relevant language elements whereafter a number of examples aregiven. Most of the examples are extended versions of Hoare'sSmallIntSet [Hoare 72].</p><p>There is a distinction between the base language (called<i>basic</i> BETA) and <i>standard</i> BETA. Standard BETA is basicBETA extended with a number of commonly used constructs. Theseadditional constructs may all be regarded as patterns in basicBETA, but will often be given a special syntax. This paper willmainly focus on basic BETA. Occasionally we shall use parts of astandard BETA, but this will be stated at the appropiate place.</p>", "authors": [{"name": "Bent Bruun Kristensen", "author_profile_id": "81100073755", "affiliation": "Aalborg University Center, Aalborg, Denmark", "person_id": "P29079", "email_address": "", "orcid_id": ""}, {"name": "Ole Lehrmann Madsen", "author_profile_id": "81100506035", "affiliation": "Aarhus University, Aarhus, Denmark", "person_id": "PP14176537", "email_address": "", "orcid_id": ""}, {"name": "Birger M&#248;ller-Pedersen", "author_profile_id": "81100622129", "affiliation": "Norwegian Computing Center, Oslo, Norway", "person_id": "P30797", "email_address": "", "orcid_id": ""}, {"name": "Kristen Nygaard", "author_profile_id": "81100392381", "affiliation": "Norwegian Computing Center, Oslo, Norway", "person_id": "PP39040761", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/567067.567094", "year": "1983", "article_id": "567094", "conference": "POPL", "title": "Abstraction mechanisms in the BETA programming language", "url": "http://dl.acm.org/citation.cfm?id=567094"}