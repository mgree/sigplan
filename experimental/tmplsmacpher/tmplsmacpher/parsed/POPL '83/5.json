{"article_publication_date": "01-24-1983", "fulltext": "\n Permission to make digital or hard copies of part or all of this work or personal or classroom use is \ngranted without fee provided that copies are not made or distributed for profit or commercial advantage \nand that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, \nto post on servers, or to redistribute to lists, requires prior specific permission and/or a fee. &#38;#169; \n1983 ACM 0-89791-090-7 $5.00 As an artificial example, if wc take the natural numbers as our f universe \nof scalarsand Ict ~ be the successor function, then u ~ v = (u~ vA Z~[U, V)). As a more motivating example, \nlet the domain of scalars be the set of addresses of data records in some pool of memory. Suppose that \neach dab record contains a liok field, whose value is the address of some other record in the pool. Given \nan address w define ~(u) to be the address contained in the link field of the record whose address f \n is u. Then u ~ v means that the record (whose address is) v can be reached from the record (whose address \nis) u by following some number (possibly zero) of links, without ever following the link of the record \n(whose address is) z. If the first field of some record (whose address is) u is overwritten with the \nvalue v, the effect is to change f to j ~), where, for any (W) is tie function that satisfiesfunction \n~ and scalars u and v, ~ . That is, ~ ~) agrees with ~ except at u, where it has the value v. A final \ndefinition: we write P: where P is a predicate, z is a variable, and tis a term, to denote the predicate \nthat says about t whatever P says about z. If P is given by a first-order formula, p: is given by the \nresult of substituting tfor all free occurrences of z in P. (Provided, that is, that z is free for t \nin F .) An expression fike P~$ denotes the simultaneous substitution of t and sc for x and y; successive \nsubstitution would be denoted by (P~)\\. Questions about the reachability predicate may be settled by \n appealing to its definition and using mathematical induction, but this is often tedious, since induction \nis such an elementary principle. So, our strategy is to identify a small number of fundamental properties \nof the predicate that can bc used as axioms for subsequent reasoning. Induction arguments arc required \nto verify the axioms, but can be dispensed with thereafter. Eight axioms suffice for all the proofs described \nin this paper. Perhaps they are a complete axiomatization of the predicate, but this is an open question. \nThe axioms are: (Al) (Wc will leave out universal quantifiers from displayed formulas when it is obvious \nchat they are meant to be generally valid, rather than statcmmrts about some particular values of their \nvariables.) The notational liberties taken in A3, A5, and A8 will be explained later. The remainder of \nthis section verifies the axioms in order, and describes some of their elementary consequences. In presenting \nthe proofs oftfre axioms we will use the notation ~< (u) #vasshorthand for(Vm: m<n:fm(u) #v). Using this \nnotation, theproof of Al is: / u~v = (an:: ~n(u) = v A ~<n(u) # Z) ={sincen=OVrz>O} U= VV(3n:n>O:fn(U)=VA \nj< (u) #z) = {writing m for n 1} u= vV(3m ::fm(j(u)) = vAu# xAj<m(~(u)) # z) =u=v V(u#z A~(u)~V) I (When \npossible wc will lay out a proof as a chain of equalities between predicates, with any required justifications \ncut off by braces. For a theorem of the form P a Q, the chain may contain implications as well as equalities. \nSome librrties will be taken with precedence, since the layout makes it obvious which = signs are links \nin the chain and which are parts of the chainees.) There are two simple consequences of Al worth noting: \nf u~u +=(u=v) Both proofs arc immediate. (Some readers may be surprised that Al is not by itself a \ncomplete axiomatization for +, since it seems to contain all the information needed to compute the truth \nvalue of u ~f v by a recursive computation involving ~(u). The trouble is that if this recursive f computation \nloops, Al does not determine u ~ v. For a concrete example of a model in which Al is true but (for example) \nA2 is false, let u, v, and w be distinct scalars and let j be the only non-scalar. Let~(u) = u,j(v) = \nv,andf(w) = w. Define z~ ytobetrue whenever z = y, or (z, y, z) = (u, v, w), or (z, y, z) = (v, VJ,VJ), \nand false in all other cases. Then Al is satisfied but A2 is false, since u~ v and v~ waretie, but u~ \nwisfalse.) The proof of A2 is ff u;v Av~w = (3n, m ::j (u) = v A j< (u) # z ,A jm(V) = wAf<m(V) # Z) \n=+ (3 n, m :: ~m(.fn(u)) = w A ~<n(u) # z A ~<m(~ (u)) # z) =u~wf ~ We define u ~ v to be u -$ v. Axiom \nA3 therefore says that it is not necessary to pass through v in order to reach v. Its proof is: = (37?:: \njn(7J) = v A ~<n(U) # Z) =$(3n ::f~(u) = v) = {induction} (3J :: jn(U) = v A ~<n(u) # v) =u~v = {definition} \nUJ+V ~ For n > 1 wc define u xl,. ~., ~n ~v to be the conjunction ff u ~ v A . . . A u ~ v. From these \ndefinitions it foilows that . f f,V u bv+u Xo>...,xfl Z19. ..1G isvalid for n ~ O. Al and A2 between \nthem say tiat the prcdicatc ? ~ ? is reflexive and transitive. But it is not an order relation, since \nwc may have ff u ~ v and v ~ u for distinct u and v, in the presence of circular lists. This lack of \norderliness makes the predicate ?~ 7 somewhat unmanageable, and it is generally prcfcrablc to focus on \nthe predicate u ~ ?, which, as we shall see, is better behaved. For fixed u and ~ we can read u ~ z as \nz occurs at least as soon as y (in u, j(u), . . . . this requires that z occur, but not that y occur). \nAxiom A4 says that the predicate u =$? is transitive: if z occurs at least as soon as y which occurs \nat least as soon as z, then z occurs at least as soon as 2. Its proof is ff u~xAu~y = (~n, ?n :: f (u) \n= z A f< (u) # y A ~w(u) = u A j<m(u) # Z) + {m > n, hence f<m(u) # z =+ f< (u) # Z} (~n,tn :: fn(u) \n= .2 A f<n(u) # Z) f =u~x ~ Axiom A5 says that the relation u ~ ? is almost total in that it relates \neither (z, y) or (y, z); the only proviso is that one of z, y must be reachable from u: if either are \nreachable, one occurs at least as soon as the other. Since A5 is symmetric in z and y; it suffices to \nprove that the consequent holds if u ~ z: f U+z = (372:: j (u) = z A f<n(U) # Z) = {either ~<n(u) # y \nor 3rn :: m < n : ~m(u) = y} ( (an:: f (u) = z A j<n(U) # Z A f<n(U) # y) v (3n, rrc:rn<n:fn(u)=z A \nj< (u)#z A fro(u)= y)) +U+zvu$y B One consequence of A5 is the important ff f u~vAv*w=+u*w (Ll) Note \nthat L1 does not follow ~ directly from A2, We will prove f it by contradiction; assume u -+ v and v \n-w; then -.U+wf ff =+ {V4W, A2}7U3V a {u&#38; A5}u+w U+ul =${A3} f E Another consequence of A5 is the \noccasionally useful f ff u*vATu~w~u~ V (L2) That is, if v is reachable and w isn t, then v is reachable \nwithout using w. The proof of L2 is: ff U-+ VA TU-+W + {A5}(u~v VU$W)An UL w . (u$v A_Iu~w) V(U~WA_IULW) \n. {A3}(u~v AAu~vJ)V1 U;vf m + The next axiom, A6, connects the two relations ~ ? and ?--t ?. It says \nthat if, starting from u, z occurs at least as soon as y which occurs at least as soon as z; then y is \nreachable from z without passing through z. Its proof is very much like A4 s: ff u~x/fu~g = (3n, rn ,, \nf (u) = z A ~< (u) # y A jm(u) = Y A f< -n(fn(u)) # Z) *{since m>n, m n>O} (3n, m :: j (u) = z A fm-n(f \n(ri)) == y A j<m(U) # Z) +(an, rrz::.f - (z) = y A f<m-n(x) # Z) f =z~y E An important consequence of \nA6 is f u~vAu~wqv=w f (L3) For, assuming the antecedent, we conclude from A6~~V that ,V ~ w, hence, by \nAl, v = w. From A4, A5, and L3 it follows that the predicate u -$+? is transitive, almost total, and \nanti-symmetric; thus it is a total order on the set of clcmcnts reachable from u. Axiom A7 says that \nto reach v from f(u), it does not help to pass through u. This is obvious, since passing through u returns \nto the starting point j(u). The proof is f(u) -L v = (~ n :: fn(f(U)) = v A f< (f(U)) # V) = (~n :: \nfn+ (u) = v A (Vm : m < n : fro+ (u) # jn+ (U))) = (~rz :: f + (u) = v A (Vm : m < n : fro+ (u) # fm+ \n(~ -m(u)))) =?(3n ::fn+l(u) = vA(Vrn :m < n:u # f m(u))) =(3 ??:: fn(f(u)) = v A f (f(u))+ U) = f(u) \n$ v The other half of A7 follows from A3. s One useful consequence of A7 is f u~z Af(u)$@u=r (L4) That \nis, if z is reachable from u, but u is circular and doesn t contain z except possibly u = z, then u = \nz. The proof of L4, by contradiction, is: u~x Af(u)+u Au#x . {Al} f(u)~z A f(u)&#38; U#Z . {A7} f(u)$z/f \nf(u)$c A U#Z + {~~}u=z Au#z . FI Another useful consequence of A7 is f ff u~zAf(u)~u~z-+ U (L5) The proof \nof L5 is left to the reader. The last axiom, A8, identifies the reachability relation for f ~) with -that \nfor f, provided that passing through p is forbidden. Its proof requires Lemma O. (f ~))<n(u) # p + (f \n$))n(u) = fn(u), ProoJ (Induction on n.) If n = O, the lemma reduces to u = u, or trrrc. Suppose the \nlemma true for given n, and suppose (f ; )<n+w # P (1) From (1) wc conclude (f ~~) < (u) # p, hence, \nsince we arc suppos\u00ading the Icmma true for n, (f : )~(u) = f ~(u) (2) Now we derive (f (g~)~+l(u) . (f \n~ )((f ;T(U)) = {(1)} f((f(:))n(~)) = {(2)} f(f (u)) . f ~+yu) which is the equality that was to be proved. \nB Note that Lemma O has the corollary (f ; )- (u) # p =$ ((j : )< (u) # z) = (f -(u) # z) A very similar \nproof (the same except that the. analogues of (1) and (2) are used in the opposite order) establishes \nLemma 1. f<n(u) # p s (f ~~)n(u) = fn(u). I Lemma 1 has the corollary f<n(u) # p + ((f ~~)<n(u) # z) \n= (f -(u) # z) Given these lemmas and corollaries A8 fo!lows immediately: j (;)  = ~d ; :p(f;~))n(U) \n= v : (f ~ )<n(U) # z A (f ; ) <n(U) # p) = (~;: f (u) = v : j< (u) # z A f<n(?J) # p) =U>v ~ We would \nlike to be able to simplify expressions of the form f (P) u + v, even without a p below the arrow. We \nwill derive such a simplification rule from A8 and the auxiliary identity: u&#38;=(u~vV(U~pA p$v)) (L6) \nL6 says that if v K reachable from u, then it IS reachable either by passing through p or by not passing \nthrough p. Its proof is u~vf . {A5}u#v A(u$w VU~p)  u+ Jv(u&#38;ju+p)   {A6}u&#38;v V(U$VAU~p Il p$l) \n =$ {A4}u&#38;p~vv (&#38;i pA p&#38;) 11 The other half of L6 follows from A2. B Using L6 we can prove \nthe important identity: f (P) u+ @+HJV(rq~v)) J++pAp#zA (L7) That is, to any path traced by f ~) there \ncorresponds either a path traced by f that does not pass through p, or two paths each traced by f such \nthat the last element of one path is p and the first element of dre other path is q. When f is replaced \nby f ~) the paths will be joined. Tracing the joined path wdl require applying f ~) to p, whereas in \ntracurg the two paths individually f is never applied to P: hence the appearance of the conjunct p # \nz. To remember thk formula It helps to note that for each of the arrows on the right hand side, If the \nvariable to the right of the arrow is added to the set beneath it, the result is {p, v, z}. The proof \nof L7 is ~ f (;) v = {L6; f (;) (P) f (P) f u vV(U~PA P-&#38;+ v) z, P = {A8, A3,A8,A1} f (P) u+ JV(u&#38;+PA(p=VV(P# \nzAf(;)(P)~v))) f ={si~cep= vAu~p*u&#38;v} f (P) u~vV(u~pAp#zAf(;)(~) -+V) = {A7} u~v V(u~p Ap#x Af(;)(p) \n~V) = {A8, f j (p) = 9} u~vv(u~PAP#z Aq &#38;v) I By applying L7 repeatedly, a relation of the form (Pi) \n. . .(Pm) f ql hbv u x can be expanded to a boolean combination of relations in which only f appears \nabove the arrows. There is one disjunct corresponding to each ordered subset of {1, 2,.. ., n}; the disjunct \ncorresponding to {ii, ..., ik} says that v is rcachcd by going from u to p,,, then from q,, to p,,, then \nfrom q,, to pa, . . . and finally from q,, to v. The disjunct must include the constraint z @ {?%l,. \n... F&#38;). If tie p s are not known to be distinct, the disjunct inchrdcs the constraint Aj, j :I<j \nSk Al<j <n Aj >i, :Pj #p,, ),wllich guarantees that the modified function s value at each p,, is g,,, \nrather Man gj) for some j > if. Wc will encounter an example later. 3. Notation for programs Our notation \nis essentially the same as Dijkstra s [2], but we avoid scoping brackets in favor of initializing guards, \nwe contrive a closed form for the weakest precondition of an annotated iteration, and we allow parametrized \nprocedures, as described below. We use the ordinary scalar assignment operation z := t. The non-scalar \nassignment f(u) := t is regarded as an abbreviation for ~:= f Y; tfrLLStie ~rget of every assignment \nis a variable. scalar or not. We write if P+SO D7P+Slfi and do P+ Sod where othem write ifP then Soeke \nS1 and while P do S respectively. We also insert loop invariant; do { Q}P ~ S od is operationally equivalent \nto do P + S od, but proclaims that Q is true each time P is tested. TN only scoping convention we use \nis the initializing guard; thus for example ifz:P(z) a S% introduces a local variable x whose initial \nvalue satisfies P and whose scope is S. If no such z exists, the command aborts. It is not required that \nz be constant in S; the state space of S has one more dimension than the state space of the enclosing \nblock. Nor is it required that P(z) bc invariaotly true within S. To specify that a procedure named S \nhas the by name parameter u and the by value parameter v, and that the truth of P at entrance to S assures \nthe truth of Q at exit, we write {P} u: S(v) {Q}, Here P is a predicate over a space whose coordinates \nare u and v; Q is a predicate over a space whose coordinates are u, v, and Uo. (In other words, P has \nno free variables besides u and v; and Q has none besides u, v, and Uo,) The purpose of U. is to allow \nQ to refer to the initial value of u, which may differ from the final value. For example, {z > y} z:Down(y) \n{ZII > z > Y} means that Down is a procedure that decreases its first argument to some value no smaller \nthan its second argument, provided that initially the first argument exceeds the second. We use multiple \nparameters (e.g., U1,..., tin: S(q, . . . . Vm)), with the obvious meaning. If S is a command and R \nis a predicate, then wp(S, R) is the predicate to activate S would establish R . For example, f wp(dou#v \nAu#z+ u:= ~(u)od, u=v)=u~rz Similarly, wlp(S, R) is the predicate to activate S would not establish \n1 R , or equivalently, to activate S would either establish R, or cause an aborted computation or an \ninfinite loop. We will work wi~ wlp instead of wp so that we can avoid termination proofs. The equations \nfor wlp that wc will need are wlp(z := = R:  t,l?)(WI) Wlp(s O;S1 , R) = w]P(so, W]p(sL, R)) (W2) wlp(if \nP ~ So II Q ~ S1 fi,R) (W3) = (P =+ W]I)(SO, R)) A (Q* WIP(S1,F?)) wlp(if x:P ~ S fi, R) = (Vz : P : \nwp(S, R)) (W4) wlp(do {Q} P ~ u: S(v) od, R) (W5) =Q A (VU: Q:(R A lP) V (P A wIP(L$, Q))) Here arc translations \ninto English, WI: changing z to equal t will establish R, if what R says about z is true of L W2: the \ncompound sratcmcnt SO; S1 will establish R, if SO will establish a state from which S l will csrablish \nR. W3: an alternating construct will establish R, if each applicable case will csrablish R. (The corresponding \nequation for wp requires that some case bc applicable, to guarantee against abortion.) W4 (only valid \nif R contains no free occurrence of z): if z: P ~ S fi will csrablish R provided that for any legal initial \nvalue of z, S will establish R, W5: the loop will establish R, provided that the invariant is true initially, \nand that for any vahzc to which the changing variable u may be set during tbc coorsc of tbc computation \ni,c., for any value satisfying tbc loop invariant Q citbcr the guard is false and the postcondition has \nbeen established, or else the guard is true and the activation of the loop body will re-establish the \nloop invariant. We wrote u: S(v) in this equation to make explicit that u was the only variable that \nwas changing. If the body of the loop is a compound statement the equation can still be used, provided \nthat every target variable of the loop body is quantified over. The remainder of this section may be \nskipped by those who have no interest in it: it contains a derivation of a weakest precondition equation \nfor procedure calls. We formally define the meaning of {P} u: S(v) {Q) where u and v are distinct variables, \nP is a predicate on u, v, Q k a predicate on u, Uo, and V, and S is a name, to be: for any distinct variables \nx and y, z: S(y) is a transformer on predicates over z and y that satisfies: P; a wlp(x: S(y), Q:)~. \n(1) That is, if P(z, g) is true, then the conditions on (z, y, Uo) that suffice for z: S(y) to establish \nQ(z, y, Uo) are true of (z, y, z). Note that in (l), the transformer z: S(y) acts only on the first two \ncoordinates of the predicate Q(t, y, Uo). It follows from (1) that (Where x is any variable, distinct \nfrom z and y, of which R is independent.) That is, to prove that z: S(y) establishes R, it suffices to \nprove that the precondition Pg~ is true, and that for any value z to which z may be changed i.e., any \nvalue z such that what Q says about (u, Uo, v) is true of (z , z, v) z satisfies the postcondition, in \nthat what R says about z is true of z . The proof of W6 is: (1) A p;; A (VZ : Qj~J : R;,) -wlp(z: S(y), \nQ:~):o A (V z : Q:Y:v : R~/) = {Choose a variable, say ZO, that is not free in R} (V Z. : Z. = z : wlp(z: \nS(y), Q;J);o A (Vz : Q:Y:; : R:,)) = {SubstKute zo for z in two places} (V Z. : ZO = z : wlp(z: S(V), \nQ:);: A (Vz : Q;Y;O; : R;,)) = {Since wlp(z: S(y), ?) doesn t act on uo or Zo} (VZO : zo = z : wIP(z:S(Y), \nQ;&#38;~) A (vz : Q~Y;;y : W,)) = {Rename the bound variable z to z} (VZO : zo = z : WIP(Z: S(V), Q~j) \nA (Vz : Q::~j : R)) % {Since (Pa Q) a (wlp(S, P) a wlp(S, Q))} (VZO : z, = z : WIP(Z: S(V), R) = {Since \nwlp(z: S(y), R) is independent of ZO} Wlp(z: s(y), R) ~ Note the shift in coordinates between (x , z) \nand (z, zo); a similar shift is required in most calculations that use W6. 4. The set union algorithm \nThe set union operation is performed on a state in which each object z belongs to some set whose name \nis r(z); thus two objects z and y are in the same set if and only if r(z) = r(y). Given two objects a \nand b, the operation Union(a, b) changes r so that, relative to its old value ro, it satisfies Vz, y \n:: (r o(~) = ri)(a) A r(Z) = ro(b)) (RI) V (TO(Z) # ~o(a) A ~(z) = n(z)). That is, every object starting \nin the set r{a) is now in the set r(b), and all other objects are in the same set they used to be in. \nThus a s set IS merged mto b s. (We will rake our umverse to be the set of records mampulated by the \nalgorithm, so that we can use unbounded quantification m the mvariants.) In order to find those z s where \nr(z) most be charrjcd it will be necessary to enumerate sets; we therefore assume that the initial state \nsatisfies Vz, y::(r(z) = r(y)) = x~ y. (Ql) That Is, we have a hnk field g such that z and y are in the \nsame set if and only if z is rcachablc from y via q. It follows that each set is linked into a circular \nlist by q, that is: Q1 + (Vz ::q(z) % z) (Bl) The proof of B1 is: q(z) .% z = {Ql} ?(q(z)) = .(2) = r(z) \n= r(q(z)) = {Ql} Z ~q(Z) = {Al} 2 B The union operation establishes R1 under invariance of Ql: {Ql} r, \nq: Union(a, b) {Ql A RI} Evidently Union can be implemented in two steps: firs~ traverse a s equivalence \nclass, changing r(z) from r(a) to r(b) for each z encountered; second, splice the two circular lists \ninto one. Call the first operation S1 and the second S2. Then we have: {Ql} r: Sl(a, b) {Rl} {Q2:q(a)-% \nu/fq(b)%b Ava%b An b.%a} q: S2(a, b) {R2:Vz, y:z%y=(z~y V(zf%a Ab~y) V (.zAbA a~y))} r, q: Union(a, b) \n= if r(a) = r(b) ~ ship II r-(a) # r(b) -+ r: Sl(a, b); q: S2(a, b) fi Thus S1 establishes R1 given Q1; \nthe implementation of S1 will be described later. S2 splices two circular lists into one; its precondition \nQ2 requires that a and b point into diffcrerrt circular lists, since if they pointed into the same lis~ \nthe splice operation would have an unexpected effect. The fourth conjunct in Q2 IS redundant, but is \ninchrdcd to keep Q2 symmetric in a and b. The postcondition R2 characterizes the effect on reachability \n-via-g of splicing two circular lists linked by q. We do not include Q1 in the precondition for S2, so \nwe cannot, for example, replace the z % a in R2 with a $ x. The splice operation has nothing to do wtth \nr, so to include Q1 would be to give up generality unnecessarily. To verify the given implementation \nof Union we must verify both cases of the if statement, The r-(4) = r-(b) case is valid because v(a) \n= r(b) ~ RIJo (B2) The proof of B2 is left to the reader. Next we show that the precondition for S2 is \ntrue at entry; this follows from Q1 A r(a) # r-(b) a Q2 (B3) To prove B3, we assume Q1 and r(a) # z-(b) \nand derive q(a)-%a Aq(b)%b A Ta~bA-b~a = {B1, Q1} 2 A 2 A -IT(a)= r(b) A mr(b) = r(a) . TM Finally, \nwe must show that Union s postcondition will be estab\u00adlished. RI is established by S1 and cannot bc destroyed \nby S2, which leaves r invariant. That Q1 is re-established follows from (B4) To prove B4, we assume Ql:&#38;, \nRI, and R2 and derive r(z) = r(y) = {RI} ( (ro(z) = ro(a) A TO(Y)= To(a) A ~o(b) = ~o(b)) v (To(Z) # \n~0(~) A ~o(~) # ~o(a) A ~o(~) = ~o(y)) V (~0(~) = rO(a) A ~O(y) # TO(U) A ~o(b) = rob)) V (TO(Z) # TO(U) \nA ro(Y) = ro(a) A TO(Z)= ro(b)) ) = {Combine 1st 2 cases; use ro(z) # ro(y) in last 2} ( TO(z)= r-o(y) \nV (TO(Z) = To(a) A To(b) = ro(Y)) V (?O(~) = ro(b) A ~0(~) = To(y)) ) = {QK&#38;} z@yV(x~aAb~y)V(z -% \nbAa~y) = {R2} z~y ~ B2, L?3, and B4 complete the verification of Union relative to S 1 and S2. Notice \nthat the only reasoning about reachability required was the single application of Al in the proof of \nB1. The verifications of S1 and S2 will involve more reasoning about reachability. The suspicious reader \nmay ask, how do you know that B2-B4 complete the verification? , We argued operationally that B2 justified \nthe a = b path through Union, that B3 justified the entry assertion for S2, and that B4 justified the \npostcondition, but what if we missed something? We will double-check by doing a simple predicate calculation \nthat checks that the verification is complete. The calculation is as boring as casting out nines, but \nit works. We will require W6 from the end of section 3. In the following, we write P += Q for Q ~ P. \nTo tit the calculation between the margins, we break it into two parts, checking first that Q1 A r(a) \n# r+) =$ Wp(K S1; q: S2, Q1 A Rl)::9\u00b0 (1) To prove (l), assume Q1 A r(a) # r(b) and derive VW(r: S1; \nq: S2, QI A Rl)~q90 $= {W2, W6} (QI A (Vr : RI;, : Wp(~: S2, Q1 A Rl);,)~;qO @ {Ql = Ql:j9\u00b0, W6} (b r \n: Rl;, : (Q2 A (h q : R2;, : (Ql A Rl)$))~,)fiqO = {Q2~, = Q2:~~~, B3} (VT : RI;, : (Vq : R2:, : (Ql \nA Rl)~,)f,);~gu = {(R1 $):, = Rl;,,B4fi~:~} T~ About the last step in the above derivation: B4 is valid \nfor any initial values To and q. and final values r-and q. But the application of W6 introduced a shift \nof coordinates, naming the initial values r and q and the final vahres r and q . Since B4 is valid, it \nis true in the new coordinates; chat is, B4~:~~,g or Q1 A Rl~;7 A R2~.fi Ql;&#38; is true. This formula \njustifies the last step in the derivation. Finally, {Ql} ~, q: Union(a, b) {Ql A RI} f= {definition} \nQ1 ~ wp(Union, Q1 A Rl)~90 = {W3, wp(sk@, R) = R} ( (Ql A ~(~)= ~(~)+ (Ql A Rl):$O) A (Ql A r(a) # r(b) \n+ wp(r:Sl; q: S2, Ql A Rl):j ) ) = {(Q1 A Rl)~gO == (QI A ~l; ), % (1)} TM (The lack of any real content \nin the last two derivations suggests that there is some better way of presenting the argument. It would \nbe more traditional to present tie above proof in the opposite orde~ first the verification conditions \nB2-B4 are extracted from the specifications by applying the weakest prccondicion equations; then the \nverification conditions are proved. But, working with a pencil and paper, it is messy to extract B2 B4 \nfrom the specifications; it is easier to use one s operational intuition to see what formulas must be \nproved, and than to use the weakest precondition equations to check that they imply the specifications.) \n5. Verification of S1 The purpose of S1 is to change r-(z) for all I such that a % z. We will operate \non the elements in the order q(a), q(q(a)), . . . . a; in the general state of the loop there will be \nsome element c that is the last that has been operated on, and in this general state it will be true \nthat: (Vz : (q(a) $ z ,A ,(z) = ro(b)) (Q3) V (~ q(a)+ x A ~(~) = ~O(z)) That is, r(z) has become ro(b) \nfor all z between q(a) and c inclusive, and r is otherwise unchanged. Q3 is easy to establish for c = \nq(a), and Q3 A c = a implies the postcondition R 1 that we are to establish. Thus we derive the loop: \nr: Sl(a, b) = if c:c = q(u) + r(e) := r(b); do {g(a)% c A Q3} c# a~ c:= q(c); r-(c) := r(b) od 6 To verify \nthis program we first show that the loop invariant is true at entry: that is, Q1 A c = g(a) * (Q3~,yj))K0 \n(B5) (Note that the unlabeled part of the loop invariant, g(a) ~ c, follows from c = q(a) by Al.) To \nprove B5, assume Q1 and c = q(a); then ( (da)$ z A T$j(z) = W) v (7da) $ z A ~f;)(z)= T(z))) = {Al, \nC = q(a)} ( (Z= c A f $;@ = ~(b)) v (Z # c A ~;;/)(T)= f (~))) =T H Next we show that the postcondition \nwill hold when the loop is exited; that is: Ql~OAQ3Ac=a*Rl (B6) The proof of B6 is: ( (To(a)= r,(z) A \nr_(Z)= To(b)) V (r,(a) # r~(z) A r(z)= 7,(Z))) = {Q1;O} (a&#38; z A r(z)= ro(b)) V (1a ~ z A r(z)= TO($)) \n= {Ql;o + (a %x = da) 3z)} (f?(a) ~ z A T(Z)= ~o(b)) V (T da) ~ z A dz) == ~o(z)) = {c = a,A7} (da) $ \nzAdz) = ~o(~))V(Tda) $ zAdz) = TO(Z)) = {Q3} TI Finally we must show that the loop invariant is really \ninvariant Note that the unlabeled part of the loop invariant, q(a) ~ c, is invariant under c := q(c), \nby U. (We add q(a) % u to the antecedent of B7 because we will need it; it is justified by Q1 (the precondition \nfor S1) and B1.) The proof of B7 is the first non-trivial reasoning about reachability encountered in \nthe proof of Union. It is an instance of the following general pattern: suppose that we are processing \nthe elements of a list that starts at u and ends at v, and that the pointer varying in the 100P is w. \nThen we will have an invariant of the form (VZ: (u ~ z = Processed(z)) A (= u ~ z a Unprocessed(x))) \n In order to prove that &#38;is invariant is main~ined when w is assigned J(w) and the new element ~(w) \nis processed, it will be necessary to prove that f ~=(u+zvz= f(w))! ~ in other words that the interval \nfrom u to j(w) is equal to the interval from u to w cxtcndcd by the element j(w). But this is false if \nj(w) hooks back into the interval between u and w. our first ]CIIMTMk that if such hooks are forbidden, \nthen the equality holds: f ~=(u$svz= f(w))) (L8) ++ V +( W The reason that the list can t hook is that \nwe are in the midst of processing the interval from u to v; if moving from w to ~(w) returned LIS to \nan already-processed elcmen~ then v would not be reachable from u. This explains our second lemma: u~v \nAu&#38; AIJ#w=+q+w (L9) We will first prove L!3, then L8. The proof of L9, by contradic\u00adtion. is: fU+ \nVA fU~WAV #WA -U * + {A5}u~tI Au$uJAv#w Au~f(w) + {A6}u~tJAu-$w Av#w A f(w)+w ff * {L4}U&#38;VAU; WATW \n-+v 5 {A6} F m The proof of L8 is in three cases. Assume u w. In the * first case, if u *z, then by \nA4, u fir. In the second case, if z = j(w), then u z is just u ~ j(w), and follows by .L1. In the third \ncase, we d~ Wc can now prove B7 as follows. Assume q(a) % a, g(a) ~ c, Q3, and c# a. Then ( (q(u) A ,(*) \nr-l)(b)) -&#38;z r (c))(z)= q z A r(;[~(z) = ~O(Z)) ) v ( 9( ) ~ = {(L9 A L8);~~.), A7} ( ((q(a) ~ z \nV z = q(c)) A r$[~~(z) = ro(b~) V (m q(a): z A $ # q(c) A (;t\\(z) = o(z)) ) = {Split first case into \ntwo} ( (x= q(c) A ~(b)= ~o(b)) V (q(~)+ z A z # dc) A d~) = o(b)) V (_=du) + z A z # dc) A ~(z)= O(z))) \n= {Q3} x # q(c) v NJ) = ~o(fs) = {Q3 a r(b) = ro(b)} TI B5, 136, and B7 complete the verification of \nS1. To formally check that the verification is complete. assume Q 1 and grind out Wlp(sl, Rl)p = ( v \nc : C = q(a) : wlp(do . . . od)f(c:, )7 = (Vc : C = g(a) : (q(a) ~ c A Q3);;/~, A (V C,r:Q3A q(a)~c: \n(c # a + ((Q3 A q(a) ~ c)~(.))~f;{@~) A (C= a =$ Rl)))~O % {B5, A1} (Vc, r: Q3Aq(a) &#38;c: (C # a =+ \n((Q3 A q(a)% c):(c))~f;[$) A (c= a+ Rl))y = {B7, Q1 + q(a) % a,l,l} (Vc, r: Q3fiq(u) ~c:c=a=Ml)J0 = \n{Rename the bound variable r to r } (Vc, r-): Q3~~ A g(u)% c:c=a=+l?l~f) = {B6~:} T,  Note that before \nrenaming r to r , the variable r. was not free for r in the formula, so the substitution ; could not \nbe moved in. 6. The verification of S2 Two circular lists can be spliced by exchanging any pointer in \none with any pointer in the other; so S2 can be implemented: q: S2(a, b) = if t: t= q(a)-+q(a) := q(b); \nq(b) := t fi. Thus the proof of {Q2}q: S2{R2} reduces (via WI, W2, W3, and kV4) to tie proof of or, \nequivalently, to The proof of B8 requires four uninteresting lemmas: Q2=$. (q(b) fiy=b%y) (B9) Q2Ab%y*x&#38;a=x%a \n(B1O) Q2 A b%ydq(a~~a (Bll) Q2/lb%y~(x-$b=x$b) (B12) These facts are obvious properties of the disjoint \ncircular lists a and b; we will prove B9 and omit the other proofs, which are similar. From Al, A2, and \nA3 we conclude q(b)* y a b ~ y; the proof of the other half of B9 is: b$y Note tlrat since Q2 is symmetric \nwith respect to a and b, a and b may be exchanged in B9-B12, Observe also that the identity which says \nthat a path from z to y must either avoid a and b, or include a, or include b, follows directly from \nL6. We can now prove B8. Assume Q2, then = {L72} ( X*Y V(zfia Aq(b)-$y Aa#b) V(z~b Aq(a)fiy) v(z~a \nAq(b)fib Aq(a)fiv A a#b) V(X= q bAq(a)fi aAg(b)-&#38;y Aa #b)) = {B9-B12, Q2 * a # b} = {Combine lst,$th, \nand 5th cases with B13} This completes the verification of S2, hence of Union. 7. Concluding remarks \n Some readers may be dismayed by tic effort required to verify such a short program, but the critical \nquestion is the asymptotic rate of growth of proof size versus program size, not the constant of proportionality. \nEven m our small example program, the calculations with the reachability predicate were already, perhaps, \nthe minority of the work; a good deal of it concerned r or the relation between r and q, and had nothing \nto do with reachability via q. This su~ests that in verifying large programs, the obstacle will be their \nsize, not the mampulatlons they perform upon pointers-a conclusion that should be no surprise, but is \nworth stating explicitly since one often encounters vague negative remarks along the lines of you will \nrun into programs that play fast and loose with pointers, and you won t be able to do anything with them \n. Various decision problems are suggested by the theory. The axiomatic system AO-A8 can be formulated \nas a first-order system with one predicate and two function symbols by regarding ~(u) as shorthand for \napply( f, u), ~ ~~ as shorthand for store(~, u, v), and f u ~ v as shorthand for rcach(j, u, v, z). \n(Our function variables are simply a sort of first-order variable; this is not a second-order theory.) \nBy quantifying over fonctlon variables, one can express essentially arbitrary first-order statements; \nso the theory is undecidable, and AO A8 are probably not complete. But if quantification is allowed only \nover scalars, the resulting theory might be decidable, and AO A8 might be complete. From the point of \nview of mechanizing program verificatiorz$ the critical question is the quantifier-free case, since quantifiers \nare best handled by general-purpose matchmg algorithms. The quantifier free case reduces to the problem \nof determining the satisfiability of conjunctions of Iiterals, It is not difficult to show that, for \nthe theory of AO-A8, this satisfiability problem is NP-complete, (As is the theory of AO alone see [5], \nchapter 10.) The search for a fast program for solving the satisfiability problem therefore must focus \non avoiding unnecessary case splits; one step in this search is to find special cases which can be solved \nrapidly. One result of this type (see [6]) is a polynomial-time algorithm for determining the satisfiability \nof conjunctions of formulas of the form ff u-tu m 3U+V, * where u and v are scalar variables and ~ is \na function variable. This isn t as easy as it first appears. We have focusscd on verifying reachability \ninvariants, but the bread-and-butter invanants about linked data structures concern the domains and ranges \nof link ticld variables: by checking that z is in the domain of j whenever the program computes f(z), \nwc guarantee that a program never accesses the f field of a record that doesn t have an f field. For \nnice programs (where nice means a non-polymorphic program that does not use variant records and does \nnot explicitly deallocate storage), these invariants are trivial to verify; the required predicate calculations \ncan be performed by associating a type with every variable and checking that each use of the variable \nis consistent with its type. Compilers for Algol-like languages do this calculation in their type-checking \nphase. For non-nice programs, the invariants about the domains and ranges cannot be verified so simply; \nthey are typically complicated by invariants about tag bits or reachability. Of these two complicabons \nthe latter is more serious. A potential application for the techniques described in this paper is a compiler \nthat type-checks non-nice programs as well as nice ones. This requires a study of reachability via partial \nfunctions. We treated only total functions in this paper, but very few changes are required to accommodate \npartiaf functions. Only AO suffers much change: A1-A7 are still valid, and A8 is valid whenever f ~) \nis defined. (In this context, it is best to consider ~ ~) undefined if p is not in the domain of f.) \nIt is easy to imagine similar predicates for reachability via muhiple links (e.g., u @ v), but it is \nnot clear which of the many imaginable predicates are ~portant. References [1] Burstall, R. M., Some \ntechniques for proving correctness of programs which alter data structures , Machine Intelligence 6, \npp. 23-50, Edinburgh, Edinburgh Uruversity Press, 1971. [2] Dijkstra, E. W., A Discipline oj Programming, \nPrentice-Hall, En\u00adglewood Cliffs, N.J. 1976. [3] Luckham, D. and Suzuki, N., Automatic program verification \nV: verification-oriented proof rules for arrays, records, and pointem , Starrford Al Memo AIM-278, March, \n1976, [4] Morris, J. H., Verification-oriented language design , Technical Report 7, Department of Computer \nScience, UC Berkeley, De\u00adcember, 1972. [5] Nelson, G,, Techniques for program verification , CSL-81-1O, \nXerox Palo Aho Research Center, June, 1981. [6] Nelson, G. and Yao, F., Solving reachability constraints \nfor linear lists , manuscript, Augus~ 1982. \n\t\t\t", "proc_id": "567067", "abstract": "The paper introduces a reachability predicate for linear lists, develops the elementary axiomatic theory of the predicate, and illustrates its application to program verification with a formal proof of correctness for a short program that traverses and splices linear lists.", "authors": [{"name": "Greg Nelson", "author_profile_id": "81100407919", "affiliation": "Xerox Palo Alto Research Center, Palo Alto, California", "person_id": "PP31040964", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/567067.567073", "year": "1983", "article_id": "567073", "conference": "POPL", "title": "Verifying reachability invariants of linked structures", "url": "http://dl.acm.org/citation.cfm?id=567073"}