{"article_publication_date": "01-24-1983", "fulltext": "\n Permission to make digital or hard copies of part or all of this work or personal or classroom use is \ngranted without fee provided that copies are not made or distributed for profit or commercial advantage \nand that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, \nto post on servers, or to redistribute to lists, requires prior specific permission and/or a fee. &#38;#169; \n1983 ACM 0-89791-090-7 $5.00 Records may be assigned and passed as parameters and may occur as components \nof arrays and records. Packages are not typed objects and cannot be assigned or passed as parameters \nor appear as components of structured objects. However, packages may have richer components and more \npowerful forms of paremeterization than records. Record components are restricted to be typed objects \nwhile package components may include types, subprogram specifications and package specifications. Record \nparameterization is res\u00ad tricted to discriminants of a discrete type. Generic packages have a compile-time \nparameterizetion mechanism richer than that for subprograms which allows types and subpro\u00adgrams tobe \ngeneric parameters. Let s examine the nature of the notion of type, A type has type-dependent attributes \nsuch as integers end type\u00adindependent attributes such as declaration, parameter pass\u00ading and assignment \napplicable to all types. Specific types of a programming language are generally defined in terms of type-dependent \nattributes. Type-independent attributes are not considered to be part of the type definition but part \nof the language definition. Their specification is distri\u00adbuted in other parts of a language manual, \nsuch as the sec\u00adtion on assignment, parameter passing, etc. However, in examining the nature of the notion \nof type we must con\u00adcentrate on type-independent attributes. The attributes mentioned in example 3 are \nall type-independent. In its attempt to be conservative (safe) Ada has not permitted packages (or subprograms) \nto be declared or passed as parameters, or to have other attributes of types. The mechanisms and attributes \nfor declaring and instantiat\u00ading typed objects and program units are entirely separate. However, attributes \nsuch as declaration, instantiation, hav\u00ading components, being components of structures, having parameters, \nor being passed as parameters do not depend on whether an entity is a data or a program structure. Even \nthe property of being assignable es the value of a variable can be extended from typed objects to program \nunits if the proper notion of the value of a variable is introduced, as is the case in languages like \nRussell [4] or ML [2]. We sheil explore mechanisms for the unification of typed objects and program units, \nBefore doing so, how\u00adever, some of the ways in which dual language mechanisms for data and program abstraction \ngive rise to complexity in current Ada will be examined. Data and Program Abstraction Abstraction is \nconcerned with specifying relevant attributes of a class of objects, situations or processes and ignoring \n(hiding) irrelevant attributes. Different forms of abstraction are concerned with different ways of specify\u00ading \nrelevant attributes and hiding irrelevant attributes. We are concerned with providing users of an abstraction \nwith operations on a data object while hiding its data representation. Ada provides two abstraction mechanisms \nfor hiding data representations that are respectively related to the type end generic mechanisms. (1) \nData abstraction which provides the user with a ! private (hidden) type and operations on objects of \nthe type.  (2) Program abstraction which provides operations on an object whose representation and identity \nis hidden from the user. Program abstraction provides a stronger form of hiding than data abstraction \nsince the identity as well as the representation of the object is hidden from the user.  Queues will \nbe used as a running example to illustrate language design end programming methodology issues which arise \nin comparin~ data and program abstraction mechanisms. Queues may be abstractly defined by a set of operations \nsuch as APPEND and REMOVE which captun? the first-in fimt-out behavior of queue elements. They may be \nrealized in Ada either as packages with private types -which allow the user to create queue objects and \noperate upon them using package operations, or ss generic packages whose instantiation contain queue \noperations in the inter\u00adface specification, Example 4: Data Versus Object Abstraction package QP is --QP \nis an abatract data type type QUEUE is private; operations on queue private .-representationqueue of \n.. hidden from user but visible to the compiler end QP; P, Q: QUEUE; --object declaration generic --QG \nis a generic package --generic formal parameters package QG is operations on queue end QG; package R \nis new QG(actual-parameters); --instantiation The package QP is a data abstraction whose operations are \nshared by objects P,Q of the type QUEUE created by users of the package. The generic package QG represents \nen entirely different view of queue abstractions, l@tlfYlng the queue with a set of operations and eliminating \nthe need for a queue type with an identity separate from that of the operations. Creation of objects \nwhich share a set of opera\u00adtions is replaced by creation of packages which determine a set of operations. \nGeneric packages are program abstrac\u00adtions since they determine a template for a package rather than \nfor a data object. Queue data objects such es P may have values assign\u00adable to other variables Q of the \nsame type and may be passed as parameters of procedures. The package instance R pro\u00advides the user with \nqueue operations tmt cannOt be assigned or Passedas a parameter. On the other hand, gen\u00aderic packages \nmay have type parameters so that queues of integers and of messages can be instantiated from the same \ngenericThe generic package has a more powerful template. instantiation mechanism than the abstract data \ntype but less powerful facilities for manipulating instances. The above tradeoffs between data and as \nprogram abstraction are determined by language-imposed properties of Ada rather then by intrinsic differences \nbetween methods of abstraction. The Proposed unification of objects and program units would eliminate \nm tificial restrictions such as the inability to pass packages as parameters or to parametrize types, \nand would allow the use of abstract entities as values and parameters independently of idiosyn\u00adcratic \nlanguage restrictions. The full specification for QP includes procedures for appending and remoVing queue \nelements, functions for testing if the queue is full or empty, and exceptions which are raised when the \nuser attempts to append to a full queue or remove from an empty queue. Example 5: Hiding the Representation \nof Queues package QP is type QUEUE(MAX: NATURAL:= 100) isiimited Private; procedure APPEND(Q: in out \nQUEUE; E: in INTEGER); procedure REMOVE(Q: in out QUEUE; E: out INTEGER); function IS..-FULL(Q: in QUEUE) \nreturn BOOLEAN; function lS_EIWPTY(Q: in QUEUE) return BOOLEAN; FULL, EMPTY: exception; private type \nQUEUE( MAX: NATURAL := 100) is record FIRST, LAST: INTEGER := 1 ; COUNT: INTEGER := O; ELEMENTS: array(l \n,.MAX) of INTEGER;  end record; end QP; package body QP is --bodies of APPEND, REMovE, ISfilJLL, lsfiMpTy \nend; Simpler interfaces and simpler user calling sequences are two intrinsic advantages of generic instantiation \nover data abstraction. This simplicity must be balanced against the fact that APPEND and REMOVE procedures \nof the generic abstraction achieve simplicity of the interface through hid\u00adden side effects on the local \nqueue data structure. We shall see below that generic abstraction represents en object\u00adoriented programming \nstyle while data abstraction represents a functional programming style. Comparison of these two programming \nstyles for this particular example provides insight into general tradeoffs between functional and object-oriented \nprogramming. Functional versus Object-Oriented Programming Abstract data types require users to create \nqueue objects, to manage storage for queue objects, and to pass them as parameters to queue operations. \nGeneric packages represent a higher level of abstraction because they com\u00adpletely hide the queue data \nstructure in the body of the package and implement shared access to the hidden data structure by non-local \nvariables of queue operations whose side effects are strictly contained within the package body. P: QUEUE(60); \nExample 8: Parameters versus Shared Data Structures The corresponding generic package has a simpler iuter\u00adface \nthan the abstract data type because the type name need not be specified and the data structure for queues \nis buried in the body of the package. Example 6: A Package which is a Queue generic type ELEMENT is private; \nSIZE: INTEGER := 1 00; package (2G is procedure APPEND(E: in ELEMENT); procedure REMOVE(E: out ELEMENT); \nfunction IS_FULL return BOOLEAN; function ISJMPTY return BOOLEAN; FULL, EMPTY: exception; end QG; package \nbody QG is --contains local definition of queue data structure --and the bodies of package operations \n--which have side effects on the queue --through non-local variables end QG; package Q is new QG(INTEGER, \n50); Generic packages not only have a simpler interface. They also have a simpler calling sequence, since \nthe queue is a local data structure of the generic queue package and an explicit parameter of abstract \ndata type operations. Example 7: Comparison of User Calls Q. APPEND(E); --call of APPEND in generic package \nQP.APPEND(Q, E); --call of APPEND in abstract data type a) Abstract Data Types and Functional Programming \n-w b) Generic Abstraction and Object-Oriented Programming Abstract data types conceptually realize APPEND \nby passing the queue and the element to the procedure and returning the modified queue as a result. Generic \nabstrac\u00adtions share the queue data structure among package opera\u00adtions using non-local variables (such \nas Q above) as the sharing mechanism. Abstract data types support a f unc \u00adtional programming style using \nfunctions that have no side effects, while generic abstraction supports an object oriented programming \nstyle in which queue operations transform a hidden internal state that depends on the his\u00adtory of the \noperations applied to the initial state of the queue. Functional programming has the advantage that pro\u00adgrams \nare mathematically tractable and more easily verifi\u00adable. There are no restrictions on the order of evaluation, \nand lazy evaluation that delays evaluation until its value is needed can be performed. Objwt-oriented \nprogramming achieves greater abstraction by hiding the data as an inter\u00adnal state, may provide a more \nrealistic model of real world objects (which often hide an updatable internal state under a deceptively \nsimple interface). Moreover, object abstrac\u00adtions can be more efficiently implemented on a Von Neu\u00admann \nmachine than corresponding function abstractions. Since object-oriented programming is better for users \nand for executing on a computer the user language and machine language should probably be object-oriented. \nSince functional programs are better for verification and optimization, we should consider compiling \nobject-oriented source programs into equivalent functional programs for verification and optimization, \nand then transforming them back into an object-oriented form for execution. The equivalence between functional \nprograms of the form 8a) and object-oriented programs of the form 8b) holds only under very restricted \nconditions in the absence of sharing. But the attempt to explore such equivalence could lead to insights \nconcerning the conditions under which object\u00adoriented programming is equivalent to functional program\u00adming. \nThe proposed transformation from high-level object\u00adoriented programs to lower level functional programs \nsug\u00adgests that mathematical notation should be regarded as an assembly language suitable for automating \nproofs and per\u00adforming optimization rather than a high-level language appropriate for modellittg real-world \nproblems. This accords wtth the fact that complete mathematical rigor may obscure fundamental concepts \nby excessive attention to detail. The queue example illustrates that functional pro\u00adgramming achieves \nits simpltcit y by greatly increasing the volume of parametric information (messaged when func\u00adtions \nare called and when values are returned. This extra information must be managed in the environment of \nthe function, so that simplicity at one level is achieved by irresponsibly passing the buck to the next \nlevel. This contrasts with the object-oriented (generic) approach where state information is carefully \nmanaged within the abstraction itself and full responsibility y is exercised over accessing and sharing \nthe local data. The essence of packages is their ability to define a local data structure (an internal \nstate) that is shared by non\u00adlocal variables of its subprograms. Program abstraction encourages the use \nof subprograms with non-local variables within fiackages. This violation of the accepted wisdom that \nfunctions should not have side effects or non-local variables must be balanced against the fact that \nsuch vari\u00adables not only increase efficiency but increase the leveI of abstraction by allowing side effects \non the local state. Side effects have traditionally been considered harm\u00adful. The present discussion \nillustrates that side effects are a necessary mechanism for information hiding. They allow a subprogram \nto have effects that are hidden from the user which change the internal system state and affect the future \nbehavior of the system. Controlled side effects that affect future system behavior are desirable and \nnatural in many practical situa\u00adtio~s. Depositing money in a bank account is an example of a transaction \nin which a side effect that effects future behavior of the system is desired. Flexibility of human behavior \nis possible only because past experiences have side effects that affect future behavior. Pure functions \nare constrained to have the same behavior every time they are called with given inputs, while functions \nwith controlled side effects can can cause desired changes in a local environment and adapt their behavior \nto changing cir\u00adcumst antes. The partition between parameters and non-local vari\u00adables in a subprogram \nthus reflects a desirable partition between external communication for interaction with its users and \ninternal communication with other components of a subsystem that provide a desired service for the user. \nProgrammers designing large programs with many hundreds of modules must choose between data and pro\u00adgram \nabstraction as a basis for module design. In current Ada instances of data abstractions may be manipulated \nas first-class objects while generic instances may be used but not manipulated. The designers of Ada \nclearly envisaged data abstraction to be the primary abstraction mechanism. However, abstractions consisting \nof a collection of opera\u00adtion without an associated type appear to be simpler and higher-level than data \nabstractions. The fact that program\u00admers are penalized in defining such abstractions is certainly undesirable. \nHowever, in fairness to Ada it should be pointed out that the ability to define such abstractions at \nall is an improvement over previous languages. The Hybrid Status of Tasks Tasks in Ada have a hybrid \nstatus in that they are both program units and typed objects. They are program units in the sense that \nthey have separate specifications and bodies. However, they may be declared as types from which objects \nare created by object declarations. A task type QUEUE with a body common to all objects of the task type, \nand an associated object declaration Ct of the type QUEUE can be specified as follows Example 9: Task \nTypes and Task Objects task type QUEUE is --task type specification entry APPEND(E: in INTEGER); entry \nREMOVE(E: out INTEGER); end; task body Q is ... @ QUEUE; --task object of the type queue Tasks can specify \nonly entry points in their interface and cmtnot directly support concurrent data abstractions which export \na type to users. Queues (buffers) shared by concurrently executing tasks are reatized by object\u00adoriented \nabstractions with a shared state in the task body. This is appropriate since sharing of the queue buffer \nby the competing tasks is generally the appropriate semantics, and simulation of such sharing by an en \nabstract data type that relies on passing the queue data structure from users to the queueing task and \nreturning the modified queue to the user would be difficult. Objects of a task type may be passed as \nparameters and aPPear as components of structured objects and as elements of lists. However they are \nnot first-class objects because they do not have values which can be tested for equality or assi,gned \nas values of task vsxiables. Moreover, they are not first-class program units for the following reasons: \n(1) Task specifications may specify only entry points while package specifications may specify a wide \nvariety of computational resources.  (2) Tasks cannot be made generic or have generic parame\u00adters. The \ntype mechanism rather than the generic mechanism is used to define task templates so that objects created \nfrom the template can be passed as parameters.  In order to achieve the effect of generic parameters \nfor taska it is necessary to embed them in a package. Example 10: Embedding Tasks In Generic Pack@es \ngeneric type ELEMENT is private; package QG is task QT is entry APPEND(E: in ELEMENT); entry REMOVE(E: \nout ELEMENT); end; end; package Q is new QG(INTEGER); The instance Q of the generic package QG contains \na task for concurrently appending and removing elements from a queue whose data structure is defined \nlocal to the task body (in the associated package body). This construc\u00adtion is clearly clumsy and reflects \nthe fact that tasks were not designed to be general user interfaces. The user inter\u00adface for concurrent \nqueues can be better modelled by pack\u00adages containing procedure calls to APPEND and REMOVE which result \nin concurrent calls to a task whose specifica\u00adtion and body is defined entirely within the package body. \nThe dual status of tasks as both objects and program units reflects the fact that the language designers \nfirst con\u00adceived of tasks as program units, and then allowed them to be typed objects so that they could \nbe dynamically created, passed as parameters, and appear as components of lusts and structures. This \nhas strange consequences such as the fact that a subprogram can be passed as a parameter only if it is \ndefined to be concurrent. The task construct is unsatisfac\u00adtory because it contravenes the esthetics \nof the language design and because tasks are second-class entities, both as objects and as program units. \nOne of the consequences of the second-class status of taslw M that they cannot compete with packages \nas vehicles for interface specification and may require a package interface as in the above example. \nThus we see that the duality between objects and pro\u00adgram units in Ada leads to design complications \nwhen introducing new language constructs which have both pro\u00adgram and data attributes. Program Units \nas First-Class Objects Packages in Ada provide a collection of resources to users of the package which \nare specified in the package specification and implemented in the package body. Example 11: Structure \nof Package Specifications package KITCHEN_SINK is resource 1 resources may include resource 2 --subprograms \n .. . --types resource N --variables (typed objects) end KITCHEN SINK; --packages, tasks, exceptions \npackage body KITCHEN_SINK is implementation of resources and The resources provided by a package may \nin general include subprograms, types, typed objects, packages, tasks and exceptions. The set of resources \npermitted in a package may well be richer than is necessary for good programming style. In particular, \nvariables (typed objects) should perhaps be excluded from the package interface. This would allow a package \nto be viewed consistently as an entity with a hidden internal state rather than as an entity whose state \nis partly hidden in the package body and partly visible in typed variables of the package specification. \nHowever the view of packages as a collection of operations on a shared hidden data structure is narrower \nthan that of packages as an arbitrary collection of resources, and the question of whether the narrower \nview significantly res\u00adtricts expressive power needs further study. Packages are au object-oriented language \nconstruct in the sense that they may be used to define objects whose behavior is characterized by a set \nof operations on a com\u00admon hidden data structure. However packages are not first -class objects in the \nsense that they cannot be assigned as values of variables, cannot be passed as parame\u00adters, and cannot \nappear as components of structures or lists. This inconsistency between declarative power and manipu\u00adlation \nability for packages is a basic flaw of Ada. It has caused extensive debate concerning the degree to \nwhich Ada is an object-oriented language. The design decision to make packages second-class objects was \nmade because it was felt that design and imple\u00admentation of packages as as first-class objects was beyond \nthe state of the art. However, advances in our understand\u00ading of object-oriented language design and \nimplementation in the last decade provide a basis for designing an integrated Ada-like object-oriented \nlanguage in which language constructs such as packages are first-class objects. The key to unification \nof records and packages is mak\u00ading functions into first-class ObJeCtS. Let s assume that we have a notion \nof value for functions, so that functions can be assigned, passed as a parameter, returned as a func\u00adtion \nvalue, and be a component of a record or array. Pack\u00adage values may then be defined in terms of function \nvalues a $ records with function-valued components. In the example below we introduce the neutral key\u00adword \n tuple to denote a structure with components and indicate that records may be viewed as tuples of field \nnames and packages may be viewed as tuples of resource specifications. Example 12: Record and Package \nValues tuple (fieldl, field2, .,,, fieldN); .\u00ad --a record value is a tuple of fields tuple (resourcel, \nresource2, .... resource); --a package value is a tuple of resources Record and package types may be \nuniformly defined in terms of functions which return a tuple as their value. A functional specification \nof record and package types in an Ada-style syntax is given below Example 13: Record and Package Types \n a) Record Tuples type RTYPE is --function that produces tuple of fields tuple (fieldl, field2, ,,. , \nfieldN); R: RTYPE; --call function RTYPE, assign value to R b) Package Tuples type PTYPE is --function \nthat produces tuple of resources use (body of package) in tUple (resourcel, resource2, .,. , resource); \nP: PTYPE; --call function PTYPE, assign value to P Both records and packages are defined above as tuples \nwhose components may be accessed by selectors. In the case of records the action when a component haa \nbeen selected iS always access to a named field. In the case of pack~es the action is determined by a \nprogrammer-defined specification in the package body that may involve mani\u00adpulation of a hidden local \ndata structure. The action for record components such as R.f ield 1 is determined by the system while \nthe action for package components such as P.resowce 1 may be specified by the programmer. The role of \nthe package body is to allow the programmer to define the actions to be performed when components of \nthe pack\u00adage specification are selected. A record may be viewed as a degenerate package specification \nwith an empty body that causes components to have a default system-defined interpretation in terms of \nread and write operations. Now that we have seen how subprogram values may be used in defining package \nvalues, we shall review how subprogram values may be defined in terms of closures. A closure consists \nof a representation of the subprogram body together with an environment specification for interpret\u00ading \nits non -local variables. The closure of a subprogram APPEND with a non-local variable that refers to \na shared queue data structure has the following form: Example 14: Format for Subprogram Closures closure \n= (subProgram body, identifier-value paira) = (body of APPEND, < Q , pointer to queue>) The generic \npackage of example 8 has the following form in our notation: Example 15: Generic Queue Type type QG is \nuse(APPEND, REMOVE, initialized queue) in tuple (specification of QG); Q: QG; --creates instance of QG \ncalled Q Elaboration of the declaration Q: QG; causes a value for the package Q to be created consisting \nof an initially empty queue data structure and closures of package pro\u00adcedures such as APPEND and REMOVE \nwith bindings of their non-local variables to the local queue data structure. Calls such as Q.APPEN D(E); \nby the user append the element E to the queue specified by the binding of non-local variables of Q. APPEND. \nClosures allow non-local variables in a subprogram definition to be statically bound to the environment \nin which the subprogram declaration is elaborated so that they are independent of the environment in \nwhich the subprogram is executed. They provide an operational model for subprogram values that may be \nused as a basis for designing abstract machines for languages having subpro\u00adgrams as first-class values. \nAn extended abstract machine for languages with packages as first-class values may then be defined using \nthe definition of packages in terms of sub\u00adprogram closures. The ability to define a simple abstract \nmachine which embodies the operational semantics of languages we are trying to design is a key to simplicity \nof the associated programming language. The interdependence of resources in a package is reflected in \nthe fact that the collection of closures representing package resources refer to shared resources hidden \nfrom the user and accessible only to resources within the package. The operational model of hiding and \nsharing in terms of an interdependent collection of closures deserves further study and may come to play \na central role as a semantic foundation for object-oriented programming. Once the basic model is understood, \nvariants that allow access control, adding and deleting resources, multiple views that share the same \nhidden resources, and concurrent and distributed processing for hidden resources may be considered. Ada \npermits the specification and body of subprograms and packages to be separately compiled. The operational \nimplications of separate compilation will be briefly con\u00adsidered. Separate compilation for packages requires \nthat the specification contain sufficient information for the user to write synaptically correct catls \non package resources and for the compiler to check the type-correctness of such calls. Separately compiled \nbodies may be indicated in our notation as follows: Example 16: Package Types with Separate Bodies type \nQG is separate (body of QG) in tuple (specification of QG); Q: QGi Separate compilation of bodies requires \ncareful parti\u00adtioning between the information needed to invoke resources of a package and that needed \nduring execution of such resources. Once this separation is understood the pro\u00advision of separate compilation \nfacilities is straightforward. There may however be tradeoffs between information and efficiency. One \nsuch tradeoff arises in connection with the Ada requirement that the data representation for private \ndata types be included in the specification. This informa\u00adtion belongs logically in the package body \nsince it is an implementation detail. It was included in the package specification because it was felt \nby the designers that the compiler needed this information to make compile-time decisions about storage \nallocation. This dilemma arises because abstract data types require storage for user-created abstract \ndata objects to be managed in the user environ\u00ad ment, and does not arise at all for object-oriented abstrac\u00ad \ntions which remove this burden from the user. The term entit y will be used to refer to the extended \nImtion of type resulting from the unification of types and program units. The set of attributes permitted \nfor entities should be a union of those associated with types and program units in current Ada. Example \n17: Attributes of Entities has a type which determines operations is created by declarations may have \ncomponents may becomponents (of arrays, records) attributes maybe access values (of lists) of may have \nparameters entities maybe parameters, returned as values maybe assigned as values of variables maybe \ntested for equality may have a hidden body The proposed unification requires a generalization of the \nnotion of value so that subprograms have closures as their values and package values are tuples of resources \nwhose interpretation is determined by the package body. This generalization of the notion of value requires \npartial abandonment of the activation-record-stack run-time environment, and might result in a penalty \nin execution\u00adtime efficiency. But with careful design of the run-time environment and hardware-supported \ngarbage collection these penalties would be acceptable. It is expected that object-oriented computers \nof the future will have built-in on-the-fly garbage collection that wiil greatly reduce the execution-time \npenalty of having a heap. Moreover, the user who uses only values that do not violate the stack dis\u00adcipline \nwould be able to run as efficiently as in current Ada. The proposed changes would result in an object\u00adoriented \nlanguage with the notion of entities with values playing a central semantic role. The language would \nbe simpler because redundant concepts and mechanisms would disappear and confusing non-uniformities in \nabstraction parametrization and accessing for data and program struc\u00adtures would be eliminated. Some \nof the proposed features are currently present in languages like Algol 68 [3] (pro\u00adcedure values), Lisp \n(attribute lists for defining objects), Russell [4] (careful analysis of notion of type), and Smalltalk \n[5] (modules are first-class objects). The pro\u00adposed language would be an Ada-like language just as Ada \nis a Pascal-like language, but would reflect the state of the art in i985 rather than 1975. It would \nreflect our increased understanding of modular programming, recent work on object-oriented languages \nand architectures, and the lessons we have learned in developing Ada. Types as First-Class Objects The \ndomain of applicability of type-independent operations can be extended from data objects to program units \nby making program units into first-class values. It is tempting to extend the domain even further by \nmaking types into first-class values and permitting parameter passi\u00adng, assignment, and other operations \nfor types. This requires careful analysis of the notion of value for types. Tradeoffs between reliability, \nefficiency, and readability of lat@.uigM with compile-time type invariance, and expres\u00adsiveness resulting \nfrom run-time variability of types will be examined. Strong typing in Ada restricts the compile-time \nvaria\u00adbility of types and conflicts with the treatment of types as first-class objects which can be manipulated \nat run time. We shall examine the restrictions on the run-time variabil\u00adity of types imposed by Ada, \nand consider relaxing these restrictions so that types may have some of the run-time variability enjoyed \nby objects. The mechanisms for preserving type consistency when run-time variability for types is introduced \nsuggests that type values be tuples of operators as proposed by Demers and Donahue for Russell [4]. Ada \nrequires all occurrences of a type-valued expres\u00adsion to be manifest at compile time. This implies that \nassignment to type-valued variables and run-time passing of type-valued parameters must be prohibited. \nHowever, Ada allows generic abstractions to have compile-time type parameters subject to the restriction \nthat actual parameters of a generic instantiation are determinable at compile time. A generic queue type \nQG with a generic type parameter (for queue elements) whose actual parameter value is specified at generic \ninstantiation time is illustrated below Example 18: Generic Type Parameters type QG (formal use (body \nof tuple (specific type parameter) QG) in ation of QG); is Q QG (actual type (compile-time constant)); \n Generic bodies may contain identifiers associatd with different types for different instantiations. \nBut all type variability is resolved at compile time during generic instantiation. Instantiation is conceptually \na macro expan\u00adsion with substitution of the actual parameter for all instances of the formal parameter \nin the expanded generic body. Expansions for different actual types result in dif\u00adferent overloading \nof the operators and subprograms for the generic type in the body of QG that are automatically taken \ncare of by the overloading rules of Ada (which cause compile-time substitution of different code for \ndifferent overloadings of an operator). Thus overloading of APPEND for queues of integers and queues \nof messages is realized by different subprograms in the compiled program. Generics allow the programmer \nto write generic definitions with type variables and objects of variable type but are designed so that \nall type variability may be resolved at compile time by the overloading mechanism. Overloaded operators \nand subprograms applicable to objects of a given generic type are implicit formal parameters of the generic \nbody that are bound to specific actual parameters at compile time deter\u00admined by the actual type parameter \nsupplied at generic instantiation time. Run-time type variability for Ada could be introduced in one \nof the following ways: (i) Changing the semantics of generics so that instantia\u00adtion is at execution \ntime rather than at compile-time and actual type parameters are allowed to be variables. (2) Allowing \nthe types of subprogram parameters to be variables that are bound at the time of subprogram call.  Execution-time \ngeneric instantiation would require resolution of overloaded operators and subprograms to be performed \nwhen the actual type is supplied during execu\u00adtion, or mmn later at the time tkt aperators are USSC4. \nInstantiation could consist of execution-time macro expan\u00adsion of object code for the particular overloading \nof opera\u00adtors or of simply noting the type and using it in subsequent interpretive execution of overloaded \noperators. Type con\u00adsistency is guaranteed either way because the system knows the operators for each \ntype and ensures the right execution-time overloading for operators of the generic body. Subprograms \nwith type variables may be illustrated by a SORT procedure which has an array parameter whose elements \nhave a variable type T2 and is supplied with a < operator that compares elements of the type T2 and \nreturns a Boolean result. Example 19: Type Variability in Procedures procedure SORT(X: array (T I ) of \nT2; with <( (T232)BOOL); Explicitly supplied operators such as < allow a programmer-defined meaning to \nbe associated with opera\u00adtions on the type T2, either because none exists or because the programmer wishes \nto redefine the meaning. Implicitly supplied operators such as assignment for elements being sorted are \nassumed to have a default meaning for all ele\u00adment types T2. In general each variable type may have both \nimplicitly overloaded operators whose overloading is supplied. by default by the system and explicitly \noverloaded oDerators supplied by the programmer. The above examples illustrate that type consistency \nin a strongly typed language may be maintained by supplying operators on objects with the type along \nwith the type itself at the time the type value is bound. Such operators may be supplied either explicitly \nby the programmer or implicitly by the system. The need for such operators demonstrates that the operators \nare effectively part of the value associated with a type. Abandoning strong typing attogether leads \nto type\u00adless languages such as the lambda calculus, Lisp, or Snobol 4, in which types of variables are \nnot known at compile time. Languages like SNOBOL 4, which combine t ypeless\u00adness for variables with a \nnotion of type for values, are type-consistent in the sense that execution time checks guarantee that \nonly legitimate operators can be applied to values of variables. The type is part of the value and a \nrun-time type check causes dynamic selection among over\u00adloading of en operator. Variant records provide \na mechanism for selective typelessness that allows the programmer to defer type checking to run-time \nfor selective variables. Variant records in Ada have a discriminant field that identifies the current \nvariant and provide different code segments for operating on different variants of the type. Tests are \npro\u00advided to SI1OW programmer-defined checks for type con\u00adsistency, but these tests could in principle \nbe backed up by system-defined checking for consistency of the tag field of a variant record with the \noperations to be applied to the data. We have indicated a number of options on the spec\u00adtrum between \nmanifest compile-time type specification and complete typelessness. Type variability was found to be \nclosely coupled to mechanisms for binding operators for a given type to specific operations. Compile-time \ntype reso\u00adlution for generic instances in Ada is closely coupled to compile-time binding of overloaded \noperators, while run\u00adtime type variation requires run-time binding of operators. Operators are effectively \nadditional parameters of type varying modules that are bound when the type is bound. Type consistency \nof type-varying modules can be assured if we associate new values with all operators on objects of a \ngiven type every time the type changes. This effectively identifies the value of a given type with the \ntuple of all operators on objects of the type. If we sys\u00adtematically update this value every time the \ntype changes then type consistency is automatically maintained no matter how much run-time type variability \nis introduced. From this point of view strong typing is seen, to be a syn\u00adtactic requirement for textual \ntype invariance that is com\u00adpletely orthogonal to the requirement of type consistency. The identification \nof the type value with the tuple of its operations allows types to be treated as first-class values and \nallows unification of the notion of type with that of records and packages as a tuple of resources. This \napproach has been taken by Demers and Donahue in advocating and implementing the principle of type completeness \nfor the language Russell [4]. The present discussion indicates how completeness consistency can be approached \nstarting from strongly-typed languages such as Ada. Strong typing may be seen es a requirement for restricting \ntextual variability of types that is orthogonal to type consistency. Abandon\u00ading strong typing may result \nin severe problems of execution-time efficiency and program readability and is not necessarily recommended \nfor higher-level languages. However, the notion of type and package values es tuples with similar structure \nis attractive. Moreover, the concep\u00adtual introduction of types as first-class values decouples considerations \nof textual type invariance from considera\u00adtions of type consistency, thereby allowing a more flexible \napproach to the design of type systems for higher-level languages. Comparison with CLU CLU [6] is a programming \nlanguage whose type mechanism supports both program and data abstraction. It is instructive to compare \nclusters (the abstraction mechan\u00adism of CLU) with the data abstraction and generic type mechanisms of \nAda. Clusters are types. Instances of a cluster are intro\u00adduced by declarations. Instances of clusters \nare first-class objects (they can be passed as parameters and be com\u00adponents of structures). But a cluster \nis semantically like a package with a set of operations on a private data type. Declamation of an instance \nis conceptually like generic instantiation, since declarations create an instance of the complete cluster \nrather than just of the data type. , The cluster data type may be t bought of as the value a$t ribute \nof the cluster. It may be initialized by a kreate operation and then updated by operators that modify \nthe value. CLU allows clusters to have generic parameters, but breaks down the process of supplying actual \nparameters and creating instances of the cluster into two steps. This sim\u00adplifies create operations for \nclusters. It permits the declara\u00adtion of both clusters and data types to be modeled by parameterless \noperations with similar syntax and seman\u00ad tics. CLU, like Lisp, distinguishes between binding a vari\u00adable \nto a conceptually preexisting object (CLU assignment) and changing the state of a preexisting object. \nIts notion of assignment is very different from the Ada notion of assign\u00adment which causes a copy of \nan object to be placed into a container associated with the variable. The CLU and Lisp mechanisms for \nbinding values to variables provide a cleaner basis for associating first-class values with erbi\u00adtrary \nobjects than the mechanisms of Pascal and Ada. The work on guardians [7], which is en evolution of the \nwork on CLU for distributed processes, explicitly intro\u00adduces two kinds of modules whose mechanisms for \ncom\u00admunication are respectively governed by message passing and shared variables. Guardians, which represent \ncomplete nodes of a distributed network, can communicate with each other only by message passing, while \nmodules within a given guardian can communicate through shared vari\u00adables or parameters. Any successor \nto Ada should contain both abstraction mechanisms for concurrently executable modules which can communicate \nonly by message passing and submodules which can communicate by shared vari\u00adables or parameters. CLU \nprovides a model for the unification of program and data abstraction in the presence of strong typing \nthat is * good ~ef~r~~ee Point for the unification of objects and program units in Ada. Lisp, ML, and \nRussell provide additional models. The successor of Ada should try to com\u00adbine the Ada approach to separation \nbetween interface specifications and module bodies with mechanisms in the above languages for the unification \nof values, functions, structures, and types. Conclusion The duality between objects and program units \nin Ada is a source of unnecessary complexity which could be elim\u00adinated by replacing these separate but \nredundant notions by a single notion (entity) having both object and program attributes. This duality \ngives rise to complexity at the level of programming methodology which forces the user to make artificial \nchoices between data and program abstractions. It gives rise to complexity at the level of language design \nbecause the designer is forced to choose between a commitment to a program view or data view of a language \nconstruct or, es in the case of Ada tasks, to violate the duality between objects and program units that \nlies at the core of the language design. A unified mechanism for handling obJects and program units would \nnot merely result in a simpler language with a smaller number of orthogonal concepts. It would remove \nthe need for an artificial and premature commitment to program-oriented or data-oriented views at the \nlevel of programming metho\u00addology or language design. The development of a uniform mechanism for abstraction \nand of a consistent mechanism for types are important issues in designing a successor to Ada. This paper \nis not intended to provide definitive solu\u00adtions but to stimulate further discussion. The designers of \nAda were asked (as part of the rules of the Ada design competition) to choose between a com\u00adplex language \n(PL/I or Algol 68) and a simple language (Pasc@ ss a starting point for Ada. The alternative of building \noutwards from a simple Pascal framework was chosen over that of scaling down and modifying the more complex \nAlgol 68 or PL/I frameworks. In designing a suc\u00ad cessor to Ada we could similarly start with a complex \nlanguage such as Ada itself or with a simpler language such as CLU, Russell or ML. Choice of Ada as a \nstarting point could result in a simpler, more powerful language easily learnd by Ada programmers, while \nchoice of a simple language would allow us to start from sound principles and a simple abstract machine \nand add required semantic features and syntactic sugaring in a way that is consistent with the basic \nmodel. Clearly the answer is to combine the two approaches so that the understanding of language structure \nin the research community can be combined with the understanding of problem-solving requirements accu\u00admulated \nduring the design of Ada. It is not too early to start thinking about the redesign of Ada, making use \nof the suggestions in this paper and of advances in hardware and language design and implementation technology \nin the 1980s [8]. The period between now and 1985 could be used for research and requirements analysis, \nwith the object ive of producing a new language design by 1987 and of completing an implementation of \nthe new language by 1990. Experience gained in the design and implementation of current Ada will prove \nextremely useful. Current Ada may be viewed as a rapid prototype for the proposed suc\u00adcessor. We conclude \nthat a strongly -tYP~ Ada-1ike language with frost-class values for data objects, program units, and \ntypes is desirable and feasible. The principles of design depend on a uniform notion of value that permits \ntype\u00adindependent operations such as assignment, parameter pass\u00ading, and component selection to be uniformly \nperformed for all entities, and on the development of a simple abstract machine and an architecture that \npemits efficient imple\u00admentation of the abstract machine. The present paper com\u00adplements fundamental \nresearch in this area on languages which derive from the lambda calculus by showing how notions of value \nand structure developed for such languages can be used to simplify, unify end model the constructs of \nAda, Ackn~wledgements The author is indebted to Dared McQueen and Luca Cardelli for showing how generic \npackage abstractions could be realized in ML by functions which return records with functional components, \nto Alessandro Giacalone for implementing closures in statically scoped Lisp, and to Alan Derners for \nclamfying the notion of types as first-class values represented by tuples of operators. References (1) \nReference Manual for the Ada Programming Language, US Department of Defense, July 1980, -GPO 008-000\u00ad00354-8. \n (2) Gordon M., Milner R., Morris L., Newey M., and Wads\u00adworth C., A Metalanguege (ML) for Interactive \nProof in LCF, Proc 5th POPL Symposium, January 1978. (3) Van Wijngaarden et al, Revised Report on the \nAlgo\u00adrithmic Language Algol 68, Numer. Math., Feb 1975. (4) Demers. A. and Donahue J., Type Completeness \nas a Language Principle, Proc 7th POPL Symposium, Janu\u00adary 1980. (5) Smelltalk Issue, Byte, August 1981. \n (6) Liskov B. Snyder A., Atkinson R., and Sch$ffert C., Abstraction Mechanisms in CLU, CACM August 1977. \n (7) Liskov B. and Scheifler R., Guardians and Actions: Linguistic Support for Robust Distributed Programs, \nProc 9th POPL Conference, Jan 1982. (8) Wegner P., Emperors, Generals, and programmers, ACM Forum, CACM \nFebruary 1982.  \n\t\t\t", "proc_id": "567067", "abstract": "Ada is rich in the variety of its abstraction mechanisms. It has both a data abstraction mechanism (packages with private data types) that supports a functional programming style and a program abstraction mechanism (generic program units) that supports an object-oriented program style. Tradeoffs between data and program abstraction are examined and it is pointed out that Ada discourages program abstraction because program units are not first-class objects. It is shown how program units could be made into first-class objects by introducing closures as values for functions and records with function components as values for packages. Further unification by allowing types to be first-class objects conflicts with the requirement of compile-time type invariance. The relaxation of this requirement in a manner that preserves type consistency is examined and leads to a notion of value for types as tuples of operations. It is suggested in the conclusion that our understanding of abstraction for object-oriented languages and of other language design, implementation, and environment issues will have progressed sufficiently by 1985 to warrant the design of a successor to Ada by the late 1980s.", "authors": [{"name": "Peter Wegner", "author_profile_id": "81332534685", "affiliation": "Brown University, Providence, RI", "person_id": "PP43124908", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/567067.567091", "year": "1983", "article_id": "567091", "conference": "POPL", "title": "On the unification of data and program abstraction in Ada", "url": "http://dl.acm.org/citation.cfm?id=567091"}