{"article_publication_date": "09-25-2013", "fulltext": "\n Unifying Structured Recursion Schemes Ralf Hinze Nicolas Wu Jeremy Gibbons Department of Computer Science, \nUniversity of Oxford, Wolfson Building, Parks Road, Oxford, OX1 3QD, England {ralf.hinze,nicolas.wu,jeremy.gibbons}@cs.ox.ac.uk \nAbstract Folds over inductive datatypes are well understood and widely used. In their plain form, they \nare quite restricted; but many dis\u00adparate generalisations have been proposed that enjoy similar cal\u00adculational \nbene.ts. There have also been attempts to unify the var\u00adious generalisations: two prominent such uni.cations \nare the re\u00adcursion schemes from comonads of Uustalu, Vene and Pardo, and our own adjoint folds . Until \nnow, these two uni.ed schemes have appeared incompatible. We show that this appearance is illusory: in \nfact, adjoint folds subsume recursion schemes from comonads. The proof of this claim involves standard \nconstructions in category theory that are nevertheless not well known in functional program\u00adming: Eilenberg-Moore \ncategories and bialgebras. Categories and Subject Descriptors D.1.1 [Programming Tech\u00adniques]: Applicative \n(Functional) Programming; D.3.2 [Program\u00adming Languages]: Language Classi.cations applicative (func\u00adtional) \nlanguages; F.3.2 [Logics and Meanings of Programs]: Se\u00admantics of Programming Languages algebraic approaches \nto se\u00admantics General Terms Languages; Theory; Veri.cation Keywords recursion schemes; adjunctions; comonads; \nbialge\u00adbras; distributive laws 1. Introduction It has long been understood that explicit recursion is \nthe goto of pure functional programming [22], and should be considered harm\u00ad ful to program comprehension \nand analysis. Instead, structured re\u00adcursion operators such as catamorphisms (folds) [10, 19] ought to \nbe used wherever possible: they make termination manifest, and enjoy many useful calculational properties \nwhich would otherwise have to be established afresh for each new application. However, catamorphisms \nare relatively restricted. There are many other structured patterns of recursion, equally harmless and \nworth capturing, that do not quite .t the scheme. Variations that have been proposed in the past include \nfolds with parameters and accumulating folds [25], which may depend on constant or varying additional \narguments; mutumorphisms [8], which are pairs of mu\u00ad tually recursive functions; zygomorphisms [18], \nwhich consist of a main recursive function and an auxiliary one on which it depends; Permission to make \ndigital or hard copies of all or part of this work for personal or classroom use is granted without fee \nprovided that copies are not made or distributed for pro.t or commercial advantage and that copies bear \nthis notice and the full citation on the .rst page. Copyrights for components of this work owned by others \nthan the author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or republish, \nto post on servers or to redistribute to lists, requires prior speci.c permission and/or a fee. Request \npermissions from permissions@acm.org. ICFP 13, September 25 27, 2013, Boston, MA, USA. Copyright is held \nby the owner/author(s). Publication rights licensed to ACM. ACM 978-1-4503-2326-0/13/09. . . $15.00. \nhttp://dx.doi.org/10.1145/2500365.2500578 paramorphisms [21], in which the body of structural recursion \nhas access to immediate subterms as well as to their images under the recursion; histomorphisms [26], \nin which the body has access to the recursive images of all subterms, not just the immediate ones; and \nso-called generalised folds [4], which use polymorphic recursion to handle nested datatypes. The many \ndivergent generalisations of catamorphisms can be bewildering to the uninitiated, and there have been \nattempts to unify them. One approach is the identi.cation of recursion schemes from comonads [30] (which \nwe call rsfcs for short). Comonads capture the general idea of evaluation in context [27], and rsfcs \nmake contextual information available to the body of the recursion. This pattern subsumes zygomorphisms \nand histomorphisms. A more recent attempt [11] uses adjunctions as the common thread. Adjoint folds arise \nby inserting a left adjoint functor into the recursive characterisation, thereby adapting the form of \nthe recursion; they subsume accumulating folds, mutumorphisms (and hence zygomorphisms), and generalised \nfolds. Given that adjoint folds and rsfcs cover some of the same exam\u00adples, it seems reasonable to suspect \na deeper relationship between them. That suspicion is strengthened by the observation that every adjunction \ninduces a comonad, and every comonad can be factored into adjoint functors. And indeed, the suspicion \nturns out to be well founded. In this paper, we show that rsfcs are subsumed by adjoint folds. Moreover, \nalthough the converse does not hold, we identify those adjoint folds that correspond to rsfcs. Technically \nspeaking, our contributions are as follows: We provide a fresh account of adjoint folds, making essential \nuse of liftings and conjugates. Very brie.y, adjoint folds are parametrised by an adjunction L -R and \na distributive law s : L.D..C.L that connects data structure to control structure.  We show that that \nrsfcs [30] are subsumed by adjoint folds.  We state precisely the relationship to the (type) fusion \nrule of categorical .xed-point calculus [1]. In essence, type fusion allows us to fuse an application \nof a left adjoint with an initial algebra to form another initial algebra, L (\u00b5C) ~ = \u00b5D, under the \nstronger assumption that s is an isomorphism.  We prove that adjoint folds can be framed as rsfcs, if \na distribu\u00adtive isomorphism s exists.  We dissect most of the proofs into two parts: .rst, we establish \na bijection between certain arrows and homomorphisms; second, we instantiate the bijections to initial \nor free algebras. The uni.ed approach to recursion schemes is based on adjoint folds and unfolds, so \nno new theory is needed. This is good news indeed! The message of this paper is that the existing theory \nis more general than we anticipated. The uni.cation is more than merely an intellectual curiosity: it \npromises concrete returns, too for example, through general techniques for combining different recursion \nschemes (most functions actually use a combination of recursion schemes).  Because of space limitations, \nwe focus on algebras and induc\u00adtive types; but everything dualises elegantly to a theory of adjoint unfolds \n[11] that subsumes patterns such as apomorphisms [31] and futumorphisms [26]; we return to this point \nin Section 9. The paper is organised as follows: Section 2 presents a sm\u00f6rg\u00e5s\u00ad bord of Haskell examples, \nwhich are picked up later; Section 3 summarises some of the theoretical background; Section 4 walks through \na basic example of our unifying theory of adjoint folds, which is set out in Section 5; Section 6 shows \nthat all rsfcs are adjoint folds, and Section 7 identi.es those adjoint folds that are rsfcs; and .nally, \nSection 8 discusses related work, and Section 9 concludes and points out directions for future work. \n2. A Zoo of Morphisms In this section we exhibit a number of specimens from the zoo of morphisms, which \nwill serve to illustrate the theory that follows. We use Haskell as a lingua franca for codifying our \ncategorical constructions as programs. However, throughout the paper we are careful to distinguish between \ninductive and coinductive types, which Haskell con.ates. Catamorphism The most basic recursion scheme \nis the catamor\u00adphism, known more colloquially as fold. A catamorphism decom\u00adposes an inductively de.ned \nstructure, replacing each of the con\u00adstructors with a provided argument. An example of this pattern is \nto compute the depth of a binary tree. data Tree = Empty | Node Tree N Tree depth :: Tree . N depth (Empty) \n= 0 depth (Node l a r) = 1 + (depth l max depth r) Folds with parameters Folds with constant parameters \ntake an additional argument, on which results may depend. List concatena\u00adtion is a canonical example: \ncat :: ([ a],[a]) . [a] cat ([ ], ys) = ys cat (x : xs,ys) = x : cat (xs,ys) . Here, the second component \nof the pair is the parameter; cat is not just a fold because the pair argument is not of an an inductive \ntype. In folds with accumulating parameters, the additional argument may vary in recursive calls. Haskell \ns foldl is an example. More interesting examples are provided by downwards accumulations on trees [9]; \nfor example, replacing every element with its depth (if the accumulator is initialised to 0): depths \n:: (Tree,N) . Tree depths (Empty, n) = Empty depths (Node l a r,n) = Node (depths (l,n+1)) n (depths \n(r,n+1)) . This is a rather simple example; in general, the accumulating pa\u00adrameter will vary in different \nways in different branches. Paramorphism The paramorphism models primitive recursion: the body has access \nnot only to the results of recursive calls, but also to the substructures on which these calls are made. \nAn example of a paramorphism is counting the words in a string: wc :: [Char] . Int wc [ ] = 0 wc (c : \ncs) | \u00ac (isSpace c) . (null cs . isSpace (head cs)) = wc cs + 1 | otherwise = wc cs . Note that in the \nclause for non-empty lists, the result depends not only on a recursive call wc cs on the substructure, \nbut also on the substructure cs itself. Zygomorphism A variation is the zygomorphism, where the re\u00adcursion \nis aided by an auxiliary function: perfect :: Tree . B perfect Empty = True perfect (Node l a r) = perfect \nl . perfect r . (depth l depth r) . The function perfect is not a simple fold, since it relies on an \nauxiliary traversal of the tree structure using depth. Mutumorphism A mutumorphism generalises the idea \nof a zygo\u00admorphism, allowing the recursive functions to rely mutually on one another. For example, consider \nthe odd and even functions: odd :: N . B even :: N . B odd 0 = False even 0 = True odd (n + 1) = even \nn even (n + 1) = odd n . Here, the functions work as a pair in tandem as they recurse through the structure \nof natural numbers. Nested datatypes Functions over nested datatypes such as perfect trees or random-access \nlists have to deal with the polymorphic re\u00adcursion. For example, consider summing a perfect tree of numbers: \ndata Perfect a = Zero a | Succ (Perfect (a,a)) instance Functor Perfect where fmap f (Zero a) = Zero \n(f a) fmap f (Succ p) = Succ (fmap (. (x,y) . (f x,f y)) p) total :: Perfect N . N total (Zero n) = n \ntotal (Succ p) = total (fmap (. (a, b) . a + b) p) . This is not a straightforward fold, because the \nrecursive call of total is not applied directly to a subterm indeed, it cannot be so applied, because \nthe subterm p of Succ p has type Perfect (N,N) rather than Perfect N. Histomorphism Histomorphisms capture \ntabulation, as used in dynamic programming. For example, consider the unbounded knapsack problem: given \nan integer capacity c, and as many copies as needed of each of a collection of items (wi, vi) with posi\u00adtive \ninteger weight wi and value vi, compute the maximum value that will .t in the knapsack. Thus, given capacity \n15 and items [ (12,4),(1,2),(2,2),(1, 1),(4,10) ], the maximum value possible is 36, using three copies \neach of the second and .fth items. The naive recursive solution takes exponential time (we sup\u00adpose here \nthat the maximum value of the empty list of candidate solutions is zero): knapsack :: [ (N, R) ] . N \n. R knapsack wvs c = maximum [v + knapsack wvs (c-w) | (w,v) . wvs,w . c] . However, by tabulating the \nresults for each capacity in 0 . . c, one can compute the answer in pseudo-polynomial time: knapsack \nwvs c = table !! c where table = [ ks i | i . [0. . c] ] ks i = maximum [v + table !! (i-w) | (w,v) . \nwvs,w . i] . Lazy evaluation works out the data dependencies automatically; but each element of the table \ndepends only on elements with lower indices, so even without lazy evaluation it suf.ces to .ll the table \nin index order. Now, the general question is whether the recursion equations above have unique solutions? \nThe answer is yes for all of them. However, up to now the proofs involved two seemingly incompat\u00adible \ntechniques: most of the examples can be identi.ed as adjoint folds; some of them (in particular knapsack) \nare subsumed by re\u00adcursion schemes from comonads. Before we show how to unify the two approaches, we \n.rst need to introduce a bit of theory.  3. Background This paper assumes a basic knowledge of category \ntheory, in that the reader should be familiar with the notions of functors, natural transformations, \nand product and functor categories. In this section we .x the notation and establish categorical concepts \nthat will be used in the remainder of the paper. For the most part this material is standard and can \nsafely be glossed over on an initial reading. An exception is perhaps the material on functor squares \nand conjugates, which will need particular attention. 3.1 Functor Squares A functor square consists of \nfour functors and a natural transfor\u00admation between them (to read off the type of . , it might help to \ntilt your head 45. to the left when looking at this diagram): H C 1 C 1 . : F . H ..K . F1 . FF  D1D \nK For brevity, we call . a distributive law, even though the name is traditionally used for the special \ncase in which opposite functors are comonads or monads. Functor squares can be horizontally (and also \nvertically, not shown below) composed: H1 H.H1 H C 1 C 11 C 11 C C F11 = F11 , F1F F   D11 D11 D1D \nD K1 K.K1 K where the horizontal composition . - . 1 of the distributive laws . and . 1 is given by a \ncombination of horizontal (.) and vertical (\u00b7) composition of natural transformations (. binds tighter \nthan \u00b7): . - . 1 = K . . 1 \u00b7 . . H1 . This composition is associative, with idF : F . Id ..Id . F as \nits neutral element. 3.2 Algebras and Coalgebras Algebras and coalgebras form the basis for the categorical \ndescrip\u00adtion of structured recursion schemes. Given an endofunctor F : C . C , an F-algebra is a pair \n(a,A), where a : F A . A is an arrow and A : C is an object, which are known as the action and carrier \nof the algebra. (We deviate a little from the standard notation (A,a), in order to have a syntax that \ndis\u00adtinguishes algebras from coalgebras.) Since the action determines its carrier, it is often used by \nitself to refer to the F-algebra. An F-homomorphism between algebras (a,A) and (b, B) is an arrow h : \nA . B : C such that h \u00b7 a = b \u00b7 F h. F h F A F B a b A B h Clearly, F-homomorphisms compose and have \nan identity, so it follows that F-algebras and F-homomorphisms form a category, which we call F-Alg(C \n). The initial object of this category, if it exists, is given by (in, \u00b5F) and called the initial F-algebra. \nThe ini\u00adtiality implies that to each F-algebra, (a,A), there exists a unique F-homomorphism, a : (in, \n\u00b5F) . (a,A), called a fold. The alge\u00adbra in is, in fact, an isomorphism, so \u00b5F is a .xed-point of F (the \nleast .xed-point), a fact known as Lambek s lemma. Example 3.1. The semantics of the inductive datatype \nTree is given by the initial algebra \u00b5Tree, where the so-called base functor data Tree tree = Empty | \nNode tree N tree abstracts away from the recursive occurrences of Tree. The Haskell rendering of the \nisomorphism in, the action of the initial algebra, in :: Tree Tree . Tree in (Empty) = Empty in (Node \nl a r) = Node l a r amounts to a simple renaming of constructors. Dually, given an endofunctor G : C \n. C , a G-coalgebra is a pair (C, c), where C : C is the carrier and c : C . G C is the action of the \ncoalgebra. A G-homomorphism between coalgebras (C,c) and (D, d) is an arrow h : C . D : C that satis.es \nG h \u00b7 c = d \u00b7 h. Just as before, a category G-Coalg(C ) can be formed from G-coalgebras and G-homomorphisms. \nThe .nal object of this category, if it ex\u00adists, is given by (.G,out) and called the .nal G-coalgebra. \nThe category F-Alg(C ) has more structure than C . The forget\u00adful or underlying functor UF : F-Alg(C \n) . C forgets about the additional structure: UF (a, A) = A and UF h = h. An analogous functor can be \nde.ned for coalgebras: UG : G-Coalg(C ) . C . \u00afis called a lifting of H : C . D iff H . UF = UG . H\u00af. \nGiven a distributive law . : H.F..G.H, we can de.ne a lifting as follows: Liftings and coliftings A functor \nH : F-Alg(C ) . G-Alg(D) H. (a, A) = (H a \u00b7 . A,H A) , (3.1a) H. h = H h . (3.1b) For liftings, the action \non the carrier and on homomorphisms is .xed; the action on the algebra is determined by the distributive \nlaw. Liftings of the identity functor, that is, H = Id and . = a : F ..G, are often written as a-Alg(C \n) : F-Alg(C ) . G-Alg(C ). Liftings compose in an attractive way: H. . H1.1 = (H . H1).-.1 . Since we \nuse the action of an algebra to refer to the algebra itself, we often abbreviate H a \u00b7 . A by H. a. Dually, \nH : F-Coalg(C ) . G-Coalg(D) is a colifting of H : C . D iff UG .H = H .UF. Given . : H .F ..G .H we \ncan de.ne a colifting as follows: H. (C,c) = (H C,. C \u00b7 H c) , (3.2a) H. h = H h . (3.2b)  3.3 Adjunctions \nAdjunctions were introduced by Kan [14] and are so pervasive in the study of category theory that Mac \nLane [17, p.vii] noted Ad\u00ad joint functors arise everywhere. Our work supports this view: ad\u00adjunctions \nprovide a uni.ed framework for program transformation. Given categories C ,D, we say that functors L \n: C . D and R : C . D form an adjunction, written L -R : C -D or L . C D , R iff there is a bijection \nbetween the sets of arrows l-J : C (L A, B) ~, = D(A,R B) : 1-l that is natural both in A and B. We say \nthat L is a left adjoint for R, and R a right adjoint for L; the isomorphism l-J is called the left adjunct, \nand its inverse 1-l the right adjunct. The arrows lfJ and 1gl are also called the transposes of f and \ng. That the adjuncts l-J and 1-l are mutually inverse can be captured using an equivalence: f = 1gl .. \nlfJ = g , (3.3)  for all f : L A . B : C and g : A . R B : D. The naturality properties of the adjuncts \ncan be expressed as fusion laws. R k \u00b7 lfJ \u00b7 h = lk \u00b7 f \u00b7 L hJ (3.4a) k \u00b7 1gl \u00b7 L h = 1R k \u00b7 g \u00b7 hl (3.4b) \nThese equations imply that the adjuncts are uniquely de.ned by their actions on the identity: R k \u00b7 lidJ \n= lkJ and 1idl \u00b7 L h = 1hl. An alternative de.nition of adjunctions is based on the two natural transformations \ne = 1idl and . = lidJ, which are called the counit e : L . R ..Id and the unit . : Id ..R . L of the \nadjunction. The equivalence (3.3) can also be framed in terms of the units: f = e B \u00b7 L g .. R f \u00b7 . \nA = g . (3.5) Adjunctions satisfy a wealth of properties. An important prop\u00aderty is that adjoint functors \nare uniquely de.ned up to isomorphism: if L1 -R1 and L2 -R2, then ~~ L2 = L1 .. R1 = R2 . (3.6) This \nequivalence can be used as a reasoning principle: often one isomorphism is trivial and can be used to \nestablish the other. Left adjoints preserve initial objects, L 0 ~0. Dually, right = adjoints preserve \n.nal objects, R 1 ~ = 1. In general, left adjoints preserve colimits (LAPC) and right adjoints preserve \nlimits (RAPL). Example 3.2. Coproducts and products arise as left and right adjoints (+) -. -(\u00d7) of the \ndiagonal functor . : C . C \u00d7 C de.ned by . A = (A,A) and . f = (f,f). (+) . . . C C \u00d7 C C \u00d7 C C . \n(\u00d7) The bijections express that pairs of arrows with the same source (re\u00adspectively, target) are in one-to-one \ncorrespondence with arrows to a product (respectively, from a coproduct). In the case of products, the \nleft adjunct l(f1, f2)J = f1 f2 is known as the split combina\u00adtor, and the counit e = (outl,outr) arises \nfrom the projections. Example 3.3. Perhaps the best-known example of an adjunction is currying: a function \nof two arguments can be treated as a function of the .rst argument whose values are functions of the \nsecond. -\u00d7P . C C (-)P The right adjoint of pairing with P is the exponential from P. Example 3.4. \nFor a signature expressed as a functor F, the terms involving variables of type A constitute the free \nalgebra FreeF A on A. The functor FreeF : C . F-Alg(C ) arises as the left adjoint of the forgetful functor \nUF. Dually, cofree G-coalgebras arise as the right adjoint of UG. UGFreeF . . F-Alg(C ) C C  G-Coalg(C \n) UF CofreeG The .rst bijection expresses that the compositional evaluation of a term is uniquely determined \nby the action on variables. Initial algebras and .nal coalgebras arise as special cases (LAPC and RAPL): \n(in, \u00b5F) ~ = FreeF 0 (closed terms as open terms where the variables are drawn from 0) and (.G,out) ~ \n= CofreeG 1. Adjunctions can be lifted to functor categories: L -R implies both L . - -R . - and - . \nR -- . L. The latter adjunctions capture the following bijections between natural transformations: = \nDX (F,R . G) C X (L . F,G) ~, (3.7a) = X D (F,G . L) X C (F . R,G) ~. (3.7b) Conjugates Next we introduce \na concept that will be at the heart of our framework. Just as natural transformations relate functors, \nconjugates relate adjoint pairs of functors. Given the adjunctions L -R : C -D and L1 -R1 : C 1 -D1, \nand functors H : C . C 1 and K : D . D1, the distributive laws s : L1 . K ..H . L and t : K . R ..R1 \n. H are conjugates, written s -t, if one of the following conditions holds lH f \u00b7 s AJ1 = t B \u00b7 K lfJ \n, (3.8a) H 1gl \u00b7 s A = 1t B \u00b7 K gl1 , (3.8b) for all f : L A . B : C and g : A . R B : D. The equivalence \nof the two conditions is a consequence of (3.7). In fact, each natural transformation uniquely determines \nthe other: s A = 1t (L A) \u00b7 K (. A)l1 , (3.9a) t B = lH (e B) \u00b7 s (R B)J1 . (3.9b) We obtain two distributive \nlaws for the price of one; this fact will be used a lot. The following diagrams record the types. K H \nD1 C 1 D C - L1 R1 L R  C 1 D1 C D H K (As an aside, the data the functors H and K and the laws s \nand t are also called an adjoint square, a pair of functor squares, from L -R to L1 -R1. Above, we have \ntaken the .rst steps towards de.ning the double category of adjoint squares [24].) Example 3.5. A lifting \nH\u00afprovides an important example of a con\u00adjugate between categories of algebras where the second transfor\u00admation \nt : H . UF = UG . H\u00afis manifestly the identity. 4. Warm-up: An Easy Instance of Adjoint Folds Before \nwe introduce the uni.ed framework, it is instructive to walk through a speci.c instance. In Section 2 \nwe have discussed that functions de.ned by mutual recursion, mutumorphisms, are not simple folds. They \nare, however, in one-to-one correspondence with folds. Mutumorphisms are captured by the following scheme: \nx1 \u00b7 in = b1 \u00b7 D (x1 x2) and x2 \u00b7 in = b2 \u00b7 D (x1 x2) . The split combinator makes the results of both \nrecursive calls available to the algebras bi : D (B1 \u00d7B2) . Bi. Think of xi : \u00b5D . Bi as unknowns; we \naim to show that they are uniquely determined by the two equations. We proceed in two steps: First, we \nabstract away from the initial algebra (in,\u00b5D), gener\u00adalising to an arbitrary D-algebra (a,A), and turn \nthe two equations into a form we can work with. Product categories provide a natural setting, simply \nbecause we have two equations. (Recall that split is the left adjunct of . -(\u00d7), see Example 3.2.) x1 \n\u00b7 a = b1 \u00b7 D (x1 x2) and x2 \u00b7 a = b2 \u00b7 D (x1 x2) .. { product category C \u00d7 C }(x1,x2) \u00b7 (a,a) = (b1,b2) \n\u00b7 (D (x1 x2),D (x1 x2)) .. { de.nition of . and de.nition of l-J } (x1,x2) \u00b7 . a = (b1,b2) \u00b7 . (D l(x1, \nx2)J) .. { set x := (x1,x2) and b := (b1,b2) }x \u00b7 . a = b \u00b7 . (D lxJ) We obtain a single equation, where \nthe algebra a is wrapped in a left adjoint. From here, a short calculation demonstrates that the transpose \nof x is a homomorphism:  x \u00b7 . a = b \u00b7 . (D lxJ) : . (D A) . B .. { l-J and 1-l are isomorphisms (3.3) \n} lx \u00b7 . aJ = lb \u00b7 . (D lxJ)J .. { l-J is natural (3.4a) } lxJ \u00b7 a = lbJ \u00b7 D lxJ : D A . (\u00d7) B . Thus, \nlxJ is a D-homomorphism, and so x is the transpose of a D\u00adhomomorphism. Furthermore, b is the transpose \nof a D-algebra this is an important observation. Let us record the correspondence (note that B is an \nobject of C \u00d7 C , that is, a pair of objects in C , and recall that lxJ = x1 x2). . (D lx J) D lxJ D \n((\u00d7) B) . (D A) . (D ((\u00d7) B)) D A .. lbJ . a b a (\u00d7) B . A B A x lxJ Second, we instantiate (a,A) to \nthe initial algebra (in,\u00b5D). The solution of the original pair of equations is then given by x1 x2 = \nb1 b2 , which is Fokkinga s mutu-CH A RN law [7]. Several special cases are worth singling out. If x2 \ndoes not de\u00adpend on x1, we obtain zygomorphisms (ie b2 := b \u00b7 D outr and con\u00adsequently x2 := b ). Further, \nwhen h2 is the identity, the zygo\u00admorphism specialises to a paramorphism (ie b2 := in \u00b7 D outr and consequently \nx2 := in = id). Pushing this to the extreme, if we have two independent homomorphisms (ie b1 := b1 \u00b7 \nD outl and b2 := b2 \u00b7 D outr and consequently x1 = b1 and x2 = b2 ), we derive the banana-split law [3], \nan important program optimisation that replaces a double tree traversal by a single one. b1 b2 = b1 \u00b7 \nD outl b2 \u00b7 D outr (4.1) The law can also be justi.ed in a different way: b1 b2 is the unique homomorphism \nto a product algebra: (b1,B1) \u00d7 (b2,B2) = (b1 \u00b7 D outl b2 \u00b7 D outr,B1 \u00d7 B2) . We shall see later that \nthis is not just a lucky coincidence. 5. A Uni.ed Framework for Recursion Schemes This section introduces \nthe promised unifying theory for recursion schemes. As noted in the introduction, the unifying concept, \ncalled generalised iteration in [20] and adjoint fold in [11], is not new. (So no new theory is needed, \nwhich is good.) What is novel is the presentation, which makes essential use of conjugate pairs of distributive \nlaws and liftings, rendering the proofs concise and ele\u00adgant. However, since the concepts from category \ntheory are perhaps somewhat remote from the daily practice of the programmer in the cubicle, we .rst \ntake a short detour, which hopefully helps to con\u00adnect the abstract concepts to concrete programs. 5.1 \nDetour: Mendler-style Folds Mendler-style folds [23, 28] arise from taking a logical (speci.\u00ad cally, \nsecond-order simply-typed lambda calculus) rather than an algebraic approach to inductive datatypes. \nAs such, they provide a smooth transition path from explicit recursion to the use of recur\u00adsion schemes. \nTo illustrate, the semantics of depth is roughly the .xed-point of the so-called base function depth \ndepth depth (Empty) = 0 depth depth (Node l a r) = 1 + (depth l max depth r) , which abstracts away from \nthe recursive calls. There is an addi\u00adtional twist: we have replaced the Tree constructors by the corre\u00adsponding \nTree constructors, which results in a rank-1 type: depth :: .tree . (tree . N) . (Tree tree . N) . The \npolymorphic type guarantees that the original recursion equa\u00adtion, depth \u00b7 in = depth depth has a unique \nsolution. (Because of the occurrence of in, we said roughly the .xed-point .) Translated into category \ntheory, Mendler-style folds are solu\u00adtions in an unknown x : \u00b5D . B to recursion equations of the form \nx \u00b7 in = . (\u00b5D) x , where the base function . is a natural transformation of type C (-,B) ..C (D -,B). \nVery brie.y, the Yoneda lemma [17] shows that the space of base functions such as . is isomorphic to \nthe space of D-algebras. Thus, Mendler-style folds are in one-to-one correspondence with standard folds \nof the form x \u00b7 in = b \u00b7 D x . Conversely, a standard fold is a Mendler-style fold, as the right\u00adhand \nside as a function in x satis.es the naturality requirement. 5.2 Detour: Mendler-style Adjoint Folds \nWe have noted in Section 2 that many functions do not quite .t the pattern of simple folds: depths, for \ninstance, uses an accumulating parameter. However, to provide a precise semantics we can take a similar \napproach as in the previous section. We de.ne a base function that additionally replaces the Tree constructors \non the left\u00adhand side (and only those) by the corresponding Tree constructors. depths :: .tree . ((tree,N) \n. Tree) . ((Tree tree, N) . Tree) depths depths (Empty, n) = Empty depths depths (Node l a r,n) = Node \n(depths (l, n + 1)) n (depths (r, n + 1)) The type of the base function is similar to what we had before, \nexcept that tree and Tree tree are wrapped in a left adjoint: (-,N) or, categorically speaking, - \u00d7 N. \nNonetheless, one can show that depths \u00b7 (in \u00d7 N) = depths depths has a unique solution. This motivates \nthe following generalisation of Mendler-style folds. Given an adjunction L -R, an Mendler-style adjoint \nfold x : L (\u00b5D) . B is the unique solution to the recursion equation x \u00b7 L in = . (\u00b5D) x , (5.1) where \nthe base function . is now a natural transformation of type C (L -, B) ..C (L (D -),B). The main dif.culty \nin translating the examples of Section 2 into adjoint folds is to identify the left adjoint. For some \nexamples this is obvious, eg for depths we use the curry adjunction - \u00d7 N -(-)N; for others it is less \nobvious, eg for total the left adjoint is type application (applying a functor to a constant object), \nwhich has a right adjoint under some mild conditions [11].  5.3 Adjoint Folds Standard folds are restricted \nto the case that the control structure of a function ever follows the structure of its input data. Mendler\u00adstyle \nadjoint folds loosen this tight coupling. The control structure is given implicitly through the adjunction, \nbut it can also be made explicit by introducing a control functor . De.nition 5.1 (Adjoint recursion \nequation). Given an adjunction L -R : C -D, functors C : C . C and D : D . D, and a distributive law \ns : L . D ..C . L, an adjoint recursion equation in the unknown x : L (\u00b5D) . B has the form x \u00b7 L in \n= b \u00b7 C x \u00b7 s (\u00b5D) , (5.2) where b : C B . B.  The functor C is called control functor because it governs \nthe recursive call structure. The diagram below displays the functors involved (D as in data functor, \nC as in control functor). L C C . D D (5.3) R The distributive law s : L . D ..C . L serves as an \nimpedance matcher relating data and control functors. Adjoint folds arise as unique solutions of adjoint \nrecursion equations we postpone the proof of uniqueness until Section 5.4. As in the vanilla case, Mendler-style \nadjoint folds (5.1) and adjoint folds (5.2) are interchangeable. Every adjoint fold is a Mendler\u00ad style \none, as the right-hand side of (5.2) as a function in x satis.es the naturality requirement. The other \ndirection is more interesting: Given a base function . : C (L -,B) ..C (L (D -),B), we have to construct \na control functor C, a distributive law s : L . D ..C . L and a C-algebra b : C B . B. The .rst two pieces \nof data are induced by the adjunction: a canonical choice for the control structure is C = L . D . R \nwe simply go round in a loop (5.3). Using this de.nition, the type of s expands to L . D ..L . D . R \n. L, which suggests de.ning s = L . D . .. Finally, the C-algebra is derived from the base function: \nb = . (R B) (e B) : L (D (R B)) . B. For the proof of . X x = b \u00b7 C x \u00b7 s X we refer to the original \npaper [11]. Recursive Haskell programs are easily framed as Mendler-style adjoint folds (5.1). Adjoint \nfolds (5.2) are, however, preferable for the theoretical development as they avoid sophistications such \nas natural transformations between hom-functors.  5.4 Transposed Homomorphisms To show that (5.2) has \na unique solution, we proceed in two steps, following the pattern set out in Section 4. First, we abstract \naway from the initial algebra (in,\u00b5D), gen\u00aderalising to an arbitrary D-algebra (a,A), and establish a \nbijection between arrows x : L A . B satisfying x \u00b7 L a = b \u00b7 C x \u00b7 s A , (5.4) and D-algebra homomorphisms. \nThe central step in the calculation below is the penultimate one, which replaces the distributive law \ns : L . D ..C . L by its conjugate t : D . R ..R . C, effectively shifting the recursive call to the \nright. x \u00b7 L a = b \u00b7 C x \u00b7 s A : L (D A) . B .. { l-J and 1-l are isomorphisms (3.3) }lx \u00b7 L aJ = lb \n\u00b7 C x \u00b7 s AJ .. { l-J is natural (3.4a) }lxJ \u00b7 a = R b \u00b7 lC x \u00b7 s AJ .. { s -t conjugates (3.8a) }lxJ \n\u00b7 a = R b \u00b7 t B \u00b7 D lxJ .. { de.nition of lifting (3.1a) }lxJ \u00b7 a = Rt b \u00b7 D lxJ : D A . R B Voil\u00e0: the \ntranspose lxJ : (a,A) . Rt (b, B) is a D-homomorphism between a and a lifting of b. To .x some terminology, \nwe call x a transposed homomorphism, or traho for short. D l xJ s A C x  L (D A) C (L A) C B D A D (R \nB) .. a Rt b (5.5) b L a L A x B A R B lxJ Second, if we instantiate (a,A) to the initial algebra \n(in,\u00b5D), we obtain the following Theorem 5.2 (Adjoint folds). The adjoint recursion equation (5.2) has \nthe unique solution x = 1 Rt b l, where t : D . R ..R . C is the conjugate of s. The arrow x is called \nan adjoint fold. Proof. This is an immediate consequence of initiality. x \u00b7 L in = b \u00b7 C x \u00b7 s (\u00b5D) .. \n{ see above } lxJ \u00b7 in = Rt b \u00b7 D lxJ .. { (in, \u00b5D) initial } lxJ = Rt b .. { l-J and 1-l are isomorphisms \n(3.3) }x = 1 Rt b l So an adjoint fold is a traho from the initial algebra. Using the bijection (5.5) \nwe can easily generalise from initial to free algebras. Then lxJ can be seen as evaluating a .rst-order \nterm, and is uniquely determined by an evaluation function for variables. There is an interesting observation \nto be made. Adjoint folds arise out of a situation that is not symmetric. The distributive law t allows \nus to lift the right adjoint R to categories of algebras: C-Alg(C ) Rt D-Alg(D) UC UD L (5.6) . C C \nD D R s : L . D ..C . L -t : D . R ..R . C . Alas, we cannot lift the left adjoint L with the data at \nhand: a lifting of L requires a distributive law of type C . L ..L . D. The asym\u00admetry can be traced \nback to the de.nition of algebras. Consider the type of an action, a : D A . A; the base functor D only \nappears to the left of the arrow, in a contravariant position. Symmetry can be restored if s is an isomorphism, \nan important special case, which we explore in the Section 5.5. But .rst, let us look at an example. \nExample 5.3. Mutumorphisms are an instance of adjoint folds where the control functor is the canonical \none and s = . . D . .. . ..D.(\u00d7) D2 . D D (\u00d7) The conjugate of s is t = . . D . (\u00d7) (3.9b) and thus \n(\u00d7)t (b1,b2) = b1 b2 . Note that the lifted product functor is just the left adjunct. When we discussed \nadjoint folds (Section 5.3), we introduced the canonical control functor C = L . D . R. For this case \nthe de\u00advelopment above can be simpli.ed. The functor C comes equipped with a canonical pair of distributive \nlaws: s = L . D . . : L . D ..C . L -t = . . D . R : D . R ..R . C . The proof of uniqueness then boils \ndown to a two-stepper (this is the proof of Section 4, more abstractly): x \u00b7 L a = b \u00b7 L (D lxJ) : L \n(D A) . B .. { l-J and 1-l are isomorphisms (3.3) }lx \u00b7 L aJ = lb \u00b7 L (D lxJ)J .. { l-J is natural (3.4a) \n}lxJ \u00b7 a = lbJ \u00b7 D lxJ : D A . R B .  This is indeed an instance of the previous development: some easy \ncalculations show that Rt b = lbJ and L (D lxJ) = C x \u00b7 s A. L (D lxJ ) D lxJ  L (D A) L (D (R B)) D \nA D (R B) .. a lbJ L a b L A x B A R B lxJ (5.7) Now, if (a,A) is initial, then x = 1 lbJ l. We further \nexplore the canonical control functor in Section 5.6.  5.5 Type Fusion Let us now assume that the distributive \nlaw s is an isomorphism. Then we can continue the .rst calculation of Section 5.4 in the opposite direction \n. We start with (5.4) and reason x \u00b7 L a = b \u00b7 C x \u00b7 s A : L (D A) . B .. { s is an isomorphism }x \u00b7 \nL a \u00b7 s. A = b \u00b7 C x .. { de.nition of lifting (3.1a) }x \u00b7 Ls. a = b \u00b7 C x : C (L A) . B . Overall, we \nhave established the following one-to-one correspon\u00addence between algebra homomorphisms. D lxJ C x C \n(L A) C B D A D (R B) s iso .. a Ls. b Rt b a L A x B A R B lxJ In other words, jointly with L we \nhave lifted the entire adjunction L -R to an adjunction Ls. -Rt between categories of algebras. C-Alg(C \n)(Ls. (a,A), (b,B)) ~ = D-Alg(D)((a, A),Rt (b,B)) We arrive at a situation that is perfectly symmetric. \nTrahos appear at some intermediate stage, at the point where we apply the assump\u00adtion that the distributive \nlaw s is an isomorphism. We can now complete (5.6) with the missing left adjoints. Ls. . C-Alg(C ) \n D-Alg(D) Rt UDUC ~ -- FreeC = FreeD (5.8) L C C . D D R s : L . D ~-. R . C = C . L t : D . R . \nOverall, we have four (!) adjunctions, which form a commuting square of adjunctions. The proof of this \nfact makes use of the hgih-level reasoning principle (3.6). If we instantiate (3.6) to the compositions \nof left and right adjoints (note that left adjoints are composed in the opposite order) we obtain: = \nLs. UD . Rt ~ FreeC . L ~. FreeD .. = R . UC . Since Rt is a lifting, the isomorphism on the right is \nvalid indeed, it is even an equality. Consequently, the compositions of left adjoints are isomorphic, \nas well. We record the following Theorem 5.4. Let L -R : C -D be an adjunction, and let C : C . C and \nD : D . D be functors. L . D ~= C . L =L . D * ~ . = C * . L Proof. Plugging in the de.nitions, F* = \nUF . FreeF, we conclude L . UD . FreeD = UC . Ls. = UC . FreeC . L . FreeD ~. As a corollary (using \u00b5F \n~= 0) we obtain the fu\u00ad = F* 0 and L 0 ~sion rule of Backhouse et al. [1] s categorical .xed-point calculus. \nCorollary 5.5 (Type fusion). L . D ~= C . L =L (\u00b5D) ~ . = \u00b5C Example 5.6. The diagonal functor . satis.es \na simple property: . . D = D2 . .. Since . is a left adjoint, Corollary 5.5 implies . (\u00b5D) ~.= \u00b5D2 The \ninitial algebra of D2, a functor over a product category, consists of two copies of \u00b5D we will later \nneed this simple fact. The conjugate of the distributive law id : . . D = D2 . . is t = D outl D outr \n(3.9b) and thus (\u00d7)t (b1, b2) = b1 \u00b7 D outl b2 \u00b7 D outr . Instantiating Diagram (5.8) we can see the \nglobal picture. .id = D2 . D-Alg(D)2 ~-Alg(D2) D-Alg(D) (\u00d7)t UD2 UD . D2 D2 . D D (\u00d7) Since D2-Alg(D2) \n~ = D-Alg(D)2, we obtain that (\u00d7)t modulo the isomorphism is the product functor for D-Alg(D), which \ngives us the entire infrastructure for products: outl, outr and . (This also provides us with another \nproof of the banana-split law (4.1)) We have now encountered two control functors associated with the \nadjunction . -(\u00d7): the canonical one . . D . (\u00d7) and the perfect control functor D2. The next section \nrelates the two.  5.6 Comparing Control Functors Adjoint folds involve several pieces of data: an adjunction, \nan al\u00adgebra, and a control functor equipped with a conjugate pair of dis\u00adtributive laws. The latter is \nperhaps the most mysterious, especially if we try to link the Haskell programs in Section 2 directly \nto the re\u00adcursion scheme of adjoint folds (5.2). Mendler-style folds provide a stepping stone, suggesting \nthat there is a canonical choice for the control functor: C = L . D . R with s = L . D . . : L . D ..C \n. L -t = . . D . R : D . R ..R . C . We now justify the adjective canonical for this choice: we show \nthat every other control functor can be reduced to the canonical one. Assume that we have another control \nfunctor C1 with s1 : L . D ..C1 . L -t1 : D . R ..R . C1 . Using bijection (3.7b), the distributive law \ns1 gives rise to a natural transformation . : L . D . R ..C1 = C ..C1, namely . = C . e \u00b7 s1 . R. This \nnatural transformation in turn induces the lifting .\u00adAlg(C ), which maps C1-algebras to C-algebras. Since \nit is a lifting of the identity functor, .-Alg(C ) is faithful. Moreover, we have the following commutative \ndiagrams of functors. C-Alg(C ) Rt  D-Alg(D) (5.9) .-Alg(C ) C1-Alg(C ) D-Alg(D) Rt1  We .rst note \nthat . relates s -t and s1 -t1 in the following way (the proofs are routine but uninstructive). s1 = \n. . L \u00b7 s (5.10a) t1 = R . . \u00b7 t (5.10b) For the proof of (5.9) it suf.ces to concentrate on the algebras: \nRt (.-Alg(C ) a) = R (a \u00b7 . A) \u00b7 t A = R a \u00b7 t1 A = Rt1 a . Furthermore, every traho can be translated \ninto a traho that uses the canonical control functor: x \u00b7 L a = b \u00b7 C1 x \u00b7 s1 A .. { (5.10a) } x \u00b7 L \na = b \u00b7 C1 x \u00b7 . (L A) \u00b7 s A .. { . is natural and x : L A . B } x \u00b7 L a = b \u00b7 . B \u00b7 C x \u00b7 s A .. { de.nition \nof lifting (3.1b) } x \u00b7 L a = .-Alg(C ) b \u00b7 C x \u00b7 s A . Example 5.7. In Section 4 we noted that the banana-split \nlaw (4.1) arises as an extreme case of mutumorphisms. Mutumorphisms are based on the canonical control \nfunctor C = . . D . (\u00d7); banana\u00adsplit employs the control functor D2. The lifting .-Alg(C 2) : D2\u00adAlg(C \n2) . C-Alg(C 2) induced by . = (D outl,D outr) : C . D2 serves as the adaptor, translating D2-into C-algebras. \n6. Recursion Schemes from Comonads Recursion schemes from comonads [30], rsfcs for short, form a general \nrecursion principle that makes use of a comonad N to provide contextual information to the algebra. Like \nadjoint folds, it is doubly generic : it is parametric in the datatype \u00b5F, and in the comonad N. As a \nparticularly nice example, histomorphisms, the Squiggol rendering of course-of-values recursion, employ \nthe cofree comonad, which makes available the results of recursive calls on all subterms. (An even better \nchoice is the cofree recursive comonad [29].) To this end it makes use of a coalgebra fan : \u00b5F . N (\u00b5F) \nthat embeds a subterm in a context. For the cofree comonad, fan maps a term to the cotree of all subterms. \nThe coalgebra can be de.ned generically in terms of a distributive law . : F . N ..N . F, which is subject \nto certain conditions (6.6), detailed below. De.nition 6.1 (Comonadic recursion equation). Given a functor \nF, a comonad (N,e,d), and a distributive law . : F . N ..N . F, a comonadic recursion equation in the \nunknown f : \u00b5F . B has the form f \u00b7 in = b \u00b7 F (N f \u00b7 fan) , (6.1) where fan = N in \u00b7 . (\u00b5F) : \u00b5F . \nN (\u00b5F) and b : F (N B) . B. The composition N f \u00b7 fan creates a context that makes the results of recursive \ncalls available to the algebra b, which is a context\u00adsensitive algebra an (F . N)-algebra, rather than \nmerely an F\u00adalgebra. Uustalu et al. [30] showed the following Theorem 6.2 (Rsfcs). The comonadic recursion \nequation (6.1) has the unique solution f = e B \u00b7 N b \u00b7 . (N B) \u00b7 F (d B) . A couple of remarks are in \norder. The recursion scheme involves both algebras and coalgebras, and combines them in an interesting \nway. We noted above that fan is a coalgebra, but it is actually a bit more: it is a coalgebra for the \ncomonad N. Furthermore, the algebra in and the coalgebra fan go hand-in-hand. They are related by the \ndistributive law . and form what is known as a . -bialgebra, a combination of an algebra and a coalgebra \nwith a common carrier. We postpone our proof of Theorem 6.2 to Section 6.3, after we have provided the \nnecessary background in the following sections, which can be skipped by those already familiar with the \nmaterial. 6.1 Background: Eilenberg-Moore Categories Comonads and monads Functional programmers have \nembraced monads, and to a lesser extent, comonads, to capture effectful and context-sensitive computations. \nA comonad is a functor N : C . C equipped with natural transformations e : N ..Id (counit), that ex\u00adtracts \na value from a context, and d : N ..N . N (comultiplication), that duplicates a context, such that the \nfollowing laws hold: e . N \u00b7 d = N , (6.2a) N . e \u00b7 d = N , (6.2b) d . N \u00b7 d = N . d \u00b7 d . (6.2c) The \n.rst two properties, the counit laws, state that duplicating a context and then discarding a duplicate \nis the same as doing nothing. The third property, the coassociative law, equates the two ways of duplicating \na context twice. Monads (M, .,\u00b5) are dual to comonads, with transformations . : Id ..M (unit) and \u00b5 : \nM .M ..M (multiplication) that obey dual properties. Huber [13] discovered that an adjunction (e,L -R,.) \ninduces a comonad (L . R,e, L . . . R) and a monad (R . L,.,R . e . L). For example, the adjunction FreeF \n-UF induces the so-called free monad F* = UF . FreeF, the carrier of the free F-algebra, repre\u00adsenting \n.rst-order terms with variables. (The comonad that arises is less interesting.) Dually, the adjunction \nUG -CofreeG induces the cofree comonad G8 = UG . CofreeG. This can be seen as the type of generalised \nstreams of observations generalised because the tail is a G-structure of streams rather than just a single \none; we obtain streams for G = Id. (Now the monad is less interesting.) Coalgebras for a comonad A coalgebra \nfor a comonad N is an N-coalgebra (C,c) that respects e and d: e C \u00b7 c = idC , (6.3a) d C \u00b7 c = N c \u00b7 \nc . (6.3b) If we .rst create a context and then focus, we obtain the original value. Creating a nested \ncontext is the same as .rst creating a con\u00adtext and then duplicating it. For example, the so-called cofree \ncoal\u00adgebra (N C, d C) is respectful, which follows directly from (6.2b) and (6.2c). The second law (6.3b) \nalso enjoys an alternative read\u00ad ing: c is a homomorphism of type (C,c) . (N C,d C). This obser\u00advation \nis at the heart of the Eilenberg-Moore construction, which we discuss below. Coalgebras that respect \ne and d, and coalge\u00adbra homomorphisms between them, form a category, known as the (co)-Eilenberg-Moore \ncategory and denoted CN. Eilenberg-Moore categories generalise categories of coalgebras: G-Coalg(C ) \n~ = CN where N = G8 is the cofree comonad. Eilenberg-Moore construction As noted above, every adjunction \ngenerates a comonad. The converse is also true: every comonad N induces an adjunction that generates \nN in fact, in two canonical ways. One construction was discovered by Kleisli [15], the other by Eilenberg \nand Moore [6]. We shall need the latter, which constructs a right adjoint to the forgetful functor UN \n: CN . C . UN . C CN CofreeN The functor CofreeN maps an object to the cofree coalgebra for N: CofreeN \nB = (N B,d B) , (6.4a) CofreeN f = N f . (6.4b) The counit e : UN .CofreeN ..Id of the adjunction UN \n-CofreeN is the counit of N; the unit . : Id ..CofreeN . UN de.ned . (C, c) = c extracts the action of \na coalgebra, which is an N-coalgebra homo\u00admorphism of type (C,c) . (N C,d C) (6.3b). The bijection framed \nin terms of the units reads:  f = e B \u00b7 UN h .. CofreeN f \u00b7 . (C,c) = h , for all f : UN (C,c) . B and \nh : (C,c) . CofreeN B. The adjunction UN -CofreeN indeed generates the comonad N: we have UN . CofreeN \n= N and d = UN . . . CofreeN. Since UN is faithful, we can simplify the bijection slightly: f = e B \u00b7 \nh .. N f \u00b7 c = h , (6.5) for all f : C . B and homomorphisms h : (C, c) . (N B,d B). Have we seen an \narrow of the form N f \u00b7 c before?  6.2 Background: Bialgebras A bialgebra combines an algebra and a \ncoalgebra with a common carrier. Bialgebras come in many .avours; we need the variant that combines F-algebras \nand coalgebras for a comonad N. The two functors have to interact coherently, described by a distributive \nlaw. Distributive laws A distributive law . : F .N ..N .F of an endo\u00adfunctor F over a comonad N is a \nnatural transformation satisfying the two coherence conditions: e . F \u00b7 . = F . e , (6.6a) d . F \u00b7 . \n= N . . \u00b7 . . N \u00b7 F . d . (6.6b) We can use . to colift F to the category CN. The coherence condi\u00adtions \nguarantee that F. : CN . CN preserves respect for e and d. Dually, . induces the lifting N. : F-Alg(C \n) . F-Alg(C ). Now, the coherence conditions ensure that N. is a comonad with e\u00af(a,A) = \u00af e A and d (a,A) \n= d A. In particular, the lifted transformations e\u00af: N. ..Id and d \u00af : N. ..N. . N. are F-algebra homomorphisms. \nBialgebras Let . : F . N ..N . F be a distributive law for the endofunctor F over the comonad N. A . \n-bialgebra (a,X,c) consists of an F-algebra (a,X) and a coalgebra (X, c) for the comonad N such that \nthe pentagonal law holds: c \u00b7 a = N a \u00b7 . X \u00b7 F c . (6.7) Loosely speaking, the law allows us to swap \nthe algebra a and the coalgebra c. A . -bialgebra homomorphism is both an F-algebra and an N-coalgebra \nhomomorphism. . -bialgebras and their homo\u00admorphisms form a category, denoted . -Bialg(C ). The pentagonal \nlaw (6.7) also has two asymmetric renderings, which relate it to liftings and coliftings. F X F c a F \n(N X) X a F X F X F c F (N X) F. c a . X c N. X a  N X N (F X) X c N X c N (F X) N a N a N X (6.8) \nThe diagram on the left shows that c : (a, X) . N. (a,X) is an F\u00adalgebra homomorphism. Dually, the diagram \non the right identi.es a : F. (X, c) . (X,c) as an N-coalgebra homomorphism. Thus, we can interpret the \nbialgebra (a,X, c) both as an algebra over a coalgebra (a, (X,c)), or as a coalgebra over an algebra \n((a,X), c). Formally, we have the following isomorphisms of categories: F. -Alg(CN) ~= . -Bialg(C ) ~. \n= (F-Alg(C ))N. (6.9) The alternative interpretations are useful to determine initial and .nal objects \nin . -Bialg(C ). To determine the initial object, we use the coalgebra over algebra view, as categories \nof G-coalgebras have a trivial initial object: (0,0 G 0), where 0 is the initial object in the underlying \ncategory and 0 G 0 the unique arrow from it. Consequently, (in,\u00b5F,fan) with fan = N. in is indeed \ninitial.  6.3 Recursion Schemes from Comonads are Adjoint Folds We now return to the proof of Theorem \n6.2 using our new vocabu\u00ad lary to derive the unique solution. Somewhat surprisingly, as an im\u00admediate \nconsequence of this proof, it turns out that rsfcs are an in\u00adstance of adjoint folds, when previously, \nthe two frameworks were thought of as being orthogonal [11]. Of course, the derivation is not strictly \nnecessary, but it helps to relate the present development to prior work [30], and it hopefully helps \nto understand why rsfcs are an instance of adjoint folds. The development will follow the pattern we \nhave already established. First, we abstract away from the initial object (in,\u00b5F,fan), gen\u00aderalising \nto an arbitrary . -bialgebra (a, A,c). The goal is to estab\u00adlish a bijection between arrows f : A . B \nsatisfying f \u00b7 a = b \u00b7 F (N f \u00b7 c) and . -bialgebra homomorphisms h : (a, A,c) . (b ,N B,d B), where \nb is a to-be-determined F-algebra. Now, we already know that arrows of type f : A . B and N-coalgebra \nhomomorphisms h : (A,c) . (N B,d B) are in one-to-one correspondence (6.5). So we identify N f \u00b7 c as \nthe transpose of f and simplify f s equation to f \u00b7 a = b \u00b7 F h. It remains to show that h is an F-algebra \nhomo\u00admorphism of type (a,A) . (b ,N B). F h F A F (N B) F A F h F (N B) .. (6.10) a b b a A B A \nN B f h The strategy for the proof is clear: we have to transmogrify f into N f \u00b7 c. Thus, we apply N \nto both sides of f \u00b7 a = b \u00b7 F h and then swap a and c using the pentagonal law (6.7). f \u00b7 a = b \u00b7 F \nh =. { N functor }N f \u00b7 N a = N b \u00b7 N (F h) =. { Leibniz }N f \u00b7 N a \u00b7 F. c = N b \u00b7 N (F h) \u00b7 F. c .. \n{ a : F. (A,c) . (A,c) (6.7) }N f \u00b7 c \u00b7 a = N b \u00b7 N (F h) \u00b7 F. c .. { F. h : F. (A,c) . F. (N B,d B) \nand F. h = F h }h \u00b7 a = N b \u00b7 F. (d B) \u00b7 F h The proof makes essential use of the fact that a and h are \nN\u00adcoalgebra homomorphisms, and that F. preserves coalgebra homo\u00admorphisms. Along the way, we have derived \na formula for b : b = N b \u00b7 F. (d B) = N b \u00b7 . (N B) \u00b7 F (d B) . (6.11) We have to show that (b , N B, \nd B) is a . -bialgebra. Since F. (N B,d B) is a coalgebra for the comonad N, we can con\u00adclude using (6.5) \nthat b is a coalgebra homomorphism of type F. (N B,d B) . (N B,d B), which establishes the desired result. \nFurthermore b = e B \u00b7 b , which allows us to complete the proof. h \u00b7 a = b \u00b7 F h =. { Leibniz }e B \u00b7 \nh \u00b7 a = e B \u00b7 b \u00b7 F h .. { f = e B \u00b7 h and b = e B \u00b7 b }f \u00b7 a = b \u00b7 F h We have discovered an important \nfact: b and b are also related by the Eilenberg-Moore adjunction UN -CofreeN! Using the no\u00adtation for \nadjuncts, the right-hand side of (6.10) reads lfJ \u00b7 a = lbJ \u00b7 F lfJ. This looks suspiciously like the \nright-hand side of (5.7), which relates trahos (adjoint folds) and homomorphisms. However, the original \nequation for f does not seem to .t into the picture. This is because it omits the forgetful functor UN. \nIf we make it explicit, we obtain the the following bijection, which is indeed an instance of (5.7). \n UN (F. lfJ) UN (F. (A,c)) UN (F. (CofreeN B)) UN a b  B UN (A, c) f F. lfJ F. (A,c) F. (CofreeN B) \n.. a lbJ (A,c) CofreeN B lfJ If we simplify the composition of functors using UN . F. = F . UN and \nUN . F. . CofreeN = F . UN . CofreeN = F . N, we obtain the original equivalence (6.10). The somewhat \npedantic diagrams above explicate all the information implicit in (6.10). For example, we can read off \nthat a is an N-coalgebra homomorphism. The second step should be routine by now. If we instantiate (a,A,c) \nto the initial . -bialgebra (in, \u00b5F,fan), we obtain that the unique solution of the original equation \n(6.1) is f = 1 lbJ l or, expressed using the vocabulary of [30], f = e B \u00b7 b . We record Theorem 6.3. \nA recursion scheme from the comonad N and the distributive law . : F . N ..N . F can be framed as an \nadjoint fold based on the Eilenberg-Moore adjunction UN -CofreeN, using the canonical control functor \nUN . F. . CofreeN = F . N. UN F.N C . F. CofreeN CN Let us conclude the section by investigating \nan alternative con\u00adtrol functor: since UN .F. = F.UN, the functor F itself can be used as the control! \nFor this case the distributive law s is an isomorph\u00adism, even an identity, so we can invoke the machinery \nof Section 5.5 and lift the adjunction UN -CofreeN to an adjunction between cat\u00adegories of algebras. \nThe conjugate of s = id is just . , we have UN . t = . . (The coherence condition (6.6b) shows that . \nis an N-coalgebra homomorphism of type F. .CofreeN ..CofreeN . F.) Uid N . F-Alg(C ) F. -Alg(CN) Cofreet \nN UF ~UF. -- FreeF = FreeF. UN F C .  F. CofreeN CN In the upper right corner we .nd the category \nof . -bialgebras (6.9). This shows that the underlying functor . -Bialg(C ) . F-Alg(C ), which forgets \nabout the algebra part, has a right adjoint. Since right adjoints preserve .nal objects, we immediately \nobtain that Cofreet (F 1 1,1) is the .nal bialgebra. N 7. When is an Adjoint Fold an Rsfc? We have seen \nthat all rsfcs are adjoint folds; and indeed, pre\u00advious work has shown that the two share some connection \nzygomorphisms have been modelled both by using rsfcs [30] and as adjoint folds [11]. But what about the \nreverse direction: when is an adjoint fold also modelled by using an rsfc? In this section we show that \nan adjoint fold based on the canonical control functor can be captured as an rsfc, if additionally a \ndistributive isomorphism exists. An adjoint fold is based on an adjunction L -R, and an rsfc on a comonad. \nThus, using Huber s result, an obvious choice for the comonad is N = L . R. However, we also need to \nmanufacture a distributive law . : F . N ..N . F. Now, one can show that a con\u00adjugate pair s -t of distributive \nlaws, where s is an isomorphism, induces a distributive law for an endofunctor over comonad [32]. Consequently, \nwe assume the following data (we rename F to C to bring the subsequent development in line with Section \n5.5): s : L . D ~= C . L -t : D . R ..R . C . These are the same assumptions as for the type fusion rule, \nCorol\u00adlary 5.5. We shall see shortly that this is not a mere coincidence. Under these assumptions we \naim to show that the following two diagrams are equivalent. On the left we have the diagram for adjoint \nfolds based on the canonical control functor (5.7); on the right we have the diagram for recursion schemes \nfrom comonads (6.1). L (D lxJ ) C (N f\u00b7fan) L (D (\u00b5D)) L (D (R B)) C (\u00b5C) C (N B) .. b1b\u00b7s. (R B)L in \nb in L (\u00b5D) B \u00b5C B x f The functions x and f are related by the isomorphism L (\u00b5D) ~\u00b5C, = provided \nby Corollary 5.5. The main task is to relate the upper arrows. To this end we derive a simple formula \nfor fan, which uses the assumption that N = L . R is a composition of adjoint functors. But .rst, we \nhave to set up the infrastructure. From the data above we can generate two distributive laws [32]: a \n= t - s. = R . s. \u00b7 t . L : D . M ..M . D , (7.1a) . = s. - t = L . t \u00b7 s. . R : C . N ..N . C . (7.1b) \nThe distributive law . satis.es the two requirements for . (6.6) (note that N. = Ls. .Rt); the distributive \nlaw a of an endofunctor over a monad enjoys analogous conditions: a \u00b7 D . . = . . D , (7.2a) a \u00b7 D . \n\u00b5 = \u00b5 . D \u00b7 M . a \u00b7 a . M . (7.2b) Next we construct an initial .-bialgebra. Since L (\u00b5D) ~ = \u00b5C, we \nknow that (Ls. in,L (\u00b5D)) is initial in C-Alg(C ). To determine a formula for fan, the corresponding \ncoalgebra part, we have to delve a bit deeper into the theory. The Eilenberg-Moore adjunction UN -CofreeN \nhas an important property: it is the largest adjunction that generates N, in the sense that for every \nadjunction L -R there is a unique adjoint square from L -R to UN -CofreeN, see the diagram on the left \nbelow. (Since the distributive laws of the adjoint square are identities, it is actually a so-called \nmap of adjunctions.) E. C C D-Alg(D) C. -Alg(CN) CofreeN UD L - R UN - UC. D CND CN E E The so-called \ncomparison functor E : D . CN is de.ned E A = (L A,L (. A)) , (7.3a) E f = L f . (7.3b) Since the distributive \nlaws of the adjoint square are identities, we have UN . E = Id . L and E . R = CofreeN . Id. Note that \nthe carrier of E A is L A, which suggests that the coalgebra part of the initial .-bialgebra is perhaps \njust L (. (\u00b5D)).   Then it remains to verify that Ls. in and L (. (\u00b5D)) satisfy the pentagonal law. \nWe prove, in fact, a slightly more general result: we show that (Ls. a,L A,L (. A)) is a .-bialgebra, \nby lifting the comparison functor E to categories of algebras, see diagram on the right above. To this \nend, we need a distributive law . : E . D ..C. . E. We claim that s. itself .ts the bill: UN . . = s.. \n(Note that UN .E .D ..UN . C. .E = L . D ..C .L). In other words, we have to show that s. is a natural \nN-coalgebra homomorphism of type E . D ..C. . E. Plugging in the de.nitions, we reason L . . . D \u00b7 s. \n= { a respects . (7.2a) }L . a \u00b7 L . D . . \u00b7 s. = { s. is natural }L . a \u00b7 s. . M \u00b7 C . L . . = { s. \n- a = s. - t - s. = . - s. }N . s. \u00b7 . . L \u00b7 C . L . . . We have derived the following attractive de.nition \nof fan: fan = L (. (\u00b5D)) , (7.4) which is in most cases a much more ef.cient implementation than N in \n\u00b7 . (\u00b5F) . We are now ready to show that adjoint folds are recursion schemes from comonads, provided \nthat a distributive isomorphism s : L . D ~ = C . L exists. Here is the diagram for rsfcs with applica\u00adtions \nof the isomorphism s made explicit. s (\u00b5D ) C (N x\u00b7fan ) s. (R B ) L (D (\u00b5D)) C (L (\u00b5D)) C (N B) L (D \n(R B)) Ls. b\u00b7s. (R B)L in bin L (\u00b5D) L (\u00b5D) B B x Thus, it remains to show that L lxJ = N x \u00b7 fan. \nL lxJ = { l-J expressed in terms of .; (3.4a) with k,f,h := x,id,id } L (R x \u00b7 . (\u00b5D)) = { L functor \nand de.nition of fan (7.4) } N x \u00b7 fan We record the result in the following Theorem 7.1. An adjoint \nfold based on the adjunction L -R and the canonical control functor can be framed as a recursion scheme \nfor the comonad N = L . R if there is a control functor C and a conjugate pair of distributive laws with \ns an isomorphism: s : L . D ~= C . L -t : D . R ..R . C . The distributive law . : C . N ..N . C is given \nby s. - t. Example 7.2. Mutumorphisms are an instance of rsfcs using s = id : . . D = D2 . ., see Example \n5.6. Since the isomorphism is an identity, we can transform the diagram for adjoints folds almost directly \ninto a corresponding diagram for rsfcs (A := \u00b5D). . (D lx J) D2 (. lx J) . (D A) . (D ((\u00d7) B)) D2 (. \nA)) D2 (. ((\u00d7) B)) .. . in b . in b . A B . A B x x In the upper right corner we discover the comonad \nN = . . (\u00d7), which works over a product category. As fan = . (id id), we have . lxJ = . ((\u00d7) x \u00b7 (id \nid)) = N x \u00b7 fan. If we identify . (\u00b5D) and \u00b5D2 so that . in = in, the diagram for rsfcs emerges. We \nhave seen in the previous section that an rsfc (based on a comonad N and a distributive law . : F . N \n..N . F) can be framed as an adjoint fold, which in turn is based on the Eilenberg-Moore adjunction UN \n-CofreeN. Now, what happens if we go round in a circle, instantiating the development above to D = F. \n, C = F, and id : UN . F. = F . UN? Recall that UN . t = . ; consequently, . = s. - t = UN . t \u00b7 id. \n. CofreeN = . . Hence, we obtain back the original rsfc! We have seen that mutumorphisms based on . -(\u00d7) \ncan be modelled by using an rsfc. Of course, this does not work for every adjunction. As an example, \nconsider the curry adjunction. One would need a control functor C such that: s : (- \u00d7 P) . D ~. = C . \n(- \u00d7 P) Such a control functor is not guaranteed to exist for all datatypes. 8. Related Work Adjoint \nfolds Mendler-style adjoint folds .rst appeared in a pa\u00adper by Bird and Paterson [4], where they were \nused to show that generalised folds are uniquely de.ned. (Somewhat ironically, ad\u00adjoint folds were only \nused in the proofs, not as a general recursion principle.) The algebraic variant of adjoint folds that \nwe have em\u00adployed throughout was introduced by Matthes and Uustalu [20] un\u00ad der the name generalised \niteration. The .rst author of the present paper explored the design space of adjoint folds [11], identifying \nthe adjunctions underlying various recursion schemes. The paper also shows how to combine recursion schemes \nby combining the underlying adjunctions. Alas, we wrote However, we cannot rea\u00adsonably expect that adjoint \n(un)folds subsume all existing species of morphisms. For instance, a largely orthogonal extension of \nstan\u00addard folds are recursion schemes from comonads. Recursion schemes from comonads Recursion schemes \nfrom comonads are due to Uustalu et al. [30]. Simultaneously and inde\u00ad pendently, Bartels [2] introduced \nthe dual construction under name . -coiteration. Technically, his work is closest to ours in the use \nof . -bialgebras, although our proofs differ considerably in that we make use of the Eilenberg-Moore \nconstruction. Bartels also discussed variations of the scheme that do not rely on a monad structure. \nThese and further variations were used in a recent ICFP paper [12] to prove the unique .xed-point principle \ncorrect. Categorical .xed-point calculus The roots of the initial algebra approach to the semantics of \ndatatypes can be traced back to the work of Lambek [16] on .xed points in categories. Lambek sug\u00ad gests \nthat lattice theory provides a fruitful source of inspiration for results in category theory. These ideas \nwere picked up by Back\u00adhouse et al. [1], where a number of lattice-theoretic .xed-point rules were generalised \nto categories, type fusion being one of them. Category theory Most of the category theory utilised in \nthis pa\u00adper is fairly standard [17] is a good reference except perhaps the material on distributive laws \nand conjugates. An extensive ac\u00adcount of the relationship between adjunctions and monads is pro\u00advided \nby Vidal and Tur [32]. Roughly speaking, they show that the Eilenberg-Moore construction is a right biadjoint \nto the Huber con\u00adstruction. 9. Conclusion As one might expect, everything dualises elegantly. There is \nin\u00adsuf.cient space to tell the full story here; but the essential fact is that adjoint unfolds subsume \nanamorphisms, apomorphisms, gen\u00aderalised unfolds, . -coiteration, futumorphisms, and other dual pat\u00adterns \nthat have not yet been formally christened. Table 1 provides an overview of the various morphisms and \ntheir duals, and shows how they are captured in the framework of adjoint (un)folds.  (a) catamorphism \n[10, 19] mutumorphism [8] special case: zygomorphism [18] special case: paramorphism [21] fold with a \nparameter [25] generalised fold [4] recursion scheme from a comonad [30] special case: histomorphism \n[26] Id -Id . -(\u00d7) - \u00d7 P -(-)P (- . P) -RanP UN -CofreeN depth even/odd perfect wc cat, depths total \nknapsack (b) anamorphism [10, 19] Id -Id (mutumorphism) (+) -. apomorphism [31] (generalised unfold) \nLanP -(- . P) . -coiteration [2] FreeM -UM special case: futumorphism [26]  Table 1. Adjoint folds \n(a) and unfolds (b); LanP and RanP are left and right Kan extensions, FreeM -UM is the Eilenberg-Moore \nadjunction This paper shows again the importance of adjunctions. They have played a pivotal role in the \ncategorical analysis of logic; we believe that will prove just as important in the theory of program\u00adming. \nThe uni.cation of recursion schemes we have presented is mathematically satisfying: in the economy of \nexpression it provides (for example, for reasoning about products in F-Alg(C )), and espe\u00adcially in the \nsimple reassurance it provides through things just .t\u00adting together in the right way. But it is more \nthan merely an intellec\u00adtual curiosity: the additional structure we have uncovered promises concrete \nreturns, too for example, through general techniques for combining different recursion schemes, by composing \nthe corre\u00adsponding adjunctions. In practice, most functions do indeed use a combination of recursion \nschemes (in particular, functions over parametric datatypes). In future work, we intend to explore the \ncalculational proper\u00adties of adjoint folds; our earlier paper [11] lists several laws, and it would be \ninteresting to know whether the laws for recursion schemes from comonads of Uustalu et al. [30] are instances \nof these. Another interesting direction is to explore the use of recur\u00adsive coalgebras [5] (or corecursive \nalgebras) in . -bialgebras. Acknowledgments This work has been funded by EPSRC grant number EP/J010995/1, \non Unifying Theories of Generic Programming. The authors would like to thank the anonymous reviewers \nand Jos\u00e9 Pedro Magalh\u00e3es for their helpful and constructive comments. References [1] R. Backhouse, M. \nBijsterveld, R. van Geldrop, and J. van der Woude, Categorical .xed point calculus, in CTCS, ser. LNCS, \nvol. 953. Springer, 1995, pp. 159 179. [2] F. Bartels, Generalised coinduction, Mathematical Structures \nin Computer Science, vol. 13, pp. 321 348, 2003. [3] R. Bird and O. de Moor, Algebra of Programming. \nLondon: Prentice Hall, 1997. [4] R. Bird and R. Paterson, Generalised folds for nested datatypes, Formal \nAspects of Computing, vol. 11, no. 2, pp. 200 222, 1999. [5] V. Capretta, T. Uustalu, and V. Vene, Recursive \ncoalgebras from comonads, Information and Computation, vol. 204, no. 4, pp. 437 468, 2006. [6] S. Eilenberg \nand J. C. Moore, Adjoint functors and triples, Illinois J. Math, vol. 9, no. 3, pp. 381 398, 1965. [7] \nM. M. Fokkinga, Law and order in algorithmics, Ph.D. dissertation, University of Twente, Feb. 1992. [8] \n , Tupling and mutumorphisms, The Squiggolist, vol. 1, no. 4, pp. 81 82, Jun. 1990. [9] J. Gibbons, Generic \ndownwards accumulations, Science of Com\u00adputer Programming, vol. 37, no. 1-3, pp. 37 65, 2000. [10] T. \nHagino, Category theoretic approach to data types, Ph.D. disser\u00adtation, University of Edinburgh, 1987. \n[11] R. Hinze, Adjoint folds and unfolds an extended study, Science of Computer Programming, Aug. 2012. \n[12] R. Hinze and D. W. James, Proving the unique .xed-point principle correct: an adventure with category \ntheory, in ICFP. ACM, 2011, pp. 359 371. [13] P. J. Huber, Homotopy theory in general categories, Math. \nAnn., vol. 144, pp. 361 385, 1961. [14] D. M. Kan, Adjoint functors, Trans. AMS, vol. 87, no. 2, pp. \n294 329, 1958. [15] H. Kleisli, Every standard construction is induced by a pair of adjoint functors, \nProc. AMS, vol. 16, no. 3, pp. 544 546, Jun. 1965. [16] J. Lambek, A .xpoint theorem for complete categories, \nMath. Zeitschr., vol. 103, pp. 151 161, 1968. [17] S. Mac Lane, Categories for the Working Mathematician, \n2nd ed., ser. Graduate Texts in Mathematics. Berlin: Springer-Verlag, 1998. [18] G. Malcolm, Algebraic \ndata types and program transformation, Ph.D. dissertation, University of Groningen, 1990. [19] , Data \nstructures and program transformation, Science of Com\u00adputer Programming, vol. 14, no. 2 3, pp. 255 280, \n1990. [20] R. Matthes and T. Uustalu, Substitution in non-wellfounded syntax with variable binding, TCS, \nvol. 327, no. 1 2, pp. 155 174, 2004. [21] L. Meertens, Paramorphisms, Formal Aspects of Computing, vol. \n4, pp. 413 424, 1992. [22] E. Meijer, M. Fokkinga, and R. Paterson, Functional programming with bananas, \nlenses, envelopes and barbed wire, in FPLCA, ser. LNCS, vol. 523. Springer, 1991, pp. 124 144. [23] N. \nP. Mendler, Inductive types and type constraints in the second\u00adorder lambda calculus, Ann. Pure Appl. \nLogic, vol. 51, no. 1 2, pp. 159 172, 1991. [24] P. H. Palmquist, The double category of adjoint squares, \nin Midwest Category Seminar V, ser. LNM. Springer, 1971, vol. 195, pp. 123 153. [25] A. Pardo, Generic \naccumulations, in Working Conference on Generic Programming, vol. 243. Kluwer Academic Publishers, Jul. \n2002, pp. 49 78. [26] T. Uustalu and V. Vene, Primitive (co)recursion and course-of-value (co)iteration, \ncategorically, Informatica, Lith. Acad. Sci., vol. 10, no. 1, pp. 5 26, 1999. [27] , Comonadic notions \nof computation, in CMCS, ser. ENTCS, vol. 203(5), 2008, pp. 263 284. [28] , Mendler-style inductive \ntypes, categorically, Nordic J. Com\u00adput., vol. 6, pp. 343 361, 1999. [29] , The recursion scheme from \nthe cofree recursive comonad, ENTCS, vol. 229, no. 5, pp. 135 157, 2011, proceedings of the Sec\u00adond Workshop \non Mathematically Structured Functional Program\u00adming (MSFP 2008). [30] T. Uustalu, V. Vene, and A. Pardo, \nRecursion schemes from comon\u00adads, Nordic J. Comput., vol. 8, pp. 366 390, Sep. 2001. [31] V. Vene and \nT. Uustalu, Functional programming with apomorphisms (corecursion), Proceedings of the Estonian Academy \nof Sciences: Physics, Mathematics, vol. 47, no. 3, pp. 147 161, 1998. [32] J. C. Vidal and J. S. Tur, \nKleisli and Eilenberg-Moore constructions as parts of biadjoint situations, Extracta Mathematicae, vol. \n25, no. 1, pp. 1 61, 2010.   \n\t\t\t", "proc_id": "2500365", "abstract": "<p>Folds over inductive datatypes are well understood and widely used. In their plain form, they are quite restricted; but many disparate generalisations have been proposed that enjoy similar calculational benefits. There have also been attempts to unify the various generalisations: two prominent such unifications are the 'recursion schemes from comonads' of Uustalu, Vene and Pardo, and our own 'adjoint folds'. Until now, these two unified schemes have appeared incompatible. We show that this appearance is illusory: in fact, adjoint folds subsume recursion schemes from comonads. The proof of this claim involves standard constructions in category theory that are nevertheless not well known in functional programming: Eilenberg-Moore categories and bialgebras.</p>", "authors": [{"name": "Ralf Hinze", "author_profile_id": "81548013859", "affiliation": "University of Oxford, Oxford, United Kingdom", "person_id": "P4261245", "email_address": "ralf.hinze@cs.ox.ac.uk", "orcid_id": ""}, {"name": "Nicolas Wu", "author_profile_id": "81548022559", "affiliation": "University of Oxford, Oxford, United Kingdom", "person_id": "P4261246", "email_address": "nicolas.wu@cs.ox.ac.uk", "orcid_id": ""}, {"name": "Jeremy Gibbons", "author_profile_id": "81339501222", "affiliation": "University of Oxford, Oxford, United Kingdom", "person_id": "P4261247", "email_address": "jeremy.gibbons@cs.ox.ac.uk", "orcid_id": ""}], "doi_number": "10.1145/2500365.2500578", "year": "2013", "article_id": "2500578", "conference": "ICFP", "title": "Unifying structured recursion schemes", "url": "http://dl.acm.org/citation.cfm?id=2500578"}