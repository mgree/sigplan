{"article_publication_date": "09-25-2013", "fulltext": "\n Mtac: A Monad for Typed Tactic Programming in Coq Beta Ziliani MPI-SWS beta@mpi-sws.org Derek Dreyer \nNeelakantan R. Krishnaswami MPI-SWS MPI-SWS dreyer@mpi-sws.org neelk@mpi-sws.org Abstract Effective \nsupport for custom proof automation is essential for large\u00adscale interactive proof development. However, \nexisting languages for automation via tactics either (a) provide no way to specify the behavior of tactics \nwithin the base logic of the accompanying theorem prover, or (b) rely on advanced type-theoretic machinery \nthat is not easily integrated into established theorem provers. We present Mtac, a lightweight but powerful \nextension to Coq that supports dependently-typed tactic programming. Mtac tactics have access to all \nthe features of ordinary Coq programming, as well as a new set of typed tactical primitives. We avoid \nthe need to touch the trusted kernel typechecker of Coq by encapsulating uses of these new tactical primitives \nin a monad, and instrumenting Coq so that it executes monadic tactics during type inference. Categories \nand Subject Descriptors D.3.3 [Programming Lan\u00adguages]: Language Constructs and Features Data types and \nstruc\u00adtures; F.3.1 [Logics and Meanings of Programs]: Specifying and Verifying and Reasoning about Programs \nMechanical veri.cation Keywords Interactive theorem proving; custom proof automation; Coq; monads; typed \nmeta-programming; tactics. 1. Introduction The past decade has seen a dramatic rise in both the popularity \nand sophistication of interactive theorem proving technology. Proof assistants like Coq and Isabelle \nare now eminently effective for formalizing research-grade mathematics [8, 9], verifying serious software \nsystems [15, 16, 32, 6], and, more broadly, enabling re\u00adsearchers to mechanize and breed con.dence in \ntheir results. Nev\u00adertheless, due to the challenging nature of the veri.cation problems to which these \ntools are applied, as well as the rich higher-order logics they employ, the mechanization of substantial \nproofs typi\u00adcally requires a signi.cant amount of manual effort. To alleviate this burden, theorem provers \nprovide facilities for custom proof automation, enabling users to instruct the system how to carry out \nobvious or oft-repeated proof steps automatically. In some systems like Coq, the base logic of the theorem \nprover Permission to make digital or hard copies of all or part of this work for personal or classroom \nuse is granted without fee provided that copies are not made or distributed for pro.t or commercial advantage \nand that copies bear this notice and the full citation on the .rst page. Copyrights for components of \nthis work owned by others than the author(s) must be honored. Abstracting with credit is permitted. To \ncopy otherwise, or republish, to post on servers or to redistribute to lists, requires prior speci.c \npermission and/or a fee. Request permissions from permissions@acm.org. ICFP 13, September 25 27, 2013, \nBoston, MA, USA. Copyright is held by the owner/author(s). Publication rights licensed to ACM. ACM 978-1-4503-2326-0/13/09. \n. . $15.00. http://dx.doi.org/10.1145/2500365.2500579 Aleksandar Nanevski Viktor Vafeiadis IMDEA Software \nInstitute MPI-SWS aleks.nanevski@imdea.org viktor@mpi-sws.org is powerful enough that one can use proof \nby re.ection to im\u00adplement automation routines within the base logic itself (e.g., [3]). However, this \napproach is applicable only to pure decision proce\u00addures, and requires them to be programmed in a restricted \nstyle (so that their totality is self-evident). In general, one may wish to write automation routines \nthat engage in activities that even a rich type system like Coq s does not sanction routines, for instance, \nthat do not (provably) terminate on all inputs, that inspect the intensional syntactic structure of terms, \nor that employ computational effects. Toward this end, theorem provers typically provide an addi\u00adtional \nlanguage for tactic programming. Tactics support general\u00adpurpose scripting of automation routines, as \nwell as .ne control over the state of an interactive proof. However, for most existing tactic languages \n(e.g., ML, Ltac), the price to pay for this freedom is that the behavior of a tactic lacks any static \nspeci.cation within the base logic of the theorem prover (such as, in Coq, a type). As a result of being \nuntyped, tactics are known to be dif.cult to com\u00adpose, debug, and maintain. A number of researchers have \ntherefore explored ways of sup\u00adporting typed tactic programming. One approach, exempli.ed by Delphin \n[23], Beluga [21], and most recently VeriML [29], is to keep a strict separation between the computational \ntactic lan\u00adguage and the base logic of the theorem prover, thus maintaining .exibility in what tactics \ncan do, but in addition employing rich type systems to encode strong static guarantees about tactic behav\u00adior. \nThe main downside of these systems is a pragmatic one: they are not programmable or usable interactively, \nand due to the ad\u00advanced type-theoretic machinery they rely on e.g., for Beluga and VeriML, contextual \nmodal type theory [20] it is not clear how to incorporate them into established interactive theorem provers. \nA rather different approach, proposed by Gonthier et al. [11] speci.cally in the context of Coq, is to \nencapsulate automation routines as overloaded lemmas. Like an ordinary lemma, an over\u00adloaded lemma has \na precise formal speci.cation in the form of a (dependent) Coq type. The key difference is that an overloaded \nlemma much like an overloaded function in Haskell is not proven (i.e., implemented) once and for all \nup front; instead, every time the lemma is applied to a particular goal, the system will run a user-speci.ed \nautomation routine in order to construct a proof on the .y for that particular instance of the lemma. \nTo program the automation routine, one uses Coq s canonical structure mecha\u00adnism to declare a set of \nproof-building rules implemented as Coq terms that will be .red in a predictable order by the Coq uni.ca\u00adtion \nalgorithm (but may or may not succeed). In effect, one encodes one s automation routine as a dependently-typed \nlogic program to be executed by Coq s type inference engine. The major bene.t of this approach is its \nintegration into Coq: it enables users to program tactics in Coq directly, rather than in a separate \nlanguage, while at the same time offering signi.cant addi\u00adtional expressive power beyond what is available \nin the base logic of Coq. The downside, however, is that the logic-programming style of canonical structures \nis in most cases not as natural a .t for tactics as a functional-programming style would be.1 Moreover, \ncanonical structures provide a relatively low-level language for writing tactics. The control .ow of \nsophisticated canonical struc\u00adture programs depends closely on how Coq type inference is imple\u00admented, \nand thus writing even simple tactics requires one to think at the level of the Coq uni.cation algorithm, \nsometimes embracing its limitations and sometimes working around them. To make up for this, Gonthier \net al. [11] describe a series of design patterns for programming canonical structures effectively. While \nthese design patterns are clearly useful, the desire for them nonetheless suggests that there is a high-level \nlanguage waiting to be born.  1.1 Mtac: A Monad for Typed Tactic Programming in Coq In this paper, we \npresent a new language Mtac for typed tactic programming in Coq. Like Beluga and VeriML, Mtac supports \ngeneral-purpose tactic programming in a direct functional style. Unlike those languages, however, Mtac \nis not a separate language, but rather a simple extension to Coq. As a result, Mtac tactics (or as we \ncall them, Mtactics) have access to all the features of ordinary Coq programming in addition to a new \nset of tactical primitives. Furthermore, like overloaded lemmas, their (partial) correctness is speci.ed \nstatically within the Coq type system itself, and they are fully integrated into Coq, so they can be \nprogrammed and used interactively. Mtac is thus, to our knowledge, the .rst language to support interactive, \ndependently-typed tactic programming. The key idea behind Mtac is dead simple. We encapsulate tactics \nin a monad, thus avoiding the need to change the base logic and trusted kernel typechecker of Coq at \nall. Then, we modify the Coq infrastructure so that it executes these monadic tactics, when requested \nto do so, during type inference (i.e., during interactive proof development or when executing a proof \nscript). More concretely, Mtac extends Coq with: 1. An inductive type family oA (read as maybe A ) classify\u00ading \nMtactics that if they terminate successfully will produce Coq terms of type A. The constructors of this \ntype family essen\u00adtially give the syntax for a monadically-typed tactic language: they include the usual \nmonadic return and bind, as well as a suite of combinators for tactic programming with .xed points, exception \nhandling, pattern matching, and more. (Note: the def\u00adinition of the type family oA does not per se require \nany ex\u00adtension to Coq it is just an ordinary inductive type family.) 2. A primitive tactic execution \nconstruct, run t, which has type A assuming its argument t is a tactic of type oA. When (our instrumentation \nof) the Coq type inference engine encounters run t, it executes the tactic t. If that execution terminates, \nit will either produce a term u of type A (in which case Coq will rewrite run t to u) or else an uncaught \nexception (which Coq will report to the user). If a proof passes entirely through type inference without \nincurring any uncaught exceptions, that means that all instances of run in the proof must have been replaced \nwith standard Coq terms. Hence, there is no need to extend the trusted kernel typechecker of Coq to handle \nrun.  Example: Searching in a List. To get a quick sense of what Mtac programming is like, consider \nthe example in Figure 1. Here, search is a tactical term of type .x : A. .s : list A. o(x . s). When \nexecuted, search x s will search for an element x (of type A) in a list s (of type list A), and if it \n.nds x in s, it will return a 1 In terms of expressivity, there are tradeoffs between the two styles \nfor further discussion, see \u00a76. 01 De.nition search (x : A) := 02 m.x f [s : list A] := 03 mmatch s as \ns return o(x . s ) with 04 | [l r] l ++ r . 05 mtry 06 il . f l; 07 ret (in or app l r x (or introl il)) \n08 with . 09 ir . f r; 10 ret (in or app l r x (or intror ir)) 11 end 12 13 14 | [s ] (x :: s ) . ret \n(in eq | [y s ] (y :: s ) . r . f s ; ) 15 ret (in cons y r) 16 17 | . raise NotFound end. Figure 1. \nMtactic for searching in a list. proof that x . s. Note, however, that search x s itself is just a Coq \nterm of monadic type o(x . s), and that the execution of the tactic will only occur when this term is \nrun. The implementation of search relies on four new features of Mtac that go beyond what is possible \nin ordinary Coq program\u00adming: it iterates using a potentially unbounded .xed point m.x (line 2), it case-analyzes \nthe input list s using a new mmatch con\u00adstructor (line 3), it raise-s an exception NotFound if the element \nx was not found (line 16), and this exception is caught and han\u00addled (for backtracking purposes) using \nmtry (line 5). These new features, which we will present in detail in \u00a72, are all constructors of the \ninductive type family oA. Regarding mmatch, the reason it is different from ordinary Coq match is that \nit supports pattern\u00admatching not only against primitive datatype constructors (e.g., nil and ::) but \nalso against arbitrary terms (e.g., applications of the ++ function for concatenating two lists). For \nexample, search starts out (line 4) by checking whether s is an application of ++ to two sub\u00adterms l \nand r. If so, it searches for x .rst in l and then in r. In this way, mmatch supports case analysis of \nthe intensional syntactic structure of open terms, in the manner of VeriML s holcase [29] and Beluga \ns case [21]. By run-ning search, we can now, for example, very easily prove the following lemma establishing \nthat z is in the list [x; y; z]: Lemma z in xyz (x y z : A) : z . [x; y; z] := run (search ) Note here \nthat we did not even need to supply the inputs to search explicitly: they were picked up from context, \nnamely the goal of the lemma (z . [x; y; z]), which Coq type inference proceeds to unify with the output \ntype of the Mtactic search.  1.2 Contributions and Overview In the remainder of this paper, we will: \n Describe the design of Mtac in detail (\u00a72).  Give a number of examples to concretely illustrate the \nbene.ts of Mtac programming (\u00a73).  Present the formalization of Mtac, along with meta-theoretic results \nsuch as type safety (\u00a74).  Explore some technical issues regarding the integration of Mtac into Coq \n(\u00a75).  Compare with related work and discuss future work (\u00a76).  The Coq patch and the examples can \nbe downloaded from: http://plv.mpi-sws.org/mtac  o : Type . Prop ret : .A. A . oA bind : .A B. oA . \n(A . oB) . oB raise : .A. Exception . oA mtry : .A. oA . (Exception . oA) . oA m.x : .A B. ((.x : A. \no(B x)) . (.x : A. o(B x))) . .x : A. o(B x) mmatch : .A B (t : A). list (Patt A B) . o(B t) print : \n.s : string. ounit nu : .A B. (A . oB) . oB abs : .A P x. P x . o(.y : A. P y) is var : .A. A . obool \nevar : .A. oA is evar : .A. A . obool Patt : .A (B : A . Type). Type Pbase : .A B (p : A) (b : o(B p)). \nPatt A B Ptele : .A B C. (.x : C. Patt A B) . Patt A B Figure 2. The o and Patt inductive types. 2. Mtac: \nA Language for Proof Automation In this section, we describe the syntax and typing of Mtac, our language \nfor typed proof automation. Syntax of Mtac. Mtac extends CIC, the Calculus of (co-)Inductive Constructions \n(see e.g., [2]), with a monadic type constructor oA, representing tactic computations returning results \nof type A, along with suitable introduction and elimination forms for such compu\u00adtations. We de.ne o \n: Type . Prop as a normal CIC inductive predicate with constructors re.ecting our syntax for tactic program\u00adming, \nwhich are shown in Fig. 2. (We prefer to de.ne o induc\u00adtively instead of axiomatizing it in order to \ncheaply ensure that we do not affect the logical consistency of CIC.) The o constructors include standard \nmonadic return and bind (ret, bind), primitives for throwing and handling exceptions (raise, mtry), a \n.xed point combinator (m.x), a pattern matching construct (mmatch), and a printing primitive useful for \ndebugging Mtactics (print). Mtac also provides more specialized operations for handling parameters and \nuni.cation variables (nu, abs, is var, evar, is evar), but we defer explanation of those features until \n\u00a73.2. First, let us clear up a somewhat technical point. The reason we de.ne o as an inductive predicate \n(i.e., whose return sort is Prop rather than Type) has to do with the handling of m.x. Speci.cally, in \norder to satisfy Coq s syntactic positivity condition on inductive de.nitions, we cannot declare m.x \ndirectly with the type given in Figure 2, since that type mentions the monadic type constructor o in \na negative position. To work around this, in the inductive de.nition of oA, we replace the m.x constructor \nwith a variant, m.x', in Mendler style [17, 14], i.e., in which references to o are substituted with \nreferences to a parameter 8: m.x' : .A B 8. (.x : A. 8(B x) . o(B x)) . ((.x:A. 8(B x)) . (.x:A. 8(B \nx))) . .x:A. o(B x) The m.x from Figure 2 is then recovered simply by instantiating the 8 parameter of \nm.x' with o, and instantiating its .rst value parameter with the identity function. However, due to the \ninherent circularity of this trick, it only works if the type oA belongs to an impredicative sort like \nProp. (In particular, if oA were de.ned in Type, then while m.x' would be well-formed, applying m.x' \nto the identity function in order to get an m.x would cause a universe inconsistency.) Fortunately, de.ning \noA in Prop has no practical impact on Mtac programming. Note that, in CIC, Prop : Type; so it is possible \nto construct nested types such as o(oA). Now, onto the features of Mtac. The typing of monadic ret and \nbind is self-explanatory. The exception constructs raise and mtry are also straightforward: their types \nassume the existence of an exception type Exception. It is easy to de.ne such a type, as well as a way \nof declaring new exceptions of that type, in existing Coq (see \u00a75 for details). The print statement print \ntakes the string to print onto the standard output and returns the trivial element. Pattern matching, \nmmatch, expects a term of type A and a se\u00adquence of pattern matching clauses of type Patt A B, which \nmatch objects x of type A and return results of type B x. Binding in the pattern matching clauses is \nrepresented as a telescope: Pbase p b describes a ground clause that matches the constant p and has body \nb, and Ptele(.x. pc) adds the binder x to the pattern matching clause pc. So, for example, Ptele(.x. \nPtele(.y. Pbase (x + y) b) represents the clause that matches an addition expression, binds the left \nsubexpression to x and the right one to y, and then returns some expression b which can mention both \nx and y. Another example is the clause, Ptele(.x. Pbase x b) which matches any term and re\u00adturns b. Note \nthat it is also .ne for a pattern to mention free variables bound in the ambient environment (i.e., not \nbound by the telescope pattern). Such patterns enable one to check that (some component of) the term \nbeing pattern-matched is syntactically uni.able with a speci.c term of interest. We will see examples \nof this in the search2 and lookup Mtactics in \u00a73. In our examples and in our Coq development, we often \nomit in\u00adferrable type annotations and use the following notation to improve readability of Mtactics: \n' x . t; tdenotes bind t (.x. t') m.x f [x : A] := t denotes m.x (.f. .x. t) . x : A. t denotes nu (.x \n: A. t) mmatch t mmatch (.x. T ) t as x return oT with [ | [x1] p1 . b1 Ptele x1 (Pbase p1 b1), . . . \ndenotes . . . | [xm] pm . bm Ptele xm (Pbase pm bm) end ] mtry t denotes mtry t (.e. with ps end mmatch \ne with ps end) where Ptele x1 \u00b7 \u00b7 \u00b7 xn p means Ptele(.x1 . . . Ptele(.xn. p)\u00b7 \u00b7 \u00b7). The type annotation \nas x return oT in the mmatch notation is optional and can be omitted, in which case the returning type \nis left to the type inference algorithm to infer. Running Mtactics. De.ning o as an inductive predicate \nmeans that terms of type oA can be destructed by case analysis and induction. Unlike other inductive \ntypes, o supports an additional destructor: tactic execution. Formally, we extend Coq with a new construct, \nrun t, that takes an Mtactic t of type oA (for some A), and runs it at type-inference time to return \na term t' of type A. ' G f t : oA G f t .* ret tG f run t : A We postpone the de.nition of the tactic \nevaluation relation, ., as well as a precise formulation of the rule, to \u00a74, but note that since tactic \nevaluation is type-preserving, t' has type A, and thus A is inhabited. 3. Mtac by Example In this section, \nwe offer a gentle introduction to the various fea\u00adtures of Mtac by working through a sequence of proof \nautomation examples.  3.1 noalias: Non-Aliasing of Disjointly Allocated Pointers Our .rst example, noalias, \nis taken from Gonthier et al. [11]. The goal is to prove that two pointers are distinct, given the assumption \nthat they appear in the domains of disjoint subheaps of a well\u00adde.ned memory. In [11], the noalias example \nwas used to illustrate a rather subtle and sophisticated design pattern for composition of overloaded \nlemmas. Here, it will help illustrate the main characteristics of Mtac, while at the same time emphasizing \nthe relative simplicity and readability of Mtactics compared to previous approaches. Preliminaries. We \nwill work here with heaps (of type heap), which are .nite maps from pointers (of type ptr) to values. \nWe write h1 h2 for the disjoint union of h1 and h2, and x . v for the singleton heap containing only \nthe pointer x, storing the value v. The disjoint union may be unde.ned if h1 and h2 overlap, so we employ \na predicate def h, which declares that h is in fact de.ned. Motivating Example. With these de.nitions \nin hand, let us state a goal we would like to solve automatically: D : def (h1 (x1 . v1 x2 . v2) (h2 \n x3 . v3)) x1 != x2 . x2 != x3 Above the line is a hypothesis concerning the well-de.nedness of a heap \nmentioning x1, x2, and x3, and below the line is the goal, which is to show that x1 is distinct from \nx2, and x2 from x3. Intuitively, the truth of the goal follows obviously from the fact that x1, x2, and \nx3 appear in disjoint subheaps of a well-de.ned heap. This intuition is made formal with the following \nlemma (in plain Coq): noalias manual : .(h:heap) (y1 y2:ptr) (w1:A1) (w2:A2). def (y1 . w1 y2 . w2 \nh) . y1 != y2 Unfortunately, we cannot apply this lemma using hypothesis D as it stands, since the heap \nthat D proves to be well-de.ned is not of the form required by the premise of the lemma that is, with \nthe pointers in question (x1 and x2, or x2 and x3) at the very front of the heap expression. It is of \ncourse possible to solve the goal by: (a) repeatedly applying rules of associativity and commutativity \nfor heap expressions in order to rearrange the heap in the type of D so that the relevant pointers are \nat the front of the heap expression; (b) applying the noalias manual lemma to solve the .rst inequality; \nand then repeating (a) and (b) to solve the second inequality. But we would like to do better. What we \nreally want is an Mtactic that will solve these kinds of goals automatically, no matter where the pointers \nwe care about are located inside the heap. One option is to write an Mtactic to perform all the rearrangements \nnecessary to put the two pointers at the front, and then apply the lemma above. The main inconvenience \nwith this approach is that each inequality in the goal requires a new rearrangement of the heap, where \neach pointer has to be found and then bubbled up to the front of the heap. Computationally, this takes \ntwice the size of the heap for each pointer. Instead, we pursue a solution analogous to the one in [11], \nbreaking the problem into two smaller Mtactics scan and search2, combined in a third Mtactic, noalias. \nThe Mtactic scan. Figure 3 presents the Mtactic scan. It scans its input heap h to produce a list of \nthe pointers x appearing in singleton heaps x . v in h. More speci.cally, it returns a dependent record \ncontaining a list of pointers (seq of, of type list ptr), together with a proof that, if h is well-de.ned, \nthen (1) the list seq of is unique (denoted uniq seq of), meaning that all elements in it are distinct \nfrom one another, and (2) its elements all belong to the domain of the heap. To do this, scan inspects \nthe heap and considers three different cases. If the heap is a singleton heap x . v, then it returns \na 01 Record form h := Form { 02 seq of :> list ptr; 03 axiom of : def h . uniq seq of 04 . . x. x . seq \nof . x . dom h }. 05 06 De.nition scan := 07 m.x f [h : heap] : o(form h) := 08 mmatch h with 09 | [x \nA (v:A)] x . v . ret (Form [x] ...) 10 | [l r] l r . 11 rl . f l; 12 rr . f r; 13 ret (Form (seq of \nrl ++ seq of rr) ...) 14 | [h ] h . ret (scan h [] ...) 15 end. Figure 3. Mtactic for scanning a heap \nto obtain a list of pointers. 01 De.nition search2 x y := 02 m.x f [s] : o(uniq s . x != y) := 03 mmatch \ns with 04 05 06 07 08 | [s ] x :: s . r . search y s ; ret (foundx pf x r) | [s ] y :: s . r . search \nx s ; ret (foundy pf y r) | [z s ] z :: s . r . f s ; ret (foundz pf z r) | . raise NotFound end. Figure \n4. Mtactic for searching for two pointers in a list. singleton list containing x. If the heap is the \ndisjoint union of heaps l and r, it proceeds recursively on each subheap and returns the concatenation \nof the lists obtained in the recursive calls. Finally, if the heap doesn t match any of the previous \ncases, then it returns an empty list. Note that this case analysis is not possible using Coq s standard \nmatch mechanism, because match only pattern-matches against primitive datatype constructors. In the case \nof heaps, which are really .nite maps from pointers to values, x . v and l r are applications not of \nprimitive dataype constructors but of de.ned functions ( . and ). Thus, in order to perform our desired \ncase analysis, we require the ability of Mtac s mmatch mechanism to pattern-match against the syntax \nof heap expressions. In each case, scan also returns a proof that the output list obeys the aforementioned \nproperties (1) and (2). For presentation purposes, we omit these proofs (denoted with . . . in the .gures), \nbut they are proven as standard Coq lemmas. (We will continue to omit proofs in this way throughout the \npaper when they present no interesting challenges. The reader can .nd them in the source .les.) The Mtactic \nsearch2. Figure 4 presents the Mtactic search2. It takes two elements x and y and a list s as input, \nand searches for x and y in s. If successful, search2 returns a proof that, if s is unique, then x is \ndistinct from y. Similarly to scan, this involves a syntactic inspection and case analysis of the input \nlist s. When s contains x at the head (i.e., s is of the form x :: s '), search2 searches for y in the \ntail s ', using the Mtactic search from \u00a71.1. If this search is successful, producing a proof r : y . \ns ' , then search2 concludes by composing this proof together with the assumption that s is unique, using \nthe easy lemma foundx pf: foundx pf : .x y : ptr. .s : list ptr. y . s . uniq (x :: s) . x != y (In the \ncode, the reader will notice that foundx pf is not passed the arguments y and s explicitly. That is because \nthey are inferrable from the type of r, and thus are treated as implicit arguments.)  De.nition noalias \nh (D : def h) : o(. x y. o(x != y)) := 01 Program De.nition interactive search2 x y := sc . scan h; ret \n(. x y . s2 . search2 x y (seq of sc); ret (combine s2 D)). Figure 5. Mtactic for proving that two pointers \ndo not alias. If s contains y at the head, search2 proceeds analogously. If the head element is different \nfrom both x and y, then it calls itself recursively with the tail. In any other case, it throws an exception. \nNote that, in order to test whether the head of s is x or y, we rely crucially on the ability of patterns \nto mention free variables from the context. In particular, the difference between the .rst two cases \nof search2 s mmatch and the last one is that the .rst two do not bind x and y in their telescope patterns \n(thus requiring the head of the list in those cases to be syntactically uni.able with x or y, respectively), \nwhile the third does bind z in its telescope pattern (thus enabling z to match anything). The Mtactic \nnoalias. Figure 5 shows the very short code for the Mtactic noalias, which stitches scan and search2 \ntogether. The type of noalias is as follows: .h : heap. def h . o(.x y. o(x != y)) As the two occurrences \nof o indicate, this Mtactic is staged: it takes as input a proof that h is de.ned and .rst runs the scan \nMtactic on h, producing a list of pointers sc, but then it immediately returns another Mtactic. This \nlatter Mtactic in turn takes as input x and y and searches for them in sc. The reason for this staging \nis that we may wish to prove non-aliasing facts about different pairs of pointers in the same heap. Thanks \nto staging, we can apply noalias to some D just once and then reuse the Mtactic it returns on many different \npairs of pointers, thus avoiding the need to rescan h redundantly. At the end, the proofs returned by \nthe calls to scan and search2 are composed using a combine lemma with the following type: Lemma combine \nh x y (sc : form h) : (uniq (seq of sc) . x != y) . def h . x != y. This lemma is trivial to prove by \nan application of the cut rule. Applying the Mtactic noalias. The following script shows how noalias \ncan be invoked in order to solve the motivating example from the beginning of this section: pose F := \nrun (noalias D) by split; apply: run (F ) When Coq performs type inference on the run in the .rst line, \nthat forces the execution of (the .rst scan-ning phase of) the Mtac\u00adtic noalias on the input hypothesis \nD, and the standard pose mech\u00adanism then binds the result to F . This F has the type .x y : ptr. o(x \n!= y) In the case of our motivating example, F will be an Mtactic that, when passed inputs x and y, will \nsearch for those pointers in the list [x1; x2; x3] output by the scan phase. The script continues with \nCoq s standard split tactic, which gen\u00aderates two subgoals, one for each proposition in the conjunction. \nFor our motivating example, it generates subgoals x1 != x2 and x2 != x3. We then solve both goals by \nexecuting the Mtactic F . When F is run to solve the .rst subgoal, it will search for x1 and x2 in [x1; \nx2; x3] and succeed; when F is run to solve the second subgoal, it will search for x2 and x3 in [x1; \nx2; x3] and succeed. QED. Note that we provide the arguments to F implicitly (as ). As in the proof of \nthe z in xyz lemma from \u00a71.1, these arguments are 02 m.x f [s] : o(uniq s . x != y) := 03 mmatch s with \n04 | [s ] x :: s . r . search y s ; ret 05 | [s ] y :: s . r . search x s ; ret 06 | [z s ] z :: s . \nr . f s ; ret 07 | . raise NotFound 08 end. 09 Next Obligation. ... Qed. 10 Next Obligation. ... Qed. \n11 Next Obligation. ... Qed. Figure 6. Interactive construction of search2 using Program. inferred from \nthe respective goals being solved. (We will explain how this inference works in more detail in \u00a75.) Developing \nMtactics Interactively. One key advantage of Mtac is that it works very well with the rest of Coq, allowing \nus among other things to develop Mtactics interactively. For instance, consider the code shown in Figure \n6. This is an in\u00adteractive development of the search2 Mtactic, where the developer knows the overall \nsearch structure in advance, but not the exact proof terms to be returned, as this can be dif.cult in \ngeneral. Here, we have pre.xed the de.nition with the keyword Program [27], which allows us to omit certain \nparts of the de.nition by writing underscores. Program instructs the type inference mechanism to treat \nthese underscores as uni.cation variables, which unless in\u00adstantiated during type inference are exposed \nas proof obligations. In our case, none of these underscores is resolved, and so we are left with three \nproof obligations. Each of these obligations can then be solved interactively within a Next Obligation \n. . . Qed block. Finally, it is worth pointing out that within such blocks, as well as within the actual \nde.nitions of Mtactics, we could be running other more primitive Mtactics.  3.2 tauto: A Simple First-Order \nTautology Prover With this next example, we show how Mtac provides a simple but useful way to write tactics \nthat manipulate contexts and binders. Speci.cally, we will write an Mtactic implementing a rudimen\u00adtary \ntautology prover, modeled after those found in the work on VeriML [29] and Chlipala s CPDT textbook [5]. \nCompared to VeriML, our approach has the bene.t that it does not require any special type-theoretic treatment \nof contexts: for us, a context is nothing more than a Coq list. Compared to Chlipala s Ltac version, \nour version is typed, offering a clear static speci.cation of what the tautology prover produces, if \nit succeeds. To ease the presentation, we break the problem in two. First, we show a simple propositional \nprover that uses the language constructs we have presented so far. Second, we extend this prover to handle \n.rst-order logic, and we use this extension to motivate some additional features of Mtac. Warming up \nthe Engine: A Simple Propositional Prover. Fig\u00adure 7 displays the Mtactic for a simple propositional \nprover, taking as input a proposition p and, if successful, returning a proof of p: prop-tauto : .p : \nProp. op The Mtactic only considers three cases: p is True. In this case, it returns the trivial proof \nI.  p is a conjunction of p1 and p2. In this case, it proves both propositions and returns the introduction \nform of the conjunc\u00adtion (conj r1 r2).  p is a disjunction of p1 and p2. In this case, it tries to prove \nthe proposition p1, and if that fails, it tries instead to prove   01 De.nition prop-tauto := 02 m.x \nf [p : Prop] : op := 03 mmatch p as p return op with 04 | True . ret I 05 | [p1 p2] p1 . p2 . 06 r1 . \nf p1; 07 r2 . f p2; 08 ret (conj r1 r2) 09 | [p1 p2] p1 . p2 . 10 mtry 11 r1 . f p1; ret (or introl r1) \n12 with . 13 r2 . f p2; ret (or intror r2) 14 end 15 | . raise NotFound 16 end. Figure 7. Mtactic for \na simple propositional tautology prover. 01 De.nition tauto := 02 m.x f [c : list dyn; p : Prop] : op \n:= 03 mmatch p as p return op with 04 | True . ret I 05 | [p1 p2] p1 . p2 . 06 r1 . f c p1 ; 07 r2 . \nf c p2 ; 08 ret (conj r1 r2) 09 | [p1 p2] p1 . p2 . 10 mtry 11 r1 . f c p1 ; ret (or introl r1) 12 with \n. 13 r2 . f c p2 ; ret (or intror r2) 14 end 15 | [p1 p2 : Prop] p1 . p2 . 16 . (y:p1). 17 r . f (Dyn \np1 y :: c) p2; 18 abs y r 19 | [A (q:A . Prop)] (. x:A. q x) . 20 . (y:A). 21 r . f c (q y); 22 abs y \nr 23 | [A (q:A . Prop)] (. x:A. q x) . 24 X . evar A; 25 r . f c (q X ); 26 b . is evar X; 27 if b then \nraise ProofNotFound 28 else ret (ex intro q X r) 29 | [p :Prop] p . lookup p c 30 end. Figure 8. Mtactic \nfor a simple .rst-order tautology prover. the proposition p2. The corresponding introduction form of \nthe disjunction is returned (or introl r1 or or intror r2). Otherwise, it raises an exception, since \nno proof could be found. Extending to First-Order Logic. We now extend the previous prover to support \n.rst-order logic. This extension requires the tactic to keep track of a context for hypotheses, which \nwe model as a list of (dependent) pairs pairing hypotheses with their proofs. More concretely, each element \nin the hypothesis context has the type dyn = Sp : Prop. p. (In Coq, this is encoded as an inductive type \nwith constructor Dyn p x, for any x : p.) De.nition lookup (p : Prop) := m.x f [s : list dyn] : op := \nmmatch s return op with | [x s ] (Dyn p x) :: s . ret x | [d s ] d :: s . f s | . raise ProofNotFound \nend. Figure 9. Mtactic to look up a proof of a proposition in a context. Figure 8 shows the .rst-order \nlogic tautology prover tauto. The .xed point takes the proposition p and is additionally parameterized \nover a context (c : list dyn). The .rst three cases of the mmatch are similar to the ones in Figure 7, \nwith the addition that the context is passed around in recursive calls. Before explaining the cases for \n., . and ., let us start with the last one (line 29), since it is the easiest. In this last case, we \nattempt to prove the proposition in question by simply searching for it in the hypothesis context. The \nsearch for the hypothesis p ' in the context c is achieved using the Mtactic lookup shown in Figure 9. \nlookup takes a proposition p and a context, and traverses the context linearly in the hope of .nding \na dependent pair with p as the .rst component. If it .nds such a pair, it returns the second component. \nLike the Mtactic search2 from \u00a73.1, this simple lookup routine depends crucially on the ability to match \nthe propositions in the context syntactically against the p for which we are searching. Returning to \nthe tautology prover, lines 15 18 concern the case where p = p1 . p2. Intuitively, in order to prove \np1 . p2, one would (1) introduce a parameter y witnessing the proof of p1 into the context, (2) proceed \nto prove p2 having y : p1 as an assumption, and (3) abstract any usage of y in the resulting proof. The \nrationale behind this last step is that if we succeed proving p2, then the result is parametric over \nthe proof of p1, in the sense that any proof of p1 will suf.ce to prove p2. Steps (1) and (3) are performed \nby two of the operators we haven t yet described: nu and abs (the former is denoted by the . x binder). \nIn more detail, the three steps are: Line 16: It creates a parameter y : p1 using the constructor nu. \nThis constructor has type nu : .(A B : Type). (A . oB) . oB (where A and B are left implicit). It is \nsimilar to the operator with the same name in [19] and [26]. Operationally, . x : A. f (which is notation \nfor nu (.x : A. f )), creates a parameter y with type A, pushes it into the local context, and executes \nf{y/x} (where \u00b7{\u00b7/\u00b7} is the standard substitution) in the hope of getting a value of type B. If the value \nreturned by f refers to y, then it causes the tactic execution to fail: such a result would lead to an \nill-formed term because y is not bound in the ambient context. This line constitutes the .rst step of \nour intuitive reasoning: we introduce the parameter y witnessing the proof of p1 into the context. Line \n17: It calls tauto ' recursively, with context c extended with the parameter y, and with the goal of \nproving p2. The result is bound to r. This line constitutes the second step. Line 18: The result r created \nin the previous step has type p2. In order to return an element of the type p1 . p2, we abstract y from \nr, using the constructor abs : .(A : Type) (P : A . Type) (y : A). P y . o(.x : A. P x) (with A, P implicit). \nOperationally, abs y r checks that the .rst parameter y is indeed a variable, and returns the function \n.x : A. r{x/y}  In this case, the resulting element has type .x : p1. p2, which, since p2 does not refer \nto x, is equivalent to p1 . p2. This constitutes the last step: by abstracting over y in the result, \nwe ensure that the resulting proof term no longer mentions the .\u00adbound variable (as required by the use \nof nu in line 16). Lines 19 22 consider the case that the proposition is an abstrac\u00adtion .x : A. q x. \nHere, q is the body of the abstraction, represented as a function from A to Prop. We rely on Coq s use \nof higher-order pattern uni.cation [18] to instantiate q with a faithful representation of the body. \nThe following lines mirrors the body of the previous case, except for the recursive call. In this case \nwe don t extend the context with the parameter y, since it is not a proposition. Instead, we try to recursively \nprove the body q replacing x with y (that is, applying q to y). If the proposition is an existential \n.x : A. q x (line 23), then the prover performs the following steps: Line 24: It uses Mtac s evar constructor \nto create a fresh uni.ca\u00adtion variable called X. Line 25: It calls tauto ' recursively, replacing x for \nX in the body of the existential. Lines 26 28: It uses Mtac s is evar mechanism to check whether X is \nstill an uninstantiated uni.cation variable. If it is, then it raises an exception, since no proof could \nbe found. If it is not that is, if X was successfully instantiated in the recursive call then it returns \nthe introduction form of the existential, with X as its witness. Now we are ready to prove an example, \nwhere P : nat . Prop: De.nition exmpl : .P x. P x . .y. P y := run (tauto [] ). The proof term generated \nby run is exmpl = .P x (H : P x). ex intro P x H  3.3 Inlined Proof Automation Due to the tight integration \nbetween Mtac and Coq, Mtactics can be usefully employed in de.nitions, notations and other Coq terms, \nin addition to interactive proving. In this respect, Mtac differs from the related systems such as VeriML \n[29] and Beluga [21], where, to the best of our knowledge, such expressiveness is not currently available \ndue to the strict separation between the object logic and the automation language. In this section, we \nillustrate how Mtactics can be invoked from Coq proper. To set the stage, consider the scenario of developing \na library for n-dimensional integer vector spaces, with the main type vector n de.ned as a record containing \na list of nats and a proof that the list has size n: Record vector (n : nat) := Vector {seq of : list \nnat; : size seq of = n}. One of the important methods of the library is the accessor function ith, which \nreturns the i-th element of the vector, for i < n. One implementation possibility is for ith to check \nat run time if i < n, and return an option value to signal when i is out of bounds. The downside of this \napproach is that the clients of ith have to explicitly discriminate against the option value. An alternative \nis for ith to explicitly request a proof that i < n as one of its arguments, as in the following type \nascription: ith : .n:nat.vector n . .i:nat.i < n . nat Then the clients have to construct a proof of \ni < n before invoking ith, but we show that in some common situations, the proof can be constructed automatically \nby Mtac, and then passed to ith. Program De.nition compare (n1 n2 : nat) : o(n1 = n2) := r1 . to ast \nnil n1; r2 . to ast (ctx of r1) n2; match cancel (ctx of r2) (term of r1) (term of r2) return o(n1 = \nn2) with | true . ret (@sound n1 n2 r1 r2 ) | . raise NotLeqException end. Next Obligation. ... Qed. \nFigure 10. Mtactic for proving inequalities between nat s. Speci.cally, we describe an Mtactic compare, \nwhich automati\u00adcally searches for a proof that two natural numbers n1 and n2 sat\u00adisfy n1 = n2. compare \nis incomplete, and if it fails to .nd a proof, because the inequality doesn t hold, or because the proof \nis too complex, it raises an exception. Once compare is implemented, it can be composed with ith as follows. \nGiven a vector v whose size we denote as vsize v, and an integer i, we introduce the following notation, \nwhich invokes compare to automatically construct a proof that i + 1 = vsize v (equivalent to i < vsize \nv). Notation [ ith v i ] := (@ith v i (run (compare (i+1) (vsize v)))) The notation can be used in de.nitions. \nFor example, given vectors v1, v2 of .xed size 2, we could de.ne the inner product of v1 and v2 as follows, \nletting Coq .gure out automatically that the indices 0, 1 are within bounds. De.nition inner prod (v1 \nv2 : vector 2) := [ith v1 0] \u00d7 [ith v2 0] + [ith v1 1] \u00d7 [ith v2 1]. If we tried to add the summand [ith \nv1 2] \u00d7 [ith v2 2], where the index 2 is out of bounds, then compare raises an exception, making the \nwhole de.nition ill-typed. Similarly, if instead of vector 2, we used the type vector n, where n is a \nvariable, the de.nition will be ill-typed, because there is no guarantee that n is larger than 1. On \nthe other hand, the following is a well-typed de.nition, as the indices k and n are clearly within the \nbound n + k + 1. De.nition indexing n k (v : vector (n + k + 1)) := [ith v k] + [ith v n]. We proceed \nto describe the implementation of compare, pre\u00adsented in Figure 10. compare is implemented using two \nmain helper functions. The .rst is the Mtactic to ast which re.ects the numbers n1 and n2. More concretely, \nto ast takes an integer ex\u00adpression, and considers it as a syntactic summation of a number of components. \nIt parses this syntactic summation into an explicit list of summands, each of which can be either a constant \nor a free vari\u00adable (subexpressions containing operations other than + are treated as free variables). \nThe second helper is a CIC function cancel which cancels the common terms from the syntax lists obtained \nby re.ecting n1 and n2. If all the summands in the syntax list of n1 are found in the syntax list of \nn2, then it must be that n1 = n2 and cancel returns the boolean true. Otherwise, cancel doesn t search \nfor other ways of proving n1 = n2 and simply returns false to signal the failure to .nd a proof. This \nfailure ultimately results in compare raising an exception. Notice that cancel can t directly work on \nn1 and n2, but has to receive their syntactic representation from to ast (in the code of compare these \nare named term of r1 and term of r2, respectively). The reason is that cancel has to compare names of \nvariables appearing in n1 and n2, and has to match against the occurrences of the (non-constructor) function \n+, and such comparisons and matchings are not possible in CIC.  Alternatively, we could use mmatch to \nimplement cancel in Mtac, but there are good reasons to prefer a purely functional Coq implementation \nwhen one is possible, as is the case here. With a pure cancel, compare can return a very short proof \nterm as a result (e.g., (sound n1 n2 r1 r2 ) in the code of compare). An Mtac implementation would have \nto expose the reasoning behind the soundness of the Mtactic at a much .ner granularity, resulting in \na larger proof. We next describe the implementations of the two helpers. Data Structures for Re.ection. \nThere are two main data struc\u00adtures used for re.ecting integer expressions. As each expression is built \nout of variables, constants and +, we syntactically represent the sum as term containing a list of syntactic \nrepresentations of variables appearing in the expression, followed by a nat constant that sums up all \nthe constants from the expression. We also need a type of variable contexts ctx, in order to determine \nthe syntactic representation of variables. In our case, a variable context is sim\u00adply a list of nat expression, \neach element standing for a different variable, and the position of the variable in the context serves \nas the variable s syntactic representative. De.nition ctx := list nat Record var := Var of nat De.nition \nterm := (list var) \u00d7 nat Example 1. The expression n = (1 +x)+(y+ 3) may be re.ected using a variable \ncontext c = [x, y], and a term ([Var 0, Var 1], 4). Var 0 and Var 1 correspond to the two variables in \nc (x and y, respectively). 4 is the sum of the constants appearing in n. Example 2. The syntactic representations \nof 0, successor construc\u00adtor S, addition and an individual variable, may be given as follow\u00ading term \nconstructors. We use .1 and .2 to denote projections out of a pair. De.nition syn zero : term := (nil, \n0). De.nition syn succ (t : term) := (t.1, t.2 + 1). De.nition syn add (t1 t2 : term) := (t1.1 ++ t2.1, \nt1.2 + t2.2). De.nition syn var (i : nat) := ([Var i], 0). In prose, 0 is re.ected by an empty list of \nvariable indexes, and 0 as a constant term; if t is a term re.ecting n, then the successor S n is re.ected \nby incrementing the constant component of t, etc. We further need a function interp that takes a variable \ncontext G and a term t, and interprets t into a nat, as follows. interp vars (G : ctx) (t : list var) \n:= if t is j :: t then if (vlook G j, interp G t ) is (Some v, Some e) then Some (v + e) else None else \nSome 0. interp (G : ctx) (t : term) := if interp vars G t.1 is Some e then Some (e + t.2) else None. \nFirst, interp vars traverses the list of variable indices of t, turning each index into a natural number \nby looking it up into the context G, and summing the results. The lookup function vlook G j is omitted \nhere, but it either returns Some j-th element of the context G, or None if G has less than j elements. \nThen, interp simply adds the result of interp vars to the constant part of the term. For example, if \nthe context c = [x, y] and term t = ([Var 0, Var 1], 4), then interp c t equals Some (x + y + 4). Re.ection \nby to ast. The to ast Mtactic is applied twice in compare: once to re.ect n1, and again to re.ect n2. \nEach time, Record ast (G : ctx) (n : nat) := Ast {term of : term; ctx of : ctx; : interp ctx of term \nof = Some n . pre.x G ctx of} De.nition to ast : . G n. o(ast G n) := m.x f [G ; n] := mmatch n with \n| 0 . ret (Ast G 0 syn zero G ...) | [n ] S n . r . f G n ; ret (Ast G (S n ) (syn succ (term of r)) \n(ctx of r) ...) | [n1 n2] n1 + n2 . r1 . f G n1; r2 . f (ctx of r1) n2; ret (Ast G (n1 + n2) (syn add \n(term of r1) (term of r2)) (ctx of r2) ...) | . ctx index . .nd n G; ret (Ast G n (syn var ctx index.2) \nctx index.1 ...) end. Figure 11. Mtactic for re.ecting nat expressions. Fixpoint cancel vars (G : ctx) \n(s1 s2 : list var) : bool := if s1 is v :: s1 then v . s2 &#38;&#38; cancel vars G s1 (remove var v \ns2) else true. De.nition cancel (G : ctx) (t1 t2 : term) : bool := cancel vars G t1.1 t2.1 &#38;&#38; \nt1.2 = t2.2. Figure 12. Algorithm for canceling common variables from terms. to ast is passed as input \na variable context, and extends this con\u00adtext with new variables encountered during re.ection. To re.ect \nn1 in compare, to ast starts with the empty context nil, and to re.ect n2, it starts with the context \nobtained after the re.ection of n1. This ensures that if the re.ections of n1 and n2 encounter the same \nvariables, they will use the same syntactic representations for them. The invariants associated with \nto ast are encoded in the data structure ast (Figure 11). ast is indexed by the input context G and the \nnumber n to be re.ected. Upon successful termination of to ast, the term of .eld contains the term re.ecting \nn, and the ctx of .eld contains the new variable context, potentially extending G. The third .eld of \nast is a proof formalizing the described properties of term of and ctx of. Referring to Figure 11, the \nMtactic to ast takes the input vari\u00adable context G and the number n to be re.ected, and traverses n trying \nto syntactically match the head construct of n with 0, S or +, respectively. In each case it returns \nan ast structure containing the syntactic representation of n, e.g.: syn zero, syn succ or syn add, respectively. \nIn the n1 + n2 case, to ast recurses into n2 by using the variable context returned from re.ection of \nn1 as an input, sim\u00adilar as in compare. In each case, the Ast constructor is supplied a proof that we \nomit but can be found in the sources. In the default case, when no constructor matches, n is treated \nas a variable. The Mtactic .nd n G (omitted here), searches for n in G, and returns a ctx \u00d7 nat pair. \nIf n is found, the pair consists of the old context G, and the position of n in G. If n is not found, \nthe pair consists of a new context in which n is cons-ed to G, and the index k, where k is the index \nof n in the new context. to ast then repackages the context and the index into an ast structure. Canceling \nCommon Variables. The cancel function is presented in Figure 12. It takes a variable context G, and terms \nt1 and t2 and tries to determine if t1 and t2 syntactically represent two =-related  ' G; S f t whd \nt G f (S; t) (S; t ') m.x f t f (m.x f) t t t ' t t ' bind t f bind t ' f mtry t f mtry t ' f bind (ret \nt) f f t bind (raise t) f raise t mtry (ret t) f ret t mtry (raise t) f f t psi whd* Ptele x (Pbase p \nb) S, ?y f p{?y/x} t e S ' , ?y := t ' .j < i. psj does not unify with t G f (S; mmatch t ps) (S' ; \nb{t '/x}) ?x /. dom(S) (S; evarA) (S, ?x : A; ret ?x) whd* whd* e ?x (?x := ) ./S e t t not unif. variable \n(S; is evar e) (S; ret true) (S; is evar e) (S; ret false) G, x : A f (S; t) (S ' ; t ' ) x /. FV(v) \nG f (S; . x : A. t) (S' ; .x : A. t') (. x. v) v e whd* x (x : A) . G (* print s to stdout *) G f abs \ne t ret (.y. t{y/x}) print s ret . Figure 13. Operational small-step semantics. expressions by cancelling \ncommon terms, as we described previ\u00adously. First, the helper cancel vars iterates over the list of variable \nrepresentations of t1, trying to match each one with a variable rep\u00adresentation in t2 (in the process, \nremoving the matched variables by using yet another helper function remove vars, omitted here). If the \nmatching is successful and all variables of t1 are included in t2, then cancel merely needs to check \nif the constant of t1 is smaller than the constant of t2. We conclude the example with the statement \nof the correctness lemma of cancel, which is the key component of the soundness proof for compare. We \nomit the proof here, but it can be found in our Coq .les. Lemma sound n1 n2 (a1 : ast [] n1) (a2 : ast \n(ctx of a1) n2) : cancel (ctx of a2) (term of a1) (term of a2) . n1 = n2. In prose, let a1 and a2 be \nre.ections of n1 and n2 respectively, where the re.ection of a1 starts in the empty context, and the \nre.ection of a2 starts in the variable context returned by a1. Then running cancel in the .nal context \nof a2 over the re.ected terms of a1 and a2 returns true only when it is correct to do so; that is, only \nwhen n1 = n2. 4. Operational Semantics In this section, we let e, e ' range over CIC terms and t, t ' \nover Mtac\u00adtics, i.e., CIC terms of type oA for some type A. The operational semantics of Mtac de.nes \nthe judgment form G f (S; t) (S ' ; t ' ) where G is the typing context containing parameters and (let\u00adbound) \nlocal de.nitions, while S and S ' are contexts for uni.\u00adcation variables ?x. Both kinds of contexts contain \nboth variable declarations (standing for parameters and uninstantiated uni.ca\u00adtion variables, respectively) \nand de.nitions (let-bound variables and instantiated uni.cation variables, respectively). G ::= \u00b7 | G, \nx : A | G, x : A := e S ::= \u00b7 | S, ?x : A | S, ?x : A := e These contexts are needed for weak head reduction \nof CIC terms (G; S f e whd e '), but also for some of Mtac constructs. Except where noted, every rule \njust passes around the contexts, so to avoid clutter we omit them. We also omit the types, although we \nassume that the terms are well-typed in their given contexts and we ensure that this invariant is maintained \nthroughout execution. Tactic computation may either (a) terminate successfully return\u00ading a term, ret \ne, (b) terminate by throwing an exception, raise e, (c) diverge, or (d) get blocked. (We explain the \npossible reasons for getting blocked below.) Hence we have the following tactic values: De.nition 1 (Values). \nv . Values ::= ret e | raise e . Figure 13 shows our operational semantics. The .rst rule per\u00adforms a \nCIC weak head reduction step. Weak head reduction re\u00adquires both contexts because, among other things, \nit will unfold de.nitions of variables and uni.cation variables in head position. For a precise description \nof Coq s standard reduction rules, see \u00a74.3 of Coq s Reference Manual [31]. Next, we have the standard \nunfolding of Mtac .xpoints. The next six rules are quite standard and concern the semantics of bind and \nmtry: note the symmetry between bind/ret and mtry/raise. The most complex rule is the next one concerning \npattern matching. It matches the term t with some pattern described in the list ps. Each element psi \nof ps is a pair containing a pattern p and a body b, abstracted over a list of (dependent) variables \nx : A. Since patterns are .rst class citizens in CIC, psi is .rst reduced to weak head normal form in \norder to expose the pattern and the body. The normalization relation is written whd* and, as with the \nweak head reduction relation, it requires the two contexts that we omit for clarity. Then, we replace \neach variable x with a corresponding uni.cation variable ?y in p, and proceed to unify the result with \nterm t. For this, the context S is extended with the freshly created uni.cation variables ?y. After uni.cation \nis performed, a new uni\u00ad.cation variable context is returned that might not only instantiate the freshly \ngenerated uni.cation variables ?y, but may also instan\u00adtiate previously de.ned uni.cation variables. \n(Instantiating such uni.cation variables is important, for instance, to instantiate the existentials \nin the tautology prover example of \u00a73.2). We actually require that uni.cation uni.es all the freshly \ngenerated variables, so that we can safely remove them after substituting them in the body, thereby avoiding \ncontext pollution. Finally, we require that patterns are tried in sequence, i.e., that the scrutinee, \nt, should not be uni.\u00adable with any previous pattern psj . In case no patterns match the scrutinee, the \nmmatch is blocked. The semantics for pattern matching is parametric with respect to the uni.cation judgment \nand thus does not rely on any particu\u00adlar uni.cation algorithm. (Our implementation uses Coq s standard \nuni.cation algorithm.) We observe that our examples, however, im\u00adplicitly depend on higher-order pattern \nuni.cation [18]. Higher\u00adorder uni.cation is in general undecidable, but Miller identi.ed a decidable \nsubset of problems, the pattern fragment, where uni.ca\u00adtion variables appear only in equations of the \nform ?f x1 . . . xn t, with x1, . . . , xn distinct variables. The . and . cases of the tau\u00adtology prover \n(\u00a73.2) fall into this pattern fragment, and their proper handling depends on higher-order pattern uni.cation. \nAnother notable aspect of Coq s uni.cation algorithm is that it equates terms up to de.nitional equality. \nIn particular, if a pattern match at .rst does not succeed, Coq will take a step of reduction on the \nscrutinee, try again, and repeat. Thus, the ordering of two pat\u00adterns in a mmatch matters, even if it \nseems the patterns are syn\u00adtactically non-overlapping. Take for instance the search example in \u00a71.1. \nIf the pattern for concatenation of lists were moved after the patterns for consing, then the consing \npatterns would actually match against (many) concatenations as well, since the concatena\u00adtion of two \nlists is often reducible to a term of the form h :: t.  Related to this, the last aspect of Coq s uni.cation \nalgorithm that we depend on is its .rst-order approximation. That is, in the presence of an equation \nof the form c t1 . . . c t ' . . . t ' tn 1 n, where c is a constant, the uni.cation algorithm tries \nto equate each ti ti ' . While this may cause Coq to miss out on some solutions, it has the bene.t of \nbeing simple and predictable. For instance, consider the equation ?l++?r []++(h :: t) that might result \nfrom matching the list []++(h :: t) with the pattern for concatenation of lists in the search example \nfrom \u00a71.1, with ?l and ?r fresh uni.cation variables. Here, although there exist many solutions, the \nalgorithm assigns ?l := [] and ?r := (h :: t), an assignment that is intuitively easy to explain. Coming \nback to the rules, next is the rule for evarA, which simply extends S with a fresh uninstantiated uni.cation \nvariable of the appropriate type. The two following rules govern is evar e and check whether an expression \n(after reduction to weak head normal form) is an uninstantiated uni.cation variable. The next two rules \nde.ne the semantics of the . x binder: the parameter x is pushed into the context and the execution proceeds \nuntil a value is reached. The computed value is simply returned if it does not contain the parameter, \nx; otherwise, . x. v is blocked. The latter rule is for abstracting over parameters. If the .rst argument \nof abs weak-head reduces to a parameter, then we abstract it from the second argument of abs, thereby \nreturning a function. The astute reader may wonder why we decided to have . x and abs instead of one \nsingle constructor combining the semantics of both. Such a combined constructor would always abstract \nthe pa\u00adrameter x from the result, therefore avoiding the .nal check that the parameter is not free in \nthe result. The reason we decided to keep nu and abs separate is simple: it is not always desirable to \nabstract the parameters in the same order as they were introduced. This is the case, for instance, in \nthe Mtactic skolemize for skolemizing a formula (provided in the Mtac distribution). Moreover, sometimes \nthe parameter is not abstracted at all, for instance in the Mtactic fv for computing the list of free \nvariables of a term (also provided in the Mtac distribution). Coming back to the rules, .nally, the last \nrule replaces a printing command with the trivial value . Informally, we also print out the string s \nto the standard output, although standard I/O is not formally modeled here. Assuming that uni.cation \nis sound, we can show that Mtac reduction is type-preserving. Theorem 1 (Type preservation). If G f (S; \nt) (S ' ; t ' ) and G; S f t : oA, then G; S ' f t ' : oA. As mentioned earlier, Mtactic execution can \nblock. Here, we de.ne exactly the cases when execution of a term is blocked. De.nition 2 (Blocked terms). \nA term t is blocked if and only if the subterm in reduction position satis.es one of the following cases: \n It is not an application of one of the o constructors and it is not reducible using the standard CIC \nreduction rules (whd).  It is .x. v and x . FV(v).  ' ' It is abs e t and e whd* e and (e : ) ./G. \n It is mmatch t ps and no pattern in ps uni.es with t.  With this de.nition, we can then also establish \na standard type safety theorem for Mtac. Theorem 2 (Type safety). Whenever G; S f t : oA, then either \nt is a value, or t is blocked, or there exist t ' and S ' such that G f (S; t) (S ' ; t ' ) and G; S \n' f t ' : oA . Example: We show the trace of a simple example to get a grasp of the operational semantics. \nIn this example, G = {h : nat}. let s := (h :: [])++[] in search h s We want to show that the .nal term \nproduced by running this Mtactic expresses the fact that h was found at the head of the list on the left \nof the concatenation, that is, in or app (h :: []) [] (or introl (in eq h [])) First, the let is expanded, \nobtaining search h ((h :: [])++[]) Then, after expanding the de.nition of search and \u00df-reducing the term, \nwe are left with the .xpoint being applied to the list: (m.x f [s : list A] := . . .) ((h :: [])++[]) \nAt this point the rule for m.x triggers, exposing the mmatch: mmatch ((h :: [])++[]) with . . . end Thanks \nto .rst-order approximation, the case for append is uni.ed, and its body is executed: mtry il . f (h \n:: []); ret . . . with . . . . end (1) where f stands for the .xpoint. The rule for mtry executes the \ncode for searching for the element in the sublist (h :: []): il . f (h :: []); ret (in or app (h :: []) \n[] h (or introl il)) (2) The bind rule triggers, after which the .xpoint is expanded and a new mmatch \nexposed: mmatch (h :: []) with . . . end This time, the rule for append fails to unify, but the second \ncase succeeds, returning the result in eq h []. Coming back to (2), il is replaced with this result, \ngetting the expected .nal result that is in turn returned by the mtry of (1). As a last remark, notice \nhow at each step the selected rule is the only applicable one: the semantics of Mtac is deterministic. \n5. Implementation This section presents a high-level overview of the architecture of our Mtac extension \nto Coq, explaining our approach for guarantee\u00ading soundness even in the possible presence of bugs in \nour Mtac implementation. The main idea we leverage in integrating Mtac into Coq is that Coq distinguishes \nbetween fully and partially type-annotated proof terms: Coq s type inference (or elaboration) algorithm \ntransforms partially annotated terms into fully annotated ones, which are then fed to Coq s kernel type \nchecker. In this respect Coq follows the typical architecture of interactive theorem provers, ensuring \nthat all proofs are ultimately certi.ed by a small trusted kernel. Assuming that the kernel is correct, \nno code outside this kernel may generate incorrect proofs. Thus, our Mtac implementation modi.es only \nthe elaborator lying outside of Coq s kernel, and leaves the kernel type checker untouched. Extending \nElaboration. The typing judgment used by Coq s elaboration algorithm [24, 25] takes a partially type-annotated \nterm e, a local context G, a uni.cation variable context S, and an optional expected type B, and returns \nits type A, and produces a fully annotated term e ', and updated uni.cation variable context S ' . G; \nS fB e y' : A S ' . e e  If an expected type B, is provided, then the returned type A will be convertible \nto it, possibly instantiating any uni.cation variables appearing in both A and B. The elaboration judgment \nserves three main purposes that the kernel typing judgment does not support: 1. To resolve implicit arguments. \nWe have already seen several cases where this is useful (e.g., in \u00a71.1), allowing us to write underscores \nand let Coq s uni.cation mechanism replace them with the appropriate terms. 2. To insert appropriate \ncoercions. For example, Ssre.ect [10] de.nes the coercion is true : bool . Prop := (.b. b = true). So \nwhenever a term of type Prop is expected and a term b of type bool is encountered, elaboration will insert \nthe coercion, thereby returning the term is true b having type Prop. 3. To perform canonical structure \nand type class resolution. Am\u00adple examples of canonical structures can be found in Gonthier et al. [11]. \nA type class example will be shown towards the end of this section.  We simply extend the elaboration \nmechanism to perform a fourth task, namely to run Mtactics. We achieve this by adding the following rule \nfor handling run t terms: ' S ' ' ) * (S '' G; S foB t y. t : oA e G f (S ' ; t ; ret e) S'' G; S fB \nrun t y. e : A e This rule .rst recursively type-checks the tactic body, while also unifying the return \ntype A of the tactic with the expected goal B (if present). This results in the re.nement of t to a new \nterm t ', which is then executed. If execution terminates successfully returning a value e (which from \nTheorem 2 will have type A), then that value is returned. Therefore, as a result of elaboration, all \nrun t terms are replaced by the terms produced when running them, and thus the kernel type checker does \nnot need to be modi.ed in any way. Elaboration and the apply Tactic. We have just seen how the elaborator \ncoerces the return type A of an Mtactic to be equivalent to the goal B, but we did not stipulate in what \nsituations the knowledge of B is available. Our examples so far assumed B was given, and this was indeed \nthe case thanks to the speci.c ways we invoked Mtac. For instance, at the end of \u00a71.1 we proved a lemma \nby direct de.nition i.e., providing the proof term directly and in \u00a73.1 we proved the goal by calling \nthe Ssre.ect tactic apply: (note the colon!). In both these situations, we were conveniently relying \non the fact that Coq passed the knowledge of the goal being proven into the elaboration of run. Unfortunately, \nnot every tactic does this. In particular, the standard Coq tactic apply (without colon) does not provide \nthe elaborator with the goal as expected type, so if we had written apply (run (F )), the Mtactic F would \nhave been executed on unknown parameters, resulting in a different behavior from what we expect. (Speci.cally, \nit would have uni.ed the implicits with the .rst two pointers appearing in the heap, succeeding only \nif, luckily, these are the pointers in the goal.) To ensure that information about the goal is available \nwhen run\u00adning Mtactics, we recommend installing Ssre.ect [10]. However, we note that using the standard \nCoq tactic re.ne instead of apply also works. One last point about tactics: Mtac is intended as a typed \nalter\u00adnative to Ltac for developing custom automation routines, and it is neither intended to replace \nthe built-in tactics (like apply) nor to subsume all uses of existing Coq tactics. For example, the OCaml \ntactic vm compute enables dramatic ef.ciency gains for re.ection\u00adbased proofs [12], but its performance \ndepends critically on being compiled. Mtac is interpreted, and it is not clear how it could be compiled, \ngiven the interaction between Mtac and Coq uni.cation. 01 Class runner A (f : oA) := { eval : A }. 02 \n03 Hint Extern 20 (runner ?f) . 04 (exact (Build runner f (run f))) 05 : typeclass instances. Figure \n14. Type class for delayed execution of Mtactics. Delaying Execution of Mtactics for Rewriting. Consider \nthe goal from \u00a73.1, after doing pose F := run (noalias D), unfolding the implicit is true coercions for \nclarity: D : def (h1 (x1 . v1 x2 . v2) (h2 x3 . v3)) F : .x y. o((x != y) = true) (x1 != x2) = true \n. (x2 != x3) = true Previously we solved this goal by applying the Mtactic F twice to the two subgoals \nx1 != x2 and x2 != x3. An alternative way in which a Coq programmer would hope to solve this goal is \nby using Coq s built-in rewrite tactic. rewrite enables one to apply a lemma one or more times to reduce \nvarious subterms of the current goal. In particular, we intuitively ought to be able to solve the goal \nin this case by invoking rewrite !(run (F )), where the ! means that the Mtactic F should be applied \nrepeatedly to solve any and all pointer inequalities in the goal. Unfortunately, however, this does not \nwork, because like Coq s apply tactic rewrite typechecks its argument without knowledge of the expected \ntype from the goal, and only later uni.es the result with the subterms in the goal. Consequently, just \nas with apply, F gets run prematurely. Fortunately, we can circumvent this problem, using a cute trick \nbased on Coq s type class resolution mechanism. Type classes are an advanced Coq feature similar to canonical \nstructures, with the crucial difference that their resolution is trig\u00adgered by proof search after elaboration \n[28]. We exploit this func\u00adtionality in Figure 14, by de.ning the class runner, which is param\u00adeterized \nover an Mtactic f with return type A and provides a value, eval, of the same type. We then declare a \nHint instructing the type class resolution mechanism how to build an instance of the runner class, which \nis precisely by running f . The details of this implementation are a bit of black magic, and beyond the \nscope of this paper to explain fully. But intuitively, all that is going on is that eval is delaying \nthe execution of its Mtactic argument until type class resolution time, at which point information about \nthe goal to be proven is available. Returning to our example, we can now use the following script: rewrite \n!(eval (F )) . This will convert the goal to is true true . is true true, which is trivially solvable. \nIn fact, with eval we can even employ the standard apply tactic, with the caveat that eval creates slightly \nbigger proof terms, as the .nal proof term will also contain the unevaluated Mtactic inside it. A Word \nabout Exceptions In ML, exceptions have type exn and their constructors are created via the keyword exception, \nas in exception MyException of string Porting this model into Coq is dif.cult as it is not possible to \nde.ne a type without simultaneously de.ning its constructors. Instead, we opted for a simple yet .exible \napproach. We de.ne the type Exception as isomorphic to the unit type, and to distinguish each exception \nwe create them as opaque, that is, irreducible. Figure 15 shows how to create two exceptions, the .rst \none parameterized over a string. What is crucial is the sealing of the de.nition with Qed, signaling \nto Coq that this de.nition is opaque. The example test ex illustrates the catching of different exceptions. \n 01 De.nition MyException (s : string) : Exception. 02 exact exception. 03 Qed. 04 05 De.nition AnotherException \n: Exception. 06 exact exception. 07 Qed. 08 09 De.nition test ex e := 10 mtry (raise e) with 11 | AnotherException \n. ret 12 | MyException hello . ret world 13 | [s] MyException s . ret s 14 end. Figure 15. Exceptions \nin Mtac. 6. Related Work Languages for Typechecked Tactics. In the last .ve years there has been increasing \ninterest in languages that support safe tactics to manipulate proof terms of dependently typed logics. \nDelphin [23], Beluga [21, 22, 4], and VeriML [29, 30] are languages that, like Mtac, fall into this category. \nBy safe we mean that, if the execu\u00adtion of a tactic terminates, then the resulting proof term has the \ntype speci.ed by the tactic. But, unlike Mtac, these prior systems employ a strict separation of languages: \nthe computational language (the language used to write tactics) is completely different from the logical \nlanguage (the language of proofs), making the meta-theory heavier than in Mtac. Indeed, our proof of \ntype safety is completely straightforward, as it inherits from CIC all the relevant properties such as \ntype preserva\u00adtion under substitution. Having a simple meta-theory is particularly important to avoid \nprecluding future language extensions indeed, extensions of the previous systems have often required \na reworking of their meta-theory [30, 4]. Another difference between these languages and Mtac is the \nlogical language they support. For Delphin and Beluga it is LF [13], for VeriML it is .HOL [1], and for \nMtac it is CIC [2]. CIC is the only one among these that provides support for computation at the term \nand type level, thereby enabling proofs by re.ection (e.g., see \u00a73.3). Instead, in previous systems term \nreduction must be wit\u00adnessed explicitly in proofs. To work around this, VeriML s compu\u00adtational language \nincludes a construct letstatic that allows one to stage the execution of tactics, so as to enable equational \nreasoning at typechecking time. Then, proofs of (in-)equalities obtained from tactics can be directly \ninjected in proof terms generated by tactics. This is similar to our use of run in the example from \u00a73.3, \nwith the caveat that letstatic cannot be used within de.nitions, as we did in the inner prod example, \nbut rather only inside tactics. In Beluga and VeriML the representation of objects of the logic in the \ncomputational language is based on Contextual Modal Type Theory [20]. Therefore, every object is annotated \nwith the context in which it is immersed. For instance, a term t depending only in the variable x is \nwritten in Beluga as [x. t], and the typechecker enforces that t has only x free. In Mtac, it is only \npossible to perform this check dynamically, writing an Mtactic to inspect a term and rule out free variables \nnot appearing in the set of allowed variables (the interested reader may .nd an example of this Mtactic \nin the Mtac distribution). On the other hand, the syntax of the language and the meta-theory required \nto account for contextual objects are signi.cantly heavier than those of Mtac. Delphin shares with Mtac \nthe . x : A binder from [26, 19]. In Delphin, the variable x introduced by this binder is distinguished \nwith the type A#, in order to statically rule out offending terms like . x : A. ret x. In Mtac, instead, \nthis check gets performed 01 Structure tagged heap := Tag {untag :> heap}. 02 De.nition default tag := \nTag. 03 De.nition ptr tag := default tag. 04 Canonical Structure union tag h := ptr tag h. 05 06 Structure \nform (s : list ptr) := Form {07 heap of :> tagged heap; 08 : def heap of . uniq s . 09 . x. x . s . x \n. dom heap of}. 10 11 Canonical Structure union form s1 s2 h1 h2 := 12 Form (s1 ++ s2) (union tag (h1 \n h2)) ... 13 14 Canonical Structure ptr form A x (v : A) := 15 Form [:: x] (ptr tag (x . v)) ... 16 17 \nCanonical Structure default form h := 18 Form [::] (default tag h) ... Figure 16. Scan tactic in lemma \noverloading style. dynamically. Yet again, we see a tension between the simplicity of the meta-theory \nand the static guarantees provided by the system. In Mtac we favor the former. From all these systems, \nVeriML is the only system that provides ML-style references at the computational level. References are \nuseful for writing ef.cient tactics. For instance, Stampoulis and Shao [29] .rst present a tautology \nprover similar to the one in \u00a73.2, with a linear list lookup function. Then, they replace the list of \nhypotheses with a hash table to ef.ciently store and lookup hypotheses. In our implementation of Mtac, \nwe have begun to look into this, and the interested reader can .nd in the Mtac distribution a similar \noptimized version of the tautology prover, but we have yet to work out its meta-theory. Finally, a key \ndifference between Mtac and all the aforemen\u00adtioned systems is the ability to program Mtactics interactively, \nas shown at the end of \u00a73.1. None of the prior systems supports this. Proof Automation Through Lemma \nOverloading. At heart, one of the key ideas of Mtac is to get tactic execution to be performed by Coq \ns type inference engine. In that sense, Mtac is closely related to (and indeed was inspired by) Gonthier \net al. s work on lemma overloading using canonical structures [11]. However, as explained in the introduction, \nwhereas Mtac sup\u00adports a functional style of programming, the style of programming imposed by lemma overloading \nis that of (dependently-typed) logic programming. For instance, Figure 16 shows the scan algorithm from \n\u00a73.1 rewritten using canonical structures. Without going into detail, the structure (a.k.a. record) form \nin line 9 is the backbone of the tactic. The (tagged) heap heap of is the input to the algorithm, and \nthe list of pointers s and the (unnamed) axiom are the output of the algorithm. The tagging of the heap \n(lines 1 to 4) is required in order to specify an order in which the canonical instance decla\u00adrations \nin lines 13 to 20 (much like type class instances in Haskell) should be considered during canonical instance \nresolution. The reason for using a parameter of the structure (s) to represent one of the outputs of \nthe algorithm is tricky to explain. More gener\u00adally, knowing where to place the inputs and outputs of \noverloaded lemmas, and how to compose them together effectively, requires deep knowledge of the uni.cation \nalgorithm of Coq. In fact, the ma\u00adjor technical contribution of Gonthier et al. s paper [11] is the de\u00advelopment \nof a set of common design patterns to help in dealing with these issues. For instance, in order to encode \nthe noalias tac\u00adtic as a composition of several overloaded lemmas, Gonthier et al. employ a rather sophisticated \nparametrized tagging pattern for reordering of uni.cation subproblems.  In contrast, the Mtac encoding \nof noalias is entirely straight\u00adforward functional programming. Admittedly, the operational se\u00admantics \nof Mtac s mmatch construct is also tied to the uni.cation algorithm of Coq, and the lack of a clear speci.cation \nof this algo\u00adrithm is an issue we hope to tackle in the near future. But, crucially, the high-level control \n.ow of Mtactics is easy to understand without a detailed knowledge of Coq uni.cation. That said, there \nare some idioms that canonical structures sup\u00adport but Mtactics do not. In particular, their logic programming \nstyle makes them openly extensible (as with Haskell type classes, new instances can be added at any time), \nwhereas Mtactics are closed to extension. It also enables them to be applied in both back\u00adward and forward \nreasoning, whereas Mtactics are unidirectional. Simulable Monads. Claret et al. [7] present Cybele, a \nframework for building more .exible proofs by re.ection in Coq. Like Mtac, it provides a monad to build \neffectful computations, although these effects are compiled and executed in OCaml. Upon success, the \nOCaml code creates a prophecy that is injected back into Coq to simulate the effects in pure CIC. On \nthe one hand, since the effects Cybele supports must be replayable inside CIC, it does not provide meta-programming \nfeatures like Mtac s mmatch, nu, abs, and evar, which we use heavily in our examples. On the other hand, \nfor the kinds of effectful computations Cybele supports, the proof terms it generates ought to be smaller \nthan those Mtac generates, since Cybele enforces the use of proof by re.ection. The two systems thus \noffer complementary bene.ts, and can in principle be used in tandem. Acknowledgments We are deeply grateful \nto Chung-Kil Hur for suggesting the Mendler-style encoding of m.x, to Arnaud Spiwack for suggest\u00ading \nthe use of telescopes for representing patterns, and to Georges Gonthier for the neat type class trick \nfor delaying execution of Mtactics. We would also like to thank Jesper Bengtson and Jonas Jensen, who \ntested an earlier version of Mtac and gave useful feed\u00adback that helped us in polishing the implementation, \nas well as Nils Anders Danielsson and the anonymous reviewers for their very helpful comments. This research \nwas partially supported by the Spanish MINECO projects TIN2010-20639 Paran10 and TIN2012\u00ad39391-C04-01 \nStrongsoft, AMAROUT grant PCOFUND-GA\u00ad2008-229599, and Ramon y Cajal grant RYC-2010-0743. References [1] \nH. Barendregt and H. Geuvers. Proof-assistants using dependent type systems. In A. Robinson and A. Voronkov, \neditors, Handbook of automated reasoning. Elsevier, 2001. [2] Y. Bertot, P. Cast \u00b4 eran, G. Huet, and \nC. Paulin-Mohring. Interactive theorem proving and program development : Coq Art : the calculus of inductive \nconstructions. Texts in theoretical computer science. Springer, 2004. [3] S. Boutin. Using re.ection \nto build ef.cient and certi.ed decision procedures. In TACS, volume 1281 of LNCS. Springer, 1997. [4] \nA. Cave and B. Pientka. Programming with binders and indexed data\u00adtypes. In POPL 2012. ACM, 2012. [5] \nA. Chlipala. Certi.ed programming with dependent types. http://adam.chlipala.net/cpdt, 2008. [6] A. \nChlipala. Mostly-automated veri.cation of low-level programs in computational separation logic. In PLDI \n2011. ACM, 2011. [7] G. Claret, L. del Carmen Gonz\u00b4alez Huesca, Y. R \u00b4egis-Gianas, and B. Ziliani. Lightweight \nproof by re.ection using a posteriori simu\u00adlation of effectful computation. In ITP 2013, volume 7998 \nof LNCS. Springer, 2013. [8] G. Gonthier. Formal proof the four-color theorem. Notices of the AMS, 55(11):1382 \n93, 2008. [9] G. Gonthier, A. Asperti, J. Avigad, Y. Bertot, C. Cohen, F. Garillot, S. Le Roux, A. Mahboubi, \nR. O Connor, S. Ould Biha, I. Pasca, L. Rideau, A. Solovyev, E. Tassi, and L. Th \u00b4ery. A machine-checked \nproof of the odd order theorem. In ITP 2013, volume 7998 of LNCS. Springer, 2013. [10] G. Gonthier, A. \nMahboubi, and E. Tassi. A small scale re.ection extension for the Coq system. Technical report, INRIA, \n2008. [11] G. Gonthier, B. Ziliani, A. Nanevski, and D. Dreyer. How to make ad hoc proof automation less \nad hoc. In ICFP, 2011. [12] B. Gr\u00b4egoire and X. Leroy. A compiled implementation of strong reduction. \nIn ICFP, 2002. [13] R. Harper, F. Honsell, and G. Plotkin. A framework for de.ning logics. J. ACM, 40(1):143 \n184, Jan. 1993. [14] C.-K. Hur, G. Neis, D. Dreyer, and V. Vafeiadis. The power of parameterization in \ncoinductive proof. In POPL 2013. ACM, 2013. [15] G. Klein, J. Andronick, K. Elphinstone, G. Heiser, D. \nCock, P. Derrin, D. Elkaduwe, K. Engelhardt, R. Kolanski, M. Norrish, T. Sewell, H. Tuch, and S. Winwood. \nseL4: Formal veri.cation of an operating\u00adsystem kernel. CACM, 53(6):107 115, 2010. [16] X. Leroy. Formal \nveri.cation of a realistic compiler. CACM, 52(7):107 115, 2009. [17] N. P. Mendler. Inductive types and \ntype constraints in the second\u00adorder lambda calculus. Annals of Pure and Applied Logic, 51(1 2):159 172, \n1991. [18] D. Miller. Uni.cation of simply typed lamda-terms as logic program\u00adming. In ICLP 1991. MIT \nPress, 1991. [19] A. Nanevski. Meta-programming with names and necessity. In ICFP 2002. ACM, 2002. [20] \nA. Nanevski, F. Pfenning, and B. Pientka. Contextual modal type theory. ACM Trans. Comput. Logic, 9(3), \nJune 2008. [21] B. Pientka. A type-theoretic foundation for programming with higher\u00adorder abstract syntax \nand .rst-class substitutions. In POPL 2008. ACM, 2008. [22] B. Pientka and J. Dun.eld. Programming with \nproofs and explicit contexts. In PPDP 2008. ACM, 2008. [23] A. Poswolsky and C. Sch \u00a8urmann. System description: \nDelphin a functional programming language for deductive systems. ENTCS, 228:113 120, 2009. [24] C. Sacerdoti \nCoen. Mathematical Knowledge Management and Inter\u00adactive Theorem Proving. PhD thesis, University of Bologna, \n2004. [25] A. Sa\u00a8ibi. Typing algorithm in type theory with inheritance. In POPL 1997. ACM, 1997. [26] \nC. Sch \u00a8urmann, A. Poswolsky, and J. Sarnat. The \\-calculus. Func\u00adtional programming with higher-order \nencodings. In TLCA 2005, vol\u00adume 3461 of LNCS. Springer, 2005. [27] M. Sozeau. Subset coercions in Coq. \nIn TYPES 2006, volume 4502 of LNCS. Springer, 2007. [28] M. Sozeau and N. Oury. First-class type classes. \nIn TPHOLs 2008, volume 5170 of LNCS. Springer, 2008. [29] A. Stampoulis and Z. Shao. VeriML: Typed computation \nof logical terms inside a language with effects. In ICFP 2010. ACM, 2010. [30] A. Stampoulis and Z. Shao. \nStatic and user-extensible proof checking. In POPL 2012. ACM, 2012. [31] The Coq Development Team. The \nCoq Proof Assistant Reference Manual Version V8.4, 2012. [32] J. .c\u00b4ik, V. Vafeiadis, F. Zappa Nardelli, \nS. Jagannathan, and Sev . P. Sewell. CompCertTSO: A veri.ed compiler for relaxed-memory concurrency. \nJ. ACM, 60(3):22:1 22:50, June 2013.   \n\t\t\t", "proc_id": "2500365", "abstract": "<p>Effective support for custom proof automation is essential for large scale interactive proof development. However, existing languages for automation via *tactics* either (a) provide no way to specify the behavior of tactics within the base logic of the accompanying theorem prover, or (b) rely on advanced type-theoretic machinery that is not easily integrated into established theorem provers.</p> <p>We present Mtac, a lightweight but powerful extension to Coq that supports dependently-typed tactic programming. Mtac tactics have access to all the features of ordinary Coq programming, as well as a new set of typed tactical primitives. We avoid the need to touch the trusted kernel typechecker of Coq by encapsulating uses of these new tactical primitives in a *monad*, and instrumenting Coq so that it executes monadic tactics during type inference.</p>", "authors": [{"name": "Beta Ziliani", "author_profile_id": "81488670714", "affiliation": "MPI-SWS, Saarbruecken, Germany", "person_id": "P4261223", "email_address": "beta@mpi-sws.org", "orcid_id": ""}, {"name": "Derek Dreyer", "author_profile_id": "81548019178", "affiliation": "MPI-SWS, Saarbruecken, Germany", "person_id": "P4261224", "email_address": "dreyer@mpi-sws.org", "orcid_id": ""}, {"name": "Neelakantan R. Krishnaswami", "author_profile_id": "81320491252", "affiliation": "MPI-SWS, Saarbruecken, Germany", "person_id": "P4261225", "email_address": "neelk@mpi-sws.org", "orcid_id": ""}, {"name": "Aleksandar Nanevski", "author_profile_id": "81100503327", "affiliation": "IMDEA Software Institute, Madrid, Spain", "person_id": "P4261226", "email_address": "aleks.nanevski@imdea.org", "orcid_id": ""}, {"name": "Viktor Vafeiadis", "author_profile_id": "81100493655", "affiliation": "MPI-SWS, Kaiserslautern, Germany", "person_id": "P4261227", "email_address": "viktor@mpi-sws.org", "orcid_id": ""}], "doi_number": "10.1145/2500365.2500579", "year": "2013", "article_id": "2500579", "conference": "ICFP", "title": "Mtac: a monad for typed tactic programming in Coq", "url": "http://dl.acm.org/citation.cfm?id=2500579"}