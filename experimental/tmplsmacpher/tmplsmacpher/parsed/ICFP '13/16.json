{"article_publication_date": "09-25-2013", "fulltext": "\n Programming with Permissions in Mezzo Fran\u00e7ois Pottier Jonathan Protzenko INRIA INRIA francois.pottier@inria.fr \njonathan.protzenko@ens-lyon.org Abstract We present Mezzo, a typed programming language of ML lineage. \nMezzo is equipped with a novel static discipline of duplicable and af.ne permissions, which controls \naliasing and ownership. This rules out certain mistakes, including representation exposure and data races, \nand enables new idioms, such as gradual initialization, memory re-use, and (type)state changes. Although \nthe core static discipline disallows sharing a mutable data structure, Mezzo offers several ways of working \naround this restriction, including a novel dynamic ownership control mechanism which we dub adoption \nand abandon . Categories and Subject Descriptors D.3.2 [Programming Lan\u00adguages]: Language Classi.cations \nMultiparadigm languages Keywords static type systems; side effects; aliasing; ownership 1. Introduction \nProgramming with mutable, heap-allocated data structures is hard. In many typed imperative programming \nlanguages, including Java, C#, and ML, the type system keeps track of the structure of objects, but not \nof how they are aliased. As a result, a programming mistake can cause undesired sharing, which in turn \nleads to breaches of ab\u00adstraction, invariant violations, race conditions, and so on. Further\u00admore, the \nfact that sharing is uncontrolled implies that the type of an object must never change. This forbids \ncertain idioms, such as delayed initialization, and prevents the type system from keeping track of the \nmanner in which objects change state through method calls. In order to work around this limitation, programmers \ntypi\u00adcally use C# and Java s null pointer, or ML s option type. This im\u00adplies that a failure to follow \nan intended protocol is not detected at compile time, but leads to a runtime error. In short, there is \na price to pay for the simplicity of traditional type systems: the bugs caused by undesired sharing, \nor by the failure to follow an object protocol, are not statically detected. This paper presents the \ndesign of a new programming language, Mezzo, which attempts to address these issues. One motivating principle \nbehind the design of Mezzo is that one should be able to express precise assertions about the current \nstate of an object or data structure. The type system should keep track of state changes and forbid using \nan object in a manner that is inconsistent with Permission to make digital or hard copies of all or part \nof this work for personal or classroom use is granted without fee provided that copies are not made or \ndistributed for pro.t or commercial advantage and that copies bear this notice and the full citation \non the .rst page. Copyrights for components of this work owned by others than the author(s) must be honored. \nAbstracting with credit is permitted. To copy otherwise, or republish, to post on servers or to redistribute \nto lists, requires prior speci.c permission and/or a fee. Request permissions from permissions@acm.org. \nICFP 13, September 25 27, 2013, Boston, MA, USA. Copyright is held by the owner/author(s). Publication \nrights licensed to ACM. ACM 978-1-4503-2326-0/13/09. . . $15.00. http://dx.doi.org/10.1145/2500365.2500598 \n its current state. An example is a socket that moves from state ready , to connected , then to closed \n. The close function, for instance, should be invoked only if the socket is currently in the state connected \n, and changes its state to closed . Another example is a collection, which must not be accessed while \nan iterator exists, but can be used again once iteration is over. Although state and state change play \nan important role in many programs, no mainstream programming language builds these no\u00adtions into its \nstatic discipline. External tools must be used, such as typestate checking tools [13, 5, 6] or tools \nfor constructing proofs of programs, based for instance on separation logic [4, 20] or on the Spec# methodology \n[3]. Instead, we explore the possibility of reasoning about state within the type system. This has well-known \npotential bene.ts. A property that is expressed as a type is checked early, often, and at little cost. \nFurthermore, we believe that, in the future, such a type system can serve as a strong foundation for \nper\u00adforming proofs of programs. Obviously, if two principals separately think that the socket s is currently \nconnected , and if one of them decides to close this socket, then the other will be left with an incorrect \nbelief about s. Thus, precise reasoning about state and state changes requires that information about \na mutable object (or data structure) be recorded in at most one place in the type system. In Mezzo, this \nplace is a permission. Permissions keep track not only of the structure of data, as does a traditional \ntype system, but also of must-alias and must-not-alias (i.e. equality and disjointness) information. \nLike a separation logic assertion [29], a permission has an ownership reading: to have access to a description \nof a part of the heap is to own this part of the heap. Because to describe is to own , we need not explicitly \nannotate types with owners, as done in Ownership Types [10] or Universe Types [14]. We do not think of \nthe type of an object and of its state as two distinct notions: a permission describes both at once. \nWhereas previous work on permissions [5] distinguishes between a .xed type structure and permissions \nthat evolve with time, in Mezzo, both type and state can change over time. This yields greater expressiveness: \nfor instance, gradual initialization and memory re\u00aduse become possible. This also yields greater simplicity \nand con\u00adciseness: for instance, when we write polymorphic code that ma\u00adnipulates a list, a single type \nvariable a denotes not only what the list elements are (e.g., sockets) but also in what state they are \nand to what extent we own them. The choices described above form our basic design premises. Mezzo can \nbe viewed as an experiment, whose aim is to determine to what extent these choices are viable. Beyond \nthese decisions, we strive to make the language as simple as possible. Mezzo is a high-level programming \nlanguage: we equip it with .rst-class functions, algebraic data types, and require a garbage collector. \nWe could have chosen classes and objects instead of (or in addition to) algebraic data types; this could \nbe a topic for future research. We equip Mezzo with a simple distinction between duplicable permissions \n(for immutable data) and exclusive permissions (for mutable data). Although more advanced varieties of \npermissions exist in the literature, including read-only views of mutable data and fractional permissions \n[7], we wish to evaluate how far one can go without these advanced notions; if desired, they could in \nprinciple be added to Mezzo.  By default, Mezzo s permission discipline imposes a restrictive aliasing \nregime: the mutable part of the heap must form a forest. Mezzo offers several mechanisms for evading \nthis restriction. One, adoption and abandon, is new. It allows arbitrary aliasing patterns within a region \nof the heap and achieves soundness via dynamic checks. We describe it in detail in \u00a77. The second mechanism \nis Boyland s nesting [7]. It can be viewed as a form of adoption and abandon that requires no runtime \nchecks but is (for many purposes) less powerful. The last mechanism is locks in the style of concurrent \nseparation logic [25, 18, 19, 8]. Mezzo s static discipline has been formally de.ned and me\u00adchanically \nproved sound1. The formalization, which is available on\u00ad line [26], includes adoption and abandon, but \ndoes not (at present) cover nesting, locks, or concurrency. The statement of soundness guarantees that \nwell-typed programs do not go wrong , except possibly when the dynamic check performed at abandon fails. \nIn a concurrent extension of Mezzo, it would in addition guarantee that well-typed programs are data-race-free \n. The proof is syntac\u00adtic. We extend the typing judgement to a pair of a program under execution and \nits heap, and establish the standard subject reduction and progress lemmas. A prototype type-checker \nhas been implemented and is publicly available [27]. Several small libraries, totaling a few thousand \nlines of code, have been written, and are also available online [27]. They include immutable data structures \n(lists), mutable data structures (lists, doubly-linked lists, binary search trees, hash tables, resizable \narrays, and FIFO queues, see \u00a77), persistent data structures imple\u00ad mented via imperative means (suspensions, \npersistent arrays), and a few algorithms (memoization; graph search). At the time of this writing, an \ninterpreter is available, and a simple compiler (which translates Mezzo down to untyped OCaml) is being \ndeveloped. The paper begins with a motivating example (\u00a72), which cannot be type-checked in ML, and which \nserves to informally illustrate Mezzo s permission discipline. Then, we de.ne the syntax of types, permissions, \nand expressions (\u00a73) and informally explain the own\u00ad ership reading of permissions for immutable and \nmutable data (\u00a74). We present the typing rules (\u00a75) and introduce a few syntactic con\u00ad ventions that \nmake the surface language more palatable (\u00a76). We explain adoption and abandon, illustrate them with \na second exam\u00adple (\u00a77), and discuss nesting and locks more brie.y (\u00a78). Finally, we explain where Mezzo \nlies in the design space and compare it with some of the previous approaches found in the literature \n(\u00a79). 2. Mezzo by example Figure 1 presents code for the concatenation of two immutable lists. This example \nshowcases several of Mezzo s features, and allows us to explain the use of permissions. We review the \ncode .rst (\u00a72.1), then brie.y explain how it is type-checked (\u00a72.2 and \u00a72.3). 2.1 Code Our purpose is \nto write code that concatenates two immutable lists xs and ys to produce a new immutable list. The traditional, \npurely functional implementations of concatenation have linear space overhead, as they implicitly or \nexplicitly allocate a reversed 1 The formalization concerns a slightly lower-level language, Core Mezzo. \nIn Core Mezzo, .elds are numbered, whereas in Mezzo they are named and .eld names can be overloaded. \nAt present, Core Mezzo is missing some of the features of Mezzo, including parameterized algebraic data \ntypes and mode constraints. We hope to add them in the future. 1 d a t a l i s t a = 2 N i l | C o n \ns { h e a d : a ; t a i l : l i s t a } 3 4 d a t a m u t a b l e m l i s t a = 5 M N i l | M C o n s \n{ h e a d : a ; t a i l : l i s t a } 6 7 v a l r e c a p p e n d A u x [ a ] ( 8 c o n s u m e s d \ns t : M C o n s 9 c o n s u m e s x s : l i s t a , 10 c o n s u m e s y s : l i s t a ) 11 m a t c \nh x s w i t h 12 | N i l -> 13 d s t . t a i l < -ys ; 14 t a g o f d s t <-C o n s 15 | C o n s -> 16 \nl e t dst = M C o n s { 17 18 d s t . t a i l < -dst ; { h e a d : a ; t a i l : ( ) } , : (| d s t \n@ l i s t a ) = h e a d = x s . h e a d ; t a i l = ( ) } i n  19 t a g o f d s t <-C o n s ; 20 a p \np e n d A u x ( ds t , x s . t a i l , y s ) 21 e n d 22 23 v a l a p p e n d [ a ] ( 24 c o n s u m \ne s x s : l i s t a , 25 c o n s u m e s y s : l i s t a ) : l i s t a = 26 m a t c h x s w i t h 27 \n| N i l -> 28 ys 29 | C o n s -> 30 l e t d s t = M C o n s { h e a d = x s . h e a d ; 31 t a i l = \n( ) } in 32 a p p e n d A u x ( ds t , x s . t a i l , y s ) ; 33 d s t 34 e n d Figure 1. Tail-recursive \nconcatenation of immutable lists copy of xs. Our implementation, on the other hand, is written in destination-passing \nstyle, and has constant space overhead. Roughly speaking, the list xs is traversed and copied on the \n.y. When the end of xs is reached, the last cell of the copy is made to point to ys. The append function \n(Figure 1, line 23) is where concatenation begins. If xs is empty, then the concatenation of xs and ys \nis ys (line 27). Otherwise (line 29), append allocates an un.nished, mutable cell dst (line 30). This \ncell contains the .rst element of the .nal list, namely xs.head. It is in an intermediate state: it cannot \nbe considered a valid list, since its tail .eld contains the unit value (). It is now up to appendAux \nto .nish the work by constructing the concatenation of xs.tail and ys and writing the address of that \nlist into dst.tail. Once appendAux returns, dst has become a well\u00adformed list (this is indicated by the \npostcondition dst @ list a on line 10) and is returned by append. The function appendAux expects an un.nished, \nmutable cell dst and two lists xs and ys. Its purpose is to write the concatenation of xs and ys into \ndst.tail, at which point dst can be considered a well-formed list. If xs is Nil (line 12), the tail .eld \nof dst is made to point to ys. Then, dst, a mutable MCons cell, is frozen by a tag update instruction \nand becomes an immutable Cons cell. (This instruction compiles to a no-op.) If xs is a Cons cell (line \n15), we allocate a new destination cell dst , let dst.tail point to it, freeze dst, and repeat the process \nvia a tail-recursive call. This example illustrates several important aspects of Mezzo. Expressiveness \nIn a traditional typed programming language, such as Java or OCaml, list concatenation in destination-passing \nstyle is possible, but its result must be a mutable list, because an immutable list cell cannot be gradually \ninitialized.  State change The call appendAux(dst, xs, ys) changes the type of dst from un.nished, mutable \nlist cell to well-formed, immutable list . This type-changing update is sound because one must be the \nunique owner of the mutable cell dst for this call to be permitted. Ownership transfer In fact, the call \nappendAux(dst, xs, ys) also changes the type of xs and ys from immutable list to un\u00adknown . Indeed, the \npostcondition of appendAux guarantees noth\u00ading about xs and ys. In other words, the caller gives up the \npermis\u00adsion to use xs and ys as lists, and in return gains the permission to use dst as a list. In other \nwords, the ownership of the list elements is transferred from xs and ys to dst. This is required for \nsound\u00adness. We do not know what the list elements are (they have abstract type a). They could be mutable \nobjects, whose unique ownership property must not be violated2 .  2.2 Permissions Permissions do not \nexist at runtime: they are purely an artefact of the type system. An atomic permission x @ t represents \nthe right to use the program variable x at type t. Two permissions P1 and P2 can be combined to form \na composite permission P1 *P2. The conjunction * is separating [29] at mutable memory locations and requires \nagreement at immutable locations (\u00a74.1). The empty permission, a unit for conjunction, is written empty. \nWhen execution begins, a program conceptually possesses an empty permission. As execution progresses \nthrough the code, per\u00admissions come and go. At any program point, there is a certain current permission. \nMost of the time, the manner in which permis\u00adsions evolve and .ow is implicit. It must be made explicit \nin a few places: in particular, every function type must include explicit pre\u00adand postconditions. Let \nus continue our discussion of the concatenation example (Figure 1). We explain in an informal manner \nhow the function append is type-checked. This allows us to illustrate how permis\u00adsions are used and how \nthey evolve. The typing rules appear in Figure 4; a subset of the permission subsumption rules appear \nin Figure 6. In the following, we refer to some of these rules, but defer their detailed explanation \nto \u00a75. The append function is de.ned at line 23. At the beginning of the function s body, by the typing \nrule FU N C T I O N, permissions for the formal arguments are available. Thus, the current permission \nis: xs @ list a *ys @ list a This permission represents the right to use xs and ys as lists of elements \nof type a. This permission soon evolves, thanks to the match construct, which examines the tag carried \nby xs. By the typing rule MAT C H, as we learn that xs is a Nil cell, we replace our permission about \nxs with a more precise one, which incorporates the knowledge that the tag of xs is Nil. At line 27, the \ncurrent permission becomes: xs @ Nil *ys @ list a xs @ Nil is a structural permission: it asserts that \nxs points to a memory block whose tag is Nil (and which has zero .elds). Similarly, at line 29, the current \npermission becomes: xs @ Cons{head :a; tail :list a} *ys @ list a The structural permission for xs asserts \nthat xs points to a memory block that carries the tag Cons and has a head .eld of type a and a tail .eld \nof type list a. 2 We later note (\u00a74.1) that if at a call site the variable a is instantiated with a duplicable \ntype, say int, then the permissions xs @ list int and ys @ list int are considered duplicable, so they \ncan in fact be duplicated prior to the call appendAux(dst, xs, ys), hence are not lost. At this stage, \nthe type-checker performs an implicit operation. It applies the permission subsumption rule DE C O M \nP O S E BL O C K. This causes fresh names hd and tl to be introduced for the head and tail .elds of this \nstructural permission. This yields the following conjunction: xs @ Cons{head :(=hd); tail :(=tl)} * hd \n@ a *tl @ list a * ys @ list a This is our .rst encounter of a singleton type, which we write =hd. A \npermission of the form x @ =y asserts that the variables x and y denote the same value. In particular, \nif they denote memory locations, this means that x and y point to the same object: this is a must-alias \nconstraint. We write x = y for x @ =y. Similarly, in the structural permission above, the fact that the \nhead .eld has type =hd means that the value of this .eld is hd. We write head = hd for head :(=hd). By \nthe typing rules NE W and LE T, when the cell dst is allocated (line 30), a permission for dst appears, \nnamely: dst @ MCons{head = hd; tail :()} We now see how singleton types help reason about sharing. At \nthis point, we have three permissions that mention hd. We know that hd is stored in the head .eld of \nxs; we know that hd is stored in the head .eld of dst; and we have a permission to use hd at type a. \nWe do not need a borrowing convention [24] in order to .x which of xs or dst owns hd. Instead, the system \nknows that the object hd is accessible via two paths, namely xs.head and dst.head, and can be used under \neither name. This use of singleton types is taken from Alias Types [30]. By the typing rules RE A D and \nAP P L I C AT I O N, in order to call appendAux(dst, xs.tail, ys) (line 32), we need the following conjunction \nof permissions. It is the precondition of appendAux, suitably instantiated: dst @ MCons{head :a; tail \n:()} *tl @ list a *ys @ list a Are we able to satisfy this requirement? The answer is positive. The subsumption \nrules EX I S T S IN T RO and DE C O M P O S E BL O C K allow combining the permissions MCons{head = hd; \ntail : ()} and hd @ a (both of which are present) to obtain the .rst conjunct above. The second and third \nconjuncts above are present already. By AP P L I C AT I O N, the precondition of appendAux is consumed \n(taken away from the caller). After the call, the postcondition of appendAux is added to the current \npermission, which is then: xs @ Cons{head = hd; tail = tl} *dst @ list a The conjunct that concerns xs \nis of no use, and is in fact silently discarded when we reach the end of the Cons branch within append. \nThe conjunct that concerns dst is used to check that this branch satis.es append s advertised return \ntype, namely list a. Similarly, in the Nil branch, the permission ys @ list a shows that a value of appropriate \ntype is returned. In conclusion, append is well-typed.  2.3 To loop or to tail call? In-place concatenation \n(that is, melding) of mutable lists can also be implemented by a tail-recursive function. The pattern \nis analo\u00adgous to that of Figure 1, but the code is simpler, because the .rst list is not copied, and \nfreezing is not required. These algorithms are traditionally viewed as iterative and im\u00adplemented using \na while loop. Berdine et al. s iterative formula\u00adtion of mutable list melding [4], which is proved correct \nin sepa\u00ad ration logic, has a complex loop invariant, involving two list seg\u00adments , and requires an inductive \nproof that the concatenation of two list segments is a list segment. In contrast, in the tail-recursive \napproach, the loop invariant is the type of the recursive function (e.g., appendAux in Figure 1). This \ntype is reasonably natural and does not involve list segments.  How do we get away without list segments \nand without induc\u00adtive reasoning? The trick is that, even though appendAux is tail\u00adrecursive, which means \nthat no code is executed after the call by appendAux to itself, a reasoning step still takes place after \nthe call. Immediately before the call, the current permission can be written as follows: xs @ Cons head \n= hd; tail = tl * dst @ Cons{ head :a; tail = dst '} * dst ' @ MCons{head :a; tail :()} * tl @ list a \n*ys @ list a The call appendAux (dst , xs.tail, ys) consumes the last ' three permissions and produces \ninstead dst @ list a. The .rst two permissions are framed out , i.e., implicitly preserved. After the \ncall, we have: xs @ Cons head = hd; tail = tl * dst @ Cons{ head :a; tail = dst '} * ' dst @ list a Dropping \nthe .rst permission and combining the last two yields: dst @ Cons{head :a; tail :list a} which can be \nfolded back to dst @ list a, so appendAux satis.es its postcondition. In short, the code is tail-recursive, \nbut the manner in which one reasons about it is recursive. Minamide [22] proposes a notion of data structure \nwith a hole , or in other words, a segment, and applies it to the problem of con\u00adcatenating immutable \nlists. Walker and Morrisett [35] offer a tail\u00adrecursive version of mutable list concatenation in a low-level \ntyped intermediate language, as opposed to a surface language. The man\u00adner in which they avoid reasoning \nabout list segments is analogous to ours. There, because the code is formulated in continuation\u00adpassing \nstyle, the reasoning step that takes place after the recur\u00adsive call amounts to composing the current \ncontinuation with a coercion. Maeda et al. [21] study a slightly different approach, also in the setting \nof a typed intermediate language, where separating implication offers a way of de.ning list segments. \nOur approach could be adapted to an iterative setting by adopting a new proof rule for while loops. This \nis noted independently by Chargu\u00e9raud [9, \u00a73.3.2] and by Tuerk [34]. 3. Syntax 3.1 Types We work with \nthe internal syntax of types. The surface syntax adds a few syntactic conventions, which we explain later \non (\u00a76). For the moment, the reader may ignore the two underlined con\u00adstructs in Figure 2. Types have \nkinds. The base kinds are type, term, and perm. The standard types, such as function types, tuple types, \netc. have kind type. The types of kind term are program variables. If a variable x is bound (by let, \nfun, or match) in the code, then x may appear not only in the code, but also in a type: it is a type \nof kind term. The types of kind perm are permissions. First-order arrow kinds are used to classify parameterized \nalgebraic data types. In Figure 2, we use the meta-variables T and X to stand for types and variables \nof arbitrary kind; we use t and P to suggest that a type has kind type and perm, respectively; we use \na and x to suggest that a variable has kind type and term, respectively. We omit the de.nition of the \nkinding judgment; it appears in the extended version of this paper [28]. The structural type A{f. : t.} \ndescribes a block in the heap whose tag is currently A and whose .elds f. currently have the types t.. \nAn example, taken from \u00a72, is MCons{head :a; tail :()}. . ::= type I term I perm I . .. kind T, t, P \n::= type or permission X t .t variable (a, x, . . .) function type (t.) tuple type A{f.:t.}adoptst structural \ntype T T.n-ary type application. X :. T universal quanti.cation.( X :.) T existential quanti.cation =x \nsingleton type(t I P ) type/permission conjunction dynamic (see \u00a77) x @ t atomic permission empty empty \npermission P *P permission conjunction x :t name introduction (see \u00a76) consumes T consumes annotation \n(see \u00a76) d ::= algebraic data type de.nition . mutable? data d (X.:..) = b adoptst b ::= A{f.:t.} algebraic \ndata type branch Figure 2. Syntax of types and permissions e ::= expression x variable let p = e in e \nlocal de.nition fun [X.:..] (x :t) :t = e anonymous function e [t :.] type instantiation e e function \napplication(.e ) tuple A{f.= e.} data constructor application e.f .eld access e.f .e .eld update match \ne with p..e.case analysis tag of e .A tag update give e to e adoption take e from e abandon fail dynamic \nfailure  p ::= pattern x variable(.p ) tuple pattern A{f.= p.} data constructor pattern Figure 3. Syntax \nof expressions The data constructor A must refer to a previously de.ned algebraic data type, and the \n.elds f. must match the de.nition of A. The types t., however, need not match the types that appear in \nthe de.nition of A. For instance, in the de.nition of MCons, the type of the tail .eld is mlist a, not \n(). This implies that the above structural type cannot be folded to mlist a; the tail .eld must be updated \n.rst. A structural type may include a clause of the form adoptst, whose meaning is explained later on \n(\u00a77). If omitted, adopts1 is the default. An example of a type application T T.is list int. We sometimes \nrefer to this as a nominal type, as opposed to a structural type.  The universal and existential types \nare in the style of System F . A (base) kind annotation is mandatory; if omitted, type is the default. \nThe bottom type 1 and the top type unknown can be de.ned as .a.a and .a.a, respectively. The conjunction \nof a type and a permission is written (t I P ). Because permissions do not exist at runtime, a value \nof this type is represented at runtime as a value of type t. Such a conjunction is typically used to \nexpress function pre-and postconditions. The type (() I P ) is abbreviated as (I P ). Algebraic data \ntype de.nitions are pre.xed with the keyword data. They are anologous to Haskell s and OCaml s. Each \nbranch is explicitly named by a data constructor and carries a number of named .elds. If a de.nition \nbegins with the keyword mutable, then the tag and all .elds are considered mutable, and can be modi.ed \nvia tag update and .eld update instructions; otherwise, they are considered immutable. Examples appear \nat the top of Figure 1. Like a structural type, an algebraic data type de.nition may include an adopts \nclause; if omitted, adopts1is the default.  3.2 Expressions Expressions (Figure 3) form a fairly standard \n.-calculus with tu\u00adples and algebraic data structures. A function de.nition must be explicitly annotated \nwith the function s type parameters, argument type, and return type. One reason for this is that the \nargument and return type serve as pre-and postconditions and in general cannot be inferred. Furthermore, \nwe have System F -style polymorphism. Explicit type abstractions are built into function de.nitions. \nType applications must in principle be explicit as well. The prototype type-checker allows omitting them \nand performs a limited form of type inference, which is outside the scope of this paper. 4. Ownership, \nmodes, and extent We wrote earlier (\u00a71) that to have a permission for x can be understood informally \nas to own x . Roughly speaking, this is true, but we must be more precise, for two reasons. First, we \nwish to distinguish between mutable data, on which we impose a unique owner policy, and immutable data, \nfor which there is no such restriction. For this reason, types and permissions come in several .avors, \nwhich we refer to as modes (\u00a74.1). Second, in a permission of the form x @ t, the type t describes the \nextent to which we own x. If xs is a list cell, do we own just this cell? the entire spine? the spine \nand the elements? The answer is given by the type t. For instance (\u00a74.2), xs @ Cons{head = hd; tail = \ntl} represents the ownership of just the cell xs, because the singleton types =hd and =tl denote the \nownership of an empty heap fragment. On the other hand, xs @ Cons{head : a; tail : list a} gives access \nto the entire list spine. (Because list is an immutable algebraic data type, this is read-only, shared \naccess.) It further gives access to all of the list elements, insofar as the type a allows this access. \nIn this example, a is a variable: one must wait until a is instantiated to determine what the elements \nare and to what extent we own them. 4.1 Modes A subset of the permissions are considered duplicable, \nwhich means that they can be implicitly copied (DU P L I C AT E, Figure 6). Copying a permission for \nan object x means that x may be shared: it may be used via different pointers, or by different threads \nsimul\u00adtaneously. Thus, a duplicable permission does not represent unique ownership; instead, it denotes \nshared knowledge. Because the sys\u00adtem does not control with whom this knowledge is shared, this knowledge \nmust never be invalidated, lest some principals be left with an outdated version of the permission. Therefore, \na duplicable permission denotes shared, permanent knowledge. The permis\u00adsions that describe read-only, \nimmutable data are duplicable: for instance, xs @ Cons{head = hd; tail = tl} and xs @ list int are duplicable. \nA subset of the permissions are considered exclusive. An ex\u00adclusive permission for an object x represents \nthe unique owner\u00adship of x. In other words, such a permission grants read-write ac\u00adcess to the memory \nblock at address x and guarantees that no-one else has access to this block. The permissions that describe \nmutable memory blocks are exclusive: for instance, xs @ MCons{head = hd; tail = tl} is exclusive. An \nexclusive permission is analogous to a unique permission in other systems [5] and to a separation logic \nassertion [29]. By lack of space, we must unfortunately omit the de.nition of the predicates t is duplicable \nand t is exclusive , which are used in the typing rules (Figure 4). They can be found in the extended \nversion of this paper. No permission is duplicable and exclusive. Some permissions are neither duplicable \nnor exclusive. xs @ list (ref int) , which describes an immutable list of references to integers, illustrates \nthis. It must not be duplicated: this would violate the unique owner property of the list elements. It \nis not exclusive: the list cell at xs is an immutable object, and this permission does not guarantee \nexclusive access to this cell. Another example is x @ a . Because a is a type variable, one cannot assume \nthat this permission is duplicable (or exclusive)3 . Every permission is af.ne. One can implicitly drop \na permission that one does not need. The language is designed so that the type-checker (and the pro\u00adgrammer!) \ncan always tell what mode a permission P satis.es: du\u00adplicable, exclusive, or neither (hence, af.ne). \nModes form an upper semi-lattice, whose top element is af.ne , and where duplicable and exclusive are \nincomparable. Because algebraic data types are recursively de.ned, their mode analysis requires a .xed \npoint com\u00adputation, whose details we omit. If t and u are exclusive types, then the conjunction x @ t*y \n@ u implies that x and y are distinct addresses. In other words, conjunc\u00adtion of exclusive permissions \nis separating. On the other hand, if t and/or u are duplicable, x and y may be aliases. Conjunction is \nnot in general separating. Conjunction of duplicable permissions re\u00adquires agreement between the two \nconjuncts. The reader is referred to the draft paper that accompanies the type soundness proof [26] for \na formal de.nition of the semantics of conjunction.  4.2 Extent Every type t has an ownership reading: \nthat is, the permission x @ t represents certain access rights about x. However, the extent of these \nrights (or, in separation logic terminology, their footprint) depends on the type t. A singleton type \n=y, for instance, has empty extent. Indeed, the permission x @ =y, which we usually write x = y, asserts \nthat x and y are equal, but does not allow assuming that x is a pointer, let alone dereferencing it. \nA structural type such as Cons{head = hd; tail = tl} has an extent of one memory block. The permission \nxs @ Cons{head = hd; tail = tl} gives us (read-only, shared) access to the block at address xs, and guarantees \nthat its head and tail .elds contain the values hd and tl, respectively, but (as per the semantics of \nsingleton types) guarantees nothing about hd and tl. What is the extent of a deep composite type, such \nas the structural type Cons{head : a; tail : list a} or the nominal type list a? What does it mean to \nown a list? In order to answer these questions, one must understand how a composite permission is decomposed \ninto a conjunction of more elementary permissions. 3 Mezzo allows the programmer to explicitly assume \nthat a type variable a is duplicable, or exclusive. This mechanism is not treated in this paper.  A \nstructural permission, such as xs @ Cons{head : a; tail : list a}, can be decomposed by introducing a \nfresh name for each of the values stored in the .elds. (See DE C O M P O S E BL O C K in Figure 6.) The \nresult is a more verbose, but logically equivalent, permission: .hd, tl.(xs @ Cons{head = hd; tail = \ntl} *hd @ a *tl @ list a) The meaning and extent of the original structural permission is now clearer: \nit grants access to the cell at xs and to the .rst list element (to the extent dictated by the type a) \nand to the rest of the list. The meaning of a nominal permission, such as xs @ list a, is just the disjunction \nof the meanings of its unfoldings, namely xs @ Nil and xs @ Cons{head :a; tail :list a}. If a is (instantiated \nwith) an exclusive type, then we .nd that xs @ list a implies that the list elements are pairwise distinct, \nand grants read-only access to the list spine and exclusive access to the list elements. 5. Type assignment \n 5.1 The typing judgment The typing judgment takes the form K; P . e : t. It is induc\u00adtively de.ned in \nFigures 4 and 5. The kind environment K maps variables to kinds. This judgment means that, by consuming \nthe permission P , the expression e produces a value of type t. It is analogous to a Hoare logic or separation \nlogic triple, where P is the precondition and t is the postcondition. The typing judgement relies on \na well-kindedness judgement of the form K .t : .. It ensures that types are well-kinded and that the \nsyntactic facilities of the surface syntax (\u00a76) are used properly. For conciseness, in the typing rules, \nwe omit all freshness and well\u00adkindedness side conditions. The typing rules require many sub-expressions \nto be variables. For instance, the rule RE A D cannot handle a .eld access expression of the form e.f: \ninstead, it requires x.f . This requirement is met by .rst performing a monadic transformation, which \nintroduces extra let constructs. Furthermore, the pattern matching rules (Figure 5) cannot handle deep \npatterns: they require shallow patterns. Again, this requirement is met by introducing extra let constructs. \nWe omit the details of these transformations. VA R is the axiom rule. It is worth noting that, in conjunction \nwith the subsumption rule EQ UA L I T Y RE FL E X I V E (Figure 6), it allows proving that x has type \n=x, even in the absence of any hypothesis about x. LE T corresponds to the sequence rule of separation \nlogic. FU N C T I O N states that a duplicable permission P that exists at the function de.nition site \nis also available within the function body. Requiring P to be duplicable allows us to consider every \nfunction type duplicable. Thus, a function can be shared without restriction and can be invoked as many \ntimes as desired, provided of course that one is able to satisfy its precondition. If one wishes to write \na function that captures a non-duplicable permission P , and can be invoked at most once, this is still \npossible. Indeed, a type t1 .t2 of one-shot functions can be de.ned as: .(p :perm) (((t1 I p) .t2) I \np) This is a conjunction of a function whose precondition is p and of one copy of p. Because p is abstract, \nit is considered af.ne. Hence, at most one call is possible, after which p is consumed and the function \nbecomes unusable. AP P L I C AT I O N corresponds to the rule for procedure calls in sep\u00adaration logic. \nThe caller gives up the permission x2 @ t2, which is consumed, and in return gains a permission for the \nresult of the function call, at type t1. In other words, because types have an own\u00adership reading, a \nfunction type t1 .t2 describes not only the shape of the function s arguments and results, but also the \nside effects that the function may perform, as well as the transfers of ownership that occur from the \ncaller to the callee and back. NE W uses a structural type to describe the newly-allocated mem\u00adory block \nin an exact manner. TU P L E is analogous. RE A D requires a structural permission x @ A{F [f : t]}, \nwhich guarantees that x points to a memory block that contains a .eld named f, and allows us to dereference \nx.f4 . RE A D concludes that the .eld access expression x.f has type t, and that the structural permission \nx @ A{F [f :t]} is preserved. There is a catch: because the type t occurs twice in this postcondition, \nwe must require t to be duplicable, or the rule would be unsound. Fortunately, this is not a problem: \nby using DE C O M P O S E BL O C K (Figure 6; also explained earlier, see \u00a72.2 and \u00a74.2), it is possible \nto arrange for t to be a singleton type, which is duplicable. Like RE A D, WR I T E requires a structural \npermission, of the form x1 @ A{F [f :t1]}. It checks that this permission is exclusive, i.e., the data \nconstructor A is associated with a mutable algebraic data type. This ensures that we have write access. \nIn fact, since we have exclusive access to x1, a strong (type-changing) update is sound. The permission \nis changed to x1 @ A{F [f : t2]}, where t2 is the type of x2. Without loss of generality, one may let \nt2 be the single\u00adton type =x2. This allows the type-checker to record that x1.f and x2 are now aliases. \nIf desired, the permissions x1 @ A{F [f = x2]}and x2 @ t2 can later be combined by DE C O M P O S E BL \nO C K to yield x1 @ A{F [f : t2]}. Because DE C O M P O S E BL O C K, read from right to left, involves \na loss of information, it is typically applied by the type-checker only on demand , i.e., to satisfy \na function postcon\u00addition or a type annotation. MAT C H is used to type-check a case analysis construct. \nEach branch is type-checked independently. We currently do not check that the case analysis is exhaustive, \nbut plan to add this feature in the future. The premise relies on a judgment of the form K; P . let p \n= x in e : t. This is not a new judgment; it is an ordinary typing judgement, but, for clarity, the typing \nrules that have a con\u00adclusion of this form are isolated in Figure 5. Although these rules may appear \nsomewhat daunting, they are in fact quite straightfor\u00adward. LE T TU P L E checks that x is a tuple, i.e., \nwe have a permission of the form x @ (t1, . . . , tn). If that is the case, then matching x against the \ntuple pattern (x1, . . . , xn) is permitted, and gives rise to a conjunction of permissions of the form \nxi @ ti. Because the permission for x is not lost, the types ti are duplicated, so they are required \nto be duplicable. Again, this requirement causes no loss of generality, since one can arrange to introduce \nsingleton types ahead of time. LE T DATA MAT C H is analogous to LE T TU P L E, but con\u00ad cerns a (mutable \nor immutable) memory block. LE T DATA MI S M AT C H concerns the situation where the pattern, which mentions \nthe data constructor B, will clearly not match x, which is statically known to have the tag A. In that \ncase, the branch is dead code, and is con\u00adsidered well-typed. LE T DATAUN F O L D re.nes a nominal permission, \nsuch as x @ list a, by replacing it with a structural one, such as x @ Cons{head : a; tail : list a}, \nobtained by unfolding the al\u00adgebraic data type and specializing it with respect to the data con\u00adstructor \nthat appears in the pattern. We omit the exact de.nition of unfolding. WR I T E TAG type-checks a tag \nupdate instruction, which modi.es the tag carried by a memory block. Like WR I T E, it requires an exclusive \npermission for this block. It further requires the new tag B to carry the same number of .elds as the \nprevious tag A. (Thus, the block does not have to be enlarged or shrunk.) The structural permission is \nupdated in a straightforward way. The 4 We write F [f . t] for a sequence of .eld/type pairs in which \nthe pair f . t occurs. The adopts clause, if present, is irrelevant. We overload .eld names: there could \nexist multiple data constructors with a .eld named f. There can be at most one permission of the form \nx @ A{F [f .t]}, though, which allows disambiguation to take place.  LET FUNCTION VAR K; P .e1 :t1 K, \nx :term; x @ t1 . : K, .:., x :term; P * .e : P is duplicable e2 t2 X .x @ t1 t2 K; x @ t .x :t K; P \n.let x = e1 in e2 :t2 K; P .fun [X.:..] (x :t1) :t2 = e :.(X.:..) t1 .t2 INSTANTIATION NEW APPLICATION \nTUPLE K; P .e :.(X :.) t1 K; x1 @ t2 .t1 *x2 @ t2 .x1 x2 :t1 K; x.@ t..(x.) :(t.) A{f.} is de.ned K; \nP .e :[T2/X]t1 K; x.@ t..A{f.= x.} :A{f.:t.} READ t is duplicable WRITE P is x @ A{F [f :t]}adoptsu A{. \n. .} is exclusive K; P .x.f :(t I P ) K; x1 @ A F f :t1 adoptsu *x2 @ t2 .x1.f .x2 :(Ix1 @ A{ F [ f :t2]} \nadoptsu) MATCH WRITETAG for every i, K; P .let pi = x in ei :t A{. . .} is exclusive B{f.'} is de.ned \n#f.= #f.' K; P .match x with p..e.:t K; x @ A f.:t.}adoptsu .tag of x .B :(Ix @ B{ .:t}adoptsu) f ' \n. SUB GIVE TAKE K; P2 .e :t1 FAIL t2 adopts t1 t2 adopts t1 P1 = P2 t1 = t2 K; P .fail :t K; x1 @ \nt1 *x2 @ t2 . K; x1 @ dynamic *x2 @ t2 . K; P1 .e :t2 give x1 to x2 :(I x2 @ t2) take x1 from x2 :(I \nx1 @ t1 *x2 @ t2) FRAME EXISTSELIM K; P1 .e :t K, X :.; P .e :t K; P1 *P2 .e :(t I P2) K; .(X :.) P .e \n:t Figure 4. Typing rules LETTUPLE LETDATAMATCH(t.) is duplicable (t.) is duplicable K, x.:term; P *x \n@ (t.) *x.@ t..e :t K, x.:term; P *x @ A{f.:t.}adoptsu *x.@ t..e :t . K; P *x @ (t.) .let (.x) = x in \ne :t K; P *x @ A{f.:t}adoptsu .let A{f.= x.} = x in e :t LETDATAUNFOLD x @ A{f.:t}adoptsu is an unfolding \nof T T .. LETDATAMISMATCH A and B belong to a common algebraic data type K; P *x @ A{f.:t.}adoptsu .let \nA{f.= x.} = x in e :t . K; P *x @ A{f.:t.}adoptsu .let B{f.' = x.} = x in e :t K; P *x @ T T .let A{f.= \nx.} = x in e :t Figure 5. Auxiliary typing rules for pattern matching DUPLICATE EQUALITYREFLEXIVE EQUALSFOREQUALS \nMIXSTAR P is duplicable empty = (x = x) (y1 = y2) *[y1/x]P = (y1 = y2) *[y2/x]P x @ t *P = x @ (t I \nP ) P = P *P EXISTSATOMIC DECOMPOSEBLOCK WEAKEN EXISTSINTRO x @ .(X :.) t y @ A F f :t]}adoptsuP1 *P2 \n= P2 [T /X]P = .(X :.) P = .(X :.) (x @ t) = .(x :term) (y @ A{ F [ f = x]}adoptsu *x @ t) UNFOLD FOLD \nA{f.:t}adoptsu is an unfolding of T T .. DYNAMICAPPEARS .. A{f.:t}adoptsu is an unfolding of T T T \nT.has only one branch t is exclusive .. x @ A{f.:t.}adoptsu = x @ T T x @ T T = x @ A{f.:t.}adoptsu x \n@ t = x @ t *x @ dynamic Figure 6. Permission subsumption (not all rules shown) types t.of the .elds \ndo not change. The names of the .elds change from f. to f.' , where the sequences of .elds are ordered \nin the same way as in the (user-provided) de.nitions of A and B. It is worth noting that A and B need \nnot belong to the same algebraic data type: thus, a memory block can be re-used for a completely new \npurpose. Furthermore, the tag B may be associated with an immutable algebraic data type: in that case, \nthe block is frozen, that is, becomes forever immutable. This feature is exploited in the concatenation \nof immutable lists (Figure 1, line 19). GI V E and TA K E are explained later on (\u00a77). SU B is analogous \nto Hoare s rule of consequence. It relies on permission subsumption, P1 = P2, de.ned in Figure 6 and \ndis\u00adcussed further on (\u00a75.2), and on subtyping, t1 = t2, de.ned as x @ t1 = x @ t2 for a fresh x. FR \nA M E is analogous to the frame rule of separation logic.  5.2 The permission subsumption judgment A \nsubset5 of the subsumption rules appears in Figure 6. Since x = y is sugar for x @ =y, the rule EQ UA \nL I T Y RE FL E X I V E can be understood as a claim that x inhabits the singleton type =x. EQ UA L S \nFO R EQ UA L S shows how equations are exploited: if y1 and y2 are known to be equal, then they are interchangeable. \n(We write =for subsumption in both directions.) DU P L I C AT E states that a permission that is syntactically \nconsidered duplicable can in fact be duplicated. MI X STA R introduces and eliminates (t I P ). WE A \nK E N states that every permission is af.ne. EX I S T S IN T RO introduces an existential permission; \nEX I S T S AT O M I C converts between an exis\u00adtential permission and an existential type. When read \nfrom left to right, DE C O M P O S E BL O C K, which was discussed earlier (\u00a72.2, \u00a74.2), introduces a \nfresh name x for the value stored in y.f . When read from right to left, it forgets such a name. (In \nthat case, it is typi\u00adcally used in conjunction with EX I S T S IN T RO.) This rule is related to Sing# \ns explicit expose [15]. FO L D folds an algebraic data type de.nition, turning a structural type into \na nominal type. Unfold\u00ading is normally performed by case analysis (see LE T DATAUN F O L D in Figure \n5), but in the special case where an algebraic data type has only one branch (i.e., it is a record type), \nit can be implicitly unfolded by UN F O L D. DY NA M I C AP P E A R S is explained later on (\u00a77).  5.3 \nThe Mezzo type-checker Implementing a checker for a highly non-deterministic system such as Mezzo poses \ntechnical challenges. Our type-checker greedily introduces fresh auxiliary names so as to normalize the \ntypes and permissions at hand. A persistent union-.nd data structure keeps track of the permissions of \nthe form x = y . The use of .exible variables enables a limited form of type inference. At present, the \nimplemented type-checker is not complete with respect to the type assignment rules. This is only a brief \noverview: a follow-up paper devoted to the implementation of Mezzo is in the works. 6. Surface syntax \nThe internal syntax, which we have been using so far, can be fairly verbose. To remedy this, we introduce \ntwo syntactic con\u00adventions, which rely on the name introduction construct and on the consumes keyword \n(Figure 2). Two transformations eliminate these constructs, so as to obtain a type expressed in the internal \nsyntax. They are formalized in the extended version of the present paper [28]. Here, we give only an \nintuition. 5 The reader is referred to the extended version of this paper [28] for the full set of rules. \nThe omitted rules include: conjunction is commutative, associative, and has unit empty; covariance and \ncontravariance of the type constructors; and a few more. 6.1 The name introduction form The construct \nx : t allows introducing a name x for a component of type t. This allows writing dependent function types \n, such as (x1 : t1) . (x2 : t2), where by convention x1 is bound within t1 and t2, while x2 is bound \nwithin t2. This is desugared by quanti.ying x1 universally above the arrow and quantifying x2 existentially \nin the right-hand side of the arrow. As an example, consider the type of :=, the function that writes \na reference. This function expects a pair of a reference x whose content has type a and of a value of \ntype b, which it stores into x. At the end, x has become a reference whose content has type b. The variable \nx must be mentioned in the pre-and postcondition. In the internal syntax, the type of := is: .a, b..(x \n:term) ((=x I x @ ref a), b) .(I x @ ref b) Thanks to the name introduction form, instead of planning \nahead and quantifying x in front of the function type, one names the .rst argument x on the .y. Thus, \nin the surface syntax, one writes: .a, b.(consumes x :ref a, consumes b) .(I x @ ref b) This is not signi.cantly \nshorter, because of the consumes keyword, which must be used in the surface syntax, as explained below. \nIn actual use, though, the comfort afforded by this feature is critical.  6.2 The consumes annotation \nOften, a permission is required and returned by a function, in which case it is unpleasant to have to \nwrite this permission twice, in the precondition and postcondition. Drawing inspiration from Sing# [15], \nwe adopt the convention that, in the surface syntax, by default, the permission for the argument is required \nand returned, i.e., it is not consumed. For instance, the type of the list length function, which in \nthe internal syntax is: .a..(x :term)(=x I x @ list a) .(int I x @ list a) can in the surface syntax \nbe written in a much more pleasant form: .a.list a .int The type list a is mentioned once, instead of \ntwice, and as a side effect, the need to name the argument x vanishes. When a permission is consumed, \nthough, we need a way of indicating this. This is the purpose of the consumes keyword. When a component \nis marked with this keyword, the permission for this component is required and not returned. This keyword \nmakes sense only in the left-hand side of an arrow. Since internal syntax and surface syntax interpret \nthe function type differently, a translation is required, regardless of whether consumes is used. Consider \na function type of the form t . u, where t does not contain any name introduction forms. Let t1 stand \nfor [t /consumes t]t, i.e., a copy of t where the consumes keyword is erased. Let t2 stand for [./consumes \nt]t, i.e., a copy of t where every component marked with this keyword is replaced with .6 . Then, the \ntranslation of this function type is (x : t1) . (u I x @ t2). The parts of the argument that are not \nmarked as consumed are returned to the caller. The type of the function insert, which appears in Figure \n7 and is discussed in \u00a77.1, states that the .rst argument is consumed, while the second argument is not. \nIts translation into the internal syntax is as follows: .(a :type) .(x :term) (=x I x @ (a, bag a)) .(I \nx @ (unknown, bag a)) 6 Here, we write . for unknown or empty, depending on whether the consumes keyword \nis applied to a type or a permission.  1 a b s t r a c t b a g a 2 v a l c r e a t e : [ a ] ( ) -> \nb a g a 3 v a l i n s e r t : [ a ] ( c o n s u m e s a , b a g a ) -> () 4 v a l r e t r i e v e : [ \na ] b a g a -> o p t i o n a Figure 7. An interface for bags 1 d a t a m u t a b l e c e l l a = 2 C \ne l l { e l e m : a ; n e x t : d y n a m i c } 3 4 d a t a m u t a b l e b a g a = 5 E m p t y { h e \na d , t a i l : ( ) } 6 | N o n E m p t y { h e a d , t a i l : d y n a m i c } 7 a d o p t s c e l l \na 8 9 v a l c r e a t e [ a ] ( ) : b a g a = 10 E m p t y { h e a d = ( ) ; t a i l = ( ) } 11 12 v \na l i n s e r t [ a ] ( c o n s u m e s x : a , b : b a g a ) : ( ) = 13 l e t c = C e l l { e l e m \n= x ; n e x t = ( ) } in 14 c . n e x t <-c ; 15 g i v e c t o b ; 16 m a t c h b w i t h 17 | E m p \nt y -> 18 t a g o f b < -N o n E m p t y ; 19 b . h e a d <-c ; 20 b . t a i l <-c 21 | N o n E m p t \ny -> 22 t a k e b . t a i l f r o m b ; 23 b . t a i l . n e x t < -c ; 24 g i v e b . t a i l t o b \n; 25 b . t a i l <-c 26 e n d 27 28 v a l r e t r i e v e [ a ] ( b : b a g a ) : o p t i o n a = 29 \nm a t c h b w i t h 30 | E m p t y -> 31 N o n e 32 | N o n E m p t y -> 33 t a k e b . h e a d f r o \nm b ; 34 l e t x = b . h e a d . e l e m i n 35 i f b . h e a d = = b . t a i l t h e n b e g i n 36 \nt a g o f b < -E m p t y ; 37 b . h e a d < -( ) ; 38 b . t a i l < -( ) 39 e n d e l s e b e g i n 40 \nb . h e a d < -b . h e a d . n e x t 41 e n d ; 42 S o m e { v a l u e = x } 43 e n d Figure 8. A FIFO \nimplementation of bags  6.3 Function de.nitions In the internal syntax, functions take the form fun \n(x :t1) :t2 = e, where one variable, namely x, is bound in e. In the surface syntax, instead, functions \ntake the form fun t1 : t2 = e. The argument type t1 is interpreted as a pattern, and the names that it \nintroduces are considered bound in e. An example is fun (x : int, y : int) : int = x +y, where (x : int, \ny : int) is the type of the argument, int is the type of the result, and x and y are bound in the function \nbody, which is x +y. 7. Adoption and abandon The permission discipline that we have presented so far \nhas limited expressive power. It can describe immutable data structures with ar\u00adbitrary sharing and tree-shaped \nmutable data structures. However, because mutable memory blocks are controlled by exclusive per\u00admissions, \nit cannot describe mutable data structures with sharing. 7.1 Overview In order to illustrate this problem, \nlet us imagine how one could implement a bag abstraction. A bag is a mutable container, which supports \ntwo operations: inserting a new element and retrieving an arbitrary element. We would like our implementation \nto offer the interface in Figure 7. There, bag is presented as an abstract type. Because it is not explicitly \ndeclared duplicable, it is regarded as af.ne. Hence, a bag has a unique owner , i.e., is governed by \na non\u00adduplicable permission. The function create creates a new bag, whose ownership is transferred to \nthe caller. The type of insert indicates that insert(x, b) requires the permissions x @ t and b @ bag \nt , for some type t, and returns only the latter. Thus, the caller gives up the ownership of x, which \nis transferred to the bag . Conversely, the call let o = retrieve b in ... produces the permission o \n@ option a , which means that the ownership of the retrieved element (if there is one) is transferred \nfrom the bag to the caller . To implement bags, we choose a simple data structure, namely a mutable singly-linked \nlist. One inserts elements at the tail and extracts elements at the head, so this is a FIFO implementation. \nOne distinguished object b, the bag , has pointers to the head and tail of the list, so as to allow constant-time \ninsertion and extraction. (We use object as a synonym for memory block .) This data structure is not \ntree-shaped: the last cell in the list is accessible via two distinct paths. In order to type-check this \ncode, we must allow the ownership hierarchy and the structure of the heap to differ. More speci.cally, \nwe would like to view the list cells as collectively owned by the bag b. That is, we wish to keep track \nof just one exclusive permission for the group formed by the list cells, as opposed to one permission \nper cell. We use the name b as a name for this group. When a cell c joins the group, we say that b adopts \nc, and when c leaves the group, we say that b abandons c. In other words, the bag b is an adopter, and \nthe list cells c are its adoptees. In terms of ownership, adopter and adoptees form a unit: the exclusive \npermission that controls b also represents the ownership of the group, and is required by the adoption \nand abandon operations. Adoption requires and consumes an exclusive permission for the cell c that is \nabout to be adopted: the ownership of c is trans\u00adferred to the group. Conversely, abandon produces an \nexclusive per\u00admission for the cell c that is abandoned: the group relinquishes the ownership of c. Abandon \nmust be carefully controlled. If a cell could be aban\u00addoned twice, two permissions for it would appear, \nwhich would be unsound. Due to aliasing, though, it is dif.cult to statically prevent this problem. Instead, \nwe decide to record at runtime which object is a member of which group, and to verify at runtime that \nabandon is used in a safe way.  7.2 Details Let us now explain in detail the dynamic semantics of adoption \nand abandon (what these operations do) as well as their static semantics (what the type-checker requires). \nAdopter .elds We maintain a pointer from every adoptee to its adopter. Within every object, there is \na hidden adopter .eld, which contains a pointer to the object s current adopter, if it has one, and null \notherwise. This information is updated when an object is adopted or abandoned. In terms of space, the \ncost of this design decision is one .eld per object.  The type dynamic The permission c @ dynamic guarantees \nthat c is a pointer to a memory block and grants read access to the .eld c.adopter. This can be used \nto verify the identity of c s adopter. In other words, c @ dynamic can be viewed as a permis\u00adsion to \nperform a dynamic group membership test. It is a duplicable permission. It appears spontaneously when \nc is known to be a (mutable) object: this is stated by the rule DY NA M I C AP P E A R S in Figure 6. \nIn the bag implementation, shown in Figure 8, the head and tail .elds of a non-empty bag object, as well \nas the next .eld of every cell object, have type dynamic (lines 2 and 6). Because dynamic is duplicable, \nsharing is permitted: for instance, the pointers b.head and b.tail might happen to be equal. Adopts clauses \nWhen a cell c is adopted, the exclusive per\u00admission that describes it, namely c @ cell a , disappears. \nOnly c @ dynamic remains. As a result, the information that c is a cell is lost: the type-checker can \nno longer tell how many .elds exist in the object c and what they contain. When the bag b later aban\u00addons \nc, we would like the permission c @ cell a to re-appear. How can the type-checker recover this information? \nFortunately, when b abandons c, the type-checker has access to the type of b. Thus, provided the type \nof the adopter determines the type of its adoptees, this problem is solved. For an object b of type t \nto serve as an adopter, where t is an algebraic data type, we require that the de.nition of t contain \nthe clause adopts u and that t and u be exclusive types. This is illustrated in Figure 8, where the de.nition \nof bag a says adopts cell a (line 7). Because the type of the adoptees must not be forgotten when an \nalgebraic data type is unfolded, structural permissions also carry an adopts clause. In the case of bags, \nfor instance, the permission b @ bag a is re.ned by the match constructs of lines 16 and 29 into either \nb @ Empty { head, tail: () } adopts cell a or b @ NonEmpty { head, tail: dynamic } adopts cell a , and, \nconversely, either of these permissions can be folded back to b @ bag a . We write that t adopts u if \neither t is an algebraic data type whose de.nition contains the clause adopts u or t is a structural \ntype that contains the clause adopts u . Adoption The syntax of adoption is give c to b . This in\u00adstruction \nrequires two permissions c @ u and b @ t , where t adopts u (GI V E, Figure 4). At the program point \nthat follows this instruction, the permission b @ t remains available, but c @ u has been consumed. Fortunately, \nnot everything about c is forgot\u00adten. The permission c @ dynamic , which is present before the adoption \ninstruction because c @ u spontaneously gives rise to c @ dynamic , remains present after adoption. The \nruntime effect of this operation is to write the address b to the .eld c.adopter. The exclusive permission \nc @ u guarantees that this .eld exists and that its value, prior to adoption, is null. In the bag implementation \n(Figure 8), adoption is used at the beginning of insert (line 15), after a fresh cell c has been allocated \nand initialized. This allows us to maintain the (unstated) invariant that every cell that is reachable \nfrom b is adopted by b. Abandon The syntax of abandon is take c from b . This in\u00adstruction requires b \n@ t and c @ dynamic , where t adopts u , for some type u (TA K E, Figure 4). After this instruction, \nb @ t remains available. Furthermore, the permission c @ u appears. The runtime effect of this operation \nis to check that the .eld c.adopter contains the address b and to write null into this .eld, so as to \nre.ect the fact that b abandons c. If this check fails, the execution of the program is aborted. In the \nbag implementation (Figure 8), abandon is used near the beginning of retrieve, at line 33. There, the \n.rst cell in the queue, b.head, is abandoned by b. This yields a permission at type cell a for this cell. \nThis permission lets us read b.head.elem and b.head.next and allows us to produce the permission x @ \na , where x is the value found in b.head.elem. Abandon and adoption are also used inside insert, at lines \n22 and 24. There, the bag b is non-empty, and the cell b.tail must be updated in order to re.ect the \nfact that it is no longer the last cell in the queue. However, we cannot just go ahead and access this \ncell, because the only permission that we have at this point for this cell is at type dynamic . Instead, \nwe must take the cell out of the group, update it, and put it back. We allow writing taking b.tail from \nb begin ... end as sugar for such a well\u00adparenthesized use of take and give.  7.3 Discussion To the \nbest of our knowledge, adoption and abandon are new. Naturally, the concept of group, or region, has \nreceived sustained interest in the literature [11, 12, 16, 32]. Regions are usually viewed either as \na dynamic memory management mechanism or as a purely static concept. Adoption and abandon, on the other \nhand, offer a dynamic ownership control mechanism, which complements our static permission discipline. \nAdoption and abandon are a very .exible mechanism, but also a dangerous one. Because abandon involves \na dynamic check, it can cause the program to encounter a fatal failure at runtime. In principle, if the \nprogrammer knows what she is doing, this should never occur. There is some danger, but that is the price \nto pay for a simpler static discipline. After all, the danger is effectively less than in ML or Java, \nwhere a programming error that creates an undesired alias goes completely undetected until the program \nmisbehaves in one way or another. One might wonder why the type dynamic is so uninformative: it gives \nno clue as to the type of the adoptee or the identity of the adopter. Would it be possible to parameterize \nit so as to carry either information? The short answer is negative. The type dynamic is duplicable, so \nthe information that it conveys should be stable (i.e., forever valid). However, the type of the adoptee, \nor the identity of the adopter, may change with time, through a combination of strong updates and give \nand take instructions. Thus, it would not make sense for dynamic to carry more information. That said, \nwe believe that adoption and abandon will often be used according to certain restricted protocols, for \nwhich more information is stable, hence can be re.ected at the type level. For instance, in the bag implementation, \na cell only ever has one adopter, namely a speci.c bag b. In that case, one could hope to work with a \nparameterized type dynamic ' b, whose meaning would be either this object is currently not adopted, or \nit is adopted by b . Ideally, dynamic ' would be de.ned on top of dynamic in a library module, and its \nuse would lessen the risk of confusion. 8. Other means of permitting sharing Adoption and abandon is \nnot the only way of sharing mutable data. We now describe two other mechanisms, namely nesting and locks. \n 8.1 Nesting Nesting [7] is a mechanism by which an object x adopts (so to speak) a permission P . It \nis a purely static mechanism. The act of nesting P in x has no runtime effect, but consumes P and produces \na witness, a permission which Boyland writes P . x. Because nesting is irreversible, such a witness is \nduplicable. Once P has been nested in x, whoever has exclusive owner\u00adship of x may decide to temporarily \nrecover P . This is done via two symmetric operations, say focus and defocus , which in the presence \nof P . x convert between x @ t and P *(P -+x @ t) (where the type t is arbitrary, but must be exclusive). \nThe permis\u00adsion P -+x @ t means that P has been carved out of x. While this is the case, x @ t is temporarily \nlost: in order to recover it, one must give up P . Thus, it is impossible to simultaneously carve two \npermissions out of x.  Nesting subsumes F\u00e4hndrich and DeLine s adoption and focus [16]. We view it as \na purely static cousin of adoption and abandon. Adoption is more .exible in several important ways: it \nallows ac\u00adcessing two adoptees at the same time, and allows abandoning an object forever. Nesting has \nadvantages over adoption and abandon: it cannot fail at runtime; it has no time or space overhead; one \nmay nest a permission, whereas one adopts an object; and nesting is het\u00aderogeneous, i.e., an object x \ncan nest multiple distinct permissions, whereas, in the case of adoption and abandon, all adoptees of \nx must have the same type. Nesting can be axiomatized in Mezzo as a trusted library, whose interface \nappears in the extended version of this paper [28]. In principle, this requires extending the proof of \ntype soundness; we have not done so. When applicable, nesting seems preferable to adoption; however, \nadoption is more widely applicable.  8.2 Locks Dynamically-allocated locks in the style of concurrent \nseparation logic [25, 18, 19, 8] are another dynamic mechanism for mediating access to a permission. \nA new lock, of type lock P , where P is an arbitrary permission, is created via a function new. The functions \nacquire and release both take the lock as an argument; acquire produces the permission P , which release \nconsumes. The type lock P is duplicable, so an arbitrary number of threads can share the lock and simultaneously \nattempt to acquire it. Within a critical section, delimited by acquire and release, the lock invariant \nP is available, whereas, outside of it, it is not. The invariant P can in fact be broken within the critical \nsection, provided it is restored when one reaches the end of the section. Locks introduce a form of hidden \nstate into the language. Be\u00adcause the permission l @ lock P is duplicable, it can be captured by a closure. \nAs a result, it becomes possible for a function to per\u00adform a side effect, even though its type does \nnot reveal this fact (the pre-and postcondition are empty). Mezzo s modest library for memoization exploits \nthis feature. Locks can be used to encode weak (duplicable) references in the style of ML and duplicable \nreferences with af.ne content in the style of Alms [33], both of which support arbitrary sharing. Locks \ncan be axiomatized in Mezzo as a library, whose interface appears in the extended version of this paper \n[28]. Again, the proof of type soundness must be extended; we have begun this work. We view locks as \ncomplementary to adoption and abandon and nesting. In a typical usage scenario, a lock protects an adopter, \nwhich in turn controls a group of adoptees (or of nested permissions). This allows a group of objects \nto be collectively protected by a single lock. It should be noted that (we believe) adoption and abandon \nare sound in a concurrent setting. 9. Related work The literature offers a wealth of type systems and \nprogram logics that are intended to help write correct programs in the presence of mutable, heap-allocated \nstate. We review a few of them and contrast them with Mezzo. Ownership Types [10] and its descendants \nrestrict aliasing. Ev\u00ad ery object is owned by at most one other object, and an owner\u00adas-dominator principle \nis enforced: every path from a root to an object x must go through x s owner. Universe Types [14] impose \na slightly different principle, owner-as-modi.er . Arbitrary paths are allowed to exist in the heap, \nbut only those that go through x s owner can be used to modify x. This approach is meant to support program \nveri.cation, as it allows the owner to impose an object in\u00advariant. Permission systems [5, 7, 17] annotate \npointers not with owners, but with permissions. The permission carried by a pointer tells how this pointer \nmay be used (e.g. for reading and writing, only for reading, or not at all) and how other pointers to \nthe same object (if they exist) might be used by others. The systems mentioned so far are re.nements \n(restrictions) of a traditional type discipline. Separation logic [29] departs from this approach and \nobeys a principle that we dub owner-as-asserter . (In O Hearn s words, ownership is in the eye of the \nasserter [25].) Objects are described by logical assertions. To assert is to own: if one knows that x \nis a linked list , then one may read and write the cells that form this list, and nobody else may. Whereas \nthe pre\u00adviously mentioned systems combine structural descriptions (i.e., types) with owner or permission \nannotations, separation logic as\u00adsertions are at once structural descriptions and claims of ownership. \nMezzo follows the owner-as-asserter principle. In the future, this should allow us to annotate permissions \nwith logical assertions and use that as a basis for the speci.cation and proof of Mezzo programs. A tempting \nresearch direction is to translate Mezzo into F . [31]. This purely functional programming language is \nequipped with af.ne values, with powerful facilities for expressing program speci.cations and proofs, \nand with a notion of proof erasure. Although our permission discipline is partly inspired by sepa\u00adration \nlogic [29], it is original in several ways. It presents itself as a type system, as opposed to a program \nlogic. This makes it less expressive than a program logic, but more pervasive, in the sense that it can \n(and must) be used at every stage of a program s de\u00advelopment, without proof obligations. It distinguishes \nbetween im\u00admutable and mutable data, supports .rst-class functions, and takes advantage of algebraic \ndata types in novel ways. As far as we know, Ownership or Universe Types cannot express uniqueness or \nownership transfer. M\u00fcller and Rudich [23] extend Universe Types with these notions. They rely on the \nfact that each object maintains, at runtime, a pointer to its owner. The potential analogy with our adopter \n.elds deserves further study. The use of singleton types to keep track of equations, and the idea that \npointers can be copied, whereas permissions are af.ne, are inspired by Alias Types [30]. Linear [1] and \naf.ne [33] type systems support strong updates and often view permissions (or capabilities ) as ordinary \nvalues, which hopefully the compiler can erase. By offering an explicit distinction between permissions \nand values, we guarantee that permissions are erased, and we are able to make the .ow of permissions \nmostly implicit. Through algebraic data types and through the type constructor (t I P ), we retain the \nability to tie a permission to a value, if desired. Regions [30, 16, 1] have been widely used as a technical \ndevice that allows a type to indirectly refer to a value or set of values. In Mezzo, types refer to values \ndirectly. This simpli.es the meta\u00adtheory and the programmer s view. Gordon et al. [17] ensure data-race \nfreedom in an extension of C#. They qualify types with permissions in the set immutable, isolated, writable, \nor readable. The .rst two roughly correspond to our immutable and mutable modes, whereas the last two \nhave no Mezzo analogue. Shared (writable) references allow legacy se\u00adquential code to be considered well-typed. \nA salient feature is the absence of an alias analysis, which simpli.es the system consider\u00adably. This \ncomes at a cost in expressiveness: mutable global vari\u00adables, as well as shared objects protected by \nlocks, are disallowed. Plaid [2] and Mezzo exhibit several common traits. A Plaid ob\u00adject does not belong \nto a .xed class, but can move from one state to another: this is related to Mezzo s tag update. Methods \ncarry state pre-and postconditions, which are enforced via permissions [5]. Plaid is more ambitious in \nthat states are organized in an extensible hierarchy, whereas algebraic data types are .at and closed. \n 10. Conclusion and future work Mezzo is a high-level functional and imperative programming lan\u00adguage \nwhere the traditional concept of type is replaced with a more powerful concept of permission . Distinguishing \nduplica\u00adble, exclusive, and af.ne permissions allows reasoning about state changes. We strive to achieve \na balance between simplicity and expressiveness by marrying a static discipline of permissions and a \nnovel dynamic form of adoption and abandon. By adding other mechanisms for controlling sharing, such \nas nesting and locks, we augment the expressiveness of the language and emphasize that the permission \ndiscipline is suf.ciently powerful to express these no\u00adtions. Mezzo is type-safe: well-typed programs \ncannot go wrong (but an abandon operation can fail). We have carried out a machine\u00adchecked proof of type \nsafety [26]. In the future, we would like to extend Mezzo with support for shared-memory concurrency. \nWe believe that, beyond locks (\u00a78.2), many abstractions (threads, chan\u00ad nels, tasks, etc.) can be axiomatized \nso as to guarantee that well\u00adtyped code is data-race-free. References [1] Amal Ahmed, Matthew Fluet, \nand Greg Morrisett. L3: A linear language with locations. Fundamenta Informatic\u00e6, 77(4):397 449, 2007. \n[2] Jonathan Aldrich, Joshua Sunshine, Darpan Saini, and Zachary Sparks. Typestate-oriented programming. \nIn Companion to Object-Oriented Programming, Systems, Languages, and Applications (OOP-SLA), pages 1015 \n1022, 2009. [3] Mike Barnett, K. Rustan M. Leino, and Wolfram Schulte. The Spec# programming system: \nAn overview. In Construction and Analysis of Safe, Secure and Interoperable Smart devices (CASSIS), volume \n3362 of Lecture Notes in Computer Science, pages 49 69. Springer, 2004. [4] Josh Berdine, Cristiano Calcagno, \nand Peter W. O Hearn. Smallfoot: Modular automatic assertion checking with separation logic. In For\u00admal \nMethods for Components and Objects, volume 4111 of Lecture Notes in Computer Science, pages 115 137. \nSpringer, 2005. [5] Kevin Bierhoff and Jonathan Aldrich. Modular typestate checking of aliased objects. \nIn Object-Oriented Programming, Systems, Lan\u00adguages, and Applications (OOPSLA), pages 301 320, 2007. \n[6] Kevin Bierhoff, Nels E. Beckman, and Jonathan Aldrich. Practical API protocol checking with access \npermissions. In European Con\u00adference on Object-Oriented Programming (ECOOP), volume 5653 of Lecture Notes \nin Computer Science, pages 195 219. Springer, 2009. [7] John Tang Boyland. Semantics of fractional permissions \nwith nesting. ACM Transactions on Programming Languages and Systems, 32(6), 2010. [8] Alexandre Buisse, \nLars Birkedal, and Kristian St\u00f8vring. A step\u00ad indexed Kripke model of separation logic for storable locks. \nElec\u00adtronic Notes in Theoretical Computer Science, 276:121 143, 2011. [9] Arthur Chargu\u00e9raud. Characteristic \nFormulae for Mechanized Pro\u00ad gram Veri.cation. PhD thesis, Universit\u00e9 Paris 7, 2010. [10] David G. Clarke, \nJohn M. Potter, and James Noble. Ownership types for .exible alias protection. In Object-Oriented Programming, \nSys\u00adtems, Languages, and Applications (OOPSLA), pages 48 64, 1998. [11] Karl Crary, David Walker, and \nGreg Morrisett. Typed memory man\u00ad agement in a calculus of capabilities. In Principles of Programming \nLanguages (POPL), pages 262 275, 1999. [12] Robert DeLine and Manuel F\u00e4hndrich. Enforcing high-level \nproto\u00ad cols in low-level software. In Programming Language Design and Implementation (PLDI), pages 59 \n69, 2001. [13] Robert DeLine and Manuel F\u00e4hndrich. Typestates for objects. In European Conference on \nObject-Oriented Programming (ECOOP), volume 3086 of Lecture Notes in Computer Science, pages 465 490. \nSpringer, 2004. [14] Werner Dietl and M\u00fcller Peter. Universes: Lightweight ownership for JML. Journal \nof Object Technology, 4(8):5 32, 2005. [15] Manuel F\u00e4hndrich, Mark Aiken, Chris Hawblitzel, Orion Hodson, \nGalen Hunt, James R. Larus, and Steven Levi. Language support for fast and reliable message-based communication \nin Singularity OS. In EuroSys, pages 177 190, 2006. [16] Manuel F\u00e4hndrich and Robert DeLine. Adoption \nand focus: practical linear types for imperative programming. In Programming Language Design and Implementation \n(PLDI), pages 13 24, 2002. [17] Colin S. Gordon, Matthew J. Parkinson, Jared Parsons, Aleks Brom\u00ad.eld, \nand Joe Duffy. Uniqueness and reference immutability for safe parallelism. In Object-Oriented Programming, \nSystems, Languages, and Applications (OOPSLA), pages 21 40, 2012. [18] Alexey Gotsman, Josh Berdine, \nByron Cook, Noam Rinetzky, and Mooly Sagiv. Local reasoning for storable locks and threads. Techni\u00ad cal \nReport MSR-TR-2007-39, Microsoft Research, 2007. [19] Aquinas Hobor, Andrew W. Appel, and Francesco Zappa \nNardelli. Oracle semantics for concurrent separation logic. In European Sym\u00adposium on Programming (ESOP), \nvolume 4960 of Lecture Notes in Computer Science, pages 353 367. Springer, 2008. [20] Bart Jacobs and \nFrank Piessens. The VeriFast program veri.er. Tech\u00ad nical Report CW-520, Department of Computer Science, \nKatholieke Universiteit Leuven, 2008. [21] Toshiyuki Maeda, Haruki Sato, and Akinori Yonezawa. Extended \nalias type system using separating implication. In Types in Language Design and Implementation (TLDI), \n2011. [22] Yasuhiko Minamide. A functional representation of data structures with a hole. In Principles \nof Programming Languages (POPL), pages 75 84, 1998. [23] Peter M\u00fcller and Arsenii Rudich. Ownership transfer \nin universe types. In Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA), pages \n461 478, 2007. [24] Karl Naden, Robert Bocchino, Jonathan Aldrich, and Kevin Bierhoff. A type system \nfor borrowing permissions. In Principles of Program\u00adming Languages (POPL), pages 557 570, 2012. [25] \nPeter W. O Hearn. Resources, concurrency and local reasoning. Theoretical Computer Science, 375(1 3):271 \n307, 2007. [26] Fran\u00e7ois Pottier. Type soundness for Core Mezzo. Unpublished, January 2013. [27] Fran\u00e7ois \nPottier and Jonathan Protzenko. Mezzo. http://gallium. inria.fr/~protzenk/mezzo-lang/, July 2013. [28] \nFran\u00e7ois Pottier and Jonathan Protzenko. Programming with permis\u00ad sions in Mezzo (long version). Unpublished, \nJuly 2013. [29] John C. Reynolds. Separation logic: A logic for shared mutable data structures. In Logic \nin Computer Science (LICS), pages 55 74, 2002. [30] Frederick Smith, David Walker, and Greg Morrisett. \nAlias types. In European Symposium on Programming (ESOP), volume 1782 of Lecture Notes in Computer Science, \npages 366 381. Springer, 2000. [31] Nikhil Swamy, Juan Chen, C\u00e9dric Fournet, Pierre-Yves Strub, Karthik \nBhargavan, and Jean Yang. Secure distributed programming with value-dependent types. In International \nConference on Functional Programming (ICFP), pages 266 278, 2011. [32] Nikhil Swamy, Michael Hicks, Greg \nMorrisett, Dan Grossman, and Trevor Jim. Safe manual memory management in Cyclone. Science of Computer \nProgramming, 62(2):122 144, 2006. [33] Jesse A. Tov and Riccardo Pucella. Practical af.ne types. In Princi\u00adples \nof Programming Languages (POPL), pages 447 458, 2011. [34] Thomas Tuerk. Local reasoning about while-loops. \nUnpublished, 2010. [35] David Walker and Greg Morrisett. Alias types for recursive data structures. In \nTypes in Compilation (TIC), volume 2071 of Lecture Notes in Computer Science, pages 177 206. Springer, \n2000.     \n\t\t\t", "proc_id": "2500365", "abstract": "<p>We present Mezzo, a typed programming language of ML lineage. Mezzo is equipped with a novel static discipline of duplicable and affine permissions, which controls aliasing and ownership. This rules out certain mistakes, including representation exposure and data races, and enables new idioms, such as gradual initialization, memory re-use, and (type)state changes. Although the core static discipline disallows sharing a mutable data structure, Mezzo offers several ways of working around this restriction, including a novel dynamic ownership control mechanism which we dub \"adoption and abandon\".</p>", "authors": [{"name": "Fran&#231;ois Pottier", "author_profile_id": "81100490085", "affiliation": "INRIA, Paris-Rocquencourt, France", "person_id": "P4261239", "email_address": "francois.pottier@inria.fr", "orcid_id": ""}, {"name": "Jonathan Protzenko", "author_profile_id": "83058735757", "affiliation": "INRIA, Paris-Rocquencourt, France", "person_id": "P4261240", "email_address": "jonathan.protzenko@ens-lyon.org", "orcid_id": ""}], "doi_number": "10.1145/2500365.2500598", "year": "2013", "article_id": "2500598", "conference": "ICFP", "title": "Programming with permissions in Mezzo", "url": "http://dl.acm.org/citation.cfm?id=2500598"}