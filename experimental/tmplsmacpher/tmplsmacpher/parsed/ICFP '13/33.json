{"article_publication_date": "09-25-2013", "fulltext": "\n Experience Report: Functional Programming of mHealth Applications Christian L Petersen Matthias G \u00a8orges \nDustin Dunsmuir J Mark Ansermino Guy A Dumont University of British Columbia, Vancouver, BC, Canada \n{cpetersen mgorges ddunsmuir}@cw.bc.ca anserminos@yahoo.ca guyd@ece.ubc.ca Abstract A modular framework \nfor the development of medical applications that promotes deterministic, robust and correct code is presented. \nThe system is based on the portable Gambit Scheme program\u00adming language and provides a .exible cross-platform \nenvironment for developing graphical applications on mobile devices as well as medical instrumentation \ninterfaces running on embedded plat\u00adforms. Real world applications of this framework for mobile diag\u00adnostics, \ntelemonitoring and automated drug infusions are reported. The source code for the core framework is open \nsource and available at: https://github.com/part-cw/lambdanative. Categories and Subject Descriptors \nD.1.1 [Programming Tech\u00adniques]: Applicative (Functional) Programming; D.2.3 [General]: Coding Tools \nand Techniques; D.3.2 [Programming Languages]: Language Classi.cations -Applicative (Functional) Languages \nKeywords functional programming, Scheme, application pro\u00adgramming, medical systems, cross-platform development \n1. Introduction The Pediatric Anesthesia Research Team (PART) at the University of British Columbia is \na multidisciplinary research team conduct\u00ading clinical research to improve the safety and outcomes of \nchil\u00addren both in the hospital and at home. In recent years the team has increased its focus on technology \ninnovation, and is currently de\u00adveloping a range of new diagnostic and monitoring solutions for low cost \nmobile and embedded applications. As this technology is developed in-house with very limited resources, \na new software development framework promoting robust ef.cient code, exten\u00adsive testing and debugging \nfacilities, fast development and .exible cross-platform deployment was required. The team has four code \ndevelopers on staff; one programmer, two physicists and one engineer, with diverse coding backgrounds. \nThe typical application development process involves a much larger diverse group of clinicians, nurses, \ncommunity healthcare workers, engineers, graphic designers and research assistants. Traditionally, biomedical \nresearch teams write graphical soft\u00adware applications in Matlab, Visual Basic and LabView. These prototyping \nlanguages are not a good .t for robust performance\u00adoriented platform-independent coding. On the other \nhand, perfor- Permission to make digital or hard copies of all or part of this work for personal or classroom \nuse is granted without fee provided that copies are not made or distributed for pro.t or commercial advantage \nand that copies bear this notice and the full citation on the .rst page. Copyrights for components of \nthis work owned by others than the author(s) must be honored. Abstracting with credit is permitted. To \ncopy otherwise, or republish, to post on servers or to redistribute to lists, requires prior speci.c \npermission and/or a fee. Request permissions from Permissions@acm.org. ICFP 13 September 25 27 2013, \nBoston, MA, USA Copyright is held by the owner/author(s). Publication rights licensed to ACM. ACM 978-1-4503-2326-0/13/09. \n. . $15.00 http://dx.doi.org/10.1145/2500365.2500615 mance-critical applications are traditionally written \nin C, the ubiq\u00aduitous system language that is available on virtually all platforms. C is however a very \nlow level language and vulnerable to common null pointer dereferences. We .rst discovered Scheme as an \nextension language to C, and the ability to automatically generate C applications from Scheme was a natural \nnext step. Functional languages, such as Scheme, of\u00adfer an attractive alternative to conventional languages, \nespecially when combined with a C compilation backend. In this paper we describe a Scheme based software \ndevelopment solution using the Gambit-C Scheme to C compiler [1, 2]. Scheme is a mature lan\u00adguage originally \ndeveloped at MIT over the period 1975-1980, and is standardized on the of.cial IEEE standard 1178-1990 \n[3] and the Revised Reports on the Algorithmic Language Scheme [4]. It features an exceptionally simple \nhomoiconic syntax based on s\u00adexpressions. The primary goal in the design of the framework was to strike \na balance between productivity, correct programming and perfor\u00admance. The brevity and simplicity of Scheme \ncode promotes pro\u00adductivity and correctness, which is essential for mission critical medical applications. \nAt the same time, the C backend allows com\u00adpilation of high-performance binaries. Many diagnostic medical \ndevices require low-level access to relatively high bandwidth sen\u00adsors, and tight integration between \nScheme and C is essential to facilitate this in real time. The framework currently contains many distinct \napplications ranging from medical device servers running on embedded sys\u00adtems, over graphical interfaces \nrunning on medical .at panel PCs, to mobile applications for iPhone and Android. In this paper we examine \nthree examples of these applications and discuss their im\u00adplementation. 2. Concept The application model \nadopted herein relies on the fact that modern operating systems share many core features. For example, \niOS re\u00adquires applications to be developed in Objective C. However, much of the underlying core operating \nsystem (Darwin) is written in C, and can readily be addressed though the standard UNIX and POSIX application \nprogramming interfaces. The same holds true for the Android operating system, which requires applications \nto be de\u00adveloped in Java, while the underlying operating system (Linux) is C based. Another common denominator \nbetween most modern computing platforms is the presence of an accelerated OpenGL or OpenGL ES graphics \nengine [5]. This provides an ef.cient univer\u00adsal mechanism for graphical user interfaces to function \nregardless of the underlying operating system. It is thus possible to construct a cross-platform program \nthat, while meeting the minimum requirements of the host operating system, performs the bulk of its operations \nthrough a universal C  Figure 1. (A) Schematic of the portable application concept. (B) Application \nstructure. (C) Compilation .ow diagram. application interface. This is illustrated in Fig 1(A). The application \nconsists of a payload written in Scheme which is compiled to a native binary using the Gambit Scheme-to-C \ncompiler and the C (cross-)compiler available for the target platform. A small stub shared between all \napplications in the framework manages the operating system speci.c application requirements, launches \nthe program, and relays events to the payload. The advantage of this approach is that a single code base \ncan be deployed unchanged to a wide range of platforms, and run with a high level of performance suitable \nfor IO and computationally in\u00adtensive applications. Support for a new platform is simply a matter of \nwriting another stub to launch the application on the platform and tie into its operating system event \nsystem. The framework has successfully been used to build applications for iOS, Android, Mac OS X, Linux, \nWindows, OpenBSD, and NetBSD. The disadvantage of the approach is that a Native Development Kit with \na C cross-compiler is required to build the payload. While all modern operating systems have this compiler \navailable, some vendors may choose to withhold access to the compiler. In addition, user interface elements \nintegrated into to the host operating system are not readily available to the payload. To overcome the \ninterface limitations we have developed a widget based graphics engine entirely in Scheme, which provides \na .exible platform-independent front end to the host OpenGL or OpenGL ES Graphics Processing Unit (GPU). \n3. Structure The applications are structured in a modular fashion to maximize code reuse between applications. \nThis is illustrated in Fig 1 (B). Each application consists of a main routine that references modules \nin a common code repository shared by all applications in the framework. The four main modules shared \nby most applications are eventloop, glcore, glgui and store. The eventloop module is responsible for \nfeeding user and operating system events such as touch screen presses and redraw triggers to the payload \napplication. It also relays sensor information such as battery level and device orientation to the application. \nThe graphics engine consists of a minimal Scheme wrapper around the OpenGL and OpenGL ES functions in \nglcore and a Scheme based graphical user interface in glgui. glgui imple\u00adments a full widget system with \nbuttons, labels, boxes, scrollable lists, keypads, images, containers, modal dialogs etc. and is eas\u00adily \nexpandable with more widget types. Each widget type consists of a hash table holding widget properties, \na procedure for drawing the current representation of the widget and a procedure for han\u00addling input \nevents. Widgets are associated with gui hash tables, and multiple gui tables can be displayed on screen \nat the same time. This allows simple grouping of widgets to support different screen con.gurations. The \nsystem also supports rotation and scaling to accommodate different screen geometries, resolutions and \ndevice orientation events. store is a generic data store implemented as a hash table with support for \ndata timeouts and categories. Data stores are used throughout the applications as a convenient way to \norganize data. For example in the telemonitoring application described below, pa\u00adtient data is grouped \nin individual data stores based on the network address of the patient monitors from which the data originates. \nThe framework also includes support for a plugin structure built around the scheduler module. The scheduler \ndrives the sequential execution of plugins based on their type (four types are supported; input, algorithm, \ndecision support and output). Plugins are instan\u00adtiated against a data store, and multiple instances \nare allowed. For example, this allows multiple syringe pump drivers and infusion controllers to be instantiated \nfor different drugs. This functionality is used in the closed-loop anesthesia controller described later. \nThe stub (in Fig. 1 (A) and (C)) which ties the Scheme payload into the operating system is a small piece \nof code in the native lan\u00adguage of each platform, and is responsible for opening an OpenGL window and \nrelaying rendering and user events to the payload event loop. The rendering itself is accomplished through \ndirect calls to OpenGL in glcore. 4. Development and debugging The framework is designed to be independent \nof an Integrated De\u00advelopment Environment (IDE), allowing developers to choose their  Figure 2. (A) \nElements of the phone oximeter. (B) Screen shot showing a PIERS phone oximeter measurement in progress. \nmost productive environment. Developers are currently working with diverse software development environments \nranging from the Eclipse IDE to the Vi editor on both Mac OS X and Linux. The application framework incorporates \na simple .le based log\u00adging system that can be used for fault .nding. Exceptions triggered in the Scheme \npayload will result in a message about the fault writ\u00adten to the log. Applications built in debug mode \ninclude source code .le and line number information, allowing easy identi.cation of the problem code. \nFaults on the C side can similarly be tracked down by compiling in debug mode and using a platform speci.c \nstack analysis tool like ndk-stack for Android. A simple unit test system is used to test integrity of \nalgorithmic components such as the encryption and compression communica\u00adtion routines, and a lint-like \nstatic analyzer [6] is available to .nd structural problems within the code, such as shadowed declarations \nand use of reserved keywords. The built-in Scheme interpreter and equivalence of data and code provide \nunique ways to investigate and debug the state of the live running system. For example, a console application \ncan be used to test a new code module interactively, prior to deployment in the .nal applications. Pro.ling \nis accomplished by using Gambit-C s internal ability to capture thread continuations and provide information \nabout .le names and line numbers to build statistical information about bottle necks in the source code. \nAn automated smoke test script is used to periodically build and run all applications in the framework \nand verify that the binaries are runnable. This catches compatibility problems when making changes to \nthe common code base of the framework. For application veri.cation we have developed systematic test \nsuites. For example, an automated test including 100 simulated patients is used to verify the integrity \nof the the drug delivery controller described later. These tests run in real-time, using the built-in \ninterpreter to script the inputs to the applications. The everyday development and training within the \nprogram\u00adming team takes place in a .at structure, where code is reviewed and bugs resolved by drawing \non the individual knowledge of each developer about particular portions of the code. The somewhat sim\u00adplistic \ndebugging tools have not limited us so far. The most elusive bugs were unexpected number types at the \nforeign function inter\u00adface which caused type conversion problems in the C API calls. 5. Compilation \nThe compilation .ow diagram is shown in Fig 1 (C). The basic idea is to build a single static library \ncontaining all of the Scheme payload, and link this library to a small launcher stub in the native language \nof the target platform (Objective C on iOS and OS X, Java on Android etc). The payload is compiled using \nthe standard automake tool chain. First the Scheme source .les are converted to C using the Gambit-C \ngsc compiler. Next, resources such as images and fonts are processed into Scheme data with custom resource \ncompilation tools and likewise compiled to C with gsc. Finally, the resulting intermediate C source .les \nare compiled to object .les using the target platform (cross-)compiler against the SDK provided header \n.les. The resulting object .les are assembled into a single static payload library. Compilation of the \napplication binary is complicated by the platform vendors requirement for speci.c tools. For example, \niPhone applications must be built with XCode to satisfy the strin\u00adgent code signing requirements for \napp store submissions. For this reason a CMake script is used to automatically generate an XCode project \nand xcodebuild is used to link the payload to the appli\u00adcation stub and generate a valid application \nbinary. Similarly the unconventional linking done in the Android build chain requires automating the \nuse of the Android NDK ant based build system. The framework also automatically handles the manifests \nand icon graphics needed for the SDK driven builds on the different plat\u00adforms. 6. Applications The following \nsections describe three representative examples of the framework applications. Most of the applications \nare research tools used for human trials, and have been used to collect clinical data from more than \n10,000 subjects in Canada, France, India, Uganda, Bangladesh, and South Africa, in more than 10 separate \nclinical studies.  Figure 3. (A) Schematic of the VitalNode server accessing a patient monitor network \nthrough a passive tap. (B) telePORT application overview screen showing real time vital signs from a \nhospitals operating room theatres. Almost all our application code is functional style Scheme (R5RS) \nwithout macros. The code repository contains 317,829 lines of Scheme, including comments and auto-generated \ncode. There are 58 modules, 30 plugins and 77 applications. The only other languages used are C and shell \nscript for supporting tools. Current applications are deployed on embedded platforms, medical grade .at \npanel displays, netbooks, and smartphones run\u00adning iOS and Android. The applications have no noticeable \nperfor\u00admance problems with respect to garbage collection, memory leaks, footprint etc. Our telemonitoring \nserver described below has upti\u00admes of over a year running on embedded hardware, and our mobile applications \nrun on devices with only 128Mb RAM. Any device used for diagnostic purposes in humans requires regulatory \napproval. Health Canada and regional ethics boards have approved the use of our devices for clinical \nresearch. The use of Scheme did not directly impact the regulatory process, which is focused on documentation \nand hazard analysis/mitigation. 7. Use case: The Phone Oximeter A pulse oximeter is a noninvasive sensor \nthat measures the oxy\u00adgen concentration of blood. This is a critically important tool for continuous \nmonitoring of oxygen saturation (SpO2) in the operat\u00ading room (OR), and is also a good predictor of disease \nseverity and treatment response in a wide range of diseases such as pneumonia in children [7]. The Phone \nOximeter is an inexpensive and portable pulse oximeter that runs on a mobile phone [8], as shown in Fig \n2 (A). This device is targeted at users in low and middle income countries with little or no availability \nof conventional pulse oxime\u00adtry equipment. For research, we are designing mobile phone applications to \nrecord and store accurate spot-checks of a patients SpO2 using the Phone Oximeter. Fig 2 (B) shows the \nmeasurement screen of one of our newest such applications, Pre-Eclampsia Integrated Estimate of RiSk \n(PIERS), which is described later in this section. This screen displays a photoplethysmogram, as well \nas heart rate (HR) and SpO2 trends. PhoneOxR [9] and its sequel PhoneOxR2 are Phone Oxime\u00adter applications \nused to collect accurate SpO2 and HR values for patients admitted to studies on post discharge mortality, \nnewborn and early childhood sepsis, and respiratory distress in Uganda, Bangladesh, and India respectively. \nOur .rst goal with these applications was to ensure the accuracy of data used within the research studies. \nChanges in data quality re.ected in a Signal Quality Index (SQI) result in prominent colour changes on \nthe display. A horizontal progress bar shows the SQI colour over time, to promote the collection of good \ndata, as seen in Fig. 2 (B). The percent of the recording that was good quality, as well as the median \nHR and SpO2 trend values calculated from only green (high quality) sections of the recording are displayed \nat the end of the recording. For each study subject, these applications create patient records, which \ninclude the median HR and SpO2 as calculated above. A sur\u00advey component allows entry of patient details \nsuch as demograph\u00adics and medical history for each patient. The data is stored locally in an encrypted \ndatabase and whenever network access is avail\u00adable the data is sent to a secure Research Electronic Data \nCapture (REDCap) [10] server via the REDCap application programming interface. The PIERS application \nFig 2 (B) represents the next step in our Phone Oximeter applications as it provides an interface for \ncollecting not just SpO2 but also the details of signs, symptoms, medical history, and medications taken \nover multiple visits with a patient. This information is the input to a decision tree, which includes \nthe miniPIERS predictive model, to assess the risk of pre-eclampsia and provide a recommendation, such \nas urgent transport to the hospital. The miniPIERS model is similar to the fullPIERS model [11], but \nit excludes the use of laboratory tests so that it can be used in community and primary health care facilities \nwhere these test are not possible. This application is designed to be used by midwives in local clinics \nand a simpli.ed version of the application is being constructed to be used by community health care workers \nin their regular visits to pregnant women s homes. This application has undergone multiple iterations \nof usability testing and the simpli.ed Figure 4. (A) Schematic of the iControl system for automated drug \nadministration during general intravenous anesthesia. (B) The iControl interface running on platforms \nwith different screen sizes.  version will be used in a multi-site study in India, Nigeria, Pakistan \nand Mozambique in the near future. 8. Use case: The telePORT monitoring and messaging device Conventional \nphysiological monitors in multi-bed environments such as operating rooms (OR) and intensive care units \n(ICU) are connected to central monitoring stations. However, these central stations are immobile and \nhave limited proprietary interfaces. In order to make better use of collected patient data, we have devel\u00adoped \na data access node and accompanying wireless real-time dis\u00adplay of multi-bed patient data for mobile \nphones, which operates independently of the commercial patient monitor network. We use an intrinsically \nsafe method for extracting physiolog\u00adical trends and waveforms from patient monitoring networks by means \nof a passive network tap [12]. The tap is inserted into the central monitor network, Fig. 3 (A), and \nan exact copy of the net\u00adwork traf.c is analyzed in real time with no impact on the net\u00adwork itself. \nData collected from the tap is analyzed by a VitalNode server, developed in the application framework. \nThis server runs on a Soekris 5501 embedded computer, and uses the PCAP (Packet CAPture) [13] application \nprogramming interface interfaced to a Scheme based parser plugin. Our parser understands raw network \npackages from Philips IntelliVue MP70 and Datex-Ohmeda S/5 monitors and stores continuous waveforms and \nvital sign trends from the monitors. This data is then fed through a forward chaining inference engine \ndecision support plugin in the framework to gen\u00aderate trend based alerts. This approach allows wireless \nand wired access to encrypted physiological data, from all beds of the entire OR, ICU or ward to which \nthe system is connected, as well as se\u00adcure message exchange between users of the system. telePORTs purpose \nis to improve information exchange, and simplify communication between anesthesia team members [14]. \nThe telePORT interface is shown in Fig 3 (B). It runs on a mo\u00adbile phone and polls user-and system generated \nmessages, vital signs trends, and waveforms securely over the hospitals wi. net\u00adwork from the VitalNode \nserver. It then supports the users work though .ve components: A) an overview screen, which provides \nthe user with basic information about their subscribed monitoring locations, such as the anesthetic phase \nand three vital sign values. If additional detail is required access to waveforms and trends is provided. \nB) a messaging screen, which works as a combination of person-to-person chat system, and a system to \nreceive requests for help through a button pressed on the patient monitor in an OR, C) a phonebook screen, \nwhich lists frequently used phone exten\u00adsion and pager numbers; and provides editing capabilities on \nthe device, D) a room subscription screen, where room monitoring lo\u00adcations are subscribed to and where \nsubscriptions can be delegated to other users, and E) a reminder screen, which allow the user to set \nup time-and anesthetic phase-based reminders. telePORT has been used in our department continuously for \nthe last year with highly favourable reviews by its users. Based on this success, we are currently in \nthe progress of developing a mobile monitoring, in\u00adformation exchange, and team communication solution \nfor nurses, respiratory therapists and physicians in the ICU. 9. Use case: The iControl anesthesia controller \nToday, intravenous anesthesia is typically delivered by a manually adjusted continuous infusion; a syringe \npump is programmed to deliver a .xed volume per unit time, usually calculated on a weight basis with \ndosage based on a historical population average. Due to the high inter-patient variability, it is dif.cult \nto predict a manual infusion rate that will accurately produce the desired target brain concentration \nof the drug. Too little drug will mean that the patient will move or wake up, and too much drug will \nresult in prolonged recovery and an increase in side effects such as cardiovascular or respiratory depression. \nAn automated anesthetic drug delivery system that offers a con\u00adtinuously adjusted rate of intravenous \ndrug administration has ad\u00advantages over traditional static (weight based) infusion, including greater \nhemodynamic and respiratory stability, more stable depth of anesthesia, the ability to predict recovery, \nand a lower total dose of drug administered. iControl is such a closed-loop solution that delivers drugs \nbased on feedback from electroencephalography (EEG) derived measure\u00adments of depth of hypnosis, as shown \nschematically in Fig 4 (A). Closed-loop control technology is used extensively in many .elds such as \nthe aviation and nuclear industry, but has yet to make a sig\u00adni.cant impact in anesthesia (or medicine \nin general). One of the main reasons for this is the natural concern about safety of closed\u00adloop systems \nin medical applications.  The iControl system was designed and implemented using rig\u00adorous validation \nrequirements of high-risk medical instrumenta\u00adtion, including a detailed user and system requirements \nspeci.ca\u00adtion, hazard analysis, and system design speci.cation. The system underwent usability studies \nand extensive manual and automated system tests prior to being approved for clinical trials by Health \nCanada. iControl is implemented as a client-server system. The server resides on a Soekris 5501 embedded \ncomputer running Linux or OpenBSD. The server has several sub-processes that use the frame\u00adwork plugin \nstructure to feed data from syringe pumps and patient monitors to a patient speci.c data store. A controller \nplugin in\u00adstantiated on the patient store calculates the new infusion rates and instructs the pump plugins \nto update the devices. The server com\u00admunicates with a client interface through the same encrypted com\u00admunication \nscheme as used by the telePORT application. The iControl client interface is shown in Fig 4 (B). It features \na real time display of current infusion rates, estimated brain concen\u00adtrations of the delivered drugs, \nmeasured depth of hypnosis, and target depth of hypnosis. The system is controlled through a simple touch \nscreen based input system that is designed to provide a consistent and safe in\u00adterface. The user interface \nscreen layout automatically recon.gures based on the size of the display. The primary system console \nclient runs on a medical grade .at panel PC (Windows XP embedded), mounted on a mobile medical cart together \nwith pumps, EEG mon\u00aditor and the embedded controller. Remote monitoring is possible over wi. by running \nthe iControl interface application on a mobile phone or tablet. Multiple clients can run against the \nserver simulta\u00adneously. iControl has successfully been used to automate hypnotic drug (propofol) delivery \nin adults [15] and children [16, 17] , and is currently used in a study on adults controlling both hypnotic \nand analgesic drug (remifentanil) delivery concurrently. 10. Conclusions A modular framework for cross-platform \ndevelopment of robust medical applications has been developed and used for deployment of diverse applications \nranging from mission-critical embedded drug delivery systems to diagnostic and monitoring apps on iPhone \nand Android smart phones. The use of Scheme and the extensive reuse of code between applications have \nenabled ef.cient development cycles with mini\u00admal resource requirements and a very small code base. The \nability to deploy applications on a wide range of different platforms has proven to provide great .exibility \nand offers a way to easily port the system to new platforms if the need arises. The possibility of developing \non a platform other than the target platform also pro\u00advides greater productivity as it allows developers \nto work with the platform and development tools they prefer. The biggest challenge encountered has been \nthe learning curve associated with the Scheme language, and the lack of knowledge of functional programming \nin the engineering and the medical community from which we normally recruit. Unfamiliar syntax appears \nto be the biggest barrier. Use of a more familiar C or Java like in-.x notation, for example as provided \nby the Gambit-C internal six notation, may overcome this problem, and provide a robust cross-platform \ndevelopment system that can bene.t from the strength of functional programming while being disseminated \nto the programming community at large. A. Source code The source code for the core framework, including \nsimple demon\u00adstrator applications, is open source and available for download at: https://github.com/part-cw/lambdanative. \nReferences [1] Gambit Scheme programming language, http://gambitscheme.org [2] Feeley M, Miller JS, Guillermo \nJR, Wilson JA. Compiling higher-order languages into fully tail-recursive portable C. Technical Report \n1078, d \u00b4epartement d informatique et r.o., Universit \u00b4e de Montr\u00b4eal (1997) [3] IEEE Standard for the \nScheme Programming Language, IEEE 1178\u00ad1990, ISBN: 1559371250 [4] The Revised6 Report on the Algorithmic \nLanguage Scheme, http://www.r6rs.org [5] Kilgard MJ, Akeley K. Modern OpenGL: its design and evolution. \nSIGGRAPH Asia 08, p. 13 (2008) [6] Johnson S. Lint, a C program checker. Computer Science Technical Report \n65, Bell Laboratories, December 1977 [7] Neuman MI, Monuteaux MC, Scully KJ, Bachur RG. Prediction of \nPneumonia in a Pediatric Emergency Department. Pediatrics, 2011; 128:2 p. 246-53 [8] Karlen W, Hudson \nJ, Lim J, Petersen C, Anand R, Dumont GA, Ansermino JM. The Phone Oximeter. IEEE Engineering in Medicine \nand Biology Society Unconference, Boston, USA, August 30, 2011 [9] Dunsmuir D, Petersen C, Karlen W, \nLim J, Dumont GA, Ansermino JM. The Phone Oximeter for Mobile Spot-Check. Society for Technol\u00adogy in \nAnesthesia 2012 Annual Meeting, Palm Beach, FL, USA, January 18-21, 2012 [10] Harris PA, Taylor R, Thielke \nR, Payne J, Gonzalez N, Conde JG. Research electronic data capture (REDCap) -A metadata-driven methodology \nand work.ow process for providing translational research informatics support. J Biomed Inform. 2009, \n42(2), p. 377-81 [11] von Dadelszen P, Payne B, Li J, Ansermino JM, Broughton-Pipkin F, Cote AM, Douglas \nJM, Gruslin A, Hutcheon JA, Joseph KS, Kyle PM, Lee T, Loughna P, Menzies JM, Merialdi M, Millman AL, \nMoore MP, Moutquin JM, Ouellet AB, Smith GN, Walker JJ, Walley KR, Walters BN, Widmer M, Lee SK, Russell \nJA, Magee LA. Predicting adverse maternal outcomes in pre-eclampsia: the fullPIERS (Pre-eclampsia Integrated \nEstimate of RiSk) model -development and validation. Lancet, 2011, 377 (9761), p. 219-227 [12] G\u00a8 orges \nM, Petersen C, Ansermino JM, Capturing vital signs for research in a multi-bed monitoring environment. \nAnesth Analg, 2011, 113 (2S Suppl), p. 42 [13] McCanne S, Jacobson V. The BSD Packet Filter: A New Architecture \nfor User-level Packet Capture. Proc. of the USENIX Winter 1993 Conference p. 2 [14] G \u00a8orges M, Ansermino \nJM. Development of a Mobile Monitoring and Communications Solution for Anesthesia Team Members. Anesth \nAnalg, 2011, 112 (5S Suppl), p. S207 [15] Dumont G, Liu N, Petersen C, Chazot T, Fischler M. Closed-Loop \nAdministration of Propofol Guided by the NeuroSense: Clinical Evaluation Using Robust Proportional-Integral-Derivative \nDesign. American Society of Anesthesiologists (ASA) Annual Meeting 2011 [16] van Heusden K, Dumont GA, \nSoltesz K, Petersen C, West N, Ansermino JM. Clinical evaluation of closed-loop controlled propofol infusion \nin children. World Congress of Anesthesiologists, Buenos Aries, Argentina, March 25-30, 2012 [17] West \nN, Dumont GA, van Heusden K, Khosravi S, Petersen C, Ansermino JM. The administration of closed-loop \ncontrol of anesthesia for gastrointestinal endoscopic investigations in children. Society for Pediatric \nAnesthesia AAP Pediatric Anesthesiology Annual Meeting, Tampa, FL, USA, February 23-26, 2012  \n\t\t\t", "proc_id": "2500365", "abstract": "<p>A modular framework for the development of medical applications that promotes deterministic, robust and correct code is presented. The system is based on the portable Gambit Scheme programming language and provides a flexible cross-platform environment for developing graphical applications on mobile devices as well as medical instrumentation interfaces running on embedded platforms. Real world applications of this framework for mobile diagnostics, telemonitoring and automated drug infusions are reported. The source code for the core framework is open source and available at: https://github.com/part-cw/lambdanative.</p>", "authors": [{"name": "Christian L. Petersen", "author_profile_id": "83059112557", "affiliation": "University of British Columbia, Vancouver, BC, Canada", "person_id": "P4261278", "email_address": "cpetersen@cw.bc.ca", "orcid_id": ""}, {"name": "Matthias Gorges", "author_profile_id": "83058770457", "affiliation": "University of British Columbia, Vancouver, BC, Canada", "person_id": "P4261279", "email_address": "mgorges@cw.bc.ca", "orcid_id": ""}, {"name": "Dustin Dunsmuir", "author_profile_id": "81496686665", "affiliation": "University of British Columbia, Vancouver, BC, Canada", "person_id": "P4261280", "email_address": "ddunsmuir@cw.bc.ca", "orcid_id": ""}, {"name": "Mark Ansermino", "author_profile_id": "81351608779", "affiliation": "University of British Columbia, Vancouver, BC, Canada", "person_id": "P4261281", "email_address": "anserminos@yahoo.ca", "orcid_id": ""}, {"name": "Guy A. Dumont", "author_profile_id": "81339497710", "affiliation": "University of British Columbia, Vancouver, BC, Canada", "person_id": "P4261282", "email_address": "guyd@ece.ubc.ca", "orcid_id": ""}], "doi_number": "10.1145/2500365.2500615", "year": "2013", "article_id": "2500615", "conference": "ICFP", "title": "Experience report: functional programming of mHealth applications", "url": "http://dl.acm.org/citation.cfm?id=2500615"}