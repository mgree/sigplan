{"article_publication_date": "09-25-2013", "fulltext": "\n Simple and Compositional Rei.cation of Monadic Embedded Languages Functional Pearl Josef Svenningsson \nBo Joel Svensson Chalmers University of Technology {josefs,joels}@chalmers.se Abstract When writing embedded \ndomain speci.c languages in Haskell, it is often convenient to be able to make an instance of the Monad \nclass to take advantage of the do-notation and the extensive monad li\u00adbraries. Commonly it is desirable \nto compile such languages rather than just interpret them. This introduces the problem of monad rei.\u00adcation, \ni.e. observing the structure of the monadic computation. We present a solution to the monad rei.cation \nproblem and illustrate it with a small robot control language. Monad rei.cation is not new but the novelty \nof our approach is in its directness, simplicity and compositionality. Categories and Subject Descriptors \nD.3.2 [Programming Lan\u00adguages]: Language Classi.cations Applicative (functional) lan\u00adguages; D.3.4 [Programming \nLanguages]: Processors Code gen\u00aderation Keywords Compiling, embedded language, rei.cation, monads 1. \nIntroduction Benny is a computer science student working in a project involv\u00ading programming robots in \na low-level imperative language. How\u00adever, Benny has a budding interest in functional programming us\u00ading \nHaskell and has read The Haskell school of expression [6]. He gets the idea to implement a language for \nrobot control em\u00adbedded in Haskell. Benny realises that the capabilities of the robot hardware are very \nsimilar to those of the robots that Hudak evalu\u00adates graphically in a grid world. There is however a \nvery important difference; the embedded language needs to be compiled into some form that is understood \nby the robot. Guided by the capabilities of the target robot, Benny designs an API for robot programming. \nThe robot can perform operations such as move that steps the robot forward and turn left and right. The \nrobot also has the capability to execute program loops and conditionals and it has a forward facing sensor \nwith which it can query the world. Permission to make digital or hard copies of all or part of this work \nfor personal or classroom use is granted without fee provided that copies are not made or distributed \nfor pro.t or commercial advantage and that copies bear this notice and the full citation on the .rst \npage. Copyrights for components of this work owned by others than the author(s) must be honored. Abstracting \nwith credit is permitted. To copy otherwise, or republish, to post on servers or to redistribute to lists, \nrequires prior speci.c permission and/or a fee. Request permissions from permissions@acm.org. ICFP 13, \nSeptember 25 27,2013, Boston, MA, USA. Copyright &#38;#169; 2013 ACM 978-1-4503-2326-0/13/09 $15.00. \n http://dx.doi.org/10.1145/2500365.2500611 The API that Benny designs is simple: move :: Program () turnLeft \n:: Program () turnRight :: Program () sensor :: Program Bool cond :: Program Bool -> Program () -> Program \n() -> Program () while :: Program Bool -> Program () -> Program () Now, Benny wants to express robot \nprograms using the Haskell do notation. The motivation behind this is the imperative look and feel of \nthe operations he identi.ed and the potential to use all the control structures in the Control.Monad \nlibrary. For this, a Monad instance is needed. To be able to create a .rst-order representation of a \ncomputation described using monads, Benny needs to solve the problem of reifying monads. This is the \nstory of how Benny came up with a particularly simple solution to this problem. 1.1 Example programs \nBenny is quite happy with his language design and decides to write some programs to try it out. The .rst \nprogram is called sMove, which implements a safe move operation. This operation can be executed by the \nrobot even though it is facing an obstacle, without risk of harming robot or obstacle. sMove :: Program \n() sMove = cond sensor turnRight move The second program moves the robot forward until it stands directly \nin front of an obstacle such as a wall. moveToWall :: Program () moveToWall = while ((liftM not) sensor) \nmove Based on these examples, Benny is quite satis.ed with the design of his language and turns to implementing \nit.  1.2 Implementation and data structures Enthused by the prospect of compiling these programs to \nthe target language and seeing some robot action, Benny goes to work on the data structures. Since the \nlanguage is going to be compiled, Benny realises that the booleans in his language cannot be regular \nHaskell booleans. The booleans needs to be replaced by boolean typed expressions.  type Name = String \ndata BoolE = Lit Bool | Var Name | (:||:) BoolE BoolE | (:&#38;&#38;:) BoolE BoolE | Not BoolE Following \nthis, the operations that should go into the Program data type feel straightforward. data Program a where \nMove :: Program () TurnLeft :: Program () TurnRight :: Program () Sensor :: Program BoolE Cond :: Program \nBoolE -> Program () -> Program () While :: Program BoolE -> Program () -> Program ()  Benny continues \nby naively adding constructors for Return and Bind to the Program data type. data Program a where ... \nReturn :: a -> Program a Bind :: Program a -> (a -> Program b) -> Program b Then he writes down the \nMonad instance. instance Monad Program where return = Return (>>=) = Bind Proud of his accomplishments, \nBenny sends his Haskell mod\u00adule in an email to Prof. Bj\u00f6rn. Benny knows that Bj\u00f6rn is teaching an introductory \nHaskell course and should be able to provide feed\u00adback. 1.3 Problem statement Meanwhile in Professor \nBj\u00f6rn s Of.ce Prof. Bj\u00f6rn notices an email from Benny in his inbox and opens it. Dear Professor Bj\u00f6rn \nI am CS student working in a robot control project. Usually, we program our robots in C but I have developed \nan interest in Haskell programming and thought it d be natural to try implementing an EDSL. I know you \nteach an FP course and thought I would ask for your input. Attached to this mail is a .le containing \nan outline of the data types I want to use. Does this look sensible to you? Thank you Benny  Prof. \nBj\u00f6rn opens the attachment and takes a look at the data type. He particularly notices the constructors \nReturn and Bind and the Monad instance. He shakes his head at Benny s naivet\u00e9 and writes an email back: \nHello Benny I m afraid your implementation of the monadic primi\u00adtives can never work. The constructor \nReturn can take any arbitrary value that has nothing to do with the language you re designing. These \nvalues may be strings, binary trees or higher-order functions from zygomorphisms to histomorphisms. The \nsame problem goes for Bind; it has to be able to handle arbitrary values. It cannot possibly work! This \nis a very dif.cult problem and such a naive solution is bound to fail. Prof. Bj\u00f6rn Dept. of Computer \nScience and Engineering Chalmers University of Technology While waiting for feedback from Bj\u00f6rn, Benny \nhas carried on trying to implement a compiler for his language. When Bj\u00f6rn s email does arrive, Benny \nis confused. He feels he has already managed to compile the Program data type into a rep\u00adresentation \ncloser to that which is executed by the robot hardware. He writes an apprehensive email back to Prof. \nBj\u00f6rn. Hello Prof. Bj\u00f6rn Thanks for your feedback. But I think it does work! Attached to this email you \n.nd a .le containing my attempt at compiling the Program data type into a representation closer to that \nwhich is executed by our robots. I have also attached two example programs that you can compile and \nthen run in the graphical simulator (see .g\u00adure 1) Benny 2. Compilation of the monadic robot EDSL Bj\u00f6rn \nreceives Benny s latest email Bj\u00f6rn looks through the Compiler module and .nds a data type describing \na .rst-order representation of the robot language. data Prg = PMove | PTurnRight | PTurnLeft | PSensor \nName | PCond BoolE Prg Prg | PWhile Name Prg Prg | PSeq Prg Prg | PSkip | PAssign Name BoolE From the \nPrg data type, Bj\u00f6rn presumes that the PSeq construc\u00adtor will be the result of compiling Bind and that \nPSensor binds a variable which can be used in PAssign and PWhile. The conclu\u00adsion is that the representation \nlooks sensible, but he is very inter\u00adested in seeing the Program a -> Prg transformation. The com\u00adpile \nfunction assumes a splittable name supply with the interface described in .gure 2.  spiralIn :: Int \n-> Program () spiralIn 0 = return () spiralIn n = do replicateM_ 2 $ do replicateM_ n move turnLeft \nspiralIn (n-1)  followWall :: Program () followWall = while (return true) $ cond checkLeft sMove $ do \nturnLeft move checkLeft :: Program BoolE checkLeft = do TurnLeft s <-Sensor TurnRight return s  Figure \n1. The spiralIn and followWall programs sent from Benny to Bj\u00f6rn in an email newNameSupply :: NameSupply \nsplit2 :: NameSupply -> (NameSupply,NameSupply) split3 :: NameSupply -> (NameSupply,NameSupply,NameSupply) \nsupplyValue :: NameSupply -> Int Figure 2. The interface of the splittable name supply used in the implementation \nof the compile functions runCompile :: Program a -> Prg runCompile prg = snd $ compile s prg where s \n= newNameSupply compile :: NameSupply -> Program a -> (a, Prg) compile s Move = ((),PMove) compile s \nTurnRight = ((),PTurnRight) compile s TurnLeft = ((),PTurnLeft) compile s Sensor = (Var nom,PSensor nom) \n where v = supplyValue s nom = \"v\" ++ show v  compile s (Cond b p1 p2) = ((),bp PSeq PCond b p1 p2 ) \n where (s1,s2,s3) = split3 s (b ,bp) = compile s1 b (a1,p1 ) = compile s2 p1 (a2,p2 ) = compile s3 p2 \n compile s (While wp prg) = ((),PWhile nom nwp prg ) where (s1,s2,s3) = split3 s (b,wp ) = compile s1 \nwp (c,prg ) = compile s2 prg nom = \"v\" ++ (show $ supplyValue s3) nwp = (wp PSeq PAssign nom b)  compile \ns (Return a) = (a,PSkip) compile s (Bind pa f) = (b, prg1 PSeq prg2) where (s1,s2) = split2 s (a,prg1) \n= compile s1 pa (b,prg2) = compile s2 (f a)  Bj\u00f6rn studies the code in disbelief, saves the module and \ntries it out on some examples. The code does indeed seem to work and Bj\u00f6rn s disbelief is replaced with \nenthusiasm; this appears to be a simple and convenient way to reify monads. Bj\u00f6rn sends an email to Benny, \ninviting him to a meeting. 3. Meeting in Bj\u00f6rn s of.ce BJ \u00d6 R N : Hello, come in. BE N N Y : Thanks. \nBJ \u00d6R N : So, about this robot language! You gave me a bit of a surprise there. I was entirely sure that \nwhat you did was impossible. BE N NY: Oh, But I just did the .rst thing that came to mind. There was \nno deep thought behind it. BJ \u00d6R N : The problem is [Bj\u00f6rn approaches his whiteboard] when you try to \nreify the bind constructor of your representation. Bind :: Program a -> (a -> Program b) -> Program b \n BJ \u00d6R N : You need to come up with an element of type a to pass to the function. BE N NY: I didn t realise \nit was problem. BJ \u00d6R N : But it is! Your solution is that you are careful about the return types of \nall operations in your language. They are either of unit type or some type which can be guaranteed to \nbe rei.ed. [Bj\u00f6rn scribbles on his whiteboard] Move :: Program () Sensor :: Program BoolE BJ \u00d6R N : \nThis is different from how such constructs are normally implemented. If I had implemented the language \nI would have given Sensor the type Program Bool so that I could write an evaluator of type Program a \n-> a, or perhaps Program a -> M a. But then adding a monad to the lan\u00adguage and reifying it becomes much \nharder. BE N NY: Yes, now that you mention it, I have seen that style used for de.ning DSLs. BJ \u00d6R N \n: Having constructors like Sensor return BoolE instead of Bool is a crucial part of why your method works. \nIt allows the compile function to be written in such a way that it can generate the return values statically \nand pass them as arguments to Bind. In a sense you re doing evaluation at the same time as compilation. \nThere s just enough evaluation to remove the monadic constructs. It s a very neat trick! BE N NY: Thank \nyou. BJ \u00d6R N : Another way to think about your trick is that you are using a writer monad to evaluate \nyour language and produce the .rst-order syntax tree as a side effect. Then you could have used a state \nmonad transformer on top of that for the fresh name supply. But that s a stylistic choice. BE N NY: You \nseem to be making a big deal out of this. I just did what I thought was the most straightforward thing \nto do. 3.1 Related work BJ \u00d6R N : Others have solved this problem before but I have never seen a solution \nas simple as yours and was quite surprised that it works. For example, in this paper [Bj\u00f6rn shows Benny \nthe paper [7]], the authors use a continuation monad to be able to reify the monadic constructs of their \nlanguage. If they were to implement your robot language they would use the same Program data type as \nyou do. However, they would not expose that to the user of the language. Instead they would create a \ntype like this: data P a = P (forall r. ((a -> Program r) -> Program r)) BJ \u00d6 R N : The type P is a \ncontinuation monad so the monad in\u00adstance comes naturally. Operations on P are de.ned using Bind like \nthis: while :: P BoolE -> P () -> P () while c b = P (\\k -> While (runP c) (runP b) Bind k) cond :: \nBoolE -> P () -> P () -> P () cond b t e = P (\\k -> Cond b (runP t) (runP e) Bind k) runP :: P a -> \nProgram a runP (P f) = f (\\a -> Return a) BE N N Y : I see. Continuations are quite magical to me. I \ncould never have come up with that technique. How do they deal with transforming higher-order programs \nto .rst-order pro\u00adgrams? BJ \u00d6 R N : That s a good question. The transformation to .rst or\u00adder programs \nis dealt with by a library called Syntactic. It is described in a separate paper [Bj\u00f6rn pulls out the \npaper [2] from a pile of papers]. It s hard to do an apples to apples compari\u00adson between Syntactic and \nyour technique. Syntactic solves a much bigger problem than what you re doing so it is nat\u00adurally more \ncomplicated. BE N N Y : Ok. BJ \u00d6 R N : There are also the papers [5, 8] which solves the prob\u00adlem in \na manner that is more similar to yours. They also have explicit constructors Bind and Return but give \nthem a slightly different type which guarantees that all applica\u00adtions of Bind are normalised, so that \nall Binds are right\u00adassociated. Unexpectedly, this allows them to make in\u00adstances of the Monad class \nbut at the same time constrain the arguments of Bind. Their technique is more compli\u00adcated than yours, \nbut just as with the case of Syntactic, they solve a more general problem. However, there is one particular \nthing I like about your technique. BE N N Y : What is that? BJ \u00d6 R N : Your technique is compositional. \n 3.2 Compositionality BE N N Y : What does it mean that my technique is compositional? BJ \u00d6 R N : The \ncompile function is compositional because there is one case for each constructor and each case deals \nwith ex\u00adactly one constructor. In particular, the constructors Return and Bind are handled completely \nseparately from all other language constructs. BE N N Y : And that is good ? BJ \u00d6 R N : Absolutely! Compositional \nde.nitions are nice because they imply that there is no weird semantical interaction between the constructs \nas they are de.ned independently. But it also means that it should be possible to factor out the constructors \nReturn and Bind into a data type of their own. Then, it could be combined with other data types using \ntechniques like Data Types \u00e1 la Carte [9] or CompData [3]. This way, a language can be designed piece \nby piece.You can then select the set of pieces required for a particular task or that suits a particular \nbrand of robots. BE N NY: Oh! Interesting. 3.3 The Monad laws BJ \u00d6R N : There is still one problem \nwith your method though. BE N NY: What s that? BJ \u00d6R N : When we make instances of the monad class we \nexpect certain laws to hold. [Bj\u00f6rn writes the laws on his whiteboard] m >>= return = m return a >>= \nf = f a (m >>= f) >>= g = m >>= \\a -> f a >>= g  BJ \u00d6R N : These laws clearly don t hold for your instance. \nTake the .rst law for instance. The left hand side will have extra Bind and Return constructors compared \nto the right hand side. BE N NY: Hmmm. I hadn t really thought about that. But adding an extra return \nat the end of a computation shouldn t make a difference in my implementation. BJ \u00d6R N : So, you re saying \nthat your implementation actually obeys the .rst monad law? BE N NY: Well, at least when I run my programs \nI will never see any difference between the left hand side and the right hand side. BJ \u00d6R N : Aha, so \nwhat you re saying is that if we compare the semantics of programs rather than comparing the programs \nthemselves then we get some useful laws. [Bj\u00f6rn scribbles some new laws on the whiteboard] eval (m >>= \nreturn) = eval m eval (return a >>= f) = eval (f a) eval ((m >>= f) >>= g) = eval (m >>= \\a -> f a >>= \ng)  BJ \u00d6R N : These laws are morally the same as the monad laws, especially if we don t let the user \nof the robot language ever compare terms in the language. BE N NY: Yes, that captures my intuition very \nwell. BJ \u00d6R N : Ok, good. Can you prove these equations? BE N NY: No, I don t have any experience proving \nprograms cor\u00ad rect. BJ \u00d6R N : Well, it shouldn t be that dif.cult. Let me see what I can come up with. \n[Bj\u00f6rn scribbles frenetically on a piece of paper for a couple of min\u00adutes.] Aha! Your technique is quite \ngeneral. It can reify mon\u00adads into any kind of structure which is a monoid. Return translates into the \nmonoid unit and bind translates into the monoid operation. For example, in your compilation function \nit is important that the semantics of PSkip is the identity of the semantics of PSeq and that PSeq is \nassociative. BE N NY: Ok, that sounds good. I take that as meaning the method is quite general? BJ \u00d6R \nN : Yes, requiring a monoid is a very mild restriction. Look at the time! This was interesting, I got \nquite carried away. We must round off but please get back to me if you make any more progress on your \nrobot language. BE N NY: Thanks very much for your time. Bye! BJ \u00d6R N : Thank you. 4. Composing rei.able \nmonadic languages At Benny s computer Benny was really intrigued by the idea of compositionally build\u00ading \nembedded languages and after having read the papers Bj\u00f6rn showed him he decides to try his own approach \nto the problem.  data (e1 :+: e2) x a = InjL (e1 x a) | InjR (e2 x a) infixr :+: class sub :<: sup where \ninj :: sub x a -> sup x a instance f :<: f where inj = id instance (f :<: (f :+: g)) where inj = InjL \ninstance (f :<: h) => (f :<: (g :+: h)) where inj = InjR . inj Figure 3. Data types from CompData for \ncomposing languages. Inspired by CompData he starts out by adding the code in .gure 3 to his .le. The \ndata type :+: is used for composing languages, and the :<: typeclass provides coercions so that the programmer \ndoesn t have to worry about using the right sequence of the InjL and InjR constructors to inject terms \ninto the composed language. Benny then starts to add data types for the different language constructs \nin his robotic language. The different operations for the robot are pleasingly easy to add. data MoveOp \nx a where Move :: MoveOp x () data TurnOp x a where TurnLeft :: TurnOp x () TurnRight :: TurnOp x () \ndata SensorOp x a where Sensor :: SensorOp x BoolE data CondOp x a where Cond :: x BoolE -> x () -> x \n() -> CondOp x () data WhileOp x a where While :: x BoolE -> x () -> WhileOp x () In order to test out \nthese de.nitions, Benny next turns to im\u00adplementing a compiler. He realises that the compiler now needs \nto be implemented as a class with one instance per compilable sub\u00adlanguage. runCompile :: Compile f => \nf a -> Prg runCompile prg = snd $ compile s prg where s = newNameSupply class Compile f where compile \n:: NameSupply -> f a -> (a, Prg) instance Compile (MoveOp x) where compile _ Move = ((), PMove) instance \nCompile (TurnOp x) where compile _ TurnLeft = ((), PTurnLeft) compile _ TurnRight = ((), PTurnRight) \ninstance Compile (SensorOp x) where compile s Sensor = (Var nom, PSensor nom) where v = supplyValue s \nnom = \"v\" ++ show v instance Compile x => Compile (CondOp x) where compile s (Cond b p1 p2) = ((),bp \nPSeq PCond b p1 p2 ) where (s1,s2,s3) = split3 s (b ,bp) = compile s1 b (a1,p1 ) = compile s2 p1 (a2,p2 \n) = compile s3 p2 instance Compile x => Compile (WhileOp x) where compile s (While wp p) = ((),PWhile \nnom nwp p ) where (s1,s2,s3) = split3 s (b,wp ) = compile s1 wp (c,p ) = compile s2 p nom = \"v\" ++ (show \n$ supplyValue s3) nwp = wp PSeq PAssign nom b instance (Compile (e1 f), Compile (e2 f)) => Compile ((e1 \n:+: e2) f) where compile s (InjL a) = compile s a compile s (InjR a) = compile s a But when Benny tries \nto add the monadic operations he .nds that they are quite resistant to a compositional treatment. After \nmuch struggle he comes up with the following data type de.nition: data Mops f x a where Oper :: f x a \n-> Mops f x a Return :: a -> Mops f x a Bind :: x a -> (a -> x b) -> Mops f x b The recursion is provided \nby another data type that Benny calls MonadExp. data MonadExp f a = In (Mops f (MonadExp f) a) Benny \nthinks of the MonadExp data type as a representation of a monadic language parameterised over operations \nOper that are constructed using the constructors of some type f. The monad in\u00adstance for this data type \nis only slightly more complicated com\u00adpared to the earlier, non-compositional setting. instance Monad \n(MonadExp f) where return = In . Return (>>=) a f = In (Bind a f) Benny can now write the type of his \nrobotic language, built from independent pieces. It is noteworthy that the monadic expressions have to \nbe added on top of all the other language constructs. type Robot = MonadExp (MoveOp :+: TurnOp :+: CondOp \n:+: WhileOp :+: SensorOp) Given the de.nition of his language Benny can now write an injection function \nwhich helps writing smart constructors for all the different robot operations. inject :: (sub :<: f) \n=> sub (MonadExp f) a -> MonadExp f a inject a = In $ Oper $ inj $ a move :: (MoveOp :<: f) => MonadExp \nf () move = inject Move turnL :: (TurnOp :<: f) => MonadExp f () turnL = inject TurnLeft turnR :: (TurnOp \n:<: f) => MonadExp f () turnR = inject TurnRight sensor :: (SensorOp :<: f) => MonadExp f BoolE sensor \n= inject Sensor  cond :: (CondOp :<: f) => MonadExp f BoolE -> MonadExp f () -> MonadExp f () -> MonadExp \nf () cond b p1 p2 = inject $ Cond b p1 p2 while :: (WhileOp :<: f) => MonadExp f BoolE -> MonadExp f \n() -> MonadExp f () while pb p = inject $ While pb p Things are starting to fall into place. The only \nremaining bit is to complete the compiler for monadic expressions. instance (Compile x, Compile (f x)) \n=> Compile (Mops f x) where compile s (Oper o) = compile s o compile s (Return a) = (a,PSkip) compile \ns (Bind m f) = (b,prg1 PSeq prg2) where (s1,s2) = split2 s (a,prg1) = compile s1 m (b,prg2) = compile \ns2 (f a)  instance (Compile (f (MonadExp f))) => Compile (MonadExp f) where compile s (In a) = compile \ns a Now, Benny has all the functions he needs to compile a simple example program. test1 :: Robot () \ntest1 = do move turnL move turnL Compiling the program above gives the expected result. PSeq PMove (PSeq \nPTurnLeft (PSeq PMove PTurnLeft)) Benny decides to contact Bj\u00f6rn again to show him what he has done. \nDear Prof. Bj\u00f6rn I have attached a .le which demonstrates that the monadic constructs can be factored \nout and compiled separately, just as you suggested. Thanks Benny Benny, Fascinating! You ve managed \nto factor out the monadic operations so that they can be compiled once and for all. Users of your library \ndon t have to be concerned at all with the semantics of bind and return. Very nice! I note that the \ndata type for monadic operations cannot be composed as freely as the other operations, but instead has \nto be applied separately as a .nal step. Your solution is very similar to how variable binding is handled \nin the Syntactic library [1]. Prof. Bj\u00f6rn Dept. of Computer Science and Engineering Chalmers University \nof Technology 5. Epilogue This paper shows a simple method of implementing monadic ED-SLs. It shows \na na\u00efve approach to the monad rei.cation problem which has the additional bene.t of being compositional. \nIn section 4, the language is reimplemented in an extensible way and the com\u00adpile function is shown explicitly \nto be compositional by treating sub parts of the language separately. The example language used throughout \nthe story is small and quite limited. But the technique presented in this paper does scale up to larger \nlanguages and more complicated language constructs. It is currently used in the implementation of Obsidian, \nan EDSL for general purpose GPU programming [4]. Obsidian has language constructs which are considerably \nmore advanced than the robot language is this paper. One example is the sequential for-loop which is \nhigher-order (the type parameter t is not relevant to the current discussion): SeqFor :: EWord32 -> (EWord32 \n-> Program t ()) -> Program t () There does, however, seem to be restrictions on what kind of lan\u00adguage \nconstructs the rei.cation technique presented in this paper can deal with. For instance, the functions \nfrom the MonadPlus class has resisted our attempts at adding them to an EDSL in the same way as we ve \nadded Return and Bind. The exact limits of the ex\u00adpressiveness of our method is currently unknown to \nus. Acknowledgments We would like to thank Emil Axelsson for very valuable help during the implementation \nof the methods used in this pearl. We thank Mary Sheeran for suggesting the names Bj\u00f6rn &#38; Benny. \nThe ICFP reviewers provided many helpful suggestion which has improved the paper. This research has been \nfunded by the Swedish Foundation for Strategic Research (which funds the Resource Aware Functional Programming \n(RAW FP) Project) and by the Swedish Research Council. References [1] E. Axelsson. Syntactic. http://hackage.haskell.org/package/syntactic. \n[2] E. Axelsson. A generic abstract syntax model for embedded languages. In Proceedings of the 17th ACM \nSIGPLAN international conference on Functional programming, pages 323 334. ACM, 2012. [3] P. Bahr and \nT. Hvitved. Parametric compositional data types. In MSFP, pages 3 24, 2012. [4] K. Claessen, M. Sheeran, \nand B. J. Svensson. Expressive Array Con\u00adstructs in an Embedded GPU Kernel Programming Language. In Pro\u00adceedings \nof the 7th workshop on Declarative aspects and applications of multicore programming, DAMP 12, pages \n21 30, New York, NY, USA, 2012. ACM. ISBN 978-1-4503-1117-5. [5] A. Farmer and A. Gill. Haskell DSLs \nfor interactive web ser\u00advices. In 1st International Workshop on Cross-model Language De\u00adsign and Implementation, \nSep 2012. (published on workshop website, http://workshops.inf.ed.ac.uk/xldi2012/). [6] P. Hudak. The \nHaskell School of Expression: Learning Functional Programming through Multimedia. Cambridge University \nPress, New York, NY, USA, 1999. ISBN 0521643384. [7] A. Persson, E. Axelsson, and J. Svenningsson. Generic \nmonadic con\u00adstructs for embedded languages. In Proceedings of the 23rd interna\u00adtional conference on Implementation \nand Application of Functional Languages, IFL 11, pages 85 99, Berlin, Heidelberg, 2012. Springer-Verlag. \n[8] N. Sculthorpe, J. Bracker, G. Giorgidze, and A. Gill. The constrained\u00admonad problem. In Proceedings \nof the 18th ACM SIGPLAN interna\u00adtional conference on Functional programming. ACM, 2013. [9] W. Swierstra. \nData types \u00e0 la carte. Journal of Functional Program\u00adming, 18(4):423, 2008.   \n\t\t\t", "proc_id": "2500365", "abstract": "<p>When writing embedded domain specific languages in Haskell, it is often convenient to be able to make an instance of the Monad class to take advantage of the do-notation and the extensive monad libraries. Commonly it is desirable to compile such languages rather than just interpret them. This introduces the problem of monad reification, i.e. observing the structure of the monadic computation. We present a solution to the monad reification problem and illustrate it with a small robot control language. Monad reification is not new but the novelty of our approach is in its directness, simplicity and compositionality.</p>", "authors": [{"name": "Josef David Svenningsson", "author_profile_id": "81100424031", "affiliation": "Chalmers University of Technology, Gothenburg, Sweden", "person_id": "P4261261", "email_address": "josefs@chalmers.se", "orcid_id": ""}, {"name": "Bo Joel Svensson", "author_profile_id": "81496660788", "affiliation": "Chalmers University of Technology, Gothenburg, Sweden", "person_id": "P4261262", "email_address": "joels@chalmers.se", "orcid_id": ""}], "doi_number": "10.1145/2500365.2500611", "year": "2013", "article_id": "2500611", "conference": "ICFP", "title": "Simple and compositional reification of monadic embedded languages", "url": "http://dl.acm.org/citation.cfm?id=2500611"}