{"article_publication_date": "09-25-2013", "fulltext": "\n Modular Monadic Meta-Theory Benjamin Delaware Steven Keuchel Tom Schrijvers Bruno C. d. S. Oliveira \nUniversity of Texas at Austin Ghent University The University of Hong Kong bendy@cs.utexas.edu {steven.keuchel,tom.schrijvers}@ugent.be \nbruno@cs.hku.hk Abstract This paper presents 3MT, a framework for modular mechanized meta-theory of \nlanguages with effects. Using 3MT, individual lan\u00adguage features and their corresponding de.nitions \nsemantic func\u00adtions, theorem statements and proofs can be built separately and then reused to create \ndifferent languages with fully mechanized meta-theory. 3MT combines modular datatypes and monads to de.ne \ndenotational semantics with effects on a per-feature basis, without .xing the particular set of effects \nor language constructs. One well-established problem with type soundness proofs for denotational semantics \nis that they are notoriously brittle with re\u00adspect to the addition of new effects. The statement of type \nsound\u00adness for a language depends intimately on the effects it uses, mak\u00ading it particularly challenging \nto achieve modularity. 3MT solves this long-standing problem by splitting these theorems into two separate \nand reusable parts: a feature theorem that captures the well-typing of denotations produced by the semantic \nfunction of an individual feature with respect to only the effects used, and an effect theorem that adapts \nwell-typings of denotations to a .xed superset of effects. The proof of type soundness for a particular \nlanguage simply combines these theorems for its features and the combina\u00adtion of their effects. To establish \nboth theorems, 3MT uses two key reasoning techniques: modular induction and algebraic laws about effects. \nSeveral effectful language features, including references and errors, illustrate the capabilities of \n3MT. A case study reuses these features to build fully mechanized de.nitions and proofs for 28 languages, \nincluding several versions of mini-ML with effects. Categories and Subject Descriptors D.3.1 [Programming \nLan\u00adguages]: Formal De.nitions and Theory Semantics General Terms Languages Keywords mechanized meta-theory; \nmodularity; monads; side\u00adeffects 1. Introduction Theorem provers are actively used to mechanically verify \nlarge\u00adscale formalizations of critical components, including program\u00adming language meta-theory [1], compilers \n[25], large mathematical proofs [15] and operating system kernels [23]. Due to their scale Permission \nto make digital or hard copies of all or part of this work for personal or classroom use is granted without \nfee provided that copies are not made or distributed for pro.t or commercial advantage and that copies \nbear this notice and the full citation on the .rst page. Copyrights for components of this work owned \nby others than ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or republish, \nto post on servers or to redistribute to lists, requires prior speci.c permission and/or a fee. Request \npermissions from permissions@acm.org. ICFP 13, September 25 27, 2013, Boston, MA, USA. Copyright c &#38;#169; \n2013 ACM 978-1-4503-2326-0/13/09. . . $15.00. and complexity, these developments can be quite time consuming, \noften demanding multiple man-years of effort. It is reasonable to expect that variations can simply extend \nand reuse the original development in order to leverage the large in\u00advestment of resources in these formalizations. \nThis is unfortunately often not the case, as even small extensions can require signi.cant additional \neffort. Adding a new language feature to a programming language formalization or compiler, for example, \ninvolves signi.\u00adcant redesigns that have a cross-cutting impact on nearly all de.\u00adnitions and proofs \nin the formalization. This leads to a copy-paste\u00adpatch approach to reuse with several modi.ed copies \nof the original development, making it dif.cult to compose new features and ulti\u00admately leading to a \nmaintenance nightmare. Dissatis.ed with this situation, several researchers [1, 15, 43, 44] have called \nfor better ways to modularize mechanical formalizations. This work extends the current state-of-the-art \nin modular mech\u00adanizations by solving a well-known and long-standing open prob\u00adlem with denotational \nsemantics: type soundness proofs are notori\u00adously brittle with respect to the addition of new effects. \nThis is an important problem because effects are pervasive in programming language formalizations: in \naddition to extensions to syntax and semantics, new features usually introduce new effects to the de\u00adnotations. \nWithout a more robust formulation of type soundness, the addition of new effects requires cross-cutting \nchanges to type soundness theorem statements and proofs. Initially the semantics themselves were also \nbrittle with respect to effects [24, 32], but monads [31, 50] have been found to provide the necessary \nrobustness to denotations. Yet as far as we know, the brittleness of (denotational) type soundness proofs \nhas remained an open problem since it was raised by Wright and Felleisen [53] to motivate their own type-soundness \napproach. The framework we present here, modular monadic meta-theory (3MT), is the .rst in 20 years to \nprovide a substantial solution. Using 3MT, we develop a novel approach to proving type soundness for \nmonadic denotational semantics in a way that is modular in the set of effects used. Proofs for individual \nfeatures do not depend on effects they do not use and hence are robust to extension. The solution builds \non Meta-Theory ` a la Carte (MTC) [9], a Coq framework for the mechanization of formal programming language \nmeta-theory that supports modular extension of existing de.nitions. With MTC it is possible to develop \nmeta-theory which is modular in two dimensions: language features on the one hand and functions and proofs \nover these features on the other hand. MTC adapts ideas from existing programming language solutions \n[34, 46] to the expression problem [51] for functions and features, and adds modular induction for proofs. \n3MT adds a third modularity dimension to MTC: modular addition of new effects. 3MT enables the separate \nde.nition of features with effectful semantic functions and proofs over these functions, and reuse of \nthese features in formalizations of multiple languages. http://dx.doi.org/10.1145/2500365.2500587  To \nmake denotations robust with respect to effects, 3MT uses the established solution, monads. In Coq, type \nclasses [52] enable semantic function de.nitions that are constrained, yet polymorphic in the monad. \nThis allows the inclusion of a feature in any language which supports a superset of its effects. When \na language is com\u00adposed from different effectful features, monad transformers [28] are used to instantiate \nthe denotation s monad with all the effects required by the modular components. To solve the key challenge \nof modularizing and reusing theo\u00adrems and proofs of type soundness, we split the classic type sound\u00adness \ntheorems into three parts: 1. Reusable feature theorems capture the essence of type soundness for an \nindividual feature. They depend only on that feature s syntax, typing relation, semantic function and \nthe effects used therein. At the same time, they abstract over the syntax, semantics and effects of other \nfeatures. This means that the addition of new features with other types of effects does not affect the \nexisting feature theorem proofs. To achieve the abstraction over other effects, a feature uses a constrained \npolymorphic monad. As a consequence, it only establishes the well-typing of the resulting denotations \nwith respect to the effects declared in the constraints. 2. Reusable effect theorems .x the monad of \ndenotations and consequently the set of effects. They take well-typing proofs of monadic denotations \nexpressed in terms of a constrained polymorphic monad and which mention only a subset of effects, and \nturn them into well-typings with respect to a .xed monad and all the effects it provides. Effect theorems \nreason fully at the level of denotations and abstract over the details of language features like syntax \nand semantic functions. 3. Finally, language theorems establish type soundness for a particular language. \nThey require no more effort than to instantiate the set of features and the set of effects (i.e., the \nmonad), thus tying together the respective feature and effect theorems into an overall proof.  To establish \nthe .rst two theorems, 3MT relies on modular induc\u00adtion and algebraic laws about effects. As far as we \nknow, it applies the most comprehensive set of such laws to date, as each effect uti\u00adlized by a feature \nneeds to be backed up by laws and interactions be\u00adtween different effects must also be governed by laws. \nThese laws are crucial for modular reasoning in the presence of effects. In summary, the speci.c contributions \nof this work are: A reusable framework, 3MT, for mechanized meta-theory of languages with effects. This \nframework includes a mech\u00adanized library for monads, monad transformers and corre\u00adsponding algebraic \nlaws in Coq. Besides several laws for spe\u00adci.c types of effects, the library also includes laws for the \ninteractions between different types of effects.  A new modular proof method for type-soundness proofs \nof denotational semantics.  A case study of a family of fully mechanized languages, in\u00adcluding a mini-ML \nvariant with errors and references. The case study comprises 28 languages, 8 different effect theo\u00adrems \nand 5 features with their feature theorems.  3MT is implemented in the Coq proof assistant and the code \nis available at http://www.cs.utexas.edu/~bendy/3MT. Code and Notational Conventions While all the code \nunderlying this paper has been developed in Coq, the paper adopts a terser syn\u00adtax for its many code \nfragments. For the computational parts, this syntax exactly coincides with Haskell syntax, while it is \nan extrap\u00adolation of Haskell syntax style for propositions and proof concepts. Following MTC, the Coq \ncode requires the impredicative-set op\u00adtion due to the use of Church encodings. 2. Background: Meta-Theory \n`a la Carte This section summarizes the necessary parts of the Meta-Theory `a la Carte (MTC) approach \nto modular datatypes in Coq. For the full details of MTC, we refer the reader to the original paper [9]. \n2.1 Mendler Church Encodings and Folds for Semantics MTC encodes data types and folds with a variant \nof Church encod\u00adings [5, 36] based on Mendler folds [47]. The advantage of Mendler folds is that recursive \ncalls are explicit, allowing the user to pre\u00adcisely control the evaluation order. The Mendler-Church \nencodings represent (least) .xpoints and folds as follows: type Algebra M f a = .r.(r . a) . f r . a \ntype FixM f = .a.Algebra M f a . a foldM :: Algebra M f a . FixM f . a foldM alg fa = fa alg Mendler \nalgebras (Algebra M f a ) use a function argument of type (r . a) for their recursive calls. To enforce \nstructurally recursive calls, arguments which appear at recursive positions have a poly\u00admorphic type \nr. Using this polymorphic type prevents case analy\u00adsis, or any type of inspection, on those arguments. \nMendler-Church encodings (FixM f ) are functions of type .a.Algebra M f a . a. Mendler folds are de.ned \nby directly applying a Church encoded value fa to a Mendler algebra alg. All these de.nitions are non\u00adrecursive \nand can thus be expressed in Coq. Example As a simple example, consider a language for boolean expressions \nsupporting boolean literals and conditionals: data LogicF e = BLit Bool | If e e e type Value = Bool \nThe evaluation algebra for this language is de.ned as follows: ifAlg :: Algebra M Logic F Value ifAlg \n[\u00b7] (BLit b ) = b ifAlg [\u00b7] (If e1 e2 e3) = if [e1] then [e2] else [e3] Unlike conventional Church encodings \nand folds, the recursive calls ([\u00b7]) are explicit and indicate the evaluation order. The evaluation function \nsimply folds the ifAlg algebra: eval :: FixM LogicF . Value eval = foldM ifAlg  2.2 Modular Composition \nof Features MTC adapts the Data Types ` a la Carte (DTC) [46] approach for composing f -algebras to Mendler \nalgebras. Modular Functors Because feature syntax is de.ned by means of functors, such as LogicF , it \ncan easily be composed with functor composition: data (.) f g a = Inl (f a) | Inr (g a ) The syntax of \na language of both conditional and simple arithmetic expressions, for example, is Fix (Arith F . LogicF \n) where data Arith F e = Lit Int | Add e e Feature semantics are expressed as Mendler algebras and can \nbe composed in a similar way. Type Classes Unlike DTC, MTC de.nes a number of type classes with laws \nin order to support proofs. These classes and laws are summarized in the table in Figure 1. The second \ncolumn notes whether the base instances of a particular class are provided by the user or are automatically \ninferred with a default instance. Impor\u00adtantly, instances of all these classes for feature compositions \n(using .) are built automatically.  Class De.nition Description class Functor f where fmap :: (a . b) \n. (f a . f b) fmap id :: fmap id = id fmap fusion :: .g h . fmap h . fmap g = fmap (h . g) Functors Supplied \nby the user class f -: g where inj :: f a . g a prj :: g a . Maybe (f a) inj prj :: prj ga = Just fa \n. ga = inj fa prj inj :: prj . inj = Just Functor Subtyping Inferred class (Functor f , Functor g , f \n-: g) . WF Functor f g where wf functor :: .a b (h :: a . b). fmap h . inj = inj . fmap h Functor Delegation \nInferred class (Functor h , f -: h, g -: h) . Functor Discrimina- DistinctSubFunctor f g h where tion \ninj discriminate :: .a (fe :: f a) Inferred (ge :: g a ).inj fe = inj ge class FAlg name t a f where \nf algebra : Mixin t f a Function Algebras Supplied by the user class (f -: g, FAlg n t a f , FAlg n t \na g ) . WF FAlg n t a f g where wf algebra :: .rec (fa :: f t ). f algebra rec (inj fa ) = f algebra \nrec fa Algebra Delegation Inferred class (Functor f , Functor g , f -: g) . PAlg name f g a where p algebra \n:: Algebra f a proj eq :: .e.p1 (p algebra e ) = inf (inj (fmap p1 e)) Proof Algebras Supplied by the \nUser Figure 1. Type classes provided by 3MT The Functor class provides the fmap method and is an adap\u00adtation \nof the corresponding type class in Haskell. In contrast with the Haskell version, the two functor laws \nare part of the de.nition. The class -: represents a subtyping relation between two func\u00adtors f and g. \nThis class is an adaptation of the corresponding class in DTC and it includes two additional laws which \ngovern the be\u00adhavior of functor projection and injection (inj prj and prj inj ). The class WF Functor \nensures that fmap distributes through in\u00adjection, and the class DistinctSubFunctor ensures that injections \nfrom two different subfunctors are distinct. Unlike DTC, MTC de\u00ad.nes a single generic Coq type class, \nFAlg , for the de.nition of semantic algebras. FAlg is indexed by the name of the semantic function (name). \nNote that the type Mixin: type Mixin t f a = (t . a) . f r . a is a slight generalization of Mendler \nalgebras, which is useful for de.ning non-inductive language features such as general recursion or higher-order \nbinders. The type class WF FAlg provides a well\u00adformedness condition for every composite algebra. Finally, \nthe type class PAlg provides the de.nitions for proof algebras.  2.3 Modular Proofs The main novelty \nof MTC is its modular approach to inductive proofs. Regular structural induction is not available for \nChurch en\u00adcodings, so MTC adapts the proof methods used in the initial al\u00adgebra semantics of data types \n[14, 29] in particular universal properties to support modular inductive proofs over Church en\u00adcodings. \nProofs are written in the same modular style as functions, using proof algebras (class PAlg in Figure \n1). These algebras are folded over the terms and can be modularly combined. Unlike func\u00adtion algebras, \nproof algebras are subject to an additional constraint which ensures the validity of the proofs (proj \neq ). Sublemmas Each feature builds extensible datatypes by abstract\u00ading them over a super-functor. Because \nthis super-functor is ab\u00adstract, the complete set of cases needed by a proof algebra is un\u00adknown within \na feature. To perform induction, a feature must there\u00adfore dispatch proofs to an abstract proof algebra \nover this super\u00adfunctor. The components of this proof algebra are built in a dis\u00adtributed fashion among \nindividual features. These components can then be composed to build a complete proof algebra for a concrete \ncomposition of functors. As an example, consider the lemma that the type equality func\u00adtion eqType is \nsound: .t1 t2.eqType t1 t2 = true . t1 = t2 (EqP) This property can be captured in a proof algebra: PAlg \nEqF name f f (. e : EqP e ) A feature can build a proof of EqP for a speci.c type t by folding this proof \nalgebra over t. Features also provide speci.c instances of this proof algebra for the types they introduce: \nPAlg EqF name TBool F f (. e : EqP e ) A concrete language with boolean and natural types provides a \nproof algebra of the lemma by composing the proof algebras for the two separate type functors and instantiating \nthe super-functor f to TNatF . TBool F . By instantiating f to other functor compo\u00adsitions, the proof \nalgebras of the individual features can easily be reused in other languages.  2.4 No Effect Modularity \nUnfortunately, effect modularity is not supported in MTC. Consider two features: mutable references Ref \nF and errors ErrF . Both of these introduce an effect to any language, the former state and the latter \nthe possibility of raising an error. These effects show up in the type of their evaluation algebras: \nevalRef :: Algebra M Ref F (Env . (Value , Env)) evalErr :: Algebra M ErrF (Maybe Value ) MTC supports \nthe composition of two algebras over different func\u00adtors as long as they have the same carrier. That \nis not the case here, making the two algebras incompatible. This problem can be solved by anticipating \nboth effects in both algebras: evalRef :: Algebra M Ref F (Env . (Maybe Value , Env)) evalErr :: Algebra \nM ErrF (Env . (Maybe Value , Env)) This anticipation is problematic for modularity: the algebra for ref\u00aderences \nmentions the effect of errors even though it does not involve them, while a language that includes references \ndoes not necessar\u00adily feature errors. More importantly, the two algebras cannot be composed with a third \nfeature that introduces yet another effect (e.g., local environments) without further foresight. It is \nimpossible to know in advance all the effects that new features may introduce. 3. The 3M T Monad Library \n3MT includes a monad library to support effectful semantic func\u00adtions using monads and monad transformers, \nand provides alge\u00adbraic laws for reasoning. Monads provide a uniform representation for encapsulating \ncomputational effects such as mutable state, ex\u00adception handling, and non-determinism. Monad transformers \nallow monads supporting the desired set of effects to be built. Algebraic laws are the key to modular \nreasoning about monadic de.nitions. 3MT implements the necessary de.nitions of monads and monad transformers \nas a Coq library inspired by the Haskell monad transformer library (MTL) [28]. Our library re.nes the \nMTL in two key ways in order to support modular reasoning using algebraic laws. While algebraic laws \ncan only be documented informally in  Monad class Reader class Identity monad class Functor m . Monad \nm where class Monad m . RM e m where newtype I a return :: a . m a ask :: m e I :: a . I a (> =) :: m \na . (a . m b) . m b local :: (e . e) . m a . m a runI :: I a . a return bind :: return x > = f = f x \nask query :: ask > t = t bind return :: p > = return = p local return :: local f . return = return Failure \ntransformer bind bind :: (p > = f ) > = g = ask ask :: ask > = .s > = ask > = f s = newtype FT m a p \n> = .x . (f x > = g) ask > = .s . f s s FT :: m (Maybe a) . FT m a fmap bind :: fmap f t = t > = (return \n. f ) ask bind :: t > = .x . ask > = .e . f x e = runFT :: FT m a . m (Maybe a) Failure class class Monad \nm . FM m where local bind ask > = .e . t > = .x . f x e :: local f (t > = g) = local f t > = local f \n. g State transformer newtype ST s m a fail :: m a bind fail :: fail > = f = fail local ask local local \n:: local f ask = ask > = return . f :: local f . local g = local (g . f ) ST :: (s . m (a, s)) . ST s \nm a runST :: ST s m a . s . m (a, s) State class class Monad m . SM s m where get :: m s put :: s . m \n() get query :: get > t = t put get :: put s > get = put s > return s get put :: get > = put = return \n() get get :: get > = .s > = get > = f s = get > = .s . f s s put put :: put s1 > put s2 = put s2 Exception \nclass class Monad m . EM x m where throw :: x . m a catch :: m a . (x . m a) . m a bind throw :: throw \ne > = f = throw e catch throw1 :: catch (throw e) h = h e catch throw2 :: catch t throw = t catch return \n:: catch (return x) h = return x fmap catch :: fmap f (catch t h) = catch (fmap f t) (fmap f . h) Exception \ntransformer newtype ET x m a ET :: m (Either x a) . ET x m a runET :: ET x m a . m (Either x a) Reader \ntransformer newtype RT e m a RT :: (e . m a) . RT e m a runRT :: RT e m a . e . m a Figure 2. Key classes, \nde.nitions and laws from 3MT s monadic library. The names of algebraic laws are in bold. Haskell, our \nlibrary fully integrates them into type class de.nitions using Coq s expressive type system. Additionally, \n3MT systemati\u00adcally includes laws for all monad subclasses, several of which have not been covered in \nthe functional programming literature before. Library overview Figure 2 summarizes the library s key \nclasses, de.nitions and laws. The type class Monad describes the basic interface of monads. The type \nm a denotes computations of type m which produce values of type a when executed. The function return \nlifts a value of type a into a (pure) computation that simply produces the value. The bind function > \n= composes a computation m a producing values of type a, with a function that accepts a value of type \na and returns a computation of type m b. The function > de.nes a special case of bind that discards the \nintermediate value: (> ) :: Monad m . m a . m b . m b ma > mb = ma > = \\ . mb The do notation is syntactic \nsugar for the bind operator: do {x . f ; g } means f > = .x . g. Particular monads can be built from \nbasic monad types such as the identity monad (I) and monad transformers including the failure (FT), mutable \nstate (ST), and exception (ET) transformers. These transformers are combined into different monad stacks \nwith Iat the bottom. Constructor and extractor functions such as ST and runST provide the signatures \nof the functions for building and running particular monads/transformers. In order to support extensible \neffects, a feature needs to abstract over the monad implementation used. Any implementation which includes \nthe required operations is valid. These operations are cap\u00adtured in type classes such as SM and EM, also \ncalled monad sub\u00adclasses. The type classes (denoted by subscript M) are used to re\u00adquire a monad stack \nto support a particular effect without assuming a particular stack con.guration.1 Each class offers a \nset of primitive operations, such as get to access the state for SM. Algebraic laws Each monad (sub)class \nincludes a set of algebraic laws that govern its operations. These laws are an integral part of the de.nition \nof the monad type classes and constrain the possi\u00adble implementations to sensible ones. Thus, even without \nknowing 1 Supporting two instances of the same effect requires extra machinery [41]. the particular implementation \nof a type class, we can still modu\u00adlarly reason about its behavior via these laws. This is crucial for \nsupporting modular reasoning [35]. The .rst three laws for the Monad class are standard, while the last \nlaw (fmap bind) relates fmap and bind in the usual way. Each monad subclass also includes its own set \nof laws. The laws for various subclasses can be found scattered throughout the functional programming \nliterature, such as for failure [13] and state [13, 35]. Yet, as far as we know, 3MT is the .rst to systematically \nbring them together. Furthermore, although most laws have been presented in the semantics literature \nin one form or another, we have not seen some of the laws in the functional programming literature. One \nsuch example are the laws for the exception class: The bind throw law generalizes the bind fail law: \na sequen\u00adtial computation is aborted by throwing an exception.  The catch throw1 law states that the \nexception handler is invoked when an exception is thrown in a catch.  The catch throw2 law indicates \nthat an exception handler is redundant if it just re-throws the exception.  The catch return law states \nthat a catch around a pure com\u00adputation is redundant.  The fmap catch law states that pure functions \n(fmap f ) distribute on the right with catch.  Other de.nitions Our monad library contains a number \nof other classes, de.nitions and laws apart from the de.nitions discussed here. This includes infrastructure \nfor other types of effects (e.g. writer effects), as well as other infrastructure from the MTL. There \nare roughly 30 algebraic laws in total. 4. Modular Monadic Semantics Features can utilize the monad library \nincluded with 3MT to con\u00adstruct algebras for semantic functions which are compatible with a range of \neffects. These modular monadic algebras have the form: evalRef :: SM Store m . AlgebraM Ref F (m a) evalErr \n:: EM () m . AlgebraM ErrF (m a) These algebras use monad subclasses such as SM and EM to con\u00adstrain \nthe monad required by the feature, allowing the monad to  Simpli.ed value interface Monadic typing algebra \nMonadic evaluation algebra type Value typeofRef :: FM m . evalRef :: SM Store m . AlgebraM Ref F (m Value) \nloc :: Int . Value AlgebraM Ref F (m Type) evalRef rec (Ref e) = stuck :: Value typeofRef rec (Ref e) \n= do v . rec e unit :: Value do t . rec e env . get isLoc :: Value . Maybe Int return (tRef t) typeofRef \nrec (DeRef e) = put (v : env) return (loc (length env)) Simpli.ed type interface type Type tRef :: Type \n. Type do te . rec e maybe fail return (isTRef te) typeofRef rec (Assign e1 e2) = do t1 . rec e1 evalRef \nrec (DeRef e) = do v . rec e env . get case isLoc v of tUnit :: Type isTRef :: Type . Maybe Type case \nisTRef t1 of Nothing . fail Nothing . return stuck Just n . return (maybe stuck id (fetch n env)) Expression \nfunctor data Ref F a = Ref a | DeRef a | Assign a a Just t . do t2 . rec e2 if (t = t2) then return tUnit \nelse fail evalRef rec (Assign e1 e2) = do v . rec e1 env . get case isLoc v of Nothing . return stuck \nJust n . do v2 . rec e2 type Store = [Value ] put (replace n v2 env) return unit Figure 3. Syntax, type, \nand semantic function de.nitions for references. Arithmetic Expressions Monad m Boolean Expressions Monad \nm Errors EM () m References SM Store m Lambda RM Env m, FM m Figure 4. Effects used by the case study \ns evaluation algebras. have more effects than those used in the feature. These two alge\u00adbras can be combined \nto create a new evaluation algebra with type: (SM m s, EM m x) . AlgebraM (Ref F . ErrF ) (m a) The combination \nimposes both type class constraints while the monad type remains extensible with new effects. The complete \nset of effects used by the evaluation functions for the .ve language proof reuse, however: each combination \nof effects induces its own type soundness statement. Consider the theorem for a language with references \nwhich features a store s and a store typing S that are related through the store typing judgement S f \ns: 9 >= >; . j 8 >< >: typeof e = return t .e, t, S, s.. S f s put s > [e] = put sI > return v I I SI \n. S .v, S,s. SI f v : t SI f sI (LSOUNDS ) Contrast this with the theorem for a language with errors, \nwhich must account for the computation possibly ending in an exceptionfeatures used in our case study \nof Section 7 are given in Figure 4. being thrown: 4.1 Example: References Figure 3 illustrates this \napproach with de.nitions for the functor for expressions and the evaluation and typing algebras for the \nreference feature. Other features have similar de.nitions. For the sake of presentation the de.nitions \nare slightly simpli\u00ad.ed from the actual ones in Coq. For instance, we have omitted .e, t.typeof e = return \nt . (.v.[e] = return v. f v : t) . (.x.[e] = throw x) (LSOUNDE ) Clearly, the available effects are essential \nfor the formulation of issues related to the extensibility of the syntax for values (Value) the theorem. \nA larger language which involves both exceptions and and types (Type). We refer the interested reader \nto MTC [9] and state requires yet another theorem where the impact of both effects the 3MT Coq code for \nthese details. Value and Type are treated cross-cut one another2: as abstract datatypes with a number \nof constructor functions: loc, stuck, unit, tRef and tUnit denote respectively reference loca\u00adtions, \nstuck values, unit values, reference types and unit types. There are also matching functions isLoc and \nisTRef for checking whether a term is a location value or a reference type, respectively. The type Ref \nF is the functor for references. It has constructors for creating references (Ref ), dereferencing (DeRef \n) and assign\u00ading (Assign) references. The evaluation algebra evalRef uses the state monad for its reference \nenvironment, which is captured in the type class constraint SM Store m. The typing algebra (typeofRef \n) is also monadic, using the failure monad to denote ill-typing. 9 >= >; . j 8 >< >: typeof e = return \nt .e, t, S, s.. S f s put s > [e] = put sI > return v I I SI . S .v, S,s. SI f v : t SI f sI . .x.put \ns > [e] = throw x (LSOUNDES ) Modular formulations of LSOUNDE less for proving a modular variant of LSOUNDES \n 4.2 Effect-Dependent Theorems and LSOUNDS are use\u00ad because their Monadic semantic function algebras \nare compatible with new ef\u00adfects and algebraic laws facilitate writing extensible proofs over these \nmonadic algebras. Effects introduce further challenges to 2 A similar proliferation of soundness theorems \ncan be found in TAPL [37]. (WFM-ILLTYPED) S fM vm : fail S f v : t (WFM-RETURN) S fM return v : return \nt Figure 5. Typing rules for pure monadic values. induction hypotheses have the wrong form. The hypothesis \nfor LSOUNDE requires the result to be of the form return v, disal\u00adlowing put sI > return v (the form \nrequired by LSOUNDS ). Similarly, the hypothesis for LSOUNDS does not account for ex\u00adceptions occurring \nin subterms. In general, without anticipating ad\u00additional effects, type soundness theorems with .xed \nsets of effects cannot be reused modularly. 5. Modular Monadic Type Soundness In order to preserve a \nmeasure of modularity, we do not prove type soundness directly for a given feature, but by means of a \nmore generic theorem. The technique of proving a theorem of interest by means of a more general theorem \nis well-known. For a conven\u00adtional monolithic language, for instance, type soundness is often established \nfor any well-formed typing context, even though the main interest lies with the more speci.c initial, \nempty context. In that setting, the more general theorem produces a weaker induction hypothesis for the \ntheorem s proof. Our approach to type soundness follows the core idea of this technique and relies on \nthree theorems: FSOUND: a reusable feature theorem that is only aware of the effects that a feature uses \nESOUND: an effect theorem for a .xed set of known effects, and LSOUND: a language theorem which combines \nthe two to prove soundness for a speci.c language. In order to maximize compatibility, the statement \nof the reusable feature theorem cannot hardwire the set of effects. This statement must instead rephrase \ntype soundness in a way that can adapt to any superset of a feature s effects. Our solution is to have \nthe feature theorem establish that the monadic evaluation and typing algebras of a feature satisfy an \nextensible well-formedness relation, de.ned in terms of effect-speci.c typing rules. Thus, a feature \ns proof of FSOUND uses only the typing rules required for the effects speci.c to that feature. The .nal \nlanguage combines the typing rules of all the language s effects into a closed relation. Figure 6 illustrates \nhow these reusable pieces .t together to build a proof of soundness. Each feature provides a proof algebra \nfor FSOUND which relies on the typing rules (WFM-X) for the ef\u00adfects it uses. Each unique statement of \nsoundness for a combination of effects requires a new proof of ESOUND. The proof of LSOUND for a particular \nlanguage is synthesized entirely from a single proof of ESOUND and a combination of proof algebras for \nFSOUND. Note that there are several dimensions of modularity here. A feature s proof of FSOUND only depends \non the typing rules for the effects that feature uses and can thus be used in any language which includes \nthose typing rules. The typing rules themselves can Figure 6. Dependency Graph Extensible Typing Relation \nThe extensible typing relation has the form: S fM vm : tm The relation is polymorphic in an environment \ntype env and an evaluation monad type m. The parameters S, vm and tm have types env, m Value and Maybe \nType respectively. The modular typing rules for this relation can impose constraints on the environment \ntype env and monad type m. A particular language must instantiate env and m in a way that satis.es all \nthe constraints imposed by the typing rules used in its features. Figure 5 lists the two base typing \nrules of this relation. These do not constrain the evaluation monad and environment types and are the \nonly rules needed for pure features. The (WFM-ILLTYPED) rule denotes that nothing can be said about computations \n(me) which are ill-typed. The (WFM-RETURN) rule ensures that well\u00adtyped computations only yield values \nof the expected type. To see how the reusable theorem works for a pure feature, consider the proof of \nsoundness for the boolean feature. Proof Using the above two rules, we can show that FSOUND holds for \nthe boolean feature. The proof has two cases. The boolean literal case is handled by a trivial application \nof (WFM-RETURN). The second case, for conditionals, is more interesting3 . (fM : typeof ec) . [ec] (fM \n: typeof et ) . [et ] (fM [ee] : typeof ee) . 01 01 . typeof do tc ec . typeoftt et CCCCCCCA BBBBBBB@ \nbe reused by any number of different features. ESOUND depends . . typeofJust b te ee fM : solely on a \nspeci.c combination of effects and can be reused in if b then [et ] any language which supports that \nunique combination, e.g. both guard (eqT tt te) LSOUNDA and LSOUNDAR use ESOUNDES . return tt CCCCCCCA \nBBBBBBB@ do v . [ec]case isBool v of guard (isTBool tc) else [ee ]Nothing . stuck 5.1 Soundness for \na Pure Feature (WFM-IF-VC) The reusable feature theorem FSOUND states that [\u00b7] and typeof Because [\u00b7] \nand typeof are polymorphic in the monad, we are related by the extensible typing relation: cannot directly \ninspect the values they produce. We can, how\u00ad .e, S. S fM [e] : typeof e (FSOUND) 3 We omit the environment \nS to avoid clutter.  ever, perform case analysis on the derivations of the proofs pro\u00adduced by the induction \nhypothesis that the subexpressions are well-formed, fM [ec] : typeof ec, fM [et ] : typeof et , and fM \n[ee ] : typeof ee . The .nal rule used in each derivation deter\u00admines the shape of the monadic value \nproduced by [\u00b7] and typeof . Assuming that only the pure typing rules of Figure 5 are used for the derivations, \nwe can divide the proof into two cases depending on whether ec, et , or ee was typed with (WFM-ILLTYPED). \n If any of the three derivations uses (WFM-ILLTYPED), the result of typeof is fail. As fail is the zero \nof the typing monad, (WFM-ILLTYPED) resolves the case.  Otherwise, each of the subderivations was built \nwith (WFM-RETURN) and the evaluation and typing expressions can be simpli.ed using the return bind monad \nlaw.  S fM throw x : tm (WFM-THROW) S fM m > = k : tm . SI . S x . SI fM h x > = k : S fM catch m h \n> = k : tm tm (WFM-CATCH) Figure 7. Typing rules for exceptional monadic values. different proof algebras. \nRelying on such speci.c properties can lead to a proliferation of proof obligations for each new effect. \nAlternatively, the boolean feature can use a proof algebra for a stronger property that is also applicable \nin other proofs, cutting down on the number of feature interactions. One such stronger, more general \nsublemma relates the monadic bind operation to well\u00ad typing: 1 0 do guard (isTBool tc) 1 CCA 0 BB@ case \nisBool vc of BBBBB@ if b then return vt else return ve CCCCCA (S fM vm : tm) . Just b . II I fM guard \n(eqT tt te ) : (.v T S. S. (Sf v : T ) . S fM kv v : kt T ) . return tt S fM vm > = kv : tm > = kt (WFM-BIND) \nNothing . stuck A proof of WFM-IF-VC follows from two applications of this stronger property. The advantage \nof WFM-BIND is clear: it can be reused to deal with case analyses in other proofs of FSOUND, while After \nsimpli.cation, the typing expression has replaced the bind with explicit values which can be reasoned \nwith. If a proof of WFM-IF-VC has only a single use. The disadvantageisTBool tc is false, then the typing \nexpression reduces to is that WFM-BIND may not hold for some new effect, whilefail and well-formedness \nagain follows from the WFM\u00adthe weaker WFM-IF-VC does, possibly excluding some featureILLTYPED rule. Otherwise \ntc = TBool, and we can apply combinations. As WFM-BIND is a desirable property for typingthe inversion \nlemma rules, the case study focuses on that approach. f v : TBool . .b.isBool v = Just b to establish \nthat vc is of the form Just b, reducing the evaluation to either return ve or return vt . A similar case \nanalysis on eqT tt te will either produce fail or return tt . The former is trivially true, and both \nfM return vt : return tt and fM return ve : return tt hold in the latter case from the induction hypotheses. \nModular Sublemmas The above proof assumed that only the pure typing rules of Figure 5 were used to type \nthe subexpressions of the if expression, which is clearly not the case when the boolean feature is included \nin an effectful language. Instead, case analyses are performed on the extensible typing relation in order \nto make the boolean feature theorem compatible with new effects. Case analyses over the extensible fM \nrelation are accomplished using extensible proof algebras which are folded over the derivations provided \nby the induction hypothesis, as outlined in Section 2.3. In order for the boolean feature s proof of \nFSOUND to be com\u00adpatible with a new effect, each extensible case analysis requires a proof algebra for \nthe new typing rules the effect introduces to the fM relation. These proof algebras are examples of feature \ninter\u00adactions [3] from the setting of modular component-based frame\u00adworks. In essence, a feature interaction \nis functionality (e.g., a function or a proof) that is only necessary when two features are combined. \nImportantly, these proof algebras do not need to be pro\u00advided up front when developing the boolean algebra, \nbut can in\u00adstead be modularly resolved by a separate feature for the interaction of booleans and the \nnew effect. The formulation of the properties proved by extensible case analysis has an impact on modularity. \nThe conditional case of the previous proof can be dispatched by folding a proof algebra for the property \nWFM-IF-VC over fM : typeof . Each new [vc] tc effect induces a new case for this proof algebra, however, \nresulting in an interaction between booleans and every effect. WFM-IF-VC is speci.c to the proof of FSOUND \nin the boolean feature; proofs of FSOUND for other features require different properties and thus  5.2 \nType Soundness for a Pure Language The second phase of showing type soundness is to prove a state\u00adment \nof soundness for a .xed set of effects. For pure effects, the soundness statement is straightforward: \n.vm t. fM vm : return t . .v.vm = return v . f v : t (ESOUNDP ) Each effect theorem is proved by induction \nover the derivation of fM vm : return t. ESOUNDP .xes the irrelevant environment type to the type () \nand the evaluation monad to the pure monad I. Since the evaluation monad is .xed, the proof of ESOUNDP \nonly needs to consider the pure typing rules of Figure 5. The proof of the effect theorem is straightforward: \nWFM-ILLTYPED could not have been used to derive fM vm : return t, and WFM-RETURN provides both a witness \nfor v and a proof that it is of type t. The statement of soundness for a pure language built from a particular \nset of features is similar to ESOUNDP : .e, t.typeof e = return t . .v.[e] = return v . f v : t (LSOUND) \nThe proof of LSOUND is an immediate consequence of the reusable proofs of FSOUND and ESOUNDP . Folding \na proof al\u00adgebra for FSOUND over e provides a proof of fM [e] : return t, satisfying the .rst assumption \nof ESOUNDP . LSOUND follows im\u00admediately.  5.3 Errors The evaluation algebra of the error language feature \nuses the side effects of the exception monad, requiring new typing rules. Typing Rules Figure 7 lists \nthe typing rules for monadic compu\u00adtations involving exceptions. WFM-THROW states that throw x is typeable \nwith any type. WFM-CATCH states that binding the re\u00adsults of both branches of a catch statement will \nproduce a monad with the same type. While it may seem odd that this rule is formu\u00adlated in terms of a \ncontinuation > =k, it is essential for compatibil\u00adity with the proofs algebras required by other features. \nAs described  Figure 8. Typing rules for stateful monadic values. in Section 5.1, extensible proof algebras \nover the typing derivation will now need cases for the two new rules. To illustrate this, con\u00adsider the \nproof algebra for the general purpose WFM-BIND prop\u00aderty. This algebra requires a proof of: (S fM catch \ne h > = k : tm) . II I (.v T S. S. (Sf v : T ) . SfM kv v : kt T ) . S fM (catch e h > = k) > = kv : \ntm > = kt With the continuation, we can .rst apply the associativity law to reorder the binds so that \nWFM-CATCH can be applied: (catch e h > = k)> = kv = catch e h > = (k> =kv). The two premises of the rule \nfollow immediately from the inductive hypoth\u00adesis of the lemma, .nishing the proof. Without the continuation, \nthe proof statement only binds catch e h to vm , leaving no applicable typing rules. Effect Theorem The \neffect theorem, ESOUNDE , for a language whose only effect is exceptions re.ects that the evaluation \nfunction is either a well-typed value or an exception. .vm t. fM vm : return t . .x.vm = throw x . .v.vm \n= return v. f v : t (ESOUNDE ) The proof of ESOUNDE is again by induction on the derivation of fM vm \n: return t. The irrelevant environment can be .xed to (), while the evaluation monad is the exception \nmonad ET x I. The typing derivation is built from four rules: the two pure rules from Figure 5 and the \ntwo exception rules from Figure 7. The case for the two pure rules is effectively the same as be\u00adfore, \nand WFM-THROW is straightforward. In the remaining case, vm = catch e I h, and we can leverage the fact \nthat the evalu\u00adation monad is .xed to conclude that either .v.e I = return v or .x.e I = throw x. In \nthe former case, catch e I h can be re\u00adduced using catch return, and the latter case is simpli.ed using \ncatch throw1. In both cases, the conclusion then follows imme\u00addiately from the assumptions of WFM-CATCH. \nThe proof of the language theorem LSOUNDE is similar to LSOUND and is easily built from ESOUNDE and FSOUND. \n 5.4 References Typing Rules Figure 8 lists the two typing rules for stateful com\u00adputations. To understand \nthe formulation of these rules, consider LSOUNDS , the statement of soundness for a language with a state\u00adful \nevaluation function. The statement accounts for both the typing environment S and evaluation environment \ns by imposing the in\u00advariant that s is well-formed with respect to S. FSOUND however, has no such conditions \n(which would be anti-modular in any case). We avoid this problem by accounting for the invariant in the \ntyping rules themselves: WFM-GET requires that the continuation k of a get is well\u00adtyped under the invariant. \n WFM-PUT requires that any newly installed environment  maintains this invariant. The intuition behind \nthese premises is that effect theorems will maintain these invariants in order to apply the rules. .s, \nS f s . S fM k s : tm ... G f . . G fM k . : tm (WFM-GET) (WFM-ASK) S fM get > = k : tm G fM ask > =k \n: tm SI f s SI . S SI fM k : tm . .. G f . . GI f f . GI fM m : return tm I (WFM-PUT) .v. f v : tI \nm . G fM (k v) : tm S fM put s > k : tm G fM local f m > = k : tm (WFM-LOCAL) (WFM-BOT) G fM . : tm Figure \n9. Typing rules for environment and failure monads. Effect Theorem The effect theorem for mutable state \nproceeds again by induction over the typing derivation. The evaluation monad is .xed to ST Sigma I and \nthe environment type is .xed to [Type ] with the obvious de.nitions for .. The proof case for the two \npure rules is again straightforward. For WFM-GET we have that put s > [e] = put s > get> = k. After \nreducing this to k s with the put get law, the result follows immediately from the rule s assumptions. \n Similarly, for WFM-PUT we have that put s =  > [e] put s > put sI > k. After reducing this to put \nsI > k with the put put law, the result again follows immediately from the rule s assumptions.  5.5 \nLambda The case study represents the binders of the lambda feature using PHOAS [7] to avoid many of the \nboilerplate de.nitions and proofs about term well-formedness found in .rst-order representations. The \nEnvironment Effect Unlike in MTC, 3MT neatly hides the variable environment of the evaluation function \nwith a reader monad RM. This new effect introduces the two new typing rules listed in Figure 9. Unsurprisingly, \nthese typing rule are similar to those of Figure 8. The rule for ask is essentially the same as WFM-GET. \nThe typing rule for local differs slightly from WFM-PUT. Its .rst premise ensures that whenever f is \napplied to an environment that is well-formed in the original typing environment G, the re\u00adsulting environment \nis well-formed in some new environment GI . The second premise ensures the body of local is well-formed \nin this environment according to some type T , and the .nal premise ensures that k is well-formed when \napplied to any value of type T . The intuition behind binding the local expression in some k is the same \nas with put. The Non-Termination Effect The lambda feature also introduces the possibility of non-termination \nto the evaluation function, which is disallowed by Coq. MTC solves this problem by combining mixin algebras \nwith a bounded .xpoint function. This function applies an algebra a bounded number of times, returning \na . value when the bound is exceeded. Because MTC represented . as a value, all evaluation algebras needed \nto account for it explicitly. In the monadic setting, 3MT elegantly represents . with the fail primitive \nof the failure monad. This allows terminating features to be completely oblivious to whether a bounded \nor standard fold is used for the evaluation function, resulting in a much cleaner semantics. WFM-BOT \nallows . to have any type. 6. Effect Compositions As we have seen, laws are essential for proofs of FSOUND. \nThe proofs so far have involved only one effect and the laws regulate the behavior of that effect s primitive \noperations.  8 >< 9 >= Languages often involve more than one effect, however. Hence, the proofs of effect \ntheorems must reason about the interaction be\u00ad .S, G, d, ., s, eE , eT . . tween multiple effects. There \nis a trade-off between fully instanti\u00ad S f . : G >: ating the monad for the language as we have done \npreviously, and typeof eT = return t >; continuing to reason about a constrained polymorphic monad. The \n9 = local (. ..) (put s > [e]E ) > return v) former is easy for reasoning, while the latter allows the \nsame lan- I I = local (. ..) (put sI . S , s guage proof to be instantiated with different implementations \nof , v. :; SI f v : t the monad. In the latter case, additional effect interaction laws are required. \n. 8 >< 9 >= >; 6.1 Languages with State and Exceptions local (. ..) (put s > [e]E ) = local (. ..(put \nsI > .) SI Consider the effect theorem which .xes the evaluation monad to . SI , sI , v. SI f sI : >: \nsupport exceptions and state. The statement of the theorem men\u00ad SI . S tions both kinds of effects by \nrequiring the evaluation function to be run with a well-formed state s and by concluding that well\u00ad . \n8 >< 9 >= typed expressions either throw an exception or return a value. The WFM-CATCH case this theorem \nhas the following goal: local (. ..) (put s > [e]E ) > throw t) SI = local (. .G(put sI . SI , sI , v. \nSI f sI (S f s : S) : >; (ESOUNDESRF ) SI f v : t Figure 10. Effect theorem statement for languages with \nerrors, >: SI . S . j . put s > catch e h > = k = put sI > return v . SI , sI , v. state, an environment \nand failure. . j . put s > catch e h > = k = put sI > throw x I I The study builds twenty eight different \ncombinations of the . S , s, x. SI SI f sI : features which are all possible combinations with at least \none feature providing values.4 Figure 13 presents the syntax of theIn order to apply the induction hypothesis \nto e and h, we need to precede them by a put s. Hence, put s must be pushed under the catch statement \nthrough the use of a law governing the behavior of put and catch. There are different choices for this \nlaw, depending on the monad that implements both SM and EM. We consider two reasonable choices, based \non the monad transformer compositions ET x (ST s I) and ST s (ET x I): Either catch passes the current \nstate into the handler: put s > catch e h = catch (put s > e) h  Or catch runs the handler with the \ninitial state: put s > catch e h = catch (put s > e) (put s > h)  The WFM-CATCH case is provable under \neither choice. As the LSOUNDES proof is written as an extensible theorem, the two cases are written as \ntwo separate proof algebras, each with a different assumption about the behavior of the interaction. \nSince the cases for the other rules are impervious to the choice, they can be reused with either proof \nof WFM-CATCH.  6.2 Full Combination of Effects A language with references, errors and lambda abstractions \nfeatures four effects: state, exceptions, an environment and failure. The language theorem for such a \nlanguage relies on the effect theorem ESOUNDESRF given in Figure 10. The proof of ESOUNDESRF is similar \nto the previous effect theorem proofs, and makes use of the full set of interaction laws given in Figure \n11. Perhaps the most interesting observation here is that because the environment monad only makes local \nchanges, we can avoid having to choose between laws regarding how it interacts with exceptions. Also \nnote that since we are representing nontermination using a failure monad FM m, the catch fail law conforms \nto our desired semantics. 7. Case Study As a demonstration of the 3MT framework, we have built a set \nof .ve reusable language features and combined them to build a family of languages which includes a mini-ML \n[8] variant with references and errors. The study includes pure boolean and arith\u00admetic features as well \nas effectful features for references, errors and lambda abstractions. expressions, values, and types \nprovided; each line is annotated with the feature that provides that set of de.nitions. Four kinds of \nfeature interactions appear in the case study. The PHOAS representation of binders requires an auxiliary \nequivalence relation, the details of which are covered in the MTC paper [9]. The soundness proofs of \nlanguage theorems 4 Also available at http://www.cs.utexas.edu/~bendy/3MT Exceptional Environment class \n(EM x m, RM m) . ERM x g m where local throw :: local f (throw e) = throw e local catch :: local f (catch \ne h) = catch (local f e) (.x.local f (h x)) Exceptional Failure class (EM x m, FM m) . FSM x m where \ncatch fail :: catch fail h = fail fail neq throw :: fail = throw x Exceptional State Failure class (EM \nx m, SM s m, FM m) . EFSM x m where put fail throw :: put s > fail = put s1 > throw x Exceptional State \nclass (EM x m, FM m) . MonadErrorState x m where put ret throw :: put s > return a = put s1 > throw x \nput throw :: .A B.put s > throw A x = put s1 > throw A x . put s > throw B x = put s1 > throw B x Alternate \nExceptional State laws class (EM x m, FM m) . ESM1 x m where put catch1 :: put s > catch e h = catch \n(put s > e) h Or class (EM x m, FM m) . ESM2 x m where put catch2 :: put env > catch e h = catch (put \ns > e) (.x . put s > h x) Figure 11. Interaction laws  e ::= N | e + e Arith | B | if e then e else \ne Bool | lam x : T.e | e e | x Lambda | ref e | !e | e:=e References | try e with e | error Errors V \n::= N Arith T ::= Nat Arith | B Bool | Bool Bool | clos e V Lambda | T . T Lambda | loc N References \n| Ref T References Figure 13. mini-ML expressions, values, and types for languages which include binders \nproceed by induction over this equivalence relation instead of expressions. The reusable feature theorems \nof other features need to be lifted to this equivalence relation. The effect theorems that feature an \nenvironment typing S, such as those for state or environment, need a weakening sublemma which states \nthat each well-formed value under S is also well-formed under a conservative extension: S f v : t . SI \n. S . SI f v : t Inversion lemmas for the well-formed value relation as in the proof of FSOUN D for the \nboolean feature in Section 5.1 are proven by induction over the relation. The proofs of the .rst and \nsecond kind of feature interactions are straightforward; the inversion lemmas of the third kind can be \ndis\u00adpatched by tactics hooked into the type class inference algorithm. The framework itself consists \nof about 4,400 LoC of which about 2,000 LoC comprise the implementation of the monad trans\u00adformers and \ntheir algebraic laws. The size in LoC of the implemen\u00adtation of semantic evaluation and typing functions \nand the reusable feature theorem for each language feature is given in the left box in Figure 12. The \nright box lists the sizes of the effect theorems. Each language needs on average 110 LoC to assemble \nits semantic functions and soundness proofs from those of its features and the effect theorem for its \nset of effects. 8. Related Work While previous work has explored the basic techniques of modu\u00adlarizing \ndynamic semantics of languages with effects, our work is the .rst to show how to also do modular proofs. \nAdding the ability to do modular proofs required the development of novel techniques for reasoning about \nmodular components with effects. 8.1 Functional Models for Modular Side Effects Monads and Monad Transformers \nSince Moggi [31] .rst pro\u00adposed monads to model side-effects, and Wadler [50] popularized them in the \ncontext of Haskell, various researchers (e.g., [21, 45]) have sought to modularize monads. Monad transformers \nemerged [6, 28] from this process, and in later years various alternative im\u00adplementation designs facilitating \nmonad (transformer) implemen\u00adtations, have been developed, including Filinksi s layered mon\u00adads [10] \nand Jaskelioff s Monatron [19]. Monads and Subtyping Filinski s MultiMonadic MetaLanguage (M3L) [11, \n12] embraces the monadic approach, but uses subtyp\u00ading (or subeffecting) to combine the effects of different \ncompo\u00adnents. The subtyping relation is .xed at the program or language level, which does not provide \nthe adaptability we achieve with con\u00adstrained polymorphism. Algebraic Effects and Effect Handlers In \nthe semantics commu\u00adnity the algebraic theory of computational effects [39] has been an active area of \nresearch. Many of the laws about effects, which we have not seen before in the context of functional \nprogramming, can be found throughout the semantics literature. Our .rst four laws for exceptions, for \nexample, have been presented by Levy [26]. A more recent model of side effects are effect handlers. They \nwere introduced by Plotkin and Pretnar [38] as a generalization from exception handlers to handlers for \na range of computational effects, such as I/O, state, and nondeterminism. Bauer and Pret\u00adnar [4] built \nthe language Eff around effect handlers and show how to implement a wide range of effects in it. Kammar \net al. [22] showed that effect handlers can be implemented in terms of de\u00adlimited continuations or free \nmonads. The major advantage of effect handlers over monads is that they are more easily composed, as \nany composition of effect operations and corresponding handlers is valid. In contrast, not every compo\u00adsition \nof monads is a monad. In the future, we plan on investigating the use of effect handlers instead of monad \ntransformers, which could potentially reduce the amount of work involved on proofs about interactions \nof effects. Other Effect Models Other useful models have been proposed, such as applicative functors \n[30] and arrows [17], each with their own axioms and modularity properties.  8.2 Modular Effectful \nSemantics There are several works on how to modularize semantics with effects, although none of these \nworks considers reasoning. Mosses [33] modularizes structural operational semantics by means of a label \ntransition system where extensible labels capture effects like state and abrupt termination. Swierstra \n[46] presents modular syntax with functor coproducts and modular semantics with algebra compositions. \nTo support effects, he uses modular syntax to de.ne a free monad. The effectful semantics for this free \nmonad is not given in a modular manner, however. Jaske\u00adlioff et al. [20] present a modular approach for \noperational seman\u00adtics on top of Swierstra s modular syntax, although they do not cover conventional \nsemantics with side-effects. Both Schrijvers and Oliveira [42] and Bahr and Hvitved [2] have shown how \nto de.ne modular semantics with monads for effects; this is essentially the approach followed in this \npaper for modular semantics. 8.3 Effects and Reasoning Non-Modular Monadic Reasoning Although monads \nare a purely functional way to encapsulate computational-effects, programs us\u00ading monads are challenging \nto reason about. The main issue is that monads provide an abstraction over purely functional models of \neffects, allowing functional programmers to write programs in terms of abstract operations like > =, \nreturn, or get and put. One way to reason about monadic programs is to remove the abstrac\u00adtion provided \nby such operations [18]. However, this approach is fundamentally non-modular. Modular Monadic Reasoning \nSeveral more modular approaches to modular monadic reasoning have been pursued in the past. One approach \nto modular monadic reasoning is to exploit para\u00admetricity [40, 49]. Voigtl\u00a8ander [48] has shown how to \nderive para\u00admetricity theorems for type constructor classes such as Monad. Unfortunately, the reasoning \npower of parametricity is limited, and parametricity is not supported by proof assistants like Coq. A \nsecond technique uses algebraic laws. Liang and Hudak [27] present one of the earliest examples of using \nalgebraic laws for reasoning. They use algebraic laws for reader monads to prove correctness properties \nabout a modular compiler. In contrast to our work, their compiler correctness proofs are pen-and-paper \nand thus more informal than our proofs. Since they are not restricted by a termination checker or the \nuse of positive types only, they exploit features like general recursion in their de.nitions. Oliveira \net al. [35] have also used algebraic laws for the state monad, in combination with parametricity, for \nmodular proofs of non\u00adinterference of aspect-oriented advice. Hinze and Gibbons discuss several other \nalgebraic laws for various types of monads [13]. However, as far as we know, we are the .rst to provide \nan extensive mechanized library for monads and algebraic laws in Coq.  8.4 Mechanization of Monad Transformers \nHuffmann [16] illustrates an approach for mechanizing type con\u00adstructor classes in Isabelle/HOL with \nmonad transformers. He con\u00adsiders transformer variants of the resumption, error and writer mon\u00adads, but \nfeatures only the generic functor, monad and transformer laws. The work tackles many issues that are \nnot relevant for our Coq setting, such as lack of parametric polymorphism and explicit modeling of laziness. \n9. Conclusion In previous work [9] we have shown that it is possible to modularize meta-theory along \ntwo dimensions: 1) language constructs and 2) operations and proofs. A signi.cant limitation of that \nwork is that it only considered pure languages. This work lifts that limitation and shows how to develop \nmodu\u00adlar meta-theory for languages with effects. Our solution uses mon\u00adads and corresponding algebraic \nlaws for reasoning about different types of effects. The key challenge that we have solved is how to \nformulate and prove a general type-soundness theorem in a mod\u00adular way that enables the reuse of feature \nproofs across multiple languages with different sets of effects. This turned out to be non\u00adtrivial because \nexisting formulations of type-soundness are very sensitive to the particular effects used by the language. \nAs a secondary contribution, our work shows that algebraic laws about effects scale up to realistic veri.cation \ntasks such as meta\u00adtheoretic proofs. As far as we know, it is their largest application to date. In this \nsetting, the proof assistant Coq has been invaluable. While the typically smaller examples in the functional \nprogram\u00adming community can easily be dealt with by pen-and-paper proofs, that approach would not have \nbeen manageable for the large family of type-soundness proofs for mini-ML variants, as keeping track \nof large goals and hypotheses by hand would be too painful and error-prone. Acknowledgements We would \nlike to thank the anonymous re\u00adviewers for their many comments and suggestions. This work was supported \nby the National Science Foundation under Grant CCF 0724979. References [1] Brian E. Aydemir et al. Mechanized \nmetatheory for the masses: The poplmark challenge. In Theorem Proving in Higher Order Logics, volume \n3603 of Lecture Notes in Computer Science, pages 50 65. Springer, 2005. [2] Patrick Bahr and Tom Hvitved. \nCompositional data types. In Pro\u00adceedings of the seventh ACM SIGPLAN workshop on Generic pro\u00adgramming, \nWGP 11, pages 83 94. ACM, 2011. [3] Don Batory, Jongwook Kim, and Peter H\u00a8ofner. Feature interactions, \nproducts, and composition. In Proceedings of the 10th ACM interna\u00adtional conference on Generative programming \nand component engi\u00adneering, GPCE 11. ACM, 2011. [4] Andrej Bauer and Matija Pretnar. Programming with \nalgebraic effects and handlers. CoRR, abs/1203.1539, 2012. [5] Corrado B\u00a8ohm and Alessandro Berarducci. \nAutomatic synthesis of typed -programs on term algebras. Theoretical Computer Science, 39(0):135 154, \n1985. [6] Pietro Cenciarelli and Eugenio Moggi. A syntactic approach to mod\u00adularity in denotational semantics. \nIn In Proceedings of the Conference on Category Theory and Computer Science, CCTCS 93, 1993. [7] Adam \nChlipala. Parametric higher-order abstract syntax for mecha\u00adnized semantics. In Proceedings of the 13th \nACM SIGPLAN interna\u00adtional conference on Functional programming, ICFP 08, pages 143 156. ACM, 2008. [8] \nDominique Cl\u00b4ement, Thierry Despeyroux, Gilles Kahn, and Jo\u00a8elle Despeyroux. A simple applicative language: \nmini-ml. In Proceedings of the 1986 ACM conference on LISP and functional programming, LFP 86, pages \n13 27. ACM, 1986. [9] Benjamin Delaware, Bruno C. d. S. Oliveira, and Tom Schrijvers. Meta-theory `In \nProceedings of the 40th annual ACM a la carte. SIGPLAN-SIGACT symposium on Principles of programming \nlan\u00adguages, POPL 13, pages 207 218. ACM, 2013. [10] Andrzej Filinski. Representing layered monads. In \nProceedings of the 26th ACM SIGPLAN-SIGACT symposium on Principles of program\u00adming languages, POPL 99, \npages 175 188. ACM, 1999. [11] Andrzej Filinski. On the relations between monadic semantics. Theor. Comput. \nSci., 375(1-3):41 75, 2007. [12] Andrzej Filinski. Monads in action. In Proceedings of the 37th annual \nACM SIGPLAN-SIGACT symposium on Principles of programming languages, POPL 10, pages 483 494. ACM, 2010. \n [13] Jeremy Gibbons and Ralf Hinze. Just do it: simple monadic equational reasoning. In Proceedings \nof the 16th ACM SIGPLAN international conference on Functional programming, ICFP 11, pages 2 14. ACM, \n2011. [14] Joseph A. Goguen, James W. Thatcher, Eric G. Wagner, and Jesse B. Wright. Initial algebra \nsemantics and continuous algebras. J. ACM, 24(1), 1977. [15] Georges Gonthier. Engineering mathematics: \nthe odd order theo\u00adrem proof. In Proceedings of the 40th annual ACM SIGPLAN-SIGACT symposium on Principles \nof programming languages, POPL 13, pages 1 2. ACM, 2013. [16] Brian Huffman. Formal veri.cation of monad \ntransformers. In Proceedings of the 17th ACM SIGPLAN international conference on Functional programming, \nICFP 12, pages 15 16. ACM, 2012. [17] John Hughes. Generalising monads to arrows. Sci. Comput. Program., \n37(1-3):67 111, 2000. [18] Graham Hutton and Diana Fulger. Reasoning about effects: Seeing the wood through \nthe trees. In Proceedings of the Ninth Symposium on Trends in Functional Programming, 2008. [19] Mauro \nJaskelioff. Monatron: An extensible monad transformer library. In Implementation and Application of Functional \nLanguages, volume 5836 of Lecture Notes in Computer Science, pages 233 248. Springer, 2011. [20] Mauro \nJaskelioff, Neil Ghani, and Graham Hutton. Modularity and implementation of mathematical operational \nsemantics. Electron. Notes Theor. Comput. Sci., 229(5):75 95, 2011. [21] Mark P. Jones and Luc Duponcheel. \nComposing monads. Research Report YALEU/DCS/RR-1004, Yale University, 1993. [22] Ohad Kammar, Sam Lindley, \nand Nicolas Oury. Handlers in action. In The 1st ACM SIGPLAN Workshop on Higher-Order Programming with \nEffects, HOPE 12, 2012. [23] Klein et al. sel4: formal veri.cation of an operating-system kernel. Commun. \nACM, 53(6):107 115, 2010. [24] Peter Lee. Realistic Compiler Generation. MIT Press, Cambridge, MA, 1989. \n[25] Xavier Leroy. Formal veri.cation of a realistic compiler. Commun. ACM, 52(7):107 115, 2009. [26] \nPaul Blain Levy. Monads and adjunctions for global exceptions. Electron. Notes Theor. Comput. Sci., 158:261 \n287, 2006. [27] Sheng Liang and Paul Hudak. Modular denotational semantics for compiler construction. \nIn Proceedings of the 6th European Symposium on Programming Languages and Systems, ESOP 96, pages 219 \n234. Springer-Verlag, 1996. [28] Sheng Liang, Paul Hudak, and Mark Jones. Monad transformers and modular \ninterpreters. In Proceedings of the 22nd ACM SIGPLAN-SIGACT symposium on Principles of programming languages, \nPOPL 95, pages 333 343. ACM, 1995. [29] Grant Malcolm. Algebraic Data Types and Program Transformation. \nPhD thesis, Rijksuniversiteit Groningen, September 1990. [30] Conor Mcbride and Ross Paterson. Applicative \nprogramming with effects. J. Funct. Program., 18(1):1 13, 2008. [31] Eugenio Moggi. An abstract view \nof programming languages. Techni\u00adcal Report ECS-LFCS-90-113, Edinburgh University, Department of Computer \nScience, June 1989. [32] Peter D. Mosses. A basic abstract semantic algebra. In Semantics of Data Types, \nvolume 173 of Lecture Notes in Computer Science, pages 87 107. Springer, 1984. [33] Peter D. Mosses. \nModular structural operational semantics. Journal of Logic and Algebraic Programming, 6061(0):195 228, \n2004. [34] Bruno C. d. S. Oliveira. Modular visitor components. In Proceedings of the 23rd European Conference \non Object-Oriented Programming, ECOOP 2009, pages 269 293. Springer-Verlag, 2009. [35] Bruno C. d. S. \nOliveira, Tom Schrijvers, and William R. Cook. Effec\u00adtiveAdvice: disciplined advice with explicit effects. \nIn Proceedings of the 9th International Conference on Aspect-Oriented Software Devel\u00adopment, AOSD 10, \npages 109 120. ACM, 2010. [36] Frank Pfenning and Christine Paulin-Mohring. Inductively de.ned types \nin the calculus of constructions. In Mathematical Foundations of Programming Semantics, volume 442 of \nLecture Notes in Computer Science, pages 209 228. Springer-Verlag, 1990. [37] Benjamin C. Pierce. Types \nand Programming Languages. MIT Press, 2002. [38] Gordon Plotkin and Matija Pretnar. Handlers of algebraic \neffects. In Programming Languages and Systems: 18th European Symposium on Programming, ESOP 2009, volume \n5502 of Lecture Notes in Com\u00adputer Science, pages 80 94. Springer, 2009. [39] Gordon D. Plotkin and John \nPower. Notions of computation determine monads. In Proceedings of the 5th International Conference on \nFoun\u00addations of Software Science and Computation Structures, FoSSaCS 02, pages 342 356. Springer-Verlag, \n2002. [40] John C. Reynolds. Types, abstraction and parametric polymorphism. In IFIP Congress, pages \n513 523, 1983. [41] Tom Schrijvers and Bruno C. d. S. Oliveira. Monads, zippers and views: virtualizing \nthe monad stack. In Proceedings of the 16th ACM SIGPLAN international conference on Functional programming, \nICFP 11, pages 32 44. ACM, 2011. [42] Tom Schrijvers and Bruno C. d. S. Oliveira. The monad zipper. Report \nCW 595, Dept. of Computer Science, K.U.Leuven, 2010. [43] Zhong Shao. Certi.ed software. Commun. ACM, \n53(12):56 66, 2010. [44] Antonis Stampoulis and Zhong Shao. Veriml: typed computation of logical terms \ninside a language with effects. In Proceedings of the 15th ACM SIGPLAN international conference on Functional \nprogramming, ICFP 10, pages 333 344. ACM, 2010. [45] Guy L. Steele, Jr. Building interpreters by composing \nmonads. In Proceedings of the 21st ACM SIGPLAN-SIGACT symposium on Prin\u00adciples of programming languages, \nPOPL 94, pages 472 492. ACM, 1994. [46] Wouter Swierstra. Data types a`la carte. J. Funct. Program., \n18(4):423 436, 2008. [47] Tarmo Uustalu and Varmo Vene. Coding recursion a la Mendler. `In Proceedings \n2nd Workshop on Generic Programming, WGP 00, pages 69 85, 2000. [48] Janis Voigtl \u00a8ander. Free theorems \ninvolving type constructor classes: functional pearl. In Proceedings of the 14th ACM SIGPLAN interna\u00adtional \nconference on Functional programming, ICFP 09, pages 173 184. ACM, 2009. [49] Philip Wadler. Theorems \nfor free! In Proceedings of the fourth international conference on Functional programming languages and \ncomputer architecture, FPCA 89, pages 347 359. ACM, 1989. [50] Philip Wadler. Monads for functional programming. \nIn Proceedings of the Marktoberdorf Summer School on Program Design Calculi, August 1992. [51] Philip \nWadler. The Expression Problem. Email, November 1998. Discussion on the Java Genericity mailing list. \n[52] Philip Wadler and Stephen Blott. How to make ad-hoc polymorphism less ad hoc. In Proceedings of \nthe 16th ACM SIGPLAN-SIGACT sym\u00adposium on Principles of programming languages, POPL 89, pages 60 76. \nACM, 1989. [53] Andrew K. Wright and Matthias Felleisen. A syntactic approach to type soundness. Information \nand Computation, 115(1):38 94, 1994.    \n\t\t\t", "proc_id": "2500365", "abstract": "<p>This paper presents 3MT, a framework for modular mechanized meta-theory of languages with effects. Using 3MT, individual language features and their corresponding definitions -- semantic functions, theorem statements and proofs-- can be built separately and then reused to create different languages with fully mechanized meta-theory. 3MT combines modular datatypes and monads to define denotational semantics with effects on a per-feature basis, without fixing the particular set of effects or language constructs.</p> <p>One well-established problem with type soundness proofs for denotational semantics is that they are notoriously brittle with respect to the addition of new effects. The statement of type soundness for a language depends intimately on the effects it uses, making it particularly challenging to achieve modularity. 3MT solves this long-standing problem by splitting these theorems into two separate and reusable parts: a feature theorem that captures the well-typing of denotations produced by the semantic function of an individual feature with respect to only the effects used, and an effect theorem that adapts well-typings of denotations to a fixed superset of effects. The proof of type soundness for a particular language simply combines these theorems for its features and the combination of their effects. To establish both theorems, 3MT uses two key reasoning techniques: modular induction and algebraic laws about effects. Several effectful language features, including references and errors, illustrate the capabilities of 3MT. A case study reuses these features to build fully mechanized definitions and proofs for 28 languages, including several versions of mini-ML with effects.</p>", "authors": [{"name": "Benjamin Delaware", "author_profile_id": "81414620111", "affiliation": "University of Texas at Austin, Austin, TX, USA", "person_id": "P4261268", "email_address": "bendy@cs.utexas.edu", "orcid_id": ""}, {"name": "Steven Keuchel", "author_profile_id": "83058751057", "affiliation": "Ghent University, Ghent, Belgium", "person_id": "P4261269", "email_address": "steven.keuchel@ugent.be", "orcid_id": ""}, {"name": "Tom Schrijvers", "author_profile_id": "81100049265", "affiliation": "Ghent University, Ghent, Belgium", "person_id": "P4261270", "email_address": "tom.schrijvers@ugent.be", "orcid_id": ""}, {"name": "Bruno C.d.S. Oliveira", "author_profile_id": "81310493622", "affiliation": "The University of Hong Kong, Hong Kong, Hong Kong", "person_id": "P4261271", "email_address": "bruno@cs.hku.hk", "orcid_id": ""}], "doi_number": "10.1145/2500365.2500587", "year": "2013", "article_id": "2500587", "conference": "ICFP", "title": "Modular monadic meta-theory", "url": "http://dl.acm.org/citation.cfm?id=2500587"}