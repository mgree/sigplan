{"article_publication_date": "09-25-2013", "fulltext": "\n Programming and Reasoning with Algebraic Effects and Dependent Types Edwin Brady School of Computer \nScience, University of St Andrews, St Andrews, Scotland. Email: ecb10@st-andrews.ac.uk Abstract One \noften cited bene.t of pure functional programming is that pure code is easier to test and reason about, \nboth formally and infor\u00admally. However, real programs have side-effects including state management, exceptions \nand interactions with the outside world. Haskell solves this problem using monads to capture details \nof pos\u00adsibly side-effecting computations it provides monads for captur\u00ading state, I/O, exceptions, non-determinism, \nlibraries for practical purposes such as CGI and parsing, and many others, as well as monad transformers \nfor combining multiple effects. Unfortunately, useful as monads are, they do not compose very well. Monad \ntransformers can quickly become unwieldy when there are lots of effects to manage, leading to a temptation \nin larger programs to combine everything into one coarse-grained state and exception monad. In this paper \nI describe an alternative approach based on handling algebraic effects, implemented in the IDRIS programming \nlanguage. I show how to describe side effect\u00ading computations, how to write programs which compose multiple \n.ne-grained effects, and how, using dependent types, we can use this approach to reason about states \nin effectful programs. Categories and Subject Descriptors D.3.2 [Programming Lan\u00adguages]: Language Classi.cations \nApplicative (functional) Lan\u00adguages General Terms Languages, Veri.cation Keywords Dependent Types, Algebraic \nEffects 1. Introduction Pure functions do not have side effects, but real applications do: they may have \nstate, communicate across a network, read and write .les, or interact with users, among many other things. \nFurthermore, real systems may fail due to corrupted or untrusted data. Pure functional programming languages \nsuch as Haskell [26] manage such problems using monads [31], and allow multiple effects to be combined \nusing a stack of monad transformers [17]. Monad transformers are an effective tool for structuring larger \nHaskell applications. An application using a Read-Execute-Print loop, for example, may have some global \nstate and perform console Permission to make digital or hard copies of all or part of this work for personal \nor classroom use is granted without fee provided that copies are not made or distributed for pro.t or \ncommercial advantage and that copies bear this notice and the full citation on the .rst page. Copyrights \nfor components of this work owned by others than the author(s) must be honored. Abstracting with credit \nis permitted. To copy otherwise, or republish, to post on servers or to redistribute to lists, requires \nprior speci.c permission and/or a fee. Request permissions from permissions@acm.org. ICFP 13, September \n25 27, 2013, Boston, MA, USA. Copyright is held by the owner/author(s). Publication rights licensed to \nACM. ACM 978-1-4503-2326-0/13/09. . . $15.00. http://dx.doi.org/10.1145/2500365.2500581 I/O, and hence \nbe built with an IO monad transformed into a state monad using the StateT transformer. However, this \ncan create dif.culties: the order in which transformers are applied matters (that is, transformers do \nnot commute easily); and it is dif.cult to invoke a function which uses a subset of the transformers \nin the stack. To illustrate these problems, consider an evaluator, in Haskell, for a simple expression \nlanguage: data Expr = Val Int | Add Expr Expr eval : Expr -> Int eval (Val i) = i eval (Add x y) = eval \nx + eval y If we extend this language with variables, we need to extend the evaluator with an environment, \nand deal with possible failure if a variable is unde.ned (we omit the Val and Add cases): data Expr = \nVal Int | Add Expr Expr | Var String type Env = [(String, Int)] eval :: Expr -> ReaderT Env Maybe Int \n eval (Var x) = do env <-ask lift (lookup x env) Here, the Maybe monad captures possible failure, and \nis trans\u00adformed into a reader monad using the ReaderT transformer to store the environment, which is \nretrieved using ask. The lift operation allows functions in the inner Maybe monad to be called. We can \nextend the language further, with random number generation: data Expr = Val Int | Add Expr Expr | Var \nString | Random Int eval :: Expr -> RandT (ReaderT Env Maybe) Int eval (Var x) = do env <-lift ask \n lift (lift (lookup x env)) eval (Random x) = getRandomR (0, x) We have added another transformer to \nthe stack, RandT, and added lift where necessary to access the appropriate monads in the stack. We have \nbuilt this interpreter from reusable components, the Maybe monad and ReaderT and RandT transformers, \nwhich is clearly a good thing. A problem, however, is that the use of lift is a little noisy, and will \nonly get worse if we add more monads to the stack, such as IO. Bigger problems occur if we need to permute \nthe order of the transformers, or invoke a function which uses a subset: permute :: ReaderT Env (RandT \nMaybe) a -> RandT (ReaderT Env Maybe) a dropReader :: RandT Maybe a -> RandT (ReaderT Env Maybe) a These \nproblems mean that, in general, there is little motivation for separating effects, and a temptation to \nbuild an application around one general purpose monad capturing all of an application s state and exception \nhandling needs. This is undesirable, as it limits reuse and hinders modular design. It would be desirable \ninstead to be able to separate effects into speci.c modular components such as console I/O, .le and network \nhandling and operating system interaction, for the same reason that it is desirable to separate the pure \nfragments of a program from the impure fragments using the IO monad. That is, the program s type would \ngive more precise information about its behaviour, making the program easier to reason about and reducing \nthe possibility of errors.  In this paper, I present an alternative approach to combining ef\u00adfects in \na pure functional programming language, based on handlers of algebraic effects [3], and implemented directly \nas a domain spe\u00adci.c language embedded in a dependently typed host, I DRIS [4, 5]. 1.1 Contributions \nThis paper takes as its hypothesis that algebraic effects provide a cleaner, more composable and more \n.exible notation for program\u00adming with side effects than monad transformers. Although they are not equivalent \nin power (for example, unlike algebraic effects, mon\u00adads can express continuations) many common side-effects \nare cap\u00adtured. The main contribution of this paper is a notation for describ\u00ading and combining side effects \nusing IDRIS. More speci.cally: An Embedded Domain Speci.c Language (DSL), Effects, for capturing algebraic \neffects, in such a way that they are easily composable, and translatable to a variety of underlying contexts \nusing effect handlers.  A collection of example effects (State, Exceptions, File and Console I/O, random \nnumber generation and non-determinism) and their handlers. I show how alternative handlers can be used \nto evaluate effects in different contexts, for example using an alternative handler to run interactive \nprograms in a pure context.  I give example programs which combine effects, including an interpreter \nfor an imperative language with mutable variables, to illustrate how effectful applications may be structured. \n The Effects DSL makes essential use of dependent types, .rstly to verify that a speci.c effect is available \nto an effectful program using simple automated theorem proving, and secondly to track the state of a \nresource by updating its type during program execution. In this way, we can use the Effects DSL to verify \nimplementa\u00adtions of resource usage protocols. I describe how to use Effects in Section 2, how it is imple\u00admented \nin Section 3, and give a larger example in Section 4. It is distributed with I DRIS1. All of the examples \nin this paper are avail\u00adable online at http://idris-lang.org/effects. 2. Effects: an Embedded DSL for \nEffects Management In this section, I introduce Effects, an embedded domain speci.c language for managing \ncomputational effects in I DRIS. I will intro\u00adduce speci.c features of I DRIS as required. In particular, \nwe will use implicit conversions and default implicit arguments in the im\u00adplementation of Effects. A \nfull tutorial is available elsewhere [5]. First, I describe how to use effects which are already de.ned \nin the language in order to implement the evaluator described in the introduction. Then, I show how new \neffects may be implemented. The framework consists of a DSL representation Eff for com\u00adbining effects, \nEffM for combining mutable effects, and implemen\u00adtations of several prede.ned effects. We refer to the \nwhole frame\u00adwork with the name Effects. 1http://idris-lang.org/ 2.1 Programming with Effects Programs \nin the Effects language are described using the follow\u00ading data type, in the simplest case (I will defer \nintroducing the con\u00adtructors until later): Eff : (m : Type -> Type) -> (es : List EFFECT) -> (a : Type) \n-> Type Note that function types in I DRIS take the form (x : a) -> b, with an optional name x on the \ndomain of the function. This is primarily to allow the name x to be used in the codomain, although it \nis also useful for documenting the purpose of an argument. Eff is parameterised over a computation context, \nm, which de\u00adscribes the context in which the effectful program will be run, a list of side effects es \nthat the program is permitted to use, and the program s return type a. The name m for the computation \ncontext is suggestive of a monad, but there is no requirement for it to be so. Side effects are described \nusing the EFFECT type; we will refer to these as concrete effects. For example: STATE : Type -> EFFECT \n EXCEPTION : Type -> EFFECT FILEIO : Type -> EFFECT STDIO : EFFECT RND : EFFECT States are parameterised \nby the type of the state being carried, and exceptions are parameterised by a type representing errors. \nFile I/O allows a single .le to be processed, with the type giving the current state of the .le (i.e. \nclosed, open for reading, or open for writing). Finally, STDIO and RND permit console I/O and random \nnumber generation respectively. For example, a program with some integer state, which performs console \nI/O and which could throw an exception of type Error might have the following type: example : Eff IO \n[EXCEPTION Error, STDIO, STATE Int] () More generally, a program might modify the set of effects available, \nfor example when adding a new effect or updating a dependently typed state. In this case, we describe \nprograms using EffM: EffM : (m : Type -> Type) -> (es : List EFFECT) -> (es : List EFFECT) -> (a : Type) \n-> Type EffM is parameterised over the context and type as before, but separates input effects (es) \nfrom output effects (es ). In fact, Eff is de.ned in terms of EffM, with equal input/output effects. \nWe adopt the convention that the names es and fs refer to a list of input effects, and es and fs refer \nto a list of output effects. 2.1.1 First example: State In general, an effectful program implemented \nin the EffM structure has the look and feel of a monadic program in Haskell, since EffM supports do-notation. \nTo illustrate basic usage, let us implement a stateful function, which tags each node in a binary tree \nwith a unique integer, depth .rst, left to right. We declare trees as follows: data Tree a = Leaf | Node \n(Tree a) a (Tree a) To tag each node in the tree, we write an effectful program which, for each node, \ntags the left subtree, reads and updates the state, tags the right subtree, then returns a new node with \nits value tagged. The type expresses that the program requires an integer state: tag : Tree a -> Eff \nm [STATE Int] (Tree (Int, a)) The implementation traverses the tree, using get and put to ma\u00adnipulate \nstate:  tag Leaf = return Leaf tag (Node l x r) = do l <-tag l lbl <-get; put (lbl + 1) r <-tag \nr return (Node l (lbl, x) r ) The Effects system ensures, statically, that any effectful functions \nwhich are called (get and put here) require no more effects than are available. The types of these functions \nare: get : Eff m [STATE x] x put : x -> Eff m [STATE x] () Each effect is associated with a resource. \nFor example, the resource associated with STATE Int is the integer state itself. To run an effectful \nprogram, we must create a list of resources corresponding to the list of supported effects, and instantiate \nm. Here we instantiate m with id, resulting in a pure function. tagFrom : Int -> Tree a -> Tree (Int, \na) tagFrom x t = runPure [x] (tag t) In general, to run an effectful program, we use one of the func\u00adtions \nrun, runWith or runPure, instantiating an environment with resources corresponding to each effect: run \n: Applicative m => Env m es -> EffM m es es a -> m a runWith : (a -> m a) -> Env m es -> EffM m es \nes a -> m a runPure : Env id es -> EffM id es es a -> a Corresponding functions runEnv, runWithEnv \nand runPureEnv also return the .nal resources. The reason run needs m to be an applicative functor is \nthat it uses pure to inject a pure value into m. If this is inconvenient, runWith can be used. Note that \nthere is no requirement that m is a monad; any type transformer is .ne. In particular, id can be used \nto translate an effectful program into a pure function. As we will see, the particular choice of m can \nbe important. Programs with exceptions, for example, can be run in the context of IO, Maybe or Either. \nWe will return to the de.nition of Env in Section 3.2. For now, it suf.ces to know that it is a heterogeneous \nlist of values for the initial resources es.  2.1.2 Labelled Effects When we invoke an effect, Effects \ninternally searches the list of available effects to check it is supported, and invokes the effect using \nthe corresponding resource. This leads to an important ques\u00adtion: what if we have more than one effect \nwhich supports the func\u00adtion? A particular situation where this arises is when we have more than one \ninteger state. For example, to count the number of Leaf nodes in a tree while tagging nodes, we will \nneed two integer states: tagCount : Tree a -> Eff m [STATE Int, STATE Int] (Tree (Int, a)) What should \nbe the effect of get and put in this program? Which effect do they act on? In practice, the earlier effect \nis chosen. While clearly de.ned, this is unlikely to be the desired behaviour, so to avoid this problem, \neffects may also be labelled using the ::: operator. A label can be of any type, and an effect can be \nconverted into a labelled effect using the :-operator: (:::) : lbl -> EFFECT -> EFFECT (:-) : (l : lbl) \n-> EffM m [x] [y] t -> EffM m [l ::: x] [l ::: y] t In order to implement tagCount now, .rst we de.ne \na type for the labels. We have one state variable representing the leaf count, and one representing the \ncurrent tag: data Vars = Count | Tag Then, we use these labels to disambiguate the states. To increment \nthe count at each leaf, we use update, which combines a get and a put by applying a function to the state: \ntagCount : Tree a -> Eff m [Tag ::: STATE Int, Count ::: STATE Int] (Tree (Int, a)) tagCount Leaf = \ndo Count :-update (+1) return Leaf tagCount (Node l x r) = do l <-tagCount l lbl <-Tag :-get Tag \n:-put (lbl + 1) r <-tagCount r return (Node l (lbl, x) r ) In order to retrieve the count afterwards, \nwe will need access to the environment after running tagCount. We use runPureEnv, which returns the .nal \nresource states as well as the result: runPureEnv : Env id xs -> EffM id xs xs a -> (Env id xs , a) \nTo initialise the environment, we give the label name along with the initial value of the resource (where \n:= initialises a label). The order is important here, since resources are initialised in the order given \nby the list of supported effects. runPureEnv [Tag := 0, Count := 0] (tagCount t) And .nally, to implement \na pure wrapper function which returns a pair of the count of leaves and a labelled tree, we call runPureEnv \nwith the initial resources, and match on the returned resources to retrieve the leaf count: tagCountFrom \n: Int -> Tree a -> (Int, Tree (Int, a)) tagCountFrom x t = let ([_, Count := leaves], tree) = runPureEnv \n[Tag := 0, Count := 0] (tagCount t) in (leaves, tree)  2.1.3 An Effectful Evaluator revisited To implement \nthe effectful evaluator from the introduction in Effects, we support exceptions, random numbers and an \nenvi\u00adronment mapping from String to Int: Vars : Type Vars = List (String, Int) The evaluator invokes \nsupported effects where needed. We use the following effectful functions: get : Eff m [STATE x] x raise \n: a -> Eff m [EXCEPTION a] b rndInt : Int -> Int -> Eff m [RND] Int The evaluator itself is written \nas an instance of Eff: eval : Expr -> Eff m [EXCEPTION String, RND, STATE Vars] t The implementation \nsimply invokes the required effects with Effects checking that they are available: eval (Val x) = return \nx eval (Var x) = do vs <-get case lookup x vs of Nothing => raise (\"Error \" ++ x) Just val => return \nval eval (Add l r) = [| eval l + eval r |] eval (Random upper) = rndInt 0 upper  Remark: We have \nused idiom brackets [20] in this implementation, to give a more concise notation for applicative programming \nwith effects. An application inside idiom brackets, [| f a b c d |] translates directly to: pure f <$> \na <$> b <$> c <$> d In order to run this evaluator, we must provide initial values for the resources \nassociated with each effect. Exceptions require the unit resource, random number generation requires \nan initial seed, and the state requires an initial environment. We instantiate m with Maybe to be able \nto handle exceptions: runEval : List (String, Int) -> Expr -> Maybe Int runEval env expr = run [(), 123456, \nenv] (eval expr) Extending the evaluator with a new effect, such as STDIO is a matter of extending the \nlist of available effects in its type. We could use this, for example, to print out the generated random \nnumbers: eval : Expr -> Eff m [EXCEPTION String, STDIO, RND, STATE Vars] t ... eval (Random upper) \n= do num <-rndInt 0 upper putStrLn (show num) return num We can insert the STDIO effect anywhere in \nthe list without dif.\u00adculty. The only requirements are that its initial resource is in the corresponding \nposition in the call to run, and that run instantiates a context which supports STDIO, such as IO: runEval \n: List (String, Int) -> Expr -> IO Int runEval env expr = run [(), (), 123456, env] (eval expr)  \n 2.2 Implementing effects In order to implement a new effect, we de.ne a new type (of kind Effect)and \nexplain how that effect is interpreted in some under\u00adlying context m. An Effect describes an effectful \ncomputation, pa\u00adrameterised by an input resource res, an output resource res , and the type of the computation \nt. Effect : Type Effect = (res : Type) -> (res : Type) -> (t : Type) -> Type We describe effects as \nalgebraic data types. To run an effect, we re\u00adquire an interpretation in a computation context m. To \nachieve this, we make effects and contexts instances of a type class, Handler, which has a method handle \nexplaining this interpretation: class Handler (e : Effect) (m : Type -> Type) where handle : res -> (eff \n: e res res t) -> (res -> t -> m a) -> m a Type classes in IDRIS may be parameterised by anything. This \nmeans not only types, but also values, and even other type classes. Thus, if a parameter is anything \nother than a Type, it must be given a type label explicitly, like e and m here. Handlers are parameterised \nby the effect they handle, and the context in which they handle the effect. This allows several differ\u00adent \ncontext-dependent handlers to be written, e.g. exceptions could be handled differently in an IO setting \nthan in a Maybe setting. When effects are combined, as in the evaluator example, all effects must be \nhandled in the context in which the program is run. An effect e res res t updates a resource type res \nto a re\u00adsource type res , returning a value t. The handler, therefore, im\u00adplements this update in a context \nm which may support side effects. The handler is written in continuation passing style. This is for two \nreasons: .rstly, it returns two values, a new resource and the result of the computation, which is more \ncleanly managed in a contin\u00aduation than by returning a tuple; secondly, and more importantly, it gives \nthe handler the .exibility to invoke the continuation any number of times (zero or more). An Effect, \nwhich is the internal algebraic description of an effect, is promoted into a concrete EFFECT, which is \nexpected by the EffM structure, with the MkEff constructor: data EFFECT : Type where MkEff : Type -> \nEffect -> EFFECT MkEff additionally records the resource state of an effect. In the remainder of this \nsection, we describe how several effects can be implemented in this way: mutable state; console I/O; \nexceptions; .les; random numbers, and non-determinism. 2.2.1 State In general, effects are described \nalgebraically in terms of the oper\u00adations they support. In the case of State, the supported effects are \nreading the state (Get) and writing the state (Put). data State : Effect where Get : State a a a Put \n: b -> State a b () The resource associated with a state corresponds to the state itself. So, the Get \noperation leaves this state intact (with a resource type a on entry and exit) but the Put operation may \nupdate this state (with a resource type a on entry and b on exit). That is, a Put may update the type \nof the stored value. We can implement a handler for this effect, for all contexts m, as follows: instance \nHandler State m where handle st Get k = k st st handle st (Put n) k = k n () When running Get, the \nhandler passes the current state to the continuation as both the new resource value (the .rst argument \nof the continuation k)as well as the return value of the computation (the second argument of the continuation). \nWhen running Put, the new state is passed to the continuation as the new resource value. We then convert \nthe algebraic effect State to a concrete effect usable in an Effects program using the STATE function, \nto which we provide the initial state type as follows: STATE : Type -> EFFECT STATE t = MkEff t State \n We adopt the convention that algebraic effects, of type Effect, have an initial upper case letter. Concrete \neffects, of type EFFECT, are correspondingly in all upper case. Algebraic effects are promoted to Effects \nprograms with con\u00adcrete effects by using the mkEffect function. We will postpone giving the type of mkEffect \nuntil Section 3.1.2. For now, it suf\u00ad.ces to know that it converts an Effect to an effectful program. \nTo create the get and put functions, for example: get : Eff m [STATE x] x get = mkEffect Get put : x \n-> Eff m [STATE x] () put val = mkEffect (Put val) We may also .nd it useful to mutate the type of a \nstate, considering that states may themselves have dependent types (we may, for example, add an element \nto a vector in a state). The Put constructor supports this, so we can implement putM to update the state \ns type: putM : y -> EffM m [STATE x] [STATE y] () putM val = mkEffect (Put val)  Finally, it may be \nuseful to combine get and put in a single update: update : (x -> x) -> Eff m [STATE x] () update f = \ndo val <-get; put (f val)  2.2.2 Console I/O Consider a simpli.ed version of console I/O which supports \nread\u00ading and writing strings. There is no associated resource, although in an alternative implementation \nwe may associate it with an abstract world state, or a pair of handles for stdin/stdout. Algebraically: \ndata StdIO : Effect where PutStr : String -> StdIO () () () GetStr : StdIO () () String STDIO : EFFECT \nSTDIO = MkEff () StdIO The obvious way to handle StdIO is via the IO monad: instance Handler StdIO IO \nwhere handle () (PutStr s) k = do putStr s; k () () handle () GetStr k = do x <-getLine; k () x Unlike \nthe State effect, for which the handler worked in all con\u00adtexts, this handler only applies to effectful \nprograms run in an IO context. We can implement alternative handlers, and indeed there is no reason that \neffectful programs in StdIO must be evaluated in a monadic context. For example, we can de.ne I/O stream \nfunctions: data IOStream a = MkStream (List String -> (a, List String)) instance Handler StdIO IOStream \nwhere ... A handler for StdIO in IOStream context generates a function from a list of strings (the input \ntext) to a value and the output text. We can build a pure function which simulates real console I/O: \nmkStrFn : Env IOStream xs -> Eff IOStream xs a -> List String -> (a, List String) mkStrFn {a} env p \ninput = case mkStrFn of MkStream f => f input where injStream : a -> IOStream a injStream v = MkStream \n(\\x => (v, [])) mkStrFn : IOStream a mkStrFn = runWith injStream env p To illustrate this, we write \na simple console I/O program which runs in any context which has a handler for StdIO: name : Handler \nStdIO e => Eff e [STDIO] () name = do putStr \"Name? \" n <-getStr putStrLn (\"Hello \" ++ show n) Using \nmkStrFn, we can run this as a pure function which uses a list of strings as its input, and gives a list \nof strings as its output. We can evaluate this at the I DRIS prompt: *name> show $ mkStrFn [()] name \n[\"Edwin\"] ((), [\"Name?\" , \"Hello Edwin\\n\"]) This suggests that alternative, pure, handlers for console \nI/O, or any I/O effect, can be used for unit testing and reasoning about I/O programs without executing \nany real I/O. 2.2.3 Exceptions The exception effect supports only one operation, Raise. Excep\u00adtions \nare parameterised over an error type e, so Raise takes a single argument to represent the error. The \nassociated resource is of unit type, and since raising an exception causes computation to abort, raising \nan exception can return a value of any type. data Exception : Type -> Effect where Raise : e -> Exception \ne () () b EXCEPTION : Type -> EFFECT EXCEPTION e = MkEff () (Exception e) The semantics of Raise is \nto abort computation, therefore handlers of exception effects do not call the continuation k. In any \ncase, this should be impossible since passing the result to the continuation would require the ability \nto invent a value in any arbitrary type b! The simplest handler runs in a Maybe context: instance Handler \n(Exception a) Maybe where handle _ (Raise err) k = Nothing Exceptions can be handled in any context \nwhich supports some representation of failed computations. In an Either e context, for example, we can \nuse Left to represent the error case: instance Handler (Exception e) (Either e) where handle _ (Raise \nerr) k = Left err Given that we can raise exceptions in an Effects program, it is also useful to be \nable to catch them. The catch operation runs a possibly failing computation comp in some context m: catch \n: Catchable m err => (comp : EffM m xs xs a) -> (handler : err -> EffM m xs xs a) -> EffM m xs xs a \nUsing catch requires that the computation context m supports throwing and catching of errors, using the \nCatchable class im\u00adplemented as part of the I DRIS library: class Catchable (m : Type -> Type) t where \nthrow : t -> m a catch : m a -> (t -> m a) -> m a This is implemented directly as part of the Effects \nDSL. There is a simple instance for Maybe, limited to the unit error: instance Catchable Maybe () where \nthrow () = Nothing catch Nothing h = h () catch (Just x) h = Just x The Either e instance allows that \nany type be thrown as an error: instance Catchable (Either e) e where throw x = Left x catch (Left err) \nh = h err catch (Right x) h = (Right x)  2.2.4 Random numbers Random number generation can be implemented \nas an effect, with the resource tracking the seed from which the next number will be generated. The Random \neffect supports one operation, getRandom, which requires an Int resource and returns the next number: \ndata Random : Type -> Type -> Type -> Type where GetRandom : Random Int Int Int RND : EFFECT RND = MkEff \nInt Random Handling random number generation shows that it is a state effect in disguise, where the \neffect updates the seed. This is a simple linear congruential pseudo-random number generator: instance \nHandler Random m where handle seed GetRandom k = let seed = 1664525 * seed + 1013904223 in k seed seed \n  Alternative handlers could use a different, possibly more secure approach. In any case, we can implement \na function which returns a random number between a lower and upper bound as follows: rndInt : Int -> \nInt -> Eff m [RND] Int rndInt lower upper = do v <-mkEffect GetRandom return (v mod (upper -lower) + \nlower)  2.2.5 Resource management: Files Instead of implementing all I/O operations as a single effect, \nas with the IO monad, we can separate operations into more .ne\u00adgrained effects. Another I/O related effect \nwhich we can handle separately is .le management. Here, we can take advantage of the resource associated \nwith an effect, and the fact that resource types are mutable, by associating the effect with a .le handle \nparameterised by its current state (i.e. closed, open for reading, or open for writing). File handles \nare represented as follows, where File is a primitive .le handle provided by the IDRIS library: data \nMode = Read | Write data OpenFile : Mode -> Type where FH : File -> OpenFile m When we declare FileIO, \nwe express in the resource transitions how each effect changes the state of the resource: data FileIO \n: Effect where Open : FilePath -> (m : Mode) -> FileIO () (OpenFile m) () Close : FileIO (OpenFile \nm) () () ReadLine : FileIO (OpenFile Read) (OpenFile Read) String WriteLine : String -> FileIO (OpenFile \nWrite) (OpenFile Write) () EOF : FileIO (OpenFile Read) (OpenFile Read) Bool We can see from this \ndeclaration that opening a .le moves from an empty resource to a .le open for a speci.c purpose and that \nclosing a .le removes the .le resource. Only .les which are open for reading may be read, or tested for \nend of .le, and only .les open for writing may be written to. Any violation of this resource access protocol \nwill result in a type error. In general, we can use the effect signature of a function to manage resources \nsafely, subsuming the resource management DSL we have previously implemented [9]. The FILE IO effect \nis parameterised over the current state of a .le resource with which it is associated: FILE_IO : Type \n-> EFFECT The type of open expresses that the resource changes from a unit to an open .le: open : FilePath \n-> (m : Mode) -> EffM IO [FILE_IO ()] [FILE_IO (OpenFile m)] () Note that opening a .le may fail. We \nwill deal with such excep\u00adtional behaviour shortly. Using EffM, we have expressed that open\u00ading a .le \ncauses a change in the resource state. It is then only pos\u00adsible to close a .le if there is an open .le \navailable: close : EffM IO [FILE_IO (OpenFile m)] [FILE_IO ()] () Reading is only possible from a .le \nopened for reading: readLine : Eff IO [FILE_IO (OpenFile Read)] String As with STATE, we can use labelled \nresources if we require more than one .le handle at a time. We have handlers for FileIO for the IO context, \nwhich does not handle exceptions (in which case failing to open a .le is a fatal run-time error), and \nan IOExcept e context which is IO augmented with exceptions of type e and an instance of the Catchable \nclass: data IOExcept err a ioe_lift : IO a -> IOExcept err a instance Catchable IOExcept err Assuming \nwe are in a state where we have a .le handle available and open for reading, we can read the contents \nof a .le into a list of strings: readLines : Eff (IOExcept String) [FILE_IO (OpenFile Read)] (List String) \nreadLines = readAcc [] where readAcc : List String -> Eff (IOExcept String) [FILE_IO (OpenFile Read)] \n(List String) readAcc acc = do e <-eof if (not e) then do str <-readLine readAcc (str :: acc) else return \n(reverse acc) To read a .le, given a .le path, into a list of strings, reporting an error where necessary, \nwe can write the following readFile function. We add STDIO to the list of effects so that we can report \nan error to the console if opening the .le fails: readFile : FilePath -> Eff (IOExcept String) [FILE_IO \n(), STDIO] (List String) readFile path = catch (do open path Read lines <-readLines close return \nlines) (\\err => do putStrLn (\"Failed \" ++ err) return []) The effect type of readFile means that we \nmust begin and end with no open .le. This means that omitting the close would result in a compile time \ntype error. It would also be a type error to try to invoke readLines before the .le was open, or if the \n.le was opened for writing instead.  2.2.6 Non-determinism Following [3], non-determinism can be implemented \nas an effect Selection, in which a Select operation chooses one value non\u00addeterministically from a list \nof possible values: data Selection : Effect where Select : List a -> Selection () () a We can handle \nthis effect in a Maybe context, trying every choice in a list given to Select until the computation succeeds: \ninstance Handler Selection Maybe where handle _ (Select xs) k = tryAll xs where tryAll [] = Nothing \n tryAll (x :: xs) = case k () x of Nothing => tryAll xs Just v => Just v The handler for Maybe produces \nat most one result, effectively performing a depth .rst search of the values passed to Select. The handler \nruns the continuation for every element of the list until the result of running the continuation succeeds. \nAlternatively, we can .nd every possible result by handling selection in a List context: instance Handler \nSelection List where handle r (Select xs) k = concatMap (k r) xs We can use the Selection effect to \nimplement search problems by non-deterministically choosing from a list of candidate solutions.  For \nexample, a solution to the n-Queens problem can be imple\u00admented as follows. First, we write a function \nwhich checks whether a point on a chess board attacks another if occupied by a Queen: no_attack : (Int, \nInt) -> (Int, Int) -> Bool no_attack (x, y) (x , y ) = x /= x &#38;&#38; y /= y &#38;&#38; abs (x -x \n) /= abs (y -y ) Then, given a column and a list of Queen positions, we .nd the rows on which a Queen \nmay safely be placed in that column: rowsIn : Int -> List (Int, Int) -> List Int rowsIn col qs = [ x \n| x <-[1..8], all (no_attack (x, col)) qs ] Finally, we compute a solution by accumulating a set of \nQueen positions, column by column, non-deterministically choosing a po\u00adsition for a Queen in each column. \naddQueens : Int -> List (Int, Int) -> Eff m [SELECT] (List (Int, Int)) addQueens 0 qs = return qs \naddQueens col qs = do row <-select (rowsIn col qs) addQueens (col -1) ((row, col) :: qs) We can run \nthis in Maybe context, to retrieve one solution, or in List context, to retrieve all solutions. In a \nMaybe context, for example, we can de.ne: getQueens : Maybe (List (Int, Int)) getQueens = run [()] (addQueens \n8 []) Then to .nd the .rst solution, we run getQueens at the REPL: *Queens> show getQueens \"Just [(4, \n1), (2, 2), (7, 3), (3, 4), (6, 5), (8, 6), (5, 7), (1, 8)]\" : String Remark: It is important to note \nthat when combining SELECT with other effects, the values of other resources are reset at the begin\u00adning \nof each select branch. This means, at least in the current im\u00adplementation, that state cannot be shared \nbetween branches. While perhaps not so important for selection, this may be a problem for other control \neffects such as co-operative multithreading, for which we may need a more .exible handler if we wish \nto deal with shared state. We will deal with this issue in future work.  2.3 Effect Polymorphism Since \nEffects is implemented as an embedding in a host language, we can exploit features of the host language. \nThe means that we can write higher order functions, and functions which are poly\u00admorphic in their effects. \nFor example, a mapEff function can be implemented corresponding to fmap for functors: mapEff : Applicative \nm => (a -> Eff m xs b) -> List a -> Eff m xs (List b) mapEff f [] = pure [] mapEff f (x :: xs) = [| \nf x :: mapEff f xs |] This applies an effectful function across a list, provided that we are in an applicative \ncontext, and that the effectful function supports the correct set of effects. 3. The Effects DSL implementation \nThe implementation of Effects follows a common pattern in dependently typed DSL implementation, that \nof the well-typed interpreter [2, 6, 25]. We describe the DSL as a data type, EffM, which expresses the \nproperties a program must satisfy in its type, with a corresponding interpreter. The type system guarantees \nthat only programs which satisfy these properties can be interpreted. 3.1 Language representation The \nEffM data type represents the Effects language constructs. It is parameterised over its computation context \nm, and indexed by the list of effects on input and the list of effects on output, as well as the return \ntype of the computation: data EffM : (m : Type -> Type) -> (es : List EFFECT) -> (es : List EFFECT) \n-> (a : Type) -> Type For the common case of programs in which the input effects are the same as the \noutput effects, we de.ne Eff: Eff : (m : Type -> Type) -> (es : List EFFECT) -> (a : Type) -> Type \nEff m es t = EffM m es es t The complete syntax is given in Figure 1 for reference. In this section, \nwe describe the constructs in detail. Remark: One way of looking at EffM is as a .exible monad transformer, \naugmenting an underlying monad with additional fea\u00adtures. In this way we can combine algebraic effects \nwith concepts more dif.cult to capture, such as partiality and continuations. 3.1.1 Basic constructs \nIn the simplest case, we would like to inject pure values into the EffM representation: return : a -> \nEffM m es es a Additionally, we have (>>=) to support do notation: (>>=) : EffM m es es a -> (a -> EffM \nm es es b) -> EffM m es es b The type of (>>=) expresses that available effects may change, transitively, \nacross a program. The output of the .rst action, es becomes the input to the second. Remark: IDRIS allows \nad-hoc name overloading, as well as overloading via type classes. Since it does not support type infer\u00adence \nat the top level, as full type inference is undecidable for de\u00adpendently typed languages, such overloading \ncan be resolved in a type directed way. It is important here, since we cannot make EffM an instance of \nMonad, but we would like to use do-notation as a natural way of implementing imperative code.  3.1.2 \nInvoking effects Recall that an algebraic effect is promoted to an Effects program with the mkEffect \nfunction, the type of which has so far been post\u00adponed. We can invoke effects using a helper, mkEffectP, \nwhich requires a proof, prf, that the effect is available: mkEffectP : (prf : EffElem e a es) -> (eff \n: e a b t) -> EffM m es (updateResTy es prf eff) t If we are invoking an effect eff, provided by the \nalgebraic effect e, with an input resource type a, this is valid only if we can provide a proof that \nthe algebraic effect is present in the input set of resources es. This concept is captured in the EffElem \npredicate: data EffElem : (Type -> Type -> Type -> Type) -> Type -> List EFFECT -> Type where Here \n: EffElem x a (MkEff a x :: es) There : EffElem x a es -> EffElem x a (y :: es) This proof serves two \npurposes: it provides a guarantee that the effect is available with the correct resource type; and, as \nwe shall see shortly, it serves as an index into the resource set when we evaluate programs. After the \neffect has been handled, its resource type may have been updated. We must therefore update the output \n data EffM : (m : Type -> Type) -> List EFFECT -> List EFFECT -> Type -> Type where return : a -> EffM \nm es es a  (>>=) : EffM m es es a -> (a -> EffM m es es b) -> EffM m es es b mkEffectP : (prf : EffElem \ne a es) -> (eff : e a b t) -> EffM m es (updateResTy es prf eff) t liftP : (prf : SubList fs es) -> \nEffM m fs fs t -> EffM m es (updateWith fs es prf) t (:-) : (l : ty) -> EffM m [x] [y] t -> EffM m [l \n::: x] [l ::: y] t new : Handler e m => res -> EffM m (MkEff res e :: es) (MkEff res e :: es ) a -> \nEffM m es es a catch : Catchable m err => EffM m es es a -> (err -> EffM m es es a) -> EffM m es es \na Figure 1. The Effects DSL data type resource state in the type. Again, we use the structure of the \nproof, to update the resource type from a to b. updateResTy : (es : List EFFECT) -> EffElem e a es -> \ne a b t -> List EFFECT updateResTy {b} (MkEff a e :: es) Here n = (MkEff b e) :: es updateResTy (x :: \nes) (There p) n = x :: updateResTy es p n The problem with mkEffectP is that we must provide an explicit \nproof that the effect is available. Since the effect list is statically known, I DRIS ought to be able \nto .nd such a proof automatically. IDRIS currently has limited proof search, based on re.ection and rei.cation \nof programs, but it is suf.cient for constructing the required proofs. The re.ection mechanism itself \nis beyond the scope of this paper. Brie.y, we have the following function, which constructs a tactic \nfor searching for proofs of EffElem: findEffElem : Tactic Then, we have a notation for giving default \nimplicit arguments to functions. The mkEffect function is a wrapper for mkEffectP with a default argument \nwhich invokes the findEffElem tactic. If the proof search fails, this causes a compile time error, reporting \nthat the effect is not available. mkEffect : {default tactics { reflect findEffElem; } prf : EffElem \ne a es} -> (eff : e a b t) -> EffM m es (updateResTy es prf eff) t mkEffect {prf} e = mkEffectP prf \ne Fortunately, there is no need for a user of the library to know anything about this proof search mechanism. \nTactic construction for automated proof search is related to the Ltac [11] system in Coq, the intention \nbeing to make simple proofs automatable.  3.1.3 Effectful sub-programs As well as invoking algebraic \neffects directly, we would like to be able to invoke sub-programs, which may use all of the effects available, \nor a subset. To achieve this, we use the liftP construct: liftP : (prf : SubList fs es) -> (prog : EffM \nm fs fs t) -> EffM m es (updateWith fs es prf) t This requires a proof that the effects available to \nthe sub-program prog are a subset (strictly, a sub-list) of the effects available to the outer program, \nexpressed using the following predicate: data SubList : List a -> List a -> Type where SubNil : SubList \n[] [] Keep : SubList es fs -> SubList (x :: es) (x :: fs) Drop : SubList es fs -> SubList es (x :: \nfs) This predicate describes a sublist in terms of a larger list by saying, for each element of the \nlarger list, whether it is kept or dropped. An alternative base case could state that [] is a sub-list \nof any list, assuming that remaining items are dropped. The sub-program may itself update the effects \nit uses, so again the proof serves two purposes: Firstly, to ensure the effects are indeed available; \nand secondly, to be able to update the effects in the outer program once the sub-program is complete, \nas follows: updateWith : (fs : List a) -> (es : List a) -> SubList fs es -> List a updateWith (y :: fs) \n(x :: es) (Keep rest) = y :: updateWith fs es rest updateWith fs (x :: es) (Drop rest) = x :: updateWith \nfs es rest updateWith [] [] SubNil = [] Again, we can construct the necessary proofs of SubList automat\u00adically, \nif the sub-program uses a valid set of effects, because all effects are statically known, using a re.ected \ntactic findSubList. We implement a wrapper lift which builds this proof implicitly: implicit lift : \n{default tactics { reflect findSubList; } prf : SubList fs es} -> (prog : EffM m fs fs t) -> EffM \nm es (updateWith fs fs prf) t lift {prf} e = lift prf e The implicit modi.er before lift states that \nthis function can be used as an implicit conversion. Implicit conversions are inspired by a similar feature \nin Scala [24]. The effect of the implicit modi.er is, intuitively, that lift will be applied to a program \nin EffM if it is required for type correctness. Since type checking is type directed it always has access \nto the required type of an expression, and the implicit coercions which produce that type, so applying \nconversions is simple. Such conversions are, deliberately, limited. They cannot be chained, unlike implicit \ncoercions in Coq, to avoid coherence prob\u00adlems. Furthermore, to avoid ambiguity problems, if there is \nmore than one implicit conversion available then neither will be applied. In the Effects library, only \nlift is implicit. Remark: Using SubList as it is, rather than some notion of subset, means that in sub-programs \nthe effects must appear in the same order as they appear in the caller s effect list. This is not an \ninherent limitation; with improved proof search, we should also be able to support effect sets which \nare permutations of another. For the moment, to handle the (uncommon) case where permutations are needed, \nwe provide a permute operation, where Perm es fs is a proof that es is a permutation of fs, though we \nomit further details from the present paper. permute : Perm es fs -> Eff m fs t -> Eff m es t  3.1.4 \nLabelling effects If we have an effectful program p with a single effect, we can label that effect using \nthe (:-) operator: (:-) : (l : ty) -> EffM m [x] [y] t -> EffM m [l ::: x] [l ::: y] t  It is suf.cient \nto handle single effects here, because labels can only apply to one effect at a time, and such effectful \nsub-programs can easily be invoked using an implicit lift as described above. Labelling effects does \nnothing more than adding a label to the effect and its corresponding resource.  3.1.5 Introducing effects \nWe can introduce a new effect in the course of an effectful program, provided that the effect can be \nhandled in the current computation context m: new : Handler e m => res -> EffM m (MkEff res e :: es) \n(MkEff res e :: es ) a -> EffM m es es a This extends the list of effects, initialised with a resource \nof type res. Once the sub-program is complete, the resource for the new effect is discarded, as is clear \nfrom the type of new. The effect itself, e, is never given explicitly here, which means that it must \nbe clear from the sub-program what the effect is. Typically, this means that the sub-program will be \na function with an explicit type. 3.1.6 Handling failure Finally, if the computation context m supports \nfailure handling, we can use the catch construct to handle errors: catch : Catchable m err => (prog \n: EffM m es es a) -> (handler : err -> EffM m es es a) -> EffM m es es a If the sub-program prog fails \nwith an error, of type err, then the handler is called wth the error. Note that both prog and handler \ntransform the effect list from es to es . If prog fails, then the resources are reset to their starting \nstate. This requires some care, if the effect refers to external resources such as .le handles.  3.2 \nThe Effects interpreter Running an effectful program, of type EffM m es es t, should yield a computation \nof type m t, that is, the program returns a value of type t in some computation context m. We can interpret \nprograms through a traversal of the EffM syntax, subject to: Keeping track of resources corresponding \nto each effect.  Invoking the appropriate handlers where necessary.  Returning two values as part of \nthe computation: the result t and an updated collection resources.  To keep track of resources, we build \nan environment as a heteroge\u00adneous list to store the resource corresponding to each effect: data Env \n: (m : Type -> Type) -> List EFFECT -> Type where Nil : Env m Nil (::) : Handler eff m => a -> Env \nm es -> Env m (MkEff a eff :: es) Using the (overloaded) Nil and (::) gives us access to list syntax \nfor environments. They are parameterised over a computation con\u00adtext m, which allows an effect handler \ninstance to be associated with each entry. As a result EffM programs can be independent of con\u00adtext, \nthus interpretable in several contexts, and effects and hence their handlers can change during execution. \nSince we need to return two values, a result and an updated re\u00adsource collection, we implement the evaluator \nin continuation pass\u00ading style, with the two values passed to the continuation. This also helps when \ninvoking handlers, which also require a continuation. The interpreter has the following type: effInt \n: Env m es -> EffM m es es a -> (Env m es -> a -> m b) -> m b Effectful programs are invoked using a \nfunction of the following form, calling effInt with a continuation which simply discards the environment \nwhen evaluation is complete. run : Applicative m => Env m es -> EffM m es es a -> m a run env prog = \neffInt env prog (\\env, r => pure r) runPure : Env id es -> EffM id es es a -> a runPure env prog = \neffInt env prog (\\env, r => r) The full implementation of effInt is given for reference in Figure 2. \nThe interpreter uses a number of helpers in order to manage effects. Firstly, to invoke a handler given \na proof that an effect is available, we use execEff, de.ned as follows: execEff : Env m es -> (p : EffElem \ne res es) -> (eff : e res b a) -> (Env m (updateResTy es p eff) -> a -> m t) -> m t execEff (val \n:: env) Here eff k = handle val eff (\\res, v => k (res :: env) v) execEff (val :: env) (There p) eff \nk = execEff env p eff (\\env , v => k (val :: env ) v) The proof locates the effect and handler in the \nenvironment. Fol\u00adlowing the interpreter and the handlers, execEff is written in con\u00adtinuation passing \nstyle, and is used directly to execute effects: effInt env (mkEffectP prf effP) k = execEff env prf effP \nk Invoking a sub-program with a smaller collection of effects in\u00advolves dropping the unnecessary resources \nfrom the environment, invoking the sub-program, then rebuilding the environment rein\u00adstating the resources \nwhich were not used. We drop resources from an environment according to the SubList proof with dropEnv: \ndropEnv : Env m fs -> SubList es fs -> Env m es dropEnv [] SubNil = [] dropEnv (v :: vs) (Keep rest) \n= v :: dropEnv vs rest dropEnv (v :: vs) (Drop rest) = dropEnv vs rest Correspondingly, rebuildEnv rebuilds \nthe outer environment, up\u00addating the resources which were updated by the sub-programs: rebuildEnv : Env \nm fs -> (prf : SubList fs es) -> Env m es -> Env m (updateWith fs es prf) rebuildEnv [] SubNil env \n= env rebuildEnv (f :: fs) (Keep rest) (e :: env) = f :: rebuildEnv fs rest env rebuildEnv fs (Drop \nrest) (e :: env) = e :: rebuildEnv es rest env We can use dropEnv and rebuildEnv to interpret the execution \nof sub-programs, dropping resources before invoking, then rebuilding the environment before invoking \nthe continuation: effInt env (liftP prf effP) k = let env = dropEnv env prf in effInt env effP (\\envk, \np => k (rebuildEnv envk prf env) p ) To introduce a new effect using new, we simply extend the environ\u00adment \nwith the new resources before invoking the sub-program, and drop the extra resource before invoking the \ncontinuation: effInt env (new r prog) k = let env = r :: env in effInt env prog (\\ (v :: envk), p => \nk envk p )  effInt : Env m es -> EffM m es es a -> (Env m es -> a -> m b) -> m b effInt env (return \nx) k = k env x effInt env (prog >>= c) k = effInt env prog (\\env , p => effInt env (c p ) k) effInt env \n(mkEffectP prf effP) k = execEff env prf effP k effInt env (liftP prf effP) k = let env = dropEnv env \nprf in effInt env effP (\\envk, p => k (rebuildEnv envk prf env) p ) effInt env (new r prog) k = let \nenv = r :: env in effInt env prog (\\ (v :: envk), p => k envk p ) effInt env (catch prog handler) k = \ncatch (effInt env prog k) (\\e => effInt env (handler e) k) effInt env (l :-prog) k = let env = unlabel \nenv in effInt env prog (\\envk, p => k (relabel l envk) p ) Figure 2. The Effects DSL interpreter Interpreting \na catch involves using the catch method of the Catchable class. We rely on type directed overloading \nhere to disambiguate the catch: effInt env (catch prog handler) k = catch (effInt env prog k) (\\e => \neffInt env (handler e) k) Finally, to interpret a labelled effect, we remove the label, interpret the \nresulting effect as normal, then replace the label (unlabel and label have the obvious de.nitions, with \nunlabel removing a label from a singleton environment, and relabel replacing it): effInt env (l :-prog) \nk = let env = unlabel env in effInt env prog (\\envk, p => k (relabel l envk) p ) 4. Example: An Imperative \nLanguage Interpreter As a larger example, I present an interpreter for a small imperative language, Imp, \nwhich supports variables (requiring an updatable environment), and printing (requiring console I/O). \nWe follow the well-typed interpreter pattern, using a context membership proof to guarantee that local \nvariables are well-scoped. We separate ex\u00adpressions (Expr) from statements in the imperative language \n(Imp). First, we de.ne the types, supporting integers, booleans and unit, and a function interpTy to \nconvert these to I DRIS types: data Ty = TyInt | TyBool | TyUnit interpTy : Ty -> Type Expressions include \nvalues, variables, random numbers and binary operators derived from I DRIS functions, and are indexed \nby a con\u00adtext G (of type Vect Ty n), and the type of the expression: data Expr : Vect Ty n -> Ty -> Type \nwhere Val : interpTy a -> Expr G a Var : HasType i G t -> Expr G t Rnd : Int -> Expr G TyInt Op : \n(interpTy a -> interpTy b -> interpTy c) -> Expr G a -> Expr G b -> Expr G c For brevity, we omit the \nde.nition of HasType. It is suf.cient to know that HasType i G t states that variable i (a de Bruijn \nindex) in context G has type t. Values of variables are stored in a heterogeneous list corresponding \nto a vector of their types, with a lookup function to retrieve these values: data Vars : Vect Ty n -> \nType where Nil : Vars Nil (::) : interpTy a -> Vars G -> Vars (a :: G) lookup : HasType i G t -> Vars \nG -> interpTy t We can write an evaluator for this simple expression language in Effects, using the \nrandom number effect, and an environment corresponding to the context G: eval : Expr G t -> Eff m [RND, \nSTATE (Vars G)] (interpTy t) eval (Val x) = return x eval (Var i) = do vars <-get return (lookup i \nvars) eval (Rnd upper) = rndInt 0 upper eval (Op op x y) = [| op (eval x) (eval y) |] Using dependent \ntypes, we have expressed a correspondence be\u00adtween the context G under which the expression and the variables \nare de.ned. The imperative fragment is also indexed over a context G and the type of a program. We use \nthe unit type for statements (speci.cally Print) which do not have a value: data Imp : Vect Ty n -> Ty \n-> Type where Let : Expr G t -> Imp (t :: G) u -> Imp G u (:=) : HasType i G t -> Expr G t -> Imp G \nt Print : Expr G TyInt -> Imp G TyUnit (>>=) : Imp G a -> (interpTy a -> Imp G b) -> Imp G b return \n: Expr G t -> Imp G t Interpreting the imperative fragment requires the local variables to be stored \nas part of the state, as well as console I/O, for interpreting Print. We express this with the following \ntype: interp : Imp G t -> Eff IO [STDIO, RND, STATE (Vars G)] (interpTy t) In order to interpret Let, \nwhich introduces a new variable with a given expression as its initial value, we must update the environ\u00adment. \nBefore evaluating the scope of the Let binding, the envi\u00adronment must be extended with an additional \nvalue, otherwise the recursive call will be ill-typed because the state effect must be car\u00adrying an environment \nof the correct length and types. Therefore, we evaluate the expression with eval, extend the environment \nwith the result, evaluate the scope, then drop the value. interp (Let e sc) = do e <-eval e vars <-get; \nputM (e :: vars); res <-interp sc (_ :: vars ) <-get; putM vars return res Calling eval is .ne here, \nbecause it uses a smaller set of effects than interp. Also, note that if we forget to drop the value \nbe\u00adfore returning, this de.nition will be ill-typed because the type of interp requires that the environment \nis unchanged on exit. Interpreting an assignment simply involves evaluating the ex\u00adpression to be stored \nin the variable, then updating the state, where updateVar v vars val updates the variable at position \nv in the environment vars with the new value val :  interp (v := val) = do val <-eval val update (\\vars \n=> updateVar v vars val ) return val For Print, we simply evaluate the expression and display it, rely\u00ading \non the STDIO effect: interp (Print x) = do e <-eval x putStrLn (show e) Given some program, prog : Imp \n[] TyUnit, a main program would need to set up the initial resources, then call the interpreter: main \n: IO () main = run [(), 123456, []] (interp prog) Though small, this example illustrates the design \nof a complete application with Effects: a main program sets up the required set of resources and invokes \nthe top level effectful program. This, in turn, invokes effectful programs as necessary, which may use \nat most the resources available at the point where they are invoked. 5. Related Work The work presented \nin this paper arose from dissatisfaction with the lack of composability of monad transformers, and a \nbelief that a dependently typed language ought to handle side-effects more .ex\u00adibly, in such a way that \nit would be possible to reason about side\u00adeffecting programs. The inspiration for using an algebraic \nrepre\u00adsentation was Bauer and Pretnar s Eff [3], a language based around handlers of algebraic effects. \nIn our Effects system, we have found type classes to be a natural way of implementing handlers, in that \nthey allow different effect handlers to be run in different con\u00adtexts. Other languages aim to bring effects \ninto their type system, such as Disciple [18], Frank2 and Koka3. These languages are built on well-studied \ntheoretical foundations [13, 16, 27, 28], which we have also applied in this paper. Algebraic effects \nhave also been applied in Haskell, in order to combine I/O effects [30], and more recently [15] with \nan effect handler library. In our approach, we have seen that the I DRIS type system can express effects \nby embedding, without any need to extend the language or type system. We make no attempt to infer effect \ntypes, however, since our intention is to specify effects and check that they are used correctly. While \nour original motivation was to avoid the need for monad transformers [17] in order to compose effects, \nthere is a clear rela\u00adtionship. Indeed, EffM is in a sense a monad transformer itself, in that it may \naugment an underlying monad with additional effects. Therefore, we can expect it to be possible to combine \neffects and monad transformers, where necessary. The problem with modular\u00adity of monad transformers is \nwell-known, and addressed to some extent [14], though this still does not allow easy reordering of trans\u00adformers, \nor reducing the transformer stack. The Effects approach encourages a more .ne-grained separation of effects, \nby making it easy to call functions which use a smaller set of effects. Our approach, associating resources \nwith each effect, leads to a natural way of expressing and verifying resource usage protocols, by updating \nthe resource type. This is a problem previously tack\u00adled by others, using special purpose type systems \n[32] or Haskell extensions [19], and in my own previous work [7, 9] by creating a DSL for resource management, \nbut these are less .exible than the present approach in that combining resources is dif.cult. A related \nconcept is Typestate [1, 29], which allows states to be tracked in 2https://personal.cis.strath.ac.uk/conor.mcbride/pub/ \nFrank/ 3http://research.microsoft.com/en-us/projects/koka/ types, though again, we are able to implement \nthis directly rather than by extending the language. Implementing and reasoning about state-dependent \ninteractive programs has also been studied using type theory [12, 21]. To some extent, we can now support \nimperative programming with dependent types, such as supported by Xanadu [33] and Ynot [23]. Ynot in \nparticular is an axiomatic extension to Coq which allows reasoning about imperative programs using Hoare \nType Theory [22]. Preconditions and postconditions on operations can be expressed in Effects with input \nand output resource types. The dif.culty in imperative programming with dependent types is that updating \none value may affect the type of another, though in our interpreter example in Section 4 we have safely \nused a depen\u00addent type in a mutable state. 6. Conclusions IDRIS is a new language, with a full dependent \ntype system. This gives us an ideal opportunity to revisit old problems about how to handle effects in \na pure functional language. While the conven\u00adtional approach, based on monads and transformers, has proved \nsuccessful in Haskell, in this paper we have investigated an alterna\u00adtive approach and found it to be \na natural method for de.ning and using effects. By linking each effect with a resource we can even track \nthe state of resources through program execution, and reason about resource usage protocols such as .le \nmanagement. The Effects approach has a number of strengths, and some weaknesses which we hope to address \nin future work. The main strength is that many common effects such as state, I/O and excep\u00adtions can \nbe combined without the need for monad transformers. Effects can be implemented independently, and combined \nwithout further effort. Lifting is automatic; sub-programs using a smaller set of effects can be called \nwithout any explicit lifting operation, so as well as being easy to combine effects, programs remain \nreadable. We have described a number of effects which are representable in this setting, and there are \nseveral others we have not described which are easy to de.ne, such as parsing, logging, and bounded mutable \narrays. Arrays, statically bounded with a dependent type, could even lead to optimisations since the \neffect system can guar\u00adantee that only one copy is needed, therefore the array could have a compact representation \nwith no run-time bounds checking. Another advantage is that it will be possible to have .ne-grained separation \nof systems effects. We can be precise about needing net\u00adwork support, CGI, graphics, the operating system \ns environment, etc, rather than including all of these effects in one IO monad. While using Effects, \nwe are still able to use monads. Effects work with monads rather than against them, and indeed effectful \nprograms are generally translated to monadic programs. As a result, concepts which need to be monadic \n(for example, continuations) can remain so, and still work with Effects. Further Work The Effects system \nis promising as a general approach to effectful programming, but we have only just begun. At present, \nwe are developing more libraries using Effects to assess how well it works in practice as a programming \ntool, as well as how ef.cient it is for realistic programs. The most obvious weakness of Effects, is \nthat algebraic effects cannot capture all monads. This does not appear to be a serious problem, however, \ngiven that Effects is designed to interact with monads, rather than to replace them. More seriously, \nbut less obviously, there is a small interpreter overhead since EffM is represented as an algebraic data \ntype, with an associated interpreter. We have not yet investigated in depth how to deal with this overhead, \nor indeed if it is a serious problem in practice, but we expect that partial evaluation [8] or a .nally \ntagless approach [10] would be suf.cient.  Another weakness which we hope to address is that mixing \ncontrol and resource effects is a challenge. For example, we cannot currently thread state through all \nbranches of a non-deterministic search. If we can address this, it may be possible to represent more \nsophisticated effects such as co-operative multithreading, or even partiality. One way to tackle this \nproblem could be to introduce a new method of the Handler class which manages resources more precisely, \nwith a default implementation calling handle. An implementation detail which could be improved without \naffecting usage of the library is that effectful sub-programs require ordering of effects to be preserved. \nWe address this with a permute operator, requiring a proof that the new effect list is a permutation \nof the old, but ideally generating these proofs will be automatic. The Effects implementation is entirely \nwithin the I DRIS lan\u00adguage, with no extensions needed. It takes advantage of dependent types and theorem \nproving in several small but important ways: het\u00aderogeneous lists of resources, proofs of list membership \nand sub\u00adlist predicates, and parameterisation of resources. Since modern Haskell supports many of these \nfeatures, this leads to an obvious question: what would it take to implement Effects as an embed\u00added \nlibrary in Haskell? An interesting topic for further study would be whether this approach to combining \neffects would be feasible in a more mainstream functional language. Monad transformers have served us \nwell, and are a good .t for the Haskell type system. However, type systems are moving on. Perhaps now \nis the time to look for something more effective. Acknowledgments This work was supported by the Scottish \nInformatics and Computer Science Alliance (SICSA). My thanks to the inhabitants of the #idris IRC channel \non irc.freenode.net for their feedback, and to the anonymous referees for their helpful comments. References \n[1] J. Aldrich, J. Sunshine, D. Saini, and Z. Sparks. Typestate-oriented programming. In Proceedings \nof the 24th conference on Object Oriented Programming Systems Languages and Applications, pages 1015 \n1012, 2009. [2] L. Augustsson and M. Carlsson. An exercise in dependent types: A well-typed interpreter, \n1999. In Workshop on Dependent Types in Programming, Gothenburg. [3] A. Bauer and M. Pretnar. Programming \nwith Algebraic Effects and Handlers, 2012. Available from http://arxiv.org/abs/1203. 1539. [4] E. Brady. \nIdris, a General Purpose Programming Language: Design and Implementation, 2013. Draft. [5] E. Brady. \nProgramming in Idris: a Tutorial, 2013. Available from http://idris-lang.org/tutorial. [6] E. Brady and \nK. Hammond. A veri.ed staged interpreter is a veri.ed compiler. In Generative Programming and Component \nEngineering (GPCE 2006). ACM, 2006. [7] E. Brady and K. Hammond. Correct-by-construction concurrency: \nUsing dependent types to verify implementations of effectful resource usage protocols. Fundamenta Informaticae, \n102:145 176, 2010. [8] E. Brady and K. Hammond. Scrapping your inef.cient engine: Using partial evaluation \nto improve domain-speci.c language implementa\u00adtion. In Proceedings of the 15th International Conference \non Func\u00adtional Programming (ICFP 10), pages 297 308. ACM, 2010. [9] E. Brady and K. Hammond. Resource-safe \nSystems Programming with Embedded Domain Speci.c Languages. In Practical Applica\u00adtions of Declarative \nLanguages, pages 242 257, 2012. [10] J. Carette, O. Kiselyov, and C.-C. Shan. Finally tagless, partially \nevaluated: Tagless staged interpreters for simpler typed languages. Journal of Functional Programming, \n19(05):509 543. [11] D. Delahaye. A tactic language for the system Coq. In Logic for Programming and \nAutomated Reasoning (LPAR), volume 1955 of LNAI, pages 85 95. Springer, 2000. [12] P. Hancock and A. \nSetzer. Interactive Programs in Dependent Type Theory. In Proceedings of the 14th Annual Conference of \nthe EACSL on Computer Science Logic, pages 317 331, Aug. 2000. [13] M. Hyland, G. Plotkin, and J. Power. \nCombining effects: Sum and tensor. Theoretical Computer Science, 357:70 99, 2006. [14] M. Jaskelioff. \nModular monad transformers. In ESOP 09: Proceedings of the 18th European Symposium on Programming Languages \nand Systems, LNCS, pages 64 79. Springer, 2009. [15] O. Kammar, S. Lindley, and N. Oury. Handlers in \naction. In Proceed\u00adings of the 18th International Conference on Functional Programming (ICFP 13). ACM, \n2013. [16] P. B. Levy. Call-By-Push-Value. PhD thesis, Queen Mary and West\u00ad.eld College, University of \nLondon, 2001. [17] S. Liang, P. Hudak, and M. Jones. Monad transformers and modular interpreters. In \nProceedings of the 22nd ACM SIGPLAN-SIGACT symposium on Principles of Programming Languages, pages 333 \n343, New York, New York, USA, Jan. 1995. ACM Press. [18] B. Lippmeier. Witnessing Purity, Constancy and \nMutability. In 7th Asian Symposium on Programming Languages and Systems (APLAS 2009), volume 5904 of \nLNCS, pages 95 110. Springer, 2009. [19] C. McBride. Kleisli arrows of outrageous fortune, 2011. Draft. \n[20] C. McBride and R. Paterson. Applicative programming with effects. Journal of functional programming, \n18(1):1 13, 2008. [21] M. Michelbrink and A. Setzer. State dependent IO-monads in type theory. Electronic \nNotes in Theoretical Computer Science, 122:127 146, 2005. [22] A. Nanevski, G. Morrisett, and L. Birkedal. \nHoare type theory, poly\u00admorphism and separation. Journal of Functional Programming, 18(5 6):865 911, \nSept. 2008. [23] A. Nanevski, G. Morrisett, A. Shinnar, P. Govereau, and L. Birkedal. Ynot: Dependent \ntypes for imperative programs. In Proceedings of the 13th International Conference on Functional Programming \n(ICFP 08), pages 229 240. ACM, 2008. [24] M. Odersky, P. Altherr, V. Cremet, B. Emir, S. Maneth, S. Micheloud, \nN. Mihaylov, M. Schinz, E. Stenman, and M. Zenger. An overview of the Scala programming language. Technical \nreport, 2004. [25] E. Pa.salic, W. Taha, and T. Sheard. Tagless staged interpreters for typed languages. \nIn Proceedings of the 7th International Conference on Functional Programming (ICFP 02), volume 37, pages \n218 229. ACM, Sept. 2002. [26] S. Peyton Jones. Haskell 98 Language and Libraries: The Revised Report. \nTechnical report, 2002. [27] G. Plotkin and M. Pretnar. Handlers of Algebraic Effects. In ESOP 09: Proceedings \nof the 18th European Symposium on Programming Languages and Systems, pages 80 94, 2009. [28] M. Pretnar. \nThe Logic and Handling of Algebraic Effects. PhD thesis, University of Edinburgh, 2010. [29] R. Strom \nand S. Yemini. Typestate: A programming language concept for enhancing software reliability. IEEE Transactions \non Software Engineering, SE-12(1):157 171, 1986. ` ming, 18(4):423 436, 2008. [30] W. Swierstra. Data \ntypes a la carte. Journal of functional program\u00ad [31] P. Wadler. Monads for functional programming. In \nJ. Jeuring and E. Meijer, editors, Advanced Functional Programming, volume 925 of LNCS, pages 24 52. \nSpringer, 1995. [32] D. Walker. A Type System for Expressive Security Policies. In Pro\u00adceedings of the \n27th ACM SIGPLAN-SIGACT Symposium on Princi\u00adples of Programming Languages, POPL 00, pages 254 267. ACM, \n2000. [33] H. Xi. Imperative Programming with Dependent Types. In 15th Annual IEEE Symposium on Logic \nin Computer Science, pages 375 387, 2000.   \n\t\t\t", "proc_id": "2500365", "abstract": "<p>One often cited benefit of pure functional programming is that pure code is easier to test and reason about, both formally and informally. However, real programs have side-effects including state management, exceptions and interactions with the outside world. Haskell solves this problem using <i>monads</i> to capture details of possibly side-effecting computations --- it provides monads for capturing state, I/O, exceptions, non-determinism, libraries for practical purposes such as CGI and parsing, and many others, as well as <i>monad transformers</i> for combining multiple effects.</p> <p>Unfortunately, useful as monads are, they do not compose very well. Monad transformers can quickly become unwieldy when there are lots of effects to manage, leading to a temptation in larger programs to combine everything into one coarse-grained state and exception monad. In this paper I describe an alternative approach based on handling <i>algebraic effects</i>, implemented in the IDRIS programming language. I show how to describe side effecting computations, how to write programs which compose multiple fine-grained effects, and how, using dependent types, we can use this approach to reason about states in effectful programs.</p>", "authors": [{"name": "Edwin Brady", "author_profile_id": "81319488859", "affiliation": "University of St Andrews, St Andrews, United Kingdom", "person_id": "P4261232", "email_address": "ecb10@st-andrews.ac.uk", "orcid_id": ""}], "doi_number": "10.1145/2500365.2500581", "year": "2013", "article_id": "2500581", "conference": "ICFP", "title": "Programming and reasoning with algebraic effects and dependent types", "url": "http://dl.acm.org/citation.cfm?id=2500581"}