{"article_publication_date": "09-25-2013", "fulltext": "\n Experience Report: Applying Random Testing to a Base Type Environment Vincent St-Amour PLT @ Northeastern \nUniversity stamourv&#38;#169;racket-lang.org Abstract As programmers, programming in typed languages \nincreases our con.dence in the correctness of our programs. As type system de\u00adsigners, soundness proofs \nincrease our con.dence in the correct\u00adness of our type systems. There is more to typed languages than \ntheir typing rules, however. To be usable, a typed language needs to provide a well-furnished standard \nlibrary and to specify types for its exports. As software artifacts, these base type environments can \nrival typecheckers in complexity. Our experience with the Typed Racket base environment which accounts \nfor 31% of the code in the Typed Racket implementation teaches us that writing type envi\u00adronments can \nbe just as error-prone as writing typecheckers. We report on our experience over the past two years of \nusing random testing to increase our con.dence in the correctness of the Typed Racket base environment. \nCategories and Subject Descriptors D.2.5 [Software Engineer\u00ading]: Testing and Debugging Testing tools; \nD.3.3 [Programming Languages]: Language Constructs and Features Keywords Random testing, Type environments, \nNumeric towers 1. Types as Speci.cations Typecheckers prove claims about the run-time execution of pro\u00adgrams. \nProgrammers and compilers depend on the validity of these claims when they reason about programs. The \ncorrectness of these claims depends not only on the correctness of the underlying type system, but also \non the correctness of the base type environment of the language. The type for any given primitive operation \nmust be consistent with the operation s run-time behavior. In languages with sophisticated type systems, \ntypes can en\u00adcode precise speci.cations for primitive operations. For example Alms (Tov and Pucella 2011) \nuses session types to encode mutual exclusion for lock operations, Vault (DeLine and F\u00e4hndrich 2001) \nuses typestate to encode protocols in the types of its networking primitives, and FISh (Jay 1999) uses \nshape types to encode the ef\u00adfect matrix operations have on matrix shapes. Such speci.cations can be \nsubtle, making the encoding process error-prone. Permission to make digital or hard copies of all or \npart of this work for personal or classroom use is granted without fee provided that copies are not made \nor distributed for pro.t or commercial advantage and that copies bear this notice and the full citation \non the .rst page. Copyrights for components of this work owned by others than the author(s) must be honored. \nAbstracting with credit is permitted. To copy otherwise, or republish, to post on servers or to redistribute \nto lists, requires prior speci.c permission and/or a fee. Request permissions from permissions@acm.org. \nICFP 13, September 25 27, 2013, Boston, MA, USA. Copyright is held by the owner/author(s). Publication \nrights licensed to ACM. ACM 978-1-4503-2326-0/13/09. . . $15.00. http://dx.doi.org/10.1145/2500365.2500616 \n Neil Toronto PLT @ Brigham Young University ntoronto&#38;#169;racket-lang.org Typed Racket (Tobin-Hochstadt \nand Felleisen 2008) provides a rich numeric tower (St-Amour et al. 2012) similar to those provided by \nlanguages in the Lisp and Smalltalk families of languages, and it encodes precise type-based speci.cations \nfor its numeric oper\u00adations. The .ne-grained types offered by the type system and the .exibility of the \nlanguage s numeric operations result in large and complex speci.cations. Errors and oversights in these \nspeci.ca\u00adtions have been a major source of bugs in Typed Racket. The functional programming community \nhas a successful his\u00adtory of using random testing (Claessen and Hughes 2000) to .nd bugs in programs \nranging from undergraduate coursework (Page et al. 2008) to full-scale language models (Berghofer and \nNip\u00adkow 2004; Klein et al. 2012; Klein et al. 2013). Inspired by these success stories, we decided to \ninvestigate whether random testing would help us detect bugs in the Typed Racket base environment speci.cally \nin the implementation of its numeric tower. We report on our successful experience using PLT Redex (Felleisen \net al. 2009) to build a random tester that we have been using for this task over the last two years. \nThe rest of the paper is organized as follows: section 2 pro\u00advides background on the Typed Racket numeric \ntower, section 3 describes our random testing strategy, section 4 presents techniques we used to increase \nthe effectiveness of our random tester, section 5 summarizes positive and negative aspects of our experiences \nand section 6 concludes. 2. The Typed Racket Numeric Tower Typed Racket s approach to numeric types and \noperations its numeric tower (St-Amour et al. 2012) is inspired by those of untyped languages in the \nLisp and Smalltalk families. Numeric towers typically provide a deep hierarchy of numeric types including, \nin the case of Typed Racket, .xed-width and un\u00adbounded integer types, arbitrary-precision rational numbers, \nboth single and double-precision .oating-point numbers, and complex numbers. Numeric towers support generic \nand .exible numeric op\u00aderations that accept numbers of any type, support mixed-type arith\u00admetic that \nis, programmers can freely mix and match numeric types such as Integer and Float and always produce results \nwith the most precise representation available. In Typed Racket, the types of numeric operations include \npre\u00adcise speci.cations of their .exible run-time behavior. Given the complexity of these behaviors, their \nspeci.cations are often large and brittle. The operations themselves are implemented in C as part of \nthe Racket (Flatt and PLT 2010) runtime system and not in Typed Racket itself. This rules out the option \nof having the typechecker automatically infer or even check their types. The Typed Racket implementers \nmust therefore manually assign types to each of them, a laborious and therefore error-prone process. \n 2.1 Speci.cations for Numeric Operations In Typed Racket, numeric types can encode not only numeric \nlay\u00aders whether a number is an integer, a .oating-point number, or a complex number but also sign and \nrange properties. For example, Typed Racket provides a Positive-Float type which only in\u00adcludes positive \n.oating-point numbers and is a subtype of the more general Float type, which includes all .oating-point \nnumbers. Types such as Byte and Fixnum impose range constraints on their members, the former including \nintegers between 0 and 255 and the latter including all exact integers that can be represented in a tagged \nmachine word. These types are related to each other via subtyping: Byte is a subtype of Fixnum, which \nis in turn a subtype of Integer the type that contains all integers regardless of bit\u00adwidth. Range-bounded \ntypes can be further partitioned by sign, to obtain for instance Positive-Byte or Negative-Fixnum. Speci.cations \nfor numeric operations such as +, round and sqrt can take advantage of the .ne-grained distinctions encoded \nin these types to precisely describe the behavior of those operations. For example, the speci.cation \nof the sqrt function expresses that the Nonnegative-Real type is closed under sqrt, but that it returns \nComplex numbers in the general case. Types also encode the coercion rules that govern mixed-type arithmetic. \nFor example, the speci.cation of the + function ex\u00adpresses that the addition of an Integer and a Float \nreturns a Float.  2.2 Encoding Speci.cations as Types Typed Racket encodes speci.cations for numeric \noperations as ordered intersections of function types. That is, each property is individually encoded \nas a function type; all these properties are then intersected using Typed Racket s case-> type constructor. \nFor example, the closure property of integers under addition is expressed using this function type, [Integer \nInteger -> Integer] the contagion rule for integer-.oat mixed-type arithmetic is ex\u00adpressed with these \ntwo function types [Integer Float -> Float] [Float Integer -> Float] and sign preservation is encoded \nin these two function types [Positive Positive -> Positive] [Negative Negative -> Negative] To build \nthe type of + we intersect these properties, and all others that hold about addition: (: + (case-> [Zero \nZero -> Zero] ... [Fixnum Zero -> Fixnum] [Zero Fixnum -> Fixnum] ... [Integer Integer -> Integer] ... \n[Integer Float -> Float] [Float Integer -> Float] [Float Float -> Float] ... [Positive Positive -> Positive] \n[Negative Negative -> Negative] ...)) Each side of a symmetric property needs to be encoded as a separate \nfunction type and, because of Typed Racket s checking rule for intersection types, additional function \ntypes are required for each case where two or more properties intersect. As a result, types for numeric \nprimitives become large and complicated. For example, the type of + is an intersection type with 147 \nclauses while the type of * has 209 clauses. 3. Random Testing Strategy Types for numeric operations \nhave been a signi.cant source of bugs in Typed Racket. Of the 576 reported Typed Racket bugs, 63 (10.9%) \ncan be traced back to the types of numeric operations, and 39 others (6.8%) can be traced back to other \nparts of the base type environment. Such bugs signal a mismatch between the type of an operation and \nthe run-time behavior of the operation. Since we consider the run-time behavior of the numeric primitives \nto be the correct semantics, types need to be .xed when bugs are found. The Typed Racket developers have \nspent time and effort manu\u00adally testing the type environment,1 but manual testing alone is in\u00adsuf.cient. \nHandwritten tests often either test properties in isolation, or test combinations of a small number of \nproperties together. Most combinations remain unexplored, including some in which proper\u00adties combine \nto create interesting corner cases. We used random testing to improve the coverage of our test suite \nand .nd bugs be\u00adfore they cause problems in the real world. 3.1 Random Testing with PLT Redex PLT Redex \n(Felleisen et al. 2009) is an embedded domain-speci.c language built inside of Racket (Flatt and PLT \n2010) for de.n\u00ading and mechanizing executable language models. A typical mod\u00adeling work.ow with Redex \nis as follows. First, users de.ne a gram\u00admar and a reduction semantics for their language. Then, they \nwrite functions that encode properties that they expect to hold about terms in their language, such as \ntype soundness (Tobin-Hochstadt and Felleisen 2008) or determinism (Kuper and Newton 2012). Af\u00adterwards, \nthey write test cases to check whether the property holds for speci.c terms. Redex also provides support \nfor random testing (Klein and Findler 2010), inspired by QuickCheck (Claessen and Hughes 2000). Redex \ns random testing facility, redex-check, takes as input a language grammar and a property expressed about \nterms in that language, generates random terms and checks whether the desired property holds. It has \nbeen previously used to .nd mistakes in nine ICFP 2009 papers (Klein et al. 2012) and to .nd bugs in \na model of the Racket virtual machine (Klein et al. 2013).  3.2 Testing Type Preservation We designed \na language of arithmetic terms using Redex. The structure of the language is simple: it consists only \nof arithmetic expressions, with numbers at the leaves and arithmetic operations as the internal nodes. \nTo detect discrepancies between types and run-time behavior, we test type preservation on randomly generated \nterms in this language. The process is as follows: 1. Our tester generates a random arithmetic expression. \n 2. It then invokes the Typed Racket typechecker on the expression. 3. If the expression is ill-typed, \nthe tester rejects it and starts again with a new expression. 4. Otherwise, the tester asks the Typed \nRacket implementation to evaluate the expression. 5. It invokes the Typed Racket typechecker to typecheck \nthe result.  If the type of the result is not a subtype of the type of the original expression, then \nthe claim made by the typechecker does not hold 1 The Typed Racket test suite has over 10,000 lines of \nhandwritten tests.  and the tester has found a discrepancy. The result is unsound, almost always due \nto a bug in the type environment. We encoded this preservation property as a Racket function which redex-check \nthen applies to random terms.  3.3 Example: Floating-Point Under.ow Bug To illustrate this process, \nlet us examine an example bug we found using random testing. Consider this excerpt from the type we orig\u00adinally \nassigned to Racket s hyperbolic sine function, sinh: (: sinh (case-> [Float-Zero -> Float-Zero] [Positive-Float \n-> Positive-Float] [Negative-Float -> Negative-Float] ...)) Mathematically, the hyperbolic sine function \nmaps zero to zero, positive reals to positive reals, and negative reals to negative reals. The above \ntype encodes this mathematical statement. Now consider the following randomly generated term: (sinh 1.2535e-17) \nSince 1.2535e-17 is of type Positive-Float, the entire expres\u00adsion should be of type Positive-Float, \ngiven the type of sinh above. However, the term evaluates to 0.0 which, in Typed Racket, is of type Float-Zero. \nThe type Float-Zero is not a subtype of Positive-Float, which includes only positive .oating-point numbers. \nThus, the type fragment above does not accurately re.ect the runtime behavior of sinh. For values of \nx suf.ciently close to zero, sinh(x) is too small to represent as a .oating-point number, causing an \nunder.ow. We therefore need to correct the above type to account for this subtle corner case. This revised \ntype fragment, taken from the current type of sinh, addresses this issue: (: sinh (case-> [Float-Zero \n-> Float-Zero] [Positive-Float -> Nonnegative-Float] [Negative-Float -> Nonpositive-Float] ...)) 4. Improving \nRandom Test Case Generation Since we applied random testing to a speci.c domain numeric operations we \nwere able to leverage domain constraints to im\u00adprove the quality of randomly generated test cases. With \nhigher\u00adquality test cases, we were able to .nd more bugs with fewer at\u00adtempts than by using Redex s test \ncase generation directly. We improved the quality of test cases in two ways. First, we in\u00adcreased the \nprobability of generating well-typed terms. Second, we used specialized random number generation to generate \nnumeric corner cases with higher probability. 4.1 Generating Well-Typed Terms Testing type preservation \nmakes sense only for terms that are well\u00adtyped in the .rst place; our test infrastructure automatically \nrejects ill-typed terms. Therefore, to minimize wasting time on generating unusable terms, we engineered \nour grammar to generate well-typed terms with high probability. When .rst designing our term grammar, \na key design decision was to only allow trees of literal numbers and arithmetic operations as expressions. \nVariables and binders do not appear in the grammar, and thus cannot appear in the generated terms. This \nnot only guar\u00adantees that the generated terms are closed, but it also rules out by construction terms \nthat contain variables whose types are incon\u00adsistent between de.nition and use sites. Since we are interested \nin Strategy % of rejected terms (lower is better) Baseline 57.6% + integer non-terminal 45.3% + .oat \nnon-terminal 41.1% + integer and .oat non-terminals 1.6%  Figure 1: Percentage of rejected terms by \ngeneration strategy testing the types of numeric operations, there is no loss of gen\u00aderality; adding \nbinders and variables would not uncover bugs that would not have been found otherwise. That choice proved \neffective in practice. As the .rst row of .gure 1 shows, only around half of the generated terms were \nill\u00adtyped using our .rst attempt at a grammar. Looking at the ratio of rejected terms does not tell the \nwhole story, however. Most numeric operations in Typed Racket accept any kind of number as input the \n+ function accepts, e.g., inte\u00adgers and complex numbers alike. Other operations which we call type-limited \noperations accept inputs only from a portion of the numeric tower. For example, modulo accepts only integers, \nand fl+ is a .oating-point speci.c addition operation. By looking at a sample of rejected terms, we noticed \nthat terms containing type\u00adlimited operations accounted for most of the rejections. Those rejected terms \nmost often featured subexpressions of type Float (or one of its subtypes) used as arguments to integer-speci.c \nfunctions. Because the inexactness of .oating-point numbers is contagious for most operations, randomly \ngenerated terms are more likely to evaluate to .oating-point numbers than to integers. Less common were \nrejected terms containing .oat-speci.c opera\u00adtions receiving integers or complex numbers as arguments. \nSince terms containing type-limited operations were more likely to be rejected than other terms, type-limited \noperations were under\u00adtested compared to other operations. Types of type-limited opera\u00adtions are not, \non average, signi.cantly simpler than types of other numeric operations; testing type-limited operations \nadequately is thus important. While the types of numeric operations distinguish input types at a .ne-grained \nlevel e.g. they distinguish by sign, range, etc. they all possess a most general domain that is a supertype \nof all its other domains. For example, while the + function distinguishes between the addition of two \npositive integer and the addition of two negative integers and assigns different types to the results \nof the two expressions, it accepts any value of type Number, which is a supertype of all its other valid \ninput types. The most general domains of the vast majority of type-limited operations belong to a small \nset of types: Integer, Float and Real. Furthermore, the most general domains of most type-limited operations \nare closed under those operations. Armed with these two observations, we refactored our arithmetic expression \ngrammar so that it included an additional non-terminal for each of these types. The productions for these \nnon-terminals include literal numbers of that type, as well as type-limited operations with the appropriate \nmost general domain. In addition, these non-terminals include pro\u00adductions for other, non-type-limited \noperations on which the non\u00adterminal s type is closed. For example, to test the portion of the type of \n+ that handles values of type Integer and its subtypes, we added productions that generate addition terms \nto the integer non-terminal. Figure 2 shows an abbreviated version of the result\u00ading grammar. The define-language \nform takes the name of the language as its .rst argument, and each subsequent clause de.nes a non-terminal, \nin which the .rst element of the clause is the non\u00adterminal s name and the remaining elements are productions. \n (define-language tr-arith ; Float and its subtypes [F* (random-float) F] [F (* F* F*) (+ F* F*) (-F* \nF*) (/ F* F*) (max F* F*) (min F* F*) (abs F*) (floor F*) (ceiling F*) (truncate F*) (round F*) (cos \nF*) (sin F*) (tan F*) ... ; float-specific operations (fl+ F* F*) (fl-F* F*) (fl* F* F*) (fl/ F* F*) \n(flmin F* F*) (flmax F* F*) (flabs F*) ...] ; Integer and its subtypes [I* (random-integer) I] [I (* \nI* I*) (+ I* I*) (-I* I*) (max I* I*) (min I* I*) (abs I*) ... ; integer-specific operations (modulo \nI* I*) (remainder I* I*) (quotient I* I*) (gcd I* I*) (lcm I* I*) ...] ; any numeric type [E* (random-number) \nE F I] [E (* E* E*) (+ E* E*) (-E* E*) (/ E* E*) (max E* E*) (min E* E*) (abs E*) (floor E*) (ceiling \nE*) (truncate E*) (round E*) (sqrt E*) (log E*) (exp E*) (cos E*) (sin E*) (tan E*) ...]) Figure 2: \nAbbreviated grammar for Typed Racket arithmetic ex\u00adpressions This grammar refactoring signi.cantly lowered \nthe term rejec\u00adtion rate. Figure 1 shows the impact of the additional non-terminals on the rejection \nrate. In turn, this refactoring increased the amount of testing of type-limited operations.  4.2 Generating \nNumeric Corner Cases In addition to reducing the ratio of rejected test cases, we were also interested \nin increasing the ratio of bugs found per test case. Most of the bugs we had found in Typed Racket s \nnumeric types were related to numeric corner cases, that is, cases where the usual rules governing the \nbehavior of numeric operations do not apply. Corner cases lead to counter-intuitive behavior, which we \nas type environment designers often overlook and forget to encode as part of numeric types. Based on \nour corpus of numeric tower-related bugs, we iden\u00adti.ed three main sources of corner cases: mixed-type \narithmetic, special values and representation limitations. A key observation is that corner cases are \nnot uniformly distributed across the entire nu\u00admeric tower. To increase the likelihood that individual \ntest cases would trigger a bug, we engineered random number generation to generate these three cases \non a regular basis, while still adequately testing the common cases. 4.2.1 Mixed-type arithmetic Mixed-type \narithmetic exercises the coercion and contagion rules of numeric primitives described in section 2.2. \nThese rules are quite complex and not always intuitive, which makes the portions of numeric types that \ndeal with mixed-type arithmetic especially error-prone. To trigger mixed-type arithmetic, the random \ngenerator we use for real numbers picks a numeric layer at random, then calls the relevant layer-speci.c \ngenerator. Speci.cally, the random\u00adinteger->random-real function, shown in .gure 3, takes as argument \na random integer provided by the Redex random test generator and returns a random real number from a \nrandom layer. Using this technique, random terms generated for the any nu\u00admeric type non-terminal are \nhighly likely to feature mixed-type arithmetic. Furthermore, the any numeric type expressions can have \nsubexpressions drawn from type-limited expressions, which also introduces mixed-type arithmetic. 4.2.2 \nSpecial values When it comes to special values, such as the .oating-point in.ni\u00adties, NaN and the .oating-point \nzeroes, numeric primitives deal with these as special cases, usually mirrored by special cases in numeric \ntypes. Integer 0 is also often handled as a special case. For example, 0 is the null element of multiplication, \nand causes the * function to ignore all coercion and contagion rules. Instead it returns 0 directly, \nand that must be re.ected in the type. To ensure an adequate representation of special values, we al\u00adlocate \nportions of the random distributions speci.cally to them. As the last three conditional clauses in .gure \n4 show, NaN and each of the two .oating-point in.nities are generated with probability 0.05 when generating \n.oating-point numbers. The .oating-point zeroes are similarly special-cased. Special values in other \nlayers such as integer 0, and the single-precision .oating-point special values are handled similarly. \n 4.2.3 Representation Limitations Because of limitations of numeric representations, properties that \nwe expect to hold about mathematical functions may not hold of their implementations in the standard \nlibrary. Since we rely heavily on our intuition about mathematical functions when assigning types and \noften overlook the speci.cs of numeric representations, such limitations are a frequent source of bugs. \nBugs due to overlooking .oating-point under.ow as dis\u00adcussed in section 3.3 are examples of bugs due \nto representation limitations. Other examples include .oating-point over.ow and au\u00adtomatic .xnum to bignum \npromotion when integer values exceed a certain range. To ensure that these cases are exercised, we reserve \npart of the distribution for values that are near representation boundaries e.g. extremely small or extremely \nlarge .oating-point numbers or integers just small enough to be represented as .xnums. Figure 4 also \nshows the generation of .oating-point numbers in these ranges. To quantify the effectiveness of these \nreserved portions of the distribution, we attempted to trigger the under.ow bug discussed in section \n3.3 by generating random applications of the sinh func\u00adtion. Without these reserved portions of our distribution, \nwe gen\u00aderated .ve million random terms and none of them triggered the bug. With those reserved portions, \nwe executed 10 test runs. For each run, the bug was always triggered within 29 attempts, with 7 attempts \nbeing neccessary on average.  (define (random-integer->random-real i) (define r (random)) ; probability \n0.25 each (cond [(< r 0.25) i] ; random integer [(< r 0.5) (random-integer->random-rational i)] [(< r \n0.75) (random-integer->random-flonum i)] [else ; single-precision flonum (random-integer->random-single \ni)])) Figure 3: Allocation of random numbers to layers (define (random-integer->random-flonum i) (define \nr (random)) (cond ; 0.25: laplace-distributed with scale i [(< r 0.25) (random-laplace (abs i))] ; 0.25: \nuniform bits [(< r 0.5) (random-uniform-flonum)] ; 0.35: very small or very large [(< r 0.85) (define \nr (random)) (cond [(< r 0.5) (define x (ordinal->flonum i)) (if (= x 0.0) ; special case: float zeroes \n(if (< (random) 0.5) 0.0 -0.0) x)] [(< r 0.75) (flstep -inf.0 (abs i))] [else (flstep +inf.0 (-(abs i)))])] \n; 0.05 each: +nan.0, +inf.0, -inf.0 [(< r 0.9) +nan.0] [(< r 0.95) +inf.0] [else -inf.0])) Figure 4: \nRandom generation of .oating-point numbers 5. Lessons Learned Randomly testing the Typed Racket base \nenvironment has been a success. We achieved our goal of automatically .nding bugs in the Typed Racket \nenvironment. Based on our experience, we recommend using Redex-based random testing to typed language \nimplementers looking to test their type environments. This section provides some details on positive \nand negative aspects of our experience. 5.1 What Worked Random testing shined for some aspects of our \nproject. Of them, the following should be of general interest to other typed language implementers. Finding \nbugs Our random tester successfully found a large num\u00adber of bugs. These bugs had not been found through \nmanual testing, which suggests that random testing and manual testing complement each other. Some of \nthe bugs uncovered by random testing had already been reported by users (but had not been .xed yet). \nOur random checker created test cases that were often more useful as starting points for the debgugging \nphase than user-provided test cases. Randomly generated terms tended to be small compared to user-provided \ntest cases, which were often complete functions. Furthermore, random test cases included numeric operations \nonly which again narrowed down debugging signi.cantly. Testing the full implementation Our random tester \ncalls out to the Typed Racket implementation directly both to typecheck terms and to evaluate them. Redex \ncan call arbitrary Racket code, which made this work.ow convenient. Being able to test the actual Typed \nRacket implementation, rather than testing a separate model, was key to effectively .nding bugs. Con.dence \nwhen refactoring The Typed Racket numeric tower is in constant evolution. We need to assign new types \nwhen new primitives are added to the Racket runtime, and we constantly revise the design of Typed Racket \ns numeric tower to improve its usability. The addition of a random tester makes us much more con.dent \nwhen refactoring the numeric tower. We follow each change to numeric types with a round of random testing, \nin addition to manual testing. For example, in July 2012, the .rst author undertook a major change in \nthe design of the numeric tower: for usability reasons, we decided to include NaN as a valid value to \nall non-singleton .oating-point types. This refactoring required changing the major\u00adity of the types \nof .oat-speci.c operations, and of many generic operations as well several days of work. Without a random \ntester, the chances of introducing subtle bugs and not detecting them would have made such a refactoring \nterrifying. In the end, we may even have decided against it, and left the usability issue un\u00adaddressed. \nWith random testing as part of the development cycle, however, the refactoring was a success. We implemented \na .rst version of the new types, ran the random checker, .xed the bugs it found, and repeated the process. \nWhen short test runs stopped revealing bugs, we let the checker run overnight. Eventually, we trusted \nour refactoring and released it. So far, no bug has been reported that could be traced to it. Low effort \nrequired Writing the .rst version of the random tester took the .rst author, who had no previous experience \nwith Re\u00addex, about two hours. That initial effort resulted in a working ran\u00addom generator that successfully \nfound bugs. Racket s extensive math library made our subsequent experimentation with random distributions \ndescribed in section 4 easy. Continuous integration Our random tester is run every time a change is committed \nto the Racket code base. DrDr,2 Racket s continuous integration system, runs one thousand random test \ncases on every change, in addition to running the manually written Typed Racket test suite. Random testing \naccounts for about a minute and a half of this process. In general, continuous integration is useful \nto detect regressions. When combined with random testing, it also increases test coverage by running \nnew random test cases every time a change is made. 2 drdr.racket-lang.org   5.2 What Could Have Worked \nBetter While we were developing our random tester, we encountered three limitations of Redex. None were \nshow-stoppers we successfully worked around them but they nonetheless slowed us down. Type system integration \nWe needed to manually adjust our gram\u00admar to produce well-typed terms as often as possible. In doing \nso, we manually encoded aspects of the Typed Racket type system as part of our grammar. Changes to the \ntype system may accidentally cause an increase of the test case rejection rate and require manual changes \nto the grammar. Had Redex been able to use our type sys\u00adtem to guide its random generation, this effort \nwould not have been necessary. Default random number generation Redex provides a random number generator \nas part of its random testing support. It generates numbers from the full range of Racket s numeric types \nincluding fractions and complex numbers which made it a good starting point. Due to its inability to \ngenerate corner cases suf.ciently often, however, we eventually replaced it with our own custom random \nnumber generator. Test case reduction While randomly generated test cases were usually smaller than user-provided \ntest cases, they were often larger than necessary. Often, only one or two of a test case s operations \nwould be relevant to the exposed bug. Therefore, the .rst step of our response to failing test cases \nis to .nd which part of the term triggers the bug and isolate it. Had Redex provided test case reduc\u00adtion, \nour debugging cycle would have been signi.cantly shorter. 6. Conclusion Based on our experience with \nTyped Racket over the last two years, we have found that random testing is an effective technique for \nincreasing con.dence in a language s base type environment. With only a small amount of effort, we were \nable to implement a basic random tester and uncover bugs. With a modest amount of additional work, we \nwere able to increase the effectiveness of our tester signi.cantly. As a result of those efforts, the \nTyped Racket base type environment is now much more robust than it was two years ago. Acknowledgments \nWe thank Casey Klein and Robby Findler for suggesting that we use random testing to .nd bugs in the Typed \nRacket numeric tower. This work has been supported by the NSERC. Bibliography Stefan Berghofer and Tobias \nNipkow. Random testing in Isabelle/HOL. In Proc. Conf. on Software Engineering and Formal Methods, pp. \n230 239, 2004. Koen Claessen and John Hughes. QuickCheck: a lightweight tool for ran\u00addom testing of Haskell \nprograms. In Proc. International Conf. on Func\u00adtional Programming, pp. 268 279, 2000. Robert DeLine and \nManuel F\u00e4hndrich. Enforcing high-level protocols in low-level software. In Proc. Conf. on Programming \nLanguage Design and Implementation, pp. 59 69, 2001. Matthias Felleisen, Robert Bruce Findler, and Matthew \nFlatt. Semantics Engineering with PLT Redex. MIT Press, 2009. Matthew Flatt and PLT. Reference: Racket. \nPLT Inc., PLT-TR-2010-1, 2010. http://racket-lang.org/tr1/ C. Barry Jay. Programming in FISh. International \nJournal on Software Tools for Technology Transfer 2(3), pp. 307 315, 1999. Casey Klein, John Clements, \nChristos Dimoulas, Carl Eastlund, Matthias Felleisen, Matthew Flatt, Jay McCarthy, Jon Rafkind, Sam Tobin-Hochstadt, \nand Robert Bruce Findler. Run your research: on the effec\u00adtiveness of lightweight mechanization. In Proc. \nSymp. on Principles of Programming Languages, pp. 285 296, 2012. Casey Klein and Robert Bruce Findler. \nRandomized testing in PLT Redex. In Proc. Works. Scheme and Functional Programming, pp. 26 36, 2010. \nCasey Klein, Matthew Flatt, and Robert Bruce Findler. The Racket virtual machine and randomized testing. \nHigher-Order and Symbolic Compu\u00adtation, 2013. Lindsey Kuper and Ryan Newton. A lattice-theoretical approach \nto deter\u00administic parallelism with shared state. Indiana University, TR702, 2012. Rex Page, Carl Eastlund, \nand Matthias Felleisen. Functional programming and theorem proving for undergraduates: a progress report. \nIn Proc. Works. Functional and Declarative Programming in Education, pp. 21 30, 2008. Vincent St-Amour, \nSam Tobin-Hochstadt, Matthew Flatt, and Matthias Felleisen. Typing the numeric tower. In Proc. Practical \nAspects of Declarative Languages, pp. 289 303, 2012. Sam Tobin-Hochstadt and Matthias Felleisen. The \ndesign and implemen\u00adtation of Typed Scheme. In Proc. Symp. on Principles of Programming Languages, pp. \n395 406, 2008. Jesse A. Tov and Riccardo Pucella. Practical af.ne types. In Proc. Symp. on Principles \nof Programming Languages, pp. 447 458, 2011.    \n\t\t\t", "proc_id": "2500365", "abstract": "<p>As programmers, programming in typed languages increases our confidence in the correctness of our programs. As type system designers, soundness proofs increase our confidence in the correctness of our type systems. There is more to typed languages than their typing rules, however. To be usable, a typed language needs to provide a well-furnished standard library and to specify types for its exports.</p> <p>As software artifacts, these base type environments can rival typecheckers in complexity. Our experience with the Typed Racket base environment---which accounts for 31% of the code in the Typed Racket implementation---teaches us that writing type environments can be just as error-prone as writing typecheckers.</p> <p>We report on our experience over the past two years of using random testing to increase our confidence in the correctness of the Typed Racket base environment.</p>", "authors": [{"name": "Vincent St-Amour", "author_profile_id": "81485646095", "affiliation": "PLT @ Northeastern University, Boston, USA", "person_id": "P4261276", "email_address": "stamourv@racket-lang.org", "orcid_id": ""}, {"name": "Neil Toronto", "author_profile_id": "81490686870", "affiliation": "PLT @ Brigham Young University, Provo, USA", "person_id": "P4261277", "email_address": "ntoronto@racket-lang.org", "orcid_id": ""}], "doi_number": "10.1145/2500365.2500616", "year": "2013", "article_id": "2500616", "conference": "ICFP", "title": "Experience report: applying random testing to a base type environment", "url": "http://dl.acm.org/citation.cfm?id=2500616"}