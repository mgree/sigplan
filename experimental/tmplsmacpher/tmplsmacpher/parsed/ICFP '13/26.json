{"article_publication_date": "09-25-2013", "fulltext": "\n The Constrained-Monad Problem Neil Sculthorpe Jan Bracker George Giorgidze Andy Gill ITTC Institut \nf\u00a8ur Informatik Institut f\u00a8ur Informatik EECS /ITTC The University of Kansas Christian-Albrechts-Universit \n\u00a8at Universit \u00a8at T\u00a8ubingen The University of Kansas neil@ittc.ku.edu jbra@informatik.uni-kiel.de george.giorgidze@uni-tuebingen.de \nandygill@ittc.ku.edu Abstract In Haskell, there are manydata types that would form monads were it not \nfor the presence of type-class constraints on the operations on that data type. This is a frustrating \nproblem in practice, because there is a considerable amount of support and infrastructure for monads \nthat these data types cannot use. Using several examples, we show that a monadic computation can be restructured \ninto a normal form such that the standard monad class can be used. The technique is not speci.c to monads, \nand we show how it can also be applied to other structures, such as applicative functors. One signi.cant \nuse case for this technique is domain-speci.c languages, where it is often desirable to compile a deep \nembedding of a computation to some other language, which requires restricting the types that can appear \nin that computation. Categories and Subject Descriptors D.3.3 [Programming Lan\u00adguages]: Language Constructs \nand Features Constraints, Poly\u00admorphism, Data types and structures; D.3.2 [Programming Lan\u00adguages]: Language \nClassi.cations Applicative (functional) lan\u00adguages Keywords Class Constraints; Monads; Deep Embeddings; \nHaskell 1. Motivation The use of monads to structure computation was .rst suggested by Moggi [27, 28]and \nSpivey [36], and was then enthusiastically taken up by Wadler [41, 42]. Monads have since proved to be \na popular and frequently occurring structure, and are now one of the most prevalent abstractions within \nthe Haskell language. However, there are manydata structures that are monad-like, but cannot be made \ninstances of the Monad type class (Figure 1) be\u00adcause of type-class constraints on their operations. \nThe classic ex\u00adample of this is the Set data type, which imposes an ordering con\u00adstraint on its operations. \nThis is unfortunate, because the Haskell language and libraries provide a signi.cant amount of infrastruc\u00adture \nto support arbitrary monads, including special syntax. We will refer to this situation where type-class \nconstraints prevent a Monad instance from being declared as the constrained-monad problem . This paper \nis about investigating solutions to this problem, with an emphasis on the particular solution of normalizing \na deep embed\u00adding of a monadic computation. We aim to understand the utility of Permission to make digital \nor hard copies of all or part of this work for personal or classroom use is granted without fee provided \nthat copies are not made or distributed for pro.t or commercial advantage andthat copies bear this notice \nandthe fullcitation on the .rst page. Copyrights for components of this work owned by others than the \nauthor(s)must be honored. Abstractingwithcredit is permitted. To copyotherwise, or republish, to poston \nservers or to redistribute to lists, requires prior speci.c permission and/or a fee. Request permissions \nfrom permissions@acm.org. ICFP 13, September 25 27, 2013, Boston, MA, USA. Copyright is heldbythe owner/author(s). \nPublication rights licensed to ACM. ACM 978-1-4503-2326-0/13/09. . . $15.00. http://dx.doi.org/10.1145/2500365.2500602 \n class Monad (m :: * . *) where return :: a . m a (> =) :: m a . (a . m b) . m b return a > = k = k a \n(left identity) ma > = return = ma (right identity) (ma > = h) > = k = ma > = (.a . h a > = k) (associativity) \n Figure 1. Monads and the monad laws. the various solutions, publicize their usefulness, and explain \nhow theyrelate to each other. We begin by giving three concrete examples of the constrained\u00admonad problem: \nthree data types that would be monads were it not for the presence of class constraints on their operations. \n 1.1 Sets The Data.Set module in the Haskell standard library provides an abstract representation of \nsets that is implemented using size\u00adbalanced binary trees [1] for ef.ciency. The operations from the \nmodule that we will use are as follows: singleton :: a . Set a toList :: Set a . [ a] fromList :: Ord \na . [ a] . Set a unions :: Ord a . [ Set a ] . Set a Notice the Ord class constraint on two of the operations; \nthis is a consequence of the binary-tree implementation. Ideally we would like to de.ne a Set monad that \nbehaves anal\u00adogously to the list monad (i.e. modelling non-determinism), except that it should combine \nduplicate results. For example, we would like to write the following set comprehension, do n . fromList \n[ 3, 2, 1, 2 ] c . fromList [ a , b ] return (n, c) and be able to evaluate it to the set: {(1, a ), \n(1, b ), (2, a ), (2, b ), (3, a ), (3, b )} Using the operations provided by Data.Set, it appears straight\u00adforward \nto de.ne return and > = (pronounced bind ) functions that satisfy the monad laws (Figure 1): returnSet \n:: a . Set a returnSet = singleton bindSet :: Ord b . Set a . (a . Set b) . Set b bindSet sa k = unions \n(map k (toList sa)) However, the use of unions introduces an Ord constraint in the type of bindSet, \nwhich means that a straightforward attempt to de.ne a Monad instance will not type check: instance Monad \nSet where return = returnSet (> =) = bindSet --does not type check  The problem is that > = must be \nparametrically polymorphic in its two type parameters, whereas bindSet constrains its second type parameter \nto ordered types.  1.2 Vectors In their work on structuring quantum effects, Vizzotto et al. [39] discuss \nhow quantum values can be represented as a vector asso\u00adciating a complex number to each element of a \n.nite set. Further\u00admore, theyobserve that such vectors have a structure that is almost a monad, with \nthe application of a linear operator to a vector match\u00ading the type of > = and obeying the monad laws. \nAdapting their code slightly, this can be de.ned as follows1: class Finite (a :: *) where enumerate :: \n[ a ] type Vec (a :: *) = (a . Complex Double) returnVec :: Eq a . a . Vec a returnVec a = .b . if a \n= b then 1 else 0 bindVec :: Finite a . Vec a . (a . Vec b) . Vec b bindVec va k = .b . sum [ va a * \n(k a) b | a . enumerate] Notice the presence of class constraints on both returnVec and bindVec; as with \nthe set example, these constraints prevent these functions being used to de.ne a Monad instance. However, \nthe situation is not quite the same as for sets: bindVec has a constraint on its .rst type parameter, \nwhereas bindSet had a constraint on its second type parameter. Additionally, returnVec is constrained, \nwhereas returnSet was not; and furthermore, the constraint on returnVec differs from the constraint on \nbindVec.  1.3 Embedding JavaScript Our Sunroof library [6] provides an Embedded Domain-Speci.c Language \n(EDSL) [5, 10]for expressing JavaScript computations in Haskell, and for compiling them to executable \nJavaScript. Our initial embedding of a JavaScript computation in Haskell used the following Generalized \nAlgebraic Data Type (GADT) [31]: data JS :: * . * where Prompt :: JSString . JS JSString Alert :: JSString \n. JS () If :: JSBool . JS a . JS a . JS a We consider only a small selection of constructors for brevity: \nPrompt and Alert are deep embeddings of the standard-library functions of the same names; If is a deep \nembedding of a condi\u00adtional statement. We have enumerated the functions Prompt and Alert for clarity \nhere, but will later abstract over an arbitrary func\u00adtion (Section 4.3.2). To allow JS to be compiled, \nwe must constrain anypolymorphic types to those that can be successfully translated to JavaScript a \ncommon requirement for this style of EDSL [8, 37]. We represent this constraint with a class called Sunroof, \nwhich can generate new variables, print values in their JavaScript form, and, given a right\u00adhand side, \ngenerate a JavaScript assignment: type JSCode = String class Show a . Sunroof (a :: *) where mkVar :: \nString . a -- New variable of type a showJS :: a . JSCode -- Show as JavaScript assignVar :: a . JSCode \n. JSCode -- Assign to a variable assignVar a c = showJS a + \"=\" + c + \";\" The () type is the outlier, \nso we give its instance here. It is inter\u00adesting because values of type () are not stored in variables, \nand expressions of type () are never even computed. 1Actually, Vec should be de.ned as a newtype because \nof limitations on the use of type synonyms in Haskell. However, as this introduces some syntactic clutter, \nwe elide this detail. instance Sunroof () where mkVar = () showJS () = \"null\" assignVar () = \"\" To compile \nto JavaScript, we use the pattern of compiling JS into a pair consisting of JavaScript code and a JavaScript \nvari\u00adable referring to the result of that code. We work inside a state monad [42] called CompM for name \nsupply purposes. compileJS :: Sunroof a . JS a . CompM (JSCode, a) compileJS (Prompt s) = do (decl, v) \n. newVar return (concat [ decl  , assignVar v (\"prompt(\" + showJS s + \")\") ], v) compileJS (Alert s) \n= return (concat [ \"alert(\", showJS s, \");\" ], ()) compileJS (If b ja1 ja2 ) = do (decl, v) . newVar \n(c1 , a1 ) . compileJS ja1 (c2 , a2 ) . compileJS ja2 return (concat [ decl , \"if(\", showJS b, \") {\" \n, c1 , assignVar v (showJS a1 ) , \"} else {\" , c2 , assignVar v (showJS a2 ) , \"}\" ], v) As JavaScript \ncomputations are usually sequences of com\u00admands, with some commands returning values that can in.uence \nwhich commands follow, a natural way of expressing these se\u00adquences would be to use a monad. In particular, \ndo-notation would allow for code that emulates JavaScript closely. For example: js1 :: JS () js1 = do \nreply . Prompt (string \"Name?\") Alert (string \"Hello: \" . reply) string :: String . JSString --only \nsignature given For monadic code such as this to be valid, we need to write a Monad instance for JS. \nNote that we do not want the monadic op\u00aderations to interpret the JavaScript (a shallow embedding); rather \nwe want to construct a representation of the monadic operations (a deep embedding) so that we can later \ncompile them to JavaScript. Thus we add Return and Bindconstructors to the JS data type, us\u00ading the higher-order \nabstract syntax [33] approach of representing a variable binding as a Haskell function: data JS :: * \n. * where . . . Return :: a . JS a Bind :: JS x . (x . JS a) . JS a Note that the semantics of GADTs \nare such that the x on the Bind constructor is an existential type [22]: it is instantiated to a speci.c \ntype when a Bind is constructed, and then inaccessibly encapsulated by the constructor until the Bind \nis deconstructed through case analysis. Using Return and Bind, it is trivial to declare a Monadinstance: \ninstance Monad JS where return = Return (> =) = Bind The constrained-monad problem strikes when we try \nto com\u00adpile this deep embedding into JavaScript. Initially, compiling the Return and Bind constructors \nmay seem to be straightforward: compileJS (Return a) = return (\"\", a) compileJS (Bind jx k) = do (c1 \n, x) . compileJS jx --does not type check (c2 , a) . compileJS (k x) return (c1 + c2 , a)  However, \nthis does not type check. The problem is that the exis\u00adtential type introduced by the Bind constructor \nis not constrained by the Sunroof type class, and thus we cannot recursively call compileJS on the argument \njx . There appears to be a simple solu\u00adtion though add the Sunroofconstraint to the Bind constructor: \nBind :: Sunroof x . JS x . (x . JS a) . JS a However, because the type of Bind is now more constrained \nthan the type of > =, the Monad instance for JS no longer type checks, leaving us in a similar situation \nto the vector example. Yet while the same issue has arisen, this example is fundamen\u00adtally different \nfrom the previous two examples. There we wanted to de.ne return and > = operations that would use their \narguments to compute a new set/vector (i.e. a shallow embedding), whereas for Sunroof we are constructing \na computation that we can then compile to JavaScript (i.e. a deep embedding).  1.4 Contributions We \nhave seen three examples of the constrained-monad problem. In each case, the problem was slightly different. \nThe set example only required the second type parameter of > = to be constrained, the vector example \ninvolved two distinct constraints, and in the Sunroof example the objective was to compile the computation \nto JavaScript, rather than to evaluate the computation. We will refer to the situation where we want \nto evaluate a monadic computation to the same type that we are operating on as the shallow constrained\u00admonad \nproblem, and to the situation where we want to compile a monadic computation as the deep constrained-monad \nproblem (also known as the monad-rei.cation problem). The problem generalizes beyond monads. There are \nmanyother type classes with methods that are parametrically polymorphic in one or more arguments (e.g. \nFunctor). We would like data types with operations that obey the relevant laws to be able to use the \nexisting type-class hierarchyand infrastructure, even if those oper\u00adations constrain the polymorphic \narguments. As the problem is that we have a type class and a data type that are incompatible, a solu\u00adtion \nmust therefore involve either modifying the class, modifying the data type, or both (or modifying the \nlanguage). This paper brings together several techniques for working with monads, constraints and deep \nembeddings, to present a framework for addressing the constrained-monad problem. In the process we demonstrate \nthe compatibility of many of these techniques, and how they can be used to complement each other. The \nprincipal solution that we describe involves de.ning a normal form for a monadic computation, and a GADT \nto represent a deep embedding of that computation. The GADT explicitly constrains all existential types \nwithin the GADT, while still allowing a Monad instance to be declared for that GADT. The deep embedding \ncan then be given multiple interpretations, which can impose different constraints. Finally, we show \nhow the technique can be applied to other control structures, such as applicative functors. We also survey \nother solutions to the constrained-monad prob\u00adlem, and related techniques. Some of the techniques we \ndescribe are well known, but have not been applied to this problem before. Others are known in functional-programming \nfolklore to be able to address either the shallow or deep version of the problem, but have either not \nbeen documented, or generalized to the other half of the problem. There is one existing published solution \nto the deep constrained-monad problem [30], with which we compare in detail. Our solution is direct, \nand we show how it can be applied to structures other than monads. Additionally, our solution provides \na use case demonstrating the utility of the recent constraint kinds [3] GHC extension. In summary, the \ncontributions of this paper are as follows: We describe our solution to the constrained-monad problem. \nSpeci.cally, we construct a normalized deep embedding of a monadic computation with explicit constraints \non the existential types. The normalization eliminates any unconstrained types, allowing a Monadinstance \nto be declared. We demonstrate our solution by applying it to each of the three examples. (Section 2) \n We present a general solution by abstracting from the solutions for each example. (Section 3)  We \nsurvey other solutions to the constrained-monad problem, and compare them to each other and to our solution. \n(Section 4)  We apply our solution to several other structures. (Section 5)  We show how Jones et al. \n[17] s technique for specifying con\u00adstraints at use sites is compatible with our solution, and how it \nsupports multiple interpretations of a computation. (Section 6)  2. Normality can be Constraining In \nthis section we present our technique for addressing the con\u00adstrained-monad problem: constraining all \nexistential types by nor\u00admalizing a deep embedding of the monadic computation. For clar\u00adity, we present \nspecialized solutions for each of the three examples. 2.1 Overview of Technique The main steps of our \ntechnique are as follows: Separate the monadic structure of the computation from its primitive operations. \n Restructure the computation into a normal form by applying the monad laws.  Capture that structure \nin a deep embedding that constrains all existential types.  Only permit constrained primitive operations \nto be lifted into the embedding.  Declare a Monad instance for the embedding.  Constrain the type parameter \nof the computation when inter\u00ad  preting the computation. By monadic structure we mean all uses of return \nand > =. Byprim\u00aditive operations, we mean other functions that produce values of type m a for the speci.c \nmonad m with which we are working. The literature refers to primitive operations under a variety of names, \nin\u00adcluding non-proper morphisms , effect basis , instruction sets and generic effects . For example, \nthe primitive operations of the Maybe monad are the constructors Just and Nothing, whereas the primitive \noperations of the state monad [42] are get and put. The monadic normal form [2] consists of a sequence \nof right\u00adnested > =s terminating with a return, where the .rst argument to each > = is a primitive operation. \nThis can be seen graphically in Figure 2. Any monadic computation constructed from > =, return and primitive \noperations can be restructured into this normal form by applying the monad laws. As well as allowing \nus to overcome the constrained-monad problem, there are two well-known bene.ts from constructing a normalized \ndeep embedding. First, by applying the monad laws to normalize the structure, the monad laws are enforced \nby construc\u00adtion [24]. Second, by using a deep embedding, the construction of the monadic computation \nis separated from its interpretation. Consequently, multiple interpretations can be given to a computa\u00adtion \n[2, 24]. For example, a monadic computation over a probabil\u00adity distribution can be interpreted either \nnon-deterministically by using a state monad where the state is a pseudo-random seed, or by computing \nthe weights of all possible outcomes [2]. Furthermore, of particular relevance to the constrained-monad \nproblem, different interpretations can impose different constraints. In the remainder of this section, \nwe demonstrate how normal\u00adization is the tool we need to constrain all existential types in a monadic \ncomputation, by applying it to our three examples.  m a > = m x1 x1 . m a prim > =  m x2 prim x . \nm a n-1 m x n x n . m a prim return a Figure 2. A normal form for monadic computations.  2.2 Sets We \nbegin by de.ning a deep embedding of normalized monadic computations over Set as a GADT: data SetM :: \n* . * where Return :: a . SetM a Bind :: Set x . (x . SetM a) . SetM a Notice that the .rst argument \nto Bind is an actual Set (i.e. the type of primitive operations), not a recursive occurrence of SetM. \nWe recommend that the reader takes a few moments to convince herself that this data type only permits \nmonadic computations in the normal form presented in Figure 2. We now declare a Monad instance for SetM, \nusing the monad laws to restructure the computation into the normal form: instance Monad SetM where return \n:: a . SetM a return = Return (> =) :: SetM a . (a . SetM b) . SetM b (Return a) > = k = k a --left identity \n(Bind sx h) > = k = Bind sx (.x . h x > = k) --associativity The use of the monad laws is essential: \nattempting to de.ne > = simply as Bindwould not type check, because the .rst argument to > = is a SetM, \nwhereas the .rst argument to Bind is a Set. We now need a way to lift a primitive Set into this deep \nembed\u00adding. As there is no constructor for a solitary primitive operation, we use the right-identity \nlaw to introduce a Bind and Return: liftSet :: Set a . SetM a liftSet sa = Bind sa Return --right identity \n If this does not seem obvious, consider that it is similar to creating a singleton list using (.x . \nx : [ ]). We can now construct monadic computations over sets by work\u00ading in the SetM monad. For example, \nwe can express a set compre\u00adhension as follows: s1 :: SetM (Int, Char) s1 = do n . liftSet (fromList \n[ 3, 2, 1, 2 ]) c . liftSet (fromList [ a , b ]) return (n, c) Finally, we need to lower a SetM to a \nSet. This is a simple matter of folding over the GADT, replacing Return and Bind with returnSet and bindSet \n(from Section 1.1), respectively: lowerSet :: Ord a . SetM a . Set a lowerSet (Return a) = returnSet \na lowerSet (Bind sx k) = bindSet sx (lowerSet . k) Thus, to express monadic set computations, we can \nlift primitive Sets into the SetM type, write computations in the SetM monad, and then lower the resulting \nSetM to a Set. But why does this work? Observe from Figure 2 that, after normalization, the second type \nparameter of > = is the same type (a) throughout the com\u00adputation, and that this type is the same type \nas the top-level type parameter. Hence, by constraining the top-level type parameter in the type signature \nof lowerSet, we constrain the second type pa\u00adrameter of all occurrences of Bind. As the bindSet function \nonly requires its second type parameter to be constrained, we are thus always able to use it in place \nof Bind. If we had not normalized the computation, then arbitrary existential types could appear as the \nsecond type parameter of Bind, and so we could not fold the computation using bindSet.  2.3 Vectors \nHaving solved the constrained-monad problem for sets, it would seem straightforward to do the same for \nvectors. And indeed we can de.ne a normalized deep embedding (VecM), declare a monad instance for it, \nand provide a lifting function, exactly as we did for SetM. However, an attempt to de.ne a similar lowering \nfunction fails to type check: --does not type check lowerVec :: (Eq a, Finite a) . VecM a . Vec a lowerVec \n(Return a) = returnVec a lowerVec (Bind vx k) = bindVec vx (lowerVec . k) The problem is that bindVec \nconstrains its .rst type parameter (whereas bindSet constrains its second type parameter). That .rst \nparameter is not present in the type signature of lowerVec; indeed it is not even a single type: it needs \nto be instantiated to every existential type within the GADT (types x1 to xn in Figure 2). There is no \ntype signature that we can give to lowerVec to express this constraint. However, we can change the deep \nembedding such that it con\u00adstrains the existential types. In this case, we attach the Finite con\u00adstraint \nto the Bind constructor: data VecM :: * . * where Return :: a . VecM a Bind :: Finite x . Vec x . (x \n. VecM a) . VecM a The de.nition of lowerVec now type checks, because the type of bindVec matches that \ntype of Bind. Indeed, we can even drop the Finite constraint from the type of lowerVec, lowerVec :: Eq \na . VecM a . Vec a as that constraint need only appear on the .rst type parameter of bindVec. Conversely, \nthe Eq constraint must remain, as that is required by returnVec. But does adding this constraint interfere \nwith de.ning a Monad instance for VecM?Perhaps surprisingly, it does not; we can de.ne the monad instance \nexactly as before: instance Monad VecM where return :: a . VecM a return = Return (> =) :: VecM a . (a \n. VecM b) . VecM b (Return a) > = k = k a --left identity (Bind vx h) > = k = Bind vx (.x . h x > = k) \n--associativity Initially this may appear magical: a function without class con\u00adstraints is constructing \na GADT containing class constraints. How\u00adever, observe that (> =)isn tintroducing anynew types; it is \nmerely re-associating the existing computation. In the recursive case, it pattern matches on Bind, introducing \nthe Finite constraint, before constructing a new Bind with the same existential type, and thus the necessary \nconstraint is already in scope.  Of course, the Finite constraint has to come from somewhere, and that \nsomewhere is the lifting function, which constructs a Bind without deconstructing an existing Bind: liftVec \n:: Finite a . Vec a . VecM a liftVec va = Bind va Return --right identity This addition of a class constraint \nto the lifting function is key. Consider, the only ways to create a VecM are by using liftVec and Return. \nAs liftVec is constrained, the only way to introduce an unconstrained type is through Return. But by \nperforming normal\u00adization, all occurrences of Return except the .nal occurrence are eliminated. And the \ntype of that .nal Return can be constrained by the lowering function. Hence, in combination, we can constrain \nall types within a VecM computation.  2.4 Embedding JavaScript In the previous two examples we introduced \na deep embedding as a means of normalizing a monadic computation, and then de.ned a lowering function \nthat interpreted the deep embedding as the same type as the underlying primitive operations. The Sunroof \nexample differs in that rather than interpreting the computation as the underlying type, we instead want \nto compile it to JavaScript. We begin by splitting a JavaScript computation into two mutu\u00adally recursive \ndata types2, one for the primitive operations and one for the (normalized) monadic structure: data JS \n:: * . * where Prompt :: JSString . JS JSString Alert :: JSString . JS () If :: JSBool . JSM a . JSM \na . JS a data JSM :: * . * where Return :: a . JSM a Bind :: Sunroof x . JS x . (x . JSM a) . JSM a \n Notice that, as with VecM, we constrain the existential type. AMonadinstance for JSM, and an accompanying \nlifting func\u00adtion, are de.ned in exactly the same way as for VecM. We can then successfully complete \nthe compiler for the JS monad: compileJSM :: Sunroof a . JSM a . CompM (JSCode, a) compileJSM (Return \na) = return (\"\", a) compileJSM (Bind jx k) = do (c1 , x) . compileJS jx (c2 , a) . compileJSM (k x) return \n(c1 + c2 , a) We do not repeat the de.nition of compileJS as it is mostly un\u00adchanged from Section 1.3; \nthe only difference is that the recursive calls to compileJS are replaced with calls to compileJSM. \n 2.5 Discussion The key to this technique is normalization. Once normalized, the only types within a \nmonadic computation are either the type param\u00adeters of primitive operations, or the top-level type parameter. \nCon\u00adsequently, by constraining the primitives and constraining the top\u00adlevel type parameter, we can constrain \nall types within the compu\u00adtation. Thus, when interpreting the computation, we can use func\u00adtions that \nhave class constraints. As shown by the vector example, the class constraints on the > =-like and return-like \nfunctions can differ. In general, any con\u00adstraints on the .rst type parameter of the > =-like function \nshould appear in the context of the Bind constructor, constraining the ex\u00adistential type. Whereas anyconstraints \non either the type parameter of the return-like function, or on the second type parameter of the > =-like \nfunction, should appear in the context of the interpretation function, constraining the type parameter \nof the computation. 2A non-recursive and more reusable alternative would be to paramaterize JS on a type \nm :: * . *, and then instantiate that type to JSM. Such an approach is advocated by Lin [24]. Note that \nwhile the deep embedding is used to facilitate nor\u00admalization, it is not necessary: there are other ways \nto normalize a monadic computation, as we will discuss in Section 4.4. Further\u00admore, even using a deep \nembedding, de.ning a GADT that enforces the normal form is unnecessary. A valid alternative is to de.ne \na GADT that allows arbitrary nesting of Binds and occurrences of Returns (such as the JS data type in \nSection 1.3). We would then normalize that GADT, or normalize during deconstruction of the GADT (as is \ndone by Unimo [24]and RMonad [35]). However, we consider it clearer, and less error-prone, to have the \nGADT enforce the normal form (as is done by Operational [2]). 3. Generalizing using Constraint Kinds \nEach deep embedding in Section 2 was specialized to a particular example. In this section we use the \nrecent constraint kinds GHC extension to generalize to a single deep embedding that can be instantiated \nto any of the examples. This generalized solution is also available in our Constrained-Normal library \n[34]. 3.1 Constraint Kinds Constraint kinds were implemented by Bolingbroke [3], motivated by a desire \nto support the constraint synonyms and constraint fam\u00adilies proposed by Orchard and Schrijvers [29]. \nThe core idea is to add a new literal kind to Haskell called Constraint, which is the kind of a fully \napplied type class. For example, the Ord and Monad classes would be assigned the following kinds: Ord \n:: * . Constraint Monad :: (* . *) . Constraint The most signi.cant bene.t of this extension is the \nability to ab\u00adstract over constraints: data types and type classes can take class constraints as parameters. \nThe extension also adds syntax for an empty constraint and constraint synonyms; however, as constraint \nsynonyms cannot be partially applied, theyare less expressive than de.ning empty type classes with polymorphic \ninstances. For example, we will later need to instantiate a parameter of kind (* . Constraint)such that \nit imposes no constraints on the type; so we encode this using the following empty type class: class \nUnconstrained (a :: *) where instance Unconstrained a where  3.2 Constrained Normal Monads We now de.ne \nwhat we call a constrained normal monad: a GADT representing a normalized monadic computation with constrained \nexistential types. This requires parameterizing the GADT on a class constraint c and an underlying type \nof primitive operations t: data NM :: (* . Constraint) . (* . *) . * . * where Return :: a . NM c t a \nBind :: c x . t x . (x . NM c t a) . NM c t a This GADT generalizes SetM, VecMand JSMfrom Section 2, \nand has a Monadinstance de.ned in the same way. To accompanyNM, we provide a generalized lifting function: \nliftNM :: c a . t a . NM c t a liftNM ta = Bind ta Return Constructing monadic computations is now no \nharder than when using the specialized solutions in Section 2, for example: s1 :: NM Unconstrained Set \n(Int, Char) s1 = do n . liftNM (fromList [ 3, 2, 1, 2 ]) c . liftNM (fromList [ a , b ]) return (n, c) \nA generalized lowering function is slightly more complicated. Recall that lowerSet and lowerVec made \nuse of operations speci.c to their underlying type, such as returnVec and bindVec. Thus, our generalization \nhas to take those functions as arguments:  lowerNM :: . a c t. (a . t a) . (. x. c x . t x . (x . t \na) . t a) . NM c t a . t a lowerNM ret bind = lowerNM ' where lowerNM ' :: NM c t a . r lowerNM ' (Return \na) = ret a lowerNM ' (Bind tx k) = bind tx (lowerNM ' . k) The type signatures used here require the \nscoped type variables [31] and rank-2 types [32] GHC extensions. Notice that the type of ret shares its \ntype parameter (a)with the parameter of the NM argu\u00adment. Thus ret need only be applicable at that one \nspeci.c type, which is suf.cient because normalization ensures that there will only be one Return constructor, \nand it will have that type. The sec\u00adond type parameter of bind is that same type a, but its .rst type \nparameter can be any type that type satis.es the constraint c. This restriction is precisely what allows \nlowerNM to take constrained functions such as bindVec as arguments. For example: lowerVec :: Eq a . NM \nFinite Vec a . Vec a lowerVec = lowerNM returnVec bindVec lowerSet :: Ord a . NM Unconstrained Set a \n. Set a lowerSet = lowerNM returnSet bindSet Actually, the inferred type of lowerNM is more general \nthan the type signature we assigned it. Its de.nition is a fold over the GADT, which could return values \nof types other than the primitive operation. Renaming lowerNM to foldNM, the inferred type is: foldNM \n:: . a c r t. (a . r) . (. x. c x . t x . (x . r) . r) . NM c t a . r This generalization is useful \nbecause it can be used to de.ne in\u00adterpretations of a monadic computation that differ from the under\u00adlying \ntype. For example, we could de.ne compileJSM in terms of foldNM, but not in terms of lowerNM. A problem \narises when we try to use multiple interpretations that impose distinct constraints. Consider the type \nof the following pretty printer for set computations (its de.nition is straightforward, but unimportant \nto the discussion): prettySet :: Show a . NM Show Set a . String If we try to apply prettySet to s1 (from \nSection 3.2), type checking will fail because Show does not match Unconstrained. We can work around this \nby assigning s1 a more polymorphic type, thereby allowing it to be interpreted by both lowerSet and prettySet: \ns1 :: (c Char, c Int) . NM c Set (Int, Char) However, while this works in this case, there are limitations \nto this approach. We postpone demonstrating these limitations, and describing an approach to overcoming \nthem, until Section 6. 4. A Survey of Solutions The constrained-monad problem is well known, and a variety \nof techniques have been implemented or proposed to address it. In this section we survey the existing \nsolutions, and compare them to each other and the normalized deep-embedding approach. 4.1 Restricted \nData Types An early solution to the constrained-monad problem was Hughes restricted data types [12] proposed \nlanguage extension. The essence of the idea was to extend Haskell to support data types with at\u00adtached \nconstraints that scope over the entire type. Hughes s pro\u00adposed syntax is best seen by example: data \nOrd a . RSet a = ... Note however that this is intended to be semantically stronger than the existing \nmeaning of that same syntax in Haskell (which has since been deprecated). Furthermore, the proposal included \nintroducing a keyword wft (well-formed type) that would allow the constraints of a data type to be referenced. \nFor example, a context wft (RSet a) . ... would be semantically equivalent to Ord a . ... Type classes \ncould then refer to these attached constraints in their methods. For example: class Monad (m :: * . *) \nwhere return :: wft (m a) . a . m a (> =) :: (wft (m a), wft (m b)) . m a . (a . m b) . m b Instances \ncould then be declared for restricted data types such as RSet, as anyattached constraints are brought \ninto scope. Note that the keyword wft is crucial to this approach. Without the keyword, a restricted \ndata type is analogous to a GADT with the constraint on each constructor, except that it is necessary \nto pattern match on the constructor to bring the constraint into scope. However, this GADT approach is \ninsuf.ciently constraining: for example, an instance for sets would effectively require return to map \nany type a to a pair of Set a and an Ord a class dictionary, which is impossible to de.ne. The wft keyword \nis needed to allow the Ord constraint to scope over the argument type a. 4.2 Restricted Type Classes \nHughes [12] also suggested an alternative approach: de.ning re\u00adstricted type classes that take a class \nconstraint as a parameter. For example, a restricted monad could be de.ned as follows: class RMonad (c \n:: * . Constraint) (m :: * . *) where return :: c a . a . m a (> =) :: (c a, c b) . m a . (a . m b) . \nm b This was prior to the advent of constraint kinds so was not possible at the time, but several simulations \nof restricted type classes were encoded using various work-arounds [12, 18, 19, 35]. An alternative formulation \nof restricted type classes uses an associated type function [4] to map the data type to a constraint, \nrather than taking a constraint as a parameter [3, 29]. Such a function can be given a default de.nition \nas Unconstrained, which is convenient when declaring instances for data types that do not require a constraint \non their operations. For example: class RMonad (m :: * . *) where type Con m :: * . Constraint type Con \nm = Unconstrained return :: Con m a . a . m a (> =) :: (Con m a, Con m b) . m a . (a . m b) . m b instance \nRMonad Set where type Con Set = Ord return = returnSet (> =) = bindSet instance RMonad [ ] where return \na = [ a] ma > = k = concatMap k ma The restricted-type-class solutions do not require anymodi.ca\u00adtion \nto the data types involved, but theydo require either the exist\u00ading type classes to be modi.ed, or new \ntypes classes to be added. In the former case existing code will break, in the latter case the new code \nwill not be compatible with the existing, unrestricted, classes. Thus, for this to be practical, a class \nauthor must anticipate the need for constraints when de.ning the class [12].  4.3 Normalizing using \nDeep Embeddings The idea of separating the monadic structure of a computation from its interpretation \nwas pioneered by the Unimo framework [24], and then later used by the MonadPrompt [15] and Operational \n[2] libraries. The same idea was used by Swierstra [38]to embed IO computations, albeit formulated somewhat \ndifferently using free monads (see Section 5.2). Normalization is not an essential part of separating \nstructure from interpretation, but it does have the advantage of enforcing the monad laws: without normalization \nit is possible to de.ne an interpretation that exhibits different behavior for computations that are \nequivalent according to the monad laws.  The .rst use of normalization to overcome the constrained\u00admonad \nproblem of which we are aware was in the RMonad li\u00adbrary [35]. The central feature of this library is \na restricted-monad class, RMonad. This class is similar to the restricted monads de\u00adscribed in Section \n4.2, except that it is implemented using a data family [20], with the constructors of the family containing \nthe con\u00adstraints. We believe this implementation choice was made because constraint kinds were not then \navailable; the implementation could now be simpli.ed using the associated-type-function approach. The \nRMonad library also provides a (non-normalized) deep embedding over the RMonad class, with an accompanying \nMonad instance. The library provides a function to interpret that deep embedding, which normalizes the \nstructure and lowers it to the underlying re\u00adstricted monad. This is essentially the same technique as \npresented in Section 3, using normalization to ensure that the necessary con\u00adstraints hold whenever the \n(restricted) > = of the restricted monad is applied. The differences are that an RMonadinstance is required, \nand that the only interpretation of the embedding is as that under\u00adlying RMonad. 4.3.1 Using the Operational \nLibrary While Unimo, MonadPrompt and Operational do not explicitly handle constraints, it is possible \nto leverage their deep embedding and normalization functionality when addressing the constrained\u00admonad \nproblem. We will demonstrate this by encoding the tech\u00adnique from Section 3 using Operational, and we \nnote that Unimo and MonadPrompt could use a similar encoding. The core of Operational is a deep embedding \nof a normalized monadic computation, which is essentially our NMdata type with\u00adout the constraint parameter3: \ndata Program :: (* . *) . * . * where Return :: a . Program t a Bind :: t x . (x . Program t a) . Program \nt a For Program to be able to handle constraints, we have to embed the desired constraint into an underlying \ntype. This can be achieved using a GADT: data FinVec :: * . * where FV :: Finite a . Vec a . FinVec a \n When de.ning an interpretation, we can pattern match on the GADT to bring the constraint into scope, \nfor example (where lowerProgis de.ned similarly to lowerNM): lowerVec :: Eq a . Program FinVec a . Vec \na lowerVec = lowerProg returnVec (.(FV vx ) k . bindVec vx k) This is okay if the user always wants to \nwork with speci.c pairs of primitive operations and constraints, but does not allow for situa\u00adtions where \nthe user wants to write code that treats one as polymor\u00adphic and the other as specialized. However, this \ncan be addressed by abstracting over the constraint and primitive operations: data Box :: (* . Constraint) \n. (* . *) . * . * where Box :: c a . t a . Box c t a lowerVec :: Eq a . Program (Box Finite Vec) a . \nVec a lowerVec = lowerProg returnVec (.(Box vx ) k . bindVec vx k) 3We simplify slightly, as the Operational \nimplementation uses monad trans\u00adformers and views, but our encoding is valid using the actual library. \nWe could now, for example, assign the following polymorphic type to the s1 computation: s1 :: (c Char, \nc Int) . Program (Box c Set) (Int, Char) 4.3.2 Constraining the Primitive Operations If the type of \nprimitive operations is a GADT, then as an alternative to using the Box type from Section 4.3.1, the \ndesired constraint can instead be placed within each constructor of the GADT that contains polymorphic \ntypes, for example: type JSM (a :: *) = Program JS a data JS :: * . * where If :: Sunroof a . JSBool \n. JSM a . JSM a . JS a . . . Instead of pattern matching on the Box GADT, we can now intro\u00adduce the \nconstraint by performing a case analysis on the primitive operation. The disadvantages of this approach \nare that primitive op\u00aderations must not be an abstract data type, that syntactic clutter is introduced \nin the form of repeated constraints, and that additional case analyses may sometimes be required. However, \na signi.cant advantage is that it becomes possible to constrain existential types that occur within the \nprimitive-operation GADT, or to have differ\u00adent constraints on different constructors. For example, the \nPrompt and Alert constructors can be generalized to a single Call construc\u00adtor that is polymorphic in \nits argument and result type, provided those types have Sunroof instances: data JS :: * . * where Call \n:: (Sunroof a, Sunroof b) . JSFunction a b . a . JS b . . . Indeed, this is how Sunroof is actually implemented, \nusing Opera\u00adtional for the monadic deep embedding and normalization [6].  4.4 Normalizing using Continuations \nUnimo, Operational, RMonad, and our constrained normal mon\u00adads are all similar in that theynormalize \nthe structure of a monadic computation by capturing that structure as a deep embedding. How\u00adever, an \nalternative means of normalizing a monadic computation is to use continuations. Consider the following \ntypes: type ContT (r :: *) (t :: * . *) (a :: *) = (a . t r) . t r type CodT (t :: * . *) (a :: *) = \n. r. (a . t r) . t r These are known as the continuation monad transformer [23] and the codensity monad \ntransformer [14, 16]. Note however that both ContT r t and CodT t form a monad, regardless of whether \nthe underlying type t is a monad4: instance Monad (CodT t) where return :: a . CodT t a return a = .h \n. h a (> =) :: CodT t a . (a . CodT t b) . CodT t b ca > = k = .h . ca (.a . (k a) h) A Monad instance \nfor ContT is declared in the same way: ContT is just a special case of CodT that .xes the result type \nr . Primitive operations can be lifted into (or lowered from) the codensity monad by providing a > =-like \nor return-like function, respectively: liftCodT :: (. r. t a . (a . t r) . t r) . t a . CodT t a liftCodT \nbind ta = bind ta lowerCodT :: (a . t a) . CodT t a . t a lowerCodT ret ca = ca ret 4As with Vec, we \nelide the detail that ContT and CodT must be newtypes for this to be valid Haskell.  A consequence of \nthese de.nitions is that any monadic computa\u00adtion constructed in the CodT monad will construct a normalized \ncomputation with respect to the underlying > =-like and return\u00adlike functions. A useful analogy for what \nhappens, suggested by Voigtl\u00a8ander [40], is that it is like using difference lists [11] to right\u00adassociate \nnested applications of string concatenation. Alternatively, observe that each primitive operation always \nappears as the .rst argument to the underlying > =-like function, as that function is partially applied \nto the primitive during lifting. And there is always exactly one use of the return-like function, which \nis when it is used as the .nal continuation during lowering. This infrastructure can be used to address \nthe constrained\u00admonad problem, for example: liftVec :: Finite a . Vec a . CodT Vec a liftVec = liftCodT \nbindVec lowerVec :: Eq a . CodT Vec a . Vec a lowerVec = lowerCodT returnVec During lifting the .rst \ntype parameter of bindVec is exposed, so it can be constrained with Finite. During lowering, the type \nparame\u00adter of returnVec is exposed, so it can be constrained with Eq. However, what is not exposed is \nthe second type parameter to bindVec, which is the universally quanti.ed r hidden inside CodT. For the \nvector example that is not a problem, but if we try to lift a Set in a similar manner then the de.nition \nwill not type check because r is required to satisfy an Ord constraint. Perhaps then we should use ContT \ninstead of CodT, as that exposes a .xed result type that we could constrain? While that would work, it \nwould be unnecessarily restrictive. We don t need r to be a speci.c type, merely for it to satisfy Ord. \nTherefore, we de.ne what we shall call the restricted codensity transformer: type RCodT (c :: * . Constraint) \n(t :: * . *) (a :: *) = . r. c r . (a . t r) . t r This type expresses exactly what we need: the result \ntype can be any type that satis.es c. This gives rise to lifting and lowering functions with the following \ntypes: liftRCodT :: (. r. c r . t a . (a . t r) . t r) . t a . RCodT c t a lowerRCodT :: c a . (a . \nt a) . RCodT c t a . t a Thus, the shallow constrained-monad problem can be overcome using the restricted \ncodensity transformer with comparable ease to using a normalized deep embedding. However, the two approaches \nare not equivalent, as becomes evident when we consider inter\u00adpretations other than lowering to the underlying \ntype. The deep\u00adembedding approach allows multiple interpretations to be given to a monadic computation, \nwhereas the codensity approach only al\u00adlows a single interpretation. That single interpretation is essentially \nhard-wired into the computation, as the > =-like operation is par\u00adtially applied to each primitive operation \nwhen it is lifted. There is a work-around though. Rather than using the primi\u00adtive operations directly, \nwe can .rst construct a deep embedding of a monadic computation over the primitive-operation type, and \nthen use that deep embedding as the underlying type of the re\u00adstricted codensity monad. Regardless of \nhow return and > = are then used, the result after lowering will be a normalized deep em\u00adbedding. That \ndeep embedding can then be interpreted in whatever way is desired. This is essentially the approach taken \nby Persson et al. [30]to overcome the monad-rei.cation problem in the Syn\u00adtactic library, though they \nbuild their own specialized type around the continuation monad, rather than de.ning the general-purpose \nrestricted codensity transformer as we have here. In our opinion, using the codensity technique for the \ndeep constrained-monad problem in this manner is more complicated than using the normalized-deep-embedding \napproach, as it requires two levels of structure rather than one: the codensity transformer to perform \nthe normalization, and then the deep embedding to allow multiple interpretations. Whereas a normalized \ndeep embedding provides both with a single structure. Finally, we observe that this two-level approach \ncould be employed with any solution to the constrained-monad problem that only permits one interpretation, \nsuch as the RMonad library.  4.5 Normalization and Ef.ciency That continuations can be used to overcome \nthe constrained-monad problem has been an obscure piece of functional-programming folklore for several \nyears [26], but, to our knowledge, the only published use of the technique was when Persson et al. [30] \nused it in Syntactic. There have been other uses of continuations to nor\u00admalize monadic computations, \nbut with the aim of improving ef\u00ad.ciency. For example, Voigtl\u00a8ander [40] uses the codensity trans\u00adformer \nto improve the ef.ciency of the tree-substitution monad. This is possible because the monad laws only \nguarantee the equiv\u00adalence of the semantics of two monadic computations; the laws do not guarantee the \nequivalence of operational behavior. However, normalization is not always bene.cial to perfor\u00admance. \nFor example, normalizing a set-monad computation de\u00adfers elimination of duplicate elements until the \nend, rather than eliminating duplicates in intermediate results [35]. That is, the per\u00adformance of a \nnormalized set monad will typically be no better than converting to a list, using the list monad, and \nthen converting back to a set again. Note that this change in operational behavior is a consequence of \nthe normalization, and applies regardless of whether a deep embedding or the codensity transformer is \nused to achieve that normalization. Conversely, using a restricted monad does not cause a change in operational \nbehavior, as no normaliza\u00adtion of structure occurs (but nor are the monad laws enforced). 5. The Constrained-Type-Class \nProblem The focus of this paper has been monads; a choice we made be\u00adcause of the widespread use of monads \nin functional programming. However, the essence of the problem that some data types can\u00adnot be made \ninstances of some type classes because of the presence of class constraints on their operations is not \nspeci.c to monads, nor are the techniques for overcoming it. In this section we demon\u00adstrate that the \nsolutions to the constrained-monad problem are more widely applicable, by applying them to several related \ntype classes: Functor, Applicative and MonadPlus. 5.1 The Constrained-Functor Problem Consider the Functor \ntype class (Figure 3). As with the Monad class methods, sometimes the only mapping function that exists \nfor a data type imposes constraints on its type parameters, thereby preventing a Functor instance from \nbeing declared. For example: mapSet :: Ord b . (a . b) . Set a . Set b mapVec :: (Finite a, Eq b) . (a \n. b) . Vec a . Vec b We have the same options for addressing this problem as we had for monads. Thus, \nif we are prepared to use a new type class, then we could de.ne a restricted functor class: class RFunctor \n(c :: * . Constraint) (f :: * . *) where fmap :: (c a, c b) . (a . b) . f a . f b We could also use \nthe variant that has an associated type function that maps to a constraint, rather than a constraint \nparameter. On the other hand, if we want to use the standard Functor class, then we can take the normalization \napproach. The normal form for functors is fairly simple: a single fmapapplied to a single primitive operation. \nThis ensures that all existential types within the com\u00adputation appear as parameters on the (single) \nprimitive operation.  class Functor (f :: * . *) where fmap :: (a . b) . f a . f b fmap id = id fmap \ng . fmap h = fmap (g . h) (identity) (composition) Figure 3. Functors and the functor laws. Normalization \nconsists of applying the functor composition law to fuse together all uses of fmap. Taking the deep-embedding \napproach to normalization, we can de.ne constrained normal functors as follows: data NF :: (* . Constraint) \n. (* . *) . * . * where FMap :: c x . (x . a) . t x . NF c t a instance Functor (NF c t) where fmap \n:: (a . b) . NF c t a . NF c t b fmap g (FMap h tx) = FMap (g . h) tx --composition law liftNF :: c a \n. t a . NF c t a liftNF ta = FMap id ta --identity law lowerNF :: (. x. c x . (x . a) . t x . t a) . \nNF c t a . t a lowerNF fmp (FMap g tx) = fmp g tx Notice the similarities to constrained normal monads \n(Section 3.2): we de.ne the normal form as a GADT, declare a Functor instance by using laws to convert \nto that normal form, de.ne a lifting function by using an identity law, and de.ne a lowering function \nthat takes interpretations of the constructors as arguments. We can also take the codensity approach \nto normalization, but instead of the codensity transformer, we need to use the related Yoneda functor \ntransformer [21], which generates a functor (but not a monad) for anyt :: * . *: type Yoneda (t :: * \n. *) (a :: *) = . r. (a . r) . t r instance Functor (Yoneda t) where fmap :: (a . b) . Yoneda t a . Yoneda \nt b fmap g ya = .h . ya (h . g) As with codensity, we introduce a restricted version of this trans\u00adformer \nby adding a constraint parameter: type RYoneda (c :: * . Constraint) (t :: * . *) (a :: *) = . r. c r \n. (a . r) . t r We can then de.ne lifting and lowering functions as follows: liftRYoneda :: (. r. c \nr . (a . r) . t a . t r) . t a . RYoneda c t a liftRYoneda fmp ta = .h . fmp h ta lowerRYoneda :: c \na . RYoneda c t a . t a lowerRYoneda ya = ya id Notice that liftRYoneda takes an fmap-like function \nas an argu\u00adment this means that the interpretation of fmap is hard-wired during construction in a similar \nmanner to the interpretation of > = when using the codensity transformer for monads.  5.2 Aside: Free \nMonads Every functor induces a monad, known as the free monad [38, 40] of that functor: data Free (f \n:: * . *) (a :: *) = Pure a | Impure (f (Free f a)) instance Functor f . Monad (Free f) where return \n:: a . Free f a return = Pure (> =) :: Free f a . (a . Free f b) . Free f b (Pure a) > = k = k a (Impure \n.a ) > = k = Impure (fmap (> =k) .a ) The data type Free is a deep embedding of a monadic computa\u00adtion, \nand thus can be given multiple interpretations [38]. Yet this embedding is not as deep as the NM embedding, \nas it always uses class Applicative (f :: * . *) where pure :: a . f a (.) :: f (a . b) . f a . f b pure \nid . fa = fa ((pure (.) . fa) . fb) . fc = fa . (fb . fc) pure g . pure a = pure (g a) fg . pure a \n= pure (.g . g a) . fg (identity) (composition) (homomorphism) (interchange) Figure 4. Applicative functors \nand the applicative-functor laws. the fmap of the underlying functor, rather than allowing it to be given \nmultiple interpretations. We .nd it helpful to think of this as constructing a monad from fmap, return \nand join, where fmap is shallowly embedded and return and join are deeply embedded. Aside from the lack \nof constraint parameter, the keydistinction between the two embeddings is that, to induce a monad, Free \nrequires the underlying type to be a Functor, whereas NMdoes not. However, we showed in Section 5.1 that \nit is possible to generate a functor for anyt::* . *, by using a deep embedding. This provides an alternative \nway to construct a deep embedding of a monadic computation: take the free monad over the deep embedding \nof a functor. Doing so results in a type isomorphic to a deep embedding of a normalized monad. This can \nbe seen informally as follows: Free (NF c t) a NM c t a Pure a Return a Impure (FMap k tx) Bind tx \nk  5.3 The Constrained-Applicative-Functor Problem Applicative functors [25] (Figure 4) are a structure \nthat lies between functors and monads, and the usual problem arises if we want to de\u00adclare an instance \nfor a data type with constrained operations. De.n\u00ading a class of restricted applicative functors is as \nstraightforward as de.ning restricted monads or restricted functors, so we will just discuss the normalization \napproach. The normal form for applicative functors [7] consists of a left\u00adnested sequence of .s (pronounced \napply ) terminating in a pure (Figure 5). Our deep embedding of this normal form is as follows: data \nNAF :: (* . Constraint) . (* . *) . * . * where Pure :: a . NAF c t a Ap :: c x . NAF c t (x . a) . t \nx . NAF c t a De.ning an Applicative instance and lifting function require ap\u00adplying the laws of the \nstructure (Figure 4), as usual: instance Applicative (NAF c t) where pure :: a . NAF c t a pure = Pure \n(.) :: NAF c t (a . b) . NAF c t a . NAF c t b (Pure g) . (Pure a) = Pure (g a) --homomorphism n1 . (Pure \na) = Pure (.g . g a) . n1 --interchange n1 . (Ap n2 tx) = Ap (Pure (.) . n1 . n2 ) tx --composition liftNAF \n:: c a . t a . NAF c t a liftNAF ta = Ap (Pure id) ta --identity While in many ways similar, there is \nan important difference between the normal forms for monads and applicative functors. For monads, the \ntop-level type parameter is propagated along the spine of the normal form, giving the same result type \nat each node (type a in Figure 2). Whereas for applicative functors the type of each node differs, as \nthe function type is progressively saturated with type arguments (see Figure 5). Furthermore, the type \nof Pure differs from the top-level type parameter. Consequently, an interpretation of applicative functors \nhas to be able to handle these existential types. This is not an obstacle, but does lead to heavy use \nof rank-2 types when assigning a type to those interpretations. For example:  f a f (x n . a) f x n \n prim . a) f x(n-1) prim f (x2 . . . . n f (x1 . x2 . . . . . xn . a) f x1 pure g prim Figure 5. Anormal \nform for applicative computations. foldNAF :: . a c r t. (. x. x . r x) . (. y z. c y . r (y . z) . t \ny . r z) . NAF c t a . r a foldNAF pur app = foldNAF ' where foldNAF ' :: . b. NAF c t b . r b foldNAF \n' (Pure b) = pur b foldNAF ' (Ap n tx) = app (foldNAF ' n) tx The reader may now expect us to de.ne a \ntransformer similar to Codensity and Yoneda, but that generates an applicative functor. However, we were \nunable to .nd such a transformer, as we will now explain. Initially we did not know what type the transformer \nshould have, so we started with the lifting function. We wanted the lifting function to partially apply \n., such that the primitive appears as its second argument, which gave us the following type: liftAFT \n:: (. r. t (a . r) . t a . t r) . t a . AFT t a liftAFT app ta = .tg . app tg ta From this, we inferred \na type for the transformer: type AFT t a = . r. t (a . r) . t r It was then straightforward to de.ne \na lowering function: lowerAFT :: (. x. x . t x) . AFT t a . t a lowerAFT pur ra = ra (pur id) However, \nwe were unable to de.ne an Applicative instance for AFT t, and have come to the conclusion that it is \nonly possible to de.ne such an instance if the underlying type t is itself an Applicative. As the problem \nwe are trying to overcome is that the underlying type is not an Applicative, this is no use to us. We \ndo not claim that there is no transformer type that could solve this problem for applicative functors. \nRather, we observe that we found it dif.cult to apply the Codensity/Yoneda approach to other structures, \nbecause it is not obvious what the transformer type should be. Arguably, this problem requires no more \ninventiveness than deciding on a normal form for the structure (which is needed for the deep-embedding \napproach). However, our experience has been that it is easier to devise a normal form than to devise \na suitable transformer type.  5.4 The Constrained-MonadPlus Problem Now consider the MonadPlus type \nclass (Figure 6). De.ning a restricted version of this type class is straightforward as usual, so we \nwill just discuss the normalization approach. We represent the MonadPlus normal form using two mutually \nrecursive data types: class Monad m . MonadPlus (m :: * . *) where mzero :: m a mplus :: m a . m a . \nm a mplus mzero a = a (left unit) mplus a mzero = a (right unit) mplus (mplus a b) c = mplus a (mplus \nb c) (associativity) mzero > = k = mzero (left zero)  mplus a b > = k = mplus (a > = k) (b > = k) (left \ndistribution) Figure 6. MonadPlus and the MonadPlus laws. type NMP c t a = MZero | MPlus (NMP ' c t a) \n(NMP c t a) data NMP ' :: (* . Constraint) . (* . *) . * . * where Return :: a . NMP ' c t a Bind :: \nc x . t x . (x . NMP c t a) . NMP ' c t a The .rst type, NMP, represents a normal form for the monoidal \nmplus/mzero operations. That normal form is just the free monoid (i.e. a list) over the second type, \nNMP ' . The normal form for NMP ' is the usual monadic normal form, except that the result of the second \nargument to Bind is the NMP type, rather than NMP ' . De.ning a MonadPlus instance for NMP proceeds in \na similar manner to the monad and applicative functor cases, so we direct the reader to our Constrained-Normal \nlibrary [34] for the details. The key step is the application of the left-distribution law (Figure 6) \nwhen an MPlus appears as the .rst argument to > =. Likewise, the accompanying lifting function involves \napplying the right-identity law (and the right-unit law), and the folding function takes inter\u00adpretations \nfor the four constructors as arguments.  5.5 Discussion The same idea underlies the normalization technique \nfor all of the structures we have considered, and for each structure we performed the same sequence of \nsteps. First, we identify a normal form that contains no existential types except those that appear on \nprimitive operations. Second, we de.ne a deep embedding of that normal form as a GADT. The GADT takes \na class constraint as a parameter, and places that constraint on anyexistential types within the GADT. \nThird, we declare the structure s class instance for the GADT;this instance normalizes the computation \nby applying the algebraic laws of the structure, which typically involves fusing pure computations and \nthereby eliminating intermediate existential types. Fourth, we de.ne a function to lift a primitive operation \ninto the normal form, which (for the structures we have considered) involved applying one or more identity \nlaws, and required the type parameter of the primitive operation to satisfy the class constraint. Finally, \nwe de.ne a fold for the computation, which takes interpretations for the operations of the structure \nas arguments. In sections 4.3.1 and 4.3.2 we discussed variant formulations of a deep embedding for monads \nthat place the class constraint either on the constructors of the primitive operations, or in a Box GADT \nthat can be used as a wrapper around the primitive operations. Both of those techniques generalize to \nthe other structures. The structures we considered in this section are all special\u00adizations or generalizations \nof monads. That is not a limitation of the technique; these are just well-known structures that we chose \nas a starting point. We are also investigating the Category and Arrow [13] type classes. Our initial \nresults show that Category is straightforward to normalize, as it has a monoidal structure, but that \nthere may not exist an Arrow normal form that ensures that all ex\u00adistential types appear as type parameters \non primitive operations. However, an intermediate structure consisting of a Category with an arr operation \n(but not a .rst)does have a suitable normal form: a sequence of alternating pure functions and primitives. \nWe are also interested in investigating recursive structures such as MonadFix and ArrowLoop, but this \nremains as future work.  Note that for some structures, full normalization is not required to eliminate \nall unconstrained existential types (and hence to allow the desired class instance). For example, normalizing \nthe monoidal structure of the MonadPlus class is unnecessary to infer any con\u00adstraints, as the mplus \nand mzero operations do not introduce any existential types; normalizing the monadic structure is suf.cient. \nIndeed, the RMonad library [35] takes the approach of only nor\u00admalizing the monadic structure, not the \nmonoidal structure. How\u00adever, an advantage of fully normalizing is that the monoid laws are enforced \nby construction, which is why we chose to do so. 6. Interpretations with Distinct Constraints In Section \n3.2 we demonstrated that it is possible to de.ne mul\u00adtiple interpretations for a constrained normal monad \n(lowerSet and prettySet), even if those interpretations impose different con\u00adstraints. However, that \napproach does not allow both interpretations to be applied to the same computation if they impose distinct \ncon\u00adstraints. Even if the computation is de.ned to be polymorphic in its constraint parameter, two copies \nof the computation have to be con\u00adstructed, one for each interpretation. This is a more general problem \nthat af.icts any data type that has a constraint parameter, but for\u00adtunately Jones et al. [17] have recently \ndeveloped a technique for addressing it. In this section we demonstrate the problem, and then show how \nJones et al. s technique can be applied to overcome it. While we only consider our constrained normal \nmonads, we note that this technique is also compatible with using a Box wrapper and the Operational library \n(Section 4.3.1), with placing the constraints on the constructors of the primitive operations (Section \n4.3.2), and with the other type classes discussed in Section 5. 6.1 Distinct Constraint Parameters are \nIncompatible Imagine that we wish to display all elements of all Finite types that appear within a vector \ncomputation. We could achieve this by de.ning a function of the following type: showFin :: NM FiniteShow \nVec a . String class (Finite a, Show a) . FiniteShow a where instance (Finite a, Show a) . FiniteShow \na where The de.nition of showFin is unimportant to the discussion; what matters is that it imposes a \nShow constraint on the existential types. The need for an auxiliary class representing the intersection \nof the Finite and Show constraints is irritating, but not a major concern. Now let us try to both display \nand evaluate a computation: --does not type check showAndLower :: Eq a . NM FiniteShow Vec a . (String, \nVec a) showAndLower v = (showFin v, lowerVec v) This does not type check because lowerVec requires its \nargument to have exactly the type NM Finite Vec a, and the constraints Finite and FiniteShow are distinct. \nTo overcome this, we would have to either de.ne a variant of lowerVec that uses FiniteShow instead of \nFinite, or modify the type of the existing lowerVec function. That is, we must either duplicate or modify \nexisting code, both of which are bad for modularity. In general, whenever we want to apply two (or more) \ninterpreta\u00adtions that impose distinct constraints to the same computation, we have to duplicate or modify \nthose interpretations to use a new type class representing the intersection of all the required constraints. \nNote that while in this example one constraint is strictly stronger than the other, in general different \ninterpretations can have disjoint constraints. We want a way to combine existing interpreters that have \ndistinct constraints without modifying those interpreters.  6.2 A List of Existential Types Jones et \nal. s key idea is that, rather than parameterizing a GADT on a constraint, we can parameterize it on \nthe set of types within that GADT. We can then constrain those types when we interpret the GADT, rather \nthan during construction. We will demonstrate this technique by applying it to our constrained normal \nmonads. We begin by replacing the constraint parameter with a list of types, making use of the data kinds \n[43] GHC extension: data NM :: [ *] . (* . *) . * . * where Return :: a . NM xs t a Bind :: Elem x xs \n. t x . (x . NM xs t a ) . NM xs t a Instead of the constraint parameter, the context of the Bind con\u00adstructor \nnow uses the Elem type class, which represents type-level list membership: class Elem (a :: *) (as :: \n[ *]) where . . . The intent is that Elem a as should only be satis.ed if the type a is an element of \nthe list of types as , and thus the xs parameter of NM limits the existential types that can appear on \nBind constructors. The de.nitions of the liftNM and foldNM functions remain unchanged from Section 3.2, \nbut their types are modi.ed to use Elem rather than a constraint parameter: liftNM :: Elem a xs . t a \n. NM xs t a foldNM :: . a r t xs. (a . r) . (. x. Elem x xs . t x . (x . r) . r) . NM xs t a . r To use \nthis list of types to constrain the existential types within the GADT, we need another type class: class \nAll (c :: * . Constraint) (as :: [ *]) where . . . The intent is that All c as should only be satis.ed \nif c holds for every type in the list as . We can then use All to constrain the existential types when \nde.ning an interpretation, for example: lowerVec :: (Eq a, All Finite xs) . NM xs Vec a . Vec a showFin \n:: (All Finite xs , All Show xs) . NM xs Vec a . String Our goal, combining multiple interpretations \nwith different con\u00adstraints, is now straightforward: showAndLower :: (Eq a, All Finite xs , All Show \nxs ) . NM xs Vec a . (String, Vec a) showAndLower v = (showFin v, lowerVec v) An explanation of the methods \nof the Elem and All classes, and how they are used, is beyond the scope of this paper, so we direct the \nreader to the original paper by Jones et al. [17]. 7. Conclusions In this paper we surveyed a variety \nof solutions to the constrained\u00admonad problem, some of which require modifying the data type (normalization, \nrestricted data types), and some of which require modifying the type class (restricted type classes). \nSome solutions are only proposals, as they require modi.cations to the Haskell language (restricted data \ntypes). Some solutions are better suited to the shallow version of the problem than the deep version \n(restricted monads, continuations), and some were straightforward to apply to other structures (normalized \ndeep embeddings, restricted type classes). Our solution using normalized deep embeddings with explicit \nconstraints on the existential types is pragmatic, simple to understand and implement, and useful in \npractice. A valid concern about our technique is whether the bene.ts of being able to de.ne a monad instance \nfor a data type with constrained operations outweigh the cost of applying the technique. We expect the \nanswer will vary between use cases. However, we observe that if a data type is provided abstractly by \na library, then it is possible for all of the work to be done internally by the library implementer. \nFor example, we have constructed an alternative to the Data.Set module, and made it available as the \nSet-Monad library [9]. This library provides an abstract type Set, with the same interface as Data.Set. \nHowever, it performs normalization internally, and thus is able to provide Monad and other instances \nfor its Set type. That is, the Set type it exposes corresponds to the SetM type described in Section \n2.2.  We think that awareness of the ability to reify computations expressed using structures containing \nexistential types will have a signi.cant impact on future EDSL designs. Both Syntactic\u00adbased EDSLs [30] \nand our own Sunroof [6] would be considerably weaker without this ability. Referring to our experience \nin Sun\u00adroof, the ability to perform monadic-bind rei.cation has led to a useful compiler that directly \nsupports multiple threading models and concurrency objects such as mutable variables and channels. We \nanticipate others using monadic-bind rei.cation to build other effect-based EDSLs. Acknowledgments We \nthank Andrew Farmer and Nicolas Frisby for suggesting the normal form and normalization algorithm for \napplicative functors. We also thank Heinrich Apfelmus and Ryan Ingram for observing that we could use \nthe Operational and MonadPrompt libraries to perform the monadic normalization, respectively. Finally, \nwe thank Ed Komp, Philip H\u00a8olzenspies and the anonymous reviewers for feedback on earlier versions of \nthis paper, and Edward Kmett for his helpful comments on restricted monads. This material is based upon \nwork supported by the National Science Foundation under Grant No. 1117569. References [1] S. Adams. Ef.cient \nsets a balancing act. Journal of Functional Programming, 3(4):553 561, 1993. [2] H. Apfelmus. The Operational \nmonad tutorial. The Monad.Reader, 15:37 55, 2010. [3] M. Bolingbroke. Constraint kinds for GHC, 2011. \nURL http: //blog.omega-prime.co.uk/?p=127. [4] M. M. T. Chakravarty, G. Keller, and S. Peyton Jones. \nAssociated type synonyms. In International Conference on Functional Programming, pages 241 253. ACM, \n2005. [5] C. Elliott, S. Finne, and O. de Moor. Compiling embedded languages. Journal of Functional Programming, \n13(3):455 481, 2003. [6] A. Farmer and A. Gill. Haskell DSLs for interactive web services. In Cross-model \nLanguage Design and Implementation, 2012. [7] J. Gibbons and B. C. dos Santos Oliveira. The essence of \nthe iterator pattern. Journal of Functional Programming, 19(3 4):377 402, 2009. [8] A. Gill. Type-safe \nobservable sharing in Haskell. In Haskell Sympo\u00adsium, pages 117 128. ACM, 2009. [9] G. Giorgidze, 2012. \nURL http://hackage.haskell.org/ package/set-monad. [10] P. Hudak. Modular domain speci.c languages and \ntools. In Interna\u00adtional Conference on Software Reuse, pages 134 142. IEEE Computer Society, 1998. [11] \nJ. Hughes. A novel representation of lists and its application to the function reverse . Information \nProcessing Letters, 22(3):141 144, 1986. [12] J. Hughes. Restricted data types in Haskell. In Haskell \nWorkshop, 1999. [13] J. Hughes. Generalising monads to arrows. Science of Computer Programming, 37(1 \n3):67 111, 2000. [14] G. Hutton, M. Jaskelioff, and A. Gill. Factorising folds for faster functions. \nJournal of Functional Programming, 20(3&#38;4):353 373, 2010. [15] R. Ingram and B. Felgenhauer, 2008. \nURL http://hackage. haskell.org/package/MonadPrompt. [16] M. Jaskelioff. Monatron: An extensible monad \ntransformer library. In Implementation and Application of Functional Languages 2008, volume 5836 of LNCS, \npages 233 248. Springer, 2011. [17] W. Jones, T. Field, and T. Allwood. Deconstraining DSLs. In In\u00adternational \nConference on Functional Programming, pages 299 310. ACM, 2012. [18] E. Kidd. How to make Data.Set a \nmonad, 2007. URL http://www.randomhacks.net/articles/2007/03/15/ data-set-monad-haskell-macros. [19] \nO. Kiselyov. Restricted monads, 2006. URL http://okmij.org/ ftp/Haskell/types.html#restricted-datatypes. \n[20] O. Kiselyov, S. Peyton Jones, and C. Shan. Fun with type functions. In Re.ections on the Work of \nC.A.R. Hoare, chapter 14, pages 301 331. Springer, 2010. [21] E. A. Kmett, 2013. URL http://hackage.haskell.org/ \npackage/kan-extensions. [22] K. L\u00a8aufer and M. Odersky. Polymorphic type inference and abstract data \ntypes. Transactions on Programming Languages and Systems, 16 (5):1411 1430, 1994. [23] S. Liang, P. Hudak, \nand M. Jones. Monad transformers and modular interpreters. In Principles of Programming Languages, pages \n333 343. ACM, 1995. [24] C. Lin. Programming monads operationally with Unimo. In In\u00adternational Conference \non Functional Programming, pages 274 285. ACM, 2006. [25] C. McBride and R. Paterson. Applicative programming \nwith effects. Journal of Functional Programming, 18(1):1 13, 2008. [26] M. Mitrofanov. A problem de.ning \na monad instance, 2009. URL http://www.haskell.org/pipermail/haskell-cafe/ 2009-November/068761.html. \n[27] E. Moggi. Computational lambda-calculus and monads. In Logic in Computer Science, pages 14 23. IEEE \nPress, 1989. [28] E. Moggi. Notions of computation and monads. Information and Computation, 93(1):55 \n92, 1991. [29] D. Orchard and T. Schrijvers. Haskell type constraints unleashed. In International Conference \non Functional and Logic Programming, pages 56 71. Springer, 2010. [30] A. Persson, E. Axelsson, and J. \nSvenningsson. Generic monadic con\u00adstructs for embedded languages. In Implementation and Application of \nFunctional Languages 2011, volume 7257 of LNCS, pages 85 99. Springer, 2012. [31] S. Peyton Jones, D. \nVytiniotis, S. Weirich, and G. Washburn. Simple uni.cation-based type inference for GADTs. In International \nConfer\u00adence on Functional Programming, pages 50 61. ACM, 2006. [32] S. Peyton Jones, D. Vytiniotis, S. \nWeirich, and M. Shields. Practical type inference for arbitrary-rank types. Journal of Functional Pro\u00adgramming, \n17(1):1 82, 2007. [33] F. Pfenning and C. Elliott. Higher-order abstract syntax. In Program\u00adming Language \nDesign and Implementation, pages 199 208. ACM, 1988. [34] N. Sculthorpe, 2013. URL http://hackage.haskell.org/ \npackage/constrained-normal. [35] G. Sittampalam and P. Gavin, 2008. URL http://hackage. haskell.org/package/rmonad. \n[36] M. Spivey. A functional theory of exceptions. Science of Computer Programming, 14(1):25 42, 1990. \n[37] J. Svenningsson and E. Axelsson. Combining deep and shallow embedding for EDSL. In Trends in Functional \nProgramming 2012, volume 7829 of LNCS. Springer. [38] W. Swierstra. Data types `a la carte. Journal of \nFunctional Program\u00adming, 18(4):423 436, 2008. [39] J. Vizzotto, T. Altenkirch, and A. Sabry. Structuring \nquantum effects: Superoperators as arrows. Mathematical Structures in Computer Sci\u00adence, 16(3):453 468, \n2006. [40] J. Voigtl \u00a8Asymptotic improvement of computations over free ander. monads. In Mathematics \nof Program Construction, pages 388 403. Springer, 2008. [41] P. Wadler. Comprehending monads. In LISP \nand Functional Program\u00adming, pages 61 78. ACM, 1990. [42] P. Wadler. The essence of functional programming. \nIn Principles of Programming Languages, pages 1 14. ACM, 1992. [43] B. A. Yorgey, S. Weirich, J. Cretin, \nS. Peyton Jones, D. Vytiniotis, and J. P. Magalh aes. Giving Haskell a promotion. In Types in Language \nDesign and Implementation, pages 53 66. ACM, 2012.     \n\t\t\t", "proc_id": "2500365", "abstract": "<p>In Haskell, there are many data types that would form monads were it not for the presence of type-class constraints on the operations on that data type. This is a frustrating problem in practice, because there is a considerable amount of support and infrastructure for monads that these data types cannot use. Using several examples, we show that a monadic computation can be restructured into a normal form such that the standard monad class can be used. The technique is not specific to monads, and we show how it can also be applied to other structures, such as applicative functors. One significant use case for this technique is domain-specific languages, where it is often desirable to compile a deep embedding of a computation to some other language, which requires restricting the types that can appear in that computation.</p>", "authors": [{"name": "Neil Sculthorpe", "author_profile_id": "81442614500", "affiliation": "The University of Kansas, Lawrence, KS, USA", "person_id": "P4261257", "email_address": "neil@ittc.ku.edu", "orcid_id": ""}, {"name": "Jan Bracker", "author_profile_id": "83058774157", "affiliation": "Christian-Albrechts-Universitat, Kiel, Germany", "person_id": "P4261258", "email_address": "jbra@informatik.uni-kiel.de", "orcid_id": ""}, {"name": "George Giorgidze", "author_profile_id": "81337489650", "affiliation": "Universitat Tuebingen, Tuebingen, Germany", "person_id": "P4261259", "email_address": "george.giorgidze@uni-tuebingen.de", "orcid_id": ""}, {"name": "Andy Gill", "author_profile_id": "81318489268", "affiliation": "The University of Kansas, Lawrence, KS, USA", "person_id": "P4261260", "email_address": "andygill@ittc.ku.edu", "orcid_id": ""}], "doi_number": "10.1145/2500365.2500602", "year": "2013", "article_id": "2500602", "conference": "ICFP", "title": "The constrained-monad problem", "url": "http://dl.acm.org/citation.cfm?id=2500602"}