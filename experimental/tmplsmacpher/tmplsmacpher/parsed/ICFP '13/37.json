{"article_publication_date": "09-25-2013", "fulltext": "\n A Practical Theory of Language-Integrated Query James Cheney Sam Lindley Philip Wadler The University \nof Edinburgh University of Strathclyde The University of Edinburgh jcheney@inf.ed.ac.uk Sam.Lindley@ed.ac.uk \nwadler@inf.ed.ac.uk Abstract Language-integrated query is receiving renewed attention, in part because \nof its support through Microsoft s LINQ framework. We present a practical theory of language-integrated \nquery based on quotation and normalisation of quoted terms. Our technique sup\u00adports join queries, abstraction \nover values and predicates, compo\u00adsition of queries, dynamic generation of queries, and queries with \nnested intermediate data. Higher-order features prove useful even for constructing .rst-order queries. \nWe prove a theorem character\u00adising when a host query is guaranteed to generate a single SQL query. We \npresent experimental results con.rming our technique works, even in situations where Microsoft s LINQ \nframework ei\u00adther fails to produce an SQL query or, in one case, produces an avalanche of SQL queries. \nCategories and Subject Descriptors D.1.1 [Applicative (Func\u00adtional) Programming]; D.3.1 [Formal De.nitions \nand Theory]; D.3.2 [Language Classi.cations]: Applicative (functional) lan\u00adguages; D.3.3 [Language Constructs \nand Features]; H.2.3 [Lan\u00adguages]: Query languages Keywords lambda calculus; LINQ; F#; SQL; quotation; \nanti\u00adquotation 1. Introduction What is the difference between theory and practice? In theory there is \nno difference, but in practice there is.1 A quarter-century ago, Copeland and Maier (1984) decried the \nimpedance mismatch between database and conventional pro\u00adgramming models, and Atkinson and Buneman (1987) \nspoke of The need for a uniform language (their emphasis), and observed that Databases and programming \nlanguages have developed al\u00admost independently of one another for the past twenty years. Smooth integration \nof database queries with programming lan\u00adguages, also known as language-integrated query, remains an \nopen problem. Language-integrated query is receiving renewed atten\u00adtion, in part because of its support \nthrough Microsoft s LINQ framework (Meijer et al. 2006; Syme 2006). 1 Attributed variously to Yogi Berra, \nWilliam T. Harbaugh, Karl Marx, Chuck Reid, and Jan L. A. van de Snepscheut. Permission to make digital \nor hard copies of all or part of this work for personal or classroom use is granted without fee provided \nthat copies are not made or distributed for pro.t or commercial advantage and that copies bear this notice \nand the full citation on the .rst page. Copyrights for components of this work owned by others than the \nauthor(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or republish, to \npost on servers or to redistribute to lists, requires prior speci.c permission and/or a fee. Request \npermissions from permissions@acm.org. ICFP 13, September 25 27, 2013, Boston, MA, USA. Copyright is held \nby the owner/author(s). Publication rights licensed to ACM. ACM 978-1-4503-2326-0/13/09. . . $15.00. \nhttp://dx.doi.org/10.1145/2500365.2500586  The problem is simple: two languages are more than twice \nas dif.cult to use as one language. The host and query languages often use different notations for the \nsame thing, and convenient abstrac\u00adtions such as higher-order functions and nesting may not be avail\u00adable \nin the query language. Interfacing between the two adds to the mental burden on the programmer and leads \nto complex code, bugs, and security holes such as SQL injection attacks. Wrapper libraries, such as JDBC, \nprovide raw access to high-performance SQL, but the resulting code is dif.cult to maintain. Object-relational \nmap\u00adping frameworks, such as Hibernate, provide an object-oriented view of the data that makes code easier \nto maintain but sacri.ces performance (Goldschmidt et al. 2008); and workarounds to re\u00adcover performance, \nsuch as framework-speci.c query languages, reintroduce the drawbacks of the two-language approach. We \npresent a practical theory of language-integrated query, con\u00adsisting of a theoretical model, T-LINQ, \nand a practical implemen\u00adtation, P-LINQ. Our approach is based on quotation and normali\u00adsation of quoted \nterms. Our approach can be used in off-the-shelf languages, such as F#, .ts with existing frameworks, \nsuch as Mi\u00adcrosoft LINQ, and does not require specialised type systems of the kind found in Ur (Chlipala \n2010) or our own work on Links (Cooper et al. 2007; Cooper 2009). In this paper we focus on SQL queries, \nalthough we believe the techniques adapt to other targets, such as XQuery, and may even be applicable \nto DSLs for domains other than query. Microsoft LINQ was released as a part of .NET Framework 3.5 in \nNovember 2007, and LINQ continues to evolve with new re\u00adleases. LINQ operators construct queries in a \nhost language, and LINQ providers translate these into a target language, such as SQL, XQuery, or GPU \ncode. In this paper we focus on Microsoft s LINQ to SQL provider, which targets Microsoft SQL Server. \nThere are variants of LINQ for C#, Visual Basic, and F#, among others. T-LINQ and P-LINQ correspond to \nLINQ for F#. Similar techniques may apply to C#, though it requires some tricks to support anti\u00adquotation \n(Petricek 2007b). A few details of F# 3.0 hinder smooth integration with P-LINQ, and we are working with \nMicrosoft to enable its wider use. Our formal theory T-LINQ is similar in scope, power, and trans\u00adlation \ntechnique to NRC (Buneman et al. 1994; Wong 1996) and to our own previous work on Links (Cooper et al. \n2007; Cooper 2009). NRC is a special-purpose, .rst-order query language, and does not address integration \ninto a general-purpose language. Links sup\u00adports higher-order queries and addresses integration, but \nrequires a special-purpose type-and-effect system. Our achievement here is to transpose most of the bene.ts \nof Links for language-integrated querying to a widely-used practical language. We had previously argued \nthat Links offered signi.cant bene.ts over LINQ. A precise comparison was dif.cult because LINQ, like \nmany practical systems, is large and not precisely de.ned. To explore the relationship between Links \nand LINQ, we formulated a core calculus capturing essential features of LINQ. In the course of formulating \nT-LINQ, we realised that many of the bene.ts of Links can in fact be achieved in LINQ, and we are pleased \nto offer P-LINQ as a widely-available alternative. Through a series of examples, we show how our technique \nsup\u00adports join queries, abstraction over values and predicates, compo\u00adsition of queries, dynamic generation \nof queries, and queries con\u00adtaining intermediate nested data. We believe our series of examples distills \nan important set of features, and may be of independent in\u00adterest. Among other things, these examples \ndemonstrate the value of higher-order functions and nesting in queries, even when the tar\u00adget query language, \nin this case SQL, is .rst-order and does not support nested data. We require that each query in the host \nlanguage generate ex\u00adactly one SQL query. Alluding to twin perils Odysseus sought to skirt when navigating \nthe straits of Medina, we seek to avoid Scylla and Charybdis. Scylla stands for the case where the system \nfails to generate a query, signalling an error. Charybdis stands for the case where the system generates \nmultiple queries, hindering ef.\u00adciency. The overhead of accessing a database is high, and to a .rst approximation \ncost is proportional to the number of queries. We particularly want to avoid a query avalanche, in the \nsense of Grust et al. (2010), where a single host query generates a number of SQL queries proportional \nto the size of the data. Current LINQ implementations may founder on either of these perils. Scylla: \nmany of our examples fail under either F# 2.0 or F# 3.0, and different examples fail in the two different \nsystems. Charybdis: one of our examples causes a query avalanche in F# 3.0. In Grust et al. (2010) avalanches \nare caused by queries with nested results; interestingly, the avalanche is caused by a query with .at \nresults, but with nested intermediate structure. The documentation for F# LINQ does not explain when \nhost queries may fail or when multiple SQL queries may be generated; trial and error is required to determine \nwhat does or does not work. Our work avoids these perils. For T-LINQ, we prove the Scylla and Charybdis \ntheorem, characterising when a host query is guar\u00adanteed to generate a single SQL query. All our examples \nare easily seen to satisfy the characterisation in the theorem, and indeed our theory yields the same \nSQL query for each that one would write by hand. For P-LINQ, we verify that its run time on our examples \nis comparable to that of F# 2.0 and F# 3.0, in the cases where those systems generate a query, and signi.cantly \nfaster in the one case where F# 3.0 generates an avalanche indeed, arbitrarily faster as the size of \nthe data grows. Our theory models only a fraction of the features of LINQ, but our practice applies to \nits entirety. T-LINQ supports queries formed from comprehensions, union, and existence tests, but excludes \nsort\u00ading, grouping, and aggregation; extending it to these other features is important future work. However, \nP-LINQ supports all features of LINQ, and we validate its coverage and performance, showing it has comparable \nruntime to F# 3.0 for all 62 database queries listed in the F# 3.0 documentation. The language features \nwe require are lambda abstraction, records and lists, comprehension notation, and quotation and anti\u00adquotation. \nQuotation and anti-quotation .rst appear in Lisp, and are also found in Scheme, Racket, Haskell (via \nTemplate Haskell), OCaml (via Camlp4), and F#. Quotation comes in two forms, closed and open; in the \nformer, quoted terms must contain no free quoted variables. All languages with quotation support closed \nquo\u00adtation, while only some support open quotation; in particular, F# only supports closed quotation. \nOur approach requires only closed quotation. We observe that one should abstract when possible in the \nquoted language rather than the host language, as this enables composition while restricting to closed \nquotation. Though it seems obvious in retrospect, that one should abstract when possible in the quoted \nlanguage came as a surprise to us; previously, we had assumed one people couples Figure 1. People as \na Database should abstract when possible in the host language, as is done when using open quotation. \nMany embedded domain speci.c languages (EDSLs) build ex\u00adpression trees as constructs of the host language. \nFor instance, in Nikola (Mainland and Morrisett 2010) or Feldspar (Axelsson et al. 2010; Axelsson and \nSvenningsson 2012), addition is overloaded so that a + b denotes either an integer (of type int) or a \nquotation of an expression that yields an integer (of type Expr< int >), de\u00adpending on whether a and \nb denote either the former or latter. For technical reasons, overloading does not apply to all operations, \nso users have the minor inconvenience of writing a < b as a . < . b and if a then b else c as a ? (b, \nc). In our case, quotation avoids this inconvenience, allowing terms in the embedded language to use \nidentical syntax to the host language. It is common for EDSLs to reuse the type system of the host language \nas the type system of the embedded language here we have, in effect, extended the same idea to syntax. \nThe contributions of this paper are: We introduce our technique, and through a series of exam\u00adples show \nhow it supports join queries, abstraction over val\u00adues and predicates, composition of queries, dynamic \ngeneration of queries, and nesting of intermediate data. We also present a larger example of translation \nfrom XPath to SQL, which illus\u00adtrates the power resulting from combining higher-order queries with language \nintegration. (Sections 2, 3, and 4).  We develop our theoretical model, T-LINQ, and prove standard results, \nincluding a theorem that normalisation always succeeds in translating any T-LINQ query to SQL. (Section \n5.)  We observe that one should abstract when possible in the quoted language rather than the host language, \nin order to support composition in the presence of closed quotation, and we show how closed quotation \ncan simulate open quotation. (Section 6 and 7.)  We describe our practical implementation, P-LINQ, and \npresent experimental results con.rming our technique works in prac\u00adtice. We observe that F# 2.0 or F# \n3.0 fail on key examples where we succeed; that when F# 2.0 or F# 3.0 succeed our per\u00adformance is comparable; \nthat when F# 3.0 avalanches our per\u00adformance is arbitrarily better as the problem size grows; and that \nwe handle with comparable performance all 62 database query examples in the F# 3.0 documentation. (Sections \n8 and 9.)  We discuss related work, and summarise our results in the form of a recipe that may apply \nto a wide variety of domain-speci.c languages. (Sections 10 and 11.)  Our implementation, examples, \nand experimental data are available online in the ACM Digital Library. 2. Fundamentals We consider a \nsimpli.ed programming language, based loosely on F# (Syme et al. 2012), featuring records and list comprehensions. \n {people = [{name = Alex ; age = 60}; {name = Bert ; age = 55}; {name = Cora ; age = 33}; {name = Drew \n; age = 31}; {name = Edna ; age = 21}; {name = Fred ; age = 60}]; couples = [{her = Alex ; him = Bert \n}; {her = Cora ; him = Drew }; {her = Edna ; him = Fred }]} Figure 2. People as Data We review the relationship \nbetween comprehensions and database queries and then introduce the use of quotation to construct queries. \n 2.1 Comprehensions and Queries For purposes of illustration, we consider a simple database con\u00adtaining \ntwo tables, shown in Figure 1. The .rst table, people, has columns for name and age, and the second table, \ncouples, has columns for her and him. (Schema update will be required once equal marriage legislation \npasses in Scotland.) Here is an SQL query that .nds the name of every woman that is older than her mate, \npaired with the difference in ages. select w.name as name, w.age - m.age as di. from couples as c, people \nas w, people as m where c.her = w.name and c.him = m.name and w.age > m.age It returns the following \ntable: Assuming the people table is indexed with name as a key, this query can be answered in time O(|couples|). \nThe database is represented in T-LINQ as a record of tables, where each table is represented as a list \nof rows, and each row is represented as a record of scalars. type DB = {people : {name : string; age \n: int} list; couples : {her : string; him : string} list} Following F#, we use lists to represent tables, \nand will not consider the order of their elements as signi.cant. We follow the notational conventions \nof F#, writing lists in square brackets and records in curly braces. Our language includes a construct \nthat takes the name of the database and returns its content as a data structure. let db' : DB = database( \nPeople ) If People is the name of the database in Figure 1, then db' is bound to the value shown in Figure \n2. We stick a prime on the name to warn that this is too naive: typically, the database will be too large \nto read into main memory. We consider a feasible alternative in the next section. Many programming languages \nprovide a comprehension nota\u00adtion offering operations over lists analogous to those provided by SQL over \ntables (Trinder and Wadler 1989; Buneman et al. 1994). F# also supports a form of comprehension notation \ncalled compu\u00adtation expressions (Petricek and Syme 2012). T-LINQ follows this approach, so the previous \nquery can be written as follows. let di.erences' : {name : string; di. : int} list = for c in db'.couples \ndo for w in db'.people do for m in db'.people do if c.her = w.name &#38;&#38; c.him = m.name &#38;&#38; \nw.age > m.age then yield {name : w.name; di. : w.age - m.age} Evaluating di.erences' returns the value \n[{name = Alex ; di. = 5}; {name = Cora ; di. = 2}] which corresponds to the table returned by the previous \nSQL query. Again, we stick a prime on the name to warn that this tech\u00adnique is too naive: typically, \nin-memory evaluation of a compre\u00adhension does not take advantage of indexing, and so requires time O(|couples| \n\u00b7 |people|2). We consider a feasible alternative in the next section. Here we use three constructs, similar \nto those supported in the sequence expressions of F#. The term for x in M do N binds x to each value \nin the list M and computes the list N, concatenating the results; in mathematical notation, we write \n{N | x . M}; note that x is free in M but bound in N. The term if L then M evaluates boolean L and returns \nlist M if it is true and the empty list otherwise. The term yield M returns a singleton list containing \nthe value of M. Many languages support similar notation, including Haskell, Python, C#, and F#. The T-LINQ \nterm for x in L do for y in M do if P then yield N is equivalent to the mathematical notation {N | x \n. L, y . M, P } or the F# sequence expression seq {for x in L do for y in M do if P then yield N}. \nThe last is identical to T-LINQ, save it is preceded by the keyword seq and surrounded by braces. 2.2 \nQuery via Quotation T-LINQ allows programmers to access databases using a notation nearly identical to \nthe naive approach of the previous section, but generating ef.cient queries in SQL. The recipe for conversion \nis as follows. First, we wrap the reference to the database inside quotation brackets, <@ \u00b7 \u00b7 \u00b7 @>. let \ndb : Expr< DB > = <@ database( People ) @> Next, we wrap the query inside quotation brackets, <@ \u00b7 \u00b7 \n\u00b7 @>, and wrap occurrences of any externally bound variable, such as db, in anti-quotation brackets, \n(% \u00b7 \u00b7 \u00b7 ). let di.erences : Expr< {name : string; di. : int} list > = <@ for c in (%db).couples do for \nw in (%db).people do for m in (%db).people do if c.her = w.name &#38;&#38; c.him = m.name &#38;&#38; \nw.age > m.age then yield {name : w.name; di. : w.age - m.age} @> Finally, to get the answer we evaluate \nthe term run(di.erences) (1) Evaluating (1) takes the quoted expression, normalises it, translates the \nnormalised expression to SQL, evaluates the SQL query on the database, and imports the resulting table \nas a data structure. In this case, the quoted expression is already in normal form, and it translates \ninto the SQL in the previous section, and so returns the table and answer seen previously. We drop the \nwarning primes, because the answer is computed feasibly by access to the database. The notation <@ \u00b7 \n\u00b7 \u00b7 @> indicates quotation, which views an ex\u00adpression of type A as a data structure of type Expr< A \n> that repre\u00adsents the expression as an abstract syntax tree. The notation (% \u00b7 \u00b7 \u00b7 ) indicates anti-quotation, \nwhich splices a value of type Expr< A > into a quoted expression at a point expecting a quoted term of \ntype A. Database access, indicated by the keyword database, denotes the value of the database viewed \nas a record of tables, where each table is a list of rows, and each row is a record of scalars. Database \naccess is only permitted within quotation, as its use outside quota\u00adtion would require reading the entire \ndatabase into main memory, which is in general infeasible. Query evaluation, indicated by the keyword \nrun, takes an expression of type Expr< A >, normalises it, translates the normalised expression to SQL, \nevaluates the SQL query on the database, and imports the result as a data structure of type A. Some restrictions \nare required on the abstract syntax tree in a run expression in order to ensure that it may be successfully \ntrans\u00adlated to SQL. First, all database literals within a given query must refer to a single database \non which the query is to be evaluated. Second, the return type must be a .at relation type, that is, \na list of records with .elds of scalar type. Third, the expression must not contain operations that cannot \nbe converted to SQL, such as recur\u00adsion. (Technically, SQL supports some forms of recursion, such as \ntransitive closure, but current LINQ systems do not.) Fourth, we re\u00adstrict our attention to queries built \nfrom sequence comprehensions, emptiness tests, and sequence union. In T-LINQ, these restrictions are \nstatically checked (in the case of the .rst restriction, by only supporting one database); in P-LINQ, \nthese restrictions are dynam\u00adically checked. T-LINQ captures the essence of query processing in Microsoft \nLINQ, particularly as it is expressed in F#. However, the details of Microsoft LINQ are more complicated, \ninvolving three types Expression<A>, IEnumerable<A> and IQueryable<A> that play overlapping roles, together \nwith implicit type-based coercions in\u00adcluding a type-based approach to quotation in C# and Visual Ba\u00adsic, \nplus special additional query notations in C#, Visual Basic, and F# 3.0. We relate our model to the pragmatics \nof LINQ in Section 8.  2.3 Abstracting over Values Our quoted language supports abstraction. Here is \na query that .nds the names of all people with ages in a given range, inclusive of the lower bound but \nexclusive of the upper bound. type Names = {name : string} list let range : Expr< (int, int) . Names \n> = <@ fun(a, b) . for w in (%db).people do if a = w.age &#38;&#38; w.age < b then yield {name : w.name} \n@> We insist that the answer type always corresponds to a table, so here we return a list of records \nwith a name .eld, rather than just a list of strings. Here we have abstracted in the quoted language \nrather than the host language. As we shall see, this is essential to being able to reuse queries .exibly \nin constructing other queries. As we explain in Section 6, we recommend abstracting in the quoted language \nrather that the host language whenever possible, because it supports composition. Here we use the usual \nF# notation for function abstraction. Function applications inside queries normalise by beta reduction: \n(fun(x) . N)(M) . N[x := M], where N [x := M] denotes the capture-avoiding substitution of terms M for \nvariables x in term N. We form a speci.c query by instantiating the parameters: run(<@ (%range)(30, 40) \n@>) (2) Evaluating (2) .nds everyone in their thirties: [{name = Cora }; {name = Drew }] In this case, \nthe term passed to run is not quite in normal form: it requires one step of beta-reduction, substituting \nthe actuals 30 and 40 for the formals a and b. More generally, we can instantiate arbitrary values by \nuse of the lift operator, which lifts a value of some base type O into a quoted expression of type Expr< \nO >. let a = 30 let b = 40 run(<@ (%range)(lift(a), lift(b)) @>) This returns the same value as the \nprevious query. 2.4 Abstracting over a Predicate In general, we may abstract over an arbitrary predicate. \nlet satis.es : Expr< (int . bool) . Names > = <@ fun(p) . for w in (%db).people do if p(w.age) then yield \n{name : w.name} @> A predicate over ages is denoted by a function from integers to booleans. We form \na speci.c query by instantiating the predicate: run(<@ (%satis.es)(fun(x) . 30 = x &#38;&#38; x < 40) \n@>) (3) Evaluating (3) yields the same query as (2). In this case, the term passed to run requires two \nsteps of beta-reduction to normalise. The .rst step replaces p by the function, and enables the second \nstep, which replaces x by w.age. We can instantiate the query with any predicate, so long as it only \ncontains operators available in SQL: run(<@ (%satis.es)(fun(x) . x mod 2 = 0) @>) (4) Evaluating (4) \n.nds everyone whose age is even. It would not work if, say, the predicate invoked recursion. 2.5 Composing \nQueries Uniformly de.ning queries as quotations makes it easy to compose queries. Say that given two \nnames, we wish to .nd the names of everyone at least as old as the .rst but no older than the second. \nTo express this concisely, we de.ne an auxiliary query that .nds a person s age. let getAge : Expr< string \n. int list > = <@ fun(s) . for u in (%db).people do if u.name = s then yield u.age @> If names are keys, \nthis will return at most one age. It returns a list of integers, not a list of records, so it is not \nsuitable for use as a query on its own, but may be used inside other queries. We may now form our query \nby composing two uses of the auxiliary getAge with the query range. let compose : Expr< (string, string) \n. Names > = <@ fun(s, t) . for a in (%getAge)(s) do for b in (%getAge)(t) do (%range)(a, b) @> We form \na speci.c query by instantiating the parameters. run(<@ (%compose)( Edna , Bert ) @>) (5)  Evaluating \n(5) yields the value: [{name = Cora }; {name = Drew }; {name = Edna }] Unlike the previous examples, \nnormalisation of this query requires rules other than beta-reduction; it is described in detail in Sec\u00adtion \n5.4.  2.6 Dynamically Generated Queries We now consider dynamically generated queries. The following \nalgebraic datatype represents predicates over integers as abstract syntax trees. type Predicate = | Above \nof int | Below of int | And of Predicate \u00d7 Predicate | Or of Predicate \u00d7 Predicate | Not of Predicate \nWe take Above(a) to denote all ages greater than or equal to a, and Below(a) to denote all ages strictly \nless than a, so each is the negation of the other. For instance, the following trees both specify predicates \nthat select everyone in their thirties: let t0 : Predicate = And(Above(30), Below(40)) let t1 : Predicate \n= Not(Or(Below(30), Above(40))) Given a tree representing a predicate we can compute the quo\u00adtation of \na function representing the predicate. We make use of the lift operator, which lifts a value of some \nbase type O into a quoted expression of type Expr< O >. The de.nition is straightforward. let rec P(t \n: Predicate) : Expr< int . bool > = match t with | Above(a). <@ fun(x) . (%lift(a)) = x @> | Below(a) \n. <@ fun(x) . x < (%lift(a)) @> | And(t, u) . <@ fun(x) . (%P(t))(x) &#38;&#38; (%P(u))(x) @> | Or(t, \nu) . <@ fun(x) . (%P(t))(x) || (%P(u))(x) @> | Not(t) . <@ fun(x) . not((%P(t))(x)) @> For instance, \nP(t0) returns <@ fun(x) . (fun(x) . 30 = x)(x) &#38;&#38; (fun(x) . x < 40)(x) @> Applying normalisation \nto the above simpli.es it to <@ fun(x) . 30 = x &#38;&#38; x < 40 @>. Note how normalisation enables \nmodular construction of a dynamic query. We can combine P with the previously de.ned satis.es to .nd \nall people that satisfy a given predicate: run(<@ (%satis.es)(%P(t0)) @>) (6) Evaluating (6) yields the \nsame query as (2) and (3). We may also instantiate to a different predicate: run(<@ (%satis.es)(%P(t1)) \n@>) (7) Evaluating (7) yields the same answer as (6), though it normalises to a slightly different term, \nwhere the test 30 = w.age &#38;&#38; w.age < 40 is replaced by not(w.age < 30 || 40 = w.age). This series \nof examples illustrates our key result: including ab\u00adstraction in the quoted language and normalising \nquoted terms sup\u00adports abstraction over values, abstraction over predicates, composi\u00adtion of queries, \nand dynamic generation of queries. 3. Nesting We now consider nested data, and show further advantages \nof the use of normalisation before execution of a query. {departments = [{dpt = Product }; {dpt = Quality \n}; {dpt = Research }; {dpt = Sales }]; employees = [{dpt = Product ; emp = Alex }; {dpt = Product ; emp \n= Bert }; {dpt = Research ; emp = Cora }; {dpt = Research ; emp = Drew }; {dpt = Research ; emp = Edna \n}; {dpt = Sales ; emp = Fred }]; tasks = [{emp = Alex ; tsk = build }; {emp = Bert ; tsk = build }; {emp \n= Cora ; tsk = abstract }; {emp = Cora ; tsk = build }; {emp = Cora ; tsk = design }; {emp = Drew ; tsk \n= abstract }; {emp = Drew ; tsk = design }; {emp = Edna ; tsk = abstract }; {emp = Edna ; tsk = call \n}; {emp = Edna ; tsk = design }; {emp = Fred ; tsk = call }]} Figure 3. Organisation as Flat Data For \npurposes of illustration, we consider a simpli.ed database representing an organisation, with tables \nlisting departments, em\u00adployees belonging to each department, and tasks performed by each employee. Its \ntype is Org, de.ned as follows. type Org = {departments : {dpt : string} list; employees : {dpt : string; \nemp : string} list; tasks : {emp : string; tsk : string} list } We bind a variable to a reference to \nthe relevant database. let org : Expr< Org > = <@ database( Org ) @> The corresponding data is shown \nin Figure 3. The following parameterised query .nds departments where every employee can perform a given \ntask u. let expertise ' : Expr< string . {dpt : string} list > = <@ fun(u) . for d in (%org).departments \ndo if not(exists( for e in (%org).employees do if d.dpt = e.dpt &#38;&#38; not(exists( for t in (%org).tasks \ndo if e.emp = t.emp &#38;&#38; t.tsk = u then yield { }) )) then yield { }) )) then yield {dpt = d.dpt} \n@>  Evaluating run(<@ (%expertise )( abstract ) @>) (8) .nds departments where every employee can abstract: \n[{dpt = Quality }; {dpt = Research }] There are no employees in the Quality department, so it will be \ncontained in the result of this query regardless of the task speci.ed. Query expertise ' works as follows. \nThe innermost for yields an empty record for each task t performed by employee e that is equal to u; \nthe resulting list is empty if employee e cannot perform task u. The middle for yields an empty record \nfor each employee e in department d that cannot perform task u; the resulting list is empty if every \nemployee in department d can perform task u. Therefore, [{dpt = Product ; employees = [{emp = Alex ; \ntasks = [ build ]} {emp = Bert ; tasks = [ build ]}]}; {dpt = Quality ; employees = []}; {dpt = Research \n; employees =  [{emp = Cora ; tasks = [ abstract ; build ; design ]}; {emp = Drew ; tasks = [ abstract \n; design ]}; {emp = Edna ; tasks = [ abstract ; call ; design ]}]}; {dpt = Sales ; employees = [{emp \n= Fred ; tasks = [ call ]}]}] Figure 4. Organisation as Nested Data the outermost for yields departments \nwhere every employee can perform task u. We stick a prime on the name to warn that the query is hard \nto read. Using nested intermediate data structures will help us formulate a more readable equivalent. \n3.1 Nested Structures An alternative way to represent an organisation uses nesting, where each department \nrecord contains a list of employees and each em\u00adployee record contains a list of tasks: type NestedOrg \n= {dpt : string; employees : {emp : string; tasks : string list} list} list We convert the .rst representation \ninto the second as follows: let nestedOrg : Expr< NestedOrg > = <@ for d in (%org).departments do yield \n{dpt = d.dpt; employees = for e in (%org).employees do if d.dpt = e.dpt then yield {emp = e.emp; tasks \n= for t in (%org).tasks do if e.emp = t.emp then yield t.tsk}}} @> If org is bound to the data in Figure \n3, then nestedOrg is bound to the data in Figure 4. We cannot write run(nestedOrg) to compute this value \ndirectly, because run requires an argument that is .at, and the type of nestedOrg is nested. However, \nit can be convenient to use nestedOrg to formulate other queries, as we now show.  3.2 A Query over \na Nested Structure For convenience, we de.ne several higher-order queries. The .rst takes a predicate \nand a list and returns true if the predicate holds for any item in the list. let any : Expr< (A list, \nA . bool) . bool > = <@ fun(xs, p) . exists(for x in xs do if p(x) then yield { }) @> The second takes \na predicate and a list and returns true if the predicate holds for all items in the list. It is de.ned \nin terms of any using De Morgan duality. let all : Expr< (A list, A . bool) . bool > = <@ fun(xs, p) \n. not((%any)(xs, fun(x) . not(p(x)))) @> The third takes a value and a list and returns true if the value \nappears in the list. It is also de.ned in terms of any. let contains : Expr< (A list, A) . bool > = <@ \nfun(xs, u) . (%any)(xs, fun(x) . x = u) @> All three of these resemble well-known operators from functional \nprogramming, and similar operators with the same names are pro\u00advided in Microsoft s LINQ framework. We \nde.ne all three as quo\u00adtations, so that they may be used in queries. We de.ne a query equivalent to expertise \n' as follows: let expertise : Expr< string . {dpt : string} list > = <@ fun(u) . for d in (%nestedOrg) \nif (%all)(d.employees, fun(e) . (%contains)(e.tasks, u) then yield {dpt = d.dpt} @> Evaluating run(<@ \n(%expertise)( abstract ) @>) (9) yields the same query as the previous example, (8). In order for this \nto work, normalisation must not only perform beta-reduction, but also perform various reductions on sequence \nex\u00adpressions that are well known from the literature on conservativity results. The complete set of reductions \nthat we require is discussed in Section 5. 4. From XPath to SQL So far, all of our examples (except satis.es) \ncould have been writ\u00adten in a higher-order variant of SQL, implemented using normal\u00adisation; they do \nnot illustrate the full power of our approach. We now consider the problem of dynamic generation of SQL \nqueries that simulate XPath queries over XML data represented as rela\u00adtions. This requires not only support \nfor higher-order queries within SQL, but also the capability to construct queries dynamically using recursion \nand other host language features. We represent tree-structured XML in a relation using stretched pre-order \nand post-order indexes; see, for example, Grust et al. (2004, sec. 4.2). Each node of the tree corresponds \nto a row in a table xml with schema: type Node = {id : int, parent : int, name : string, pre : int, post \n: int} The id .eld uniquely identi.es each node; the parent .eld refers to the identi.er of the node \ns parent (or -1 for the root node); the name .eld stores the element tag name; and the pre and post .elds \nstore the position of the opening and closing brackets of the node in its serialisation. For example, \nFigure 5 shows an XML tree and its tabular representation. The datatypes Axis and Path, de.ned below, \nrepresent the ab\u00adstract syntax of a fragment of XPath. type Axis = type Path = | Self | Seq of Path \u00d7 \nPath | Child | Axis of Axis | Descendant | Name of string | DescendantOrSelf | Filter of Path | Following \n| FollowingSibling | Rev of Axis The Axis datatype de.nes the primitive forward axes and Rev to reverse \nthe axes (the reverse of child is parent, the reverse of descendant is ancestor, and so on). The Path \ndatatype de.nes Seq to concatenate two paths, Axis to de.ne an axis step, Name to test whether an element \ns name is equal to a given string, and Filter to test whether a path expression is satis.able from a \ngiven node. Figure 6 gives the complete code of an evaluator for this frag\u00adment of XPath, which generates \none SQL query per XPath query. The functions axis and path are de.ned by case analysis over the datatypes \nAxis and Path, respectively; they yield predicates that  id parent name pre post 0 1 2 3 4 5 6 -1 0 \n1 2 1 4 4 #doc a b c d e f 0 1 2 3 6 7 9 13 12 5 4 11 8 10 (base) O ::= int | bool | string \n(type) A, B ::= O | A . B | {e : A} | A list | Expr< A > (table) T ::= {e : O} list (env t) G, . ::= \n\u00b7 | G, x : A (term) L, M, N ::= c | op(M) | lift M | x | fun(x) . N | L M | rec f(x) . N | {e = M} | \nL.e | yield M | [ ] | M @ N | for x in M do N | exists M | if L then M | run M | <@ M @> | database(db) \n| (%M) xml Figure 5. XML Tree and Tabular Representation Figure 7. Syntax of T-LINQ let rec axis(ax : \nAxis) : Expr< (Node, Node) . bool > = match ax with | Self . <@ fun(s, t) . s.id = t.id @> | Child . \n<@ fun(s, t) . s.id = t.parent @> | Descendant . <@ fun(s, t) . s.pre < t.pre &#38;&#38; t.post < s.post \n@> | DescendantOrSelf . <@ fun(s, t) . s.pre = t.pre &#38;&#38; t.post = s.post @> | Following . <@ \nfun(s, t) . s.post < t.pre @> | FollowingSibling . <@ fun(s, t) . s.post < t.pre &#38;&#38; s.parent \n= t.parent @> | Rev(axis) . <@ fun(s, t) . (%axis(ax))(t, s) @> let rec path(p : Path) : Expr< (Node, \nNode) . bool > = match p with | Seq(p, q) . <@ fun(s, u) . (%any)((%db).xml, fun(t) . (%path(p))(s, t) \n&#38;&#38; (%path(q))(t, u)) @> | Axis(ax) . axis(ax) | Name(name) . <@ fun(s, t) . s.id = t.id &#38;&#38; \ns.name = name @> | Filter(p) . <@ fun(s, t) . s.id = t.id &#38;&#38; (%any)((%db).xml, fun(u) . (%path(p))(s, \nu)) @> let xpath(p : Path) : Expr< int list > = <@ for root in (%db).xml do for s in (%db).xml do if \nroot.parent = -1 &#38;&#38; (%path(p))(root, s) then yield s.id @> Figure 6. An Evaluator for XPath \nhold when two nodes are related by the given axis or path. The function xpath translates a Path p to \na query expression that re\u00adturns each node in the table that matches p, starting from the root. In our \ntests we consider the following example paths. xp0 = /*/* (10) xp1 = //*/parent::* (11) xp2 = //*[following-sibling::d] \n(12) xp3 = //f[ancestor::*/preceding::b] (13) Translation of XPath to Path is straightforward; for example, \nxp0 is Seq(Axis(Child), Axis(Child)). The four queries yield the results [2, 4], [1, 2, 4], [2], and \n[6], respectively on the example data in Figure 5. While this is a small fragment of XPath, there is \nno obstacle to adding other features such as attributes, boolean operations on .lters, or tests on text \ndata. 5. Core Language In this section we give a formal account of T-LINQ as a lambda calculus with comprehension, \nquotation, and constructs to access a database and run queries. Queries are constructed by quotation, \nand crucially! the quoted term is normalised as part of the pro\u00adcess of issuing a query. In practice, \nhost and quoted languages are usually identical, but this is a design choice. In T-LINQ, there are small, \nbut important, differences between the host and quoted languages. 5.1 Typing Rules The syntax of types \nand terms is given in Figure 7 and the typing rules are given in Figure 8. There are two typing judgements, \none for host terms and one for quoted terms. Judgement G f M : A states that host term M has type A in \ntype environment G, and judgement G; . f M : A states that quoted term M has type A in host type environment \nG and quoted type environment .. For simplicity, we assume that all queries are on a single database \ndb; in practice, we check dynamically that each query refers to a single database. We assume a signature \nS that maps each constant c, each primitive operator op, and the database db to its type. Most of the \ntyping rules are standard, and mirrored across both judgements; we list here the rules that differ. Recursion \nis only available in a host term (RE C); other operations available to the host but not the database \nmay be modelled similarly. The database is only available in a quoted term (DATA BA S E). A term of base \ntype O can be lifted to a quoted term of type Expr< O > (LI F T). A quoted term of table type T can be \nevaluated as a query (RU N). The rule for quoting requires the quoted type environment to be empty, ensuring \nquoted terms are closed (QUOT E). The rule for splicing is the only place the host type environment G \nis referenced in the typing rules for quoted terms (ANTI QU OT E). 5.2 Operational Semantics The syntax \nof values and evaluation contexts is given in Figure 9. Values are standard, save that we add values \n<@ Q @>, where Q is a quotation value, a quoted term in which all anti-quotes have been resolved. We \nwrite [V ] to abbreviate yield V1 @ \u00b7 \u00b7 \u00b7@ yield Vn @ [ ]. The semantics is parameterised by an interpretation \nd for each primitive operation op, and an interpretation O for the database db, both of which respect \ntypes: if S(op) = O . O and f V : O and V = d(op, V ) then f V : O, and f O(db) : S(db). Reduction M \n-. N is the relation in Figure 10. We write -. * for the re.exive and transitive closure of -.. The rules \nare standard apart from those for quotation and query evaluation. All of the rules are interpreted relative \nto a .xed database; the eval func\u00adtion evaluates the query against this database. Evaluation contexts \nE enforce left-to-right call-by-value evaluation, and quotation con\u00adtexts Q are contexts over quoted \nterms that have no anti-quotation to the left of the hole. Rule (lift) converts a constant into a quoted \nconstant, and rule (splice) resolves an anti-quote once its body has been evaluated to a quotation. Rule \n(run) evaluates a quotation value Q by .rst normalising Q to yield an equivalent SQL query S = norm(Q), \nand then evaluating S on the database to yield the G f M : A CO N S T OP LI F T VA R FU N S(c) = A \nS(op) = (O) . O G f M : O G f M : O x : A . G G, x : A f N : B G f c : A G f op(M) : O G f lift M : Expr< \nO > G f x : A G f fun(x) . N : A . B AP P RE C RE C O R D PRO J E C T G f L : A . B G f M : A G, f : \nA . B, x : A f N : B G f M : A G f L : {e : A}G f L M : B G f rec f(x) . N : A . B G f {e = M} : {e : \nA} G f L.ei : Ai SI N G L E TO N EM P T Y UN I O N FO R G f M : A G f M : A list G f N : A list G f M \n: A list G, x : A f N : B list G f yield M : A list G f [ ] : A list G f M @ N : A list G f for x in \nM do N : B list EX I S T S IF RU N QU OT E G f M : A list G f L : bool G f M : A list G f M : Expr< T \n> G; \u00b7 f M : A G f exists M : bool G f if L then M : A list G f run M : T G f <@ M @> : Expr< A > G; \n. f M : A CO N S T Q OPQ S(c) = A S(op) = (O) . O G; . f M : O G; . f c : A G; . f op(M) : O AP P Q \nRE C O R D Q G; . f L : A . B G; . f M : A G; . f M : A G; . f L M : B G; . f {e = M} : {e : A} EM P \nT Y Q UN I O N Q G; . f M : A list G; . f N : A list VA R Q FU N Q x : A . . G; ., x : A f N : B G; \n. f x : A G; . f fun(x) . N : A . B PRO J E C T Q G; . f L : {e : A}G; . f L.ei : Ai SI N G L E T O N \nQ G; . f M : A G; . f yield M : A list FO R Q G; . f M : A list G; ., x : A f N : B list  G; . f [ ] \n: A list G; . f M @ N : A list G; . f for x in M do N : B list EX I S T S Q IFQ DATA BA S E AN T I Q \nU OT E G; . f M : A list G; . f L : bool G; . f M : A list S(db) = {e : T } G f M : Expr< A > G; . f \nexists M : bool G; . f if L then M : A list G; . f database(db) : {e : T } G; . f (%M) : A Figure 8. \nTyping Rules for T-LINQ value V = eval(O, S). De.ne eval(O, Q) = V when O(Q) -. * V , where O(Q) replaces \neach occurrence of database(db) in Q by O(db). The following section de.nes norm(Q), and shows that normalisation \npreserves types and meaning: if \u00b7; \u00b7 f Q : T and S = norm(Q) then f S : T and eval(O, S) = eval(O, Q). \nIt is straightforward to show that type soundness holds, via the usual method of preservation and progress. \nPRO P O S IT IO N 1. If G f M : A and M -. N then G f N : A. If G f M : A then either M is a value or \nM -. N for some N.  5.3 Query Normalisation In this section we establish the Scylla and Charybdis theorem: \nEvery quoted term of .at type can be normalised to a term that is isomorphic to a single SQL query. Query \nnormalisation is central to our technique. Similar tech\u00adniques go back to Wong (1996), and the work here \nis based directly on Cooper (2009) and Lindley and Cheney (2012). The query nor\u00admalisation function norm \nis based on two reduction relations, sym\u00adbolic reduction, P Q, and ad-hoc reduction, P Y . Q. We write \n* and Y. * for the re.exive and transitive closure of and Y. respectively. De.ne norm(P ) = R when P \n* Q and Q YR, . * where Q and R are in normal form with respect to and Y., re\u00adspectively. Symbolic reduction \nP Q is the compatible closure of the rules in Figure 11. The rules are straightforward, including beta\u00adreduction \nfor functions, records, and booleans, plus the usual laws for monads with sums (Trinder 1991). Terms \nin normal form under this relation satisfy the subformula property: with the exception of predicates \n(such as < or exists), the type of a subterm must be a subformula of either the type of a free variable \nor of the type of the term (Prawitz 1965). Hence, symbolic reduction eliminates nesting from a term that \nreturns a value of table type. Ad-hoc reduction, P Y . Q, is the compatible closure of the rules in \nFigure 12. These reductions account for the lack of unifor\u00admity in SQL. Rule (for-@), which hoists a \nunion out of a compre\u00adhension body, is the only rule that is not sound for a list semantics, since it \nchanges the order in which elements are generated. Rewriting preserves types and meaning. PRO P O S \nITI O N 2. If f P : A and P Q or P YQ then . f Q : A and eval(O, P ) = eval(O, Q). The normal form of \na query is easy to compute because rewrites may be applied in any order and rewriting always terminates. \n (value) V, W ::= c | fun(x) . M | rec f(x) . M | {e = V }| [V ] | <@ Q @> (quotation value) P, Q, R \n::= c | op(Q) | lift Q | x | fun(x) . R | P Q | {e = Q} | P.e | yield Q | [ ] | Q @ R | for x in Q do \nR | exists Q | if P then Q | database(db) (evaluation context) E ::= [ ] | op(V , E, M) | lift E | E \nM | V E '' | {e = V , e ' = E, e = M} | E .e | yield E | E @ M | V @ E | for x in E do N | exists E | \nif E then M | run E | <@ Q[(%E)] @> (quotation context) Q ::= [ ] | op(Q, Q, M) | lift Q | fun(x) . Q \n| Q M | Q Q | {e = Q, e ' = Q, e '' = M }| Q.e | yield Q | Q @ M | Q @ Q| for x in Q do N | for x in \nQ do Q| exists Q | if Q then M | if Q then Q | run Q Figure 9. Values and Evaluation Contexts op(V ) \n-. d(op, V ) (fun(x) . N) V -. N[x := V ] (rec f(x) . N) V -. M[f := rec f(x) . N, x := V ] {e = V }.ei \n-. Vi if true then M -. M if false then M -. [ ] for x in yield V do M -. M[x := V ] for x in [ ] do \nN -. [ ] for x in L @ M do N -. (for x in L do N ) @ (for x in M do N) exists [] -. false exists [V ] \n-. true, |V | > 0 run <@ Q @> -. eval(norm(Q)) (run) lift c -. <@ c @> (lift) <@ Q[(%<@ Q @>)] @> -. \n<@ Q[Q] @> (splice) M -. N E[M] -. E [N] Figure 10. Operational Semantics for T-LINQ PRO P O S IT IO \nN 3. Both and Y. are con.uent and strongly nor\u00admalising for typed terms. The proof is straightforward. \nFactoring into two relations makes the strong normalisation proof easier than in Cooper (2009). The grammar \nof normalised terms, given in Figure 13, is essen\u00adtially isomorphic to a subset of SQL. The correspondence \nis not quite exact, because the SQL standard has no notation for empty records, and lacks constructs \nfor an empty table or to access a table or table variable directly (the .rst constructs of S, X, and \nY , re\u00adspectively); but these idiosyncrasies are easy to work around, and are handled already by LINQ. \nIt is straightforward to establish that if Q is a closed term of table type T , then its normalisation \nexists and matches the grammar of S. PRO P O S IT IO N 4 (Scylla and Charybdis). If f Q : T then there \nexists an S such that S = norm(Q). (fun(x) . R) Q R[x := Q] {e = Q}.ei Qi for x in (yield Q) do R R[x \n:= Q] (for-yld) for y in (for x in P do Q) do R for x in P do (for y in Q do R) (for-for) for x in (if \nP then Q) do R if P then (for x in Q do R) (for-if) for x in [ ] do N [ ] for x in (P @ Q) do R (for \nx in P do R) @ (for x in Q do R) if true then Q Q if false then Q [ ] Figure 11. Normalisation Stage \n1: symbolic reduction for x in P do (Q @ R) Y. (for-@) (for x in P do Q) @ (for x in P do R) for x in \nP do [ ] Y. [ ] if P then (Q @ R) Y. (if P then Q) @ (if P then R) if P then [ ] Y. [ ] if P then (if \nQ then R) Y. if (P &#38;&#38; Q) then R (if-if) if P then (for x in Q do R) Y. for x in Q do (if P then \nR) (if-for) Figure 12. Normalisation Stage 2: ad-hoc reduction (SQL query) S ::= [ ] | X | X1 @ X2 (collection) \nX ::= database(db) | yield Y | if Z then yield Y | for x in database(db).e do X (record) Y ::= x | {e \n= Z}(base) Z ::= c | x.e | op(X) | exists S Figure 13. Syntax of Normalised Terms  5.4 An Example As \nan example of normalisation, we consider evaluation of query (5) from Section 2.5. run(<@ (%compose)( \nEdna , Bert ) @>) After splicing, the quotation becomes: (fun(s, t) . for a in (fun(s) . for u in database( \nPeople ).people do if u.name = s then yield u.age)(s) do for b in (fun(s) . for u in database( People \n).people do if u.name = s then yield u.age)(t) do (fun(a, b) . for w in database( People ).people do \nif a = w.age &#38;&#38; w.age < b then yield {name : w.name})(a, b)) ( Edna , Bert ) For stage 1 (Figure \n11), applying four beta-reductions yields: for a in (for u in database( People ).people do if u.name \n= Edna then yield u.age) do for b in (for u in database( People ).people do if u.name = Bert then yield \nu.age) do for w in database( People ).people do if a = w.age &#38;&#38; w.age < b then yield {name : \nw.name}  Continuing stage 1, applying each of rules (for-for), (for-if), and (for-yld) twice, and renaming \nto avoid capture, yields: for u in database( People ).people do if u.name = Edna then for v in database( \nPeople ).people do if v.name = Bert then for w in database( People ).people do if u.age = w.age &#38;&#38; \nw.age < v.age then yield {name : w.name} For stage 2 (Figure 12), applying rule (if-for) thrice and rule \n(if-if) twice yields: for u in database( People ).people do for v in database( People ).people do for \nw in database( People ).people do if u.name = Edna &#38;&#38; v.name = Bert &#38;&#38; u.age = w.age \n&#38;&#38; w.age < v.age then yield {name : w.name} This is in normal form, and easily converted to SQL. \nRunning it yields the answer given previously. 6. Quoted Language vs. Host Language We write in a style \nwhere we abstract in the quoted language whenever possible. As we shall see, this is essential if several \nfunctions are to be composed into a single query, as in Section 2.5. We abstract in the host language \nonly when we need a feature not present in the quoted language, such as recursion, as used to construct \ndynamic queries in Sections 2.6 and 4. Another style, which might at .rst appear appealing, is to al\u00adways \nabstract in the host language. For instance, one might rede.ne range from Section 2.3 as follows. let \nrange ' (a : Expr< int >, b : Expr< int >) : Expr< Names > = <@ for w in (%db).people do if (%a) = w.age \n&#38;&#38; w.age < (%b) then yield {name : w.name} @> (Or one might de.ne a variant where a and b have \ntype int and lifting is used, which raises similar issues.) Before, we wrote an invocation like this: \nrun(<@ (%range)(30, 40) @>). Now, we write an invocation like this: run(range ' (<@ 30 @>, <@ 40 @>)). \nThe latter may be slightly more ef.cient, as it directly yields a quotation in normal form, and no beta-reduction \nis required. For this reason, we had originally assumed that one should abstract in the host language, \nbut late in the process of writing this paper we realised this is a mistake. We stick a prime on the \nname to warn that this form of de.nition hinders composition. Let s see what goes wrong with composition. \nIn Section 2.5 we used range to de.ne compose. Attempting a revision using range ' yields the following. \nlet compose ' : Expr< (string, string) . Names > = <@ fun(s, t) . for a in (%getAge)(s) do for b in (%getAge)(t) \ndo (%range ' (<@ a @>, <@ b @>)) @> Warning: the above is not legal in F# (or T-LINQ)! Previously, all \nthe quotations we saw were closed, since every quoted variable is bound within the quotation; but the \ntwo quotations <@ a @> and <@ b @> passed to range ' are open, since they contain free quoted variables. \nIn this case, the variables become bound after splicing into the surrounding quotation, but, in general, \nopen quotations come with no guarantee that free variables meet their binding occurrences. For this reason, \nopen quotations are illegal in F# and in T-LINQ, and there is no easy way to use range ' to de.ne compose \n' . Typing closed quotation is straightforward in current languages, and is supported in F# or in any \nlanguage with GADTs (Cheney and Hinze 2003). In contrast, open quotation in a typed language requires \nsome form of specialised type system; experimental lan\u00adguages that support open quotation include MetaML \n(Taha and Sheard 2000) or Ur (Chlipala 2010), and a recent experimental feature in GHC supports MetaML \ntyping rules for quotations. We sketch a simple type system that supports open quotation in Sec\u00adtion \n7, and show how closed quotation can simulate that form of open quotation, which suggests how closed \nquotation may be ade\u00adquate for situations where one might have thought open quotation was required. While \nopen quotation avoids the cost of some beta-reductions, it does not avoid the need for the other normalisation \nrules discussed in Section 5.3. Further, the cost of normalising a quoted term is low compared to the \ncost of evaluating the resulting SQL query against the database, as demonstrated in Section 9. Thus, \nwe believe closed quotation and normalisation provide a practical alternative to more elaborate systems \nthat support open quotation. 7. Open Quotation Section 6 discussed the difference between closed and \nopen quota\u00adtion. T-LINQ and P-LINQ, like F#, support only closed quotation. Here we generalise T-LINQ \nto support a form of open quotation, and we show how this form may be simulated by closed quota\u00adtion. \nChoi et al. (2011) give a similar result. Our formalisation of open quotation is not as powerful as that \nfound in systems such as MetaML or Ur, but the translation is suggestive of why closed quotation may \nbe adequate for dealing with cases (such as compo\u00adsition of queries or dynamic generation of queries) \nthat one may previously have thought required open quotation. For the extension, we add a type environment \nto the type of quoted terms, generalising Expr< A > to Expr< .; A >, where . speci.es the types of the \nfree variables in the quoted term. Only four typing rules need to change. LI F T RU N G f M : O G f M \n: Expr< \u00b7; T > G f lift(M) : Expr< \u00b7; O > G f run M : T QU OT E AN T I Q U OT E G; . f M : A G f M : \nExpr< .; A > G f <@ M @>. : Expr< .; A > G; . f (%M). : A In order to allow syntax-directed typechecking, \nwe add type envi\u00adronment annotations to quotation and antiquotation expressions. To simulate the extended \nlanguage in the original, we represent an open quotation of type Expr< .; A > by a closed quotation of \ntype Expr< . . A >, explicitly abstracting over each of the free variables in the quoted type environment. \nWe specify translations of types, host terms, and query terms from the extended language back into the \noriginal language. There is only one case of interest for each translation. [Expr< .; A >] = Expr< [.] \n. [A] > [<@ M @>.] = <@ fun(.) . [M] @> [(%M).] = (%M) . All of the other cases are de.ned homomorphically. \nHere . on the right-hand side stands in the .rst line for a tuple of the types in the environment; in \nthe second line for a tuple of the bindings in the environment, over which the translation is abstracted; \nand in the third line for a tuple of the variables in the environment, to which the translation is applied. \nAll tuples must be consistently ordered, say alphabetically on the names of the variables in .. PRO \nP O S IT IO N 5. The translation preserves types, and the ex\u00adtended language is simulated by the original \nlanguage. If G f M : A then [G] f [M]. If G; . f M : A then [G]; [.] f [M] : [A]. If G f M : A and M \n-. N then [M] -. [N].  If G; . f M : A and M -. N then [M] -. [N].  8. Comparison to Microsoft LINQ \nT-LINQ abstracts from several distracting issues in the implemen\u00adtation of Microsoft LINQ for C#, Visual \nBasic, and F#. Microsoft s LINQ library includes interfaces IEnumerable<A> and IQueryable<A> that provide \nstandard query operators includ\u00ading selection, join, .ltering, grouping, sorting, and aggregation. These \nquery operators are de.ned to act both on sequences and on quotations that yield sequences. LINQ query \nexpressions in C# or Visual Basic are translated to code that calls the methods in these interfaces. \nFor example, a C# LINQ query from x in e where p(x) select f(x) translates to the sequence of calls e.Where(x \n. p(x)).Select(x . f(x)) Depending on the context, lambda-abstractions in C# and Visual Basic are treated \neither as functions or as quoted functions. Any external data source that can implement some of the query \noperations can be connected to LINQ using a query provider. Im\u00adplementing a query provider can be dif.cult, \nin part because of the overhead of dealing with the Expression<A> type. Eini (2011) characterises the \nexperience of writing a custom query provider as doom, gloom with just a tad of despair . Microsoft supplies \na LINQ to SQL query provider for SQL Server. Microsoft s query provider is proprietary, so its behaviour \nis a black box, but it does appear to perform some beta-reduction and other normalisation. As we have \nalready described, F# supports LINQ using syntac\u00adtic sugar for comprehensions (called computation expressions \n(Pet\u00adricek and Syme 2012)), quotations, and re.ection. In the F# Power-Pack library made available for \nF# 2.0, some LINQ capabilities are supported by a translator from the F# Expr< A > type to the LINQ Expression<A> \ntype. This implementation has some bugs and lim\u00aditations, for instance, it fails to translate arguments \nof exists in the test of a conditional. F# 3.0 supports LINQ through an improved translation based on \ncomputation expressions (Petricek and Syme 2012). In F# 3.0, one can simply write query{e} to indicate \nthat a computation ex\u00adpression e should be interpreted as a query; the standard library class QueryBuilder \ntranslates e to a C# LINQ expression and eval\u00aduates it. This implementation also has some bugs and limitations, \nfor instance, it forbids some uses of splicing, and does not correctly process some queries that start \nwith a conditional. 9. Implementation and Results To validate our design, we implemented a pre-processor \nthat takes any quoted F# sequence expression over the standard query oper\u00adators and normalises it as \ndescribed in Section 5.3. In theory, our normaliser could be followed by either the F# 2.0 or F# 3.0 \nback\u00adend, but the bugs noted in the previous section prevent some of our sample queries from working \nwith each. The F# 2.0 PowerPack is distributed as a separate library and easy to modify, while the F# \n3.0 backend is built-in and dif.cult to modify. Hence, for most of our experiments, we opted to use F# \n2.0 LINQ syntax and a modi.ed version of the F# 2.0 backend with our pre-processor. To All times in milliseconds. \n\u00d7 marks failures. Example F# 2.0 F# 3.0 P-LINQ norm di.erences (1) 17.6 20.6 18.1 0.5 range (2) \u00d7 5.6 \n2.9 0.3 satis.es (3) 2.6 \u00d7 2.9 0.3 satis.es (4) 4.4 \u00d7 4.6 0.3 compose (5) \u00d7 \u00d7 4.0 0.8 P(t0) (6) 2.8 \u00d7 \n3.3 0.3 P(t1) (7) 2.7 \u00d7 3.0 0.3 expertise ' (8) 7.2* 9.2 8.0* 0.6 expertise (9) \u00d7 66.7av 8.3* 0.9 xp0 \n(10) \u00d7 8.3 7.9 1.9 xp1 (11) \u00d7 14.7 13.4 1.1 xp2 (12) \u00d7 17.9 20.7* 2.2 xp3 (13) \u00d7 3744.9 3768.6* 4.4 \n* marks cases requiring modi.ed F# 2.0 PowerPack library. av marks the case where a query avalanche occurs. \n|people| = 10000, |couples| = 5000, |employees| = 5000, |tasks| = 4931, |xml| = 6527 Table 1. Experimental \nResults. experiment with grouping, aggregation and other operations that are only supported in F# 3.0, \nwe have also developed a proto\u00adtype that provides subclasses of the F# 3.0 QueryBuilder library class, \nalong with variants of the query{ \u00b7 \u00b7 \u00b7 } keyword, that per\u00adform normalisation before calling F# 3.0 \ns LINQ implementation. The QueryBuilder implementation employs some subtle tricks to support type-directed \ndispatch so that query{ \u00b7 \u00b7 \u00b7 } works for both in-memory and external database calls. Unfortunately, \nthese tricks make it dif.cult to smoothly override the QueryBuilder class to provide drop-in compatible \nbehaviour; in our implementation, we provide different variants of the query keyword for use in differ\u00adent \ncontexts. This limitation could easily be overcome by a change to the F# 3.0 QueryBuilder class, and \nwe are discussing this pos\u00adsibility with Microsoft. We use the term P-LINQ to refer to both implementations, \nand specify the back-end F# LINQ implementa\u00adtion used when it is relevant. All experiments were run on \na Dell OptiPlex 790 with Intel Core i5-2400 CPU at 3.10 GHz, 4GB RAM and a 7200 RPM hard drive with 8MB \ncache, and using Microsoft .NET 4.0 runtime, Visual Studio 2012 v11.0.50727.1, and SQL Server 2012, all \nrunning on the same machine to avoid any network-related latency. All reported times are the medians \nof 21 trials. All source code for the examples, the data, and the modi.ed F# 2.0 PowerPack library is \navailable online (Cheney et al. 2012). Table 1 summarises our experimental results. We wrote and ran \nversions of each example using the F# 2.0 PowerPack LINQ li\u00adbrary, the F# 3.0 LINQ library, and P-LINQ \n(using the F# 2.0 back\u00adend). We randomly generated data for the couples and organisation databases, and \nused an existing repository of XML data, with sizes as listed in the table. Each entry in the table either \nindicates that the query failed (\u00d7), or gives the total time in milliseconds for suc\u00adcessful evaluation, \nincluding time to generate the SQL query (or queries, in the case of an avalanche), to evaluate the query, \nand to construct a value from the result. For P-LINQ, the total includes time to normalise the quoted \nexpression; this is also shown sepa\u00adrately in the column labelled norm. F# 2.0 failed on seven examples, \nand F# 3.0 failed on .ve, though each succeeds on examples on which the other fails. The modi.ed PowerPack \nlibrary was required in one case by F# 2.0 and in four cases by P-LINQ. F# 3.0 generated an avalanche \nof SQL queries for query (9); this example query involves nested in\u00adtermediate data but its result is \n.at, in contrast to cases of avalanche Table 2. Comparison of F# 3.0 and P-LINQ (using F# 3.0 as a back-end) \non the 62 example database queries in the F# 3.0 documentation (Microsoft 2013). There are 67 examples \nin total; .ve query expressions (Q3, Q4, Q26, Q28, Q31) are excluded because they execute on in-memory \nlists rather than generate SQL.  Q# F# 3.0 P-LINQ norm Q# F# 3.0 P-LINQ norm Q# F# 3.0 P-LINQ norm Q1 \nQ2 Q5 Q6 Q7 Q8 Q9 Q10 Q11 Q12 Q13 Q14 Q15 Q16 Q17 Q18 Q19 Q20 Q21 Q22 Q23 2.0 1.5 1.7 1.7 1.5 2.3 2.3 \n1.4 1.4 4.4 2.5 2.5 3.5 3.5 6.2 1.5 1.5 1.5 1.6 1.6 1.6 2.4 1.7 2.1 2.1 1.8 2.4 2.7 1.7 1.7 4.9 2.9 2.9 \n4.0 4.0 6.7 1.8 1.8 1.8 1.9 1.9 1.9 0.3 0.2 0.3 0.3 0.2 0.2 0.3 0.2 0.2 0.4 0.4 0.3 0.5 0.5 0.4 0.2 0.2 \n0.2 0.3 0.3 0.3 Q24 Q25 Q27 Q29 Q30 Q32 Q33 Q34 Q35 Q36 Q37 Q38 Q39 Q40 Q41 Q42 Q43 Q44 Q45 Q46 Q47 1.8 \n1.4 1.8 1.5 1.8 2.7 2.8 3.1 3.1 2.2 1.3 4.2 4.2 4.1 6.3 4.7 7.2 5.4 2.2 2.3 2.1 2.0 1.6 2.1 1.7 2.0 3.1 \n3.1 3.6 3.6 2.4 1.6 4.9 4.7 4.6 7.3 5.5 6.9 6.2 2.6 2.7 2.5 0.3 0.2 0.2 0.2 0.2 0.3 0.3 0.5 0.4 0.2 0.2 \n0.6 0.4 0.4 0.6 0.5 0.7 0.7 0.3 0.4 0.3 Q48 Q49 Q50 Q51 Q52 Q53 Q54 Q55 Q56 Q57 Q58 Q59 Q60 Q61 Q62 Q63 \nQ64 Q65 Q66 Q67 2.1 2.4 2.2 2.0 6.1 11.9 4.4 5.2 4.6 2.5 2.5 3.1 3.6 5.8 5.4 3.4 4.3 10.2 8.9 14.7 2.5 \n2.7 2.5 2.4 5.9 11.2 4.8 5.6 5.1 2.9 2.9 3.6 4.4 6.3 5.9 3.8 4.9 10.1 8.7 13.1 0.3 0.3 0.3 0.3 0.4 0.6 \n0.4 0.4 0.5 0.4 0.4 0.5 0.7 0.3 0.2 0.4 0.6 0.4 0.6 1.1  reported by Grust et al. (2010), all of which \nreturn nested results. As guaranteed by Proposition 4, translation for P-LINQ always suc\u00adceeds and never \ngenerates avalanches for queries with .at results. Generally, normalisation time is dwarfed by query \nevaluation time, in some cases by several orders of magnitude. The F# type Expr< A > maintains information \nirrelevant to our application, so we elected to normalise by converting the F# type Expr< A > to our \nown custom representation, normalising that, and converting back to Expr< A >. Pro.ling suggests most \nof the time in our normaliser is spent converting to our custom representation. The only way to traverse \nExpr< A > expressions in F# is through active pattern matching, which appears to be expensive. To evaluate \nthe impact of query avalanches, we reran query (9) with F# 3.0 and P-LINQ with varying numbers of departments, \nranging from 4 to 64. For F# 3.0, the number of queries performed is d+1 where d is the number of departments. \nThe results are shown in Figure 14. Both approaches scale roughly linearly in the number of departments \n(and hence, total data size); we summarise the re\u00adsults in terms of the average time s to process each \ndepartment. The value of s for F# 3.0 is 12.8 milliseconds per department, while that for P-LINQ is 0.3. \nThese results con.rm that P-LINQ s normalisa\u00adtion can reap signi.cant savings by avoiding query avalanches. \n T-LINQ does not include constructs such as sorting, grouping, or aggregation, which are important in \npractical use of LINQ. We have designed P-LINQ so that it rewrites any subterm it recognises, and carries \nthrough other constructs unchanged. Our results suggest this is a practical alternative: we tested this \nprototype on all 62 of the example database queries on the F# 3.0 Query Expressions doc\u00adumentation page \n(Microsoft 2013). (There are also .ve tests that do not generate SQL queries, which we excluded from \nthe exper\u00adiments.) All of these queries are concrete, that is, none involves abstraction, and they are \nevaluated on a small database of about 30 records. The results are shown in Table 2. We summarise the \nresults in terms of the ratio r of P-LINQ to F# 3.0 evaluation time. The ge\u00adometric mean of r over all \ntests is 1.13 (so on average P-LINQ is 13% slower), and the minimum and maximum values of r over all \ntests is 0.89 and 1.24, respectively (so at best P-LINQ is 11% faster and at worst 24% slower). All the \ntranslations succeeded, suggest\u00ading that normalisation does not interfere with F# 3.0 s support for additional \nquery operators. These results demonstrate that the over\u00adhead of normalisation is modest, even for small \ndata sets, and oc\u00adcasionally normalisation improves query time, even for concrete queries. At present, \nF# 3.0 does not allow overriding the default query builder, so we cannot yet provide our implementation \nas a drop-in replacement. We are discussing with the Microsoft F# team how best to make our techniques \navailable in a future version of F#. 10. Related Work LINQ has attracted considerable commercial interest, \nbut has not been extensively documented in the research literature. Meijer et al. (2006) and Meijer (2011) \ngive overviews of the foundations of LINQ. Syme (2006) presents an early version of F# s quotation and \nre.ection capabilities, illustrated via applications to LINQ, GPU code generation, and runtime F# code \ngeneration. Bierman et al. (2007) present a formalisation of several extensions to C#, including LINQ. \nEini (2011) identi.es obstacles to implementing LINQ providers for non-SQL databases. Beckman (2012) \nadvo\u00adcates LINQ as an interface to cloud computing platforms. Petricek and Syme (2012) and Syme et al. \n(2012) describe F# 3.0 s sequence expressions and the related computation builder mechanism. Use of LINQ \nfor abstraction over values and predicates and dynamic gen\u00aderation of queries has been discussed in blogs \nand online forums, such as Petricek (2007b,a), but has not, to our knowledge, previ\u00adously been modelled \nformally. Type-safe quotation and meta-programming is an active re\u00adsearch area. Davies and Pfenning (2001) \nintroduce a calculus .0 for closed multistage programming based on a modal logic, where each stage uses \nthe same language. T-LINQ can be viewed as a vari\u00adant with just two stages, each using a slightly different \nlanguage. Rhiger (2012) presents a calculus for multistage programming with open quotations, noting that \nclosed quotation leads to less ef.cient code due to administrative redexes. In our setting, such adminis\u00adtrative \nredexes have negligible cost because we normalisation time is dominated by query execution time. Choi \net al. (2011) present a translation from open to closed quotation similar to ours, aimed at supporting \ntranslation-based static analysis for staged computation. Van den Bussche et al. (2005) present a meta-querying \nsystem for SQL, but does not consider type safety or language integration. Integrating queries into a \ngeneral-purpose language is also an active research area. Ohori and Ueno (2011) introduces SML#, which \noffers direct support for SQL queries, including a type sys\u00adtem that guarantees each query accesses only \na single database. It does not normalise queries. Chlipala (2010) introduces Ur/Web, which uses open \nquotations with a sophisticated type system. It also does not normalise queries. Ur/Web can express most \nof the queries given here, though it relies on subqueries to express query compo\u00adsition, and it cannot \nexpress the nested query (9) of Section 3.2 (Adam Chlipala, personal communication, January 2013). Budiu \net al. (2013) present a general framework for composing compilers based on LCF-style tactics, and apply \nthis methodology to a sub\u00adset of LINQ in C# called \u00b5LINQ. It would be interesting to see whether this \napproach can be used for T-LINQ. Grust et al. (2009, 2010) describe Ferry, a functional query language \nthat, like our work, supports higher-order functions and nested data, but goes beyond our work in also \nsupporting queries that return nested results. The Ferry team have implemented sev\u00aderal LINQ query providers, \nas well as interfacing Ferry with Links (Ulrich 2011) and Haskell (Giorgidze et al. 2010). Hen\u00adglein \nand Larsen (2010) consider ef.cient in-memory evaluation of query-like constructs using lazy evaluation \nand generic discrimina\u00adtion. These approaches employ complementary techniques to our normalisation-based \napproach; combining our results with these systems appears possible, and should be explored in future \nwork. In our case the host language and quoted language are taken to be identical, but that is a design \nchoice. An approach where host and quoted languages differ is described by Mainland (2012). We indicate \nquotations syntactically (with <@ \u00b7 \u00b7 \u00b7 @>). An al\u00adternative approach is to indicate quotation by type \ndeclaration, as is done in C# and with Lightweight Modular Staging in Scala (Rompf and Odersky 2012). \nAnother alternative is not to support quotation in the language, but to use an embedded DSL to construct \nparse trees, an approach taken in Nikola (Mainland and Morrisett 2010) and Feldspar (Axelsson et al. \n2010; Axelsson and Svenningsson 2012). We intend to team with Feldspar researchers to compare their approach \nwith ours. 11. Conclusion We presented a simple theory of language-integrated query based on quotation \nand normalisation. Through a series of examples, we demonstrated that our technique supports abstraction \nover val\u00adues and predicates, composition of queries, dynamic generation of queries, and queries with \nnested intermediate data; and that higher\u00adorder features proved useful even for dynamic generation of \n.rst\u00adorder queries. We developed a formal theory, T-LINQ, and proved that normalisation always succeeds \nin translating any query of .at relation type to SQL. We presented an implementation in F# called P-LINQ, \nand experimental results con.rming our technique works in practice as predicted. We observed that for \nseveral of our exam\u00adples, Microsoft s LINQ framework either fails to produce an SQL query or produces \nan avalanche of SQL queries. In essence, we have supplied a recipe for using a host language to generate \ncode in a target language. The recipe involves three languages: the host language (in our case, F#), \nthe target language (in our case, SQL), and a quoted language (in our case, essentially F# again). The \nhost language should support quotation and anti-quotation of terms in the quoted language: in our case, \nwe use F# quota\u00adtion.  The quoted language may need to add constructs not in the host language (so it \nis as expressive as the target language), and omit some constructs in the host language (so it is not \nmore expressive than the target language after normalisation): in our case, the quoted language adds \nthe database construct but omits recursion.  The quoted language should at least support lambda abstraction \nand typing: support for lambda abstraction means it is suf.cient to support closed quotations, which \nin turn makes it easier to support typing.  Finally and most importantly one must identify an adequate \nnormalisation procedure. Normalisation should at least perform beta-reduction: thus the quoted language \nmay exploit the ex\u00adpressiveness of lambda abstraction even if the target language is .rst order. Normalisation \nmay perform operations other than beta-reduction: in our case, additional rewrite rules support translation \ninto SQL.  Applying the recipe to other domains is an important area for future work. To conclude, \nlet s compare the theoretical and practical aspects of our work. Regarding the host and quoted languages, \nthe recipe above makes clear they may differ in theory, and this is the case in T-LINQ; in practice, \nthey tend to be the same, and this is the case in P-LINQ. Regarding coverage, T-LINQ differs from full \nLINQ, and extending it to cover sorting, grouping, and aggregation remains important work for tomorrow. \nMeanwhile, P-LINQ supports the same features as LINQ, and it can be put to work today. Our opening adage \nacknowledges that theory can fall short of the needs of practice. In contrast, our experience con.rms \nthat prac\u00adtice bene.ts from a judicious dose of theory, even when that theory is incomplete. We propose \na reversal of the opening platitude. What is the difference between theory and practice? In theory there \nis a difference, but in practice there isn t. Acknowledgments We are grateful to Nada Amin, James McKinna, \nTomas Petricek, Simon Peyton Jones, Tiark Rompf, and Don Syme for comments on this work. The second author \nwould like to thank Conor McBride for the craic. This work is supported in part by a Google Re\u00adsearch \nAward (Lindley), EPSRC grants EP/J014591/1 (Lindley) and EP/K034413/1 (Lindley, Wadler), and a Royal \nSociety Uni\u00adversity Research Fellowship (Cheney). References M. P. Atkinson and O. P. Buneman. Types \nand persistence in database programming languages. ACM Comput. Surv., 19(2):105 170, 1987. E. Axelsson \nand J. Svenningsson. Combining deep and shallow embedding for EDSL. In TFP, 2012. E. Axelsson, K. Claessen, \nM. Sheeran, J. Svenningsson, D. Engdal, and A. Persson. The design and implementation of Feldspar an \nembedded language for digital signal processing. In J. Hage and M. T. Moraz \u00b4an, editors, IFL, volume \n6647 of LNCS, pages 121 136. Springer, 2010. B. Beckman. Why LINQ matters: cloud composability guaranteed. \nCom\u00admun. ACM, 55(4):38 44, Apr. 2012. G. M. Bierman, E. Meijer, and M. Torgersen. Lost in translation: \nformal\u00adizing proposed extensions to C#. In OOPSLA, pages 479 498. ACM, 2007. M. Budiu, J. Galenson, and \nG. D. Plotkin. The compiler forest. In ESOP, number 7792 in LNCS, pages 21 40. Springer-Verlag, 2013. \nP. Buneman, L. Libkin, D. Suciu, V. Tannen, and L. Wong. Comprehension syntax. SIGMOD Record, 23:87 96, \n1994. J. Cheney and R. Hinze. First-class phantom types. Computer and Informa\u00adtion Science Technical \nReport TR2003-1901, Cornell University, 2003. J. Cheney, S. Lindley, and P. Wadler. A practical theory \nof language\u00adintegrated query (code supplement), 2012. http://homepages.inf.ed.ac.uk/jcheney/linq. A. \nJ. Chlipala. Ur: statically-typed metaprogramming with type-level record computation. In PLDI, pages \n122 133. ACM, 2010. W. Choi, B. Aktemur, K. Yi, and M. Tatsuta. Static analysis of multi-staged programs \nvia unstaging translation. In POPL, pages 81 92. ACM, 2011. E. Cooper. The script-writer s dream: How \nto write great SQL in your own language, and be sure it will succeed. In DBPL, number 5708 in LNCS, pages \n36 51. Springer-Verlag, 2009. E. Cooper, S. Lindley, P. Wadler, and J. Yallop. Links: web programming \nwithout tiers. In FMCO, volume 4709 of LNCS, pages 266 296, 2007. G. Copeland and D. Maier. Making Smalltalk \na database system. SIGMOD Rec., 14(2):316 325, 1984. R. Davies and F. Pfenning. A modal analysis of staged \ncomputation. J. ACM, 48(3):555 604, 2001. O. Eini. The pain of implementing LINQ providers. Commun. ACM, \n54(8): 55 61, 2011. G. Giorgidze, T. Grust, T. Schreiber, and J. Weijers. Haskell boards the Ferry -database-supported \nprogram execution for Haskell. In IFL, number 6647 in LNCS, pages 1 18. Springer-Verlag, 2010. T. Goldschmidt, \nR. Reussner, and J. Winzen. A case study evaluation of maintainability and performance of persistency \ntechniques. In ICSE, pages 401 410. ACM, 2008. T. Grust, M. van Keulen, and J. Teubner. Accelerating \nXPath evaluation in any RDBMS. ACM Trans. Database Syst., 29:91 131, 2004. T. Grust, M. Mayr, J. Rittinger, \nand T. Schreiber. Ferry: Database-supported program execution. In SIGMOD, pages 1063 1066. ACM, 2009. \nT. Grust, J. Rittinger, and T. Schreiber. Avalanche-safe LINQ compilation. PVLDB, 3(1):162 172, 2010. \nF. Henglein and K. F. Larsen. Generic multiset programming with discrimination-based joins and symbolic \ncartesian products. Higher-Order and Symbolic Computation, 23(3):337 370, 2010. S. Lindley and J. Cheney. \nRow-based effect types for database integration. In TLDI, pages 91 102. ACM, 2012. G. Mainland. Explicitly \nheterogeneous metaprogramming with Meta-Haskell. In P. Thiemann and R. B. Findler, editors, ICFP, pages \n311 322. ACM, 2012. ISBN 978-1-4503-1054-3. G. Mainland and G. Morrisett. Nikola: embedding compiled \nGPU functions in haskell. In J. Gibbons, editor, Haskell Symposium, pages 67 78. ACM, 2010. ISBN 978-1-4503-0252-4. \nE. Meijer. The world according to LINQ. Commun. ACM, 54(10):45 51, Oct. 2011. E. Meijer, B. Beckman, \nand G. M. Bierman. LINQ: reconciling object, relations and XML in the .NET framework. In SIGMOD, page \n706. ACM, 2006. Microsoft. Query expressions (F# 3.0 documentation), 2013. http://msdn.microsoft.com/en-us/library/vstudio/\u00adhh225374.aspx, \naccessed March 18, 2013. A. Ohori and K. Ueno. Making Standard ML a practical database program\u00adming language. \nIn ICFP, pages 307 319. ACM, 2011. T. Petricek. Building LINQ queries at runtime in (F#), 2007a. http://tomasp.net/blog/dynamic-flinq.aspx. \nT. Petricek. Building LINQ queries at runtime in (C#), 2007b. http://tomasp.net/blog/dynamic-linq-queries.aspx. \nT. Petricek and D. Syme. Syntax Matters: Writing abstract computations in F#. Pre-proceedings of TFP, \n2012. http://www.cl.cam.ac.uk/~tp322/drafts/notations.pdf. D. Prawitz. Natural Deduction: A Proof-Theoretical \nStudy. Almqvist and Wiksell, Stockholm, 1965. M. Rhiger. Staged computation with staged lexical scope. \nIn ESOP, number 7211 in LNCS, pages 559 578. Springer-Verlag, 2012. T. Rompf and M. Odersky. Lightweight \nmodular staging: a pragmatic approach to runtime code generation and compiled dsls. Commun. ACM, 55(6):121 \n130, 2012. D. Syme. Leveraging .NET meta-programming components from F#: integrated queries and interoperable \nheterogeneous execution. In ML Workshop, pages 43 54. ACM, 2006. D. Syme, A. Granicz, and A. Cisternino. \nExpert F# 3.0. Apress, 2012. ISBN 978-1-4302-4650-3. W. Taha and T. Sheard. MetaML and multi-stage programming \nwith explicit annotations. Theor. Comput. Sci., 248(1-2):211 242, 2000. P. Trinder. Comprehensions, a \nquery notation for DBPLs. In Proceedings of 3rd International Workshop on Database Programming Languages, \npages 49 62. Morgan Kaufmann, 1991. P. Trinder and P. Wadler. Improving list comprehension database queries. \nIn TENCON 89., 1989. A. Ulrich. A Ferry-based query backend for the Links programming language. Master \ns thesis, University of T \u00a8ubingen, 2011. J. Van den Bussche, S. Vansummeren, and G. Vossen. Towards \npractical meta-querying. Inf. Syst., 30(4):317 332, 2005. L. Wong. Normal forms and conservative extension \nproperties for query languages over collection types. J. Comput. Syst. Sci., 52(3):495 505, 1996.  \n \n\t\t\t", "proc_id": "2500365", "abstract": "<p>Language-integrated query is receiving renewed attention, in part because of its support through Microsoft's LINQ framework. We present a practical theory of language-integrated query based on quotation and normalisation of quoted terms. Our technique supports join queries, abstraction over values and predicates, composition of queries, dynamic generation of queries, and queries with nested intermediate data. Higher-order features prove useful even for constructing first-order queries. We prove a theorem characterising when a host query is guaranteed to generate a single SQL query. We present experimental results confirming our technique works, even in situations where Microsoft's LINQ framework either fails to produce an SQL query or, in one case, produces an avalanche of SQL queries.</p>", "authors": [{"name": "James Cheney", "author_profile_id": "81100057679", "affiliation": "University of Edinburgh, Edinburgh, United Kingdom", "person_id": "P4261289", "email_address": "jcheney@inf.ed.ac.uk", "orcid_id": ""}, {"name": "Sam Lindley", "author_profile_id": "81330494526", "affiliation": "University of Strathclyde, Glasgow, United Kingdom", "person_id": "P4261290", "email_address": "Sam.Lindley@ed.ac.uk", "orcid_id": ""}, {"name": "Philip Wadler", "author_profile_id": "81100173596", "affiliation": "University of Edinburgh, Edinburgh, United Kingdom", "person_id": "P4261291", "email_address": "wadler@inf.ed.ac.uk", "orcid_id": ""}], "doi_number": "10.1145/2500365.2500586", "year": "2013", "article_id": "2500586", "conference": "ICFP", "title": "A practical theory of language-integrated query", "url": "http://dl.acm.org/citation.cfm?id=2500586"}