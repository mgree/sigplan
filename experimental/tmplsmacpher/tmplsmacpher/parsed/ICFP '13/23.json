{"article_publication_date": "09-25-2013", "fulltext": "\n Using Circular Programs for Higher-Order Syntax Functional pearl Emil Axelsson Koen Claessen Chalmers \nUniversity of Technology {emax,koen}@chalmers.se Abstract This pearl presents a novel technique for \nconstructing a .rst\u00adorder syntax tree directly from a higher-order interface. We exploit circular programming \nto generate names for new variables, resulting in a simple yet ef.cient method. Our motivating application \nis the design of embedded languages supporting variable binding, where it is convenient to use higher-order \nsyntax when constructing programs, but .rst\u00adorder syntax when processing or transforming programs. Categories \nand Subject Descriptors D.3.1 [Formal De.\u00adnitions and Theory]: Syntax; D.3.2 [Language Classi.ca\u00adtions]: \nApplicative (functional) languages Keywords higher-order syntax; embedded languages; cir\u00adcular programming \n1. Introduction Imagine a simple Haskell data type for expressions of the lambda calculus: data Exp = \nVar Name --Variable | Lam Name Exp --Abstraction | App Exp Exp --Application deriving (Show) The Var \nand Lam constructors use explicit names to refer to variables, where names belong to the abstract type \nName. When constructing expressions in this representation, we have to keep track of the scope of bound \nvariables. As an example, the term .x.(.y.y)(.z.z)x a verbose de.nition of the identity function can \nbe represented as follows (assuming an integer representation of names): Permission to make digital or \nhard copies of all or part of this work for personal or classroom use is granted without fee provided \nthat copies are not made or distributed for pro.t or commercial advantage and that copies bear this notice \nand the full citation on the .rst page. Copyrights for components of this work owned by others than the \nauthor(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or republish, to \npost on servers or to redistribute to lists, requires prior speci.c permission and/or a fee. Request \npermissions from permissions@acm.org. ICFP 13, September 25 27, 2013, Boston, MA, USA. Copyright is \nheld by the owner/author(s). Publication rights licensed to ACM. ACM 978-1-4503-2326-0/13/09. . . $15.00. \nhttp://dx.doi.org/10.1145/2500365.2500614 app :: Exp . Exp . Exp lam :: (Exp . Exp) . Exp Figure 1: \nHigher-order interface for the lambda calculus identity FO :: Exp identity FO = Lam 1 (App (App (Lam \n2 (Var 2)) (Lam 3 (Var 3))) (Var 1) ) Because it is so easy to mix up variable names, it is common to \ninstead use higher-order syntax (HOS) in embedded lan\u00adguages. A HOS interface for the lambda calculus \nis given in Fig. 1. HOS allows us to write the above example in a much more convenient form: identity \n:: Exp identity = lam (.x . app (app (lam (.y . y)) (lam (.z . z))) x ) By using binding in the host \nlanguage to represent binding in the object language, it is impossible to refer to unbound variables. \nNote that the HOS interface does not include a constructor for variables. Those are implicitly introduced \nby lam. How can we implement the interface in Fig. 1 without chang\u00ading the original Exp data type? That \nis the question that this pearl will answer. As we shall see in Sec. 4, this problem is highly relevant \nto the implementation of embedded lan\u00adguages. First attempt. The dif.culty is in implementing lam. A \n.rst attempt may lead to the following code: lam f = Lam n (f (Var n)) where n = ??? Now, the problem \nis to choose a name n that does not inter\u00adfere with other names in the expression. The name must be \n bot :: Name prime :: Name . Name --prime law: . a . prime a > a --Maximum: ( u ) :: Name . Name . Name \nm u n | m = n = m | n > m = n Figure 2: Creation and manipulation of names chosen so that (1) the binding \ndoes not accidentally capture free variables in the body, and (2) uses of the new variable are not captured \nby other bindings in the body. Abstract representation of names. In order to allow free\u00addom in the representation \nof names, we will use the opera\u00adtions in Fig. 2 to create, manipulate and reason about names. A name \ncan be any totally ordered type implementing the given interface. The law for prime states that this \nfunction always increases the order of a name. Since no operation de\u00adcreases the order of a name, we \ncan argue that bot is the smallest name, as long as we only create names using the given interface. For \nthe examples in this pearl, we will use the following implementation of names: type Name = Integer bot \n= 0 prime = succ Note also that (u) is equivalent to the max function. 2. Alternatives This section \ngives two alternative implementations of the HOS interface. These provide suf.cient background to de\u00advelop \nour new method in Sec. 3. Some additional alternatives are mentioned in the related work (Sec. 4). 2.1 \nThreading a name supply As a reference, let us .rst consider a non-solution one that does involve changing \nthe Exp type. The idea is to prevent capturing by using a unique name in each binding. This can be done \nby threading a name supply through the lam and app functions, which requires us to change Exp to a state-passing \nfunction:1 type Exp NS = Name . (Exp, Name) 1 We will use subscripts as a way to distinguish different \nimplementations of similar functions and types throughout the paper. fromExp NS :: Exp NS . Exp fromExp \nNS e = fst (e (prime bot)) The implementation of application will just thread the state, .rst through \nthe function and then through the argument. Abstraction is a bit more involved. app NS :: Exp NS . Exp \nNS . Exp NS app NS f a = .n . let (f ,o) = f n (a ,p) = a o in (App f a , p) lam NS :: (Exp NS . Exp \nNS ) . Exp NS lam NS f = .n . let var = .o . (Var n, o) (a,p) = f var (prime n) in (Lam n a, p) The \nincoming name n is used for the new variable. The vari\u00adable expression var just passes its name supply \nthrough un\u00adchanged. The body (f var) is given (prime n) as the incom\u00ading name, which ensures that all \nits bindings will use names that are different from n. An example shows how the names are chosen: *Main> \nfromExp NS identity NS Lam 1 (App (App (Lam 2 (Var 2)) (Lam 3 (Var 3))) (Var 1)) The expression identityNS \nis de.ned as identity but with NS subscripts on app and lam. We will use the same convention for identitySPEC \nbelow. The name supply method does not solve the original prob\u00adlem, as it uses a different representation \nof expressions. Also, the tedious state threading in appNS and lamNS leaves a bad taste in the mouth. \nOn the more practical side, the fact that ExpNS is a function leads to some additional problems: It \nis not directly possible to pattern match on expressions. Pattern matching is commonly used to de.ne \nsmart con\u00adstructors that simplify expressions on the .y [6].  It is not possible to observe any implicit \nsharing [5, 7] in the expression. After all, a shared sub-expression can appear in many contexts with \ndifferent name supplies.  For all these reasons, we leave ExpNS behind and look for a better alternative. \n 2.2 Speculative naming Recall, the problem is to implement lam without changing the Exp type, which \nmeans that there will not be any name supply available. Let us thus return to our original attempt at \nde.ning lam: lam f = Lam n (f (Var n)) where n = ???  We have no name supply, yet we need to pick a \nname that does not interfere with the body of the expression. One way to solve this puzzle is to speculatively \nevaluate the function f to .nd out which names are used in the body, then pick a different name for the \nvariable, and apply f again: lamSPEC :: (Exp . Exp) . Exp lamSPEC f = Lam n (f (Var n )) where ph = \nVar bot --Placeholder n = max V (f ph) --Speculation n = prime n The placeholder ph used in the .rst \napplication of f uses the smallest name bot, which is assumed only to be used for speculative evaluation, \nnot for bound variables. The maxV function simply traverses the body to .nd the greatest occur\u00adring variable \nname: max V :: Exp . Name max V (Var n) = n max V (App f a) = max V f u max V a max V (Lam a) = max V \na _ Selecting n = prime n ensures absence of capturing: there could be other variables of that name \nin scope, but they are anyway not used in the body. Since we are now constructing the Exp type directly, \nthe appSPEC constructor is identical to App: appSPEC = App Our running example shows how the names are \nchosen: *Main> identitySPEC Lam 2 (App (App (Lam 1 (Var 1)) (Lam 1 (Var 1))) (Var 2)) So, the method \nworks, but can you spot the problems with the implementation of lamSPEC ? One problem is that maxV has \nto traverse the whole body, leading to quadratic complexity in expressions with nested lambdas. However, \nthere is a much more severe problem: The function f is applied twice in each lambda, which means that \nan expression with n nested lambdas requires 2n appli\u00adcations! Deeply nested lambdas are not uncommon \nin embedded languages where variable binding is used to represent shared sub-expressions (as, for example, \nin reference [6]). Thus, the exponential complexity renders the above method unusable in practice. 3. \nOur method: circular speculation The speculative application in the previous method is used to resolve \nthe circular dependency arising from the fact that we need to examine the body before constructing it. \nIn a classic paper, Richard Bird poses the Repmin problem that has a similar circular dependency [2]. \nThe Repmin problem is to de.ne a function that converts a tree into a tree of identical shape, but where \nall leaves have been replaced by the minimal leaf in the original tree. A naive solution would traverse \nthe tree twice once to .nd the minimal leaf, and once to construct the new tree. Bird s solution uses \ncircular programming to collapse the two traversals into one. For the Repmin problem, circular programming \nreduces two traversals into one more complicated traversal, which makes it unclear if the approach saves \nany computation at all. How\u00adever, in case of nested traversals, cutting the number of re\u00adcursive calls \nin each step can reduce the complexity class! Can we use circular programming to avoid the exponential \nblowup in lamSPEC ? Let us try: lamCIRC :: (Exp . Exp) . Exp lamCIRC f = Lam n body where body = f (Var \nn ) n = max V body n = prime n This version avoids the separate speculation by using the correct name \nright away. Although this function type checks, unfortunately it does not work. Why? The problem is that \nmaxV can no longer distinguish the new variable from other variables in the body. Thus, maxV re\u00adturns \na name that is at least as high as n , giving n = n . At the same time, we have n = prime n which gives \nus n > n. This contradiction manifests itself as an in.nite loop in lamCIRC . 3.1 A different perspective \nThe simple speculative method involved .nding a name that is not used in the body of a binding. As previously \nsaid, this ensures absence of capturing. However, another way to avoid capturing is to only look at the \nvariables that are bound in the body, and pick a name that is not bound. Then there is still a risk of \ncapturing a free variable, but as long as all bindings and variables are created using the same method, \nthis will never happen (see Sec. 3.2). The function that .nds the greatest bound variable is a slight \nvariation of maxV : max BV :: Exp . Name max BV (Var _) = bot max BV (App f a) = max BV f u max BV a \nmax BV (Lam n a) = n u max BV a  app :: Exp . Exp . Exp app = App lam :: (Exp . Exp) . Exp lam f = \nLam n body where body = f (Var n) n = prime (max BV body) Figure 3: Implementation of the higher order \ninterface using circular programming Fig. 3 gives a complete de.nition of the HOS interface using circular \nprogramming. The trick is that since maxBV does not look at Var constructors, it can produce a value \nwithout forcing evaluation of the new variable. Thus, the in.nite loop is broken. For the identity example \n(but not in general), our method chooses the same names as the simple speculative method: *Main> identity \nLam 2 (App (App (Lam 1 (Var 1)) (Lam 1 (Var 1))) (Var 2))  3.2 The law of the jungle: to capture or \nto be captured When choosing a name for a new binding, there are two problems we want to avoid: (1) the \nbinding captures a free variable in the body, and (2) uses of the new variable are captured by other \nbindings in the body. For closed terms, capturing can only happen when a binder shadows a vari\u00adable in \nscope. Thus, to check for absence of capturing, it is enough to check for absence of shadowing: safe \n:: Exp . Bool safe (Var _) = True safe (App f a) = safe f &#38;&#38; safe a safe (Lam n a) = n > max \nBV a &#38;&#38; safe a The above function checks that no binding is shadowed by another binding in its \nbody. The requirement that each bind\u00ading introduces a variable that is greater than all bound vari\u00adables \nin the body is overly conservative (it is enough that the new variable is distinct from the bound variables \nin the body), but suf.ces for our purposes. Note that by assuming closed terms and only considering shadowing, \nwe can reason about capture-avoidance purely in terms of binders, ignoring any uses of the variables. \nWe trust that our HOS implemen\u00adtation only produces closed expressions. We will argue for the correctness \nof our method by show\u00ading that any term constructed using the HOS interface app and lam is safe. To \nsimplify reasoning, we only consider Haskell terms t built using direct application of those func\u00adtions \nand variables. De.nition 1. A HOS term is de.ned by the following gram\u00admar: t ::= v | app t t | lam (.v \n. t) De.nition 2. We use c f t . e to denote evaluation of the term t to value e (of type Exp) in context \nc. A context is a mapping from Haskell variables to expressions of type Exp. We omit the de.nition of \nevaluation from the paper. De.nition 3. We extend the notion of safety to contexts: safeCXT c holds if \nall variables in c map to safe expressions. Theorem 1. Evaluation of a term t in a safe context c results \nin a safe expression: . c t e . safeCXT c &#38; c f t . e . safe e The proof is by induction on terms. \nThe base case, for vari\u00adables, is proved by noting that looking up a variable in a safe context must \nresult in a safe expression. The case for app is shown by a straightforward use of the induction hypothesis. \nFor lam, we see in Fig. 3 that it evaluates to Lam n body. This expression is safe if n is greater than \nall bound variables in the body and the body is safe. The .rst requirement is triv\u00adially ful.lled by \nthe de.nition of lam. To show that body is safe, we expand it to f (Var n), where f is equal to .v . \nt for some variable v and term t. Thus, the evaluation of the body in context c must be equal to the \nevaluation of t in context (v . Var n : c). Assuming that c is safe, this extended con\u00adtext is also safe; \nhence the induction hypothesis implies that the result of evaluating the body is safe.  3.3 Achieving \nlinear complexity So far, we have prevented the exponential complexity in the simple speculative solution \nby only computing the body once in lam. However, since lam has to traverse the whole body to .nd the \ngreatest bound variable, we still have quadratic complexity in the number of nested lambdas. For\u00adtunately, \nthe reasoning in Sec. 3.2 shows us that lam actually traverses most of the body in vain! The safe property \nstates that each binding introduces a vari\u00adable that is greater than all bound variables in the body. \nThis means that we can make an improved version of maxBV that only looks at the closest binders: max \nBV+ :: Exp . Name max BV+ (Var _) = bot max BV+ (App f a) = max BV + f u max BV+ a max BV+ (Lam n _) \n= n  Lemma 1. For safe expressions, maxBV + gives the same re\u00adsult as maxBV : safe e . maxBV + e = \nmaxBV e Proof by induction on expressions. Swapping in maxBV + in the de.nition of lam gives us a more \nef.cient implementation: lam+ f = Lam n body where body = f (Var n) n = prime (max BV+ body) Here, \nmaxBV + traverses the body down to the closest binders, which in the worst case means traversing most \nof the expres\u00adsion. However, since the result is a Lam expression, the body will never have to be traversed \nagain by uses of maxBV + from lambdas higher up in the expression. Thus, the total effect of all uses \nof maxBV + is one extra traversal of the expression. This means that the complexity of building an expression \nis linear in the size of the expression, giving an amortized complexity of O(1) for each lam and app. \nTheorem 2. Let t+ range over terms built using app and lam+. Evaluation of a term t+ in a safe context \nc results in a safe expression: . c t+ e . safeCXT c &#38; c f t+ . e . safe e Proof using induction \non terms t+ and lemma 1. 4. Discussion and related work The problem solved in this pearl is not just \na theoretical ex\u00adercise it is of great interest to the implementation of em\u00adbedded domain-speci.c languages \n(EDSLs). There are many EDSLs that rely on a higher-order interface towards the user and a .rst-order \nrepresentation for analysis and code gener\u00adation: Lava [3], Pan [6], Nikola [8], Accelerate [10], Obsid\u00adian \n[12] and Feldspar [1], to name some. All of these EDSLs employ some kind of higher-order to .rst-order \nconversion. The simple speculative method in Sec. 2.2 was originally suggested by Lennart Augustsson \nin a private communica\u00adtion with the authors. One of the anonymous referees also brought to our attention \nthat a similar method is used in ref\u00aderence [4] to construct a .rst-order term with de Bruijn in\u00addexes \nfrom a higher-order interface. A common method for implementing higher-order lan\u00adguage constructs is \nto use higher-order abstract syntax (HOAS) [11]. A HOAS version of the lambda calculus would be like \nour Exp but where the Lam constructor mim\u00adics the type of lam: data Exp = Var Name | App Exp Exp | Lam \n(Exp . Exp) The advantage of this representation is that the constructors have a direct correspondence \nto the HOS interface in Fig. 1. However, working with this type is not convenient. As soon as we need \nto look inside a lambda, we need to come up with a variable name to pass to the binding function, which \nmeans that the name generation problem we have battled in this paper will reappear in each analysis. \nAnother prob\u00adlem is HOAS to HOAS transformations where the binding functions have to be reconstructed \nafter transforming under a lambda. Instead, a common approach is to have a separate data type for .rst-order \nabstract syntax (FOAS) and a function to con\u00advert from HOAS to FOAS. This technique is used, for exam\u00adple, \nin Accelerate and recent versions of Feldspar. Although the technique is quite useful, it has some practical \nconcerns: It requires de.ning two separate but almost identical data types (or play tricks to merge \nthe two into one).  Care has to be taken not to destroy implicit sharing during conversion [10].  In \na blog post, McBride [9] proposes an implementation of higher-order syntax that, like our solution, does \nnot require a separate HOAS data type. His term representation uses typed de Bruijn indexes and a type \nclass to compute the index of a variable depending on its use site. Since de Bruijn indexes depend on \nthe nesting depth of binders, a value-level implementation would require passing an environment while \nbuilding expressions (with problems similar to the ones in Sec. 2.1). McBride cleverly avoids the problem \nby lifting the environment to the type level. Unfortunately, this also leads to more complicated types \nin the user interface. It should be noted that our technique using circular spec\u00adulation assumes that \nall bindings and variables are created using the lam function. This restriction is .ne in an embed\u00added \nlanguage front end where terms are constructed from scratch, but it makes the approach unsuitable for \nintroduc\u00ading new bindings in existing terms. Consider the following transformation: trans (Lam n a) = \nLam n (trans a) If trans introduces a new binder using lam, this introduction will be unaware of the \nfact that n is in scope leading to potential capturing. To avoid capturing, we would have to use lam \non the right-hand side to introduce a fresh variable x, and substitute x for n in the body (assuming \nthe existence of a suitable substitution function subst): trans (Lam n a) = lam (.x . trans (subst n \nx a))  data Exp = Var Name --Variable | Lam Name Exp --Abstraction | App Exp Exp --Application deriving \n(Show) app :: Exp . Exp . Exp app = App lam :: (Exp . Exp) . Exp lam f = Lam n body  where body = f \n(Var n) n = prime (max BV body) type Name = Integer bot :: Name prime :: Name . Name ( u ) :: Name . \nName . Name bot = 0 prime = succ ( u ) = max  max BV :: Exp . Name max BV (Var _) = bot max BV (App \nf a) = max BV f u max BV a max BV (Lam n _) = n Figure 4: Final solution Although this version does avoid \ncapturing, the whole ap\u00adproach is a bit fragile, and the need for renaming makes it quite inef.cient. \n5. Conclusion We have presented a simple solution to the problem of gen\u00aderating .rst-order syntax with \nbinders from a higher-order interface. The key is to use circular programming to be able to examine the \nbody of a binding before deciding which name to bind. Despite its simplicity, our solution pos\u00adsesses \ncharacteristics that makes it quite suitable for practi\u00adcal EDSLs. In particular, our solution does \nnot require a separate data type for higher-order abstract syntax,  is ef.cient and implementable in \nplain Haskell 98.  Our technique also serves as a real example where circu\u00adlar programming is used to \nchange the complexity class of an algorithm. Bird s circular solution to the Repmin prob\u00adlem uses one \ntraversal instead of two, possibly leading to a smaller constant factor for the algorithmic complexity. \nIn our case, circular programming allows us to build an expression in linear time instead of exponential. \nThe complete .nal solution is given in Fig. 4. Acknowledgments This work has been partially funded by \nthe Swedish Founda\u00adtion for Strategic Research, under grant RAWFP. We would like to thank Anders Persson, \nJean-Philippe Bernady, Joel Svensson, Josef Svenningsson, Mary Sheeran and Michal Palka for useful input \non this pearl. References [1] E. Axelsson, K. Claessen, M. Sheeran, J. Svenningsson, D. Engdal, and A. \nPersson. The design and implementation of Feldspar. In Implementation and Application of Functional Languages, \nvolume 6647 of LNCS, pages 121 136. Springer Berlin Heidelberg, 2011. [2] R. Bird. Using circular programs \nto eliminate multiple traver\u00adsals of data. Acta Informatica, 21(3):239 250, 1984. [3] P. Bjesse, K. Claessen, \nM. Sheeran, and S. Singh. Lava: hard\u00adware design in Haskell. In Proceedings of the third ACM SIG-PLAN \ninternational conference on Functional programming, ICFP 98, pages 174 184. ACM, 1998. [4] V. Capretta \nand A. P. Felty. Combining de Bruijn indices and higher-order abstract syntax in Coq. In Types for Proofs \nand Programs, volume 4502 of Lecture Notes in Computer Science, pages 63 77. Springer Berlin Heidelberg, \n2007. [5] K. Claessen and D. Sands. Observable sharing for func\u00adtional circuit description. In Advances \nin Computing Science, ASIAN 99, volume 1742 of LNCS, pages 62 73. Springer, 1999. [6] C. Elliott, S. \nFinne, and O. De Moor. Compiling embedded languages. Journal of Functional Programming, 13(3):455 481, \nMay 2003. [7] A. Gill. Type-safe observable sharing in Haskell. In Pro\u00adceedings of the 2nd ACM SIGPLAN \nsymposium on Haskell, Haskell 09, pages 117 128. ACM, 2009. [8] G. Mainland and G. Morrisett. Nikola: \nembedding compiled GPU functions in Haskell. In Proceedings of the third ACM Haskell symposium on Haskell, \nHaskell 10, pages 67 78. ACM, 2010. [9] C. McBride. I am not a number, I am a classy hack. 2010. URL \nhttp://www.e-pig.org/epilogue/?p=773. [10] T. L. McDonell, M. M. Chakravarty, G. Keller, and B. Lipp\u00admeier. \nOptimising purely functional GPU programs. Accepted for publication at ICFP 2013. [11] F. Pfenning and \nC. Elliot. Higher-order abstract syntax. In Proceedings of the ACM SIGPLAN 1988 conference on Pro\u00adgramming \nLanguage design and Implementation, PLDI 88, pages 199 208. ACM, 1988. [12] J. Svensson, M. Sheeran, \nand K. Claessen. Obsidian: A domain speci.c embedded language for parallel programming of graphics processors. \nIn Implementation and Application of Functional Languages, volume 5836 of LNCS, pages 156 173. Springer \nBerlin Heidelberg, 2011.    \n\t\t\t", "proc_id": "2500365", "abstract": "<p>This pearl presents a novel technique for constructing a first-order syntax tree directly from a higher-order interface. We exploit circular programming to generate names for new variables, resulting in a simple yet efficient method. Our motivating application is the design of embedded languages supporting variable binding, where it is convenient to use higher-order syntax when constructing programs, but first-order syntax when processing or transforming programs.</p>", "authors": [{"name": "Emil Axelsson", "author_profile_id": "81337487449", "affiliation": "Chalmers University of Technology, Gothenburg, Sweden", "person_id": "P4261251", "email_address": "emax@chalmers.se", "orcid_id": ""}, {"name": "Koen Claessen", "author_profile_id": "81100206977", "affiliation": "Chalmers University of Technology, Gothenburg, Sweden", "person_id": "P4261252", "email_address": "koen@chalmers.se", "orcid_id": ""}], "doi_number": "10.1145/2500365.2500614", "year": "2013", "article_id": "2500614", "conference": "ICFP", "title": "Using circular programs for higher-order syntax: functional pearl", "url": "http://dl.acm.org/citation.cfm?id=2500614"}