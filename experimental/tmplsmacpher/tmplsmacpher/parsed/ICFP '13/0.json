{"article_publication_date": "09-25-2013", "fulltext": "\n Interactive Programming with Dependent Types Ulf Norell University of Gothenburg ulf.norell@cse.gu.se \nAbstract In dependently typed languages run-time values can appear in types, making it possible to give \nprograms more precise types than in languages without dependent types. This can range from keeping track \nof simple invariants like the length of a list, to full functional correctness. In addition to having \nsome correctness guarantees on the .nal program, assigning more precise types to programs means that \nyou can get more assistance from the type checker while writ\u00ading them. This is what I focus on here, \ndemonstrating how the programming environment of AG DA can help you when develop\u00ading dependently typed \nprograms. Categories and Subject Descriptors D.1.1 [Programming Tech\u00adniques]: Applicative (Functional) \nProgramming; D.2.2 [Software Engineering]: Design Tools and Techniques General Terms Design, Languages, \nTheory Keywords Dependent types 1. Introduction Dependent type systems blur the line between the expression \nlan\u00adguage and the type language, allowing types to talk about run-time values as well as allowing types \nto be de.ned by computation. De\u00adpendent types are used heavily in the theorem proving community, most \nnotably in CO Q, where the propositions-as-types paradigm lets types act as predicates on values. In \nrecent years, however, there has been an increasing interest in using dependent types for pro\u00adgramming \nwith languages such as AG DA [3], ID R I S [1] and EP I -G RA M [2], as well as CO Q [6], exploring the \nnotion of a depen\u00addently typed program in contrast to a simply typed program with associated dependently \ntyped properties. We have also seen dependent types making their way into lan\u00adguages like HA S K E L \nL with the introduction of GADTs [4], type families [5] and data kinds [7], which, while not offering \nfull depen\u00addent types, still provides rich opportunities for dependently typed programming. 2. Interacting \nwith the Type Checker With dependent types we can no longer expect the machine to in\u00adfer types for us, \ninstead it becomes an important design decision Permission to make digital or hard copies of part or \nall of this work for personal or classroom use is granted without fee provided that copies are not made \nor distributed for pro.t or commercial advantage and that copies bear this notice and the full citation \non the .rst page. Copyrights for third-party components of this work must be honored. For all other uses, \ncontact the owner/author(s). Copyright is held by the owner/author(s). ICFP 13, September 25 27, 2013, \nBoston, MA, USA. ACM 978-1-4503-2326-0/13/09. http://dx.doi.org/10.1145/2500365.2500609 to decide what \nproperties of a program to track in its type. This does not mean that programs are cluttered with type \nannotations everywhere once the top-level type of a function is given, type information can routinely \nbe pushed inwards resulting in imple\u00admentations as short as the corresponding simply typed function. \nHaving written down a precise type before implementing a func\u00adtion means that the type checker knows \nwhat it is you are trying to do. This opens up a wide range of opportunities for the type checker to \nassist in the implementation. Some of these opportunities are taken advantage of by the programming environment \nof AG DA. The central notion of AG DA s interactive programming model is that of a hole. A hole is an \nun.nished part of the program and a program under development can contain any number of holes. For each \nhole the type checker can answer a number of questions, such as, what is the type of the expression expected \nin the hole, what are the types of the variables in scope of the hole, etc. In addition to providing \nthis information the type checker can also help you .ll the hole in various ways. For instance, .lling \nin the appropriate data type constructor with holes as arguments when there is only one choice, or introducing \na case split on a given term. 3. What is Missing? The main feature that is missing in the AG DA environment \nis support for refactoring. A larger design space for types means that there are more opportunities for \nmaking mistakes and having to go back and revise previous de.nitions. This is a situation where having \nmore precise types would help as well with more precise information, the machine can make more precise \nchanges. References [1] E. Brady. Idris systems programming meets full dependent types. In Proc. of 5th \nACM Workshop on Programming Languages Meets Program Veri.cation, PLPV 11, pp. 1 2. ACM, 2011. [2] C. \nMcBride and J. McKinna. The view from the left. J. of Funct. Program., 14(1):69 111, 2004. [3] U. Norell. \nTowards a practical programming language based on dependent type theory. PhD thesis, Chalmers U. of Techn., \n2007. [4] S. Peyton Jones, D. Vytiniotis, S. Weirich, and G. Washburn. Simple uni.cation-based type inference \nfor GADTs. In Proc. of 11th ACM SIGPLAN Int. Conf. on Functional Programming, ICFP 06, pp. 50 61. ACM, \n2006. [5] T. Schrijvers, S. Peyton Jones, M. Chakravarty, and M. Sulzmann. Type checking with open type \nfunctions. In Proc. of 13th ACM SIGPLAN Int. Conf. on Functional Programming, ICFP 08, pp. 51 62. ACM, \n2008. [6] M. Sozeau. PROGRAM-ing .nger trees in Coq. In Proc. of 12th ACM SIGPLAN Int. Conf. on Functional \nProgramming, ICFP 07, pp. 13 24. ACM, 2007. [7] B. A. Yorgey, S. Weirich, J. Cretin, S. Peyton Jones, \nD. Vytiniotis, and J. P. Magalh Giving Haskell a promotion. In Proc. of 8th ACM aes. SIGPLAN Workshop \non Types in Language Design and Implementation, TLDI 12, pp. 53 66. ACM, 2012.  \n\t\t\t", "proc_id": "2500365", "abstract": "<p>In dependently typed languages run-time values can appear in types, making it possible to give programs more precise types than in languages without dependent types. This can range from keeping track of simple invariants like the length of a list, to full functional correctness. In addition to having some correctness guarantees on the final program, assigning more precise types to programs means that you can get more assistance from the type checker while writing them. This is what I focus on here, demonstrating how the programming environment of Agda can help you when developing dependently typed programs.</p>", "authors": [{"name": "Ulf Norell", "author_profile_id": "81100528766", "affiliation": "University of Gothenburg, Gothenburg, Sweden", "person_id": "P4261202", "email_address": "ulf.norell@cse.gu.se", "orcid_id": ""}], "doi_number": "10.1145/2500365.2500610", "year": "2013", "article_id": "2500610", "conference": "ICFP", "title": "Interactive programming with dependent types", "url": "http://dl.acm.org/citation.cfm?id=2500610"}