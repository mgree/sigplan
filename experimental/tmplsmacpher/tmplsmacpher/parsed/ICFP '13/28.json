{"article_publication_date": "09-25-2013", "fulltext": "\n Structural Recursion for Querying Ordered Graphs Soichiro Hidaka Kazuyuki Asada * Zhenjiang Hu Hiroyuki \nKato National Institute of Informatics, Japan {hidaka,asada,hu,kato}@nii.ac.jp Abstract Structural recursion, \nin the form of, for example, folds on lists and catamorphisms on algebraic data structures including \ntrees, plays an important role in functional programming, by providing a systematic way for constructing \nand manipulating functional pro\u00adgrams. It is, however, a challenge to de.ne structural recursions for \ngraph data structures, the most ubiquitous sort of data in comput\u00ading. This is because unlike lists and \ntrees, graphs are essentially not inductive and cannot be formalized as an initial algebra in general. \nIn this paper, we borrow from the database community the idea of structural recursion on how to restrict \nrecursions on in.nite un\u00adordered regular trees so that they preserve the .niteness property and become \nterminating, which are desirable properties for query languages. We propose a new graph transformation \nlanguage called AFG for transforming and querying ordered graphs, based on the well-de.ned bisimulation \nrelation on ordered graphs with special .-edges. The language AFG is a higher order graph transformation \nlanguage that extends the simply typed lambda calculus with graph constructors and more powerful structural \nrecursions, which is ex\u00adtended for transformations on the sibling dimension. It not only gives a general \nframework for manipulating graphs and reasoning about them, but also provides a solution to the open \nproblem of how to de.ne a structural recursion on ordered graphs, with the help of the bisimilarity for \nordered graphs with .-edges. Categories and Subject Descriptors CR-number [subcate\u00adgory]: third-level; \nD.3.2 [Programming Languages]: Language Classi.cations Specialized application languages; E.1 [Data Structures]: \nGraphs and networks Keywords Structural Recursion, Ordered Graphs, Graph Query Language, Bisimulation, \nOptimization 1. Introduction Structural recursion, in the form of, for example, folds on lists and catamorphisms \n(Meijer et al. 1991) on algebraic data structures in\u00adcluding trees, plays an important role in functional \nprogramming, by providing a systematic way for construction and manipulation * Current af.liation is \nThe University of Tokyo. Permission to make digital or hard copies of part or all of this work for personal \nor classroom use is granted without fee provided that copies are not made or distributed for pro.t or \ncommercial advantage and that copies bear this notice and the full citation on the .rst page. Copyrights \nfor third-party components of this work must be honored. For all other uses, contact the owner/author(s). \n ICFP 13, September 25 27, 2013, Boston, MA, USA. Copyright is held by the owner/author(s). ACM 978-1-4503-2326-0/13/09. \nhttp://dx.doi.org/10.1145/2500365.2500608 Keisuke Nakano University of Electro-Communications, Japan \n ksk@cs.uec.ac.jp of functional programs (Bird and de Moor 1996; Gill et al. 1993; Hu et al. 2006). \nIt is, however, a challenge to de.ne structural re\u00adcursions for graph data structures, the most ubiquitous \nsort of data in computing. This is because, unlike lists and trees, graphs are essentially not inductive \nand cannot be formalized as an initial al\u00adgebra (Gibbons 1995). Many attempts have been made to resolve \nthis problem by using special trees to represent graphs so that struc\u00adtural recursion on trees can be \nused to manipulate graphs. This in\u00adcludes the work on representing graphs by trees with speci.c point\u00aders \n(Hamana 2009; Dal Zilio et al. 2004; Oliveira and Cook 2012) and by trees with embedded functions (Fegaras \nand Sheard 1996). However, these attempts have not been so successful, because of the gap between trees \n(with speci.c pointers/embedded functions) and graphs, and they require programmers to bridge the gap \nby explic\u00aditly programming these speci.c pointers and embedded functions. Would it be possible to de.ne \na structural recursion on graphs as if the graphs were trees (special graphs), while using it to ma\u00adnipulate \ngeneral graphs? Yes, this has been proved to be possible to some extent in the database community, where \nUnCAL (and its user-level surface syntax UnQL) (Buneman et al. 2000) was intro\u00adduced to provide a powerful \nquerying method through structural recursion on .nite graphs. The graph model of UnCAL is an un\u00adordered \ngraph (whose outgoing edges are not ordered), which can be treated as (unordered) regular trees (Ginali \n1979) given a suit\u00adable de.nition of bisimulation. The bene.t of bisimulation is that structural recursion \non regular trees can be used for graphs, and moreover, it leads to an interesting and important feature \nof struc\u00adtural recursion on graphs: bulk semantics. With bulk semantics, a structural recursion can be \nevaluated by .rst processing all edges of the input graph in parallel and then combining the results. \nBulk se\u00admantics relies on the use of .-edges (like . transitions in the labeled transition system) in \ngraphs and provides a smart way of treating shared nodes and cycles in graphs. Despite usefulness of \nstructural recursion in querying unordered graphs, there are two major limitations with UnCAL. One is \nthat UnCAL can treat only unordered graphs; it cannot treat other graph models, such as the widely used \nordered graphs in which the out\u00adgoing edges of a node are ordered, e.g., in EMF Ecore, MOF, and KM3 (Jouault \nand B\u00b4ezivin 2006). Another limitation is the lack of expressive power of transformations in the sibling \ndimension. For example, when the edges of input graphs are labeled with natural numbers, we cannot write \na transformation in UnCAL that extracts all edges labeled with the average number on the labels of all \nsib\u00adlings. At .rst sight, it seems that the .rst limitation could be easily overcome by encoding ordered \ngraphs as unordered ones with suitable edge labels, say by using hd and tl to represent the .rst branch \nand the rest of the branches, respectively. However, there is a fatal problem with this hd-tl encoding. \nIt is unsound in the context of UnCAL where .-edges must be taken into account for the graph construction \nand structural recursion. Figure 1 shows Figure 1. Examples of Head-tail Encoding and Its Unsoundness \n an encoding example, where the numbers on the nodes have no particular meaning, since we consider bisimulation. \nAs shown in Figure 1, the ordered graphs G1 and G2, where we use dotted arrows to represent .-edges, \nare naturally bisimilar (denoted by . in the .gure), but the corresponding encoded graphs G;1 and G;2 \n(.= in the .gure denotes the encoding) are not bisimilar at all. One might think that we could do the \nencoding after deleting .-edges. However, as the graph G3 in Figure 1 shows, .-edge elim\u00adination of some \nordered graphs could produce in.nite width graphs, and this in.nite-width problem is not trivial to solve \n(see Section 3). Even if we could come up with an encoding, we would still have to show consistency and \nsoundness of the encoding and the corre\u00adsponding decoding and provide a suitable notion of bisimilarity \nfor ordered graphs having .-edges, which is very subtle as well (see Section 3). Moreover, we would need \nan effective way to guaran\u00adtee that UnCAL transformations map well-encoded graphs to well\u00adencoded graphs \nthat can be successfully decoded later. All these suggest it would be better to design a new language \nthat treats or\u00addered graph directly. In fact, it has been an open problem for more than ten years as \nto whether the de.nition of structural recursion in UnCAL can be modi.ed so that it treats ordered graphs \nrather than unordered ones (the issue was .rst raised in the conclusion of the paper (Buneman et al. \n2000)): ... there are some important and interesting areas of re\u00adsearch that may well bear fruit. In \nconnection with XML, we have shown how the principles of UnQL will work on an ordered tree. However, \nit is not clear how they can be extended to an ordered graph model. ... we still lack a com\u00adplete picture \nof this topic ... In this paper, we provide a solution to this problem; i.e., we de.ne a new structural \nrecursion for ordered graphs. For this, we de.ne the subtle notion of bisimilarity for ordered graphs \nhaving .\u00adedges, and prove bisimulation genericity (well-de.nedness with re\u00adspect to bisimilarity) of \nour structural recursion. Note that our (and ref. (Buneman et al. 2000) s) notion of bisimilarity is \ndifferent from that of weak bisimilarity used in process algebra. Weak bisimilarity does not .t our purpose, \nbecause, for example, the graph union op\u00aderator (works like the list append in the case of ordered lists) \nwould not be associative. We propose AFG , a powerful higher-order graph transformation language, which \nis an extension of the simply typed lambda cal\u00adculus with graph constructors and a more powerful structural \nre\u00adcursion for manipulating ordered graphs than what is available in UnCAL. The main contributions of \nthis paper can be summarized as follows. We propose a novel de.nition of bisimilarity between ordered \ngraphs having .-edges, forming the semantic foundation for AFG . Speci.cally, we show that the branch \norder is not neces\u00adsarily .nite but of countable linear order, even for .nite graphs, and clarify that \nthe combination of .-edges and cycles induces such a countable linear order on the branchings, which \nwould cause issues that do not occur in the unordered case. We show that we can decide whether an ordered \ngraph is empty and whether we can eliminate all .-edges for a .nite ordered graph in such a way that \nthe .nite width property of the graph is kept.  We show that graph constructors and structural recursion \non unordered graphs can be adapted to those of ordered ones, forming the core syntax of AFG . Speci.cally, \nwe de.ne a more powerful structural recursion on ordered graphs, which can describe various graph queries \nincluding those on the sibling dimension. We also prove that (1) any graph query in AFG is bisimulation \ngeneric in the sense that it returns bisimilar results for bisimilar inputs, and (2) any graph query \nin AFG terminates, transforming node-.nite graphs to node-.nite graphs. Unlike UnCAL, we also de.ne \nbisimilarity for higher order functions and prove bisimulation genericity of our structural recursion \nas a higher order function; this is the key to extending our language to a simply typed lambda calculus, \nand it makes it clear how we can extend it to rich type systems such as polymorphic/dependent type systems. \nMoreover, our proof of bisimulation genericity is clearer than the original proof given in (Buneman et \nal. 2000); this should make further extensions of structural recursion for graphs easier.  We have implemented \nan interpreter for AFG that is available at http://www.biglab.org/src/lambdaFG/, and we have tested all \nthe examples in this paper. In addition, we demonstrate (but have not implemented) that structural recur\u00adsions \nare suitable for query reasoning and query optimization such as fusion and tupling transformations. This \nshows that our embedding of structural recursions into lambda calculus would be a good foundation to \novercome the known impedance mismatch problem that is often raised from a gap between two languages when \na query language is used in a general-purpose one for developing a practical application.  Note that \nin this paper, the ordered in ordered graph refers to the order on the branchings (rather than, say, \nthe order on the nodes), and graphs generally refers to ordered graphs that can have .-edges. Organization \nof the Paper We shall start with an overview of AFG , a new graph transformation language for querying \nordered graphs in Section 2. In Section 3, we discuss the .rst key technical contribution of this paper, \nde.ning ordered graphs, bisimilarity for ordered graphs having .-edges, and .-elimination. In Section \n4, we give the semantics of our structural recursion and AFG and prove its bisimulation genericity. We \ndemonstrate how to reason about graph transformations and discuss the expressive power of AFG in Section \n5. Finally, we discuss related work in Section 6 and conclude the paper in Section 7. (a) A Simple (b) \nAn Equivalent (c) Result of a2d xc on Graph: G Graph: G; (a) Figure 2. Examples of Graphs 2. Overview \nof AFG We start with an overview of our transformation language AFG for transforming (querying) ordered \ngraphs. We introduce our graph model to which closed terms of graph types in AFG are interpreted. Then \nwe present the syntax and typing rules of AFG and explain how to represent graphs and write transformations \nfor graphs in AFG. 2.1 Ordered Graphs Graphs treated in AFG are multi-rooted, directed, and edge-labeled. \nThe graph model in AFG has three prominent features: .-edges, markers, and graph concatenation. An .-edge \nrepresents a short\u00adcut between the two nodes and behaves like the .-transition in automata. Nodes may \nbe marked with input and output markers. These markers are used as an interface to other graphs through \n.-edges. Graph concatenation sequentially aligns two graphs in a given order. Formally, we de.ne an ordered \ngraph as follows. We write L for a set of labels and La for L U {.}. Let X and Y be .nite sets of input \nand output markers, respectively; we add the pre.x &#38; for markers like &#38;x. Accordingly, an ordered \ngraph G (or just graph) is de.ned by a triple (V, B, I), where V is a set of nodes,  B: V = List(La\u00d7V \n+Y ) is a branch function mapping a node to a list of branches: a branch in La\u00d7V +Y is either a labeled \nedge Edge(l, v) or an output marker Outm(&#38;y), and  I : X = V is afunction which determines the input \nnodes (also called roots)of the graph.  Note that in the terminology of coalgebra theory, an ordered \ngraph is a coalgebra (V, B) of the endofunctor List(La\u00d7(-)+Y ) equipped with a number |X| of initial \nstates I. Example 1 (Ordered Graph). The ordered graph in Figure 2(a), where the branches are ordered \nfor each node, is represented as (V, B, I), where V = {1, 2, 3, 4}B = {1 .= [Edge(d, 2), Edge(a, 4)], \n2 .= [Edge(c, 3)], 3 .= [Edge(d, 2)], 4 .= [Edge(b, 3), Outm(&#38;y)]}I(&#38;) = 1. In our graph model, \nevery node in the range of function I is called a root. In Example 1, node 1 is the root node. Even though \nit is called a root , it may have incoming edges. However, we can convert any graph having such edges \nincoming to the root into graphs bisimilar to the original one but having no such incoming edges. We \nshall write GY X for the set of ordered graphs with the input marker set X and the output marker set \nY . We say that a graph is X .nite if V is a .nite set and write Gf Y for the set of .nite ordered . \n::= . = . | . + . | . \u00d7 . { function, coproduct, product types } | List(.) | Bool { list and boolean \ntypes } | Label | GX { label and graph types } Y e ::= x | Ax.e | e e | case e of inl(x) = e or inr(y) \n= e | inl e | inr e | (e, e) | prle | pre { terms of lambda calculus } r | nil | cons(e, e) | foldr(e, \ne) | ... { functions for lists } | if e then e else e { conditional } | a | e = e { labels (a * L)and \nlabel equality } | [] | e + e | [e : e]| [&#38;y]| &#38;x := e | () | e f e | e @e | cycle(e) { graph \nconstructors } | isEmpty(e) { graph emptiness checking } | srec(e, e) { structural recursion functions \n} Figure 3. AFG Language graphs. When we say just .nite , it always means .niteness on the set of nodes. \nWe allow a graph to have multiple roots, as a multi\u00adrooted graph is to aforest what asingle-rooted graph \nis to atree. For single-rooted graphs, we often use the default marker &#38; to indicate {&#38;} the \nroot and use GY to denote GY . 2.1.1 Graph Equivalence AFG uses bisimilarity (also called value-equivalence) \nas the graph equivalence for ordered graphs. For instance, the graphs G and G; in Figures 2(a) and 2(b) \nare equivalent. In G;, nodes 3 and 3; are bisimilar because both nodes only have one outgoing edge labeled \nd to node 2. Also in G;, there is an .-edge (denoted by the dotted line) from node 1 to node 3, which \ncan be eliminated while maintaining bisimilarity by replacing the .-edge with an outgoing edge labeled \nd from node 1 to node 2. The parts that are unreachable from the roots are disregarded. The formal de.nition \nof bisimilarity for ordered graphs having .-edges, which is one of the important results in this paper, \nis described in Section 3. Note that the notion of equivalence based on bisimilarity in.u\u00adences the expressiveness \nof our query language. For example, since we do not distinguish bisimilar graphs like in Figures 2(a) \nand 2(b) they have different numbers of nodes , we cannot count the number of nodes of a graph.  2.2 \nSyntax of AFG The syntax of AFG is given in Figure 3, and its typing rules are given in Figure 4, though \nwe have omitted some standard typing rules. From here onwards, we will explain the syntax, but will omit \nthe standard explanations for lambda terms and conditionals. We will explain graph constructors and structural \nrecursion in detail in Sections 2.2.1 and 2.2.2 and give their formal semantics in Sections 3.4 and 4. \nWe use the underlined syntax to distinguish certain graph constructors from ordinary list constructors. \nList(.) is the usual list type whose elements belong to .;nil, cons(e, e), and foldr(e, e) are standard \nlist functions, and we can add anyconvenient list functions. These are used for specifying d in srec(e, \nd). Note that we do not include the label . in the syntax; .-edges are only used in the semantics. Equality \nonly applies to labels. We have prepared a set of markers Marker;the metavariables X, Y , and so on denote \n.nite subsets of Marker. Note that we assume type annotations for bound variables, graph constructors, \nand structural recursions: e.g., Ax\".e, []Y , and srecX,Y,Z (e, d); but we will omit them in this presentation \nfor simplicity. We have a type inference procedure to omit marker set annotations in a way similar to \nour previous work for UnCAL (Hidaka et al. 2012). The set of markers a in the type of d is an abstract \nset of markers, which can be viewed as being similar to a type variable in (a . L) \u00d8 e1 : Label \u00d8 e2 \n: Label \u00d8 a: Label e1 = e2 : Bool \u00d8 e1 : GX Y \u00d8 e1 : Label \u00d8 e2 : GX Y \u00d8 e2 : GY \u00d8 [] : GY \u00d8 e1 ++e2 \n: GX \u00d8 [e1: e2]: GY Y (&#38;y . Y ) \u00d8 e: GY \u00d8 [&#38;y]: GY \u00d8 &#38;x := e: G{&#38;x}Y \u00d8 (): G. Y \u00d8 e1 \n: GX1 Y \u00d8 e2 : GX2 Y \u00d8 e1 : GX Y (X1 . X2 = .) \u00d8 e2 : GY Z X1uX2 \u00d8 e1 @e2 : GX \u00d8 e1 f e2 : GY Z \u00d8 e: \nGX (X . Y = .) \u00d8 e: GX XuY Y \u00d8 cycle(e): GX \u00d8 isEmpty(e): Bool Y \u00d8 e: Label\u00d7GY = GZ Z \u00d8 d: List(GZ Z\u00d7Y \n) = GZ Z\u00d7a+GZ Z\u00d7a+Z\u00d7Y = GZ\u00d7X \u00d8 srec(e, d): GX Y Z\u00d7Y (Note that we haveomitted the typing environments \nr in each rule.) Figure 4. Typing Rules for Graph-Related Expressions in AFG Figure 5. Graph Constructors \npolymorphic lambda calculi. This polymorphism in the semantics of our structural recursion is explained \nin Section 4. The graph type GX is interpreted as a set Gf X of .nite graphs. Y Y Similarly to the notation \ngiven in Section 2.1 for sets of graphs, we {&#38;} use GY to denote GY . The predicate isEmpty(e) is \ntrue if the graph obtained by e has no non-.-edges in the accessible part. 2.2.1 Graph Construction \nAFG provides useful graph constructors to build arbitrary .nite ordered graphs. Figure 5 summarizes the \nconstructors; let us see how type discipline on the input and output markers works for each constructor. \nFirst, [] constructs a root-only graph with the default input marker and no output markers. For twographs \nG1 and G2 having identical input markers and output markers, G1 ++ G2 concatenates them byadding twobranching \n.-edges from each new root to the corresponding old roots of G1 and G2. Next, [a : G] extends G with \na new fresh root node pointing to the old root of G with an a-labeled edge; the constructor [&#38;y]constructs \na graph with a single node marked with an output marker &#38;y (in (Buneman et al. 2000), [a : G]and \n[&#38;y]are denoted as {a : G} and &#38;y, respectively). Marker renaming &#38;x := G associates an input \nmarker &#38;x with the root node of G (here, G should have only one default input marker &#38;). () constructs \na trivial graph that has neither a node nor an edge; and G1 f G2 constructs a disjoint union of G1 and \nG2,i.e., the set of nodes of G1 fG2 is the disjoint union of those of G1 and G2 and branching of nodes \n(B)is the same as the original. Then, G1@G2 appends twographs byreplacing the output markers of G1 with \nan .-edge pointing to the corresponding input nodes of G2, and cycle(G) replaces the output marker of \nG with .-edges pointing to the corresponding input nodes of G to form cycles. Note that this set of \nconstructors is powerful enough to describe any.nite ordered graphs (although such a description may \nnot be unique). More precisely, for any.nite graph, there is a term using graph constructors whose interpretation \nis bisimilar to the given graph. This can be shown in aquite similar way to that in (Buneman et al. 2000). \nFor instance, the ordered graph in Figure 2(a) can be constructed as follows: &#38;n1 @cycle((&#38;n1 \n:= [d : [&#38;n2]]+ [a : [&#38;n4]]) f (&#38;n2 := [c : [&#38;n3]]) f (&#38;n3 := [d : [&#38;n2]]) f \n(&#38;n4 := [b : [&#38;n3]]++[&#38;y])).  2.2.2 Structural Recursion Structural recursion in AFG provides \na powerful mechanism to de\u00adscribe transformations and queries over ordered graphs that guaran\u00adtees the \ntermination of the computation and preserves the .niteness of graphs. In general, the typing rule of \nsrec is the one given in Figure 4; but here, for ease of explanation, we will use the following simpli\u00ad.ed \nvariant in which the input graph has no output marker. \u00d8 e: Label\u00d7G. = GZ \u00d8 d: List(GZ Z\u00d7a Z\u00d7a) = GZ \nZ = GZ\u00d7X \u00d8 srec;(e, d): GX . Z\u00d7. This srec; is obtained as syntax sugar from the original srec: ; def \nsrec(e, d) = srec(e, i . d . p) where p : List(GZ Z\u00d7.) = List(GZ Z\u00d7a+GZ Z\u00d7a) discards ele\u00adments in GZ \nin an input list and i : GZ = GZ is Z\u00d7. Z\u00d7a Z\u00d7a+Z\u00d7. the obvious isomorphism. Throughout this section, \nwe will simply ; srec for srec. Nowlet us brie.y explain the semantics of srec(e, d);there are twodifferent \nstyles: recursive semantics and bulk semantics. Recur\u00adsive semantics is more concise and useful for reasoning \nabout not only the behavior of a function de.ned in a recursive way but also program transformation/optimization \n(This will be considered in Section 5.1). On the other hand, bulk semantics is useful for under\u00adstanding \nhowagraph is transformed on the whole, for parallel com\u00adputation, and for proving the termination and \n.niteness-preserving properties. We will explain recursive semantics in a simple form here and formally \ndescribe these two semantics in Section 4. We introduce a reasonable condition called production\u00adconsumption \ncompatibility (PCC) on e and d so that we can give a clearer form of recursive semantics. The condition \nis explained in detail in Section 4.1, and the following examples in this section satisfy it. Furthermore, \nfor simplicity, we consider the following case: d = foldr(8, iG) for some monoid (8, iG) on GZ we Z\u00d7a; \nconsider general d in Section 4.1. The structural recursion function def f = srec(e, d) satis.es the \nfollowing equations (here, equality means the bisimilarity): f([]) = iG f(g1 + g2) = f(g1) 8 f(g2) f([l \n: g]) = e(l, g) @f(g) (1) f(&#38;x := g) = (f&#38;z~Z (&#38;z, &#38;x) := [(&#38;z, &#38;)]) @f (g) f(()) \n= () f(g1 f g2) = f(g1) f f(g2).  Figure 6. Ordered Graph Representation of Books Though the above \nequations do not necessarily determine the func\u00adtions f uniquely (up to bisimilarity), we can obtain \na de.nition of f by the above equations: graphs can be regarded as in.nite trees constructed by the above \nseven graph constructors (i.e., all the nine graph constructors but @and cycle), and hence the above \nequa\u00adtions can be taken as a de.nition by a .xed-point operator. Thus, f transforms graphs along the \nstructures of graphs; e re\u00adplaces a label with a new graph, and d (i.e., 8)acts on branches and transforms \nin sibling directions. The fourth equation is just re\u00adnaming of input markers and the .fth and sixth \nequations are cases of multi-rooted graphs; these three equations are straightforward, and so will be \nomitted in other forms of recursive semantics given later. In the case of the monoid (+ , []) this satis.es \nPCC with any e , the above recursive semantics is the same as given in UnCAL (Buneman et al. 2000) except \nthat we treat ordered graphs rather than unordered graphs. Though the above recursive semantics gives \nus a de.nition of the structural recursion, it is not obvious howto makethe semantics terminating and \nthat the semantics outputs .nite (up to bisimilarity) graphs for given .nite input graphs. It is the \nbulk semantics that shows the termination and .niteness of output graphs; and the bulk semantics satis.es \nthe above equations. In the following, we give several examples demonstrating the power of our language \nin transforming ordered graphs. Further examples are given in Sections 4.1 and 5.2. Example 2. This example \nshows how we can manipulate edges of the graph and change its shape. The following structural recursion \na2d xc replaces all labels a with d and contracts c-labeled edges by using the function rc (remove c). \na2d xc = srec(rc, foldr(+ , [])) where rc(l, g) = if l = a then [d : [&#38;]] else if l =c then [&#38;] \nelse [l : [&#38;]] Applying the function a2d xc to the graph in Fig. 2(a) yields the graph in Fig. 2(c). \nNote that [&#38;]can be considered as a hole that will be later .lled in with a recursive result. Example \n3. This example demonstrates that our structural recur\u00adsion can de.ne transformations in the sibling \ndirection, showing that it is more powerful than the structural recursion in UnCAL. The following function \nreverses the branches of each node of a graph. revBranches = srec(idE, foldr(+ +, [])) where idE(l, g) \n= [l : [&#38;]] r1 + r2 = r2 ++r1 Example 4. This example demonstrates the usefulness of nested structural \nrecursion. Figure 6 shows an ordered graph represen\u00adtation of a list of books that contains hierarchical \nstructures with section -labeled edges. Since section s must be ordered and there would be reference \nlinks in books, we can regard books as ordered graphs. The following nested structural recursion toc, \nwhich is adapted from (Robertson et al. 2009), computes a table-of-contents of books in which sections \ncan be arbitrarily nested: toc = srec(extractSection, foldr(++, [])) where extractSection(l, g) = if \nl = section then [section : (get title(g) + [&#38;])] else [&#38;] where the function get title, again \nde.ned by a structural recur\u00adsion, results in the title of the section. get title(g) = srec(extractTitle, \nfoldr(++, [])) where extractTitle(l1, g1) = if l1 = title then [title : srec(A(l2, g2).[l2 : []], foldr(++, \n[])) (g1)] else [] Example 5. We can de.ne complex graph transformations by gluing together smaller \nones. Suppose that we want to make a reverse version of the table-of-contents of a book. We can simply \nde.ne it as tocRev(g) = revBranches (toc(g)). Before ending the review of AFG, it is worth remarking \nthat compared with the structural recursion in UnCAL (Buneman et al. 2000), structural recursion in AFG \ncan deal with ordered graphs and computations on the sibling dimension of graphs; in fact, srec in UnCAL \ndoes not have the function argument d. As will be seen later,the keyto the success of our extension from \nunordered graphs to ordered ones is a new de.nition of bisimilarity for ordered graphs having .-edges, \nunder which (.nite) ordered graphs are equivalent to (possibly in.nite) regular trees up to bisimilarity. \nIn the rest of this paper, we will formally de.ne our version of bisimilarity on ordered graphs, give \na formal semantics for AFG, prove the three important properties of AFG, namely bisimulation genericity, \ntermination, and .niteness-preservation, and demon\u00adstrate how to reason about graph transformations. \n3. Ordered Graphs and Bisimilarity As discussed in the introduction, direct manipulation of graphs is \ndif.cult. We will tackle this problem by regarding graphs as their equivalent trees so that we can manipulate \ngraphs as if to manipu\u00adlate trees. To this end, we need to de.ne the semantic equivalence for the graph \nmodel of AFG:bisimilarity between ordered graphs. It should be noticed that ordered graphs have a big \nproblem that does not occur with unordered graphs: i.e., .-elimination might induce branches with an \nin.nite width. In the following, we shall illustrate this problem and show how to de.ne bisimilarity \nbetween ordered graphs. We will show an effective procedure to avoid in.nite-width graphs. 3.1 Bisimilarity \nfor Ordered Graphs Let us show some examples of ordered graphs in order to get a feeling for the bisimilarity \nto be de.ned. Consider the graphs in Figure 7. Unfolding the graph Gs will yield an in.nite tree (the \ngraph in the middle), and performing .-elimination on the in.nite tree will give the graph on the right, \nwhose branchings Gs Gd . . . . Figure 7. Graphs with Stream Branching and with Dense Branch\u00ading look \nlike a stream. However, such in.niteness that occurs in or\u00addered graphs having .-edges is not just the \nstream type, as in the next example Gd. Unfolding Gd will yield the tree in the middle, and performing \n.-elimination will give the graph on the right. This graph has a set of branches behaving like the ordered \nset {n/2m.Q| n, m . N, 0<n<2m}, which is a dense countable lin\u00adear ordered set.1 It is worth noting that, \nif we were in an unordered setting where the branches are sets (that is, duplications of iden\u00adtical branches \nare ignored), Gs and Gd after .-elimination would be bisimilar to the graph with only one branch; consequently, \n.\u00adelimination in this case would just delete the .-loops. Now let us de.ne bisimilarity between ordered \ngraphs. As can be seen from the above examples, the .-elimination of an ordered graph might induce a \ncountable width. Therefore, we shall .rst de.ne a generalized notion of an ordered graph with a countable \nwidth , and then proceed to de.ne bisimilarity for such generalized graphs. To this end, for a set S, \nwe extend the set of lists List(S)(= .n~NSn) to that of the countable list CList(S) de.ned as defL CList(S) \n= .L~LS where N is generalized to L, the set of countable linear ordered sets up to order isomorphism \n2. Replacing List with CList, we extend the notion of ordered graph to that of ordered graph with a countable \nwidth. The set of such extended graphs is denoted by GcX Y . Certainly, our original ordered graphs GY \nX are a subset of GcX Y . Once we become aware of the importance of countable linear order, our idea \nto de.ne bisimilarity between graphs in GcX is Y rather simple. Informally, given two graphs, a relation \nR is a bisim\u00adulation relation if for any two R-related nodes v and v;, their corre\u00adsponding proper branch \nsets are related through R. Here a proper branch of a node is de.ned as a path from v going through zero \nor more .-edges and reaching a non-.-edge. Now we see the formal de.nitions. For a branching function \nB(v), we use |B(v)| to denote the countable linear ordered set L, call i . |B(v)| a branch index of a \nnode v, and write B(v).i . La\u00d7V +Y for the i-th branch. De.nition 6 (Proper Branch). Let G = (V, B, I \n) . GcX Y and v . V . The path starting from v v (= v0) a=i0 v1 ... a=in-1 vn =in 1In this paper, the \nterm countable includes the .nite case. 2 More precisely, CList(S) is the set of objects of the skeleton \nof the comma category (U l S) where U : CLO -Set is the forgetful functor from the category CLO of countable \nlinear ordered sets and monotone functions. is called a proper branch of v if the in-th branch B(vn).in \nis not an .-edge; i.e., it is either a non-. edge or an output marker. The set of all proper branches \nof v in G is denoted by Pb(G, v). De.nition 7 (Order on Proper Branches). Given two proper aa branches \np = (v =i0 v1 ... =in-1 vn =in ) and ; a;a; p= (v =it v1 ... =it vnt =it ), let their branch index 0 \nnt-1 nt def def sequences be p = (i0, ..., in-1, in) and p ; = (i0;, ..., i;t-1, i;t ). nn def We de.ne \np :Pb p; ~. p :l p ;, where :l is the lexicographical order between branch index sequences. Now we are \nready to de.ne the bisimilarity. De.nition 8 (Bisimilarity). For two graphs G = (V, B, I ) and G; = \n(V ;, B; ) in GcX V and V ; is , I ; Y , a relation R between called a bisimulation relation, if for \nany vRv;, there is an order isomorphism f : (Pb(G, v), :Pb) = (Pb(G;, v;), :Pb) satisfy\u00ading the following \norder-preserving property: For any proper branch aa p = (v =i0 ... vn =in ) . Pb(G, v) with f(p) = (v; \n=it 0 ... v;t ) . Pb(G;, v;), we have n=it t n Edge Correspondence: if B(vn).in = Edge(l, u) for some \nl . L, u . V , then there exists u; . V ; such that B;(v;t ).i;t = Edge(l, u;) and uRu;, nn Marker Correspondence: \nif B(vn).in = Outm(&#38;y) for some &#38;y . Y , then B;(v;t ).i;t = Outm(&#38;y). nn Two graphs G and \nG; are bisimilar (denoted by G . G;) if there is a bisimulation relation R such that for every input \nmarker &#38;x . X, I(&#38;x) R I ;(&#38;x). 3.2 Elimination of .-Edges The .-edges are introduced (and \nnecessary) in our internal seman\u00adtics of graph transformation, but unnecessary .-edges in the .nal result \nshould be eliminated. The following de.nition leads to a procedure to eliminate .-edges (for example \nby taking transitive closures) from the graphs and shows that the graph obtained by .-elimination is \nbisimilar to the original graph. De.nition 9 (.-elimination). For a graph G = (V , B, I ) . GcX Y , the \n.-elimination .-elim(G) of G is a graph (V , B; Y , I ) . GcX def def where |B;(v)| = Pb(G, v) and B;(v).p \n= B(vn).in for p = a (v =i0 ... vn =in ) in |B;(v)|. Note that the .-elimination does not change the \nsets of nodes. Proposition 10. GcX 1. For any G . Y , .-elim(G) has no .-edge, and G and .-elim(G) \nare bisimilar. 2. Two graphs G, G; . G cX are bisimilar if and only if .-elim(G)  Y and .-elim(G;) \nare bisimilar.  3.3 Decidability of Empty and Finite-Width Graphs In our graph transformation, i.e., \nany function from a graph type to a graph type in AFG like tocRev in Example 5 the input graph is usually \nan ordered graph that has neither .-edges nor in.nite width, but the result may contain .-edges in our \ncontext. In the following, we show that, given a graph with .-edges, it is possible to decide whether \nthere is a corresponding bisimilar ordered graph that has neither .-edges nor in.nite width, and there \nis a procedure to compute out such a bisimilar graph. Let FG/. be the set of .nite ordered graphs (with \n.nite width and possibly with .-edges) that are bisimilar to some .nite ordered graphs without .-edge \nor in.nite width. The following procedure answers (decides) whether a .nite ordered graph G is in FG/. \nor not. 1. For each node accessible from a root, check if there is an .\u00adcycle a cyclic path consisting \nonly of .-edges on the node or not. If there is no .-cycle, then G is in FG/.. 2. Otherwise, for every \naccessible node with an .-cycle, if there is no proper branch, then graph G is in FG/.;otherwise, it \nis not in FG/..  If G is in FG/., we can effectively eliminate .-edges; otherwise, it is impossible \nto eliminate .-edges and keep the width .nite. isEmpty(G) is true iff G has no non-. edge in the accessible \npart, and thus, it is decidable. Note that this procedure is useful for evaluating AFG; though we need \n.-edges for the implementation for structural recursion and for the ef.ciencyof the graph calculation \n, practical graphs in the real world have no .-edges. If a user writes such a practical query,the result \nshould be agraph in FG/.;if it is an incorrect query not intended by the user and then if the result \nhas .-edges, the above procedure can determine this and can warn the user. Note also that, in the FG/. \nclass, since we can eliminate .-edges, we can use familiar effective procedures for checking bisimilarity \nand for obtaining the minimum graphs in asimilar way to that of unordered graphs.  3.4 Graph Constructors \nIn Section 2.2.1, we have given an intuitive explanation for our graph constructors; the formal semantics \nof them should be obvi\u00adous. As an example, we give the semantic de.nition of G1 + G2 (the formal semantics \nof all graph constructors can be found in Ap\u00adpendix A). For Gi = (Vi, Bi, Ii) . GY X , def G1 ++G2 = \n(V1 U V2 U {v1, . . . , vm}, B;, I;) where v1, . . . , vm are fresh node identi.ers {&#38;x1, . . . , \n&#38;xm} = Dom(I1) (= Dom(I2)) B; = B1 U B2U {vi .= [Edge(., I1(&#38;xi)), Edge(., I2(&#38;xi))] | i=1, \n..., m} I; (&#38;xi) = vi. Above, we assume V1 and V2 to be disjoint, which is realized by taking copies \nof them; recall that node identity is ignored in the context of bisimilarity. One important property \nof the graph constructors is that they are bisimulation generic. As an example, consider G1 ++ G2;we \nwant to show that ++ is bisimulation generic in the sense that if G1 . G1;and G2 . G2;, then G1 ++ G2 \n. G1;++ G;2. We say that two graphs are strongly bisimilar if they are bisim\u00adilar without special treatment \nof .-edges (i.e., .-edges are con\u00adsidered as ordinary edges but labeled .). It is quite straightfor\u00adward \nto see that the graph concatenation constructor + is strongly\u00adbisimulation generic. Furthermore, we can \nsee that .-elim(G1 ++ G2) is bisimilar to .-elim(.-elim(G1)++.-elim(G2)). This means that strong-bisimulation \ngenericity implies bisimulation generic\u00adity for this graph constructor. Similarly we can show other graph \nconstructors are bisimulation generic. This leads to the following proposition. Proposition 11 (Bisimulation \nGenericity of Graph Constructors). All the graph constructors are strongly-bisimulation generic and also \nare bisimulation generic. 4. Structural Recursion Here, we give the semantics of our structural recursion; \nwe modify structural recursion for unordered graphs UnCAL (Buneman et al. 2000)to deal with ordered graphs \nand extend it so that we can transform graphs also in the sibling direction. We start by giving recursive \nsemantics of our structural recursion; this enables us to understand the behavior of functions by recursive \nreasoning. After that, we give the bulk semantics of the structural recursion to show the termination \nand .niteness preserving properties. Next, we show that our structural recursion and every transfor\u00admation \nin AFG are bisimulation generic;i.e., theyreturns bisimilar results for bisimilar inputs. This bisimulation \ngenericity plays an important role in our framework, allowing us to reason about prop\u00aderties of graphs \nby using (possibly in.nite) trees bisimilar to them. To this end, we extend the notion of bisimilarity \nto higher order functions in Section 4.3 and give the whole semantics of AFG. After that, we will discuss \nimplementation and termination property. Finally, we will summarize relations of conditions and results \nprovided in this section. Below, we often use the following marker renaming graphs: for a marker renaming \nfunction f : X = Y , we de.ne a graph def .fn . GX as .fn = L &#38;x := [f(&#38;x)]. As two use cases, \nY &#38;x~X for G . GY X with f : X; = X, .fn @G . GY Xt is input marker renaming by f: an input marker \nf (&#38;x) is replaced with &#38;x and input markers of G that are not in the image of f are removed. \nAlso, for G . GY X with f : Y = Y ;, G @.fn . GY X t is output marker renaming by f:an output marker \n&#38;y is replaced with f(&#38;y). 4.1 Recursive Semantics In Section 2.2.2, we described the recursive \nsemantics of our structural recursion in the simple setting where we ignored output marker cases, assumed \nproduction-consumption compatibility (PCC), and restricted d to be the form of foldr(8, iG). Here, we \nwill give other forms of recursive semantics, relaxing these restrictions; but we still ignore output \nmarker cases for the sake of simplifying the presentation. (For recursive semantics for the general d \nwithout ignoring output markers, see Appendix B.) Hence, in this subsection, the type of d is List(GZ \nZ\u00d7a Z\u00d7a. ) = GZ (In bulk semantics, though, we will deal with also output marker cases.) First, let \nus explain the polymorphism a in the type of d. This a plays two important roles: It is used to substitute \na concrete set for a in order to express recursivesemantics and de.ne bulk semantics; it is also used \nto showbisimulation genericity of the bulk semantics by using relational parametricity. Formally, we \nshould introduce a by formulating AFG as polymorphic typed lambda calculus as well as by introducing \nsets of markers as types, but to keep the presentation simple, we formulated AFG as a simply typed lambda \ncalculus. In the following explanation of semantics, we will write dX for the type application of d to \nX on a,and when we interpret srec(e, d), we introduce the universal quanti.er .a. for d to bind a. We \nuse the type application only in semantics for the above purposes, and do not use syntactically in AFG \nitself. Thus, AFG is essentially a rank-2 polymorphic lambda calculus; hence, type inference is decidable \n(Kfoury and Tiuryn 1990). Now,let us consider recursivesemantics of f = srec(e, d). For general e and \nd,the straightforward generalization of Equations (1) should be, just in form, as the following: f([l1 \n: g1]++\u00b7 \u00b7 \u00b7 ++[ln : gn]) ` \u00b4 (2) = d. [e(l1, g1) @f(g1), . . . , e(ln, gn) @f(gn)] . This equation \nmeans that, when we start from the root of a graph, we have the branches [li : gi]under the root; then \nf .rst computes e(li, gi) and recursively computes f(gi);theyare connected by @ and .nally are transformed \nin the sibling direction by using d. However, for general e and d, this recursive semantics is not necessarily \ncorrect, i.e., the structural recursion functions de.ned by bulk semantics given later do not necessarily \nsatisfy this equa\u00adtion. On the other hand, if we evaluate the above recursively, then, since the computation \nof d depends on f(gi), and since gi may include a cyclic path returning to the original root, the evaluation \nmay not terminate. Even if it terminates, the result is not necessarily bisimilar to the result by bulk \nsemantics. Instead, for general e and d, we have the following recursive semantics. f([l1 : g1]+ \u00b7 \u00b7 \n\u00b7 + [ln : gn]) ` \u00b4 = dn\u00af[e(l1, g1)@.in1n, . . . , e(ln, gn)@.innn] (3) ` \u00b4 ` \u00b4 @ .iso1n@f(g1) f \u00b7 \u00b7 \u00b7 \nf .isonn@f(gn) def def where n\u00af= {1, ..., n}, ini : Z = Z\u00d7n\u00afis de.ned as ini(&#38;z) = def (&#38;z, i), \nand isoi : Z\u00d7{i} .Z is de.ned as isoi((&#38;z, i)) = &#38;z. = This might look a bit complicated, but \nyou can disregard marker\u00adrenaming parts @.inin and .isoin@, which are not essential. A noteworthy point \nin Equation (5) is that d is applied before @ connects e(li, gi) to f(gi);in Equation (2), the order \nis reversed. Now, the PCC condition is naturally introduced as the require\u00adment that the recursive semantics \n(2)and (3) coincide, i.e., the order of application of d and connecting e(li, gi) with f (gi) by @ may \nbe interchanged. Formally e: Label\u00d7G. = Z and GZ d: List(GZ ) = GZ are called production-consumption \nZ\u00d7a Z\u00d7a compatible (PCC) if theysatisfy the following equation: ` \u00b4 ;; d. [e(l1, g1) @g1, . . . , e(ln, \ngn) @gn] ` \u00b4 = dn\u00af[e(l1, g1) @.in1n, . . . , e(ln, gn) @.innn] ` \u00b4 ` \u00b4 ;; @ .iso1n@g1 f \u00b7 \u00b7 \u00b7 f .isonn@gn \nIntuitively,the abovecondition says that d consumes only the infor\u00admation in the graphs produced by e \nand does not traverse beyond the output markers of the graphs produced by e. For example, if we write \ne such that any e(l, G) has no output markers down to depth three, we can write d that can traverse graphs \nup to depth three. Note that, if d changes only the positions of graphs in an input list such positions \nare regarded as positions of branches and does not traverse each graph, then d satis.es the PCC condition \nwith anye. By de.nition, if e and d satisfy PCC, then f = srec(e, d) has the recursive semantics (2). \nNote that, in this paper, we call only the functions de.ned by the following equivalent semantics structural \nrecursion functions (and denoted by srec(e, d)): (i) the bulk semantics (De.nition 13), (ii) the recursive \nsemantics (3), and (iii) when PCC holds, the recursive semantics (2) and (1). For example, if e and d \ndo not satisfy PCC, then in this paper we do not call functions de.ned by the recursive semantics (2)structural \nrecursion functions even if theyterminate. Introducing d is our extension for sibling transformations \nfrom the original structural recursion in UnCAL. Note that, no matter whether we use the general recursive \nsemantics (3) or the recursive semantics (2) with PCC, access by d is con.ned to the graphs produced \nby e anyway. This is the keyrestriction on our structural recursion for termination. Example 12. In this \nexample, d satis.es PCC with anye. To re\u00ad def move the even branches of a graph, we can apply even remove \n= def def def srec(e, d) where e(l, g) = [l : &#38;]; and d([]) = [], d([g]) = g, and ; def d(g :: g:: \ngs) = g + d(gs). In the next example, e and d do not satisfy PCC, but we still can reason that this \nworks as expected from the recursivesemantics (3). Tocontract the even edges of agraph, from (3), it \nis enough that e is an identity and d contracts even labeled edges; i.e., we can apply def even contract \n= srec(e, d) where def def def e(l, g) = [l : &#38;], d([]) = [], d([g]) = g, ; def ; d(g :: g:: gs) \n= g ++p(g) + d(gs), def {&#38;} {&#38;} p = srec(A(l, g).[&#38;], foldr(+ , [])) : G= G. {&#38;}\u00d7a {&#38;}\u00d7a \n 4.2 Bulk Semantics Here, we give bulk semantics of the structural recursion srec(e, d) for a general \nd not assuming PCC nor ignoring output markers. Before giving the formal de.nition of the bulk semantics \nof srec(e, d), we illustrate the behavior of the semantics in an ex\u00ad def ample a2d xc = srec(rc, foldr(+ \n, [])) (see Example 2for rc). Mainly, an evaluation with the bulk semantics consists of three steps; \nwe start with the input graph (a) in Figure 8. 1. Applying the Map Computation on Edges with e We apply \nthe function rc (which renames a-labeled edges as d-labeled ones and contracts the c-labeled edges) to \nevery l\u00ad labeled edge and the graph g following the edge, to yield a graph in GZ Z . Let us call the \ngraphs produced by an expression e e-graphs. Graph (b) is a graph whose edges are labeled by rc-graphs. \n 2. Applying Map Computation on Nodes with d For each edge from a node v to a node v; of Graph (b), we \nreplace every output marker &#38;z of the e-graph with a pair ; (&#38;z, v), which will be used in the \nnext grouping step. Next, for every node v of Graph (b), we use binary operator + to combine all e-graphs \nwhich are labels of the branches of v. Let us call the graphs produced using d (= foldr(++, [])) d-graphs; \nGraph (c) shows the result. Nodes 1 and 4 have more than one branch which need to be merged using ++. \nAfter producing the d-graph for v, we replace each input marker &#38;z with a pair (&#38;z, v). 3. Grouping \nNew Graphs with .-Edges Now, for each node of Graph (b) equivalently, for each node of the original graph \n, we have a d-graph produced as above. We group all these d-graphs in Graph (c) by connecting every output \nmarker (&#38;z , v) of every d-graph to the corresponding input node of some d-graph by using an .-edge. \nThe root of the new graph is that of the d-graph on the original root node. Thereby, we get Graph (d) \nas an evaluation result of the struc\u00adtural recursion. Graph (e) is the graph obtained by perform\u00ading \n.-elimination on Graph (d). We remark that .-elimination may increase the number of non-. edges as this \nexample. (We can further minimize Graph (e) if necessary, resulting the graph in Figure 2(c).) Before \napplying a structural recursion function srec(e, d) to G, we have to perform .-elimination on G; if .-elim(G) \nhas in.nite width, we raise an error. Without the .-elimination, if we extend the bulk semantics to treat \ninput graphs hav\u00ad def ing .-edges by extending e to e\u00af(., g) = .idZ n, then the srec(\u00afe, d) is not necessarily \nbisimulation generic, as shown by the following counter example. The two graphs on the left are bisimilar, \nbut if we apply the structural recursion function even remove in Example 12, the resulting graphs are \nnot bisimilar. Though, if d = foldr(++, []) or d = foldr(+ +, []) (reverse func\u00adtion), then we can show \nthe bisimulation genericity without performing .-elimination. Now let us give the formal de.nition of \nthe bulk semantics of the structural recursion. Note that the following de.nition is more concise than \nthe one given in (Asada et al. 2012), which mimics the original bulk semantics of UnCAL given in (Buneman \net al. 2000); and this simpli.cation makes the proof of bisimulation genericity clearer. De.nition 13 \n(Bulk Semantics). For functions e: L\u00d7GY = GZ +GZ d: .a.List(GZ Z\u00d7Y ) = GZ Z Z\u00d7a Z\u00d7a+Z\u00d7Y , a structural \nrecursion function srec(e, d): GX = GZ\u00d7X is de- Y Z\u00d7Y .ned as follows. Let G = (V, B, I) be a graph in \nGY X . As explained above, we perform .-elimination on G in order to ensure bisimulation genericity; \nhence, we assume G has no .-edges. Let us de.ne e : L\u00d7V = Z as e . (idL\u00d7G|(-)), where G|(-) : V = GY \nGZ def extracts the subgraph of G whose root is a given node: i.e., G|v = (V, B, {&#38;.=v}). Then, as \nin the .rst step explained above, we construct a new branching function B; def = map(( e, a2)+idY ) . \nB of type Bmap(. e,72\u00d8+idY ) V ------------= List(GZ = List(L\u00d7V +Y ) Z \u00d7V +Y ). This corresponds to a \nstep producing Graph (b) in Figure 8. def As for the second step, .rst, we construct a function d;= a \nda . map(p+q) of type map(p+q) da List(GZ Z \u00d7a+Y ) -= List(GZ Z\u00d7Y ) = GZ +GZ ----Z\u00d7a -Z\u00d7a+Z\u00d7Y def def \nwhere p(G, &#38;a) = G @ .&#38;z .= (&#38;z, &#38;a)n and q(&#38;y) = .&#38;z .= (&#38;z, &#38;y)n. Next, \nby using the following bijective corre\u00adspondence, . = oplus : (V =GZ Z \u00d7V +Z\u00d7Y ) -= GZ\u00d7V Z\u00d7V +Z\u00d7Y , \nL def oplus(f) = (&#38;z, v) := ([&#38;z]@f(v)) (&#38;z,v)~Z\u00d7V we obtain a graph G; def = oplus(d;. \nB;) . GZ\u00d7V , which V Z\u00d7V +Z\u00d7Y corresponds to (c) in Figure 8;then, in correspondence with (d) in Figure \n8, we de.ne srec(e, d)(G) = .idZ \u00d7In@ cycle(G;) Z\u00d7Y def (. GZ\u00d7X ). It is worth remarking that the abovebulk \nsemantics is essentially root-independent:the whole part except for the .nal step i.e., till constructing \ncycle(G;) does not use the input function I. The following is clear from the above bulk semantics. Proposition \n14. If the functions e and d map .nite graphs to .nite graphs, so does srec(e, d). From the above bulk \nsemantics, we can show obviously the termination property of AFG. We can implement the above bulk semantics \nin an obvious way: We may represent graphs (X, Y, V, B, I) using set and map (implemented as, e.g., balanced \ntrees); X,Y , and V are as set s, and B and I are as map s. Then implementation of the bulk semantics \nis straightforward. It is clear that the computation of the bulk semantics terminates by the above de.nition \nand the .niteness on nodes and width of graphs, which is ensured by the above proposition. Our actual \nimplementation in OCaml can be found at http://www.biglab.org/src/lambdaFG/; note that d in srec in the \nimplementation is currently restricted to the form foldr(8, iG). 4.3 Semantics of AFG and Bisimilarity \non Functions Before proving the bisimulation genericity of the structural recur\u00adsion, we will summarize \nthe whole semantics of AFG. A requirement of our semantics is that it should guarantee that any transformation \nincluding the one using higher order functions in AFG must be bisimulation generic. To this end, we extend \nthe notion of bisimilarity on graphs to bisimilarity on functions in AFG. We have de.ned bisimilarity \nfor graph types GX the equality relations for the other Y , and we can use basic types. It is well known \nthat, if we want to lift equivalence relations to function types, we need to switch from the notion of \nan equivalence relation to that of a partial equivalence relation, i.e., equivalence relation on some \nsubset of the original set. This is because, in the current case, it is not true that all functions on \nX Gf Y are bisimulation generic, so we have to focus on its subset consisting of bisimulation generic \nfunctions. Formally, for types . of AFG, we de.ne binary logical relations .\" from the above equivalence \nrelations on the base types. Let us recall the logical relation .\" only in the essential case, i.e., \nfunction types: . = .1 = .2 (for other cases, one can consult (Mitchell def 1996)). We de.ne a binary \nrelation .\" on [ .] = [ .1] = [ .2] as f; def; ; f; ; f .\" ~. .x, x. [ .1] . (x .\"1 x. f(x) .\"2 (x)). \nFor anytype ., .\" becomes a partial equivalence relation on [ .] , def i.e., an equivalence relation \non the subset |.\"| = {x . [ .] | x .\" x}. We say a function f : [ .1] = [ .2] bisimulation generic if \nf is in |.\"1*\"2 |. Now from the Basic Lemma of the logical relation (Mitchell 1996), interpretations \nof all the terms are bisimulation generic if in\u00adterpretations of all the constants (including constant \nfunctions) are bisimulation generic; accordingly, we can form a model (a carte\u00adsian closed category) \nof AFG such that the interpretations of types are the quotient sets of the partial equivalence relations. \nWe have already shown the bisimulation genericity of graph constructors, and now we will show the same \nfor the structural recursion.  4.4 Bisimulation Genericity of the Structural Recursion We prove a stronger \nstatement of bisimulation genericity than the original one in (Buneman et al. 2000), which proves only \n.rst-order bisimulation genericity, i.e., only bisimulation genericity on graph arguments. In addition, \nour proof is much clearer than the original naive proof. This simpli.cation should make further extensions \nof structural recursion easier. Theorem 15 (Bisimulation Genericity of srec). The higher order function \nsrec is bisimulation generic; i.e., for e1 . e2, d1 . d2, and G1 . G2, srec(e1, d1)(G1) . srec(e2, d2)(G2). \nWe will use the following notions and notations in the proof of the above theorem. We write R : A1 + \nA2 for a relation R . A1\u00d7A2;e.g., the diagram on the left below means that if a1 R a2, then f1(a1) S \nf2(a2). f1 I1 - - B1 - A1 B1 X1 V1 CList(L\u00d7V1+Y1) R+ +S S+ R+ +CList(L\u00d7R+T ) - A2 f2 B2 X2 - V2 - CList(L\u00d7V2+Y2) \nI2 B2 For S : X1 + X2 and T : Y1 + Y2, let us de.ne the relation .S GX2 T : GX1 + : for Gi, let (Vi, \nBi, Ii) = .-elim(Gi), then Y1 Y2 G1 .S G2 if there exists a relation R : V1 + V2 such that T the right \ndiagram above commutes (i.e., each of the two squares is true). We write simply X for the diagonal relation \nbetween X and X, then note that .X Y + GY X is the same as .. Y : GX Proof. Let Gi be (Vi, Bi, Ii). From \nG1 . G2, there exists R : V1 + V2 such that the following diagram commutes. I1 X - V1 B1 - List(L\u00d7V1+Y \n) R+ +List(L\u00d7R+Y ) (4) X V2 List(L\u00d7V2+Y ) I2 B2 Next, from the assumption that e1 . e2 and d1 . d2, \nthe following diagram commutes. dt map(.e 1,72\u00d8+idY ) B11V - 1 V1 Z \u00d7V1+Y ) Z\u00d7V1+Z\u00d7Y - List(L\u00d7V1+Y ) \n- List(GZ GZ Z R+ List(L\u00d7R+Y )+ Z + + List( Z \u00d7R+Y ) Z\u00d7R+Z\u00d7Y - - - GZ V2 List(L\u00d7V2+Y ) Z \u00d7V2+Y ) List(GZ \nZ\u00d7V2+Z\u00d7YB2 dt map(.e 2,72\u00d8+idY ) 2V2 Note that to show the right square above, we also use the relational \nparametricity of di and hence of d;i; see De.nition 13 for the de.nition of d;i. Then, for the above \ncompositions, transposing Vi by using oplus as in De.nition 13 yields Gt 1 -GZ\u00d7V1 1 Z\u00d7V1+Z\u00d7Y Z\u00d7R + G;1 \n.Z\u00d7R G; Z\u00d7R+Z\u00d7Y i.e., Z\u00d7R+Z\u00d7Y 2. (5) -GZ\u00d7V2 1 Z\u00d7V2+Z\u00d7Y Gt 2 After that, we can show that 1) .Z\u00d7R cycle(G;Z\u00d7Y \ncycle(G;2), (6) and from the left square of the diagram (4) we get .idZ \u00d7I1n @cycle(G;1) .Z\u00d7X .idZ \u00d7I2n \n@cycle(G;2) Z\u00d7Y i.e., srec(e1, d1)(G1) . srec(e2, d2)(G2). For readers familiar with category theory,we \nwill elaborate abit on the general technique behind Equation (6). From the correspon\u00addence Y .= GY , \nwe can construct a monad on Set;then cycle becomes an iteration operator (dual of .xed point operator) \nin its Kleisli category. Furthermore, the iteration operator is uniform on values (i.e., functions). \nThe above Equation (6) from Equation (5) is then the uniformity principle on relations (Hasegawa 2002). \n 4.5 Remark We conclude this section with a summary of some conditions that we assumed occasionally. \n(Ignoring output marker cases is just for presentation and not essential.) We use PCC to obtain more \nfamiliar form of recursive seman\u00adtics (2), and moreover we assumed d to be in the fold form of monoid \nto obtain simpler recursive semantics (1). The PCC con\u00addition and its recursive semantics are also used \nfor optimization given in Section 5.1. The polymorphism of a of d is used to express recursive se\u00admantics \nand de.ne bulk semantics, and its parametricity is used to prove the bisimulation genericity of the bulk \nsemantics. The pre\u00adprocessing of .-elimination for input graphs of structural recursion functions is \nalso used to prove the bisimulation genericity. Termination and node-.niteness preserving properties \nof the structural recursion was shown via the bulk semantics, and essen\u00adtially comes from the suitable \nrestriction of recursion pattern; our structural recursion still has rich expressivepower (see Section \n5.2) and enables systematic optimization bythe recursivesemantics (see Section 5.1). 5. Discussion 5.1 \nOptimization of AFG Programs Embedding graph queries into lambda calculus as structural recur\u00adsions would \nmake query optimization easier and more systematic. This is not only because existing optimization techniques \nfor func\u00adtional programs can be directly brought in, but also because struc\u00adtural recursion itself has \nnice algebraic properties for optimization. Here, we illustrate the usefulness of structural recursion \nin reason\u00ading and manipulating graph queries with two known transformation techniques, fusion and tupling. \nFusion Transformation Fusion (or called deforestation) (Meijer et al. 1991; Gill et al. 1993; Takano \nand Meijer 1995) is an impor\u00adtant program transformation to turn a composition of two structural recursions \ninto one so that unnecessary intermediate data passed from one structural recursion to another can be \nremoved. The fol\u00adlowing is our fusion rule showing that a composition of a function f and a structural \nrecursion srec(e, d) can be merged into one as long as the PCC condition holds for e and d: f . srec(e, \nd) = srec(e; . e, d;) holds, provided that f is promoted on d and demoted on @; i.e., for some f;, we \nhave ; f . d = d; . map f; and f;(g @r) = e(g) @f(r). Tupling Transformation Tupling (Hu et al. 1997) \nis another im\u00adportant optimization technique. It eliminates multiple traversals of the same data. Our \nfollowing tupling transformation rule reduces two traversals of G given by two structural recursions \ninto one. (&#38;x1 := srec(e1, d1)(G)) f (&#38;x2 := srec(e2, d2)(G)) = srec(e, d)(G) where e (l, g) \n= (&#38;x1 := (e1(l, g) @[&#38;x1])) f (&#38;x2 := (e2(l, g) @[&#38;x2])) d gs = (&#38;x1 := d1(map (Ag.[&#38;x1]@g) \ngs)) f (&#38;x2 := d2(map (Ag.[&#38;x2]@g) gs)) The new structural recursion basically computes in parallel \ntwo graphs marked by &#38;x1 and &#38;x2. Note that the tuple construction and projection that are used \nin the ordinary tupling technique are encoded here by the disjoint union (f)and marker renaming: a pair \n(g1, g2) is by (&#38;x1 :=(g1 @[&#38;x1])) f (&#38;x2 :=(g2 @[&#38;x2])), and a projection ai(g) is by \n[&#38;xi]@g.  5.2 Expressive Power of AFG In the previous sections, we described the de.nition and properties \nof AFG , and showed some interesting query examples. In this sec\u00adtion, we discuss the expressive power \nof AFG from the user s point of view, to show that AFG can serve as a basis of query languages on ordered \ngraphs under bisimulation. As has already been demonstrated by Buneman et al. (2000) in the unordered \nsetting, nesting of srec can produce a se\u00adquence of combinations of label and graph variable bindings \n(A(l1, g1), A(l2, g2), . . .). We can combine this nesting with condi\u00adtionals on these variables to express \nvariety of join conditions. For example, two nested structural recursions can extract subgraphs following \nconsecutive edges with identical labels. Moreover, regular path expressions of labels can be expressed \nby srec with a body e generating multiple roots via tupling (Hu et al. 1997), as shown in Section 5.1. \nSuch an e can be systematically constructed from the regular path expressions of labels via .nite state \nautomata, as in Buneman et al. (2000) (while NFA is used in (Buneman et al. 2000), we need DFA to make \nthe result well-de.ned). These kinds of queries in AFG can be concisely expressed by using a more user-friendly \nsyntactic sugar like UnQL for UnCAL in (Buneman et al. 2000) (although we do not give any concrete desugaring \nrules here) so that users do not have to write nested structural recursions with multiple root expressions \nmanually. For example, select e where [path :g] in db binds the graph variable g to every subgraph pointed \nto by a regular path expression path from the root of the graph that db is bound to, Figure 9. insertion \nof reverse edge and will join (++) the graphs generated by the expression e that refers the graph variable \ng. It is worth noting that, in case of extracting subgraphs under regular path pattern, we just shortcut \nthe edges with unmatching labels like in the else clause of extractSection in Example 4. If there is \na cycle of these unmatching labels (labels other than section in the example) above the matching subgraph, \nthen the cycle turns into an .-cycle, meaning that the result of query represents in.nite number of that \nsubgraphs. This in.nity is no surprising since original input graph essentially includes in.nite number \nof that subgraphs when the cycle is unfolded. The in.nity in the result is reported by .-elimination \nerror in AFG . Interestingly, this exhibits the expressive power of AFG to detect cyclic patterns speci.ed \nby the automata mentioned above. For example, extractSection corresponds to automata on the right, which \nincludes \u00acsectiona cycle. If this cycle and the ones in the  input graph matches, then an .-cycle is \nsection .1 - -@ produced. 1 2 Expressive Power on Sibling Dimension With the parameter d +GZ of type \nList(GZ Z\u00d7Y ) = GZ in srec we can express not only queries such as extracting subgraphs as mentioned \nabove, but also those manipulating siblings of nodes, like reversal (Example 2), removing and contracting \neven-numbered siblings (Example 12). Z\u00d7a Z\u00d7a+Z\u00d7Y Expressiveness under Bisimilarity Equivalence Since \nour lan\u00adguage is bisimulation generic, targeting graphs under bisimilarity equivalence, queries that \ndistinguish bisimilar graphs are not ex\u00adpressible. For example, we cannot count the number of nodes, \nsince two bisimilar graphs may have different numbers of nodes. As an\u00adother example, we cannot insert \na reverse edge. For example, in Figure 9, the graph G2 is obtained from G1 by unfolding the cycle formed \nby the edge labeled b at node 2; hence so G1 and G2 are bisimilar. The bisimulation relation S : G1.V \n\u00d7 G2.V is {(1, 1), (2, 2), (2, 2;)}. Now suppose we insert for every a-labeled edge a reversed a;-labeled \nedge like in G;1 and G2;. Notice the dif\u00adference between outgoing edges from node 2 and those from node \n2;. In G;1, there is an outgoing edge a; from node 2. However, in G;2, there is no such edge from node \n2;. So G;1 and G;2 are not bisimilar anymore. The essential reason for this bisimulation gener\u00adicity \nviolation is that the reverse edge on a node is inserted on in\u00adcoming edges while bisimulation is determined \nby outgoing edges. So bisimilar nodes are treated differently. It would be interesting to combine AFG \nwith the predicate of bisimilarity on graphs. Since (for .-eliminable graphs) the bisimi\u00adlarity is decidable, \nwe can readily introduce such predicate in AFG and express queries that identify nodes in terms of their \nbisimilar\u00adity. 6. Related Work Our structural recursion for ordered graphs is very much related to research \non algebras of programming (Meijer et al. 1991; Bird and de Moor 1996; Hu et al. 2006), where structural \nrecursions such as folds and catamorphisms are used to structure programs and systematically manipulate \nprograms. In particular, our approach is in.uenced by the many attempts at de.ning structural recursions \nfor speci.c graphs, such as graphs represented by trees with spe\u00adci.c pointers (Hamana 2009; Dal Zilio \net al. 2004; Oliveira and Cook 2012) and graphs represented by trees with embedded func\u00adtions (Fegaras \nand Sheard 1996). However, they do not ensure all of the bisimulation genericity, terminating property, \nand .niteness preserving property, which are our original goals as explained in the introduction. In \nthe database community, structural recursion is an important primitive in database queries. Rewriting \nrules for optimization can be obtained by exploiting axiom of languages based on structural recursion. \nAlthough it works for various data models such as rela\u00adtions (Breazu-Tannen et al. 1991), nested collections \n(Wong 1994), unordered graphs (Buneman et al. 2000), and ordered trees (Robert\u00adson et al. 2009), structural \nrecursion for querying ordered graphs has not been established yet. As described in the introduction, \nour work was inspired by the structural recursion in UnCAL (Buneman et al. 2000) that is prac\u00adtically \nused for manipulating unordered graphs. We borrow from database community the idea of how to restrict \na structural recur\u00adsion for in.nite regular trees so that a structural recursion for .\u00adnite graphs preserves \n.niteness of graphs and becomes terminating, which are desirable properties for query languages. We solve \nthe open problem of dealing with ordered graphs by providing a novel de.nition of bisimulation relation \nfor ordered graphs. To enhance the expressive power to deal with transformation among children graphs, \nwe extend the original structural recursion from srec(e) to srec(e, d) so that d can be used to combine \nresults among children. A lot of work has been devoted to ef.cient implementation of graph algorithms \nin lazy functional languages (Burton and Yang 1990; King and Launchbury 1995; Erwig 1997; Johnsson 1998). \nThe emphasis there is placed on the importance of achieving ef\u00ad.cient implementation of general graph \nalgorithms through the monadic model for including actions on the state in the non-strict context. In \ncontrast, we focus on inductive traversals of ordered graphs and aim to provide an ef.cient way to deal \nwith a speci.c class of important graph algorithms graph querying. In addition, unlike the above where \ngraph equivalences are up to isomorphism, our graph equivalences are up to bisimilarity and all our transfor\u00admations \nare guaranteed to be bisimulation generic. Algebraic graph transformations (Ehrig et al. 2006) formalize \ngraph transformations using categories in which objects are graphs and graph patterns to be matched, \nand matching be graph mor\u00adphisms. A step of transformations is realized by a pushout com\u00adplement followed \nby a pushout in the double-pushout approach. Category theory is elegantly used in the proofs and various \ncon\u00adstructions like transformation rule compositions. In contrast to our graph model, their graph model \nis based on graph isomorphism, and order between outgoing edges are not considered. Picard and Matthes \n(2012) deal with node-labeled graphs using coinductive data types in Coq proof assistant. Although outgoing \nedges of their graphs are also ordered and graph equivalence based on bisimulation is considered, .-edges \nare not considered. Our decision procedure on .-eliminability under .nite-width in Section 3.3 is close \nto the eliminability of .-transition cycles of weighted automata in Lombardy and Sakarovitch (2012). \nHowever, while eliminability of .-transition cycle in the weighted automata is determined solely by the \nweight of the .-edge (whether the weight is starable), we also consider the presence of proper branches. \nNote also that there is no notion of order between transitions in Lom\u00adbardy and Sakarovitch (2012), so \nour .-elimination cannot be de\u00adrived from that of weighted automata. The treatment for .-edges in the \ncurrent paper was inspired by (Jacobs 2010). Although there was no consideration of .-edge itself in \nthat study, the author showed that the trace semantics for some kinds of coalgebra induces iteration \noperators by forgetting the length of trace paths; the resulting iteration operators can be regarded \nas .-elimination. The countable list monad CList is not treated in that paper (or in any literature to \nthe best of our knowl\u00adedge); it does not satisfy the assumption of the theorem in that pa\u00adper. Since \nour de.nition of bisimilarity agrees with (strong) bisim\u00adilarity de.ned generally by coalgebra theory \nif graphs contain no .-edges, Proposition 10 suggests that our bisimilarity for graphs having .-edges \ncan be equivalently de.ned by the combination of the usual strong bisimulation and .-elimination. In \nthis viewpoint, our essential contribution in Sections 3.1 and 3.2 is that we de.ne and exploit CList \nand de.ne the .-elimination. This paper is also related to our another submission (Asada et al. 2013), \nwhich also treats an extension of UnCAL. In the current pa\u00adper, we provide a novel solution to the problem \nof querying over the ordered graphs, while Asada et al. (2013) shows that the solution can be partially \ngeneralized with less expressiveness of queries. More speci.cally, the two papers are technically independent \nin the following two points. First, though Asada et al. (2013) shows that branch patterns of graphs can \nbe generalized by using monads, the generalization assumes the existence of a monad with an iteration \noperator. For ordered graph case, the de.nition of the monad CList with its iteration operator (i.e., \nthe .-elimination) is the very contri\u00adbution of the current paper, and Asada et al. (2013) just use the \nre\u00adsult to include ordered graph case as an example of the generaliza\u00adtion. The other point is that the \ncurrent paper is not an instantiation of Asada et al. (2013); though the current paper extends the struc\u00adtural \nrecursion with d for sibling transformations, it is not achieved in Asada et al. (2013). Also, the decidability \nof .-eliminability is not generalized in Asada et al. (2013). 7. Conclusions and Future Work We presented \nthe .rst solution to the open problem of how to modify the graph model and structural recursion from \nunordered graphs to ordered ones and de.ned a new graph transformation language AFG for doing so. The \nkey technical contributions are a novel de.nition of a bisimulation relation on ordered graphs having \n.-edges and an extension of structural recursion with an operation for combining sibling results to achieve \nexpressive power on the sibling dimension. We implemented AFG and showed two important optimization rules. \nThere are many interesting future paths of study. First, we should analyse structural recursion more \nthoroughly; for instance, we should examine the circumstances under which structural recursion is productive. \nA structural recursion is said to be pro\u00adductive, if it produces a .nite ordered graph without .-edges \n(i.e., FG/. de.ned in Section 3.3) for any input ordered graph without .-edge. Second, following our \nprevious work on bidirectionalizing UnCAL (Hidaka et al. 2010), we are very interested in developing \na systematic way to bidirectionalize AFG . Acknowledgments We would like to thank Kazutaka Matsuda for \nvarious comments to the current and earlier versions of the paper. We also would like to thank the anonymous \nreviewers of the present and earlier ver\u00adsions for their thorough comments and constructive suggestions \nto improve the paper. The research was supported in part by the Grand-Challenging Project on the Linguistic \nFoundation for Bidi\u00adrectional Model Transformation of the National Institute of Infor\u00admatics, and a Grant-in-Aid \nfor Scienti.c Research for Encourage\u00adment of Young Scientists (B) No. 20700035, and a Grant-in-Aid for \nScienti.c Research (B) No. 22300012. References K. Asada, S. Hidaka, H. Kato, Z. Hu, and K. Nakano. \nParameterized graph transformation languages with monads. Technical Report GRACE\u00adTR-2012-07, GRACE Center, \nNational Institute of Informatics, 2012. http://www.biglab.org/papers.html. K. Asada, S. Hidaka, H. Kato, \nZ. Hu, and K. Nakano. A parameterized graph transformation calculus for .nite graphs with monadic branches, \n2013. To appear in PPDP 13. R. Bird and O. de Moor. Algebras of Programming. Prentice Hall, 1996. V. \nBreazu-Tannen, P. Buneman, and S. Naqvi. Structural recursion as a query language. In Proc. of the Third \nInternational Workshop on Database Programming Languages(DBPL 91), pages 9 19, 1991. P. Buneman, M. F. \nFernandez, and D. Suciu. UnQL: a query language and algebra for semistructured data based on structural \nrecursion. VLDB Journal: Very Large Data Bases, 9(1):76 110, 2000. F. W. Burton and H.-K. Yang. Manipulating \nmultilinked data structures in a pure functional language. Softw. Pract. Exper., 20:1167 1185, November \n1990. S. Dal Zilio, D. Lugiez, and C. Meyssonnier. A logic you can count on. POPL 04, pages 135 146, \nNew York, NY, USA, 2004. ACM. H. Ehrig, K. Ehrig, U. Prange, and G. Taentzer. Fundamentals of Algebraic \nGraph Transformation. Springer-Verlag, 2006. M. Erwig. Functional programming with graphs. ICFP 97, pages \n52 65, New York, NY, USA, 1997. ACM. L. Fegaras and T. Sheard. Revisiting catamorphisms over datatypes \nwith embedded functions. POPL 96, St. Petersburg Beach, Florida, Jan. 1996. J. Gibbons. An initial-algebra \napproach to directed acyclic graphs. In Math\u00adematics of Program Construction, MPC 95, pages 282 303, \nLondon, UK, 1995. Springer-Verlag. A. Gill, J. Launchbury, and S. P. Jones. A short cut to deforestation. \nIn Proc. Conference on Functional Programming Languages and Com\u00adputer Architecture, pages 223 232, Copenhagen, \nJune 1993. S. Ginali. Regular trees and the free iterative theory. J. Comput. Syst. Sci., 18(3):228 242, \n1979. M. Hamana. Initial algebra semantics for cyclic sharing structures. TLCA 09, pages 127 141, Berlin, \nHeidelberg, 2009. Springer-Verlag. M. Hasegawa. The uniformity principle on traced monoidal categories. \nElectr. Notes Theor. Comput. Sci., 69:137 155, 2002. S. Hidaka, Z. Hu, K. Inaba, H. Kato, K. Matsuda, \nand K. Nakano. Bidi\u00adrectionalizing graph transformations. In ACM SIGPLAN International Conference on \nFunctional Programming, pages 205 216. ACM, 2010. S. Hidaka, Z. Hu, K. Inaba, H. Kato, K. Matsuda, K. \nNakano, and I. Sasano. Marker-directed Optimization of UnCAL Graph Transformations. In LOPSTR 11, volume \n7225 of LNCS, pages 123 138. Springer, 2012. Z. Hu, H. Iwasaki, M. Takeichi, and A. Takano. Tupling calculation \nelim\u00adinates multiple data traversals. ICFP 97, pages 164 175, Amsterdam, The Netherlands, June 1997. \nACM Press. Z. Hu, T. Yokoyama, and M. Takeichi. Program optimizations and trans\u00adformations in calculational \nform. In Summer School on Generative and Transformational Techniques in Software Engineering, pages 139 \n164, Braga, Portugal, 2006. Springer, LNCS 4043. B. Jacobs. From coalgebraic to monoidal traces. Electronic \nNotes in Theoretical Computer Science, 264(2):125 140, 2010. Proceedings of the Tenth Workshop on Coalgebraic \nMethods in Computer Science (CMCS 2010). T. Johnsson. Ef.cient graph algorithms using lazy monolithic \narrays. J. Funct. Program., 8:323 333, July 1998. F. Jouault and J. B\u00b4ezivin. KM3: A DSL for metamodel \nspeci.cation. In Formal Methods for Open Object-Based Distributed Systems, pages 171 185. LNCS 4037, \nSpringer, 2006. A. J. Kfoury and J. Tiuryn. Type reconstruction in .nite-rank fragments of the polymorphic \nlambda-calculus (extended summary). In LICS, pages 2 11, 1990. D. J. King and J. Launchbury. Structuring \ndepth-.rst search algorithms in Haskell. POPL 95, pages 344 354, New York, 1995. ACM. S. Lombardy and \nJ. Sakarovitch. The removal of weighted c-transitions. CIAA 12, pages 345 352. Springer-Verlag, 2012. \nE. Meijer, M. Fokkinga, and R. Paterson. Functional programming with bananas, lenses, envelopes and barbed \nwire. In Proc. Conference on Functional Programming Languages and Computer Architecture(LNCS 523), pages \n124 144, Cambridge, Massachuetts, Aug. 1991. J. C. Mitchell. Foundations for programming languages. Foundation \nof computing series. MIT Press, 1996. B. C. Oliveira and W. R. Cook. Functional programming with structured \ngraphs. ICFP 12, pages 77 88, New York, 2012. ACM. C. Picard and R. Matthes. Permutations in Coinductive \nGraph Represen\u00adtation. In D. Pattinson and L. Schr \u00a8 oder, editors, Coalgebraic Methods in Computer Science, \nvolume 7399 of LNCS, pages 218 237. Springer, 2012. E. L. Robertson, L. V. Saxton, D. V. Gucht, and \nS. Vansummeren. Structural recursion as a query language on lists and ordered trees. Theory of Computing \nSystems, 44(4):590 619, 2009. A. Takano and E. Meijer. Shortcut deforestation in calculational form. \nFPCA 95, pages 306 313, New York, 1995. ACM. L. Wong. Querying Nested Collections. PhD thesis, Philadelphia, \nPA, USA, 1994. A. Semantics of Graph Constructors Figure 10 summarizes the semantic de.nitions of all \ngraph con\u00adstructors in AFG. In the de.nitions of ++, f, and @, we assume V1 and V2 to be disjoint, which \nis realized by taking copies of them. The semantics should be easy to understand with the help of Figure \n5and the intuitive explanations given in Section 2.2.1. B. Recursive Semantics with Output Markers In \nSection 4.1, we gave recursive semantics by omitting output marker case. Throughout here, we consider \ngeneral case with out\u00adput markers. Hence, the typing rule is the one in Figure 4. Now we will give both \ncases with and without PCC, whose de.nition will be given at the end. Before that, let us see more simple \ncase, i.e., in addition to PCC, we assume that, for some monoid (8, iG) on GZ Z\u00d7a+Z\u00d7Y , d = foldr(8, \niG) . List([p, q]) ZZ Z : List(GZ\u00d7a+GZ\u00d7Y ) = GZ\u00d7a+Z\u00d7Y def def where p = (-) @ .inln : GZ = GZ and q \n= Z\u00d7a Z\u00d7a+Z\u00d7Y (-) @.inr Z\u00d7Y Z\u00d7a+Z\u00d7Y . Then, a structural recursion n : GZ = GZ def function f = srec(e, \nd) characterized by the following recursive semantics: f([]) = iG f(g1 + g2) = f(g1) 8 f(g2) f([l : g]) \n= e(l, g) @f(g) f([&#38;y]) = .&#38;z .= (&#38;z, &#38;y)n (7) f(&#38;x := g) = (f&#38;z~Z (&#38;z, &#38;x) \n:= [(&#38;z, &#38;)]) @f (g) f(()) = () f(g1 f g2) = f(g1) f f(g2). The fourth equation is the new one \nfor the output marker case. The meaning should be quite easy to understand, and the following more general \nversions are essentially the same as this. [] G1 ++G2 = = ({root}, {root .= []}, {&#38; .= root}) where \nroot is a fresh node let (V1, B1, I1) = G1; (V2, B2, I2) = G2 {&#38;x1, . . . , &#38;xm} = Dom(I1) (= \nDom(I2)) v1, . . . , vm are fresh node identi.ers B; = B1 U B2U {vi .= [Edge(., I1(&#38;xi)), Edge(., \nI2(&#38;xi ))] | i = 1, . . . , m}I;(&#38;xi ) = vi [l : G] = in (V1 U V2 U {v1, . . . , vm}, B;, I;) \nlet (V, B, I) = G root is a fresh node [&#38;y] &#38;x := G G1 f G2 = = = in (V U {root}, B U {root .= \n[Edge(l, I(&#38;))]}, {&#38; .= root}) ({v}, {v .= [Outm(&#38;y)]}, {&#38; .= v}) where v is a fresh \nnode let (V, B, I) = G in (V, B, {&#38;x .= I(&#38;)}) let (V1, B1, I1) = G1; (V2, B2, I2) = G2 in (V1 \nU V2, B1 U B2, I1 U I2) () G1 @G2 = = ({}, {}, {}) let (V1, B1, I1) = G1; (V2, B2, I2) = G2 B;(v1(. V1)) \n= [ .llOutm b | b . B1(v1)] where .llOutm (Edge(l;, v;)) = Edge(l;, v;) .llOutm (Outm(&#38;y)) = Edge(., \nI2(&#38;y)) B;(v2(. V2)) = B2(v2) in (V1 U V2, B;, I1) cycle(G) = let (V, B, I) = G B;(v) = [ cyclize \nb | b . B(v)] where cyclize (Edge(l;, v;)) = Edge(l;, v;) cyclize (Outm(&#38;y)) = if &#38;y /. Dom(I) \nthen Outm(&#38;y) else Edge(., I(&#38;y)) in (V, B;, I) Figure 10. Semantics of Graph Constructors  \nNow let us see another recursive semantics, with relaxing as\u00adsumptions. For e and d satisfying PCC, we \nhave the following re\u00adcursive semantics. () [li : gi] f(++n ) i=1 [&#38;yi ] (` \u00b4)(8) ` inl e(li, gi) \n@f(gi) \u00b4 = dY [` \u00b4i=1 @..Z\u00d7Y n ]n inr . &#38;z .= (&#38;z, &#38;yi )n where [xi]n i=1 is comprehension \nrepresentation of alist [x1, ..., xn]. The above equation is read as follows: for each i on the left \nhand side, the content of {-} is upper or lower; then on the right hand side, for each i, according to \nthe case on the left hand side, we think the upper or lower. Compare the above with the following recursive \nsemantics given in Section 4.1, where we omit the case of output markers: f([l1 : g1]++... + [ln : gn]) \n` \u00b4 = d. [e(l1, g1) @f(g1), ..., e(ln, gn) @f(gn)] . In Section 4.1, as well as assuming Y to be ., we \nsimpli.ed the typing of d ZZ Z from d : List(GZ\u00d7a+GZ\u00d7Y ) = GZ\u00d7a+Z\u00d7Y to d : List(GZ ) = GZ Z\u00d7a Z\u00d7a hence \nwe did not need to use inl and . in Equation (8). For general d without assuming PCC, we have the following \nrecursive semantics. () [li : gi] f(+ n ) i=1 [&#38;yi ] (` \u00b4) ` inl e(li, gi) @.&#38;z .= (&#38;z , \n&#38;i)n \u00b4 ]n inr . &#38;z .= (&#38;z, &#38;yi )n = dn [` \u00b4 i=1 (9) ()`L\u00b4 n f(gi) @ ( i=1.isoin@) f .idZ\u00d7Y \nn [] where isoi : Z\u00d7{i} . = Z. Production-Consumption Compatibility The PCC con\u00addition is de.ned as \nfollows: e: Label\u00d7GY = Z and GZ d: List(GZ +GZ are called production- Z\u00d7Y ) = GZ Z\u00d7a Z\u00d7a+Z\u00d7Y consumption \ncompatible (PCC) if they satisfy the following: For any n, suppose that, for each i . n, li . L, Gi . \nGY , and G;. GZ are given, or &#38;y . Y is given. Then the following i Z\u00d7Y equation holds (` \u00b4) inl \ne(li, Gi) @G;idY ([` \u00b4i=1) @..Z\u00d7Y n ]n inr .&#38;z .= (&#38;z, &#38;y)n (` ) ` inl e(li, Gi) @.&#38;z \n.= (&#38;z, i)n) \u00b4 ]n inr .&#38;z .= (&#38;z , &#38;y)n =dn [` \u00b4 i=1 ` L n .Gt \u00af \u00b4 @ ( i=1.isoin@ i ) \nf .idZ\u00d7Y n [] where .Z\u00d7Y : Z\u00d7Y +Z\u00d7Y = Z\u00d7Y and isoi : Z\u00d7{i} . = Z.    \n\t\t\t", "proc_id": "2500365", "abstract": "<p>Structural recursion, in the form of, for example, folds on lists and catamorphisms on algebraic data structures including trees, plays an important role in functional programming, by providing a systematic way for constructing and manipulating functional programs. It is, however, a challenge to define structural recursions for graph data structures, the most ubiquitous sort of data in computing. This is because unlike lists and trees, graphs are essentially not inductive and cannot be formalized as an initial algebra in general. In this paper, we borrow from the database community the idea of structural recursion on how to restrict recursions on infinite unordered regular trees so that they preserve the finiteness property and become terminating, which are desirable properties for query languages. We propose a new graph transformation language called lambdaFG for transforming and querying ordered graphs, based on the well-defined bisimulation relation on ordered graphs with special epsilon-edges. The language lambdaFG is a higher order graph transformation language that extends the simply typed lambda calculus with graph constructors and more powerful structural recursions, which is extended for transformations on the sibling dimension. It not only gives a general framework for manipulating graphs and reasoning about them, but also provides a solution to the open problem of how to define a structural recursion on ordered graphs, with the help of the bisimilarity for ordered graphs with epsilon-edges.</p>", "authors": [{"name": "Soichiro Hidaka", "author_profile_id": "81329489357", "affiliation": "National Institute of Informatics, Tokyo, Japan", "person_id": "P4261263", "email_address": "hidaka@nii.ac.jp", "orcid_id": ""}, {"name": "Kazuyuki Asada", "author_profile_id": "83058631357", "affiliation": "National Institute of Informatics, Tokyo, Japan", "person_id": "P4261264", "email_address": "asada@nii.ac.jp", "orcid_id": ""}, {"name": "Zhenjiang Hu", "author_profile_id": "81100253989", "affiliation": "National Institute of Informatics, Toyko, Japan", "person_id": "P4261265", "email_address": "hu@nii.ac.jp", "orcid_id": ""}, {"name": "Hiroyuki Kato", "author_profile_id": "81418592890", "affiliation": "National Institute of Informatics, Tokyo, Japan", "person_id": "P4261266", "email_address": "kato@nii.ac.jp", "orcid_id": ""}, {"name": "Keisuke Nakano", "author_profile_id": "81100633478", "affiliation": "University of Electro-Communications, Chofu-shi, Japan", "person_id": "P4261267", "email_address": "ksk@cs.uec.ac.jp", "orcid_id": ""}], "doi_number": "10.1145/2500365.2500608", "year": "2013", "article_id": "2500608", "conference": "ICFP", "title": "Structural recursion for querying ordered graphs", "url": "http://dl.acm.org/citation.cfm?id=2500608"}