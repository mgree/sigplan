{"article_publication_date": "09-25-2013", "fulltext": "\n System FC with Explicit Kind Equality Stephanie Weirich Justin Hsu Richard A. Eisenberg Department of \nComputer and Information Science, University of Pennsylvania Philadelphia, PA, USA {sweirich,justhsu,eir}@cis.upenn.edu \nAbstract System FC, the core language of the Glasgow Haskell Compiler, is an explicitly-typed variant \nof System F with .rst-class type equality proofs called coercions. This extensible proof system forms \nthe foundation for type system extensions such as type families (type\u00adlevel functions) and Generalized \nAlgebraic Datatypes (GADTs). Such features, in conjunction with kind polymorphism and datatype promotion, \nsupport expressive compile-time reasoning. However, the core language lacks explicit kind equality proofs. \nAs a result, type-level computation does not have access to kind\u00adlevel functions or promoted GADTs, the \ntype-level analogues to expression-level features that have been so useful. In this paper, we eliminate \nsuch discrepancies by introducing kind equalities to System FC. Our approach is based on dependent type \nsystems with heterogeneous equality and the Type-in-Type axiom, yet it preserves the metatheoretic properties \nof FC. In particular, type checking is simple, decidable and syntax directed. We prove the preservation \nand progress theorems for the extended language. Categories and Subject Descriptors F.3.3 [Studies of \nProgram Constructs]: Type structure General Terms Design, Languages Keywords Haskell, Dependent types, \nEquality 1. Introduction Is Haskell a dependently typed programming language? Many would say no, as Haskell \nfundamentally does not allow expressions to appear in types (a de.ning characteristic of dependently-typed \nlanguages). However, the type system of the Glasgow Haskell Compiler (GHC), Haskell s primary implementation, \nsupports two essential features of dependently typed languages: .ow-sensitive typing through Generalized \nAlgebraic Datatypes (GADTs) (Pey\u00adton Jones et al. 2006; Schrijvers et al. 2009), and rich type\u00adlevel \ncomputation through type classes (Jones 2000), type fami\u00adlies (Chakravarty et al. 2005), datatype promotion \nand kind poly\u00admorphism (Yorgey et al. 2012). These two features allow clever Haskellers to encode programs \nthat are typically reputed to need dependent types. Permission to make digital or hard copies of all \nor part of this work for personal or classroom use is granted without fee provided that copies are not \nmade or distributed for pro.t or commercial advantage and that copies bear this notice and the full citation \non the .rst page. Copyrights for components of this work owned by others than the author(s) must be honored. \nAbstracting with credit is permitted. To copy otherwise, or republish, to post on servers or to redistribute \nto lists, requires prior speci.c permission and/or a fee. Request permissions from permissions@acm.org. \nICFP 13, September 25 27, 2013, Boston, MA, USA. Copyright is held by the owner/author(s). Publication \nrights licensed to ACM. ACM 978-1-4503-2326-0/13/09. . . $15.00. http://dx.doi.org/10.1145/2500365.2500599 \n However, these encodings cannot accommodate all dependently\u00adtyped programs. GADTs and type families \nare supported in FC, GHC s typed intermediate language, through the use of .rst-class type equalities \n(Sulzmann et al. 2007). However, FC lacks .rst\u00adclass kind equalities limiting its expressiveness. As \na result, GADTs cannot be promoted, because the type equalities in their de.nition cannot be lifted to \nkind equalities. Furthermore, GADTs cannot be indexed by kinds, which would require reasoning about kind \nequality. Finally, although type families permit types to be de.ned computationally, the lack of kind \nequalities means there are no kind families in GHC. Although these features seem esoteric, they are often \nnecessary for encoding dependently-typed programs in GHC (Eisenberg and Weirich 2012). We give concrete \nexamples that require these features in Section 2. Our goal in this paper is to eliminate such nonuniformities \nwith a single blow, by unifying types and kinds. In essence, we augment FC s type language with dependent \nkinds kinds that can depend on types. This process is not without challenges this dependency has complex \ninteractions with type equality. However, our ultimate goal is to better support dependently typed programming \nin GHC, and resolving these issues is an critical step. Speci.cally, we make the following technical \ncontributions: We describe an explicitly-typed intermediate language with explicit equality proofs for \nboth types and kinds (Sections 3 and 4). The language is no toy: it is an extension of the System FC \nintermediate language used by GHC (Sulzmann et al. 2007; Weirich et al. 2011; Yorgey et al. 2012; Vytiniotis \net al. 2012).  We extend the type preservation proof of FC to cover the new features (Section 5). The \ntreatment of datatypes requires an im\u00adportant property: congruence for the equational theory. In other \nwords, we can derive a proof of equality for any form of type or kind, given equality proofs of subcomponents. \nThe compu\u00adtational content of this theorem, called lifting, generalizes the standard substitution operation. \nThis operation is required in the operational semantics for datatypes.  We prove the progress theorem \nin the presence of kind coer\u00adcions and dependent coercion abstraction. The progress theo\u00adrem holds under \nconsistent sets of equality axioms. Our mod\u00adi.cations require new conditions on axioms to ensure consis\u00adtency, \nand proving consistency requires signi.cant changes to the proof from prior work. We discuss these changes \nand their consequences in Section 6.  We have implemented our extensions to FC in a development branch1 \nof GHC to demonstrate that our modi.cations are compat\u00adible with the existing system, and do not invalidate \nexisting Haskell 1 Available online, from http://www.cis.upenn.edu/~eir/packages/nokinds/.  programs. \nThis implementation involves extensions to the core lan\u00adguage syntax, type checker and stepper (used \nin optimizations). Although our designs are inspired by the rich theory of depen\u00addent type systems, applying \nthese ideas in the context of Haskell means that our language differs in many ways from existing work. \nWe detail these comparisons in Section 7. The scope of this paper only includes the design and implemen\u00adtation \nof kind equalities in the FC intermediate language; we have not yet modi.ed GHC s source language, so \npromoted GADTs, kind-indexed GADTs and kind families are not (yet) available to programmers. Although \nthe required syntactic extensions are mi\u00adnor, extending GHC s constraint solver requires careful integra\u00adtion \nwith existing features. Furthermore, the encodings that work around Haskell s restriction that terms \ncannot appear in types often impose heavy syntactic overheads improved source-level support for dependently-typed \nprogramming should also address this issue. We describe this important future work in Section 8. For \nreasons of space, several technical details and the proofs are deferred to the extended version of the \npaper, available at http: //www.cis.upenn.edu/~sweirich/nokinds-extended.pdf. 2. Why kind equalities? \nKind equalities enable new, useful features. In this section we use an extended example to demonstrate \nhow kind-indexed GADTs, promoted GADTs, and kind families might be used in practice. Be\u00adlow, code snippets \nthat require kind equalities in their compilation to FC are highlighted in gray all other code snippets \ncompile.2 The running example below de.nes shallowly and deeply indexed representations of types, and \nshows how they may be used for Generic Programming. The former use Haskell s types as indices (Crary \net al. 1998; Yang 1998), whereas the latter use an algebraic datatype (also known as a universe) (Altenkirch \nand McBride 2002; Norell 2002). (Magalh aes (2012) gives more details describing how extensions to Haskell, \nincluding the ones described in this paper, bene.t generic programming.) Shallow indexing Consider a \nGADT for type representations: data TyRep :: * . * where TyInt :: TyRep Int TyBool :: TyRep Bool GADTs \ndiffer from ordinary algebraic datatypes in that they allow each data constructor to constrain the type \nparameters to the datatype. For example, the TyInt constructor requires that the single parameter to \nTyRep be Int. We can use type representations for type-indexed programming a simple example is computing \na default element for each type. zero :: . a. TyRep a . a zero TyInt = 0 -- a must be Int zero TyBool \n= False -- a must be Bool This code pattern matches the type representation to determine what value to \nreturn. Because of the nonuniform type index, pattern matching recovers the identity of the type variable \na. In the .rst case, because the data constructor is TyInt, this parameter must be Int, so 0 can be returned. \nIn the second case the parameter a must be equal to Bool, so returning False is well-typed. However, \nthe GADT above can only be used to represent types of kind *. To represent type constructors with kind \n* . *, such as Maybe or [], we could create a separate datatype, perhaps called TyRep1. However, this \napproach is ugly and in.exible what about tuples? Do we need a TyRep2, TyRep3, and more? 2 with GHC 7.6 \nand the language extensions PolyKinds, DataKinds, GADTs, ExplicitForAll and TypeFamilies. We might hope \nthat kind polymorphism (Yorgey et al. 2012), which allows datatypes to be parameterized by kind variables \nas well as type variables, could be the solution. For example, the following kind polymorphic type takes \ntwo phantom arguments, a kind variable . and a type variable a of kind .. data Proxy (a :: k) = P However, \nkind polymorphism is not enough to unify the represen\u00adtations for TyRep the type representation (shown \nbelow) should constrain its kind parameter. data TyRep :: . k. k . * where TyInt :: TyRep Int TyBool \n:: TyRep Bool TyMaybe :: TyRep Maybe TyApp :: TyRep a . TyRep b . TyRep (a b) This TyRep type takes \ntwo parameters, a kind k and a type of that kind (not named in the kind annotation). The data constructors \nconstrain k to a concrete kind. For the example to be well-formed, TyInt must constrain the kind parameter \nto *. Similarly, TyMaybe requires the kind parameter to be * . *. We call this example a kind-indexed \nGADT because the datatype is indexed by both kind and type information. Pattern matching with this datatype \nre.nes kinds as well as types determining whether a type is of the form TyApp makes new kind and type \nequalities available. For example, consider the zero function extended with a default value of the Maybe \ntype. zero :: . (a :: *). TyRep a . a zero TyInt = 0 zero TyBool = False zero (TyApp TyMaybe _) = Nothing \nIn the last case, the TyApp pattern introduces the kind variable k, the type variables b :: k . * and \nc :: k, and the type equality a ~ b c. The TyMaybe pattern adds the kind equality k ~ * and type equality \nb ~ Maybe. Combining the equalities, we can show that Maybe c, the type of Nothing, is well-kinded and \nequal to a. 3 Deep indexing Kind equalities enable additional features besides kind-indexed GADTs. The \nprevious example used Haskell types directly to index type representations. With datatype promotion, \nwe can instead de.ne a datatype (a universe) for type information. data Ty = TInt | TBool We can use \nthis datatype to index the representation type. data TyRep :: Ty . * where TyInt :: TyRep TInt TyBool \n:: TyRep TBool Note that the kind of the parameter to this datatype is Ty instead of * datatype promotion \nallows the type Ty to be used as a kind and allows its constructors, TyInt and TyBool, to appear in types. \nTo use these type representations, we describe their connection with Haskell types via a type family \n(a function at the type level). type family I (t :: Ty) :: * type instance I TInt = Int type instance \nI TBool = Bool I is a function that maps the (promoted) data constructor TInt to the Haskell type Int, \nand similarly TBool to Bool.  We can use these type representations to de.ne type-indexed operations, \nlike before. zero :: . (a :: Ty). TyRep a . I a zero TyInt = 0 zero TyBool = False Pattern matching TyInt \nre.nes a to TInt, which then uses the type family de.nition to show that the result type is equal to \nInt. Dependently typed languages do not require an argument like TyRep to implement operations such as \nzero they can match directly on the type of kind Ty. This is not allowed in Haskell, which maintains \na separation between types and expressions. The TyRep argument is an example of a singleton type, a standard \nway of encoding dependently typed operations in Haskell. Note that this representation is no better than \nthe shallow ver\u00adsion in one respect I must produce a type of kind *. What if we wanted to encode TMaybe \nwith Ty? To get around this issue, we use a GADT to represent different kinds of types. We .rst need \na universe of kinds. data Kind = Star | Arr Kind Kind Kind is a normal datatype that, when promoted, \ncan be used to index the Ty datatype, making it a (standard) GADT. data Ty :: Kind . * where TInt :: \nTy Star TBool :: Ty Star TMaybe :: Ty (Arr Star Star) TApp :: Ty (Arr k1 k2) . Ty k1 . Ty k2 This indexing \nmeans that Ty can only represent well-kinded types. For example TMaybe has type Ty (Arr Star Star) and \nTApp TMaybe TBool has type Ty Star, while the value TApp TInt would be rejected. Although this GADT can \nbe expressed in GHC, the corresponding TyRep type requires two new extensions: promoted GADTs and kind \nfamilies. With the current design of FC, only a subset of Haskell 98 datatypes can be promoted. In particular, \nGADTs cannot be used to index other GADTs. The extensions proposed in this work allow the GADT Ty above \nto be used as an index to TyRep or to be interpreted by the type family I, as shown below. data TyRep \n(k :: Kind) (t :: Ty k) where TyInt :: TyRep Star TInt TyBool :: TyRep Star TBool TyMaybe :: TyRep (Arr \nStar Star) TMaybe TyApp :: TyRep (Arr k1 k2) a . TyRep k1 b . TyRep k2 (TApp a b) We now need to adapt \nthe type family I to work with the new promoted GADT Ty. To do so, we must classify its return kind, \nand for that, we need a kind family a function that produces a kind by pattern matching a type or kind \nargument. For example, we can interpret values of the Kind datatype as Haskell kinds like so: kind family \nIK (k :: Kind) kind instance IK Star = * kind instance IK (Arr k1 k2) = IK k1 . IK k2 This interpretation \nof kinds is necessary to de.ne the interpre\u00adtation of types without it, this de.nition does not kind-check \n: type family I (t :: Ty k) :: IK k type instance I TInt = Int type instance I TBool = Bool type instance \nI TMaybe = Maybe type instance I (TApp a b) = (I a) (I b) However, once I has been de.ned, Ty and TyRep \ncan be used in type-indexed operations as before. zero :: . (a :: Ty Star). TyRep Star a . I a zero TyInt \n= 0 zero TyBool = False zero (TyApp TyMaybe _) = Nothing The examples above demonstrate all three features \nthat kind equalities enable: kind-indexed GADTs, kind families, and pro\u00admoted GADTs. While these examples \nare all derived from generic programming, we have also been able to use these features to ex\u00adpress dependently \ntyped programs from McBride (2012) and Oury and Swierstra (2008). We omit these examples for lack of \nspace. We note that the Haskell syntax used in the gray boxes above is hypothetical, as we have not extended \nthe surface language. However, an important .rst step is to enhance the core language, System FC, so \nthat it is expressive enough to support these features. We now turn to this task. 3. System FC System \nFC is the typed intermediate language of GHC. GHC s ad\u00advanced features, such as GADTs and type families, \nare compiled into FC as type equalities. This section reviews the current status of System FC, describes \nthat compilation, and puts our work in context. FC has evolved over time, from its initial de.nition \n(Sulz\u00admann et al. 2007), to extensions F C2 (Weirich et al. 2011), and FC . (Yorgey et al. 2012). In \nthis paper, we use the name FC for the language and all of its variants. Our technical discussion contrasts \nour new extensions with the most recent prior version, FC . . Along with the usual kinds (.), types (t \n) and expressions (e), FC contains coercions (.) that are proofs of type equality. The judgement G fco \n. : t1 ~ t2 checks that the coercion . proves types t1 and t2 equal. These proofs are used to change \nthe types of expressions. For example, if . is a proof of t1 ~ t2, and the expression e has type t1, \nthen the expression e C . (pronounced e casted by . ) has type t2. Making type conversion explicit ensures \nthat the FC typing re\u00adlation G ftm e : t is syntax-directed and decidable. This is not the case in the \nsource language; there type checking re\u00adquires nonlocal reasoning, such as uni.cation and type class \nres\u00adolution. Furthermore, in the presence of certain .ags (such as UndecidableInstances), it may not \nterminate. Straightforward type checking is an important sanity check on the internals of GHC transformations \nand optimizations must preserve typability. Therefore, all information necessary for type checking is \npresent in FC expressions. This information includes explicit type abstractions and applications (System \nFC is an exten\u00adsion of System F. (Girard 1972)) as well as explicit proofs of type equality. For example, \ntype family de.nitions are compiled to axioms about type equality that can be used in FC coercion proofs. \nA type family declaration and instance in source Haskell type family F a :: * type instance F Bool = \nInt generates the following FC axiom declaration: axF : F Bool ~ Int When given a source language function \nof type g :: . a. a . F a . Char  the expression g True 3 translates to the FC expression g Bool True \n(3 C sym axF) that instantiates g at type Bool and coerces 3 to have type F Bool. The coercion sym axF \nis a proof that Int ~ F Bool. GADTs are compiled into FC so that pattern matching on their data constructors \nintroduces type equality assumptions into the context. For example, consider the following simple GADT. \ndata T :: * . * where TInt :: T Int This declaration could have also been written as a normal datatype \nwhere the type parameter is constrained to be equal to Int. data T a = (a ~ Int) . TInt In fact, all \nGADTs can be rewritten in this form using equality constraints. Pattern matching makes this constraint \navailable to the type checker. For example, the type checker concludes below that 3 has type a because \nthe type Int is known to be equal to a. f :: T a . a f TInt = 3 In the translation to FC, the TInt data \nconstructor takes this equality constraint as an explicit argument. TInt : . a: * . (a ~ Int) . T a When \npattern matching on values of type T a , this proof is avail\u00adable for use in a cast. f = .a: * ..x: T \na . case x of TInt (c: a ~ Int) . (3 C sym c) Coercion assumptions and axioms can be composed to form \nlarger proofs. FC includes a number of forms in the coercion lan\u00adguage that witness the re.exivity, symmetry \nand transitivity of type equality. Furthermore, equality is a congruent relation over types. For example, \nif we have proofs of t1 ~ t2 and t1'~ t2', then we can form a proof of the equality t1 t1'~ t2 t2'. Finally, \ncomposite coercion proofs can be decomposed. For example, data construc\u00adtors T are injective, so given \na proof of T t1 ~ T t2, a proof of t1 ~ t2 can be produced. Explicit coercion proofs are like explicit \ntype arguments: they are erasable from expressions and do not effect the operational behavior of an expression. \n(We make this precise in Section 5.3.) To ensure that coercions do not suspend computation, FC includes \npush rules . For example, when a coerced value is applied to an argument, the coercion must be pushed \nto the argument and result of the application so that \u00df-reduction can occur. G fco . : s1 . s2 ~ t1 . \nt2 S PU SH (v C . ) e -. (v (e C sym (nth1 .))) C nth2 . In this rule, if the expression (v C .) e is \nwell typed, then . must be a proof of the equality s1 . s2 ~ t1 . t2. The coercions sym (nth1 .) and \nnth2 . decompose this proof into coercions for the argument (t1 ~ s1) and result (s2 ~ t2) of the application. \n4. System FC with kind equalities The main idea of this paper is to augment FC with proofs of equality \nbetween kinds and to use these proofs to explicitly coerce the kinds of types. We do so via new type \nform: if type t has kind .1, and . is a proof that kind .1 equals kind .2, then t C . is type t casted \nto kind .2. There are several challenges to this extension, which we address with the following technical \nsolutions. H ::= Type constants | (.) Arrow | * Type/Kind | T Type constructor | K Promoted data constructor \nw ::= Type-level names | a Type variables | F Type functions | H Type constants s, t, . ::= Types and \nKinds | w Names | . a: .. t Polymorphic types | . c: f. t Coercion abstr. type | t1 t2 Type/kind application \n| t C. Casting | t . Coercion application f ::= s ~ t Propositions (coercion kinds) . , . ::= Coercions \n| c Variables | C . Axiom application | (t) Re.exivity | sym . Symmetry | .1 9 .2 Transitivity | ..(a1, \na2, c).. Type/kind abstr. cong. | .(.1,.2)(c1, c2).. Coercion abstr. cong. | .1 .2 Type/kind app. cong. \n| .(.2, .2') Coercion app. cong. | . C .' Coherence | .@.' Type/kind instantiation | .@(.1, .2) Coercion \ninstantiation | nthi . nth argument projection | kind . Kind equality extraction . ::= t | . Type or \ncoercion e, u ::= Expressions | x Variables | .x: t. e Abstraction | e1 e2 Application | .a: .. e Type/kind \nabstraction | e t Type/kind application | .c: f. e Coercion abstraction | e . Coercion application | \ne C . Casting | K Data constructors | case e of p . u Case analysis | contra . t Absurdity p ::= K . \nx:t Patterns . ::= Telescopes | \u00d8 Empty | ., a: . Type variable binding | ., c: f Coercion variable binding \n Unifying kinds and types. A language with kind polymorphism, kind equalities, kind coercions, type \npolymorphism, type equal\u00adities and type coercions quickly becomes redundant (and some\u00adwhat overwhelming). \nTherefore, we follow pure type systems (Barendregt 1992) and unify the syntax of types and kinds, allowing \nus to reuse type coercions as kind coercions.4 Although there is no syntactic distinction between types \nand kinds, we informally use the word type (metavariables t and s) for those members that classify runtime \nexpressions, and kind (metavariable .) for those members that classify expressions of the type language. \nAs in pure type systems, types and kinds share semantics there is a common judgement for the validity \nof both. Further\u00admore, our rules include the *:* axiom which means that there is no real distinction \nbetween types and kinds. This choice sim\u00adpli.es many aspects of the language design. Languages such as \nCoq and Agda avoid the *:* axiom because it introduces inconsistency, but that is not an issue here. \nThe FC type language is already inconsistent in the sense that all kinds are inhabited. The type safety \nproperty of FC depends on the consistency of its coercion language, not its type language. See Section \n6 and Section 7 for more discussion of this issue.5 Making type equality heterogeneous . As kinds classify \ntypes, kind equality has nontrivial interactions with type equality. Because kind coercions are explicit, \nthere are equivalent types that do not have syntactically identical kinds. Therefore, like McBride s \nJohn Major equality (2002), our de.nition of type equality t1 ~ t2 is heterogeneous the types t1 and \nt2 could have kinds .1 and .2 that have no syntactic relation to each other. A proof . of t1 ~ t2 implies \nnot only that t1 and t2 are equal, but also that their kinds are equal. The new coercion form kind . \nextracts the proof of .1 ~ .2 from .. Another dif.culty comes from the need to equate polymorphic types \nthat have coercible but not syntactically equal kinds for the bound variable. We discuss the modi.cation \nto this coercion form in Section 4.3.1. Coercion irrelevance. Coercions should be irrelevant to both \nthe operational semantics and type equivalence. The fact that a coercion is used to change the type of \nan expression, or the kind of a type, should not in.uence the evaluation of the expression or the equalities \navailable for the type. For the former, we maintain irrelevance by updating FC s push rules to the new \nsemantics (see Section 5 for details). For the latter, we carefully construct our coercion forms to ignore \ncoercions inside types (Section 4.3.2).  Dependent coercion abstraction. As in prior versions of FC, \ncoercions are .rst class they can be passed as arguments to functions and stored in data structures (as \nthe arguments to data constructors of GADTs). However, this system differs from earlier versions in that \nthe type form for these objects, written . c: f. t , names the abstracted proof with the variable c and \nallows the type t to refer to this coercion.  This extension is necessary for some kind-indexed GADTs. \nFor example, consider the following datatype, which is polymor\u00adphic over a kind and type parameter. 4 \nGHC already uses a shared datatype for types and kinds, so this merge brings the formalism closer to \nthe actual implementation. 5 If a consistent type language were desired for FC for other reasons, we \nbe\u00ad lieve that the ideas presented in this paper are adaptable to the strati.cation of * into universe \nlevels (Luo 1994), as is done in Coq and Agda. data T :: . k. k . * where K :: . (b :: *). b . T b The \nsingle data constructor K constrains the kind to be * but does not otherwise constrain the type. After \ntranslation, the data constructor should be given the fol\u00adlowing FC type, where the abstracted kind coercion \nc is used to cast the kind of the parameter k. K: . k: *, b: k. . c: (k ~ *). (b C c) . T k b 4.1 Type \nsystem overview The next few subsections go into more detail about these technical points. We start with \na quick tour of the type system. The new syntax for FC appears in Figure 1; forms that are new or modi.ed \nin this paper are highlighted these modi.cations are primarily in the type and coercion languages. Also, \nnote that * is a new type constant and . is a metavariable for types. The only difference in the grammar \nfor expressions is that type abstractions and kind abstractions have been merged. In general, the type \nsystem and operational semantics for the expression language is the same here as in prior versions of \nFC. A context G is a list of assumptions for term variables (x), type variables/datatypes/data constructors \n(w), coercion variables (c), and coercion axioms (C). G ::= \u00d8| G, x: t | G, w: . | G, c: f | G, C: . \n.. f The type system includes the following judgements: fwf G Context validity (Figure 5) G fty t : . \nType/kind validity (Figure 2) G fpr f ok Proposition validity (Figure 3) G ftm e : t Expression typing \n(extended version) G fco . : f Coercion validity (Figure 4) G ftel . . . Telescope arg. validity (extended \nversion) Each of the judgements is syntax directed: given the information before the colon (if present), \na simple algorithm determines if the judgement holds, and recovers the information after the colon. \n 4.2 Type and kind formation We next describe our extensions and modi.cations to the rules classifying \nFC types into kinds, which appear in Figure 2. Some of these rules are unchanged or only slightly modi.ed \nfrom prior versions of FC. For example, rule K VAR looks up the kind of a type-level name from the typing \ncontext. Unlike previous systems, this rule now covers the kinding of promoted constructors, since w \nranges over them. Recall that datatype promotion allows data constructors, such as TInt, to appear in \ntypes and be the arguments of type functions. Previously, the types of data constructors had to be explicitly \npromoted to kinds (Yorgey et al. 2012). Now, any data constructor may freely be used as a type. When \nthe constructor is used as a type, its kind is the same as the type of the constructor when used as a \nterm. Rule K AR ROW gives the expected kind for the arrow type con\u00adstructor. We use the usual syntactic \nsugar for arrow types, writing t1 . t2 for (.) t1 t2. Note that the kind of the arrow type con\u00adstructor \nis itself an arrow type. However, that circularity does not cause dif.culty. After that, the rule K AL \nLT describes when poly\u00admorphic types are well formed. The next two rules describe when type application \nis well\u00adformed. Application is overloaded in these rules, but the system is still syntax-directed the \ntype of the .rst component determines which rule applies. We do not combine function types s1 . s2  \nG fty t : . fwf G w: . . G K VAR G fty w : . fwf G K ARROW G fty (.) : * . * . * G, a: . fty t : * G \nfty . : * K AL LT G fty . a: .. t : * G fty t1 : .1 . .2 G fty t2 : .1 K APP G fty t1 t2 : .2 G fty \nt1 : . a: .1. .2 G fty t2 : .1 K IN S T G fty t1 t2 : .2[t2/a] fwf G K STA R INSTAR G fty * : * G fty \nt1 : . c: f. . G fco .1 : f K CAP P G fty t1 .1 : .[.1/c] G, c: f fty t : * G fpr f ok K AL L C G fty \n. c: f. t : * G fty t : .1 G fco . : .1 ~ .2 G fty .2 : * K CAST G fty t C. : .2 Figure 2. Kind and type \nformation rules G fpr f ok G fty s1 : .1 G fty s2 : .2 PRO P EQUA L IT Y G fpr s1 ~ s2 ok Figure 3. Proposition \nformation rule and polymorphic types . a: .. s into a single form because of type erasure: term arguments \nare necessary at runtime, whereas type ar\u00adguments may be erased. Although this distinction is meaningless \nat the kind level, it is benign. Identifying these forms at the kind level while retaining the distinction \nat the term level would needlessly complicate the language. The rules K STA RINSTA R, K CA S T and K \nCAP P and K AL L C check the new type forms. The .rst says that * has kind *. To preserve the syntax-directed \nnature of FC, we must make the use of kind equality proofs explicit. We do so via the new form t C . \nof kind casts: when given a type t of kind .1 and a proof . that kind .1 equals kind .2, the cast produces \na type of kind .2. Because equality is heterogeneous, the K CA S T rule requires a third premise to ensure \nthat the new kind has the correct classi.cation, so that inhabited types have kind *. To promote GADTs \nwe must be able to promote data construc\u00adtors that take coercions as arguments, requiring the new application \nform t .. For example, the data constructor TInt (from Section 3) requires a type argument t and a proof \nthat t ~ Int. Note that there is no type-level abstraction over coercion the form t . can only appear \nwhen the head of t is a promoted datatype constructor.  4.3 Coercions Coercions are proof terms witnessing \nthe equality between types (and kinds), and are classi.ed by propositions f. The rules under which the \nproofs can be derived appear in Figure 4, with the validity G fco . : f G fty t : . CT RE FL G fco (t \n) : t ~ t G fco . : t1 ~ t2 CT SY M G fco sym . : t2 ~ t1 G fco .1 : t1 ~ t2 G fco .2 : t2 ~ t3 CT TR \nA NS G fco .1 9 .2 : t1 ~ t3 G fco .1 : t1 ' ~ t2 ' G fco .2 : t1 ~ t2 ' ' G fty t1 t1 : .1 G fty t2 \nt2 : .2 CT AP P G fco .1 .2 : t1 ' t1 ~ t2 ' t2 G fco .1 : t1 ~ t1 ' ' . ' G fty t1 .2 : . G fty t1 .2 \n' : CT CAP P ' ' . ' G fco .1(.2, . ) : t1 .2 ~ t 2 12 G fco . : .1 ~ .2 G, a1: .1, a2: .2, c: a1 ~ a2 \nfco . : t1 ~ t2 G fty . a1: .1. t1 : * G fty . a2: .2. t2 : *  CT AL LT G fco ..(a1, a2, c).. : (. a1: \n.1. t1) ~ (. a2: .2. t2) G fco .1 : s1 ~ s1 ' f1 = s1 ~ s2 G fco .2 : s2 ~ s2 ' f2 = s1 ' ~ s2 ' c1 # \n|.| c2 # |.| G, c1: f1, c2: f2 fco . : t1 ~ t2 G fty . c1: f1. t1 : * G fty . c2: f2. t2 : *  CT AL \nL C G fco .(.1,.2)(c1, c2).. : (. c1: f1. t1) ~ (. c2: f2. t2) G f. : t1 ~ t2 G fty t1 C . ' : . co CT \nCOH G fco . C .' : t1 C .' ~ t2 c: f . G fwf G CT VAR G fco c : f C: . .. (t1 ~ t2) . G G ftel . . . \nCT AXI O M G fco C . : t1[./.] ~ t2[./.] G fco . : H . ~ H . ' . ' ' .i = t i = t CT NTH ' G fco nthi \n. : t ~ t G fco .1 : (. a1: .1. t1) ~ (. a2: .2. t2) CT NT H 1TA G fco nth1 .1 : .1 ~ .2 G fco .1 : \n(. a1: .1. t1) ~ (. a2: .2. t2) G fco .2 : s1 ~ s2 G fty s1 : .1 G fty s2 : .2 CT IN S T G fco .1@.2 \n: t1[s1/a1] ~ t2[s2/a2] G fco . : (. c: .1 ~ .2. t ) ~ (. c ' : . ' 1 ~ .2 ' . t ' )  CT NTH 1CA G fco \nnth1 . : .1 ~ .1 ' G fco . : (. c: .1 ~ .2. t ) ~ (. c ' : .1 ' ~ . ' 2. t ' )  CT NTH 2CA G fco nth2 \n. : .2 ~ . ' 2 G fco . : (. c1: f1. t1) ~ (. c2: f2. t2) G fco .1 : f1 G fco .2 : f2 CT IN S T C G fco \n.@(.1, .2) : t1[.1/c1] ~ t2[.2/c2] G fco . : t1 ~ t2 G fty t1 : .1 G fty t2 : .2 CT EXT G fco kind . \n: .1 ~ .2  rule for f appearing in Figure 3. These rules establish properties of the type equality relation: \n Equality is an equivalence relation, as seen in rules CT REFL, CT SY M, and CT TRAN S.  Equality is \ncongruent types with equal subcomponents are equal. Every type formation rule (except for the base cases \nlike variables and constants) has an associated congruence rule. The exception is kind coercion t C ., \nwhere the congruence rule is derivable (see Section 4.3.2). The congruence rules are mostly straightforward; \nwe discuss the rules for quanti.ed types (rules CT AL LT and CT AL LC) in Section 4.3.1.  Equality can \nbe assumed. Coercion variables and axioms add assumptions about equality to the context and appear in \nproofs (using rules CT VA R and CT AXI O M respectively). These ax\u00adioms for type equality are allowed \nto be axiom schemes they may be parameterized and must be instantiated when used. The general form of \nthe type of an axiom, C: . .. f gathers multiple parameters in a telescope, a context denoted with . \nof type and coercion variables, each of which scope over the remainder of the telescope as well as the \nbody of the axiom. We specify the list of instantiations for a telescope with ., a mixed list of types \nand coercions. When type checking an axiom application, we must type check its list of arguments . against \nthe given telescope. The judgement form G ftel . . . (presented in the extended version of this paper) \nchecks each argument . in turn against the binding in the telescope, scoping variables appropriately. \n Equality can be decomposed using the next six rules. For exam\u00adple, because we know that datatypes are \ninjective type func\u00adtions, we can decompose a proof of the equivalence of two datatypes into equivalence \nproofs for any pair of correspond\u00ading type parameters (CT NT H). Furthermore, the equivalence of two \npolymorphic types means that the kinds of the bound variables are equivalent (CT NTH 1TA), and that all \ninstanti\u00adations of the bound variables are equivalent (CT IN ST). The same is true for coercion abstraction \ntypes (rules CT NTH1CA, CT NT H2CA, and CT IN S T C).  Equality is heterogeneous. If . is a proof of \nthe equality t1 ~ t2, then kind . extracts a proof of equality between the kinds of t1 and t2.  4.3.1 \nCongruence rules for quanti.ed types In prior versions of FC, the coercion .a: ... proved the equality \nproposition . a: .. t1 ~ . a: .. t2, using the following rule: G fty . : * G, a: . fco . : t1 ~ t2 CT \nAL LTX G fco . a: .. . : (. a: .. t1) ~ (. a: .. t2) This rule suf.ced because the only quanti.ed types \nthat could be shown equal had the same syntactic kinds . for the bound variable. However, we now have \na nontrivial equality between kinds. We need to be able to show a more general proposition, . a: .1. \nt1 ~ . a: .2. t2, even when .1 is not syntactically equal to .2. Without this generality, the language \ndoes not satisfy the preservation theorem, which requires that the equality relation be substitutive \ngiven a valid type s where a appears free, and a proof G fco . : t1 ~ t2, we must be able to derive a \nproof between s[t1/a] and s[t2/a]. For this property to hold, if a occurs in the kind of a quanti.ed \ntype (or coercion) variable . b: a. t , then we must be able to derive . b: t1. t ~ . b: t2. t . Rule \nCT ALLT shows when two polytypes are equal. The .rst premise requires a proof . that the kinds of the \nbound variables are equal. But, these two kinds might not be syntactically equal, so we must have two \ntype variables, a1 and a2, one of each kind. The fwf G G fty . a: .. * : * T # G GWF TYDATA fwf G, T: \n. a: .. * G fty . a: .. . .. (s . T a) : * K # G GWF CO N fwf G, K: . a: .. . .. (s . T a) G, . fpr f \nok C # G GWF AX fwf G, C: . .. f Figure 5. Context formation rules (excerpted) second premise of the \nrule adds both bindings a1: .1 and a2: .2 to the context as well as an assertion c that a1 and a2 are \nequal. The polytypes themselves can only refer to their own variables, as veri.ed by the last two premises \nof the rule. The other type form that includes binding is the coercion ab\u00adstractions, . c: f. t . The \nrule CT AL L C constructs a proof that two such types of this form are equal. We can only construct such \nproofs when the abstracted propositions relate correspond\u00adingly equal types, as witnessed by proofs .1 \nand .2. The proof term introduces two coercion variables into the context, similar to the two type variables \nabove. Due to proof irrelevance, there is no need for a proof of equality between coercions themselves. \nNote that the kind of c1 is not that of .1: the kind of c1 is built from types in both .1 and .2. The \nrule CT AL LC also restricts how the variables c1 and c2 can be used in .. The premises c1 # |.| and \nc2 # |.| prevent these variables from appearing in the relevant parts of .. (The freshness operator # \nrequires its two arguments to have disjoint sets of free variables.) This restriction stems from our \nproof technique for the consistency of this proof system; we de.ne the erasure operation | \u00b7 | and discuss \nthis issue in more detail in Section 6. 4.3.2 Coercion irrelevance and coherence Although the type system \nincludes a judgement for type equality, and types may include explicit coercion proofs, the system does \nnot include a judgement that states when two coercions proofs are equal. The reason is that this relation \nis trivial all coercions should be considered equivalent. As a result, coercion proofs are irrelevant \nto type equality. This proof irrelevance is guaranteed by several of the coer\u00adcion rules. Consider the \ncongruence rule for coercion application, CT CAP P: there are no restrictions on .2 and .2 ' other than \nwell\u00adformedness. Another example is rule CT IN S TC again, no rela\u00adtion is required between the coercions \n.1 and .2. Not only is the identity of coercion proofs irrelevant, but it is always possible to equate \na type with a casted version of itself. The coherence rule, CT CO H, essentially says that the use of \nkind coercions can be ignored when proving type equalities. Although this rule seems limited, it is suf.cient \nto derive the elimination and congruence rules for coerced types, as seen below. G fco . : t1 ~ t2 G \nfty t1 C .1 : .1 G fty t2 C .2 : .2 G fco (sym ((sym .) C .2)) C .1 : t1 C .1 ~ t2 C .2 (Again, note \nthat there is no relation required between .1 and .2.) We use the syntactic sugar . C .1 ~ .2 to abbreviate \nthe coercion (sym ((sym .) C .2)) C .1.  4.4 Datatypes Because we focus on the treatment of equality \nin the type language, we omit most of the discussion of the expression language and its operational semantics. \nHowever, since we have collapsed types and kinds, we must revise the treatment of datatypes, whose construc\u00adtors \ncan contain types and kinds as arguments. Previously, the ar\u00adguments to datatype constructors were ordered \nwith all kind argu\u00adments occurring before all type arguments (Yorgey et al. 2012). In this language, \nwe cannot divide up the arguments in this way. Therefore, we again use the technique of telescopes to \ndescribe the more complex dependency between arguments.  The validity rules for contexts (see Figure \n5) restrict datatype constants T to have kind . a: .. *. We call the variables a the parameters of the \ndatatype. For example, the kind of the datatype List is . a: *. * and the kind of the datatype TyRep \n(the .rst version from Section 2) is . k: *, t: k. *. Furthermore, datatypes can only be parameterized \nby types and kinds, not coercions. Likewise, the same validity rules force data constructors K to have \ntypes/kinds of the form . a: .. . .. (s . T a). Each data constructor K must produce an element of T \napplied to all of its parameters a: .. Above, the form . .. t is syntactic sugar for a list of nested \nquanti.ed types. The scope of the bound variables includes both the remainder of the telescope . and \nthe form within the quanti.cation (in this case, s . T a). The telescope . describes the existential \narguments to the data constructor. These arguments may be either coercions or types, and because of the \ndependency, must be allowed to freely intermix. For example, the data constructor TyInt from Section \n2 (a data constructor belonging to TyRep : . k: *, t: k. *) includes two coercions in its telescope, \none asserting that the kind parameter k is *, the second asserting that the type parameter t is Int: \nTyInt : . k: *, t: k. . c1: k ~ *, c2: t ~ Int. TyRep k t Likewise, the data constructor TyApp existentially \nbinds k ' , a, b, and c one kind and two type variables followed by a coercion. TyApp : .k: *, t: k..k \n' : *, a: k ' . k, b: k ' , c: t ~ a b . TyRep (k ' . k) a . TyRep k ' b . TyRep k t A datatype value \nis of the form K t . e, where t denotes the parameters (which cannot include coercions), . instantiate \nthe ex\u00adistential arguments, and e is the list of usual expression arguments to the data constructor. \n5. The push rules and the preservation theorem Now that we have de.ned our extensions, we turn to the \nmetathe\u00adory: preservation and progress. While the operational semantics is largely unchanged from prior \nwork, we detail here a few key dif\u00adferences. The most intricate part of the operational semantics of \nFC are the push rules, which ensure that coercions do not inter\u00adfere with the small step semantics. Coercions \nare pushed into the subcomponents of values whenever a coerced value appears in an elimination context. \nSystem FC has four push rules, one for each such context: term application, type application, coercion \napplica\u00adtion, and pattern matching on a datatype. The .rst three are straight\u00adforward and are detailed \nin previous work (Yorgey et al. 2012). In this section, we focus on pattern matching and the S KPU S \nH rule. 5.1 Pushing coercions through constructors When pattern matching on a coerced datatype value \nof the form K t . e C . , the coercion must be distributed over all of the argu\u00ad' . ' ' ments of the \ndata constructor, producing a new scrutinee K t e as shown in Figure 6. In the rest of this section, \nwe explain the rule by describing the formation of the lifting context . and its use in ' , . ' ' the \nde.nition of t and e . The S KPUSH rule uses a lifting operation .(\u00b7) on expressions which coerces the \ntype of its argument (e in Figure 6). For example, K: . a: .. . .. s . (T a) . G . = extend(context(.); \n.; .) t' = .2(a) . ' = .2(dom .) for each ei . e, ei ' = ei C .(si ) S KPU S H case ((K t . e) C .) \nof p . u -. ' . ' case (K t e ' ) of p . u Figure 6. The S KPUS H rule suppose we have a data constructor \nK of type . a: * . F a . T a for some type function F and some type constructor T . Consider what happens \nwhen a case expression scrutinee (K Int e)C., where . is a coercion of type T Int ~ T t '. The push rule \nshould convert this expression to K t ' (e C . ' ) for some new coercion . ' showing F Int ~ F t '. To \nproduce . ', we need to lift the type F a to a coercion along the coercion nth1 ., which shows Int ~ \nt ' . In previous work, lifting was written s[a . .], de.ned by anal\u00adogy with substitution. Because of \nthe similar syntax of types and coercion proofs, we could think of lifting as replacing a type vari\u00adable \nwith a coercion to produce a new coercion. That intuition holds true here, but we require more machinery \nto make this precise. Lifting contexts We de.ne lifting with respect to a lifting context ., which maps \ntype variables to triples (t1, t2, .) and coercion variables to pairs (.1, .2). The forms t1 and .1 refer \nto the original, uncoerced parameters to the data constructor (Int in our example). The forms t2 and \n.2 refer to the new, coerced parameters to the data constructor (like t ' in our example). Finally, the \ncoercion . witnesses the equality of t1 and t2. No witness is needed for the equality between .1 and \n.2 equality on proofs is trivial. The lifting operation is de.ned by structural recursion on its type \nargument. This operation is complicated by type forms that bind fresh variables: . a: .. t and . c: f. \nt . Lifting over these types introduces new mappings in the lifting context, marked with .. (We use \nthe notation . to refer to a mapping created either with . ::= \u00d8 || ., a: . . (t1, t2, .) ., a: . . (a1, \na2, c) || ., c: f . (.1, .2) ., c: f . (c1, c2) ?  . or with ..) A lifting context . induces two multisubstitutions \n.1(\u00b7) and .2(\u00b7), as follows: De.nition 5.1 (Lifting context substitution). .1(\u00b7) and .2(\u00b7) are multisubstitutions, \napplicable to types, coercions, telescopes, typ\u00ading contexts, and even other lifting contexts. ? 1. For \neach a: . . (t1, t2, .) in ., .1(\u00b7) maps a to t1 and .2(\u00b7) maps a to t2. ? 2. For each c: f . (.1, \n.2) in ., .1(\u00b7) maps c to .1 and .2(\u00b7) maps c to .2.  The two substitution operations satisfy straightforward \nsubsti\u00adtution lemmas, de.ned and proved in the extended version of this paper. The usual substitution \nlemmas, which substitute a single type or coercion, are a direct corollary of these lemmas. We can now \nde.ne lifting:6 De.nition 5.2 (Lifting). We de.ne the lifting of types to coercions, written .(t), by \ninduction on the type structure. The following equations, to be tried in order, de.ne the operation. \n(Note that the last line uses the syntactic sugar introduced in Section 4.3.2.)  ? .(a) = . when a: \n. . (t1, t2, .) . . .(t) = (t ) when t # dom(.) .(t1 t2) = .(t1) .(t2) .(t .) = .(t )(.1(.), .2(.)) .(. \na: .. t ) = ..(.)(a1, a2, c).. ' (t ) where . ' = ., a: . . (a1, a2, c) and a1, a2, c are fresh .(. \nc: s1 ~ s2. t ) = .(.(s1),.(s2))(c1, c2).. ' (t )  where . ' = ., c: s1 ~ s2 . (c1, c2) and c1, c2 are \nfresh .(t C .) = .(t ) C .1(.) ~ .2(.) The lifting lemma establishes the correctness of the lifting op\u00aderation \nand shows that equality is congruent. Lemma 5.3 (Lifting Lemma). If . is a valid lifting context for \ncontext G and the telescope ., and G, . fty t : ., then G fco .(t ) : .1(t ) ~ .2(t ) Lifting context \ncreation In the S KPUS H rule, the actual context . used for lifting is built in two stages. First, context(.) \nde.nes a lifting context with coercions for the parameters to the datatype. De.nition 5.4 (Lifting context \ngeneration). If G fco . : T s ~ T s' , and T: . a: .. * . G, where the lists s, s', and a: . are all \nof length n, then de.ne context(.) as i.1..n context(.) = ai: .i . (si , s i ' , nthi .) Intuitively, \n(context(.))1(t ) replaces all parameters a in t with the corresponding type on the left of ~ in the \ntype of .. Simi\u00adlarly, (context(.))2(t) replaces a with the corresponding type on the right of ~. Next, \nthis initial lifting context is extended with coercions using the operation extend(\u00b7), which adds mappings \nfor the variables in ., the existential parameters to the data constructor K . Due to the dependency, \nwe de.ne the operation recursively. The intuition still holds: (extend(.; .; .))1(t ) replaces free variables \nin t with their corresponding from types, while (extend(.; .; .))2(t ) replaces a variables with their \ncorresponding to types. De.nition 5.5 (Lifting context extension). De.ne the operation of lifting context \nextension, written extend(.; .; .), as: extend(.; \u00d8; \u00d8) =. extend(.; ., t ; ., a: .) = . ' , a: . . \n(t, t C . ' (.), sym ((t) C . ' (.))) where . ' = extend(.; .; .) extend(.; ., . ; ., c: s1 ~ s2) = . \n' , c: s1 ~ s2 . (., sym (. ' (s1)) 9 . 9 . ' (s2)) where . ' = extend(.; .; .)  5.2 Type preservation \nNow that we have explained the most novel part of the operational semantics, we can state the preservation \ntheorem. Theorem 5.6 (Preservation). If G ftm e : t and e -. e ' then G ftm e ' : t . The proof of this \ntheorem is by induction on the typing deriva\u00adtion, with a case analysis on the small-step. Most of the \nrules are straightforward, following directly by induction or by substi\u00adtution. The push rules require \nreasoning about coercion propaga\u00adtion. We include the details of the rules that differ from previous \nwork (Weirich et al. 2010) in the extended version of this paper.  5.3 Correctness of push rules: The \ntype erasure theorem We care not only that the push rules preserve types, but that they do the right \nthing. Do these rules reduce to no-ops if we erase types and coercions? To state this formally, we de.ne \nan erasure operation | \u00b7 | over expressions. This operation erases types, coercions, and equality propositions \nto trivial forms ty , co and prop and removes all casts. The full de.nition of this operation appears \nin the extended version of this paper, and we present only the interesting cases here: |e t| = |e| ty \n|e .| = |e| co |e C .| = |e| With this operation, we can state that erasing types, coercions and casts \ndoes not change how expressions evaluate e. Theorem 5.7 (Type erasure). If e -. e ', then either |e| \n= |e ' | or |e| -. |e ' |. 6. Consistency and the progress theorem The proof for the progress theorem \nfollows the same course as in previous work (Weirich et al. 2010). The progress theorem holds only for \nclosed, consistent contexts. A context is closed if it does not contain any expression variable bindings \nas usual, open ex\u00adpressions could be stuck. We use the metavariable S to denote closed contexts. Theorem \n6.1 (Progress). Assume S is a closed, consistent context. If S ftm e1 : t and e1 is not a value v or \na coerced value v C . , then there exists an e2 such that e1 -. e2. The de.nition of consistent contexts \nis stated using the notions of uncoerced values and their types, value types. Formally, we de.ne values \nv and value types ., with the following grammars: v ::= .x: s. e | .a: .. e | .c: f. e | K t . e . ::= \ns1 . s2 | . a: .. s | . c: f. s | T s De.nition 6.2 (Consistency). A context G is consistent if .1 and \n.2 have the same head form whenever G fco . : .1 ~ .2. Although the extensions in this paper have little \neffect on the structure of this proof compared to prior work, there is still work to do: we need an new \nnotion of acceptable contexts to allow kind equalities, and we must prove that these contexts are consistent. \nOur consistency argument proceeds in four steps: 1. Because coercion proofs are irrelevant to type equivalence, \nwe start with an implicitly coerced version of the language, where all coercion proofs have been erased. \nDerivations in the explicit language can be matched up with derivations in the implicit language (De.nition \n6.3) so showing consistency in the latter implies consistency in the former. 2. We de.ne a rewrite relation \nthat reduces types in the implicit system by .ring axioms in the context (Figure 7). 3. We specify a \nsuf.cient condition, which we write Good G (De.nition 6.5), for a context to be consistent. This condition \nallows the axioms produced by type and kind family de.nitions. 4. We show that good contexts are consistent \nby arguing that the joinability of the rewrite relation is complete with respect to the implicit coercion \nproof system. Since the rewrite relation and erasure preserve the head form of value types, this gives \nconsistency for both the implicit and explicit systems.  Since we don t want consistency to depend on \nparticular proofs of kind equality, we prove our results with an implicit version of the type language. \nThis implicit language elides coercion proofs and casts from the type language, and has judgements (denoted \nwith a turnstile |=) analogous to the explicit language but for a few key  G |= t t ' TS RE FL G |= \nt t G, G ' |= . . ' G, c: a1 ~ a2, G ' |= s s ' TS ALLT G, G ' |= . a1: .. s . a2: . ' . s ' G |= t1 \nt1 ' G |= t2 t2 ' G |= s s ' ' ' TS AL L C G |= . c: t1 ~ t2. s . c: t1 ~ t2. s' C: . .. (F t ~ t ' ) \n. G s1 = t [./.] s ' = t ' [./.] 1 TS RE D G |= F s1 s1 ' c: a ~ t . G TS VA RRE D G |= a t G |= t t \n' G |= s s ' TS AP P ' s ' G |= t t ' G |= t s t TS CAP P G |= t co t ' co Figure 7. Rewrite relation \ndifferences where coercions are dropped from types. To connect the explicit and implicit systems, we \nde.ne an erasure operation: De.nition 6.3 (Coercion Erasure). Given an explicitly typed term t or coercion \n., we de.ne its erasure, denoted |t | or |.|, by induction on its structure. The interesting cases follow: \n|t C .| = |t | |.(.1, .2)| = |.|( co, co) |t .| = |t | co |. C . ' | = |.||.@(. ' , . '' )| = |.|@( co, \nco) All other cases follow by simply propagating the | \u00b7 | operation down the abstract syntax tree. (The \nfull de.nition of this operation appears in the extended version of this paper.) We further de.ne the \nerasure of a context G, denoted |G|, by erasing the types and equality propositions of each binding. \nLemma 6.4 (Erasure is type preserving). If a judgement holds in the explicit system, the judgement with \ncoercions erased throughout the context, types and coercions is derivable in the implicit system. We \nde.ne a nondeterministic rewrite relation on open implicit types in Figure 7. We say that s1 is joinable \nwith s2, written G |= s1 . s2, when both can multi-rewrite to a common reduct. Consistency does not hold \nin arbitrary contexts, and it is dif.cult in general to check whether a context is inconsistent. Therefore, \nlike in previous work (Weirich et al. 2010), we give suf.cient conditions written Good G, for a context \nto be consistent. Since we are working with the implicit language, these conditions are actually for \nthe erased context. De.nition 6.5 (Good contexts). We have Good G when the fol\u00adlowing conditions hold: \n1. All coercion assumptions and axioms in G are of the form C: . .. (F t ~ t ' ) or of the form c: a1 \n~ a2. In the .rst form, the arguments to the type function must behave like patterns: for all ., every \nti . t and every ti ' such that G |= ti [./.] ti ' , there exists . ' such that t ' = ti [.'/.] and G \n| s ' for i = smm each sm . . and s ' . . ' . m 2. Axioms and coercion assumptions don t overlap. For \neach F t , there exists at most one pre.x t1 of t such that there exist C and . where C: . .. F s0 ~ \ns1 . G and t1 = s0[./.]. These C and . are unique for every matching F t1. 3. For each a, there is at \nmost one assumption of the form c: a ~ '' ' a or c: a ~ a, and a . = a 4. Axioms equate types of the \nsame kind. For each C: . .. (F t ~ t ' ) in G, the kinds of each side must equal: for some ., G, . |= \nF t : . and G, . |= t ' : . and that kind must not mention bindings in the telescope, G |= . : *. The \nmain lemma required for consistency is the completeness of joinability. Here, we write fcv(.) . dom G \n' to indicate that all coercion variables and axioms used in . are in the domain of G ' . Lemma 6.6 (Completeness). \nSuppose that G |= . : s1 ~ s2, and fcv(.) . dom G ' for some subcontext G ' satisfying Good G ' . Then \nG |= s1 . s2. The proof of this theorem appears in the extended version of this paper. Here, we highlight \na technical point about coercions between coercion abstractions. The completeness proof requires that \nall coercion variables in a coercion . must satisfy the requirements of Good contexts. As a result, we \nneed to restrict the coercion abstraction equality rule in both the implicit and explicit systems. G \n|= .1 : s1 ~ s1 ' f1 = s1 ~ s2 G |= .2 : s2 ~ s2 ' f2 = s1 ' ~ s2 ' c1 # . c2 # . G, c1: f1, c2: f2 |= \n. : t1 ~ t2 G |= . c1: f1. t1 : * G |= . c2: f2. t2 : * G |= .(.1,.2)(c1, c2).. : (. c1: f1. t1) ~ (. \nc2: f2. t2) In this rule, the variables c1 and c2 cannot be used in . due to the premises c1 # . and \nc2 # .. (The analogous rule in the explicit system includes the premises c1 # |.| and c2 # |.|.) This \nrestriction is because c1 and c2 may be inconsistent assumptions: perhaps c1: Int ~ Bool. If we were \nto introduce these into the context, induction would fail. The consequence of these restrictions is that \nthere are some types that cannot be shown equivalent, even though they are in\u00adtuitively equivalent. For \nexample, there is no proof of equivalence between the types . c1: Int ~ b. Int and . c2: Int ~ b. b a \ncoer\u00adcion between these two types would need to use c1 or c2. However, this lack of expressiveness is \nnot signi.cant in source Haskell, it could only be observed through exotic uses of .rst-class polymor\u00adphism, \nwhich are already rare in general. Furthermore, this restric\u00adtion already exists in GHC7 and other dependently-typed \nlanguages such as Agda and Coq. It is possible that a different consistency proof would validate a rule \nthat does not restrict the use of these variables. However, we leave this possibility to future work. \n7. Discussion and related work Collapsing kinds and types Blurring the distinction between types and \nkinds is convenient, but is it wise? It is well known that type systems that include the G fty * : * \nrule are inconsistent log\u00adics (Girard 1972). Does that cause trouble? For FC the answer is no inconsistency \nhere means that all kinds are inhabited, but even without our extensions, all kinds are already inhabited. \nThe G fty * : * rule often causes type checking to be undecid\u00adable in dependently typed languages (Cardelli \n1986; Augustsson 1998). This axiom permits the expression of divergent terms if the type checker tries \nto reduce them it will loop. However, type checking in FC is decidable all type equalities are witnessed \nby .nite equality proofs, not potentially in.nite reductions.  At the source language level, which does \nreduce type expres\u00adsions, it is not clear whether adding the G fty * : * rule could cause type inference \nto loop (in the absence of language extensions such as UndecidableInstances which already make divergence \npossible). However, even though this version of FC combines types and kinds, the Haskell source language \nneed not do so (predictable type inference algorithms may require more traditional strati.ca\u00adtion). This \ngap would not be new differing requirements for the core and surface languages have already led FC to \nbe more expres\u00adsive than source Haskell. Heterogeneous equality Heterogeneous equality is an essential \npart of this system. It is primarily motivated by the presence of de\u00adpendent application (such as rules \nK INST and K CAP P), where the kind of the result depends on the value of the argument. We would like \ntype equivalence to be congruent with respect to appli\u00adcation, as is demonstrated by rule CT APP. However, \nif all equal\u00adities are required to be homogeneous, then not all uses of the rule are valid because the \nresult kinds may differ. For example, consider the datatype TyRep : . k: * . . b: k. *. If we have coercions \nG fco .1 : * ~ . and G fco .2 : Int ~ t (with G fty t : .), then we can construct the proof G fco (TyRep) \n.1 .2 : TyRep * Int ~ TyRep . t However, this proof requires heterogeneity because the .rst part ((TyRep) \n.1) creates an equality between types of different kinds: TyRep * and TyRep .. The .rst has kind * . \n*, whereas the second has kind . . *. The coherence rule (CT COH) also requires that equality be het\u00aderogeneous \nbecause it equates types that almost certainly have dif\u00adferent kinds. This rule, inspired by Observational \nType Theory (Al\u00adtenkirch et al. 2007), provides a simple way of ensuring that proofs do not interfere \nwith equality. Without it, we would need coercions analogous to the many push rules of the operational \nsemantics. There are several choices in the semantics of heterogeneous equality. We have chosen the most \npopular, where a proposition s1 ~ s2 is interpreted as a conjunction: the types are equal and their kinds \nare equal . This semantics is similar to Epigram 1 (McBride 2002), the HeterogeneousEquality module in \nthe Agda standard library,8 and the treatment in Coq.9 Epigram 2 (Al\u00adtenkirch et al. 2007) uses an alternative \nsemantics, interpreted as if the kinds are equal then the types are equal . (This relation requires a \nproof of kind equality before coercing types.) Guru (Stump et al. 2008) and Trellys (Kimmell et al. 2012; \nSj \u00a8oberg et al. 2012) use yet another interpretation which says nothing about the kinds. These differences \nre.ect the design of the type systems the syntax\u00addirected type system of FC makes the conjunctive interpretation \nthe most reasonable, whereas the bidirectional type system of Epi\u00adgram 2 makes the implicational version \nmore convenient. As Gu\u00adru/Trellys demonstrate, it is also reasonable to not require kind equality. We \nconjecture that without the kind . coercion form, it would be sound to drop the fourth condition from \nGood G. Unlike higher-dimensional type theory (Licata and Harper 2012), equality in this language has \nno computational content. Be\u00adcause of the separation between objects and proofs, FC is resolutely one-dimensional \nwe do not de.ne what it means for proofs to be equivalent. Instead, we ensure that in any context the \nidentity of equality proofs is unimportant. The implicit language Our proof technique for consistency, \nbased on erasing explicit type conversions, is inspired by ICC (Miquel 2001). Coercion proofs are irrelevant \nto the de.nition of 8 http://wiki.portal.chalmers.se/agda/agda.php?n= Libraries.StandardLibrary 9 http://coq.inria.fr/stdlib/Coq.Logic.JMeq.html \ntype equality, so to reason about type equality it is convenient to ignore them entirely. Following ICC* \n(Barras and Bernardo 2008), we could also view the implicit language as the real semantics for FC, and \nconsider the language of this paper as an adaptation of that semantics with annotations to make typing \ndecidable. Furthermore, the implicit language is interesting in its own right as it is closer to source \nHaskell, which also makes implicit use of type equalities. However, although the implicit language allows \ntype equality assumptions to be used implicitly, it is not extensional type theory (ETT) (Martin-L \u00a8 \nof 1984): it separates proofs from programs so that it can weaken the former (ensuring consistency) while \nenriching the latter (with type-in-type ). As a result, the proof language of FC is not as expressive \nas ETT; besides the limitations on equalities between coercion abstractions in Section 6, FC lacks .-equivalence \nor extensional reasoning for type-level functions. Explicit equality proofs In concurrent related work, \nvan Doorn, Geuvers and Wiedijk (Geuvers and Wiedijk 2004; van Doorn et al. 2013) develop a variant of \npure type systems that replaces implicit conversions with explicit convertibility proofs. There are strong \nconnections to this paper: they too use heterogeneous equality and must signi.cantly generalize the statement \nof a lifting lemma (which they call equality of substitutions ). However, there are differences. Their \nwork is based on Pure Type Systems, which gen\u00aderalize over sorts, rules and axioms; we only consider \na single in\u00adstance here. They also show that the system with explicit equalities is equivalent to the \nsystem with implicit equalities; we only show one direction. Finally, as their work is based on intensional \ntype theory, it does not address coercion abstraction. Consequently, their analogue to rule CT ALLT is \nthe following asymmetric rule. G fco . : .1 ~ .2 G, a1: .1 fco . : t1 ~ t2[a1 C ./a2] G fty . a1: .1. \nt1 : * G fty . a2: .2. t2 : * CT ALLTA G fco . a1: .1. . : (. a1: .1. t1) ~ (. a1: .2. t2) We conjecture \nthat in our system, the above rule is equivalent to CT ALLT. 8. Conclusions and future work This work \nprovides the basis for the practical extension of a popu\u00adlar programming language implementation. It \ndoes so without sac\u00adri.cing any important metatheoretic properties. This extension is a necessary step \ntowards making Haskell more dependently typed. The next step in this research plan is to lift these extensions \nto the source language, incorporating these features within GHC s constraint solving algorithm. In particular, \nwe plan future language extensions in support of type-and kind-level programming, such as datakinds (datatypes \nthat exist only at the kind-level), kind syn\u00adonyms and kind families. Although GHC already infers kinds, \nwe will need to extend this mechanism to generate kind coercions and take advantage of these new features. \nGoing further, we would like to also like to support a true de\u00adpendent type in Haskell, which would allow \ntypes to mention ex\u00adpressions directly, instead of requiring singleton encodings. One way to extend Haskell \nin this way is through elaboration: we be\u00adlieve that the translation between source Haskell and FC could \nau\u00adtomatically insert the appropriate singleton arguments (Eisenberg and Weirich 2012), perhaps using \nthe class system to determine where they are necessary. This approach would not require fur\u00adther extension \nto FC. Alternatively, Adam Gundry s forthcoming dissertation10 includes .-types in a version of System \nFC that is 10 Personal communication  strongly in.uenced by an early draft of this work. If elaboration \ndoes not prove to be suf.ciently expressive, Gundry s work pro\u00advides a blueprint for future core language \nextension. In either case the interaction between dependent types and type inference brings new research \nchallenges. However, the results in this paper mean that these challenges can be addressed in the context \nof a .rm semantic basis. Acknowledgments Thanks to Simon Peyton Jones, Dimitrios Vytiniotis, Iavor Di\u00adatchki, \nJos\u00b4aes, Adam Gundry and Conor McBride e Pedro Magalh for discussion. This material is based upon work \nsupported by the National Science Foundation under Grant Nos. 0910500 and 1116620. References T. Altenkirch \nand C. McBride. Generic programming within dependently typed programming. In J. Gibbons and J. Jeuring, \neditors, Generic Programming, volume 243 of IFIP Conference Proceedings, pages 1 20. Kluwer, 2002. T. \nAltenkirch, C. McBride, and W. Swierstra. Observational equality, now! In Proceedings of the 2007 workshop \non Programming Languages meets Program Veri.cation, PLPV 07, pages 57 68, New York, 2007. ACM. L. Augustsson. \nCayenne a language with dependent types. In Proceedings of the third ACM SIGPLAN International Conference \non Functional Programming, ICFP 98, pages 239 250, New York, 1998. ACM. . H. P. Barendregt. Handbook \nof logic in computer science (vol. 2). chapter Lambda calculi with types, pages 117 309. Oxford University \nPress, New York, 1992. B. Barras and B. Bernardo. The implicit calculus of constructions as a pro\u00adgramming \nlanguage with dependent types. In Foundations of Software Science and Computational Structures, volume \n4962 of Lecture Notes in Computer Science, pages 365 379. Springer, Berlin, Heidelberg, 2008. L. Cardelli. \nA polymorphic lambda calculus with type:type. Technical Report 10, Digital Equipment Corporation Systems \nResearch Center, 1986. M. M. T. Chakravarty, G. Keller, and S. Peyon Jones. Associated type synonyms. \nIn Proceedings of the tenth ACM SIGPLAN International Conference on Functional Programming, ICFP 05, \npages 241 253, New York, 2005. ACM. K. Crary, S. Weirich, and G. Morrisett. Intensional polymorphism \nin type erasure semantics. In Proceedings of the Third ACM SIGPLAN International Conference on Functional \nProgramming, ICFP 98, pages 301 313, Baltimore, MD, USA, 1998. ACM. R. A. Eisenberg and S. Weirich. Dependently \ntyped programming with singletons. In Proceedings of the 2012 Haskell Symposium, Haskell 12, pages 117 \n130, New York, 2012. ACM. H. Geuvers and F. Wiedijk. A logical framework with explicit conversions. In \nC. Schuermann, editor, LFM 04, Proceedings of the Fourth Interna\u00adtional Workshop on Logical Frameworks \nand Meta-Languages, Cork, Ireland, pages 32 45, 2004. J.-Y. Girard. Interpr \u00b4 \u00b4 etation fonctionnelle \net elimination des coupures de l arithm\u00b4etique d ordre sup\u00b4PhD thesis, Universit\u00b4 erieu. e de Paris VII, \n1972. M. P. Jones. Type classes with functional dependencies. In 9th European Symposium on Programming, \nESOP 00, volume 1782 of Lecture Notes in Computer Science, pages 230 244. Springer, 2000. G. Kimmell, \nA. Stump, H. D. Eades III, P. Fu, T. Sheard, S. Weirich, C. Cas\u00adinghino, V. Sj \u00a8 oberg, N. Collins, and \nK. Y. Ahn. Equational reasoning about programs with general recursion and call-by-value semantics. In \nSixth ACM SIGPLAN Workshop Programming Languages meets Pro\u00adgram Veri.cation (PLPV 12), 2012. D. R. Licata \nand R. Harper. Canonicity for 2-dimensional type theory. In Proceedings of the 39th annual ACM SIGPLAN-SIGACT \nsymposium on Principles of programming languages, POPL 12, pages 337 348, New York, NY, USA, 2012. ACM. \nZ. Luo. Computation and reasoning: a type theory for computer science. Oxford University Press, Inc., \nNew York, NY, USA, 1994. J. P. Magalh aes. The right kind of generic programming. In 8th ACM SIG-PLAN \nWorkshop on Generic Programming, WGP 2012, Copenhagen, Denmark, New York, NY, USA, 2012. ACM. P. Martin-L \n\u00a8of. Intuitionistic Type Theory. Bibliopolis, 1984. C. McBride. Elimination with a motive. In Selected \npapers from the International Workshop on Types for Proofs and Programs, TYPES 00, pages 197 216, London, \nUK, UK, 2002. Springer-Verlag. C. T. McBride. Agda-curious?: an exploration of programming with depen\u00addent \ntypes. In P. Thiemann and R. B. Findler, editors, ICFP, pages 1 2. ACM, 2012. ISBN 978-1-4503-1054-3. \nA. Miquel. The implicit calculus of constructions: extending pure type sys\u00adtems with an intersection \ntype binder and subtyping. In Proceedings of the 5th international conference on Typed lambda calculi \nand appli\u00adcations, TLCA 01, pages 344 359, Berlin, Heidelberg, 2001. Springer-Verlag. U. Norell. Functional \ngeneric programming and type theory, 2002. MSc thesis. N. Oury and W. Swierstra. The power of Pi. In \nProceedings of the 13th ACM SIGPLAN international conference on Functional programming, ICFP 08, pages \n39 50, New York, NY, USA, 2008. ACM. ISBN 978\u00ad1-59593-919-7. S. Peyton Jones, D. Vytiniotis, S. Weirich, \nand G. Washburn. Simple uni.cation-based type inference for GADTs. In Proceedings of the eleventh ACM \nSIGPLAN International Conference on Functional Pro\u00adgramming, ICFP 06, pages 50 61, New York, NY, USA, \n2006. ACM. T. Schrijvers, S. Peyton Jones, M. Sulzmann, and D. Vytiniotis. Complete and decidable type \ninference for GADTs. In Proceedings of the 14th ACM SIGPLAN international conference on Functional programming, \nICFP 09, pages 341 352, New York, NY, USA, 2009. ACM. V. Sj \u00a8oberg, C. Casinghino, K. Y. Ahn, N. Collins, \nH. D. Eades III, P. Fu, G. Kimmell, T. Sheard, A. Stump, and S. Weirich. Irrelevance, het\u00aderogenous equality, \nand call-by-value dependent type systems. In Fourth workshop on Mathematically Structured Functional \nProgram\u00adming (MSFP 12), 2012. A. Stump, M. Deters, A. Petcher, T. Schiller, and T. Simpson. Veri.ed programming \nin Guru. In Proceedings of the 3rd workshop on Program\u00adming languages meets program veri.cation, PLPV \n09, pages 49 58, New York, NY, USA, 2008. ACM. M. Sulzmann, M. M. T. Chakravarty, S. P. Jones, and K. \nDonnelly. System F with type equality coercions. In Proceedings of the 2007 ACM SIGPLAN international \nworkshop on Types in languages design and implementa\u00adtion, TLDI 07, pages 53 66, New York, NY, USA, 2007. \nACM. F. van Doorn, H. Geuvers, and F. Wiedijk. Explicit convertibility proofs in pure type systems. Draft \npaper, in submission, http://www.cs.ru. nl/~herman/PUBS/ExplicitPTS.pdf, 2013. D. Vytiniotis, S. Peyton \nJones, and J. P. Magalh aes. Equality proofs and deferred type errors: A compiler pearl. In Proceedings \nof the 14th ACM SIGPLAN International Conference on Functional Programming, ICFP 2012, Copenhagen, Denmark, \nNew York, NY, USA, 2012. ACM. S. Weirich, D. Vytiniotis, S. Peyton Jones, and S. Zdancewic. Generative \ntype abstraction and type-level computation (extended version). Techni\u00adcal report, University of Pennsylvania, \nNov. 2010. S. Weirich, D. Vytiniotis, S. Peyton Jones, and S. Zdancewic. Generative type abstraction \nand type-level computation. In Proceedings of the 38th annual ACM SIGPLAN-SIGACT symposium on Principles \nof program\u00adming languages, POPL 11, pages 227 240, New York, NY, USA, 2011. ACM. Z. Yang. Encoding types \nin ML-like languages. In Proceedings of the Third International Conference on Functional Programming \n(ICFP), pages 289 300, Baltimore, Maryland, USA, 1998. ACM Press. B. A. Yorgey, S. Weirich, J. Cretin, \nS. Peyton Jones, D. Vytiniotis, and J. P. Magalh aes. Giving Haskell a promotion. In Proceedings of the \n8th ACM SIGPLAN workshop on Types in Language Design and Implementation, TLDI 12, pages 53 66, New York, \nNY, USA, 2012. ACM.   \n\t\t\t", "proc_id": "2500365", "abstract": "<p>System FC, the core language of the Glasgow Haskell Compiler, is an explicitly-typed variant of System F with first-class type equality proofs called coercions. This extensible proof system forms the foundation for type system extensions such as type families (type-level functions) and Generalized Algebraic Datatypes (GADTs). Such features, in conjunction with kind polymorphism and datatype promotion, support expressive compile-time reasoning.</p> <p>However, the core language lacks explicit kind equality proofs. As a result, type-level computation does not have access to kind-level functions or promoted GADTs, the type-level analogues to expression-level features that have been so useful. In this paper, we eliminate such discrepancies by introducing kind equalities to System FC. Our approach is based on dependent type systems with heterogeneous equality and the \"Type-in-Type\" axiom, yet it preserves the metatheoretic properties of FC. In particular, type checking is simple, decidable and syntax directed. We prove the preservation and progress theorems for the extended language.</p>", "authors": [{"name": "Stephanie Weirich", "author_profile_id": "81548019099", "affiliation": "University of Pennsylvania, Philadelphia, PA, USA", "person_id": "P4261254", "email_address": "sweirich@cis.upenn.edu", "orcid_id": ""}, {"name": "Justin Hsu", "author_profile_id": "81508686544", "affiliation": "University of Pennsylvania, Philadelphia, PA, USA", "person_id": "P4261255", "email_address": "justhsu@cis.upenn.edu", "orcid_id": ""}, {"name": "Richard A. Eisenberg", "author_profile_id": "81542549256", "affiliation": "University of Pennsylvania, Philadelphia, PA, USA", "person_id": "P4261256", "email_address": "eir@cis.upenn.edu", "orcid_id": ""}], "doi_number": "10.1145/2500365.2500599", "year": "2013", "article_id": "2500599", "conference": "ICFP", "title": "System FC with explicit kind equality", "url": "http://dl.acm.org/citation.cfm?id=2500599"}