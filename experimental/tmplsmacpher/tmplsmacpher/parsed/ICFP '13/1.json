{"article_publication_date": "09-25-2013", "fulltext": "\n Veri.ed Decision Procedures for MSO on Words Based on Derivatives of Regular Expressions Dmitriy Traytel \nTobias Nipkow Technische Universit\u00e4t M\u00fcnchen, Germany traytel@in.tum.de www.in.tum.de/~nipkow Abstract \nMonadic second-order logic on .nite words (MSO) is a decidable yet expressive logic into which many decision \nproblems can be encoded. Since MSO formulas correspond to regular languages, equivalence of MSO formulas \ncan be reduced to the equivalence of some regular structures (e.g. automata). This paper presents a veri.ed \nfunctional decision procedure for MSO formulas that is not based on automata but on regular expressions. \nFunctional languages are ideally suited for this task: regular expressions are data types and functions \non them are de.ned by pattern matching and recursion and are veri.ed by structural induction. Decision \nprocedures for regular expression equivalence have been formalized before, usually based on Brzozowski \nderivatives. Yet, for a straightforward embedding of MSO formulas into regular expressions an extension \nof regular expressions with a projection operation is required. We prove total correctness and completeness \nof an equivalence checker for regular expressions extended in that way. We also de.ne a language-preserving \ntranslation of formulas into regular expressions with respect to two different semantics of MSO. Our \nresults have been formalized and veri.ed in the theorem prover Isabelle. Using Isabelle s code generation \nfacility, this yields purely functional, formally veri.ed programs that decide equivalence of MSO formulas. \nCategories and Subject Descriptors F.4.3 [Mathematical Logic And Formal Languages]: Formal Languages \nDecision problems; F.3.1 [Mathematical Logic And Formal Languages]: Specifying and Verifying and Reasoning \nabout Programs General Terms Algorithms, Theory, Veri.cation Keywords MSO; WS1S; decision procedure; \nregular expressions; Brzozowski derivatives; interactive theorem proving; Isabelle 1. Introduction Many \ndecision procedures for logical theories are based on the fa\u00admous logic-automaton connection. That is, \nthey reduce the decision problem for some logical theory to a decidable question about some class of \nautomata. Automata are usually implemented with the help of imperative data structures for ef.ciency \nreasons. Permission to make digital or hard copies of all or part of this work for personal or classroom \nuse is granted without fee provided that copies are not made or distributed for pro.t or commercial advantage \nand that copies bear this notice and the full citation on the .rst page. Copyrights for components of \nthis work owned by others than the author(s) must be honored. Abstracting with credit is permitted. To \ncopy otherwise, or republish, to post on servers or to redistribute to lists, requires prior speci.c \npermission and/or a fee. Request permissions from permissions@acm.org. ICFP 13, September 25 27, 2013, \nBoston, MA, USA. Copyright is held by the owner/author(s). Publication rights licensed to ACM. ACM 978-1-4503-2326-0/13/09. \n. . $15.00. http://dx.doi.org/10.1145/2500365.2500612 In functional languages, automata are not an ideal \nabstraction because they are graphs rather than trees. In contrast, regular ex\u00adpressions are perfect \nfor functional languages and they are equally expressive. In fact, Brzozowski [8] showed how automata-based \nalgorithms can be recast as recursive algebraic manipulations of regular expressions. His derivatives \ncan be seen as a way of simu\u00adlating automaton states with regular expressions and computing the next-state \nfunction symbolically. Recently Brzozowski s derivatives were discovered by func\u00adtional programmers and \ntheorem provers. Owens et al. [23] real\u00ad ized that regular expressions and their derivatives .t perfectly \nwith data types and recursive functions. Their paper explores regular expression matching based directly \non regular expressions rather than automata. Fischer et al. [13] also explore regular expression matching, \nbut by means of marked regular expressions rather than derivatives. Slightly later, the interactive theorem \nproving commu\u00adnity woke up to the beauty of derivatives, too. This resulted in four papers about veri.ed \ndecision procedures for the equivalence of regular expressions based on derivatives and on marked regular \nex\u00adpressions (see Related Work below). In one of these four papers, Coquand and Siles [10] state that \nA more ambitious project will be to use this work for writing a decision procedure for WS1S , a monadic \nsecond-order logic. Our paper does just that (and more). Monadic second-order logic on .nite words (MSO) \nis a decid\u00adable yet expressive logic into which many decision problems can be encoded [26]. MSO allows \nonly monadic predicates but quan\u00ad ti.cation both over numbers and .nite sets of numbers. Two closely \nrelated but subtly different semantics can be found in the literature. One of the two, WS1S the Weak \nmonadic Second-order logic of 1 Successor, is based on arithmetic. The other, M2L(Str) [16], is more \nclosely related to formal languages. There seems to be some disagreement as to which semantics is the \nmore appropriate one for veri.cation purposes [3, 17]. Hence we cover both. Essentially, MSO formulas \ndescribe regular languages. There\u00adfore MSO formulas can be decided by translating them into au\u00adtomata. \nThis is the basis of the highly successful MONA tool [12] for deciding WS1S. MONA s success is due to \nits (in practical terms) highly ef.cient implementation and to the ease with which very different veri.cation \nproblems can be encoded in monadic second-order logic, for example Presburger arithmetic and Hoare logic \nfor pointer programs. The contribution of this paper is the presentation of the .rst purely functional \ndecision procedures for two interpretations of MSO based on derivatives of regular expressions. These \ndecision procedures have been veri.ed in Isabelle/HOL and we sketch their correctness proofs. We are \nnot aware of any previous decision procedure for MSO based on regular expressions (as opposed to automata), \nlet alone a veri.ed program. It is instructive to compare our decision procedure for WS1S with MONA. \nMONA is a highly tuned implementation using cache-conscious data structures including a BDD-based automaton \nrepresentation. Ours is a (by comparison tiny) purely functional program that operates on regular expressions \nand can only cope with small examples. MONA is not veri.ed (and the prospect of doing so is daunting), \nwhereas our code is.  In this paper we distinguish ordinary regular expressions that contain only concatenation, \nunion, and iteration from extended regular expressions that also provide complement and intersection. \nThe rest of the paper is organized as follows. Section 2 gives an overview of related work. Section 3 \nintroduces some basic notations. Sections 4 and 5 constitute the main contribution of our paper the .rst \nshows how to decide equivalence of extended regular expressions with an additional projection operation, \nthe second reduces equivalence of MSO formulas to equivalence of exactly those regular expressions with \nrespect to both semantics, M2L and WS1S. In total this yields a decision procedure for MSO on words. \nA short case study of the decision procedure is given in Section 6. 2. Related Work Brzozowski [8] introduced \nderivatives of extended regular expres\u00ad sions. Antimirov [1] introduced partial derivatives of regular \nex\u00ad pressions. Caron et al. [9] extended Antimirov to extended regu\u00ad lar expressions. The concept of \nderivatives as means to compute the next state symbolically goes beyond regular expressions as witnessed \nby libraries for parsing developed by Danielsson [11] in Agda and by Might et al. [19] in Lisp using \nlazily evaluated varia\u00ad tions of Brzozowski derivatives for parser combinators. MONA was linked to Isabelle \nby Basin and Friedrich [5] and to PVS by Owre and Rue\u00df [24]. In both cases, MONA is used as an oracle \nfor deciding formulas in the respective theorem prover. Now we discuss work on veri.ed decision procedures \nfor reg\u00adular expressions. The .rst veri.ed equivalence checker for regular expressions was published \nby Braibant and Pous [7]. They worked with automata, not regular expressions, their theory was large \nand their algorithm ef.cient. In response, Krauss and Nipkow [18] gave a much simpler partial correctness \nproof for an equivalence checker for regular expressions based on derivatives. Coquand and Siles [10] \nshowed total correctness of their equivalence checker for extended regular expressions based on derivatives. \nAsperti [2] pre\u00ad sented an equivalence checker for regular expressions via marked regular expressions \n(as previously used by [13]) and showed total correctness. Moreira et al. [20] presented an equivalence \nchecker for regular expressions based on partial derivatives and showed its total correctness. Berghofer \nand Reiter [6] formalized a decision procedure for Presburger arithmetic via automata in Isabelle/HOL. \nOutside of the application area of equivalence checking, Wu et al. [28] bene.ted from the inductive structure \nof regular expres\u00ad sions to formally verify the Myhill-Nerode theorem. 3. Preliminaries Although we formalized \neverything in this paper in the theorem prover Isabelle/HOL [21, 22], no knowledge of theorem provers \nor Isabelle/HOL is required because we employ mostly ordinary mathematical notation in our presentation. \nSome speci.c notations are summarized below. The symbol B represents the type of Booleans, where . and \n1 represent true and false. The type of sets and the type of lists over some type t are written tset \nand tlist. In general, type constructors follow their arguments. The letters a and \u00df represent type variables. \nThe notation t ::t means that term t has type t. Many of our functions are curried. In some cases we \nwrite the .rst argument as an index: instead of f a b we write fa(b) (in preference to just fa b). The \nprojection functions on pairs are called fst and snd. The image of a function f over a set S is written \nf S . Lists are built up from the empty list [ ] via the in.x # operator that prepends an element x to \na list xs: x # xs. Two lists are con\u00adcatenated with the in.x @ operator. Accessing the nth element of \na list xs is denoted by xs[n]; the indexing is zero-based. The length of the list xs is written xs . \nFinite words as in formal language theory are modelled as .nite lists, i.e. type a list. The empty word \nis the empty list. As is customary, concatenation of two words u and v is denoted by their juxtaposition \nuv; similarly for a single letter a of the alphabet and a word w: aw. That is, the operators # and @ \nremain implicit (for words, not for arbitrary lists). 4. Extended Regular Expressions In Section 5, MSO \nformulas are translated into regular expressions such that encodings of models of a formula correspond \nexactly to words in the regular language. Thereby, equivalence of formulas is reduced to the equivalence \nof regular expressions. Decision procedures for equivalence of regular expression have been formalized \nearlier in theorem provers. Here, we extend the existing formalization and the soundness proof in Isabelle/HOL \nby Krauss and Nipkow [18] with negation and intersection operation on regular expressions, as well as \nwith a nonstandard projection operation. Additionally, we provide proofs of termination and com\u00adpleteness. \n 4.1 Syntax and Semantics Regular expressions extended with intersection and complement allow us to encode \nBoolean operators on formulas in a straight\u00adforward fashion. A further operation the projection . plays \nthe crucial role of encoding existential quanti.ers. These .-extended regular expressions (to distinguish \nthem from mere extended reg\u00adular expressions) are de.ned as a recursive data type a RE, where a is the \ntype of the underlying alphabet. In conventional concrete syntax, a RE is de.ned by the grammar r = 0 \n1 a * r +s r \u00b7s r r ns \u00acr . r where r, s ::a RE and a ::a. Note that much of the time we will omit the \n.-extended and simply speak of regular expressions if there is no danger of confusion. We assume that \ntype a is partitioned into a family of alphabets Sn that depend on a natural number n. In our application, \nn will rep\u00adresent the number of free variables of the translated MSO formula. For now Sn is just a parameter \nof our setup. We focus on wellformed regular expressions where all atoms come from the same alphabet \nSn. This will guarantee that the language of such a wellformed expression is a subset of S * n . The \nprojection operation complicates wellformedness a little. Because projection is meant to encode existential \nquanti.ers, projection should transform a regular expression over Sn+1 into a regular expression over \nSn, just as the existential quanti.er transforms a formula with n +1 free variables into a formula with \nn free variables. Thus projection changes the alphabet. Wellformedness is de.ned as the recursive predicate \nwf ::N.a RE .B. wfn(0) =. wfn(1) =. wfn(a) =a .Sn wfn(r +s) =wfn(r) .wfn(s) wfn(r \u00b7s) =wfn(r) .wfn(s) \nwfn(r *) =wfn(r) wfn(r ns) =wfn(r) .wfn(s) wfn(\u00acr) =wfn(r) wfn(. r) =wfn+1(r) We call a regular expression \nr n-wellformed if wfn(r) holds.  The language L::N.a RE .(a list)set of a regular expres\u00adsion is de.ned \nas usual, except for the equations for complement and projection. For an n-wellformed regular expression \nthe de.ni\u00adtion yields a subset of S * n . Ln(0) ={} Ln(1) ={[ ]} Ln(a) ={a} Ln(r +s) =Ln(r) .Ln(s) Ln(r \n\u00b7s) =Ln(r) \u00b7Ln(s) Ln(r *) =Ln(r)* Ln(r ns) =Ln(r) nLn(s) Ln(\u00acr) =S * n \\Ln(r) Ln(. r) =(map p) Ln+1(r) \nThe .rst unusual point is the parametrization with n. It expresses that we expect a regular expression \nover Sn and is necessary for the de.nition Ln(\u00acr) =S * n \\Ln(r). The de.nition Ln(. r)=map p Ln+1(r) \nis parameterized by a function p ::Sn+1 .Sn 1. The projection . denotes the homomor\u00adphic image under \nthis .xed p. In more detail: map lifts p homomor\u00adphically to words (lists), and lifts it to sets of \nwords. Therefore . transforms a language over Sn+1 into a language over Sn. To understand the projection \nterminology, it is helpful to think of elements of Sn as lists of .xed length n over some alphabet S \nand of p as the tail function on lists that drops the .rst element of the list. A word over Sn is then \na list of lists. Though this is a good intuition, the actual encoding of formulas later on will be slightly \nmore complicated. Fortunately we can ignore these complications for now by working with arbitrary but \n.xed Sn and p in the current section. Speci.c instantiations for them are given in Section 5.  4.2 Deciding \nLanguage Equivalence Now we turn our attention to deciding equivalence of .-extended regular expressions. \nThe key concepts required for this are .nality and derivatives. We call a regular expression .nal if \nits language contains the empty word [ ]. Finality can be easily checked syntac\u00adtically by the following \nrecursive function e ::a RE .B. e(0) =1 e(1) = . e(a) =1 e(r +s) = e(r) .e(s) e(r \u00b7s) =e(r) .e(s) e(r \n*) = . e(r ns) =e(r) .e(s) e(\u00acr) = \u00ace(r) e(. r) =e(r) The characteristic property e(r) iff [ ] . Ln(r) \nfor any regular expression r and n .N follows by structural induction on r. The second key concept the \nderivative of a regular expression D::a .a RE .a RE and its lifting to words D* ::a list .a RE . a RE \nsemantically corresponds to left quotients of regular lan\u00adguages with respect to a .xed letter or word. \nJust as before, the recursive de.nition is purely syntactic and the semantic correspon\u00addence is established \nby induction. Db(0) =0 Db(1) =0 Db(a) =if a =b then 1 else 0 Db(r +s) =Db(r) +Db(s) * Db(r \u00b7s) = Db(r \n*) =Db(r) \u00b7r if e(r) then Db(r) \u00b7s +Db(s) else Db(r) \u00b7s Db(r ns) =Db(r) nDb(s) Db(\u00acr) =\u00acDb(r) Db(. r) \n=. ( . Dc(r)) c.p-b D* D* D* [](r) =r bw(r) = w(Db(r)) 1 Due to Isabelle s lack of dependent types the \nactual type of p is a .a. The more re.ned dependent type Sn+1 .Sn is realized via Isabelle s tool for \nmodeling parameterized systems with additional assumptions: locales [4]. A locale .xes parameters and \nstates assumptions about them. Hence, we use the locale assumption p Sn+1 .Sn to relate locale parameters \np and S. Lemma 1. Assume b . Sn, v . S * and let r be an n-wellformed n regular expression. Then Ln(Db(r)) \n= {w bw . Ln(r)} and wfn(Db(r)), and consequently Ln(Dv *(r))={w vw .Ln(r)} and wfn(Dv *(r)). The projection \ncase introduced some new syntax that deserves some explanation. The preimage p- applied to a letter b \n. Sn de\u00adnotes the set {c . Sn+1 p c = b}. Our alphabets Sn are .nite for each n, hence so is the preimage \nof a letter. The summation .over a .nite set denotes the iterated application of the +-constructor of \nregular expressions. Summation over the empty set is de.ned as 0. Derivatives of extended regular expressions \nwere introduced by Brzozowski [8] almost .fty years ago. Our contribution is the extension of the concept \nto handle the projection operation. Since the projection acts homomorphically on words, it is clear that \nthe derivative of . r with respect to a letter b can be expressed as a projection of derivatives of r. \nThe concrete de.nition is a consequence of the following identity of left quotients for b . Sn and A \n.S * n+1: {w bw .map p A} =map p . {w cw .A} c.p-b Although we completely avoid automata in the formalization, \na derivative with respect to the letter b can be seen as a transition labelled by b in a deterministic \nautomaton, the states of which are labelled by regular expressions. The automaton accepting the lan\u00adguage \nof a regular expression r can be thus constructed iteratively by exploring all derivatives of r and de.ning \nexactly those states as accepting, which are labelled by a .nal regular expression. How\u00adever, the set \n{Dw *(r) w ::a list} of states reachable in this man\u00adner is in.nite in general. To obtain a .nite automaton, \nthe states must be partitioned into classes of regular expressions that are ACI\u00adequivalent, i.e. syntactically \nequal modulo associativity, commuta\u00adtivity and idempotence of the +-constructor. Brzozowski showed that \nthe number of such classes for a .xed regular expression r is .nite by structural induction on r. The \ninductive steps require proving .niteness by representing equivalence classes of deriva\u00adtives of the \nexpression in terms of equivalence classes of deriva\u00adtives of subexpressions. This is technically complicated, \nespecially for concatenation, iteration and projection, since it requires a care\u00adful choice representatives \nof equivalence classes to reason about them, and Isabelle s automation can not help much with the .nite\u00adness \narguments indeed the veri.cation of Theorem 2 constitutes the most intricate proof in the present work. \nTheorem 2. {.Dw *(r). w ::a list} is .nite for any regular expres\u00adsion r. The function .-.::a RE .aRE \nis the ACI normalization func\u00adtion, which maps ACI-equivalent regular expressions to the same representative. \nIt is de.ned by means of a normalizing constructor. :: a RE .a RE .a RE and an arbitrary linear order \n. on regular expressions. The equations for .are matched sequentially. .0. = 0 .1. =1 .a. = a .r +s. \n=.r. ..s. .r \u00b7s. = .r. \u00b7.s. .r *. =.r.* .r ns. = .r. n.s. .\u00acr. =\u00ac.r. .. r. = . .r. (r +s) .t = r .(s \n.t) r .(s +t) = if r = s then s +t else if r . s then r +(s +t) else s +(r .t) r .s = if r = s then r \nelse if r . s then r +s else s +r  After the application of .-. all sums in the expression are associated \nto the right and the summands are sorted with respect to. and duplicated summands are removed. From this, \nfurther later on useful properties of .-. can be derived: Lemma 3. Let r be a regular expression, n .N \nand b .Sn. Then Ln.r. =Ln(r), ..r.. =.r. and .Db.r.. =.Db(r).. So far, ACI normalization only connects \nBrzozowski deriva\u00adtives to deterministic .nite automata. Furthermore, it will ensure termination of our \ndecision procedure even without ever entering the world of automata. Instead we follow Rutten [25], who \ngives an alternative view on deterministic automata as coalgebras. In the coalgebraic setting the function \n.r. (e(r), .b. Db(r))::a RE .B\u00d7(a .a RE) is a D-coalgebra for the functor D(S) =B\u00d7(a .S). The .nal coalgebra \nof D exists and corresponds exactly to the set of all languages. Therefore, we obtain the powerful coinduction \nprin\u00adciple, reducing language equality to bisimilarity. We phrase this general theorem instantiated to \nour concrete setting. The formal\u00adized proof itself does not require any category theory; it resembles \nthe reasoning in Rutten [25, \u00a74]. Theorem 4 (Coinduction). Let R ::(a RE \u00d7a RE)set be a relation, such \nthat for all (r, s) .R we have: 1. wfn(r) .wfn(s); 2. e(r) .e(s); 3. (.Db(r)., .Db(s).) .R for all \nb .Sn.  Then for all (r, s) .R, Ln(r) =Ln(s) holds. From Lemma 1 and Lemma 3, we know that the relation \nB={(.Dw *(r).,.Dw *(s).) w .S * n } contains (.r., .s.) and ful.ls the assumptions 1 and 3 of the coin\u00ad \nduction theorem, assuming that r and s are both n-wellformed. Moreover, using Theorem 2 it follows that \nthis relation is .nite. Thus, checking assumption 2 for every pair of this .nite relation is suf.cient \nto prove language equality of r and s by coinduction. We obtain the following abstract speci.cation of \na language equiv\u00adalence checking algorithm. Theorem 5. Let r and s be n-wellformed regular expressions. \nThen ' Ln(r) =Ln(s) iff we have e(r ') .e(s ') for all (r , s ') .B.  4.3 Executable Algorithm from \na Theorem Our goal is not only to prove some abstract theorems about a de\u00adcision procedure, but also \nto extract executable code in some func\u00adtional programming language (e.g. Standard ML, Haskell, OCaml) \nusing the code generation facility of Isabelle/HOL [15]. Theorem 5 is not enough to do so: it contains \na set comprehension ranging over the in.nite set S * n , which is not executable as such. We need to \ninstruct the system how to enumerate B. We start with the pair (.r.,.s.) and compute its pairwise derivatives \nfor all letters of the alphabet. For the computed pairs of regular expressions we proceed by computing \ntheir derivatives and so on. This of course does not terminate. However, if we stop our exploration at \npairs that we have seen before it does, since we are exploring a .nite set. In more detail, we use a \nworklist algorithm that iteratively adds not yet inspected pairs of regular expressions while exhausting \nwords of increasing length until no new pairs are generated. Sat\u00aduration is reached by means of the executable \ncombinator while ::(a .B).(a .a).a .aoption from the Isabelle/HOL library. The option type a option has \ntwo constructors None ::a option and Some ::a .a option. Some lifts elements from the base type a to \nthe option type, while None is usually used to indicate some excep\u00adtional behaviour. The de.nition of \nwhile Least k.\u00acb(c while b c s = if .k.\u00acb(ck(s)) then Some (ck (s))(s)) else None is not executable, \nbut the following key lemma is: while b c s = if b s then while b c (c s) else Some s The code generated \nfrom this recursive equation will return Some s in case the de.nition of while says so, but instead of \nreturning None, it will not terminate. Thus we can prove termination if we can show that the result is \n.None. In our algorithm, the state s of the while loop consists of a work\u00adlist ws ::(a RE \u00d7a RE)list \nof unprocessed pairs of regular expres\u00adsions together with a set N ::(. \u00d7.)set of already seen pairs \nmod\u00adulo a normalization function norm ::a RE ... This normalization function (which is a parameter of \nour setup) is applied to already ACI-normalized expressions, to syntactically identify further lan\u00adguage \nequivalent expressions. This makes the bisimulation relation that must be exhausted smaller, thus saturation \nis reached faster. The range type of the normalization is not .xed, but we require a notion of languages \nL. ::N.. .(a list)set to be available for it, such that L. n(norm r)=Ln(r) holds. In the simplest case \nnorm can be the identity function and L. =L. More interesting is a function on regular expressions that \neliminates 0 from unions, concatena\u00adtions and intersections and 1 from concatenations. Not .xing the \nrange type allows us to use different regular structures such as au\u00adtomata or different types of regular \nexpressions, on which further simpli.cations might be easier. Finally, the functions b ::(a RE \u00d7a RE)list \n\u00d7(. \u00d7.)set .B and c ::N.(a RE \u00d7a RE)list \u00d7(. \u00d7.)set .(a RE \u00d7a RE)list \u00d7(. \u00d7.)set de.ned below are given \nas arguments to while. A well\u00adformedness check completes the now executable algorithm eqv RE :: N.a RE \n.a RE .B. b ([ ], _) =1 b ((r, s) # _, _) = e(r) .e(s) cn ((r, s) # ws, N) = let succs =map (.b. let \n' r =.Db(r). ' s =.Db(s). ' ' in ((r , s '), (norm r , norm s '))) Sn new =remdups snd (.lter (.(_, r \ns). r s .N) succs) in (ws @ map fst new, set (map snd new) .N) eqv RE r s = n wfn(r) .wfn(s) .(case while \nb cn ([(.r., .s.)],{(norm.r.,norm.s.)}) of([ ], _) ..(_ # _, _) .1) The function set ::a list .a set \nmaps a list to the set of its el\u00adements, .lter ::(a .B) .a list .a list removes elements that do not \nful.l the given predicate, while remdups :: (a .\u00df) . a list .a list is used to keep the worklist as small \nas possible. remdups f xs removes duplicates from xs modulo the function f , e.g. remdups snd [(0, 0), \n(1,0)] = [(1, 0)] (which element is actually kept is irrelevant; the result [(0, 0)] would also be valid). \nThe termination of eqv RE for any input is guaranteed by two facts: (1) all recursively de.ned functions \nin Isabelle/HOL termi\u00adnate by their de.nitional principle (either primitive or wellfounded recursion) \nand (2) the termination of while follows from Theorem 2 and the fact that the set N of already seen pairs \nin the state is a sub\u00adset of norm {(.Dw *(r)., .Dw *(s).) w .S * n }.  Theorem 6 (Termination). Let \nr and s be n-wellformed regular expressions. Then while b cn ([(.r., .s.)],{(norm.r.,norm.s.)}) . None. \nFunction eqv RE deserves the name decision procedure since it constitutes the re.nement of the algorithm \nabstractly stated in Theorem 5, and is therefore sound and complete. Theorem 7 (Soundness). Let r and \ns be regular expressions such RE that eqv r s. Then Ln(r) =Ln(s). n Theorem 8 (Completeness). Let r and \ns be n-wellformed regular RE expressions such that Ln(r) =Ln(s). Then eqv r s. n Let us observe the decision \nprocedure at work by looking at the regular expressions a * and 1 +a \u00b7a * for some a .Sn = {a, b} for \nsome n. For presentation purposes, the correspondence of deriva\u00adtives to automata is useful. Figure 1 \nshows two automata, the states of which are equivalence classes of pairs of regular expressions in\u00addicated \nby a dashed fringe (which is omitted for singleton classes). The equivalence classes of automaton (a) \nare modulo plain ACI normalization, while those of automaton (b) are modulo a stronger normalization \nfunction, making the automaton smaller. Transitions correspond to pairwise derivatives and doubled margins \ndenote states for which the associated pairs of regular expressions are pairwise .nal. Both automata \nare the result of our decision pro\u00adcedure performing a breadth-.rst exploration starting with the ini\u00adtially \ngiven pair and ignoring states that are in the equivalence class of already visited states. The absence \nof pairs (r, s) for which r is .nal and s is not .nal (or vice versa) proves the equivalence of all * \npairs in the automaton, including the pair (a , 1 +a \u00b7 in the nameless formula refers to the outermost \n.rst-order quanti\u00ad.er. Inside of the inner second-order quanti.er, index 1 refers to the outermost quanti.er \nand index 0 to the inner quanti.er. The nameless representation simpli.es reasoning by implicitly captur\u00ading \na-equivalence of formulas. On the downside, de Bruijn indices are less readable and must be manipulated \nwith care. Formulas may have free variables. The functions V1 ::a F . Nset and V2 ::a F .Nset collect \nthe free .rst-order and second\u00adorder variables: V1(Q a m) = {m} V2(Q a m) ={} V1(m1 <m2)= {m1, m2} V2(m1 \n<m2)={} V1(m .M) = {m} V2(m .M) ={M} V1(. ..) = V1(.) .V1(.) V2(. ..) =V2(.) .V2(.) V1(. ..) = V1(.) \n.V1(.) V2(. ..) =V2(.) .V2(.) V1(\u00ac.) = V1(.) V2(\u00ac.) =V2(.) V1(..) = .V1(.)\\{0}. V2(..) =.V2(.). V1(. \n.) = .V1(.). V2(. .) =.V2(.)\\{0}. The notation .X. is shorthand for (.x. x -1) X, which reverts the increasing \neffect of an existential quanti.er on previously bound or free variables. To obtain only free variables, \nbound variables are removed when their quanti.er is processed, at which point the bound variable has \nindex 0. Just as for .-extended regular expressions, not all formulas in aF are meaningful. Consider \n0 .0, where 0 is both a .rst-order and F a second-order variable. To exclude such formulas, we de.ne \nthe predicate wfF ::N.a F .Bas wf (.) F =(V1(.)nV2(.) ={}). n F (.) and call a formula . n-wellformed \nif wfn (.) holds. The recursively de.ned predicate pre_wfF ::N.a F .B is used n a *). pre_wf 5. MSO on \nFinite Words for further assumptions on the structure of n-wellformed formulas, Logics on .nite words \nconsider formulas in the context of a formal which will simplify our proofs: word, with variables representing \npositions in the word. In the .rst\u00ad (Q a m) =a .S .m <n (m1 <m2) F n pre_wf order logic on words a variable \nalways denotes a single position, =m1 <n .m2 <n m <n .M <n F n while in monadic second-order logic (MSO) \nvariables come in two pre_wf (m .M)(. ..) F n .avours: .rst-order variables for single positions and \nsecond-order = pre_wf(.) .pre_wf (.)(.) F n FF variables for .nite sets of positions. = pre_wfpre_wf \nn n In the next subsections we .rst de.ne the syntax of formulas and (. ..)(\u00ac.) (.) .pre_wf n n F n FF \n= pre_wfpre_wf give them a semantics that is related to formal languages: M2L(Str). The second semantics, \nWS1S, is then introduced as a relaxation of F F (.) n+1(.) .0 .V1(.) .0 .V2(.) n+1(.) .0 .V1(.) .0 .V2(.) \nF n F = pre_wfpre_wf n (..)(. .) F n = = pre_wfpre_wf M2L (we drop the (Str) from now on). Both semantics \nare equally F n expressive and deciding both is of nonelementary complexity. The pre_wf pre_wf bene.ts \nand drawbacks of the two semantics are discussed else\u00ad(.) ensures that the index of every free variable \nin . is F pre_wf where [3, 17]. below n and the values of type a come from a .xed alphabet S. n 5.1 \nSyntax and M2L Semantics MSO formulas are syntactically represented by the recursive data type a F using \nde Bruijn indices for variable bindings. Terms of a F are generated by the grammar . = Q am m1 <m2 m \n.M . .. . .. \u00ac... . . where .,. ::a F, m, m1,m2, M .N and a .a. Lower-case variables m,m1, m2 denote \n.rst-order variables, M denotes a second order variable. The atomic formula Q a m requires the letter \nof the word at the position represented by variable m to be a; the constructors < and . compare positions; \nBoolean operators are interpreted as usual. The bold existential quanti.er . binds second-order variables,. \nbinds .rst-order variables. Occurrences of bound variables rep\u00adresented as de Bruijn indices refer to \ntheir binders by counting the number of nested existential quanti.er between the binder and the occurrence. \nFor example, the formula .(Q a 0 .(. 1 .0)) corre\u00adsponds to .x.(Q a x .(.X. x .X)) when using names. \nThe .rst 0 Note that S is really just a .xed set of letters of type a, independent of any n and is a \nparameter of our setup. Moreover, pre_wfF checks that bound variables are correctly used as .rst-order \nor second\u00adorder with respect to their binders and excludes formulas with unused binders; unused binders \nare obviously super.uous. An interpretation of an MSO formula is a pair of a word w :: a list from S \n* and an assignment I ::(N+Nset)list for free vari\u00adables. The latter essentially consists of two functions \nwith .nite do\u00admain: one from .rst-order variables to positions and the other from second-order variables \nto sets of positions. We represent those two functions by a list, once again bene.ting from de Bruijn \nindices the value lookup for a variable with de Bruijn index i corresponds to inspecting the assignment \nI at position i, i.e. I[i]. The range of I is a sum type, denoting the disjoint union of its two argu\u00adment \ntypes. The sum type has two constructors Inl ::a .a +\u00df and Inr ::\u00df .a +\u00df, such that for a .rst-order \nvariable m there is a posi\u00adtion p with I[m] =Inl p and for a second-order variable M there is a .nite \nset of positions P with I[M] =Inr P. An interpretation that satis.es a formula is called a model. Satis.ability \nfor M2L, denoted by in.x .::alist\u00d7(N+Nset)list .  Da  (b) norm unfolds 0 +r =r, 0 \u00b7r =0 and 1 \u00b7r =r \nFigure 1. Checking the equivalence of a * and 1 +a \u00b7a * for Sn ={a, b} aF .B, is de.ned recursively on \naF. To simplify the notation, the sum constructors Inl and Inr are stripped implicitly in the de.nition. \n(w, I) .Q a m .w[I[m]] =a (w, I) .m1 <m2 .I[m1] <I[m2] (w, I) .m .M .I[m] .I[M] (w, I) .. .. .(w, I) \n.. .(w, I) .. (w, I) .. .. .(w, I) .. .(w, I) .. (w, I) .\u00ac. .(w, I) /.. (w, I) ... ..p . {0, . .. , w \n-1}. (w, Inl p # I) .. (w, I) .. . ..P .{0, . .. , w -1}. (w, Inr P # I) .. For the de.nition to make \nsense, I must correctly map .rst-order variables to positions (i.e. I[m]=Inl p) and second-order variables \nto sets of positions (i.e. I[M]=Inr P). Furthermore, all positions inI should be below the length of \nthe word, and for technical reasons the word should not be empty. We formalize these assumptions by the \npredicate wfM2L ::a F .a list \u00d7(N+Nset)list .Band call an interpretation M2L-wellformed for . if wfM2L \n. (w, I) holds: wfM2L (w, I) = . w .[] .w .S *. .Inl p .set I. p < w . .Inr P .set I. (.p .P. p < w ) \n. .m .V1(.) (.p. I[m] = Inl p) . .M .V2(.) (.P. I[M] =Inr P)  5.2 WS1S Semantics In an M2L-wellformed \nmodel, positions are restricted by the length of the word. This is the key difference compared to WS1S. \nIn WS1S no a priori restrictions on the variable ranges are made, although all second-order variables \nstill represent .nite sets. The subtle difference is illustrated by the formula . (.0 .1) (with names: \n.X..x. x .X), where .. is just an abbreviation for \u00ac.\u00ac.. In the M2L semantics . (.0 .1) is satis.ed by \nall wellformed interpretations the witness set for the outer existential quanti.er is for a wellformed \ninterpretation (w, I) just the set {0, ... , w -1}. In contrast, in WS1S, there is no .nite set which \ncontains all arbitrarily large positions, thus . (.0 .1) is unsatis.able. Formally, satis.ability for \nWS1S, denoted by in.x ..::a list \u00d7(N+Nset)list .a F .B, is de.ned just as for M2L (replacing . by ..) \nexcept for the following equations. (w, I) ..Q a m.(if I[m] < w then w[I[m]] else z) =a (w, I) .... ..p. \n(w, Inl p # I) ... (w, I) ... . ..P. (w, Inr P # I) ... ..nite P Here, z is a distinguished letter from \nS. WS1S as de.ned in the literature does not handle the Q a m case at all, usually interpreting formulas \nonly with respect to the assignment I. In order to be able to use the same syntax and the same type of \ninterpretations for both semantics, we have made the above choice. This also allows us to translate Q \na m into the same regular expression irrespective of the intended semantics. Besides the mentioned relaxation \nof WS1S-wellformedness with respect to variable ranges, the empty word does not impose tech\u00adnical complications \nas in M2L. Therefore, the predicate wfWS1S :: a F .a list \u00d7(N+Nset)list .Bis de.ned as follows. wfWS1S \n. (w, I) = w .S *. .Inr P .set I. .nite P . .m .V1(.) (.p. I[m] = Inl p) . .M .V2(.) (.P. I[M] =Inr P) \n 5.3 Encoding Interpretations as Words Formulas are equivalent if they have the same set of wellformed \nmodels. To relate equivalent formulas with language equivalent regular expressions, the set of wellformed \nmodels must be repre\u00adsented as a formal language by encoding interpretations as words. As before, we \ncover the encoding of the M2L semantics .rst. To simplify the formalization, we choose a very simple \nencod\u00ading using Boolean vectors. For an interpretation (w, I), we asso\u00adciate with every position p in \nthe word w a Boolean vector bs of length I , such that bs[m]=.iff the mth variable in I is .rst-order \nand its value is p or it is second-order and its value contains p. For example, for S ={a, b} the interpretation \n(w, I)=(aba, Inl 0 # Inr {1,2} # Inl 2 # []) can be written in two dimensions as follows: a b a Inl 0 \n. 1 1 Inr {1,2} 1 . . Inl 2 1 1 . In the .rst row, the value . is placed only in the .rst column because \nthe .rst variable of I is the .rst-order position 0. In general, the columns correspond to the Boolean \nvectors associated with positions in the word, while every row corresponds to one variable. For .rst-order \nvariables there must be exactly one . per row. The .rst row encodes the value of the most recently bound \nvariable. Now, we consider every column as a letter of a new alphabet, which is the underlying alphabet \nSn =S \u00d7Bn of regular expressions of Section 4. This transformation of interpretations into words over \nSn is performed by the function enc M2L ::a list \u00d7(N+Nset)list .(a \u00d7Blist)list; we omit its obvious de.nition. \n Furthermore, the second parameter p ::Sn+1 .Sn of our deci\u00adsion procedure for regular expressions can \nnow be instantiated as the function that maps (a, b # bs) to (a, bs). Thus, the projection . operates \non words by removing the .rst row from words in the language of the body expression, re.ecting the semantics \nof an ex\u00adistential quanti.er. Below we use a more visually appealing notation for elements of Sn. E.g. \n(a, .# 1# 1# []) is written as ( a .11). Finally, the M2L-language LM2L ::N.a F .(a \u00d7Blist)set of an \nMSO formula is the set of encodings of its wellformed models, M2L(w, I) wfM2L i.e. LM2L n (.) ={enc . \n(w, I) . I =n .(w, I) ..}. Concerning WS1S, the encoding is slightly more compli\u00adcated due to the following \nobservation: Interpretations (w, I) and n (wz , I) for all n . N behave the same when considering satis.\u00adability \nand wellformedness with respect to a formula (z n denotes n-fold repetition of the letter z as a word). \nThat suggests that the example interpretation (w, I) =(aba, Inl 0 # Inr {1, 2} # Inl 2 # []) from above \ncan be encoded as a b a z m Inl 0 . 1 1 1m Inr {1, 2} 1 . . 1m Inl 2 1 1 . 1m for every m . N. Hence, \nthe a single WS1S interpretation is translated into a countably in.nite set of words by a function WS1S \nenc :: a list \u00d7(N+Nset) list .(a \u00d7Blist)list set; we again omit its formal de.nition. Accordingly, the \nWS1S-language LWS1S :: N .a F .(a \u00d7Blist) set of an MSO formula is de.ned by taking the union of all \nencodings of its wellformed models: LWS1S M2L(w, I) wfWS1S n (.) =.{enc . (w, I) . I =n .(w, I) ...}. \n 5.4 From Formulas to Regular Expressions MSO formulas interpreted in M2L are translated into regular \nex\u00adpressions by means of the primitive recursive function mkREM2L :: N.a F .a RE (see Figure 2). The \nnatural number parameter of mkREM2L indicates the number for free variables for the processed formula. \nThe parameter is increased when entering recursively the scope of an existential quanti.er. In general, \nthe abbreviation . X. /.. /.. /.. /. . .  . . m n-m-1 actually denotes the huge summation a .( ). a.X \nb0 .bm-1 .bm+1 .bn-1 bi .{., } i.{0,...,m-1,m+1,..,n-1} The intuition behind the translation is demonstrated \nby the case Q a m. We .x a wellformed model (w,I) of Q a m. (w, I) must satisfy w[I[m]] = a, or equivalently \nthe fact that there exists a M2L(w, I)[I[m]] = Boolean vector bs of length n such that enc(a, bs) and \nbs[m] = .. Therefore, the letter at position I[m] of enc M2L(w, I) is matched by the middle part of mkREM2L \nn (Q a m), while the subexpressions \u00ac0 (which denotes S * n ) match the .rst M2L(w, I). I[m] and the \nlast n -I[m] letters of enc Conversely, if we .x a word from mkREM2L n (Q a m), it will be equal to an \nencoding of an interpretation that satis.es Q a m by a similar argument. However, the interpretation \nmight be not wellformed for Q a m. This happens because the regular expression mkREM2L n (Q a m) does \nnot capture the distinction between .rst\u00adorder and second-order variables, such that it accepts encodings \nof interpretations that have the value .more than once at different positions representing the same .rst-order \nvariable. This indicates that the subexpressions \u00ac0 in the base cases are not precise enough, but also \nin the case of Boolean operators similar issues arise. So instead of tinkering with the base cases, it \nis better to separate the generation a regular expression that encodes models from the one that encodes \nwellformed interpretations. To rule out not wellformed interpretations is exactly the pur\u00adpose of the \nWF ::N.a F .a RE function. The regular expres\u00adsion WFn(.) (see Figure 2) accepts exactly the encodings \nof well\u00adformed interpretations (both models and non-models) for . by en\u00adsuring that .rst-order variables \nare encoded correctly. Lemma 9. Let . be an n-wellformed formula. Then WS1S(w, I) wfWS1S Ln(WFn(.)) \n={enc . (w, I). I =n}, and M2L(w, I) wfM2L  Ln(WFn(.))\\{[]} ={enc . (w, I). I =n}.  Using WF in every \ncase of the recursive de.nition of mkREM2L is very redundant it is enough to perform the intersection \nonce globally for the entire formula and additionally for every existential quanti.er. MSO formulas interpreted \nin WS1S are translated into regular expressions by means of the function mkREWS1S ::N.aF .a RE. The de.nition \nof mkREWS1S coincides with the one of mkREM2L except for the existential quanti.er cases: z . mkREWS1S \nQ. .(. (mkREWS1S n (..) = n+1 (.) nWFn+1(.))) .1n z . mkREWS1S Q. .(. (mkREWS1S (. .) = n+1 (.) nWFn+1(.))) \nn .1n The regular operation Q::a \u00d7Blist .a RE .a RE reestablishes m the invariant of having all words \nterminated with a suf.x (1z n) for every m . N in the WS1S language encoding of a formula as required \nby de.nition of enc WS1S (this invariant might be violated by the projection). More precisely, the following \nlanguage identity holds for an n-wellformed regular expression r: m Ln(Qa r) ={xa m .N..l. xa l .Ln(r)} \nWe do not show the concrete executable de.nition of Q which can be found in our formalization. On a high-level, \nQis computed by repeatedly deriving from the right by a (dual to Da which derives from the left). The \ntermination of the repeated derivation is established by the dual of Theorem 2 for ACI-equivalent right \nderivatives . Finally, we can establish the language correspondence between formulas and generated regular \nexpressions. Theorem 10. Let . be an n-wellformed formula. Then LWS1S (mkREWS1S n (.) =Ln n (.) nWFn(.)), \nand LM2L (.) =Ln(mkREM2L (.) nWFn(.))\\{[]}. n n The proof is by structural induction on .. Above we have \nseen the argument for the base case Q a m, other base cases follow simi\u00adlarly. The cases .. and . . follow \neasily from the semantics of . given by our concrete instantiation for p and Sn and the induc\u00ad  . {a} \n. mkREM2L(Q a m) = \u00ac0 \u00b7 /.. /. . /.. /. \u00b7\u00ac0 n . . . . m n-m-1 . S . . S . mkREM2L(m1 <m2) = \u00ac0 \u00b7 /.. \n/. . /.. /. \u00b7\u00ac0 \u00b7 /.. /. . /.. /. \u00b7\u00ac0 n . . . . . .. . m1 n-m1 -1 m2 n-m2-1 . S . mkREM2L(m .M) = \u00ac0 \n\u00b7 /.. /. . /.. /. . /.. /. \u00b7\u00ac0 n . . . . min m M max m M-min m M-1 n-max m M-1 mkREM2L n (. ..) = mkREM2L \nn (.) nmkREM2L n (.) mkREM2L n (. ..) = mkREM2L n (.) +mkREM2L n (.) mkREM2L n (\u00ac.) = \u00acmkREM2L n (r) \nmkREM2L n (..) . (mkREM2L = n+1(.) nWFn+1(.)) mkREM2L n (. .) . (mkREM2L = n+1(.) nWFn+1(.)) * * . S \n. . S . . S . WFn(.) = . /.. /. 1 /.. /. \u00b7 /.. /. . /.. /. \u00b7 /.. /. 1 /.. /. . . . . . . m.V1(.) . \n.. .. . m n-m-1 m n-m-1 m n-m-1 Figure 2. De.nition of mkREM2L and WF tion hypothesis. The most interesting \ncases are, somehow unex\u00adpectedly, those for Boolean operators. Although the de.nitions are purely structural, \nsets of encodings of models must be composed or, even worse, complemented in the inductive steps. The \nkey prop\u00aderty required here is that enc M2L (and enc WS1S ) do not collapse mod\u00adels and non-models: two \ndifferent wellformed interpretations for a formula one being a model, the other being a non-model are \nen\u00adcoded into different words (sets of words). This is again established by structural induction on formulas \nfor both semantics. Lemma 11. Let (w1, I1) and (w2, I2) be two M2L-wellformed M2L(w1, I1) M2L(w2, I2). \ninterpretations for . such that enc = enc Then (w1, I1) .. .(w2, I2) ... Lemma 12. Let (w1, I1) and (w2, \nI2) be two WS1S-wellformed WS1S(w1, I1) WS1S(w2, I2). interpretations for . such that enc = enc Then \n(w1, I1) ... .(w2, I2) ....  5.5 Deciding Language Equivalence of Formulas M2L ::N.a F .a F .B and eqv \nWS1S ::N . The algorithms eqv a F .a F .Bthat decide language equivalence of MSO formulas check wellformedness \nof the input formulas, translate the formulas into regular expressions and let eqv RE do the work: eqv \nM2L . . = n F wfn (. ..) . RE eqvn (mkREM2L n (.) +1) (mkREM2L n (.) +1) eqv WS1S . . = n F wfn (. ..) \n. RE (mkREWS1S(.)) (mkREWS1S eqv n n (.)) n Note that wellformedness is checked on the disjunction of \nboth formulas to ensure that they agree on free variables (i.e. no .rst\u00adorder free variable of . is used \nas a second-order free variable in . and vice versa). Further, we add the empty word into both regular \nexpression when working with the M2L semantics. This is allowed, since [] is not a valid encoding of \nan interpretation, and necessary because Theorem 10 does not give us any information whether the empty \nword is contained in the output of mkREM2L or not. Termination of eqv RE is ensured by Theorem 6 and \nthe de.nition principle of primitive recursion for wfF , mkREM2L and mkREWS1S . Soundness and completeness \nfollow easily from Theorems 7, 8 and 10. Theorem 13 (Soundness). Let . and . be MSO formulas. M2L LM2L \nIf eqv . ., then Ln M2L (.) = n (.). n WS1S LWS1S If eqv . ., then Ln WS1S(.) = n (.). n Theorem 14 (Completeness). \nLet . .. be an n-wellformed MSO formula. If LM2L LM2L M2L n (.) = n (.), then eqv . .. n If LWS1S LWS1S \nWS1S n (.) = n (.), then eqv . .. n 6. Application: Finite-Word LTL We want to execute the code generated \nby Isabelle/HOL for our decision procedures on some larger examples. For simplicity, we focus on M2L. \nIn order to create larger formulas, it is helpful to introduce some syntactic abbreviations. We de.ne \nthe unsatis.able formula 1 as.0 <0 and the valid formula . as \u00ac1 . Now, checking that a formula is valid \namounts to checking its equivalence to . . Implication . .. is de.ned as (\u00ac.).. and universal quanti.cation \n.. as before as \u00ac.\u00ac.. Next, we introduce temporal logical operators always .P ::N .a F and eventually \n.P ::N .a F depending on P :: N .a F a formula parameterized by a single variable indicating the time. \nThe operators have their usual meaning except that with the given M2L semantics the time variable ranges \nover a .xed set determined by the interpretation. Additionally, we lift the disjunction and implication \nto time-parameterized formulas.  .P t = .(\u00act +1 <0.P 0) .P t = .(\u00act +1 <0 .P 0)(P .Q) t = P t .Q t (P \n.Q) t = P t .Q t Note that t +1 has nothing to do with the next time step. It is just the lifting of \nthe de Bruijn index under a single quanti.er. Further, formulas of linear temporal logic contain atomic \npred\u00adicates for which the interpretation must specify at which points in time they are true. This information \ncan be encoded in two ways, which we compare in the following. The .rst possibility is to encode atomic \npredicates in the word of the interpretation. This is done by identifying S with the powersetP of atomic \npredicates. For every point in time, that is for every position in the word, the letter is the set of \npredicates that are true at this point. Using this encoding we can prove the validity of the following \nclosed formulas over the alphabet P{P} = {{P}, {}} automatically within a few milliseconds. .(.(Q{P}) \n..(Q{P})) 0 .(.(Q{P}) ...(Q{P})) 0 Alternatively, a free second-order variable can be used to encode \nan atomic predicate directly. The variable denotes the set of points in time for which the atomic predicate \nholds. The alphabet S can then be trivial, i.e. S ={a} for an arbitrary a. Using this encoding the above \ntwo formulas correspond to .(.(.t. t .2) ..(.t.t .2)) 0 .(.(.t. t .2) ...(.t.t .3)) 0 Both formulas have \none free second-order variable 0 that is lifted when passing two or three quanti.ers. The generated algorithm \nshows the equivalence to . again within milliseconds. In order to explore the limits of our decision \nprocedure, formu\u00adlas over more atomic predicates are required. Therefore, we con\u00adsider the distributivity \ntheorems of . over implication for both representations of atomic predicates as shown in Figure 3. When \nthe number of predicates n is increased, the size of .n grows ex\u00adponentially: to express that a predicate \nP holds at some position we need the disjunction of all atoms containing P. In contrast, the size of \n.n grows linearly. The complexity of .n is hidden in its encoding the latter also grows exponentially \nwith increasing n. The running times of the decision procedure are summarized in Figure 4. Thereby, .1, \n.2 and .3 were processed over S ={a}, .1 was processed over S =P{P}, .2 over S =P{P1, P2} and .nally \n.3 over S = P{P1, P2, P3}. Figure 4 also shows the sizes of the generated regular expressions. Both size \nand sizelen count the con\u00adstructors in a regular expression. The difference is that the size of an atom \nis 1 whereas the sizelen of an atom is the length of its Boolean vector. The attentive reader will have \nnoticed that we have said nothing about how sets are represented in the code generated from our mathematical \nde.nitions. We have chosen an existing veri.ed red black tree implementation for our measurements. Isabelle \ns code generator supports the transparent replacement of sets by some veri.ed implementation [14]. The \nperformance of our automatically generated code may ap\u00adpear disappointing but that would be a misunderstanding \nof our in\u00adtentions. We see our work primarily as a succinct and elegant func\u00adtional program that may \npave the way towards veri.ed and ef.cient decision procedures. As a bonus, the generated code is applicable \nto small examples. In the context of interactive theorem proving, this is primarily what one encounters: \nsmall formulas. Any automation is welcome here because it saves the user time and effort. Auto\u00admatic \nveri.cation of larger systems is the domain of highly tuned implementations such as MONA. 7. Conclusion \nWe have presented functional programs that decide equivalence of MSO formulas for two different semantics \nin Isabelle/HOL. They come with formal proofs of termination, soundness and com\u00adpleteness. The programs \noperate by translating formulas into .\u00adextended regular expressions and deciding the language equiva\u00adlence \nof the latter using Brzozowski derivatives. Although formal\u00adized in Isabelle/HOL s functional programming \nlanguage, we can automatically generate code from them in different functional tar\u00adget languages. The \ndevelopment amounts to roughly 350 lines of functional programs and 5000 lines of proofs, of which 2100 \nlines are devoted to deciding equivalence of .-extended regular expres\u00adsions. For M2L, the program is \ncompletely contained in this paper. The Isabelle scripts are publicly available [27]. Our work can be \ncontinued in two dimensions. First, the algo\u00adrithm is not optimized. Especially the encoding of interpretations \nas Boolean vectors leaves room for improvement. Second, several related decidable logics can be formalized \nand veri.ed using similar technology. A related logic is MSO on in.\u00adnite words (also called S1S). S1S \nformulas can be translated into .-regular expressions representing .-regular languages. A veri.ed decision \nprocedure for deciding equivalence of .-regular expres\u00adsions without constructing .-automata is an interesting \nchallenge. An even more distant goal is to move from words to trees (or even from .-words to .-trees) \nand decide equivalence of MSO formulas on (in).nite trees (or alternatively (W)S2S formulas) by translating \nthem into (.-)regular tree expressions. Acknowledgments We thank Alexander Krauss for inspiring discussions \nand Jasmin Christian Blanchette for numerous comments on the presentation. Comments and questions of \nfour anonymous reviewers helped to clarify certain .ne points. The .rst author s research is sup\u00adported \nby the doctorate program 1480 (PUMA) of the Deutsche Forschungsgemeinschaft (DFG). References [1] V. \nAntimirov. Partial derivatives of regular expressions and .nite automaton constructions. Theor. Comput. \nSci., 155(2):291 319, Mar. 1996. [2] A. Asperti. A compact proof of decidability for regular expression \nequivalence. In L. Beringer and A. Felty, eds., Interactive Theorem Proving, ITP 2012, vol. 7406 of LNCS, \npp. 283 298. Springer, 2012. [3] A. Ayari and D. Basin. Bounded model construction for monadic second-order \nlogics. In E. A. Emerson and A. P. Sistla, eds., Proc. Int. Conf. Computer Aided Veri.cation, CAV 2000, \nvol. 1855 of LNCS, pp. 99 112. Springer, 2000. [4] C. Ballarin. Interpretation of locales in Isabelle: \nTheories and proof contexts. In J. M. Borwein and W. M. Farmer, eds., Mathematical Knowledge Management, \nMKM 2006, vol. 4108 of LNCS, pp. 31 43. Springer, 2006. [5] D. Basin and S. Friedrich. Combining WS1S \nand HOL. In D. Gabbay and M. de Rijke, eds., Frontiers of Combining Systems 2, vol. 7 of Studies in Logic \nand Computation, pp. 39 56. Research Studies Press/Wiley, 2000. [6] S. Berghofer and M. Reiter. Formalizing \nthe logic-automaton connection. In S. Berghofer, T. Nipkow, C. Urban, and M. Wenzel, eds., Theorem Proving \nin Higher Order Logics, TPHOLs 2009, vol. 5674 of LNCS, pp. 147 163. Springer, 2009.  .1 =.(.(Q{P}) \n..(Q{P})) 0 .1 =.(.(.t. t .2) ..(.t. t .2)) 0 .2 =.(.(.t. t .2 .t .3) ..(.t.t .2) ..(.t. t .3)) 0 .3 \n=.(.(.t. t .2 .t .3 .t .4) ..(.t.t .2)..(.t. t .3) ..(.t. t .4)) 0 Figure 3. De.nition of .n and .n \nTime to prove .n Time to prove .n size (mkREM2L(.n)) size (mkREM2L(.n)) sizelen (mkREM2L(.n)) sizelen \n(mkREM2L(.n)) 0 n 0 n n=1 2ms 2ms 262 262 330 404 n=2 2s 2s 741 960 949 1370 n=3 81min 44min 1920 1836 \n2480 4148 Figure 4. Comparison of .n and .n in the M2L semantics [7] T. Braibant and D. Pous. An ef.cient \nCoq tactic for deciding Kleene algebras. In M. Kaufmann and L. Paulson, eds., Interactive Theorem Proving, \nITP 2010, vol. 6172 of LNCS, pp. 163 178. Springer, 2010. [8] J. A. Brzozowski. Derivatives of regular \nexpressions. J. ACM, 11(4):481 494, Oct. 1964. [9] P. Caron, J.-M. Champarnaud, and L. Mignot. Partial \nderivatives of an extended regular expression. In A.-H. Dediu, S. Inenaga, and C. Mart\u00edn-Vide, eds., \nProc. Int. Conf. Language and Automata Theory and Applications, LATA 2011, vol. 6638 of LNCS, pp. 179 \n191. Springer, 2011. [10] T. Coquand and V. Siles. A decision procedure for regular expression equivalence \nin type theory. In J.-P. Jouannaud and Z. Shao, eds., Proc. Int. Conf. Certi.ed Programs and Proofs, \nCPP 2011, vol. 7086 of LNCS, pp. 119 134. Springer, 2011. [11] N. A. Danielsson. Total parser combinators. \nIn P. Hudak and S. Weirich, eds., Proc. Int. Conf. Functional Programming, ICFP 2010, pp. 285 296. ACM, \n2010. [12] J. Elgaard, N. Klarlund, and A. M\u00f8ller. MONA 1.x: new techniques for WS1S and WS2S. In A. \nJ. Hu and M. Y. Vardi, eds., Proc. Int. Conf. Computer Aided Veri.cation, CAV 1998, vol. 1427 of LNCS, \npp. 516 520. Springer, 1998. [13] S. Fischer, F. Huch, and T. Wilke. A play on regular expressions: functional \npearl. In P. Hudak and S. Weirich, eds., Proc. Int. Conf. Functional Programming, ICFP 2010, pp. 357 \n368. ACM, 2010. [14] F. Haftmann, A. Krauss, O. Kun. car, and T. Nipkow. Data re.nement in Isabelle/HOL. \nIn S. Blazy, C. Paulin-Mohring, and D. Pichardie, eds., Interactive Theorem Proving, ITP 2013, vol. 7998 \nof LNCS, pp. 100 115. Springer, 2013. [15] F. Haftmann and T. Nipkow. Code generation via higher-order \nrewrite systems. In M. Blume, N. Kobayashi, and G. Vidal, eds., Functional and Logic Programming, FLOPS \n2010, vol. 6009 of LNCS, pp. 103 117. Springer, 2010. [16] J. G. Henriksen, J. L. Jensen, M. E. J\u00f8rgensen, \nN. Klarlund, R. Paige, T. Rauhe, and A. Sandholm. MONA: Monadic second-order logic in practice. In E. \nBrinksma, R. Cleaveland, K. Larsen, T. Margaria, and B. Steffen, eds., Tools and Algorithms for the Construction \nand Analysis of Systems, TACAS 1995, vol. 1019 of LNCS, pp. 89 110. Springer, 1995. [17] N. Klarlund. \nA theory of restrictions for logics and automata. In N. Halbwachs and D. Peled, eds., Proc. Int. Conf. \nComputer Aided Veri.cation, CAV 1999, vol. 1633 of LNCS, pp. 406 417. Springer, 1999. [18] A. Krauss \nand T. Nipkow. Proof pearl: Regular expression equivalence and relation algebra. J. Automated Reasoning, \n49:95 106, 2012. published online March 2011. [19] M. Might, D. Darais, and D. Spiewak. Parsing with \nderivatives: A functional pearl. In M. M. T. Chakravarty, Z. Hu, and O. Danvy, eds., Proc. Int. Conf. \nFunctional Programming, ICFP 2011, pp. 189 195. ACM, 2011. [20] N. Moreira, D. Pereira, and S. M. de \nSousa. Deciding regular expressions (in-)equivalence in Coq. In W. Kahl and T. Grif.n, eds., Relational \nand Algebraic Methods in Computer Science, RAMiCS 2012, vol. 7560 of LNCS, pp. 98 113. Springer, 2012. \n[21] T. Nipkow. Programming and proving in Isabelle/HOL. http://isabelle.in.tum.de/doc/prog-prove.pdf. \n[22] T. Nipkow, L. Paulson, and M. Wenzel. Isabelle/HOL A Proof Assistant for Higher-Order Logic, vol. \n2283 of LNCS. Springer, 2002. [23] S. Owens, J. H. Reppy, and A. Turon. Regular-expression derivatives \nre-examined. J. Funct. Program., 19(2):173 190, 2009. [24] S. Owre and H. Rue\u00df. Integrating WS1S with \nPVS. In E. A. Emerson and A. P. Sistla, eds., Proc. Int. Conf. Computer Aided Veri.cation, CAV 2000, \nvol. 1855 of LNCS, pp. 548 551. Springer, 2000. [25] J. J. M. M. Rutten. Automata and coinduction (an \nexercise in coalgebra). In D. Sangiorgi and R. de Simone, eds., Proc. Int. Conf. Concurrency Theory, \nCONCUR 1998, vol. 1466 of LNCS, pp. 194 218. Springer, 1998. [26] W. Thomas. Languages, automata, and \nlogic. In G. Rozenberg and A. Salomaa, eds., Handbook of Formal Languages, pp. 389 455. Springer, 1997. \n[27] D. Traytel and T. Nipkow. Formal development associated with this paper. http://www21.in.tum.de/~traytel/icfp13_mso.tar.gz. \n[28] C. Wu, X. Zhang, and C. Urban. A formalisation of the Myhill Nerode theorem based on regular expressions \n(Proof pearl). In M. Eekelen, H. Geuvers, J. Schmaltz, and F. Wiedijk, eds., Interactive Theorem Proving, \nITP 2011, vol. 6898 of LNCS, pp. 341 356. Springer, 2011.   \n\t\t\t", "proc_id": "2500365", "abstract": "<p>Monadic second-order logic on finite words (MSO) is a decidable yet expressive logic into which many decision problems can be encoded. Since MSO formulas correspond to regular languages, equivalence of MSO formulas can be reduced to the equivalence of some regular structures (e.g. automata). This paper presents a verified functional decision procedure for MSO formulas that is not based on automata but on regular expressions. Functional languages are ideally suited for this task: regular expressions are data types and functions on them are defined by pattern matching and recursion and are verified by structural induction.</p> <p>Decision procedures for regular expression equivalence have been formalized before, usually based on Brzozowski derivatives. Yet, for a straightforward embedding of MSO formulas into regular expressions an extension of regular expressions with a projection operation is required. We prove total correctness and completeness of an equivalence checker for regular expressions extended in that way. We also define a language-preserving translation of formulas into regular expressions with respect to two different semantics of MSO. Our results have been formalized and verified in the theorem prover Isabelle. Using Isabelle's code generation facility, this yields purely functional, formally verified programs that decide equivalence of MSO formulas.</p>", "authors": [{"name": "Dmitriy Traytel", "author_profile_id": "81501682166", "affiliation": "Technische Universit&#228;t M&#252;nchen, Munich, Germany", "person_id": "P4261203", "email_address": "traytel@in.tum.de", "orcid_id": ""}, {"name": "Tobias Nipkow", "author_profile_id": "81100147685", "affiliation": "Technische Universit&#228;t M&#252;nchen, Munich, Germany", "person_id": "P4261204", "email_address": "nipkow@in.tum.de", "orcid_id": ""}], "doi_number": "10.1145/2500365.2500612", "year": "2013", "article_id": "2500612", "conference": "ICFP", "title": "Verified decision procedures for MSO on words based on derivatives of regular expressions", "url": "http://dl.acm.org/citation.cfm?id=2500612"}