{"article_publication_date": "09-25-2013", "fulltext": "\n C-SHORe A Collapsible Approach to Verifying Higher-Order Programs Christopher Broadbent LIAFA, Universit \n\u00b4e Paris Diderot Paris 7 &#38; CNRS &#38; University of Tokyo &#38; Technische Universit \u00a8at M\u00a8unchen \nbroadben@in.tum.de Arnaud Carayol LIGM, Universit \u00b4e Paris-Est &#38; CNRS arnaud.carayol@univ-mlv.fr \nOlivier Serre LIAFA, Universit \u00b4e Paris Diderot Paris 7 &#38; CNRS olivier.serre@liafa.univ-paris-diderot.fr \nMatthew Hague Royal Holloway University of London &#38; LIGM, Universit \u00b4e Paris-Est &#38; LIAFA, Universit \n\u00b4e Paris Diderot Paris 7 &#38; CNRS matthew.hague@rhul.ac.uk Abstract Higher-order recursion schemes \n(HORS) have recently received much attention as a useful abstraction of higher-order functional programs \nwith a number of new veri.cation techniques employ\u00ading HORS model-checking as their centrepiece. This \npaper con\u00adtributes to the ongoing quest for a truly scalable model-checker for HORS by offering a different, \nautomata theoretic perspective. We introduce the .rst practical model-checking algorithm that acts on \na generalisation of pushdown automata equi-expressive with HORS called collapsible pushdown systems (CPDS). \nAt its core is a substantial modi.cation of a recently studied saturation algo\u00adrithm for CPDS. In particular \nit is able to use information gath\u00adered from an approximate forward reachability analysis to guide its \nbackward search. Moreover, we introduce an algorithm that prunes the CPDS prior to model-checking and \na method for extracting counter-examples in negative instances. We compare our tool with the state-of-the-art \nveri.cation tools for HORS and obtain encour\u00adaging results. In contrast to some of the main competition \ntack\u00adling the same problem, our algorithm is .xed-parameter tractable, and we also offer signi.cantly \nimproved performance over the only previously published tool of which we are aware that also enjoys this \nproperty. The tool and additional material are available from http://cshore.cs.rhul.ac.uk. Categories \nand Subject Descriptors F.1.1 [Models of Computa\u00adtion]: Automata Keywords Higher-Order; Veri.cation; \nModel-Checking; Recur\u00adsion Schemes; Collapsible Pushdown Systems Permission to make digital or hard copies \nof all or part of this work for personal or classroom use is granted without fee provided that copies \nare not made or distributed for pro.t or commercial advantage and that copies bear this notice and the \nfull citation on the .rst page. Copyrights for components of this work owned by others than the author(s) \nmust be honored. Abstracting with credit is permitted. To copy otherwise, or republish, to post on servers \nor to redistribute to lists, requires prior speci.c permission and/or a fee. Request permissions from \npermissions@acm.org. ICFP 13, September 25 -27 2013, Boston, MA, USA. Copyright is held by the owner/author(s). \nPublication rights licensed to ACM. ACM 978-1-4503-2326-0/13/09. . . $15.00. http://dx.doi.org/10.1145/2500365.2500589 \n 1. Introduction Functional languages such as Haskell, OCaML and Scala strongly encourage the use of \nhigher-order functions. This represents a chal\u00adlenge for software veri.cation, which usually does not \nmodel re\u00adcursion accurately, or models only .rst-order calls (e.g. SLAM [2] and Moped [33]). However, \nthere has recently been much inter\u00adest in a model called higher-order recursion schemes (HORS) (see e.g. \n[29]), which offers a way of abstracting functional programs in a manner that precisely models higher-order \ncontrol-.ow. The execution trees of HORS enjoy decidable \u00b5-calculus theo\u00adries [29], which testi.es to \nthe good algorithmic properties of the model. Even reachability properties (subsumed by the \u00b5-calculus) \nare very useful in practice. As a simple example, the safety of incomplete pattern matching clauses could \nbe checked by asking whether the program can reach a state where a pattern match failure occurs. More \ncomplex reachability properties can be ex\u00adpressed using a .nite automaton and could, for example, specify \nthat the program respects a certain discipline when accessing a par\u00adticular resource (see [22]). Despite \neven reachability being (n-1)-EXPTIME complete, recent research has revealed that useful prop\u00aderties \nof HORS can be checked in practice. Kobayashi s TRecS [23] tool, which checks properties express\u00adible \nby a deterministic trivial B\u00a8uchi automaton (all states accept\u00ading), was the .rst to achieve this. It \nworks by determining whether a HORS is typable in an intersection-type system characterising the property \nto be checked [22]. In a bid to improve scalability, a number of other algorithms have subsequently been \ndesigned and implemented such as Kobayashi et al. s GTRecS(2) [25, 26] and Neatherway et al. s TravMC \n[28] tools (appearing in ICFP 2012), all of which remain based on intersection type inference. This work \nis the basis of various techniques for verifying func\u00adtional programs. Kobayashi et al. have developed \nMoCHi [27] that checks safety properties of (OCaML) programs, and EHMTT Ver\u00adi.er [38] for tree processing \nprograms. Both use a model-checker for recursion schemes as a central component. Similarly, Ramsay and \nOng [30] provide a veri.cation procedure for programs with pattern matching employing recursion schemes \nas an abstraction. Despite much progress, even the state-of-the-art TRecS does not scale to recursion \nschemes big enough to model realistically sized programs; achieving scalability while accurately tracking \nhigher-order control-.ow is a challenging problem. This paper of\u00adfers an automata-theoretic perspective \non this challenge, providing a fresh set of tools that contrast with previous intersection-type approaches. \nTechniques based on pushdown automata have previ\u00adously visited ICFP, such as the approximate higher-order \ncontrol\u00ad.ow analysis CFA2 [40], but our aims are a bit different in that we wish to match the expressivity \nof HORS. Consequently we require a more sophisticated notion of pushdown automaton. Collapsible pushdown \nsystems (CPDS) [16] are an alternative representation of the class of execution trees that can be gener\u00adated \nby recursion schemes (with linear-time mutual-translations be\u00adtween the two formalisms [10, 16]). While \npushdown systems aug\u00adment a .nite-state machine with a stack and provide an ideal model for .rst-order \nprograms [20], collapsible pushdown systems model higher-order programs by extending the stack of a pushdown \nsys\u00adtem to a nested stack-of-stacks structure. The nested stack struc\u00adture enables one to represent closures. \nIndeed the reader might .nd it helpful to view a CPDS as being Krivine s Abstract Machine in a guise \nmaking it amenable to the generalisation of techniques for pushdown model-checking. Salvati and Walukiewicz \nhave studied in detail the connection with the Krivine abstract machine [32]. For ordinary ( order-1 \n) pushdown systems, a model-checking approach called saturation has been successfully implemented by \ntools such as Moped [33] and PDSolver [15]. Given a regular set of con.gurations of the pushdown system \n(represented by a .nite automaton A acting on stacks), saturation can solve the back\u00adward reachability \nproblem by computing another .nite automaton recognising a set of con.gurations from which a con.guration \nin L(A) can be reached. This is a .xed-point computation that gradu\u00adally adds transitions to A until \nit is saturated . If A recognises a set of error con.gurations, one can determine whether the pushdown \nsystem is safe by checking if its initial con.guration is recognised by the automaton computed by saturation. \nWe recently extended the saturation method to a backward reachability analysis of collapsible pushdown \nsystems [7]. This runs in PTIME when the number of control states is bounded. Crucially, this condition \nis satis.ed when translating from recursion schemes of bounded arity with properties represented by automata \nof bounded size [16]. Whilst the HORS/intersection-type based tool GTRecS(2) also enjoys this .xed-parameter \ntractability (others do not), it times out on many benchmarks that our tool solves quickly. Motivated \nby these facts, we revisit the foundations of higher\u00adorder veri.cation tools and introduce C-SHORe the \n.rst model\u00adchecking tool for the (direct) analysis of collapsible pushdown systems. Whilst the tool is \nbased on the ICALP 2012 result, some substantial modi.cations and additions are made to the algorithm, \nleading to several novel practical and theoretical contributions: 1. An approximate forward reachability \nalgorithm providing data (a) . . . allowing for the CPDS to be pruned so that saturation receives a smaller \ninput. (b) . . . employed by a modi.ed saturation algorithm to guide its backward search.  This is \nessential for termination on most of our benchmarks. 2. A method for extracting witnesses to reachability. \n 3. A complete reworking of the saturation algorithm that speeds up the .xed-point computation. 4. Experimental \nresults showing our approach compares well with TRecS, GTRecS(2) and TravMC.  It is worth remarking \nthat the other type-based tools mentioned above all work by propagating information in a forward direction \nwith respect to the evaluation of the model. In contrast, the raw saturation algorithm works backwards, \nbut we also show here how forward and backward propagation can be combined. In Sections 5 to 8 we describe \nthe original contributions of this paper. These sections can be understood independently of one an\u00adother, \nand hence the reader does not need to fully grasp each section before continuing to the next. The remaining \nsections describe the background, related work and conclusions. In Section 3 we recall the basic structures \nused in the paper as well as recapping the ICALP 2012 algorithm. In Section 5 we describe the approximate \nforwards-reachability analysis and how it is exploited. In Section 6 we show how to generate witnesses \nto reachability. In Section 7, we then consider how to restructure the saturation algorithm to more ef.ciently \ncompute the .xed-point. We provide experimental results in Section 8. Note that we do not discuss in \nformal detail the translation from HORS model-checking to reachability for CPDS, which essentially follows \n[10]. However, we do give an informal overview in Section 2, which we hope serves to demonstrate how \nclosures can be accurately modelled. The tool is available at http://cshore.cs.rhul.ac.uk. An appendix \ncontaining additional material appears in the long version of this paper, available from the same URL. \n2. Modelling Higher-Order Programs In this section we give an informal introduction to the process of \nmodelling higher-order programs for veri.cation. In particular, we show how a simple example program \ncan be modelled using a higher-order recursion scheme, and then we show how this scheme is evaluated \nusing a collapsible pushdown system. For a more sys\u00adtematic approach to modelling higher-order programs \nwith recur\u00adsion schemes, we refer the reader to work by Kobayashi et al. [27]. This section is for background \nonly, and can be safely skipped. For this section, consider the toy example below. Main = MakeReport \nNil MakeReport x = if * (Commit x) else (AddData x MakeReport) AddData y f = if * (f Error) else (f Cons(_, \ny)) In this example, * represents a non-deterministic choice (that may, for example, be a result of \nsome input by the user). Execution begins at the Main function whose aim is to make a report which is \na list. We begin with an empty report and send it to MakeReport. Either MakeReport indicates the report \nis .nished and commits the report somehow, or it adds an item to the head of the list, using the AddData \nfunction, which takes the report so far, and a continuation. AddData either detects a problem with the \nnew data (maybe it is inconsistent with the rest of the report) and .ags an error by passing Error to \nthe continuation, or extends the report with some item. In this case, the programmer has not provided \nerror handling as part of the MakeReport function, and so an Error may be committed. 2.1 Higher-Order \nRecursion Schemes As a .rst step in modelling this program, we introduce, informally, higher-order recursion \nschemes. These are rewrite systems that generate the computation tree of a functional program. A rewrite \nrule takes the form N.x '. t where N is a typed non-terminal with (possibly higher-order) argu\u00adments \n. and x. A term N t. tx rewrites to t with t. substituted for . and tx substituted for x. Note that recursion \nschemes require t to be of ground type. We will illustrate the behaviour of a recursion scheme and its \nuse in analysis using the toy example from above. We can directly model our example with the scheme where \nM is the non-terminal associated with the MakeReport function, and A is the non-terminal associated with \nthe AddData function; nil, or, commit, error and cons are terminal symbols of arity 0, 2, 1, 0 and 1 \nrespectively (e.g. in the second rule, or takes the two arguments (commit x) and (A x M )). The scheme \nabove begins with the non-terminal main and, through a sequence of rewrite steps, generates a tree representation \nof the evolution of the program. Figure 1, described below, shows such a sequence. main '. M nil M x \n'. or (commit x) (A x M ) A y . '. or (. error) (. (cons y))  Beginning with the non-terminal main, \nwe apply the .rst rewrite rule to obtain the tree representing the term (A nil). We then apply the second \nrewrite rule, instantiating x with nil to ob\u00adtain the next tree in the sequence. This continues ad in.nitum \nto produce a possibly in.nite tree labelled only by terminals. We are interested in ensuring the correctness \nof the program. In our case, this means ensuring that the program never attempts to commit an error. \nBy inspecting the rightmost tree in Fig\u00adure 1, we can identify a branch labelled or, or, or, commit, \nerror. This is an error situation because commit is being called with an error report. In general we \ncan de.ne the regular language * Lerr = orcommit or*error. If the tree generated by the re\u00adcursion scheme \ncontains a branch labelled by a word appearing in Lerr , then we have identi.ed an error in the program. \n 2.2 Collapsible Pushdown Automata Previous research into the veri.cation of recursion schemes has used \nan approach based on intersection types (e.g. [24, 28]). In this work we investigate a radically different \napproach exploiting the connection between higher-order recursion schemes and an automata model called \ncollapsible pushdown automata (CPDA). These two formalisms are, in fact, equivalent. Theorem 2.1 (Equi-expressivity \n[16]). For each order-n recursion scheme, there is an order-n collapsible pushdown automaton gen\u00aderating \nthe same tree, and vice-versa. Furthermore, the translations in both directions are linear. We describe \nat a high level the structure of a CPDA and how they can be used to evaluate recursion schemes. In our \ncase, this means outputting a sequence of non-terminals representing each path in the tree. More formal \nde.nitions are given in Section 3. At any moment, a CPDA is in a con.guration .p, w., where p is a control \nstate taken from a .nite set P, and w is a higher\u00adorder collapsible stack. In the following we will focus \non the stack. Control states are only needed to ensure that sequences of stack operations occur in the \ncorrect order and are thus elided for clarity. In the case of our toy example, we have an order-2 recursion \nscheme and hence an order-2 stack. An order-1 stack is a stack of characters a from a .nite alphabet \n.. An order-2 stack is a stack of order-1 stacks. Thus we can write [[main]] to denote the order\u00ad2 stack \ncontaining only the order-1 stack [main]; [main] is an order-1 stack containing only the character main. \nIn general . will contain all subterms appearing in the original statement of our toy example recursion \nscheme. The evolution of the CPDA stack is given in Figure 2 and explained below. The .rst step is to \nrewrite main using main '. M nil. Since (M nil) is a subterm of our recursion scheme, we have (M nil) \n= . and we simply rewrite the stack [[main]] to [[M nil]]. The next step is to call the function M. As \nis typical in the execution of programs, a function call necessitates a new stack frame. In particular, \nthis means pushing the body of M (that is (or (commit x) (A x M )))onto the stack, resulting in the third \nstack in Figure 2. Note that we do not instantiate the variable x, hence we use only the subterms appearing \nin the recursion scheme. Recall that we want to obtain a CPDA that outputs a sequence of terminals representing \neach path in the tree. To evaluate the term or (\u00b7 \u00b7 \u00b7 ) (\u00b7 \u00b7 \u00b7 ) we have to output the terminal or and \nthen (non\u00addeterministically) choose a branch of the tree to follow. Let us choose (A x M ). Hence, the \nCPDA outputs the terminal or and rewrites the top term to (A x M ). Next we make a call to the A function, \npushing its body on to the stack, and then pick out the (. error) branch of the or terminal. This takes \nus to the beginning of the second row of Figure 2. To proceed, we have to evaluate (. error). To be \nable to do this, we have to know the value of .. We can obtain this information by inspecting the stack \nand seeing that the second argument of the call of A is M. However, since we can only see the top of \na stack, we would have to remove the character (. error) to be able to determine that . = M, thus losing \nour place in the computation. This is where we use the power of order-2 stacks. An order-2 stack is able \n via a push2 operation to create a copy of its topmost order-1 stack. Hence, we perform this copy (note \nthat the top of the stack is written on the left) and delve into the copy of the stack to ascertain the \nvalue of .. While doing this we also create a collapse link, pictured as an arrow from M to the term \n(. error). This collapse link is a pointer from M to the context in which M will be evaluated. In particular, \nif we need to know the value of x in the body of M, we will need to know that M was called with the error \nargument, within the term (. error); the collapse link provides a pointer to this information (in other \nwords we have encoded a closure in the stack). We can access this information via a collapse operation. \nThese are the two main features of a higher\u00adorder collapsible stack, described formally in the next section. \nTo continue the execution, we push the body of M on to the stack, output the or symbol and choose the \n(commit x) branch. Since commit is a terminal, we output it and pick out x for evaluation. To know the \nvalue of x, we have to look into the stack and follow the collapse link from M to (. error). Note that \nwe do not need to create a copy of the stack here because x is an order\u00ad0 variable and thus represents \na self-contained execution. Since error is the value of the argument we are considering, we pick it out \nand then output it before terminating. This completes the execution corresponding to the error branch \nidenti.ed in Figure 1. 2.3 Collapsible Pushdown Systems The CPDA output or, or, or, commit, error in \nthe execution above. This is an error sequence in Lerr and should be .agged. In general, we take the \n.nite automaton A representing the regular language Lerr and form a product with the CPDA described above. \nThis results in a CPDA that does not output any symbols, but in\u00adstead keeps in its control state the \nprogression of A. Thus we are interested in whether the CPDA is able to reach an accepting state of A, \nnot the language it generates. We call a CPDA without output symbols a collapsible pushdown system (CPDS), \nand the question of whether a CPDS can reach a given state is the reachability prob\u00adlem. This is the \nsubject of the remainder of the paper. 3. Preliminaries 3.1 Collapsible Pushdown Systems We .rst introduce \nhigher-order collapsible stacks and their opera\u00adtions, before giving the de.nition of collapsible pushdown \nsystems. 3.1.1 Higher-Order Collapsible Stacks and Their Operations Higher-order collapsible stacks are \nbuilt from a stack alphabet . and form a nested stack-of-stacks structure. Using an idea from panic automata \n[21], each stack character contains a pointer called a link to a position lower down in the stack. \nOperations updating stacks (de.ned below) may create copies of sub-stacks. The link is intuitively a \npointer to the context in which the stack character was .rst created. In the sequel, we .x the maximal \norder to n, and use k to range between 1 and n. In the de.nition below, we defer the meaning of collapse \nlink to De.nition 3.2. '''\u00b7 \u00b7 ' '\u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 Figure 2: Astack evaluating the toyexample. De.nition \n3.1 (Order-n Collapsible Stacks). Given a .nite set of stackcharacters , an order-0 stack is simply a \ncharacter a = . An order-n stack is a sequence w = [wl . . . w1]n suchthat each wi is an order-(n - 1) \nstack and each character a on the stack is augmented with a collapse link. The top-most stack is wl. \nLet Stacksn denote the set of order-n stacks. Collapse links point to positions in the stack. Before \ndescribing them formally,we givean informal description and some basic def\u00adinitions. An order-n stack \ncan be represented naturally as an edge\u00adlabelled word-graph over the alphabet {[n-1, . . . , [1, ]1, \n. . . , ]n-1}. , with additional collapse-links pointing from a stack character in to the beginning of \nthe graph representing the target of the link. For technical convenience we do not use [n or ]n symbols \n(these appear uniquely at the beginning and end of the stack). An example order-3 stack is given in Figure \n3, with only a few collapse links shown, ranging from order-3 to order-1 respectively. Stacks are written \nwith the top on the left. Given an order-n stack [wl . . . w1]n, we de.ne topn+1([wl . . . w1]n) = [wl \n. . . w1]n topn([wl . . . w1]n) = wl if l > 0 topn([ ]n) = [ ]n-1 otherwise topk([wl . . . w1]n) = topk(wl) \nif k < n and l > 0 noting that topk(w) is unde.ned if topk ' (w) is empty for any k ' > k. We also remove \nthe top portion of a topk stack using botn i ([wl . . . w1]n) = [wi . . . w1]n when i : l and l > 0, \nand botk i ([wl . . . w1]n) = [botk i (wl)wl-1 . . . w1]n when k < n and l > 0. We are now ready to de.ne \ncollapse links. De.nition 3.2 (Collapse Links). An order-k collapse link is a pair (k, i) where 1 : k \n: n and i > 0. For top1(w) = a where a has the link (k, i), the destination of the link is boti k(w). \nWe disallow collapse links where boti k does not lead to a valid stack. The example stack in Figure 3 \nis (3,1) (2,1)]1[d(1,1) thus [[[ab]1]2[[ce]1]2]3, where collapse links are denoted as superscripts. Often \n(as we have done for the stack characters b and e)we will omit these superscripts for readability. Finally \nthe following notation appends astack on top of another. Given an order-k stack v = [vl . . . v1]k and \nan order-(k ' - 1) stack u (with k ' : k), we de.ne u :k ' v = [u vl . . . v1]k if k ' = k and u :k ' \nv = [(u :k ' vl) . . . v1]k if k ' < k. The following operations apply to an order-n collapsible stack. \nOn = {pop1, . . . , popn} . {push2, . . . , pushn} . {collapse2, . . . , collapsen} . { } push2 a a | \na =, . . . , pushn , rewa We de.ne each stack operation for an order-n stack w. Collapse links are created \nby pushk a, which add a character to the top of a given stack w with a link pointing to topk+1(popk(w)). \nThis gives a access to the context in which it was created. We set 1. popk(u :k v) = v, 2. pushk(u :k \nv) = u :k (u :k v), 3. collapsek(w) = boti k(w) where top1(w) = a(k,i) for some i, 4. pushk b (w) = \nb(k,l-1) :1 w where topk+1(w) = [wl . . . w1]k,  () (k,i) = b(k,i) 5. rewb a:1 v:1 v. Note that, for \na pushk operation, links outside of u = topk(w) point to the same destination in both copies of u, while \nlinks pointing within u point within the respective copies of u. Since collapse1 would always be equivalent \nto pop1, we neither create nor follow order-1 links. (Often in examples we do not illustrate links that \nare never used.) For amore detailed introduction see [10]. 3.1.2 Collapsible Pushdown Systems We are \nnow ready to de.ne collapsible pushdown systems. De.nition 3.3 (Collapsible Pushdown Systems). An order-n \ncol\u00adlapsible pushdown system (n-CPDS) is a tuple C = (P, , R) where P is a .nite set of control states, \nis a .nite stackalphabet, and R < P \u00d7 \u00d7 On \u00d7 P is a set of rules. Acon.guration of a CPDS is a pair .p, \nw. where p = P and w = Stacksn. We denote by .p, w. -. .p ' , w ' . a transition from a rule (p, a, o, \np ' ) with top1(w) = a and w ' = o(w). Arun of a CPDS is a .nite sequence .p0, w0. -. \u00b7 \u00b7 \u00b7 -. .pl, wl.. \n = ' ' ' ' ' [2 \u00b7\u00b7\u00b7 \u00b7\u00b7\u00b7 Figure 4: Part of a run over an example stack.  3.2.1 Representing Transitions \nand States We use a long-form notation (de.ned below) that captures nested a sequences of transitions. \nFor example, we may write q3 - -. Qcol (Q1, Q2, Q3) to capture the transitions shown in Figure 4. To\u00adgether, \nthese indicate that after starting from the beginning of the stack and reading only the topmost stack \ncharacter, the remainder of the stack must be accepted by Qcol, Q1, Q2, and Q3. More gen\u00ad q1q2 erally, \nwe may also use q3 -. (Q2, Q3), and q3 -. (Q3). Formally, when q = Qk, q ' = Qk ' , Qi < Qi for all k \n. i . 1, and there is some i with Qcol < Qi, we write ' aq q - -. (Q1, . . . , Qk) and q -. (Qk ' +1, \n. . . , Qk) . Qcol qk-1 In the .rst case, there exist qk-1, . . . , q1 such that q ---. Qk = qk-2 a .k, \nqk-1 ---. Qk-1 = .k-1, . . . , q1 - -. Q1 = .1. In Qcol qk-1 the second case there exist qk-1, . . . \n, qk ' +1 with q ---. Qk = q qk-2 k ' +1 .k, qk-1 ---. Qk-1 = .k-1, . . . , qk ' +2 - --. Qk ' +2 = \n' q.k ' +2 and qk ' +1 -. Qk ' +1 = .k ' +1. Remark 3.1. We may also write qQk,...,Qfor the q ' above \nk ' +1 (whichis uniquely determined by Qk, . . . , Qk ' +1). a Note that our de.nitions mean that we \nhave, e.g., q - -. Qcol a (Q1, Q2, Q3) if and only if we have qQ3,Q2 - -. Q1 in .1. Qcol  3.2.2 Representing \nSets of Transitions a Let .S k denote the set of all order-k long-form transitions q - -. Qcol (Q1, \n. . . , Qk) of order-k. For a set T = k , we {t1, . . . , tl} < .S say T is of the form a Q - -. (Q1, \n. . . , Qk) Qcol whenever Q = {q1, . . . , ql} and for all 1 : i : l we have a() . ti = qi - -. Qi 1, \n. . . , Qk i and Qcol = Qcol i and for 1<i<l Qi col . all 1 : k ' : k, Qk ' = Qk i ' . Because a link \ncan only be of 1<i<l one order, we insist that Qcol < Qk ' for some 1 : k ' : n. 3.3 Representing Sets \nof Con.gurations Wede.ne anotion of P-multi-automata [4] for representing sets of con.gurations of collapsible \npushdown systems. De.nition 3.5 (P-Multi Stack Automata). Given an order-n CPDS with control states P,aP-multi \nstackautomaton is an order\u00adn stackautomaton A = (Qn, . . . , Q1, , .n, . . . , .1, Fn, . . . , F1) suchthat \nfor eachp = P there exists a state qp = Qn. Astate is initial if it is of the form qp = Qn for some control \n state p or if it is a state qk = Qk for k < n such that there exists qka transition qk+1 -. Qk+1 in \n.k+1. The language of a P-multi {g} stack automaton A is the set L(A) = .p, w. g w = Lqp (A) . 3.4 \nBasic Saturation Algorithm Our algorithm computes the set P re * C(A0) of a collapsible push\u00addown system \nC and a P-multi stack automaton A0. We assume without loss of generality that initial states of A0 do \nnot have in\u00adcoming transitions and are not .nal. To accept empty stacks from initial states, a bottom-of-stack \nsymbol can be used. Let P re * C(A0) be the smallest set with P re * C(A0) 2 L(A0), and P re * C(A0) \n2 {.p, w. | ..p, w. -. .p ' , w ' . = P reC * (A0) }. We begin with A0 and iterate a saturation function \nI adding new transitions to A0 until a .xed point is reached; that is, we cannot .nd anymore transitions \nto add. Notation for Adding Transitions During saturation we designate a transitions qn - -. (Q1, . \n. . , Qn) to be added to the automaton. Qcol qn-1 qn-2 Recall this represents q ---. Qn = .n, qn-1 ---. \nQn-1 = a .n-1, . . . , q1 - -. Q1 = .1. Hence, we .rst, for each n . k > Qcol qk-1  1, add qk ---. \nQk to .k if it does not already exist. Then, we a add q1 - -. Q1 to .1. Qcol Justi.ed Transitions In \nthis paper,we extend the saturation func\u00adtion to add justi.cations to new transitions that indicate the \nprove\u00adnance of each new transition. This permits counter example gen\u00ad = == ' ' ' = = ' ' ' ' = ' ' \n= = = = ' ' ' ' ' ' ' = ' ' ' = = ' = = = ' ' = ' ' ' = ' ' ' ' = = ' = ' ' Figure 5shows the sequence \nof saturation steps, beginning with an accepting run of .p5, [d]. and .nishing with an accepting run \nof .p1, [b] [c] [d].. The individual steps are explained below. Initial Automaton We begin at the top \nof Figure 5with a stack automaton containing the transitions qp5 -q1-d\u00d8, which . \u00d8 and q1 . \u00d8 we write \nqp5 -d(\u00d8, \u00d8). This gives the pictured run over .p5, [d].. . \u00d8 Rule (p4, c, pop2, p5) When the saturation \nstep considers such a pop rule, it adds qp4 -c(\u00d8, {qp5 . }). We add such a transition \u00d8 because we only \nrequire the top order-1 stack (removed by pop2) to have the top character c (hence \u00d8 is the next order-1 \nlabel), and after the pop2 the remaining stack needs to be accepted from qp5 (hence {qp5 } is the next \norder-2 label). This new transition allows us to construct the next run over .p4, [c] [d]. in Figure \n5. Rule (p3, a, collapse2, p4) Similarly to the pop rule above, the a saturation step adds the transition \nqp3 ----. (\u00d8, \u00d8). The addition {qp4 } of such a transition allows us to construct the pictured run over \n.p3, [ab] [ab] [c] [d]. (collapse links omitted), recalling that \u00d8 -\u00d8 . \u00d8, ab \u00d8 -\u00d8 and \u00d8 . \u00d8 transitions \nare always possible due to the empty . - \u00d8 \u00d8 initial set. Note that the labelling of {qp4 } in the run \ncomes from ' the collapse link on the topmost a character on the stack. Rule (p2, a, push2, p3) Consider \nthe run from qp3 in Figure 5. The initial transition of the run accepting the .rst order-1 stack is a \n\u00d8 qp3 - --. - (\u00d8, \u00d8). We also have \u00d8 . \u00d8 (trivially) accepting the = {qp4 } ' second order-1 stack. \nAny push2 predecessor of this stack must haveatop order-1 stack that could haveappeared twice at the \ntop of the stack from qp3 . Thus, the saturation step makes the intersection of the initial order-1 transitions \nof .rst two order-1 stacks. This a results in the transition qp2 - ----. (\u00d8 . \u00d8, \u00d8), which is used to \n{qp4 }u\u00d8 form the shown run over .p2, [ab] [c] [d]. (collapse links omitted). () Rule p1, b, pusha 2 \n, p2 The run from qp2 in Figure 5begins with qp2 - --(\u00d8, \u00d8) and \u00d8 . \u00d8. Note that the pusha 2 a. -bgives \na stack {qp4 } \u00d8 with ab on top. Moreover,the collapse link on a should point to the order-1 stack just \nbelow the current top one. Since the transition from qp2 requires that the linked-to stack is accepted \nfrom qp4 , we need this requirement in the preceding stack (accepted from qp1 and without the a on top). \nThus, we move the target of the collapse link into the order-2 destination of the new transition. That \nis, the b saturation step for push2 a rules creates qp1 . (\u00d8, \u00d8 . {qp4 }). This - \u00d8 can be used to \nconstruct an accepting run over .p1, [b] [c] [d].. ]1 Figure 5: Asequence of saturation steps. 5. Initial \nForward Analysis In this section we distinguish an error state perr and we are in\u00adterested only in whether \nC can reach a con.guration of the form .perr , w. (hence our A0 is non-alternating ). This suf.ces to \ncap\u00adture the same safety (reachability) properties of recursion schemes as TRecS. We .x a stack-automaton \nE recognising all error con.g\u00adurations (those with the state perr ). We write P ost * C for the set of \ncon.gurations reachable by C from the initial con.guration. This set cannot be represented precisely \nby a stack automaton [5] (for nn n instance using push2, we can create [[a ]1[a ]1]2 from [[a ]1]2 for \nany n . 0). We summarise our approach then give details in Sections 5.1, 5.2 and 5.3. It is generally \ncompletely impractical to compute P re * C(E) in full (most non-trivial examples considered in our experiments \nwould time-out). For our saturation algorithm to be usable in prac\u00adtice, it is therefore essential that \nthe search space is restricted, which we achieve by means of an initial forward analysis of the CPDS. \nIdeally we would compute only P re * C(E) \u00d8 P ost * C. Since this can\u00adnot be represented by an automaton, \nwe instead compute a suf.\u00adcient approximation T (ideally a strict subset of P re * C(E))where: ** * P \nreC(E) \u00d8 P ostC < T < P reC(E). The initial con.guration will belong to T iffit can reach a con.gu\u00adration \nrecognised byE. Computing such aT is much more feasible. We .rst compute an over-approximation of P ost \n* C. For this we use a summary algorithm [34] (that happens to be precise at order\u00ad1)from which we extract \nan over-approximation of the set of CPDS rules that may be used on a run to perr . Let C ' be the (smaller) \nCPDS containing only these rules. That is, we remove all rules that we know cannot appear on a run to \nperr . We could thus take T = P re * C ' (E) (computable by saturation for C ')since it satis.es the \nconditions above. This is what we meant by pruning the CPDS (1a in the list on page 2) However, we further \nimprove performance by computing an even smaller T (1b in the list on page 2). We extract contextual \ninformation from our over-approximation of P ostC * about how pops and collapses might be used during \na run to perr . Our C ' is then restricted to a model C '' that guards its rules by these contextual \nconstraints. Taking T = P re * C '' (E) we haveaT smaller than P re * C ' (E),but still satisfying our \nsuf.cient conditions. In fact, C '' will be a guarded CPDS (de.ned in the next subsection). We cannot \ncompute P re * C '' (E) precisely for a guarded CPDS, but we can adjust saturation to compute T such \nthat P re * C '' (E) < T < P re * C ' (E). This set will thus also satisfy our suf.cient conditions. \n 5.1 Guarded Destruction An order-n guarded CPDS (n-GCPDS) is an n-CPDS where con\u00adventional popk and \ncollapsek operations are replaced by guarded S operations of the form popk and collapseS k where S < \n. These operations may only be .red if the resulting stack has a member of S on top. That is, for o = \n{collapsek, popk | 1 : k : n }: { o(u) if o(u) de.ned and top1(o(u)) = S o S(u) := unde.ned otherwise \n. Note, we do not guard the other stack operations since these them\u00adselves guarantee the symbol on top \nof the new stack (e.g. when a transition (p, a, push2, p ' ) .res it must always result in astack with \na on top, and (p, a, pushb k, p ' ) produces a stack with b on top). Given aGCPDS C,we write Triv(C) \nfor the ordinary CPDS that S is the trivialisation of C, obtained by replacing each popk (resp. collapseS \nk )in the rules of C with popk (resp. collapsek). We modify the saturation algorithm to use guarded saturation \nsteps for pop and collapse rules. Other saturation steps are un\u00adchanged. Non-trivial guards reduce the \nsize of the stack-automaton constructed by avoiding certain additions that are only relevant for unreachable \n(and hence uninteresting) con.gurations in the pre\u00adimage. This thus improves performance. qk 1. when \no = pop S , for each qp ' -. (Qk+1, . . . , Qn) in A such k that there is a transition of the form qk \n-b) in A such . ( , . . . , that b = S, add qp -a(\u00d8, . . . , \u00d8, {qk} , Qk+1, . . . , Qn) to A ' , . \u00d8 \nqkk 3. when o = collapseS , for each qp ' -. (Qk+1, . . . , Qn) in A such that there is a transition \nof the form qk -b) in A . ( , . . . , a with b = S, add qp - -. (\u00d8, . . . , \u00d8, Qk+1, . . . , Qn) to A \n' . {qk} E.g., suppose that an ordinary (non-guarded) 2-CPDS has rules (p1, c, collapse2, p) and (p2, \nd, collapse2, p ' ). The original satu\u00adration algorithm would process these rules to add the transitions: \nc d qp1 ---. (\u00d8, \u00d8) and qp2 - --. (\u00d8, \u00d8) {qp} {qp ' } Now suppose that the saturation algorithm has produced \ntwo ab transitions of the form qp -. ( , ) and qp ' -( , ). If a . {a} GCPDS had, for example, the \nrules (p1, c, collapse2 , p) and {b} ' (p2, d, collapse2 , p ), then these same two transitions would \nbe added by the modi.ed saturation algorithm. On the other hand, {a} {a} ' the rules (p1, c, collapse2 \n, p) and (p2, d, collapse2 , p ) would only result in the .rst of the two transitions being added. Lemma \n5.1. The revised saturation algorithm applied to E (for a GCPDS C)gives a stack automaton recognising \nT such that P re * < T < P re * (E) C(E) Triv(C) Remark 5.1. The algorithm may result in a stack-automaton \nrecognising con.gurations that do not belong to P re * C(E) (al\u00adthough still in P re * (E)). This is \nbecause a state qk having Triv(C) a transition qk -b( , . . . ,. ) may also have another transition \n ' .' = '' = ' ' ' ' where the .rst con.guration mentioned here is reachable. We should then have edges \n((p1, b), r1, (p2, b)), ((p2, b), r2, (p3, c)) and ((p3, c), r3, (p4, b)) in E. We denote the con.gurations \nabove C1, C2, C3 and C4 respectively,with respectivestacks s1, s2, s3, s4. Such a graph can be computed \nusing an approximate summary algorithm,which builds up an object (H, E, B, U) consisting of an B((p2, \nb)) are relevant to the description of top2(s4) contained in B((p4, b)). First remark that this situation \nonly occurs for the popk and collapsek operations. To keep track of these correlations, we use the component \nU of the graph. The component U is a set of approximate higher-order sum\u00admary edges. Asummary edge describes \nhowinformation contained in stack descriptors should be shared between heads. An order\u00adk summary edge \nfrom a head h to a head h ' is a triple of the form (h, (h ' n, . . . , hk' +1) , h ' ) where each hi \n' is ahead. Such asum\u00admary edge is added when processing either a popk or a collapsek operation on an \norder-k link. Intuitively such a summary edge that if , then we=(h, . . . , h, h, . . . , h, h) B(h)means \nk+1 k 1n c g should also have(h ' , . . . , h ' ). Tocon\u00ad n k+1, hk, . . . , h1, hc) = B(h ' tinue our \nexample, the r3 rule (which performs a pop1 operation) from C3 to C4 means U should contain an order-1 \nsummary edge {{ ((p2, b), ((p1, b)) , (p4, b)). Since pop1 is an order-1 operation, we have pop2(s3) \n= pop2(s4). Hence (p1, b) (the order-2 component of the stack descriptor for s3)should also be the .rst \ncomponent of a stack descriptor for s4. However, since top1(s4) was created at a con.guration with head \n(p2, b), the order-1 and collapse com\u00adponents of such a stack descriptor for s4 should be inherited from \na stack descriptor in B((p2, b)). In general if we go from a con\u00ad.guration (p, s) with h to a con.guration \n(p ' , s ' ) with head h ' by the popk operation or collapsek on an order-k link, we have that popk+1(s) \n= popk+1(s ' ) and hence we have a summary edge (h, (h ' , . . . , h ' k+1) , h ' ) n The construction \nof the approximate reachability graph is de\u00adscribed in algorithms 7, 8, 9 and 10. The main work is done \nin the function ProcessHeadWithDescriptor. In particular, this is where summary edges are added for the \npopk and collapsek oper\u00adations. Afully worked example is given in the long version. 5.3 Extracting the \nGuarded CPDA Let G = (H, E) be an approximate reachability graph for C. Let Heads(E) be the set of heads \nof error con.gurations, i.e. Heads(E) := {(perr , a) | a = }. We do a simple backwards reachability computation \non the .nite graph G to compute the set BackRules(G), which is de.ned to be the smallest set satisfying: \ne = E e = E The CPDS rules occurring in the triples in BackRules(G) can be }} e = (h, r, h ' ) = E for \nsome approximate reachability graph together with two additional com\u00ad BackRules(G) = h ' = Heads(E) ponents. \nB is a map assigning each head h in the graph a set B(h) of stackdescriptors, which are (n + 1)-tuples \n(hn, . . . , h1, hc) of heads. In the following, we refer to hk as the order-k component e = (h, r, h \n' ) = E for some . (h ' , , ) = BackRules(G) and hc the collapse component. Roughly speaking, hk describes \nat which head the new topk-stack resulting from a popk operation (applied to a con.guration with head \nh)may have been created, used to de.ne a pruned CPDS C ' and hc does likewise for a collapse operation. \n(We will use _ in only if the original also does. However, the approximate reacha\u00adplace of a head to \nindicate when popk or collapse is unde.ned.) bility graph provides enough information to construct a \nguarded Consider C3 = .p3, s3. from the example above. This has CPDS C '' whose guards are non-trivial. \nIt should be clear that the control-state p3 and top stack symbol c and so is associated with the following \nset BackRulesG(G) of guarded rules can be computed: that reaches an error state if and head (p3, c). \nThus B((p3, c)) should contain the stack-descriptor . . . . .. . . . . .. .. . . . ' ((p1, b), (p2, \nb), (p1, b)), which describes s3. The .rst (order-2) component is because top2(s3) was created by a push2 \noperation from a con.guration with head (p1, b). The second (order-1) com\u00ad ) , ) = BackRules(G) and \n. . . .. ( , (p, a, o, p S } g { if o is a pop or a collapse and S ((p, a), r, (p ' , b)) with r = \n(p, a, o, p if o is a rewrite or push o ( ' ' p, a, o , p ) ponent is because the top symbol was created \nvia an order-1 push b = ' o = = E .. . . . from (p2, b). Finally, the order-2 link from the top of s3 \npoints to a stack occurring on top of a con.guration at the head (p1, b), giving . . . ' ) rise to the \n.nal (collapse) component describing the collapse link. o Tracking this information allows the summary \nalgorithm to pro\u00adcess the rule r3 to obtain a description of C4 from the description of C3. Since this \nrule performs a pop1, it can look at the order-1 g These rules de.ne a GCPDS on which C-SHORe .nally \nper\u00adforms saturation. component of the stack descriptor to see the head (p2, b), telling us that pop1 \nresults in b being on top of the stack. Since the rule r3 Lemma 5.2. The GCPDS C '' de.ned using BackRulesG(G) \nsat\u00admoves into control-state p4, this tells us that the new head should is.es: P ost * C \u00d8 P reC * (E) \n< P reC * '' (E) < P reC * (E) be (p4, b). It also tells us that certain pieces of information in Algorithm \n1 The Approximate Summary Algorithm Require: An n-CPDS with rules R and heads P \u00d7 and initial con.guration \n.p0, [\u00b7 \u00b7 \u00b7 [a0]1 \u00b7 \u00b7 \u00b7 ]n. Ensure: The creation of a structure (H, E, B, U ) where (H, E) is an approximate \nreachability graph and U is a set of approximate higher-order summary edges. Set H := {(p0, a0)} and \nset E, B and U to be empty Call AddStackDescriptor((p0, a0), (_, . . . , _, _)) return Done, (H, E, B, \nU ) will now be as required Algorithm 2 AddStackDescriptor(h, (hn, . . . , h1, hc)) Require: A head \nh = H and a stack descriptor (hn, . . . , h1, hc) Ensure: (hn, . . . , h1, hc) = B(h) and all additions \nto B(h ' ) for all h ' = H needed to respect summary edges are made. if (hn, . . . , h1, hc) = B(h) then \nreturn Done (Nothing to do) Add (hn, . . . , h1, hc) to B(h) Call ProcessHeadWithDescriptor(h, (hn, . \n. . , h1, hc)) for h ' = H such that (h, (h ' , . . . , h ' k+1) , h ' ) = U do Call AddStackDescriptor(h \n' , (h ' , . . . , h k' +1, hk, . . . , h1, hc)) n n return Done Algorithm 3 ProcessHeadWithDescriptor(h, \n(hn, . . . , h1, hc)) Require: A head h := (p, a) = H and a stack descriptor (hn, . . . , h1, hc) = B(h) \nEnsure: All necessary modi.cations to the graph are made so that it is consistent with (hn, . . . , h1, \nhc) = B(h). In particular this is the procedure that processes the CPDS rules from h (with respect to \na stack described by h and the stack descriptor). for o and p ' such that r = (p, a, o, p ' ) = R do \nif o = rewb then Add (p ' , b) to H and ((p, a), r, (p ' , b)) to E Call AddStackDescriptor((p ' , b), \n(hn, . . . , h1, hc)) else if o = pushk b then Add (p ' , b) to H and ((p, a), r, (p ' , b)) to E Call \nAddStackDescriptor((p ' , b), (hn, . . . , h2, (p, a), hk)) else if o = pushk then Add (p ' , a) to H \nand ((p, a), r, (p ' , a)) to E Call AddStackDescriptor((p ' , a), (hn, . . . , hk+1, (p, a), hk-1, . \n. . , h1, hc)) else if o = popk with hk = (pk, ak) where ak . = _ then Add (p ' , ak) to H and ((p, \na), r, (p ' , ak)) to E Call AddSummary((pk, ak), (hn, . . . , hk+1) , (p ' , ak)) else if o = collapsek, \nhc = (pc, ac) and ac . = _ then Add (pc, ac) to H and ((p, a), r, (p ' , ac)) to E Call AddSummary((pc, \nac), (hn, . . . , hk+1) , (p ' , ac)) return Done 6. Counter Example Generation In this section, we describe \nan algorithm that given a CPDS C and a stack automaton A0 such that a con.guration .p, w. of C belongs \nP re * C(A0), constructs a sequence of rules of C which when applied from .p, w. leads to a con.guration \nin L(A0). In practice, we use the algorithm with A0 accepting the set of all con.gurations starting with \nsome error state perr . The output is a counter-example showing how the CPDS can reach this error state. \nThe algorithm itself is a natural one and the full details are given in the full version of this paper. \nWe describe it informally here by means of the example in Figure 5, described in Section 4. To construct \na trace from .p1, [b] [c] [d]. to .p5, [d]. we .rst note that, when adding the initial transition of \nthe pictured run from qp1 , the saturation step marked that the transition was added due to the Algorithm \n4 AddSummary(h, (h ' , . . . , hk+1) , h ') n Require: An approximate higher-order summary edge (h, \n(h ' , . . . , hk+1) , h ' ) Ensure: n (h, (h ' , . . . , h ' k+1) , h ' ) = U and that all necessary \nstack n descriptors are added to the appropriate B(h '' ) for h '' = H so that all summary edges (including \nthe new one) are respected. if (h, (h ' n, . . . , h ' k+1) , h ' ) = U then return Done (Nothing to \ndo) Add (h, (h ' , . . . , h ' k+1) , h ' ) to U n for (hn, . . . , hk+1, hk, . . . , h1, hc) = B(h) \ndo AddStackDescriptor(h ' , (h ' , . . . , h ' k+1, hk, . . . , h1, hc)) return Done n () rule p1, b, \npusha 2 , p2 . If we apply this rule to .p1, [b] [c] [d]. we obtain .p2, [ab] [c] [d]. (collapse links \nomitted). Furthermore, the justi.cations added during the saturation step tell us which transi\u00adtions \nto use to construct the pictured run from qp2 . Hence, we have completed the .rst step of counter example \nextraction and moved one step closer to the target con.guration. To continue, we con\u00adsider the initial \ntransition of the run from qp2 . Again, the justi.ca\u00adtions added during saturation tell us which CPDS \nrule to apply and which stack automaton transitions to use to build an accepting run of the next con.guration. \nThus, we follow the justi.cations back to a run of A0, constructing a complete trace on the way. The \nmain technical dif.culty lies in proving that the reasoning outlined above leads to a terminating algorithm. \nFor example, we need to prove that following the justi.cations does not result us following a loop inde.nitely. \nSince the stack may shrink and grow during a run, this is a non-trivial property. To prove it, we require \na subtle relation on runs over higher-order collapsible stacks. 6.1 A Well-Founded Relation on Stack \nAutomaton Runs We aim to de.ne a well-founded relation over runs of the stack automaton A constructed \nby saturation from C and A0. To do this we represent a run over a stack as another stack of (sets of) \ntran\u00adsitions of A. This can be obtained by replacing each instance of a stack character with the set \nof order-1 transitions that read it. This is formally de.ned in the full version of the paper and described \nby example here. Consider the run over [[b] [c] [d]] from qp1 in Fig\u00adure 5. We can represent this run \nas the stack [[{t1}] [{t2}] [{t3}]] bcd where t1 = -\u00d8, t2 = q2 . \u00d8 and t3 = -\u00d8. Note that q5 . -q1 . \n\u00d8\u00d8 \u00d8 q5 since q5 uniquely labels the order-2 transition qp1 -. {qp4 } (and similarly for the transitions \nfrom qp4 and qp5 )we do not need to explicitly store these transitions in our stack representation of \nruns. Using this representation, we can de.ne by induction a relation '.k on the order-k runs of A. Note \nthat this is not an order relation as it is not always transitive. There are several cases to '.k. 1. \nFor k = 1, we say w ' '.1 w if for some i . 0, w contains strictly fewer transitions in .1 justi.ed at \nstep i than w ' and that for all j > i they both contain the same number of transitions in .1 justi.ed \nat step j. 2. For k > 1, we say u = [ul . . . u1]k '.k v = [vl ' . . . v1]k if  (a) l ' < l and ui \n= vi for i = [1, l ' - 1] and either ul ' = vl ' or ul ' '.k-1 vl ' , or (b) l ' . l and ui = vi for \ni = [1, l - 1] and ul '.k-1 vi for all i = [l, l ' ].  Lemma 6.1. For all k = [1, n], the relation \n'.k is well-founded. Namely there is no in.nite sequence w0 '.k w1 '.k w2 '.k \u00b7 \u00b7 \u00b7 . It is possible \nto show that by following the justi.cations, from stack w to a w ', we always have w '.n w '. Since this \nrelation is well-founded, the witness generation algorithm always terminates. 7. Ef.cient Fixed Point \nComputation We introduce an ef.cient method of computing the .xed point in Section 3, inspired by Schwoon \net al. s algorithm for alternating (order-1)pushdown systems [36]. Rather than checking all CPDS rules \nat each iteration, we fully process all consequences of each new transition at once. New transitions \nare kept in a set .new (implemented as a stack), processed, then moved to a set .done, which forms the \ntransition relation of the .nal stack automaton. We assume w.l.o.g. that a character s link order is \ndetermined by the character. This is true of all CPDSs obtained from HORSs. In most cases, new transitions \nonly depend on a single existing transition, hence processing the consequences of a new transition is \nstraightforward. The key dif.culty is the push rules, which de\u00adpend on sets of existing transitions. \nGiven a rule (p, a, pushk, p ' ), a processing t = qp ' - -. (Q1, . . . , Qk, . . . , Qn) once and once \nQcol only must somehow include adding a new transition whenever a there is a set of transitions of the \nform Qk - -. (Q1 ' , . . . , Q ' k) Q ' col in Ai either now or in the future. When t is processed, we \nthere\u00adfore create a trip-wire, consisting of a source and target. Atarget collects transitions from a \ngiven set of states (such as Qk above), whilst a source describes how such a collection could be used \nto form a new transition according to a push saturation step. De.nition 7.1. An order-k source for k \n. 1 is de.ned as a tuple (qk, qk-1, a, Qk) in Qk \u00d7 Q= k-1 \u00d7 \u00d7 2Qk 0 where Q= := {_}and Q= = Qi . {_} \nfor i . 1. An order-k target is a tuple i C ' Qk (Qk, Qk , Qlbl , Qk) = 2Qk \u00d7 2Qk \u00d7 2Qk-1 \u00d7 2 if k . \n2, and if k = 1 n(). C ' Q (Q1, Q1 , a, Qcol, Q1) = 2Q1 \u00d7 2Q1 \u00d7 \u00d7 2k ' \u00d7 2Q1 . k ' =2 The set QC is acountdown \ncontaining states in Qk still awaiting k () Qk \\ QC Qlbl a transition. We always have QC k < Qk and k \n--. Q ' k. Likewise, an order-1 target (Q1, QC 1 , a, Qcol, Q1) will satisfy (Q1 \\ QC aQ ' 1 ) - -. 1. \nAtarget is complete if QC k = \u00d8 or Q1 C = \u00d8. Qcol A trip-wire of order-k is an order-k source-target \npair of the form (( , , , Qk), (Qk, , , )) when k . 2 or (( , , a, Qk), (Qk, , a, , )) when k = 1. When \nthe target in a trip-wire is complete, the action speci.ed by its source is triggered, which we now sketch. \nAn order-k source for k . 2 describes how an order-(k - 1) source should be created from a complete target, \npropagating the computation to the level below, and an order-1 source describes how a new long-form transition \nshould be created from a complete target. That is, when we have (qk, , a, Qk) (we hide the second component \nfor simplicity of description) and (Qk, \u00d8, Qlbl , Q ' k) this Qlbl means we ve found a set of transitions \nwitnessing Qk --. Q ' k and should nowlook for transitions from Qlbl . Hence the algorithm creates a \nnew source and target for the order-(k - 1) state-set Qlbl . When this process reaches order-1, a new \ntransition is created. This results in the construction of the t ' from a push saturation step. Algorithm \n5gives the main loop and introduces the global sets .done and .new, and two arrays Usrc[k] and Utarg[k] \ncontaining sources and targets for each order. Omitted are loops processing popn and collapsen rules \nlike the naive algorithm. Algorithm 6 gives the main steps processing a new transition. We present only \ntwo CPDS rule cases here. In most cases a new transition is cre\u00adated, however, for push rules we create \na trip-wire. Remaining al\u00adgorithms, de.nitions, justi.cation handling, and proofs are given in the long \nversion of this paper. We describe some informally below. In create trip wire we create a trip-wire \nwith a new target (Qk, Qk, \u00d8, \u00d8). This is added using an add target procedure which also checks .done \nto create further targets. E.g., a new target () qk-1 . Q '' Qk, QC k , Qlbl , Q ' combines with an existing \nqk ---to k (k )create a new target Q, QC \\ {qk} , Qlbl . {qk-1} , Qk ' . Q '' . (This step corrects \na bug in the algorithm of Schwoon et al.)Simi\u00adlarly update trip wires updates existing targets by new \ntransitions. In all cases, when a source and matching complete target are cre\u00adated, we perform the propagations \ndescribed above. k k Proposition 7.1. Given a CPDS C and stackautomaton A0, let A be the result of Algorithm \n5. We have L(A) = P re * C(A0). 8. Experimental Results We compared C-SHORe with the current state-of-the-art \nveri.ca\u00adtion tools for higher-order recursion schemes (HORS): TRecS [23], GTRecS2 [26] (the successor \nof [25]), and TravMC [28]. Bench\u00admarks are from the TRecS and TravMC benchmark suites, plus several larger \nexamples provided by Kobayashi. The majority of the TravMC benchmarks were translated into HORS from \nan ex\u00adtended formalism, HORS with Case statements (HORSC), using a script by Kobayashi. For fairness, \nall tools in our experiments took a pure HORS as input. However, the authors of TravMC report that TravMC \nperforms faster on the original HORSC examples than on their HORS translations. In all cases, the benchmarks \nconsist of a HORS (generating a computation tree) and a property automaton. In the case of C-SHORe, the \nproperty automaton is a regular automaton describing branches of the generated tree that are considered \nerrors. Thus, fol\u00adlowing the intuition in Section 2, we can construct a reachability query over a CPDS, \nwhere the reachability of a control state perr indicates an erroneous branch (see [10] for more details). \nAll other tools check co-reachability properties of HORS and thus the prop\u00aderty automaton describes only \nvalid branches of the computation tree. In all cases, it was straightforward to translate between the \nco-reachability and reachability properties. The experiments were run on a Dell Latitude e6320 laptop \nwith 4Gb of RAM and four 2.7GHz Intel i7-2620M cores. We ran C-SHORe on OpenJDK 7.0 with IcedTea7 replacing \nbinary plugs, using the argument -Xmx to limit RAM usage to 2.5Gb. As ad\u00advised by the TravMC developers, \nwe ran TravMC on the Mono JIT Compiler version 3.0.3 with no command line arguments. Finally TRecS (version \n1.34) and GTRecS2 (version 3.17) were compiled with the OCaml version 4.00.1 compilers. On negative examples, \nGTRecS2 was run with its -neg argument. We used the ulimit command to limit memory usage to 2.5Gb and \nset a CPU timeout of 600 seconds (per benchmark). The given runtimes were reported by the respective \ntools and are the means of three separate runs on each example. Note that C-SHORe was run until the automaton \nwas completely saturated. Table 1shows trials where at least one tool took over 1s. This is because virtual \nmachine warm-up and HORS to CPDS con\u00adversion can skew the results on small benchmarks. Full results are \nin the full paper. Examples violating their property are marked (bug) . The order (Ord) and size (Sz) \nof the schemes were re\u00adported by TRecS. We show reported times in seconds for TRecS (T), GTRecS2 (G), \nTravMC (TMC) and C-SHORe (C) where  means analysis failed. For C-SHORe, we report the times for HORS \nto CPDS translation (Ctran), CPDS analysis (Ccpds), and building the approximation graph (Capprox). Capprox \nis part of Ccpds, and the full time (C) is the sum of Ctran and Ccpds. Of 26 benchmarks, C-SHORe performed \nbest on 5examples. In 6cases, C-SHORe was the slowest. In particular, C-SHORe does not perform well on \nexp4-1 and exp4-5. These belong to a class of benchmarks that stress higher-order model-checkers and \nindi\u00ad Algorithm 5Computing P re * C(A0) . Algorithm 6update rules(t) Let .done = \u00d8, .new = .k, n>k>1 \nif t is an order-k transition for 2 : k : n of the form qp ' Qn \u00b7\u00b7\u00b7Qk+1 - . Qk then Usrc[k] = \u00d8, Utarg[k] \n= {(\u00d8, \u00d8, \u00d8, \u00d8)} for p = P and a = such that r := (p, a, popk, p ' ) = R do for each n . k > 1 and Utarg[1] \n= ({} ) a {(\u00d8, \u00d8, a, \u00d8, \u00d8) | a = }. add to worklistqp - -. (\u00d8, . . . , \u00d8, qp 'Qn \u00b7\u00b7\u00b7Qk+1 , Qk+1, . . \n. , Qn), r Qcol . . . for p = P and a = such that r := (p, a, pushk, p ' ) = R do while .t = .new do \n() create trip wireqp,Qn,...,Qk+1 , qp ' ,Qn,...,Qk+1,Qk , a, Qk, (r, t) update rules(t);update trip \nwires(t);move \u00b7 \u00b7 \u00b7 t from .new to .done Benchmark .le Ord Sz T TMC G C Ctran Ccpds Capprox ,/X order5 \n5 52 0.007 0.039 0.415 0.057 0.358 0.205 order5-2 5 40 0.022 0.084 0.305 0.050 0.255 0.157 order5-variant \n5 55 0.019 0.039 1.519 0.427 0.057 0.370 0.177 filepath 2 5956 210.102  0.397 0.168 0.229 0.221 , filter-nonzero \n(bug) 5 484 0.006 0.115 0.182 1.443 0.100 1.344 1.006 X filter-nonzero-1 5 890 0.176 211.907 4.492 0.159 \n4.332 3.484 map-head-filter-1 3 880 0.141 1.343 0.400 0.119 0.281 0.273 map-plusone-1 5 459 0.030 0.736 \n 1.247 0.119 1.128 0.908 map-plusone-2 5 704 1.358 13.962 2.634 0.142 2.491 2.183 exp4-1 4 31 0.047 \n0.114 0.039 0.240 X exp4-5 4 55  0.818 0.046 2.128 X cfa-life2 14 7648   0.479  cfa-matrix-1 \n8 2944 16.937  19.230 0.332 18.898 18.892 cfa-psdes 7 1819 17.654  1.920 0.273 1.647 1.640 , dna 2 \n411 0.031 0.263 0.046 6.918 0.175 6.743 6.206 X fibstring 4 29 74.569 0.114 0.042 0.256 X fold fun \nlist 7 1346 0.519  1.356 0.202 1.154 1.147 fold right 5 1310 31.624  1.255 0.191 1.064 1.043 , jwig-cal \nmain 2 7627 0.062 0.052 0.161 3.802 3.739 0.063 0.057 X l 3 35 15.743 0.010 0.248 0.042 0.206 0.199 \nsearch-e-church (bug) 6 837 0.012 0.258 4.741 0.155 4.586 1.760 specialize cps coerce1-c 3 2731  1.131 \n0.293 0.838 0.830 , tak (bug) 8 451 3.945 41.772 0.136 41.636 34.855 xhtmlf-div-2 (bug) 2 3003 0.234 \n 39.961 2.743 2.303 0.440 0.422 xhtmlf-m-church 2 3027 0.238 8.420 2.708 2.319 0.389 0.382 zip 4 2952 \n22.251  3.356 0.295 3.061 1.609 , Table 1: Comparison of model-checking tools. Shown in bold are the \ntwo .xed-parameter tractable algorithms, GTRecS2 and C-SHORe. cate that our tool currently does not always \nscale well. However, C-SHORe seems to show a more promising capacity to scale on larger HORS produced \nby tools such as MoCHi [27], which are particularly pertinent in that theyare generated by an actual \nsoft\u00adware veri.cation tool. Wealso note that C-SHORe timed out on the fewest examples despite not always \nterminating in the fastest time. It is also very important to note that C-SHORe and GTRecS2 are the only \nimplemented .xed-parameter tractable algorithms in the literature for HORS model-checking of which we \nare aware (both TRecS and TravMC have worst-case run-times non\u00adelementary in the size of the recursion \nscheme). Moreover, C-SHORe generally performs much better than GTRecS2. Thus not only does C-SHORe s \nperformance seem promising when com\u00adpared to the competition, there is also theoretical reason to suggest \nthat the approach could in principle be scalable, in contrast to some of the alternatives. Thus initial \nwork justi.es further investigation into saturation based algorithms for higher-order model-checking. \nFinally, we remark that without the forwards analysis described in Section 5, all shown examples except \nfilepath timed out. We also note that we did not implement anaiveversion of the saturation algorithm, \nwhere after each change to the stack automaton, each rule of the CPDS is checked for further updates. \nHowever, experi\u00adence implementing PDSolver [15](for order-1 pushdown systems) indicates that the naive \napproach is at least an order of magnitude slower than the techniques [36] we generalised in Section \n7. 9. Related Work The saturation technique has proved popular in the literature. It was introduced \nby Bouajjani et al. [4]and Finkel et al. [13] and based on a string rewriting algorithm by Benois [3]. \nIt has since been ex\u00adtended to B\u00a8uchi games [8], parity and \u00b5-calculus conditions [15], and concurrent \nsystems [1, 37], as well as weighted pushdown sys\u00adtems [31]. In addition to various implementations, \nef.cient versions of these algorithms have also been developed [12, 36]. The saturation algorithm for \nCPDS that we introduced in [7], extending and improving [14] (and [5]), follows anumber of papers solving \nparity games on the con.guration graphs of higher-order automata [6, 9, 11,16]. While only handling reachability,saturation \nlends itself well to implementation. This paper describes such a practical incarnation and a number of \nsigni.cant optimisations, such as using a forwards analysis to guide the backward search. This latter \npoint is an important way in which C-SHORe differs from previous model-checkers for HORS, which employintersec\u00adtion \ntypes and propagate information purely in a forward direction. This is related to the fact that the \nlatter accept co-reachability prop\u00aderties (represented by trivial B\u00a8uchi automata) as input, expressing \nthe complement of properties taken by C-SHORe. Indeed it would be interesting to investigate in more \ndetail how approximate forward and backward analyses of varying degrees of accuracy could be combined \nfor ef.ciency. It would also be helpful to more closely analyse the relationship between CPDS and type\u00adbased \nalgorithms allowing a transfer of ideas. In any case, this paper shows that saturation-based algorithms \nfor HORS/CPDS perform suf.ciently well in practice to warrant further study. To .nish, we brie.y mention \nseveral approaches to analysing higher-order programs with differing aims to ours. In static anal\u00adysis, \nk-CFA [35] and CFA2 [39] perform an over-approximative analysis of higher-order languages with at-most \n.rst-order granu\u00adlarity. Similarly Jhala et al. use re.nement types to analyse OCaml programs by reducing \nthe problem to .rst-order model-checking, which is thus incomplete [19]. Finally, Hopkins et al. have \npro\u00adduced tools for equivalence checking fragments of ML and Ideal\u00adized Algol up to order-3 [17, 18]. \n10. Conclusion We have considered the problem of verifying safety properties of a model that can be used \nto precisely capture control-.ow in the presence of higher-order recursion. Whilst previous approaches \nto such an analysis are based on higher-order recursion schemes and intersection types, our approach \nis based on automata and saturation techniques previously only applied in practice to the .rst-order \ncase. At a more conceptual level, our algorithm works by propagating information backwards from error \nstates towards the initial state. Moreover, it combines this with an approximate forward analysis to \ngather information that guides the backward search. In contrast, the preceding type-based algorithms \nall work by propagating information purely in a forward direction. Our preliminary work brings new techniques \nto the table for tackling a problem, which in contrast to its .rst-order counterpart, has proven dif.cult \nto solve in a scalable manner. Our algorithm has the advantage that it accurately models higher-order \nrecursion whilst also being .xed-parameter tractable, therefore giving a the\u00adoretical reason for hope \nthat it could scale. In contrast TRecS and TravMC have worst-case run-times non-elementary in the size \nof the recursion scheme. Our tool also seems to work signi.cantly bet\u00adter in practice than GTRecS2, the \nonly other HORS model-checker in the literature that does enjoy .xed-parameter tractability. We therefore \nbelieve that a C-SHORe-like approach shows much promise and warrants further investigation. Acknowledgments \nWe are extremely to Robin Neatherway and Naoki Kobayashi for help with benchmarking, Lukasz Kaiser for \nweb-hosting, and for discussions with Stefan Schwoon. Supported by Fond. Sci. Math. Paris, AMIS (ANR \n2010 JCJC 0203 01 AMIS), FREC (ANR 2010 BLAN 0202 02 FREC), VAPF (R\u00b4egion IdF), and EPSRC (EP/K009907/1). \nReferences [1] M. F. Atig. Global model checking of ordered multi-pushdown sys\u00adtems. In FSTTCS, 2010. \n[2] T. Ball and S. K. Rajamani. The SLAM project: Debugging system software via static analysis. In POPL, \n2002. [3] M. Benois. Parties rationnelles du groupe libre. Comptes-Rendus de l Acamd \u00b4emie des Sciences \nde Paris, S\u00b4erie A, 269:1188 1190, 1969. [4] A. Bouajjani, J. Esparza, and O. Maler. Reachability analysis \nof pushdown automata: Application to model-checking. In CONCUR, 1997. [5] A. Bouajjani and A. Meyer. \nSymbolic Reachability Analysis of Higher-Order Context-Free Processes. In FSTTCS, 2004. [6] C. H. Broadbent, \nA. Carayol, C.-H. L. Ong, and O. Serre. Recursion schemes and logical re.ection. In LICS, 2010. [7] C. \nH. Broadbent, A. Carayol, M. Hague, and O. Serre. A saturation method for collapsible pushdown systems. \nIn ICALP, 2012. [8] T. Cachat. Games on Pushdown Graphs and Extensions. PhD thesis, RWTH Aachen, 2003. \n[9] T. Cachat. Higher order pushdown automata, the Caucal hierarchy of graphs and parity games. In ICALP, \n2003. [10] A. Carayol and O. Serre. Collapsible pushdown automata and labeled recursion schemes: Equivalence, \nsafety and effective selection. In LICS, 2012. [11] A. Carayol, M. Hague, A. Meyer, C.-H. L. Ong, and \nO. Serre. Winning Regions of Higher-Order Pushdown Games. In LICS, 2008. [12] J. Esparza, D. Hansel, \nP. Rossmanith, and S. Schwoon. Ef.cient algorithms for model checking pushdown systems. In CAV, 2000. \n[13] A. Finkel, B. Willems, and P. Wolper. A direct symbolic approach to model checking pushdown systems. \nIn INFINITY, 1997. [14] M. Hague and C.-H. L. Ong. Symbolic backwards-reachability analy\u00adsis for higher-order \npushdown systems. Logical Methods in Computer Science, 4(4), 2008. [15] M. Hague and C.-H. L. Ong. Analysing \nmu-calculus properties of pushdown systems. In SPIN, 2010. [16] M. Hague, A. S. Murawski, C.-H. L. Ong, \nand O. Serre. Collapsible pushdown automata and recursion schemes. In LICS, 2008. [17] D. Hopkins and \nC.-H. L. Ong. Homer: A higher-order observational equivalence model checker. In CAV, 2009. [18] D. Hopkins, \nA. S. Murawski, and C.-H. L. Ong. Hector: An equiva\u00adlence checker for a higher-order fragment of ml. \nIn CAV, 2012. [19] R. Jhala, R. Majumdar, and A. Rybalchenko. Hmc: Verifying func\u00adtional programs using \nabstract interpreters. In CAV, 2011. [20] N. D. Jones and S. S. Muchnick. Even simple programs are hard \nto analyze. J. ACM, 24:338 350, April 1977. [21] T. Knapik, D. Niwinski, P. Urzyczyn, and I. Walukiewicz. \nUnsafe grammars and panic automata. In ICALP, 2005. [22] N. Kobayashi. Types and higher-order recursion \nschemes for veri.ca\u00adtion of higher-order programs. In POPL, 2009. [23] N. Kobayashi. Model-checking higher-order \nfunctions. In PPDP, 2009. [24] N. Kobayashi. Higher-order model checking: From theory to practice. In \nLICS, 2011. [25] N. Kobayashi. A practical linear time algorithm for trivial automata model checking \nof higher-order recursion schemes. In FOSSACS, 2011. [26] N. Kobayashi. GTRECS2: A model checker for \nrecursion schemes based on games and types. A tool available at http://www-kb.is. s.u-tokyo.ac.jp/~koba/gtrecs2/, \n2012. [27] N. Kobayashi, R. Sato, and H. Unno. Predicate abstraction and cegar for higher-order model \nchecking. In PLDI, 2011. [28] R. P. Neatherway, S. J. Ramsay, and C.-H. L. Ong. A traversal-based algorithm \nfor higher-order model checking. In ICFP, 2012. [29] C.-H. L. Ong. On model-checking trees generated \nby higher-order recursion schemes. In LICS, 2006. [30] C.-H. L. Ong and S. J. Ramsay. Verifying higher-order \nfunctional programs with pattern-matching algebraic data types. In POPL, 2011. [31] T. W. Reps, S. Schwoon, \nS. Jha, and D. Melski. Weighted pushdown systems and their application to interprocedural data.ow analysis. \nSci. Comput. Program., 58(1-2):206 263, 2005. [32] S. Salvati and I. Walukiewicz. Recursive schemes, \nkrivine machines, and collapsible pushdown automata. In RP, 2012. [33] S. Schwoon. Model-checking Pushdown \nSystems. PhD thesis, Techni\u00adcal University of Munich, 2002. [34] M. Sharir and A. Pnueli. Two approaches \nto interprocedural data .ow analysis, chapter 7, pages 189 234. Prentice-Hall, 1981. [35] O. Shivers. \nControl-Flow Analysis of Higher-Order Languages. PhD thesis, Carnegie-Mellon University, 1991. [36] D. \nSuwimonteerabuth, S. Schwoon, and J. Esparza. Ef.cient algo\u00adrithms for alternating pushdown systems with \nan application to the computation of certi.cate chains. In ATVA, 2006. [37] D. Suwimonteerabuth, J. Esparza, \nand S. Schwoon. Symbolic context\u00adbounded analysis of multithreaded java programs. In SPIN, 2008. [38] \nH. Unno, N. Tabuchi, and N. Kobayashi. Veri.cation of tree\u00adprocessing programs via higher-order model \nchecking. In APLAS, 2010. [39] D. Vardoulakis. CFA2: Pushdown-Flow Analysis for Higher-Order Languages. \nPhD thesis, Northeastern University, Boston, 2012. [40] D. Vardoulakis and O. Shivers. Pushdown .ow analysis \nof .rst-class control. In ICFP, 2011.    \n\t\t\t", "proc_id": "2500365", "abstract": "<p>Higher-order recursion schemes (HORS) have recently received much attention as a useful abstraction of higher-order functional programs with a number of new verification techniques employing HORS model-checking as their centrepiece. This paper contributes to the ongoing quest for a truly scalable model-checker for HORS by offering a different, automata theoretic perspective. We introduce the first practical model-checking algorithm that acts on a generalisation of pushdown automata equi-expressive with HORS called collapsible pushdown systems (CPDS). At its core is a substantial modification of a recently studied saturation algorithm for CPDS. In particular it is able to use information gathered from an approximate forward reachability analysis to guide its backward search. Moreover, we introduce an algorithm that prunes the CPDS prior to model-checking and a method for extracting counter-examples in negative instances. We compare our tool with the state-of-the-art verification tools for HORS and obtain encouraging results. In contrast to some of the main competition tackling the same problem, our algorithm is fixed-parameter tractable, and we also offer significantly improved performance over the only previously published tool of which we are aware that also enjoys this property. The tool and additional material are available from http://cshore.cs.rhul.ac.uk.</p>", "authors": [{"name": "Christopher Broadbent", "author_profile_id": "81418599634", "affiliation": "LIAFA, Universite Paris Diderot -- Paris 7 &#38; CNRS &#38; University of Tokyo &#38; Technische Universitat Munchen, Paris, Tokyo, Munich, Germany", "person_id": "P4261205", "email_address": "broadben@in.tum.de", "orcid_id": ""}, {"name": "Arnaud Carayol", "author_profile_id": "81100363218", "affiliation": "LIGM, Universite Paris-Est &#38; CNRS, Paris, France", "person_id": "P4261206", "email_address": "arnaud.carayol@univ-mlv.fr", "orcid_id": ""}, {"name": "Matthew Hague", "author_profile_id": "81384598252", "affiliation": "Royal Holloway University of London &#38; LIGM, Universite Paris-Est &#38; LIAFA, Universite Paris Diderot -- Paris 7 &#38; CNRS, London, United Kingdom", "person_id": "P4261207", "email_address": "matthew.hague@rhul.ac.uk", "orcid_id": ""}, {"name": "Olivier Serre", "author_profile_id": "81100088916", "affiliation": "LIAFA, Universite Paris Diderot -- Paris 7 &#38; CNRS, Paris, France", "person_id": "P4261208", "email_address": "olivier.serre@liafa.univ-paris-diderot.fr", "orcid_id": ""}], "doi_number": "10.1145/2500365.2500589", "year": "2013", "article_id": "2500589", "conference": "ICFP", "title": "C-SHORe: a collapsible approach to higher-order verification", "url": "http://dl.acm.org/citation.cfm?id=2500589"}