{"article_publication_date": "09-25-2013", "fulltext": "\n Functional Reactive Programming with Liveness Guarantees As relations are to set-valued functions, so \nevent sources are to behaviours Alan Jeffrey Bell Labs, Alcatel-Lucent aje.rey@bell-labs.com Abstract \nFunctional Reactive Programming (FRP) is an approach to the de\u00advelopment of reactive systems which provides \na pure functional in\u00adterface, but which may be implemented as an abstraction of an im\u00adperative event-driven \nlayer. FRP systems typically provide a model of behaviours (total time-indexed values, implemented as \npull sys\u00adtems) and event sources (partial time-indexed values, implemented as push systems). In this \npaper, we investigate a type system for event-driven FRP programs which provide liveness guarantees, \nthat is every input event is guaranteed to generate an output event. We show that FRP can be implemented \non top of a model of sets and relations, and that the isomorphism between event sources and be\u00adhaviours \ncorresponds to the isomorphism between relations and set-valued functions. We then implement sets and \nrelations using a model of continuations using the usual double-negation CPS trans\u00adform. The implementation \nof behaviours as pull systems based on futures, and of event sources as push systems based on the observer \npattern, thus arises from .rst principles. We also discuss a Java im\u00adplementation of the FRP model. Categories \nand Subject Descriptors D.1.1 [Software]: Program\u00adming Techniques Applicative (Functional) Programming \nGeneral Terms Design, Theory Keywords Functional Reactive Programming, Concurrency, Live\u00adness 1. Introduction \nMany classes of programs are reactive: they run for a long period of time during which they interact \nwith their environment. Examples of reactive programs include control systems, servers, and any program \nwith a graphical user interface. Many reactive programs are implemented using an event-driven model, \nin which stateful components send and receive events which update their state, and may cause side-effects \nsuch as network traf.c or screen updates. The event-driven model forms the basis of Actors [12], and \nthe Model View Controller architecture of Smalltalk [5]. Permission to make digital or hard copies of \nall or part of this work for personal or classroom use is granted without fee provided that copies are \nnot made or distributed for pro.t or commercial advantage and that copies bear this notice and the full \ncitation on the .rst page. Copyrights for components of this work owned by others than ACM must be honored. \nAbstracting with credit is permitted. To copy otherwise, or republish, to post on servers or to redistribute \nto lists, requires prior speci.c permission and/or a fee. Request permissions from permissions@acm.org. \nICFP 13, September 25 27, 2013, Boston, MA, USA. Copyright c &#38;#169; 2013 ACM 978-1-4503-2326-0/13/09. \n. . $15.00. http://dx.doi.org/10.1145/2500365.2500584 The event-driven model has a number of challenging \nfeatures, including: Concurrency: reactive programs often have concurrent features such as dealing with \nmultiple simultaneous events. This either leads to multithreaded languages such as Java, with complex \nconcurrency models [4, Ch. 17], or single-threaded languages such as ECMAScript which do not naturally \nsupport multicore execution, and rely on cooperative multitasking.  Imperative programming: components \nare stateful, and may re\u00adspond to events by updating their internal state. These hidden side-effects \ncan result in complex implicit component interde\u00adpendencies.  Referential opacity: since components \nsupport mutable state, component identity is important. The semantics for components is not referentially \ntransparent, since creating a component and copying it is not equivalent to creating multiple components. \n Callbacks: the idiom for programming in an event-driven model is registering callbacks rather than \nblocking function calls. For example, in ECMAScript an HTTP request is not a blocking method call, but \ninstead a non-blocking call which registers a callback to handle the result of the HTTP request. This \nessen\u00adtially requires the programmer to convert their program to Con\u00adtinuation Passing Style (CPS) [22]. \nManual CPS transformation can be error-prone, for example, calling the wrong continua\u00adtion, or mistakenly \ncalling a continuation twice. In the absence of call/cc, CPS transformation is a whole-program translation, \nso can require a large codebase to be rewritten.  Functional Reactive Programming allows reactive programs \nto be written in a pure functional style. Originally developed by El\u00adliot and Hudak [11] as part of the \nFran functional animation sys\u00ad tem, there are now a number of implementations, including Agda FRP [15], \nFlapjax [20], Frapp\u00b4 e [8], Froc [9], FrTime [7], Grape\u00ad fruit [16], Reactive [10], Reactive-Banana [2], \nand Yampa [23]. Comparing FRP with the event-driven model, we have: Pure functional model: there are \nno implicit interactions caused by shared mutable state, and a simple concurrency model.  Referentially \ntransparent: signals can be copied without alter\u00ading their semantics.  Direct: FRP programs are given \nin direct style rather than CPS.  Comparing FRP with synchronous data.ow languages such as Es\u00adterel \n[3], some key distinctions are: Fine-grained time: FRP often models time as a continuous domain (such \nas R) or using a much .ner unit of time than the sample frequency of a synchronous language (such as \n1ms).  Higher-order signals: FRP allows signals of signals, which model dynamically recon.gurable data.ow \nnetworks.  Embedded DSL: FRP is typically implemented as an embedded DSL library in a functional host \nlanguage (often Haskell, but also Agda [13], ECMAScript [20], Java [8], OCaml [9], or Scheme [7]).  \n In this paper, we consider the problem of liveness of an FRP program. We develop a type system and \nmodel of FRP which provides liveness guarantees.  We show how to de.ne guarded .xed points, and provide \nlive\u00adness in the presence of recursion.  We give an implementation of FRP in terms of programming over \nsets and relations, which are in turn implemented using callbacks.  We discuss a multithreaded Java \nimplementation of the model.  This is the .rst work to provide liveness guarantees for event-based \nprograms in FRP. Moreover, in implementing FRP in terms of a model of sets and relations: The isomorphism \nbetween event sources and behaviours cor\u00adresponds to the isomorphism between relations and set-valued \nfunctions.  The implementation of sets and relations using the usual double-negation CPS transform allows \nthe implementation of behaviours as pull systems based on futures, and of event sources as push systems \nbased on the observer pattern, to arise from .rst principles.  The implementation of event sources as \nrelations allows natu\u00adrally for concurrent execution, and in particular for out-of-order arrival of events. \nMost combinators naturally allow for concur\u00adrency, and it is only combinators which rely on ordering \n(such as an accumulation function) which force an order on events.  This is the .rst such investigation \nof the relationship between FRP and a CPS implementation of sets and relations, and the .rst implementation \nof concurrent FRP using out-of-order events. 2. History-free programs In this section, we present our \ncore FRP model, with types, combi\u00adnators, and their semantics. For readability, we present the model \nin pseudo-Haskell: the actual implementation is in Java, as discussed in Section 6. We start by presenting \nthe combinators for history\u00ad free programs: history-sensitive programs are discussed in the next section. \nThe semantics of FRP is de.ned in terms of behaviours over a total order Time, whose semantics are given \nas total functions from time to values: [Behaviour A] = Time . [A] and event sources which are partial \nfunctions: [Event A] = Time . [A]. where: X. = {.} . {lift x | x . X} We will sometimes refer to signals \nwhen we want to talk about both behaviours and events. The timestamps for events are based on the time \nan event .rst enters the FRP system, not the current wall-clock time. For exam\u00adple, a function on event \nsources which processes a event x with timestamp t to an event f(x) will still emit f(x) with timestamp \nt, irrespective of the running time of f. Signal types come with a collection of combinators such as: \nmap : (A . B) . Event A . Event B .lter : (A . Boolean) . Event A . Event A whose semantics are as one \nmight expect: lift (f x) if s t = lift x [map] f s t = . otherwise lift x if s t = lift x and f x [.lter] \nf s t = . otherwise For example, a simple web server, which responds Hello, World! to any GET request \nmight be written: server : Event HTTPRequest . Event HTTPResponse server reqs = getResps where getReqs \n= .lter isGetRequest reqs getResps = map hello getReqs hello req = httpResponse 200 \"Hello, World!\" \nassuming a library for HTTP messages: isGetRequest : HTTPRequest . Boolean httpResponse : Integer . String \n. HTTPResponse Unfortunately, this server has a serious problem: it suffers from a lack of liveness, \nin that a non-GET request will result in no response at all. To .x this, we introduce explicit error \nhandling: server : Event HTTPRequest . Event HTTPResponse server reqs = union getResps otherResps where \n(getReqs, otherReqs) = partition isGetRequest reqs getResps = map hello getReqs otherResps = map error \notherReqs hello req = httpResponse 200 \"Hello, World!\" error req = httpResponse 405 \"Method not supported.\" \n This uses combinators for partitioning and recombining events: partition : (A . Boolean) . Event A . \n(Event A \u00d7 Event A) union : Event A . Event A . Event A The semantics of partitioning is simple: [partition] \nf s = ([.lter] f s, [.lter] (\u00ac . f) s) The semantics of recombining is not so simple, since we have \nto account for the possibility that events will arrive simultaneously from both sources. The easiest \nthing to do is to prioritize one source over the other, for example to prioritize the .rst source: lift \nx if s t = lift x[union] s t t = t t otherwise Unfortunately, this approach is problematic for three \nreasons: This semantics for union xs ys is not commutative, even though in its idiomatic usage xs and \nys have disjoint domains.  The types for partition and union permit the original buggy server, so do \nnot provide liveness guarantees.  The implementation of union xs ys is dif.cult, in that an event from \nys at time t cannot be emitted until we know that xs will not generate an event at time t. This may cause \nevents from ys to be unnecessarily buffered, and requires the presence of negative information (xs will \nnot generate an event at time t).  For these reasons, we propose an alternative type system for be\u00adhaviours \nand events. Rather than event sources being partial func\u00ad Event T A] = [T ] . [A] Behaviour T A] = [T \n] . [A] [ Minus T S] = [T ] \\ [S] event : Behaviour T A . Event T A [event] s = s bu.er : Event T A \n. Behaviour T A [bu.er] s = s map : (A . B) . Event T A . Event T B [map] f s t = f (s t)  map : (A \n. B) . Behaviour T A . Behaviour T B [map] f s t = f (s t) map2 : (A . B . C) . Behaviour T A . Behaviour \nT B . Behaviour T C [map2] f s t t = f (s t) (t t) map2 : (A . B . C) . Event T A . Behaviour T B . \nEvent T C [map2] f s t t = f (s t) (t t) partition : (A . Boolean) . Event T A . .(S = T )(Event S A \n\u00d7 Event (Minus T S) A) [partition] f s = (X, t, .) where X = {t | f (s t)} and t t = s t and . t = s \nt union : Event S A . Event (Minus T S) A . Event T A [union] s t = s . t Figure 1. History-free fragment, \nwhere [S] . [T ] . Time is locally .nite and well-ordered tions with domain Time, we propose viewing \nthem as total func\u00adtions whose domain is a subset of Time, that is: [Event T A] = [T ] . [A] Since event \nsources are total, they guarantee liveness in the sense that they will produce a value for any time in \n[T ]. For symmetry, we parameterize behaviours by the times at which they change: [Behaviour T A] = [T \n] . [A] To ensure the existence of .xed points, as discussed in Section 3, we require that [T ] . Time \nis locally .nite (that is every interval [s, t] from [T ] is .nite) and well-ordered (every non-empty \nsubset of T has a least element). Note that T is being used as a phantom type [19]: it is a .ction of \nthe types for signals, and its implementa\u00adtion is not necessarily as a subset of Time. Semantically, \nevents and behaviours are equivalent, and indeed they form an isomorphism given by: event : Behaviour \nT A . Event T A bu.er : Event T A . Behaviour T A As we shall see, their implementations are quite different \n(be\u00adhaviours are implemented as pull systems, and events are imple\u00admented as push systems). In particular, \nthe event function intro\u00adduces no overhead, but the bu.er function introduces buffering, and so may have \na signi.cant memory overhead. We are careful about when we use Behaviour types and when we use Event \ntypes to ensure that the only source of buffering from the primitives is the bu.er function. For example, \nwe provide two functions for mapping a binary function over two signals: map2 : (A . B . C) . Behaviour \nT A . Behaviour T B . Behaviour T C map2 : (A . B . C) . In both cases, one of the signals must be a \nbehaviour, and if we wish to combine two event sources, we must .rst buffer one of them, for example \nif xs, ys : Event T Integer then: map2 (\u00b7 + \u00b7) xs (bu.er ys) : Event T Integer We do not provide a combinator: \nmap2 : (A . B . C) . Event T A . Event T A . Event T A since map2 f xs ys cannot be implemented without \nbuffering: an event with timestamp t may arrive from xs at wall-clock time t1, with the matching event \nfrom ys arriving at wall-clock time t2; events must be buffered to allow for the differences in wall-clock \ntime. The type for map is unchanged, and its semantics is simpli.ed, since events are now total: map \n: (A . B) . Event T A . Event T B [map] f s t = f (s t) The type for .lter must change: if xs has domain \nT , then .lter f xs will not have domain T , but will instead have some subdomain of T . To model this, \nwe use bounded existential types [6], with semantics: [.(A = B)(F A)] = {(X, [F ]X) | X . [B]} The type \nand semantics of .lter are then: .lter : (A . Boolean) . Event T A . .(S = T )(Event S A) [.lter] f s \n= (X, t) where X = {t | f (s t)} and t t = s t For example, if: [things] = {0 . apple, 1 . cat, 2 . \nbanana} Event T A . Behaviour T B . Event T C  then: [.lter isFruit things] = ({0, 2}, {0 . apple, 2 \n. banana}) For partitioning, we could just continue to treat a partition as a pair of .lters, which \nwould give the type: partition : (A . Boolean) . Event T A . (.(S = T )(Event S A) \u00d7 .(R = T )(Event \nR A)) However, with this type, we have lost the information that T has been partitioned into S and R. \nInstead, we provide a more re.ned type, in which we set R to be Minus T S: partition : (A . Boolean) \n. Event T A . .(S = T )(Event S A \u00d7 Event (Minus T S) A) where Minus T S is interpreted as set subtraction \n(maintaining an invariant that [S] . [T ]): [Minus T S] = [T ] \\ [S]The semantics of partition is: [partition] \nf s = (X, t, .) where X = {t | f (s t)} and t t = s t and . t = s t For example: [partition isFruit things] \n= ({0, 2}, {0 . apple, 2 . banana}, {1 . cat}) The bene.t of this re.ned type for partition is that it \nallows for a better treatment of union: union : Event S A . Event (Minus T S) A . Event T A [union] s \nt = s . t For example, if we de.ne: mkDog xs = union fruit dogs where (fruit, rest) = partition isFruit \nxs dogs = map (.x . dog) rest then we have: [mkDog things] = {0 . apple, 1 . dog, 2 . banana} This \naddresses the three issues we highlighted earlier: The semantics of union is commutative.  The .xed \nversion of the HTTP server typechecks with type server : Event T HTTPRequest . Event T HTTPResponse. \nThe buggy server does not typecheck with this type. In general, the semantics of Event T A require liveness \nfor all of T .  The implementation of union xs ys is simple: when an event from either xs or ys is generated, \nit can immediately be emitted. No negative information is required.  In Figure 1 we summarize the history-free \nfragment of our model. 3. History-sensitive programs So far the FRP combinators only allow history-free \nprograms to be de.ned, in that output behaviour at time t can only depend on input behaviour at time \nt, not at any time before t. We now present combinators which support history-sensitive programming. \nThe simplest form of history-sensitivity is the delay function, which takes a behaviour, and delays it \nby one unit of time: delay : Behaviour T A . Event (Tail T ) A [delay] s ti+1 = s ti For example: [delay \nthings] = {1 . apple, 2 . cat} Here we are making use of the requirement that T is a locally .nite and \nwell-ordered, since this means that: [T ] = {t0 < t1 < t2 < \u00b7 \u00b7 \u00b7 } In particular we can then de.ne \nthe tail of T to be every element other than the least one: [Tail T ] = if [T ] = \u00d8 then \u00d8 else [T ] \n\\ {t0} We can similarly de.ne the tail of a behaviour to be every element but the .rst: tail : Behaviour \nT A . Behaviour (Tail T ) A [tail] s t = s t For example: [tail things] = {1 . cat, 2 . banana} We \ncannot, however, provide a matching head function with type Behaviour T A . A, since t0 may be in the \nfuture (and indeed T may be empty, so no such A may exist). Instead, we allow a peek function, which \nallows the .rst element to be inspected as long as an event is being produced: peek : Behaviour T A . \n(A . Event T B) . Event T B [peek] s f = f (s t0) For example: [peek things (.x . if isFruit x then \nys else zs)] = [ys] These functions allow signals to be decomposed, we can also com\u00adpose them, for example: \ncons : A . Event (Tail T ) A . Event T A x if t = t0 [cons] x s t = s t otherwise for example: [cons \ndog (event (tail things))]= {0 . dog, 1 . cat, 2 . banana} Finally, we consider recursively de.ned behaviours. \nWe will only allow the solution to guarded equations, in the sense that behaviour at time ti+1 can only \ndepend on recursive behaviour up to time ti. We ensure this by introducing an explicit delay, that is \nwe are solving: s = f ([delay] s) Since all de.nable functions on signals are causal (output at time \nt only depends on input up to time t) we have that s s value at time ti+1 only depends on f ([delay] \ns) s value at time ti+1, which only depends on ([delay] s) s value up to time ti+1, which only depends \non s s value up to time ti. Thus, s is well-de.ned. For a more formal treatment of the well-de.nedness \nof guarded equations, see Krishnaswami and Benton s ultrametric space semantics [18], or the author s \nuse of parametricity to ensure causality [14]. Unfortunately, the obvious type for .xed points: .x : \n(Event (Tail T ) A . Behaviour T A) . Behaviour T A has a problem. We are maintaining an invariant that \nall time do\u00admains are locally .nite and well-ordered, but if we were to allow .x to exist for all T , \nthen we could use it to inhabit Behaviour R+ A, for example: .x(.xs . bu.er(cons(0, xs))) Since R+ is \nlocally in.nite and non-well-ordered, this would be problematic. To avoid this, we introduce a type of \nclocks, which is only inhabited when T . Time is locally .nite and well-ordered, in which case its semantics \nis trivial: [Clock T ] = {*}  Tail T ] = if [T ] = \u00d8 then \u00d8 else [T ] \\ {t0}[ Clock T ] = {*} peek : \nBehaviour T A . (A . Event T B) . Event T B [peek] s f = f (s t0) tail : Behaviour T A . Behaviour (Tail \nT ) A [tail] s t = s t delay : Behaviour T A . Event (Tail T ) A [delay] s ti+1 = s ti cons : A . Event \n(Tail T ) A . Event T A x if t = t0 [cons] x s t = s t otherwise clock : Behaviour T A . Clock T [clock] \ns = *  .x : Clock T . (Event (Tail T ) A . Behaviour T A) . Behaviour T A [.x] c f = s where s = f ([delay] \ns) Figure 2. History-sensitive fragment of our FRP model, where [T ] = {t0 < t1 < t2 < \u00b7 \u00b7 \u00b7 } The modi.ed \ntype for .x uses a clock element to ensure that it is [Set A] = P [A] safe to inhabit Behaviour T A: \nRelation A B = Set (A \u00d7 B) .x : Clock T . (Event (Tail T ) A . Behaviour T A) . Behaviour T A bu.er \n: Relation A B . A . Set B [.x] c f = s where s = f ([delay] s) [bu.er] R x = {y | (x, y) . R} For example, \nwe can use .x to de.ne a constant behaviour: empty : Set A constant : Clock T . A . Behaviour T A [empty] \n= \u00d8 constant c x = .x c (.xs . bu.er(cons(x, xs))) [constant] c x t = x singleton : A . Set A [singleton] \nx = {x} We can also use .x to de.ne an accumulator function: accum : (B . A . B) . B . Behaviour T A \n. Behaviour T B union : Set A . Set A . Set A accum f y xs = .x (clock xs) (.ys . bu.er(map2 f cons(y, \nys) xs)) [union] X Y = X . Y making use of a function to extract a clock from a behaviour: pmap : (A \n. Set B) . Set A . Set B clock : Behaviour T A . Clock T [pmap] f X = {y | x . X, y . f x} [clock] s \n= * .x : ((A . Set B) . (A . Set B)) . A . Set B For example if: [.x] f = the smallest g such that .x \n. f g x . g x s = {t0 . x0, t1 . x1, t2 . x2, . . .} Figure 3. Model of sets and relations then: [accum] \n(\u00b7 + \u00b7) 0 s = and set-valued functions (X . P Y ) given by the functions: {t0 . x0, t1 . (x0 + x1), \nt2 . (x0 + x1 + x2), . . .} relation : Set A . (A . Set B) . Relation A B In Figure 2 we summarize the \nhistory-sensitive fragment of our FRP model. relation xs f = pmap (.x . map (x, \u00b7) (f x)) xs [relation] \nX f = {(x, y) | x . X, y . f x} 4. Implementation of behaviours and events bu.er : Relation A B . A \n. Set B The implementation of signals is built on top of a library of sets [bu.er] R x = {y | (x, y) \n. R} and relations. In Figure 3 we give the model of sets and relations, we defer discussing its implementation \nuntil the next section. It Given a relation R whose domain (that is {x | .y . (x, y) . R}) is provides \ntwo types, for sets and relations: X, we have: [Set A] = P [A] [relation] X ([bu.er] R) = R Relation \nA B = Set (A \u00d7 B) and given a function f whose domain (that is {x | .y . y . f x}) is X, we have: together \nwith a collection of combinators for these types. Of par\u00adticular interest is the isomorphism between \nrelations (P (X \u00d7 Y )) [bu.er] ([relation] X f) = f We shall see later that this isomorphism generates \nthe isomorphism between behaviours and event sources. The combinators include a .xed point function: \n.x : ((A . Set B) . (A . Set B)) . A . Set B [.x] f = the smallest g such that .x . f g x . g x This \nfunction is well-de.ned because the only implementable func\u00adtions are monotone with respect to .. Using \nthe combinators given in Figure 3, we can derive other combinators such as: map : (A . B) . Set A . Set \nB map f = pmap (.x . singleton(f x)) [map] f X = {f x | x . X} pmapr : (B . Set C) . Relation A B . \nRelation A C pmapr f = pmap (.(x, y) . map (x, \u00b7) (f y)) [pmapr] f R = {(x, z) | (x, y) . R, z . f y} \n .lter : (A . Boolean) . Set A . Set A .lter f = pmap (.x . if f x then singleton x else empty) [.lter] \nf X = {x | x . X, f x} domain : Relation A B . Set A domain = map (.(x, ) . x) [domain] R = {x | .y \n. (x, y) . R}  In particular, we can implement the categorical structure of rela\u00adtions, with identity \nand composition: diagonal : Set A . Relation A A diagonal = map (.x . (x, x)) [diagonal] X = {(x, x) \n| x . X} comp : Relation A B . Relation B C . Relation A C comp q r = pmapr (bu.er r) q [comp] Q R = \n{(x, z) | (x, y) . Q, (y, z) . R} We shall now consider an implementation of FRP using sets and relations, \nbeginning with the implementation of clocks. A clock is implemented as an abstract datatype whose implementation \nis: data Clock T = Clock {times : Set Time, .rst : Set Time, prev : Relation Time Time, parent : T } \n We maintain the following invariants about c : Clock T , where [T ] . Time is locally .nite and well-ordered, \nand so [T ] is of the form {t0 < t1 < t2 < \u00b7 \u00b7 \u00b7 }: times c] = [T ]. .rst c] = {t0} (or \u00d8 when [T ] = \n\u00d8). [ prev c] = {(ti+1, ti) | ti+1 > t0}. Note that every element of Clock T is equal (and in fact we \nuse memoization to ensure that every T has at most one Clock T ). Clocks are needed as a way to access \nat run time the total order on T . We can implement a function: tail : Clock T . Clock (Tail T ) tail \nc = Clock { times = domain (prev c) .rst = pmap (.t . domain(.lter (.( , u) . t = u) (prev c))) (.rst \nc) prev = pmap (.t . .lter (.( , u) . t < u) (prev c)) (.rst c) parent = c } The reason for having a \nparent element is to implement: tail-1 : Clock (Tail T ) . Clock T The concrete implementation of Tail \nT is: data Tail T = Tail {clock : Clock T } so we can de.ne: tail-1 c = clock (parent c) The implementation \nof Minus T and minus-1 are similar. We can now turn our attention from clocks to behaviours and event \nsources. The concrete implementation of a behaviour is a clock together with a function from time to \nsets of events: data Behaviour T A = Behaviour {clock : Clock T, function : Time . Set A } and the concrete \nimplementation of an event source is a clock together with a relation between time and events: data Event \nT A = Event {clock : Clock T, relation : Relation Time A } As we shall see when we look at the implementation \nof sets and relations, behaviours are implemented as pull systems, and event sources are implemented \nas push systems. We maintain the follow\u00ading invariants about xs : Behaviour T A and ys : Event T A: \nFor any t . [T ], the set [function xs] t is a singleton.  The domain of [relation ys] is [T ].  For \nany (t, x) . [relation ys] 3 (t, y), we have x = y.  These invariants mean that it is straightforward \nto translate the concrete semantics of signal to their abstract semantics: xs t = the unique x such that \nx . [function xs] t [ ys] t = the unique x such that (t, x) . [relation ys] We can then implement the \nFRP combinators, and verify that they maintain the invariants and have the expected semantics. Most are \nquite straightforward given the model of sets and relations, for example the isomorphism between behaviours \nand events is just given by lifting the isomorphism between functions to sets and relations: event : \nBehaviour T A . Event T A event (Behaviour c f) = Event c (relation (times c) f) bu.er : Event T A . \nBehaviour T A bu.er (Event c r) = Behaviour c (bu.er r)  [Not A] = [A] . 2 bu.er : Not (Not (A \u00d7 B)) \n. A . Not (Not B) [bu.er] k x e = k (. (x', y) . (x = x') . e(y)) discard : Not A [discard] x = false \ndoubleNot : A . Not (Not A) [doubleNot] x k = k x andthen : Not A . Not A . Not A [andthen] k e x = \nk x . e x copmap : (B . Not (Not A)) . Not A . Not B [copmap] f k y = f y k .x : ((A . Not B) . (A . \nNot B)) . A . Not B [.x] f = the smallest g such that .x . .y . f g x y . g x y Figure 4. Model of continuations \n The delay function is implemented by mapping the behaviour over the previous time relation: delay : \nBehaviour T A . Event (Tail T ) A delay (Behaviour c f ) = Event (tail c) (pmapr f (prev c)) The cons \nfunction is just the union of the head and the tail: cons : A . Event (Tail T ) A . Event T A cons x \n(Event c r) = Event c' (union r r') where ' c= tail-1 c '  r= map (.rst c') (.t . (t, x)) The union \nfunction is just union of relations: union : Event S A . Event (Minus T S) A . Event T A union (Event \nq) (Event c r) = Event (minus-1 c) (union q r) We defer a discussion of the implementation of partition \nto Sec\u00adtion 6. The implementation and veri.cation of the remaining prim\u00ad itives is straightforward. 5. \nImplementation of sets and relations The implementation of signals is built on top of a library of contin\u00aduations. \nIn Figure 4 we give the model of continuations, we defer discussing its implementation until the next \nsection. It provides a type of continuations: [Not A] = [A] . 2 together with a collection of combinators \nfor these types. These combinators correspond directly to the combinators for sets, since we can de.ne: \ndata Set A = Set {unSet : Not (Not A))} and then de.ne: bu.er (Set xs) = Set \u00b7 (bu.er xs) empty = Set \ndiscard singleton x = Set (doubleNot x) union (Set xs) (Set ys) = Set (andthen xs ys) pmap f (Set xs) \n= Set (comap (copmap (unSet \u00b7 f))) .x f = Set \u00b7 .x (.g . unSet \u00b7 f (Set \u00b7 g))  public class Events<T,A> \n{ public final Clock<T> clock; public final Relation<Time,A> relation; public<B> Events<T,B> map(Function<A,B> \nf) { ... } public Behaviour<T,A> buffer() { ... } public PartitionedEvents<?,T,A> partition(Predicate<A> \np) { ... } ...  } public interface PartitionedEvents<S extends T,T,A> { public Events<S,A> yes(); public \nEvents<Minus<T,S>,A> no(); public<Z> Z split(Function2< Events<S,A>, Events<Minus<T,S>,A>, Z> f);  \n} Figure 5. Event sources in Java where: comap : (B . A) . Not A . Not B comap f = copmap (.y . doubleNot \n(f y)) We can translate from the concrete semantics of sets to their ab\u00adstract semantics as: [xs] = \n{x | [unSet xs] (.x' . x = x')} It is straightforward to verify that the combinators on sets have their \nexpected semantics. We have now shown that a model of FRP can be translated into a model of sets and \nrelations, and from there to continuations. Composing these translations, we get: Behaviour T A . Clock \nT \u00d7 (Time . Not (Not A)) Event T A . Clock T \u00d7 Not (Not (Time \u00d7 A)) that is: Behaviours are implemented \nas pull systems: a user of a be\u00adhaviour can call it with a time t . [T ], and receive back a future value, \nof type Not (Not A). A client can then register callbacks of type Not A with the future, which will be \nexecuted when the value is known. Since we maintain an invariant that behaviours return singletons, each \ncallback will be executed precisely once.  Events are implemented as push systems: a user of an event \ncan register a callback of type Not(Time\u00d7A) with it, which will be executed with pairs (t, x) whenever \nan event x arrives at time t. We maintain an invariant that each time t has a unique x, and that all \ntimes t . [T ] will generate an event.  It is interesting that the implementation of reactive programs \nas push or pull systems, and the uses of futures and the observer pat\u00adtern fall out naturally from the \ntranslation of signals to sets and re\u00adlations, and then to continuations. Moreover, the isomorphism be\u00adtween \npush systems and pull systems is given by the isomorphism between relations and set-valued functions. \n public<T> Events<T,HttpResponse> responses(Events<T,HttpRequest> requests) { return requests.partition(request \n-> request.isGetRequest() ).split((getReqs,otherReqs) -> getReqs.map(request -> new HttpResponse(200,\"Hello, \nWorld!\") ).union(otherReqs.map(request -> new HttpResponse(405) )) ); } Figure 6. Example Hello, World! \nserver implemented in Java public interface Not<A> { public void accept(A x); default public<B> Not<B> \ncomap(Function<B,A> f) { return y -> { this.accept(f.apply(y)); }; } default public Not<A> andthen(Not<A> \nother) { return x -> { this.accept(x); other.accept(x); }; } ... } public interface Not2<A,B> { public \nvoid accept(A x, B y); ...  } Figure 7. Continuation classes in Java 6. Java implementation The FRP \nimplementation is in Java, and is a direct translation of the model discussed in Sections 2 5. Part of \nthe interface for event sources is given in Figure 5, and is the Java equivalent of the relevant fragment \nof Figure 1. We make use of Java 8 s support for anonymous functions (where .x . M is written in Java \nas x -> M). There is a slight difference in the way Java treats bounded existential types, which is by \nwildcarding (the ? type in the return type of partition). Java does not support direct unpacking of existential \ntypes, and instead unpacking must be performed by helper functions. For example in Java one cannot write: \nEvents<T,Integer> xs = ...; PartitionedEvents<S,T,Integer> p = xs.partition(x -> 0 <= x); Events<S,Integer> \npos = p.yes(); Events<Minus<T,S>,Integer> neg = p.no(); return pos.union(neg.map(Math.abs));  because \nthere is no way to introduce the new bound type variable S. Instead, one writes: Events<T,Integer> xs \n= ...; public class NotImpl<A> implements Not<A> { protected List<Not<A>> conts; final WeakReference<NotNotImpl<A>> \nnot; public NotImpl(NotNotImpl<A> not) { this.not = new WeakReference<>(not); } public void accept(A \nx) { List<Not<A>> ks; NotNotImpl<A> not; synchronized(this) { ks = this.conts; not = this.not.get(); \nif (not != null) { not.values = new List<>(x,not.values); } } while (ks != null) { ks.hd.accept(x); \nks = ks.tl; } }  } public class NotNotImpl<A> implements Not<Not<A>> { protected List<A> values; final \nNotImpl<A> not = new NotImpl<>(this); public void accept(Not<A> k) { List<A> xs; synchronized(this.not) \n{ xs = this.values; this.not.conts = new List<>(k,this.not.conts); } while (xs != null) { k.accept(xs.hd); \nxs = xs.tl; } }  } Figure 8. Mutable implementation of continuations return xs.partition(x -> 0 <= x \n).split((pos,neg) -> pos.union(neg.map(Math.abs)) )  Inside the anonymous helper function, an anonymous \ntype variable S is created, pos is given type Events<S,Integer> and neg is given type Events<Minus<T,S>,Integer>. \nThe example Hello, World! web application is shown in Fig\u00adure 6. An implementation of an asynchronous \nservlet allows it to execute in any servlet container, resulting in the interactions: $ curl -i localhost:8080/hello \nHTTP/1.1 200 OK Content-Length: 13 Server: Jetty(9.0.0.M5) Hello, World! public class FunctionNotNotRef<A,B> \nimplements Function<A,Not<Not<B>>>, Not<Function<A,Not<Not<B>>>> { protected Function<A,Not<Not<B>>> \ndelegate; protected HashMap<A,NotNotImpl<B>> cache = new HashMap<>(); public Not<Not<B>> apply(A x) \n{ Function<A,Not<Not<B>>> f; NotNotImpl<B> k = null; synchronized (this) { f = this.delegate; if (f \n== null) { k = this.cache.get(x); if (k == null) { k = new NotNotImpl<B>(); this.cache.put(x,k); } } \n} if (f == null) { return k; } else { return f.apply(x); } } public void accept(Function<A,Not<Not<B>>> \nf) { HashMap<A,NotNotImpl<B>> cache; synchronized (this) { cache = this.cache; this.cache = null; this.delegate \n= f; } for( Entry<A,NotNotImpl<B>> e : cache.entrySet() ) { A x = e.getKey(); Not<B> k = e.getValue().not; \nf.apply(x).accept(k); } }  } public<A,B> Function<A,Not<Not<B>>> fix( Function< Function<A,Not<Not<B>>>, \nFunction<A,Not<Not<B>>>  > f ) { FunctionNotNotRef<A,B> g = new FunctionNotNotRef<A,B>(); Function<A,Not<Not<B>>> \nh = f.apply(g); g.accept(h); return h;  } Figure 9. Implementation of .x public class FunctionNotNotImpl<A,B> \nimplements Function<A,Not<Not<B>>>, Not2<A,B> { final WeakHashMap<A,NotNotImpl<B>> cache = new WeakHashMap<>(); \n public synchronized NotNotImpl<B> apply(A x) { NotNotImpl<B> k = this.cache.get(x); if (k == null) { \nk = new NotNotImpl<B>(); this.cache.put(x,k); } return k; } public void accept(A x, B y) { this.apply(x).not.accept(y); \n}  } public<A,B> Function<A,Not<Not<B>>> buffer(Not<Not2<A,B>> k) { FunctionNotNotImpl<A,B> f = new \nFunctionNotNotImpl<A,B>(); k.accept(f); return f;  } Figure 10. Implementation of bu.er and: curl -i \n-d \"Stuff\" localhost:8080/hello HTTP/1.1 405 Method Not Allowed Content-Length: 0 Server: Jetty(9.0.0.M5) \nMost of the work in the FRP implementation is in implement\u00ading the continuation classes Not<A> which \nrepresents Not A and Not2<A,B> which represents Not (A \u00d7 B). The implementa\u00adtion of Not<A> is as an interface \nwith a single abstract method void accept(A x). This method is allowed to be side-effecting (although \ncare is required from any programmer working at this low level to respect the high-level semantics). \nFigure 7 shows some of the implementation of the classes. One implementation of continuations is a pair \nof mutable con\u00adtainers, given in Figure 8. One is a container of Not A continua\u00adtions, and implements \nNot A; the other is a container of A values, and implements Not (Not A). When a new continuation is added \n(by calling accept on the value container), it is applied to all of the existing values. Similarly when \na new value is added (by call\u00ading accept on the continuation container), all the existing contin\u00aduations \nare applied to it. Note that there is only a weak reference from the continuation container to the value \ncontainer, so the value container can be garbage collected without impacting the continu\u00adation container. \nTo ensure thread-safety of the implementation, appropriate locking is used on critical sections. Note \nthat we never call any callbacks while holding a lock, so there is never any attempt to acquire two locks \nsimultaneously. Thus, the code is deadlock-free, and will not introduce issues with liveness. public \nclass ClockImpl<T> extends Clock<T> { final Not<Time> ntimes; final Not<Time> nfirst; final Not2<Time,Time> \nnprev; ...  } public class EventsImpl<T,A> extends Events<T,A> { final public ClockImpl<T> clock; final \npublic Not2<Time,A> nrelation; ...  } public class PartitionedEventsImpl<T,A> implements PartitionedEvents<T,T,A> \n{ final Predicate<A> pred; final EventsImpl<T,A> yes; final EventsImpl<Minus<T,T>,A> no; final WeakHashMap<Time,Boolean> \nflags; final HashMap<Time,Time> prevUnknown; final HashMap<Time,Time> nextUnknown; final HashMap<Time,Time> \nprevSame; final HashMap<Time,Time> nextSame; Time first = null; public PartitionedEventsImpl( Predicate<A> \npred, Events<T,A> xs ) { this.pred = pred; this.yes = new EventsImpl<>(...); this.no = new EventsImpl<>(...); \nxs.relation.pairs.accept(this::acceptEvent); ... } public void emitTime(Time t, Boolean flag) { if (flag) \n{ this.yes.clock.ntimes.accept(t); } else { this.no.clock.ntimes.accept(t); } } public void emitEvent(Time \nt, A x, Boolean flag) { if (flag) { this.yes.nrelation.accept(t,x); } else { this.no.nrelation.accept(t,x); \n} } public void acceptEvent(Time t, A x) { Boolean tflag = this.pred.apply(x); synchronized (this) { \nthis.flags.put(t,tflag); } this.emitEvent(t,x,tflag); this.emitTime(t,tflag); ... } ... } The two methods \nof Not A which require effort are .x (which .nds the .xed point of set-valued functions) and bu.er (which \nimplements half of the isomorphism between relations and set\u00advalued functions). These two functions are \nimplemented similarly, in that under the hood they are based on mutable continuations, and use a HashMap \nto buffer values. The implementations are given in Figures 9 and 10. In the case of .x, we make use of \na class FunctionNotNotRef which implements A . Not (Not B) by acting as a delegate to another function \nof the same type. Crucially, the delegate may be set after the reference has been created, so the function \nhas to respond to apply in the absence of its delegate. It does so by creating a new mutable Not (Not \nA), which it stores in a cache before returning. When the delegate is set, it runs through the cache, \ninitializing all of the cached continuations appropriately. Thus, a suitable mix of buffering and mutable \nstate allows cyclic structures to be built which give the appearance of pure functional .xed points. \nThe implementation of bu.er is similar, but there is one crucial difference. In the case of .x, the buffering \nis only required after the reference has been created, but its delegate is initialized. In most cases, \nthis will be transitory, and the buffer will not be long-lived. In the case of bu.er, the buffer will \nbe long-lived, and we need to take care that it does not cause a space leak. For this reason, we use \na weak hash map to store the buffer. When a key in the buffer can be garbage collected, it will be, and \nthe corresponding value will be removed. In its use in the FRP implementation, FunctionNotNotImpl is \nalways used to implement a function of type Time . Not (Not A), and so every use of buffering will introduce \na WeakHashMap whose keys are Time. This makes Time objects quite expensive: even though each Time object \nis small (just containing a long times\u00adtamp) each live Time object is also keeping alive many entries \nin a buffer. For this reason, the FRP interface does not expose Time ob\u00adjects to user code, since it \nwould be very easy to introduce a space leak by holding on to a time object. In our setting, this is \nthe form that time leaks take [21], even though Java is a strict language. There is one method of signals \nwhich we implement directly at a low level rather than going through the abstraction of sets and relations. \nAn outline of the implementation of partition is given in Figure 11. It uses implementations of Clock \nT and Event T A which are backed by mutable sets to create two new event sources yes and no. When an \nevent x arrives at time t, it calls pred on x to determine whether to send the event on to yes or to \nno. Most of the effort is in implementing yes.clock and no.clock, and to do this we maintain the following \ndata structures: flags is a map from Time to Boolean such that (t, b) . flags] whenever there is some \n(t, x) . [xs.relation] and[ pred] x = b,  prevUnknown is a map from Time to Time such that (t, s) . \n[prevUnknown] whenever s . t and either s or t is not in the domain of [flags],  nextUnknown is the \ninverse of prevUnknown,  prevSame is a map from Time to Time such that (t, s) . [prevSame] whenever \ns . * ?/c t and there is no r .?/c s,  nextSame is a map from Time to Time such that (s, t) . [prevSame] \nwhenever s b/? t and there is no t .b/? u, . * and first . [xs.clock.first], where we write: Figure \n11. Implementation of partition s . t whenever (t, s) . [xs.clock.prev],  s .b/c t whenever s . t and \n(s, b) . [flags] 3 (t, c), s .b/? t whenever s .b/c t for some c, and  s .?/c t whenever s .b/c t for \nsome b.  This data is enough to construct yes.clock and no.clock, for example (t, s) . [yes.clock.prev] \nwhenever: s .true/true t or s .true/false \u00b7 . * false/false \u00b7 .false/true t One unusual feature of our \nFRP implementation is that it allows out-of-order arrival of events. Due to multithreading, it is possible \nthat an event (t, x) will arrive before an event (u, y) even when t > u. For example FrTime [7] makes \nuse of an ordering scheme similar to that of Acar s [1] self-adjusting computation to ensure in\u00ad order \narrival of events. In our setting, we are prioritizing liveness over execution order, and so we only \nintroduce time dependencies where they are needed (for example in accum) and allow most event sources \nto proceed at their own pace. 7. Comparison with push/pull FRP The most closely related work is Elliott \ns [10] push-pull FRP. Elliott reconstructs the behaviour and event source types using futures. Elliott \ns type Future A can be encoded in our system as: Future A = Not (Not (Time \u00d7 A)) so Elliott s type for \nevent sources: Event A = Future (A \u00d7 Event A) is the equivalent of: Event A = Not (Not (Time \u00d7 A \u00d7 Event \nA)) Comparing this to our type: Event T A = Not (Not (Time \u00d7 A)) we can see some of the important distinctions \nbetween the ap\u00adproaches: Push-pull FRP is based on the one-shot Future type, rather than the implementation \nof Set using callbacks.  In push-pull FRP, events are guaranteed to arrive in order. If (s, x, s) . \n. and (t, y, t ) . s then s < t. In our implementa\u00adtion of FRP, events may arrive out-of-order. In particular, \npush\u00adpull FRP uses McCarthy amb to implement union. Out-of-order events also occur in Jeltsch s push-based \nFRP [17, \u00a74.2.6].  Push-pull FRP does not make use of the isomorphism between relations and set-valued \nfunctions.  There are also some differences of focus: we have focused on liveness, which is not an \nissue in push-pull FRP, and we have not focussed on continuous-time behaviours. 8. Conclusions and future \nwork We have presented a model of FRP which provides liveness guar\u00adantees by static typing. The implementation \nof FRP is based on a model of sets and relations, which in turn is implemented using continuations. This \nimplementation shows how the pull implemen\u00adtation of behaviours using futures, and the push implementation \nof event sources using the observer pattern, arise naturally. There are two areas of future work: on \nstopping space and time leaks and on distribution. Currently, there is effort made to ensure that signals \ndo not cause space and time leaks, by appropriate use of weak pointers. However, it is possible for users \nto cause a leak by keeping a reference to a signal live. We are already tracking time domains, so it \nshould be possible to use them as Jeltsch s [16] era parameters, and ensure that signals do not have \nto buffer all their events. The Java implementation of the FRP library is already linked against a servlet \nclass, to allow it to be used as the processing en\u00adgine in an HTTP server. It would be interesting to \nsee if HTTP could be used as the communication protocol between FRP in\u00adstances, and so build a distributed \nFRP implementation. References [1] U. A. Acar. Self-Adjusting Computation. PhD thesis, Carnegie Mellon \nUniv., 2005. [2] H. Apfelmus. http://www.haskell.org/haskellwiki/ Reactive-banana. [3] G. Berry and G. \nGonthier. The Esterel synchronous programming lan\u00adguage: Design, semantics, implementation. Sci. Computer \nProgram\u00adming, 19(2):87 152, 1992. [4] G. Bracha, J. Gosling, B. Joy, and G. Steele. The Java Language \nSpeci.cation. Sun Microsystems, third edition, 2005. [5] S. Burbeck. Applications programming in Smalltalk-80: \nHow to use model-view-controller (MVC), 1987. [6] L. Cardelli and P. Wegner. On understanding types, \ndata abstraction, and polymorphism. ACM Comput. Surv., 28(150), 1985. [7] G. H. Cooper and S. Krishnamurthi. \nEmbedding dynamic data.ow in a call-by-value language. In Proc. European Symp. on Programming, pages \n294 308, 2006. [8] A. Courtney. Frapp\u00b4 In e: Functional reactive programming in Java. Proc. Symp. Pratical \nAspects of Declarative Languages, pages 29 44, 2001. [9] J. Donham. Functional reactive programming in \nOCaml. https: //github.com/jaked/froc. [10] C. Elliott. Push-pull functional reactive programming. In \nProc. Haskell Symp., 2009. [11] C. Elliott and P. Hudak. Functional reactive animation. In Proc. Int. \nConf. Functional Programming, pages 263 273, 1997. [12] C. Hewitt, P. Bishop, and R. Steiger. A universal \nmodular actor formalism for arti.cial intelligence. Proc. Int. Joint Conf. Arti.cial Intelligence, pages \n235 245, 1973. [13] A. S. A. Jeffrey. https://github.com/agda/agda-frp-js/. [14] A. S. A. Jeffrey. Causality \nfor free!: Parametricity implies causality for functional reactive programs. In Proc. ACM Workshop Programming \nLanguges meets Program Veri.cation, pages 57 68, 2013. [15] A. S. A. Jeffrey. Provably correct web applications: \nFRP in Agda in HTML5. In Proc. Int. Symp. Practical Aspects of Declarative Languages, 2013. [16] W. Jeltsch. \nSignals, not generators! In Proc. Symp. Trends in Func\u00adtional Programming, pages 283 297, 2009. [17] \nW. Jeltsch. Strongly Typed and Ef.cient Functional Reactive Program\u00adming. PhD thesis, BTU Cottbus, 2012. \n[18] N. Krishnaswami and N. Benton. Ultrametric semantics of reactive programs. In Proc. IEEE Logic in \nComputer Science, pages 257 266, 2011. [19] D. Leijen and E. Meijer. Domain speci.c embedded compilers. \nIn Proc. Conf. Domain-Speci.c Languages, pages 109 122, 1999. [20] L. A. Meyerovich, A. Guha, J. Baskin, \nG. H. Cooper, M. Greenberg, A. Brom.eld, and S. Krishnamurthi. Flapjax: A programming lan\u00adguage for ajax \napplications. In Proc, ACM Conf. Object-Oriented Pro\u00adgramming Systems, Languages and Applications, pages \n1 20, 2009. [21] H. Nilsson, A. Courtney, and J. Peterson. Functional reactive program\u00adming, continued. \nIn Proc. ACM Workshop on Haskell, pages 51 64, 2002. [22] G. Plotkin. Call-by-name, call-by-value, and \nthe .-calculus. Theoret\u00adical Computer Science, 1:125 159, 1975. [23] Yale Haskell Group. Yampa library \nfor programming hybrid systems. http://www.haskell.org/haskellwiki/Yampa.  \n\t\t\t", "proc_id": "2500365", "abstract": "<p>Functional Reactive Programming (FRP) is an approach to the development of reactive systems which provides a pure functional interface, but which may be implemented as an abstraction of an imperative event-driven layer. FRP systems typically provide a model of behaviours (total time-indexed values, implemented as pull systems) and event sources (partial time-indexed values, implemented as push systems). In this paper, we investigate a type system for event-driven FRP programs which provide liveness guarantees, that is every input event is guaranteed to generate an output event. We show that FRP can be implemented on top of a model of sets and relations, and that the isomorphism between event sources and behaviours corresponds to the isomorphism between relations and set-valued functions. We then implement sets and relations using a model of continuations using the usual double-negation CPS transform. The implementation of behaviours as pull systems based on futures, and of event sources as push systems based on the observer pattern, thus arises from first principles. We also discuss a Java implementation of the FRP model.</p>", "authors": [{"name": "Alan Jeffrey", "author_profile_id": "81100380257", "affiliation": "Alcatel-Lucent, Naperville, IL, USA", "person_id": "P4261249", "email_address": "ajeffrey@bell-labs.com", "orcid_id": ""}], "doi_number": "10.1145/2500365.2500584", "year": "2013", "article_id": "2500584", "conference": "ICFP", "title": "Functional reactive programming with liveness guarantees", "url": "http://dl.acm.org/citation.cfm?id=2500584"}