{"article_publication_date": "09-25-2013", "fulltext": "\n Type-Theory In Color Jean-Philippe Bernardy Guilhem Moulin Chalmers University of Technology and University \nof Gothenburg {bernardy,mouling}@chalmers.se Abstract Dependent type-theory aims to become the standard \nway to formal\u00adize mathematics at the same time as displacing traditional platforms for high-assurance \nprogramming. However, current implementa\u00adtions of type theory are still lacking, in the sense that some \nobvious truths require explicit proofs, making type-theory awkward to use for many applications, both \nin formalization and programming. In particular, notions of erasure are poorly supported. In this paper \nwe propose an extension of type-theory with col\u00adored terms, color erasure and interpretation of colored \ntypes as predicates. The result is a more powerful type-theory: some de.ni\u00adtions and proofs may be omitted \nas they become trivial, it becomes easier to program with precise types, and some parametricity re\u00adsults \ncan be internalized. Categories and Subject Descriptors F.4.1 [Mathematical logic]: Lambda calculus and \nrelated systems Keywords type-theory, parametricity, erasure 1. Introduction Intelligent use of color \nin a written argument can go a long way into conveying an idea. But how convincing can it really be? \nConsider the case of the computer scientist Philip Wadler, who is fond of using color in his papers. \nOn multiple occasions, Wadler (2003, 2007, 2012) presents a programming language and its type-system, \nand shows that, by erasing the appropriate parts of the type-system, a logic appears. This is done by \na straightforward but clever use of colors. Typically, in the presentation of a typing rule, the program \nparts are written in blue. The corresponding logic rule appears if one erases that color. As Wadler suggests, \none can see the erasure simply by putting on blue glasses. f :A . B u :A A . B A f u :B B Typing rule \nfor application After erasure: modus ponens The relationship between the programming language and the \nlogic is deep: for every aspect of the language, there is a blue part that can be erased away to obtain \nthe corresponding logical concept. For example, a computation step on the programming side yields a cut-elimination \nstep on the logic side. That is, Wadler does not play Permission to make digital or hard copies of all \nor part of this work for personal or classroom use is granted without fee provided that copies are not \nmade or distributed for pro.t or commercial advantage and that copies bear this notice and the full citation \non the .rst page. Copyrights for components of this work owned by others than the author(s) must be honored. \nAbstracting with credit is permitted. To copy otherwise, or republish, to post on servers or to redistribute \nto lists, requires prior speci.c permission and/or a fee. Request permissions from permissions@acm.org. \n ICFP 13, September 25 27, 2013, Boston, MA, USA. Copyright is held by the owner/author(s). Publication \nrights licensed to ACM. ACM 978-1-4503-2326-0/13/09. . . $15.00. http://dx.doi.org/10.1145/2500365.2500577 \n mindlessly with colors, he is consistent; he follows in fact a precise (however unwritten) logic of \ncolors1. In fact, his proofs by putting on glasses are extremely compelling. In this paper, we set-out \nto formalize this kind of reasoning with colors as an extension of dependent type-theory. The result \nis a more powerful type-theory: some de.nitions and proofs may be omitted as they become trivial; it \nbecomes easier to program with precise types; and some propositions that were impossible to prove now \nbecome provable. In Sec. 2 we demonstrate how one can program and reason with colors via a number of \nexamples, and introduce the fundamental concepts of type-theory with color at the same time. In Sec. \n3, we describe CCCC (the main technical contribution of this pa\u00adper), a core calculus of constructions \nwith colors, and prove meta\u00adtheoretical properties (subject-reduction, normalization). In Sec. 4, we \ndiscuss some possible extensions of CCCC. Related work is discussed in Sec. 5, and we conclude in Sec. \n6. 2. Programming And Reasoning With Colors In this section we explain how we envision a full-featured \ntype\u00adtheory with color (TTC) would be designed, in the form of a short tutorial. We assume familiarity \nwith a proof assistant based on type\u00adtheory such as AG DA or CO Q (Norell 2007; The Coq development team \n2012). 2.1 Colored Lists We start with an example similar in structure, but signi.cantly simpler than \nthose presented by Wadler. In the standard inductive de.nition of lists, the structure of the list does \nnot depend on the elements it contains. Hence, it makes sense to color the elements: erasing that color \nyields a meaningful de.nition. In fact, the result is structurally equal to the usual unary representation \nof natural numbers: N = LList aji (In this section we assume a color i that we render in blue. Even though \nwe strongly recommend reading the colored version, we index an i-tainted typing with i, so readers can \nmake sense of what follows even if it is printed in black and white.) data List (a :i *) : * stop : List \na more : (x :i a) . List a . List a data List : * stop : List more : List . List As in Wadler s examples, \nthe relationship between colored objects and their erasure carries over everywhere. For example, erasing \n1 A meta-level logic, not to be confused with the object logics studied by Wadler.  color from a given \nlist yields its length and the typing relation is preserved. ' ' more 'b' (more 'l' (more ustop)) : \nList Char more (more (more stop)) : List Concatenation yields addition; assuming a :i * : (+) : List \na . List a . List a stop + xs = xs more x xs + ys = more x (xs + ys) (+) : List . List . List stop + \nxs = xs more xs + ys = more (xs + ys) This structural relation is a bene.t of abiding to color discipline: \ncolorless parts shall never refer to tainted ones, and in return one gets some equalities for free. For \nexample, the length of the con\u00adcatenation is the addition of the lengths. This proposition requires a \nproof in AGDA or CO Q, but thanks to colors, it holds by de.ni\u00adtion. Writing Ltji for the i-erasure of \nt: Lxs + ysji = Lxsji + Lysji In fact, TTC does not have a special purpose operator for erasure: the \ncontext determines whether variables refer to complete objects or to their erasures. For example in the \nfollowing signature, the annotation i indicates that type of the .rst argument of < is any type which \nyields Nafter erasing i. (We will say that xs is oblivious to i in the de.nition of <.) (<) : (xs : i \nN) . (y : N) . Bool Hence, if xs : List a then xs < 5 is a valid expression2; and it tests whether xs \nhas less than 5 elements. The expression 3 < 5 is also type-correct, because the erasure is idempotent. \nIn general, it has no effect on terms which do not mention the erased color (LNji = N). We note also \nalready that substitution behaves specially on oblivious arguments. Consider again the expression xs \n< 5. In it, one can substitute for xs a concrete list containing information. The remarkable feature \nis that in the resulting term, the erased list will stand for xs. For example: ' ''' b' l' (xs < 5)[more \n(more (more ustop))/xs] = more (more (more stop)) < 5 = 3 < 5  2.2 Types as predicates By using colored \ntypes, one effectively speci.es structural invari\u00adants. For example, the type of the above concatenation \noperation constrains the length of its result. In our TTC it is possible to reveal these invariants explicitly \nby viewing types as predicates, and terms as proofs that the predicates are satis.ed by the i-erasure. \nThis is done by modulating the typing judgment. For example, under the modality i, the type of lists \nis seen as a predicate over N. To indi\u00adcate that the judgment is modulated, the typing operator (colon) \nis indexed with i. List (a :i *) :i (xs : i N) . * Any typing can be so modulated. For example, a list \nxs : List a becomes a proof that Lxsji satis.es the List a seen as a predicate. xs :i List a i xs (To \navoid confusion we write predicate test using the i operator. Formally it is just the application corresponding \nto i-oblivious 2 We take the liberty to use decimal notation for unary naturals. abstraction.) Likewise, \nthe concatenation returns a list whose length is the sum of the lengths of its inputs. (+) :i (xs : List \na) . (ys : List a) . List a i (xs + ys) (To make sense of the above typings, recall that the second ar\u00adgument \nto List is a natural after erasing i; in general a variable xs :i List a i n stands for a list of size \nn.) Additionally, we remark that even though every type becomes a predicate, the computations (or data) \nthat it represents do not essentially change. Taking our list example, the union of the types List a \ni n for any n : N is isomorphic to List a seen as a type. Hence, assuming one has existential quanti.cation, \nthe type A : * remains available as a type under the modality i, as .x.A x : *. Hence, one can continue \nto use types as types, even under a colored typing, referring implicitly to the above existential construction. \nWe will take advantage of this shortcut in Sec. 2.4 for concision. 2.3 Colored Pairs Another (dual) \nway to introduce colors is via pairs. A colored pair type, whose general form is written (x : A) \u00d7i B, \nis similar to the usual type S(x : A) B (in particular x may occur in B). The dif\u00adference is that B is \ntainted with the color i; and A is oblivious to i. Given a : A and b :i B[a/x] one can construct an inhabitant \nof the pair type. As usual, colors must match: a,i b : (x : A) \u00d7i B is valid only if b is tainted and \na is oblivious to i. Erasure extracts the .rst component of a pair, and interpreting a pair as a predi\u00adcate \nyields its second component. The following example illustrates how colored pairs can be used to prove \nsome parametricity proper\u00adties. Assume the following (i-oblivious) context. f : (a : *) . a . a b : \n* y : b  We then can de.ne t : (x : b) \u00d7i (x = y) t = f ((x : b) \u00d7i (x = y)) (y,i re.) By de.nition \nof erasure: Ltji = f by (1) The above equation can also be intuited by looking at t under i\u00adglasses: \nf (( b) \u00d7i (Lxji = y)) (y ) In an i-modulated typing, one implicitly refers to the colored com\u00adponent \nof pairs, and therefore we have: t :i Ltji = y. By (1) we obtain t :i f by = y This result is normally \nobtained by a logical relation argument out\u00adside the theory, while it is internalized here albeit via \na judgment with an extra color. (A fully formal version of this example is pre\u00adsented in Sec. 4.) It \nmay be worth stressing that, if one were to use a regular pair type, then, because f is abstract, the \n.rst component of t would not compute. In contrast, erasure is de.ned even on neutral terms.  2.4 Multiple \nColors We propose to support arbitrarily many colors. This feature is important for compositionality: \nit ensures that one can always mark a binding as tainted without corrupting interactions with the rest \nof the program. Indeed the other parts of the programs will use other, orthogonal colors. For example, \nthe List a type described above is suf.cient, there is no need to de.ne a version without color. If one \nneeds to access the elements of the list in a function, one simply taints its typing with the color. \nFor example, a summation function may be given the type sum :i List N . N. The taint will be transitively \ninherited by all functions using sum (and they can use other colors at will).  In fact, it is advisable \nto use colors even more effectively, and instead de.ne sum by erasure. Assume the following de.nition \nof concat, where the nested lists use a different color j for the type a of elements, which we render \nin red. (In the type of concat, a occurs in an i-tainted context, so it is tainted both with i and j. \nWe have a :ij *, and we render it with the combination of blue and red: magenta). concat :i List (List \na) . List a concat stop = stop concat (more x xs) = x + concat xs Then one can obtain sum by erasing \nj from concat: (sum = Lconcatjj ). This would be impossible with a single color: attempt\u00ading to erase \nthe elements of the inner lists would erase the whole function. Another use for multiple colors is to \nnest pairs. One cannot nest pairs which differentiate on the same given color, because this would break \nthe rule that either side of an i-colored pair must respectively be oblivious to i or be tainted with \nit. However one can nest pairs which use different colors. The general form of j-colored pairs nested \ninside an i-colored one is the following: (x : (w : A) \u00d7j B[w]) \u00d7i ((z : C[x]) \u00d7j D[x, z]) C can only \nrefer to the j-oblivious part of x. C may not refer to the j-tainted part of w, since it does not carry \nthat color itself. Looking at the above type successively with i and j glasses3: ( (w : A) \u00d7j B[w]) \u00d7i \n((z : C[x]) \u00d7j D[x, z]) (x : ( A) \u00d7j B[w]) \u00d7i (( C[x]) \u00d7j D[x, z]) Using nested pairs is syntactically \ninconvenient, hence in the rest of the section we use a record-like syntax. Using record syntax, the \nabove pair would be written {w : ij A; y : i B[w]; z : j C[w]; D((w,j y) , z)} The following example \nillustrates how multiple colors can be used to program with relations. Assume a de.nition of streams \nStream : * . *. Stream is a functor as witnessed by map : (a : *) . (b : *) . (a . b) . Stream a . Stream \nb, with usual de.nitions. Assume furthermore the following abstract context: nth : (a : *) . Stream a \n. N . a a : * b : * f : a . b  xs : Stream a n : N 3 The analogy to perceptual colors still holds \nhere: magenta both appears blue under blue glasses and red under red glasses. (i.e. it fades into the \nbackground in both cases.) The analogy breaks only when one uses too many colors: most humans can only \nperceive three primary colors, while we allow an unbounded number of colors in TTC. We de.ne: r : * r \n= {x : i a; y : j b; f x = y}  u : a . r u = .z.{x =z; y =f z; re.}  t : r  t = nth r (map u xs) n \n= nth {x : i a; y : j b; f x = y} (map (.z.{x =z; y =f z; re.}) xs) n Erasing colors from t yields: \nLtji = nth a (map ida xs) n = nth a xs n Ltjj = nth b (map f xs) n Indeed, looking at t respectively \nunder i-colored and j-colored glasses: nth { a } (map (.z.{ z }) xs) n nth { b } (map (.z.{ f z }) xs) \nn Now, viewing t under the i then {i, j}-modalities: t : r t :i r Ltji  t :i,j r Ltji Ltjj t :i,j f \nLtji = Ltjj t :i,j f(nth a xs n) = nth b (map f xs) n Hence writing nth a xs n as xs !! n, we obtain \nthe expected commuting law f(xs !! n) = map f xs !! n.  2.5 Conclusion A motto of programming with \ndependent types is to use more and more types to express one s intentions more and more precisely. However, \nthere is a drawback to precise types: hard work to con\u00ad vince a type-checker that programs inhabit them. \nWe observe that the use of colors is a way to specify invariants in types which does not complicate user \ncode. For instance we have seen that it is just as easy to program with colored lists as with regular \nones, and length invariants are captured. Furthermore, the system can automatically discover equations \nwhich would require a proof without the use of colors. One cannot go wrong by using more colors in a \nlibrary. In the worst case, colors can simply be ignored by the users of the library. In the best case, \nthey serve to specify invariants concisely, facilitate reasoning, and provide a variant of the library \nto the user for each possible erasure combination. We have implemented a prototype of TTC as an extension \nof the AGDA system. The prototype, in its current version at the time of writing, features colored bindings \nand abstraction over colors, but is still lacking erasure, oblivious bindings and col\u00ad ored pairs. The \nprototype, together with a short tutorial for it, can be obtained online: http://www.cse.chalmers.se/~mouling/ \nParametricity/TTC.html. 3. CCCC: A Core Calculus of Colored Constructions In this section we present \nCCCC (the Core Calculus of Colored Constructions) which is the formal core of the TTC we envision.  \nTechnically, CCCC is an extension of CC (the plain Calculus of Constructions (Coquand and Huet 1986)) \nwith the notion of color informally introduced in the previous section. Even though we use CC as a base, \nwe do not rely on its speci.cs. Along the lines presented here, it is conceivable to construct a variant \nof any type\u00adsystem with colors, including intuitionistic type-theory (Martin-L\u00a8 of 1984). The rest of \nthe section describes the main features of CCCC in pedagogical order. A summary is shown in appendix \nfor reference. We emphasize that we describe only on the core features of TTC. Some features used in \nthe previous section will not be included here, even though it is conceivable to integrate them with \nlimited effort. Even though we continue to render some expressions in color as a visual aid, the formal \nsystem does not rely on them in any way. This section can be read in black and white without any loss \nin precision. 3.1 CC as a PTS We use CC as a base, so we recall brie.y its de.nition, using a pure type \nsystem (Barendregt 1992) presentation. The typing rules are as follows: CO N V G f a : A A = \u00df A ' G \nf a : A ' AX I O M f G G f * : D VA R f G x : A . G G f x : A PRO D G, x : A f B : s G f (x : A) . B \n: s AB S G f G, x : A f b : B .x : A.b : (x : A) . B AP P G f F : (x : A) . B G f u : A G f F u : B[u/x] \nTo limit clutter we omit the well-formedness conditions of types A and B in the rule ABS. The product \n(x : A) . B may be also written A . B when x does not occur free in B, and we generally omit the application \noperator . The metasyntactic variable s ranges over the sorts * and D. The context-lookup relation (x \n: A . G) is straightforward, and the context-formation rules are: BI N D EM P T Y f G G f A : s f f \nG, x : A Traditional presentations of PTSs, including that of Barendregt (1992), use another formulation, \nwhich integrates the context\u00adlookup, context-formation and typing rules. Instead of the VA R rule, one \nhas the following WEA K E N I NG and STA RT rules, and axioms can only be used in the empty context. \nSTA RT WE A K E N I N G G f A : s G f A : B G f C : s G, x : A f x : A G, x : C f A : B While the presentation \nof Barendregt economizes a couple deriva\u00adtion rules, it has the disadvantage to con.ate separate concepts \nin a single de.nition. Consequently, is it harder to extend, and mod\u00adern presentations tend to use separate \ncontext-lookup and context\u00adformation relations. 3.2 Colors, Taints and Modalities We assume an in.nite \nsupply of color names; the metasyntactic variables i and j stand for them in the remainder. We call an \nordered set of such color names a taint and use . or . to range over taints. A color may be introduced \nin the context by its name. After such a mention, terms may contain i-tainted parts, but also non i-tainted \nparts. In contrast, before the mention of i, terms are i-oblivious: they cannot depend on i in any way. \nOur typing judgment G f A :. B is indexed by a taint ., which must be a subset of the colors present \nin G. The presence of a given color i in . indicates how i can be used in A and B. i . . indicates that \nA is not tainted with i. A term A typed in such a taint may still mention the color i. For example .(x \n:i T ) . a is allowed. However, the usage of i-tainted vari\u00adables is forbidden in the target (a) of the \nterm. For example .(x :i T ) . x is forbidden.  i . . indicates that the term A is tainted with i. In \nsuch a judgment, using i-tainted variables is allowed in the targets of terms and types. Remark: It does \nnot make sense to erase i from a judgment using this taint; conceptually the whole typing is tainted, \nso it would be entirely removed.  For each taint . we have two sorts * . and D., with the axiom * . \n: D.. The conversion rule merely preserves taints. CO N V G f a :. A A = \u00df A ' G f a :. A ' AX I O M \nf G G f * . :. D. A variable binding x :. A does not only carry a taint, but also a modality. (. and \n. range over modalities.) A modality is composed of two disjoint sets of colors (say . = (., .) with \n. n . = \u00d8) that constrain what kind of a term u can be substituted for x. The .rst set . is the taint \nof u. The second set . is an anti-taint : a set of col\u00adors which u must be oblivious to. We often use \nthe compact nota\u00adtion i1 . . . in, j1 . . . jn for the modality ({i1 . . . in}, {j1 . . . jn}). Similarly \nwe will write j . . to mean that j is found in the second set. Using this notation, the following two \ncontexts are equivalent (one can substitute one for another without changing the provability of a judgment): \nG, x : A, i, . G, i, x : i A, . That is, declaring a variable before i, or declaring it i-oblivious explicitly \nare equivalent. The product and abstraction rules can change the modality of the type quanti.ed over; \nthe application rule behaves correspondingly. PRO D AB S G, x :. A f B :. s G, x :. A f b :. B G f (x \n:. A) . B :. s G f (.x :. A.b) :. (x :. A) . B AP P G f F :. (x :. A) . B G f u :. A G f F . u :. B[u/x] \n(where the metasyntactic variable s now ranges over the sorts *. or D., for any ..) To be able to merely \nforward modalities, we need to extend the judgment to support arbitrary modalities ., not just taints \n., as we do at the beginning of the next section. We generally omit the modality annotation on applications, \nbecause they are easily inferred from the context. One can embed any derivation from CC into CCCC simply \nby using the empty taint everywhere.  3.3 Obliviousness and variable lookup We extend the typing judgment \nto support any modality . (not just a taint) as follows: De.nition 1 (Oblivious judgment). . If . = (., \n.) then G f A :. B = LGj. f A :. B  This captures the intuition that A and B are oblivious to every \ncolor in .. Indeed, the erasure removes all mentions of i from the context G for every i . . (a complete \nde.nition and justi.cation of erasure is given in the following section). In particular, if x : A . G, \nthen G f x : i LAji; in words, referencing a variable from an i-oblivious judgment yields only a witness \nof the i-erased type. Hence, variable lookup requires equality of taints, not merely inclusion: VA R \nf G x :. A . G G f x :. A There are two ways to access an i-oblivious variable x. First, it is accessible \nin an i-oblivious judgment, as can be seen by expanding Def. 1: G, x : i A, . f x : i A = LGji, x : A, \nL.ji f x : A Second, it can be accessed from an i-aware judgment, as formalized in the context-lookup \nrules: CO L . WK STA RT x :. A . G i . . x :. A . G, x :(.,.) A x :. A . G, i WK x :. A . G x :. A . \nG, y :. B The CO L . WK rule ensures that x is accessible from an i-aware context (but not an i-tainted \none), even if it is declared before the introduction the color i. The STA RT rule plays a similar role: \nx can be explicitly oblivious to any set of colors, it does not change its accessibility. Consider as \nan example the following de.nition, a variant of Leibniz equality. x =i a y = (P :i (z : i a) . * i).P \nx.P y One can verify that it is a well-colored type as follows. Let . = a : *, x : a, y : a: APP . . \n. Def. 1 . f y : a ., i, . . . f y : i a ., i, P :i (z : i a) . *i, q :i P x f P y : *i PROD ., i f \nx =i a y :i * i With re.i = .(P :i *)..(q :i P ).q, one can also derive a : *, x : a, i f re.i :i x =i \na x. In order to use = as an equality, we need to access oblivious variables from non-oblivious contexts, \nas we explain in this para\u00adgraph. The key difference between = as de.ned above and the usual Leibniz \nequality here is that we use propositions P of type (x : i a) . *i; that is, the parameter of P is i-oblivious. \nThanks to the context lookup rules, a variable x : i Bool may be used even in an i-aware context, so \none can construct a proposition Qi of the right type which returns truth if the Boolean is true and falsity \notherwise. Then one can obtain falsity from true =Bool false by substituting Qi for P . Assuming a de.nition \nTest :i Bool . * i which does the adequate case analysis on booleans, one has: x : Bool . i, x : i Bool \n. . VA R . i, x : i Bool f x : Bool AP P i, x : i Bool f Test x :i *i AB S i f .(x : i Bool).Test x :i \n(x : i Bool) . *i Def. i f Qi :i (x : i Bool) . * i  3.4 Erasure Color erasure is de.ned by structural \ninduction on terms. The effect on each modality is the following. Applying i-erasure on an i\u00adtainted \nbinding removes it. The i-erasure of a non i-tainted binding is the binding of the erasure. Erasing i \nfrom an i-oblivious binding has no effect besides removing the mention of i . Erasure of product, abstraction \nand application follows directly from the behavior on bindings. Erasure preserves all variable occur\u00adrences, \nas well as sorts. In the following table we sum up all cases. The erasure of terms which do not mention \na modality are show in the .rst column. For terms which mention a modality, we show the various cases \nin various columns. The .rst column shows the case where the color occurs nowhere in the modality. The \nsecond one shows the case where i occurs as a taint. The third one shows the case where the i occurs \nas an anti-taint. i . . i . . . = ., i lxJi = x lsJi = s l(x :. A) . BJi = (x :. lAJi) . lBJi lBJi (x \n:. A) . lBJi l.x :. A.bJi = .x :. lAJi.lbJi lbJi .x :. A.lbJi lF . aJi = (lF Ji) . laJi lF Ji (lF Ji) \n. a lG, x :. AJi = lGJi, x :. lAJi lGJi lGJi, x :. A lG, j Ji = lGJi, j lG, iJi = G Lemma 1 (Erasure \npreserves typing). If G f A :. B and i . . then LGji f LAji :. LBji. Proof. By induction on the derivation. \nThe proof relies on the color\u00addiscipline enforced by the typing rules. This lemma means that erasure \nmakes sense as a meta-level de.nition. The precondition is important: erasing i makes no sense on an \ni-tainted term; conceptually the whole term would be erased in that case. This justi.es for example the \ncase for sorts in the de.nition: the precondition guarantees that erasure will not be applied to a sort \n* i. In the system, we use erasure only in situations where this precondition is satis.ed. Erasure is \nused in the de.nition of substitution (whose full de.nition is given in Sec. 6): when substituting in \nan oblivious argument, or in the type of an oblivious parameter, one needs to erase the substitutee. \nFor example: (f i u)[t/x] = f[t/x] i u[Ltji/x] Note that if x is i-tainted, the type-system prevents \nany occurrence of x in u, ensuring that the precondition of Lem. 1 is respected. We have not yet de.ned \nhow to reduce terms in CCCC, but it is worth mentioning already that erasure preserves computation. A \nproof is given latter in Lem. ??. if A -.* B, then LAji -.* LBji, for any color i.  3.5 Types as Predicates \nBy modulating a judgment with a color i, a type B becomes a predicate over LBji 4. The erasure of a term \nA of type B satis.es the type B seen as a predicate. The parametric interpretation de.ned by Bernardy \net al. (2010), can be extented to our theory with colors: 4 With the exception of terms which are sorted \nin under that color. For example, *i :i Di and not *i :i *i . Di. This feature prevents an in.nite descent \ninto deeper and deeper predicates.  [xri i = x i iii [.x :. A.br= .x :. A..x:.,i x .. [Ar.[brif i . \n. = [bri if i . . = .x :. A.[bri if . = ., i ii i [F . ar= [F r . a .,i [arif i . . = [F ri if i . \n. = [F ri . a if . = ., i i = .x :i T .x . [T ri if T is a type [T r C .. [sri = (x :., i C) . s if \ni . . = s if i . . = (x :. C) . s if . = ., i C .. [(x :i A) . Bri = ii i (x :. A) . (x :.,i x .. [Ar) \n. (C . x) .. [Brif i . . = C .. [Bri if i . . = (x :. A) . (C . x) .. [Bri if . = ., i C .. [T ri = [T \nri ., i LT ji if T is not a type Theorem 1 (Parametricity of closed terms). If f A :. B and i . ., then \ni i f [Ar :.,i [Br ., i LAji Proof. The proof uses the standard techniques of logical relations, extended \nto dependent types by Bernardy et al. (2010). We wish however not to be limited to closed terms, and \nwant parametricity even on open terms. The presence of colors allows5 to add the following rule, which \ninternalizes the reinterpretation of terms as predicates and proofs. PA R A M G f A :. B i . . G f A \n:.,i B ., i LAji This rule is a generalization of Th. 1 and it allows to deduce, within the calculus, \ntheorems which could only be obtained meta\u00adtheoretically without it. However, in this paper, the treatment \nof logical relations differs from the usual one: a type is not interpreted as a predicate (via the above \ntransformation of terms and types [\u00b7r), but is directly used as such in an i-modulated judgment. In order \nto use T as a predicate we extend reduction rules as follows, where we recall that s ranges over sorts, \nwhile t ranges over terms. s. . t -. (z :. t) . s... (1) where . = (., .) ((x :. A) . B) . t -. (x :. \nA) . (B . t) (2) if .i such that i . . and i . . ((x :. A) . B) . t -. (x :. A) . (B . (t . x)) (3) otherwise \n(.x :. A.b) . t -. b[t/x] (4) (1): Since a type becomes a predicate, a type of types (a sort) becomes \na type of predicates. The target sort of the predicate type is adjusted, in order to obtain a type (and \nnot again a predicate see footnote 4). 5 The issues that one faces when attempting to internalize parametricity \nin a theory without colors are detailed by Bernardy and Moulin (2012). (2) and (3): A function t satis.es \nthe predicate of a function type if an argument x (which implicitly satis.es the predicate of the domain \nA) is mapped by the function t to a value satisfying the codomain B. In the case of (2), the modality \n. mandates erasure of the domain A, therefore x is not given as an argument to t.  (4): The \u00df-reduction \nis trivially amended to account for colors. The rules (1,2,3) do not interfere with \u00df, because they concern \nother syntactic forms.  The cases (1,2,3) agree with the standard interpretation of types as predicates. \nBernardy and Moulin (2012); Bernardy et al. (2012) give a detailed account of logical relations in the \npresence of depen\u00addent types. As an example, one can check that reduction behaves as expected for the \nlist concatenation type: ((xs : List a) . (ys : List a) . List a) i c -. (xs : List a) . ((ys : List \na) . List a) i (c xs) -. (xs : List a) . (ys : List a) . List a i (c xs ys)  3.6 Example Assume the \ncolors i and j as well as the context Listi : (a :i * i) . * Listj : (b :j * j ) . * fold : (a :i * i) \n. (b : *) . (a . b . b) . b . Listi a . b One can de.ne a variant of the ubiquitous map function as follows: \nmap : (a :i *i) . (b :j *j ) . (f :j (x :i a) . b) . Listi a . Listj b map = .f.fold a (Listj b) (. x \nxs.more (f x) xs) stop This version of map is versatile. After erasing j, the f argument disappears and \nmap becomes a function returning the length of its input. After erasing i, f becomes a constant of type \nb, the input list becomes a natural number (n), and map returns a list containing n copies of f.  3.7 \nAnalysis In this section we state and prove a number of standard meta\u00adtheoretical results for our calculus. \nDetails can be found in the appendix. Corollary 1 (Con.uence). CCCC has the con.uence property. Proof. \nA direct consequence of Th. ?? and -. * = e * . Lemma 2 (Thinning). Let G and . be legal contexts such \nthat G . .. Then G f A :. B =. . f A :. B. Proof. As in (Barendregt 1992, lem. 5.2.12). The generation \nlemma for PTS can be extended to colored bindings. The only dif.culty is the following. In (Barendregt \n1992), the generation lemma includes a case for applications. This case is dif.cult to extend to our \ncalculus, since application can be done not only on lambda abstractions, but also on types, when they \nare used as predicates. Fortunately, that case is not used in the subject reduction lemma, and therefore \nwe can omit it from our version of the generation lemma. Lemma 3 (Generation). The statement is similar \nto that of (Baren\u00addregt 1992, lem. 5.2.13). Points 1. to 4. (constant, variable, prod\u00aduct, abstraction) \nare adapted in a straightforward manner to col\u00adored binding. Point 5. (application) is removed. The following \ntwo points are added.  If G f (s.,i ., i t) :.,i C, then s. and C =\u00df s ' with (s, s ' ) . A G f t :., \ni . If G f ((x :. A) . B) ., i t :.,i C, then G f t :., i L(x :. A) . Bji and C =\u00df s. ' with G f (x :. \nA) . B :. s. Proof. As in (Barendregt 1992): we follow the derivations until s.,i (resp. (x :. A) . B) \nis introduced. It can only be done by the PA R A M rule, and the conclusion follows from a use of the \nThinning Lemma. (An example of such derivations can be found in Fig. 1.) Theorem 2 (Subject reduction). \nIf A-.A ' and G f A : T , then G f A ' : T . Proof. Most of the technicalities of the proof of subject \nreduc\u00adtion for PTSs (Barendregt 1992) concern \u00df-reduction, and are not changed by the addition of colors. \nHence we discuss here only the handling of reduction rules (1) to (3). We treat .rst the case of sorts \n(1): s. . t -. (z :. t) . s... (1) where . = (., .) In this case, the Generation Lemma indicates that \nthe derivation tree must end with an AP P rule and contain a chain PA R AM-AX on the left-hand side of \nthe derivation. A template for such a tree is shown in Fig. 1. One can then construct a typing derivation \nfor the reduct, which ends with the PRO D rule, and does not mention PA RAM nor AP P. The template for \ntyping the reduct is also shown in Fig. 1. Second we treat the case of products (2) and (3). ((x :. A) \n. B) . t -. (x :. A) . (B . t) (2) if .i such that i . . and i . . ((x :. A) . B) . t -. (x :. A) . (B \n. (t . x)) (3) otherwise Again we can use the Generation Lemma to obtain the shape of a derivation tree \nof the reducible expression, and obtain a valid typing for the reduct (also shown in Fig. 1. In this \ncase the typing of the source involves the chain of rules PA R A M-PROD on the left-hand side of APP. \nThe typing of the reduct ends with PRO D. We have taken the view in our presentation that the reduction \nrules are untyped, and therefore subject reduction must recover typings using the Generation Lemma. An \nalternative would be to have a typed reduction relation (this relation usually goes by the name of judgmental \nequality ). In this case the reduction of proof trees shown in Fig. 1 would be part of the de.nition \nof reduction. The two approaches have been proved equivalent for arbitrary PTSs by Siles (2010). Theorem \n3 (Normalization). CCCC is strongly normalizing: every sequence of reductions eventually terminates. \nProof. The new reduction rules, involving PA RA M, are much easier to handle than \u00df-reduction (rule 4). \nIndeed, the argument to the application is not duplicated by these reduction rules. Hence, one can adapt \nthe proofs of termination of CC to CCCC. At a high-level, the argument goes as follows. Consider reduction \nrules (1) to (3), that we collectively call PA R A M-reductions be\u00adlow. Their effect is to make the left-hand-side \nof the . operator smaller. This can also be seen by examining the corresponding typ\u00ading derivations: \nthe reductions strictly decrease the size of the tree above the PA RA M rule involved. Consequently, \nbetween each \u00df-reduction step, there can be only a .nite number of PA RAM-reductions. The question is \nnow: do these PA RAM-reductions create \u00df-redexes? The reductions (1) and (2) do not, but (3) does. However, \nthe new redex is harmless: it lies in an i-oblivious context, and therefore there is no risk of an (i-aware) \nPA RA M-reduction to be created by that redex. The situation is then that, by importing the proof techniques \ndeveloped for CC, one can bound the chains of \u00df-reductions, and use the above argument to .nitely-bound \nthe PA RA M-reductions occurring between \u00df-reduction steps. The above proof is an alternative to that \ndone in earlier work (Bernardy and Moulin 2012), which works by construction a model by translation into \nCC. Even though the earlier proof can be adapted to the present system, we .nd the above proof more modular, \nand thus easier to grasp.  3.8 Type-Checking With Colors The rules PA R AM and the de.nition of and \noblivious judgment Def. 1 are not syntax-directed, therefore it may be non-obvious how they should be \nused in type-checking. In this subsection we sketch a possible type-checking algorithm and brie.y argue \nfor its soundness. A full description of the algorithm, together with a completeness proof, is left for \nfuture work. We assume that the user supplies a term t, a type T , a modality . and a context G. The \ntask is to reconstruct a derivation of G f t :. T . Most of the implementation of the new rules is realized \nat the point of checking a variable (t = x). Let us assume that looking up x in the context G yields \nx :. A. For each color i . G we have to take into account its status in . and .. For simplicity we assume \nthat . and . contain at most one color; a full implementation will do the same task for each color independently. \n1. i . .. If i is not mentioned in ., then the derivation is the following. x : A . G VA R G f x : A \nLem. 1 LGji f x : LAji Def. 1 G f x : i LAji Hence we simply check that T = LAji. For i . . , then x \nis not accessible and type-checking reports failure. For i . . one needs only to check T = A. 2. If the \njudgment is i-aware (. = \u00d8), we have three cases. If i . ., then x is not accessible and type-checking \nreports failure. Otherwise, then modalities match and we only need to check T = A. Notably, if . ., \nx is more oblivious than required, but this is accepted by the STA RT rule, which allows arbitrary extra \nanti-taints in the binding of the looked-up variable. 3. If i . ., we have two cases. If i . ., then \none simply checks T = A. Otherwise, one must take into account PA R A M, that is, check T = A i x instead \nof T = A. Lastly, when checking a type used as a predicate, that is a term t of the form (. . B) . u \n(for any telescope .) or s . u , we reduce the term t before checking it. The number of reduction steps \nis at most |.| + 1 in the .rst case or 1 in the second case: the performance hit is minimal. As usual \nin type-checking algorithms, all the equality-tests men\u00adtioned above have to be performed up-to the reduction \nrelation, in order to take into account the CO N V rule. This is done using standard means, for example \nnormalizing terms before comparison, which is possible thanks to Th. 3.  f G AX f G G f t : i * G f \n* : D BI N D PA RA M f G, x : i t G f * :i D i * =. AX CO N V G, x : i t f *i :i Di G f * :i (x : i \n*) . Di G f t : i * PROD AP P G f (x : i t) . *i :i Di G f * i t :i Di PRO D G, x : A f B : * PA RAM \nG f (x : A) . B : * CO NV G f (x : A) . B :i * i L(x : A) . Bji =. APP G f (x : A) . B :i L(x : A) . \nBji . *i G f t : i L(x : A) . Bji G f ((x : A) . B) i t :i *i PA RAM APP G, x : A f B : * G, x : A f \nB :i LBji . * i AP P G f t : i L(x : A) . Bji G, x : A f t x : i B G, x : A f B i (t x) :i *i PRO D \nG f (x : A) . B i (t x) :i *i Figure 1. Proof-reduction templates corresponding to the term-reductions \n(1) and (3). The sorts and taint annotations are specialized to the simplest case to reduce clutter; \ngeneralization to arbitrary taints and sorts is straightforward. 4. Extensions 4.1 Inductive De.nitions \nThe de.nitions presented in the previous section can be extended to work on inductive types in a straightforward \nmanner, merely recur\u00adsively applying the de.nitions on the types of each component of the inductive type, \nas we have done in the examples in Sec. 2. The extension of a similar system to inductive de.nitions \nis described in full detail by Bernardy et al. (2012). We conjecture that the addition of inductive de.nitions \ndoes not compromise any meta-theoretical property.  4.2 Colored Pairs In this section we formally introduce \ncolored pairs, and formalize a example presented in Sec. 2: inhabitants of the type (a : *) . a . a must \nbe the identity function. The formation and introduction rules (SU M , PA I R) are similar to the usual \nrules for dependent pairs, with the difference that the modalities track that the .rst component is oblivious \nto the color while the second component is tainted. SU M PA I R G, x : i A f B :i s G f a : i A G f b \n:i B[a/x] G f (x : A) \u00d7i B : s G f a,i b : (x : A) \u00d7i B We do not provide special elimination rules for \ncolored pairs. In\u00adstead, erasure and PA RA M play this role. The erasure of a pair yields its .rst component \nif colors match, otherwise it acts struc\u00adturally. L(x : A) \u00d7i Bji = A L(x : A) \u00d7j Bji = (x : LAji) \u00d7j \nLBji La,i bji = a La,j bji = Laji,j Lbji We remark that the property that erasure preserves typing is \ncon\u00adserved. In particular: if G f p : (x : A) \u00d7i B then LGji f Lpji : A Interpreting a pair as a predicate \nyields the second component if colors match, otherwise it acts structurally: ((x : A) \u00d7i B) ., i t = \nB[t/x] ((x : A) \u00d7j B) . t = (x : A . Ltjj ) \u00d7j (B . t) We can now explain fully formally how one can \nderive that any function of type (a : *) . a . a is indeed an identity function. Let G = f : (a : *) \n. a . a, b : *, y : b x =a y = (P : a . *) . P x . P y t = f ((x : b) \u00d7i (x =b y)) (y,i re.i) Where = \nrefers to the de.nition of the previous section. We .rst check that (x : b) \u00d7i (x =b y) is well-colored \n(and well-sorted): G f b : * Erasure Def. LG, iji f b : * G, i, x : i b f x : i b Def. 1 G, i f b : i \n* G, i, x : i b f (x =b y) :i * i SU M G, i f (x : b) \u00d7i (x =b y) : * And proceed with the main result: \nG f y : b G, i f re.i :i (y =b y) . PA IR . . G, i f (y,i re.i) : (x : b) \u00d7i (x =b y) APP G, i f f \n((x : b) \u00d7i (x =b y)) (y,i re.i) : ((x : b) \u00d7i (x =b y)) Def. G, i f t : (x : b) \u00d7i (x =b y) PA RAM G, \ni f t :i (Ltji =b y) Erasure Def. G, i f t :i f by =b y An essential component of the trick is that f \nis i-oblivious. Hence it cannot distinguish in any way between i-tainted and non i-tainted terms, thus \nwe can pass it a colored pair as its type argument. The trick generalizes: one is able to derive useful \nproperties about a polymorphic term q of type A by construction of an ad\u00adequate term p of type (x : A) \n\u00d7i B such that Lpji = q. The con\u00adstruction of q involves specializing a type parameter to a colored pair \ntype involving the property of interest.  In fact, by pairing a type A with a predicate B[x], colored \npair type allows to override the default predicate interpretation of the type A with B[x], for a given \nspeci.c color.  4.3 Abstraction Over Colors So far we have assumed that colors were available in the \ncontext. In a complete TTC, a mechanism to abstract over colors should be provided. At this stage we \nhave thought of colors only as a .rst\u00adorder concept, that is, we propose only .rst-order quanti.cation \nover colors. As such, color abstraction is a relatively modest, straightforward addition. We need new \nsyntax for abstraction, quanti.cation, and application, as well as a constant color (written 0 in the \nfollowing) used for erasure. A notable feature is that one cannot abstract over a color which is present \nin the modality; otherwise the color would escape the scope where it is introduced. Using k to range \nover color names or 0, the typing rules are as follows: CO L . A B S CO L . AP P G, i f A :. B i . . \nG f A :. .i.B G f .i.A :. .i.B G, k f A k :. B[k/i] and the reduction rules: (.i.T ) . t -. .i.T . (t \ni) (.i.t) 0 -. Ltji (.i.t) j -. t[j/i] Erasure must be extended as well to substitute occurrences of \ncolors as arguments: Lt iji = Ltji 0 Lt ijj = Ltjj i Lt 0ji = Ltji 0 L.i. tjj = .i.Ltjj With this extension, \nthe subject reduction property depends on Lem. 1. 5. Discussion and Related Work COQ-style erasure Thanks \nto Paulin-Mohring (1989), CO Q fea\u00adtures program extraction, which is an erasure of proofs to obtain \nprograms. Such programs are external entities, that is, they cannot be referred to as an erasure from \nthe CO Q script they originate. This shortcoming is remedied in TTC. For the purpose of extrac\u00adtion, \nCO Q separates types from propositions, using different sorts for each, and allows types to depend on \nthe existence of proofs (but not their structure). In contrast, in the system we present here, un\u00adtainted \nterms cannot even depend on the existence of a tainted term. It is likely that the two notions of erasure \ncan be combined in a sin\u00adgle system, but we leave the study of that combination to future work. AG DA-style \nerasure A number of systems with modalities for erasure have been proposed (Pfenning 2001; Mishra-Linger \nand Sheard 2008; Abel and Scherer 2012), with the interpretation of irrelevance: types marked with a \nspecial modality (usually written x \u00f7 A) are understood as proofs, whose inhabitants are irrelevant for \nthe execution of the programs. The system presented here bears some similarity to such sys\u00adtems, but \nalso presents important differences: Our binding form x :i A corresponds to the irrelevant binding x \n\u00f7 A.  We have, in addition to irrelevant bindings, the complementary notion (written x : i A). This \nallows us to mix erased terms with non-erased ones, and choose arbitrarily which version we  mean. In \ncontrast, systems with erasure usually .x a speci.c view on which parts of a term is accessible. We \nsupport an arbitrary number of colors instead of a single one, which is essential for compositionality \nand to support n\u00adary parametricity.  We focus on erasure instead of irrelevance. Previous authors usually \nallow the use of the ex falso quod libet principle on irrelevant assumptions, while we forbid any use \nof a tainted variable in a non-tainted context.  Types for language-based security Our notion of taint \nis rem\u00adiniscent of that used in language-based security. More precisely, our tainted variables would \ncorrespond to variables at high security levels: tainted variables may be used only in tainted contexts. \nThe present work can be seen as a generalization of (Abadi et al. 1999) to dependent types. A difference \nis that we use modalities instead of a different type former for security levels. As a consequence, we \ndo not need a monad to relate security levels. To our knowledge, the combination of dependent types and \nsecurity-levels in a type\u00adsystem has not been realized before. Ornaments Relating variants of dependently-typed \nprograms have been a concern for a long time. The idea of ornamenting inductive structures have been \nproposed to remedy this problem (Dagand and McBride 2012). Here, we instead focus on erasure (let the \nuser specify an ornamented type and recover the relation with its erasure) instead of specifying ornamentation \nof already ex\u00adisting types. This is not much of a difference in practice, because ornaments typically \ncan only be applied to a single type. An advan\u00adtage of colors over ornaments is that colors integrate \nnatively with existing type-theories, while ornamentation relies on encodings; additionally we get free \nequalities when working with erasures, and colored pairs reveal parametricity properties. The chief ad\u00advantage \nof ornaments is that any algebra can be used to ornament datatypes, while we are limited to structural \nrelations. ? have shown how to compose ornaments. Composition is lack\u00ading from the system presented here, \nbut we plan to support it in future extensions of TTC. Indeed, if two terms A and B share an erasure \n(for example C = LAji = LBjj ), it means that A and B are to versions of C ornamented differently. Under \nthe same as\u00adsumption, it is possible to automatically construct a term D such that LDjj = A, LDji = B, \nand LDjij = C. That is, D contains both the ornamentations coming from A and B. Parametricity Bernardy \nand Moulin (2012) have described a cal\u00adculus which internalizes parametricity, and have shown that higher \ndimensions are necessary to nest parametricity. The present work has the same model as the previous one \n(colors are dimensions un\u00adder another name). Besides re-framing dimensions as colors, which we .nd allows \nan easier grasp of intuitions, the present system fea\u00adtures a number of technical simpli.cations: 1. \nIn the system of Bernardy and Moulin (2012), one has to be ex\u00adplicit about the number of dimensions that \na term has. In con\u00adtrast, here, the dimensionality of a term is implicit. Indeed, con\u00adtexts can be extended \nwith an arbitrary number of dimensions. This means that a term can always be used in a context which \nhas more (distinct) colors, whereas previously an explicit con\u00adversion had to take place. In other words, \nterms can be seen as in.nitely-dimensional; but if they do not mention a dimension explicitly they behave \nuniformly over it. In particular, usual .\u00adterms are uniform, and parametricity is a consequence of this \nuniformity. 2. In this paper, we name dimensions, whereas they are numbered in (Bernardy and Moulin \n2012). The situation is analogous to the issue of the representation of variables in lambda-calculi. \n  One can either use explicit names or De Brujin indices, and using names is usually more convenient. \nIt is worth underlining that the notion of erasure we employ here is not the same as that of (Bernardy \nand Lasson 2011). Here, we erase the colored component; whereas Bernardy and Lasson (2011) erase the \noblivious components. Parametricity has more standard consequences such as the deduction of induction \nprinciples. Unfortunately, many of these consequence also require extensionality (Wadler (2007) gives \na complete development). Since extensionality is not well integrated to type-theory (let alone TTC) at \nthe moment, we cannot derive such constructions, at least not without postulating extensionality. Higher-dimensional \nEquality Recent work on the interpreta\u00adtion of the equality-type in intensional type theory suggests \nthat it should be modeled using higher-dimensional structures (Licata and Harper 2012). In the present \nwork we support the de.nition of higher-dimensional structures via dependencies on colors. In fu\u00adture \nwork we wish to investigate whether the presence of colors can help encoding the higher-dimensional structure \nof equality. A potential dif.culty is that the structure of equality is simplec\u00adtic, while we have here \na cubic structure (colors are orthogonal). A simplex is however easily embedded in a cube, so there are \ngrounds to believe that the two aspects can eventually be integrated. 6. Conclusion and Future Work We \nhave described an extension of type-theory with colored terms, a notion of color erasure, and a way to \ninterpret colored types as predicates. We have shown how that extension provides a new kind of genericity, \nand how the coloring discipline enforces invariants when writing programs. We also shown how to reveal \nthese invari\u00adants (by typing the judgment in another modality) and internalize some parametricity results. \nWe detailed extensively a core version of that colored type\u00adtheory, namely CCCC. In particular, we proved \nfundamental prop\u00aderties for that system, such as Church-Rosser s, subject-reduction, and strong normalization. \nWe also implemented some features of CCCC in a prototype we aim to merge into the main stream AG DA proof \nassistant. Future work chie.y involves unifying colors as presented here with previous similar notions. \nOn the implementation side, we aim to complete our prototype with all the features presented in this \npaper. Besides, we would like to investigate the feasibility of inference of color annotations before \nmerging our implementation of TTC into the main branch of AG DA. We will then be able to assess the practical \npower of TTC. A .rst step in this direction is the retro.tting of the AG DA standard library to use colors. \nAcknowledgments Many ideas underlying this paper have germinated and matured in discussions with Thierry \nCoquand, Simon Huber and Patrik Jans\u00adson. We thank Peter Dybjer, Cezar Ionescu, Nicolas Pouillard and \nPhilip Wadler as well as anonymous reviewers for useful feedback. This work has been partially funded \nby the Swedish Foundation for Strategic Research, under grant RAWFP. References M. Abadi, A. Banerjee, \nN. Heintze, and J. Riecke. A core calculus of dependency. In POPL 99, pages 147 160. ACM, 1999. A. Abel \nand G. Scherer. On irrelevance and algorithmic equality in pred\u00adicative type theory. Logical Methods \nin Comp. Sci., 8(1):1 36, 2012. TYPES 10 special issue. H. P. Barendregt. Lambda calculi with types. \nHandbook of logic in computer science, 2:117 309, 1992. . J.-P. Bernardy and M. Lasson. Realizability \nand parametricity in pure type systems. In M. Hofmann, editor, FoSSaCS, volume 6604 of LNCS, pages 108 \n122. Springer, 2011. J.-P. Bernardy and G. Moulin. A computational interpretation of para\u00admetricity. \nIn Proc. of the Symposium on Logic in Comp. Sci. IEEE, 2012. J.-P. Bernardy, P. Jansson, and R. Paterson. \nParametricity and dependent types. In Proc. of ICFP 2010, pages 345 356, Baltimore, Maryland, 2010. ACM. \nJ.-P. Bernardy, P. Jansson, and R. Paterson. Proofs for free parametricity for dependent types. J. Funct. \nProgram., 22(02):107 152, 2012. . T. Coquand and G. Huet. The calculus of constructions. Technical report, \nINRIA, 1986. P.-E. Dagand and C. McBride. Transporting functions across ornaments. In Proc. of ICFP 2012, \nICFP 12, New York, NY, USA, 2012. ACM. D. Licata and R. Harper. Canonicity for 2-dimensional type theory. \nIn Proc. of POPL 2012. ACM, 2012. P. Martin-L \u00a8of. Intuitionistic type theory. Bibliopolis, 1984. N. \nMishra-Linger and T. Sheard. Erasure and polymorphism in pure type systems. In FoSSaCS 2008, pages 350 \n364. Springer-Verlag, 2008. U. Norell. Towards a practical programming language based on de\u00adpendent type \ntheory. PhD thesis, Chalmers Tekniska H \u00a8ogskola, 2007. URL http://publications.lib.chalmers.se/cpl/ \nrecord/index.xsql?pubid=46311. C. Paulin-Mohring. Extracting F. s programs from proofs in the calculus \nof constructions. In POPL 89, pages 89 104. ACM, 1989. ISBN 0\u00ad89791-294-2. . F. Pfenning. Intensionality, \nextensionality, and proof irrelevance in modal type theory. In Proc. 16th Annual IEEE Symposium on Logic \nin Comp. Sci., pages 221 230. IEEE, 2001. ISBN 0-7695-1281-X. . URL http://ieeexplore.ieee.org/lpdocs/epic03/wrapper. \nhtm?arnumber=932499. V. Siles. Investigation on the typing of equality in type systems. Phd thesis, \u00b4 \nEcole Polytechnique, 2010. The Coq development team. The Coq proof assistant, 2012. URL http: //coq.inria.fr. \nP. Wadler. Call-by-value is dual to call-by-name. In Proc. of ICFP 2003, ICFP 03, pages 189 201, New \nYork, NY, USA, 2003. ACM. ISBN 1-58113-756-7. . URL http://doi.acm.org/10.1145/944705. 944723. P. Wadler. \nThe Girard Reynolds isomorphism (second edition). Theor. Comp. Sci., 375(1 3):201 226, 2007. P. Wadler. \nPropositions as sessions. In Proc. of ICFP 2012, ICFP 12, pages 273 286, New York, NY, USA, 2012. ACM. \n Appendix A: De.nition of CCCC De.nition 2 (Syntax). Variable 3 x, y, z Color 3 i, j Sort 3 s ::= * \n. | D. Taint 3 ., . ::= \u00d8 empty | ., i tainted Modality 3 ., . ::= (., .) Term 3 A, . . . , Z ::= x variable \na, b, c, t, u | s sort | (x :. A) . B product | .x :. A.b abstraction | F . a application Context 3 G, \n. ::=  empty | G, x :. A binding | G, i color De.nition 3 (Typing rules G f A :. B ). G f A :. B is \nwell-formed only if i . G for each i . .. CO N V AX I O M G f a :. A A = \u00df A ' f G G f a :. A ' G f *. \n:. D. VA R PRO D f G x :. A . G G, x :. A f B :. s G f x :. A G f (x :. A) . B :. s AB S G, x :. A f \nb :. B G f (.x :. A.b) :. (x :. A) . B AP P G f F :. (x :. A) . B G f u :. A G f F . u :. B[u/x] PA R \nA M G f A :. B i . . G f A :.,i B ., i LAji (To limit clutter we omit the well-sorted conditions of types \nA and B in the rule ABS.) We also have If . = (., .) then G f A :. B = LGj. f A :. B De.nition 4 (Accessible \nvariable x :. A . G ). CO L . WK STA RT x :. A . G i . . x :. A . G, x :(.,.) A x :. A . G, i WK x :. \nA . G x :. A . G, y :. B De.nition 5 (Well-formed contexts f G ). CO L O R BI N D EM P T Y f G f G G \nf A :. s f f G, i f G, x :. A De.nition 6 (erasure The de.nition of erasure depends on the actual modality \nused. We write all the cases on the same LT ji ). line; the condition is written above each column. i \n. . i . . . = ., i lxJi = x lsJi = s l(x :. A) . BJi = (x :. lAJi) . lBJi lBJi (x :. A) . lBJi l.x :. \nA.bJi = .x :. lAJi.lbJi lbJi .x :. A.lbJi lF . aJi = (lF Ji) . laJi lF Ji (lF Ji) . a lG, x :. AJi = \nlGJi, x :. lAJi lGJi lGJi, x :. A lG, j Ji = lGJi, j lG, iJi = G Erasure is extended to taints as follows: \nDe.nition 7 (erasure LT j. ). LT j\u00d8 = T LT j.,i = LLT jij. De.nition 8 (Reduction t -. u ). s. . t -. \n(z :. t) . s... (1) where . = (., .) ((x :. A) . B) . t -. (x :. A) . (B . t) (2) if .i such that i . \n. and i . . ((x :. A) . B) . t -. (x :. A) . (B . (t . x)) (3) otherwise (.x :. A.b) . t -. b[t/x] (4) \nand congruences. De.nition 9 (Substitution). The substitution of variables in i\u00adoblivious contexts erases \ni from the substitutees. (F . a)[u/x] = F [u/x] . a[u{.}/x] ((y :. A) . B)[u/x] = (y :. A[u{.}/x]) . \nB[u/x] (.y :. A.b)[u/x] = .y :. A[u{.}/x].b[u/x] Where u{(., .)} = Luj.   \n\t\t\t", "proc_id": "2500365", "abstract": "<p>Dependent type-theory aims to become the standard way to formalize mathematics at the same time as displacing traditional platforms for high-assurance programming. However, current implementations of type theory are still lacking, in the sense that some obvious truths require explicit proofs, making type-theory awkward to use for many applications, both in formalization and programming. In particular, notions of erasure are poorly supported.</p> <p>In this paper we propose an extension of type-theory with colored terms, color erasure and interpretation of colored types as predicates. The result is a more powerful type-theory: some definitions and proofs may be omitted as they become trivial, it becomes easier to program with precise types, and some parametricity results can be internalized.</p>", "authors": [{"name": "Jean-Philippe Bernardy", "author_profile_id": "81372591366", "affiliation": "Chalmers University of Technology, Gothenburg, Sweden", "person_id": "P4261219", "email_address": "bernardy@chalmers.se", "orcid_id": ""}, {"name": "Moulin Guilhem", "author_profile_id": "83058849657", "affiliation": "Chalmers University of Technology, Gothenburg, Sweden", "person_id": "P4261220", "email_address": "mouling@chalmers.se", "orcid_id": ""}], "doi_number": "10.1145/2500365.2500577", "year": "2013", "article_id": "2500577", "conference": "ICFP", "title": "Type-theory in color", "url": "http://dl.acm.org/citation.cfm?id=2500577"}