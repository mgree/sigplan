{"article_publication_date": "06-07-2008", "fulltext": "\n Expressive and Safe Static Re.ection with MorphJ Shan Shan Huang Yannis Smaragdakis College of Computing \nDepartment of Computer and Information Science Georgia Institute of Technology University of Oregon ssh@cc.gatech.edu \nyannis@cs.uoregon.edu Abstract Recently, language extensions have been proposed for Java and C# to support \npattern-based re.ective declaration. These extensions introduce a disciplined form of meta-programming \nand aspect\u00adoriented programming to mainstream languages: They allow mem\u00adbers of a class (i.e., .elds \nand methods) to be declared by statically iterating over and pattern-matching on members of other classes. \nSuch techniques, however, have been unable to safely express sim\u00adple, but common, idioms such as declaring \ngetter and setter meth\u00adods for .elds. In this paper, we present a mechanism that addresses the lack of \nexpressiveness in past work without sacri.cing safety. Our tech\u00adnique is based on the idea of nested \npatterns that elaborate the outer-most pattern with blocking or enabling conditions. We im\u00adplemented \nthis mechanism in a language, MorphJ. We demonstrate the expressiveness of MorphJ with real-world applications. \nIn par\u00adticular, the MorphJ reimplementation of DSTM2, a software trans\u00adactional memory library, reduces \n1,107 lines of Java re.ection and bytecode engineering library calls to just 374 lines of MorphJ code. \nAt the same time, the MorphJ solution is both high level and safer, as MorphJ can separately type check \ngeneric classes and catch er\u00adrors early. We present and formalize the MorphJ type system, and offer a \ntype-checking algorithm. Categories and Subject Descriptors D.1.5 [Programming Tech\u00adniques]: Object-oriented \nProgramming; D.3.1 [Programming Languages]: Formal De.nitions and Theory; D.3.3 [Program\u00adming Languages]: \nLanguage Constructs and Features General Terms Languages Keywords object-oriented programming, structural \nabstraction, class morphing, aspect-oriented programming, meta-programming, language extensions 1. Introduction \nConsider the following task: how would you write a piece of code that, given any class X, returns another \nclass that contains the exact same methods as X, but logs each method s return value? That is, the code \nis a modular representation of the functionality logging , and abstracts over the exact methods it may \nbe applied to. Capturing this level of abstraction has traditionally been only possible with techniques \nsuch as meta-object protocols (MOPs) Permission to make digital or hard copies of all or part of this \nwork for personal or classroom use is granted without fee provided that copies are not made or distributed \nfor pro.t or commercial advantage and that copies bear this notice and the full citation on the .rst \npage. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior \nspeci.c permission and/or a fee. PLDI 08, June 7 13, 2008, Tucson, Arizona, USA. Copyright &#38;#169; \n2008 ACM 978-1-59593-860-2/08/06. . . $5.00 [17], aspect-oriented programming (AOP) [18], or various \nforms of meta-programming (e.g., re.ection and ad-hoc program generation using quote primitives, string \ntemplates, or bytecode engineering). While just about any programmer can write a method that logs its \nreturn value, the techniques listed above are largely unapproach\u00adable. Additionally, these techniques \nbypass the guarantees offered by the type system so that there is no pre-application guarantee that the \nresulting code would be well-formed. Recently, extensions have been proposed [14, 7]for Java and C#, \nto bridge this gap between the lack of expressiveness in main\u00adstream languages, and the lack of type \nsafety in the more exotic techniques mentioned above. Both extensions introduce a notion of static (as \noppose to runtime) iteration over .elds or methods of a class, interface, or type variable. A simple \npattern language is used to match on the elements being iterated over. A declaration can be made for \neach element in the iteration, using pattern-matched vari\u00adables. We call this type of declaration pattern-based \nre.ective dec\u00adlaration and the general technique class morphing. For example, using MJ, the Java extension \nwe introduced in [14], we can write the following generic class: 1 class LogMe<class X> extends X { \n2 <R,A*>[m] for ( public R m(A) : X.methods ) 3 public Rm (A a){ 4 R result = super.m(a); 5 System.out.println(result); \n6 return result; 7 } 8 } This MJ generic class extends its own type parameter X.Lines 2-7 form a re.ective \ndeclaration block: line 2 de.nes the range of elements being iterated over; lines 3-7 are the method \nbeing declared once for each element in the iteration range. The iteration happens statically. Line 2 \nsays we want to iterate over all methods of X that match the pattern public R m (A) , where R, A,and \nm are pattern variables (declared before the keyword for). R and A are pattern type variables, where \nR matches any type except void,and A, because of the * notation in A s declaration, matches a sequence \nof types of any length, including zero. m is a name variable, and matches any identi.er. Thus, this block \niterates over all public methods of X that take any number of arguments, and have non\u00advoid returns. For \neach such method, it declares a method with the same signature. For example, LogMe<java.io.File> gives \nus a version of File with all its methods return values logged. This task can be similarly accomplished \nwith Compile-Time Re.ection (CTR) [7], an extension proposed for C#. MJ and CTR increase the expressiveness \nof their respective base languages by providing a limited form of meta-programming, through a familiar \nsyntax accessible to the average programmer. They additionally offer a level of static type safety that \nhas never been achieved by mechanisms like MOPs, AOP, or various forms of meta-programming. For instance, \nMJ preserves the separate type\u00adcheckability of Java generics: a generic class can be type checked separately \nfrom the types it may be instantiated with, and a well\u00adtyped generic class will never introduce a type \nerror in its instanti\u00adated form. Thus, the class LogMe<X> is guaranteed to never contain type errors, \nno matter what X is instantiated to. However, simple pattern-based re.ective declaration is not ex\u00adpressive \nenough for many common tasks that are otherwise per\u00adfectly suited for this type of mechanism. Example \n1: Consider the pesky problem of de.ning getter methods for .elds in a class. Currently, programmers \ndeal with this by repeating the same boiler-plate code for each .eld. This seems to be a task perfectly \nsuited for pattern-based re.ective declaration. However, we cannot implement this in a type-safe way \nusing MJ or CTR. Consider the following attempt in MJ: class AddGetter<class X> extends X { <F>[f] for \n( F f : X.fields ) F get#f () { return super.f; } } AddGetter<X> de.nes a method get#f() for each .eld \nf in type variable X. get#f denotes an identi.er that begins with the string get , followed by the identi.er \nmatched by f.1 However, AddGetter<X> is not modularly type safe we cannot guarantee that no matter what \nX is instantiated with, AddGetter<X> is always well-typed! Suppose we have class C: class C { Meal lunch; \n... // other methods. boolean getlunch() { return isNoon() ? true : false; } } AddGetter<C> contains \nmethod Meal getlunch() , which in\u00adcorrectly overrides method boolean getlunch() in its super\u00adclass, C. \nFor this reason, the de.nition of AddGetter<X> does not pass MJ s type-checking. This is an error of \nunder-speci.ed requirements. The de.nition of AddGetter<X> should clearly specify that it can only declare \nmethod get#f for those .elds f where a con.ictingly de.ned get#f does not already exist in X. However, \nthe pattern-matching language in MJ (or CTR) does not allow us to specify such a condition. What we need \nis to place a negative existential condition on each .eld matched by the pattern: for all .elds f of \nX such that method get#f() does not already exist in X, declare the method get#f(). Example 2: Consider \nhow one would de.ne a class Pair<X,Y>, which is a container for objects x and y of types X and Y, respec\u00adtively. \nFor every non-void method that X and Y have in common (i.e., same method name and argument types), Pair<X,Y> \nshould declare a method with the same name and argument types, but a return type that is another Pair, \nconstructed from the return types of that method in X and Y. Again, this task seems perfectly suited \nfor pattern-based re.ec\u00adtive declaration. Yet there is no way to de.ne such a class using MJ (or CTR). \nWhat we need is a positive existential condition:for all methods in X, such that another method with \nthe same name and argument types exists in Y, declare a method that invokes both and returns a Pair of \ntheir values. Contributions: In this work, we introduce nested patterns. Nested patterns act as existential \nconditions that either enable or block the applicability of the outer-most (primary) pattern. We im\u00ad \n1 This MJ class only de.nes getter methods for non-private .elds: the se\u00admantics of pattern Ff without \nmodi.er speci.cation is that it matches all non-private .elds. This is a limitation with the subclassing-as-extension \nbased approach that MJ adopts. plemented nested patterns in our language, MorphJ, an extension of MJ \n[14].2 Nested patterns make the following contributions: Nested patterns signi.cantly enhance the expressiveness \nof pattern-based re.ective declarations. Without nested patterns, languages like MJ and CTR are mostly \nlimited to expressing wrapper-like patterns [8], such as the logging class LogMe<X>.  Nested patterns \nalso form the basis for adding more features to the MorphJ language, such as a static if and a static \nerrorif statements. The static if allows code to exist or not depend\u00ading on the existence or absence \nof other members. The static errorif acts as a type-cast: it allows the type system to assume the existence \nor absence of a member, and, if the assumption is violated, an instantiation-time error occurs.  We \ndemonstrate the power of nested patterns with real-world applications. We reimplemented parts of DSTM2 \n[10], a Java software transactional library that heavily uses re.ection and bytecode engineering (with \nBCEL [2]) to transform sequential classes into transactional ones. The MorphJ re-implementation replaces \n1,107 lines of Java re.ection and BCEL library calls with 374 lines of MorphJ code. We also implemented \na generic class that provides default implementations for unimplemented interface methods, for a combination \nof any class and any in\u00adterface. The current solutions to this problem are either imple\u00admented as extensions \nto the underlying language itself, or use unsafe code generation with templates. We show in Section 3 \nhow the MorphJ implementations are easy to write, easy to un\u00adderstand, as well as type safe.  Nested \npatterns create additional challenges for type checking. We show the techniques involved to preserve \nthe separate type\u00adcheckability of generic classes in MorphJ. We formalize our type system and prove it \nsound. We offer a decidable algorithm for type-checking. In the remainder of this paper, we start by \nintroducing the syntax  and example usages of nested patterns in MorphJ (Section 2). We then show real-world \napplications implemented using MorphJ (Section 3). In Section 4, we discuss the type-checking issues \nraised by nested patterns and introduce our type rules in an informal manner. We then formalize a core \nsubset of MorphJ and present the type rules in Section 5. We continue with a discussion on related work \nin Section 6 and conclude with our grand-scheme view of the evolution of programming languages and the \nrole of MorphJ and other related mechanisms (Section 7).  2. Re.ective Declarations with Nested Patterns \nMorphJ extends the re.ective declaration blocks of MJ [14] with nested patterns. A nested pattern has \nthe same syntactic form as a primary pattern, but is preceded by the keywords some (for a positive nested \npattern) or no (for a negative nested pattern). Like primary patterns, nested patterns can only re.ect \nover con\u00adcrete types, or type variables of the generic class. A nested pattern places a condition (nested \ncondition) on each element matched by the primary pattern. An element must be matched by the primary \npattern and satisfy all nested conditions to be a part of a re.ective block s iteration range. We illustrate \nthe use of nested patterns with the following examples. 2.1 Negative Nested Pattern A negative nested \npattern exerts a condition that is only satis.ed if there is nothing in the range of elements matched \nby the pattern. 2 MorphJ is effectively MJ 2.0. The change of name was decided to avoid ambiguity in \nour efforts to release the software for wide use MJ is an overloaded term for indexing and search purposes. \nNevertheless, the change is also convenient in the context of this paper as it enables us to refer to \nold capabilities by name. Negative nested patterns allow us to implement a modularly type safe AddGetter<X>: \n 1 class AddGetter<X> extends X { 2 <F>[f]for( F f : X.fields ; no get#f() : X.methods ) 3 F get#f() \n{ return super.f; } 4 } The nested pattern condition on line 2 is only satis.ed by those .elds f of \nX for which there is no method get#f() in X.(The missing return type in the nested pattern is a MorphJ \nshorthand for matching both void and non-void return types.) Observe that this AddGetter<X> class will \nnot introduce ill-typed code for any X. Potentially con.icting method declarations are prevented by the \nnegative nested pattern. A .eld f for which a method get#f() already exists in X does not satisfy the \nnested condition, and thus is not in the iteration range of the re.ective block.  2.2 Positive Nested \nPattern A positive nested pattern exerts a condition that is only satis.ed if there is some element in \nthe range matched by the pattern. A positive nested pattern allows us to de.ne the Pair<X,Y> class discussed \nin the Introduction as follows: 1 public class Pair<X,Y> { 2 Xx;Yy; 3 public Pair(X x, Y y) { this.x \n= x; this.y = y; } 4 5 <RX extends Object, RY extends Object, A*>[m] 6 for( public RX m(A) : X.methods \n; 7 some public RY m(A) : Y.methods ) 8 public Pair<RX,RY> m(A args) { 9 return new Pair<RX,RY>(x.m(args), \ny.m(args)); 10 } 11 } Methods of Pair<X,Y> are de.ned using the re.ective block on lines 5-10. The primary \npattern on line 6 matches all non-void and non-primitive methods of X. For each such method, the positive \nnested condition on line 7 is only satis.ed if a method with the same name and argument types also exists \nin Y. Thus, the primary and nested patterns in this class .nd precisely all methods that X and Y share \nin name and argument types. For each such method, Pair<X,Y> declares a method with the same name and \nargument types, and a body that invokes the corresponding method of X and Y. The return type is another \nPair, constructed from the return values of the invocations. Following the same pattern, the class can \nbe enhanced to also handle methods returning primitive types or void.  2.3 More Features: if, errorif \nNested patterns enable other powerful language features. The re\u00ad.ective declarations we have seen so \nfar have been iteration-based: a piece of code is declared for each element in the iteration range. MorphJ \nalso supports condition-based re.ective declarations and statements. An example (from an application \ndiscussed in detail in Section 3) illustrates the usage of pure conditions in re.ective dec\u00ad larations: \n<R> if ( no public R restore() : X.methods ) public void restore() { ... } The above re.ective declaration \nblock consists of a statically ex\u00aderted condition, speci.ed by the pattern following the if keyword. \nIf the pattern condition is satis.ed, the code following the condi\u00adtion is declared. Thus, method void \nrestore() is only declared if a method restore(), with any non-void return type, does not al\u00adready exist \nin X. Another useful feature is introduced by the errorif keyword. errorif acts as a type-assertion, \nallowing the programmer to ex\u00ad press facts that he/she knows are true about a type parameter. For instance, \nthe programmer can express a mixin class that is only ap\u00adplicable to non-con.icting classes: 1 class \nSizeMixin<X> extends X { 2 <F> errorif ( some F size : X.fields ) 3 int size = 0; 4 } In this case, \nthe programmer wants to assert that, if the parame\u00adter type C already contains a .eld named size, this \nis not an error in the de.nition of SizeMixin but in the instantiation SizeMixin<C>. Thus, the errorif \nconstruct serves as a typical type-cast: it is both an assumption that the type system can use (i.e., \nwhen checking SizeMixin<X> it can be assumed that X has no size .eld) and at the same time a type obligation \nfor a later type-checking stage. Unlike, however, traditional type-casts that turn a static type check \ninto a run-time type check, an errorif turns a modular type check into a non-modular (type-instantiation \ntime), but still static, type check.  2.4 Semantics of Nested Patterns Similarly to primary patterns, \na nested pattern introduces an itera\u00adtion. However, nested patterns are only used to return a true/false \ndecision. For instance, in class Pair<X,Y>, the nested pattern iter\u00adates over all the methods in Y matching \nthe pattern, but the itera\u00adtion only serves to verify whether a matching method exists, not to produce \ndifferent code for each matching method. Furthermore, multiple nested patterns are all nested at the \nsame level, forming a conjunction of their conditions. Nested patterns may use pattern variables that \nare not bound by any primary pattern. However, there are restrictions as to how vari\u00adables bound only \nby nested patterns can be used in code introduced by the re.ective block (i.e., the re.ective declaration). \nPattern vari\u00adables bound by only negative nested patterns cannot be used in the re.ective declaration \nat all. For instance, the pattern no public R restore() above bound type variable R.However, R only appears \nin a negative nested pattern, and thus cannot be used in the dec\u00adlaration of restore(). Intuitively, \na variable in a negative nested pattern is never bound to any concrete type/identi.er no match can exist \nfor the negative nested condition to be satis.ed. Clearly, an unbound variable cannot be used in declarations. \nPattern variables that are bound by positive nested patterns, however, can be used in the re.ective declaration, \nif we can deter\u00admine that exactly one element can be matched by the nested pattern. This is the case \nonly if all uniquely identifying parts of the nested pattern use either constants, or pattern variables \nbound by the pri\u00admary pattern. The uniquely identifying parts of a method pattern are its name and argument \ntypes, and the uniquely identifying part of a .eld pattern is its name. For example, in Pair<X,Y>, the \nposi\u00adtive nested pattern some RY m(A) : Y.methods uses m and A in its uniquely identifying parts. Both \npattern variables are bound by the primary pattern. Thus, we can use RY in the re.ective declaration, \neven though it only appears in the nested pattern. It may not be immediately obvious how if and errorif \nrelate to nested patterns. However, the type system machinery that enables if and errorif is precisely \nthat of nested patterns. The patterns used as if and errorif conditions are regular nested patterns (with \nsome and no) with the same semantics and conditions (e.g., limitations on when bound variables can appear \nin a re.ective declaration). Indeed, even our actual implementation of the static if statement translates \nit intermediately into a static for loop with a special unit value for the primary pattern condition. \nWe do not allow the nesting of primary patterns i.e., it is not legal to have nested static for loops. \nHowever, if and errorif declarations and statements can be freely nested within the scopes of one another, \nor within the scope of a static for loop.  3. Real-World Applications We next show two real world applications, \nre-implemented con\u00adcisely and safely with nested patterns. 3.1 DSTM2 DSTM2 [10] is a Java library implementing \nobject-based software transactional memory. It provides a number of transactional fac\u00adtories that take \nas input a sequential class, and generate a trans\u00adactional class. Each factory supports a different transactional \npol\u00adicy. The strength of DSTM2 is in its .exibility. Users can mix and match policies for objects, or \nde.ne new factories implementing their own transactional policies. In order to automatically generate \ntransactional classes, DSTM2 factory classes use a combination of Java re.ection, bytecode en\u00adgineering \nwith BCEL [2], and anonymous class de.nitions. How\u00ad ever, the information needed for these generations \nis purely static and structural. The authors of DSTM2 had to employ low-level run\u00adtime techniques because \nthe Java language does not offer enough support for compile-time transformation of classes. MorphJ, how\u00adever, \nis a good .t for this task. In our re-implementation of DSTM2 s factories and support\u00ading classes, 1,107 \n(non-commented, non-blank) lines of Java code are replaced with 374 lines of MorphJ code. For example, \nwe replaced DSTM2 s factory.shadow.RecoverableFactory<X> and factory.shadow.Adaptor<X> with the MorphJ \nclass Recoverable<X> in Figure 1. 1 @atomic public class Recoverable<class X> extends X { 2 // for each \natomic field of X, declare a shadow field. 3 <F>[f]for(@atomic F f: X.fields; no shadow#f: X.fields) \n4 F shadow#f; 5 6 // for each field of X, declare a getter. 7 <F>[f]for(@atomic F f: X.fields; no get#f(): \nX.methods) 8 public F get#f () { 9 Transaction me = Thread.getTransaction(); 10 Transaction other = \nnull; 11 while (true) { 12 synchronized (this) { 13 other = openRead(me); 14 if (other == null) { return \nf; } 15 } 16 manager.resolveConflict(me, other); 17 } 18 } 19 20 // for each field of X, declare a setter \n21 <F>[f]for(@atomic F f : X.fields; 22 no set#f(F) : X.methods) 23 public void set#f ( F val ) { 24 \n... // code to open transaction. 25 f = val; 26 ... // code resolving conflict. 27 } 28 29 // create \nbackup method 30 <R>if ( no R backup() : X.methods ) 31 public void backup() { 32 <F>[f] for (@atomic \nF f : X.fields) 33 shadow#f = f; 34 } 35 36 // create recover method 37 <R>if ( no R recover() : X.methods \n) 38 public void recover() { 39 // restore field values from shadow fields. 40 <F>[f] for ( @atomic F \nf : X.fields ) 41 f = shadow#f; 42 } 43 } Figure 1. A recoverable transactional class in MorphJ. For \neach .eld of X, Recoverable<X> creates a shadow .eld, as well as getter and setter methods that acquire \na lock from a transactional manager .rst, perform the read or write, and then resolve con.icts before \nreturning. Furthermore, it creates backup() and restore() methods to backup and restore .elds to and \nfrom their shadow .elds.3 The advantage of the MorphJ implementation is two-fold. First, Recoverable<X> \nis guaranteed to never declare con.icting declara\u00adtions. For example, shadow#f is only declared if this \n.eld does not already exist in X,and backup() is only declared if such a method does not already exist \nin X. Implementations using re.ection and bytecode engineering enjoy no such guarantees, and must instead \nrely on thorough testing to discover potential bugs. Secondly, class Recoverable<X> is easier to write \nand under\u00adstand. For example, the code for generating a backup() method in DSTM2 s RecoverableFactory<X> \nis illustrated in Figure 2. We invite the reader to compare the backup() method declaration in Figure \n1 (lines 29-33) to the code in Figure 2. 1 public class RecoverableFactory<X> 2 extends BaseFactory<X> \n{ 3 ... 4 public void createBackup() { 5 InstructionList il = new 6 InstructionList(); MethodGen method \n= 7 new MethodGen(ACC_PUBLIC, Type.VOID, Type.NO_ARGS, 8 new String[] { }, \"backup\", 9 className, il, \n_cp); 10 11 for (Property p : properties) { 12 InstructionHandle ih_0 = 13 il.append(_factory.createLoad(Type.OBJECT, \n0)); 14 il.append(_factory.createLoad(Type.OBJECT, 0)); 15 il.append(_factory 16 .createFieldAccess(className, \np.name, 17 p.type, 18 Constants.GETFIELD)); 19 il.append(_factory. 20 .createFieldAccess(className, 21 \np.name + \"$\", 22 p.type, 23 Constants.PUTFIELD)); 24 } 25 26 InstructionHandle ih_24 = 27 il.append(_factory.createReturn(Type.VOID)); \n28 method.setMaxStack(); 29 method.setMaxLocals(); 30 _cg.addMethod(method.getMethod()); 31 il.dispose(); \n32 } 33 } Figure 2. DSTM2 code for creating a method backup(). Interestingly, the predecessor of DSTM2 \nis a C# software trans\u00adactional memory library called SXM [9]. It was re-implemented by F\u00a8ahndrich, Carbin \nand Larus as the quintessential example of Compile-Time Re.ection (CTR) [7]. However, CTR s safety guar\u00ad \nantees only concern the validity of references, and not declaration con.icts. We give a more detailed \nexposition of CTR in Section 6.  3.2 Default Implementations for Interface Methods Java ensures that \na class cannot be declared to implement an in\u00adterface unless it provides implementations for all of the \ninterface s methods. This often results in very tedious code. For instance, it is common in code dealing \nwith the Swing graphics library to im\u00adplement an event-listener interface, yet provide empty implementa\u00ad \n3 The MorphJ implementation replicates the functionality of DSTM2 fac\u00adtory classes, but with low-level \ndifferences. For instance, a DSTM2 factory generates transactional classes from interface de.nitions. \nIt parses the inter\u00adface s method names that begin with get and set to determine the .eld names to generate. \nWe believe this to be a design artifact due to the con\u00adstraints of the Java language. We instead statically \niterate over the @atomic .elds of classes, and generate backup .elds as needed. tions for most of the \ninterface methods because the application does not care about the corresponding events. In response to \nthis need, there have been mechanisms proposed [11, 20] that allow the pro\u00ad grammer to specify that he/she \nwants just a default implementation for all members of an interface that are not already implemented \nby a class. These past solutions introduced new keywords (or Java annotations) for this speci.c feature. \nThey either have no guarantee for the well-typedness of generated code [11], or require extensions to \nthe Java type system [20]. These changes to the underlying lan\u00ad guage are required to support just this \none feature. In contrast, we can express these language extensions as a MorphJ generic class that is \nguaranteed to always produce well-typed code. Below is a slightly simpli.ed version of the MorphJ solution \nto this problem. (For conciseness, we elide the declarations dealing with void-or primitive-type-returning \nmethods, which roughly double the code.) 1 class DefaultImplementation<X,interface I> implements I { \n2 Xx; 3 DefaultImplementation(X x) { this.x = x; } 4 5 // for all methods in I, if the same method does \n6 // not appear in X, provide default implementation. 7 <R extends Object,A*>[m]for( R m (A) : I.methods \n; 8 no R m (A) : X.methods ) 9 R m (A a) { return null; } 10 11 // for all methods in X that *do* correctly \noverride 12 // methods in I, we need to copy them. 13 <R,A*>[m]for( R m (A) : I.methods ; 14 some R m \n(A) : X.methods ) 15 R m (A a) { return x.m(a); } 16 17 // for all methods in X, such that there is no \nmethod 18 // in I with the same name and arguments, copy method. 19 <R,A*>[m]for( R m (A) : X.methods; \n20 no m (A) : I.methods) 21 R m (A a) { return x.m(a); } 22 } Class DefaultImplementation<X,I> copies \nall methods of type X that either correctly implement methods in interface I,orare guaranteed to not \ncon.ict with methods in I. For methods in I that have no counterpart in X, a default implementation is \nprovided. Methods in X that con.ict with methods in I (same argument types, different return) are ignored. \nThe above code demonstrates the power of nested patterns, both in terms of expressiveness, and in terms \nof type safety. The application naturally calls for different handling of methods in a type, based on \nthe existence of methods in another type. Furthermore, these declarations are guaranteed to be unique, \nand their uniqueness is crucially based on nested patterns.  4. Type-Checking Nested Patterns The complexity \nin type-checking pattern-based re.ective declara\u00adtions arises from the existence of pattern type and \nname variables. When a declaration is made using such variables, how can we check that for all concrete \ntypes and identi.ers these variables could ex\u00adpand to, the declaration will always be unique? Similarly, \nhow can we check that a reference made using a name variable always refers to an entity that is declared? \nThe key is to treat a declaration as a range of declared elements. (A declaration made without pattern \nvariables has a one-element range.) Determining the uniqueness of two declarations then re\u00adduces to determining \nwhether their ranges are disjoint. Similarly, a reference is also a range. Determining whether a reference \nis valid then reduces to determining subsumption: do all entities in the ref\u00aderence range have corresponding \nentities in the declaration range? In this section, we introduce the techniques for checking ref\u00aderence \nvalidity and declaration uniqueness with nested patterns. We focus on declarations and references made \nby re.ecting over type variables: re.ecting over non-variable types is simply syntac\u00adtic sugar for manually \ninlining the declarations. We further focus on the rules for type-checking methods rules for .elds are \na triv\u00adial adaptation of those for methods. 4.1 Reference Validity Let us take another look at class \nLogMe<X> from the Introduction: 1 class LogMe<class X> extends X { 2 <R,A*>[m] for ( public R m(A) : \nX.methods ) 3 public Rm (A a){ 4 R result = super.m(a); 5 System.out.println(result); 6 return result; \n7 } 8 } How do we know that the method invocation super.m(a) (line 4) is valid? Notice that the range \nof m (i.e., all the identi.ers it could expand to) is exactly the names of methods matched by the primary \npattern on line 2: all non-void methods of X. This range is certainly subsumed by the range of all methods \ndeclared for X.Thus,we know method m exists, no matter what X is. Furthermore, how do we know we are \ninvoking m with the right arguments? The type of a is A: exactly the argument type m of X is expecting. \nThings get a bit more complex when a name variable bound in one re.ective block references a method declared \nin a different re.ective block. Consider the following class, which logs the argu\u00adments of methods accepting \nstrings, before calling LogMe to log the return value. 1 class LogStringArg<class Y> { 2 LogMe<Y> loggedY; \n3 4 <T>[n] for ( public T n(String) : Y.methods ) 5 public T n (String s) { 6 System.out.println(\"arg: \n\" + s); 7 return loggedY.n(s); 8 } 9 } How do we know that loggedY.n(s) (line 7) is a valid reference, \nwhen the methods of loggedY are de.ned in a different class and a different re.ective block? The key \nis to determine that the range of n is subsumed by the range of methods in LogMe<Y>.This is to say that \nthe range of n s enclosing re.ective block should be subsumed by the range of LogMe<Y> s declaration \nre.ective block. Observe that the declaration block of LogMe<Y> is de.ned over methods of Y (after substituting \nY for X), as is the re.ective block enclosing n. Secondly, the pattern for the declaration block of LogMe<Y> \nis more general than the pattern for the re.ective block enclosing n:the former matches all non-void \nmethods, and the latter matches all non-void methods taking exactly one String argument. Thus, any method \nthat is matched by the reference re.ective block s pattern is matched by the declaration re.ective block \ns pattern, regardless of what Y is. Thus, there is always a method n in LogMe<Y>. Whether a pattern is \nmore general than another can be sys\u00adtematically determined by .nding a one-way uni.cation from the more \ngeneral pattern to the more restricted one. In a one-way uni\u00ad.cation, only pattern variables declared \nfor the more general pat\u00adtern are used as uni.cation variables. All other pattern variables are considered \nconstants. In this example, we can unify public R m(A) to public T n(String) using the mapping {R.n, \n.T, mA .{String}}. We also use this uni.cation mapping in determining whether n is invoked with the right \nargument types. We apply the mapping to the method declaration in LogMe<Y>, and get the declared signature \npublic T n(String) . Since s has the type String, the invocation is clearly correct. Furthermore, we \ncan check that the result of the invocation is of type T, which is precisely the expected return type \nof the method enclosing loggedY.n(s) . For the case of nested patterns, consider the following class: \n 1 class VoidPair<X,Y> { 2 X x; Y y; ...// constructor to initialize x and y. 3 4 <A*>[m]for ( public \nvoid m(A) : X.methods ; 5 some public void m(A) : Y.methods ) 6 public void m (A a) { x.m(a); y.m(a); \n} 7 } VoidPair<X,Y> declares a method for every void method that X and Y share in name and argument \ntypes, and invokes that method on x and y. Using the reference rules described previously, we know that \nx.m(a) is a valid reference. Furthermore, because the pattern variables used in the positive nested pattern \non line 5 are all bound by the primary pattern, we know that if the nested condition is satis.ed, there \nis exactly one element in the range of the nested pattern, so the call y.m(a) is unambiguous. Since the \ntypes also match, y.m(a) is a valid reference, as well. Let us now consider the general case of a reference \nmade in one re.ective block, to declarations made in another re.ective block, when both blocks have nested \npatterns. Let Rd and Rr denote the ranges for the re.ective blocks of the declaration and the reference, \nrespectively. There are two suf.cient conditions to determine that Rr is subsumed by Rd. First, the primary \nrange of Rr must be subsumed by the primary range of Rd. Second, for all methods that are in the primary \nrange of Rr (and thus also in the primary range of Rd), if the method satis.es the nested conditions \nof Rr,it should also satisfy the nested conditions of Rd. That is to say, the nested conditions of Rr \nshould be stronger, and imply the nested conditions of Rd. Determining that one nested condition implies \nanother can be reduced to single range subsumption. Let (Nr,Tr)denote the range of a nested pattern Nr \nmatching over the methods of type Tr.Let (Nd,Td) be similarly interpreted. Let + pre.x a positive nested \ncondition, and - pre.x a negative nested condition. We have two ways of determining that one condition \nimplies another: +(Nr,Tr) implies +(Nd,Td) if (Nd,Td) subsumes (Nr,Tr). -(Nr,Tr) implies -(Nd,Td) if \n(Nr,Tr) subsumes (Nd,Td). Intuitively, +(Nr,Tr) is satis.ed if there is at least one element in (Nr,Tr). \nThen there is certainly at least one element in a larger range, as well. Thus, +(Nd,Td)should be satis.ed. \nSimilar reason\u00ading applies for the implication between two negative conditions. To be more concrete, \nconsider the following class: 8 class CallVoidsWithString<T,S> { 9 VoidPair<T,S> voidPair; 10 ... // \nconstructor to initialize voidPair 11 [n]for ( public void n(String) : T.methods ; 12 some public void \nn(String) : S.methods ) 13 public void n (String s) { voidPair.n(s); } 14 } For every void method taking \none String argument that T and S have in common, CallVoidsWithString<T,S> declares a method with the \nsame signature, and invokes a method with the same name on voidPair, of type VoidPair<T,S>. This reference \nis valid if the range of the re.ective block on lines 11-12 is subsumed by the range of the declaration \nre.ective block (lines 4-5 in the de.nition of VoidPair). The range of primary pattern on line 11 is \nsubsumed by the range of declaration s primary pattern (line 4), by the one-way uni.cation mapping {m.n, \nA .{String}}. To check whether the nested pattern on line 5 subsumes the nested pattern on line 12, note \nthat we .rst apply the uni.cation mappings obtained from unifying the primary patterns we only want to \ndetermine this subsumption relationship for those methods that lie in the range of both primary patterns. \nIn our example, af\u00adter applying the uni.cation mapping to the positive nested pattern on line 5 (and \nalso substituting S for Y), we have public void n(String) : S.methods . This clearly subsumes public \nvoid n(String) : S.methods on line 12. These two conditions guarantee us that reference voidPair.n(s) \nis always a valid one. It is easy to check that this is indeed the case. The above approach generalizes \nto an arbitrary number of nested conditions: each nested condition in the declaration range must be implied \nby at least one nested condition in the reference range. A range with no nested patterns is equivalent \nto a range with a positive nested pattern that subsumes everything, or a negative nested pattern that \nis subsumed by everything. The case where there are only nested patterns (i.e., if and errorif statements) \ncan be re\u00adduced to a range with a special primary pattern value that subsumes only itself and is subsumed \nonly by itself.  4.2 Uniqueness of Declarations We use range disjointness to check whether two declarations \nare unique. In the case of method declarations, uniqueness means two methods within the same class (including \ninherited methods) can\u00adnot have the same name and argument types.4  4.2.1 Internally Well-de.ned Range \nA simple property to establish is that declarations introduced by the same re.ective block do not con.ict. \nConsider the following class: 1 class CopyMethods<X> { 2 <R,A*>[m] for( R m (A) : X.methods ; nestedConds \n) 3 Rm (A a){ ... } 4 } CopyMethods<X> s methods are declared within one re.ective block. The iteration \nrange of this block comprises all non-void methods of X that also satisfy arbitrary nested conditions, \nnested-Conds. For each of these methods, a method with identical signa\u00adture is declared for CopyMethods<X>. \nHow do we guarantee that, given any X, the method declarations within this block are always unique? Observe \nthat X can only be instantiated with a well-formed type (the base case being Object), and all well-formed \ntypes have unique method declarations. Thus, if the declaration block merely copies the name and argument \ntypes of methods from a well-formed type, the methods declared by this block are guaranteed to be unique, \nas well.  4.2.2 Uniqueness Across Ranges When one or both methods are de.ned using re.ective iterations, \ntheir uniqueness means that the range of their (name, argument types) tuple cannot overlap. This can \nbe determined by a two-way uni.cation of the two declarations. In a two-way uni.cation, pat\u00ad tern variables \nfrom both re.ective blocks are uni.cation variables. Let us start with a simple example. Consider the \nfollowing class: 1 class DisjointDecs<X> { 2 <R>[m] for(R m (int) : X.methods; nestedConds1 ) 3 R m \n(int i) ... 4 5 <S>[n] for(S n (int) : X.methods; nestedConds2 ) 6 S n (int i, String s) ... 7 } 4 In \nJava, methods in a subclass are allowed to override their counterparts in the superclass with co-variant \nreturn types. This involves a relaxation of the rules we describe in this section: return types in the \nsubclass are allowed to be subtypes of their counterparts in the superclass. It is easy to see that the \ndeclarations on lines 3 and 6 cannot overlap for any X. There is no uni.cation to make the two signatures \nhave the same (name, argument types) tuple, because there is simply no way to unify {int} with {int,String}. \nWhen two method signatures do unify, there may be overlap in the declarations. However, if we can prove \nthat overlapping ele\u00adments are infeasible, then the declarations are still unique. An over\u00adlap is infeasible \nif the uni.cation mapping producing the overlap, when applied to the primary and nested patterns, produces \nmutually exclusive conditions. Note that a non-empty primary pattern range states a condition, as well \nit is a positive condition that says some element exists in this range. Consider the following class: \n 1 class StillUnique<X> { 2 <A1>[m]for( String m (A1) : X.methods ; nestedConds1 ) 3 void m (A1 a) {... \n} 4 5 <A2>[n]for( int n (A2) : X.methods ; nestedConds2 ) 6 void n (A2 a) {... } 7 } The declared signatures \non lines 3 and 6 unify with the mapping {m .n, A1.A2}. Applying this mapping to the primary patterns \non lines 2 and 5, we get String n (A2) : X.methods , and int n (A2) : X.methods . Methods matched by \nthese patterns can cause con.icting declarations. However, having at least one method in both of these \nranges means that there need to be two methods in X with the same name and argument types, but different \nreturn types. This directly contradicts the fact that X is a well-formed type. Thus, this uni.cation \nmapping produces mutually exclusive conditions between the two primary pattern conditions, and there \nare no elements that would make the mapping possible. These declarations are thus still disjoint. There \nare two ways to determine whether two conditions are mutually exclusive. Using the same notation as before, \n+(Pn,Tn) and +(P,Sn) are mutually exclusive if Tn is a subtype of Sn,and Pnn, Pnhave unifying method \nname and argument types, but different return types. +(Pn,Tn) and -(P,Sn) are mutually exclusive if (P,Sn) \nnn subsumes (Pn,Tn) We apply these rules on all pairs of conditions. A single mutual exclusive pair guarantees \nthe disjointness of ranges. We applied the.rst ruletoprove that StillUnique<X> contains unique method \ndeclarations. The following example demonstrates an application of the second rule: 1 public class UnionOfStatic<X,Y> \n{ 2 <A*>[m] for( static void m (A) : X.methods; nestedCond ) 3 public static void m(A args) { X.m(args); \n} 4 5 <B*>[n] for( static void n (B) : Y.methods ; 6 no static void n (int, B) : X.methods ) 7 public \nstatic int n(int count, B args) { 8 for (int i = 0; i < count; i++) Y.n(args); 9 return count; 10 } 11 \n} The two method declarations on lines 3 and 7 have signatures that can be uni.ed with the mapping { \nAm.n}.Ap\u00ad .{int,B}, mplying this substitution to the primary pattern on line 2 yields static void n(int,B) \n: X.methods . Having a method in the range of this pattern directly contradicts the condition of the \nnega\u00adtive nested pattern on line 6, which states there should be no meth\u00adods in the range of static void \nn(int,B) : X.methods . Thus, the two method declarations are unique for all X and Y.  4.2.3 Generalizations \nand Boundary Conditions We have so far neglected to state the rules for when one of the names used for \nreference or declaration is a constant name. The range of reference and declaration with such a name \ncontains a single element. Thus, it can always be subsumed by a range with a variable name, but it can \nnever be disjoint from a range with a variable name. We have also glossed over some details in the uni.cation. \nIn addition to unifying the pattern variables, there needs to be an additional check on type bounds. \nFor example, a pattern vari\u00adable A extends Number cannot be uni.ed with variable B extends java.io.File, \nbecause they can never match the same types there is no type that is a subtype of both Number and java.io.File. \nThis detail is rigorously de.ned in the rules presented in Section 5.   5. Formalization We formalize \nMorphJ s type system with a simpli.ed formalism, FMJ, based on FGJ [15]. Due to space limitations, we \npresent only the type rules most relevant to checking declarations and expressions enclosed by nested \npatterns. Interested readers may consult our technical report [12] for the full text of type rules and \nsoundness proofs. 5.1 Syntax The syntax of FMJ is presented in Figure 3. We adopt many of the notational \nconventions of FGJ: C,D denote constant class names; X,Y,Z denote type variables; N,P,Q,R denote non-variable \ntypes; S,T,U,V,W denote types; f denotes .eld names; m denotes non\u00advariable method names; x,y denote \nargument names. Notations new to FMJ are: . denotes a variable method name; n denotes either variable \nor non-variable names; o denotes a nested pattern condition operator (either + or -)for thekeywords some \nor no, respectively. T ::= X|N N ::= C<T> CL ::= class C<X<N>< N {T f;M} | class C<X<N>< {T f; M ::= \nTm (T x) {.e;} +|\u00ade ::= x | e.f | e. n(e) | new C<T>(e) n ::= m| . Figure 3. Syntax We use the shorthand \nT for a sequence of types T0,T1,...,Tn, and x for a sequence of unique variables x0,x1,...,xn.We use \n to denote an empty sequence. We use : for sequence concatenation, e.g. S:T is a sequence that begins \nwith S, followed by T.We use . to mean is a member of a sequence (in addition to set member\u00adship). We \nuse . . . for values of no particular signi.cance to a rule. < and . are shorthands for the keywords \nextends and return,re\u00adspectively. Note that all classes must declare a superclass, which can be Object. \nFMJ formalizes some core Mystique features that are represen\u00adtative of our approach. One simpli.cation \nis that we allow only one nested pattern per re.ective block. This does not change the essence of our \ntype system, since we can emulate multiple nested patterns using one nested pattern that re.ects over \nan intermedi\u00adate type, de.ned itself using re.ective declarations. (I.e., we can simulate i nested patterns \nwith i - 1 intermediate types with one nested pattern each.) Another simpli.cation is that we do not \nal\u00adlow a nested pattern to use any pattern type or name variables not bound by its primary pattern. We \nalso do not formalize re.ecting over a statically known type, or using a constant name in re.ective patterns. \nThese are decidedly less interesting cases from a typing perspective. The zero or more length type vectors \nT* are also not formalized. These type vectors are a mere matching convenience. Thus, safety issues regarding \ntheir use are covered by non-vector types. We do not formalize re.ectively declared .elds their type\u00adchecking \nis a strict adaptation of the techniques for checking meth\u00adods. Lastly, static name pre.xes, casting \nexpressions and polymor\u00adphic methods are not formalized. FGJ does not support method overloading, and \nFMJ inherits this restriction. Thus, a method name alone uniquely identi.es a method de.nition. Since \nwe allow no fresh name variables in nested patterns, there can be only one name variable in a re.ective \nblock. We use . for this name variable, and a re.ective de.nition must also use this same name variable. \nThis results in a small simpli.cation over the informal rules in Section 4 but leaves their essence intact. \nA program in FMJisan (e, CT) pair, where e is an FMJ expression, and CT is the class table. We place \nsome conditions on CT: every class declaration class C... has an entry in CT; Object is not in CT. The \nsubtyping relation derived from CT must be acyclic, and the sequence of ancestors of every instantiation \ntype is .nite. (The last two properties can be checked with the algorithm of [1] in the presence of mixins.) \n  5.2 Typing Judgments There are three environments used in our typing judgments: .: Type environment. \nMaps type variables to their upper bounds.  G: Variable environment. Maps variables (e.g., x) to their \ntypes.  .: Re.ective iteration environment. . has the form (Rp ,oRn ), where Rp is the primary pattern, \nand oRn the nested pattern. o can be + or -.   Rp has the form (T1, <Y<P>U.U0). T1 is the type over \nwhose methods Rp iterates. We call it the re.ective type of RpY are pattern type variables, bounded by \nP,and U.U0 . the method pattern.  Rn has a similar form: (T2, V.V0). However, note the lack of pattern \ntype variables, due to the (formalism-only) simpli.cation that the nested pattern not use pattern type \nvariables not already bound in the primary pattern. There is no nesting of re.ective loops. Thus, . contains \nat most one (Rp ,oRn ) tuple. We use the mample, .=Xm .C<T> means that .(X)=C<T>. Every type variable \nmust be bounded by a non-variable type. The function bound. (T) returns the upper bound of type T in \n.. bound . (N)=N,if N is not a type variable. And bound. (X)=bound. (S),where .(X)=S. In order to keep \nour type rules manageable, we make two sim\u00adplifying assumptions. To avoid burdening our rules with renam\u00adings, \nwe assume that pattern type variables have globally unique names (i.e., are distinct from pattern type \nvariables in other re.ec\u00adtive environments, as well as from non-pattern type variables). We also assume \nthat all pattern type variables introduced by a re.ective block are bound (i.e., used) in the corresponding \nprimary pattern. Checking this property is easy and purely syntactic. The core of our type system is \nin determining re.ective range subsumption and disjointness. Thus, we begin our discussion with a detailed \nexplanation of the rules for subsumption and disjointness.  5.2.1 Subsumption and Disjointness The range \nof a re.ective environment, (Rp ,oRn ), comprises meth\u00adods in the primary range Rp , that also satisfy \nthe nested condition oRn . The nested condition +Rn (or -Rn ) is satis.ed if there is at least one method \n(or no method, resp.) in the range of Rn . We call ranges of Rp and Rn single ranges. In this section, \nwe explain the rules for determining the following three relations: .;[W/Y]f.... . Range of . is subsumed \nby the range of . , under the assumptions of type environment . and the unifying type substitutions of \n[W/Y].  .;[W/Y]fR1.RR2. Single range R1 is subsumed by single range R2, under the assumptions of . and \nthe unifying type substitutions of [W/Y].  .fdisjoint(., .). The range of . and . are disjoint under \nthe assumptions of ..  Single range subsumption. In determining the subsumption be\u00adtween two re.ective \nenvironments, we must .rst see how subsump\u00adtion is determined between two single ranges. Rule SB-R (Fig\u00adure \n4) states that .rst, the re.ective type of the larger range, R2, should be a subtype of R1 s re.ective \ntype. Secondly, R2 s pattern should be more general than R1 s pattern. This means that a one\u00adway uni.cation \nexists from the pattern of R2 to the pattern of R1, where only the pattern type variables in R2 are considered \nvariables in the uni.cation process. [W/Y] are the substitutions that satisfy such one-way uni.cation. \nUni.cation is de.ned by two relations: .;[W/Y]funify(U0:U, V0:V). Rule UNI (Figure 6) describes a standard \nuni.cation condition with a twist: unifying substi\u00adtutions (for pattern type variables) must respect \nthe subtyp\u00ading bounds of the type variables. For example, the substitu\u00adtion [Y/Object],where .fY<:Number, \ndoes not unify Y and Object, because the bound of Y is tighter than Object.  .fT.:Z S (Figure 6) indicates \nthat type T is a valid substitution of S, i.e., it obeys the bound of S,using Z as pattern type variables. \n Re.ective (nested) range subsumption. SB-. (Figure 4)de\u00ad .nes the conditions for the range of re.ective \nenvironment .=(Rp ,oRn ) to be subsumed by the range of .=(Rp ,o Rn ). These conditions re.ect precisely \nthe informal rules of Section 4. First, regardless of nested patterns, the primary range of . should \nat least be subsumed by the primary range of . . Secondly, for every method in Rp that satis.es the nested \npattern oRn , the correspond\u00ad ing method in Rp should satisfy the nested pattern o Rn .There are a couple \nof ways to guarantee oRn implies o Rn .If +Rn is true, and Rn is subsumed by Rn ,then +Rn is also true. \nThis condition is expressed by .; fRn .R[W/Y]Rn ,if o=o =+. We apply the uni\u00adfying type substitutions \nfor the primary ranges to the nested range Rn : in order to properly compare the ranges of Rn and Rn \n, we need to restrict Rn to what it can be for the methods that are matched by both Rp and Rp . Note \nthat we are using an empty sequence of type substitutions ( ) in determining that Rn is subsumed by [W/Y]Rn \n. This is because nested patterns do not have pattern type variables of their own, and pattern type variables \nfrom the primary pattern are treated as constants in the nested patterns. Similarly, if -Rn is true, \nand Rn subsumes Rn ,-Rn is also true. Re.ective range disjointness. Disjointness of re.ective ranges \nis de.ned by rules DS-.1and DS-.2. DS-.1 speci.es the condi\u00adtions for disjointness when . and . re.ect \nover types from the same subtyping hierarchy. In this case, . and . are disjoint if their primary ranges \nare disjoint. However, if the two primary ranges do have overlap, (i.e., .;[W/Z]funify(U0:U, U0:U ):a \ntwo-way uni.\u00adcation exists between the primary ranges) it is still possible for .        Figure \n4. Range subsumption and disjointness rules. Method type lookup: .=(Rp ,oRn ) Rp =(X, <Y<P>U.U0) .=(Rp \n,+Rn ) Rn =(X, U.U0)  .; . fmtype(., X)=U.U0 (MT-VAR-R1) .; . fmtype(., X)=U.U0 (MT-VAR-R2) .=(Rp ,oRn \n) Rp =(T, <Y<P>V.V0) .;. fmtype(., bound. (X))=U.U0  .; . fmtype(., X)=U.U0 (MT-VAR-S) CT(C)=class \nC<X<N><T {... M} <Y<P>for(Mp ;oMf )S0 . (S x) {.e;}. M Mp =U0 . (U):Xi.methods Mf =V0 . (V):Xj .methods \nRp =(Ti, [T/X](<Y<P>U.U0)) Rn =(Tj , [T/X](V.V0)) .d =(Rp ,oRn ) .;[W/Y]f.C..d    .; . fmtype(., C<T>)=[T/X][W/Y](S.S0) \n(MT-CLASS-R) for all CT(C)=class C<X<N><T {... M}<Y<P>for(Mp ;oMf )S0 . (S x) {.e;}. M Mp =U0 . (U):Xi.methods \nMf =V0 . (V):Xj .methods Rp =(Ti, [T/X](<Y<P>U.U0)) Rn =(Ti, [T/X](V.V0)) .d =(Rp ,oRn ) implies .fdisjoint(., \n.d)  (MT-SUPER-R) Figure 5. Method type lookup. and . to be disjoint if we can establish that for the \nmethods that fall into the overlap, the nested patterns cannot be satis.ed simul\u00adtaneously. There are \ntwo ways to establish the exclusivity of two nested patterns. First, if +Rn is true, and Rn is subsumed \nby Rn , then -Rn cannot possibly by true. Similarly, if +Rn is true, and Rn is subsumed by Rn ,then -Rn \ncannot be true. DS-.2 speci.es a different condition for disjointness: if the primary range of ., Rp \n, can be subsumed by the nested range of . , Rn , and the nested pattern is negative (i.e., -Rn ), then \nit is guaranteed that . and . have disjoint names. The reason is that any method matched by the primary \nrange Rp is guaranteed to not satisfy the nested pattern -Rn , thus the two nested ranges are disjoint. \nSimilarly, if Rp is subsumed by Rn ,and -Rn is the nested pattern condition, disjointness is also established. \nThese rules re.ect very closely the informal rules of Section 4 modulo the small differences in the formalism \nmentioned in Sec\u00adtion 5.1: we do not need to distinguish between declarations and primary patterns in \nthe formalism, as the uniqueness of entities in the primary pattern implies (through name uniqueness, \nsince there is no overloading) the uniqueness of declared entities.  5.2.2 Valid Method Invocation The \nrest of the typing rules add machinery to standard FGJ type checking to express checks using range subsumption \nand disjoint\u00adness. For instance, method invocation rules rely on method lookup rules, mtype, to determine \nthe correct method type. We have shown in Figure 5 the mtype rules pertaining to looking up methods ref\u00adered \nto using name variables. Please consult our technical report for the full set of rules. MT-VAR-R1 and \nMT-VAR-R2 say that the type of method with avariablename . in a type X,where X is either the re.ective \ntype for the primary pattern or the re.ective type of a positive nested pattern, is exactly the type \nspeci.ed by the primary (or nested, respectively) pattern. Otherwise, if X is a type variable, then we \nmust look for the method type in its bound (MT-VAR-S). Note that in the formalism, since all variables \nare bound in the primary pattern, we can always invoke a method guaranteed to exist by a positive nested \npattern. MT-CLASS-R lists conditions for retrieving the type of . in reference, which is the current \nre.ective environment, is subsumed by the declaration re.ective environment, the type of . is the substitutions \nfor unifying the declaration range and the reference range, [W/Y]. MT-SUPER-R simply states that when \nthe reference re.ective environment is disjoint from every declaration re.ective environment in C<T>, \nwe must look to the superclass for the type of ..  5.3 Soundness: We prove the soundness of FMJ by proving \nSubject Reduction and Progress. Theorem 1 [Subject Reduction]: If .; .; G fe.T and e . e , then .; .; \nG fe .S and . fS<:T for some S. Theorem 2 [Progress]: Let e be a well-typed expression. 1. If e has new \nC<T>(e).f as a subexpression, then \u00d8f.elds(C<T>)=U f,and f=fi.2. If e has new C<T>(e).m(d) as a subexpression, \nthen mbody(m, Theorem 3 [Type Soundness]: If \u00d8; \u00d8; \u00d8fe.T and e-. * e ,then e is a value v such that \u00d8; \n\u00d8; \u00d8fv.S and \u00d8fS<:T for some type S.     Type Uni.cation: .;[U/Z]funify(T, S) Pattern matching rules: \n.fT.:Z T Zi (UNI) (PM-REFL) CT (C)=class C<X<N><T {...} (PM-CL) [U/Z]T=[U/Z]SforallZi.Z,.fUi.:Z.fT.:ZS.fC<T>.:ZC<S> \n (PM-CL-S) Z.ZT..Z bound . (T)=C<T> .fC<T>.:Z [C<T>/Z]bound . (Z) .fT.:Z Z (PM-VAR) Zi.ZZj .Z  j . \nf [Zi/Zj ]bound . (Zj ).:Z Zi or . f [Zj /Zi]bound . (Zi).:Z Zj .fZi.:Z Zj (PM-PVARS) Figure 6. Uni.cation \nand pattern-matching rules  5.4 Decidability To establish the decidability of our type system, we enforce \nlimita\u00adtions on possible circularities in either subtyping or static iteration cross-type references. \nFor the former, we inherit a standard tech\u00adnique from Allen et al. [1]. Applying the same restrictions \n(i.e., a declared supertype cannot be a type with a mixin superclass itself), we can guarantee that there \nis no cyclic inheritance in FMJ. An\u00adother source for non-termination in FMJ is in circularly dependent \nmethod de.nitions. For example, 1 class C<X extends D<X>> { 2 <R>[m]for(R m() : X.methods) ... 3 } 4 \nclass D<X> extends C<D<X>> { ... } The methods of C<X> are circularly de.ned: they re.ect over the methods \nof X, which include the methods of D<X>, which, in turn, include the methods of C<D<X>>! This type of \nde.nition would cause in.nite recursion in the derivation of mtype. We detect such circularity by constructing \na chain of re.ective reachability. The chain of reachability for a type T is essentially all the types \nmtype(n, T) could recursively call upon. For example, the chain of reachability for the above C<X> is \nC<X>, X, D<X>, C<D<X>>, ... We stop the chain construction as soon as we see a re-occurrence of any type \nalready in the chain, in any form of instantiation. We reject classes with such circular dependency. \nSince there is a .nite number of classes, the chain must either see a reoccurrence of some class, or \nbe .nitely sized. The length of the chain serves as a measure function for each call of mtype. The .nite \nsize of the chain means the measure function cannot decrease in.nitely, thus proving termination. A more \nsophisticated protocol would be possible, to make the check less conservative, but we have yet to encounter \na realistic use that needs it.  6. Related Work As discussed earlier, MorphJ s closest relatives are \nMJ [14]and CTR [7]. CTR is an extension to C# that pioneered the use of pat\u00ad terns for re.ective iteration \nand was one of the .rst systems to aim for modular type safety. Nevertheless, its modular guarantees \nconcern only validity of references and not the absence of declara\u00adtion con.icts. Additionally, CTR does \nnot allow matching multiple method argument types, and there is currently no formal type sys\u00adtem or soundness \nguarantees. A unique aspect of CTR (compared to MJ or MorphJ) is that it transforms classes in-place, \nwhich enables some interesting applications. MJ, on the other hand, introduced two main elements: static \nchecking for disjointness of re.ective declarations, and the integration of static re.ection as an extension \nof standard generics. MJ has a formal type system, with a sound\u00adness proof but with no demonstration \nof its decidability. MorphJ improves over both CTR and MJ by adding more expressiveness through nested \npatterns, while keeping or strengthening the typing guarantees, and by validating the promise of the \noverall approach with larger-scale applications. Static re.ection mechanisms such as Genoupe [6]and SafeGen \n [13] attempted to allow declaration using re.ection. Yet none of these mechanisms offer full modular \ntype-checking guarantees. For instance, the Genoupe [6] approach has been shown unsafe, as its reasoning \ndepends on properties that can change at runtime; SafeGen [13] has no soundness proof and relies on the \ncapabilities of an automatic theorem prover an unpredictable and unfriendly process for a programmer. \nAdditionally, these mechanisms use complex syntax for retrieving re.ective members, whereas MorphJ utilizes \npatterns very similar to method and .eld signatures. An extension of traits [21] offers pattern-based \nre.ection by allowing a trait to use name variables for declarations. However, [21] does not offer static \niteration over the members of classes a name-generic trait must be mixed in once for each name instance. \nThe main capabilities of MorphJ can typically be emulated only with lower-level mechanisms, such as re.ection, \nmeta-object protocols [17], aspect-oriented programming [18], or pattern-based program generation and \ntransformation [3, 4, 24]. The goal of our work is to promote these abilities to high-level language \nfeatures, with full modular type-safety. None of the above mechanisms offer such safety guarantees: a \ntransform, aspect, or meta-class cannot be type-checked independently from the rest of the program, in \na way that guarantees it is well-typed for all its possible uses. An interesting special case of program \ngeneration is staging lan\u00adguages such as MetaML [23]and MetaOCaml[5]. These languages offer modular type \nsafety: the generated code is guaranteed correct for any input, if the generator type-checks. Nevertheless, \nMetaML and MetaOCaml do not allow generating identi.ers (e.g., names of variables) or types that are \nnot constant. Neither do they allow generation of code by re.ecting over a program s structure. Gen\u00aderally, \nstaging languages target program specialization rather than full program generation: the program must \nremain valid even when staging annotations are removed. It is interesting that even recent meta-programming \ntools, such as Template Haskell [22]are ex\u00ad plicitly not modularly type safe its authors acknowledge \nthat they sacri.ce the MetaML guarantees for expressiveness. There has been a line of work focused on \nproviding statically type-safe generic traversal of data structures [19, 16]. For instance, the scrap \nyour boilerplate [19] line of work offers extensions of Haskell that allow code to abstract over the \nexact structures of the data types it acts on, and to have the appropriate functions invoked when their \nexpected data types are encountered during traversal. Abstracting over the structures of data types in \nfunc\u00adtional languages is similar to abstracting over the .elds and meth\u00adods of classes in object-oriented \nlanguages. [25] offers such generic traversal capabilities for Java. However, whereas [19, 16, 25]fo\u00ad \ncus on offering structurally-generic traversal, MorphJ focuses on structurally-generic declarations. \nNeither of [19, 16, 25] allow more functions to be declared using the names or types retrieved from a \nnon-speci.c data type. Thus, these techniques fall short of MorphJ (and static re.ection work in general \n[14, 6, 7, 13]) in this respect. On the other hand, MorphJ is not well-suited for writ\u00ading generic traversal \ncode. Traversing data structures and invoking methods on objects encountered is largely based on the \ndynamic types of these objects. MorphJ s re.ective declarations are based purely on the static types \nof .elds and methods. 7. Conclusions We believe that MorphJ and the general approach of class morph\u00ading \nrepresent a signi.cant trend in the evolution of programming languages. Most major advances in programming \nlanguages are modularity or re-usability enhancements. The .rst step was taken with procedural abstraction \nin the 50s and 60s, which culminated in structured programming languages. Procedural abstraction cap\u00adtured \nalgorithmic logic in a form that could be multiply reused both in the same program and across programs, \nover different data ob\u00adjects. The next major abstraction step was arguably type abstraction or polymorphism, \nwhich allowed the same abstract logic to be ap\u00adplied to multiple types of data, although the low-level \ncode for each type would end up being substantially different. The next big step in language evolution \ncan perhaps be called structural abstraction. Structural abstraction is abstraction over the structure \nof other pro\u00adgram elements. Mechanisms like CTR, MorphJ, or the scrap your boilerplate approach are instances \nof structural abstraction: they allow safe static re.ection over members of a type. We believe that the \ninclusion of such constructs in mainstream languages will be a topic of major importance for decades \nto come and that this paper represents a big step forward in this direction. Availability and Acknowledgments \nMorphJ is available at http://code.google.com/p/morphing/ This work was funded by the NSF under grant \nCCR-0735267.  References [1] E. Allen, J. Bannet, and R. Cartwright. A .rst-class approach to genericity. \nIn Proc. of Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA), 2003. [2] Apache \nSoftware Foundation. Byte-code engineering library. http://jakarta.apache.org/bcel/manual.html . Accessed \nMar. 08. [3] J. Bachrach and K. Playford. The Java syntactic extender (JSE). In Proc. of Object-Oriented \nProgramming, Systems, Languages, and Applications (OOPSLA), 2001. [4] J. Baker and W. C. Hsieh. Maya: \nmultiple-dispatch syntax extension in Java. In Proc. of Programming Language Design and Implementation \n(PLDI), 2002. [5] C. Calcagno, W. Taha, L. Huang, and X. Leroy. Implementing multi-stage languages using \nASTs, gensym, and re.ection. In Proc. of Generative Programming and Component Engineering (GPCE), 2003. \n[6] D. Draheim, C. Lutteroth, and G. Weber. A type system for re.ective program generators. In Proc. \nof Generative Programming and Component Engineering (GPCE), 2005. [7] M. F\u00a8ahndrich, M. Carbin, and J. \nR. Larus. Re.ective program generation with patterns. In Proc. of Generative Programming and Component \nEngineering (GPCE), 2006. [8] E. Gamma, R. Helm, and R. Johnson. Design Patterns. Elements of Reusable \nObject-Oriented Software. Addison-Wesley Professional Computing Series. Addison-Wesley, 1995. [9] M. \nHerlihy. SXM: C# Software Transactional Memory. http://www.cs.brown.edu/ mph/SXM/README.doc . Accessed \nMar. 08. [10] M. Herlihy, V. Luchangco, and M. Moir. A .exible framework for implementing software transactional \nmemory. In OOPSLA 06: Proceedings of the 21st annual ACM SIGPLAN conference on Object\u00adoriented programming \nsystems, languages, and applications, 2006. [11] S. S. Huang and Y. Smaragdakis. Easy language extension \nwith Meta-AspectJ. In Proc. of International Conference on Software Engineering (ICSE), 2006. [12] S. \nS. Huang and Y. Smaragdakis. Morphing with nested patterns: Making generic classes highly con.gurable. \nTechnical report, 2007. http://www.cc.gatech.edu/~ssh/mjnested-tr.pdf. [13] S. S. Huang, D. Zook, and \nY. Smaragdakis. Statically safe program generation with SafeGen. In Proc. of Generative Programming and \nComponent Engineering (GPCE), 2005. [14] S. S. Huang, D. Zook, and Y. Smaragdakis. Morphing: Safely shaping \na class in the image of others. In Proc. of the European Conference on Object-Oriented Programming (ECOOP), \n2007. [15] A. Igarashi, B. C. Pierce, and P. Wadler. Featherweight java: a minimal core calculus for \njava and gj. ACM Trans. Program. Lang. Syst., 23(3):396 450, 2001. [16] P. Jansson and J. Jeuring. PolyP \n-a polytypic programming language extension. In POPL 97: Proceedings of the 24th ACM SIGPLAN-SIGACT symposium \non Principles of programming languages, 1997. [17] G. Kiczales, J. des Rivieres, and D. G. Bobrow. The \nArt of the Metaobject Protocol. MIT Press, 1991. [18] G. Kiczales, J. Lamping, A. Menhdhekar, C. Maeda, \nC. Lopes, J.-M. Loingtier, and J. Irwin. Aspect-oriented programming. In Proc. of European Conf. on Object-Oriented \nProgramming (ECOOP), 1997. [19] R. L\u00a8ammel and S. P. Jones. Scrap your boilerplate: a practical design \npattern for generic programming. In TLDI 03: Proceedings of the 2003 ACM SIGPLAN international workshop \non Types in languages design and implementation, 2003. [20] M. Mohnen. Interfaces with default implementations \nin Java. In Proc. of Principles and Practice of Programming, 2002. [21] J. Reppy and A. Turon. Metaprogramming \nwith traits. In ECOOP 07: Proceedings of the European Conference on Object-Oriented Programming, 2007. \n[22] T. Sheard and S. P. Jones. Template meta-programming for Haskell. In Proc. of the ACM SIGPLAN workshop \non Haskell, 2002. [23] W. Taha and T. Sheard. Multi-stage programming with explicit annotations. In Proc. \nof Partial Evaluation and semantics-based Program Manipulation (PEPM), 1997. [24] E. Visser. Program \ntransformation with Stratego/XT: Rules, strategies, tools, and systems in Stratego/XT 0.9. In Domain-Speci.c \nProgram Generation. Springer-Verlag, 2004. LNCS 3016. [25] S. Weirich and L. Huang. A design for type-directed \nJava. In Workshop on Object-Oriented Developments (WOOD), 2004. \n\t\t\t", "proc_id": "1375581", "abstract": "<p>Recently, language extensions have been proposed for Java and C# to support <i>pattern-based reflective declaration</i>. These extensions introduce a disciplined form of meta-programming and aspect-oriented programming to mainstream languages: They allow members of a class (i.e., fields and methods) to be declared by statically iterating over and pattern-matching on members of other classes. Such techniques, however, have been unable to safely express simple, but common, idioms such as declaring getter and setter methods for fields.</p> <p>In this paper, we present a mechanism that addresses the lack of expressiveness in past work without sacrificing safety. Our technique is based on the idea of nested patterns that elaborate the outer-most pattern with blocking or enabling conditions. We implemented this mechanism in a language, MorphJ. We demonstrate the expressiveness of MorphJ with real-world applications. In particular, the MorphJ reimplementation of DSTM2, a software transactional memory library, reduces 1,107 lines of Java reflection and bytecode engineering library calls to just 374 lines of MorphJ code. At the same time, the MorphJ solution is both high level and safer, as MorphJ can separately type check generic classes and catch errors early. We present and formalize the MorphJ type system, and offer a type-checking algorithm.</p>", "authors": [{"name": "Shan Shan Huang", "author_profile_id": "81100080995", "affiliation": "Georgia Institute of Technology, Atlanta, GA, USA", "person_id": "P1022748", "email_address": "", "orcid_id": ""}, {"name": "Yannis Smaragdakis", "author_profile_id": "81100614708", "affiliation": "University of Oregon, Eugene, OR, USA", "person_id": "P1022749", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1375581.1375592", "year": "2008", "article_id": "1375592", "conference": "PLDI", "title": "Expressive and safe static reflection with MorphJ", "url": "http://dl.acm.org/citation.cfm?id=1375592"}