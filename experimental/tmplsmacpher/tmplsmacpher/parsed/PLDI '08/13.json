{"article_publication_date": "06-07-2008", "fulltext": "\n SharC: Checking Data Sharing Strategies for Multithreaded C Zachary Anderson David Gay University of \nCalifornia, Berkeley {zra, brewer}@cs.berkeley.edu Abstract Unintended or unmediated data sharing is \na frequent cause of in\u00adsidious bugs in multithreaded programs. We present a tool called SharC (short \nfor Sharing Checker) that allows a user to write lightweight annotations to declare how they believe \nobjects are be\u00ading shared between threads in their program. SharC uses a com\u00adbination of static and dynamic \nanalyses to check that the program conforms to this speci.cation. SharC allows any type to have one of \n.ve sharing modes private to the current thread, read-only, shared under the control of a speci.ed lock, \nintentionally racy, or checked dynamically. The dynamic mode uses run-time checking to verify that objects \nare either read-only, or only accessed by one thread. This allows us to check programs that would be \ndi.cult to check with a purely static system. If the user does not give a type an explicit annotation, \nthen SharC uses a static type-quali.er analysis to infer that it is either private or should be checked \ndynamically. SharC allows objects to move between di.erent sharing modes at runtime by using reference \ncounting to check that there are no other references to the objects when they change mode. SharC s baseline \ndynamic analysis can check any C program, but is slow, and will generate false warnings about intentional \ndata sharing. As the user adds more annotations, false warnings are reduced, and performance improves. \nWe have found in practice that very few annotations are needed to describe all sharing and give reasonable \nperformance. We ran SharC on 6 legacy C programs, summing to over 600k lines of code, and found that \na total of only 60 simple annotations were needed to remove all false positives and to reduce performance \noverhead to only 2 14%. Categories and Subject Descriptors D.3.3 [Programming Lan\u00adguages]: Language Constructs \nand Features Concurrent program\u00adming structures General Terms Languages  1. Introduction The ongoing \nmigration of mainstream processors to many cores ac\u00adcelerates the need for programmers to write concurrent \nprograms. Unfortunately, programmers generally .nd concurrent programs much more di.cult to write than \nsequential programs. One signif\u00adicant reason for this is that unintended data sharing among threads Permission \nto make digital or hard copies of all or part of this work for personal or classroom use is granted without \nfee provided that copies are not made or distributed for pro.t or commercial advantage and that copies \nbear this notice and the full citation on the .rst page. To copy otherwise, to republish, to post on \nservers or to redistribute to lists, requires prior speci.c permission and/or a fee. PLDI 08, June 7 \n13, 2008, Tucson, Arizona, USA. Copyright &#38;#169;c2008 ACM 978-1-59593-860-2/08/06. . . $5.00 Rob \nEnnals Eric Brewer Intel Research, Berkeley {david.e.gay,robert.ennals}@intel.com can make program behavior \nhard to understand or predict. By un\u00adintended sharing we mean data shared among threads in ways that \nthe programmer does not expect and that are not part of the de\u00adsign of the program. One key symptom of \nunintended sharing is a data race when two or more threads access the same memory location without synchronization, \nand at least one access is a write. However, rather than looking only for data races, we consider most \ndata sharing, even if mediated by locks or signaling, to be an error unless it has been explicitly declared \nby the programmer. We .nd in large real programs that requiring sharing to be explicitly declared is \nnot unreasonable. Unintended or unmediated sharing is often considered a major source of hard-to-.nd \nbugs in low-level multithreaded programs. Searching for vulnerabilities caused by race conditions in \nthe US-CERT advisory archive yields hundreds of results [24]. The unin\u00adtended sharing that causes data \nraces is di.cult to diagnose because its occurrence and its e.ects are highly dependent on the scheduler. \nThis fact may frustrate developers using traditional tools such as a debugger or print statements, which \nmay alter the schedule. Even when unintended sharing is benign, it may indicate places the pro\u00adgrammer \nmay need to investigate more carefully. In this paper, we present SharC, a tool that allows a C program\u00admer \nto declare the data sharing strategy that a program should fol\u00adlow, and then uses static and dynamic \nanalysis to check that the program conforms to this strategy. Dynamic analysis allows SharC to check \nany program, including programs that would not be easily checkable with purely static analysis. SharC \ns static analysis im\u00adproves performance by avoiding dynamic checks where unintended sharing is impossible. \nWhen using SharC, a programmer uses type quali.ers to declare the sharing mode of objects. Sharing modes \ncan declare that an ob\u00adject is thread-private, read-only, protected by a lock, intentionally accessed \nin a racy way, or checked dynamically. The dynamic shar\u00ading mode checks at run time that the object is \neither read-only, or only accessed by one thread. This allows SharC to check programs that would be di.cult \nto check with a purely static system. The annotation burden is low because SharC makes reasonable and \npre\u00addictable guesses at unannotated types. Further, SharC allows the programmer to change an object s \nsharing mode using a cast, and uses reference counting to check the safety of such casts dynami\u00adcally \n(Section 2). We show that SharC s mixed static/dynamic checking approach is sound (i.e., detects all \ndata races and checks all sharing mode changes), for a simple C-like language with thread-private and \ndynamic sharing modes (Section 3). We then describe SharC s implementation, in particular how it selects \nsharing modes for unannotated types and implements its runtime checks (Section 4). SharC can be applied \nto programs incrementally. As more an\u00adnotations are added, the false positive rate drops and performance \nimproves. We ran SharC on a set of real legacy C programs, which sum to over 600k lines of code. Two \nof the benchmarks are over 100k lines of code, and some contain kernels that have been .nely tuned for \nperformance. Further, we chose benchmarks that use threads in a variety of ways, from threads for serving \nclients, to hid\u00ading I/O and network latency, to improving performance. We found that for this set of \nprograms, the number of annotations required to eliminate false positives and achieve reasonable performance \n(i.e., 9% runtime and 26% memory overheads) is small (Section 5). These results provide good evidence \nfor the generality and practi\u00adcality of our approach. In summary, this paper makes the following novel \ncontributions: We specify a lightweight type annotation system that uses a mixture of statically and \ndynamically checked properties to describe many of the data sharing conventions used in existing multithreaded \nC programs. We show that in practice, these annotations are not overly burdensome. Indeed we believe \nthat they are su.ciently simple and clear that they could be viewed as compiler-checked documentation. \n We show that dynamic reference counting makes it possible to safely cast an object between di.erent \nsharing modes.  We describe a new dynamic race detection algorithm that uses and enforces the sharing \nmode annotations supplied by the programmer, and those discovered by a .ow-insensitive type quali.er \nanalysis.  We describe our implementation, and demonstrate its practical\u00adity by applying it to several \nlarge, real-world, legacy1 Cpro\u00adgrams. On these programs we observe lower performance over\u00adheads than \nexisting dynamic race detection tools. We believe these overheads are low enough that our analysis could \ncon\u00adceivably be left enabled in production systems.  Our implementation also includes an adaptation \nof the fast con\u00adcurrent reference counting algorithm found in the work of Levanoni and Petrank [16]. \nWe describe our modi.cations (Section 4.3), as they may also be useful in memory management schemes for \nC that rely on reference counting and wish to handle multithreaded programs e.ciently. 2. SharC s API \nSharC uses a mixture of static and dynamic checking to provide an API that is simple to understand, and \nyet is complete enough that large real programs can be checked with reasonable runtime e.ciency. SharC \ns .rst key concept is a set of sharing mode anno\u00adtations that describe the rules that threads must follow \nwhen access\u00ading a particular object. The programmer can annotate types with the following sharing mode \nquali.ers: private: Indicates that an object is owned by one thread and only accessible by this thread \n(enforced statically).  readonly: Indicates that an object is readable by any thread but not writeable, \nwith one exception: a readonly .eld in a private structure is writeable (enforced statically). This ex\u00adception \nmakes initialization of readonly structure .elds prac\u00adtical, while maintaining the read-only property \nwhen the struc\u00adture is accessible from several threads. Unlike C s existing const quali.er, readonly \nmay be safely cast to another shar\u00ading mode that allows writes, as described below.  locked(lock): Indicates \nthat an object is protected by a lock and only accessible by whatever thread currently holds the lock \n(enforced by a runtime check). Here, lock is an expression or structure .eld for the address of a lock, \nwhich must be veri.ably  1 By legacy code we mean any existing (including multithreaded) C code. We \ncontrast SharC with languages intended for new code (e.g. Cilk [4], and Cyclone [14]). constant (uses \nonly unmodi.ed locals or readonly values) for type-safety reasons. racy: A mode for objects on which \nthere are benign races (no enforcement required).  dynamic: Indicates that SharC is to enforce at runtime \nthat the object is either read-only, or only accessed by a single thread.  SharC selects a sharing mode \nfor each unannotated type, using a set of simple rules and a whole-program sharing analysis that infers \nwhich objects may be accessed by more than one thread. The rules were selected based on our experience \nusing SharC, and help keep the annotation burden low in practice. These rules include a limited form \nof quali.er polymorphism for structures: unquali.ed .elds inherit the quali.er of their containing structure \ninstance. The result of the sharing analysis is used to add dynamic and private quali.ers. Unannotated \ntypes that refer to objects accessible by more than one thread should be checked for races, so they get \nthe dynamic quali.er. All remaining unannotated types are given the private quali.er. The quali.ers inferred \nby this analysis are not trusted: they are statically checked for well-formedness, and by our dynamic \nanalysis. The rules and analysis are described in detail in Section 4.1. The dynamic sharing mode makes \nSharC practical for large, real-world programs by avoiding the need for complex polymor\u00adphic types. However, \nin real programs, objects often go through a sequence of sharing modes. For example, in a producer-consumer \nrelationship, an object is .rst private to the producer, then protected by a lock, then private to the \nconsumer. Thus, SharC s second key feature is a sharing cast that allows a program to change an object \ns sharing mode: int readonly *y; ... x = SCAST(int private *, y); SharC enforces the soundness of these \ncasts by nulling-out the pointer being cast, and by using reference-counting to ensure that the pointer \nbeing cast is the only reference to the underlying object. If we have the only reference to some object, \nthen we can, e.g., safely cast it to or from private, since no thread will be able to see the object \nwith the old sharing mode. SharC can infer where sharing casts are needed to make a pro\u00adgram type-check. \nHowever, since nulling-out a cast s source may break the program, SharC does not insert these casts automatically, \nbut instead suggests where they should be added. It is then up to the programmer to add the suggested \ncasts to the program if they are safe, or make alternative changes if they are not. Additionally, SharC \nwill emit a warning if a pointer is de.nitely live after being nulled-out for a cast. 2.1 An Example \nConsider a multithreaded program in which a bu.er is read in from a .le, passed among threads in a pipeline \nfor various stages of processing, and then output to disk, screen, or other medium. This is a common \narchitecture for multimedia software, for example the GStreamer framework [11]. The core function implementing \nsuch a pipeline is shown in Figure 1. The stage structures are arranged in a list, and there is a thread \nfor each stage. Each thread waits on a condition variable for sdata (line 16). When data arrives, the \npointer is copied into a local variable (line 17), the original pointer is nulled (line 18), and the \nprevious stage is signaled (line 19). This indicates that the current stage has taken ownership of the \ndata, and that the previous stage is free to use the sdata pointer of the current stage for the next \nchunk of data. Having claimed the data, the current stage processes it somehow (line 21), waits for the \nnext stage to be ready to receive it (line 25), copies the pointer into the next stage (line 27), and \nthen 1 // pipeline test.c 2 typedef struct stage { 3 struct stage *next; 4 cond *cv; 5 mutex *mut; 6 \nchar *locked(mut) sdata; 7 void (*fun)(char private *fdata); 8 } stage t; 9 10 void *thrFunc(void *d) \n{ 11 stage t *S = d, *nextS = S->next; 12 char *ldata; 13 while (notDone) { 14 mutexLock(S->mut); 15 \nwhile (S->sdata == NULL) 16 condWait(S->cv,S->mut); 17 ldata = SCAST(char private *, S->sdata); 18 S->sdata \n= NULL; 19 condSignal(S->cv); 20 mutexUnlock(S->mut); 21 S->fun(ldata); 22 if (nextS) { 23 mutexLock(nextS->mut); \n24 while (nextS->sdata) 25 condWait(nextS->cv,nextS->mut); 26 nextS->sdata = 27 SCAST(char locked(nextS->mut) \n*, ldata); 28 condSignal(nextS->cv); 29 mutexUnlock(nextS->mut); 30 } 31 } 32 return NULL; 33 } Figure \n1. A simple multithreaded pipelining scheme as might be used in multimedia software. Items in bold are \nthe additions for SharC. signals that the next stage may claim it (line 28). The process then repeats \nuntil all chunks have been processed. SharC will compile this code as is. However, since the program\u00admer \nhas not added annotations to tell SharC the desired sharing strategy, SharC will assume that all sharing \nit sees is an error, and will generate an error report. SharC reports two kinds of data shar\u00ading. First, \nit reports sharing of the sdata .eld of the stage struc\u00adtures. The following is an example of such a \nreport. read conflict(0x75324464): who(2) S->sdata @ pipeline test.c: 15 last(1) nextS->sdata @ pipeline \ntest.c: 27 This indicates that thread 2 tried to read from address 0x75324464 through the l-value S->sdata \non line 15 of the .le after thread 1 wrote to the address through l-value nextS->sdata on line 27. Without \nknowledge of the desired sharing strategy, SharC assumes that this sharing is an error. This error report \nwas generated by SharC s dynamic checker. SharC was not able to prove statically that the sdata .eld \nwas private, so it inferred the dynamic sharing mode for sdata,and monitored it at runtime for races \n(two threads have accessed the same location, with at least one access being a write). As a human reading \nthe code, it is clear that the programmer intended the sdata .eld to be shared between threads, and to \nbe protected by the mut lock. We can declare this policy to SharC by adding a locked annotation to line \n6. Now, rather than checking that sdata is not accessed by more than one thread, SharC will instead check \nthat the referenced lock is held whenever sdata is accessed. 1 // pipeline test.c 2 typedef struct stage(q) \n{ 3 struct stage pdynamic *q next; 4 cond racy *q cv; 5 mutex racy *readonly mut; 6 char locked(mut) \n*locked(mut) sdata; 7 void (*q fun)(char private *private fdata); 8 } stage t; 9 10 void dynamic*private \nthrFunc(void dynamic *private d){ 11 stage t dynamic *private S = d; 12 stage t dynamic *private nextS \n= S->next; 13 char private *private ldata; 14 ... 15 } Figure 2. The stage structure, with the annotations \ninferred by SharC shown un-bolded. The quali.er polymorphism in structures is shown through the use of \nthe quali.er variable q. SharC will also report sharing of memory pointed to by the sdata .eld. Here \nis an example: write conflict(0x75324544): who(2) *(fdata + i) @ pipeline test.c: 52 last(3) *(fdata \n+ i) @ pipeline test.c: 62 Lines 52 and 62 are not shown in the .gure, but are both in functions that \ncan be pointed to by the fun .eld of the stage structure. In these functions, fdata is equal to the ldata \npointer that was passed as the argument to fun. The error message indicates that thread 2 tried to write \nto address 0x75324544 through the l\u00advalue *(fdata+i) on line 52 after thread 3 had read from the same \naddress through the l-value *(fdata+i) on line 62. Here, SharC is not aware that ownership of the bu.er \nis being transferred between the threads, and so believes that the bu.er is being shared illegally. The \nuser can tell SharC what is going on by adding a private annotation to the fdata argument of fun on line \n7. This will cause SharC to infer that ldata is private rather than dynamic, but type checking will fail \nat lines 17 and 27 due to the assignment of a (char locked(mut)*) to and from (char private*). To .x \nthis, SharC suggests the addition of the sharing casts (SCAST(...)) shown in bold on lines 17 and 27. \nAs discussed above, these sharing casts will null-out the cast value (S->sdata or ldata) and check that \nthe reference count for the object is one. For line 17 this ensures the object referenced by S->sdata \nis not accessible by inconsistently quali.ed types (locked(...) and private). These two annotations and \ntwo casts are su.cient to describe this simple program s sharing strategy, and allow it to run without \nSharC reporting any errors. Figure 2 shows the sharing modes selected by SharC for the stage struct, \nand the .rst few lines of the thrFunc function. The next, cv and fun .elds inherit the structure s quali.er \nq.The internals of pthread s lock and condition variable types (mutex, cond) have data races by their \nvery nature, so they have the racy quali.er. The mut .eld must be readonly for type-safety reasons, as \nthe type of sdata depends on it. The object referenced by sdata has inherited its pointer s sharing mode. \nThe object referenced by next has not been annotated, so must be given the dynamic mode since the structure \ns quali.er can t be similarly inherited for referent types for soundness reasons. SharC s sharing analysis \ninfers that the object passed to thrFunc is accessible from several threads, so d, S and nextS must be \npointers to dynamic. At runtime for the annotated program, SharC will check that: 1. When the sdata .eld \nof a stage structure is accessed, the mut mutex of that structure is held. Core Type s ::= int |ref t \nSharing Mode m ::= dynamic |private Type t ::= m s|thread Program P ::= t x |f (){t1 x1 ...tn xn; s}|P; \nP L-expression t ::= x |*x |a Expression e ::= t|scastt x |n |null |newt Statement s ::= s1; s2 |spawn \nf () | t := e [when .1(t1),...,.n(tn)] | skip |done |fail Predicate . ::= chkread |chkwrite |oneref f,x \n. Identi.ers a,n . Integer constants Figure 3. The grammar for a simple concurrent language with global \nand local variables, and quali.ers for describing sharing. done, skip, fail and runtime addresses (a) \nare only used in the operational semantics. 2. When the non-private pointer S->sdata is cast to private \non line 17, no other references to that memory exist. 3. When the private pointer ldata is cast to a \nnon-private type on line 27, no other references to that memory exist. 4. There are no races on objects \ninferred to be in dynamic mode.   3. The Formal Model In this section we present a formal model for \nSharC. We reduce the set of sharing modes to just private and dynamic, omitting racy, locked,and readonly. \nWe also use a simpli.ed version of the C language. Our goal is to express the essence of SharC, without \nobscuring it with these additional features. The formalism is readily extendable to include locked, readonly,and \nracy. 3.1 Language Figure 3 shows the grammar for the language. A type (t) includes a private or dynamic \nsharing mode. Programs (P) consist of a list of declarations of thread de.nitions and global variables. \nThread de.nitions ( f ) have no arguments or results and declare local vari\u00adables. We assume that all \nidenti.ers are distinct. The thread body is a sequence of statements (s) that spawn threads and perform \nas\u00adsignments. Control .ow has no e.ect on our type system or runtime checks, so it is omitted from the \nlanguage. L-values (t) include global and local variables, and dereferences of local variables (this \nrestriction is enforced in the type system). Assignments can assign l-values, constants (n, null) and \nnewly allocated memory cells, and perform casts that change the sharing mode of a referenced cell (scast \nx). Note that casts implicitly null-out their source, to elimi\u00adnate the reference with the old type. \nRuntime checks (added during type checking) are represented by guards (when .1,...) on assign\u00adments. \nThe runtime checks consist of assertions that it is safe to access memory cells (chkread, chkwrite), \nand assertions that there is only one reference to a cell (oneref).  3.2 Static Semantics The static \ntype-checker (Figure 4) checks that programs are well\u00adtyped and inserts runtime checks for casts and \naccesses to objects with dynamic sharing mode. The rules for checking programs ensure that global declarations \nuse the dynamic sharing mode (GLOBAL) and that no type has a dynamic reference to a private type (REF \nCTOR). The thread type is used to identify threads in G and cannot appear in user-declared types. The \n.ve assignment rules (*-ASSIGN) check the types being assigned and rely on the R and W functions to compute \nruntime checks for accesses to objects in dynamic mode. In environment G program P compiles to P',which \nG fP .P' is identical to P except for added runtime checks. (global) fdynamic ref t G[x : t] fP .P' \nG ft x; P .t x; P' (thread) fti G[x1: ta,...,xn : tn] fs .s' G[ f : thread] fP .P' G ff (){t1 x1 ...tn \nxn; s}; P .f (){t1 x1 ...tn xn; s'}; P' ft Type thas no dynamic references to private types (ref ctor) \n(int ctor) fm's m = m'.m = private fm int fm ref (m's) G ft : t In environment G, tis a well-typed l-value \nwith type t. (name)(deref) G(x) = t G(x) = private ref t G fx : t G f*x : t In environment G statement \ns compiles to s',which G fs .s' is identical to s except for added runtime checks. (seq)(spawn) G fs1 \n.s'G fs2 .s' G( f ) = thread 12 G fs1; s2 .s1'; s' 2 G fspawn f () .spawn f () (constant-assign) G ft \n: m int G ft := n .t := n when W(t,m) (null-assign) G ft : m ref t G ft := null .t := null when W(t,m) \n(new-assign) G ft : m ref t G ft := newt .t := newt when W(t,m) (assign) G ft1: m1 s G ft2: m2 s G ft1:= \nt2 .t1:= t2 when W(t1,m1),R(t2,m2) (cast-assign) G ft : m ref (m1 s) G(x) = private ref (m2 s) t = m1 \ns G ft := scastt x .t := scastt x when oneref(() *x),W(t1,m) Types with dynamic sharing mode need runtime \nchecks R(t,dynamic) = chkread(t) R(t,private) = E W(t,dynamic) = chkwrite(t)W(t,private) = E Figure \n4. Typing judgments. S ::= S ; s |[\u00b7]S |l := e when .1([\u00b7]L),.2(t2),...,.n(tn) |[\u00b7]L := e |a := [\u00b7]L \n M,E : x t -. E(x) M,E,id : skip; s s -. M,.,s M,E : *x t -. Mv(E(x)) M,E,id :spawn f () s -. M, f,skip \nM,E,id : a1 := a2 s -. M[a1 v -.Mv(a2)],.,skip M,E,id : a := null s -. M[a v -.0],.,skip M,E,id : a := \nnewt s -. extend(M[a v -.m + 1],id,t),.,skip M,E,id : a := n s -. M[a v -.n],.,skip s v v t o R W M,E,id \n: a1:= --.0,v2 .t,v2 .id,v2 .\u00d8.\u00d8],.,skip where v2 .M[a1 .v2,a2 -----M(a2).value scastt a2 ,v2 = M,E,id \n: t := e when .1(a),.2(t2) ...,.n(tn) -s ,.,t := e when .2(t2),...,.n(tn= .1(a) .M' .M' ) if M,id |M,E,id \n: t := e when .1(a),.2(t2) ...,.n(tn) .sM,.,fail if M,id= - |.1(a) s tt '' '' M,E,id : s -, f,sM,E : \nt.tt M,E : t.tt = 0 .M ' -' * 0 -M,E,id : S [s]S .M ' , f,S [s ' ]SM,E,id : S [t]L .M,.,S [t ' ]LM,E,id \n: S [t]L .M,.,fail M,E,i : si .M ' ,.,s ' iM ' = threadexit(M,Ei ,i) M,...,(Ei ,si),... .M ' ,...,(Ei \n' ,si ' ),... M,...,(Ei,skip),... .M ' ,...,(Ei ,done),... ' M '' M,E,i : si .M ' , f,sf (){t1 x1 ...tnxn; \ns}.PE = G[x1 .m + 1,...,xn .m + n] = extend(M ' ,n + 1,t1,...,t) in ) .M '' ' M,...,(Ei,si),...,(En ,sn,...,(Ei \n' ,si ),...,(En,sn),(E,s) m = max(Dom(M)) t vo RW extend(M,id,t1,...,tk ) = M[...,(m + i) .ti,(m + i) \n.0,(m + i) .id,(m + i) .\u00d8,(m + i) -,...] ----.\u00d8 . .M' . (a) = 0 if .x .dom(E) -dom(G).E(x) = a . v . \n. threadexit(M,E,id) = M ' where . M '(a) = Mv(a) otherwise . v . . . M'(a) = Mt(a),M'(a) = MR(a) -{id},M' \n(a) = MW (a) -{id} tRW Figure 5. Parallel operational semantics. Sharing casts (CAST-ASSIGN) allow, e.g., \nthe conversion of a ref (dynamic int) to a ref (private int). To guarantee soundness, this sharing cast \nis preceded by a oneref check that ensures that the converted reference is (at runtime) the sole reference \nto the dynamic int. It is not possible to convert types that di.er further down, e.g., you cannot cast \nfrom ref (dynamic ref (dynamic int)) to ref (private ref (private int)) as the existence of a single \nreference to (dynamic ref (dynamic int)) does not guarantee that there are not more references to the \nunderlying int. To prevent other threads changing x between a runtime check and the assignment it protects, \nx must be private (and hence a local variable) in the CAST-ASSIGN and DEREF rules. It is easy to rewrite \na program with extra local variables to meet this require\u00adment. The remaining rules are straightforward \nand self explanatory.  3.3 Dynamic Semantics In Figures 5 and 6 we give a small-step operational semantics \nfor our simple language. This semantics gives a formal model for the way that SharC checks accesses to \nobjects in dynamic mode, and checks casts between sharing modes. The runtime environment consists of \nthree mappings and an integer thread identi.er: Memory M : l .Z \u00d7t\u00d7l \u00d7P(l) \u00d7P(l) M maps a cell s address \nto its value, type, owner, and sets of readers and writers (sets of thread identi.ers). For cells of \nreference type, the value is the address of the referenced cell (0 is always an invalid address). For \ncells in private mode, the owner is the thread that can access the cell. We use the notations Mv, Mt, \nMo, MR and MW to denote the projection of M to (respectively) it s value, type, owner, readers and writers. \nCorrespondingly, M[a -v . n] is the memory that di.ers from M only by the fact that M[a -v (a) = n (and \nso on for the . n]vother elements of a cell). At program start M maps the global variables to zeroes \nof the appropriate type, with empty reader and writer sets, and owner = 0 (no owner). Note that SharC \ns implementation does not need to track types or owners at runtime (the type and owner elements are never \nread by the operational semantics). Globals G : var .l gives the address of each global variable in \nM. G never changes, so we use it directly when needed.  Environment E : var . l gives the addresses \nin M of the variables of a particular thread (locals and globals).  Thread id : l is a positive natural \nnumber identifying a thread.  There are three kinds of transition rules and a runtime judgment: M,E \n: t -t .a In the given environment the l-value tevaluates to the address a where the l-value is stored. \n' M,E,id : s .-sM' , f,s In the given environment, the execu\u00adtion of statement s results in new memory \nM' and proceeds to statement s '.If f * ., thread f should be spawned.  M,(E1,s1),...,(En,sn) . M,(E1,s \n'),...,(Em,s ' ) Asys\u00ad  1m tem with main memory M and n threads with environments Ei currently executing \nstatement si transitions to a new state with main memory M' and new thread state. Each step cor\u00adresponds \nto a change in a single thread i,so .j * i.sj = s ' j. The choice of which thread advances at any given \npoint is non-deterministic. Terminated threads are left in the list with sk = done and at most a single \nthread is spawned at each step, so m = n .m = n + 1. MW (a) -{id}= \u00d8 R M, id |= - chkread(a) .M[a .MR(a) \n.{id}] MR(a) -{id}= \u00d8 MW (a) -{id}= \u00d8 W M, id |= chkwrite(a) .M[a -.MW (a) .{id}] |{b|M(b).value = a \n.M(b).type = m ref t}|= 1 M, id |= oneref(()a) .M Figure 6. Semantics for performing runtime checks. \nChecks are executed in one big step once their argument is known. M, id |= .(a) . M' Given memory state \nM, runtime check . is satis.ed for the cell at address a with new reads and writes by id recorded in \nM' . The chkread and chkwrite checks update readers and writers, as the check and update must be done \natomically, but the subse\u00adquent reads and writes can be performed independently assum\u00ading the runtime \ncheck succeeds. Most of the semantic rules are straightforward. The do-nothing skip statement is used \ninternally to simplify the semantics. Runtime checks (when) are executed left-to-right before the assignment \nthat they guard. If a runtime check fails, or if a null pointer is deref\u00aderenced, the thread transitions \nto the special fail statement, leav\u00ading the thread blocked. The chkread and chkwrite runtime checks (Figure \n6) enforce the n-readers-or-1-writer restriction for dynamic cells. The extend function extends the memory \nmap with n new memory cells of the speci.ed type, initialized to zero. Finally, threadexit updates the \nmemory after a thread exits: the thread is removed from all readers and writers sets, and the cells containing \nthe thread s locals are set to zero. The most interesting part of the semantics is the rule for scast. \nFirst, as enforced by the static semantics, the oneref predicate is used to check that there is a single \nreference to the object referenced by local variable x. This guarantees that it is safe to change the \ntype of *x as speci.ed by the cast. Second, x itself must be set to null, as there would otherwise be \ntwo ways of accessing the same memory cell with inconsistent types. Finally, the modi.ed memory cell \nhas its reader and writer sets cleared: after a cast, past accesses by other threads no longer constitute \nunintended sharing since the user has explicitly changed the cell s sharing mode, and veri.ed that other \nthreads can no longer access it. The oneref check is speci.ed using heap inspection for simplic\u00adity of \nexposition, while the SharC implementation uses reference counting. This does not a.ect our semantics \nas our simple language does not support recursive types. 3.4 Soundness We have proved that these semantics \nguarantee that the declared sharing strategy is respected: private cells are only accessed by the thread \nthat owns them  no two threads have a race on a dynamic cell, i.e., access the same dynamic cell with \nat least one access being a write, unless there has been an intervening sharing cast  The proof is based \non showing that at all times, all threads are well-typed, well-checked (necessary runtime checks hold \nor will be performed), and consistent with the memory. Definition 1. M is consistent with the environment \nE of thread id if types and owners are consistent between E, M and the static seman\u00adtics, and when one \ncell refers to another within M. Furthermore, the readers and writers sets in M must have legal values. \nFormally, for all addresses a with non-zero value b = Mv(a), and all variables x with declared type tx \n: Mt(E(x)) = tx (variable types are preserved)  x . Dom(G) . Mo(E(x)) = id (local variables are owned \nby their thread)  Mt(a) = m ref t .b * E(x) (variables are not addressable)  Mt(a) = m ref t .Mt(b) \n= t (types are consistent)  Mt(a) = private ref (private s) .Mo(a) = Mo(b)(owners are consistent)  \n|MW (a)|=1 (no more than one writer)  MW (a) * \u00d8. MR(a) . MW (a) (no other readers than the writer) \n Proof Outline: The proof proceeds by induction over steps of the operational semantics, showing that \nall steps preserve well\u00adtypedness, well-checkedness and consistency. From this, it imme\u00addiately follows \nthat private accesses are safe, i.e., when thread id reads or writes private cell a, a s owner is id. \nSimilarly, well\u00adcheckedness implies that dynamic accesses are safe, i.e., when thread id reads (respectively, \nwrites) dynamic cell a, chkread (a) (respectively, chkwrite (a)) holds. Therefore no races occur on dynamic \ncells. The full proof is found in our technical report [2].  4. Implementation The input to the SharC \ncompiler is a partially annotated C pro\u00adgram. The SharC compiler .rst infers the missing annotations \n(Sec\u00adtion 4.1). SharC then type-checks and instruments with runtime\u00adchecks the now-complete program. \nThis augmented code is then passed to a normal C compiler and linked with SharC s runtime library. At \nruntime, SharC veri.es correct use of dynamic and locked locations, and checks that sharing casts are \nonly applied to objects to which there is only one reference (Section 4.2). SharC assumes that its input \nis a type-and memory-safe C program. Furthermore, sharing casts that change quali.ers of (void *) types \nare forbidden. The programmer must cast the (void *) pointer to a concrete type before the sharing change \nso that SharC can check that the change is legal. To ensure full soundness, SharC would need to be combined \nwith a system such as CCured [18], or Deputy [6] that checks such (void *) casts and guarantees type\u00adand \nmemory-safety. 4.1 Sharing Analysis The main purpose of SharC s sharing analysis is to determine which \ndata might be shared across threads and needs the dynamic mode, with the remaining data being private. \nAdditionally, how\u00adever, to reduce the annotation burden, SharC will infer other sharing modes by following \nthese simple rules: A .eld or variable used in a locked quali.er must be readonly, to preserve soundness. \n Type de.nitions can specify that they are inherently racy. This is used, e.g., for pthread s mutex \nand cond types.  SharC provides a simple form of quali.er polymorphism for structs. If the outermost \nquali.er on a structure .eld is not speci.ed, it is inferred to be the same as the quali.er on the instance \nof the structure. This is sound, since structure .elds occupy the same memory that is described by the \ninstance. As a consequence, SharC does not allow the outermost annotation of a .eld to be private: within \na private struct, such a .eld is already private, while accesses to a private .eld within a non-private \nstruct would be unsound.  Outside of structure de.nitions, if the target type of a pointer is unannotated, \nthen it is assumed to be the type of the pointer. For instance (int * dynamic) becomes (int dynamic * \ndynamic), but (int dynamic * private) remains as is. In\u00adside of a structure de.nition, unannotated pointer \ntarget types are given the dynamic mode.  An array is treated like a single object of the array s base \ntype.  We have found that these rules expedite the application of SharC to real C programs. After these \nrules have been applied, the sharing analysis makes all remaining unannotated types either private or \ndynamic.Be\u00adcause accesses to dynamic objects are checked at runtime to detect data races, SharC attempts \nto minimize the number of objects in\u00adferred to be dynamic. First, we describe how the dynamic quali.er \n.ows for assignments and function calls. Second, we describe how the analysis is seeded by a set objects \nthat are inherently shared among threads. Taken together, this is su.cient to identify all the potentially \nshared objects that need the dynamic quali.er. For assignments, we follow CQual s[10] .ow-insensitive \ntype quali.er rules, with changes to account for quali.er polymorphism in structures. To avoid overaggressive \npropagation of the dynamic quali.er, we only infer that it .ows from formals to actuals in the following \ncase: if a formal is stored in a dynamic location, or has a dynamic location stored in it, then the dynamic \nquali.er will .ow to the actual at the call site. This is equivalent to adding a second kind of dynamic \nquali.er, which we internally refer to as dynamic in, which accepts both private and dynamic objects. \nUsers of our system never see or write this quali.er. Next, we must .nd the shared objects with which \nto seed the analysis. First, we observe that for an object to be shared, it must be read or written in \na function spawned as a thread. The locations available to a function spawned as a thread are the following: \n locals These can only be shared if their addresses are written into another shared location, so locals \nare not seeds.  formals The argument to the thread function is an object passed by another thread, \nso is inherently shared and seeds the analysis.  globals All globals touched by thread functions might \nbe shared, and so are seeds for the analysis.  It is an error if any of these inherently shared objects \nhave been annotated as private. In order to identify all globals that might be touched by threads, we \nconstruct control .ow graphs rooted at the functions that are spawned as threads. We handle function \npointers by assuming that they may alias any function in the program of the appropriate type. This is \nsound under our type and memory safety assumption. 4.2 Runtime Checks At runtime, SharC tracks held \nlocks, reference counts, and reader, writer sets for dynamic locations. This information is then in\u00adspected \nin a straightforward way by the various runtime checks. 4.2.1 Tracking Reader and Writer Sets For every \n16 bytes of memory SharC maintains an extra n bytes that record how each thread has accessed those 16 \nbytes. We can support up to 8n - 1 threads when n extra bytes are used for record keeping. For the applications \nwe have evaluated with SharC, setting n = 1 has been su.cient. Accesses and updates to the bits are made \natomic, as required by the chkread and chkwrite checks, through use of the cmpxchg instruction available \non the x86 architecture. These extra bytes encode the reader and writer sets as follows. If the low (0-th) \nbit is set, this indicates that a single thread is reading 1 void *scast(void *src, void **slot) { 2 \n*slot = NULL; 3 if (refcount(src) > 1) 4 error(); 5 return src; 6 } Figure 7. The procedure for checking \na sharing cast. and writing to the location. If the n-th bit is set, this indicates that the n-th thread \nis reading from the location, and writing to it if the 0-th bit is also set. This encoding of reader, \nwriter sets does not scale well to larger numbers of threads. In the future, we plan to explore alternative, \nmore e.cient encodings. When heap memory is deallocated with free(), it is no longer considered to be \naccessed by any thread, and all of its bits are cleared. When a thread ends, the bits recording its accesses \nare cleared: SharC does not consider it a race for two threads to access the same location if their execution \ndoes not overlap. The clearing operation is made e.cient by logging the addresses of all of a thread \ns reads and writes on its .rst accesses to those addresses. 4.2.2 Tracking Held Locks When a lock is \nacquired, the address of the lock is stored in a thread private log. When a thread accesses an object \nin the locked sharing mode, a runtime check is added that ensures the required lock is in the log. When \nthe lock is released, the address of the lock is removed from the log. 4.2.3 Checking Sharing Casts \nThe procedure for checking a sharing cast is given in Figure 7. When a programmer adds an explicit sharing \ncast, e.g. x= SCAST(t, y), SharC transforms it into x = scast(y, &#38;y) after determining that the cast \nis legal. The address of the reference is needed so that the reference can be nulled out. Then, if there \nis more than one reference to the object being casted, an error is signaled. Finally, the reference is \nreturned. In the example above, if y were still live after the cast, SharC would issue a warning. This \nwarning lets the programmer know that the reference will be null after the cast. The procedure for determining \nreference counts is described in section 4.3.  4.3 Maintaining Reference Counts SharC builds upon the \nauthors prior work [13] in reference count\u00ading C. Applying this work directly in SharC implies atomically \nup\u00addating reference counts for all pointer writes. The resulting over\u00adhead is unacceptable on current \nhardware, even on x86 family processors that support atomic increment and decrement instruc\u00adtions. To \nreduce this overhead, SharC performs a straightforward whole-program, .ow-insensitive, type-quali.er-like \nanalysis to de\u00adtect which locations might be subject to a sharing cast. Only point\u00aders to these locations \nneed reference count updates. However, even with this optimization, the runtime overhead is still too \nhigh (over 60% in many cases). To reduce this overhead, we adapted Levanoni and Petrank s high performance \nconcurrent reference counting al\u00adgorithm [16] (designed for garbage collection) for use with SharC. In \nLevanoni and Petrank s algorithm, there are a number of threads mutating data(i.e. mutators), and a distinguished \nthread that performs garbage collection(i.e. the collector). Each mutator thread keeps a private, unsynchronized \nlog of the reference updates it performs. The log contains a record for each update of which reference \nwas updated along with the old value that was overwritten by the update. To keep the log size manageable, \nan entry is only added the .rst time a reference is updated. This is accomplished by keeping a dirty \nbit for each reference, which is set the .rst time the reference is updated, and occasionally cleared \nby the collector thread. When a reference count is needed, the collector thread stops the mutator threads, \ncopies their logs before clearing them, resets the dirty bits, and starts the mutator threads running \nagain. The collec\u00adtor thread then processes the logs as follows. First, the reference counts for the \noverwritten values are decremented. Next, the refer\u00adence counts for the new values are incremented, but \nonly when the dirty bit for the reference cell has not been set again since the mu\u00adtator threads were \nrestarted. If the dirty bit has been set again, the reference count for the overwritten value in the \ncurrently live logs is incremented being in the new logs, it will be decremented when the new logs are \nprocessed. We note here that it is safe to temporar\u00adily overestimate the reference counts. Levanoni and \nPetrank also have another algorithm that stops threads one by one, rather than all at once, but which \nis more complicated to implement. We have adapted the simpler algorithm in the following ways. First, \nin our adaptation, there is no need for a dedicated collector thread. When a thread needs a reference \ncount, it simply performs all the tasks of the collector thread listed above. However, only one thread \nat a time may act as the collector thread. Second, there is no need to stop all threads while the collector \nthread copies logs. Rather, in our implementation there are two sets of logs, and two arrays of dirty \nbits. Instead of copying logs, the collector thread arranges(through a simple lock-free algorithm) for \neach thread to use the other set of logs and dirty bits, and waits for any pending updates to complete. \nAt this point the collector thread can proceed as before. Levanoni and Petrank also describe how to avoid \nthe problems that arise when the target architecture does not have a sequentially consistent memory model. \nWe describe in detail our algorithm and how these problems are addressed by our implementation in our \ntechnical report [2]. 4.4 The C Library In applying SharC to real C programs, it is necessary to handle \nsome features of the C language, and the C Library. In particular, we require pointer arguments to variable \nargument functions to be private. This caused no problems when SharC was applied to the benchmarks in \nSection 5. Further, we stipulate that C Library calls require pointer arguments be private. However, \nSharC also sup\u00adports trusted annotations that summarize the read/write behavior of library calls. When \nthe read/write behavior of a library call is sum\u00admarized for an argument, the call may accept an actual \nargument in any sharing mode except for locked. In particular, for a dynamic actual, the read/write summary \ntells how to update the reader/writer sets for the object, and a readonly actual can be safely passed \nwhen there is a read summary. 4.5 Limitations SharC has a couple of limitations. First, false race reports \nmay re\u00adsult from false sharing, and from the use of custom memory alloca\u00adtors. Since we track races at \na 16-byte granularity, races may be re\u00adported for two separate objects that are close together, but used \nin a non-racy way. To alleviate this problem, SharC ensures that malloc allocates objects on a 16-byte \nboundary. If a program s custom memory allocator transfers unused memory between threads, or does not \nallocate on 16-byte boundaries, SharC may incorrectly re\u00adport races. In the future, we will provide support \nfor making SharC understand custom allocators. Second, our analysis is dynamic, so it will only detect \nsharing strategy violations over a limited number of paths, and only for thread schedules that actually \noccur on a concrete run of the pro\u00adgram. The advantage of the dynamic analysis is, of course, that er\u00adrant \nprogram behavior will be detected when it occurs, rather than at some later time.  5. Evaluation We \napplied SharC to 6 multithreaded C programs totaling over 600k lines of code. Two of the programs were \nover 100k lines. These programs use threads in a variety of ways: some use threads for performance, whereas \nothers use threads to hide I/O latency. Further, one benchmark is a server that spawns a thread for each \nclient. We found the following procedure for applying SharC to be ex\u00adpedient. Minimal changes are made \nto the source until the inference stage no longer results in ill-formed types. This involves removing \ncasts that that incorrectly strip o. our type quali.ers. Then, we run the program and inspect the error \nreports. These are usually su.\u00adcient to tell how data is shared in the program, and we use them to decide \nwhat objects are protected by which locks, and to note where the sharing mode of objects changes (typically, \nSharC s shar\u00ading cast suggestions can be applied as is). The goal of these experiments is to demonstrate \nthat our ap\u00adproach is practical. In particular, it requires few enough code changes, and incurs low enough \noverhead that it could be used in production systems. We found no serious errors2 in our bench\u00admarks \nbecause our tests only sought to exercise typical runs of the programs we did not perform thorough regression \ntesting. Table 1 summarizes our experience using SharC. The reported runtimes are averages of 50 runs \nof each of the benchmarks. Mem\u00adory overhead was measured by recording the number of minor pagefaults3 \nincurred by each benchmark. All tests were run on a machine with a dual core 2GHz Intel Xeon processor \nwith 2GB of memory. A total of 60 annotations, and 122 other code changes were required for the 600k \nlines of code. On average, SharC in\u00adcurred a performance overhead of 9.2%, and a memory overhead of 26.1%. \nThe pfscan benchmark is a tool that spawns multiple threads for searching through .les. It combines some \nfeatures of grep and .nd. One thread .nds all the paths that must be searched, and an arbitrary number \nof threads take paths o. of a shared queue protected with a mutex and search .les at those paths. Our \ntest searched for a string in all .les in an author s home directory. We found that running the test \nseveral times allowed all .les to be held in the operating system s bu.er cache, and so we were able \nto eliminate .le systems e.ects in measuring the overhead. The aget benchmark is a download accelerator. \nIt spawns sev\u00aderal threads that each download pieces of a .le. We measured per\u00adformance by downloading \na Linux kernel tarball. The program was network bound, and so the overhead created by SharC was not mea\u00adsurable. \nThe pbzip2 benchmark is a parallel implementation of the block-based bzip2 compression algorithm. The \nbenchmark con\u00adsisted of using three worker threads to compress a 4MB .le. The pbzip2 benchmark has threads \nfor .le I/O, and an arbitrary number of threads for (de)compressing data blocks, which the .le-reader \nthread arranges into a shared queue. The functions that perform the (de)compression assume they have \nownership of the blocks, and so we annotate their arguments as private. One benign race was found in \na .ag used to signal that reading from the input .le has .nished. At worst, a thread might yield an extra \ntime before exiting. 2 By serious error we mean a sharing strategy violation that causes unin\u00ad tended \nresults. 3 The number of minor pagefaults indicates the number of times the oper\u00adating system kernel \nmaps a page of the process s virtual address space to a physical frame of memory. It is a rough measure \nof memory usage.  Name Benchmark Threads Lines Annots. Changes Time Orig. SharC Pagefaults Orig. SharC \n% dynamic Accesses pfscan 3 1.1k 8 11 1.84s 12% 21k 0.8% 80.0% aget 3 1.1k 7 7 n/a n/a 0.4k 30.8% 8.7% \npbzip2 5 10k 10 36 0.83s 11% 10k 1.6% ~0.0 % dillo 4 49k 8 8 0.69s 14% 2.6k 78.8% 31.7 % .tw 3 197k 7 \n39 44.1s 7% 63k 1.2% 0.2 % stunnel 3 361k 20 22 0.39s 2% 0.5k 43.5% ~0.0% Table 1. Benchmarks for SharC. \nFor each test we show the maximum number of threads running concurrently(Threads), the size of the benchmark \nincluding comments (Lines), the number of annotations we added (Annots.) and other changes required (Changes). \nWe also report the time and memory overhead caused by SharC along with the proportion of memory accesses \nto dynamic objects. The dillo benchmark is a web browser that aims to be small and fast. We measured \nthe overhead of SharC by starting the browser, requesting a sequence of 8 URLs, and then closing the \nbrowser. The dillo benchmark uses threads to hide the latency of DNS lookup. It keeps a shared queue \nof the outstanding requests. Four worker threads read requests from the queue and initiate calls to gethostbyname. \nSeveral functions called from the worker threads assume that they own request data, so the arguments \nto these func\u00adtions were annotated private. The memory overhead for dillo is higher because integers \nare cast to pointer type, and SharC infers they need to be reference counted. These bogus pointers are \nnever dereferenced, but we incur minor pagefaults when their reference counts are adjusted. We suspect \nthat this issue could be addressed if the programmer annotates the pointers that only store bogus values. \nThe .tw benchmark performs 32 random FFT s as generated by the benchmarking tool distributed with The \nFastest Fourier Trans\u00adform in the West [12]. The .tw benchmark computes by dividing arrays among a .xed \nnumber of worker threads. Ownership of ar\u00adrays is transferred to each thread, and then reclaimed when \nthe threads are .nished. The functions that compute over the partial arrays assume that they own that \nmemory, so it was only necessary to annotate those arguments as private. The stunnel benchmark is a tool \nthat allows the encryption of arbitrary TCP connections. It creates a thread for each client that it \nserves. The main thread initializes data for each client thread before spawning them. There are also \nglobal .ags and counters, which are protected by locks. Stunnel uses the OpenSSL library, so it is also \nnecessary to process it with SharC. Even though OpenSSL is not concurrent itself, SharC is able to verify \nthat there are no thread\u00adsafety issues with its use by stunnel in our tests. Our experiments with stunnel \ninvolved encrypting three simultaneous connections to a simple echo server with each client sending and \nreceiving 500 messages. 5.1 Conversion E.ort Our experiments on the programs above did not require extremely \ndeep understanding. Locks tended to be declared near the objects they protected, threading-related code \ntended to be in a .le called thread.c , private annotations were made close both textually and in the \ncall graph to thread creation calls, and so forth. As in Section 2.1 s example, SharC s error reports \nwere often helpful in guiding annotation insertion. Also, SharC infers a reasonable de\u00adfault for omitted \nannotations. Therefore, we had no insurmount\u00adable problems in adding the few needed annotations. Time \nrequired to read and annotate relevant code varied between 2 and 4 hours. Time for reading and annotating \nlarger codes did not grow propor\u00adtionally because threading-related code tended to be concentrated in \none place. Since the annotation burden is low, we do not believe that automating the annotation process \nwould have a substantial bene.t.  6. Related Work The work most closely related to our own are tools \nthat attempt to .nd data races in concurrent programs. Whereas SharC attempts to identify violations \nof a sharing strategy, race detectors simply look for unsynchronized access to memory. There are several \ndi.erent approaches to race detection. We classify the approaches as static, dynamic, and model-checking. \n6.1 Static Race Detection and Model Checking There has been much work on statically analyzing data races \nand atomicity in Java programs [3, 21, 17]. We have used some own\u00adership type ideas from these works \nin our own type system, and believe that atomicity is an important concern requiring further at\u00adtention \nin dynamic analysis of large real-world legacy C programs. Cyclone [14] allows the programmer to write \ntype annotations that enable its compiler to statically guarantee race-freedom. The di.culty in applying \nCyclone s analysis to existing multithreaded programs lies in translation to a program with Cyclone s \nannota\u00adtions and concurrency primitives. Our system requires annotations, but they are far less pervasive. \nRelay [25], and RacerX [8] are static lockset based analyses for C code that scale to large real world \nprograms including the Linux kernel. However, both tools are unsound, and require signif\u00adicant post-processing \nof warnings to achieve useful results. Lock\u00adsmith [19], on the other hand, is a sound static race detector \nfor C. It statically infers the correlation of memory locations to the locks that protect them. If a \nshared location is not consistently protected by the same lock, a race is reported. Locksmith also does \na shar\u00ading analysis similar to our own as an optimization. Unfortunately, Locksmith runs out of resources \nwhile analyzing larger programs. Some of these techniques have scaled up to many hundreds of thousands \nof lines of code and have uncovered serious problems in real world software. Further, some of these techniques, \nespecially the ones for Java, also achieve manageable false positive rates. For development cultures \nin which programmers are encouraged to use the results of static analysis, these techniques are probably \nan appropriate choice. However, testing is already widely used, and so low overhead dynamic analysis \nwill be the least cost path to race detection for many people. Sen and Agha [23] perform explicit path \nmodel checking of multithreaded programs by forcing races detected on a concrete run to permute by altering \nthe thread schedule, and by solving symbolic constraints to generate inputs that force the program down \nnew paths. KISS and the work of Henzinger et. al. can also .nd errors in concurrent programs with model \nchecking [20, 15]. 6.2 Dynamic Race Detection Eraser [22] popularized the dynamic lockset algorithm \nfor race de\u00adtection. The goal of the lockset algorithm is to ensure that every shared location is protected \nby a lock. Eraser monitors every mem\u00adory read and write in the program through binary instrumentation, \nand tracks the state of each location in memory. The states that a lo\u00adcation can inhabit model common \nidioms such as initialization be\u00adfore sharing, read-sharing, read-write locking, and so forth. Eraser \nis able to analyze large real-world programs, but it incurs a 10x\u00ad30x runtime overhead. Further, the \nstate diagram used to determine when a race might be occurring may not be an accurate model of the data \nsharing protocol in a program. This inaccuracy leads to false positives. Improvements to the lockset \nalgorithm use Lamport s happens\u00adbefore relation to track thread-ownership changes. This reduces false \npositives due the lockset state diagram failing to model sig\u00adnaling between threads, among other things. \nAdditionally, some dy\u00adnamic race detectors perform preliminary static analysis to improve performance. \nAnalyses using these improvements have achieved lower false positive rates and better performance [1, \n9, 4]. For Java, the overhead has been reduced to 13%-42% [5]. Goldilocks inte\u00adgrates race detection \ninto the Java runtime [7]. Racetrack integrates race detection into the CLR [26], and achieves overhead \nin the range 1.07x-3x for .Net languages, with the low end correspond\u00ading to non-memory-intensive programs. \nUsing the happens-before relation and more complicated state diagrams to model additional data sharing \nschemes reduces false positives, but our system is the .rst to attack the root of the problem by modeling \nownership trans\u00adfer directly.  7. Conclusion We have presented SharC, the .rst tool that allows programmers \nto specify and verify (through static and dynamic checks) the data sharing strategy used in multithreaded \nC programs. We have shown the promise and practicality of SharC by applying it to over 600k lines of \nlegacy C code with few annotations and performance over\u00adhead under 10% on average. SharC can still be \nimproved. In particular, its runtime race detection should be able to handle a larger number of threads \nwith low overhead. SharC may also need new sharing modes to better support existing sharing strategies \n(e.g., more support for locks), and to model new sharing strategies (e.g., transactional memory). 7.1 \nFuture Work We mentioned in Section 4 that for full soundness, SharC must rely on some external tool \nto provide type-and memory-safety. For that reason, we are currently integrating SharC with the Deputy \n[6], and Heapsafe [13] tools. Deputy provides for type-and memory-safety, and Heapsafe provides for deallocation \nsafety (i.e. the absence of dangling references). It is interesting to note that Deputy and Heapsafe \nby themselves are unsound in the presence of sharing strategy violations, but when combined with SharC \nthey provide an incremental pathway to type-and memory-safe concurrent C programs.  References [1] Agarwal,R., \nSasturkar,A., Wang,L., and Stoller,S.D. Optimized run-time race detection and atomicity checking using \npartial discovered types. In ASE 05. [2] Anderson,Z.R., Gay,D., Ennals,R., and Brewer,E. SharC: Checking \ndata sharing strategies for multithreaded C. Tech. Rep. UCB/EECS-2008-25, EECS Department, University \nof California, Berkeley, Mar 2008. [3] Boyapati,C., Lee,R., and Rinard, M. Ownership types for safe programming: \npreventing data races and deadlocks. In OOPSLA 02, pp. 211 230. [4] Cheng, G.-I., Feng,M., Leiserson,C.E., \nRandall,K. H., and Stark, A. F. Detecting data races in Cilk programs that use locks. In SPAA 98, pp. \n298 309. [5] Choi,J.-D., Lee,K., Loginov,A., O Callahan,R., Sarkar,V., and Sridharan,M. E.cient and precise \ndatarace detection for multithreaded object-oriented programs. In PLDI 02, pp. 258 269. [6] Condit,J., \nHarren,M., Anderson,Z., Gay,D., and Necula,G. Dependent types for low-level programming. In ESOP 07. \n [7] Elmas,T., Qadeer,S., and Tasiran, S. Goldilocks: a race and transaction-aware Java runtime. In PLDI \n07, pp. 245 255. [8] Engler,D., and Ashcraft, K. RacerX: e.ective, static detection of race conditions \nand deadlocks. In SOSP 03, pp. 237 252. [9] Flanagan,C., and Freund, S. N. Atomizer: a dynamic atomicity \nchecker for multithreaded programs. In POPL 04, pp. 256 267. [10] Foster,J. S., Fahndrich,M., and Aiken, \nA. A theory of type quali.ers. In PLDI 99, pp. 192 203. [11] freedesktop.org. Gstreamer: Open source \nmultimedia framework. http://gstreamer.freedesktop.org/. [12] Frigo, M. A fast Fourier transform compiler. \nIn PLDI 99, pp. 169 180. [13] Gay,D., Ennals,R., and Brewer, E. Safe manual memory management. In ISMM \n07 (New York, NY, USA, 2007), ACM, pp. 2 14. [14] Grossman, D. Type-safe multithreading in Cyclone. [15] \nHenzinger,T. A., Jhala,R., and Majumdar, R. Race checking by context inference. In PLDI 04, pp. 1 13. \n[16] Levanoni,Y., and Petrank, E. An on-the-.y reference-counting garbage collector for Java. ACM Transactions \non Programming Languages and Systems 28, 1 (2006), 1 69. [17] Naik,M., Aiken,A., and Whaley,J. E.ective \nstatic race detection for Java. In PLDI 06, pp. 308 319. [18] Necula,G. C., Condit,J., Harren,M., McPeak,S., \nand Weimer,W. CCured: Type-safe retro.tting of legacy software. ACM Transactions on Programming Languages \nand Systems 27, 3 (May 2005). [19] Pratikakis,P., Foster,J.S., and Hicks, M. Locksmith: context\u00adsensitive \ncorrelation analysis for race detection. In PLDI 06, pp. 320 331. [20] Qadeer,S., and Wu, D. KISS: keep \nit simple and sequential. In PLDI 04, pp. 14 24. [21] Sasturkar,A., Agarwal,R., Wang,L., and Stoller,S.D. \nAutomated type-based analysis of data races and atomicity. In PPoPP 05, pp. 83 94. [22] Savage,S., Burrows,M., \nNelson,G., Sobalvarro,P., and Anderson, T. Eraser: a dynamic data race detector for multi-threaded programs. \nIn SOSP 97, pp. 27 37. [23] Sen,K., and Agha, G. A race-detection and .ipping algorithm for automated \ntesting of multi-threaded programs. In Haifa Veri.cation Conference (2006), pp. 166 182. [24] US-CERT. \nTechnical cyber security alerts. http://www.us-cert.gov/cas/techalerts/index.html. [25] Voung,J.W., Jhala,R., \nand Lerner, S. RELAY: static race detection on millions of lines of code. In ESEC-FSE 07, pp. 205 214. \n[26] Yu,Y., Rodeheffer,T., and Chen, W. Racetrack: e.cient detection of data race conditions via adaptive \ntracking. In SOSP 05, pp. 221 234.  \n\t\t\t", "proc_id": "1375581", "abstract": "<p>Unintended or unmediated data sharing is a frequent cause of insidious bugs in multithreaded programs. We present a tool called SharC (short for <i>Sharing Checker</i>) that allows a user to write lightweight annotations to declare how they believe objects are being shared between threads in their program. SharC uses a combination of static and dynamic analyses to check that the program conforms to this specification.</p> <p>SharC allows any type to have one of five \"sharing modes\" -- private to the current thread, read-only, shared under the control of a specified lock, intentionally racy, or checked dynamically. The dynamic mode uses run-time checking to verify that objects are either read-only, or only accessed by one thread. This allows us to check programs that would be difficult to check with a purely static system. If the user does not give a type an explicit annotation, then SharC uses a static type-qualifier analysis to infer that it is either private or should be checked dynamically.</p> <p>SharC allows objects to move between different sharing modes at runtime by using reference counting to check that there are no other references to the objects when they change mode.</p> <p>SharC's baseline dynamic analysis can check any C program, but is slow, and will generate false warnings about intentional data sharing. As the user adds more annotations, false warnings are reduced, and performance improves.We have found in practice that very few annotations are needed to describe all sharing and give reasonable performance. We ran SharC on 6 legacy C programs, summing to over 600k lines of code, and found that a total of only 60 simple annotations were needed to remove all false positives and to reduce performance overhead to only 2-14%.</p>", "authors": [{"name": "Zachary Anderson", "author_profile_id": "81332488087", "affiliation": "University of California, Berkeley, Berkeley, CA, USA", "person_id": "P1022765", "email_address": "", "orcid_id": ""}, {"name": "David Gay", "author_profile_id": "81100039538", "affiliation": "Intel, Berkeley, CA, USA", "person_id": "P1022766", "email_address": "", "orcid_id": ""}, {"name": "Rob Ennals", "author_profile_id": "81331491980", "affiliation": "Intel, Berkeley, CA, USA", "person_id": "P1022767", "email_address": "", "orcid_id": ""}, {"name": "Eric Brewer", "author_profile_id": "81100357712", "affiliation": "University of California, Berkeley, Berkeley, CA, USA", "person_id": "P1022768", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1375581.1375600", "year": "2008", "article_id": "1375600", "conference": "PLDI", "title": "SharC: checking data sharing strategies for multithreaded c", "url": "http://dl.acm.org/citation.cfm?id=1375600"}