{"article_publication_date": "06-07-2008", "fulltext": "\n LiquidTypes * Patrick M. Rondon Ming Kawaguchi Ranjit Jhala University of California, San Diego {prondon,mwookawa,jhala}@cs.ucsd.edu \nAbstract We presentLogically Quali.ed DataTypes, abbreviated to Liquid Types, a system that combines \nHindley-Milner type inference with Predicate Abstraction to automatically infer dependent types pre\u00adcise \nenough to prove a variety of safety properties. Liquid types allow programmers to reap many of the bene.ts \nof dependent types, namely static veri.cation of critical properties and the elim\u00adination of expensive \nrun-time checks, without the heavy price of manual annotation.We have implemented liquid type inference \nin DSOLVE,whichtakesasinputanOCAMLprogramandasetoflog\u00adical quali.ers and infers dependent types for the \nexpressions in the OCAML program.To demonstrate the utility of our approach, we describe experiments \nusing D SOLVE to statically verify the safety of array accesses ona setofOCAML benchmarksthat were previ\u00adously \nannotated with dependent types as partof theDMLproject. We show that when used in conjunction with a \n.xed set of array bounds checking quali.ers, DSOLVE reduces the amount of man\u00adual annotation required \nfor proving safety from 31% of program text to under 1%. Categories and Subject Descriptors D.2.4[Software \nEngineer\u00ading]: Software/ProgramVeri.cation; F.3.1[Logics and Meanings of Programs]: Specifying andVerifying \nand Reasoning about Pro\u00adgrams General Terms Languages, Reliability,Veri.cation Keywords DependentTypes, \nHindley-Milner, Predicate Abstrac-tion,Type Inference 1. Introduction Modern functional programming languages, \nlike ML and Haskell, have manyfeatures that dramatically improve programmer produc\u00adtivityand software \nreliability.Twoofthe most signi.cant are strong static typing, which detects a host of errors at compile-time, \nand type inference, which (almost) eliminates theburdenof annotating the program with type information, \nthus delivering the bene.ts of strong static typing for free. * This work was supported by NSF CAREER \ngrant CCF-0644361, NSF PDOS grant CNS-0720802, NSF Collaborative grant CCF-0702603, and a gift from Microsoft \nResearch. Permission to make digital or hard copies of all or part of this work for personal or classroom \nuse is granted without fee provided that copies are not made or distributed for pro.t or commercial advantage \nand that copies bear this notice and the full citation on the .rst page.To copyotherwise, to republish, \nto post on servers or to redistribute to lists, requires prior speci.c permission and/or a fee. PLDI \n08, June 7 13, 2008,Tucson, Arizona, USA. Copyright c &#38;#169; 2008ACM 978-1-59593-860-2/08/06... $5.00. \n The utility of these type systems stems from their ability to pre\u00addict, at compile-time, invariants \nabout the run-time values com\u00adputed by the program. Unfortunately, classical type systems only capture \nrelatively coarse invariants. For example, the system can express thefact thatavariable i is of the type \nint, meaning that itisalwaysaninteger,butnotthatitisalwaysaninteger withina certain range, say between \n1 and 99. Thus, the type system is un\u00adable to statically ensure the safety of critical operations, such \nas a divisionby i, or the accessing of an array a of size 100 at an index i. Instead, the language can \nonly provide a weaker dynamic safety guarantee at the additional cost of high performance overhead. In \nan exciting development, several authors have proposed the use of dependent types [20] as a mechanism \nfor enhancing the expressivity of type systems [14, 27, 2, 22, 10]. Such a system can express thefact \ni :: {. : int | 1 = . . . = 99} which is the usual type int together with a re.nement stating that the \nrun-time value of i is an always an integer between 1 and 99. Pfenning and Xi devised DML, a practical \nway to integrate such types into ML, and demonstrated that theycould be used to recover static guarantees \nabout the safety of array accesses, while simul\u00adtaneously making the program signi.cantlyfasterby eliminating \nrun-time checking overhead [27]. However, these bene.ts came at the price of automatic inference. In \nthe DML benchmarks, about 31%ofthecode(or17%bynumberoflines)is manual annotations thatthe typecheckerneedstoprovesafety.Webelievethatthisnon\u00adtrivial \nannotationburden has hampered the adoption of dependent types despite their safety and performance bene.ts. \nWe presentLogically Quali.ed DataTypes, abbreviated to Liq\u00aduidTypes,asystem for automatically inferring \ndependent types pre\u00adcise enough to prove a variety of safety properties, thereby allow\u00ading programmers \nto reap manyof the bene.ts of dependent types without paying the heavy price of manual annotation. The \nheart of our inference algorithmisa techniquefor blending Hindley-Milner type inference with predicate \nabstraction, a technique for synthe\u00adsizing loop invariants for imperative programs that forms the algo\u00adrithmic \ncore of several software model checkers [3, 16, 4, 29, 17]. Our system takes as input a program and a \nset of logical quali.ers which are simple boolean predicates over the program variables, a special value \nvariable ., and a special placeholder variable * that can be instantiated with program variables. The \nsystem then infers liquid types, which are dependent types where the re.nement pred\u00adicates are conjunctions \nof the logical quali.ers. In our system, type checking and inference are decidable for three reasons \n(Section3). First,we useaconservativebut decidable notion of subtyping, where we reduce the subtyping \nof arbitrary dependent types to a set of implication checks over base types, each of which is deemed \nto hold if and only if an embedding of the implication into a decidable logic yields a valid formula \nin the logic. Second, an expression has a valid liquid type derivation only if it has a valid ML type \nderivation, and the dependent type of every subexpression is a re.nement of its ML type. Third, in any \nvalid type derivation, the types of certain expressions, such as .-abstractions, if-then-else expressions, \nand recursive functions must be liquid. Thus, inference becomes decidable, as the space of possible typesis \nbounded.We use these featuresto designa three\u00adstep algorithm for dependent type inference (Section 4). \nStep 1: Hindley-Milner Type Inference: First, our algorithm in\u00advokes Hindley-Milner [7] to infer types \nfor each subexpression and the necessary type generalization and instantiation annotations. Next, our \nalgorithm uses the computed ML types to assign to each subexpression a template, a dependent type with \nthe same struc\u00adture as the inferred ML type,but which has liquid type variables representing the unknown \ntype re.nements. Step 2: Liquid Constraint Generation: Second, we use the syntax\u00addirected liquid typing \nrules to generate a system of constraints that capture the subtyping relationships between the templates \nthat must be met for a liquid type derivation to exist. Step 3: Liquid Constraint Solving: Third, our \nalgorithm uses the subtyping rules to split the complex template constraints into sim\u00adple constraints \nover the liquid type variables, and then solves these simple constraints using a .xpoint computation \ninspired by predi\u00adcate abstraction [1, 15]. Of course, there may be safe programs which cannot be well\u00adtyped \nin our system due either to an inappropriate choice of quali\u00ad.ers or the conservativeness of our notion \nof subtyping. In the for\u00admer case, we can use the readable results of the inference to manu\u00adally add \nmore quali.ers, and in the latter case we can use the results of the inference to insert a minimal set \nof run-time checks [22, 10]. Tovalidate the utilityof our technique, wehavebuiltDSOLVE, which infers \nliquid types forOCAML programs. While liquid types can be used to statically prove a variety of properties \n[24], in this paper we focus on the canonical problem of proving the safety of array accesses. We use \na diverse set of challenging benchmarks takenfromtheDMLprojectto demonstratethatDSOLVE, together with \na simple set of array bounds checking quali.ers, can prove safety completely automatically for many programs \n(Section 5). For the few programs where these bounds checking quali.ers are insuf.cient, the programmer \ntypically only needs to specify one or two extra quali.ers. Even in these rare cases, the dependent types \ninferredbyD SOLVEusing only the bounds checking quali.ers help the programmertorapidly identifytherelevantextra \nquali.ers.We show that, over all the benchmarks, DSOLVE reduces the manual annotation required to prove \nsafety from 31% of program text (or 17% by number of lines) to under 1%. Finally, we describe a case \nstudy where DSOLVE was able to pinpoint an error in an open\u00adsourceO CAMLbitvectorlibrary implementation,ina \nfunction that contained an explicit (but insuf.cient) safety check. 2. Overview Webeginwithanoverviewofour \nalgorithmfor inferring dependent types using a set of logical quali.ers Q. First, we describe depen\u00addent \ntypes, logical quali.ers, and liquid types, and then, through a series of examples, we show how our system \ninfers dependent types. DependentTypes. Following [2, 10], our system allowsbase re\u00ad.nements of the form \n{. : B |e}, where . is a special value vari\u00adable not appearing in the program, B is a base type and e \nis a boolean-valued expression constraining the value variable called the re.nement predicate. Intuitively, \nthe base re.nement predicate speci.es the set of values c of the base type B such that the predi\u00adcate \n[c/.]e evaluatesto true.Forexample, {. : int |0 <.}spec\u00adi.es the set of positive integers, and {. :int \n|. =n}speci.es the set of integers whose value is less than or equal to the value of the variable n. \nThus, B is an abbreviation for {. : B |true}.We use the base re.nements tobuild up dependent function \ntypes, written x : T1.T2 (following [2, 10]). Here, T1 is the domain type of the function, and the formal \nparameter x may appear in the base re.ne\u00adments of the range type T2. Logical Quali.ers and Liquid Types. \nA logical quali.er is a boolean-valued expression(i.e., predicate) over the program vari\u00adables, the special \nvalue variable . which is distinct from the program variables, and the special placeholder variable * \nthat can be instantiated with program variables. For the rest of this section, let us assume that Q is \nthe set of logical quali.ers {0 =., * =., .<*, .< len *}. In Section 5 we describe a simple set of quali.ers \nfor array bounds checking. We say that a quali.er q matches the quali.er q' if replacing some subset \nof the free variables in q with * yields q'.For example, the quali.er x =. matches the quali.er * =..We \nwrite Q* for the set of all quali.ers not containing * that match some quali.er in Q.For ex\u00adample, when \nQ is as de.ned as above, Q* includes the quali.ers {0 =., x =., y =., k =., .< n,.< len a}.A liquid type \nover Q is a dependent type where the re.nement predicates are conjunctions of quali.ers from Q*.We write \nliquid type when Q is clear from the context. When checking or inferring dependent types over the logical \nquali.ers, our system ensures that the types are well-formed, i.e., for each subexpression, the free \nvariables ap\u00adpearing in the inferred type are bound in the environment for that subexpression. LiquidType \nInference. Our liquid type inference algorithm pro\u00adceeds in three steps. First, we perform Hindley-Milner \n(HM) type inference and use the results to generate templates, which are de\u00adpendent types with unknown \nbase re.nements representedby liquid type variables .. Second, we generate constraints on the templates \nthat capture the subtyping relationships between the re.nements. Third, we solve the constraints by using \npredicate abstraction to .nd, for each ., the strongest conjunction of quali.ers from Q* that satis.es \nall the constraints. Note that for the third step, we need onlyconsiderthe .nite subsetof Q* whose freevariables \nbelongto the program. Next, through a series of examples, we show how our type inference algorithm incorporates \nfeatures essential for infer\u00adring precise dependent types namely path-sensitivity, recursion, higher-order \nfunctions, and polymorphism and thus can stati\u00adcally prove the safety of array accesses. Notation: We \nwrite B as an abbreviation for {. :B |true}. Ad\u00additionally, when the base type B is clear from the context, \nwe abbreviate {. : B |.}as . when . is a liquid type variable, and {. :B |e}as {e}when e is a re.nement \npredicate.For example, x :int.y : int.{x =. .y =.}denotes the type of a function that takes two (curried) \ninteger arguments x, y and returns an inte\u00adger no less than x and y. Example 1: Path Sensitivity. Consider \nthe max function shown in Figure1asanOCAML program.Wewillshowhowwe inferthat max returns a value no less \nthan both arguments. (Step 1) HM infers that max has the type x :int.y :int.int. Using this type, we \ncreate a template for the liquid type of max, x :.x .y : .y ..1,where.x ,.y ,.1 are liquid type variables \nrepre\u00adsenting the unknown re.nements for the formals x, y and the body of max, respectively. (Step 2) \nAs the body is an if expression, our algorithm generates the following twoconstraints that stipulate \nthat, under the appropri\u00adate branch condition, the then and else expressions, respectively x, y, have \ntypes that are subtypes of the entire body s type: x :.x ; y : .y ;(x > y) f{. = x}<: .1 (1.1) x :.x \n; y : .y ; \u00ac(x > y) f{. = y}<: .1 (1.2) Constraint (1.1) (resp. (1.2)) stipulates that when x and y \nhave the types .x and .y respectively and x > y (resp. \u00ac(x > y)), the type of the expression x (resp. \ny), namelythesetofallvaluesequalto x (resp. y), must be a subtype of the body .1. (Step3) Since the program \nis open , i.e., there are no calls to max, we assign .x , .y true, meaning that any integer arguments \ncan be passed, and use a theorem prover to .nd the strongest conjunction of quali.ers in Q* that satis.es \nthe subtyping constraints. The theorem prover deduces that when x > y (resp. \u00ac(x > y))if . = x (resp. \n. = y)thenx = . and y = .. Hence, our algorithm infers that x = . . y = . is the strongest solution for \n.1 that satis.esthetwoconstraints.Bysubstitutingthe solutionfor .1 into the template for max, our algorithm \ninfers max :: x : int.y : int.{. : int | (x = .) . (y = .)} Example 2: Recursion. Next, we show how our \nalgorithm infers that the recursive function sum from Figure1always returnsa non\u00ad negative value greater \nthan or equal to its argument k. (Step 1) HM infers that sum has the type k :int.int. Using this type, \nwe create a template for the liquid type of sum, k :.k ..2, where .k and .2 represent the unknown re.nements \nfor the formal k and body, respectively. Due to the let rec, we use the created template as the type \nof sum when generating constraints for the body of sum. (Step 2) Again, as the body is an if expression, \nwe generate con\u00adstraints that stipulate that under the appropriate branch conditions, the then and else \nexpressions have subtypes of the body .2. For the then branch, we get a constraint: sum :...; k : .k \n; k < 0 f{. =0} <: .2 (2.1) The else branch is a let expression. First, considering the expres\u00adsion that \nis locally bound, we generate a constraint sum : ...; k : .k ; \u00ac(k < 0) f{. = k - 1} <: .k (2.2) from \nthe call to sum that forces the actual passed in at the callsite to be a subtype of the formal of sum. \nThe locally bound variable s gets assigned the template corresponding to the output of the application, \n[k - 1/k].2, i.e., the output template of sum with the formal replaced with the actual argument, and \nwe get the next constraint that ensures the else expression is a subtype of the body .2. \u00ac(k < 0); s \n:[k - 1/k].2 f{. = s + k} <: .2 (2.3) (Step 3) Here, as sum is called, we try to .nd the strongest con\u00adjunction \nof quali.ers for .k and .2 that satis.es the constraints. To satisfy (2.2),.k can only be assigned true \n(the empty conjunc\u00adtion), as when \u00ac(k < 0), the value of k - 1 can be either negative, zero or positive. \nOn the other hand, .2 is assigned 0 = . . k = ., the strongest conjunction of quali.ers in Q* that satis.es \n(2.1) and (2.3). Constraint (2.1) is trivially satis.ed as the theorem prover de\u00ad duces that when k < \n0, if . =0 then 0 = . and k = .. When .2 is assigned the above conjunction, the binding for s in the \nenviron\u00adment for constraint (2.3) becomes s : {0 = . . k - 1 = .}. Thus, constraint (2.3) is satis.ed \nas the theorem prover deduces that when \u00ac(k < 0) and [s/.](0 = . . k - 1 = .), if . = s + k then 0 = \n. and k = .. The substitution simpli.es to 0 = s . k - 1 = s, which effectively asserts to the solver \nthe knowledge about the type of s, and crucially allows the solver to usethefact that s is non\u00adnegative \nwhen determining the type of s + k, and hence, the output of sum. Thus, recursion enters the picture, \nas the solution for the output of the recursive call, which is bound to the type of s, is used in conjunction \nwith the branch information to prove that the output expression is non-negative. Plugging the solutions \nfor .k and .2 into the template, our system infers sum :: k : int.{. : int | 0 = . . k = .} let max x \ny = if x> ythenx else y letrecsumk = if k< 0then0 else let s = sum (k-1) in s+k letfoldnnb f= let rec \nloop i c = ifi <nthen loop (i+1)(fic)elsecin loop0 b let arraymax a = letam lm=max(subal)m in foldn (len \na) 0 am Figure 1. ExampleOCAML Program Example 3: Higher-Order Functions. Next, considera program comprising \nonly the higher-order accumulator foldn shown in Figure 1.We show how our algorithm infers that f is \nonly called with arguments between 0 and n. (Step 1) HM infers that foldn has the polymorphic type .a.n \n: int.b : a.f :(int.a.a).a. From this ML type, we create the new template .a.n :.n .b : a.f :(.3.a.a).a \nfor foldn, where .n and .3 represent the unknown re.nements for the formal n and the .rst parameter for \nthe accumulation function f passed into foldn. This is a polymorphic template, as the occur\u00adrences of \na are preserved. This will allow us to instantiate a with an appropriate dependenttypeat places where \nfoldn is called. HM infers that the type of loop is i :int.c : a.a, from which we generate a template \ni : .i .c : a.a for loop, which we will use when analyzing the body of loop. (Step 2) First, we generate \nconstraints inside the body of loop. As HM infers that the type of the body is a, we omit the trivial \nsubtyping constraints on the then and else expressions. Instead, the two interesting constraints are: \n... ; i : .i ; i < n f{. = i + 1} <: .i (3.1) which stipulates that the actual passed into the recursive \ncall to loop is a subtype of the expected formal, and ... ; i : .i ; i < n f{. = i} <: .3 (3.2) which \nforces the actual i tobeasubtypeofthe .rst parameterofthe higher-order function f, in the environment \ncontaining the critical branch condition. Finally, the application loop 0 yields ... f{. =0} <: .i (3.3) \n forcing the actual 0 to be a subtype of the formal i. (Step 3) Here, as foldn is not called, we assign \n.n true and try to .nd the strongest conjunction of quali.ers in Q* for .i and .3. We can assign to.i \nthe predicate 0 = ., which trivially satis.es (3.3), and also satis.es (3.1) as when [i/.](0 = .), if \n. = i + 1 then 0 = .. That is, the theorem prover can deduce that if i is non-negative, then so is i \n+ 1.To .3 we can assign the conjunction 0 = . . .< n which satis.es (3.2) as when [i/.](0 = .) and i \n< n, if . = i then 0 = . and .< n. By plugging the solutions for .3, .n into the template our algorithm \ninfers foldn :: .a.n : int.b :a.f :({0 = . . .< n}.a.a).a Example 4: Polymorphism and Array Bounds Checking. \nCon\u00adsider the function arraymax that calls foldn with a helper that calls max to compute the max of the \nelements of an array and 0. Suppose there is a base type intarray representing arrays of inte\u00adgers. Arrays \nare accessed via a primitive function sub :: a :intarray.j : {. : int | 0 = . . .< len a}.int where the \nprimitive function len returns the number of elements in the array. The sub function takes an array and \nan index that is between 0 and the number of elements, and returns the integer at that index in the array.We \nshow how our algorithm combines predicate abstraction, function subtyping, and polymorphism to prove \nthat (a) the array a is safely accessed at indices between0 and len a, and (b) arraymax returns a non-negative \ninteger. (Step 1) HM infers that (1) arraymax has the type a : intarray.int,(2)am has the type l :int.m \n:int.int, and (3) foldn called in the body is a polymorphic instance where the type variable a has been \ninstantiated with int. Consequently, our algorithm creates the following templates: (1) a :intarray..4 \nfor arraymax, where .4 represents the unknown re.nement for the output of arraymax, (2) l : .l .m : .m \n..5 for am, where .l , .m and .5 represent the unknown re.nements for the parameters and output type \nof am respectively, and (3) .6 for the type that a is instantiated with, and so the template for the \ninstance of foldn inside arraymax is the type computed in the previous example with .6 substituted for \na, namely, n : int.b : .6.f :({0 = . . .< n}..6..6)..6 (Step2) First, for the application sub a l, our \nalgorithm generates  l :.l ; m : .m f{. = l} <: {0 = . . .< len a} (4.1) which states that the argument \npassed into sub must be within the array bounds.For the application max (sub a l) m, using the type inferred \nfor max in Example 1, we get l :.l ; m : .m f{sub a l = . . m = .} <: .5 (4.2) which constrains the output \nof max (with the actuals (sub a l) and m substituted for the parameters x and y respectively),tobeasubtype \nof the output type .5 of am. The call foldn (len a) 0 generates ... f{. = 0} <: .6 (4.3) which forces \nthe actual passed in for b to be a subtype of .6 the type of the formal b in this polymorphic instance. \nSimilarly, the call foldn (len a) 0 am generates a constraint (4.4) ... f l : .l .m : .m ..5 <: {0 = \n. . .< len a}..6..6 forcing the type of the actual am to be a subtype of the formal f inferred in Example \n1, with the curried argument len a substituted for the formal n of foldn, and ... f.6 <: .4 (4.5) forcing \nthe output of the foldn application to be a subtype of the body of arraymax. Upon simpli.cation using \nthe standard rule for subtyping function types, constraint (4.4) reduces to ... f{0 = . . .< len a} <: \n.l (4.6) ... f.6 <: .m (4.7) ... f.5 <: .6 (4.8) (Step 3) The strongest conjunction of quali.ers from \nQ* that we can assign to: .m , .4, .5 and .6 is the predicate 0 = .. In essence the solution infers that \nwe can instantiate the typevariable a with the dependent type {. :int | 0 = .}. This is sound because \nthe basevalue 0 passed in is non-negative (constraint (4.3) is satis.ed), and the accumulation function \npassed in(am), is such that if its second argument(m of type .m )is non-negative then the output (of \ne ::= Expressions: | x variable | c constant | .x.e abstraction | ee application | if e then e else e \nif-then-else | let x = e in e let-binding | let rec f = .x.e in e letrec-binding | [.a]e type-abstraction \n| [t]e type-instantiation Q ::= Liquid Re.nements | true true | q logical quali.er in Q* | Q . Q conjunction \nof quali.ers B ::= BaseTypes: | int base type of integers | bool base type of booleans T(B) ::= Type \nSkeletons: |{. :B | B} base | x:T(B).T(B) function | a type variable S(B) ::= Type Schema Skeletons: \n| T(B) monotype |.a.S(B) polytype t, s ::= T(true), S(true) Types, Schemas T,S ::= T(E), S(E) Dep.Types, \nSchemas  T, S ::= T(Q), S(Q) LiquidTypes, Schemas Figure 2. Syntax type .5)is non-negative (constraint \n(4.2) is satis.ed). Plugging the solution into the template, our algorithm infers arraymax :: intarray.{. \n: int | 0 = .} The strongest conjunction over Q* we can assign to .l is 0 = . . .< len a,which trivially \nsatis.es constraint (4.6). More\u00ad over, with this assignment, we have satis.ed the bounds check constraint \n(4.1), i.e., we have inferred an assignment of dependent types to all the program expressions that proves \nthat all array ac\u00adcesses occur within bounds. 3. LiquidType Checking We .rst present the syntax and static \nsemantics of our core lan\u00adguage .L, a variant of the .-calculus with ML-style polymorphism extended with \nliquid types.Webeginby describing the elementsof .L, including expressions, types, and environments (Section \n3.1). Next, we present the type judgments and derivation rules and state a soundness theorem which relates \nthe static type system with the operational semantics (Section 3.2). We conclude this section by describing \nhow the design of our type system enables automatic dependent type inference (Section 3.3). 3.1 Elements \nof .L The syntax of expressions and types for .L is summarized in Fig\u00adure 2. .L expressions include variables, \nspecial constants which include integers, arithmetic operators and other primitive opera\u00adtions described \nbelow, .-abstractions, and function applications. In addition, .L includes as expressions the common \nconstructs if-then-else and let,which the liquid type inference algorithm exploitstogenerate precise \ntypes, as well aslet rec which is syn\u00adtactic sugar for the standard fix operator. Types and Schemas.We \nuseB to denote base types such as bool or int. .L has a system of re.ned base types, dependent function \ntypes, and ML-style polymorphism via type variables that are uni\u00adversally quanti.ed at the outermost \nlevel to yield polymorphic type schemas.We write t and s for ML types and schemas, T and S for dependent \ntypes and schemas, and T and S for liquid types and schemas. Environments and Well-formedness. A type \nenvironment G is a sequence of type bindings x : S and guard predicates e. The former are standard; the \nlatter capture constraints aboutthe if-then\u00adelse branches under which an expression is evaluated, which \nis required to make the system path-sensitive (Section 3.3).Atype is considered well-formed with respect \nto an environment if all the free variables appearing in the re.nement predicates of the type are bound \nin the environment. An environment is considered well\u00adformed if, in each type binding, the dependent \ntype is well-formed with respect to the preceding (pre.x) environment. Shapes. The shape of the dependent \ntype (schema) S, denoted by Shape(S), is the ML type (schema) obtained by replacing all re.nement predicates \nwith true.We lift the function Shape to type environments by applying it to each type binding and eliminating \nthe guard predicates. Constants. As in [22, 10], the basic units of computation are the constants c built \ninto .L, each of which has a dependent type ty(c) that precisely captures the semantics of the constants. \nThese include basic constants, corresponding to integers and boolean values, and primitive functions, \nwhich encode various operations. The set of constants of .L includes: true :: {. :bool | .} false :: \n{. :bool | not .} . :: x:bool.y :bool.{. :bool | . . (x . y)} 3 :: {. :int | . =3}= :: x:int.y :int.{. \n:bool | . . (x = y)} + :: x:int.y :int.{. :int | . = x + y}fix :: .a.(a.a).a len :: intarray.{. :int \n| 0 = .}sub :: a:intarray.i:{. :int | 0 = . . .< len a}.int The types of some constants are de.ned in \nterms of themselves (e.g., +). This does not cause problems, as the dynamic semantics of re.nement predicates \nis de.ned in terms of the operationalse\u00admantics (as in [10]), and the static semantics is de.ned via \na sound overapproximation of the dynamic semantics [24].For clarity, we will use in.x notation for constants \nlike +.To simplify the expo\u00adsition, we assume there is a special base type that encodes integer arrays \nin .L.The lengthof an arrayvalueis obtained using len.To access the elements of the array, we use sub, \nwhich takes as input an array a and an index i that must be within the bounds of a, i.e., non-negative, \nand less than the length of the array.  3.2 LiquidType Checking Rules Wenow describethekeyingredientsofthetype \nsystem:the typing judgments and derivation rules summarized in Figure 3. Our system has three kinds of \njudgments relating environments, expressions, and types. Well-formednessJudgmentG f S: states that the \ndependent type schema S is well-formed under the type environment G. Intuitively, a type is well-formed \nif its base re.nements are boolean expressions which refer only to variables in the scope of the corresponding \nexpression. SubtypeJudgment G f S1 <: S2: states that dependent type schema S1 is a subtype of schema \nS2 in environment G. LiquidTypeJudgment G fQ e : S: states that, using the logical quali.ers Q, the expression \ne has the type schema S under the type environment G. Soundness of LiquidType Checking. Assume that variables \nare bound at most once in any type environment; in other words, assume that variables are a-renamed to \nensure that substitutions (such as in [LT-APP])avoid capture. Let .. describe the single * evaluation \nstep relation for .L expressions and .. describe the re.exive, transitive closure of ... Asthe conservativesubtypingrulemakesithardtoproveasub\u00adstitution \nlemma, we prove soundness via two steps. First, we de.ne an exact version of the type system, with a \njudgment G f e : S, whose rules use an undecidable subtyping relation.We show the standard weakening, \nnarrowing, and substitution lemmas for this system, and thereby obtain preservation and progress theorems. \nSecond, we show that our decidable system is conservative: i.e., if G fQ e : S then G f e : S. Combining \nthe results, we conclude that if an expression is well-typed in our decidable system then we are guaranteed \nthatevaluation does notget stuck , i.e., at run-time, every primitive operation receives valid inputs. \nTHEOREM 1. [LiquidType Safety] 1. (Overapproximation) If G fQ e : S then G f e : S. 2. (Preservation) \nIf G f e : S and e.. e ' then G f e ' : S. 3. (Progress) If \u00d8f e : S and e is not a value then there \nexists an e ' , e.. e ' .  We omit the details due to lack of space the formalization and proofs can \nbe found in [24]. Thus, if a program typechecks we are guaranteed that every call to sub gets an index \nthat is within the array s bounds. Arbitrary safety properties(e.g., divide-by-zero errors) canbeexpressedby \nusing suitable types for the appropriate primitive constant(e.g., requiring the second argument of (/) \nto be non-zero). 3.3 Featuresofthe LiquidType System Next, we describe some of the features unique to \nthe design of the Liquid type system and how theycontribute to automatic type inference and veri.cation. \n1. Path Sensitivity. Any analysis that aims to prove properties like the safety of array accesses needs \nto be sensitive to branch information; it must infer properties which hold for the entire if expression \nas well as for the individualthen and else expressions. For example, without the branch information in \nthe sum example from Section 2, the system would not be able to infer that the occurrence of k inside \nthe else expression is non-negative, and hence that sum returned a non-negative value. For array bounds \nchecking, programmers often compare the index to some other expression either the array length, or some \nother variable that is knowntobe smallerthanthearraylength(e.g., in arraymax from Section 2), and only \nperform the array access under the appropriate guard.To capture this kindof information, the environment \nG also includes branch information, shownin rule[LT-IF]in Figure3. 2. Decidable, Conservative Subtyping. \nAs shown in Figure 3, checking that one type is a subtype of another reduces to a set of subtype checks \non base re.nement predicates, whichfurther re\u00adduces to checking if the re.nement predicate for the subtype \nim\u00adplies the predicate for the supertype. As the re.nement predicates contain arbitrary terms, exact \nimplication checking is undecidable. Toget aroundthis problem,oursystem usesa conservativebutde\u00adcidable \nimplication check,shownin rule[DEC-<:-BASE]of Fig\u00adure 3. Let EUFAbe the decidable logic of equality, \nuninterpreted functions and linear arithmetic [21].We write [ e] for the embed\u00adding of the expression \ne into terms of the logic EUFAby encoding expressions corresponding to integers, addition, multiplication \nand division by constant integers, equality, inequality, and disequality with corresponding terms in \nthe EUFAlogic, and encoding all other constructs, including .-abstractions and applications, with uninter\u00ad \n preted function terms.We write: ^^ [ G]] ={e | e . G}. {[ [x/.]e] | x : {. :B | e}. G} as the embedding \nfor the environment. Notice that we use the guard predicates and base type bindings in the environment \nto strengthen the antecedent of the implication. However, we substitute all occurrences of the value \nvariable . in the re.ne\u00adments from G with the actual variable being re.ned, thereby asserting in the \nantecedent that the program variable satis.es the base re.nement predicate. Thus, in the embedded formula, \nall occurrences of . refer to the two types that are being checked for subtyping. The embedding is conservative, \ni.e., the validity of the embedded implication implies the the standard, weaker, exact requirement for \nsubtypingof re.ned types [10, 22].Forexample, for the then expression in max from Section 2, the subtyping \nre\u00adlation: x :int; y : int; x > y f{. = x} <: {x = . . y = .}holds as the following implication is valid \nin EUFA: ((true . true . x > y) . (. = x)) . (x = . . y = .) 3. Recursion via Polymorphism. To handle \npolymorphism, our type system incorporates type generalization and instantiation an\u00adnotations, which \nare over ML type variables a and monomor\u00adphic ML types t , respectively, and thus can be reconstructed \nvia a standard type inference algorithm. The rule [LT-INST]allows a type schema to be instantiated with \nan arbitrary liquid type T of the same shape as t , the monomorphic ML type used for instantiation. \nWe use polymorphism to encode recursion via the polymorphic type given to fix. That is, let rec bindings \nare syntactic sugar: letrecf= eine is internally converted to let f= fix (fun f->e) ine . The expression \ntype\u00adchecks if there is an appropriate liquid type that can be instantiated for the a in the polymorphic \ntype of fix;this liquid type corre\u00adsponds to the type of the recursive function f. 4. The LiquidType \nRestriction. The most critical difference be\u00adtween the rules for liquid type checking and other dependent \nsys\u00adtemsis that our rules stipulate that certain kindsofexpressionshave liquid types.In essence, theseexpressions \nare thekeypoints where appropriate dependent types must be inferred. By forcing the types to be liquid, \nwe bound the space of possible solutions, thus making inference ef.ciently decidable. [LT-INST]For polymorphic \ninstantiation, also the mechanism for handling recursion, the liquid type restriction enables ef.cient \nin\u00adference by making the set of candidate dependent types .nite. [LT-FUN]For .-abstractions, we impose \nthe restriction that the input and output be liquid to ensure the types remain small, thereby making \nalgorithmic checking and inference ef.cient. This is anal\u00adogous to procedure summarization for .rst-order \nprograms. [LT-IF]For conditional expressions we impose the liquid restric\u00adtion and implicitly force the \nthen and else expressions to be sub\u00adtypesofa fresh liquid type, insteadofanexplicit join operatoras in \ndata.ow analysis.Wedosoastheexpressionmayhavea func\u00adtion type and with a join operator, input type contravariance \nwould introduce disjunctions into the dependent type which would have unpleasant algorithmic consequences. \n[LT-LET]For let-in expressions we impose the liquid restriction as a means of eliminating the locally \nbound variable from the de\u00adpendent type of the whole expression (as the local variable goes out of scope). \nThe antecedent G f T requires that the liquid type be well-formed in the outer environment, which, together \nwith the condition, enforcedviaalpha renaming,thateachvariableis bound only once in the environment, \nis essential for ensuring the sound\u00adnessofoursystem[24].The alternativeofexistentially quantifying the \nlocal variable [18] makes algorithmic checking hard. LiquidType Checking G fQ e : S G fQ e : S1 G f \nS1 <: S2 G f S2 [LT-SUB] G fQ e : S2 G(x)= {. : B | e} G(x) not a base type [LT-VAR] [LT-VAR] G fQ x \n: {. : B | . = x} G fQ x : G(x) [LT-CONST] G fQ c : ty(c) G; x : T x fQ e : T G f x : T x.T [LT-FUN] \nG fQ .x.e :(x : T x.T ) G fQ e1 :(x :Tx.T )G fQ e2 : Tx [LT-APP] G fQ e1 e2 :[e2/x]T G fQ e1 : bool \nG; e1 fQ e2 : T G; \u00ace1 fQ e3 : T G f T [LT-IF] G fQ if e1 then e2 else e3 : T G fQ e1 : S1 G; x : S1 \nfQ e2 : T G f T [LT-LET] G fQ let x = e1 in e2 : T G fQ e : Sa not free in G [LT-GEN] G fQ [.a]e : .a.S \nG fQ e : .a.S G f T Shape(T ) = t [LT-INST] G fQ [t ]e :[ T /a]S Decidable Subtyping G f S1 <: S2 Valid([[G] \n. [ e1] . [ e2] ) [DEC-<:-BASE] G f{. : B | e1} <: {. : B | e2} ' '' G f Tx <: Tx G; x : Tx f T<: T [DEC-<:-FUN] \nG f x :Tx.T<: x: Tx' .T ' G f S1 <: S2 [<:-VAR] [<:-POLY] G f a<: a G f.a.S1 <: .a.S2 Well-FormedTypes \nG f S G; . : B f e : bool [WT-BASE] [WT-VAR] G f{. : B | e} G f a G; x: Tx f T G f S [WT-FUN] [WT-POLY] \nG f x:Tx.T G f.a.S Figure3. Rulesfor LiquidType Checking 5. Placeholder Variables and a-Renaming. We \nuse the place\u00adholder variables * instead of hard-coded program variables to make our type system robust \nto a-renaming. If Q is {x<.}, then \u00d8fQ (.x.x +1) : x : int.{x<.} isavalid judgment,but \u00d8fQ (.y.y +1) \n: y : int.{y<.} is not, as y<. is not in Q* . If instead Q is {*<.}, then Q* includes {x < .,y < .} and \nso both of the above are valid judgments. In general, our type system is robust to renaming in the following \nsense: if G fQ e1 : S1 and e1 is a-equivalent to e2 and the free variables of Q are bound1 in G, then \nfor some S2 that is a-equivalent to S1, we have G fQ e2 : S2. 1Recall that variables are bound at most \nonce in anyenvironment 4. LiquidType Inference We now turn to the heart of our system: the algorithmInfer \n(shown in Figure4) that takes as inputa type environment G, anexpression e, and a .nite set of logical \nquali.ers Q and determines whether e is well-typed over Q, i.e., whether there exists some S such that \nG fQ e : S. Our algorithm proceeds in three steps. First, we ob\u00adserve that the dependent type for any \nexpression must be a re.ne\u00adment of its ML type, and so we invoke Hindley-Milner (HM) to infer the types \nof subexpressions, and use the ML types to gen\u00aderate templates representing the unknown dependent types \nfor the subexpressions (Section 4.1). Second, we use the syntax-directed liquid typing rules from Figure3 \ntobuilda systemof constraints that capture the subtyping relationships between the templates that must \nhold for a liquid type derivation to exist (Section 4.2). Third, we use Q to solve the constraints using \na technique inspired by predicate abstraction (Section 4.3). 4.1 MLTypes andTemplates Our type inference \nalgorithm is based on the observation that the liquid type derivations are re.nements of the ML type \nderivations, and hence the dependent types for all subexpressions are re.ne\u00adments of their ML types. \nML Type Inference Oracle. Let HM be an ML type inference oracle, which takes an ML type environment G \nand an expres\u00adsion e and returns the ML type (schema) s if and only if, us\u00ading the classical ML type \nderivation rules [7], there exists a derivation G f e : s. The liquid type derivation rules are re.ne\u00adments \nof the ML type derivation rules. That is, if G fQ e : S then HM(Shape(G),e)= Shape(S). Moreover, we assume \nthat the ML type derivation oracle has inserted suitable type gen\u00aderalization([.a]e)and instantiation([t \n]e)annotations. Thus, the problem of dependent type inference reduces to inferring appropri\u00adate re.nements \nof the ML types. Templates. Let Kbeasetof liquid type variables used to represent unknown type re.nement \npredicates.A template F is a dependent type schema described via the grammar shown below, where some \nof the re.nement predicates are replaced with liquid type variables with pending substitutions.A template \nenvironment isa map G from variables to templates. . ::= E | [e/x]; . (Pending Substitutions) F ::= S(E \n. . \u00b7 K) (Templates) Variables with Pending Substitutions. A sequence of pending substitutions . is de.ned \nusing the grammar above.To understand the need for ., consider rule[LT-APP]from Figure3which speci\u00ad .es \nthat the dependent typeofa function applicationis obtainedby substituting all occurrences of the formal \nargument x in the output type of e1 with the actualexpression e2 passed in at the application. When generating \nthe constraints, the output type of e1 is unknown and is represented by a template containing liquid \ntype variables. Suppose that the type of e1 is x: B.{. :B | .}, where . is a liq\u00aduid type variable. In \nthis case, we will assign the application e1 e2 the type {. : B | [e2/x] \u00b7 .}, where [e2/x] \u00b7 . is a \nvariable with a pending substitution [18]. Note that substitution can be pushed in\u00ad side type constructors, \ne.g., . \u00b7 ({.1}.{.2}) is the same as {. \u00b7 .1}.{. \u00b7 .2} and so it suf.ces to apply the pending substi\u00adtutions \nonly to the root of the template.  4.2 Constraint Generation Wenowdescribehowour algorithm generates \nconstraintsovertem\u00adplatesbytraversingtheexpressioninthe syntax-directed mannerof a type checker, generating \nfresh templates for unknown types, con\u00adstraints that capture the relationships between the types of various \nsubexpressions, and well-formedness requirements. The generated constraints are such that theyhave a \nsolution if and only if the ex\u00adpression hasavalid liquid type derivation. Our inference algorithm uses \ntwo kinds of constraints over templates. Well-formedness constraints of the form G f F , where G is template \nenvironment, and F is a template, ensure that the types inferred for each subex\u00adpression are over program \nvariables that are in scope at that subex\u00adpression. Subtyping constraints of the form G f F1 <: F2 where \nG is a template environment and F1 and F2 are two templates of the same shape, ensure that the types \ninferred for each subexpres\u00adsion can be combined using appropriate subsumption relationships to yield \na valid type derivation. Our constraint generation algorithm, Cons, shown in Figure 4, takes as input \na template environment G and an expression e that we wish to infer the type of and returns as output \na pair of a type template F , which corresponds to the unknown type of e, and a set of constraints C. \nIntuitively, Cons mirrors the type derivation rules and generates constraints C which captureexactly \nthe relationships that must hold between the templates of the subexpressions in order for e to have a \nvalid type derivation over Q. To understand how Cons works, notice that the expressions of .L can be \nsplit into two classes: those whose types are constructable from the environment and the types of subexpressions, \nand those whose types are not. 1. Expressions with ConstructableTypes. The .rst class of ex\u00adpressions \nare variables, constants, function applications and poly\u00admorphic generalizations, whose types can be \nimmediately con\u00adstructed from the types of subexpressions or the environment.For such expressions, Cons \nrecursively computes templates and con\u00adstraints for the subexpressions and appropriately combines them \nto form the template and constraints for the expression. As anexample, consider Cons(G,e1 e2). First, \nCons is called to obtain the templates and constraints for the subexpressions e1 and e2. If a valid ML \ntype derivation exists, then e1 must be a function type with some formal x. The returned template is \nthe result of pushing the pending substitution of x with the actual argument e2 into the leaves of the \ntemplate corresponding to the return type of e1. The returned constraints are the unionofthe constraints \nfor the subexpressions anda subtyping constraint ensuring that the typeof the argument e2 is a subtype \nof the input type of e1. 2. Expressions with LiquidTypes. The second class are expres\u00adsions whose types \ncannot be derived as above, as the subsumption rule is required to perform some kind of over-approximation \nof their concrete semantics. These include .-abstractions,if-then-else expressions, let-bindings, and \npolymorphic instantiations (which includes recursive functions).We use two observations to infer the \ntypes of these expressions. First, the shape of the dependent type is the same as the ML type of the \nexpression. Second, from the liquid type restriction, we know that the re.nement predicates for theseexpressions \nare conjunctionsof logical quali.ers from Q* (cf. rules[LT-LET],[LT-FUN],[LT-IF],[LT-INST]of Figure3). \nThus, to infer the types of these expressions, we invoke HM to determine the ML type of the expression \nand then use Fresh to generate a template with the same shape as theML typebut with fresh liquid type \nvariables representing the unknown re.nements.  As an example, consider Cons(G, if e1 then e2 else e3). \nFirst,afresh templateis generatedusingtheMLtypeoftheexpres\u00adsion. Next, Cons recursively generates templates \nand constraints for the then and else subexpressions. Note that for the then (resp. else)subexpression, \nthe environment is extended withe1 (resp. \u00ace1)as in the type derivation rule ([LT-IF]from Figure 3). \nThe fresh template is returned as the template for the whole expression. The constraints returned are \nthe union of those for the subexpres\u00adsions,awell-formedness constraint for the wholeexpression stem\u00adplate, \nand subtyping constraints forcing the templates for the then and else subexpressions to be subtypes of \nthe whole expression s template Example: Constraints. The well-formedness constraint \u00d8f x : .x .y : .y \n..1 is generated for the fresh template for max (from Figure 1). The constraint ensures that the inferred \ntype for max only contains program variables that are in scope at the point where max is bound. The if \nexpression that is the body of max is anexpression with liquid type.For thisexpression,a fresh template \n.1. is generated, and the subtyping constraints: x : .x ; y :.y ;(x > y) f{. = x} <: .1. x : .x ; y :.y \n; \u00ac(x > y) f{. = y} <: .1. x :.x ; y : .y f .1. <: .1 are generated, capturing the relationships between \nthe then and the if expression, the else and the if expression, and the if and the output expression, \nrespectively. The constraints (1.1) and (1.2) are the above constraints simpli.ed for exposition. The \nrecursive application sum (k-1) from Figure 1 is an expression with a constructable type. For this expression \nthe subtyping constraint (2.2) is generated, forcing the actual to be a subtype of the formal. The output \nof the application, i.e., the output type .2 of sum, with the pending substitution of the formal k with \nthe actual(k - 1)is shown bound to s in (2.3).  4.3 Constraint Solving Next, we describe our two-step \nalgorithm for solving the con\u00adstraints, i.e., assigning liquid types to all variables . such that all \nconstraints are satis.ed. In the .rst step, we use the well\u00adformedness and subtyping rules to split the \ncomplex constraints, which may contain function types, into simple constraints over variables with pending \nsubstitutions. In the second step, we iter\u00adatively weaken a trivial assignment, in which each liquid \ntype vari\u00adable is assigned the conjunction of all logical quali.ers, until we .nd the least .xpoint solution \nfor all the simpli.ed constraints or determine that the constraints have no solution.We .rst formalize \nthe notion of a solution and then describe the two-step algorithm that computes solutions. Satisfying \nLiquid Assignments. ALiquid Assignment over Q is a map A from liquid type variables to sets of quali.ers \nfrom Q* . Assignments can be lifted to maps from templates F to dependent types A(F ) and template environments \nG to environments A(G), V by substituting each liquid type variable . with A(.) and then applying the \npending substitutions. A satis.es a constraint c if A(c) is valid. That is, A satis.es a well-formedness \nconstraint G f F if A(G) f A(F ), and a subtyping constraint G f F1 <: F2 if A(G) f A(F1) <: A(F2). A \nis a solution fora setof constraints C if it satis.es each constraint in C. Step 1: Splitting into Simple \nConstraints. First, we call Split, which uses the rules for well-formedness and subtyping (Figure 3) \nto convert all the constraints over complex types(i.e., function types) into simple constraints over \nbase types. An assignment is a solution for C if and only if it is a solution for Split(C). Example: \nSplitting. The well-formedness constraint \u00d8f x : .x .y : .y ..1 splits into the three simple constraints: \n\u00d8f .x , x :.x f .y and x :.x ; y :.y f .1, which ensure that: the parameter x must have a re.nement over \nonly constants and the value variable . as the environment is empty; the parameter y must have a re.nement \nover only x and .; and the output type s re.nement can refer to both parameters x, y and the value variable. \nThe function subtyping constraint generated by the call foldn (len a) 0 am shown in (4.4) splits into \nthe simple subtyping constraints (4.6),(4.7),(4.8). Notice how substitution and contravariance combine \nto cause the .ow of the bounds information into input parameter .l (4.6) thus allowing the system to \nstatically check the array access. Step 2: Iterative Weakening. Due to the well-formedness con\u00adstraints, \nanysolution over Q mustmapthe liquidtypevariablesto sets of quali.ers whose free variables are either \nthe value variable . or the variables in the input environment G (written Var(G)), or thevariablesinthe \ninputexpression e (written Var(e)).That is, any solution maps the liquid variables to a set of quali.ers \ncontained in Inst(G, e, Q) which is de.ned as {q | q . Q* and FreeVar(q) .{.}. Var(G) . Var(e)} where \nVar(G) and Var(e) are the set of variables in G and e respectively. Notice that if Q is .nite, then Inst(G, \ne, Q) is also .nite as the placeholder variables can only be instantiated with .nitely manyvariables \nfrom G and e. Thus, to solvethe constraints, we call the procedure Solve, shown in Figure 4, with the \nsplit constraints and a trivial initial assignment that maps each liquid type variable to Inst(G, e, \nQ). Solve repeatedly picks a constraint that is not satis.ed by the current assignment and calls Weaken \nto remove the quali.ers that prevent the constraint from being satis.ed. For unsatis.ed con\u00adstraints \nof the form: (1) G f{. :B | . \u00b7 .}, Weaken removes from the assignment for . all the quali.ers q such \nthat the ML type of . \u00b7 q (the result of applying the pending substitutions . to q) cannot be derived \nto be bool in the environment Shape(G); . : B, (2) G f{. : B | .} <: {. : B | . \u00b7 .}, where . is either \na re.ne\u00adment predicate or a liquid variable with pending substitutions, Weaken removes from the assignment \nfor . all the logical qual\u00adi.ers q such that the implication ([[A(G)]] . [ A(.)]]) . . \u00b7 q is not valid \nin EUFA, (3) G f{. : B | .} <: {. : B | e}, Weaken, and therefore Solve, returns Failure. Correctness \nof Solve. For two assignmentsA and A ', we saythat A = A ' if for all ., the set of logical quali.ers \nA(.) contains the set of logical quali.ers A ' (.).We can prove that if a set of con\u00adstraints hasasolutionover \nQthenit hasaunique minimum solution w.r.t. =. Intuitively, we invoke Solve with the least possible assign\u00adment \nthat maps eachliquidvariable to all the possible quali.ers. Solve then uses Weaken to iteratively weaken \nthe assignment until the unique minimum solution is found. The correctness of Solve follows from the \nfollowing invariant about the iterative weakening: if A * is the minimum solution for the constraints, \nthen in each itera\u00adtion, the assignment A = A *. Thus, if Solve returnsasolution then it must be the \nminimum solution for C over Q. If at some point a constraint G f{. : B | .} <: {. : B | e} is unsatis.ed, \nsubsequent weakening cannot make it satis.ed. Thus, if Solve returns Failure then C has no solution over \nQ. By combining the steps of constraint generation, splitting and solving, we obtain our dependent type \ninference algorithm Infer shown in Figure 4. The algorithm takes as input an environment G, an expression \ne and a .nite set of logical quali.ers Q, and determines whether there exists a valid liquid type derivation \nover Q for e in the environment G. The correctness properties of Infer are stated in the theorem below, \nwhose proof is in [24]. From Theorems 1, 2, we conclude that if Infer(\u00d8, e, Q)= S then every primitive \noperation invoked during the evaluation of e succeeds. THEOREM 2. [LiquidType Inference] 1. Infer(G, \ne, Q) terminates, 2. If Infer(G, e, Q)= S then G fQ e : S, and, 3. If Infer(G, e, Q)= Failurethen there \nis no S s.t. G fQ e : S.  RunningTime. Most of the time taken by Infer goes inside proce\u00addure Solve \nwhich asymptotically dominates the time taken to gen\u00aderate constraints. Solve returns the same output \nregardless of the orderin which the constraints are processed.Foref.ciency, we im\u00adplement Solve in two \nphases. First, Solve makesa (linear) pass that solves the well-formedness constraints, thus rapidly pruning \naway irrelevant quali.ers. Second, Solve uses a standard worklist-based algorithm that solves the subtyping \nconstraints. The time taken in the .rst phaseis asymptotically dominatedby the time takenin the second. \nLet Q be the maximum number of quali.ers that anyliq\u00aduid variable is mapped to after the .rst well-formedness \npass, V be the number of variables in the program e that have a base type, and D be the size of the ML \ntype derivation for e in the environment G.Aconstraint is sent to Weaken only when the antecedent of \nits implication changes, i.e., at most V \u00d7 Q times. There are at most O(D) constraints and so Weaken \nis called at most O(D \u00d7 V \u00d7 Q) times. Each call to Weaken makes at most Q calls to the theorem prover. \nThus, in all the running time of Infer is O(D \u00d7 V \u00d7 Q2) assuming each theorem prover call takes unit \ntime. Of course, D can be exponential in the program size (but tends to be linear in practice), and the \nsize of each (embedded) theorem prover query is O(V \u00d7Q). Thoughvalidity checkinginEUFAis NP-Hard,several \nsolvers for this theory exist which are very ef.cient for the simple queries that arise in our context \n[9]. 4.4 Featuresof LiquidType Inference We now discuss some features of the inference algorithm. 1.TypeVariables \nandPolymorphism. There are two kinds of typevariables used during inference:ML typevariables a obtained \nfrom theML types returnedby HM, and liquid type variables . in\u00adtroduced during liquid constraint generation \nto stand for unknown liquid types. Our system is monomorphic in the liquid type vari\u00adables. PolymorphismonlyentersviatheMLtypevariablesasfresh \nliquid typevariables are created at each point where anML type variable a is instantiated with a monomorphic \nML type. 2. Whole Program Analysis and Non-General Types. Due to the above, the types we obtain for function \ninputs are the strongest liquid supertype of all the arguments passed into the function. This is in contrast \nwith ML type inference which infers the most general type of the function independent of how the function \nis used. For example, consider the func\u00adtion neg de.ned as fun x -> (-x), and suppose that Q = {0 = ., \n0 = .}. In a program comprising only the above func\u00adtion i.e., where the function is never passed arguments, \nour al\u00adgorithm infers neg :: {0 = . . 0 = .}.{0 = . . 0 = .} which is useless but sound. If neg is only \ncalled with (provably) non-negative (resp. non-positive) arguments, the algorithm in\u00adfers neg :: {0 = \n.}.{0 = .} (resp. neg :: {0 = .}.{0 = .}) If neg is called with arbitrary arguments, the algorithm infers \nneg :: int.int and not a more general intersection of function types.We found this design choice greatly \nsimpli.ed the inference procedurebyavoiding theexpensive case splits on all possible in\u00adputs [14] while \nstill allowing us to prove the safety of challenging benchmarks. Moreover, we can represent the intersection \ntype in our system as: x : int.{(0 = x . 0 = .) . (0 = x . 0 = .)}, and so, if needed, we can recover \nthe precision of intersection types by using quali.ers containing implications. 3. A-Normalization. \nRecall the sum example from Section 2. Our system as described would fail to infer that the output type \nof:  letrecsumk= ifk<0 then0else(s+ sum(k-1)) was non-negative, as it cannot use the fact that sum (k-1) \nis non-negative when inferring the type of the else expression. This is solved by A-Normalizing[12] the \nprogram so that intermediate subexpressions are bound to temporary variables, thus allowing us to use \ninformation about types ofintermediate expressions, as in the original sum implementation. 5. Experimental \nResults We now describe our implementation of liquid type inference in the toolDSOLVEwhich does liquid \ntype inference forOCAML.We Cons(G,e)= match e with | x -. if HM(Shape(G),e)= B then ({. :B | . = x}, \n\u00d8) else (G(x), \u00d8) | c -. (ty(c), \u00d8) | e1 e2 -. let (x:Fx . F, C1)= Cons(G,e1) in ' let (F ,C2)= Cons(G,e2) \nin x ' ([e2/x]F, C1 . C2 .{G f F<: Fx}) x | .x.e -. let (x:Fx . F )= Fresh(HM(Shape(G), .x.e)) in let \n(F ' ,C)= Cons(G; x:Fx,e) in ' (x:Fx . F, C .{G f x:Fx . F }.{G; x:Fx f F<: F }) | if e1 then e2 else \ne3 -. let F = Fresh(HM(Shape(G),e)) in let ( ,C1)= Cons(G,e1) in let (F2,C2)= Cons(G; e1,e2) in let (F3,C3)= \nCons(G; \u00ace1,e3) in (F, C1 . C2 . C3 .{G f F }. {G; e1 f F2 <: F }.{G; \u00ace1 f F3 <: F }) | let x = e1 \nin e2 -. let F = Fresh(HM(Shape(G),e)) in let (F1,C1)= Cons(G,e1) in let (F2,C2)= Cons(G; x:F1,e2) in \n(F, C1 . C2 .{G f F }.{G; x:F1 f F2 <: F }) | [.a]e -. let (F, C)= Cons(G,e) in (.a.F, C) | [t]e -. \nlet F = Fresh(t) in let (.a.F ' ,C)= Cons(G,e) in ([F/a]F ' ,C .{G f F }) Weaken(c, A)= match c with \n| G f{. :B | . \u00b7 .} -. A[. .{q | q . A(.) and Shape(G); . :B f . \u00b7 q : bool}] | G f{. :B | .} <: {. \n:B | . \u00b7 .} -. A[. .{q | q . A(.) and [ A(G)]] . [ A(.)]] . [ . \u00b7 q] }] | -. Failure Solve(C, A)= if \nexists c . C such that A(c) is not valid then Solve(C, Weaken(c, A)) else A Infer(G, e, Q)= let (F, \nC)= Cons(G,e) in let A = Solve(Split(C), ...Inst(G, e, Q)) in A(F ) Figure4. LiquidType Inference Algorithm \n describe experiments which demonstrate, over a set of benchmarks thatwerepreviously annotatedintheDMLproject[27],thatliquid \ntypes greatly reduce theburden of manual dependent type annota\u00adtion required to prove the safety of array \naccesses. DSOLVE takes as input a closed OCAML program and a set of quali.ers Q, and outputs the dependent \ntypes inferred for the pro\u00adgramexpressionsandthesetof applicationsofprimitiveoperations that could not \nstaticallybeproven safe (ideally empty).DSOLVEis builtontopofOCAML:DSOLVE usestheOCAML parserandtype \ninference engine (to implement the oracle HM), and outputs the inferred dependent types in .annot .les \nas documentation. Array Bounds Checking Quali.ers. To automate array bounds checking, we observe that \nthe safety of array accesses typically de\u00adpends on the relative ordering of integer expressions. Thus, \nto stat\u00adically prove the safety of array accesses, we use the mechanically\u00adgenerated set of array bounds \nchecking quali.ers QBC de.ned as {.M X | M .{<, =, =, =, >, =} and X .{0, *, len *}} Next, we showexperimental \nresults demonstratingthat liquid type inference over QBC suf.ces to prove the safety of most array ac\u00adcesses. \nEven when DSOLVE needs extra quali.ers, the types in\u00adferred using QBC help the programmer quickly identify \nthe rele\u00advant extra quali.ers. Benchmarks. We use benchmarks from the DML project [26] (ported toOCAML)that \nwere previously annotated with dependent types with the goal of statically proving the safety of array \naccesses [27]. The benchmarks are listed in the .rst column of Table 1. The second column indicates the \nsize of the benchmark (ignoring comments and whitespace). The benchmarks include O CAML im\u00adplementations \nof: the Simplex algorithm for Linear Programming (simplex), theFastFourierTransform(fft), Gaussian Elimina\u00adtion(gauss), \nMatrix Multiplication(matmult), Binary Searchina sorted array(bsearch), computing the Dot Product of \ntwo vectors (dotprod), Insertion sort(isort), the n-Queens problem(queen), theTowers of Hanoi problem(tower), \na fast byte copy routine (bcopy), and Heap sort(heapsort). The above include allDML array benchmarks \nexcept quicksort, whose invariants remain un\u00adclear to us. In addition, we ran DSOLVE on a simpli.ed Quicksort \nroutine fromO CAML s Sort module(qsort-o), a version ported from theDML benchmark(qsort-d)where one optimization \nis removed, andBITV, an open source bitvector library(bitv). Array Bounds Checking Results. As shown \nin column DSOLVE of Table 1, DSOLVE needs no manual annotations for most pro\u00adgrams: that is, the quali.ers \nQBC suf.ce to automatically prove the safety of all array accesses. For some of the examples, e.g., tower, \nwe do need to provide extra quali.ers. However, even in this case,the annotationburdenis typicallyjustafew \nquali.ers. For example, intower, we require a quali.er which is analogous to . = n -h1 -h2,which describes \nthe height of the third tower, capturing the invariant that the height is the total number of rings n \nminus the rings in the .rst two towers. Similarly, in bitv, one quali.er statesthekeyinvariant relatingabitvector \ns lengthtothe length of its underlying data structure. The time for inference is ro\u00adbust to the number \nof quali.ers as most quali.ers are pruned away by the well-formedness constraints. In our prototype implementa\u00adtion, \nthe time taken for inference is reasonable even for non-trivial benchmarks like simplex, fft and gauss. \nCase Study: BitVectors. We applied DSOLVE to verify the open source BITV bit vector library (version \n0.6). A bit vector in BITV consists of a record with two .elds: length, the num\u00adber of bits stored, and \nbits, the actual data. If b is the number of bits stored per array element, length and bits are related \nby (len bits - 1) \u00b7 b< length = (len bits) \u00b7 b. The executed code, and hence, dependent types are different \nfor 32-and 64-bit machines. Thus, to verify the code using our conjunctive types, we .xed theword size \nto 32.We were able toverify the array safety of 58 of BITV s 65 bit vector creation, manipulation, and \niteration functions, which contain a total of 30 array access operations. There are three kinds of manual \nannotation needed for veri.ca\u00adtion: extraquali.ers(14 lines, 605 characters), trusted assumptions (8 \nlines, 143 characters), and interface speci.cations (43 lines, 2390 characters). The trusted assumptions \n(which are akin to dy\u00adnamic checks) are needed due to current limitations of our system. These include \nthe conservative way in which modular arithmetic is embeddedintoEUFA,thelackof re.nementsfortypevariablesand \nrecursive datatypes, and the conservative handling of control-.ow. The interface speci.cations are needed \nbecause BITV is a library, i.e., anopen program.Thus,forveri.cation,weneedtospecifythat Table 1. Experimental \nResults: Size is the amount of program text (without annotation) after removing whitespace and comments \nfrom the code. DML is the amount of manual annotation required in the DML versions of the benchmarks. \nDSOLVE is the amount of manual annotation required by DSOLVE, i.e., quali.ers not in QBC . Timeis the \ntime takenbyDSOLVEto infer dependent types. Size DML DSOLVE Program Line Char Line Char Line Char Time \n(s) dotprod 7 158 3(30%) 110 (41%) 0(0%) 0(0%) 0.31 bcopy 8 199 3(27%) 172 (46%) 0(0%) 0(0%) 0.15 bsearch \n24 486 3(11%) 157 (24%) 0(0%) 0(0%) 0.46 queen 30 886 7(19%) 309 (26%) 0(0%) 0(0%) 0.70 isort 33 899 \n12 (27%) 702 (44%) 0(0%) 0(0%) 0.88 tower 36 927 8(18%) 348 (27%) 1(2%) 26 (2%) 3.33 matmult 43 797 10 \n(19%) 454 (36%) 0(0%) 0(0%) 1.79 heapsort 84 1414 11 (12%) 433 (23%) 0(0%) 0(0%) 0.53 fft 107 3279 13 \n(11%) 790 (19%) 1(1%) 25 (1%) 9.13 simplex 118 2712 33 (22%) 1913 (41%) 0(0%) 0(0%) 7.73 gauss 142 2431 \n22 (13%) 999 (29%) 1(1%) 67 (2%) 3.17 TOTAL 633 14188 125 (17%) 6387 (31%) 3(1%) 93(1%) qsort-o 62 1585 \n0(0%) 0(0%) 1.89 qsort-d 112 2735 5(5%) 63 (2%) 18.28 bitv 426 10757 65 (15%) 3138 (29%) 63.11  theAPIfunctionsare \ncalledwithvalidinputvectorsthatsatisfyin\u00advariants like the one described above. The interface speci.cations, \nbyfar the largest categoryof annotations, are unavoidable. Theex\u00adtra quali.ers andexpressiveness limitations \nare directions for future work. DSOLVE was able to locate a serious bounds checking error in BITV. The \nerror occurs in BITV s blit function, which copies c bits from v1,starting at bitoffset1,tov2,starting \nat bitoffset2. This function .rst checks that the arguments passed are safe, and then callsafastbut unsafe \ninternal function unsafe blit. let blit v1 offset1 v2 offset2 c = if c < 0 || offset1 < 0 || offset1 \n+ c > v1.length offset2 < 0 || offset2 + c > v2.length then invalid_arg \"Bitv.blit\"; unsafe_blit v1.bits \noffset1 v2.bits offset2 c unsafe blit immediately accesses the bit at offset1 in v1, re\u00adgardless of \nthe value of c. When the parameters are such that: offset1 = v1.length and v1.length mod b =0 and c =0, \nthe unsafe blit attempts to access the bit at index v1.length, which must be located in v1.bits[v1.length \n/ b];but this is v1.bits[len v1.bits], which is out of bounds and can cause a crash, as we veri.ed with \na simple input. The problem is that blit doesnotverifythatthe startingoffsetis withinthe boundsofthebit \nvectors. This is .xed by adding the test offset1 >= v1.length (and offset2 >= v2.length for similar reasons). \nDSOLVE suc\u00adcessfully typechecks the .xed version. 6. RelatedWork The .rst component of our approach is \npredicate abstraction, [1, 15] which has its roots in early work on axiomatic semantics [8]. Predicate \nabstraction has proven effective for path-sensitive veri.cation of control-dominated properties of .rst-order \nimpera\u00adtive programs [3, 16, 11, 4, 29, 17]. The second component of our approach is constraint-based \npro\u00adgram analysis, an example of which is the ML type inference algorithm. Unlike other investigations \nof type inference for HM with subtyping, e.g., [19, 23, 25], our goal is algorithmic depen\u00ad dent type \ninference, which requires incorporating path-sensitivity and decision procedures for EUFA.We also draw \ninspiration from type quali.ers [13] that re.ne types witha latticeofbuilt-in and programmer-speci.ed \nannotations. Our Shape and Fresh functions are similar to strip and embed from [13]. Liquid types extend \nqual\u00ad i.ers by assigning them semantics via logical predicates, and our inference algorithm combines \nvalue .ow (via the subtyping con\u00adstraints) with information drawn from guards and assignments. The idea \nof assigning semantics to quali.ers has been proposed recently [5],but with the intentionof checking \nand inferring rules for qual\u00ad i.er derivations. Our approach is complementary in that the rules themselvesare.xed,butallowforthe \nuseofguardandvalue bind\u00ading information in type derivations, thereby yielding a more pow\u00aderful analysis.Forexample,itis \nunclear whether the approachof [5] would be able to prove the safety of any of our benchmark programs, \ndue to the inexpressivity of the quali.ers and inference rules.Ontheotherhand,our techniqueis more computationallyex\u00adpensive \nas the decision procedureis integrated with type inference. The notion of type re.nements was introduced \nin [14] with re.nements limited to restrictions on the structure of algebraic datatypes, for which inference \nis decidable. DML(C)[28] extends ML with dependent types over a constraint domain C;type check\u00ading is \nshown to be decidable modulo the decidability of the domain, but inference is still undecidable. Liquid \ntypes can be viewed as a controlled way to extend the language of types using simple pred\u00adicates over \na decidable logic, such that both checking and infer\u00adence remain decidable. Our notion of variables with \npending sub\u00adstitutions is inspired by a construct from [18], which presents a technique to reconstruct \nthe dependent type of an expression that captures its exact semantics (analogous to strongest postconditions \nfor imperative languages). The technique works in a restricted set\u00adting without polymorphism and the \nreconstructed types are terms containing existentially quanti.ed variables (due to variables that are \nnot in scope), and the fix operator (used to handle recursion), which make static reasoning impossible. \n7. Conclusions and FutureWork Inthispaper,wehavepresentedadependenttypesystem calledliq\u00aduid types, a \ntool DSOLVE that infers liquid types, and experiments showing that DSOLVE can signi.cantly reduce the \namount manual annotation required to statically prove the safety of array accesses. Even in very complex \nbenchmarks like BITV, DSOLVE needs 22 lines of manual hints, which is only 5% of the entire code size. \nThe other annotations, namely, types specifying correct usage of inter\u00adface functions, are unavoidable. \nThus, we believe that liquid types will prove useful even for modular veri.cation. If the modules are \ndesigned well, their interfaces shouldhavefarfewer functions than their implementationsandsothegainsfromnothavingto \nmanually specify the types of all top-level bindings will be signi.cant. Several challenges need to be \naddressed in order to realize the full potential of liquid types. First, we would like to make the system \nmore expressive, for example, by extending the system to allow re.nements for type variables and recursive \ndatatypes. This will allow us to apply liquid types to a larger class of programs and properties. Second, \nfor the cases when typechecking fails, we require error reporting techniques that help the programmer \ndetermine whether there is either an error in her program, the set of quali.ers is insuf.cient, or, the \nconservativeness of the system is to blame. One approach would be to devise a notion of type counterexample \nand adapt proof-based methods to check if the counterexample is feasible(i.e., there is an error) or \nif not, to lazily extract new quali.ers from the counterexample [6, 3, 16]. Third, we would like to extend \nthe system to include reasoning about imperative features.With suchanextension, liquid types couldbe \npro.tably applied to verify C++, Java and C# programs which use generic datatypes. Acknowledgments. We \nthank Adam Chlipala, Cormac Flana\u00adgan, RadhaJagadeesan, SureshJagannathan,Kenn Knowles, Sorin Lerner, \nBill McLoskey, Todd Millstein, Corneliu Popea, Philip Wadler, Westley Weimer, and the anonymous referees \nfor their helpful comments and suggestions for improving this paper. References [1] Tilak Agerwala and \nJayadev Misra. Assertion graphs for verifying and synthesizing programs.Technical Report83,UniversityofTexas, \nAustin, 1978. [2] L. Augustsson. Cayenne -a language with dependent types. In ICFP, 1998. [3]T. Ball \nand S.K.Rajamani. The SLAM project: debugging system software via static analysis. In POPL, pages 1 3.ACM, \n2002. [4] S. Chaki, E. M. Clarke, A. Groce, J. Ouaknine, O. Strichman, andK.Yorav. Ef.cient veri.cationof \nsequentialand concurrent c programs. FMSD, 25(2-3):129 166, 2004. [5] B. Chin, S. Markstrum,T. D. Millstein, \nand J.Palsberg. Inference of user-de.ned type quali.ers and quali.er rules. In ESOP, pages 264 278, 2006. \n[6] E. M. Clarke, O. Grumberg, S. Jha, Y. Lu, and H. Veith. Counterexample-guided abstraction re.nement. \nIn CAV, LNCS 1855, pages 154 169. Springer, 2000. [7] L. Damas and R. Milner. Principal type-schemes \nfor functional programs. In POPL, 1982. [8] E.W. Dijkstra. ADiscipline of Programming. Prentice-Hall, \n1976. [9] B. Dutertre and L. De Moura. Yices SMT solver. http://yices.csl.sri.com/.  [10] C. Flanagan. \nHybrid type checking. In POPL.ACM, 2006. [11] C. Flanagan and S. Qadeer. Predicate abstraction for software \nveri.cation. In POPL.ACM, 2002. [12]C.Flanagan,A.Sabry,B.F.Duba,andM. Felleisen.The essenceof compiling \nwith continuations. In PLDI, 1993. [13] J.S.Foster. Type Quali.ers: Lightweight Speci.cations to Improve \nSoftware Quality. PhD thesis, U.C. Berkeley, 2002. [14]T. Freeman andF. Pfenning. Re.nement types for \nML. In PLDI, 1991. [15] S. Graf and H. Sa\u00a8idi. Construction of abstract state graphs with PVS. In CAV, \nLNCS 1254, pages 72 83. Springer, 1997. [16] T.A. Henzinger, R. Jhala, R. Majumdar, and K.L. McMillan. \nAbstractions from proofs. In POPL 04.ACM, 2004. [17] F. Ivancic, I. Shlyakhter, A. Gupta, and M. K. Ganai. \nModel checking c programs using f-soft. In ICCD, pages 297 308, 2005. [18] K. Knowles and C. Flanagan. \nType reconstruction for general re.nement types. In ESOP, 2007. [19] P. Lincoln and J. C. Mitchell. Algorithmic \naspects of type inference with subtypes. In POPL, Albequerque, New Mexico, 1992. [20] P. Martin-Lof. \nConstructivemathematics and computer programming. Royal Society of London Philosophical Transactions \nSeries A, 312:501 518, October 1984. [21]G.Nelson. Techniquesfor programveri.cation. TechnicalReport \nCSL81-10, XeroxPalo Alto Research Center, 1981. [22]X.Ou,G.Tan,Y. Mandelbaum,andD.Walker. Dynamictypingwith \ndependent types. In IFIP TCS, pages 437 450, 2004. [23] F. Pottier. Simplifying subtyping constraints. \nIn ICFP, NewYork, NY, USA, 1996.ACM Press. [24] P. Rondon, M. Kawaguchi, and R. Jhala. Liquid types. \nTechnical Report CSETech Report, UCSD, 2008. [25] M. Sulzmann, M. Odersky, and M. Wehr. Type inference \nwith constrained types. In FOOL, 1997. [26] H. Xi. DML code examples. http://www.cs.bu.edu/fac/hwxi/DML/. \n[27]H.Xi andF. Pfenning. Eliminating array bound checking through dependent types. In PLDI, 1998. [28]H.XiandF. \nPfenning. Dependenttypesin practical programming.In POPL, pages 214 227, 1999. [29] Y. Xie and A. Aiken. \nScalable error detection using boolean satis.ability. In POPL, pages 351 363, 2005.  \n\t\t\t", "proc_id": "1375581", "abstract": "<p>We present <i>Logically Qualified Data Types</i>, abbreviated to <i>Liquid Types</i>, a system that combines <i>Hindley-Milner</i> type inference with <i>Predicate Abstraction</i> to automatically infer dependent types precise enough to prove a variety of safety properties. Liquid types allow programmers to reap many of the benefits of dependent types, namely static verification of critical properties and the elimination of expensive run-time checks, without the heavy price of manual annotation. We have implemented liquid type inference in DSOLVE, which takes as input an OCAML program and a set of logical qualifiers and infers dependent types for the expressions in the OCAML program. To demonstrate the utility of our approach, we describe experiments using DSOLVE to statically verify the safety of array accesses on a set of OCAML benchmarks that were previously annotated with dependent types as part of the DML project. We show that when used in conjunction with a fixed set of array bounds checking qualifiers, DSOLVE reduces the amount of manual annotation required for proving safety from 31% of program text to under 1%.</p>", "authors": [{"name": "Patrick M. Rondon", "author_profile_id": "81435603774", "affiliation": "University of California, San Diego, San Diego, CA, USA", "person_id": "P1022769", "email_address": "", "orcid_id": ""}, {"name": "Ming Kawaguci", "author_profile_id": "81351608495", "affiliation": "University of California, San Diego, San Diego, CA, USA", "person_id": "P1022770", "email_address": "", "orcid_id": ""}, {"name": "Ranjit Jhala", "author_profile_id": "81100198278", "affiliation": "University of California, San Diego, San Diego, CA, USA", "person_id": "P1022771", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1375581.1375602", "year": "2008", "article_id": "1375602", "conference": "PLDI", "title": "Liquid types", "url": "http://dl.acm.org/citation.cfm?id=1375602"}