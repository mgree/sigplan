{"article_publication_date": "06-07-2008", "fulltext": "\n Conditional Correlation Analysis for Safe Region-based Memory Management Xi Wang Zhilei Xu Xuezheng \nLiu Zhenyu Guo Xiaoge Wang Zheng Zhang Tsinghua University Microsoft Research Asia {v-xwa, v-zhixu, xueliu, \nzhenyug, zzhang}@microsoft.com wangxg@tsinghua.edu.cn Abstract Region-based memory management is a popular \nscheme in systems software for better organization and performance. In the scheme, a developer constructs \na hierarchy of regions of different lifetimes and allocates objects in regions. When the developer deletes \na region, the runtime will recursively delete all its subregions and simultaneously reclaim objects in \nthe regions. The developer must construct a consistent placement of objects in regions; otherwise, if \na region that contains pointers to other regions is not always deleted before pointees, an inconsistency \nwill surface and cause dangling pointers, which may lead to either crashes or leaks. This paper presents \na static analysis tool RegionWiz that can .nd such lifetime inconsistencies in large C programs using \nre\u00adgions. The tool is based on an analysis framework that general\u00adizes the relations and constraints \nover regions and objects as condi\u00adtional correlations. This framework allows a succinct formalization \nof consistency rules for region lifetimes, preserving memory safety and avoiding dangling pointers. RegionWiz \nuses these consistency rules to implement an ef.cient static analysis to compute the con\u00additional correlation \nand reason about region lifetime consistency; the analysis is based on a context-sensitive, .eld-sensitive \npointer analysis with heap cloning. Experiments with applying RegionWiz to six real-world soft\u00adware packages \n(including the RC compiler, Apache web server, and Subversion version control system) with two different \nregion\u00adbased memory management interfaces show that RegionWiz can reason about region lifetime consistency \nin large C programs. The experiments also show that RegionWiz can .nd several previously unknown inconsistency \nbugs in these packages. Categories and Subject Descriptors D.2.4 [Software Engineer\u00ading]: Software/Program \nVeri.cation Reliability; D.3.4 [Pro\u00adgramming Languages]: Processors Memory management; F.3.2 [Logics \nand Meanings of Programs]: Semantics of Programming Languages Program analysis General Terms Experimentation, \nReliability, Veri.cation Keywords region, conditional correlation, program analysis, error detection, \nmemory management Permission to make digital or hard copies of all or part of this work for personal \nor classroom use is granted without fee provided that copies are not made or distributed for pro.t or \ncommercial advantage and that copies bear this notice and the full citation on the .rst page. To copy \notherwise, to republish, to post on servers or to redistribute to lists, requires prior speci.c permission \nand/or a fee. PLDI 08 June 7 13, 2008, Tucson, Arizona, USA. Copyright c . 2008 ACM 978-1-59593-860-2/08/06. \n. . $5.00 1. Introduction Region-based memory management [21, 38, 6] is an alternative scheme to explicit \nallocation and deallocation (e.g., malloc and free) and automatic garbage collection [7, 41]. In this \nscheme, a developer constructs a hierarchy of regions (a.k.a. pools) of differ\u00adent lifetimes and allocates \nobjects in regions. Region lifetimes are nested; when the developer deletes a region, the memory manage\u00adment \nruntime will delete the region and its subregions recursively, deallocating all the contained objects. \nRegions expose a simpler interface than explicit allocation and deallocation to organize complex data \nstructures, since pro\u00adgrammers can delete sets of objects instead of only individual objects. It also \npreserves the safety of intra-region pointers and reduces the risk of leaks and double frees. On the \nother hand, com\u00adpared to garbage collection, it still enables .ne-grained control of the lifetimes of \nobjects via regions, which is usually required in performance-critical systems software such as operating \nsystems and servers. Furthermore, because the memory allocators of dif\u00adferent regions are usually independent \nof each other, developers can separate related objects into the same region to express data locality, \navoid lock contention, and batch allocation and deallo\u00adcation. Hence, programs using regions can often \nachieve better performance [16, 17]. In practice, regions are popular in software that operates in stages, \nsuch as compilers and network applications. A staged ap\u00adplication generally has an inherent hierarchical \nstructure; region\u00adbased memory management can match up with the structure via a region hierarchy for \nbetter organization and performance. For ex\u00adample, a web server maintains a group of TCP connections, \nand a TCP connection contains a series of HTTP requests. Thus, an HTTP request is a child of a TCP connection, \ni.e., the request has a shorter lifetime. A developer can assign a region to the con\u00adnection and a subregion \nto the request, then allocate resources used throughout the connection from the parent region and those \nused during processing the request only from the subregion. The devel\u00adoper can delete either the subregion \n(if the request has been pro\u00adcessed), or the parent region (if the connection is closed) so that the \nruntime can further delete the subregions of the requests and reclaim all memory easily. Figure 1 lists \nthe pseudo code snippet of the web server example above, with two region primitives: 1) rnew creates \na subregion of the given parent region, and 2) ralloc allocates a object in the given region. First, \nline 1 allocates a connection object conn in region r using ralloc. Later, line 3 creates a subregion \nsubr using rnew, taking r as its parent region. Then line 5 allocates a request object req in subr, and \nline 6 assigns .eld req.connection with a pointer to conn. We omit further details of the hierarchy (e.g., \nthe parent region and other subregions of r) for simplicity. The connection-request example involves \nthree relations: 1 conn = ralloc(r); 2 ... 3 subr = rnew(r);  Ownership Subregion 4 ... Access 5 \nreq = ralloc(subr); 6 req.connection = conn; Figure 1. The connection-request example. the subregion \nrelation over regions, speci.ed by calls to rnew, e.g., subr and r at line 3;  the ownership relation \nover regions and objects, speci.ed by calls to ralloc, e.g., r and conn at line 1, subr and req at line \n5;  the access relation over objects, implied by .eld assignments of inter-object pointers, e.g., req \nand conn at line 6.  The access relation requires that req should be reclaimed before conn to avoid \nthe pointer req.connection being dangling. Thus, combined with the ownership relation, a safety requirement \nis that the region subr that owns req should have a shorter lifetime than the region r that owns conn. \nMeanwhile, the developer speci.es the subregion relation that subr is a subregion of r,which is consistent \nwith the safety requirement. Otherwise, if subr is not always deleted before r, e.g., subr is not a subregion \nof r or even it is the parent of r, the pointer req.connection may be dangling. Therefore, the three \nrelations are correlated and they must be consistent; the speci.ed subregion relation and the access \nrelation implied by inter-object pointers constrain each other via the own\u00adership map over regions and \nobjects. We refer such correlation as conditional correlation, and develop a formalization of the consis\u00adtency \nproblem in Section 3. Dangling pointers caused by the inconsistencies can harm the correctness and robustness \nof software using regions. Intuitively, further use of the dangling pointers would lead to crashes. Fur\u00adthermore, \neven a dangling pointer is never used and the program does not crash, it may cause leaks as well. Consider \nthe example in Figure 1 again. The developer might not code subr as a subre\u00adgion of r, e.g., subr might \nbe a subregion of the root region that lives forever, or even r inappropriately takes subr as its parent \nregion. In such cases, the object req that resides in subr unnec\u00adessarily consumes memory even after \nconn is reclaimed, and the developer cannot use this memory any more. More seriously, such objects of \nlonger-than-necessary lifetime may lead to unpredictable memory consumption [5] especially if a function \nthat contains such buggy code resides in recursions or loops. Of course, there are no real leaks in region-based \nmemory management as de.ned in the malloc-free scheme, because the runtime will delete all regions eventually. \nIn this paper, we use the term leaks to refer to such longer-than-necessary lifetime cases. Unfortunately, \nit is dif.cult for developers to track such con\u00adsistency interprocedurally in large code base. For example, \nas in Figure 1, the code at line 5 and 6 may be in a function foo given a object conn and a region sub \nas parameters. Consequently, foo assumes that the caller must be careful about both allocating conn from \nan appropriate region and creating subr with a consistent par\u00adent region. However, the parameters for \nfoo may be passed deep along call paths, and the program points of allocating conn and creating subr \nmaybefar wayfrom foo. Thus, caller code may be unaware of the implicit constraint, or it may assume that \nfoo will keep a duplicated copy of the object referred by a parameter, which could be true especially \nwhen the object is a string. In ei\u00adther case, the code is prone to inconsistencies that may result in \ndangling pointers. Developers may discover inconsistencies that lead to crashes after they surface at \nruntime. It is harder to .nd such bugs in (a) r1= r2 (b) r2< r1 (c) unspecified (d) r1< r2 Figure 2. \nFour different subregion relations between r1 and r2. multi-threaded programs with regions, because the \ndeletion order of regions may vary due to scheduling and the bugs may not appear in each run. Several \ndynamic approaches have been proposed to preserve memory safety with regions at runtime [16, 17], but \nthey cannot .nd inconsistencies that are on less-executed code paths and that are sensitive to runtime \nenvironments such as scheduling, nor can they solve the leaks caused by inconsistencies. In this paper, \nwe focus on static analysis techniques and present a prototype tool RegionWiz that searches exhaustively \nfor region lifetime inconsistencies in source code. To the best of our knowl\u00adedge, it is the .rst tool \nto address the problem in large C programs using regions. Speci.cally, the main contributions of this \npaper are: 1) a uni.ed framework of conditional correlation that may be of independent interest; 2) a \nformalization of the region lifetime con\u00adsistency problem as an instantiation; 3) an implementation that \nem\u00adploys a context-sensitive, .eld-sensitive pointer analysis with heap cloning and that performs a conditional \ncorrelation analysis for the region lifetime consistency problem in large C programs; and, 4) the evaluation \nwith six real-world software packages of two region\u00adbased memory management interfaces. The rest of the \npaper is organized as follows. Section 2 gives an overview of the analysis methodology. Section 3 de.nes \nthe con\u00adcept of conditional correlation. Section 4 formalizes region lifetime consistency based on conditional \ncorrelation and describes a static analysis algorithm. Section 5 presents our implementation details. \nSection 6 reports our experimental results. We survey related work in Section 7 and conclude in Section \n8.  2. Overview In this section we present an overview of how RegionWiz reasons about region lifetime \nconsistency. For two regions r1,r2, we write r1 <r2 if r1 is a subregion of r2,and r1 = r2 if r1,r2 refers \nto the same region. Further, we write r1 = r2 if r1 is a direct or indirect subregion of r2, while r1 \n. r2 otherwise. The partial order = is the re.exive transitive closure of the subregion relation <over \nregions. Consider a simple case that o2 in region r2 holds a pointer to o1 in region r1. There are four \npossible subregion relations between r1 and r2 in caller code, as illustrated in Figure 2. (a) r1,r2 \nrefer to the same region, i.e., r1 = r2,so o1,o2 share the same lifetime, and the intra-region pointer \nis always safe.  (b) r2 is a subregion of r1, i.e., r2 <r1,so o2 will be deleted before o1, and the \ninter-region pointer is always safe. (c) There is no subregion relation between r1 and r2, i.e., r1 \n. r2 and r2 . r1, so the inter-region pointer may be dangling if r1 is deleted .rst.  (d) r1 is a subregion \nof r2, i.e., r1 <r2,so o1 will be deleted .rst, and the inter-region pointer will become dangling.  \nAs in Figure 2, r2 = r1 holds in (a) and (b), where the pointers from o2 to o1 are always safe. Meanwhile, \nthe pointers from o2 to o1 may be dangling in (c) and (d), where r2 . r1 and r1 may be deleted before \nr2. To sum up, we have the following rules for two objects o1,o2 in regions r1,r2, respectively. 1 o1 \n= ralloc(r1); 2 if P r = r0; 3 if Q r = r1; 4 r2 = rnew(r); 5 o2 = ralloc(r2); 6 o2.f = o1; Figure 3. \nAn aliasing example. Proposition 2.1. If o2 may access o1, r2 =r1 must hold. Proposition 2.2. If r2 =r1 \nholds, any pointer from o2 that may access o1 is always safe. With Proposition 2.1 one can reason about \nconsistency starting from objects. The relations of ownership and access combine to im\u00adply that r2 =r1 \nmust hold. However, the must-subregion require\u00adment may be hard to prove in the presence of aliasing. \nConsider a degradation case that o1, too, holds a pointer to o2, i.e., o1,o2 can access each other. To \npreserve memory safety, o1 and o2 under this circumstance must reside in the same region. In other words, \nit suf\u00ad.ces to show that the two variables r1 and r2 must always refer to the same region. This approach \nrequires a must-alias analysis [2], which is generally dif.cult to perform [33]. Nevertheless, we cannot \njust show that r2 = r1 may hold and conclude that region lifetime is consistent; the compromise is unsound \nand may lead to missing of inconsistencies. Consider the code in Figure 3, where r2 may be a subregion \nof r1 if condition Q evaluates true. However, the region lifetime in Figure 3 is not consistent because \nr2 = r1 does not always hold; r2 can be a subregion of r0 when P evaluates true and Q evaluates false. \nIn this case there is no subregion partial order between r2 and r1,so that the pointer o2.f may be dangling. \nRegionWiz takes the other approach to reason about consis\u00adtency by using Proposition 2.2. As stated, \nif r2 =r1 holds, we can conclude that any pointer from o2 to o1 is always safe. Thus, it suf.ces to show \nthat for any two regions x, y that have no subregion partial order x . y, each object in x must not access \nany object in y. By verifying the non-access property against region pairs that have no subregion partial \norder, we can prove that region lifetime is consistent. Take Figure 3 as example again. Note that we \nhave just dis\u00adcussed that r2 =r1 does not always hold. So the most conserva\u00adtive estimation of region \npairs that have no subregion partial order is the set {ri . rj |i =.j; i, j =0, 1, 2}. To verify them, \nwe can .nd that for r2 . r1, o2 in r2 may access o1 in r1, which violates Proposition 2.2 and is a potential \ninconsistency. To sum up, our tool RegionWiz reasons about region lifetime consistency in the following \nsteps: 1. start with region pairs that have no subregion partial order, 2. map regions to objects they \nown via the ownership relation, and 3. verify the non-access property against sets of objects.  In \nthe example above, the chosen of region pairs that have no subregion partial order may be too conservative: \nif r2 may bea subregion of more than one region due to aliasing, we have to verify its objects against \nthose in all its ancestors for a sound approximation, which may yield a large mount of false warnings. \nWe will discuss improvements in Section 4.3.  3. Conditional Correlation The region lifetime consistency \nproblem correlates the two sets, i.e., regions and objects, and involves three relations of subregion, \nownership, and access. We generalize the correlation between two sets of objects as follows. De.nition \n3.1 (Conditional Correlation). Let A, B be two sets with binary relations f : A \u00d7A, g : B \u00d7B, and map \n. : A .B.We de.ne a conditional correlation .f, ., g.over A, B as (x, y) .f =. (.(x),.(y)) .g (3.1) If \n.f, ., g.holds for (x, y), it means that (.(x),.(y)) .g can be proven under the assumption (x,y) .f.Inother \nwords, . is a relation-preserving map from A to B with respect to f and g. De.nition 3.2 (Consistent \nConditional Correlation). A condi\u00adtional correlation .f, ., g.is consistent over A, B if it holds for \nall (x, y) .A \u00d7A. Note that .f, ., g.always holds for (x, y) .(A \u00d7A)\\f,so it suf.ces to show that (3.1) \nholds for (x, y) . f to prove the consistency of the conditional correlation. We brie.y describe the \nregion lifetime consistency problem as an example of conditional correlation. Consider a set of regions \nR with the subregion relation, and a set of objects O where each object may access some other objects. \n A = R is the set of regions;  B =2O is the powerset of objects;  f is all region pairs (r1,r2) over \nA \u00d7A that r1 . r2 holds;  . maps a region to a set of objects that it owns;  g is all object set pairs \n(s1,s2) over B \u00d7B that each object in s1 cannot access any object in s2;  By de.nition, we can see that \nthe ownership relation . is a relation\u00adpreserving map with respect to f and g,and .f,., g.is a condi\u00adtional \ncorrelation for reasoning about region lifetime consistency. Now we consider how to perform a conditional \ncorrelation analysis statically. Intuitively, as for a sound approximation, if we prove a conditional \ncorrelation .F,F,G.is consistent, where F is a superset of f, F is a superset of .,and G is a subset \nof g, we can conclude that .f,., g.is also consistent. Hence, to perform a conditional correlation analysis, \nwe can estimate an over\u00adapproximation of f, ., and an under-approximation of g.More generally, we de.ne \nan abstraction relation .over conditional correlations. De.nition 3.3 (Conditional Correlation Analysis). \nGiven two con\u00additional correlations .f,., g.over A, B and .F,F,G.over A. ,B. , let a : A .A. , \u00df : B \n.B. be two maps. We de.ne .f, ., g.. .F, F,G.if the following conditions are satis.ed. .(x, y) .A \u00d7A \n:(x, y) .f =. (a(x),a(y)) .F (3.2) .x .A,s .B : .(x)= s =. F(a(x)) = \u00df(s) (3.3) .(s,t) .B \u00d7B :(s, t) \n./g =. (\u00df(s),\u00df(t)) ./G (3.4) By de.nition, given two conditional correlations .f, ., g.and .F, F,G.such \nthat .f, ., g...F, F,G., it is easy to show that .f, ., g.holds if .F, F,G.holds. In general, to .nd \nan appropriate .F, F,G.for a speci.c condi\u00adtional correlation .f,., g.over A, B usually depends on the \ntopolo\u00adgies or the shapes [18] of the two sets, e.g., are they trees, directed acyclic graphs, or cyclic \ngraphs? In the region lifetime consistency problem, we notice that the regions shape a tree while objects \nform a graph. We will further discuss analysis techniques exploiting the property in Section 4.  4. \nRegion Lifetime Consistency In this section, we formalize the region lifetime consistency prob\u00adlem based \non conditional correlation and discuss static analysis al\u00adgorithms to reason about the consistency. \n4.1 Language To develop the formalization, we describe a weakly-typed toy lan\u00adguage. Let R be the set \nof regions and H be the set of normal objects allocated in regions. We use the term object to refer to \neither null, a region r .R, or a normal object h.H. Each normal object may have several .elds f .F to \naccess other objects. The language has the following statements. s::=x=null |x=rnew y |x=ralloc y |x=y \n|x=y.f | x.f =y |s1 ; s2 |if ~s1 else s2 |while ~s A variable may be initialized to null. A new subregion \ncan be created using rnew, given a parameter as the parent region. A new normal object may be allocated \nin a given region using ralloc.Ifthe parameter given in rnew or ralloc is null, it means the root region, \ndenoted as .. In addition, the language has standard assignment, load, store, composition, branching, \nand looping statements. We consider the subregion relation enforces the region deletion order, so we \ndo not model region deletion in the language. Let O = R .H be the union of regions and normal objects, \nso that o .O is a non-null object. O. =O .{.}represents all objects including null. We de.ne the concrete \ncontexts and effects as follows. .::=V .O. (environment) d ::=H \u00d7F .O. (heap) p ::=R \u00d7R (subregion) f::=R \n\u00d7O (ownership) s ::=O \u00d7O (access) The environment .maps a variable to an object. The heap d tracks the \nset of objects that each normal object can access via its .elds. In addition, three effects record necessary \ninformation for reasoning about consistency as follows. r<r. in precords that ris a subregion of r . \n.  r. oin frecords that region rowns object o.  o. o . in srecords that object ocan access object o \n. . Since null can be used to refer to the root region .in rnew and ralloc,wede.ne .. : V . R in addition \nto . for convenience. Note that .. is unde.ned for a normal object. ( r if .(x)=r .. (x)=. if .(x)=. \nFigure 4 shows the big-step operational semantics of the lan\u00adguage. A judgment s,.,d ...,d.,p0,f0,s0 \nmeans that after each statement sthe environment .and the heap d change to .. and d. , respectively, \nand the statement sgenerates new tuples p0,f0,s0 in relations p, f, s, respectively. We explain each \njudgment in detail. (4.1) Variable xis initialized as null.  (4.2) A new region r is created as a subregion \nof the parent r . referred by y, and is assigned to x. A new subregion tuple r<r. is generated in p. \n (4.3) A new normal object h is allocated in region r referred by y, and is assigned to x. A new ownership \ntuple r . h is generated in f.  (4.4) Variable xis assigned with the object that yrefers to.  (4.5) \nVariable x is assigned with the object that normal object hcan access via .eld f,where his referred by \ny.  (4.6) Field f of normal object h is assigned with the object that y refers to, where h is referred \nby x. A new access tuple h. .(y)is generated in s if yrefers to a non-null object.  x=null,.,d ..[x \n...],d,\u00d8,\u00d8,\u00d8 (4.1) .. (y)=r . rfresh p0 ={r<r.} (4.2) x =rnew y,.,d ..[x ..r],d,p0,\u00d8,\u00d8 .. (y)=rhfresh \nf0 ={r. h} (4.3) x=ralloc y,.,d ..[x .h],d[h.fi .,\u00d8,f0,\u00d8 ...]x=y,.,d ..[x ...(y)],d,\u00d8,\u00d8,\u00d8 (4.4) .(y)=h \n(4.5) x =y.f,.,d ..[x..d(h.f)],d,\u00d8,\u00d8,\u00d8 .(x)=hs0 =if .(y)=.then \u00d8else {h. .(y)} x.f =y,.,d ..,d[h.f .,\u00d8,\u00d8,s0 \n..(y)] (4.6) s1,.,d ...,d.,p1,f1,s1 s2,..,d. ....,d..,p2,f2,s2 s1 ; s2,.,d ....,d..,p1 .p2,f1 .f2,s1 \n.s2 (4.7) s1,.,d ...,d.,p,f,s (4.8) if ~s1 else s2,.,d ...,d.,p,f,s s2,.,d ...,d.,p,f,s (4.9) if ~s1 \nelse s2,.,d ...,d.,p,f,s while ~s,.,d ..,d,\u00d8,\u00d8,\u00d8 (4.10) s,.,d ...,d.,p1,f1,s1 while ~s,..,d. ....,d..,p2,f2,s2 \nwhile ~s,.,d ....,d..,p1 .p2,f1 .f2,s1 .s2 (4.11) Figure 4. Operational semantics. (4.7) p, f,and s \nare union of the tuples generated by two composition statements.  (4.8) (4.9) p, f,and s is the tuples \ngenerated by a branching statement.  (4.10) The loop is not executed.  (4.11) p, f,and s are union \nof the tuples generated during the execution of the loop.  Example 4.1. Consider the code in Figure \n3. Assuming that .(r0)= .0, .(r1)= .1, P,Q both evaluate true: line 1, ac\u00adcording to (4.3), allocates \na normal object h1, assigns .(o1)=h1, and generates .1 . h1 in f; line 2, according to (4.4), (4.8), \nand our assumption, assigns .(r)=.0; line 3, similar to line 2, assigns .(r)=.1; line 4, according to \n(4.2), creates a new subregion .2, assigns .(r2)=.2, and generates .2 <.1 in p; line 5, similar to line \n1, allocates h2, assigns .(o2)=h2, and generates .2 . h2 in f; line 6, according to (4.6), assigns d(h2.f)=h1 \nand generates h2 . h1 in s.  4.2 Problem Formulation Now we formulate the region lifetime consistency \nproblem for the language. Let the partial order p+ be the re.exive transitive closure of the subregion \nrelation p. In addition, we extend the ownership relation f to the re.exive closure f = to capture the \ninconsistency that a normal object in r1 can access region r2 if r1 . r2. To prove consistency, it suf.ces \nto show that for any regions x,y that have = no partial order x . y, i.e., (x,y) ./p+, each object in \nf (x) must not access any object in f = (y). In the words, the following set must be empty. .\u00af == (o1,o2)|(o1,o2).s \n:o1 .f (x).o2 .f (y).(x,y)./p+ (4.12) To simplify (4.12), extend the access relation s to s * over the \npowerset of objects as follows. * . O \u00af s =(s1,s2)|s1,s2 .2..o1 .s1,o2 .s2 :(o1,o2).s Applying s * to \n(4.12), it suf.ces to prove the following propo\u00adsition holds for consistency. == * .(x,y)./p+ :(f (x),f \n(y))./s * Let p+ ,sdenote the complement of p+,s *, respectively. We rewrite the above proposition as \nfollows. .(x,y).p+ :(f = (x),f = (y)).s* (4.13) (3.1) and (4.13) combine to show that the region lifetime \ncon\u00adsistency problem is an instantiation of conditional correlation. De.nition 4.1 (Region Lifetime Consistency). \n.p+,f = ,s*.is a conditional correlation over R and 2O . Example 4.2. Continue with Figure 3. Example \n4.1 already shows that it generates the tuples in the three relations p : {.2 <.1}, f : {.1 . h1,.2 . \nh2},and s : {h2 . h1}.Sothere are.ve region pairs in p+: .0 . .1, .0 . .2, .1 . .0, .1 . .2,and .2 . \n.0. Further, f = maps them to corresponding object pow\u00ad `\u00b4`\u00b4`\u00b4 erset pairs: {.0},{.1,h1}, {.0},{.2,h2}, \n{.1,h1},{.0}, `\u00b4`\u00b4 {.1,h1},{.2,h2},and {.2,h2},{.0}, respectively. It is easy to show that all the pairs \nare in s* in the case that both P,Qevalu\u00adate true, so the region lifetime here is consistent. 4.3 Static \nAnalysis Consider a static analysis algorithm that computes abstract effects ., F,and Sfor p, f,and s, \nrespectively, such that .p+,f = ,s*.. ..+ ,F = ,S*.holds. As we have discussed in Section 3, a sound \nalgorithm should estimate an over-approximation of p+,f =,and an under-approximation of s*, that is, \nan under-approximation of p, and an over-approximation of f,s. We brie.y describe a standard Anderson-style \nanalysis [3]. In addition to the three abstract effects ., F,and S, the algorithm estimates two abstract \ncontexts: abstract environment G and ab\u00adstract heap .. Using abstract locations instead of fresh objects, \nit is straightforward to compute abstract contexts and effects in initial\u00adization, region creation, normal \nobject allocation, assignment, load, store, and composition statements for the toy language in parallel \nwith the semantics. For branching statements, the algorithm joins the abstract contexts and effects on \nboth paths by union of abstract contexts and effects. For looping statements, it iterates until reach\u00ading \na .xed point. We omit the details for brevity. Intuitively, the algorithm estimates ., F,and Sas an over-approximation \nof p, f, and s, respectively, either .ow-sensitive or .ow-insensitive. Example 4.3. Consider Figure 3 \nagain. Similar to Example 4.1, assuming that G(r0)= {.0}, G(r1)= {.1}: line 1 generates (o1,h1)in Gand \n.1 . h1 in F; line 2 generates (r,.0)in G;line3 generates (r,.1)in G,sonow G(r)= {.0,.1}; line 4 generates \n(r2,.2)in Gand .2 <.0,.2 <.1 in .; line 5 generates (o2,h2) in Gand .2 . h2 in F; line 6 generates (h2.f,h1)in \n.and h2 . h1 in S. Here .0,.1,h1,h2 are abstract locations; the abstract effects are .: {.2 <.0,.2 <.1}, \nF: {.1 . h1,.2 . h2}, and S:{h2 . h1}. Note that .is an over-approximation of p. However, we need an \nunder-approximation. As we have discussed in Section 2, using such imprecise subregion edges can be unsound \nand will miss region pairs that should be veri.ed in .+, e.g., .2 <.1. Generally, the subregion relation \np should form a tree, where each region (except for the root region .) has one and only one parent. A \nstatic analysis algorithm may conservatively estimate  1 if ~ p = rnew( ); else p = rnew( ); 2 q = \nrnew(p); 3 o1 = ralloc(p); 4 o2 = ralloc(q);  5 o2.f = o1; (a) (b) Figure 5. An intra-region pointer \nexample. region r to be a subregion of several regions r1,r2,...,rn,rather than a unique parent in semantics. \nIn such cases, regions form a join-semilattice, where the root region .is the top. We consider the parent \nregion of r as the join of all its possible parent regions W n W n ri, and replace them with the tuple \nr< ri in .. i=1 i=1 Example 4.4. Continue with Example 4.3. Assume that the parent of either .0 or .1 \nis the root region .. The algorithm .nally generates .: {.i < .|i =0,1,2}, so that there are six region \npairs in .+ to be veri.ed, as discussed in Section 2. The algorithm can be .ow-insensitive, thus we adopt \nmore pre\u00adcise pointer analysis techniques [22] while preserving scalability. We should distinguish effects \n(e.g., the subregion, ownership, and access relations) in individual contexts (e.g., call paths), so \nwe need context-sensitivity [14]. Furthermore, we should precisely track what each .eld of an object \nrefers to, so we also use .eld\u00adsensitivity. In addition, we should be able to distinguish different instances \nof objects that are created at the same call site but on dif\u00adferent call paths, thus heap cloning or \nspecialization is critical for precision [36]. RegionWiz implements a .ow-insensitive, context\u00adsensitive, \n.eld-sensitive analysis with heap cloning. However, the algorithm comes at a price. Consider the example \nin Figure 5. Line 1 creates either r0 or r1; line 2 creates a subregion r2, taking the region that prefers \nto as its parent. When prefers to either ri,i =0,1, o1 is in ri and r2 is also a subregion of ri. Since \no2 is in r2, the region lifetime is always consistent. Our .ow\u00adinsensitive algorithm will conservatively \nyield an imprecise result as shown in Figure 5(a) and report a false warning, because it fails to capture \nthe fact that the parent of r2 and the owner of o1 are always the same region. A possible approach is \nto introduce an indirect level. Re.ne the relations of subregion p and ownership f as p. : R \u00d7 V and \nf. : V \u00d7O, respectively, where V is the set of variables. A new static analysis algorithm that computes \ndef-use information for each variable can yield a more precise result, as shown in Fig\u00adure 5(b). The \nnew subregion tuple is r2 =. p, while the new own\u00adership tuples are p.. o1,q .. o2. In this case it suf.ces \nto verify against (region) variable pairs v1,v2 if there exists region r that variable v2 may refer to \nsuch that r . v1. A practical implemen\u00adtation can adopt techniques such as IPSSA [29], an unsound but \neffective approach. We defer it to future work.  5. Implementation Our prototype tool RegionWiz currently \nsupports two region-based memory management interfaces used in real-world C programs: RC regions [17] \nand Apache Portable Runtime (APR) pools [23]. We use the interface of APR pools as an example, which \nis widely adopted by various software packages such as Apache web server and Subversion version control \nsystem. Figure 6 lists part of the interface. Similar to rnew, apr pool create creates a new subregion \nof a given parent region (or the root if given null); the subregion can be retrieved by dereferencing \nthe .rst parameter newp, a pointer to pointer. A function apr palloc, similar to ralloc, allocates a \n/* region creation (rnew) */ apr_status_t apr_pool_create(apr_pool_t **newp, apr_pool_t *parent); /* \nobject allocation (ralloc) */ void * apr_palloc(apr_pool_t *p, apr_size_t size); void * apr_pcalloc(apr_pool_t \n*p, apr_size_t size); /* region deletion */ void apr_pool_clear(apr_pool_t *p); void apr_pool_destroy(apr_pool_t \n*p); /* cleanup registration */ typedef apr_status_t (*cleanup_t)(void *data); void apr_pool_cleanup_register(apr_pool_t \n*p, const void *data, cleanup_t plain_cleanup, ...); Figure 6. Part of APR pools interface. speci.ed \nsize of memory in a given region; apr pcalloc further .lls the newly allocated memory with zero. A region \ncan be cleared using apr pool clear or deleted us\u00ading apr pool destroy; the runtime will operate on all \nits de\u00adscendants. Moreover, APR enables to register cleanup functions on regions via apr pool cleanup \nregister. For example, the de\u00adveloper opens a .le descriptor using open and registers a cleanup function \nthat calls close to delete the .le descriptor on a region. When the region is cleared or deleted, the \nruntime will trigger the cleanup function to close the .le descriptor, so that it can avoid re\u00adsource \nleaks. In this way, APR manages systems resources such as .le descriptors using open-close similarly \nto memory in regions. Interested readers may refer to APR documentation for detailed in\u00adformation. Now \nwe describe the implementation details of RegionWiz. It consists of four phases: 1) call graph construction, \n2) con\u00adtext cloning, 3) conditional correlation computation, and 4) post processing. It mostly follows \nthe standard steps in cloning-based context-sensitive pointer analysis [40], with additional supports \nfor heap cloning [36]. 5.1 Call Graph Construction The .rst phase constructs an initial context-insensitive \ncall graph in a standard way as a basis for further computation. We built a back-end plug-in for the \nPhoenix compiler framework [31], and transparently inserted the plug-in into the compiler phase list \nto extract instructions of the intermediate representation (IR) for pro\u00adgrams. Each instruction consists \nof destination operands, opcode, and source operands. // time_t t = time(0); 1 t142 = CALL &#38;_time, \n0 2 _t = ASSIGN t142 // struct tm * (*mytime)(const time_t *timer); // mytime = localtime; 3 _mytime \n= ASSIGN &#38;_localtime // int week = mytime(&#38;t)->tm_wday; 4 t143 = CALL _mytime, &#38;_t 5 t144 \n= ADD t143, 24 6 _week = ASSIGN [t144]* In the example above, line 1 is a direct CALL instruction to \nfunc\u00adtion time; line 3 assigns a function pointer to variable mytime; line 4 indirectly invokes the function \npointer and assigns t143 with the resulting structure tm; to access its .eld tm.tm wday, line 5 adds \nthe pointer with offset 24, which is machine-dependent; line 6 deferences the value. The algorithm for \ncall graph construction is expressed as Dat\u00adalog rules and solved using the bddbddb deductive database \n[24] over such IR instructions. Let I be the set of IR instructions and F be the set of functions. The \nresulting call graph is in the form call : I \u00d7 F , the set of call edges; call(i, f) means that the target \nof instruction i (that should be a CALL instruction) is function f. RegionWiz computes call from direct, \nindirect, and implicit calls. The target function of a direct call can be simply extracted from the .rst \nsource operand of the CALL instruction, such as line 1 that calls time in the example above. An indirect \ncall requires to resolve the .rst source operand of a CALL instruction to determine what functions the \nvariable may refer to. To do so, RegionWiz estimates the set vF : V \u00d7 F for each variable, where V is \nthe set of variables. For an initialization instruction such as line 3 in the example above, it is straightfor\u00adward \nto add (mytime, localtime) into set vF . RegionWiz fur\u00adther propagates function pointer values along \nvariable assignments intraprocedually and call-return instructions (e.g., parameters and return values) \ninterprocedurally, and iterates to add (variable, func\u00adtion) pairs into set vF until it converges. An \nimplicit call such as system callback requires expert knowl\u00adedge. For example, if there is a call instruction \ni to function apr thread create with the entry function foo as its parame\u00adter, the system will create \na thread that invokes foo at runtime. Thus, in addition to the direct call (i, apr thread create), Re\u00adgionWiz \nalso adds the implicit call (i, foo) into set call for a more complete call graph. Current implementation \nsupports such thread creation functions provided by Windows API, libc, and APR. Moreover, RegionWiz identi.es \nthe main entry for a program (usually the main function in C) and performs a reachability analy\u00adsis to \nprune the instructions in those functions that are never called directly or indirectly from the main \nentry. 5.2 Context Cloning RegionWiz transforms the context-insensitive call graph call to a context-sensitive \ncall graph cc : C \u00d7 I \u00d7 C \u00d7 F via cloning; cc(c0,i,c1,f) is a call edge that instruction i in context \nc0 calls function f in context c1. The transformation .rst reduces strongly connected components in call \ninto single nodes, .nds a topolog\u00adical order, and then numbers individual call paths as calling con\u00adtexts, \nfollowing the standard algorithm [40]. Each context number for a function represents a unique call path \nthat reaches the function from the main entry. Since the number of contexts is exponential, RegionWiz \nstores the relation cc using a .nite domain implemen\u00adtation in BuDDy [28], a binary decision diagram \n(BDD) package. Nowwehaveacontext-sensitivecallgraph cc, where each call to function f in context c is \nidenti.ed as a unique pair (c, f). Thus, for each call to region creation functions (e.g., apr pool create) \nor object allocation functions (e.g., apr palloc), (c, f) can repre\u00adsent a region or object instance. \nOur subsequent computation uses such pairs to identify regions and objects. In addition, variable v is \nidenti.ed as (c, v), so that we can compute points-to set for each variable in individual contexts, such \nas vR(c, v, rc, rf) for variable v in context c that may refer to region instance (rc, rf). The propagation \nfor computing the set works as follows. For intraprocedural statements such as assign\u00adment v2 = v1,add \n(c, v2,rc, rf) into vR if (c, v1,rc, rf) is in vR. Interprocedurally, for CALL instruction i, (c1,i,c2,f) \nin cc, assuming v1 is the k-th variable of instruction i in caller code and v2 is the k-th parameter \nof the target function f in callee code, add (c2,v2,rc, rf) into vR if (c1,v1,rc, rf) is in vR; in addi\u00adtion, \nassuming v3 is assigned with the return value of instruction i and v4 is the source operand of a RETURN \ninstruction in f,add (c1,v3,rc, rf) into vR if (c2,v4,rc, rf) is in vR. The computa\u00adtion iterates until \nit converges.  5.3 Conditional Correlation Computation This phase is the core part of our analysis to \ncompute the condi\u00adtional correlation over regions and objects. 5.3.1 Effect Computation The computation \nfor the effects iterates as described in Section 5.2 for a whole program. It is usually the most time-consuming \npart. For calls to region creation functions (e.g., apr pool create) we estimate vR, the set of regions \nthat each variable may point to, and the subregion relation over regions. vR : C \u00d7 V \u00d7 C \u00d7 F is the \npoints-to relation for regions; vR(c, v, rc, rf) means that variable v in context c may point to region \n(rc, rf).  subregion : C \u00d7 F \u00d7 C \u00d7 F is the subregion relation over regions; subregion(rc0,rf0,rc1,rf1) \nmeans that region (rc0,rf0) may be a subregion of (rc1,rf1).  For calls to object allocation functions \n(e.g., apr palloc)we similarly estimate vH, the set of objects that each variable may point to, and the \nownership relation between regions and objects. vH : C \u00d7 V \u00d7 C \u00d7 F is the points-to relation for objects; \nvH(c, v, hc, hf) means that variable v in context c may point to object (hc, hf). ownership : C \u00d7 F \u00d7 \nC \u00d7 F is the ownership relation be\u00adtween regions and objects; ownership(rc, rf, hc, hf ) means that region \n(rc, rf) may own object (hc, hf). We further compute the set heap on each store statement x->f =y that \nx can access y via .eld f. Since C is a weakly-typed language, we use offset values instead of symbolic \nnames for .elds. heap : C \u00d7 F \u00d7 N \u00d7 C \u00d7 F is the set for heap over objects; heap(c0,f0,n,c1,f1) means \nthat object (c0,f0) contains a pointer at the offset n that can access object (c1,f1). We do not compute \na separate access relation; heap is suf.cient.  5.3.2 Inconsistency Computation We .lter candidate region \npairs that have no subregion partial order, and verify the non-access property against each pair. regionP \nair : C \u00d7F \u00d7C \u00d7F is the set of region pairs that may have no subregion partial order; regionP air(rc0,rf0,rc1,rf1) \nmeans that (rc0,rf0) . (rc1,rf1). objectP air : C \u00d7 F \u00d7 N \u00d7 C \u00d7 F is the resulting inconsistent object \npairs; objectP air(c0,f0,n,c1,f1) means that object (c0,f0) contains a possible dangling pointer at .eld \noffset n to object (c1,f1). The computation of regionP air is based on the conservative way to estimate \nparent regions described in Section 4.3. It is straight\u00adforward to compute the result objectP air based \non regionP air, ownership,and heap according to (4.12) and (4.13).  5.4 Post Processing As a static \nanalysis tool may generate a large amount of warnings, it is necessary to process the reported warnings \nand aid developers to locate and inspect the suspicious code. First, since the result objectP air is \nover context-sensitive ob\u00adject pairs, the size is usually quite large because the object pairs can be \ninconsistent in many similar contexts. We condense context\u00adsensitive object pairs to context-insensitive \ninstruction pairs (I\u00adpairs) for further inspection. Besides, we rank reported warnings. RegionWiz does \nnot com\u00adpute def-use information, as we have discussed in Section 4.3, so it may report warnings on intra-region \npointers that should be always safe. To .lter them our current implementation applies one rank\u00ading heuristic: \nfor an inconsistent object pair, if their owner regions never have the subregion relation, we rank them \nhigh in the result. KLOC exe brief description rcc 37 1 RC compiler apache 2.2.6 42 9 web server and \nutilities freeswitch 1.0b1 109 1 telephony platform shell jxta-c 2.5.2 114 1 P2P framework shell lklftpd \n5 1 FTP server subversion 1.4.5 240 9 version control system Figure 7. Benchmarks. The exe column lists \nthe number of executables in each packages. The rcc package uses RC regions. Other software packages \nare based on APR, where the code size of APR (~ 200 KLOC) does not count. high-ranked (cause) inconsistency \n(cause) rcc 1(1) 1(1) apache 1(1) 0(0) lklftpd 2(2) 2(2) subversion 21 (6) 9(4) total 25 (10) 12 (7) \n Figure 8. Numbers of high-ranked warnings and inconsistencies, as well as their unique causes. 5.5 \nLimitations RegionWiz supports pointers to pointers, since they are typ\u00adical in C functions for retrieving \nnewly created objects, e.g., apr pool create. It also handles unsafe typecasts including casts between \nintegers and pointers, and uses low-level offset integers rather than symbolic .eld names for structures \nand unions. It is unsound for more complex pointer operations such as arithmetic. RegionWiz tracks thread \ncreations as implicit calls, but it may still miss some call edges due to other implicit callbacks from \nthe operating systems or underlying libraries. It tracks function pointers but may still fail to resolve \nsome call sites due to complex pointer operations or dynamic loading of shared libraries. The current \nPhoenix version does not emit all information generated by the front-end, so RegionWiz may miss some \nindirect call edges. These limitations will result in an incomplete call graph. Besides, our post processing \nis unsound. Developers may focus on high-ranked warnings and miss lower-ranked inconsistencies.  6. \nExperiments We have applied our prototype tool RegionWiz to six software packages, as listed in Figure \n7. Among them rcc uses RC regions, while others use APR pools. All packages in the experiments were the \nlatest stable releases (if possible), so we did not expect there would be many inconsistencies. Development \nversions are more likely to have serious inconsistencies; interested readers can search their repository \nlogs for .xes. RegionWiz reported 230 warnings of instruction pairs for in\u00adconsistent objects and ranked \n25 of them high (10 unique causes). We examined them and found 12 inconsistencies (7 unique causes), \nas showninFigure8. 6.1 Case Study Figure 9 illustrates an inconsistency case between a hash table and \nan iterator in Subversion. The hash table should have a longer lifetime than the iterator. On the contrary, \nin Figure 9(a) the hash table resides in subregion subpool; in Figure 9(b) the iterator hi is allocated \nin the parent pool, which is inconsistent. Though the inconsistency does not lead to crash, the longer-than-necessary \nlifetime is a potential memory leak. /* libsvn_subr/xml.c:svn_xml_make_open_tag_v */ apr_pool_t *subpool \n= svn_pool_create(pool); apr_hash_t *ht = svn_xml_ap_to_hash(ap, subpool); svn_xml_make_open_tag_hash(str, \npool, ..., ht); svn_pool_destroy(subpool); (a) A hash table ht is allocated in subpool. /* libsvn_subr/xml.c:svn_xml_make_open_tag_hash \n*/ for (hi = apr_hash_first(pool, ht); hi; ...) (b) Retrieve an iterator hi for the hash table ht. /* \napr/tables/apr_hash.c: apr_hash_first */ if (pool) hi = apr_palloc(pool, sizeof(*hi)); else hi = &#38;ht->iterator; \nhi->ht = ht; (c) If the given region pool is not null, a new iterator hi is allocated from pool; otherwise, \nhi uses a .eld of ht intrusively. The iterator can access the hash table via hi->ht. Figure 9. An inconsistency \nbetween a hash table and its iterator. The iterator hi allocated in parent pool holds a possible dangling \npointer hi->ht to the hash table ht allocated in subpool. Note that the code in Figure 9(a) allocates \nthe hash table in a subregion and deletes the subregion before exit; the developers should have intended \nto free all temporary memory, but the inten\u00adtion fails due to hi that inconsistently resides in pool. \nThe devel\u00adopers might argue that using a separate subregion could be more likely to be thread safe (see \nSection 6.4 for further discussion), but hi is allocated in the parent pool, which contradicts the argument. \nTo .x the bug, the call to svn xml make open tag hash in Fig\u00adure 9(a) can pass subpool instead of pool. \nAlternatively, the call to apr hash first in Figure 9(b) can pass null instead of pool as the .rst parameter; \nin Figure 9(c) iterator hi will share the same region as the hash table. Another type of inconsistency \nrelates to strings. The warning generated for rcc is such a case that an object holds a pointer to a \nstring while their owner regions have no subregion partial order. We omit the code for brevity since \nit involves about 10 functions. The inconsistency does not lead to crash because the two owner regions \nare never deleted. However, the object should not expect client code never deletes the region that owns \nthe string; a better way could be to duplicate the string in the object s owner region. Temporary inconsistencies \nthat violate the consistency seman\u00adtics within a scope of code are benign . Figure 10 illustrates an \nexample. Object lock is allocated from pool,and lock->set may be assigned with a temporary hash table \nallocated from subpool via a call to apr hash make. Our tool reported a warning for the case since it \nviolates the semantics de.ned in Section 3, though later lock->set is reassigned with associated->set \nbefore subpool is deleted. A more precise analysis with path sensitivity may help to elim\u00adinate the temporary \ninconsistency. Particularly, the analysis may have to prove that object lock is always allocated from \na parent re\u00adgion pool in either branch of write lock,that lock->set is set to a hash table allocated \nin a subregion subpool under the condi\u00adtion P that both levels to lock!=0 and associated hold, that lock->set \nis reassigned with associated->set under the condi\u00adtion Q that associated holds (independent of levels \nto lock), and that P implies Q. Generally, temporary inconsistencies make code that involves complicated \nbranch conditions more error-prone. Developers have to carefully handle assignments of objects of different \nlifetimes in various code branches. Nevertheless, a better way to organize /* libsvn_wc/lock.c:do_open \n*/ svn_wc_adm_access_t *lock; apr_pool_t *subpool = svn_pool_create(pool); if (write_lock) lock = adm_access_alloc(..., \npool); else lock = adm_access_alloc(..., pool); if (levels_to_lock != 0) { if (associated) lock->set \n= apr_hash_make(subpool); if (associated) { ... lock->set = associated->set; } } if (associated) lock->set \n= associated->set; svn_pool_destroy(subpool); Figure 10. A (slightly simpli.ed) temporary inconsistency \nex\u00adample. Object lock is allocated in pool (in either branch of write lock). Its .eld lock->set is temporarily \nassigned with a hash table, which is allocated from subpool; the .eld is later reas\u00adsigned with associated->set. \ncode could be updating object .elds only when necessary to avoid temporary inconsistencies and reduce \nthe risk of crashes and leaks. In our experience, region lifetime inconsistency usually in\u00advolves several \nfunctions and deep call paths, thus it requires a precise interprocedural analysis as we have employed. \n 6.2 False Warnings Since our analysis is mostly .ow-insensitive, we expected there would be corresponding \nfalse warnings. We looked 205 lower\u00adranked warnings. Most of them are false; we found 1 temporary in\u00adconsistency \nthere. So our simple heuristic described in Section 5.4 effectively pruned most false warnings. However, \nto eliminate the false warnings (3 unique causes) in high-ranked ones we found that all of them require \nextra effort in addition to .ow sensitivity. Here is an example. 1 /* libsvn_subr/error.c:make_error_internal \n*/ 2 if (child) 3 pool = child->pool; 4 else 5 if (apr_pool_create(&#38;pool, NULL)) 6 abort(); 7 new_error \n= apr_pcalloc(pool, ...); 8 new_error->child = child; At .rst glance, line 5 creates a separate region \npool and line 7 allocates object new error in the region; at line 8 the object seems to hold a possible \ndangling pointer to child. In fact, pool is a separate new region only if child is null; in this case \npointer new error->child is assigned with null. Otherwise pool refers to child->pool at line 3; because \nnew error shares the same region with child, pointer new error->child is intra-region and always safe. \nIn either case, the region lifetime is consistent. To eliminate such false warnings, we may apply heuristics \nsim\u00adilar to lock-unlock pairs computation in RacerX [15] for race de\u00adtection, or employ a path-sensitive \nanalysis [12, 43] to track branch conditions. We leave it as future work.  6.3 Quantitative Results \nFigure 11 shows our experimental results in detail. For each exe\u00adcutable, we measure the analysis time, \nthe total numbers of regions R and normal objects H, and the sizes of the three relations sub\u00adregion, \nownership, and heap (access). We also count the numbers of region pairs that have been veri.ed (R-pairs) \nand suspicious ob\u00adject pairs that have been detected (O-pairs). The context-insensitive instruction pairs \n(I-pairs) and high-ranked pairs are useful for fur\u00adther inspection. The time for call graph construction \ndoes not count since they are relatively small compared to the analysis time. time R H sub. own. heap \nR-pair O-pair I-pair high rcc 19m21s 10 2536 9 1577 746940 70 1 1 1 ab 49s 11 111 10 53 24 92 0 0 0 htdbm \n51s 3 15 2 12 10 4 0 0 0 rotatelogs 51s 3 21 2 17 21 4 0 0 0 httxt2dbm 56s 4 80 3 27 45 8 0 0 0 htcacheclean \n1m21s 13 242 12 162 230 120 0 0 0 htdigest 1m27s 3 293 2 264 315 4 0 0 0 htpasswd 1m50s 3 406 2 338 343 \n4 0 0 0 .ood 2m06s 6 324 5 62 97 24 0 0 0 httpd 34m04s 19 4546 18 2341 2273 319 410 9 1 freeswitch 14m55s \n20 3174 46 3065 2499 360 456 4 0 jxta-c 58m24s 17 5007 16 27 10 256 0 0 0 lklftpd 2m34s 7 622 6 622 565 \n34 6 2 2 diff 16m29s 427 1941 680 64833 4274 181477 260 13 1 diff3 19m30s 424 1865 535 25135 2766 178930 \n189 13 1 diff4 21m24s 425 1877 538 25147 2781 179767 190 13 1 svndump.lter 44m46s 6517 28378 6870 2069908 \n29153 42458253 4072 15 2 svnadmin 53m20s 7274 31620 8326 3881275 39133 52896514 7741 23 2 svnlook 1h00m57s \n8194 35638 8760 4846261 37928 67125232 5289 23 2 svnsync 1h21m43s 8123 36589 10863 5003865 62491 65965730 \n7896 24 3 svnserve 15h09m41s 47480 195255 93771 158244795 314511 2254148642 43874 57 3 svn 25h59m53s \n53754 238521 542402 897921834 280671987 2889375908 134798 31 6 Figure 11. Experimental results. All experiments \nwere conducted on a server with Intel Xeon 2.0 GHz and 32 GB of RAM. The time column lists the analysis \ntime for each executable. R , H are the numbers of regions and normal objects, respectively (Section \n5.2). sub. , own. , and heap are the sizes of the subregion, ownership,and heap relations, respectively \n(Section 5.3.1). R-pair is the number of region pairs to be veri.ed and O-pair is the number of reported \ninconsistent object pairs (Section 5.3.2). I-pair is the number of context-insensitive instruction pairs \nof O-pairs and high is the number of high-ranked I-pairs (Section 5.4).  As reported [24], BDD variable \norder can greatly affect ef.\u00adciency of bddbddb. We randomly tried a few orders and picked a not-so-bad \none. 18 out of 22 experiments can .nish within an hour. However, as calling contexts grow, the numbers \nof objects (R and H) increase fast and lead to a large amount of relations and region pairs to be veri.ed. \nThe most time-consuming exper\u00adiment, svn, takes more than one day to .nish, which at .rst we thought \ncould not produce a result. Notably, it yields more than 2 billions R-pairs and thus complicates the \ncomputation. The result suggests that reducing calling contexts is an important factor to im\u00adprove scalability. \nWhile RegionWiz uses call paths as contexts, we are investigating other precise context-sensitivity for \nC programs that yields a smaller number of contexts.  6.4 Discussion It is arguable that few inconsistencies \nimply good code practice. Our tool reported few to none inconsistencies for Apache that manages regions \nin an elaborate way [23], while there were dozens of warnings for Subversion. As an example, let s compare \nXML parser creation API implementations provided by the two packages. Both implementations return a newly \ncreated parser object, based on the popular Expat library (in Expat XML ParserCreate creates a new instance \nand XML ParserFree frees it, similar to open\u00adclose for .le descriptors). As shown in Figure 12(a), apr \nxml parser create in Apache allocates the parser object from the given pool, creates an Expat instance, \nand registers a cleanup function cleanup parser (code not list here). If client code deletes pool, the \nruntime will trigger the cleanup function that invokes XML ParserFree to free the Expat instance. APU_DECLARE(apr_xml_parser \n*) apr_xml_parser_create(apr_pool_t *pool) { apr_xml_parser *parser = apr_pcalloc(pool, ...); parser->xp \n= XML_ParserCreate(NULL); ... apr_pool_cleanup_register(pool, parser, cleanup_parser, ...); ... return \nparser; } (a) apr xml parser create in Apache. svn_xml_parser_t * svn_xml_make_parser(..., apr_pool_t \n*pool) { svn_xml_parser_t *svn_parser; apr_pool_t *subpool; XML_Parser parser = XML_ParserCreate(NULL); \n... /* ### we probably don t want this pool; or at least we should pass it ### to the callbacks and clear \nit periodically. */ subpool = svn_pool_create(pool); svn_parser = apr_pcalloc(subpool, ...); ... return \nsvn_parser; } (b) svn xml make parser in Subversion. Figure 12. Two XML parser creation API implementations. \nOn the other hand, Figure 12(b) shows the Subversion counter\u00adpart svn xml make parser. It does not register \nany callback for XML ParserFree, so to delete pool in client code will lead to leaks (though they provide \na separate parser deletion API). More importantly, it creates subpool of the given pool, and allocates \nthe parser object in subpool rather than in pool as Apache code does. The region usage is debatable. \nInterestingly, as shown in Fig\u00adure 12(b), the developers themselves put a comment that concerns the issue \nin the code. First, as we have discussed in Section 1, one advantage of re\u00adgions is that developers can \ngather relevant objects in the same re\u00adgion and batch allocation and deallocation for better performance. \nHowever, because svn xml make parser allocates the object in a separate subregion, the memory allocator \nof which is independent, client code loses .ne-grained control and cannot take the perfor\u00admance advantage. \nMoreover, since the memory allocator of the subregion is inde\u00adpendent, one may argue that the usage provides \nbetter thread safety and concurrency, as some developers responded; the parser can use subpool independent \nof pool that might be shared with another thread without locks. However, it is not the XML parser API \ns responsibility to take care of the multi-threading issue; the parser does not create any thread. It \nis the client code that should manage threads and regions because only the client code has the knowledge \nto determine whether pool is shared among threads and which re\u00adgion the parser object should reside. \nBecause the parser in svn xml make parser is created in subpool, any object that is created in pool and \nthat can access the parser involves an inconsistency, such as object loggy in the following code. /* \nlibsvn_wc/log.c:run_log */ struct log_runner *loggy = apr_pcalloc(pool, ...); parser = svn_xml_make_parser(..., \npool); ... loggy->parser = parser; RegionWiz reports a warning for every such use.  7. Related Work \nRegions have long been an underlying abstraction for memory management [5], such as in ML [38, 1], real-time \nJava [8, 10, 11], and C [25]. The abstraction is also useful for detecting memory er\u00adrors [20, 13]. Some \nC dialects support regions via language exten\u00adsions. Cyclone [19] enables developers to add region annotations \nin a restricted discipline to source code. It infers regions and performs type checking to statically \ndetect dangling pointers. C@ [16] and RC [17] support more .exible region usages. They maintain refer\u00adence \ncounts for regions at runtime; a region will not be deleted if it is still referenced by inter-region \npointers from outside. While use\u00adful, dynamic techniques for safe regions do not .x bugs generally; objects \nstill reside inconsistently in regions, and resources in the re\u00adgions cannot be reclaimed. RegionWiz \ncan .nd these bugs before deployment and usually provide a higher coverage. Correlations that capture \nconsistency constraints between two sets of objects pervade in software systems. MUVI [30] infers multi-variables \nthat should be updated consistently, e.g., a buffer and its length, and detects violations in source \ncode. Another no\u00adtable example is the correlation between locks and memory loca\u00adtions for race detection, \nwhich is an inspiration of our work. Rac\u00aderX [15] employs heuristics to detect races and dead locks in \nmil\u00adlions lines of systems code. LOCKSMITH [37] infers the correlation for C programs and formalizes \nthe problem as a constraint resolu\u00adtion. Chord [33, 34] further introduces a disjoint reachability anal\u00adysis \nfor Java; proving race-free is formalized as a conditional must not aliasing problem based on analyzing \nthe heap. Ownership types for real-time Java [8, 11], based on the concept of encapsulation, can also \nbe used to prove conditional correlation for region lifetime consistency, though not necessary [34]. \nBesides, they infer own\u00adership between objects; our ownership relation is between regions and objects, \nwhich is more natural for region interfaces such as RC regions and APR pools. RegionWiz adopts a cloning-based \ncontext-sensitive pointer analysis [40] with heap cloning [36] to distinguish different call paths to \nregion creation and object allocation sites. Most previous cloning-based work [40, 4, 39] did not clone \nthe heap; they consider these sites in a context-insensitive way. We feel that heap cloning is necessary \nfor our analysis, but the numbers of contexts using call paths are too large in some cases. The Chord \nrace detector [33] uses object sensitivity [32] for a smaller number of contexts in Java programs. We \nare investigating more appropriate context sensitiv\u00adity for C programs. In addition to the cloning-based \napproach, we may also adopt other context-sensitive pointer analysis with heap cloning [35, 26]. Besides, \nour analysis algorithm is mostly solved by bddb\u00adddb [24], the BDD-based deductive database. Since BDD \nis often a key component to achieve scalability in context-sensitive analy\u00adsis [27, 40, 44], we are interested \nin a parallel BDD implementation that can help to build more ef.cient analysis tools. To achieve a lower \nfalse-positive rate, we may employ more precise path-sensitive analysis techniques, such as IPSSA [29] \nand SAT-based approaches [42, 9]. 8. Conclusion Region-based memory management is widely used in systems \nsoft\u00adware, but it is prone to lifetime consistency that can cause dangling pointers. We formalize the \nproblem based on the concept of condi\u00adtional correlation, which may be of independent interest. We have \nbuilt a prototype tool RegionWiz to detect such inconsistencies in source code and applied it to real-world \napplications. It is useful to .nd inconsistency bugs in practice. We would like to further investigate \nmore precise and scalable analysis techniques for computing conditional correlation. Besides, we are \nworking on extensions to support analysis of open programs such as libraries. Our future work also includes \nto study other conditional correlations, such as locks and memory locations.  Acknowledgments We thank \nDavid Gay for insightful comments on the RC compiler and John Whaley for useful discussions about bddbddb. \nWe would like to thank Frans Kaashoek, Zhengwei Qi, Linchun Sun, Ming Wu, Jianian Yan, and the anonymous \nreviewers for their valuable feedback on earlier drafts of this paper. Xi Wang and Xiaoge Wang are supported \nin part by National High-Tech Research and Devel\u00adopment Plan of China under Grant No. 2006AA01Z198 and \nby Basic Research Foundation of Tsinghua National Laboratory for Information Science and Technology. \n References [1] A.Aiken,M.F\u00a8ahndrich, and R. Levien. Better static memory management: Improving region-based \nanalysis of higher-order languages. In ACM SIGPLAN Conference on Programming Language Design and Implementation \n(PLDI), 1995. [2] R. Z. Altucher and W. Landi. An extended form of must alias analysis for dynamic allocation. \nIn ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages (POPL), 1995. [3] L.O.Andersen. \nProgram Analysis and Specialization for the C Programming Language. PhD thesis, DIKU, University of Copenhagen, \n1994. [4] D. Avots, M. Dalton, V. B. Livshits, and M. S. Lam. Improving software security with a C pointer \nanalysis. In International Conference on Software Engineering (ICSE), 2005. [5] E. D. Berger, B. G. Zorn, \nand K. S. McKinley. Reconsidering custom memory allocation. In ACM SIGPLAN Conference on Object-Oriented \nProgramming, Systems, Languages, and Applications (OOPSLA), 2002. [6] L. Birkedal, M. Toft, and M. Vejlstrup. \nFrom region inference to von Neumann machines via region representation inference. In ACM SIGPLAN-SIGACT \nSymposium on Principles of Programming Languages (POPL), 1996. [7] H.-J. Boehm and M. Weiser. Garbage \ncollection in an uncooperative environment. Software Practice and Experience, 18(9):807 820, 1988. [8] \nC. Boyapati, A. S.alcianu, W. Beebee, and M. Rinard. Ownership types for safe region-based memory management \nin real-time Java. In ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI), \n2003. [9] S. Cherem, L. Princehouse, and R. Rugina. Practical memory leak detection using guarded value-.ow \nanalysis. In ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI), 2007. [10] \nS. Cherem and R. Rugina. Region analysis and transformation for Java programs. In International Symposium \non Memory Management (ISMM), 2004. [11] W.-N. Chin, F. Craciun, S. Qin, and M. Rinard. Region inference \nfor an object-oriented language. In ACM SIGPLAN Conference on Programming Language Design and Implementation \n(PLDI), 2004. [12] M. Das, S. Lerner, and M. Seigle. ESP: Path-sensitive program veri.cation in polynomial \ntime. In ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI), 2002. [13] \nD. Dhurjati, S. Kowshik, and V. Adve. SAFECode: Enforcing alias analysis for weakly typed languages. \nIn ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI), 2006. [14] M. Emami, \nR. Ghiya, and L. J. Hendren. Context-sensitive interprocedural points-to analysis in the presence of \nfunction pointers. In ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI), \n1994. [15] D. Engler and K. Ashcraft. RacerX: Effective, static detection of race conditions and deadlocks. \nIn ACM Symposium on Operating Systems Principles (SOSP), 2003. [16] D. Gay and A. Aiken. Memory management \nwith explicit regions. In ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI), \n1998. [17] D. Gay and A. Aiken. Language support for regions. In ACM SIGPLAN Conference on Programming \nLanguage Design and Implementation (PLDI), 2001. [18] R. Ghiya and L. J. Hendren. Is it a tree, a DAG, \nor a cyclic graph? a shape analysis for heap-directed pointers in C. In ACM SIGPLAN-SIGACT Symposium \non Principles of Programming Languages (POPL), 1996. [19] D. Grossman, G. Morrisett, T. Jim, M. Hicks, \nY. Wang, and J. Cheney. Region-based memory management in Cyclone. In ACM SIGPLAN Conference on Programming \nLanguage Design and Implementation (PLDI), 2002. [20] B. Hackett and R. Rugina. Region based shape analysis \nwith tracked locations. In ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages (POPL), \n2005. [21] D. R. Hanson. Fast allocation and deallocation of memory based on object lifetimes. Software \n Practice and Experience, 20(1):5 12, 1990. [22] M. Hind. Pointer analysis: Haven t we solved this problem \nyet? In ACM SIGPLAN-SIGSOFT Workshop on Program Analysis for Software Tools and Engineering (PASTE), \n2001. [23] N. Kew. The Apache Modules Book: Application Development with Apache. Prentice Hall PTR, 2007. \n[24] M. S. Lam, J. Whaley, V. B. Livshits, M. C. Martin, D. Avots, M. Carbin, and C. Unkel. Context-sensitive \nprogram analysis as database queries. In SIGMOD-SIGACT-SIGART Symposium on Principles of Database Systems \n(PODS), 2005. [25] C. Lattner and V. Adve. Automatic pool allocation: Improving performance by controlling \ndata structure layout in the heap. In ACM SIGPLAN Conference on Programming Language Design and Implementation \n(PLDI), 2005. [26] C. Lattner, A. Lenharth, and V. Adve. Making context-sensitive points-to analysis \nwith heap cloning practical for the real world. In ACM SIGPLAN Conference on Programming Language Design \nand Implementation (PLDI), 2007. [27] O. Lhot\u00b4ak and L. Hendren. Jedd: A BDD-based relational extension \nof Java. In ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI), 2004. [28] \nJ. Lind-Nielsen. BuDDy: A binary decision diagram package. http://buddy.sourceforge.net/. [29] V. B. \nLivshits and M. S. Lam. Tracking pointers with path and context sensitivity for bug detection in C programs. \nIn European Software Engineering Conference and ACM SIGSOFT Symposium on the Foundations of Software \nEngineering (ESEC/FSE), 2003. [30] S. Lu, S. Park, C. Hu, X. Ma, W. Jiang, Z. Li, R. A. Popa, and Y. \nZhou. MUVI: Automatically inferring multi-variable access correlations and detecting related semantic \nand concurrency bugs. In ACM Symposium on Operating Systems Principles (SOSP), 2007. [31] Microsoft. \nPhoenix compiler framework. http://research. microsoft.com/phoenix/. [32] A. Milanova, A. Rountev, and \nB. G. Ryder. Parameterized object sensitivity for points-to and side-effect analyses for Java. In ACM \nSIGSOFT International Symposium on Software Testing and Analysis (ISSTA), 2002. [33] M. Naik and A. Aiken. \nEffective static race detection for Java. In ACM SIGPLAN Conference on Programming Language Design and \nImplementation (PLDI), 2006. [34] M. Naik and A. Aiken. Conditional must not aliasing for static race \ndetection. In ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages (POPL), 2007. [35] \nE. M. Nystrom, H.-S. Kim, and W. mei W. Hwu. Bottom-up and top-down context-sensitive summary-based pointer \nanalysis. In Static Analysis Symposium (SAS), 2004. [36] E. M. Nystrom, H.-S. Kim, and W. mei W. Hwu. \nImportance of heap specialization in pointer analysis. In ACM SIGPLAN-SIGSOFT Workshop on Program Analysis \nfor Software Tools and Engineering (PASTE), 2004. [37] P. Pratikakis, J. S. Foster, and M. Hicks. LOCKSMITH: \nContext\u00adsensitive correlation analysis for race detection. In ACM SIGPLAN Conference on Programming Language \nDesign and Implementation (PLDI), 2006. [38] M. Tofte and J.-P. Talpin. Implementation of the typed call-by-value \n.-calculus using a stack of regions. In ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages \n(POPL), 1994. [39] X. Wang, Z. Guo, X. Liu, Z. Xu, H. Lin, X. Wang, and Z. Zhang. Hang analysis: Fighting \nresponsiveness bugs. In ACM SIGOPS European Conference on Computer Systems (EuroSys), 2008. [40] J. Whaley \nand M. S. Lam. Cloning-based context-sensitive pointer alias analysis using binary decision diagrams. \nIn ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI), 2004. [41] P. R. \nWilson. Uniprocessor garbage collection techniques. In International Workshop on Memory Management (IWMM), \n1992. [42] Y. Xie and A. Aiken. Context-and path-sensitive memory leak detection. In European Software \nEngineering Conference and ACM SIGSOFT Symposium on the Foundations of Software Engineering (ESEC/FSE), \n2005. [43] Y. Xie and A. Aiken. Scalable error detection using Boolean satis.ability. In ACM SIGPLAN-SIGACT \nSymposium on Principles of Programming Languages (POPL), 2005. [44] J. Zhu and S. Calman. Symbolic pointer \nanalysis revisited. In ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI), \n2004.  \n\t\t\t", "proc_id": "1375581", "abstract": "<p>Region-based memory management is a popular scheme in systems software for better organization and performance. In the scheme, a developer constructs a hierarchy of regions of different lifetimes and allocates objects in regions. When the developer deletes a region, the runtime will recursively delete all its subregions and simultaneously reclaim objects in the regions. The developer must construct a <i>consistent</i> placement of objects in regions; otherwise, if a region that contains pointers to other regions is not always deleted <i>before</i> pointees, an inconsistency will surface and cause dangling pointers, which may lead to either crashes or leaks.</p> <p>This paper presents a static analysis tool RegionWiz that can find such lifetime inconsistencies in large C programs using regions. The tool is based on an analysis framework that generalizes the relations and constraints over regions and objects as conditional correlations. This framework allows a succinct formalization of consistency rules for region lifetimes, preserving memory safety and avoiding dangling pointers. RegionWiz uses these consistency rules to implement an efficient static analysis to compute the conditional correlation and reason about region lifetime consistency; the analysis is based on a context-sensitive, field-sensitive pointer analysis with heap cloning.</p> <p>Experiments with applying RegionWiz to six real-world software packages (including the RC compiler, Apache web server, and Subversion version control system) with two different region-based memory management interfaces show that RegionWiz can reason about region lifetime consistency in large C programs. The experiments also show that RegionWiz can find several previously unknown inconsistency bugs in these packages.</p>", "authors": [{"name": "Xi Wang", "author_profile_id": "81451596353", "affiliation": "Tsinghua University, Beijing, China", "person_id": "P1022735", "email_address": "", "orcid_id": ""}, {"name": "Zhilei Xu", "author_profile_id": "81351591505", "affiliation": "Tsinghua University, Beijing, China", "person_id": "P1022736", "email_address": "", "orcid_id": ""}, {"name": "Xuezheng Liu", "author_profile_id": "81350577857", "affiliation": "Microsoft Research Asia, Beijing, China", "person_id": "P1022737", "email_address": "", "orcid_id": ""}, {"name": "Zhenyu Guo", "author_profile_id": "81350572404", "affiliation": "Microsoft Research Asia, Beijing, China", "person_id": "P1022738", "email_address": "", "orcid_id": ""}, {"name": "Xiaoge Wang", "author_profile_id": "81409597174", "affiliation": "Tsinghua University, Beijing, China", "person_id": "P1022739", "email_address": "", "orcid_id": ""}, {"name": "Zheng Zhang", "author_profile_id": "81310489323", "affiliation": "Microsoft Research Asia, Beijing, China", "person_id": "P1022740", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1375581.1375588", "year": "2008", "article_id": "1375588", "conference": "PLDI", "title": "Conditional correlation analysis for safe region-based memory management", "url": "http://dl.acm.org/citation.cfm?id=1375588"}