{"article_publication_date": "06-07-2008", "fulltext": "\n Discovering Properties about Arrays in Simple Programs * Nicolas Halbwachs MathiasP\u00b4eron Verimag -CNRS \n, Grenoble France Nicolas.Halbwachs@imag.fr/Mathias.Peron@imag.fr Abstract Array bound checking and \narray dependency analysis (for paral\u00adlelization) have been widely studied. However, there are much less \nresults about analyzing properties of array contents. In this paper, we propose a way of using abstract \ninterpretation for discover\u00ading properties about array contents in some restricted cases: one\u00addimensional \narrays, traversedbysimple for loops. The basic idea, borrowed from [GRS05], consists in partitioning \narrays into sym\u00adbolic intervals (e.g., [1,i - 1], [i, i], [i +1,n]), and in associat\u00ading with each such \ninterval I and each array A an abstract vari\u00adable AI ;the new idea is to considerrelational abstract \nproperties .(AI ,BI , ...) about these abstract variables, and to interpret such a property pointwise \non the interval I: .e . I,.(A[e],B[e], ...). The abstract semantics of our simple programs according \nto these abstract properties has been de.ned and implemented in a proto\u00adtype tool. The method is able, \nfor instance, to discover that the re\u00adsultofan insertionsortisasortedarray,orthat,inanarraytraversal \nguardedbya sentinel , the index stays within the bounds. Categories and Subject Descriptors D.2.4 [Software/Program \nVeri.cation]; F.3.1 [Specifying and Verifying and Reasoning about Programs]; F.3.2[Semantics of Programming \nLanguages]: Program analysis General Terms Veri.cation, Theory Keywords Program veri.cation, abstract \ninterpretation, invariant synthesis, arrays, sorting algorithms, sentinel 1. Introduction Although array \nbound checking was a motivation of the very .rst work on abstract interpretation [CC76], analyzing properties \nof ar\u00adray contents was considered only recently. The reason is, of course, that the general problem is \ndif.cult: array indexing induces com\u00adplex semantics, and in particular the possibility of aliasing; more\u00adover, \nsince the size of an array can be large or unknown, it repre\u00adsents a large or unbounded number of variables. \nIn this paper, we * Thisworkhasbeen partially supportedbytheAPRON projectofthe ACI S\u00b4e Informatique of \nthe French Ministry of Research. ecurit\u00b4 Verimagisa joint laboratoryof Universit\u00b4e JosephFourier, CNRS \nand INPG. Permission to make digital or hard copies of all or part of this work for personal or classroom \nuse is granted without fee provided that copies are not made or distributed for pro.t or commercial advantage \nand that copies bear this notice and the full citation on the .rst page.To copyotherwise, to republish, \nto post on servers or to redistribute to lists, requires prior speci.c permission and/or a fee. PLDI \n08, June 7 13, 2008,Tucson, Arizona, USA. Copyright c &#38;#169; 2008ACM 978-1-59593-860-2/08/06... $5.00 \nproposeawayofusing abstract interpretationfordiscoveringprop\u00aderties about array contents in some restricted \ncases. First, we re\u00adstrict ourselves to one-dimensional arrays and simple programs , which manipulate \narrays onlyby sequential traversal: typically, for loops incrementing (or decrementing) their index at \neach iteration, and accessing arrays by simple expressions (constant translations) of the loop index. \nFig.1shows severalexamplesof such simple programs , which will be used throughout the paper. Second, \nwe consider a restricted class of properties: while a quite general kind of property about arrays A1,A2,...,Am \ncould be written .e . D, .(A1[f1(e)],...,Am[fm(e)],x1,...,xp) (1) where D is somesetofvaluesfor indices, \n. is some scalar property about content values, f1,...,fm are general index functions, and x1,...,xp \nare scalar variables, we will only consider properties of the form .e . I,.(A1[e + k1],...,Am[e + km],x1,...,xp) \n(2) where I is an interval, and k1,...,km are integer constants. For instance, our method will discover \nautomatically the follow\u00ad ing properties: at the end of Array maximum (Fig. 1.a): .e . [1, n], A[e] = \nmax (3) at the end of Array copy (Fig. 1.b): .e . [1, n], A[e] = B[e] (4) at the end of Insertion sort \n(Fig. 1.c): .e . [2, n], A[e] = A[e - 1] (5) So, in spite of severe restrictions both on programs and \nproperties, our method allows interesting properties to be found about non trivial programs. Related \nwork: The automatic analysis of properties of array con\u00adtents was considered only recently. [BMS06, IHV08] \nstudy de\u00adcidable logics for expressing such properties. If we restrict our\u00adselvesto automatic analysis,an \nimportanttrackinitiatedby[FQ02] concerns veri.cation of programs with arrays using predicate ab\u00adstraction \n[LBC03, LB04], possibly improved with counter-example guided re.nement [BHMR07] and Craig interpolants \n[JM07]. All these approaches make use of the property to be proved, while we aim at discovering properties. \nConcerning automatic program analysis methods based on a abstract interpretation, a general common approach \n[BCC+03, GMD+04] is by summarizing a collection S of variables with one auxiliaryvariable, say s,managed \nto satisfy the disjunction of prop\u00aderties of variables in the collection: if s satis.es a property . \nso do all the variables v . S. In [BCC+03], this approach is called array smashing : all the cells of \nan array A are subsumed by one variable a, of the same max := A[1] ; for i := 2 to n do if max <A[i] \nthen max := A[i] for i := 1 to n do A[i] := B[i] a. Array maximum b. Array copy  for i := 2 to n do \nx := A[i];j := i - 1 ; while j = 1 and A[j] >x do A[j + 1] := A[j] ;( ) j := j - 1 A[j + 1] := x c. Insertion \nsort x := A[1] ;i := 2 ;j := n ; while i = j do if A[i] <x then A|i - 1] := A[i] ; i := i +1 else while \nj = i and A[j] = x do j := j - 1 if j>i then A[i - 1] := A[j];A[j] := A[i] ; i := i +1 ;j := j - 1 A[i \n- 1] := x ; d. Find: segmentation phase of the QuickSort A[1] := 7 ; for i := 2 to n do A[i] := A[i - \n1] + 1 e. Sequence initialization A[n] := x ;i := 1 ; while A[i] = x do i := i +1 f. Sentinel s := n \n+1 ; for i := 1 to n do if s = n +1 and A[i] =0 then s := i g. First not null Figure 1. Some simple programs \ntype asthe cells. Initially, a is given the strongest known property satis.ed by all the initial values \nof the cells of A. Each assignment A[i] := e to an array cell is replaced by a weak update of the auxiliary \nvariable: the weak update of an expression e to a variable a (it will be noted a U= e)canbe interpreted \nasa non deterministic choice betweenkeeping a unchanged and actually performing the assignment (or strong \nupdate) a := e. For instance, if all the cells of an array A are known to satisfy some property ., and \nif the expression e is known to satisfy .', then after an assignment A[i] := e all the cells of A are \nknown to satisfy . U .' (where U is the least upper bound operator on properties), which is exactly the \neffect of a weak update a U= e, if a is known to satisfy . before. The problem with this approach is \nthat the weak assignment can only lose information; moreover tests on individual cells don t bring any \ninformation. One needs to know (i.e., the user has to provide) an initial property satis.ed by all the \narray cells, and the analysiscanonlyweakenthisinitialknowledge.Asaconsequence, the results are generally \nvery unprecise. [GRS05, Gop07] proposes a signi.cant improvement, by par\u00adtitioning the index domain (say, \n[1..n])into several symbolic in\u00adtervals (e.g., I1 = [1 .. i -1], I2 =[i, i], I3 =[i+1 .. n]), and associating \nwith each subarray A[Ik] a summary auxiliary variable ak, managed so that .(ak) . .(A[e]), .e . Ik (6) \nIn order to reduce the loss of information due to weak updates, each cell A[i] appearing in the left-hand \nside of an assignment or in a test constitutes a singleton in the partition, so the assignment can be \ninterpreted as a strong update of the corresponding sum\u00admaryvariable. This techniqueis ableto discover \nour property(3)at the end of the Array maximum program. Concerning the Array copy , if we know that all \nthe cells of B are positive, it can deduce that so are all the cells of A after the copy. So, the method \nis much more effective in discovering global properties of array contents. However, it cannot discover \nrelations between the contents of dif\u00adferent cells.For instance,itisnotabletodiscoverthat A[e]= B[e] \nfor all e (property (4)) at the end of Array copy . The paper pro\u00adposes a technique to check such properties, \nwhich succeeds for our properties (4) and (5),but these candidate invariants must be pro\u00advidedby the \nuser. While in our property scheme (2), the indices will be quanti.ed over intervals chosen in a .xed \npartition like in [GRS05, Gop07], [GMT08] considers more general pointwise properties of the form .e, \n.(e) . .(A[e] ...). This generality involves dif.culties, since in such properties, assumptions . on \nindices must be under\u00adapproximated. Moreover, the user must provide some template for the properties \nthat should be discovered. [BBH+06] deals with the same kind of problems in a quite different context, \nwhich is the analysis of data-sensitive programs manipulating single linked lists. The considered data \nstructure is rather different, and the method is specialized to ordering relations. Moreover, as for \nCousot s parametric abstract domains [Cou03], the considered propertiesexpress relations between all \nthe elements of two data collections, while the essence of our approach is to express pointwise relations. \nContribution: Our main contribution, in the present paper, is to propose a fully automatic method to \ndiscover relations be\u00adtween array cells.For that, we use the same partitioning approach as [GRS05, Gop07],but \nthe auxiliaryvariables ak are not summary variables (let us call them slice variables), they are interpreted \nin a much more restrictive sense: we generalize the interpretation (6) by giving the following sense \nto relations between slice variables: .(ak,bk) . .(A[e],B[e]), .e . Ik (7) Moreover, we will introduce \nshift variables, representing .xed translations of array slices, in order to be able to express relations \nlike .(A[e],A[e + k1],B[e + k2]), .e . I as announced at (2). The paperisorganizedas follows:in Section2,wegivea \nbetter intuition of the method, by dealing informally with the Array copy example. Section3makes precisethekindof \nprogramswe consider, and Section 4 de.nes the abstract properties we shall deal with. All necessary operations \non these properties are de.ned in Section 5. Section 6 describes our prototype implementation and theexperiments \nperformed.We conclude the paper with some perspectives. 2. An Intuitive Example We .rst give a very informal \nintuition of the method. Let us con\u00adsider the program Array copy of Fig. 1.b. As in [GRS05], since there \nis an assignment to A[i], the set [1,n] of index values is split into three intervals: I1 = [1, (i - \n1)] ,I2 =[i, i] ,I3 = [(i + 1),n] and with each array, we associate three slice variables, say: A . (a1,a2,a3) \nB . (b1,b2,b3) which take their values in the same set as array contents. As said before, a property \n.(ak) should be understood as .e . Ik,.(A[e]). Remarks: 1. If Ik is empty (e.g., I1 when i =1), .(ak) \nis true for all . (in particular false). 2. Intervals Ik are symbolic; in particular, the emptiness \nof Ik depends on the value of the index i.  With these auxiliary variables, interpreted in that way: \n the assignment A[i] := B[i] can be abstracted into a2 := b2  when i is incremented, its previous value \nmoves from I2 to I1, and its current value is extracted from I3 to become the only element of I2. So, \nthe index incrementation involves  a weak update (a1,b1) U= (a2,b2); the assignment is weak because \nI1 is not a singleton. an assignment (a2,b2) := (a3,b3), which is strong because I2 isa singleton(Thisjustan \nintuitive justi.cation.Infact, such a strong assignment would result in the property a2 = a3, which makes \nno sense according to formula (7) since it relates variables corresponding to distinct intervals with \ndifferent size. The actual interpretation is more complex, see \u00a75.5). In summary, instead of considering \nthe initial program with arrays, we can analyze the following program without arrays: 1 i := 1 ; 2 while \ni = n do 3 a2 := b2 ; 4 i := i +1 ; 5 (a1,b1) U= (a2,b2) ; 6 (a2,b2) := (a3,b3) and interpret, in the \nresults, the properties of (ak,bk) as de.nedby formula (7). Let us assume that classical analyses are \navailable, which take into account simple inequalities of indices (e.g., difference bound (program) ::= \n(statement) (statement) ::= (left-part) := (C-exp) | i := (Iexp) | for(i := (Iexp);(cond);(progress)) \n(statement) | if (cond)(statement)(statement) |(statement) ;(statement) (left-part) ::= x | A[(Iexp)] \n(Iexp) ::= k | n | i |(Iexp) + k (cond) ::= (Icond) |(Ccond) |(cond) and (cond) |(cond) or (cond) (progress) \n::= ++ | -- Figure 2. The syntax of simple programs matrices [Dil89] or octagons [Min01]), and equalities \nof array con\u00adtents: so, after the assignment a2 := b2 , we know that a2 = b2. Now, the analysis of our \nprogram without arrays provides: At the .rst iteration: Afterline 2: i =1, which implies I1 = \u00d8, so false(a1,b1) \n(cf. remark2above). after line 3: i =1, false(a1,b1), (a2 = b2) after line 6: i =2, (a1 = b1), (a2 = \na3), (b2 = b3), since false(a1,b1) U (a1 = b1)=(a1 = b1); At the second iteration: at line 2, the property \non i is widened to 1 = i = n +1, and a least upper bound is taken on other properties, giving 1 = i = \nn +1, (a1 = b1). after line 3: 2 = i = n, (a1 = b1), (a2 = b2) after line 6: 2 = i = n, (a1 = b1), (a2 \n= a3), (b2 = b3), and the iteration converges; So, the .nal result at the end of the program is (i = \nn + 1), (a1 = b1), which can be interpreted as the expected result (i = n + 1), .e . [1,i - 1],A[e]= \nB[e]. 3. Simple Programs For simplicity,we assume that programs manipulate only data types integer (for \nindices), content (an arbitrary type), and array of content . The following sets will be considered (with \nassociated meta-variables): Integer constants: Z(3 k)  Integer parameters(ornon assignableintegervariables,usedfor \nparametric array size): Params(3 n)  Integer variables: Indices (3 i, j)  Content constants: C  Content \nvariables: CVars (3 x, y)  Array variables: Arrays (3 A, B)  3.1 Syntax Fig.2givesthe abstractsyntaxofoursimple \nprograms.Someofthe imposed restrictions are just for simplicity, others are necessary for the analysistogivegood \nresults.As usualin abstract interpretation, a more general language canbe considered, eitherby de.ning \nspe\u00adci.cextensionstothe analysis,orbyabstractingawaytheextended features. [[.]]: (statement) . States \n. States (Cexp) . States . C (Iexp) . States . Z (cond) . States . B [ x := (C-exp)]](I, C, A)=(I, C[[[(C-exp)]](I, \nC, A)/x], A) [ i := (Iexp)]](I, C, A)=(I[[[(Iexp)]](I, C, A)/i], C, A) [ A[(Iexp)] := (C-exp)]](I, C, \nA)=(I, C, A[F/A]) j A(A)(z) if z [ (Iexp)]](I, C, A)= where F = .z. [ (C-exp)]](I, C, A) otherwise [ \nfor(i:=(Iexp); (cond); (prog))(stat)]](I, C, A)= [ while(cond)(stat)i(prog)]](I[[[(Iexp)]](I, C, A)/i], \nC, A) [ while(cond)(stat)i(prog)]](I, C, A)= j (I, C, A) if [ (cond)]](I, C, A)= false [ (stat); i(prog); \nwhile(cond)(stat)i(prog)]](I, C, A) otherwise [ i ++]](I, C, A)=(I[(I(i) + 1)/i], C, A) [ i --]](I, C, \nA)=(I[(I(i) -1)/i], C, A) [ if(cond)(stat1)(stat2)]](I, C, A)= j [ (stat1)]](I, C, A) if [ (cond)]](I, \nC, A)= true [ (stat2)]](I, C, A) otherwise [ (stat1); (stat2)]](I, C, A)= [ (stat2)]]([[(stat1)]](I, \nC, A)) Figure 3. Semantics of simple programs We ignore the declarations, so a program is simply a (se\u00adquence \nof) statement(s). Statements can be assignments to con\u00adtent variables or array elements (the syntax of \ncontent expres\u00adsions (C-exp) is left unspeci.ed, since it depends on the content type), assignment to \ninteger variables (which must not be loop indices), for loops (which are restrictions of C-like for con\u00adstructs: \nin the initialization of the loop index i := (Iexp) , the expression (Iexp) may not depend on i; the \nloop progress state\u00adment can only be an index incrementation(++)or decrementa\u00adtion(--); the loop index \nmay not be assigned inside the loop), conditionals, and sequences. The syntax of for loops is con\u00advenient \nto express the wanted restrictions, but for detailing the analysis of examples, such loops will often \nbe decomposed into i := (Iexp); while(cond){(statement); i(progress)} . Index ex\u00adpressions are restricted \nto constants or parameters and sums of an index or parameter and a constant. Conditions are conjunctions \nand/or disjunctions of atomic conditions, whose syntax will depend on the lattices used in the analysis \n(see \u00a74.1): theconditions on con\u00adtents are supposedtoexpressat least equalities (e.g., x = A[i+1]), those \non indices are supposed to express at least potentials (e.g., i = j - 3).  3.2 Semantics Arrays will \nbe indexed from 1 to m, where m is the size of the array. We are concerned with the analysis of array \ncontents, not with array bound checking, which we assumetobe solvedby other means. As a consequence, \nwe don t want to bother about access out of bounds. This is re.ected by considering an array value to \nbe a function Z . C. from all relative integers to the domain of contents completed witha . element: \nof course, an array value A is restricted to return a non . value exactly on an interval [1,m]. Let States \ndenotethesetofstatesofaprogram.Astateisatriple (I, C, A), where I :(Indices . Params) . Z is a valuation \nfor indices and parameters, C : CVars . C is a valuation for content variables, and A : Arrays . (Z . \nC.) is a valuation for arrays. The semanticsof statementsis describedinFig.3as functionsfrom States to \nStates. 4. Array Content Properties 4.1 Lattices Throughoutthe paper,we assumetheexistenceoftwoanalyses,the \nformer concerning the behavior of indices, and the later concerning contents. In some sense, our method \nis parameterized by these analyses: The analysis of indices is based on a lattice (LZ, .Z,nZ, UZ, TZ, \n.Z) of properties over the set Indices of index variables. Elements of LZ will be noted f. LZ must be \na relational lattice, at least as powerful as potential constraints (i.e., systems of inequalities of \nthe form i - j = k, k1 = i = k2, often implemented as Difference Bound Matrices [Dil89, ACD93]), and \nde.ning convex properties. Candidates for LZ are potential constraints, octagons [Min01], octahedra [CC04], \nor polyhedra [CH78]. In this paper we will consider LZ to be the lattice of potential constraints.We \nwill also use an extension LZ ' of LZ, expressing properties over Indices .{e}, where e is a new special \nvariable (used for quanti.cation). Elements of LZ ' will be noted .. The same notations will be used \nfor operations in LZ and L ' Z, and LZ will often be implicitly plunged into L ' Z.  The analysis of \ncontents is based on a lattice (LC, .C,nC, UC, TC, .C), of which we only assume that it is able to express \nequality relations. Elements of LC will be noted ..  In many classical examples, it happens that array \ncontents are numbers. In that case, we can choose LC = LZ, but this choice is not compulsory. 4.2 Partitions \nFollowing [GRS05], our method relies on the choice of a symbolic partitionof the index domain.We formalize \nsuch a partition asa .nite set P =(.p)p.P of properties in L ' Z, such that '' UZ.p = TZ , .p, p . P, \n(p = p ) . .p nZ .p' = .Z p.P Elements .p of a partition will be called slices. An example of partition \nis .0 =(i< 1) .1 =(e< 1 = i = n) .2 = (1 = e<i = n) .3 = (1 = e = i = n) .4 = (1 = i<e = n) .5 = (1 = \ni = n<e) .6 =(n<i) A different partition will be considered for each loop in the pro\u00adgram. The choice \nof the partition, for a given loop, is performed automatically from the text of the program according \nto the follow\u00ading rules: (i) the partition of a nested loop should re.ne the partition of the outer loop; \n (ii) for a loop for(i := Iexp; cond; ++) , the partition should distinguish the cases (e< Iexp) and \n(e = Iexp);conversely, for a loop for(i := Iexp; cond; --) , the partition should distinguish the cases \n(e> Iexp) and (e = Iexp).  (iii) for each A[Iexp] appearing either in the left part of an as\u00adsignment, \nor in a condition, the partition should distinguish be\u00adtween (e< Iexp), (e = Iexp), and (e> Iexp). In \npractice, a partition doesn t have to cover the whole domain of indices: it is enough that it covers \nall the valuations that are reach\u00adable during the program execution; in particular, the cases where e \nis outside the array bounds are not considered.Apreliminary anal\u00adysis of the indices generally provides \na restricted domain for each f =0 = j = i - 1, 2 = i = n .1 = (1 = J <j<i) .1 = TC .2 = (1 = j = J <i) \n.2 = TC 0 .3 = (1 = j +1= J <i) .3 =(a>x) .4 = (2 = J <j<i) .4 =(a0 = a-1) .5 = (2 = j = J <i) .5 =(a0 \n= a-1) .6 = (2 = j +1= J <i) .6 =(a0 > x,a0 = a-1) .7 = (1 = j +1 <J <i) .7 =(a0 = a-1 >x) 0 .8 = (2 \n= J = j +1= i) .8 =(a= x) .9 = (1 = j +1 <J = i) .9 =(a0 = a-1 >x) .10 = (1 = j +1 = i, 2 = i<J) .10 \n= TC Figure 4. Example of abstract value for insertion sort loop.The left columnofFig.4showsa realisticexampleof \nparti\u00adtion, where, since it is known that 0 = j<i = n +1, situations like i = 0 or j = i are not considered. \nRemarks: Although a slice .p in a partition is intended to specify an interval for the speci.c variable \ne, this interval depends on the valuation I of indices.  Moreover, .p may involve constraints on I.We \nwill note .p the property .e..p which summarizes the constraints on indices in the slice .p.  As soon \nas an equation (e = Iexp) appears in the de.nition of a slice, the slice is a singleton: for any I there \nis at most one e in the slice. Singleton slices play an important role, because their corresponding slice \nvariables may be dealt with as scalar variables.We note Single(P) the set of singletons in P.  Slice \ncompatibility: Let s recall that .p denotes the constraints on indices involved by a slice .p. Now, if \n.p n .p ' = .Z, the slices .p and .p ' induce contradictory constraints, so these slices cannot be both \nnon-empty in a same state. There are said to be incompatible. We shall use a notion of compatibility \nrelative to some formula f on indices: two slices .p and .p ' will be said to be f-compatible, if and \nonly if f n .p n .p ' = .Z.  4.3 Abstract Values As announced in the introduction, our analysis will \nmake use of slice variables, possibly shifted. The choice of these variables will beexplicited later,butwe \nalready assumetheexistenceofa .nite set {a z} of slice variables: this notation associates uppercase \nlet\u00adters (e.g., A, B)for arrays, with lowercase letters(a, b)for slice variables; the exponent z is a \nrelative integer, called the shift.For a given valuation I of index variables and a given slice .p, the \nslice variable a z represents the subarray {A[e + z] | .p(I,e)}. Remark: the disappearance of the subscript \np, referring to a sym\u00adbolic slice,on slicevariablesis not ashortcut. As we sawduring the analysisof our \nintuitiveexample(\u00a72), we are interested in the join of properties linked to different symbolic slices \n(e.g., weak update). If these properties use the same slice variables, the join operation canbe performedina \nclassical lattice (here LC).In theexample,in place of joining a1 = b1 and a2 = b2 the join will be between \ntwo identical properties a 0 = b0 . Given a partition (.p)p.P and a set of slice variables {a z}, an \nabstract value . consists of a property f . LZ of index variables  a tuple (.p)p.P of properties(. \nLC)of slice variables and content variables.  The concretization .(.) of an abstract value . is a set \nof states (.(.) . States)de.ned as follows: 8 < f(I) (I, C, A) . .(.) . .p . P, .e such that .p(I,e): \n.p[A[e + z]/az](C, A) (in the formula above, .p[A[e + z]/az](C, A) means that (C, A) satisfy the formula \n.p where eachvariable a z has been replacedby A[e + z]). Example: Fig. 4 shows the abstract value associated \nwith the entry of the inner loop of the insertion sort (Fig. 1.c) at the end of the analysis.For instance, \n(.7,.7) expresses that .e, (1 = j +1 <e<i) . A[e] = A[e - 1] > x. WenoteVars(.p) the setofvariables appearingin \n(i.e., constrained by) .p. For each partition P, the set of abstract values forms a lattice (LA(P), A, \nnA, UA, TA, .A). The lattice operations and all other necessary operationson abstractvalues are describedinthe \nfollow\u00ading section. 5. Operations on Abstract Values 5.1 Normalization An abstract value .=(f, (.p)p.P \n) is a complex object which mustbekept consistent.For instance,ifits concretizationis empty, it should \nbe normalized to .A. There are other needs for normal\u00adization, which are taken into account by the following \nconditional rewriting rules: 1. (empty slice) As said before, when a slice .p is empty, the corresponding \n.p can be anyformula, in particular the strongest one .C. Hence the rule: (f nZ .p = .Z) . .p ..C. 2. \n(unsatis.able index property) If f is not satis.able, .(.) is empty: f = .Z . . ..A. 3. (consistency \nof constraints on scalars) The knowledge about scalar contents variables in each .p should be propagated \nto all slices f-compatible slices with .p. For instance, after the assignment x = A[i] , in the slice \n[i, i] we know that x has the same properties than A[e]. The part of this knowledge that does not depend \non e (e.g., x = 0)must be propagated to slices [1,i - 1] and [i +1,n]. Let Sc(.p) be the projection of \n. obtained by existential quanti.cation of all slice variables a z . Then ( .p nZ f) Z .p ' . .p . .p \nnC Sc(.p ' ). Fig.5 shows an abstractvalue on partition {.1 = (1 = e< i = n),.2 = (1 = e = i = n),.3 \n= (1 = i<e = n)}, followed by the result of the application of the rule. Such an abstract value will \nappear for instance, in the program i := 1;x := 5; for i := 1 to n do x := x +1 at the head of the loop. \n4. (consistency of shifts) If some z-shift of a slice .p is in\u00adcluded inside another slice .p ' , the \nconstraints on a -z in .p ' should apply to a 0 in .p. For instance, if we know that .e . [2,n],A[e] \n= A[e - 1], we may conclude that .e . [1, 1],A[e] = A[e + 1]; that is, for .1 =(e = 1) and .2 = (2 = \ne = n), if .2 implies (a -1 = a 0) then .1 should imply (a 0 = a 1). Let us note .p . z = .p[e - z/e] \nand .1 .2 .3 i .1 = (x = 6) f =(i = 1) .2 = (x = 5) .3 = (n +5 = x = 5) .1 =(i = 2) normalization .2 \n=(i = 1) .1 = (n +5 = x = 6) .3 =(i = 1) .2 = (n +5 = x = 5) .3 = (n +5 = x = 5) Figure 5. Example for \nconsistencyof scalars properties .p ' E z = .p ' [ay-z/ay]. Then the .rst rule for consistencyof shift \nis .p . z Z .p ' . .p . (.p nC (.p ' E z)). In theexample above, .1 . 1=(e = 2) Z .2, so .2 must be strengthened \nwith (a -1 = a 0) E -1=(a 0 = a 1), as desired. There is a second rule when the reverse inclusion also \nholds: .p ' Z .p . z . .p ' . (.p ' nC (.p E -z)). For instance,this rule will be applied in the normalization \nphase of Fig. 8, where .1 =(e = i) .2 =(e = i + 3) 00 -3 .1 =(a = x) .2 =(a = a ) we have .2 .-3= .1, \nso both .1 and .2 are rewritten: 0300 -3 -3 .1 . (a = x, a = a ) ,.2 . (a = a ,a = x). To make the rules \nreadable, we discarded the use of f. However, better results are obtained if the slices appearing in \npremises of the rules are intersected with f. For instance, consider the partition of Fig.5with f =(i \n= 2). Then we have (.1 nZ f) Z ((.2 .-1) nZ f) and .1 could be strengthened. Of course, these rules in.uence \neach other. By chance they can be applied step by step, in reverse order w.r.t. the list above (i.e., \napply thoroughly the rule (4), then apply thoroughly the rule (3), etc.). Henceforth, we will assume \nthat all abstract values are normalized. Proposition. Normalization does not changethe concretizationof \nformulas: . . . ' . .(.) = .(. ' ) 5.2 Lattice Operations After normalization, the lattice operations \nare straightforward. They are de.ned on abstract values based on the same partition: '' '' (f, (.p)p.P \n) nA (f, (.p)p.P )=(f nZ f, (.p nC .p)p.P ) '' '' (f, (.p)p.P ) UA (f, (.p)p.P )=(f UZ f, (.p UC .p)p.P \n) '' ' . A . .. f Z f ..p . P, .p C .p 5.3 Change of Partition When enteringa loop,anewindex i is introduced, \nand the partition is re.ned accordingtothisindex.Conversely,whenaloopisexited, itsindexisforgotten,andthe \npartitionis simpli.ed accordingly.We need operations for transforming an abstract value . on a partition \nP to an abstract value . ' =[P.P ' ](.) on a partition P ' that i re.nes P, and the converse operation, \nnoted [P ' .P] which also ' (. ' forgets about the index i. If P = p)p.P ' is a re.nement of Figure \n6. Example for slice property P =(.p)p.P , then, for every p . P ', there exists f(p) . P such that . \n' p Z .f(p). Then, for .=(f, (.p)p.P ) . LA, we de.ne [P.P ' ](.) = (f, (.f(p))p.P ' ) conversely, for \n. ' =(f ' , (.p' )p.P ' ) we de.ne i' [P.P ](. ' )=(.i.f ' , (Up=f(p ' ).p ' )p.P ) 5.4 Slice Property \nGiven a symbolic interval . . L ' Z and an abstract formula . . LA(P), we want to extract the strongest \nproperty ..(.) implied by . on .. Of course, if there exists p . P such that . = .p, ..(.) is simply \n.p. However, the operation is more tricky and interesting when . intersects several slices in P. The \n.rst idea is to takethe least upper bound of the properties of these slices. However we shall see that \nadditional information canbegained from shifted variables. We de.ne: Inter.(.)= {p .P | .p nZ . nZ f \n=.Z} z Trans.(.)= {(p, z) | a . Vars(.p) and .p . z nZ . nZ f = .Z} Then we de.ne ..(.)= Up.Inter.(.).p \nn n(q, z) . Trans.(.) .q E -z .p n . n f C .q . z n f Weexplainthiscomplexformulabymeansofasmallexample(see \nFig. 6): the partition is {.1 =(i = e),.2 =(i<e)}, the abstract formula . = (1 = i, {.1 =(a 0 =4,a 1 \n= 5),.2 = (5 = a 0 = 10)}).For . =(i = e = i + 1), we have Inter.(.)= {1, 2} and Trans.(.)= {(1, 1)}.We \nget Up.Inter.(.).p = (4 = a 0 = 10). If we take also into account the translated slices intersected by \n. (we have (. nZ .2) Z .1 . 1)we get the more precise result . = (4 = a 0 = 5). 5.5 Index Progression \nLet us consider index incrementing (the decrementing being sym\u00admetrical). When an index i is incremented, \nthe subarray represented by a slice .p involving i changes. Let us note . ' p = .p[i +1/i]. Thanks to \nthe operation de.ned in the previous subsection, we can compute the property .p ' = ..(. ' p) , which \nis the property to be satis.ed within .p after the assignment. So, we can de.ne \u00ab [i ++]A(.)= [i ++]Z(f),..(.p[i \n+1/i]) . p.P For instance, Fig. 7 represents a property with partition {.1 = (1 = e<i = n),.2 = (1 = \ne = i = n),.3 = (1 = i< e = n)}, and f = (1 = i = n),.1 = (0 = a 0 = 4),.2 =(a 0 = 6),.3 =(a 0 >a-1). \nThen, . ' 1 = (1 = e<i +1 = n),. ' 2 = (1 = e = i +1 = n),. ' 3 = (1 = i +1 <e = n).We get [i++]A(.) \n= (f = (2 = i = n+1),.1 = ..(.1' ) = (0 = a 0 = 0 -10 -1 6),.2 = ..(.2' )=(a >a),.3 = ..(.3' )=(a >a). \n Figure 7. Example for index progression 5.6 Loop Index Initialization Index initialization i := Iexp \nonly occurs when entering a loop. So, it is applied just after the re.nement of the partition (cf. \u00a75.3), \nand nothing is known about i before the assignment.So the trans\u00adformation is just [i := Iexp]A(.) = (f \nn (i = Iexp), (.p)p.P ) . 5.7 Content Assignment A content assignment of an expression exp, affects \nseveral slice formulas, in which the modi.ed slice variable will be different, the update willbe applied \nstrongly or weakly,and expwill be translated in terms of slice variables in accordance. First, we address \nleft part issues: Left part: In case of a scalar assignment x := exp, the variable x must be strongly \nupdated in all .p.  In case of an array cell assignment A[i + k] := exp, we know that there are singleton \nslices .s where (e = i + k). In the corresponding .s, a 0 must be strongly assigned. We call Strong1 \nthe set of such s. Moreover, for each s . Strong1, there can be also other slices .p, f-compatible with \n.s, such that there is some a z . Vars(.p) and .p . z intersects (in fact, contains) .s. We call Affect(.s) \nthe set of such p. If p . Affect(.s), .p refers to a shift variable which may be aliased with the assigned \nvariable: if .p is a singleton, a z must be strongly assigned, otherwise it must be weakly assigned in \n.p. So, we de.ne  Strong1 = {s . P | .s Z (e = i + k)} Affect(.s)= {(p, z) | a z . Vars(.p),.s Z .p \n. z} Strong = {s ' . Single(P) |.s . Strong1, .z . Z, (s ' ,z) . Affect(.s)} Weak= {p . P \\ Single(P) \n|.s . Strong1, .z . Z, (p, z) . Affect(.s)} Scalar right part: When the right part exp does not contain \nany array access, the postcondition of the assignment is easy to com\u00adpute. Let us note .p ' the slice \nformulas of [Left = exp]A(.). If the left-hand side is scalar,then .p, . p ' =[x := exp]C(.p). Otherwise, \nwith the notations de.ned above: .s . Strong1, .s ' =[a 0 := exp]C(.s) z .s . Strong, (s, z) . Affect(.s \n' ),. s ' =[a :=exp]C(.s) z .p .Weak, (p, z) .Affect(.s ' ),. p ' = .p UC[a := exp]C(.p) Right part with \narray accesses: Without loss of generality as\u00adsume the right part of the assignment is an expression \nB[j + k] (more complex expressions may be reduced to this case using aux\u00adiliary scalar variables and \nsuccessive assignments). If the left-hand sideisa scalarvariable x,itsnewvalue mustbe computedfor each \nslice. If it is an array cell, we have to perform weak or strong as\u00adsignments in some slice property \n.p to some slice variable a z , p belonging either to Strong1, or to Strong, or to Weak. So, we want \nto get the strongest information about B[j + k] available in some slice .p.Two cases occur: .1 .2 .3 \nii+3 .1 = (a 0 = x) .2 = (a 0 >x) .3 = (a 0 > x,a-1 > x,a0 = a -1) content assignment A[i + 3] := A[i] \n.1 = (a 0 = x) -3) .2 = (a 0 = a .3 = (a 0 > x,a-1 = x, a 0 = a -1) normalization 0 033 .1 = (a = x, \na = a ,a = x) -300 -3) .2 = (a = x, a = x, a = a .3 = (a 0 > x,a-1 = x, a 0 = a -1) Figure 8. Example \nfor content assignment either .p(e) implies j + k = e + w, for some w, in which case, B[j + k] is represented \nby a shift variable bw: if .p nZ (e ' = j + k) implies e ' = e + w for some w, then [A[i] := B[j + k]]A(.p)=[a \nz := bw]C(.p) otherwise, we extract the scalar information about B[j + k] using our slice property operation(\u00a75.4), \nas follows: the formula . = ..((e = j + k) nZ f nZ .p ) gives for b0 the best information about B[j + \nk] for the slice .p ((e = j + k) is f-compatible with .p), so . ' = Sc(.[y/b0]), where y is a fresh scalarvariable,givesthewanted \ninformation for y. Then the result is obtained in a similar way as for a scalar right part reduced to \ny: [x := B[j + k]]A(.p)= .y.[x := y]C(.p nC . ' ) Let . ' =(e = j + k);Fors . Strong1, [A[i] := B[j + \nk]]A(.s)= .y.[a 0 := y]C(.s nC . ' ) where . ' = Sc(..(. ' nZ f nZ .s )[y/b0]). Fors . Strong, (s, z) \n. Affect(.s ' ), [A[i] := B[j + k]]A(.s)= .y.[a z := y]C(.s nC . ' ) where . ' = Sc(..(. ' nZ f nZ .s \n)[y/b0]). Forp . Weak, (p, z) .Affect(.s ' ), [A[i] := B[j + k]]A(.p)= .p UC [a z := y]C(.p nC . ' ) \nwhere . ' = Sc(..(. ' nZ f nZ .p )[y/b0]). Example: On the example shown in Fig 8, we perform the as\u00adsignment \nA[i + 3] := A[i]. We have s =2, Affect(.s)= {(2, 0), (3, -1)}, Strong1 = {2}, Strong = {2}, Weak= {3}. \nSo, . ' 0 -30 -3 2 = .2[a := a ]C(.2)=(a = a ).To compute .3, we have .rst to compute . ' = Sc(..((e \n= i) nZ f nZ .3 )[y/a0]) = (a 0 = x)[y/a0]=(y = x), and then .3 ' = .3 UC [a -1 := -10 -10 y]C(.3 nC \n. ' )= .3 UC [a := y]C(a >x,a>x,a= -10 -1 00 a ,y = x,a >y,a>y)= .3 UC (a > x,y = x,a > -10 -1 -10 -10 \ny, a = y,a >a,a = x)=(a > x,a= x, a = a -1). The rest of the work is done by the normalization. Notice \nthat, in spite of the weak assignment, the property that the slice .3 is sorted is preserved. 5.8 Conditional \nstatements Let us note Cond(c, .) the strengthening of a formula .= (f, (.p)p.P ) by the knowledge that \nthe condition c is true. Ac\u00adcording to the syntax of our simple programs, a condition is ei\u00adthera formula \non indices, ora formula on contents (including array cells) ora conjunction ora disjunctionof conditions.We \nassume that an elementary condition only on indices is abstracted by a for\u00admula fc . LZ. Then, Cond(fc, \n.) = (f nZ fc, (.p)p.P ).For elementary conditions only on contents, let us note Cond(c, .) = (f, (Cond(c, \n.p)p.P )). If c does notinvolve anyarrayexpression, it is supposed to be a formula .c . LC on content \nvariables, and Cond(c, .p)= .p nC .c for all p. Otherwise, if A[i + k] appears in c, there are singleton \nslices .s Z (e = i + k), for which a represents A[i + k] in .s. As for the assignment, either other ar\u00adray \nexpressions in c can be expressed as translations of A[i + k], and replaced by some a z in c, or their \nproperties can be extracted using slice property operation and reported in c. Anyway, c is transformed \ninto a formula .cs . LC. Then, for slices s such that .s Z (e = i + k), Cond(c, .s)= .s nC .cs . Finally, \nfor conditions mixing conditions on indices and on contents, we use the classical lattice operators: \nCond(c or c ' , .) = Cond(c, .) UA Cond(c ' , .) Cond(c and c ' , .) = Cond(c, .) nA Cond(c ' , .) 5.9 \nSoundness of Operations Proposition. All the operations de.ned so far are sound, i.e., .., .(I, C, A) \n. .(.), .(I,e) . ..(.)[A[e + z]/az](C, A) [ i ++] (I, C, A) . [i ++]A(.) [ i := Iexp] (I, C, A) . \n[i := Iexp]A(.) [ x := exp] (I, C, A) . [x := exp]A(.) [ A[i + k] := exp] (I, C, A) . [A[i + k] := \nexp]A(.) if [ c] (I, C, A) . .(.) = true, then (I, C, A) . Cond(c, .).  5.10 Widening We assume that \na widening.Z is available in LZ.For LC we note .C either the widening in LC if any, or the least upper \nbound UC if LC is of .nite depth. Then, a natural de.nition for a widening operator in LA is `\u00b4` \u00b4 '' \n'' (f, (.p)p.P ) . f, (.p)p.P = f.Zf, (.p.C.p)p.P . Now, this operator is not completely satisfactory \nfor the follow\u00ading reason: when it happens that some slice .p is empty in . (i.e., f nZ .p = .Z)and not \nempty in. ', the corresponding slice prop\u00adertyiswidened from .C in the result (since .p = .C).In that \ncase, itis bettertowaitfortwomeaningful iterates before performingthe `\u00b4 global widening. So, we de.ne \n(f, (.p)p.P ) .A f ' , (.p' )p.P as 8` \u00b4 < f ' , (.p' )p.P if .p, f nZ .p = .Z and f ' nZ .p = .Z `\u00b4 \n: f.Zf ' , (.p.C.p' )p.P otherwise Proposition. .A is a widening (i.e., . UA . ' A ..A. ', and .A satis.es \nthe chain condition).  5.11 About Shift Variables The analysis introduces slice and shift variables \nat different steps: slicevariablesarecreatedatthe creationofnew partitions(.rsten\u00adtry in a loop); shift \nvariables are introduced during normalization (consistency of shifts) and assignment (array expression \nin right part). It is important to notice that, even if these variables are cre\u00adated during the analysis, \ntheir number remains bounded: theycan only appear during the .rst traversal of a loop, the next iterations \ncan only remove variables. 6. Implementation and Experiments The method has been implemented in OCaml \nfrom a generic analyzer due to B. Jeannet (see http://bjeannet.gforge.inria.fr/fixpoint/). When in\u00advoking \nthe prototype, one can choose the lattice for indices (intervals or potentials) or a domain for arrays \nwhich is a functor on the abstract domains(LZ and LC)assuming a .xed set of func\u00adtions on these domains. \nOf course, classical operations on lattices mustbeavailable,but also normalization functions, postcondition \nof assignment and condition, support (set of involved variables), and support extension/reduction. The \nprogram to be analyzed is givenasa control-.owgraph,ina language inspiredfromtheinput languageofFAST \n[BLP06]. The array content analysis takes place after some preliminary steps: 1. First, an index analysis \nis performed, which checks the array accesses w.r.t. array bounds, and computes invariants about index \nvalues at each control point of the program. 2. Second, an analysis of live variables is performed to \ndetermine the live indexes in each point 3. Finally, a traversal of strongly connected subcomponents \n(SC\u00adSCs)builds the partition attached with each SCSC, according to the strategy described in \u00a74.2.  \nThe results of these three analyses are merged to get, at each control point, the needed actions for \nchanging the partition (cf. \u00a75.3). The results of analysis (1) are f formulas that are used for simplifying \nthe partition. Only live variables are considered for partitioning. Then the analysis described in this \npaper is performed. Notice that for examples 1.f and 1.g, which use disequations over array cells in \ntheir conditions, we used the abstract domain of dDBM [PH07] as the lattice of properties over contents(LC). \nThis domain is an extension of the DBM one, handling disequations between pairs of variables. We give \nnow the results of this analysis on some examples: Insertion sort (Fig. 1.c),aversionof thefamous Find \nprogram (Fig. 1.d) used for segmenting arrays in QuickSort, a simple ini\u00adtialization sequence (Fig. 1.e) \nshowing properties mixing indices and contents when the same lattice is used (numerical arrays), a versionofthe \nSentinel program(Fig.1.f),whichisawell-known challengefor array bound checking,andaprograminvolvinganin\u00addexassignment: \nFirst not null ,extracted from [FQ02].Of course, simpler programs like Array maximum and Array copy (Fig1) \ngive the announced results, which we don tdetail here. Results for Find : Fig. 1.d shows a version of \nthe famous Find program [Hoa71], used for segmenting an array according to its .rst element, and used \nat each step of the QuickSort . The .nal results attachedbyour analyzertotheveryendofthe program are \nexactly those expected (i.e., the array is segmented): f = (2 = i = n +1,j = i - 1)  either n =1, then \ni =2 and A[1] = x  or n = 2 and A[i - 1] = x and .e, 1 = e<i - 1 . A[e] <x and .e, i = e = n . x = A[e] \nResults for Insertion sort : The result of the analysis at the end of the program is as simple as the \npartition at that point: .e, 2 = e = n . A[e - 1] = A[e]. A more interesting result is after the array \nassignment in the nested loop (( )point in Fig.1.c). The situation is: sorting is not terminated(i = \nn)and currentvalue in cell j is greater than the keyx, so we assign its value to cell j +1.We have: array \ncopy seq. init. max. search sentinel .rst n. null insert. sort .nd #vert.\u00d7 #edg. 3\u00d7 3 3\u00d7 3 5\u00d7 6 3\u00d7 3 \n6\u00d7 8 9\u00d7 11 9\u00d7 13 #.p 3 4 4 9 13 4-10 14 #shifts avg (max) 0(0) 0.8 (2) 0.8 (2) 0(1) 0(1) 4.6 (11) 6.7 \n(14) #iter. 5 5 5 5 6 7 6 time (s) 0.02 0.05 0.10 0.21 2.25 5.38 22.87 #norm. 30 32 58 28 89 169 171 \ntime (%) -54 50 22 50 85 74 norm. avg. time (s) /(#.p +#shifts) - 0.00016 0.00017 0.00019 0.00102 0.00153 \n0.00453 Figure 9. Performance results f = (1 = j = i - 1 = n - 1)  either j =1 then A[1] = A[2] >x \n moreover if i = 3 then .e, 3 = e = i, A[e] = A[e - 1] >x or j = 2, then .e, 2 = e < j,A[e] = A[e - \n1] and A[j] >x and A[j +1] = A[j] = A[j - 1] moreover if i>j +1 then .e, j +2 = e = i, A[e] = A[e - 1] \n>x Results for Sequence init. : At the end of the program, we get theexpected bound on array contents(= \nn +6): f = (1 = n = i - 1)  n = 1 . A[1] = 7 = n +6  moreover if n = 2 then .e, 2 = e = n . 8 = A[e] \n= n +6, 7 = A[e - 1] = n +5,A[e]= A[e - 1] + 1  Results for Sentinel : Amore surprising success is the \ndiscov\u00adery, in the program of Fig. 1.f, that the index cannot exceed the bound n:the sentinel x is either \nfound before or at n. At the end of the program we get: f =1 = i = n  A[i]= x and .e, 1 = e<i . A[e]= \nx  It is an interesting case where a property on contents involves a property on indices. Results for \nFirst not null : The program of Fig. 1.g, was given in[FQ02].The standard methodgivespoor results.However,ifwe \nenrich the partition by distinguishing the singleton (e = s) we get the expected property at then end \nof the program: f = (1 = s = i = n + 1)  s = n +1 . (.e, 1 = e = s - 1 . A[e] = 0)  moreover if s \n= n then A[s]=0  Performances: Experiments were driven on a Core2 Duo 1.6 GHz, with 2Mo of RAM. In Fig. \n9, the .rst part of the table shows, for each example, the size of the control-.ow graph (num\u00adber of \nvertices and edges), the size of the partition, the (average and maximum) numberof shiftvariables presentsin \nabstractvalues during the analysis, the number of iterations before convergence, and the total computation \ntime. If smallexamplestakelessthanahalfof secondtobe analyzed, analysis time sharply increases when more \nslices and shiftvariables are required. In order to con.rm this point, the second part of the table shows \nthe number of normalizations performed during the analysis. This number is directly linked to the number \nof abstract operations done, which is a good measure of the complexity of the program under analysis. \nBut it does not explain the hight time of the analysis of Find . The table indicates also the amount \nof time spent doing normalizations, which most often need more than half the total analysis time. Finally,itgivestheaverageof \nnormalization timedividedby the sumof the sizeof the partition and the number of shift variables. As \nexpected, the cost to maintain the coherence between slices is dominating, and seems to behave exponentially \nwith respect to the number of slices (compare Sentinel and First not null ), and the number of shift \nvariables (compare Find and First not null ). We know there is room for improvements, particularly focusing \non the design of a clever data structure for the partition. 7. Conclusion and Future Work We have presented \na method for automatically discovering prop\u00adertiesinvolving array contentsin simple programs. Thekey \nidea is to synthesize pointwise relations between array segments. The method is able to deal with problems \nwhich are well-known to be dif.cult. A prototype tool has been implemented and applied to some classical \nexamples, most of which, to our knowledge, were not managedby previouslyexisting methods. This work deserves \nto be extended in several directions. Our .rst task will be to improve our prototype implementation, \nboth concerning the performances and the .exibility; in particular, it should be made fully compatible \nwith the APRON interface (see http://apron.cri.ensmp.fr/library/), which would allow all compatible lattices \nto be used. A more clever choice of the partition would reduce the number of slices and variables. An \nimproved widening is also likely to reduce the number of iterations. Of course, more general programs \nmust be considered: on one hand, non convex slices should be dealt with to take into ac\u00adcount more than \nsimple index incrementation/decrementation; on the other hand, multi-dimensional arrays should be considered \nas well. We could make use of non-convex partitioning of multi\u00addimensional arrays as proposed in [Mas92]. \nAlso, we are notfar from analyzing programs like QuickSort,but our current prototype does not deal with \nrecursive programs. Concerning ourexamples, notice that generally we did not fully verify programs: for \narray maximum , we prove that the result is greater than all the array elements, it remains to prove \nthat it belongs to the set of elements; for insertion sort , we prove that the resultis sorted,it remainstoprovethatitisapermutationofthe \ninitial array, and similarly for .nd . So, it would be nice to design an analysis dealing with the (multi-)sets \nof array cell contents. A longer term perspective would be to generalize our abstract values for other \nuses: an array is a special case of function, so an interesting question is whether, using similar principles, \nwe could design an abstract domain for expressing function properties. Acknowledgments We are indebted \nto Tom Reps and Bertrand Jeannet for helpful discussions, and to the anonymous referees for their constructive \ncomments. References [FQ02] C. Flanagan and S. Qadeer. Predicate abstraction for software [ACD93] R. \nAlur, C. Courcoubetis, and D. L. Dill. Model-checking in dense real-time. Information and Computation, \n104(1):2 34, 1993. Preliminary version appears in the Proc. of 5th LICS, 1990. [BBH+06] A. Bouajjani, \nM. Bozga, P. Habermehl, R. Iosif, P. Moro, and T. Vojnar. Programs with lists are counter automata. In \nComputer Aided Veri.cation (CAV2006), pages 517 531. LNCS 4144, Springer Verlag, July 2006. [BCC+03] \nB. Blanchet, P. Cousot, R. Cousot, J. Feret, L. Mauborgne, A. Min\u00b4e, D. Monniaux, and X. Rival. Astatic \nanalyzer for large safety-critical software. In PLDI 2003, ACM SIGPLAN SIGSOFT Conference on Programming \nLanguage Design and Implementation, pages 196 207, San Diego (Ca.), June 2003. [BHMR07] D. Beyer, T. \nA. Henzinger, R. Majumdar, and A. Ry\u00adbalchenko. Path invariants. In J. Ferrante and K. S. McKinley, editors, \nPLDI 2007, pages 300 309. ACM, 2007. [BLP06] S. Bardin, J. Leroux, and G. Point. Tool presentation: Fast \nextended release. In 18th Conf. Computer Aided Veri.cation (CAV 2006), pages 63 66, Seattle (Washington), \n2006. LNCS 4144, Springer-Verlag. [BMS06] A. R. Bradley, Z. Manna, and H. B. Sipma. What s decidable \nabout arrays? In E. A. Emerson and K. S. Namjoshi, editors, VMCAI 06, pages 427 442. LNCS 3855, Springer \nVerlag, 2006. [CC76] P. Cousot and R. Cousot. Static determination of dynamic properties of programs. \nIn 2nd Int. Symp. on Programming. Dunod, Paris, 1976. [CC04] R. C. Claris and J. Cortadella. Veri.cation \nof parametric timed circuits using octahedra. In Designing correct circuits, DCC 04, Barcelona, March \n2004. [CH78] P. Cousot and N. Halbwachs. Automatic discovery of linear restraints among variables of \na program. In 5th ACM Symposium on Principles of Programming Languages, POPL 78, Tucson (Arizona), January \n1978. [Cou03] P. Cousot. Veri.cation by abstract interpretation. In N. Dershowitz, editor, Proc. Int. \nSymp. on Veri.cation Theory &#38;Practice Honoring Zohar Manna s 64th Birthday, pages 243 268, Taormina, \nItaly,June 29 July 42003. c&#38;#169; Springer-Verlag, Berlin, Germany. [Dil89] D. L. Dill. Timing assumptions \nand veri.cation of .nite state concurrent systems. In Workshop on Automatic Veri.cation Methods for Finite \nState Systems, Grenoble. LNCS 407, Springer Verlag, June 1989. [GMD+04] [GMT08] [Gop07] [GRS05] [Hoa71] \n[IHV08] [JM07] [LB04] [LBC03] [Mas92] [Min01] [PH07] veri.cation. In POPL 2002, pages 191 202.ACM, 2002. \nD. Gopan,F. Di Maio, N. Dor,T. Reps, and M. Sagiv. Nu\u00admeric domains with summarized dimensions. In TACAS \n04, pages 512 529, Barcelona, 2004. S. Gulwani, B. McCloskey, and A.Tiwari. Lifting abstract interpreters \nto quanti.ed logical domains. In G. C. Necula andP.Wadler, editors, POPL 2008, pages 235 246.ACM, 2008. \nD. Gopan. Numeric program analysis techniques with applications to array analysis and library summarization. \nPhD thesis, Computer Science Department, University of Wisconsin, Madison, WI, August 2007. D. Gopan,T. \nReps, andM. Sagiv.Aframework for numeric analysis of array operations. In Proc. of POPL 2005, pages 338 \n 350, Long Beach, CA, 2005. C. A. R. Hoare. Proof of a program: Find. CACM, 14(1):39 45, 1971. R. Iosif,P. \nHabermehl, andT.Vojnar. What elseis decidable about arrays? In R. Amadio, editor, FOSSACS 2008. LNCS, \nSpringerVerlag, 2008. R. Jhala and K. L. McMillan. Array abstractions from proofs. InW. Damm and H. Hermanns, \neditors, CAV2007, pages 193 206. LNCS 4590, SpringerVerlag, 2007. S. K. Lahiri and R. E. Bryant. Indexed \npredicate discovery for unbounded system veri.cation. In R. Alur and D. Peled, editors, CAV 2004, pages \n135 147. LNCS 3114, Springer Verlag, 2004. S.K. Lahiri,R.E. Bryant,andB. Cook.Asymbolic approach to predicate \nabstraction. InW. A. Hunt Jr. andF. Somenzi, editors, CAV 2003, pages 141 153. LNCS 2725, Springer Verlag, \n2003. F. Masdupuy. Array abstractions using semantic analysis of trapezoid congruences. In ICS 92: Proceedings \nof the 6th international conference on Supercomputing, pages 226 235,NewYork,NY, USA, 1992.ACM. A. Mine.\u00b4The \noctagon abstract domain. In AST 2001 in WCRE 2001, IEEE, pages 310 319. IEEE CS Press, October 2001. \n M.P\u00b4eronandN. Halbwachs.An abstract domainextending Difference-Bound Matrices with disequality constraints. \nIn B. Cook and A. Podelski, editors, 8th International Conference onVeri.cation, Model-checking, and \nAbstract Intepretation, VMCAI 07, Nice, France, January 2007.   \n\t\t\t", "proc_id": "1375581", "abstract": "<p>Array bound checking and array dependency analysis (for parallelization) have been widely studied. However, there are much less results about analyzing properties of array <i>contents</i>. In this paper, we propose a way of using abstract interpretation for <i>discovering</i> properties about array contents in some restricted cases: one-dimensional arrays, traversed by simple \"for\" loops. The basic idea, borrowed from [GRS05], consists in partitioning arrays into symbolic intervals (e.g., [1,<i>i</i> -- 1], [<i>i</i>,<i>i</i>], [<i>i</i> + 1,<i>n</i>]), and in associating with each such interval <i>I</i> and each array <i>A</i> an abstract variable <i>A</i><sub><i>I</i></sub>; the new idea is to consider <i>relational</i> abstract properties &#968;(<i>A</i><sub><i>I</i></sub>, <i>B</i><sub><i>I</i></sub>, ...) about these abstract variables, and to interpret such a property pointwise on the interval <i>I</i>: &#8704;<i>l</i> &#8712; <i>I</i>, &#968;(<i>A</i>[<i>l</i>], <i>B</i>[<i>l</i>],...). The abstract semantics of our simple programs according to these abstract properties has been defined and implemented in a prototype tool. The method is able, for instance, to discover that the result of an insertion sort is a sorted array, or that, in an array traversal guarded by a \"sentinel\", the index stays within the bounds.</p>", "authors": [{"name": "Nicolas Halbwachs", "author_profile_id": "81100642295", "affiliation": "Verimag - CNRS, Grenoble, France", "person_id": "P1022816", "email_address": "", "orcid_id": ""}, {"name": "Mathias P&#233;ron", "author_profile_id": "81351607813", "affiliation": "Verimag - CNRS, Grenoble, France", "person_id": "P1022817", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1375581.1375623", "year": "2008", "article_id": "1375623", "conference": "PLDI", "title": "Discovering properties about arrays in simple programs", "url": "http://dl.acm.org/citation.cfm?id=1375623"}