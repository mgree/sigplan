{"article_publication_date": "06-07-2008", "fulltext": "\n Certifying Low-Level Programs with Hardware Interrupts and Preemptive Threads XinyuFeng Zhong Shao \nYuan Dong \u00a7 YuGuo* YaleUniversity,NewHaven,CT06520-8285,U.S.A. ToyotaTechnological InstituteatChicago, \nChicago,IL 60637,U.S.A. \u00a7Tsinghua University,Beijing 100084, China *UniversityofScienceandTechnologyofChina,Hefei,Anhui \n230026,China feng@tti-c.org shao@cs.yale.edu dongyuan@tsinghua.edu.cn guoyu@mail.ustc.edu.cn Abstract \nHardware interrupts are widely used in the world s critical soft\u00adware systemstosupportpreemptivethreads,devicedrivers, \noperat\u00adingsystemkernels,and hypervisors.Handlinginterruptsproperly is an essentialcomponent oflow-level \nsystemprogramming.Un\u00adfortunately,interruptsarealsoextremelyhardtoreason about:they dramaticallyaltertheprogram \ncontrol.owandcomplicatethein\u00advariants in low-level concurrent code (e.g., implementation of syn\u00adchronizationprimitives).Existingformal \nveri.cationtechniques includingHoarelogic,typedassemblylanguage,concurrent sepa\u00adrationlogic, andthe assume-guarantee \nmethod have consistently ignoredtheissuesof interrupts;thisseverely limitstheapplicability andpower oftoday \nsprogram veri.cation systems. In this paper we present a novel Hoare-logic-like framework for certifying \nlow-level system programs involving both hard\u00adware interrupts and preemptive threads. We show that enabling \nanddisablinginterrupts canbe formalized preciselyusing simple ownership-transfer semantics, andthe sametechniquealsoextends \nto the concurrent setting. By carefully reasoning about the inter\u00adaction among interrupt handlers, context \nswitching, and synchro\u00adnization libraries, we are able to for the .rst time successfully certify apreemptivethreadimplementationandalarge \nnumberof common synchronization primitives. Our work provides a foun\u00addation for reasoning about interrupt-based \nkernel programs and makes animportant advancetowardbuildingfully certi.edoperat\u00adingsystemkernels and \nhypervisors. Categories and Subject Descriptors F.3.1[Logics and Meanings of Programs]:SpecifyingandVerifying \nandReasoning aboutPro\u00adgrams; D.2.4[Software Engineering]: Software/Program Veri.\u00adcation Correctness \nproofs, formal methods, reliability; D.3.1 [Programming Languages]: FormalDe.nitions andTheory Se\u00admantics; \nD.4.5[Operating Systems]:Reliability Veri.cation General Terms Languages, Reliability,Security,Veri.cation \nKeywords Hardware Interrupts, Preemptive Threads, Certi.ed SystemSoftware,Concurrency,SeparationLogic \nPermissiontomake digitalorhard copiesofallorpart of thisworkforpersonalor classroom useisgranted withoutfeeprovidedthatcopies \nare not made or distributed forpro.torcommercialadvantageandthatcopiesbearthis noticeandthefullcitation \nonthe.rstpage.Tocopyotherwise,torepublish,topost onserversortoredistribute tolists,requirespriorspeci.cpermission \nand/orafee. PLDI 08, June 7 13, 2008,Tucson,Arizona,USA. Copyright c . 2008ACM978-1-59593-860-2/08/06...$5.00 \n High-Level Concurrent Programs irq0 irq1 irq2 irq3 irq4 irq5 irq6 irq7 Low-Level Code with Interrupts \n&#38; Concurrency Figure 1. High-Level vs. Low-Level SystemPrograms 1. Introduction Low-level systemprograms(e.g., \nthreadimplementations, device drivers,OSkernels, and hypervisors)formthebackbone of almost everysafety-critical \nsoftware systemintheworld.Itisthushighly desirable to formally certify the correctness of these programs. \nIndeed,therehave been severalnew projectslaunchedrecently includingVerisoft/XT(Gargano et al. 2005; Paul \net al. 2007), L4.veri.ed(Tuchetal. 2005),andSingularity(Hunt andLarus 2004) allaimingtobuildcerti.edOSkernelsand/or \nhypervisors. Withformal speci.cations andprovablysafecomponents, certi.ed system software can provide \na trustworthy computing platform andenableanticipatorystatementsabout system con.gurations and behaviors(Hunt \nandLarus 2004). Unfortunately, system programs especially those involving both interrupts and concurrency \nare extremely hard to reason about. In Fig. 1, we divide programs in a typical preemptible uniprocessor \nOS kernel into two layers. At the higher abstrac\u00adtion level, we have threads that follow the standard \nconcurrent programming model(Hoare 1972):interruptsareinvisible,butthe executionof athread canbepreemptedbyotherthreads; \nsynchro\u00adnization operations aretreated as primitives. Below this layer (see the shaded box), we have \nmore sub\u00adtle lower-level code involving both interrupts and concurrency. The implementation of many synchronization \nprimitives and in\u00adput/output operationsrequiresexplicit manipulationofinterrupts; they behave concurrentlyinapreemptiveway(ifinterruptis \nen\u00adabled) ora non-preemptiveway(ifinterruptisdisabled).When executionof a threadis interrupted,controlistransferredtoanin\u00adterrupt \nhandler,whichmaycallthethread schedulerandswitchthe controltoanotherthread.Someofthe codeintheshaded \nbox(e.g., thescheduler andcontext switchingroutine) maybehavesequen\u00adtially sincethey arealwaysexecuted \nwithinterruptdisabled. Existing program veri.cation techniques (including Hoare logic (Hoare 1969), typed \nassembly language (Morrisett et al. Figure 2. InteractionbetweenThreadsand Interrupts 1998), concurrent \nseparationlogic(O Hearn 2004;Brookes 2004), andits assume-guaranteevariant(Fengetal. 2007a;Vafeiadisand \nParkinson 2007))canprobablyhandlethosehigh-levelconcurrent programs, but they have consistently ignored \nthe issues of inter\u00adruptsthus cannotbe usedto certifyconcurrent codeintheshaded box.Having bothexplicitinterruptsandthreadscreatesthefollow\u00adingnew \nchallenges: Asymmetric preemption relations. Non-handler code may be . preemptedby aninterrupt handler(andlow-priority \nhandlers canbepreemptedbyhigher-priorityones),but notviceversa. Interrupt handlers cannotbesimplytreatedasthreads(Regehr \nandCooprider 2007). Subtle intertwining between interrupts and threads. InFig. 2, thread A is interrupted \nby the interrupt request irq0. In the handler, the control is switched to thread B. From thread A s pointofview,the \nbehaviorofthehandler0iscomplex: should thehandlerberesponsibleforthe behaviorofthreadB?  Asymmetric \nsynchronizations. Synchronization between han\u00addler and non-handler codeis achievedsimplybyenablingand \ndisablinginterrupts(via sti and cli instructionsin x86).Unlike locks,interrupts canbedisabledby onethreadandenabledby \nanother.InFig.2,threadAdisablesinterruptsandthen switches controltothreadB(step(5)), whichwill enable \ninterrupts.  Handlerforhigher-priorityinterruptsmight be interrupted by lower-priorityones.InFig.2, \nhandler0switchesthe controlto threadB atstep(1); threadB enables interruptsand isinter\u00adrupted byirq1, \nwhichmay have alower-prioritythanirq0.  In thispaperwetackle thesechallengesdirectlyandpresent a novelframeworkfor \ncertifyinglow-levelprogramsinvolving both interrupts and preemptive threads. We introduce a new abstract \ninterrupt machine(namedAIM,seeSec.3 andthe upperhalf of Fig. 3) to capture interrupt-aware concurrency, \nand use simple ownership-transfer semanticstoreason abouttheinteractionamong Thread A Handler 0 Thread \nB   cli/ sti  Level C Sec. 3.2 &#38; [TR] Level S [TR] node* deQueue(queue * q) ctxt switching codevoid \nenQueue(queue * q, node *n) Figure 3. StructureofOur Certi.edPreemptiveThreadImplementation interrupt \nhandlers, contextswitching, andsynchronizationlibraries. Ourpaper makesthefollowing newcontributions: \n Asfaraswe know, ourworkpresentsthe.rstprogramlogic (seeSec.4)that can successfullycertifythe correctnessoflow\u00adlevelprogramsinvolving \nbothinterruptsand concurrency.Our ideaof usingownership-transfersemanticstomodelinterrupts is bothnoveland \ngeneral(sinceitalsoworksintheconcurrent setting). Our logic supports modular veri.cation: threads and \nhandlers canbe certi.edinthesameway as we certifysequen\u00adtialcodewithoutworryingabout possibleinterleaving.Sound\u00adnessof \nourlogicisformallyprovedintheCoqproof assistant.  Following separationlogic slocal-reasoningidea, ourprogram \nlogic also enforces partitions of resources between different threadsand betweenthreadsandinterrupt handlers.Theselog\u00adical \npartitions at different program points essentially give an abstractformalizationofthe semanticsofinterruptsandthein\u00adteractionbetween \nhandlersandthreads.  OurAIMmachine(seeSec.3) uni.es boththepreemptiveand non-preemptive threading models, \nand to our best knowledge, is the .rst to successfully formalize concurrency with explicit interrupt \nhandlers. In AIM, operations that manipulate thread queues are treated as primitives; These operations, \ntogether withthescheduler andcontext-switching code(thelowhalfof Fig.3),arestrictlysequentialthus canbe \ncerti.edinasimpler logic. Certi.ed code at differentlevelsislinkedtogether using anOCAP-styleframework(Fengetal. \n2007b).  Synchronization operations canbeimplementedassubroutines inAIM.To demonstratethepowerofourframework,wehave \ncerti.ed, for the .rst time, various implementations of locks andconditionvariables(seeSec.5).Our speci.cations \npinpoint preciselythedifferences betweendifferentimplementations.  2. Informal Development Before presenting \nour formal framework, we .rst informally ex\u00adplain the key ideas underlying our abstract machine and our \nownership-transfer semanticsforreasoning aboutinterrupts. 2.1 Design of the Abstract Machine InFig.3weoutlinethe \nstructureofathreadimplementationtaken froma simpli.edOSkernel.Wesplitall shaded codeintotwo layers:the \nupperlevelC(for Concurrent ) andthelowlevelS(for Sequential ).Code atLevelCis concurrent;ithandlesinterrupts \nexplicitlyandimplementsinterrupthandlersbutabstracts awaythe implementationof threads.Code atLevelSis \nsequential(always executed with interrupts disabled); functions that need to know theconcreterepresentationsofthread \ncontrolblocks(TCBs)and INV0 INV0  Critical Region B sti INV0 INV0  Figure 4. MemoryPartitionfor Handler \nandNon-Handler thread queuesareimplemented atLevelS;thereare one queuefor readythreadsand multiplequeuesforblockedthreads. \nWe implement three primitive thread operations at Level S: switch, block,and unblock.The switch primitive, \nshown as the scheduler() function in Fig. 3, saves the execution context of thecurrentthreadintotheready \nqueue,picks another onefromthe queue,and switchestotheexecutioncontextofthe newthread.The block primitivetakesapointertoablock \nqueueasargument,puts the current thread into the block queue, and switches the control toathreadintheready \nqueue.The unblock primitive also takes a pointertoablock queue as argument;it movesathreadfromthe block \nqueuetotheready queuebut does notdo context switching. LevelSalso contains codefor queue operations andthread \ncontext switching, whichare calledbythese threadprimitives. In the abstract machine at Level C, we use \ninstructions sti/cli toenable/disable interrupts(asonx86processors); theprimitives switch, block and \nunblock are also treated as instructions; thread queues are now abstract algebraic structures outside \nof the data heapand canonlybe accessedviathethreadprimitives.  2.2 Ownership-Transfer Semantics Concurrententities, \ni.e., thehandler code andthethreadsconsisting ofthe non-handler code,allneedto accessmemory.To guarantee \nthe non-interference,we enforcethefollowinginvariant,inspired byrecent work onConcurrentSeparationLogic(O \nHearn 2004; Brookes 2004): there always exists a partition of memory among these concurrent entities, \nand each entity can only access its own part of memory.Therearetwoimportantpointsaboutthisinvariant: \n thepartitionis logical;wedo not needto change our modelof the physical machine, which only has one global \nshared data heap.The logicalpartitioncanbeenforced followingSepara\u00adtionLogic(Ishtiaq andO Hearn 2001;Reynolds \n2002),aswe will explainbelow.  thepartitionis not static;itcanbe dynamically adjusted during programexecution,whichisdonebytransferringtheownership \nof memory from one entity to the other.  Insteadofusingthe operationalsemanticsofcli,sti andthread prim\u00aditives \ndescribed above to reason about programs, we model their semanticsintermsof memory ownershiptransfers.Thissemantics \ncompletelyhidesthread queuesandthusthecomplexinterleaving between concurrententities. We .rst studythe \nsemantics ofcli and sti assumingthatthe non\u00adhandler code is single-threaded. Since the interrupt handler \ncan preempt the non-handler code but not vice versa, we reserve the partof memoryusedbythehandlerfromtheglobalmemory,shown \nasblockAinFig.4.BlockAneedstobewell-formedwithrespect to the precondition of the handler, which ensures \nsafe execution of thehandlercode.Wecall thepreconditionaninvariant INV0, sincetheinterrupt maycomeat \nanyprogrampoint(aslong asitis enabled)andthisprecondition needstoalwayshold. If theinterrupt is enabled, \nthe non-handler code can only access the rest part of memory, calledblockB.Ifitneedsto accessblockA,ithasto.rst \n T1: cli INV1 INV0 INV1 INV0 switch T1 T2 C A T1 T2 T2 : C T2: A T2: sti INV1 INV0 INV1 INV0 Figure \n5. TheMemoryModelforMulti-ThreadedNon-Handler T1: block INV1 INV0  T2: unblock T2: switch INV1 INV0 \n Figure 6. Block andUnblock disabletheinterrupt by cli.Therefore we can model the semantics of cli as \na transfer of ownership of the well-formed block A, as showninFig.4.The non-handler code does not needtopreserve \ntheinvariant INV0iftheinterruptisdisabled,butitneedstoensure INV0 holds beforeit enablestheinterrupt \nagainusing sti.The sti instructionreturnsthewell-formedblockAtotheinterrupt handler. If the non-handler \ncode is multi-threaded, we also need to guar\u00adantee non-interference between these threads. Fig. 5 re.nes \nthe memory model.TheblockAisstilldedicatedtotheinterrupthan\u00addler.The memoryblockBissplitintothreeparts(assumingthere \nare onlytwothreads): eachthread hasitsownprivate memory,and boththreadssharetheblockC.WhenblockCisavailablefor \nshar\u00ading,itneedstobewell-formedwithsome speci.cationINV1. How\u00adever,athread cannotdirectly accessblockCiftheinterruptis \nen\u00adabled,evenif thehandler does not access it.Thatis becausethe handler mayswitchtoanotherthread,asshowninFig.2(step(1)). \nToaccessblockAandC,thecurrentthread,sayT1,needstodisable theinterrupt; so cli grants T1 the ownership \nof well-formed blocks AandC.If T1 wantsto switchcontrolto T2,it.rstmakes surethat INV0and INV1holdoverAandCrespectively.The \nswitch oper\u00adationtransferstheownershipofA andCfrom T1 to T2, knowing thattheinterrupt remainsdisabled.Enabling \ntheinterrupt(by T2) releasesthe ownership. Blockingthread queuesare usedtoimplementsynchronization primitives, \nsuch aslocksorconditionvariables.Whenthelockis not available, or the condition associated with the condition \nvari\u00adable does not hold, the current thread is put into the correspond\u00ading block queue. We can also model \nthe semantics of block and unblock asresourceownershiptransfers: ablockedthreadis essen\u00adtiallywaitingfortheavailabilityofsome \nresource, e.g., thelockand theresourceprotectedbythelock, ortheresourceoverwhichthe condition associated \nwith the condition variable holds. As shown in Fig. 6, thread T1 executes block when it waits for some \nre\u00adsource (represented asthe dashed box containing ? ).Since block (World) W ::=(C,S,K,pc) * (CodeHeap) \nC ::={ f . c}(State) S ::=(H,R,ie,is) * (Heap) H ::={ l . w}(RegFile) R ::={ r0 . w0,...,rk . wk}(Stack) \nK ::=nil | f ::K| (f,R)::K (Bit) b ::=0| 1 (Flags) ie,is ::=b (Labels)l,f,pc ::=n (nat nums) (Word) w \n::=i (integers) (Register) r ::=r0 | r1 | ... (Instr) . ::=mov rd ,rs | movi rd ,w | add rd ,rs | sub \nrd ,rs | ld rd ,w(rs)| st w(rt ),rs | beq rs,rt ,f | call f | cli | sti (Commd) c ::=. | j f | ret | \niret (InstrSeq) I ::=.;I| j f | ret | iret Figure 7. De.nition ofAIM-1 { C[f] def cc =C(f)and c =j f' \n, ret, or iret = .;I . =C(f)and I=C[f+1] { (F{ a . b} )(x) def b ifx =a = F(x) otherwise . defdef S| \nH' =(H' ,S.R,S.ie,S.is) S|{ ie=b} =(S.H,S.R,b,S.is) defdef S| R' =(S.H,R' ,S.ie,S.is) S|{ is=b} =(S.H,S.R,S.ie,b) \nFigure 8. De.nition ofRepresentations switches controltoother threads, T1 needstoensurethat INV0and INV1holdoverAandC, \nwhichisthesamerequirement as switch. When T2 makes the resource available, it executes unblock to re\u00adleaseathreadinthecorrespondingblock \nqueue,andtransfersthe ownership ofthe resourcetothe releasedthread.Notethat unblock itselfdoes notdo \ncontextswitching.When T1 takes control again, itwill ownthe resource.From T1 s point of view,the block \nopera\u00adtion acquirestheresource associatedwiththecorrespondingblock queue.This view of block and unblock \nisvery.exible:by choosing whethertheresourceis empty or not,we can certifyimplementa\u00adtionsofMesa-andHoare-styleconditionvariables \n(seeSec.5). 3. The Abstract Interrupt Machine (AIM) Inthis section, we present our Abstract Interrupt \nMachine(AIM) in twosteps.AIM-1showstheinteractionbetweenthehandlerand sequential non-handler code.AIM-2,the.nal \nde.nitionofAIM, extends AIM-1 with multi-threaded non-handler code. 3.1 AIM-1 AIM-1isde.nedinFig.7.Thewhole \nmachine con.guration W consists of a code heap C, a mutable program state S, a control stack K, and a \nprogram counter pc. The code heap C is a .nite partial mappingfromcodelabelsto commands c.Each command \nc iseitherasequential orbranchinstruction ., orjump orreturn instructions. The state S contains the data \nheap H, the register .le R, and .ags ie and is. The binary .ags ie and is record whethertheinterruptisdisabled,andwhetheritiscurrentlybeing \nserviced,respectively.Theabstract controlstack K savesthe return addressofthe currentfunctionortheinterrupt \nhandler.Eachstack frameeither containsacodelabelf orapair (f,R).Wealsode.ne theinstruction sequence I \nas a sequence of sequentialinstructions ending withjump or return commands. C[f]extracts aninstruction \nsequence startingfrom f in C,asde.nedinFig.8.Weusethe dot notation to represent a component in a tuple, \ne.g., S.H means the data heapin state S.Morerepresentations arede.nedinFig.8. NextS(c,K) SS' where S=(H,R,ie,is) \nif c = S' = mov rd ,rs (H,R{ rd . R(rs)} ,ie,is) movi rd ,w (H,R{ rd . w} ,ie,is) add rd ,rs (H,R{ rd \n. (R(rs)+R(rd ))} ,ie,is) sub rd ,rs (H,R{ rd . (R(rd )- R(rs))} ,ie,is) ld rd ,w(rs) (H,R{ rd . H(R(rs)+w)} \n,ie,is) if (R(rs)+w). dom(H) st w(rt ),rs (H{ (R(rt )+w). R(rs)} ,R,ie,is) if (R(rt )+w). dom(H) cli \nS| { ie=0} sti S| { ie=1} iret (H,R' ,1,0) if is =1,K=(f,R' )::K' for some f and K' other cases S NextK(pc,c) \nKK' K' = if c = call f (pc+1)::K ret K'' if K=f ::K'' for some f iret K'' if K=(f,R)::K'' for some f \nand R other cases K ' NextPC(c,R,K) pc pc ' if c = pc= beq rs,rt ,ff if R(rs)=R(rt ) beq rs,rt ,f pc \n+1if R(rs)= R(rt ) call ff j f f ret f if K=f ::K' for some K' iret f if K=(f,R' )::K' for some K' and \nR' other cases pc +1 c =C(pc) ' NextS(c,K) SS' NextK(pc,c) KK' NextPC(c,S,K) pc pc .R (PC) (C,S,K,pc) \n-. (C,S' ,K' ,pc' ) ie =1 is =0 (IRQ) (C,(H,R,ie,is),K,pc)i(C,(H,R,0,1),(pc,R)::K,h entry) ' =def (W-. \n(WiW W. W= W' ).' ) Figure 9. OperationalSemantics ofInstructions Operational semantics. At eachstep,the \nmachineeitherexecutes the next instruction at pc orjumps tohandle the incoming inter\u00adrupt.Tosimplify \nthepresentation,themachinesupports only one interrupt,withaglobalinterrupt handler entryh entry.Supportof \nmulti-levelinterruptsisdiscussedinSec.6. An incominginterrupt isprocessed onlyifthe ie bitisset,and nointerruptis \ncurrently beingserviced(i.e., is =0).Theprocessor pushes (pc,R)ontothe stack K, clears ie,sets is, and \nsets the new pc to h entry.The statetransition (WIW' )isde.nedinthe IRQ ruleinFig.9. The operational \nsemantics of each instruction is de.ned in Fig.9.WeuserelationsNextS(c,K),NextK(pc,c)and NextPC(c,R ,K) \n to show the change of states, stacks and program counters re\u00adspectively when c isexecuted.Semanticsofmostinstructions \nare straightforward.The command iret popsthe stackframe (f,R' )on topof K and resets pc andthe register \n.le R with f and R' , respec\u00adtively.It also restores ie and is withthevalue when theinterrupt occurs, \nwhich mustbe1and0respectively(otherwisetheinterrupt cannothave been handled).InAIM,theregister.le R is \nautomati\u00adcally saved andrestoredattheentryandexitpointoftheinterrupt handler.Thisisasimpli.cationofthex86interrupt \nmechanismfor ' (C,S,K,pc,tid,T,B)-. W where S=(H,R,ie,is) ' if C(pc)= W = switch block rt block rt unblock \nrt ,rd unblock rt ,rd other c ' ''' (C,(H,R,0,is ' ),K,pc ,tid ' ,T,B) ' '' if ie =0, T =T{tid (R,K,is,pc+1)}, \ntid '. readyQ(T,B), and T ' (tid ' )=(R,K,is ' ,pc ' ) ' ''' (C,(H,R,ie,is ' ),K,pc ,tid ' ,T,B ' ) ' \n if ie =0, w =R(rt ), B(w)=Q, B =B{w (Q.{tid})}, tid '. readyQ(T,B ' ), '' ' T(tid ' )=(R,K,is ' ,pc \n' )and T =T{tid (R,K,is,pc+1)}(C,(H,R,ie,is),K,pc,tid,T,B) if ie =0, and readyQ(T,B)={tid} '' (C,(H,R,ie,is),K,pc+1,tid,T,B) \nif ie =0, w =R(rt ), B(w)=\u00d8, and R =R{rd 0} ' (C,(H,R,ie,is),K,pc+1,tid,T,B ' ) '' if ie =0, w =R(rt \n), B(w)=Qt{tid '}, B =B{w Q}, and R =R{rd tid '} ''' ''' (C,S,K,pc ,tid,T,B) if NextS(c,K) SS, NextK(pc,c) \nKK, and NextPC(c,R,K) pc pc incleft: (p0, NoG)} h_entry: -{(pi, gi)} movi $r1, RIGHT movi $r1, LEFT movi \n$r2, LEFT movi $r2, RIGHT l_loop: (p1, NoG)} movi $r3, 0 movi $r3, 0 ld $r4, 0($r1) cli beq $r3, $r4, \nr_win (p2, NoG)} movi $r3, 1 ld $r4, 0($r1) sub $r4, $r3 beq $r3, $r4, l_win st 0($r1), $r4 movi $r3, \n1 ld $r4, 0($r2) sub $r4, $r3 add $r4, $r3 st 0($r1), $r4 st 0($r2), $r4 ld $r4, 0($r2) iret add $r4, \n$r3 r_win: -{(p4, gid)} st 0($r2), $r4 iret sti (p1, NoG)} j l_loop l_win: (p3, NoG)} sti j l_loop Figure \n10. Sample AIM-1Program:Teeter-Totter (World) W ::=(C,S,K,pc,tid,T,B) (ThrdSet) T ::={tid (R,K,is,pc)}* \n(BlkQSet) B ::={w Q}* (ThrdQ) Q ::={tid1,...,tidn}(ThrdID) tid ::=n (nat nums, and n > 0) (qID) w ::=n \n(nat nums, and n > 0) (Instr) . ::=... | switch | block rt | unblock rt ,rd | ... Figure 11. AIM-2De.ned \nas anExtension ofAIM-1 acleaner presentation.In ourimplementation(Feng et al. 2007c), thehandler code \nneedstosaveandrestoretheregisters. Fig.9alsode.nes (W -. W ' )forexecutingthe instructionat the current \npc;program executionisthen modeledas W=. W ' . Fig.10 showsa sampleAIM-1program.Theprogram speci.\u00adcations \ninshadedboxesareexplainedinSec.4.Initially LEFT and RIGHT pointto memorycells containingthesamevalue(say,50). \nThe non-handler increases the value stored at LEFT anddecrease the value at RIGHT. The interrupt handler \ncode does the reverse. Whichsidewinsdependsonhowfrequenttheinterrupt comes.To avoidraces,the non-handler \ncodealwaysdisablesinterruptsbefore itaccessesLEFT and RIGHT. {} g0 . (ie =ie ' ). (is =is ' ) Figure \n12. TheStepRelationfor AIM-2 h_entry: -{(pi, gi)} j h_timer h_timer: -{(pi, gi)} movi $r1, CNT ld $r2, \n0($r1) ; $r2 <-[CNT] movi $r3, 100 beq $r2, $r3, schd ; if ([CNT]=100) movi $r3, 1 ; goto schd add $r2, \n$r3 st 0($r1), $r2 ; [CNT]++ iret schd: -{(p0, g0)} movi $r2, 0 st 0($r1), $r2 ; [CNT] := 0 switch iret \np0 = enable iret . (r1 =CNT)def def CNT . = INV0 Figure 13. APreemptiveTimer Handler  3.2 AIM-2 Fig.11 \nde.nesAIM-2asanextensionoverAIM-1.Weextendthe world W with an abstractthread queue T,a setofblock queues \nB, andtheid tid forthe currentthread. T maps athreadidtoathread executioncontext, whichcontainstheregister.le,stack,theis \n.ag and pc. B mapsblock queueids w to block queuesQ.These block queuesare usedtoimplementsynchronizationprimitivessuchas \nlocks and condition variables. Q isaset of threadidspointing to thread contexts in T.Noteherewedo not \nneedaseparate Q for readythreads, which arethreadsin T butnot blocked: ,B) def readyQ(T= {tid | tid . \ndom(T).\u00ac.w.tid . B(w)} . We alsoaddthreeprimitive instructions:switch, block and unblock. The step relation \n(W -. W ' )ofAIM-2isde.nedinFig. 12. The switch instruction saves the execution context of the current \nthread into thethreadqueue T, and picks a thread nondetermin\u00adistically from readyQ(T,B)torun.Tolet our \nabstraction.tinto theinterfaces showninFig.3,werequirethattheinterruptbedis\u00adabledbefore switch.This also \nexplains why ie is not savedinthe thread context, andwhyitissetto0whenanewthreadisscheduled from T.The \nblock rt instructionputsthecurrent thread id into theblock queue B(rt ), and switches the control to \nanother thread in readyQ(T,B).Ifthere arenootherthreadsin readyQ,the ma\u00adchinestutters(in our x86implementation,thiswould \nnever happen becausethereisanidlethread and our programlogicprohibitsit from executing block).The unblock \nrt ,rd instruction removes a thread from B(rt )and putsits tid into rd ifthe queueisnot empty; (CdHpSpec) \n. ::= {(f1,s1),...,(fn,sn)} (Spec) s ::=(p,g) (Pred) p . Stack . State . Prop (Guarantee) g . State . \nState . Prop (MPred) m,INV0,INV1 . Heap . Prop (WQSpec) . ::= {w m}* Figure 14. Speci.cationConstructs \notherwise rd contains 0. Here t representsthe union oftwodis\u00adjoint sets. By the de.nition of readyQ, \nwe know tid willbe in readyQ after being unblocked. unblock does not switch controls. Like switch, block \nand unblock canbeexecutedonlyiftheinterrupt is disabled.The effectsofotherinstructionsover S, K and pc \nare thesameasinAIM-1.Theydo not changeT, B and tid.Thetran\u00adsition (WIW ')forAIM-2is almostthesameastheoneforAIM-1 \nde.nedbythe IRQ rule.Itdoes not change T,B and tid either.The de.nition of(W =. W ')is unchanged. A preemptive \ntimer interrupt handler. The design of AIM is veryinterestinginthatit supports bothpreemptivethreads(if \nthe interrupt is enabled and the handler does context switching) and non-preemptive ones(iftheinterruptisdisabled,oriftheinterrupt \nis enabledbutthehandler doesnocontextswitching)forhigher\u00adlevelconcurrent programs(seeFig.1). Fig.13showstheimplementationof \napreemptive timerinter\u00adrupt handler.Eachtimetheinterrupt comes,thehandlerteststhe valueofthe counterat \nmemorylocation CNT.Ifthe counterreaches 100,thehandler switchescontroltootherthreads;otherwiseitin\u00adcreases \nthe counter by1 and returns to theinterrupted thread.We willexplainthe meaningsofspeci.cationsandshowhowthetimer \nhandleris certi.edinSec.4. 4. The Program Logic 4.1 Speci.cation Language We use the mechanizedmeta-logic \nimplementedin theCoqproof assistant(Coq2006) as our speci.cationlanguage.Thelogiccor\u00adrespondsto higher-orderlogicwith \ninductive de.nitions. As showninFig.14, thespeci.cation . for the code heap C associates codelabels f \nwithspeci.cations s.We allow each f to have morethan one s,just asafunctionmayhave multiplespeci\u00ad.edinterfaces.The \nspeci.cation s is apair (p,g).The assertion p isapredicateovera stack K and a program state S, while \ng is a predicateovertwo programstates.Aswe can see,the NextS(c,K) relationde.nedinFig.9is a specialform \nof g.AsinSCAP(Feng et al. 2006), we use p to specify theprecondition overstack and state, and use g to \nspecifythe guaranteed behaviorfromthe speci\u00ad.edprogram pointtothe pointwherethe current function returns. \nWe also use the predicate m to specify data heaps.We encode inFig.15SeparationLogicconnectors(IshtiaqandO \nHearn 2001; Reynolds 2002)in our speci.cationlanguage.AssertionsinSep\u00adarationLogic captureownership ofheaps.Theassertion \nl . n holdsiff the heap has only one cell at l containing n.It can also beinterpreted astheownership \nofthismemorycell. m * m ' means ' theheap canbesplitinto two disjoint parts, and m and m hold over oneofthem \nrespectively. m -* m ' holdsover H iff,foranydisjoint ' heap H ' satisfying m, H t H ' satis.es m . The \nspeci.cation . maps anidenti.er w toaheap predicate m specifying the well-formednessoftheresource thatthethreadsin \ntheblock queueB(w)are waitingfor. Speci.cations of the shared resources. Heap predicates INV0 and INV1arepartof \nourprogramspeci.cations,whichspecifythe well-formednessoftheshared sub-heapA andC respectively, as shown \nin Figs. 5 and 6. The de.nition of INV0 depends on the def def true = .H. True emp = .H. H=\u00d8 def def \nl . w = .H. H={lw} l . = .H. .w. (l . w)H def H1.H2 = dom(H1)n dom(H1)=\u00d8 { def H1. H2 if H1.H2 H1t H2 \n= unde.ned otherwise def m1* m2 = .H. .H1,H2. (H1t H2 =H). m1 H1. m2 H2 def p * m = .K,S. .H1,H2. (H1t \nH2 =S.H). p KS|H1 . m H2 ' def ' '' ''). m H '' m -* m = .H. .H,H . (Ht H ' =H '. m ' H def m -* p = \n.K,S. .H ' ,H '' . (H 't S.H=H ''). m H '. p KS|H '' m) def precise(= .H,H1,H2. (H1 . H). (H2 . H). m \nH1. m H2 . (H1 =H2) Figure 15. De.nitions ofSeparationLogicAssertions functionality oftheglobalinterrupthandler; \nand INV1depends on thesharingofresources amongthreads.Tosimplify thepresenta\u00adtion,wetreatthem asglobalparametersthroughoutthis \npaper.1 Speci.cation of the interrupt handler. We needtogiveaspeci.\u00adcationtotheinterrupt handlertocertifythe \nhandler code andensure the non-interference.Welet (h entry,(pi,gi)). .,where pi and gi arede.ned asfollows: \ndef pi = .K,S. ((INV0* true)S.H). (S.is =1). (S.ie =0) '' ..f,R,K. K=(f,R)::K (1) {} def INV0 '' gi = \n.S,S. S.HS.H INV0 '' .(S.ie =S.ie). (S.is =S.is) (2) The precondition pi speci.es the stack and state \nat the entry h entry.It requiresthatthelocal heap usedbythehandler(block AinFig.5)satis.es INV0.The guarantee \ngi speci.es the behav\u00adiorofthe handler.The argumentsS and S ' correspond to program states at the entry \nand exit points, respectively. It says the ie and is bits inS ' havethesamevalue asin S, and thehandler \nslocal heap satis.es INV0in S and S ',whiletherest oftheheap remains {} m1 unchanged.Thepredicate is \nde.ned below. m2 {} def m1 '' '' = .H1,H2. .H1,H2,H. (m1 H1). (m2 H2). m2 '' (H1t H=H1). (H2t H=H2) (3) \n It hasthefollowingnice monotonicity:for anyH1, H2 and H ',if H1 and H2 satisfythepredicate, H1.H ',and \nH2.H ',then H1tH ' and H2t H ' satisfy thepredicate. 4.2 Inference Rules InferencerulesoftheprogramlogicareshowninFig. \n16.Thejudg\u00adment .,. f{s}f : I de.nesthewell-formedness oftheinstruction sequence I startingatthe codelabel \nf,giventheimportedinterfaces in .,the speci.cation . ofblockqueues, andaprecondition (p,g). The SEQ rule \nis a schema forinstructionsequences startingwith an instruction . (. cannot be branch andfunction callinstructions). \n' We needto.ndanintermediatespeci.cation (p ,g '), with respect towhich the remaininginstructionsequenceiswell-formed.Itis \nalso used as a post-condition for the .rst instruction. We use g. 1Theycan also be treated as local parameters \nthreading through judgments in our program logic(as . and . inFig.16).Toavoid therequirementof theglobal \nknowledge aboutshared resources andtohavebettermodularity, frame rules(Reynolds 2002; O Hearnetal. 2004) \ncanbesupportedfollow\u00adingthesameway they aresupportedinSCAP(Feng andShao 2008).We do not discussthe details \nin this paper. .,.f{s}f : I (Well-Formed Instr. Seq.) '' ..{call ...,beq ...} .,.,g f{( p ) }f+ 1: I \n'' enable( p,g.)( p Ig.) .p ( p .( g..g )) .g def where g.=[[ .]] . (SEQ) .,.;I f{( p,g) }f : . '''''''' \n ( f+ 1, ( p ,g )) ...,.f{( p ,g ) }f+ 1: I ''' ( f ' , ( p ,g )) .. .K,S,pc. p KS.p ( pc ::K) S ''' \n'' ( p Ig ) .p ( p .( g '.g )) .g (CALL) .,.f{( p,g) }f : call f ' ;I p .enableiret ( p .gid) .g (IRET) \n.,.f{( p,g) }f : iret def ' where enableiret = .K,S. .f,R,K. K=( f,R) ::K '.S.is = 1 p .enableret ( p \n.gid) .g (RET) .,.f{( p,g) }f : ret def '' where enableret = .K,S. .f,K. K= f ::K '''''' ( f ' , ( p \n,g )) ...,.f{( p ,g ) }f+ 1: I '' ( p Igidrs = rt ) .p ( p .( gidrs = rt .g )) .g '' '' ( p Igidrs =) \n.p ( p .( gidrs = .g )) .g rt rt (BEQ) .,.f{( p,g) }f : beq rs,rt,f ' ;I '''' ( f ' , ( p ,g )) ..p .p \n( p .g ) .g (J) .,.f{( p,g) }f : j f ' ' .,.fC:.(Well-Formed Code Heap) ' for all ( f,s) ..: .,.f{s}f \n: C[ f] (CDHP) ' .,.fC:..,.fW (Well-Formed World) T\\tid = {tid1 ( R1,K1,is1,pc1) ,..., tidn ( Rn,isn,pc) \n} n,Kn S.H= H0t...tHn Si =( Hi,Ri,0,isi)( 0<i =n) '' .,.fC:....dom( .)= dom( B) ' WFCth( S0,K,pc,.) \nwhere S0 = S| H0 for all0 < k =n such that tidk .readyQ( T,B) : ' WFRdy( Sk,Kk,pck,.) for all w and0 \n< j =n such that tid j .B( w) : ' WFWait( Sj,Kj,pc j,.,.( w)) (WLD) .,.f( C,S,K,pc,tid,T,B) Figure 16. \nInferenceRules to represent the state transition [[ .]] .made by the instruction ., which is de.ned in \nFig. 18 and is explained below. The premise enable( p,g.) isde.nedinFig.17.Itmeansthatthe statetransition \ng.would not get stuck as long as the starting stack and state satisfy p. The predicate p I g., shown \nin Fig. 17, speci.es the stack and state resultingfrom the state transition g., knowing the initialstate \nsatis.es p.Itisthe strongest postconditionafter g..The composition of two subsequent transitions g and \ng ' is represented ' as g .g ,and p .g re.nes g with theextraknowledge thattheinitial state satis.es \np.Wealso liftthe implicationrelationbetween p s and g s.Thelastpremiseinthe SEQ rulerequiresthecomposition \n' of g.and g ful.lls g, knowingthecurrentstatesatis.es p. If .isanarithmeticinstruction,moveinstructionormemoryop\u00aderation, \nwe de.ne [[ .]] .inFig.18 asNextS( .) .Since NextS does , notdepend onthestackfortheseinstructions (recallitsde.nition \ndef '' enable( p,g)= .K,S. p KS..S,g SS def p Ig = .K,S. .S0,p KS0.g S0 S def def ' ''' '''' ' ' g .g \n= .S,S . .S. g SS '.g SS p .p = .K,S. p KS.p KS def def ' ' ' '''' p .g = .S,S. .K.p KS.g SS g .g = \n.S,S. g SS .g SS Figure 17. Connectorsforp and g def ' P ?m:m ' = .H. ( P.m H) .( \u00acP.m H) def '' [[ cli \n]] .= .( H,R,ie,is) ,( H,R,ie ' ,is ') . ' ( is = is ') .( R= R) .( ie ' = 0) . {} emp ' ( ie = 1.is \n= 0) ? ( INV0*INV1) :emp HH def '' [[ sti ]] .= .( H,R,ie,is) ,( H,R,ie ' ,is ') . ' ( is = is ') .( \nR= R) .( ie ' = 1) . {} ( ie = 0.is = 0) ? ( INV0*INV1) :emp ' HH emp def '' [[ switch ]] .= .( H,R,ie,is) \n,( H,R,ie ' ,is ') . ' ( ie = 0) .( ie = ie ') .( R= R) .( is = is ') . {} INV0*( is = 0? INV1:emp) ' \nINV0*( is = 0? INV1:emp) HH def '' [[ block rs ]] .= .( H,R,ie,is) ,( H,R,ie ' ,is ') . ' ( ie = 0) .( \nie = ie ') .( R= R) .( is = is ') . .m. .( R( rs)) = m. {} INV0*( is = 0? INV1:emp) ' INV0*( is = 0? \nINV1:emp) *m HH def '' [[ unblock rs,rd ]] .= .( H,R,ie,is) ,( H,R,ie ' ,is ') . ' ( ie = 0) .( ie = \nie ') .( is = is ') .( .r = rd. R( r)= R( r)) . .m. .( R( rs)) = m .( m *true) H. {} ' ( R( rd)= 0) ? \nemp:m ' HH emp def [[ .]] .= NextS( .(for all other .) , ) Figure 18. Thread-LocalStateTransitions Madeby. \n inFig.9),weuse torepresent arbitrarystacks.Also notethat the NextS relationsfor ld or st requirethetargetaddresstobeinthe \ndomain ofheap,therefore thepremiseenable( p,g.) requiresthat p containstheownershipofthetargetmemorycell. \nInterrupts and thread primitive instructions. One of the major technical contributionsofthis paperis \nourformulationof [[ .]] .for cli, sti, switch, block and unblock,which,asshowninFig. 18,gives them an \naxiomaticownershiptransfersemantics. The transition [[ cli]] .says that, if cli is executed in the non\u00adhandler(is \n= 0) and the interrupt isenabled(ie = 1), the cur\u00adrentthreadgetsownership of thewell-formed sub-heapA \nandC satisfying INV0*INV1,as showninFig.5;otherwise thereisno ownershiptransfer. Thetransition [[ sti]] \n.isde.nedsimilarly.Note that the premise enable( p,g.) in the SEQ rule requires that, be\u00adfore executing \nsti, theprecondition p must contain the ownership ( ie = 0.is = 0) ? ( INV1*INV0) :emp. [[ switch]] .requiresthatthe \nsub-heapAandC(inFig.5)bewell\u00adformedbefore andafter switch.However,ifweexecute switch in the interrupt \nhandler(is = 1), we know INV1always holds andleave it implicit. Also enable( p,g.) requires that p ensures \nie = 0and INV0*( is = 0? INV1:emp) holds over some sub-heap. [[ block rs ]] .requires ie = 0and rs contains \nan identi.er of a block queue with speci.cation m in ..It is similar to [[ switch]] ., except that the \nthread gets the ownership of m afteritis released (seeFig. 6).In[[ unblock rs,rd ]] .,werequiretheinitialheap \nmust . . INV1 is = 1 Inv(ie,is) def = emp is = 0and ie = 0 . INVs is = 0and ie = 1 def where INVs = INV0* \nINV1 def p * Inv = .K,S. (p * Inv(S.ie,S.is)) KS 1gJ def '' '' = .(H,R,ie,is),(H,R,ie ' ,is ')..H1,H2,H1,H2. \n'' (H1t H2 = H) . (H = H ') 1t H2 '' .g (H1,R,ie,is)(H1,R,ie ' ,is ') ' .Inv(ie,is) H2. Inv(ie ' ,is \n') H2 ,nil,.) def '' WFST(g,S= \u00ac.S. g SS ,.) def WFST(g,S,f ::K= .pf,gf . (f, (pf ,gf)) . . '' ..S. g \nSS '. (pf * Inv) KS '. WFST(1gfJ,S,K,.) ,.) def WFST(g,S,(f,R)::K= .pf,gf . (f, (pf ,gf)) . . ' '' ..S. \ng SS '. (pf * Inv) KS '' . WFST(1gfJ,S ,K,.) ' where S '' =(S.H,R,1,0) def WFCth(S,K,pc,.)= .p,g. (pc,(p,g)) \n. . .(p * Inv) KS. WFST(1gJ,S,K,.) def WFCth(pc,.)= .K,S. WFCth(S,K,pc,.) ,pc,.) def WFRdy(S,K=((INV0* \nINV1) -* WFCth(pc,.)) KS def WFRdy(pc,.)= .K,S. WFRdy(S,K,pc,.) ,pc,.,m) def WFWait(S,K=(m -* WFRdy(pc,.)) \nKS Figure 19. Well-FormedCurrent,ReadyandWaitingThreads contain a sub-heap satisfying m, because unblock \nmay transfer it to ablockedthread.However, since unblock does notimmediately switch controls,wedo not \nneedthesub-heapA andCtobewell\u00adformed.If rd contains non-zero value at the end of unblock,some threadhasbeenreleasedfromtheblock \nqueue.The currentthread transfers m tothereleasedthread andhas no accesstoitany more. Otherwise, nothreadisreleased \nandthereisnoownershiptransfer. Other instructions. Inthe CALLruleinFig.16,wetreatthestate ' transition \ng madebythecalleeasthe transitionofthecallinstruc\u00adtion.Wealso requirethattheprecondition p impliesthe \nprecondi\u00adtion p ' ofthecallee,whichcorrespondstothe enable premiseinthe SEQ rule. IRET and RETrulesrequirethatthefunctionhas.nished \nitsguaranteed transitionatthispoint.Soanidentity transition gid should satisfy the remaining transition \ng.The predicates enableiret and enableret specifytherequirementsoverstacks.Inthe BEQ rule, we use gidrs \n=rt and gidrs =rt to represent identity transitions with extra knowledge about rs and rt : def '' gid \n= .S,S. S= S def ') . (S ' gidrs = .S,S. (gid SS .R(rs)= S.R(rt )) =rt def ' gidrs = .S,S. (gid SS ') \n. (S.R(rs)= S.R(rt )) =rt We do not have an enable premisebecause beq nevergets stuck. The J rule canbeviewed \nasaspecializationof BEQ. Well-formed code heap. The CDHPrule saysthecode heapis well-formed if and only \nif each instruction sequence speci.ed in .' is well-formed. . and .' canbeviewed astheimported and exportedinterfaces \nof C respectively. Program invariants. The WLD rule formulates the program in\u00advariantenforcedby ourprogramlogic.If \nthereare n threadsin T inadditiontothe current thread,theheap canbe split into n + 1 blocks.Each block \nHk (k > 0)is fora readyorblockedthreadin defdefdef ' p =(ie = 1) . (is = 0) p =(ie = 0) . (is = 0) p0 \n= p def p1 = p . (r1 = RIGHT) . (r2 = LEFT) def p2 = p '. (r1 = RIGHT) . (r2 = LEFT) . (r3 = 0) . (INV0* \ntrue) def p3 = p '. (r1 = RIGHT) . (r2 = LEFT) . (INV0* true) def def ' p4 = enable iret NoG = .S,S.False \nFigure 20. Speci.cations oftheTeeter-TotterExample queues.Theblock H0is assignedtothe currentthread,whichin\u00adcludes \nbothits privateheap andthe shared part (blocksA andC, as showninFig.5).Thecode heap C needstobe well-formed, \nas de.nedbythe CDHPrule.Werequiretheimportedinterface . is asubset oftheexportedinterface .',therefore \nC is self-contained and eachimported speci.cationhas been certi.ed.The domainof . should be the same \nwith the domain of B, i.e., . speci.es and only speci.esblock queuesin B.The WLD rule also requires that \nthelocal heapsandexecutioncontextsofthecurrentthread,ready threadsandblockedthreadsareallwell-formed \n(seeFig. 19). WFCth de.nes the well-formedness of the current thread. It requires that the pc has a speci.cation \n(p,g) in ., thus C[pc] is well-formed with respect to (p,g).The current thread s stack and itslocal state(containingthesub-heapH0)need \nto satisfy p * Inv. Here p speci.esthestateaccessiblebythe currentthread,while Inv, de.nedinFig.19, speci.estheinaccessiblepartofthe \nshared heap. Ifthecurrentprogrampointisintheinterrupt handler(is = 1), p leavesthememoryblockC(inFig.5) \nunspeci.ed,thereforeInv is de.ned as INV1and speci.esthewell-formednessofC.Otherwise (is = 0),if ie = \n0, blocksA andCbecome thecurrentthread s private memory and the inaccessible part is empty. If ie = 1, \nA andC areinaccessible; Inv speci.es their well-formedness in this case.Thepredicate WFST,de.nedinFig. \n19, saysthereexistsa well-formed stack with somedepth k.Thede.nitionis similar to the oneinSCAP(Fengetal. \n2006) andis notexplainedhere. The de.nition of well-formed ready threads WFRdy is very straightforward: \nif the ready thread gets the extra ownership of shared memoryA andC,itbecomesa well-formed current thread \n(see Fig. 5). Recall that m -* p is de.ned in Fig. 15. Similarly, WFWait says that the waiting threadinablockqueuewaitingfor \nthe resourcem becomes a well-formedready threadif itgets m (see Fig.6).The de.nitionsofWFRdy and WFWait \nconciselyformu\u00adlate the relationshipbetween current, ready and waitingthreads. The Teeter-Totter example. \nWithourprogramlogic,we can now certifytheTeeter-TotterexampleshowninFig.10.We.rstinstanti\u00adate INV0,theinterrupt \nhandler s speci.cationforitslocal memory: INV0 def = .wl ,wr. ((LEFT . wl ) * (RIGHT . wr)) . (wl + wr \n= n), where n isanauxiliary logical variable.Thenwecangetthecon\u00adcretespeci.cationoftheinterrupt handler,following \nFormulae(1) and(2)inSec. 4.1.Welet INV1be emp, since the non-handler codeis sequential. Speci.cations \nareshowninFig. 20. Recallenableiret isde.ned inFig. 16.Tosimplifyourpresentation,wepresentthepredicate \np in the form of a proposition with free variables referring to components of the state S.Also, we use \nm as a shorthand for the proposition m H whenthereis no confusion. If we compare p1 and p2,wewill seethatthe \nnon-handler code cannot access memory at addresses LEFT and RIGHT without .rst disabling theinterrupt \nbecause p1 does not contain the ownership of LEFT and RIGHT.Sincethenon-handler neverreturns,wesimply \nuse NoG (seeFig.20) astheguaranteeforthe statetransitionfrom thespeci.edpointtothereturn point. The timer \nhandler. Wealso brie.yexplainthe speci.cationfor thepreemptivetimer handler showninFig. 13.Thehandler \nonly accessesthe memory cell atthelocation CNT.Weinstantiate INV0 below: INV0 def = .w. (CNT .w) .(w \n=100). Thenwegetthe speci.cationofthe handler(pi,gi) byFormulae(1) and(2).In g0(showninFig. 13),weuseprimedvariable(e.g., \nie ' and is ')toreferto componentsinthe secondstate. Soundness. Weprovethesoundness oftheprogramlogicfollow\u00adingthe \nsyntactic approach.Based ontheprogressandpreservation lemmas, weknowtheprogramnevergetsstuckaslongastheinitial \nstatesatis.estheprograminvariantde.nedbythe WLD rule. More importantly,we knowtheinvariantalways holds \nduring execution, fromwhichwe can deriverichpropertiesofprograms.Here,we only showthe soundnesstheoremformalizing \nthe partial correct\u00adnessofprograms.SeetheTR(Fenget al. 2007c)forproof details. Theorem 4.1 (Soundness) \nIf INV0and INV1are precise, .,. fW,and (h entry,(pi,gi)) . ., then,for any n, there exists W ' such that \nW=.n W ' ;and, if W ' =(C,S,K,pc,tid,T,B),then 1. if C(pc)= j f,thenthere exists (p,g) suchthat (f,(p,g)) \n.. and p KSholds; 2. if C(pc)= beq rs,rt ,f and S.R(rs)= S.R(rt ),thenthereexists (p,g) suchthat (f,(p,g)) \n.. and p KSholds; 3. if C(pc)= call f,thenthere exists (p,g) suchthat (f,(p,g)) . . and p (pc ::K) Sholds. \n Recall thatprecisenessis de.nedinFig.15, andthe speci.cation (pi,gi) is de.nedby Formulae(1)and(2). \n5. More Examples Inthis section,weshowhowtouseAIMandtheprogramlogicto implementand certifycommonsynchronizationprimitives. \n 5.1 Implementations of Locks Threadsuselocksto achieveexclusive accesstosharedheap.We use G to specifyinvariantsof \nmemoryblocksprotectedbylocks. (LockID) l ::= l * (LockSpec) G ::= {l m} In ourimplementations,weuse memorypointers(labell)aslock \nids l. Each l points to a memory cell containing a binary .ag that records whether the lock has been \nacquired (.ag is 0) or not.Theheap usedtoimplementlocksandtheheapprotectedby locksare sharedbythreadsinthe \nnon-handler code.Theinvariant INV(G) overthispartofheapis de.ned below.Werequire INVs . INV(G) *true \n(recallthat INVs is a shorthandforINV0*INV1). INV(l,m) def = .w. (l .w) *((w = 0) .emp .(w = 1) .m) (4) \nINV(G) def = .*l .dom(G). INV(l,G(l)) (5) where .* is an indexed, .nitely iterated separating conjunction, \nwhichisde.nedas: { *x .S. P(x) def emp if S = \u00d8 .= P(xi) *.*x .S' . P(x) if S = S't{xi} We.rst showtwoblock-basedimplementations,inwhich \nwe usethelockid astheidenti.erofthecorrespondingblock queue in B.Then weshowanimplementationof spinlocks.Moredetailed \nexplanationsaregivenintheTR(Fengetal. 2007c). The Hoare-style implementations. In Hoarestyle,thethreadgets \nthe lock (and the resource protected by the lock) immediately afteritisreleasedfromtheblock queue.Theimplementationand \nspeci.cationsareshown in Figs.21 and22. Thepreconditionfor ACQ H is (p01,g01). The assertion p01 requires \nthat r1 contains a lockidand .(r1)= G(r1). The guarantee g01 shows that the ACQ_H: -{(p01, g01)} cli \ncall ACQ_H_a sti ret  ACQ_H_a: -{(p11, g11)} ld $r2, 0($r1) ;; $r2 <-[l] movi $r3, 0 beq $r2, $r3, gowait \n;; ([l]== 0)? st 0($r1), $r3 ;; [l]<> 0: ret ;;[l]<-0 gowait: -{(p12, ;; [l]== 0: g11)} block $r1 ;; \nblock -{(p13, gid)} ret REL_H: -{(p21, g21)} cli call REL_H_a sti ret REL_H_a: -{(p31, g31)} unblock \n$r1, $r2  -{(p32, g32)} movi $r3, 0 beq $r2, $r3, rel_lock ret rel_lock: -{(p33, g33)} movi $r2, 1 \nst 0($r1), $r2 -{(p34, gid)} ret Figure 21. Hoare-StyleImplementation ofLocks def p0 =(is = 0) .enableret \n.(r1 .dom(G)) .(.(r1)= G(r1)) def p01 = p0.(ie = 1) {} def empg01 G(r1) = .(ie = ie ') .(is = is ') .trash({r2,r3}) \ndef p11 = p0.(ie = 0) .(INVs *true) {} def INVs = .(ie = ie ') .(is = is ') .trash({r2,r3}) g11 INVs \n*G(r1) def p12 = p0.(ie = 0) .([r1]= 0) .(INVs *true) def p13 = p0.(ie = 0) .(INVs *true *G(r1)) def \np21 = p0.(ie = 1) .(G(r1) *true) {} def G(r1) g21 = .(ie = ie ') .(is = is ') .trash({r2,r3}) emp def \np31 = p0.(ie = 0) .(G(r1) *INVs *true) {} { } {} def G(r1) def r1 . def emp ga = gb = hid = emp r1 .1 \nemp defg31 a =(g.gb) .(ie = ie ') .(is = is ') .trash({r2,r3}) def p32 = p0.(ie = 0) .((r2 = 0) .(G(r1) \n*INVs *true) .(r2 = 0) .(INVs *true)) def g32 =((r2 = 0.gb) .(r2 = 0.hid)) .(ie = ie ') .(is = is ') \n.trash({r2,r3}) def p33 = p0.(ie = 0) .(G(r1) *INVs *true) def g33 = gb .(ie = ie ') .(is = is ') .trash({r2,r3}) \ndef p34 = p0.(ie = 0) .(INVs *true) Figure 22. Speci.cations ofHoare-StyleLocks def p0 =(is =0). enableret \n. (r1 . dom(G)). (.(r1)=emp) def def p11 p12 p11 . (r3 = p0. (ie =1) ==0) {} def empg11 G(r1) = . (ie \n=ie '). (is =is '). trash({r2,r3}) def p13 = p0. (ie =0). (INVs * true) {} def INVs g13 G(r1) = . (ie \n=1- ie '). (is =is '). trash({r2,r3}) def p21 = p0. (ie =1). (G(r1)* true) {} def G(r1) g21 = . (ie =ie \n'). (is =is '). trash({r2}) emp ACQ_M: -{(p11, g11)} movi $r3, 0 acq_loop: -{(p12, g11)} cli ld $r2, \n0($r1) ;; $r2 <\u00ad [l] beq $r2, $r3, gowait ;; ([l]== 0)? st 0($r1), $r3 ;; No: [l]<\u00ad0 sti ret gowait: \n-{(p13, g13)} block $r1 sti j acq_loop REL_M: -{(p21, g21)} cli unblock $r1, $r2 movi $r2, 1 st 0($r1), \n$r2 sti ret Figure 23. Mesa-Style Locks  function obtains the ownership ofG(r1)when it returns. Here \nwe useprimed variables(e.g., ie ' and is ')toreferto componentsin the return state, and use trash({r2,r3})to \nmean that values of all registers otherthan r2 and r3 arepreserved. We also show some intermediate speci.cations \nused during veri.cation. Comparing (p01,g01)and (p11,g11), we can see that (p01,g01) hides INVs and the \nimplementation details of the lock from the client code. Readers can also compare p12 and p13 and seehow \nthe BLK ruleisapplied. Functions REL H and REL H a are speci.ed by (p21,g21) and (p31,g31), respectively. \nDepending on whether there are threads waiting for the lock, the current thread may either transfer the \nownership of G(r1) to a waiting thread or simply set the lock to beavailable, as speci.edin g31,butthesedetails \narehiddenin g21. The Mesa-style implementation. Fig. 23 shows the Mesa-style implementation oflocks.Inthe \nACQ M function, the thread needs to start another round of loop to test the availability of the lock \nafter block.The REL M functionalways setsthelocktobeavailable, even if it releases a waiting thread. \nSpeci.cations are the same with Hoarestyleexceptthattheassertion p0 requires .(r1)=emp, whichimpliestheMesa-style \nsemanticsof block and unblock.More intermediateassertionsaregiveninthetechnical report. Spinlocks. Animplementationofspinlocksfor \nuniprocessorsys\u00adtems and its speci.cations are shown in Fig. 24. The speci.ca\u00adtions (p11,g11) and (p21,g21) \ndescribes the interface of lock ac\u00adquire/release. They look very similar to speci.cations for block\u00adbasedimplementations: \nacquire getstheownership of theextra resource G(r1) protected by the lock in r1, while release loses \ntheownership sothattheclient can nolongerusetheresourceaf\u00ad   def p =(is =0). enableret . (r1 . dom(G)) \ndef def p11 p12 p11 . (r2 = p . (ie =1) ==1) {} def emp g11 G(r1) = . (ie =ie '). (is =is '). trash({r2,r3}) \ndef p13 = p . (ie =0). ([r1]=1). (INVs * true) {} def INVs g13 = G(r1) . (ie =1-ie '). (is =is '). trash({r2}) \ndef p21 = p . (ie =1). (G(r1)* true) {} def G(r1) g21 = . (ie =ie '). (is =is '). trash({r2}) emp ;; \nacquire(l): $r1 contains l spin_acq: -{(p11, g11)} movi $r2, 1 spin_loop: -{(p12, g11)} cli ld $r3, \n0($r1) beq $r2, $r3, spin_set sti j spin_loop spin_set: -{(p13, g13)} movi $r2, 0 st 0($r1), $r2 sti \n ret ;; release(l): $r1 contains l spin_rel: -{(p21, g21)} movi $r2, 1 cli st 0($r1), $r2 sti ret Figure \n24. ASpinlock WAIT_H: -{(p11, g11)} ;; wait(l, cv) cli mov $r4, $r2 call REL_H_a block $r4 sti ret SIGNAL_H: \n-{(p21, g21)} ;; signal(l, cv) cli unblock $r2, $r3 movi $r4, 0 beq $r3, $r4, sig_done block $r1 sig_done: \n-{(p22, g22)} sti ret SIGNAL_BH: ;; signal(l, cv) -{(p31, g31)} cli unblock $r2, $r3 ;; $r2 contains \ncv movi $r4, 0 beq $r3, $r4, sig_cont sti ret sig_cont: -{(p32, g32)} call REL_H_a ;; $r1 contains l \nsti ret Figure 25. Impl.ofCV -HoareStyleandBrinchHansenStyle Cond(r,r ') def = G(r).(.(r ')*true) Cond(r,r \n') def = G(r).\u00ac(.(r ')*true) p(r,r ') def =(is =0).enableret. ' .l,cv,m,m . (r =l).(r ' =cv).(G(l)=m).(.(l)=m) \n.(.(cv)=m ').(.(cv)=Cond(r,r ')) def p11 = p(r1,r2).(ie =1).(Cond(r1,r2)*true) {} def Cond(r1,r2) = .(ie \n=ie ').(is =is ').trash({r2,r3,r4}) g11 Cond(r1,r2) def p21 = p(r1,r2).(ie =1).(Cond(r1,r2)*true) {} \ndef Cond(r1,r2) g21 = G(r1) .(ie =ie ').(is =is ').trash({r2,r3,r4}) def p22 = p(r1,r2).(ie =0).(INVs \n*G(r1)*true) {} def INVs g22 = .(ie =1-ie ').(is =is ').trash({r2,r3,r4}) emp def def p31 = p21 p32 = \np22 {} def Cond(r1,r2) g31 = .(ie =ie ').(is =is ').trash({r2,r3,r4}) emp {} def G(r1)*INVs g32 = emp \n.(ie =1-ie ').(is =is ').trash({r2,r3,r4}) Figure 26. Spec.ofCV-HoareStyleandBrinchHansenStyle terwards.These \nspeci.cations alsohide theimplementationdetails (e.g., thelock name l isa pointer pointingtoa binary \nvalue)from the client code.  5.2 Implementations of Condition Variables Now we show implementations \nof Hoare style (Hoare 1974), BrinchHansenstyle(BrinchHansen 1975),and Mesastyle(Lamp\u00adsonand Redell 1980) \nconditionvariables.Below we use . to spec\u00adifytheconditionsassociatedwithconditionvariables. (CondVar) \ncv ::= n (nat nums) * (CVSpec) . ::= {cv m} In our implementation, we let cv be an identi.er pointing \nto a block queue in B.Alock l needs to be associated with cv to guaranteeexclusive access of the resource \nspeci.edby G(l).The difference between G(l)and .(cv)is that G(l)speci.es the basic well-formedness ofthe \nresource(e.g., a well-formedqueue), while .(cv)speci.es an extra condition(e.g., the queueis not empty). \nHoare style and Brinch Hansen style. Theimplementations and speci.cations are shown in Figs. 25 and 26. \nThe precondition for WAIT H is (p11,g11).As p11 shows, r1 containsaHoare-style lock in the sense that \n.(r1)=G(r1).The register r2 contains the condition variable with speci.cation .(r2). For Hoare-style, \nwe require .(r2)=G(r1).(.(r2)*true).Therefore,whenthe blocked threadisreleased,itgetsthe resource protectedbythelockwiththe \nextra knowledge that the condition associated with the condition variableholds.Here the condition .(r2)does \nnot have to specify thewholeresource protectedbythelock,thereforeweuse .(r2)* true.Before calling WAIT \nH, p11requiresthatthelock musthave been acquired, thus we have the ownership G(r1).The condition .(r2) \nneedstobefalse.Thisis not an essential requirement,but we use it to prevent waiting without testing the \ncondition. The guarantee g11 says that, when WAIT H returns, the current thread stillowns thelock(and \nG(r1))and it also knows the condition speci.edin . holds.ThepreconditionforSIGNAL H is (p21,g21). SIGNAL \nH requiresthethreadownsthelockandthecondition .(r2) holdsatthebeginning.Whenitreturns,thethread stillownsthe \nlock,but theconditionmay no longer hold. p(r,r ') def =(is =0).enableret. ' .l,cv,m,m . (r =l).(r ' =cv).(G(l)=m).(.(l)=m) \n.(.(cv)=m ').(.(cv)=emp) def p11 = p(r1,r2).(ie =1).(Cond(r1,r2)*true) {} def Cond(r1,r2)g11 G(r1) = \n.(ie =ie ').(is =is ').trash({r2,r3,r4}) '(r) def p =(is =0)..cv,m. (r =cv).(.(cv)=m).(.(cv)=emp) def \np21 = p '(r1).(ie =1) def g21 =hid .(ie =ie ').(is =is ').trash({r2}) WAIT_M: -{(p11, g11)} ;; wait(l, \ncv) cli mov $r4, $r2 call REL_H_a block $r4 sti call ACQ_H ret SIGNAL_M: -{(p21, g21)} ;; signal(cv) \ncli unblock $r1, $r2 sti ret Figure 27. Impl.andSpec.ofCV-MesaStyle  BrinchHansen styleconditionvariablesaresimilartoHoare\u00adstyle.Thewaitfunctionisthe \nsame as WAIT H.The signalfunction SIGNAL BH is speci.edby (p31,g31)de.nedinFig. 26.Here p31 is the same \nas p21.Thede.nition of g31 shows the difference: the lockis releasedwhensignal returns.Therefore,calling \nthesignal functionmustbethelast commandinthecriticalregion. Mesa-style. Fig.27showsMesa-styleconditionvariables. \nWAIT M is speci.ed by (p11,g11).The assertion p11 is similartothepre\u00adcondition for Hoare-style, except \nthat we require .(r2)=emp. Therefore, as g11 shows,thecurrentthread hasnoideaaboutthe validity ofthe \ncondition whenit returns. SIGNAL M isspeci.edby(p21,g21).The assertion hid isde.ned inFig.22,whichmeansthe \nfunctionhasnoeffectsoverdataheap. From g21 we can see that, if we hide the details of releasing a blockedthread,the \nsignalfunctioninMesastyleisjustlikea skip command. We do not require the current thread to own the lock \nl before it calls SIGNAL M,sinceit hasnoeffectsoverdataheap. Intermediate assertions forthese examples \naregiven in theTR. 6. Implementations and Further Extensions Theprogramlogicpresentedinthis paperhas \nbeen adaptedforthe 16-bit, real-mode x86 architecture. We have formalized a subset of the x86 assembly \nlanguage, its operational semantics, and the programlogicintheCoqproof assistant(Coq2006).In ourimple\u00admentation,we \nassumethatallinterruptsexceptthetimerhave been masked.Soundness oftheprogramlogicisprovedinanOCAP\u00adlike(Fengetal. \n2007b)framework:inferencerulesareproved as lemmasinthefoundationalframework;the soundnessoftheframe\u00adwork \nitself is then proved following the syntactic approach. The proofisalso formalizedinCoqandis machine-checkable. \nOurpreemptivethreadlibraries(showninFig.3) arealsoim\u00adplementedinthe x86 assemblycode andworksinreal-mode.Syn\u00adchronizationprimitivesatLevelC \nare certi.ed usingthe AIMpro\u00adgramlogic.Thetimer handler callstheschedulerimplemented at thelow-level,which \ncorrespondstothe switch instructioninAIM. Theyieldfunction simplywrapsthe scheduler by disablingthein\u00adterrupt \natthebeginning andenablingit atthe end.They arealso certi.edusingthislogic.ThreadprimitivesatLevelSinFig.3 \nare certi.ed as sequential code.Linkingofthe certi.edlow-level code withthemiddle-levellibraries andthetimer \nhandleris doneinthe OCAP-like framework. Linking of the thread library code at the middlelevelwith thehigh-level \nconcurrent programs(seeFig.1) canbe doneinasimilarway andisleftasfuturework.   TheCoqimplementationhastakenmany \nman-months, outof whichasigni.cantamountofeffortshas beenputontheimplemen\u00adtationofbasicfacilities,including \nlemmasand tacticsforpartial mappings,heaps, queues, andSeparationLogicassertions.These commonfacilitiesare \nindependent ofthetask of certifyingthread libraries and canbereusedinfutureprojects.Thesizeoftheproof \nscripts,intermsofthe numberoflinesofCoqtactics,ishuge com\u00adpared with the size of the x86 code. For instance, \nthe proof for theMesa-styleconditionvariables(26 linesofx86code)isaround 5400lines,including commentsand \nwhite spaces.However,as ob\u00adservedby McCreightetal.(2007),thelengthofproofisprobablya poor metricof complexity.Thereisalotofredundancyintheproof: \nwhen aninstructionisseenasecondtimeinthe code,wesimply copyandpastethepreviousproof,anddo someminor changes.We \nhope the length of the proof can be greatly reduced given better abstractions andtactics.Also,the 5400lineofproofwas.nished \nonlyintwo daysby oneoftheauthors,whoisanexperiencedCoq user.Webelievethisisaveryreasonableprice topayforfullycer\u00adti.ed \nsubroutineswithmachinecheckableproofs.ThewholeCoq implementationisreleasedaspartoftheTR(Fengetal. 2007c). \nExtensions and future work. InAIM,we onlysupportoneinter\u00adruptinthesystem,whichcannotbeinterrupted again.Itis \nactually easy to extend the machine to support multi-level interrupts: we change the is bitintoavector \nof bits ivec corresponding tointer\u00adruptsinservice.Aninterrupt can onlybeinterruptedbyotherinter\u00adrupts \nwithhigherpriorities, which can alsobedisabledby clearing the ie bit.Attheendof eachinterrupt handler,the \ncorresponding in-servicebitwillbecleared sothatinterruptsatthe same orlower levelcan be served. Extensionofthe \nprogram logictosupportmulti-levelinterrupts isalso straightforward,followingthesameideaofmemoryparti\u00adtions.Supposetherearen \ninterruptsinthe system,the memorywill bepartitionedinton+1blocks, as shownbelow: . . . INVn-1 INV0 where \nblock Ak will be used by the interrupt handler k.To take careof thepreemptionrelations with multiplehandlers, \nweneed tochange ourde.nition of Inv(ie,is) in Fig.19into Inv(ie,ivec), which models the switch of memory \nownership atthepoints of cli, sti and boundariesofinterrupt handlers. Anothersimpli.cationinourwork is \ntheassumption ofaglobal interrupt handler entry.Itis easytoextend our machineandpro\u00adgramlogictosupport \nrun-timeinstallationofinterrupt handlers.In our machine,wecan addaspecialregister andan install toupdate \nthisregister.Wheninterrupt comes,welookuptheentrypointfrom thisregister.Thisextension hasalmostnoeffectsover \nourprogram logic,thanksto our supportofmodularreasoning.We onlyneedto add acommand ruleforthe install \ninstructiontoenforcethatthe newhandler sinterfaceiscompatible tothespeci.cation (pi,gi). Also,wedo not \nconsider dynamiccreationofthreadsandblock queuesinthispaper.In ourpreviouswork(FengandShao 2005), wehaveshownhowto \nsupport dynamicthreadcreationfollowing asimilartechniqueto support dynamicmemory allocationintype systems.Thetechniqueisfairly \northogonaland canbe easilyin\u00adcorporatedintothiswork.Gotsmanetal.(2007) andHoboretal. (2008)extendedconcurrent \nseparationlogicwithdynamiccreation oflocks.Theirtechniquesmightbe appliedhereaswelltosupport dynamicblock \nqueues. It is also interesting to extend our logic to support multi\u00adprocessor machines in the future. \nThe general idea of memory partitionsandownership transfersusedherewould stillapplyina multi-processorsetting,exceptthat \nweneed toknowwhichinter\u00adruptinterruptswhich processor.Theimplementationofkernel-level threadsattheLevelSinFig.3becomesmorecomplicated \nbecause itisno longersequential,butitstill prohibits interruptsatthislevel and can be certi.ed based \non existing work on concurrency veri.\u00adcation.Disablinginterruptsplaysalessimportantroleto bootstrap the \nimplementation of synchronization primitives. To implement spinlocks, weneedtouseatomicinstructionsprovidedbythehard\u00adware, \ne.g., thecompare andswapinstruction(cas).Also, wewould liketoseehowrelaxed memorymodelsaffectthereasoning \nabout concurrent programs. There are other possible extensions of the program logic to increaseitsexpressiveness.Bornatetal.(2005) \nshowedre.nements ofSeparationLogicassertionstodistinguishread-only accessand read/write accessof memory \ncells.The re.nements canbe applied to ourprogramlogictosupport veri.cationof reader/writerlocks. Also,we \ncan changethecurrentinvariant-basedspeci.cations for the well-formedness of shared memory into rely-guarantee \nstyle speci.cations,where assertionsspecifytransitionsofstatesandare moreexpressivethaninvariants(Fenget \nal. 2007a;Vafeiadis and Parkinson 2007). 7. Related Work and Conclusion Regehr andCooprider(2007) showed \nhowtotranslateinterrupt\u00addriven programs to thread-based programs. However, their tech\u00adnique cannotbedirectlyappliedfor \nourgoaltobuild certi.edOS kernel.First,proofofthecorrectnessofthetranslationisnon-trivial and has not \nbeen formalized. As Regehr and Cooprider pointed out,theproofrequiresaformal semanticsofinterrupts.Ourwork \nactuallyprovides suchformal semantics.Second,theirtranslation requireshigher-levellanguage constructs \nsuch aslocks,whilewe certifytheimplementationoflocks basedon ourAIM. SuenagaandKobayashi(2007)presentedatype \nsystemtoguar\u00adantee deadlock-freedom in a concurrent calculus with interrupts. Their calculus is an ML-style \nlanguage with built-in support of threads, locks and interrupts. Our AIM is at a lower abstraction level \nthantheirswithnobuilt-inlocks. Also,theirtypesystemis designedmainlyforpreventingdeadlockswithautomatictype \nin\u00adference,while ourprogramlogicsupportsveri.cationofgeneral safetyproperties,including partial correctness. \nPalsbergandMa(2002)proposeda calculusofinterruptdriven systems,whichhas multi-levelinterruptsbutnothreads.Instead \nof ageneralprogramlogiclike ours,theyproposedatype systemto guarantee an upper bound of stack space. \nDeLine andF\u00a8ahndrich (2001) showedhowtoenforceprotocolswithregard tointerrupts levels as an applicationofVault \nstype system.However,itis not clearhowtousethetype systemforgeneralpropertiesofinterrupts. Bevier(1989) \ncerti.edKit, anOSkernelimplementedinma\u00adchinecode.Garganoetal.(2005)showedaframeworkfora cer\u00adti.edOSkernelintheVerisoftproject.Ni \net al.(2007) certi.eda non-preemptive thread implementation. In all these cases, imple\u00admentations of \nkernels or thread libraries are all sequential. They cannotbeinterrupted andthereis nopreemptiveconcurrency. \nInthispaperwepresent anewHoare-style frameworkfor cer\u00adtifying low-level programs involving both interrupts \nand concur\u00adrency. Following Separation Logic, we formalize the interaction amongthreadsandinterrupt handlersintermsof \nmemory owner\u00adshiptransfers.Insteadof usingthe operationalsemanticsof cli, sti andthread primitives, our \nprogramlogicformulatestheirlocal ef\u00adfectsoverthe currentthread,asshowninFig.18,whichisthekey for ourlogictoachieve \nmodularveri.cation.Wehavealso certi.ed various lock and condition-variable primitives; our speci.cations \nareboth abstract(hidingimplementationdetails) and precise (cap\u00adturingthesemanticdifference amongthesevariations). \nPractitioners doing informal proofs can also bene.t from our logicbylearning howtodoinformalreasoninginasystematic \nway forgeneral concurrentprograms,whosecorrectnessis usuallynot obvious. Althoughtheprimitivesshowninthis \npaperaresimilar to standard routines in many OS textbooks, we are not aware of any(eveninformal)proofsfor \ncodethatinvolves bothhardwarein\u00adterruptsandpreemptiveconcurrency.Sayingthatthecode should workisonething(itoftenstill \nrequiresleap-of-faithinourexpe\u00adrience) knowingwhyitworks(whichthis paper does)is an\u00adotherthing.Theideaofmemorypartitionsandownership \ntransfers showninthispaper(andinspired bySeparationLogic) givesgen\u00aderal guidelinesevenforinformalproofs. \nAcknowledgments We thank anonymous referees for suggestions and comments on an earlier version of this \npaper. Wei Wang, Haibo Wang, and Xi Wang helpedprove someofthelemmas in ourCoqimplementa-tion.XinyuFengandZhongShao \naresupportedinpartbygiftfrom MicrosoftandNSFgrant CCR-0524545.YuanDongis supported in partbyNationalNaturalScienceFoundationofChina(under \ngrant No. 60573017), China Scholarship Council, and Basic Re\u00adsearch FoundationofTsinghuaNationalLaboratoryforInforma\u00adtionScience \nandTechnology(TNList).YuGuois supportedinpart by grantsfromNationalNaturalScienceFoundation ofChina(un\u00addergrantsNo. \n60673126 andNo. 90718026) andIntelChinaRe\u00adsearchCenter.Anyopinions,.ndings,and contributions contained \nin this document are those of the authors and do not re.ect the viewsofthese agencies. References William \nR. Bevier. Kit: A study in operating system veri.cation. IEEE Trans. Softw. Eng., 15(11):1382 1396, 1989. \nRichardBornat, Cristiano Calcagno, PeterO Hearn, andMatthewParkin\u00adson. Permission accounting in separation \nlogic. In Proc. 32nd ACM Symp. on Principles of Prog. Lang.,pages 259 270,January 2005. PerBrinchHansen. \nTheprogramming language concurrent pascal. IEEE Trans. Software Eng.,1(2):199 207, 1975. Stephen Brookes. \nA semantics for concurrent separation logic. In Proc. 15th Int l Conf. on Concurrency Theory (CONCUR \n04), volume 3170 of LNCS,pages 16 34. Springer, September 2004. CoqDevelopmentTeam. TheCoqproof assistantreferencemanual. \nThe Coq release v8.1, 2006. RoberDeLineand ManualF\u00a8ahndrich.Enforcinghigh-levelprotocolsin low-level \nsoftware. In Proc. 2001 ACM Conf. on Prog. Lang. Design and Impl.,pages 59 69.ACMPress,June 2001. XinyuFengandZhong \nShao.Modularveri.cationof concurrent assembly code with dynamicthread creationand termination. In Proc. \n2005 ACM Int l Conf. on Functional Prog.,pages 254 267, September 2005. Xinyu Feng and Zhong Shao. Local \nreasoning and information hid\u00ading in SCAP. Technical Report YALEU/DCS/TR-1398, Dept. of Computer Science, \nYale University, New Haven, CT, February 2008. http://flint.cs.yale.edu/publications/SCAPFrame.html. \nXinyuFeng,Zhong Shao,AlexanderVaynberg,Sen Xiang, andZhaozhong Ni. Modular veri.cation of assembly code \nwith stack-based control abstractions.In Proc. 2006 ACM Conf. on Prog. Lang. Design and Impl., pages \n401 414.ACMPress,June 2006. Xinyu Feng, Rodrigo Ferreira, and Zhong Shao. On the relationship be\u00adtween \nconcurrent separationlogicand assume-guarantee reasoning. In Proc. 16th European Symp. on Prog. (ESOP \n07), volume4421 of LNCS, pages 173 188. Springer, March 2007a. XinyuFeng,ZhaozhongNi,ZhongShao,andYu \nGuo.Anopen framework forfoundationalproof-carrying code. In Proc. 2007 ACM Workshop on Types in Lang. \nDesign and Impl.,pages 67 78,January 2007b. XinyuFeng,Zhong Shao,YuanDong, andYuGuo. Certifying low-level \nprograms with hardware interrupts and preemptive threads. Techni\u00adcal ReportYALEU/DCS/TR-1396 andCoqImplementations,Dept.of \nComputer Science,Yale University,New Haven, CT,November 2007c. http://flint.cs.yale.edu/publications/aim.html. \nMauro Gargano, Mark A. Hillebrand, Dirk Leinenbach, and Wolfgang J. Paul. On the correctness of operating \nsystem kernels. In Proc. 18th Int l Conf. on Theorem Proving in Higher Order Logics, volume 3603 of LNCS,pages \n1 16, August2005. Alexey Gotsman,JoshBerdine, ByronCook, Noam Rinetzky, and Mooly Sagiv. Local reasoning \nfor storable locks and threads. In Proc. 5th ASIAN Symp. on Prog. Lang. and Sys. (APLAS 07),pages 19 \n37, 2007. C. A. R. Hoare. An axiomatic basisfor computer programming. Commu\u00adnications of the ACM, 26(1):53 \n56, October 1969. C.A.R.Hoare.Monitors:An operatingsystemstructuring concept. Com\u00admunications of the \nACM, 17(10):549 557, October 1974. C.A.R. Hoare. Towardsa theoryof parallelprogramming. InOperating Systems \nTechniques,pages 61 71. Academic Press, 1972. AquinasHobor,AndrewW.Appel, andFrancescoZappaNardelli. \nOracle semanticsfor concurrentseparationlogic.InProc. 17th European Symp. on Prog. (ESOP 08),pagetoappear, \n2008. GalenC.Hunt andJamesR.Larus. Singularity designmotivation.Techni\u00adcal ReportMSR-TR-2004-105, MicrosoftCorporation, \nDecember 2004. SaminS.Ishtiaqand PeterW.O Hearn. BI as an assertionlanguage for mutabledata structures.InProc. \n28th ACM Symp. on Principles of Prog. Lang.,pages 14 26.ACMPress,January 2001. ButlerW.Lampson andDavidD. \nRedell. Experience with processesand monitors inMesa. Commun. ACM, 23(2):105 117, 1980. Andrew McCreight,Zhong \nShao,ChunxiaoLin, andLongLi. Ageneral framework for certifying garbage collectors and their mutators. \nIn Proc. 2007 ACM Conf. on Prog. Lang. Design and Impl., pages 468 479. ACMPress,June 2007. GregMorrisett,DavidWalker,KarlCrary, \nandNealGlew.FromSystemF to typed assembly language. In Proc. 25th ACM Symp. on Principles of Prog. Lang.,pages \n85 97.ACMPress,January 1998. Zhaozhong Ni, Dachuan Yu, and Zhong Shao. Using XCAP to certify realistic \nsystems code: Machine context management. In Proc. 20th Int l Conf. on Theorem Proving in Higher Order \nLogics, volume 4421 of LNCS,pages 189 206. Springer, September 2007. PeterW.O Hearn. Resources,concurrency \nand local reasoning. In Proc. 15th Int l Conf. on Concurrency Theory (CONCUR 04), volume 3170 of LNCS,pages \n49 67. Springer, September 2004. PeterW.O Hearn, HongseokYang,andJohnC.Reynolds.Separationand information \nhiding. In Proc. 31th ACM Symp. on Principles of Prog. Lang.,pages 268 280.ACMPress,January 2004. Jens \nPalsberg and Di Ma. A typed interrupt calculus. In Proc. 7th Int l Symp. on Formal Tech. in Real-Time \nand Fault-Tolerant Sys. (FTRTFT 02), volume 2469 of LNCS,pages 291 310, September 2002. WolfgangPaul,ManfredBroy, \nandThomasInderRieden.TheVerisoftXT project. URL: http://www.verisoft.de, 2007. JohnRegehr andNathanCooprider.Interruptveri.cationvia \nthreadveri.\u00adcation. Electron. Notes Theor. Comput. Sci., 174(9), 2007. John C. Reynolds. Separation logic: \nA logic for shared mutable data structures. In Proc. 17th Annual IEEE Symp. on Logic in Comp. Sci. (LICS \n02),pages 55 74. IEEEComputer Society,July 2002. KoheiSuenaga andNaokiKobayashi.Type basedanalysisofdeadlock \nfor a concurrent calculus with interrupts. In Proc. 16th European Symp. on Prog. (ESOP 07), volume 4421 \nof LNCS,pages 490 504, March 2007. HarveyTuch,GerwinKlein,andGernotHeiser.OSveri.cation now!In Proc. \n10th Workshop on Hot Topics in Operating Systems,June 2005. ViktorVafeiadisand MatthewParkinson.Amarriageof \nrely/guarantee and separationlogic. InProc. 18th Int l Conf. on Concurrency Theory (CON\u00adCUR 07), volume \n4703 of LNCS,pages 256 271, September 2007.   \n\t\t\t", "proc_id": "1375581", "abstract": "<p>Hardware interrupts are widely used in the world's critical software systems to support preemptive threads, device drivers, operating system kernels, and hypervisors. Handling interrupts properly is an essential component of low-level system programming. Unfortunately, interrupts are also extremely hard to reason about: they dramatically alter the program control flow and complicate the invariants in low-level concurrent code (e.g., implementation of synchronization primitives). Existing formal verification techniques---including Hoare logic, typed assembly language, concurrent separation logic, and the assume-guarantee method---have consistently ignored the issues of interrupts; this severely limits the applicability and power of today's program verification systems.</p> <p>In this paper we present a novel Hoare-logic-like framework for certifying low-level system programs involving both hardware interrupts and preemptive threads. We show that enabling and disabling interrupts can be formalized precisely using simple ownership-transfer semantics, and the same technique also extends to the concurrent setting. By carefully reasoning about the interaction among interrupt handlers, context switching, and synchronization libraries, we are able to---for the first time---successfully certify a preemptive thread implementation and a large number of common synchronization primitives. Our work provides a foundation for reasoning about interrupt-based kernel programs and makes an important advance toward building fully certified operating system kernels and hypervisors.</p>", "authors": [{"name": "Xinyu Feng", "author_profile_id": "81100140619", "affiliation": "Toyota Technological Institute at Chicago, Chicago, IL, USA", "person_id": "P1022772", "email_address": "", "orcid_id": ""}, {"name": "Zhong Shao", "author_profile_id": "81351597965", "affiliation": "Yale University, New Haven, CT, USA", "person_id": "P1022773", "email_address": "", "orcid_id": ""}, {"name": "Yuan Dong", "author_profile_id": "81384592192", "affiliation": "Tsinghua University, Beijing, China", "person_id": "P1022774", "email_address": "", "orcid_id": ""}, {"name": "Yu Guo", "author_profile_id": "81322495267", "affiliation": "University of Science and Technology of China, Hefei, Anhui, China", "person_id": "P1022775", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1375581.1375603", "year": "2008", "article_id": "1375603", "conference": "PLDI", "title": "Certifying low-level programs with hardware interrupts and preemptive threads", "url": "http://dl.acm.org/citation.cfm?id=1375603"}