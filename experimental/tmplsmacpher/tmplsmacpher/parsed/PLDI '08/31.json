{"article_publication_date": "06-07-2008", "fulltext": "\n Full Functional Veri.cation of Linked Data Structures Karen Zee Viktor Kuncak Martin C. Rinard MIT \nCSAIL, Cambridge, MA, USA EPFL, I&#38;C, Lausanne, Switzerland MIT CSAIL, Cambridge, MA, USA * kkz@csail.mit.edu \nviktor.kuncak@ep..ch rinard@csail.mit.edu Abstract We present the .rst veri.cation of full functional \ncorrectness for a range of linked data structure implementations, including muta\u00adble lists, trees, graphs, \nand hash tables. Speci.cally, we present the use of the Jahob veri.cation system to verify formal speci.cations, \nwritten in classical higher-order logic, that completely capture the desired behavior of the Java data \nstructure implementations (with the exception of properties involving execution time and/or mem\u00adory consumption). \nGiven that the desired correctness properties in\u00adclude intractable constructs such as quanti.ers, transitive \nclosure, and lambda abstraction, it is a challenge to successfully prove the generated veri.cation conditions. \nOur Jahob veri.cation system uses integrated reasoning to split each veri.cation condition into a conjunction \nof simpler subformu\u00adlas, then apply a diverse collection of specialized decision proce\u00addures, .rst-order \ntheorem provers, and, in the worst case, interac\u00adtive theorem provers to prove each subformula. Techniques \nsuch as replacing complex subformulas with stronger but simpler alterna\u00adtives, exploiting structure inherently \npresent in the veri.cation con\u00additions, and, when necessary, inserting veri.ed lemmas and proof hints \ninto the imperative source code make it possible to seam\u00adlessly integrate all of the specialized decision \nprocedures and theo\u00adrem provers into a single powerful integrated reasoning system. By appropriately \napplying multiple proof techniques to discharge dif\u00adferent subformulas, this reasoning system can effectively \nprove the complex and challenging veri.cation conditions that arise in this context. Categories and Subject \nDescriptors D.2.4 [Software Engineer\u00ading]: Software/Program Veri.cation; D.3.1 [Programming Lan\u00adguages]: \nFormal De.nitions and Theory; F.3.1 [Logics and Mean\u00ading of Programs]: Specifying and Verifying and Reasoning \nabout Programs General Terms Algorithms, Languages, Reliability, Veri.cation Keywords veri.cation, Java, \ndata structure, theorem prover, deci\u00adsion procedure * This research was supported in part by the Singapore-MIT \nAlliance, DARPA Cooperative Agreement FA 8750-04-2-0254, NSF Grant CCR\u00ad0086154, NSF Grant CCR-0341620, \nNSF Grant CCF-0209075, and NSF Grant CCR-0325283. Permission to make digital or hard copies of all or \npart of this work for personal or classroom use is granted without fee provided that copies are not made \nor distributed for pro.t or commercial advantage and that copies bear this notice and the full citation \non the .rst page. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires \nprior speci.c permission and/or a fee. PLDI 08, June 7 13, 2008, Tucson, Arizona, USA. Copyright c . \n2008 ACM 978-1-59593-860-2/08/06. . . $5.00 1. Introduction Linked data structures such as lists, trees, \ngraphs, and hash tables are pervasive in modern software systems. But because of phenom\u00adena such as aliasing \nand indirection, it has been a challenge to de\u00advelop automated reasoning systems that are capable of \nproving im\u00adportant correctness properties of such data structures. 1.1 Background In principle, standard \nspeci.cation and veri.cation approaches should work for linked data structure implementations. But in \nprac\u00adtice, many of the desired correctness properties involve logical constructs such transitive closure \nand quanti.ers that are known to be intractable for automated reasoning systems [36, 45]. Re\u00adsearchers \nhave therefore focused on more tractable goals: verify some (but not all) of the desired correctness \nproperties [6, 18, 28, 42, 47, 49, 50, 74, 88, 89], work with programs that do not ma\u00adnipulate recursive \nlinked data structures [29, 81], or use .niti\u00adzation to check correctness properties within a bounded \nanalysis scope [15, 20, 38, 70, 77, 78]. While systems exist that can specify, and in principle even \npotentially verify, the full range of desired data structure correctness properties [3,7,53,82], to the \nbest of our knowledge no previous system has actually done so (see Section 8). 1.2 The Result This paper \npresents our experience using integrated reasoning in the Jahob veri.cation system to verify a diverse \nset of challeng\u00ading linked data structure implementations. Our proofs establish the full functional correctness \nof the data structure implementations Jahob veri.es formal speci.cations that completely capture the \ndesired behavior of the data structure implementations (with the exception of properties involving execution \ntime and/or mem\u00adory consumption). The source code for the speci.cations, the data structures, and the \nJahob system itself are all publicly available at http://javaverification.org [1]. To the best of our \nknowl\u00adedge, this is the .rst veri.cation of full functional correctness for our target class of linked \ndata structures. 1.3 Basic Speci.cation Approach Our speci.cations use abstract sets and relations to \ncharacterize the abstract state of the data structure. A veri.ed abstraction function establishes the \ncorrespondence between the concrete values that the implementation manipulates when it executes and the \nabstract sets and relations in the speci.cation. Method preconditions and post\u00adconditions written in \nclassical higher-order logic use these abstract sets and relations to express externally observable properties \nof the data structures. We .nd classical higher-order logic to be effective for specifying data structures \nbecause it naturally supports a num\u00adber of constructs: quanti.ers for invariants in programs that manipulate \nan un\u00adbounded number of objects, a notation for sets and relations, which we use to concisely specify \ndata structure interfaces,  transitive closure, which is essential for specifying important properties \nof recursive data structures,  the cardinality operator, which is suitable for specifying numer\u00adical \nproperties of data structures, and  lambda abstraction, which can represent de.nitions of per\u00adobject \nspeci.cation .elds and is useful for parameterized short\u00adhands.  Sets and relations as speci.cation \nvariables enable developers to soundly hide data structure implementation details and provide intuitive \nmethod interfaces. Clients can use such interfaces to check that the data structure is used correctly \nand to reason about the effect of data structure operations. 1.4 Basic Veri.cation Approach Jahob proves \nthe desired correctness properties by .rst generating veri.cation condition formulas, then proving these \nformulas. The veri.cation conditions are proof obligations that, together, ensure that the program respects \nmethod preconditions, postconditions, in\u00advariants, and preconditions of operations such as array accesses \nand pointer dereferences. The veri.cation condition generator requires loop invariants. These can be \nsupplied by the developer or, in some cases, by a shape analysis [88]. The veri.cation condition formulas \nare expressed in an unde\u00adcidable fragment of higher-order logic and are therefore beyond the reach of \nany automated decision procedure. Simple attempts to improve the tractability by limiting the expressive \npower of the logic fail because some of the correctness properties involve inher\u00adently intractable constructs \nsuch as quanti.ers, transitive closure, and lambda abstraction. 1.5 Technical Insights Upon examination, \nhowever, it becomes clear that while the veri.\u00adcation conditions as a whole can be quite complex, they \ncan also be represented as a conjunction of a large number of smaller subfor\u00admulas, many of which are \nstraightforward to prove. Moreover, the remaining subformulas, while containing a diverse group of pow\u00aderful \nlogical constructs, often have enough structure to enable the successful application of specialized decision \nprocedures or theo\u00adrem provers. Speci.cally, some subformulas can be proved with suf.cient quanti.er \ninstantiations, congruence closure algorithms, and linear arithmetic solvers; precise reasoning about \nreachability is suf.cient to discharge others; still others require complex quanti\u00ad.er reasoning but \ndo not require arithmetic reasoning. In the worst case, it is always possible to use interactive theorem \nprovers to dis\u00adcharge the remaining few complex subformulas. Armed with this insight, we developed an \nintegrated reason\u00ading approach that enables the simultaneous application of a diverse group of interoperating \nreasoning systems to prove each veri.ca\u00adtion condition. This approach is based on the following techniques: \n Splitting: Jahob splits veri.cation conditions into equivalent conjunctions of subformulas and processes \neach subformula independently. It can therefore use different provers to estab\u00adlish different parts of \nproof obligations. Because it treats each prover as a black box, it is easy to incorporate new provers \ninto the system. Moreover, each prover can run on a separate proces\u00adsor core, reducing the running time \non modern workstations.  Formula Approximation: Jahob uses a variety of new and ex\u00adisting external decision \nprocedures, Nelson-Oppen provers, and .rst-order theorem provers, each with its own restrictions on the \nset of formulas that it will accept as input. Several formula ap\u00adproximation techniques make it possible \nto successfully deploy  Figure 1. Integrated Reasoning in the Jahob System this diverse set of reasoning \nsystems together within a single uni.ed reasoning framework. These approximation techniques accept higher-order \nlogic formulas and create equivalent or se\u00admantically stronger formulas accepted by the specialized deci\u00adsion \nprocedures and provers. Our approximation techniques rewrite equalities over complex types such as functions, \napply beta reduction, and express set operations using .rst-order quanti.cation. They also soundly approximate \nconstructs not directly supported by a given spe\u00adcialized reasoning system, typically by replacing problematic \nconstructs with logically stronger and simpler approximations. Decision procedures such as MONA [30] \nperform reasoning under the assumption that the models of given formulas are trees. The Jahob interfaces \nto such decision procedures rec\u00adognize subformulas that express the relevant structure (such as treeness \nor transitive closure). They then expose this structure to the decision procedure by applying techniques \nsuch as .eld constraint analysis [87] and encoding transitive closure using second-order quanti.ers. \nTogether, these techniques make it possible to productively ap\u00adply arbitrary collections of specialized \nreasoning systems to complex higher-order logic formulas. Our implemented Jahob system, for example, \ncontains a simple syntactic prover, inter\u00adfaces to .rst-order provers (SPASS [84] and E [76]), an in\u00adterface \nto SMT provers (CVC3 [26] and Z3 [19]), an inter\u00adface to MONA [67], an interface to the BAPA decision \npro\u00adcedure [44, 46], and interfaces to interactive theorem provers (Isabelle [63] and Coq [11]). Proof \nDecomposition: Jahob allows the developer to insert program-point-speci.c lemmas and proof hints into \nthe imper\u00adative source code. Jahob proves these lemmas (using the full range of its reasoning techniques) \nthen uses the lemmas as ad\u00additional assumptions in veri.cation conditions. The developer can also use \ninteractive theorem provers to prove parts of ver\u00adi.cation conditions. These techniques enable the developer \nto guide the proof of any veri.cation conditions that are beyond the reach of the fully automated techniques. \nFigure 1 graphically presents the resulting integrated reasoning architecture of the Jahob system. In \npractice, the syntactic prover quickly disposes of many of the conjuncts in each veri.cation condition. \nA complex core of subformulas makes it through to the more powerful automated reasoning systems. Each \nof these reasoning systems proves the subset of subformulas for which it is applicable; together, they \nprove the majority of the remaining conjuncts. When the automation does not succeed (typically due to \nconjuncts that contain large numbers of universally quanti.ed assumptions), we manually guide the proof \nprocess by inserting veri.ed lemmas and proof hints into the source code. Finally, we use interactive \ntheorem provers to prove veri.cation conditions that require complex inductive reasoning or nonlinear \narithmetic, relying on a body of previously proved lemmas and the ability to fully control the proof \nprocess. 1.6 Consequences of Our Result Full functional speci.cations decouple data structure interfaces \n(as expressed in formal logic) from implementations. The veri.cation of these speci.cations ful.lls, \nfor the .rst time, the previously unrealized ideal of abstract data types and modular reasoning for data \nstructures. We identify several ways in which this research may in.uence future efforts. Veri.ed Data \nStructure Libraries: In retrospect, it is clear that data structures are a natural candidate for full \nfunctional veri.cation. Because data structures have been studied for decades, there is a broad consensus \non how they should behave. It is therefore relatively straightforward to develop the required complete \nformal speci.cations. Because the speci.cation and veri.cation effort can be pro.tably amortized over \nmany data structure uses, data structures can support focused veri.cation efforts that would be impractical \nfor single systems. In the future, developers of data structure libraries may choose to deliver formally \nspeci.ed and fully veri.ed implementations. Advantages of this development could include the elimination \nof ambiguity from data structure interfaces and increased con\u00ad.dence in the correctness of the implementation. \n Integrated Reasoning Systems: In recent years researchers have developed a range of decision procedures, \ntheorem provers, and other reasoning tools [11,16,19,26,27,30,46,47,55,63,65, 76, 84]. Techniques that \nenable these reasoning tools to seam\u00adlessly interoperate within a uni.ed reasoning framework (such as \nNelson-Oppen combination [60] and our formula approx\u00adimation) greatly increase the value of each individual \ntool. One potential result is a proliferation of specialized reason\u00ading tools, a corresponding increase \nin the combined capabilities of automated reasoning systems in general, a move away from monolithic general-purpose \nreasoning systems, and an overall improvement in our ability to effectively reason about complex computer \nsystems.  New Program Analysis Techniques: Pointers and indirection, especially in the context of recursive \ndata structures, are the bane of program analysis. Their presence often complicates, and sometimes even \ninvalidates, many otherwise straightfor\u00adward program analysis approaches.  The .eld has responded by \ndeveloping a variety of pointer and shape analyses [18, 28, 41, 50, 72 75, 83, 86]. These analyses reason \ndirectly about pointers across the entire analyzed range of the program. Despite intensive research efforts \nand many impressive technical results, scalability and/or precision issues continue to limit the utility \nof even the most advanced analyses. Upon re.ection, it becomes clear that standard shape analysis approaches \nare at variance with modern software engineering practices. Decades ago all programmers used to reason \ndirectly about the pointers in their data structures. But the concept of abstract data types enabled \na productive separation of reasoning concerns. With abstract data types, only the implementor of the \ndata structure reasons directly about the pointers in the data structure implementation. Implementors \nof code that uses the data structure reason more productively at the more abstract level of the data \nstructure interface. Until now, the informal and unveri.ed nature of typical data structure interfaces \nhas prevented sound automated reasoning systems from exploiting this kind of structure. But the avail\u00adability \nof fully veri.ed data structure implementations elimi\u00adnates this problem, paving the way for new analysis \napproaches that use veri.ed data structure speci.cations to reason soundly about the program at the higher \nlevel of abstract sets of objects and relations. We expect the resulting analyses 1) to be substan\u00adtially \nmore scalable than existing analyses and 2) to extract sig\u00adni.cantly more useful information. In particular, \nwe have used this approach successfully in the Hob system to obtain anal\u00adyses that deliver an unprecedented \ncombination of scalability and precision [42, 49]. Commuting Operations: If all operations in a computation \ncommute, it is possible to generate code that executes the com\u00adputation in parallel [69]. Applying this \nprinciple to computa\u00adtions that manipulate linked data structures can be challeng\u00ading because commuting \noperations on linked data structures often produce different but semantically equivalent data struc\u00adture \nstates. Veri.ed speci.cations that use sets and relations to soundly summarize the abstract state of \nthe data structure can often eliminate this problem different but semantically equivalent concrete data \nstructure states (such as two lists that store the same set of objects) often have identical abstract \nstates. If the abstract states also differ, it is often possible to use the speci.cation and veri.cation \nsystem to precisely state the de\u00adsired equivalence condition, then prove that operations com\u00admute relative \nto this condition. The correctness proofs also en\u00adsure that properly synchronized parallel computations \ncorrectly preserve the data structure invariants (regardless of whether or not the operations commute). \nThe availability of veri.ed spec\u00adi.cations may therefore substantially extend our ability to rea\u00adson \nsuccessfully about parallel computations that manipulate linked data structures.  1.7 Limitations We \nidentify several limitations of our veri.cation system. First, we assume that each data structure operation \nexecutes atomically. For this assumption to hold in concurrent settings, some form of synchronization \nwould be required. Our current system also does not support dynamic class loading, exceptions, or dynamic \ndis\u00adpatch. Techniques exist, however, that should make it possible to extend our modular veri.cation \napproach to support such con\u00adstructs [8,17,32]. Two limitations could be eliminated by minor ex\u00adtensions. \nWe currently model numbers as algebraic quantities with unbounded precision and assume that object allocation \nalways suc\u00adcessfully produces a new object. While these assumptions are often used in the veri.cation \n.eld and are typically consistent with the execution of the program, they are at variance with the full \nseman\u00adtics of the underlying programming language. Finally, we make no attempt to verify any property \nrelated to the running time or the memory consumption of the data structure implementation. In par\u00adticular, \nwe do not attempt to verify the absence of in.nite loops or memory leaks. 2. Example In this section \nwe use a veri.ed association list to demonstrate how developers use Jahob to specify data structure implementations. \nWe also present a sized list example, which illustrates the coordi\u00adnated application of multiple theorem \nprovers and decision proce\u00addures to verify the speci.cation of a single method. 2.1 Association List \nFigure 2 presents selected portions of the AssocList class. This class maintains a list of key-value \npairs. When presented with a given key it returns the corresponding value for that key. Ja\u00adhob works \nwith Java programs augmented with speci.cations. The speci.cations appear as special comments of the \nform /*: ... */ or //: ... , enabling the use of standard Java compilers and virtual machines. The .rst \ncomment in Figure 2 identi.es the abstract state content of the association list as a relation in the \nform of a set of pairs of objects. 1 Method interfaces. The put(k0,v0) method inserts the pair (k0,v0) \ninto the association list, returning the previous associa\u00adtion for k0 (if such an association existed). \nThe requires clause indicates that it is the client s responsibility to ensure that neither k0 nor v0 \nis null. The modi.es clause indicates that the method observably changes nothing except the abstract \nstate content of the association list. The ensures clause of the speci.cation states that the abstract \nstate content after the method executes is the abstract state old content from before the method executes \naugmented with the new association (k0,v0). Any previous association (k0,result) is removed from the \nassociation list, with result returned as the result of the put method. It returns null if no such previous \nassoci\u00adation existed. The get(k0) method returns the value v associated with k0 if such an association \nexists. Otherwise it returns null. Concrete and abstract state. Figure 3 presents the de.nition of the \nNode class, which contains the key, value, and next .elds that implement the linked list of key-value \npairs in the association list. The assertion claimedby AssocList speci.es that only the methods in the \nAssocList class can access these .elds. Jahob enforces this speci.cation by a simple syntactic check. \nThe Node class also has a speci.cation variable cnt, whose purpose is to de.ne the abstract state content \nof the association list. There is one cnt variable for each Node object. Speci.cation variables exist \nonly to support the speci.cation and veri.cation and do not exist when the program runs. Figure 4 presents \nthe CntDef and CntNull invariants, which to\u00adgether de.ne the value of the cnt speci.cation variable for \neach Node object x. The CntDef invariant recursively de.nes the value of cnt for an object x as the set \nof pairs stored in the part of the asso\u00adciation list reachable from x by following next .elds. The CntNull \ninvariant de.nes the base case of the recursion: cnt is empty for the null object. Because cnt is a ghost \nspeci.cation variable, the implementation uses speci.cation assignments to explicitly update cnt when \nchanging the next, key, and/or value .elds. The speci.cation variable content contains the set of key/value \npairs that comprise the abstract state of the association list. The def\u00adinition of content appears after \nthe vardefs keyword and speci.es that content is the value of cnt for the .rst node in the list. In con\u00adtrast \nto cnt (which is a ghost speci.cation variable), content is a de.ned speci.cation variable: when one \nor more of the variables in the de.nition of content change, Jahob computes the correspond\u00ading changes \nto content automatically. Figure 4 also illustrates how private de.ned speci.cation vari\u00adables such as \nedge can serve as useful shorthands. The edge vari\u00adable denotes either the .rst or the next .eld of the \ncorresponding object, making the InjInv invariant easier to write. Semantic domain. The syntax of Jahob \ninvariants re.ects the underlying semantic domain in which the veri.cation takes place. The domain (denoted \nobj) contains the in.nite set of all objects that 1 Our examples use mathematical notation for concepts \nsuch as set union (.) and universal quanti.cation (.). Developers can use the ProofGeneral editor mode \nto view these symbols in either ASCII or mathematical nota\u00adtion [5] class AssocList {//: public specvar \ncontent :: (obj * obj) set public Object put(Object k0, Object v0) /*: requires k0 .null . v0 = null \nmodi.es content ensures content = old content -{(k0, result )} .{(k0, v0)}. ( result = null .\u00ac (. v. \n(k0, v) . old content)) . ( result .null . (k0, result) . old content) */ = {...} public Object get(Object \nk0) /*: requires k0 .null = ensures ( result = null .\u00ac (. v. (k0, v) . content)) . ( result .null . \n(k0, result) . content) */ = {...}} Figure 2. Association List Operations public /*: claimedby AssocList \n*/ class Node {public Object key; public Object value ; public Node next; //: public ghost specvar cnt \n:: (obj * obj) set = {} } Figure 3. Node De.nition private Node .rst ; vardefs content == .rst .. cnt \n; invariant CntDef: . x. x . Node . x . alloc . x .null . = x .. cnt = {(x..key, x..value)}. x..next..cnt \n. (. v. (x..key, v) ./x..next..cnt) ; invariant CntNull: . x. x . Node . x . alloc . x = null . x..cnt \n= {} ; private static specvar edge :: obj . obj . bool ; vardefs edge == (. x y. (x . Node . y = x..next) \n. (x . AssocList . y = x...rst)) ; invariant InjInv: . x1 x2 y. y .null . edge x1 y . edge x2 y . x1=x2 \n; = Figure 4. Abstraction Function and Invariants in AssocList public Object get(Object k0) /*: requires \nk0 .null = ensures ( result .null . (k0, result) . content) . = ( result = null .\u00ac(. v. (k0, v) . content)) \n*/ { Node current = .rst ; while//: inv .v. ((k0,v) .content) = ((k0,v) .current..cnt) (current != null) \n{ if (current.key == k0) { return current. value ; } current = current.next; } return null ; } Figure \n5. Implementation of the get method the program could use during any execution. Classes correspond to \nsets of objects within this domain. The notation x . Node states that the object x is an element of the \nNode class). Fields correspond to functions from objects to values. The expression x..next denotes the \napplication of the next function to the x object. It is often convenient for these functions to be total \n(i.e., always de.ned for every object) if the object is not a member of a given class, the values of \nall of the .elds from that class are simply null. Veri.ed method implementations. Figure 5 presents the \nimple\u00admentation of the get(k0) method. This method searches the list to .nd the Node containing the key \nk0, then returns the corresponding value v (or null if no such value exists). The loop invariant states \nclass List {private List next; private Object data; private static List root ; private static int size \n; /*: private static ghost specvar nodes :: objset = {} ; public static ghost specvar content :: objset \n= {} ; invariant nodesDef: nodes = {n. n .null . (root,n) .{(u,v). u..next=v}*} ; = invariant contentDef: \ncontent= {x. .n. x=n..data . n.nodes} ; invariant sizeInv: size = cardinality content ; invariant treeInv: \ntree [ List .next] ; ... */ public static void addNew(Object x) /*: requires comment xFresh (x ./content) \nmodi.es content ensures content = old content .{x} */ { List n1 = new List(); n1.next = root; n1.data \n= x; root = n1; size = size + 1; /*: nodes := {n1}. nodes ; content := {x}. content ; note theinv sizeInv \n by sizeInv , xFresh */ }} Figure 6. Sized List $jahob List.java -method List.add -usedp spass mona \nbapa ... ======================================================== Built-in checker proved 2 sequents \nduring splitting. SPASS proved 4 out of 8 sequents. Total time : 0.2 s MONA proved 3 out of 4 sequents. \nTotal time : 0.2 s BAPA proved 1 out of 1 sequents. Total time : 0.0 s ======================================================== \nA total of 10 sequents out of 10 proved. :List.add] 0=== Verification SUCCEEDED. Figure 7. Command line \nand Jahob output in example that com\u00adbines multiple decision procedures to verify one method that the \npair (k0, v) is in the association list if and only if it is in the part of the list remaining to be \nsearched in effect, that the search does not skip the Node with key k0. Given the speci.cation and the \ninvariants, Jahob is capable of verifying that this method both correctly implements its speci.cation \nand correctly preserves the invariants. In addition to the get method, the association list contains \nother methods that check membership of keys in the association list, add associations to the list, and \nremove associations from the list. The basic concepts are the same: statically veri.ed full functional \nspec\u00adi.cations, loop invariants where appropriate, and explicit updates of the appropriate speci.cation \nvariables.  2.2 Sized List Figure 6 presents a simple example [40, Chapter 2] whose veri.\u00adcation requires \nthe combination of three Jahob provers. The add operation inserts a new element into the linked list. \nThe invariants of the linked list maintain the set of linked list nodes, the set of objects stored in \nthese nodes, and the size of the list. The sizeInv invariant requires the size of the data structure \nto be equal to the number of objects reachable from the root. Many natural logical fragments in which \nthis invariant is expressible (such as monadic second-order logic with equicardinality constraints) are \nundecid\u00adable. However, thanks to the use of the nodes and content speci\u00ad.cation variables, the generated \nveri.cation conditions can be split into a conjunction of implications, each of which is provable using \none of the following three provers: 1) MONA [30], 2) the SPASS .rst-order prover [84], and 3) the BAPA \ndecision procedure for sets with cardinality bounds [43, 46]. Our formula approximation tech\u00adnique eliminates \nassumptions not meaningful for a given prover; the values of the speci.cation variables ensure that the \nresulting for\u00admula contains enough information to be provable. Thanks to such mechanisms, Jahob users \ncan use speci.cation variables and as\u00adsertions to simulate the effect of Nelson-Oppen combination for \ncomplex logics to which the Nelson-Oppen procedure traditionally has not been applied [40, Section 4.4.5]. \nFigure 7 presents the Jahob veri.cation report for the add method. This report indicates how many sequents \n(implications that represent parts of veri.cation conditions) were proved by each theorem prover or decision \nprocedure. The command line instructs Jahob to use SPASS, MONA, and the BAPA decision procedure (in that \norder) when attempting to discharge the proof obligations that arise during the veri.cation. 3. Jahob \nSpeci.cation Constructs Developers specify Jahob programs using speci.cation variable declarations, method \ncontracts, class invariants, and annotations within method bodies. 3.1 Jahob Formulas Many Jahob speci.cation \nconstructs contain formulas. The syn\u00adtax and semantics of Jahob formulas follow Isabelle/HOL [63]. Formulas \nare simply typed with ground types bool for boolean values, int for integers, and obj for objects, as \nwell as type con\u00adstructors . for total functions, * for tuples, and set for sets. The logic contains \npolymorphic equality, standard logical connectives ., ., \u00ac, ., ., ., as well as the . binder, set comprehension \n{e.F }, and standard operations on sets and integers. It supports selected de.ned operations, most notably \n(u, v) .{(x, y).G} * for transi\u00adtive closure, tree[f1,...,fn] denoting that a data structure is a tree, \nand cardinality for the cardinality of .nite sets. 3.2 Speci.cation Variables In addition to concrete \nJava variables, Jahob supports speci.cation variables [24, Section 4], which do not exist during program \nexe\u00adcution but are useful to specify the behavior of methods without re\u00advealing the underlying data structure \nrepresentation. The developer uses the specvar keyword to introduce a speci.cation variable, in\u00addicate \nits type and an optional initial value, whether the variable is public or private, and whether it is \na static or instance variable. If a variable is not static, Jahob lifts the variable s type from the \nspeci.ed type t to obj . t, converting it into a variable of function type. There are two kinds of speci.cation \nvariables in Jahob: ghost variables and de.ned variables. Ghost variables must be updated explicitly \n(but Jahob ensures soundness in the presence of such up\u00addates). De.ned variables are simply ways to name \nthe value of an expression (which appears in the declaration of the variable). The de.nitions of de.ned \nvariables must be acyclic. For recursive def\u00adinitions the developer can use transitive closure or a ghost \nvariable with a class invariant that encodes the desired recursive relation\u00adship. 3.3 Method Contracts \nA method contract in Jahob contains three parts: 1) a precondition, written as a requires clause, stating \nthe properties of the program state and parameter value that must hold before a method is in\u00advoked; 2) \na frame condition, written as a modi.es clause, listing the components of the state that the method may \nmodify (the remain\u00ading components remain unchanged); and 3) a postcondition, written as an ensures clause, \ndescribing the state at the end of the method (possibly de.ned relative to the parameters and state at \nthe entry of the method). Jahob uses method contracts for assume/guarantee reasoning in the standard \nway. When analyzing a method m, Jahob assumes m s precondition and checks that m satis.es its postcon\u00addition \nand the frame condition. Dually, when analyzing a call to m, Jahob checks that the precondition of m \nholds and assumes that the values of state components from the frame condition of m change subject only \nto the postcondition of m, and that the state components not in the frame condition of m remain unchanged. \nPublic methods omit changes to the private state of their enclosing class and instead use public speci.cation \nvariables to describe how they change the state. Methods typically do not specify changes to newly allocated \nobjects (the exception is that if a .eld f is changed for allocated objects and is otherwise not mentioned \nin the modi\u00ad.es clause, then the developer needs to add the special item NEW.f into the modi.es clause). \n 3.4 Class Invariants A class invariant can be thought of as a boolean-valued speci.ca\u00adtion variable \nthat Jahob implicitly conjoins with the preconditions and postconditions of public methods. The developer \ncan declare an invariant as private or public (the default annotation is private). Typically, a class \ninvariant is private and is visible only inside the implementation of the class. Jahob conjoins the private \nclass in\u00advariants of a class C to the preconditions and postconditions of methods declared in C. To ensure \nsoundness in the presence of callbacks, Jahob also conjoins each private class invariant of class C to \neach reentrant call to a method m declared in a different class C1. This policy ensures that the invariant \nC will hold if C1.m (ei\u00adther directly or indirectly) invokes a method in C. To make the in\u00advariant F \nwith label l hold less often than given by this policy, the developer can write F as b . I for some speci.cation \nvariable b. To make F hold more often, the developer can use assertions with the shorthand (theinv l) \nthat expand into F .  3.5 Annotations Within Method Bodies The developer can use several kinds of annotations \ninside a method to re.ne expectations about the behavior of the code, to guide the analysis by stating \nintermediate facts, or to debug the veri.cation process. Loop invariants. The developer states a loop \ninvariant of a while loop immediately after the while keyword using the keyword in\u00advariant (or inv for \nshort). Each loop invariant must hold before the loop condition and be preserved by each iteration of \nthe loop. The developer can omit conditions that depend only on variables not modi.ed in the loop Jahob \nuses a simple syntactic analysis to conclude that the loop preserves such conditions. Local speci.cation \nvariables. In addition to speci.cation vari\u00adables at the class level, the developer can introduce ghost \nor non\u00adghost speci.cation variables that are local to a particular method and are stated syntactically \nas statements in the method body. Such variables can be helpful to simplify proof obligations or to state \nrelationships between the values of variables at different program points. Non-deterministic change. \nA speci.cation statement of the form havoc x suchThat G, where x is a variable and G is a formula, changes \nthe value of x subject only to the constraint G (for exam\u00adple, the statement havoc x suchThat 0 = x sets \nx to an arbitrary non-negative value). To ensure soundness, Jahob emits an assertion that veri.es that \nat least one such value of x exists. Consequently, a havoc statement can also be used to pick a witness \nfor an ex\u00adistentially quanti.ed assumption .x.G and to make this witness available for subsequent speci.cation. \nA speci.cation assignment of the form x := e (for x not occurring in e) is a special case of the havoc \nstatement whose condition is x = e (its feasibility condition is trivial). Jahob also supports .eld speci.cation \nassignments of the form x..f := e, which is a shorthand for f := f(x := e). Here f(x := e) is the standard \nfunction update expression returning a function identical to f except at x where it has value e. Assert. \nAn assert G annotation at program point p in the body of the method requires the formula G to be true \nat the program point p. Like standard Java assertions, Jahob assertions identify conditions that should \nbe true at a given program point. An important differ\u00adence is that Jahob assertions are statically checked \nto hold for all executions rather than dynamically checked for only the current ex\u00adecution. In particular, \nJahob assertions produce proof obligations that Jahob statically veri.es to guarantee that G will be \ntrue in all program executions that satisfy the precondition of the method. Assume. An assume G statement \nis dual to the assert statement. Whereas an assert requires Jahob to demonstrate that G holds, an assume \nstatement allows Jahob to assume that G is true at a given program point. The developer-supplied use \nof assume statements may violate soundness and causes Jahob to emit a warning. The intended use of assume \nis debugging, because it allows Jahob to verify a method under the desired restricted conditions. For \nexam\u00adple, a speci.cation statement assume False at the beginning of a branch of an if statement means \nthat Jahob will effectively skip the veri.cation of that branch. More generally, assume statements al\u00adlow \nthe developer to focus the analysis on a particular scenario of interest (e.g. a particular aliasing \ncondition) and therefore under\u00adstand better why a proof attempt is failing. Specifying lemmas. A note \nG statement is a sequential composi\u00adtion of assert G followed by assume G. It is always sound for the \ndeveloper to introduce a note statement because Jahob .rst checks the condition G before assuming it. \nTherefore, note G is seman\u00adtically equivalent to assert G, but instructs Jahob to use G as a useful lemma \nin proving subsequent conditions. Such lemmas can often overcome limitations of automated provers by \nproviding key intermediate steps in the proof. Specifying which assumptions to use. note G and assert \nG state\u00adments can optionally contain a clause by l1,...,ln to identify the facts from which the formula \nG should follow. We found the by construct particularly helpful for guiding .rst-order and SMT provers \nto an appropriate set of facts to use when the number and the complexity of the invariants becomes large \n[14]. The identi.ers li can refer to the labels of facts introduced by previous note and assume statements, \npreconditions, invariants, conditions encoding a path in the program, or parts of formulas explicitly \nlabelled using the comment construct. Case analysis and hypothetical reasoning. When establishing note \nG, the developer can help the provers by doing a case analysis on some condition F . One way to achieve \nthe case analysis is to use a sequence note l1:(F . G); note l2:((\u00acF ) . G); note G by l1,l2 However, \nproving an implication such as F . G may itself require further note statements, which are valid only \nunder the assump\u00adtion F . Jahob therefore supports hypothetical blocks of the form assuming l1:F in (c \n; note G). Within such a block, Jahob inserts F as an assumption. The block can contain further proof \nstatements that derive consequences of F and previously known facts. (The block may not contain executable \nJava statements.) If the veri.ca\u00adtion of the block succeeds, Jahob inserts the formula F . G after the \nblock. To ensure soundness, the assumption F does not persist outside the block. Proving universally \nquanti.ed statements. To show that an as\u00adsertion .x.G holds after a sequence of statements c, instead \nof us\u00ading the sequence (c; note .x.G),a Jahob developer can instead use the statement (pickAny x in (c \n; note G)). With the pickAny construct, the universally quanti.ed variable x becomes visible in\u00adside \nthe statements c as a speci.cation variable with arbitrary value. The developer can therefore state lemmas \nthat involve x as a .xed variable and therefore help in the proof of G. Note that x is not a quanti.ed \nvariable in such veri.cation conditions, which simpli.es the theorem proving task. Moreover (unlike the \nassuming block), the statements c may contain Java code (including loops). The use of the pickAny construct \nmay therefore make it possible to elim\u00adinate universal quanti.ers from loop invariants (and the resulting \nveri.cation conditions). 4. Generating Veri.cation Conditions Jahob produces veri.cation conditions by \nsimplifying the Java code and transforming it into extended guarded commands (Fig\u00adure 8), then desugaring \nextended guarded commands into simple guarded commands (Figure 9), and .nally generating veri.cation \nconditions from simple guarded commands in a standard way (Fig\u00adure 10). 4.1 Representation of Program \nMemory The state of a Jahob program is given by a .nite number of con\u00adcrete and speci.cation variables. \nThe types of speci.cation vari\u00adables appear in their declarations. Jahob maps the types of con\u00adcrete \nJava variables as follows. Static reference variables become variables of type obj (obj is the type of \nall object identi.ers). An instance variable f in a class declaration class C {Df} becomes a function \nf :: obj . obj mapping object identi.ers to object iden\u00adti.ers. The Java expression x.f becomes fx, that \nis, the function f applied to x. Jahob represents Java class information using a set of objects for each \nclass. For example, Jahob generates the axiom .x.x . C . fx . D for the above .eld f. Note that the function \nf is total. When x is null or of a class that does not include the .eld f, Jahob assumes that fx = null.(Jahob \ncorrectly checks for the absence of null dereferences by creating an explicit assertion before each dereference.) \nJahob represents an object-valued array as a function of type obj . int . obj, which accepts an array \nand an index and returns the value of the array at the index. Jahob also introduces a function of type \nobj . int that indicates the ar\u00adray size, and uses it to generate array bounds check assertions. The \ntype int represents the integer type, which Jahob models as the set of unbounded mathematical integers. \n 4.2 From Java to Guarded Commands Jahob s transformation of Java into guarded commands resembles a compilation \nprocess. Jahob simpli.es executable statements into three-address form to make the evaluation order in \nexpressions ex\u00adplicit. It also inserts assertions that check for null dereferences, ar\u00adray bounds violations, \nand type cast errors. It converts .eld and array assignments into assignments of global variables whose \nright\u00adhand side contains function update expressions. Having taken the side effects into account, it \ntransforms Java expressions into math\u00adematical expressions in higher-order logic. Receiver parameters \nin speci.cations. Java makes most uses of the receiver this parameter implicit, with the compiler us\u00ading \nscoping rules to resolve the reference. Jahob applies similar rules to disambiguate occurrences of variables \nin speci.cation con\u00adstructs. When a .eld f occurs in an expression that is not imme\u00addiately of the form \nx..f and when f is not quali.ed with a class name, Jahob converts the occurrence of f into this..f. Jahob \nalso transforms each de.nition x=f of a non-static speci.cation variable x into the de.nition x= . this.f. \nIf, after transformation, a class invariant Inv in class C contains an occurrence of this, Jahob trans\u00adforms \nInv into the invariant .this.this . C . this . alloc . Inv. An invariant stated for a given object is \ntherefore implicitly inter\u00adpreted as being required for all allocated objects of the class, and becomes \na global invariant. This mechanism enables Jahob devel\u00adopers to not only concisely state invariants on \na per-object basis but also to use global invariants that state relationships between differ\u00adent instances \nof the class. 4.3 From Extended to Simple Guarded Commands We call the main internal representation \nof Jahob the extended guarded command language because it contains guarded com\u00admand statements, proof \ncommands, and simple control structures. Figure 8 presents the syntax of the extended guarded command \nlanguage. We next describe how Jahob transforms such guarded commands into the simple guarded command \nlanguage (for which veri.cation condition generation is standard as presented in Fig\u00adure 10). Translating \nstate changing statements. Figure 11 describes the translation of guarded commands that change the state. \nWe can represent assignments using havoc followed by an equality con\u00adstraint, which reduces all state \nchanges to havoc statements. Con\u00additional statements become non-deterministic choice with assume statements, \nas in control-.ow graph representations. The Jahob en\u00adcoding of loops with loop invariants is analogous \nto the sound ver\u00adsion of the encoding in ESC/Java [25]. Encoding and semantics of proof constructs. One \nof our ob\u00adservations is that proof constructs have natural translations into the guarded command language \n(as presented in Figure 12). This translation can also be viewed as providing a semantics for our proof \nconstructs. With very modest requirements on the underlying provers (completeness for propositional reasoning \nand the ability to perform uni.cation), the constructs pickAny, havoc, and note form a complete proof \nsystem for .rst-order logic. We therefore believe that the expressive power of these constructs and the \nsimplicity of their translation into guarded commands makes them an appealing candidate for annotations \nin any software veri.cation system.  4.4 Accounting for Variable Dependences The semantics of extended \nguarded commands assumes a set D of speci.cation variable de.nitions (v, Dv) where v is a variable and \nDv is a term representing the de.nition of v in terms of other variables. If .u is a list of variables \nwe write deps(.u) for the set of all variables that depend on any of the variables in .u, that, is, variables \nwhose value may change if one of the variables .u changes. To de.ne this set precisely, let FV(G) denote \nall free variables in G, let the dependence relation be . = {(v1,v2) |(v2,D2) . D . v1 . FV(D2)} and \nlet . * denote the transitive closure of .. Then deps(u1,...,un)= .ni=1{v | (ui,v) . . * }. We write \ndefs(.u) for the set of constraints expressing these dependencies, with defs(.u)= {v = Dv | v . deps(.u) \n. (v, Dv) . D}. To correctly take dependences into account during veri.cation condition generation, it \nsuf.ces to treat in Figures 11 and 12 each command of the form havoc .x as the command (havoc (.x, deps(.x)) \n; assume defs(.x)). Eliminating unnecessary assumptions. To simplify the generated veri.cation conditions, \nsome of the internally generated assume statements indicate a variable that the statement is intended \nto constrain. For example, an assumption generated from a variable de.nition v = Df is meant to constrain \nthe variable v, as are assumptions of the form v . C where C is a set of objects of class C. Ignoring \nan assumption is always sound, and Jahob does so whenever the postcondition does not contain a variable \nthat the assumption is intended to constrain. Moreover, in certain cases Jahob reorders consecutive assume \nstatements to increase the number of assumptions that it can omit. c ::= assume l: F | assert l: F by \nh | havoc .x suchThat F | x := F | note l:F by h | assuming F in (cpure ; note G) | pickAny .x in (c \n; note G) | c1 . c2 | c1 ; c2 | if(F ) c1 else c2 | loop inv(I) c1 while(F ) c2 Figure 8. Extended guarded \ncommands c ::= assume l: F | assert l: F by h | havoc x | c1 . c2 | c1 ; c2 Figure 9. Simple guarded \ncommands F [l] . G F [l;h] . G wlp((assume l: F ),G)= wlp((assert l: F by h),G)= wlp((havoc .x),G)= ..x. \nG wlp((c1 . c2),G)= wlp(c1,G) . wlp(c2,G) wlp((c1 ; c2),G)= wlp(c1, wlp(c2,G)) Figure 10. Weakest preconditions \nfor simple guarded commands for v fresh variable, .x := F . = assume (v = F ) ; havoc x ; assume (x = \nv) .if(F ) c1 else c2. =(assume F ; c1) .(assume \u00acF ; c2) .loop inv(I) c1 while(F ) c2. = assert I ; \nhavoc .r ; assume I ; c1 ; (assume (\u00acF ) .(assume F ; c2 ; assert I ; assume false)) Figure 11. Translating \nexecutable constructs into simple com\u00admands .havoc .x suchThat F .= assert ..x.F ; havoc .x ; assume \nF .note l:F by h.= assert l: F by h ; assume l: F .assuming F in (cpure ; note G).=(skip .(assume F ; \ncpure ; assert G ; assume false)) ; assume (F . G) .pickAny .x in (c ; note G).=(skip .(havoc .x ; c \n; assert G ; assume false)) ; assume ..x.G Figure 12. Translating proof constructs into simple commands \nA . G1 . G2 . A . G1,A . G2 .[q] B[q]) . G[pq] A . (B.. G[p]). (A.. . A ..x.G . A . G[x := xfresh] Figure \n13. Splitting rules converting a formula into implication list (notation F [c] denotes formula F annotated \nwith string c) 5. Proving Veri.cation Conditions Jahob generates a proof obligation for each method it \nveri.es. These veri.cation conditions are expressed in a subset of the Is\u00adabelle/HOL notation. We next \ndiscuss how Jahob proves such ver\u00adi.cation conditions. 5.1 Splitting Jahob follows the standard rules \nin Figure 10 to generate veri.ca\u00adtion conditions. Veri.cation conditions generated using these rules \ncan typically be represented as a conjunction of a large number of conjuncts. Figure 13 describes Jahob \ns splitting process, which produces a list of implications whose conjunction is equivalent to the original \nformula. The individual implications correspond to dif\u00adferent paths in the method, as well as different \nconjuncts of assert statements, operation preconditions, invariants, postconditions, and preconditions \nof invoked methods. The splitting rules in Jahob preserve formula annotations, which are used for assumption \nselection and in error messages to indicate why a veri.cation failed. Because Jahob splits only the goal \nof an implication, the number of generated implications is polynomial in the size of the original veri.cation \ncondition (the veri.cation condition itself can be exponential in the size of the method). During splitting \nJahob eliminates simple syntactically valid implications, such as those whose goal occurs as one of the \nassumptions. 5.2 Using Multiple Provers A typical data structure operation generates a veri.cation condition \nthat splitting separates into a few hundred implications, each of which is a candidate for any of the \nprovers in Figure 1. Each implication generated from a veri.cation condition must be valid for the data \nstructure operation to be correct. Each proof can be performed entirely independently. To prove an implication, \nJahob may attempt to use any of the available provers. In practice, a Jahob user speci.es, for a given \nveri.cation task, a sequence of provers and their parameters on the command line. Jahob tries the provers \nin sequence, so the user lists the provers starting from the ones that are most likely to succeed or, \nif possible, fail quickly when they do not succeed. Often different provers are appropriate for different \nproof obligations in the same method. For such cases Jahob provides a facility to spawn provers in parallel \nand succeed as soon as at least one of them succeeds. On multi-core machines the resulting parallel execution \ncan reduce the overall proof time. On single-core machines it may enable an appropriate prover to quickly \nprove the fact without waiting for any inappropriate provers to .nish.  5.3 Formula Approximation Ef.cient \nprovers are often specialized for a particular class of formulas. One of the distinguishing characteristics \nof Jahob is its ability to integrate such specialized provers into a system that uses an expressive fragment \nof higher-order logic. This integration is based on the concept of formula approximation, which maps \nan arbitrary formula into semantically stronger but simpler formulas in an appropriate subset of higher-order \nlogic. Because the resulting formulas are stronger, the approach is sound. Figure 14 presents the general \nidea of approximation: for atomic formulas representable in the target logic subset, the approxima\u00adtion \nproduces the appropriate translation; for logical operations it proceeds recursively; for unsupported \natomic formulas it produces true or false depending on the polarity of the formula. To improve the precision \nof this recursive approximation step, Jahob .rst ap\u00adplies rewrite rules that substitute de.nitions of \nvalues, perform beta reduction, and .atten expressions. The details of rewriting and ap\u00adproximation depend \non the individual prover interface. a : {0, 1}\u00d7 F . C ap(f1 . f2) = ap(f1) . ap (f2) ap(f1 . f2) = ap(f1) \n. ap (f2) ap\u00acap (\u00acf) = (f) ap(.x.f) =.x.ap(f); ap(.x.f) =.x.ap(f) ap(f) = e, for f directly representable \nin C as e a0(f) = false, for f not representable in C a1(f) = true, for f not representable in C Figure \n14. General formula approximation scheme 6. Provers Deployed in Jahob We next describe how we integrated \nseveral provers into Jahob. 6.1 Syntactic Prover Before invoking external provers, Jahob .rst tests whether \nthe for\u00admula is trivially valid. Speci.cally, it checks for the presence of appropriately placed propositional \nconstants false and true. It also checks whether or not the conclusion of an implication appears in the \nassumption (modulo simple syntactic transformations that pre\u00adserve validity). In practice these techniques \ndischarge many veri.\u00adcation condition conjuncts. The .rst source of such conjuncts is checks such as \nnull dereferences which occur (implicitly) many times in the source code. The second source is sequences \nof method calls, speci.cally when class invariants that hold after one method call need to be shown to \nhold for subsequent calls. For complex formulas the syntactic prover is very useful because more sophisti\u00adcated \nprovers often perform transformations that destroy the struc\u00adture of the formula, converting it into \na form for which the proof attempt fails. 6.2 First-order Provers Decades of research into .rst-order \ntheorem proving by resolu\u00adtion have produced carefully engineered systems capable of prov\u00ading non-trivial \n.rst-order formulas [76, 80, 84]. Jahob leverages this development by translating higher-order logic \ninto .rst-order logic [14]. This translation is very effective for formulas without transitive closure \nand arithmetic. Such formulas may contain set ex\u00adpressions, but those expressions are typically quanti.er-free, \nwhich enables their translation into quanti.ed .rst-order formulas. Using ghost variables and recursive \naxioms we are also able to use .rst\u00adorder provers to prove strong properties about reachability in data \nstructures [14]. Our translation uses an incomplete set of axioms for ordering and addition to provide \npartial support for linear arith\u00admetic. We found this axiomatization effective for reasoning about data \nstructures such as hash tables. 6.3 SMT Provers Provers based on Nelson-Oppen combination of decision \nproce\u00addures enhanced with quanti.er instantiation have been among the core technologies of past veri.cation \nsystems [60]. Jahob incor\u00adporates state-of-the art solvers in this family using the SMT-LIB standard \nformat [67]. Overall, the approximation for this format is similar to the approximation for .rst-order \nprovers, but uses the SMT-LIB representation of linear arithmetic. We have primarily used two SMT provers \nin Jahob: CVC3 [26] and Z3 [19]. 6.4 MONA MONA is a decision procedure for monadic second-order logic \nover strings and trees [30]. Its expressive power stems from its abil\u00adity to quantify over sets of objects. \nQuanti.cation over sets can in turn encode transitive closure, which is extremely useful for rea\u00adsoning \nabout recursive data structures. Jahob contains a .exible interface that enables the use of MONA even \nfor some non-tree data structures [87]. When proving an implication A1,...,An . G this interface identi.es \nassumptions of the form tree[f1,...,fn], then interprets the formula assuming that f1,...,fn form the \ntree back\u00adbone of the data structure. Furthermore, it identi.es assumptions Ai of the form .xy.f(x)=y \n. H(x, y) (for f/ .{f1,...,fn}) and soundly approximates a goal of the form G(f(t)) with the stronger \ngoal .u.H(t, u) . G(u). This enables the approximation to maintain information about non-tree .elds and \nprovides certain completeness guarantees [87, Theorems 2 and 3]. 6.5 BAPA Jahob also implements decision \nprocedures for sets with symbolic cardinality bounds [43, 46]. This decision procedure can prove a class \nof veri.cation conditions that use set algebra, symbolic car\u00addinality constraints, and linear arithmetic \n(i.e., quanti.er-free Pres\u00adburger arithmetic). Such veri.cation conditions arise when check\u00ading invariants \non the size of allocated structures, as in the sized list example of Section 2.2 and other examples such \nas tracking the number of objects that a method allocates [46]. Previous theorem provers have limited \neffectiveness for such formulas because set al\u00adgebra and linear arithmetic interact in non-trivial way \nthrough the cardinality operator.  6.6 Isabelle and Coq Jahob provides interfaces to the Isabelle [63] \nand Coq [11] interac\u00adtive theorem provers. Jahob can invoke Isabelle automatically on a given proof obligation \nusing the general-purpose theorem proving tactic in Isabelle. In some cases (e.g., for relatively small \nproof obli\u00adgations that involve complex set expressions) this approach suc\u00adceeds even when other approaches \nfail. In general, Isabelle requires interaction, so the user can prove the implication interactively \nand save it into a .le. Jahob loads this .le in future veri.cation attempts and treats such proven lemmas \nas true. 7. Veri.ed Data Structures We have speci.ed and veri.ed the following data structures: Association \nList: The association list data structure discussed in Section 2.  Space Subdivision Tree: A three-dimensional \nspace subdivi\u00adsion tree. Each internal node in the tree stores the pointers to its subtrees in an eight-element \narray.  Spanning Tree: A spanning tree for a graph. Veri.ed properties include that the produced data \nstructure is, in fact, a tree and that this tree includes all nodes reachable from the root of the graph. \n Hash Table: A hash table implementing a map from objects to objects, implemented as an array of linked \nlists storing keys and values.  Binary Search Tree: A binary search tree implementing a set, with tree \noperations veri.ed to preserve tree shape, ordering, and changes to tree content.  Priority Queue: A \npriority queue stored as a complete binary tree in a dense array, with parent and child relationships \ncom\u00adputed by arithmetic operations on array indices. Among the ver\u00adi.ed properties is that the .ndMax \nmethod returns the smallest element in the queue, a property that requires verifying that all operations \npreserve the heap ordering invariant.  Array List: A list stored in an array implementing a map from \nintegers to objects, optimized for storing maps from a dense subset of the integers starting at 0 (modelled \nafter  Data Structure Association List Space Subdivision Tree Spanning Tree Hash Table Binary Search \nTree Priority Queue Array List Circular List Singly-Linked List Cursor List Syntactic Isabelle Interactive \nTotal Prover MONA Z3 SPASS E CVC3 Script Proof Time 227 120 (8.9s) 12.0s 392 269 (46.9s) 9 (2.5s) 1 70.9s \n368 80 (142.6s) 22 (2.0s) 172.2s 570 222 (58.3) 1(0.5) 6 73.6s 469 665 (6232.1s) 170 (7.5s) 10 (0.5s) \n6265.0s 311 179 ( 4.9) 4 12.9s 400 306 (60.8s) 16 (66.7s) 2 (9.9s) 161.1s 26 100 (183.6s) 184.4s 74 94 \n(5.9s) 6.9s 193 218 (27.6s) 17 (2.3s) 41.2s Figure 15. Number of Proved Sequents and Veri.cation Times \nfor Veri.ed Data Structures java.util.ArrayList). Method contracts in the list describe operations using \nan abstract relation {(0,v0),..., (k, vk)}, where k +1 is the number of stored elements. Circular List: \nA circular doubly-linked list implementing a set interface.  Singly-Linked List: A null-terminated singly-linked \nlist imple\u00admenting a set interface.  Cursor List: A list with a cursor that can be used to iterate over \nthe elements in the list and, optionally, remove elements during the iteration. Method contracts include \nchanges to the list content and to the position of the iterator.  Together, these data structures comprise \na representative subset of the data structures found in a typical program. 7.1 Veri.cation Statistics \nFigure 15 contains, for each data structure, a line summarizing the veri.cation process for that data \nstructure. Each line contains a breakdown of the number of sequents proved by each theorem prover or \ndecision procedure when verifying the corresponding data structure. The theorem provers or decision procedures \nare ap\u00adplied in the order in which they appear in the table. A blank entry indicates that the corresponding \ntheorem prover or decision proce\u00addure was not used during the veri.cation. Figure 15 also presents, for \neach theorem prover or decision procedure, the time it took try\u00ading to prove the sequents it attempted \nto prove. Consider, for ex\u00adample, the SPASS entry for the Association List. This entry is 120 (8.9s), \nindicating that, for the Association List data structure, the SPASS theorem prover took 8.9 seconds trying \nto prove sequents, and succeeded in proving 120 of them (the 8.9 seconds includes time spent on unsuccessful \nproof attempts for sequents that were later proved by another prover). The .nal column presents the total \nveri.cation time, which includes the time spent in the veri.cation condition generator, splitter, syntactic \nprover, and any applied deci\u00adsion procedures or theorem provers. Most of the data structures ver\u00adify \nwithin several minutes. The outlier is the binary search tree with a total veri.cation time of an hour \nand forty-.ve minutes (primarily due to the amount of time spent in the MONA decision procedure). 7.2 \nDiscussion Figure 15 illustrates how Jahob effectively combines the capabili\u00adties of multiple theorem \nprovers and decision procedures to verify sophisticated data structure correctness properties. It also \nillustrates how the different capabilities of these theorem provers and decision procedures are necessary \nto obtain the correctness proofs. For ex\u00adample, although the vast majority of the sequents are proved \nby fully automated means, the occasional use of interactive proofs is critical for enabling the veri.cation \nof our set of data structures. In our experience specifying and verifying a new data structure requires \ninsight into why the data structure implementation is cor\u00adrect combined with familiarity with the veri.cation \nsystem. At this point we are able to implement, specify, and fully verify a new, rel\u00adatively simple data \nstructure (such as a list implementation of a set) in several hours. More complicated data structures \n(such as a space subdivision tree) can take days or even, in extreme cases, a week or more. Our current \ndesign emphasizes the simplicity of the underlying semantic model. Almost all required correctness properties \nthere\u00adfore appear explicitly in both the speci.cations and the generated veri.cation conditions. Different \ndesigns are possible. For exam\u00adple, Jahob could support a system of defaults that would enable developers \nto work with simpler speci.cations. Similarly, an en\u00adhanced (but more complex) veri.cation condition \ngenerator could use simple checks to eliminate many properties before veri.ca\u00adtion condition generation. \nWe anticipate that an optimal distribu\u00adtion of the veri.cation responsibility across the different compo\u00adnents \nof the veri.cation system will become clearer as researchers gain more experience with the problem. 8. \nRelated Work We discuss the Hob analysis system and related work in shape anal\u00adysis, software veri.cation \nsystems, interactive theorem provers, and .nitization and automated testing. Hob. The Hob system supports \nveri.ed data structure interfaces that use sets of objects to summarize the state of the data structure \nand the effect of data structure operations [42,49]. Because the Hob speci.cation language is based on \nsets, it is powerful enough to specify full functional correctness only for data structures that ex\u00adport \na set interface. For data structures with richer interfaces (such as hash tables and search trees) it \ncan specify and verify some, but not all, correctness properties. Like Jahob, Hob integrates a variety \nof reasoning techniques to successfully discharge generated veri.\u00adcation conditions, including the use \nof arbitrarily precise reasoning techniques within data structure implementations. Hob emphasizes the \nuse of the veri.ed speci.cations in the anal\u00adysis of data structure clients. We have successfully used \nHob to develop new analyses with an unprecedented combination of scal\u00adability and precision. Indeed, \nour results show that Hob is capable of specifying and verifying deep properties that capture important \nconcepts from the underlying domain of the program. These prop\u00aderties are directly meaningful not just \nto the developers of the pro\u00adgram, but (perhaps more importantly) also to its users. To the best of our \nknowledge, Hob is the .rst system capable of specifying and verifying these kinds of outward-looking, \napplication-and domain\u00adoriented correctness properties. Shape analysis. The goal of shape analysis is \ntypically to ver\u00adify only data structure shape properties (and not full functional correctness properties \nsuch as the change of data structure con\u00adtent) [18, 28, 28, 41, 50, 74]. Parameterized shape analyses \nsuch as TVLA have been extended to prove properties beyond shape, such as ordering of list elements [52] \nand the correctness of a binary search tree with a set interface [68] (using manually devised and un\u00adveri.ed \nrules for updating instrumentation predicates). Approaches to automating separation logic have similarly \nfocused primarily on shape properties as opposed to full correctness properties [10]. These approaches \nhave recently been extended to verify bag and size properties (although the system does not support arrays \nor loops) [62]. Advanced type systems similarly use recursive data structure speci.cations with fold \nand unfold as proof rules [22,89]. Although these type systems could, in principle, be extended to prove \nspeci.cations that use relations as speci.cation variables, we are not aware of any system that has done \nso. Decision procedures based on .nite quanti.er instantiation [55] are effective for reasoning about \nlocal properties of data struc\u00adtures but are not complete for reachability properties. However, decision \nprocedures that support reachability exist that can ver\u00adify programs that manipulate only linked lists \n[47]. In some cases, it is also possible to express reachability properties in .rst-order logic [14, \n41, 48, 51, 55, 61]. Approaches based on MONA [58, 87] guarantee completeness for reachability properties. \nBy themselves, these approaches are not suf.cient for the veri.cation of many im\u00adportant data structure \nproperties. Our experience indicates, how\u00adever, that they become very useful in combination with other \ntech\u00adniques. The applicability of decision procedures such as MONA can be extended using structure simulation \n[37], provided that cer\u00adtain conditions are met. A Jahob user can use a tree declaration over manually \nupdated ghost .elds to obtain some of the bene.ts of structure simulation. Automated .rst-order or SMT \nprovers can inductively prove the conditions required for the soundness of this approach as a part of \nthe standard veri.cation process, without re\u00adquiring any special support or methodology. Software model \ncheckers based on predicate abstraction use the\u00adorem provers to over-approximate reachable program states \n[6,31]. A recent combination with shape analysis can verify shape prop\u00aderties, yielding performance better \nthan when using shape analysis alone [12]. Jahob contains an implementation of an alternative ap\u00adproach, \nsymbolic shape analysis [66,87,88], which generalizes the predicate abstraction domain to perform shape \nanalysis. We have not used symbolic shape analysis for the examples in this paper. However, we have applied \nsymbolic shape analysis to somewhat simpler data structures, including lists, trees, and arrays [88]. \nThe analysis successfully inferred loop invariants and proved the full functional correctness of operations \nthat insert elements into data structures that implement a set interface. Shape analyses occupy an uneasy \nposition in a world with veri\u00ad.ed data structure speci.cations. Analyses involving data structure clients \nare invariably better off working with the higher-level ab\u00adstractions present in the speci.cations rather \nthan directly with the pointers in the implementations. Although shape analyses can be useful for automating \nparts of the analysis of data structure imple\u00admentations (indeed, we have used this technology for this \npurpose ourselves), their value is undercut by the fact that less automated techniques are perfectly \nadequate for this purpose. Software veri.cation tools. Software veri.cation tools that can prove properties \nof linked data structures include Spec# [8], ESC/Modula-3 [21], ESC/Java [24], ESC/Java2 [17], Krakatoa \n[23, 53], KIV [7], KeY [3], and LOOP [82]. To the best of our knowledge, none of these systems have been \nused to verify the full functional correctness of a collection of linked data structures. For example, \nthe LOOP system has been used to prove the correctness of the Java Vector class implementation [33, 34], \nwhich is not a re\u00adcursive linked data structure. LOOP, KIV, Jive, and Krakatoa have been used to verify \nsmartcard applications (an electronic purse and the Mondex case study [29, 79, 81]), which do not contain \ncom\u00adplex linked data structures. KeY has also been used to prove the correctness of an insertion operation \ninto a TreeMap [71]. While these efforts suggest that the veri.cation of linked data structures is possible \nin principle, the scope of these previous results does not establish the extent to which this veri.cation \nis feasible in practice using these systems. Jahob s integrated reasoning approach (speci.cally the integra\u00adtion \nof a wide range of theorem provers and decision procedures via a new combination technique in conjunction \nwith features that enable the developer to guide the veri.cation process when nec\u00adessary) makes it feasible \nto verify a range of linked data structure implementations. Moreover, previous systems do not, to the \nbest of our knowledge, use decision procedures (such as MONA [30]) that enable complete reasoning over \nlist and tree data structures, nor do they use decision procedures (such as the BAPA decision proce\u00addure \n[43,46]) to reason about sets with cardinality constraints. Proof methods based on natural deduction \ncombined with auto\u00admated provers have recently been shown to be effective for obtain\u00ading complex proofs \nin interactive provers [4, 85]. Although Jahob supports the use of interactive provers, its proof commands \npro\u00advide an alternative way of decomposing proof obligations without ever leaving the world of the original \nJava program. The fact that these proof constructs naturally translate into guarded commands suggests \nthat they are intuitive for the veri.cation of imperative programs. For example, the havoc ... suchThat \nstatement works both as a proof construct of systems such as Isabelle, and as a spec\u00adi.cation statement \nin wide-spectrum languages [59]. Interactive theorem proving systems. The notation for formu\u00adlas in Jahob \nis based on Isabelle/HOL [63]. Provers such as Is\u00adabelle/HOL support inductively de.ned data types and \nhave been used to verify the correctness of purely functional data structures such as a binary search \ntree with a map interface [39], an AVL tree with a set interface [64], and garbage collection algorithms \n[56]. In the Verisoft project researchers have developed Isabelle proofs of correctness for doubly-linked \nlist implementations [2]. It is nat\u00adural to consider combinations of automated techniques to increase \nthe granularity of interactive proof steps in interactive provers. This kind of integration is used in \nPVS [65], Boyer-Moore provers [16], and higher-order logic systems [35, 54]. There are recent and on\u00adgoing \nefforts to integrate Isabelle with monadic second-order logic over strings [9] and with .rst-order provers \n[57]. We believe that the Jahob approach is useful for proof obligations that arise in data structure \nveri.cation (and potentially for other kinds of proof obli\u00adgations as well), whether these proof obligations \narise within the context of a program veri.cation system or entirely within an inter\u00adactive theorem prover. \nFinitization and automated testing. Jahob and other systems based on theorem proving verify that data \nstructures are correct for all executions. In contrast, testing and software model checking approaches \nbased on .nitization [13,15,20,38,70,77,78] check the correctness of only .nitely many executions (and \nnot the correct\u00adness of the remaining in.nitely many executions). Systems such as Bogor [70] and JACK \n[13] integrate several techniques for check\u00ading .nite models of software systems. We consider such approaches \nto be complementary to ours. With the current state of veri.ca\u00adtion technology, a cost-effective approach \nto develop correct data structures might be to .rst develop the implementation and perform manual testing, \nthen develop speci.cations and check them using .nite state exploration techniques, and .nally use a \nsystem such as Jahob to prove the implementations correct. 9. Conclusion This paper demonstrates the \nuse of integrated reasoning to obtain the .rst veri.cation of full functional correctness for a substantial \ncollection of linked data structures. We have already veri.ed many of the data structures that programmers \nuse in practice. In the near future it is not unreasonable to expect to see data structure libraries \nshipped only after full functional speci.cation and veri.cation. Full functional veri.cation has long \nbeen viewed as an impracti\u00adcal or even unrealizable goal. The results in this paper demonstrate, for \nthe .rst time, that this goal is within practical reach for linked data structure implementations. These \nresults are especially com\u00adpelling given the widespread reuse of data structure libraries and the central \nrole that linked data structures play in computer sci\u00adence. Acknowledgements. We thank Thomas Wies for \nhis contribu\u00adtions to Jahob, which include the implementation of .eld con\u00adstraint analysis, the MONA \ninterface [87], the syntactic prover, and contributions to the SMT-LIB interface. We thank Charles Bouil\u00adlaguet \nfor developing the interface to .rst-order provers [14]. We also thank the anonymous reviewers and our \nshepherd, Rajeev Alur, for their useful feedback on the paper. References [1] The Jahob project web page. \nhttp://javaverification.org. last accessed: March 2008. [2] Verisoft project. http://www.verisoft.de, \nLast accessed March 2008. [3] W. Ahrendt, T. Baar, B. Beckert, R. Bubel, M. Giese, R. H\u00a8ahnle, W. Menzel, \nW. Mostowski, A. Roth, S. Schlager, and P. H. Schmitt. The KeY tool. Software and System Modeling, 4:32 \n54, 2005. [4] K. Arkoudas, K. Zee, V. Kuncak, and M. Rinard. Verifying a .le system implementation. In \nICFEM, volume 3308 of LNCS, 2004. [5] D. Aspinall. Proof general: A generic tool for proof development. \nIn TACAS, 2000. [6] T. Ball, R. Majumdar, T. Millstein, and S. K. Rajamani. Automatic predicate abstraction \nof C programs. In Proc. ACM PLDI, 2001. [7] M. Balser, W. Reif, G. Schellhorn, K. Stenzel, and A. Thums. \nFormal system development with KIV. In FASE, number 1783 in LNCS, 2000. [8] M. Barnett, R. DeLine, M. \nF\u00a8ahndrich, K. R. M. Leino, and W. Schulte. Veri.cation of object-oriented programs with invariants. \nJournal of Object Technology, 3(6):27 56, 2004. [9] D. Basin and S. Friedrich. Combining WS1S and HOL. \nIn Frontiers of Combining Systems 2, 2000. [10] J. Berdine, C. Calcagno, and P. W. O Hearn. Smallfoot: \nModular automatic assertion checking with separation logic. In FMCO, 2005. [11] Y. Bertot and P. Cast\u00b4 \neran. Interactive Theorem Proving and Program Development Coq Art: The Calculus of Inductive Constructions. \nSpringer, 2004. [12] D. Beyer, T. A. Henzinger, and G. Th\u00b4eoduloz. Lazy shape analysis. In CAV, 2006. \n[13] A. Bouali, S. Gnesi, and S. Larosa. The integration project for the JACK environment. Bulletin of \nthe EATCS, (54):207 223, 1994. [14] C. Bouillaguet, V. Kuncak, T. Wies, K. Zee, and M. Rinard. Using \n.rst-order theorem provers in a data structure veri.cation system. In VMCAI 07, November 2007. [15] C. \nBoyapati, S. Khurshid, and D. Marinov. Korat: Automated testing based on Java predicates. In ISSTA, 2002. \n[16] R. S. Boyer and J. S. Moore. Integrating decision procedures into heuristic theorem provers: A case \nstudy of linear arithmetic. In Machine Intelligence, volume 11, pages 83 124. OUP, 1988. [17] P. Chalin, \nC. Hurlin, and J. Kiniry. Integrating static checking and interactive veri.cation: Supporting multiple \ntheories and provers in veri.cation. In VSTTE, 2005. [18] S. Chong and R. Rugina. Static analysis of \naccessed regions in recursive data structures. In Proc. 10th SAS, volume 2694 of LNCS. Springer, 2003. \n[19] L. de Moura and N. Bj\u00f8rner. Ef.cient E-matching for SMT solvers. In CADE, 2007. [20] G. Dennis, \nF. Chang, and D. Jackson. Modular veri.cation of code with SAT. In ISSTA, 2006. [21] D. L. Detlefs, K. \nR. M. Leino, G. Nelson, and J. B. Saxe. Extended static checking. Technical Report 159, COMPAQ Systems \nResearch Center, 1998. [22] J. Dun.eld. A Uni.ed System of Type Re.nements. PhD thesis, Carnegie Mellon \nUniversity, 2007. CMU-CS-07-129. [23] J.-C. Filliatre. Veri.cation of non-functional programs using interpretations \nin type theory. Journal of Functional Programming, 13(4):709 745, 2003. [24] C. Flanagan, K. R. M. Leino, \nM. Lilibridge, G. Nelson, J. B. Saxe, and R. Stata. Extended Static Checking for Java. In ACM Conf. Programming \nLanguage Design and Implementation (PLDI), 2002. [25] C. Flanagan and J. B. Saxe. Avoiding exponential \nexplosion: Generating compact veri.cation conditions. In Proc. 28th ACM POPL, 2001. [26] Y. Ge, C. Barrett, \nand C. Tinelli. Solving quanti.ed veri.cation conditions using satis.ability modulo theories. In CADE, \n2007. [27] M. J. C. Gordon and T. F. Melham. Introduction to HOL, a theorem proving environment for higher-order \nlogic. Cambridge University Press, Cambridge, England, 1993. [28] B. Guo, N. Vachharajani, and D. I. \nAugust. Shape analysis with inductive recursion synthesis. In PLDI, 2007. [29] D. Haneberg, G. Schellhorn, \nH. Grandy, and W. Reif. Veri.cation of Mondex electronic purses with KIV: from transactions to a security \nprotocol. Formal Asp. Comput., 20(1):41 59, 2008. [30] J. Henriksen, J. Jensen, M. J\u00f8rgensen, N. Klarlund, \nB. Paige, T. Rauhe, and A. Sandholm. Mona: Monadic second-order logic in practice. In TACAS, 1995. [31] \nT. A. Henzinger, R. Jhala, R. Majumdar, and K. L. McMillan. Abstractions from proofs. In 31st POPL, 2004. \n[32] M. Hirzel, A. Diwan, and M. Hind. Pointer analysis in the presence of dynamic class loading. In \nECOOP, 2004. [33] M. Huisman. Java program veri.cation in higher order logic with PVS and Isabelle. PhD \nthesis, University of Nijmegen, 2001. [34] M. Huisman, B. Jacobs, and J. van den Berg. A case study in \nclass library veri.cation: Java s vector class. STTT, 3(3):332 352, 2001. [35] J. Hurd. An LCF-style \ninterface between HOL and .rst-order logic. In CADE-18, 2002. [36] N. Immerman, A. M. Rabinovich, T. \nW. Reps, S. Sagiv, and G. Yorsh. The boundary between decidability and undecidability for transitive\u00adclosure \nlogics. In Computer Science Logic (CSL), pages 160 174, 2004. [37] N. Immerman, A. M. Rabinovich, T. \nW. Reps, S. Sagiv, and G. Yorsh. Veri.cation via structure simulation. In CAV, pages 281 294, 2004. [38] \nS. Khurshid and D. Marinov. TestEra: Speci.cation-based testing of Java programs using SAT. Autom. Softw. \nEng., 11(4):403 434, 2004. [39] V. Kuncak. Binary search trees. The Archive of Formal Proofs, http://afp.sourceforge.net/, \nApril 2004. [40] V. Kuncak. Modular Data Structure Veri.cation. PhD thesis, EECS Department, Massachusetts \nInstitute of Technology, February 2007. [41] V. Kuncak, P. Lam, and M. Rinard. Role analysis. In Annual \nACM Symp. on Principles of Programming Languages (POPL), 2002. [42] V. Kuncak, P. Lam, K. Zee, and M. \nRinard. Modular pluggable analyses for data structure consistency. IEEE Transactions on Software Engineering, \n32(12), December 2006. [43] V. Kuncak, H. H. Nguyen, and M. Rinard. An algorithm for deciding BAPA: Boolean \nAlgebra with Presburger Arithmetic. In CADE-20, 2005. [44] V. Kuncak, H. H. Nguyen, and M. Rinard. Deciding \nBoolean Algebra with Presburger Arithmetic. J. of Automated Reasoning, 2006. http://dx.doi.org/10.1007/s10817-006-9042-1. \n[45] V. Kuncak and M. Rinard. Existential heap abstraction entailment is undecidable. In SAS, 2003. [46] \nV. Kuncak and M. Rinard. Towards ef.cient satis.ability checking for Boolean Algebra with Presburger \nArithmetic. In CADE-21, 2007. [47] S. Lahiri and S. Qadeer. Back to the future: revisiting precise program \nveri.cation using smt solvers. In POPL, 2008. [48] S. K. Lahiri and S. Qadeer. Verifying properties of \nwell-founded linked lists. In POPL, 2006. [49] P. Lam. The Hob System for Verifying Software Design Properties. \nPhD thesis, Massachusetts Institute of Technology, February 2007. [50] O. Lee, H. Yang, and K. Yi. Automatic \nveri.cation of pointer programs using grammar-based shape analysis. In ESOP, 2005. [51] T. Lev-Ami, N. \nImmerman, T. Reps, M. Sagiv, S. Srivastava, and G. Yorsh. Simulating reachability using .rst-order logic \nwith applications to veri.cation of linked data structures. In CADE-20, 2005. [52] T. Lev-Ami, T. Reps, \nM. Sagiv, and R. Wilhelm. Putting static analysis to work for veri.cation: A case study. In Int. Symp. \nSoftware Testing and Analysis, 2000. [53] C. March\u00b4e, C. Paulin-Mohring, and X. Urbain. The Krakatoa \ntool for certi.cation of JAVA/JAVACARD programs annotated in JML. Journal of Logic and Algebraic Programming, \n2003. [54] S. McLaughlin, C. Barrett, and Y. Ge. Cooperating theorem provers: A case study combining \nHOL-Light and CVC Lite. In PDPAR, volume 144(2) of ENTCS, pages 43 51, Jan. 2006. [55] S. McPeak and \nG. C. Necula. Data structure speci.cations via local equality axioms. In CAV, pages 476 490, 2005. [56] \nF. Mehta and T. Nipkow. Proving pointer programs in higher-order logic. In CADE-19, 2003. [57] J. Meng \nand L. C. Paulson. Translating higher-order problems to .rst-order clauses. In ESCoR: Empir. Successful \nComp. Reasoning, pages 70 80, 2006. [58] A. M\u00f8ller and M. I. Schwartzbach. The Pointer Assertion Logic \nEngine. In Programming Language Design and Implementation, 2001. [59] C. Morgan. Programming from Speci.cations \n(2nd ed.). Prentice-Hall, Inc., 1994. [60] G. Nelson. Techniques for program veri.cation. Technical report, \nXEROX Palo Alto Research Center, 1981. [61] G. Nelson. Verifying reachability invariants of linked structures. \nIn POPL, 1983. [62] H. H. Nguyen, C. David, S. Qin, and W.-N. Chin. Automated veri.cation of shape, size \nand bag properties via separation logic. In VMCAI, 2007. [63] T. Nipkow, L. C. Paulson, and M. Wenzel. \nIsabelle/HOL: A Proof Assistant for Higher-Order Logic, volume 2283 of LNCS. Springer-Verlag, 2002. [64] \nT. Nipkow and C. Pusch. AVL trees. The Archive of Formal Proofs, http://afp.sourceforge.net/, March 2004. \n[65] S. Owre, J. M. Rushby, and N. Shankar. PVS: A prototype veri.cation system. In D. Kapur, editor, \n11th CADE, volume 607 of LNAI, pages 748 752, jun 1992. [66] A. Podelski and T. Wies. Boolean heaps. \nIn Proc. Int. Static Analysis Symposium, 2005. [67] S. Ranise and C. Tinelli. The SMT-LIB Standard: Version \n1.2. Technical report, Department of Computer Science, The University of Iowa, 2006. Available at www.SMT-LIB.org. \n[68] J. Reineke. Shape analysis of sets. Master s thesis, Universit\u00a8at des Saarlandes, Germany, June \n2005. [69] M. Rinard and P. Diniz. Commutativity analysis: A new analysis technique for parallelizing \ncompilers. TOPLAS, 19(6), Nov. 1997. [70] Robby, E. Rodr\u00b4iguez, M. B. Dwyer, and J. Hatcliff. Checking \nJML speci.cations using an extensible software model checking framework. STTT, 8(3), 2006. [71] A. Roth. \nDeduktiver Softwareentwurf am Beispiel des Java Collections Frameworks. Diplomarbeit, Fakult\u00a8ur Informatik, \nat f\u00a8 Universit\u00a8 at Karlsruhe, June 2002. [72] R. Rugina and M. C. Rinard. Pointer analysis for structured \nparallel programs. ACM Trans. Program. Lang. Syst., 25(1), 2003. [73] R. Rugina and M. C. Rinard. Symbolic \nbounds analysis of pointers, array indices, and accessed memory regions. ACM Trans. Program. Lang. Syst., \n27(2), 2005. [74] M. Sagiv, T. Reps, and R. Wilhelm. Parametric shape analysis via 3-valued logic. ACM \nTOPLAS, 24(3):217 298, 2002. [75] A. Salcianu and M. Rinard. Pointer and escape analysis for multithreaded \nprograms. In PPoPP, 2001. [76] S. Schulz. E A Brainiac Theorem Prover. Journal of AI Communications, \n15(2/3):111 126, 2002. [77] K. Sen, D. Marinov, and G. Agha. Cute: a concolic unit testing engine for \nc. In ESEC/SIGSOFT FSE, pages 263 272, 2005. [78] A. Sobeih, V. Mahesh, D. Marinov, and J. Hou. J-Sim: \nAn integrated environment for simulation and model checking of network protocols. In IPDPS, 2007. [79] \nS. Stepney, D. Cooper, and J. Woodcock. An electronic purse: Speci.cation, re.nement, and proof. Technical \nmonograph PRG\u00ad126, Oxford University Computing Laboratory, 2000. [80] G. Sutcliffe and C. B. Suttner. \nThe TPTP problem library: CNF release v1.2.1. Journal of Automated Reasoning, 21(2):177 203, 1998. [81] \nI. Tonin. Verifying the Mondex case study: The KeY approach. Technical Report 2007-4, Uni. Karlsruhe, \nJuly 2007. [82] J. van der Berg and B. Jacobs. The LOOP compiler for Java and UML. Technical Report CSI-R0019, \nComputing Science Institute, Univ. of Nijmegen, Dec. 2000. [83] F. Vivien and M. Rinard. Incrementalized \npointer and escape analysis. In Proc. ACM PLDI, June 2001. [84] C. Weidenbach. Combining superposition, \nsorts and splitting. In A. Robinson and A. Voronkov, editors, Handbook of Automated Reasoning, volume \nII, chapter 27, pages 1965 2013. Elsevier Science, 2001. [85] M. Wenzel. Isabelle/Isar a versatile environment \nfor human\u00adreadable formal proof documents. PhD thesis, Technische Universi\u00adtaet Muenchen, 2002. [86] \nJ. Whaley and M. Rinard. Compositional pointer and escape analysis for Java programs. In OOPSLA, Denver, \nNov. 1999. [87] T. Wies, V. Kuncak, P. Lam, A. Podelski, and M. Rinard. Field constraint analysis. In \nVMCAI, 2006. [88] T. Wies, V. Kuncak, K. Zee, A. Podelski, and M. Rinard. Verifying complex properties \nusing symbolic shape analysis. In Heap Abstraction and Veri.cation, 2007. [89] D. Zhu and H. Xi. Safe \nprogramming with pointers through stateful views. In PADL, 2005.     \n\t\t\t", "proc_id": "1375581", "abstract": "<p>We present the first verification of <i>full functional correctness</i> for a range of linked data structure implementations, including mutable lists, trees, graphs, and hash tables. Specifically, we present the use of the Jahob verification system to verify formal specifications, written in classical higher-order logic, that completely capture the desired behavior of the Java data structure implementations (with the exception of properties involving execution time and/or memory consumption). Given that the desired correctness properties include intractable constructs such as quantifiers, transitive closure, and lambda abstraction, it is a challenge to successfully prove the generated verification conditions.</p> <p>Our Jahob verification system uses <i>integrated reasoning</i> to split each verification condition into a conjunction of simpler subformulas, then apply a diverse collection of specialized decision procedures, first-order theorem provers, and, in the worst case, interactive theorem provers to prove each subformula. Techniques such as replacing complex subformulas with stronger but simpler alternatives, exploiting structure inherently present in the verification conditions, and, when necessary, inserting verified lemmas and proof hints into the imperative source code make it possible to seamlessly integrate all of the specialized decision procedures and theorem provers into a single powerful integrated reasoning system. By appropriately applying multiple proof techniques to discharge different subformulas, this reasoning system can effectively prove the complex and challenging verification conditions that arise in this context.</p>", "authors": [{"name": "Karen Zee", "author_profile_id": "81100238724", "affiliation": "MIT, Cambridge, MA, USA", "person_id": "P1022818", "email_address": "", "orcid_id": ""}, {"name": "Viktor Kuncak", "author_profile_id": "81100277693", "affiliation": "EPFL, Lausanne, Switzerland", "person_id": "P1022819", "email_address": "", "orcid_id": ""}, {"name": "Martin Rinard", "author_profile_id": "81100087275", "affiliation": "MIT, Cambridge, MA, USA", "person_id": "P1022820", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1375581.1375624", "year": "2008", "article_id": "1375624", "conference": "PLDI", "title": "Full functional verification of linked data structures", "url": "http://dl.acm.org/citation.cfm?id=1375624"}