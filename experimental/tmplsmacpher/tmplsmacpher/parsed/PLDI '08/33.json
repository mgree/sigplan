{"article_publication_date": "06-07-2008", "fulltext": "\n Model Checking Transactional Memories * Rachid Guerraoui Thomas A. Henzinger Barbara Jobstmann Vasu \nSingh \u00b4 Ecole PolytechniqueF\u00b4eralede Lausanne (EPFL), Switzerland ed\u00b4 {rachid.guerraoui,tah,barbara.jobstmann,vasu.singh}@ep..ch \nAbstract Model checking software transactional memories (STMs) is dif.\u00adcult because of the unbounded \nnumber, length, and delay of con\u00adcurrent transactions and the unbounded size of the memory. We show that, \nunder certain conditions, the veri.cation problem can be reduced to a .nite-state problem, and we illustrate \nthe use of the method by proving the correctness of several STMs, including two-phase locking, DSTM, \nTL2, and optimistic concurrency con\u00adtrol. The safety properties we consider include strict serializability \nand opacity; the liveness properties include obstruction freedom, livelock freedom, and wait freedom. \nOur main contribution lies in the structure of the proofs, which are largely automated and not restricted \nto the STMs mentioned above. In a .rst step we show that every STM that enjoys certain structural properties \neither violatesa safetyorliveness requirement on some program with two threads and two shared variables, \nor satis.es the requirement on all programs. In the second step we use a model checker to prove the requirement \nfor the STM applied to a most general program with two threads and two variables. In the safety case, \nthe model checker constructs a simulation relation between two carefully constructed .nite-state transition \nsystems, one representingthegivenSTM appliedtoamost general program, and the other representing a most \nliberal safe STM applied to the same program. In the liveness case, the model checker analyzes fairness \nconditions on the given STM transition system. Categories and Subject Descriptors D.1.3[Programming tech\u00adniques]: \nConcurrent Programming; D.2.4[Software engineering]: Software/ProgramVeri.cation General Terms Languages,Veri.cation \nKeywords Transactional memories, Model checking 1. Introduction Withtheadventof multi-core processors, \nthereisanewurgencyfor concurrent programming models thatgive the programmer the illu\u00adsionof sequentialityandthe \ncompiler maximal.exibility.Amodel that has enjoyed particular recent success is software transactional \nmemory (STM), which allows the programmer to think in coarse\u00adgrained code blocks that appear to be executed \natomically and, at * This researchwas supportedby the Swiss National ScienceFoundation. Permission to \nmake digital or hard copies of all or part of this work for personal or classroom use is granted without \nfee provided that copies are not made or distributed for pro.t or commercial advantage and that copies \nbear this notice and the full citation on the .rst page.To copyotherwise, to republish, to post on servers \nor to redistribute to lists, requires prior speci.c permission and/or a fee. PLDI 08 June 7 13, 2008,Tucson, \nArizona, USA. Copyright c &#38;#169; 2008ACM 978-1-59593-860-2/08/06... $5.00 the same time, minimally \nconstrains the compiler. Inspired by how databases manage concurrency, transactional memory was .rst \nin\u00adtroduced by Herlihyand Moss [HM93] in multi-processor design. Later Shavit andTouitou [ST95] introduced \nSTM,asoftware-based variant of the concept, which enables a new way of looking at con\u00adcurrent programming.AnextensiveoverviewofSTM \ncanbe found in [LR07]. In this paper, we consider the following STM algo\u00adrithms: two-phase locking, DSTM \n[HLMS03], TL2 [DSS06], and optimistic concurrencycontrol [KR81]. Precisely because STM algorithms encapsulate \nthe dif.culty of handling concurrency, the potential of subtle errors is enormous. This makes STM a ripe \nand important proving ground for for\u00admal veri.cation. While there have been initial steps in this direc\u00adtion \n[COP+07], the challenge remains daunting for several reasons. First, there is no generally agreed upon \nformal notion of cor\u00adrectness for STM. Scott [Sco06] was the .rst to provide a formal semantics for STM. \nHowever, his weakest correctness criterion re\u00adquires the order of commits to be preserved. Thus, the \npopular STM algorithm TL2 [DSS06], which does not preservethe order of com\u00admits,falls outside the semantic \nclassi.cationby Scott. Guerraoui and Kapalka [GK08] discussed various alternatives to precisely capture \nthe safety aspect of STM and highlighted the subtle dif\u00adferences with database transactions. Second, \nwhile model checking is the veri.cation technique that is best equipped to .nd concurrency bugs, model \nchecking is severely handicapped by several sources of unbounded state in STM: memory size, thread count, \nand transaction length cannot be bounded, and neither can the delay until a transaction commits, nor \nthe number of times that a transaction aborts. As with relaxed memory models, special careis neededin \nformulatingaveri.cation problem that is both relevant and solvable, as some problems about sequentializing \nconcurrent systems are undecidable [AMP00]. Third, the speci.cation of an STM universally quanti.es over \nall possible application programs, requiring the desired safety and liveness conditions for all programs \nthat are executed on the STM. In this sense, STM veri.cation resembles the problem of check\u00ading that \na processor implements an instruction set architecture, where the executed programs are also universally \nquanti.ed. In both cases,thekeyisto de.ne(and check)a suitable implemen\u00adtation relation [BD94]. While \nin processor veri.cation, the imple\u00admentation relation needs to handle pipelines and out-of-order exe\u00adcution, \nin STM, we need to handle aborted transactions. We present in this paper a new technique for verifying \nSTM safety and liveness properties. Our technique addresses the three issues above as follows. First, \nthe safety requirements we consider are strict serializ\u00adability [Pap79] and opacity [GK08]. (We consider \na single-version read/write restriction of the general notion of opacity.) Strict se\u00adrializability preserves \nthe order of con.icting operations between transactions, and the order of non-overlapping transactions. \nOpac\u00adity ensures, in addition, that aborting transactions do not see an inconsistent state of the memory, \nwhich can be disastrous in STMs (dueto in.nite loops,orexceptions).Westudy opacity, becauseit provides \nthe programmer with the full sequentiality illusion and is satis.ed by most STM protocols that claim \nthat illusion [LR07]. Strict serializability is considered here for pedagogical reasons, as it is intuitive \nand captures the main technical dif.culties behind verifying opacity. The liveness requirements we consider \nare the standard notions of obstruction freedom [HLM03], livelock free\u00addom [AKH03], and wait freedom \n[Her91]. Second,weexploitthe structural symmetriesthatare inherentin STM algorithmsto reducetheveri.cationof \nunboundedSTM state spaces to a problem that involves only a small number of threads and sharedvariables. \nSpeci.cally,we showthatevery STM that en\u00adjoys certain structural properties either violates anyof the \nconsid\u00adered safety and liveness requirements on some program with two threads and two shared variables, \nor satis.es the requirement on all programs. The structural properties, which expect all threads to be \ntreated equally, are ful.lled by most transactional algorithms, including for instance, two-phase locking, \nDSTM, TL2, and op\u00adtimistic concurrency control. Similar techniques for reducing un\u00adbounded instances \nof model-checking tasks to small, characteristic instanceshavebeenusedforverifying protocolswithan unbounded \nnumber of identical processes [BCG89] and cache-coherence pro\u00adtocols [HQR99]. Third, and perhaps most \nimportantly, we de.ne two .nite-state transition systems that generate exactly the strictly serializable \n(resp. opaque) executions of programs with two threads and two shared variables. These transition systems \ncan be viewed as most liberal reference STM algorithms guaranteeing strict serializability (resp. opacity).To \nour knowledge, the transition systems presented in this paper provide the .rst .nite-state representation \nof the lan\u00adguage of strictly serializable (resp. opaque) executions for trans\u00adactions that may abort. \nThe .nite size of the transition systems is achievedbya careful choiceof state, which encompasses forevery \nthreadasetof readvariables(at mosttwo),asetof writtenvariables (at mosttwo),asetofvariables not allowedtobe \nread(at mosttwo), a set of variables not allowed to be written (at most two), and a set of threads withoverlapping, \npreceding transactions(at most1).We show that an STM algorithm is strictly serializable (resp. opaque) \nifffor a speci.c, most general program with two threads and two variables, all executions are permitted \nby the reference STM algo\u00adrithm. Then, instead of checking language containment between a given STM algorithm \nand the reference algorithm, we check for the existence of a simulation relation between both transition \nsys\u00adtems [Mil71].Theexistenceofa simulation relationisa commonly used, ef.cient suf.cient condition for \nlanguage containment. Putting all steps together, we reduce the problem of verifying the safety of an \nSTM algorithm, which is unbounded in manydi\u00admensions (memory size, thread count, transaction delay, etc.), \nto a simulation check between two .nite-state systems.For two-phase locking, DSTM, TL2, and optimistic \nconcurrencycontrol, we ob\u00adtain transition systems with up to 12,000 states, and the reference transition \nsystems have about 12,500 states. We implemented a simulation checker that automatically veri.es strict \nserializability for optimistic concurrencycontrol and opacity for two-phase lock\u00ading, DSTM, and TL2 in \nless than 30 minutes. It should be noted that the methodology is applicable to any other STM algorithms \nthat satisfy the structural properties. Our simulation checker .nds that correctnessis not self-evidentinmany \nSTM algorithms.For example, we found an ambiguity in ordering of two particular op\u00aderations in the published \nTL2 algorithm [DSS06]. One of the order\u00adings makes TL2 unsafe. In this case, the simulation check provides \nas counterexampleanexecutionthatisnot strictly serializable(and thus not opaque). We therefore expect \nour veri.cation tool to be useful to STM designers when theydevelop or modify STM algo\u00adrithms. On the \nliveness side, we prove again a structuralreduction the\u00adorem to check the desired liveness requirement \non the .nite-state transition system that results from a given STM algorithm applied toa most general \nprogram with two threads and onevariable.We built a model checking tool to verify the different liveness \nproper\u00adties. In the case of obstruction freedom, this amounts to checking a Streett condition. The check \ngoes through for DSTM.For two\u00adphase locking, TL2, and optimistic concurrencycontrol, the model checker \nautomatically generates counterexamples to obstruction freedom, as it does for DSTM and livelock freedom. \n2. Safety in transactional memories We introduce a few notions about transactions, and then formalize \nthe correctness of transactional memories. Let V bea set {1,...,k} of k variables, and let C = {commit}. \n({read, write}\u00d7 V ) be the set of commands on the variables V . Also, let C = C .{abort}. Let T = {1,...,n} \n bea setof n threads. Let S = C \u00d7 T be the set of statements. Also, let S = C \u00d7 T . A word w . S * is \na .nite sequence of statements. Given a word w . S * , we de.ne the thread projection w|t of w on thread \nt . T as the subsequence of w consisting of all statements s in w such that s . C \u00d7{t}.Givena threadprojection \nw|t = s0 ...sm ofaword w on thread t,a statement si is .nishing in w|t ifitisa commitoran abort.A statement \nsi is initiating in w|t if it is the .rst statement in w|t, or the previous statement si-1 is a .nishing \nstatement. Given a thread projection w|t of a word w on thread t,a consecutive subsequence x = s0 ...sm \nof w|t is a transaction of thread t in w if (i) s0 is initiating in w|t, and (ii) sm is either .nishing \nin w|t,orsm is the last statement in w|t,and (iii) no other statement in x is .nishing in w|t. The transaction \nx is committing in w if sm is a commit. The transaction x is aborting in w if sm is an abort. Otherwise, \nthe transaction x is un.nished in w. Givenaword w and twotransactions x and y in w (possibly of different \nthreads), we say that x precedes y in w, written as x<w y, if the last statement of x occurs before the \n.rst statement of y in w.A word w is sequential if for every pair x, y of transactions in w, either S \n* . S * x<w y or y<w x.We de.ne a function com : such that for all words w . S *, the word com(w) is \nthe subsequence of w that consists of every statement in w that is part of a committing transaction. \nAtransactionx of a thread t writes to a variable v if x contains a statement ((write,v),t).A statement \ns = ((read,v),t) in x is a global read of a variable v if there is no statement ((write,v),t) before \ns in the transaction x.Atransaction x of a thread t globally reads a variable v if there exists a global \nread of variable v in ' transaction x. A word w is transaction equivalent to a word wif for every thread \nt . T , we have w|t = w'|t. Note that two transaction equivalent words have the same order of commands \nfor all threads. 2.1 Safety criteria Con.ict serializability [EGLT76] is a commonly used correctness \ncriterion for concurrent systems and, in particular, for transactional systems. Con.ict serializability \nallows us to omit the values of read and write commands, since the consistencyof the values fol\u00adlows \nfrom preserving the order of con.icts. In the context of trans\u00adactional memories, a stronger property, \ncalled strict serializabil\u00adity, is considered. Strict serializability preserves the order of non\u00adoverlapping \ntransactions too.We note that strict serializability does not state any restrictions on the operations \nof the aborting trans\u00adactions. In the scope of STMs, an even stronger notion of correct\u00adness, referred \nto as opacity, has been suggested [HLMS03, GK08] to avoid unexpected side effects, like in.nite loops, \nor array bound violations. Opacity requires thatawordbe strictly serializable, and that even aborting \ntransactions do not read inconsistent values. Now, we formalize these correctness criteria. We start \nwith the notionofa con.ict.Transactional memories use direct update semantics (every transaction modi.es \nthe shared variables in place and restores them upon abort), or deferred update semantics(every transaction \nmodi.es a local copy, and changes the shared copy upona commit).We choose to de.ne con.icts under the \ndeferred update semantics.Astatement s1 of transaction x and a statement s2 of transaction y (where x \nis different from y)con.ict inaword w if (i) s1 isa global readof somevariable v, and s2 isa commit, \nand y writes to v, or (ii) s1 and s2 are both commits, and x and y write to the samevariable v.Aword \nw = s0 ...sm is con.ict equivalent to a word w ' if (i) w is transaction equivalent to w ', and (ii)for \nevery pair si,sj of statements in w, if si and sj con.ict and i<j, then si occurs before sj in w '. Note \nthat transaction equivalence ensures that con.ict equivalence is a symmetric relation, since w ' is a \npermutation of w. Aword w = s0 ...sm is strictly equivalent to a word w ' if (i) w is con.ict equivalent \nto w ', and (ii) for every pair x, y of trans\u00adactions in w, where x is a committing or an aborting transaction, \nif x<w y, then it is not the case that y<wI x.A word w . S * is strictly serializable if thereexistsasequentialword \nw ' such that w ' is strictly equivalent to com(w). Furthermore, a word w is opaque if there exists a \nsequential word w ' such that w ' is strictly equiva\u00adlent to w.We note that given a word w, if w is opaque, \nthen w is strictly serializable. An in.nite word w . S . is strictly serializ\u00adable (resp. opaque)if every \n.nite pre.x ofw is strictly serializable (resp. opaque). Example. Consider a word w = ((read, v1), t1), \n((write, v1), t2), ((write, v2), t2),(commit, t2), ((read, v2), t1),(abort, t1). w has two transactions: \n(i) an aborting transaction of t1, and (ii) a com\u00admitting transaction of t2. The following pairs of statements \ncon.ict: (((read, v1), t1),(commit, t2)) and (((read, v2), t1),(commit, t2)). Theword w is strictly serializable \nbecause com(w)= ((write, v1), t2), ((write, v2), t2),(commit, t2). On the other hand, w is not opaque \nsince t1 reads the old value of v1 (before t2 commits) and the new value of v2 (committed by t2).  2.2 \nTransactional memories We consider thread programs as our basic sequential unit of com-putations.Weexpress \nthread programs as in.nite binary trees on commands. This makes the representation independent of speci.c \ncontrol .ow statements, such as exceptions for handling aborts of transactions.Forevery commandofathread,we \nde.netwosucces\u00adsor commands, one if the command is successfully executed, and anotherifthe commandfailsduetoanabortofthe \ntransaction.Note that this de.nition allows us to capture easily different retry mech\u00adanisms of TMs, \ne.g., retry the same transaction until it succeeds or try another transaction after an abort.We usea \nsetof thread pro\u00adgrams to de.nea multithreaded program.Formally,a thread pro\u00adgram . ona set C of commands \nis a function . : B* . C.We write T for the setof thread programs.A (multithreaded) program p on n threads \nand k variablesis an n-tuple p = (.1,...,.n) of thread programs on C.Figure 1(a) shows an example program \non two threads and two variables. Let P n,k be the set of all programs on n threads and k variables. \nLet P be the set of all programs. We de.ne a transactional memory as an abstract function that takes \nas input a program, and produces a set of in.nite words. Formally, a transactional memory (TM) is a function \nM : P . 2S . .Atransactional memory M ensures strict serializability(resp. opacity) for all programs \nwith n threads and k variables if forevery program p . P n,k , every word w . M(p) is strictly serializable \n(resp. opaque). Moreover,atransactional memory M ensures strict  Figure 1. Our framework of transactional \nmemory serializability (resp. opacity)if it ensures strict serializability (resp. opacity) for all programs \nwith an arbitrary number of threads and variables. 3. Transactional memory algorithms We use state transition \nsystems to de.ne TM.ATM algorithm is afamily of TM transition systems, one for n threads and k vari\u00adables, \nfor every n and k.ATM transition system consists of a set of states, an initial state, an extended set \nof commands depending on the underlying TM, a pending function, and a transition rela\u00adtion between the \nstates. The extended commands include the set C of commands, and TM speci.c additional commands.For exam\u00adple, \na given TM may require that a thread locks a variable before writingto thevariable, or thata threadvalidates \nthevariables read in a transaction, before accessing a new variable. Every extended command is assumed \nto execute atomically. The pending function represents the pending command of a thread in a state, and \nensures that if a thread has not .nished the execution of a particular com\u00admand, then no other command \nis executed by the thread. ATM algorithm interacts with a program and a scheduler (see Fig. 1(b)). The \nscheduler chooses a thread, which determines the next command to be executed. The TM transition system \ndecides whether the command can be executed in a single atomic step, or in several atomic steps (using \nadditional extended commands), or has to be aborted. The TM algorithm gives back to the program a response. \nThe response is . if the TM algorithm needs additional steps to complete the command, 0 if the TM algorithm \nneeds to abort the transaction, and 1 if the TM algorithm has completed the command. Given a program, \na scheduler, and a TM transition system, we get a run. Projecting the run to the set of successful statements(thatis, \naborts,and statementsthatget response1)gives a word in S ..We describe the language of a TM transition \nsystem as the set of words on S . that it can produce for anyprogram and anyscheduler. Formally, a scheduler \ns on T is a function s : N . T . We de.ne a TM algorithm A as a family of TM transition systems An,k \n= (Q, qinit , D, p, d) for each n and k, where Q isa setof states, qinit is the initial state, D is the \nset of extended commands with C . D, the function p : Q \u00d7 T . C . {.} represents the pending command \nin a state for a thread , and d . Q \u00d7 C \u00d7 S D \u00d7 Resp \u00d7 Q is the deterministic or non-deterministic transition \nrelation, where SD =(D .{abort}) \u00d7 T and Resp = {., 0, 1}. The transition relation d and the pending \nfunction p obey the following rules: 1. For all threadst . T , we have p(qinit ,t)=.. 2. For all states \nq, q ' . Q such that there exists an incoming transition (q, c, (d, t), r, q ' ) . d to q ', if r =., \nthen p(q ' ,t)= c, otherwise p(q ' ,t)=.. 3. For all states q, q ' . Q such that there exists an incoming \ntransition (q, c, (d, t), r, q ' ) . d to q ', then p(q ' ,u)= p(q, u) for all threads u  = t. 4. For \nall statesq and all threads t, if p(q, t)= c where c =., then for all outgoing transitions (q, c1, (d, \nt), r, q ' ) . d from q, we have c1 = c. 5. For all states q and all threads t, if p(q, t)=., then there \nexists an outgoing transition (q, c, (d, t), r, q ' . d from q for every command c . C. 6. For allq \n. Q, for all transitions (q, c, (d, t), r, q ' ) . d, we have d = abort if and only if r =0.  Note that \nthe rules above restrict the transition relation and the pending function p such that p is unique. A \ncommand c is enabled in a state q for thread t if p(q, t) . {.,c} (i.e., either no command is pending, \nor c itself is pending). In a deterministic transition relation d, a command c is abort enabled in a \nstate q for thread t if c is enabled in q for thread t and there is no transition (q, c, (d, t), r, q \n' ) . d such that d . D. A transition relation d is deterministic if for all q . Q and (c, t) . S, if \n(q, c, (d1,t),r1,q1) . d and (q, c, (d2,t),r2,q2) . d, then d1 = d2, r1 = r2, and q1 = q2. Unless otherwise \nstated, TM transition systems have deterministic transition relations.We shall use non\u00addeterministicTM \ntransition systems laterto describe referenceTM algorithms. Let p = (.1,...,.n) be a program in P n,k \n. Let s be a sched\u00aduler on n threads.A run . = (q0,l0, (d0,t0),r0)(q1,l1, (d1,t1), r1) ... of a TM transition \nsystem An,k with scheduler s on pro\u00adgram p is an in.nite sequence of tuples of states, program lo\u00adcations, \nstatements, and responses, where lj = (lj 1,...,ljn). (B* )n for all j = 0 and the following hold: (i) \nq0 = qinit and l0 = (E,..., E), (ii) for all j = 0, there exists a transi\u00adtion (qj ,cj , (dj ,tj ),rj \n,qj+1) . d such that tj = s(j) and cj = .tj (ljtj ) and for all t . T , we have ljt +1 = ljt if either \nt = tj or rj =., and ljt +1 = ljt \u00b7 rj otherwise. Given a sched\u00aduler and a program, there is exactly \none run for a deterministic TM transition system An,k , whereas there is at least one run for a non\u00addeterministicTM \ntransition system.Wesaythatastatement sj . S is successful in the run . = (q0,l0,s0,r0)(q1,l1,s1,r1) \n... if (i) rj .{0, 1}, or (ii) rk =1 with j<k and rj+1 ...rk-1 are all equal to .. We de.ne the language \nL(An,k ) of An,k as the set S . of all in.nite words w . such that w is the sequence of all successful \nstatements in a run of An,k with some scheduler on n threads, on some program on n threads and k variables.For \na TM algorithm A, we require that for n = n ' and k = k ', the language I,kI L(An,k ) . L(An ). A TM \nalgorithm A de.nes a transactional memory M such that for all n and k, for every program p in P n,k and \nevery word w . S ., we have w . M(p) iff there exists a scheduler s on T and a corresponding run . of \nAn,k with s on p such that w is the sequence of all successful statements in .. It follows that a TM \nde.ned by a TM algorithm A ensures strict serializability (resp. opacity) for all programs with n threads \nand k variables iff all words in L(An,k ) are strictly serializable (resp. opaque). In the following \nsections, we describe different transactional memories asTM algorithms.To simplify the description, we \nview a state q of the corresponding TM transition systems as an n-tuple (q 1 ...q n),where each componentq \nt correspondstoathread t and is called the thread state of t. 3.1 The sequential TM Tokeep our .rstexample \nsimple, we describeasequential TM. The sequential TM executes the transactions sequentially (as ideally \nsuitedforauniprocessor).Wede.nethe sequentialTM Mseq using a sequential TM algorithm Aseq . The sequential \nTM transition system An,k for n threads and k variables is given by the tuple seq (Q, qinit , D, p, d). \nThe thread state q t of thread t is in {T, F}. If a thread t has an un.nished transaction in a state \nq, then the thread state q t is T, and F otherwise. The initial state qinit = (F,..., F). The set of \nextended commands is D = C.Atransition (q1, c, (d, t), r, q2) is in d if c is enabled in q1 for thread \nt and one of the following holds: 1. Read (resp. write). (i) c =(read,v) (resp. c =(write,v))and d = \nc and r =1, and (ii) q1 u = F for all u = t, and (iii) q2 t = T and q2 u = q1 u for all u = t. When a \nthread reads (resp. writes) a variable, if the state of all other threads is F, then the state of t is \nset to T. 2. Commit. (i) c = commit and d = c and r =1, and (ii) q1 u = F  t uu for all u = t, and \n(iii) q2 = F and q2 = q1 for all u = t. When a thread commits, if the state of all other threads is F, \nthen the state of t is set to F. Atransition(q1, c, (abort,t), 0,q2) is in d if c is abort enabled in \nq1 for thread t and q2 = q1. 3.2 The two-phase locking TM Our secondexampleofaTM algorithmis basedontwo-phase \nlock\u00ading (2PL) protocol, commonly used in database transactions. Every transaction locks the variables \nit reads or writes before accessing them, and releases all acquired locks during the commit.Ashared lock \nis acquired for reading, and an exclusive lock is acquired for writing.We de.ne the 2PL TM M2PL using \na 2PL TM algorithm A2PL. The 2PL TM transition system An,k for n threads and k 2PL variables is given \nby the tuple (Q, qinit , D, p, d). The thread state q t of thread t is a pair (rs, ws), where rs . V \nis the set of vari\u00adables locked by t in shared mode, and ws . V is the set of vari\u00adables lockedinexclusive \nmode.Forevery thread, the initial thread t state of thread t is qinit = (\u00d8, \u00d8). The set of extended commands \nis D = C . ({rlock, wlock}\u00d7 V ).Atransition (q1, c, (d, t), r, q2) is in d if c is enabled in q1 for \nthread t and one of the following holds: 1. Read. (i) c =(read,v) and d = c and r =1, and (ii) v . ws \nt 1 . rs t 1, and (iii) q2 = q1. When a thread reads a variable that already exists in the read set or \nthe write set of the thread, then the state does not change. 2. Write. (i) c =(write,v) and d = c and \nr =1, and (ii) v . ws1t , and (iii) q2 = q1. When a thread writes to a variable that already exists in \nthe write set of the thread, then the state does not change. 3. Read Lock. (i) c =(read,v) and d =(rlock,v) \nand r =.,  tu t and (ii) v ./rs1 and v ./ws1 for all threads u, and (iii) rs2 = t uu rs1 .{v}, and (iv) \nq2 = q1 for all threads u = t. When a thread t reads v, and v is not in the read set of t, and v is not \nin the write set of anythread, then v is added to the read set of t. 4. Write Lock. (i) c =(write,v) \nand d =(wlock,v) and r =., t uu and (ii) v/. ws1 and v/. rs1 . ws1 for all threads u = t, and (iii) tt \nuu rs2 = rs1 .{v}, and (iv) q2 = q1 for all threads u = t. When a thread writes v, and v is not in the \nwrite set of t, and v is not in the read set or write set of anythread other than t, then v is added \nto the write set of t. 4. Commit. (i) c = commit and d = c and r =1,and (ii)rs t 2 = \u00d8, t uu and ws2 \n= \u00d8, and (iii) for all threads u = t, we have q2 = q1 . When a thread commits, the read set and the write \nset are changed to empty. Atransition(q1, c, (abort,t), 0,q2) is in d if c is abort enabled t tuu in \nq1 for thread t and rs2 = \u00d8 and ws2 = \u00d8, and q2 = q1 for all threads u = t.  3.3 The dynamic software \ntransactional memory Dynamic software transactional memory (DSTM) [HLMS03] is one of the most popular \nSTM algorithms. The algorithm exists in several .avors. In this work, we focus on one of them, called \ninvisible read DSTM, where the transactions require ownership of variables only for writing. The readers \nare not visible to the writers. Upon reading, a transaction validates its read set in order to ensure \nopacity. In our work, we ignore optimizations like early release t .{validated,.nished}, is the write \nset, lst . V is the lock set, and ms  rs t . V .ag for other transactions, and requiring that a transaction \naborts modi.ed set. The initial thread state q t = (.nished, \u00d8, \u00d8, \u00d8, \u00d8) T . The set of extended commands \nis D = init whenever the abort .ag is set for the thread. We de.ne DSTM for all threads t . TM Mdstm \nusing a DSTM TM algorithm Adstm . The DSTM TM C . ({lock}\u00d7 V ) .{validate}.A transition (q1, c, (d, t), \nr, q2) transition system An,k for n threads and k variables is given by is in d if c is enabled in q1 \nfor t and one of the following holds: dstm 1. Local read. (i) c =(read,v) and d = c and r =1, and (ii) \nt (Q, qinit , D, p, d).Athread state q t), where status tt of thread t is de.ned as a 3\u00ad v . ws t 1 and \nq2 = q1. When a thread reads v such that the read is not global, the state does not change. t tuple (status \n.{aborted, validated, . V is the t , rs , os invalid, .nished} is the status of thread t, and rs read \nset of thread t, and os t 2. Global read. (i) c =(read,v) and d = c and r =1, and (ii) . V is the ownership \nset of thread v ./ws t 1 ./ms t 1 rs t 2 = rs t 1t 2 = ls t 1 and v , and (iii) t 1 t 2 .{v} and ls= \nstatus t init = t. For every thread, the initial thread state of thread t is q and ws t 2 = ws t 1 and \nms t 2 = ms t 1 and status , and (iv) (.nished, \u00d8, \u00d8). The set of extended commands is D C . = for all \nthreads u = t, we have q . Whenathread reads v and u 2 u 1 ({own}\u00d7 V ) .{validate}.Atransition (q1, \nc, (d, t), r, q2) is in d if c is enabled in q1 for thread t and oneofthe following holds: thereadis \nglobal,ifthevariableisnotinthe modi.edset,then v is 1. Local read. (i) c =(read,v) and d = c and r =1, \nand (ii) added to the read set. = q 3. Write. (i) c =(write,v) and d = c and r =1, and (ii) v . os t \n1 and status t 1 = aborted, and (iii) q2 = q1. When a thread ws t 2 = ws t 1t 2 = ls t 1 and rs t 2 = \nrs t 1 and ms t 2 = ms t 1 t 1 .{v} and lsstatus reads v such that the read is not global, the state \ndoes not change. t 2 and status , and (iv) q u 1 for all threads u = u 2 2. Global read. (i) c =(read,v) \nand d = c and r =1, and (ii) t. = = q When a thread writes to v, the variable v is added to its write \nset. 4. Lock. (i) c = commit and d =(lock,v) and r =., and (ii) v ./os t 1 t 1 t 2 t 2 .{v} and for all \nthreads and status = .nished, and (iii) rs = rs os t 2 = os t 1 t 2 = status t 1 ,and(iv)q u 2 and status \nu 1 = q t 1 t 1 = .nished and v . ws and (iii) there is no thread u . Tu = t. When a thread reads v globally, \nif the status of the thread is status t 2 = ls t 1t 2 = rs t 1 andsuch that v . ls u 1 , and (iv) ls \n t 2 .{v} and rs status .nished, then v is added to the read set of the thread. ws t 2 = ws t 1 and \nms t 2 = ms t 1t 1 and status , and (v) for 3. Own. (i) c =(write,v) and d =(own,v) and r =., and (ii) \n= all threads u = t, we have q . When a thread t commits, if u 2 u 1 status t 1 = t 2 t 1t 2 t 1 aborted, \nand (iii) rs and os .{v}, and (iv) for all threads u = t, if v . os u 1 = q = rs = os the status is .nished \nand v is in the write set of t and v is not in the t 2 = status t 1 and status , lock set of anythread, \nthen v is added to the lock set of t. then status aborted, and os u 2 = \u00d8, and rs = \u00d8, otherwise u 2 \nu 2 = 5. Validate. (i) c = commit and d = validate and r =., and (ii) = status u 1 and os u 2 = os u \n1 and rs u 2 = rs u 1 . When a status u 2 t 1 t 1 n ms t 1 = \u00d8 and ws t 1 t 1 and for all = .nished and \nrs = ls thread writes to v, if the status of the thread is not aborted, then status t 1t 2 threads u \n= t,we havers = \u00d8,and (iii)status u 1 nls = validated the variable v is added to the owned set of the \nthread, and if some and ls t 2 = ls t 1 and rs t 2 = rs t 1 and ws t 2 = ws t 1 and ms t 2 = ms t 1 ,thread \nowns v, then the status of that thread is set to aborted and and (iv) q u 2 for all threads u = t When \na thread commits, u 1 its read set and own set are set to empty. = q if the status is .nished, and the \nread set does not intersect with the 4. Write. (i) c =(write,v) and d = c and r =1, and (ii) modi.ed \nset, and the write setis equalto the lock set, and the read status t 1 = aborted and v . os t 1 , and \n(iii) q u 2 = q u 1 for all u . T . set does not intersect with the lock set of anyother thread, then \nthe Whenathread writesto v, if the status is not aborted andv is in the own set of the thread, then \nthe state does not change. status is set to validated. 5. Validate. (i) c = commit and d = validate and \nr =., and 6. Commit. (i) c = commit and d = c and r =1, and (ii) t 1 t 2 t 2 t 2 t 2 validated, and (iii) \nrs = \u00d8 = ls(ii) status t 1 = .nished and status t 2 status validated, and (iii) for = = ws = ms = t 2 \nand status .nished, and (iv) for all threads u = t, we have all threads u = t, we have rs u 2 = rs and \nos u 2 = os u 1 , and if u 1 = and ws u 2 = ws u 1 and ls u 2 = lsand statusrs u 2 u 1u 1u 2 = rs t 1 \nn os u 1 = \u00d8, then status u 2 = aborted, else status u 2 = status t 1 . = rs . (v) for all threads u \n= t such that rs u 1u 1 . ws u 1 = \u00d8, we When a thread t commits, if the status is .nished, then the \nstatus is status u 2 = ms u 1 . ws t 1 . When a thread t commits, if the status have mschanged to validated,and \nfor all threadsu whoseown set intersects is validated, then the status is changed to .nished, and the \nread, with the read set of t, the status of u is changed to aborted. write, lock, and modi.ed sets are \nset to empty, and all variables 6. Commit. (i) c = commit and d = c and r =1, and (ii) written by t are \nadded to the modi.ed sets of all threads that have t 1 validated, and (iii) os t 2 = \u00d8, and rs t 2 = \n\u00d8 and status = an un.nished transaction. t 2 .nished, and (iv) for all threads u = t, we have rs u 2 \n= status = A transition (q1, c, (abort,t), 0,q2) is in d if the command c = os u 1 ,and if rs u 1 nos \nt 1 = \u00d8, then status u 2 = invalid, and os rs u 1u 2 is abort enabled in q1 for thread t, and status \nt 2 = .nished, and else status = status u 1 . When a thread t commits, if the status is u 2 t 2 = ws \nt 2 = ls t 2 = ms t 2 = \u00d8, and q u 2 = q u 1 for all threads u = t.validated, then the own set and read \nset of t are set to empty and rs the status is set to .nished, and the status of threads, whose read \n set intersects with the own set of t, is set to invalid. 3.5 The optimistic concurrency control TM A \ntransition (q1, c, (abort,t), 0,q2) is in d if the command c Wenowdiscussacommon concurrencyprotocolusedin \ndatabases. is abort enabled in q1 for thread t, and status t 2 = .nished, and It was proposed by Kung \net al. [KR81], and is called optimistic rs t 2 = \u00d8 and os t 2 = \u00d8, and q u 2 = q u 1 for all threads \nu = t. concurrencycontrol (OCC). OCC executes the transactions of the  3.4 The TL2 transactional memory \nTransactional locking2 (TL2) [DSS06] isa TM that uses global version numbers to ensure correctness.Version \nnumbers allow ef\u00ad.cient read set validation in a distributed setting. We model ver\u00adsion numbers using \nmodi.ed sets for each thread. When a trans\u00adaction commits, it adds its write set to the modi.ed set of \nev\u00adery thread with an un.nished transaction.We de.ne the TL2 TM MTL2 using the TL2 TM algorithm as ATL2 \n. The TL2 TM tran\u00adsition system An,k for n threads and k variables is given by the TL2 threads without \nany synchronization. Before committing, every transaction chooses a sequence number and validates its \nread set. Transactions commit in the order of sequence numbers, which we model using precedence sets, \nsimilar to the way we modeled version numbers using modi.ed sets in the TL2 TM algorithm. We de.ne the \nOCC TM Mocc using an OCC TM algorithm Aocc. We refer to the OCC TM transition system with n threads and \nk variables as An,k . The formal de.nition of the transition occ system can be obtained from the original \nalgorithm, as we did in the previous examples. tt tuple (Q, qinit , D, p, d). A thread state q rithm \nis de.ned as a 5-tuple (status of t in the TL2 algo-Table1shows runs with different schedules on the \nprogram in tt , lst , ms t), where Figure 1(a), for each TM algorithm described above. , rs , ws TM \nScheduler output The sequence s0s1 ... in the run of L(A) The word for the run of L(A) seq 11122 ... \n(r, 1)1, (w, 2)1,c1, (w, 1)2,c2 ... (r, 1)1, (w, 2)1,c1, (w, 1)2,c2 ... 112122 ... (r, 1)1, (w, 2)1,a2,c1, \n(w, 1)2,c2 ... (r, 1)1, (w, 2)1,a2,c1, (w, 1)2,c2 ... 2PL 111112 ... (l, 1)1, (r, 1)1, (l, 2)1, (w, 2)1,c1, \n(l, 2)2 ... (r, 1)1, (w, 2)1,c1 ... 1211112 ... (l, 1)1,a2, (r, 1)1, (l, 2)1, (w, 1)1,c1, (l, 2)2 ... \na2, (r, 1)1, (w, 2)1,c1 ... dstm 12211112 ... (r, 1)1, (o, 1)2, (w, 1)2, (o, 2)1, (w, 2)1,v1,c1,a2 ... \n(r, 1)1, (w, 1)2, (w, 2)1,c1,a2 ... 12222111 ... (r, 1)1, (o, 1)2, (w, 1)2,,v2,c2, (o2)1, (w, 2)1,a1 \n... (r, 1)1, (w, 1)2,c2, (w, 2)1,a1 ... TL2 11211122212 ... (r, 1)1, (w, 2)1, (w, 1)2, (l, 2)1,k1,v1, \n(l, 1)2,k2,v2,c1,c2 ... (r, 1)1, (w, 2)1, (w, 1)2,c1,c2 ... 112121222 ... (r, 1)1, (w, 2)1, (w, 1)2, \n(l, 2)1, (l, 1)2,a1,k2,v2,c2 ... (r, 1)1, (w, 2)1, (w, 1)2,a1,c2 ... occ 1211212 ... (r, 1)1, (w, 1)2, \n(w, 2)1,s1,s2,c1,c2 ... (r, 1)1, (w, 1)2, (w, 2)1,c1,c2 ... 1221112 ... (r, 1)1, (w, 1)2,s2, (w, 2)1,s1,a1,c2 \n... (r, 1)1, (w, 1)2, (w, 2)1,a1,c2 ... 4. Reduction theorem for safety Wepresentareduction theorem for \nstrict serializability and opacity. The theorem states that if a TM ensures strict serializability (resp. \nopacity)forall programsontwothreadsandtwovariables,thenthe TM ensures strict serializability (resp. opacity). \nThe reduction the\u00adorem relies on certain structural properties of transactional mem\u00adories. These properties \nare satis.ed by all TMs that we discussed in the previous section.Forevery property, we alsogive more \nde\u00adtails onwhythe mentioned TMs satisfythese properties. Note that the properties are suf.cient (and \nnot necessary) conditions for the reduction theorem to hold. We de.ne four structural properties for \nTMs. LetM be a trans\u00adactional memory. Let p be a program on n threads and k variables. Let w be a .nite \npre.x of a word in M(p). P1. Transaction projection. Aborting and un.nished transactions can in.uence \nother transactions only by forcing them to abort. Thus, removing all aborting transactions and some of \nthe un.n\u00adished transactions do not change the response of the TM to the remaining statements.Formally, \nlet X be the set of transactions in w.We de.ne the transaction projection of w on X ' . X as the subsequence \nof w that contains every statement of all transactions in X '. The property P1 states that the transaction \nprojection of w on X ', where X ' contains all committing transactions, no aborting transactions, and \nanysubset of the un.nished transactions in w, is in M(p ' ) for some program p '.For instance, a TM satis.es \nP1 if forevery thread t:(i) whenevera statementofan abortingor un.n\u00adished transaction of thread t changes \nthe state of another thread u, then u cannot commit, and (ii) upon an abort, the state of t is reset \nto the initial thread state of t. P2. Thread symmetry. For non-overlapping transactions, the TM is oblivious \nto the identity of the thread executing the transaction. The property P2 states that if (i) w have no \naborting transactions, and (ii) there exist two threads u and t such that for all committing transactions \nx of u and y of v in the word w, either x<w y or y<w x, then the word w ' obtainedby renamingall transactionsof \nthread u to be from thread t isa .nite pre.xofawordin M(p ' ) for some program p ' on n - 1 threads and \nk variables.For instance, a TM satis.es P2 if (i) the thread state is set to the initial thread state \nupon a commit, and (ii) the transition relation is identical for all threads. P3. Variable projection.Ifatransaction \ncan commit, then removing all statements thatinvolve some particularvariables does not cause the transaction \nto abort.We de.ne the variable projection of w on V ' . V as the subsequence of w that contains all commit \nand abort statements, and all read and write statements to variables in V '. The property P3 states that \nif w has no aborting transactions, then for all V ' . V ,thevariable projectionofw on V ' is in M(p ' \n), where p ' is obtained by removing all read and write statements to variables in V \\ V ' from all thread \nprograms in p.For instance, a TM satis.es P3 if reading or writing a variable does not remove a con.ict \non other variables. All TMs we know of satisfy P3 as they track every variable accessed by every thread \nindependently. P4. Monotonicity. If a word is allowed by the TM, then more sequential formsof theword \nare also allowed.Formally, let F . S * bethesetof opaque(resp.strict serializable)wordswithexactly one \nun.nished transaction.We de.nea function seq : F . 2F such that if w2 . seq(w1) and y is the un.nished \ntransaction in w1, then (i) com(w2) is sequential and strictly equivalent to com(w1' ), and (ii) all \nstatements of y in w1 ' occur in w2 in some order suchthat order of all con.icts of global reads in y \nwith other transactions in w1 ' is preserved, where w1 ' is obtained from w1 by adding for every transaction \nx that commits before y in w, a write of an auxiliary variable vxy to x, and a read of vxy to y. (These \nvariables are introduced to maintain the order of transactions.) The monotonicity property for opacity \n(resp. strict serializability) states that if w = w ' \u00b7 s, where w ' . F , and s is not an abort, and \ns is a statement of the un.nished transaction in w ', then for every word w2 . seq(w ' ), the word w2 \n\u00b7 s is a .nite pre.x of a word in M(p ' ) for some program p '.For instance, a TM satis.es P4 if it is \nun.nished commutative and commit commutative. A TM is un.nished commutative if for all words wp,wq,ws \n. S *, if the word wp \u00b7 wq \u00b7 s \u00b7 ws is a .nite pre.x of a word in M(p), where s is a global read and \nno statement in wq con.icts with s, then wp \u00b7s\u00b7wq \u00b7ws isa.nite pre.xofawordin M(p ' ) for some program \np '.ATM is commit commutative if for allwords wp,wq,ws . S * , if wp \u00b7 wq \u00b7 s \u00b7 ws is a .nite pre.x of \na word in M(p), where s is a commit of some transaction x and no statement in wq con.icts with s, then \nthe word wp \u00b7 x \u00b7 wq ' \u00b7 ws is a .nite pre.x of a word in M(p ' ) for some program p ', where wq ' is \nthe word obtained by removing transaction x from wq. The idea is that with these commutativity rules, \nan interleaved word can be made sequential. The TMs, 2PL, DSTM, TL2 and OCC are un.nished commutative \nand commit commutative, and thus satisfy monotonicity. Theorem 1. IfaTM M ensures strict serializability \n(resp. opacity) for all programs on two threads and two variables, and satis.es the properties P1, P2, \nP3, and P4 for opacity (resp. strict serializabil\u00adity), then M ensures strict serializability (resp. \nopacity). Proof. We prove the theorem for strict serializability. A similar proof holds for opacity. \nThe proof is by contradiction. Let p be a program in P n,k . Let w beaword in M(p) such that w is not \nstrictly serializable. Let wp be the longest .nite pre.x of w such that wp is strictly serializable and \nlet w1 = wp \u00b7 s, where s =(c, t) is a statement of transaction x. Let X be the set of statement sj of \nv2 and i>j. The con.ict graph G is acyclic iffthe committed transactions in wp. By property P1, there \nexists a word wordw isstrictly serializable.Wenotethatthesizeofthis construc\u00adw2 generated by projecting \nw1 to X .{x} such that w2 is a .nite tion is unbounded. The following parameterized word illustrates \npre.x of a word in M(p2) for some program p2. We note that the point: wm =((read, v1), t1), (((write, \nv1), t2),(commit, t2))m , '' \u00b7 s and w is strictly serializable and w2 is not strictly (commit, t1). \nThe number of vertices in the con.ict graph of wm w2 = w pp serializable. So, using property P4 for \nstrict serializability, there is m +1. Thus, we cannot aim to create a .nite transition system ''' '' \nexists a word w ) such that the word w3 . seq(w w a .nite pre.x of a word in M(p2). In w3 only one transaction, \nx, does not execute sequentially. Using property P2, we rename the threads for the transactions in w3.We \nlet all transactions except x to be executed by thread u. Let this renaming give word w4.We note that \nthe last statement of x is a commit. As w4 is not strictly serializable, we know (by the de.nition of \ncon.ict) that one of the following holds: (i) s1 = ((read,v1),t) and s2 = ((read,v2),t) are global reads \nof transaction x such that some transaction y of thread u writes to v1 and some transaction y ' of u \nwith y ' = y or y<w4 y ' writes to v2 and both commit between s1 and s2, (note that y and y ' cannotoverlapduetothe \nstructureof w4,)or (ii) s1 = ((read,v1),t) isaglobal readof transaction x such that some transaction \ny of thread u writes to v1 and commits after s1, and thereisacommitting transaction y ' with y ' = y \nor y<w4 y ' which has a command (read,v2) or (write,v2), and x also writes to v2. (Note that v1 may be \nsame as v2). Let w5 be a variable projection of w4 on {v1,v2}. We know that w5 is a .nite pre.x of a \nword in M(p5) for some program p5 on two threads and two variables, by property P3. Also, we note that \nw5 is not strictly serializable. As M ensures strict serializability for all programs on two threads \np and two variables, we get a contradiction. Thus, there is no such program p5. This leads us to a contradiction. \nD = p p \u00b7 s is for the RSS TM algorithm using con.ict graphs. We give a .rst .nite state representation \nfor the language of strictly serializable words, when transactions may abort. The idea of maximal serializ\u00adability \nwas also addressed earlier [FR85] for a bounded number of non-aborting transactionswithabounded numberof \nstatementsper transaction.Theideawasbuiltupona notionof transitive con.icts, which does not hold when \ntransactions may abort. Thekey idea to get around the problem of in.nite states is to maintain sets called \nprohibitedread and write sets forevery thread. These sets allow to handle unbounded delay between transactions, \nas committing transactions store the required information in the sets of other threads. Onceatransaction \ncommits or aborts, we need not remember it (unlike con.ict graphs). Thus, we need to store infor\u00admation \nof at most one transaction per thread. The RSS TM tran\u00adsition system is based on the following observation: \nEvery com\u00admitting transaction serializes at some point during its execution. The RSS TM transition system \nmakes a non-deterministic guess of when a transaction serializes. Depending upon the guess, the tran\u00adsition \nsystem checks uponthe commitofa transaction, whetherthe commit can be executed, or it needs to abort. \nFormally, we de.ne the RSS TM algorithm Ass as a fam\u00adily of RSS TM transition systems. The RSS TM transition \nsys\u00adtem Anss ,k for n threads and k variables is given by the tuple q t is a 6-tuple of the form tttt \n(Q, qinit , D, p, d). The thread state 5. The reference TM algorithms (Statust tt t , Predst),whereStatust \n.{started, invalid, serialized, .nished} is the status function, rs . V is the , rs , ws , prs , pws \nTo verify the safety properties of a transactional memory, we take read set, ws is the write set, prs \nis the prohibited . V . V the following approach. We construct a reference TM algorithm t . V is the \nprohibited write set, and Predst . T read set, pwsfor strict serializability (RSS TM algorithm), whose \nlanguage is is the predecessor set for thread t. If v . prs t (resp. v . pws t),exactly the set of all \nstrictly serializable words. Similarly, we con\u00adthen the status of the thread t is set to invalid if t \nglobally reads struct a reference TM algorithm for opacity (RO TM algorithm), (resp. writes to) v. If \nu . Predst, then the un.nished transaction whose language is exactly the set of all opaque words. Then, \nof u has to commit before the un.nished transaction of t. The ini\u00adwe show that a given TM de.ned by a \nTM algorithm A ensures strict serializability (resp. opacity) ifffor all n and k, all words in tial thread \nstate q t init is (.nished, \u00d8, \u00d8, \u00d8, \u00d8, \u00d8). The set of extended commands is D = C .{serialize}. The transition \nrelation d is non\u00addeterministic.Atransition (q1, c, (d, t), r, q2) is in d if c is enabled L(An,k ) are \nin the language of the RSS (resp.RO) TM transition system for n threads and k variables. If the given \nTM satis.es the in q1 for thread t and one of the following holds. structural properties presented in \nthe previous section, it is suf.\u00ad1. Local read. (i) c =(read,v) and d = c and r =1, and (ii) cient to \ncheck that all words in L(A2,2) are in the language of the RSS(resp.RO)TM transitionsystemfor2threadsand2variables. \nt 1, and (iii) q2 not global, then the state remains unchanged. q1. When a thread reads v, if the read \nis v . ws = Thekeyinsight that makes our techniqueworkis that the ref\u00ad2. Global read. (i) c =(read,v) \nand d = c and r =1, and (ii) erence TM algorithms for strict serializability and opacity for two t 1, \nand (iii) if statuselse if status t 1 = t 2 .nished, then status ./ws = started, v threads and two variables \ncan be de.ned as .nite-state transition tt 1 , then status t 2 = serialized and v . prs = invalid, systems. \nThis is not obvious, as threads may be delayed arbitrarily, 1 t t 1, and(iv) and pws tt t else status \n t t t rs2 = rs1 .{v} and ws2 = ws 1, and = status transactions may contain arbitrarily many statements \nand may be 2 1 t t 2 = prs 1 t t and prs and PredsPreds= pws = aborted arbitrarily often.We presenttheRSSTM \ntransition system .rst, because it provides the basis for de.ning theROTM transi\u00ad 22 1 u 1 . Whenathread \nt reads v globally, v is added to the read set, and if the status of t is .nished, (v) for all threads \nu = t,we haveq  u = q 2 tion system. Suitable .nite-state reference TM transition systems can also \nbe de.ned for stronger notions of safety, such as the no\u00ad tions described by Scott [Sco06], by modifying \nthe semantics of con.ict. then the status of t is changed to started, else if the status of t is serialized \nand v is in the prohibited read set, then the status of t is changed to invalid. 3. Write. (i) c =(write,v) \nand d = c and r =1, and (ii) if 5.1 The reference TM algorithm for strict serializability t .nished, \nthen status t 2 = t started, else if status status = = 1 t 1 , then status t 2 t serialized and \nv . pws = invalid, else status = The classical approach to checking whether a word is strictly se\u00ad t \n1, and (iii) ws and pws t 2 t t t t = ws1 .{v} and rs2 = rs1 and prs = 1, and (iv) for all tt status \nrializable is to construct a directed graph G =(V,E), called the tt t and PredsPreds con.ict graph \n[Pap79], of the committing transactions in the word. prs = pws 2 = 1 2 1 The con.ict graph captures the \nprecedence of the committing trans\u00ad actions based on the con.icts. Given a word w = s0s1 ..., the transactions \nin w form the set V of vertices in the con.ict graph. There exists an edge from a vertex v1 to a vertex \nv2 if v2 commits or aborts before v1 starts, or a statement si of v1 con.icts with a threads u = t, we \nhave q u u = q 21 When a thread t writes to v, the variable v is added to the write set, and if the \nstatus of t is .nished, then the status of t is changed to started, else if the status of t is serialized \nand v is in the prohibited write set, then the status of t is changed to invalid. C4. There exists a \ntransaction y such that x serializes after y and y writes to v and x reads v before y commits, and then \ny commits. The RSS TM transition system An,k guarantees by construc\u00ad ss tion, that a transaction x does \nnot commit iff one of the conditions, C1 C4 holds. Hence,everywordin L(An,k ) is strictly serializable. \nss Conversely, let w be strictly serializable. Consider an arbitrary .nite pre.x w2 of w. As w2 is strictly \nserializable, there is a sequential word w ' such that com(w ' ) is strictly equivalent to com(w2). Let \nthe committing transactions in the sequential word w ' be given by the sequence x1x2 ... of transactions. \nConsider a run . of the RSS TM transition system An,k such that w2 isa .nite ss pre.x of all successful \nstatements of ., and for all i and j such4. Serialize. (i) d = serialize and r =., and (ii) status t \n1 = that i<j, the transaction xi serializes before xj in .. The run t 2 = t 2 = rs t 1t 2 started, and \n(iii) status serialized and rs and ws = . exists because (i) the RSS TM transition system guesses every \npossible serialization forevery transaction during itsexecution, and t 1t 2 = prs t 1t 2 = pws t 1t 2 \n= and prs and pws and Preds {u . u = t, we have ws = serialized}, and (iv) for all threads . Upon anycommand \nof thread t, if the current status of t u 1 (ii)given that w2 is strictly serializable, there is no transaction \nx in q T | Status= q u 1u 2 the sequence x1x2 ... that satis.es anyof the conditions C1 C4,is started \nand if the thread t chooses to serialize, then the status of and commits in w2. Thus, the word w is in \nthe language L(An,k ). ss t is set to serialized, and every thread whose status is serialized is D added \nto the predecessor set of t. 5. Commit. (i) c = commit and d = c and r =1, and (ii)  5.2 The reference \nTM algorithm for opacity t 1 t 2 = .nished . status Apart from the requirements of the above mentioned \nreference TM t 2 and rs \u00d8, and (iv) for {serialized, .nished}, and (iii) statusPreds t 2 t 2 t 2 t 2 \n= = ws = prs = pws = algorithm for strict serializability, opacity requires that even global all threads \nu = t, we have rs and ws = ws u 1 and u 2 = rs u 1u 2 reads of aborting transactions observe consistent \nvalues. It turns = t, if u . u 2 u 1 Preds = Preds out that we can obtaina .nite-state representationof \ntheROTM t 1 . rs t 1 . ws t 1 , ,then prs and pws ,and(v)forallthreads \\{}tu u 1 u 2 t 1 u 1 u 2 . ws \nPreds = prs = pws transition system by slightly modifying our RSS TM transition else prs u 2 and pws \n, and (vi) for all threads u 1u 2 = pws u 1 = prs system. TheROTM transition system is based on the following \nobser\u00ad t 1 u 1 n (ws t 1 . rs t 1 )= \u00d8, and = invalid if ws u 2 u . Preds , set status otherwise, and \n(vii) for all threads u/. Preds t 1 status u 2 = status u 1 vation: Every committing and aborting transaction \nshould serial\u00ad and u = t, set status u 2 = invalid if ws t 1 n rs u 1 = \u00d8, andstatus u 2 = ize at some \npoint during its execution. Like the RSS TM transition status u 1 otherwise. Whenathread t commits, if \nthe current status of system, the RO TM transition system makes a non-deterministic guess of when a transaction \nserializes. In this case, the transition system checks uponevery global read andeverycommitofa trans\u00ad \naction, whether the command can be executed or the transaction needs to be aborted. The formalism for \nROTM algorithmAop and An,k the ROTM transition system op is identical to that of the RSS t is serialized \nor .nished,then the following happen: The status oft is set to .nished.For every predecessor thread u \nof t, all variables in the write set of t are added to the prohibited read set and the prohibited write \nset of u, and all variables in the read set of t are added to the prohibited write set of u.For all predecessor \nthreads u of t such that the write set of u intersects with the read set or write set of t, the status \nof u is set to invalid.For all threads u that are TM algorithm and the RSS TM transition system. The \nonly differ\u00adnot predecessors of t such that the read set of u intersects with the ence comes in the transition \nrelation d, on a global read, and on write set of t, the status of u is set to invalid. a serialize command.We \nobtain the transition relation for Aopn,k by Forevery stateq1 . Q,atransition(q1, c, (abort,t), 0,q2) \nisin replacingrules2and4ofthatof An,k by the rules 2a and 4a below. ss 2a. Global read. (i) c =(read,v) \nand d = c and r d if c . C is enabled in q1 for thread t, and rs t 2 = ws t 2 = prs t 2 = = 1, ws t 1 \nprs t 1t 2 = rs t 1 and (ii) vand v , and (iii) rs pws t 2 = Preds t 2 = \u00d8, and status t 2 = .nished, \nand q u 2 = q u 1 for all . . t 2 t 1t 2 t 1 and pws t 2 and ws and prs t 1 .{v} and threads u = t. = \nws = prs = pws Preds t 2 t 1t 1 t 2 Note that the non-determinism in the transition relation comes , \nand (iv) if = .nished, then = Predsstatusstatus = t 2 = status t 1 from the serialize command, and thefact \nthat abort is allowed in started, else status, and (v) for all threads u t, = every state where a command \nis enabled. if status = serialized and t and v . ws u 1 , then u 1 Preds u 1 ./ invalid, else status \n, and (vi) for all status u 2 u 2 u 1 = status = Theorem 2. Given a word w on n threads and k variables, \nthe word w is strictly serializable if and only if w . L(An,k ). ss threads u = t, if status serialized \nand t , then u 1 = u 1 ./Preds , and (vii) prs u 2 pws u 2 u 1u 2 = pws u 1u 1 = pws = prs Proof. \nConsidera run . of An,k . Let w1 be an arbitrary .nite pre.x and rs ss u 2 u 1 .{v}, else pws and ws \nand Preds u 2 = Preds for all u 2 u 1u 1 = rs = ws of the sequence of all successful statements in \n., and let X be the set of .nished transactions in w1. Let w ' be the sequential word such that w ' is \ntransaction equivalent to w and x<wI y if the serialize command of transaction x comes before that of \ntransaction y in . (Note that every non-empty transaction has the serialize command exactly once.) Then, \ncom(w ' ) is strictly equivalent to com(w1) if for every transaction x . X, either the transaction x \nthreads u = t. When a thread t reads v globally, if v is not in the prohibited read set, then the following \nhappen: v is added to the read set. If the status of t is .nished, then it is changed to started. For \nevery other threadu with status serialized such that t is nota predecessor of u, the variable v is added \nto the prohibited write set of u, and if v is in the write set of u, then the status of u is set to invalid. \n does not commit in w1,or one of the following conditions holds for 4a. Serialize. (i) d = serialize \nand r =., and (ii) status x (graphically shown in Figure 2): started, and (iii) if there exists a thread \nu = t such that status t 1 u 1 = = started and rs u 1 nws t 1 = \u00d8,thenstatus t 2 = invalid,elsestatus \n t 2 C1. There exists a transaction y such that x serializes before y and = y writes to a variable v \nand commits, and then x globally reads v. serialized, and (iv) pws t 2 = pws t 1 . V ' where V ' t \n1 {v . V |started}, = for some thread u = t with u 1u 1 C2. There exists a transaction y such that x \nserializes before y and v . rs status = t 2 = rs t 1 and ws t 2 t 1t 2 and (v) and prs and x writes \nto v and y reads v before x commits, and y commits. rs = ws = prs Preds t 2 C3. There exists a transaction \ny such that x serializes before y and u 1 {u . T | = t, if status status = = both x and y write to \na variable v, and y commits before x does. threads t 1 u 1 serialized}, and (vi) for all serialized and \nws u 1 = n rs \u00d8, u = Table 2. Time for simulation checking for TM algorithms on a quad dual core 2.8 \nGHz server with 16 GB RAM. In case simu\u00adlation holds, we write YES followed by the time required for \nthe simulation. Otherwise, we write NO followed by the counterex\u00adample produced, followed by the time \nrequired to prove that no simulation exists, followed by the time required to .nd the coun\u00adterexample.A \n* for the search for simulation relation means that itdoesnot completein2hours,andwetryto.nda counterexam\u00adple. \nTM tran- Number sition 2,22,2 of A2,2 -Ass A2,2 -Aop system states A2,2 seq 3 YES, 0.8s YES, 0.7s 2PL \n99 YES, 13s YES, 8s dstm 944 YES, 127s YES, 82s TL2 11840 YES, 1647s YES, 1438s occ 4480 YES, 765s NO, \nw1, 567s,4s TL2 modi.ed 17520 NO, w2, *, 9s NO, w2, *, 8s ss 12346  op 9202 Counterexample w1 (w, 1)2, \n(r, 1)1,c2, (r, 1)1 w2 (w, 2)1, (w, 1)2, (r, 2)2, (r, 1)1,c2,c1 u uu then status2 = invalid, else status2 \n= status1 , and (vii) for all u uut threads u = t, if status1 = serialized, then pws2 = pws1 . rs1, u \nu uuuu else pws = pws , and (viii) prs = prs and rs = rs and 2 1 2121 ws u 2 = ws u 1 and Predsu 2 = \nPredsu 1 for all threads u = t. Upon anycommand of thread t, if the current status of t is started, and \nif the thread chooses to serialize, then the following happen: If there isathread u with status started \nsuch thatthe read setof u intersects with the write set of t, then the status of t is set to invalid, \nelse the status of t is set to serialized. All variables in read sets of threads with status started \nare added to the prohibited write set of t. All threads with status serialized are added to the predecessor \nset of t. Forevery other threadu,if the status ofu is serialized and the write set of u intersects with \nthe read set of t, then the status of u is set to invalid.For every thread u with status serialized, \nthe read set of t is added to the prohibited write set of u. Theorem 3. Given a word w on n threads and \nk variables, the word w is opaque if and only if w . L(An,k ). op  5.3 Implementation and simulation \nchecking A TM de.ned by a TM algorithm A ensures strict serializability (resp. opacity) iff L(A2,2) . \nL(A2,2) (resp. L(A2,2) . L(A2,2)). As checking language inclusion is PSPACE-hard, we use the com\u00admon \ntechnique of checking for the existence of a simulation rela\u00adtion betweenboth transition systems.Theexistenceofa \nsimulation relationisa suf.cient condition for language inclusion.We write ss op 2,22,2 A1 -A2 to denote \nthat there exists a simulation relation be\u00adtween A21 ,2 and A22 ,2. For a TM M de.ned by a TM algorithm \nA which satis.es the structural properties of the reduction theo\u00adrem (Theorem 1), M ensures strict serializability \n(resp. opacity) if A2,2 -A2,2 ss (resp. A2,2 -A2,2). op We built an automatic veri.cation tool in C for \nchecking the existence of simulation relations using the quadratic algorithm by Henzinger et al. [HHK95]. \nThe tool is conceived as a platform for the automatic veri.cation of TMs that satisfy the structural \nproperties. We mention that simulation checking requires extra technical care in this scenario due to \ndifferent extended alphabets in different TMs. The tool takes as input two TM algorithms A1 2,22,2 and \nA2, and checks whether A1 -A2 . If the toolfails to .nd a simulation relation, it attempts to return \na .nite counterexample w . S * such that w is a pre.x of some word in L(A12,2), and w is not a pre.x \nof any word in L(A22 ,2). In certain cases, it is possible that although language inclusion holds, the \ntool cannot .ndasimulation relation. Thus, our decision procedureis soundbut notcomplete.ForallTM transitionsystemswe \nconsidered,ourtool terminates after .nding a simulation relation, or a counterexample. The results of \nour simulation checks are presented inTable 2. Our results demonstrate that all TMs discussed in Section \n3 sequential, 2PL, DSTM, and TL2 TM are simulatedby both ref\u00aderence TM transition systems. As for the \nOCC TM, it is simulated by the RSSTM transition system,but notby theROTM transi\u00adtion system.The toolgivesa \ncounterexampleinthe latter case.Our results establish the following theorem. Theorem 4. The sequential \nTM, two-phase locking, DSTM, and TL2 ensure opacity. The optimistic concurrency control ensures strict \nserializability,but not opacity. Our tool discovered a subtle point in TL2. In the description of the \npublished TL2 algorithm, we found the order of two oper\u00adations,validating the read set(rvalidate), and \nchecking whether a variable in the read set is locked(chklock), ambiguous.We mod\u00adeled these operations \nas two separate atomic operations, such that that chklock happens after rvalidate, to obtain a modi.ed \nTL2 TM algorithm. The tool found that the modi.ed TL2 TM algorithm is not simulated by the RSS TM transition \nsystem, and the tool pro\u00advided a counterexample. Thus, we conclude that the modi.ed TL2 TM does not ensure \nstrictly serializability, and thus does not en\u00adsure opacity. In the published TL2 algorithm, the authors \nmaintain the version number and the lock bit of every variable in the same memory word. This ensures \nthat the two operations chklock and rvalidate execute atomically, and thus they can be executed in any \norder. So, our experiments discover that the correctness of TL2 is based on the subtlefact that either \ntheversion number and the lock bit have to be accessed atomically, or rvalidate has to occur after chklock. \n6. Verifying liveness We de.ne two different notions of liveness, obstruction freedom and livelock freedom, \nas discussed in the transactional memory literature.A third notion, wait freedom [Her91], implies livelock \nfreedom.Sincewewillshowthat noneofourexampleTMssatisfy livelock freedom, theydo not satisfy wait freedom \neither. Aword w . S . is obstruction free [HLM03] if for all threads t, if the word w has an in.nite \nnumber of aborts of t, then w has an in.nite number of commits of t or there are in.nitely many statements \nof some thread u = t.Formally, w is obstruction free if VW (D.(abort,t) . D.((commit,t). c. (c, u))). \nt.T C,u.T \\{t} This is a Streett condition. Awordw . S . is livelockfree [AKH03]ifthewordhasan in.nite \nnumber of commits, or there is a thread t such that t has in.nitely many statements and .nitely many \naborts in w. Formally, w is W WW livelockfree if D.((commit,t)). (D.((c, t)). t.Tt.Tc.C .D\u00ac(abort,t)). \nNote that livelock freedom implies obstruction freedom. ATMM ensures obstruction freedom (resp. livelockfreedom) \nfor all programs with n threads and k variables if for every pro\u00adgram p . P n,k , every word w . M(p) \nis obstruction free (resp. livelock free). M ensures obstruction freedom (resp. live\u00adlock freedom) if \nM ensures obstruction freedom (resp. livelock freedom) for all programs with an arbitrary number of threads \nand variables.We usethe formalismofTM algorithmstoverifylive\u00adness propertiesof TMs.We de.nea loop l in \na TM transition sys\u00adtem An,k as a .nite word s0 ...sm such that there exists a run (q0,l0,s0,r0) ... \n(qm,lm,sm,rm) of An,k such that q0 = qm. Note that every word w that is not obstruction free violates \nat least one of the conjuncts of the Streett condition stated above. Each conjunct (Streett pair) corresponds \nto one thread.A word w can violate the condition for thread t, only if w has from some point on only \nstatements of t. Note that in this case w trivially satis.es the Streett pairs for other threads. Thisfact \nallows us to use a simple model checking procedure, even though obstruction freedom is formally a Streett \ncondition. In particular, a TM de.ned by a TM algorithm A ensures ob\u00adstruction freedom for all programs \nwith n threads and k variables iffthere is no loop l in An,k such that all statements in l are from the \nsame thread, and l contains no commit, and l contains an abort. Similarly, a TM ensures livelock freedom \nfor all programs with n threads and k variables iffthere is no loop l in An,k such l contains no commit, \nand every thread that has a statement in l, has an abort in l. 6.1 Reduction theorem for liveness As \nwe did for safety, we state a reduction theorem that proves that it is suf.cient to verify liveness of \na TM on programs with two threads and one variable to generalize the result to all programs. For this \npurpose, we describe two more structural properties of TMs. These properties are again satis.ed by all \nTMs that we have discussed. Let w = w1 \u00b7 w2 be an in.nite word such that w is in M(p) for some program \np, and no un.nished transaction in w1 has a statement in w2, and all statements in w2 are from the same \nthread, and there is no commit command in w2.For i .{1, 2}, let Vi be the variables accessed in wi. P5. \nTransaction projection. A thread t running in isolation (no interleaved step from other threads) shall \nabort repeatedly only if it con.icts with some un.nished transaction. As the number of threads is .nite, \nand a thread can have at most one un.nished transaction, there are in.nitely manyaborts of t due to a \nparticular thread. The property P5 states that (i) the word w1 ' \u00b7 w2 is in M(p ' ) for some program \np ', where w1 ' is obtained by taking the transaction projection of w1 on non-aborting transactions, \nand (ii) if w1 has no aborting transactions and w2 reads or writes only one ' '' '' variable, then thereexistsawordw \n= w1 \u00b7w2 . M(p),wherew1 is obtained by projecting w1 to transactions of some thread t that has statements \nin w1.For instance, a TM satis.es P5 if the state of a thread is reset to the initial state upon an abort \ncommand, and every variable accessed by every thread is tracked independently. P6. Variable projection.Athreadt \nrunning in isolation shall abort repeatedly only if some commands corresponding to some vari\u00adablesarenotallowed.Asthe \nnumberofvariablesis.nite,thereare in.nitely manyaborts of t due to a particular variable. The prop\u00aderty \nP6 states that(i) thereexistsaword w1 \u00b7w2 ' . M(p ' ) for some program p ', where w2 ' is the variable \nprojection of w2 on {v} for some variable v . V2, and (ii) if w1 has no aborting transactions, ''' ' \nthen the word w = w1 \u00b7 w2 is in M(p ) for some program p , where w1 ' is the variable projection of w1 \non V2.For instance, a TM satis.es P6 if the TM tracks every variable accessed by every thread independently. \nTheorem 5. Ifa TM M satis.es properties P5 and P6, and M ensures obstruction freedom for two threads \nand one variable, then M ensures obstruction freedom. Proof. Let w . M(p) beawordon arbitrary numberof \nthreadsand variables such thatw is not obstruction free. As w is not obstruction free, it can be written \nin the form w1 \u00b7 w2 as required by the properties P5 and P6.We can then use these properties to obtain \na ' '' word w on two threads and one variable such that w . M(p ) for some program p ' . D Table 3. Results \nof model checking liveness on a dual core 2.66GHz desktop PC with2GB RAM. The notation is similar to \nTable 2. The time denotes the time required to prove a liveness property or .nd a counterexample. The \ncounterexamples obtained are of the form a \u00b7 b..We write the looping part b here. TM algorithm Obstruction \nfreedom Livelock freedom seq NO, w1, 0.1s NO, w1, 0.1s 2PL NO, w1, 0.1s NO, w1, 0.1s dstm YES, 2s NO, \nw2, 0.2s TL2 NO, w1, 0.4s NO, w1, 0.4s occ NO, w3, 0.7s NO, w3, 0.7s Counterexamples w1 a1 w2 a1, (r, \n1)1, (o, 1)1, a2, (o, 1)2 w3 s1, a1  6.2 Model checking liveness Webuiltaveri.cation toolto check obstruction \nfreedomandlive\u00adlock freedom properties for transaction memories de.ned by TM algorithms.To check obstruction \nfreedom, our tool tries to .nda loop l in the TM transition system such that all statements in l are \nfrom the same thread, and l has no commit, and l has an abort. If the tool .nds such a loop, the loop \nis a counterexample to obstruc\u00adtion freedom. If the tool does not .nd a loop, we know that the TM ensures \nobstruction freedom. Similarly, to check livelock freedom, our tool tries to .nd a loop l in the TM transition \nsystem such that there is no commit in l, and every thread that has a statement in l, has an abort in \nl. In this way, our tool provides a platform for TM designers to check which liveness properties are \nensured by their TMs. If the liveness propertyfails, then the tool provides feedbackin the form of a \nrun thatrepresents a counterexample. Our results are shown in Table 3. The next theorem follows. Theorem \n6. DSTM ensures obstruction freedom and does not en\u00adsure livelock freedom. Sequential TM, two phase-locking, \nTL2, and optimistic concurrencycontrol do not ensure obstruction free\u00addom. 7. Related Work There has \nbeen recent independent work on the formal veri.cation of STM algorithms [COP+07]. Cohen et al. model \nchecked STMs applied to programs with a small number of threads and variables against the strong safety \ncriteria of Scott [Sco06]. Theydo not offer a reduction theorem and do not consider liveness properties. \nOur construction of the reference TM algorithms is related to the work of Fle and Roucairol [FR85]. They \ninvestigated the set of concurrent traces that are generated by a .nite set of iterating transactions. \nTheyproved that the language consisting of all traces that are con.ict equivalent to a sequential trace \nis regular. Their results cannot be applied in the presence of aborting transactions, as they require \nthe transitivity of con.icts, which does not hold when transactions may abort. There has been much research \non the formal veri.cation of relaxed memory models and cache-coherence protocols for modern multi-processors, \ne.g., [HQR99, Qad03, GYS04,BAM07]. In this work, the semantics of a shared memory is generally given \nby a memory consistency model, which de.nes the possible outcomes ofexecutinga concurrent program. Since \nour approach speci.cally targets STM, we use a deferred update semantics rather than a memory consistencymodel. \n8. Conclusion We presented a new technique for verifying STM safety and live\u00adness properties. The cornerstones \nof our technique are a .nite-state representation for the languages of strictly serializable and opaque \nexecutions, and an automated veri.cation tool for STMs. Our method applies to all STM protocols that \nsatisfy certain structural properties, and we successfully veri.ed opacity for 2PL, DSTM, and TL2, and \nthe obstruction freedom of DSTM. Currently,our framework does not apply when transactions help each other. \nFor instance, we cannot model Fraser s STM [FH07] where threads help each other in order to ensure livelock \nfree\u00addom.Foref.cient performance during contention, manySTM pro\u00adtocols rely on a contention manager, \nlike the Politeor Karma con\u00adtention manager of Scherer and Scott [SS05]. In this work, we do not handle \nsomeof these contention managers.Weplantoex\u00adtend our work by modeling different contention managers as \nnon\u00addeterministic transition systems. Also, our liveness properties cap\u00adture deterministic notions. It \nwill be interesting to account for prob\u00adabilistic meanstodealwith contention,suchas randomexponential \nbackoff. We also assumed that the commands in the extended alphabet, like read, write, validate, commit, \nexecuted atomically. So, STM algorithms have to guarantee this level of atomicity to ensure cor\u00adrectness \nusing our methodology. Currently we are extending our work to reason about correctness if the lower level \nprimitives are not atomic. References [AKH03] J.H. Anderson,Y. Kim, andT. Herman. Shared-memory mu\u00adtual \nexclusion: Major research trends since 1986. Distributed Computing, pages 75 110, 2003. [AMP00] R. Alur, \nK. L. McMillan, and D. Peled. Model-checking of correctness conditions for concurrent objects. Information \nand Computation, pages 167 188, 2000. [BAM07] S. Burckhardt, R. Alur, and M. M. K. Martin. Checkfence: \nchecking consistency of concurrent data types on relaxed memory models. In ACM SIGPLAN Conference on \nProgram\u00adming Language Design and Implementation (PLDI), pages 12 21, 2007. [BCG89] M. C. Browne, E. M. \nClarke, and O. Grumberg. Reasoning about networks with many identical .nite state processes. Information \nand Computation, pages 13 31, 1989. [BD94] J.R. BurchandD.L. Dill. Automaticveri.cationof pipelined microprocessors \ncontrol. In International Conference on Computer AidedVeri.cation (CAV), pages 68 80. Springer, 1994. \n[COP+07] A. Cohen, J. O Leary, A. Pnueli, M. R.Tuttle, and L. Zuck. Verifying correctness of transactional \nmemories. In Inter\u00adnational Conference onFormal Methods in Computer-Aided Design (FMCAD), pages 37 44. \nIEEE Computer Society, 2007. [DSS06] D. Dice,O. Shalev,andN.Shavit.Transactional lockingII.In International \nSymposium on Distributed Computing (DISC), pages 194 208. Springer, 2006. [EGLT76] K.P. Eswaran, J. Gray, \nR. A. Lorie, and I. L.Traiger. The notions of consistency and predicate locks in a database system. Communicationsof \ntheACM, pages 624 633, 1976. [FH07] K. Fraser andT. Harris. Concurrent programming without locks. ACMTransactions \non Computer Systems, 2007. [FR85] M. Fl\u00b4 e and G. Roucairol. Maximal serializability of iterated transactions. \nTheoretical Computer Science, pages 1 16, 1985. [GK08] R. Guerraoui and M. Kapalka. On the correctness \nof transactional memory. In ACM SIGPLAN Symposium on Principles and Practice ofParallel Programming (PPoPP), \npages 175 184, 2008. [GYS04] G. Gopalakrishnan,Y.Yang, and H. Sivaraj. QB or Not QB: Anef.cientexecutionveri.cation \ntool for memory orderings. In International Conference on Computer AidedVeri.cation (CAV), pages 401 \n413. Springer, 2004. [Her91] M. Herlihy. Wait-free synchronization. ACMTransactions on Programming Languages \nand Systems, pages 124 149, 1991. [HHK95] M. R. Henzinger, T. A. Henzinger, and P. W. Kopke. Computing \nsimulations on .nite and in.nite graphs. In IEEE Annual Symposium on Foundations of Computer Science \n(FOCS), pages 453 462, 1995. [HLM03] M. Herlihy,V. Luchangco, and M. Moir. Obstruction-free synchronization: \nDouble-ended queues as an example. In International Conference on Distributed Computing Systems, pages \n522 529. IEEE Computer Society, 2003. [HLMS03] M. Herlihy,V. Luchangco,M. Moir, andW.N. Scherer. Soft\u00adware \ntransactional memory for dynamic-sized data structures. In ACM SIGACT-SIGOPS Symposium on Principles \nof Dis\u00adtributed Computing (PODC), pages 92 101, 2003. [HM93] M. Herlihy and J. E. B. Moss. Transactional \nmemory: Architectural support for lock-free data structures. In International Symposium on Computer Architecture, \npages 289 300.ACM Press, 1993. [HQR99] T. A. Henzinger, S. Qadeer, and S. K. Rajamani. Verifying sequential \nconsistency on shared-memory multiprocessor systems. In International Conference on Computer Aided Veri.cation \n(CAV), pages 301 315. Springer, 1999. [KR81] H.T.Kung and J.T. Robinson. On optimistic methods for concurrencycontrol. \nACMTransactions on Database Systems, pages 213 226, 1981. [LR07] J. R. Larus and R. Rajwar. Transactional \nMemory. Synthesis Lectures on Computer Architecture. Morgan &#38; Claypool, 2007. [Mil71] R. Milner. \nAn algebraic de.nition of simulation between programs. In International Joint Conference on Arti.cial \nIntelligence (IJCAI), pages 481 489. William Kaufmann, 1971. [Pap79] C.H.Papadimitriou. The serializabilityof \nconcurrent database updates. Journalof theACM, pages 631 653, 1979. [Qad03] S. Qadeer. Verifying sequential \nconsistency on shared\u00admemory multiprocessors by model checking. IEEETrans\u00adactions onParallel and Distributed \nSystems, pages 730 741, 2003. [Sco06] M. L. Scott. Sequential speci.cation of transactional memory semantics. \nIn ACM SIGPLANWorkshop on Languages, Com\u00adpilers, and Hardware Support forTransactional Computing (TRANSACT), \n2006. [SS05] W. N. Scherer and M. L. Scott. Advanced contention management for dynamic software transactional \nmemory. In ACM SIGACT-SIGOPS Symposium on Principles of Distributed Computing (PODC), pages 240 248, \n2005. [ST95] N. Shavit and D.Touitou. Software transactional memory. In ACM SIGACT-SIGOPS Symposium on \nPrinciples of Distributed Computing (PODC), pages 204 213, 1995.   \n\t\t\t", "proc_id": "1375581", "abstract": "<p>Model checking software transactional memories (STMs) is difficult because of the unbounded number, length, and delay of concurrent transactions and the unbounded size of the memory. We show that, under certain conditions, the verification problem can be reduced to a finite-state problem, and we illustrate the use of the method by proving the correctness of several STMs, including two-phase locking, DSTM, TL2, and optimistic concurrency control. The safety properties we consider include strict serializability and opacity; the liveness properties include obstruction freedom, livelock freedom, and wait freedom.</p> <p>Our main contribution lies in the structure of the proofs, which are largely automated and not restricted to the STMs mentioned above. In a first step we show that every STM that enjoys certain structural properties either violates a safety or liveness requirement on some program with two threads and two shared variables, or satisfies the requirement on all programs. In the second step we use a model checker to prove the requirement for the STM applied to a most general program with two threads and two variables. In the safety case, the model checker constructs a simulation relation between two carefully constructed finite-state transition systems, one representing the given STM applied to a most general program, and the other representing a most liberal safe STM applied to the same program. In the liveness case, the model checker analyzes fairness conditions on the given STM transition system.</p>", "authors": [{"name": "Rachid Guerraoui", "author_profile_id": "81100348136", "affiliation": "EPFL, Lausanne, Switzerland", "person_id": "P1022823", "email_address": "", "orcid_id": ""}, {"name": "Thomas A. Henzinger", "author_profile_id": "81100034124", "affiliation": "EPFL, Lausanne, Switzerland", "person_id": "P1022824", "email_address": "", "orcid_id": ""}, {"name": "Barbara Jobstmann", "author_profile_id": "81323491677", "affiliation": "EPFL, Lausanne, Switzerland", "person_id": "P1022825", "email_address": "", "orcid_id": ""}, {"name": "Vasu Singh", "author_profile_id": "81381599564", "affiliation": "EPFL, Lausanne, Switzerland", "person_id": "P1022826", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1375581.1375626", "year": "2008", "article_id": "1375626", "conference": "PLDI", "title": "Model checking transactional memories", "url": "http://dl.acm.org/citation.cfm?id=1375626"}