{"article_publication_date": "06-07-2008", "fulltext": "\n Checking Race Freedom via Linear Programming Tachio Terauchi Tohoku University terauchi@ecei.tohoku.ac.jp \nAbstract We present a new static analysis for race freedom and race de\u00adtection. The analysis checks race \nfreedom by reducing the prob\u00adlem to (rational) linear programming. Unlike conventional static analyses \nfor race freedom or race detection, our analysis avoids explicit computation of locksets and lock linearity/must-aliasness. \nOur analysis can handle a variety of synchronization idioms that more conventional approaches often have \ndif.culties with, such as thread joining, semaphores, and signals. We achieve ef.ciency by utilizing \nmodern linear programming solvers that can quickly solve large linear programming instances. This paper \nreports on the for\u00admal properties of the analysis and the experience with applying an implementation \nto real world C programs. Categories and Subject Descriptors F.3.2 [Logics and Meaning of Programs]: \nSemantics of Programming Languages Program analysis; F.3.3 [Logics and Meaning of Programs]: Studies \nof Program Constructs Type structure General Terms Algorithms, Languages, Theory, Veri.cation Keywords \nFractional Capabilities,Linear Programming 1. Introduction Race condition occurs when one thread writes \nto a memory location that another thread is concurrently writing or reading. Race free\u00addom, the absence \nof race conditions, is a basic building block for developing and verifying shared-memory parallel programs, \nand static analysis for race freedom and race detection has been an ac\u00adtive focus of research. In many \nstatic (or dynamic) analyses for race freedom or race detection, the central idea is to compute locksets.Alocksetisthe \nset of locks that are always held when accessing some memory location (abstract memory location in static \nanalyses) such that a potential race is detected when the lockset is empty. It is important that the \nlocks in the locksets are linear [20] (or must-alias [18]), in the sense that each lock corresponds to \na unique concrete lock. Inferring locksets and lock linearity/must-aliasness statically can be non-trivial, \nespecially in the presence of non-lexically scoped locks, that sometimes analyses make optimistic approximations. \nAlso, this approach is usually limited to locks and other lock like synchronization idioms. Permission \nto make digital or hard copies of all or part of this work for personal or classroom use is granted without \nfee provided that copies are not made or distributed for pro.t or commercial advantage and that copies \nbear this notice and the full citation on the .rst page. To copy otherwise, to republish, to post on \nservers or to redistribute to lists, requires prior speci.c permission and/or a fee. PLDI 08, June 7 \n13, 2008, Tucson, Arizona, USA. Copyright c . 2008 ACM 978-1-59593-860-2/08/06. . . $5.00 e ::= x (variable) \n|n (integer constant) |let x = e1 in e2 (variable binding) |if * then e1 else e2 (branch) |while * do \ne (loop) |newtid (new thread identi.er) |spawn(e1){e2}(new thread) |join e (thread join) |ref e (new \nreference cell) |!e (reference read) |e1 := e2 (reference write) |newlock (new lock) |freelock e (free \nlock) |lock e (lock acquire) |unlock e (lock release) Figure 1. The syntax of the simple concurrent language. \nThis paper presents a different approach for statically checking race freedom. The key idea is to reduce \nthe race checking problem to a linear programming problem such that if there exists a solution to the \nconstructed linear programming instance, then the program is guaranteed to be race free. In contrast \nto previous approaches, our approach only needs standard may-aliasing information, and does not require \nlocksets and lock linearity/must-aliasness. By uti\u00adlizing ef.cient linear programming algorithms, we \nachieve both good theoretical computational complexity (polynomial in the size of the program), and good \npractical running times, without sacri.c\u00ading soundness. The approach can be extended to synchronization \nmethods beyond simple lock-based idioms. The prototype imple\u00admentation described in Section 3 handles \nprogramming idioms that other analyses often have dif.culties with, such as thread joining, semaphores, \nsignals, and read-write locks, as well as read only ac\u00adcesses and local accesses. The rest of the paper \nis organized as follows. Section 2 intro\u00adduces the key concepts with a toy language that contains only \nlocks and thread spawning/joining, and formally proves soundness. Sec\u00adtion 3 discusses the implementation, \nLP-Race, a tool for detect\u00ading races in multithreaded C programs. Section 4 discusses related work, Section \n5 discusses open issues, and Section 6 concludes.  2. Formal Aspects Figure 1 shows a simple .rst order \nexpression language (with side effects) we use to present the key concepts of the analysis. The language \nis minimized in ordered to focus on the novel aspects of the analysis. We brie.y describe the syntax. \nVariables are ranged over by meta variables x, x1, etc. The construct let x = e1 in e2 binds the result \nof evaluating e1 to x and evaluates e2.Wewrite e1; e2 for let x = e1 in e2 such that x is not free in \ne2. The language contains non-deterministic branches and loops. The let x = ref 0 in let x = ref 0 in \nspawn(newtid){!x}; let l = newlock in x:= 1 spawn(newtid){ (a) lock l; !x; let x = ref 0 in unlock l \n}; let t = newtid in lock l; spawn(t){!x}; x:= 1; join t; unlock l x:= 1 (c) (b) Figure 2. Simple race \n(a), and race avoidance via thread joining (b) and locking (c). F ::= t.E |F ||p |p||F E ::= let x = \nE in e |ref E |E := e |v := E |!E |lock E |unlock E |freelock E |spawn(E){e}|join E Figure 3. The evaluation \ncontexts construct spawn(e1){e2}creates a new thread to evaluate e2. Here, e1 is a thread identi.er that \ncan be used at join e to join threads. Multiple threads are allowed to have the same thread identi.er. \nThe language contains reference cells, that could be written and read concurrently. Finally, the language \ncontains syntax for creating, deleting, acquiring, and releasing locks. Figure 2 (a) shows a simple example \nprogram that contains a read write race. The spawned thread may read from the reference cell bound to \nthe variable x while the spawner thread writes to it. Such a race can be avoided by using locks, as shown \nin (c), or by using join to wait until the other thread .nishes, as shown in (b). 2.1 The Semantics We \nformally de.ne the semantics of the language. The semantics is de.ned as small-step reductions from states \nto states. A state is a quadruple (., ., ., p) where . is the set of currently allocated thread identi.ers, \n. is the current lock state, a mapping from the currently available locks to {U, L}where U denotes that \nthe lock is unlocked and L denotes that the lock is locked, . is a store mapping locations to values,and \np is a program state.Values, v, are de.ned as v ::= t |l |f |n where the symbol t ranges over thread \nidenti.ers, l ranges over locks, and f ranges over locations. A program state is de.ned as follows. e \n::= \u00b7\u00b7\u00b7|v p ::= t.e |p1||p2 Here, e is extended with values. Intuitively, an (extended) expres\u00adsion pre.xed \nby a thread identi.er, t.e, denotes a thread with the thread identi.ed by t whose current program counter \nis e, whereas p1 ||p2 denotes a parallel composition of threads. Therefore, a program state is a parallel \ncomposition of .nitely many expres\u00adsions pre.xed by thread identi.ers. We let the parallel composition \noperator ||be commutative and associative. We de.ne the following standard notational convention. Given \na mapping (i.e., a set-theoretic function) f, f [a .b] denotes the mapping {c .f(c) |c .dom(f) \\{a}}.{a.b}. \nFigure 3 de.nes evaluation contexts. Figure 4 shows the reduc\u00adtion rules. If1, If2, Loop,and Let are \nstraightforward. Note that because the language is an expression language, every expression If1 (., ., \n., F [if * then e1 else e2]) .(., ., ., F [e1]) If2 (., ., ., F [if * then e1 else e2]) .(., ., ., F \n[e2]) Loop (., ., ., F [while * do e)) . (., ., ., F [if * then (e; while * do e) else 0]) Let (., ., \n., F [let x = v in e]) .(., ., ., F [e[v/x]]) t/.dom(.) NewT (., ., ., F [newtid]) .(. .{t},.,.,F [t]) \nSpawn (., ., ., F [spawn(t){e}]) .(., ., ., F [0] ||t.e) Join (., ., ., F [join t] ||t.v) .(., ., ., \nF [0]) f/.dom(.) Ref (., ., ., F [ref v]) .(., ., .[f.v],F [f]) Read (., ., ., F [!f]) .(., ., ., F \n[.(f)]) Write (., ., ., F [f := v]) .(., ., .[f .v],F [0]) l/.dom(.) NewL (., ., ., F [newlock]) .(., \n.[l .U],.,F [l]) . = .' .{ll/) .U}.dom(.' FreeL (., ., ., F [freelock l]) .(., .',.,F [0]) .(l)= U Lck \n(., ., ., F [lock l]) .(., .[l .L],.,F [0]) Ulck (., ., ., F [unlock l]) .(., .[l .U],.,F [0]) Figure \n4. The operational semantics. needs to evaluate to a value if they terminate, and so we use 0 as the \nunit value for expressions that are evaluated purely for their effects. NewT creates a fresh thread identi.er. \nSpawn spawns a new thread using the given thread identi.er, and Join waits for a thread with the thread \nidenti.er to .nish. Ref allocates a new reference cell that can be read by Read andwrittenby Write. NewL \ncreates a new lock, initialized to unlocked status. If the lock is unlocked, Lck may acquire the lock, \nsetting the lock status to locked. Ulck releases the lock, setting the lock status to unlocked. FreeL \ndeletes a lock if the lock is unlocked1. We write (.1,.1,.1,p1) .* (.2,.2,.2,p2) for zero or more reduction \nsteps from the state (.1,.1,.1,p1) to the state (.2,.2,.2,p2). We now formally de.ne race freedom. 1 \nThis models pthread mutex destroy in the POSIX threads library. DEFINITION 2.1 (Race Freedom). Astate \n(.1,.1,.1,p1) is said to be race free if for any state (.2,.2,.2,p2) such that (.1,.1,.1,p1) .* (.2,.2,.2,p2), \np2 is not of the following form. F1[f := v1] ||F2[f := v2]  F1[f := v] ||F2[!f]  2.2 The Type System \nWe formulate the analysis as a type inference problem for a type system. The type system guarantees that \na typable program is race free. The types are de.ned as follows. t ::= ref(.,t)(reference cells) ||| \nint lock(.) tid(.) integers (locks) (thread identi.ers) The type ref(., t) denotes a type of a reference \ncell pointing to the abstract location ., storing a value of the type t. Symbols ., .1, etc. range over \ncapability mappings. A capability mapping is a function from abstract locations to non-negative rational \nnumbers [0, 8). Capability mappings denote access capabilities to abstract loca\u00adtions. Each thread holds \nsome amount of capabilities, representing the access capabilities of the thread. Intuitively, a thread \nholding ca\u00adpabilities . such that .(.) =1 is allowed to write to the abstract location ., and a thread \nholding capabilities . such that .(.) > 0 is allowed read from the abstract location . (thus the write \ncapabil\u00adity implies the read capability). The type system ensures that the to\u00adtal amount of capabilities \nsummed across all live threads is at most 1 for any abstraction location. This property ensures race \nfreedom as there cannot be two threads, say holding capabilities .1 and .2 respectively, such that one \nthread can write to an abstract location ., (i.e., .1(.) =1) while the other thread can read or write \nto it (i.e., .2(.) > 0), because then the total amount of capabilities for . would exceed 1. Threads \nmay transfer capabilities at synchronization points, which in this simple language, is when accessing \nlocks and spawn\u00ading and joining threads. The capabilities . appearing in a lock type lock(.) represents \nthe amount of capabilities transferred to the thread when acquiring the lock, and transferred from when \nre\u00adleasing the lock. The capabilities . appearing in a thread identi.er type tid(.) represents the amount \nof capabilities transferred to the joiner thread by joining a thread with the thread identi.er. Figure \n5 shows the type checking rules. The judgement are of the form G, .1, fe : t, .2 where G is a type environment \nmapping variables to their types, the pre-capability .1 is the capabilities be\u00adfore the evaluation of \ne,the post-capability .2 is the capabilities after the evaluation of e,and t is the type of e. VAR and \nINT are self-explanatory. LET, IF, WHILE make sure that capabilities are conserved (i.e., not created \nout of thin air) through the sequen\u00adtial .ow of computation. The inequality .1 =.2 is de.ned as ....1(.) \n=.2(.). Also, the subtraction of capabilities is de.ned point-wise as .1 -.2 = ....1(.) -.2(.). Note \nthat because the range of any capability mapping is restricted to non-negative rationals, the subtraction \nis unde.ned if the result is negative. Similarly, the addition of capabilities is de.ned as .1+.2 = ....1(.)+.2(.). \nNEWT, SPAWN,and JOIN type thread creation and thread joining. At SPAWN, the parent thread gives part \nof its capabilities, .3, to the newly created thread, and so .2 -.3 amount of capabilities are left for \nthe continuation of the parent thread. The capabilities that are left after the spawned thread .nishes, \n.4,or at least a part of it (.1), may be recovered by using the thread identi.er. At JOIN, the joiner \nthread gains capabilities from the joined thread through the thread identi.er. VAR INT G,. fx :G(x), \n.G, . fn : int, . G,. fe1 : t1,.1 G[x .t1], .1 fe2 : t2,.2 LET G,. flet x = e1 in e2 : t2,.2 G, . fe1 \n: t, .1 .1 =.3 G, . fe2 : t, .2 .2 =.3 IF G, . fif * then e1 else e2 : t, .3 G, .1 fe : t, .2 .2 =.1 \n. =.1 WHILE G,. fwhile * do e : int,.1 NEWT G,. fnewtid : tid(.1), . G, . fe1 : tid(.1),.2 G, .3 fe2 \n: t,.4 .4 =.1 SPAWN G, . fspawn(e1){e2}: int, .2 -.3 G, . fe : tid(.1), .2 JOIN G, . fjoin e : int, \n.1 +.2 G, . fe : t,.1 REF G,. fref e : ref(., t), .1 G, . fe1 : ref(.,t), .1 G, .1 fe2 : t, .2 .2(.) \n=1 WRITE G,. fe1 := e2 : int, .2 G, . fe : ref(., t),.1 .1(.) > 0 READ G, . f!e : t, .1 NEWL G, . fnewlock \n: lock(.1), . -.1 G, . fe : lock(.1), .2 FREEL G, . ffreelock e : int, .2 +.1 G, . fe : lock(.1), .2 \n LCK G, . flock e : int, .2 +.1 G, . fe : lock(.1), .2 ULCK G, . funlock e : int, .2 -.1 Figure 5. The \ntype checking rules. REF, WRITE,and READ type reference cell accesses. As remarked above, READ requires \na positive amount of capability for the abstract location, and WRITE requires capabilities at least 1. \nBecause there is no notion of lockset, these rules do not assert anything about which locks protect the \nreference cell. Note that READ naturally allows parallel reads (i.e., read-only accesses), because n \nthreads may each hold 1/n amount of capabilities for the same abstract location and still satisfy the \nat most 1 property. NEWL types lock creations. As remarked above, releasing a lock loses the amount of \ncapabilities associated with the lock. Because new locks are initialized to the unlocked state, we subtract \nthe capabilities as if the lock is unlocked. Dually, FREEL gets back the capability associated with the \nlock for destroying the lock. At LCK, the thread gains the capabilities, and at ULCK,the capabilities \nare lost. The simplicity of these rules may appear deceptive. Researchers familiar with lockset-based \nrace analysis might have expected to see a rule requiring the locks to be linear [20] (or must-alias \n[20]). A formal proof of correctness appears at the end of the section. To see how the type system avoids \nlinearity/must-aliasness require\u00adment, suppose the rule NEWL is replaced by the following un\u00adsound rule. \nNEWL-unsound G,. fnewlock : lock(.1),. Consider the following program. let x = ref 0 in let l1 = newlock \nin let l2 = newlock in spawn(newtid){ lock l1;!x; unlock l1 }; lock l2; x:= 1; unlock l2 The program \nhas a race on x because two threads concurrently access x (by holding different locks). However, with \nNEWL\u00adunsound, the program would type check (cf. De.nition 2.3) by assigning the type lock(.) to both \nl1 and l2 such that .(.)=1 where x has the type ref(.,int). NEWL prevents such a situation by making \nsure that capabilities (like . above) are not created out of thin air . In practice, this implies that \nif the type system cannot distinguish two locks that are alive at the same time such that at least one \nof them is used to guard some location, then the type sys\u00adtem may report a false positive because the \ntotal capability would exceed 1 at one of the lock allocation point. The locality extension discussed \nin Section 3.1.5 can soundly allow may-aliased live locks to be used to guard locations in some situations. \nWe now de.ne the notion of a well-typed state. We extend type environments so that they map values to \ntypes as well as variables. Non-integer values are typed by the following rule. G,. fv :G(v),. We de.ne \nthe notion of a well-typed store. DEFINITION 2.2 (Well-typed Store). We write G f. if for each f.dom(.), \nG,0 f.(f): t,0 where G(f)= ref(.,t) for some .. Here, 0 is the null capability, de.ned as 0 = ...0. Threads \nare typed by the following rule, which says that the capabilities left at the end of the thread is at \nleast the capabilities obtainable by joining the thread. G,. fe:.1 G(t)= tid(.2).1 =.2 G,. ft.e : int,0 \nLet cap(lock(.)) = .. Recall that any program state is a parallel composition of .nitely many threads, \nthat is, it is of the form t1.e1 ||t2.e2 ||... ||tn.en where nis the number of threads. DEFINITION 2.3 \n(Well-typed State). Let p = t1.e1 ||... ||tn.en such that there are no free variables in p. We write \nG f(.,.,.,p) if there exist .1,...,.n such that (1) For all t.., G(t) is a thread identi.er type. (2) \nFor all l .dom(.), G(l) is a lock type. (3) G f.. (4) For all i.{1,...,n}, G,.i fti.ei : int,0 . (5) \nLet U = {l |.(l)= U}.Let  n XX .= cap(G(l))+ .i l.Ui=1 Then ....(.) =1 The .rst three conditions ensure \nthat .,.,. are well-typed. The condition (4) states that all threads are well-typed. The condition (5) \nasserts that the total amount of capabilities summed across all P threads (i.e.., n .i) and the amount \nof capabilities obtainable i=1 P by acquiring locks (i.e., l.U cap(G(l))) is at most 1 for any abstract \nlocation. Well-typedness is preserved across reductions. LEMMA 2.4 (Preservation). Suppose G f(.1,.1,.1,p1) \nand (.1,.1,.1,p1) .(.2,.2,.2,p2). G f(.2,.2,.2,p2). Proof: By case analysis on the reduction. 0 Note \nthat the condition (5) of De.nition 2.3 implies that a well\u00adtyped state cannot have two threads such \nthat one thread is trying to write to a location and the other thread is accessing the same location. \nMore formally, LEMMA 2.5. Suppose pis of the form F1[f := v1] ||F2[f := v2] or F1[f := v] ||F2[!f]. Then \nfor no G, G f(.,.,.,p). The soundness of the type system follows from the above lemmas. THEOREM 2.6. \nSuppose G f(.,.,.,p).Then (.,.,.,p) is race free. Proof: Straightforward from Lemma 2.4, Lemma 2.5, and \nDe.ni\u00adtion 2.1. 0 The type system is inspired by research on fractional permis\u00adsions/capabilities. Fractional \npermissions were originally invented to guarantee determinism of multithreaded programs in the pres\u00adence \nof parallel reads [5]. The idea has been adopted in concurrent separation logic [3], and has also been \nused to statically check de\u00adterminism of channel communicating processes [21]. 2.2.1 Example Consider \nthe following example which spawns threads in a loop, and uses locks and joins to avoid races to the \nshared reference cells bound to x and y. let x = ref 0 in let y = ref 0 in let t = newtid in let l = \nnewlock in while * do spawn(t){letz= !y in lock l; x:= z; unlock l}; spawn(t){letz= !y in lock l; x:= \nz; unlock l}; join t; join t; y:= 1 Let e be the code above, and let p = t1.e. Consider the state ({t1},\u00d8,\u00d8,p).Let \n.1 = 0 [.x .1][.y .1].Thenwehave \u00d8,.1 f({t1},\u00d8,\u00d8,p), guaranteeing that Figure 2 (b) is race free. The \ntype derivation uses a type environment of the form {t1 .tid(0 ),x .ref(.x,int),y .ref(.y,int) t .tid(0 \n[.y .0.5]), l .lock(0 [.x .1])} to type check the main body of e. Note that the type of t indicates that \nthe spawned thread gets a fraction of the capability to access y in read-only mode, which is combined \nat joins so that the main thread can write to y after the threads .nish. The type of l indicates that \nthe spawned threads get the full (i.e., write) capability for x by acquiring l.  2.3 The Analysis Algorithm \nIntuitively, the analysis algorithm is a type inference algorithm for the type system presented in Section \n2.2. The analysis is separated in two phases. Informally, the .rst phase infers everything about the \ntype derivation except for the amount of capabilities. The second phase uses linear programming to check \nif there exist an assignment of capabilities that satis.es the capability constraints. .fresh a,.fresh \n.,. fx:.(x),.; \u00d8.,.fn: a,.; {a = int}.,. fe1 : a1,.1; C1 .,.2 fe2 : a2,.3; C2 .,. flet x = e1 in e2 : \na2,.3; C1 .C2 .{a1 =.(x),.1 = .2} ' '' .,.fe1 : a,.1; C1 .,. fe2 : a ,.1; C2 .,. fif * then e1 else \ne2 : a,.2; C1 .C2 .{a = a ' ,. = . ' ,.1 =.2,. ' 1 =.2}.,.1 fe: a,.2; Ca2,.fresh a,.,.1 fresh .,. fwhile \n* do e : a2,.1; C .{a2 = int,.2 =.1,. =.1}.,.fnewtid : a,.; {a = tid(.1)}.,. fe1 : a1,.2; C1 .,.3 fe2 \n: a2,.4; C2 a,.1,.5 fresh .,.fspawn(e1){e2}: a,.5; C1 .C2 .{a = int,a1 = tid(.1),.4 =.1,.5 = .2 -.3}.,. \nfe: a,.2; Ca1,.1,.1 fresh .,. fe: a,.1; Ca1,efresh .,.fjoin e : a1,.3; C .{a = tid(.1),a1 = int,.3 = \n.1 + .2}.,. fref e: a1,.1; C .{a1 = ref(e,a)}.,. fe1 : a1,.1; C1 .,.1 ' fe2 : a2,.2; C2 a,efresh .,. \nfe1 := e2 : a,.2; C1 .C2 .{a = int,a1 = ref(e,a2),.1 = .1' ,.2(e) =1}.,.fe: a,.1; Ca1,efresh a,.1,. ' \nfresh .,.f!e: a1,.1; C .{a = ref(e,a1),.1(e) >0}.,. fnewlock : a,. ' ; {a= lock(.1),. ' = .-.1}.,. fe: \na,.1; C .,. ffreelock e: a ' ,.3; C .{a ' = int,a = lock(.2),.3 = .1 + .2}.,. fe: a,.2; Ca1,.1,.3 fresh \n.,. flock e: a1,.3; C .{a= lock(.1),a1 = int,.3 = .2 + .1}.,. fe: a,.2; Ca1,.1,.3 fresh .,. funlock e \n: a1,.3; C .{a = lock(.1),a1 = int,.3 = .2 -.1} Figure 6. The type inference rules. 2.3.1 Phase 1 The \n.rst phase is mostly a standard uni.cation-based inference, generating capability constraints on the \nside. Figure 6 shows the constraint generation rules. Here, a s are type variables, e s are ab\u00adstract \nlocation variables, and . s are capability mapping variables. These rules are straightforward syntax-directed \ninference rules for the type rules from Figure 5. The inference judgement, .,.1 fe : a,.2; C, reads under \nthe environment ., e is inferred to have the type a, the pre\u00adcapability .1, the post-capability .2, with \nthe set of constraints C. For simplicity, we assume that let-bound variables are distinct. We initialize \n. to map each variable to a fresh type variable. We visit each AST node (i.e., expression) in a bottom \nup manner to build the set of constraints. The resulting set of constraints contains three kinds of con\u00adstraints: \n(a) Type uni.cation constraints: s = s ' . (b) Capability (in)equality constraints: f = f ' and f=f \n' . (c) Access constraints: .(e) =1 and .(e) > 0.  where s ::= a|ref(e,a) |int |lock(.) |tid(.) f::= \n.|f+ f |f-f The constraints of the kind (a) can be resolved by the standard uni.cation algorithm, which \nmay create more constraints the kind (b). In addition, it creates constraints of the form e1 = e2,which \ncan also be resolved by the standard uni.cation algorithm. This leaves us with a set of constraints of \nthe kind (b) and (c). Because we used simple types for the sake of exposition, the analysis algorithm \nmay fail at this point, for example, when the program uses integers as locks. We may reject the program \nat this point. But it is easy to extend the system with sum types and recursive types so that this phase \nnever fails. We take such an approach in the implementation described in Section 3. 2.3.2 Phase 2 The \nsecond phase of the algorithm .nds a satisfying solution to the remaining constraints generated in the \n.rst phase so that the pro\u00adgram is well-typed. We reduce the problem to linear programming as follows. \nLet e be the program being analyzed. Phase 1 returns pre-capability .e such that .,.e fe : t,. ' ; C \nfor some t,. ' and C. For each e(that is, its equivalence class obtained by the uni.ca\u00adtion in phase \n1), we instantiate a linear programming problem using the remaining constraints together with the constraint \n.e(e) =1. More precisely, each constraint mapping variables . is instanti\u00adated as a linear programming \nvariable .(e), and access constraints '' .(e ) =1 and .(e ) > 0 are removed from the constraints if e' \ne. We add constraints .(e) =0 for each . to ensure that = capabilities are non-negative. To apply linear \nprogramming algorithms that can only take non-strict inequalities such as the one implemented in GLPK \n[1], we add a fresh linear programming variable E and replace each .(e) > 0 with .(e) =E, and set the \nobjective function to be E.We ask the linear programming solver to .nd a solution that maximizes E. If \nthe solver returns a solution such that E> 0, then we accept the program as race free on the location \ne. Otherwise, we report a possible race on e. A write-write race is reported if the linear programming \nsolver cannot .nd any solution. A read-write race is reported if the linear programming solver .nds a \nsolution but E=0. 2.3.3 Analysis of the Algorithm We prove the correctness of the analysis algorithm. \nWe use the sym\u00adbol . to denote a constraint solution, which is a sorted substitu\u00adtion mapping type variables \nto types, abstract location variables to abstract locations, and capability mapping variables to capability \nmappings. A constraint solution becomes a mapping from s, ., and fin the obvious way. DEFINITION 2.7. \nWe write . |= C ( . solves C ) if for each s = s ' .C, .(s)= .(s ' ).  for each f =f ' .C, .(f) =.(f \n' ).  for each f = f ' .C, .(f)= .(f ' ).  for each f(e) =1 .C, .(f)(.(e)) =1.  for each f(e) >0 .C, \n.(f)(.(e)) > 0.  for each f(e) =1 .C, .(f)(.(e)) =1.  LEMMA 2.8. Suppose .,.1 fe : a,.2; C and . |= \nC. Then, .(.),.(.1) fe: .(a),.(.2). Proof: By induction on the type derivation. 0 THEOREM 2.9 (Soundness). \nSuppose .,.e fe : t,.; C and [ . |= {.e(e) =1}.C Let G= .(.).Let x1,...,xn be the free variables in \ne.Let v1,...,vn be such that G fvi :G(xi) for each vi.Let ., ., . be such that . .dom(.) .dom(.) .Z .{v1,...,vn}, \nG f., and .(l)= L for each l .dom(.).Let t/... Then, ({t}..,.,.,t.e[v1/x1] ...[vn/xn]) is race free. \nProof: Straightforward from Lemma 2.8 and Theorem 2.6. 0 We argue the theoretical computational complexity \nof the anal\u00adysis algorithm. The instance of linear programming problem in phase 2 can be solved in time \npolynomial in the size of the con\u00adstraints by algorithms such as interior points methods. Therefore, \nthe complexity of the algorithm is polynomial in the time phase 1 takes to generate the capability constraints, \nwhich is polynomial in the size of the program for our simple language. Therefore, the complexity of \nthe analysis algorithm is polynomial in the size of the program. In general, the complexity will increase \nif we include more com\u00adplex programming constructs such as data structures and higher or\u00adder functions \nif we stick with the simple types. But this can be avoided by incorporating recursive types, as is done \nin the LP-Race implementation.   3. LP-Race We have implemented a prototype of the analysis algorithm, \nLP-Race, a tool for detecting races in C programs. LP-Race uses CIL [19] as a front-end to parse C .les \nand handles the full-set of C. 3.1 Handling C Features LP-Race extends the analysis framework to handle \nC features not covered in the formalism detailed in Section 2. This includes structs and unions, functions, \nand synchronization methods such as signal\u00ading and semaphores. This section highlights some of the notable \nextensions. 3.1.1 Alias Analysis C programs use pointers and arrays extensively. To generate a sen\u00adsible \nset of abstract locations, LP-Race performs points-to analysis and use the computed may-alias sets as \nabstract locations. For the prototype implementation, we choose one-level-.ow analysis [6, 7] (with optimistic \n.eld sensitivity2), which is fast and known to pro\u00adduce good alias sets in practice. In principle, any \nmay alias analysis can be used to obtain abstract locations. As remarked earlier, LP-Race uses sum types \nand recursive types so that the .rst phase of the analysis never fails. This allows, among other things, \nLP-Race to report all single-threaded C pro\u00adgrams to be race free. 3.1.2 Generic Control Flow C contains \nunstructured control .ow such as gotos and breaks. To handle generic control .ow, LP-Race uses CIL to \ngenerate a control .ow graph for each function, and associate a fresh capability for each node in the \ncontrol .ow graph. Then, for each successor node b of a node a, LP-Race adds the constraint .a =.b where \n.a is the capability associated with aand .b is the capability associated with b. 3.1.3 Functions Because \nthreads are typically created using function pointers, han\u00addling .rst class functions is crucial for \nanalyzing multithreaded C programs. We extend the type system with function types of the form t ::= \u00b7\u00b7\u00b7|(.pre,Tt) \n.(.post ,tret ) where Tt are the arguments types (the notation Ta denotes a se\u00adquence), and tret is the \nreturn type. Intuitively .pre is the capa\u00adbility that the caller of the function must be holding, and \n.post is the capability that can be returned to the caller when the function returns. .pre is taken from \nthe entry node of the function body, and .ret is the solution for the capability variable .ret such that \nfor each return node ain the function, LP-Race adds the constraint .a =.ret where .a is the capability \nassociated with a. LP-Race type check function calls by the following rule. G,. fe :(.pre ,t1,...,tn) \n.(.post ,tret ),.1 .i .{1,...,n}.(G,.i fei : ti,.i+1) .n+1 =.pre +.keep G,. fe(e1,...,en): tret ,.post \n+.keep Here, .n+1 is the capability held by the caller just before entering the function. Note that only \na part of .n+1,thatis .pre, needs to be given to the function. The remaining capabilities, .keep is kept \nby the caller and combined with the return capability of the function. This capability .ow around technique \nprovides context sensitivity as each call site can use a different .keep to avoid con.ating capabilities. \nThe .ow around technique is inspired by similar ideas used in Cqual [12] and Locksmith [20]. However, \nunlike Cqual or Lock\u00adsmith, LP-Race does not require an effect analysis to determine 2 The .elds of a \nstruct/union are allowed to have different types and abstract locations. what to give to the function \nand what to keep, because the .ow around relation becomes just an additional set of linear equations \nso that linear programming automatically discovers what to .ow around. Also, it is more general because \nit allows fractional amount of capabilities to be .own around. Polymorphic Function Signatures A polymorphic \n(i.e., a context sensitive) alias analysis [8, 7, 23, 14] can be used to generate polymorphic types for \nfunctions. That is, we can quantify function types by abstract locations so that functions are given \ntypes of the form .T,T ..(.pre t) .(.post ,tret ) This allows us to type check situations requiring parametric \npoly\u00admorphism, as in the code below. int c, d; pthread_t tid1, tid2; void *f(void *p) { *p=1; } void \nmain(void) { pthread_create(&#38;tid1, NULL, &#38;f, &#38;c); pthread_create(&#38;tid2, NULL, &#38;f, \n&#38;d); } Currently, LP-Race uses monomorphic one-level-.ow analysis and so polymorphic function signatures \ncannot be obtained. We leave extending LP-Race with polymorphic function signatures for future work. \n 3.1.4 Synchronization Primitives As remarked earlier, our analysis approach is not limited to locks. \nHere, we discuss other kinds of synchronization primitives LP-Race handles. Signaling Perhaps the simplest \nform of synchronization is to send a signal from one thread to another thread waiting for a signal. For \nexample, POSIX threads programs use conditional variables for signaling. LP-Race gives signal primitives \nlike a conditional variable the type of the form sig(.) so that a send of a signal is typed as follows. \nG, . fe : sig(.1), .2 G, . fsend e : int, .2 -.1 And a wait on a signal is typed as follows. G, . fe \n: sig(.1), .2 G, . fwait e : int, .2 +.1 Semaphores Semaphores are straightforward to handle in our framework. \nA semaphore is given the type of the form sem(.). A post of a semaphore is typed as follows. G, . fe \n: sem(.1), .2 G, . fV e : int, .2 -.1 A wait on a semaphore is typed as follows. G, . fe : sem(.1), .2 \nG, . fP e : int, .2 +.1 Unlike a lock release, a post of a semaphore is not idempotent. For example, \na race must be reported in the following situation. int c; pthread_t tid1, tid2; sem_t sem; void *f(void \n*) { sem_wait(&#38;sem); c=1; } void main(void) { sem_init(&#38;sem, 0, 0); pthread_create(&#38;tid1, \nNULL, &#38;f, &#38;c); pthread_create(&#38;tid2, NULL, &#38;f, &#38;c); sem_post(&#38;sem); sem_post(&#38;sem); \n} It is not dif.cult to prove that type system is sound for semaphores with their usual semantics of \na post incrementing a counter and a wait waiting for a counter to be positive and then decrementing the \ncounter.3 We omit the details for space. Read-Write Locks LP-Race models read-write locks when the upper \nbound on the number of live threads are known. Read-write locks are given types of the form rwlock(.r, \n.w). The type rules for read-write lock acquires and releases are much like those of regular locks, except \nthat .w is used in write mode and .r is used in read-only mode. .r =.w/N G, . fnewrwlock : rwlock(.r, \n.w), . -.w G, . fe : rwlock(.r, .w), .1 G, . frdlock e : int, .1 +.r G, . fe : rwlock(.r, .w), .1 G, \n. frdunlock e : int, .1 -.r G, . fe : rwlock(.r, .w), .1 G, . fwrlock e : int, .1 +.w G, . fe : rwlock(.r, \n.w), .1 G, . fwrunlock e : int, .1 -.w Here, newrwlock creates a new read write lock, rdlock e (rdunlock \ne) acquires (releases) the read-write lock e in read\u00adonly mode, and wrlock e (wrunlock e) acquires (releases) \nthe read-write lock e in write mode. In the rule for newrwlock, N is the upper bound on the number of \nthreads. For instance, if a read-write lock l is used to guard an abstract location ., then the type \nof l would be of the form rwlock(.w, .r) such that .w(.) =1. Obtaining a read lock grants .r(.) =.w(.)/N \namount of capability, which could be less than 1, but is enough to do a read (i.e., greater than 0). \nIt is easy to prove that this scheme is sound when the program spawns at most N threads. 3 This actually \nimplies that the type rule for unlock is somewhat conser\u00advative for double unlocking. However, unlocking \nan already unlocked lock is often considered a bug and has unde.ned behavior in many thread li\u00adbrary \nspeci.cations. Issues on recursive locking and unlocking is discussed further in Section 5. App Size \nLP Instances Warnings Time aget ctrace smtprc retawq 2.2 2.2 9.0 52.3 40 24 85 605 15 12 42 14 4 5 145 \n6855 Table 1. Experiment results. 3.1.5 Local Accesses Consider the following program. pthread_t tid1, \ntid2; pthread_mutex_t lock; void *g(void *q) { pthread_mutex_lock(&#38;lock); *q=*q+1; pthread_mutex_unlock(&#38;lock); \n } void *f(void *) { int*p= malloc(sizeof(int)); *p=1; pthread_mutex_init(&#38;lock, NULL); pthread_create(&#38;tid1, \nNULL, &#38;g, p); pthread_create(&#38;tid2, NULL, &#38;g, p); } void main(void) { pthread_create(&#38;tid1, \nNULL, &#38;f, NULL); pthread_create(&#38;tid2, NULL, &#38;f, NULL); } The memory region allocated in \nthe function f is used only in\u00adside the function (which include threads spawned by the function). To \ncheck that such local uses of memory regions are race free, LP-Race performs an escape analysis to determine \nif an abstract location escapes through globals or the function arguments or re\u00adturns. Suppose e does \nnot escape. Then, LP-Race adds the con\u00adstraint .pre(e) =1 where .pre is the capability at the entry of \nthe function, and removes the constraints of the form .(e) =.pre(e). This allows functions to use the \nlocally allocated locations in a race free manner. 3.1.6 Subtyping LP-Race takes advantage of the one-level-.ow \npoints-to analysis framework to do one level of subtyping (types are uni.ed under pointers). We show \nthe subtyping rules for lock types. LP-Race extends the lock type to lock(.in, .out) such that .in is \nused at LCK and .out is used at NEWL and ULCK. We assert .out =.in,and use the following subtyping rule. \n.in =. ' in .out =. ' out lock(.in, .out) =lock(. ' out) in, . ' The idea is inspired by the read-type \nwrite-type separation for subtyping reference cells. We type other synchronization primitives similarly. \nThis has the effect of reducing false-aliasing of locks.  3.2 Experiments LP-Race is implemented in \nOCaml. LP-Race uses CIL 1.3.6 [19] as the frontend parser, and GLPK 4.2.1 [1] as the backend linear programming \nsolver. In general, any tool capable of solving a system of rational linear inequalities can be used \nas the backend. The code was compiled using OCaml 3.08 and gcc 3.4.4. The experiments were run on a PC \nwith a Intel T7200 2GHZ processor with 2GB of RAM, running Cygwin inside Windows XP. We ran LP-Race on \nseveral POSIX threads applications. We chose three benchmarks from the Locksmith paper [20], aget, ctrace \nand smtprc, mainly to check that the results from LP-Race agree with their .ndings, and also tried a \nlarger application, retawq, a multithreaded webserver, to see how LP-Race scales to larger code base. \nTable 1 summarizes the results. The size column is the number of kilo lines of code after CIL merges \nthe preprocessed application .les and .lters out duplicate or unused de.nitions. The time column is in \nseconds. The warnings column shows the number of possible races reported. It is worth noting that the \nwarning counts are sensitive to the underlying alias analysis. LP-Race currently distinguishes possible \nraces by alias sets only (after removing duplicates), therefore, for instance, if we had used a very \ncoarse alias analysis that returns a single alias set containing all locations, then the analysis would \nalways report at most one warning. Also, with this method, even if there are multiple races on the same \nalias set, only one warning is reported. Section 5 discusses issues regarding error reporting. We reviewed \nthe error reports. For aget, LP-Race was able to de\u00adtect the races reported in [20]. For ctrace, LP-Race \ndetects the two races reported in [20]. In addition, it reports ten false positives. Ex\u00adamining these \nfalse positives, as pointed out in [20], some appeared to be due to semaphores. While LP-Race can handle \nstandard semaphore uses, ctrace contains a manual read-write semaphore implemented with a counter, which \nLP-Race is not able to handle. Replacing this manual read-write semaphore with LP-Race s read\u00adwrite lock \neliminated four false positives. The other false positives are related to the unused lock problem discussed \nin Section 5, and accesses to a global array indexed by thread identi.ers. We also ob\u00adserved that the \nhandling of join was necessary for eliminating one false positive. For smtprc, many of the warnings are \nfalse read-write races reported due to loops spawning unbounded number of threads (cf. Section 5). Manually \nunrolling the loops twice eliminates 19 false positives. The other false positives are due to accesses \nto a global data structure indexed by thread identi.ers. We noticed that smtprc dangerously releases \na lock in a loop, which, according to the POSIX threads speci.cation, has unde.ned behavior. Such lock \nreleases could lead to a race if a thread can release a lock that other threads are holding (though this \nis implementation dependent). LP-Race correctly reports warnings for such situations thanks to the conservative \nhandling of recursive unlocks. For retawq, many of the warnings appear to be false positives caused by \nfalse aliasing of locations returned by memory allocation wrapper functions. One warning appears to be \na race, though seemingly benign. 3.2.1 Discussion The backend of LP-Race, which dominates the running \ntime, is em\u00adbarrassingly parallel. The backend solves one linear programming instance per an alias set \ncontaining a possibly thread shared loca\u00adtion. The third column of Table 1 shows the number of instances \ncreated, after some .ltering to remove redundant instances. Each linear programming instance is nearly \nthe same size for the same code base and can be solved independently of the others. Therefore, by solving \neach instance in parallel, in theory, we should get near N times speedup with N parallel processors for \napplications with more than N alias sets. Also, because the running times are dominated by the backend, \nthe choice of the linear programming solver may affect the perfor\u00admance. We chose GLPK mostly out of \nconvenience 4,but GLPK is by no means the fastest linear programming solver. Running times often differ \nby several orders of magnitude across different 4 We based the implementation on a partial OCaml interface \nfor GLPK [15]. solvers [16]. We leave experimenting with other linear program\u00adming solvers for future \nwork.  4. Related Work Many static race analyses focus on lexically-scoped locking pat\u00adternssuchasthe \nsynchronized blocks in Java. The essence of lexically-scoped locking patterns can be cleanly captured \nas a lockset-based analysis based on the classical type and effect sys\u00adtem. Early systems [9, 10, 13, \n4] required the users to supply an\u00adnotations, whereas more recent work [2, 11, 18, 17] infer locksets \nautomatically by utilizing powerful reasoning techniques such as binary decision diagrams and SAT solvers. \nA lockset-based analysis for non-lexically scoped locks is said to require .ow-sensitivity to infer locks \nheld at each program point [20, 22], and considered more dif.cult than that for lexically scoped locks. \nLike lockset-based analyses for scoped locks, these analyses are usually limited to locks and lock-like \nsynchronization patterns. An issue with handling non-lock synchronization patterns like semaphores and \nsignals is that it is ok for another thread to release a semaphore that another thread has acquired , \nwhile such a behavior is uncommon for locks.5 Also, unlike that for scoped locks that has a straightforward \nformalization as a type and effect system, a lockset-based analysis for non-scoped locks are rarely formalized \nand proven sound.6 This paper gives a simple formalization of non-scoped locks (as well as other synchronization \npatterns) in terms of capabilities. Locksmith [20] is a lockset-based analysis that introduces the notion \nof correlation analysis to reason about non-scoped locks used in a context sensitive manner. Relay [22] \nis a lockset-based analysis for non-scoped locks that has been applied to a much larger code base (millions \nof lines) than the applications we analyzed with LP-Race. To scale to such a large code base, they parallelize \nthe analysis to utilize a cluster of high performance machines. As remarked in Section 3.2, LP-Race should \nalso bene.t from parallel computation. We leave implementing parallelized LP-Race for future work. Both \nRelay and Locksmith employ a number of techniques to trade unlikely sources of unsoundness for precision \nor speed, such as optimistic thread-sharedness assumptions and using C types to re.ne aliasing. Such \ntechniques are important for analyzing large\u00adscale real-world programs. Many of such techniques affect \nonly the may alias part of the analysis, and therefore, they should also be adaptable to our framework. \nThe technique to reduce a static analysis problem to linear pro\u00adgramming may be of independent interest. \nThe approach was in\u00adspired by the idea of fractional permissions/capabilities, originally proposed by \nBoyland [5] as a way to allow parallel reads while guaranteeing determinism. The idea has been used to \nreason about concurrent reads in separation logic [3], and also to check deter\u00adminism of channel communicating \nprocesses [21]. This paper is the .rst application of the fractional permissions/capabilities idea to \nreal world programs. 5. Open Issues We identify the limitations of the current analysis system. We address \neach issue and describe possible remedies. The analysis does not handle recursive locks because it assumes \nthat a thread blocks when trying to acquire a lock that is already held, regardless of who holds the \nlock. Therefore. If this condi\u00ad 5 In fact, many threads libraries, including POSIX threads, condemns \nsuch idioms as erroneous. 6 The Locksmith paper [20] formalizes by assuming that each access is annotated \nwith the held locks. tion is violated, it is easy to construct a program that gains an in\u00advalid amount \nof capabilities (i.e., greater than 1) by acquiring the same lock multiple times. Effect-based approaches \n[9, 10, 13, 4] can naturally express Java-style lexically-scoped recursive locks. Effectively handling \nnon-scoped recursive locks is an open issue [22]. One limitation that seems unique to our analysis (and \npossibly to others based on the permissions/capabilities idea) occurs when a program spawns an unbounded \nnumber of live threads in a loop. This implies that either the created threads start with no capability, \nor the loop head has an in.nite amount of capabilities (which is invalid for any program locations that \nare reachable). In practice, this makes the analysis report some read-only access as a possible read-write \nrace. For example, a false race is detected in the program below. let x = ref 0 in while * do spawn(newtid){!x \n} Currently, we unroll thread allocating loops manually when LP-Race reports a false read-write race. \nA related issue is locks created early. The key argument used to prove soundness is to interpret locks \nand other lock-like prim\u00aditives to be storing the capabilities in their unlocked state (cf. De.nition \n2.3). Therefore, once a lock is created, the capabilities stored in the lock can prevent a thread from \naccessing the loca\u00adtions guarded by the lock even when there is no contention on the locations. In particular, \nthis makes some thread-local accesses un\u00adtypable, as shown below. let x = ref 0 in let l = newlock in \nx:= 1; spawn(newtid){lock l; x:= 0; unlock l} spawn(newtid){lock l; x:= 0; unlock l} Here, l must hold \nthe full (i.e., 1) capability for x so that the spawned threads can write to x. But this implies that \nx:= 1 is not typable because l is at an unlocked state at that point. A similar issue appears when accesses \nare made when the lock is no longer used (but before the lock is explicitly destroyed). Currently, we \n.x such situations by manually moving lock allocation/deletion points or by inserting a lock acquire/release \npair around the unguarded access. A more principled remedy is to infer program points that can acquire \na lock without contention, and allow such program points to use the capabilities stored in the lock without \nactually acquiring the lock. Another issue with our approach is error reporting. Because the analysis \ndoes not compute locksets, LP-Race does not give a feedback containing held locks at each program location \nwhen it detects a possible race. This can make analyzing false positives somewhat inconvenient. Currently, \nLP-Race reports the program location and the kind (i.e., a read or a write) of accesses made to the abstract \nlocation that failed the check, and whether the error is a possible write-write race or is a read-write \nrace. How to concisely represent the reason for the race (or a false positive) is an important issue \nin race analysis. One approach that may work well with LP-Race is an interactive debugging interface \nin which the user speci.es a subset of reported accesses as race free so that LP-Race re-solves the linear \nprograming instance for that location with the reduced accesses. With such a strategy, we can avoid re-running \nthe entire analysis from scratch. 6. Conclusions We have presented a new static analysis for race freedom \nthat re\u00adduces the problem to linear programming. The analysis is quite different from more traditional \nanalyses and does not require com\u00adputation of locksets nor lock linearity/must-aliasness. The analy\u00adsis \nhas a straightforward formalization as a permissions/capabilities system, and enjoys bene.ts such as \nbeing able to handle a variety of synchronization primitives. The preliminary experiment reports encouraging \nresults analyzing small to medium size multithreaded C programs.  References [1] GNU Linear Programming \nKit. http://www.gnu.org/software/glpk/glpk.html. [2] R. Agarwal and S. D. Stoller. Type inference for \nparameterized race-free Java. In Veri.cation, Model Checking, and Abstract Inter\u00adpretation, 5th International \nConference, VMCAI 2004, Proceedings, pages 149 160. [3] R. Bornat, C. Calcagno, P. W. O Hearn, and M. \nJ. Parkinson. Permission accounting in separation logic. In Proceedings of the 32nd Annual ACM SIGPLAN-SIGACT \nSymposium on Principles of Programming Languages, pages 259 270, Long Beach, California, Jan. 2005. [4] \nC. Boyapati, A. Salcianu, W. Beebee, Jr., and M. Rinard. Ownership types for safe region-based memory \nmanagement in real-time Java. In Proceedings of the 2003 ACM SIGPLAN Conference on Programming Language \nDesign and Implementation, San Diego, California, June 2003. [5] J. Boyland. Checking interference with \nfractional permissions. In Static Analysis, Tenth International Symposium, pages 55 72, San Diego, CA, \nJune 2003. [6] M. Das. Uni.cation-based pointer analysis with directional assignments. In Proceedings \nof the 2000 ACM SIGPLAN Conference on Programming Language Design and Implementation, pages 35 46, Vancouver \nB.C., Canada, June 2000. [7] M. Das, B. Liblit, M. F\u00a8 ahndrich, and J. Rehof. Estimating the impact of \nscalable pointer analysis on optimization. In Static Analysis, Eighth International Symposium, pages \n260 278, Paris, France, July 2001. [8] M. F\u00a8ahndrich, J. Rehof, and M. Das. Scalable context-sensitive \n.ow analysis using instantiation constraints. In Proceedings of the 2000 ACM SIGPLAN Conference on Programming \nLanguage Design and Implementation, pages 253 263, Vancouver B.C., Canada, June 2000. [9] C. Flanagan \nand M. Abadi. Types for safe locking. In D. Swierstra, editor, 8th European Symposium on Programming, \nvolume 1576 of Lecture Notes in Computer Science, pages 91 108, Amsterdam, The Netherlands, Mar. 1999. \nSpringer-Verlag. [10] C. Flanagan and S. N. Freund. Type-based race detection for Java. In Proceedings \nof the 2000 ACM SIGPLAN Conference on Programming Language Design and Implementation, pages 219 232, \nVancouver B.C., Canada, June 2000. [11] C. Flanagan and S. N. Freund. Type inference against races. In \nStatic Analysis, Eleventh International Symposium, pages 116 132, Verona, Italy, August 2004. [12] J. \nS. Foster, T. Terauchi, and A. Aiken. Flow-sensitive type quali.ers. In Proceedings of the 2002 ACM SIGPLAN \nConference on Programming Language Design and Implementation, Berlin, Germany, June 2002. [13] D. Grossman. \nType-safe multithreading in Cyclone. In Proceedings of the 2003 ACM Workshop on Types in Language Design \nand Implementation, pages 13 25, New Orleans, Louisiana, Jan. 2003. [14] J. Kodumal and A. Aiken. The \nset constraint/c. reachability connection in practice. In Proceedings of the 2004 ACM SIGPLAN Conference \non Programming Language Design and Implementation, pages 207 218, Washington DC, USA, June 2004. [15] \nS. Mimram. ocaml-glpk. http://ocaml-glpk.sourceforge.net/. [16] H. Mittelmann. Benchmarks for optimization \nsoftware. http://plato.asu.edu/bench.html. [17] M. Naik and A. Aiken. Conditional must not aliasing for \nstatic race detection. In Proceedings of the 34th Annual ACM SIGPLAN-SIGACT Symposium on Principles of \nProgramming Languages, pages 327 338, Nice, France, Jan. 2007. [18] M. Naik, A. Aiken, and J. Whaley. \nEffective static race detection for Java. In Proceedings of the 2006 ACM SIGPLAN Conference on Programming \nLanguage Design and Implementation, pages 308 319, Ottawa, Ontario, Canada, June 2006. [19] G. C. Necula, \nS. McPeak, S. P. Rahul, and W. Weimer. CIL: Intermediate language and tools for analysis and transformation \nof c programs. In Compiler Construction, 11th International Conference, pages 213 228, Grenoble, France, \nApr. 2002. [20] P. Pratikakis, J. S. Foster, and M. W. Hicks. LOCKSMITH: context\u00adsensitive correlation \nanalysis for race detection. In Proceedings of the 2006 ACM SIGPLAN Conference on Programming Language \nDesign and Implementation, pages 320 331, Ottawa, Ontario, Canada, June 2006. [21] T. Terauchi and A. \nAiken. A capability calculus for concurrency and determinism. In Concurrency Theory, 17th International \nConference, volume 4137, pages 218 232, Bonn, Germany, Aug. 2006. [22] J. W. Voung, R. Jhala, and S. \nLerner. RELAY: static race detection on millions of lines of code. In Proceedings of the 6th joint meeting \nof the European Software Engineering Conference and the ACM SIGSOFT International Symposium on Foundations \nof Software Engineering, pages 205 214, Dubrovnik, Croatia, Sept. 2007. [23] J. Whaley and M. S. Lam. \nCloning-based context-sensitive pointer alias analysis using binary decision diagrams. In Proceedings \nof the 2004 ACM SIGPLAN Conference on Programming Language Design and Implementation, pages 131 144, \nWashington DC, USA, June 2004. \n\t\t\t", "proc_id": "1375581", "abstract": "<p>We present a new static analysis for race freedom and race detection. The analysis checks race freedom by reducing the problem to (rational) linear programming. Unlike conventional static analyses for race freedom or race detection, our analysis avoids explicit computation of locksets and lock linearity/must-aliasness. Our analysis can handle a variety of synchronization idioms that more conventional approaches often have difficulties with, such as thread joining, semaphores, and signals. We achieve efficiency by utilizing modern linear programming solvers that can quickly solve large linear programming instances. This paper reports on the formal properties of the analysis and the experience with applying an implementation to real world C programs.</p>", "authors": [{"name": "Tachio Terauchi", "author_profile_id": "81100563652", "affiliation": "Tohoku University, Sendai, Japan", "person_id": "P1022829", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1375581.1375583", "year": "2008", "article_id": "1375583", "conference": "PLDI", "title": "Checking race freedom via linear programming", "url": "http://dl.acm.org/citation.cfm?id=1375583"}