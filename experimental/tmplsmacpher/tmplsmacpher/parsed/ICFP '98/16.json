{"article_publication_date": "09-29-1998", "fulltext": "\n Lazy Compdation with Exact Inca! Numbers* Abhas Edalat Peter John Potts Ptliliyp Siinderhanf Department, \nof Computing, Imperial College, 180 Queen ~ C&#38;e, London SW7 2BZ, UK {a.edalat,p.potts,p.sunderhauf}@doc.ic.ac.uk \nAbstract We provide a semantical framework for exact real arithmetic using linear fractional transformations \non the extended real line. We present an extension of PCF with a real type which introduces an eventually \nbreadth-first strategy for lazy eval- uation of exact real numbers. In this language, we present the \nconstant r&#38;ndant if, rif, for defining functions by cases which, in contrast to parallel if (pif), \novercomes the prob- lem of undecidability of comparison of real numbers in finite time. We use the upper \nspace of the one-point compactifi- cation of the real line to develop a denotational semantics for the \nlazy evaluation of real programs. Finally two ad- equacy results are proved, one for programs containing \nrif and one for those not containing it. Our adequacy results in particular provide the proof of correct.ness \nof algorithms for computation of single-valued elementary functions. Introduction It is well known that \nthe accumulation of round-off errors in floating point programs can lead to grossly incorrect numer-ical \nresults which in general are impossible to estimate 123. This problem, with all its implications, has \nremained the main unresolved issue in computer arithmetic. Two main approaches have been proposed for \nexact real arithmetic as an alternative to floating point: The first, introduced by Vuillemin [20], uses \nredundant contin-ued fractions to represent real numbers and has been imple- mented by Lester [lo]. The \nother approach, by Boehm and Cartwright, uses redundant sequences of R-adic numbers to represent reals \nand has been implemented by Menissier- Morain [II]. There has been no attempt to provide proper semantics \nfor either of the two frameworks. In fact, there are no proofs of correc-t.ness of algorithms in the \nformer and the lack of semantics in the latter makes it very hard to check the various ad hoc proofs \nfor the correctness of the algorithms given in [ll]. .4 new framework for exact real computation has \nbeen introduced in 115, 61 in which a real number is given by the intersection cji ii nested sequenc \ne of rational intervals ob- tained by appl+ng a sequence of composition of linear frac- tional transfor~~l \n- b ons (lft s), rquivalently matrices, with in- teger coefficients to the base interval [O,co]. This \nprovides a redu:-,dant. rt~pr<~sentation of a real number by a product of matrices, called a normal \nproduct. A complete set of ef- ficient on-line algorithms for elementary functions in this setting has \nI)cen provided in [13] and implemented in Caml. It has the distinguishing features that it is incremental \n(i.e. to obtai.1 ir ~(JTV accurate result one only needs to proceed with con~puta~ion at the previous \nstage) and also includes rational aritlir.~r:ic. In [Ia] fol~c:~~i~~g Scott s suggestion in [17] and \nthe work in 14, lij, a;) extension of PCF [lS, 121, with a real num-ber data rype, I)a:+ecl on the domain \nof intervals, was pre-sented to give a &#38;notational semantics to this lft framework. However, there \nare two essential restrictions here: Firstly, it only applies to computation on the non-negative reals \nwhich greatly simplifies the framework as one only needs to work with matrices with non-negative integer \ncoefficients. Sec-ondly, it uses norl-deterministic reduction rules. In this set-ting, it v:as proved \nthat an evaluation branch which produces the correct rf?:ulr must exist hllT no effective strategy was \npresent&#38;. In [15, :5 . :-!~? lft framework was extended to the ex-tended T-U! !il c\\ JY as follows: \nThe leading matrix in a normHl l!roduc~t., c,alled a sign matrix, has arbitrary integer coefficicn!::. \nT1:c sign matrix determines an interval of Woo while the suhscquent so called digit matrices, with all \nnon-negative or all non-positive entries successively refine this interval to th!a rcsal number in question. \nIn the present pa-per, we nrsT give a semantics to t.his framework. We present an extel:+ior: I.?I!H.@ \n(Language for Computable Real Func-tions) (6 I- /ii; n,:th a real type which has deterministic re-duction \nr:llc:: f:!ving an eventually breadth-first strategy for lazy evamatic!r! <)f exact real numbers. In \nthe operational semantics, :nc I:Iz:\\. deterministic strategy allows us to con-venieI&#38;l:l:; c,t+i,l,: \n&#38;al(P)(n) as the nth interval in the output of the re:\\l progr,:(m P. LC) ; F is eql:ipped with the \nconstant redundant if, rif, which g~ncralizcs the quasi-relational comparison operator << with tolerance \nc in [3, page 471 and which allows us to define a function over the whole of the extended reals by dividing \nits c:ijn,ain to, say, two overlapping intervals that cover R,- . it i.5 ,Iecidahle in finite time that \na real number lies in cxt:c of t ? :ic intervals. If the function is single-valued then its ~,aiuc il~i \n-a-he overlap coincides in the two branches of rif anti w: ar :r!)lc to compntc the function thanks to \nthe b, bl -1 Figure 1: Stereographic projection of the extended redundancy of our representation. In \nthis way, rif can be regarded as a redundant version of pif used in 14, 7] which, in contrast to pif, \novercomes the problem of undecidability of comparison of real numbers in finite time. We use, for the \nfirst time in semantics of programming languages, the upper space UR (the non-empty compact subsets of \nIwoo with reverse inclusion), defined for general topological spaces in [19] and proposed as a computational \nmodel for Hausdorff spaces in [5], to develop a denotational semantics for LCRF. In fact, the semantics \nof rif relies on the existence of the infimum of two approximate reals and this infimum does not exist \nin the domain IEP of intervals of IP. Moreover URw is, in contrast to IIF?, a continuous Scott domain \nwhich provides a convenient setting for our semantics. We finally prove two adequacy results. The first \napplies to all programs which do not contain rif. The other adequacy result applies to an inductively \ndefined class of so called basic real programs which contain rif and include real programs for all single-valued \nelementary functions. 2 Preliminaries We denote with BP = Iw U {co} the one point compactifica-tion of \nthe real line. Furthermore, we define for ca, b E IP the closed intenjal from a to 6 by [u, b] = {z E \nIR 1 a 5 2 5 b} for a 5 band [a,b] = {ca}U{z E R 1 z 5 b}U{z E lw 1 a < x} for b < a. So [l, -11 denotes \nthe complement of the open interval (-1,l) in W . If IIP is represented by the unit circle S1 in the \nusual way using the stereographic projec-tion, these intervals correspond to arcs going anti-clockwise \nfrom u to b, see Figure 1. The arithmetic operations are extended to Woo in the usual manner, i.e. x \n+ 03 = co + z = 00 -x = z -cc = 00 forx#ooandx~oo=oo~z=~forz#Oaswellas~=O and f = co. To be able to deal \nwith the remaining cases, we will also consider WY = P u {I} and set co + 00 = 00 -co = 0 .oo = d = I \nand 2 * I = I * 2 = I for all z~ll+$ and*E {+,-;./}. real line onto the unit circle and intervals as \narcs. 2.1 Real Numbers as Normal Products We now briefly describe the framework for exact real arith-metic \nfrom 115, C,!. A real number z E BP is presented as the infinite intersection of a nested sequence of \nratio-nal intervals, i.e. by a sequence 10 > 11 > 1~ > . .. such that nrzO lTrl = {x}. We will consider \ninterval sequences obtained by applying a sequence of compositions of linear fractional lransiinmations \nwith integer coefficients to the base intzval (II, x;] as follows. .4 (one-dimensional) linear fractional \ntransformation (lft) is a function f: WY + It? where f(z) = E for certain parameters a, b, c? d E W. \nIf ad -bc # 0 then this function restricts to a homeomorphism of R onto itself. Now consider a sequence \nfo, fi, f~, . . of lft s such that the interval seqlencp defined by I = fo(IO, ml -71  = fo(f1 (IO: \nml)) I2 = fo(f1 (fi(P, =)I))) (1) is nested *antI inrprsects in a single point. Here, application of \nan lft to a set is understood pointwise, i.e. we set f(A) = {f (2) [ .z: ff J?,) f,Y -4 c &#38;?O . We \nrcstyict ,:urs:A!ves to Ift s with integer coefficients and represenT. them lhy matrices. Let us defme \nand for M E Ml let O(M) be t,he lft associated with M, i.e. Note that @(MN) = O(M) o@(N), where MN denotes \nthe usual matrix product. For convenience, we will frequently drop 0. The inform&#38;on of a matrix M \nis defined by Info(M) = A4([0, ~01) if the map O(M) does not take the value I in [O,co]. Oth- erwise, \nwe let Info(M) = IP . By monotonicity of lft s, it follows that lnfo( i ;)={ [%?$I [;,:I ifad-bc<O ifad-bc>O \nand Let I@ = {(i 5) E M 1 a, b, c, d > 0 or a, 6, c,d 5 0) denote the set of matrices with same sign \ninteger coefficients. Note that for matrices A4 with non-zero columns we have Info(M) C [O, co] iff h4 \nE IV%+. In particular, this implies that Info(NM) C Info(N) for such A4 and all NE M Thus picking fo \n= O(S) and fix = O(M,) for n > 1 with matrices S E M and M, E lK+ results in a shrinkinginterval sequence \nas defined in (1). This is the basic idea of how to represent elements of Woo by sequences of integer \nmatrices. This idea is refined by introducing vectors which enable us to represent rational numbers exactly. \nLet the set of vectors with integer coefficients. The zero-dimensional lft or the constant associated \nwith a vector is defined by O( ,) = t E WY. We will also consider the set V ={(Z) EVJa.b>O} of vectors \nwith same sign integer coefficients which correspond to rational numbers in [0, co] or to 1. Now we are \nable to define our representation of real num-bers. First, the special case of elements of [0, co] is \ntreated separately. Definition 1 An unsigned normal product is either an in- finite sequence of matrices \nof &#38;!I+, called digit matrices, OT a finite list of such matrices terminated by a, vector from V+. \nThe unsigned normal product a = A4oMlMzMs . . repre-sents the interval sequence seq(cr) with seq(a)(n) \n= [0, co] fl h Info(MoM~M~ . . Mi). i=o If a = M&#38;ll... n/r,V then seq(cr) = seq(a ) with (Y = MOMI \nMZ . . . M, M:z+lA4A+z . . . where A4;+, = (V, 1 ) and M&#38; = (A ;) fOT k > n + 2. The most common \ncase of an unsigned normal product is that of an infinite sequence N = MoMl of matrices which are all \nnon-singular. In this case the associated interval se-quence is simply given by seq(a)(n) = Info(hilo~1M~...114,~). \n Note that without any further assumptions this interval se-quence might converge to an interval with \nnon-empty iute-rior rather than to a single point. One way to derive unsigned normal products is via \ncon-tinued fractior?s 1211. For example, take the expansion \\fi=l$ 1 1 2+ 1 2+ 2+... This yields fi = \n9 with z satisfying 1 21 x=2+;== 1o 2. i ) Thus we get the cosigned normal product for J i. The corrc>sponding \ninterval sequence starts with i:, cm] > [1,1.5] _> [1.4,1.5] > [1.4, S] > . . . Allowing the first matrix \nin a normal product to be ar- bitrary, we get a representation of all of R .  Definition 2 A signed \nnormal product consists either of a sign matrix fron: M followed by an unsigned normal product or of \na sl;sglc ?frxtor from V. T!le signed normal product Q = MoAll Aifs 11.8 . represents the interval sequence \nseq(a) with Zf cy = MOMI . . M,,V then seq(a) = seq(cu ) with cy = MoMI A42 . . . M, I%~~+, MA+.L where \nMA+, = (V, V) and Mi = (i y) for I: > n + 2. Note that ;f 3 == MoMlMzM3 ... = Mea is a signed nor- mal \nprodact -,-hcrl N is an unsigned normal product and seq(,C?)(n) = /Vc(seq(a)(n)) for n 2 1. As in the \ncase of un- signed norni a1 ~)~)(?ucts, the most common case of a signed normal produr:t s that of an \ninfinite sequence (Y = MoMl . . . of matrices which are all non-singular. In this case the as- sociated \ninrer-ral :+quence is simply given by seq(n)(n) = Info(A40M1 A42 Mn). Extending the above example, \nan unsigned normal product for l-d? w IS given by  (-I >(::)(:b)(:b)@~).... Finally! we need one more \ndefinition: The pseudo-inverse of a non-sir.g.uiar ,natrix M = (z ii) is given by M = (-f 7). Then @(AT@ \n= @(GM) is the identity. Note that for non- singular M, N we have Info(N) s Info(M) iff M^iv E l$@. In \nthis case, we want the entries of this matrix to be non-negative ~ncl hei;ce define if all entries of \nMN -are non-positive otherwise for ail nmtrim~ ? i, nl E M. Then A/r* N E M+ if and only if Info(X) \n2 !:;?J;. .;; hnd t,he c t ~3 N are non-negative .n I A. s i,f W exact!:; in I .;. n ,C of tensors to \ncapture functions. The two-dimensional lft assigned to a tensor is defined by 2.2 Tensors and Expression \nTrees we elaborate how to assign interval sequences to expression The framework of (15, G] employs the \nset trees, we give one more example from 1131. The tree 11 1 1 Simple examples are tensors for the basic \narithmetic opera-tions, e.g. T+ = and TX = for addition and multiplication, respectively. Compound computations \nand the elementary functions are computed using possibly infinite binary trees whose nodes are either \ntensors with two children, matrices with one child, or vectors with no children. Normal products are \nthe simplest possible such trees. Another example is the tree Tl /\\ M-7 3 2 7-4 Y 3 02 2 /\\ 7 5 / Y, \nX which denotes the infinite expression 2 1 (M%(Y, 1.5),Ts(x,T4(x,Th(x,. . J))), where x and y are \nreal numbers given as normal products. It is shown in [13] that for every elementary function there exists \nsuch a tree which computes the function in the lft framework. We give in Section 3.3 below an example \nfor the tangent function. We derive an interval sequence from such a tree in the following manner: For \nthe nth interval, cut the tree off at depth n and plug in the interval [0, m] for all exposed ar-guments. \nThe resulting intervals will be nested, if all lft s in the tree have non-negative entries except possibly \nfor the root node. We call such a tree a signed ezpressdon tree. For the special case that the entries \nof all tensors, matrices and vectors in the tree are non-negative, we speak of an unsigned expression \ntree. If there are just finitely many nodes with negative entries, we are dealing with expressaon trees. \nBefore The trees were typeset using Paul Taylor s diagram macros. . . . . / . . .x can he shown to evaluate \nfi for x given as an unsigned normal product. Evaluating an expression in this framework amounts to transforming \nthe expression tree into an equivalent tree which is a normal product. We need some further defini-tions \nin order to explain the possible transformations. The transpose of a tensor is defined by (ii f i) = \n(i J i g). Furthermcze , (Ti, .Tz) @ M = (TI . M, T2 . M) is the right product of a t~sor with a matrix; \nthe left product is de- fined by T @ 1.4 = (T @ M) . Here we write Tl, respec-tively TL , f,Gr tll+ >natrix \nconsisting of the first, respectively last, two cohlmns of T and, as above, denote the usual matrix product \nby . or simply juxtaposition. In particu-lar, M (TI, T2) = (MT,, MTJ). Observe that TtMtx),~) = (TO Why) \n(2) Ttx> M(Y)) = (TO M)(x,Y) (3) (M.T)(x,y) = M(T(x,y)) (4 for T E T and M E M and all z, y E WY. These \nidentities are read from i,+it to right as rewrite rules. Here a step of the fc,rm i (!(2 (:c), y) * \n(TO M)(x, y) or T(x, M(y)) -(T @ M)(:r,y1 l,sing (2) or (3) is called left-absorption or right-abwrptaon, \nrespectively, while T(x, y) -M(T (x, y)) derived from (4) is referred to as emission. The rules are repeatedly \napplied to an expression tree such that the root emits a sequence of matrices-the normal product which \nrepresents the result of the computation. The key steps are the emission steps. In order to ap-ply (4), \na tensor ,T has to be split into a product MT . This has t.o be done in such a way that the remaining \ntensor T has positive e++s in order to ensure that the resulting sequence of matrices is a normal product, \ni.e. that the asso-ciated inrerva!:: .: -m a nested sequence. This is achieved by considering the information \nof a tensor and emitting a ma- trix with exactlv rhe same information contents as follows. The znform&#38;on \nof a tensor T lft is defined by Info(T) = T((0, cmj,(0, mj) if O(T) is nonsingular in [O,OO]~. Other-wise, \nwe let Info(T) = Ir9 . By monotonicity of lft s, it follows t.hat Info(T) = Info(T1) U Info(T2) U Info((T \n)l) U Info(( P)z). For thr foliowing procedure to calculate the information of a tensor, TYP ,i&#38;ne \nthe relat.ions 5 and x on V by (z) -< (2) iff (y>) =: (,-r:; : I nd - bc < 0 aud V =: W iff there is \nT < 0 with V z: rM, Definit:*uz~ S S~~pp~~seT = jl/lI :LVsVi) E T, where the &#38; denote ihe columns \nof T. The head Thd of T is the matrix defined as follows: If there are i, j E { 1,2,3,4} with Vi x V \nthen we set Thd = (: y). Otherwise we distinguish two cases: (1) if 3 is not o. partial order on {VI, \nVz, Vs, Vd}, i.e. if there are pairwzsc disjoint i, j, k with Vi 5 V, 3 Vk, then we also set Thd = (A \ny) and (2) if 5 is a partial order on {VI, Va, Va, VA} we define Thd = (max(Vi),min(Vi)) E M (the head \nof T), where we pick the unique maximal/minimal element (z) with minimal sum a + b. The tail T of T is \nthe tensor defined by T = FT E II . Lemma 4 For any T E T, head and tail as given above are well-defined. \nIf Info(T) f Boo then Info(T) = Info(Thd) and Tt E II +. If info(T) = KY then Thd = (h y). With this \ntool at hand we are able to transform nondegen- erate expression trees into signed expression trees in \na finite number of steps. Theorem 5 Every expressaon tree with the property that all its unsigned subtrees \ndenote single points can be transformed into a signed expression tree with a finite number of emis- sions \nand absorptions. Proof. Starting with the lowermost signed tensor T, we absorb from both sides until \nInfo(T) # R . Then we are able to emit a signed matrix; the remaining tensor is un-signed. Signed matrices \nand vectors are absorbed. As there is just a finite number of signed nodes, after a finite number of \nstep the root is the only node left which might contain negative entries. The new tree is a signed expression \ntree. n LCRF The Language for Computable Real Functions (LCRF) in- cludes the syntax and conventions \nof the Programming Lan- guage for Computable Functions (PCF) with products de- scribed by Gunter IS]. \nThis in turn includes the terms of the simply-typed X-calculus. The context-free grammar for LCRF is \ngiven in BNF by x E variable t ::= num 1 boo1 1 real 1 real+ 1 t + t 1 t x t P ::= x 1 0 1 true 1 false \n1 succ (P) I pred (P) I zero(P) I if P then P else P / Xa: : f.P ( PP I ,Ux : t.P I (P, P) ] ?st (P) \n/ snd (P) / rif i PI i [f? I U? I )fV where variable is the primitive syntax class of variables. The \nexpressions in the syntax class over which t ranges are called types, and those over which P ranges are \ncalled term trees. The types num, boo1 real and real+ are called the ground types. Due to the special \nrole of the interval [0, oo] in the theory of lft s, we have two types corresponding to the reals, real \nfor Rot and real+ for [O,oo]. Term trees of the form Xx : t.P are called abstractions, and those of the \nform PQ are called applications. The other constructs of PCF with products include the successor -succ(P), \npredecessor pred(.P), test for zero ~- zero(P), con-ditional -if Pthen PelseP, pairing --(P,Q), first \nprojec-tion fst(P), second projection -snd(P) and recursion -PZ : t.P. The uew constructs for LCRF are \nredundant if -rif, used 6:. dc il:ition of real functions by cases, and trans-formatz~wi / A, [P), (P) \nand )P), corresponding to 0. As we will ::ec later: the different types of brackets correspond to different \ntypes of input and output. The equivalence class of term trees modulo renaming of bound variables are \ncalled just terms and we refer to a closed term of a type which is a product of ground types as a program. \nWe will use the notation [Q/ZIP for substitution to indicate the result of replacing all free occurrences \nof the variable .c in i> Ily Q, making the appropriate changes in the bound vari.:ibl:qr ~8 P so that \nno free variables in Q become bound. For CC~IW~:~~I:C~, int denotes arc integer constructed in the usuai \nway usir ; s ljair of naturai numtrers num, vector(t) de-notes t XL, marrix(r~ denotes vector(t) xvector(t) \nand tensor(t) denores .Xatrlx(t) x matrix(t). There are two systems of rules describing LCRF. The first \nof these determines which of the term described by the syntax above are to be considered well-typed. \nThese are the terms to wnich we will assign a meaning in our semantic model. The second set of rules \nform the operational seman-tics for evaiual:i, *II 3.1 r;y:i!I:,?; I i,!ies A @pc ( .~.~MJ~~:YII. is \na list H f XI : tl, xz : tz,. . ,x,, : t, of pairs of variables and types such that the variables are \ndistinct. A typi7~g *vtdgement is a triple, denoted H E P : t. con-sisting of a type assignment H, a \nterm P and a type t such that all the Fred variables of P appear in the list H. We read this triple as \ngiven the assignment H, the term P has type t . It is deiin~ 1 to be the least reiation satisfying the \ntyping rules for PCF ~(ITL products, which is well known [8], and I i ~pcl] H t-H I : \\,ector(int) I- \n[I,-): real H t----_ I :\\,ector (num\\ H k (\\Y:real+ [ Clarij -H I- A/r : matrix (int) H t-[M]:real + \nreal H k G:reai L --f real M EM Iv E M Info(M) U Irj~o(iv)o = Iwoo Info(M) # JR # info(N) (Rifl) \n(RB) lRif3) M OEM? __ rif(M, N, F,G)[O)P -+ b \\(,+I cYJP) M O 4 lid+ N-0 E ii&#38; - rif(M, N, F,G)[O)P \n-+ G((I1 (;)I>) M O 4 W+ N O $ k ---1? -+ K?)Q rif(M, N, F,G)([O)P) -+ rif(M, IV, i-, G);[OO )Q) / Figure \n2: Reduction rules for !-C!t!. whc>re A denotes the interior of A 5 RCO. As can he seen from these rules, \nwe 71se the different types of brackets to denote different types of input and output to a function. \nSo the right square bracket 1 denotes input type real and the left. square bracket [ output type real \nwhile right angle bracket ) stands for input real+ and left angle bracket ( for output real+. For simplicity, \nwe do not consider functions with input real and output real+, hence there is no transformation (PI. \nThe special construct )T) is used to indicate that a tensor is in a state where only absorption is allowed. \nThe restrictions in the rule [Rif] ensure that the two cases cover all input values and overlap. Intuitively, \nthe t.erm rif(M, N, ,f, g) should be thought of as the function z ~--f f(M- :c) for :c E Info(M) and \nz ++ g(N- 2) for zc E Info(N).  3.2 Reduction Rules A real program can be considered as an expression \ntree as described in Section 2.2. The reduction rules will include the rules of PCF and allow expression \ntrees to be t.ransformed into normal products by al)sorption and emission rules. For-mally, the reduction \nrules of LCRF are defined in two steps. First we extend the retluct.ion relation -+ of PCF to o71r language. \nThis relation allows us to emit a leading matrix from any expression tree, i.e. the sign matrix for type \nreal and the first digit matrix for type real+. Then we define the relation ==+ which enables 71s to \nemit seq71ences of matrices. We define -+ to he the least reflexive transitive relation satisfying the \nreduction rules for call-by-name evaluation of PCF with products, which is well known 181, and the rules \ngiven in Figure 2, where, for simplicity? WP have omitted a corresponding set of rules for vectors in \nplace of matrices. The rules (M&#38;l/S) ensure that only the leading matrix of i7 normal product may \nhave negative ent.ries. For the same reason, a tensor [ i ] may only absorb information {AbsS) and a \ntensor [Z ) may only emit if it has non-trivial informa-tion (Emit2) and has to absorb otherwise (Abs2). \nWhenever a tensor emits information (Emitl/2), its state is changed to ) f), so that absorption is forced \nnext (Absl). This ensures that in an jr&#38;ire tree (Z J)(z, (TJ)(x, {T~)(z,. . .))) which I: u~ IMP \nr~structed using /c (see the example in 3.3 below), 11,forrnntion is process\\?tl in a breadth-first manner \nto avoid poF:sihie unnecessary dcadloc~k. N0t.e thaT ihe rules for rif are deterministic. Priority is \ngiven to th,? !eft branch (Rifl), the right branch is cho- sen only if :: ;:ai t-choice is not possible \n(Rif2). Only if nei- ther branch c~17 be chosen yet, the argument is further re duced (R i ). The rcdJ,ct,~o \n1. relation ti) AS now defined as the least relation conri:l :rJg + and satis?;irJg 1 - (ii) pjgz+j$ \nHence =--;I!![YYS us to emit sequences of matrices. The distinctic::i X. ~,YY: t and --i I< .nc-cessary \nto ensure that the rulrs :,r .l :letzrministic: Suppose P -+ (M)P and P i (!Y ; I 2, well as Q + (N;Q \n. Then there is only one wav of rcduc r lc: f )(p, Q), na;ncly to (TO M@ N)(P , Q ) by (tlks;j. 1. :. \ndid not distiuguish between -+ and =+, the11 (ii! wo:~l~i YiPld P --t (Al)(M ) P and the reduction )T)(.F \n,Qi + {/ CL? iIf@ N)((M )P ,Q) would also be pos- sible. We ,ii?\\- th;tr :. program P :vra!-ates to a \nvalue Z if P ===s 2 where N value of typck bool, num, or int is, as usual, a : .;ll!ii.'lLi .)I of the \nfor,JJ succ (0) for some n E N, respectiT,r :a! y, I t;lnt :10 further :etluction is possible. As usual, \nv,,!xc, 3E p;i:duct type are f-.1p!rs with values as com- ponents. I :,: !;:;Je real, values arr :.Jrograms \nof the form [V) or for sornt> prcJg~:a~~~ P and matric~c~~ with values as entries. Simiiari,,, for r.;;c \nreal+ witn (413) as leading term. Note that, unlike the czse of the other types, a value of type real \nOr I+ :r:;,y hc urtiler reduced ur~!?s:~ it is a vector. I?WII th:cJ r4.1ction for t! r- I:CW types need \nnot ter-minate. :: ;c~:: .X:.,X reduction yi:4&#38; a sequence of matrices as the : 111~:: R- -!!~tc?rministic. \n7 w.s we are able to extend the cvel:lat:or. +::,?::m Eva! frc.:n programs to values to the Figure 3: \nUnfolding the expression tree new types as follows. if the program P reduces to val-ues starting with \narbitrarily many matrices, it determines a normal product CY, signed or unsigned depending on the type. \nWe let Eval(P) = seq(a) be the sequence of infor- mation thus calculated. Thus, e.g., if P is of type \nreal and P * [A4e)(A41) ... (Mn)Q and all these matrices are non-singular then EvaI = Info(nF=, Mi). \n 3.3 Example A continued fraction for tangent is (Lambert [9]) 1 tan(x) = 1 I+ 3 X --1 2+5 1 ;+7------$... \nX This can be transformed [13] to tan(s) = (\";;,' \",I) n-((2n+3)(2+1) '\"\"';$x-pw~~) n=O (PnfS)r+(Pn+1) \n or put another way tan((i -i)x) = ( : ; -:, -1, (x, (; .: ; i;) (XT (:: : : ;, (2, .))) for z E [0, \noo]. This infinite tree can be generated using the p construct. If we set 2n+3 2n+l 2n+3 2nf5 I = An. \n27a+s h-l-3 2n+l 2n+3 ( > and * = pf.Xn. (I(n))(x,f (n + 1)) then Q, -+ h.(I(7l>))(X, cP(n + l)), for \ntan(s) where :I: t [0, cm] does not reduce. so CD(O) --f jr~,o)i(.f:, 9(l)) -+ (I(O)}(x, (1(1))(2,9(2))) \n4 . *. provided :L doe+ XIT reduce. Thus, a program h: real+ + real in LCRF vith 1. (xl = tan((i -i).xj \nfor z E [0, oo] is h(x) = (J)(x, 9(O)) where .i = (: v -: -,i). The first few unfoldings of h are displayed \nin Figure 3. This enables us to calculate tan(x) for all z E [-l,l]. For x $ [-1, 11, we must repeatedly \napply the trigonometric identity where T = (-7 d A yj in order t.) ishift the argument of tan into I--1,1 \n,. .4 recursive application of the rif-statement can be used to a,:ct:~n>lish this prc,vicied we use \na suitable pair of overlappinv iv tervals. For instance, consider the two ma-trices hf := 1 ij and N \n= (-3 f) with Info(M) = [-l,l] ?1 II and Info(N) = [f, -iI. We get. tan == pf.cif(M. N, h, Xx.[T](f([N \n)z), f([N )x))) So, if tire f,:~.r tan is applied to a real number, [L) z say, then if info(L) C Info(M) \n= [-I, lj the result is else if Info(L) E Info(N) = [i, -31 the result is [T](tan([N )(~~ *L)x),tan([N \n)(~N*L)x))) r .I!1 = D ,: y ] (tan ([N AV*L)x) ,tan ([N N*L)x))-! i Define otherwise [L) z must be \nevaluated further. Denotational Semantics We refer the reader to [l] for domain theory. Let IV1 = NU \n{I} and BI = {true, false, I} denote the flat domains of natural numbers and truth values, respectively. \nFor a com- pact Hausdorff space X, let UX be its upper power space, i.e. the collection of all nonempty \nclosed subsets of X, or-dered by reversed set inclusion. The space X is embedded into UX as the set of \nmaximal elements via z t+ {x}. The way-below relation < on UX is given by K < L iff there is an open \nset 0 s X such that K > 0 > L. If f: X + Y is continuous, its canonical extension Uf: UX -+ UY is given \nby Uf(A) = {f(z) 1 x E A}. We write Uf simply as f. We will use these domains, which are all continu-ous \nScott-domains, i.e. are bounded complete, to extend the standard fied-point model relative to call-by-name \nof PCF with products to LCRF. The interpretation [It] of a type t is the domain defined inductively by \n[real+] = U[O, ~~31 [;:;I 1 p us -+ tn [real] = U&#38;? I[s x tj 1 /ys x-gnl While a type assignment \nassociates types with variables, an environment associates values to variables. If H is a type assignment, \nthen an H-environment is a function p on vari- ables that maps each x : t E H to a value p(x) E [tn. \nLet us use the notation [H D P : t] for the interpretation of term P relative to type assignment H and \ntype t. Thus [H D P : tJ is a function from H-environments to it] defined by induction on the type derivation \nof H k P : t. Thus, in particular, we get for transformations that ulv)j = Info(V) E UR up41n = o(n4):ulw \n--t TJIR~ [[T]] = O(T): UWoo x VW -+ UR and similarly for the other cases. One has to take care in the \ncase of Ift s containing (i) columns. So [[($)jj = Woo = -LlJBt= whereas (( i)) is of type real+ and \nthus a( (:))I = [0, ~1 = lu[o,ool. Similarly for the zero matrix (i z) which is interpreted as the constant-l \nfunction of the appropriate type.The semantics of rif-statements is given by UriYM, iv, P, &#38;)1(x) \npqh;I) ifxN =0 = u&#38;nbN) if 5,~ = 0  um4 u bath4 ctherwise, 1 where XM = hf-l x n [O, cm] and xN \n= N- x fl[O, co]. Hence this programming construct, introduced to enable the pro-grammer to give d&#38;initic>ns \nby cases as in the example in 3.3, may be used to produce r,on-single-valued functions as in the following \nexample. As lnfo( 6 y) = [;J, m] and lnfo(T 1;) = [2,1], the restriction of upj to ma&#38;;ial elements \nof UR , i.e. to singletons {z} with z E Rm is ttlr function pq(-:i7Tj) = (0)(11 J (5 IL 21\\ i&#38;2) \nx E [co, O] \\ (0, cm} 1 {O,l} x E [0, l] u [2,co] The deterministi!: reduction rules will choose one \nbranch when evaluating :;uch a functior?, vhera the choice depends on the particiilar representation \nof t.he argument. We say th;rr a term is srnglc-valued, if such a thing does no t happen. i.e. if for \nall its subterms of the form rif(M,N, I ,Q) ir is true that [E-n(M- x) = [Qj(N- x) holds fm ail maximal \n.I: E Info(M)nlnfo(N). There is no way to syntact.ically prevent the user from writing multi-valued programs. \nNote that, as in the above example, the union of inter- vals uPI U [Qn(zN) in definition of the semantics \nof rif need not be an i,ltervaJ. Hence it is not possible to de&#38;e a denotational scr,:a&#38;ics for \nLCRF using the interval domain IIP in place (VI -iiX 5 Comput:~t ional Adequacy In this pqer. Y li have \nnot alic:wed multi-valued reduc-tion rules. This means that the reduction rules are sound, i.e. P + Q \nimplies [P] = [Qj, except for the rif-rules. So we get Theorem 6 (Sxmdness) For a,11 single-valued pro-grams \nP, Ckm ;~I~~-~~Ic~Y Car q. ~1::~;s of basic functions which ir,lds we will define i~c,!onr. As usual, \nit: proof is by induction. We need thr follov I:.;; &#38;finitions. Definition 7 The computable fz:rms \nof LCRF form the least set of tc rms such that e A progr~.;;~ P is computable whenever [PI E UnEN EvaI( \nl If t-P: s -4 i then P is computable whenever PQ is computablt- ,for any closed computable term Q of \ntype s. 0 Af :i:i:T1. ..,:Cn:tn k P: t then P is computable when-ever 14,. , Pn/zl,. . . , xlL! P is \ncomputable for any set of closed computable terms Pi such that I- Pi: xi. Definition 8 The I-total elements \nof the semantic do-mains [t] are &#38;fined inductively by l If t is a. :~avnd type then n E It] is I-total \niff a = I or a is 7n~::vmnl. 0 lft==tL \\r t2 then a = (a,, a2) E [t] is I-total if al and a2 I?. , I-total. \n Note that every element of NL and BI is I-totat, hence so are all elements of [t] for t a type not wntaining \nreal or real+, i.e., a type of PCF with products. The I-total computable terms of LCRF form the least \nset of terms such that l A program P is -L-total computable whenever [P]I is I-total and [PI &#38; UnEN \nEval(P)(n). l If k P: s + t then P is I-total computable whenever PQ is I-total computable for any closed \nI-total wm-putable term Q of type s. l If Z1:tl,...,xn: t, t P: t then P is I-total com-putable whenever \n[PI,. . . , P,/xl,. . . ,x,]P is I-total computable for any set of closed I-total computable terms Pi \nsuch that I- Pi: xi. Lemma 9 A real program P is computable (I-total wm-putable) ifl for all a. << [PI \nthere is n E N such that a 5 Eval(P)(n) (and P Zs -L-total). Lemma 10 If T l;s n tensor and P, Q are \nterms of appro-priate type then there a,re i, k E N such that for all n E N (1) Eval((WP, Q))(n + 1)) \n= T(EvW )(nL EvaKQ(4))  W EvW HP, Q))(n)) = T(EvWW), EvaI(Q  (3) EvaW)(P, Q))(n + 1)) = T(Eval(P)(n \n+ i), Eval(Q(n + i)))  (4)E=Wl(P, Q)Hn + 1)) = T(Eval(P)(n + k), Eval(Q(n + k))). Proof. (1) If P --t \n(M)P and Q --f (N)Q then (T)PQ w (T ld)(Shd) )S )(P ,Q ) with S = T @ nf@ N. Thus Eval((T)(P,Q))(l) = \nInfo(T Shd) = Info(T@ MO S) = T(Eval(P)(O), Eval(Q)(O)). The general case follows by induction. Similarly, \n(2), (3) and (4) are proven with the alteration that in (2) the tensor does not emit prior to absorbing \nand that in (3) and (4) the tensor has to absorb a certain number of matrices before it can start to \nemit. If the arguments P and Q cannot deliver enough information for T to start ab-sorbing, both sides \nof the equation are equal to 1. n Lemma 11 All tmnsjY>rmations are computable. Proof. Let us consider \ncte case (2 ) for a tensor T. We ap- ply Lemma 9. Suppose IL < [(T)(P, Q)j = T([P]I, [&#38;I) for computable \nP and Q. By continuity, there are b, c E UW with b < UP], c < [Q], and a 5 T(b,c). By computabil- ity \nof P and Q there are m,n E N with b &#38; Eval(P)(m) and c 5 Eval(Q)(n). Take k = 1 + max(n,m), then \na g Eval((T)(P, Q))(k) by Lemma 10 and monotonicity of T. The cases of )T), iTj and [T), matrices and \nvectors are dealt with similarly. n Lemma 12 Suppose %/rat W = rif(M, iV, F, Q) is well-typed and s:Ingle-valued, \n;iha,! [1:-J is strict, and that P and Q are I-total computtible. Thm W is I-total computable. Proof. \nASSX~IFI that R is I-total computable. We have to show that :I, (H) is I-total computable. Suppose a \n<< [U (R)&#38; ils ;< i;3 I-total, either [RI = I or else [R] is maximal ii. IJR . If [RI = I then [W(R)1 \n= I by strictness, hl\\~(:,-1. = I and ncrthing is to show. So as-sume that [R< i : :naximal. Then there \nis n E N such that Eval(R)(n) is co-!rained in Info(M) or Info(N) so that the term W(R) reduces to the \nrespective branch. Assume the former. More precisely, let R * [Mo)(Ml). .. (Mn)R and for M = MQ . M+, \nand A4 = M M% su -pose M*M E I@, M M $ lV?, and N M $ MC Then W(R) --t P([M*M )R ) and moreover I[W(R)] \n= I[P([M*M )K;I by single-valuedness. Using Lemma 9, it is easy to see ~*.ar I-total computability of \nR implies I-total comput;tl;(lit\\: of [M*n4 )R . Thus P([M*M )R ) is I-total c~~Ini.j~~td~i~ and hence \nthere is k E N such that a g Eval( F-(:iii * ,\\I )R ))(k) = Eval(W(R))(k). There-fore W(R I is i-total \ncomputablr. n Definition 13 A term P of type t is basic, if [Qj is strict, single-valued, and I-total \nfor all .subterms Q of P. This class inc!,lGr; in particular the programs for all single- valued eleme:.,.? \n1. functions pTe ented in [13]. Lemma 14 E,~rl; trrm of LC!%7 zuhrch does not contain rif is compuf&#38;~: \n.iv.ql basic term is I-total computable. Proof. 7 ;:s ;,I .K).! is by structural induction on the term \nP. Let (r be a Etib;iti tution of closed (I-total) computable terms for the free va5a!)les in P. Thus, \nwe must show that UP is (I-total) computable. We only deal with the cases which deviate from t.hr corresponding \nproof for PCF with prod-ucts [S]. For F :-.\\x : t.Q, we must show that R z (Xx : [.(rl'J)yip2 . ., p, \n;:. (l-total) computable if PI, Pz. . .J!, are closed c-L.-total) computable terms and h i .::. ;,qpe \nreal or ;f:al+. Observe that R + ([P~/.cJ(c$Jj,~~. . . P, f (tciPl/:c])Q)Pg . . .Pn, which .., ze we,. \n, ;.H ,;. But, S 1.; (I-:-&#38;al) computable be-caxt 2 iz &#38;total) cc,n:puti;ble. NOW UR] = I[S] \nam-l i/,&#38;E3 fud:(R)(n) = UnEN iZval(S)(n), thus R is (I- total) computable. For P z /~.i : t.Q, we \nmust sh;>w that R E SPI Pz . . . P, where S = pz : t.oQ is (I-total) computable if PI, &#38;, . , I=?, \nare closed (I--total) computable terms and R h.+; I; I~+ real or real-, &#38;fine Si by so E /.!:J: t.:,: \ni+1 s s (Xx : t.uQ) S . ? lm i3i] = ~~~j~,[,.!?] and Si is (J--total) computable for ali i E N. Let u \nK BR] = uquPIn.. . uPnn = u~ =oljS P~ ... P,,j. Then there is i E N with a << ljSiP; .. . P,,C. Therefore \nthere is k E N such that a &#38; Eval(S P1 .. . m)(k) because Si is (I-total) com-1~11 Lii analogy t1.e \nUnwinding Theorem [8], table. with .Ctcan bc, .I ,-i.?d by in&#38;t ~~;on Ihat there is e E W with Eval(SiPi \n ,,)(k) _C Evnl(Rj(P). Thus R is (I-total) ccmp;-t;: : -1) l The r-:, . ;..ii.g cases zre if! v,hich \nis I-total com-pu:.ah!~ 7~ LJV?mrna 12 (7::~: transformations, which are cor:lputaSl:! 1.1; Lemma i 1, \nn Theorem 15 (Completeness) If P is a, program which does not contain rif or wh,ich is basic, then IF \n3iz u E-l(P)(n).  nEN Combining Theorems 6 and 15, we get computational ade-quacy for all programs which \ndo not contain rif or which are basic. Corollary 16 The LCRF function tan defined in the ex-ample in \nSection 3.3 conputes the tangent function. More precisely: If P as a program of type real denotang x \nE Iw, i.e. if Un,ePdEval(P) = {z}, then tan(P) denotes tan(z). Proof. Combine the adequacy result with \nthe proof of mathematical correctness of the formula for the tangent given in Section 3.3. n Likewise, \nwe can compu:e all elementary functions like sin, cos, tan, exp, using t.he formulas given in [13] and \ncor-rectness of the resulting LCRF-programs is guaranteed by the adequacy result combined with the mathematical \ncor-rectness of the formulas involved. Conclusion We have shown the ck,mputational adequacy of the lft \nframe- work for lazy real number computation for a class of basic real programs which includes programs \nfor single-valued el-ementary functions. This in itself represents a significant theoretical progress \nin developing correct algorithms for real functions. It also narrows the gap between the theory and practice \nof real number computat.ion. Among the main is-sues for future work wil! be the question of universality \nof LCRF and the development of more efficient evaluation strat,egies. Also, in order to capture multi-valued \nfunctions such as arctan in our semantics, we need to allow multi-valued reduction rules for rif. Alternatively, \nwe can use a parallel construction to obtain computational adequacy for all elementary functions [14]. \nFurthermore, the implemen-tation Calathea in Cam1 of the lft framework by Potts at Im- perial College \nis based on exact floating point [15, 61, i.e. it restricts the set of matrices used to only four sign \nand three digit matrices; this ~rralws the flow of information steady and allows an infornaat7on flow \nana2ysis 1131 to maximize the efficiency of the lazy evaluation. The question of com- putational adequacy \nof the exact floating point framework with the information flow analysis will also be a basic focus of \nfuture research. References [I] S. Abramsky and A. Jung. Domain t,heory. In S. Abramsky, D.M. Gabbav, \nand T.S.E. Maibaum, editors. Handbook of Logic in Co&#38;$uter Sdence, volume 3, pages i-168. Claren: \ndon Press.a: 1994. [2! J.-C. Bajard: D. Michelucci, J.-M. Moreau: and J.-M. Muller. Int,roductior to \nthe special issue Real numbers and comnuters . lownnl of Uniovrsnl Computer Science, 1(7):436-438, 1995. \n[3] H.-J. Boehnl and II. Cartwright. Exact. real arithmetic: For-niulating real numbers <as functions. \n111 0. Tilrner, edit,or, Research Topics in Fun,ctional Programming, pages 43-64. Addison--\\ l rsley, \n1990. I . 1% <:i~i.~,~f <,; .nio. A Fun.ctioiinl Approach to Computability on, Rr:ibl /u. i;f~ :7 s, \nPhD thesis No. I D-6/93, University of l isa-(d~i.ttvn--1 \\line, 199.3 [4 PI .2. Edalai. .:::namical \nsystcus, :neasures and fractals via dolliair, thw;.:.,. Informatio:a and Computation, 120(1):32-48, 109.5. \nA. Edalar, and I . J. Pott,s. A new representation for exact real numbers. Electronic Notes in, Theoretical \nComputer Sc? ence, 6. 1997. IJRL: http://wa~,~.elsevier.nl/locate/entcs/volumeg.html. M. II. %; a--!h \nPCF extended Tvit,!l real numbers. Theoret-l;cnl C:~;:*I (;,Y Science: 162(i !: ;0&#38;11.5, August 1996. \n171 I< c,. A. i;t,,s _ Sernantl:i:s of Pwgnwnm.ing Languages. MIT Press. 1!1!1 !. 181 PI .I. i-I. Lanwert. \nBertrhge .zu91t,C.:tbrauch der Mathematik und deren AnuJendun.g, volume 1 of I . II. Zweiten Theil, Berlin, \n1770. D. R.. Lest,er. Vuillemin s exact real arithmetic. In R. Heldal, C. K. Hois and P. L. Wadler, edit,ors, \nFunctional Progmm-mi9z.g, Glad ,; 011, t 9.91: P~roceebgs of th,e 1991 Workshop, f ortrec, 0 11. : qrs \n225-238. Berlin, 1992. Springer Verlag. L.. .\\/I;-:.--,<~ ci,:ain. Arbi+,rzry precision real arithmetic: \ndrsiq ~1~~~1 I:; c c.1 Ithms. t,o J. Symbolic Computa- w: , Sabm;t,ted th, lLl!h,. C. !7. F lot c :~. \nI CF considered a:: a programming language. Theoretrcnl Computer Scieme, 5:223-2X&#38; 1977. PI P. .i. \nPotts. Efficient on-line computation of real functions PI Ilsing exact floating point,. Sub;nit,ted for \npublication. Avail- able frnn!: http://theory.doc.ic.ac.uk/-pjp, 1997. P. .I. Pot ! + , ,x::IcT. real \narithn,-i,lc using Mijbius transforma-tions. 1 1: i ~-l i(w;;: Imperial ( 01 ,:ge London, 1998. Available \nfro71: h I- I- : '/;LRory.doc.ic.ac.uk/-pjp D41 WI 2. r), 1,'; ,I. lf: -~ A. Edalat. &#38;act Real Computer \nArith-metic, h;:i r<.!l 1997. Depart,ment of Computing Techni-ca: Report IXK 97/9, Jmpcrial College, \navailable from http://theo+y.doc.ic.ac.uk/-pjp. P. J. Potts: A. Edalat, and M. H. Escard6. Semantics \nof exact. real arithmetic. In Proceedings of the Twelfth An-nuah IEEE Symposium on Logic In, Computer \nScience, pages 248--2:,!: : ia-saw, Poland, 1997. WI D. S. Fro, i. x\\:ltline of a mat~hematical theory \nof computa- tion. lx i 3 .4 frnual Ptin,o:tw (:onference on Information jWi?l,..:i j_s__ pager:; Lb:)- \nI 76, 1970. P71 d ;.I;stems, iI. s. :t I1.b. A type-theoretical akernative to ISWIM, 1181 CIJC:W. Ovv \n:#? . Theoreticd Computer Science, 121:411- 110. 1993. K:~:,:int of a niaIluh+pt written in 1969. M.H. \nSn:ylh. Powerdomains and predicate transformers: a copologicai xriew. In J. Diaz, editor, Automata, Lan,guages \n292~1Prqranrnrl:ng, pages 662.-675, Berlin, 1983. Springer Lrlag. L,wl, 11 13 Notes in Computer Science \nVol. 154. 1191 ,I. s. :. I (II,:? Exacr real comput,er arithmetic with PO1 conTin * i ,: j ibns. IEEh \nll,,lrisnctions on Computers, :w(:q: ) It . l990. [21] ..S \\: Y rdinued Fracti~vR. D. Van Nostrand, \nNew \\: 01.1:. 1% (.  \n\t\t\t", "proc_id": "289423", "abstract": "We provide a semantical framework for exact real arithmetic using linear fractional transformations on the extended real line. We present an extension of PCF with a real type which introduces an eventually breadth-first strategy for lazy evaluation of exact real numbers. In this language, we present the constant <i>redundant if</i>, rif, for defining functions by cases which, in contrast to <i>parallel if</i> (pif), overcomes the problem of undecidability of comparison of real numbers in finite time. We use the upper space of the one-point compactification of the real line to develop a denotational semantics for the lazy evaluation of real programs. Finally two adequacy results are proved, one for programs containing rif and one for those not containing it. Our adequacy results in particular provide the proof of correctness of algorithms for computation of single-valued elementary functions.", "authors": [{"name": "Abbas Edalat", "author_profile_id": "81100228115", "affiliation": "Department, of Computing, Imperial College, 180 Queen's Gate, London SW7 2BZ, UK", "person_id": "P10092", "email_address": "", "orcid_id": ""}, {"name": "Peter John Potts", "author_profile_id": "81100304824", "affiliation": "Department, of Computing, Imperial College, 180 Queen's Gate, London SW7 2BZ, UK", "person_id": "P225020", "email_address": "", "orcid_id": ""}, {"name": "Philipp S&#252;nderhauf", "author_profile_id": "81100455480", "affiliation": "Department, of Computing, Imperial College, 180 Queen's Gate, London SW7 2BZ, UK", "person_id": "P226598", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/289423.289441", "year": "1998", "article_id": "289441", "conference": "ICFP", "title": "Lazy computation with exact real numbers", "url": "http://dl.acm.org/citation.cfm?id=289441"}