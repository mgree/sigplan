{"article_publication_date": "09-29-1998", "fulltext": "\n A Non-Deterministic Call-by-Need Lambda Calculus Arne Kutzner, Manfred Schmidt-SchauB Fachbereich Informatik \nJohann Wolfgang Goethe-Universitgt Postfach 11 19 32 D-60054 Frankfurt, Germany email: {schauss , arne}flki \n. cs .uni-f rankfurt . de Tel: (f49) 69 798 28597; Fax: (+49) 69 798 28919 Abstract In this paper we \npresent a non-deterministic call-by-need (untyped) lambda calculus X,d with a constant choice and a let-syntax \nthat models sharing. Our main result is that Xnd has the nice operational properties of the standard \nlambda calculus: confluence on sets of expressions, and normal or-der reduction is sufficient to reach \nhead normal form. Us-ing a strong contextual equivalence we show correctness of several program transformations. \nIn particular of lambda-lifting using deterministic maximal free expressions. These results show that \nAnd is a new and also natural combination of non-determinism and lambda-calculus, which has a lot of \nopportunities for parallel evaluation. An intended application of And is as a foundation for compil-ing \nlazy functional programming languages with I/O based on direct calls. The set of correct program transformations \ncan be rigorously distinguished from non-correct ones. All program transformations are permitted with \nthe slight ex-ception that for transformations like common subexpression elimination and lambda-lifting \nwith maximal free expres-sions the involved subexpressions have to be deterministic ones. Introduction \nCurrently, the preferred methods in non-strict functional languages to implement l/O and other interactions \nwith the environment are monadic programming as in Haskell ([PHA+97]) or direct calls that are embedded \nin a system of unique types as in Clean [NSvPSl, Ach96]. In the com- mercial non-strict functional programming \nlanguage Natu-ral EL [HNSSH97] these interactions were implemented as direct calls. The intention of \nthis paper is twofold: On the one hand a non-deterministic lambda calculus &#38;,d is described that \nis different from most other non-deterministic lambda calculi insofar as it is lazy, i.e., call-by-need, \nand has all the ad-vantageous properties of a lambda-calculus, where instead of confluence a generalized \nnotion (set-confluence) is used. On the other hand we want to demonstrate that the ntive approach to \nI/O in non-strict functional languages can be justified, based on a different set of transformations \nof the non-deterministic lambda-calculus. The following well-known example demonstrates the prob-lems \nin adding non-determinism to the lambda calculus: Let 0 be non-deterministic choice and let the function \ndouble be defined as double z = z + z. The issue is: What is the result of reducing the expression double \n(1 0 a)? Using p-reduction there are two different reduction sequences that conflict with set-confluence. \nl double (1 0 2) -+ (1 0 2) + (1 0 2), which may result in 2, 3, or 4. l double (1 0 2) -+ double n, \nwhere n = 1 V 2, which may result in 2 or 4. This means that depending on the selected redex to be re-duced, \nthe set of possible results is different after one re-duction step, which means that this kind of beta-reduction \nmakes an implicit choice . This is not only counterintu-itive, but leads to inconsistencies. One remedy \nis to restrict the permitted redexes, usually by only permitting a fixed re-duction strategy like strict \nevaluation or normal order eval-uation. The first possibility is the method chosen for strict func-tional \nprogramming languages and also for Clean. It has the disadvantage that it severely restricts the permitted \npro-gram transformations, since the sequence of evaluation is highly fixed. Another remedy, which we \nwill pursue, is to modify the cal- culus by introducing sharing such that the calculus does not unnecessarily \ncopy expressions. In the example above, the expression (1 0 2) is not copied, such that the set of possi-ble \nresults is 2 or 4. We are strongly influenced by the let-calculi described in [AFM+95, AF97, MOW981 which \nmodel sharing. The only syntactic addition is to add choice as a constant. In order to be able to built \na compiler using program trans-formations like lambda-lifting, partial evaluation, inlining, etc., it \nis important that the calculus is rather permissive in the applicability of its reduction rules, such \nthat a wide range of program transformations can be shown to be cor-rect. The sequence of evaluations \nshould have a maximal degree of freedom, such that parallel evaluation is possible. On the other hand, \nthe normal order reduction should be rather close to a possible implementation. The calculus &#38;d meets \nthese requirements. There are two criteria that play a role in the correctness proofs: One is set-confluence, \nthe other is the existence of (in)finite normal order reductions. Set-confluence corre-sponds to the \nintuition that the initial program determines the set of possible results, and that exactly these results \ncan be computed using reduction rules. Moreover, it also cap-tures the intuition that all choices are \nexplicit. Thus it is a natural generalization of confluence. The achievements of this paper are that \nthe non-deterministic call-by-need lambda calculus X,d is set-confluent (Theorem 3.8) and that whenever \nan expression can be reduced to a HNF, there is a normal order reduction to a HNF (Theorem 4.9). We show \ncorrectness of lambda-lifting with maximal free expressions wrt contextual equiva-lence, a result which \nseems of practical value (Theorem 8.2). As a corollary it follows by simply dropping the choice, that \nthe calculus Xl,t [AFMt95, AF97] may have more permis-sive reduction rules without destroying confluence. \nIn [SS92] twelve different kinds of non-determinism in non-strict functional languages are identified. \nUsing their categories, And has an erratic, restrained, singular non-determinism. However, x,,d justifies \nunfolding, (i.e., pro-gram transformations) without incompatibilities between singular semantics and \nunfoldability. Hence, And is a new kind of non-determinism in non-strict functional languages. Unfortunately, \nit is a real pain to work through case-analyses and reductions of lots of diagrams. Due t,o lack of space, \nwe often give only the results and omit the tedious computa-tions. The diagrams are also mechanically \nchecked (by a Haskell-program) up to a certain size of expressions. This forces us to correct several \nerrors in the diagrams. An ex-tended version of this paper with full proofs is in prepara-tion. Our calculus \nAnd fits into the work on implementing and compiling non-strict functional programming languages [PJ87, \nPJLSl], since the calculus is compatible with super-combinator reduction. The practical application of \nour calculus is to provide a basis for program transformations (i.e. compilation) of lazy func-tional \n(higher order) programming languages that use direct calls. The correct program transformations can be \nderived by simulating the result of an I/O-function by a big choice-expression. For example, the result \nof an I/O-function that may return True or False can be modeled by the expression (choicel(choice True \nFalse)). The paper is structured as follows. First the calculus is described in section 2. Then the basic \nproperties like set-confluence and existence of a normal order reduction are investigated in sections \n3 and 4. Contextual equivalence and deterministic expressions are defined in sections 5 and 7. The correctness \nof a set of extended rules and of lambda- lifting is proved in sections 6, 7 and 8, and the relationship \nwith the usual lambda calculus is clarified in section 9. 2 The Language A-expressions may be variables \nx, the constant choice, ap-plications (s t), let expressions (let x = s in t) and abstrac-tions Xz.t, \nwhere x is a variable, and s, t are A-expressions. As a convention we shall assume that all bound variables \nare different, which can be achieved by a consistent renaming of bound variables. The set of variables \nin a closed expres-sion t is denoted as V(t), the set of let-bound variables as Vi,,(t). A closed expression \nis one without free variables. We consider expressions as equal (denoted z), if there is some consistent \nrenaming of bound variables that makes them equal, i.e., if they are o-convertible. We use the convention \nthat application is left associating, i.e., el ez e3 means the expression ((el e2) es). The constant \nchoice is intended to be a function that may reduce (choice s t) to either s or t. We use several kinds \nof reduction relations. We shall use the +,*-notation for the transitive and the transitive-reflexive \nclosure. The sym-bol ?,, is used for reduction consisting of 0 or 1 steps. A context C[.] is a closed \nA-expression with exactly one hole, where the hole can be at every position where an expression is permitted, \ni.e., the syntax is C ::= [.] ] C s ] s C ] (let x = C in s) ] (let x = S in s) ] Xx.C, where s is a \nA-expression and x a variable. The notation C[s] stands for the expres-sion, where s is plugged into \nthe hole. A reduction rule + is compatible, iff t -+ t implies C[t] --+ C[t ] for every context C[.]. \n 2.1 Non-Deterministic Reduction We use the reduction rules in table 1, which are a gener- alization \nof the ones in [AFMt95, AF97]. The calculus is almost the same as the one in [MOW98], but we leave out \nthe garbage collection rule (ldel), see 2. The rule (nd) is not compatible, which is justified by the \nintuition that a compiler should not be able to optimize functions by evaluate I/O s at compile time. \nIt could be made compatible by formulating the reduction rules on sets of expressions. The presented \nformulation is close to the operational view that the choice-decisions are taken outside the functional \nprogram, and that once a decision is made, you can forget the alternatives (committed choice). Definition \n2.1 Let s denote an expression. A reduc- tion context R[.] is dejined by the syntax: R ::= [*I 1 (R s) \n( (s R) 1 (let x = s in R) I (let x = R in 3). A let-context is defined by the syntm L ::= [.I I (let \nx = s in L). We will use the symbols R, L only with this mean- ing. Moreover, let LL ::= (let x = in \ns), AL ::= . s, and W ::= L ) L[LL[A;]] Definition 2.2 Based on the reductions in table I, we de- fine: \ns 3 t, ifs 4 t for p E {llet, lbeta, lapp}. s loq t, ifls llef t or s % t. Definition 2.3 We define \nrelations on sets of closed ex- pressions. Let s, t be closed expressions and let M be a set of closed \nexpressions. l Ifs 4 t, then MU (3) 2 MU {t} for all labels p E (cp, llet, lapp, lbeta}. set,let,nd \nset&#38;t set,nd l ------+ := -----+u----+. set set,let,nd set,cp . +X,nd := +u+.  We define redexes \nas immediately reducible subexpressions within an expression. Let C, D be arbitrary contexts. (llet) \nC[(let 2 = (let y = t, (lapp) C[((let x = t, in 3) t)] I bd , a) C((X 2.. t) 3)l n R[(cholce s)] (cp) \nC[(let x = 3 in D[x])] If s is a lambda-abstraction in tl) or in s)] choice + + -+ + -+ --+ and C[(let \nC[(let C[(let R[((X R[((X C[(let s is a y = t, in (let x = t, x = t, in (s t))] x = 3 in t)] x . (X y \n. y)) s)] where x (X y . 2)) s)] where 5 = s in D[s ])] renamed copy of s in s))] Z, y are x, y are fresh \nfresh variables. variables. Table 1: The non-deterministic calculus And 3 Confluence of Reduction on \nSets Usually, confluence of reduction is interpreted as the inde-pendence of the result of a computation \nfrom the sequence of reductions. For a non-deterministic reduction, this no-tion has to be generalized. \nFor example, choice s t may be reduced to s as well as t. Since the expressions s, t are arbi-trary, \nwe cannot hope that there is any sensible relationship between s and t. The criterion that we will use \ninstead is that the set of possible results is an invariant of reduction: For non-nd reductions this \nmeans that the set of possible re-sults does not change, i.e., there will be no implicit choices. For \nan nd-reduction t 4 tl, where the other alternative is t -% t2, we require that the set of possible results \nof t is the same as the union of the possible results of tl, t2. 3.1 Confluence of -% Definition 3.1 \nA relation + is locally confluent, iff whenever a + b and a + c for some closed expressions a, there \nis some d, such that b 4 d, and c &#38; d. set,let,nd Lemma 3.2 The reduction relations -% and + are \nterminating. Proof. The following measure cp = (cpl, (~2) is used for ex-pressions, where pairs are compared \nlexicographically. The first component cpi is the number of occurrences of choice, and the second is \ndefined as follows: I 1 if s is a variable or choice ;:(lp'(tJ + w(r)) ifs = (t r) $72(s):= t)  If3 \nr (A x 2 * v2(r) + 92(t) ifs E (let x = r in t) I It is an easy task to check that all the reductions \n-% for p E {Ret, lapp, lbeta, nd} strictly reduce the measure. It is easy to extend this to sets using \nwell-foundedness of the corresponding multiset ordering. 0 set,let,nd Lemma 3.3 The reduction relations \n-% and + are locally confluent. Proof. For local confluence of 3, we have to check 5 non- trivial overlappings. \nWe show only for the overlap of the llet-rule with itself that there is a common reduct: (let x = (let \ny = (let z = t, in tY) in tz) in s) reduces either to (let y = (let .z = t, in tY) in (let x = t, in \n3)) or to (let 2 = (let z = t, in (let y = t, in t,)) in s). The first expression reduces in one further \nlet-reduction to (let z = t, in (let y = t, in (let 2 = t, in 3))). The sec-ond expression reduces as \nfollows: (let z = t, in (let x = (let y = t, in tl) in s)), which further reduces to (let z = t, in (let \ny = t, in (let x = t, in s))). The other compu-tations are similar. set,let,nd To check that + is locally \nconfluent, there are no extra nontrivial overlappings. The only nontrivial argument is that let-reductions \ncannot move a choice out of a reduction context. cl set,let,nd Proposition 3.4 The relations -% and ___$ \nare con- fluent. Proof. The Newman-lemma [New421 (see also [HueSO]) set,let,nd shows confluence of the \nrelation 2 and + using lem-mas 3.3 and 3.2. 0 3.2 Confluence of 3 The same technique as in subsection \n3.1 is used to show confluence of %. Definition 3.5 The measure $J is defined using an environ-ment parameter. \nFor closed expressions let $(s) := [s]~ 0. := p(x) [f:Tce] p := 2. := it] p[x c-) O] t&#38;J b t&#38;&#38;J \n:= b&#38; + WI~LP [(let z = s in t)]+p := [s]+p+ [t]+p where p := Pb I+ B+JJ + 11 Lemma 3.6 The relations \n-% and ..t,,q are terminating. Proof. The measure is strictly monotone in the measure of subexpressions. \n3 strictly reduces the measure 4. Since the measure is well-founded, -% terminates. A consequence set,cp \nis t,hat __) terminates. q Proposition 3.7 The relation 2 is locally confluent.  3.3 Confluence Theorem \n3.8 The relation %X,nd is confluent Proof. We use Lemma 3.3.6 in [Bar841 which states the fol-lowing: \nIf for all a, b, c: if a +i b, a +a c there exists some d, such that b &#38;J d,c <1 r d, then --%I \nand -%2 commute. set,lct,nd We use this lemma with +r := 3, -+s := w . We have to check the nontrivial \noverlappings and to show that the forking reductions can be joined according to the re-strictions. I.e., \nwe have to check the situations tl + t2, tl + t3 using the syntactical structure of expressions. l Case: \none reduction is an nd-reduction. Then there is no problem in joining, since a cp-reduction cannot duplicate \nthe nd-redex. l Case: One reduction is a let-reduction. Then one cp-reduction and 1 or 2 let-reductions \nare sufficient to join the reduction. The latter case is possible if the let-reduction is within an abstraction. \nset,let,nd,r The relations ___+ and -=% commute. The propo- sitions 3.4 and 3.7 and the commutation property \nnow show that the relation *X,nd is confluent. cl Example 3.9 The reduction +Qd would become non-set-confluent, \nif we would permit the choice-reduction in the body of abstractions: Consider the expression (let x = \n(A y . choice 1 2) in (z 0)+(x 0)), which results in {2,3,4} after the correct reductions. The wrong \nchoice-reduction would give {(let x = (X y . 1) in (x 0) + (x O)),(let x = (A y . 2) in (x 0) + (x 0))}, \nwhich results in {2,4}. 4 Normal order reduction sequences In this section we define normal order reduction \nand show that normal order reduction is sufficient to reduce expres-sions to HNF. This definition models \nthe normal order re-dex as an outermost redex that is demanded. This is a slightly more lazy variant \nof the normal order definition in [MOW98]. Definition 4.1 A normal order redex (n-o-redex) of a closed \nexpression t is defined using rules for shifting a la-bel E (for evaluation) up and down in the expression \nto a final position, thereby leaving as trace a label e and also a compound label describing the n-o-reduction. \nWe start with tE, where t is unlabelled. i) C[s ], and s is an abstraction or the constant choice. Stop, \nthe expression t is a HNF. ii) C[(r s) ] and r is an abstraction. Mark the expression in the brackets \nas (lbeta) and return. iii) C[(choice s)~]. Mark the expression in the bracket as (nd) and return. iv) \nC[(r s)~], and r is a variable or an application. Proceed with C[(rE s)~]. v) C[(r s)~], and r is a let-expression. \nMark the expres-sion in the bracket as (lapp) and return, vi) C[(let x = s in t)E]. Proceed with C[(let \nx = s in tE) ]. vii) C[(let x = (let y = t, in t5) in D[x ])]. Mark the expression in the bracket as \n(llet) and return. viii) C[(let x = r in D[xE])] and r is an abstraction or the constant choice. Mark \nthe expression in the [.]-bracket as (cp) and also with the context D[.], and return. ix) C[(let x = \nr in D[x ])] and r is an application or a variable. Proceed labeling with C[(let I = rE in D[x ])] The \nsubexpression that is finally labelled E is called the n-o-redex if it is not a lambda-abstraction or \nchoice, otherwise the whole expression t is a head normal form (HNF). The normal order reduction has \nto be performed such that the rule corresponding to the label is executed. The rule (cp) has to be performed \nsuch that the variable labelled E is replaced at the position indicated by the context D[.]. A reduction \nsequence that reduces only n-o-redexes is called a normal order reduction. Lemma 4.2 The following holds \nfor the labeling algorithm. The labeling terminates and either marks a unique n-o-redex or marks the \nwhole expression as a HNF. Every superexpression of an n-o-redex is marked e in the labeling. An n-o-redex \nmay only be subexpression of another re-dex of type cp or llet, but not in the expression to be copied \nby the cp-rule. It is also not a subexpression of another redex of type lapp, lbeta, or nd. Any n-o-redex \nand also the variable to be replaced is in the context W. An n-o-redex of type (cp) or (llet) is only \npossible in a let-context L[.]. A HNF is of the form L[(X y . t)] or L[choice] . Lemma 4.3 Let t be a \nHNF. If t + t then t is a HNF. Lemma 4.4 Let t be a closed expression with an n-o-redex. If t + t , by \na non-n-o-reduction, then t is not a HNF. Proof. If the redex in t ----+ t is not labelled e, this is \nobvious. Otherwise, this redex is marked e. It is an easy exercise to check the cases where the reduction \nis of type llet or cp. 0 Corollary 4.5 The last reduction before reaching a HNF is a normal order reduction \nof type (cp) or (lbeta). In the following we show that an arbitrary reduction to a HNF can be turned \ninto an n-o-reduction by commuting the reductions. A non-n-o-reduction is also denoted as i(nternal) \nreduction. In order to ease notation, we denote a sequence of reductions as words: 3 is denoted as (a, \np) for all types nqnd I of rules and for a E {no, i}. For example __) o z is denoted as (no, nd) o (i, \ncp). We will use meta-reductions on sequences of reductions. Definition 4.6 Let t be a closed expression. \nThe reduction t 7 t is defined as follows: For x, y 6 &#38;t(t) let x <. y, ifl (let y = t, in s) is \na subexpression oft and x occurs in t,, and let < be the transitive closure of <* . Select an antichain \nW s V&#38;t(t), i.e. the variables in W are not related by <. Then define the relation cppa:~ for subexpressions \ns oft as follows:  CPPar0 x-WI  . x cppa:w tl, if x E W and x is let-bound in t to the abstraction \nt,, and tk is a renamed version of t,. CPPar l choice --+w choice  cppar a If (31 ~2) is a subexpression \nof t, and s1 +W s;, s2 xW sb, then s1 s2 ZW si si. fPPar . If (A z ~1) is a subexpression oft, and s1 \n-----+w s{, then (A z . ~1) ZW (A z . s:). l Let (let 2 = t, in st) be a subexpression of t. CPPar I \nIf sz Cppa:W s;, t, ww t,, then (let z = t, in sz) 5~ (let z = t: in s:). Note that if ZEW thens,=s:. \n Let t z t i# t cppa:w t for some antichain W. Lemma 4.7 If t x t , then t x t , where the re-ductions \ncan be performed in any order. Moreover, there is at most one n-o-reduction among them. This n-o-reduction \ncan be shifted to the left. We give an explanation of the notation in the following lemma: (i, a) o (no, \nb) u (no, b) o (i,a) means Vtl, t2, t3 : t1 z,a t-2 z t3 j 34 : t1 z t4 I t3. Lemma 4.8 Every i-reduction \nfollowed by normal order re-ductions can be shifted to the right according to one of the following rules: \n(i, a) o (no, b) + (no, b) o (i, a). (i, a) o (no, b) u (no, b) o (no, a) for a # cppar. (i,a) 0 (no,cp) \ncr, (no,cp) 0 (no,a)? 0 (i,a)*, for a # nd, cppar. (i,cppar) o(no,a)u (no,a) o(no,cp)* o(i,cppar) . (i, \nllet) 0 (no,lapp) 0 (no,llet)? 0 (no, lapp) 0 (no,llet) -+ (no,lapp)W o (no,llet) o (a,llet) where (a \nE {i, no}) and UJ 2 0. Theorem 4.9 Let t be a closed expression. If t -% t where t is a HNF, then there \nis a HNF t , such that t no,: t and t -G t . Proof. We use the previous lemmas. Let t -% t be a reduction. \nWe use as meta-reduction strategy to shift the rightmost i-reduction to the right dropping the i-reductions \nafter reaching a HNF. The following well-founded ordering shows termination of this meta-reduction, since \nit is strictly decreased in every meta-reduction. It is a lexicographic ordering of four components. \nThe first component is the number of (i, cppar)-reductions. The sec-ond is a multiset of the following \nnumbers: For every i-reduction: the number of (no,cp) reductions that are right of it. The third component \nis the total number of internal reductions. The fourth component is the number of n-o-reductions to HNF \nright of the rightmost i-reduction. It is easy to see that this measure is well-founded and that every \nmeta-reduction on the reductions to HNF strictly de-creases this size. Hence the meta-reduction will \nend with a reduction that is a sequence of n-o-reductions followed by a sequence of i-reductions to a \nHNF. The i-reductions retain the property of being a HNF, hence the theorem holds. q Corollary 4.10 If \nan expression can be reduced to HNF, then an n-o-reduction sequence has the smallest number of nd-reduction \nsteps. Corollary 4.11 Every infinite n-o-reduction contains an infinite number of cp-reductions and an \ninfinite number of beta-reductions Proof. The only rule that may increase the measure $ is the rule lbeta. \nOn the other hand, the only rule that can increase t,he measure cp is cp. 0 5 Contextual Equivalence \nIn order to prove correctness of optimized lambda-lifting and to clarify the connection with the deterministic \nlambda cal-culus, the criterion of contextual equivalence [AbrSO, How891 is required. We will use a rather \nstrong criterion including termination as well as non-termination. Definition 5.1 Let s, t be (open) \nexpressions. Then s wC t, i# the following holds i) For all contexts C[.], such that C[s], C[t] is closed: \nC[s] has a reduction to HNF iff C[t] has a reduction to HNF. ii) For all contexts C[.], such that C[s], \nC[t] is closed: C[s] has an infinite n-o-reduction, iflC[t] has an infinite n-o-reduction. Note that \n-C is a congruence, which can be proved straight-forwardly. To justify the second requirement, consider \nfor example the two expressions 0 and Y(X x choice z 0), where Y is the usual fixpoint combinator. Clearly, \nthe two expressions be-have differently, and are also different using our definition, but would be equivalent \nwithout the requirement ii). We define a relation similar to a parallel reduction in [Bar84]. Definition \n5.2 Let t be a closed expression. The relation s is defined as follows: First select a set W c Vi,,(t), \nwhich is an antichain w.r.t. to the ordering defined in defy-nition 4.6. Then consider the subexpressions \noft and define the relation S\\W. l choice Par ----+w choice l Par x-w-7: l (app) Ifs parw s , r parw \nr , then (s r) ZW (s r ). l (lam) Ifs CW s , then (A x . s) zw (A x s ). Par Par l (let) Zf r ---+w r \n, s +W s , then (let x = rz in .sI ) 5~ (let I = r: in s:). If x E W, then r5 E r:. (cp) x parw t; if \nx E W and x is let-bound to the abstraction t, in t and tk is a renamed version oft,. (lapp) if t, parw \nt6, s5 Gw s:, r Cw r , then ((let x = t, in s ) r) Zr.v (let x = tl, in s: r'). If x E W, then t, G t:. \n(lbeta) If t, parw t:, s 5~ s , then ((A x . tz)s) Zw ((let x = s in tk) Par Par Par (llet) If t, -----+w \nt:, t, -----+w th, and s ------+w s', then (let x = (let y = t, in t%) in s) 5~ (let y = t , in (let \nx = tl, in s')). If y E W, then t, E t&#38;. Let t Z t ifl t -%.Lv t for some antichain. Not,e that an \n(nd)-reduction is not permitted in the par- relation. Lemma 5.3 If t Z t , then there is a sequence \nof re- ductions (using the basic calculus) from t + t , such that the reductions can be performed in \nany order. It is possible to arrange the sequence, such that all normal order reductions come first. \n Proof. That the reductions can be performed in any order follows from the definition. The normal-order \nreductions can be shifted to the left using Lemma 4.8. 0 In the following we use the wording complete \nset of fork- ing (commutation) diagrams for a relation P. A com- plete forking (commutation) diagrams \nmeans a set of meta- reduction rules, such that for every maximal n-o-reduction sequence red, the prefix \nof every reduction sequence &#38; ored (L ored) can be meta-reduced. Note that these complete sets are \nnot unique. Lemma 5.4 In the following we consider only par- reductions consisting of internal reductions. \nA complete set of forking diagrams for par is: 7%0,LZ,* no,b ii) to/o 3 X+ ~ o~whereafnd. TW,llet,+ \niii) yet*+ o z,pa: ^rt s,pa:,? o ~ . n0,10CZ,* no,laPP 7W,l0Cl,* -o -o iq u r,par,? no, aPP i?J) ---+o+----00. \n Proposition 5.5 Let t, t be closed expressions such that t q t . Then t wC t : Proof. Note that it \nis not necessary to use the context C[.], since the par-reduction does not contain an nd-reduction, and \nhence has no restrictions of applications in an expres- sion. If t has a HNF, then t prime has an n-o-reduction \nto HNF, which follows from Theorem 4.9. If t has an infinite n-o- reduction, then the diagrams in Lemma \n4.8 and corollary 4.11 show that there is also an infinite n-o-reduction for t. Now assume that there \nis an n-o-reduction for t ending with a HNF. The diagrams in Lemma 5.4 show that by induction on the \nlength of an n-o-reduction of t, we get also an n-o-reduction for t . If the n-o-reduction for t is infinite, \nthen the diagrams show that we can shift the (i,par) down the n-o-reduction for t and that we can produce \nan infinite n-o-reduction for t . Corollary 5.6 Let t, t be closed expressions such that t + t by a \nnon-ad reduction. Then t wC t Proof. Every one step non-nd-reduction is also a par-reduction. q Note \nthat this is not true for nd-reductions, since nd nd (choice 0 I) ---+ I, and (choice 0 I) __$ 0, hence \n(choice 0 I) has a finite as well as an infinite n-o-reduction, but -L has only an infinite one. Thus \n(choice 0 I) $c 1. 6 Behavioral Equivalence of the Rules ldel and lcv In the following we give forking \nand commutation diagrams for the reductions in Table 2 in the same way and under the same conditions \nas in Lemmas 5.4 and 4.8. The rule (ldel) is the garbage collection rule, whereas (lcv) corresponds to \nan elimination of indirections. Lemma 6.1 A complete set of commutation diagrams for (ldel) is: l ldel \no (no, a) --+ (no, a) o ldel. l ldel o (no, cp) w (no, cp) o ldel o ldel. l ldel o (no,lapp)wt o (no,lZet) \n^rs (no,lapp)ws o (no, llet)ko(no, lapp) + o(no, llet)ko ldel, where w >_ 0 and k E (0, 1). l ldel o \n(no, llet) c\\it (no, llet) o (no, llet) o ldel l ldel o (no, p) u (no,lapp) o (no, p) o Zdel, where p \nE {nd, lbeta} For (ldel) the forking diagrams are a sufficient set of meta-reductions that met.a-reduce \nevery reduction sequence of the ldel form tl ----+ tz together with an n-o-reduction starting from tl \ninto another sequence. Lemma 6.2 A complete set of forking diagrams for (ldel) is: no,a ldel ldel n ,a \nbi----00 13 --+O+----   ?KJ,CP ldel no,CP ldel ldel bt-00 -A +o+o+--. no, aPPldel ldel l e----o--+ \ncvt -. nqllet ldel ldel l +---00 -A ___). Theorem 6.3 Let t, t be closed expressions and t ldef t . \nThen t wC t . ldel  F-w g b , , ~o=o~c~~~~ces CM ofF (lcv) C[(let x = y in D[z])] Icv C[(let x = y \nin D[y])] where y is a variable Table 2: Extended rules of AZ, Proof. Let t Ide! t and assume there is \nan n-o-reduction for t , finite or infinite. If the n-o-reduction is a finite one to a HNF, then use \nas a measure for meta-reductions the fol-lowing lexicographical ordering of three components: i) the \nmultiset of: for every ldel-reduction, the number of (no,cp) that are right of it. ii) The total number \nof ldel-reductions, iii) the number of n-o-reductions to HNF right of the right-most ldel reduction. \nIt is easy to see using the commutation diagrams for ldel, that this measure is strictly decreased if \nthe rightmost ldel is shifted and an ldel for a HNF are elim-inated. If the reduction for t is infinite, \nthen the number of its (no,cp)-reduction steps is infinite. We show by induction on the number of (no,cp)-reductions \nin a normal order reduc-tion sequence of t , that shifting ldel s to the right does not change this number. \nBy using the strategy to shift all ldels over the first (no,cp), then all ldel s over the second and \nso forth, we get an infinite normal order reduction for t. Now assume that there is an n-o-reduction \nfor t. Now we have to use the forking diagrams in lemma 6.2. Using as main measure the number of (no,cp)-reductions \nin a se-quence, it is easy to see that for a finite as well as for an infinite normal order reduction, \nwe can construct a hnite (infinite) normal order reduction for t . 0 Lemma 6.4 A forking of an n-o-reduction \nand an internal cppar-reduction can be meta-reduced according to one the following rules. no,o t,cPPar \ni,cppar no,a l t00 w ---+Ot- no,cp,* no,b : 1 CPPar i,cppar,? no,b 0 tot-o--__) of-.  Proof. The main \narguments are: an internal cp cannot copy an n-o-redex nor the into-position of an (no,cp)-redex. The \nsecond rule covers the case that there may be an normal-order reduction in the (i,cppar) after another \nn-o-reduction. 0 Lemma 6.5 A complete set of commutation diagrams for lcv is: 0 lcff 0 (no,a) -+ (no,a) \n0 lcu. 0 lcv 0 (no, cp) cv) (no, cp) 0 lcu 0 lcu 0 zcv 0 (no,cp) -A (no,cp) 0 (a,cp)o Z where a E (6 \nno) Lemma 6.6 A complete set of forking diagram8 for lcv is: no,a lcv lcv no,a l to---+ ?$ -0t. no,CP \nlcu lcv lcu no,CP rtoo -----)O~O+----. no,cP no,CP lcv i,cp no,CP 0 t-0000 -4 tot. no,cp 1CU i,cp i,cp \nno,CP l too -A *ot00. We require a special measure for lcv. Definition 6.7 The measure t is defined \nusing an environ-ment parameter. For closed expressions rue define c(s) := BJBE 0. := p(x)6Xl~P [choice]l \np := I[(X x . := ;tj p[x I-) O] tf&#38;P UJ t&#38;P := 2 *c[s]cP + [t&#38;p [(let x = 3 in t)](p := \n[slep+ [t&#38;p where p := P[X e I[s]~P + a] where a = 0 ifs is a variable. Otherwise: a = 1. Lemma 6.8 \nIf t Y, t for y E {ZZet,Zapp,cp,nd}, then E(t) > ((t ). If t Icq t , then r(t) = t(t ) Proof. Evaluate \nthe expressions before and after application of the rules and compare the measures. 0 Icv Theorem 6.9 \nLet t, t be closed expressions and t __) t . Then t wC t . Proof. First let a normal order reduction \nfor t be given. We use induction on the number of lbeta-reductions and the size [(t ). First assume that \nthe reduction is finite. We make induction on triples (t, t , red), where red is a nor-mal order reduction \nfrom t to HNF. The induction ordering is: (tl, t;,redl) < (tz, t;, redz), iff (#(lbeta,redl),[(tl)) < \n(#(lbeta, reds), t(h)) in the lexicographical ordering. The induction hypothesis is that we can find \na normal order re-duction for t with the same number of lbeta-reductions. We go through the three possibilities \nin Lemma 6.5. In the first diagram, induction is easy. In the second diagram, let t x tl -% t2 2 t3 :o,cp \nt . Lemma 6.8 shows that we can apply the induction hypothesis first to the triple (t2, t3, reds), where \nred = t 2 reds. Then we can use the hypothesis for the triple (tl, tl, reds), where reds is the existing \nn-o-reduction for t2. In the last diagram, we use Lemma 6.4 and 4.8, which shows an (i,cppar) reduction \nin front of a normal order reduction leaves the number of lbeta reductions unchanged. Since lcv keeps \nthe property of being a HNF, we have shown that there is a finite n-o-reduction to a HNF starting from \nt. If the reduction starting from t is infinite, then we use the same arguments for the claim: the number \nof lbeta reduc-tions of a normal order reduction of t is greater than n . This permits to construct an \ninfinite n-o-reduction for t. Let t have a finite or infinite n-o-reduction. Similar as above, we base \nthe proof on the number of lbeta-reductions in a n- o-reduction of t and t . 0 7 Deterministic subexpressions \n In order to provide optimized lambda-lifting and to clarify the relation to the deterministic lambda \ncalculus, we iden-tify certain subexpressions that can be copied as they can be in the deterministic \nlambda calculus. This is not in-tended as an operational rule for an implementation, but only for proving \ncorrectness of lambda-lifting with deter-ministic maximal free expressions, and also of correctness of \nthe usual lambda-calculi rules in the absence of choice. Definition 7.1 Let t be a closed expression. \nThen a subex- pression s oft is deterministic iff s is an expression without occurrences of choice, which \nis either closed, or in which all free variables are let-bound variables and moreover, all the let-bound \nvariables are bound to deterministic subexpressions ojt. Definition 7.2 A subexpression oft is reproducible, \ni@ it is either a lambda-abstraction, a variable, the constant choice or deterministic. The following \nrule (pdcp) is a parallel copy rule that is di- rectly related to the lambda calculus. The rule (pdld) \nde-fined below is used for technical purposes. Deflnition 7.3 Let t be a closed expression. The reduction \nt s t is defined as jollows: Use the same ordering < as in Lemma 4.6 Select an antichain W E K,t(t), \nsuch that the variables in W are introduced by lets, and all terms let-bound to a variable in W are deterministic. \nThen define the relation -f%~ for subexpressions s oft as jollows: PdcP 0 x-----+wx l x pdcpw tl, ijx \nis let-bound in t to the (deterministic) expression t,, and t: is a renamed version oft,. PdcP l choice \n-----+w choice PdcP l If (81 82) is a subexpression of t, and 81 -----+w s;, pdcp PdcP sa *w si, then \n81 sa +w 8; 81. b Ij(X z . 81) is a subexpression oft, and s1 zW si, then (X z 81) SW (X z . 9;). a Let \n(let z = t, in sz) be a subexpression of t. Pdv , i-j sa pdcpw s:, t, *W t,, then (let z = t, in sZ) \n3~ (let z = t: in 8:). Note that if ZEW thent,=t:. Let t 3 t i# t 3~ t for some antichain W. Note that \npdcp may also copy (deterministic) variables. Definition 7.4 Let t be a closed expression. The reduction \n t z t is defined as jollows. Select a set W c K,,(t), such that the variables in W are deterministic. \nThen define the relation SW for subex- pressions s oft as jollows: pdld x----+wx pdld choice ----+w \nchoice pdld If (81 82) is a subexpression oj t, and s1 *w si, pdld pdld 32 ------+w 84, then 31 32 +W \n8; s;. pdld Ij(Xt. 81) is a subexpression oft, and 81 *w s;, then (X z . 81) -fff+~ (X z . 8:). Let (let \nz = t, in sz) be a subexpression of t. Let pdld s, --$w 8:. If z E W, then let t, E t:. Other-pdld pdld \nwise, let t, *W t: and (let z = t, in sZ) ----+w (let 0 = ti in s:), pdld Let s1 ----+w 82. If x E W, \nlet the subexpression oft be (let x = t, in s=), such that 81 is a subexpression ojs,. Then sy -ff%w \n(let x = tk in s;), where tk is a renamed version of t, and s: is a version of 92, where any occurrences \nof x are renamed by x . Let t -ff+ t iff t -ff%w t for some W. Lemma 7.5 All reductions in And , Xz, \nand the reductions pdcp, pdld preserve the property that a subexpression is de-terministic. Proof. An \neasy analysis of the cases. 0 We give the commutation and forking diagrams for pdcp and pdld We assume \nthat pdcp is internal, i.e., has no normal order component. Lemma 7.6 A complete set of commutation diagrams \njor (pdcp) is: pdcp o (no,a) ?+ (~,a) o (no,cp) o pdcp?, where a means a reduction in the base calculus. \npdcpo(::;;r! A (no,Zlet)*o(no,cp)o(no,cp) opdcp?o t,CP pdld o &#38; 0+. pdcp o (no, cp) -.+ (no, cp) \no (no, cp)? o pdcp o c pdcp o (no, a) ?A (no, a) o (no, cp) o pdcp?o :,,,. for a E {lbeta, Zapp}. pdw \n0 (wbp) -(no,Zlet) o (no,cp) o pdcp? o t,llet.* pdldo +------. pdcp o (n~,~U~et)~~ (no, Zlet) o (no, \ncp)? o pdcp? o pdld o (i,Zlet) o I). Lemma 7.7 A complete set of commutation diagram8 for (pdld) is: \nl pdld o (no, nd) -rs (no, nd) o pdld. l pdld o (no, Q) cr) (no,a) o pdldo z for all a E {cp, llet, lapp, \nlbeta}. l pdld o (no, a) + pdld for a E {lapp, llet}. Proof. There are less complications than in the \ncommutation case for pdcp. We illustrate a complex case: (let y = (let x = t, in tY) in y) --ff$ (let \ny = (let x = t, in tY) in (let y = (let x = t, in tY) in y)) no,llet 4 (let y = (let x = t, in tY) in \n(let x = t, in (let y = t, in y))). The other reduction gives: (let y = (let x = t, in tY) in y) no,llel \n(let x = t, in (let y = t, in y)) pdld ----+ (let x = t, in (let y = t, in (let x = t,llet tl, in \n(let y = tl, in y )))) t-. The pdld reduction in the second reduction sequence fulftlls the condition \nof the defi-nition, since the replaced positions are not within a copied body. q In the following we \nuse the measure of a reduction sequence ~1 that is a pair, compared lexicographically, where the first \ncomponent ~1 is the number of nd, lbeta, and cp-reductions, and the second component ~2 is the measure \ncp defined in subsection 3.1. Lemma 7.8 Let an n-o-reduction red from t (to a HNF) be given. If t -f+ \nt , with p E {llet, lapp,cp,lbeta}, then there is an n-o-reduction red from t (to a HNF) with pl(red \n) 5 pl(red) Proof. Follows from lemma 5.4 q Lemma 7.9 Let an n-o-reduction red from t (to a HNF) be given. \nIf t % t , then there is an n-o-reduction red from t (to a HNF) with pl(red) = pl(red ) Proof. Follows \nfrom lemma 4.8 q Lemma 7.10 Let t % t . Ijt has an n-o-reduction red to a HNF, then t has an n-o-reduction \nred to a HNF, where ~(red) 5 ~(red ). Proof. We use lemma 7.7. The second diagram in lemma 7.7 has a \nbackward reduction, for which we need Lemma 7.8. q pdld Lemma 7.11 Let t ---+ t . If t has an infinite \nn-o-reduction red , then t has an infinite n-o-reduction red. Proof. We use lemma 7.7. The second diagram \nin lemma 7.7 has a backward reduction, for which we need lemma 5.6. For the third diagram we need the \nargument that an infinite n-o-reduction cannot contain solely of lapp, llet-reductions. q Lemma 7.12 \nLet t -ff? t . Ij t has a finite n-o-reduction to HNF, then t has a finite n-o-reduction to a HNF. Proof. \nBy induction using the following lexicographically PdcP ordered measure: Let t __) t and red be a n-o-reduction \nto HNF from t . Then the first component of the measure is p(red ), the second is t(t). If the first \nreduction from t is of type nd, lbeta, or cp, then the diagrams in lemma 7.6 show that the first component \nis sufficient to use the induction, where lemmas 7.8, 7.7, and 7.10 are used. If the first reduction \nin red is a llet or lapp-reduction. Then the corners of the diagram are t % tl, t -t , t z t2. The tail \nof the n-o-reduction red is red;. We use for t,he last diagram in lemma 7.6, the claim of lemma 7.9 to \nshow that pl(reda) 5 pl(red ). In any case, we can apply the induction hypothesis since ((tl) < E(t). \nIf t is already a HNF, then t is also a HNF. q Lemma 7.13 Let t z t . If t has an infinite n-o-reduction \nred, then t has an infinite n-o-reduction. Proof. By induction on ~1. The diagrams show that there is \na reduction sequence no,t Pdcp t ----+ t1 -----+ t;. It is easy to see for all cases of di-agrams in \nlemma 7.6 that if t has an infinite n-o-reduction, then t; has an infinite n-o-reduction, where lemma \n7.11 and lemma 5.6 is required. Since every such step adds at least one n-o-reduction to the n-o-reduction \nsequence after t, we can construct an infinite n-o-reduction for t. q Lemma 7.14 A complete set of forking \ndiagram8 for inter-nal pdcp is: nqcp,? no,a   Pdcp ?$ PdfPO no,a l +---0+--o no,cp,? no,a p* Lv) \npdcp i+h* nola a+----0+--o 0 to tjor a E {lapp, lbeta, cp}. %Xcp,? ?W,llet pdld,? i,llet,r pdcp u pdcp \nl +----000 *o*o+ nqllet,? O+------. Proof. By checking the possible overlaps using the same techniques \nas before. q Lemma 7.15 A complete set of forking diagrams for (pdld) is: no,a .+----Opdld -4 9 o x for \nall a in the base calculu8. no, no,loa,* .+--o 2 crs pd 0 Zo Zo t---for all a E {lapp, lbeta, llet} \n. no,llet , +o,d$ 2$ pdleO+-, Proof. By checking the possible overlaps. u Lemma 7.16 Let t 5 t such \nthat t has a finite n-o- reduction to a HNF. Then t has a finite n-o-reduction to a HNF. Proof, By induction \non the length of an n-o-reduction of t, the diagrams in lemma 7.15 show that there is a mixed reduction \nfor t to a HNF. Theorem 4.9 shows that there is also a n-o-reduction to some HNF. 0 Lemma 7.17 Let t \na t such that t has a finite n-o- reduction to a HNF. Then t has a finite n-o-reduction to a HNF. Proof. \nBy induction on the length of an n-o-reduction of t, the diagrams in lemma 7.15 and lemma 7.16 show that \nthere is a mixed reduction for t to a HNF. Theorem 4.9 shows that there is also a n-o-reduction to some \nHNF. 0 Lemma 7.18 Let t s t such that t has an infinite n- o-reduction. Then t has an infinite n-o-reduction. \nProof. We show by induction on the number of lbeta- reduction, that if t has an n-o-reduction with more \nthan n lbeta-reductions, then this holds also for t . First, if s s s and s has an n-o-reduction with \nmore than n lbeta-reductions, then we can construct a mixed re- duction for s with not less than n n-o-lbeta-reductions \nby lemma 7.15. The commutation lemma 4.8 then shows that there are at least n lbeta-reductions in the \nn-o-reduction after using the commutation rules. We use lemma 7.14 to show that the same arguments apply \nto pdcp. Finally, every infinite n-o-reduction has an infinite number of lbeta-reductions, hence the \nlemma holds. 0 Theorem 7.19 If t dcp t , then t wC t Proof. Follows from lemmas 7.12, 7.13, 7.17, 7.18. \n0 8 Lambda-lifting using deterministic maximal free expressions In general, lambda-lifting using expressions \nlarger than vari-ables (maximal free expressions in [PJ87]) is not correct for non-deterministic reduction. \nHowever, it can be used for expressions that do not use choice, i.e., for deterministic maximal free \nexpressions (dmfe). We provide a definition that generalizes lambda-lifting: Definition 8.1 Let C[D[tl \n, . . . , tn]] be an expression, such that the t, are reproducible expressions. Then the following relation \ngeneralizes dmfe-lambda-lifting: C[D[tl, . , tn]] -li-dmfe C[((XZl,. . . ,z*.D[z1,. . . , Zn] t1 . . \n. tn)] where zs are fresh variables. Theorem 8.2 Let C[D[tl, . , tn]] be an expression, such that the \nt, are reproducible expressions. Then C[(Xz,, . . . , Z,.D[Zl,. . . , zn]) t1 . . . tn] NC C[Lql,. . \n*, tn]] Proof. Using Theorem 7.19, 6.3 and 6.9 we show that the lambda-lifted expression is contextually \nequivalent to the previous one. C[(Xzr, . . . , z,.D[zr, , zn]) tl . . . tn] wC C[(let ZI = tl in Xzz,. \n. ,zn.D[zr,. . . , zn]) tz . . . tn] pdcp ( Ica C[(let = tl in Xrz,. . . , z,.D[tl, 22 , zn]) tz . tn] \nldel C[(Xz2,. . , z,.D[tl, z2 . . . , zn]) t2 . . . tn]. By induc-tion on n and using the lemmas above, \nwe obtain the claim that this is NC C[D[h, . , tn]]. 0 In general, lambda-lifting using arbitrary maximal \nfree ex-pressions [PJ87] is not correct for non-deterministic reduc-tion: Example 8.3 The expression \n(let z = Xx.(choice 1 z) in (z 0) + (z 0)) has {O,l, 2) as possible results. Using unrestricted lambda-lifting \nwith Max-imal free expressions, the following expression would result: (let z = (Xy.Xz.(y z)) (choice \n1) in (z 0) + (z 0)), which has as possible results {0,2}. Example 8.4 This example demonstrates that \nthe rule let-over-lambda is not correct in the catcutus And. The expressions (let x = t, in (A y . ty)) \nand (ihy (let I = tz in ty)) are not behaviorally equivalent: expression (let z = (let E = choice 0 1 \nin (A y . x)) in (z 0) + (z 0)) has as possible results {0,2}, whereas (let t = (A y . (let z = choice \n0 1 in x)) in (z 0) + (z 0)) has (0, 1,2} as possible results. 9 Relation to classical lambda calculus \nWe consider the usual lambda calculus with ,&#38;reduction and P-equivalence, where we assume implicit \na-conversions. Let T be a translation of choice-free expressions with r((let z = s in t)) = ((A x t) \ns). Then the following holds: Theorem 9.1 Let s, t be choice-free closed expression. Then T(9) B, T(t) \n=i' 3 NC t 9 iA,,&#38; t =k' T(8) &#38; T(t). Let t be an expression without lb&#38;o-redex. Then t e \ns in Hh F ifs r(t) can be reduced to a HNF as follows: First mark all /3 - redexes in the expression; \nthen reduce the expression using a normal order strategy, where only marked redexes are allowed to be \nreduced. Proof. The first implication follows from Theorem 7.19. The second implicat,ion follows straightforwardly \nby proving this for the reductions llet, lapp, cp, and lbeta. The third claim holds, since if t is a \nHNF w.r.t. &#38;d,r.&#38;, the transformed expression can be reduced to a HNF by first marking the redexes, \nthen reducing only the marked redexes. The other direction follows, since every redex of T(t) corresponds \nto a let-expression in t. 0 10 Remarks 10.1 Supercombinators A common step in compiling lazy functional \nprogramming languages is to transform expressions into a set of defini-tions of supercombinators. This \nrequires lambda-lifting or an equivalent technique, which is clarified in Theorem 8.2. Further transformations \nby extracting non-recursive super-combinators do not present a problem. 10.2 Recursion The fixed point \ncombinator Y := Xf . (AZ . f(~ z)) (XX . f(~ x)) is sufficient to express recursion. It is a fixed point \ncombinator, since for a lambda-expression F: Y F -+ (let f = F in (XX f(~ x)) (XX f(z x))) ldef (Xx . \nF(z z)) (Xx . F(x z)) -&#38; (let x = CAY. F(Y Y)) in F(x xl)) 5. F((~Y. F(Y Y)) (XY . F(Y Y))). Using \nthe criterion of behavioural equivalence it appears to be~pissible in to use Y implemented as a cyclic \nfixed-point combinator if F is deterministic or a lambda abstraction of at least two arguments. However, \nsee the discussion on re-cursion in [MOW98]. For recursively defined constants that are not deterministic \nlike the constant L := choice 1 (l+L), a noncyclic implementation of Y is required. 11 Applications of \nthe calculus X,d Natural EL [HNSSH97] is a lazy functional programming language that uses direct calls \nfor I/O. The implementors based the compiler on [PJ87], but they soon detected that the transformation \nrules did not properly work in this frame-work. In particular the lambda-lifting rule using maximal free \nexpressions once introduced an infinite loop by using the value of a previous I/O-action instead of repeating \nthe I/O. This was remedied by lambda-lifting variables only. There are also other restrictions in Natural \nEL, for exam-ple Natural EL uses a non-cyclic Y-combinator. Recently, Nigel Hutchison told me that the \noptimzations crossed let-boundaries, but not X-boundaries. Happily, the combination of all the methods, \nin particular sharing of nodes, finally produced a lazy functional programming language with an easy-to-grasp \noperational behavior. The calculus X,d can be seen as an important part of the theoretic foundation for \nsuch a language and for a com-piler based on transformations into supercombinators. The I/O-calls can \nbe modeled in &#38;d as a big choice-expression. The results on deterministic subexpressions are of practical \nadvantage in that they provide an (easily) decidable crite-rion to use optimizing transformations, for \nexample lambda-lifting with maximally free expressions. The effect of using &#38;d in a lazy functional \nprogramming language can be illustrated by three applications: i) The usage of a trace functions that \noutputs a certain text by a direct call and then returns True. The trace expression is simulated by (choice \nTrue I) and thus cannot be optimized away. ii) Calling a random number generator using a direct call \nis easily possible. An infinite list of random numbers could be defined bv randlist = (rand 0) : randlist. \nInterestingly, t,he logical sequence may be different from the sequence of calls t.o the random oracle. \niii) Several threads of execution are possible by simply permitting (conserva-tive) parallel evaluation. \nFor example, parallel evaluation of the expression askint 0 + askint 0 using an appro-priate user interface \nwould behave as follows: Two windows asking for a number are opened, the user can decide which to answer \nfirst or second. Only if both are answered, the sum is returned as a result. 12 Related work There is \na lot of work on non-deterministic computation. It is impossible to cite or discuss the literature in \ndepth. We confine ourselves to a selection of papers that is concerned with higher-order functions and \nnon-determinism. There are papers that investigate combinations of lambda-calculi where a fixed (strict \nor call-by name or call-by value) reduction strategy is used e.g. [Man95]. Some other ap-proaches [Ong93, \nDP95, San941 do not take care of shar-ing properties and thus suffer from the implicit choice -problem \nmentioned in the introduction. Bottom-avoiding choice operators like amb or por as inves-tigated for \nexample in [HOgO, H089, HM92, Bou94] cor-responds to the operational semantics of (local) speculative \nevaluat.ion; i.e. it is not like a committed choice. In [Bou94], confluence of a calculus using (por) \nis shown, which is related to the properties of And, but the calculi are different, since Xnd builds \nupon a stronger contextual equivalence (Defini-tion 5.1) and t,hus justifies a different set of valid \nprogram transformations. In [Pat911 similar ideas are developed for an application in the field of functional-logic \nprogramming, but rigorous con-sideration of the operational behavior are missing. [AC791 also considered \nsharing (of ground expressions) as an im-portant, technique for modeling non-determinism. However, their \ncalculus is also different, since they included the let-over-lambda rule, which is not correct in our \nsetting (see Example 8.4). Explicit sharing in functional programming is also a base for investigations \nin optimal reductions [Yos93, ACCL91] and in [Lau93] for a better understanding of implementations of \nlazy functional programs. Our calculus can be seen as a generalization of the calculi in [MOW98, AF97] \nthough there are some differences. In [MOW98], the core calculus has garbage collection (ldel) as an \naddibional rule, which seems to be not the minimal calculus. The normal order reduction in [MOW981 is \nde-fined differently: it uses strict evaluation of the let-rules, whereas ours is i lazy . There are \nonly slight differences, for example lengths of normal order reductions are in some examples longer than \nfor our calculus (there may be more llet s). We have not explored the way to base the proof on their \nn-o-reduction, but experience shows that the proofs based on diagrams are very sensible to minor changes \nin the rules. The proofs of our theorems in a setting based on the normal order reduction definition \nof [MOW981 would be very different and perhaps more complex. The calculus in [AF97] models almost only \nthe normal order reduction and thus has a narrow range of program transfor-mations. 13 Further Research \nThe extension of our calculus to non-strict functional lan-guages using constructors and a polymorphic \ntype system has to be investigated. A more detailed analysis of the input-output behavior of a functional \nprogramming lan-[How891 D. Howe. Equality in lazy computation sys-guage based on the non-determinism \nis required. The prop-tems. In 4th IEEE Symp. on Logic in Computer erties of choice as a parallel combinator \nhave to be clarified, Science, pages 198-203, 1989. where associativity, commutativity and idempotency \nappear [Hue801 G.P. Huet. Confluent reductions: Abstract to hold. An investigation in a semantics for \nAnd is in order. properties and applications to term rewriting syst,ems. J. of the ACM, 27:797-821, 1980. \n References [Lau93] J Launchbury. A natural semantics for lazy [AbrSO] Samson Abramsky. The lazy lambda \ncalculus. evaluation. In Proc. 20th Principles of Pro-In D. Turner, editor, Research Top&#38; in Func- \ngramming Languages, 1993. tional Programming, pages 65-116. Addison-Wesley, 1990. [Man951 L. Mandel. \nConstrained Lambda Calculus. Ver-lag Shaker, Aachen, Germany, 1995. [AC791 Egidio Astesiano and Gerard0 \nCosta. Sharing in nondeterminism. In Proc. 6th ZCALP 79, [MOW981 John Maraist, Martin Odersky, and Philip \npages 1-15, 1979. Wadler. The call-by-need lambda calculus. J. of Functdonal programming, 1998. to appear. \n[ACCLSl] M. Abadi, L. Cardelli, P.-L. Curien, and J.-J L&#38;y. Explicit substitutions. J. &#38;zctional \npro-[New421 M.H.A. Newman. On theories with a combi-gramming, 4(1):375-416, 1991. natorial definition \nof equivalence . Annals of Mathematics, 2~223-243, 1942. [Ach96] Peter Achten. Interactive functional \nprograms: models, methods and implementation. PhD the- [NSvPSl] E. NGcker, J. E. Smetsers, M. van Eekelen, \nand sis, Computer Science Department, University M. J. Plasmeijer. Concurrent Clean. In Proc Nijmegen, \n1996. o,f Parallel Architecture and Languages Europe (PARLE Sl), number 505 in LNCS, pages 202- [AF97] \nZ.M. Ariola and M Felleisen. The call-by-need 219. Springer Verlag, 1991. lambda calculus. J. functional \nprogramming, 7(3):265-301, 1997. [On@31 C.-H. L. Ong. Non-determinism in a functional setting. In Proc. \n8th IEEE Symposium on Logic [AFM+95] Z.M. Ariola, M. Felleisen, .J. Maraist, M. Oder-in Computer Science \n(LICS 99), pages 275-sky, and P. Wadler. A call-by-need lambda cal-286. IEEE Computer Society Press, \n1993. culus. In Principle3 of programming languages, pages 233-246, San fiancisco, California, 1995. \n [Pat911 Ross Paterson. A tiny functional languageACM Press. with logical features. In M.Coppo et.al., \nedi-tor, Declarative Programming, Sasbachwalden, [Bar841 H.P. Barendregt. The Lambda Calculus. Its pages \n66-79, 1991. Syntax and Semantics. North-Holland, Ams- terdam, New York, 1984.  [PHA+97] J. Peterson \n[ed.], K. Hammond [ed.], L. Au-gustsson, B. Boutel, W. Burton, J. Fasel, A. D. [Bou94] G. Boudol. Lambda-calculi \nfor (strict) paral-Gordon, J. Hughes, P. Hudak, Th. Johnsson, lel functions. Information and Computation, \nM. Jones, E. Meijer, S. Peyton Jones, A. Reid, 1085-127, 1994. and P. Wadler. Report on the programming \nlan-[DP95] U. De Liguoro and A. Piperno. Nondeterminis-guage Haskell: A non-strict, purely functional \ntic extensions of untyped X-calculus. Informa-language, Version 1.4, 1997. tion and Coinputation, 122:149-177, \n1995. [PJ87] Simon L. Peyton Jones. The Implementation of [HM92] J. Hughes and A. Moran. A semantics \nfor lo-Functional Programming Languages. Prentice-cally bottom-avoiding choice. In Proc. Glasgow Hall \nInternational, London, 1987. functional programming workshop 199,?, Work- shops in Computing. Springer-Verlag, \n1992. [PJLSl] Simon L. Peyton Jones and David R. Lester. Implementing Functional Languages: a Tuto-[HNSSH97] \nN.W.O. Hutchison, U. Neuhaus, M. Schmidt- rinl. Prentice-Hall International, London, 1991. SchauB, and \nC.V Hall. Natural Expert: A com-mercial functional programming environment. [San94] D. Sangiorgi. The \nlazy lambda calculus in a J. of Functional Programming, 7(2):163-182, concurrency scenario. Information \nand Com-1997. putation, 111:120-153, 1994. [HO891 J. Hughes and J. O Donnell. Expressing and [SS92] H. \nSondergard and P. Sestoft. Non-determinism reasoning about non-deterministic functional in functional \nlanguages. The Computer Jour-programs. In Glasgow workshop on junctional nal, 35(5):514-523, 1992. programmileg \n1989, Workshops in Computing, [Yos93] N. Yoshida. Optimal reductions in weak-X- pages 308-328. Springer-Verlag, \n1989. calculus with shared environments. In Proc. [HO901 J. Hughes and J. O Donnell. Nondeterminis-functional \nprogramming languages and com-tic functional programming with sets. In IV puter architecture, pages 243-252. \nACM press, Higher Order Workshop, Workshops in Com-1993. puting, pages 11-31. Springer-Verlag, 1990. \n \n\t\t\t", "proc_id": "289423", "abstract": "In this paper we present a non-deterministic call-by-need (untyped) lambda calculus &amp;lambda;<inf><i>nd</i></inf> with a constant choice and a let-syntax that models sharing. Our main result is that &amp;lambda;<inf><i>nd</i></inf> has the nice operational properties of the standard lambda calculus: confluence on sets of expressions, and normal order reduction is sufficient to reach head normal form. Using a strong contextual equivalence we show correctness of several program transformations. In particular of lambda-lifting using deterministic maximal free expressions. These results show that &amp;lambda;<inf><i>nd</i></inf> is a new and also natural combination of non-determinism and lambda-calculus, which has a lot of opportunities for parallel evaluation.An intended application of &amp;lambda;<inf><i>nd</i></inf> is as a foundation for compiling lazy functional programming languages with I/O based on direct calls. The set of correct program transformations can be rigorously distinguished from non-correct ones. All program transformations are permitted with the slight exception that for transformations like common subexpression elimination and lambda-lifting with maximal free expressions the involved subexpressions have to be deterministic ones.", "authors": [{"name": "Arne Kutzner", "author_profile_id": "81384619114", "affiliation": "Fachbereich Informatik, Johann Wolfgang Goethe-Universit&#228;t, Postfach 11 19 32, D-60054 Frankfurt, Germany", "person_id": "P21700", "email_address": "", "orcid_id": ""}, {"name": "Manfred Schmidt-Schau&#223;", "author_profile_id": "81100302294", "affiliation": "Fachbereich Informatik, Johann Wolfgang Goethe-Universit&#228;t, Postfach 11 19 32, D-60054 Frankfurt, Germany", "person_id": "P186785", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/289423.289462", "year": "1998", "article_id": "289462", "conference": "ICFP", "title": "A non-deterministic call-by-need lambda calculus", "url": "http://dl.acm.org/citation.cfm?id=289462"}