{"article_publication_date": "09-29-1998", "fulltext": "\n Verbose Typing Robert Ennals rje33Qcam.ac.uk Cambridge University (Undergraduate) 1 Motivation In type \nsystems that require one to manually specify types, one is constrained by practicality into having relatively \nshort types that can be read and written easily. This constrains the amount of information that can be \nencoded in a type, and forces one to restrict the expressiveness of the type sys-tem. Type inference \nsystems such as that of Haskell [l] improve things greatly by allowing the type system to infer types, \nbut still require types to be stated when declaring type classes. By removing such requirements to state \ntypes, we can grant ourselves the freedom to make types as large as we like, including much more information \nthan would otherwise be practical. One way to do this is by separating the concepts of a type identifier \nand a type constraint. 2 A Simple Type System In the proposed system, every object has its own indepen-dent \ntype, and has members. These are similar to functions in Haskell type classes [l] and to dynamically \ntyped object members. A member is identified by a unique name. The set of members of an object can be \nany subset of the global set of possible members, and the object may implement any member with any type. \nThe type is independent of the member identifier. Making the type of the member independent allows in-creased \nflexibility, especially useful in large complex systems. For example, one might have objects that wish \nto export windows with different abilities. This should be allowed, as long as all these windows satisfy \nthe constraints required by the function that is using them. Fixing the constraints of the implementation \nof a member prevents one from being able to make further requirements or provide less guarantees. Types \nare divided into type requirements and type guar-antees. If is implemented as a special case. Instead \nof requiring its arguments to have the same type, it allows its arguments to have any type, and the guarantee \nof its result is the intersection of the guarantees of its arguments. Like-wise, applying a function \nto its own result does not constrain the return type to be the same as the argument type. Example constraints \nare that an object must have a spec- ified member (which may also have constraints), be of a specified \nbase type, satisfy one of a list of constraints (for pattern matches), satisfy all of a list of constraints, \nor satisfy the constraints imposed by another function. Disjoint types are handled by giving one of the \nmem-bers an identifier type. This is a special type, that has no purpose other than to be used as an \nidentifier in pattern matching. All disjoint types are part of a global namespace, allowing anything \nto take on any set of disjoint types. Pat-tern matches can match several possible disjoint types and \nplace different requirements on other things, depending on which disjoint type is found. Matching is \nchecked entirely statically with no runtime match errors. If one has a concept of a reactive function \n121, then one can also allow disjoint types to be introduced on the fly with a non referentially transparent \nnew function. This allows one to do things like typing the contents of arrays. A new disjoint type is \ncreated for the array contents when a new array is created, and is preserved when the array is mapped \nor joined. This allows type safe use of keys between arrays. No attempt is made to reduce the constraints \ninto a sim- plified general form or remove recursion from the constaints. Type checking proceeds by expanding \nfunction evaluations until either the type constraints repeat or an error are found. In most cases, one \nor the other will be found fairly quickly, however in some special cases it may run for a very long time \nor even not terminate. One such case is a function involving a divergent computation on Church numerals. \nAS every Church numeral has a different type in this system, there will be no fixed point or error, and \nso the type check will not terminate. Such cases are, however, very rare and generally not very useful. \nIn practice problems could be avoided by giving a type error if a recursion did not reach a fixed point \nwithin a certain (large) number of expansions. This type system attempts to get close to the freedom \nof Smalltalk, while maintaining the safety of strong typing. References [l] Paul Hudak, Phillip Wadler \net al, The Haskell report 1.4. 1997. [2] Robert Ennals, Controlled Temporal Non-Determinism for Reasoning \nWith A Machine Of Finite Speed, ICFP98 (Poster). 340 \n\t\t\t", "proc_id": "289423", "abstract": "", "authors": [{"name": "Robert Ennals", "author_profile_id": "81540726056", "affiliation": "Cambridge University", "person_id": "PP31075345", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/289423.289468", "year": "1998", "article_id": "289468", "conference": "ICFP", "title": "Verbose typing", "url": "http://dl.acm.org/citation.cfm?id=289468"}