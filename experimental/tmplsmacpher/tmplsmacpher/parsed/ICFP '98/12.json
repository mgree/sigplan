{"article_publication_date": "09-29-1998", "fulltext": "\n Typed Cross-Module Compilation* Zhong Shao Dept. of Computer Science Yale University New Haven, CT 06520 \nshao-zhongQcs.yale.edu Abstract Higher-order modules are very effective in structuring large programs \nand defining generic, reusable software compo-nents. Unfortunately, many compilation techniques for the \ncore languages do not work across the module boundaries. As a result, few optimizing compilers support \nthese module facilities well. This paper exploits the semantic property of ML-style modules to support \nefficient cross-module compilation. More specifically, we present a type-directed translation of the \nMacQueen-Tofte higher-order modules into a predicative variant of the polymorphic X-calculus F,. Because \nmodules can be compiled in the same way as ordinary polymorphic functions, standard type-based optimizations \nsuch as rep- resentation analysis immediately carry over to the module languages. We further show that \nthe full-transparency property of the MacQueen-Tofte system yields a near optimal cross-module compilation \nframework. By propagating various static information through the module boundaries, many static program \nanalyses for the core languages can be ex-tended to work across higher-order modules. Introduction Modular \nprogramming has proven to be extremely valuable in the development and maintenance of large software \nsys-tems [3, 31, 91. Many modern programming languages such as Modula-3 [31] and Standard ML [26, 271 \nprovide support for both core-level and module-level programming. The core *This research was sponsored \nin part by the Defense Advanced Research Projects Agency IT0 under the title Software Evolution using \nHOT Language Technology, DARPA Order No. D888, issued under Contract No. F30602-96-2-0232, and in part \nby an NSF CA-REER Award CCR-9501624, and NSF Grant CCR-9633390. The views and conclusions contained in \nthis document are those of the authors and should not be interpreted 88 representing the official poli-cies, \neither expressed or implied, of the Defense Advanced Research Projects Agency or the U.S. Government. \n language, in general, deals with the detailed implementation of algorithms in terms of data structures \nand control con-structs. The module language, on the other hand, provides glue to organize large programs \nand to build generic and reusable components. A mature and scalable compiler must support both styles \nof programming well, generating decent code even for heavily modularized programs. ML-style higher-order \nmodules [25, 11, 201 are widely recognized as one of the most powerful moduIe constructs in existence \ntoday. Recent work on the type-theoretic foun-dations of ML modules [ll, 19, 271 has cleaned up many \nrough spots in the original design [26]. Still, the seman-tics for higher-order modules involves the \nuse of dependent types [24, 121 or translucent signatures [ll, 191. MacQueen and Tofte [25] have shown \nthat even a small restriction on signature matching [19,11] can significantly compromise the overall \nexpressiveness (i.e., full transparency) of the under-lying module language. It is fair to say that the \ntype sys-tems for higher-order modules is much more elaborate than (or at least very different from) \nthose for the core-ML-like languages [8]. This semantic difference between the core and module languages \nposes great challenges to compiler writers. Al-though the module code itself seldom needs to be compiled \nefficiently, optimizations used for the core language must be compatible with the module constructs in \norder to have a coherent compiler. Unfortunately, many compilation tech-niques do not work on programs \nthat use higher-order mod-ules. In fact, most recent work on compiling functional lan-guages have ignored \nissues on the necessary module support. Take the area of type-directed compilation ss an example: recent \nwork includes representation analysis [18, 331, type specialization [6], intensional type analysis [14], \ntyped clo-sure conversion [28], tagless garbage collection [40], to name just a few. All of these are \nperformed on the variants of core ML [8] or the polymorphic X-calculus F, [lo, 321. While they have all \ndemonstrated that types can be used to make pro-grams run faster and consume less space, it is not obvious \nhow any of these would work in the presence of higher-order modules (which make use of dependent types). \nConsider the module code in Figure 1, written in the SML syntax. Here, structure SA, SB, and SC are simple \nmodules; signature ASIC and BSIC express the interface of structures; functor F (inside SB) and APP, \nalso known as parameterized modules, are just functions from structures to structures. Functor specifications \nsuch az F inside BSIG use functor signatures to express the interface of functors. signature ASIC = \nsig type s val f : s end signature BSIG = sig functor F(X : ASIC) : ASIC end structure SB = struct functor \nF(X : ASIC) = struct type s = x.s -> x.s fun f (x : X.s) = X.f end end  structure SA = I functor APP \n(B : BSIG) = B.F(SA) struct type s = int val f = 3 structure SC = APP(SB) end Figure 1: An example of \nML-style higher-order modules Structure SB and functor APP are examples of the so-called higher-order \nmodules: structures (SB) can contain other functors as their components, and functors (APP) can take \narbitrary structures as their arguments. Functors can only be applied to structures with compatible signatures, \nas in APP(SB); the result structure has an interface like that of the original functor body, but with \nproper instantiations. It is easy to see why higher-order modules would break the type-baaed optimizations \nmentioned above. In the F, calculus, polymorphic functions such as the identity function At :: &#38;Xx \n: t.z always cleanly separate the type abstraction (A) from the value abstraction (X). Therefore, polymorphic \nfunctions in F, or core ML can be specialized to particular type arguments at compile time. Furthermore, \nboth repre-sentation analysis [18, 331 and intensional type analysis [14] can be performed, inserting \ncoercions or runtime type pa-rameters at every type-application site. Higher-order mod-ules, on the other \nhand, express both the type and value abstractions through a single construct (i.e., functor). A functor \nsuch as APP and SB.F takes mixed sets of types and values as its argument, and return another such set \nas its re-sult. F unctor applications such as APP(SB) cannot be type- specialized, because we do not \nknow how to identify the exact type parameters in functors such as APP. Representa- tion analysis and \nintensional type analysis are also hard to perform because of the pervasive use of dependent types. Higher-order \nmodules also make it very difficult to carry out static program analysis across the module boundaries. \nBecause the module signature does not propagate any static information other than types, many existing \ntechniques, such as constant propagation, function inlining [2], partial evaluation [17], and constraint-based \nanalysis (11, lose all their information at the functor-application boundaries. In the previous example, \nif we textually inline all functor appli-cations in the source, we can deduce that the f component in \nstructure SC is equivalent to the following: fun f (x : int) = 3 However, because inlining large functors \ncan lead to code explosion, and moreover, modules often must be compiled separately, it is impractical \nto eliminate all functors by in- lining. The challenge then is to deduce these properties statically \nwhile still supporting separate compilation. This paper exploits the semantic property [13] of ML-style \nmodules to support efficient cross-module compilation. More specifically, we present a type-directed \ntranslation of the MacQueen-Tofte higher-order modules [25] into a pred- icative variant of the F, calculus. \nBecause modules can be compiled in the same way as ordinary polymorphic func-tions, all the type-baaed \noptimizations mentioned above im-mediately carry over to the module languages. The basic idea of our \nalgorithm is similar to phase-splitting [13]: we notice that every ML module can be split into a type \npart and a value part; the type (value) part of a structure includes all of its type (value) components \nplus the type (value) parts of its structure and functor components; the type part of a functor is a \nhigher-order type function from the type part of its arguments to that of its result; the value part \nof a functor can be viewed as a polymorphic function quantified over the type part of its arguments; \nfunctor applications can thus be expressed as a combination of type application and value application \nas in the F, calculus. We further show that the full-tmnsparency property of the MacQueen-Tofte system \nyields a near optimal cross-module compilation framework. Here, by full transparency, we mean that type \ninformation is always propagated opti-mally through all the module boundaries, so structures such as \nSC get exactly the same typing whether functor APP is tex- tually inlined or separately compiled. By \npropagating other static information in the same way, we can extend most static program analyses for \ncore languages to work across higher-order modules. The main contributions of this paper are: l As far \nas we know, our work is the first comprehensive and formal study. on how to apply type-baaed com-pilation \ntechniques [18, 40, 14, 28, 331 to programs using ML-style modules. Our main result that ML-style modules \ncan be compiled into an F,-like calculus is new and significant because immediately all type-based techniques \nfor F, become applicable to the mod- ule languages as well. . Our translation of the MacQueen-Tofte system \ninto the F, calculus is the first such algorithm that deals with the essential features in the ML-like \nmodule lan-guages. Several recent papers [13,4, 201 have attacked similar problems but with completely \ndifferent moti-vations; they also impose severe restrictions to their module languages (e.g., no type \nabbreviation or shar- ing inside signatures [13], no parameterized types [4], kind tycon type term decl \n Kt ::= R 1 ict -h n; 1 {Z::nt,...,Z ::nE:} jtt ::= (Y ] Int ] pt -P&#38; ] Xa::nt.pt ] PtbL:] ] {l=pt,...,~ \n=jJi} ] Pt.1 ut ::= z-(/At) 1 ut + a; 1 {z:ut,...,z :u;} 1 va::nt.ut et ::= x 1 i 1 Xx:at.et 1 Qete: \n1 ha::nt.et 1 et[pt] 1 {l=et,...,l =ei} I et.1 I let dt in et dt ::= E 1 (x = et);dt Figure 2: Syntax \nof the F,-based target cakulu~ TGC A D pt :: tct . . . A D /t; :: IC; A D {l=pt ,..., i =/.t;} :: {l::/ct \n,..., l ::K:} A D { . . . . I=/&#38;, . ..} :: { . . . . I::&#38;, . ..} (cpl-eqv) A D { . . . . l=/tt, \n. ..}.l Et /&#38; :: nt A;I P et : ot . . . A;I P e: : a; A;I P {Z=et ,..., Z =e:} : {Z:ut ,..., Z :ui} \n Figure 3: Selected and limited forms of functor arguments [20]). l Our compilation algorithm can handle \nthe entire SML 97 language [27] including both tmnsparent and opaque signature matching. In fact, the \nalgorithm has been implemented and released with the SML/NJ compiler since version 109.24 (January 9, \n1997). As a result, all type-based optimizations in the compiler work across the higher-order module \nboundaries. l We also describe a new algorithm that does both cross-module inlining and type specialization, \neven for func- tions with free value and type variables. Our algorithm supports fully transparent propagation \nof binding in-formation, even across heavily functorized code. Other kinds of program analysis can be \nextended to work across higher-order modules in the same way. l To facilitate our presentation, we give \na new and more complete formal definition for the MacQueen-Tofte higher-order modules. MacQueen and Tofte \ns origi-nal semantics [25] does not address many important features such as type specifications, type \ndeclarations, and hidden module components. Our new semantics covers a much richer language and solves \nthe remaining technical problems. The rest of this define an F,-based higher-order module tains all the \nessential We give the static paper is organized as follows: we first target calculus (TGC) and an ML-style \ncalculus (NRC). The NRC calculus con-features in an ML-style module system. semantics for NRC and then \npresent a type-directed translation from NRC to TGC. We show how to exploit the full-transparency property \nto support cross-module program analysis. Finally, we discuss implementa-tion details, related work, \nand then conclude. 2 An F,-based target Our target calculus TGC polymorphic X-calculus in Figure 2. Here, \nkinds calculus is a predicative variant [13] of the F, . The syntax of TGC is given classify type constructors \n(tycon); A D pt :: { . . . . l::)~t ,... } (cprod) (cselect)A D pt.1 :: fit A D pt :: n; n;I = {l::Kt, \n. . ..t.:K;} (cp2-w) A D {l=/&#38;.l, . . . . i =jtt.l } Et /At :: IE;  A;I P et : { . . . . Z:at ,... \n} (pm4 (select)A; l? P et.1 : ut typing rules for TGC types classify terms. Declarations (dec) and \nthe term let dt in et are syntactic sugar introduced to simplify the presen-tation of our translation \nalgorithm. Constructors of kind R name monotypes. The monotypes are generated from vari-ables, Int, and \nthrough the arrow constructor (+). The application and abstraction constructors correspond to the function \nkind Kt + IE:. The product and selection con-structors correspond to the product kind {I :: Kt, . . . \n. 1 :: K;}. Types in TGC include the monotypes, and are closed under products, function spaces, and polymorphic \nquantification. Following Harper and Morrisett [14], we use T(p) to de-note the corresponding monotype \nof the constructor CL. The terms are an explicitly typed X-calculus with explicit con-structor abstraction \n(A) and application forms. TGC terms also include the labeled product and selection terms; prod-uct terms \nsuch as (1 = et, . . . . 1 = e;} correspond to product types of {Z:ut,...,Z :u~}. The static semantics \nfor TGC consists of the following set of typing rules: constructor formation constructor equivalence \ntype formation type equivalence term formation declamtion formation A D pt :: tct 2 ; F ct /A; :: nt, \nA D a: zt a; A;l?P et:at a;r P dt:r Here, A is a kind environment that maps from type vari-ables to kinds, \nand I is a type environment that maps from program variables to types. The constructor formation rule \nis of form A D pt :: nt, meaning that constructor pt has kind tct under kind environment A. Two constructors \npt and &#38; of kind Kt are considered equivalent if A D pt Et pi :: tct. The term formation rule is \nof form A; I P et : ut, meaning that term et is assigned type ut under kind environment A and type environment \nr. Figure 3 gives the typing rules for the product-related constructors and terms. The rest of the rules \nare all standard, as shown in the companion technical report [35]. It is well known that type-checking \nfor the TGC-like calculus is decidable, and furthermore, its typing rules are consistent with properly \ndefined operational semantics [29, 141. Access paths: Kinds and types: I strpath ps ::= Si 1Pa.Si kind \nnC ::= RIR-+fc, fcWh m ::= fi I pa.fi tycon jbC ::= Pt I id I PC + pb Wwth pt ::= ti 1 p8.t; I Mi :: \nQ.k I Pc[Pb] Signatures and specifications: Modules and declarations: I spec D ::= E ) DD decl d ::= \nE 1 dd 1 local d in d end 1 type i!; :: fee 1 type ti :: &#38; = /.Lc 1 type ti :: Kc = /Lc structure \nSi = m, structure si : MS i functor fi = mf I f unctor fi : Mf str ma ::= PS 1 fi(Si) I (~i:Ms) I mb \nsig MS ::= sig D end mb ::= struct d end fsh Mr ::= fsig(s;:M,)Mi fct mf ::= pf 1 fun&#38; (Si:Ms)mb \nFigure 4: Syntax of the normalized module calculus NRC 3 Module semantics and translation To show how \nwe translate the ML-style modules into the TGC calculus, we choose a surface language (SFC) that is similar \nto the SML 97 module language[27] extended with the MacQueen-Tofte higher-order modules [25]. We divide \nthe translation from SFC to TGC into two steps: l First, we perform a series of syntactic transformations \nand normalizations, and then translate the SFC pro-gram into a normalized module calculus (NRC); z Second, \nwe translate the NRC program into the TGC calculus. To make the paper more focused, we will only briefly \nexplain the first step, and then concentrate on describing the NRC calculus and how we translate NRC \ninto the TGC calculus. The companion TR [35] gives more details about the SFC calculus and the SFC-to-NRC \ntranslation. 3.1 Normalization and the NRC calculus The syntax of our normalized module calculus NRC \nis de- fined in Figure 4. During the SFC-to-NRC translation, each identifier in the surface language \nis alpha-converted and as-signed a unique internal name, so an identifier (e.g., zi) in NRC always consists \nof two parts: an external name (z) and an internal stamp (i). We use t, s, and f to denote type, structure, \nand functor identifiers, and pt, ps, and pf for the access paths. The NRC module language includes standard \nconstructs such as signatures (M.), functor signatures (Mf), structure expression (m,), and functor expressions \n(mf). A signa-ture contains a list of type, structure, and functor specifica-tions (D). A type specification \ncan either be a flexible one-specifying only the arity of the underlying type constructor; or it can \nbe a type abbreviation. Type-sharing specifica-tions in SFC are converted into type abbreviations [22]. \nA structure expression can be a structure path (pb), a func- tor application (fi(si)), a structure matched \nby a signature (si : Ma), or a definitional structure (ma). Functors in NRC are higher-order because \nthey can be passed as arguments or returned as results by other functors. To simplify the presentation, \nwe did not include value specification and value declaration in the current NRC cal-culus. We also used \na rather simple type language where pc denotes type constructor and &#38;cc denotes its kind (i.e, the \narity). These simplifications do not affect the generality of our algorithm since the main idea of our \ntranslation can be illustrated independent of these core-language features. Sec-tion 5 gives more details \non how to handle value components and other advanced core-language features. The translation from SFC \nto NRC does a series of nor-malizations that turn complex SFC constructs into simpler and more primitive \nNRC constructs. The most important transformation is to make explicit all enrichment coercions occurring \nat every signature matching (see the companion TR [35] for details). After this transformation, a structure \nsi in NRC will only match a signature M, if the following are all satisfied: first, si must contain the \nsame number of components as those in Md; second, each pair of correspond- ing components in s; and M., \nmust have the same external and internal names and follow the same order; finally, each functor component \nin si must have a signature syntactically equivalent to its counterpart in Md. These invariants are reflected \nand enforced in NRC s static semantics given in Section 3.2. Another unusual feature of NRC is that functor \nbody must be of form struct.. . end, i.e., a definitional structure expression marked syntactically as \nmb. This is exploited by the static semantics to ensure a one-to-one mapping between type stamps and \ntheir definitional type paths. To convert an arbitrary functor expression (say funct (si : M#)m,) into \nthis form, the SFC-to-NRC translation wraps an extra layer around the functor body m.; the resulting \nfunctor body becomes: funct (si:M,) struct structure R = m. end. Functor bodies inside functor signatures \nare transformed in the same way. Meanwhile, functor application such as F(S) is translated into: let \nstructure T = F(S) in T.R and. Finally, all module declarations inside the let expressions in SFC are \npushed upwards and then turned into the NRC local declarations (see the companion TR [35] for details). \n144 Stamp n E sameasi Path PZ ::= ps 1 &#38; Tgcon ::= n(nc,pf) 1 a 1 int ( pm + /.4L Pm StampEnv N \n= Stamp 3 QpPath I Xa::G7l I pZm[/.L] SpecEnv D z Id 3 Spec QpRlzn rt ::= pm StrRlzn ra ::= R RlznEnv \nR s Id % Rlzn FctRLn rf ::= (mb,B, At) 1 (At) Basis B = (A, N, D, R) Rlzn r ::= rt I r8 I rf AuxInfo \nAt ::= &#38;,a*) Figure 5: Semantic objects for NRC signature subsumption B p M, 5 M; Figure 7 module \ndeclaration Bt- d: N;D;Radt Figure 7 module expression B t-m-: N; M-; r--et Figure 7 signature instantiation \npt;p,;B c M. : N;r,*ut Figure 8 signature kind translation I-- M- =+ nt Figure 9 module type translation \nI-= (i&#38;r-) a pt;ut Figure 9 Figure 6: NRC semantics and translation: a summary 3.2 Static semantics \nfor NRC and n (&#38;., &#38;) are equivalent if and only if n and n are equal. A realization can be a \ntype realization (rt), a structure Before presenting the translation from NRC to TGC, we realization \n(rd), or a functor realization (rf). A type real-first give a new and more complete formal semantics \nfor the ization captures the actual definition of a type component;MacQueen-Tofte higher-order modules \n[25] in the context it is represented simply as the internal type constructor /.J,,,. of NRC. Under our \nstamp-based approach, the type of a A structure realization captures the detailed definitions ofmodule-also \ncalled the modtype in this paper-is expressed all the components in a structure; it is defined as a real-as \na pair of a signature and a realization. The signature cap-ization environment (R) which maps from (type, \nstructure,tures the module skeleton such as names of its components and functor) identifiers to realizations. \nA functor realizationand the kind and sharing information for type specifications. captures the typing \nrelationship between the argument andThe realization describes the actual type definition for all the \nresult of a functor; it is defined either as a realizationthe type paths (pt) in an NRC construct. The \njob of the closure (mb, B, At) or as a formal template (At). ,In both static semantics is to infer and \nvalidate the semantic types cases, At contains auxiliary TGC type information main-for all NRC type paths, \nand then propagate this information tained solely for the NRC-to-TGC translation. to different modules. \nThe realization for a fully defined functor, e.g., funct Figure 5 defines the semantic objects used by \nour new se- (si : M8)mb, is a realization closure (m;, B, At). The codemantics. Figure 6 gives a summary \nof all the semantic rules; part of the closure, rn;, is simply the actual functor body mb. we use a single \nset of deduction rules to describe both the The environment part of the closure is the current basis \nBstatic semantics and the translation algorithm. A deduction (defined below). The realization for a formal \nfunctor param-such as W I- X : Y * 2 has the following meaning: un-eter, e.g., functor B.F inside APP \nin Figure 1, is defined asder the environment W, the NRC construct X is elaborated a formal template, \nmarked as (At); all we know about suchinto the semantic object Y and translated into the TGC functor \nis its signature. construct 2. In the rest of this paper, we use ON, OR, etc. to denote the empty environments; \nW to denote the environ- The basis environment B is a tuple (A, N, D, R) where ment overlay; l to denote \nthings that are irrelevant under A is an auxiliary TGC kind environment, N is a stamp en-the current \nrule; and si.p. to denote an access path that vironment, D is a specification environment (represented \nas starts with an structure si and ends with a tail path pz. We NRC specifications), and R is a realization \nenvironment. also restrict our semantics to elaborate normalized NRC pro-The kind environment A does \nnot play any role for the grams only; an NRC program is normalized if there are no static semantics; \nit is purely maintained for the NRC-to-duplicate bindings within each scope, and all of its functor TGC \ntranslation (mainly to simplify the technical proof). definitions have distinctly named formal parameters; \nthese The stamp environment N records all the type stamps de- conditions are enforced by the SRC-to-NRC \ntranslation. fined so far and maps each of them to its definitional type path. The specification environment \nD and the realiza- Returning to Figure 5, here, pm is an internal semantic tion environment R form the \nactual modtype environment. type constructor designed for type-checking. The only dif-Given a module \naccess path p-, we can retrieve its modtype ference between pm and the NRC type constructor /.J~ is that \nby looking it up in the corresponding environments; the re-pc might be a type path p: but p,,, cannot \nbe. During the sult is abbreviated as B(pJ = (M-, r-) where wild card l elaboration, formal type constructors \nin NRC are translated implies either structure entity (3) or functor entity (f). into type stamps of \nthe form n(lcc, c(t) where n is a stamp, ac is its kind, and /,Q is a TGC type constructor-auxiliary \nin-At any time during the elaboration, an NRC type pc can formation used solely for the NRC-to-TGC translation. \nThe be mapped into its actual semantic type p,,, , and vice versa. type equivalence relation I ,,, on \np,,, is the standard struc- Neither the kind environment nor the stamp environment is re- tural equivalence \nexcept that two stamped types n(ac,pt) quired here, but we include it anyway to simplify the notation. \n Signature subsumption: [BP Ma 5 M;I Bl- D<D B P D 5 D B P D 5 D (1) (2) B P sig D end 5 sig D end \nB P DD 5 D D B P E 5 E (3) B P functor fi: Mf < functor fi: Mf (4) B I- M, 5 M; c2m(B, PC) S, cSm(B, \ncl:) (5) (6) B P structure si: M, 5 structure si: Mi B P type ti::nc=pc < typo ti::nc=&#38; B P type \nti ::Ic~ = /AC 5 typo h ::KC (7) B P type ti ::nc 5 type ti ::nc (8) Typing and translation of declaration(s): \nBl- d:N;D;R=%dt pm = c2m(B,pc) p,,, has kind tcC (9) BP type ti::Kc=pc : O~;{type ti::&#38;=Pc}i{h +Pm}*&#38; \nB P m, : N; M.,;r,*et N = {n I+ 8i.p: ) pt = N(n),n E Dam(N)} (lo) B P structure si =mb : N ; {structure \n3: : M,} ; {si c) rs} * (Si = et) B P mf : N ; Mf ; rf =+-et N 9 0~ (11) B td functor fi=mf : 0~; {functor \nfi:Mf}; {fi I+ f) * (fi =Q) B P E : 0~ ; 0~ ; 0~ = E (12) B P d : N ; D ; R e d: B@(&#38;,N ,D ,R ) P \nd : N ; D ; R ad:( (13) B P d d : N @ N ; D D ; R kl R + d;d;l B P d : N ; D ; R ti d: B@ (&#38;,N \n,D ,R ) P d : N ; D ; R ad: (14) B P local d in d end : N Itl N ; D ; R U R * d;d:( Typing and translation \nof module expression: BP m-: N; M-;r-&#38;et B(p-) = (M-, r-) B(si) = (Mi,r,) B p Mi 5 M., (16) (15) \n BP p-: 0N; M-;r-=+p- B Cm (si: Ma) : 8, ; Ma ; ~a d Si B P d : N ; D ; R d dt et = {Zi = Zip.. .} for \nall xi E Dom(D ), Zi not a type (17) B I- struct d end : N ; sig D end ; RofB U R a let dt in et I= \nM, ----7 nt A = {si ::nt} si;si;B~(A,0N,8o,OR)r Ma : N;r,*m B U (A, N, {structure si: M.,}, {Si c) ra}) \nI- mb : l ; Mi ; r: --7 et P (Mkrb) * P:;u; At = (Xsi::Kt.&#38;, Vsi::nt.~t + 0;) rf = (mb, B, At) \n(18) B P funct (si:Ma)mb : 0~; fsig(si:M,)Mi; rf * hSi::Kt.XSt:ut.et B(fi) = (Mf,rf) B(Si) = (Md,rd) \nMf = f sig(si : M,)Mi D = {structure s: : M.} R = (3: I+ rs} I-= (M.,rb) * we if rf = (At) and At = (pi, \n0) then p;b~t] ; E ; B U (0a, ON, D , R ) P Mi : N ; r: ==+ l if rf = (mb, B ,o) then (AofB, NofB, DofB \nU D , RofB U R ) P mb : N ; l ; ri * l  B P fi(si) : N ; Mi ; r: * @I(fibt])Si (19) Figure 7: Module \nsemantics and its translation into TGC Signature instantiation and translation: /.tt;p,;B I- M, : N; \nr-8 *ut pt;p,;B I- D : N ; R ==+lts R = RofB U R pt;p,;B F sig D end : N ; R *{Its} (20) /.~t;p,;B \nP D : N; Ralt /J~;~,;BW(&#38;,N,D,R) pt;p,;B I-J DD : Ntd N ; RkJ R /.J,,, = c2m(B,pC) pt;p,;B tJ E : \n0x.4; 0, *E (22) /.tt ;p,;B k (type ti::nc=/tc) : 0,; R*E n $Dom(NofB) IEt = ICC Pam = n(&#38;,pt.ti) \n(24) pt;pz:iBt (type ti::K,) : {n~ppz.ti};{ti~~m}~~ pt.si;p,.si;BP MS : N;r,eot ptips;BtJ P Ma * IE~ \nA P t = Pt.fi py[si] 0: = VSi :I IQ ,Ut, + ff; pt;p,;B tJ Figure P D : N ; R w Its (21) * lt,lts pm has \nkind )E= R = {t; I+ pm} (23) (25) (structure si:Ma): N;{sit+~,}~si:~t = {si :: Kt} si;si;BU(AY0,,0n,8n) \nt Ma : N;T, *Ot ; E; B U (A, N, {structure At = (p;I,u; ) (functor fi:fsig(si:M,)Mj) 8: Signature instantiation \nGiven a basis environment B = (N, D, R), the c2m opera-tor converts pc into a semantic type by replacing \neach type path pt in pc with its actual definition R(pt); the result is denoted as c2m(B,pc). Similarly, \nthe m2c operator can convert a semantic type p,,, back to the external format by replacing each stamped \ntype n(Kc,pt) with its definitional type path N(n). The m2c operator is not used in the cur-rent semantics, \nbut it is useful for inferring the signature of modules with value (i.e., val) components. The most unusual \naspect of our semantics is the rules for signature subsumption (see Rules l-8 in Figure 7): they are \nmuch more restrictive than those used by MacQueen and Tofte [25]. To have one signature subsume another, \nboth must contain the same number of components, following the same order (Rules 2 and 3); furthermore, \nthe respec-tive functor components must have syntactically equivalent signature (Rule 4). This restriction, \nwhich is critical to the NRC-to-TGC translation, ensures that each NRC functor can only replace another \nif they have precisely same signa-ture. Nevertheless, the surface language (SFC) can still have the more \ngeneral subsumption rules, but signature matching in SFC must have all subsumption coercions made explicit \nduring the translation from SFC to NRC (see discussions on related topics in Section 3.1). Another interesting \naspect is the elaboration of functor application (see Rule 19 in Figure 7). Functor application fi(si) \nin NRC requires that the argument structure si have the syntactically same signature (M,) as the formal \nparam-eter of fi. This again requires that signature matching at each functor application be made explicit \nduring the SFC-to-NRC translation. The actual application is then done by applying the functor realization \nrf of fi to the realization rd of si. If fi is a formal functor, that is, rf is a realization template \n(At), we deduce the result realization through in- si: M,}, {si I-+ TV}) F M: : l ; l =+-U; rf = (At) \n (26) : $N; {fi tirf} tiff;:oi and its translation into TGC stantiation of fi s body signature Ml; if \nrf is a realization closure (m:, R , At), we get the result by re-elaborating the functor body (of fi). \nBecause NRC does not have datatypes, new stamped types are only generated during signature instantiation \n(see Figure 8). In fact, only flexible type specifications are as-signed new stamped types (see Rule \n24). To maintain the mapping from a new stamp to its definitional type path, the instantiation procedure \nalways (pZ) for the current component. The static semantics for NRC transparency property: a functor \nsame typing whether we compile memoizes the access path satisfies a very nice full-application is assigned \nthe it as is or by textually in- lining the functor body. Full transparency opens up the possibility \nof embedding NRC into an F,-like calculus such as TGC. After all, F, shares a similar property: given \na term e = At :: K.ei and a constructor p of kind K, type applica-tion e[p] always has the same type \nas the result of inllned application [p/t]el where [p/t] is a substitution mapping t to ~1. The main \nchallenge is then to model functors using type abstraction (A) and value abstraction (X) in TGC.  3.3 \nTranslation from NRC to TGC The NRC-to-TGC translation uses the same set of deduction rules as in the \nstatic semantics (see Figures 7 to 9). There are two key ideas behind our algorithm: l First, functor \napplication fi(si) in NRC always re-quires that the argument si has exactly the same sig-nature as the \nformal parameter of fi. NRC also uses a very restricted set of signature subsumption rules where functors \ncan only match if they have same func- tor signatures. These restrictions allow us to use the Relating \nsignature with TGC kind: -1 I-= D a lks (27) t-type t; :: tee = PC ==+ E (28) P type ti ::IEc * i!i::fGc \n(29)P sig D end =+ {lks} P M, ===s tct P Mf = tct (30) P structure si:: MS =+ si ::~t P functor fi :: \nMf ti fi ::Ic~ (31) P M, = K.Et t-2 M: Q K; P D = lks P D -----*. lks (32) I-= &#38; * &#38; (33) (34)P \nfsig(si:M,)Mi * nt + &#38; P DD --*. lks, lks Relating modtype with TGC type: P (Me,r-) a pt; ut M, = \nsig D end R I= D ==+ lcs; Its rf = (a,., At) or (At) At = &#38;,a) (35) (36) P (M,,r,) * {lcs};{lts) \nI--(Mf,rf) * pt;ut RPEEEE;E (37) R P type ti::Kc=/tc + E;E (39) R I= D a lcs; Its R I= D a 1~s ; Its \npm = R(h) pt = m2t(pm) c40j (38) R I= DD * lcs, lcs ;lts, Its R P type ti::nc a ti=pt;E p (Ms,R(si)) \n* pt;ut p (Mf,Nfi)) * Ptiut R P structure si :: M, + si=/.Lt; si :ut (41) R P functor fi :: Mf a fi=pt; \nfi :Qt (42) Figure 9: Relating NRC semantic objects with TGC types signature to guide our translation. \n. Second, an NRC module can be split into a type part and a value part. We use the signature (e.g., Md) \nrather than the modtype to guide splitting. The type (value) part of a structure includes its type (value) \ncomponents plus the type (value) parts of its structure and functor components. By type components, we \ninclude only those with flexible type specifications in MS (not those type-abbreviation specs). The type \npart of a functor is a higher-order type func- tion from the type part of its arguments to that of its \nresult; the value part of a functor is a polymorphic function quantified over the type part of its arguments; \nfunctor applications can thus be expressed as a com- bination of type application and value application \nas in the TGC calculus. Rules 9-19 in Figure 7 give the translation from the NRC module declarations \n(expressions) to the TGC declarations (expressions). All module declarations (except type dec-larations) \nare translated into the TGC value declarations. Module access path is translated into TGC record selection \n(Rule 15). We take the liberty of using the same pa and pf to denote the TGC selection terms such as \nzi. . . * .si and . . . . fi. Definitional structure .end is trans- zied into record construction in \nT?Ggk 17). Each NRC functor, funct(si : Md)mb, is translated into a TGC polymorphic function, hsi :: \nnt.Xsi : at.et (see Rule 18). Here, we assume that type and value identifiers in TGC belong to different \nname space so we can use the same si to name both without causing confusion (we can always tell the identifier \nstatus in TGC). We use the signature-instantiation procedure in Figure 8 to split functor parameter into \ntwo parts: its type part is a type parameter (si) of kind Kt; its value part is a value parameter (si) \nof type ut. Kind (Kt) can be inferred from the signature alone (see Rules 27-34 in Figure 9), and once \nagain only flexible included in the type part (Rules 28 vs 29). If we name the type part of the functor \nTGC type constructor si of kind Kt, all can be assigned a TGC tycon as well. This the signature instantiation: \nthe pt on the Rules 20-26 denote the TGC tycon of the constructors are parameter as a its components \nis again done by left-hand side of enclosing struc- ture. For example, according to Rule 24, the flexible \ntycon ti is translated into a stamped type n(rc,, (pteti)) where n is a new stamp, and the selection \nconstructor pt.&#38; is the corresponding TGC tycon for the component ti. After we instantiate the parameter \nsignature, the functor body mb is elaborated into a structure realization P:. The type part of this functor \nis expressed as a tycon Xsi :: Kt+t where pt is the type part of mb. This information is mem- oized inside \nthe functor realization (rf) for future use (e.g., Rule 36). The type part of mb is calculated by the \nprocedure defined in Figure 9: given a structure with signature M. and realization r., its type part \nis simply a TGC product con-structor, counting only those flexible type components (Rule 39 vs. Rule \n40). The m2t operator in Rule 40 translates a semantic type CL,,, into the TGC tycon pt by replacing \nall instances of stamped types n(&#38;, &#38;) with pi. Translating functor applications is much simpler \n(Rule 19). A functor application fi(si) is translated into a TGC expression Q(fi[pt])Si. Here, the value \npart of functor fi is signature Z A : ASIG F : FSIG X : XSIG  module 2 X I J K G type part (kind \nnz) value part (type uz) KA = {t::fi} QA = {} KF = KA + {} UF = VAT::IEA.({} + {}) nx = {F :: &#38;7} \nUX = {F : UF} type part (Won pz) value part (term ez) px=xT =xv Zf= {} PI = 0 pJ = {t = Int} eJ ={} \nPK = 0 eK = O(XV.F[~J])J /tG = idxT::nx. eG = AXT ::nX.xxV :uX. {I=~I,J=~J,K=/.W} let I = er; J = f?J; \nK = eK in{I=I,J= J,K=K} Figure 10: Translating a simple NRC program translated into a TGC polymorphic \nfunction named fi; the value part of structure si is translated into a TGC record named si; polymorphic \nfunction fi is applied to the type part of structure si, which is a TGC tycon pt extracted from si s \nmodtype (M., rd). To prove the correctness of our translation, we need to re- late the basis environment \nin NRC with the kind and type environments in TGC. Given a basis B, we can derive its corresponding TGC \nenvironments as follows: the kind en-vironment A is just the A component maintained inside B; the type \nenvironment r is calculated by applying the proce- dure defined in Figure 9, assuming RofB P DofB ==+ \na; Its, then we convert the list of record fields Its into a TGC type environment in a straightforward \nmanner. In the companion TR [35], we show that as long as the basis B satisfies certain pre-conditions \n(i.e., it is well-formed and it preserves TGC typing, see TR [35] for detailed definitions), our translation \nalgorithm preserves typing. Theorem 3.1 (type preservation) Given a well-formed basis B, suppose B preserves \nTGC typing, and A and T are its derived TGC kind and type environments, then for each NRC module expression \nm-, if m- is normal- ized with respect to B and B I- m-: N ; M- ; r- * et and I-M-* Kt and I-(M-,r-) \n=+ pt;ut, then ADpt::nt and A;I P et:ut; w for each NRC module declaration d, if d is normalized with \nrespect to B and B P d : N ; D ; R * dt, and T is the derived TGC type environment constructed from R \nand D, then B U (a,, N, D, R) preserves TGC typing and A; l? P dt : I . We conclude this section by applying \nour algorithm to a sample NRC program. We use ML-like signature declaration to simplify the presentation \nof NRC signature expressions (keyword funsig denotes functor signatures). signature ASIC = sig type t \nend funsig FSIG = fsig (A : ASIG) : sig type u = A.t end signature XSIG = sig functor F : FSIC and fuactor \nG (X : XSIC) = struct structure I = struct type t = int end structure J = (I : ASIG) structure K = X.F(J) \nend. Here, identifiers ASIG, FSZG, and XSIG behave like macros and they are inlined whenever used inside \nany NRC pro-gram. Inside the functor body, structure I has signature sig type t = int end, this is not \nsame as the parameter signature of X . F so we need to insert an explicit signature matching to create \nstructure J. To show how our algorithm works, we give the detailed translation results of every module \nexpression in Figure 10. Here, for every functor parameter 2 (e.g., X and A in the example), we use &#38; \nto denote its corresponding TGC con-structor identifier and Zv to denote the TGC value identi-fier; if \n2 has signature ZSIG, we can infer the TGC kind of 2~ (denoted as ~cz) and the TGC type of 2~ (denoted \nas uz). Similarly, for every module identifier 2, we give its corresponding TGC type constructor (denoted \nas pz) and target term expression (denoted as ez). Notice the type part for the body of functor X. F \ndoes not include type u. Doing so would force the use of dependent kinds to model nx. The fact that type \nt in structure K is equivalent to int is deduced and propagated by the elaborator. 4 Cross-module program \nanalysis We can extend the stamp-based semantics for NRC to sup- port cross-module program analysis. \nFull transparency guar-antees that type information be optimally propagated across module boundaries. \nWe could propagate other static infor-mation in the same manner, and by doing this, many static program \nanalyses for the core languages can be extended to work across higher-order modules. Because the realization \npart of a modtype is always hidden inside the compiler, we can freely add new static information into \nthe realization without making any changes to the source-level signature calculus. To support cross-module \ninlining, we add a new form of the type specifications and declarations into the NRC calculus. We call \nit binfo, meaning the binding information: spec D ::= . . . . . . ] binfo bi decl d ::= . . . . . . ] \nbinfo bi = eb where eb is a form of binfo expressions, possibly defined as follows: bexp eb ::= p(, 1 \nDyn 1 STFun(et) 1 STVal(c) I . . . Here, Dyn denotes a value that we know nothing about at compile time; \nSTFun (e) denotes a function that is statically known as a closed expression e, written in some typed \nin-termediate language such as TGC; and STVal (c) refers to a statically known constant c. Notice we \ndo not make any changes to SFC, instead, the SFC-to-NRC translation can use heuristics (or hints from \nthe programmer) to decide the possible inlining candidates, and then insert the proper binfo specifications \nand declarations into the NRC code. We extend the semantic objects, NRC realizations, to in- clude a \nmapping from binfo identifiers to their corresponding binding information. The binfo expressions will \nbe recorded in the realization closure of a functor, just like normal type declarations. All deduction \nrules remain unchanged, and the binding information will be optimally propagated just as the normal type \ninformation. We then systematically replace each value specification in signatures by a compound structure \nspecification that records all the relevant type, value, and binfo information. Taking the code in Figure \n1 as our example, the value spec-ification val f : s in ASIC is re-interpreted internally as follows: \nstructure f : sig val dv : s binfo dvB type tenv type venvT val venv : venvT binfo venvB end Here, binfo \nvb is a new form of specification used for binding information, Signature matching on binfo is always \ntransparent. The value component dv is f s original defini-tion. The binfo component dvB denotes f s \nbinding informa-tion. We use tenv and venv to record all the free type and value identifiers (and paths) \nin the definition of f. We use venvT to specify the type of venv because each value com-ponent must have \na type. Finally, the closure venv might be a constant itself, so we introduce venvB to record its bind-ing \ninformation. Given a structure S with signature ASIC, the access to S . f can now be implemented as follows: \n(1) if dvB is Dyn, or if the optimization is turned off, then S .f under the new interpretation is just \nS.f .dv; (2) if dvB is STFun (e), then S . f is translated into Q (e[S . f . tenv]) venw where venw is \nc if venvB is STVal (c), or S.f .venv if otherwise; (3) if dvB is STVal (c), then S . f is simply c. \nInside each structure body, we replace each value com-ponent by a structure declaration that is consistent \nwith our changes on the signatures. For example, function f inside structure SB . F is replaced by the \nfollowing: structure f = etruct fun dv (x : X.s) = X.f binfo dvB = STFun (At, :: R.XV, : t,.Xz : te.ue) \ntype tenv = x.s type venvT = X.8 val venv = X.f.dv binfo venvB = X.f.dvB end If we use the same stamp-based \nsemantics to elaborate the functor application APP(SB), we can deduce that the f com-ponent in structure \nSC (in Figure 1) is simply Xz :: int.3 . Under this algorithm, the binding information of each value \ncomponent is always propagated optimally even across higher-order modules. A more traditional approach \nwould compile the higher-order modules into the usual higher-order functions in the core language, and \nthen perform the heavy- weight control flow analysis [37] on them. Our module elab-oration algorithm \nis somewhat similar to the abstract exe-cution, but it separates the module-level declarations from the \nthe core-language expressions within. The elaboration is simple and very efficient because the module-level \ncode is always small and non-recursive. 5 implementation We have implemented both the translation algorithm \nand the cross-module inlining algorithm in the SML/NJ com-piler [36] and the FLINT/ML compiler [34]. \nThe imple-mentation in SML/NJ has been released and in production use since version 109.24 (January 9, \n1997). In our imple-mentation, we extended the NRC-to-TGC translation to handle other features in SML \n97 [27] such as value compo-nents, opaque signature matching, polymorphic types, and recursive datatypes. \nThe translation makes it possible to support type-based optimizations even in the presence of higher-order \nmodules. The cross-module inlining algorithm we implemented currently only inlines and specializes all \nthe primitive functions, but the binding information is fully propagated across the signature matching \nand functor appli-cation. The new inlining algorithm replaced the old ad-hoc algorithm in SML/NJ which \ndoes not even propagate inlin-ing information across signature matching. In the following, we briefly \nexplain some of these implementation issues; more details can be found in the companion TR [35]. Adding \nvalue components to the NRC calculus is quite trivial. Handling value specifications in signatures requires \na utility function (i.e., cam) to convert source-level types (cl=) into internal semantic types (pm). \nSimilarly, to infer the full signature of an arbitrary structure expression, we use a utility function \n(i.e., m2c) to convert the semantic type (pm) of each value component back to its source-level counterpart \n&#38;)-this is possible because the stamp envi-ronment (N) in the basis maintains a one-to-one mapping \nfrom each type stamp to its definitional type path. The semantics given in Section 3.2 always re-elaborates \nthe functor body at each functor application, but much of this is redundant. Under our implementation, \nonly type-related components are re-elaborated at each functor appli-cation; all value-related components \nare type-checked once and for all when the functor definition is processed. Opaque signature matching \n[27] can be implemented us-ing the same signature-instantiation algorithm given in Fig- ure 8. All flexible \ntype components are turned into ab-stract types, represented as fresh stamps annotated with its representation \ntype (e.g., n(~,p)). The NRC-to-TGC translation then converts these stamped types into concrete TGC types \nby dropping all the stamps. This method does not propagate abstract types into the intermediate language \nbut is sufficient if the underlying compiler does not analyze abstract types. Although the translation \nalgorithm itself does not im-prove the efficiency of the module code, it does allow many type-baaed optimizations \nto be applied to languages that use ML-style modules. Recent work [36,38,33] shows that type-based optimizations \ndramatically improve the performance of heavily modularized ML programs. 6 Related work Module systems \nhave been an active research area in the past decade. The ML module system was first proposed by Mac- \nQueen [24] and later incorporated into Standard ML [26]. Harper and Mitchell [12] show that the SML SO \nmodule lan-guage can be translated into a typed lambda calculus (XML) with dependent types. Together \nwith Moggi, they later show that even in the presence of dependent types, type-checking of XML is still \ndecidable [13], thanks to the phase-distinction property of ML-style modules. The SML SO module lan-guage, \nhowever, contains several major problems; for exam-ple, type abbreviations itre not allowed in signatures, \nopaque signature matching is not supported, and modules are fist- order only. These problems were heavily \nresearched [ll, 19, 20, 23, 39, 25, 161 and mostly resolved in SML 97 [27]. The main remaining issue \nis with the design of higher-order mod-ules, with proposals ranging from fully transparent ones [25], \nto applicative functors [20, 71, or abstract functors [ll, 19, 231. Fully transparent modules are most \nexpressive, but it is not clear whether they are absolutely necessary; they also interact poorly with \ntrue separate compilation [19]. This paper shows that at least from the implementation point of view, \nfull transparency is important in providing optimal support to efficient cross-module compilation. The \nquestion of whether higher-order modules can be compiled into simple F,-like calculus has been open for \na while. Several recent papers [13, 4, 201 have attacked vari-ants of this problem with different motivations; \nhowever, they all impose severe restrictions to their module languages. The algorithm hidden inside Harper, \nMitchell, and Moggi s phase-distinction paper [13] is most related, however, it does not support type \nabbreviation and sharing in signatures. Supporting type abbreviation is non-trivial, as discovered by \nMorrisett [30] and also demonstrated in this paper. Harper and Stone [15] give a new type-theoretical \nsemantics for the entire SML 97, however, their internal language, IL, con-tains a separate module calculus \nthat uses translucent signa-tures. Biswas [4] gives a semantics for the MacQueen-Tofte modules based \non simple polymorphic types; however, his algorithm does not support parameterized type construc-tors. \nAnother difference is that in his scheme, functors are not considered as higher-order type constructors, \ninstead, he has to encode certain type constructors of kind Sl using higher-order types; this significantly \ncomplicates his seman- tics. Finally, Leroy [20] uses applicative functors to achieve full transparency, \nbut his approach handles limited fun&#38;or arguments only; Courant [71 s semantics does not, have such \nrestriction, but he did not give a translation of his calculus into the F, calculus. Both Lillibridge \n[23] and Leroy [21] discussed how to add value identities to their module interfaces though neither of \nthem gave any actual algorithm. Blume and Appel [5] pro- posed a cross-module inlining algorithm that \nsupports in-lining of functions with free variables. Their algorithm is *Although the paper by Harper \net al [13] wag published in 1990, the importance of its phase-splitting algorithm wan not recognized \nuntil very recently. In fact, we reinvented the same algorithm while working on the type-directed compilation \nof ML-style modules during 1996. The first version of our algorithm was presented at the IFIP WG2.8 meeting \nin September 1996. It was at that meeting when Bob Harper pointed us to the phase-distinction paper. \nIn January 1997, Greg Morrisett [30] told ua that he had problems adapting the original phase-splitting \nalgorithm 1131 to SML 1271 since it does not supDort type abbreviations in sign&#38;u;es. As a res&#38;, \nthe TIL compiler &#38;day is still using an intermediate language with dependent singleton kinds rather \nthan the plain F, calculus. carried in an untyped setting, so type specialization is not directly supported; \nneither does their algorithm guarantee the fully transparent propagation of the inlining informa-tion. \nOur algorithm does guarantee the optimal propaga-tion, but at the price of further complicating the module \nelaboration. We are currently working together on an inlin- ing algorithm that combines the best of both \nschemes. Type-directed compilation has received much attention lately, but little has been done to extend \nit to work across higher-order modules. Shao and Appel[36] extended Leroy s representation analysis [18] \nto work for the SML SO modules; their algorithm works only for the pure-coercion-based rep-resentation \nanalysis [18]. The algorithm in this paper trans-lates the module language into the F, calculus, so type-based \noptimizations [18, 33, 14, 28, 401 that work for F, immediately work for higher-order modules as well. \n7 Conclusions We have presented a series of techniques for compiling across higher-order modules. These \ntechniques have been imple-mented and released with the SML/NJ compiler since ver-sion 109.24 (January \n9, 1997). The main contribution of our work is the translation algorithm from ML-style modules (SML 97 \nextended with MacQueen-Tofte higher-order mod-ules) to the F, calculus. Without such translation, none \nof those important type-based optimizations [14, 33, 341 would apply to the full SML language. We have \nalso presented ways to extend various program analyses to work across higher-order modules; in fact, \nwe show that for fully trans-parent, modules, static information can always be optimally propagated across \nthe module boundaries. Finally, we have presented a new and more complete formal definition for the MacQueen-Tofte \nhigher-order modules; our new semantics covers a much richer language and solves all the remaining technical \nproblems in MacQueen and Tofte s original pro-posal [25]. Availability The implementation discussed in \nthis paper is now released with the Standard ML of New Jersey (SML/NJ) compiler and the FLINT/ML compiler \n[34]. SML/NJ is a joint work by Lucent, Princeton, Yale and AT&#38;T. FLINT is a modern compiler infrastructure \ndeveloped at Yale University. Both FLINT and SML/NJ are available from the following web site: http://flint.cs.yale.edu \n Acknowledgement I would like to thank Andrew Appel, Christopher League, David MacQueen, Bratin Saha, \nChris Stone, Valery Tri-fonov, and the anonymous referees for their comments and suggestions on an early \nversion of this paper. The imple-mentation of higher-order modules inside SML/NJ is joint work with David \nMacQueen at, Lucent Technologies. References [l] A. Aiken and N. Heintze. Constraint-based program analysis. \nPOPL 95 nt.orial, January 1995. 1.51 A. W. Appel. Compiling with Continuations. Cambridge PI University \nPress, 1992. E. Bianioni, R. Harper, P. Lee, and B. Milnes. Signatures for a network protocol stack: \nA systems application of Standard ML. In 1994 ACM Conference on Lisp and Functional Pro-gramming, pages \n55-64; New York, June 1994. ACM Press. [31 S. K. Biswas. Higher-order functors with transparent signa- \nI41 tures. In Twenty-second Annual ACM Symp. on Principles of Prog. Languages, pages 154-163, New York, \nJan 1995. ACM Press. M. Blume and A. W. Appel. Lambda-splitting: A higher-order approach to cross-module \noptimizations. In Proc. 1997 A CM SIGPLA N International Conference on Functional Programming (ICFP 97), \npages 112-124. ACM Press, June 1997. [51 C. Chambers. The Design and Implementation of the SELF Compiler, \nan Optimiting Compiler for Object-Oriented Pro-gramming Languages. PhD thesis, Stanford University, Stan-ford, \nCalifornia, March 1992. PI J. Courant. An applicative module calculus. In M. Bidoit and I71 M. Dauchet, \neditors, TAPSOFT 97: Theory and Pm&#38;ice of Software Development: LNCS Vol 1214, pages 622-636, New \nYork, 1997. Springer-Verlag. L. Damas and R. Milner. Principal type-schemes for func-tional programs. \nIn Ninth Annual ACM Symp. on Principles of Prog. Languages, pages 207-212, New York, Jan 1982. ACM Press. \nPI L. George. MLRISC: Customizable and reusable code gen-erators. Technical memorandum, AT&#38;T Bell \nLaboratories, Murray Hill, NJ, 1997. PI J. Y. Girard. Interpretation Fonctionnelle et, Elimination des \nCoupures dans [ Arithmetique d Ordre Superieur. PhD thesis, University of Paris VII, 1972. PO1 R. Harper \nand M. Lillibridge. A type-theoretic approach to higher-order modules with sharing. In Twenty-first Annual \nACM Symp. on Principles of Prog. Languages, pages 123-137, New York, Jan 1994. ACM Press. WI R. Harper \nand J. C. Mitchell. On the type structure of Stan- dard ML. ACM l+ans. on Programming Languages and Sys- \ntems, 15(2):211-252, April 1993. WI R. Harper, J. C. Mitchell, and E. Moggi. Higher-order mod-ules and \nthe phase distinction. In Seventeenth Annual ACM Symp. on Principles of Prog. Languages, pages 341-344, \nNew York, Jan 1990. ACM Press. 1131 R. Harper and G. Morrisett. Compiling polymorphism using intensional \ntype analysis. In Twenty-second Annual ACM Symp. on Principles of Prog. Languages, pages 130-141, New \nYork, Jan 1995. ACM Press. 1141 1151 R. Harper and C. Stone. An interpretation of Standard ML in type \ntheory. Technical Report CMU-CS-97-147, School of Computer Science, Carnegie Mellon University, Pittsburgh, \nPA, June 1997. M. P. Jones. Using parameterized signatures to express mod-ular structure. In Twenty-third \nAnnual ACM Symp. on Principles of Prog. Languages, pages 68-78, New York, Jan 1996. ACM Press. WI N. \nD. Jones. Partial evaluation. POPL 91, tutorial handout, January 1991. P71 WI X. Leroy. Unboxed objects \nand polymorphic typing. In Nineteenth Annual ACM Symp. on Principles of Prog. Lan-guages, pages 177-188, \nNew York, Jan 1992. ACM Press. Longer version available as INRIA Tech Report. I191 X. Leroy. Manifest \ntypes, modules, and separate compila-tion. In Twenty-first Annual ACM Symp. on Principles of Prog. Languages, \npages 109-122, New York, Jan 1994. ACM Press. X. Leroy. Applicative functors and fully transparent higher-order \nmodules. In Twenty-second Annual ACM Symp. on Principles of Prog. Languages, pages 142-153, New York, \nJan 1995. ACM Press. WI PO1 X. Leroy. A modular module system. Technical report 2866, INRIA, April 1996. \nX. Leroy. A syntactic theory of type generativity and sharing. Journal of Functional Progmmming, 6(5):1-32, \nSeptember 1996. WI M. Lillibridge. tinslucent Sums: A Foundation for Higher-Order Module Systems. PhD \nthesis, School of Computer Science, Carnegie Mellon University, Pittsburgh, PA, May 1997. Tech Report \nCMU-CS-97-122. [231 D. MacQueen. Using dependent types to express modular structure. In Proc. 13th Annual \nACM SIGPLAN-SIGACT Symp. on Principles of Programming Languages, pages 277- [241 286. ACM Press, 1986. \nD. MacQueen and M. Tofte. A semantics for higher order functors. In The 5th European Symposium on Progmmming, \npages 409-423, Berlin, April 1994. Spinger-Verlag. [251 R. Milner, M. Tofte, and R. Harper. The Definition \nof Stan- dard ML. MIT Press, Cambridge, Massachusetts, 1990. WI R. Milner, M. Tofte, R. Harper, and D. \nMacQueen. The Def- inition of Standard ML (Revised). MIT Press, Cambridge, Massachusetts, 1997. [271 \nY. Minamide, G. Morrisett, and R. Harper. Typed closure conversion. In Proc. 23rd Annual ACM SIGPLAN-SIGACT \nSymp. on Principles of Programming Languages, pages 271- WI 283. ACM Press, 1996. PI G. Morrisett. Compiling \nwith Pypes. PhD thesis, School of Computer Science, Carnegie Mellon University, Pittsburgh, PA, December \n1995. Tech Report CMU-CS-95-226. G. Morrisett. Personal Communication, Cornell University, January 1997. \n1361 G. Nelson, editor. Systems programming with Modula-3. Prentice Hall, Englewood Cliffs, NJ, 1991. \nI311 J. C. Reynolds. Towards a theory of type structure. In Proceedings, Colloque sur la Programmation, \nLecture Notes in Computer Science, volume 19, pages 408-425. Springer-Verlag, Berlin, 1974. [321 Z. Shao. \nFlexible representation analysis. In Proc. 1997 ACM SIGPLAN International Conference on Functional Progmmming \n(ICFP 97), pages 85-98. ACM Press, June 1997. I331 Z. Shao. An overview of the FLINT/ML compiler. In \nProc. 1997 ACM SIGPLAN Workshop on !Qpes in Compilation, June 1997. I341 Z. Shao. Typed cross-module \ncompilation. Technical Report YALEU/DCS/RR-1126, Department of Computer Science, Yale University, New \nHaven, CT, June 1998. [361 Z. Shao and A. W. Appel. A type-based compiler for-Stan-dard ML. In Proc. \nACM SIGPLAN 95 Conj. on Prog. Lang. Design and Implementation, pages 116-129. ACM Press, 1995. I351 0. \nShivers. Control-Flow Analysis of Higher-Order Lan-guages. PhD thesis, Carnegie Mellon Univ., Pittsburgh, \nPennsylvania, May 1991. CMU-CS-91-145. [381 D. Tarditi, G. Morrisett. P. Chenn. C. Stone. R. Harper. \nand [371 P. Lee. TIL: A type-dir&#38;ted optikizing compiler fo; ML. In Proc. ACM SIGPLAN 96 Conf. on \nProo. Lana. Desion and Implementation, pages lSl-19i. ACM &#38;ess, l 996. - [391 M. Tofte. Principal \nsignatures for high-order ML functors. In Nineteenth Annual ACM Symp. on Principles of Prog. Languages, \npages 189-199, New York, Jan 1992. ACM Press. I401 A. Tolmach. Tag-free garbage collection using explicit \ntype parameters. In Proc. 1994 ACM Conf. on Lisp and Func-tional Programming, pages l-11, New York, June \n1994. ACM Press.  \n\t\t\t", "proc_id": "289423", "abstract": "Higher-order modules are very effective in structuring large programs and defining generic, reusable software components. Unfortunately, many compilation techniques for the core languages do not work across the module boundaries. As a result, few optimizing compilers support these module facilities well.This paper exploits the semantic property of ML-style modules to support efficient cross-module compilation. More specifically, we present a type-directed translation of the MacQueen-Tofte higher-order modules into a predicative variant of the polymorphic &amp;lambda;-calculus F<inf>&amp;omega;</inf>. Because modules can be compiled in the same way as ordinary polymorphic functions, standard type-based optimizations such as representation analysis immediately carry over to the module languages.We further show that the full-transparency property of the MacQueen-Tofte system yields a near optimal cross-module compilation framework. By propagating various static information through the module boundaries, many static program analyses for the core languages can be extended to work across higher-order modules.", "authors": [{"name": "Zhong Shao", "author_profile_id": "81351597965", "affiliation": "Dept. of Computer Science, Yale University, New Haven, CT", "person_id": "PP14127817", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/289423.289436", "year": "1998", "article_id": "289436", "conference": "ICFP", "title": "Typed cross-module compilation", "url": "http://dl.acm.org/citation.cfm?id=289436"}