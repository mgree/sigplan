{"article_publication_date": "09-29-1998", "fulltext": "\n Lava: Hardware Design in Haskell Per Bjesse, Koen Claessen, Mary Sheeran Chalmers University of Technology, \nSweden {bjesse, koen, ms}Qcs.chalmers.se Satnam Singh Xilinx, USA satnamQxilinx.com Abstract Lava is \na tool to assist circuit designers in specifying, de-signing, verifying and implementing hardware. It \nis a col- lection of Haskell modules. The system design exploits func-tional programming language features, \nsuch as monads and type classes, to provide multiple interpretations of circuit descriptions. These interpretations \nimplement standard cir-cuit analyses such as simulation, formal verification and the generation of code \nfor the production of real circuits. Lava also uses polymorphism and higher order functions to provide \nmore abstract and general descriptions than are pos- sible in traditional hardware description languages. \nTwo Fast Fourier Transform circuit examples illustrate this. Introduction The productivity of hardware \ndesigners has increased dra-matically over the last 20 years, almost keeping pace with the phenomenal \ndevelopment in chip technology. The key to this increase in productivity has been a steady climb up through \nlevels of abstraction. In the late seventies, de-signers sat with coloured rectangles and laid out individ-ual \ntransistors. Then came the move through gate-level to register-transfer level descriptions, and the important \nstep from schematic capture to the use of programming languages to describe circuits. Standard Hardware \nDescription Lan-guages like VHDL and Verilog have revolutionised hardware design. However, problems remain. \nVHDL was designed as a simu- lation language, but now subsets of it are used as input to many kinds of \ntools, from synthesis engines to equivalence checkers. VHDL is poorly suited to some tasks, for example \nformal verification. Ideally, we would like to be able to describe hardware at a variety of levels of \nabstraction, and to analyse circuit de-scriptions in many different ways. The analyses (or inter-pretations) \nthat we consider to be essential are simulation (checking the behaviour of a circuit by giving it some \ninputs and studying the resulting outputs), verification (proving properties of the circuit), and the \ngeneration of code that allows a physical circuit to be produced. We want to be able to perform all of \nthese tasks on one and the same circuit de-scription. The temptation to go away and design yet another \nhard-ware description language is strong, but we have resisted it. Instead, we would like to see how \nfar we can get using the functional programming language Haskell. We call our de-sign system Lava. The \nidea of using a functional hardware description langauge is, of course, not new, and the work de-scribed \nhere builds on our earlier work on pFP [She851 and Ruby [JS90], and on the use of non-standard interpretation \nin circuit analysis [SinSl]. What is new about Lava is that we have built a complete system in which \nreal circuits can be described, verified, and implemented. An earlier version of the system was used \nto generate filters and Bezier curve drawing circuits for im- plementation in a Field Programmable Gate \nArray based PostScript accelerator. Using the current system, very large combinational multipliers have \nbeen verified [SB98]. The largest formula produced so far from a circuit description had almost a million \nconnectives. The system is constructed in a way that systematically makes use of important features of \nHaskell: monads, type classes, polymorphism and higher order functions. We use ideas from Ruby, for example \nthe use of combinators to build circuits, but in using Haskell, we gain access to a fully fledged programming \nlanguage, with a rich type system and higher order functions. Having higher order functions available \nhas greatly eased circuit description in real cir-cuit examples. Circuits themselves still correspond \nto first order functions, but we use higher order functions to con-struct circuit descriptions. Although \nwe knew in theory that it is a good idea to have circuits as first class objects, we were surprised by \nhow useful it is in practice. For example, higher order functions make it very easy to describe circuits \ncontaining look-up-tables. VHDL descriptions of such cir- cuits tend to be long and hard to read, precisely \nbecause of the absence of suitable combinators. And even in Ruby, it is hard to deal with circuits that \nhave a regular structure but components that vary according to their position in the Figure 1: A half \nadder circuit structure. Although we have moved from a relational to a functional programming language, \nwe can retain as much of the gen-erality of relations as we need, because the logical interpre-tation \ndescribed later produces formulas that are relational, in that they do not distinguish between input \nand output. What we have lost, in moving away from Ruby, is machine support for high level design [SR93]. \nAfter choosing to use Haskell for hardware description, we again had two options: to make a Haskell variant \nand write specialised tools (compilers, synthesis engines and so on) to process it, or to make use of \nexisting Haskell compilers by embedding a hardware description language in Haskell. Launchbury and his \ngroup are investigating the first op-tion [CLM98]. We chose the second. 2 Overview of the System This \nsection presents the types and abstractions used in the Lava system. 2.1 Monads Dealing with an embedded \nlanguage in a functional language requires a significant amount of information plumbing. A good way to \nhide this is to use monads [Wad92]. Defining a monad means defining the language s features; a monadic \nexpression is a program in the embedded language. More-over, Haskell provides syntactic support and general \ncombi-nator libraries for monads. Let us take a look at a small example, and see how we can define a \nhalf adder circuit (figure 1): halfAdd : : Circuit m => (Bit, Bit) -> m (Bit, Bit) halfAdd (a, b) = do \ncarry <-and2 (a, b) sum <-xor2 (a. b) return (carry, sum) This circuit has two input wires (bits) and \ntwo output wires. By convention, wires axe grouped together so that a circuit always has one input value, \nand one output value. The halfAdd circuit consists of an and gate and an xor gate. Note that the type \nof a circuit description contains a type variable m, indicating that it is overloaded in the underly-ing \nmonad. This means that we can later decide how to interpret the description by choosing an appropriate \nimple-mentation of m. The same description can be interpreted in many ways, giving various different \nsemantics to the embed- ded language. Examples of such interpretations are simula-tion (where we run \nthe circuit on specific values), and the symbolic evaluation that is used to produce VHDL code. Provable \nprove, Figure 2: Type Class structure for Interpretations 2.2 Type Classes Some circuit operations are \nmeaningful only to certain in-terpretations; Lava is therefore structured with type classes (see figure \n2). For example, a higher-level abstract circuit can deal with arithmetic operators, such as plus and \ntimes, where a physical circuit has no notion of numbers at all. We can point out groups of operations, \nwhich are supported by some interpretations but not by others, thus forming a hierarchy of classes. The \nbase class of the hierarchy is called Circuit. To be a Circuit, means to be a Monad, and to support basic \nopera-tions like and and or. class Monad m => Circuit m where and2, or2 :: (Bit, Bit) -> m Bit . . . \n Subclasses of Circuit are for example the Arithmetic class, for higher-level interpretations supporting \nnumbers, and the Sequential class, for interpretations containing delay oper-ations. class Circuit m \n=> Arithmetic m where plus, times :: (NumSig, NumSig) -> m NumSig . . . class Circuit m => Sequential \nm where delay :: Bit -> Bit -> m Bit loop : : (Bit -> m Bit) -> m Bit . . . A circuit description will \ntypically be constrained in the type to indicate what interpretations are allowed to run the de-scription. \nThe following circuit can only be run by interpre- tations supporting arithmetic: square :: Arithmetic \nm => NumSig -> m NumSig square x = times (x, x1 The architecture of the system makes it easy for the \nuser to add new classes of operations to the hierarchy, and new interpretations that give semantics to \nthem (see section 4.1).  2.3 Primitive Data Types We use the datatype Bit to represent a bit. For now, \nthis datatype can be regarded as just a boolean value, but we -f-g-h- Figure 3: compose [f,g,h] will \nslightly extend the datatype later (see section 3.2). We provide two constant values of this type: data \nBit = Boo1 Boo1 1 . . . low, high :: Bit low = Boo1 False high = Boo1 True To describe circuits at a \nhigher level, we add another prim-itive datatype, a NumSig, which represents an abstract wire through \nwhich numbers (integers) can flow. The NumSig wires will of course never appear in a physical circuit \nas an interpretation needs to be in the type class Arithmetic to handle this datatype. data NumSig = \nInt Int 1 . . . int :: Int -> NumSig int n = Int n It is possible for the user to add other datatypes \nto Lava (see section 4.1).  2.4 Combinators Common circuit patterns are captured using combinators which \nallow the designer to describe regular circuits com-pactly and in a way that makes the patterns explicit. \nThis section describes some simple combinators that will be use- ful later. The composition combinator \n>-> passes the output of the first circuit as input to the second circuit. We also provide a version \nthat works on lists (figure 3). (>->I : : Circuit m => (a -> m b) -> (b -> m c) -> (a -> m c) compose \n: : Circuit m => Ca -> m al -> (a -> m a) compose = foldr (>->I return The combinators one and two build \ncircuits operating on 2n- lists from circuits operating on n-lists. While one f applies the circuit f \nto one half of the wires and leaves the rest untouched, two f maps it to both halves (see figure 4 and \n5). one :: Circuit m => (Cal -> m [al) -> (Cal -> m [al) two :: Circuit m => ([al -> m cbl) -> ([a] \n-> m [b])  Repeated application of a function is captured by raised: The expression raised 3 two f results \nin 8 copies of the f circuit, each applied to one eighth of the input wires. Figure 4: one f Figure 5: \ntwo f raised : : Int -> (a -> a) -> (a -> a) raised n f = (! ! n) . iterate f The circuit decmap n f \nprocesses an n-list of inputs by ap- plying f (n-l), f (n-21, . , f 0 consecutively to each ele- ment \n(see figure 6). decmap : : Circuit m => Int -> (Int -> a -> m b) -> (Cal -> m Cbl) decmap n f = zipWithM \nf Cn-l,n-2 . . 01 The user can define new combinators as needed. 3 Interpretations In this section, we \npresent some interpretations dealing with concrete circuit functionality. Standard interpretations cal-culate \noutputs of a circuit, given input values. Symbolic in-terpretations connect Lava to external tools, by \ngenerating suitable circuit descriptions. 3.1 Standard Interpretation The standard interpretation we \npresent here is one that can only deal with combinational circuits, which have no notion of time or internal \nstate. In this case, it suffices to use the identity monad since no side effects are needed. data Std \na = Std a simulate : : Std a -> a simulate (Std a) = a instance Monad Std where . . . The resulting Std \ninterpretation is integrated into the sys-tem by specifying the Circuit operations. instance Circuit \nStd where and2 (Boo1 x, Boo1 y) = return (Boo1 (x &#38;&#38; y) 1 instance Arithmetic Std where plus \n(Int x, Int y> = return (Int (x + y))  type Sym a = CVarl -> (a, CVarl , [Assertion]) Figure 6: decmap \n3 f We can now simulate the example of section 2.1. Hugs> simulate (halfAdd (high, high)) (high, low) \n To deal with time and state, we can lift a combinational circuit interpretation into a sequential one. \nHow this is done is beyond the scope of this paper. 3.2 Symbolic Interpretation Lava provides connection \nto external tools through the sym- bolic interpretations. These generate descriptions of cir-cuits, rather \nthan computing outputs. External tools pro-cess these descriptions, and in turn give feedback to the \nLava system. The tools we focus on in this paper are theo- rem provers. We briefly sketch other possibilities \nin section 3.5. A circuit description is symbolically evaluated by providing abstract variables as input. \nThe result of running the circuit is a symbolic expression representing the circuit. To imple- ment this \nidea, we need some extra machinery. First of all, the signal datatypes are modified by adding a constructor \nfor a variable, since a signal in this context can be both a value and a variable: type Var = String \ndata Bit data NumSig = Boo1 Boo1 = Int Int 1 BitVar Var I NumVar Var It is important to keep the constructors \nof these datatypes abstract as the Std interpretation is unable to handle vari-ables. By introducing \nthe class Symbolic, we ensure that functions for variable creation are only available in interpre- tations \nwhich recognise variables. class Circuit m => Symbolic m where newBitVar :: m Bit newNumVar :: m NumSig \n When a circuit operation is applied to symbolic inputs, we create a fresh variable, and remember internally \nin the monad how this variable is related to the parameters of the operation. An implementation for this \ninterpretation is a state monad in an (infinite) list of unique variables, and a writer monad in a list \nof assertions. The type Expression is left abstract here. data Assertion = Var := Expression type Expression \n= . . .  The instance declaration for Circuit Sym is: instance Circuit Sym where and2 (a, b) = do v \n<-newSymbol addAssertion (v := And [a,b]) return (BitVar v) . . . When this interpretation is run on \nthe half adder from sec-tion 2.1, the following internal assertion list is generated: [ b3 := And [ BitVar \n\"bl\", BitVar \"b2\" 1 \"b4\" := Xor [ BitVar \"bl\" , BitVar \"b2\" 1 i  The inputs to the circuit are called \nbi and b2 . 3.3 Using a Symbolic Circuit How can we now prove properties of circuits? We need to be \nable to formulate the circuit properties we want to verify. To do this, we create an abstract circuit \nthat contains both the circuit and the property we want to prove. To show a full adder with its leftmost \nbit set to False equiv- alent to a half adder, we write the question: type Form = Bit question :: Symbolic \nm => m Form question = do a <-newBitVar --free variables b <-newBitVar out1 <-halfAdd (a, b) out2 <-fullAdd \n(low, a, b) equals (outl. out21 Two fresh variables a and b are given as inputs to both the half adder \nand the restricted full adder. The resulting formula (of type Form) is true if the outputs of these circuits \nare the same. The type Form is the same as Bit, so that we can use the logical operators (and2, or2, \netc.) on both types. The function question is polymorphic in the underlying interpretation; any symbolic \ninterpretation is applicable. Here, we shall instantiate m with Sym. 3.4 Verification The Sym interpretation \nis not very interesting on its own; it needs to be connected to the outside world in some way. The function \nverify takes a description of a question (which is of type m Form) and generates a file containing a \n(possibly very large) logical formula. This file is then processed by one of the automatic theorem provers \nthat is connected to Lava by means of the IO monad. verify :: Sym Form -> IO ProofResult data ProofResult \n= Valid I Indeterminate 1 Falsifiable Model  The result from the theorem prover interaction has type \nProofResult and indicates whether the desired formula was valid or not. If a countermodel (a valuation \nmaking the formulas false) can be found, it is also returned. Using Hugs, the user of Lava can run proofs \nfrom inside the interpreter. Hugs> verify question >>= print Valid This invocation generates input for \na theorem prover, con-taining the variable definitions and the question, separated by an implication \narrow: AND( b3 <-> bl &#38; b2, b4 <-> (bl #! b2) , b5 <-> FALSE &#38; bl, b6 <-> (FALSE t! bl) , bi \n<-> b6 &#38; b2, b8 <-> (b6 #! b2) , b9 <-> b5 # b7, b10 <-> (b3 <-> b9) , bll <-> (b4 <-> b8). b12 <-> \nb10 % bll ) -> b12 Currently Lava interfaces to the propositional tautology checker Prover (Sta89] and \nthe first order logic theorem provers Otter [MW97] and Gandalf [Tam97].  3.5 Other Interpretations Using \nthe same idea, we can generate input for other tools as well. An interesting target format is VHDL, which \nis one of the standard hardware description languages used in industry. There are many tools that can \nprocess VHDL, for purposes such as synthesis and efficient simulation. Running the Vhdl interpretation \non the half adder circuit (section 2.1) produces structural VHDL: --Automatically generated by Lava -- \nlibrary circuit; use circuit.all; entity halfadd is port ( bl, b2 : in std-logic; b3, b4 : out std-logic \n1; end halfadd; library circuit; use circuit.all; architecture structural of halfadd is begin compi : \nand2 port map (b3, bl, b2); comp2 : xor2 port map (b4, bl, b2); end structural; An extended form of symbolic \nevaluation generates layout information. This is done by not only keeping track of how the components \nof a circuit are functionally composed, but also how they can be laid out on a gate array. A >-> B in \nthis interpretation also indicates that A should be laid out to the left of B. Similarly, row 5 f a makes \n5 full adders and lays them out horizontally with left to right data-flow. The layout interpretation \ncan generate VHDL and EDIF (another standard format) containing layout attributes that give the location \nof each primitive component. Combining layout and behaviour in this way allows us to give economical \nand elegant descriptions of circuits, which in VHDL would require the user to attach complicated arith-metic \nexpressions to instances. 4 An Example: FFT This section illustrates how Lava is extended for signal-processing \napplications by the introduction of a complex number datatype and new combinators that allow two FFT \ncircuits to be described. The work presented here builds on previous work on de-riving the FFT within \nRuby [JonSO] and specifying signal processing software in Haskell [Bje97]. 4.1 Complex numbers Two flavours \nof complex numbers are needed for simulation and verification: concrete values and variables representing \ncomplex numbers. The implementation datatype CmplxSig reflects this: data CmplxSig = Abstract NumSig \n1 Concrete (Complex Double)  A complex datatype has to support operations like addi-tion and multiplication. \nThe FFT circuits also need twiddle factors, constants computed by w (see section 4.2). The ap-propriate \noperations are grouped together into a class. class Arithmetic m => CmplxAritbmetic m where cplus :: \n(CmplxSig, CmplxSig) -> m CmplxSig ctimes :: (CmplxSig, CmplxSig) -> m CmplxSig . . . W :: (Int,Int) \n-> m CmplxSig cplus = clift plus (+I ctimes = clift times (*> . . . instance CmplxAritbmetic Std where \n. . . instance CmplxArithmetic Sym where . . . To extend the existing interpretations with the complex \ndatatype, we must write appropriate instance implementa-tions. In this case it is simple, as the complex \narithmetic operations can be implemented by lifting the existing arith-metic operations on symbolic NumSig \nvariables and concrete Complex Double values. The twiddle factors have different meanings for different \ninterpretations: the Std interpreta-tion will get constant complex values, while Sym expects symbolic \nvalues.  4.2 Discrete Fourier Transform The Discrete Fourier Transform (DFT) computes a sequence of \ncomplex numbers X, given an initial sequence 2: N-l X(k) = c z(n) x wjp, kE {O...N-1) n=O where the \nconstant WN is defined as e-j2?rlN. x \\ / x+Y Each signal in the transformed sequence X(k) depends on \nevery input signal z(n); the DFT operation is therefore ex-pensive to implement directly. x / -\\ The \nFast Fourier Transforms (FFTs) are efficient algorithms Y I X-Y for computing the DFT that exploit symmetries \nin the twid--1 dle factors wk. The laws that state these symmetries are: w:: = 1 w, = 1 w, x w, = w;+ \nW, = w, , , (n,k I Jo We will later use the fact that Wj equals -j. These laws, together with a restriction \nof sequence length (for example to powers of two), simplify the computations. An FFT implementation has \nfewer gates than the original direct DFT implementation, which reduces circuit area and power consumption. \nFFTs are key building blocks in most signal processing applications. We discuss the description of circuits \nfor two different FFT algorithms: the Radix-2 FFT and the Radix-22 FFT [He95].  4.3 Two FFT circuits \nThe decimation in time Radix-2 FFT is a standard al-gorithm, which operates on input sequences of which \nthe length is a power of two [PM92]. This restriction makes it possible to divide the input into smaller \nsequences by re-peated halving until sequences of length two are reached. A DFT of length two can be \ncomputed by a simple butter-fly circuit. Then, at each stage, the smaller sequences are combined to form \nbigger transformed sequences until the complete DFT has been produced. The Radix-2 FFT algorithm can \nbe mapped onto a com-binational network as in figure 7, which shows a size 16 implementation. In this \ndiagram, digits and twiddle factors on a wire indicate constant multiplication and the merging of two \narrows means addition. The bounding boxes contain two FFTs of size 8. A less well-known algorithm for \ncomputation of the DFT is the decimation in frequency Radix-2 FFT, which assumes that the input length \nN is a power of four. The corresponding circuit implementation (in figure 8) is also very regular and \nmight be mistaken for a reversed Radix-2 circuit at a passing glance. However, it differs sub-stantially \nin that two different butterfly networks are used in each stage, the twiddle factor multiplications are \nmodified, and -j multiplication stages have been inserted.  4.4 Components We need three main components \nto implement FFT circuits. The first is a butterfEy circuit, which takes two inputs x1 and 22 to two \noutputs ~1 + 52 and x1 -x2 (see figure 9). It is the heart of FFT implementations since it computes the \n2- point DFT. Systems of such components will be applied to the in-signals in many stages (figures 7 \nand 8). The FFT butterfly stages are constructed by riffling together two halves of a sequence of length \nIc, processing them by a Figure 9: A butterfly Figure 10: A butterfly stage of size 8 expressed with \nriffling column of k/2 butterfly circuits, and unriffling the result (see figure 10). Here riffle is \nthe shuffle of a card sharp who perfectly interleaves the cards of two half decks. bfly :: CmplxArithmetic \nm => [CmplxSigl -> m [CmplxSigl bfly [il, i2l = do 01 <-csubtract (il. i2) 02 <-cplus (ii, i2) return \n[ol, 021 bflys :: CmplxArithmetic m => Int -> [CmplxSigl -> m [CmplxSigl bflys n = riffle >-> raised \nn two bfly >-> unriffle Another important component of an FFT algorithm is mul- tiplication by a complex \nconstant, which can be imple-mented using a primitive component called a twiddle factor multiplier. This \ncircuit maps a single complex input z to x x Wh for some N and k. The circuit w n k computes Wk. wMult \n:: CmplxArithmetic m => Int -> Int -> CmplxSig -> m CmplxSig wMult n k a = do twd <-w (n, k) ctimes (twd, \na) The multiplication of complete buses with -j is defined as follows, using the fact that W, equals \n-j. minus J :: CmplxArithmetic m => [CmplxSigl -> m [CmplxSigl minusJ = mapM (wMult 4 1) Another useful \ncomponent is the bit reversal permutation, used in the first or last stage of the FFT circuits. A new \nwire position is the reversed binary representation of the old position [PM92]. The permutation can be \nexpressed using riffle: bitRev :: Monad m => Int -> [a] -> m [a] bitRev n = compose [ raised (n-i) two \nriffle I i <-Cl. .nl  X(0, X(1) X(2, X(3) X(4, xu, X(6) X(7) X(8) WY) X(10) X(11) x(3) 3 I 3 I xw x01) \n~~)~: Figure 7: A size 16 Radix 2 FFT network 0.0 0.0 X(O) WI6 w4 X(l) 0 1 -1 I.0 X(8) WI6 W4 X(2) \\w/ \n0.2 -1 2.0 X(4 W. X(3  -I -j -I 3 0 W. x(15 -I / /-\\ xw -I -j -I 3 3 -I -j -I 3 0 hi W4 Figure 8: \nA size 16 Radix-2 FFT network 181 Note that these components are not shown in the diagrams; either the \nin-data is permuted from the start, or the out-sequence needs to be rearranged.  4.5 The Circuit Descriptions \nin Lava Inspired by the circuit diagrams we describe the two FFT circuits in Lava using higher-order \ncombinators. We begin by defining the type of an FFT parameterised by the interpretation monad m. A circuit \ndescription takes the exponent of the size of the circuit, and the list of inputs, and returns the outputs. \ntype Fft m = Int -> [CmplxSig] -> m [CmplxSigl The Radix-2 FFT is a bit reversal composed with the dif-ferent \nstages. radix2 :: CmplxAritbmetic m => Fft m radix2 n = bitRev n >-> compose C stage i I i <-Cl. .nl \n1 where stage i = raised (n-i) two $ twid i >-> bflys (i-1) twid i = one (decmap (2-(i-1)) (wMult (2-i))) \nThe Radix-2 FFT is the sequence of stages composed with the final bit reversal. radix22 :: CmplxAritbmetic \nm => Fft m radix22 m = compose C stage i I i <-[m,m-1.. II 1 >-> bitRev (2*m) where stage i = raised \n(m-i) (two.two) $ bflys (2*i-1) >-> one (one minusJ) >-> two (bflys (2*i-2)) >-> twid i twid i = column \nC decmap (4 (i-1)) (wMult (4-i) . (wt *)) I wt <-C3.1.2.01 1 The corresponding VHDL descriptions would \nbe several times longer.  4.6 Running Interpretations We can now run some interpretations on our FFT \ncircuits. Simulation is possible in the standard interpretation, if we provide an exponent and specific \ninputs to the circuit. input :: [CmplxSigl input = map cmplx [1:+4,2:+(-2) ,3:+2,1:+2] Hugs> simulate \n(radix2 2 input) [1.0:+6.0,(-l.O):+(-6.0),(-3.0):+2.0,7.0:+6.01 The symbolic interpretation can be applied \nto verify that two circuit instances are equivalent, using the first order theorem prover Otter [MW97]. \nWe create an abstract circuit stating the equivalence: fftSame :: (Symbolic m, CmplxAritbmetic m) => \nInt -> m Form fftSame n = do inp <-newCmplxVector (4-n) out1 <-radix2 (n*2) inp out2 <-radix22 n inp \nequals (outl, out21 The newCmplxVector function generates a list of complex symbolic variables. After \napplying both of the circuits to these inputs, we ask if the outputs are the same. Before we can verify \nthis equation, we have to add some knowledge to Otter: laws about complex arithmetic, and in particular \nthe laws about twiddle factors. This information is added in the form of theories, which are defined \nby the user in Lava, and given to the prover as a proof option. Otter now shows circuit equivalence for \nsize 4 FFTs (we have proven circuits of size 16 and 64 equivalent as well). options : : [Proof Options1 \noptions = C Prover otter , Theory arithmetic Theory (twiddle 4) i Hugs> verify options (fftSame 1) >>= \nprint Valid Figure 11 shows the formula that is generated as input to Otter (notice the arithmetic and \ntwiddle factor theory). 4.7 Related work on FFT description and verifica-tion The equivalence of a Radix-2 \nFFT algorithm and the DFT has been shown using ACLZ, a descendant of the Boyer-Moore theorem prover [Gam98]. \nOur approach in the ex-ample is slightly different in that we want to show auto-matically generated logical \ndescriptions of circuits of a fixed size equivalent, rather than proving mathematical theorems about \nthe algorithms. The verifications are similar how-ever, in that both methods use relationships between \nab-stract twiddle factors. 5 Related Work In this section, we discuss related work on the use of func- \ntional languages for hardware description and analysis. The work described here has its basis in our \nearlier work on /IFP, an extension of Backus FP language to synchronous streams, designed particularly \nfor describing and reasoning about regular circuits [She85]. We continue to use combina- tors for describing \nthe ways in which circuits are built. What we have gained through the embedding in Haskell, is the availability \nof a full-blown programming language. The syn- chronous programming languages Lustre, Esterel and Signal \n%% Automatically generated by Lava %% %% THEORY Arithmetic %% list (demodulators). eq(tim(x, plus(y, \nz)), plus(tim(x, y), tim(x, 2))). eq(tim(x. sub(y, z)), sub(tim(x. y). tim(x. z>)). eq(tim(1, x), x). \neq(tim(x, tim(y, 2))) tim(tim(x, y). z)). end-of-list. %% THEORY Twiddle Factors size 4 %% list (demodulators) \n. eq(W(x, O), 1). eq(W(x. x1. I). $LE(x, 4) -> eq(W(x, y), W($PROD(2,x), $PROD(2,y))) eq(tim(W(x.y) .W(x,z)> \n,W(x,$SUN(y,z))). end-of-list. %% SYSTEM + QUESTION %% list (sos) . eq(x,x). -eq(sub(sub(a4, tim(W(2,0), \na2)>, tim(W(4.1), sub(a3,tim(W(2,0), al)))), tim(W(B,O), sub(sub(a4, a2),tim(W(4, 11, sub(a3, al))))) \n1 -eq(sub(plus(a4, tim(W(P,O), a2)), tim(W(4.0)) plus(a3, tim(W(2.01, al)))), tim(W(4, 01, sub(plus(a4,a2), \nplus(a3, al)))) I -eq(plus(sub(a4, tim(W(P,O), a2)>, tim(W(4,1), sub(a3,tim(W(2,0), al>))), tim(W(4,0), \nplus(sub(a4, al) ,tim(W(4,1), sub(a3, al))))) 1 -eq(plus(plus(a4, tim(W(2,O). a21). tim(W(4.01, plus(a3, \ntim(W(2.01, al)))), tim(W(4. 01, plus(plus(a4,a2), plus(a3. al)))). end-of-list. Figure 11: Otter input \nfor size 4 FFT comparison can all be used to describe hardware in much the style used here. Further \nexperiments in this direction are being carried out in the EU project SYRF. A source of inspiration has \nbeen John O Donnell s Hydra system [O DSS]. In Hydra, circuit descriptions are more di-rect because they \nare written in ordinary Haskell. There are no monads cluttering up the types, and this must be an advantage. \nIt is our use of monads, however, that makes Lava easily extensible, while Hydra is less SO. The Hydra \nsystem has not, as far as we know, been used to gener-ate formulas from circuit descriptions, for input \nto theorem provers, although the idea of having multiple interpretations has been a recurring theme in \nO Donnell s work. Launchbury and his group are experimenting with a dif-ferent approach to using Haskell \nfor hardware descrip-tion [CLM98]. In Hawk, a type of signals and Lustre-like functions to manipulate \nit are provided. Circuits are mod-elled as functions on signals, and the lazy state monad is used locally \nto express sequencing and mutable state. The main application so far has been to give clear and concise \nspecifications of superscalar microprocessors. Simulation at a high level of abstraction has been the \nmain circuit analy-sis method. Work on using Isabelle to support formal proof is under way, however. \nAlso, it seems likely that Lava in-put could be generated from Hawk circuit descriptions. We plan to \nexplore this possibility in a joint project. Hawk has, at present, no means of producing code for the \nproduc- tion of real circuits, although work on circuit synthesis is in progress. Keith Hanna has long \nargued for the use of a functional language with dependent types in hardware description and verification \n[HD92]. Hanna s work inspired much research on using Higher Order Logic for hardware verification. The \nPVS theorem prover, which is increasingly used in hardware verification [Cyr96], is also based on a functional \nlanguage with dependent types. We do not know of work in which cir-cuit descriptions written in this \nlanguage are used for any-thing other than proof in PVS. HML is a hardware description language based \non ML, de-veloped by Leeser and her group [LL95]. The language ben-efits from having higher order functions, \na strong type sys-tem and polymorphism, just as ours does. The emphasis in HML is on simulation and synthesis, \nand not on formal verification. 6 Conclusions The Lava system is an easily extensible tool to assist \nhard- ware designers both in the initial stages of a design and in the final construction of a working \ncircuit. The system al-lows a single circuit description to be interpreted in many different ways, so \nthat analyses such as simulation, formal verification and layout on a Field Programmable Gate Ar-ray \nare supported. Furthermore, new interpretations can be added with relatively little disturbance to the \nexisting sys-tem, allowing us to use Lava as the main workbench for our research in hardware verification \nmethods for combinational and sequential circuits. To be able to provide these features, we rely heavily \non advanced features of Haskell s type sys-tem: monads for language embedding, polymorphism and type \nclasses to support different interpretations, and higher order functions for capturing regularity. The \nsystem is an interesting practical application of Haskell, which has proved to be an ideal tool, both \nas a hardware de-scription language and as an implementation language. As demonstrated in the FFT examples, \nour circuit descriptions are short and sweet, when one can find a suitable set of combinators. Our experience \nwith Ruby indicates that each domain of application (such as signal processing, pipelined circuits or \nstate machines) gives rise to a small and manage- able set of combinators. The largest circuit that has \nbeen tackled so far is a 128 bit by 128 bit combinational multiplier. To deal with this circuit, we needed \nto us a Haskell compiler (HBC) rather than Hugs. Writing the Lava system has been an educational exercise \nin software engineering. More than once, we have thrown everything away and started again. The latest \nversion ex-ploits Haskell s type system to impose a clear structure on the entire program, in a way that \nwe find appealing. We have all been taught to think about types very early in the design of a system. \nLava demonstrates the advantages of doing so. Future Work Logic Decomposition. PhD thesis, Lund Institute \nof Technology, 1995. We are continuing to develop the Lava system; this paper is a report of work in \nprogress rather than a description of a finished project. Until recently, we had several specialised \nversions of Lava, each concentrating on a particular aspect of design such as verification or the production \nof VHDL. The work of merging these versions has only just begun; it was really the need for fusion that \npushed us towards the current system design. Incorporating the interpretation that takes care of layout \nproduction is a non-trivial task, as this code is necessarily large and complicated. This may lead to \nfurther changes to the top level design of Lava. To make the system more usable, we need to add many \nnew interpretations. For example, we would like to work on test pattern generation and testability analysis, \nusing earlier work by Singh as a basis [SinSl]. All of these interpretations must be tested on real case \nstudies. We would be able to generalise our system further if multiple parameter type classes were provided \nin Haskell. At present, all of the interpretations share the same primitive datatypes. Using multiple \nparameter type classes, each interpretation could support its own data types, with the required features. \nIn the area of verification, we are working on interpretations involving sequential operations, such \nas delay, and on related methods to automatically prove properties of sequential cir-cuits. We are working \non a case study of a sequential FFT implementation provided by Ericsson CadLab. Inspired by the Hawk \ngroup, we find it hard to resist investigating verifi-cation of the next generation of complex microprocessors. \nIn particular, we are interested in the question of how to design processors to enable verification to \nproceed smoothly. References [Bje97] Per Bjesse. Specification of signal processing pro-grams in a pure \nfunctional language and compila-tion to distributed architectures. Master s thesis, Chalmers University \nof Technology, 1997. [CLM98] Byron Cook, John Launchbury, and John Matthews. Specifying superscalar microprocessors \nin Hawk. In Formal Techniques for Hardware and Hardware-like Systems. Marstrand, Sweden, 1998. [Cyr96] \nDavid Cyrluk. Inverting the abstraction mapping: A methodology for hardware verification. In Formal Methods \nfor Computer Aided Design of Electronic Circuits (FMCAD), number 1166 in Lecture Notes In Computer Science. \nSpringer-Verlag, 1996. [Gam98] Ruben Gamboa. Mechanically verifying the cor-rectness of the Fast Fourier \nTransform in ACLZ. In Third International Workshop on Formal Methods for Parallel Programming: Theory \nand Applications, 1998. [HDSS] Keith Hanna and Neil Daeche. Dependent types and formal synthesis. Phil. \nTrans. R. Sot. Lond. A, (339), 1992. [He951 Shousheng He. Concurrent VLSI Architectures for DFT Computing \nand Algorithms for Multi-output [Jon901 Geraint Jones. A fast flutter by the Fourier trans-form. In Proceedings \nZVth Banff Workshop on Higher Order. Springer Workshops in Computing, 1990. [JS90] Geraint Jones and \nMary Sheeran. The study of but- terflies. In Proceedings IVth Banff Workshop on Higher Order. Springer \nWorkshops in Computing, 1990. [LL95] Yanbing Li and Miriam Leeser. HML: An innova-tive hardware design \nlanguage and its translation to VHDL. In Computer Hardware Description Lan-guages (CHDL 95), 1995. [MW97] \nWilliam W. McCune and L. Wos. Otter: The CADE-13 competition incarnations. Journal of Au-tomated Reasoning, \n18(2):211-220, 1997. [O DSS] John O Donnell. From transistors to computer ar-chitecture: Teaching functional \ncircuit specification in Hydra. In Functional Programming Languagues in Education, volume 1125 of Lecture \nNotes In Com-puter Science, pages 221-234. Springer Verlag, 1996. [PM921 John Proakis and Dimitris Manolakis. \nDigital Sig-nal Processing. Macmillan, 1992. [SB98] Mary Sheeran and Arne Boralv. How to prove properties \nof recursively defined circuits using Stalmarck s method. In Formal Techniques for Hardware and Hardware-like \nSystems. Marstrand, Sweden, 1998. [She851 Mary Sheeran. Designing regular array architec-tures using \nhigher order functions. In Int. Conf. on Functional Programming Languages and Computer Architecture, \n(Jouannaud ed.), volume 201 of Lec- ture Notes In Computer Science. Springer Verlag, 1985. [Sin911 Satnam \nSingh. Analysis of Hardware Description Languages. PhD thesis, Computing Science Dept., Glasgow University, \n1991. [SR93] Robin Sharp and Ole Rasmussen. Transformational rewriting with Ruby. In Computer Hardware \nDe-scription Languages (CHDL 93). Elsevier Science Publishers, 1993. [St&#38;891 Gunnar Stalmarck. A \nSystem for Determining Propositional Logic Theorems by Applying Values and Rules to Triplets that are \nGenerated from a For-mula, 1989. Swedish Patent No. 467 076 (approved 1992), U.S. Patent No. 5 276 897 \n(1994), European Patent No. 0403 454 (1995). [Tam971 Tanel Tammet. Gandalf. Journal of Automated Reasoning, \n18(2):199-204, 1997. [Wad921 Philip Wadler. Monads for Functional Program-ming. In Lecture notes for \nMarktoberdorf Summer School on Program Design Calculi, NATO AS1 Se- ries F: Computer and systems sciences. \nSpringer Verlag, August 1992.   \n\t\t\t", "proc_id": "289423", "abstract": "Lava is a tool to assist circuit designers in specifying, designing, verifying and implementing hardware. It is a collection of Haskell modules. The system design exploits functional programming language features, such as monads and type classes, to provide multiple interpretations of circuit descriptions. These interpretations implement standard circuit analyses such as simulation, formal verification and the generation of code for the production of real circuits.Lava also uses polymorphism and higher order functions to provide more abstract and general descriptions than are possible in traditional hardware description languages. Two Fast Fourier Transform circuit examples illustrate this.", "authors": [{"name": "Per Bjesse", "author_profile_id": "81100224948", "affiliation": "Chalmers University of Technology, Sweden", "person_id": "PP14088066", "email_address": "", "orcid_id": ""}, {"name": "Koen Claessen", "author_profile_id": "81100206977", "affiliation": "Chalmers University of Technology, Sweden", "person_id": "P162548", "email_address": "", "orcid_id": ""}, {"name": "Mary Sheeran", "author_profile_id": "81100168630", "affiliation": "Chalmers University of Technology, Sweden", "person_id": "PP31096414", "email_address": "", "orcid_id": ""}, {"name": "Satnam Singh", "author_profile_id": "81100280060", "affiliation": "Xilinx", "person_id": "PP31096846", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/289423.289440", "year": "1998", "article_id": "289440", "conference": "ICFP", "title": "Lava: hardware design in Haskell", "url": "http://dl.acm.org/citation.cfm?id=289440"}