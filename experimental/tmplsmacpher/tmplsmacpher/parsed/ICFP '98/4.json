{"article_publication_date": "09-29-1998", "fulltext": "\n Taming Effects with Monadic Typing 1 Richard B. 11.ieburtz Oregon Graduate Institute Portland, Oregon, \nUSA dick@cse.ogi.edu Abstract The familiar Hindley-Milner type system of the ML language family is extended \nwith monad annotations to account for possible side effects of expression evalu-ation. This also allows \neffects to be effectively encap-sulated by lexical scopesrwith enforcement provided by type checking. \nA type-and-effects analysis sup-ports type inference. Type soundness and complete-ness theorems establish \nthe coherence of monadic type inference with the reference semantics of a small ML-style language. Introduction \nModern functional languages such as Haskellr Stan-dard MLrCAML and Clean have evolved into wide spectrum \nprogramming languages through the addi-tion of imperative features and foreign-language in-terfaces to \na purely functional core. This evolution has been necessary to make these languages practical vehicles \nfor the design and implementation of soft-ware systems but it has impaired our ability to rea-son about \nand formally manipulate programs. When evaluation of an expression may produce a side ef-fectrthe meaning \nmay depend not only upon the ex-pression itselF but upon the context in which it is evaluated. ConventionalT \nstructural typing of expressions does not account for possible side effects. Some pro-gram transformation \ntechniques such as type-directed partial evaluation [DGT96]r depend upon the fact that polymorphically \ntyped expressions in the first-order lambda calculus have unique normal forms. 1 The research reported \nin this paper was supported by the USAF Materiel Command. These techniques cannot be applied to SML pro-gramsr \nfor instanter because normal forms of poly-morphic SML expressions cannot be inferred from their types \nwhen expressions may have side effects. To resolve questions about the scope of possible effectsr Talpin \nand Jouvelot proposed a type-and-effects analysis for functional programming languages [TJ92r Ta19.31. \nThe result of this analysisr calcu-lated in conjunction with type reconstructionr ex-presses the possible \neffects of evaluating an expres-sion. Region analysis identifies dynamically allocated variables with \nsyntactically scoped regions of a pro- gramrallowing potentially mutable variables to be al- located \nand deallocated in a stack discipline [TT97]. A different approach to effects characterization is taken \nin Haskellr where effects-inducing operations are explicitly associated with monads. Operations on a \nstate variable in Haskell can be restricted to a declared scope for an instance of the state monad [LP95]. \nFurthermorerconfusion of distinct state vari-ables can be prevented by an extended type system. Thus \nthe uses of mutable state in Haskell can be effec- tively encapsulated. In a contemporary paper in this \nconference [Wad98]I Philip Wadler shows that the ef-fects typing of Talpin and Jouvelot can be recast \nin a framework of monads. He transposes their region analysis into a reconstruction algorithm for monadic \ntypes. This paper takes a different approachrcon-strutting monadic types for effects when regions are \nassociated with lexical scopes. Since this approach is newrwe offer proof of its soundness and completenessr \nrelative to a semantics for an imperativerfunctional language. This paper shows that monadic type inferencer \nbased upon effects analysisr can also be used as a general mechanism to enforce encapsulation of effects \nin a strict functional languagerwhere monads are im-plicit rather than explicit. The monadic type/effects \nsystem solves the problem of incomplete specification of effects and identifies expressions that are \npurely functional. It requires less ambitious analysis than does region analysis [BTV96]. Region analysis \nmust infer a scope in which each reference defined in a pro- gram remains accessibler whereas the monadic \ntype inference proposed here merely enforces a policy that requires effects to be restricted to a lexically \ndefined scope. It relies upon the block structure of declara-tions to define the scopes of variablesrand \nthus of regionsr whereas region analysis makes no such as-sumption. An interesting application of monadic \ntyping for effects is described by Andrew Tolmach [To198]. The potential effects of evaluating each expression \nin an ML program are inferred in a typed intermediate lan-guagerusing monad (but not region) inference. \nThe estimates of effects given by monadic typing are then used to determine when program transformations \ncan be safely applied to optimize a program during com-pilation. Polymorphic typing in the presence \nof effects is well known to be problematic. A reference or an ex-ception constructor with a polymorphic \ntype might have bound to it (by assignment or by raising an ex-ceptionrrespectively) a value of a more \nspecific type. Since values of different types might be bound in sep-arate occurrences of a reference-typed \nvariable or of an exception constructorra type system that permits polymorphism with effects may be unsound \nunless further restrictions are imposed. One such restriction limits polymorphism to ex-pressions with \nmanifest values [TofBT?T TJ92PWri95P MTM97PWad981. The value restriction assures that evaluating a polymorphic \nexpression cannot entail ef-fects. Monadic typing allows effects-free expressions to be distinguished \nthrough the type system and thus permits relaxation of the value restriction while main-taining soundness \nof typing. This is discussed in sec-tion 5. 2 Lexical scopes for effects Lexical scopes allow logical \nassertions of program properties to be directly associated with textual blocks smaller than a whole program. \nPrograms with effects are particularly difficult to reason about when effects-sensitive expressions are \ndynamically bound in a program. Our goal is to show how a type system ex-tended with effects analysis \nsupports the enforcement of a lexical scoping discipline on effects. The reader should bear in mind that \nthe restriction of effects to lexical scopes is not imposed by any existing program-ming language known \nto the author-it represents a discipline on the use of effects that disciplined pro-grammers might find \nuseful. To illustrate the techniquef we shall apply it to two different effects mechanismsr exceptions \nand state. We consider pure exceptions (they do not carry val-ues of other types) that can be first-class \n(but scope-restricted) values. State is realized with references to typedf mutable storage cellsras in \nSML. 2.1 Mini-ML with Effects To provide a platform on which to explore type-based enforcement of effects \nencapsulation we introduce a small language in the ML family-Mini-ML/Effects. Its syntax consists of \nthree forms: expressionsrstate-ments and matches. E ::= (num) 1 (op) 1 (uar) 1 fun Ident j E 1 exnIdent+E \n( (E,E) 1 EEI(E) 1 let Ident = E in E I raise E I try E with Matches end 1 ref E 1 ! E I Stmt ; E Stmt \n:I= E := E Matches ::= (num) =+ E [ I (num) + E] In each let block (and in the global scope) there is \nimplicitly declared a single exception. Since there is exactly one exception per blockr and the typing \nsystem we shall define will not allow an exception to escape from the block in which it is definedran \nex-ception can be named by the numeral corresponding to the nesting level of the block in which the excep-tion \nis declared. This convention is not meant as a proposal for realistic language designr but rather to \nsimplify the semantic description of Mini-ML/Effects by removing the need to maintain an environment \nthat associates exception names with their scopes. Occurrences of numerals will be distinguished as ei-ther \nexception names or integer constants by their typing. Abstraction with respect to an exception is distinguished \nfrom ordinary value abstraction by the keyword exn. 2.2 A semantics for Mini-ML/Effects Because Mini-ML/Effects \nhas both state and excep-tion&#38; it is awkward to express its meaning via a reduction semantics. A \ncontinuation semantics can account for the interaction of exceptions with stater as well as other effectsrwithout \nencoding the effects mechanisms as data. HoweverPa notation in which lambda calculus expressions are \nused to express con-tinuations is not particularly easy to read. To make the semantic structure more \nevident in the notationrwe employ a suite of semantics combina-tors. Mini-ML is given semantics in a \nmonad of state and exceptionsrthus each combinator expresses either a side-effecting operation in this \nmonadf or the injec-tion of a proper f or non-side-effecting construction into the monad. Typical of \nthe proper combinators is DistLRr which expresses the distribution of the monad across products. Although \nthe construction of a pair of val-ues does not induce a side effectrwhen this operation is extended to \nthe construction of a pair of compu-tationsrthe potential effects of computing each com-ponent must be \npropagated. The combinator DistLR reflects the decision to propagate effects from left to right in evaluating \nthe components of a pan. The opposite sense of effects propagation could have been chosen if that were \nthe intended meaning of the lan-guage. The semantics domains are: threading can be made explicit by n-expanding \nthese Value = Num 1 Lot 1 Exn I Value x Value ) Num -+ Computation Env = Ident-+ Value State = Nat x \nLot + Value C-cant = State+ Result E-cant = Value -+ Env -+ State -+ Result Computation = E-cent -+ C-co&#38; \nlist + Env -+ State -+ Result The domain of control continuation&#38; C-contrmodels the continuations \nthat may be defined by an excep-tion handler. 2.2.1 Semantics functions Three semantic interpretation \nfunctions are used in defining Mini-ML/Effects: &#38; : Expr -+ Computation S : Stmt -+ C-cant --+ C-cant \nlist -+ Env + State + Result  M : Match + E-cant -+ C-cant list -+ C-cent list  These interpretation \nfunctions will be defined in terms of a set of combinators of a monad that char-acterises the semantics \ndomain we have specified. 2.2.2 A monad of semantics interpretation The semantics of expressions in \nMini-ML/Effects are given in a monad whose structure can be thought of as an abstract machinercapable \nof supporting compu-tation with state and exceptions. We call this monad Sem. This monad identifier can \nbe thought of as a type constructor that injects a Mini-ML/Effects typer rrinto a s-sorted semantic type. \nSpecificallyra T-sorted semantic type will have the structure of the domain Computationf but is specialized \nin that the value expected by the E-cant argument belongs to the specific value domain associated with \nthe source language type r. The combinators for the unit and the natural extension in the monad of state-and-exceptions \nare given below. Recall that the types of the unit and natural extension combinators of a monad are: \nUnit : cr + Sem(cr) Ext : (o -+ Sem(P)) + Sem(cu) + Sem(P) Following common practicer the definitions \nof these combinators are given in n-reduced form. State 2Some authors use bmdas an alternative to the \nnatural extension combinator [Wad92]. The difference is inversion of the order of the first two arguments. \ndefinitions. Unitvkcs=kv Ext f m k cs = m (Xv. f v k cs) cs Combinators are also needed to embed the \nmonad in a Cartesian-closed category. The combinators DistLR and S emi-dist define how computations are \ndistributed over products; the combinator App de-fines the computation of applications. DistLR : (Sem(a) \nx Sem(P)) + Sem(a x /3) DistLR(P,Q)kcs=P(Xv~.Q(Xv~.k(v~,v~))~s)~s Semi-dist : (Sem( 1) x Sem(o)) -+ Sem(cr) \nSemi-dist (S, P) k cs = S (P k cs) cs App : (Sem(cu + Sem(P)) x Sem(a)) -+ Sem(P) App = (Ext ap) o DistLR \nwhere ap is the function application combinator of a Cartesian-closed categoryr satisfying the equation \nadf, e) = f e. A combinator Abs provides a semantic definition of the abstraction of an expression with \nrespect to a variable. Abs : (Ident, x Sem(p)) -+ Sem(cu + Sem(p)) Abs (x, P) = Unit(Xv k. P (Xu t. k \nu (e $ [x H v]))) These are proper combinators of the monad Semri.e. these combinators do not specify \neffects semantics. The remaining combinators specify effects.  2.2.3 Stateful effects combinators Store \nis organized as a stack of regionsreach providing a mapping of locations to values. Three state access \ncombinators describe: allocation and initialization of a storage location in the region at the top of \nthe stackr reference to a stored valuerand assignment of a new value into a storage location. In the \nsequelr zurong is the name of an excep-tional continuation to be invoked in case an invalid block level \nindex is encountered. Whenever the wrong continuation is invokedr it is applied to the cur-rent storer \nmodeling a core dump . The variable c ranges over stacks of storage regions. The func-tion new-ref : \n(Location-+ Value)+Location delivers a location distinct from any in the domain of its argu-ment. A pairr(i, \n1) E Natx Locationis the representa-tion of a reference and belongs to the Value domain. In this representationr \nthe Nat component is the in-dex of a storage region (counting from the bottom of the stack) and the Location \ncomponent is an address within the indexed storage region. The combinator Handle applies a computation \nto a normal continuation and a list of exceptional contin- 4110~ : Computation -+ Computation uations. \nAllot P k = P (Xv (s::a). let i = lengtha -1 and 1 = newref s in k (ill) ((s u (1 I+ u})::u)) Deref : \nComputation -+ Computation Deref P k = P (X(i, 1) g. let d = length o -1 in if i > d then wrong u else \nindex 1 k (d -i) d g) where index 1 k n [sd, . , snr . , so] = k (sn[l]) Assign : (Computation x Computation) \n+ Computation Assign (P, Q) c = DistLR(P, Q) (X((i, Z), U) u. let d = lengthu -1 in if i > d then wrong \nu else c ( Update 1 u (d -i) u)) where Updatelvn[sd ,..., sn ,..., so]= [sd, . . I sn @ [I I-b u], , \nSO]  2.2.4 The block entry combinator The Restore combinator pushes a newrempty storage region onto \na stack of regionsrbut restricts the store in the result continuation to the previously existing stack. \nRestore will be used in defining the semantics of local definitions (i.e. let expressions) to provide \na new storage region for references allocated in each declaration block. The notation a&#38;, denotes \nthe re-striction of a stack to its base segment of length nP i.e. CT&#38;= u if lengthu 5 n (s :: u)&#38;~= \nuJ. otherwise Restore also pushes wrong onto the stack of excep-tional continuations. Restore D k cs \nu = D (Xv u . k v u J-lengthc) (wrong::cs) (0:: u)  2.2.5 Control combinators The control combinator \nThrow specifies how an ex-ceptional continuation is accessed. ifn<d Throw n k [cd,. . , car.. . , co] \n= cn wrong otherwise The combinator Insert replaces an indexed instance of a control combinator in a \nlist. Insert (n, c ) [cd,. . . ,&#38;I,..., co] = [Cd, . . , cn+l,c , Cn-1,). . , co] ifn<d Cl otherwise \nHandle : (Computationx (E-cant -+ C-cant list -+ C-cant list)) -+ Computation Handle (P, Q) k cs = P \nk (Q k cs)  2.2.6 Semantics definitions Semantics functions are defined in terms of the com-binators \ngiven in the preceding section. The function fofoldr : (a x b -S b) + b -+ a list -+ b is the list reduction \ncombinator. To express the semantics of matches belowrthe formula uses patterned abstrac-tions to bind \nsyntactic constructs in an argument of foldr. Patterned abstractions abbreviate the op-erations of parsing \na list of matches and extracting subexpressions. &#38;[x] = Xk cs t. k (e[x]) e where x is a variable \nE[( num)j = Unit (numeral-to&#38;t (num)) E[(op)l = Unit ( Unit o (token-to-oper (op))) &#38;[fun x \n+ e] = Abs (x, E[ej) C[exn n j e] = Abs (n, e[e]) f[(el, e2)] = DistLR (@l], E[e2]) Ef-3 -521= App(dh], \nt$dJ) E[let x = e in en = Restore (App (Abs (x, E[e]I), E[e n)) Cl[raise i] = Throw i E[try e matches] \n= Handle(L[e], M[matchesn) E[ref e] = Alloc(E[eJj) E[!e] = Deref (cUeI/) &#38;Us ; e]l = Semi-dist(S[s]l, \n&#38;[el) S[el := e2n = Assign(E[el]l, C[e2JJ) M[matchesj k cs = foldr(X([i + en, cs ). Insert (i, \nE[e]I k cs) cs ) cs matches 2.3 Level-indexed types scope exceptions and references The scopes of let \nexpressions in a program form a tree embedded in the program s abstract syntax tree. At any program pointrthe \nnested scopes containing it can be indexed by natural number&#38;with index zero designating the outermostror \nglobal scope. We as-sociate with each exception and reference definition point the (largest) index of \na nested scope that con-tains it. So that the lexical scopes of let expressions will agree with the intended \nsemantic scoping of effect&#38; assume that in an expression let x = e in er the expression e has the \nsame scope as does e. This scoping convention makes recursive definitions possi-bleralthough we are not \nusing it for this purpose and have not provided semantics for recursive definition. Exceptions and references \nin Mini-ML/Effects are first class values and could be passed out of the scope of their definition points \nif no restriction prevented it. To account for the lexical scope of a reference definitionr the argument \nof the Ref constructor for type expressions consists of a lexical nesting index paired with the type \nof a stored value. At the definition point of a ref expressionr the lexical index is bound. For exampleran \noccurrence of the expression ref 0 at block level j will be typed as Ref(j,int). Similarlyrexceptions \nare designated by the index of a block in which the exception is (im-plicitly) declared. For simplicityr \nMini-ML/Effects defines exactly one exception per let block. An exception constant is simply a numeralr \ntyped as n : Exn(n). The following definition captures the intuition that underlies lexicallv scooed \ncontainment: wher- 1 ever a reference defined in block level i is admissibler II so also is a reference \nto a value of the same type de-fined at a block level irwhere i 5 j. To compare Ref typesf we need an \nordering on the types that depend on a lexical index. The intuition underlying lexically scoped containment \nis that a ref- erence to a type T value defined in a block at level j is in scope in any block that is \nnested within this block. The partial ordering of nested blocks motivates the following definition: \nDefinition 1: least upper bound of Ref and Exn types. l.u.b.(Ref (7, i), Rej(r , i )) = Ref(mgu(7, T \n), max(i, i l.u.b.(Exn(i), Exn(i )) = Exn(max(i, i )) where mgu(r, 7 ) is the most general unifier of \nT and r rif it exists. 0 2.3.1 Level based type constraint Because the types of references and exceptions \nde-pend upon the block level of their declarationrit is possible to use type checking to constrain references \nand exceptions to the scopes of their definitions. This constraint is imposed on the types of let expressions. \nThe type system will allow no occurrence of a Refer Exn type for which the block index given in the type \nexceeds the block level of the context. Not only might a reference or an exception value leak from the \nscope of its definition by explicit occur-rencerit might also be made accessible outside this scope if \nit were embedded in the body of an exported function. For exampler the following code sequence defines \na pair of functions that export read and write access to a nested reference: letx=refOin ((fun y *!x), \n(fun y * x := y; y))  To prevent the leakage of access methods in this wayr we rely upon level-stratified \nmonad annotations in an extended type system to prohibit the export of such functions from the block \nin which the reference has been defined. 3 Monadic types for lexical scopes Mini-ML/Effects has an underlying \nHindley-Milner type system that relates expressions to the domains in which their values reside. Howeverrexpressions \nmay also induce effects which are not accounted for by or-dinary types. In the semantics of Mini-ML/Effectsr \nside effects of evaluation are represented by interpret- ing each expression in a monad. 3.1 Monadic \ntype constructors The monads in which the effects of Mini-ML/Effects expressions may be interpreted are: \nId -the identity monad; no effects are supportedr Sr -the state reader monad; only reading of state is \nsupportedr St -the state monad; supports both reading and mutation of stater Ex -the exception monad; \nexceptions may be raisedr ExSr -a composite of exceptions and the state readerr ExSt -a composite of \nexceptions and state. These symbols are used as type constructors in the Mini-ML/Effects type system. \nFor instancerif T is a typerthen Ex(r) designates the computations of type T in the monad of exceptions. \nThe effects monads form a latticerindicated by the diagram of Figure 1. The partial order which induces \nthe lattice is inclusion of effects. That isrAIl L It42 if all side-effecting operations defined in the \nmonad Mr are also defined in Mz. The 1.u.b. of a pair of monadic types is formed by taking 1.u.b. of \nthe two monadic type constructors in the latticef applied to the most general unifier of the ordinary \ntypes. Note that there is no general procedure for constructng a composite monad from two given monads. \nComposite monads are defineable in the cases we have considered herer as in many other instances of computational \nmonads [JD94]. ExSt ExSr Ex Sr \\/ Id Figure l-The lattice of effects monads  3.2 Level-stratified monad \nannotations Since effects actions are associated with lexical block indices memoized at the definition \nof a reference ex-pression or exceptionra monad annotation can be as-sociated with each block. The monad \nis determined by possible effects associated with the references and exception declared in the block. \nAn expression that accesses references or exceptions defined in several blocks is interpreted in a composite \nmonad composed from block-indexed components. Notation. 4 level-indexed monad annotationis a list of \nmonad annotations indexed from 0 through some i corresponding to nested declaration contexts. For exampler \nEzo Sri Id2 Sts is a level 3 indexed monad annotation list. If A4 is a variable ranging over level-indexed \nmonad annotationsrlet Ml, stand for the restriction of M to levels 0 through i. Indexing by a subscript1 \nas M,rdenotes the ith component of M. For instanter Ml; Mt+l = M&#38;+1. The monad denoted by a level-indexed \nmonad annotation list M Jt is given by the 1.u.b. of the individually indexed monad annotations in the \nlistr u;=, MJ. For examplerthe expression if !r > 0 then x := +(!x, !r); !x else raise 0 fi where r is \nbound to a ref expression in block lrx is bound in block 3 and the exception is defined in block Orwould \nbe interpreted in the composite monad ExStT but would be annotated as EXO Sri Id2 Sts. The 1.u.b. of \ntwo level-indexed monad annotation lists is calculated by taking the 1.u.b.s of the elements of the two \nlistsron a pointwise basis. By an abuse of notationrwe extend this convention to the 1.u.b. of an indexed \nannotation list with a scalar monad anno-tation. ThusrExoSrlIdzSts u St1 = ExoStlZdzSta. A monad annotation \nexpression is applied to a typeh-rto form a monadic type expression. The infix 1.u.b. operator (u) binds \nmore tightly than does ap-plication. The meaning of such an expression is the type gotten by applying \nthe monad denoted by the annotation list to r. Howeverrit will be convenient to represent a composite \nmonadrwhen used as a type constructorrby a level-indexed annotation listras it supports description of \neffects constraint by scoping. cl  3.3 Typing as an abstract semantics The semantics combinators introduced \nin Section 2.2 can be given an abstract interpretation as typing com-binators. The typing interpretations \nof the semantic combinators (annoted by a prime) are functions in a domain of monadic type expressions. \nSince monad annotations depend upon a lexical index valuera typing interpretation can only be given in \nthe context of a lexical scope. The relation of a typing interpretation to a level index is indicated \nby the symbol (b). Its meaning is simply that the in-dexed monad annotation list used as a type construc-tor \nis restricted to the number of levels specified by the number to the left of the relation symbol. i /= \nM(r) -M = Ml; We shall overload this relation symbol in two ways. We write i b Id(r) as an abbreviation \nfor the level-indexed monad annotation expression i k Ido.. . Id,(T). We also use the relation to qualify \nan equality between type-valued expressions. When we write i b E = M(r)I we mean to assert both i + M(T) \nand E = M(T). 3.3.1 Typing interpretations of semantic combinators The typing interpretation of semantic \ncombinators maps type expressions to conform to the signature of the combinator. The least monadic typing \nthat can be associated with the combinator is chosen. As Unit is a constant of every monadrits least \nmonadic typing is in the identity monad. In the definitions belowr 7 ranges over types and M ranges over \nthe level-indexed monad annotation lists described pre-viously. i + Unit T = Id(T) i + Ext (~1 -+ M(Tz)) \n= M(TI) -+ M(T~) 3.3.2 Monad distribution over products and arrows Monads in a Cartesian category come \nequipped with a distribution combinator that specifies how the monad distributes over products.   3.3.5 \nTyping interpretations of exception i /= DistLR (M(rl) x M (T2)) = A4 u M (r1 x T2) i + Semi-dist (M(1) \nx M (T)) = M Ll M (r) In a Cartesian-closed categoryr it must be speci-fied whether or not a monad is \nstrong-that isr whether the closed representation of functions carries the monad. The computational semantics \nof Mini- ML/Effects requires strong monads. i k A~s (T-,,M(T~)) = hd(n --+ M(n)) The typing interpretation \nof the monadic application combinatorI AppFfollows from its definition: App = Ext ap where ap = ((~1 \n-+ M(Tz)) x TI) ++ M(Tz). The monad annotations of the arguments and the result of an application of \nApp are forced to matchrwhich can entail upward coercion of an argument s monad annotation. Using the \ndefinition aboverwe calculate the typing interpretation of App to be: i k App (M(rl -+ M(n)) x M(TI)) \n- i + Ext ap (Di&#38; (M(q -+ M(T~)) x M(q))) -i k Ext ap (M((T1 -+ M(T2)) x ~1)) = M(Tz) 3.3.3 Typing \ninterpretation of the block lift-ing combinator The Restore combinator coerces a declaration block to \nmeet the semantic constraints of its context. i + Restore M(r) W i + 1 b M(T) 3.3.4 Typing interpretations \nof state access combinators The state access combinators Allocr Derefr Assign encode the non-proper actions \nof the state monad. Their typing interpretations therefore mandate a monad annotation at or above St \nin the monad lattice (Sr in the case of Deref). The typing interpretations are: i b Allot M(T) = St; \nLI M(Ref(T, i)) i b Deref M(Rej(T,j)) = Sr, Ll M(T) (j 5 i) i b Assign (kf(fkf(T,j)), M(T)) (i I 4 = \nSt, u M(1) combinators Like the state access monad annotationsf the typings that involve the exception \nmonad depend upon the lexical scope level of the context of an expression. i i= Throw j = Ex,(Va.cr) \n(i L 4 The typing interpretations of Insert and Handle are i k Insert (j, M(T)) M'(T) = (hf dropE$j) \nu M(T) i /= Handle (P, Q) = foldr(X(m, b).Znsert m 6) P Q where and drop-ex Ex = Id drop-ex Id = Id drop-ex \nExSr = Sr drop-ex Sr = Sr drop-ex ExSt = St drop-es St = St 3.4 Typing rules Typing rules for Mini-ML/Effects \nare derived from the typing interpretation of its semantics. Since typ- ing interpretations are dependent \non the lexical level of an expressionrso also are the typing rules. A typ- ing judgement at level i is \nexpressed as r, i I- e : MJi (T) where r is a typing environment binding free variables to ordinary \ntypesre is an expressionr M is a level-indexed monad annotation expression and T is a type. Since the \nlevel restriction on M can be inferred from the index before the turnstilerwe shall ordinarily omit it. \nThe type of a variable is obtained from the typing environmentf and has its least monadic typing in the \nidentity monad. r, i b X : Id(r) if (Z : T) c r To calculate a least monadic typing of an expres- sionrit \nwill sometimes be necessary to specialize the monadic typing of a subexpressi0nri.e. to coerce the least \nmonadic typing of a subexpression into a monad that is higher in the lattice of effects. The rule of \nspe- cialization for typing interpretations is: r, i k e : M (T) if M 5 M r, i k e : M(T) where C is \nthe reflexive partial order on effect mon-ads. 3.4.1 Abstraction and application When an expression is \nabstracted with respect to a reference or exception-typed variabler the codomain type of the abstraction \nmay depend upon the value of the exception that will be bound when the function is appliedlYi.e.fits \nblock level. For examplerthe monadic typing of the exception abstraction exn n 3 raise n is Exn(n) 3 \nEx(n)(o)f where LY is an unbound type variable and n is an unbound block level variable. The bracketed \nsubscript denotes that the subscript letter is a variable ranging over indicesrnot an in-dex constant. \nThis is an instance of dependent typing that is decidable by static analysis in Mini-ML/Effects. The \nsituation is similar when an expres- sion is abstracted on a Ref-typed variable. r $ [X : T ], i t e \n: M(T) r, i k (funz j e) : Id(? -+ M(T)) r, i t e : hf(T + M(T)) r, i t e : hf(T ) r, i I- ee' : M(T) \nr f3 [n : Exn(6)], i I- e : M(T) r, i t (exn n + e) : Id(Exn(6) + M(T)) r, i t- e : M(Exn(6) + M(T)) \nr, i I- j : Id(Exn(j)) r, i I- e j : M[j/S] u Ex,(T) 3.4.2 Pairs and operator application r, i t el \n: M(Tl) r, i t e2 : hf(T2) r, it (e1,e2) : M(T1 X T2) r. 2 k e : Mlint x int) r, i I- (0~) e : M(int) \nNotice that there is potential information loss in the monadic typing of a pairrsince both component \nex-pressions must be typed with a common manad anno-tation. If r, i I- el : M(TI) and r, i k e2 : M (T~) \nare least monadic typings of el and esrrespectivelyf then r , i k (el, e2) : M U M'(T~ x ~22) is the \nleast monadic typing of the pair. The value projections have least monadic typings f, i I- ~l(er, es) \n: M Ll M'(T~) and r, i t- 7rs(elr es) : M U M'(Tz)rin which the monad annotations may be above the monad \nannotations on the types of the individual component expressions. This is a consequence of the fact that \na product of types is not cartesion in a domain with computational effects. 3.4.3 References and state \naccess expressions r, i t e : M(T) r, i k refe : M u St;(Ref(T, i)) r, i I- e : M(Ref(T,j)) r, i t- !e \n: MU Sr, (T) r, i t e : M(T) r, i t x : M(&#38;j(T, j)) (.i 5 4 r,ikx:=e:MuSt,(l) r, i t S; e : M(T) \n 3.4.4 Exceptions and handlers A raise expression can have any typerinjecting that type into the exception \nmonad at the lexical level specified. The Exn type is a dependent typef indexed by a numeral. Recall \nthat an exception-typed variable is bound to a numeral in the application of a function. Exceptions that \nmay be raised by evaluating a try expression are eliminated from the resultant monad if they are matched \nby a handler clause. The function drop-ex drops the monad in the lattice of monad an-notations on a level-by-level \nbasis. The match judge- ment form (t-match) relates a list of handler expres-sions to the set of exceptions \nhandled and the 1.u.b. of the monadic types of the individual expressions. r, i I- j : Exn(j) (j 5 i \nif j is a literal) l?, i I- raise j : Ex, (T) r, i I- e : Exn(n) where n is a variable r, i t raise e \n: Ex[,](T) r, i t e : M (T) r, i kmatch m : (exs, M(r)) r, i I- try e with m end : (map (cancel exs) \nM ) U M(T) where cancel exs Mi = if i E exs then drop-ez Mi else M, and map applies the function at \neach element of a level-indexed monad annotation. The typing rule for lists of exception matches ac-cumulates \nthe set of exceptions that are matchedras well as typing the substitute expressions. r, i kmatch l?, \ni I- e : M(T) m : (exs, M(T)) r, i l-match j * e I m : (exsu{j}, M(T)) r, i Patch end : (8, Id(r)) Notice \nthat the monadic typing rule for a try expression propagates the information that the branches of the \nwith clause have eliminated the set of in a nested block containing the function s declara- matched exceptionsf \nfrom those that might be raised by the trial expression. This maintains the accuracy of the monadic typing \nof exceptions. Had Mini-ML/Effects used explicitly declared character strings to name exceptionsras does \nSML or CAMLP then to preserve an accurate account of which exceptions might be extant at each lexical \nlevel it would be necessary to represent a finite set of ex-ception names in the annotation for the exception \nmonad. Moreoverr the accurate representation of extant exceptions by static typing is even more problematic \nin SML and CAMLPbecause of the generality of pat- tern matching. A pattern match in these languages may \nkey not only on an exception constructorr but also on the value argument of an exception construc-tor. \nWith value-dependent matchingrthe typing rule for a try expression would need to be weakenedras a local \nstatic analysis cannot determine that a value- dependent match handles all cases in which a program may \nraise an exception with a given exception con-structor. Xavier LeRoy has investigated this problem more \nthoroughly [LeR98].  3.4.5 Declaration blocks Declarations bind identifiers to values. Declaration contexts \nare syntactically designated by let expres-sions. Let-defined variables are monomorphically typed. r, \ni + 1 F e : M(r ) r 83 [z : ~ 1, i + 1 t- e : A4 (T) r, i t let x = e in e : MJ, (7) subject to the constraints: \n1. M1+r E St and 2. marblock 5 i and 3. max-index(r) 5 i  The auxiliary constraints on the typing \nrule restrict the export of references and exceptions. This is the mechanism that enforces the containment \nof effects within scopes in Mini-ML/Effects. Condition 1 prohibits an expression that might raise and \nfail to handle an exception declared in a block nested within the current environment. Condition 2 forbids \na type expression in which there occurs an instance of Ref( T , j) or Exn j with j > i. Such types would \nindicate that a reference or exception value defined in a nested block could be embedded in a valuation \nof the block. Condition 3 forbids an occurrence of an arrow type whose monadic codomain predicts that \nan invocation of a locally-defined function might manifest residual effects of a reference or an exception \nthat was defined tion. max..block Ref (r, i) = max(max-block T, i) 1 max-block (~1 XQ) = max(max-block \n~1, max-block ~2) 1 max-block (rl-+ M(T~)) = max( max-block 71, max-block 722) j max-block Exn(i) = i \n1 max-block _ = 0 max-index Ref (7, i) = max-index T 1 max-index (~1~~22) = max( max-index ~1, max-index \n~22) 1 max-index (rl+ M(Tz)) = max( max-effect M, max-index 72) 1 mar-index -= 0 max-effect MO = 0 1 \nmax-effect Mj., Id,+1 = max-effect M&#38;i 1 max-effect M&#38; h/r, U M,+I = max-effect M.J, M,+l if \nn is a variable 1 max-efect Mj., Mi+l = i+ 1 ifMi+r #Zd 4 Coherence of the type system with the se-mantics \nType systems for programming languages derive their utility from a (weak) coherence between typings and \ncomputations: i.e. computation preserves the typings of well-typed expressions. When computations can \nbe realized by term reductionrthe coherence property is called subject reduction. There is an analogous \ntheo-rem for Mini-ML/Effectsf although it does not have a reduction semantics.. Theorem l-Typing Completeness: \nIf a well-typed termr eP is evaluated by applying a com-posite combinatorr Tr to computations of subterms \nel,..., e,Pthen (a) those subterms are well-typed and (b) the typing interpretation of T calculates \nthe monadic type of e from the types of the sub-terms.  Stated formallyr I- , i t- e : M(r) A C[e] = \nT(E[el], . . . , &#38;[e,]) * Vk E l..ra.jPk, ik. rk, ik I- ek : Mk(~k) A i /= T (M (rl), . . , M (r,)) \n= M(s)  Proof sketch: Proof is by induction on the term structure. The semantics rules (Section 2.2.6) \ndefine a unique computation for each term from the compu- tations of all its subterms. The typing rules \n(Section 3.4) construct type expressions from the types of sub- terms; this argument establishes (a). \nTo confirm type reconstructionr note the corre-spondence between the typing interpretations and the typing \nrules. It is straightforward to check that the typing interpretations give the same result as the typ- \ning rules. Notice that the typing rule for a let expres-sion further restricts the typing interpretation \nof the Restore combinator with auxiliary conditions. The next theorem addresses the soundness of the \nmonadic typing of effects. It augmentsI but does not subsume the soundness theorem [DM82] for the underlying \nHindley-Milner typing left by erasing the monad annotations from the monadic effects typing given here. \nTheorem 2-Soundness of Typing: Suppose an expression e at block level i has type M(r)Twhere for all indices \nj E O..irM, C St. Evaluation of e cannot invoke the wrong continuation. Proof sketch: By induction on \nthe term structure. The syntactic structure of e dictates a unique top-level combinator in its semantic \ninterpretation. No-tice that only four semantic combinators can invoke the exceptional continuation wrongrnamely \nZ hrowr DerejT Aasign and Handle. We analyze each of these cases. The top level combinator is Throw n \nwhenever e = raise n. This combinator invokes wrongiff n > i. But if the argument of raise is a literal \nnumeral and n > ir the term is not well typed because the side condition on the typing interpretation \nThrow fails. Assume the argument of raise is an exception-typed expression. Since there are no operators \nthat convert values of other types into exception valuesr every such value is propagated from a literal \noccur-rence. Thus at every instance of an exception valuer its index agrees with the index in its type. \nAlthough exception values are det,ermined by lit-eral occurrence&#38;a value may be forwarded from a \nhigher to a lower lexical scope in either of two ways: (a) an exception may be raised (and not handled) \nin a let expression or (b) an exception embedded in the body of a function-typed expression that is the \nresult of a let expression may be raised when the function is applied. In each of the casesre fails to \nbe well-typed because of auxiliary conditions 1 and Srrespectivelyr of rule 3.4.5. If the top-level \ncombinator is Handle then e = try e with matches end. Handleapplies the seman- tic meaning of e to a \nnormal expression continuation and to a list of control continuations gotten by apply- ing the meaning \nof matches to a list of control contin-uations defined in the context of the expression. If e raises \nan exceptionrthen its meaning will be Throw ir where i is the index of the exception raised. In this \neaser Throw i is applied to the list of control contin-uations defined by the meaning of matchesrwhich \nis to replace control continuations from the context by new ones derived from the indexed match clauses. \nIf a continuation index that is in scope fails to appear in a match clauserthen a control continuation \nfrom the context of the try.. . with expression remains visible. The default control continuation defined \nwhen a new block is entered is wrongrwhich will be invoked if an exception is unhandled. HoweverrHandle \nrdefined in terms of hert hp-presses the Ex monad annotation only at those in-dices for which the interpretation \nof matches defines a new control continuation. Thus the only try. . . with expressions whose that might \nresult in invoking the wrong continuation are those for which the monad an-notation of the type of e \nhas a component M; 2 Exr but this has been excluded by the hypothesis that MI C Strfor every j E O..i. \nThe top level cominator Deref occurs whenever e =!e . The value of e is a reference which is repre- sented \nby an integer-location pair. The integer com-ponent of the pair is the index of the lexical block of \nthe environment in which the expression e occurs. (Note that the integer index is non-negative. An in-dex \nis calculated only by the Allot combinator and its value is one less than the number of blocks in the \nenvironment in which the reference has its definition. An environment always consists of at least one \nblock.) The wrong continuation would be raised only if the block index of the reference was greater than \nthe in- dex of the current environment blockrindicating that the reference had been forwarded from a \nhigher to a lower lexical scope. This circumstance is prohibited by conditions 2 and 3 of rule 3.4.5. \nAssign occurs as the top level combinator when an expressionIXcontains a statement prefixrei := ez. The \nvalue of ei must be a referencerrepresented as an integer-location pair. The possible values of the integer \nare restricted for exactly the reasons given in the case of Derefrmaking it impossible that Assign can \nraise the wrong continuatio n. 0 5 Polymorphism It is well known that polymorphic typing and cer-tain \nkinds of effects have a problematic interaction. When distinct occurrences of a named entityrsuch as \na mutable variable or an exception constructorrcan bind to independent valuesrpolymorphism allows val-ues \nof different types to be bound to the same namer which can lead to nonsensical programs. The problem \nwas identified by Tofte [Tof87]l who coined the slogan the problem is generalization (of effects types). \nHe proposed a special class of reference typesrwhose gen-eralization would not be defined. This solution \nwas adopted in the original definition of SML [MTHSO]P but has been abandoned in the revised language \ndefi- nition [MTM97]. In its placerSML 97 has adopted a simpler solution which more directly addresses \nTofte s slogan. This solutionrcalled the value restriction has been advocated by Wright [Wri95] and others. \nPolymorphic generalization in SML 97 is re- stricted to expressions that manifest values directlyr requiring \nno computation. Evaluation of such expres- sions (or of their componentsrin the case of composite values) \ncannot invoke effectsrthus type generalization is safe. (Note that for CAMLrthe value restriction must \nbe carefully definedras values of type string can be mutated in CAMLrand values of a CAML record type \nmay contain individually mutable fields.) Monadic typing allows the restriction of polymor- phic to \nbe relaxed slightly. A natural way to restrict polymorphism to effects-free expressions is with a rule \nthat limits type generalization to expressions that can be evaluated in the identity monad. For Mini- \nML/Effectsrsuch a rule is: r, i + 1 k e : Id(#) r $ [Z : Val .cY~.T], i + 1 t- e : M(T) r, i E let 5 \n= e in e : ML, (T) where CYI CY~ are type variables that do not occur free in the type environmentrr. \nThe rule is subject to the same three constraints specified in Section 3.4.5. The usual type specialization \nrule is added to al- low polyvariant instances of a let-bound variable to be type-instantiated independent1y.r \nProposition: Monadic typing is sound under let polymorphism restricted to generalize only types whose \nmonad annotation is Id. Proof: Relies upon two observations. (1) The typing of a reference definition \nattaches a monad annotation that has St as its lower bound. (2) Each typing rule is monotonic with respect \nto the partial ordering of monad annotationsrapplied to the annotation MJ, at lexical level i.. Consequentlyrif \nan expression can be given a type with monad annotation IdI there are no visible effects of its evaluation. \nUnder such a restric- tionrlet polymorphism is equivalent to polymorphic Hindley-Milner typingrwhich \nis sound. 5.1 Semantics of Polymorphic Let The semantics of let, expressions given in Section 2.2.6 does \nnot accommodate a polymorphic typing inter-pretationras a local declaration is replaced by an ap- plication \nof an abstraction to the value of the locally declared expressionrand the typing interpretation of application \nis monomorphic. HoweverI by accepting the typing rule that restricts locally definitions to be free of \nvisible effectsrwe allow a reduction semantics for letrin which copies of the expression body of a local \ndefinition are subst,ituted into the host expres-sion. E[let z = e in en = Restore c[e[e /x]j We shall \nnot attempt to construct an abstract typ-ing interpretation for term substitutionrbut note that the subject \nreduction theorem for a polymorphically typed lambda-calculus asserts that substitution pre-serves typability \nof expressions. 6 Conclusions We have shown that lexical contexts can be used to delimit the scope of \neffects such as exceptions and stat&#38;in an ML-style language where the presence of effects is customarily \ntaken to be implicit. This does not prohibit first-class references or exceptionsr it merely restricts \ntheir scope. Enforcement is pro- vided by an extended type system in which effects monads are inferred \nand made explicit by annotations of the type. Compared with region analysisrin which the scope of mutable \nstate variables is inferred but is not explic- itly declaredrour analysis is simplerrbut it appears to \nrequire that a programmer accepts more responsi-bility for declaration of intent. In practicerhoweverr \nusers of ML Kit with Regions often need to modify their use of state variablesrinformed by region anal-ysisr \nto obtain satisfactory space behavior in their programs. Explicit declaration of the scope of effects \noffers an alternative discipline for controlling a pro- gram s use of space. Of courserregion analysis \nalso finds the scopes of immutable heap storage cells as-sociated with dynamically allocated data structures. \nSuch structures are not present in a language as prim- itive as Mini-ML/Effectsrand we can only speculate \nas to whether programmer-declared regions would be satisfactory as repositories for data structures that \nare dynamically allocated by real programs. The treatment of exceptions in Mini-ML/Effects is simpler \nthan in SML and CAMLrwhere exceptions may carry values and a handler may match on em-bedded values as \nwell as on the exception constructor. That flexibility limits the accuracy with which it can be determined \nthat a handler catches all exceptions tagged with a given constructor. The monadic type inference algorithm \nfor Mini-ML/Effects has been prototyped in CAMLrusing a slightly different data representation for monad \nanno-tations than the one described in this paper. In the implemented prototyperthe identifiers of unhandled \nexceptions that might be raised by evaluating an ex- pression are displayed with the monad annotation \non the expression s type. This useful information adds significantly to the length of type expressions. \nMini-ML/Effects omits another significant feature of ML languages: recursive definitionron which we shall \ncomment. Potential effects are determined by a control-flow analysis which is of polynomial complex-ity \nin the presence of mutually recursive definitions. The analysis requires propagating monad annotations \nto the call sites of functions. Monad analysis with explicit declaration blocks is no more costly than \nis region analysisrfor which amortized algorithm tech-niques have been found to be effective in overcom-ing \nthe asymptotic complexity barrier in many cases [AFL95]. Finallyrwe note that the assurance of effects \ncon-t,ainment provided by monadic typing would allow a natural relaxation of the value restriction for \npoly-morphic let definitions that is imposed in SML. Acknowledgements Conversations with John LaunchburyrAndrew \nTolmach and Pierre Weis shed light on subtle aspects of effects in ML languages and their containment. \nThe author is particularly grateful to Sam Kamin for reading a penultimate draft of this paper and pointing \nout numerous opportunities to improve the exposition. References [AFL951 A. Aikenr M. Fghndrichr and \nR. Levien. Better static memory management: Improv-ing region-based analysis of higher-order lan-guages. \nIn SIGPLAN 95 Conference on Pro-gramming Language Design and Implemen-tationrpages 174-185rJune 1995. \n[BTV96] Lars BirkedalrMads Tofterand Magnus Ve-jlstrup. From region inference to von Neu-mann machines \nvia region representation in-ference. In Conference Record of the Twenty Third Annual ACM Symposium on \nPrinci-ples of Programming Languagesrpages 171- 183. ACM Pressr1996. [DGT96] 0. DanvyrR. Gliickrand \nP. Thiemannred- itors. Partial Evaluation. Dagstuhl Castle, Germany, February 1996rvolume 1110 of Lecture \nNotes in Computer Science. Berlin: Springer-VerlagI l996. [DM82] L. Damas and R. Milner. Principal type \nschemes for functional programs. In Confer-ence Record of the Ninth Annual ACM Sym-posium on Principles \nof Programming Lan-guagesrpages 207-212rJanuary 1982. [JD94] Mark Jones and Luc Duponcheel. Composing \nmonads. Technical Report YALEU/DCS/RR-1004r Yale Universityr December 1994. [LeR98] Xavier LeRoy. Static \ndebugging of uncaught exceptions in ML. Technical reportr IFIP Working Group 2.8 meetingrMarch 1998. \n[LP95] John Launchbury and Simon Peyton Jones. State in Haskell. Lisp and Symbolic Compu-tationr8(4):293-351r1995. \n[MTHSO] Robin Milnerr Mads Tofter and Robert Harper. The Definition of Standard ML. MIT Pressr Cambridger \nMassachusettsr 1990. [MTM97! R. Milnerr M. Toftel? and D. MacQueen. The Definition of Standard ML (Revised). \nMIT PressI 1997. [Ta193] J.-P. Talpin. Theoretical and Practical As-pects of Type and E#ect Inference. \nPhD the-sisruniversity of Paris vIri993. [TJ92] J.-P. Talpin and P. Jouvelot. Polymorphic typesrregion \nand effect inference. Journal of Functional Programmingr2:245-27lrl992. [Tof87] Mads Tofte. Operational \nsemantics and poly- morphic type inference. PhD thesisruniver-sity of Edinburghrl987. [To1981 Andrew \nTolmach. Optimizing ML using a hierarchy of monadic types. In Proceed-ings of Types in Compilation 98 \nWorkshopr March 1998. [TT97] Mads Tofte and Jean-Pierre Talpin. Region based memory management. Information \nand Computationl?l32(2):109-176r1997. [Wad921 Philip Wadler. The essence of functional programming. In \nConference Record of the Nineteenth Annual ACM Symposium on Principles of Programming Languagesr pages \nl-14. ACM PressrJanuary 1992. [ Wad981 Philip Wadler. The marriage of effects and monads. In International \nConference on Functional Programming. ACM Pressr1998. [Wri95] Andrew K. Wright. Simple imperative poly-morphism. \nLisp and Symbolic Computationr 8(4):343-355r1995.   \n\t\t\t", "proc_id": "289423", "abstract": "The familiar Hindley-Milner type system of the ML language family is extended with monad annotations to account for possible side effects of expression evaluation. This also allows effects to be effectively encapsulated by lexical scopes &amp;Gamma; with enforcement provided by type checking. A type-and-effects analysis supports type inference. Type soundness and completeness theorems establish the coherence of monadic type inference with the reference semantics of a small ML-style language.", "authors": [{"name": "Richard B. Kieburtz", "author_profile_id": "81100082874", "affiliation": "Oregon Graduate Institute, Portland, Oregon", "person_id": "P242295", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/289423.289428", "year": "1998", "article_id": "289428", "conference": "ICFP", "title": "Taming effects with monadic typing", "url": "http://dl.acm.org/citation.cfm?id=289428"}