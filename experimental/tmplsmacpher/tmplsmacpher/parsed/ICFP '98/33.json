{"article_publication_date": "09-29-1998", "fulltext": "\n Controlled Temporal Non-Determinism For Reasoning With A Machine Of Finite Speed Robert Ennals rje33Qcam.ac.uk \nCambridge University (Undergraduate) 1 Motivation Reactive models such as that used by Fran [l] allow \none to describe a system that changes with time, by describing the state of an object after an event \nin terms of the situation before the event. This approach has advantages over the ac- tion based approach \ntaken by imperative languages and the monadic approach 121. Notably, the state of any behaviour is defined \nin only one place, and one does not need to worry about when things should be updated. Systems such as \nFran [l] allow one to specify the state that the system should be in at an exact point in absolute time, \nhowever current machines are only capable of process- ing information at a finite speed, and so may be \nunable to set behaviours to the states specified at the times specified. We will usually need to have \na lag between the time at which something is specified to take on a value, and the time at which the \nstate actually changes. What is more, the length of this lag will generally be non-deterministic. This \nlag needs to be dealt with in some way. The con-vention has been for no objects to be allowed to lag \nwith respect to others, causing everything to always lag by the same amount. This greatly restricts what \none can do with the system. One cannot have behaviours that are allowed to update at different rates, \nor that update as quickly as possi- ble. One also cannot have practical distributed systems, as the synchronisation \noverhead would be unworkable. In order to make the reactive approach as expressive as the imperative \napproach, and thus practically applicable to areas beyond those of realtime processing and animations, \nwe need to introduce a degree of temporal non-determinism into our model. 2 Reactive Functions Ideally \nwe would like to introduce this non-determinism in a way that does not interfere with the rest of the \nlanguage, just as monadic IO [Z] does not interfere with the rest of Haskell. One way to do this is to \nintroduce the concept of a Re- active Function as distinct from a normal stateless func-tion. While the \nresult of a normal function is deterministic, referentially transparent, and depends only on its inputs, \nthe result of a reactive function is not. A reactive func-tion can depend on the times at which events \nthat it has been passed have occurred, and thus has internal state. It can also use non-deterministic \nconstructs, and so produce non-deterministic outputs. Normal functions cannot call re-active functions, \nthus the properties of normal functions are preserved, even in the face of non-determinism, 3 Some Reactive \nConstructs <initial value> Q) <event> => <definition> deterministically describes a behaviour that is \ndefined by a definition that may use the keywords prev and after to refer to the state of behaviours \njust before or after the last occurrence of the given event. It is defined by the given initial value \nbefore the first occurrence of the event. This construct is equivalent to those found in most other reactive \nmodels. <initial value> *=> <definition> non-deterministically describes a behaviour that has an ini- \ntial value and then repeatedly redefines itself using the given definition as fast as it can. As soon \nas it has finished gen-erating its state, it will start generating its next state and fire the built \nin now event. Unlike all other constructs, this is not synchronised with the behaviour it is evaluated \nfrom. This construct can be used to implement other non-deterministic constructs, including buffers that \nhold a recent version of another object and allow one to relax synchroni-sation between behaviours. It \ncan also be used for relaxing synchronisation of events across a distributed system. It is possible to \nsimulate Monadic IO [2] using the *=> construct and events. Although one would not generally wish to \ndo IO in this way, it demonstrates that this approach is as expressive as Monadic IO, something that \nwould not be the case without the new *=> construct. References [l] Conal Elliott and Paul Hudak. Functional \nReactive An-imation. ICFP97. [2] Simon Peyton Jones and Phillip Wadler. Imperative Functional Programming. \nPOPL93. 339 \n\t\t\t", "proc_id": "289423", "abstract": "", "authors": [{"name": "Robert Ennals", "author_profile_id": "81540726056", "affiliation": "Cambridge University", "person_id": "PP31075345", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/289423.289467", "year": "1998", "article_id": "289467", "conference": "ICFP", "title": "Controlled temporal non-determinism for reasoning with a machine of finite speed", "url": "http://dl.acm.org/citation.cfm?id=289467"}