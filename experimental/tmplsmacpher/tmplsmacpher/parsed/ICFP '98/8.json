{"article_publication_date": "09-29-1998", "fulltext": "\n Modular Object-Oriented Programming with Units and Mixins Robert Bruce Findler Matthew Flatt Department \nof Computer Science* Rice University Houston, Texas 77005-1892 Abstract Module and class systems have \nevolved to meet the demand for reuseable software components. Considerable effort has been invested in \ndeveloping new module and class systems, and in demonstrating how each promotes code reuse. How-ever, \nrelatively little has been said about the interaction of these constructs, and how using modules and \nclasses together can improve programs. In this paper, we demonstrate the synergy of a particular form \nof modules and classes-called units and mixins, respectively-for solving complex reuse problems in a \nnatural manner. 1 Introduction Module and class systems both promote code reuse. In the- ory, many uses \nof classes can be simulated with modules, and vice versa. Experience shows, however, that program-mers \nneed both constructs because they serve different pur-poses [43]. A module delineates boundaries for \nseparate de-velopment. A class permits fine-grained reuse via selective inheritance and overriding. Since \nmodules and classes aid different patterns of reuse, modern languages provide separate constructs for \neach. Un-fortunately, the reuse allowed by conventional module and class systems is limited. In these \nsystems, modules and classes are hard-wired to a specific context, i.e., to specific modules or to a \nspecific superclass. In previous work, we separately described the novel mod- ule and class systems in \nMzScheme [la]. MzScheme s mod-ules [13], called units, are roughly like Java packages, ex-cept that units \nare linked through an external linking spec-ification, instead of through a fixed internal specification. \nMzScheme s object language [14] provides mixins, which are like Java classes except that a mixin is parameterized \nover its superclass, so it can be applied multiple times to create different derived classes from different \nbase classes. The ad-vantages of unit,s and mixins over conventional module and l This research was partially \nsupported by a Lodleska Stockbridge Vaughan Fellowship, NSF grants CCR-9619756, CDA-9713032, and CCR-9708957, \nand a Texas ATP grant. class languages follow from a single language design prin-ciple: specify connections \nbetween modules or classes sepa-rately from their definitions. The shared principle of separating connections \nfrom def-initions makes units and mixins synergistic. When units and mixins are combined, a programmer \ncan exploit the en-capsulation and linking properties of units to control the application of mixin extensions \n(e.g., to change the class extended by a particular mixin). In Section 5, we motivate in more detail \nthe design be-hind MzScheme s units and mixins, but their synergy is best demonstrated with an example. \nThe bulk of this paper therefore presents an in-depth example, showing how the synergy of units and mixins \nsolves an old extensibility prob-lem [7, 401 in a natural manner. Section 2 describes the extensibility \nproblem, and Section 3 develops a rough solu-tion the problem using conventional classes. Section 4 intro- \nduces units and mixins to refine and complete the solution. Sections 5 and 6 extract lessons from the \nexample for the design of modular object-oriented programming languages. Finally, Section 7 relates our \nwork to other research. 2 The Extensibility Problem The following table summarizes the extensibility \nproblem: original variants extension r . 0 0 cr) original draw r &#38;au(i)-draw(Op draw(G) operations \n\\ shrink\\~shrink(D) shrink(o); shrink(u) -, ~ I extension rotate Yf,tate(O, ToiaL(o) rotate(u) { 1 The \nportion of the table contained in the dotted box repre-sents a program component that provides several \noperations, draw and shrink, on a collection of data, geometric shapes like squares and circles. A programmer \nmay wish to use such a component in three different contexts: 1. The programmer may wish to include the \ncomponent 0s is. 2. The programmer may wish to extend the datatype with a variant, repositioned shapes, \nand adapt the col- lection of operations accordingly. 3. The programmer may wish to add a new operation, \nrotate.  ,---------------------------~ ~ ;  ,---------------, ,______ I I : I : : ! : I I ! ! I I \n: : f-d 0 I I_--~- lii5l-b -___ i I__----: --v--. Client t3 (a) Original Datatype (b) New Variant \n(c) New Operation Figure 1: Extensible To avoid duplicate maintenance, or because the component is acquired \nin object form, the component must be organized so that programmers can add both new forms of data and \nnew operations without modifying of recompiling the original program component, or 0 its existing clients. \n Such a program organization dramatically increases the po- tential for software reuse and enables the \nsmooth integration of proprietary modules. Neither standard functional nor object-oriented strate-gies \noffer a satisfactory way to implement the component and its clients. In a functional language, the variants \ncan be implemented as a type, with the operations as functions on the type. Using this approach, the \nset of operations is easily extended, but adding a new variant requires modifying the functions. In an \nobject-oriented language, the variants can be implemented as a collection of classes, with the opera-tions \nas methods common to all of the classes. Using this approach, the datatype is easily extended with a \nnew vari-ant, but adding a new operation is typically implemented by modifying the classes. The existing \nliterature provides three solutions to the problem. Kiihne s [24] solution, which relies on generic pro-cedures \nwith double-dispatching, can interfere with the hi-erarchical structure of the program. Palsberg and \nJay s [32] solution is based on reflection operators and incurs a sub- stantial run-time penalty. Krishnamurthi, \nFelleisen, and Friedman 111, 231 propose an efficient solution that works with standard class mechanisms, \nbut it requires the imple- mentation (and maintenance) of a complex programming protocol. All of these \nsolutions are partial because they do not address the reuse of clients. In contrast, the combination \nof units and mixins solves the problem simply and elegantly, and it addresses the reuse of both the original \ncomponent and its clients. programming on datatypes 3 Extensible Programming with Classes Figure 1 outlines \nour solution to the extensibility problem: l Diagram (a) represents the original component. The rhombus \nstands for the datatype, and the rectangles denote the datatype s variants. The oval is a client of the \ndatatype component. l Diagram (b) shows the datatype extended with a new variant. The extension is contained \nin the right inner dashed box. The solid box on the left represents the unmodified datatype code from \n(a). The original client is also preserved, and a new client of the datatype exploits the variant extension. \nl Diagram (c) shows extension in the other direction: adding a new operation to the datatype. As before, \nthe extension is implemented by the inner dashed box while the solid box represents the unmodified existing \nimplementation from (b). The new squares in the ex-tension represent the implementation of the operation \nfor each variant. The existing clients have not been modified, although they now refer to the extended \nvari-ants. The remainder of this section develops a concrete example, an evolving shape program [ll, \n231. Since Figure 1 can be approximated using conventional classes, we first use only language features \navailable in a typical object-oriented lan-guage. But, classes are not enough; Section 4 introduces units \nand mixins to complete the solution. 3.1 Shape Datatype Initially, our shape datatype consists of three \nvariants and one operation: rectangles, circles, and translated shapes for drawing. The rectangle and \ncircle variants contain numbers that describe the dimensions of the shape. The translated variant consists \nof two numbers, A, and Av, and another (define Shape (interface () draw)) (define BB-Shape (interface \n(Shape) bounding-box)) (define Rectangle (class* null (Shape) (w&#38;h height) (public [draw (lambda \n(window z y) . . .)I))) (define Circle (class* null (Shape) (radius) (public [draw (lambda (zuindow z \ny) . . .))I)) (define Translated (class* null (Shape) (shape A, A,) (public [draw (lambda (windour E \ny) (send shape draw  window (+ z Arc) (+ Y 4,)))l))) Figure 2: Shape classes (define display-shape (lambda \n(shape) (if (not (is-a? shape Shape)) (error expected a Shape )) (let ([window . .I) (send shape draw \nwindow 0 0)))) (display-shape (make-object Translated (make-object Rectangle 50 100) 30 30)) Figure 3: \nTwo shape clients shape. For all variants, the drawing operation takes a des- tination window and two \nnumbers describing a position to draw the shape. The shape datatype is defined by the Shape interface \nand implemented by three classes: Rectangle, Circle and Trans-lated. Each subclass declares a dravr method, \nwhich is re- quired to implement the Shape interface. Figure 2 shows the interface and class definitions \nusing MzScheme s class system. (MzScheme s class system is similar to Java s; for details, see the Appendix.) \nFigure 3 contains clients for the shape datatype. The function display-shape consumes a shape and draws \nit in a new window. The final expression creates a shape and displays it. As the shape datatype is extended, \nwe consider how these clients are affected. (define Union (class* null (Shape) (left right) (public [draw \n(lambda (window I y) (send left draw window z y) (send right draw window I y))]))) (display-shape (make-object \nUnion (make-object Rectangle 10 30) (make-object Translated (make-object Circle 20) 30 30))) Figure 4: \nVariant extension and a new client (define BB-Rectangle (class* Rectangle (BB-Shape) (width height) (public \n[bounding-box (lambda () (make-object BB 0 0 width height))]) (sequence (super-init width height)))) \n(define BB-Circle (class* Circle (BB-Shape) (radius) (public [bounding-box (lambda () (make-object BB \n(-radius) (-radius) radius radius))]) (sequence (super-init r)))) (define BB-Translated (class* Translated \n(BB-Shape) (shape A, A,) (public [bounding-boz (lambda () . . .)]) (sequence (super-init shape A, A,)))) \n(define BB-Union (class* Union (BB-Shape) (left right) (public [bounding-boz (lambda () .)]) (sequence \n(super-init left right)))) (define BB (class* null () (lejt top right bottom) . ..)I (define display-shape \n(lambda (shape) (if (not (is-a? shape BB-Shape)) (error expected a BB-Shape )) (let* ([bb (send shape \nbounding-boz)] [window . . .] [z . . .] [y . . .]) (send shape draw window z y)))) Figure 5: Operation \nextension 3.2 Variant Extension To create more interesting configurations of shapes, we ex- tend the \nshape datatype with a new variant representing the union of two shapes. Following the strategy suggested \nin Figure 1 (b), we define a new Union class derived from Shape. Figure 4 defines the Union class, and \nshows an ex-pression that uses the new class. The simplicity of the variant extension reflects the nat-ural \nexpressiveness of object-oriented programming. The object-oriented approach also lets us add this variant \nwith-out modifying the original code or the existing clients in Figure 3.  3.3 Operation Extension Shapes \nlook better when they are drawn centered in their windows. We can support centered shapes by adding the \noperation bounding-box, which computes the smallest rect-angle enclosing a shape. We add an operation \nto our shape datatype by defining four new classes, each derived from the variants of Shape in Section \n3.2. Figure 5 defines the extended classes BB-Circle, BB-Rectangle, BB-Translated, and BB-Union, each \nprovid-ing the bounding-box method. It also defines the BB-Shape (set! jactory . .) (display-shape (send \nfactory make-union (send factory make-rectangle 10 30) (send factory make-translated (send factory make-circle \n20) 30 30))) Figure 6: Revised clients using Abstract Factory interface, which describes the extended \nshape type for the bounding box classes just as Shape describes the type for the original shape classes. \nThe new display-shape client in Figure 5 uses bounding box information to center its shape in a window. \nUnfortu-nately, we must also modify the clients so they create in-stances of the new bounding box classes \ninstead of the origi- nal shape classes, including clients that do not use bounding box information. \nThus, the standard object-oriented archi-tecture does not satisfy our original goal; it does not support \noperation ext,ensions to the shape datatype without modi-fying existing clients. Since object-oriented \nprogramming constructs do not ad- dress this problem directly, we must resort to a programming protocol \nor pattern. In this case, the Abstract Factory pat-tern [15] and a mutable reference solves the problem. \nThe Abstract Factory pattern relies on one object, called the fat- tory, to create instances of the shape \nclasses. The factory supplies one creation method for each variant of the shape, and clients create shapes \nby calling these methods instead of using make-object directly. To change the classes that are instantiated \nby clients, it is only necessary to change the factory, which is stored in the mutable reference. A revised \nclient, using the Abstract Factory, is shown in Figure 6. The Abstract Factory pattern implements a simple \ndy-namic linker, where set! installs the link. It separates the definition of shapes and clients so that \na specific shape im-plementation can be selected at a later time, rather than hard-wiring a reference \nto a particular implementation into the client. However, using a construct like set! for linking obscures \nthis intent both to other programmers and to the compiler. A more robust solution is to improve the module \nlanguage. 4 Better Reuse through Units and Mixins In the previous section, we developed the Shape datatype \nand its collection of operations, and we showed how object- oriented programming supports new variants \nand operations in separately developed extensions. In this section, we make the separate development \nexplicit using MzScheme s mod-ule system; the basic definitions, the extensions, and the clients are \nall defined in separate modules. MzScheme sup-ports separate compilation for these modules, and provides \na flexible language for linking them. Indeed, the linking im-plemented with an Abstract Factory in the \nprevious section can be more naturally defined through module linking. Fi-nally, we show how MzScheme \ns class-module combination provides new opportunities for reuse that are not available in conventional \nobject-oriented languages. Factory Method is a related pattern where an extra operation in the datatype \nis used to create instances instead of a separate factory object. Factory Method applies to an interesting \nspecial case the datatype client and the datatype implementation are the same, thus making the datatype \nimplementation extensible. (define BASIC-SHAPES (unit (import) (export Shape Rectangle Circle Translated) \n(define Shape (interface . . .)) ; see Figure 2 (define Rectangle (class* null (Shape) . .)) (define \nCircle (class* null (Shape) . . .)) (define Translated (class* null (Shape) .)))) Figure 7: Creating \nUnits (define GUI (unit (import Shape) (export display-shape) (define display-shape . .))) ; see Figure \n3 (define PICTURE (unit. (import Rectangle Circle Translated display-shape) (export,) (display-shape \n(make-object .)))) ; see Figure 3 Figure 8: Unitized shape clients 4.1 Unitizing the Basic Shapes A \nmodule in MzScheme is called a unit. Figure 7 shows the basic shape classes encapsulated in a BASIC-SHAPES \nunit. This unit imports nothing and exports all of the basic shape classes. The body of the unit contains \nthe class definitions exactly as they appear in Figure 2. In general, the shape of a unit expression \nis (unit (import variable .) (export variable . . .) unit-body-expr . .) (centered ellipses indicate \nrepeated syntactic patterns). The unit-body-expm have the same form as top-level Scheme ex-pressions, \nallowing a mixture of expressions and definitions, but define within a unit expression creates a unit-local \nvari-able instead of a top-level variable. The unit s imported var-ables are bound within the unit-body-exprs. \nEach exported variable must be defined by some unit-body-expcpr. Unex-ported variables that are defined \nin the unit-body-expprs are private t,o the unit. Figure 8 defines two client units of BASIC-SHAPES: \nGUI and PICTURE. The GUI unit provides the function display-shape (the same as in Figure 3). Since it \nonly depends on the functionality in the Shape type, not the specific variants, it only imports Shape. \nThe PICTURE unit imports all of the shape variants-so it can construct instances-as well as the display-shape \nfunction, and it exports nothing. When PICTURE is invoked as part of a program, it constructs a shape \nand displays it. A unit is an unevaluated bundle of code, much like a .o object file created by compiling \na traditional language. At the point where BASIC-SHAPES, GUI, and PICTURE are defined as units, no shape \nclasses have been defined, no in- stances have been created, and no drawing window has been opened. Each \nunit encapsulates its definitions and expres-sions without evaluating them until the unit is invoked, \njust like a procedure encapsulates expressions until it is applied. However, none of the units in Figures \n7 and 8 can be invoked directly because each unit requires imports. The units must first be linked together \nto form a program. (define BASK-PROGRAM (compound-unit (import) (link [S (BASIC-SHAPES)] [G (GUI (S \nShape))] [P (PICTURE (S Rectangle) (S Circle) (S Translated) (G display-shape))]) (-wrt))) (invoke-unit \nBASIC-PROGRAM) Figure 9: Linking basic shape program  4.2 Linking the Shape and Client Units Units are \nlinked together with the compound-unit form. Figure 9 shows how to link the units of the previous sub-section \ninto a complete program: BASIC-PROGRAM. The PICTURE unit s imports are not a priori associated with the \nclasses in BASIC-SHAPES. This association is estab-lished only by the compound-unit expression, and it \nis established only in the context of BASIC-PROGRAM. The PICTURE unit can be reused with different Shape \nclasses in other compound units. The compound-unit form links several units, called constituent units, \ninto one new compound unit. The link ing process matches imported variables in each constituent unit \nwith either variables exported by other constituents, or variables imported into the compound unit. The \ncompound unit can then re-export some of the variables exported by the constituents. Thus, BASIC-PROGRAM \nis a unit with im-ports and exports, just like BASIC-SHAPES or GUI, and no evaluation of the unit bodies \nhas occurred. But, unlike the BASIC-SHAPES and GUI units, BASIC-PROGRAM is a com-plete program because \nit has no imports. Each compound-unit expression (compound-unit (import variable . . .) (link [tag* (eqrl \nlinkspecl . ..)I [tag, (expr, linkspec, . .)I) (export (tug variable) . . .)) has three parts: l The \nimport clause lists variables that are imported into the compound unit. These imported variables can \nbe linked to the constituent unit s imports. l The link clause specifies how the compound unit is cre- \nated from the constituent units. Each constituent unit is specified via an expr and identified with a \nunique tag. Following the expr, a link specification linkspec is provided for each of the constituent \ns imports. Link specifications have two forms: - A linkspec of the form variable links the con-stituent \ns import to the corresponding import of the compound unit. - A linkspec of the form (tag oaraable) links \nthe con-stituent s import to variable as exported by the tag constituent.  l The export clause re-exports \nvariables from the com-pound unit that are exported from the constituents. The tag indicates the constituent \nand variable is the variable exported by that constituent. (define UNION-SHAPE (unit (import Shape) \n(export Union) (define Union (class* null (Shape) . . .)))) ; see Figure 4 (define BASICSUNION-SHAPES \n(compound-unit (import) (link [S (BASIC-SHAPES)] [US (UNION-SHAPE (S Shape))]) (export (S Shape) (S Rectangle) \n(S Circle) (S Translated) (US Union)))) Figure 10: Variant extension in a unit To evaluate a compound-unit \nexpression, the exprs in the link clause are evaluated to determine the compound unit s constituents. \nFor each constituent, the number of variables it imports must match the number of linkspecs provided; \notherwise, an exception is raised. Each linkspec is matched to an imported variable by position.2 Each \ncon-stituent must also export the variables that are referenced by link and export clauses using the \nconstituent s tag. Once a compound unit s constituents are linked, the com- pound unit is indistinguishable \nfrom an atomic unit. Con-ceptually, linking creates a new unit by merging the inter-nal expressions and \ndefinitions from all the constituent units. During this merge, variables are renamed as necessary to \nim- plement linking between constituents and to avoid name col-lisions between unrelated variables. The \nmerged unit-body-exprs are ordered to match the order of the constituents in the compound-unit s link \nclause.3 4.3 Invoking Unit Programs The BASIC-PROGRAM unit from Figure 9 is a complete pro-gram, analogous \nto a conventional application, but the pro- gram still has not been executed. In most languages with \nmodule systems, a complete program is executed through commands outside the language. In MzScheme, a \nprogram unit is executed directly with the invoke-unit form: (invoke-unit expr) The value of erpr must \nbe a unit. Invocation evaluates the unit s definitions and expressions, and the result of the last expression \nin the unit is the result of the invoke-unit expression. Hence, to run BASIC-PROGRAM, evaluate (invoke-unit \nBASIC-PROGRAM)  4.4 New Units for a New Variant To extend Shape with a Union variant, we define the \nexten-sion in its own unit, UNION-SHAPE, as shown in Figure 10. *In MzScheme s extended unit language \nwith signatures, linking matches variables by name rather than by position. When the number of imports \nis small, linking by position is simpler because it avoids complex machinery for renaming variables. \n3The implementation of linking is equivalent to this reduction, but far more efficient. In particular, \nit is not necessary to extract expressions from the constituent units, which would break separate compilation. \n(define UNION-PICRJRE (unit (import Rectangle Circle Translated Union display-shape) (export) (display-shape \n(make-object .)))) ; see Figure 4 (define UNION-PROGR.AM (compound-unit (import) (link [S (BASIC+UNION-SHAPES)] \n[G (GUI (S Shape))] [P (PICTURE (S Rectangle) (S Circle) (S Translated) (G display-shape))] [UP (UNION-PICTURE \n(S Rectangle) (S Circle) (S Translated) (S Union) (G display-shape))]) (export))) (invoke-unit ~JNION-PROGRAM) \nFigure 11: New client and the extended program The Shape class is imported into UNION-SHAPE, and the \nnew Union class is exported. In terms of Figure 1 (b), UNION-SHAPE corresponds to the smaller dashed \nbox, drawn around the new variant class. The solid box is the original unmod-ified BASIC-SHAPES unit, \nand the outer dashed box in (b) is IJASIC+UNION-SHAPES, a compound unit linking UNION-SHAPE together \nwith BASIC-SHAPES. Since the BASIC+~NION-SHAPES unit exports the vari-ants defined by both BASIC-SHAPES \nand UNION-SHAPE, it can serve as a replacement for the original BASIC-SHAPES unit, yet it can also provide \nmore functionality for new clients. The UNION-PROGRAM unit in Figure 11 demon- strates both of these \nuses. In this new program, the GUI and PICTURE clients are reused intact from the original pro-gram, \nbut they are now linked to BASIC+~NION-SHAPES instead of BASIC-SHAPES. An additional client unit, UNION-PICTURE, \ntakes advantage of the shape extension to draw a superimposed rectangle and circle picture. 4.5 New \nUnits and Mixins for a New Operation To extend Shape with a bounding-boa operation, we define the BB-SHAPES \nunit in Figure 12. This unit corresponds to the smaller dashed box in Figure 1 (c). The BB-SHAPES unit \nis the first example to rely on mix- ins. The BB-Rectangle class is derived from an imported Rectangle \nclass, which is not determined until the unit is linkc!d-long after the unit is compiled. Thus, BB-Rectangle \ndefines a mixin, a class extension that is parameterized over its superclass. The compound unit BASIC+UNION+BB-SHAPES \nlinks the BASIC+UNION-SHAPES unit from the previous section with the new bounding-box unit, then exports \nthe bounding- box classes. As the bounding-box classes are exported, they are renamed to match the original \nclass names,4 i.e., BB-Rectangle is renamed to Rectangle, and so on. This renam-ing does not affect the \nlinking within BASIC+UNION+BB-SHAPES; it, only affects the way that BASIC+UNION+BB-SHAPES is linked with \not,her units. 4The simplified description of compound-unit in Section 4.2 did not ccwer the syntax for \nrenaming exports. For a complete description of compound-unit, see the MzScheme manual [12] (define BB-SHAPES \n(unit (import Shape Rectangle Circle Translated Union) (export BB-Shape BB-Rectangle BB-Circle BB-Translated \nBB-Union BB) (define BB-Shape (interface (Shape) .)) ; see Figure 5 (define BB-Rectangle (class* Rectangle \n. .)) (define BB-Circle (class* Circle . . .)) (define BB-Translated (class* Translated .)) (define BB-Union \n(class* Union . . .)) (define BB .))) (define BAsIC+UNIoN+BB-SHAPES (compound-unit (import) (link [S \n(BASIC+UNION-SHAPES)] [BS (BB-SHAPES (S Shape) (S Rectangle) (S Circle) (S Translated) (S Union))]) (export \n(S Shape) (BS BB-Shape) (BS BB) ; rename BS s BB-Rectangle to Rectangle, etc.: (BS (BB-Rectangle Rectangle)) \n(BS (BB-Circle Circle)) (BS (BB-Translated Translated)) (BS (BB-Union Union))))) Figure 12: Operation \nextension in a unit (define BB-GUI (unit (import BB-Shape BB) (export display-shape) (define display-shape \n(lambda (shape) (if (not (is-a? shape BB-Shape)) ; see Figure 5 . ..)I)) (define BB-PROGRAM (compound-unit \n(import) (link [S (BASIC+UNION+BB-SHAPES)] [BG (BB-GUI (S BB-Shape) (S BB))] [P (PICTURE (S Rectangle) \n(S Circle) (S Translated) (BG display-shape))] [UP (UNION-PICTURE (S Rectangle) (S Circle) (S Translated) \n(S Union) (BG display-shape))]) (export))) (invoke-unit BB-PROGRAM) Figure 13: Program with the operation \nextension As before, the BASIC+UNION+BB-SHAPES unit serves as a replacement for either BASIC-SHAPES \nor BASIC+UNION- SHAI ES, and also provides new functionality for new clients. One new client is BB-GUI \n(see Figure 13), which provides a display-shape that exploits bounding box information to center a shape \nin a window. The BB-GUI unit replaces GUI, but we reuse PICTURE and UNION-PICTURE without modify-ing \nthem. An Abstract Factory is unnecessary because units already permit us to vary the connection between \nthe shape- creating clients and the instantiated classes. Putting every-thing together produces the new \nprogram BB-PROGRAM at the bot,tom of Figure 13. (define COLOR-SHAPE (unit (import Shape) (export C-Shape) \n(define C-Shape (class* Shape () args (rename [super-draw draw]) (public [color black ] [change-color \n(lambda (c) (set! color c))] [draw (lambda (zuindou, I y) (send window set-color color) (super-draw \nwindow z y))]) (sequence (apply super-init args))))))  (define BASIC+UNION+BB+COLOR-SHAPES (compound-unit \n(import) (link [S (BASIC+UNION+BB-SHAPES)] [CR (COLOR-SHAPE (S Rectangle))] [CC (COLOR-SHAPE (S Circle))] \n[CT (COLOR-SHAPE (S Translated))] [CU (COLOR-SHAPE (S Union))]) (export (S Shape) 1; &#38;Shape) (CR \n(C-Shape Rectangle)) (CC (C-Shape Circle)) (CT (C-Shape Translated)) (CU (C-Shape Union))))) Figure \n14: Reusing a class extension  4.6 Synergy at Work The shape example demonstrates the synergy of units \nand mixins. Units, by separating the definition and linking of modules, support the reuse of PICTURE \nand UNION-PICTURE as the shape representation evolves. Mixins, by abstracting a class expression over \nan imported class, enable the encap- sulation of each extension in its own unit. The combination of units \nand mixins thus enables a direct translation of the ideal program structure from Figure 1 into a working \npro-gram. We have achieved the complete reuse of existing code at every stage in the extension of Shape, \nbut even more reuse is possible. The code in Figure 14 illustrates how units and mixins combine to allow \nthe use of one extension multiple times. The COLOR-SHAPE unit imports a Shape class and extends it to \nhandle colors. With this single unit containing a single mixin, we can extend all four of the shape variants: \nRectangle, Circle, Translated, and Union. The compound unit BASIC+UNION+BB+COLOR-SHAPES in Figure 14 \nuses the COLOR-SHAPE unit four times to obtain the set of color shape classes. The code in Figure 14 \nuses a few features that are not described in this paper (the rename clause in a class* ex-pression, \nand the use of args to stand for multiple argu-ments, passed on to super-init with apply). These details \nare covered in the MzScheme reference manual [la]. The point here is that units and mixins open new avenues \nfor reuse on a large scale. 5 The Moral of the Story We have demonstrated how units and mixins apply \nto a specific example, but a general principle is at work: specify-ing connections between modules or \nclasses separately from their definitions. This principle is the key to making units and mixins succeed \ntogether without conflating the distinct purposes of module and class systems. A module system serves \ntwo key purposes: Separate Development: A module encapsulates a set of definitions, clearly delineating \nthe interface be-tween the module and the rest of the program. Each module can be developed in isolation \nand distributed to clients in a compiled form. Linking: Modules are linked together to form a pro- gram. \nLinking connects the definitions in one module with those in another, but a module cannot interfere with \nthe internal structure of any other module. In contrast, a class system supports three different key \nser-vices: l Extensible Types: An interface defines an extensible type, and a class implements such a \ntype. l Selective Reuse: A class can selectively refine the implementation of its superclass, preserving \nsome in-herited definitions and overriding others with its own definitions. l Instantiation: A class \nis instantiated to create an ob- ject, a first-class value that encapsulates the methods and instance \nvariables of the class. To serve their distinct purposes, modules and classes re- quire distinct constructs \nin a programming language, but these constructs interact. In our example program, the col-lection of \ngeometric shapes is naturally implemented as a set of Shape classes. The implementation of the shape \nclasses and the client code that uses them are defined in separate modules. Using classes to represent \nshapes makes it easy to extend the shape classes without modifying the basic defi-nition of a shape. \nSeparating the definition of shapes from their use in different modules makes it easy to replace the \noriginal shape classes with new classes without modifying the client. This is precisely how modular object-oriented \ncode is supposed to work. Unfortunately, the existing module-class combinations do not support this sort \nof modular object-oriented pro-gramming. In Java, for example, if the Rectangle class is ex- tended, \nthen a client module that creates Rectangle instances must be modified to refer to the new, extended \nclass. The root of this problem, both in Java and many other object-oriented languages, is that the connections \nbetween mod-ules are hard-wired within the modules. For example, client modules declare that they import \nthe shape module instead of importing a shape module. The design of module and class constructs must \nencour-age the interaction of the constructs. The Shape example suggests a lesson for the design of modules: \nSeparate a module s linking specif?cation from its encapsulated definitions. In other words, a module \nshould describe its imports with enough detail to support separate compilation, but the mod- ule should \nnot specify the source of its imports. Instead, the imports should be supplied externally by a linking \nexpres- sion. A module system with external linking in turn constrains the design of the class system. \nA module may encapsulate a class definition with an imported superclass (e.g., BB- Rectangle in Figure \n12). Since module linking is specified outside the module, the superclass is not determined until the \nmodule is linked, so t,he class expression is de facto pa- rameterized over its superclass. Such a parameterized \nclass is a mixin. Mixins tend to be computationally more expen- sive than classes, but the cost is small \n[14]. In parallel to the lesson for modules, the requirement to support mixins can be stated as follows: \nSeparate 0 cl0ss s superclass specificationfrom its extending definitions. Mixins are valuable in their \nown right. While classes enable reuse because each class can be extended and refined by defining new \nsubclasses, the reuse is one-sided: each class can be extended in many different ways, but each extension \napplies only to its superclass. A mixin is parameterized with respect to its superclass, so it can add \nfunctionality to many different classes. Thus, the reuse potential of a mixin is greater than that of \na class. 6 A Type Challenge We have explored typed models of mixins [14] and units [13] separately in \nprevious work. In addition, we have antici- pated an extension of the present work with types by in- \ncluding is-a? safety tests in our examples, and by showing how the Shape and BB-Shape interfaces are \nlinked to clients to enable those tests. Still, certain challenges remain for bringing mixins and units \ntogether in a single typed model. For mixins, the previously published type rules assume a complete program \nand a single namespace for mixin names. For units, the previously published language does not ex- press \nthe kind of type relationships necessary for importing and exportming interface types (e.g., importing \ntypes A and B where A must be a subtype of B). Others have explored a similar combination of classes \nand modules in a typed setting. The module systems in Objec- tive Cam1 [28, 381 and OML [39] support \nexternally specified connections, and since a class can be defined within a mod- ule, these languages \nalso provide a form of mixins. However, the modules and mixins in these languages fail to support the \nsynergy we have demonstrated for units and mixins. In particular, they do not allow the operation extension \ndemon-strated in Section 4 because an imported class must match the expected type exactly-no extra methods \nare allowed. In our example, PICTURE is initially linked to the Rectangle class and later linked to BB-Rectangle; \nsince the latter has more methods, neither Objective Cam1 nor OML would al-low PICTURE to be reused in \nthis way. Our example thus suggests a third lesson for the design of module and class type systems: Allow \nsubsumption for connections, including both module linking and class extension. 7 Related Work Much \nof the previous research on modules and classes fo- cused on unifying the constructs. Lee and Friedman \n[26, 271 investigat,ed languages that work directly on variables and bindings, which provides a theoretical \nfoundation for im-plementing bot.h modules and classes. Similarly, Jagan-nathan [%I] and Miller and Rozas \n[29] proposed first-class environment,s as a common mechanism. Bracha [3] has ex-plored mixins for both \nmodular and object-oriented pro-gramming; Ancona and Zucca [l] provide a categorical treat-ment of this \nview. Our work is complementary to all of the above work, because we focus on designing the constructs \nto be used by a programmer, rather than the method used to implement those constructs. Languages that \nhave promoted modularization, includ-ing Mesa [31], Modula-2 [45], and SML [30], provide no di-rect support \nfor object-oriented programming. Similarly, early object-oriented languages, such as Simula 67 [9] and \nSmalltalk [16], provide no module system. In contrast, lan-guages such as Ada 95 [20], Common Lisp [42], \nDylan [41], Haskell [19], Java [17], and Modula-3 [18] provide both mod-ules and classes. For Cecil 141, \nChambers and Leavens [5] de- signed a module system specifically to complement a class system with multi-methods. \nUnfortunately, these module and class systems do not support external connections-a central principle \nof our design t,hat is crucial to software engineering (see Section 5). Scheme [6] provides no specific \nmechanisms for modular or object,-oriented programming. Instead, Scheme supports modular programming \nthrough lexical scope, and many im-plementations provide separate compilation for top-level ex-pressions. \nProgrammers can regard top-level expressions as modules that, hide private definitions by using let or \nle-tree. A number of Scheme systems have been developed that codify t,he module-via-top-level idea [8, \n10, 36, 35, 441, but none of these satisfies the criteria in Section 5. In con-trast, Kelsey s proposed \nmodule system [22] captures many of the same ideas as units. Scheme can also support object-orient,ed \nprogramming by simulating objects with proce-dures and classes with higher-order procedures [37]. Sev-eral \nobject-oriented extensions for Scheme have been devel- oped [2, 341, including some that support mixins \n[25, 33].5 However, none of these systems provide complete languages for both modular and object-oriented \nprogramming. 8 Conclusion Units and mixins promote a synergistic integration of modu- lar and object-orient,ed \nprogramming techniques. The com-bination succeeds due to a consistent separation of defini- tions (encapsulated \nin modules or classes) from connections (between modules or classes) in both units and mixins. The bulk \nof the paper explores the extensibility problem because it highlights many of the advantages of units \nand mixins. %rictly speaking, the problem can be solved using conventional module and class systems and \nthe Abstract Factory pattern. Nevertheless, a straightforward datatype impleme;&#38;at,io,l using units \nand mixins is more immediately extensible. This natural bias towards reuse and extension is the essential \nbenefit of units and mixins. For a complete version of the code presented here, see www.cs.rice.edu/CS/PLT/Publications/#ifcp98-ff \n SQueinnec s [33] system actually provides generic function exten-sions lhat are parameteriaed over a \ngeneric function, rather than parameterned ck~s extensions. While the system does not provide mixins \nper se, It iollows the principle of separating connections from definitions Acknowledgements The authors \nwould like to thank Matthias Felleisen, Corky Cartwright, John Clements, Dan Friedman, Shriram Krish- \nnamurthi, Paul Sterkler, and the anonymous reviewers. References [II Ancona, D. and E. Zucca. An algebraic \napproach to mixins and modularity. In Hanus, M. and M. Rodriguez-Artalejo, editors, Proc. Conference \non Algebraic and Logic Programming, Lecture Notes in Computer Science 1139, pages 179-193, Berlin, 1996. \nSpringer Verlag. Bartley, D. H. and J. C. Jensen. The implementation PI of PC Scheme. In Proc. ACM Conference \non Lisp and Functional Programming, pages 86-93, 1986. Bracha, G. The Programming Language Jigsaw: Mix- \n[31 ins, Modularity and Multiple Inheritance. Ph.D. thesis, Dept. of Computer Science, University of \nUtah, March 1992. Chambers, C. The Cecil Language Specification and [41 Rationale: Version 2.0, 1995. \n Chambers, C. and G. T. Leavens. Typechecking and modules for multi-methods. ACM Transactions on Programming \nLanguages and Systems, 17(6):805-843, November 1995. 151 [61 Clinger, W. and Rees, J. (Eds.). The revised4 \nreport on the algorithmic language Scheme. ACM Lisp Pointers, 4(3), July 1991. Cook, W. R. Object-oriented \nprogramming versus ab- PI stract data types. In Foundations of Object-Oriented Languages, pages 151-178, \nJune 1990. Curtis, P. and J. Rauen. A module system for Scheme. In Proc. ACM Conference on Lisp and Functional \nPro-gramming, pages 13-28, 1990. PI Dahl, O.-J., B. Myrhaug and K. Nygaard. SIMULA 67. common base language. \nTechnical Report Publ. No. S- 2, Norwegian Computing Center, Oslo, Norway, May 1968. PI PO1 Feeley, M. \nGambit-C, a portable Scheme implementa-tion, 1996. [Ill Felleisen, M. and D. P. Friedman. A Little Java, \nA Few Patterns. The MIT Press, 1998. PI Flatt, M. PLT MzScheme: Language manual. Technical Report TR97-280, \nRice University, 1997. Flatt, M. and M. Felleisen. Units: Cool modules for HOT languages. In Proc. ACM \nConference on Pro-gramming Language Design and Implementation, pages 236-248, 1998. [131 Flatt, M., S. \nKrishnamurthi and M. Felleisen. Classes and mixins. In Proc. ACM Symposium on Principles of Programming \nLanguages, pages 171-183, 1998. 1141 P51 Gamma, E., R. Helm, R. Johnson and J. Vlissides. De-sign Patterns: \nElements of Reusable Object-Oriented Software. Addison Wesley, Massachusetts, 1994. WI Goldberg, A. and \nD. Robson. Smalltalk 80: The Lan-guage. Addison-Wesley, Reading, 1989. Gosling, J., B. Joy and G. Steele. \nThe Java Language Specification. The Java Series. Addison-Wesley, Read-ing, MA, USA, June 1996. [I71 \nk31Harbison, S. P. Modula-3. Prentice Hall, 1991. iI91 Hudak, P. and Wadler, P. (Eds.). Report on the \nprogramming language Haskell. Technical Report YALE/DCS/RR777, Yale University, Department of Computer \nScience, August 1991. [201 International Organization for Standardization. Ada 95 Reference Manual. The \nLanguage. The Standard Li-braries, Janurary 1995. Pll Jagannathan, S. Metalevel building blocks for modu-lar \nsystems. ACM Transactions on Programming Lan-guages and Systems, 16(3):456-492, May 1994. I221 Kelsey, \nR. A. Fully-parameterized modules or the miss- ing link. Technical Report 97-3, NEC Research Insti-tute, \n1997. Krishnamurthi, S., M. Felleisen and D. Friedman. Syn- [231 thesizing object-oriented and functional \ndesign to pro- mote re-use. In Proc. European Conference on Object-Oriented Programming, 1998. Kiihne, \nT. The translator pattern-external function- [241 ality with homomorphic mappings. In Proceedings of \nTOOLS 23, USA, pages 48-62, July 1997. Lang, K. J. and B. A. Pearlmutter. Oaklisp: an object- [25l oriented \ndialect of Scheme. Lisp and Symbolic Com-putation: An International Journal, 1(1):39-51, May 1988. Lee, \nS.-D. and D. P. Friedman. Quasi-static scoping: [261 Sharing variable bindings across multiple lexical \nscopes. In Proc. ACM Symposium on Principles of Program-ming Languages, pages 479-492, 1993. Lee, S.-D. \nand D. P. Friedman. Enriching the lambda calculus with context toward a theory of incremental program \nconstruction. In Proc. ACM International Conference on Functional Programming, pages 239-250, 1996. [271 \nLeroy, X. The Objective Cam1 system, 1996. URL: P81 http://pauillac.inria.fr/ocaml/. LagI Miller, J. \nand G. Rozas. Free variables and first-class environments. Lisp and Symbolic Computation: An In-ternational \nJournal, 3(4):107-141, 1991. Milner, R., M. Tofte and R. Harper. The Definition of Standard ML. The MIT \nPress, Cambridge, Mas-sachusetts and London, England, 1990. [301 Mitchell, J. G., W. Mayberry and R. \nSweet. Mesa Lan- [311 guage Manual, 1979. Palsberg, J. and C. B. Jay. The essence of the Visitor [321 \npattern. Technical Report 05, University of Technology, Sydney, 1997. Queinnec, C. Distributed generic \nfunctions. In Proc. [331 1997 France-Japan Workshop on Object-Based Parallel and Distributed Computing, \n1997. Queinnec, C. Meroon V3: A Small, Eficient, and En- [341 hanced Object System, 1997. Queinnec, \nC. and D. De Roure. Sharing code through [351 first-class envinroments. In Proc. ACM International Conference \non Functional Programming, pages 251-261, 1996. Rees, J. Another module system for Scheme, 1994. [361 \nScheme48 documentation. Rees, J. and N. Adams. Object-oriented programming [371 in Scheme. In Proc. \nACM Conference on Lisp and Functional Programming, pages 277-288, 1988. RCmy, D. and J. Vouillon. Objective \nML: A simple [381 object-oriented extension of ML. In Proc. ACM Sym-posium on Principles of Programming \nLanguages, pages 40-53, Paris, France, 15-17 Janurary 1997. Reppy, J. and J. Riecke. Simple objects for \nStan-dard ML. In Proc. ACM Conference on Programming Language Design and Implementation, pages 171-180, \n1996. 1391 Reynolds, J. C. User-defined types and procedural data [401 structures as complementary approaches \nto data ab-straction. In Schuman, S. A., editor, New Directions in Algorithmic Languages, pages 157-168. \nIFIP Working Group 2.1 on Algol, 1975. Shalit, A. The Dylan Reference Manual. Addison- [411 Wesley, \n1996. Steele Jr., G. L. Common Lisp: The Language. Digital Press, second edition, 1990. [421 Szyperski, \nC. A. Import is not inheritance -why we [431 need both: Modules and classes. In European Con-ference \non Object-Oriented Programming, volume 615 of Lecture Notes in Computer Science, pages 19-32. Springer-Verlag, \nNew York, N.Y., 1992. Tung, S.-H. Interactive modular programming in Scheme. In Proc. ACM Conference \non Lisp and Func-tional Programming, pages 86-95, 1992. E441 Wirth, N. Programming in Modula-2. Springer-Verlag, \n [451 1983. Appendix: MzScheme Class and Interface Syntax Classes The shape of a MzScheme class declaration \nis: (class* superclass-expr (interface-expr . . .) (init-variable . . .) instance-variable-clause . . \n.) (centered ellipses indicate repeated patterns). The expres-sion superclass-expr determines the superclass \nfor the new class, and the interface-exprs specify the interfaces imple-mented by the class. The in&#38;variables \nreceive instance-specific initialization values when the class is instantiated (like the arguments supplied \nwith new in Java). Finally, the instance-variable-clauses define the instance variables of the class, \nplus expressions to be evaluated for each instance. For example, a public clause declares public instance \nvariables and methods. Thus, the definition (define Rectangle (class* null (Shape) (width height) (public \n[draw (lambda (window x y) . ..)I))) introduces the base class Rectangle. The null indicates that Rectangle \nis not derived from any class, (Shape) indicates that it implements the Shape interface, and (width height) \nindicates that two initialization arguments are consumed for initializing an instance. There is one instance-variable- \nclause that defines a public method: draw. MzScheme s object system does not distinguish between instance \nvariables and methods. Instead, procedure-valued instance variables act like methods. The draw declaration \nin Rectangle defines an instance variable, and (lambda (win-dow x y) . . .) is its initial value expression, \nevaluated once per instance. When draw is called as the method of some object, draw may refer to the \nobject via this. In most object- oriented languages, this is passed in as an implicit argument to a method; \nin MzScheme, this is part of the environment for evaluating initialization expression, so each method \nin an object is a closure containing the correct value of this.6 An instance of Rectangle is created \nusing the make-object primitive. Along with the class to instantiate, make-object takes any initialization \narguments that are expected for the class. In the case of Rectangle, two initialization arguments specify \nthe size of the shape: (define rect (make-object Rectangle 50 100)) The value of an instance variable \nis extracted from an ob-ject using ivar. The following expression calls the draw method of rect by extracting \nthe value of draw and ap-plying it as a procedure: ((ivar rect draw) window 0 0) Since method calls \nof this form are common, MzScheme pro-vides a send macro. The following send expression is equiv- alent \nto the above ivar expression: (send rect draw window 0 0) MzScheme s approach to methods avoids duplicating \nthe func-tionality of procedures with methods. However, this design incurs a substantial cost in practice \nbecause each object record must pro-vide a slot for every method in the class, and a closure is created \nfor each method per object. Adding true methods to the object system, like methods in most object-oriented \nlanguages, would improve the run-time performance of the object system and would not affect the essence \nof our presentation. Interfaces An interface is declared in MzScheme using the interface f orm: (interface \n(superinterface-expr .) variable .) The superinterface-erprs specify all of the superinterfaces for the \nnew interface, and the variables are the instance variables required by the interface (in addition to \nvariables declared by the superinterfaces). For example, the definition (define Shape (interface () draw)) \ncreates an interface named Shape with one variable: draw. Every class that implements Shape must declare \na dravr in-stance variable. The definition (define BB-Shape (interface (Shape) bounding-box)) creates \nan interface named BB-Shape with two variables: draw and bounding-box. Since Shape is the superinterface \nof BB-Shape, every class that implements BB-Shape also im- plements Shape. A class implements an interface \nonly when it specifically declares the implementation (as in Java). Thus, the Rectan-gle class in the \nprevious section only implements the Shape interface. Derived Classes The definition (define BB-Rectangle \n(class * Rectangle (BB-Shape) (width height) (public [bounding-box .. .I) (sequence (super-init zuidth \nheight)))) derives a BB-Rectangleclass that implements BB-Shape. The draw method, required to implement \nBB-Shape, is inherited from Rectangle. The BB-Rectangle class declares the new bounding-box method. It \nalso includes a sequence clause that calls super-init. A sequence clause declares expressions to be evaluated \nfor each instance. It is commonly used to call the special super-init procedure, which initializes the \npart of the instance defined by the superclass (like calling super in a Java con-structor); a derived \nclass must call super-init exactly once for every instance. In the case of BB-Rectangle, calling super-init \nperforms Rectangle s initialization for the instance. BB-Rectangle provides two arguments to super-init \nbecause the Rectangle class consumes two initialization arguments.  \n\t\t\t", "proc_id": "289423", "abstract": "Module and class systems have evolved to meet the demand for reuseable software components. Considerable effort has been invested in developing new module and class systems, and in demonstrating how each promotes code reuse. However, relatively little has been said about the interaction of these constructs, and how using modules and classes <i>together</i> can improve programs. In this paper, we demonstrate the synergy of a particular form of modules and classes---called units and mixins, respectively---for solving complex reuse problems in a natural manner.", "authors": [{"name": "Robert Bruce Findler", "author_profile_id": "81100028925", "affiliation": "Department of Computer Science, Rice University, Houston, Texas", "person_id": "PP14022884", "email_address": "", "orcid_id": ""}, {"name": "Matthew Flatt", "author_profile_id": "81100490544", "affiliation": "Department of Computer Science, Rice University, Houston, Texas", "person_id": "PP39045354", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/289423.289432", "year": "1998", "article_id": "289432", "conference": "ICFP", "title": "Modular object-oriented programming with units and mixins", "url": "http://dl.acm.org/citation.cfm?id=289432"}