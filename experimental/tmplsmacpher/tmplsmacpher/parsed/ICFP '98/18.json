{"article_publication_date": "09-29-1998", "fulltext": "\n A Distributed Garbage Collector with Diffusion Tree Reorganisation and Mobile Objects Luc Moreau Department \nof Electronics and Computer Science University of Southampton, Southampton SO17 1BJ UK L.MoreauQecs.soton.ac.uk \nAbstract We present a new distributed garbage collection algorithm that is able to reorganise diffusion \ntrees and to support mobile objects. It has a modular design comprising three components: a reliable \ntransport mechanism, a reference- counting based distributed garbage collector for non-mobile objects, \nand an extra layer that provides mobility. The al-gorithm is formalised by an abstract machine and is \nproved to be correct. The safety property ensures that an object may not be reclaimed as long as it is \nreferred to locally or re- motely. The liveness property guarantees that unreachable objects will eventually \nbe reclaimed. The mobility property certifies that messages are always forwarded towards more recent \nmobile object positions. Introduction Distributed object systems provide programmers with the capability \nto refer to remote objects and to activate remote computations (generally called remote method invocation) \n[27, 281. In this context, distributed garbage collection is a valuable technology as it automatically \nmaintains pointer consistency: it ensures that an object will not be reclaimed as long as it is referred \nto locally or remotely. The distributed agent model of computing [2, 181 is an al- ternative to the traditional \napproach of distributed comput-ing because it is able to deal with intermittent connections. According \nto the agent paradigm, users delegate a task to a program, which attempts to solve it, autonomously given \nsome resource constraint, possibly by migrating to remote sites. Mobile computations put an extra burden \non the dis-tributed garbage collector as they typically abandon chains of forwarding pointers. It is \ndesirable to short-cut those chains not only to accelerate the access to remote mobile objects, but also \nto make them independent of the previous hosts they visited (which is precisely one of the goals of the \nmobile agent model). For this purpose, we have designed NeXeme [20] a dis- tributed extension of Scheme \n[25] with mobile objects and primitives to control resource consumption [21]. The goal of this paper \nis to describe its distributed garbage collector based on distributed reference counting. Its major features \nare: l It uses a new flexible way of reorganising diffusion trees which is suitable for immobile and \nmobile objects. l It separates concerns in different modules: (i) Re-liable message-passing and FIFO \nhandling is provided by the transport mechanism; (ii) The distributed garbage collector deals with pointers \nto immobile ob-jects; (iii) Object mobility is provided as a layer on top of the garbage collector. l \nThe distributed garbage collector can be implemented as a language independent library. NeXeme [ZO] is \na distributed Scheme based on the mes-sage-passing library Nexus [7], which essentially provides two \nmechanisms: the remote serva ce request is a form of remote procedure call, and global pointers provide \nfor global naming in a distributed environment. Nexus runs on a va- riety of hardware and protocols, \nincluding workstations or supercomputers, and TCP/IP or UDP. The garbage collector we present in this \npaper is based on reference counting. As other reference-counting algorithms, ours is unable to reclaim \ndistributed cycles. However, we should observe that there is a range of applications that do not create \ndistributed cycles. In particular, Tel and Mat-tern [29] have shown that the problem of termination in \ndis- tributed systems is equivalent to distributed GC. Reference counting can be used because processes \nform a hierarchy. Groups 1211 also have a hierarchical organisation and can be reference counted. A preliminary \nand very schematic description of the dis- tributed garbage collector appeared in [20]. This paper, which \ncovers it in details, is organised as follows. In Section 2, we describe the Nexus programming model \nand define some terminology that we shall use in the rest of a paper. In Section 3, step-by-step, we \nintuitively present our algo-rithm for distributed garbage collection. In Sections 4 and 5, the algorithm \nis formalised by an abstract machine, and its correctness is established by proving two properties: safety \nand liveness. Implementation issues are discussed in Sec-tion 6. The mobility layer is studied in Section \n7. Finally, a comparison with related work concludes the paper. 2 The Nexus Programming Model The Nexus \n[7] philosophy is derived from active messages [30], where each message contains at its head the address \nof a user-level handler executed on message arrival. Computa-tions execute on a set of sites and consist \nof a set of threads. An individual thread may read and write data shared with other threads executing \nin parallel on the same site. Nexus defines two abstractions: the global pointer and the remote service \nrequest. The global pointer (GP) pro-vides a global name space for objects, while the remote ser-vice \nrequest (RSR) is used to initiate communications and to invoke remote computations. A GP is a name for \nan object, and it specifies a destination to which a communication can be directed by an RSR. GPs can \nbe created dynamically; once created, a GP can be communicated between sites by including it in an RSR. \nAs far as distributed garbage collec-tion is concerned, a GP can be regarded as a remote object reference, \nsometimes called o-reference [17]. Practically, in NeXeme, an RSR is specified by providing a global \npointer, a handler identifier, and some arguments. Issuing an RSR causes the arguments to be transfered \nto the site designated by the global pointer, after which the routine specified by the handler is executed. \nBoth a copy of the arguments and the pointed object are available to the RSR handler. As opposed to the \ntraditional remote procedure call, a remote service request does not return a result; if a result is \nneeded, another RSR has to be used. Handlers may be executed in a new thread of control. If handlers \nare not threaded, Nexus provides a FIFO ordering of RSRs in addition to a reliable transport protocol. \nWe define the notion of owner, emitter, and receiver. The owner of a GP is the site where the GP is pointing \nat. The emitter of a GP is a site sending an RSR containing the GP; the emitter may or may not be the \nowner. The receiver of a GP is a site receiving an RSR containing the GP; the receiver may or may not \nbe GP s owner. 3 The Intuition In this Section, we progressively describe our new distributed garbage \ncollection algorithm. First, we present how refer-ence counting can be integrated with the Nexus program-ming \nmodel. Initially, we deal with two sites only; then, we show that a straightforward extension to more \nsites fails to be satisfactory. Finally, we introduce our solution. 3.1 Two sites Each site uses a thread \nsafe, conservative, mark and sweep garbage collector [lo] to reclaim unused space locally. Con-servativeness \nis required as Scheme data are passed to Nexus, written in C, and are pointed by Nexus data structures. \nLet us consider a data on a site SI and a GP pointing at this data. The purpose of a distributed garbage \ncollector is to ensure that the data on s1 is not reclaimed as long as GP remains reachable locally or \nremotely. In order to deal with distribution, we use a reference counting technique. The first time GP \nis sent to a remote site during an RSR, it is associated with a counter initialised to one. Afterwards, \nevery time the same GP is sent, its associated counter is incremented by one. We use a table to maintain \nassociations between coun-ters and global pointers that were sent to remote sites. We call this table \nsend-table as it is used when RSFls are sent. In a first approximation, the send-table indicates the \nnum-ber of tinies a global pointer was sent. The send-table is constructed as a root of the local garbage \ncollector. As a re- sult, by its presence in the send-table, GP remains reachable from the local collector \nroots, which ensures that the space used by the data referenced by GP cannot be reclaimed. In order to \nkeep reference counters upto date, each site has to be able to determine whether a GP has already been \nreceived. For this purpose, each site maintains a second ta-ble, called receive-table1 , which contains \nthe global pointers that have already been received. A GP also appears in its owner s receive table. \nSo far, the situation is summarised by Figure 1 where GP is sent from s1 to 32; GP is entered in the \nsend-table of s1 with the counter value 1 and in the receive-table of $2. Figure 1: GP sent from sl to \na2 In addition to reference counters, the distributed garbage collection algorithm uses control messages, \nwhose purpose is to update counters. A decrement message is aimed at a site and contains a global pointer \nGP. When the destination site receives such a message, it decrements the counter as-sociated with GP \nin its send-table; if the counter reaches 0, the entry for GP is removed from the send-table. We use \ndecrement messages in two different situations. First, when a GP received by a site becomes garbage on \nthis site, GP is removed from the receive table and a decrement message is sent to GP s owner. In Figure \n2, as soon as GP becomes inaccessible on ~2, a decrement message is sent to ~1. GP is removed from the \nsend-table of ~1, and the space can then be reclaimed on s1 if no longer used. Second, when a GP is received \nby a site that already owns a copy of the GP (in its receive table), a decrement message has to be sent \nback to the emitter so as to maintain accurate reference counters. Now, we can refine the counter description: \na counter in a send-table represents the num-ber of different remote copies of a GP plus the number of \nmessages related to it in transit. We call our tables send and receive because they are used when sending \nor receiving global pointers, respectively. Other names may be found in the literature: entry and exit \nitems 115, 231; scions and stubs [24]. or Inconling and Outgoing reference tables (61. is, the GP s \nowner. The effect of the decrement message is to remove GP from the send-table of ~1, and possibly to \nreclaim its space if no longer reachable. This clearly results in an inconsistent situation as GP may \nstill be active on SZ. Figure 2: GP freed on s2  3.2 More than Two Sites Let us now consider three sites. \nThe right-hand side of Fig- ure 1 displays the situation after GP is passed from si to ~2. Using the \nsame principle, Figure 3 presents the setting after GP is passed from s2 to ss: send-tables in si and \ns2 contain entries for GP, which also appears in receive-tables in s2 and sa. I Figure 3: Indirect Counters \nAlong the Diffusion Tree In fact, the mechanism we describe here bears a strong resemblance with indirect \nreference counting [22], where the sum of reference counters across the diffusion tree of a GP is the \nnumber of its remote copies. Besides, when a site receives a GP that it has already got, a decrement \nmessage is sent to the GP emitter, that is, to its parent in the diffusion tree. However, the nature \nof Nexus global pointers results in a different usage of the other kind of decrement message. Let us \nrecall that, when a GP becomes garbage, a message is sent to its owner. This design decision is motivated \nby the fact that a Nexus GP only refers to its owner site, and has no information about the site that \nemitted it. Unfortunately, untimely decrement messages may be the consequence as illustrated in Figure \n4. If the GP sent to sa becomes garbage, sa sends a decrement message to si, that , DEC(GP) , Figure \n4: Untimely Decrement Message Besides the incorrectness related to the decrement mes-sage, such an indirect \nreference counter technique may keep some pointers active longer than needed; in other words, this results \nin a form of memory leak. Indeed, in Figure 3, the space occupied by GP on sa (as well as its entry in \nthe send-table) cannot be reclaimed even if GP is no longer needed on SP. 3.3 Diffusion Tree Reorganisation \nOur solution to both the untimely arrival of messages and memory leaks involves a new type of message, \ncalled incre-ment-decrement. An increment-decrement message involves three different sites: si, 52, sa, \nrespectively, the owner, the emitter and the receiver of a GP. When GP reaches the re-ceiver for the \nfirst time, an increment-decrement message is sent to its owner. When si receives an increment-decrement \nmessage, it increments GP s reference counter, and then sends a decrement message to s2 concerning GP. \nFigure 5: Increment-Decrement Message Let us go back to Figure 3, where sa sent to sa a GP owned by \nSI. If sa receives GP for the first time, ss sends an increment. -decrement message to si concerning \nGP and ~2. The result is to increment GP s counter on si (Figure 5) and to send a decrement message from \nsi to SP (Figure 6). The effect is to prune the diffusion subtree rooted at sa, and to graft it to the \nroot ~1. Figure 6: Decrement Message Introducing the increment-decrement message is not suf- ficient \nto avoid untimely message arrivals. The increment-decrement message from sa should be received by SI \nbefore any decrement message from ss about the same GP. This can be enforced by adding an extra constraint: \na site is al- lowed to send a decrement message to the owner of an object only if there is no pending \nincrement-decrement message for the same object. The constraint can be implemented by in-order message \ndelivery. In Figure 6, we can observe that if GP is no longer reach-able on sa, its space can safely \nbe reclaimed. Such a property is particularly important in the presence of mobile compu-tations jumping \nfrom sites to sites. The diffusion tree re-organisation provided by the increment-decrement message prevents \nthe formation of chains of pointers abandoned by mobile computations. This Section has described the \nalgorithm principle. The following sections are concerned with its formalisation and correctness proof. \nWe then study its implementation and some optimisations. Abstract Algorithm In this Section, we formalise \nour garbage collection proce-dure into an abstract algorithm. We model our distributed garbage collector \nby an abstract machine, called the DGC- machine, whose state space appears in Figure 7. In the DGC-machine, \nwe only model messages exchanged by the distributed garbage collector, and we do not model any form of \ncomputation. A finite number of sites take part to the DGC-machine. We define a global pointer as a pair \ncomposed of an address and a site; by definition, the address is local to the site. The owner of a global \npointer GP = (a, s) is by definition the site s, which we write owner(GP). Three types of mes- sages \ncan be exchanged in the DGC-machine. They follow a same schema: NAME(emitter, receiver, arguments,. . \n.), where the emitter and receiver are sites, and arguments are message-dependent. Send and Receive Tables \nare rep-resented by functions associating sites and global pointers with numbers or booleans, respectively. \nFinally, a DGC-configuration is given by a tuple of sites, global pointers, send tables, receive tables, \nand a pool of messages. A pool of messages is a bag, which represents messages in transit in the system. \nBy transit, we mean messages that are queued to be sent, messages that are being transferred, and mes-sages \nthat are received but not handled yet. The initial configuration Vi is defined as follows: Vi = (S,G, \nsend-Ti, ret-Ti, @, where the initial send table send-Ti = Xs GP.9 contains zero for every entry, and \nthe initial receive table rec$ = Xs GP.owner(GP) = s is false for every entry, except on sites that own \na GP. Three kinds of legal transitions can evolve the state of the DGC-machine. According to Figure 8, \na transition trans-forms a configuration Vr into a configuration Da, using con-figuration transformers \ndefined in Figure 9; these transform- ers are an abstract representation of the algorithm. Using these \nthree transitions, the DGC-machine is able to reach all the different configurations that would be reached \nin a real implementation. We model the duplication of a global pointer, during a remote method invocation \nor re-mote service request, by the (make-copy) transition, which involves an emitter si and a receiver \nss. Messages in the pool of messages can be handled by a (receive) transition. Finally, local collectors \ncall a finalization method [ll] on global pointers that are no longer reachable from the set of roots; \nthis is modelled by the transition (delete), which means that a copy of a GP on a site s is deleted. \nThere is a side-condition of (delete) by which the owner is prevented to send such DEC messages. In Figure \n9, we use the following conventions. Let (S, 6, send-T, ret-T, M) be a configuration : l send-T(s, GP) \n:= V denotes (S, 8, send-T , ret-CT, M), such that send-T (s, GP) = V and send-T (s, GP ) = send-T(s,GP \n),VGP # GP. l ret-T(s, GP) := V is similar. l post(m) denotes (S, 6, send-T, ret-T, M U {m}), with U \nthe union operator on bags. Finally, configuration transformers are executed atomically. The configuration \ntransformer MAKECOPY is used in transition (make-copy). According to MAKE-COPY side-conditions, a transition \n(make-copy) is permitted if the emitter has access to the GP to be sent. The effect is to increase the \nemitter s send-table entry for GP and to post a COPY message, modelling a GP duplication. When a COPY \nmessage is received, either a DEC or an INCJ)EC message is posted, according to the presence of GP in \nthe receive table. Receiving an INC-DEC message increases the owner send-table and posts a DEC message. \nReceiv-ing a DEC message decreases the send-table. Finally, a DELETE transition is allowed on a site \nthat is not the owner of GP and does not contain GP in its send table. The effect is to set the receive-table \nto false and to post a DEC message to the owner. SES = {S0,S1,.~.,Sn} (Set of Sites) GP E 4 ::= (LY,S) \n(Set of Global Pointers) cuEAddr = {(Yo,. . .} (Address) mEMsg ::= DEC(sl, ~2, GP) 1 INCDEC(s1, ~2, GP, \nss) 1 COPY(sl, ~2, GP) (Message) M : Bf-wOf Ww) (Pool of Messages) send2 : SxG-hlN (Send Tables) rec2 \nS x G + Boo1 (Receive Tables) 2) E Config ::= (S,G, send-T, ret-T, M) (DGC-Configuration) Figure 7: \nState Space of the DGC-machine DD1 + MAKE-COPY(s1,sz,GP) 3 V2 (make-copy) if sl,s2 E S, GP E G, with \nlJ1 = (S,B,send-T,rec-T, M) VI + RECEIVE(m) * 272 (receive) if m E M, with VI = (S, S, send3, ret-T, \nM) A if m = DEC(sl,s2,GP), then INCDEC(sl,ss,GP,ss) # M,Vs3 V1 =+ DELETE(s,GP) + V2 (dedete) if s E S, \nGP E 4, with VI = (S,S,sendLZ ,rec-T, M) Figure 8: Transitions of the DGC-Machine MAKEXOPY(sl, ~2, GP) \nif s1 # s2 A (SI = oulner(GP) V ret-T(sl,GP)) { send-ir(sl, GP) := send-T(sl, GP) + 1 post(COPY(sl,sz,GP)) \n} RECEIVE(COPY(sl, ~2, GP)) if SI # s2 { if ret-T(s2, GP) then { post(DEC(sz, 81, GP)) } else {ret-T(s2, \nGP) := true post(INCDEC(s2, wner(GP), GP, ~1)) if s1 # owner(GP) } ) RECEIVE(INC-DEC(sl, s2, GP, s3)) \n{ send-T(s2, GP) := send-T(s2, GP) + 1 post(DEC(s2, 33, GP)) } RECEIVE(DEC(sl,s2, GP)) { sendJ (s2, GP) \n:= send-T(s2, GP) -1 } DELETE(s, GP) if send-T(s, GP) = 0, recJ (s, GP), owner(GP) # s { rec-T(s,GP) \n:= false post(DEC(s, owner(GP), GP)) } Figure 9: Abstract Garbage Collection Algorithm 5 Correctness \nIn this Section, we establish the correctness of our distributed garbage collector. Correctness of a \ndistributed garbage col- lector has two different aspects. A garbage collector has the safety property \nif an object is never reclaimed when remote references are still accessible. It has the liveness property \nif unreachable objects are eventually reclaimed. Let us first study the first property. It is derived \nfrom three invariants that we state in the following Lemmas. We are interested in proving the correctness \nof the algo- rithm for each GP. We therefore introduce an operator that allows us to select messages \nrelated to a GP. Deiinition 1 Let 2, E (S, 6, send2, ret-T, M) be a config- uration of the DGC-machine. \nLet GP be a global pointer of E. The set of messages related to GP, written M J. GP, is defined as m \n= COPY(si,sj,GP), {mEM I m = DEC(si,sj,GP), or m = INCDEC(si, sj, GP, ok), for any Si, Sj, Sk}. 0 For \na given GP, the first invariant expresses the sum of counter values in send tables as a function of the \nreceive ta-ble values and the weight associated with messages. By def- inition, DEC and COPY messages \nhave a unitary weight, while INCDEC messages have a null weight. Lemma 2 Let V E (S, E, send-T, ret-T, \nM) be a legal dis- tributed system. We have the following property. FOTany GPE~: sendA (si, GP) c si \nES = INT(rec-T(si, GP)) -1 c SiE.5 Weight(m),+ c mEMJ.GP with Weight(DEC(sl, ~2, GP)) = 1 Weight(COPY(s1, \n~2, GP)) = 1 Weight(INCDEC(sl,s2, GP)) = 0 INT(true) = 1 INT(false) = 0. cl Proof of Lemma 2 The invariant \nis initially true for any initial configuration. We then prove that each possible transition of the machine \npreserves it. Details may be obtained from [19]. 0 Before the next Lemma, we need to define an operator \nthat allows us to select messages that act (or have acted) upon counters maintained by a site si, which \nwe call mes-sages under control of si. Definition 3 Let 2, s (S, E, send-T, ret-T, M) be a config- uration \nof the DGC-machine. Let si be a site of S. The set of messages under control of sit written M .J, si, \nis defined as m = COPY(si, sj, GP), m = DEC(sj,si,GP), OT imEM I m = INC-DEC(S~, sj, GP, si), for any \nGP,sj,sk}. cl Messages that relate to GP and under control of si, writ- ten M .J (si, GP) are defined \nas the intersection of M j. (si) and M 4 (GP). Lemma 2 gives the value of the sum of counters for a given \nGP. The next Lemma states that the value of a counter on a site si that is not the GP owner is equal \nto the number of messages related to GP and under control of Si. Lemma 4 Let V E (S,g,send-T,rec-T, M) \nbe a legal dis- tributed system. We have the following property: V GP E g,V si E S such that si # owner(GP), \nsend-T(sg, GP) = #(M 4 (si, GP)). 0 Proof of Lemma 4 The equality is initially true and is preserved \nby each tran- sition. The case analysis is available from [19]. 0 By combining the results of Lemmas \n2 and 4, we can determine the value of the counter in the owner send-table. The value of the owner reference \ncounter for a given GP is the number of true entries in the receive-tables plus the number of messages \nCOPY and DEC in transit minus the number of INC-DEC messages aimed at the owner. Lemma 5 Let 2, 5 (S, \nG, send-T, ret-T, M) be a legal dis- tributed system. The following property holds: V GP E 6, such that \ns = owner(GP), send-T(s, GP) INT(rec-T(si, GP)) -1 =c &#38;ES + c Weight(m) mEMl(s,GP) -#({m 1 m = INC-DEC(sj,s,GP,si), \nVsi, sj}). 0 Proof of Lemma 5 The result is obtained by rewriting Lemma 4 into Lemma 2, and simplifying \nthe equality. 0 The next Theorem establishes the safety of the algo-rithm. If GP is accessible on a site \ndifferent from its owner, i.e. if a receive table has an entry for a given GP, then GP is present in \nthe owner send-table; therefore, cannot be reclaimed on the owner. Theorem 6 (Safety) Let (S, G, sendy \n, ret-T, M) be a configuration. The following statement holds: V GP E 6, let s = owner(GP),Vsi # S, if \nret-T(si, GP), then send-T(s, GP) > 0. Cl Proof of Theorem 6 Lemma 5 defines the value of the send-table \non the owner of a GP, which can be rewritten as follows: send-T(s,GP) = c xi -I<, si ES with Xi = INT(rec-T(si, \nGP)) + #({m 1m = DEC(si,s,GP) or m = COPY(s, si, GP)}), Ya = #({m 1m = INCDEC(si, S, GP, sj), Vsjl). \n A case analysis on the different transitions allows us to con- clude that Xi -Yi 2 0. The interesting \ncase concerns a transition receiwe(DEC(si, s, GP)), where the difference af-ter transition is smaller \nthan before transition. It however remains positive by the side-condition on the receive transi- tion. \nWe can therefore conclude that: send-T(s, GP) 2 0. If there is a si such that rec-ir(si, GP), then there \nexists at least one site sj such that X, -Yj > 0, which guarantees that sendT(s,GP) > 0. We proceed ab \nabsurdo. Let us assume that Xj -Yj = 0 for every sJ. Therefore, for every aj such that rec-T(sj, GP), \nthere is sk and at least one message INCDEC(sj, s, GP, sk), SO that Yj = Xj (cf. Lemma 5). This means \nthat sendT(sk, GP) > 0, which implies ret-T(sk,GP). Let us examine the sequence of sites: Sj, Sk,. . \n. . The sequence is either finite or infinite. l If it is finite, let sn be the last site such that rec-T(sn, \nGP) = true. By the same reasoning, there is a following site sn+l in the sequence, which contradicts \nthe fact that So was the last. l If the sequence is infinite, there must be a loop as we have only a \nfmite number of sites S. Let si the first site of the sequence occurring twice: . . . , ~1,. . . , ~1,. \n. . . Those INCDEC messages are only produced by MAKE-COPY(sl,sl+l, transitions if GP)yrec-T(sn+l, GP). \nAs those transitions are performed atomically, such a sequence cannot exist, because a transition (make-copy) \nshould have posted a DEC mes-sage instead of an INCDEC message. In order to prove the GC liveness, we \nfirst assume that control messages are eventually processed. The liveness property follows from previous \nLemmas. The next two Lem- mas define the value of reference counters when control mes-sages related to \na given global pointer are processed. First, Lemma 7 establishes that reference counters in send-tables \nof sites different from the owner become zero when control messages are processed. Lemma 7 Let 2, f (S, \n5, send-T, ret-T, M) be a legal dis- tributed system. FOT any GP E E, for any si E S such that si # owner(GP). \nIf there is no message related to GP, then: send-T(si, GP) = 0. 0 Proof of Lemma 7 The proof is a consequence \nof Lemma 4, with M 4 (si, GP) = 0. 0 Lemma 7 ensures that as control messages are processed, global \npointers will not remain accessible from local roots longer than needed by the user s program. Lemma \n8 defines the value of the owner s reference counter after processing control messages. Lemma 8 Let (S, \nG, send-T, ret-T, M) be a DGC-configu- ration. Let GP E 6, such that no message related to GP is in transit. \nIfs = owner(GP), then : send-T(s, GP) = c INT(rec-T(si, GP)). %ES 0 Proof of Lemma 8 The proof is a \nconsequence of Lemma 5, with M 4 GP = 8. 0 Next, we assume that local collectors also enjoy the live- \nness property, i.e. the ability to reclaim unreachable objects. We can conclude that if GP is unreachable \non all machines but the owner, the value of the reference counter on the owner will become zero, which \nin turn guarantees that GP and its associated object may be reclaimed if unreachable on the owner. Theorem \n9 (GC Liveness) Let GP be a global pointer inaccessible on sites different from its owner, such that \nno message related to GP is in transit. Ifs = owner(GP), then send-T(s, GP) = 0. 0 Proof of Theorem 9 \nImmediate from Lemmas 7 and 8. 0 These results also show that the effect of reorganising the difision \ntree is to flatten it so that all sites that have access to a global pointer become direct children of \nits owner. 6 Implementation Issues This section is concerned with some implementation aspects of the \ndistributed garbage collector. First, we describe the different modules of our implementation, then we \npresent a number of optimisations, and finally, some specific details are covered. 6.1 Implementation \nSketch The distributed garbage collector relies on four modules. 1. The send-table module. The send-table \nis a hash-table and, for our purpose, is interfaced by two functions. The function increment-reference-count! \nexpects a GP and in- crements its reference counter in the send-table; if GP is not present before the \ncall, it is given an initial counter value 1. The function decrement-reference-count ! expects a GP and \ndecrements its associated reference counter; GP is re- moved from the table, if its value reaches 0. \n 2. The receive-table module. The receive-table is also a hash table that is manipulated by three functions. \nThe functions put-in-receive-table! and remove-from-re-ceive-table! both expect a GP and respectively \nadd it to or remove it from the table. Finally, the predicate is-in-receive-table? indicates whether \na global pointer belongs to the table.  3. The serialisation-deserialisatl;on module. It is com- posed \nof two functions notify-send-gp! and notify-re-ceive-gp ! which are called when a global pointer is re-spectively \nserialised or cleserialised during an RSR. When a global pointer is sent, its reference counter is incremented. \nWhen a global pointer is received, the function notify-re-ceive-gp! is called and returns a global pointer \nto be used in the RSR handler. If the GP has already been received, i.e. it is already in the entry table, \na decrement message is sent to the emitter, and the copy of GP in the receive-table is returned. Otherwise, \nif it is the first reception of GP, it is entered in the receive-table and an increment-decrement message \nis sent to its owner, provided that the emitter is not the owner. Tables must be accessed in a critical \nsection as several RSRs may be received and handled in parallel. When receiv- ing an RSR, it is not the \nappropriate time to send a new GC control messages; handling the request has a higher priority. As a \nresult, requests to send control messages are simply en-queued by functions belonging to the message \nmodule (see next item). 4. The message module takes care of handling and send- ing control messages. \nWhen a decrement message is re-ceived for a given GP, the function decrement-referen-ce-count ! is called \non GP. When an increment-decrement message is received for a GP and a site s, the function increment-reference-count \n! is called on GP, and a decre- ment message is enqueued for the GP, aimed at site s. Or-der of messages \nbetween two sites must be preserved and increment-decrement messages should always be sent before decrement \nmessages if they concern a same GP. 6.2 Optimisations Section 4 described the abstract algorithm used \nfor our gar-bage collector. A number of optimisations can be imple- mented to reduce the cost of garbage \ncollection. All opti-misations are based on the property that control messages may be delayed because \nthey are not part of the mandatory computation. However, there clearly needs to be a balance between \ngarbage collection activities and mandatory compu-tations, because delaying control messages for a long \ntime may increase the memory requirement of the application too much. By grouping messages by destination, \nwe can substan-tially reduce control message traffic. For instance, a decre- ment message to a given \nhost contains a variable number of global pointers as well as the amount by which their counter should \nbe decremented. In our implementation, message frequency may be controlled by two variables specifying \nthe minimum and maximum number of counter updates in every control message. Similarly, an increment-decrement \nmessage concerning a GP and a site s may be merged with a decrement message concerning GP and aimed at \ns. The increment-decrement message should contain the amount by which the counter should be decremented \non s: when received by the owner, it increments GP counter, and then sends a decrement message with the \ngiven amount. When a GP becomes inaccessible, a decrement message is sent to its owner. The algorithm \ncan be further optimised at that time if the increment-decrement message was not yet sent to its owner \n(and to be followed by a decrement message to a third site s). The decrement message and the increment-decrement \nmessage to the owner cancelled each other and can be replaced by the decrement message to s. (Note that \nby delaying increment-decrement messages, our garbage collector behaves very similarly as indirect reference \ncounting.) We can easily see that these three optimisations preserve the safety and hveness of the algorithm. \n 6.3 Implementation Details The recedljr: tnble contains all global pointers owned or re-ceived by a \nsite. The receive table should be designed care-fully. If a global pointer entered in a receive table \nremains accessible to the local garbage collector from the root set, it will never he collected, nor \nthe object on the owner host. Therefore, entries of global pointers in an receive table should be masked \nso that their inaccessibility can be detected. Once such a glohal pointer becomes inaccessible, it must \nalso be removed from the receive table. Inaccessibility is de- tected after a local collection by installing \nfinalizers [II] on global pointers. A finalizer is a procedure called by the local garbage collector \non an object once it is detected to be in- accessible. In NeXeme, such finalizers remove global point-ers \nfrom the receive-table and prepare a decrement message to the global pointer owner. The message itself \ncannot be sent at garbage-collection time because such an operation requires memory not necessarily available \nat that moment: instead, inaccessible global pointers are queued (without al-location) by finalizers, \nand messages are sent to their des-tination sites, only after the end of the garbage collection. The \nsend-table, as opposed to the receive table, is a root of the local garbage collector. The distributed \ngarbage collector was implemented in Scheme. However, nothing prevents us to implement it in C. As a \nresult, Nexus, Boehm and Weiser s collector, and a C library for distributed garbage collection could \nall be packaged as a language-independent message-passing li-brary, with a distributed garbage collector. \n7 Mobility Nexus global pointers refer to immobile objects, but mobile objects can be implemented using \nglobal pointers. For in- stance, mob&#38; ports [8] feature mobile receiving and sending ends. In this \nSection, we describe another approach able to deliver method calls to mobile objects. We define a mobile \nobject A40 as a record composed of five fields (Figure 10): (i) the object content obj, (ii) information \nabout the object position fwd, (iii) a mobility counter count, (iv) a message queue q, (u) and a lock \nto guarantee mutual exclusion when accessing the object. (The semantics of locks and their primitives \nlock, unlock is defined in [20].) Such mobile objects may be referred to remotely by global pointers \n(cy, s), denoting a mobile object at address N on site s. We support two actions on mobile objects: remote \nser-vice requests, i.e. method invocation, and migration. Our goal is to ensure that methods will eventually \nbe invoked even though objects migrate; this requires us to forward messages to mobile objects. The RSR \nmessage, with global pointers GPI and G4, handler name and other arguments denotes the invocation of \nthe method name on a mobile object represented by GPz. When the user issues a RSR message, GPl must be \nset to nil; RECEIVE(RSR(GS, ((~2, SZ), handler,. .)) .I-..- RSR(GA, GP2, name,. .) 1 UPDATE(GP1, GS, \nGPs, courxt) (Message) f E? ::= nil 1 fVvd 1 GP (Forwarding Field Value) u E Store : S x Addr -+ MO (Store) \nMO : { obj : any, (Data Field) (Mobile Object Record) fwd: F, (Forward Field) count : IN, (Mobility Count \nField) q : m , (Queue Field) lock : C} (Lock Field) { lock(u(sz, cuz).Zock); if a(sz, crz).fwd = nil \nthen { unlock(u(sz, aa).lock); handle-msg(handler, u(sz, cvz).obj, .) } elif o(sz, az).fwd E 6 then { \nunlock(u(sz, cuz).lock); if GP1 # nil then post(UPDATE((az, SZ), G4 ,u(s~, QZ).fwd,u(sz, crz).coun,t)); \n/* update the emitter */ post( RSR( (QZ, SZ), u(s2, oz).fwd, handler, . .) } /*forward the request */ \nelse { o(s2, az).q := u(s2, crz).q 5 (RSR(GP1, (02, sz), handler,. .I); /* enqueue the request */ un1ock(u(sz, \ncrz).lock) } } MIGRATE((cvl,sl), (02, ~2)) RECEIVE(IJPDATE((CU, sl), (a~, SP), GP, count)) { lock(u(sl, \ncul).lock); { lock(u(sn, c+ock); if o(sr, crz).fwd # nil if u(sz! az).count < count then then raise object \nhas already moved { u(sz, cm). fwd := GP; else { u(sl,al).fwd := fwd; u(s2, cuz).count := count }; u(sl,cul).count \n:= u(sl,crl).count + 1; unlock(u(sz, crz).Zock) } unZock(u(sl, crl).lock); copyabject((crl, SI), (QZ, \n~2)); /* returns when object is copied*/ lock(u(si,ai).lock); u(s1, crl).fwd := (QZ, sz); u,nlock(u(sl, \nal).Zock); forward-queuedmessages(u(sl, crl).q, ((~2, ~2)) } } Figure 10: Object Migration as the request \nis forwarded, GPl denotes the latest forwarder met. When an RSR message is received, the object lock \nis acquired is order to maintain local consistency. If its fwd field is nil, the mobile object is local, \nand the method is called locally (with handlemsg). Otherwise, if the fwd field contains a global pointer \nGP, the object acts as a forwarder to the new position denoted by GP. Migration of a mobile object (or, \nsr) to a new position (oz, ~2) is handled by the function MIGRATE. Migration consists of increasing the \nmobility counter, copying the ob- ject content to the new position, and configuring the pre-vious position \nas a forwarder. In this implementation, we release the object lock as soon as possible, which requires \nus to temporarily set the fwd field to the value fwd; its role is to enqueue all incoming requests until \nthe mobile object has reached its new position. Mobile objects create chains of forwarding pointers as \nthey migrate. In order to make mobile objects independent of the sites they visited and to reduce the \ncost of remote method invocation, chains of forwarding pointers must be reduced [26]. We proceed lazily \nand update forwarders as they are used. The message UPDATE ensures that more recent positions only are \nstored in the fwd field. Using the following Lemma, one can guarantee that ev-ery message will eventually \nbe delivered, provided that the object does not migrate faster than message delivery. Lemma 10 (Mobility) \nUser messages are forwarded to-wards objects with a higher mobility counter. 0 Proof of Lemma 10 Each \nmobile object is associated with a fwd field and a mo- bility counter. We can see that they are always \nupdated at the same time (in MIGRATE and UPDATE). In both cases, the mobility counter is strictly increasing. \n0 Our migrat.ion facility is independent of the distributed garbage collector: the diffusion tree reorganisation \nmecha-nism is orthogonal to the short-cutting of forwarder chains. We believe that such a modular design \nfacilitates the under- standing and implementation of algorithms. There are many alternative designs \nto mobile objects. One could consider eager position updates, in-order message delivery or even causal \ndelivery. Choosing between them is application dependent. We believg that this argues in favour of a \nlibrary for mobility on top of a distributed garbage collector. 8 Discussion and Related Work Reference-counting \ngarbage collection was initially devel-oped for uniprocessor systems 143. It is extended to dis-tributed \nenvironments by introducing two types of messages. A decrement message is sent to GP s owner when GP \nis dis- carded; an increment message is sent to GP s owner when GP is duplicated. However, this ndive \nextension fails to be- have properly when messages are not causally ordered [14]. Numerous solutions \nto this problem have been proposed. The most famous are weighted reference counting [l, 31, 61 and its \noptimised version [5], or generational reference count-ing 191. However, Lermen and Maurer s [17, 291 \nsolution is closest to our work. They also rely on message ordering be-tween any pair of processors. \nWhen a GP is duplicated, a create message is sent to its owner. The owner then sends an acknowledgement \nto GP s receiver. When a GP is discarded a decrement message is sent only after the acknowledgement has \nbeen received for this pointer. Lermen and Maurer s technique also involves three sites (emitter, receiver, \nand owner), but it differs from ours: (i) The owner is involved every time the emitter duplicates a GP \nto the receiver in Lermen and Maurer s algorithm, whereas it is involved the first time in our algorithm. \n(ii) Lermen and Maurer s schema requires the receiver to maintain a count of both the number of copies \nmade and the number of acknowledge- ments received. Decrement messages can only be sent when both are \nequal. Indirect reference counting, initially defined by Piquer [22], consists of reference counters \ndistributed along the dif- fusion tree. It avoids the message conflict that exists in reference counting \nby using a decrement message only. In-direct reference counting creates zombie pointers [23]: these pointers \nare no longer used, but cannot be reclaimed because their associated counter is still positive as they \nare active in the children of the diffusion tree. Our algorithm reinstates a special increment-decrement \nmessage, which avoids race conditions, but is able to reorganise the diffusion tree, es-sentially deleting \nzombie pointers. The distributed variant of the Train GC [13] uses an algorithm to track pointers, which \nessentially is a reference counting mechanism. Like Birrel et al., the emitter always informs the owner \nof a pointer that a copy of the pointer is sent to another site. Reference listing 1241 is a variant \nof distributed reference counting. In this approach, send tables associate GPs with list of destination \nsites instead of a counter. Here, we discuss two variants by Birrel et al. [3] and Shapiro et al. [26, \n241. Birrel et al. [3] present network objects, a distributed object-based language with a garbage collector. \nThe owner of an object maintains a dirty set, which contains identi-fiers for all the processes that \nhave GPs to the object. When a client first receives a GP, it makes a dirty call to the owner. When the \nGP is no longer reachable, as determined by the client s local gc, the client makes a clean call and \ndeletes GP. With the dirty calls, Birrel et al. reinstate the equivalent of an increment message. In \norder to avoid conflicts between dirty and clean calls, an acknowledgement message from the receiver \nof a GP to its emitter guarantees the impossibility to free the pointer on the emitter. Similarly as \nLermen and Maurer s algorithm, Birrel s mechanism involves the object owner for every duplication of \na reference. Our mechanism is more flexible as, fully lazy, it behaves as indirect reference counting, \nand fully eager it behaves more like Birrel s; the only difference is that our acknowledgement is sent \nby the owner in the form of a decrement message and not by the recipient of the reference. Shapiro, Dickman, \nand PlainfossC 126, 241 present a fault- tolerant distributed garbage collector based on reference list-ing \nand supporting mobile objects. They introduce the no-tion of SSP chains. A chain starts its existence \nby a single SSP (Scion/Stub pair); it increases when sending the refer- ence of a local object, or when \nmigrating an object to some other site. In addition, they propose a technique to short-cut SSP-chains, \nhereby avoiding the equivalent of zombie references. Shapiro, Dickman, and Plainfoss&#38; 1261 and Pi-quer \n[23] regard migration as a primitive action that must be supported by their garbage collector. Our solution \nis to regard migration as a library functionality, which relies on our garbage collector for immobile \nobjects. Therefore, we have three different layers: reliable protocol provided by Nexus, distributed \ngarbage collection, and a library for mo-bile objects. JAVA Remote Method Invocation comes with a distri-buted \ngarbage collector [28]. It extends Birrel s reference listing technique with a new approach to fault \ntolerance, where remote pointers are leased for a period of time. Sites having pointer copies must regularly \nrenew their lease. Our approach can be extended without problem to reference list-ing so that send-tables \ncontain the sites to which GPs were sent, and a similar lease technique could also be adopted. The simplicity \nand portability of our solution is unfortu- nately counter-balanced by its inability to collect distributed \ncycles. As a result, it is the programmer s responsibility to avoid distributed cycles or to explicitly \nbreak them for col- lection [3]. Le Fessant, Piumarta, and Shapiro [16] present an extension to reference \ncounting based on timestamp, which is able to deal with distributed cycles. Lang, Quein-net, and Piquer \n[IS] are also able to collect cycles that are distributed over a group of sites. The distributed variant \nof the Train GC [13] is also able to collect cycles. It combines a reference-counting style pointer-tracking \nmechanism with a substitution protocol, in order to extend the train CC [12] to a distributed environment. \nAs such, it cannot be used in our context because it requires copying objects and we need to be conservative \nsince we interface with Nexus. However, an interesting question is to decide whether their tracking mechanism \ncould be based on our reference counting algo-rithm. 9 Conclusion We have presented a new distributed \ngarbage collection al-gorithm, which is an essential component of NeXeme, a dis- tributed implementation \nof Scheme. This algorithm uses a novel technique to short-cut diffusion trees, is able to deal with mobile \nobjects, and has a modular design. We are now adapting our implementation to the reference listing technique \nand are implementing a hierarchical domain or-ganisation, which would make it suitable to program the \nInternet.  10 Acknowledgement This research was supported in part by the Engineering and Physical Sciences \nH.esearch Council, grant GR/K30773. The Southampton DSSE seminar group, Hans Boehm, David DeR.oure, Ian \nFoster, Carl Hauser, Carl Kesselman, An-dress Kind, Christian Qucinnec, Manuel Serrano, and Steve Tuccke \ngave very useful comments and advice during the im- plementation of NeXemc and its garbage collector. \nThanks to the anonymous referees for their comments.  References [li David I. Bevan. Distributed Garbage \nCollection using Reference Counting. In PARLE Parallel Architectures and Lunguages Europe, volume 259 \nof Lecture Notes an Computer Science, pages 176-187. Springer-Verlag, June 1987. Krishna Bharat and Luca \nCardelli. Migratory appli- PI cations. In Mohrle Object Systems: Towards the Pro-grammable Internet, \npages 131-149. Springer-Verlag, April 1997. Lecture Notes in Computer Science No. 1222. Andrew Birrell, \nDavitl Evers, Greg Nelson, Susan Ow- icki, and Edward Wobber. Distributed Garbage Collec-tion for Network \nObjects. Technical Report 116, Digi- tal Systems Research Center, 130 Lytton Avenue, Palo Alto, CA 94301, \nDecember 1993. George E. Collins. A Method for Overlapping and Era- 14: sure of Lists. Conamunzcations \nof the ACM, 3(12):655- 657, December 19GO. Peter Dickman. Optimising Weighted Reference Counts for Scalable \nFault-Tolerant Distributed Object-Support fsystems. 1992. 15: lan Foster. A Multicomputer Garbage Collector \nfor a PI Single-Assignment Language. Intl J. of Pa.rallel Pro- gmmming, 18(3):181- 203, 1989. Ian Foster, \nCarl Kcsselman, and Steven Tuecke. The Nexus Approach to Integrating Multithreading and Communication. \nJournal of Parallel and Distributed Computing, 3 ?:70--82, 1996. 171 Ian T. Foster, David R. Kohr, Robert \nOlson, Steven PI Tuecke, and Ming Q. Xu. Point-to-Point Communica-tion Using Migrating Ports. In Languages, \nCompilers, and Run-twne S~ystrms for Scalable Computers, pages 199-2 12. Kluwer Academic Publishers, \n1995. PI Benjamin Goldberg. Generational Reference Counting: A Reduced-Communication Distributed Storage \nRecla-mation Scheme. In SIGPLA N Programming Language Design a,nd Implemnntation PLDI 89, pages 313-320, \n1989. [lo] H.-J.Boehm and M. Weiser. Garbage Collection in an Uncooperative Environment. Software --Practice \nand Experience, 18(9):807 ~820, 1988. Barry Hayes. Finalization in the Collector Interface. In 1111 \nProc. 1992 Interna~taonnl Workshop on Memory Man-agement, pages 277-298, Saint-Ma10 (France), Septem-ber \n1992. Springer-Verlag. Richard L. Hudson and J. Eliot B. Moss. Incremental collection of mature objects. \nIn Proc. 1992 Interna-tional Workshop on Memory Management, pages 388- 403, Saint-Malo (France), September \n1992. Springer-Verlag. 1121 R.L. Hudson, R. Morrison, J.E.B. Moss, and D.S. Munro. Garbage Collecting \nthe World: One Car at a Time. In Proceedings of OOPSLA 97, Atlanta, USA, 1997. 1131 Leslie Lamport. Time, \nClocks, and the Ordering of 114: Events in a Distributed System. Communications of thp ACM. 21(7):558-565, \nJuly 1978. Bernard Lang, Christian Queinnec, and Josh Piquer. Garbage Collecting the World. In Proceedings \nof the Nineteentll Annual ACM SIGACT-SIGPLAN Sympo-sium on Principles of Programming Languages, pages \n39--50, Albuquerque, New Mexico, January 1992. 115: Fabrice Le Fessant, Ian Piumarta, and Marc Shapiro. \nA  I161 Detection Algorithm for Distributed Cycles of Garbage. In OOPSLA 97 Garbage Collection and Memory \nManagement Workshop. http://wvw.dcs.gla.ac.nk/ whuw/oDpsla97/gc/papers. html, 1997. C.-W. Lermen and \nD. Maurer. A Protocol for Dis- II71 tribut.ed Reference Counting. In Lisp and Functional Programming, \npages 3433354, 1986. M General Magic. Telescript Technology: Mobile Agents. http://www.genmagic.com/ \nTelescript/Whitepapers/ wp4/whitepaper-4.htm1, 1996. Luc Moreau. A Distributed Garbage Collector with \nDif- PI fusion Tree Reorganisation and Object Mobility. Tech-nical Reporr M97/2, University of Southampton, \nOcto-ber 1997. PO1 Luc Moreau, David DeRoure, and Ian Foster. NeXeme: a Distributed Scheme Based on Nexus. \nIn Third Inter-national &#38;ropar Conference (EURO-PAR 97), volume 1300 of Lecture Notes in Computer \nScience, pages 581- 590, Passau, Germany, August 1997. Springer-Verlag. Luc Moreau and Christian Queinnec. \nDesign and Se- WI mantics of Quantum: a Language to Control Resource Consumption in Distributed Computing. \nIn Usenix Conference on Domain-Specijic Languages (DSL 97), pages 183-197, Santa-Barbara, California, \nOctober 1997. Jo&#38; M. Piquer. Indirect Reference Counting: A Dis- P-4 tributed Garbage Collection \nAlgorithm. In Parallel Ar-chitectures and Languages Europe (PARLE 91), pages 150-165, 1991. Jose hl. \nPiquer. Indirect Distributed Garbage Collec-tion: Handling Object Migration. ACM I?-ansactions 316 Progmmming \nLanguages and Systems, 18(5):615-1231 647. September 1996. David l- lainfosse and Marc Shapiro. A Survey \nof Dis- (241 tributed Garbage Collection Techniques. In Henry G. Baker, editor, International Workshop \non Memory Management (IWMM95), number 986 in Lecture Notes in Cornpurer Science, pages 211-249, Kinross, \nScotland, 1995. [25] Jonathan Rees and William Clinger. Revised4 Report on the Algorithmic Language \nScheme. Lisp Pointers, 4(3):1-55, July-September 1991. [26] Marc Shapiro, Peter Dickman, and David PIainfossC. \nSSP Chains: Robust, Distributed References Support-ing Acyclic Garbage Collection. Rapport de Recherche \n1799, INRIA-Rocquencourt, November 1992. Also available as Broadcast Technical Report #l. [27] .Jon Siegel. \nCORBA fundamentals and programming. Wiley, 1996. [28] Sun Microsystems. Java Remote Method Invocation \nSpecification, November 1996. [29] Gerard Tel and Friedemann Mattern. The Derivation of Distributed Termination \nDetection Algorithms from Garbage Collection Schemes. ACM Transactions on Programming Languages and Systems, \n15(1):1-35, Jan-uary 1993. [30] Thorsten von Eicken, David E. Culler, Seth Copen Goldstein, and Klaus \nErik Schauser. Active Messages: a Mechanism for Integrated Communication &#38; Compu- tation. In Proceedings \nof the 19th symposium on Com-puter Architecture, pages 256-266, 1992. [31] Paul Watson and Ian Watson. \nAn Efficient Garbage Collection Scheme for Parallel Computer Architectures. In PARLE Parallel Architectures \nand Languages Eu-rope, volume 259 of Lecture Notes in Computer Science, pages 432-443. Springer-Verlag, \nJune 1987. \n\t\t\t", "proc_id": "289423", "abstract": "We present a new distributed garbage collection algorithm that is able to reorganise diffusion trees and to support mobile objects. It has a modular design comprising three components: a reliable transport mechanism, a reference-counting based distributed garbage collector for non-mobile objects, and an extra layer that provides mobility. The algorithm is formalised by an abstract machine and is proved to be correct. The safety property ensures that an object may not be reclaimed as long as it is referred to locally or remotely. The liveness property guarantees that unreachable objects will eventually be reclaimed. The mobility property certifies that messages are always forwarded towards more recent mobile object positions.", "authors": [{"name": "Luc Moreau", "author_profile_id": "81100006426", "affiliation": "Department of Electronics and Computer Science, University of Southampton, Southampton SO17 1BJ UK", "person_id": "PP14015069", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/289423.289443", "year": "1998", "article_id": "289443", "conference": "ICFP", "title": "A distributed garbage collector with diffusion tree reorganisation and mobile objects", "url": "http://dl.acm.org/citation.cfm?id=289443"}