{"article_publication_date": "09-29-1998", "fulltext": "\n Automating Derivation of Incremental Programs * Yuchen Zhang Yanhong A. Liu Computer Science Department, \nIndiana University, Bloomington, IN 47405 { yuczhang, liu}@cs.indiana.edu Given a program f and an input \nchange operation @, an incremental program f computes the value of f(z @ y) effi- ciently by making use \nof the value of f(z). Liu and Teitel- baum proposed a systematic approach (11 for deriving incre-mental \nprograms written in a first order functional program-ming language. This work aims to automate the derivation \nof f from f and @ based on a semi-automatic implementa-tion -CACHET [2]. The derivation of incremental \nprogram shares the same underlying principle with finite differencing and a number of other program optimizations. \nIt is crucial for optimizing programs in high-level language. Derivation of incremental programs Liu \nand Teitelbaum s approach has three major compo-nents: simplification , replacement using cached results, \nand introduction of incremental functions. The derivation begins with f(z @ y). It examines subcomputations \nrecursively in applicative and left-to-right order and applies simplifications and replacements with \nretrievals from cached results. If a function application can t be replaced by a retrieval, then replace \nit with an incremental version: if it is an instance of an incremental version alreadyintroduced, then \nsimply re-place it; otherwise, introduce a corresponding incremental version for the unfolded application \nand recursively apply simplifications and replacements on the new function. Liu s semi-automatic implementation \nhas automatic rules for in- troducing incremental functions, local simplification and re- placement, \nbut the entire derivation needs manual invoca-tion of appropriate rules at each step.  Applicative-order \nrewrite Automation of CACHET continued to use the Synthe-sizer Generator 131. To automate the derivation, \nthere are three major challenges. First, sequencing the transforma-tion while mamtaining derived information \nat appropriate program points. Second, automating equality reasoning needed for local replacement. Third, \nensuring termination. We implemented three modules correeponding to the three major components of the \nderivation algorithm. A main module traverses a program in applicative order. To make the automated derivation \nefficient, transformation rules are grouped according to the program constructs they apply to so as to \nreduce rule mismatch. There are two kinds of equality reasoning: one for data constructions, the other \nfor arithmatic operation. For the first kind, equality reasoning is based on the relation be-tween a \nconstructor and its corresponding selectors. For the second kind, equality reasoning uses the simplification \nof arithmatic formula. For example, z + 1 - 1 = 2. Our This work is supported hy &#38; Motorola University \nPartnership in Research Grant sod NSF grant CCR -9711253. Yuchen Zhang is a student recipieot of Motorola \nUniversity Partnerships io Research Grant. general algorithm achieves this by grouping constants and \norganizing variables. We plan to switch to Omega [4] for the second kind of reasoning. Introducing new \nincremental function involving unfold-ing is the source of non-termination. We set a bound on the number \nof incremental versions that can be introduced for a function. Thus, the transformation terminates either \nwhen the derivation completes or such bounds are reached.  Applications Incremental computation has \napplications in optimizing compilers, transformational programming, interactive pro-grammin environments, \netc. The derivation described here allows onfy the use of the return value of f. However, when f is extended \nto return also additional information, our deriva-tion will yield a program that uses and maintains all \nsuch information. For example, given a binomial coefficient pro-gram that returns all the intermediate \nresults of function calls: bino(i, j) where 0 < j 5 i =ifj=Oorj=ithen <l> else let ul = bino(i -1, j \n-1) in let 7~2= bino(i -1,j) in < lst(u1) + lst(v2), ?Jl,a2 > For input change operation @: (i ,j ) = \n(i + 1, j), our auto-mated system produces the following incremental program, which can be used as the \nbody of a repeated computation that forms a dynamic programming solution. The speedup achieved is from \nexponential time to polynomial time. bino (i,j,r) =ifj=Oorj=i+lthen <l> else if j = i then let ul = bino \n(i -l,j -l,< 1 >) in < lst(v1) + l,ul, < 1 >> else let vl = bdno (i -1,j -1,2nd(r)) in let v2 = r in \n< lst(v1) + ld(zr2), ul, v2 > We have applied the system on a number of small exam-ples, including programs \nfor sorting, other list operations, and simple matrix computations. We translated both the original and \nincremental programs in our subject language to Scheme and compared the running times. The observed speedups \nconfirmed our asymptotic analysis. We plan to further modularize the system and improve the equality \nreasoning and other analyses used.  References [l] Yanhong A. Liu and Tim Teitelbaum. Systematic Deriva-tion \nof Incremental Programs. Science of Copmuter Pro-gramming, 24(1):1-39, Feb. 1995. [2] Yanhong A. Liu. \nCACHET: An Interactive, Incremental-Attribution-Based Program Transformation System for De- riving Incremental \nPrograms. In Proceedings of the 10th Knowledge-Based Software Engineering Conference. Novem-ber 1995. \nIEEE Computer Society Press. [3] William Pugh. The Omega Test: A fast and practi-cal integer programming \nalgorithm for dependence analysis. Communications of the ACM (CACM), 31(8), August 1992. [4] The Synthesizer \nGenerator Reference Manual, Release 5.0. GrammaTech, Inc. Ithaca, New York, 1996. 350 \n\t\t\t", "proc_id": "289423", "abstract": "", "authors": [{"name": "Yuchen Zhang", "author_profile_id": "81538722656", "affiliation": "Computer Science Department, Indiana University, Bloomington, IN", "person_id": "PP14055241", "email_address": "", "orcid_id": ""}, {"name": "Yanhong A. Lin", "author_profile_id": "81100224306", "affiliation": "Computer Science Department, Indiana University, Bloomington, IN", "person_id": "P304627", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/289423.289480", "year": "1998", "article_id": "289480", "conference": "ICFP", "title": "Automating derivation of incremental programs", "url": "http://dl.acm.org/citation.cfm?id=289480"}