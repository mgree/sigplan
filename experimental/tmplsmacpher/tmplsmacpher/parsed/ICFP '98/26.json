{"article_publication_date": "09-29-1998", "fulltext": "\n Encoding Types in ML-like Languages * Zhe Yang Department of Computer Science New York University 251 \nMercer Street, New York, NY 10012, USA E-mail: zheyangQcs .nyu. edu Abstract A Hindley-Milner type system \nsuch as ML s seems to pro-hibit type-indexed values, i.e., functions that map a family of types to a \nfamily of values. Such functions generally per-form case analysis on the input types and return values \nof possibly different types. The goal of our work is to demon- strate how to program with type-indexed \nvalues within a Hindley-Milner type system. Our first approach is to interpret an input type as its corresponding \nvalue, recursively. This solution is type-safe, in the sense that the ML type system statically prevents \nany mismatch between the input type and function arguments that depend on this type. Such specific type \ninterpretations, however, prevent us from combining different type-indexed values that share the same \ntype. To meet this objection, we focus on finding a value-independent type encoding that can be shared \nby different functions. We propose and compare two solu-tions. One requires first-class and higher-order \npolymor-phism, and, thus, is not implementable in the core language of ML, but it can be programmed using \nhigher-order func-tom in Standard ML of New Jersey. Its usage, however, is clumsy. The other approach \nuses embedding/projection functions. It appears to be more practical. We demonstrate the usefulness of \ntype-indexed values through examples including type-directed partial evaluation, C printf-like formatting, \nand subtype coercions. Finally, we discuss the tradeoffs between our approach and some other solutions \nbased on more expressive typing disciplines. Introduction Over the last two decades, the Hindley-Milner \ntype system [14, 201 has been widely used. For example, it underlies several major statically typed functional \nprogramming lan-guages, such as ML [21] and Haskell [24]. Among other *This research was partially supported \nby National Science Foun-dation grant CCR-9616993 and the Danish National Research Foun-dation. Part \nof this work was carried out during a visit to the BRICS PhD School at the University of Aarhus in the \nfall of 1997 and during a visit to DIKU. the Department of Computer Science at the Univer-sity of Copenhagen \nin January sod February 1998. reasons, this popularity can be attributed to static typing (which serves \nas a static debugging facility,) and implicit polymorphism allowed by the principal typing scheme (which \nremoves the burden of pervasive explicit type annotations). The simplicity of the type system, however, \nalso restricts the class of typeable programs. For example, one cannot exam-ine t.he type of a value \nat run-time, as in a dynamically typed language such as Scheme [4]. Functions that take type arguments \nand accordingly re-turn values of possibly different types are used frequently in abstract formulations \nof certain algorithms. Such functions form an interesting class of programs that seem to be for- bidden \nby the Hindley-Milner type system. In this article, we formulate such a function as a type-indered value, \nview-ing it as a value indexed by one or more type(s). Figure 1 illustrates a type-indexed value v indexed \nby one type ar-gument: given a type r, the corresponding value is V~ of type T,. Usually, the family \nof types r is inductively spec-ified using a set of type constructors. Consequently, the type-indexed \nvalue v is naturally defined by case analysis on the type constructions. Since all types are implicit \nin a language with Hindley-Milner type system, one can only hope to use type encodings instead of types \nas the argu-ments of au ML function fv that represents a type-indexed value v. We can reduce case analysis \non type constructions to case analysis on value constructions, by encoding type arguments using a datatype. \nThis, however, does not solve the problem, because different branches of the case analysis might have \ndifferent types, and hence may not be typeable. A common strategy in such cases is to have tagged inputs \nand outputs of some user-defined datatype. However, this requires users to tag input values themselves, \nwhich is not only inconvenient and even unreasonable for cases when ver-batim values are required, but \nalso type-unsafe in the sense that a run-time exception might be raised due to unmatched tags. This problem \nhas exposed the limitations of the Hindley- Milner type system and has motivated a lot of research exploring \nmore expressive type systems. This article in-vestigates what can be done within the framework of the \nHindley-Milner type system; in particular, we demonstrate our methods with ML, though the techniques \nare equally ap-plicable to any other language based on the Hindley-Milner type system. We show how interpreting \ntypes T using corre-sponding values vr gives a type-safe solution to the problem. Based on our approach \nto type encodings, examples ranging from a printf-like formatting function to type-directed par- Initially \ndevised by Olivier Danvy [6] 2 Type-Indexed Values A family of types T Corresponding values V, : T, \nA type-indexed value u is a function mapping a family of types T to a family of values ur of types Tr. \nFigure 1: A type-indexed value I- tial evaluation can be programmed in ML successfully. As for their \ntype safety, it is automatically ensured by the ML type system, statically. The above type encoding is \nvalue-dependent. It is not suitable in modular programming practice when different type-indexed values \nsharing the same family of type indices need to be programmed separately and combined later. It is thus \ninteresting to find a method of type encoding that is independent of any particular type-indexed value. \nA value- independent encoding of a specific type can be combined with the specification of a type-indexed \nvalue (which itself has a fixed type) to deliver the value at this type index. We present two methods \nof creating such a value-independent type encoding: 1. A type-indexed value is specified as a tuple of \nvalue con-structions for all possible type constructors, and the en- coding of a specific type recursively \nselects and applies components from the tuple. This gives rise to a Martin- Lijf-style encoding of inductive \ntypes. The encoding uses first-class polymorphism and higher-order poly-morphism, and can be implemented \nusing the higher-order module language of Standard ML of New Jersey [31. 2. A type is encoded as the \nembedding and projection functions between verbatim values of that type and tagged values of a universal \ndatatype. To encode a specific value vT of a type-indexed value v, we can first define its equivalent \nvalue, replacing types r by the corresponding datatypes, and then coerce it to the spe- cific value of \nthe indexed type. We show that this type encoding is universal, i.e., the coercion function can always \nbe constructed from the embedding and projec- tion functions of the indexed types. In Section 2, we \nformalize the notion of type-indexed val-ues, give examples, and discuss why it is difficult to program \nwith them. In Section 3, with an understanding of type encodings as type interpretations, we characterize \nrequire-ments for correct implementations of type-indexed values, and give an ad hoc approach to programming \ntype-indexed values in ML. In Section 4, we present two approaches to value-independent type encodings, \nnamely 1 and 2 above. We discuss related work in Section 5 and conclude in Sec- tion 6. Type-indexed \nvalues are used in the formulation of algo-rithms in a type-indexed (or type-directed) fashion. De-pending \non input type arguments, specific values could have different types. For brevity, we mainly consider \nprograms indexed by only one type argument. Multiple type argu-ments can be dealt with by bundling all \ntype indices into one type index. This technique, however, could lead to code explosion. We will come \nback to a practical treatment for dealing with multiple type arguments in section 4.4. A type-indexed \nvalue is defined by vT = e where expression e is a case expression whose value depends on the form of \ntype T, and is defined using the values indexed at the component types of type r. The family of types \n7 is inductively constructed in the following form: = Cl(Tll, . . . . mnl) r / . . . (1) Cn(Tn1, . . \n. . Tnnm,) where ci s are type constructors, representing a type con-struction in the underlying language \n(ML in our case), which builds type r using component types Til through Timi. With-out loss of generality, \nwe assume that the case-analysis in expression e occurs at the outer-most level, which enables us to \nrewrite the specification of the type-indexed value v in the following pattern-matching form: %(rll~....rlml) \n= el(vTll, . . . . vrlml 1 (2) vCn(Tnlr...,mm, 1 = enhI, .-, vTnmn 1 2.1 Running examples We use the \nfollowing two running examples to demonstrate the challenges posed by type-indexed values, anal later \nto illustrate our methods for programming with them. 2.1.1 List flattening The flatten program, which \nflattens arbitrary nested lists with integer elements, is a toy example often used to il-lustrate the \nintricacy of typing typecase (case study on types) in languages with Hindley-Milner type systems, and \nto motivate the use of datatypes. It can be written in an un- typed language like Scheme (where type \ntesting is allowed) as: flatten x = [x] (where 2 is atomic) flatten [zl,...,xn] = (flatten XI)@. ..Q(flatten \n2,) where 0 is the list concatenation operator. To write this function in ML, a natural solution is \nto use the ML datatype mechanism to define a list datatype, and use pattern matching facilities for case \nanalysis. However, this requires a user to tag all the values, making it somewhat inconve-nient to use. \nIs it possible to use verbatim values directly as the arguments? The term verbatim values refers to values \nwhose types are formed using only native ML type construc-tors, and are hence free of user-defined value \nconstructors. Due to restrictions of the ML type system, a verbatim value of nested list type must be \nhomogeneous, i.e., all mem- bers of the list must have the same type (in the case that members are lists \nthemselves, they must have the same nest- ing depth). Possible types r of the argument of function flatten \nform the family Fintt ast of types generated by the following grammar. r = int 1 7 list The type-indexed \nfunction flatten is specified as: flatten : hr E Fint,list.7 -4 int list flatten ,nt x = [x] flatten, \nI,~,(xI, . . . . xn] = (flatten, XI) + + (flatten, x,) Before trying to write the function flatten, \nlet us analyze how it might be used. A first attempt is to make the input value (of some arbitrary homogeneous \nnested list type) be the only argument. This requires that both expression flatten 5 and expression flatten \n[61 type-check, so the function argument should be polymorphic and should generalize both type int and \ntype int list, which must be a type variable o. But ML s parametric polymorphism disallows looking into \nthe type structure of a polymorphic value. Consequently it is impossible to write function flatten with \nthe value to be flat- tened as the only argument. The next attempt is to have an extra argument describ-ing \nthe input type, i.e., a value that encodes the type. We expect to rewrite the aforementioned function \ninvocations as flatten Int 5 and flatten (List Int) [Sl, respectively. One might try to encode the type \nusing a datatype as: datatype TypeExp = Int 1 List of Type&#38;p The fixed type Typetip of the type \nencoding, however, also makes the result of applying function flatten to the type en-coding have a fixed \nML type. As before, a simple argument shows that it is impossible to give a typeable solution in ML. \n 2.1.2 Type-directed partial evaluation Type-directed partial evaluation, a surprisingly concise al-ternative \nto the traditional syntax-directed partial evalua-tion, offers a much more interesting and practical \nexample of type-indexed values. In its simplest form, Danvy s type-directed partial evaluation (TDPE) \nis formulated in Fig-ure 2. Here, we consider the family F* ,  of types r generated inductively by the \nfollowing grammar. r = base 1 TI -+ ~2 The two functions 4 (reify) and t (reflect) are type-indexed, \nrecursively calling each other for the contravariant function argument. At first glance, their definitions \ndo not fit into our canonical form of type-indexed values; however, pairing the two functions at each \ntype index puts the definition into the standard form of a type-indexed value (Figure 3). In his article \n[5], Danvy presents the Scheme code for this algorithm, where the type index is encoded as a value, thus \nreducing type analysis to case analysis. However, a di- rect transcription of that program into an ML \nprogram that requires its input arguments being tagged is not satisfactory for the following reasons: \nIt is only for brevity that we use int as the base type: instead of a universally quantified type variable. \n(reify) Jbase v = 21 -1Tl-+TZ w = AXl. 4 (vQ(tq 21)) (where xi is a fresh variable) (reflect) t base \ne = e t rl-+r2 e = Xw. tra (eQ(J VI )) Figure 2: Type-directed partial evaluation (J.,?) : Ar E Fbase+ \nc.(~ --t Exp) x (Exp + 7) (4, ?)base = (xV.V, Xe.e) CL t) Tl -+TZ = let (JT1y?T1) = (J,T)T1 (JTZ,TT2) \n= (L?)rz in (Xv.Ax,. -1 (wQ(?~~ a)), Xe.Xwl. trz (eQ(S wl))) (where xi is a fresh variable) Figure 3: \nTDPE in the general form of type-indexed values l Using type-directed partial evaluation, we expect to \nnormalize a program in the source language and get the corresponding text. It is cumbersome for the user \nto tag/untag all the program constructs, so a verbatim program is much preferable in this case. l Unlike \nthe case of function flatten, here the type argu-ment must be explicit. The type index r only appears \nas the codomain of the function t (reflect), whereas its domain is always of type Exp. For the same input \nex-pression, varying the type argument results in different return values. Since explicit type arguments \nmust be present, the con- sistency of the type argument and the real tags of the input values cannot \nbe guaranteed by static type check-ing of ML, and run-time type error can arise in the form of pattern-mismatching \nexception. This problem is also present in the Scheme program. 3 Type-Indexed Values as Type Interpretations \nOur first approach to programming type-indexed values v is based on interpreting specific types r in \nthe program as the values IJ~ indexed by these types. As we argued in the list flattening example (sec-tion \n2.1. l), if verbatim arguments are required for an ML function representing a type-indexed value, a type \nencoding must be explicitly provided as an argument to the function, but this type encoding cannot have \na fixed type. Now that the type encoding E, itself must have different types, a rea- sonable choice of \nthese types should make them reflect the types r being encoded. For each type construction c that constructs \na type r from types 71, . . . , r,, its program en-coding EC is a function that transforms the type encodings \nE Tl, , E,, to the type encoding E,. In other words, the encodings of inductively constructed types form \na particu- lar interpretation of the types in value domains; if we use [uj instead of E, to denote the \ninterpretation, we can write down the requirements for the encodings: datatype Exp = VAR of string I \nLAM of string * Exp 1 APP of Exp * Exp This can be understood as requiring the interpretations of type \nand type constructors to form a homomorphism, i.e., [c(n). . . , Tm)ll = [cn(unn,~~~, bmnzli) (3) A \nfunction fv that represents a type-indexed value u using the above encoding should satisfy wT = fv[7j \n(4) for all types 7 in family F. Equations (3) and (4) precisely characterize program encodings of type-indexed \nvalues. Definition 1 The encodings [ci] of type constructors ci, along with function fV, are said to \nimplement type-indexed value v, if and only if they satisfy equations (9) and (4). The task of finding \nthe type encodings now boils down to finding interpretations for the type constructors ci. Ob-serving \nthe similarities of the general form of type-indexed values in the set of equations given by (2) and \nthe interpre- tation of type constructors in Equation (3), it is not difficult to imagine the following \napproach to programming a type- indexed value: we interpret a type r as the corresponding value 21,, \nand interpret the type construction ci using the value construction ei in the set of equations given \nby (Z), i.e.: [Tn = vr [Ci] = ei Using the set of equations given by (2), it follows immedi-ately that \nthis interpretation satisfies equation (3). With this type encoding, the function that maps type encodings \nto the values is simply the identity function: mn = bn Theorem 1 A given type-indexed value u is implemented \nby interpretations [ci] = ei of type constructors and function fv = Xx.x. 3.1 Examples The definition \nof function flatten gives rise to the following interpretations of type constructions: 1.1 : AT E Fint,iist.~ \n+ int list [int] = XX.[X] [CY list] = x(x1,. . . , x,].[ajx1c3.. @[a]~, A direct coding of these interpretations \nof type construction into ML functions gives the following program: val Int = fn x => [xl fun List T \n= fn 1 => foldr (op Q) [I (map T 1) fun flatten T 1 = T 1  Since we choose the ML function names to \nbe the type con-structions they interpret, a type argument List (List Int) already has the value of [(int \nlist) list] = flatten(i,, list) list) and function flatten is defined as the identity function. The \nfunction deals with verbatim values, e.g., expression infixr 5 --> val Base = (fn v => v, fn e => e) \n fun (Tl as (reify-l, reflect-l)) --> (T2 as (reify-2, reflect-2)) = let fun reify v = let val xl = \nGensym.fresh \"x\" in LAM(x1, reify-2 (v (reflect-1 (VAR xl)))) end fun reflect e = fn vl => reflect-2 \n(APP(e, reify-l(vl))) in (reify, reflect) end fun reify (T as (reify-T, reflect-T)) v = reify-T v Figure \n4: Type-directed partial evaluation in ML flatten (List (List Int.)) [Cl, 21, [I, CSI, C4, 611 evaluates \nto [1,2.3,4.61. We apply the same method to program type-directed partial evaluation (Figure 4) using \nthe type interpretation [rj = (J,t)r defined in Figure 3. As an example, the expression reify (Base --> \nBase) ((fn x => fn y => x y) (fn x => x) (fn x => x)) evaluates to a first-order representation of Xz.x \nsuch as LAM (\"xF,VAR \"x7\"). 3.2 Assessment of the approach A type encoding in the above approach is essentially \nthe type-indexed value specialized to the particular type index. There are several advantages to this \napproach: l Type safety is automatically ensured by the ML type system: case-analysis on types, though \nit appears in the formulation, does not really occur; the encoding and also the value IT] = uT of a particular \ntype index 7 already has the required type T,. If the value IT] is a function, taking some argument whose \ntype depends on type 7, then the specific type of this argument will be manifested in the type T,. Hence, \ninput arguments of illegal types would be rejected. For example, the expression reify (Base --> Base) \n(fn x => fn y => x) will cause a type error in ML, because expression reify (Base --> Base) has the domain \ntype C&#38;p -> Exp), which does not match type scheme k.A,&#38;(cu + (p -+ CX)). If we use the expression \nreify (Base --> Base --> Base) instead, whose domain is of the type (Exp -> F&#38;p -> Exp), then the \nwhole expression type-checks and it evaluates to a textual representa-tion of Xx.Xy.x like LAM (\"x7\".LAM \n(\"x8\",VAR \"x7\")). super-reverse 0-e flatten flatten I I OreverSe. Figure 5: Composing functions super-reverse \nand flatten In some other approaches that do not make the type ar-gument explicit (e.g., using classes \nof an object-oriented language), one would need to perform case-analysis on tagged values (including \ndynamic dispatching), which would require the type index to appear at the input position. In our approach, \nhowever, the type index r could appear at any arbitrary position in type T,. But this simple solution \nhas a major drawback: the loss of composability. One should be able to decompose the task of writing \na large type-indexed function into writing several smaller type-indexed functions and then combining \nthem. This would require that the encoding of a type be sharable by these different functions, each of \nwhich uses the encoding to get a specific value. However, the above simple solution of interpreting every \ntype directly as the specific value would result in each type-indexed function having a different set \nof interpretations of type constructors, thereby disallowing sharing of the type encodings. Consider \nthe following toy example: on the family F rnt, Jt of types, we define yet another type-indexed func-tion \nsuper-reverse, which recursively reverses a list at each level. The function is defined through the following \ntype interpretation: I.1 : AT E FintJist.T --f ?- J:,:] z $ 21,. . . , Zn].[[+n,~. . ) [cy]IZl] which \nis implemented in ML as, fun Int x = x fun List T = rev o (map T) fun super-reverse T 1 = T 1 Each of \nfunction flatten and function super-reverse can be used separately, but we cannot use an expression such \nas fn T => (flatten T) o (super-reverse T) to combine them. We cannot reverse a list recursively and \nthen flatten the result, because the functions Int and List are defined differently in the two programs. \n(Notice that the effect of composing function super-reverse and function flatten amounts to reversing \nthe flattened form of the original list (Figure 5).) This problem can be evaded in a non-modular fashion, \nif we know in advance all possible type-indexed values v, v . . . indexed by the same family of types, \nby tupling all the val- ues together as the type interpretation. Every function fiti simply projects \nthe appropriate component from the type interpretation. Our previous program of type-directed par-tial \nevaluation (Figure 4) illustrates such a tupling. 3.3 Other applications of the approach Sometimes, \nthe types of certain function arguments are de-termined by other arguments which embody related type \ninformation. In these cases, extra type arguments are re-dundant, and it is sufficient to interpret the \narguments de-termining types. As an example, a C printf-style formatting function spec-ifies the type \nof its arguments through its formatting spec-ification, which is a sequence of field specifiers, represented \nhere as a list. The (simplified) grammar of a formatting specification is given below: Spec ::= NIL 1 \nField :: spec Field ::= LIT s 1 % r where s is a string literal and % r specifies an input field argument \nof type 7. We want to write a function format such that, for instance, the expression format ( /, Str \n++ LIT is ++ % Int ++ LIT -year old. ) Mickey 80  evaluates to the string Mickey is SO-year old. I. \nOur function is indexed by a formatting specification fs. A specialized formatfs has type TI -+ TZ . \n. . + TV --t string, where T~ S are from all the field specifiers X G in the spec- ification fs in the \norder of their appearance. We make use of an auxiliary function format , which introduces one extra argument \nb as a string buffer; the function will append its output to the end of this input string buffer to get \nthe output string. The functions format and format can be formulated as follows. format;, : string -+ \nT(fs) where T(NIL) = string I (LIT s :: fs) = T(fs) T(% -r:: fs) = 7 + T(fs) format;&#38; = b formath \ns::fs b = format&#38;(b^s) format ,, TzzfSb = X(z : T).format>,(b^toStr,z) formatf, : Tcfs) formatf, \n= format;, ( ) In these declarations, each function toStr, : 7 -+ string con-verts a value of type \nT to its string representation. Since format is inductively defined over the formatting specifica-tion, \nwe can make it the interpretation of the formatting specification. Each individual field specification \nf can be viewed as a constructor for formatting specifications, simi-lar to the type constructors in \nthe previous section. There-fore [f] should be a transformer from us] = format;, to [f :: fs] = format;,,f,, \ni.e., format;::f, = [f] format>, It is now easy to give the interpretation of different individ-ual \nfield specifiers: [LIT s] = Xformat;,.Xb.format&#38;(b^s) [o/o Tj = 1751 toStr, = Xformat&#38;.Xb.X(z \n: 7).format&#38;(b^toStr,r)  To complete the construction, we define a function ++ to compose such transformers \n(similar to the function append for lists), and we can define a function format, which supplies the interpretation \nof the empty field specification [NIL] = format;,, to a transformer, along with an empty string as the \ninitial buffer. Let us move directly to the ML code: infix 5 ++ fun LIT s p = fn b => p (b ^ s) fun % \ntoStr_t p = fn b => fn x => p (b ^ toStr_t x) fun fl ++ f2 = fl 0 f2 fun format fs = fs (fn b => b) UU \nfun Int n = Int.toString n fun Str s = s Unlike the C printf function, the above ML implemen- tation \nis type-safe; for example, the type of the expression format (% Int ++ LIT \": \" ++ % Str) is int + string \n-+ string, thus ensuring that exactly two arguments, one of type int, the other of type string, can be \nsupplied. The power of a higher-order functional language with static typing like ML also enables the \nconstruction of field specifiers for different types: for the type-indexed function toStr, we can use \nthe standard type interpretation method to allow type constructions such as product types and list types. \nfun Pair toStr1 toStr2 = fn (xl, x2) =) #,(U ^ (toStr1 xi) ^ II, II ^ (toStr2 x2) ^ U)ll fun List toStr \n1 = let fun mkTai1 [] = \"1 II I mkTai1 [el = (toStr e) ^ \"1\" 1 r&#38;Tail (e :: el) = (toStr e) ^ I, \n ^ (r&#38;Tail el) in I 1 ^ (mkTai1 1) end This enables us to construct field specifiers for compound \ntypes. The following example illustrates its usage: format (%(List (Pair Str (List Str)))) [(\"N\", [\"Prince\", \n\"8\". \"14\"]), (\"P\", [\"Newport . \"Christopher\", \"9\"])] It should be clear that for any given type T, we \ncan have different functions to translate a value of type 7 to its string representation. It is easy \nto define a more complicated field specifier which determines formatting issues such as choos- ing various \npaddings or parameterizing the constructors of compound types over delimiters--i. e., a pretty-printer. \nDanvy observed that such an implementation of format out-performs the library version of formatting functions \npro-vided with SML/NJ and Objective Caml, without even ap-plying partial evaluation to remove interpretive \noverhead [6]. Intuitively, the efficiency comes from the elimination of case- analysis by using function \ndispatching instead, which is similar to the practice of eliminating conditionals by hard- wiring data \ninto code, or using jump-tables in machine lan-guage. Danvy also makes an interesting comparison of the \ntype- indexed formatting function and the two formatting library functions of SML/NJ and of OCaml. In \nSML/NJ, the user is required to embed all arguments into a universal datatype and to collect the result \nin a list. Any mistake in the embed- ding or in the size of the list results in a run-time error. In \nOCaml, the formatting function is itself type-unsafe. Apply-ing it to a formatting specification, however, \nyields a type- safe curried function that can be used on untagged values. Programming a formatting function \nas a type-indexed value yields the same effect as in OCaml (convenience and verba- tim values), but with \nthe added benefit that the formatting function itself can be statically type-checked in ML. 4 Value-Independent \nType Encoding In this section, we further develop two approaches to en-code types independent of the \ntype-indexed values defined on them, i.e., we should be able to define the encodings [T] of a family \nF of types 7, so that given any value w indexed by this family of types, a function fv that satisfies \nequation (4) can be constructed. In contrast to the solution in the previ- ous section, which interprets \ntypes 7 using values wT directly and is value-dependent, a value-independent type encoding enables different \ntype-indexed values TJ, v , . to share a fam- ily of type encodings, resulting in more modular programs \nusing type-indexed values. We present the following two approaches to value-independent type encoding: \nl as an abstraction of the formulation of a type-indexed value, and 0 as a universal interpretation of \ntypes as tuples of em- bedding and projection functions between verbatim values and tagged values. 4.1 \nAbstracting type encodings If the type encoding is value-independent, the function fv representing type-indexed \nvalue v should carry the infor-mation of the value constructions ei in a specification in the form of \nthe set of equations given in (2). This naturally leads to the following approach to type encoding: a \ntype-indexed value PI is specified as an n-ary tuple Z= (el, . , e,) of the value constructions, and \nthe value-independent type inter-pretation IT] maps this specification to the specific value VT. [+ = \nvT (5) With Equation (3), we require the encoding of type con-structors ci to satisfy   [cin([7.1n,. \n. . , Ihn)t  = [Ci(h , . . . ,4nz by (3) = Q;(q,...,r,) By this derivation, we have Theorem 2 The value-independent \nencodings of type con-structors Icin = xcxl,. . . ,x,).~z.ei(xlz,. . . ,xmq and the function f+,(x) = \nx(el, . . . , e,) implement the corre-sponding type-indexed value v. This approach seems to be readily \nusable as the basis of programming type-indexed values in ML. However, the restriction of ML type system \nthat universal quantifiers on type variables must appear at the top level again makes this approach infeasible. \nFor example, let us try to encode types in the family Fbare*finc, and use them to program type-directed \npartial evaluation in ML (Figure 6). val Base = fn (base-v, func-v) => base-v fun Tl --> T2 = fn (spec-v \nas (base-v, func-v)) => func-v (Tl spec-v) (T2 spec-v) fun reify T = let val (reify-T, -) = T ((fn v \n=> v, fn e => e), (* base-v *) (* func-v *) fn (reify_Tl, reflect_Tl) => fn (reify-T2, reflect-T21 => \n. . . (* (reify-T, reflect-T) *) 1 in reify-T end ?igure 6: An unsuccessful encoding of Fbaselfunc and \nTDPE The definition of reify and reflect at higher types is as before and omitted here for brevity. \nThis program will not work, because the X-bound variable spec-v can only be used monomorphically in the \nfunction body. This forces all uses of func-v to have the same monotype; as an example, the type encoding \nBase --> (Base --> Base) causes a type error, because the two uses of variable func-v (one being applied, \nthe other being passed to lower type interpretations) have different monotypes. Indeed, the type of the \nargument of reify, a type en-coding [T]I constructed using Base and -->, is somewhat in-volved: [T] : \nRobj : * -+ *. Abase-type : *. (base-type obj x (* base-v *) (Act : *,p : *.(a obj) + (,d obj) -+ (* \nfunc-v *) ((0 -+ PI obj))) + r obj Here, the type constructor obj constructs the type T, of the specific \nvalue v, from a type index r, and the type base-type gives the base type index. What we need here is \nfirst-class polymorphism, which allows nested quantified types, as used in the type of argument func-v. \nSubstantial work has been done in this direction, such as allowing selective annotations of X-bound variables \nwith polymorphic types [23] or pack-aging of these variables using polymorphic datatype com-ponents [16]. \nMoreover, higher-order polymorphism [15] is needed to allow parameterizing over a type constructor, e.g., \nthe type constructor obj. In fact, such type encodings are similar to a Martin-LCf- style encoding of \ninductive types using the corresponding elimination rules in System F,, which does support both first-class \npolymorphism and higher-order polymorphism in an explicit form [lo, 251. 4.2 Explicit first-class and \nhigher-order polymor-phism in SML/NJ The module system of Standard ML provides an explicit form of first-class \npolymorphism and higher-order polymor-phism. Quantifying over a type or a type constructor is done by \nspecifying the type or type constructor in a signature, and parameterizing functors with this signature. \nTo recast the higher-order functions in Figure 6 into functors, we also need to use higher-order functors \nwhich allows functors to have functor arguments or results. Such higher-order func-tars [31] are supported \nby Standard ML of New Jersey [3]. Below we give a program for type-directed partial evaluation using \nhigher-order functors. signature SpecValue = sig type 'a obj type my-type val v: my-type obj end signature \nIndValue = sig type 'a obj type base-type val Base : base-type obj val Arrow: 'a obj -> 'b obj -> ('a \n-> 'b) obj end signature Type = sig fun&#38;or F(Obj: IndValue): SpecValue where type 'a obj = 'a Obj.obj \nend structure Base: Type = struct fun&#38;or F(Obj: IndValua): SpecValue = struct We 'a obj = 'a Obj.obj \ntype my-type = Obj.base-type val v = Obj.Base end end functor Arrov(T1: Type) (T2: Type): Type = struct \nfun&#38;or F(Obj: IndValue): SpecValue = struct type 'a obj = 'a Obj.obj structure v-T1 = Tl.F(Obj) \nstructure v-T2 = T2.FCObj) we my-we = v-Tl.my-type -> v-T2.myJype val v = Obj.Arrow v-Ti.v v-T2.v end \nend structure reify-reflect: IndValue = struct type 'a obj = ('a -> Exp) * (Exp -> 'a) type base-type \n= Exp val Base = (fn v => v, fn v => v) fun Arrou (reify-l, reflect-l) (reify-2. reflect-2) = . . . end \n Here, a Type encoding is a fun&#38;or from a structure with signature IndValue, which is a specification \nof type-indexed values, to a structure with signature Specvalue, which de-notes a value of the specific \ntype. The type my-type gives the particular type index T, and the type base-type and the type constructor \nobj are as described in the last section. It is however cumbersome and time-consuming to use such functor-based \nencodings. The following example illus-trates how to partially evaluate (residualize) the function Xx.x \nwith type (base --t base) -+ (base -+ base). local structure T = Arrou(Arrov(Base)(Base)) (Arrov(Base) \n(Base) 1 structure V-T = T.F(reify-reflect) in val result = tl(v-T.v) (fn x => x) end  Furthermore, \nsince ML functions cannot take functors as arguments, we must define functors to use such functor-encoded \ntype arguments. Therefore, even though this ap-proach is conceptually simple and gives clean, type-safe \nand value-independent type encodings, it is not very practical for programming in ML. 4.3 Embedding/projection \nfunctions as type inter-pretation The alternative approach to value-independent type encod-ings is (maybe \nsomewhat surprisingly) based on program-ming with tagged values of user-defined universal datatypes. \nBefore describing this approach, let us look at how tagged values are often used to program functions \nwith type argu-ments. First of all, for a type-indexed value v whose type index r appears at the position \nof input arguments, the tags at-tached to the input arguments are enough to guide the com-putation. For \nexamples, the tagged-value version of func- tions flatten and superzeverse is as follows: datatype tagIntList \n= INT of int 1 LST of tagIntList list fun flattenTg (INT x) = Cxl 1 flattenTg (LST 1) = foldr Cop 0) \n[I (map (fn x => flattenTg x1 1) fun super_reverseTg (INT v) = INT v I super_reverseTg (LST 1) = LST \n(rev (map super_reverseTg 1)) In more general cases, if the type index T can appear at any position \nof the type T, of specific values vr, then a description of type 7 using a datatype must be provided \nas a function argument.. However, this approach suffers from several drawbacks: 1. Verbatim values cannot \nbe directly used. 2. If an explicit encoding of a type r is provided, one can- not ensure at compile \ntime its consistency with other in-put arguments whose types depend on type r; in other words, run-time \ntype-errors can happen due to un-matched tags.  Can we avoid these problems while still using universal \ndatatypes? To solve the first problem, we want the program to automatically tag a verbatim value according \nto the type argument. To solve the second problem, if all tagged values are generated from verbatim values \nunder the guidance of type arguments, then they are guaranteed to conform to the type encoding, and run-time \ntype-errors can be avoided. The automatic tagging process that embeds values of various types into values \nof a universal datatype is called an embedding function. Its inverse process, which removes tags and \nreturns values of various types, is called a projec- tion function. Interestingly, these functions are \ntype-indexed themselves, thus they can be programmed using the ad hoc method described in Section 3. \nUsing the embedding func-tion and projection function of a type r as its encoding gives another value-independent \ntype encoding method for type- indexed values. For each family T of types T inductively defined in the \nform of equation (l), we first define a datatype U of tagged values, as well as a datatype typeExp (type \nexpression) to represent the type structure. Next, we use the following interpretation as the type encoding: \n,;;I = pzbE; v-d,, tE,). (embeddlng function) (6) proj: : u--+7. (projection function) tE, : typeExp \n(type expression) Finally, we use the embedding and projection functions as basic coercions to convert \na value based on a universal datatype to type T, corresponding to the type index r. The important question \nthat remains is how we can de-fine the embedding/projection function pair of a type r in terms of those \nof its component types G. In general, for a covariant component type Ti, emb, and proj, should be defined \nin terms of emb,, and projri, respectively; for a contravariant component type Ti, emb, and proj, should \nbe defined in terms of proJ, and embl-, , respectively. More in-volved cases of embedding and projection \nfunctions between special types and universal tagged datatypes are studied in detail in [13]. 4.3.1 Examples \nTaking the family F nt,hst of types, we can encode the type constructors as: datatype typeExpL = tint \n1 tLst of typeExpL val Int = (fn x => INT x, fn (INT x) => x, tint) fun List (T as (emb_T, proj-l, tE_T)) \n= (fn 1 => LST (map emb_T 11, fn LST 1 => map proj_T 1, tLst tE_T) and then the functions flatten and \nsuperleverse are defined as fun flatten (T as (emb, _, -1) v = flattenTg (emb v) fun super-reverse CT \nas (emb, proj, -1) v = praj (super_reverseTg (emb v)) Now that the type encoding is neutral to different \ntype-indexed values, they can be combined, sharing the same type argument. For example, the function \nfn T => (flatten T) o (super-reverse T) defines a type-indexed function that composes flatten and super-reverse. \nThe other component of the interpretation, the type ex-pression tE is used for those functions where \nthe type indices do not appear at the input argument positions, such as the reflect funct,ion. In these \ncases, a tagged-value version of the type-indexed value must perform case analysis on the type expression \ntE. As an example, the code of type-directed partial evaluation using this new type interpretation is \npre- sented below. datatype 'base tagBaseFunc = BASE of 'base I FUNC of ('base tagBaseFunc) -> ('base \ntagBaseFunc) datatype typeExpF = tBASE I tFUNC of typeExpF * typeExpF val Base = (fn x => (BASE x1. fn \n(BASE x1 =1 x, tBASE) fun ((Tl as (I-Tl, P-Tl, tE1)) --> (T2 as (I-T2, P-T2, tE2))) = (fn f => FUNC (fn \ntag-x => I-T2 (f (P-T1 tag-x))), fn FUNC f => (fn x => P-T2 (f (I-T1 x))), tFUNC(tEl,tES)) val ret reifyTg \n= fn (tBASE, BASE v) => v I (tFUNC(tEl,tE2), FUNC v) => let val xl s Censym.fresh \"x\" in LAM(x1, reifyTg \n(tE2, v (reflectTg (tE1, (VAR xl))))) end and reflectTg = fn (tBASE, e) => BASE(e) I (tFUNC(tEl.tEP), \ne) => FUNC(fn vl => reflectTg (tE2, APP (e, reifyTg (tE1, ~1)))) fun reify (T as (emb, _, tE)) v = rsifyTg(tE, \nemb v) Recall that the definition of functions reifyTg and reflectTg will cause matching-inexhaustive \ncompilation warnings, and invoking them might cause run-time exceptions. Function reify is safe, however, \nin the sense that if the argument v type-checks with the domain type of the embedding function emb, then, \nthe resulting tagged expression must comply with the type expression tE. This value-independent type \nencod-ing can be used for the type specialization described in [7], where the partial evaluator and the \nprojection function are type-indexed by the same family of types.  4.3.2 Comments Finally, we briefly \nargue that the above approach based on embedding and projection functions is universal, in the sense \nthat the type index r can appear at any position of the type T, of the value v,. We assume the following \nconditions about the types: 1. All the type constructions ci build a type only from component types covariantly \nand/or contravariantly. As shown in the TDPE example, the same component type can be used both covariantly \nand contravariantly. 2. The type T, is constructed by covariant and/or con-travariant type constructions \nfrom type variable r ex-clusively.  We use the following systematic method of implementing type-indexed \nvalues u. First, define an ML datatype U fol- lowing the recursive construction of the type domain. Then, \nprogram the type interpretation in the form of equation (6). This can be achieved because by Condition \n1, all the type constructions are covariant/contravariant in all their argu-ments. The embedding and \nprojection functions serve as two basic coercions between type r and the type U: emb, : r--+ 11 proj, \n: U-r Given this type encoding (independent of any particular type-indexed value), we can write a universal \ndatatype ver- sion of the type-indexed v, and use the above pair of coercion functions to construct a \ncoercion from the universal-typed value to the value of particular type. The existence of such a coercion \nis ensured by Condition 2 by a straightforward structural induction on the type T,. By the construction, \nwe have Theorem 3 The approach described above, based on in-terpreting types as embedding/projection \nfunctions, gives a type-safe and value-independent solution to type encodings and implementing type-indexed \nvalues. This new approach to value-independent type encodings is general and practical. Though this approach \nis based on universal datatype solutions using tagged values, it over-comes the two original problems \nof directly using universal datatypes: l Though the universal datatype version of the indexed value is \nnot type-safe, the coerced value is type-safe in general. This is because verbatim input arguments of \nvarious types are mapped into the universal datatype by the embedding function, whose type acts as a \nfilter of input types. Unmatched tags are prevented this way. l Users do not need to tag the input and/or \nuntag the output; this is done automatically by the program fi, using the embedding and projection functions. \nFrom another perspective, this provides a method of edema/ tagging using the type structure. Such external \ntags are much smaller than the internal tags and are much easier to acquire (in our case, one can simply \nuse the result of type inference from the compiler). This approach is not as efficient as the ad hoc, \nvalue- dependent approach, due to the lengthy tagging and un-tagging operations and the introduction \nof extra intermedi-ate data structures. This problem can be overcome using program transformation techniques \nsuch as partial evalua-tion [18], by specializing the general functions with respect to certain type \nencodings at compile time, and removing all the tagging/untagging operations. In particular, Danvy showed \nhow it can be naturally combined with type-directed partial evaluation to get a 2-level embedding/projection \nfunction [7]. 4.4 Multiple type indices Though our previous examples only demonstrate type-indexed values \nwhich have only one type index, the embedding/projection-based approach can be readily ap-plied to implementing \nvalues indexed by more than one type indices. Here let us take the example of writing an ML func-tion \nthat performs subtype coercion [22]. Given a from-type, a to-type, a list of subtype coercions at base \ntypes, and a value of the from-type, this function coerces the value to the to-type and return it. Following \nthe general pattern, we first write a function univ-coerce, which performs the coercions on tagged values. \nThe fimction coerce then wraps up function univ-coerce, by embedding the input argument and projecting \nthe output. For brevity, we have omitted the obvious definition of the related datatypes, and the type \ninterpretations as embed- ding/projection functions and type expressions of Int, Str, List, -->, +*, \nsome of which have already appeared in pre- vious examljles. exception nonsubtype of typsExp * typeExp \nfun lookup~coerce Cl tE1 tE2 = raise nonSubtype(tE1, tE2) I lookup~coerce (Ct. t', t2t')::Others) tE1 \ntE2 = if t = tE1 andalso t, = tE2 then t2t' else lookup-coerce Others tE1 tE2 fun univ-coerce cl (tFUN(tEl-Ti, \ntE2-Tl)) (tFUN(tEl-T2. tE2-T2)) (FUN v) = FUN (fn x => univ-coerce-cl-tE2-Tl tE2-T2 (v (univ-coerce cl \ntEl_T2 tEl_Tl x))) I univ-coerce cl (tLST tE_Tl) (tLST tE_T2) (LST V) = LST (map (univ-coerce cl tE_Tl \ntE_TS) v) I univ-coerce cl (tPR(tEl-Tl, tE2-Tl)) (tPR(t.El-T2, tE2qT2)) (PR (x. y)) = PR (univ-coerce \ncl tEl_Tl tEl_T2 x, univ-coerce cl tE2-TI tE2-T2 y) 1 univ-coerce cl x y v = if x = y then V else (lookup-coerce \ncl x y) v fun coerce cl (Tl as (emb_Tl, proj_Tl, tE_Tl)) (T2 as (emb-T2, proj-T2, tE_T2)) v = proj-T2 \n(univ-coerce cl tE_TI tE_T2 (emb_Tl v)) The example below builds a subtype coercion C : string + string \n-int + string, given a base coercion int -string, so that, for example, the expression C (in x => x ^ \nx1 123 evaluates to \"123123,'. val C = coerce [(tINT, tSTR, in (INT x) => STR (Int.toString x1)1 (Str \n--> Str) (Int --> Str) Again, this approach can be combined with type-directed partial evaluation to \nobtain 2-level functions, as done by Danvy for coercion functions and by Vestergaard for a la Kennedy \nconversion functions [19, 321. 5 Related work 5.1 Using more expressive type systems The problem of programming \ntype-indexed values in a stati- cally typed language like ML motivated several earlier works that introduce \nnew features to the type systems. In the fol- lowing sections, we briefly go through some of these frame- \nworks that provide solutions to type-indexed values. 5.1.1 Dynamic typing Realizing that static typing \nis too restrictive in some cases, there is a line of work on adding dynamic typing [l, 21 to languages \nwith static type systems. Such an approach intro-duces a universal type Dynamic along with two operations \nfor constructing values of type Dynamic and inspecting the type tag attached to these values. A dynamic \ntyping approach extends user-defined datatypes in several ways: the set of type constructions does not \nneed to be known in advance- the type Dynamic is extensible; it also allows polymorphism in the represented \ndata. Processing dynamic values is however similar to processing tagged values of user-defined type-both \nrequire operations that wrap values and case analysis that removes the wrapping. A recent approach along \nthe line of dynamic typing, staged type inference [ZS] proposes to defer the type inference of some expressions \nuntil run-time when all related informa-tion is available. In particular, this approach is naturally \ncombined with the framework of staged computation [9, 301 to support type-safe code generation at run-time. \nStaged programming helped to solve some of the original problems of dynamic typing, especially those \nconcerning usages. However, the way type errors are prevented at run-time is to require users to provide \ndefault values that have ex-pected types of expressions whose actual types are inferred at run-time; \nwhen type-inference fails, or the inferred type does not match the context, the default values are used. \nThis is effectively equivalent to providing default exception handlers for run-time exceptions resulting \nfrom type infer-ence. The approach is still a dynamic-typing approach, so that the benefit of static \ndebugging offered by a static typ-ing system is lost. For example, the formatting function in [28] will \nsimply return an error when field specifiers do not match the function arguments. On the other hand, \nit is also because of this possibility of run-time type error that dynamic typing disciplines give extra \npower, as shown in applications such as meta-programming and higher-level data/code transferring in distributed \nprogramming. 5.1.2 Intensional type analysis Intensional type analysis [12] directly supports type-indexed \nvalues in the language XiML in order to compile polymor-phism into efficient unboxed representations. \nThe language XyL extends a predicative variant of Girard s System F, with primitives for intensional \ntype analysis, by providing facilities to define constructors and terms by structural in-duction on monotypes. \nHowever, the language XyL is ex- plicitly polymorphic, requiring pervasive type annotations throughout \nthe program and thus making it inconvenient to directlypogram in this language. Not surprisingly, the \nlan- guage Xi L is mainly used as a typed-intermediate language. 5.1.3 Haskell type classes The type-class \nmechanism in Haskell [II] also makes it easy to program type-indexed values: the declaration of a type \nclass should include all the type-indexed value needed, and every value construction ei should be implemented \nas an in- stance declaration for the constructed type, assuming the component types are already instances \nof the type class. One way of implementing type classes is to translate the use of type classes to arguments \nof polymorphic functions (or in logic teras, to translate existential quantifiers to uni- versal quantifiers \nat dual position), leading to programs in the same style as handwritten ones following the ad hoc ap- \nproach of Section 3. The type-class-based solution, like the ad hoc approach, is not value-independent, \nbecause all in-dexed values need to be declared together in the type class. Also, because each type can \nonly have one instance of a par- ticular type class, it does not seem likely to support, e.g., defining \nvarious formatting functions for the same types of arguments. It is interesting to note that type classes \nand value-independent types (or type encodings) form two dimensions of extensibility. l A type class \ntixes the set of indexed values, but the types in the type classes can be easily extended by in- troducing \nnew instances. l A value-independent type fixes the family of types, but new values indexed by the family \ncan be defined with-out changing the type declarations. It would be nice to allow both kinds of extensibility \nat the same time. But this seems to be impossible-consider the problem of defining a function when possible \nnew types of arguments the function need to handle are not known yet. A linear number of function and \ntype definitions cannot result in a quadratic number of independent variations.  5.1.4 Conclusion The \napproaches above (described in section 5.1.1 through section 5.1.3) give satisfactory solutions to the \nproblem of type-indexed values. However, since ML-like languages dominate large-scale program development \nin the functional programming community, our approach is immediately us-able and pragmatic in common \nprogramming practice.  5.2 Type-directed partial evaluation Partial evaluation is an automatic program \ntransformation technique that removes the run-time interpretive overhead of a general-purpose program \nand generates an efficient special-purpose program. A traditional partial evaluator is syntax-directed, \nintensionally working on the program text by propagating constant values through the program text and \ncarrying out static computations to yield a simplified program. On the contrary, type-directed partial \nevaluation is an extensional approach which amounts to normalizing the expression through evaluating \nthe given expression in a suitable context, given the type of residual program. Guided by the type information, \nthe functions defined in Figure 2 eta-expand a value into a two-level lambda expression. The underlined \nconstructs are dynamic constructs, which repre-sent code-generating computations, while other constructs \nare static constructs, which represent computations during partial evaluation (hence the alternative \nname normaliza-tion by evaluation 181). Andrzej Filinski first implemented type-directed partial evaluation \nin ML in 1995. In his presentations of type-directed partial evaluation, Danvy always challenged the \nattendees to program it in a typed language such as ML or Haskell. The author answered the challenge \nin 1996, which, according to Danvy, is the first solution after Filinski s. The third person to have \nsolved it is Morten Rhiger [26]. Since then, Kristoffer Rose has programmed it in Haskell, using type \nclasses 1273. An interesting common pattern shared by type-directed partial evaluation and the embedding/projection-based \nap-proach is the use of types as external tags (see section 4.3.2): loosely speaking, one external type \ntag in type-directed partial evaluation replaces pervasive binding-time annota-tions in the preprocessed \nprogram texts. The two-level eta-expansion process then follows the external type tag to place appropriate \nbinding-time annotations to the program. 6 Conclusions We have presented a notion of type-indexed values, \nwhich formalize functions having type arguments. We have formu- lated type-encoding-based implementations \nof type-indexed values in terms of type interpretations. According to this formulation, we presented \nthree approaches that enable type-safe programming of type-indexed values in ML or sim- ilar languages. \nThe first approach directly uses the specific values of a given type-indexed value as the type interpretation. \nIt gives value-dependent type encodings, not sharable by different values indexed by the same family \nof types. However, its efficiency makes it a suitable choice both for applications where all type-indexed \nvalues using the same family of types are known in advance, and for the target form of a translation \nfrom a source language with explicit support for type-indexed values. The second approach is value-independent, \nabstracting the specification of a type-indexed value from the first approach. Apart from its elegant \nform, it is not very practical because it requires first-class and higher-order polymorl~hism. The third \napproach applies the first approach to tune a usual t.agged-value-based, type-unsafe approach to give \na type-safe and syntactically convenient approach, by interpreting types as the embedding/projection \nfunc-tions. Though it is less efficient than the first approach due to all the tagging/untagging operations, \nit allows different type-indexed values to be combined. There-fore, we ;nefer this approach to the other \napproaches for practical programming in a modular fashion. On one hand, we showed in this article that \nwith appropri-ate type enco*;ng, type-indexed values can be programmed in ML-like languages; on the other \nhand, our investigation also feedbacks to the design of new features of type systems. For examp!r, implicit \nfirst-class and higher-order polymor-phism seem to be useful in applications such as type en-codings. \nThe question of what is an expressive enough and yet convenient type system will only be answered by \nvarious practical applications. Concerning programming methodologies, we note the similarity between \ntype-directed partial evaluation and our third approach in externalizing internal tags. Requiring only \na single external tag not only alleviates the burden of manu- ally annotating the program or data with \ninternal tags, but also increases tile consistency of these tags. We would like to generalize this idea \nto other applications. Acknowledgments I especially thank Olivier Danvy for his challenge, and for his \nencouragement that led to this article, and for productive discussions. I am also grateful to Hseu-Ming \nChen, Deepak Goyal, Fritz Wenglein, Bob Paige, and the anonymous ref-erees for their helpful comments. \nThanks also go to other researchers fro1.i BRICS, from the DIKU TOPPS group, and from New Ycri University \nfor fruitful discussions. Figure 5 was drawn with Kristoffer Rose sICy-pit package. References Martin \nAbadi, Luca Cardelli, Benjamin Pierce, and PI Gordon Plotkin. Dynamic typing in a statically typed language. \nACM l+ansactions on Programming Lan-guages and Systems, 13(2):237-263, April 1991. Martin Abadi, Luca \nCardelli, Benjamin Pierce, and Di- PI dier R&#38;l;-. Dynamic typing in polymorphic languages. Jorkmcl \n(J,. Functional Programming, 5(1):111-130, Jan-uary 19C,5 Andrew W. Appel and David B. MacQueen. Standard \n131 ML of New Jersey. In Jan Maluszyriski and Martin Wirsing, editors, Third International Symposium \non Programming Language Implementation and Logic Pro- gramming, number 528 in Lecture Notes in Computer \nScience, pages 1-13, Passau, Germany, August 1991. Springer-Verlag. [4] William Clinger and Jonathan \nRees, editors. Revised4 report on the algorithmic language Scheme. LISP Pointers, IV(3):1-55, July-September \n1991. [5] Olivier Danvy. Type-directed partial evaluation. In Steele [29], pages 242-257. [6] Olivier \nDanvy. Formatting strings in ML. Research Series RS-98-5, BRICS, Department of Computer Sci-ence, University \nof Aarhus, March 1998. To appear in the Journal of Functional Programming. [7] Olivier Danvy. A simple \nsolution to type specialization. Research Series RS-98-1, BRICS, Department of Com- puter Science, University \nof Aarhus, January 1998. To appear in the Proceedings of the .25fh International Col-loquium on Automata, \nLanguages, and Programming. [8] Olivier Danvy and Peter Dybjer, editors. Preliminary Proceedings of the \n1998 APPSEM Workshop on Nor-malization by Evaluation, NBE 98, (Gateborg, Swe-den, May 8-9, 1998), number \nNS-98-1 in BRICS Notes Series, BRICS, Department of Computer Science, Uni-versity of Aarhus, May 1998. \n[9] Rowan Davies and Frank Pfenning. A modal analysis of staged computation. In Steele [29], pages 258-283. \n [lo] Jean-Yves Girard. The system F of variable types, fifteen years later. Theoretical Computer Science, \n45(2):159-192, 1986. [ll] Cordelia Hall, Kevin Hammond, Simon Peyton-Jones, and Philip Wadler. Type classes \nin Haskell. ACM Transactions on Programming Languages and Systems, 18(2):109-138, March 1996. [12] Robert \nHarper and Greg Morrisett. Compiling poly-morphism using intensional type analysis. In Peter Lee, editor, \nProceedings of the Twenty-Second Annual ACM Symposium on Principles of Programming Lan-guages, pages \n130-141, San Francisco, California, Jan-uary 1995. ACM Press. [13] Fritz Henglein. Dynamic typing: syntax \nand proof the-ory. Science of Computer Programming, 22(3):197-230, June 1994. [14] J. Roger Hindley. \nThe principal type-scheme of an ob- ject in combinatory logic. Transactions of the American Mathematical \nSociety, 146:29-60, 1969. [15] Mark P. Jones. A system of constructor classes: over-loading and implicit \nhigher-order polymorphism. Jour-nal of Functional Programming, 5(1):1-35, January 1995. An earlier version \nappeared in FPCA 93. [16] Mark P. Jones. First-class polymorphism with type inference. In Jones [17], \npages 483-496. [17] Neil D. Jones, editor. Proceedings of the Twenty-Fourth Annual ACM Symposium on Principles \nof Program-ming Languages, Paris, France, January 1997. ACM Press. [18] Neil D. ones, Carsten K. Gomard, \nand Peter Ses-toft. Parilal Evaluation and Automatic Program Gen-eration. Prentice Hall International, \nInternational Se-ries in Computer Science, June 1993. [19] Andrew Kennedy. Relational parametricity and \nunits of measure. In Jones [17], pages 442-455. [20] Robin Milner. A theory of type polymorphism in pro- \ngramming. Journal of Computer and System Sciences, 17:348-375, December 1978. [21] Robin Milner, Mads \nTofte, Robert Harper, and David MacQuee.k. The Definition of Standard ML (Revised). The MIT Press, 1997. \n[22] John C. Mitchell. Coercion and type inference. In Ken Kennedy, editor, Proceedings of the Eleventh \nAnnual ACM Syfmposium on Principles of Programming Lan-guages, pages 175-185, Salt Lake City, Utah, January \n1984. [23] Martin Odersky and Konstantin L;iufer. Putting type annotations to work. In Steele [29], pages \n54-67. [24] John Peterson, Kevin Hammond, et al. Report on the programming language Haskell, a non-strict \npurely-functionai programming language, version 1.4. Avail-able at the Haskell homepage: http://www.haskell.org, \nApril 1997. [25] John C. Reynolds. Towards a theory of type struc-ture. In Programming Symposium, number \n19 in Lec-ture Notes in Computer Science, pages 408-425, Paris, France, April 1974. Springer-Verlag. \n[26] Morten Rhiger. A study in higher-order programming languages. Master s thesis, DAIMI, Department \nof Computer Science, University of Aarhus, Aarhus, Den-mark, Desember 1997. [27] Kristoffer Rose. Type-directed \npartial evaluation in a pure fimc:*.ional language. In Danvy and Dybjer [8]. [28] Mark Shields, Tim Sheard, \nand Simon Peyton Jones. Dynamic typing as staged type inference. In Luca Cardelli, editor, Proceedings \nof the Twenty-Fifth An-nu.al ACM Symposium on Principles of Programming Languages, pages 289-302, San \nDiego, California, Jan-uary 1998. ACM Press. [29] Gny L. Steele, editor. Proceedings of the Twenty-Third \nAnnxa? ii 3M Symposium on Principles of Program-ming Languages, St. Petersburg Beach, Florida, Jan-uary \n1996 ACM Press. [30] Walid Taha and Tim Sheard. Multi-stage program-ming. In Mads Tofte, editor, Proceedings \nof the 199 7 ACM SIGPLAN International Conference on Func-tional Programming, pages 321-321, Amsterdam, \nThe Netherlands, June 1997. ACM Press. [31] Ma&#38; Tofte. Principal signatures for higher-order pro-gram \nmoc!ules. Journal of Functional Programming, 4(3):285%335, July 1994. [32] H.en&#38; Vetergaard. From \nproof normalization to compiler generation and type-directed change-of-representation. Master s thesis, \nDAIMI, Department of Computer Science, University of Aarhus, Aarhus, Den-mark, May 1997.  \n\t\t\t", "proc_id": "289423", "abstract": "A Hindley-Milner type system such as ML's seems to prohibit type-indexed values, <i>i.e</i>., functions that map a family of types to a family of values. Such functions generally perform case analysis on the input types and return values of possibly different types. The goal of our work is to demonstrate how to program with type-indexed values within a Hindley-Milner type system.Our first approach is to interpret an input type as its corresponding value, recursively. This solution is type-safe, in the sense that the ML type system statically prevents any mismatch between the input type and function arguments that depend on this type.Such specific type interpretations, however, prevent us from combining different type-indexed values that share the same type. To meet this objection, we focus on finding a value-independent type encoding that can be shared by different functions. We propose and compare two solutions. One requires first-class and higher-order polymorphism, and, thus, is not implementable in the core language of ML, but it can be programmed using higher-order functors in Standard ML of New Jersey. Its usage, however, is clumsy. The other approach uses embedding/projection functions. It appears to be more practical.We demonstrate the usefulness of type-indexed values through examples including type-directed partial evaluation, C printf-like formatting, and subtype coercions. Finally, we discuss the tradeoffs between our approach and some other solutions based on more expressive typing disciplines.", "authors": [{"name": "Zhe Yang", "author_profile_id": "81450594198", "affiliation": "Department of Computer Science, New York University, 251 Mercer Street, New York, NY", "person_id": "PP15029944", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/289423.289458", "year": "1998", "article_id": "289458", "conference": "ICFP", "title": "Encoding types in ML-like languages", "url": "http://dl.acm.org/citation.cfm?id=289458"}