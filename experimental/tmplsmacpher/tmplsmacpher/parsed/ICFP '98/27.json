{"article_publication_date": "09-29-1998", "fulltext": "\n Intensional Polymorphism in Type-Erasure Semantics* Karl Crary Stephanie Weirich Greg Morrisett Cornell \nUniversity Abstract Intensional polymorphism, the ability to dispatch to different routines based on \ntypes at run time, en-ables a variety of advanced implementation techniques for polymorphic languages, \nincluding tag-free garbage collection, unboxed function arguments, polymorphic marshalling, and flattened \ndata structures. To date, languages that support intensional polymorphism have required a type-passing \n(as opposed to type-erasure) in-terpretation where types are constructed and passed to polymorphic functions \nat run time. Unfortunately, type-passing suffers from a number of drawbacks: it re-quires duplication \nof constructs at the term and type levels, it prevents abstraction, and it severely compli-cates polymorphic \nclosure conversion. We present a type-theoretic framework that supports intensional polymorphism, but \navoids many of the dis-advantages of type passing. In our approach, run-time type information is represented \nby ordinary terms. This avoids the duplication problem, allows us to recover abstraction, and avoids \ncomplications with closure con-version. In addition, our type system provides another improvement in \nexpressiveness; it allows unknown types to be refined in place thereby avoiding certain beta- expansions \nrequired by other frameworks. Introduction Type-directed compilers use type information to enable optimizations \nand transformations that are impossible (or prohibitively difficult) without such information [13, This \nmaterial is based upon work supported in part by AFOSR grant F49620-97-I-001, ARPA/RADC grant FC30602-96-I-0317, \nNSF grant CCR-9244739, and ONR grant N00014-92-J-1764. The second author is nlso supported under a National \nScience Foundation Graduate Fellowship. Any opinions, find-ings, and conclusions or recommendations in \nthis publication are those of the authors and do not reflect the views of these agencies. 11, 17, 2, \n23, 25, etc.]. However, type-directed compilers for some languages such as Modula-3 and ML face the difficulty \nthat some type information cannot be known at compile time. For example, polymorphic code in ML may operate \non inputs of type cy where (Y is not only unknown, but may in fact be instantiated by a variety of different \ntypes. In order to use type information in contexts where it cannot be provided statically, a number \nof advanced implementation techniques process type information at run time [ll, 17, 28, 19, 251. Such \ntype information is used in two ways: behind the scenes, typically by tag-free garbage collectors [28, \n11, and explicitly in program code, for a variety of purposes such as efficient data rep-resentation \nand marshalling [17, 11, 261. In this paper we focus on the latter area of applications. To lay a solid \nfoundation for programs that analyze types at run time, Harper and Morrisett devised an in-ternal language, \ncalled Xy , that supports the first-class intensional analysis of types (following earlier work by Constable \n[3, 41). The Xy language and its derivatives were then used extensively in the high-performance ML compilers \nTIL/ML [27, 201 and FLINT [26]. The pri-mary novelty of Xp is the presence of typecase oper-ators at \nthe level of terms and types, that allow compu-tations and type expressions to depend upon the values \nof other type expressions at run time. Supporting intensional type analysis (and the use of type information \nat run time in general) seems to re-quire semantics where types are constructed and passed to polymorphic \nfunctions during computation. How-ever, there are a number of practical and theoretical reasons why type-passing \nis unattractive: l A type-passing language such as XyL type information always be constructed to polymorphic \nfunctions. This framesult in considerable overhead if types amined at run time, and, as we dismakes abstraction \nimpossible. requires that and passed work can re-are rarely ex-cuss later, it l Type passing results \nin considerable complexity in Int,ensional since types are analyzed by the structure of their names, \nrather than by what terms they contain. This ap-proach is critical for practicality. language semantics, \ndue in large part to the num-ber of semantic devices that must be duplicated for both terms and types. \nFor example, in seman-tics that make memory allocation explicit [18, 191 a central device is a formal \nheap in which data is stored; in a type-erasure framework one such heap suffices, but when types are \npassed it is necessary to add a second heap (and all the attendant ma-chinery) for type data. l Type \npassing also greatly complicates low-level in-termediate languages, again due in large part to the duplication \nof computational dcviccs at the type level, and also to the need to support mixed-phase devices (constructs \nwith both type and term level components). This can pose a serious problem for typed intermediate languages, \nbecause these de-vices can disrupt the essential symmetries on which elegant type systems depend. For \nexample, a type- passing semantics for Typed Assembly Language [21] requires additional instructions \nfor allocating and initializing types, which in turn requires the typing machinery for allocation and \ninitialization to be lifted an additional level into the kind struc-ture. l As a particularly important \nexample of the preced-ing issue, type passing severely complicates typed closure conversion (compare \nthe type-passing sys-tem of Minamide et al. 1151 to the type-erasure system of Morrisett et al. [21]). \nIn a type-erasure framework, the partial application of a polymor-phic function to a type may still be \nconsidered a value (since the application has no run-time sig-nificance), which means that closed code \nmay sim-ply be instantiated with its type environment when a closure is created. In a type-passing frame-work, \nthe instantiation with a type environment can have some run-time effect, so it must be de-layed until \nthe function is invoked. Consequently, closures must include a type environment, necessi-tating complicated \nmechanisms including abstract kinds and translucent types [15]. In this paper we propose a typed calculus, \ncalled An, that ameliorates the problems of type passing without sacrificing intensional type analysis. \nIf run-time type dispatch is supported, then clearly on some level types must be passed. The fundamental \nidea behind our ap-proach is to construct and pass terms that represent types instead of the types themselves. \nThe connection between a type T and its term representation e is made in the static semantics by assigning \ne the special type R(T). Semantically, we may interpret R(T) as a single-ton type that contains only \nthe representation of 7. This framework resolves the difficulties with type pass-ing semantics discussed \nabove. In particular, as rep-resentations of types are simply terms, we can use the pre-existing term \noperations to deal with run-time type information in languages and their semantics. Further-more, we \ncan eliminate the difficulties associated with polymorphic closure conversion, as we show in Section \n4. Finally, our approach enables the choice 7101 to pass representations. In turn, this choice allows \nus to elimi-nate the overhead of constructing and passing represen-tations of types where it is not necessary. \nPerhaps more importantly, the ability not to pass types allows abstraction and parametricity to be recovered. \nIn most type systems, abstraction may be achieved by hid- ing the identity of types either through parametric \npoly-morphism [22] or through existential types [16]. How-ever, when all types are passed and may be \nanalyzed (as in A?), t,he identity of types cannot be hidden ancl consequently abstraction is impossible. \nIn contrast, a XII type can be analyzed only when its representation is availa.ble at run time, so abstraction \ncan be achieved simply by not supplying type representations. For example, consider the type 3cu.c~. \nWhen all types may be analyzed, this type implements a dynamic type; an expression of this type provides \nan object of some unknown type, and that unknown type s identity can be determined at run time by analyzing \ncy. In An, as in most other type systems, 3a.a implements an ab-stract type (in this particular example, \na useless ab-stract type), because no representation of CY is provided. Dynamic types are implemented \nin An by including a representation of the unknown type, as in 3a. R(a) x (Y. 1.1 Expressiveness In the \ninterest of clarity of presentation, we express Xn as an extension of Harper and Morrisett s AFL and \nfocus on their differences. The principal difference is the re-striction of type analysis to those types \nfor which repre-sentations arc provided. This change does not diminish the expressiveness of our calculus; \nXp may be trans- lated in a straightforward syntax-directed manner into An. Moreover, the Xn calculus \nincorporates an additional improvement in expressiveness over Xy that is indepen- dent of explicit type \npassing: In AFL, information gained by analyzing a type is not propagated to other variables having that \ntype. Consequently, when analyzing a type cy with the interest of processing an object of type Q, it \nis necessary to create a function with argument type 01 and then apply that function to the object of \ninterest. In other words, the type system of A? requires the use of beta-expansions that are not operationally \nnecessary. In A, we resolve this shortcoming by strengthening the typing rule for typecase so that it \nrefines types in place. 1.2 Overview The remainder of this paper is organized as follows: In Section \n2 we review the A? calculus. We then present, in Section 3, our A, calculus and discuss its formal se-mantics, \nincluding representation terms, R-types, and the strengthened typecase rule. In Section 4, we discuss \nIn fact, the TIL/ML compiler already finds it necessity to use annotat.ions that mark whet,hrr a type \nmust be passed at run-l.imc. Our system provides a formal basis for that mechanism. the simplification \nof polymorphic closure conversion by explicit type passing. We end with related work and conclusions \nin Sections 5 and G. In the appendices we relate our typed semantics to an untyped one through type erasure \n(Appendix A), discuss the analysis of quan- tified types (Appendix B), and provide the formal op-erational \nand static semantics (Appendices C and D.) 2 Intensional Type Analysis Suppose we wanted to efficiently \nstore an array of boolean values. Most computer architectures require that memory accesses are a word \nat a time, but it is a terrible waste of space to store booleans as integers. The word value. might &#38; \nfor solution is to pack thirty two booleans into one and use bit manipulations to retrieve the correct \nTo subscript from a packed boolean array, we use the following function (with << for shift left, bitwise \nand, and <> for inequality): val bitsub : array[intl * int -> boo1 = fn (a,i) => sub(a,i div 32) % (l<C(i \nmod 32)) 0 0 This function is fine when we know a given array con-tains boolean values, but we would \nlike code polymor-phic over all arrays to be able to use this mechanism. Below we define a new array \nconstructor, PackedArray, which will produce an array of integers to hold booleans, and an ordinary array \nfor other types. We also define an associated subscript operation, packedsub, which calls bitsub on arrays \nof booleans and the ordinary subscript operator on arrays of other types. These constructs can be created \nwith intensional type analysis, where in both cases an argument type is examined with a typecase form: \ntype PackedArray Co1 = Typecase cy of boo1 => array[intI I _ => array EcuI val packedsub : t/a. PackedArray \n[cr] Fn [cu] => typecase o. of boo1 => bitsub I -=> sub 2.1 The XyL calculus L * int -> cy = To formalize \nthe tools begin by summarizing culus Ill]. The XF form that is relatively ful. The syntax of XrL presentation). \nThe Girard s F, [9, 8] ranges only over (i.e ., monotypes), of intensional type analysis, we Harper and \nMorrisett s Xy cal- calculus provides these tools in a simple, but already quite power- appears below \n(modified slightly for backbone is a predicative variant of in which the quantified type VCY:R.U type \nconstructors and small types which do not include the quantified types. The type analysis operators are \nTyperec and typecase at the constructor and term levels respec- tively. &#38;;fs; (types) (terms) (walwes) \nOccasionally, K C :: = . . -. . - Type I ~1 - m a 1 int 1 Cl + c2 1 Cl x c2 1 xa:K.c 1 ClC2 1 Typerec \nc (&#38;t , c- , cx ) u :: = c 1 01 --+ c72 I 01 x u2 1 Vcxxa e :: = 5 1 i 1 Xx:a.e 1 fix f:a.w ] ties \n] (el,e2) I me I7r2e I Aa:n.v 1 e[c] ( typecase[cu.a] c of int =k e,,t X v :: = i 1 Xxx7.e 1 fix 5:o.u \n] (Ul, v2) I Acu:n.v for brevity, we will write typecase terms ; -, = exe- as typecase[o.o] c(e,nt,Pr.e-.+,Pr.e~). \nfix tostring : (Va:Type. LY --+ string). AmType. typecase[6.6 -+ string] a of ant * int2string string \n+ Xobj:string.obj P-r* Xobj:(p + y). function @X-Y=+ Xobj:(p x y). < ^(tostring[p](~l obj))* , I-(tostring[y](?r2 \nobj))* > Figure 1: The function tostring As an example of the use of type analysis in Xy (with the addition \nof another base type, string), consider the function tostring, presented in Figure 1. This function uses \ntypecase to produce a string representation of a data object. For example, the call tostring [id] 3 re-turns \nthe string 3 . As we cannot provide any infor-mation about the implementation of functions, we just return \nthe word function when one is encountered, as in the call: tostring [(int + int) X int] (XZ:int. x + \n1,3) which returns When function variables second (function, 3) the argument to tostring is a product \ncalls itself recursively. In this branch, ,0 and y are bound to the types of the components of the tuple, \nso that the call can be instantiated with the correct type. The typecase form has a type annotation type, \nthe the type first a.nd recursive for type checking without type inference; the annotation [a.~] indicates \nthat given a type constructor argument c, the typecase computes a value with type a[c/a] (where this \nsyntax denotes the capture-avoiding substitution of c for (Y in a). In this example, each arm returns \na function from 6 to string, where 6 is replaced by the appropriate type, such as int in the int branch, \nand fi x y in the product branch. With this intuition, the typing rule for typecase is the natural one \n(but we will see that this rule is somewhat restrictive): l7 l- c : Type l?, a:Type i-CJ type r t ed \n: a[int/oc] I , @Type, y:Type k e, : 0[/3 -+ y/a] r, @Type, y:Type I-e, : a[/? x Y/N] l? l- (typecase[o.o] \ncof) : a[c/o] int * eznf FZ -X ex Often, to compute the result type 0 of a typecase ex-pression the \nconstructor-level Typerec on the argument Q will be required. Typerec allows the creation of new types \nby similar intensional analysis. Several examples of its use appear in Harper and Morrisett [ll], including \ntype-directed data layout, marshalling and unboxing. While recursion in the term-level typecase is handled \nby fix, at the the constructor level there is no such mechanism. For this reason, Typerec is essentially \na fold operation (or catamorphism) over inductively de-fined types. It provides primitive recursion by \ncalling it-self recursively on all of the components of the argument type. Also unlike typecase, where \nthe branches explic-itly bind arguments for the components of the type, the c, and cX branches of Typerec \nare constructor func-tions. For example, if the argument of a Typerec oper-ation is ci x cs, then that \noperation reduces to its cX branch (a constructor function of four arguments) ap-plied to the components \ncl and cz, and to the result of recursively computing the Typerec operation on those components. Typerec \n(ci x cs) (c;,t, c-. , cx ) = cx Cl c2 (Typerec cl (CA, c-, cx )) (Typerec c2 (cht, c-., cx )) The kinding \nrule for Typerec is again the natural one. To compute a constructor of kind K, present a type ar-gument \nand three branches returning K constructors: r t-c : Type rl-C mt : n rt-cc, --+lG+r;+tc : Type -+ Type \nI-l-ccx: +n+n+n Type -Type I l- Typerec c (c;,t , c,, cX ) : K 3 The A, calculus Figure 2 presents the \nsyntax of Xn, which we describe in detail in the following section. (kinds) I(. ::= I K--K, Type (con \ns) c ::= int 1 (Y 1 XCKKC 1clc2 ( Cl -c2 I Cl x c2 I R(c) I Typerec c (ctnt , cx , c..+, cn) (types) \nu ::= c 1 01 + 02 1 Cl x (T2 1 Va:r;.u 1 3oM.u (terms) e ::= 2 1 i 1 (el,e2) ) 7rle I7r2e 1 Xxx7.e 1 \nele2 1 Aa:rc.v 1 e[c] 1 fix f:a.v ( pack e as 3cr.ai hiding us I unpack (01, Z) = er inez I RInt I R-(el,ez) \nI Rx(el,ez) I h(e) 1 typecase[6.c] e of F&#38;t =S etnt R-(x, Y) as (P -Y) * e- RX (2, Y) as (P x Y) \n* ex b(x) as R(P) =S en (values) 2) ::= i 1 (7~1,712) 1 Xx:u.e I Aa:n.w 1 71[c] 1 fixf:u.v I pack v \nas 3cu.ur hiding 02 I RInt I R-(v,7~2) / Rx(w,w2) 1 RR(~) Figure 2: Syntax of Xn 3.1 Term Representations \nof Types The key feature we add to the term language of Xs is the representations of types as terms, \nwhich remain when the types themselves are ultimately erased. The base type, int, has a corresponding \nrepresentation constant RInt. Likewise, inductive types have inductively defined representations; the \ntype int -+ id is represented by the term R+ (R,,t, Rlnt). Accordingly, the argument to the term level \ntypecase is the representation of a type, instead of a type. For example, if the argument e is of the \nform R, (ei, ez), the arrow branch (e-) is taken. The type variables p and y are still bound to the types \nthat ei and es represent, but, because we need not only the component types but also their representations, \nz and y are bound to ei and es. This notion is reflected in the following rule of the operational semantics: \ntypecase[6.c] (R-(ei, ez)) (e,,t, &#38;zy.e-, .) ++ e-[~(el),~(ez),el,ez/P,r,x,yl The operation D(.) \nin this rule converts a representa-tion to the type that it denotes (Figure 3). The rest of our dynamic \nsemantics is formalized in Appendix C. It is presented as a call-by-value, small step operational semantics. \nIn order to assign a type to these representations of types, we have extended the type constructor level \nof Xn with the R construct, where the representation of a type r is given the type R(T), and extended \nthe static semantics accordingly. For example, the formation rule D(R,,t) = int Wh(el,ez)) = D(el) x \nD(e2) D(R-(el,ez)) = D(a) -D(e2) Wh(e)) = WNe)) Figure 3: Translating Representations to Types for the \nrepresentation of function types is which says that if the two subterms, ei and e2, are type representations \nof ~1 and 72, then R,(ei, Q) will be a representation of ri -+ 72. As an example of the use of Xn, the \ntostring function from the previous section can be transliterated into Xrr by requiring it to take an \nadditional term argument, zn for the representation of the argument type: fix tostring : (Va:Type. R(N) \n+ a -+ string). AmType. Xza::R(a). typecase[h.cr + string] .za of R,,t =+ int2string RJinng + Xobj:string.obj \nR-(x,y)asD-+r* Xobj:p -+ y. function Rx(~,y)asP x Y * Xobj$ x y. < -(tostrzng [/3] x (~1 obj)) ^ , -(tostring \n[r]y(z~ obj))- > The static semantics we have defined ensures that these R-types are singleton types; \nfor each one there is ex-actly one value which inhabits it. This fact allows us to express constraints \nbetween types and their representa-tions at a very fine level. For instance, in the tostrzng example, \nthe representation argument must be the rep-resentation of the type of the object. Furthermore, as we \nhave added a new way to form types to the constructor language, we must add another term construct, RR(.), \nto form the representation of represen-tation types. We also extend typecase with an extra branch to \nhandle these terms and Typerec to handle R.-types. 3.2 In-place Refinement of Types The typing rules \nof Xy often Corce an inefficient use of typecase. In the tostring example in Section 2, we were required \nto create closures in each of the branches of the typecase. It would be more cflicient if we could lift \nthe lambdas outside of the typecase and have each branch of the typecase return a string. We could then \nwrite this fun&#38;on as: fix loslring : (Va:Type. h!(a) ---t a --+ string). Atr:Type. Xxa:R(a). X obJ:cy. \ntypecase[&#38;string] 2, of Rznt =+ int2string obj Lrtng =+ obj R+(z,y)asfi -+ y + function h(x,y)asP \nx Y * c ^ (tostrzng [/?I x (~1 obj)) ^ , -(tostring[y]y(~2ob~))- > The reason we could not write this \nfunction in Xy is that, it requires the type of obj to change based upon which branch of the typecase \nis selected. In Xy, all that, is known in the product branch is that obj is of type Q, not a tuple. In \norder to project from it in the recursive calls, the typing rules must update the type of obj to reflect \nthe fact that we know that 01 is 0 x y in the product branch. With the right enhancement to the static \nsemantics this optimization is possible. We have held off discussion of the Xs s typecase formation rule \nin order to emphasize this point. The basic idea is that in some cases typecase increases our knowledge \nof the argument type. We sep-arate the formation rule into situations where typecase gives us new information, \nsuch as when the argument is of type K(O), and when it does not, such as when the argument, is of type \nR(T~ -72). In the inference rule for t,ype checking a typecase term, when the argument is of type R(N), \nwe refine types containing ff to reflect the gain in information, as shown below. For simplicity, only \nsome of the rule is given here (the complete rule appears in Appendix D.3): l?, a:Type, r t-e : R(O) \nI?, l? [int/a] k e,,,[int/cu] : c[int, int/a, 61 r, P:Type, y:Type, r [P ---$ ~/4, x:R(P), Y: W-Y) k \ne-[in --+ y/ml : c[P + 7, P -r/a, 61 I , a:Type, I + typecase[6.c] e (elntr ,L+yxy.e-, . . .) : c[(-~/h] \nFor example, to typecheck the e, branch, we substitute p + y for cy everywhere, including the surrounding \ncon-t.ext.3 Consequently the types of the variables bound in t,he context will be refined by that substitution. \nBe-cause XrL only makes this substitution in the return type of the brauch, and not in the context, in \norder to propagate this information one must abstract over all variables of interest. When we know more \nabout the argument because of the singularity of the R-types, we can deduce statically which branch of \nthe typecase will be taken. Therefore we do not need to typecheck the other branches at all, leading \nto a much simpler rule. For example, if we know 3Tl~e substitution for u is applied within the branches \nthem-selves in order to avoid creating x hole in the scope of a. In practice, a typechecker would irnpten~ent \nthis operation by a lo- cal type definition, rather than by substitution. 30.5 Judgment Meaning r I- \nt: : K c is a valid constructor of kind 11 rtrr D is a valid type r t cl = c2 : n cl and c2 are equal \nconstructors rt-CT1 = CT2 ~1 and u2 are equal types r t t: : u e is a term of type g Figure 4: Judgments \nof Xn the argument is of type R(T~ + FL), we only need to examine the e, branch, as in the rule: r t- \ne : fqT1 + T2) I , z:R(7-I), y:R(72) I- e-[Tl, 72/P, Y] : c[n -+ 72/b] r I- typecase[b.c] e (eznt,,&#38;5y.e--, \n.) : C[T~ -+ 72/a]  3.3 Properties of the Formal Semantics Formally, the static semantics of Xn consists \nof a collec- tion of rules for deriving judgments of the forms shown in Figure 4. In these judgments, \nl? is a unified type and kind context, mapping constructor variables (cy, ,0, . ..) to kinds and term \nvariables (2, y, . ..) to types. The formal operational and static semantics of Xn appear in Ap-pendices \nC and D, and from them we can prove several useful properties about Xn. First, we would like to prove \nthe decidability of Xn type- checking. The only mildly difficult part is equivalence checking for constructors. \nBased upon the equivalence rules in Appendix D.2 we can define a notion of con-structor reduction to \na normal form in an obvious man-ner. This reduction relation can be proved strongly nor-malizing and \nconfluent (in a manner similar to Morrisett 1171) from which it follows that constructor equivalence \nis decidable. Therefore we can state the following theo-rem: Theorem 3.1 (Decidability) It is decidable \nwhether OT not lT k e : r rs derivable in Xn. Next, we would like to show that the static semantics guarantees \nsafety; that is, if a term typechecks, then the operational semantics will not get stuck (where a term \nthat is not a value, and for which no rule of our operational semantics applies, is stl&#38;): Theorem \n3.2 (Type Safety) If 8 I-e : D and e +-+* e then e is not stuck. The proof of this theorem is standard, \nrelying on the usual progress, subject reduction and substitution lem-mas. 4 Polymorphic Typed Closure \nConversion As a final example, we consider typed closure conver-sion in a An-like framework. The key \nidea behind clo-sure conversion is to shift from a substitution-based model of execution to an environment-based \nmodel via a source-to -source translation. In particular, all func- tions are replaced with explicit \nclosures which are rep- resented within the language as pairs consisting of a X-abstraction (the code \nof the closure), and a tuple (the environment of the closure). The environment contains values for the \nfree variables of the function. The code abstracts the environment as well as the arguments of the function \nand is thus closed. Hence, the code may be hoisted to the top-level, allocated at compile time, and shared \namong all substitution instances. Application is rewritten so that the code of a closure is first applied \nto its enviromnent and then to its arguments. ln the monomorphic case no discrepancy arises between type-passing \n[15] and type-erasure [21] closure conver-sion. An existential type is used to hold the type of the closure \ns environment abstract, so a closure for a ~1 + 72 function is given the type 3cy.((~1 x01) -9 Q)XQ. \nHowever, with the introduction of polymorphism, sig-nificant differences arise between type-passing and \ntype-erasure. The issue stems from the fact that functions may contain free type variables as well as \nfree value variables, and closed code must abstract both. Closures must then provide someway to apply \nsuch code to the appropriate type variables. In a type-erasure setting, type application has no run-time \neffect, so the partial application of code to the appropriate type variables may be performed when closures \nare created. Con-sequently, these type variables do not appear in the type of a closure. In fact, closures \nhave the same type (~cY.((T~ x CY) -+ ~2) x LY) as before. However, in a type-passing semantics, the \napplication to type arguments is a run-time operation and so such ap-plications must be suspended until \nthe closure is called. Thus, it is necessary for the closure to include a type en-vironment as well as \na value environment. The kind of the tyl)e environment must be hidden (as did the type of the value environment \nin the monomorphic case), and the closure s type must enforce the requirement that the code be applied \nonly to the proper type environ-ment (see Minamide et al. [15] for detailed explanations of why). The \nformer requires the use of abstract kinds and the latter requires the use of translucent types [lo]. \nThis approach results in a closure having the consider-ably more complicated type (again, see Minamide \net al. [15] for a formalization of the necessary type theory): 3k t,,,:Kind. 3a: vellv:Ty~e. 3Pte,,v:kte,,v. \n(Vy:ktenv=Ptenv. (71 x cyvenv) --+ Q) x avenv In the above t,ype, ktenv abstracts the kind of the type \nenvironment, avenv abstracts the type of the value of the value environment, and Ptenv provides the type \nenviron-ment. The code type then takes a type environment y of kind ktenv as an argument, but y is constrained \n(using translucent types) to be the appropriate environment, Ptell . Since our framework is one of type-erasure, \ntype en-vironments may be resolved by partial application, re-sulting in the simpler type for closures. \nHowever, it is instructive to examine the details. Suppose the func-t,ion to be closure-converted is \nthe function j = Xr:rr.e with type ri + ~2 and suppose further that the function contains free occurrences \nof the type variable o and its representation 3.,:11(o). First the function is rewritten in closed form \nas: f : vo!. (T, x R(a)) -+ 7:! = Aa. Xy:(q x R(a)). e[7rly, 7r2y/x, xcu] Then (at run tirne) f is instantiated \nwith the type en-vironrnent (that is, o): f : (T, x R(a)) --+ 72 = f [a] Finally, a closure is created: \nf = pack (f , z~) as 3,8. ((71 x 0) + 71) x /3 hiding R(o) Consider what has become of the mechanisms \nfor type-passing closure conversion: The type of f requires that it be applied (for its second argument) \nonly to the rep-resentation of o. So the translucency mechanism ap-pears again, suggesting that translucency \nis inherent in type-passing closure conversion. However, this version of translucency has two advantages; \nthe necessary type theory is simpler, and the translucency is completely hidden by the existential packaging \nin the eventual clo-sure. On the other hand, abstract kinds do not appear in the process, suggesting \nthem to be an artifact of true type-passing. Related Work Closely relat,ed to our work is the work of \nMinamide on lifting of type parameters for tag-free garbage collection [14]. Minamide was interested \nin lifting type paramc-l.ers out of code so they could be preallocated at compile lime. His lifting procedure \nrequired the maintenance of interrelated constraints bctwcen type parameters to retain type soundness, \nand he used a system similar 1.0 ours that makes explicit the passing of type param-cters in order to \nsimplify the expression of such con-straints. The principal difference between Minamide s system and \nours is that Minamide did not consider in-tensional type analysis or first-class polymorphism. Mi-iiamide \ns system also makes a distinction between type representations (which he calls evidence, following Jones \n[1 2]) and ordinary terms, while Xr, type representations are fully first-class. The issue of type parameter \nlifting is an important one for compilers based on X1{. The coustructiou of type representa.tions at \nrun time would likely lead to signifi-cant cost and, in practice, should be lifted out to compile tirne \nwhenever possible. (Uufortunately, in the presence of polymorphic recursion, which Xn supports, it is \nnot always possible.) Mechanisms for such lifting have been developed by Minamide (in the work discussed \nabove) and by Saha and Shao [24]. Dubois el al. [6] also pass explicit type representations to polymorphic \nfunctions when compiling ad-hoc poly- morphism. However, their system differs from ours and Minamide \ns in that no mechanism is provided for con- necting representations to the t,ypes they denot,e, and consequrutly, \ninformation gained by analyzing type rep- resentations does not propagate into the type system. Duggan \n[7] proposes anotjher typed framework for in-tensiollal t,yp( analysis that is similar in some ways I,0 \nPL. Like XML Duggan s syst,em passes types implicitly and allows ior the intensional analysis of types \nat the term level. Duggall s system does not support inten-sional type analysis at the constructor level, \nas Xy and Xa do, but it adds a facility for defining type classes (us-ing union and recursive kinds) \nand allows type analysis to be rcsl.ricted to members of such classes. 6 Conclusions and Future Directions \nWe have presented a type-theoretic framework that sup-ports the passing and analysis of type information \nat run time, but that avoids the shortcomings associated with previous such frameworks (e.g., duplication \nof con-structs, lack of abstraction, and complication of closure conversion). This new framework makes \nit feasible to use intensional type analysis in settings where the short-comings previously made it impractical. \nFor example, Morrisett et (~1. [21] developed typing mechanisms for low-level intermediate and target \nlan-guages that allow type information to be used all the way to t,he end of compilation. It would be \ndesirable, in a system based on those mechanisms, to be able to ex-pl01t that type information using \nintensional type anal-ysis. Ilnfortunately, the shortcomings of type-passing semantics made it, incompat,ible \nwith some of those low-level typing mechanisms. This unfortunate incompat-ibility has made it infeasible \nto use the mechanisms of Morrisett et al. in type-analyzing compilers such as TX/ML [27, 201 and FLINT \n[26], and has made it infea-sible t,o use intensional type analysis in the end-to-end typed compiler \nTALC [2I]. The framework in this pa-per makes it possible to unify these two lines of work for the first \ntime. In pursuance of this aim, an important direction for fu-ture work is to extend the mechanisms of \nXn into lower-level typed intermediate languages such as t~yped as-sembly language [21]. Among the issues \nto be explored in such research is how to analyze the more compli-cated types used iu typed assembly \nlanguage, and how to perform type-directed dispatch without an atomic typecase construct. Another issue \nto explore is anal-ysis of quantified types (an initial proposal appears iu Appendix R), and whether \nsuch mechanisms are useful in practice. Another important question is whether a parametricity theorem \nlike that of Reynolds [22] can be shown for XI?. de coupures dans l analyse et la thkorie des types. \nPolymorphism is clearly non-parametric in Xp, but the In J. E. Fenstad, editor, Proceedings of the Sec- \nlowering of type analysis to explicit term-level represen-ond Scandznavian Logic Symposium., pages 63-92. \ni,atives makes it plausible that some sort of parametric-North-Holland Publishing Co., 1971. ity could \nbe shown for Xn. In other words, we discussed J.-Y. Girard. Interpre tation fonclionelle et at an intuitive \nlevel in Section 1 how the explicit pass-PI e limination des coupures de 1 arithme tique d ordre ing \nof types restores the ability to abstract types that supe'rieur. PhD thesis, Universiti! Paris VII, 1972. \nwas discarded by X, ML; it would be interesting to explore IIOW that intuition may be formalized. R. \nIHarper and M. Lillibridge. A type-theoretic PO1 approach to higher-order modules with sharing. 111 \nTwenty-First ACM SIGACT-SIGPLAN Sym-7 Acknowledgments posz um on Principles of Programming Languages, \npages 123-137, Portland, Oregon, Jan. 1994. R. Harper and G. Morrisett. Compiling polymor- We would \nlike to thank Neal Glew, Fred Smith, Chris WI phism using intensional type analysis. In Twenty- Stone, \nDave Walker, Steve Zdancewic, and the anony-Second ACM SIGA CT-SIGPLA N Symposium on mous referees for \ncomments and suggestions. Prancaples of Programming Languages, pages 130-m 141, San Francisco, Jan. 1995. \nReferences [1 Ll M. P. Jones. A theory of qualified types. In Fourth European Symposium on Programming, \nvolume 582 111S. Aditya and A. Caro. Compiler-directed type of Lecture Notes in Computer Science, Rennes, \nreconstruction for polymorphic languages. In Con- France, 1992. Springer-Verlag. ference on Functional \nProgramming Languages and X. Leroy. Unboxed objects and polymorphic typ- P31 Computer Architecture, \npages 74-82, Copenhagen, ing. In Nineteenth A CM SIGA CT-SIGPLA N Sym- June 1993. posium on Principles \nof Programming Languages, re-pages 177-188, 1992. L. Birkedal, M. Tofte, and M. Vejlstrup. From PI gion \ninference to von Neumann machines via region Y. Minamide. Full lifting of type parameters. Sub- [I41 \nrepresentation inference. In Twendy-Third A CM mitted for publication. Earlier version publishedSIGACT-SIGPLA \nN Symposium on Principles of as Compilation Based on a Calculus for ExplicitProgramming Languages, pages \n171-183, St. Pe-Type-Passing in the Second Fuji International tersburg, Jan. 1996. Workshop on Functional \nand Logic Programming, 1996. R. L. Constable. Intensional analysis of functions PI and types. Technical \nReport CSR-118-82, Depart- [15] Y. Minamide, G. Morrisett, and R. Harper. ment of Computer Science, \nUniversity of Edin- Typed closure conversion. In Twenty-Third ACM burgh, June 1982. SIGACT-SIGPLAN Symposkm \non Principles of Programming Languages, pages 271-283, St. Pe- R. L. Constable and D. R. Zlatin. The \ntype theoryI41 tersburg, Florida, Jan. 1996. of PL/CV3. ACM Transactions on Programming Languages and \nSystems, 6(1):94-117, Jan. 1984. [I 31 J. C. Mitchell and G. D. Plotkin. Abstract types have existential \ntype. ACM Transactions on Pro- J. Despeyroux, F. Pfenning, and Carsten151 gramming Languages and Systems, \n10(3):470-502,Schiirmann. Primitive recursion for higher- July 1988. order abstract syntax. In Third \nInternational Conference on Typed Lambda Calculi and Rpplica-G. Morrisett. Compiling with Types. PhD \nthesis, [I71 tions, volume 1210 of Lecture Notes in Computer Carnegie Mellon University, School of \nComputer Science, pages 147-163, Nancy, France, Apr. 1997. Science, Pittsburgh, Pennsylvania, Dec. 1995. \nSpringer-Verlag. Extended version published as Carnegie Mellon University technical report G. Morrisett, \nM. Felleisen, and R. Harper. Ab- M CMU-(S-96-172. stract models of memory management. In Con-[er.ence \nOTL Functional Programming Languages and 161 Computer Architecture, 1995. C. Dubois, F. Rouaix, and P. \nWeis. Extensional polymorphism. [n Twenly-Second A CM SIGA CT-SIGPLAN Symposium on Prin,ciples of Program-[I91 \nG. Morrisett and R. Harper. Semantics of memory ming Languages, pages 118-129, San Francisco, management, \nfor polymorphic languages. In A. D. Jan. 1995. Gordon and A. M. I itts, editors, Higher Order Operatsonal \nTechniques in Semantics. Cambridge [71 D. Duggan. A type-based semantics for user-University Press, 1997. \ndefined marshalling in polymorphic la.nguages. In Second Workshop on Types i7L Compilation, Mar. WI G. \nMorriset,t, D. Tarditi, P. Cheng, C. Stone, 1998. R. liarper, and I . Lee. The TIL/ML compiler: Performance \nand safety through types. In Work-J.-Y. Girard. Une ext,cnsion de l interpr&#38;ation de shop on Compiler \nSupport for Systems Software, PI Gijdel L l analyse, et son application &#38; I Qlimination Tucson, Feb. \n1996. WI G. Morrisett, D. Walker, K. Crary, and N. Glew. From System F to typed assembly language. In \nTwenty-Fifth ACM SIGACT-SJGPLAN Sympo-sium on Principles of Programming Languages, pages 85-97, San Diego, \nJan. 1998. Extended ver-sion published as Cornell University technical re-port TR97-1651. J. C. Reynolds. \nTypes, abstraction and paramet-ric polymorphism. In Information Processing 83, pages 513-523. North-Holland, \n1983. Proceedings of the IFIP 9th World Computer Congress. WI E. Ruf. Partitioning dataflow analyses \nusing types. In Twenty-Fourth ACM SIGACT-SIGPLAN Sym-posium on Principles of Programming Languages, pages \n15526, Paris, Jan. 1997. 1231 13. Saha and Z. Shao. Optimal type lifting. In Second Workshop on Types \nin Compilation, Mar. 1998. 1241 Z. Shao. Flexible representation analysis. In igg7 ACM SIGPLAN International \nConference on Functional Programming, pages 85-98, Amster-dam, June 1997. 1251 WI Z. Shao. An overview \nof the FLINT/ML compiler. In 1997 Workshop on Types in Compilation, Am-sterdam, June 1997. ACM SIGPLAN. \nPublished as Boston College Computer Science Department Technical Report BCCS-97-03. WI I). Tarditi, \nG. Morrisett, P. Cheng, C. Stone, It. Harper, and P. Lee. TIL: A type-directed opti-mizing compiler for \nML. In 1996 ACM SIGPLAN Conference on Programming Language Design and Implementation, pages 181-192, \nMay 1996. P81 A. Tolmach. Tag-free garbage collection using ex-plicit type parameters. In ACM Conference \non Lisp and Functional Programming, pages l-11, Or-lando, June 1994. A Untyped Calculus Although the \nformal static and operational semantics for XI, are for a typed language, we would like to em-phasize \nthe point that types are unnecessary for com-putation and can safely be erased. Accordingly, we ex-hibit \nan untyped language, Xn , a translation of Xn to this language through type erasure, and the following \ntheorem, which states that execution in the untyped language mirrors execution in the typed language: \nTheorem A. 1 1. If el H* e2 then el H* ez . 2. If0 l-er : r and era H* u then there exists e2 such that \nel I-+* e2 and ez = u. From this theorem and type safety for XII it follows that our untyped semantics \nis safe. Corollary A.2 If fl I- e : T and e H* u then u is not stuck.   A.1 Syntax of Untyped Calculus \n(terms) u, :: = x 1 i 1 Xx.u 1 fix f.w 1 ulu~ I (w, w) 1 TlU I rzu I Lit I R-(w,uz) I Rx(U1, 1L2) I Rn(u) \nI typecase u of Rrnt * Uint R-+(z,y) =+ IL+ Rx (x, y) * ux RR(X) * un (values) w :: = i 1 (2u1,w2) 1 \nXx.u ( fix f.w I R t; 1 ;x (WI, ~2) 1 R- (WI, .w) 1 R w A.2 Type Erasure X0 = x 2 0 = 2 = (el,e2) (a \n, a ) (7r,e) 7r;e = (Xx:c.e) = X2.e (Acu:n.u) = 210 (fix f:c.u) = fix f.v = (ele2) 0 el e2 +I0 = e pack \ne as c hiding c unpack (o, z) = er in es0 1 :I, x.e2 ) el Rmt = R*nt L(el,ez) = R,(elO,ezo) Rx(el,ez) \nRx(el , ez ) = Rn(el) = Rn(el ) (typecase[&#38;c] e of = typecase e of 0 Rlnt =a etnt Lt * e,,,t R-(2, \nY) as R,(z,y) + e, (P -Y) =a e-L(x,Y) * ex Rx (5, Y) as RR(X) =b- en0 (P x Y) * ex RR(z) as WV * enlo \n A.3 Operational Semantics of XR (Xx.u.)w H u[w/x] (fix f.w)w H (w[fixf.w/f])w n1 (WI, 702) H w 7r2(WI \n1 w2) -w2 typecase Rlnt (,&#38;,t, xy.u-+, xy.ux , x.un) I--+ utnt typecase (RX (~1, WZI)) (ulnt, XY.U-, \n  xy.ux, x.un) k-+ ux [WI, wz/x, Yl typecase (R,(wl, ~2)) (GM,XY.U-, xy.ux ,z.un) b-+ u- [w , wz/x, \nY] typecase (Rn(Pu)) (U,,L, zy.u-, xy.ux , X.U,f ) +-+ ~~rr[~U/~] IL1 I--+ 71; 7.L H ,lL u, I,2 I-+ \n,u,; IL2 WI, H UIU I,,, H u; ,,, b-+ II (IL1 ,112) +-+ (4, u2) (.uJ, LI) H (W, 11 ) 11 H u, 2, H 71 7rlU \nb-9 7r1 11 7r271 F 7r211 7, , b-3 11; 7L H IL R,(.IL,,U2) +-+ R,(U;, lb) R, (.w, 11) h FL (w, 21 ) U] \nH IL , u H IL RX(n,, ug) I-+ Rx(u;, (~2) Rx ( IU, u) ++ Rx (~1, u ) 7L h 11 b(u) H Rn(u ) u H 12 typecase \nU(U,,~,;L.~.U-,:CY.~LX,Z.~I,) ++ typecase U (U,,,~,ZY.U,,~L.Y.PLX,~.~~) B Analysis of Quantified Types \nIn an impredicative or recursive variant of XII it would be desirable to analyze quantified types. This \nmodifica-tion can be done easily by limiting the analysis to the outermost operator that is, a Typerec \nor typecase will determine that a type is a V or 3 type, but will not pro-vide any information about \nthe body of the type. Ex-perience from the TIL/ML compiler suggests that this solution might be enough \nin practice. IIowever, in this section we briefly explore what would be required to extend Xn to support \nfull analysis of quantified types. Adding term-level representations for quantified types is straightforward. \nTl ie representation for VCU:K.C must carry information expressing how to produce the ap-propriate c \ngiven an appropriate (Y of kind rc. For ex-ample, a member of R(Vlu:Type.c) would be built by a constr~~ctor \n&#38;Type that takes a function with type Vcu:Type. I<(o) -+ R(c). Representations of polymorphic types \nat any other kind 6 would be built by an analo-gous constructor R,, or Rg%. Note that this solution requires \nan infinite collection of such constructors, two for each kind. Analysis of t,ypes is also straightforward \nif quantifi-cation is restricted t,o Type, or to any finite set of kinds. In that case, the appropriate \nbranches can be added to the Typerec and typecase operations, and each branch would return the appropriate \nrepresenta-tion function discussed above. General quantification could be handled, at the expense of \nadditional com-plexity, by adding kind variables, term representations of kinds, and a Kindrec facility \nfor analyzing such repre-sentations. With such additions, the quantifier branches would return a kind \nrepresentation and the appropriate representation function. However, with such a mechanism in place, \nthe amount of useful analysis that can be performed is still quite lim-ited. Type analyzing code may \napply the representation function to an argument and analyze its output, but it could not analyze the \nfunction itself. This fact makes it impossible, for example, to print quantified types. The modal type \ntheory of Despeyroux et al. [5] is intended for precisely this sort of application; it provides mech-anisms \nfor primitive recursion on higher-order syntax and should provide a solution to this problem. Also, allowing \nany analysis of quantified types by Typerec sacrifices strong normalization of type expres-sions. (A \ncorrespondence between Type and Type ---t Type can be built, permitting the encoding of the un-typed \nlambda calculus.) A modal type discipline ap-pears to solve this problem as well. C Operational Semantics \n(Xx:c.e)v e-3 e[v/x] (Acl:K.v)[c] +-+ l+/cx]  7n(w,w2) l-9 w m(w,ws) I-+ v2 (fix f:c.v)v +-+ (,u[f ix \nf:c.v/f])v (fix f:c.~)[c ] ++ (w[f ix f:c.v/f)[c ] unpack (o, Z) = (pack v as 3,8.cr hiding cz) inez \nk ez[cz, v/o, Z] typecase[6.c] RZILt (eznt, P? Y.e-, @py.ex, Px.en) ++ ed typecase[h.c] (R-(vi, ~2)) \n(&#38;t,hxY.e-, &#38;xy.exr/3x.en) +-+ e-[ o(v~), ~D(vz),vl,~~z/P,r,~,Yl typecase[b.c] (Rx (vi, nz)) \n(e,,t, p?rY.e-, /3yxy.ex,px.en) ++ e.[ID(vz), D(vz),vl,V2/P,Y,2,Yl typecase[6.c] (RR(U)) (ernt, ,@-PY.e-, \nP-vY.ex, Px.en) ++ en[Wv), u/P, 4 el b-3 e; e ++ e e +-+ e elf22 ++ eie2 ve H ve e[c] k-9 e [c] e b--+ \ne el k-+ e; e H e 7r,e b-+ 7r;e (el,e2) H (ei,e2) (v, e) ++ (v,e ) e k e pack e as 3p.ci hiding C L * \npack e as 3p.ci hiding cz e h-3 e unpack (o, Z) = e in e2 H unpack (CY, Z) = e in es e b-t e typecase[h.cr] \ne (eznl, @yZy.e,, Pyxy.e,, @es) ++ typecase[6.u] e (elntr /3yzy.e,, ,@Zy.ex, Pz.es) el t-+ e; D.2 Type \nEquivalence (selected rules) R,(el,ez) ++ R.-.(ei,ez) el -ei e H e R,(w,e) H R,(v,e') Rx(el,e2) ++Rx(e;,ez) \n r, a:KI t c1 : K r t c2 : d e t-+ e e ++ e : K (a e ~043) r t (XCY:d.c1)c2= C1[Q/CV] Rx (w, e) ++ \nRx (v, e ) h(e) H &#38;f(d) D Static Semantics D.l Type formation rt Cd : K rt-c,: Type + Type -n-n--n \nrt cx : Type -+ Type --t K --+ K --+ tc p-c:n ] r t cn : Type --t K ----) K ~ (rycx) = K) r I- Typerec(irLt) \n(w, L, cX, cn) = c,~~ : PC I t int : Type r t- cy : K 1 t cl : Type r t c2 : Type rtc znt : K I t cl \n: Type r t- 01 : Type rtc,: Type -+ Type -+K+Kc K lY t cx : Type -+ Type --+ n + n --+ tc l? t cl + cz \n: Type r t c,?: Type + .K + K I'k Typerec(cl + c~)(c,,~,c+,c~,c~) = r I- cl : Type r t c2 : Type c, \nCI c2(Typerec cl (%t, c-, CX, en)) l? I-cl x c2 : Type (Typereccz(c,,t,c-,cx,c~)) : ~c I?+ Typerec(cl \nx c~)(cznt,c,,cX,cn)= cx cl cz(Typerecc1 (c,,t,~--,CX,CR)) (Typerecc;,(c,,t,c-,cx,c~)) : rc I r t c : \nType r t Cznt : K r t C, : Type -+ Type -+ K + n --+ rc. r t cl : ICY + IE~ r t- c2 : ~~ (a &#38; DoM3) \nr t cx : Type --+ Type -+ K -+ n --+ K rtClC2:n2 r I-cn : Type -+ s + IC. I'b Typerec(l2(c))(c,,t,c-,c~,cn) \n= r I- c : Type cnc(Typerec c(c~~~,c,,cx,c~)): 6 r t R(C): Type /-i?TGJ rtal=a2:K. r t c : Type rtc \n,nt : K r t C1 = g2 r t cm. : Type + Type -K + K -K r t cx : Type + Type + K -+ K -K r t Q, : Type -+ \nr; + K. r t Typerec c(G,,A,c+,cx,c~~) : IC D.3 Term Formation II 1 I t c : Type 1 t c ___ (r(z) = a) \n r t i : inl rtz:u r t u1 r t g2 r i- o1 r t- m2 r t o1 x u2 rt u2 rte2:u2 Ul - rt el:ul r t (el,ez) \n: (~1 x (~2 rte: u1xu2 r t e : o1 x u2 r t 7rle : cl r t 7r2e : ~32 rt el : u2 -+ u1 r t e2 : ~2 r t \neleZ : u1 Term Formation (continued) r, (Y:K t e : r t e[c] :U[c/a] r t Aaxe : Vaxa rte:vWCc.U rkC:K \nu r,cu:K t 01 : Type r t U2 : K r t e : UL[U2/(Y] (cy ~ Don2.(r)) r t pack e as ~CKK.U hiding ~72 : %:K.u~ \nr t el : &#38;Y:K.cQ r,ff:rC, 2x2 b Q : Ul (a,x $ Dam(r)) I? I- unpack (cu, x) = el in e2 : UI r, fzu \nt e : r t u u (f ~~Om(r),U=Voll:Kl..~a,:K,.Ul~Uz,n~O) r t fix f:u.e: u r t el : R(cl) r t : R(a) rt \nel : R(cl) r t e2 : R(c2) e2 r t Rlnt : R(int) lY t R-. (el, ez) : R(CI + CZ) r t Rx (el, ez) : R(cl \nx ~2) e r t : R(C) l?te:u2 rtUl=U2 r t RR(e) : R(R(c)) rte:ul r t e : R(d) r t ed : u[int/6] r t typecase[&#38;a] \ne (eintr PYxy.e-, Pyxy.e,, Px.en) : a[int/S] rt e: R(cl + c2) r,dqcl),y:kqc2) t e-+[cl,c2/~,~]:u[ci -+ \nc2/6] r t typecase[b.u] e (e,,t, &#38;xy.e+, /Jyxy.e, , /Jx.en) : u[ci -+ c2/5] e r t : R(cl x ~2) r,x:R(cl),y:R(c2) \nt ex[ci,c2/P,y]:u[ci x c2/6] r t typecase[b.u] e (e,,t,&#38;zy.e-+, PYxy.ex, /Jz.erf) : u[c~ X Q/6] r \nt : R(IZ(c)) r,2:f2(C) t e,[c/p] :u[R(c)/G] e r t typecase[h.u] e (ernt, /Jyxy.e-+, @yxy.eX, Px.ert) \n: u[R(c)/4 r,a:Type,I t e : R(a) r(r'[int/a]) t e,,t[int/a] : u[int,int/ff,6] r,P:Type, y:Type, (J? [p \n+ -y/a]), z:R(P), y:R(y) t e-+[P --t r/4 : u[P -+ r,P --Y/Q , 61 I?, @Type, y:Type, (r [p x y/a]), x:R(P), \ny:R(y) t ex [P x r/4 : dP x Y, P x ~/a, 61 r, @Type, (r [R(P)/4), z:W) t en[NP)l4 : 4W% NP)IQ, 61  ecu,P, \nY e Doe7 r )) r, a:Type, I? t- typecase[S.u] e (e,,t, PTxy.e-, PYxy.e,, Pz.en) : u[cu/h] r t : R(c) \nr t ed : u[int/6] e r, @Type, y:Type, z:R(P), y:R(y) t e-: u[P -y/61 r, @Type, y:Type, xR(P), y:R(y) \nt ex : o[P x r/61 r,P:Type, z:R(P) t en : u[NP)/61 (kr 52 Dom(r,r')) r t typecase[6.u] e (e;,t,/Jyxy.e,, \n&#38;xy.ex,fix.en) : u[C/a]  \n\t\t\t", "proc_id": "289423", "abstract": "Intensional polymorphism, the ability to dispatch to different routines based on types at run time, enables a variety of advanced implementation techniques for polymorphic languages, including tag-free garbage collection, unboxed function arguments, polymorphic marshalling, and flattened data structures. To date, languages that support intensional polymorphism have required a type-passing (as opposed to type-erasure) interpretation where types are constructed and passed to polymorphic functions at run time. Unfortunately, type-passing suffers from a number of drawbacks: it requires duplication of constructs at the term and type levels, it prevents abstraction, and it severely complicates polymorphic closure conversion.We present a type-theoretic framework that supports intensional polymorphism, but avoids many of the disadvantages of type passing. In our approach, run-time type information is represented by ordinary terms. This avoids the duplication problem, allows us to recover abstraction, and avoids complications with closure conversion. In addition, our type system provides another improvement in expressiveness; it allows unknown types to be refined in place thereby avoiding certain beta-expansions required by other frameworks.", "authors": [{"name": "Karl Crary", "author_profile_id": "81100253026", "affiliation": "Cornell University", "person_id": "P157139", "email_address": "", "orcid_id": ""}, {"name": "Stephanie Weirich", "author_profile_id": "81100093135", "affiliation": "Cornell University", "person_id": "P267927", "email_address": "", "orcid_id": ""}, {"name": "Greg Morrisett", "author_profile_id": "81339518683", "affiliation": "Cornell University", "person_id": "PP43136279", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/289423.289459", "year": "1998", "article_id": "289459", "conference": "ICFP", "title": "Intensional polymorphism in type-erasure semantics", "url": "http://dl.acm.org/citation.cfm?id=289459"}