{"article_publication_date": "09-29-1998", "fulltext": "\n A Structured Approach to Retrieving Functions by Types Nancy An and Young Park School of Computer Science \nUniversity of Windsor Email: nyaOO@,toraag.com, ypark@cs.uwindsor.ca Functional programming supports \nthe idea of reusing existing diction components to build a new fQnction component through features such \nas higher-order functions and parametric polymorphic functions. Retrieving fhnctions is an important \nprocess for function reuse. This poster addresses the problem of diction retrieval using types and of \norganizing the function library. There have been proposed methods of searching for fonctions by using \ntypes of the dictions as search keys [ 1,2,3, 4, 51. Runciman and Toyn [4] presented a method of retrieving \na function using the type of the function implicitly formulated from the contexts. In [2, 31 Rittri described \ntype-based retrieval methods in which the type of the desired fimction is explicitly formulated and the \nargument order of the desired function does not have to be provided by the user. Zarcmski and Wing [S] \nextended the retrieval by types to modules and to a variety of matches. All the above methods deal with \nthe retrieval problem from an unstructured library. In [l] Park and Ramjisingh presented a method of \nstructuring function components in a reuse library based on potential reusability among functions, and \ndescribed a type-based retrieval method from the hierarchically structured library. Two kinds of reusability \namong l5nctions were considered: reuse by type substitution and by argument substitution. The retrieval \nis more efficient thau the unstructured library baaed retrieval. The user can also browse the structured \nlibrary via the reusability links as an aid in finding reusable functions. However the user specifies \nthe order of arguments of the desired function. In this poster we propose a method of structuring a function \nlibrary aud an efficient type-based retrieval method based on the structured library. In searching for \nfunctions, the argument order of the diction needs not have to be given by the user as in [2, 31.Our \nmethod is based on an extended notion of regular types called set types in order to capture all the functions \nof the same type by ignoring the order of arguments. For example, an extended set type {list(inr), int) \n-> list(inr) contains the types list(int)-> int -> list(int) and int->list(inr)->list(int). Suppose that \nthe user wants to retrieve fitnctions with two arguments (the argument order is not important) such that \nthe type of one of the argument is fist(int) and the other argument s type is int, and the retum type \nis list(int). The user provides flist(int), int) -> list(int) (or equally {int, list(ingj -> list(int)) \nas the type of the desired function. The &#38;ction library is structured as follows: Currently at Amdabl \nSoftware, Mississauga, Ontario, Canada. Functions are divided into groups based on the number of arguments. \nFor each function group, a node is created for each set type. All functions whose types belong to the \nsame set type reside in the same node. An &#38;a-group reusability link is created between two nodes \nin the same function group. Let S1 and Sz be two set type nodes. If there exists some type t in S2 such \nthat some type s in S1 is an instance oft, then create the link f+om S1 to s*. An inter-group reusability \nlink is created between two nodes in two adjacent function groups. Let S and T be two set type nodes \nin hction group Giand Gi+l, respectively. If there exists some type t in T such that some type s in S \nis an instance oft that is obtained from t by removing one argument, then create the link f?om S to T. \nThe structuring process is done only when a diction is inserted into the library. Just traversing the \nstructured library and comparing the user-provided set type with the node set types does the retrieval \n(exact match). Retrieving more general functions (relaxed matches) are done by just following the intra \nand inter links without comparing with the node set types. The user can browse the structured library \n(similar to the class hierarchy in objected-programming) via the reusability links, which helps the users \nlearn more about possible reusability among functions. References VI Park, Y. and Ramjisingh, D. (1995) \nSoftware Component Base for Reuse in Functional Program Development. Proceedings of the International \nConference on Computing and Information, pp. 1022- 1039. PI Rittri, M. (1991) U&#38;g Types as Search \nKeys in Function Libraries. Journal of Functional Programming, l(1): 71- 89. [31 Rittri, M. (1990) Retrieving \nlibrary identifiers via equational matching of types. In M. E. Stickel, editor, Int. Conf. on Automated \nDeduction, vol.449 of Lecture Notes in Artificial Intelligence, pp. 603-617, Springer-Verlag. 141 Runcimau, \nC. and Toyn, I. (1991) Retrieving reusable so&#38;ware components by polymorphic type. Journal of Functional \nprogramming 1 (2): 19 l-2 11. [51 Zaremski, A. and Wing, J. (1993) Signature Matching: A Key to Reuse. \nProceedings of the ACM SIGSOFT Symposium on Foundation of Software Engineering, pp. 182-190. 344 \n\t\t\t", "proc_id": "289423", "abstract": "", "authors": [{"name": "Nancy An", "author_profile_id": "81100329695", "affiliation": "Amdahl Software, Mississauga, Ontario, Canada and School of Computer Science, University of Windsor", "person_id": "P206798", "email_address": "", "orcid_id": ""}, {"name": "Young Park", "author_profile_id": "81542250756", "affiliation": "School of Computer Science, University of Windsor", "person_id": "PP31029897", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/289423.289473", "year": "1998", "article_id": "289473", "conference": "ICFP", "title": "A structured approach to retrieving functions by types", "url": "http://dl.acm.org/citation.cfm?id=289473"}