{"article_publication_date": "09-29-1998", "fulltext": "\n The Under-Appreciated Unfold Jeremy Gibbons Geraint Jones School of Computing and Math. Sciences Oxford \nUniversity Computing Lab Oxford Brookes University Wolfson Building, Parks Road Gipsy Lane, Headington, \nOxford OX1 3QD, UK. Oxford OX3 OBP, UK. Email: geraintacomlab . ox. ac . uk Email: j gibbonsQbrookes \n. ac . uk Abstract Folds are appreciated by functional programmers. Their dual, unfolds, are not new, \nbut they are not nearly as well appreciated. We believe they deserve better. To illustrate, we present \n(indeed, we calculate) a number of algorithms for computing the breadth-first traversal of a tree. We \nspe- cify breadth-first traversal in terms of level-order traversal, which we characterize first as a \nfold. The presentation as a fold is simple, but it is inefficient, and removing the ineffi-ciency makes \nit no longer a fold. We calculate a character- ization as an unfold from the characterization as a fold; \nthis unfold is equally clear, but more efficient. We also calcu- late a characterization of breadth-first \ntraversal directly as an unfold; this turns out to be the standard queue-based algorithm. Keywords: Program \ncalculation, functional program- ming, fold, unfold, anamorphism, co-induction, traversal, breadth-first, \nlevel-order. Introduction Folds are appreciated by functional programmers. The benefits of encapsulating \ncommon patterns of computation as higher-order operators instead of using recursion directly are well-known \nand well understood [14]. The dual notion to folds, unfolds, have been explored by Hagino (lo] and Malcolm \n[16], and popularized at this conference by Meijer et al [18]. Unfolds are certainly not new, but they \nare not nearly as well appreciated as folds. (For example, they merit just half a page in [4], and have \ndisappeared altogether in [3]. Co-inductive types warrant a few pages in [23], but apart from that there \nare no other mentions in the fourteen func-tional programming textbooks on our shelves.) We believe unfolds \ndeserve a much higher profile. To illustrate this claim, we present (indeed, we calcu-late) a number \nof algorithms for computing the breadth-first traversal of a tree in a pure functional language. This \nis a thorny problem for functional programmers, in contrast to the more natural depth-first traversal: \ndepth-first traversal runs with the grain of the tree, but breadth-first traversal runs against the grain. \nNevertheless, we can construct a simple and elegant characterization of breadth-first traversal in terms \nof level-order traversal, which we characterize as a fold. Unfortunately, this characterization is inefficient, \nand in order to remove the inefficiency we must resort to a mere recursive definition (or to a higher-order \nfold). In contrast, from the fold characterization of level-order traversal we can calculate an unfold \ncharacterization. The unfold characterization is equally clear, but apparently less obvious, even to \nexperienced functional programmers. (We have been talking about this topic to various audiences for five \nyears, but have only recently discovered the unfold char-acterization.) Moreover, the unfold characterization \nis effi- cient, taking linear time. Best of all, it is easier to manip-ulate; in particular, it leads \neasily to a deforested program with no unnecessary data structures. Taking a different route, we can \nalso calculate a char- acterization of breadth-first traversal directly as an unfold. This turns out \nto be the standard queue-based algorithm which, with a little extra work to make the queue operations \nefficient, also takes linear time. The remainder of this paper is structured as follows. In Section 2, \nwe briefly present our notation. In Section 3, we define breadth-first traversal, in terms of level-order \ntra-versal. In Section 4, we present the characterization of level- order traversal as a fold, and show \nthat it is inefficient; we then calculate the efficient characterization that ceases to be a (first-order) \nfold. In Section 5, we calculate the char-acterization of level-order traversal as an unfold from the \ncharacterization as a fold, and show that it is linear. Fin-ally, in Section 6 we calculate as an unfold \nthe standard queue-based algorithm for breadth-first traversal. 2 Notation We will be using Haskell notation \n[22], but the translation into nearly any modern functional language is straightfor- ward. 2.1 Folds \nover lists We will be using two kinds of fold on lists: the normal fold right , foldr :: (a->b->b) -> \nb -> [a] -> b foldr op e Cl = e foldr op e (a:x) = a op foldr op e x (here, the function op is converted \ninto a binary operator op by writing it in backquotes) and a restricted version for non-empty lists, \ndetermined by foldrl op (x++Cal) = foldr op a x The two are related by the property that, for non-empty \nx, foldr op e x = foldrl op x when e is a right unit of op. The normal fold enjoys a universal property, \nessentially saying that the definition of foldr, treated as an equation in the unknown f oldr op e, \nhas a unique (strict) solution. In other words, for strict h, h = foldr op e = - h[]=e A h (a:x) = a \nop h x  A number of promotion properties are simple consequences of the universal property: fold-map \npromotion: if f is strict and f (a op b) = f a 0~2 f b then f . foldr op e = foldr op2 (f e) . map f \n f . foldrl op = foldrl op2 . map f  fold-join promotion: if h = foldr op e . map f where op is associative \nwith identity e, then h (xs ++ ys> = h xs op h ys fold-concat promotion: if h = foldr op e . map f where \nop is associative with identity e, then h . concat = foldr op e . map h  2.2 Unfolds over lists We also \nuse unfolds [lo, 16, 181, a dual to folds. The stand-ard construction of unfolds [16] gives the characterization \nunfold : : (b -> Either 0 (a,b)) -> b -> [a] unfold pfg x = case pfg x of Left 0 -> Cl Right (a,y> -> \na : unfold pfg y but we will find it more convenient to use the equivalent characterization unfold :: \n(b->Bool) -> (b->a) -> (b->b) -> b -> [a] unfold p f g x 1 Px = [I I otherwise = f x : unfold p f g (g \nx) Unfolds too enjoy a universal property, saying that the above definition, considered as an equation \nin the unknown unfold p f g, has a unique solution. In other words, h = unfold p f g zz - h x = if p \nx then [I else f x : h (g x)  We work in the setting CPO of continuous functions between pointed complete \npartial orders, as advocated by Meijer et al [18], instead of the setting SET of total func-tions between \nsets originally used by Hagino [lo] and Mal-colm [16], in order better to match the semantics of most \nfunctional programming languages. In particular, because of the treatment of infinite data structures \nin SET, the data structures generated by unfolds are different from the data structures consumed by folds, \nso folds and unfolds cannot be composed; in CPO, the two kinds of data structure are the same. 2.3 Trees \nOur trees are represented by the datatype data Tree a = Nd a [Tree al of rose trees [17]. That is, a \ntree of type Tree a consists of a root label of type a and a list of children, each again of type Tree \na. We define the two deconstructors root and kids: root :: Tree a -> a root (Nd a ts> = a kids : : Tree \na -> [Tree al kids (Nd a ts> = ts Actually, we carry out most calculations on forests, lists of trees; \nit turns out simpler that way. We use the type syn-onym type Forest a = [Tree al  2.4 Folds over trees \nThe datatypes of trees and forests are mutually recursive, so folds over trees and forests are too. We \ndefine the two folds as follows: foldt : : (a->c->b) -> ([b]->c> -> Tree a -> b foldt f g (Nd a ts> = \nf a (foldf f g ts) foldf :: (a->c->b) -> ([b]->c) -> Forest a -> c foldf f g ts = g (map (foldt f g) \nts> For example, the function sumt, which sums a tree of num- bers, is given by sllInt :: Tree Int -> \nInt sumt = foldt (+> sum (where sum sums a list of numbers), and the corresponding function sumf on \nforests by sumf : : Forest Int -> Int sumf = foldf (+> sum 3 Breadth-first traversal A tree traversal \nis an operation that, given a tree, computes a list consisting of all the elements of the tree in some \nor-der. One example of a tree traversal is preorder traversal, in which every parent appears in the traversal \nbefore any of its children, and siblings appear in left-to-right order. For example, the preorder traversal \nof the tree QI to compute the level-order traversals of trees and forests, respectively. For example, \nthe level-order traversal of the forest 2 3 5 6 7 234 is thelist [1,2,5,6,3,4,71. Preorder traversal, \npostorder traversal (in which a parent appears after all its children) and inorder traversal (which only \nmakes sense on binary trees, and in which a parent ap-pears between its two children) are all examples \nof depth-first traversals. They are easy to implement in a pure functional language, because they naturally \nfollow the structure of the tree-that is, they can be expressed as folds over trees. For example, preorder \ntraversal of a tree is given by preordert :: Tree a -> [a1 preordert = foldt (:> concat In contrast, \nbreadth-first traversal goes against the struc- ture of the tree. The breadth-first traversal of a tree \ncon-sists first of the root (the only element at depth l), then of all the elements at depth 2, and so \non. For example, the breadth-first traversal of the tree above is Cl, 2,3,4,5,6,71. It is not nearly \nso obvious how to implement breadth-first traversal efficiently in a pure functional language. In par-ticular, \nbreadth-first traversal is not a fold, because the tra-versal of a forest cannot be constructed from \nthe traversals of the trees in that forest. The standard implementation of breadth-first traversal in \nan imperative language involves queues, which are awkward to express functionally because they require \nfast access to both ends of a list. In contrast, depth-first traversals are based on stacks, which come \nfor free with recursive programs. It is possible to express the standard queue-based al-gorithm efficiently \nin a pure functional language; indeed, we do so in Section 6. However, this algorithm is unsatis- factory \nin a functional language, for two reasons. For one thing, a little effort is required to implement queues \nwith (amortized) constant time operations, which is necessary to get a linear-time program. For another, \nthe queue-based al-gorithm really describes a process rather than a value, and so is rather low-level; \nin a declarative language, we would prefer a more declarative specification of the problem (even if we \nthen develop a more operational implementation). We find this more declarative characterization of breadth-first \ntraversal in the notion of level-order traversal [7, 81 of a tree. This gives the elements on each level \nof the tree, as a list of lists (and so, strictly speaking, this is not a traversal according to our \ndefinition). For example, the level-order traversal of the tree above is the list of lists C Cl], [2,3,41, \n[5.6,71 1 Given the level-order traversal, the breadth-first traversal is easy to construct: simply \nconcatenate the levels. 4 Tbaversalas a fold In this section, we will present a characterization of level- \norder traversal as a fold over trees and forests. That is, we will define the two related functions levelt \n: : Tree a -> [[a11 levelf : : Forest a -> [[a]] is the list of lists I: C1,3,51, [2,3,4,4,51, [5,6,71 \n1 Given the level-order traversal of a tree or forest, the breadth-first traversal is formed by concatenating \nthe levels: bftt :: Tree a -> [a] bftt = concat . levelt bftf :: Forest a -> [a1 bftf = concat . levelf \n Now, the level-order traversal of a forest is found by glu- ing together the level-order traversals \nof the trees in that forest. Two lists of lists can be glued together in the ap-propriate way by the \nfunction lzc (standing for long zip with concatenate ). Long zip with is related to the stand- ard function \nzipWith, but it returns a list as long as its longer argument, whereas zipWith returns a list as long \nas its shorter argument. Formally, we have lzc :: [[all -> [Call -> [Call lzc = lzw (++>  where lzw \n:: (a->a->a) -> [a] -> [a] -> [a] lzw op xs ys I null xs = ys I null ys = xs l otherwise = (head xs op \nhead ys) : lzw op (tail xs) (tail ys) (Note that lzw op is associative when op is.) Therefore we define \nthe function glue, to glue together the traversals of the trees in a forest, as follows: glue :: CCCalll \n-> [Call glue = foldr lzc Cl  The level-order traversal of a tree consists of the root of the tree pushed \non to the traversal of the forest that forms its children, so we define push :: a -> [Call -> [[all push \na xss = [al : xss  Now we can define the two functions levelt and levelf, returning the level-order \ntraversal of a tree and a forest re-spectively, by levelt : : Tree a -> [[a11 levelt = foldt push glue \n levelf : : Forest a -> [[a] 1 levelf = foldf push glue  (In passing, we observe that lzw f = uncurry \n(lzw f) is an unfold: lzw :: (a->a->a> -> ([al, [al) -> [al lzw op = unfold p f g where p (xs, ys) = \nnull xs &#38;&#38; null ys f (xs,ys) I null ys = head xs I null xs = head ys I otherwise = head xs op \nhead ys g (xs,ys) = (tail xs, tail y.5) tail zs I null 2s = Cl I otherwise = tail zs However, this uncurried \nversion is inconvenient to use, be- cause the standard definition of f oldr requires a curried op-erator. \nMoreover, this version is less efficient than the direct recursion, because it takes time proportional \nto the length of the result, whereas the direct recursion only traverses the shorter argument.) 4.1 Traversal \nas a fold in linear time This characterization of level-order traversal (and hence of breadth-first traversal) \ndoes not take linear time, even using the efficient long zip lzw. Consider for example the forest ts \n= [ Nd 1 [t,ul , Nd 2 [v,wl 1 where tl u, v and w are four trees. Unfolding the definitions, we have \nlevelf ts = lzc ([II : lzc (levelt t) (lzc (levelt u> [I>> (lzc CC21 : lzc (levelt v> (lzc (levelt w> \n[I))) [I  Note that levelt t and levelt u must be traversed once each to compute levelf [t , ul , and \nthen traversed again to compute levelf ts. In a complete binary tree of depth d, the level-order traversals \nof the deepest trees will be re- traversed d-l times; the whole algorithm takes time propor-tional to \nthe size of the forest times its depth. The standard technique of introducing an accumulating parameter \n[1] can be used to remove this inefficiency. We introduce two auxilliary functions levelt. and levelf \n, defined by levelt :: Tree a -> [[a]] -> [[a]] levelt t xss = lzc (levelt t> xss levelf J :: Forest \na -> [Call -> [[al] levelf ts xss = lzc (levelf ts) xss This is a generalization, because levelt t = \nlevelt t [I levelf ts = levelf ts [I Now, for levelf we have levelf [I xss = { levelf j } lzc (levelf \n[I> xss = { levelf, lzc } xss and levelf (t:ts) xss = { levelf } lzc (levelf (t:ts)) xss = { levelf \n} lzc (lzc (levelt t> (levelf ts>> xss = { lzc is associative } lzc (levelt t> (lzc (levelf ts> xss) \n= { levelt , levelf ) } levelt t (levelf J ts xss)  For levelt , we have to consider separately the \ntwo cases whether or not xss is empty. When xss is empty, we have levelt (Nd a ts> xss = { levelt } \nlzc (levelt (Nd a ts>) xss = { lzc; xss is empty } levelt (Nd a ts) = { levelt } : levelf ts = ;a{a \n, l ,t ,;,l > ts [] and when xss is non-empty, we have levelt (Nd a ts) xss = { levelt } lzc (levelt \n(Nd a ts>) xss = { levelt } lzc ([al :levelf ts> xss = 1 lzc: xss is non-empty ) \\ (a:head xss> : lzc \n&#38;Glf ts> (tail xss) = { levelf } (a:head xss) : levelf ts (tail xss)  Hence we can define levelt \n:: Tree a -> CCall -> [Call levelt (Nd a ts> xss = (a:ys) : levelf ts yss where (ys,yss) I null xss = \n(Cl,Cl) I otherwise = (head xss,tail xss) levelf :: Forest a -> [[all -> [[all levelf ts xss = foldr \nlevelt xss ts which takes linear time. (The efficient long zip lzw is neces- sary here; with the unfold \nversion lzw the program is still quadratic in the worst case.) Unfortunately, this efficient characterization \nof level-order traversal is no longer a fold: the traversal of a forest is not constructed from the independent \ntraversals of the trees in that forest, but rather, the trees must be considered from right to left, \nthe traversal of one being used as a starting point for constructing the traversal of the next. This \nis sad, because we have to resort to expressing the recursion directly, losing the benefits of higher-order \noperators [14]. Apart from being more difficult to read, this direct recur-sion is no longer suitable \nfor parallel evaluation, because the accumulating parameter is single-threaded throughout the computation. \nIt is possible to regain a characterization as a fold, but taking linear time, by abstracting from the \naccumulating parameter and constructing instead a function between lists of lists, in a continuation-based \n[26] or higher-order fold [6] style: levelt  :: Tree a -> [[all -> [[all levelt = foldt f g where f \na has = (a:> : hss g = foldr (lzw (.>I Cl levelf  :: Forest a -> [[a]] -> [[al] levelf = foldf f g \n but this is even more complicated, and moreover it requires higher-order language features, and so \ncannot be used in more traditional languages. 5 Traversal as an unfold In this section, we calculate \na characterization of levalf as an unfold. We have to find p, f and g such that levelf = unfold p f g \n Since a non-empty forest has a non-empty traversal, levelf ts = [I E null ts which determines p; it \nremains only to consider non-empty forests. head . levelf = { levelf } head . foldr lzc [I . map levelt \n= { foldr lzc [I = foldrl lzc on non-empty lists } head . foldrl lzc . map levelt = { fold-map promotion: \nfor non-empty xs, ys, head (lzw f xs ys) = f (head xs> (head ys) } foldrl (++I . map head . map levelt \n= { head . levelt = wrap . root, where wrap a = [al } foldrl (++> . map wrap . map root = { foldrl (++> \n. map wrap = id on non-empty lists } map root and tail . levelf = { levelf } tail . foldr lzc [I . map \nlevelt = { foldr lzc [I = foldrl lzc on non-empty lists } tail . foldrl lzc . map levelt = { fold-map \npromotion: for non-empty xs, ys, tail (lzw f xs ys> = lzw f (tail xs> (tail ys) } foldrl lzc . map tail \n. map levelt = { tail . levelt = levelf . kids } foldrl lzc . map levelf . map kids = fo;Eyz; cp1 e \n= foldrl op on non-empty lists } . map levelf . map kids = { fold-concat promotion } levelf . concat \n. map kids Therefore, levelf is an unfold as well as a fold: levelf = unfold null (map root) (concat \n. map kids)  We can write levelt using levelf: levelt t = levelf Ctl which gives a characterization \nof levelt using an unfold too. This gives us another linear-time algorithm for level-order traversal; \nthis algorithm is no more complicated (in-deed, it is arguably simpler) than the characterization as \na fold, but it is more efficient. Moreover, we will see sub- sequently that it is also amenable to manipulation; \nto con-clude this section, we will use deforestation [25] to eliminate the intermediate list of lists \nconstructed during the breadth- first traversal. 5.1 Deforestation As hinted at above, one of the benefits \nthat accrues from expressing levelf as an unfold is that bftf is then a hy-lomorphism, that is, an unfold \nfollowed by a fold. Hylo-morphisms proceed in two stages, the first producing a data structure and the \nsecond consuming it. With lazy evalu-ation, the intermediate complex data structure need never exist \nas a whole-the producer and consumer phases op-erate concurrently-but it is still advantageous to fuse \nthe two phases into one, to reduce the amount of heap space turned over. This transformation is known \nas deforestation [25], and is now a standard technique; indeed, it can even be performed mechanically \n[13, 211. To be specific, we will use deforestation on functions of the form h = foldr op e . unfold \np f g Consider first the case that p holds of the argument: =h;hj foldr op e (unfold p f g x) = { assumption: \np x holds; unfold } foldr op e Cl = { foldr } e  When p x does not hold, we have =h;hj f oldr op e (unfold \np f g x) = { assumption: p x does not hold; unfold } foldr op e (f x : unfold p f g (g x)) = { foldr \n} f x op foldr op e (unfold p f g (g x)) = {hl f x op h (g x>  Therefore hx Ipx =e I otherwise = f x \n'op h (g x)  Applied to breadth-first traversal, deforestation gives the program bftf ts I null ts = \nCl I otherwise = map root ts ++ bftf (concat (map kids ts)) (In fact, the version generated automatically \nby HYLO [21] also deforests away the ++ and the concat . map kids.) This program was shown to us by Bernhard \nKller [lQ]. It is certainly elegant, but it is rather low-level; in particular, it uses recursion directly \nrather than encapsulating it with a higher-order operator. It is gratifying to find that this program \narises as a compiler optimization from our more abstract characterization. 6 Traversal using a queue \nIt turns out that the standard queue-based traversal al-gorithm arises from expressing bftf directly \nas an unfold, starting from the characterization of level-order traversal as a fold. The calculation \ndepends crucially on the following property of lzw: if op is associative, then foldr op e (lzw op (x: \nxs) ys) =x op foldr op e (lzw op ys xs)  For example, concat (lzc Cxsl ,xs21 [ysl ,ys2 ,ys3]) = { l=c \n1 concat [xsl ++ ysl, xs2 ++ ys2, ysd] = { concat } (xsl ++ ysl) *+ (xs2 ++ ys2) ++ ye3 = { associativity \n) xsl ++ (ysl ++ xs2) ++ ys2 ++ ys3 = { concat, lzc } xsl ++ concat (lzc [ysl,ys2,ys3] [xs2]>  The proof \nof this property, by induction on xs, is straight- forward and is omitted. Returning to traversal, clearly \nwe have bftf ts = [I z null ts For a non-null forest, we have bftf (Nd a us : ts) = { bf tf, levelf \n} concat (foldr lzc [I (map levelt (Nd a us : ts>>> = { map, foldr } concat (lzc (levelt (Nd a us)) (foldr \nlzc [I (map levelt ts))) = { levelf } concat (lzc (levelt (Nd a us)) (levelf ts)) = { levelt } concat \n(lzc ([al : levelf us) (levelf ts)) Z.Z { crucial property } Cal ++ concat (lzc (levelf ts) (levelf \nus)) = { fold-join promotion: levelf (ts ++ us) = lzc (levelf ts> (levelf us) } Cal ++ concat (levelf \n(ts ++ us)) z { ++; bftf } a : bftf (ts ++ us) Therefore, we have bftf = unfold null f g where f (Nd \na us : ts) = a g (Nd a us : ts) = ts ++ us  --the standard queue-based traversal algorithm. Again, it \nis rather low-level, and it is gratifying to be able to derive it from a more abstract specification. \nOf course, this program is not linear-time: appending the children us of the first tree to the end of \nthe queue ts takes time proportional to length ts, which grows linearly in the size of the tree, so the \nprogram is quadratic. To make it take linear time, we could use a clever data structure that allows queue \noperations in amortized constant time [12, 201, but here the simpler technique [5, 9, 111 of using two \nlists, one reversed, suffices. That is, the idea is to introduce a function bftf such that bftf (ts,vs) \n= bftf (ts ++ reverse vs> where reverse reverses a list; then bftf ts = bftf (ts, Cl) and straightforward \ncalculations lead to the characterization bftf :: (Forest a,Forest a) -> [al bftf ([I,[]> = Cl bftf (13 \n,vs> = bftf (reverse vs, [I> bftf (Nd a us : ts,vs) =a: bftf (ts,reverse us ++ vs) of bftf . In fact, \nbftf * is an unfold, too: bftf = unfold p f g where p (ts,vs) = null ts &#38;&#38; null vs f ([l,vs) \n= f (reverse vs, [I > f (t:ts, vs) = root t g (Cl,vs> = g (reverse vs, [I > g (t:ts, vs) = (ts, reverse \n(kids t) ++ vs) Expressing bftf in this way entails two reversals of the second list, one for f and \none for g, when the first list runs out. This is an artifact of our choice of characterization of unfold; \nthe standard characterization would entail just one reversal. Acknowledgements This paper arose from \na discussion late in 1992 on the Usenet newsgroup camp. lang . f unct ional, on how to per-form breadth-first \ntraversal in a functional language. We wrote an earlier paper [15] giving derivations of our solu-tions, \nand also giving a rather complicated derivation of an algorithm for breadth-fist labelling, a kind of \ninverse of breadth-first traversal originally posed to us by Joe Fasel: given is a tree t and a list \nx, and the problem is to con-struct a tree of the same shape as t but with breadth-first traversal x. \nIn response to that earlier paper, Bernhard Mailer [lQ] showed us the elegant traversal algorithm presented \nhere in Section 5.1. This led to the much simpler derivations presen-ted here, and indirectly to our \nobservation that unfolds are greatly under-appreciated, even in the functional program-ming community \n(not least by ourselves at the time). We are grateful to the Problem Solving Club at Oxford University \ncomputing Laboratory, to Gravham Hutton and Colin Runciman. and to attendees at the IFIP Working Group \n2.1 meetihgs in Winnipeg and in Oxford, for thei; help in polishing the derivations presented here; also, \nwe thank Zhenjiang Hu and Yoshiyuki Onoue for their experi-ments with the HYLO system. References Geraint \nJones and Jeremy Gibbons. Linear-time 1151 Richard S. Bird. The promotion and accumulation PI strategies \nin transformational programming. ACM Transactions on Programming Languages and Systems, 6(4):487-504, \nOctober 1984. See also [2]. Richard S. Bird. Addendum to The promotion and PI accumulation strategies \nin transformational program- ming . ACM Transactions on Programming Languages and Systems, 7(3):490-492, \nJuly 1985. Richard S. Bird. Introduction to Functaonal Program- 131 ming Using Haskell. Prentice-Hall, \n1998. Richard S. Bird and Philip L. Wadler. An IntroductionPI to Functional Programming. Prentice-Hall, \n1988. F. Warren Burton. An efficient functional implement- 151 ation of FIFO queues. Information Processing \nLetters, 14(5):205-206, July 1982. Leonidas Fegaras and Tim Sheard. Revisiting cata- PI morphisms over \ndatatypes with embedded functions. In 23rd ACM SIGPLAN Symposium on Principles of Programming Languages, \npages 284-294, St Petersburg Beach, Florida, 1996. Jeremy Gibbons. Algebras for Tree Algorithms. D. Phil. \n [71 thesis, Programming Research Group, Oxford Uni-versity, 1991. Available as Technical Monograph PRG- \n94. Jeremy Gibbons. Deriving tidy drawings of trees. PI Journal of Functional Programming, 6(3):535-562, \n1996. Earlier version appears as Technical Report No. 82, Department of Computer Science, University \nof Auckland. [Ql David Gries. The Science of Programming. Texts and Monographs in Computer Science. \nSpringer-Verlag, 1981. Tatsuya Hagino. A typed lambda calculus with categor- PO1 ical type constructors. \nIn D. H. Pitt, A. PoignB, and D. E. Rydeheard, editors, LNCS 283: Category Theory and Computer Science, \npages 140-157. Springer-Verlag, September 1987. Robert Hood and Robert Melville. Real-time queue op- \n WI erations in pure Lisp. Information Processing Letters, 13(2):50-53, 1981. Rob Hoogerwoord. A symmetric \nset of efficient PI list operations. Journal of Functional Programming, 2(4):505-513, 1992. Zhenjiang \nHu, Hideya Iwasaki, and Masato Takei- 1131 chi. Deriving structural hylomorphisms from recursive definitions. \nIn International Conference on Functional Programming. ACM/SIGPLAN, 1996. John Hughes. Why functional \nprogramming matters. M Computer Journal, 32(2):98-107, April 1989. Also in 1241. breadth-first tree \nalgorithms: An exercise in the arith-metic of folds and zips. Computer Science Report No. 71, Dept of \nComputer Science, University of Auck- land, May 1993. Also IFIP Working Group 2.1 working paper 705 WIN-2. \nGrant Malcolm. Data structures and program trans- W formation. Science of Computer Programming, 14:255-279, \n1990. Lambert Meertens. First steps towards the theory of P71 rose trees. CWI, Amsterdam; IFIP Working \nGroup 2.1 working paper 592 ROM-25, 1988. Erik Meijer, Maarten Fokkinga, and Ross Pater- M son. Functional \nprogramming with bananas, lenses, envelopes and barbed wire. In John Hughes, ed-itor, LNCS 523: Functional \nProgramming Languages and Computer Architecture, pages 124-144. Springer-Verlag, 1991. PQIBernhard MGller. \nPersonal communication, May 1.993. Chris Okasaki. Simple and efficient purely functional PO1 queues \nand deques. Journal of Functional Program-ming, 5(4):583-592, 1995. Yoshiyuki Onoue, Zhenjiang Hu, Hideya \nIwasaki, and 1211 Masato Takeichi. A calculational fusion system HYLO. In Richard Bird and Lambert Meertens, \neditors, Al-gorithmic Languages and Calculi, pages 76-106. Chap-man and Hall, 1997. John Peterson, Kevin \nHammond, Lennart Augustsson, PI Brian Boutel, Warren Burton, Joseph Fasel, Andrew D. Gordon, John Hughes, \nPaul Hudak, Thomas Johns-son, Mark Jones, Erik Meijer, Simon Peyton Jones, Alastair Reid, and Philip \nWadler. The Haskell 1.4 re- port. bttp://uww.haskell.org/report/, April 1997. Simon Thompson. Type Theory \nand Functional Pro- [231 gramming. Addison-Wesley, 1991. David A. Turner, editor. Research Topics in \nFunctional P41 Programming. University of Texas at Austin, Addison- Wesley, 1990. Philip Wadler. Deforestation: \nTransforming programs [251 to eliminate trees. Theoretical Computer Science, 73:231-248, 1990. Mitchell \nWand. Continuation-based program trans- P31 formation strategies. Journal of the ACM, 27(1):164-180, \nJanuary 1980.   \n\t\t\t", "proc_id": "289423", "abstract": "<i>Folds</i> are appreciated by functional programmers. Their dual, <i>unfolds</i>, are not new, but they are not nearly as well appreciated. We believe they deserve better. To illustrate, we present (indeed, we calculate) a number of algorithms for computing the <i>breadth-first traversal</i> of a tree. We specify breadth-first traversal in terms of <i>level-order traversal</i>, which we characterize first as a fold. The presentation as a fold is simple, but it is inefficient, and removing the inefficiency makes it no longer a fold. We calculate a characterization as an unfold from the characterization as a fold; this unfold is equally clear, but more efficient. We also calculate a characterization of breadth-first traversal directly as an unfold; this turns out to be the 'standard' queue-based algorithm.", "authors": [{"name": "Jeremy Gibbons", "author_profile_id": "81339501222", "affiliation": "School of Computing and Math. Sciences, Oxford Brookes University, Gipsy Lane, Headington, Oxford 0X3 OBP, UK", "person_id": "PP43126432", "email_address": "", "orcid_id": ""}, {"name": "Geraint Jones", "author_profile_id": "81341492020", "affiliation": "Oxford University Computing Lab, Wolfson Building, Parks Road, Oxford OX1 3QD, UK", "person_id": "PP31083502", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/289423.289455", "year": "1998", "article_id": "289455", "conference": "ICFP", "title": "The under-appreciated unfold", "url": "http://dl.acm.org/citation.cfm?id=289455"}