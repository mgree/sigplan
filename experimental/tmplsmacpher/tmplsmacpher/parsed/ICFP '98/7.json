{"article_publication_date": "09-29-1998", "fulltext": "\n PLAN: A Packet Language for Active Networks Michael Hicks, Pankaj Kakkar, Jonathan T. Moore, Carl A. \nGunter, and Scott Nettles * Department of Computer and Information Science University of Pennsylvania \n Abstract PLAN (Packet Language for Active Networks) is a new lan-guage for programs that form the packets \nof a programmable network. These programs replace the packet headers (which can be viewed as very rudimentary \nprograms) used in cur-rent networks. As such, PLAN programs are lightweight and of restricted functionality. \nThese limitations are miti-gated by allowing PLAN code to call node-resident service routines written \nin other, more powerful languages. This two-level architecture, in which PLAN serves as a scripting or \nglue language for more general services, is the primary contribution of this paper. We have successfully \napplied the PLAN programming environment to implement an IP-free internetwork. PLAN is based on the \nsimply typed lambda calculus and provides a restricted set of primitives and datatypes. PLAN defines \na special construct called a chunlc used to describe the remote execution of PLAN programs on other nodes. \nPrimitive operations on chunks are used to provide basic data transport in the network and to support \nlayering of protocols. Remote execution can make debugging difficult, so PLAN provides strong static \nguarantees to the program- mer, such as type safety. A more novel property aimed at protecting network \navailability is a guarantee that PLAN programs use a bounded amount of network resources. 1 Introduction \nActive networking is all about getting programmability into the network. -Jonathan Smith Modern packet-switched \nnetworks, like the Internet, trans-port data in packets that consist of a header, containing control \ninformation, and a payload, containing the data it-self. The header may be viewed as a primitive program \nin the programming language defined by the packet format specification. This program is interpreted by \nthe protocol software in the routers, and the execution of the program causes the packet to be sent to \nthe next router along the path to the destination. If new functionality needs to be added to the protocol \nthen the packet format and its seman-tics must change. Or, using our analogy, the programming language \nand its specification must change. For a widely deployed protocol, such as IP [23], changes to the packet \nformat must be deliberated and agreed upon by a standards body. As a consequence, the introduction of \nnew network services at this level is very slow. For example, there was a span of five or more years \nfrom the time RSVP was conceptualized [5] to the time it was deployed 1171, even in a very limited manner. \nActive networks are an approach to getting more flexi-bility at the IP (or similarly standardized) level \nby making the network infrastructure programmable. If the level of ab- straction could be raised from \nthat of the bits in IP packet headers to that of a more general programming language, the evolution of \nthe network could proceed at the pace of technology, since changes would occur at the level of the program-not \nthe programming language. If this idea is to be realized, a key question is: what programming interface \nis needed? This paper offers an ap-proach based on a two-level distinction between an interop- erability \nlayer based on a new programming language PLAN (Packet Language for Active Networks) and a level of node- \nresident services, which may be written in general-purpose languages. Each packet contains a PLAN program \nthat re-places the IP packet header and payload. These programs, in turn, tie together service calls \nto create more complex net-work functions (e.g., customized routing). Therefore, PLAN can be viewed as \na network-level glue language. More concretely, consider ping, one of the most basic network diagnostics. \nIn the current network, it must be provided as a special packet type in the ICMP [22] protocol. In an \nactive network, it can just be a program provided by a user. Here is how it is coded in PLAN (language \ndetails will be explained later): fun ping (src:host, dest:host) : unit = if (not thisHostIs(dest)) then \nOnFtemote(iping1 (src,dest), dest, getRB(), defaultRoute) else OnFtemote(lacklO, src, getFlB0, defaultRoute) \n fun ack() : unit = print( Success ) Ping works as follows. This program is placed in an active packet \nthat executes ping at the source. The packet is not at the destination and so the first OnRemote call \ncauses a packet to be sent that will invoke the ping function at the destination. Once there, the second \nOnRemote sends a packet that will invoke the ack function on the original source. Al- though simple, \nthis example shows that protocols can be built with PLAN without requiring encapsulation or the def- \ninition of new packet types. Later in the paper, we will also discuss how the PLAN programming environment \nwas used to implement all of the protocols necessary to support an in- ternetwork that does not depend \non IP. This is a testament to the high level of flexibility in our system, and flexibility is precisely \nwhat is needed to allow faster network evolution. Our decision to define a new language was driven by \na variety of unique requirements that are described in the next section. For instance, the need for programs \nthat fit within individual packets suggests the use of a scripting language. Mobility suggests the need \nfor a safe language, while net-work availability demands a way to limit the resource uti-lization of \nprograms. Since mobility is the main aim of the language, it is important to make its computational model \nfundamentally distributed, rather than provided by a spe- cial library extension. In the end, the choice \nwas to design a new language realizing all of these goals well, but relying on programs in other languages \nto provide other kinds of functions. The rest of the paper describes the PLAN language and system, its \narchitecture, and our implementation of it. We base our discussion on PLAN 3.0, our current design and \nimplementation, and at the end we consider some of the changes that might appear in future versions. \n2 Requirements and Design Any active networking approach must balance the tensions among the following \nissues: flexibility, safety and security, performance, and usability. To this end, our architecture partitions \nthe problem into two levels: the packet language level and the service language level, whose roles are \nsumma- rized in Table 1. PLAN, our packet language, is intended for high-level control, while most of \nthe complex functional-ity resides in services (which for maximum flexibility can be dynamically loaded \nover the network). This approach allows us to draw a clean boundary between lightweight and heavy- weight \nprogrammability. We now explore in more detail how our two-level architecture helps us to achieve specific \ndesign goals. 2.1 Flexibility Increased flexibility is the primary motivation for active net-working. \nThe key question is: how far should we go? He- Table 1: Comparison of the Packet and Service levels \ncause of our two-level approach, PLAN does not have to be completely general, because general purpose \nexpressibility is provided by the service level language. On the other hand, PLAN must be able to express \nlittle programs for network configuration and diagnostics, and to provide the distributed communication/computing \nglue that connects router resi-dent services into larger protocols. To do this, PLAN must: embody a model \nof distributed computing; have some sim-ple, transmissible datatypes; and perhaps most importantly, be \nable to cope with and recover from errors in a general way. PLAN moves us away from a world with a fixed \nset of op- erations, and into one where node-resident services can be easily combined on-the-fly. 2.2 \nSafety and Security The shared nature of a network (and especially the Inter- net) requires that security \nbe taken very seriously. Clearly, this means that increased programmability must be added in a safe and \nsecure manner. By safety we mean reducing the risk of mistakes or unintended behavior, and by security \nwe mean the usual concept of protecting privacy, integrity, and availability in the face of malicious \nattack. To address some of these concerns, we have made PLAN a functional, stateless, strongly-typed \nlanguage. This means that PLAN programs are pointer-safe, and concurrently executing pro-grams cannot \ninterfere with one another. The other aspects of security are more problematic. For one, network administrators \nwould like to prevent arbitrary users from altering their nodes in arbitrary ways. One pos- sible approach \nwould be to force the authentication of ev-ery packet. However, many common operations, such as data \ndelivery, do not require authentication in the current network; this suggests that authentication should \nbe possi- ble but not required. Therefore, we have chosen to restrict PLAN s expressibility so that it \nmay be authentication-free. Functionality requiring authentication can be made avail-able by using services, \nand we expect to leverage active net-working security research like the SANE project [l]. 2.3 Performance \nPLAN should offer new functionality without compromis-ing the performance of functionality offered by \nthe current network, particularly payload delivery. This would be im- possible if all PLAN packets had \nto be authenticated. A major benefit of keeping PLAN simple is that its interpre-tation can be lightweight, \nand thus common tasks can be done quickly. We have avoided adding heavyweight features to PLAN in the \nbelief that if such features are needed, they can be accessed at the service level. 2.4 Usability PLAN \nprograms execute remotely, which makes it difficult to determine the causes of unexpected behavior. Therefore, \nit is important to provide the PLAN programmer with a priori assurances about a program s behavior. We \nprovide some guarantees as part of our design: all PLAN programs are statically typeable and are guaranteed \nto terminate, as long as they only call service routines that terminate (more details on this termination \nguarantee will be given shortly). PLAN is based on the simply typed lambda calculus, making it easier \nto specify a formal semantics. The a ptiori guarantees mentioned above are made possible by the deep \nunderstanding of the lambda calculus in the programming languages community. As a supplement to these \nstatic guar-antees, however, PLAN should also provide some basic error handling facilities. 2.5 Why \na New Language? Now that the reader has a basic idea of the design goals for PLAN, we can revisit the \nquestion of why we need a new language. The need for PLAN to be very lightweight, which serves all of \nits design goals (except greater flexibility), is a compelling argument that no general purpose language \nis really suitable. In fact, the requirement that programs need not be authenticated would seem to make \nit insecure to use most general-purpose languages. On the other hand, the need to tailor the language \nto the active networking domain eliminates existing special-purpose languages. Our design is based on \nremote evaluation, rather than remote procedure call. Specifically, child active packets may be spawned \nand asynchronously executed on remote nodes. This is supplemented with the ordinary form of function \ncall in a language that resembles the simply typed lambda calculus. Our goal was to use the simplest \nand most basic set of assumptions that satisfied the requirements we have just outlined. 3 PLAN Description \nWe describe the PLAN language primarily by example, with a highlight of its key constructs . Although \nPLAN is based upon the simply typed lambda calculus, it is missing some features available in common \nfunctional programming lan-guages. We discuss these differences before moving on to a discussion of how \nPLAN s evaluation model addresses re-source bounding. 3.1 PLAN by Example Figure 1 shows a PLAN version \nof the utility traceroute, a diagnostic program that reports the path taken from a source node to a destination. \nThis version of traceroute visits each router between two hosts, collecting a list of nodes visited thus \nfar. At each node it sends this list back to its source to be printed, and creates a new packet that \nis sent to the next hop to continue the process. PLAN Packets and Chunks. Traceroute creates a number \nof PLAN packets that traverse the network. As shown in Ta- A conlplete gran~nar is found in Appendix \nA. More details can be found at http://uw.cis .upsnn.edu/-svitchuare/PLAN. fun print-host(h:host, count:int) \n: int = (print(h); print( : 1; print (count) ; print ( ) ; count+11 fun ack(l:host list) : unit = (foldr(print-host,l,l); \nprint( --\\n )) fun traceroute (src:host, dst:host, 1: host list, count :int) : unit = let val this:host \n= hd(thisHost0) in (OnRemote(lackl(this::l), src, count, defaultRoute); if (not (thisHostIs(dst)) then \nlet val p:(host * dev) = defaultRoute(dst) in OnNeighbor(ItracerouteI(src, dst, this::l, count+l), fst \np, getRB 0. snd p) end else 0) end Figure 1: The PLAN traceroute program Table 2: The PLAN packet ble \n22, the primary component of each packet is its chunk (short for code hunk), which consists of code, \na function name to serve as an entry point, and values to serve as bind- ings for the arguments of the \nentry function. The PLAN syntax I f I (a, b, c) designates a chunk containing the code required to execute \nthe (top-level) entry function f, and bindings having the values of the expressions a, b, and c. The \nother fields in the packet will be explained shortly. The traceroute program is depicted visually in \nFigure 2. Each arrow in Figure 2 is labeled with its entry function name, and the arrowheads indicate \nthe nodes on which the corresponding chunks will be evaluated. Thus all ack pack- ets are evaluated only \nat node A, the source, while the traceroute packets are evaluated at each node on the way to the destination. \nInjection. A host application constructs a PLAN packet and injects it into the active network via a port \nconnected to the local PLAN interpreter. This injection port is used by PLAN to provide output to the \napplication, and allows the application to submit new packets; it is shown as the pair of dashed lines. \nHere, the application creates a PLAN packet that is injected at host A with an evalDest of A, an initial \nThese are only those packet fields required by the PLAN Ian-guage definition; for exanlple, our active \ninternetwork implementa-tion PLANet defines additional fields to assist with special routing protocols. \n n - traceroutet Figure 2: Evaluation of the traceroute program chunk of I traceroute I (A, D, Cl, \n11, an RB of n, and a routlh of defaultRoute. Output from print is passed to the application through \nthe injection port. Remote Execution. PLAN programs create new pack-ets through calls to the network \nprimitives OnRemote and OnNeighbor. A prototype OnRemote call looks like: OnRemote ( C, eualDest, Rb, \nroutFun This call essentially means create a new packet that will evaluate the chunk C on node evalDest. \nThe bindings in the chunk are PLAN values and are evaluated locally, al-though the function application \nwill be delayed until the new packet arrives on the remote host. m&#38;Fun specifies the routing scheme \nfor the new packet, and Rb indicates how much of the current packet s resource bound is transferred to \nthe new packet. It is important to note that the implemen- tation of this primitive enforces that Rb \nbe positive but less than the resource bound of the current packet, thus ensuring that the overall resource \nbound cannot be increased. OnNeighbor is similar to OnRemote, except that the evalDest must be a neighbor \nof the current node, elimi-nating the need for routing. In the example, traceroute creates two new packets: \nthe backward packet, created by OnRemote, and the forward packet, created by OnNeighbor. Consider evaluation \nof the traceroute function on Host A: the backward packet has fields: chunk I ack I ( [Al 1, evalDest \nA, routFun defaultRoute, and an RB of 1, while the forward packet has fields: chunk I traceroute I (A, \nD, [Al , 21, evalDest B, and an RB of n -1. Routing. Once a packet is created, it is sent to its evalDest \nfor evaluation. The evalDest may be many hops away, so intermediate nodes need a way to determine the \nnext hop. This is done using the packet s routFun field, which names a service function that takes the \ndestination as an argument and returns the next hop towards that des-tination. At each hop, the RB field \nis decremented by one; if the resource bound is exhausted, the packet is terminated. In the example, \nthe routing function is defaultRoute, which is also used explicitly to determine the evalDest of the \nfor-ward packet. Since PLAN evaluation need not occur on the intermediate nodes, this sort of routing \ncan be imple- mented quite efficiently using the same techniques used by the current II network. 3.2 \nLanguage Characterization Since PLAN s semantic basis is the typed lambda calcu-lus, our examples should \nhave a familiar feel to functional programmers. However, PLAN is missing several common functional programming \nconstructs. We followed a policy of not adding a language feature unless: it was necessary for important \napplications, did not compromise security, pre- served all a priori guarantees, and enhanced the usability \nof PLAN. In that light, let us look at specific components of PLAN. Flow of Control. In keeping with \nour goal of simplic- ity, PLAN has simple flow of control constructs: statement sequencing, conditional \nexecution, iteration over lists with fold, and exceptions, all in the usual style. Although func-tion \ncalls are supported, notably absent are recursive func-tion calls. The lack of recursion and unbounded \niteration (as well as the monotonically decreasing resource bound in the packet) imply that. all PLAN \nprograms terminate. PLAN does not currently support higher order functions, but we have applications \nin mind that might be simplified by this addition. While in general PLAN does not support pattern-matching, \nwe do provide a binding form of exception han-dler, which we shall discuss shortly. The Type System. \nPLAN is strongly typed, and al-though it is mostly statically typeable, it is dynamically checked. This \narises from the demands of remote program-ming: static typeability is a benefit to help debugging before \ninjecting a program into the network, yet dynamic check-ing provides efficient safety (from the nodes \npoint of view) for mobile scripting code. Although PLAN is currently monomorphic, we see no reason not \nto add polymorphism; this may be the subject of future work. In addition to a fairly standard set of \nbase types, PLAN provides a homogeneous list type and a heterogeneous tuple type, but no support for \ngeneral recursive types, since their utility is questionable without general recursion. Instead, we are \nconsidering providing a set of built-in recursive data types, with accompanying tools. Scoping. PLAN \nis lexically-scoped, with the available ser-vices occupying the initial bindings in the namespace. Be-cause \nservice invocations are syntactically identical to nor-mal function invocations, a PLAN program may shadow \na service routine by defining a local function of the same name. By the same token, if a name fails to \nresolve at invocation time, the interpreter assumes the program is at- tempting to invoke an unavailable \nservice routine, and raises a ServiceNotPresent exception. The function named in a chunk expression like \nIf I (a) is invoked in a remote envi-ronment where nil top-level bindings are available; as such it does \nnot obey the usual lexical scoping of functions. This al-lows a form of yecursive function call to be \ndone with chunks and OnRemote, but such calls must decrement the resource bound, so such recursion must \nterminate. fun exnreport(h:host,e:exn):unit = (print( 1 raised 1; print(e) ; print ( I on 1; print(h) \n) fun main(home:host,...) = try . . . handle e => abort(lexnreportI (hd(thisHostO,e))) Figure 3: A \ngeneral error-reporting mechanism Mutable state. PLAN does not provide user-defined mu-table state, although \nsome aspects of PLAN, such as the resource bound, are stateful. Not providing state simplifies PLAN in \na number of important ways. Firstly, it simpli-fies transmitting PLAN values to remote nodes, since values \ncan be copied without changing their meaning. Secondly, concurrently running PLAN programs can only share \nstate through service routines, which implies that only the service language must concern itself with \nconcurrency.  3.3 Error handling Although PLAN provides a basic exception handling mech-anism, this \nis not sufficient for handling all errors in the PLAN system. To make sure that the programmer is noti- \nfied when something goes wrong, the PLAN system provides two main error handling mechanisms. Firstly, \nan abort ser-vice is provided which allows a program to execute a chunk on its source node. This is accomplished \nby extracting the source from the packet header, sending an error packet car-rying the chunk back to \nthe source, discarding any remaining resource bound, and then evaling (see Section 3.4 below) the chunk. \nThe abort service coupled with exception handling provides a reasonably flexible error-handling mechanism; \nan example is shown in Figure 3. However, evaluation on remote nodes may raise excep-tions not ant,icipated \nby the programmer, and some errors are severe enough that they cannot be handled within PLAN (for example, \na transmission error may result in a type-incorrect program). For these cases, we provide a mecha- nism \nfor error handling through a special field in the packet header. The handler field names a service to \nbe invoked on the source in case an error or exception not handled in the program is raised. This essentially \ncorresponds to an implicit call to the abort service where the chunk to be ex- ecuted is simply a call \nto the named handler service. 3.4 Encapsulation Chunks are first-class values in PLAN, and as such, \nthey can be included in the bindings lists of other chunks. In addition, PLAN provides an eval primitive \nto invoke a chunk. To-gether, these features allow chunks to be manipulated, en-capsulated, dispatched, \nextracted, and finally executed-essentially providing for protocol layering within PLAN. For an example \nof chunk encapsulation, let us consider how to do UDP-like (211 delivery in the PLAN system. Our program \nappears in Figure 4. The heart of the communication is a chunk c that de-livers the payload to the desired \nport on the remote host. fun send-frags (x:int*host,c:chunk) : int * host = (OnRemote(c,snd x,fst x,defaultRoute);x) \nfun udp-deliver (source:host, dest:host, app:port, payload:blob) : unit = let val c:chunk = (deliver\\ \n(app,payload) val d:chunk = checksum(c) val ds:chunk list = fragment(d,pathMTU(dest)) val 1:int = length(cs) \nin (foldl(send-frags,(getRB()/l,dest),ds); 0) end Figure 4: UDP-like delivery in PLAN This chunk is \nencapsulated within another chunk d which contains code (not shown) to compute a checksum for c. d is \nthen fragmented using a service fragment, which uses the result of another service pathMTU to determine \nan appropri- ate size for the fragments. The result is a list of chunks containing code for reassembly \nas well as one fragment each of the chunk d. These new chunks are then dispatched us-ing O&#38;emote. \nAs described earlier, these packets are not evaluated until they reach the final destination. Once there, \ntheir reassembly code is invoked, producing a reconstituted chunk d. Its checksum code will be invoked \nand confirm the checksum of c. If the test succeeds then c will be evaluated and deliver its payload \nto the appropriate port.  3.5 Resource Bounds Time 6 Resources Used by a Single Packet on a Single Router \n-W pace Figure 5: Resource Cube If active network programs were allowed to use un-bounded resources, \nit would be trivial to use them to im-plement denial of service attacks. Since unicast IP packets have \na time-to-live (TTL) field, a tied maximum size, and have very simple header processing, they satisfy \nthe follow- ing safety property: The amounts of bandwidth, memory, and CPU cycles that a single packet \ncan cause to be con- sumed should be linearly related to the initial size of the packet and to some resource \nbound(s) ini-tially present in the packet. If PLAN programs are to serve as header replacements, we claim \nthat they should also satisfy this property. Consider the maximum amount of resources consumable by a \nsingle packet at a single router as a resource cube, depicted in Figure 5. The RB field of a packet therefore \nbounds the number of resource cubes that can be produced, since the RB is decreased each time the packet \nhops to a different node and each time it creates a new packet (by donating some RB to the child). Bounding \nthe number of cubes, however, is not as diffi- cult as bounding their size. At one extreme, this is \npossible by imposing fixed CPU and memory counters at each node to limit evaluation resource cost. While \nstraightforward, this method weakens a priori guarantees of correctness, since a program could be terminated \nat any time (of course, this is already somewhat the case, since OnRemote and OnNeighbor are unreliable). \nWe have implemented the fixed counter ap- proach, and in our current implementation found that it adds \nan additional overhead of about 8% to packet process- ing times. One might expect that the restrictions \nplaced on PLAN programs, in particular that they terminate, would allow these conditions to be satisfied \nwithout timers and space counters. Unfortunately, the following program runs in time exponential in its \nsize, even though it does no allocation and does not even use iterators: fun fl():unit = 0 fun f2O:unit \n= (fl(); fl()) fun f3O:unit = (f20; f20) fun f4O:unit = (f30; f30) fun exponential():unit = (f4(); f40) \n We are currently exploring further restricting the PLAN lan-guage to make programs such ;1s this one \nillegal. In par-ticular, we could obtain linearly bound execution time by imposing the following constraint: \nGiven function f which calls functions 91, ~2, . . . gn: f E valid iff gl, g2, . . . gn E valid and calls(f) \n= 0 or calIs + calIs + . . . + calIs 5 1 where calls(g) is the number of PLAN functions called from \nfunction g. This is still not enough for programs using fold, so further restriction is needed (perhaps \nby consumption of resource bound). Future work in formalizing the resource control policies of PLAN may \nallow us to improve them and perhaps permit some real-time guarantees for PLAN programs. PLAN Applied \n Recently, we have used the PLAN programming environ- ment to build an active internetwork, PLANet. PLANet \ns basic protocols are based on ones used in IP, but with a key difference: all packets are PLAN programs. \nPLANet cur-rently provides a number of application services, such as re- liable and unreliable datagram \ndelivery mechanisms, as well standard network services, such as HP-style routing [9] and ARP-like address \nresolution [ZO]. The basic performance of our user-space implementation using the OCaml bytecode interpreter \nis quite respectable: a PLANet router running on a dual 300 MHz Pentium II can switch packets at be \nl1 ->q over a 100 Mbps Ethernet. More details about PLANee < its performance may be found in [II], but \nthe use of the PLAN programming environment to implement it deserves mention. In PL.4Net, distributed \nprotocols used to maintain the network, such as routing and address resolution protocols, are implemented \nas a combination of PLAN programs and services. In particular, protocol state, timing threads, etc. are \nimplemented on each node as services; these services communicate with their counterparts on other nodes \nvia PLAN programs. This has the convenient property that a protocol designer does not need to define \nnew packet for-mats: all exchanged packets are PLAN programs, and so the packet formats are simply the \nstandard wire representa-tion of those programs. Generally, we found that even with its language restrictions, \nPLAN was more than adequately expressive for such networking tasks. 5 Implementation When rhoosing an \nimplementation language for PLAN, we had several specific requirements. First, to make the claim that \nthe network is programmable, services must be dy-namically loadable. This means that our implementation \nlanguage must allow some form of dynamic code load-ing. Second, the heterogeneous nature of an internetwork \nmeans that the implementation language should be easily portable. Third, our implementation language \nneeded to provide strong typing for safety. We have completed im-plementations of PLAN in two languages \nthat meet these requirements: OCaml [4] and the Pizza [19] extension to Java [7]. Our most current implementation \nis in OCaml due to the need for access to the source code to provide Ethernet access for our internetwork \nPLANet. We currently transmit abstract syntax trees in our pack-ets, and use an RPC-style marshalling \nscheme for the ar-guments to the invocation function. This same marshalling scheme could be extended \nto allow nodes to offer services from different languages. However, our services are cur-rently implemented \nin the same language as the PLAN in-terpreter, so service calls are simply function calls within the \ninterpreter. New services may be dynamically installed over the net-work by having PLAN programs pass \nbytecodes as argu-ments to special service installation routines. In principle, though, services could \nbe transmitted in various forms (such as source code) and installed via compilation, perhaps tak-ing \nadvantage of run-time code generation. PLAN has been taught in both a graduate-level network primer COIITSC \nand an Active Networking seminar at the University of Pennsylvania, where students were asked to use \nPLAN to implement useful network services on a small testbetl network of five nodes. Feedback from the \nstudents on the FLAN system was encouraging. One common com-ment was on the ease of dynamically installing \nservices writ-ten in Java (Fizza was the main implementation language at the time), thus validating our \ninitial design decision of following a two-level approach. 6 Related Work Postscript [27] and Java [7] \nare the most well known ex-amples of using programmability and mobile code to in-crease the flexibility \nof a system. The first application of programmable network routing may be the Softnet [30] sys-tenr whic,h \nprovided for the execution of packets of multi- threadetl M-FORTH code. The potential of active networks \nhas been demonstrated by Advanced Intelligent Network- ing (AIN) [3], which was successful in reducing \nthe deploy- ment time of some telecommunication services from years to weeks. A motivating technology \ncalled Protocol Boosters [6] provides customizable protocols, but these customizations would be difficult \nto deploy without some of the capabilities provided by active packets. Numerous other motivations for \nthe advent of active networks are described in 1281. Several other active networking projects address \nparts of the same design space as PLAN. The Active Bridge [2] is part of the SwitchWare Project [26] \nat the University of Pennsylvania. It uses OCaml [4] as a service language for constructing an extensible \nbridge. The dynamic loading in-frastructure provided by the Active Bridge forms a basis for the PLANet \ninternetwork. ANTS 1291 (Active Network Transfer System), is a toolkit for deploying Java protocols on \nactive nodes. It provides implicit demand loading of pro- tocols, essentially using Java for both its \npacket and ser-vice languages. The key disadvantages of this approach are that Java is not as secure, \nsimple, or lightweight as PLAN. Hence ANTS seems more attractive as a service-level sys-tem than as a \npacket language; using ANTS to transport service extensions within a PLAN system is something we hope \nto investigate in the near future. Sprocket is a lan- guage from the Smart Packets project at BBN [18]. \nIt uses a special-purpose byte-code language and like PLAN has as a design goal of providing flexible \nnetwork diagnostics, al-though it makes no provision for extending its service level dynamically. Sprocket, \nlike PLAN, provides for resource control, although it uses both hop and instruction counts. The Quantum \n(141 language model provides resource control for distributed computing, including the ability to grant \nand revoke resources to processes. It is not clear, however, how applicable this more complex model of \nresource usage would be in the realm of ephemeral active packets. There are a variety of projects related \nto networks, dis-tributed computing, and operating systems that are related to PLAN s philosophy of active \nnetworks. For example, the Tacoma Project [12] is a programming-language-based system for communications \nbetween mobile agents. Inter-packet communication, which is forbidden in PLAN, is the core of their approach. \nAs such, they have done more ex-tensive security work than many other active networking projects. The \nreader is referred to the SwitchWare white paper [25] for more information about systems-related is-sues \nin active networking. Future Work We are currently focusing much of our effort in the area of se- curity. \nIn particular we are looking at mechanisms for trust management and resource bounding. Trust management \nis important for authorizing the use of sensitive services, such as the ability to modify a routing table. \nWe are looking into using QCM [24], which allows us to easily define a dis- tributed key and authorization \ninfrastructure which should scale nicely in a large network. We are also exploring ways to modify PLAN \nitself to obtain better security at the ex-pense of expressiveness (one such approach was described in \nSection 3.5). Preliminary results may be found in [lo]. Two topics related to security are that of namespaces \nand formal semantics. We currently have a very basic method for managing service namespaces; a much more \nsophisti-cated mechanism will eventually be needed for scalability. Another related topic is the formal \nspecification of PLAN and its guarantees. Although we have worked hard to keep the language simple and \nclose to areas in which program-ming language theory is advanced, there are still major chal-lenges in \nthe formulation of service safety and security re-quirements. It is possible that approaches like proof \ncarrying code [16, 15, S! might provide some guidance. A topic of particular interest is how to improve \nthe per- formance of PLAN processing by active routers. The mobile programming environment provides some \nunique opportuni-ties for optimization. For example, we have already found that transmitting a program \nas an AST has space and time benefits over transmitting source, since its representation is more compact \nand allows tasks like lexing and parsing to be done once at an originating host rather than at each evaluat- \ning node. We might alternatively consider a byte-code rep-resentation which could presumably further \nimprove PLAN execution times. Applying runtime code generation tech-niques [13] to service extensions \nseems very likely to pro-vide substantial service time improvements. Implementing a code cache for commonly \nused PLAN programs (such as the UDF-delivery example in Section 3.4) might also allow such techniques \nto work on PLAN programs themselves. 8 Conclusions We have developed a design philosophy based on a two-level \narchitecture and built a language to support that architec-ture. Our work so far leads us to believe \nthat this is a very promising approach to active network design. The fact that the PLAN system has been \nused to implement an internet- work from scratch lends strong credence to this claim. We invite readers \nto browse the PLAN home page, http://wuw.cis.upenn.edu/ switchware/PLAN, which makes available detailed \ndocumentation and down-loadable software. Acknowledgments We would like to thank Alex Garth-Waite, Suresh \nJagannathan, and the anonymous referees for their valuable feedback on previous drafts of this paper. \nWe would also like to thank Jonathan Smith for using PLAN in his TCOM50C class at the University of Pennsylvania. \nReferences PI D. Scott Alexander, William A. Arbaugh, Angelos D. Keromytis, and Jonathan M. Smith. A \nsecure active network architecture. IEEE Network Special Issue on Active and Controllable Networks, 1998. \nTo appear. D. Scott Alexander, Marianne Shaw, Scott M. Nettles, and Jonathan M. Smith. Active bridging. \nIn Proceed-ings, 1947 SIGCOMM Conference. ACM, 1997. PI Bell Communications Research Inc. AIN Release \n1 Ser- [3] vice Logic Program fiameworlc Generic Requirements. FA-NWT-001132. Cam1 home page. PI http://pauillac.inria.fr/caml/index-eng.html. \nD. Clayk, Scott Shenker, and L. Zhang. Supporting [51 real-time applications in an integrated service \npacket network: Architecture and mechanism. In Proceed-WI J. Postel. User Datagram Protocol. RFC 768, \nISI, Au- ings, 1992 SIGCOMM Conference, pages 14-26, Au-gust 1980. gust 1992. PI J. Pastel. Internet \nControl Message Protocol. RFC 792, David C. Feldmeier, A. McAuley, and Jonathan M. ISI, September 1981. \nIf-53 Smith. Protocol boosters. IEEE Journal on Special Aspects of Communicatl;on, 1998. To appear in \nthe is- [23] J. Postel. Internet Protocol. RFC 791, ISI, September 1981. sue on Protocol Architectures \nfor the 21st Century. James Gosling, Bill Joy, and Guy Steele. The Java [241 Query Certificate Manager \nproject home page. VI http://www.cis.upenn.edu/ qcm. Language Specification. Addison Wesley, 1996. PI \nCarl A. Gunter, Scott Nettles, and Peter Homeier. In-[251 Jonathan M. Smith, Dave J. Farber, David C. \nFeldmeier, Carl A. Gunter, Scott M. Net- frastructure for proof-referencing code. In International Conference \non Theorem Proving in Higher Order Log-tles, William D. Sincoskie, and Scott Alexan-its, 1997. der. Switchware: \nAccelerating network evolu-tion. http://www.cis.upenn.edu/ switchware/ PI C. Hendrick. Routing Information \nProtocol. RFC 1058, papers/sware.ps, 1996. Rutgers University, June 1988. WI Switch Ware project home \npage. PO1 Michael Hicks. PLAN system security. Technical Re-http://www.cis.upenn.edu/-switchware. port \nMS-CIS-98-25, Department of Computer and In- formation Science, University of Pennsylvania, April PI \nAdobe Svstems. PostScript Language Reference Man- ual. Addison-Wesley, i985. 1998. WI David L. Tennenhouse, \nJonathan M. Smith, W. David WI Michael Hicks, Jonathan T. Moore, D. Scott Sincoskie, David J. Wetherall, \nand Gary J. Minden. AAlexander, Carl A. Gunter, and Scott Net-survey of active network research. IEEE \nCommunica-tles. PLANet: An active internetwork. tions Magazine, 35(1):80-86, January 1997. http://uwu.cis.upenn.edu/ \nswitchuare/ papers/planet.ps.  PI David J. \\IVetherall, John Guttag, and David L. Ten- nenhouse. ANTS: \nA toolkit for building and dynam- PI Dag Johansen, Robbert van Renesse, and Fred B. ically deploying \nnetwork protocols. In IEEE OPE- Schneider. Operating system support for mobile agents. NA RCH, April \n1998. In Proceedings of the 5th Worlcshop on Hot Topics in Operating Systems, May 1995. J. %ander and \nR. Forchheimer. Softnet-An approach [301 [131 Peter Lee and Mark Leone. Optimizing ML with run-to higher \nlevel packet radio. In Proceedings, AMRAD time code generation. In Proceedings of the ACM SIG- Conference, \nSan Francisco, 1983. PLAN 96 Conference on Programming Language De- sign and Implementation, pages 137-148, \nMay 1996. 1141 Luc Moreau and Christian Queinnec. Design and se-mantics of quantum: a language to control \nresource consumption in distributed computing. In USENZX Conference on Domain Specific Languages (DSL \nSY), pages 183-197, October 1997. WI George C. Necula. Proof-carrying code. In Proceedings of the 24th \nAnnual ACM SZGPLAN-SZGACT Sympo-sium on Principles of Programming Languages (POPL 97). ACM Press, 1997. \n1161 George C. Necula and Peter Lee. Safe kernel extensions without run-time checking. In Second Symposium \non Operating System Design and Implementation (OSDI 96), 1996. D. Pappalardo. BBN to test RSVP. Network \nWorld, 13(50):1,14, December 1996.  1171 [18] C. Partridge and A. Jackson. Smart packets. Technical \nreport, BBN, 1996. http://www.net-tech.bbn.com/ smtpkts/smtpkts-index.html. 1191 Pizza home page. http: \n//uww . math. luc . edu/pizza. [20] David C. Plummer. An Ethernet Address Resolution Protocol. RFC 826, \nNovember 1982.  \n\t\t\t", "proc_id": "289423", "abstract": "PLAN (Packet Language for Active Networks) is a new language for programs that form the packets of a programmable network. These programs replace the packet headers (which can be viewed as very rudimentary programs) used in current networks. As such, PLAN programs are lightweight and of restricted functionality. These limitations are mitigated by allowing PLAN code to call node-resident <i>service routines</i> written in other, more powerful languages. This two-level architecture, in which PLAN serves as a scripting or 'glue' language for more general services, is the primary contribution of this paper. We have successfully applied the PLAN programming environment to implement an IP-free internetwork.PLAN is based on the simply typed lambda calculus and provides a restricted set of primitives and datatypes. PLAN defines a special construct called a <i>chunk</i> used to describe the remote execution of PLAN programs on other nodes. Primitive operations on chunks are used to provide basic data transport in the network and to support layering of protocols. Remote execution can make debugging difficult, so PLAN provides strong static guarantees to the programmer, such as type safety. A more novel property aimed at protecting network availability is a guarantee that PLAN programs use a bounded amount of network resources.", "authors": [{"name": "Michael Hicks", "author_profile_id": "81100060959", "affiliation": "Department of Computer and Information Science, University of Pennsylvania", "person_id": "PP40035565", "email_address": "", "orcid_id": ""}, {"name": "Pankaj Kakkar", "author_profile_id": "81100231986", "affiliation": "Department of Computer and Information Science, University of Pennsylvania", "person_id": "P219231", "email_address": "", "orcid_id": ""}, {"name": "Jonathan T. Moore", "author_profile_id": "81100045762", "affiliation": "Department of Computer and Information Science, University of Pennsylvania", "person_id": "PP39065256", "email_address": "", "orcid_id": ""}, {"name": "Carl A. Gunter", "author_profile_id": "81100274423", "affiliation": "Department of Computer and Information Science, University of Pennsylvania", "person_id": "PP14103244", "email_address": "", "orcid_id": ""}, {"name": "Scott Nettles", "author_profile_id": "81100150673", "affiliation": "Department of Computer and Information Science, University of Pennsylvania", "person_id": "PP14062810", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/289423.289431", "year": "1998", "article_id": "289431", "conference": "ICFP", "title": "PLAN: a packet language for active networks", "url": "http://dl.acm.org/citation.cfm?id=289431"}