{"article_publication_date": "09-29-1998", "fulltext": "\n Cayenne -a language with dependent types Lennart Augustsson Department of Computing Sciences Chalmers \nUniversity of Technology S-412 96 Giiteborg, Sweden Email: augustssks . Chalmers. se WWW:http://www.cs.chalmers.se/ \naugustss Abstract Cayenne is a Haskell-like language. The main difference between Haskell and Cayenne \nis that Cayenne has depen-dent types, i.e., the result type of a function may depend on the argument \nvalue, and types of record components (which can be types or values) may depend on other components. \nCayenne also combines the syntactic categories for value ex-pressions and type expressions; thus reducing \nthe number of language concepts. Having dependent types and combined type and value expressions makes \nthe language very powerful. It is pow-erful enough that a special module concept is unnecessary; ordinary \nrecords suffice. It is also powerful enough to encode predicate logic at the type level, allowing types \nto be used as specifications of programs. However, this power comes at a cost: type checking of Cayenne \nis undecidable. While this may appear to be a steep price to pay, it seems to work well in practice. \nKeywords: Type systems, language design, dependent types, module systems Introduction Languages like \nHaskell [Hud92] and SML [MTHSO] have type systems that are among the most advanced of any lan-guage. \nDespite this there are things that are inexpressible in these type systems. Dependent types, i.e., having \ntypes de-pend on values, increases the expressiveness of type systems and many of the problems of Hindley-Milner \ntyping can be overcome. Cayenne is a Haskell-like language that combines depen-dent types and first class \ntypes, i.e., types can be used like values. The syntax for value and type expressions is the same. Cayenne \ndoes not have a separate notion of modules; records are used as modules, this means that the language \nfor combining modules is also the usual expression language. This is in contrast with Haskell and SML. \nHaskell has sim-ilar but different syntax for type and value expressions and definitions. SML has different \nsyntax for value, type, and module expressions and definitions. It can be argued that they should look \ndifferent, because they are different. But we want to argue the opposite, the facilities for the three \ntypes of expressions are similar, so why should they be dif-ferent? In Cayenne they are the same and \nexactly the same program constructs can be used on all levels, thus reducing the number of concepts that \nyou need to master. Although dependent types have been used before in proof systems, e.g., [CH88], to \nour knowledge this is the first time that the full power of dependent types has been integrated into \na programming language. We will now give some motivating examples, where we show problems in Haskell \nthat are solved in Cayenne. The differences between Haskell and Cayenne will be explained as they occur. \n1.1 The type of printf The C standard I/O library has a very useful function for doing output, namely \nprintf. The function printf takes a formatting string as the first argument and then some additional \narguments. The number of arguments and their types depends on the formatting string. It is simple to \nwrite a similar function in Haskell, but it will not type check. printf fmt = pr fmt I where pr res = \nres pr ( % : d :cs) res = \\ i -> pr cs (res ++ show (i::Int)) pr ( % : s :cs) res = \\ s -> pr cs (res \n++ s) pr 0% : c :cs) res = pr cs (res ++ [cl) pr (c:cs) res = pr cs (res ++ Ccl)  This is a very simplified \nversion of printf, but as in the real version, the substring %d marks an integer argument and ,s marks \na string argument. The type of printf clearly / varies with its first argument; e.g., printf %d :: Int \n-> String printf %s owes %d SEK to %s : : String -> Int -> String -> String  As we can see, the function \nis easy to write and works perfectly, but, cannot be given a type in HaskelL2 The code given here is \nvery inefficient, but that is easy to remedy. Olivier Danvy has recently shown, [DanSB], that functions \nsimilar to printf can be given a type with Hindley-Milner typing with a clever trick. Cayenne solution \nThe type of printf can easily be comput,ed from the first argument. All we need to do is to write a function \nthat computes the right type. The type of all types is called # 3 in Cayenne. PrintfType :: String -> \n# PrintfType = String PrintfType ( % : d :cs) = Int -> PrintfType cs PrintfType ( % : s :cs) = String \n-> PrintfType cs PrintfType ( % : _ :cs) = PrintfType cs PrintfType ( _ :cs) = Printf Type cs printf \n: : (fmt::String) -> PrintfType fmt printf fmt = pr fmt :: (fmt::String) -> String -> PrintfType fmt \n pr 9, 0 res = res Lr ( % : d :cs) res zz \\ (i::Int) -> pr cs (x-es ++ show i) pr ( % : s :cs) res = \n\\ (s::String) -> pr cs (res ++ s) pr ( % : c :cs) res = pr cs (res ++ Ccl 1 pr (c:cs) res = pr cs (res \n++ Ccl 1  The function PrintfType mimics the recursive structure of printf, but it computes the type \ninstead of the value. E.g., PrintfType %d +--+ Int -> String The t,yping of printf is now printf :: (fmt::String) \n-> PrintfType fmt This example differs from Haskell in that the first argument (which has type String) \nhas a name, fmt, which can be used in the type expression. A minor point to note is that X-expressions \nin Cayenne have an explicit type on the bound variable, whereas they do not in Haskell. Another example \nof a function with a dependent type cau be found in appendix B. 1.2 The set package Record types in \nHaskell (and SML) can contain values, but not t,ypes; sometimes this can be inconvenient. To show an \nexample of this we will use a simple set of integers. It should support creating the empty set, the singleton \nset, taking union, and testing for set membership. There are many possible ways to implement these sets \nand sometimes you want to have multiple implementations in a program and choose dynamically which one \nto use (e.g., depending on the use pattern). To be able to do this we would like to be able to store \ndifferent set implementations in a data structure. We would want to define the set type something like \n data IntSet = IntSet { type T, empty :: T, singleton :: Int->T, union :: T->T->T, member :: Int->T->Bool \n) 3We would like to use the more familiar notation * for the type of types. This might be possible, but \nit interacts badly with the use of *I as an infix operator. Unfortunately, this is not possible since \nwe cannot have a type in a record and the name T would also not be in scope. This kind of construct is \nonly available at, the module level in Haskell, but modules are definitely not first class objects in \nHaskell; there are no operations on modules except for the importation of them. SML allows this kind \nof definitions on the module level and has a rich language for combining them, but they are still not \nfirst class objects, so they cannot be put in a run-time data structure.4 Cayenne solution Cayenne records \nare different from Haskell records in sev-eral respects: Cayenne records are not data types, they can \ncontain types, and when defining a record object the labels are bound within the record expression. The \nsig keyword starts a record type and the struct keyword starts a record value. The IntSet type could \nbe defined like this type IntSet = sig type T empty : : T singleton :: Int->T union : : T->T->T member \n: : Int->T->Bool Au implementation could look like this naPveSet :: IntSet naEveSet = struct abstract \ntype T = Int->Bool empty x = False singleton x x = x == x union s t x = s x 1 1 t x member x s = s x \n This kind of record borrows features from Haskell mod-ules, but they are still first class objects. \n 1.3 The Eq class The Eq class in Haskell has the following definition5 class Eq a where (x) : : a -> \na -> Boo1 This, quite correctly, states that (==) takes two arguments of the same type and returns a \nboolean, but surely this is not all we expect from an equality. We expect it to be a real equality, i.e., \nwe most likely want it to be an equiva-lence relation.6 The equivalence property of equality cannot be \nexpressed in Haskell. The best we can do is to have it as a comment, and hope that each equality defined \nin the program is really an equivalence relation. Cayenne solution Cayenne has no type classes so the \nEq class problem must be reformulated slightly. A class definition in Haskell would correspond to a type \ndefinition of a record in Cayenne, and instance declarations in Haskell correspond to values 41t is not \nobvious that the first class modules proposed here extend easily to a language like SML that supports \nside effects. 51t also has a definition of (/=), but it is of no use in this example 60 we disregard \nIt. Or, even better, a congruence relation. Predicate calculus Cayenne type Absurd (or any empty type) \nT any non-empty type XVY Either x y XAY Pair 2 y Vx E A.P(x) (x: :A) -> P(x) 3x E A.P(x) {x: :A; y: : \nP(x)> data Absurd = data Pair x y = pair x y data Either x y = Left x I Right y Figure 1: Encoding predicate \nlogic as Cayenne types. of that type. All dictionaries will thus be passed explicity in Cayenne. The \nEq class in Cayenne would be type Eq a = sig (==) : : a -> a -> Boo1 To include an equivalence proof \nwe must first have a way of expressing logical properties. This is, in fact, easy since Cayenne types \ncan, through the Curry-Howard iso-morphism, encode predicate calculus as types, see figure 1. Terms of \nthe different types correspond to the proof of the corresponding properties. This is all well known from \ncon-structive type theory [NPSSO], and well before that [HowBO]. We encode the absurd proposition (i.e., \nfalsity) by the empty type, and all types with elements encode truth. The dependent function type encodes \nuniversal quantification and records encode existential quantification. Proving a property correspond \nto finding an element (i.e., constructing a value) in a type. Since false logical statements correspond \nto the empty type we cannot find any values in them, but in (constructively) true logical statements \nwe can. One way of solving our problem in Cayenne is to extend the Eq type like this: type Eq a = sig \n(x) :: a -> a -> Boo1 equiv :: Equiv (LiftBin (==))  LiftBin is a function that maps a binary operation \nyielding a Boolean into a corresponding relation. Equiv is a predi-c&#38;e on relat,ions stating that \nthe relation is an equivalence relation. The following auxiliary definitions are used above. Fur-ther \ndifferences between Haskell and Cayenne appear below: type variables must be bound, but are often used \nas hidden arguments, introduced by t,he I-> function arrow, see sec-tion 3.1 for further discussion. \ndata Absurd = data Truth = truth Lift :: Boo1 -> # Lift (False) = Absurd Lift (True) = Truth LiftBin \n:: (a :: #) I-> (a -> a -> Bool) -> Rel a LiftBin ia op = \\ (~::a) -> \\ (~::a) -> Lift (Op X y) type \nRel a = a -> a -> # Refl :: (a :: a) I-> Rel a -> # Refl Ia R = (~::a) -> x R x Symm :: (a :: #) I-> \nRel a -> # Symm Ia R = (~::a) -> (~::a) -> x R y -> y R Tram :: (a :: t) I-> Rel a -> # Tram la R = \n(~::a) -> (~::a) -> (~::a) -> x R y -> y R z -> x R z Equiv :: (a :: #) I-> Rel a -> # Equiv R = sig \nrefl :: Refl R symm :: Symm R tram : : Tram R Appendix A contains the complete code for this example \nwith some instances. 2 Core Cayenne Cayenne has three basic type forming constructs: depen-dent functions, \ndata types (sums), and dependent records (products) .7 Core Cayenne is the subset of Cayenne that has \nno syntactic bells and whistles, just the basic constructs. We will start by looking at Core Cayenne \nand then at the various syntactic shorthands. The syntax of Core Cayenne is given in figure 2. The grammar \ndisregards certain minor concrete syntax issues. There is no syntactic distinction be-tween expressions \nand types in Cayenne, as is reflected in the grammar. 2.1 Functions Function expressions are written \nas X-expressions. The bound variable must be given a type. The function type is written like the X-expression, \nbut without the leading \\ . The big difference between the Cayenne function type and the Haskell function \nis that since the bound variable is available to the right of the arrow, the result type of a function \nmay depend on the value of the argument. Function application is written with juxtaposition as usual. \nExample: \\ (x::Int) -> inc x which has type (x::Int) -> Int 2.2 Data types Unlike Haskell, a data type \n(sum type) does not have to be given a name; there is an expression that denotes each data type. E.g., \ndata False I True is the type of booleans. Constructors are written in a way that is very different from \nHaskell. The constructor names used in a data type expression have no name restrictions (unlike Haskell \nwhere they have to be capitalized) and need not be unique. Conse-quently, given only the name of a constructor \nit is impossi- ble tell what type it constructs. Therefore, constructors are given with their types in \nCayenne. E.g., True@(data False I True) is one of the constructors for the boolean type, or, if Bool \nhas been defined, it can be written True@Bool . Constructor names are not part of the usual name space; \n7The terminology is a little confusing here, what in constructive type theory is usually called dependent \nproducts is called dependent functions in this paper and what in CTT is called dependent sums is called \ndependent records here. The latter terminology is more in the tradition of programming languages. expr \narm sign defn ViS abs type varid conid lblid ::= ( varid : : type ) -> expr \\ ( varid : : type 1 -> \nexpr cxpr cxpr data { conid { type } I } conid @ type case varid of { arm } : : sig { sign } struct { \ndefn } expr . lblid id #TL ::= ( conid { varid } ) -> expr varid -> expr ; ::= lblid : : type ; lblid \n: : type = expr ; ::= vis lblid : : type = expr ; ::= private 1 public abs :I= abstract 1 concrete ::= \nexpr :I= id ::= id :I= id type ; function type X expression application sum type constructor sum scrutinization \nrecord type record formation record selection variable type of types Fi .gure 2: Core Cayenne abstract \nsyntax grammar. Metasyntax: items. they can only occur in @ -expressions and case expres-sions and in \nthe latter the type that they construct can be deduced. Case expressions in Core Cayenne look a little \ndifferent from Haskell. Only simple patterns are allowed and all con-structor patterns have t-o be parenthesised \nto distinguish them from variable patterns. Apart from the scrutinized variable and the case arms, the \ncase expression also has a type attached. This type expression gives the type of the arms of the case \nexpression. Note that this expression can contain the scrutinized variable so type may depend on it. \nThe reason for having this type is that with dependent types it is not in general possible to figure \nout the type of the case expressron. Example: case 1 of (Nil) -> True; (Cons x xs) -> False; :: Boo1 \nAn example with a dependent type: case 1 of (True) -> 1; (False) -> Hello ; : : (case 1 of (True) -> \nInt; (False) -> String)  2.3 Records The record type (product type) in Cayenne is the most com-plicated \nof the type formers. The reason for this is that records also serve the purpose of modules in most other \nlan-guages. A record type is written as sig followed by a signature for each component of the record. \nThe signature normally gives only the type of the component, but it, can also give the value of it. This \nfeature is sometimes called a translucent sum, and is described in more detail in section 4.1. A record \nis formed by the struct keyword followed by { } are used to denote repetition of an arbitrary number \nof bindings for all the record components. Each binding gives the type and value of the component as \nwell as its visibility. The names of the record components (the labels) are in scope within the record \nexpression. This means that the bindings are mutually recursive. The visibility for a record component \ndetermines how it will show up in the type of the record. A private com-ponent does not show up at all \nin the type of the record, a public abstract component has only its type, and a public concrete component \nhas both its type and value in the type of the record. A record component, which occurs in (i.e., which \nis not private) the type of the record, can be extracted with the usual dot notation. Examples: struct \nprivate x :: Int = 1 public abstract y :: Int = x+1 public concrete z :: Int = x+2 has type sig Y :: \nInt z :: Int=3 Selection: r. y + r.z 2.4 The type of types The type of types is #I, this type has type \n#s which has type #s etc. The reasons for using a stratified type system are twofold: first, using # \n: : # would, even in the absence of recursion, make the Cayenne type system unsound as a logic as it \nwould allow Girard s paradox; second, the unstratified type system would make it impossible during type \nchecking to determine if an expression corresponds to a type or a real Though there are restrictions \non how the recursion may occur in the signatures to ensure that the type can be viewerl a6 a fixpoint \nof a x-type. value and it would be impossible to remove the types at l If the variable bound in the function \ntype does not runtime, see section 6.1. occur anywhere it can be dropped and the function type Note that \nthere is no elimination construct for the # type, is thus written as in Haskell. E.g. (x: : Int)->Int \ni.e., no casetype construct. It would be possible and useful can be written as Int->Int instead. to \nhave such a construct, but, Cayenne currently lacks it, partly runtime because having it type information, \nwould see make 6.1. it impossible t,o remove o lnfix used. operators (with a fixed The same conventions \nset of as in precedences) Haskell are can used. be l The patterns in case arms can be written in the \nnormal 3 Full Cayenne Haskell style with nested patterns etc. The type part Using Core Cayenne would \nbe feasible, just like using t,he bare X-calculus is. but quite tedious, Cayenne has many of case expression \nright hand sides is only necessary if the depend on the scrutinized type of the expression. syntactic \nconstructs to make it more palatable and closer to . public can be omitted, since it is the default. \nconcrete an ordinary functional language. is the default for type definitions, and abstract for other \ndefinitions. 3.1 Hidden arguments . Function definitions can be written in t,he normal Many functions \nhave type arguments that seem to serve no Haskell style with type signatures and pattern match- purpose, \nexcept to irritate the user. E.g. ing. E.g., if :: (a :: #) -> Boo1 -> a -> a -> a f or each use of if \nthe t,ype of the two branches must be given last :: (a::#) I-> List a -> a = as the first argument,. \n\\ (a :: #) I-> \\ (1::List a) -> To lessen this problem Cayenne uses a mechanism for case 1 of leaving \nout certain arguments at the application site. How- (x : (Nil)) -> x ever, the arguments st,ill must \nbe given when the function is (x : xs) -> last xs defined. Hidden arguments introduce a new version of \nthe fun&#38;on t,ype, the function abstraction, and the function can be written application. The function \narrow in both the type and abstraction no- last :: (a::#) I-> List a -> a tation is written I-> for hidden \narguments. Application of last (x : (Nil)) = x a hidden argument uses infix I, but, normally a hidden \nar- last (x : xs) = last xs gument does not need to be given at all. In fun&#38;on definitions the hidden \narguments should not l If a definition is preceded by the keyword type it is be present on the left hand \nside unless preceded by a I, i.e., assumed to have type # and all its arguments have de- the left hand \nside looks like an application. fault type #. E.g. Example: P :: # -> # = \\ (a :: #) -> a->Bool if if \n:: (a (True) ::#) x y I->Bool->a->a->a = x can type be writt,en P a = a->Bool if (False) x y = y l A \ndata type definition can be written in the same way This if function can the be used as if True 1 \n2 , or as in Haskell. This corresponds to several bindings. more explicitly if I Int True 1 2 . The concept \nof hidden arguments is a syntactic device without any deep semantic properties. The function type for \nhidden arguments should not be viewed as a new type. First one for the type itself, then one structor \nin the type. E.g. the definition data Maybe a = Nothing I Just a correspends to the definitions for each \ncon- It It is completely only serves compatible as a marker with to aid the normal the insertion function \nof the type. hidden Maybe :: # I-> # = arguments. This view of hidden arguments was presented in \\(a. \n.:#) I-> data Nothing I Just a [ACNSO] and later used in other systems like Lego, [LP92], Nothing : : \n(a: : #) I -> Maybe a = where the concept, was formalized. Similar mechanism exist \\(a: : #) I-> Nothing@(Maybe \na) e.g., in Quest, [Car94], and Russell, [BDD89]. Just :: (a::#) I-> a -> Maybe a = The current implementation \nof hidden arguments is quite \\(a::#) I-> \\(x:: a) -> Just@(Maybe a) x weak cannot always find the hidden \narguments even when it seems reasonable that it should. It can find a hidden . Cayenne has a let expression \nthat is like the Haskell argument if t,he variable (a in the example) occurs in a lat,er let expression. \nThis can be translated into a record argument type or the result t,ype. In the future we will expression. \nprobably swit,ch to a more powerful method that introduces metavariables (in the sense of logical frameworks) \nand tries t,o derive their values using more powerful methods such as unification. . To make access to \nrecord components more convenient there is an open expression that opens a record and makes its components \navailable. The open construct explicitly names the components that should be visible. 3.2 Syntactic sugar \nE.g. The open open movePoint expression d p can use x, y in dist easily be translated x y . to a This \nis a brief list of syntactic extensions that can be re- let expression. garded as mere sugar . A value \nof record type can be coerced to a value of a different, record type if the result type is the same as \nt,he original except that it has fewer fields. The coer-cion is written eqJr : : type and translates \nto a let expression. Type signat,ures can be omitted in many places. Even if t,hr basic rule is that, \nall Cayenne definit,ions should have a t,ype signature it, is easy to relax this rule some-what,. With \nthe relaxed rule Cayenne programs have about the same number of type signatures as the corre-sponding \nHaskell program would have and they place no big burden on the programmer. . #I can be written as #. \n. A Haskell-like do notation can be used for monads. . The Haskell layout rule is used to avoid braces \nand semicolons. The keywords case, do, let, sig, and struct triggers it. 3.3 Cayenne does not really \nhave any modules in the traditional sense, all it has is named expressions that exist in a global name \nspace. Module names are distiguished by having a $ in their names. The module name space can be viewed \nas hierarchical with $ as the name separator (like how UNlX path names use / or how Java names use . \n). Module identifiers can be used freely in expressions without any explicit. import, declaration (just \nas in Java). A module definition looks like a simple definition except thai. it, is preceeded by the \nkeyword module. The type in the definition is not, necessary and it can be left out. A module can also \nhave concrete visibility. This plays the same role herf, as it does for records, i.e., you can make the \nvalue of a module known insdead of only its type. Some sample modules: module foo$bar = struct data Nat \n= Zero I Succ Nat module foo$baz = open System$Int use Int, (+) in struct inc :: Int -> Int inc x = x+1 \ndec :: Int -> Int dec x = x-l Modules are t,he units of separate compilation. To com-pile a module, only \nthe types of the modules it refers to need be known. 4 The Cayenne type system 4.1 Translucent sums \nMany Haskell modules export, types in a non-abstract way, i.e., t,he type is exported so that not only \nthe name of the type:, but, also its constructors are known. E.g. module Tree(Tree(..), depth) where \ndata Tree a = Leaf 1 Node (Tree a) a (Tree a) depth :: Tree a -> Int depth Leaf = 0 depth (Node 1 _ r) \n= 1 + (depth 1 max depth r) If we try to write the corresponding Cayenne record we get module ex$Tree \n= struct data Tree a = Leaf 1 Node (Tree a) a (Tree a) depth :: (a :: #) I-> Tree a -> Int depth (Leaf) \n= 0 depth (Node 1 _ r) = 1 + (depth 1 max depth r) which has t,ype sig Tree : : # -> # depth :: (a :: \n#) I-> Tree a -> Int This is definitely not, what we had in mind, because from this signature we can \nonly see that Tree is a type constructor, but we cannot, see its definition. We could try and remedy \nthis by saying t,hat to use a module, not only must its sig-nature be known, but its actual value as \nwell. This way, we would have the definition of Tree available. But this is also not what we intended, \nbecause this would reveal the defini-tion of depth, which we may not want to reveal to users of the ex$Tree \nmodule. For this reason we introduce the possibility for each record component to specify if it should \nbe fully known or only known with its type. We then write9 module ex$Tree = struct concrete data Tree \na = Leaf 1 Node (Tree a) a (Tree a) abstract depth :: (a :: #) I-> Tree -> Int depth (Leaf) = 0 depth \n(Node 1 _ r) = 1 + (depth 1 max depth r) which has type sig Tree :: # -> # = data Leaf I Node (Tree a) \na (Tree a) Leaf :: (a::#) I-> Tree a = \\ (a::#) I-> LeafB(Tree a) Node :: (a:. .#) I->Treea->a->Treea \n-> Tree a = \\ (a:: #) I-> \\ (1::Tree a) -> \\ (x: :a) -> \\ (r::Tree a) -> NodeQ(Tree a) 1 x y depth :: \n(a :: #) I-> Tree a -> Int This is a very peculiar type because it not only specifies the types of the \nTree, Leaf, and Node components, but also their exact values. Any record of this type will have a Tree \netc. with exactly these values, whereas the value of depth may differ. This idea comes from the type \nsystem for the SML mod-ule system where these types are called translucent sums, [Lil97], or the similar \nnotion of singleton kinds. A simi-lar construct is also present in Cardelli s Quest,, where it, is called \nmanifest definitions, [Car94]. 4.2 Typing and evaluation rules The Cayenne typing rules are given in \ntable 1 and table 2. Some simplifications have been made to the typing rules for the purpose of presentation. \nIn data type each construc-tor has exactly one argument which must be of value type. The abstract and \nconcrete keywords are actually superfluous in this example because the default visibility is the same \nas those indi- cated by the keywords. Furthermore, the order of the definitions in a struct/sig does \nnot matter in real Cayenne, where as they do in the rules. The stratification showed in the typing rules \nis also a simplification of the one used in Cayenne. The type of types as used in the rules is #n, but \nin actuality it is #n,m. The first, subscript is derived as shown in the typing rules and the second \nwe get by replacing min by max in the Prod rule. The reason for two subscripts is that the first number \nis necessary for getting the type erasure to be possible, and the second one is necessary if we want \nthe logic to be sound (if recursion is removed). The environment (or assumtions), r, in the typing rules \nmay contain variables with their types, as is usually the case. But t.hey may also contain variables \nwith their types as well as their values. Th e reason for the values is that we sometimes need values \nt,o enable reductions during type checking. It is the Ret rule that introduces values into r. The fact \nthat Cayenne has dependent types shows up in a few places in the typing rules. In the App rule the term \nf a has a type that may depend on x, so x is replaced with the actual value in B. Furthermore, in the \nCase rule in each arm the type of the arm may depend of the scrutinized variable so a substitution is \nperformed here as well. The translucent sums show up in the SelE rule where a term e.1 can be reduced \neven if only the type of e is known. This reduction is only performed during t,ype checking and never \nduring normal reduction (execution). Because of a lack of time, we have not, yet proved es-sential theorems \nabout the Cayenne type system, such as soundness and the subject reduction theorem. While we be-lieve \nthem to be true, and they have been proved similar systems, they have not proved for a system with dependent \ntypes and translucent sums. The Cayenne evaluation rules, table 4, are unsurprising. Note that because \ndefinitions is a struct are recursive some care has to be exercised. 4.2.1 A problem with substitution \nSubstitution in Core Cayenne as described by the rules in this section suffers from a problem: it does \nnot really work; there are some unavoidable name clashes. We illustrate the problem with an example. \nTo make the example shorter we omit types and use a let expression which could be trans-lated to a record \nexpression. struct x=1 z = let y = x in struct x = y As we can easily see the z component of t,his record \nis a record wit,h an x component with value 1. Let us apply the standard reduction rule for let, namely \nlet x = c in c' e e'[x I-+ e]. struct x=1 z = struct x = x This is clearly not the same value as we had \nbefore; the x has been captured when it should not be. Note that we cannot rename either of the two xs \nsince the name of the labels appear in the type; renaming them would change the type. This problem is \nannoying, but can be handled easily. All we need to do is to have two different names for all labels. \nOne name is the label itself as it appears in t,he type and the other name is the name that is bound \ninside the record. The second name is not, part of the type and can clearly be a-converted when necessary. \nTo avoid cluttering the typing rules even more we will not introduce any notation for this in the rules, \ninstead we assume that the problern can be handled if needed. A similar solution is used in [Bet#]. 4.3 \nType checking Type it is type Haskell of the checking of Cachecking uses. Type syntax tree. yenne rather \nchecking On the is basically than type proceeds way down simple, just because deduct,ions, like e.g. \nin a single traversal the environment (r) is extended with the types (and sometimes values) of bound \nidentifiers. Since Cayenne has explicit types the type of each bound identifier is known. On the way \nup the type of each subexpression can the be computed and checked. A complication arises when a typing \nrules has more than one occurence of a type, like A in the App rule in table 1. For these cases we need \nto check if the two types derived from the bottom up derivation are the same, and if they are not idenf.ical \nthe Conv rule can be used to make them equal (assuming the program is type correct). For a strongly normalizing \nlanguage without translucent types the Conv rule is uses =p for Z. This relation is easy to implement; \njust compute the normal forms of the two types and compare those. Since Cayenne is not strongly normalizing \nthis is not an option. The equivalence of two arbitrary expression is undeciable. For this reason, we \ncan not implement anything but an approximation of the Conv rule and the equality rules (table 3). This \nis a tricky part of the Cayenne type checker since if the equivalence test is implemented in a nai ve \nway type checking can easily loop.  4.4 Undecidability in practice So type checking Cayenne is undecidable. \nThis is unfortu-nate, but unavoidable for a language like Cayenne. How bad is it in practice to have \nan undecidable type checker? This question can only be answered by practical experiments. The Cayenne \nprograms we have tried to date range from ordinary Haskell style programs, to programs using depen-dent \ntypes, to proofs of mathematical propositions. The total size of these programs are only a few thousand \nlines, but so far the experience shows that it, works remarkably well. Having undecidable type checking \nmeans that the type checker might loop. This is clearly not a user friendly type checker. So instead \nthe implemented type checker has an upper bound on the number of reduction steps that it may perform. \nIf this limit is exceeded the type checker will report this. Most of the t,ype errors from the Cayenne \ncompiler are similar to those that any other language would give. Very infrequently does the type checker \nreport that it did not terminate within the prescribed number of steps. Most often, this is the result \nof a type error, but sometimes the type expression is just too complicated and the number of reduction \nsteps must be increased (the number of reduction steps is a compiler flag). The type checker can thus \ngive one of three answers: type correct (meaning that the program will not go wrong when run), type incorrect,, \nor don t know . (\\x: : t->f)e I---+ f[x ct e] e.lk where e = structt.. public caseCk@te of . . . Ck xk-behi... \n+-b ak ++ ek[. . . ,lk II, : : tk=ek; ek[xk 4 He-lk,...] .) e] Table 4: Core Cayenne evaluation rules \nstruct{ 11: : tl=el ;. (\\(x: : t)->f) (\\(x: : t)->f) [jjej: ((x: :t&#38;* 1, : : tn=en)* (e.Z)* sig{ \n)* -+ --f + + + -+ + --f \\x->f*, if t E #i f*, if t 6 #r f:e*,ife~tandt~#r f ,ife~tandt$#i 0 StrUCt{.. \nlk=e; e*.l l .I, for those lk where tk 6 #I (case e of Ci xi-> ei ;. C, (cm)* x,-> en)* data.. . * -+ \n-+ + c case l e of Cr -> er ;. . . C,-> ei #:, x* x* --+ -+ + 0 x, if l , if 2 E t, z E t, t t E #1 \ng #r Table 5: Type erasure transformation There are other languages with undecidable type check-ing, \ne.g., Quest [Car941 (which has a type system based on F,,) and Gofer [Jon94], but it is usually more \ndifficult to make these systems loop. 5 Cayenne as a proof system Since Cayenne has unrestricted recursion, \nthis means that every type is inhabited by at least one element, namely 1. Thus, proofs made in Cayenne \ncannot really be trusted as proofs, since any proposition can be proved by 1. If proper checking is done, \nit is often possible to ensure that a proof is valid, but no such checking is done at the moment. Even \nif a proofs expressed in Cayenne cannot be trusted because they pass the type checker it is still valuable \nto have the encoding of predicate logic in the language. Firstly, it allows us to express properties \nabout programs within the language even if we provide no proofs at all. It is better to have this ability \nwithin the language than to use comments or leave out those properties completely. Secondly, even if \na proof cannot be trusted one can argue that a proof that has been checked, but, may be I, is better \nthan a proof that is not checked at all. 6 Implementation Implementing Cayenne is fairly straight forward; \nit is like any other functional language. One decision that has to be made is what to do with types at \nruntime. 6.1 Erasing types Cayenne treats types like first class values. Does that mean that the types \nhave to be present at run time, passed around On a real machine Hindley-Milner type checking has the \nsame problem, but the third alternative is usually spelled Out of memory instead. Not always, of course, \nsince then we would have to solve the halting problem as arguments, stored in data structures, etc? No, \nthey do not. There is no language construct, e.g., casetype, that allows a ground value -which is all \nthat can be observed in a program -to depend on a type. Hence, types do not have to be present at run \ntime. Erasing types consists of removing all arguments and record components that have type #n or are \nfunctions computing something of type &#38;. In (Car881 it is claimed that type erasing is not possible \nand that the distinction between compile-time and run-time is blurred with dependent types. We claim \nthat this is not the case with the variant of dependent types used in Cayenne. What we need to show is \nthat evaluating an expression with types erased yields the same result as evaluating it with the types \nleft in. Definition An expression, e, has value type if e E t and t E #l Theorem If e has value type \nand e c)* v then e* M* V . We first prove a useful lemma. Lemma If c has value type, then e contains \nno 0. Proof We assume that the expression to transform is of value type, and show that each invocation \nof the transfor-mation on a subexpression is also on an expression of value type. Cases A X-expression \n\\(x: : t)->f has type (xc: : t)->r, where r is the type of f. According to the assumption (5: : t)->r \nhas type #r and typing rule Pi shows that then r has type #r as well. Thus the transformation of f is \nalso on an expression of value type. For an application f e, according to the definition of *, the transformation \nis only applied to e if it is of value type. f has type (z: : t)->r and f c has type r, if r has type \n#i then, again according to typing rule Pi, (z: : t)->r has type #i, so the transformation of f fulfills \nthe assumption. The transformation cannot be applied to a function type since this does not have value \ntype. For a record value struct( . . . ) the transformation is only applied to subexpressions of value \ntype according to the definition of l . If a record selection e .l is of value type then the field (\\x->f)e \nc-l f[x ++ el C.lk + Ck[...,lk I-) e.lk ,... ] where e E struct{. ak lk=ek;. .) caseck eof CI, Xk->ek;... \n+ ek[xk e e] Table 6: Core Cayenne typeless evaluation rules must be of value type. If one field of a \nrecord type type has type #I then the whole record type has type #I according to typing rule Prod (which \ntakes the min of all the types), so the subexpression e (of e. 1) must have value type. The transformation \ncannot be applied to a sig{ . . ) value since it is not of value type. The lemma is trivially true for \na contructor expression. For a case expression the transformation is applied to the scrutinized expression, \nwhich is always of value type (typing rule Data) and to all the right hand sides. The right hand sides \nare of value type if the whole case expressions is. The transformation cannot be applied to a data value \n since it is not of value type. The transformation cannot be applied #I since it is not of value type. \nThe lemma is true for variables according to the defini- tion of *. Corollary A transformed expression \nof value type con- tains no variables that were not of value type in the original expression. Proof \nVariables that are not, of value types are trans-lated t,o l , but there are no l in the expression, \nhence there can be such variables. Lemma The substitution lemma states that type erasure commutes with \nsubstittion: (e[x I-+ t])* = e*[x I+ t*]. Proof By structural induction over the expression syn-tax. \nWe can now return to proving the type erasure theorem. First we prove that if e has value type and e \nw f then e* + f or e* = f . The theorem then follows simply by induction on the length of the reduction \nsequence. The single step version of the theorem is proved by case analysis on the three different (typed) \nreduction kinds. Cases If the reduction is (\\z: : t->f)e +--+ f[x ct e] then the translation of the redex \nis either (\\x->f*)e* in which case there is a corresponding untyped reduction step (according to the \nsubstitution lemma). Or the translation of the redex is f (if x and e do not have value type). In this \ncase f* = f*[x ++ e*]* since x does not, occur in f (according to the corollary). If the reduction is \na selection the selected label could either be left in the transformed struct or it could have been erased. \nBut since the expression e.l has value type this means that the label has value type and it must thus \nbe left in the struct. There is then an exactly corresponding untyped reduction. If the reduction is \na case reduction there is an exact,ly corresponding untyped reduction. QED  6.2 Keeping types By keeping \ntypes at runtime it is possible to do computa-tions on types and base control decision on the dynamic \ntype of values. With runtime types we could have a casetype language construct. Keeping types around \nat runtime have some advantages, like mostly tag-free garbage collection. as used in TIL, [TMC+96, Mor95]. \n 6.3 The current implementation The current implementation of Cayenne is written in Haskell and translates \nCayenne to untyped LML. The compiler con-sists of about 5500 lines, a third of which is t,he actual type \nchecker. The compiler parses Cayenne, does t,ype checking and various other checks, erases types and \nthen translates the resulting code into LML. The LML code is then compiled with the LML compiler, (AJ89], \nwith type checking turned off. This works because the LML compiler does not rely on a the fact that the \nprogram is type correct in the Hindley-Milner type system; all the compiler assumes is that the program \nmakes sense . A snapshot of the current implementation can be found on the Web at http://www.cs.chalmers.se/-augustss/cayenne/. \n7 Related work There are many logical frameworks (proof checking sys-tems) that are based on dependent \ntypes. Some exam-ples, among many, are ALF [MN94, Nor93, ACNSO], CoC [CH86, CH88], ELF [Pfe89, Fra91, \nHHP93], Lego [Pol94], and NuPRL [Con86]. All these systems are primarily de-signed for making (constructive) \nproofs even if many of them can also execute the resulting proofs or extract a program from them. Our \napproach is different in that, we want, to make a programming language, not a proof system, but of course \nthere are big similarities. There are few programming languages with dependent types. Cardelli s Quest, \n[Car94], have similarities with Cayenne, but the final version of Quest does not have the full dependency \nwhere types can depend on values. Russell, [BDD89], has dependent types, but the notion of type equal-ity \nis name equality rather t,han the struct,ural equality of Cayenne. Russell does not do full evaluation \nduring type checking so it would not be able to do, e.g., the printf ex-ample. Russell also has a different \nnotion of what a type is. 8 Future work There are many ways to continue the work on Cayenne and related \nlanguages. First, and foremost, is to gain more ex-perience with a language with dependent types, both \nto see how dependent types can be used and to see how undecid-able type checking works out. Another interesting \nline of work is to make a partial eval-uator for this kind of language. Since types and values are combined, \na partial evaluator would serve both as a type specializer (as used in, e.g., [Aug93, PJ93]) and a traditional \npartial evaluator. I-k #n E %%+1 Star rt-AES I-,x E A t z E A Var rkAES I , x E A k B E t pi I- I- (x \n: :A)->B E t    r,zEAl-bEB rt-(x::A)->BEt Lam r wx : :A)->b E (x: :A)->B rl-fE(x ::A)->B rt-SEA APP \nr k f a E B[x r-$ a] r t-AI E #l . . . rk An c #l Data F k dataCr AI I.. .I C, A, E #I rI-TTEI r t- \nck@T E Ak->T On where T E data Cl AI I.. . I C, A, F t-xEdataCr All...1 C,A, l ,xr E A1 I-el E A[x I-+ \nCI XI] r,z,EA, ; e,~A[zcCC,x,] CaSe Ft-casexof (C1xcl->el;...;C,x,->c,}::AEA r k AI E &#38;Al r, 11 \nE AI I-AZ E #ua l-, 11 E AI, . ,/,+I E An-1 I-A, E #zL,, r, 11 E AI,...,&#38;, E A, k e3 E A, Prod r \nFsigC l1 : : -fl ; . 1, : : ~~1 E #nln{u,} where each y, is either A, or A, = e3 r, 11 E AI,... ,1,-l \nE An-1 I-A, E sn F,A t e,EA, structCprarZr::A~=er;...p,a,l,::A~=e~) Ret rk E sig( . .I, : : yl ; .I where \n1, is present iff p, = public, y, is A, = e; if oi = concrete otherwise A, A~li eA1 =c~,...,/~EA~=~,, \n r i-e E sigC . . .l,: :y,;. .J Sel rke.k EA,[ . . . . lkl+e.lk ,... ] Table 1: Core Cayenne typing \nrules IYbaEA rt-BEs rl-AzB Conv r+aEB rt--aEA r,zEAI-6 WeakE r,xEA=aE6 Table 2: Core Cayenne typing \nrules, continued TkaEA T+bEA rt-azb Congr r k C[a] z C[b] where Cl is any context TkaEA a++b Red rl--azb \nLookup r,zcA=ekrt-s7ze r t- e E sig( . . . 2; : : A; = e, ;. . .I r,h E AI,... , 1, E A, k e.1, z e, \n%lE Table 3: Core Cayenne equality rules To make the record types more useful, subtyping could be added. \nSubtyping in the presence dependent types has been studied in [Bet98]. As a proof of concept the Cayenne \ncompiler should, of course, be rewritten in Cayenne. 9 Acknowledgments A big thanks to Jessica for improving \nmy English. The programming logic group at Chalmers has over the years provided me with enough background \nmaterial to finally try to make a programming language with dependent types. A special thanks to Theirry \nCoquand for fruitful discussions and examples of how to write type checkers for dependent types. Thomas \nJohnsson, Niklas Rljjemo and Dan Synek provided me with feedback on this paper as did the anony-mous \nICFP referees. References [ACNSO] L. Augustsson, T. Coquand, and B. Nordstrom. A short description of \nAnother Logical Frame-work. In Proceedings of the First Workshop on Logical Frameworks, Antibes, pages \n39-42, 1990. [AJ89] L. Augustsson and T. Johnsson. The Chalmers Lazy-ML Compiler. The Computer Journal, \n32(2):127-141, 1989. [Aug93] Lennart Augustsson. Implementing Haskell Overloading. In Proc. 6th Int \nl Conf. on Func-tional Programming Languages and Computer Architecture (FPCA 93), pages 65-73. ACM Press, \nJune 1993. [BDD89] [Bet981 [Car881 [Car941 [CH86] [CH88] [Con861 [Dan981 [Fra!fl] [HHP93] [How801 [Hud92] \n [Jon941 [Lil97] [LP92] H. Boehm, A. Demers, and J. Donahue. A Pro-grammer s Introduction to Russell. \nTechnical report, Cornell University, 1989. Gustav0 Betarte. Dependent Record Types and Algebraic Structures \nin Type Theory. PhD the-sis, Department of Computing Science, Univer-sity of Giiteborg, GGteborg, Sweden, \nFebruary 1998. Luca Cardelli. Phase Distinction in Type The- ory. R.esearch report, DEC SRC, 1988. Luca \nCardelli. The Quest Language and System. Research report, DEC SRC, 1994. Thierry Coquand and GCrard Huet. \nThe Cal-culus of Constructions. Technical Report 530, INRJA, Centre de Rocquencourt, 1986. Thierry Coquand \nand GCrard Huet. The Calcu- lus of Constructions. Information and Compu- tation, 76(2/3):95-120, 1988. \nR. L. Constable et al. Implementing Mathemat-ics with the NuPRL Proof Development System. Prentice-Hall, \nEnglewood Cliffs, NJ, 1986. Olivier Danvy. Formatting Strings in ML. Tech-nical Report RS-98-5, BRICS, \nDepartment of Computer Science, University of Aarhus, Den-mark, March 1998. Logical Frameworks. Logic \nprogramming in the LF logical framework. In GCrard Huet and Gor-don Plotkin, editors, LZCS 89, pages \n149-181. Cambridge University Press, 1991. Robert Harper, Furio Honsell, and Gordon Plotkin. A Framework \nfor Defining Logics. JACM, 40(1):143-184, 1993. W. A. Howard. The formulae-as-types notion of construction. \nIn J. P. Seldin and J. R. Hindley, editors, To H.B. Curry: Essays on Combinatory Logic, Lambda Calculus \nand Formalism, pages 479-490. Academic Press, London, 1980. Paul Hudak et al. Report on the Programming \nLanguage Haskell: A Non-Strict, Purely Func-tional Language, March 1992. Version 1.2. Also in Sigplan \nNotices, May 1992. Mark P. Jones. The implementation of the Gofer functional programming system. Tech-nical \nReport YALEU/DCS/RR-1030, Depart-ment of Computer Science, Yale University, New Haven, Connecticut, USA, \nMay 1994, May 94. Mark Lillibridge. Translucent Sums: A Founda-tion for Higher-Order Module Systems. \nPhD the-sis, School of Computer Science, Carnegie Mel-lon TJniversity, May 1997. CMU-CS-97-122. %. Luo \nand R. Pollack. LEG0 Proof Devel-opment System: User s Manual. Technical re-port, LFCS Technical Report \nECS-LFCS-92-211, 1992. [MN941 Lena Magnusson and Bengt Nordstrtim. The ALF proof editor and its proof \nengine. In Types for Proofs and Programs, LNCS, pages 213-237, Nijmegen, 1994. Springer-Verlag. [Mor95] \nGreg thesis, Morrisett. Carnegie Compiling with Mellon University, Types. 199.5. PhD [MTHSO] R. Milner, \nnition of M. Tofte, and R. Harper. Standard ML. MIT Press, The 1990. Defy- [Nor931 Bengt Nordstrtim. \nProceedings 1993 jmegen workhop grams, 1993. The ALF proof Informal Proceedings on Types for Proofs editor. \nIn of the Ni- and Pro- [NPSSO] Bengt Nordstrijm, Smith. Programming ory. An Introduction. 1990. Kent \nPetersson, and Jan M. in Martin-L6f s Type The-Oxford University Press, [Pfe89] Frank Pfenning. Elf: \ndefinition and verified LICS R9, pages 313-322. A language for meta-programming. IEEE, June 1989. logic \nIn [PJ93] John Peterson and Mark P. Jones. Implementing Type Classes. In Proceedings of ACM SIGPLAN Symposium \non Programming Language Design and Implementation, June 1993. [ PO1941 Robert Checker tions. 1994. Pollack. \nThe Theory of Lego A Proof for the Extended Calculus of Construc-PhD thesis, University of Edinburgh, \n[TMC+96] David Tarditi, Greg Chris Stone, R.obert TIL: A Type-directed ML. Technical Report of Computer \nScience, sity, February 1996. Morrisett, Pery Cheng, Harper, and Peter Lee. Optimizing Compiler for CMU-CS-96-108, \nSchool Carnegie Mellon Univer- A The Eq class module example$Eq = #include Prelude struct data Absurd \n= data Truth = truth absurd :: (a :: #) I-> Absurd -> a absurd i = case i of c ) type (<=>) a b = sig \n( impR :: a->b; impL :: b->a; 1 concrete Lift :: Boo1 -> # Lift (False) = Absurd Lift (True) = Truth \nconcrete LiftBin :: (a:: I#) I-> (a -> a -> Bool) -> Rel a LiftBin Ia op = \\(x::a) -> \\(y::a) -> Lift \n(op x y) type Rel a = a -> a -> # concrete Refl :: (a :: It) I-> Rel a -> # Refl la R = (x::a) -> x R' \nx concrete Symm :: (a :: #) I-> Rel a -> # Symm la R = (x,y::a) -> x 'R' y -> y 'R' x concrete Trans \n:: (a :: #) I-> Rel a -> # Trans la R = (x,y,z::a) -> x R y -> y 'R z -> x 'R' s concrete Equiv :: (a \n:: #) I-> Rel a -> # Equiv R = sig refl :: Refl R symm :: Symm R trans :: Trans R --The Eq \"class\", \nwith equivalence proof type Eq a = sig (z) :: a -> a -> Boo1 equiv :: Equiv (LiftBin (==)) _- ___-_- \n--Equality on Unit Eq-Unit :: Eq Unit Eq-Unit = struct (==) (unit) (unit) = True equiv = struct refl \n(unit) = truth symm (unit) (unit) p = p trans (unit) (unit) (unit) p q P z _-----__ --Equality on Boo1 \nEq-Boo1 :: Eq Boo1 Eq-Boo1 = struct (==) (False) (False) = True (==) (True) (True) = True (==) _ -= False \nequiv = struct refl (False) = truth refl (True) = truth symm (False) (False) p = p symm (False) (True) \np = absurd p symm (True) (False) p = absurd p symm (True) (True) P=P trans (False) (False) (False) p \nq = q trans (False) (False) (True) p q = absurd q trans (False) (True) _ p q = absurd p trans (True) \n(False) _ p q = absurd p trans (True) (True) (False) p q = absurd q trans (True) (True) (True) p q = \nq private 1iftAndL :: (x,y::Bool) -> Lift (x &#38;&#38; y) -> Pair (Lift x) (Lift y) 1iftAndL (False) \n_ a = absurd a 1iftAndL (True) (False) a = absurd a 1iftAndL (True) (True) t = (t, t) private 1iftAndR \n:: (x,y::Bool) -> Pair (Lift x) (Lift y) -> Lift (x Bt&#38; y) 1iftAndR (False) _ 1iftAndR (True) (False) \ni:: ;i 1 z 1iftAndR (True) (True) (t, -) = t private isoEquiv :: (a :: #) I-> (p, q :: Rel a) -> ((x, \ny :: a) -> p x y <=> q x y) -> Equiv p -> Equiv q isoEquiv p q iso eqp = struct refl x = (iso x x).impR \n(eqp.reflx) symm x y lp = (iso y x).impR (eqp.symm x y ((iso x y).impL 1~)) trans x y .z lp lq = (iso \nx z).impR (eqp.trans x y z ((is0 x y).impL lp) ((is0 y z).impL lq)) --Equality on pairs. Eq-Pair :: \n(a,b :: #) I-> Eq a -> Eq b -> Eq (Pair a b) Eq-Pair eqa eqb = struct (==) (x, x') (y, y') = eqa.(==) \nx y &#38;&#38; eqb.(==) x' y' private eq :: Pair a b -> Pair a b -> # eq (x, x') (y, y') = pair (LiftBin \neqa.(==) x y) (LiftBin eqb.(==) X' y') private eqEq :: (x,y::Pair a b) -> eq x y <=> Lift (x == y) eqEq \n(x, x') (y, y') = struct impR p = 1iftAndR (eqa.(==) x y) (eqb.(==) x' y') p impL p = 1iftAndL (eqa.(==) \nx y) (eqb.(==) x' y') p private equivEq :: Equiv eq equivEq = struct refl (x, x') = (eqa.equiv.refl \nx, eqb.equiv.reflx') symm (x, x') (y, y') (pxy, pxy') = (eqa.equiv.symm x y pxy, eqb.equiv.symm x' y' \npxy') trans (x, x') (y, y') (2, 2') (pxy, pxy') (pyz, pyz') = (eqa.equiv.trans x y z pxy pyz, eqb.equiv.trans \nx' y' z' pxy' pyz') equiv = isoEquiv eq (LiftBin (==)) eqEq equivEq B The tautology function module \nexample$taut = #include Prelude struct data Bat = Zero I Succ Bat concrete TautArg :: Bat -> # TautArg \n(Zero) = Boo1 TautArg (Succ m) = Bool->TautArg m taut :: (n::Bat) -> TautArg n -> Boo1 taut (Zero) x=x \ntaut (Succ m) x = taut m (x True) &#38;k taut m (x False) module example$tauttest = #include Prelude \nopen example$taut use Eat, Zero, Succ, taut, TautArg in let id :: Boo1 -> Boo1 idx=x implies :: Boo1 \n-> Boo1 -1 Boo1 implies x y = not x II y equ :: Boo1 -> Boo1 -> Boo1 equ x y = implies x y I I implies \ny x  in do Ronad-putStrLn (System$Bool.shon (taut Zero True)) putStrLn (System$Bool.shon (taut (Succ \nZero) id)) PutStrLn (System$Bool.shon (taut (Succ (Succ Zero)) equ: \n\t\t\t", "proc_id": "289423", "abstract": "Cayenne is a Haskell-like language. The main difference between Haskell and Cayenne is that Cayenne has dependent types, i.e., the <i>result type</i> of a function may depend on the <i>argument value</i>, and types of record components (which can be types or values) may depend on other components. Cayenne also combines the syntactic categories for value expressions and type expressions; thus reducing the number of language concepts.Having dependent types and combined type and value expressions makes the language very powerful. It is powerful enough that a special module concept is unnecessary; ordinary records suffice. It is also powerful enough to encode predicate logic at the type level, allowing types to be used as specifications of programs. However, this power comes at a cost: type checking of Cayenne is undecidable. While this may appear to be a steep price to pay, it seems to work well in practice.", "authors": [{"name": "Lennart Augustsson", "author_profile_id": "81100292365", "affiliation": "Department of Computing Sciences, Chalmers University of Technology, S-412 96 G&#246;teborg, Sweden", "person_id": "PP37026056", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/289423.289451", "year": "1998", "article_id": "289451", "conference": "ICFP", "title": "Cayenne&#8212;a language with dependent types", "url": "http://dl.acm.org/citation.cfm?id=289451"}