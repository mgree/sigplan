{"article_publication_date": "09-29-1998", "fulltext": "\n Functional Style in C++: Closures, Late Binding, and Lambda Abstractions Ole Kiselyov oleg@pobox.com, \noleg 82acm.org, oleg@computer.org http://pobox.com/-oleg/ftp/ Closures C++ permits definition of a local \nclass, within a function, method or block rather than in the global scope. This feature makes nested \nfunctions and closures possible. Nested functions -nested methods, actually - are compiled inline, unless \nthey are virtual: void foo(const Matrix&#38; m) { Matrix ml = zero(m); struct MakeHilbert : public ElementAction \n{ void operation(R!IAL&#38; element) { element = l./(i+j-1); 1 I; ml.apply(MakeHilbertO 1; I More examples \ncan be found in LinAlg [I], a Linear Algebra Matrix and optimization package. A local class follows regular \nlexical scoping rules; furthermore, with a bit of creativity one can enforce the same rules for nested \nmembers and methods. For example, a variable of an outer block can be declared visible or modifiable \nwithin the inner scope. It is also possible to some extent to capture a local scope and return a closure \nas the value of a function (see lazy classes below). The local classes are very useful as iteratees to \nbe passed to a natural iterator [2]. Late Binding Returning an object as the result of a function inevitably \ninvolves deep-copying of the object to and from temporaries, which may be expensive for big objects (e.g., \nmatrices, images). Lazy construction -a late binding - is a simple and a very useful alternative. In \nthis approach, matrices, etc. themselves are never returned from functions; a function may however yield \na recipe for how to make an object. The construction will occur later, at a place where the object is \nactually needed. For example [I]: Matrix haar = haar-matrix(5); haar-ma tr i x is a class, not a simple \nfunction. However similar this looks to returning of a whole object, it is dramatically different. haar-ma \ntrix ( ) constructs a LazyMa trix, an object of just a few bytes long. A special Matrix(const LazyMatrix&#38; \nrecipe) conStructor follows the recipe and makes the matrix haar right in place, without any intermediary \ntemporaries. Other examples of lazy operations include: Matrix A = unit(B); A = inverse(B); In all these \ncases, the result is computed directly in its final place. With lazy matrices, it is possible to express \nmatrix multiplication in a natural way -c = A * B; -and avoid seemingly inevitable deep-copy penalties. \nThe star operator in this case does not actually multiply the matrices. It merely constructs a lazy matrix, \na promise to compute the product, when the destination place for the result becomes known. The promise \nis then forced by the assignment to matrix c. A check is made that the dimensions of the promise are \ncompatible with those of the target. The result will be computed directly into matrix s c grid, without \nallocating or using any temporary storage. Lambda Expressions The following code snippet - taken from \na LinAlg [l] validation code - speaks for itself: main(void) { printf( \\n\\n\\t\\tTesting Brent s root fmder\\n\\n \n); MalceTestFunction( cos(x)-x , Lambda((constdouble x),double,return cos(x)-x)) fcos; fcos.run(2.0,3.0); \nMakeTestFunction( HS function zerodemo.m , Lambda((constdouble x),double, return U(sqr(x-O.3) + .Ol) \n+ l/(sqr(x-0.9) + .04) -6))(). run(0.4,1.6,1.29954968); This code is C++ standard-compliant. It compiles \nwithout a warning with gee 2.8.1 and Visual C++ 5.0, and runs successfully. Thefirstargumentofthe MakeTestFunctionO \niSthe title of a test case; the second argument is a test s body itself, specified as an anonymous function: \na genuine lambda abstraction. The whole MakeTes Wunction clause has the obvious meaning of defining a \ntest case datatype, which is subsequently instantiated and run. [l] LinAlg: a Numerical Math Class Library \nhttp://pobox.com/-oleg/ftp/LinAlg.README.txt http://pobox.com/-oleg/ftp/packages.html [2] Can software \ndevelopment be elevated from the Microsofi style? http://pobox.com/-oleg/MacHack96/ 331\n\t\t\t", "proc_id": "289423", "abstract": "", "authors": [{"name": "Oleg Kiselyov", "author_profile_id": "81100177557", "affiliation": "", "person_id": "PP37038143", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/289423.289464", "year": "1998", "article_id": "289464", "conference": "ICFP", "title": "Functional style in C++: closures, late binding, and Lambda abstractions", "url": "http://dl.acm.org/citation.cfm?id=289464"}