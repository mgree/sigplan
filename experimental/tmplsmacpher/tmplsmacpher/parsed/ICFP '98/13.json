{"article_publication_date": "09-29-1998", "fulltext": "\n H/Direct: A Binary Foreign Language Interface for Haskell Sigbjorn Finne Daan Leijen Erik Meijer University \nof Glasgow University of Utrecht University of Utrecht sof@dcs.gla.ac.uk daan@cs.uu.nl erik@cs.uu.nl \nSimon Peyton Jones University of Glasgow simonpj@dcs.gla.ac.uk Abstract H/Direct is a foreign-language \ninterface for the purely func-tional language Haskell. Rather than rely on host-language type signatures, \nH/Direct compiles Interface Definition Lan-guage (IDL) to Haskell stub code that marshals data across \nthe interface. This approach allows Haskell to call both C and COM, and allows a Haskell component to \nbe wrapped in a C or COM interface. IDL is a complex language and language mappings for IDL are usually \ndescribed informally. In contrast, we provide a relatively formal and precise defy-nition of the mapping \nbetween Haskell and IDL. 1 Introduction A foreign-language interface provides a way for programs written \nin one language to call, or be called by, programs written in another. Programming languages that do \nnot sup- ply a foreign-language interface die a slow, lingering death -good languages die more slowly \nthan bad ones, but they all die in the end. In this paper we describe a new foreign-language for the \nfunctional programming language Haskell. In contrast to earlier foreign-language interfaces for Haskell, \nsuch as Green Card [5], we describe a design based on a standard Interface Definition Language (IDL). \nWe discuss the reasons for this decision in Section 2. Our interface provides direct access to libraries \nwritten in C (or any other language using C s calling convention), and makes it possible to write Haskell \nprocedures that can be called from C. The same tool also makes it allows us to call COM components directly \nfrom Haskell [4], or to seal up Haskell programs as a COM component. (COM is Microsoft s component object \nmodel; it offers a language- independent interface standard between software compo-nents. The interfaces \nof these components are written in IDL.) H/Direct generates Haskell stub code from IDL interface descriptions. \nIt is carefully designed to be independent of the particular Haskell implementation. To maintain this \nin-dependence, H/Direct requires the implementation to sup-port a primitive foreign-language interface \nmechanism, ex-pressed using a (non-standard) Haskell foreign declaration; H/Direct provides the means \nto leverage that primitive fa-cility into the full glory of IDL. Because they cater for a variety of \nlanguages, foreign-language interfaces tend to become rich, complex, incom-plete, and described only \nby example. The main contribu-tion of this paper is to provide (part of) a formal descrip-tion of the \ninterface. This precision encompasses not only the programmer%-eye view of the interface, but also its \nim- plementation. The bulk of the paper is taken up with this description. 2 Background The basic way \nin which almost any foreign-language inter-face works is this. The signature of each foreign-language \nprocedure is expressed in some formal notation. Prom this signature, stub code is generated that marshals \nthe param- eters across the border between the two languages, calls the procedure using the foreign language \ns calling conven-tion, and then unmarshals the results back across the bor-der. Dealing with the different \ncalling conventions of the two languages is usually the easy bit. The complications come in the parameter \nmarshaling, which transforms data values built by one language into a form that is comprehensible to \nthe other. A major design decision is the choice of notation in which to describe the signatures of the \nprocedures that are to be called across the interface. There are three main possibili-ties: We discuss \nthe first two possibilities in Section 2.1 and the third in Sect,ion 2.2. l Use the host language (Haskell, \nin our case). That is, write a Haskell type signature for the foreign func-tion, and generate the stub \ncode from it. Green Card uses this approach [5], as does J/Direct [8] (Microsoft s foreign-language interface \nfor Java). l Use the foreign language (say C). In this case the stub code must be generated from the \nC prototype for the procedure. SWIG [l] uses this approach. l Use a separate Interface Definition designed \nspecifically for the purpose. Language (IDL), 2.1 Using the host or foreign language At first sight \nthe first two options look much more conve-nient than the third, because the caller is written in one \nlanguage and the callee in the other, so the interface is con- veniently expressed for at least one of \nthem. Here, for exam- ple, is how J/Direct allows Java to make foreign-language calls: class ShowMsgBox \n{ public static void main(String args[]) c MessageBox(0, Hello! I , Java Messagebox ,O> ; 1 /** @dll. \nimport ( USER32 ) */ private static native int MessageBox( int hundOwner, String text String title, int \nfuStyle i; 1 The dll. import directive tells the compiler that the Java MessageBox method will link to \nthe native Windows USER32. DLL. The parameter marshaling (for example of the strings) is generated based \non the Java type signature for MessageBox. The fatal flaw is that it is invariably impossible, in general, \nto generate adequate stub code based solely on the type sig- nature of a procedure in one language or \nthe other. There are three kinds of difficulties. 1. First, some practically-important languages, notably \nC, have a type system that is too weak to express the necessary distinctions. For example: l The stub \ncode generator must know the mode of each parameter -in, in out, or out -because each mode demands different \nmarshaling code. l Some pointers have a significant NULL value while others do not. Some pointers point \nto values that can (and sometimes should) be copied across the border, while others refer to mutable \nlocations whose contents must not be copied. l There may be important inter-relationships be-tween the \nparameters. For example, one param-eter might point to an array of values, while an-other gives the number \nof elements in the array. The marshaling code needs to know about such dependencies. 2. On the other \nhand, it may not even be enough to give the signature in a language with an expressive type system, such \nas Haskell. The trouble is that the type signature still says too little about the foreign proce-dures \ntype signature. For example, is the result of a Haskell procedure returned as the result of the foreign \nprocedure, or via an out- parameter of that procedure? In the case of J/Direct, when a record is passed \nas an argument, Java s type signature is not enough to spec- ify the layout of the record because Java \ndoes not spec- ify the layout of the fields of an object and the garbage collector can move the object \naround in memory. 3. The signature of a foreign procedure may say too little about allocation responsibilities. \nFor example, if the caller passes a data structure to the callee (such as a string), can the latter assume \nthat the structure will still be available after the call? Does the caller or callee allocate space to \nhold the results? In an earlier paper we described Green Card, whose basic approach was to use Haskell \nas the language in which to give the type signatures for foreign procedures [5]. To deal with the issues \ndescribed above we provided ways of augmenting the Haskell type signature to allow the programmer to \ncus-tomise the stub code that would be generated. However, Green Card grew larger and larger -and we \nrealised that what began as a modest design was turning into a full-scale language. 2.2 Using an IDL \nOf course, we are not the first to encounter these difficulties. The standard solution is to use a separate \nInterface Defini-tion Language (IDL) to describe the signatures of proce-dures that are to be called \nacross the border. IDLs are rich and complicated, for precisely the reasons described above, but they \nare at least somewhat standardised and come with useful tools. We focus on the IDL used to describe COM \ninterfaces [lo], which is closely baaed on DCE IDL[7]. An-other popular IDL dialect is the one defined \nby OMG as part of the CORBA specification[ll], and we intend to provide support for this using the translation \nfrom OMG to DCE IDL defined by [12, 131. Like COM, but unlike CORBA , we take the view that the IDL for \na foreign procedure defines a language-independent, binary interface to the foreign procedure -a sort \nof lin-gua franca. The interface thus defined is supposed to be complete: it covers calling convention, \ndata format, and al- location rules. It may be necessary to generate stub code on both sides of the border, \nto marshal parameters into the IDL-mandated format, and then on into the format de- manded by the foreign \nprocedure. But these two chunks of marshaling code can be generated separately, each by a tool specialised \nto its host language. By design, however, IDL s binary conventions are more or less identical to C s, \nso marshaling on the C side is hardly ever necessary. Here, for example, is the IDL describing the interface \nto a function f 00: int foo ( [out] long* 1 [string, in] char* s : [in, out] double* d 1; CORBA does \nnot define a binary interface. Rather, each ORB vendor provides a language banding for a number of supported \nlan- guages. This language binding essentially provides the marshaling required to an ORB-specific common \ncalling convention. If you want to use a language that the ORB vendor does not support, you are out of \nluck. [ , Application , ) Figure 1: The big picture The parts in square brackets are called attributes. \nIn this case they describe the mode of each parameter, but there are a rich set of further attributes \nthat give further (and often essential) information about the type of the parameters. For example, the \nstring attribute tells that the parameter s points to a null-terminated array of characters, rather than \npointing to a single character. 2.3 Overview The big picture is given by Qure 1. The interface be-tween \nHaskell and the foreign language is specified in IDL. This IDL specification is read by H/Direct, which \nthen pro-duces Haskell and C2 source files files containing Haskell and C stub code. H/Direct can generate \nstub code that allows Haskell to call C, or C to call Haskell. It can also generate stub code that allows \nHaskell to create and invoke COM components, and that allows COM components to be written in Haskell. \nMuch of the work in all four cases concerns the marshal-ing of data between C and Haskell, and that is \nwhat we concentrate in this paper. Since H/Dzrect generates Haskell source code, how does it express \nthe actual foreign-language call (or entry for the inverse case)? We have extended Haskell with a foreign \ndeclaration that asks the Haskell implementation to generate code for a foreign-language call (or entry) \n[2]. The foreign declaration deals with the most primi-tive layer of marshaling, which is necessarily \nimplementa-tion dependent; H/Direct generates all the implementation- independent marshaling. To make \nall this concrete, suppose we have the following IDL interface specification: typedef struct C int x,y; \n3 Point; void Move( [in,out,ref] Point* p ); If asked to generate stub code to enable Haskell to call \nfunc- tion Move, H/Direct will generate the following trr-askelI) code: For the sake of definiteness \nwe concentrate on C as the foreign language in this paper. data Point = Point i x,y::lnt j marshalpoint \n: : Point -> IO (Ptr Point) marshalpoint = . . . unmarshalPoint :: Ptr Point -> IO Point unmarshalPoint \n= . . . move :: Point -> IO Point move p = do{ a <-marshalpoint p ; primMove a ; r <-unmarshalPoint \na ; hdFree ; return r 3 foreign import stdcall Move primMove : : Ptr Point -> IO 0 This code illustrates \nthe following features: l For each IDL declaration, H/Direct generates one or more Haskell declarations. \nl From the IDL procedure declaration Move, H/Direct generates a Haskell function move whose signature \nis intended to be LLwhat the user would expect . In par- ticular, the Haskell type signature is expressed \nusing high-level types; that is, Haskell equivalents of the IDL types. For example, the signature for \nmove uses the Haskell record type Point. The translation for a procedure declaration is discussed in \nSection 3. l The body of the procedure marshals the parameters into their You-level types, before calling \nthe low-level Haskell function primMove. The latter is defined using a foreign declaration; the Haskell \nimplementa-tion generates code for the call to the C procedure Move. Section 4 specifies the high-level \nand low-level type corresponding to each IDL type. l A low-level type is still a perfectly first-class \nHaskell type, but it has the property that it can trivially be marshaled across the border. There is \nfixed set of primitive low-level types, including Int, Float, Char and so on. Addr is a low-level type \nthat holds a raw machine address. The type constructor Ptr is just a synonym for Addr: type Ptr a = Addr \naddPtr :: Ptr a -> Int -> Ptr b The type argument to Ptr is used simply to allow H/Direct to document \nits output somewhat, by giv- ing the high-level type that was marshaled into that Addr. Section 5 describes \nhow high-level types are mar- shaled to and from their low-level equivalents. l From an IDL typedef declaration, \nH/Direct generates a corresponding Haskell type declaration together with some marshaling functions. \nIn general, a marshaling function transforms a high-level Haskell value (in this case Point) into a low-level \nHaskell value (in this case Ptr Point). These marshaling functions are in the IO monad because, as we \nshall see, they of-ten work imperatively by allocating some memory and explicitly filling it in, so as \nto construct a memory layout that matches the interface specification. The translations for typedef declarations \nare discussed in t: b basic type Section 6. l The function hdFree : : IO 0 simply releases all the memory \nallocated by the marshaling functions. So much for our example. The difficulty is that IDL is a com- \nplex language, so it is not always straightforward to guess the Haskell type that will correspond to \na particular IDL type, nor to generate correct marshaling code. (The former is important to the programmer, \nthe latter only to H/Direct itself.) Our goal in this paper is to give a systematic trans-lation of IDL \nto Haskell stub code. To simplify translation we assume that the IDL source is brought into a standard \nform, that is, we factor the trans-lation into a translation of full IDL to a core subset and a translation \nfrom core IDL to Haskell. In particular, we assume that: out parameters always have an explicit I * , \nthe pointer default is manifested in all pointer types, and all enumerations have value fields. (The \ndetails are unimpor-tant .) IDL is a large language, and space precludes giving a com- plete translation \nhere. We do not even give a syntax for IDL, relying on the left-hand sides of the translation rules to \nspecify the syntax we treat. However, the framework we give here is sufficient to treat the whole language, \nand our implementation does so. 3 Procedure declarations The translation function D] ] maps an IDL declaration \ninto one or more Haskell declarations. We begin with IDL proce-dure declarations. To start with, we concentrate \non allowing Haskell to call C; we discuss other variants in Section 7. Here is the translation rule for \nprocedure declarations: DD[t-res f( [in] t-in, [out] t-out, [in,outl t-inout)] e -ufl : : 7[t-in] -> \n7-[t-inout] -> IO (T[t-out] ,T[t-inout] ,7[t-res]) n/if] = \\m -> \\n -> do { a <-M[t-in] m ; b <-O[Lout]l \n; c <-M[thout]l n ; r <-prin&#38;V] a b c ; x <-Ul[t-out] b ; y <-qt-inout] c ; 2 <-i!d[t-res] r ; hdFree \n; return (x,y,z) 1 foreign import stdcall prid[f] : : qt-in]l -> qt-out] -> But-inod] -> IO But-res] \nDespite our claim of formality, the fully formal version of this rule has an inconvenient number of subscripts. \nInstead, we illustrate by giving one parameter of each mode ([in], Coutl, and [in, out] ); more complex \ncases are handled ex- actly analogously. The translation produces a Haskell func- tion that takes one \nargument for each IDL [in] or [in, type names 1 C{attr} + 1t* pointer type I n attr : unique 1 ref 1 \nptr 1 string 1 size-is(e) Figure 2: IDL type syntax out1 parameter, and returns one result of each IDL \n[out1 or [in, out1 parameter, plus one result for the IDL result (if any). In general, foreign functions \ncan perform side effects, so the result type is in the IO monad. We are considering adding a (non- standard) \nattribute [pure], that declares the procedure to have no side effects; in this case, the Haskell procedure \ncan simply return a tuple rather than an IO type. The generic translation for procedure declaration uses \nsev- eral auxiliary translation schemes: l The translation scheme Tit] gives the high-level Haskell type \ncorresponding to the IDL type t. l The translation scheme n/[n] does the name mangling required to translate \nIDL identifiers to valid Haskell identifiers. For example, it accounts for the fact that Haskell function \nnames must begin with a lower-case letter. l The translation scheme f3[t] gives the low-level Haskell \ntype corresponding to the IDL type t. l The translation scheme M[t] : : T[t] -> IO Bat] generates Haskell \ncode that marshals a value of IDL type t from its high-level type T[t] to its low-level form B[t]. This \nis used to marshal all the in-parameters of the procedure ([in] and [in,outl). l The translation scheme \nLd[t] : : B[t] -> IO T[t] generates Haskell code that unmarshals a value of IDL type t. This is used \nto unmarshal all the out-parameters of the procedure, and its result (if any). M] ] and U] ] are mutual \ninverses (up to memory allocation). l In addition, for [out] parameters the caller is re-quired to allocate \na location to hold the result. O[ Cattrl t*] :: IO (Ptr &#38;?[tg) is Haskell code that allocates enough \nspace to contain a value of IDL type t. 4 Mapping for types Next, we turn our attention to the translations \n7-1 ] and B[ ] that translate IDL types to Haskell types. The syntax of IDL types that we treat is given \nin Figure 2, while Figure 3 gives their translation into Haskell types. We deal with user-defined structured \ntypes later, in Section 6. Translating base types, which have direct Haskell analogues, is easy. The \nhigh-level and low-level type translations coin-cide, except that the high-level representation of IDL \ns &#38;bit That is, [ptrl values are not moved across the border B[short] D[unsigned short] ++ e Int32 \nWord32 at all. Instead they are represented Ptr 7[t], a raw machine address. by a value of type a[float]l \n++ Float B[doubleB I-+ Double B[char] e Word8 f?[wchar] c+ Char B[boolean] +) Boo1 B[void] +-+ 0 D[C&#38;rl \nt*]l +-+ Ptr 7[t] 7l[char] ++ Char TUbI I--) WPI nnn I-+ M4 T[Creflt*] I-f 7[t] 7-l [unique] t *] I+ \nMaybe Tit] T[Cptrlt*] ++ Ptr T[t] T[[string] char*] e String 7[Csize-is(v)lt*l] * CT[t]l Figure 3: Type \ntranslations characters is Haskell s 16 bit Char type. To give more pre-cise mapping we have extended \nHaskell with new base types: Word8, Wordl6, and so on. Similarly, IDL type names are translated to the \n(Haskell-mangled) name of the correspond- ing Haskell type. Matters start to get murkier when we meet \npointers. Since a pointer is always passed to and from C as a machine address, the low-level translation \nof all pointer types is simply a raw machine address: a[[attrlt*] I-+ Ptr 7[t] (Recall that Ptr t is \njust an abbreviation for Addr, but the Ptr form is somewhat more informative.) In contrast, the high-level \ntranslation of pointers depends on what type of pointer is concerned. IDL has no fewer than five kinds \nof pointer, distinguished by their attributes! We treat them one at a time (refer in each case to Figure \n3): l A value of IDL type Crefl t* is the unique pointer, or indirection, to a value of type t. A value \nof type [ref 1t * should be marshalled by copying the structure over the border. Since pointers are implicit \nin Haskell, the corresponding high-level Haskell type is just 71[t]. l The IDL type [unique] t* is exactly \nthe same as [ref] t*, except that the pointer can be NULL. The natural way to represent this possibility \nin Haskell is using the Maybe type. The latter is a standard Haskell type defined like this: data Maybe \na = Nothing 1 Just a l An IDL value of type [ptr] t* is the address of a value that might be shared, \nand might contain cycles. It is far from clear how such a thing should be marshaled, so we adopt a simple \nconvention: T[[ptrl t*]l ++ Ptr 71[t] This is often useful. For a start, some libraries im-plement an \nabstract data type, in which the client is expected to manipulate only pointers to the values. Similarly, \nCOM interface pointers should be treated simply as addresses. Finally, some operating system procedures \n(notably those concerned with windows) return such huge structures that a client might want to marshal \nthem back selectively. l A value of type [stringlchar* is the address of a null-terminated sequence of \ncharacters. (Contrast [refl char*, which is the address of a single character.) The corresponding Haskell \ntype is, of course, String. The [string] attribute applies to the following array types char, byte, unsigned \nshort, unsigned long, structs with byte (only!) fields and, in Microsoft-only IDL, wchar. l Sometimes \na procedure takes a parameter that is a pointer to an array of values, where another parameter of the \nprocedure gives the size of the array. (CORBA IDL calls such arguments sequences .) For example: void \nDrawPolygon ( [in,size-is(nPoints)] Point* points , [in] int nPoints 1; The [size-is(nPoints)l attribute \ntells that the sec-ond parameter, nPoints, gives the size of the array. (This is quite like the [string] \ncase, except that the size of the array is given separately, whereas strings have a sentinel at the end.) \nThere is a second variant in which nPoints is a static constant, rather than the name of another parameter. \nAt the moment we translate an IDL array to a Haskell list, but another possibility would be to translate \nit to a Haskell array. Different choices are probably right in different situations; perhaps we need \na non-standard attribute to express the choice. While each of these variants has a reasonable rationale, \nwe have found the plethora of IDL pointer types to be a rich source of confusion. The translations in \nFigure 3 look in-nocuous enough, but we have found them extremely helpful in clarifying and formalising \njust exactly what the transla-tion of an IDL type should be. Even if the translations are not quite right \n(whatever that means), we now have a language in which to discuss vari-ants. For example, it may eventually \nturn out that the IDL [ptr] attribute is conventionally used for subtly different purposes than the ones \nwe suggest above. If so, the transla- tions can readily be changed, and the changes explained to programmers \nin a precise way. 5 Marshaling In the translation of the IDL type signature for a procedure (Section \n3)) we invoked marshaling functions M [ ] and U[ ] for each of the types involved. Now that we have defined \nthe high and low-level translations of each type, the marshaling code is relatively easy to define. In \nthis section we define these marshaling functions. Marshaling a structured value consists, as we shall \nsee, of two steps: allocate some memory in the parameter-marshalany area to hold the value, and then \nactually marshal the Haskell value into that memory. The translations are much more elegant if we define \nauxiliary schemes, W[ ] and RI 1, that perform this by-reference marshaling. We also need a number of \nfunctions to manipulate the parameter-marshaling area. More precisely: wutn : : Ptr Qt] -> T[t] -> IO \n0 marshals its second argument into the memory location(s) pointed to by its first argument; the latter \nis a raw machine address. wtn : : Ptr T[t] -> IO T[t] unmarshals a value of IDL type t out of memory \nlocation(s) pointed to by its argument. W[ ]I and R[ ]I are mutually inverse (up to memory allocation). \nInt is the number of bytes occupied by an IDL value of type t. The function U[ 1, mentioned in Sec- tion \n3, is defined thus: sut Jl : : O[[attr] t*] c) hdAlloc sit] hdAlloc : : Int -> IO (Ptr a) allocates the \nspecified number of bytes in the parameter-marshaling area, returning a pointer to the allocated area. \nhdWriteb : : Ptr 7[b] -> 7[b] -> IO 0, where b is a basic type, marshals a value of IDL type b into the \nspecified memory location(s). hdReadb : : Ptr 7-[b] -> IO 7[b], where b is a basic type, unmarshals a \nvalue of IDL type t. hdFree : : IO 0 frees the whole parameter-marshaling area. With these definitions \nin mind, Figure 4 gives the marshal- ing schemes. We omit the schemes for [size-is] because it is tiresomely \ncomplicated. Apart from that, the translations are easy to read: l For basic types there is no marshaling \nto do, except that we must convert between the 16-bit Haskell Char and S-bit IDL char types. l Marshaling \na typedef d type can be done by invoking its marshaling function. l Marshaling a Crefl pointer is done \nby allocating some memory with hdAlloc, and then marshaling the value into it with W[ 1. Unmarshaling \nis similar, except that there is no allocation step; we just invoke 721 ]I. l Dealing with [unique] pointers \nis similar, except that we have to take account of the possibility of a NULL value. Again, it is very \nhelpful to have a precise language in which to discuss these translations. Though they look simple, we \ncan attest that it is very easy to get confused by pointers to pointers to things, and we have far greater \nconfidence in 1.58 M[t] : : 7[t] -> IO agtg Muchar] e marshalchar NibI I-) return MU4 ti marshaln M[Crefl \nt*] c-t \\x -> do{ px <-hdAlloc Sat] ; wgtg px xl M[[uniquel t*] ++ \\x -> case x of Nothing -> return \nnullPtr Just y -> M[Crefl t*n y M I[ Cptrl t*] e return M[ [string] t*] c+ marshalstring w[t] : : Ptr \n7utn -> 7[t] -> I0 0 +-+ hdWriteb wbn W[Cattrl t*] I-) \\p x -> do{ a <-M[[attrl t*] x ; hdWriteAddr p \na} untn : : apg -> IO 7-p] U[char] ti unmarshalChar I-+ return  ~~bl I-+ unmarshaln UUnil Ul[[refl \ntq ++ wn U [ [unique] t *I I-) \\p -> if p == nullPtr then return Nothing else do{ x <-??!l[t] p ; return \n(Just x)} U[Cptrl tq I-+ return U[Cstringl t*] ++ unmarshalString ?qtj :: Ptr Tut] -> IO Tit] e hdReadb \nWIbl R[ Cattrl ten e \\p -> do{ a <-hdReadAddr p ; u[w-it*] a} Figure 4: The marshaling schemes t: t[el \narray type I enm{ tagl=wl,...,tag,=w,} enumeration 1 struct tag { fl : tl;...;f, : tn;} record type union \ntag1 switch ( b tag2 1 { case wr : tl fi ; . . case wn : t, fn ; } union type Figure 5: IDL constructed \ntype syntax our implementation as a result of writing the translations formally. One might wonder about \nthe run-time cost of all this data marshalling. Indeed, historically foreign-language interfaces have \ntaken it for granted that data is not copied across the border. However, such non-marshalling interfaces \nare ex-tremely restrictive: they require the two languages to share common data representations to the \nbit level, and to share a common address space. In moving decisively towards IDL-based component-based \nprogramming, the industry has ac- cepted the performance costs of marshalling in exchange for its flexibility. \nThis in turn discourages very fine-grain, in-timate interaction between components with many border-crossings, \ninstead encouraging a coarser-grain approach. We are happy to adopt this trend, because there is no way \nto make (lazy) Haskell and C share data representations. 6 Type declarations On top of the primitive \nbase types, IDL supports the defi-nition of a number of constructed types. For example typedef int trip[3] \n; typedef struct TagPoint ( int x,y; ) Point; typedef enum { Red=O, Blue=l, Green=2 ) RGB; typedef union \n-floats switch (int ftype) { case 0: float f; case 1: double d; 3 Floats; which declares array, record, \nenumeration and union (or sum) types, respectively. Figure 5 shows the syntax of IDL s constructed types. \nThe translation provides rules for converting between IDL constructed types into corresponding Haskell \nrepresenta-tions. To ease the task of defining this type mapping, we assume that each constructed type \nappears as part of an IDL type declaration. In general, a type declaration has the following form: typedef \nt name; declaring name to be a synonym for the type t, which is either a base type or one of the above \nconstructed types. A type declaration for an IDL type t gives rise to the definition of the following \nHaskell declarations: l A Haskell type declaration for the Haskell type hignome], such that T[name] = \nN[name]. l marshalN[name] :: 7[name] -> IO B[t] which implements the M[ ] scheme for converting from \nthe Haskell representation 7[t] to the IDL type t. l unmarshaln/[name] :: B[t] -> IO T[name] which implements \nthe dual U[ ] scheme for unmarshaling. l marshalN[name]At :: Ptr B[t]l -> 7Jname]l -> IO 0 for performing \nby-reference marshaling of the constructed type. l unmarshal~[name]At : : Ptr B[t] -> IO 7[name] which \nimplements the R[ ] scheme for unmarshaling a constructed type by-reference. 0 sizeofN[name] :: Int, \na constant holding the size of the external representation of the type (in &#38;bit bytes.) The general \nrules for converting type declarations into Haskell types is presented in Figure 6. Here is what they \ngenerate when applied: l In the case of a type declaration for a base type, this merely defines a type \nsynonym. For example typedef int year; is translated into the type synonym type Year = Int plus marshaling \nfunctions for Year. l For a record type such as Point: typedef struct TagPoint {int x,y;) Point; generates \na single constructor Haskell data type: data Point = TagPoint c x:: Int, y::Int In addition to this, \nthe D[ 1 scheme generates a collec- tion of marshaling functions, including marshalpoint: marshalpoint \n:: Point -> IO (Ptr Point) marshalpoint (Point x y) = do{ ptr <-hdAlloc sizeofpoint ; let ptrl = addPtr \nptr 0 ; marshalintAt ptrl x ; let ptr2 = addPtr ptrl sizeofint ; marshalintAt ptr2 y ; return ptr 3 It \nmarshals a Point by allocating enough memory to hold the external representation of the point. The size \nof the record type is computed as follows: sizeofpoint :: Int32 sizeofPoint = structSize Csizeofint,sizaofintl \nV[typedef t name;] -type N[name] * Tit] marshaln/[name] = marshalT[t] marshalhl[name]At = marshal'T[t]At \nuumarshaln/[name] = unmarshal'T[t] uumarshalhl[namegAt = uumarshal7[t]At sizeofN[name] = S[t] 'Ditypedef \nt name Cdiml;] M-type N[name] = C 7[t] 1 marshaltij[name]l = marshalArray dim marshalT[t]At marshalN/l[name]At \n= marshalArrayAt dim marshalT[tjAt uumarshalN[name] = uumarshalArray dim uumarshal'T[t]At unmarshalh/[name]At \n= uumarshalArrayAt dim unmarshalT[t]At sizeofN[name] = dim * S[t] 'D[typedef struct tag{...; t field; \n. ..} name;] t--b data NIname] = n/[tag]{ . . ..N[field.j :: T[t;], . ..} marshaln/[name]l ret = do \nptr <-hdAlloc S[name] marshalN[name]At ptr ret return ptr marshalN/[name]At ptr (Jz/l[tag]{ . . . ,n/[field,l(, \n. ..} = do let ptr, = addPtr ptr 0 . . 3 let ptri = addPtr ptr,-, S[t,-I] W[t;] ptr, field, . . . return \n0  uumarshalni[name] = uumarshaln/[name]At uumarshaln/[name]At ptr = do let ptr, = addPtr ptr 0 . . \nlet ptr, = addPtr ptr;-, s[t,-I] i\\/[field,] <-R[t,] ptr, return (N[tag] . . . n/[field,] . . . ) sizeofN[name] \n= structsize C...,S[field,],... 1 'D[typedef enum {...,alt = value,...} name;] I+ data NIname] = . . \n. I N[alt] I . . . marshalN[name] x = case x of {...; N[alt] -> N[value]; . ..} unmarshalhl[name] x \n* case x of {...; N[walue] -> return N[alt];...} unmarshal~[name]At ptr = do v <-hdReadInt ptr unmarshalJ\\/[name] \nv sizeofNlname]l = sizeofint I I Figure 6: Translating declarations where structsize is a (platform \nspecific) function that computes the size of a struct given the field sizes.3 Point s two fields are \nmarshaled into the external rep-resentation of Point by calling the by-reference mar-shaler for the basic \ntype Int, supplying a pointer that has been appropriately offset. l For the union type example given \nat the start of Sec- tion 6, the following Haskell type is generated: data Floats = F Float 1 D Double \ntogether with actions for marshaling between the alge- braic type and a union (omitting the type signatures \nfor the by-reference marshalers): marshalFloats :: Floats -> IO (Ptr Floats) unmarshalFloats : : Ptr \nFloats -> IO Floats The external representation of a union is normally a struct containing the discriminant \nand enough room to accommodate the largest member of the union. In the case of Floats, the external representation \nmust be large enough to contain an int and a double. l Enumerations have a direct Haskell equivalent \nas alge- braic data types with nullary constructors. For exam- ple, the RGB declaration: typedef enum \n{red=O,green=l,blue=2) RGB; is translated into the Haskell type data RGB = Red I Green 1 Blue with concrete \nrepresentation B[RGB] = Int32 The marshaling actions simply map between the nullary constructors and \nInt32: marshalRGB :: RGB -> IO Int32 marshalRGB run = return (case nm of C Red -> 0 Green -> 1 Blue \n-> 2 1) unmarshalRGB : : Int32 -> IO RGB unmarshalRGB v = case v of 0 -> return Red 1 -> return Green \n2 -> return Blue _ -> fail (userError . . .) Haskell data structures can contain shared sub-components, \nor even cycles. However, such sharing is not observable by a Haskell program, so the marshalling code \ncannot take ac-count of it. DAGs are therefore marshalled just as if they were trees, and a cyclic data \nstructure (which is indistin- guishable from an infinite data structure) would make the marshaler fail \nto terminate. 3Similarly, a function that returns the offsets at which to marshal each field into is \nalso provided. Due to lack of space, marshalPoint makes the simplifying assumption that structures contain \nno internal padding. It might be possible to fix these shortcomings, but we are not unduly bothered about \nthem. Rather than mar-shal complex data structures (whether or not they contain sharing) across the border, \na better approach is usually to leave them where they are and instead marshal a pointer to the data structure. \nWhen a component technology such as COM is being used (Section 8), the right thing to do is to marshal \nan interface pointer, through which the client can access the data structure. In short, if loss of sharing \nis a worry then you are probably marshalling too much data; we look forward to learning from experience \nwhether this viewpoint is right . 7 The inverse mapping Once marshaling and unmarshaling functions are \ndefined for each data type, it is not hard to reverse the mapping and build code that allows C to call \nHaskell. The translation for a typedef remains unchanged, but the translation for an IDL procedure declaration \nis reversed. Since the procedure is being implemented in Haskell, its [in]-parameters are unmarshaled, \nthe Haskell procedure is called, its results are marshaled, and returned to the caller. (We omit the \ndetails, but the translation rule can be expressed just as we did in Section 3.) For example, the Move \nIDL declaration of that Section would be compiled to the following Haskell code: foreign export stdcall \nMove primMove : : Ptr Point -> IO 0 primMove a = do { p <-unmarshalPoint a ; q <-move p ; marshalPointAt \na q ; return 0 1 move :: Point -> IO Point move = error Not yet implemented The foreign export declaration \nasks the Haskell compiler to make Move externally callable with a stdcall interface. primMove does the \nmarshaling, before calling move, which should be provided by the programmer. 8 Talking to COM We are \nalso interested in allowing Haskell programs to create and invoke COM objects, and in allowing a Haskell \nprogram to be sealed up inside a COM object. This too is a straight- forward extension. There are a couple \nof wrinkles, however: COM methods conventionally return a value of type HRESULT, which is used to signal \nexceptional condi-tions. H/Direct knows about HRESULT and reflects its exceptional values into exceptions \nin Haskell s IO monad. COM methods are invoked indirectly, through a vector table. To support this the \nHaskell foreign declaration has to be extended to allow indirect calls. For example, the Haskell-to-COM \nside looks like this: foreign import stdcall dynamic primFoo :: Addr -> . . The keyword dynamic replaces \nthe static name of the foreign function, and the address of the function is instead passed as the first \nargument to primFoo. The foreign export case is similar. . Lastly, there are several design choices concerning \nwhat the programmer has to write to implement a COM object. Does she write a collection of functions \nthat take the object state as their first argument? Or does she write a single function that returns \na record of all the methods of the object? 9 Status and conclusions H/Direct is now our fourth attempt \nat a foreign-language in-terface for Haskell. The first was ccall, a limited and low- level extension \nroughly equivalent to foreign import [3]. The second was Green Card, which gradually turned into a domain-specific \nlanguage [5]. The third was a pre-cursor to H/Direct, Red Card, which was specifically aimed at in- terfacing \nHaskell to COM objects, [4, 61. H/Direct embod-ies the lessons we have learned: strive for implementation-independence; \navoid inventing new languages; the customer is always right. We do not claim great originality for these \nobservations. What is new in this paper is a much more precise de-scription of the mapping between Haskell \nand IDL than is usually given. This precision has exposed details of the mapping that would otherwise \nquite likely have been mis-implemented. Indeed, the specification of how pointers are translated exposed \na bug in our current implementation of H/Direct. It also allows us automatically to support nested structures \nand other relatively complicated types, without great difficulty. These aspects often go un-implemented \nin other foreign-language interfaces. We are well advanced on an implementation of H/Direct. We can parse \nand type-check the whole of Microsoft IDL, and can generate stubs that allow Haskell to call C and COM. \nWe have not yet implemented the reverse mapping, but we expect to do so in the next few months. Acknowledgements \nWe thank Conal Elliott for playing the vital role of Friendly Customer; much of our motivation derives \nfrom his desired applications. We thank EPSRC and Microsoft for their sup-port, both of equipment and \nmanpower. Erik Meijer would like to thank the Pa&#38;oft group at the Oregon Graduate In-stitute for \ntheir hospitality during the final phases of writing this paper. References [l] D. Beazley. SWIG and \nautomated C/C++ scripting extensions. Dr. Dobb s Journal, February 1998. [2] Sigbjorn Finne et al. A \nprimitive foreign function in-terface for Haskell. In preparation, preliminary specifi-cation available \nfrom http://wwu.dcs .gla. ac.uk/fp/ software/hdirect, March 1998. [3] Simon L. Peyton Jones and Philip \nWadler. Imperative functional programming. In The 20th ACM Sympo-sium on Principles of Programming Languages(POPL), \npages 71-84, 1993. [4] Simon Peyton Jones, Erik Meijer, and Daan Leijen. Scripting COM components from \nHaskell. In Proceed-ings of the 5th International Conference on Software Reuse, 1998. [5] Simon Peyton \nJones, Thomas Nordin, and Alastair Reid. Green Card: a foreign-language interface for Haskell. In Proceedings \nof the Haskell Workshop, 1997. [6] Daan Leijen. Red Card: Interfacing Haskell with COM. Master s thesis, \nUniversity of Amsterdam, 1998. http: //www.haskell.org/active/activehaskell.html. [7] X/Open Company \nLtd. X/Open Preliminary Specifica-tion X/Open DCE: Remote Procedure Call, 1993. [8] Microsoft. SDK for \nJava, 1998. http://wvw. microsoft.com/java/. [9] Microsoft Press. Developing for Microsoft Agent, 1998. \n[lo] Dale Rogerson. Inside COM. Microsoft Press, 1997. [ll] Jon Siegel. CORBA Fundamentals and Programming. \nJohn Wiley &#38; Sons, 1996. [12] A Vogel and B Gray. Translating DCE IDL in OMG IDL and vice versa. \nTechnical Report 22, CRC for Dis- tributed Systems Technology, Brisbane, 1995. [13] A Vogel, B Gray, \nand K Duddy. Understanding any IDL, lesson one: DCE and CORBA. In Proceedings of SDNE 96, 1996. \n\t\t\t", "proc_id": "289423", "abstract": "<i>H/Direct</i> is a foreign-language interface for the purely functional language Haskell. Rather than rely on host-language type signatures, <i>H/Direct</i> compiles Interface Definition Language (IDL) to Haskell stub code that marshals data across the interface. This approach allows Haskell to call both C and COM, and allows a Haskell component to be wrapped in a C or COM interface. IDL is a complex language and language mappings for IDL are usually described informally. In contrast, we provide a relatively formal and precise definition of the mapping between Haskell and IDL.", "authors": [{"name": "Sigbjorn Finne", "author_profile_id": "81100410497", "affiliation": "University of Glasgow", "person_id": "P265156", "email_address": "", "orcid_id": ""}, {"name": "Daan Leijen", "author_profile_id": "81100572466", "affiliation": "University of Utrecht", "person_id": "PP39049120", "email_address": "", "orcid_id": ""}, {"name": "Erik Meijer", "author_profile_id": "81100295095", "affiliation": "University of Utrecht", "person_id": "P78826", "email_address": "", "orcid_id": ""}, {"name": "Simon Peyton Jones", "author_profile_id": "81100271851", "affiliation": "University of Glasgow", "person_id": "PP14102538", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/289423.289437", "year": "1998", "article_id": "289437", "conference": "ICFP", "title": "<italic>H/Direct</italic>: a binary foreign language interface for Haskell", "url": "http://dl.acm.org/citation.cfm?id=289437"}