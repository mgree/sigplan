{"article_publication_date": "09-29-1998", "fulltext": "\n Imperative Streams -A Monadic Combinator Library for Synchronous Programming Enno Scholz Daimler-Benz \nAG, Research and Technology 3 Alt-Moabit 96a, 10559 Berlin, Germany scholz@dbag.bln.daimlerbenz.com \n1 ABSTRACT The paper presents a generalization of Haskell s IO monad suitable for synchronous concurrent \nprogramming. The new monad integrates the deterministic concurrency paradigm of synchronous programming \nwith the powerful abstraction features of functional languages and with full support for imperative programming. \nFor event-driven applications, it offers an alternative to the use of existing, thread-based concurrency \nextensions of functional languages. The concepts presented have been applied in practice in a framework \nfor programming interactive graphics. 1.1 Keywords Monads, synchronous languages, interactive graphics \n2 INTRODUCTION Synchronous programming languages such as Lucid [24], Lustre [3], Signal [6], Esterel \n[l] and SL [2] offer the benefits of concurrency without the complexities of nondeterminism, race conditions, \nand competition for resources. This paper presents a combinator library for constructing synchronous \nprograms called imperative streams. The combinator library is structured as a monad [ 131 [25]. It will \nbe presented in the context of the lazy pure functional programming language Haskell [ 151. Haskell has \nproven particularly suitable because it provides syntactical support for monads, but in principle imperative \nstreams can be used with any functional programming language. In the context of synchronous languages, \nour work is most similar to Esterel. Like in Esterel but unlike in most other synchronous languages, \nsynchronous programs can perform imperative actions, which are indispensable for many applications. Esterel \nis not a standalone programming language. Esterel programs perform computations and actions by calling \nprocedures implemented in another language. In contrast, imperative streams are fully integrated with \nthe functional programming language. In particular, the programmer can use the functional languages s \npowerful abstraction mechanisms to define new synchronous programming constructs on top of the primitive, \nbuilt-in constructs. This cannot be done in Esterel, whose means for constructing abstractions are relatively \nweak. The imperative streams library capitalizes on concepts developed by Elliott in the context of ActiveVRML \n[4] and Fran [5]. Like Fran, imperative streams were originally developed as a high-level approach to \nprogramming interactive graphics in a functional language. One important difference is that while Fran \ns support for imperative actions is inherently limited, imperative streams allow for straightforward \nimperative programming. Indeed, programming with imperative streams is a generalization of Haskell s \nstandard way to support imperative programming. The monadic type constructor St, on which imperative \nstreams are based, is a generalization of the monad IO used in Haskell to represent imperative programs \n[ 161. A term of type IO a represents an imperative program which, at the end of its execution, will \nproduce exactly one value of type a. In contrast, a term of type St a represents an imperative program \nwhich may produce a value of type a at repeated points during its execution. While the IO monad s bind \noperation is restricted to compose programs sequentially, the St monad s bind operation may also be used \nto compose programs concurrently. The concurrency model of imperative streams is orthogonal to existing \napproaches for extending functional languages with concurrent threads that execute asynchronously [ 181 \n[ 191 [ 171 [7]. Both kinds of concurrency can coexist peacefully within one monad. For many tasks in \nevent-driven programming (encountered, for instance, in interactive graphics applications) where concurrency \nserves as a means for improving the program structure, the synchronous programming style offered by imperative \nstreams is an attractive alternative to the use of asynchronous threads, because programs have a more \nThe following information about the streams sl and s2 is declarative flavor and behave deterministically. \nconveyed by the stream trace: In [21], we have shown how the concepts presented in this paper scale \nto realistic applications. Based on the paradigm of imperative streams, we have developed a framework \nPidgets for programming interactive graphics in Haskell. An early version of Pidgets was described in \n[20]. One element of Pidgets is a complete widget library for programming standard graphical user interfaces, \nin which widgets are represented by higher-order functions on imperative streams. However, since examples \ndemonstrating the use of type constructors in the style of St for programming interactive graphics may \nbe found in [20] and [5], this paper presents the characteristic features of imperative streams independently \nof interactive graphics. The remainder of the paper is organized as follows: Section 3 gives a flavor \nof the combinator library, appealing to the reader s intuition. Section 4 takes a closer look at some \ncentral issues of imperative streams programming. Section 5 presents all the library s basic combinators, \nand shows how abstractions may be defined on top of them. Section 6 reviews related work. Finally, Section \n7 draws conclusions. In the appendix, a complete semantics for the restricted case of side-effect free \nimperative streams is given, and the semantics for the fully general case is sketched. 3 A FLAVOR OF \nIMPERATIVE STREAMS Section 3.1 gives an overview of the terminology used in the presentation of imperative \nstreams. Section 3.2 presents two example programs appealing to the reader s intuition. 3.1 Imperative \nStreams Terminology The type St a serves to represent imperative streams capable of producing values \nof type a. Imperative streams execute in steps. Steps are globally numbered, starting from zero. In every \nstep, an imperative stream may perform any subset of the following actions: l perform a sequence of side \neffects (for instance, create, update, or read mutable variables, files, or windows), l produce a value, \nor . stop. In this paper, we will make use of stream traces to illustrate the behavior of streams. The \nstream trace given in Figure 1 depicts the behavior of two streams created by executing two programs \nsl and 92. sl: ; False T?Xe :\"hsllo\": :\",,,orldWj . -- 82: ) 66 1 -- : 'Ihi\" ! : o : , : 2 : 3 : 4 5 \n: Figure 1: A stream trace l Creation time: sl is created in step 1, 92 is created in step 0. l Stopping \ntime: sl stops in step 3. s2 has not yet stopped in step 5, and the stream trace does not say how 92 \nproceeds from step 6 onward. l Side effects: In step 2, sl performs the side effects of first printing \nhello and then printing world to the standard output. In step 4, 92 performs the side effect of printing \nhi to the standard output. For simplicity, printing strings to standard output is the only kind of side-effect \nillustrated in stream traces. Although no notation is introduced to illustrate other side effects, as \nfor instance, opening a window, it should be kept in mind that imperative streams may perform any kinds \nof side-effects, and that a stream s behavior may depend on the result of a side-effecting command. . \nProduced values: sl produces the value False in step 1 and the value True in step 3. 92 produces the \nvalue 66 in step 4. 3.2 Example Programs Here is a simple imperative stream countClicks. A precise description \nof the meaning of the streams combinators used in its implementation will be given shortly. For now, \ncountClicks is just intended to give a flavor of imperative streams programming. countClicks :: St Int \ncountClicks = let loop numClicks = until (next mouseButton) (lift numClicks) (do putStrLnI0 \"Click\" \nloop (numClicks + 1)) in loop 0 In the first step, countClicks produces the value 0. In any subsequent \nstep in which the user presses the mouse button, it produces an integer value, the number of times the \nuser has so far pressed the mouse button. In addition to (declaratively) producing values, countClicks \nalso (imperatively) performs side effects. Every time the user presses the mouse button, it prints the \nmessage Click to the console. The combinator lift is the St monad s unit operator. The stream lift numClicks \nis a constant stream. It produces the value rumClicks and stops in the step in which it is created. The \nstream next mouseButton produces the value False in the step it is created. It produces the value True \nand stops as soon as the mouse button is pressed in any later step. The stream until sl s2 s3 behaves \nlike 92 until the step in which sl produces the value True for the first time. Afterwards it behaves \nlike 93 forever. Thus, the stream loop 0 initially behaves like 262 lift 0, i.e., it produces the value \n0. As soon as the mouse button is pressed the next time, loop 0 behaves like do putStrLnI0 Click ; loop \n(numClicks+l) , i.e., it performs the side-effect of printing the message Click and then behaves like \nloop 1, which initially behaves like lift 1, etc. Because St is a monad, Haskell s do syntax can be \nused in the definition of countClicks as a shorthand for applications of the bind operator (>>=) . Like \nin any monad, do a <-s ; f a means s >>= f. In countClicks, the St monad s bind combinator is used to \nsequentialize the print command and the recursive call to loop, just like in the IO monad. However, the \nSt monad s bind combinator may also be used to compose programs in a concurrent fashion. This is demonstrated \nby the following imperative stream resettableTimer. resettableTimer :: St () resettableTimer = do numClicks \n<-countClicks putStrLnI0 ( Reset ++ show numClicks) t0 <-current time t1 <-the putStrLnI0 (show (tl \n-to)) This stream first creates an instance of countClicks as a substream, which executes concurrently. \nFor every time that countClicks produces a value, i.e., each time the user presses the mouse button, \nresettableTimer is reset. It then prints out a message to the console saying that it was reset for the \nnth time, and uses the combinator current to make a snapshot t0 of the timer s current value. Between \nresets, resettableTimer continuously samples the values t 1 produced by the timer stream (represented \nby time), and prints out the time tl-to. The body of resettableTimer and its substream countClicks execute \nconcurrently, but in a deterministic way. Whenever the user presses the left mouse button, both program \nparts get a chance to react. First countclicks prints the message Click , then resettableTimer prints \nthe message Reset cn> . 4 IMPERATIVE STREAMS ISSUES Section 4.1 introduces sensor streams, built-in streams \nrepresenting user input. Section 4.2 investigates the issue of distinguishing between objects of type \nSt a, programs, and the streams created by executing them. Section 4.3 takes a closer look at the semantics \nof the St monad s bind operator. Section 4.4 introduces a dual view on streams, which may be viewed both \nas producing values and as having a value . Section 4.5 presents alias streams, which serve as references \nto imperative streams. 4.1 Abstracting from the Event Queue: Sensor Streams Just like the type of the \nmain program in standard Haskell is IO ( ) , with imperative streams it is St () , In general, the main \nprogram consumes a global event queue. Every time the user presses or releases a key on the keyboard, \nor clicks the mouse, or produces other kinds of input, an event is said to occur, and a data structure \ncontaining information about the event is appended to the event queue. The main program sequentially \nremoves events from the queue and processes them. The time period the main program takes to process one \nevent from the queue is called a busy step. Whenever the program cannot remove an event from the queue \nbecause it is empty, idle steps occur until the user has produced new input. A step may span an arbitrary \nperiod in real time, since there are no bounds on the amount of computation that may be performed during \none step. The behavior of resettableTimer when executed as the main program is shown at the bottom of \nFigure 2. Above it, the behavior of its substream countClicks is shown. The state of the event queue \nat the beginning of each step is shown at the top in Figure 2. The figure illustrates a situation where \nthe main program initially finds the event queue empty, so step 0 is an idle step. By the beginning of \nstep 1, the user has typed the character a and pressed the mouse button, so the program now consumes \ntwo events from the event queue. By the beginning of step 3, the user has released the mouse button, \nso another busy step occurs. In step 4, the program finds the queue empty again, etc. The event queue \nis not accessed directly but via sensor streams, depicted below the event queue in Figure 2. All possible \nevents are categorized as belonging to exactly one sensor stream. For instance, key press events are \nconsidered to belong to a keyboard sensor stream. In every step in which a key press event is removed \nfrom the event queue, the keyboard sensor stream is viewed as having produced a value of type Char. Likewise, \nthere is a mouse button sensor stream that produces a boolean value (encoding the new mouse button state) \nin every step in which a mouse button press or release event is removed from the event queue. A special \ncase is the timer sensor stream. This stream produces a value in every step, the real time (measured \nin seconds) that has elapsed between the start of the main program and the time when the current step \nstarted. The first value produced by the timer stream is guaranteed to be 0.0, and each subsequent value \nproduced by it is guaranteed to be greater than its predecessor. No further assumptions may be made, \nin particular, the difference between one value and its predecessor may vary arbitrarily. The following \ncombinators represent the sensor streams: time : : St Float keyboard :: St Char mouseButton :: St Boo1 \n event queue before step 1: event queue before step 2: event queue before step 3: event queue before \nstep 4: event queue before step 5: event queue before step 6: event queue before step 7: die busy busy \nbusy idle busy idle idle I 7. _-_ timer sensor stream 0.0 0.1 0.4 0.7 0.9 1.2 2.3 2.4 _-_ --- keyboard \nsensor stream 'a' --- _-- mouse button sensor stream True False True _-- _-_ countClicks 2 0 1 _-- \n: Click j : Click : resettabloTimer _-- 0 ; 1 ; 2 ; 3 ; 4 ; 5 i 6 ; 7 Figure 2: Behavior of resettableTimer \nresettableCountClicks :: St Int 4.2 Distinguishing Programs from Streams resettableCountClicks = It is \nimportant to distinguish between terms of type St a, do char <-keyboardcalled programs in the following, \nand streams. The countClicks difference between a program and a stream is like the Here, for every time \nthe keyboard sensor stream produces a difference between an executable file and a process in an value \nchar, a fresh stream is created from the program operating system; in particular, by executing one program, \ncountClicks, and the old instance of countClicks ismultiple streams (called instances of the program) \nmay be discarded. Immediately on being created, countClicks created, which may behave differently depending \non when produces the value 0, and starts counting clicks from then they are created. The difference between \nprograms and on. There is no way for an instance of countClicks tostreams is illustrated by the following \nstream know how often the user pressed the mouse button before it resettableCountClicks. was created. \nHence, resettableCountClicks behaves like countClicks except that its counter is reset However, whenever \nit is clear from the context that there is only whenever the user enters a character. This behavior is \none stream created by executing a given term s of type St a, illustrated by Figure 3. At the bottom of \nFigure 3, the the phrase the stream s expands to the stream created by stream trace of resettableCountClicks \nis shown. executing program s . 264 keyboard sensor stream _-_ --- mouse button sensor stream I._-- \nmu&#38;Clicks countClicks _-- countClicks _-_ _-_ resettablecountclicks: 0 I----- 1:_-- 0 1 Figure 3: \nStream trace of resettableCountClicks Above it, three instances of countClicks created by subsequent \nkeyboard values are shown, Finally, note that the difference between programs and streams is crucial \nfor countClicks to work. For every iteration of the loop, a new instance of next mouseButton is created, \nwhich initially produces the value False. If it was the same instance of next mouseButton that was referenced \nin each iteration of the loop, countClicks would be stuck in an endless loop after the first press of \nthe mouse button. 4.3 The St Monad s Bind Operator Figure 4 illustrates the behavior of the St monad \ns bind combinator in the general case of streams producing side-effects. f: (\\a --> lOO+a 1 200+a ) : \n\"X1' i \"Y\" i Figure 4: Stream trace illustrating combinator (>>=) In particular, note that discarding \nf 10 in step 2 prevents it from performing any more side-effects, and that the side- effects of s are \nalways performed before the side-effects of the current instance of f a. This means that if both s and \nf a produce only one value immediately, the behavior of the IO monad s bind combinator arises as a special \ncase. 4.4 Having a Value vs. Producing Values Although streams are defined as entities producing values \n, they are designed to support another more abstract view of entities having a value . In any step, a \nstream s current value is the last value produced so far. If the stream has not produced any values yet, \nits current value is undefined. After it has stopped, a stream can never again produce values nor perform \nany side effects, but its current value is still available. Figure 5 illustrates that a stream s current \nvalue in any step is unambiguously given by the values produced so far. Note that after the stream has \nstopped in step 5, its current value is forever c . 4.5 Referencing Streams with Alias Streams A stream \ncreated when executing the program mouseButton of type St Boo1 is similar to, but not identical with \nthe mouse button sensor stream; it is called an alias stream for the mouse button sensor stream. In general, \nif 8 is an alias stream for stream s, then s is called the source stream of s . The following program \nillustrates an important relationship between alias streams and their source streams: in the step in \nwhich an alias stream is created, it produces the current value of its source stream, even if the source \nstream s current value was produced in an earlier step. mouseButtonOrFalse :: St Boo1 mouseButtonOrFalse \n= do char + keyboard if char == 'a' then mouseButton else lift False  a 'b' C 9 : current value: 8 \nundefined i i : current value: a i L'1 : currentvalue: b L'A : * --------L--+ current value: : c \n0 : 1 2 3 j 4 j 5 f 6 : Figure 5: Deriving a stream s current value from the values produced by it Whenever \na new character is entered, a new stream is created from either the program mouseButton or the program \nlift False. The behavior of mouseButtonOrFalse is illustrated by Figure 6. sensor ---stream --- mouse \nbutton T?Xle R-ala0 sensor stream --- lift False: False / : w-1mouaeButton: ; mousoButtonOrFalse: False \nT?Xle False Figure 6: Stream trace of mouseButtonOrFalse The crucial thing to notice is that the alias \nstream for the mouse button stream created in step 2 immediately produces the value True, even though \nthe mouse button sensor stream produced this value already in step 1. When viewing streams as producing \nvalues , this behavior may seem surprising at first glance, but when viewing streams as having a value \n, it is essential to establish the following invariant: in any step, the current value of any alias stream \nof a stream s will be the current value of s. Because of this property of alias streams, we can give \na simple definition of the behavior of mouseButtonOrFalse on the level of current values: while the current \nvalue of the keyboard is a , the current value of mouseButtonOrFalse is equal to the current value of \nthe mouse button, otherwise it is False. If the alias stream of the mouse button sensor stream did not \nimmediately produce the value True in step 2 in which it is created, but rather waited until step 3 before \nproducing values, then the above definition would not be true, because the current value of mouseButtonOrFalse \nin step 2 would be False, not True like the mouse button s. In general, the view of In the case of the \nmouse button, immediately receiving its current value is usually appropriate, whereas in the case of \nthe keyboard, the most recent value entered will usually be of no interest. In the sequel, combinators \nwill be introduced allowing the current value to be dropped from a stream. streams having a value abstracts \naway from the details of change propagation inherent in the view of stream s producing values . The integration \nof both views is one of the main characteristics of imperative streams, and it hinges on the property \nof alias stream to produce the current value of its source stream in the step it was created. To create \nalias streams to other streams than the sensor streams, the following operator start is used: start :: \nSt a --, St (St a) It spawns a substream executing concurrently, and returns a program which may be \nused to create alias streams for the created stream. Here is a problem that cannot be solved without \nstart. Suppose we want to write a program snapCountClicks that, whenever a character is entered, makes \na snapshot of the number of times the user has clicked the mouse button. Here is a nai ve attempt: {-does \nnot work -) snapCountClicks :: St Int snapCountClicks = do char <-keyboard current countClicks Unfortunately, \nsnapCountClicks will produce 0 each time a character is entered. This is not surprising, because this \nversion of snapCountClicks is almost identical with resettableCountClicks, except for an extra application \nof the snapshot combinator current. Thus, for every character entered, a snapshot is made of a fresh \ninstance ofcountClicks, whose currentvalueisinitially 0. Of course we do not want to create a fresh instance \nof countClicks every time a character is entered. Instead, we want to repeatedly reference the one distinguished \ninstance of countClicks created at the time when snapCountClicks was created. This is done as follows \nwith the operator start: j-works fine -} SnapCountClicks :: St Int SnapCountClicks = do countClicksAlias \n<-start countClicks char + keyboard current countClicksAlias Here, only one instance of countClicks is \ncreated at the time snapCountClicks is created. Repeatedly, alias streams are created for it by executing \nthe program countClicksAlias, but these alias streams always 266 have the same current value as the \nstream created from countClicks. In other words, in this example start serves to decouple the step in \nwhich countClicks is created and the step in which it is accessed. 5 BASIC COMBINATORS AND ABSTRACTIONS \nSection 5.1 gives an overview of all the basic combinators defined on imperative streams. Section 5.2 \ndiscusses abstractions defined on top of the basic combinators. 5.1 Overview of the Basic Combinators \nHere is a list of the basic combinators defined on imperative streams: keyboard :: St Char mouseButton \n:: St Boo1 time :: St Float lift :: a --> St a lift1 :: (a --> b) --> St a --> St b lift2 :: (a --> b \n--> c) --> St a -> St b -> St c . . . etc. . . . lift10 :: IO a --> St a next :: St Boo1 -> St Boo1 current \n:: St a --> St a hasstopped : : St a --> St Boo1 merge :: St a -> St a -a St a nil :: St a until :: St \nBoo1 --> St a --> St a --> St a (>>=) :: St a -> (a start :: St a -> St red :: (St a --> St --, St rec2 \n:: (Sta->Stb->St . . . etc. . . . --> St b) -> St b (St a) a) a (Sta,Stb)) --> St (St a,St b) withKeyboard \n:: St Char --, St a -N St a withMouseButton :: St Boo1 --> St a --> St a withTime :: St Float -> St a \n-> St a The combinators keyboard, mouseButton, and time create alias streams for the sensor stream. Whereas \nkeyboard and mouseButton could be exchanged for other combinators representing other kinds of events, \nthe existence of a sensor stream time is crucial, because many common abstractions depend on the ability \nto associate timestamps with events. The lift operators lift, liftl, lift2, . . . . serve to apply ordinary \nHaskell functions defined on non-stream values to streams. Thus they bridge the gap between the standard \nHaskell world of functions on pure values and the imperative streams world, where functions map streams \nto streams. In the general case, lift, f .SI . . s, (for n > 0, with lift0 = lift) produces the value \nf al, . . a,, in any step in which - the current values al, .., a,, of all of sl, .., s, are defined \nand - at least one of s,, .., s, produces a value. . stops in the step in which the last of sl, .., s, \nstops. Figure 7 demonstrates the behavior of lift2 f s 1 92, where f is defined to create a string containing \nthe character given by its first argument the number of times given by its second argument. sl: 'a' 'b' \n! ! s2: 2 1 3 1 lift2 f sl s2: 11aa II 1 \"aaa\" 1 \"bbb\" 80 : 1 :2 I -j .4, Figure 7: Stream trace illustrating \ncombinator lift2 The combinator lift10 (illustrated in Figure 8) serves to lift imperative commands in \nthe IO monad to the level of imperative streams; for instance, putStrLnI0 is defined as lift10 . putStrLn. \nlift10 (putStrLn \"hi\"):lo] [ i :\"hi\": : : lift10 (putStrIm \"hi\"):: : : hi : Figure 8: Stream trace illustrating \ncombinator lift10 The combinator next (Figure 9 top) serves to find out the next time when the current \nvalue of its argument stream is true. When created, the stream next s immediately creates s, and immediately \nproduces the value False, regardless of the value produced by s in the current step. In any step - starting \nwith the step after the current step - in which s produces the value True, next s produces the value \nTrue as well, stops, and discards s. The combinator current (Figure 9 bottom) enables one stream to make \na snapshot of the current value of another stream, such that future changes in the current value of the \nstream of which the snapshot was made are not reflected in the current value of the stream making the \nsnapshot. When created, the stream current s immediately creates s. In the step in which s produces its \nfirst value a -possibly immediately -current s discards s, produces a, and stops. If the argument of \ncurrent does not have a current value in the step in which it is created, current blocks until a value \nhas been produced. The operator hasstopped serves to find out whether a stream has stopped. The combinator \nmerge merges two streams such that, in case both produce a value in the same step, the first wins. The \ncombinator nil, the St monads zero, denotes the empty stream. When the program nil is executed, it creates \na stream that stops immediately without producing a value. For monads with a zero, Haskell supports a \nspecial pattern matching syntax. Whenever the pattern used in a do binding does not match, the whole \nexpression behaves like the monad s zero operation. 267 TYXlB False T??Ue FalsemouseButton: next mouseButton: \nFalse 0 1 r mouse button sensor stream: True 1 False mouseButton: ; current mouseButton: : 0 I Figure \n9: Stream trace illustrating For instance, the program do True + mouseButton; time is equivalent to do \nb <-mouseButton; if b then time else nil It denotes a stream which behaves like the timer, except that \nits value stays frozen when the mouse button is not pressed. The combinators until, (>>=) and start have \nalready been discussed previously. The combinators reel, rec2, etc., serve to define streams in a mutually \nrecursive way, such that the value produced by one stream in step i+l depends on the value produced by \nthe other streams in step i. For instance, the combinator rec2 takes a function f 2 as its argument and \nreturns a stream f2 old1 old2 that produces exactly one value, which is a pair (sl , s2) . The stream \nold1 is defined to produce a value al in step i+l iff sl produces al in step i. The stream old2 is defined \nanalogously. In programming systems that explicitly access an event queue (for instance, Xlib [14]), \noperators exist that allow the program to add events to the queue that are processed as if they were \ngenerated by the user. Such operators enable interactive program parts to be remote-controlled . To achieve \nthis goal, the imperative streams library features a combinator for rebinding each sensor stream. For \ninstance, the combinator withMouseButton binds all occurrences of the term mouseButton in its second \nargument to an alias stream created by executing its first argument. Thus, in the following program, \nwithMouseButton is used to remote-control an instance of countClicks with the keyboard: withMouseButton \n(do char + keyboard lift (char == 'a')) countClicks 5.2 Imperative Streams Abstractions These are some \nuseful abstractions that may be defined in terms of the basic imperative streams combinators: filter \n: : (a -> Bool) -x St a -> St a removeDoubles :: Eq a => St a -> St a TX-U0 Falme Ttue TNBI False 2 \n- 3 4 -- 1 I TIUO 1 False I -- )pGi+ 2 3 4 combinators next and current history :: St a --> St [a] \ntimeout :: Float --> St a -> St a choose :: [St a] --> St a append% :: St a --> St a -> St a The abstraction \nfilter serves to remove all values from a stream for which a given predicate does not hold. The abstraction \nremoveDoubles serves to remove all values from a stream that are equal to the preceding value. The abstraction \nhistory serves to collect all the values a stream has produced so far. The abstraction timeout serves \nto turn a stream into nil after a given number of seconds have elapsed. The abstraction choose takes \na list of argument streams which are executed concurrently. As soon as the first one produces a value, \nall others are discarded. If two or more produce a value at the same time, their order in the argument \nlist determines which one wins. The abstraction appendSt executes its second argument program in the \nstep after its first argument program has stopped. As an example, here is the definition of history: \nhistory s = do 8 + start s let loop as = dc a <-current s until (next (lift1 (\\_->True) 8)) (lift (as \n++ [a])) (loop (as ++ [al)) m-9 (loop II 1 (lift II 1 Note the use of start to avoid the creation of \na new instance of s in every iteration of loop, and the use of merge to provide the default value [] \nin case the current value of s is initially undefined (in which case current and thus loop [ ] blocks). \n6 RELATED WORK This section compares imperative streams to functional approaches for streams programming \nbased on the Kahn/MacQueen model (Section 6.1), to approaches for extending functional languages with \nthreads (Section 6.2), and to the Fran language for programming reactive animations (Section 6.3). 268 \n6.1 Streams Programming with Lazy Lists Following Kahn s and MacQueen s seminal paper [I 11, a number \nof related approaches appeared [8], [ 121, [22], [23], [lo]. Roughly, the differences to imperative streams \nare that process execution is asynchronous, that streams are not represented by an abstract data type \nbut by the concrete datatype of lazy lists, that I/O is stream-based, and that enabling a program s behavior \nto depend on the order in which input values become available requires a non-functional merge primitive. \n6.2 Functional Threads Approaches A number of related approaches exist for extending a functional language \nwith concurrent threads (for instance, 1181, [171, 1191, and [7]). These approaches have in common that \nthey introduce one primitive for forking threads, and a data type of primitive communication devices \nwith which threads may communicate. Like imperative streams, they restrict themselves to the introduction \nof new primitives into the functional language without adding any syntactical constructs for concurrency. \nThese are the main differences: No separation between threads and devices: While the threads approaches \nseparate the notion of communication devices (for instance, synchronous channels in Concurrent ML [ 181 \nand [ 191, service access points in Concurrent Opal [7], and M-vars in Concurrent Haskell [17]) from \nthreads, the notion of an imperative stream unifies properties of both. In imperative streams, the closest \nthing to a device object is an alias stream, which is, however, in practice undistinguishable from any \nother stream. No consumption of communicated values: In the threads approaches, if one producer thread \nsends values on a channel and two threads try to receive them, each value will be received by exactly \none thread. In imperative streams, there is no notion of values being consumed. A value produced by one \nstream may be read by arbitrarily many other streams. An imperative stream can be viewed as broadcasting \na produced value to all its dependents. No internal nondeterminism: In general, the behavior of programs \nusing threads is nondeterministic. It depends on the order in which threads are scheduled. Using imperative \nstreams, nondeterministic programs cannot be written; a program s behavior is completely determined by \nthe user s input. Pattern matching: In imperative streams, the monadic syntax for pattern matching may \nbe used to specify the value read by a stream. No preemption: In Concurrent ML, and conceptually in all \nof the threads approaches, scheduling of threads is preemptive. Unlike an imperative stream, a thread \nperforming an expensive calculation does not block the whole program. For tasks requiring preemptive \nscheduling, synchronous concurrency is not appropriate. However, both kinds of concurrency can easily \nbe made to coexist. For instance, an additional primitive combinator forkSt :: St () --> St () (similar \nto Concurrent Haskell s fork10 [17]) could be introduced that executes its argument program as the top- \nlevel stream in a separate thread. The new thread is associated with a copy of the creator thread s event \nqueue. Whenever an event occurs, a copy of it is added to the event queue of every thread in the system. \nEach thread consumes its own event queue at its own speed. Moreover, blocking primitives for synchronization \nand communication between threads can be defined which, when they unblock, add special events to the \nqueue of a given thread. 6.3 Fran Of all related work we are aware of, the combinator library Fran presented \nin [5] has the most traits in common with imperative streams. Indeed, it was Conal Elliott s paper on \nFran s predecessor, ActiveVRML [4], that motivated the development of the St monad from its predecessor \nExpr described in [20]. (In particular, the style of recursive programming with until is due to ActiveVRML). \nAlthough similar in spirit, Fran and imperative streams differ in a number of points: Type constructors: \nWhere imperative streams are based on one type constructor St, Fran distinguishes three, Behavior, Event, \nand IO, for representing continuous streams, discrete streams, and imperative programs. The monad of \nimperative streams is a generalization of the IO monad, and the difference between continuous and discrete \nstreams is reflected in the two coexisting views of having a value and producing values . Explicit vs. \nimplicit creation times: In Fran, the time when a stream is created is stated explicitly by passing it \nan object of a special type User. In imperative streams, creation times times are implicit; references \nto streams created at a previous point in time are referenced with alias streams. This makes programs \nless verbose, but there is a drawback: unlike in Fran, the fact that two streams created at the same \ntime depend on each other cannot be directly expressed by a let expression in the functional language. \nInstead, a recursion combinator like rec2 must be used. Integration of side-effects: In Fran, animations \nwanting to perform side-effects pass an extra stream producing values of type IO () to the environment. \nWhen two animations performing side-effects are composed, these command streams must be explicitly interleaved, \nwhereas side-effects are implicitly interleaved in imperative streams. Moreover, the notion of side-effects \nsupported by Fran is rather limi- ted. A Fran program can send an imperative script to its environment \nwhere it is executed, but the script cannot return a value, such as a window handle or the contents of \na file, to the Fran program. This scheme precludes many common uses of side-effecting I/O. It seems that \nthis limitation is not incidental, but is inherent in Fran s model of computation. 7 CONCLUSIONS We \nhave presented a programming formalism that offers a unified view on existing approaches towards synchronous \nprogramming, concurrent functional programming, and reactive animations. It integrates the deterministic, \ndeclarative concurrency paradigm of synchronous programming with the powerful abstraction features of \nfunctional programming It avoids the awkwardness often associated with performing imperative actions \nin purely-functional streams-based paradigms because it is a generalization of state-of-the-art monadic \nI/O. For event-driven applications, it complements the use of existing, thread-based concurrency extensions \nof functional languages. This gives rise to a two-level view of concurrency. A system consists of a number \nof threads executing concurrently in an asynchronous, nondeterministic, preemptive fashion. Each thread \nis a subsystem consisting of a number of streams executing concurrently in a synchronous, deterministic, \nnon-preemptive fashion. In a pun on Hoare s Communicating Sequential Processes , Berry and Gonthier have \nnamed this architecture Asynchronously Communicating Reactive Deterministic Systems [ 11. 8 ACKNOWLEDGEMENTS \nI am extremely grateful to Yossi Gil for digging into imperative streams, and for improving my presentation. \nMoreover, I thank Conal Elliott for discussing Pidgets and Fran with me. The comments from Boris Bokowski, \nPeter L&#38;r, and the anonymous referees were very helpful. 9 REFERENCES [II G. Berry, G. Gonthier: \nThe Esterel Synchronous Programming Language: Design, Semantics, Implementation, Science of Computer \nProgramming, 19(2), pp. 87-152, 1992 I21 F. Boussinot, R. de Simone: The SL Synchronous Language, Technical \nReport RR-2510, INRIA, March 1995 [31 P. Caspi, N. Halbwachs, D. Pilaud, J.A. Plaice: Lustre: A Declarative \nLanguage for Programming Synchronous Systems, 14 ACM Symposium on Principles of Programming Languages, \n1987 [41 Conal Elliot: A Brief Introduction to ActiveVRML, Technical Report MSR-TR-96-05, Microsoft Research, \nJuly 1996 151 Conal Elliott, Paul Hudak: Functional Reactive Animation, International Conference on Functional \nProgramming, 1997 [61 Thierrry Gautier, Paul Le Guemic, and Loic Besnard: Signal: A Declarative Language \nfor Synchronous Programming of Real-Time Systems, In Gilles Kahn (ed.) Functional Programming Languages \nand 270 Computer Architecture, pp. 257-277, LNCS 274, Springer-Verlag 1987 r71 Wolfgang Grieskamp, Thomas \nFrauenstein, Peter Pepper, Mario Siidholt: Functional Programming oj Communicating Agents and its Application \nto Graphical User Inte$aces, 2nd International Conference on Perspectives in System Informatics, Novosibirsk, \n1996 I81 Peter Henderson: Purely Functional Operating Systems, in J. Darlington, P. Henderson, D. Turner: \nFunctional Programming and its Application: An Advanced Course, Cambridge University Press, 1982 [91 \nMark. P. Jones, Luc Duponcheel: Composing monads, Research Report YALEU/DCS/RR-1004, Yale University, \nDecember 1993 [lo] Simon B. Jones, A.F. Sinclair: Functional Programming and Operating Systems, The Computer \nJournal 32(2), 1989 [l l]Gilles Kahn, David B. MacQueen: Coroutines and Networks of Parallel Processes, \nIFIP 1977 [ 121 Kent Karlsson: Nebula: A Functional Operating System, Programming Methodology Group, \nChalmers University of Technology, 198 1 [ 131 Eugenio Moggi: Computational Lambda-Calculus and Monads, \nIEEE Symposium on Logic in Computer Science, Asilomar, California, 1989 [ 14lAdrian Nye: Xlib Reference \nManual, Volume 2, O Reilly 1990 [ 151 John Peterson, Kevin Hammond (eds.): Report on the Programming \nLanguage Haskell, Version 1.4, available via ftp://haskell.org/pub/report/haskell-report- 1.4.ps.gz [16]Simon \nL. Peyton Jones, Philip Wadler: Imperative functional programming, ACM Conference on the Principles of \nProgramming Languages, ACM Press, 1993 [17]Simon L. Peyton Jones, Andrew Gordon, Sigbjem Finne: Concurrent \nHaskell, ACM Symposium on the Principles of Programming Languages, ACM Press, 1996 [18]John H. Reppy: \nCML: A Higher-Order Concurrent Language, ACM Conference on Programming Language Design and Implementation, \nJune 199 1 [ 191 Enno Scholz: Four Concurrency Primitives for Haskell, Haskell Workshop Proceedings, \nYale Univer- sity Research Report YALEU/DCS/RR-1075, 1995 [20]Enno Scholz: PIDGETS: Unifying Pictures \nand Widgets in a Constraint-Based Framework for Concurrent Functional GUI Programming, International \nSymposium on Programming Languages, Implementations, Logics, and Programs, LNCS 1140, Springer-Verlag \n1996 [21]Enno Scholz: A Framework for Programming Interactive Graphics in a Functional Programming Language, \nPhD dissertation, Freie Universittit Berlin, April 1998 [22] William Stoye: Message-Based Functional \nOperating Systems, Science of Computer Programming 6(3), pp. 29 l-3 1 I, North-Holland 1996 [23] David \nTurner: Functional Programming and Communicating Processes, Conference on Parallel Languages and Architectures \nEurope, Springer-Verlag 1987 [24] William W. Wadge, Edward A. Ashcroft: Lucid, the Datajlow Programming \nLanguage, Academic Press, New York, 1985 [25] Philip Wadler: The Essence of Functional Programming, 16th \nACM SIGPLAN-SIGACT Sympo-sium on Principles of Programming Languages, 1992 10 APPENDIX: A SEMANTICS FOR \nSIDE- EFFECT-FREE IMPERATIVE STREAMS Not all of the basic combinators presented in Section 5.1 are provided \nas primitives of the imperative streams library; in fact, liftl, lift2, . . . . reel, rec3, rec4, . . \n. next, until, merge, and start are defined in terms of time, lift, nil, hasstopped, current, (>>=), \nand rec2. Their definitions are given in Section 10.1. For lack of space, this appendix only gives a \nsemantics for imperative streams without side-effects (Sections 10.2 and 10.3). For the fully general \ncase with side-effects, two approaches are possible. The approach taken in [21] (the hard way) is to \ndefine imperative streams as a monad transformer in the style of [9] i.e., to make no assumptions about \nany operations available in the IO monad, except that it has a unit and a bind operation like any monad \n[25]. This approach gives rise to a semantic domain that is rather complicated. However, an alternative \napproach (the easy way) is to make the assumption that there are operations newRef, getRef, setRef for \nmanipulating mutable references available in the IO monad. In this approach, a - considerably simpler \n-semantic domain for imperative streams with side-effects arises, where Env, Step, and St are defined \njust as in Section 10.2 and only Stream is redefined as follows:3 type Stream a = IO (Maybe a, Maybe(Stream \na))) A stream is encoded as an imperative command returning a pair, whose first component is an optional \nvalue produced by the stream in its first step. The pair s second component is the optional continuation \nstream, to be executed in the following step. In this approach, mutable references are used to encode \nalias streams. Apart from that, it arises as a straightforward generalization of the ideas of the semantics \nwith side-effects, although it is less compact because Haskell s list manipulation functions can no longer \nbe used directly on streams. 10.1 Definition of the Non-Primitive Basic Combinators in Terms of the Primitives \nThe definitions non-primitive combinators are given in the order of dependency, i.e., each combinator \ns definition depends only on the primitives and the combinators preceding it. red f = do (s, -) <-rec2 \n(\\oldl _ --> lift (f oldl, nil)) s start s = do (sAlias, -) <-rec2 (\\_ _ --> lift (8, nil)) lift sklias \nlift1 f sl = do a + sl lift (f a) lift2 f sl s2 = do sl <-start sl 82 <-start 82 al 6 sl a2 <-82 lift \n(f a b) . . . etc. . . . merge sl s2 = do sl <-start (withTimeStamps(withStart sl)) s2 + start (withTimeStamps(withStart \n~2)) (al, timeltampl) + sl (al, timeStaq2) <-s2 if not (exists al) &#38;h not (exists al) then nil else \nif not (exists al) then lift (the a21 else if not (exists a2) then lift (the al) else lift (the (if \ntimeStamp >= timestamp then al else a2)) where WithTimeStamps :: St a --, St (a, Float) withTi.meStamps \ns = do a <-s tilnestamp <-current time lift (a, timeStamp) withstart :: St a --> St (Maybe a) withStart \ns = do 8 + start 8 hasltarted <-hasstopped (current s) if not hasstarted then lift Nothing else lift1 \nJust s until sl a2 83 = do b + merge (current (do True + sl return True) ) (lift False) if not b then \ns2 else s3 3 Here and in the sequel, to avoid clutter we pretend that Haskell allows recursive type \nsynonyms. 271 next :: St Boo1 -> St Boo1 next 8 = merge (lift False) (current (dropCurrent (do True <-s \nlift True))) where dropCurrent :: St a --> St a dropCurrent 8 = do time%-0 <-current time a <-s timeStamp \n-+ current time if timeStamp > timeStamp then lift a else nil 10.2 The Semantic Domain Steps are encoded \nby integers. A stream producing values of type a is encoded by a nonempty list of values of type Maybe \na, where the element with index i in the list (starting from zero) represents the value produced by the \nstream in step number iO+i where i0 is the step in which the stream is created. A stream which never \nterminates is represented by an infinite (lazy) list; a stream terminating after n steps is represented \nby a list with n elements. A program of type St a is represented by a function mapping a creation step \ni0 and an environment env of type Env to a stream. The environment env has one entry for each of the \nsensor streams. These entries do not directly represent the behavior of the sensor streams, rather they \nrepresent the behavior an alias stream created for their associated sensor stream in step i0 would have. \ntype Step = Int data Env = Env {keyboard-:: Stream Char, mouseButton_ :: Stream Bool, td.lne~ :: Stream \nFloat) type Stream a = [Maybe a] data St a = Step -P Env --> Stream a These are some auxiliary functions \nneeded in the semantics: indices :: Stream a --> [Step] indices [] = [I indices (a:as) = [O]++[i+l 1 \ni + indices as] left :: Step -> Stream a -> Maybe Step left i s = last ([Nothing] tt [ Just j I j <-take \n(itl) (indices s), exists (s !! j) 1) aliasAfter :: Step -> Stream a -> Stream a aliasAfter i s = [ case \nleft i s of Nothing --> Nothing Just i' --> 8 !! i' ] tt drop (itl) s envAfter :: Step -> Env -> Env \nenvAfter i env = env { keyboard- = aliasAfter i (keyboard-env), mouseButton_ = aliasAfter i (mouseButton_ \nenv), time-= aliasAfter i (time-env) ) surrogate :: Stream a --> Stream a -> Stream a surrogate as1 t1 \n= as1 surrogate [] as2 = as2 surrogate (al:asl) (a2:as2) = al : surrogate as1 as2 10.3 The Semantics \nlift a i0 env = [Just a] nil i0 env = [Nothing] tima i0 env = timer env keyboard i0 env = keyboard-env \nmouseButton i0 env = mouseButton_ env withTime stl et2 i0 env = St2 i0 env {time-= stl i0 env ) withKeyboard \nstl st2 i0 env = st2 i0 env ( keyboard- = stl i0 env ) WithMouseButton stl st2 i0 env = St2 i0 env ( \nmouseButton_ = stl i0 env } current st i0 env = let loop (a:as) = a : if exists a 11 null as then [] \nelse loop as in loop (et i0 env) hasstopped st i0 env = case st i0 env of Ial --> [Just True] a:as --, \n[Just False] tt [ Nothing 1 _ <-init as ] +t [Just True] bind at f i0 env = let 81 = st i0 env 82 i \n= surrogate (case left i sl of Nothing -s [] Just i' -> drop (i -i') (f (the (sl !I i')) (i0 t i') (envAfter \ni' env))) [ Nothing I _ <-drop i sl ] loop (as:ass) = head as : if null ass then tail as else loop ass \nin loop [ s2 i I i <-indices sl ] rec2 f i0 env = let 8 = f sOldAlias sOldAlias i0 env Just (stl, st2) \n= head s sl = stl i0 env s2 = st2 i0 env sAlias1 il _ = aliasAfter (il -i0) 81 sAlias2 il _ = aliasAfter \n(il -i0) s2 sold1 = [Nothing] +t sl sold2 = [Nothing] t+ s2 sOldAlias il _ = aliasAfter(il-i0) sold1 \nsOldAlias il _ = aliasAfter(il-i0) sold2 in [Just (skliasl, sAliasl)] 'surrogate' [Nothing I _ K-sl] \n'surrogate' [Nothing I _ + s2] 'surrogate' [Nothing I _ i-s]   \n\t\t\t", "proc_id": "289423", "abstract": "The paper presents a generalization of Haskell's IO monad suitable for synchronous concurrent programming. The new monad integrates the deterministic concurrency paradigm of synchronous programming with the powerful abstraction features of functional languages and with full support for imperative programming. For event-driven applications, it offers an alternative to the use of existing, thread-based concurrency extensions of functional languages. The concepts presented have been applied in practice in a framework for programming interactive graphics.", "authors": [{"name": "Enno Scholz", "author_profile_id": "81100253065", "affiliation": "Daimler-Benz AG, Research and Technology 3, Alt-Moabit 96a, 10559 Berlin, Germany", "person_id": "P77611", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/289423.289454", "year": "1998", "article_id": "289454", "conference": "ICFP", "title": "Imperative streams&#8212;a monadic combinator library for synchronous programming", "url": "http://dl.acm.org/citation.cfm?id=289454"}