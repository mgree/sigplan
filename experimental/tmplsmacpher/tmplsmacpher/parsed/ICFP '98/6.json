{"article_publication_date": "09-29-1998", "fulltext": "\n A Theory of Core Fudgets Colin J. Taylor Languages and Programming Group Department of Computer Science, \nUniversity of Nottingham University Park, Nottingham NG7 2RD, England. http://www.cs.nott.ac.uk/ cjt \nAbstract The Fudgets syapplications in Haskell. In this stem the lazy paper is a toolkit functional we \ndevelop for developing programming an operational graphical language semantics for a subset of this \nsystem, inspired by ideas from concur-rency theory. A semantic theory based on bisimulation is defined \nand shown to be a congruence. We consider two ap-plications of this theory: firstly, some equational \nrules useful for reasoning about Fudget programs are verified; secondly, we show how the operational \nsemantics can be used to check the correctness of implementations of the F udgets system. Introduction \n The Fudgets system [ll] is one of a number of systems for building graphical applications in lazy functional \nprogram-ming languages such as Haskell [24]. A program in the Pud- gets system is composed of a collection \nof fudgets, which correspond closely to concurrent processes in a process net-work. Fudgets can communicate \nwith one another and also with the window system, and correspond to graphical com-ponents such as pushbuttons, \nwindows and text-entry fields. Fudgets are based on the simpler concept of stream proces-sors [15, 131, \nwhich cannot communicate with the window system. The Pudgets system includes combinators to con-nect \nstream processors together. Numerous implementations of the Pudgets system exist, varying in the degree \nof concurrency they use. The origi-nal implementation [4] is written in Haskell and makes no use of concurrency. \nAlternatively, the Fudgets in Gadgets system [22] makes use of the concurrency provided by the Gadgets \nsystem [22]. In this paper we are concerned with formalising the mean- ing of programs written in the \nPudgets system. This is useful for reasoning about such programs, and also for checking the correctness \nof implementations of the Pudgets system. In-stead of attributing meanings to all the programs that can \nbe developed using the Fudgets system, we only consider the subset that use stream processors. This is \nsufficient as fud- gets can be encoded in terms of stream processors alone [5]. One approach to understanding \nthe semantics of the Fud- gets system is to use the semantic theory of the language in which the system \nis itself implemented. This is dependent on the particular implementation chosen, and may restrict the \nrange of provable statements. For example, since the original implementation is deterministic we are \nunable to prove commutativity of the parallel composition of stream processors. Ideally, we require a \nsemantics that abstracts away from such implementation details. This paper develops a semantics for a \nstream proces-sor sublanguage, called Core Fudgets, based on ideas from Milner s concurrent language \nCCS [16]. The semantics is a Plotkin style structured operational semantics [27], with the meaning of \nterms defined by a labelled transition sys-tem. Terms are equivalent if the transition trees induced \nby the semantics are bisimilar [23]. The main contributions of this paper are the definition of an operational \nsemantics and associated semantic theory for the Core Pudgets language. The theory is used to ver-ify \nsome equational rules about stream processors that are useful for reasoning about programs. The operational \nse-mantics is also used to outline a method for checking the correctness of an implementation of Core \nF udgets. These contributions form the basis for understanding the F udgets system formally, and are \ndescribed in more detail in the au-thors forthcoming thesis [29]. 1.1 Related Work We are aware of two \nother attempts to define a semantics for the Pudgets system, and we summarise the key points of these \napproaches. Our semantics resulted from an attempt to define the semantics of the Pudgets system in terms \nof the w-calculus [19], and we also review this approach. A demand driven operational semantics for F \nudgets: Hallgren and Carlsson [ll] describe a simple operational se-mantics for the Fudge&#38; system \nusing rewriting rules. This semantics takes a demand driven approach, reducing stream processors that \nproduce output before those that require input. Non-deterministic rewriting rules capture the con-currency \nof parallel composition of stream processors. The semantics we describe in this paper explores a different \nap-proach, inspired by concurrency theory, that has no bias to- wards generating output. The resulting \nsemantics has more scope for concurrency and includes Hallgren and Carlsson s semantics as an instance. \nA calculus for stream processors: More recently, Hall-gren and Carlsson [5] have suggested a calculus \nfor stream processors similar to the one we propose in this paper. How-ever, their calculus is untyped \nand although they define an equivalence based on bisimulation they do not show it to be a congruence. \nThey show how the X-calculus can be encoded in their stream processor calculus, but this requires streams \nto be able to carry values of different types. This poses no problem for their untyped calculus but as \na result we cannot use their encoding with our typed calculus. A n-calculus semantics for Fudgets: An \nalternative approach to understanding the semantics of the Fudgets sys-tem is to encode it in a language \nthat already has a formal semantics. The 7r-calculus is an appropriate choice as it sup- ports concurrency \nand higher-order communication, which are both important features of the fidgets system. This encoding \nled to the development of the semantics in this paper, which avoids some of the problems of using the \nr-calculus. For example, the 7r-calculus encodings are often large and non-intuitive in comparison to \nour operational se-mantics. The interested reader is referred to the author s forthcoming thesis [29] \nfor more details.  1.2 This paper This paper develops an operational semantics for Core Fud- gets, along \nwith a corresponding semantic theory based on bisimulation [23] - a standard notion of equivalence for \ncon- current processes. Our theory of Core Fudgets is similar to the theory of core CML [6], which is \na concurrent version of the ML language. Bisimulation has also been used to define operational theories \nof functional languages [lo], and for developing a theory of I/O in these languages [9]. Simi- larly, \nthe theory we develop here makes use of bisimulation to formalise the I/O behaviour of stream processors, \nbut, in contrast also embraces concurrency. This yields a semantics that is truly concurrent, but that \nhas possible functional implementations. The PICT programming language [25] is specified in a similar \nmanner. Although the equational rules we formally develop for the Fudgets system are unsurprising, there \nis almost no previous work published on developing such rules. The only descrip-tion of any rules for \nthe Fudgets system appears in an early tutorial [3], and describes one distributive rule. This is un- \nfortunate as the rules we develop can be useful for practical reasoning about Fudget programs such as \noptimisation. One method of proving an implementation correct with respect to an operational semantics \nis to use testing pre-orders [21]. These have previously been used to show cor-rectness of an implementation \nof the PICT language [28], and we discuss a similar approach for our semantics. In the next section we \ndescribe the stream processor sub-set of the fidgets system. Section 3 formalises the syntax and types \nof this subset in a language called Core Fudgets. The semantics for this language is defined in Section \n4, while the corresponding semantic theory is described in Section 5. Section 6 details some applications \nof the semantics, and we conclude by describing ideas for future work in Section 7. 2 Stream Processors \nAt the heart of the Fudgets system is a stream processing sublanguage. A stream is a lazy list of values \nof possibly in-finite length, while a stream processor is a process that con-sumes an input stream of \nvalues to produce a corresponding output stream of values. The Fudgets system builds on the concept of \na stream processor to obtain the concept of a fudget, which is a stream processor that can communicate \nwith the window system. It is possible to encode fudgets in terms of stream processors by tagging values \non streams to indicate if a value came from or goes to another fudget or the window system. Streams are \nconsidered to only ever carry values of a sin- gle type, and a type system is used to ensure this invariant \nis always true. A stream processor of type SP in out, can consume values of type in and produce values \nof type out. The behaviour of a stream processor is specified by the se- quence in which it reads input \nfrom its input stream and produces output on its output stream. There are numerous mechanisms for accomplishing \nthis in a functional language, such as continuation passing style I/O [14], or by using mon- ads [31]. \nThe original Fudgets system adopts a continuation passing style and defines three Haskell functions: \nputSP :: out + SP in out getSPnullSP ;; (ii ; 577k out) -+ SP in out The first function is used to produce \noutput, the second to consume input and the third to terminate a stream proces-sor. The term putSP v \nk is a stream processor that produces the value v on its output stream and then continues as the stream \nprocessor k. The stream processor getSP f reads a value x on its input stream and then continues as the \nstream processor f 2. Finally, the term nullSP corresponds to a terminated stream processor that doesn \nt produce output or consume input. 2.1 Example A simple example of a stream processor is the identity \nstream processor. This reads a value on its input stream, outputs it on its output stream, and continues \nas itself: idSP :: SP in out idSP = getSP (\\z -+ (putSP 2 idSP)). Another example is a stream processor \nthat only passes on every other value it receives on its input stream to its output stream. skip :: SP \nin out skip = getSP (\\x -+ (getSP (\\y + putSP z skip)).  2.2 Combinators Stream processors can be combined \neither in series, in paral- lel or in a loop, as illustrated in Figure 1. In these pictorial representations, \ninput is consumed at the right, while out-put is produced on the left. Two streams are merged on the \noutput side in parallel composition, while the loop combi-nator merges two streams on the input side. \nHallgren and Carlsson s semantics [ll] define this merge operation to be non-deterministic, which is \nhow we interpret it too. This de-cision requires the combinators to be intrinsic in the seman-tics, rather \nthan derived constructs from the putSP, getSP, and nulZSP functions as in the original Fudgets implementa- \ntion. Note that the input to the parallel composition of two stream processors is distributed to both \nstream processors, unlike in a process algebra, such as the r-calculus, where only one of the two processes \nwould receive the input value. We do not consider the looping combinator in the rest of this paper due \nto space restrictions, but the theory can be readily extended to encompass it [29]. -(+--a----Serial \nComposition : F >==< G t F PutSP F G F <> Parallel G Composition : F >*< G Figure 2: Duality of PutSP \nF << G and < Feedback : LoopSP F Figure 1: Stream Processor Combinators 3 Core Fudgets The language \nwe will consider in this paper, Core Fudge@ is a simplified version of the stream processor sublanguage \nof the Fudgets system. We do not include the X-calculus in this language, which would allow arbitrary \ncomputation by stream processors. Such an extension is straightforward, and all the results stated in \nthis paper hold for the extended language [29]. We define a type system for Core F udgets, primarily \nsince the original Fudgets system is implemented in a typed language. The type system also ensures that \nonly values of one type can be communicated along a particular stream. The type system simplifies the \nsemantics since we need not consider the meaning of terms that are ill-formed. 3.1 Types We consider \na monomorphic type system ~ polymorphism being an orthogonal issue for our semantics -with constant types \nand stream processor types. The symbol L E TConst ranges over a countable set of base types, with the \nset of all types described by the grammar: ..- i-..-L Constant Types 1 SP T T Stream Processor Types. \n 3.2 Terms We assume a countable set of term variables, 2, y, . . . E Var, and a countable set, c E \nConst, of constants, such that each constant c is assigned a type rc. The set of possibly open terms, \ndenoted E, F, . . . . E Expr , is given by the grammar: E ::= x Variables Constants I LdlSP Null Stream \nProcessor ] GetSP , % Input Stream Processor 1 PutSP E F Output Stream Processor 1 E>*<F Parallel Composition \nI E >==< F Serial Composition 1 E<F Feed 1 FixSP x E Recursion. There are some differences between the \nconstructs listed here and those described in the previous section. Firstly, we introduce an explicit \nfixpoint construct, FixSP, used for defining recursive stream processors such as idSP. Sec-ondly, GetSP \nand FixSP have an explicit variable argu-ment as there is no representation for functions. These two \nconstructs are similar to the corresponding constructs in the X-calculus, but their typing rules are \ndifferent. For example, the term GetSP x x cannot be typed as this would allow a stream to carry values \nof differing types. Also, we only allow fixpoints to be defined over stream processor expressions. A \nnew construct called feed is introduced to specify the semantics of stream processors. It can be considered \na dual to PutSP as shown in Figure 2. The intuitive meaning of F << G is to add the term G to the input \nstream of the stream processor F. In the special case where we constrain our semantics to favour the \nproduction of output values, all instances of the feed construct can be eliminated. This construct corresponds \nclosely to the feedSP construct in the Chalmers implementation of the Fudgets system, which supports \nadding multiple terms to the input stream of a stream processor as opposed to just a single term. We \nhave a type indexed family of null stream processors, NullSP r +,one for each combination of the types \nof input and output streams. For ease of reading, the type annota-tions on this construct will usually \nbe omitted. The constructs GetSP and FixSP are the only bind-ing constructs, and free and bound variables \nare defined in the standard way. We denote the set of free variables in a term E w FV(E), and the set \nof all closed terms as Expr. We define substitution in the standard way, and use E[F/x] to denote substituting \nF for all free occurrences of x in E, where bound variables may be renamed in order to avoid capture \nof free variables. We only consider well-typed terms, defined inductively by the typing rules in Figure \n3. A context, I , is a mapping from term variables to types. A typing judgement P k E : r asserts that \nthe term E has type r under the context I. 3.3 Examples We conclude this section with some examples \nof stream pro-cessor programs in the Core Fudget language: idSP = FixSP i (GetSP x (PutSP x i)) skip \n= FixSP s (GetSP x (GetSP y (PutSP x 3))). The first program is the identity stream processor, while \nthe second is a program that removes every other value from its input stream. (x : r) E r   Par) (Const) \n(Null) r t- NullSP, TI : SP T T r,x:rt-E:SPrr' (Input) rl-GetSPxE:SPrr' r k E : r r I- F : SP r rf (Output) \nrtPutSPEF:SPrr' (Series) r t- E : SP 7' T\" rt-E>==<F:SPrr rkF:SPrr' (Parallel) rl-E:SPrr' rl-F:SPrd \nrkE>*<F:SPrr (Feed) rl-E:SPrr' I t-E<F:SPrr l?kF:r (Fix) r,2:sPrr'kE:sPrr' r b FixSP x E : SP 7 T Figure \n3: Typing Rules for Stream Processors 4 An Operational Semantics In this section we define a structured \noperational seman-tics for Core Fudgets using ideas from Milner s concurrent language CCS [16]. We choose \nto give an operational se-mantics rather than a denotational semantics as we believe it is more intuitive \nand helps to give insight into the differ-ent implementations of the Fudgets system. In particular co-induction \n[20, 261 can be used to readily prove properties about recursive stream processor programs. The semantics \nis defined in terms of a labelled transi-tion system that characterises the immediate observations of \nCore F udget programs. A labelled transition system is a set S of states, a set A of actions used to \nlabel transitions, and a transition relation, a&#38; S x S, for each cy E A. We extend this definition \nto also include a typing context, and define the transition relation as I t E : r 3 F meaning that P \nk E : r and E can evolve into F by performing the action cr. The typing context is required to ensure \nthat only values of the correct type are communicated along streams. 4.1 Actions The actions in our semantics \nrepresent the observations that we can make of Core Budget terms. We consider three dif-ferent kinds \nof action QI as follows: 1. cy =?E, an input action. A transition I t F : r 3 G means that F can evolve \ninto G by receiving the term E on its input stream. 2. cy =!E, an output action. A transition I t F \n: r -% G means that F can evolve into G by emitting the term E on its output stream.  3. CY= u, an internal \nadministrative action. This action corresponds to the silent action r of CCS. Here we use u to avoid \nany confusion with the type r. A transition I t- F : r --% G means that F can evolve to G and requires \nno interaction with the external environment. Internal administrative actions arise from communica-tions \nbetween stream processors. Analogously to Core Fudget terms, we give typing rules for actions in Figure \n4. The (Red Action) rule states that all internal administrative actions are always well-typed. The rule \nfor input actions associates the type of the term input with the input action. Similarly, in the case \nof output ac-tions, the type of the term being output is assigned to the output action. It is important \nto type actions as their type is used to constrain the transitions that terms can make. (Red Action) \nrtvrr l-l-E:7(Znput Action) r t-?E : T rtE:r(Output Action) r t-!E: r Figure 4: Type rules for Actions \n 4.2 Transitions We define the transition relation explicitly, as opposed to defining a reduction relation \nand a structural congruence re-lation in the style of Milner [17, 181. This simplifies proving properties \nof the transition relation as it is defined induc-tively by a set of inference rules for each possible \nform of Core Fudget term. Variables, constants and NullSP have no transitions, as they cannot evolve \nfurther. Terms built from GetSP and PutSP have transitions indicating their ability to perform input \nand output actions: r t- ?E : 7 (Zw 1 r t- GetSP x F : SP T T -% F[E/x] (Out) I- t- PutSP E F : SP T \nT' -% F Any terms comprising actions that are not mentioned in the left hand side of the transition will \nbe considered to be universally quantified. The (Znpl) rule illustrates the need to extend the normal \ndefinition of transitions with typing contexts. The hypothesis of this rule ensures that only terms corresponding \nto the type of the input stream 7 can be read by the stream processor GetSP x F. If we did not have this \nhypothesis then it would be possible for a transition to result in a term that is not well-typed. Next, \nwe consider the feed construct, which has two sep-arate transition rules. The first rule allows a value \nto be fed into a stream processor that can perform an input transition of the appropriate term: I-~-EE:SPTT'~F'E' \n(FeedI) l?kE<<F:SPT#AE The second transition rule for the feed construct captures the ability of output \nand administrative actions to occur in the term which is being fed values: I- k E : SP 7 T -% E (Y E \n{v, !G} (Feed2) Serial composition has three separate transition rules, the first of which allows the \nrightmost stream processor to perform input and administrative transitions. The second rule supports \nthe leftmost stream processor performing out-put and administrative transitions: rl-F:SP7r S+F cr~{v,?G} \n(Serl) l- I- E : SP T T -% E Q: E {v, !G} (Sern) I kE>==<F:SPT7- aE >==<F The final transition rule \nfor serial composition corresponds to the communication of data between the two stream pro-cessors. This \ncan occur when the rightmost stream processor can perform an output transition, and the value output \nis then fed into the leftmost stream processor using the feed construct: rt-F:SPTT -%F Jer3 r I- E >==< \nF : SP T T --% (E << G) >==< F Serial composition corresponds closely to parallel composi-tion in a process \ncalculi such as CCS. However, the (Sers) rule differs from the rule for synchronisation in CCS of a process \nthat can perform an output with one that can per-form an input. In particular, the leftmost stream processor \nin (Sers) does not need to be able to perform an input. The rule is modelling asynchronous output as \nthe rightmost stream processor can perform its output action regardless of whether the leftmost stream \nprocessor is ready to con-sume input or not. The terms output from the rightmost stream processor are \nstored in the stream until the leftmost stream processor is ready to process them. The stream is thus \nmodelled as a buffer. Here, we use the feed construct to build this buffer, as successive outputs from \nthe rightmost stream processor will result in a chain of feed constructs into the leftmost stream processor. \nThis allows the two stream processors to proceed at different rates. We now turn our attention to the \nparallel composition of stream processors. Our first transition rule for parallel composition allows \nthe leftmost stream processor to perform output and administrative transitions: r k E : SP T T 3 E (Y \nE {u, !G} (Pan) A symmetric version of this rule is also required, allowing the rightmost stream processor \nto perform output and ad-ministrative transitions: r I- F : SP T T -% F LY E {v, !G} (Par2) rkE>*<F:SPrr \nE>>*<F All that remains is to consider when a parallel compo-sition can perform an input transition. \nThis case is quite subtle, and first we review the informal meaning of parallel composition. Values on \nthe input stream to a parallel com-position are received by both of the stream processors. This causes \na problem if we attempt to define our transition rule similarly to the rule for parallel composition \nin CCS. The obvious transition rule is defined as: l -kE:SP7#7G E r t- E >*< F : SP r r 2 E >*< F but \nthis only allows one of the branches of the parallel com-position to process the input value. The semantics \nwe desire is for both of the branches to be able to process the input value. We can achieve this by buffering \nany input values on the branch not responsible for the input using the feed construct: I-kE:SPTr ?G E \n(Pm-a) I kE>*<F:SPrr sE >*<(F<G) A symmetric version of this rule is also required, allowing the rightmost \nstream processor to perform an input action: rkF:SPTr %F (Par4) rkE>*<F:SPm =(E<G)>*<F Finally we need \nto consider the semantics of recursion. Recursion is unwound by substituting the recursive term for the \nrecursive variable as necessary. If a transition is possible when we unwind the recursion by one level \nthen the overall recursive term can also make the same transition: IY t- E[(FixSP z E)/z] : SP 7 7 -% \nE (Red r !- FixSP 2 E : SP T 7 -% E We conclude this section by proving some properties of the transition \nrelation. In particular, we show that if a term can perform an output action then the type of the action \nmust correspond to the type of the output stream of the term. A similar result holds for input actions, \nand we use both of these results to show a standard subject reduction property guaranteeing that the \ntype of a term is preserved by the transition relation: Lemma 1 (Subject Reduction) I. ifI I-E:SPrT -%E \nthenrI-F:r ; 2. ifrl-E:SPT7 sE thenrkF:r; 3. ifrl-E:r%E thenrt-E :r.  Proof. Parts (1) and (2) result \nfrom a simple induction on the inference of the transitions J? t- E : SP r r 3 E and r t E : SP r r % \nE , respectively. The last part follows by induction on the inference of r I- E : r 4 E , and by using \nparts (1) and (2) along with the standard substitution lemma which is easily proved .  4.3 Examples \n5 A Semantic Theory Before we consider formalising a theory for Core Fudgets, we pause for some examples, \nillustrating the operational se-mantics and its non-deterministic nature. The first example is given \nin Figure 5 and illustrates a simple stream proces-sor producing two constants on its output stream. \nFigure 6 shows the second example, a stream processor that discards the second value it is sent, but \nforwards the first value sent to it. There is an infinite family of initial transitions, one for each \npossible instantiation of the input variable 2. We only show one of the possible transitions for an arbitrary \ninstantiation of 2, and take this approach in the remaining examples too. As an application of recursion, \nFigure 7, shows the mean- ing attributed to the identity stream processor. It is clear that the identity \nstream processor must output any value read before continuing to read more input. The last example, in \nFigure 8, demonstrates the non-deterministic nature of the semantics for serial composition of stream \nprocessors. The initial term has two possible tran-sitions as the term can either perform an output or \nread some input. PutSP cl (PutSP c2 NullSP) 4-h (Out) PutSP cg NullSP l.!c2 (Out) NullSP Figure 5: Output \nExample GetSP z (GetSP y (PutSP z NullSP)) J?E Vw ) GetSP y (PutSP E NullSP) J.?F (IWl) PutSP E NullSP \nJ.!E (Out) NullSP Figure 6: Discard Example FixSP i (GetSP z (PutSP z i)) PutSP E (FixSP J?E i (Get \nSP z ( PutSP z i))) (Red J!E FixSP i (GetSP z (PutSP z (Out) i)) J?E VW . Figure 7: Identity Stream \nProcessor Semantics We now focus our attention on defining an appropriate equiv-alence for Core Fudget \nterms. A higher-order variation of weak early bisimulation equivalence is the one that we finally choose. \nIntuitively, this compares terms of the language ig-noring internal administrative actions, and comparing \nthe terms sent along streams using the variation of weak early bisimulation equivalence itself. We require \nour equivalences to only relate terms of the same type. This can be formalised by defining the equiva-lences \nas type-indexed families of relations: Definition 1 (Type-indexed Relation) A family of re-lations Rr,T \nbetween terms of the same type r and context I?, is a type-indexed relation if E Rr,r F implies that \nr k E : r and I? k F : r. We shall write r t- E R F : r to mean that E Rr,, F, and will omit any obvious \ntype information. Initially, we will consider equivalences on closed terms only, and so will formulate \nthem as closed type-indexed relations. These equivalences are extended to open terms by consider- ing \nall closing substitutions: Definition 2 (Open Extension) For a typing context I? where I = 21 : 71, . \n. . . x,, : r,, then a I-Closure is a sub- stitution .[c /?] where 0 t-Gi : ri for each i. The open extension, \nR , of a closed type-indexed relation, R, is the least type-indexed relation such that: l I I- E R F \n: r if and only if for all r-closures .[G/Z] then r t- E[e/Z] R F[G/Zj : r. To form the basis of a useful \nsemantic theory, an equiv-alence must be preserved by all of the constructs in the language. An equivalence \nrelation with this property is a congruence, and we capture this formally by using contexts: Definition \n3 (Context) A context is an expression con-taining a single hole, and we will use the metavariable C \nto range over them. We denote a context as F b C[-,] : r , where the hole satisfies the typing judgement \nF t--r : r. The instantiation of a context with a term E of the appro- priate type, C[E], corresponds \nto filling the hole in C with the term E, which may capture variables free in E. Intuitively, an equivalence \nrelation is a congruence if for any two terms that are related by the equivalence then the terms resulting \nfrom substituting these two terms into any context are also equivalent: Definition 4 (Congruence) A type-indexed \nequivalence re-lation, I?., is a congruence if it satisfies the following infer-ence rule:  r t q-,1 \n: d r,r t- ERE : 7 (Cov W r I- C[E]RC[E ] : T where I is the list of bound variables in the context C. \nThis definition corresponds directly to the intuition required for an equivalence to be useful for equational \nreasoning. It states that if two terms are related by the equivalence then there is no context that can \ntell the two terms apart, and so we are free to replace one term by the other. PutSP c NullSP >==< GetSP \ny NullSP I( !c \\?E NullSP >==< GetSP y NullSP PutSP c NullSP >==< NullSP J.?E J!C NullSP >==< NullSP \nNullSP >==< NullSP Figure 8: Mixed Input and Output Example 5.1 First-Order Bisimulation This problem \ncan be solved by using the weaker form of bisimulation, referred to as weak bisimulation, which doesn \nt Our starting point for an analysis of appropriate equiva-match v transitions exactly. First, we define \nweak transi-lences for Core Fudgets is strong, first-order bisimulation. tions which are used in the \ndefinition of weak bisimulation. We extend the usual definition of this equivalence to typed- indexed \nrelations as follows: Definition 7 (Weak Transition) Let ==+ be the reflexive and transitive closure \nof A, and 3 be the compositionDefinition 5 (Strong First-Order Simulation) R is a strong first-order \nsimulation if it is a closed, type-indexed a o -% o a. We define a weak transition, &#38; as: famaly \nof relations where 0 + ERF : r implies: s, a#v*= l wheneverOkE:T%E then3F .0kF:7-%Ff -{ ===s otherwise. \nand 8 l- E RF : r. Definition 8 (Weak First-Order Simulation) R is a Intuitively, we can think of this \ndefinition as requiring that weak first-order simulation if it is a closed, type-indexed fam-we can complete \nall diagrams of the following form, where ily of relations where 8 t- ERF : r implies: types have been \nomitted for simplicity: l whenever 0 I- E : r -% E then 3Fl.0 k F : r &#38; F E R F E R F and 0 k E RF \n: r. Intuitively, we can think of this definition as requiring that a as a a we can complete all diagrams \nof the following form, where types have been omitted for simplicity: 1 I I E R F E R F E E R F Definition \n6 (Strong First-Order Bisimulation) R is as a G a strong first-order bisimulation if it is a strong \nfirst-order simulation and also symmetric. Strong first-order bisimilar-I II t t + ity, ml, is defined \nto be the greatest such relation. E E R F Proposition 1 - is an equivalence. Definition 9 (Weak First-Order \nBisimulation) R is a weak first-order bisimulation if it is a weak first-order sim-Proof. By definition \n-1 is symmetric, and it is easy to show ulation and also symmetric. Weak first-order bisimilarity, {C&#38;E) \nI E w1 E} to be a strong first-order bisimulation = , is defined to be the greatest such relation. thus \nproving reflexivity. Similarly, we prove transitivity by Proposition 2 $3 is an equivalence. showing \nthat -1 o -1 2s a strong first-order bisimulation. n Proof. The proof follows similarly to Proposition \n1. n We call this equivalence first-order as actions must be matched exactly. This requirement means \nthat w1 is not a 5.2 Higher-Order Bisimulation congruence. It is easy to construct an example to demon-strate \nthis as the equivalence is not preserved by the PutSP The first-order matching of actions results in \nequivalences construct. For example, although we can show parallel com- that are too fine, as terms such \nas PutSP (E>*<F) NullSP position to be commutative, E >*< F w1 F >*< E, this and PutSP (F >*< E) NullSP \nare distinguishable. Here, equivalence is not preserved by the PutSP construct be- we follow the solution \ntaken by Thomsen [30], based on ear- cause PutSP (E >*< F) G + PutSP (F >*< E) G. lier work by Astesiano \n[l] and Boudol [2], where the terms This equivalence is strong as it requires internal admin- output \nin an output transition must be bisimilar. This is istrative v actions to be matched exactly. This yields \na called higher-order bisimulation, and we formalise it by first rather strict relation, and it is often \nthe case that one wants extending closed type-indexed relations to actions: to abstract away from the \ninternal behaviour of terms. This Definition 10 (Action Extension) A type-indexed rela- corresponds to \ntransitions of the form E --% F being un-tion, R, can be inductively extended to a relation ouer ac-observable \nby the user. For example, considering the terms tions, R , by the following rules: in Figure 9 we would \nintuitively expect A to be equivalent to B since both terms have an output transition, However, ERF B \nmust first make an internal administrative v transition before it can make this output transition, and \nthus A + B. vRDv ?ER ?E !ER !F A = PutSP c NullSP B = GetSP z (PutSP c NullSP) >==< PutSP c NullSP Figure \n9: Example of terms not w1 equivalent Strong higher-order simulation is defined similarly to it s first-order \ncounterpart: Definition 11 (Strong Higher-Order Simulation) R is a strong higher-order simulation if \nit is a closed, type- indexed family of relations where 8 I- ERF : r implies: a if@l-E:r-%E then3F ,a \n.@t-F:rsF and 8 I- E/RF : T and 8 I- cy R cy : 7 .  Intuatively, we can think of this definition as \nrequiring that we can complete all diagrams of the following form, where types have been omitted for \nsimplicity: E R F E R F , where cY cY%!?a t t t E E R F DeAnition 12 (Strong Higher-Order Bisimulation) \nA strong higher-order simulation R is a strong higher-order bisimulation if it is symmetric. Strong higher-order \nbisimi- larity, mh, is defined to be the greatest such relation. Proposition 3 N h is an equivalence. \n Proof. The proof follows similarly to Proposition 1. n Strong higher-order bisimulation, wh, is not \nparticularly useful since the abundance of internal administrative v tran- sitions in the operational \nsemantics stops us from showing even the simplest of properties. However, the natural ex-tension of this \nequivalence to use weak transitions is a much more interesting equivalence that allows us to prove such \nproperties. We will use this equivalence as the basis of an equational theory for Core Fudgets, and define \nweak higher- order simulation in an analogous manner to its first-order counterpart: Definition 13 (Weak \nHigher-Order Simulation) R is a weak higher-order simulation if it is a closed, type-indexed family of \nrelations where 8 F ERF : r implies: if0l-E:r-%E then3F ,cu .0kF:raFiand 0kE RF :r and8koRacr :~ .  \nIntuitively, we can think of this definition as requiring that we can complete all diagrams of the following \nform, where types have been omitted for simplicity: E R F E R F t t + E E R F Definition 14 (Weak Higher-Order \nBisimulation) R is a weak higher-order bisimulation if it is a weak higher- order simulation and also \nsymmetric. Weak higher-order bisimilarity, zh, is defined to be the greatest such relation. Proposition \n4 z h is an equivalence. Proof. The proof follows similarly to Proposition 1. . This equivalence is our \nfinal candidate for the basis of an equational theory for Core Fudgets. As such it should be the case \nthat the extension of this equivalence to open terms, zho, is a congruence: Proposition 5 (Congruence) \nzho is a congruence. Proof. The higher-order nature of the Core Fudgets lan-guage complicates this proof. \nThe full proof [29] follows by using Howe s method [12], which works particularly well for higher-order \nlanguages. . 6 Applications In this section we illustrate some applications of the seman-tic theory developed \nfor Core F udgets. We use the theory to prove some useful equational rules and also outline a method \nfor checking the correctness of an implementation of Core F udgets. 6.1 Equational Rules Instead of \nusing the machinery of higher-order weak bisim-ilarity for reasoning about Core Fudget programs, it would \nbe easier if we developed a set of simple equational rules: Proposition 6 (Equational Rules) The equational \nrules in Figure 10 hold for all E, F, G E Expr. Proof. The proof of these rules is routine. The two associa- \ntive rules (Assocl) and (Assoca) make use of the distributive rules for the feed construct, (Distl) and \n(Dista). . These rules can be used to optimise Core F udget programs. An obvious example is the (IdI) \nrule which can be used to eliminate terminated stream processors corresponding to a kind of garbage collection. \nSimilarly, the (I&#38;) and (Ids) rules can also be used to eliminate stream processors which have become \nstuck . Intuitively, it seems reasonable to expect that a serial composition of a stream processor, A, \nwith the identity stream processor is just equivalent to A alone. However, this is not the case as we \nhave that: E>==< idSP gh E idSP>==< F gh F Considering the first of these rules then if we take E to \nbe NullSP then the left hand side of the rule can perform an input transition that the right hand side \ncannot match. (Zero) NullSP << E (D&#38;l) (E >*< F) < G (Distz) (E >==< F) < G (D&#38;g) (E >*< F) \n>==< G (Comm) E>*< F (Assocl) (E >*< F) >*< G (Assocz) (E >==< F) >==< G NullSP >*< E (IdI) (Idz) NullSP \n>==< PutSP E F (Id31 GetSP x E >==< NullSP Figure 10: Core Fudget The problem is evident for a term \nthat has both an im-mediate input and output transition, as we can observe both actions. If instead, \nwe constrain our observations of serial and parallel compositions, such that we can only observe input \nactions when there are no output actions to observe, then the rules become valid. Interestingly, this \nconstraint also eliminates the need for the feed construct, since an in-put can only occur for a parallel \ncomposition when both branches are ready to perform an input. In the case of se-rial composition any \nvalues communicated between the two stream processors must be processed immediately in case they result \nin the ability to produce some output, and thus again the feed construct is not required. This approach \nis the one taken in the original Fudgets implementation. One possibility for solving this problem such \nthat the above identity rules do hold is to add the following inference rule to the operational semantics: \nFor the first identity rule, if E = NullSP then the right hand side can now make a matching input transition \nas re- quired. The feed construct must be an intrinsic part of the lan-guage, rather than being defined \nin terms of serial com-position and the identity stream processor, because these identity rules do not \nhold. If we defined feed as: E << F dGf E >==< PutSP F idSP. then this would lead to unexpected behaviour. \nFor example, the stream processor in Figure 11 initially consumes an item of data but then the resulting \nterm can make another input transition due to the definition of feed in terms of idSP. (GetSP z NullSP) \n>*< NullSP .J?E NullSP >*< (NullSP < E) J?E Figure 11: Problem with Feed NullSP (E<G)>*<(F<G) E >==< \n(F << G) (E >==< G) >*< (F >==< G) F >*< E E >*< (F >*< G) E >==< (F >==< G) E NullSP NullSP Equational \nRules  6.2 Correctness of Implementations Our operational semantics is also useful for checking the \ncorrectness of Fudget implementations. In order to check the correctness of an implementation we need \nto consider the implementation as a labelled transition system itself. If we can show this labelled transition \nsystem to simulate the labelled transition system of the operational semantics then we consider the implementation \nto be correct. Simulation in this case captures two properties: l Linear Time, the operational semantics \nis nondeter- ministic but most implementations will be determinis- tic. We do not intend our definition \nof correctness to prescribe particular scheduling strategies. Most prac-tical implementations will be \nincorrect if we base cor- rectness on branching time and so we only require cor-rectness to respect linear \ntime. l Termination, although we do not consider an imple-mentation which does not exhibit all the concurrent \ncomputations captured by the operational semantics to be incorrect, we do insist on maximal executions. \nIf a program terminates under the implementation then it must do so under the operational semantics too. \nThese properties lead us to propose a form of termination- preserving simulation for the definition of \ncorrectness. We begin by extending weak higher-order simulation to use two different transition relations, \n-%i, and the transition rela-tion -% of the operational semantics in Section 4. Definition 15 (Correctness \nSimulation) A closed, type- indexed family of relations R is a correctness simulation if 0 l- ERF : r \nimplies: l if 0 k E : r 3, E then 3F , cr .@ l- F : r 2 F and 0 k E RF : r and 0 I- a! 7 2 CY : T . Definition \n16 (Termination-Preserving) A closed type- indexed family of relations, R, is termination-preserving \nif 0 k ERF : I- and 0 t E : r pi implies 3F .8 I- F : r ti F where 0 k F : r ft. Definition 17 (Correctness) \nAn implementation of Core Fudgets characterised by a transition relation ai is correct with respect to \nthe operational semantics if there is some termination-preserving correctness simulation, 72, such that \nfor all E E Expr then 0 t- ERE : r. Conclusions We have considered the stream processing sublanguage \nof the Fudgets system, and described a corresponding opera-tional semantics based on concepts from concurrency \ntheory. A semantic theory has been developed using the concept of bisimulation, and was used to prove \nsome simple equational rules. Finally, we concluded by showing how the operational semantics can be used \nto check the correctness of implemen- tations of this language. The semantics presented here has been \nmotivated from a concurrency perspective. As a result we considered se-rial composition of stream processors \nin a parallel manner unlike Hallgren and Carlsson s semantics (111. In order to specify the correct semantics \nit is necessary to introduce a special construct, feed. When we constrain this semantics to be biased \ntowards generating output then we obtain the semantics given by the existing Haskell-like rewriting rules, \nand can eliminate the feed construct entirely. As previously mentioned, another approach for specify- \ning the semantics of the Core Fudgets language is to encode it in a language such as the 7r-calculus. \nThis may be partic- ularly interesting as it could be used to compare the Fudgets system with other graphical \nsystems, like Haggis [7], which already have r-calculus semantics. It would be interesting to try and \ncompletely axioma-tise the semantic theory of Core Fudgets. Such an axioma-tisation would be particularly \nuseful from a practical per-spective, as the tedious machinery of bisimulation could be completely avoided. \nThere are other implementations of the Fudgets system, and verification of them with respect to our semantics \nmay lead to interesting insights into the relationships between them. Parallel implementations of the \nFudgets system could also be explored. One possibility would be to use Concurrent Haskell [8] as the \nbasis of a concurrent implementation. One of the problems with the theory presented here is that when \narbitrary computation is allowed in stream pro-cessors then the degree to which we can reason about them \nmay be severely hampered. The stream processor: GetSP z (if 2 < 3 then PutSP True NullSP else NullSP), \n illustrates this, as we can determine that it will consume an input value, but not whether it will produce \nan output value. This can only be determined if we know the input to the stream processor. Acknowledgements \nThis work was supported by a University of Nottingham studentship. I would also like to thank my colleagues \nin the Languages and Programming research group at the Univer- sity of Nottingham, particularly Graham \nHutton, for their valuable contributions they have made to the work described in this paper. The addition \nof the feed construct was first suggested to me by Magnus Carlsson and Thomas Hallgren, while the addition \nof the (Inpl) rule to the operational semantics was suggested by Andrew D. Gordon. Finally, thanks go \nto the referees who provided detailed and helpful comments. References [l] E. Astesiano, A. Giovini, \nand G. Reggio. Generalized bisimulation in relational specification. In Proceedings of Symposium on Theoretical \nAspects of Computer Sci-ence, volume 294 of Lecture Notes in Computer Science, pages 207-226. Springer-Verlag, \n1988. PI G. Boudol. Towards a lambda calculus for concurrent and communicating systems. In TAPSOFT 89, \nvolume 351 of LNCS, pages 149-161, 1989. M. Carlsson and T. Hallgren. Programming with 131 fudgets. Available \nby anonymous FTP from pub/users/hallgren on ftp.cs.chalmers.se., De-cember 1994. M. Carlsson and T. Hallgren. \nThe Fudget Li- brary distribution. Available by anonymous FTP frompub/haskell/chalmers onftp.cs.chalmers.se., \n1995. 141 M. Carlsson and T. Hallgren. Fudgets -Purely Func-tional Processes wath applications to Graphical \nUser In- terfaces. PhD thesis, Department of Computing Sci-ence, Chalmers University of Technology, 1998. \n151 W. Ferreira, M. Hennessy, and A. Jeffrey. A theory PI of weak bisimulation for core cml. Computer \nScience Technical Report 95:05, School of Cognitive and Com-puting Sciences, University of Sussex, 1995. \nS. Finne and S. L. P. Jones. Composing Haggis. In 171 Eurographics Workshop on Programming Paradigms \nin Computer Graphics, April 1995. S. Finne and S. L. P. Jones. Concurrent Haskell. In PI Proceedings \nof the Twenty Third ACM Symposium on Principles of Programming Languages (POPL), 1996. A. D. Gordon. \nFunctional Programming and In- PI put/Output. PhD thesis, University of Cambridge, Au-gust 1992. A. D. \nGordon. Bisimilarity as a theory of functional PO1 programming. Mini-course. BRICS Notes Series NS-95-3, \nBrics, Aarhus University, 1995. Extended version of MFPS 95 and Glasgow FP 94 papers. T. Hallgren and \nM. Carlsson. Programming with Fud- 1111 gets. In J. Jeuring and E. Meijer, editors, Advanced Functional \nProgramming, volume 925 of Lecture Notes in Computer Science, pages 137-182. Springer Verlag, May 1995. \nPI D. J. Howe. Equality in lazy computation systems. In Proceedings of the Fourth IEEE Symposium on Logic \nin Computer Science, pages 198-203, 1989. G. Kahn. A preliminary theory for parallel programs. iI31 Rapport \nde Recherche 6, IRIA, January 1973. K. Karlsson. Nebula: A functional operating system. Technical report, \nProgramming Methodology Group, Chalmers University of Technology and University of Gothenburg, 1981. \n1141 P. Landin. A correspondence between algol 60 and [I51 church s lambda-notation: Part i and ii. In \nCommuni-cations of the ACM, volume 8, pages 89-101,158-165, February and March 1965. R. Milner. Communication \nand Concurrency. Prentice WI Hall. 1985. [17] R. Milner. Functions as processes. Research Report No. \n1154, INRIA, February 1990. [18] R. Milner. The polyadic x-calculus: a tutorial. Tech- nical Report \nECSLFCS-91-180, Laboratory for Foun- dations of Computer Science, Department of Computer Science, University \nof Edinburgh, UK, October 1991. [19] R. Milner, J. Parrow, and D. Walker. A calculus of mobile processes, \nparts I and II. Technical Report ECS-LFCS-89-85 and 86, Department of Computer Science, The University \nof Edinburgh, 1989. [20] R. Milner and M. Tofte. Co-induction in relational se-mantics. In Theoretical \nComputer Science, volume 87, pages 209-220, September 1990. [21] R. D. Nicola and M. C. B. Hennessy. \nTesting equiv-alences for processes. Theoretical Computer Science, 34173-133, 1984. [22] R. Noble. Lazy \nFunctional Components for Graphical User Interfaces. PhD thesis, Dept. of Computer Sci-ence, University \nof York, November 1995. [23] D. M. Park. Concurrency on automata and infinite se-quences. In Conference \non Theoretical Computer Sci-ence, volume 104 of Lecture Notes in Computer Science. Springer-Verlag, 1981. \n[24] J. Peterson and K. Hammond. Report on the Pro-gramming Language Haskell, A Non-strict, Purely Functional \nLanguage (Version 1.3). Technical Report YALEU/DCS/RR-1106, Yale University, Department of Computer Science, \nMay 1996. [25] B. C. Pierce and D. N. Turner. Pitt: A programming language based on the pi-calculus. \nTechnical Report CSCI 476, Computer Science Department, Indiana Uni-versity, 1997. [26] A. M. Pitts. \nA co-induction principle for recursively de-fined domains. Theoretical Computer Science, 124:195-219, \n1994. [27] G. D. Plotkin. A structural approach to operational semantics. Technical Report FN-19, DAIMI, \nAarhus University, September 1981. [28] P. Sewell. On implementations and semantics of a con- current \nprogramming language. In A. Mazurkiewicz and 3. Winkowski, editors, Proceedings of CONCUR 97. LNCS 1243, \npages 391-405. Springer-Verlag, 1997. [29] C. J. Taylor. Formalising and Reasoning about Fud-gets. Ph.d. \nthesis, Department of Computer Science, University of Nottingham, To appear. [30] B. Thomsen. Calculi \nfor Higher Order Communicat-ing Systems. Ph.d. thesis, Department of Computing, Imperial College, 1990. \n[31] P. Wadler. The essence of functional programing (in-vited talk). In Proceedings of the Nineteenth \nACM Symposium on Principles of Programming Languages (POPL), pages 1-14, January 1992.   \n\t\t\t", "proc_id": "289423", "abstract": "The Fudgets system is a toolkit for developing graphical applications in the lazy functional programming language Haskell. In this paper we develop an operational semantics for a subset of this system, inspired by ideas from concurrency theory. A semantic theory based on bisimulation is defined and shown to be a congruence. We consider two applications of this theory: firstly, some equational rules useful for reasoning about Fudget programs are verified; secondly, we show how the operational semantics can be used to check the correctness of implementations of the Fudgets system.", "authors": [{"name": "Colin J. Taylor", "author_profile_id": "81100518642", "affiliation": "Languages and Programming Group, Department of Computer Science, University of Nottingham, University Park, Nottingham NG7 2RD, England", "person_id": "P49768", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/289423.289430", "year": "1998", "article_id": "289430", "conference": "ICFP", "title": "A theory of core fudgets", "url": "http://dl.acm.org/citation.cfm?id=289430"}