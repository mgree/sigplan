{"article_publication_date": "09-29-1998", "fulltext": "\n On the Runtime Complexity of Type-Directed Unboxing Yasuhiko Minamide Jacques Garriguc nanQkurims.kyoto-u.ac.jp \ngarrigueQkurims.kyoto-u.ac.jp Research Institute for Mathematical Sciences Kyoto University Kyoto 6064502, \nJapan Abstract Avoiding boxing when representing native objects is csscn-tial for the efficient compilation \nof any programming lan-guage For polymorphic languages this task is difficult, but several schemes have \nbeen proposed that remove boxing on the basis of t,ype informat,ion. Leroy s type-directed unbox-ing \ntransformation is one of them. One of its nicest prop-erties is that it relies only on visible types, \nwhich makes it compatible with separate compilation. However it has been noticed that it is not safe \nboth in terms of time and space complexity --i.e. transforming a program may raise its complexity. We \npropose a refinement of this transfor-mation, still relying only on visible types, and prove that it \nsatisfies the safety condition for time complexity. The proof is an extension of the usual logical relation \nmethod, in which correctness and safety are proved simultaneously. Introduction Compared t,o explicitly \ntyped first order traditional lan- guages, polymorphically typed functional programming lan- guages have \nto face a number of challenges for their efficient compilation. One of them is choosing the right representa- \ntion for data whereas, due to polymorphism, its actual type cannot be completely known at compile time. \n In dynamically typed languages like Lisp, the basic ap-proach to data polymorphism has been to make \nthe repre-sentation homogeneous, that is to cover differences between various data types by making them \nall fit into a uniform representation. Then polymorphism is not, a problem since one knows about, the \nrepresentation of objects even with-out knowing their actual types. This approach is simple, but is also \nutterly inefficient, since it means that any dat,a which cannot fit directly into this representation, \nbeing too large for instance, has to be coerced, gcncrally by allocating the real data somewhere (e.g. \nin the heap), and by using a handle (e.g. a pointer) in place of it. Any access to the real data will \nthen require a level of indirection, particularly costly when compared with directly passing the dat,a \nvia a register. The above method, i.e. allocating data structures in the heap and passing a pointer instead, \nis called boxing, and is even used in statically typed polymorphic languages. De-spite their static typing, \nthe presence of polymorphic func-tions makes difficult the use of heterogeneous data represen-tation. \nIn the context of polymorphic languages, choosing more efficient heterogeneous representations is called \nunbox-ing. There are many approaches to perform unboxing, but we will here concern ourselves with only \none of them, type-directed unboxing transformation. The idea, formalized by Leroy [8], is to actually \nmake data representation fit its static type, exactly like it would be done in a monomorphically typed \nlanguage. However, since polymorphism means that the same value may have different static types according \nto its context, coercions between different representations are needed. This optimization s main advantage \nis that it is both cheap and effective. Since it relies only on types, no special analysis is needed, \nand separate compilation is still possible. Simultaneously, types capture the whole control flow of a \nprogram, making it possible to apply the transfor-mation almost everywhere. While this transformation \nhas been proved correct in terms of denotational semantics, it is known that it is in-correct in terms \nof complexity: optimizing may result in raising the complexity order of a program. Counter exam-ples \nwere found after a similar optimization was introduced in a publicly released compiler [20]. We think \nthat this fact reveals the need for a formal treatrnent of the complexity induced by program transfor-mation \nbased optimization techniques. In general such tech-niqucs are only proved correct in terms of semantics, \nbut not in terms of complexity. Their runtime behavior is only demonstrated by benchmarks, which tell \nabout their normal case behavior, but nothing about worst case. As an example of such a treatment, we \npresent here a re- finement of Leroy s type-directed unboxing transformation, but, this time we also \ngive a proof that, this new transfor-mation prcscrves the time complexity of programs. Notice that the \ntransformation we propose here is not guaranteed to improve the performance of programs (actually its \nperfor-mance is worst than Leroy s in most cases), but only not to raise their complexity order. The \nresults given here are the-oretical, but we believe t,hat our approach and proof method can be extended \nto more efficient optimizations, making it possible to have both performance and theoretical results. \nThis paper is organized as follows. We start with an in-formal discussion describing type-directed unboxing \nand its pitfall, then introducing our approach. In Section 3 we de- fine the language we will use in \nthe rest of the paper. We re- call Leroy s approach in Section 4. Our new transformation and its proof \nof correctness are given in Section 5. Finally we review related works, and give directions for future \nwork. Detailed proofs are included in Appendix. 2 Informal Discussion 2.1 Type-Directed Unboxing Based \non Coercions Compilation is a translation from a source language to it lower-level target language. It \nis however important to cm- sider that this target language has in fact more structure than a simple \nassembly language. That is, for a compiled program to run correctly, all compiled code and data must \nnot only be syntactically correct, but must also share the same conventions. Let us consider a function \nf,,,, : real ---f real. 111 monomorphic languages, this function will be sensibly in-plemented as a procedure \ntaking its argument and rcturn-ing its result in a floating point register. Let us suppose we do the \nsame thing in a polymorphic language. Notice first that in polymorphic languages, a polymorphic funct,ion \nfPOIY : V0.a + cr must use a more generic calling convention than freal since nothing is known about \nthe runtimc type for cy. Using boxing, fPolY will take boxed values which can be represented in one word, \nand are in the best case passed through a general purpose register. However, it may hap-pen that at runtime \nfi,Olv is used with type real + real by instantiation. We have now two possible calling conventions for \nthe type real -real: unboxed real in a floating point register for S,,,I, or boxed real through a general \npurpose register for fPOIY. Raw type information is not enough to choose the right calling convention. \nFor this very reason, many implementat,ions of polymorphic languages have just chosen a single calling \nconvention, that of fPOly, which is universal but requires all data types that do not fit in one word \nto be always boxed. In order to solve this problem, Leroy [8] has shown that by introducing coercions \nwhen a polymorphic function is specialized, one can have a function always match the calling convention \nof its type. His transformation acts on the pro-gram annotated with polymorphic types, and inserts boxing \nand unboxing so that monomorphic parts of a program can use unboxed representations of values. The key \npoint here is to distinguish between boxed and unboxed versions of types: we have both unboxed real type \nand boxed boxreal type for floating point numbers; and COP sider coercions between them: wrapreal coerces \nmu1 into boxreul and unwrapreal coerces boxreal into real. Now a function f of type v rw.a -+ (Y can \nbe safely instantiated into boxreul + boxreul, since boxreul uses the same calling con-vention as type \nvariables. However if we want to give it the type real ---* real, we have to introduce coercions where \nrepresentations change: unwrapTeal. ,reLL, (f) : real -> real = fn x => unwrapreal(f(wraprea1 x))  Thanks \nto the coercions, the calling convention of this new function matches its type. Boxing and unboxing are \nnecessary not only for special-ization of polymorphic furictions, but also for constructing and accessing \nsonic data types. It is not desirable, not even possible, to apply coercions to all data types: coercing \na whole list is too expensive, and references cannot be co-erced since one would have to make copies \nof them, changing their semantics. For such data constructors, values have t,o be coerced to their fully \nboxed representation before putting them in the constructor. Shao called these data types znco-erczble \n[lY] and we follow his terminology. We give here the example of a function g of type red -+ real being \ncoerced to boxed representation, before assigning it to a reference for instance. wrapreabred (g) : boxreal \n-> boxreal G fn x => wrapreal(g(unwraprea1 x)1 This idea of introducing coercions according to types \ncan bc extended to full ML and is implemented in [8] and [20]. Benchmarks show that it works very well \nin general. How-ever, recently several researchers have noticed undesirable behavior of some programs \nwhen compiled by this method.  2.2 Problem Let us put it short: the type-directed unboxing transforma-tion \nchanges the complexity of some programs with respect to time and space. The problem stems from the behav-ior \nof boxing and unboxing on functional values. When acting on non-functional values, boxing and unboxing \nbe-have as inverses, so that we have the following property: unwrap(wrap(v)) and wrap(unwrap(v)) are \nboth evaluated to v. However, this does not hold for function types. For example, by applying boxing \nand unboxing to f of type real 4 real we obtain the following function. ~F~P~~~;;;;;~~~r e a ;;;~~~~<f) \n1 = wrapreal (f (unwrapreal y) 1) (wrapreal x1) This expression is not evaluated to the value of f, but \nto a value wrapped with two lambda abstractions. From a deno- tational semantics point of view, they \nhave the same behav-ior. However, this changes the behavior of programs with respect to time and space. \nThis situation occurs in several ways in programs obtained by Leroy s transformation. Let us consider \nthe specialization of the polymorphic identity function to some monomorphic type. If we co-erce the polymorphic \nidentity function to the type (real ---t real) + (real --t real), we obtain the following function id \nreal-real = fn x => unwrap,,,l,,eal (id (wrapreal.+7eal (x))) Applying this identity function to a function \nf : real + real results in applying wrapping and unwrapping to f; we obtain Unwrapred-real (wrapVral+real \n(f) ) Once we have noticed this effect of boxing and unboxing, we can easily construct a program where \nthe type-directed unboxing transformation changes the complexity. Here is such a program. let. val id \n= fn x => x fun iter f 0 = 0.0 I iter f n = f (iter (id f) (n -1)) in iter (fn x => x + 1.0) n end  \nBy applying type-directed unboxing id is replaced by idrral-renl. Thus each recursive call wraps the \nfunction f with coercions and closures and increases its size. All t,hese wrappings make the complexity \noff change from ron- stant to linear in a, so that program will run in order n2 after transformation, \nwhile its naive execution would have resulted in linear time. The same problem also occurs with respect \nto space. The direct, execution of the program re- quires only a constant amount of space independent \nof n, though it requires space proportional to n if we use Leroy s representation. This violates the \nrule of safety for space complexity [l]. In this specific example, coercions can be eliminated by partially \nevaluating (id (wrapreal+,.enl f) ), but in general this is not possible: the code of id might br unknown \n-defined in another compilation unit (this is an advantage of type-directed unboxing), or abstracted \nas pa- rameter to a module--, or the reduction might increase the size of a prograrn in an unacceptable \nway (e.g. if id contains side-effects). The same problem occurs when we USC incoercible data types such \n<as references and lists. Let us consider the pro-gram: ! (ref f). Before creating the reference cell \nf must be coerced int,o fully boxed representation and after derefer-ence it must be coerced back into \nunboxed representation. Thus after the execution of this prograrn we obtain not f but the following value. \nunwrapred-d (wrap,enl+rrnl (f)) = fn x => unwrapreal((fn y => wrapreal(f(unwraprea1 y))) (wrapreal x)) \nThe same problem occurs for a pair of dereference and as- signment r := !r. In practice this situation \noccurs quite frequently and may cause some programs to abort unex- pectedly running out of memory.  \n2.3 Our Approach If WC: trace back what is happening in the above examples, we see that we have an unlimited \nnumber of coercions applied successively to the original function. The natural answer is to cut such \ninfinite chains. The way we do cut these infinite chains is by always keep-ing an untouched reference \nversion of the original function, together wit,h the specialized version. From this reference version, \nwe can obtain any degree of specialization of the function by applying a single coercion. That is we \ncan ob-tain any form of our function by applying at mist two coer-cions to the original code: one to \nbuild the rcfcrcnce version from the original function, and one to build the specialized function from \nthe reference version. There is still a question: what should bc this rcfcrence version ? The simplrst \nanswer is also the only possible one: the fully boxed form of the function. Indeed if we do not want \nto use any runtirne information, there is no other rea-sonable way to define a reference version, exact,ly \nfor the same reasons some compilers choose to use only the fully boxed form. In our scheme, there arc \nt,wo different representations for a function: the generic representation is just its fully boxed version, \nwhile specialized representations are pairs of a spe-cialized version and the fully boxed version. Going \nback to our running example, the specialized representation of f is a pair of functions (f L , fz) where \nf, and f Z have type real + real and bozreal + boxreul respectively. Applica-tion is performed by extract,ing \nthe first component of the pair before applying it to an argument v: (~1 (f 1, f 2 1 Iv. IJsing this \nspecialized representation, the generic represon-t,ation of a function can be obtained by just extracting \nthe second component of the pair: ~2 (f 1, f 2). This makes wrap-ping a function particularly simple. \nConversely, from the generic representation, one can ob-tain a specialized version by applying coercions \nas before. Let fo be a function of type bozreal --f bozreal. The spe-cialized representation is obtained \nby the following expres-sion. (fn x => unwrapreal(f0 (wrapreal x)) , fo) Now the first component is wrapped \nby coercion and lambda abstraction. Our idea is summarized in Figure 1. In this approach boxing and unboxing \nwill not cause a function to be wrapped by coercion repeatedly, growing for-ever: every time we build \na new specialized version, we start from the same untouched generic representation. As a re-sult, our \ntype-directed transformation preserves the com-plexity of programs. The translation of our previous example \nusing this rep-resentation of functions is shown in Figure 2. Details of the translation process will \nbe explained in the formal dcvelop-ment. Recursive calls of iter frorn its body of iter do not change \nthe second component of f and pass the following value for f. (unwrap,,,l -7.eal ( wrapreal+real (fn \nx => x + 1 .O)) , wrapreal+real(fn x => x + 1.0)) Although the first component of this value is wrapped \nin unwrap,.,,i,,,,l and wrapreal-trcal, it remains the same for each recursive call. Hence the complexity \nof the program is still order n with respect to evaluation steps and it runs in a constant amount of \nmemory. This approach does not solve another problern of coer-cion based unboxing. This problem is related \nwith space-complexity in an execution model using tail-call optimiza-tion. Let, us see t,he following \nprogram. fun apply (f, x1 = f x fun f x = if x < 0.0 then x else apply (f, x -1.0) Since apply (f , \nx -1 .O) is a tail call in f and f x a tail call in apply, it shall be possible to execute f in constant \nspace. The t,ypr of apply is (o -fl) x cy -/?, but, it is used at type (real --t real) x real ---t real. \nAs a result, our transforrnation (as Leroy s) will insert coercions around apply s call in f, making \nit a non-t,ail call. The transformed program will need linear space. Still, this problem shall not be \noverstated. It rnay appear with some special t,ail calls, like the one above, but it does not appear \nwith tail recursion, at least in a framework with-out polymorphic recursion. That is, in usual ML recursion, \nall recursively defined functions are monomorphic, and no coercion needs to be insert,ed in recursive \ncalls. R.ecursive tail calls are correctly transformed into tail calls. For this reason we believe that \nour transformation is space-safe, even in a model containing tail-recursion optirnization. 3 Source and \nTarget Languages In t,his section we define a language to formalize our type-directed unboxing t,ransforrnation \nand discuss the relation Specialized r2 Generic (real --t real) x (bozreal + bozreal) (bozreal + bozreal) \nx id unww,,,l+,.,,l Figure 1: Represention of Functions let val id = (fn x => x, fn x => x) fun iter \nf 0 = 0.0 I iter f n = 7r1 (f) (iter (let val f = 7r2(id) (7rz(f)) in (unwrap red-ml(f ), f ) end) (n \n-1)) in iter (fn x => x + 1 .O, wraprenlirPnl (fn x => x + 1 .O)) n end Figure 2: Example of Translation \nbetween the complexit,y of source programs a.1~1 their trans-The source language is considered as a subset \nof the target, lations. In order to make possible discussing the complex-language. Thus we will present \nthe type system and opera-ity of programs, we adopt an operational semantics which tional semantics only \nfor t,he target language. cour~tsevaluation steps. To this language we apply Milner s type discipline \n[lo] The source language is basically the core language of ML. and use the syntax-directed typing rules \npresented in [3]. Our integers require boxing. Effects of incoercible data types Typing judgments have \nthe following form: such as reference or list,s are simulated by a single incoercible type 7 pack wit,h \nconstructor pack and destructor unpack rk-e:T [19]. where IY is a finite mapping from variables to polytypes. \nr ::= (Y I int 1 T ---f T I T x T / r puck Important rules of the type system are shown in Figure 3. \nCT ::= VICYI N,L.T Other rules are standard, and we omit them to concentrate i ::= 0 11 12 1 on essential \nparts. f! ::= i / .T / cc I X.r:.r / let z = e in e / (e,c) I We define the operational semantics of \nthe source and 7r,(v) 1 TV ) pack(e) / unpack(e) I target languages by natural semantics. For integers \nwe con-iter(e, e, c) sider unboxed integers i and boxed integers ?. The values are defined as follows: \n Instead of recursive definitions, which would rnake complex-ity semantics rat,her involved, we include \niter(n, II, f) which  21 ::= i I $ I ((7, x,4) I (v,u) I ((v)) npplios thr function f to v repeatedly \n7~ times. This is enough to write crit,ical examples and simplifies our pre- where y is an environmmt, \ni.e. a finite map from variables to scnt,ation. For instance, translation using Leroy s method values, \n((7, z, e)) is a closure with an environrnent y, and ((v)) would change t,he complexity for both of \nthe following pro- is a value of type T pack. Then the operational semantics is grams (they correspond \nt,o the two examples prescntcd defined as the following relation: above) let id = Xz.3: in The rules \nare given in Figure 4. Their meaning is standard iter(rc, (0, X:C.~),X?/.(~~(Y)~~(Y),~~(~~(Y)))) except \nfor the subscript n. This subscript indicates the num-iter(n, (4 Az.z), XK.(~(,Y)TI(Y), unpack(pack(~z(y))))) \nber of evaluation steps needed to obtain the value V. The definition of evaluat,ion of iter(e1, e2, es) \nrequires two aux-The target language is extcndcd with the type bozint for iliary rules with judgments \nof the forrn 1% ~1, ~2 In V. This boxed integers and the coercions wrapint(e) and unwrapint(e) relation \nmeans that u is obtained by applying ~1 to the clo-bet.wwn int arid bozint. sure v2 repeatedly 1. times. \nWe write y k e &#38; II if y k e lk v for some /c < n. T ::= CY / rut / T -+ T I T x T / T pack 1 hmi71f, \ne 1. -zz i / 3; ) cc / X:r.e I let z = c in c I (~,e) I r,(e) I x2(e) I pack(e) I unpack(e) 1 wrapint(e) \n/ unwrapint(e) / iter(e, e, e)  I- t e : r rteerppack !J F e : boxint r t e : int r f pack(e) : T pack \nr E unpack(e) : 7 r F unwrapint(e) : int r b wrapint(e) : boxint l-(x) = va,, ,&#38;.T Don+) = {al,. \n,NrL} rtel 3-1 r, x : C~OS(T,, r) t e2 : 72 r k x : p(r) r t let z = er in e2 : r2 rkel :int rteeazT \nrte:1:7+r r t iter el,e2,e:< : 7 Figure 3: Typing Rules 7tel lnul Yte21,vz y k e 171 (Vl,W) Ytz:ll Y(Z) \nYi-illY y t (el,m ln-tn+l VI,UZ y t n,(e) 1ILfl ?J, 7 t el 1~ ((y ,z,e)) Y 1 e2lm 212 r [w/2] t e lrL \n71 y t X.r.e 11 ((7,x, e)) Y t ete2 lf+7L+m+l 21 y t (: 1 II 1 ytelni y k e In 71 Y + e In l(u)) y b \nwrapint(e) ln+, i y t unwrapmt e lTL+l z Y t pack(e) In+1 ((71)) Y t unpack(e) In+1 71 y t e1 11 11 \n-+u /x] t ez l,,L v ytecl hi 7te21mvz 7~~1,~ t, u2,m lp v y t let .c = er in c3 l~+~+r v 7 t iter(el, \nez, e3) IL+~+~+~+I v Ai > 1 tt-l ~2, ((y, x, e)) lm 71 y[w /x] t e In 71 to u,d 11 IJ tz ~2, ((Y, 2, \ne)) lnL+n+~ 21 Figure 4: Operational Semantics = Semantic t,yping of values is Mined as follows: [Tl-iQ] \nhl + hl [t1 x n] = [Tl] x [%I + 4 : int [a] = a b i : boxint  [T pack] = [T] pack  + (~l,VZ) : 71 \nx r2 if k ~1 : rr and + 112 : 72. [id] = box&#38;t I= ((7, x, e)) : 71 -F2 if there exists r such that \n+ y : r  The specialized representation of T in 7 pack is fully boxed arid r,x : 7-l \u00e4 e : 7;~. since \nr pack is an incoercible type. + ((,u)) : T pack if + v : 7. We then define coercions between specialized \nand generic types: wrap, coerces a value of IT] into [r] and unwrap,Then the st,andard type soundness \nholds for both source coerces a value of [r] into l-r]. and target languages: if an expression has type \nr and it is evaluated to 71,then II has type r. wrap,(e) = e wrap,,,(e) = wrapint(e) 4 Leroy s Type-Directed \nUnboxing wrap T,-*T2(e) = h.ww,2 (4unwrapTl (Y))) wrap e T pack(e) = Befort: formalizing our approach \nwe briefly review Leroy s let x = e in type-directed unboxing transformat,ion. For details see wrap \nTlxTz(e) = (wrapTI (~l(x)),wrap,(~z(x))) Leroy s paper [8]. First, we define two translations of types \n1.1 and [.I, where unwrap,(e) = /r( is the type of the specialized representation of r and [r] unwrap,,,(e) \n= Znwrapint(e)is t,he type of t,hc generic representation of 7. A term of type unwrap,, +T2 (e) = ~y.unww,,(4wrwT, \n(~1))7 in the source lauguage is translated into a term of type ]7-unwrap, pnCk(e) = in the targel, language. \n unwrap,, Xr2 (e) = let 2 = e in (unwrap,, (m(x)), unwrap,,(m(z))) Programs are translated by rules of \nthe form r t e : T -..+ e . The only case where something special happens is when a variable gets specialized: \nwhere specialization S, is dcfincd by mutual recursion with generalization G, as follows: S,(e : cy) \n= unwrap,(,)(e) S,(f! : int) = f! S,(e:7.pack) = e S,(e : T, -T2) = X2S,(e(C,(2 : 7-l)) : T2) S,(e:~j \nx ~22) = let z = e in (S,(n1(z) : n), Sp(m(z) : n)) G,(e : cy) = wrap,,(,,)(e) G,(e: int) = e G,(e: \n~pa.ck) = e G,(e : 71 --t 72) = Xz.G,(e(S,(2 : 71)) : 72) G,(e: ~1 x 722) = let z = e in (G,(nl(z) : \nTI), Gp(n(z) : n2)) The other rules of the translation are straightforward. To illustrate this transformation, \nthe two programs in Section 3 are translated as follows: let id = XZ.Z in iter(n,, (0, XXX), xY.(m(Y)nl(Y), \n(Xz.unwrap,,t-znt(i(t(wrap,,,,,,,(z))))~2(y)) As we explained earlier, wrapLmtWznt and unwrap,,,,,,, \nin-troduced by the translation make the complexity of both programs change from linear to 72 . 5 Formalization \nof Our Approach Along the lines of the formalizat,ion of Leroy s type-directed unboxing transformation \nin the previous section, we formal-ize our approach and prove that it preserves the complexity of a program \nwith respect to evaluation stf:ps. 5.1 Translation and Type Correctness In this section we formalize \nthe unboxing transformation based on our representation of functions and prove its type correctness. \nFirst, as for Leroy s translation we define two translations of types: IT] is the type of the specialized \nrepre-seruation of T and [T] is the type of the generic representation of 7. In + 721 = (IT11 ---) 1721) \nx [71 - 721 ITI x 721 = 16 x IT21 ICYI = cy /T p;cti z [Y-] pack In -i71t [n -T21 = [Tll + hl [n x T2] \n= [Tl] x [ L] [a] = 0 [T pack] = [T] pack [int] = bozirtt As you can see, these translations only differ \nfrom Leroy s translations by the specialized representation of functions. As we explained informally, \nthis representation is a pair of a. specialized function of type ]~i] + ]7;2] and the fully boxed function \nof type [7-r -+ ~1. You may notice also that the generic translation is closed under substitution: b1W) \n= [PC711 where [p] is a type substitution such that [p](o) = [p(o)]. We then define the operations wrap,(e) \nand unwrap,(e) where 7 is a type in the source language and e is an expres-sion of the target language: \nwrap, coerces a value into fully boxed form and unwrap, coerces a value into the unboxed form for 7, \nstarting from fully boxed form. wrap,(e) = e ww:,, (e) = wrapint(e) wrap T,-T2(e) = m(e) wrap T pack(e) \n= e wrap rlxrz(e) = let z =e in (wrvTl (nb)h ww,(~2(z))) unwrap,(e) = e unwrap,,, (e-1 = unwrapint(e) \nunwwb,+,2 (e) = let z = e in (XY.unwrap,z(z(wrap,, (Y))L x) unwrap, pack(e) = e unwrap,, xrz(e) = let \nz = e in (unwrapTl (m(z)), unww,(~z(z))) In this definition unwrap,1,,2 (e) creates a specialized ver-sion \nof the function as in Leroy s method, but retains the fully boxed version in the second component of \nthe pair. The coercion wrapTI -T2 (e) can be performed by just extracting the second component of the \npair . These operations satisfy the following lemma which states that they coerce values into their expected \ntype. Lemma 1 1. Ijr 1 e : [p]l~l, then r t wrap,(e) : [P(T)]. 2. Ijr k e : [p(7)], then r t unwrap,(e) \n: [&#38;71. The next step is to define the operation S,(e : 7) which is used to coerce values of polymorphic \ntype r into a more spe-cialized type P(T). With our representation it can be easily defined by using \nunwrap, without introducing the general-ization G,(e : 7). This comes from the fact we always build new \nversions of a function by specializing its fully boxed ver-sion, rather than generalizing another specialized \nversion. if p(r) f 7 S,(e : T) = e otherwise S,(e : cx) = unwrap,(,)(e) S,(e: int) = e S,(e : ~1 ---t \n72) = unwrap,c,,,T,j(T2(e)) S,(e: 71 X 72) = let z = e in  (Sp(Xl(~) : n), S,(rz(z) : 72)) S,(e : T \npack) = e This operation coerces a value into the proper type as stated below. Lemma 2 then : 7) : IQ(T)/. \n rjr k e : [p](l71), r t S,(e These new definitions of wrap ad unwrap arc not, con~patiblc wit,lr those \nused in the informal prcsent,;ttion: there we USA Leroy s dofirri-tions. r, 5 : rl t e : rz -d l- t \nxz.c : 7, ---) T2 - let y = X:r.e in (y, Xz.wrapT2 (?j(unwrap,, (2)))) r b eI : rl -..+ ei r, 5 : ck~(7~, \nr) t e2 : 72 -e; rtlet X=-e1 in ex:Tiulet z=e; in er I t el : ~1 rrt e; r k e2 : 72 ark e; r k e : 71 \nx r2 ^v) 6 r t (el,e2) : 7-l x r~ ^v) (e;,fJi) r t Xl(e) : r, ^v) 7r,(e )- I te:rue r t e : T puck -c \nr t pack(c) : 7 pack -pack(wrap,(e )) r F unpack(e) : T -unwrap,(unpack(e )) I t el : int -e; r k e2 \n: T ^rt eh r t e:s : 7 --i 7 u ds r + iter(el, e2, e:i) : 7 u iter(e{, eh, 7rl(eL)) Figure 5: Translation \nof Expressions Now we present the t,ranslation of expressions as a de-Finally, the two programs in Section \n3 are translated as ductive system with judgments of the form follows: rte:rl,e . let id = wrap ,+,(/\\z.z) \nin iter(n, (0, wrap ,, _ ,t(Xz:.z)),The rules of the translation are shown in Figure 5. The X(Yl,?/2).(~l~?,zfYl,translation \nis uniquely determined by the typing derivation Unwrap,,,t-zlLt(~2(id)(wrapL,t-,,t(y2))))) of e. Let \nus explain a few rules: Variable A variable 2 is translated to S,(z) which specializes the representation \nof z. Application After translation the specialized version of a where wrap TL-TZ (e) is a shorthand \nfor let y = function is obtained by extracting the first component e in (y, Xz.wrap,*(y(unwrap,, (~1))) \nand WYL, w1.e of its representation. We also simplifiedfor h.4~1 (Y)/YI, m(~Il~21. (e)) into e. As for \nLeroy s transformation, at, runtime these programs successively apply unwrap,,,-,,, Abstraction A lambda \nabstraction is translated to a pair of v (ww T1 -TZ lambda abstractions. The fully boxed version is ob-However, \nthis does not raise the original tained by coercing the specialized version by unwrapTl and wwznt+znt. \nand wrapT2. complexity anymore, as we explained earlier. We extend the translation to polytypes and \ntype environ-5.2 Correctness and Complexity ments as IVZ,l = V%.Jrl and Iri(z) = /l?(z)l. Then the type \ncorrectness of this translation is formulated as the fol-In this section WC prove the main theorem of \nthis paper: lowing lemma and proved by induction on the derivation of our version of the type-directed \nunboxing transformation is rt--:7-e . correct and does not raise the complexity of programs with respect \nto evaluation steps. Lemma 3 (Type Correctness) If r k e : T -e , then Formalizing the fact our translation \npreserves the com- pq t- e : 171. plexity of programs with respect to evaluation steps is not As an example, \nlet us consider the specialization of that easy. For instance, there exists no constant C such that a \nvariable z of polymorphic type Vc~.o + (Y to (1:nt + for any closed program e the following holds. int) \n--t zn -+ int). We do not expand wrap,,t...+znt and unwrap i t for the sake of readability. Property \n4 If 0 k c : int + e and 0 t e lVL i, then zn -tnt 0 t c J lCh i. et) 5 =  ~ ~~~~~~~~~~*~~~~~~~t~~~~t~(AI(L,, \nThis impossibility is related to the fact wrap,(e) and = let 2= ~J(z) in unwrap,(e) may require a number \nof evaluation steps pro-portional to the size of 7. This becomes clear if you consider the evaluation \nof wrap,,L(e) where 70 = int and In our representation, application of efl to an expression el -r,+, \n= 7,, x Tn. wilt be written TTI(PO)C:I. After a few administrative reduc-Notice also that, if we let \nthe ratio C depend on thetions, let us see what it looks like. closed program to be transformed, the \nabove propert,y is 7rl(eo)el = 7rl(let II: = 7rz(z) in trivial: just choose C such that Cn, is larger \nthan the number of steps needed to evaluate e ! (Xy.unwrapz,,t-tnt(~~(wrap,7,t-,,t(y))),~))el Thus, while \nthe ratio C needs to be program dependent = (~?/.unwrap,,,,-,,,(~z(~)(wrap~~~,-~~~,(?/))))e~ t,o avoid \nthe above impossibility, we will consider a larger = Unwrap,n,-tlrLt(~2(Z)(wrap27L1-rznt(el))) ClitSS \nof programs, i.e. programs with a single free variable of type int, rather than only closed ones. Then \nwe can formalize our main theorem. Theorem 5 Let e ht CA progrnrrr such that x : int t e : int - 1 . \nThen there exits a co,nstan,t C such that for any integer i, zf [i/z] t e lrL < then [i/x] t c' J.LcrL \n<. This means t,hat, the time cornpl(>xit,y of e is preserved up to C, independently of the value: of \n:I . Several st,udies related t,o program transformation have used logical relations to build correctness \nproofs [14, 8, 6, I I]. For our main theorem we ext.end t,he standard logical rela-t,ion framework so \nthat the relation between evaluation steps is taken into account. Our relat,ions depend on a constant \nC which indicat,es t,he maxirnunl ratio between the nurnber of evaluation steps in the source program \nand in the translated program. Wt: define relations between values v : 7 Z:C II : T indexed by closed \nsource and target types 7 and 7 . The definition of t,he relat,ions 0 : 7 25~: 11 : T is shown in Fig-ure \n6 where we write: E 1~ lrL 0 if (I is a closure ((y,2, e)) and y[v /z] tm c lrLpl u . The key point, \nin this definition is that in (*) t,he eval- uat,ion of the application u; to 71 is required to terminate \nnot in less than 2Crt -1 steps, but in less than 2Cn -C steps. Thanks to this extra C-1, one can obtain \nan unboxed version of u without violating t,he condition on evaluation steps. The above relations arc \nwell-defined by induction on the structure of indexing types. Our strategy to prove the main theorem \nis to find for each program a constant, C such that the program and its translation satisf,y the relation \nEC. We determine C by inspecting the maximal size of the types appearing in t,hc typing derivation of \nthe program. The size of types is defined as fotlows: size(a) = 1 size(int) = 1 size(rpack) = size(T)+ \n1 SiZe(TI x 7-l) = size(rl)+ size(r2) + 1 size(rl + ~2) = .SZ7x?(T,) + size(r2) + 1 The following lemmas \ngive an upper bound for the cost of three basic opc:rat,ions: boxing, unboxing and specialization. We \nuse a constant natural number R = 6, determined by inspecting the evaluation of wrap,(e), unwrap,(e), \nand S,(e : 7). Lemma 6 Let M be a constant natural number and C be a nrLtura1 number such that C > RM. \nThen the following hold for any r svch that size(r) 5 M. 1. 2%. Lemma 7 Let M be a constunt 7~utwul \nnvrnber and C be a rrc~l~rrr~ul rr.rlrrh~r such that C 2 RM. For any T and p sach that size(p(-r)) < \nM, zf y' I-d 17,1 v' and II : b(p(~)) NC: 11 : [4(bl(l~l)), then Y i- S,(e : ~1 Um+~t(.51re(p(T))) ,d \nad l/ : 6(p(r)) z:c d : [d(lP(T)l). The proof of t,hese lemrtlas appears in Appendix. The next lemma \ntells that we can choose a constant such that the evaluation of a source program and its trans-lation \nare related by C. For y and y two environments with same domain, y : r NC y : I means that they are point-wise \nrelated at types corresponding to the signatures JY and I . Lemma 8 Let r t e : 7 ^vt e . Then there \nexiSt.5 a COnSta7Lt C such that if y : 6(r) zc 7' : [h](lri) und y t e 1% U, then y t c $2~~~ 71 and \nv : b(~) NC: u : [S](l~l). This lemma is proved by induction on the derivation of r k (: : T u e by using \nLemma 6 and 7. An outline of the proof appears in Appendix. The rnain theorem is obtained by restricting \nthis lemma to I-= z : int and T = int. 6 Related Work I he formal study of unboxing for functional programming \nlanguages started at the beginning of the 1990 s. Peyt,on <Jones and Launchbury [IS] extended a non-strict \nfunctional language and its type system to handle unboxed values. By making all boxing and unboxing explicit \nin an intermediate language, they are able to express optimizations in terms of program transformation. \nHowever their transformations are not type-directed, and their unboxing is only local: thanks to a worker-wrapper \nmodel of functions they are able to han-dle unboxing in up to recursive function calls -the worker calls \nitself recursively with unboxed values while the wrap-per does the necessary unboxing and boxing-, but \nthey cannot handle cross-module optimizations for instance. By using a type-directed transformation, \nLeroy avoids such limitations [S]. We presented his transformation thor- oughly in the body of this paper. \n From then this area has been stimulating several at-tempts to effectively use unboxed representations \nin the implementation of polymorphic languages. Basically two approaches have been proposed so far: the \ncoercion based approach following Leroy, and another approach based on runtime type passing. Thiemann \nshowed that by tnaking some mild as-sumption on the calling convention of the underlying lan-guage, and \nusing a yet more refined type system, not only monomorphic functions but also some polymorphic func-tions \ncan get rid of boxing [22]. Henglein and Jtirgensen formalized optimality of boxing and unboxing [7]. \nHowever, their optimality criterion is based on a rewriting of programs which eliminates coercions and \ndoes not capture the run-time behavior of boxing and unboxing. Shao proposed to mix with the second approach: \nunboxing based on both co-ercion and runtime type passing [19]. His method can use part,ially unboxed \nrepresentation even for incoercible data types such as reference and lists. The main topic of these studies \nhas been to reduce boxing and unboxing operations and to extend the use of unboxed representations. However, \nnone of them was aware that ml-boxing t,ransformation may raise a program s complexity. The coercion \nbased approach is still limited by the barrier of polymorphism: once we pass a function to a higher-order \npolymorphic functional, there is no way we can use its un-boxed version. Runtimc type passing can handle \nthis case. Ohori and Takamizawa [15] showed that it is possible to pass unboxed values to polymorphic \nfunctions by parameterizing them on the size of their arguments. Harper and Morrisett, 1: int z:c i : \nint j : int =C g : boxint (Wl,W2) : 71 x 72 =c (wl,,w;) : T; x r; if 111 : ~1 zc PI; : 7: and 7)~ : -rz \nzc v$ : ~-4 ((,w)) : T pack %:c ((71 )) : 7 pack if v : 7 z:c v : 7 for all 7~1 : TI z:c vi : 7;, if \nt vu1 In 212 (*I then k v w: &#38;cn-c vb and wz : TZ EC vi : T; for all v1 : 71 ZC vi : 7;, if t zlvl \nIn 7)~ w:T1+72Mc (v , v ) : T; + 7; x 7; --t r; then 71 : T1 k w vi &#38;cn-l vi and --+ FJ EC 21I, : \n7; + 7; v2 : 71 EC vi : T; W : vCt,.T %c WI : tIcY,.T for all T%, w : [T,/LY,]T zc v : [[T,]/~u,]T \nFigure 6: Logical Relations presented a general framework to utilize runtime type in- formation by dynamically \npassing it [S]. The TIL ML com- piler [21, 121 is developed based on this framework and uses unboxed \nrepresentations. Runtime type passing does not seem to change the complexity of programs. However, there \nare difficult implementation issues in this approach [12]. Recently, the complexity problem we pointed \nhere, to-gether with the difficulties inherent to other methods, have stimulated stronger interest for \nuntyped flow analysis based optimizations. In his ML compiler, Leroy abandons type-directed unboxing \nfor a set of local untyped optimizations combined with a simple flow analysis, and reports encour-aging \nresults [9]. Goubault [4] goes further by refining the worker-wrapper model, and suggesting to inline \nthe wrap-per, cut into pre-processing and post-processing parts. He can then eliminate most of the boxing \non the basis of a control-flow analysis. While there was no concern about complexity in the un-boxing \noptimization area, there have been several studies on how to formalize complexity in functional programming \nlanguages. Santos [18] enriches natural semantics with a notion of cost in a way very similar to ours, \nand studies time-complexity properties of several transformations in a lazy functional programming language. \nHowever, the trans-formations he studied arc local and change only the con-stant amount of costs. Thus \nhe did not have to consider asymptotic complexity of programs as we do. Roe [17], and Greiner and Blelloch \n[5, 21 defined profiling operational se-mantics for parallel functional languages. The later have used \nit to prove that the translation of the parallel specu-lative X-calculus and NESL into abstract machines \npreserve asymptotic complexity of programs. Future Work This work is still ongoing, and there are problems \nleft to solve, both theoretical and practical. We have proved that our unboxing transformation pre-serves \nthe complexity of programs with respect to evaluation steps, that is safety for time. The next natural \nstep is to prove the same safety property for space. We believe our approach also preserves the space \ncomplexity of programs, in the sense of amount of live heap needed. However formal-izing that property \nwould need a more refined operational semantics such as proposed in [13], and the proof ought to be more \ninvolved. Our unboxing transformation still shares another unde-sirable property with other type-directed \nunboxing transfor-mations: it may convert some tail calls into non-tail calls, which can also change \nthe space complexity of programs (in a model including tail-call optimization). We are working at solving \nthis problem. Even if we can solve all these questions, our transforma-tion is useless if it does not \nindeed increase the performance of programs. As we stated in the introduction, on purely monomorphic \nprograms (i.e. without specialization at all) it is by definition less efficient than Leroy s, since \nwe are adding projections at every application step. Even for poly-morphic ones, our coercions are generally \nmore complex. A first remark is that it is not really as bad as it seems. For instance, our specialized \nrepresentation for function types is a pair. Since it is independent from the generic rep-resentation, \nnothing opposes unboxing this pair, and getting rid of the extra indirection needed for boxed pairs. \nIt means that we loose almost nothing on monomorphic programs, and gain when the fully boxed version \nis needed, since we already have it for free. To get, into more details we need to actually implement \nthis transformation. Another remark is that we shall be able to extend this proof to further refinements \nof the unboxing transformation, this time oriented towards efficiency. One of the problems we have is \nthat we specialize a function always from its fully boxed form. However, this can be modified without \nviolat-ing safety so that a function is specialized from its current specialized form. To achieve this \nscheme the only thing to modify is the definition of specialization. s,(e : ~1 + TX) = (Xx.S,(xl(e)(G,(x \n: 71)) : Tz), 7Q(e)) G,(e : TI --t TZ) = (~x.unwrap,,(~z(e)(wrap,l(z))), m(e)) The other cases are taken \nfrom Leroy s definitions. In this scheme, specialization increases the size of functions. How-ever, this \nexpansion does not go on forever, since general-ization restarts from the generic representation. For \nthis reason we believe this method still preserves the complexity of programs. This is yet to be proved. \nAcknowledgements This work is partially supported by Grant-in-Aid for En-couragement of Young Scientists \nof Japan No. 09780271. We would like to thank Masahito Hasegawa, Susumu Nishimura, Atsushi Ohori, and \nthe anonymous reviewers for their many helpful comments and suggestions. References A. W. Appel. Compilang \nwath Continuatzon. Cambridge University Press, 1992. G. E. Blelloch and J. Greiner. A provably time and \nspace efficient implementation of NESL. 111 P1vc. ACM SIGPLAN lnternatxonal Conference on Fanc-tzonal \nProgramming, pages 2 13 ~~225, 1996. PI 0. Clkment, .J. Despeyroux, T. Despeyroux, and G. Kahn. A simple \napplicative language: Mini-ML. In Proc. ACM Conference on Lisp and Functional Pro-gramming, pages 13 \n27, 1986. [41 .I. Goubault. Generalized unboxing, congruences and partial inlining. In Proc. Static Analysis \nSymposium, pages 147-161, 1994. .J. Greiner and G. E. Blelloch. A provably time-efficient parallel implementation \nof full speculation. In Proc. ACM Symposium on Principles of Prqramming Lan-guages, pages 309 -321, 1996. \nI51 PI R. Harper and G. Morrisett. Compiling polymorphism using intensional type analysis. In Proc. ACM \nSympo-sium on Principles of Programming Languages, pages 130~141, 1995. [71 F. Henglein and J. JGrgensen. \nFormally optimal box-ing. In Proc. ACM Symposium on Principles of Pro-gramming Languages, pages 213 ~ \n226, 1994. X. Leroy. Unboxed objects and polymorphic typing. In Proc. ACM Symposium on Principles of \nProgramming Languages, pages 177 -188, 1992. PI PI X. Leroy. The effectiveness of type-based unboxing. \nIn Proc. Internatzonal Workshop on Types in Compilation, pages 1-8, 1997. [lOI R. Milner. A theory of \ntype polymorphism in pro-gramming. ,Journal of Computer and System Sciences, 17:348-375, 1978. [111 Y. \nMinamide, G. Morrisett, and R. Harper. Typed clo-sure conversion. In Proc. ACM Symposium on Princi-ples \nof Programming Languages, pages 271 -283, 1996. [I 4 G. Morris&#38;t. Compiling with Types. PhD thesis, \nSchool of Computer Science Carnegie Mellon University, 1995. [13] G. Morrisett, M. Felleisen, and R. \nHarper. Abstract models of memory management. In Proc. ACM Sympo-.saum on Functional Programming Languages \nand Corn-puLter Architecture, pages 66-77, 1995. [ 141 A. Ohori. A polymorphic record calculus and its \ncompi-lation. ACM Transaction on Programming Languages and Systems, 17(6):844&#38;895, 1995. [15] A. \nOhori and T. Takamizawa. An unboxed operational semantics for ML polymorphism. Journal of Lisp and ,Symbolzc \nComputatrort, lO( 1):61 91, 1997. [ 161 S. L. Peyton Jones and J. Launchbury. Unboxed values ilS first \nclass citizens in a non-strict functional language. In Proc. ACM Symposium on Functional Programming \nLanguages and Computer Architecture, pages 636 .- 666, 199 1. P. R.oe. Parallel Programming using Functional \nLan- [I71 guages. PhD thesis, Department of Computing Science, University of Glasgow, 1991. [181 A. \nL. Santos. Compilation by Transfonnataon in N071-,strict Functional Languages. PhD thesis, Department \nof Computing Science, University of Glasgow, 1995. Z. Shao. Flexible representation analysis. In Proc. \n P 31 ACM SIGPLAN International Conference on Func-tional Programming, pages 85 -98, 1997. Z. Shao and \nA. W. Appel. A type-based compiler WI for Standard ML. In Proc. ACM SIGPLAN Confer-ence on Programming \nLanguage Desagn and Implemen-tation, pages 116 ~ 129, 1995. D. Tarditi, G. Morrisett, P. Cheng, C. Stone, \n WI R. Harper, and P. Lee. TIL: A type-directed optimiz-ing compiler for ML. In Proc. ACM SIGPLAN Con-ference \non Programming Language Design and Imple-mentation, pages 181-192, 1996. P. Thiemann. Polymorphic typing \nand unboxed val-ues revisited. In Proc. ACM Symposium on Functional Programming Languages and CompvLter \nArchitecture, pages 24 -35, 1995. PA A Proofs A.1 Proof of Lemma 6 Proof. By induction on the structure \nof types. We will show some important cases. In this proof we write N for NC. &#38;SC?: 7 iS 71 + 72. \nSubcase: wraprl-r2 (e ) is xz(e ). By definition of N, w can be written as (w;,w;) and v : ~(71 + ~2) \nM vh : [p(rl + ~2)). This case is proved since y k rp(e ) Urn+1 w;. Subcase: unwrap,,,,,(e ) is let x \n= e in (Xy.unwrap,,(x(wrapT1 (y))), x). By definition of the operational semantics, ~ [v lxl t (Xy.unwrap,,(x(wrap,, \n(y)))l xl 13 (((~ b lxl, Y, unwrap, (x(vwb, (y)))))lv ) Let v be ((y [w /x], y, unwrap,,(x(wrap,l (y))))). \nThen y b let x = e in (Xy.unwrap,(x(wrap,I (y))), x) 1m+3+1 ( v 14 where 3 + 1 5 R(size(Tl ---t 72)). \nNow we have to prove that v : ~(71 + 72) = (w ,w ) : [p]l~~ + 721. By the hypothesis of this lemma, w \n: ~(71 + 71 : [p][~~ ---t ~21. Thus the only thing we have to 7-z)x prove is that for all v1 : ~(71) \nN vi : [P]17i/, if t- VW1 in V2 then k w v; &#38;cn-l w&#38; and v2 : ~(72) % v; : [p]l~~l. NOW we will \nprove this claim. By induction hypothesis, [Vi/z] t wrapTI (z) $l+R(szze(TI)) 7); and 711 : ~(71) N W; \n: [p(T,)]. BY u : P(TI + 5) N v : [p(rI + TV)] and ~1 : p(rl) N v; : [p(q)] and k vv1 1% 712, we obtain \n+ W U~ &#38;c;~-c V; and 712 : ~(72) z wk : [P(Q)]. Then r b l~lk~~l~l t- y(wrw,, (2)) U l+(l+R(szze(~,)))+2Cn-C \nu; Then by induction hypothesis, r V/~lW4 k unwwTZ Mwrathl (~1)) u(2Cn-C+R(szze(T, ))+2)+R(stze(T*)) \nV; and ?I2: c'(Q) N u;' : [p]IPJl (1) By the operational semantics, t ((Y V~Y I, 2, unwrab2 (y(ww,, (z))))M \nU2Cn-C+R( sLze(T,)+sLze(r,))+a 6 Knowing that R(size(q) + size) + 3 -C 5 RM -R+Y-CL-l, k ((7 b ly l, \n6 Unwrap,, Mwrw,, (~I))))4 U2cn-1 VY (2) (I) and (2) complete the proof of this case. Case: 7 is 71 \nx 72 Subcase: wrapTI xTa (e ) is let z = e in (wrapTI (TV), wrap, (~(2))). By definition of z, v and \nV can be written as (vI,v~) and (v~,v~) such ,that v1 : p(q) N vi : [p]lq and : P(T2Tz) N : [p]1~21. \nThen r [(vi,vL)/x] t z(z) 42 vi. By fnduction hypothesis, r [(v;, vb)/z] k wrwT1(~l(x)) +2+R(sz+e(r,)) \n4 and ~1 : p(n) = Vi : [P(.TI)l. In t,he same way, r [(v;,v~)/z] b wwT2(m(x)) &#38;2+R(szze(rz)) 4 and \n~2 : ~(72) = 4 : [p(n)]. Then -/[(vi, 4)/4 k (wrap,, (~I(~)), wrw,,(~2(x))) us+R(szze(r,)+~zze(7~)) (v; \n, u;) and (VI, ~1.1) : ~(71 x ~2) NC (II; , v;) : [p(rl x 72)]. Finally, y t let z = e in (wrapT, (T1(5)), \nwrapT2(r2(a))) Um+S+R(s~re(~~)+szze(-r~))+l  (v; ,4) wherem+5+R(.size(T~)+si~e(T~))+1 5 77L+Iqsize(T1)+ \nsire(r2) + 1) = nt + R(size(q x 72)). Here we used the fact R = fi. The same proof works for unwrap,, \nxT2 (e ).  A.2 Proof of Lemma 7 Proof. By induction on the structure of T. We will show some important \ncases. In this prove we write z for z:c. Case: P(T) z T. This case is clear since Sp(e : T) is c . Cast: \n7 is (Y arid S,(e : n) is unwrap,(,,)(e ) By [p]lcyI = [I] and Lemma 6, -Y + unwrw,(,)(e ) L+R(~~~+(~))) \n7~ and PI : 6(p(~)) z 11 : [b](lp(a)l)  Case: 7 is r1 ---) 72 and S,(e : 71 + ~2) is UnwraPp(r,-TZ)(K2(e \n)). By definition of N, -y i- I JJ(,,+l) v and ZI : 6(p(q ---t 72)) = 21 : Plblh + 721 By [6][p][q + \n7-21 - [6][p(q ---t pl)] and Lemma 6, we obtain 2, : 6(&#38;l + 72)) = v : [6](lp(n + r2)l) (3) Moreover, \nunwrapp(r, --rzj (I) is actually the following expression. c = let 5 = 7r2(e ) in (Xy.unwrap,(,a,(z(wrapp(,,j(y))),2) \nThen it is clear that -y k e JJ~m+I)+:c+l 71 where (7n + 1) + 3 + 1 5 m + R(size(p(rl + 72))). This \nstatement and (3) complete the proof of this case.  A.3 Proof of Lemma 8 Proof. There is a natural number \nA4 such that the size of any t,ype appearing the derivation IY I e : 7 -.A e is less than M. Let C be \na natural number such that C > RM. Now C is fixed, and we will prove the property by induc-tion for every \njudgment in the derivation of r k e : 7 -.A e . We write N for EC. Case: r I-z : p(7-) -S,(z). We assume \nthat Dam(G) fl (5) = 8 by variable convention and Dam(p) = (5). By the hypothesison r, v : E.~(T) z v \n: E.[cS](lrl). Let p be 6 op. Then by the definition, v : p (6(7)) N v : [p ][S](l~l). That is YI : 6(p(7)) \nN v : [S][p](l~l). On the other hand y k z 11 u and y t z 11 v . Then by Lemma 7, y k S,(a: : szze(p(T))) \nY such that u : 6(p(7)) = 11 : [S](lp(~)l) where 1 + R(size(p(r))) 5 1 + RM 5 2C. 7) Ul+R( Case: r \nt-ele2 : 72 -rl(e;)e; is obtained from IY t- el : 71 ---) 72 -e; and r t e2 : ~1 -eh. Let y I el il VI \nand y t e2 lrn 712. Then by induction hypothesis for el, y t e; 42~~ (v;,t&#38; ) and VI : b(~1 + 7-z) \n= (v~,v~) : [b]((ln ---* 1~21) x [TI + 721). Then Y t- nl(e:) Uzc~+l vi. By induction hypothesis for \ne2, y b e; $2~~ vi and v2 : 6C.n 1 = v; : [S](l~ll). Let E ?IlVZ In 21. Then by the definition of N, \nt U\\U~ J.lzcn-l V and w : I N v : [6](/~21). This means that y E ele2 ll+m+n v and -y k 7rl(e;)e; &#38;~1+1+2~~+2~~-1 \nv where 2Cl + 1 + 2Cm + 2Cn-1=2C(1+m+n). Case: r k Xx.e : q + r2 -..+ let y = Xz.e in (y, Xz.wrapT2 \n(y(unwrapTl (z)))) is obtained from r, z : rl t-e : r2 2$ e . Let e be let y = X5.e in (y, Xz.wrap,2(y(unwrap,I \n(2)))). Y k Xx.e 11 ((7,x, e)) and y k e 15 ((t-f , 2, e )), ((Y [((Y , 2, Olyl, 2, wrap,,(y(unwrw,l \n(~)))))I where 5 5 2C. Take II : 6(71) = 71 : [h](j~~l). Let i-((y,z,e))v 1% 212. That rncans r[v/z] \nt e In-l 712. By induction hypothesis, $[7~ /z] k e $2~;(7L--1) V; and ~2 : h (r2) = 71; : [ct]l~~I. \nThen k ((y , x, e ))v &#38;2~(n-l)+1 71; where 2C( n-1)+1 5 2Cr~pl. Take u : 6(q) N U : [J(T~)] and \nlet y[v/z] t-((~,w,e))~ I,, v:j. That means Y[U/Z] t e -In-l ~3 (4) Now we have to consider the evaluation \nof  ((Y [((Y ,5, O/v/l7 z, ww,z (dunwrap,, k)))))v . Let y be -y [((T , z, e ))/y][v /z]. Then we will \nconsider t,hc evaluation of wrapT2 (y(unwraprL (2))) under the environment 7 . By Lemma 6, y F unwrapTl(z) \n$l+~(szze(iI)) II and v : 6(7*) 11 : [S](l:*l). By induction hypothesis for y[v/~] : 6(r,~ : ~1) z -y \n[d /z] : [6](lrl,z : 1~11) and (4), Therl Y t dunwrap,, (~1) Ul+(l+l~(~~~~(~~)))+~~(~--l)+l 4% and v:j \n: d (~.2) N U; : [6](1~1). By Lemma 6, 7 + wrap,2Munwwbl (~1)) v;U(R(stze(71))+2C(n-l)+~)+R(szz~(~~)) \nand v:j : 6(~2) z &#38; : [6(rz)]. This means where (R(size(rl)) + 2C(n -1) + 3) + R(size(T2)) + 1 = \nR(size(n -~))+2C(n-1)+4-R< RM+2C(n-1) 5 2cn -c Case: r b let z = el in e2 : T ^r) let 5 = e; in e; is \nderived from r E el : q ^v) e; and r, z : Clos(q, I?) t- e2 : 7-u eh. Let {cy,} be FTV(T~) \\ FTV(r) and \n6 be a ground sub- stitution on crz. By t.he operational semantics y 1 el 11 ~1. Then by in-duction hypothesis \ny I-e; J,lzcl V; and 111 : J (b(~l)) M u , : [S ]([~](~TI[)). By definition ~1 : V (-Y,.~(~I) N U; : \nVcr%.[S](l~ll). By the operational semantics y[vl/z] F e2 lnL v. Then by induction hypothesis, for -y[vl/z] \n: p(r,z : v~,.~,) N y [v:/x] : [p](lrj,z : IVcr,.~~j) and 7 k e2 lm v, we obtain y [vl/z] t e; &#38;cm \nZI and U : 6(72) 25 7) : [6](/~Jl). This means that y F e l~+~+l 2, and y t e Jz~,Y+ Lc~+I 71 and II \n: 6(r2) E II : [6](/72)). This case is proved since 2Cl + 2Cm + 1 5 2C(1+ m + 1). Case: r F pack(e) \n: T paclc --+ pack(wrap,(e )) is de-rived from I? F e : 7 2) e . Let y E e 1% u. Then Y + pack(e) lntl \n((II)). By induction hypothesis, y F e -/2cn PI such that v : fi(~) z w : [S]l~l. By Lemma 6, y t wrap,(e \n) 12Cn+R(szze(T)) 7~  such that, v : S(T) L=z v : [b (7)]. Then y E pack(ww,(e )) 12Clz+R(szte(r))+l \n((v )) where 2C n + R(szze(r))+l 5 2Cn+RM+l 5 2Cn+C+l 5 2C(n+l). \n\t\t\t", "proc_id": "289423", "abstract": "Avoiding boxing when representing native objects is essential for the efficient compilation of any programming language For polymorphic languages this task is difficult, but several schemes have been proposed that remove boxing on the basis of type information. Leroy's type-directed unboxing transformation is one of them. One of its nicest properties is that it relies only on visible types, which makes it compatible with separate compilation. However it has been noticed that it is not safe both in terms of time and space complexity ---<i>i.e</i>. transforming a program may raise its complexity. We propose a refinement of this transformation, still relying only on visible types, and prove that it satisfies the safety condition for time complexity. The proof is an extension of the usual logical relation method, in which correctness and safety are proved simultaneously.", "authors": [{"name": "Yasuhiko Minamide", "author_profile_id": "81100225818", "affiliation": "Research Institute for Mathematical Sciences, Kyoto University, Kyoto 606-8502, Japan", "person_id": "P304920", "email_address": "", "orcid_id": ""}, {"name": "Jacques Garrigue", "author_profile_id": "81100518834", "affiliation": "Research Institute for Mathematical Sciences, Kyoto University, Kyoto 606-8502, Japan", "person_id": "PP17010225", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/289423.289424", "year": "1998", "article_id": "289424", "conference": "ICFP", "title": "On the runtime complexity of type-directed unboxing", "url": "http://dl.acm.org/citation.cfm?id=289424"}