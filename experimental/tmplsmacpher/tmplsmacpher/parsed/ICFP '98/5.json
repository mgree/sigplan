{"article_publication_date": "09-29-1998", "fulltext": "\n The marriage of effects and monads Philip Wadler Bell Laboratories, Lucent Technologies wadler@research.bell-labs.com \nAbstract Gifford and others proposed an effect typing discipline to de- limit the scope of computational \neffects within a program, while Moggi and others proposed monads for much the same purpose. Here we marry \neffects to monads, uniting two pre- viously separate lines of research. In particular, we show that the \ntype, region, and effect system of Talpin and Jou- velot carries over directly to an analogous system \nfor mon-ads, including a type and effect reconstruction algorithm. The same technique should allow one \nto transpose any ef-fect systems into a corresponding monad system. Introduction Computational effects, \nsuch as state or continuations, are powerful medicine. If taken as directed they may cure a nasty bug, \nbut one must be wary of the side effects. For this reason, many researchers in computing seek to exploit \nthe benefits of computational effects while delimiting their scope. Two such lines of research are the \neffect typing discipline, proposed by Gifford and Lucassen (GL86, Luc87], and pursued by Talpin and Jouvelot \n[TJ92, TJ94] among others, and the use of monads, proposed by Moggi [Mog89, MogSl], and pursued by myself \n[WadSO, Wad92, Wad93, Wad951 among others. Effect systems are typically found in strict languages, such \nas FX [GJLS87] (a variant of Lisp), while monads are typically found in lazy languages, such as Haskell \n(PH97]. In my pursuit of monads, I wrote the following: . . the use of monads is similar to the use of \neffect systems . . . An intriguing question is whether a similar form of type inference could apply to \na language based on monads. [Wad921 Half a decade later, I can answer that question in the affir- mative. \nGoodness knows why it took so long, because the correspondence between effects and monads turns out to \nbe surprisingly close. The marriage of effects and monads Recall that a monad language introduces a type \nT T to represent a com- putation that yields a value of type r and may have side effects. If the call-b \n-value translation of r is rt, then we P have that (r -+ r ) , where + represents a function that may \nhave side effects, is equal to rt + T r +, where -+ rep-resents a pure function with no side effects. \nRecall also that an effect system labels each function with its possible effects, so a function type \nis now written r 4 r , indicating a function that may have effects delimited by 0. The innovation of \nthis paper is to marry effects to mon-ads, writing Tar for a computation that yields a value in r and \nmay have effects delimited by (T. Now we have that (T 4 T )+ is rt -+ TV r +. The monad translation offers \ninsight into the structure of the original effect system. In the original system, variables and lambda \nabstractions are labelled with the empty effect, and applications are labeled with the union of three \neffects (the effects of evaluating the function, the argument, and the function body). In the monad system, \neffects appear in just two places: the unit of the monad, which is labeled with the empty effect; and \nthe bind of the monad, which is labeled with the union of two effects. The translation of variables and \nlambda abstractions introduces unit , hence they are labeled with an empty effect; and the translation \nof application introduces two occurrences of bind , hence it is labeled with a union of three effects \n(each U symbol in D U cr U c coming from one bind ). Transposing effects to monads Several effect systems \nhave been proposed, carrying more or less type informa-tion, and dealing with differing computational \neffects such as state or continuations [GL86, Luc87, JG89, TJ92, TJ94]. Java contains a simple effect \nsystem, without effect vari-ables, where each method is labeled with the exceptions it might raise [GJSQG]. \nFor concreteness, this paper works with the type, region, and effect system proposed by Talpin and Jouvelot \n[TJ92], where effects indicate which regions of store are initialised, read, or written. All of Talpin \nand Jouvelot s results trans-pose in a straightforward way to a monad formulation. It seems clear that \nother effect systems can be transposed to monads in a similar way. For instance, Talpin and Jou-velot \nlater proposed a variant system [TJ94], and Tofte and Bikedal [TB98] propose a system for analysing memory \nal-location, and it appear either of these might work equally well as a basis for a monad formulation. \nThe system used in [TJSP] allows many effect variables to appear in a union and maintains sets of constraints \non effects, while the systems used in [TJ94] and (TB98] re-quires exactly one effect variable to appear \nin each union and requires no constraints other than those imposed by unification. Either form of bookkeeping \nappears to trans-pose readily to the monad setting. Applications In Glasgow Haskell, the monad ST is \nused to represent computational effects on state [PWSS, LP94]. All effects on state are lumped into a \nsingle monad. There is no way to distinguish an operation that reads the store from one that writes the \nstore, or to distinguish operations that write two distinct regions of the store (and hence can-not interfere \nwith each other). The type, region, and effect system of Talpin and Jouvelot addresses precisely this \nprob- lem, and the system described here could be applied directly to augment the ST monad with effects. \nSimilarly, in Haskell the monad IO is used to represent all computational effects that perform input/output \n[PW93, PH97]. In the Glasgow and Chalmers dialects of Haskell, this includes calls of procedures written \nin other languages [PW93]. Again, all effects are lumped into a single monad, and again a variant of \nthe system described here could be used to augment the IO monad with effects. Monads labeled with effects \ncan also be applied to op-timizing strict languages such as Standard ML. Whereas Haskell requires the \nuser to explicitly introduce monads, Standard ML can be regarded as implicitly introducing a monad everywhere, \nvia Moggi s translation from call-by-value lambda calculus into a monadic metalanguage. The implicit \nmonad of Standard ML incorporates all side effects, including operations on references and input-output, \nmuch like a combination of Haskell s ST and IO monads. As be- fore, labeling the monad with effects can \nbe used to delimit the scope of effects. In particular, where the monad is la- beled with the empty effect, \nthe corresponding term is pure and additional optimizations may be applied. Or when the monad reads but \ndoes not write the store, certain operations may be commuted. This technique has been applied to inter- \nmediate languages for Standard ML compilers by Tolmach [To1981 and by Benton, Kennedy, and Russel [BKR98]. \nOur work can be regarded as complementary to theirs: we pro- vide the theory and they provide the practice. \nSummary of results Talpin and Jouvelot present (i) a type system with effects, (ii) a semantics, with \na proof that types and effects are consistent with the semantics (iii) a type and effect reconstruction \nalgorithm, with a proof that it is sound and complete. We review each of these results, fol-lowing it \nby the corresponding result for the monad system. We also recall the call-by-value translation from lambda \ncal-culus into a monad language, and show that this translation preserves (i) types, (ii) semantics, \nand (iii) the principal types derived by the reconstruction algorithms. By and large, we stick to the \nnotation and formulation of Talpin and Jouvelot [TJ92]. (Along the way, we correct a few infelicities \nin their paper.) One difference from Talpin and Jouvelot is that they follow the classic work of Tofte \n[Tof87] and use an operational semantics based on normal- istation ( big step ), while we follow the \nupdated approach of Wright and Felleisen [WF94] and use an operational seman-tics based on reduction \n( small step ). As noted by Wright and Felleisen, this leads to a simpler proof: instead of a com- plex \nrelation between values and types (specified as a great- est fixpoint), we can use the existing type \nrelation (specified by structural induction). The monad translation we use is standard. It was in- troduced \nby Moggi [Mog89, MogQl], and has been further studied by Hatcliff and Danvy [HD94] and Sabry and Wadler \n[SW97]. Our reduction semantics for the monad is new. It most closely resembles the work of Hatcliff \nand Danvy, but they did not deal with state and therefore failed to distin- guish between pure reductions \nand those with computational effects, as we do here. The results are all obtained by straightforward \napplica-tion of well-known techniques, and so we don t bother to give the proofs in detail. The lack \nof interest in the proofs is part of our point: results for effect systems transpose to monads without \nmuch effort. Value polymorphism Some care is required when mix-ing computational effects with polymorphic \ntypes, lest soundness be forfeit. One approach, due Tofte [Tot871 and used in the original SML [MTHSO], \nintroduces impera-tive type variables in the presence of computational effects. Numerous other approaches \nhave been broached, including some based on effects [wri92, TJ94]. However, by far the simplest is value \npolymorphism. This approach, noted by Tofte [Tof87], promoted by Wright [Wri95], and used in the revised \nSML [MTHM97], restricts polymorphism to values, a subclass of expressions that can have no computational \nef-fects. Talpin and Jouvelot [TJSP] used value polymorphism, and we do so here. There is potentially \na problem here. Moggi s original monad translation was monomorphic, and it was not en-tirely obvious \nhow to extend it to polymorphism. I recall a conversation several years ago between Moggi, John Hughes, \nand myself where we attempted to add polymorphism to the translation and failed. However, we did not \nconsider value polymorphism, which was less popular back then. One contribution of this paper is to extend \nthe monad translation to include value polymorphism. This extension is presented for the monad system \nwith effects, but applies equally well when effects are absent. In retrospect, the ex-tension seems obvious, \nsince the monad translation handles values specially. One might say that value polymorphism fits monads \nto a T . Outline The remainder of this paper is organised as fol- lows. Section 2 introduces the effect \ntype system and the corresponding type system for monads, and introduces the monad translation and shows \nthat it preserves types. Sec-tion 3 presents an operational semantics for effects and a corresponding \nsemantics for monads, shows each semantics sound with respect to types, and shows that the monad translation \npreserves semantics. Section 4 presents a type, region, and effect reconstruction algorithm for effects \nand a corresponding algorithm for monad, shows each algorithm is sound and complete, and shows that the \nmonad translation relates the two algorithms. Section 5 concludes. 2 Types This section introduces two \nlanguages and their type sys-tems, and the translation between them. The first language, Efect, is a \ncall-by-value lambda calculus together with op-erations on a store, with a type system that includes \nre-gions and effects. The second language, Monad, is based on Moggi s monad metalanguage together with \nthe same store operations, and with a type system augmented by the same regions and effects. We extend \nthe usual monad translation to include effects, and show that it preserves typings. 2.1 Types for Effect \nThe language Effect and its type system is shown in Figure 1. There are two syntactic classes, values \nand expressions. A value is eit,her an identifier, a lambda abstraction, or a re- cursive function binding. \nAn expression is either a value, an application, a let binding, or one of three primitives oper-ations \non the store, which allocate a new reference, get the value of a reference, and set a reference to a \nnew value. x E Id v E Vul v::=xlXx.e/recx.Xx .e e E Exp e::=vIee Iletx=eiine IneueIgeteIsetee r E RegConst \ny E Reg Var p E Region p::=yIr c E EffVar u E Effect u ::= q ( 8 I u U o 1 init I read(p) 1 vrite(P) \na E !FyVar L E Basenpe TE &#38;E ISpe FyEnv 7 ::= cx 1 L 1 7 4 =Zd-t Type T 1 ref, 7 ~U{~++T~~ ,Z I--+--~ \nkeffe:7!0 (uar) (ret) Ez*z E t &#38;2: u {x t-) T} l-&#38;-f 2 : 7 ! 0 eff ret x. Xx . e : 7 4 7 ! \n0 E, U z I-+ 7-Feff e : 7 !6 capp) &#38; t,tf e : 7 -; 7 ! u &#38; teff e : 7 ! u Cabs) Et eff Xx.e:7%#!0 \nE teff e e : r ! u U u U 0 &#38;k,ffe::!!a u 7 u El-,fie:T!u (does) (new) Et &#38; t,fl e : T ! u Ed \nnew e : ref P 7 ! u U init El-,ffe:ref,T!u E teff e : ref, T ! u E l-,=.ff e : 7 ! 6 (94 E t (set) Ed \nget e : T ! u U read(p) El-,flsetee :-r!uUu Uwrite(p) Figure 1: The effect calculus, Eflect A region \nis either a region variable or a region constant. An effect is either the empty effect, the union of \ntwo effects, or one of three effects corresponding to the three operations on the store, each of which \nis labelled with the region of store affected. Equality on effects is modulo the assumption that U is \nassociative, commutative, idempotent, and has 8 as a unit. We write u > u when u = u U u . A type is \neither a type variable, a base type, a function type (labelled with the effect that occurs when the func-tion \nis applied), a reference type (labelled with the region in which the reference is located). A type environment \nmaps identifiers to types. We write &#38;, for the environment with x removed from its domain, {x I+ \nT} for the environment that maps z to r, and E U E for the union of two maps with disjoint domains. (Similar \nnotation will be used later for stores and substitutions.) A typing &#38; keff e : r ! u indicates that \nexpression e yields a value of type 7 and has effect delimited by u, where the type environment &#38; \nmaps the free identifiers of e to types. in the rule for abstraction, (abs), the effect is empty be-cause \nevaluation immediately returns the function, with no side effects; while the effect on the function arrow \nis the same as the effect for the function body, because applying the function will have the same side \neffects as evaluating the body. In the rule for application, (app), the effect is the union of the effects \nfor evaluating the function, evaluating the argument, and applying the function. There are two rules \nfor let binding, a polymorphic rule for binding values (let), and a non-polymorphic rule other-wise (ilet). \nFollowing Talpin and Jouvelot, we use substi- tion rather than type schemes to indicate polymorphism. \nThe equivalence of the two forms of specification is well known (e.g., see Mitchell s text [Mit96]). \nThe notation e[v/x] stands for the substitution of value v for identifier x in expression e, with renaming \nto avoid capture of bound identifiers. Of course, actually performing the substitution is far too expensive \nwhen it comes to type reconstruction, and Talpin and Jouvelot s algorithm uses a form of type scheme, \nas one would expect. Note that if &#38; t- v : T ! u then u must be 0. Rule (does) permits a form of \nsubeffecting. Effects indi-cate an upper bound on the side effects a term may have, and so may always \nbe made larger. The rules for the three primitive operations, (new), (get), and (set), add the cor-responding \neffect to the effects for their arguments. The region in the effect matches the region in the reference \ntype. The (new) rule may allocate a new reference in any region. 2.2 Types for Monad Whereas Eflect \nis a call-by-value language, with side effects occuring when any expression is evaluated, Monad is a \ncall- by-name (or call-by-need) language, with side effects occur-ing only at top-level. All computations \nwith side effects are e E MonExp e::=x)Ax.e)recx.e)ee Iletx=eine I<e>Iletx*eine IneweIgeteIsetee r E \nMonnpe r ::= a ( L 1 T + r 1 TO r 1 ref, T &#38; E MonTyEnv = Id 4 MonType (abs) E, U {x I--t 7) hoI \ne : 7 65, U {x ti T} Fmon e : 7 (var) (ret) E, u {x t-$ r} t-n,,,, x : T Et lllotl Xx. e : 7 -+ r &#38; \nt-mon ret x. e : r 1 E tIIlol, e : 7 + 7 E ~~~~~~~ e . 7 E FltlO1l e : 7 Et-man e e x : r (am) , I (W \nI I E h11o11 e e : 7 &#38; ttlloI1 let x = e in e : 7 &#38; t-lt10l1 e : Ta T E h~0tl e : r (does) E \nb*,,on e : y ; 2 u (new) &#38; l-111o11 ref p 7 new e : T initb) E tlllOll e : refp r &#38; t-1,1o11 \ne : refp 7 tt l~l~fl e :7 (94 (set) set &#38; l-.111ol1 get e : Tr*ad(pl ref p Q- &#38; l--111o11 e e \n: T writ*(p) -I- Figure 2: The monad language, Monad represented by the new monad type. We use call-by-name \nfor monads to stress the rela-tion to Haskell. Like Plotkin s CPS translation, Moggi s monad translation \nis indifferent: it remains valid whether the monad language uses call-by-value or call-by-name [Plo75, \nHD94, SW9 7]. The language Monad and its type system is shown in Figure 2. The distinction between values \nand expressions is no longer relevant, since evaluation has no side effects. Ex-pressions are extended \nwith two new forms for manipulating monads (we will describe these shortly). Regions and effects are \nas before. The function type r 4 7 of before is here broken into the pure function type r --t r , and \nthe monad type TO r, representing a computation that yields a value of type r and has effects delimited \nby u. The monad unit <e> denotes the computation that im-mediately returns the value of e, with no effects. \nHence in (unit) the effect is empty. The monad bind let z + e in e denotes the computation that first \nperforms computation e, binds x to the result, and then performs computation e . Hence in (bind) the \neffect is the union of the effects of its two subcomputations. (The forms <e> and let z (r e in e are \nwritten in Haskell as retrune and e >>= Xx. e , respectively.) Ordinary binding let x = e in e is distinct \nfrom monad bind. As shown in rule (let), it corresponds to polymor-phism. Since expressions have no side \neffects, there is no need to restrict polymorphism to values. The remaining rules are straightforward \nadjustments of the previous forms. The three primitive operations, since they involve computa-tional \neffects, have monad types. 2.3 The translation The translation from Effect to Monad is shown in Figure \n3. This is just the usual typed call-by-value monad translation. We write rt for the translation on types, \nvt for the transla- tion on values, e* for the translation on expressions, and Et for the translation \non type environments. As is well known, the monad translation preserves typ-ing, a property that continues \nhold for our systems with effects. Proposition 2.1 (nanslation preserves types) The proof is by induction \non the structure of type deriva-tions. For example, the translation of variables and lambda abstractions \nintroduces unit , hence they are labeled with an empty effect; and the translation of application intro-duces \ntwo occurrences of bind , hence it is labeled with a union of three effects (each U symbol in o U u U \nu coming from one bind ). The translation of let works out neatly thanks to the value polymorphism restriction. \nWhereas the translation of an expression is a monad, and so must be bound with the non-polymorphic monad \nbind, the translation of a value is not a monad, and can safely be bound with the polymorphic let. The \nfigure also shows the grammar of expressions and types in Monad that are in the image of the translation \nfrom values, expressions, and types in Effect. In the im-age, application always has values for function \nand the ar-gument, ordinary let always binds to a value, and monad unit always contains a value. This \nexplains the indifference property alluded to earlier: since functions are applied only to values, call-by-value \nand call-by-name agree in the image of the translation. ct+ = a (L)+ = 1 (7. 4 r )+ = r+ -+ T #+ (refP?-)+ \n= ref,7+ x+ = x (Xx.e)+ = Xx.e* (ret x. Xx . e)+ = ret 2. Xx . e* * = <?I+> (ee;* In xx = let 2 t= \ne in let x * e * (letx=vine)* = letx=v+ine* (let x = e in e ) = let x (r e in f: * (newe)* = letx*e* \ninnewx (get e)* = letxee* ingetx (setee ) = let x G= e in let x X= e * in set xx (Xl :rl,...,xn:rn) \n+ = x1:&#38;.. .,xn : 7; 21 E 13unVal w::=xIXx.e e E !PranExp e::=vIrecx.eI UV Iletx=vine I<v>Iletx*eine \nInewwIgetvIsetvv r E TranType r ::= Q 1 L I t -+ T r 1 ref P T Figure 3: Translation from Effect to Monad \n3 Semantics This section presents operational semantics of the two lan-guages. The reduction system for \nEflect is standard, save for instrumentation to trace operations on the store, which is used to demonstrate \nconsistency between semantics and effects. The reduction system for Monad appear to be new, even without \nthe instrumentation. It resembles that of Hat- cliff and Danvy [HD94], but differs in distinguishing \ntwo sorts of reductions, those that may have side effects and those that do not. For both effects and \nmonads, we show that the type and effect system is sound, modifying the re-sults of Wright and Felleisen \n[WF94] to take take effects and monads into account. We also show that the transla-tion preserves semantics, \nin that it preserves instrumented reductions. 3.1 Semantics for Effect The operational semantics for \nEffect are shown in Figure 4. Locations E are a designated subset of the variables. By convention, a \nlocation is never used as the bound variable in a lambda or let expression. A store s maps locations \nto values. A trace f is the semantic equivalent of an effect, where regions are replaced by locations. \nThe notation sl U (1 e V} stands for the store that maps location 1 to value v and otherwise behaves \nlike store s (by convention, s does not have 1 in its domain). An expression e is closed with respect \nto a store s if the only free variables in e are locations in s, that is, if fv(e) E dam(s). We restrict \nour attention to reduction states s,e where e is closed with respect to s. A single reduction step is \nwritten s, e -&#38;,=.R s , e , where s, e is the state before the step, f is a trace of the effects \nof the step, and s , e is the state after the step. Rule (beta) specifies function application; the language \nEflect is call-by-value as the argument must be a value for the rule to apply. The rule leaves the store \nunchanged and is labeled with an empty effect. Rules (rep) and (let) are similar. Rules (new), (get), \nand (set) perform actions on the store and have corresponding effects. Rule (app0) allows reduction of \nthe first part of an application; and once it is reduced to a value, rule (app1) allows reduction of \nthe second part; eventually either rule (beta) or (ret) will apply. The other numbered rules are similar. \nFinally, rules (step), ~;~~J~ean~~) specify ---ft as the reflexive and transitive (Wright and Felleisen, \namong others, use evaluation con-texts as a concise notation that achieves the same effect as the numbered \nrules here. We ll see why we don t use con- texts here in the next subsection.) We need to relate stores \nto type environments, and traces to effects. Write &#38; keff s if dam(s) = dom(&#38;) and &#38; keff \ns(Z) : E(1) for each 1 E dam(s). Write &#38; l-,~ f ! u if l when init &#38; f then E(E) = ref, T and \ninit C u, l when read(l) C f then &#38;(I) = ref, 7 and read(p) c O, l when write(l) G f then E(l) = \nrefp 7 and write(p) C u. Reductions preserve types and are consistent with effects. Proposition 3.1 \n(Subject reduction) If &#38; l-eff s and &#38; Feff e : T ! o and s, e Lee s , e then there exists a \nE > &#38; such that E keff s and E keff e : 7 ! D and E keff f ! u. 67 The proof is by case analysis \non the reduction step. 1 E Ref 2 Var s E Store = Ref + Value f E fiace f ::= 0 I f u f 1 init 1 read(l) \n( write(l) (beta) s, (Xx. e)v Aefl s,+lel tree) s, (ret 2. Xx . e)v -Qeff s, (Xx . ret 2. Xx . e[x/e])u \nt 14 s, let x = 2) in e jeff s, 4x/e] (new) s, new v inG)efl su{l~~},x freshles (get) (set) sl 91 U (1 \nU {I H I-+ o}, getl w},setlv' Iand ),ff 2 \"rite(I)4 &#38; .sl U {I i-3 Sl u (1 c) v},w v'},v' (an4 s,e \ns, e e Lefi Lefi s ,e s , e e (am4 9, e J-kefi s, v e L,ff s , e s, v e (let0) s, let x = s,e f ,ff \ne in e &#38;,ff s ,e s , let x = e in e (new0) s, e Leff 5, new e L,ff s , e s , new e (WA s, e -Gaff \ns, get e --G,ff s , e s , get e (set0) s, e -hefi s, set e e -5,~ s , e s , set e e (setl) s, e fteff \ns,setve -5,~ s , e s ,setve (step) s, e -f-tefl s, e ISfeff s , e s , e ( r@) s,e Aefl s,e (tran) s, \ne Aeff s , e s, e Seff f s , e --++,=,ff s , e s , e Figure 4: Semantics for Effect As noted by Wright \nand Felleisen [WF94], for type soundness one also wants to prove a syntactic equivalent of Milner s slogan \nwell typed expressions cannot go wrong . An expression e is faulty if it contains a subexpression in \none of the following forms: v e, where 21 is a location, get v, where v is not a location, set u of, \nwhere u is not a location. An evaluation state s, e is stuck if there is no f, s , e such that s, e \nAe~ s ,e , and if e is not a value. Evaluation becomes stuck only for faulty expressions, while well-typed \nexpressions are never faulty. Proposition 3.2 (Uniform evaluation) If e is closed over s and s, e is \nstuck, then e is faulty. Proposition 3.3 [Well-typed expressions are not faulty) If &#38; Eeff e : 7 \n! 6, then e is not faulty. The first proof is by induction over the structure of e, and the second by \ncase analysis of the definition of faulty. It follows that evaluation of well-typed terms never gets \nstuck. Write . is an infinite reduction s, e +&#38; If there Jo fl f2 s, e ----+df sl, el --beff 92, \ne2 -+eff . . . with f = IJ f;. We have the following corollary. Proposition 3.4 (Type soundness) If &#38; \nl-e~ s and &#38; l-e~ e : r ! u then either l s,e&#38; and&#38;l-,tf f !a, or l s,~~~ffs ,vand&#38;t,tfs \nand&#38;t,t~v:T!0and &#38;t-&#38;f !u.  3.2 Semantics for Monad Our reduction system is specialised \nto the case where the top-level expression has a monad type. Evaluation is call- by-name, and proceeds \nonly to the point where the top-level expression has reduced to a monad unit, forcing all opera-tions \non the store to occur. This corresponds to Haskell, where the top-level expression is a monad over the \ntrivial type, IO 0, and is executed for its side effects rather than the value retured. The operational \nsemantics for Monad are shown in Fig- ure 5. Locations and traces are as before, but a store now maps \nlocations to expressions. Reductions divide into two sorts. Pure reductions do not access the store and \nhave no effect, and are written e +mOn e . Monadic reductions are executed at top-level, may access the \nstore and have an effect, and are written s, e f tnon s, e . Rule (beta) specifies function application; \nthe language Monad is call-by-name as the argument need not be a 68 1 E Ref &#38; Var s E Store = Ref \n--t MonExp (beta) (Xx. e )e --+1n011 e[x/e j recx.e -+ man ret x. e[x/e] (red (W let x = e in e ---hlOII \n4x/e ] (bind) s, let z * <e> in e s, ek/e l  init 1) (new) s, new e ?::, s~{11+e},<Z> freshl@ s r.ad \n1) slU{1*e},get1 2 IllOU sl U {I I-) e}, <e> writ*(l) sl U (1 +i e}, set 1 e -+ *non sl U (1 ++ e }, \n<e > e --+ e e -+ e (w4 11 I I, (pure-step) , (pure-ban) e -t -$-e ee ---+ee e---Se f Ie --+ e s, e \n---hrlolI s , e (Pure) 0 (bindO) s, e ---+II~oll s, e s, let 2 + e in e f nloIl s , let 2 X= e in e \nf e --+ e e + e s, e -+IWII s , e (newU) WO) 0 (set@ 0 , ,I f s, get e +nI~n s, get e s, set e e ---+tnoIl \ns, set e e s, new e ---+olon s , new e f f f s, e ---+1~0t~ s , e s, e --+hIlon s , e s , e --+~IIo,I \ns , e (step) f ( refi) 0 (tran) fUf s, e -hloIl s, e s, e --+Itloll s , e S, e +mon S , d Figure 5: \nSemantics for Monad value for the rule to apply. The rule is pure and makes no reference to the store. \nRules (ret) and (let) are simi-lar. Rule (bind) simplifies a monadic bind to a monadic unit; it leaves \nthe store unchanged and is labeled with an empty effect. (But it is not a pure operation: this prevents \nreduction of ill-typed and nonsensical expressions such as (let 2 -G= <(Xy. y)> in z)z, where the monadic \nexpression is not at top-level.) Rules (new), (get), and (set) perform ac-tions on the store and have \ncorresponding effects. Rule (app0) allows reduction of the function part of an application; eventually \nit will reduce to a lambda and rule (beta) will apply. Since Monad is call-by-name, the argu-ment of \nan application is not reduced. Rule (pure) allows pure reductions at top-level. (This permits reduction \nof sen- sible expressions such as (Xy. let z e <y> in x)z where an application yields a monadic expression \nat top-level.) Rule (bindO) allows reduction of the first part of a monad bind; eventually it will simplify \nto monad unit and rule (bind) will apply. Rules (getO) and (put0) reduce the location argument to an \noperation on the store. Locations are not monads, SO their reductions are pure. Since expressions, not \nvalues, are placed in the store there is no need to reduce the argument of new or the second argument \nof put. Finally, rules specify --tt as the reflexive and transitive closure of red, for both pure and \nmonadic versions. (One may formulate the above in terms of evaluation contexts, but it gets messy. It \nseems to require three sorts of contexts: pure context with pure hole for (appU), monad context with \nmonad hole for (bindO), monad context with pure hole for (pure), (getO), and (seto). Hence our eschewal \nof evaluation contexts.) The relations E t--tnon s and &#38; t-111o1, f ! B are defined, mu-tatus mutandem, \nas for the effect system. Again, reductions preserve types and are consistent with effects. Proposition \n3.5 (Subject reduction) If &#38; Et- man e : T T and s, e f\\Il,on s , e then E: +I &#38; such that E \nkInoI, s and E !-man mon f ! 0. Now an expression e is faulty if it contains sion in one of the following \nforms: e e , where e is a location, let x e e in e , where e is a lambda or get e, where e is a lambda \nor monad set e e , where e is a lambda or monad The other definitions and results carry through tandem. \nProposition 3.6 (Uniform evaluation) If e s and s,e is stuck, then e is faulty. Proposition 3.7 (Well-typed \nexpressions are El-man e : 7, then e is not fadty. Proposition 3.8 (l$pe soundness) If &#38; t kmon e \n: T r then either bon s and there mists a e : TV T and a subexpres- location, unit, unit. mutatus mu- \nis closed over not faulty) If l-n,on s and 0 E Subst = (Ty Var -+ Type) x (Reg Var + Region) x (EffVar \n-+ Effect) U(a,a ) = {ck e a } U(L,L) = id U(cy,~) = if (Y E fv(~) then fail else {a ++ T} U(T,Q) = \nU(cr,r) U(T0 4 71) T:, d T;) = let 0 = {G ~-f s }; e = u(e70,e~&#38; e = u(e BT1, ele7-:) in e e e U(ref \ny 7, ref ++ T ) = let e = (7 ++ 7 ); 8 = u(eT, 0~ ) in e/e U(-,-) = fail Figure 6: Unification K E Constraint \n= p(EflVar x Efiect) p E EfiModel = EffVar-t Effect K(0) = id K({r E u} U fc) = let p = K(K) in {s H \n/Lo \\ s}c1 Figure 7: Constraints l s, e I &#38; f ! 6,and E t-1~1~~~ or l s, e --%e~ s , <e > and &#38; \nkllloll s and &#38; t-111o11 and e : r El-mon f ! u. 3.3 The translation As is well known, the monad \ntranslation preserves seman-tics, a property that continues to hold for our instrumented semantics. A \nkey to the correspondence is that if a term in Eflect is translated to Monad then the resulting term \nhas subterms of the form e e, let x = e in e or <e> only where e is a value. Ifs is a store in Efect, \nwe write st for the corresponding store in Monad, with s+(Z) = (s(l))+ for each 1 E dam(s). Proposition \n3.9 (The translation preserves semantics) If s,e ftte~ s , e then st,e _f,,lnon s +,e *. The proof is \nby induction over reduction sequences. 4 Type reconstruction This section presents type, region, and \neffect reconstruction algorithms for the two languages. The reconstruction algo-rithm for Effect, due \nto Talpin and Jouvelot, closely resem-bles Milner s original type reconstruction algorithm (Mi178]. Effects \nare handled by accumulating a set of constraints, similar to the handling of subtypes in Mitchell s inference \nalgorithm [MitSl]. It is straightforward to transpose the 70 reconstruction algorithm from Effect to \nMonad. Both algo-rithms are sound and complete, and typings yielded by the two algorithms are related \nby the translation between the two languages. 4.1 Unification Substitutions and the unification algorithm \nare shown in Figure 6. A substitution maps type variables to types, re-gion variables to regions, and \neffect variables to effects. We write id for the identity substitution. A central trick in the reconstruction \nalgorithm is to en-sure that all effects and regions are represented by variables, to simplify unification. \nWe call a type or substitution nor-malised if the only regions and effects it contains are vari-ables. \n(One infelicity of Talpin and Jouvelot is that they neglect to mention which types and substitutions \nare nor-malised in the statement of their theorems.) The unification algorithm U(T, 7 ) takes two normalised \ntypes and returns a normalised substitution 0. Proposition 4.1 (Unification) l (Sound) If 8 = U(r, r \n) then 8r = Or (with 8, r, r normal&#38;d). l (Complete) If 9r = 13r1 then there exist 8 and .Q such \nthat 0 = U(T,T ) and 0 = 0 tJ (with T, r , 8 nor-malised). The proof is standard, as normalisation eliminates \nany po-tentially tricky cases. w E Var = QVar + Reg Var + EffVar F E T&#38;heme P ::= VWl,. . . ,Wn. \n(T,K) &#38; E QEnv = Id + TyScheme = = I&#38;(&#38;, ret 5. Xx . e) = Gff (E, e 4 = Z,ff(&#38;, let 2 \n= 2, in e) = Z,fl(&#38;, let x = e in e ) = = Gff (E, =ew e) = Aff 6% get e) I,&#38;&#38;, set e e ) \n= Figure let VWI , . . . ,Wk. (7, K) = &#38;(x) neww:,...,wj, e={wl l+wW;,...,Wn~w;} in (id, &#38;,8, \nOn) let new (Y, s (e,~, 0,~) = Zeff (8, U {x * 4, e) in (e, ea 4 ~,0, KU {c 2 c}) let new Q, Q , c 64 \n7, U, 4 = zeff (E3c,21 U {x t-f a 3 a , 2 +b a}, e) 8 = u(ed, T) in (e/e, e ela 4 CK ), 0, e+ u {eq 7 \n~7))) let (0,7,0, n) = Z&#38;(&#38;,e) (et, T , d, K ) = &#38;(BE, e ) new (Y,C e/f = u(e 7,7 -3 0) in \n(e e e, e/j@, e (e u u U u c), eyeh u K')) let (e, 7,0, K) = Z,ff(E, W) w1,. . . , Wn = fvtT) u TV \\ \nfv(eq (et, T ,u, 14) = zeff (e&#38;, u {X e VW],. . , wn. (7, IE)}, e) in (e e, #, u, K ) let (e,T,u,K) \n= Z&#38;((E,e) (et, Tf, d, d) = Gff (eEz u {Z +t 7}, e) in (e'e,T',6ud,~uti) let (e,T,u,K) = Z&#38;(E,e) \nnew 7 in (0, ref 7 7, u U init.(y), K) let (e,T,u,K) = &#38;(E,e) new Q, y 8 = L/(7, ref y 0) in (e/e, \neb, u u read(O y), ek) let (e, r, u, K) = Z,ff(&#38;, e) (et, +, 61, d) = Z&#38;M, e) new y ef = u(er, \nref 7 T ) in (e\"e'e, e'J+, e\"(e'u u 0' u write(r)), eqeh U K )) 8: Type reconstruction for Effect 4.2 \nConstraints Constraints and the constraint solution algorithm are shown in Figure 7. A set of constraints \nK is a set of inequations of the form c > u, asserting that effect variable c is bounded below by effect \nu. Constraints always have solutions. A substitution ~1 tak- ing effect variables to effects models a \nconstraint set K, writ- ten p + K, if pc > pa for each inequation c > u in IE. (An- other infelicity \nof Talpin and Jouvelot is that they assert the solutions are minimal. The solutions are not minimal in \ngeneral, though they may be minimal over the domain of K. However, minimality is irrelevant to the remainder \nof their results, or to ours.) The constraint solution algorithm K(K) takes a con-straint set and returns \na model /I. It assumes that effect variables on the left hand of constraints in n are distinct, which \ncan be achieved by merging the two constraints c 2 o and s 1 u into the equivalent constraint c > u U \nCT . The notation u \\ s stands for the effect u such that u = u U c and c does not appear in u . The \nresult of the algorithm is independent of the order in which the constraints are visited. Ztnoll(E,x) \n= let VWI,. . . ,wk. (T, K) = E(z) Z,,,,, (E, Xx. e) = 2,,,,,, (E, ret x. e) = Lo,, (E, let x = e in \ne ) = 21r10r1(E, <e>) = ZInon(&#38;,let x -+ e in e ) = L?,,,,,, (E, new e) = Ztlloll(&#38;, set e e \n) = Figure new w;,. . .,w; e={wl+-+ww;,...,wnt-+~;} in (id, er, eK) let new (Y (e, T, K) = 2I11011(&#38;z \nu {x ct N}, e) in (e, ecu + 7, K) let new Q! (e, 7, K) = ZI11011(&#38;2 u {X ++ a}, e) 8' = u(ea, 7-J \n(e's, ejT, efK) (e, 7, K) = &#38;,,,,(E, e) (e', 4, K') = 7Zn,oll(6E,e ) new cr 8 = U(B T, 7 -+ a) \nin (effe e, e/b, e (ek u d)) let (e, 7, K) = Z1lO1l(E, e) WI,. . . ,Wn = fv(T) u fv(K) \\ fv(6E) (e ,~ \n,~ )=Z,,,,,l(eE~u{z~V~l ,..., w~.(T,K)},~ ) in (e/e, +, 14) let (8, T, K) = Ztlloll(&#38;, e) new F in \n(6,TF~,~U{s J 0)) let (B,T, K) = Lx(E, e) new a, q 8 = U(T, TC (Y) (e ,~ , IF ) = Z,,,,,(E u {X i-+ ek+ \ne ) new cy , c 6 = U(T , TF a ) new c in (e e #e, TC e d, e (e e K. U d U {c g @ O S U F })) let (e, \n7, K) = Z,,O,,(E, e) new 7,F in (6, TF ref, 7, IC U {s 7 init(r (6, T, K) = L,,,(E, e) new CX,~ 8 = U(T, \nref 7 12) new c in (e/e, TC B cY, efK u {S 2 read(e y)}) let (6, T, 6, K) = Zrlon (E, e) (e , T , u \n, K ) = Loll (BE, e) new y e = .U(~T, ref I r ) new G in (effe'e, TC (VT'), tl\"(e'~ u K') u {S 7 write(Py)}) \n9: Type reconstruction for Monad 4.3 Reconstruction for Effect Type schemes and the reconstruction algorithm \nfor Effect are shown in Figure 8. Type schemes are introduced to rep- resent all possible types associated \nwith a polymorphically bound variable, thus avoiding the computationally infeasible use of substitution \nsuggested by a naive reading of the type rule for let. A type scheme has the form Vwl, . . , , wn. (T, \nK) where each w is a type, region, or effect variable; the scheme is normalised if 7 is normalised. Such \na scheme represents all types of the form 6% where 8 + K and the domain of tI is contained in WI,. . \n. , wn. Type environments are now taken to map identifiers to type schemes; the environment is normalised \nif all types in it are normalised. The reconstruction algorithm Z,tf(&#38;, e) takes a nor-malised type \nenvironment &#38; and an expression e, and re-turns a quadruple (6, r, u, IE), with 6 and r normalised. \nIt fails if some unification within it fails. The substitution 6 is idempotent, and T, u, and IE are \ninvariant under 8. As shown by Talpin and Jouvelot, the reconstruction al-gorithm is sound and complete. \nProposition 4.2 (Qpe reconstruction, Talpin and Jou-velot) l (Sound) Zf Z,R(&#38;, e) = (6,T,u, K) and \n/I ,k K then @&#38; keff e : ~7 ! w, with E, 6, and r normalised. l (Complete) If BE l-eff e : r ! u \nthen Z,ff(&#38;,e) = (B ,r ,u ,k) and there exists a substitution 6 such that BE = f3 B E and r = 6 r \nand u > 0 u and e k 4 with E, 8 and 7 normalised. The proof for the first part by induction on the structure \nof expressions, and for the second by induction on the structure of type derivations. (A fmal infelicity \nof Talpin and Jouvelot is that they skip the case of polymorphic let binding, as-suming such bindings \nhave been expanded out. Fortunately, it is easy to give a proof for these cases, along the lines of the \nstandard proof in Mitchell s text [MitSG] or a later proof of Talpin and Jouvelot [TJ94]. Alternatively, \nit is easy to prove a lemma showing that Z,tf(&#38;, let 2 = e in e ) and Z,B(&#38;, e [e/z]) yield the \nsame results, justifying the ex-pansion.) 4.4 Reconstruction for Monad The reconstruction algorithm \nfor Monad is shown in Fig-ure 8. The unification algorithm, type schemes, and type environments are as \nbefore, with types for Monad replacing types for Effect, mutatus mutandem. Constraints carry over without \nchange. The reconstruction algorithm Znloll(&#38;,e) takes a type environment &#38; and an expression \ne, and returns a triple (6, T, K), or fails if some unification within it fails. The recon-struction \nalgorithm is easily transposed to the new setting. It has much the same structure before, the largest \ndifference being that effects are mentioned only in monad types, and effects in types are always represented \nby variables, so a few extra constraints are required. It is also easy to transpose the results regarding \nthe al-gorithm. Proposition 4.3 (Type reconstruction) l (Sound) If Znlotl(&#38;,e) = (0, r, K) and p \nk K. then pe&#38; hloll e : pr, with E, 6, and r normalised. l (Complete) If t!9&#38; kmoII e : T then \nI&#38;,,,(&#38;, e) = (O , r , K ) and there exists a substitution 0 such that BE = 6 0 &#38; and 7 = \n6 r and 0 + IE , with E, B , and 7 normalised.  4.5 Translation The two reconstruction algorithms yield \nresults that are re- lated by the translation. Write K, N IC if for all p we have p+~ifandonlyifpk~c \n. Proposition 4.4 (Tbanslation preserves type reconstruc-tion) Zf Z&#38;E, e) = (0, 7, u, K) and ZIllorl(Et, \ne*) = (6 , #, lo ) then there exist c and /I such that T rt = r and 6 = 1-16 andu=pq andtcz&#38;. The \nproof is by induction on the structure of expressions. 5 Conclusions We have verified the conjecture, \nfirst broached half a decade past, that effect systems can be adapted to monads. We have demonstrated \nthis for the specific case of the type, re-gion, and effect system of Talpin and Jouvelot, but it seems \nclear that any effect system can be adapted to monads in a similar way. Here are points for future work. \n Denotational semantics It is straightforward to provide semantics for effects and monads in a denotational \nstyle. In this semantics, the instrumentation can be factored out as a separate monad transformer. The \nfactoring uses the well known result that if TX is a monad, then so is TA X = TX x A, where A is a monoid. \nIn this case, A is taken to be the monoid of traces, with identity 0 and operator U. Coherent semantics \nAn alternative approach to denota- tional semantics might be to eliminate the instrumentation, and associate \nwith each effect u a different monad T . For state, one traditionally defines TX = S + X x S where the \nstore S is a mapping from locations to values. Here one would define T r = S, -+ X x S where S, is a \nstore restricted to contain only locations in regions p such that read(p) is in u, and 5 is a store \nrestricted to contain only locations in regions p such that init or write(p) is in u. Corresponding to \neach effect inclusion u c u there should be a monad morphism T -+ T . In order to ensure CO-herence in \nthe style of Breazau-Tannen et al. [BCGSSl], we should expect transitivity of inclusions to correspond \nto composition of the corresponding morphisms. A general theory of effects and monads As hypothe- sised \nby Moggi and as born out by practice, most computa-tional effects can be viewed as a monad. Does this \nprovide the possibility to formulate a general theory of effects and monads, avoiding the need to create \na new effect system for each new effect? Acknowledgements I thank Mads Tofte, Jon Riecke, Matthias Felleisen, \nand J.-P. Talpin for comments on earlier drafts of this paper. References [BKR98] N. Benton, A. Kennedy, \nand G. Russell, Compil-ing Standard ML to Java Bytecodes, ACM 3 rd Znter-national Conference on Functional \nProgramming, Bal-timore, September 1998. [BCGSSl] V. Breazu-Tannen, T. Coquand, C. A. Gunter, and A. \nScedrov, Inheritance as explicit coercion, Information and Computation, 93(1):172-221, 1991. Reprinted \nin C. A. Gunter and J. C. Mitchell, ed-itors, Theoretical aspects of object-oriented program-ming, MIT \nPress, 1994. [GL86] D. K. Gifford and J. M. Lucassen, Integrating func-tional and imperative programming, \nACM Confer-ence on Lisp and Functional Programming, Cambridge, Massachusetts, August 1986. [GJLS87] D. \nK. Gifford, P. Jouvelot, J. M. Lucassen, and M. A. Sheldon, FX-87 Reference Manual, Technical report \nMIT/LCS/TR-407, MIT Laboratory for Computer Sci-ence, September 1987. [GJSSG] James Gosling, Bill Joy, \nand Guy Steele, The Java [TJ92] J.-P. Talpin and P. Jouvelot, Polymorphic type, re- Language Specification, \nJava Series, Sun Microsystems, gion, and effect inference, Journal of F unctional Pro- 1996. gramming, \n2(3):245-271, July 1992. [HDSI] J. Hatcliff and 0. Danvy, A generic account of continuation-passing \nstyles, ACM Symposium on Prin- ciples of Programming Languages, Portland, Oregon, January 1994. [JG89] \nP. Jouvelot and D. K. Gifford, Reasoning about continuations with control effects, Technical report MIT/LCS/TM-378, \nMIT Laboratory for Computer Science, January 1989. [Jon951 M. P. Jones, Functional programming with over-loading \nand higher-order polymorphism, in J. Jeuring and E. Meijer, editors, Advanced finctional Program-ming, \nLNCS 925, Springer Verlag, 1995. [LP94] J. Launchbury and S. L. Peyton Jones, Lazy func-tional state \nthreads, ACM Conference on Program-ming Language Design and Implementation, Orlando, Florida, 1994. [Luc87] \nJ. M. Lucassen, Types and effects, towards the in- tegration of functional and imperative programming, \nPh.D. Thesis, Technical report MIT/LCS/TR-408, MIT Laboratory for Computer Science, August 1987. [Mi178] \nR. Milner, A theory for type polymorphism in pro- gramming, Journal of Computer and Systems Science, \n17~348-375, 1978. [MitSl] J. C. Mitchell, Type inference with simple sub- types, Journal of Functional \nProgramming, 1(3):245- 286, 1991. [Mit96] J. C. Mitchell, Foundations for programming lan-guages, MIT \nPress, 1996. [MTHSO] R. Milner, M. Tofte, and R. Harper, The Defini- tion of Standard ML, MIT Press, \n1990. [MTHM97] R. Milner, M. Tofte, R. Harper, and D. Mac-Queen, The Definition of Standard ML (Revised), \nMIT Press, 1997. [Mog89] E. Moggi, Computational lambda calculus and monads, IEEE Symposium on Logic \nin Computer Sci-ence, Asilomar, California, June 1989. [MogSl] E. Moggi, Notions of computation and monads, \nIn-formation and Computation, 93(l), 1991. [PH97] J. Peterson and K. Hammond, editors, Haskell 1.4, a \nnon-strict, purely functional language, Technical re-port, Yale University, April 1997. [Plo75] G. Plotkin, \nCall-by-name, call-by-value, and the X-calculus, Theoretical Computer Science, 1:125-159, 1975. [PW93] \nS. L. Peyton Jones and P. Wadler, Imperative func-tional programming, ACM Symposium on Principles of \nProgramming Languages, Charleston, South Carolina, January 1993. [SW971 A reflection on call-by-value. \nAmr Sabry and Philip Wadler. ACM iPransactions on Programming Lan-guages and Systems, 19(6):916-941, \nNovember 1997. (An earlier version appeared in 1 st ACM International Conference on Functional Programming, \nPhiladelphia, [TJ94] J.-P. Talpin and P. Jouvelot, The type and effect discipline, Information and Computation, \n111(2):245-296, 1994. [Tot?371 M. Tofte, Operational semantics and polymorphic type inference, PhD Thesis, \nUniversity of Edinburgh, 1987. [TB98] M. Tofte and L. Birkedal, A region inference algo-rithm, Transactions \non Programming Languages and Systems, November 1998 (to appear). [To1981 A. Tolmach, Optimizing ML using \na hierarchy of monadic yypes WorF;ghop on Types in Compilation, Kyoto, March 1998. [WadSO] P. Wadler, \nComprehending monads. ACM Con-ference on Lisp and Functional Programming, Nice, France, June 1990. [Wad921 \nP. Wadler, The essence of functional programming (Invited talk), ACM Symposium on Principles of Pro- \ngramming Languages, Albuquerque, New Mexico, Jan-uary 1992. [Wad931 P. Wadler, Monads for functional \nprogramming, in M. Broy, editor, Program Design Calculi, NATO AS1 Series, Springer Verlag, 1993. Also \nin J. Jeuring and E. Meijer, editors, Advanced Functional Programming, LNCS 925, Springer Verlag, 1995. \n [Wad951 P. Wadler, How to declare an imperative (Invited talk), International Logic Programming Symposium, \nPortland, Oregon, MIT Press, December 1995. [WF94] A. Wright and M. Felleisen, A syntactic approach to \ntype soundness, Information and Computation, 115(1):38-94, November 1994. (Wri92] A. Wright, Typing references \nby effect inference, 4th European Symposium on Programming, Rennes, France, February 1992, Springer-Verlang \nLNCS 582. [Wri95] A. Wright, Simple imperative polymorphism, Lisp and Symbolic Computation, 8:343-355, \n1995. May 1996.)   \n\t\t\t", "proc_id": "289423", "abstract": "Gifford and others proposed an <i>effect</i> typing discipline to delimit the scope of computational effects within a program, while Moggi and others proposed <i>monads</i> for much the same purpose. Here we marry effects to monads, uniting two previously separate lines of research. In particular, we show that the type, region, and effect system of Talpin and Jouvelot carries over directly to an analogous system for monads, including a type and effect reconstruction algorithm. The same technique should allow one to transpose any effect systems into a corresponding monad system.", "authors": [{"name": "Philip Wadler", "author_profile_id": "81100173596", "affiliation": "Bell Laboratories, Lucent Technologies", "person_id": "PP39030941", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/289423.289429", "year": "1998", "article_id": "289429", "conference": "ICFP", "title": "The marriage of effects and monads", "url": "http://dl.acm.org/citation.cfm?id=289429"}