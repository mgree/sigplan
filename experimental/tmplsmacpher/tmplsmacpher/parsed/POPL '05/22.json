{"article_publication_date": "01-12-2005", "fulltext": "\n Context Logic and Tree Update* Cristiano Calcagno Philippa Gardner Uri Zarfaty Department of Computing \nImperial College University of London ABSTRACT Spatial logics have been used to describe properties \nof tree\u00adlike structures (Ambient Logic) and in a Hoare style to rea\u00adson about dynamic updates of heap-like \nstructures (Separa\u00adtion Logic). We integrate this work by analyzing dynamic updates to tree-like structures \nwith pointers (such as XML with identi.ers and idrefs). Na\u00a8ive adaptations of the Am\u00adbient Logic are \nnot expressive enough to capture such local updates. Instead we must explicitly reason about arbitrary \ntree contexts in order to capture updates throughout the tree. We introduce Context Logic, study its \nproof theory and models, and show how it generalizes Separation Logic and its general theory BI. We use \nit to reason locally about a small imperative programming language for updating trees, using a Hoare \nlogic in the style of O Hearn, Reynolds and Yang, and show that weakest preconditions are derivable. \nWe demonstrate the robustness of our approach by using Context Logic to capture the locality of term \nrewrite sys\u00adtems.  Categories and Subject Descriptors D.2.4 [Software/Program veri.cation]: Correctness \nproofs, Formal methods, Validation; F.3.1 [Specifying and Veri\u00adfying and Reasoning about Programs]: Logics \nof pro\u00adgrams General Terms Languages, theory, veri.cation  Keywords tree update, Hoare Logic, contexts \n 1. INTRODUCTION We study Hoare logics for reasoning about data update. Hoare logics have been well-explored \nfor heap update, from * A preliminary version of this work appeared in an informal proceedings [3]. Permission \nto make digital or hard copies of all or part of this work for personal or classroom use is granted without \nfee provided that copies are not made or distributed for pro.t or commercial advantage and that copies \nbear this notice and the full citation on the .rst page. To copy otherwise, to republish, to post on \nservers or to redistribute to lists, requires prior speci.c permission and/or a fee. POPL 05, January \n12 14, 2005, Long Beach, California, USA. Copyright 2005 ACM 1-58113-830-X/05/0001 ...$5.00. the original \nwork of Hoare based on .rst-order logic to the recent work of O Hearn, Reynolds and Yang [9, 12, 6], \nwith their emphasis on local reasoning using the Separation Logic. Such Hoare reasoning has hardly been \nexplored for other data structures. We show that the techniques for reasoning locally about heap update \ncan be adapted to reason locally about tree update (XML update). This adaptation was by no means straightforward. \nSurprisingly, the Ambient Logic for trees cannot be used as the basis for the Hoare triples, since the \nweakest preconditions are not expressible. Instead, we had to fundamentally change the way we reason \nabout structured data, using Context Logic to analyse both data and contexts. Data update typically identi.es \nthe portion of data to be replaced, removes it, and inserts the new data in the same place. This place \nof insertion is essential for reasoning about updates. Context Logic has context application data in\u00adsertion \nin a context as its central construct, plus (adjunct) connectives for reasoning hypothetically about \ndata inser\u00adtion. This shift of perspective emerged from our study of tree update, in particular realising \nthat the Ambient Logic could not directly describe tree insertion. Given the con\u00adceptual nature of our \ncontext reasoning, we expect the same approach to apply to a wide range of structured data. In this paper, \nwe provide a Hoare logic for reasoning lo\u00adcally about a simple imperative language for tree update, using \nour Context Logic specialised to trees. We prove that the weakest preconditions are derivable. We study \nthe gen\u00aderal theory of Context Logics, providing a Hilbert-style proof theory, forcing semantics and \nmodels. The Bunched Logic (BI) of O Hearn and Pym gives the general theory of Separa\u00adtion Logic. We show \nthat BI can be obtained from Context Logic by collapsing some of the structure. We prove sound\u00adness of \nour proof theory with respect to the forcing seman\u00adtics. Calcagno and Yang have recently proved completeness, \nby adapting Yang s results for BI [11]. We also adapt our Hoare logic reasoning about trees to heap update \nand term rewriting. Our reasoning about heap update corresponds precisely to O Hearn et al. s reasoning \nusing Separation Logic, as one would expect since heap contexts are simple. Our reasoning about term \nrewriting demonstrates the robustness of our approach1 . Although terms in rewrite systems can be seen \nas special cases of trees, there is a crucial di.erence: terms over a signature do not decompose as a \ncomposition of subterms, due to the .xed arity of function symbols. They do however decompose 1Many thanks \nto Peter O Hearn for suggesting this open problem. nicely as context/subtree pairs. This example demonstrates \nthe fundamental importance of contexts for reasoning locally about structured data. Heap Update O Hearn \nand Reynolds have introduced a style of Hoare logic for imperative programs consisting of small local \naxioms, which specify properties about the portion of the heap ac\u00adcessed by a command, and a frame rule, \nwhich uniformally extends the reasoning to properties about the rest of the heap. The impact of their \napproach is that the resulting Hoare logic is very simple, and has been applied to several problems such \nas pointer arithmetic, concurrent impera\u00adtive programs and passivity which escaped reasoning in the traditional \nHoare-logic style. Their primary innovation was to base their Hoare logic on the Separation Logic, consisting \nof standard .rst-order connectives and additional formulae for directly analysing the heap structure. \nIn particular, two key logical constructs are the separating conjunction * for describing disjoint properties \nabout the heap and used to formulate the frame rule, and its adjoint -* for analysing extensions of the \nheap and used to express the weakest pre\u00adconditions. Consider the heap update command [n]= v, which up\u00addates \naddress nin the heap with value v. The corresponding small axiom for this command is {n..-}[n]= v{n..v} \nThe precondition states that the heap consists of one cell with address nand an unspeci.ed value, and \nthe postcondi\u00adtion states that the cell now has value v. This small axiom only describes properties about \nthe speci.c cell n.To ex\u00adtend to properties about a larger heap, we use the frame rule to derive the \ntriple {P *(n.]= v{P *(n.v)} .-)}[n. The assertion P*(n. .-) states that the heap can be split disjointedly \ninto the cell n with an arbitrary value (the or\u00addering of cells does not matter), and the rest of the \nheap with property P which is una.ected by the update com\u00admand. The postcondition therefore has the same \nstructure, with the now updated cell n and the rest of the heap satis\u00adfying P. The small axioms and frame \nrule are elegant, and intu\u00aditively express the behaviour of commands. In addition, the weakest preconditions \nare derivable, a natural requirement which is essential for providing veri.cation tools. The weak\u00adest \npreconditions use assertions of the form R-* Q,which states that whenever a heap is extended by a heap \nsatisfy\u00ading R then the resulting heap satis.es Q. For example, the formula (n.*Q states that, whenever \nthe heap is ex\u00ad .v) -tended by a cell with address n and value v, then property Q must hold. This formula \nis used to de.ne the weakest precondition of our update command: {((n.*Q) *(n.-)}[n]= v{Q} .v) -. The \nprecondition states that the heap can be split into the cell nwith unspeci.ed value and the rest of the \nheap which, when extended by a cell n with speci.c value v,satis.es property Q. Tree Update We apply \nthis style of Hoare logic reasoning about heap update to tree update. It is possible to describe analogous \nsmall axioms and frame rule using (an adaptation of) the Ambient Logic. In order to derive the weakest \npreconditions however, we must work with Context Logic, as we illustrate in Section 5. Consider the following \npicture of a tree, the corresponding XML format and the syntactic description we use in this paper: \nXML format: <a ID=m> <b ID=n1 IDREF=n2> T1 </b> <b ID=n2> T2 </b> </a> am:\u00d8[bn1:@n2[T1] |bn2:\u00d8[T2]] \n The structure highlights the unique node addresses (XML identi.ers) and the arbitrary cross-links (pointers, \nXML idrefs), and is similar to the trees studied in [1] except that we per\u00admit dangling pointers. In \n[4], Gardner et al. use the Ambient Logic to specify static properties of such trees: the verti\u00adcal path \nstructure (path expressions), the horizontal struc\u00adture (XML schema) and properties about pointers (types \nfor XML idrefs). Here we reason about tree update. Consider an update command for trees [n]= T,which \nreplaces the subtree at address nwith the tree T.The small axiom for this command is {an:v[true]}[n]= \nT {an:v[T]} The precondition states that the tree consists of a top node identi.ed by address nwith \nvalue v and an unspeci.ed sub\u00adtree. The postcondition says that the subtree has been re\u00adplaced by T. \nIn order to extend the small axiom to triples stating properties about larger trees, we use a generalised \nframe rule based on context application to derive the triple {K(an:v[true])}[n]= T {K(an:v[T])} The \nprecondition states that the tree can be split disjoint\u00adedly into a tree with top node an:v, and a context \nsatisfying context formula K which is una.ected by the update com\u00admand. The postcondition therefore has \nthe same structure, with the subtree at address n updated. To specify the weakest precondition, we use \na context adjunct PQ which describes a property about contexts: whenever a tree satisfying P is placed \nin the context hole, then the resulting tree satis.es Q. For example, the adjoint an:v[T]Qstates that, \nwhenever a tree with address n,value vand subtree T is placed in the context hole, then the prop\u00aderty \nQ must hold. The weakest precondition of our update command is: {(an:v[T] Q)(an:v[true])}[n]= T {Q} \nThe precondition says that the tree can be split into a sub\u00adtree with top node an:v, and a context which \nsatis.es Q when tree an:v[T] is put in the hole. Again, this triple is derivable. In contrast, we believe \nthat it is not possible to express such weakest preconditions using (a minor adaptation of) the Ambient \nLogic to the trees-with-pointers model. We can prove that the Ambient Logic cannot express the weakest \npreconditions without some form of recursion. The some\u00adwhere modality does provide a limited form of \ncontext rea\u00adsoning, but in Section 5 we illustrate that this reasoning is not enough to describe the \nparametric weakest precondi\u00adtions. It remains future work to pin down this inexpressivity result.  2. \nTREE DATA MODEL We present a data model for semi-structured data (XML) based on Cardelli, Gardner and \nGhelli s trees-with-pointers model [4] (see also [2]). Our formalism integrates the sim\u00adple tree structure \nof Cardelli and Gordon s ambient calcu\u00adlus [5] with the pointer structure of heaps. In particular, it \npermits dangling pointers, which are essential for local reasoning about such linked structures. Trees \nwith Pointers Our trees-with-pointers model consists of a labelled tree structure with uniquely identi.ed \nnodes, unstructured data (values, text) and graphical links (pointers) between nodes. Node identi.ers \nallow us to update trees locally, while point\u00aders allow us to model arbitrary graph structures. We also \nde.ne linear contexts, which are trees with a unique hole2 . Given in.nite sets of names n .N and labels \na .A,the sets of values, trees and contexts are de.ned in Figure 1. The insertion of a tree T in a context \nC, denoted C(T), is de.ned in the standard way. A well-formed tree or context is one where the node identi.ers \nare unique. Note that com\u00adposition, node formation and tree insertion are partial when restricted to \nwell-formed trees. The structural congruence =between trees is the small\u00adest congruence on trees which \nsatis.es axioms (i)-(iii) in Figure 1. This corresponds to tree isomorphism under a multiset interpretation. \nWe trivially extend this to a struc\u00adtural congruence on contexts using axioms (iv)-(vi). Note that the \nresult is also a congruence with respect to tree in\u00adsertion: that is, C1(T1) =C2(T2) whenever C1 =C2 \nand T1 =T2. The de.nitions of well-formed trees and contexts are consistent with respect to structural \ncongruence.  3. TREE UPDATE LANGUAGE We present a core update language for directly manipu\u00adlating trees \nwith pointers. The language is simple, yet ex\u00adpressive enough to illustrate the subtleties of tree update. \nThe atomic commands are similar to the basic operations for XML update studied in [10]. Our core language \nserves as a starting point for a full update language for XML. Variables and Expressions Our data storage \nmodel resembles that of traditional imper\u00adative languages, except that trees are .rst-class objects. \nIt consists of two components: a working tree T (analogous to a heap) and a store s. The latter is a \n.nite partial func\u00adtion de.ned on both tree variables , which are mapped to 2We believe it is routine \nto adapt the results presented in this paper to multi-holed contexts. We limit ourselves to linear contexts, \nsince these are enough to derive our weakest preconditions. trees, and value variables , which are mapped \nto values (see Figure 2). This approach allows us to break down complex operations, such as moving and \ncopying trees, into smaller ones that deal with only one area of the working tree at a time and can hence \nbe analysed locally. We employ two types of expressions in our update lan\u00adguage: tree expressions and \nvalue expressions. Tree expres\u00adsions are just tree variables, since these are enough to present our ideas. \nIn fact, our results hold for more complex tree ex\u00adpressions, such as those for describing path-based \nreasoning. Value expressions consist of value variables or constants. Both forms of expressions are determined \nby valuations [ E]]s on the store s, as shown in Figure 2. Commands The core system consists of a simple \nimperative program\u00adming language for altering state, with assignment, lookup, update, new and disposal \ncommands: tree operations value operations x= ET u = EV assignment x=[EV ]T u =[EV ]V lookupC ::= [EV \n]T += FT [EV ]V = FV update u=new a at EV new dispose EV dispose These commands are split into tree \noperations and value operations. Assignment, lookup and update have closely re\u00adlated tree and value forms. \nAssignment assigns to a variable x or u the value of an expression ET or EV ; lookup assigns to x or \nu the tree or value at the location speci.ed (as a pointer) by the value of EV ; and update goes to the \nloca\u00adtion speci.ed by EV and either appends to the subtree there the value of FT ,or replaces the value \nthere by the value of FV . We chose to append in the case of tree updates as it is a natural operation \non trees which, together with appropriate disposal, can express tree replacement. The new command creates \na new tree node, with label a,a fresh identi.er, the nil value and an empty subtree, appends the node \nto the subtree at the location speci.ed by EV ,and assigns to u a pointer back to the newly created identi.er. \nThe dispose command deletes the tree speci.ed by EV . The complete operational semantics of the commands \nis given in Figure 3, and is similar to the operational seman\u00adtics for updating heaps given in [12]. \nIt uses an evaluation relation . de.ned on con.guration triples C,s,t,terminal states s,t, and faults. \nNote that the speci.cation of the se\u00admanticsrequirescontexts C to isolate the subtrees a.ected by the \ncommands. The diagram below illustrates the be\u00adhaviour of some of the commands on a simple tree of the \nform an:v[T], with arrows pointing to the results: '  dispose @ n [@ n]= v V value update disposal \n ' += T[@ n] Tupdate u =@ m ee tr u = ne w b neat w @ n values V ::= nil null value @n apointer data \ndata  trees T ::= 0 empty tree an:V [T] node: label a,name n,value V T | T composition of trees contexts \nC ::= - empty context an:V [C] node: label a,name n,value V C| T right-composition with tree T | C left-composition \nwith tree Figure 1: Data Model Structural congruence (i) T1 | T2 = T2 | T1 (ii) T | 0 = T (iii) T1 | \n(T2 | T3) = (T1 | T2) | T3 (iv) C| T = T | C (v) C| 0 = C (vi) C| (T1 | T2) = (C| T1) | T2  tree \nvariables VarT = {x,y,...} tree expressions ET ::= VarT value variables VarV = {u,v,...} value expressions \nEV ::= VarV | V [[u]]s = s(u)stores s. (VarT .n T) \u00d7 (VarV .n V) valuations [ E]]s :[[x]]s = s(x) [[V]]s \n= V Figure 2: Variables and Expressions The lookup, update and dispose commands rely on the ex\u00adpression \nEV evaluating to a pointer which identi.es a node in the working tree3 . If it does not, they will fault. \nA dif\u00adferent error occurs when the tree update operation tries to insert a tree with a node identi.er \nthat clashes with one al\u00adready in the working tree. In this case, the rule diverges, returning no result. \nThis choice to diverge rather than fault is necessary in order to keep the command local (see Sec\u00adtion \n5). In fact, our current choice of update is somewhat unnatural, precisely because of its dependence \non the global state of the tree. A more realistic update operation is to rename the node identi.ers of \nthe tree being inserted with fresh identi.ers. Our simpler operation is enough for this paper. Example \nProgram We present a simple program delink that takes a pointer from a given location, and collapses \nit by moving its target to that location: delink(EV ) . u=[EV ]V ; x=[u]T ; dispose u; [EV ]T += x; [EV \n]V =nil 3Well-formedness of the working tree ensures that the pointer target is always unique. The diagram \nbelow illustrates the behaviour of the program on the sampletreegiven in theintroduction:  Note that \nthe program would also yield a result if the pointer referred to a subtree inside T1, but would clearly \nfault if the pointer referred back to the top node. In Section 5, we show how our program reasoning copes \nquite naturally with these di.erent cases. 4. CONTEXT LOGIC In [4], Gardner et al. amalgamated ideas \nfrom the Ambi\u00adent Logic and Separation Logic to provide a logic for analysing the trees-with-pointers \nmodel. In Section 5, we show that this logic is not expressive enough to describe the weakest preconditions \nfor our update language. This observation led to Context Logic. Beginning with a concrete application, \nwe .rst introduce the Context Logic specialised to analyse our trees. We then study the general theory \nof Context Logic, providing the proof theory, models and completeness results. We also show how to collapse \nits structure to ob\u00adtain the Bunched Logic of O Hearn and Pym as a special instance. In Section 5, we \nshow that the Context Logic for the trees-with-pointers model is indeed expressive enough to describe \nweakest preconditions. [[ET ]]s =T' [[EV ]]s = V x= ET ,s,T . [s|x.T'],T u= EV ,s,T . [s|u .V],t [[EV \n]]s =@nT =C(an:V [T']) [[EV ]]s =@nT =C(an:V [T']) x=[EV ]T ,s,T . [s|x.an:V [T']],T u =[EV ]V ,s,T . \n[s|u .V],T [[EV ]]s =@nT =C(an:V [T']) [ FT ]]s =T'' C(an:V [T' |T'']) well-formed [EV ]T += FT ,s,T \n. s,C(an:V [T' |T'']) [[EV ]]s =@nT =C(an:V [T']) [ FV ]]s = V' [[EV ]]s =@mT =C(bm:V [T']) n/.Free Names(T) \n[EV ]V = FV ,s,T . s,C(an:V [T']) u =new a at EV ,s,T . [s|u .@n],C(bm:V [T' |an:nil[0]]) [[EV ]]s=@nT \n=C(an:V [T']) [[EV ]]s n:V [T'])) =@n.T=C(a 9 dispose EV ,s,T . s,C(0) x=[EV ]T u =[EV ]V = [EV ]T += \nFT [EV ]V = FV ,s,T . fault ; u=new a at EV dispose EV C1,s,T . C1',s',T' C1,s,T . s',T' C1,s,T . fault \n(C1; C2),s,T . (C1' ; C2),s',T' (C1; C2),s,T . C2,s',T' (C1; C2),s,T . fault [s|x.v] means the partial \nfunction s overwritten with s(x)= v Figure 3: Operational Semantics 4.1 A Context Logic for Trees The \nContext Logic for analysing trees with pointers con\u00adsists of tree assertions denoted by P, and context \nassertions denoted by K. In each case, these include standard asser\u00adtions from classical .rst-order logic, \nnovel structural asser\u00adtions for analysing the tree and context structure, and spe\u00adcialised assertions \nassociated with our tree model: basic tree and context assertions, and quanti.cation over the variables \nof our update language: P ::= K(P) |K . P structural assertions 0 |ET |EV = EV basic assertions P .P \n|false classical assertions .x.P |.u.P |.a.P |.n.P quanti.ers K ::= P . P structural assertions -|an:EV \n[K] | P |K basic assertions K .K |False classical assertions .x.K |.u.K |.a.K |.n.K quanti.ers The full \nsemantics is given in Figure 4 by two satisfaction relations: the judgement s,T FT P says that the tree \nas\u00adsertion P holds for a given store and tree, while judgement s,C FK K states that the context assertion \nK holds for a given store and context. The key assertions are the structural assertions K(P), K. P and \nP . Q.The application assertion K(P)speci.es that a tree can be split into a context satisfying K applied \nto a subtree satisfying P. The other two assertions are both (right) adjoints of application. The assertion \nK . P is ad\u00adjoint to K(-). It is satis.ed by a given tree if, whenever we insert the tree into a context \nsatisfying K, then the result satis.es P. We shall see that this adjoint is analogous to the magic wand \nof Separation Logic, and the composition and branch adjoints of the Ambient Logic. Meanwhile P . Q is \nadjoint to -(P) and is therefore a statement on contexts.It is satis.ed by a given context if, whenever \nwe insert in the context a tree satisfying P, then the result satis.es Q.Note that this assertion has \nno analogue in a na\u00a8ive adaptation of the Ambient Logic, and provides much of the power of our context \napproach. It does however correspond to the magic wand of Separation Logic, as the context structure \ncollapses in the heap case. It is used throughout the pa\u00adper and is essential for expressing weakest \npreconditions for update commands. The basic tree assertions are speci.c to our tree appli\u00adcation. They \nconsist of the empty tree 0, the assertion ET which holds whenever the working tree has the same value \nas ET (up to structural congruence), and the asser\u00adtion EV = FV which holds when the values of the expressions \nare equal. The basic context assertions consist of the empty context - and two basic context connectives: \nthe subtree context an:EV [K], satis.ed by the context an:[[EV ]]s[C]for some C satisfying K,and the \nparallel context P |K,satis.ed by a tree satisfying P in parallel with a context satisfying K. For ease \nof reading, we often write P |Q and an:v[P]in\u00adstead of (P |-)(Q)and (an:v[-])(P). This causes no ambi\u00adguity. \nAuxiliary De.nitions We use the standard derived classical connectives and quan\u00adti.ers for both trees \nand contexts: \u00acP,true, P .P, P .P and . .P,where is x, u, a or n. (For contexts we write True rather \nthan true.) We also use the derived tree equality ET = FT , which is satis.ed whenever the two tree expres\u00adsions \nhave the same value: ET = FT . true |((ET . FT )(0) .0) s, T FT K(P )i. .C, T ' s.t. T =C(T ' ), s, C \nFK K and s, T ' FT P s, T FT K . P i. .C1(s, C1 FK K and C1(T ) well-formed .s, C1(T ) FT P ) s, T FT \n0i. T =0 s, T FT ET i. T =[[ET ]]s s, T FT EV = FV i. [ EV ]]s =[[FV ]]s s, T FT P .Q i. s, T FT P implies \ns, T FT Q s, T FT false never s, T FT .x.P i. .T ' s, T FT .u.P i. .V s, T FT .a.P i. .a ' s, T FT .n.P \ni. .n ' s.t. [s|x ..T ' ],T FT P s.t. [s|u ..V ],T FT P .As.t. s, T FT P [a ' /a] .N s.t. s, T FT P [n \n' /n] s, C FK P . Q i. .T1(s, T1 FT P and C(T1) well-formed .s, C(T1) FT Q) s, C FK -i. C =- s, C FK \nan:EV [K]i. .C ' s.t. C =an:[[EV ]]s[C ' ] and s, C ' FK K s, C FK P |K i. .T,C ' s.t. C =T |C ' , s, \nT FT P and s, C ' FK K s, C FK K1 .K2 i. s, C FK K1 implies s, C FK K2 s, C FK False never s, C FK .x.K \ni. .T s.t. [s|x ..T ],C FK K s, C FK .u.K i. .V s.t. [s|u ..V ],C FK K s, C FK .a.K i. .a ' .As.t. s, \nC FK K[a ' /a] s, C FK .n.K i. .n ' .N s.t. s, C FK K[n ' /n] Figure 4: Semantics of Formulas A useful \nproperty of equality assertions for values and trees is their context-insensitivity: K((ET = FT ) .Q) \n. (ET = FT ) .K(Q) K((EV = FV ) .Q) . (EV = FV ) .K(Q) We say that an assertion is exact if it is satis.ed \nby at most one tree or context for any given store. The following useful property is reversible whenever \nP is exact. always ----. (P . Q)(P ) Q .True(P ) .----- exact P  4.2 General Theory of Context Logic \nIn this section, we develop the underlying general theory of Context Logic, giving the proof theory, \nthe models and the forcing semantics. We give soundness and completeness results. Finally, we compare \nour Context Logic with the Bunched Logic of O Hearn and Pym. For the purpose of this paper, we deal only \nwith boolean Context Logics, where the law of excluded middle holds. Definition 1 (Context Logic Assertions). \nContext Logic consists of a set of data assertions and a set of context assertions, described by the \ngrammars: data assertions P ::= K(P ) |K . P structural assertions P .P |false additive assertions context \nassertions K ::= I |P . P structural assertions K .K |False additive assertions Definition 2 (Proof \nTheory). The Hilbert-style proof theory for Context Logic consists of the standard axioms and rules for \nthe additive assertions plus those for the structural assertions given in Figure 5. Definition 3 (Model). \nA model M for Context Logic is given by two sets, K and D, with a partial application function app : \nK \u00d7D . D and a nonempty set I .K that acts as a left identity: .d .D.app(I, {d})= {d} where app is extended \nto sets in the obvious way. The forcing semantics for the structural assertions with respect to a model \nM is also given in Figure 5, using two satisfaction relations M,c FK K and M,d FD P .The se\u00admantics for \nboth sets of additive connectives is standard. Theorem 4 (Soundness and Completeness). The proof theory \nis sound and complete with respect to the forcing se\u00admantics: that is, K .K K ' .(M,K FK K ' for all \nmodels M) P .D P ' .(M,P FD P ' for all models M) where M,K FK K ' ..c .K. M,c FK K .M,c FK K ' and \nM,P FD P ' ..d . D. M,d FD P . M,d FD P ' when M =(K, D, app,I). Proof. Soundness follows by easy induction \non the deriva\u00adtion of K .K K ' and P .D P ' respectively. Completeness requires techniques based on maximally \nconsistent sets of formulas and bisimulation, recently developed in [11]. Context Logic with Zero A natural \nadditional assertion is the zero assertion 0, cor\u00adresponding to the empty heap assertion in Separation \nLogic and the empty tree assertion in the Ambient Logic. We shall however see that this extra assertion \nis not present in the term rewriting case. When it is present, the zero asser\u00adtion allows us to derive \nextra structure: speci.cally, K(0) is a projection from contexts onto data, and 0 . P is an (adjoint) \nembedding in the other direction. Definition 5 (Context Logic Assertions with Zero). The Context Logic \nwith Zero consists of data and context assertions as in De.nition 1, with an additional data asser\u00adtion \n0. Definition 6 (Proof theory with Zero). The proof theory for Context Logic with Zero extends Figure \n5 with the following axioms: (0 . P )(0) ..D P \u00ac(0 . P ) ..K 0 . \u00acP I ..K 0 . 0 It is simple to check \nthat these axioms hold in our concrete tree model. We give further explanation after we introduce the \nmodels. P ..D I(P) K(P1) .D P2 K .K P1 . P2 K(P1) .D P2 P1 .D K . P2  K1 .K K2 P1 .D P2 M =(K,D,app,I) \nK1(P1) .D K2(P2) K .K P1 . P2 P .D P1 K(P) .D P2 M,d FD K(P)i. .c.K,d ' .D. s.t. app(c,d ' )= d, M,c \nFK K and M,d ' FD P M,d FD K . P i. .c.K.(M,c FK K and app(c,d) de.ned .M,app(c,d) FD P) P1 .D K . P2 \nK1 .K K M,cFK I i. c.I K1(P1) .D P2 M,cFK P1 . P2 i. .d.D.(M,d FD P1 and app(c,d) de.ned .M,app(c,d) \nFD P2) Figure 5: Context Logic Proof Theory and Forcing Semantics Definition 7 (Model with Zero). A \nmodel M for Context Logic with Zero is a model (K,D,app,I) for Con\u00adtext Logic with an additional set \n0 . D,and a relation Rapp .K \u00d7D de.ned by (c,d) .Rapp .d.app(c,0) which satis.es the following conditions: \n(i) Rapp is a total surjective function K .D; (ii) Rapp -1(0)= I.  The .rst Axiom in De.nition 6 implies \nthat Rapp is surjec\u00adtive, and the second implies that it is a total function. The third axiom corresponds \nto condition (ii). Notice that the action of Rapp on sets of contexts is rep\u00adresentable as an operator \n-p : K ..K(0). The inverse rela\u00adtion is also representable, as the operator -e : P ..(0 . P). Using this \nderived notation, we can give a new reading to the axioms in the proof theory. The .rst axiom becomes \nPep . .D P, and implies that (-e ,-p) is an embedding-projection pair. The second axiom becomes \u00ac(Pe) \n..K (\u00acP)e,and says that the embedding preserves and re.ects negations, or equivalently that -e has a \nright adjoint \u00ac((\u00ac-)p). The third axiom becomes I ..K 0e,and says that 0embedsto I. Definition 8 (Forcing \nsemantics with Zero). The forcing semantics for Context Logic with Zero extends Fig\u00adure 5 with M,d FD \n0 i. d.0 Lemma 11 (Unit). P *0 .P .0 *P Proof. The left logical equivalence follows immediately from \nthe .rst axiom in De.nition 6. The right one follows from the third axiom and I being the left identity \nof appli\u00adcation. However, * does not have a monoid structure in general. This is exempli.ed in the tree \nmodel: P*Q holds of a tree if it can be decomposed into a context whose underlying tree satis.es P, and \na tree satisfying Q. Therefore * is neither commutative nor associative. Moreover, the interpretation \nof *in the tree model is a relation R .(D \u00d7D) \u00d7D,rather than a partial function. Comparison with BI The \nBunched Logic of O Hearn and Pym [8] is a special case of Context Logic, where the two sets of assertions \nare iden\u00adtical, application corresponds to -*-, the two adjoints are the same due to the commutativity \nof *, and I corresponds to 0. We formalise the correspondence. When the model M comes from a BI model4, \nthen our derived *-connective coin\u00adcides with BI s *-connective. Moreover, in these BI models, the Context \nLogic is exactly as expressive as BI. Theorem 12 (Collapse to BI). For each data formula P, there exists \nan equivalent BI formula5 f: that is, M,true FD (P .f) whenever M comes from a BI model. In this section, \nwe have concentrated on a speci.c presen\u00adtation of boolean Context Logic. We are currently working on \nthe categorical semantics and completeness for several Theorem 9 (Soundness and Completeness with Zero). \nvariants of the logic, where context composition and the The proof theory for Context Logic with Zero \nis sound and complete with respect to the forcing semantics with Zero. Using the derived embedding/projection \nnotation, there is a natural way to de.ne a structural operation -*- on data: an embedding followed by \nan application. The de.nition of * and its two right adjoints (.xing either argument) is as follows: \nP *Q Pe(Q) P *- Q Pe . Q P -* Q \u00ac((\u00ac(P . Q))p) Lemma 10 (Adjoints). P*--and P-*-are the right adjoints \nof P *- and -*P, respectively. Proof. The former is immediate since K . - is right adjoint of K(-). The \nlatter follows from the adjunction properties of . and -e, together with excluded middle and the second \naxiom in De.nition 6. embedding/projection pair described here play a prominent role. This work will \nappear in a future paper.  5. PROGRAM LOGIC FOR TREE UPDATE We present a Hoare logic for reasoning about \nour tree update language, based on the fault-avoiding interpretation and small axioms of O Hearn, Reynolds \nand Yang [7]. We express and derive the weakest preconditions for our com\u00admands. Definition 13 (Hoare \ntriples). Atriple {P}C {Q}holds i. whenever C is run in a state s,T satisfying P:(i) it does not generate \na fault (we say C,s,T is safe), and (ii) if it terminates then the resulting state satis.es Q. 4That \nis, both K and D being the underlying set of the BI monoid, with app and I the binary operation and unit. \n5A formula in the fragment f ::= 0 | f*f | f-* f | f . f|false. {(x= x0) . 0} {(u = u0) . 0} {(EV =@n) \n. (x= x0) . (an:v[true] . y)} {(EV =@n) . (u= u0) . an:v[y]} {(EV =@n) . an:v[y]} {(EV =@n) . an:v[y]} \n{(EV =@m) . (u = u0) . bm:v[y]} {(EV =@n) . an:v[true]}  x= ET u = EV x=[EV ]T u =[EV ]V [EV ]T += FT \n[EV ]V = FV u =new a at EV dispose EV {(x = ET [x0/x]) . 0} {(u = EV [u0/u]) . 0} {(EV [x0/x]=@n) . (x= \ny) . (an:v[true] . y)} {(EV [u0/u]=@n) . (u = v) . an:v[y]} {(EV =@n) . an:v[y| FT ]} {(EV =@n) . an:FV \n[y]} {(EV [u0/u]=@m) ..n.((u=@n) . bm:v[y| an:nil[0]])} {(EV =@n) . 0}  The variables x,x0,y and u,u0,v \nare assumed to be distinct. Figure 6: Small Axioms {P} C {Q} Frame Rule: Mod(C) n FV(K)= {} {K(P)} C \n{K(Q)} {P} C {Q} Auxiliary Variable Elimination: = x|u|a|n/. FV(C) {. .P} C {. .Q} P '' . P {P} C \n{Q} Q. Q Consequence: {P '} C {Q '} {P} C1 {Q}{Q} C2 {R} Sequencing: {P} C1; C2 {R} Figure 7: Inference \nRules Small Axioms We give a set of small axioms , one for each of the com\u00admands that alter state. The \naxioms are small, in that they mention only those areas of data that are accessed by the corresponding \ncommand. They are presented in Figure 6 and are self-explanatory. Theorem 14. The Small Axioms are sound. \nProof. The result follows directly from the operational semantics of the commands. Inference Rules There \nare four inference rules, given in Figure 7. The key rule is the Frame Rule, which is a direct generalisation \nof the Frame Rule in [12]. It captures the idea of local behaviour, by stating that if a working tree \nis su.cient for the faultless execution of a command, then any additional tree structure will remain \nunaltered by that command. We use context assertions to separate out this extra structure. The set Mod(C) \nin the side-condition contains those store variables modi.ed by a command C: i.e. {x} for tree assign\u00adments \nand lookups, {u} for value assignments, lookups and new, {} for update and disposal, and the usual union \nfor sequences. We de.ne FV(P), FV(K)and FV(C)to bethe set of free variables in P, K and C, with variables \nbound only by existential quanti.ers. The Auxiliary Variable Elimination, Consequence and Se\u00adquencing \nrules are standard. The proof of soundness for the inference rules is routine, except for the Frame Rule \nwhich depends on the commands being local. Definition 15 (Locality). A command C is local if it satis.es \nthese properties: Safety Monotonicity: if C,s,T is safe (i.e. executes without fault) and C(T) is well-formed \nthen C,s,C(T) safe. Frame Property: if C,s,T is safe, C(T) is well-formed, and C,s,C(T) . * s ' ,T ' \nthen . T '' such that C,s,T . * ' ,T '' = C(T '' ). s and T ' These conditions characterise which commands \nact, and can therefore be reasoned about, locally. They are general\u00adisations of the conditions given \nin [12]. For example, a tree update command resulting in a non-wellformed tree must diverge (as mentioned \nin Section 3). This divergence is nec\u00adessary since the well-formedness check is a global one. Using fault \ninstead of divergence would break safety monotonicity and make local reasoning impossible. This situation \nis anal\u00adogous to reasoning about a heap command trying to allocate a .xed location, say 7. This command \nwould diverge when 7 is already allocated. Theorem 16. The Inference Rules given in Figure 7 are sound. \nProof. The only interesting case is the Frame Rule. All the commands are local (i.e. satisfy Safety Monotonicity \nand the Frame Property). Soundness then follows from a direct argument as in [12]. Weakest Preconditions \nThe weakest precondition with respect to a predicate P and a command C is a predicate characterizing \nall pre-states from which every terminating execution of C leads to a state satisfying P. Being able \nto express the weakest preconditions in the logic and derive them from the small axioms is an impor\u00adtant \nsanity check and immediately provides a completeness {P [ET /x]} x = ET {P } {P [EV /u]} u = EV {P } \n{.y, v, a, n. (EV =@n) . True(an:v[true] . y) . P [y/x]} x =[EV ]T {P } {.v, a, n. (EV =@n) . True(an:v[true]) \n. P [v/u]} u =[EV ]V {P } {.y, v, a, n. (EV =@n) . (an:v[y | FT ] . P )(an:v[y])} [EV ]T += FT {P } {.y, \nv, a, n. (EV =@n) . (an:FV [y] . P )(an:v[y])} [EV ]V = FV {P } {.y, v, b, m.(EV =@m) . (.n. (bm:v[y \n| an:nil[0]] . P [@n/u]))(bm:v [y])} u =new a at EV {P } {.v, a, n. (EV =@n) . ((0 . P )(an:v[true]))} \ndispose EV {P } The variables y, v, a, b, m, n (except a for new) are assumed not to occur free in the \ncommand or the postcondition. Figure 8: Weakest Preconditions result for straightline code: all true \ntriples are derivable. Furthermore, a standard design of a veri.cation tool is to use a veri.cation generator \non code annotated with pre-and postconditions to derive the weakest precondition of a given postcondition, \nand then verify, using a theorem prover (or automatic decision procedure when possible), that the cor\u00adresponding \ngiven precondition implies the weakest one. Figure 8 contains the weakest preconditions expressed as \nHoare triples. These triples are analogous to those given in [12] for heap update, as we show in Section \n6. As an ex\u00adample, consider the weakest precondition for the tree update command [EV ]T += FT : .y, v, \na, n. (EV =@n) . (an:v[y | FT ] . P )(an:v[y]) This property is satis.ed if EV evaluates to a pointer \n@n, and the tree can be split into a context C and a subtree an:v[y] for some fresh tree variable y, \nsuch that when an:v[y | FT ] is inserted into the context and the result is well-formed, then the result \nsatis.es P . In another words, the result of appending FT under the node at n satis.es P ,as wewould \nexpect. Lemma 17. The axioms in Figure 8 express the weakest preconditions. Proof. The result follows \ndirectly from the operational semantics of the commands. Theorem 18 (Derivation of WP s). The weakest \npre\u00adconditions are derivable. Proof. See extended version of the paper online. Program Logic Example \nUsing the example program from Section 3, we can demon\u00adstrate Hoare reasoning using Context Logic. By \ncalculating the weakest precondition of program with respect to the postcondition {true}, we can derive \nthe necessary condition for non-faulting execution. We show this for delink(@n), simplifying the expressions \nas we go: . . .a, b, m, v2. (0 . True(an:@m[true]))(bm:v2 [true]) u =[v]V ; . . .a, b, m, v1,v2. (u \n=@m) . (0 . True(an:v1 [true]))(bm:v2 [true]) x =[u]T . . .a, b, m, v1,v2. (u =@m) . (0 . True(an:v1 \n[true]))(bm:v2 [true]) dispose u {.a, v1. True(an:v1 [true]}[@n]T += x; {.a, v1. True(an:v1 [true]}[@n]V \n=nil {true} Hence the precondition of a non-faulting execution must sat\u00adisfy (0 . True(an:@m[true]))(bm:v2 \n[true]) for some a,b,m and v2. This assertion expresses exactly what we would expect: the pointer at \nan must point somewhere, but not to a direct ancestor. Furthermore, we can now easily derive a general \nspeci.cation for the command, using tree variables as place\u00adholders: {(0 . True(an:@m[x]))(bm:v[y])}delink(@n) \n{True(an:nil[x | bm:v[y]])} Relation to Ambient Logic A natural question is whether the weakest preconditions \nare expressible using (a variation of) the Ambient Logic to trees with pointers. The Ambient Logic can \nexpress updates at the top level of trees by using the parallel composition and branch adjoints to build \ncontexts around the tree. What it cannot do directly is reason about update in an arbitrary context. \nUsing a size argument, we can prove that the Am\u00adbient Logic cannot express the weakest preconditions \nwith\u00adout some form of recursion. By introducing the somewhere modality ., we obtain a limited form of \ncontext reasoning. However, we believe that this by itself is still not enough to express the weakest \npreconditions. This is best illustrated with an example. Expressing the weakest precondition of dispose \n@n with even a simple post\u00adcondition requires case by case analysis using the Ambient Logic with .. For \nexample, the postcondition bm1:v1 [bm2:v2 [0]] has weakest precondition {.a, v. (bm1:v1 [bm2:v2 [P ] \n| P ] | P ) . .an:v[true]} where P is (an:v[true] . 0). Meanwhile, the precondition for the weakened \npostcondition .bm2:v2 [true] is {.a,v. .an:v[\u00ac.bm2:v2 [true]] . .bm2:v2 [true]} These preconditions are \nclearly not parametric in the post\u00adcondition. Moreover, we know that the .rst of these pre\u00adconditions \nmust imply the second, since weakest precon\u00additions are monotonic with respect to the postcondition, \nand bm1:v1 [bm2:v2 [0]] implies .bm2:v2 [true]. It is clearly not straightforward to prove this implication. \nIn contrast, the implication for the weakest preconditions in Context Logic is trivial (where . is just \nthe context True): {.a, v. (0 .bm1:v1 [bm2:v2 [0]])(an:v[true])} . {.a, v. (0 ..bm2:v2 [true])(an:v[true])} \n 6. RELATION TO SEPARATION LOGIC We adapt our logic to reasoning about heap structures: that is .nite \npartial functions from locations to values. We represent heaps as a collection of unary cells m . . n,where \nm is the location of the cell and n the value it contains. Val\u00adues are locations and nil. By analogy \nwith our tree model, we present heaps and contexts with the grammars H =0 | m ..n | H * H C = -| C * \nH | H * C together with a structural congruence on heaps and con\u00adtexts, such that * is a commutative \nmonoid with unit 0, and a well-formedness condition stipulating unique locations. A variable store s \nmaps variables u to locations, and expres\u00adsions E, F take as values either locations or variables. The \nkey step in adapting our logic is to change the model\u00adspeci.c data and context assertions to .t the heap \nstructure: P ::= . K(P) | K .P | 0 | E . F |P . P | false |.u. P K ::= -| P .P |K . K | False |.u. K \nHere we have two atomic heap assertions: 0 and E ..F, which holds for the corresponding cell [ E]]s ..[[F]]s \n(cell [[E]]s containing value [ F]]s). Note that we do not need special context assertions, since all \nthe contexts are already expressible using the insertion adjoint P .Q.In particular, a context of the \nform P *- is expressible as (0.P), as there is only one way to add a hole to a heap. The resulting logic \nis essentially the assertion language of Separation Logic. The presence of a 0 allows us to de.ne * and \n-* as described in Section 4. These coincide with the ones of Separation Logic. Furthermore, our Collapse \nresult for BI (Theorem 12) gives us a translation of Context Logic assertions into the fragment de.ned \nby * and -* .Thus, the Context Logic for heaps has the same expressive power as Separation Logic. The \nconnection between reasoning about heaps and trees goes further. Our storage model and commands for ma\u00adnipulating \ntrees can be collapsed onto the heap to produce essentially the commands used in [12]. To do this, we \ndis\u00adcard tree variables but keep value variables, view pointers @n as locations n, and restrict ourselves \nto nodes of the form an:V [0], which we view as heap pointers n . . V (ignor\u00ading the tag a). The value \nassignment, lookup, update and disposal commands translate into their heap equivalents, as do the relevant \nsmall axioms, weakest preconditions, and even the derivation proofs [12]. For example, the weakest preconditions \nbecome: {P[E/u]} u = E {P}{.v.(true * (E .u =[E]V . v)) . P[v/u]}{P}{.v.((E .* P) * (E . v)} = F . F) \n-.[E]V {P}{.v.P * (E .dispose E . v)}{P} The only command that does not translate neatly is new. This \nis unsurprising. For heaps, we do not need to specify where a new cell goes (there is only one place \nit can go), but for trees we do. This is because, unlike heaps, trees have no single location that is \nexpressible locally. 7. APPLICATION TO TERM REWRITING We now adapt our Context Logic to reason about \nterm rewriting systems. Terms over a signature do not decompose as parallel composition of subterms, \ndue to the .xed arity of function symbols. They do however decompose nicely as context/subtree pairs, \nshowing that a *-like composition operator and empty term are not the essential primitives for all kinds \nof spatial reasoning. The simplicity of this adaptation to term rewriting demonstrates the generality \nof our Context Logic approach. In this application we treat rewrite rules as atomic com\u00admands, and capture \ntheir locality by giving small axioms and showing that the weakest preconditions are derivable. Intuitively, \nrewrite rules act locally since, once the redex is identi.ed, only the corresponding subterm is a.ected. \nWe formalize this by considering located terms, where each oc\u00adcurrence of a function symbol f is annotated \nwith a location n .N . Terms and contexts are de.ned in Figure 9. As be\u00adfore, we require uniqueness of \nidenti.ers for well-formedness. Our storage model consists of an environment, a variable store, and a \nworking term. The environment maps term variables x to terms, and is used only in the logic. The store \nmaps location variables u to locations. Expressions E are terms containing term variables and function \nsymbols annotated with location variables see Figure 9 for the full description. We write FVT (E) for \nthe free term variables and FVL(E) for the free location variables of E. Finally, we de.ne the command \nlanguage consisting of atomic rewrite commands E . F (with E and F subject to restrictions described \nlater) and sequencing: C = E . F | C; C The command E . F .nds matchings for the term variables in E, \nsuch that E evaluates to a subterm of the working term, and then replaces that subterm with the one gener\u00adated \nby substituting the matches into F, with fresh values assigned to F s location variables. For example, \nthe exe\u00adcution of the rewrite rule fu(x, y) . gv(x,hw(y)) in a store where u = n will turn fm(fn(cp,cp \n)) into fm(gk(cp,hl(cp ))) with k and l fresh, and will assign k to v and l to w. We must place the following \nrestrictions on E and F in the command E . F.For x = FVT (E), u = FVL(E), v = FVL(F), we require that: \ny = FVT (F), and 1. each x . x occurs exactly once in E and y . x,which corresponds to the de.nition \nof a rewrite rule; 2. each y . y occurs exactly once in F, a linearity condi\u00adtion needed to preserve \nwell-formedness;  terms T ::= fn(T1,T2,...Tk) k =0 contexts C ::= -|fn(T1,...,C,...Tk) k =1 term variables \nVarT = {x,y,...} expressions E ::= VarT |fu(E1,E2,...Ek) location variables VarL = {u,v,...} environment \n. .(VarT .n T) [[x]].s = .(x) valuations [ E]].s : store s.(VarL .n N) [[fu(E1 ...Ek)]].s = fs(u)([[E1]].s...[[Ek]].s) \nFigure 9: Term Rewrite: Data &#38; Storage Models T = C(TE ) TE T/u)/TF T/m/C(TF ) well-formed = E[ x][s(u]= \nF[ x][ v] Command: E .F,s,T . [s|m],C(TF ) v .where x= FVT (E),u= FVL(E)and v = FVL(F) .,s,T FT E .T \n=[[E]].s Logic: '' ' .,s,C FK fu(P1 ...,K,...Pk) ..C .C = fs(u)(T1 ...,C ,...Tk), .,s,Ti FT Pi, .,s,C \nFK K Figure 10: Term Rewrite: Command &#38; Logic Semantics 3. E is of the form fu(...) and not a term \nvariable VarT , so that the rewriting acts locally at u;and 4. each v . v occurs exactly once in F, \nallowing fresh location values to be assigned in parallel.  The operational semantics of E .F is given \nin Figure 10. Thefreevariables of E .F are u.v, whilst the modi.ed variables are just v. Since term variables \nare only used in\u00adternally for pattern matching, they are neither modi.ed nor free, which explains why \nthe environment is not a parameter of the operational semantics. We can now easily adapt our context \nlogic approach to reasoning about terms and rewrites. As before, the key is to change the model-speci.c \nassertions, in this case given by term expressions E and term contexts fu(P ...,K,...P). The tree and \ncontext assertions are given by the grammars: P ::= K(P) |K . P |E |P .P |false |.u.P K ::= -|P . P |fu(P,...,K,...P) \n|K .K |False |.u.K The semantics for the model-speci.c assertions is given in Figure 10. Our Hoare logic \nfor term rewriting consists of small ax\u00adioms for each rewriting command, the Frame Rule, and the other \ninference rules. The small axiom for E .F is simply {E[x'/x]} E .F {F[x'/x]} The substitution x'/x re.ects \nthe fact that the term vari\u00adables x are bound in the command, and can hence be re\u00adnamed in the logic. \nThe weakest precondition axiom is ' {(.v.(F[v'/v] . P[v'/v]))(E)} E .F {P} where x = FVT (E), v = FVL(F), \nxnFVL(P)= {} and v' nFVL(F,P)= {}. The derivation from the small ax\u00adiom is straightforward, using the \nFrame Rule with context '' ' .v.(F[v/v] . P[v/v]), and the Rule of Consequence.  8. CONCLUSIONS AND \nFUTURE WORK Although here we concentrated on a speci.c presentation of boolean Context Logic, there is \nongoing work on cate\u00adgorical semantics and completeness for other variants that include more structure \non contexts context composition and where embedding and projection take a more prominent role. This \nwill appear in a future paper. We have presented a Hoare logic for reasoning locally about trees, introducing \nContext Logic and deriving weak\u00adest preconditions. It is possible to describe our Hoare triples using \nthe Ambient Logic. However, it is not possible to de\u00adrive the weakest preconditions, since although we \nhave given such conditions for speci.c cases in Section 5, it seems clear that we cannot do it parametrically. \nWe have an inexpres\u00adsivity result for the Ambient Logic without recursion, but it remains future work \nto pin down such a result for the Ambient Logic with a somewhere modality. Our original motivation for \nreasoning about tree update was to reason about update languages for XML. In this pa\u00adper, we focus on \na simple imperative language for manipu\u00adlating trees, which is expressive enough to illustrate the sub\u00adtleties \nof tree update. In future, we will develop a full lan\u00adguage for XML update, incorporating features such \nas com\u00admands for updating nodes identi.ed by path expressions, and a local update command that renames \nnode identi.ers to avoid name clashes. We provide a general theory of boolean Context Logic, with a Hilbert-style \nproof theory, forcing semantics and mod\u00adels. We have shown soundness, and Yang and Calcagno have recently \nproved completeness. We also extend our results to the Context Logic with an additional 0 data element. \nThis element is present in the heap and tree model (empty heap or tree), but is not present in term rewriting. \nWith the 0 element, we can derive a *-like composition on data with two corresponding right adjoints. \nWhen *is associative and commutative, then the corresponding two right adjoints co\u00adincide and we obtain \nBI. We are only at the beginning of a general study of Context Logic. We are currently study\u00ading the \ncategorical semantics, and the corresponding models and completeness results (with Yang). We have shown \nthe generality of our Hoare logic reason\u00ading, by adapting our reasoning about tree update to heap update \nand term rewriting. The heap update example illus\u00adtrates that not only does our Context Logic collapse \nto BI, but also that our Hoare reasoning about trees collapses to that of heaps. Our term rewriting example \nillustrates that our focus on contexts is more fundamental than the multi\u00adplicative structure of BI (0 \nand *), and suggests that our Hoare logic reasoning is robust with respect to the style of update language \nchosen. These examples demonstrate the generality of our Context Logic reasoning. In future, we will \nextend this work to reason more generally about data up\u00addate. For example, a natural next step is to \nextend our work to more complex data structures involving name binding. Acknowledgments. We would like \nto thank Peter O Hearn, Pino Rosolini and Hongseok Yang for their insightful com\u00adments. This work was \nsupported by EPSRC.  9. REFERENCES [1] S. Abiteboul, P. Buneman, and D. Suciu. Data on the Web: from \nrelations to semistructured data and XML. Morgan Kaufmann, 1999. [2] N. Biri and D. Galmiche. A separation \nlogic for resource distribution. In 23rd Conference on Foundations of Software Technology and Theoretical \nComputer Science (FSTTCS), 2003. [3] C. Calcagno, P. Gardner, and U. Zarfaty. A context logic for tree \nupdate. In Proceedings of Workshop on Logics for Resources, Processes and Programs (LRPP 04), 2004. [4] \nL. Cardelli, P. Gardner, and G. Ghelli. Querying trees with pointers. Unpublished Notes, 2003; talk at \nAPPSEM 2001. [5] L. Cardelli and A. D. Gordon. Mobile ambients. Theoretical Comput. Sci., 240:177 213, \n2000. [6] S. Ishtiaq and P. O Hearn. BI as an assertion language for mutable data structures. In 28th \nPOPL, pages 14 26, London, January 2001. [7] P.O Hearn,J.Reynolds, and H. Yang. Local reasoning about \nprograms that alter data structures. In L. Fribourg, editor, Computer Science Logic (CSL 01), pages 1 \n19. Springer-Verlag, 2001. LNCS 2142. [8] D. Pym. The Semantics and Proof Theory of the Logic of Bunched \nImplications. Applied Logic Series. Kluwer Academic Publishers, 2002. http://www.dcs.qmul.ac.uk/~pym/Papersage/bunch.ps. \n[9] J. Reynolds. Separation logic: a logic for shared mutable data structures. Invited Paper, LICS 02, \n2002.  [10] I. Tatarinov, Z. G. Ives, A.Y.Halevy, andD.S.Weld. Updating XML. SIGMOD 2001, Santa Barbara, \nCA. [11] H. Yang and C. Calcagno. Completeness results for Context Logic and BI. In preparation, 2004. \n[12] H. Yang and P. O Hearn. A semantic basis for local reasoning. Proceedings of FOSSACS, 2002.  \n\t\t\t", "proc_id": "1040305", "abstract": "Spatial logics have been used to describe properties of tree-like structures (Ambient Logic) and in a Hoare style to reason about dynamic updates of heap-like structures (Separation Logic). We integrat this work by analyzing dynamic updates to tree-like structures with pointers (such as XML with identifiers and idrefs). Na&#237;ve adaptations of the Ambient Logic are not expressive enough to capture such local updates. Instead we must explicitly reason about arbitrary tree contexts in order to capture updates throughout the tree. We introduce Context Logic, study its proof theory and models, and show how it generalizes Separation Logic and its general theory BI. We use it to reason locally about a small imperative programming language for updating trees, using a Hoare logic in the style of O'Hearn, Reynolds and Yang, and show that weakest preconditions are derivable. We demonstrate the robustness of our approach by using Context Logic to capture the locality of term rewrite systems.", "authors": [{"name": "Cristiano Calcagno", "author_profile_id": "81100047402", "affiliation": "Imperial College, University of London, London, UK", "person_id": "PP31024717", "email_address": "", "orcid_id": ""}, {"name": "Philippa Gardner", "author_profile_id": "81100521527", "affiliation": "Imperial College, University of London, London, UK", "person_id": "PP39046739", "email_address": "", "orcid_id": ""}, {"name": "Uri Zarfaty", "author_profile_id": "81100525241", "affiliation": "Imperial College, University of London, London, UK", "person_id": "P707746", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1040305.1040328", "year": "2005", "article_id": "1040328", "conference": "POPL", "title": "Context logic and tree update", "url": "http://dl.acm.org/citation.cfm?id=1040328"}