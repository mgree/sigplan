{"article_publication_date": "01-12-2005", "fulltext": "\n Transition Predicate Abstraction and Fair Termination* Andreas Podelski Andrey Rybalchenko Max-Planck-Institut \nf\u00a8ur Informatik Saarbr\u00a8ucken, Germany  ABSTRACT Predicate abstraction is the basis of many program veri.ca\u00adtion \ntools. Until now, the only known way to overcome the inherent limitation of predicate abstraction to \nsafety prop\u00aderties was to manually annotate the .nite-state abstraction of aprogram. We extendpredicate \nabstractionto transition predicate abstraction. Transitionpredicate abstractiongoes beyondtheideaof.nite \nabstract-state programs(andcheck\u00adingtheabsenceofloops). Instead,ourabstractionalgorithm transforms a \nprogram into a .nite abstract-transition pro\u00adgram. Then, a second algorithm checks fair termination. \nThe two algorithms together yield an automated method for the veri.cation of liveness properties under \nfull fairness assumptions(justice and compassion). In summary, we ex\u00adhibit principles that extend the \napplicability of predicate abstraction-basedprogram veri.cation to thefull set of tem\u00adporal properties. \n Categories and Subject Descriptors D.2.4[Software Engineering]: Software/Program Veri.-cation;F.3.1[Logics \nand Meanings of Programs]: Spec\u00adifying and Verifying and Reasoning about Programs. General Terms Languages, \nTheory, Veri.cation.  Keywords Software model checking, transition predicate abstraction, fair termination, \nliveness. * This research was supported in part by the German Re\u00adsearch Foundation (DFG) as a part of \nthe Transregional Collaborative Research Center Automatic Veri.cation and Analysis of Complex Systems \n(SFB/TR 14 AVACS), by the German Federal Ministry of Education and Research (BMBF) in the framework of \nthe Verisoft project under grant 01 IS C38. Permission to make digital or hard copies of all or part \nof this work for personal or classroom use is granted without fee provided that copies are not made or \ndistributed for pro.t or commercial advantage and that copies bear this notice and the full citation \non the .rst page. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires \nprior speci.c permission and/or a fee. POPL 05, January 12 14, 2005, Long Beach, California, USA. Copyright \n2005 ACM 1-58113-830-X/05/0001 ...$5.00. 1. INTRODUCTION Since 1977, a high amount of research, both \ntheoretical and applied, has been invested in honing the tools for ab\u00adstractinterpretation[10] for verifying \nsafety andinvariance properties of programs. This e.ort has been a success. One promisingapproachis predicate \nabstraction on which a num\u00adber of academic andindustrialtools arebased[2,6,14,15, 30]. What has been \nleft open is how to obtain the same kind of tools for the full set of temporal properties. So far, there \nwas no viable approach to the use of abstract interpretation for analogous tools establishing liveness \nproperties (under fairness assumptions). This paper presents the .rst steps towards such an approach. \nWe believe that our work may open the door to a series of activities for liveness, similar to the one \nmentioned above for safety and invariance. Onebasicidea of abstractionistotransformtheprogram to be checked \ninto a more abstract one, one on which the property still holds. When we are interested in termination \nunder fairness assumptions, we need to solve two problems: the abstractprogram needs topreserve(1) thetermination \nproperty, and(2) thefairness assumptions. (Checkinglive\u00adness can be reduced to fair termination, just \nas safety re\u00adduces to reachability.) In this paper, we show how to solve these two problems. We propose \na transformation of a pro\u00adgram into a node-labeled edge-labeled graph such that the termination property \ncan be retrieved from the node labels and thefairness assumptionsfrom the edgelabels. (To avoid the possibility \nof confusion, note that our method does not check the absence of loops in the graph.) The transforma\u00adtion \nis based on transition predicate abstraction, an exten\u00adsion of predicate abstraction that we propose. \nThe di.erent steps in our automated method for checking a liveness property under fairness assumptions \nare: the reduction of the liveness property to fair termina\u00adtion(this reductionis standard, see e.g. \n[29]);  the transitionpredicate abstraction-based transforma\u00adtion of theprogram P into a node-labeled \nedge-labeled graph, the abstract-transition program P#;  a number of termination checks that mark some \nnodes of P# as terminating ;  an algorithm on the automaton underlying P# that marks some nodes as fair \n;  the method returns property veri.ed if each fair node is marked terminating .  Our conceptual contribution \nlies in the use of transition predicatesforautomatedlivenessproofs. Ourtechnical con\u00adtributions are the \nalgorithm to retrieve fairness in the ab\u00adstract program P#, and the proof of the correctness of the overall \nmethod. We use both relevant kinds of fairness, which are justice and compassion (to model the assump\u00adtion \nthat a transition is eventually taken if it is continually resp. in.nitely often enabled). 2. RELATED \nWORK Our work is most closely related to the work on predi\u00adcate abstraction; see e.g. [2, 6, 14, 15, \n30]. The key idea of predicate abstraction is to partition the state space of the program into a .nite \nset of equivalence classes using pred\u00adicates over states. The equivalence classes are treated as the \nabstract states forming the nodes of a .nite graph. A safetyproperty canthenbe checked onthe abstract \nsystem. Predicate abstraction can also provide a basis for the devel\u00adopment of testing methods by guiding \nthe test generation, e.g. [1]. Unfortunately, predicate abstraction is inherently limited to safety properties. \nThat is because every su.ciently long computation oftheprogram(withthelengthgreaterthen the number of \nabstract states) results in a computation of the abstract system that contains a loop. I.e., termination \n(as wellas more general liveness properties) cannot be pre\u00adserved by predicate abstraction. local y : \nnatural e0 : while y> 0 do \u00bb e1 : y := y -1 e2 : skip e3 : y> 0, t1 : ' y= y-1 y =0, t2: ' y= y Figure \n1: Terminating program LOOP. We illustrate the limitation on a very simple program LOOP [16], shown on \nFigure 1 together with the (slightly simpli.ed) control-.ow graph. The predicates y = 0 and y> 0 split \nthe data domain of the variable y into zero and pos. The corresponding abstractiontransformstheprogram \nLOOP into the .nite-state abstract program shown on Fig\u00adure 2. That program contains a self-loop, i.e. \nis not ter\u00adminating. The abstract state S1 corresponds to the con\u00adjunction at e0 .y> 0 denoting the set \nof states where the program counter has the value e0 and y is strictly positive. If we split the abstract \nstate S1 (byadding morepredicates) then at least one of the resulting abstract states will have a self-loop, \nand so on. In the augmented abstraction framework for proving live\u00adness properties, the .nite-state abstraction \nis annotated by t1  Figure 2: Non-terminating abstract-state program for LOOP. progress monitors orthelike[16,17,22,31]. \nThe annota\u00adtion involves the manual construction of ranking functions or other termination arguments. \nUntil now, this has been the only known way to overcome the inherit limitation of predicate abstraction \nto safety properties. In contrast, the method that we propose does not require the manual con\u00adstruction \nof termination arguments. In[24] wepresented aproof rulefortermination andlive\u00adness based on transition \ninvariants. In this paper, we make the .rst stepstowardsrealizingitspotentialforautomation. We note a \nmajor di.erence in the notions of fairness used here and in [24]. In [24], we used an automata-theoretic \nnotion of state-basedfairness to formalize a uniform setting. Here we use justice and compassion, two \ntransition-based notions offairness. These are the two notions offairness that arerelevant with concreteconcurrentprograms. \nItis widely accepted that one needs a direct treatment of justice and compassion since the translation \nto the automata-theoretic notion is prohibitively expensive. As a consequence, the notion oftransitioninvariantin[24]is \nnot applicable as such. Forintuition, anabstractprogram P# canbeimagined as a new notion of transitioninvariant, \nonethat encodesjustice and compassion assumptions in a graph with labeled edges. The abstractinterpretationframeworkformalizes \nthe con\u00adservative approximation of .xed point expressions [10]. For the veri.cation of liveness properties \ndenoted by .x\u00adpoints expressions, this approximation involves the under\u00adapproximationofleast .xpointsor(equivalently) \ntheover\u00adapproximation of greatest .xpoints. Although possible in principle, the automation of the corresponding \nextrapola\u00adtionseemsdi.cult, andpracticaltechniques(analogousto theextrapolationbyintervals, convexhulls,Cartesianprod\u00aducts,etc.) \narenotinsight(cf.[4,12,26,28]). One source of inspiration for the idea of abstracting re\u00adlations is the \nwork on higher-order abstract interpretation in[11]. Itsinstantiation to transitionpredicate abstraction \nandits useforliveness withjustice and compassionisproper to this paper. The termination analysis of[19]forfunctionalprogramsis \nbased onthecomparisonofin.nitepathsinthecontrol .ow graph and in size-changing graphs ; that comparison \ncan be reduced to the language containment test of B\u00a8uchi au\u00adtomata. Our work extendstheterminationprinciplein[19] \nto a setting with parameterized abstraction, liveness, and fairness. Veri.cationdiagrams aregraphsthat \nare useful tofactor\u00adize deductive proofs of temporal properties including live\u00adness [5]. Their nodes \ndenote sets of states (and not pairs of states) and arehence closein spiritto abstract-statepro\u00adgrams(andnot \nto the abstract-transitionprograms). Itmay be interesting to consider veri.cation diagrams with nodes \ndenoting sets of pairs of states, and to come up with accord\u00ading proof rules. The predicate abstraction \nmethod of [9] constructs an abstract-state system for which it can automatically trans\u00adfer some fairness \nrequirements of the input program. The method applies to liveness properties that can be proven by considering \nonly the transfered fairness, which strongly depends on theprecision of the abstraction. Our methodac\u00adcounts \nfor fairness requirements without abstracting them.  3. ABSTRACT-TRANSITION PROGRAMS Informal Description. \nWe propose to abstract relations instead of sets of states, and to use transition predicate ab\u00adstraction \ninstead of predicate abstraction. Transition pred\u00adicates arebinary relations over states(given e.g. by \nasser\u00adtions over unprimed and primed program variables). Transition predicate abstraction goes beyond \nthe idea of abstracting aprogramby a .nite abstract-state program. In\u00adstead, we abstract a program by \na .nite abstract-transition program. An abstract transition is a binary relation rep\u00adresented by a conjunction \nof transition predicates. An abstract-transition program is given by a .nite directed graph whose nodes \nare labeled by abstract transitions, and whose edges are labeled by program statements, later for\u00admalized \nas transitions t .T. t1 Figure 3: Abstract-transition program LOOP# . On Figure 3, we see the abstract-transition \nprogram LOOP# . One node is labeled by the abstract transition T1. It corresponds to the conjunction \nof transition predicates at e0 .at ' e0 .y> 0.y ' = y-1 denoting the set of all pairs of states (s,s \n' ), both at the program location e0. The value of y is strictly positive in the state s, and changes \nto a strictly smaller valuein s ' . The node labeled by T2 refers to states s and s ' at e0 and at e3 \n(withunspeci.ed values for y), respectively. The abstract-transition program LOOP# abstracts the program \nLOOP. What does this mean? We .rst recall themeaning of abstractionof aprogramby an abstract-stateprogram. \nIf a state s has a transition to s ' underthe execution of theprogram statement t, then there is an edge \nlabeled by t between two corresponding abstract states S1 and S2 (i.e. s . S1 and s ' . S2). The meaning \nof abstraction of a program by an abstract\u00adtransition program is analogous. If a pair of states (s,s \n' ) can be extended to the pair (s,s '' ) by the execution of the program statement t (which is: s ' \ngoes to s '' under the execution of the statement t), then there is an edge labeled by t between two \ncorresponding abstract transition T1 and T2 (which is: (s, s ' ). T1 and(s,s '' ). T2). Note that LOOP# \nonly serves to demonstrate the con\u00adcept of abstract-transition programs. To illustrate how our method \nworks to verify termination and general liveness properties, we will use concurrent programs with nested \nloops. In fact, the program LOOP is an example of a sin\u00adgle while loop program. Our method calls(as a \nsubroutine) a termination check that exists for single while loop pro\u00adgrams[8, 23, 27]. We now start \nthe formal de.nitions. Programs and Computations. Following[20], weabstract away from the syntax of a \nconcrete (concurrent) program\u00adming language and represent a program P by a fair transi\u00adtion system P \n= (S, T, T, J, C) consisting of: S: the set of states,  T: asetof initial states such that T . S, \n T: a .nite set of transitions such that each transition t .T is associated with a transition relation \n.t,  .t . S\u00d7 S J: a set of just transitions such that J .T,  C: a set of compassionate transitions \nsuch that C.T.  A computation s is a sequence of states s1,s2,... , which is either in.nite or no more \nextendible, such that: s1 is a initial state, i.e. s1 . T,  for each i = 1 there exists a transition \nt .T such that si goes to si+1 under .t, formally  (si,si+1). .t. We will de.ne fairness requirements \n(justice and compas\u00adsion) in Sections 6 and 7, respectively. We write example programs using the Simple \nProgram\u00admingLanguageSPL of[20]. ThetranslationfromSPL and other(concurrent) programminglanguagesintofair \ntransi\u00adtion system is standard. Transition Predicates. We now de.ne the building blocks for abstract-transition \nprograms. Definition 1 (Transition Predicate p). A transition predicate p is a binary relation over states. \nUsually,transitionpredicates aregivenby atomic assertions overunprimed andprimedprogramvariables. We \n.xatran\u00adsition predicate Id for the identity relation, formally Id = {(s,s)|s . S}. From now on, the \nformal statements refer to a .xed .nite set of transition predicates P. The predicates at e and at ' \ne are implicitly contained in P, for all program locations e. Definition 2 (Abstract Transition T). An \nabstract transition T is a conjunction of transitionpred\u00adicates. We write TP # for the (.nite) set of \nabstract transi\u00adtions. Formally, TP # = {p1 .... .pn |n = 0 and p1,...,pn .P}. Alternatively, we may \nde.ne an abstract transition to be a conjunction in which every transition predicate appears either positively \nor negated. In this case, abstract transi\u00adtions can be identi.ed by bit-vectors. The di.erence is only \nrelevant for implementation issues. An abstract-transition program uses abstract transitions for its \nnode labels. P#An abstract-transition program P# is a .nite directed rooted node-labeled edge-labeled \ngraph Definition 3 (Abstract-Transition Program ). P# = (V,E,v0,LV ,LE) where: V and E are the set \nof nodes resp. edges,  v0 . V is the root node,  LV : V .TP # and LV (v0)= Id, i.e., every node v is \nlabeled by an abstract transi\u00adtion LV (v) which we also write Tv, the root node is labeled Id,  LE : \nE .T, i.e., every edge (u,v)is labeled by a transition t.  We illustrate the de.nition above on the \nabstract-transition program LOOP#, shown on Figure 3. V = {v0,T1,T2}, E = {(v0,T1), (T1,T1), (T1,T2)}, \nLV (v0)= Id LV (T1)= at e0 .at ' e0 .y> 0.y ' = y -1 LV (T2)= at e0 .at ' e3 LE(v0,T1)= LE(T1,T1)= t1 \nLE(T1,T2)= t2 We will often use the set V- of all non-root nodes (on .gures illustrating examples, we \ndo not show v0). V- = V \\{v0} As usual, the symbol . denotes the relational composition operator. R1 \n.R2 = {(s,s '' )|exists s ' such that ' ''' (s,s ). R1 and(s ,s ). R2} We can now de.ne the meaning of \nabstraction of a pro\u00adgram P by an abstract-transition program P# . Later on, wepresent an algorithmfor \nthe transformation of aprogram P into an abstract-transition program P# . P#An abstract-transition program \nP# = (V,E,v0,LV ,LE) is an abstraction of the program P = (S, T, T, J, C) if for all nodes v1 labeled \nby, say, the abstract transition T1, and for all transitions t of the program P, Definition 4 (Abstraction \nP .). if T1 contains a pair of states (s,s ' ) such that s ' goes to some state s '' under the transition \nt, then there exists a non-root node v2 that is labeled by an abstract transition T2 containing the \npair (s,s '' ), and  there exists an edge from v1 to v2 labeled by t.  Formally: ' ''' v1 . V, LV (v1)= \nT1, (s,s ). T1, (s,s ). .t implies the existence of v2 . V- and (v1,v2). E such that LE(v1,v2)= '' ). \nt and, for LV (v2)= T2, (s,s T2. Note that the target node v2 in thede.nition above mustbe di.erent from \nthe root node v0. However, there may exist a target node v2 labeled by Id. In the rest of the paper, \nthe notation P# always refers to anabstract-transitionprogram P# thatis an abstraction the program P, \ni.e. P .P# . 4. AUTOMATED ABSTRACTION P . P# Givena .niteset of transitionpredicates P, the algorithm \nshown onFigure4 takes aprogram P and returns aprogram P# abstracting it, i.e. P .P# . The algorithm constructsthe \nnodes(and edges) of P# in a breadth-.rst manner. The set of nodes whose successors have not been yet \nexplored are kept in the queue Q. The set of transition predicates P de.nes a unique best\u00adabstraction \nfunction a for the abstractdomainTP # . Itmaps a binary relation T over states to the smallest abstract \ntran\u00ad sition containing the relation T. For example, if the set of transition predicates is ' '' P = \n{x = 0,x = x -1,x = x,x = x +1}, the relation T = x> 0.x ' = x -1 is abstracted to the abstract transition \na(T)= x = 0.x ' = x -1. The algorithm implements the abstraction function a using the following equality. \n^ a(T)= {p .P| T . p} Here, the assertions p and T de.ne binary instead of unary relations over states, \nand useprimed and unprimed variables instead ofjust unprimed variables. Everything elseis asin classical \npredicate abstraction. That is, a theorem prover is called for each entailment test T . p . If n is the \nnumber of predicates, then for each newly created node and each transition t we have n calls to the theorem \nprover. Thus, the theoretical worst-case number of calls to the theorem prover is the same as in classical \npredicate abstraction.  5. OVERALL METHOD Our overall method to check a liveness property of a pro\u00adgram \nunder fairness assumptions consists of the .ve steps given in the introduction. input P: program with \n.nite set of transitions T P: .nite set of transition predicates  output abstract-transition program \nP# with: V: set of nodes labeled by abstract transitions E: set of edges labeled by transitions t begin \nQ:= empty queue V a := .T. {p .P| T . p} v0 := new node labeled by Id V := {v0} enqueue(Q, v0) E := \u00d8 \nwhile Q not empty do u := dequeue(Q) foreach t .T do T := a(Tu ..t) if T = \u00d8 then continue with next \nt . if exists w . V- such that T = Tw then v := w else v := new node labeled by T V := V .{v} enqueue(Q, \nv) . (u,v):= new edge labeled by t E := E .{(u,v)} od od end. Figure 4: Transition predicate abstraction \nP . P# . Wedonotfurtherelaboratethe .rststep,thereductionof the veri.cation problem for general temporal \nproperties to the oneforfairtermination. This step is standard(cf.[29]), analogous one for safety and \nreachability. We have just presented the second step, the transition predicate abstraction-based transformation \nof the program P into a node-labeled edge-labeled graph, the abstract\u00adtransition program P# . We now \n.x P# . The third step checks, for each non-root node v of P# , whether its label, the abstract transition \nTv, is well-founded (and then marks the node accordingly as terminating or not). In fact, our method \ncan be parameterized by the well-foundedness test we apply. Here, we assume that the transition predicates \nare linear arithmetic formulas (with\u00adout disjunction). Then, we can apply one of the well\u00adfoundedness \ntests described in [8, 23, 27]. For intuition, the well-foundedness of a relation de.ned by a conjunctive \nformula in primed and unprimed variables is the termina\u00adtion of a corresponding program that consists \nof a single while loop. The loop body only contains a simultaneous (possibly non-deterministic) update \nstatement. For exam\u00adple, x> 0.x ' = x-1 corresponds to while(x>0){x:=x-1}. From our experience, checking \nwell-foundedness of abstract transitions(termination of single whileloops) canbedone very e.ciently. \nE.g. our prototype implementation of [23] handles over 500 single while loops in a couple of millisec\u00adonds. \nThe only missing link is the fourth step of our overall method: an algorithm on the automaton underlying \nP# that marks nodes as fair resp. unfair . Before we give the formal de.nition of each kind of fairness, \njustice resp. compassion in Section 6 resp. Section 7, we outline the al\u00adgorithm. The .rstpartof thealgorithmcomputes,foreach \nnode v, a set abc(Lv) of transitions, i.e. abc(Lv).T. The second part checks a condition on abc(Lv). \nThat condition is spe\u00adci.ctothekind offairness, namely(1) inSection6 resp.(2) in Section 7. The algorithm \nmarks the node v according to the outcome of the check. In its .fth, .nal step our method returns property \nveri\u00ad.ed if each fair node is marked terminating . Hence, the correctness of our overall method follows \nfrom Theorem 1 in Section 6 resp. Theorem 2 in Section 7, depending on the kind of fairness. Finite Automata. \nWe observe that the graph of P# with\u00adoutthenodelabelsisthetransitiongraph of adeterministic .nite automaton \nover the alphabet T. Each node v . V de\u00ad.nes an automaton Av whose initial state is the root node v0, \nand whose only .nal state is the node v. Av = (T,V,d,v0, {v}) The transition relation d is the following. \nd = {(u,t,v)|(u,v). E is an edge labeled by t} Let Lv be the language de.ned by the automaton Av. We \nnext formalize the fact that the language Lv covers all rele\u00advant compositions of transition relations. \nLemma 1. Every word t1 ...tn over transitions in T lies in the lan\u00adguage Lv for a non-root node v, unless \nthe composition of the corresponding transition relations is empty. Formally, .t1 .... ..tn = \u00d8 =..v \n. V-.t1 ...tn .Lv. Proof. By induction over n. The set abc(Lv) consists of all letters appearing in some \nword in Lv, i.e. of all transitions t .T labeling the edges that constitute a path from the root node \nv0 to the node v. \\ abc(Lv)= {M .T|Lv . M * } We compute abc(Lv)by traversing backwards the graph of \nAv from the node v.  6. JUSTICE Justice is a conditional fairness requirement [20]. It is sensitive \nto the enabledness of transitions. A transition t is enabled on the state s if the set of states {s ' \n|(s,s ' ). .t} is not empty. We write En(t)for the set of states on which the transition t is enabled. \nEn(t)= {s |exists s ' . S suchthat(s,s ' ). .t} Justice requirement is represented by a set J of just \ntran\u00adsitions, J.T. Every just transition that is continually enabled beyond a certain point must be taken \nin.nitely of\u00adten. We make the following assumption on the transition rela\u00adtions of the program P. Assumption \n1 (Transition Disjointness for J). Transition relation of each just transition is disjoint from the transition \nrelation of every other transition. Formally, .tj .J .t .T.t j = t =. .tj n.t = \u00d8. The assumption is \nnot a proper restriction. In fact, it is au\u00adtomatically ful.lled by the transition relations of SPL pro\u00adgrams. \nFor every pair of transitions t\u00a3 and tm that belong to di.erent processes, we have the following transition \nrela\u00adtions. '' ' .t\u00a3 = at e .at e .at m .at m .... ' '' .tm = at e .at e .at m .at m .... Clearly, the \nrelations .t\u00a3 and .tm are disjoint. Transitions that belong to the same process are marked with di.erent \nlabels, so their enabledness sets are disjoint. We make thefollowingassumption on the enabledness sets \nof transition in the program P. Assumption 2 (Enabledness for J). The enabledness set of eachjusttransitionis \neither disjoint or coincides with the enabledness set of every other transi\u00adtion. Formally, jj .t.J .t \n.T.t = t =. (En(tj)nEn(t)= \u00d8. En(tj)= En(t)). Assumption2is notaproper restriction either;for complete\u00adness, \nwe give the corresponding syntactic transformation in the appendix. We de.ne an auxiliary predicate just(v,tj)as \nfollows. just(v,tj)= tj . abc(Lv). .t . abc(Lv). En(t)nEn(tj)= \u00d8 Informally, just(v,tj) holds if the \ntransition tj is either taken or not continually enabled on somepathfrom the root to the node v. Such \ntransitions contribute to the marking of v as fair . A node v . V- ismarked(justly) fair ifthepredicate \njust(v,tj)holdsfor everyjusttransition. fairJ (v)= .tj .J. just(v,tj) (1) We saythataprogram justlyterminates \nifitdoes nothave in.nite computationsthat satisfy thejustice requirement. Theorem 1 (Just Termination). \nThe program P justly terminates if every non-root fair marked node v of the abstract-transition program \nP# is la\u00adbeled by a well-founded abstract transition Tv, formally .v . V- . fairJ (v)=. well-founded(Tv). \nProof. Assume that the program P does notjustly ter\u00adminate. We show that there exists a non-rootnode \nv labeled by a non-well-founded abstract transition Tv, and that for everyjust transition tj the predicate \njust(v,tj)holds. Let s = s1,s2,... be an in.nite computation induced by the in.nite sequence of transitions \n. = t1,t2,... , where for all i = 1 we have (si,si+1) . .ti, that satis.es the justice requirement. The \ncomputation s partitions the set of just transitions d(isabled) t(aken) J into the sets Jand Jas follows. \nA transi\u00adtion t .J is in the set Jd if it is not continually enabled. Otherwise, i.e., if t is takenin.nitely \noften, wehave t .Jt . Let L = l1,l2,... be anin.nite ordered set ofpositionsin s such that for all i \n= 1 we have: Every transition from Jd is not enabled on a state lying between the positions li and li+1, \nformally .t .Jd .i = 1 . li <p <li+1.sp . En(t). Every transition from Jt is taken on a state lying be\u00adtween \nthe positions li and li+1, formally .t .Jt .i = 1 . li <p <li+1.tp = t. Such a set L exists since s satis.esthejustice \nrequirement. For the .xed sequences . and L, we de.ne a function f that maps apair ofpositions(k,l), \nwherek<l, from L to one of the nodes of the abstract-transition program P# in the following way. We de.ne \nf(k,l) to be the node v such that the word tk ...tl-1, which is a segment of ., is in the language Lv. \nThe function f exists, by Lemma 1. The function f induces an equivalence relation ~ onpairs of elements \nof L. '' '' (k,l)~ (k ,l ) ifand only if f(k,l)= f(k ,l ) Since the range of f is .nite, the equivalence \nrelation ~ has .nite index. ByRamsey s theorem[25], there exists an in.nite ordered set of positions \nK = k1,k2,... , where ki . L for all i = 1, that satis.es the following property. All pairs of elements \nin K belong to the same equivalence class. That is, there exists a non-root node v such that for all \nk,l . K where k<l we have f(k,l)= v. We .x the node v. Since f(ki,ki+1)= v for all i = 1, the in.nite \nsequence sk1,sk2,... is induced by the relation Tv. (ski,ski+1). Tv for all i = 1 We conclude that the \nabstract transition Tv is not well\u00adfounded. We show that each transition tj .Jt is contained in the set \nof transitions abc(Lv). By the choice of the set L and taking into consideration that the set K is a \nsubset of L, for each i = 1 there existpositions a and b in L such that a<b, la = ki, and lb = ki+1. \nFurthermore, we have tj .{tla ,...,tlb-1}. Since the word tki ...tki+1-1 is in the language Lv, we con\u00adclude \ntj . abc(Lv). We show that for every td .Jd there exists a transition t . abc(Lv) such that En(t)nEn(td)= \n\u00d8. By the choice of L, there exists a position p in s between the positions ki and ki+1 such that the \ntransition td is not enabled on the state sp. Thus, the transition from the state sp to its successor \nstate is induced by a transition t . td = We have t . abc(Lv). By Assumption 2, the sets En(td)and En(t) \nare disjoint. We nowillustrate an application ofTheorem1forproving just termination ofexample programs. \nlocal x,y : integer where x =1,y =1 2 6 6 P1 :: 4 \u00bb e0 : while x =1 do e1 : y := y+1 e2 : while y> 0 \ndo e3 : y := y-1 m0 : x := 0 . P2 :: m1 : 3 7 7 5 x =1, y> 0, '' '' x = x,y = y+1 x = x,y = y-1  x \n= 1, x ' = x,y ' = y x ' =0,y ' = y Figure 5: Program ANY-DOWN. ANY-DOWN. We show the program ANY-DOWN \non Fig\u00adure 5. We obtain the control-.ow graph shown on Figure 6 by taking the asynchronous parallel composition \nof the pro\u00adcesses. Every transitionisjust. J = {t1,...,t4} We compute the abstract-transition program \nANY-DOWN#, shown on Figure 7, by taking the following set of transition predicates. P = {x =0,x =1,y \n> 0,y ' = y -1} The abstract transition T1 is the only one thatis not well\u00adfounded. From the graph of \nANY-DOWN#, we obtain the following set abc(L1). abc(L1)= {t1} Since the enabledness condition of the \ntransition t1 coin\u00adcides with the enabledness condition of the transition t4, thepredicate just(1,t4)does \nnot hold. Hence, the non-well\u00adfoundedness of T1 is not required for the just termination of ANY-DOWN. \nSince all other abstract transitions are well\u00adfounded, by Theorem 1, we conclude the ANY-DOWN justly \nterminates. ANY-WHILE. We make the program ANY-DOWN more in\u00adterestingby adding aloopinthesecondprocess. \nTheresult\u00adingprogram ANY-WHILE and the control-.owgraphfor the parallel composition of its processes \nare shown on Figures 8 and resp.9. Every transitionisjust. J = {t1,...,t6} x =1,x ' = x,t1 : y ' = y+1 \n x =1,x ' =0, t4: y ' = y x =0,x ' = 0, t2 : y ' = y e2,m1  x =0,x ' = x,t3 : y> 0,y ' = y -1 Figure \n6: Control-.ow graph for the parallel com\u00adposition of processes P1 and P2 in ANY-DOWN. t1 t2 at e0,at \nm0, at e0,at m1, T1 : '' t1 T2 : '' at e0,at m0 at e2,at m1 x =1 x =0 t4 t3 Figure 7: Abstract-transition \nprogram ANY-DOWN# . local x,y : integer where x =1,y =1 23 e0 : while x =1 do 67 e1 : y := y +1 67 P1 \n:: 4 e2 : while y> 0 do 5 e3 : y := y -1 \u00bb m0 : while y> 0 do . P2 :: m1 : x := 0 x =1, y> 0, '' '' x \n= x,y = y+1 x = x,y = y -1 x = 1, x ' = x,y ' = y  y> 0, x ' =0,y ' = y Figure 8: Program ANY-WHILE. \nx =1,x ' = 0, t4 : y> 0,y ' = y x =1,x ' = x, x =0,x ' =0, t1 : y> 0, t5: ' y> 0,y = y y ' = y +1 x =0,x \n' = x, t2 : ' y> 0,y = y x =0,x ' = x, x =0,x ' =0, t3 : y> 0,t6: ' y> 0,y = y y ' = y -1  Figure 10: \nAbstract-transition program ANY- Figure 9: Control-.ow graph for the parallel com- WHILE# . position \nof the processes P1 and P2 in ANY-WHILE. For the set of transition predicates P = {x =0,x =1,x ' = x, \nx ' =0, y> 0,y ' = y, y ' = y -1} we compute the abstract-transitionprogram ANY-WHILE# , shown on Figure \n10. We observe that the abstract transitions T1,T5, and T6 are not well-founded. We read the following \nsets from the graph of ANY-WHILE# . abc(L1)= {t1} abc(L5)= {t5} abc(L6)= {t6} Looking at the control-.ow \ngraph on Figure 9, we observes the following. En(t1)= En(t4) En(t5)= En(t2) En(t6)= En(t3) This means \nthat the predicates just(1,t4), just(5,t2), and just(6,t3) do not hold. Hence, the well-foundedness of \nT1,T5, and T6 is not requiredfor thejust termination. We conclude that ANY-WHILE justlyterminates.  \n7. COMPASSION Compassion is another conditional fairness require\u00adment [20]. Compared to justice, it is \nnot sensitive to the interruptionof transitionenablednessin.nitely many times. Compassion requirementis \nrepresentedbya set C of compas\u00adsionate transitions, C.T. Every compassionate transition thatis enabledin.nitely \noften mustbe takenin.nitely often. We extend Assumptions 1 and 2 to compassionate tran\u00adsitions. This \nextension is not a proper restriction (see the appendix for details). For dealing with compassion, we \nare interested in the set T of letters(transitions) abc( Lv)that appear in every word of the language \nLv. \\ abc( Lv)= {t |Lv n(T \\{t}) * = \u00d8} T We compute the set abc( Lv) by a standard algorithm, which \ninvolves a backward graph traversal staring from v and computing intersections over all paths. We de.ne \nan auxiliary predicate comp(v,tc)as follows. tc comp(v,tc)= . abc(Lv). \\ .t . abc( Lv). En(t)nEn(tc)= \n\u00d8 Informally, comp(v,tc) holds if the transition tj is either taken or possibly continually disabled \non some path from the root to the node v. A node v . V- ismarked(compassionately) fair ifthe predicate \ncomp(v,tc)holds for every compassionate transi\u00adtion. fairC(v)= .tc .C. comp(v,tc) (2) We say that a program \ncompassionately terminates if it does not have in.nite computations that satisfy the com\u00adpassion requirement. \nTheorem 2 (Compassionate Termination). Theprogram P compassionately terminatesif every non-root fair \nmarked node v of the abstract-transition program P# is labeled by a well-founded abstract transition \nTv, formally .v . V- . fairC(c)=. well-founded(Tv). Proof. Assume that the program P does not compas\u00adsionately \nterminate. We show that there exists a non-root node v labeledby a non-well-founded abstract transition \nTv, and thatfor every compassionate transition tc thepredicate comp(v,tc)holds. Let s = s1,s2,... be \nan in.nite computation induced by the in.nite sequence of transitions . = t1,t2,... , where for all i \n= 1 wehave(si,si+1). .ti, that satis.es the compas\u00adsion requirement. The computation s partitions the \nset of compassionate and Ct(aken) transitions C intothe setsCd(isabled) asfollows. A transition t .C \nis in the set Cd if it is not enabled in.nitely often. Otherwise, i.e., if t is taken in.nitely often, \nwe have t .Ct . Let L = l1,l2,... be anin.nite ordered set ofpositionsin s such that: Every transition \nt .Cd is not enabled on states at positions after l1, formally .t .Cd .p = l1.sp . En(t). Every transition \nt .Ct is taken on a state lying be\u00adtween the positions li and li+1 for all i = 1, formally .t .Ct .i \n= 1 . li <p <li+1.tp = t. By de.ning an equivalence relation onpairfromthe set L and applying Ramsey \ns theorem along the lines of the proof of Theorem 1, we obtain an in.nite ordered set K . L and a non-root \nnode v with the following property. For every pair of elements(k,l) in K we have f(k,l)= v. Again, we \nobserve that the abstract transition Tv is not well-founded. Furthermore, since every transition from \nCt is taken on a statebetween thepositions ki and ki+1 for all i = 1, we con\u00adclude that Ct is contained \nin the set of transitions abc(Lv). By the choice of L, a transition td .Cd is not enabled on the state \nsp for every position p in s after the position k1. T Since every transition t . abc( Lv) must appear \nbetween the positions ki and ki+1, we conclude that there exists a state s such that s . En(t) and s \n. En(td). By Assump\u00adtion2(which we extendedto the compassionate transitions), the sets En(td)and En(t)are \ndisjoint. SUB-SKIP. We illustrate Theorem 2 on the program SUB-SKIP, shown on Figure 11. The set of compassionate \ntran\u00adsitions C is the following. C = {t2,t3} Every in.nite computation of SUB-SKIP may take the tran\u00adsition \nt2 only .nitely many times, although it is enabled in\u00ad.nitely often, thus, violating the compassion requirement \nC. We show the abstract transition program SUB-SKIP# on Figure 12. We compute SUB-SKIP# by applying the \nset of transition predicates below. P = {y> 0,y ' = y, y ' = y -1} The only non-well-founded abstract \ntransitions are T5 and T7. We show that according to Theorem 2, the well\u00adfoundedness of these two abstract \ntransitions is not needed local y : integer e0 : while y> 0 do 23 e1 a : y := y -1 e1 : 4 or 5 e1 b : \nskip t2 : y ' = y -1 t3 : y ' = y Figure 11: Program SUB-SKIP.  Figure12: Abstract-transitionprogram \nSUB-SKIP# . for proving compassionate termination. We show that the predicates comp(5,t2)and comp(7,t2)do \nnot hold. FromFigure12, we obtainthefollowingsets oftransitions. abc(L5)=abc(L7)= \\\\ abc( L5)= abc( L7)= \n{t1,t3} Furthermore, we observe (on Figure 11) that En(t2)= En(t3). Hence, the predicates comp(5,t2) \nand comp(7,t2) do not hold. 8. LEXICOGRAPHIC COMPLETENESS Our main interest is in fair termination. \nBut let us look also attermination. This allows usto comparethepower of transition predicate abstraction \nwith the classical means to construct termination arguments for programs with nested loops, which is \nthe lexicographic combination of ranking functions(see e.g. [21]). We showthat,if eachlexicographic component \nof a ranking functionfortheprogram canbe ex\u00adpressed by some conjunction of transition predicates in P, \nthentransitionpredicate abstraction will construct atermi\u00adnation argument for the program. The characterization \nof(plain) termination of aprogram P (namely, by the well-foundedness of the abstract tran\u00adsitions labeling \nthe nodes of the abstract-transition pro\u00adgram )is the instance of the characterization of fair ter- P# \nmination where the set of fair transitions to be empty. The programP terminatesif every non-root nodeinthe \nabstract\u00adtransition program P# is labeled by well-founded abstract transitions, formally .v . V- . well-founded(Tv). \nLet (f1,...,fn) be a tuple of functions from the set of statesSinto thedomains(W1, h1), ...,(Wn, hn)such \nthat hi is an ordering relation, i.e. transitive and irre.exive, for each 1 = i = n. The tuple(f1,...,fn)is \na lexicographic ranking function for theprogramP ifeach ordering hi is well-foundedandfor every transition \nt there exists an index j .{1,...,n}such that the auxiliary predicate lex(.t,j), de.ned as follows, holds. \nlex(R,j)= .(s,s ' ). R. fj(s)hj fj(s ' ). .1 = i <j. fi(s)Ci fi(s ' ) For each function fi we de.ne a \npair fi hi fi ' and fi Ci fi ' of transition predicates. '' ' fi hi fi = {(s,s )|fi(s)hi fi(s )} '' ' \nfi Ci fi = {(s,s )|fi(s)Ci fi(s )} Obviously, the transition predicate fi hi fi ' is well-founded. For \nexample, the function f(x,y)= x + y, where the variables x and y range over integers, into the set of \nnatu\u00adral numbersde.nes the transitionpredicates x + y>x ' + y ' and x + y = x ' +y ' . Theorem 3 (Lexicographic \nCompleteness). If the set TP # generated by the set of transition predicates P con\u00adtains the relation \nfi hf ' and the relation fi Ci f ' for every component fi of the lexicographic ranking function (f1,...,fn) \nfor the program P, then every non-root node of the abstract program P# obtained by transition predicate \nabstraction algorithm is labeled by a well-founded abstract transition. ii i Proof. Let the tuple (f1,...,fn) \nbe a lexicographic ranking function for the program P such that the transi\u00adtion predicates fi hi fi ' \nand fi Ci fi ' are contained in the set of abstract transitions TP # for each component fi of the tuple. \nWe prove for each non-root node v, by induction over the length of a shortest path from the root node \nv0 to the node v, that there exists an index j .{1,...,n}such that the predicate lex(Tv,j) holds. The \nwell-foundedness of Tv follows directly. For the base case, let t be the transition that labels the edge \nfrom the node v0 to the node v. Since lex(.t,j)holds for some j .{1,...,n}, we have .t . fj hj fj ' .TP \n# , .1 = i <j. .t . fi Ci fi ' .TP # . Since a is the best-abstraction function, we have a(.t). fj hj \nfj' , .1 = i <j. a(.t). fi Ci fi' . Hence, we conclude lex(Tv,j)where Tv = a(.t). For the induction step, \nlet u be a predecessor node of a non-root node v such that u is on a shortest path from v0 to v. Let \nthe predicate lex(Tu,j) hold for some index j .{1,...,n}. For a transition t thatlabelsthe edge(u,v) \nthere exists anindex l .{1,...,n}suchthat lex(.t,l)holds. Let m = min(j,l). We show that lex(a(Tv),m)holds. \nBy the induction hypothesis, we have Tu . fj hj fj ' and .1 = i <j. Tu . fi Ci fi' . From lex(.t,l)we \nhave .t . fl hl fl ' and .1 = k < l. .t . fk Ck fk' . By the transitivity of hi for 1 = i = n, we have \n' Tu ..t . fm hm fm, .1 = i< m.Tu ..t . fi Ci fi' . Analogously to thebase case, we conclude lex(Tv,m), \nwhere Tv = a(Tu ..t). The following example illustrates that transition predi\u00adcate abstraction may apply \nto programs whose termination cannot be proven by lexicographic ranking functions whose components are \ncontained in TP # . CHOICE. We consider the program CHOICE shown on Fig\u00adure 13. This program terminates. \nAs one can easily see, no lexicographic combination of the functions f1(x,y)= x, f2(x,y)= y, f3(x,y)= \nx +y is a ranking function for CHOICE. Executing the transition t1 may strictly increase the value of \ny and x + y, and ex\u00adecuting the transition t2 the value of x or y may increase. We compute the abstract-transition \nprogram CHOICE# , shown onFigure14, by taking thefollowing set of transition predicates. '' ' P = {x \n= x, x = x -1,x = y -2, ''' ' y = y, y = y -1,y = x +1,y = x} local x,y : natural 23 loop foreverdo 23 \n6 e a :(x,y):= (x -1,x) 7 67 44 or 55 e b :(x,y):= (y-2,x +1) x ' = x -1, x ' = y -2, t1 : t2 : y ' = \nx y ' = x +1 t1,t2 Figure 14: Abstract-transition program CHOICE# . Note that the set of abstract transition \nTP # induced by the transition predicates above contains the transition predi\u00adcates fi hi fi ' and fi \nCi fi ' for each i .{1, 2, 3} (and no other ranking functions.) We observe that every non-root node in \nCHOICE# is la\u00adbeled by a well-founded abstract transition, i.e., the pro\u00adgram CHOICE terminates. 9. CONCLUSION \nInthispaper, wehaveproposed theextensionofpredicate abstraction to transition predicate abstraction as \na way to overcome the inherent limitation of predicate abstraction to safety properties. Previously, \nthe only known way to overcome this limitation was to annotate the .nite-state ab\u00adstraction of aprogramin \naprocess thatinvolved the manual constructionof rankingfunctions. Wehavegonebeyond the idea of abstracting \na program to a .nite-state program and checking the absence of loops in its .nite graph. Instead, we \nhave given the transformation of a program into a .nite abstract-transition program. We have given algorithms \nto check fair termination on the abstract-transition program. The two algorithms togetheryield an automated \nmethodfor the veri.cation of liveness properties under full fairness as\u00adsumptions(justice and compassion). \nIn conclusion, wehave exhibited principles that extend the applicability of predi\u00adcate abstraction-basedprogramveri.cationtothefull \nset of temporal properties. We believe that our work may trigger a series of activities to develop tools \nfor checking liveness, similar to the series of activities that have lead to the success of tools for \nsafety and invariance properties[2, 6, 14, 15, 30]. The logical next step is to investigate counterexample\u00addriven \nabstraction re.nement[2,7,15]. We extractedtran\u00adsitionpredicatesfromguards(whichyieldsthe special case \nof assertions such as x> 0, i.e. without primed variables) and from update statements x:=e (which yields \ntransition predicates of the form x ' = e and x ' = e). Although this was su.cient for our experiments \nso far, an automated counterexample-driven abstraction re.nement will be desir\u00adable at some point. A \ncounterexample will here be a rela\u00adtion t1 . ... . tn corresponding to a path in the graph of an abstract-transition \nprogram, a path that leads to a fair non-terminating node. Anotherdirectionforfuture workis toinvestigate \nwhether the existing techniques to speed up predicate abstraction, e.g. [3, 13, 18], are applicable for \ntransition predicate ab\u00adstraction. Our algorithm suggests a veri.cation methodology where theinput to \nthe algorithmis alivenessproperty withoutfair\u00adness assumptions. One then takes the computed abstract\u00adtransition \nprogram and its node labeling ( terminating or not) to derive what fairness assumptions are required \nfor the liveness property to hold. It should be possible to auto\u00admate this derivation step. Acknowledgment. \nWe thank Bruno Blanchet, Bernd Finkbeiner, and Alexan\u00adder Malkis for comments and suggestions. 10. REFERENCES \n[1] T. Ball. A theory of predicate-complete test coverage and generation. In FMCO 2004: Symp. on Formal \nMethods for Components and Objects, LNCS. Springer, 2004. To appear. [2] T. Ball, R. Majumdar, T. Millstein, \nand S. Rajamani. Automatic predicate abstraction of C programs. In PLDI 2001: Programming Language Design \nand Implementation, volume 36 of ACM SIGPLAN Notices, pages 203 213. ACM Press, 2001. [3] T. Ball, A. \nPodelski, and S. K. Rajamani. Boolean and cartesian abstractions for model checking C programs. In TACAS \n2001: Tools and Algorithms for the Construction and Analysis of Systems, volume 2031 of LNCS, pages 268 \n283. Springer, 2001. [4] F. Bourdoncle. Abstract debugging of higher-order imperative languages. In PLDI \n1993: Programming Language Design and Implementation, pages 46 55. ACM Press, 1993. [5] I. Browne, Z. \nManna, and H. Sipma. Generalized veri.cation diagrams. In FSTTCS 1995: Foundations of Software Technology \nand Theoretical Computer Science, volume 1026 of LNCS, pages 484 498. Springer, 1995. [6] S. Chaki, E. \nClarke, A. Groce, S. Jha, and H. Veith. Modular veri.cation of software components in C. In ICSE 2003: \nInt. Conf. on Software Engineering, pages 385 395, 2003. [7] E. M. Clarke, O. Grumberg, S. Jha, Y. Lu, \nand H. Veith. Counterexample-guided abstraction re.nement. In CAV 2000: Computer Aided Veri.cation, volume \n1855 of LNCS, pages 154 169. Springer, 2000. [8] M. Col\u00b4on and H. Sipma. Synthesis of linear ranking \nfunctions. In TACAS 2001: Tools and Algorithms for the Construction and Analysis of Systems, volume 2031 \nof LNCS, pages 67 81. Springer, 2001. [9] M. Col\u00b4on and T. Uribe. Generating .nite-state abstractions \nof reactive systems using decision procedures. In CAV 1998: Computer Aided Veri.cation, volume 1427 of \nLNCS, pages 293 304. Springer, 1998. [10] P. Cousot and R. Cousot. Abstract interpretation: a uni.ed \nlattice model for static analysis of programs by construction or approximation of .xpoints. In POPL 1977: \nPrinciples of Programming Languages, pages 238 252. ACM Press, 1977. [11] P. Cousot and R. Cousot. Higher-order \nabstract interpretation(and applicationto comportment analysis generalizing strictness, termination, \nprojection and PER analysis of functional languages). In ICCL 1994: Int. Conf. on Computer Languages, \npages 95 112. IEEE, 1994. [12] G. Delzanno and A. Podelski. Constraint-based deductive model checking. \nInt. Journal on Software Tools for Technology Transfer(STTT), 2000. [13] C.Flanagan andS.Qadeer.Predicate \nabstractionfor software veri.cation. In POPL 2002: Principles of Programming Languages, pages 191 202. \nACM Press, 2002. [14] S. Graf and H. Sa\u00a8idi. Construction of abstract state graphs with PVS. In CAV 1997: \nComputer Aided Veri.cation, volume 1254 of LNCS, pages 72 83. Springer, 1997. [15] T. Henzinger, R. Jhala, \nR. Majumdar, and G. Sutre. Lazy abstraction. In POPL 2002: Principles of Programming Languages, pages \n58 70. ACM Press, 2002. [16] Y. Kesten and A. Pnueli. Veri.cation by augmented .nitary abstraction. Information \nand Computation, a special issue on Compositionality, 163(1):203 243, 2000. [17] Y. Kesten, A. Pnueli, \nand M. Y. Vardi. Veri.cation by augmented abstraction: The automata-theoretic view. Journal of Computer \nand System Sciences, 62(4):668 690, 2001. [18] S. K. Lahiri, R. E. Bryant, and B. Cook. A symbolic approach \nto predicate abstraction. In CAV 2003: Computer Aided Veri.cation, volume 2725 of LNCS, pages 141 153. \nSpringer, 2003. [19] C. S. Lee, N. D. Jones, and A. M. Ben-Amram. The size-change principle for program \ntermination. In POPL 2001: Principles of Programming Languages, volume 36, 3 of ACM SIGPLAN Notices, \npages 81 92. ACM Press, 2001. [20] Z. Manna and A. Pnueli. Temporal veri.cation of reactive systems: \nSafety. Springer, 1995. [21] Z. Manna and A. Pnueli. Temporal veri.cation of reactive systems: Progress. \nDraft, 1996. [22] A. Pnueli, J. Xu, and L. Zuck. Liveness with (0, 1, 8)-counter abstraction. InCAV 2002: \nComputer Aided Veri.cation, volume 2404 of LNCS, pages 107 122. Springer, 2002. [23] A. Podelski and \nA. Rybalchenko. A complete method for the synthesis of linear ranking functions. In VMCAI 2004: Veri.cation, \nModel Checking, and Abstract Interpretation, volume 2937 of LNCS, pages 239 251. Springer, 2004. [24] \nA. Podelski and A. Rybalchenko. Transition invariants. In LICS 2004: Logic in Computer Science, pages \n32 41. IEEE, 2004. [25] F. P. Ramsey. On a problem of formal logic. In Proc. London Math. Soc., volume \n30, pages 264 285, 1930. [26] H. Sipma, T. Uribe, and Z. Manna. Deductive model checking. In CAV 1996: \nComputer Aided Veri.cation, volume 1102 of LNCS, pages 208 219. Springer, 1996. [27] A. Tiwari. Termination \nof linear programs. In CAV 2004: Computer Aided Veri.cation, volume 3114 of LNCS, pages 70 82. Springer, \n2004. [28] T. Uribe. Abstraction-Based Deductive-Algorithmic Veri.cation of Reactive Systems. PhD thesis, \nStanford University, 1999. [29] M. Y. Vardi. Veri.cation of concurrent programs the automata-theoretic \nframework. Annals of Pure and Applied Logic, 51:79 98, 1991. [30] E. Yahav. Verifying safety properties \nof concurrent Java programs using 3-valued logic. In POPL 2001: Principles of Programming Languages, \npages 27 40. ACM Press, 2001. [31] E. Yahav, T. Reps, M. Sagiv, and R. Wilhelm. Verifying temporal heap \nproperties speci.ed via evolution logic. In ESOP 2003: European Symp. on Programming, volume 2618 of \nLNCS, pages 204 222. Springer, 2003. APPENDIX  A. ENABLEDNESS ASSUMPTIONS For completeness, we give \nthe syntactic transformation for Assumptions 2 and 2 (which we extended to the com\u00adpassionate transitions). \nWe replace every fair transition t .J.C by a set of transitions obtained as follows. For each bit-vector \nover the enabledness sets of transitions T \\{t}we create a new tran\u00adsition with the transition relation \nobtainedfrom .t byinter\u00adsectingitsenabledness set En(t)with the setde.nedby the bit-vector. The following \nconditions hold for the transition relations and the enabledness sets obtained by splitting the transition \nt into the set of transitions {t1,...,tn}. En(t)= En(t1)\u00b7\u00b7\u00b7 En(tn) (3a) .t = .t1 \u00b7\u00b7\u00b7 .tn (3b) The set \nof just (compassionate) transitions J (C) of the program is modi.ed by replacing t by the set {t1,...,tn}. \nWe show that the above modi.cation preserves the fair termination property. Lemma 2. The program P withthe \nset ofjusttransitions J justly terminates if it justly terminates after replacing eachjusttransitionby \nthe set of transitions satisfying Equa\u00adtion (3). Proof. Assume that there exists an in.nite computa\u00adtion \ns = s1,s2,... of the original program that satis.es the justice requirement J. Since partitioning does \nnot make the transition relation of the program smaller, see Equa\u00adtion(3b), s is a computation of the \nmodi.ed program. We show that for every t .J replaced by the set of tran\u00adsitions {t1,...,tn}, the computation \ns satis.es thejustice requirement for each ti, where 1 = i = n. If t is disabled in.nitely often then \neach of ti, for 1 = i = n, is disabled in.nitely often. If t is continually enabled, and, hence, in.nitely \noften taken, we consider the following two cases. We assume that there exists an enabledness set En(tj)for \nsome 1 = j = n such that s eventually does not leave the set En(tj), formally, .1 = j = n .k = 1 .l = \nk. sl . En(tj). Every transition ti, where 1 = i = j = n, is not continu\u00adally enabled, by Assumption \n2. The transition tj is taken in.nitely often, by Assumption 1. If the assumption above does not hold, \nthen none of the transitions ti, for 1 = i = n, is continually enabled. Lemma 3. The program P with the \nset of compassionate transitions C compassionately terminates if it compassion\u00adately terminates after \nreplacing each compassionate transi\u00adtion by the set of transitions satisfying Equation (3). Proof. Assume \nthat there exists anin.nite computation s = s1,s2,... of the originalprogram that satis.es the com\u00adpassion \nrequirement C. Since partitioning does not make the transition relation of the program smaller, see Equa\u00adtion(3b), \ns is a computation of the modi.ed program. We show that for each t .C replaced by the set of transi\u00adtions \n{t1,...,tn}, the computation s satis.es the compas\u00adsion requirement for each ti, where 1 = i = n. If \nt is not enabled in.nitely often then each of ti, for 1 = i = n, is not enabled in.nitely often. If t \nis enabled often, and, hence, in.nitely often taken, we consider the following two cases. For each 1 \n= j = n such that En(tj) is visited in.nitely often,byAssumptions1 and2(extendedto compassionate transitions), \nthe transition tj is taken in.nitely often. All other transitions are not enabled in.nitely often.  \n \n\t\t\t", "proc_id": "1040305", "abstract": "Predicate abstraction is the basis of many program verification tools. Until now, the only known way to overcome the inherent limitation of predicate abstraction to safety properties was to manually annotate the finite-state abstraction of a program. We extend predicate abstraction to <i>transition predicate</i> abstraction. Transition predicate abstraction goes beyond the idea of finite <i>abstract-state</i> programs (and checking the absence of loops). Instead, our abstraction algorithm transforms a program into a finite <i>abstract-transition</i> program. Then, a second algorithm checks fair termination. The two algorithms together yield an automated method for the verification of liveness properties under full fairness assumptions (justice and compassion). In summary, we exhibit principles that extend the applicability of predicate abstraction-based program verification to the full set of temporal properties.", "authors": [{"name": "Andreas Podelski", "author_profile_id": "81100130920", "affiliation": "Max-Planck-Institut f&#252;r Informatik, Saarbr&#252;cken, Germany", "person_id": "PP14056587", "email_address": "", "orcid_id": ""}, {"name": "Andrey Rybalchenko", "author_profile_id": "81100483883", "affiliation": "Max-Planck-Institut f&#252;r Informatik, Saarbr&#252;cken, Germany", "person_id": "P688961", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1040305.1040317", "year": "2005", "article_id": "1040317", "conference": "POPL", "title": "Transition predicate abstraction and fair termination", "url": "http://dl.acm.org/citation.cfm?id=1040317"}