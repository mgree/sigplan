{"article_publication_date": "01-12-2005", "fulltext": "\n Permission Accounting in Separation Logic Richard Bornat School of Computing Science Middlesex University \nLONDON N17 8HR, UK R.Bornat@mdx.ac.uk Peter O Hearn Department of Computer Science Queen Mary, University \nof London LONDON E1 4NS, UK  ohearn@dcs.qmul.ac.uk ABSTRACT A lightweight logical approach to race-free \nsharing of heap storage between concurrent threads is described, based on the notion of permission to \naccess. Transfer of permission between threads, subdivision and combination of permission is discussed. \nThe roots of the approach are in Boyland s [3] demonstration of the utility of fractional permissions \nin specifying non-interference between concurrent threads. We add the notion of counting permission, \nwhich mirrors the programming technique called permission counting. Both fractional and counting permissions \npermit passivity, the speci.cation that a program can be permitted to access a heap cell yet prevented \nfrom altering it. Models of both mechanisms are described. The use of two di.erent mech\u00adanisms is defended. \nSome interesting problems are acknow\u00adledged and some intriguing possibilities for future develop\u00adment, \nincluding the notion of resourcing as a step beyond typing, are paraded. Categories and Subject Descriptors \nD.2.4 [Software/Program veri.cation]: Correctness proofs, Formal methods, Validation; F.3.1 [Specifying \nand Verifying and Reasoning about Programs]: Logics of programs General Terms Languages, theory, veri.cation \n Keywords separation, logic, concurrency, permissions Permission to make digital or hard copies of all \nor part of this work for personal or classroom use is granted without fee provided that copies are not \nmade or distributed for pro.t or commercial advantage and that copies bear this notice and the full citation \non the .rst page. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires \nprior speci.c permission and/or a fee. POPL 05, January 12 14, 2005, Long Beach, California, USA. Copyright \n2005 ACM 1-58113-830-X/05/0001 ...$5.00. Cristiano Calcagno Department of Computing Imperial College, \nUniversity of London LONDON SW7 2AZ, UK  ccris@doc.ic.ac.uk Matthew Parkinson Computer Laboratory University \nof Cambridge CAMBRIDGE CB3 0FD, UK  mjp41@cl.cam.ac.uk  1. BACKGROUND Separation logic has its roots \nin the observation by Burstall in 1972 [7] that separate program texts which work on separate sections \nof the store can be reasoned about in\u00addependently. Reynolds, O Hearn and Yang [20, 19, 14] and others \ndeveloped the logic to describe mutation of the heap based on a notion of separate locations. In logical \nterms it s a particular model of BI [17, 18], but in programming terms it s a really cool hack with Hoare \nlogic, making earlier at\u00adtempts to prove pointer-mutating programs (see [1] for ref\u00aderences) look ridiculously \ncomplicated and ad-hoc. Small but intricate graph-manipulating programs can be speci.ed and proved with \nrelatively little fuss [2]. The ambitions of the separation logic community extend far beyond the description \nof graph-mutating programs. The aim all along was to understand, specify and prove proper\u00adties of fundamental \nprograms, for example operating sys\u00adtems, written in low-level languages and running without support \non naked hardware. That requires an attack, .rst of all, on the problems of concurrency (and, of course, \nthere will be many more problems to come: it s too early to storm the walls yet). O Hearn has shown [15] \nthat separation logic can describe ownership transfer, where concurrent program threads move ownership \nof heap cells into and out of shared resources which can be semaphores, conditional critical regions \nor monitors. Breakthrough though it is, this isn t enough by itself. Separation logic deals with separation: \nexclusive own\u00adership by one side or another of each heap cell. In prac\u00adtice heap cells, like variables \nin Dijkstra s original descrip\u00adtions [9], can safely be shared between concurrent threads provided they \nall promise only to read, never to write. This has echoes of the notion of passivity which appears to \nbe necessary in a separation-logic treatment of sequential pro\u00adgrams: we have to be able to say that \na program has read access to a heap cell but doesn t have the right to change it. The invention of ownership \ntransfer began a change in the way that separation logic assertions are read. The basic assertion N . \nE, pronounced N points to E, is a predicate of a heap asserting that it consists of a single cell with \ninteger address N and integer contents E. It can equally be read as a permission asserting the right \nto read, write or dispose READERS WRITER P(m); count := count + 1; if count = 1 then P(write); V(m); \nP(write); ... reading happens here ...; ... writing happens here ... P(m); count := count - 1; if count \n= 0 then V(write); V(write) V(m) Figure 1: Readers and writers (from [8], with shortened names) that \nparticular cell. It s the permission rather than the cell that is transferred between threads in an ownership \ntransfer. The basic assertion emp is a predicate that the heap has no cells; as a permission it means \nwithout permission to access any cell . Nothing changes semantically, but for many programmers the permission \nreading of separation logic is easier to grasp than the predicate version. Viewing ownership as total \nread/write/dispose permission makes it possible to begin to see how heap cells might be shared. A total \npermission can be split into as many read\u00adonly permissions as needed and shared around as necessary. \nGiving a read-only permission surely ought to guarantee passivity (as it does, as we shall see). The \nonly problem is in gathering them back in. How many read permissions make a total permission? Clearly, \nyou need them all but how many is all? (Answer: it depends how many you made when you started.) What \nif some of the read permissions we handed out were split by their recipients? (Answer: if they do that, \nthen either you have to know about it or they have to put them back together before handing them in.) \nHow can you keep account? You surely need to keep account. Suppose there is a pro\u00adgram which has total \nownership of cell N, and which tempor\u00adarily splits into two threads which concurrently read N but don \nt write to it or transfer it elsewhere. After the threads recombine, you can harvest the permissions \nyou gave them. Now the program must have total access once more: if not, where has the permission gone? \nTo lose permissions is to leak resource; accurate accounting is essential. It s the need for permission \naccounting which constrains the treatment of permissions in separation logic. You have to measure them \nout, and you have to measure them all back in. The design choices are all about simplicity and convenience \nof di.erent kinds of measurement. There are several oddities about permission accounting as we currently \nunderstand it. One is immediately obvious: there are at least two alternative accounting mechanisms. \nAnother is that it is proving di.cult to extend the treat\u00adment of heap cells to recursively-de.ned data \nstructures. Finally, exploration of permissions has clearly exposed a deeper problem in the treatment \nof variables as resource. Nevertheless we have come a considerable distance in the quantity as well as \nthe kind of resource that is supplied to a program or command must be described and veri.ed. My intention \nis to discover the principles of resourcing by exploring resource properties of programs that can be \nspe\u00adci.ed and veri.ed. Proof-theoretic exploration is dangerous: you can go far out on very thin ice, \nand if it s unsound you get very cold and wet. On the other hand, sound but unex\u00adplored logics don t \nnecessarily make useful reasoning tools. Surely there s room in our subject for those who experiment \nproof-theoretically as well as those who deal in certainty. I m interested in proof; I believe that it \ns worth trying to .nd logics that look so obviously useful that they deserve a soundness proof. Soundness \nmatters, though, even to me. In this work I haven t gone very far from land: soundness, I hope and ex\u00adpect, \nwill be a matter of building small bridges to previous work, dotting is and crossing ts. In the meantime \nI m search\u00ading for nice proofs : proofs that can be understood, concise proofs, proofs you can read. \nI m hoping to prove programs that people already think they understand but which don t yet have satisfying \nproofs. I m aiming, in the end, for proofs that a compiler could follow and, if I m allowed to dream, \nproofs that a compiler could guess.  2. A PROGRAM IN NEED OF RESOURCING The readers and writers algorithm \nof Courtois et al. [8], shown in .gure 1, allows multiple readers concurrent access to a shared variable, \nbut restricts writers to exclusive access. It would be possible to read the algorithm as a description \nof two parallel processes, but it is far more concurrent than that. There are various components which \ncan be executed concurrently, with varying degrees of mutual exclusion: the four uses of the binary \nmutex m;  the reader prologue count := count +1...;  the reader action section;  the reader epilogue \ncount := count - 1...;  eight months since we .rst heard Boyland s laconic hint 1 2 + the two uses \nof the binary mutex write; 1 2 = 1 . I hope that we are blazing a trail towards the goal of resourcing, \na step beyond program typing in which the the writer action section. A resourcing of this program must \nexplain how that con\u00adcurrency is controlled. Further, it must explain how use of variable count is restricted \nto reader prologue and epilogue. All of these resourcing questions are addressed below. I have answers \nto all but the dynamic restriction of the scope of count applied by use of the mutex m (and in that case \nwe can provide an explanation of an alternative version of the program).  3. BASICS I give a brief description \nof separation logic. A more care\u00adful treatment, particularly of critical regions and resource bundles, \nis in [15] and [6], where there is also a discussion of the relation to earlier work on concurrency. \nIn the original model of separation logic a heap is a partial map from addresses to values. The simplest \nheaps are the empty heap emp and the singleton heap with address E and content E', written as E . E'. \nWe write E . as a shorthand for .v\u00b7E . v. Two heaps can be combined, using multiplicative conjunction \n(*) i. their (address) domains are disjoint. The frame property (section 11.3) of separation logic re\u00adquires \nthat if a program doesn t go wrong in a particular stack/heap con.guration s, h, then it will not go \nwrong in a larger con.guration s, (h*h'); its e.ect will still be to change h, leaving the added heap \nh' completely una.ected. As a result, separation is policed and exploited by the frame rule {Q}C{R} (modi.es \nC n vars P = \u00d8) {P *Q}C{P *R} (1) if C can t modify the variables of P , and if the heap it ma\u00adnipulates \nis disjoint from that of P , then we can reason about C and its e.ects separately from P . The side-condition \nis required because separation logic deals only with separation of heap cells, not (stack) variables. \n The language that separation logic treats includes new and dispose, abstractions of similar Pascal or \nC library prim\u00aditives. new is a heap creator it makes a singleton heap  and dispose a matching heap \ndestroyer. In the simplest version of the language we don t care what value is in the heap that new creates \nor dispose destroys. Writing E for a pure expression one which doesn t involve heap access we have: \n {emp} x := new() {x .}{E .} dispose E {emp} (2) There is absolutely no way to make a heap other than \nwith new, or to destroy one other than with dispose.1 To make the frame rule work, we know that new has \nto be magic, in the sense of program re.nement: it must always return an address which is disjoint from \nthe domain of any heap in use at the time. Of course this is easy to implement using a list of locations \nnot yet handed out to the program, so it s really only stage magic. Addresses received from new are integers, \nbut all a pro\u00adgram can do with with the heap via an address is to access 1The axioms in (2) allocate \nand dispose a single cell, for simplicity. Axioms which deal with any particular record size are possible. \nA treatment which deals with computable record sizes, unrecorded by the program but tracked by the speci.cation \n that is, a treatment of C s malloc and free is one aim of the work reported here. or modify the addressed \nvalue. Writing [ ] for heap access, we recognise three forms of assignment: {Rx E } x:=E {R}{E' .} [E']:=E \n{E' . E} (3) {E' . E} x:=[E'] {E' . E . x = E} The use of conventional Hoare logic in the .rst assignment \naxiom gives rise to the proviso in the frame rule. I d love to get rid of that condition, but as you \nshall see (section 13.2) that isn t easy. The other two axioms are presented as forward reasoning steps \n(backward versions, using BI s magic wand operator -* are possible, but I don t give them here). The \nlast rule, as a forward step, requires a side-condition that x does not occur free in E or E'. 3.1 Concurrency \nSince Dijkstra [9] the description of safe concurrency has been based on a separation of variables into \ndistinct groups: read/write variables unique to each thread;  read-only variables shared between threads; \n read/write shared variables accessible only in mutually-exclusive critical sections of program code. \n Other treatments conditional critical regions, monitors have provided alternative linguistic expression \nof the same fundamental notion. Our approach is in the same tradition, but treating heap locations rather \nthan variables. The concurrency rule {Q1} C1 {R1}\u00b7\u00b7\u00b7{Qn} Cn {Rn} {Q1 * \u00b7\u00b7\u00b7 *Qn}(C1 \u00b7 \u00b7\u00b7 Cn){R1 * \u00b7\u00b7\u00b7 \n*Rn} (4) describes how concurrent threads with *-separable heap re\u00adsources can be treated separately. \nThe side-condition, which guarantees non-interference of variables, is that no variable free in Qi or \nis modi.ed in Cj when j i. It is re- Ri = markable that such a simple rule is possible in our logic. \nIt holds out the promise that we might specify and verify zero-execution-cost barriers between threads. \nAs a concurrent program executes, heap resources must remain separated but the separation need not be \n.xed: own\u00adership can be transferred between threads. Following [13] our treatment is based on conditional \ncritical regions. A conditional critical region (CCR) [11] is a command with b when G do C od where b \nis a resource-bundle name. 2 A bundle, like a thread, may possess its own private read/write variables; \nthe boolean G and the command C in a CCR command may refer to these variables. Execution of a CCR is \nin mu\u00adtual exclusion with all other CCRs for the same bundle. It proceeds, rather like a monitor procedure \nexecution, as fol\u00adlows: 2Hoare called resource bundles simply resources, but I want that word to apply \nto the items heap locations and vari\u00adables at least, perhaps time and stack space and whatever else \nwe can manage and the permissions that are owned by, shared between or transferred between the threads \nof a concurrent program. A resource bundle contains a bundle of resources described by an invariant formula \n hence the nomenclature. Bundle b : Vars full, buf ; buf := false; Invariant if full then buf . else \nemp . 1 0 BBBBBBBBBBBBBBBBBBBBBBBBBBB@ {emp} x := new() {x .} with b when \u00acfull do {(x . * if full \nthen buf . else emp .) .\u00acfull} . {x . * emp} . {x .} buf := x {x .. buf = x} full := true {full . x \n.. buf = x} . {full . buf .} . {if full then buf . else emp . . full} . {if full then buf . else emp \n.} . {emp * if full then buf . else emp .} od {emp} {emp} with b when full do {(emp * if full then \nbuf . else emp .) . full} . {emp * buf .} . {buf .} y := buf {buf .. y = buf } full := false {\u00acfull \n. y .} . {y . * (\u00acfull . emp)} . {y . * (\u00acfull . if full then buf . else emp .)} . {y . * if full then \nbuf . else emp .)}od {y .}dispose y {emp} CCCCCCCCCCCCCCCCCCCCCCCCCCCA Figure 2: Ownership transfer \nbetween concurrent threads using CCR commands 1. acquire bundle b; 4. OWNERSHIP 2. evaluate the boolean \nguard G; 3. if G is true, execute the command C and release b; 4. if G is false, release b and try \nagain.  Following [15], a mutex semaphore m is a bundle whose CCRs are either P: with m when m = 0 \ndo m :=0od, or V: with m when true do m := 1 od. A counting semaphore c is similar, but with commands \nc := c - 1 and c := c + 1. This is much more than a convenient equivalence: it inverts the normal treatment \nof semaphores, converting them from (negative) locks keeping you out to (positive) stores of resource \nthat you can use. In our treatment each bundle must have an invariant for\u00admula describing its resources \nin terms of its private variables, (*)-separated from each other and from the resource of any thread \nin a version of the concurrency rule. If the resource of bundle b is described by invariant Ib, the conditional \ncritical region rule is {(Q*Ib) . G}C{R*Ib} {Q}with b when G do C od{R} (5) The non-interference side \ncondition is that processes cannot refer to variables of the bundle outside a CCR command. This approach \nhas been proved sound by Brookes in [6]: the result is that given invariant formulae for each bundle \nand (*)-separation of bundle resources from each other and from thread resources, we can reason sequentially \nabout each thread and the CCRs it employs. Brookes s semantics allows threads to share read-only variables \nand locations: I shall return to that point. O Hearn, in [13], gave an alternative reading of E . E ' \nas expressing ownership of a heap location. He used the con\u00additional critical region rule to transfer \nownership between threads. Figure 2 shows his example with assertions of own\u00adership. For separation logic \nusers, O Hearn s alternative reading of the . relation was a breakthrough, a liberation. But we needed \nhelp to take the next step towards permission accounting and shareable resource.  5. FRACTIONAL PERMISSIONS \nIn order to reason about non-interference of concurrent threads, Boyland [3] associates a rational z \nwith each stack variable and heap location. Like Brookes, he distinguishes total control (dispose, read \nand write permission) from shared access (read only: no thread can write or dispose). z = 1 gives exclusive \nownership and total control; 0 <z< 1 allows shared access. This enabled him to describe the al\u00adlocation \nof memory access rights to threads. He proved the determinacy of disjoint concurrency with shared read \naccess. He pointed out, correctly, that separation logic couldn t match this: the concurrency rule only \ndeals with exclusive access. He suggested, however, that separation logic might be modi.ed to include \nthe equivalent of P . .P * (1 - .)P and thus be able to deal with shared heaps. Boyland s suggestion \nturns out to deal very nicely with fork-join programs where permission splitting and combin\u00ading is part \nof the program structure. Fractional permission accounting, like program typing, is a compile-time discip\u00adline. \nThe program does nothing to support the accounting: everything happens in the speci.cations and the proof. \nThe magnitude of non-integral fractions don t seem to matter: a program can do exactly as well with 0.1 \nas with 0.9 (but see section 13.1). Those who, like me, would hesitate before mixing rational arithmetic \nand logic need not be scared of its use in per\u00admission accounting. The complexity of the arithmetic de\u00adductions \nis only that required by a particular speci.cation: READERS with read when true do if count = 0 then \nP(write) else skip .; count +:= 1 od; ... reading happens here ...; with read when count > 0 do count \n-:= 1; if count = 0 then V(write) else skip . od WRITER P(write); ... writing happens here ... V(write) \n Figure 3: Readers and writers: CCR version typically, no more than observing that z +z ' = z ' +z or \nthat two halves make a one. Fractions seem to be more conveni\u00adent to use than history-based mechanisms \nlike sets of binary trees.  6. COUNTING PERMISSIONS Not every program is suitable for fractional permission \naccounting. Programs which keep a semaphore-protected count of the number of permissions handed out need \nan alternative treatment. A famous example is the readers\u00adand-writers problem; another example is pipeline \nprocessing where permission to access a bu.er is passed from an origin\u00adator thread to a number of assistants, \nany of which may pass it on further, and eventually dispose the permission without the originator s involvement. \nTo deal with permission counting we have counting per\u00admissions. A central permissions authority holds \na source permission, annotated with the number of read permissions that have been split o. from it; the \nsplit-o. read permis\u00adsions can t be split further; only a source with no split-o. children gives total \nread/write/dispose ownership. An ana\u00adlogy is Neolithic .int knapping: arrowheads were split from a stone \nthat remained capable of providing more of the same. In principle the arrowheads could be re-attached \nto re-create the original stone. Permission counting is not reference counting: it has noth\u00ading to do \nwith reachability. The number of permissions can be many fewer than the number of reachable pointers. \n(Sep\u00adaration logic embraces the dangling pointer, yet again!)  7. FRACTIONAL PERMISSIONS IN DETAIL We \nmodify the model of separation logic (see section 10 for more detail). A heap is now a partial map from \naddresses to values with permissions. We use Boyland s [3] numerical scheme: a permission is z, where \n0 <z = 1; z = 1 allows dispose, write and read; any other value is read access only. We annotate the \n. relation to show the level of permission it carries: x -. E =0 <z = 1 z . (6) Heaps can be combined \nwith (*) i., where their addresses coincide, they agree on values and their permissions combine arithmetically. \nReading in the other direction, an existing {emp} x := new(); {x -.} 1 [x] := 7; {x -.7} . {x - -. 7 \n*x - -. 7} 10.50.5 0 1 {x - -. 7} {x - -. 7} @ 0.5 0.5 y := [x] - 1 z := [x]+1 A ; {x - -. 7 . y =6} \n{x - -. 7 . z =8} 0.5 0.5 {x - -. 7 *x - -. 7 . y =6 . z =8} . 0.50.5 {x -.7 . y =6 . z =8} 1 dispose \nx; {emp . y =6 . z =8} Figure 4: Fractions are easy permission can always be split in two. x -. z E*x \n- . .. x - --.7 E . z> 0 . z ' > 0 (7) 7 E zz+z We require positive z and z ' to avoid silly nonsense \nlike 2 * -1 .. 1: otherwise, the fractions we choose are arbitrary, an aide-memoire for future recombination. \nReasoning about their magnitudes would seem to be like reasoning about the identity of the names we use \nfor the parameters of a theorem. new and dispose deal only in full permissions: {emp} x := new() {x -.} \n1 {E -.} dispose E {emp} (8) 1 Assignment needs full access for writing, any access at all for reading: \n{Rx E } x:=E {R}{x -.} [x]:=E {x -.E} 11 (9) {E ' -. E} x:=[E ' ] {E ' -. E . x = E ' } z z (the side-condition \non the last rule is once again x not free in E or E ' ). It s then completely straightforward to check \nthe correctness of the program in .gure 4, in which parallel threads require simultaneous read access \nto location [x]. Most fractional problems are as simple as this. It really is that easy. Section 9 discusses \na larger example. 7.1 Passivity Passivity is a property of a command which has access to a heap cell \nbut leaves it unchanged. Any fractional permission less than 1 prescribes passivity, by the following \nargument. {emp} P(write): {y {y 0 BBBB@ 1 CCCCA 0 -. .) . write =1} . 0 {(emp *y write := 0 {(emp * \nif write = 0 then emp else y -. ) . write =1} 0 -. * (emp . write = 0)} . -. * (if write = 0 then emp \nelse y 0 -0 . . . write = 0)} 0 {y -. } 0 {y -. } V(write): {y {y {emp * (y 0 BBBB@ 00 -. * if write \n= 0 then emp else y -. .} . -. 1 CCCCA 0 * (emp . write = 0)}write := 1 0 -. . write = 1)} . {emp * \n(if write = 0 then emp else y -0 . . . write = 1)} {emp} Figure 5: Proof of pre-and post-condition of \nP(write) and V(write) Commands in our language obey the frame property. In the sequential sub-language \nthey also display termination monotonicity (section 11.3): if a command terminates in a particular heap, \nthen it terminates in any larger heap. Suppose that C is a command which is given fractional per\u00admission \nto access cell 10, and which manages to change that cell somehow say to increase its value. That is, \nit obeys {10 - -. N}C{10 - -. N +1} 0.50.5 and it terminates. It must therefore terminate in any larger \nheap. Using the frame rule you can show {10 - -. N* 10 - -. N}C{10 - -. N* 10 - -. N +1} 0.50.50.50.5 \nbut the postcondition is false, so C can t terminate in the larger heap, so it can t be a command of \nthe sequential sub\u00adlanguage since it doesn t exhibit termination monotonicity. That proof, and its conclusion, \nmust be treated with care in the non-sequential case, because a command can apply to a bundle for additional \nresource. Suppose Ib = 10 - -. 0.5 C = with b when true do [10] := 3 od then you can show with the CCR \nrule that {10 - -. 2}C{10 - -. 3} 0.50.5 Using the frame rule you can prove {10 - -. 2 * 10 - -. 2}C{10 \n- -. 2 * 10 - -. 3} 0.50.50.50.5 But the proof is useless, because to use this triple in parallel with \nthe resource bundle b the conclusion of the concurrency rule must be {Ib * 10 - -. 2 * 10 - -. 2}C{Ib \n* 10 - -. 2 * 10 - -. 3} 0.50.50.50.5 The precondition is false; there is no such heap; the conclu\u00adsion \nis vacuous. In practice you can constrain a command to passivity by passing it only a proportion of the \npermission you hold. Then it cannot possibly acquire a total permission from any\u00adwhere, and you can be \nsure of its passivity.  8. COUNTING PERMISSIONS IN DETAIL To model permission counting we have to distinguish \nbetween the source permission , from which read permis\u00adsions are taken, and the read permissions themselves. \nWe also have to distinguish a total permission from one which lacks some split-o. parts. 0 A total permission \nis written E -. E ' . A source from n' which n read permissions have been split is written E - . E . \nA read permission is written E . E ' . 3 . E ' nn+1' E - n. n = 0 (10) E - . E ' . n = 0 .. E - --. \nE *E . E ' The assignment and new/dispose axioms are very like (8). 0 Only a total permission, E -. E \n' , allows write and dispose. 0 {emp} x:=new(E) {x -. E} 0 {E ' -. } dispose E ' {emp}{Rx x:=E (11) E}{R} \n00 {E ' -. } [E ' ]:=E {E ' -. E} {E ' . E} x:=[E ' ] {E ' . E . x = E} Read permissions (.) guarantee \npassivity in just the same way as non-integral fractional permissions. 8.1 A counting permission example \nI can t yet treat the original version of the readers-and\u00adwriters algorithm because I can t yet deal \nformally with per\u00admission to access stack variables (see section 13.2). I can deal with it,though, if \nI transform the readers prologue and epilogue, both mutex-protected critical sections, into CCRs, as \nshown in .gure 3. I ve added a guard (count > 0) on the reader epilogue, and made some insigni.cant changes \nwhich make the proof presentation easier. Suppose the shared resource is a cell pointed to by y and the \ntwo bundles have invariants 0 write: if write = 0 then emp else y -. . (12) count read: if count = 0 \nthen emp else y - ---. . 3In terms of the model (section 10.2), it should be written -1 E - -. E ' , \nbut it simpli.es the proof theory if I use a special arrow and reserve the annotation of permissions \nfor positive integers. {emp} with read when true do count {if count = 0 then emp else y - ---. . * emp} \n0 if count = 0 then {emp} P(write) {y -. } countcount else {y - ---. } skip {y - ---. } . count {y \n- ---. } count +:= 1 count-1 count {y - -----. } . {y - ---. *z . } od {z . N} {z . N} with read when \ncount > 0 do  count {if count = 0 then emp else y - ---. . *z . N . count > 0} count -:= 1 count+1 \n{if count +1 = 0 then emp else y - -----. . *z . N . count +1 > 0} . count+1 count {y - -----. *z . N \n. count = 0} . {y - ---. . count = 0} 0 if count = 0 then {y -. } V(write) {emp} countcount else {y \n- ---. } skip {y - ---. } . count {if count = 0 then emp else y - ---. . * emp} od {emp} Figure 6: \nResource release in readers prologue and reclamation in epilogue The write semaphore-bundle owns a total \npermission which it releases on P and claims on V. It s easy to prove that using the CCR rule, as shown \nin .gure 5. From the proofs you can see that it would be impossible to P the semaphore if you already \nown the permission, and wrong to V it if you don t. Then a proof that the readers prologue releases a \nread permission into the surrounding program goes as in .gure 6. The epilogue reverses the action, with \nthe additional re\u00adquirement that count must be non-zero on entry to ensure that the resource-bundle invariant \nis preserved. (Investiga\u00adtions are underway to eliminate this infelicity in our treat\u00adment: if the readers \nand/or writers don t do anything silly, of course count > 0 on entry to the epilogue.)  8.2 No more \ncritical sections? When Dijkstra [9] introduced semaphores, the name re\u00adferred to those mechanical railway \nsignals which let only one train at a time onto a critical (signal-controlled) section of track. This \nblock signalling technique provides mutual ex\u00adclusion in the critical section. Hardware provides mutual \nexclusion only between executions of the test-and-set / in\u00adcrement instructions which implement the semaphore \nand we must rely on proof techniques to show mutual exclusion in critical sections. Sometimes the critical \nsections of a pro\u00adgram are hard to identify or non-existent. Brinch Hansen, arguing for the use of monitors \ninstead of semaphores, stated the problem: Since a semaphore can be used to solve arbitrary synchronizing \nproblems, a compiler cannot con\u00adclude that a pair of wait and signal operations on a given semaphore \ninitialized to 1 delimits a crit\u00adical region, nor that a missing member of such a pair is an error. [4] \nOur treatment (following [15]) inverts Dijkstra s view by focussing on permission rather than prohibition. \nA thread in possession of a permission can use it at any time. Separation guarantees absence of races \neven while permitting sharing. Semaphores are resource-holders which can be unlocked, not guardians of \ncritical sections. In .gure 3 there is mutual exclusion between the readers prologue and epilogue and \nbetween the four uses of the write semaphore, but otherwise it is unnecessary to invoke the notion of \ncritical section. I can write a silly but perfectly veri.able pattern use of read permissions: prologue; \nprologue; prologue; \u00ab reader1; reader2 reader3 ; epilogue epilogue; reader4; epilogue and an even sillier \nuse of total permission: `\u00b4 P(write); writer1; reader5 reader6 ; writer2; V(write) If the count variable \nof .gure 1 were in the heap, I could apply resourcing to a version of the algorithm which uses a mutex \nm instead of the CCRs of .gure 3, and produce a proof entirely free of the notion of critical section \n(but see also section 13.2).  9. WHY TWO MECHANISMS? The most striking feature of our presentation is \nthat there are two distinct models and two distinct logics. That s be\u00adcause proof requires two distinct \nand somewhat incompat\u00adible properties: unbounded divisibility suits some problems; unbounded counting \nsuits others. Problems which can exploit fractional permissions exhibit symmetrical splitting, inde.nite \nsubdivision, and simple and predictable split/combine behaviour. Those which need counting permissions \nhave asymmetrical splitting with an authority and a user, counting in the program, and split / combine \nas actions of the program rather than properties of its structure. It should be clear already that some \nproblems don t suit the notion of fractional permissions. It would be ex\u00adtremely di.cult, perhaps impossible, \nto specify and prove the readers-and-writers program using that technique. The read permissions are all \ngiven out from the same point and are all identical: they can be given back in any order, and anything \nother than counting-accounting would be absurdly over-complicated. Since counting is so clearly sometimes \nnecessary, I have to make a similar case for fractions. I do so by example. 9.1 Lambda-term substitution \nOur example is substitution on a lambda term, performed in parallel for the sub-terms of a function application. \nThe syntax of lambda terms is T ::= Lam vT | App TT | Var v (13) I de.ne substitution (for simplicity, \nallowing variable cap\u00adture) in the obvious way ( Lam v ' (\u00df[t/v]) v = v ' (Lam v ' \u00df)[t/v]= Lam v ' \u00dfv \n' = v (App fa)[t/v]= App (f[t/v]) (a[t/v]) ( Var v ' v = v ' (Var v ' )[t/v]= tv = v ' A possible heap \nrepresentation predicate for a lambda term pointed to by x with access permission z is z AST x (Lam v\u00df) \nz = .b.(x -. 0,v,b * AST b\u00dfz \u00ab z x -. 1,f,a * AST f fz* AST x (App fa) z = .f, a. AST aaz z AST x (Var \nv) z = x -. 2,v For simplicity, variables are represented by integers; the 0/1/2 tags which distinguish \ndi.erent kinds of nodes in the heap are arbitrarily chosen. The substitution function is given in Figure \n7 (the pro\u00adgram is abbreviated: some of the calculations and assign\u00adments in the .gure represent sequences \nof correct separation\u00adlogic assignments). The algorithm reads the node type from the heap: for a lambda \nabstraction it checks if the bound variable is the same variable as the substitution and if not substitutes \non the body; for an application it performs the substitution on each sub-term concurrently; and for a \nvari\u00adable if it is the variable being replaced it calls a copy function and returns a pointer to that \ncopy. The copy function has the speci.cation {AST yt z} x := copy y {AST yt z* AST xt 1} The substitution \nfunction is speci.ed as {AST xt 1 * AST yt ' z} z := subst x y v {AST z (t [t ' /v]) 1 * AST yt ' z} \nThe interesting part of the proof is the application case ([x] = 1). {AST x (App fa)1 * AST yt ' z} [x+1] \n:= subst [x+1] y v || [x+2] := subst [x+2] y v '' ' {AST x (App (f[t /v]) (a[t /v])) 1 * AST yt z} The \nproof requires the substituted lambda term to be split into two pieces, and needs the equivalence AST \nyt (z + z ' ) . AST yt z* AST yt z ' This equivalence is proved by induction on the structure of t . \n4 Using the Hoare-logic rule of consequence with this equivalence and the de.nition of AST, followed \nby an ap\u00adplication of the frame rule, I can derive the following proof obligation j. x . 1,f,a * AST \nff 1 * AST yt ' (z/2) * AST aa 1 * AST yt ' (z/2) [x+1] := subst [x+1] y v || [x+2] := subst [x+2] y \nv j. '''' ' x . 1,f ,a * AST f (f[t /v]) 1 * AST yt (z/2) * AST a ' (a[t ' /v]) 1 * AST yt ' (z/2) The \nproof is straightforward from the speci.cation of subst. But and this is the point which justi.es fractional \nrather than counting permissions because the proof uses frac\u00adtions I don t need to know how many times \nthe permission AST yt ' (z/2) will have to be split to complete either of the parallel threads (i.e. \nhow many application nodes there are altogether in f and a). The split is genuinely symmet\u00adrical; both \nsides may need to split further; there isn t any machinery in the program which corresponds to a splitting \nauthority. This example illustrates a situation in which fractional permissions lead to simpler and more \nusable proofs than counting. Counting .ts problems where a thread or a library module is used as an authority \nto give out ownership. Either approach can conceivably be used in the other s domain, but at an unnecessary \ncost. 10. MODELS Although there are two logical mechanisms, their models are very similar. 10.1 General \nstructure of models We will consider models where heaps are partial functions Heaps = L. (V \u00d7 M) where \nL and V are the sets of locations and values respect\u00adively, and M is equipped with a partial commutative \nsemig\u00adroup structure, where the binary operator is denoted *. The idea is that * adds permissions together, \nand the order in which permissions are combined does not matter. We ex\u00adtend * to the set V \u00d7 M as follows: \n8 < if v = v ' and '' (v,m * m ' ) (v, m) * (v ,m )= m*m ' defined : unde.ned otherwise 4 But see section \n13.1. subst x y v = [x+2] := subst [x+2] y v); if [x]=0then x if [x+1] != v then elsf [x+1] = v then \n[x+2] := subst [x+2] y v dispose x; dispose (x+1); else skip fi; new(2, copy y) x else elsf[x]=1then \nx ([x+1] := subst [x+1] y v || fi Figure 7: Substitution Source and correspondingly to the set Heaps: \nThe model is ({q . Q | 0 <q = 1},*2), where Q is the set of rational numbers and *2 is de.ned as follows: \nh*h ' de.ned i. h(l)*h ' (l) de.ned for each l . dom(h)n dom(h ' ) j ' unde.ned if q + q> 1 ' q + q otherwise \n8< : ' q*2 q = if h ' (l) unde.ned h(l) (h*h ' )(l)= h ' (l) if h(l) unde.ned h(l) *h ' (l) otherwise \nThe write permission is 1. The following property holds: Given a choice of M, the syntax and semantics \nof the (.) predicate is 7 ' 7 q+q - --. E ' q - . E ' ' q -. E (17) .. (E ) . q + q = 1 \u00ab E *E m' s, \nh . E - . E i.  dom(h)= [ E] s and h([[E] s) = ([[E ' ] s, m) 10.4 Combined Model A model (M, mW ) is \ngiven by a concrete M, together with a distinguished element mW . M , the write permission, such that: \n' ' mW * m unde.ned for any m . M (14) ' '' for all m . M there exists m . M such that m ' * m '' = mW \n(15) Intuitively, the two conditions say that mW is the maximal permission, and any permission can be \nextended to obtain the maximal one. 10.2 Model of counting permissions We distinguish read permissions \nfrom others. We count the number of read permissions that have been .aked o. a source permission. You \ncan t combine two source permis- By making read permissions divisible, it s possible to com\u00adbine the \nproperties of fractional and counting permissions. You .nish up with an asymmetrical fractional model. \nDes\u00adpite the fact that there is only one model, there are still two ideas proliferation and divisibility \n each of which seems to be necessary, neither of which is subservient to the other. The proofs sketched \nabove are all supportable in the com\u00adbined model. The only signi.cant di.erence is that it is impossible \nin the combined model to set up a logic in which read permissions cannot be split once issued, and control \nis entirely with the splitting authority a programming dis\u00adcipline which may prove to be useful in certain \nsituations. The model (Q, *3) combines counting and fractional per\u00admissions, where Q is the set of rational \nnumbers and *3 is de.ned as follows: sions. You can t combine a source permission with more read permissions \nthan it s generated. Given that, you can 8< : ' unde.ned if q = 0 and q = 0 '' record permission to \naccess a heap cell is represented by an q*3 q ' = unde.ned if (q = 0 or q = 0) and q + q < 0 ' integer: \n0 for a total permission, -1 for a read permission, q + q otherwise +k for a source permission from which \nk read permissions have been taken. The write permission is 0. The following properties hold: Formally, \nthe model is (Z, *1), where Z is the set of in\u00adtegers and * 1 is de.ned as follows: i*1 j = 8< : qq+q \n7 -q 7 unde.ned if i = 0 and j = 0 E -. E ' .. E - --. E ' *E - -. E ' unde.ned if (i = 0 or j = 0) \nand i + j< 0 when q = 0 and q ' > 0 (18) i + j otherwise -(q+q 7) -q -q 7 ' E - -----. E ' .. E - -. \nE ' *E - -. E when q, q ' > 0 The write permission is 0. The following properties hold: nn+m -m ' E - \n. E ' .. E - ---. E ' *E - --. E when n = 0 and m> 0 (16) -(n+m) -n -m E - -----. E ' .. E - -. E ' \n*E - --. E ' 11.  SEQUENTIAL SEMANTICS  when n,m > 0 If we restrict attention to the sequential case, \nthe se\u00admantics of commands in the permissions model is a minor 10.3 Model of fractional permissions modi.cation \nof the usual semantics. It is then possible to Fractions are easy: just add them up, make sure you don \nt show all the usual results about locality, weakest precondi\u00adgo zero, negative or greater than 1. tions \netc. 11.1 Semantics of commands Given a model we de.ne the semantics of atomic com\u00admands as follows \n[ E] s = v x := E, s, h r (s | x . v),h [ E ' ] s = l [ E] s = vh(l)=( ,mW ) [E ' ] := E, s, h r s, (h \n| l . (v, mW )) [ E ' ] s = lh(l)=(v, m) (19) x := [E ' ], s, h r (s | x . v),h l . L - dom(h)[ E] s \n= v x := new(E), s, h r (s | x . l), (h | l . (v, mW )) [ E ' ] s = lh(l)=( ,mW ) dispose(E ' ), s, h \nr s, (h - l) We observe that this is the usual standard semantics of these commands, plus runtime checks \non permissions. 11.2 Small Axioms We give small axioms for the atomic commands, in the style of [14]; \nthe frame rule can be used to infer complex speci.cations from these simple ones. The assignment and \nnew/dispose axioms are as you would expect. Only the total permission, mW , gets write and dis\u00adpose access. \nIn contrast, any permission m grants read ac\u00adcess. {Rx E } x:=E {R} - mW-' {E ' -. } [E ' ]:=E {E - \nm-W-. E} m'' m {E ' - . E} x:=[E ] {E - . E . x = E} (20) - mW {emp} x:=new(E) {x --. E} {E ' - mW --. \n} dispose E ' {emp} The side condition on the third axiom is that x does not occur free in E or E ' . \n 11.3 Frame Property, termination and safetymonotonicity Soundness of the frame rule depends on the local \nbeha\u00adviour of commands. The locality of commands was formal\u00adized in [21] with three properties: Safety \nMonotonicity: if C, s, h is safe and h*h ' is de.ned, then C,s,h * h ' is safe.  Termination Monotonicity: \nif C, s, h must terminate normally and h*h ' is de.ned, then C,s,h * h ' must terminate normally.  Frame \nProperty: if C, s, h0 is safe, and C, s, h0 *h1 r*  s ' ,h ' then there is h0 ' such that C, s, h0 r* \ns ' ,h ' 0 and h ' = h ' 0 *h1. The same properties hold when heaps are built using per\u00admission models. \nIn particular, condition (14) ensures that Safety Monotonicity and Frame Property hold for the com\u00admands \nin (19). A simple proof of soundness of the Frame Rule follows. 11.4 Weakest preconditions Weakest preconditions \nare obtained as a variation of the usual de.nitions by decorating the . assertions. Weakest preconditions \nare derivable, as usual, from the small axioms. 12. SOUNDNESS The soundness of our logics would appear \nto be shown by adapting the proof presented in [6] to each of our ver\u00adsions of resource permission and \nseparation. Adaptation is not a daunting task because of the framework of that proof. We intend, however, \nto take an alternative route: work is already in progress on the soundness of a general model which can \nbe instantiated with a range of di.erent de.ni\u00adtions. 13. FUTURE WORK The notion of permission is a \nstrong fertiliser for novel ideas about interesting problems. We already have more than we can deal with. \nSome of those closest to a solution are variables as resource, existence permissions and semaphores in \nthe heap. 13.1 Oddities of inductive de.nitions A separation-logic heap predicate for a tree (e.g. in \n[2]: versions di.er according to whether they have explicit Tips or store values at Node s) is tree nil \nEmpty = emp tree t (Tip a) = t . 0,a \u00ab (21) t . 1,l,r * tree t (Node ..) = .l, r \u00b7 tree l.* tree r. \nIt s tempting to de.ne a ztree as a tree whose pointers are all decorated with a fractional permission: \nztree z nil Empty = emp ztree zt (Tip a) = t -. 0,a z \u00ab t -. 1,l,r * ztree zt (Node ..) = .l, r \u00b7 z \nztree z l.* ztree zr. (22) (cf. the AST predicate in the term-rewriting example above). We do now have \nztree (z + z ' ) tt .. ztree ztt * ztree z ' tt , but sometimes only vacuously! (*) no longer guarantees \ndisjointness of domains, because of (7), so I can demonstrate some peculiarities. Consider the following \nex\u00adample (heavily abbreviated, in particular using .. for con\u00additional conjunction, like C s &#38;&#38;): \nif t = nil . [t]=1 . [t +1] = [t + 2] . [t + 1] = nil . [[t + 1]] = 0 (23) then [[t +1]+1] := [[t +1]+1]+1 \nelse skip . This program checks if it has been given a heap consisting of a Node in which left and right \npointers are equal and point to a Tip; it then attempts to increment the value in that tip. Such a heap \ncontains a DAG, not a tree: I would have hoped that the ztree predicate enforced tree structure just \nas tree does. Sharing can occur in ztrees when z = 0.5, because nothing in the de.nition provides against \nthe possibility that part or all of the l heap isn t then shared with the r heap. That s not all. The \nheap x - -. 1,l,l * l - -. 0, 3 *l - -. 0, 3 0.50.50.5 satis.es ztree 0.5 x (Node (Tip 3) (Tip 3)) Program \n(23)) will change it so that ztree 0.5 x (Node (Tip 4) (Tip 4)) Given x - --. 1,l,l * l - --. 0, 3 *l \n- --. 0, 3 0.25 0.25 0.25 the same locations with a di.erent fractional permission the same program \nwill abort. It s impossible to have x - --. 1,l,l * l - --. 0, 3 *l - --. 0, 3 0.75 0.75 0.75 there s \nno sharing in a ztree when z> 0.5. This is all very peculiar. We don t have passivity in ztrees as we \ndid with single cells and the values of fractions seem to matter: has everything gone horribly wrong? \nWell no, it hasn t: not quite. You can use the technique suggested in section 7.1: pass subprograms only \na part of the per\u00admission you hold. The term-rewriting example above isn t scuppered if the AST you pass \nin is a DAG, because the copy rule makes a new copy with 1.0 permission, and it s a sequential program \nso parallel subprograms can t conspire to accumulate total permission. In e.ect we can rely on passivity \nand there s no paradox, after all. Inductive de.nitions can be similarly confusing us\u00ading counting read-only \npermissions rather than fractions: there s no possibility of modi.cation by coincidence of sub\u00adtrees, \nbut once again DAGs are allowed where we d like to have only trees. Separation logic isn t broken by \nthis discov\u00adery, but we don t yet know how to write inductive de.nitions which combine obvious separation \nwith obvious reduction of permission. 13.2 Variables as resources Separation logic s success with the \nheap is partly good luck. Hoare logic s variable-assignment rule .nesses the distinction between program \nvariables and logical variables and assumes an absence of program-variable aliasing. The price for that \nsleight of hand is paid in the array-element\u00adassignment rule, which has to deal with aliasing of integer \nindices using arithmetic in the proof. In programming languages a little more developed than that treated \nby Hoare logic, Strachey s distinction of rvalue (variable address) and lvalue (variable contents) is \nmade ex\u00adplicit and can be exploited. Because heap rvalues and lvalues alike are integers, separation \nlogic can ignore the distinction and use the conventional Hoare logic variable assignment rule. The use \nof pure expressions (constants and variable names) not referring to the heap, and the restriction to \npar\u00adticular forms of assignment that essentially constrain us to consider single transfers between the \nstack (registers) and the heap, make it all work. Descriptions of the heap are es\u00adsentially pictures \nof separation; issues of aliasing then rarely arise, and we can regard separation as the problem. Separation \nlogic treats heap locations and variables quite di.erently. Heap locations are localised resources whose \nal\u00adlocation can be reasoned about, for example in the frame rule. But stacks are global: that fact shows \nup in the frame rule s proviso, which requires extra-logical syntactic separ\u00adation between resource formula \nP and the set of variables assigned to in C. I d much prefer to be able to integrate de\u00adscriptions of \nvariables as resources into the frame rule, make (*) do all the work, and eliminate the proviso. The \nmost obvious solution puts the stack in the heap. This naive approach doesn t work or rather, it doesn \nt work conveniently, because it destroys the main advant\u00adage of Hoare logic, which is the elegant simplicity \nof the variable-assignment rule. Drawing pictures of separation in the stack necessarily exposes the \nrvalue/lvalue distinction and the pun between logical and program variables which lies behind Hoare logic \ns use of straightforward substitution no longer makes sense. The problems of reasoning about concurrent \nprograms make treatment of variables-as-resources more than a matter of aesthetics, more than a desire \nto eliminate ugly provisos. I would like to be able to describe transfer of ownership of variables into \nand out of resource bundles. I can explain the original readers and writers algorithm (.gure 1) if the \ncount variable is locked away in the m mutex, released by P and reclaimed by V. Semantically the notion \nisn t very di.cult, but integrating it into a useful proof theory is proving di.\u00adcult. It s crucial that \nthis step is made so that we can have an e.ective logic of storage-resource in concurrent programs (and, \nby the by, eliminate any logical dependence on crit\u00adical sections and split binary semaphores, and maybe \neven provide a Hoare logic that deals with variable aliasing). 13.3 Existence permissions The treatments \nabove separate total permission from read permission. This is not the only distinction it is useful to \ndraw. A semaphore, for example, has permission to read and write its own variable. A concurrent thread \nhas no access to that variable but can P or V it. Existence permissions provide evidence of a resource \ns existence, but no access to its contents. They allow us to separate total from read/write permissions. \nA user knows that a semaphore exists, but can\u00adnot read it. The semaphore can t dispose itself (see below) \nunless its permission is total that is, unless there are no users with existence permissions. The proof \ntheory of existence permissions seems to be a variation on fractional permissions. We don t yet have \na satisfying and elegant model. 13.4 Semaphores in the heap I .rst encountered permission counting in \nthe context of pipeline processing in the Intel IXP network processor chip [12]. A read thread waits \nfor packet data to arrive on a par\u00adticular network port, and assembles packet fragments into a newly-allocated \npacket bu.er. It then immediately passes the bu.er, through an inter-thread queue, to the .rst pro\u00adcessing \nthread, and turns to wait for the next packet. The processing thread does some work on the bu.er and \npasses it on to the next processing thread, and so on until even\u00adtually it arrives at a write thread \nwhich disassembles the processed packet, transmits the pieces of data through its network port, and disposes \nthe bu.er. This is single-casting, in which every packet has a single destination address, and it s a \nbeautiful example of the power of ownership transfer. Each thread owns the bu.er until it transfers it \ninto an inter-thread queue, an example of a shared resource bundle. Each thread has a loop invari\u00adant \nof emp, so if there are any space leaks it can only be that a queue is overlooked and never emptied. \nThe most im\u00adportant feature of the technique is its simplicity the read thread, which allocates the \nbu.er, has nothing to do with its disposal and e.ciency no need for accounting in the program, only \nin the proof. In multicasting a single packet can be distributed to sev\u00aderal destinations at once. An \nobvious technique would be to copy the incoming packet into several bu.ers, but the desire for e.ciency \nand maximum packet throughput com\u00adpels sharing. The solution adopted is to use a semaphore\u00adprotected \ncount of access permissions to determine when everybody has .nished and the bu.er can be disposed. In \nprinciple it s not much more di.cult to program, but there s many a slip, so it would be good to be able \nto formalise it [10]. The obstacles to a proof don t seem unsurpassable but I cannot claim that they \nare conquered already. The program must dynamically allocate semaphores as well as bu.ers, and the idea \nof semaphores in the heap makes theoreticians wince. The semaphore has to be available to a shared re\u00adsource \nbundle: that means a bundle will contain a bundle which contains resource, a notion which makes everybody \ns eyes water. None of it seems impossible, but it s a signi.cant problem, and solving it will be a small \ntriumph. Acknowledgements Doug Lea .rst suggested that we should read . as a per\u00admission. John Boyland \nput us on to a means of accounting. Josh Berdine, a conspirator in the East London Massive, helped us \nargue through early ideas and re.ne later ones. John Reynolds questioned some wild early versions. Our \nhonorary guru Hongseok Yang beat us back from the wilder shores of speculation. Those excesses that remain \nare all my own. Calcagno, O Hearn and Parkinson were supported by EPSRC.  14. REFERENCES [1] R. Bornat. \nProving pointer programs in Hoare logic. In R. C. Backhouse and J. N. Oliveira, editors, Mathematics \nof Program Construction, 5th International Conference, LNCS, pages 102 126. Springer, 2000. [2] R. Bornat, \nC. Calcagno, and P. O Hearn. Local reasoning, separation and aliasing. SPACE Workshop, Venice, 2004. \n[3] J. Boyland. Checking interference with fractional permissions. In R. Cousot, editor, Static Analysis: \n10th International Symposium, volume 2694 of Lecture Notes in Computer Science, pages 55 72, Berlin, \nHeidelberg, New York, 2003. Springer. [4] P. Brinch Hansen. Operating System Principles. Prentice Hall, \n1973. [5] P. Brinch Hansen, editor. The Origin of Concurrent Programming. Springer-Verlag, 2002. [6] \nS. D. Brookes. A semantics for concurrent separation logic. In CONCUR 04: 15th International Conference \non Concurrency Theory, volume 3170 of Lecture Notes in Computer Science, pages 16 34, London, August \n2004. Springer. Extended version to appear in Theoretical Computer Science. [7] R. Burstall. Some techniques \nfor proving correctness of programs which alter data structures. Machine Intelligence, 7:23 50, 1972. \n[8] P. J. Courtois, F. Heymans, and D. L. Parnas. Concurrent control with readers and writers . Commun. \nACM, 14(10):667 668, 1971. [9] E. W. Dijkstra. Cooperating sequential processes. In F. Genuys, editor, \nProgramming Languages, pages 43 112. Academic Press, 1968. Reprinted in [5]. [10] R. Ennals, R. Sharp, \nand A. Mycroft. Linear types for packet processing. In To appear. Proceedings of the 2004 European Symposium \non Programming (ESOP), LNCS. Springer-Verlag, 2004. [11] C. A. R. Hoare. Towards a theory of parallel \nprogramming. In Hoare and Perrott, editors, , in , ed. Operating System Techniques,, 1972., pages 61 \n71. Academic Press, 1972. [12] E. J. Johnson and A. Kunze. IXP2400/2800 Programming: The Complete Microengine \nCoding Guide. Intel Press, 2003. [13] P. O Hearn. Notes on separation logic for shared-variable concurrency. \nunpublished, Jan. 2002. [14] P. O Hearn, J. Reynolds, and H. Yang. Local reasoning about programs that \nalter data structures. In L. Fribourg, editor, CSL 2001, pages 1 19. Springer-Verlag, 2001. LNCS 2142. \n[15] P. W. O Hearn. Resources, concurrency and local reasoning. to appear in Theoretical Computer Science; \npreliminary version published as [16]. [16] P. W. O Hearn. Resources, concurrency and local reasoning. \nIn CONCUR 04: 15th International Conference on Concurrency Theory, volume 3170 of Lecture Notes in Computer \nScience, pages 49 67, London, August 2004. Springer. Extended version is [15]. [17] P. W. O Hearn and \nD. J. Pym. The logic of bunched implications. Bulletin of Symbolic Logic, 5(2):215 244, June 1999. [18] \nD. Pym. The Semantics and Proof Theory of the Logic of Bunched Implications, volume 26 of Applied Logic \nSeries. Kluwer Academic Publishers, 2002. [19] J. Reynolds. Separation logic: a logic for shared mutable \ndata structures. Invited Paper, LICS 02, 2002. [20] J. C. Reynolds. Intuitionistic reasoning about shared \nmutable data structure. In J. Davies, B. Roscoe, and J. Woodcock, editors, Millennial Perspectives in \nComputer Science, pages 303 321. Palgrave, 2000. [21] H. Yang and P. O Hearn. A semantic basis for local \nreasoning. In 5th FOSSACS, pages 402 416. Springer-Verlag, 2002.   \n\t\t\t", "proc_id": "1040305", "abstract": "A lightweight logical approach to race-free sharing of heap storage between concurrent threads is described, based on the notion of permission to access. Transfer of permission between threads, subdivision and combination of permission is discussed. The roots of the approach are in Boyland's [3] demonstration of the utility of fractional permissions in specifying non-interference between concurrent threads. We add the notion of counting permission, which mirrors the programming technique called permission counting. Both fractional and counting permissions permit passivity, the specification that a program can be permitted to access a heap cell yet prevented from altering it. Models of both mechanisms are described. The use of two different mechanisms is defended. Some interesting problems are acknowledged and some intriguing possibilities for future development, including the notion of resourcing as a step beyond typing, are paraded.", "authors": [{"name": "Richard Bornat", "author_profile_id": "81100414897", "affiliation": "Middlesex University, London, UK", "person_id": "PP14146914", "email_address": "", "orcid_id": ""}, {"name": "Cristiano Calcagno", "author_profile_id": "81100047402", "affiliation": "Imperial College, University of London, London, UK", "person_id": "PP31024717", "email_address": "", "orcid_id": ""}, {"name": "Peter O'Hearn", "author_profile_id": "81332519314", "affiliation": "Queen Mary, University of London, London, UK", "person_id": "PP45027416", "email_address": "", "orcid_id": ""}, {"name": "Matthew Parkinson", "author_profile_id": "81406598777", "affiliation": "University of Cambridge, Cambridge, UK", "person_id": "P707743", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1040305.1040327", "year": "2005", "article_id": "1040327", "conference": "POPL", "title": "Permission accounting in separation logic", "url": "http://dl.acm.org/citation.cfm?id=1040327"}