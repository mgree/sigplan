{"article_publication_date": "01-12-2005", "fulltext": "\n Combinators for Bi-Directional Tree Transformations A Linguistic Approach to the View Update Problem \nJ. Nathan Foster, Michael B. Greenwald, Jonathan T. Moore, Benjamin C. Pierce, and Alan Schmitt University \nof Pennsylvania ABSTRACT We propose a novel approach to the well-known view up\u00addate problem for the \ncase of tree-structured data: a domain\u00adspeci.c programming language in which all expressions de\u00adnote \nbi-directional transformations on trees. In one direc\u00adtion, these transformations dubbed lenses map a \ncon\u00adcrete tree into a simpli.ed abstract view ; in the other, they map a modi.ed abstract view, together \nwith the orig\u00adinal concrete tree, to a correspondingly modi.ed concrete tree. Our design emphasizes both \nrobustness and ease of use, guaranteeing strong well-behavedness and totality prop\u00aderties for well-typed \nlenses. We identify a natural space of well-behaved bi-directional transformations over arbitrary structures, \nstudy de.nedness and continuity in this setting, and state a precise connection with the classical theory \nof update translation under a con\u00adstant complement from databases. We then instantiate this semantic \nframework in the form of a collection of lens combi\u00adnators that can be assembled to describe transformations \non trees. These combinators include familiar constructs from functional programming (composition, mapping, \nprojection, conditionals, recursion) together with some novel primitives for manipulating trees (splitting, \npruning, merging, etc.). We illustrate the expressiveness of these combinators by de\u00adveloping a number \nof bi-directional list-processing transfor\u00admations as derived forms. Categories and Subject Descriptors. \nD.3.2 [Programming Languages]: Language Classi.ca\u00adtions Specialized application languages General Terms. \nLanguages Keywords. Bi-directional programming, Harmony, XML, lenses, view update problem 1. INTRODUCTION \nComputing is full of situations where one wants to transform some structure into a di.erent form a view \nin such a way Permission to make digital or hard copies of all or part of this work for personal or classroom \nuse is granted without fee provided that copies are not made or distributed for pro.t or commercial advantage \nand that copies bear this notice and the full citation on the .rst page. To copy otherwise, to republish, \nto post on servers or to redistribute to lists, requires prior speci.c permission and/or a fee. POPL \n05 January 12 14, 2005, Long Beach, California, USA. Copyright 2005 ACM 1-58113-830-X/05/0001 ...$5.00. \n that changes made to the view can be re.ected back as up\u00addates to the original structure. This view \nupdate problem is a classical topic in the database literature, but has so far been little studied by \nprogramming language researchers. This paper addresses a speci.c instance of the view up\u00addate problem \nthat arises in a larger project called Har\u00admony [26]. Harmony is a generic framework for synchro\u00adnizing \ntree-structured data a tool for propagating updates between di.erent copies of tree-shaped data structures, \npos\u00adsibly stored in di.erent formats. For example, Harmony can be used to synchronize the bookmark .les \nof several di.erent web browsers, allowing bookmarks and bookmark folders to be added, deleted, edited, \nand reorganized in any browser and propagated to the others. Other Harmony instances currently in daily \nuse or under development include syn\u00adchronizers for calendars (Palm DateBook, ical, and iCalen\u00addar formats), \naddress books, slide presentations, structured documents, and generic XML and HTML. Views play a key \nrole in Harmony: to synchronize dis\u00adparate data formats, we de.ne one common abstract view and a collection \nof lenses that transform each concrete for\u00admat into this abstract view. For example, we can synchro\u00adnize \na Mozilla bookmark .le with an Explorer bookmark .le by transforming each into an abstract bookmark struc\u00adture \nand synchronizing the results. Having done so, we need to take the updated abstract structures and perform \nthe corresponding updates to the concrete structures. Thus, each lens must include not one but two functions \none for extracting an abstract view from a concrete one and an\u00adother for pushing an updated abstract \nview back into the original concrete view to yield an updated concrete view. We call these the get and \nputback components, respectively. The intuition is that the mapping from concrete to abstract is commonly \nsome sort of projection, so the get direction involves getting the abstract part out of a larger concrete \nstructure, while the putback direction amounts to putting a new abstract part into an old concrete structure. \nWe present a concrete example in \u00a72. The di.culty of the view update problem springs from a fundamental \ntension between expressiveness and robustness. The richer we make the set of possible transformations \nin the get direction, the more di.cult it becomes to de.ne cor\u00adresponding functions in the putback direction \nso that each lens is both well behaved its get and putback behaviors .t together in a sensible way and \ntotal its get and putback functions are de.ned on all the inputs to which they may be applied. To reconcile \nthis tension, any approach to the view update problem must be carefully designed with a particular application \ndomain in mind. The approach described here is tuned to the kinds of projection-and-rearrangement trans\u00adformations \non trees and lists that we have found useful for implementing Harmony instances. It does not directly \nad\u00address some well-known di.culties with view update in the classical setting of relational databases \nsuch as the di.\u00adculty of inverting queries involving joins though we hope that our work may suggest new \nattacks on these problems. A second di.culty concerns ease of use. In general, there are many ways to \nequip a given get function with a putback function to form a well-behaved and total lens; we need some \nmeans of specifying which putback is intended that is natural for the application domain and that does \nnot involve onerous proof obligations or checking of side conditions. We adopt a linguistic approach \nto this issue, proposing a set of lens combinators a small domain-speci.c language in which every expression \nsimultaneously speci.es both a get function and the corresponding putback. Moreover, each combinator \nis accompanied by a type declaration, designed so that the well-behavedness and for non-recursive lenses \ntotality of composite lens expressions can be veri.ed by straightfor\u00adward, compositional checks. The \n.rst step in our formal development, in \u00a73, is identi\u00adfying a natural space of well-behaved lenses over \narbitrary data structures. There is a good deal of territory to be ex\u00adplored at this semantic level. \nFirst, we must phrase our basic de.nitions to allow the underlying functions in lenses to be partial, \nsince there will in general be structures to which a given lens cannot sensibly be applied. The sets \nof structures to which we do intend to apply a given lens are speci.ed by associating it with a type \nof the form C c A, where C is a set of concrete source structures and A is a set of abstract target structures. \nSecond, we de.ne a notion of well-behavedness that captures our intuitions about how the get and putback \nparts of a lens should behave in con\u00adcert. Third, we use standard tools to de.ne monotonicity and continuity \nfor lens combinators, establishing a founda\u00adtion for de.ning lenses by recursion. Finally, to allow lenses \nto be used to create new concrete structures rather than just updating existing ones (which can happen, \ne.g., when new records are added to a database in the abstract view), we show how to adjoin a special \nmissing element to the structures manipulated by lenses and establish suitable con\u00adventions for how it \nis treated. We next proceed to syntax. We .rst (\u00a74) present a group of generic lens combinators (identities, \ncomposition, and constants), which can work with any kind of data. Next (\u00a75), we present several more \ncombinators that perform various manipulations on trees (hoisting, splitting, mapping, etc.) and show \nhow to assemble these primitives to yield some use\u00adful derived forms. \u00a76 introduces another set of generic \ncom\u00adbinators implementing various sorts of bi-directional condi\u00adtionals. \u00a77 gives a more ambitious illustration \nof the expres\u00adsiveness of these combinators by implementing a number of bi-directional list-processing \ntransformations; our main ex\u00adample is a bi-directional list filter lens whose putback direction performs \na rather intricate weaving operation to recombine an updated abstract list with the concrete list ele\u00adments \nthat were .ltered away by the get. A more pragmatic illustration of the use of our combinators in real-world \nlens programming may be found in the accompanying technical report [12], where we walk through a substantial \nexample derived from the Harmony bookmark synchronizer. \u00a78 surveys a variety of related work and states \na precise correspondence (ampli.ed in [25]) between our well-behaved lenses and update translation under \na constant comple\u00adment from databases. \u00a79 sketches directions for future re\u00adsearch. Omitted proofs can \nbe found in [12]. 2. A SMALL EXAMPLE Suppose our concrete tree c is a small address book: 8.. ..9 . \n.. .. > Phone n. 333-4444 > >.. ..> < Pat n.= ..URLn. http://pat.com .. . . ... c = .. .. > Phone n. \n888-9999 > >.. ..> : Chris n.;..URL n. http://chris.org .. (We draw trees sideways to save space. Each \nset of hollow braces corresponds to a tree node, and each X n. ... de\u00adnotes a child labeled with the \nstring X. The children of a node are unordered. To avoid clutter, when an edge leads to an empty tree, \nwe usually omit the braces, the n. symbol, and the .nal childless node e.g., 333-4444 above stands for \n.. .\u00af . .333-4444 n. {||} . When trees are linearized in running text, we separate children with commas.) \nNow, suppose that we want to edit the data from this concrete tree in a simpli.ed format where each name \nis as\u00adsociated directly with a phone number. . .. .. Pat n. 333-4444 .. a = .Chris n. 888-9999. Why \nwould we want this? Perhaps because the edits are going to be performed by synchronizing this abstract \ntree with another replica of the same address book in which no URL information is recorded. Or perhaps \nthere is no syn\u00adchronizer involved, but the edits are going to be performed by a human who is only interested \nin phone information and whose screen should not be cluttered with URLs. Whatever the reason, we are \ngoing to make our changes to the abstract tree a, yielding a new abstract tree al of the same form but \nwith modi.ed content.1 For example, let us change Pat s phone number, drop Chris, and add a new friend, \nJo. . .. .. l Pat n. 333-4321 .. a = .Jo n. 555-6666 . Lastly, we want to compute a new concrete tree \ncl re.ect\u00adl ing the new abstract tree a. That is, we want the parts l of cthat were kept when calculating \na (e.g., Pat s phone number) to be overwritten with the corresponding informa\u00ad l tion from a, while \nthe parts of c that were .ltered out (e.g., Pat s URL) have their values carried over from c. 8. . ...9 \n.. .. > Phone n. 333-4321 > >.. ..> < Pat n.= l .. ..URLn. http://pat.com . .... c = .. .. > Phone n. \n555-6666 > >.. ..> : Jo n.; ..URL n. http://google.com .. We also need to .ll in appropriate values \nfor the parts of ll c(in particular, Jo s URL) that were created in aand for which c therefore contains \nno information. Here, we simply set the URL to a constant default. 1l Note that we are interested here \nin the .nal tree a, not the particular sequence of edit operations that was used to l transform a into \na. This is important in the context of Harmony, where we only have access to the current states of the \nreplicas, rather than a trace of modi.cations; see [26]. Together, the transformations from c to a and \nfrom a l and c to c l form a lens. Our goal is to .nd a set of com\u00adbinators that can be assembled to \ndescribe a wide variety of lenses in a concise, natural, and mathematically coherent manner. (Just to \nwhet the reader s appetite, the lens expres\u00adsion that implements the transformation sketched above is \n.. .\u00af . written map (focus Phone .URL n. http://google.com ).)  3. SEMANTIC FOUNDATIONS Although many \nof our combinators work on trees, their se\u00admantic underpinnings can be presented in an abstract set\u00adting \nparameterized by the data structures ( views ) manip\u00adulated by lenses. In this section and in \u00a74, where \nwe discuss generic combinators we simply assume some .xed set U of views; from \u00a75 on, we will choose \nU to be the set of trees. Basic Structures When f is a partial function, we write f (a) n if f is de.ned \non argument a and f (a)= . otherwise. We write f (a) . b for f (a)= ..f (a)= b. We write dom(f ) for \nthe set of arguments on which f is de.ned. When S .U, we write f (S) for {r | s . S . f (s) n. f (s)= \nr}. We take function application to be strict, i.e., f (g(x)) n implies g(x) n. 3.1 De.nition [Lenses]: \nA lens l comprises a partial function l/ from U to U, called the get function of l, and a partial function \nl\" from U\u00d7U to U, called the putback function. 3.2 De.nition [Well-behaved lenses]: Let l be a lens and \nlet C and A be subsets of U. We say that l is a well behaved lens from C to A, written l . C c A, i. \nit maps arguments in C to results in A and vice versa l/(C) . A (Get) l.(A \u00d7 C) . C (Put) and its get \nand putback functions obey the following laws: l \" (l/ c, c) . c for all c . C (GetPut) l/ (l \" (a, c)) \n. a for all (a, c) . A \u00d7 C (PutGet) We call C the source and A the target in C c A. Intuitively, the \nGetPut law states that, if we get some abstract view a from a concrete view c and immediately putback \na (with no modi.cations) into c, we must get back exactly c (if both operations are de.ned). PutGet, \non the other hand, demands that the putback function must cap\u00adture all of the information contained in \nthe abstract view: if putting a view a into a concrete view c yields a view c l , then the abstract view \nobtained from c l is exactly a. An example of a lens satisfying PutGet but not GetPut is the following. \nSuppose C = string\u00d7int and A = string, and de.ne l by l/ (s, n)= s and l \" (s l , (s, n)) = (s l , 0). \nThen l \" (l/ (s, 1), (s, 1)) = . (s, 0) =(s, 1). Intuitively, the law fails because the putback function \nhas side e.ects : it modi.es information from the concrete view that is not re\u00ad.ected in the abstract \nview. An example of a lens satisfying GetPut but not PutGet is the following. Let C = string and A = \nstring \u00d7 int, and de.ne l by l/ s =(s, 0) and l \" ((s l ,n),s)= s l . Put-Get fails here because some \ninformation contained in the abstract view does not get propagated to the concrete view. l lll For example, \nl/ (l \" ((s, 1),s)) = l/ s =(s, 0) .=(s, 1). The GetPut and PutGet laws re.ect fundamental ex\u00adpectations \nabout the behavior of lenses; removing either law signi.cantly weakens the semantic foundation. We may \nalso consider an optional third law, called PutPut, stating that l \" (a l,l \" (a, c)) . l \" (a l ,c) \nfor all a, a l . A and c . C. This law states that the e.ect of a sequence of two putbacks is (modulo \nunde.nedness) just the e.ect of the second: the .rst gets completely overwritten. Alternatively, a series \nof changes to an abstract view may be applied either incremen\u00adtally or all at once, resulting in the \nsame .nal concrete view. We say that a well-behaved lens that also satis.es PutPut is very well behaved. \nBoth well-behaved and very well be\u00adhaved lenses correspond to well-known classes of update translators \nfrom the classical database literature (see \u00a78). However, when we come to de.ning our lens combinators \nfor tree transformations in \u00a75, we will not require PutPut because one of our most important lens combinators, \nmap, fails to satisfy it(see \u00a75). A .nal important property of lenses is totality. 3.3 De.nition [Totality]: \nA lens l . C c A is said to be total, written l . C .. A, if C . dom(l/) and A \u00d7 C . dom(l.). The reasons \nfor considering both partial and total lenses instead of building totality into the de.nition of well\u00adbehavedness \nare much the same as in conventional functional languages. In practice, we always want lenses to be total: \nto make Harmony synchronizers work predictably, lenses must be de.ned on the whole of the domains where \nthey are used. All of our primitive lenses are designed to be total, and all of our lens combinators \nmap total lenses to total lenses with the sole, but important, exception of lenses de.ned by recursion \n(to which we will turn in a moment); as usual, re\u00adcursive lenses must be constructed in the semantics \nas limits of chains of increasingly de.ned partial lenses. At the level of types, the type annotations \nwe give for our lens combina\u00adtors can be used to prove that any well-typed lens expression is well-behaved, \nbut only recursion-free expressions can be shown total by completely compositional reasoning; for re\u00adcursive \nlenses, more global arguments are required. The long version of the paper gives several of these arguments \nin de\u00adtail, showing that all our derived forms involving recursion are actually total. In what follows \nhere, however, we focus on well-behavedness for the sake of brevity. Recursion Since we will be interested \nin lenses over trees, and since trees in many interesting application domains may have unbounded depth \n(e.g., a bookmark item can be either a link or a folder containing a list of items), we will often want \nto de.ne lenses by recursion. The development follows familiar lines. We introduce an information ordering \non lenses and show that the set of lenses equipped with this ordering is a complete partial or\u00adder (cpo). \nWe then apply standard tools from domain theory to interpret a variety of common syntactic forms from \npro\u00adgramming languages in particular, functional abstraction and application ( higher-order lenses ) \nand lenses de.ned by single or mutual recursion. We say that a lens ll is more informative than a lens \nl, written l \u00d8 ll , if both the get and putback functions of ll have domains that are at least as large \nas those of l and if their results agree on their common domains. A cpo is a partially ordered set in \nwhich every increasing chain of elements has a least upper bound in the set. A cpo with bottom is a cpo \nwith an element . that is smaller than every other element. In our setting, . is the lens whose get and \nputback functions are everywhere unde.ned. 3.4 Lemma: Let l0 \u00d8 l1 \u00d8 ... \u00d8 ln \u00d8 ... be an increasing chain \nof lenses. The lens l de.ned by id/ c = c id (a, c)= a VC.U. id . CC !c The lens composition combinator \nl; k places two lenses l and k in sequence. tity lens belongs to CC for any C ). (a, c)= li (a, c) if \nli (a, c) n for some i l/ c = li/ c if li/ c n for some i and unde.ned elsewhere is a least upper bound \nfor the chain. 3.5 Lemma: Let l0 \u00d8 l1 \u00d8 ... \u00d8 ln \u00d8 ... be an increasing chain of lenses, and let C0 . \nC1 . ... and A0 . A1 . ... be !c (l; k)/ c = k/ (l/ c) (l; k)(a, c)= l (k (a, l/ c),c) VA,B, C.U. Vl \n. CB. Vk . BA. !c l; k . CA !c increasing chains of subsets of U. Then(Vi . w. li . Ci FS S c The get \ndirection applies the get function of l to yield a .rst Ai)=. ( ln) . ( Ci) c ( Ai). ni i 3.6 Theorem: \nLet L be the set of well-behaved lenses from C to A. Then (L, \u00d8) is a cpo with bottom. We can now apply \nstandard domain theory to interpret recursive de.nitions: the least .xed point of a continuous function \non well-behaved lenses is a well-behaved lens. Dealing with Creation In practice, there will be cases \nwhere we need to apply a putback function, but where no old concrete view is available, as we saw with \nJo s URL in \u00a72. We deal with these cases by enriching the universe U of views with a special placeholder \nD, pronounced missing, which we assume is not already in U. When S .U, we write ST for S .{D}. abstract \nview, on which the get function of k is applied. In the other direction, the two putback functions are \napplied in turn: .rst, the putback function of k is used to put a into the concrete view that the get \nof k was applied to, i.e., l/ c; the result is then put into c using the putback function of l. (If the \nconcrete view c is D, then, l/ c will also be D by our conventions on D, so the e.ect of (l; k)(a, D) \nis to use k to put a into D and then l to put the result into D.) Another simple combinator is const \nvd, which transforms any view into the constant view v in the get direction. In the putback direction, \nconst simply restores the old concrete view if one is available; if the concrete view is D, it returns \na default view d. Intuitively, l (a, D) means create a new concrete view from the information in the \nabstract view a. By convention, D is only used in an interesting way when it is the second argument to \nthe putback function: in all of the lenses de.ned below, we maintain the invariants that (1) l/ D = D, \n(2) l (D,c)= D for any c, (3) l/ c = D for any c .D, and .= !c (const vd)/ c = v (const vd)(a, c)= c \nif c . =D d if c =D VC.U. Vv.U. Vd.C. const vd . C{v} Note that the type declaration demands that the \nputback (4) l (a, c)=D forany a .D and any c (including D). .= direction only be applied to the abstract \nargument v. !c We write C A for the set of well-behaved lenses from We will de.ne a few more generic \nlenses in \u00a76; for now, CT to AT obeying these conventions. For brevity in the though, let us turn to \nsome lens combinators that work on lens de.nitions below, we always assume that c .D when = tree-structured \ndata, so that we can ground our de.nitions de.ning l/ c and that a .(a, c), since = D when de.ning l \n in speci.c examples. the results in these cases are uniquely determined by these conventions. (There \nare other, formally equivalent, ways of handling missing concrete views. The advantages of this one \n5. LENSES FOR TREES are discussed in \u00a75.)  4. GENERIC LENSES With these semantic foundations in hand, \nwe are ready to move on to syntax. We begin in this section with sev\u00aderal generic lens combinators, whose \nde.nitions are inde\u00adpendent of the particular choice of universe U. Each def\u00adinition is accompanied by \na type declaration asserting its well-behavedness under certain conditions (e.g., the iden\u00ad !c To keep \nour lens de.nitions as straightforward as possible, we work with an extremely simple form of trees: unordered, \nedge-labeled trees with no repeated labels. This does not give us primitively all the structure we need \nfor some ap\u00adplications; in particular, we will need to deal with ordered data such as lists and XML documents \nvia an encoding in\u00adstead of primitively. Experience has shown that the reduc\u00adtion in the complexity of \nthe lens de.nitions obtained in this way far outweighs the increase in complexity of lens pro\u00ad grams \ndue to manipulating ordered data in encoded form. Most of the lens de.nitions in this and following sections \nare parameterized on one or more arguments. These may be of various types: views, other lenses, predicates \non views, edge labels, predicates on labels, etc. The long version in\u00adcludes proofs that every lens we \nde.ne is well behaved (i.e., that the type declaration accompanying its de.nition is a theorem) and total, \nand that every lens that takes other lenses as parameters is continuous in these parameters and maps \ntotal lenses to total lenses. The identity lens copies the concrete view in the get direc\u00adtion and the \nabstract view in the putback direction. Notation From this point on, we choose the universe U to be \nthe set T of .nite, unordered, edge-labeled trees with labels drawn from some in.nite set N of names \ne.g., character strings and with the children of a given node all labeled with distinct names. A tree \nis essentially a .nite partial function from names to other trees. It will be more convenient, though, \nto adopt a slightly di.erent perspective: we will consider a tree t .T to be a total function from N \nto TT that yields D on all but a .nite number of names. We write dom(t) for the domain of t i.e., the \nset of the names for which it returns something other than D and t(n) for the subtree associated to name \nn in t, or D if n .. dom(t). Tree values are written using hollow curly braces. The empty tree is written \n{||}. (Note that {||}, a node with no chil\u00addren, is di.erent from D.) We often describe trees by com\u00ad \n.. .\u00af . prehension, writing .n n. F (n) | n . N , where F is some .. . (plunge n)/ c = .n n. c .. .\u00af \n. .\u00af (plunge n)(a, c)= t if a = .n n. t .. . VC.T . Vn.N . plunge n . C .n n. C .\u00af ! c Forking The lens \ncombinator xfork applies di.erent function from N to TT and N .N is some set of names. lenses to di.erent \nparts of a .. .\u00af l ll . When t and thave disjoint domains, we write t \u00b7 tor .tttree: it splits the tree \ninto  pa pa (the latter especially in multi-line displays) for the tree map-two parts according to \nthe ping n to t(n) for n . dom(t), to tl(n) for n . dom(tl), and names of its immediate chil\u00ad to D otherwise. \n dren, applies a di.erent lens  papa  the restriction of t to children with names from p (l1 )(l2 \n) pc pc When p .N is a set of names, we write p to each, and concatenates for N\\p, the complement of \np. We write t|p for the results. Formally, xfork takes as arguments two sets .. .\u00af . i.e., the tree \n.n n. t(n) | n . p n dom(t) and t\\p for of names and two lenses. .. .\u00af . .n n. t(n) | n . dom(t)\\p . \nWhen p is just a singleton set The get direction of xfork  {n}, we drop the set braces and write just \nt|n and t\\n in-pc pal1 l2 can be visualized stead of t|{n} and t\\{n}. as in the inset .gure (the To shorten \nsome of the lens de.nitions, we adopt the con-concrete tree is at the bot\u00ad ventions that dom(D) = ., \nand that D|p = D for any p. tom). The triangles labeled For writing down types,2 we extend these tree \nnotations pc denote trees whose immediate child edges have labels in .. .\u00af . to sets of trees. If T .T \nand n .N , then .n n. T .. .\u00af . denotes the set of singleton trees { .n n. t | t . T }. If .. .\u00af . T \n.T and N .N , then .N n. T denotes the set of trees .. no . ?. {t | dom(t)= N and Vn . N. t(n) . T } \nand .N n. T . denotes the set of trees {t | dom(t) . N and Vn . N. t(n) . TT }. We write T1 \u00b7 T2 for \n{t1 \u00b7 t2 | t1 . T1,t2 . T2} and T (n) for {t(n) | t . T }\\{D}. If T .T , then dom(T )= {dom(t) | t . \nT }. .. .\u00af . A value is a tree of the special form .k n. {||} , of\u00ad ten written just k. For instance, \nthe phone number .. .\u00af pc; dotted arrows represent splitting or concatenating trees. The result of applying \nl1/ to c|pc (the tree formed by drop\u00adping the immediate children of c whose names are not in pc) must \nbe a tree whose top-level labels are in the set pa; similarly, the result of applying l2 / to c\\pc must \nbe in pa. That is, the lenses l1 and l2 are allowed to change the sets of names in the trees they are \ngiven, but each must map from its own part of pc to its own part of pa. Conversely, in the putback direction, \nl1 must map from pa to pc and l2 from pa to pc. Here is the full de.nition: ! c V.NV.T|V.T|CApc,pa11...pcpa! \nc ! c (xfork pc pa l1 l2 )/ c =(l1/ c|pc) \u00b7 (l2/ c\\pc) (xfork pc pa l1 l2 )(a, c)= (l1 (a|pa,c|pc)) \u00b7 \n(l2 (a\\pa,c\\pc)) VC2.T \\pc. VA2.T \\pa. Vl1 . C1 A1. Vl2 . C2 A2. xfork pc pa l1 l2 . (C1 \u00b7 C2)(A1 \u00b7 A2) \n. .333-4444 n. {||} in the example of \u00a72 is a value. Hoisting and Plunging Let s warm up with some com\u00adbinators \nthat perform simple structural transformations on trees of very simple shapes. We will see shortly how \nto com\u00adbine these with a powerful forking operator to perform related operations on more general sorts \nof trees. The lens hoist n is used to shorten a tree by removing an edge at the top. In the get direction, \nit expects a tree that has exactly one child, named n. It returns this child, remov\u00ading the edge n. In \nthe putback direction, the value of the old concrete tree is ignored and a new one is created, with a \nsingle edge n pointing to the given abstract tree. (hoist n)/ c (hoist n) (a, c) = = t if c = .. .n n. \nt . . \u00af .. .n n. a . . \u00af .. .\u00af  ! c . VC.T . Vn.N . hoist n . .n n. CC We rely here on our convention \nthat D|p = D to avoid ex\u00adplicitly splitting out the D case in the putback direction. We have now de.ned \nenough basic lenses to implement several useful derived forms for manipulating trees. In many uses of \nxfork, the sets of names specifying where to split the concrete tree and where to split the abstract \ntree are identical. We can de.ne a simpler fork as: ! c! c ! c fork pl1 l2 = xfork ppl1 l2 Vp.N . VC1,A1 \n.T |p. VC2,A2.T \\p. Vl1 . C1 A1 . Vl2 . C2 A2. fork pl1 l2 . (C1 \u00b7 C2 )(A1 \u00b7 A2 ) We can use fork to \nde.ne a lens that discards all of the Conversely, the plunge lens is used to deepen a tree by adding \nan edge at the top. In the get direction, a new tree is created, with a single edge n pointing to the \ngiven concrete tree. In the putback direction, the value of the old concrete tree is ignored and the \nabstract tree is required to have ex\u00ad actly one subtree, labeled n, which becomes the result of the plunge. \n2 Note that, although we are de.ning a syntax for lens ex\u00adpressions, the types used to classify these \nexpressions are semantic they are just sets of lenses or views. We are not (yet! see \u00a79) proposing an \nalgebra of types or an algorithm children of a tree whose names do not belong to some set p: ! c filter \npd = fork p id (const {||} d) VC.T . Vp.N . Vd . C\\p. filter pd . (C|p \u00b7 C\\p)C|p for mechanically checking \nmembership of lens expressions in In the get direction, this lens takes a concrete tree, keeps type expressions. \nthe children with names in p (using id), and throws away the rest (using const {||} d). The tree d is \nused when putting want to be able to perform transformations in the interior an abstract tree into a \nmissing concrete tree, providing a of trees. The map combinator is our fundamental means of default for \ninformation that does not appear in the abstract doing this. When combined with recursion, it also allows \nus tree but is required in the concrete tree. The type of filter to iterate over structures of arbitrary \ndepth. follows directly from the types of the three primitive lenses: The map combinator is parameterized \non a single lens l. In const {||} d, with type C\\p {{||}}, the lens id, with the get direction, map applies \nl/ to each subtree of the root .. C|p, and fork (with the observation that ! .. C|p = C|p \u00b7 {||}). \nwe will de.ne a more general combinator, called wmap, that Another way to thin a tree is to explicitly \nspecify a child can apply a di.erent lens to each subtree.) The putback that should be removed if it \nexists: direction is more interesting. In the simple case where a ! type C|p and combines the results \ntogether into a new tree. (Later, and c have equal domains, its behavior is straightforward: it uses \nl to combine concrete and abstract subtrees with identical names and assembles the results into a new \ncon\u00adcrete tree, c l . In general, however, the abstract tree a in the putback direction need not have \nthe same domain as c (i.e., the edits that produced the new abstract view may have involved adding and \ndeleting children); the behav\u00ad ior of map in this case is a little more involved. Observe, .rst, that \nthe domain of c l is determined by the domain of the abstract argument. Since we aim at building to\u00ad \n.. ` .\u00af\u00b4 . prune nd = fork {n} const {||} .n n. d id VC.T . Vn.N . Vd.C(n). prune nd . (C|n \u00b7 C\\n)C\\n \n! c This lens is similar to filter, except that (1) the name given is the child to be removed, and (2) \nthe default tree is the one to go under n if the concrete tree is D. Conversely, we can grow a tree in \nthe get direction by explicitly adding a child. The type annotation disallows changes in the newly added \ntree, so it can be dropped in the tal lenses, we may suppose that (map l)/ ((map l)(a, c)) is de.ned, \nin which case it must be equal to a by rule putback. add nt = xfork {} {n} (const t {||}; plunge n) id \nVn.N . VC.T \\n. Vt .T . .. .\u00af . add nt . C .n n. {t}\u00b7 C ! c PutGet. Thus dom((map l)/ ((map l)(a, c))) \n= dom(a), hence dom((map l)(a, c)) = dom(a) as the get of map does not change the domain of the tree. \nThis means we can simply drop children that occur in dom(c) but not in dom(a). Children bearing names \nthat occur both in dom(a) and dom(c) are dealt with as described above. This leaves Another lens focuses \nattention on a single child n: the children that only appear in dom(a), which need to be passed through \nl so that they can be included in c l; to do focus nd =(filter {n} d); (hoist n) ! c Vn.N . VC.T \\n.Vd.C. \nVD.T . .. .\u00af . focus nd . (C \u00b7 .n n. D )D In the get direction, focus .lters away all other children, \nthen removes the edge n and yields n s subtree. As usual, the this, we need some concrete argument to \npass to l . There is no corresponding child in c, so instead these abstract trees are put into the missing \ntree D indeed, this case is precisely why we introduced D. Formally, the behavior of map is de\u00ad.ned as \nfollows. (It relies on the convention that c(n)=D if n .. dom(c); the type declaration also involves \nsome new notation, explained below.) ! c ! c .. .\u00af . (map l)/ c = .n n. l/ c(n) | n . dom(c) (map l) \n(a, c)= .. .\u00af . .n n. l (a(n),c(n)) | n . dom(a) VC, A.T with C = Co, A = Ao, dom(C)= dom(A). T Vl . \n( nEN .C(n)A(n)). map l . CA default tree is only used in the case of creation, where it is the default \nfor children that have been .ltered away. Again the type of focus follows from the types of the lenses \nfrom which it is de.ned, observing that filter {n} d . (C \u00b7 {|n n. {|n n. D|} and that hoist ! D|}) ..n \n. {|n n. D|} ..A last derived lens renames a single child. ! D. ! c rename mn = xfork {m}{n} (hoist m; \nplunge n) id Vm, n.N . VC.T . VD.T \\{m,n}. .. .. .\u00af .\u00af .. rename mn . ( .m n. C \u00b7 D)( .n n. C \u00b7 D) Because \nof the way that it takes tree apart, transforms the pieces, and reassembles them, the typing of map is \na lit\u00adtle subtle. For example, in the get direction, map does not In the get direction, rename splits \nthe concrete tree in two. modify the names of the immediate children of the concrete The .rst tree has \na single child m (which is guaranteed to tree and in the putback direction, the names of the abstract \nexist by the type annotation) and is hoisted up, removing tree are left unchanged; we might therefore \nexpect a simple T the edge named m, and then plunged under n. The rest of typing rule stating that, \nif l . ( C(n) nEN ! c A(n)) i.e., the original tree is passed through the id lens. Similarly, the if \nl is a well-behaved lens from the concrete subtree type putback direction splits the abstract view into \na tree with a C(n) to the abstract subtree type A(n) for each child n single child n, and the rest of \nthe tree. The tree under n is then map l . C ! c A. Unfortunately, for arbitrary C and put back using \nthe lens (hoist m; plunge n), which .rst removes the edge named n and then plunges the resulting tree \nunder m. Note that the type annotation on rename demands that the concrete view have a child named m \nand that the abstract view have a child named n. Mapping So far, all of our lens combinators do things \nnear the root of the trees they are given. Of course, we also A, the map lens is not guaranteed to be \nwell-behaved at this type. In particular, if dom(C), the set of domains of trees in C, is not equal to \ndom(A), then the putback function can produce a tree that is not in C, as the following example .. .\u00af.. \n.\u00af .. shows. Consider the sets of trees C = { .x n. m , .y n. n } .. .\u00af . and A = C .{ .x n. m, y n. \nn }, and observe that with . ... .\u00af.\u00af .. trees a = .x n. m, y n. n and c = .x n. m , we have map id \n(a, c)= a, a tree that is not in C. This shows that the type of map must include the requirement that \ndom(C)= dom(A). (Recall that for any type T the set dom(T ) is a set of sets of names.) A related problem \narises when the sets of trees A and C have dependencies between the names of children and the trees that \nmay appear under those names. Again, one might A .nal point of interest is the relation between map \nand the missing tree D. The putback function of every other lens combinator only results in a putback \ninto the missing tree if the combinator itself is called on D. In the case of map l, calling its putback \nfunction on some a and c where c is not the missing tree may result in the application of the putback \nof l toD if a has some children that are not in c. In naively expect that, if l has type C(n) name m, \nthen map l would have type C ! c! c A(m) for each an earlier variant of map, we dealt with missing children \nby A. Consider, providing a default concrete child tree, which would be used however, the set A = {{|x \nn. m, y n. p|}, {|x n. n, y n. q|}} , in which the value m only appears under x when p appears under \ny, and the set C = {{|x n. m, y n. p|}, {|x n. m, y n. q|}, {|x n. n, y n. p|}, {|x n. n, y n. q|}}, \nwhere both m and n appear with both p and q. When we consider just the projections of C and A at speci.c \nnames, we obtain the same sets of subtrees: C(x)= A(x)= {{|m|}, {|n|}} and C(y)= A(y)= {{|p|}, {|q|}}. \nThe lens id has type C(x) ! c A(x) and when no actual concrete tree was available. However, we discovered \nthat, in practice, it is often di.cult to .nd a sin\u00adgle default concrete tree that .ts all possible abstract \ntrees, particularly because of xfork (where di.erent lenses are ap\u00adplied to di.erent parts of the tree) \nand recursion (where the depth of a tree is unknown). We tried parameterizing this default concrete tree \nby the abstract tree and the lens, but noticed that most primitive lenses ignore the concrete tree C(y) \n! c A(y) (and C(z)= . ! c . = A(z) for all other names when de.ning the putback function, as enough information \n is available in the abstract tree. The natural choice for a concrete tree parameterized by a and l was \nthus l (a, D), for some special tree D. The only lens for which the putback function needs to be de.ned \non D is const, as it is the only lens that discards information. This led us to the present design, where \nonly the const lens (and other lenses de.ned from it, such as focus) expects a default tree d. This ap\u00ad \nproach is much more local than the others we tried, since one only needs to provide a default tree at \nthe exact point where information is discarded. z). But it is clearly not the case that map id . C ! \nc A. To avoid this error (but still give a type for map that is precise enough to derive interesting \ntypes for lenses de.ned in terms of map), we require that the source and target sets in the type of map \nbe closed under the shu.ing of their children. Formally, if T is a set of trees, then the set of shu.ings \nof S T , denoted T o , is T o = {|n n. T (n) | n . D|} DEdom(T ) where {|n n. T (n) | n . D|} is the \nset of trees with domain D whose children under n are taken from the set T (n). We say that T is shu.e \nclosed i. T = T o . For instance, in the We now de.ne a more general form of map that is param\u00adexample \nabove, Ao = Co = C i.e., C is shu.e closed, but eterized on a total function from names to lenses. A \nis not. In the situations where map is used, shu.e closure is typ\u00ad ically easy to check. For example, \nany set of trees whose el\u00adements each have singleton domains is shu.e closed. Also, for every set of \ntrees T , the encoding introduced in \u00a77 of lists with elements in T is shu.e closed, which justi.es using \nmap (with recursion) to implement operations on lists. Fur\u00adthermore, types of the form {|n n. T | n . \nN|} with in.nite domain but with the same structure under each edge, which are heavily used in database \nexamples (where the top-level names are keys and the structures under them are records) are shu.e closed. \n! c ! c (wmap m)/ c = .. .\u00af . .n n. m(n)/ c(n) | n . dom(c) (wmap m)(a, c)= .. .\u00af . .n n. m(n)(a(n),c(n)) \n| n . dom(a) VC, A.T with C = Co , A = Ao , dom(C)= dom(A). Vm . (.n.N .C(n)A(n)). wmap m . CA In the \ntype annotation, we use the dependent type notation m . .n. C(n) ! c A(n) to mean that m is a total function \n mapping each name n to a well-behaved lens from C(n) to Another point to note about map is that it does \nnot obey the PutPut law. Consider a lens l and (a, c) . dom(l ) such that l (a, c) .= l (a, D). We have \nA(n). Although m is a total function, we will often describe . .\u00b4 `.. \u00af `..\u00af\u00b4 .. `.. .\u00af\u00b4 (map l) .n \nn. a, ((map l) {||}, .n n. c ) . .. .\u00af =(map l) .n n. a, {||} . = .n n. l (a, D) whereas . . .... .\u00af \n`.\u00af.\u00af\u00b4 . .. .n n. l (a, c) =(map l) .n n. a, .n n. c. Intuitively, there is a di.erence between, on the \none hand, modifying a child n and, on the other, removing it and then adding it back: in the .rst case, \nany information in the concrete view that is projected away in the abstract view will be carried along \nto the new concrete view; in the second, such information will be replaced with default values. This \ndi.erence seems pragmatically reasonable, so we prefer to keep map and lose PutPut. 3 3 Alternatively, \nwe could use a re.nement of the type sys\u00adtem to track when PutPut does hold, annotating some of it by \ngiving its behavior on a .nite set of names and adopting the convention that it maps every other name \nto id. For example, the lens wmap {x n. plunge a} maps plunge a over trees under x and id over the subtrees \nof every other child. Merging It sometimes happens that a concrete represen\u00adtation requires equality \nbetween two distinct subtrees within a view. A merge lens is one way to preserve this invariant when \nthe abstract view is updated. In the get direction, merge takes a tree with two (equal) branches and \ndeletes one of them. In the putback direction, merge copies the up\u00addated value of the remaining branch \nto both branches in the concrete view. the lens combinators with the fact that they are oblivious (i.e., \nignore their concrete argument), and then give map two types: the one we gave here plus another saying \nwhen map is applied to an oblivious lens, the result is very well behaved. (merge mn)/ c = c\\n (merge \nmn)(a, c)= a \u00b7 .n n. a(m) if c(m)= c(n) . .. .\u00af . a \u00b7 .n n. c(n) . if c(m)= c(n) Vm, n.N . VC.T \\{m,n}. \nVD.T . merge mn . .. .\u00af ...\u00af . . (C \u00b7 .m n. DT ,n n. DT )(C \u00b7 .m n. DT ) ...\u00af ! c There is some freedom \nin the type of merge. On one hand, we can give it a precise type that expresses the intended equality \nconstraint in the concrete view; the lens is well\u00adbehaved and total at that type. Alternatively, we can \ngive it a more permissive type (as we do) by ignoring the equality and applies the putback of l1 if it \nsatis.es the predicate and l2 otherwise. l1 / c if c . C1 (ccond C1 l1 l2 )/ c = l1 (a, c) if c . C1 \n(ccond C1 l1 l2)(a, c) = l2 (a, c) if c .. C1 VC, C1 ,A.U. Vl1 . CnC1 A. Vl2 . C\\C1 A. ! c ccond C1 l1 \nl2 . CA ! c /..iflCcc21 ! c A quite di.erent way of de.ning a conditional lens is to make it ignore \nits concrete argument in the putback direction,constraint even if the two original branches are unequal, \nmerge is still de.ned and well-behavedness is preserved. basing its decision whether to use l1 or l2 \nentirely on its abstract argument. Other Tree Lenses The long version of the paper de.nes several additional \ncombinators for manipulating tree struc\u00adtures: a copy lens, which duplicates information in the get direction \nand re-integrates the copied children in the putback direction after performing an equality check (we \nalso dis\u00adcuss problems with the typing of copy and compare it with some variants that have been proposed \nby others), and three lenses for dealing with relational data encoded as trees a .attening combinator \nthat transforms a list of (keyed) records into a bush, a pivoting combinator that can be used to promote \na key .eld to a higher position in the tree, and a transposing combinator related to the outer join operation \non databases. ! c ! c ! c l1/ c if c . C1 (acond C1 A1 l1 l2 )/ c = l2/ c if c .. C1 (acond C1 A1 l1 \nl2 )(a, c)= 8 > l1 (a, c) if a . A1 . c . C1 > < l1 (a, D) if a . A1 . c .. C1 > l2 (a, c) if a .. A1 \n. c .. C1 > : l2 (a, D) if a .. A1 . c . C1 VC, A,C1 ,A1.U. Vl1 . CnC1 AnA1. Vl2 . (C\\C1 )(A\\A1). acond \nC1 A1 l1 l2 . CA  6. CONDITIONALS Conditional lens combinators, which can be used to selec\u00adtively apply \none lens or another to a view, are necessary for writing many interesting derived lenses. Whereas xfork \nand its variants split their input trees into two parts, send each part through a separate lens, and \nrecombine the re\u00adsults, a conditional lens performs some test and sends the whole trees through one or \nthe other of its sub-lenses. The requirement that makes conditionals tricky is totality: we want to be \nable to take a concrete view, put it through a conditional lens to obtain some abstract view, and then \ntake any other abstract view of suitable type and push it back down. But this will only work if either \n(1) we somehow ensure that the abstract view is guaranteed to be sent to the same sub-lens on the way \ndown as we took on the way up, or else (2) the two sub-lenses are constrained to behave coherently. Since \nwe want reasoning about well-behavedness and totality to be compositional in the absence of recursion, \nthe second is unacceptable. Interestingly, once we adopt the .rst approach, we can give a complete characterization \nof all possible conditional lenses: we argue (in the long version of the paper) that every binary conditional \noperator that yields well-behaved and total lenses is an instance of the general cond combi\u00adnator presented \nbelow. Since this general cond is a little complex, however, we start by discussing two particularly \nuseful special cases. Our .rst conditional, ccond, is parameterized on a pred\u00adicate C1 on views and two \nlenses, l1 and l2. In the get direction, it tests the concrete view c and applies the get of l1 if c \nsatis.es the predicate and l2 otherwise. In the putback direction, ccond again examines the concrete \nview, The general conditional, cond, is essentially obtained by combining the behaviors of ccond and \nacond. The concrete conditional requires that the targets of the two lenses be identical, while the abstract \nconditional requires that they be disjoint. More generally, we can let them overlap ar\u00adbitrarily, behaving \nlike ccond in the region where they do overlap (i.e., for arguments (a, c) to putback where a is in the \nintersection of the targets) and like acond in the re\u00adgions where the abstract argument to putback belongs \nto just one of the targets. To this we can add one additional observation: that the use of D in the de.nition \nof acond is actually arbitrary. All that is required is that, when we use the putback of l1 , the concrete \nargument should come from (C1)T , so that l1 is guaranteed to do something good with it. These considerations \nlead us to the following de.nition. (()CAflcond a,c11211 ! c! c ! c (cond C1 A1 A2 f21 f12 l1 l2 )/ c \n= l1 / c if c . C1 l2 / c if c .. C1 A2 f12 l2 ) = 8 l1 (a, c) if a . A1nA2 . c . C1 > > > > l2 (a, c) \nif a . A1nA2 . c .. C1 > < l1 (a, c) if a . A1\\A2 . c . (C1 )T > l1 (a, f21 (c)) if a . A1\\A2 . c .. \n(C1 )T > > > > l2 (a, c) if a . A2\\A1 . c .. C1 : l2 (a, f12 (c)) if a . A2\\A1 . c . C1 VC, C1 ,A1,A2 \n.U. Vl1 . (CnC1 )A1. Vl2 . (C\\C1 )A2. Vf21 . (C\\C1 ) . (CnC1 )T. Vf12 . (CnC1 ) . (C\\C1 )T. cond C1 \nA1 A2 f21 f12 l1 l2 . C (A1.A2) When a is in the targets of both l1 and l2, cond chooses between them \nbased solely on c (as does ccond, whose tar\u00adgets always overlap). If a lies in the range of only l1 or \nl2 , then cond s choice of lens for putback is predetermined (as with acond, whose targets are disjoint). \nOnce l is cho\u00ad list map l = wmap {*h n. l, *t n. list map l} VC, A.T . Vl . C! A. list map l . [C]! [A] \nc c The get direction applies l to the subtree under *h and re\u00ad sen to be either l1 or l2 , if the old \nvalue of c is not in ran(l )T, then we apply a .xup function, f21 or f12 , to c to choose a new value \nfrom ran(l )T . D is one possible result of the .xup functions, but it is sometimes useful to compute \na more interesting one, as we will see in \u00a77.  7. DERIVED LENSES FOR LISTS XML and many other concrete \ndata formats make heavy use of ordered lists. We describe in this section how we can represent lists \nas trees, using a standard cons cell encoding, and introduce some derived lenses to manipulate them. \nWe begin with very simple lenses for projecting the head and tail of a list encoded as a cons cell. We \nthen de.ne recursive lenses implementing some more complex operations on lists: mapping and .ltering. \nIn the long version of the paper, we also show how to derive a list-reversing lens that takes a list \nencoded as a tree and yields the same list in reverse order (in both directions, ignoring its concrete \nargument in the putback direction). Other list-processing derived forms that we have implemented include \na grouping lens that, in the get direction, takes a list whose elements alternate between elements of \nD and elements of E and returns a list of pairs of Ds and Es e.g., it maps [d1e1 d2 e2d3 e3] to [[d1 \ne1] [d2 e2] [d3 e3]]. A tree t is said to be a list i. either it is empty or it has exactly two children, \none named *h and an\u00adother named *t, and t(*t) is also a list. In the follow\u00ading, we use the lighter notation \n[t1 ...tn] for the tree ... . \u00af.\u00af. ...\u00af .... .*h n. t1 *t n. ... n. .*h n. tn *t n. {||} . In types, \nwe write [] for the set {{||}} containing only the empty list, .. .\u00af . C :: D for the set .*h n. C, *t \nn. D of cons cell trees whose head belongs to C and whose tail belongs to D, and [C] for the set of lists \nwith elements in C i.e., the smallest set of trees satisfying [C] = [].(C :: [C]). The interleaving of \na list of type [B] and a list of type [C], taking elements from the .rst list and elements from the second \nin an arbi\u00adtrary fashion but maintaining the relative order of each, is written [B]&#38;[C]. Our .rst \nlist lenses extract the head or tail of a cons cell. c .. .\u00af . hd d = focus *h .*t n. d VC, D.T . Vd.D. \nhd d . (C :: D)! C c .. .\u00af . tl d = focus *t .*h n. d VC, D.T . Vd.C. tl d . (C :: D)! D curses on \nthe subtree under *t. The putback direction uses l on corresponding pairs of elements from the abstract \nand concrete lists. The result has the same length as the abstract list; if the concrete list is longer, \nthe extra tail is thrown away. If it is shorter, each extra element of the ab\u00adstract list is putback \ninto D. Since list map is our .rst recursive lens, it is worth mak\u00ading a few observations about the way \nrecursive calls are made in each direction. The get function of the wmap lens sim\u00adply applies l to the \nhead and list map l to the tail until it reaches a tree with no children. Similarly, in the putback direction, \nwmap applies l to the head of the abstract tree and either the head of the concrete tree (if it is present) \nor D, and it applies list map l to the tail of the abstract tree and the tail of the concrete tree (if \nit is present) or D. In both directions, the recursive calls continue until the entire tree concrete \n(for the get) or abstract (for the putback) has been traversed. Our most interesting derived lens, list \nfilter, is pa\u00adrameterized on two sets of views, D and E, which we as\u00adsume to be disjoint and non-empty. \nIn the get direction, it takes a list whose elements belong to either D or E and projects away those \nthat belong to E, leaving an abstract list containing only Ds; in the putback direction, it restores \nthe projected-away Es from the concrete list. Its de.nition utilizes our most complex lens combinators \nwmap and two forms of conditionals and mutual recursion, yielding a lens that is well-behaved and total \non lists of arbitrary length. In the get direction, the desired behavior of list filter DE (for brevity, \nlet us call it l) is clear. In the putback direction, things are more interesting because there are many \nways that we could restore projected elements from the concrete list. The lens laws impose some constraints \non the behavior of l . The GetPut law forces the putback function to restore each of the .ltered elements \nwhen the abstract list is put into the original concrete list. For example (letting d and e be elements \nof D and E) we must have l ([d], [e d])= [e d]. The PutGet law forces the putback function to include \nevery element of the abstract list in the resulting concrete list, and these elements must be the only \nDs in the result (there is however no restriction on the Es). The behavior that seems most natural to \nus is to overwrite elements of D in c with elements of D from a, element-wise, until either c or a runs \nout of elements of D. If c runs out .rst, then l appends the rest of the elements of a at the end of \nc. If a runs out .rst, then l restores the remaining Es from the end of c and discards any remaining \nDs in c (as it must to satisfy PutGet). The lens hd expects a default tree, which it uses in the putback \ndirection as the tail of the created tree when the concrete tree is missing; in the get direction, it \nreturns the tree under *h. The lens tl works analogously. Note that the types of these lenses apply to \nboth homogeneous lists (the ! type of hd implies VC.T . Vd.[C]. hd d . [C] ..C) as well as cons cells \nwhose head and tail have unrelated types. The types of hd and tl follow from the type of focus. The list \nmap lens applies l to each element of a list: These choices lead us to the following speci.cation for \na single step of the putback part of a recursively de.ned lens implementing l. If the abstract list a \nis empty, then we restore all the Es from c. If c is empty and a is not empty, then we return a. If a \nand c are both cons cells whose heads are in D, then we return a cons cell whose head is the head of \na and whose tail is the result obtained by recursing on the tails of both a and c. Otherwise (i.e., c \nhas type E :: ([D]&#38;[E])) we restore the head of c and recurse on a and the tail of c. Translating \nthis into lens combinators leads to the de.nition below of list filter and a helper lens, inner filter, \nby mutual recursion.4 The de.nitions involve a little new notation and a few additional technicalities, \nexplained below. list filter DE = cond [E] [] (D :: [D]) .trE (Ac. c@[anyD]) (const [] []) (inner filter \nDE) inner filter DE = ccond (E ::((D :: [D])&#38;[E])) (tl anyE ; inner filter DE) (wmap {*h n. id, *t \nn. list filter DE}) VD, E.T . with D n E = . and D .= . and E .= .. ! list filter DE . [D]&#38;[E] c \n[D] and ! inner filter DE . (D :: [D])&#38;[E] c (D :: [D]) The choice operator anyD denotes an arbitrary \nelement of the (non-empty) set D. 5 The function .trE is the usual list-.ltering function, which for \npresent purposes we simply assume has been de.ned as a primitive. (In our implementa\u00adtion, we actually \nuse list filter/.) Finally, the function Ac. c@[anyD] appends some arbitrary element of D to the right-hand \nend of a list c. These .xup functions are ap\u00adplied in the putback direction by the cond lens. The behavior \nof the get function of list filter can be described as follows. If c . [E], then the outermost cond selects \nthe const [] [] lens, which produces []. Otherwise the cond selects inner filter, which uses a ccond \ninstance to test if the head of the list is in E. If this test succeeds, it strips away the head using \ntl and recurses; if not, it retains the head and .lters the tail using wmap. In the putback direction, \nif a = [] then the outermost cond lens selects the const[] [] lens, with c as the concrete argu\u00adment \nif c . [E] and (.trE c) otherwise. This has the e.ect of restoring all of the Es from c. Otherwise, if \na =.[] then the cond instance selects the putback of the inner filter lens, using c as the concrete argument \nif c contains at least one D, and (Ac. c@[anyD]) c, which appends a dummy value of type D to the tail \nof c, if not. The dummy value, anyD, is required because inner filter expects a concrete argument that \ncontains at least one D. Intuitively, the dummy value marks the point where the head of a should be placed. \nTo illustrate how all this works, let us step through some examples in detail. In each example, the concrete \ntype is [D]&#38;[E] and the abstract type is [D]. We will write di and ej to stand for elements of D \nand E respec\u00adtively. To shorten the presentation, we will write l for list filter DE and i for inner \nfilter DE. In the .rst example, the abstract tree a is [d1 ], and the concrete tree 4 The singly recursive \nvariant where inner filter is in\u00adlined has the same dynamic behavior as the version pre\u00adsented here. \nWe split out inner filter so that we can give it a more precise type, facilitating reasoning about well\u00adbehavedness \nand totality: in the get direction it maps lists containing at least one D to (D :: [D]); the corresponding \ntypes for list filter include empty lists. 5 We are dealing with countable sets of .nite trees here, \nso this construct poses no metaphysical conundrums; alterna\u00adtively, but less readably, we can pass list \nfilter an extra argument d . D. c is [e1 d2 e2]. At each step, we underline the term that is simpli.ed \nin the next step. l (a, c) = i (a, c) by the de.nition of cond, as a . (D :: [D]) and c . ([D]&#38;[E]) \n\\ [E] = (tl anyE ; i) (a, c) by the de.nition of ccond, as c . E :: ((D :: [D])&#38;[E]) =(tl anyE ) \ni a, (tl anyE )/ c ,c by the de.nition of composition  =(tl anyE ) i (a, [d2 e2 ]),c reducing (tl anyE \n)/ c  =(tl anyE ) wmap {*h n. id, *t n. l} by the de.nition of ccond, as [d2 e2] .. E ::((D :: [D])&#38;[E]) \n =(tl anyE ) d1 ::(l ([], [e2 ])),c (a, [d2 by the de.nition of wmap with id (d1, d2 )= d1  =(tl anyE \n) d1 ::((const [] [])([], [e2 ])),c by the de.nition of cond, as [] . [] and [e2 ] . [E] =(tl anyE )(d1 \n:: [e2 ],c) by the de.nition of const = [e1 d1 e2] by the de.nition of tl. The .nal two examples illustrate \nhow the .xup functions supplied to the cond lens are used. The .rst function, .trE , is used when the \nabstract list is empty and the concrete list is not in [E]. Let a = [] and c = [d1 e1]. l (a, c)=(const \n[] []) [], .trE [d1 e1 ] by the de.nition of cond, as a = [] but c .. [E] =(const [] [])([], [e1 ]) by \nthe de.nition of .trE = [e1 ] by de.nition of const. The other .xup function, (Ac. c@[anyD ]), inserts \na dummy D element when list filter is called with a non-empty abstract list and a concrete list whose \nelements are all in E. Let a = [d1 ] and c = [e1 ] and assume that anyD = d0 . l (a, c)= i a, (Ac. c@[anyD \n]) c by the de.nition of cond, as a . (D :: [D]) and c . [E] = i (a, [e1 d0]) by the de.nition of (Ac. \nc@[anyD]) = (tl anyE ; i) (a, [e1 d0]) by the de.nition of ccond, = (tl anyE as [e1 d0] . E :: ((D :: \n[D])D&#38;[E]) ) i a, (tl anyE )/ [e1 d0] , [e1 d0 ] = (tl anyE by the de.nition of composition ) \n i (a, [d0 ]), [d0 e1 ] reducing (tl anyE )/ [d0 e1 ] = (tl anyE ) wmap {*h n. id, *t n. l} (a, [d0]), \n[e1 d0 ] by the de.nition of ccond, as [d0 ] .. E :: ((D :: [D])&#38;[E])  e2]),c =(tl anyE ) d1 ::(l \n([], [])), [e1 d0] by the de.nition of wmap with id (d1, d0)= d1 =(tl anyE ) d1 ::((const [] [])([], \n[])), [e1 d0 ] by the de.nition of cond, as [] . [] and [] . [E] =(tl anyE )(d1 :: [], [e1 d0 ]) by the \nde.nition of const = [e1 d1] by the de.nition of tl.  8. RELATED WORK Our lens combinators evolved in \nthe setting of the Harmony data synchronizer. The overall architecture of Harmony and the role of lenses \nin building synchronizers for various forms of data are described in [26], along with a detailed discussion \nof related work on synchronization. Our foundational structures lenses and their laws are not new: closely \nrelated structures have been studied for decades in the database community. However, our treat\u00adment of \nthese structures is arguably simpler (transforming states rather than update functions ) and somewhat \nmore re.ned (treating well-behavedness as a form of type asser\u00adtion). Our formulation is also novel in \nconsidering the is\u00adsue of continuity, thus supporting a rich variety of surface language structures including \nde.nition by recursion. The idea of de.ning programming languages for constructing bi\u00addirectional transformations \nof various sorts has also been explored previously in diverse communities. We appear to be the .rst to \ntake totality as a primary goal (while connect\u00ading the language with a formal semantic foundation, choos\u00ading \nprimitives that can be combined into composite lenses whose totality is guaranteed by construction), \nand the .rst to emphasize types (i.e., compositional reasoning) as an or\u00adganizing design principle. Foundations \nof View Update The foundations of view update translation were studied intensively by database re\u00adsearchers \nin the late 70s and 80s. This thread of work is closely related to our semantics of lenses in \u00a73. Dayal \nand Bernstein [11] gave a seminal formal account of the theory of correct update translation. Their notion \nof exactly performing an update corresponds to our Put-Get law. Their absence of side e.ects corresponds \nto our GetPut and PutPut laws. Their requirement of preserva\u00adtion of semantic consistency corresponds \nto the partiality of our putback functions. Bancilhon and Spyratos [6] developed an elegant semantic \ncharacterization of update translation, introducing the no\u00adtion of complement of a view, which must include \nat least all information missing from the view. When a complement is .xed, there exists at most one update \nof the database that re.ects a given update on the view while leaving the com\u00adplement unmodi.ed i.e., \nthat translates updates under a constant complement. In general, a view may have many complements, each \ncorresponding to a possible strategy for translating view updates to database updates. The prob\u00adlem of \ntranslating view updates then becomes a problem of .nding, for a given view, a suitable complement. Gottlob, \nPaolini, and Zicari [13] o.ered a more re.ned theory based on a syntactic translation of view updates. \nThey identi.ed a hierarchy of restricted cases of their frame\u00adwork, the most permissive form being their \ndynamic views and the most restrictive, called cyclic views with constant complement, being formally \nequivalent to Bancilhon and Spyratos s update translators. In a companion report [25], we state a precise \ncorrespon\u00addence between our lenses and the structures studied by Bancilhon and Spyratos and by Gottlob, \nPaolini, and Zi\u00adcari. Brie.y, our set of very well behaved lenses is isomor\u00adphic to the set of translators \nunder constant complement in the sense of Bacilhon and Spyratos, while our set of well\u00adbehaved lenses \nis isomorphic to the set of dynamic views in the sense of Gottlob, Paolini, and Zicari. To be precise, \nboth of these results must be quali.ed by an additional con\u00addition regarding partiality. The frameworks \nof Bacilhon and Spyratos and of Gottlob, Paolini, and Zicari are both formu\u00adlated in terms of translating \nupdate functions on A into up\u00addate functions on C, i.e., their putback functions have type (A -. A) -. \n(C -. C), while our lenses translate ab\u00adstract states into update functions on C, i.e., our putback functions \nhave type (isomorphic to) A -. (C -. C). Moreover, in both of these frameworks, update transla\u00adtors (the \nanalog of our putback functions) are de.ned only over some particular chosen set U of abstract update \nfunc\u00adtions, not over all functions from A to A. These update translators return total functions from \nC to C. Our putback functions, on the other hand, are de.ned over all abstract states and return partial \nfunctions from C to C. Finally, the get functions of lenses are allowed to be partial, whereas the corresponding \nfunctions (called views) in the other two frameworks are assumed to be total. In order to make the correspondences \ntight, our sets of well-behaved and very well behaved lenses need to be restricted to subsets that are \nalso total in a suitable sense. Recent work by Lechtenb\u00a8orger [17] establishes that trans\u00adlations of \nview updates under constant complements are pos\u00adsible precisely if view update e.ects may be undone using \nfurther view updates. In the literature on programming languages, laws similar to our lens laws (but \nsomewhat simpler, dealing only with total get and putback functions) appear in Oles category of state \nshapes [24] and in Hofmann and Pierce s work on positive subtyping [14]. Languages for Bi-Directional \nTransformations At the level of syntax, di.erent forms of bi-directional pro\u00adgramming have been explored \nacross a surprisingly diverse range of communities, including programming languages, databases, program \ntransformation, constraint-based user interfaces, and quantum computing. One useful way of clas\u00adsifying \nthese languages is by the shape of the semantic space in which their transformations live. We identify \nthree major classes: Bi-directional languages, including ours, form lenses by pairing a get function \nof type C . A with a putback function of type A \u00d7 C . C. In general, the get function can project away \nsome information from the concrete view, which must then be restored by the putback function. In bi\u00adjective \nlanguages, the putback function has the simpler type A . C it is given no concrete argument to refer \nto. To avoid loss of information, the get and putback functions must form a (perhaps partial) bijection \nbetween C and A. Re\u00adversible languages go a step further, demanding only that the work performed by any \nfunction to produce a given out\u00adput can be undone by applying the function in reverse working backwards \nfrom this output to produce the origi\u00adnal input. Here, there is no separate putback function at all: \ninstead, the get function itself is constructed so that each step can be run in reverse. We survey relevant \nwork in the .rst two classes in detail next; information on reversible languages (whose concerns are \nless closely related) can be found in the long version of the paper. In the .rst class, the work that \nis fundamentally most similar to ours is Meertens s formal treatment of con\u00adstraint maintainers for constraint-based \nuser interfaces [21]. Meertens s semantic setting is actually even more general: he takes get and putback \nto be relations, not just functions, and his constraint maintainers are symmetric: get relates pairs \nfrom C \u00d7 A to elements of A and putback relates pairs in A \u00d7 C to elements of C. Taking the special case \nwhere the get relation is actually a function (which is important for Meertens because this is the case \nwhere composition [in the sense of our ; combinator] is guaranteed to preserve well\u00adbehavedness), yields \nessentially our very well behaved lenses. Meertens proposes a variety of combinators for building con\u00adstraint \nmaintainers, most of which have analogs among our lenses, but does not directly deal with de.nition by \nrecur\u00adsion; also, some of his combinators do not support com\u00adpositional reasoning about well-behavedness. \nHe considers constraint maintainers for structured data such as lists, as we do for trees, but here adopts \na rather di.erent point of view from ours, focusing on constraint maintainers that work with structures \nnot directly but in terms of the edit scripts that might have produced them. In the terminol\u00adogy of synchronization, \nhe switches from a state-based to an operation-based treatment at this point. Recent work of Mu, Hu, \nand Takeichi on injective lan\u00adguages for view-update-based structure editors [22] adopts a similar perspective. \nAlthough their transformations obey our GetPut law, their notion of well-behaved transforma\u00adtions is \ninformed by di.erent goals than ours, leading to a weaker form of the PutGet law. A primary concern is \nusing the view-to-view transformations to simultaneously restore invariants within the source view as \nwell as update the con\u00adcrete view. Another paper by Hu, Mu, and Takeichi [15] applies a bi-directional \nprogramming language quite closely related to ours to the design of programmable editors for structured \ndocuments. As in [22], they support preservation of local invariants in the putback direction. Here, \ninstead of modifying the abstract view, they assume that a putback or a get occurs after every modi.cation \nto either view. They use this only one update assumption to choose the cor\u00adrect inverse for the lens \nthat copied data in the get direction because only one branch can have been modi.ed at any given time. \nConsequently, they can putback the data from the modi.ed branch and overwrite the unmodi.ed branch. Here, \nas in [22], the notion of well-behavedness must be weakened. We discuss these variants further in the \nfull pa\u00adper, in the section discussing our copy and merge lenses. The TRIP2 system (e.g., [19]) uses \nbidirectional transfor\u00admations speci.ed as collections of Prolog rules as a means of implementing direct-manipulation \ninterfaces for application data structures. The get and putback components of these mappings are written \nseparately by the user. Languages for Bijective Transformations An active thread of work in the program \ntransformation community concerns program inversion and inverse computation see, for example, [3, 4] \nand many other papers cited there. Pro\u00adgram inversion derives the inverse program from the forward program. \nInverse computation computes a possible input of a program from a particular output. One approach to \nin\u00adverse computation is to design languages that produce easily invertible expressions for example, languages \nthat can only express injective functions, where every program is trivially invertible. These languages \nbear some intriguing similarities to ours, but di.er in a number of ways, primarily in their focus on \nthe bijective case. In the database community, Abiteboul, Cluet, and Milo [1] de.ned a declarative language \nof correspondences between parts of trees in a data forest. In turn, these correspon\u00addence rules can \nbe used to translate one tree format into another through non-deterministic Prolog-like computation. \nThis process assumes an isomorphism between the two data formats. The same authors [2] later de.ned a \nsystem for bi-directional transformations based around the concept of structuring schemas (parse grammars \nannotated with se\u00admantic information). Thus their get functions involved pars\u00ading, whereas their putbacks \nconsisted of unparsing. Again, to avoid ambiguous abstract updates, they restricted them\u00adselves to lossless \ngrammars that de.ne an isomorphism be\u00adtween concrete and abstract views. Ohori and Tajima [23] developed \na statically-typed poly\u00admorphic record calculus for de.ning views on object-oriented databases. They \nspeci.cally restricted which .elds of a view are updatable, allowing only those with a ground (simple) \ntype to be updated, whereas our lenses can accommodate structural updates as well. A related idea from \nthe functional programming commu\u00adnity, called views [29], extends algebraic pattern matching to abstract \ndata types using programmer-supplied in and out operators. Update Translation for Tree Views There have \nbeen many proposals for query languages for trees (e.g., XQuery and its forerunners, UnQL, StruQL, and \nLorel), but these either do not consider the view update problem at all or else handle update only in \nsituations where the abstract and concrete views are isomorphic. For example, Braganholo, Davidson, and \nHeuser [8] and others studied the problem of updating relational databases presented as XML. Their solution \nrequires a 1:1 mapping between XML view elements and objects in the database, to make updates unambiguous. \nTatarinov, Ives, Halevy, and Weld [28] described a mechanism for translating up\u00addates on XML structures \nthat are stored in an underlying relational database. In this setting there is again an iso\u00admorphism \nbetween the concrete relational database and the abstract XML view, so updates are unambiguous rather, \nthe problem is choosing the most e.cient way of translating a given XML update into a sequence of relational \noperations. The view update problem has also been studied in the context of object-oriented databases. \nSchool, Laasch, and Tresch [27] restrict the notion of views to queries that pre\u00adserve object identity. \nThe view update problem is greatly simpli.ed in this setting, as the objects contained in the view are \nthe objects of the database, and an update on the view is directly an update on objects of the database. \nUpdate Translation for Relational Views Research on view update translation in the database literature \nhas tended to focus on taking an existing language for de.ning get functions (e.g., relational algebra) \nand then considering how to infer corresponding putback functions, either auto\u00admatically or with some \nuser assistance. By contrast, we have designed a new language in which the de.nitions of get and putback \ngo hand-in-hand. Our approach also goes beyond classical work in the relational setting by directly transform\u00ading \nand updating tree-structured data, rather than .at re\u00adlations. (Of course, trees can be encoded as relations, \nbut it is not clear how our tree-manipulation primitives could be expressed using the recursion-free \nrelational languages con\u00adsidered in previous work in this area.) We brie.y review the most relevant research \nfrom the relational setting. Masunaga [18] described an automated algorithm for translating updates on \nviews de.ned by relational algebra. The core idea was to annotate where the semantic ambi\u00adguities arise, \nindicating they must be resolved either with knowledge of underlying database semantic constraints or \nby interactions with the user. Keller [16] catalogued all possible strategies for handling updates to \na select-project-join view and showed that these are exactly the set of translations that satisfy a small \nset of intuitive criteria. Building on this foundation, Barsalou, Siambela, Keller, and Wiederhold [7] \ndescribed a scheme for interactively constructing update translators for object\u00adbased views of relational \ndatabases. Medeiros and Tompa [20] presented a design tool for ex\u00adploring the e.ects of choosing a view \nupdate policy. This tool shows the update translation for update requests sup\u00adplied by the user; by considering \nall possible valid concrete states, the tool predicts whether the desired update would in fact be re.ected \nback into the view after applying the translated update to the concrete database. Atzeni and Torlone \n[5] described a tool for translating views and observed that if one can translate any concrete view to \nand from a meta-model (shared abstract view), one then gets bi-directional transformations between any \npair of concrete views. They limited themselves to mappings where the concrete and abstract views are \nisomorphic. Complexity bounds have also been studied for various ver\u00adsions of the view update inference \nproblem. In one of the earliest, Cosmadakis and Papadimitriou [10] considered the view update problem \nfor a single relation, where the view is a projection of the underlying relation, and showed that there \nare polynomial time algorithms for determining whether in\u00adsertions, deletions, and tuple replacements \nto a projection view are translatable into concrete updates. More recently, Buneman, Khanna, and Tan \n[9] established a variety of in\u00adtractability results for the problem of inferring minimal view updates \nin the relational setting for query languages that include both join and either project or union.  9. \nCONCLUSIONS AND FUTURE WORK We have worked to design a collection of combinators that .t together in \na sensible way and that are easy to program with. Starting with lens laws that de.ne reasonable be\u00adhavior, \nadding type annotations, and proving that each of our lenses is total, has imposed strong constraints \non our design of new lenses constraints that, paradoxically, make the design process easier. In the early \nstages of the Harmony project, working in an under-constrained design space, we found it extremely di.cult \nto converge on a useful set of primitive lenses. Later, when we understood how to im\u00adpose the framework \nof type declarations and the demand for compositional reasoning, we experienced a huge increase in manageability. \nThe types helped not just in .nding pro\u00adgramming errors in derived lenses, but in exposing design mistakes \nin the primitives at an early stage. Naturally, the progress we have made on lens combina\u00adtors raises \na host of further challenges. The most urgent of these is automated typechecking. At present, it is the \nlens programmers responsibility to check the well-behavedness of the lenses that they write. But the \ntypes of the prim\u00aditive combinators have been designed so that these checks are both local and essentially \nmechanical. The obvious next step is to reformulate the type declarations as a type alge\u00adbra and .nd \na mechanical procedure for checking (or, more ambitiously, inferring) types. A number of other interesting \nquestions are related to static analysis of lenses. For instance, can we characterize the complexity \nof programs built from these combinators? Is there an algebraic theory of lens combinators that would \nunderpin optimization of lens expressions in the same way that the relational algebra and its algebraic \ntheory are used to optimize relational database queries? (For example, the combinators we have described \nhere have the property that map l1 ; map l2 = map (l1; l2 ) for all l1 and l2 , but the latter should \nrun substantially faster.) This algebraic theory will play a crucial role in a more serious implementation \ne.ort. Our current prototype per\u00adforms a straightforward translation from a concrete syntax similar to \nthe one used in this paper to a combinator library written in OCaml. This is fast enough for experimenting \nwith lens programming (Malo Denielou has built an inter\u00adactive programming environment that recompiles \nand re\u00adapplies lenses on every keystroke) and for small demos (our calendar lenses can process a few \nthousands of appointments in under a minute), but we would like to apply the Harmony system to applications \nsuch as synchronization of biological databases that will require much higher throughput. Another area \nfor further investigation is the design of ad\u00additional combinators. While we have found the ones we have \ndescribed here to be expressive enough to code a large number of examples both intricate structural manipula\u00adtions \nsuch as the list transformations in \u00a77 and more pro\u00adsaic application transformations such as the ones \nneeded by our bookmark synchronizer there are some areas where we would like more general forms of the \nlenses we have (e.g., a more .exible form of xfork, where the splitting and re\u00adcombining of trees is \nnot based on top-level names, but involves deeper structure), lenses expressing more global transformations \non trees (including analogs of database op\u00aderations such as join), or lenses addressing completely dif\u00adferent \nsorts of transformations (e.g., none of our combinators do any signi.cant processing on edge labels, \nwhich might in\u00adclude string processing, arithmetic, etc.). Higher-level com\u00adbinators embodying more global \ntransformations on trees perhaps modeled on a familiar notation such as XSLT are another interesting \npossibility. More generally, what are the limits of bi-directional pro\u00adgramming? How expressive are the \ncombinators we have de.ned here? Do they cover any known or succinctly char\u00adacterizable classes of computations \n(in the sense that the set of get parts of the total lenses built from these combi\u00adnators coincide with \nthis class)? We have put considerable energy into these questions, but at the moment we can only report \nthat they are challenging! One reason for this is that questions about expressiveness tend to have trivial \nanswers when phrased semantically. For example, it is not hard to show that any surjective get function \ncan be equipped with a putback function indeed, typically many to form a total lens. Indeed, if the concrete \ndomain C is recursively enu\u00admerable, then this putback function is even computable. The real problems \nare thus syntactic how to conveniently pick out a putback function that does what is wanted for a given \nsituation. Finally, we intend to experiment with instantiating our semantic framework with other structures \nbesides trees in particular, with relations, to establish closer links with existing research on the \nview update problem in databases. Acknowledgements The Harmony project was begun in collaboration with \nZhe Yang. Owen Gunden and, more recently, Malo Denielou have also collaborated with us on many aspects \nof the Har\u00admony design and implementation. Trevor Jim provided the initial push to start the project. \nConversations with Martin Hofmann, Zack Ives, Nitin Khandelwal, Sanjeev Khanna, William Lovas, Kate Moore, \nCyrus Najmabadi, Penny An\u00adderson, and Steve Zdancewic helped us sharpen our ideas. Serge Abiteboul, Zack \nIves, Dan Suciu, and Phil Wadler pointed us to related work. We would also like to thank Karthik Bhargavan, \nVanessa Braganholo, Peter Buneman, Michael Hicks, Norman Ramsey, Wang-Chiew Tan, Stephen Tse, and several \nanonymous referees for helpful comments. The Harmony project is supported by the National Science Foundation \nunder grant ITR-0113226, Principles and Prac\u00adtice of Synchronization. 10. REFERENCES [1] S. Abiteboul, \nS. Cluet, and T. Milo. Correspondence and translation for heterogeneous data. In Proceedings of 6th Int. \nConf. on Database Theory (ICDT), 1997. [2] S. Abiteboul, S. Cluet, and T. Milo. A logical view of structure \n.les. VLDB Journal, 7(2):96 114, 1998. [3] S. M. Abramov and R. Gl\u00a8uck. The universal resolving algorithm: \nInverse computation in a functional language. In R. Backhouse and J. N. Oliveira, editors, Mathematics \nof Program Construction, volume 1837, pages 187 212. Springer-Verlag, 2000. [4] S. M. Abramov and R. \nGl\u00a8uck. Principles of inverse computation and the universal resolving algorithm. In T. Mogensen, D. \nSchmidt, and I. H. Sudborough, editors, The Essence of Computation: Complexity, Analysis, Transformation, \nvolume 2566 of Lecture Notes in Computer Science, pages 269 295. Springer-Verlag, 2002. [5] P. Atzeni \nand R. Torlone. Management of multiple models in an extensible database design tool. In Proceedings of \nEDBT 96, LNCS 1057, 1996. [6] F. Bancilhon and N. Spyratos. Update semantics of relational views. TODS, \n6(4):557 575, 1981. [7] T. Barsalou, N. Siambela, A. M. Keller, and G. Wiederhold. Updating relational \ndatabases through object-based views. In PODS 91, pages 248 257, 1991. [8] V. Braganholo, S. Davidson, \nand C. Heuser. On the updatability of XML views over relational databases. In WebDB 2003, 2003. [9] \nP. Buneman, S. Khanna, and W.-C. Tan. On propagation of deletions and annotations through views. In PODS \n02, pages 150 158, 2002. [10] S. S. Cosmadakis and C. H. Papadimitriou. Updates of relational views. \nJournal of the ACM, 31(4):742 760, 1984. [11] U. Dayal and P. A. Bernstein. On the correct translation \nof update operations on relational views. TODS, 7(3):381 416, September 1982. [12] J. N. Foster, M. B. \nGreenwald, J. T. Moore, B. C. Pierce, and A. Schmitt. Combinators for bi-directional tree transformations: \nA linguistic approach to the view update problem. Technical Report MS-CIS-04-15, University of Pennsylvania, \nAug. 2004. An earlier version appeared in the Workshop on Programming Language Technologies for XML (PLAN-X), \n2004, under the title A Language for Bi-Directional Tree Transformations .  [13] G. Gottlob, P. Paolini, \nand R. Zicari. Properties and update semantics of consistent views. ACM Transactions on Database Systems \n(TODS), 13(4):486 524, 1988. [14] M. Hofmann and B. Pierce. Positive subtyping. In ACM SIGPLAN SIGACT \nSymposium on Principles of Programming Languages (POPL), San Francisco, California, pages 186 197, Jan. \n1995. Full version in Information and Computation, volume 126, number 1, April 1996. Also available as \nUniversity of Edinburgh technical report ECS-LFCS-94-303, September 1994. [15] Z. Hu, S.-C. Mu, and M. \nTakeichi. A programmable editor for developing structured documents based on bi-directional transformations. \nIn Partial Evaluation and Program Manipulation (PEPM), 2004. [16] A. M. Keller. Algorithms for translating \nview updates to database updates for views involving selections, projections, and joins. In PODS 85, \n1985. [17] J. Lechtenb\u00a8orger. The impact of the constant complement approach towards view updating. In \nProceedings of the 22nd ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems, pages 49 \n55. ACM, June 9 12 2003. San Diego, CA. [18] Y. Masunaga. A relational database view update translation \nmechanism. In VLDB 84, 1984. [19] S. Matsuoka, S. Takahashi, T. Kamada, and A. Yonezawa. A general framework \nfor bi-directional translation between abstract and pictorial data. ACM Transactions on Information Systems, \n10(4):408 437, October 1992. [20] C. M. B. Medeiros and F. W. Tompa. Understanding the implications of \nview update policies. In VLDB 85, 1985. [21] L. Meertens. Designing constraint maintainers for user interaction, \n1998. Manuscript. [22] S.-C. Mu, Z. Hu, and M. Takeichi. An algebraic approach to bi-directional updating. \nIn ASIAN Symposium on Programming Languages and Systems (APLAS), Nov. 2004. [23] A. Ohori and K. Tajima. \nA polymorphic calculus for views and object sharing. In PODS 94, 1994. [24] F. J. Oles. Type algebras, \nfunctor categories, and block structure. In M. Nivat and J. C. Reynolds, editors, Algebraic Methods in \nSemantics. Cambrige University Press, 1985. [25] B. C. Pierce and A. Schmitt. Lenses and view update \ntranslation. Manuscript, 2003. [26] B. C. Pierce, A. Schmitt, and M. B. Greenwald. Bringing Harmony to \noptimism: A synchronization framework for heterogeneous tree-structured data. Technical Report MS-CIS-03-42, \nUniversity of Pennsylvania, 2003. [27] M. H. Scholl, C. Laasch, and M. Tresch. Updatable Views in Object-Oriented \nDatabases. In C. Delobel, M. Kifer, and Y. Yasunga, editors, Proc. 2nd Intl. Conf. on Deductive and Object-Oriented \nDatabases (DOOD), number 566. Springer, 1991. [28] I. Tatarinov, Z. G. Ives, A. Y. Halevy, and D. S. \nWeld. Updating XML. In SIGMOD Conference, 2001. [29] P. Wadler. Views: A way for pattern matching to \ncohabit with data abstraction. In ACM Symposium on Principles of Programming Languages (POPL), Munich, \nGermany. 1987.   \n\t\t\t", "proc_id": "1040305", "abstract": "We propose a novel approach to the well-known <i>view update problem</i> for the case of tree-structured data: a domain-specific programming language in which all expressions denote bi-directional transformations on trees. In one direction, these transformations---dubbed <i>lenses</i>---map a \"concrete\" tree into a simplified \"abstract view\"; in the other, they map a modified abstract view, together with the original concrete tree, to a correspondingly modified concrete tree. Our design emphasizes both robustness and ease of use, guaranteeing strong well-behavedness and totality properties for well-typed lenses.We identify a natural space of well-behaved bi-directional transformations over arbitrary structures, study definedness and continuity in this setting, and state a precise connection with the classical theory of \"update translation under a constant complement\" from databases. We then instantiate this semantic framework in the form of a collection of <i>lens combinators</i> that can be assembled to describe transformations on trees. These combinators include familiar constructs from functional programming (composition, mapping, projection, conditionals, recursion) together with some novel primitives for manipulating trees (splitting, pruning, copying, merging, etc.). We illustrate the expressiveness of these combinators by developing a number of bi-directional list-processing transformations as derived forms.", "authors": [{"name": "J. Nathan Foster", "author_profile_id": "81100121184", "affiliation": "University of Pennsylvania", "person_id": "PP43116414", "email_address": "", "orcid_id": ""}, {"name": "Michael B. Greenwald", "author_profile_id": "81100237510", "affiliation": "University of Pennsylvania", "person_id": "P548416", "email_address": "", "orcid_id": ""}, {"name": "Jonathan T. Moore", "author_profile_id": "81100045762", "affiliation": "University of Pennsylvania", "person_id": "PP39024686", "email_address": "", "orcid_id": ""}, {"name": "Benjamin C. Pierce", "author_profile_id": "81100303310", "affiliation": "University of Pennsylvania", "person_id": "PP14111353", "email_address": "", "orcid_id": ""}, {"name": "Alan Schmitt", "author_profile_id": "81326492348", "affiliation": "University of Pennsylvania", "person_id": "PP37022719", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1040305.1040325", "year": "2005", "article_id": "1040325", "conference": "POPL", "title": "Combinators for bi-directional tree transformations: a linguistic approach to the view update problem", "url": "http://dl.acm.org/citation.cfm?id=1040325"}