{"article_publication_date": "01-12-2005", "fulltext": "\n A Framework for Numeric Analysis of Array Operations* \u00a7 Denis Gopan Thomas Reps Mooly SagivUniversity \nof Wisconsin University of Wisconsin Tel-Aviv University gopan@cs.wisc.edu reps@cs.wisc.edu msagiv@post.tau.ac.il \nABSTRACT Automatic discovery of relationships among values of array elements is a challenging problem \ndue to the unbounded na\u00adture of arrays. We present a framework for analyzing array operations that is \ncapable of capturing numeric properties of array elements. In particular, the analysis is able to es\u00adtablish \nthat all array elements are initialized by an array\u00adinitialization loop, as well as to discover numeric \nconstraints on the values of initialized elements. The analysis is based on the combination of canonical \nab\u00adstraction and summarizing numeric domains. We describe a prototype implementation of the analysis \nand discuss our experience with applying the prototype to several examples, including the veri.cation \nof correctness of an insertion-sort procedure. Categories and Subject Descriptors D.3.1 [Formal De.nitions \nand Theory]: Semantics; F.3.2 [Semantics of Programming Languages]: Program anal\u00adysis General Terms \nLanguages, Veri.cation  Keywords Program analysis, array analysis, abstract numeric domains, canonical \nabstraction, summarization * Supported in part by ONR under contract N00014-01-1-0796. Supported in \npart by a Cisco Systems Wisconsin Distinguished Graduate Fellowship. Supported in part by NSF under \ngrant CCR-9986308, by ONR under contract N00014-01-1-0708, and by the Alexander von Humboldt Foundation. \n\u00a7 Supported in part by a grant from the Israeli Academy of Science and by the Alexander von Humboldt \nFoundation. Permission to make digital or hard copies of all or part of this work for personal or classroom \nuse is granted without fee provided that copies are not made or distributed for pro.t or commercial advantage \nand that copies bear this notice and the full citation on the .rst page. To copy otherwise, to republish, \nto post on servers or to redistribute to lists, requires prior speci.c permission and/or a fee. POPL \n05, January 12 14, 2005, Long Beach, California, USA. Copyright 2005 ACM 1-58113-830-X/05/0001 ...$5.00. \n1. INTRODUCTION An array is a simple and e.cient data structure that is heavily used. In many cases, \nto verify the correctness of programs that use arrays an analysis needs to be able to discover relationships \namong values of array elements, as well as their relationships to scalar variables and constants. For \nexample, in scienti.c programing, a sparse matrix is rep\u00adresented with several arrays, and indirect indexing \nis used to access matrix elements. In this case, to verify that all array accesses are in bounds, an \nanalysis has to discover up\u00adper and lower bounds on the elements stored in the index arrays. Mutual-exclusion \nprotocols, such as the Bakery and Peterson algorithms [10, 16], use certain relationships among the values \nstored in a shared integer array to decide which processes may enter their critical section. To verify \nthe cor\u00adrectness of these protocols, an analysis must be capable of capturing these relationships. Static \nreasoning about array elements is problematic be\u00adcause of the unbounded nature of arrays. Array operations \ntend to be implemented without having a particular .xed array size in mind. Rather, the code is parametrized \nby scalar variables that have certain numeric relationships to the actual size of the array. The proper \nveri.cation of such code requires establishing the desired property for any val\u00adues of those parameters \nwith which the code may be invoked. These symbolic constraints on the size of the array preclude the \nanalysis from modeling each array element as an inde\u00adpendent scalar variable and using standard numeric \nanalysis techniques to verify the property. Alternatively, an entire array may be treated as a single \nsummary numeric quantity. In this case, numeric properties established for the summary quantity that \nrepresents an ar\u00adray must be shared by all array elements. This approach, known as array smashing [2], \nresolves the unboundedness issue. However, the problem with this approach, as with any approach that \nuses such aggregation, is the inability to perform strong updates when assigning to individual array \nelements;1 this can lead to signi.cant precision loss. In this paper, we present a static-analysis framework \nthat combines canonical abstraction [19, 11] and summarizing nu\u00admeric domains [7], and is more precise \nthan array smashing. The analysis uses canonical abstraction to partition an un\u00adbounded set of array \nelements into a bounded number of 1A strong update corresponds to a kill of a scalar variable; it represents \na de.nite change in value to all concrete objects that the abstract object represents. Strong updates \ncannot generally be performed on summary objects because a (concrete) update only a.ects one of the summarized \nconcrete objects. groups. Partitioning is done based on certain properties of array elements, in particular, \non numeric relationships be\u00adtween their indices and values of scalar variables. The ele\u00adments that have \nthe same properties are grouped together. Each group is represented by an abstract array element. The \nabstraction is storeless in the sense that there is no static connection between a concrete array element \nand an ab\u00adstract array element that represents it: after the properties of a concrete array element change, \nit may be represented by a di.erent abstract element. The analysis uses summarizing numeric domains to \nkeep track of the values and indices of array elements. Indices of array elements are modeled explicitly; \nthat is, two numeric quantities are associated with each array element: the actual value of the element \nand its index. Intuitively, the analysis attempts to partition array ele\u00adments into groups about which \nstronger assertions can be established and maintained. For example, if an array ele\u00adment is assigned \nto, the analysis tries to isolate that ele\u00adment in a separate group, so that a strong update may be performed. \nWhen analyzing array-initialization code, the analysis attempts to keep array elements that were already \ninitialized in a separate group from the uninitialized ones. For the veri.cation of sorting routines, \nthe analysis tries to separate portions of arrays that have been sorted from the unsorted portions, and \nso on. Given a program that uses multiple arrays and non-array variables, an important question is how \nto partition each array to verify the desired property. We found that a simple heuristic of partitioning \narrays with respect to variables that are used to access them is very e.ective in practice. The ar\u00adray \nelements that are indexed by scalar variables are placed by themselves into individual groups, which \nare represented by non-summary abstract elements. Array segments in be\u00adtween the indexed elements are \nalso placed into individual groups, but these groups are represented by summary ab\u00adstract elements. Such \na partitioning heuristic allows the analysis to discover constraints on the values of array ele\u00adments \nafter simple initialization loops; this can be done fully automatically. More complex properties, such \nas verifying comparison\u00adbased sorting algorithms, require extra care. To this end, in Sect. 4.3, we introduce \nauxiliary predicates that are attached to each abstract partition element and encompass numeric properties \nthat are beyond the capabilities of summarizing numeric domains. Throughout the paper, we give several \nexamples of such auxiliary predicates and illustrate how they can be used to establish the desired properties \nfor several challenging examples.2 The goal of the analysis is to collect an overapproximation of the \nset of reachable states at each program point. We use the abstract-interpretation framework [3] to formalize \nthe analysis. The abstract states that are obtained for each program point are a set of triples; each \ntriple consists of an array partition, an element of a summarizing abstract numeric domain, and a valuation \nof auxiliary predicates. To implement a prototype of the analysis, we extended the TVLA tool [11] to \nprovide it with the capability to reason about numeric quantities. TVLA uses three-valued logical 2The \nprocess of identifying auxiliary predicates and their abstract transformers is not, at present, performed \nautomatically. Sect. 6.2 discuses some possibilities for carrying out these steps automati\u00adcally. structures \nto describe states of a program. We had to as\u00adsociate an element of a summarizing numeric domain with \neach three-valued structure, to extend TVLA s internal ma\u00adchinery to maintain numeric states correctly, \nand to extend the speci.cation language to incorporate predicates that in\u00adclude numeric comparisons. \nThe summarizing numeric do\u00admain was implemented by wrapping the Parma library for polyhedral analysis \n[1] in the manner described in [7]. We then de.ned a set of predicates necessary for describing and partitioning \narrays. With this prototype implementation, we were able to analyze successfully several kernel exam\u00adples, \nincluding verifying the correctness of an insertion-sort implementation. The contributions we make in \nthis paper are: We introduce an abstract domain suitable for analyz\u00ading properties of complex array \noperations.  More generally, we show how two previously described techniques, canonical abstraction \nand summarizing nu\u00admeric domains, can be combined to work together.  We describe a working prototype \nof the analysis, and illustrate it with several non-trivial examples.  1.1 Related work The problem \nof reasoning about values stored in arrays has been addressed in previous research. Here we review some \nof the related approaches that we are aware of. Masdupuy, in his dissertation [13], uses numeric domains \nto capture relationships among values and index positions of elements of statically initialized arrays. \nIn contrast, our framework allows to discover such relationships for dynam\u00adically initialized arrays. \nIn particular, canonical abstraction lets our approach retain precision by handling assignments to array \nelements using strong updates. Blanchet et al., while building a special-purpose static pro\u00adgram analyzer \n[2], recognized the need for handling values of array elements. They proposed two practical approaches: \n(i) array expansion, i.e., introducing an abstract element for each index in the array; and (ii) array \nsmashing, i.e., using a single abstract element to represent all array elements. Array expansion is precise, \nbut in practice can only be used for arrays of small size, and is not able to handle unbounded arrays. \nArray smashing allows handling arbitrary arrays ef\u00ad.ciently, but su.ers precision losses due to the need \nto per\u00adform weak updates. Our approach combines the bene.ts of both array expansion and array smashing \nby dynamically expanding the elements that are read or written to so as to avoid weak updates, and smashing \ntogether the remaining elements. Flanagan and Qadeer used predicate abstraction to in\u00adfer universally-quanti.ed \nloop invariants [6]. To handle un\u00adbounded arrays, they used predicates over Skolem constants, which are \nsynthetically introduced variables with uncon\u00adstrained values. These variables are then quanti.ed out \nfrom the inferred invariants. Our approach is di.erent in that we model the values of all array elements \ndirectly and use summarization to handle unbounded arrays. Also, our approach uses abstract numeric domains \nto maintain the nu\u00admeric state of the program, which obviates the need for calls to a theorem prover. \n. Cern\u00b4y introduced the technique of parametric predicate abstraction [20], in which special-purpose \nabstract domains void array copy(int a[], int b[], int n) { i . 0; (.) while(i < n) { b[i] . a[i]; i \n. i+1; } Figure 1: Array-copy function. are designed to reason about properties of array elements. The \ndomains are parametrized with numeric quantities that designate the portion of an array for which the \ndesired prop\u00aderty holds. The abstract transformers are manually de.ned for each domain. The analysis \ninstantiates the domains by explicitly modeling their parameters in the numeric state. Our approach di.ers \nin two respects. First, in our approach numeric states directly model array elements; which allows the \nanalysis to automatically synthesize certain invariants that involve values of array elements. Second, \nour approach separates the task of array partitioning from the task of es\u00adtablishing the properties of \narray elements. This separation allows the user to concentrate directly on formulating aux\u00adiliary predicates \nthat capture the properties of interest. Canonical abstraction [19, 11] was .rst introduced for the purpose \nof determining shape invariants for programs that perform destructive updating on dynamically allocated \nstorage. However, it lacked the ability to explicitly repre\u00adsent numeric quantities. Also, [7] introduced \na method for extending existing numeric domains with the capability of reasoning about unbounded collections \nof numeric quanti\u00adties. However, static partitioning of numeric quantities was assumed. Our work combines \nthese techniques and shows how their combination can be used for verifying properties of array operations. \n 1.2 Paper organization The paper is structured as follows: Sect. 2 gives an overview of the analysis. \nSect. 3 discusses concrete semantics. Sect. 4 introduces the abstraction. Sect. 5 details the analysis \nof the running example. Sect. 6 outlines a prototype analysis implementation. Sect. 7 describes our experiences \nwith the analysis prototype. Sect. 8 concludes the presentation.  2. RUNNING EXAMPLE In this section, \nwe illustrate our technique using a simple example. The procedure in Fig. 1 copies the contents of array \na into array b. Both arrays are of size n,which is speci.ed as a parameter to the procedure. Let us assume \nthat the analysis has already determined some facts about values stored in array a. For instance, assume \nthat the values of elements in array a range from -5to 5. At the exit of the procedure, we would like \nto establish that the values stored in array b also range from -5to5. Furthermore,wewould like to establish \nthis property for any reasonable array size, i.e., for all values of n greater than or equal to one. \nOur technique operates by partitioning the unbounded number of concrete array elements into a bounded \nnumber of groups. Each group is represented by an abstract array element. The partitioning is done by \nintroducing relations between the indices of array elements and the value of loop variable i. In particular, \nfor the example in Fig. 1, our technique will group the elements of the two arrays with in\u00addiceslessthan \ni into two summary array elements (denoted by a<i and b<i, respectively). Array elements with indices \ngreater than i are grouped into two other summary array elements (a>i and b>i). Array elements a[i] and \nb[i] are not grouped with any other array elements, and are represented by non-summary abstract array \nelements ai and bi. Such partitioning allows the analysis toperform astrongupdatewhenit processes the \nassignment statement in the body of the loop. Fig. 2(a) shows how the elements of both arrays are par\u00adtitioned \nduring the .rst iteration of the loop. Each of the abstract array elements ai and bi represents a single \ncon\u00adcrete array element of the corresponding array. This allows the analysis to conclude that the value \nof the concrete array element b[0] that is represented by bi ranges from -5to5 after the assignment b[i] \n. a[i]. As variable i gets incremented, the grouping of concrete array elements changes. The element \nb[0], represented by bi, moves into the group of the concrete array elements that are represented by \nb<i. The abstract element bi represents the array element b[1] that is extracted from the group of concrete \narray elements that is represented by b>i.The elements of array a are treated similarly. Fig. 2(b) shows \nhow the arrays a and b are partitioned during the second iteration. The analysis re.ects the change in \ngrouping of array ele\u00adments by combining the numeric properties associated with bi with the numeric properties \nassociated with b<i. The new numeric properties for the abstract element bi are obtained by duplicating \nthe numeric properties associated with b>i. As a result, at the beginning of the second iteration, the \nanalysis establishes that the value of the concrete array el\u00adement represented by b<i ranges from -5to5. \nNumeric properties associated with abstract elements of array a are treated similarly. As the value of \ni increases with each iteration, more and more of the concrete array elements of both arrays move from \nthe two groups subscripted by >i , to the two groups subscripted by i , and .nally, to the two groups \nsubscripted by <i . Fig. 2(c) shows how the arrays are partitioned on the k-th iteration. The concrete \narray elements that are rep\u00adresented by b<i are the elements that have been initialized. Suppose that \nthe analysis has established that the values of the elements represented by b<i at the beginning of the \nk-th iteration range from -5 to 5. After interpreting the assign\u00adment in the body of the loop, the analysis \nestablishes that the value of the element b[k], represented by bi, also ranges from -5 to 5. After the \nincrement of variable i,the numeric properties associated with bi are combined with the proper\u00adties associated \nwith b<i. As a result, the analysis establishes that the values of the concrete elements represented \nby b<i at the beginning of the k+ 1-st iteration range from -5to 5. An important thing to observe is \nthat, even though the partitions shown in Fig. 2 (b) and (c) describe di.erent groupings of concrete \narray elements, both partitions have the same sets of abstract array elements. Therefore, from the point \nof view of the analysis these partitions are the same. To establish which concrete array elements are \nrepre\u00adsented by a particular abstract element, the analysis directly models the values of indices of \narray elements in the numeric state associated with each partition. Fig. 2(e) shows how the array elements \nare partitioned an-1 ai  b ...bb 0n-2 n-1 b<i bi (a) (d) ...a a0 a1 a2...a a0 a1 n-1 n-1 a<i ai \na>i a<i b b b ...b b0b1...bn-1 012n-1 bbb b<i <ii >i (b) (e) ... ...  a0 ak-1 ak ak+1 an-1 a<i ai \na>i b ... b b ...b 0bk-1 kk+1n-1 b<i bi b>i (c) Figure 2: Partitionings of array elements at di.erent \npoints in the execution of the array-copy function: (a)on the 1-st loop iteration; (b)on the 2-nd it\u00aderation; \n(c)on the k-th iteration; (d)on the last iteration; (e)after exiting the loop. after exiting from the \nloop. We have just shown that, on each iteration, the analysis established that the values of the concrete \narray elements that are represented by b<i range from -5 to 5. After the loop, as shown in Fig. 2(e), \nb<i represents all of the concrete elements of array b. Therefore, the analysis is able to conclude that \nall the values stored in b range from -5to 5. The analysis is also able to establish a more general prop\u00aderty, \nnamely, that the value of each element of array b is equal to the value of the element of array a with \nthe same index. Unfortunately, the numeric domains that are used by the analysis are not capable of maintaining \nthe numeric relationships of this kind for the concrete array elements that have been summarized together. \nTo capture such rela\u00adtionships, we augment each abstract array element of array b with an extra value \nthat indicates whether the property holds for (i) all, (ii) some, or (iii) none of the concrete array \nelements represented by that abstract element. This is done by introducing an auxiliary three-valued \nunary logic predi\u00adcate d, which evaluates to the values 1, 1/2, and 0 on the abstract elements of array \nb to represent cases (i), (ii), and (iii), respectively. Theanalysisproceedsasfollows: elementsofarray \nb start with d evaluating to 1/2, which indicates that the analysis has no knowledge about the values \nstored in array b.On each iteration, the property is established for the array ele\u00adment bi, i.e., d(bi) \nis set to 1. At the end of the iteration, the concrete array element represented by bi is merged into \nthe group of elements represented by b<i. On the .rst iteration, no b<i exists, so the properties of \nbi are directly transfered to b<i, i.e., d(b<i) = 1. On the following iterations, the new value for d(b<i) \nis determined by joining its current value, expr ::= c stmt ::= v .expr |v |a[v] .expr |a[v] |if(cond) \nstmt else stmt |expr 8expr |while(cond) stmt cond ::= expr w expr |stmt; stmt c .V,v .Scalar, a .Array \n8.{+, -, \u00d7},w .{<, =, =, =,>} Figure 3: An array-manipulation language. which is 1, with the value d(bi), \nwhich also equals to 1. As a result, the analysis establishes that d(b<i) = 1 after each iteration, which \nindicates that the property of interest holds for all initialized array elements.  3. CONCRETE SEMANTICS \nOur goal is to analyze programs that operate on a .xed, .nite set of scalar variables and arrays. A concrete \nprogram state stores a corresponding value for each scalar variable and each array element. We denote \nthe set of all possible concrete program states by Sigma. We denote the set of scalar variables and the \nset of arrays used in the program by Scalar = {v1, ..., vn} and Array = {A1, ..., Ak}, respectively. \nThese sets are the same across all concrete states that may arise as a result of program execution. Be\u00adcause \nwe would like to reason about arrays of arbitrary size, the set of elements of a particular array may \ndi.er from state to state. We use the notation AS to denote the set of elements of array A .Array in \nstate S. To ensure proper sequencing of array elements, we assume that a concrete state explicitly assigns \nto each array element its proper in\u00addex position in the corresponding array. Let V denote a set of possible \nnumeric values (such as Z, Q,or R). We encode a concrete state S with the help of the following four \nfunctions: ValueS : Scalar .V maps each scalar variable to its corresponding value,  SizeS : Array \n.N maps each array to its size,  ValueS : AS .V maps an element of an array A .  A Array to its corresponding \nvalue, IndexS : AS .N maps an element of an array A . A Array to its index position in the array. Example \n1. Let program P operate on two scalar vari\u00adables, i and j, and an array B of size 10. Suppose that at \nsome point in the execution of the program, the values of variables i and j are 4 and 7, respectively, \nand the values that are stored in array B are {1, 3, 8, 12, 5, 7, 4, -2, 15, 6}. We encode the concrete \nstate S of the program as follows: Scalar = {i, j}, Array = {B},BS = {b0,...,b9} ValueS =[i.4,j.7] ,SizeS \n=[B .10] Notation: c .V,v .Scalar, A .Array, S .S,D .S 8.{+, -, \u00d7},w .{<, =, =, =,>} .\u00af elem(S, A, v)= \nu .A : IndexS A(u)= ValueS(v) Expressions: [[c]](S)= c, [[v]](S)= ValueS(v) . ValueS u .elem(S, A, v) \nA(u)if .[[A[v]]](S)= . otherwise [[expr1 8expr2]](S)= [ expr1]](S) 8[[expr2]](S) Conditions: [[expr1 \nw expr2]](S)= [ expr1]](S) w [[expr2]](S) Assignments: [[v .expr]](S)= S [v .[[expr]](S)] . [[a[v] .expr]](S)= \nS [u .[[expr]](S)] . if .u .elem(S, A, v) otherwise Errors: [[.]](.)= . Set transformers: [[v .expr]](D)= \n{[[v .expr]](S): S .D} (Assigns) [[a[v] .expr]](D)= {[[a[v] .expr]](S): S .D} (Assigna) [[cond]](D)= \n{S : S .D and [ cond]](S)= true} (Cond) D1 D2 = D1 .D2 (Join) Figure 4: Concrete collecting semantics \nfor the lan\u00adguage shown in Fig. 3. S ValueB =[b0 .1,b1 .3,b2 .8,...,b9 .6] IndexS B =[b0 .0,b1 .1,b2 \n.2,...,b9 .9] In Fig. 3, we de.ne a simple language suitable for express\u00ading array operations. The language \nconsists of assignment statements, conditional statements, and while loops. Values can be assigned to \nboth scalar variables and array elements. However, the language does not allow to use arbitrary ex\u00adpressions \nexplicitly to access array elements. Only scalar variables are allowed to index into arrays. We de.ne \nthe program s concrete collecting semantics as follows. To each program point we attach a set of concrete \nstates, D. The set transformers shown in Fig. 4 are used to propagate the sets of concrete states through \nthe program. Set transformers are de.ned for assigning to scalar vari\u00adables (Assigns) and array elements \n(Assigna), interpreting numeric conditionals of if-statements and while-statements (Cond), and joining \nsets of concrete states at control merge points (Join). The goal of the analysis is to collect the set \nof reachable program states at each program point. Determining the exact sets of concrete states is, \nin general, undecidable. We use the framework of abstract interpretation [3] to collect at each program \npoint an overapproximation of the set of states that may arise there.  4. ABSTRACT DOMAIN In this section, \nwe de.ne the family of abstract domains that is the main contribution of this paper. The elements of \nthe abstract domains are sets of abstract memory con.gu\u00adrations. Each abstract memory con.guration S# \nis a triple .\u00b8 P # , .# , .#,inwhich P # speci.es how arrays are par\u00adtitioned, .# represents the corresponding \nabstract numeric state, and .# stores the values of auxiliary predicates. We denote the set of all possible \nabstract partitions by S# . 4.1 Array partitioning The goals of array partitioning are twofold. First, \nwe would like to isolate in separate groups the array elements that are assigned to. This allows the \nanalysis to perform strong updates when assigning to these elements. Second, we would like to group elements \nwith similar properties to\u00adgether to minimize the precision loss due to summarization. In this paper, \nwe explore an array-partitioning scheme based on numeric relationships among indices of array ele\u00adments \nand values of scalar variables. In particular, given a set of scalar variables, we partition an array \nso that each element whose index is equal to the value of any of the vari\u00adables in the set is placed \nin a group by itself. Such groups are represented by non-summary abstract array elements. The consecutive \narray segments in between the indexed el\u00adements are grouped together. Such groups are represented by \nsummary abstract array elements. We de.ne array partitions by using a .xed set of partition\u00ading functions, \ndenoted by .. Each function is parametrized by an array and a single scalar variable. Let A . Array and \nv . Scalar.In a concrete state S, a function pA,v is interpreted as: pA,v : AS .{-1, 0, 1}, and is evaluated \nas follows: 8 < -1if IndexS A(u) <ValueS (v) pA,v(u)= 0 A(u)= ValueS (v) if IndexS : 1 if IndexS A(u) \n>ValueS (v) The choice of values is completely arbitrary as long as the function evaluates to a di.erent \nvalue for each of the three cases. We denote the set of partitioning functions parame\u00adterized with array \nA by .A. In a given concrete state, we partition each array A . Array by grouping together elements of \nA for which all partitioning functions in .A evaluate to the same values. Each group is represented by \nan abstract array element: a non-summary element if at least one partitioning function evaluates to 0 \nfor the array elements in the group; a sum\u00admary element otherwise. If the set .A is empty, all of the \nelements of array A are grouped together into a single sum\u00admary element. The values to which partitioning \nfunctions evaluate on the array elements in a group uniquely determine the abstract element that is used \nto represent that group. We continue using the intuitive abstract-element naming introduced in Sect. \n2, e.g., b>i,<j denotes the group of array elements whose indices are greater than the value of i, but \nless than the value of j. Formally, array partition P # maps each array in Array to a corresponding set \nof abstract array elements. We say that two array partitions are equal if they map all arrays in Array \nto the same sets: hi ## ## P = P .. .A .Array P (A)= P (A) 12 12 The following example illustrates array \npartitioning. Example 2. Assume the same situation as in Ex. 1. Let the set of partitioning functions \n. be (pB,i,pB,j ).The el\u00adements of array B are partitioned into .ve groups, each of which is represented \nby an abstract array element: (i) {b0,b1,b2,b3}, represented by b<i,<j ; (ii) {b4}, represented by bi,<j \n;  (iii) {b5,b6},represented b>i,<j ; (iv) {b7}, represented by b>i,j; (v) {b8,b9}, represented by \nb>i,>j. The abstract array elements bi,<j and b>i,j are non-summary, while b<i,<j , b>i,<j,and b>i,>j \nare summary. Thus,  # P =[B .{b<i,<j,bi,<j ,b>i,<j,b>i,j,b>i,>j }] Note, that since each abstract element \nof array A corre\u00adsponds to a valuation of partitioning functions in .A,there canbeatmost3|.A| abstract \narray elements of A.Thus, the number of ways to partition array A (i.e., the number of sets of abstract \narray elements that consistently represent the corresponding array) is .nite, although combinatorially \nlarge. However, our observations show that only a small fraction of these partitions actually occur in \npractice. The approach that is presented in this section illustrates only one of the possibilities for \npartitioning an array. We found this partitioning to be useful when consecutive ar\u00adray elements share \nsimilar properties, e.g., when analyzing simple array-initialization loops and simple array-sorting al\u00adgorithms, \nwhich constitutes a large portion of actual uses of arrays. However, in more complicated examples, e.g., \nwhen using double indexing to initialize an array and using an ar\u00adray to store a complex data structure \n(such as a tree), the above array partitioning is not likely to succeed. We plan to address the issue \nof improving array partitioning in future work. 4.2 Numeric states To keep track of the numeric information \nassociated with an array partition, we attach to each partition an element of a summarizing numeric domain \n[7]. Summarizing nu\u00admeric domains are capable of modeling values associated with summary objects and \nare automatically constructed by extending standard relational numeric domains, such as octagons [14] \nand polyhedra [5, 8]. Each quantity associ\u00adated with an abstract object is modeled by a dimension in \nthe domain. Dimensions can be summary or non-summary depending on the type of the corresponding object. \nIn array analysis, we use non-summary dimensions to rep\u00adresent the values of scalar variables, array \nsizes, and the values and indices of non-summary abstract array elements. Summary dimensions are used \nto model values and indices of summary abstract array elements. Note that each ab\u00adstract array element \nhas two dimensions associated with it: one for the value, and one for its index position in the array. \nWe use the following notation to refer to the dimensions of summarizing numeric domain: v denotes the \ndimension that represents the values of scalar variable v; A.size de\u00adnotes the dimension that represents \nthe size of an array A.Let u . P #(A) denote an arbitrary abstract element of array A. Then, u.value \ndenotes the dimension that rep\u00adresents the value of u,and u.index denotes the dimension that represents \nits index. For simplicity, we assume that the summarizing numeric domain used in the analysis was constructed \nby extending polyhedral numeric domain; thus, we present numeric states as sets of linear constraints. \nA constraint on a quantity associated with a summary object is interpreted to hold for the quantities \nassociated with all concrete objects represented by that abstract object. Example 3. Assume the same \nsituation as in Ex. 2. The numeric state associated with P # is described by the follow\u00ading set of linear \nconstraints: i =4,j =7,B.size =10 0 =b<i,<j.index =31 =b<i,<j .value =12 bi,<j .index =4 bi,<j .value \n=5 5 =b>i,<j.index =64 =b>i,<j .value =7 b>i,j .index =7 b>i,j .value = -2 8 =b>i,>j.index =96 =b>i,>j \n.value =15 The de.nitions of a partial-order relation and of a join op\u00aderation for a summarizing domain \ndepend on the underlying numeric domain. For example, in a polyhedral domain, the result of a join operation \nis computed by taking the convex hull of the union of the arguments. Only numeric states that have the \nsame set of dimensions can be compared and joined together. The set of dimensions is determined by the \narray partition. Thus, only numeric states that are asso\u00adciated with similar array partitions can be \ncompared and joined.  4.3 Beyond summarizing domains Summarizing numeric domains can be used to reason \nabout collective numeric properties of summarized array elements. However, the relationships among quantities \nthat are sum\u00admarized together are lost. This precludes summarizing nu\u00admeric domains from being able to \nexpress certain properties of interest, e.g., it is impossible to express the fact that a set of array \nelements that are summarized together are in sorted order. In Ex. 3, the numeric state S# is only able \nto capture the property that the values of the concrete array elements represented by b(<i,<j) range \nfrom 1 to 12, but not that those elements are sorted in ascending order. To capture properties that are \nbeyond the capabilities of summarizing numeric domains, we introduce a set of aux\u00adiliary predicates, \ndenoted by .. In a concrete state S,a predicate in dA . . maps each element of array A to a boolean value: \nto 1 if the property of interest holds for that element, and to 0 otherwise: dA : AS .{0, 1}. We specify \nthe semantics of auxiliary predicates by supply\u00ading a formula that is evaluated in concrete states. When \nthe elements of array A are summarized, we join the corresponding values of dA in a 3-valued logic lattice \n[19]. In 3-valued logic, an extra value, denoted by 1/2, is added to the set of Boolean values {0, 1}. \nThe order is de.ned as follows: l1 .l2 i. l1 = l2 or l2 =1/2 Thus, 1/2 0=1/2 1=0 1=1/2. The resulting \nvalue is attached to the corresponding abstract array element. In an abstract memory con.guration, we \nuse an abstract # counterpart of the predicate, denoted by dA , to map abstract array elements to corresponding \nvalues: d# : P #(A) .{0, 1, 1/2} A Let u .P #(A) be an arbitrary abstract array element. The value of \nd#(u) is interpreted as follows: the value of 1 indi- A cates that the property holds for all of the \narray elements represented by u; the value of 0 indicates that the property does not hold for any of \nthe array elements represented by u; and the value of 1/2 indicates that property may hold for some of \nthe array elements represented by u, but may not hold for the rest of the elements. Example 4. Assume \nthe same situation as in Ex. 3. We introduce a predicate dB that evaluates to 1 for array ele\u00adments that \nare in ascending order, and to 0 for the elements that are not: n =1,i =0, ai.index =0 - 5 = ai.value \n= 5 bi.index =0  b>i n = 2,i =0, ai.index = bi.index =0 1 = a>i.index = n - 1 - 5 = ai.value = 5 - \n5 = a>i.value = 5 1 = b>i.index = n - 1 ## =[bi . 1/2] =[bi . 1/2,b>i . 1/2] dd b b dB (u)=. t . B SS \nB(t) <IndexB(u) . Index SS ValueB(t) = ValueB(u) In the concrete state shown in Ex. 1, dB evaluates to \n1 for the elements b0, b1, b2, b3,and b8;and to 0 for the remain\u00ading elements. The values associated \nwith the abstract array elements are constructed as follows: #0 ,1 ,2 Figure 5: The abstract state at \nthe entrance of the loop (program point (.))in Fig. 1. The abstract state contains two abstract memory \ncon.gurations: #0 one represents arrays of length 1; the other repre\u00adsents arrays of length 2 and greater. \nSS # (b<i,<j )= F3 i=0 dB (bi)=1 1 1 1=1 d B # d (bi,<j )= dB (b4)=0 Given a set of abstract memory con.gurations \nSS# B ,we # B (b>i,<j )= dB (b5) dB (b6)=0 0=0 d say that C# is a partition congruence class i. it is \na maximal\u00ad # B sized subset of SS# d (b>i,j )= dB (b7)=0 , all of whose members partition arrays # # \nsimilarly (i.e., there exists P # . C# (b>i,>j )= dB (b8) dB (b9)=1 0=1/2 d such that for all S, B i \n# P #P ). We de.ne the abstraction function for a set of = i The part of an abstract memory con.guration \nthat stores concrete states D . S as follows: the interpretation of auxiliary predicates is denoted by \n.# . . C# .{ \u00df(S): S . D} G and is de.ned as: a(D)= C # : (u) is a partition congruence class Thus, \nan abstract state D# is a set of abstract memory con\u00ad ## . (dA,u)= d A It only makes sense to compare \nand join the interpretations .gurations with distinct array partitions. The concretiza\u00ad that are de.ned \nfor the same set of abstract array elements, tion function is de.ned as follows: i.e., the interpretations \nthat are associated with the same no #### array partition P # . We de.ne a partial order relation for \n)= S : . S. D s.t. \u00df(S) . S .(D. interpretations of auxiliary predicates as follows: We de.ne a partial-order \nand a join operation for abstract . #1 . . #2 states as follows. Let D #1 ,D #2 . S# denote two abstract \n.. states. The partial-order relation is de.ned by: hi #(A) . #1 (dA,u) . . #2 (dA,u) . . dA . . . u \n. P hi D #1 . D #2 .. . S #1 . D #1 . S #2 . D #2 S #1 . S #2 The join operation for interpretations \nof auxiliary predicates #1 . #2 =.#,where for is de.ned as follows: we say that .The join of two abstract \nstates is performed by comput\u00adall dA . .and forall u . P #(A) ing a union of the corresponding sets of \nabstract memory con.gurations. The con.gurations that have similar array partitions are joined together. \nThis is similar in spirit to the . # (dA,u)=. #1 (dA,u) . #2 (dA,u). partially disjunctive heap abstraction \ndescribed in [12].  4.4 Abstract states Examples 2, 3, and 4 illustrate the construction of an abstract \nmemory con.guration that represents an arbitrary 5. RUNNING EXAMPLE REVISITED concrete state. We use \na function \u00df :S . S# to refer to In this section, we .esh out the schematic illustration of this process \nof abstracting a single concrete state. the analysis that was given in Sect. 2. The analysis is applied \nDEDE Let S #1 = P , ., . and S #2 = P, ., . de\u00adto the code shown in Fig. 1. We depict the abstract \nmem\u00ad ory con.gurations that arise in the course of the analysis as note two abstract memory con.gurations. \nWe de.ne a partial\u00ad follows. The partition of the arrays is shown graphically: order relation for the \nabstract memory con.gurations as fol\u00ad solid boxes represent non-summary abstract array elements; lows: \ndashed boxes represent summary abstract array elements. S #1 . S #2 .. P #1 = P #2 . . #1 . . #2 \n. . #1 . . #2 Numeric states are shown as sets of linear constraints. Aux\u00ad iliary predicates are shown \nas maps from sets of abstract The join operation is only de.ned for the abstract memory array elements \nto corresponding values in { 0, 1, 1/2} . #1 Consider the program in Fig. 1. The set of scalar variables \n. The resulting abstract partition is de.ned by and the set of arrays are de.ned as follows: Scalar = \n{ i, n} #2 = P # and Array = { a, b} . The analysis uses the set of partitioning functions . = { pa,i,pb,i} \n. It is beyond the capabilities of DE # = S #1 S #2 = P # #1 . #2 , . #1 . #2 ai bi ai a>i bi \nb>i ai b<i a<i bi ai a>i b>ibib<i a<i 1-st iteration i =0,n =1, ai.index =0 -5 = ai.value = 5 bi.index \n=0 d# b =[bi . 1/2] S# 1,1 i =0,n = 2, ai.index = bi.index =0 1 = a>i.index = n - 1 -5 = ai.value = 5 \n-5 = a>i.value = 5 1 = b>i.index = n - 1 d# b =[bi . 1/2,b>i . 1/2] S# 1,2 (not present) (not present) \n2-nd iteration (same as above) (same as above) i =1,n =2, ai.index = bi.index =1 a<i.index =0 -5 = ai.value \n= 5 -5 = a<i.value = 5 b<i.index =0 b<i.value = a<i.value d# b =[b<i . 1,bi . 1/2] S# 2,3 i =1,n = 3, \nai.index = bi.index =1 2 = a>i.index = n - 1 a<i.index =0 -5 = ai.value = 5 -5 = a>i.value = 5 -5 = a<i.value \n= 5 2 = b>i.index = n - 1 b<i.value = a<i.value d# b =[b<i . 1,bi . 1/2,b>i . 1/2] S# 2,4 3-rd iteration \n(same as above) (same as above) i =2,n =3 ai.index = bi.index =2 0 = a<i.index = 1 -5 = ai.value = 5 \n-5 = a<i.value = 5 0 = b<i.index = 1 -5 = b<i.value = 5 d# b =[b<i . 1,bi . 1/2] S# 3,3 i =2,n = 4 ai.index \n= bi.index =2 0 = a<i.index = 1 3 = a>i.index = n - 1 -5 = ai.value = 5 -5 = a>i.value = 5 -5 = a<i.value \n= 5 0 = b<i.index = 1 3 = b>i.index = n - 1 -5 = b<i.value = 5 d# b =[b<i . 1,bi . 1/2,b>i . 1/2] S# \n3,4 3-rd iteration (after join) (same as above) (same as above) 1 = i = 2 n = i +1 ai.index = i 0 = a<i.index \n= i - 1 -5 = ai.value = 5 -5 = a<i.value = 5 bi.index = i 0 = b<i.index = i - 1 -5 = b<i.value = 5 d# \nb =[b<i . 1,bi . 1/2] S# J,3 1 = i = 2 i = ai.index = bi.index 0 = a<i.index = i - 1 i +1 = a>i.index \n= n - 1 -5 = ai.value = 5 -5 = a>i.value = 5 -5 = a<i.value = 5 0 = b<i.index = i - 1 i +1 = b>i.index \n= n - 1 -5 = b<i.value = 5 d# b =[b<i . 1,bi . 1/2,b>i . 1/2] S# J,4 3-rd iteration (after widening) \n(same as above) (same as above) 1 = i n = i +1 ai.index = i 0 = a<i.index = i - 1 -5 = ai.value = 5 -5 \n= a<i.value = 5 bi.index = i 0 = b<i.index = i - 1 -5 = b<i.value = 5 d# b =[b<i . 1,bi . 1/2] S# W,3 \n1 = i i = ai.index = bi.index 0 = a<i.index = i - 1 i +1 = a>i.index = n - 1 -5 = ai.value = 5 -5 = a>i.value \n= 5 -5 = a<i.value = 5 0 = b<i.index = i - 1 i +1 = b>i.index = n - 1 -5 = b<i.value = 5 d# b =[b<i . \n1,bi . 1/2,b>i . 1/2] S# W,4 Figure 6: Abstract memory con.gurations at the begining of the 1-st, 2-nd \nand 3-d iterations of the loop in Fig. 1. The sets of abstract memory con.gurations in each row form \ncorresponding abstract states. Last two rows show the transformation of the abstract state on the third \niteration, as is is joined and widened with respect to the abstract state obtained on the second iteration. \nafter 1-st iteration after 2-nd iteration after 3-rd iteration .nal state n =1,i = n, n =2,i = n, n = \n2,i = n n = 1,i = n b<i a<i a<i.index =0 -5 = a<i.value = 5 b<i.index =0 b<i.value = a<i.value 0 = a<i.index \n= n - 1 -5 = a<i.value = 5 0 = b<i.index = n - 1 -5 = b<i.value = 5 0 = a<i.index = n - 1 -5 = a<i.value \n= 5 0 = b<i.index = n - 1 -5 = b<i.value = 5 0 = a<i.index = n - 1 -5 = a<i.value = 5 0 = b<i.index = \nn - 1 -5 = b<i.value = 5 d# b =[b<i . 1] d# b =[b<i . 1] d# b =[b<i . 1] d# b =[b<i . 1] S# 1,5 S# 2,5 \nS# 3,5 S# E,5 Figure 7: The abstract state (consisting of a single abstract memory con.guration)that \nreaches program point (..) after the 1-st, 2-nd, and 3-d iterations of the loop in Fig. 1. The last column \nshows the stabilized abstract state at (..). summarizing numeric domains alone to express the property \nfor every index k,the valueof b[k] is equal to the value of a[k] . To capture this property, we introduce \nan auxiliary predicate db, whose semantics in a concrete state S is de.ned by SS S db(u)= .t . a Indexb \n(u)= Indexa (t) . ValueSb (u)= ValueSa (t) . Fig. 5 shows the abstract state at program point (.). The \nabstract state contains two abstract memory con.gurations: S# 0,1 and S0# ,2. Con.guration S0# ,1 represents \nthe degenerate case of each array containing only one element. Thus, each array is represented by a single \nabstract array element, ai and bi, respectively. The indices of both ai and bi are equal to zero, and \nthe value of ai ranges from -5to5. Abstract memory con.guration S0# ,2 represents the con\u00adcrete states \nin which both arrays are of length greater than or equal to two. In these situations, each array is represented \ntwo abstract elements: ai and bi represent the .rst elements of the corresponding arrays, while a>i and \nb>i represent the remaining elements. The numeric state associated with this partition indicates that \nthe indices of the concrete array ele\u00adments represented by ai and bi are equal to zero, the indices of \nthe concrete array elements represented by a>i and b>i range from 1 to n-1, and the values of all concrete \nelements of array a range from -5to5. The auxiliary predicate db # evaluates to 1/2 for all array # elements \nin the abstract memory con.gurations Sand 0,1 S# This means that, in the concrete states represented \nby 0,2. S# and S# , the values of the concrete elements of array 0,10,2 b may either be equal to the \nvalues of the corresponding elements of array a or not. Fig. 6 shows the abstract states that the analysis \nencoun\u00adters at the beginning of each iteration. Each entry in the table represents an abstract memory \ncon.guration. The ab\u00adstract state at a particular iteration is the set of abstract memory con.gurations \nshown in the corresponding row of the table. Table columns correspond to distinct array par\u00adtitions that \narise during the analysis. Fig. 7 shows the evo\u00adlution, on successive iterations of the analysis, of \nthe single abstract memory con.guration that reaches the exit of the loop. The analysis proceeds as follows. \nBoth S0# ,1 and S0# ,2 sat\u00adisfy the loop condition and are propagated into the body of the loop. The \nabstract state at the beginning of the .rst # iteration contains abstract memory con.gurations Sand 1,1 \n# ## S1,2, which are similar to Sand Srespectively. Af\u00ad 0,10,2, ter the assignment b[i] . a[i] , two \nchanges happen to both abstract memory con.gurations: (i) the constraint ai.value = bi.value is added \nto their numeric states, and (ii) the value of auxiliary predicate db #(bi) is changed to 1. At the end \nof the .rst iteration, as variable i is incre\u00ad # mented, abstract memory con.guration Sis transformed \n1,1 into con.guration S1# ,5. The loop condition does not hold in S1# ,5, thus, this memory con.guration \nis propagated to the program point after the exit of the loop. Abstract mem\u00adory con.guration S1# ,2 is \ntransformed into two new abstract memory con.gurations: S2# ,3 and S2# ,4. These memory con\u00ad.gurations, \nalong with S# and S# , form the abstract state 1,11,2 at the beginning of the second iteration. At the \nend of the second iteration, the abstract mem\u00adory con.guration S# is transformed into con.guration S# \n2,32,5, which violates the loop condition, and is, thus, propagated to program point (..). The abstract \nmemory con.gura\u00adtion S2# ,4 is transformed into two new abstract memory con\u00ad.gurations, S# and S# in \nwhich loop condition holds. 3,33,4, Because the abstract state accumulated at the head of the loop already \ncontains memory con.gurations with similar array partitions, the numeric states and the values of aux\u00adiliary \npredicates for these abstract memory con.gurations are joined. In particular, abstract memory con.guration \nS# is joined with S# to produce S# Similarly, S# is 2,33,3 J,3. 2,4 joined with S# , resulting in S# \nFurthermore, widening 3,4J,4. is applied: S# is widened with respect to S# , producing J,32,3abstract \nmemory con.guration S# ;and S# is widened W,3J,4 with respect to S# , resulting in S# 2,4W,4. On the \nthird iteration, abstract memory con.guration S# is transformed into S# , which is propagated to pro\u00ad \nW,33,5gram point (..). Abstract memory con.guration S# ,is W,4transformed into memory con.gurations S# \nand S# ,which W,3 W,4 were previously encountered by the analysis. At this stage, the abstract state \nat the head of the loop stabilizes and the analysis terminates. All of the abstract memory con.gurations \nthat reach pro\u00adgram point (..) partition arrays similarly. The analysis joins these memory con.gurations \nto produce the abstract state that contains a single abstract memory con.guration S# E,5 shown in the \nlast column of Fig. 7. It is easy to see that this con.guration represents only the concrete states in \nwhich (i) the values stored in the array b range from -5 to 5 (follows from -5 = b<i = 5 constraint in \nthe numeric state); and (ii) the value of each element of array b is equal to the value of the element \nof array a with the same index (follows from the fact that db #(b<i) evaluates to de.nite value 1). \n 6. ABSTRACT SEMANTICS To make the abstraction described in previous sections usable, we have to de.ne \nthe abstract counterparts for the concrete state transformers shown in Fig. 4. In [4], it is shown that \nfor a Galois connection de.ned by abstraction function a and concretization function .,the best abstract \ntransformer for a concrete transformer t ,de\u00adnoted by t , can be expressed as: t . = a.t ... This de.nes \nthe limit of precision obtainable using a given abstract do\u00admain; however, it is a non-constructive de.nition: \nit does not provide an algorithm for .nding or applying t . . We implemented a prototype of our analysis \nusing the TVLA tool [11], and de.ned overapproximations for the best abstract state transformers by using \nTVLA mechanisms. Space considerations preclude us from giving a full account of the modi.cations that \nneeded to be applied to TVLA, and the exact de.nitions of the predicates needed to support ar\u00adray operations. \nIn the rest of this section, we give a brief overview of TVLA, and sketch the techniques for modeling \narrays and de.ning abstract transformers. 6.1 An extension of TVLA TVLA models concrete states by .rst-order \nlogical struc\u00adtures. The elements of a structure s universe represent the concrete objects. Predicates \nencode relationships among the concrete objects. The abstract states are represented by three-valued \nlogical structures, which are constructed by ap\u00adplying canonical abstraction to the sets of concrete \nstates. The abstraction is performed by identifying a set of ab\u00adstraction predicates and representing \nthe concrete objects for which these abstraction predicates evaluate to the same values by a single element \nin the universe of a three-valued structure. In the rest of the paper, we refer to these abstract elements \nas nodes. A node that represents a single concrete object is called non-summary node, and a node that \nrepre\u00adsent multiple concrete objects is called summary node. TVLA distinguishes between two types of \npredicates: core predicates and instrumentation predicates. Core predicates are the predicates that are \nnecessary to model the concrete states. Instrumentation predicates, which are de.ned in terms of core \npredicates, are introduced to capture prop\u00aderties that would otherwise be lost due to abstraction. An \nabstract state transformer is de.ned in TVLA as a sequence of (optional) steps: A focus step replaces \na three-valued structure by a set of more precise three-valued structures that rep\u00adresent the same set \nof concrete states as the original structure. Usually, focus is used to materialize a non-summary node \nfrom a summary node. The struc\u00adtures resulting from a focus are not necessarily images of canonical abstraction, \nin the sense that they may have multiple nodes for which the abstraction predi\u00adcates evaluate to the \nsame values.  A precondition step .lters out the structures for which a speci.ed property does not hold \nfrom the set of struc\u00adtures produced by focus. Generally, preconditions are used to model conditional \nstatements.  An update step transforms the structures that satisfy the precondition, to re.ect the \ne.ect of an assignment statement. This is done by changing the interpretation of core and instrumentation \npredicates in each struc\u00adture.  A coerce step is a cleanup operation that sharpens updated three-valued \nstructures by making them com\u00adply with a set of globally de.ned integrity constraints.  A blur step \nrestores the canonicity of coerced three\u00advalued structures by applying canonical abstraction to them, \ni.e., merging together the nodes for which the abstraction predicates evaluate to the same values.  \nWe extended TVLA with the capability to explicitly model numeric quantities. In particular, we added \nthe facilities to associate a set of numeric quantities with each concrete ob\u00adject, and equipped each \nthree-valued logical structure with an element of a summarizing numeric domain to represent the values \nof these quantities in abstract states. Each node in a three-valued structure is associated with a dimension \nof a summarizing numeric domain. TVLA speci.cation lan\u00adguage was extended to permit using numeric comparisons \nin logical formulas, and to specify numeric updates. The operations that a.ect numeric states, such as \nper\u00adforming numeric updates and evaluating numeric compar\u00adisons, as well as creating, removing, merging, \nand duplicat\u00ading nodes in the structure are handled by the correspond\u00ading abstract transformers of a \nsummarizing numeric domain. The focus and coerce operations use the assume operation, provided by the \ndomain, to augment a numeric state with extra constraints. 6.2 Modeling arrays We encode concrete states \nof a program as follows. Each scalar variable and each array element corresponds to an el\u00adement in the \nuniverse of the .rst-order logical structure. We de.ne a core unary predicate for each scalar variable \nand for each array. These predicates evaluate to 1 on the elements of the .rst-order structure that represent \nthe corresponding scalar variable or the element of corresponding array, and to 0 for the rest of the \nelements. Each element in the uni\u00adverse is associated with a numeric quantity that represents its value. \nEach array element is associated with an extra numeric quantity that represents its index position in \nthe array. To model the array structure in TVLA correctly, extra predicates are required. We model the \nadjacency relation among array elements by introducing a binary instrumen\u00adtation predicate for each array. \nThis predicate evaluates to 1 when evaluated on two adjacent elements of an array. To model the property \nthat indices of array elements are contiguous and do not repeat, we introduce a unary instru\u00admentation \npredicate for each array that encodes transitive closure of the adjacency relation. Partitioning functions \nare de.ned by unary instrumenta\u00adtion predicates. Since a partitioning function may evaluate to three \ndi.erent values, whereas a predicate can only eval\u00aduate to0or1, weuse twopredicatestoencodeeach par\u00adtitioning \nfunction. Auxiliary predicates directly correspond to unary instrumentation predicates. To perform the \nabstraction, we select a set of abstrac\u00adtion predicates that contains the predicates corresponding to \nscalar variables and arrays, the predicates that encode the transitive closure of adjacency relations \nfor each array, and the predicates that implement the partitioning func\u00adtions. The auxiliary predicates \nare non-abstraction predi\u00adcates. The resulting three-valued structures directly corre\u00adspond to the abstract \nmemory con.gurations we de.ned in Sect. 4. The transformers for the statements that do not require array \nrepartitioning, e.g., conditional statements, and as\u00adsignments to array elements and to scalar variables \nthat are not used to index array elements, are modeled trivially. The transformers for the statements \nthat cause a change in ar\u00adray partitioning, e.g., updates of scalar variables that are used to index \narray elements, are de.ned as follows: focus is applied to the structure to materialize the array element \nthat will be indexed by the variable after the update; then, the value of the scalar variable, and the \ninterpretation of the partitioning predicates are updated; .nally, blur is used to merge the array element \nthat was indexed by the variable previously, into the appropriate summary node. To update the interpretation \nof auxiliary predicates, the programmer must supply predicate-maintenance formulas for each statement \nthat may change the values of those pred\u00adicates. Also, to re.ect the numeric properties, encoded by the \nauxiliary predicates, in the numeric state as the group\u00ading of the concrete array elements changes, a \nset of integrity constraints implied by the auxiliary predicates must be sup\u00adplied. Aside from the integrity \nconstraints and update formu\u00adlas for the auxiliary predicates, the conversion of an arbi\u00adtrary program \ninto a TVLA speci.cation can be performed fully automatically. In the future, we plan to extend the technique \nfor di.erencing logical formulas, described in [17], with the capability to handle numeric formulas. \nSuch an ex\u00adtension will allow us to automatically compute safe abstract transformers for the auxiliary \npredicates. Another technique that may help to fully automate the analysis involves the use of decision \nprocedures to symbolically compute best abstract transformers [18, 21].  7. EXPERIMENTS In this section, \nwe describe the application of the anal\u00adysis prototype to four simple examples. We used a simple heuristic \nto obtain the set of partitioning functions for each array in the analyzed examples. In particular, for \neach ar\u00adray access a[i] in the program we added a partitioning function pa,i to the set .. This approach \nworked well for all of the examples, except for the insertion-sort implemen\u00adtation, which required the \naddition of an extra partitioning function. 7.1 Array initialization Fig. 8 shows a piece of code that \ninitializes array a of size n. Each array element is assigned a value equal to twice its index position \nin the array plus 3. The purpose of this example is to illustrate that the analysis is able to automat\u00adically \ndiscover numeric constraints on the values of array elements. The array-partitioning heuristic produces \na single parti\u00adtioning function pa,i for this example. The analysis estab\u00adlishes that after the code \nis executed the values stored in the array range from 3 to 2 \u00d7 n+ 1. No human intervention in the form \nof introducing auxiliary predicates is required. int a[n], i, n; i . 0; while(i < n) { a[i] . 2 \u00d7 i+ \n3; i . i+ 1; } Figure 8: Array-initialization loop. int a[n], b[n], c[n], i, j, n; i . 0; j . 0; while(i \n< n) { if(a[i] == b[i]) { c[j] . i; j . j+ 1; } i . i+ 1; } Figure 9: Partial array initialization. In \ncontrast, other approaches that are capable of handling this example [6, 20] require that the predicate \nthat speci\u00ad.es the expected bounds for the values of array elements is supplied explicitly, either by \nthe user or by an automatic abstraction-re.nement technique [9]. 7.2 Partial array initialization Fig. \n9 contains a more complex array-initialization exam\u00adple. The code repeatedly compares elements of arrays \na and b and, in case they are equal, writes their index position into the array c. The portion of array \nc that is initialized depends on the values stored in the arrays a and b.Three scenarios are possible: \n(i) none of the elements of c are ini\u00adtialized; (ii) an initial segment of c is initialized; (iii) all \nof c is initialized. The purpose of this example is to illus\u00adtrate the handling of multiple arrays as \nwell as partial array initialization. The array-partitioning heuristic derives a set of three par\u00adtitioning \nfunctions for this example, one for each array: .= {pa,i,pb,i,pc,j}. The analysis establishes that, after \nthe loop, the elements of array c with indices between 0 and j- 1 were initialized to values ranging \nfrom 0 to n- 1. Again, no auxiliary predicates are necessary. The abstract state that reaches the exit \nof the loop con\u00adtains four abstract memory con.gurations. The .rst con.g\u00aduration represents concrete \nstates in which none of the array elements are initialized. The value of j, in this domain el\u00adement, \nis equal to zero, and, thus, the array partition does not contain the abstract element c<j . The second \nand the third memory con.gurations repre\u00adsent the concrete states in which only an initial segment of \narray c is initialized. Two di.erent memory con.gurations are required to represent this case because \nthe analysis dis\u00adtinguishes the case of variable j indexing an element in the middle of the array from \nthe case of j indexing the last ele\u00adment of the array. The last abstract memory con.guration represents \nthe concrete states in which all elements of array c are initial\u00adized. In the concrete states represented \nby this memory con.guration, the value of variable j is equal to the value of variable n,and allelements \nofarray c are represented by the abstract array element c<j . void sort(int a[], int n) { int i,j, k, \nt; i . 1; while(i < n) { j . i; while(j > 0) { k . j-1; if(a[j] = a[k]) break; t . a[j]; a[j] . a[k]; \na[k] . t; j . j-1; } i . i+1; }} Figure 10: Insertion-sort procedure. The initialized array elements \nare represented by the ab\u00adstract array element c<j . The array partition of the .rst memory con.guration \ndoes not contain element c<j ,which indicates that no elements were initialized. The numeric states associated \nwith the other abstract memory con.gu\u00adrations capture the property that the values of initialized array \nelements range between 0 and n - 1. 7.3 Insertion sort Fig. 10 shows a procedure that sorts an array \nusing an in\u00adsertion sort. Parameter n speci.es the size of array a.The invariant for the outer loop is \nthat the array is sorted up to the i-th element. The inner loop inserts the i-th element into the sorted \nportion of the array. An interesting detail about this implementation is that elements are inserted into \nthe sorted portion of the array in reverse order. The pur\u00adpose of this example is to demonstrate the \napplication of the analysis to a more challenging problem. The application of the array-partitioning \nheuristic yields .= {pa,j}. Unfortunately, this partitioning is not su.\u00adcient. We also need to use variable \ni to partition the array so that the sorted segment of the array is separate from the unsorted segment. \nHowever, since i is never explicitly used to index array elements, our array-partitioning heuris\u00adtic \nfails to add pa,i to the set of partitioning functions. To successfully analyze this example, we have \nto manually add pa,i to .. Summarizing numeric domains are not able to preserve the order of summarized \narray elements. An auxiliary pred\u00adicate, de.ned similarly to the predicate dB in Ex. 4, needs to be introduced. \nOur prototype implementation requires user involvement to specify the explicit update formulas for this \npredicate for each of the program statements. Fortunately, the majority of the program statements do \nnot a.ect this predicate. Thus, the corresponding update formula for such statements is the identity \nfunction. The only non-trivial case is the assignment to an array element. The human involvement necessitated \nby the analysis is (i) minor, and (ii) problem-speci.c. In particular, only one aux\u00adiliary predicate \nneeds to be introduced, Furthermore, this predicate is not speci.c to a given implementation of a sort\u00ading \nalgorithm. Rather, it can be reused in the analysis of other implementations, and even in the analysis \nof other sorting algorithms. Also, this example identi.es some directions for future research: (i) designing \nbetter techniques for the automatic array partitioning, and (ii) automatically discovering and maintaining \nauxiliary predicates. 7.4 Results We ran the analysis prototype on an Intel-based Linux machine equipped \nwith a 2.4 GHz Pentium 4 processor and 512Mb of memory. Fig. 11 shows the measurements we col\u00adlected \nwhile analyzing the examples discussed above. The measurements are severely a.ected by our decision to \nimplement the analysis prototype in TVLA. Because TVLA is a general framework, the structure of an array \nhas to be modeled explicitly by introducing a number of instrumen\u00adtation predicates and integrity constraints. \nConsequently, the majority of the analysis time is spent executing focus and coerce operations to ensure \nthat the array structure is preserved. The measurements in Fig. 11 indicate that, on average, focus and \ncoerce account for about 80% of the overall analysis time. Building a dedicated analysis imple\u00admentation, \nin which the knowledge of the linear structure of arrays is built into the abstract state transformers, \nwould recover the majority of that time. Another shortcoming of the analysis prototype is that the number \nof nodes it uses to represent an array in TVLA is larger than the number of abstract objects created \nby array partitioning described in Sect. 4.1. For example, extra non\u00adsummary nodes are used to represent \nthe .rst and the last elements of each array. As a result, the reported number of abstract objects in \neach abstract memory con.guration as well as the number of memory con.gurations in an abstract state \nis greater than a dedicated analyzer would encounter. Another factor that slows down the analysis is \nour use of the polyhedral numeric domain. While o.ering a superior precision, the polyhedral numeric \ndomain does not scale well as the number of dimensions grow. This property is partic\u00adularly apparent \nwhen a polyhedron that represents the ab\u00adstract state is a multidimensional hypercube. In the array copy \nexample, the constraints on the values of elements of both arrays form a 10-dimensional hypercube, which \npro\u00advides an explanation of why the analysis takes over 6 min\u00adutes. If the constraints on the values \nof array a are excluded from the initial abstract state, the analysis takes merely 8 seconds. Observation \nof the numeric constraints that arise in the course of the analysis led us to believe that using less \npre\u00adcise, but more e.cient weakly-relational domains [15], may speed up the analysis of the above examples \nwithout sacri\u00ad.cing precision. We reran the analysis of the array copy ex\u00adample, using a summarizing \nextension of a weakly-relational domain. The analysis was able to verify the desired proper\u00adties in 40 \nseconds, which is a signi.cant improvement over the time it takes to perform the analysis with a polyhedral \ndomain.  8. CONCLUSIONS Canonical abstraction is a powerful technique that allows static analysis to \nrepresent a (potentially unbounded) set of concrete objects with a bounded number of abstract objects. \nThe partitioning imposed on the set of the concrete objects is dynamic in a sense that the same abstract \nobject may represent di.erent groups of the concrete objects within the same abstract state. The net \nresult is an ability to avoid per\u00ad Example Abstract Memory Con.gurations (AMCs) Time for Coerce &#38; \nFocus (%) Time (sec) Max AMCs per state Max nodes per AMC Array initialization Partial initialization \nArray copy Insertion sort 7 35 7 38 8 20 13 14 68.3 86.3 94.2 85.5 1.7 194.0 338.1 48.5 Figure 11: Analysis \nmeasurements: maximal number of abstract memory con.gurations in an abstract state, maximal number of \nabstract objects in an abstract memory con.guration, percentage of the overall analysis time spent on \nfocus and coerce operations, and the overall analysis time. forming weak updates, which greatly improves \nthe precision of the analysis. In this paper, we explore the possibilities for combining canonical abstraction \nwith existing numeric analyses and applications of the combined analysis to the problem of analyzing \narray operations. The analysis we de.ne in this paper is capable of automat\u00adically establishing interesting \narray properties; in particular, we show how it is able to capture numeric constraints on the values \nof array elements after an array-initialization loop. More sophisticated properties, such as verifying \nthe imple\u00admentation of comparison-based sorting algorithms, require some human intervention to de.ne \nnecessary auxiliary pred\u00adicates along with their abstract transformers. The auxiliary predicates that \nare introduced are problem-speci.c,rather then program-speci.c, which allows them to be reused for the \nanalysis of other programs. The prototype implementation of the analysis, although not very e.cient, \ncan be used to analyze interesting array operations in reasonable times.  9. REFERENCES [1] R. Bagnara, \nE. Ricci, E. Za.anella, and P. M. Hill. Possibly not closed convex polyhedra and the parma polyhedra \nlibrary. In Static Analysis Symp.,volume 2477, pages 213 229, 2002. [2] B. Blanchet, P. Cousot, R. Cousot, \nJ. Feret, L. Mauborgne, A. Min\u00b4e, D. Monniaux, and X. Rival. Design and implementation of a special-purpose \nstatic program analyzer for safety-critical real-time embedded software. In The Essence of Computation: \nComplexity, Analysis, Transformation., pages 85 108. Springer-Verlag, 2002. [3] P. Cousot and R. Cousot. \nAbstract interpretation: A uni.ed lattice model for static analysis of programs by construction of approximation \nof .xed points. In Symp. on Princ. of Prog. Lang., pages 238 252, New York, NY, 1977. ACM Press. [4] \nP. Cousot and R. Cousot. Systematic design of program analysis frameworks. In Symp. on Princ. of Prog. \nLang., pages 269 282, New York, NY, 1979. ACM Press. [5] P. Cousot and N. Halbwachs. Automatic discovery \nof linear constraints among variables of a program. In Symp. on Princ. of Prog. Lang., 1978. [6] C. Flanagan \nand S. Qadeer. Predicate abstraction for software veri.cation. In Symp.on Princ.ofProg. Lang., pages \n191 202, 2002. [7] D. Gopan, F. DiMaio, N. Dor, T. Reps, and M. Sagiv. Tools and Algorithms for the Construction \nand Analysis of Systems, pages 512 529, 2004. [8] N. Halbwachs, Y.-E. Proy, and P. Roumano.. Veri.cation \nof real-time systems using linear relation analysis. Formal Methods in System Design, 11(2):157 185, \n1997. [9] S. K. Lahiri and R. E. Bryant. Indexed predicate discovery for unbounded system veri.cation. \nIn Int. Conf. on Computer Aided Veri.cation, pages 135 147, 2004. [10] L. Lamport. A new approach to \nproving the correctness of multiprocess programs. Trans. on Prog. Lang. and Syst., 1(1):84 97, July 1979. \n[11] T. Lev-Ami and M. Sagiv. TVLA: A system for implementing static analyses. In Static Analysis Symp., \npages 280 301, 2000. [12] R. Manevich, M. Sagiv, G. Ramalingam, and J. Field. Partially disjunctive heap \nabstraction. In Static Analysis Symp., pages 265 279, 2004. [13] F. Masdupuy. Array Indices Relational \nSemantic Analysis using Rational Cosets and Trapezoids.PhD thesis, Ecole Polytechnique, 1993. [14] A. \nMine. The octagon abstract domain. In Proc. Eighth Working Conf. on Rev. Eng., pages 310 322, 2001. [15] \nA. Mine. A few graph-based relational numerical abstract domains. In Static Analysis Symp., pages 117 \n132, 2002. [16] G. Peterson. Myths about the mutual exclusion problem. Information Processing Letters, \n12(3):115 116, June 1981. [17] T. Reps, M. Sagiv, and A. Loginov. Finite di.erencing of logical formulas \nfor static analysis. In European Symp. on Programming, pages 380 398, 2003. [18] T. Reps, M. Sagiv, and \nG. Yorsh. Symbolic implementation of the best transformer. In Veri.cation, Model Checking, and Abstract \nInterpretation, pages 252 266, 2004. [19] M. Sagiv, T. Reps, and R. Wilhelm. Parametric shape analysis \nvia 3-valued logic. Trans. on Prog. Lang. and Syst., 24(3):217 298, 2002. [20] P. .y. V\u00b4etation abstraite \nde Cern\u00b4eri.cation par interpr\u00b4pr\u00b4edicats param\u00b4etriques. D.E.A. Report, Univ. Paris \u00b4 VII &#38; Ecole \nnormale sup\u00b4erieure, September 2003. [21] G. Yorsh, T. Reps, and M. Sagiv. Symbolically computing most-precise \nabstract operations for shape analysis. In Tools and Algorithms for the Construction and Analysis of \nSystems, pages 530 545, 2004.  \n\t\t\t", "proc_id": "1040305", "abstract": "Automatic discovery of relationships among values of array elements is a challenging problem due to the unbounded nature of arrays. We present a framework for analyzing array operations that is capable of capturing numeric properties of array elements.In particular, the analysis is able to establish that all array elements are initialized by an array-initialization loop, as well as to discover numeric constraints on the values of initialized elements.The analysis is based on the combination of canonical abstraction and summarizing numeric domains. We describe a prototype implementation of the analysis and discuss our experience with applying the prototype to several examples, including the verification of correctness of an insertion-sort procedure.", "authors": [{"name": "Denis Gopan", "author_profile_id": "81100414876", "affiliation": "University of Wisconsin", "person_id": "P707737", "email_address": "", "orcid_id": ""}, {"name": "Thomas Reps", "author_profile_id": "81100117392", "affiliation": "University of Wisconsin", "person_id": "PP40023877", "email_address": "", "orcid_id": ""}, {"name": "Mooly Sagiv", "author_profile_id": "81100150928", "affiliation": "Tel-Aviv University", "person_id": "PP39029858", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1040305.1040333", "year": "2005", "article_id": "1040333", "conference": "POPL", "title": "A framework for numeric analysis of array operations", "url": "http://dl.acm.org/citation.cfm?id=1040333"}