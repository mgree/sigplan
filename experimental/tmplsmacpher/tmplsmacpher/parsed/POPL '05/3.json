{"article_publication_date": "01-12-2005", "fulltext": "\n A Simple Typed Intermediate Language for Object-Oriented Languages Juan Chen David Tarditi Microsoft \nResearch Microsoft Research One Microsoft Way One Microsoft Way Redmond, WA 98052 Redmond, WA 98052 \njuanchen@microsoft.com dtarditi@microsoft.com ABSTRACT Traditional class and object encodings are di.cult \nto use in practical type-preserving compilers because of the com\u00adplexity of the encodings. We propose \na simple typed inter\u00admediate language for compiling object-oriented languages and prove its soundness. \nThe key ideas are to preserve lightweight notions of classes and objects instead of com\u00adpiling them away \nand to separate name-based subclassing from structure-based subtyping. The language can express standard \nimplementation techniques for both dynamic dis\u00adpatch and runtime type tests. It has decidable type checking \neven with subtyping between quanti.ed types with di.erent bounds. Because of its simplicity, the language \nis a more suitable starting point for a practical type-preserving com\u00adpiler than traditional encoding \ntechniques.  Categories and Subject Descriptors D.3.3 [Programming Languages]: Language Constructs and \nFeatures Classes and Objects; D.3.1 [Programming Languages]: Formal De.nitions and Theory General Terms \nLanguages  Keywords Typed intermediate language, class and object encoding 1. INTRODUCTION Preserving \ntypes during compilation has signi.cant bene\u00ad.ts [33, 32, 25, 14]. Types can be used to debug compilers, \nto guide optimizations, and to generate safety proofs for programs [26]. In practice, however, compilers \nfor object\u00adoriented languages do not use statically typed low-level in\u00adtermediate languages, even though \ntheir input is statically typed. Permission to make digital or hard copies of all or part of this work \nfor personal or classroom use is granted without fee provided that copies are not made or distributed \nfor pro.t or commercial advantage and that copies bear this notice and the full citation on the .rst \npage. To copy otherwise, to One reason compilers for object-oriented languages have not adopted type-preserving \ncompilation is the complex\u00adity of traditional class and object encodings. A practical compiler requires \nsimple, general and e.cient type systems. First, compiler writers who are not type theorists should be \nable to understand the type system. Second, the type sys\u00adtem needs to cover a large set of realistic \nlanguage features and compiler transformations. Third, the type system needs to express standard implementation \ntechniques without in\u00adtroducing extra runtime overhead. Traditional encodings are not a good match for \nthese goals. We discuss these en\u00adcodings more in Section 7. This paper describes a simple typed intermediate \nlan\u00adguage LILC (Low-level Intermediate Language with Classes) for compiling class-based object-oriented \nlanguages. LILC is lower level than JVML [25] or CIL [14]. The key ideas are to preserve lightweight \nnotions of classes and objects instead of compiling them away and to separate name-based subclass\u00ading \nfrom structure-based subtyping. LILC divides types into two parts: one part uses class names to type \nobjects and keeps the name-based class hier\u00adarchy; the other part uses record types and has structural \nsubtyping. Each class has a corresponding record type that represents its object layout. Objects and \nrecords can be coerced to each other with no runtime overhead. Keeping classes and objects has a low \ncost because most interesting work, such as .eld fetching, method invocation and cast, is done on records. \nOur approach simpli.es the type system. First, structural recursive types are not necessary because each \nrecord type can refer to any class name, including the class to which the record type corresponds. Second, \nit simpli.es the bounded quanti.cation that is needed to express inheritance. The bounds for type variables \nare in terms of subclassing, not subtyping as in traditional bounded quanti.cation. Thus, the bounds \nmust be classes or type variables, not arbitrary types. As a result, LILC has decidable type checking. \nThe contributions of this work include: LILC is simpler and more natural than traditional en\u00adcodings. \nIt is also sound and e.cient.  LILC can express standard implementation strategies for self application, \ndynamic type dispatch, and run\u00adtime type tests.    republish, to post on servers or to redistribute \nto lists, requires prior speci.c LILC uses existential types and invariant array types permission and/or \na fee. to describe covariant source-level array types. It can POPL 05, January 12 14, 2005, Long Beach, \nCalifornia, USA. Copyright 2005 ACM 1-58113-830-X/05/0001 ...$5.00. also express runtime store checks \n. Instructions for distance Figure 1: Object Layout for Point By supporting the decomposition of runtime \nprimi\u00adtives such as type cast and runtime store checks, LILC makes the interface between the runtime \nsystem and compiled code more explicit and checkable. The rest of the paper is organized as follows. \nSection 2 gives an informal overview of LILC . The next two sections explain the syntax and semantics \nof LILC . Section 5 de\u00adscribes a source language and the translation from the source language to LILC \n. Section 6 presents some extensions. Sec\u00adtion 7 discusses related work and Section 8 concludes.  2. \nOVERVIEW This section describes informally how LILC addresses the implementation of object-oriented features \nsuch as object layout, inheritance, dynamic dispatch and runtime type tests. Roughly speaking, LILC supports \nfeatures in Featherweight Java [21], assignments and arrays. For clarity, we make some simpli.cations. \nFirst, we omit non-virtual methods. The compiler can transform those methods to global func\u00adtions (with \nexplicit this pointers) because it knows all call sites of those methods. Second, we make each class \ncontain declarations of all its members, including the inherited ones from its super classes. Third, \nwe rename variables so that they are all unique. Finally, we omit null references and consider only proper \nobjects. 2.1 Object Layout LILC has both class names and record types. We use B, C and D to range over \nclass names. Each class name C has a corresponding record type R(C) that describes its ob\u00adject layout \nthe organization of .elds, methods and runtime tags. R is not a constructor in LILC , but a macro used \nby the type checker (Section 4.1.1). We use a standard object layout. An object of C contains avtable \nof C and .elds. Therefore, R(C) is a record type containing entries for C s vtable and .elds. The vtable \nis a record that includes a runtime tag for the class and function pointers for the virtual methods. \nThe runtime tag contains class-speci.c information and is used to identify the class. As shown in Section \n4.1.1, it is easy to substitute other layout strategies for the current one. The type of a .eld or a \nmethod in R(C)can refer to any class name declared in the program, including C.This allows a straightforward \ntyping of self-application seman\u00adtics [22], where each method takes the this pointer as its .rst parameter. \nLILC assigns the type .a . C. a,which represents objects of class C or C s subclasses, to the this pointer \nof methods in C. We explain the type in Section 2.2. We use the following example throughout the paper: \nclass Point {int x; int distance(){...}} The object layout of Point is shown in Figure 1. Type R(Point) \nrepresents this layout naturally: R(Point) = {vtable : {tag : Tag(Point), distance :(.a . Point.a) . \nint}, x :int} The tag of a class C identi.es C at run time. Its type is represented as Tag(C), where \nTag is an abstract type constructor. For simplicity, we treat tags as abstract. An object of C can be \ncoerced to a record of type R(C) and vice versa. The coercions are no-ops at run time and introduce no \noverhead. Object Creation To create an object of class C,wecre\u00adate a record of R(C) and then coerce the \nrecord to an object. Field Fetch To fetch a .eld from an object, we coerce the object to a record and \nfetch the .eld from the record. Method Invocation To call a method on an object o of class C,we coerce \no to a record, fetch the vtable from the record, then fetch the method from the vtable, and pass o (after \npackingit tohavetype .a . C. a)to the method. This is exactly how most compilers implement vir\u00adtual method \ninvocation, if we ignore types and coercions, which turn into no-ops at run time anyway. R(C) speci.es \nthe full shape of an object of C, including the .elds and methods from C s super classes. The inher\u00adited \nmembers must have the same order in C as in C s super classes, and appear before the members speci.c \nto C. Sup\u00adpose class Point2D extends class Point as follows: class Point2D : Point{ int y; int distance(){...y...}} \nR(Point2D) will be the following type : R(Point2D) = {vtable : {tag : Tag(Point2D), distance :(.a . Point2D.a) \n. int}, x :int,y :int} R(Point2D) includes members in Point, but it has its own tag and its own type \nfor the this pointer. 2.2 Subclassing and Bounded Quanti.cation LILC de.nes a subclassing relation \u00ab \nbetween class names to preserve the name-based class hierarchy in the source program. If a class C extends \nclass B,then C . B. For example, Point2D . Point. The subclassing relation is re.exive and transitive. \nIn most source languages, a class name C describes ob\u00adjects of C and C s subclasses. LILC translates \na source-level class name C to an existential type with subclassing-based quanti.cation: .a . C. a,where \na indicates the actual class. Objects that have type C or one of C s subclasses can be packed to have \ntype .a . C. a. A class name in LILC represents only objects of itself. Similarly, type variables introduced \nby universal types can have bounds too. Type .a . C. t describes terms (poly\u00admorphic functions) that \nwork on C and any subclass of C. The bound of a type variable must be a class name or another type variable, \nnot an arbitrary type. The bound never refers to the type variable it constrains1 . 2.3 Dynamic Dispatch \nDynamic dispatch requires a distinction between the static type and the dynamic type of an object. LILC \nuses class names for exact types (dynamic types) and existential types for imprecise types (static types). \nBy having exact notions, LILC excludes unsafe dynamic dispatch. Consider the following function: void \nTest(Point p1,Point p2){ vt = p1.vtable; dist = vt.distance; dist(p2); } This function is unsafe, even \nthough the distance method fetched from p1 requires an object of Point and p2 is indeed an object of \nPoint. The function Test can be called in an unsafe way: Point point1 = new Point2D(...); Point point2 \n= new Point(...); Test(point1,point2); The argument point1 is an object of Point2D. The dis\u00adtance method \nfetched from point1 s vtable accesses the .eld y,which point2 does not have. A language without away \nto express exact dynamic types cannot catch such errors. In LILC ,if anobject has type t and its vtable \ncontains amethod m, then only objects of type .a . t. a can be passed to the this pointer of m. In this \nrepresentation, Test is translated to an ill-typed function: void Test(p1 : .a . Point.a, p2 : .\u00df . Point.\u00df){ \n(a, p. 1)= open(p1); p '. 1 = toRecord(p1. ); vt = p1 .vtable; dist = vt.distance; dist(p2); //ill-typed! \n} p1 . has type a and dist requires an object of type .d . a. d. Object p2 does not have this type. \n2.4 Subtyping LILC also has structural subtyping, represented by = . The subtyping relation is re.exive \nand transitive. Record types have standard pre.x subtyping and depth subtyping on immutable .elds. By \npre.x subtyping, ap\u00adpending more .elds to a record type creates a subtype. The super type is a pre.x \nof the subtype. Specializing immutable .eld types leads to depth subtyping. LILC excludes depth subtyping \non mutable .elds to preserve soundness. The la\u00adbel order in a record type is signi.cant because the .elds \nrepresent the physical layout of data. LILC uses record subtyping to approximate the layout of an object \nwhose exact type is unknown at compile time. A detailed explanation is in Section 4.1.1. Bounded quanti.ed \ntypes have subtyping. The most fre\u00adquently used rule is (.a . C. a) = (.a . B. a)if C . B. It is used \nfor: 1LILC has a much simpler solution to binary methods than F-bounded quanti.cation [5]. See Section \n6.2. tag vtable of C Figure 2: Tag Chains Inheritance Subsumption If C . B andanobject o has type .a \n. C. a,then o canbe usedwhereveranobject of class B or B s subclasses (type .a . B. a)is expected. Inherited \nMethod Implementation A subclass can in\u00adherit a method implementation from its super classes. Sup\u00adpose \nclass C is a subclass of B. The this pointer of meth\u00adods in C has type .a . C. a. The this pointer of \nmeth\u00adods in B has type .a . B. a.Because (.a . C. a) = (.a . B. a), a function that takes a parameter \nof type .a . B. a can be used as one with a parameter of type .a . C. a,that is, C can use B s method \nimplementation. Subclassing is distinct from subtyping. If C . B and C and B are di.erent classes, then \nC is not a subtype of B,and neither is R(C) a subtype of R(B), because C represents objects of exact \nC.An object of exact C cannot be used where an object of exact B is needed.  2.5 Type Cast It is di.cult \nto model the implementation of downward type casts in a typed language. Most typed intermediate languages \ntreat downcast as a primitive. Downward type casts check at run time whether an ar\u00adbitrary object belongs \nto some class or its subclasses. In a typical implementation, each class stores a tag in its vtable. \nIf C extends B, then the tag of C has a pointer pointing to the tag of B (Figure 2). The pointers form \na tag chain. Downward type casts fetch tags in the chain and compare them with the tag of the target \nclass. This implementation can be expressed as a well-typed function in LILC that can be used for arbitrary \nobjects and arbitrary classes. The key ideas are to use types to con\u00adnect an object with the tag it contains, \nand to re.ne types according to the tag comparison result. The tag of class C is represented as a constant \ntag(C), which has type Tag(C). If an object has type t , then the tag it contains has type Tag(t ). The \ntype checker checks the connection at object creation sites. Tag comparison is based on that two classes \nare the same i. their tags are equal. If an object o has type t and the tag in o is equal to tag(C), \nthen t = C. If one of the parent tag, which identi.es a parent class of t ,isequal to tag(C), then t \n. C and o canbe packedtohave type .d . C. d. Figure 3 shows a global polymorphic function that im\u00adplements \ndowncast. More details of the function are in Section 4.1.3. Primitive ifEqTag compares tags and if-Parent \ntests whether there exists a parent tag. Each of them corresponds to only two x86 instructions compare \nand branch. We could further break down the primitives by exposing tag details. The details are irrelevant \nto our basic ideas, so we keep tags abstract for simplicity. A companion technical report explains how \nto express op\u00adtimizations of the above linear search, such as caching the  fix Downcast(a,\u00dfH(ta :Tag(a),obj \n: \u00df): .d \u00aba. d = //ta : tag of target class a,obj :object to cast loop[a,\u00df,\u00df](ta,obj,(c2r(obj).vtable).tag) \nfix loop(a,.,\u00df \u00ab.H(ta :Tag(a),obj : \u00df,t. :Tag(.)) : .d \u00aba. d = //t. : a tag in the tag chain ifEqTag.d\u00aba. \nd(t. ,ta)thenpack \u00df as d \u00ab. in (obj : d)else //. = a ' ifParent(t. )thenbind(.',t. )in loop[a,.',\u00df](ta,obj,t'. \n) else error[.d \u00aba. d] //. \u00ab.' Figure 3: Cast Method most recently successful parent tag, or storing \na display of super classes [10]. It also explains array casting.  2.6 Arrays Covariant array types require \nruntime store checks each time an object is stored into an array. If array a has type array(B), to store \nan object of type B in a,we have to check whether the object has the actual element type of a because \na might be an array of B s subclasses. LILC uses existential types and invariant array types to express \nsource-level array types. LILC type ARRAY(B)= .a \u00abB.{tag :Tag(a),table : array(.\u00df \u00aba. \u00df)}represents source \ntype array(B). The outer existential type binds the actual element type of the array, and the inner one \nbinds the actual type of each element. The tag indicates the ar\u00adray element type. The source-level array \nsubtyping is trans\u00adferred to subtyping on existential types in LILC .If C is a subclass of B,then ARRAY(C) \n=ARRAY(B). To store an object inanarray, LILC programs must ex\u00adplicitly check whether the object matches \nthe element type of the array. The cast routine in Figure 3 will su.ce. The checks are inserted automatically \nby the translation from source programs, and can be eliminated if the type system can prove that the \nelimination is safe. LILC relies on runtime checks for array-bounds checking. For simplicity, it does \nnot reason about integer constraints. 3. SYNTAX OF LILC LILC extends the polymorphic lambda calculus \nwith class names, subclassing, subclassing-based quanti.cation and im\u00ad perative features. Figures 4, \n5 and 6 show the syntax. The notation represents empty lists. 3.1 Kinds and Types . ::= . |.c t ::= \nint |C |Tag(t) |a |array(t) |.a \u00abt. t' |.a\u00abt. t' |(t1,...,tn) .t lf1 lf1 |{: t1,...,lfn : tn}|{{: t1,...,lfn \n: tn} 1 n 1 n tvs ::= |a \u00abt,tvs f ::= I |M Figure 4: Kinds and Types LILC uses a special kind .c to \nclassify class names: only class names and type variables that will be instantiated with class names \nhave kind .c. Topc is a special class name that is a super class of all classes, like System.Object in \nMicrosoft CLI. Kind .c guarantees that certain operations, such as \u00ab and Tag , are applied properly. \nKind . is used for other types. Kind .c is a subkind of .. Standard types in LILC include int, type variables, \narray types, function types and record types {lf1 n 1 : t1,...,lfn : tn}. The superscript annotations \nI or M on record .elds indicate immutable or mutable .elds respectively. For con\u00advenience, I is often \nomitted. Non-standard types are class names, tag types, bounded quanti.ed types and exact record types. \nSection 2 explained the .rst three types already. Exact record types are denoted by { and } . Some\u00adtimes \nthe type checker needs to know the full shape of a record all .elds in the record. For example, when \na record is coerced to an object, the record must have and only have the elements speci.ed in the class \ndeclaration. Extra .elds are undesirable. The normal record type is imprecise be\u00adcause of pre.x subtyping. \nA record of an exact record type lf1 { : t1,...,lfn : tn} has and only has .elds labeled as 1 n l1,...,ln. \nThese .elds have types t1,...,tn respectively. Type R(C), which describes the object layout of C,isan \nexact record type. The vtable in R(C) also has an exact record type to exclude extra .elds (extra methods). \nTo simplify the type system, LILC has the subtyping rule lf1 lf1 { : t1,...,lfn : tn}}={: t1,...,lfn \n: tn}. 1 n 1 n Type .a1 \u00abt1......an \u00abtn.t is often abbreviated as .a1 \u00ab t1,...,an \u00abtn.t. Existential \ntypes have similar abbreviation. The upper bound Topc is often omitted. 3.2 Values and Expressions v \n::= n |f |C(v) |tag(C) |pack t as a\u00abtu in (v : t') n hv ::= {li = vi}i=1 |[v0,...,vn-1]t |.x g(tvsH(x1 \n: t1,...,xn : tn): t = em e ::= x |n |f |tag(C) |C(e) |c2r(e) |error[t] n |new[t]{li = ei}i=1 |e.l |e1.li \n:= e2 in e3 |new[e0,...,en-1]t |e1[e2] |e1[e2]:= e3 in e4 |x: t = e1 in e2 |x:= e1 in e2 |e[t1,...,tm](e1,...,en) \n|pack t as a\u00abtu in (e: t') |(a,x)=open(e1)in e2 |ifParent(e)thenbind(a,x)in e1 else e2 |ifEqTagt (et1,et2)then \ne1 else e2 Figure 5: Values and Expressions LILC has the following word-size values: integer literal \nn, label f (a pointer to a value on the heap), C(v)representing an object of C coerced from a record \nlabeled by v,runtime tag tag(C) for class C and packed word-size values. Large values records, arrays \nand functions are allocated on the heap. Function .x g(tvsH(x1 : t1,...,xn : tn): t = em declares a \nfunction g with type variables tvs,formals x1 : t1,...,xn : tn,return type t and function body em. The \nbody em can call g recursively. Most expressions in LILC are standard. The notation := stands for assignment \nand e[e ' ] stands for array el\u00adement access. Expression new[t]{ l1 = e1,...,ln = en} creates a record \nof type t. Expression new[e0,...,en-1]t creates an array of t. The let expression x : t = e in e ' \nspeci.es the type of the new variable x. The pack expres\u00adsion pack t as a \u00ab tu in (e : t ' ) hides type \nt with a type variable a bounded by tu. Expression C(e) coerces a record e to an object of C, and c2r(e) \ncoerces an object e to a record. Expression ifParent(e)thenbind(a, x)in e1 else e2 tests whether tag \ne has a parent tag. If so, a new value variable x is introduced to represent the parent tag and a new \ntype variable a is bound to the type x indicates, and the control transfers to e1. Otherwise, the control \ntransfers to e2. Expression ifEqTagt (et1,et2)then e1 else e2 is a condi\u00adtional branch for tag comparison. \nIf two tags et1 and et2 are the same, e1 is evaluated. Otherwise e2 is evaluated. The expression speci.es \nthe result type t for the whole expres\u00adsion to simplify type checking. Expression error[t] represents \nruntime errors, such as cast failures. Type t means that a value of type t is expected if no errors happen. \nFuture versions of LILC will replace error expressions with exception handling. 3.3 Classes and Programs \nfield ::= f : t method ::= m : . tvs (t1,...,tn) . t ---. - ---. class ::= C : B{ field, method}H ::= \n| H,f . hv V ::= | V, x = v ---. prog ::= (class; H; V ; e) Figure 6: Classes and Programs A .eld declaration \nf : t declares a .eld f of type t. Type t contains no free type variables. A method declara\u00adtion m : \n. tvs (t1,...,tn) . t declares a method m with type variables tvs,formal types t1,...,tn and return type \nt.Types t1,...,tn and t can contain only type variables in tvs. Method declarations do not have explicit \nthis types. A class declaration has a class name, a parent class, a - . collection of .eld declarations \nand method declarations (. means a list of items in .). Class declarations contain only the signatures \nof their methods, not any implementations. Method bodies are translated to functions on the heap, and \nthey are called through function pointers inside vtables. Finally a program has a set of class declarations, \na heap H that maps labels to heap values, a set of variable-value bind\u00adings V , and a main expression. \nMethod implementations and vtables are static data on the heap and are generated during the translation \nfrom the source language.  4. LILC SEMANTICS 4.1 Static Semantics LILC maintains a class declaration \ntable T that maps class names to declarations. The class declaration part of a pro\u00adgram can serve as \nsuch a table. A kind environment . tracks type variables in scope and their bounds. Each entry in . introduces \na new type vari\u00adable and an upper or lower bound of the type variable. The bound is a class name or another \ntype variable introduced previously in .. The typing rule for expression ifParent introduces type variables \nwith lower bounds (Figure 10). A heap environment S maps labels to types. A type en\u00advironment G maps \nvariables to types. An entry x :M t in G means that variable x is mutable. Substitution t/a means replacing \na with t. 4.1.1 Helper Functions We .rst explain three important helper functions that the type checker \nuses. The .rst function addThis(tthis,t) adds tthis,the type for the this pointer, to a function type \nt. addThis(tthis, . tvs (t1,...,tn) . t) = . tvs(tthis,t1,...,tn) . t Suppose a class C has .elds f1 \n: s1,...,fn : sn and meth\u00adods m1 : t1,...,mk : tk. Function R(C) returns an exact record type that represents \nthe object layout of C. Function ApproxR(a, C) returns a normal record type that approxi\u00admates R(a) for \nsome type variable a \u00ab C. R(C)= { vtable : { tag : Tag(C), m1 : addThis(. . \u00ab C. .,t1),..., mk : addThis(. \n. \u00ab C. .,tk)} , f1 M : s1,...,fnM : sn} ApproxR(a, C)= { vtable : { tag :Tag(a), m1 : addThis(. . \u00ab \na. .,t1), ..., mk : addThis(. . \u00ab a. .,tk)} , f1 M : s1,...,fnM : sn} ApproxR(a, Topc) = { vtable : { \ntag :Tag(a)}} In ApproxR(a, C), the tag has type Tag(a) and the this pointer has type . . \u00ab a. .. ApproxR(a, \nTopc) contains only a vtable and the vtable contains only the tag of a. Structural record subtyping guarantees \nthat the approxi\u00admation of ApproxR is valid. Suppose an object o has type . a \u00ab Point.a. It might be \nan object of Point or any sub\u00adclass of Point. The layout of o can be approximated by: ApproxR(a, Point) \n= { vtable : { tag :Tag(a), distance :(. . \u00ab a. .) . int} , x M :int } If o is actually an object of \nPoint2D, its layout is: R(Point2D) = { vtable : { tag : Tag(Point2D), distance :(. . \u00ab Point2D..) . int} \n, x M :int,y M :int} Structural record subtyping in LILC guarantees that R(Point2D) = ApproxR(a, Point)[Point2D/a]holds. \nThe two helper functions R(C) and ApproxR(a, C) need full knowledge of what layout the compiler chooses \nfor ob\u00adjects. Therefore, the layout information is part of the type system. However, only three typing \nrules use the helper functions. The rest of the type system is independent of the layout strategy. The \nsoundness of the type system only re\u00adquires that: (1) ApproxR(a, C) = ApproxR(a, B)if C \u00ab B; (2) R(C) \n= ApproxR(a, B)[C/a]if C \u00ab B (Section C.3 in C .domain(T) T; . ft :.c T; fC :.c T; . fTag(t):. a \u00abt ..or \na \u00bbt .. T; fTopc : .c T; . fa:.c T; . ft :.c T; . ft :.c T; .,a\u00abt ft ' :. T;.,a\u00abt ft ' :. T; . f.a \u00abt. \nt ' :. T;. f.a \u00abt. t ' :. Figure 7: Selected Kinding Rules T(C)= C : B{...} T; . ft :.c T; . ft :.c T; \n. fC \u00abB T; . ft \u00abTopc T; . ft \u00abt T; . ft1 \u00abt2 a \u00abt .. a \u00bbt .. T; . ft2 \u00abt3 T; . fa \u00abt T; . ft \u00aba T; . \nft1 \u00abt3 Figure 8: Subclassing Rules the appendix of the technical report). The type system is parameterized \nby the compiler layout strategies. 4.1.2 Types The kinding judgment T; . f t : . means that under environments \nT and ., type t has kind .. All rules are standard except for the kind .c. Figure 7 shows some kind\u00ading \nrules. The rest are in the technical report. The subclassing judgment T; . ft1 \u00abt2 means that un\u00adder \nenvironments T and ., t1 is a subclass of t2 (Figure 8). The subtyping judgment T; . ft1 =t2 means that \nunder environments T and ., t1 is a subtype of t2 (Figure 9). Subtyping between quanti.ed types is similar \nto Castagna and Pierce s .-top rule [9], where the checker ignores the bounds of type variables (relax \nit to Topc) when check\u00ading subtyping between the body types. Contrary to LILC , Castagna and Pierce s \nbounded quanti.cation was based on subtyping, and did not have the minimal type property [8]. 4.1.3 \nExpressions The typing judgment T; .; S; G f e : t means that un\u00adder environments T,.,S andG,expression \ne has type t. Figure 10 shows all expression typing rules. Only records of type R(C) can be coerced to \nobjects of C.Coercing an object of C to a record results in a record of type R(C). Coercing an object \nof a to a record results in a record of type ApproxR(a,C)if a \u00abC. In a call expression e[t1,...,tm](e1,...,en) \n, emust have a function type .tvs(s1,...,sn) . s. The type arguments t1,...,tm must satisfy the constraints \ntvs speci.es. The value arguments e1,...,en have types s1,...sn respectively, after the type variables \nin tvs are replaced with t1,...,tm. In ifParent(e)thenbind(a,x)in e1 else e2 , tag e has type Tag(t)for \nsome type t.If e has a parent tag, a new type variable a is introduced for the super class of t and a \nnew value variable x (of type Tag(a)) is introduced for the parent tag. In ifEqTagt (et1,et2)then e1 \nelse e2 , if both et1 and et2 are tags for concrete class names, the type checker only checks the branch \nto be taken. Otherwise, the .rst tag et1 must have type Tag(.) for some type variable .. The second m \n=n fi mfi n T; . f{l: ti}={l: ti} ii=1 ii=1 T; . fti =t ' if fi = I .1 =i =m,i = t ' if fi = M tii fi \nmfi m T; . f{l: ti}={l: t ' } ii=1 i ii=1 fi mfi m T; . f{{l: ti} ={l: ti} ii=1 ii=1 T; . fti =si .1 \n=i =n T; . fs=t T; . f(s1,...,sn) .s=(t1,...,tn) .t T; . fu1 \u00abu2 T; .,a\u00abTopc ft1 =t2 T; . f(.a \u00abu1.t1) \n=(.a \u00abu2.t2) T; . fu2 \u00abu1 T; .,a\u00abTopc ft1 =t2 T; . f(.a \u00abu1.t1) =(.a \u00abu2.t2) T; . ft1 =t2 T; . ft2 =t3 \nT; . ft =t T; . ft1 =t3 Figure 9: Subtyping Rules tag et2 can be a tag for type t. , either a class name \nor a type variable introduced before ..The checker uses . = t. to re.ne the type of the true branch e1,because \n. = t. must hold if the true branch is taken. The false branch has no type re.nement. As usual, a subsumption \nrule says: if t1 = t2 and e has type t1,then e has type t2. No similar rules exist for sub\u00adclassing because \nof the exact class notions. We elaborate the downcast function in Figure 3 a bit here to explain the \nusage of ifEqTag . To cast an object obj of type \u00df to a class a,the loop function compares a tag t. in \nthe tag chain of obj with the tag of the target class. t. identi.es . and \u00df \u00ab.. If the two tags are equal, \nthen the cast succeeds: obj is packed to have type .d \u00ab.. d,which is .d \u00aba. d because . = a. Otherwise, \nthe parent tag of t. is fetched and loop is called recursively. The cast fails if no such parent tag \nexists. The downcast function Downcast calls loop with the target tag ta,the object obj and the tag in \nobj s vtable (of type Tag(\u00df)). The typing judgment T; S fhv : t means under environ\u00admentsTandS, heapvalue \nhv has type t (Figure 11). T; ;S; fvi : t .0 =i=n-1 hv array T; S f[v0,...,vn-1]t : array(t) T; ;S; fvi \n: ti .1 =i=n hv record nfi n T; S f{li = vi}: { l: ti} i=1 ii=1 tf = .tvs (t1,...,tn) .t T; tvs;S; g \n: tf ,x1 : t1,...,xn : tn fem : t hv fun T; S f.x g(tvs)(x1 : t1,...,xn : tn): t = em : tf Figure 11: \nHeap Value Typing Rules  4.1.4 Class Declarations and Programs A well-formed class contains all the \nmembers inherited from its parent, which is solely an implementation strategy to simplify looking up \nmembers. LILC requires that the T; . f t :. var error int T; .; S; G f x:G(x) T;.;S;G f n :int T;.;S;G \nf error[t]: t C . domain(T) T; .; S; G f e : R(C) label tag object T; .; S; G f . :S(\u00a3) T;.;S;G f tag(C): \nTag(C) T;.;S;G f C(e): C T; .; S; G f e : C T; .; S; G f e: a T; . f a \u00ab C c2r c c2r tv T; .; S; G f \nc2r(e): R(C) T;.;S;G f c2r(e) : ApproxR(a,C) f1 fn t = { l: t1,...,ln : tn} 1 f1 fn T; .; S; G f ei \n: ti .1 = i = n T; .; S; G f e: {l: t1,...,ln : tn} 1 = i = n 1 record .eld T; .; S; G f new[t]{l1 = \ne1,...,ln = en} : t T; .; S; G f e.li : ti f1 fn T; .; S; G f e1 : {l: t1,...,lM : ti,...,ln : tn} T; \n.; S; G f e2 : ti T; .; S; G f e3 : t1 i assignR T; .; S; G f e1.li := e2 in e3 : t T; .; S; G f ei : \nt .0 = i = n- 1 T;.;S;G f e1 : array(t) T;.;S;G f e2 :int array subscript T; .; S; G f new[e0,...,en-1]t \n: array(t) T;.;S;G f e1[e2]: t T; .; S; G f e1 : array(t) T;.;S;G f e2 :int T;.;S;G f e3 : t T; .; S; \nG f e4 : t ' assignA T; .; S; G f e1[e2]:= e3 in e4 : t ' T; .; S; G f e1 : t T; .; S; G,x:M t f e2 \n: t ' x:M t . G T;.;S;G f e1 : t T; .; S; G f e2 : t ' let assign T; .; S; G f x : t = e1 in e2 : t ' \nT; .; S; G f x:= e1 in e2 : t ' T; .; S; G f e : .tvs(t1,...,tn) . t tvs = a1 \u00ab u1,...,am \u00ab um s = t1,...,tm/tvs \nT; .; S; G f e1 : .\u00df \u00ab tu.t T; . f ti \u00ab ui[s] .1 = i = m a/. domain(.) a/. free(t ' ) T; .; S; G f ei \n: ti[s] .1 = i= n T; .,a\u00ab tu;S; G,x : t[a/\u00df] f e2 : t ' open T; .; S; G f e[t1,...,tm](e1,...,en): \nt[s] call T; .; S; G f (a,x)= open(e1)in e2 : t ' T; . f t \u00ab tu a/. domain(.) T;.;S;G f e: t ' [t/a] \npack T; .; S; G f pack t as a \u00ab tu in (e : t ' ): .a \u00ab tu.t ' T; .; S; G f e :Tag(t) a/. domain(.) T; \n.,a\u00bb t;S; G,x: Tag(a) f e1 : t ' T; .; S; G f e2 : t ' ifParent T; .; S; G f ifParent(e)thenbind(a,x)in \ne1 else e2 : t ' T; .; S; G f et1 :Tag(C1) T;.;S;G f et2 :Tag(C2) C1 = C2 T; .; S; G f e1 : t ifTag \neq T; .; S; G f ifEqTagt (et1,et2)then e1 else e2 : t T; .; S; G f et1 : Tag(C1) T;.;S;G f et2 : Tag(C2) \n.T; .; S; G f e2 : t C1 = C2 ifTag neq T; .; S; G f ifEqTagt (et1,et2)then e1 else e2 : t T; .; S; \nG f et1 : Tag(.) T;.;S;G f et2 : Tag(t. ) .=.1,P(.),.2 P(.)= . \u00ab u or P(.)= . \u00bb u T; .1 f t. :.c T; .; \nS; G f e : t1 T; .; S; G f e1 : t[./t. ] T;.;S;G f e2 : t T; . f t1 = t2 ifTag tv T; .; S; G f ifEqTagt \n(et1,et2)then e1 else e2 : t T; .; S; G f e : t2 sub Figure 10: Expression Typing Rules   parent class \nbe declared before the child class. Figure 12 shows the rule for class declarations. T fTopc{} T fB \n: D{f1 : s1,...,fp : sp,m1 : t1,...,mq : tq } B declared before C in T D is optional p =nq =k T; fsi \n:. .p+1 =i=n T; fti :. .q+1 =i =k T fC : B{f1 : s1,...,fn : sn,m1 : t1,...,mk : tk} Figure 12: Well-formedness \nof Class Declarations A program (T; H; V; e) is well-formed with respect to a heap environment if its \nclass declaration T is well-formed, the heap H respects the heap environment, the variable\u00advalue binding \nV is well-formed and the main expression e is well-typed (see Figure 13). The main expression e has no \nfree type variables, and refers only to labels in H and variables in V. domain(V)= domain(G) T; ;S; fV(x): \nG(x) .x .domain(V) T; S fV :G domain(H)= domain(S) T; S fH(\u00a3):S(\u00a3) .\u00a3 .domain(H) T fH :S T= class1,...,classm \nT fclassi .1 =i =m T fH :S T;S fV :G T; ;S; G fe: t S f(T; H; V; e): t Figure 13: Well-formedness of \nPrograms  4.2 Dynamic Semantics Figure 14 shows all the evaluation rules except for congru\u00adence rules. \nThe programs in the .rst column evaluate one step to the corresponding ones in the second column, if \nthe side conditions in the third column hold. Judgment P .P ' means that program P steps to P ' . Expressions \nC(v)and c2r(v) coerce between objects and records. ifParent(tag(C)) then bind (a,x)in e1 else e2 steps \nto e1 with a replaced with B and x assigned tag(B), if C extends some class B. Otherwise it steps to \ne2. Expression ifEqTagt (tag(C1),tag(C2)) then e1 else e2 steps to e1 if C1 = C2,and to e2 otherwise. \nThe evaluation of an error expression error[t] in.nitely loops. 4.3 Properties of LILC We have proved \nthe soundness of LILC ,in the style of [34], and the decidability of type checking. Full proofs are in \nthe technical report. Theorem 1 (Preservation). If S fP : t and P. P ' ,then .S ' such that S ' fP ' \n: t. Theorem 2 (Progress). If S fP : t, then either the main expression in P is a value, or .such that \nP . P ' .P ' Proof sketch: by standard induction over the typing rules. Combining these two theorems, \nwe can conclude that a well-formed LILC program never gets stuck: if the main expression in a program \nis not a value, the program can always go one more step to another well-formed program. Theorem 3 (Decidability \nof Type Checking). It is decidable whether T; .; S; G fe: t holds. Proof sketch: by proving the minimal \ntype property and decidability of subtyping. We designed a set of syntax\u00addirected subtyping rules (without \nthe transitivity rule) of the form T; . F t1 =t2. We proved that the new rules terminate and that T; \n. ft1 =t2 i. T;. F t1 =t2. Similarly, we designed a set of syntax-directed expression typing rules (without \nthe subsumption rule) of the form T; .; S; G F e : t and proved that: (1) the new rules termi\u00adnate; (2) \nif T; .; S; G F e : t, then T;.;S; G fe : t;(3) if T; .; S; G fe : t,then .tm such that T; .; S; G F \ne : tm and T;. ftm =t. Lemma 4 (Bounded Joins and Meets). Two types have a join (least upper bound) if \nthey have a common upper bound. Similarly, two types have a meet (greatest lower bound) if they have \na common lower bound. Both joins and meetsare in termsof subtyping.  5. SOURCE LANGUAGE AND TRANSLATION \nTO LILC t := int |C |array(C) e := n |f |x |x: t = e1 in e2 |x:= e1 in e2 |new C{f1 = e1,...,fn = en}|e.fi \n|e1.fi := e2 in e3 |e.m(e1,...,en) |new[e0,...,en-1]t |e1[e2]:= e3 in e4 |e1[e2] |cast[C](e) |cast[C[ \n]](e) v := n |f hv := C{f1 = v1,...,fn = vn}|[v0,...,vn-1]t mdecl := tm(x1 : t1,...,xn : tn)= e cdecl \n:= Cextends B{f1 : t1,...,fn : tn, mdecl1,...,mdeclk} prog := cdecl1,...,cdecln in e Figure 15: Syntax \nof the Source Language The source language is roughly Featherweight Java (FJ) [21] enhanced with assignments \nand one dimensional arrays of objects. Figure 15 shows the syntax. All local variables and record .elds \nare mutable. Variables are renamed such that no two variables have the same name. A new expres\u00adsion is \nused to create objects instead of constructors as in FJ. Expression cast[C[ ]](e) represents casting \nexpression e to an array of C. The semantics of the source language is standard and is shown in the technical \nreport. The source-target translation performs several tasks, be\u00adsides lowering types and expressions: \n(1) It collects mem\u00adbers for each class, including those from super classes. (2) It lifts method de.nitions \nto global functions, after adding the this parameter. Therefore after translation, class dec\u00adlarations \nhave only method signatures, not method bodies. (3) It creates vtables for classes. The translation can \nbe optimized, for example, to elim\u00adinate pairs of pack and open. We do not focus on those optimizations \nat present. Original Program New Program Side Conditions (H; V; x) (H; V; V(x)) (H; V;c2r(C(v))) (H; \nV; v) ' ' (H; V;new[t]{l1 = v1,...,ln = vn}) (H; V; f.li) ' (H ; V; f) (H; V; vi) ' H = H,f. {li = vi}n \ni=1 f/.domain(H) H(f)= {li = vi}n i=1 1 =i=n .f ' = f,H ' (f ' )= H(f ' ) (H; V; f.li := vi in e) (H; \nV;new[v0,...,vn-1]t ) (H; V; f[i]) (H ; V; e)(H ' ; V; f) (H; V; vi) H(f)= {l1 = v1,...,ln = vn}H ' (f)= \n{l1 = v1,...,li = v ' i,...,ln = vn}H ' = H,f. [v0,...,vn-1]t f/.domain(H) H(f)=[v0,...,vn-1]t and 0 \n=i=n-1 '' ' ' (H; V; f[i]:= v ' i in e) (H ' ; V; e) 0 =i< n .f = f,H (f )= H(f) H(f)= [v0,...,vn-1]t \nH ' (f)=[v0,...,v ' i,...,vn-1]t (H; V; x: t = v in e) (H; V ' ; e) V ' = V,x= v (H; V; x:= v ' in e) \n(H; V ' ; e) V = V1,x = v,V2 V ' = V1,x = v ' ,V2 (H; V; f[t1,...,tm](v1,...,vn)) (H; V ' ; em[Tt/tvs]) \nH(f)=.x g(tvsH(xi : ti)n i=1 : t = em V ' = V,x1 = v1,...,xn = vn,g = f (H; V;(a,x)=open(v)in e0) (H; \nV ' ; e0[t/a]) v =pack t as \u00df \u00abtu in (v ' : t ' ) V ' = V,x= v ' (H; V;ifParent(v) thenbind(a,x)in e1 \nelse e2) (H; V ' ; e1[B/a]) v = tag(C) C extends BV ' = V,x= tag(B) (H; V;ifParent(v) thenbind(a,x)in \ne1 else e2) (H; V;ifEqTagt (v1,v2)then e1 else e2) (H; V;ifEqTagt (v1,v2)then e1 else e2) (H; V; e2) \n(H; V; e1) (H; V; e2) v = tag(C) C does not extend any class. v1 = tag(C1),v2 = tag(C2),C1 = C2 v1 = \ntag(C1),v2 = tag(C2),C1 = C2 (H; V; error[t]) (H; V; error[t]) Figure 14: Evaluation Rules  Type Translation \nClass names are translated to existen\u00adtial types. Covariant array types are translated to existential \ntypes that hide the actual element types. |int| =int |C| = .a\u00abC. a |array(C)| = .a\u00abC.{ tag : Tag(a), \ntable: array(.\u00df \u00aba. \u00df)} |(t1,...,tn) .t|=(|t1|,...,|tn|) .|t| Class and Program Translation A method \ndeclara\u00adtion is translated to a pair of a function label and a global function de.nition with an explicit \nthis . Suppose class C implements a method m. The translation generates a new label lm and translates \nthe method as follows: |tm(x1 : t1,...,xn : tn)= e,C|= (lm,.x m(H(this: .a \u00abC. a, x1 : |t1|,...,xn : \n|tn|): |t|= |e|) A class declaration is translated to a triple: a class dec\u00adlaration in LILC , function \nde.nitions that correspond to method declarations and the vtable (see Figure 16). For convenience, we \nuse vtableC to represent the label for C s vtable. If S is a sequence of bindings, then S .b means S,b \nif S does not have the item bound in b.Otherwise, S .b means replacing with b the corresponding entry \nin S. mtype(T,m,C) means the type of method m in class C. A program is translated to a set of new class \ndeclarations, an initial heap that contains function de.nitions and vtables, and a new main expression. \nT= cdecl1,...,cdecln |cdecli|=(newci,newmsi,vti) .1 =i=n H0 = newms1,...,newmsn,vt1,...,vtn |Tin e|=(newc1,...,newcn; \nH0; ; |e|) Expression Translation Figure 17 shows the transla\u00adtion of expressions. Each new variable \nintroduced during translation is unique. The translation of the new expression new C{fi = ei}n creates \na record of vtableC (vtable i=1 of C) and .elds f1,...,fn andthencoerces the recordto an object. The \ntranslation of array store instructions in\u00adserts store checks: the object to be stored is .rst cast to \nthe target element type. The translation of array cast uses Arraycast , which is similar to Downcast \nand is de.ned in the technical report. Theorem 5. The translation from the source language to LILC preserves \ntypes. If fP : t holds in the source lan\u00adguage, then S0 f|P|: |t|holds in LILC ,where S0 is the environment \nfor the initial heap (H0 in the program trans\u00adlation rule).  6. EXTENSIONS 6.1 Interfaces The subclassing \nrelation can extend to interfaces. If a class C implements an interface I,then C \u00abI.An object of I has \ntype .a \u00abI. a. A standard implementation uses an itable to store a tag and function pointers for each \ninterface a class implements, and compares the tag of each itable entry with the tag of the target interface \nat interface method invocation time2 . LILC can express the searching process with some ex\u00adtensions. \nThe itable of class C canhave anarraytype array(.. \u00bbC.{ tag :Tag(.),methods: RI (.,C)} ), because each \nentry in the itable represents a super interface of C. Each entry is a record of two .elds: a tag and \na method table. RI is an abstract type constructor for representing method tables. RI (I,C)is equivalentto \na record typethat 2Some strategies create new objects with specialized itables when objects are cast \nto interfaces. We do not think those approaches are practical, because they have di.culties with mutable \n.elds and with casting the new objects to other types. |Topc| =(Topc{}, (),vtableTopc . {tag = tag(Topc)}) \n|B| =(B : D{fieldsB ,mtypesB},mdefsB,vtableB . {tag = tag(B),fpsB}) mdecli de.nes mi |mdecli,C| =(li,mbodyi) \n.1 = i = k |Cextends B{f1 : t1,...,fn : tn,mdecl1,...,mdeclk}| = .. C : B{fieldsB ,f1 : |t1|,...,fn \n: |tn|,mtypesB . m1 : |mtype(T,m1,C)|. ... . mk : |mtype(T,mk,C)|}, .. (l1 . mbody1,...,lk . mbodyk), \nvtableC . {tag = tag(C),fpsB . m1 = l1 . ... . mk = lk} |n| |x| |x : t = e1 in e2| |x := e1 in e2| |new \nC{fi = ei}n | i=1|e.fi||e1.fi := e2 in e3||e.m(e1,...,en)||new[e0,...,en-1]C | |e1[e2]| |e1[e2]:= e3 \nin e4| |cast[C](e)| |cast[C[ ]](e)|  Figure 16: Class Declaration Translation = n = x = x : |t| = |e1| \nin |e2| = x := |e1| in |e2| =pack C as a \u00ab C in (C(new[R(C)]{vtable = vtableC , (fi = |ei|)n }): a) \ni=1 =(a, x)= open(|e|)in c2r(x).fi =(a, x)= open(|e1|)in c2r(x).fi := |e2| in |e3| =(a, x)= open(|e|)in \nc2r(x).vtable.m(pack a as \u00df \u00ab a in (x : \u00df), |e1|,... |en|) =pack C as a \u00ab C in ({tag = tag(C), table \n=new[|e0|,..., |en-1|]|C|} : { tag : Tag(a), table : array(.\u00df \u00ab a. \u00df)} ) =(a, x)= open(|e1|)in x.table[|e2|] \n=(a, x)= open(|e1|)in (\u00df, y)= open(|e3|)in x.table[|e2|]:= Downcast[a, \u00df](x.tag, y)in |e4|=(a, x)= open(|e|)in \nDowncast[C, a](tag(C),x) =(a, x)= open(|e|)in Arraycast[C, a](tag(C),x) Figure 17: Translation of Expressions \nspeci.es all methods in I.If the tag of interface . is equal to the tag of target interface I,then RI \n(., C) can be re.ned to RI (I,C) and methods can be fetched from it.  6.2 Binary Methods A binary method \ntakes a parameter that has the same exact type as the this pointer. A typical example is the equality \noperation. For example, eq in class Point compares two objects of exact class Point. The subclasses must \noverride the eq method in the same spirit. The eq method in Point2D compares two objects of exact Point2D. \nWith notions of exact types, LILC can express binary methods easily. It can use a special annotation \non param\u00adeters to indicate that those parameters have the same type as this . The two parameters of a \nbinary method in class C, this and the annotated parameter, will be given type C,not .a \u00ab C. a,because \nC s subclasses have to override the binary method. For example, the eq method in Point will have type \nPoint . Point . bool, and the eq method in Point2D will have type Point2D . Point2D . bool.  7. RELATED \nWORK The type-theoretic foundations for object-oriented lan\u00adguages have been studied extensively [6, \n30, 4, 31, 2, 1, 15, 20, 13]. Most existing work focused on encoding classes and objects to some form \nof the typed lambda-calculus with records and functions. Many encodings use non-standard implementation \ntechniques for object-oriented features. Some encodings introduce extra runtime overhead [2, 30, 4, 15]. \nTwo complexities involved in class and object encodings are recursion and inheritance. The recursive \nreference to class C in the de.nition of C itself is often expressed by re\u00adcursive types. Bounded quanti.cation \n(based on subtyping) is introduced to express inheritance [7], but the full-scale version has undecidable \ntype checking [29, 18]3.The inter\u00adaction with constructs such as recursive types, intersection types \nand binary methods further complicates the type sys\u00adtem [17, 28, 5, 3]. The object calculi proposed by \nAbadi and Cardelli can be used to express class-based languages [1]. Object calculi use operations on \nobjects as primitives, instead of those on records. They are not suitable for addressing low-level de\u00adtails \nused by the compiler, such as object layout and vtables. Some recent work aimed at e.cient encodings: \nGlew s Fself [20], Crary s OREI [13] and League et al. s JFlint [24]. All three calculi and LILC express \nabstract views of objects with type variables and express concrete views with record types, but they \nuse di.erent mechanisms. To aid compari\u00adson, we use the LILC notation ApproxR in the explana\u00adtion. LILC \nuses coercion c2r to coerce an object of type a toarecord type ApproxR(a, C), if a \u00ab C. Fself combined \nF-bounds with equi-recursive types in a self construc\u00adtor. An object of class C has type selfa.ApproxR(C, \na). When unfolded, the object has type a,and a is a subtype of ApproxR(a, C). OREI used intersection \ntypes .a.a n ApproxR(a, C) to express both views of objects of C.Either view can be projected by coercions. \nJFlint used existentially quanti.ed row variables .tail.\u00b5self.ApproxR(self, C)+tail4 to type objects \nof C. The row variable tail abstracts possible extensions in subclasses. Among the four e.cient calculi, \nonly LILC can specify (subclassing) bounds on type variables. As a result, LILC can easily express covariant \nsource array types with invari\u00adant array types, and with minor extensions it can model 3A restricted \nvariant (Kernel F<:) has decidable type check\u00ading, but it is not very expressive. 4 + is not a notation \nin League s encoding. We use it to express concatenation. displays of super classes (for casting) and \nitables. Also, LILC supports type cast implemented by walking through tag chains. JFlint used sum types \nand a one-armed case to represent cast. Each class must override a projection function that can cast \nan object to the class, which is non\u00adstandard. In another paper, Glew proposed a mechanism to model hierarchical \ndispatch [19]. He introduced subtyp\u00ading between tag types, which we think does not agree with the convention \nthat a tag uniquely identi.es a class. Be\u00adcause of this subtyping, he had to use variance annotations \non tag types because tag creation and tag comparisons need di.erent subtyping behaviors. Canning et al. \nseparated inheritance and subtyping back in 1990 [12]. Their work gave a denotational semantics to inheritance. \nObjects were modeled as .xed points of re\u00adcursive records, and classes were .xed points of F-bounded \nrecursive functions, which made the encoding not as simple or as natural as LILC . Bruce used matching \nand match-bounded polymorphism to express inheritance [4]. The denotational semantics, which can be seen \nas an encoding, was based on F-bounded quan\u00adti.cation with .xed points at both the term level and the \ntype level. Matching is purely structural. No nominal sub\u00adclassing relation is preserved. Xi et al. presented \nan object encoding as an application of guarded recursive datatype constructors [36]. Classes are tags \non messages. Subclassing does not imply subtyping. Objects are interpreted as functions that can dispatch \nmes\u00adsages, which di.ers from the standard implementation of objects as records. As a result, fetching \n.elds and invoking methods inherited from super classes have extra overhead. Wright et al. compiled a \nsubset of Java to a typed inter\u00admediate language [35]. They relied on runtime type checks to perform \ndynamic dispatch and type cast, and used un\u00adordered records to represent interfaces. Fisher et al. proposed \nan untyped calculus for compiling class-based object-oriented languages [16]. They aimed to support inheritance \nfrom unknown base classes. Therefore, they used dictionary lookups for .eld and method access. Necula \net al. developed a certifying compiler called Spe\u00adcialJ for Java [11] as part of the Proof-Carrying Code \nframe\u00adwork [27]. The compiler translates Java bytecode to x86 as\u00adsembly code with type annotation, and \na safety proof that certi.es the code. The compiler handles a large subset of Java, including exceptions. \nThe type system in SpecialJ uses only high-level abstractions such as classes and objects. Sub\u00adclassing \nimplies subtyping. SpecialJ does not have exact type notions. As a result, its type system is unsound \nthe unsafe dispatch shown in Section 2.3 would be well-typed in SpecialJ [23]. 8. CONCLUSION This paper \npresents a simple typed intermediate language LILC for type-preserving compilation of object-oriented \nlan\u00adguages. By preserving lightweight class names and restrict\u00ading bounded quanti.cation to subclassing, \nLILC reduces the encoding complexity signi.cantly, and it is able to faithfully model standard implementation \ntechniques for self applica\u00adtion, dynamic dispatch and type cast. It is sound and has decidable type \nchecking. We believe LILC is more suitable as a starting point for practical compilers than traditional \nencodings. 9. REFERENCES [1] Martin Abadi and Luca Cardelli. A Theory of Objects. Springer, New York, \n1996. [2] Mart\u00b4in Abadi, Luca Cardelli, and Ramesh Viswanathan. An interpretation of objects and object \ntypes. In ACM Symposium on Principles of Programming Languages, pages 396 409, St. Petersburg Beach, \nFlorida, 1996. [3] Paolo Baldan, Giorgio Ghelli, and Alessandra Ra.aeta. Basic theory of f-bounded quanti.cation. \nInformation and Computation, 153(1):173 237, 1999. [4] Kim B. Bruce. A paradigmatic object-oriented programming \nlanguage: Design, static typing and semantics. Journal of Functional Programming, 4(2):127 206, 1994. \n [5] Peter Canning, William Cook, Walt Hill, Walter Oltho., and John C. Mitchell. F-bounded quanti.cation \nfor object-oriented programming. In Fourth International Conference on Functional Programming Languages \nand Computer Architecture, pages 273 280, 1989. [6] Luca Cardelli. A semantics of multiple inheritance. \nInformation and Computation, 76(2/3):138 164, February/March 1988. [7] Luca Cardelli and Peter Wegner. \nOn understanding types, data abstraction, and polymorphism. ACM Computing Surveys, 17(4):471 522, 1985. \n [8] Giuseppe Castagna and Benjamin C. Pierce. Corrigendum: Decidable bounded quanti.cation. http://www.cis.upenn.edu/~bcpierce/papers/fsubnew\u00adcorrigendum.ps. \n[9] Giuseppe Castagna and Benjamin C. Pierce. Decidable bounded quanti.cation. In 21st ACM Symposium \non Principles of Programming Languages, pages 151 162. ACM Press, 1994. [10] Juan Chen and David Tarditi. \nA simple typed intermediate language for object-oriented languages. Technical Report MSR-TR-2004-68, \nMicrosoft Corporation. ftp://ftp.research.microsoft.com/pub/tr/TR-2004\u00ad68.pdf. [11] Christopher Colby, \nPeter Lee, George C. Necula, Fred Blau, Ken Cline, and Mark Plesko. A certifying compiler for Java. In \nACM SIGPLAN Conference on Programming Language Design and Implementation. ACM Press, June 2000. [12] \nWilliam R. Cook, Walter Hill, and Peter S. Canning. Inheritance is not subtyping. In 17th ACM Symposium \non Principles of Programming Languages, pages 125 135. ACM Press, 1990. [13] Karl Crary. Simple, e.cient \nobject encoding using intersection types. Technical report. CMU Technical Report CMU-CS-99-100. [14] \nMicrosoft Corp. et al. Common Language Infrastructure. 2002. http://msdn.microsoft.com/net/ecma/. [15] \nKathleen Fisher. Type Systems for Object-oriented Programming Languages. PhD thesis, Stanford University, \n1996. [16] Kathleen Fisher, John H. Reppy, and Jon G. Riecke. A calculus for compiling and linking classes. \nIn Proceedings of the 9th European Symposium on Programming Languages and Systems, pages 135 149. Springer-Verlag, \n2000. [17] Giorgio Ghelli. Recursive types are not conservative over F=.In Proceedings of the International \nConference on Typed Lambda Calculi and Applications, pages 146 162. Springer-Verlag, 1993. [18] Giorgio \nGhelli. Divergence of F< type checking. Theoretical Computer Science, 139(1 2):131 162, 1995. [19] Neal \nGlew. Type dispatch for named hierarchical types. In ACM SIGPLAN International Conf. on Functional Programming, \npages 172 182, 1999. [20] Neal Glew. An e.cient class and object encoding. In ACM SIGPLAN Conference \non Object-Oriented Programming, Systems, Languages, and Applications, pages 311 324, 2000. [21] Atsushi \nIgarashi, Benjamin C. Pierce, and Philip Wadler. Featherweight Java: a minimal core calculus for Java \nand GJ. ACM Trans. on Programming Languages and Systems, 23(3):396 450, 2001. [22] S. Kamin. Inheritance \nin Smalltalk-80: a denotational de.nition. In 15th ACM Symposium on Principles of Programming Languages, \npages 80 87. ACM Press, 1988. [23] Christopher League. A Type-preserving Compiler Infrastructure. PhD \nthesis, Yale University, 2002. [24] Christopher League, Zhong Shao, and Valery Trifonov. Type-preserving \ncompilation of Featherweight Java. ACM Trans. on Programming Languages and Systems, 24(2), March 2002. \n[25] Tim Lindholm and Frank Yellin. The Java Virtual Machine Speci.cation. Addison-Wesley, 1999. [26] \nGreg Morrisett, David Walker, Karl Crary, and Neal Glew. From System F to typed assembly language. ACM \nTrans. on Programming Languages and Systems, 21(3):527 568, May 1999. [27] George Necula. Proof-Carrying \nCode. In ACM Symposium on Principles of Programming Languages, pages 106 119. ACM Press, 1997. [28] Benjamin \nC. Pierce. Intersection types and bounded polymorphism. In Typed Lambda Calculi and Applications, volume \n664, pages 346 360. Springer-Verlag, 1993. [29] Benjamin C. Pierce. Bounded quanti.cation is undecidable. \nIn Theoretical Aspects of Object-Oriented Programming: Types, Semantics, and Language Design, pages 427 \n459. The MIT Press, MA, 1994. [30] Benjamin C. Pierce and David N. Turner. Simple type-theoretic foundations \nfor object-oriented programming. Journal of Functional Programming, 4(2):207 247, 1994. [31] Didier R\u00b4emy. \nProgramming objects with ml-art, an extension to ml with abstract and record types. In International \nConference on Theoretical Aspects of Computer Software, pages 321 346. Springer-Verlag, 1994. [32] Zhong \nShao. An overview of the FLINT/ML compiler. In ACM SIGPLAN Workshop on Types in Compilation, June 1997. \n[33] D. Tarditi, G. Morrisett, P. Cheng, C. Stone, R. Harper, and P. Lee. TIL: A type-directed optimizing \ncompiler for ML. In ACM SIGPLAN Conference on Programming Language Design and Implementation, pages 181 \n192, 1996. [34] Andrew K. Wright and Matthias Felleisen. A syntactic approach to type soundness. Information \nand Computation, 115(1):38 94, 1994. [35] Andrew K. Wright, Suresh Jagannathan, Cristian Ungureanu, and \nAaron Hertzmann. Compiling Java to a typed lambda-calculus: A preliminary report. In Types in Compilation, \npages 9 27, 1998. [36] Hongwei Xi, Chiyan Chen, and Gang Chen. Guarded recursive datatype constructors. \nIn ACM SIGPLAN Symposium on Principles of Programming Languages, pages 224 235, New Orleans, January \n2003.  \n\t\t\t", "proc_id": "1040305", "abstract": "Traditional class and object encodings are difficult to use in practical type-preserving compilers because of the complexity of the encodings. We propose a simple typed intermediate language for compiling object-oriented languages and prove its soundness. The key ideas are to preserve lightweight notions of classes and objects instead of compiling them away and to separate name-based subclassing from structure-based subtyping. The language can express standard implementation techniques for both dynamic dispatch and runtime type tests. It has decidable type checking even with subtyping between quantified types with different bounds. Because of its simplicity, the language is a more suitable starting point for a practical type-preserving compiler than traditional encoding techniques.", "authors": [{"name": "Juan Chen", "author_profile_id": "81100119052", "affiliation": "Microsoft Research, Redmond, WA", "person_id": "PP39028301", "email_address": "", "orcid_id": ""}, {"name": "David Tarditi", "author_profile_id": "81100531922", "affiliation": "Microsoft Research, Redmond, WA", "person_id": "PP14184693", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1040305.1040309", "year": "2005", "article_id": "1040309", "conference": "POPL", "title": "A simple typed intermediate language for object-oriented languages", "url": "http://dl.acm.org/citation.cfm?id=1040309"}