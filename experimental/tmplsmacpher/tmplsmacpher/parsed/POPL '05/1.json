{"article_publication_date": "01-12-2005", "fulltext": "\n Environmental Acquisition Revisited Richard Cobbe Matthias Felleisen College of Computer and Information \nScience Northeastern University 360 Huntington Ave Boston, MA 02115 cobbe@ccs.neu.edu ABSTRACT In 1996, \nGil and Lorenz proposed programming language constructs for specifying environmental acquisition in ad\u00addition \nto inheritance acquisition for objects. They noticed that in many programs, objects are arranged in containment \nhierarchies and need to obtain information from their con\u00adtainer objects. Therefore, if languages allowed \nprogrammers to specify such relationships directly, type systems and run\u00adtime environments could enforce \nthe invariants that make these programming patterns work. In this paper, we present a formal version \nof environmen\u00adtal acquisition for class-based languages. Speci.cally, we introduce an extension of the \nClassicJava model with con\u00adstructs for environmental acquisition of .elds and methods, a type system \nfor the model, a reduction semantics, and a type soundness proof. We also discuss how to scale the model \nto a full-scale Java-like programming language. Categories and Subject Descriptors D.3.3 [Programming \nLanguages]: Language Constructs and Features classes and objects; D.1.5 [Programming Techniques]: Object-oriented \nProgramming; D.2.3 [Soft\u00adware Engineering]: Coding Tools and Techniques object\u00adoriented programming General \nTerms Languages, Design Keywords environmental acquisition, object-oriented languages, object containment, \nobject composition 1. INTRODUCTION Programs often manipulate hierarchical containers or tree\u00adshaped forms \nof data. For example, a PLT Scheme [5] pro- Permission to make digital or hard copies of all or part \nof this work for personal or classroom use is granted without fee provided that copies are not made or \ndistributed for pro.t or commercial advantage and that copies bear this notice and the full citation \non the .rst page. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires \nprior speci.c permission and/or a fee. POPL 05, January 12 14, 2005, Long Beach, California, USA. Copyright \n2005 ACM 1-58113-830-X/05/0001 ...$5.00. gram that uses the MrEd library [6] for implementing a graphical \nuser interface nests panels inside of a window to ar\u00adrange the basic GUI widgets. Or, a Java program \nthat uses the XML library creates a tree representation from some text that it reads. Indeed, the idea \nof using hierarchical data representations of this kind is so standard that the collection of object\u00adoriented \n(program) design patterns [10] contains special pat\u00adterns, like the composite and interpreter patterns, \nfor de\u00adsigning an appropriate set of classes. As many people have observed [12, 15], however, patterns \nalmost naturally sug\u00adgest new constructs for programming languages. Speci.\u00adcally, if a language codi.es \na pattern with a new construct, the compiler and the run-time system can enforce the pat\u00adtern s programming \ninvariants or, alternatively, can signal violations as soon as they recognize them. Consider the case \nof hierarchical data. Typically, the de\u00adsign of hierarchical data implies that each item has a unique \ncontainer, if it has one at all. Using the equivalent terminol\u00adogy of nested containers, an item is inside \nof (at most) one container, which in turn may be inside of another container and so on. Based on this \nproperty, programs tend to com\u00adpute properties of an item that are a function of the item s uniquely \ndetermined environment. That is, items acquire properties from their environments and compute with them. \nOf course, this only works if the program establishes, main\u00adtains, and uses the hierarchy properly at \nall times, includ\u00ading so-called friend pointers from an item to its container (also known as two-way \nlinks in the UML community [8, p. 155]). Gil and Lorenz [11] recognized this problem of environ\u00admental \nacquisition and proposed constructs for specifying such relationships directly within programs.1 Their \nproposal was informal; it neither speci.ed a formal type system for environmental acquisition nor stated \na soundness theorem for a speci.c model. Since then, environmental acquisition has found its way into \nPython [22, 9] as a part of the Zope project [16]. Also, the second author has used environmen\u00adtal acquisition \nfor a systems administration project where computers, switches, and ethernet cards acquire policies and \nother network information from their containers [17]. In this paper, we resume and continue this language \ndesign experiment. Speci.cally, we present a typed version of envi\u00ad 1As Gil and Lorenz point out, an \nobject s environment may in\u00adcorporate many di.erent kinds of related objects. We restrict ourselves, \nas they do, to the environment provided by an object s containers. class JComponent extends Container \n// ... { // ... public JRootPane getRootPane() { return SwingUtilities.getRootPane(this); } // ... } \nclass SwingUtilities // ... { // ... public static JRootPane getRootPane(Component c) { if (c instanceof \nRootPaneContainer) { return ((RootPaneContainer)c).getRootPane(); } for( ; c != null; c = c.getParent()) \n{ if (c instanceof JRootPane) { return (JRootPane)c; } } return null; } // ... } Code from Java s Swing \nAPI [20]. Figure 1: root panes in Swing ronmental acquisition for a class-based object-oriented pro\u00adgramming \nlanguage. Our goal is to show language designers how environmental acquisition helps programmers; what \nit takes to type constructs for environmental acquisition; and when the run-time system needs to check \nthe invariants for acquisition relationships. A formal model, based on Clas\u00adsicJava [7], provides the \nframework in which we discuss the design decisions and in which we can prove a type soundness theorem. \nFinally, we use the model to formulate a challenge for the designers of type systems concerning the elimination \nof run-time checks. The paper consists of seven sections. The next section introduces environmental acquisition \nwith concrete exam\u00adples. Then the third section brie.y recalls those elements of ClassicJava that matter \nfor this paper. The fourth sec\u00adtion is dedicated to Jacques, an extension of ClassicJava with constructs \nfor specifying the environmental acquisition of .elds and methods, its type system, and its formal seman\u00adtics. \nIn the .fth section we discuss several decisions concern\u00ading the design of Jacques. The sixth section \nsketches how to scale our model to a full object-oriented language. The sev\u00adenth section sketches related \ne.orts, their limitations, and how we might incorporate their methods into future versions of Jacques. \nThe .nal section suggests some future work, especially on an improved type system for keeping track of \nacquisitions.  2. MOTIVATING EXAMPLES As environmental acquisition relies on an object contain\u00adment \nhierarchy, it has a strong connection with design pat\u00adterns where such hierarchies play central roles, \nparticularly the composite pattern and its close relative, the interpreter pattern. The focus of these \npatterns is often propagating information towards the root of an object tree. Acquisition Figure 2: \nacquisition example: investment accounts becomes relevant if the application must propagate informa\u00adtion \naway from the root. For example, consider GUI development toolkits, which are typically implemented with \nthe composite pattern. In Java s Swing toolkit [21], for instance, all graphical com\u00adponents are subclasses \nof JComponent; several components like JPanel may contain other components. Every operating\u00adsystem-level \nwindow in a Swing program has a single root pane; this pane contains the window s menu bar and other \ncapabilities. Therefore, components that need to access the menu bar must have access to their containing \nroot pane. Currently, the JComponent.getRootPane method retrieves the root pane by chasing explicit pointers \nup the panel con\u00adtainment hierarchy, as shown in .gure 1. As GUI compo\u00adnents are added, destroyed, and \nmoved, the library main\u00adtains these pointers. With environmental acquisition, each individual component \ncould simply acquire a reference to the root pane from its container, avoiding the need to write error-prone \npointer-management code directly and instead leaving that responsibility to the run-time system. Following \nGamma et al, we take our next example of ac\u00adquisition in the composite pattern from the .nancial sector. \nSee .gure 2 for the class diagram. The Account class repre\u00adsents an individual s account with a mutual \nfund .rm; each account contains several Fund instances. It is frequently the case that an investor may \nhave several types of funds within the same account; some funds may be standard investments, while others \nmay be part of an IRA. To keep these funds separate for tax purposes, it is convenient to group multi\u00adple \nfunds into a FundGroup instance. Now, transactions on a particular fund must take the fund s tax policy \ninto account. With environmental acquisition, we simply declare the pol\u00adicy for the account as a whole, \nallow fund groups to override that policy for their funds, and have each fund acquire the policy from \nits nearest container. For a .nal example, extracted from DrScheme [4], consider a class-writing wizard \nfor use in a program development en\u00advironment; see .gure 3 for a UML diagram of the relevant classes. \nThis wizard allows the user to de.ne a new class or set of classes by specifying their properties graphically; \nthe produce method in the ClassUnionWizard class generates the corresponding declarations in the target \nprogramming lan\u00adguage. The system allows the user to de.ne classes in several di.erent manners. For example, \nthe ClassInfo wizard con\u00adstructs a single class, and the UnionInfo wizard constructs a sum-of-products \ntype, as seen in the interpreter pattern.  VariantPanel add( ) produce( ) acquire errorMessage( )  \nFigure 3: acquisition example: class wizard Control interface Work area Error window Figure 4: class \nwizard dialog Each dialog contains three main visual components: a control interface at the top, an error \nwindow at the bottom, and a large work area in the center that is specialized to the speci.c wizard; \nsee .gure 4. For example, the UnionInfo wizard contains a work area with one panel for each variant of \nthe data type being developed. Since these variant panels are complicated in their own right, we have \nnot included this code in UnionInfo but removed it to the VariantPanel class, instances of which are \ncontained in the main dialog box. A wizard typically cannot detect all of the errors in a de\u00adsign until \nit attempts to emit code via the produce method. In the UnionInfo class, this method simply invokes the \nsame method on each of its VariantPanels. If one of those de\u00adtects an error, it must report it by communicating \nthe error message up to the main dialog box for display in its error panel. Since, however, VariantPanel \ninherits from Horizon\u00adtalPanel and not from ClassUnionWizard, it must use some other mechanism to access \nthe errorMessage method. In other words, it must acquire this method from its containers. This acquisition \nlink also makes it easier to extend Union\u00adInfo s behavior later. In particular, if we wanted to subclass \nthis to direct all error reports to a log .le on disk, in addition to sending them to the window, we \ncould simply place the VariantPanel objects into the extended UnionInfo; the pan-els would acquire the \nextended errorMessage method, and we would achieve the desired behavior with no changes to VariantPanel. \nP defn * e defn class c extends c { .eld * meth *} .eld tfd meth tmd( arg *) { e} arg tvar e new \nc var null e : c .fd e : c .fd = e e.md( e *) super = this : c.md( e *) cast te let var = e in \ne var a variable name or this c aclass name or Object fd a.eld name md amethodname t c (a type name) \nFigure 5: ClassicJava syntax Without acquisition, we could achieve the same behavior through either \nof two strategies. First (and currently), we couldwrapthe errorMessage method in a Scheme closure and \npass this as an argument to the VariantPanel constructor; this panel object could then simply invoke \nthe closure to report an error. Second, we could manage the container pointer manually, and the VariantPanel \nobject could chase pointers to .nd the errorMessage method.  3. CLASSIC JAVA ClassicJava [7] is a formal \nmodel of the sequential core of Java [13] that includes inheritance, method overriding, and .eld mutation; \nthe model could easily apply to simi\u00adlar OO languages, like C# [3] or Ei.el [19]. We summarize ClassicJava \nin this section and refer the reader to the orig\u00adinal paper for the full details. Figure 5 speci.es the \nsyntax for ClassicJava programs. The underlined portions of the syntax are added by the type checking \nand elaboration phase in order to make certain context-sensitive details available to the operational \nseman\u00adtics. For instance, evaluating a super expression requires knowledge of the location of the expression \nin the original program in order to perform method lookup correctly. Sim\u00adilarly, .eld accesses must know \nthe static type of the object whose .eld is being accessed in order to resolve shadowed .elds correctly. \nThe underlined annotations provide all nec\u00adessary information for these cases. Figure 6 describes the \nsix type judgments necessary to de.ne ClassicJava s static semantics; we refer the reader to the original \npaper for the de.nition of these judgments. The ClassicJava semantics also requires several additional \nrelations; those that are relevant to our work are de.ned in .gure 7. The dynamic semantics (a small-step \noperational semantics with evaluation contexts) requires access to the program s class de.nitions P and \nan explicit store S.Fi\u00adnally, we represent an instance as an ordered pair < c,F ) , where c is the object \ns class tag and F is a .nite map from tagged .eld names (i.e., c.fd)to values. ClassicJava satis.es a \ntype soundness theorem: Theorem 1 (Type Soundness for ClassicJava) I P' If fp P : t and P'= defn1 ... \ndefnn e, then either P'-* ' f < e,O) '< obj ,S) and S( obj )=< t,F ) and t'. P t;or  P'f < e,O) '-* \n< null,S) ;or  P'f < e,O) '-* < error: bad cast,S) ;or  P'f < e,O) '-* < error: dereferenced null,S) \n;or  P'f < e,O)1 .  4. JACQUES Jacques is an extension to ClassicJava. It supports en\u00advironmental acquisition \nof both .elds and methods. In this section, we .rst describe Jacques s syntax, type system, and operational \nsemantics; then we state and sketch a proof of type soundness for Jacques. In the following section, \nwe discuss our design choices and how the formal model helped making them. To describe object containment \nin Jacques programs, we use two directed graphs: the class containment graph and the object containment \ngraph. The class containment graph for a program P contains one node for each class de.ned in P; there \nis an edge from class c1 to class c2 if and only if c1 s declaration indicates that it may be contained \nin c2 (section 4.1). The class containment graph is orthogonal to the class inheritance tree, and it \nis a static property of program P. In contrast, the object containment graph describes the state of the \nprogram at a particular point in its execution. This graph (section 4.4) contains one node for each object \ninstance in the program s store, and an edge from object x to object y exactly when x is contained in \ny. Finally, while Jacques supports most of ClassicJava s capabilities, we disallow .eld shadowing, to \nsimplify the de\u00adscription of .eld acquisition. In section 6, we discuss the issue of adding .eld shadowing \nand other features of Java to Jacques. 4.1 Syntax To support acquisition along containment links between \nobjects, we must have some way to distinguish between * defn class c extends c contained c { .eld * contains \n.eld * acquires .eld * meth * acquires acqmeth * } acqmeth tmd( t *) Figure 8: Jacques syntax extensions \nthose links that represent containment in the sense of a con\u00adtainment hierarchy and those that do not. \nTherefore, in Jacques, the programmer must explicitly tag those .elds that represent a containment relationship. \nJacques also requires explicit acquisition, i.e., classes must explicitly de\u00adclare the .elds they acquire \nfrom their environment. Fig\u00adure 8 extends ClassicJava s class de.nition syntax with these annotations. \nThe contains and acquires keywords divide the .eld de.\u00adnitions into three groups. Consider the class \nde.nition class A { Xx contains Y y acquires Z z and let a be an instance of A. Fields in the .rst \ntwo groups (here, x and y) are parts of a, and .elds in the last group (z)are not directlyin a but are \nrather acquired from a s context. Further, only objects in .elds in the second group (here, y) are considered \nto be contained in a, and therefore only they may acquire .elds from a. Similarly, the acquires keyword \nsplits the method de.ni\u00adtions into two groups. Methods in the .rst group behave as in ClassicJava. Methods \nin the second group, on the other hand, are acquired from the object s context; there\u00adfore, their de.nitions \nneed not include anything beyond their signatures. Finally, the (possibly empty) sequence of classes \nspeci.ed after the contained keyword places restrictions on the types of objects that may contain objects \nof the class being de\u00ad.ned. In particular, if an instance a of class c is contained in anything, the \ncontainer s type must be a subtype of one of theclasses speci.edin c s container list. As a consequence, \nif this list is empty, then a may not be contained (in the spirit of environmental acquisition) in any \nobject.  4.2 Types Both the static and dynamic semantics must be able to distinguish between the three \nkinds of .elds and the two kinds of methods. Therefore, we adjust ClassicJava s ab\u00adstract representation \nof .elds and methods. A .eld de.ni\u00adtion is now a triple < t,fd,s) ,where t is the .eld s type, fd is \nits name, and s is a tag indicating the kind of .eld; s is one of normal, contained,or acquired. Similarly, \na method de.nition is a 5-tuple < md,T,V,e,s) , where md, T, V,and e are as before, and sis a tag indicating \nwhere the method originated; s may be either normal or acquired. (Thethird andfourthelementsofthe tupleare \nmeaningless for acquired methods, but we leave them in to simplify the de.nition of, e.g., .P .) fp \nP I P ' : t program P elaborates to P ' with type t P fd defn I defn ' class de.nition defn elaborates \nto defn ' P,t fm meth I meth ' method meth in class t elaborates to meth ' P,G fe e I e ' : te elaborates \nto e ' with type t in G P,G fs e I e ' : te elaborates to e ' and has type t using subsumption in G P \nft t type t exists Figure 6: ClassicJava type judgments .P immediate subclass c .P c ' = class c extends \nc ' { . . . } is in P . P subclass . P is de.ned to be the re.exive-transitive closure of .P . P .eld \nis declared in a class ( c.fd,t) . P c = class c . . . {. . . tfd . . . } is in P . P method is declared \nin a class ( md,( t1 ...tn \u00adt) ,( var1 ...varn) ,e) . P c = class c . . . {. . . tmd( t1 var1 ... tn \nvarn) { e} . . . } is in P .P .eld is contained in a class ( c ' .fd,t) .P c = ( c ' .fd,t) . P c ' and \nc ' min{ c\" c . P c\"and : t ' .( c\".fd,t ') . P c\"} .P method is containedina class ( md,T,V,e) .P c \n= ( md,T,V,e) . P c ' and c ' min{ c\" c . P c\"and : e ' ,V ' .( md,T,V ' ,e ') .P c\"} Figure 7: ClassicJava \nrelations Finally, we also use an adjusted instance representation: < c,ctnr,F ) where c is the class \ntag, ctnr is a (possibly null) reference to the instance s container, and F is a .nite map from .eld \nnames to values. We also de.ne three selector functions: classTag, ctnr,and .elds map an instance triple \nto its class tag, container reference, and .eld function, re\u00adspectively. Jacques s semantics requires \nmany of the relations and predicates de.ned in .gure 7, with appropriate modi.ca\u00adtions to several, including \n. P and .P . The additional nec\u00adessary predicates are straightforward; their de.nitions are provided \nbelow and in .gure 9. The predicate canAcqP ( c,< t,fd,acquired)) determines if it is safe for class \nc to acquire .eld < t,fd,s) . This acquisition is safe if the class containment graph implies that, for \nall pos\u00adsible environments for instances of c, the nearest enclosing class that provides the .eld fd \nprovides it with a compatible type. Formally, we de.ne canAcqP ( c,< t,fd,s)) to be true if and only \nif every unsafe path that starts with c in the class containment graph has a safe pre.x. An unsafe path \nis one \" that ends in a class csuch that \"\"\" < t,fd,s) .P c,and \" t P t. A safe path is one that ends \nin a class c ' such that ''' < t ,fd,s) .P c ,and s ' i acquired,and  t ' P t.  In other words, no \ntraversal of the class containment graph .nds a .eld of the desired name and an incompatible type before \nit .nds a .eld with a compatible type. Note that we allow the existence of paths that never .nd a .eld \nof the desired name, and we even allow the absence of any paths that .nd the desired .eld. Forbidding \nthese conditions would not strengthen the type system: even if all paths from aclass c reach the .eld, \nwe must still check at run-time for the possibility that an object of type c has a null container. Similarly, \nthe predicate canAcqMethP checks whether it is safe for class c to acquire a method md; it di.ers only \nin the type compatibility requirements. Formally, canAcqMethP ( c, < md,( t1 ...tn -t) ,V,e,s)) is true \nif and only if every un\u00adsafe path that starts with c in the class containment graph has a safe pre.x. \nHere, an unsafe path is one that ends in \"\"\"\"\" aclass csuch that < md,( t1 ...tm -t\") ,V\",e,s\") .P cand \none of the following is true: mi n,or \" t P t,or \" m= n and for some i E[ 1,n] , ti P ti . A safe path \nis one that ends in a class c ' where ''''''' < md,( t1 ...tn -t ) ,V ,e ,s ) .P c ,and s ' i acquired,and \n t ' P t,and  ti P ti ' for all iE[ 1,n] .  With these relations on the class graph, we can de.ne \nthe type elaboration rules for Jacques; .gure 10 speci.es the necessary changes to ClassicJava s rules. \nIn addition to the rules shown, there are straightforward variations of Clas\u00adsicJava s Get, Call,and \nSuper to account for the change in .eld and method representations. Also, because we no longer support \n.eld shadowing, we add ClassFieldsOK ( P) as an antecedent to the Progj rule, and neither the Getj ClassFieldsOK \n( P) no .eld de.nition shadows a .eld de.ned in a superclass (( t1,fd,s1) . P c1 and ( t2,fd,s2) . P \nc2 and c1 i c2)= c1 P c2 containersP ( c) set of all possible containers of instances of class c containersP \n( Object)0 containersP ( c){ c1,...,cn} where class c ... contained c1 ...cn {...} is in P acqFieldsP \n( c) set of all acquired .elds in class c acqFieldsP ( Object)0 acqFieldsP ( c) acqFieldsP ( c ' ){( \nt,fd,acquired)( t,fd,acquired) . P c} where class c extends c ' ...{...} is in P acqMethodsP ( c) set \nof all acquired methods in class c acqMethodsP ( Object)0 acqMethodsP ( c){( md,T,V,e,acquired)( md,T,V,e,acquired) \n.P c} where class c ...{...} is in P .P class may be contained c1 .P c2 = there exists c ' E containersP \n( c1) such that c2 P c ' Figure 9: Jacques relations Defnj P ft tj for all j E[ 1,m] P ft cj for all \nj E[ 1,n] P,c fm methi I methi ' for all iE[ 1,p] f E acqFieldsP ( c) .canAcqP ( c,f) m E acqMethodsP \n( c) .canAcqMethP ( c,m) containersP ( c ' )< containersP ( c) ti CP c for all i E[ k+ 1,\u00a3] P fd class \nc extends c ' contained c1,...,cn I { t1 fd1 ...tk fdk contains tk+1 fdk+1 ...t\u00a3 fd\u00a3 acquires t\u00a3+1 fd\u00a3+1 \n...tm fd m meth1 ...methp acquires acqmeth1 ...acqmethq Setj P,G fs e1 I e ' 1 : t ' si acquired P,G \nfs class c extends c ' contained c1,...,cn { t1 fd1 ...tk fdk contains tk+1 fdk+1 ...t\u00a3 fd\u00a3 acquires \nt\u00a3+1 fd\u00a3+1 ...tm fd m meth1 ' ...methp ' acquires acqmeth1 ...acqmethq < t,fd,s) .P t ' e2 I e2 : t \nP,G fe e1.fd = e2 I e1' .fd = e2 ' : t Figure 10: Jacques type elaboration rules nor the Setj rule annotates \n.eld reference or assignment ex\u00adpressions. Further, Setj prohibits assignments to acquired .elds; see \nsection 5.5 for the rationale for this restriction. The Defnj rule contains most of the changes that \nsupport acquisition. First, it veri.es that class c s environments pro\u00advide the necessary .elds and methods \nwith compatible types. This indirectly requires that if c or any of its superclasses acquire any .elds \nor methods, then c must have at least one container. Second, c s containers must be a superset of c s \nsuperclass s containers, to preserve behavioral subtyping.2 Third, it must ensure that all of the classes \nthat can be in c s contained .elds allow themselves to be contained in c, as required by the soundness \nproof. The Defnj rule could also verify that class A can contain instances of class B if and only if \nB can be contained in A. While warnings of violations of this invariant are likely to be useful to the \npro\u00adgrammer, they are not required for type soundness. 2As we move down the inheritance hierarchy, the \nset of possi\u00adble containers must increase monotonically. However, a subclass may also add new acquired \n.elds or methods; this further con\u00adstrains the set of possible containers. There is no inconsistency \nhidden here; it simply creates a trade-o. that the programmer must consider during the design of class \nhierarchies.  4.3 Semantics Jacques s semantics is like that of ClassicJava,with some modi.cations and \nadditions; the changes are de.ned in .gure 11, with additional supplementary functions de\u00ad.ned in .gure \n12. In particular, many of these rules per\u00adform the additional run-time checks necessary to ensure that \nacquisition is well-de.ned. In particular, the agetj , acallj , and asuperj rules ensure that references \nto acquired .elds or methods happen when the object is in a su.ciently rich environment; if not, the \nrules raise an incomplete context exception. Similarly, the ct-setj rule, for assignment to a contained \n.eld, ensures that the .eld s new contents are not already contained elsewhere and that the assignment \ndoes not create an acquisition cycle. If either condition fails, the rules raise an already contained \nor containercycle ex\u00adception as appropriate.  4.4 Jacques Soundness To study the properties of Jacques \ns type system and se\u00admantics, we have implemented the model in PLT Redex [18], a system for debugging \nreduction systems. This implemen\u00adtation does not yet support either method acquisition or .eld assignment, \nbut it raises our con.dence that the proof of the following type-soundness theorem is correct. e ... \nobj v obj null E []E.fd E.fd = ev.fd = EE.md( e ...) v.md( v ...E e ...) super = v : c.md( v ...E e ...) \ncast t E let var = Ein e P f ( E[new c],S) .-( E[obj ],S[ obj -( c,null,F )]) [newj ] where obj r dom( \nS) and F { fd- null ( t,fd,s) .P c and si acquired} P f ( E[obj .fd],S) .-( E[F( fd) ],S) [getj ] where \nF .elds( S( obj )) and fd E dom( F) P f ( E[obj .fd],S) .-( E[getAcqFieldP ( S,obj ,fd) ],S) [agetj] \nwhere ( t,fd,acquired) .P classTag( S( obj )) and getAcqFieldP ( S,obj ,fd)i. P f ( E[obj .fd],S) .-( \nerror: incomplete context,S) [xagetj] where ( t,fd,acquired) .P classTag( S( obj )) and getAcqFieldP \n( S,obj ,fd). P f ( E[obj .fd = v],S) .-( E[v],updateField( S,obj ,fd,v)) [setj ] where ( t,fd,normal) \n.P classTag( S( obj )) P f ( E[obj .fd = null],S) .-( E[null],updateCtdField( S,obj ,fd,null)) [n-ct-setj \n] where ( t,fd,contained) .P classTag( S( obj )) P f ( E[obj .fd = v],S) .-( error: already contained,S) \n[x-ct-setj] where ( t,fd,contained) .P classTag( S( obj )) and v E dom( S) and ctnr( S( v))i null P f \n( E[obj .fd = v],S) .-( error: container cycle,S) [cycle-setj ] where ( t,fd,contained) .P classTag( \nS( obj )) and v E dom( S) and canReachP ( S,obj ,v) P f ( E[obj .fd = v],S) .-( E[v],updateCtdField( \nS,obj ,fd,v)) [ct-setj ] where v E dom( S) and ( t,fd,contained) .P classTag( S( obj )) and ctnr( S( \nv)) null and . canReachP ( S,obj ,v) P f ( E[obj .md( v1 ... vn) ],S) .-( E[eb[ obj '/ this,v1/ var1,...,vn/ \nvarn] ],S) [acallj] where ( md,T,V,e,acquired) .P classTag( S( obj )) and ( obj ' ,eb) getAcqMethodP \n( S,obj ,md) P f ( E[obj .md( v1 ... vn) ],S) .-( error: incomplete context,S) [xacallj] where ( md,T,V,e,acquired) \n.P classTag( S( obj )) and getAcqMethodP ( S,obj ,md). ' P f ( E[super = obj : c .md( v1 ... vn) ],S) \n.-( E[e[ obj/ this,v1/ var1,...,vn/ varn] ],S) [superj] where ( md,T,( var1,...,varn) ,e,normal) .P c \n' P f ( E[super = obj : c ' .md( v1 ... vn) ],S) .-( E[e[ obj '/ this,v1/ var1,...,vn/ varn] ],S) [asuperj] \nwhere ( md,T, , ,acquired) .P c ' and ( obj ' ,e) getAcqMethodP ( S,obj ,md) P f ( E[super = obj : c \n' .md( v1 ... vn) ],S) .-( error: incomplete context,S) [xasuperj] where ( md,T, , ,acquired) .P c ' \nand getAcqMethodP ( S,obj ,md). P f ( E[cast t ' obj ],S) .-( E[obj ],S) [cast] where S( obj )( c,ctnr,F \n) and c P t ' P f ( E[let var = v in e],S) .-( E[e[ v/ var] ],S) [let] P f ( E[cast t ' obj ],S) .-( \nerror: bad cast,S) [xcast] where S( obj )( c,ctnr,F ) and c P t ' P f ( E[cast t ' null],S) .-( error: \ndereferenced null,S) [ncast] P f ( E[null.fd],S) .-( error: dereferenced null,S) [nget] P f ( E[null.fd \n= v],S) .-( error: dereferenced null,S) [nset] P f ( E[null.md( v1 ... vn) ],S) .-( error: dereferenced \nnull,S) [ncall] Figure 11: Jacques operational semantics getAcqFieldP ( S, null, fd) getAcqFieldP ( S, \nobj , fd) {F( fd) getAcqFieldP ( S, ctnr, fd) if fd E dom( F) otherwise where ( c, ctnr, F ) S( obj ) \ngetAcqMethodP ( S, null, fd) getAcqMethodP ( S, obj , fd) {( obj, eb) getAcqMethodP ( S, ctnr, md) if \n( md,T,V, eb, normal) .P classTag( S( obj )) otherwise where ctnr ctnr( S( obj )) updateField( S, obj \n, fd, v) S[ obj -( c, ctnr, F[ fd -v] ) ] where ( c, ctnr, F ) S( obj ) updateCtdField( S, obj , fd, \nv) updateField( S2, obj , fd, v) where ( c, ctnr, F ) S( obj ) and S1 updateContainer( S, F( fd) , null) \nand S2 updateContainer( S1, v, obj ) updateContainer( S, obj , ctnr) { S if obj null S[ obj -( c, ctnr, \nF )] otherwise where ( c, , F ) S( obj ) canReachP ( S, obj , v) = obj v or ( ctnr i null and canReachP \n( S, ctnr, v)) where ctnr ctnr( S( obj )) Figure 12: Jacques supplementary functions  Theorem 2 (Type \nSoundness for Jacques) If fp P I P ' : t and P ' = defn1 ... defnn e, then either P ' f< e,O)1 ;or P \n' f< e,O) '-* < obj ,S) and classTag( S( obj )) P t; or P ' f< e,O) '-* < null,S) ;or P ' f< e,O) '-* \n< error: bad cast,S) ;or  P ' f< e,O) '-* < error: dereferenced null, S) ;  or P ' f< e,O) '-* < error: \nincomplete context,S) ;or  P ' f< e,O) '-* < error: already contained,S) ;or  P ' f< e,O) '-* < error: \ncontainer cycle,S) .  A comparison of theorem 1 and theorem 2 indicates that Jacques can throw additional \nexceptions that do not occur in ClassicJava programs. The last three exceptions are forced upon us by \nacquisition, and we cannot avoid them without a complex analysis, a more sophisticated type sys\u00adtem, \nor di.erent linguistic mechanisms. Put di.erently, we have succeeded in making acquisition just as safe \nas ML, as many errors can be caught statically, but some run-time checks (and exceptions) remain necessary. \nThe soundness proof follows the standard method [23] as applied to ClassicJava [7]. In addition to the \nsubject reduc\u00adtion and uniform evaluation lemmas, we also require some de.nitions and supporting lemmas \nbeyond those used in the ClassicJava soundness proof; they are stated below. De.nition 1 (Object Containment) \nWe write P,Sfobj 1 :obj 2 to indicate that obj 1 contains obj 2 in store Sand program P. Formally: P,Sfobj \n1 :obj 2 <I S( obj 1)=< c,ctnr,F) and F( fd)= obj 2 for some fd such that < c ' ,fd,contained) .P c. \nDe.nition 2 (Object Containment Graph) For a given store S, we construct a directed graph GS , called \nthe object containment graph, as follows: GS =( V,E) where 2 V = rng( S) and E ={< x,y)E V I ctnr( x)= \ny. In other words, there is a node in GS for each object in S, andan edgefromeachnodetoits container. \nNext we need to adapt the environment-store consistency relation from the proof of theorem 1 to the new \ncontext. De.nition 3 (Environment-Store Consistency) We write P,G fs Sto indicate that the type environment \nG and the store Sare consistent with one another, given the program P. Formally: P,G fs S= obj Edom(G)=) \n obj Edom(S 1dom(S)<dom(G) * 1GS has no cycles and is of .nite size 1[S (obj )=(c,ctnr,F)= G(obj )=c \n1dom(F)={fd I(t,fd,s).P c,s E{normal,contained}} 1rng(F)<dom(S){null} . 1(F(fd)Edom(S)1(c,fd,s).P c)= \n. classTag(S(F(fd))).Pc * 1(F(fd)=F(fd.)*null 1(t,fd,contained).P c1 (t. ,fd. P c)= ,contained). fd =fd. \n. . * 1 .3obj).P,Sfobj.obj ctnr =null =Edom(S * 1)= ctnr Edom(S P,Sfctnr .obj * 1)= ctnr Edom(S . . 3cEcontainersP \n(c).classTag(S(ctnr)).Pc * 1(P,Sfobj .obj.)=(obj ctnr(S .))=obj * 1ctnr Edom(S){null}] Those clauses \nmarked with * are added to ClassicJava for Jacques. In order, they place the following requirements on \nthe store: No object may have two contained .elds that refer to the same object. This allows us to set \nan object s container to null when we remove it from its container without breaking any other invariants. \n If obj s container is null, then there exists no object that contains obj .  If obj s container is \nobj ' ,then obj ' contains obj .  If obj has class tag c and container obj ' ,then obj ' must have a \nclass tag that is a subtype of one of class c s containers.  If obj contains obj ' ,then obj ' must \nspecify obj as its container.  An object s container is either a valid object reference or null.  Lemma \n1 (Containment Path Consistency) If P, G fs S and S( obj )=< c, ctnr, F ) and ctnr i null,then there \nexists a class c ' E containersP ( c) such that classTag( S( ctnr)) P c ' . This lemma follows fairly \ndirectly from P, G fs S.Since GS is .nite and acyclic, all paths have .nite length, and therefore a simple \ninduction on the length of the path proves that all paths in the object containment graph are consistent \nwith the class containment graph. We use this result in the proof of the subject reduction lemma to ensure \nthat the results of getAcqFieldP and getAcqMethodP have the expected types.  5. JACQUES DESIGN ISSUES \nIn developing Jacques, we encountered several interest\u00ading design problems. We rejected some design alternatives \nbecause they break type safety; for others, we based our decisions on pragmatics. In this section, we \ndiscuss these design choices and provide rationales. We use the program in .gure 13 as a running example. \n5.1 Containment Cycles The object containment graph cannot have cycles, as Gil and Lorenz explain. This \ndoes not mean, however, that the class containment graph should be acyclic as well. As stated in section \n2, acquisition is often useful in conjunction with the composite pattern. It is frequently essential \nin this pattern that objects be allowed to contain other instances of their own class (or a superclass). \nFor a concrete example, consider a GUI toolkit library in which classes such as Panel and Button are \nsubclasses of Component. If instances of Panel cannot contain other instances of Panel or instances of \n(subclasses of) Component, then programmers have too little freedom to compose objects. Therefore, we \nallow cycles within the class containment graph. Acquisition remains well-de.ned as long as the object \ncontainment graph has no cycles, and the ct-setj reduction enforces this restriction at runtime. This \ndesign choice is orthogonal to type safety. As dis\u00adcussed in section 4.4, we have proved type soundness \nwith cycles in the class containment graph. 5.2 Acquisition by Value and by Name In their original description \nof acquisition, Gil and Lorenz do not address .eld assignment and how it interacts with acquisition. \nWith assignment, it becomes important to de\u00adtermine when acquisition takes place. We considered two op\u00adtions, \nwhich we call acquisition-by-value and acquisition\u00adby-name, by analogy with call-by-value and call-by-name. \nTheprimary di.erencebetween thetwo is thepoint at which the acquiring object receives the value of the \ncontainer s .eld. In our running example (.gure 13) with acquisition-by\u00advalue, the acquiring object anItem \nreceives the value of its acquired .elds when it is placed in its container aCtnr. Sub\u00adsequent modi.cations \nto aCtnr s .elds are not automatically visible to anItem. With acquisition-by-name, on the other hand, \nanItem receives the value of its acquired .elds anew each time the .elds are referenced. Therefore, modi.cations \nto aCtnr s .elds are automatically visible to anItem.In both cases, type soundness is preserved as long \nas the value in aCtnr.fd has a type compatible with that declared for an\u00adItem.fd. The choice of acquisition-by-value \nraises two questions: 1. If we remove anItem from its container aCtnr,doesit preserve the .eld values \nit acquired from aCtnr,ordo those .elds now become unde.ned? 2. If we then add anItem to another container \naCtnr ' ,does it preserve its existing .eld values, or does it replace them with the values then current \nin its new container?  With acquisition-by-name, in contrast, the answers to these questions follow \ndirectly from the de.nition above. This ambiguity leads us to believe that acquisition-by-name is the \nbetter mechanism, from both a semantic as well as a pragmatic perspective. 5.3 Types of Acquired Fields \nIn the example of .gure 13, anItem acquires the .eld fd from its environment, speci.cally the container \naCtnr.The class Container1 de.nes fd to have type Prop1, but Item ac\u00adquires it with Property s interface. \nSince Prop1 is a sub\u00adtype of Property, this acquisition is safe. In general, ac\u00adquiring classes may expect \na more general type for their acquired .elds than their environments actually provide. For increased \n.exibility, the de.nition of Jacques, through the canAcqP predicate, allows just this sort of type vari\u00adance. \n(Note that this is similar to, though not exactly the same as, the traditional notion of contravariance: \nwe have Prop1 P Property but Item P Container1,so the idea of one type getting larger while the other \ngets smaller is not applicable.)  5.4 Types of Acquired Methods In our example, Item acquires the method \nmeth with ar\u00adgument type Prop2 and result type Property.This is safe so long as the method that is actually \nexecuted as as result of calls to anItem.meth (that is, the method provided by the context) allows a \nmore general type for its arguments and returns a value of a more speci.c type. So, since Prop2 P Property \nand Prop1 P Property, Item can safely acquire meth from Container1. The de.nition of canAcqMethP allows \nthis .exibility. This is only safe, however, because Jacques does not support method overloading. As \nwe scale acquisi\u00ad Container2 contains Item it Prop2 fd Property meth(Prop2 x) { ... } Property ... Item \n: contained Ctnr1, Ctnr2 Prop1 fd2 acquire Property fd acquire Property meth(Prop2) Container1 Prop1 \nfd Prop2 fd2 contains Item it Prop1 meth(Property p) { ... }  ... Prop1 ... Prop2  class Main { Container1 \naCtnr Item anItem ... Object run () { ... aCtnr.it = anItem // anItem contained in aCtnr ... } ... } \n Figure 13: Jacques running example tion to a language with method overloading, we may have to restrict \nmethod acquisition to use invariant types.  5.5 Assignment to Acquired Fields Allowing assignment to \nacquired .elds with contravari\u00adant typing as described above is not type-safe. In our run\u00adning example, \nan assignment such as anItem.fd = new Prop2() would type-check because anItem.fd is declared to have \ntype Property. However, since anItem acquires the .eld fd from aCtnr,and aCtnr.fd has type Prop1, allowing \nassignments such as the above would break type safety. There are three possible strategies that would \nallow assignment to anItem.fd while preserving type safety: 1. Thetype ofanacquired.eld mustmatch exactlyin \nthe acquiring class and the container. In our example, this would correspond to requiring Item to acquire \nthe .eld fd with type Prop1 (which would in turn prevent Container2 from containing Item). 2. We could \nrestrict the assignment statement while pre\u00adserving variance in acquired .eld types. In this case, the \nvalue on theright-handsideofanassignment must have exactly the same type as the left-hand side; sub\u00adtyping \nwould no longer be allowed here. 3. We could preserve the variance in acquired .eld types and simply \ndisallow all assignments to acquired .elds.  The second option has several drawbacks. First, as long \nas we preserve subsumption throughout the rest of the lan\u00adguage, this restriction could only be performed \nby a dynamic check, which would complicate the semantics yet further. Second, it would restrict the types \nallowed on the left-hand side of an assignment statement. In Java, for instance, the left-hand side of \nsuch an assignment statement could not have an interface type. Because interfaces can never be in\u00adstantiated \ndirectly, it would be impossible for the value of theright-handsidetohaveexactly the same type asthe \nleft. This would severely constrain assignment statements. Finally, it would forbid subsumption in a \nparticular con\u00adtext. Not only would this create asymmetry in the language design, it would do so in a \nparticularly restrictive fashion, due to the frequent occurrence of assignment statements in object-oriented \nprograms. Therefore, we must choose between the .rst and third options. Jacques implements the third \noption, as we con\u00adjecture that it is more pragmatically useful than the .rst. Without the bene.t of experience \nwith acquisition in real\u00adworld software projects, though, we cannot answer this ques\u00adtion de.nitively, \nand we need to revisit this issue once we have gained more experience. 5.6 Changing Containers With \nthe ability to mutate .elds in existing objects comes the ability to mutate the object containment graph \nafter it has been established. While this ability may be neces\u00adsary in some applications, we want to \npreserve the invariant that aCtnr contains anItem if and only if anItem s container is aCtnr. This allows \nboth objects, but particularly aCtnr, to make useful assumptions about the object containment graph at \nruntime. For this reason, we prohibit programs from moving an object from one container to another in \na single assignment statement, because it can easily break the containment hier\u00adarchy property. This \nrestriction is enforced by the x-ct-setj reduction, which requires an object s container pointer to be \nnull before it can be added to a container. An alternative would be to follow Alan Kay s maxim of replacing \nassign\u00adment with higher-level forms of mutation operations [14], speci.cally a switch-container operation. \n 5.7 Forwarding and Delegation Semantics Gil and Lorenz discuss the choice between forwarding and delegation \nsemantics for acquired methods. To de.ne these terms as applied to environmental acquisition, consider \nour running example, in which anItem acquires the method meth from aCtnr;recall that Item P Container1. \nUnder forward\u00ading semantics, when Main invokes anItem.meth, this is bound to aCtnr during the execution \nof the method s body. With delegation semantics, this is instead bound to anItem. By type rule Methj, \nthe body of Container1.meth is elab\u00adorated under the assumption that this has type Container1 (or any \nsubtype). Hence, the body can refer to arbitrary features of Container1,such as fd2.If, instead, this \nwere sud\u00addenly bound to anItem at runtime, references to properties of Container1 may become unde.ned \nor ill-typed. Specif\u00adically, a reference to this.fd2 would reduce to a value of type Prop1 rather than \nProp2 as expected. We thus conclude that forwarding semantics for environmental acquisition is the only \nsafe possibility in a statically typed language. 5.8 Guarded Field References As de.ned, Jacques throws \nan exception upon a refer\u00adence to an acquired .eld if the object in question is not in an environment \nthat provides the expected .eld. In their original formulation, Gil and Lorenz propose guarded .eld references \nas a protection against this exception. A guarded .eld reference is simply a .eld reference expression \nthat in\u00adcludes a default value to be used if the object is not in a suitable environment. If the compiler \ncan prove that, for a particular .eld reference, the object is always in a suitable environment, the \nprogrammer may omit the default. Since Jacques s type system cannot prove this for any .eld reference, \nall references would have to have guards in order to preserve safety. As a result, proving type soundness \nwith guards is not markedly di.erent from proving it with the incomplete context exception. Further, \nwe conjecture that in practice, most programmers would specify null as their guard expression, thus hiding \nthe incomplete context exception within a null pointer exception and thus severely hindering their own \ndebugging e.orts. Therefore, we have have chosen to omit guards and to raise an exception in cases where \nan object s environment does not su.ce. If practical experience suggests that such guards are practically \nuseful, we may add them to the language later.  6. SCALING TO FULL JAVA To scale Jacques s design to \nfull Java [13] or C# [3], we must address two features of the larger language that our model does not \ninclude: concurrency and .eld shadowing. It seems that acquisition can co-exist with concurrency with\u00adout \nany more than the normal di.culties associated with concurrent programs. In particular, if one thread \nchanges the object containment graph while another is traversing that graph to look up an acquired .eld \nvalue, the results are unde.ned. It would be possible to de.ne an acquired .eld reference to be an atomic \noperation via a Java synchronized block, but this seems unnecessary; the di.culties that can arise in \nsituations like this are no worse than those which may arise in concurrent Java programs that involve \nheavy pointer manipulation. Java-style .eld shadowing presents a more complicated challenge. In the case \nwhere an object acquires a shadowed or shadowing .eld from its container, it is no longer clear which \n.eld should be visible to the acquiring object. Con\u00adsider the following class de.nitions: class A extends \nObject ...{Xx ...} class B extends A ...{Xx ...} class C extends Object contained A {...acquires X x \n...} If c, an instance of C, is contained within b, an instance of B, it is most consistent with Java \ns current behavior if c acquires A.x rather than B.x,as c acquires properties from its container as viewed \nthrough A s interface. However, the language should provide the programmer with a means of overriding \nthis default when necessary, much as Java allows the programmer to cast the object in a .eld reference \nex\u00adpression to select which overloaded .eld is used. 7. RELATED WORK The recent work in ownership types \n[2, 1] introduces con\u00adstraints on the object composition graph in order to pre\u00adserve certain desirable \ninvariants, much as we do. In such a type system, the programmer annotates all .eld declara\u00adtions, local \nvariable declarations, method arguments, and method return types with ownership information. The type \nsystem then ensures that all paths from the root of the ob\u00adject containment graph to an object must pass \nthrough the object s owner. Consequently, if an object is owned by its container, only its container \nmay refer to it. This restricts object aliasing and makes it easier to reason about object\u00adoriented programs \nin the face of .eld mutation. While ownership types and types for environmental ac\u00adquisition both restrict \nthe shape of the object containment graph, the similarities end there. While ownership con\u00adstraints could \nhelp ensure that an object has at most one container, we believe that preventing aliasing to the degree \nachieved by their system is overly restrictive. In Jacques, we explicitly allow an object to possess \na reference to the contents of another object s contained .eld, so long as this additional reference \ndoes not imply a containment relation\u00adship. Further, we could remove the need for the already contained \nexception without complicating the type system further by disallowing direct assignment to contained \n.elds and providing a switch-container operation that manipulates the object containment graph while \npreserving all desired in\u00advariants. Finally, ownership types do not appear to help our existing system \ns most severe drawback, namely the inabil\u00adity to detect at compile time whether an object will be in \nan environment that provides all of the necessary acquired .elds and methods. 8. CONCLUSIONS AND FUTURE \nWORK In this paper, we have resumed Gil and Lorenz s language design experiment in environmental acquisition. \nWe have extended ClassicJava to provide a formal operational se\u00admantics and a formal type system for \na language that in\u00adcludes acquisition, thus placing the mechanism on a .rm theoretical grounding. We \nhave also explored several of the design alternatives in the formal context, and we have found that type \nsoundness means that many of these alternatives can only be resolved in certain ways. Soundness alone \nis not su.cient to resolve all of the design choices, however, so we clearly need more experience with \nacquisition to make the appropriate choices. This research suggests three additional projects. First, \nwe need to implement acquisition by modifying an existing class system, so that we can conduct program \ndesign experiments in the context of a full programming language. Second, we must search existing class \nlibraries and frameworks for in\u00adstances of environmental acquisition via pointer chasing or callbacks \nto collect a wide range of examples for this fea\u00adture. Third, we must investigate the use of more advanced \ntype systems for acquisition. These include the ability to infer certain types, such as the list of possible \ncontainers for a class, and the use of resource-aware type systems to en\u00adsure that certain exceptions \n(most notably the incomplete context exception) cannot be generated. Acknowledgments: We thank David \nLorenz for taking the time to discuss his prior work with us. We also thank Mitchell Wand for his assistance \nwith Jacques s soundness proof. Finally, we thank the anonymous reviewers for their comments, insights, \nand suggestions. 9. REFERENCES [1] Dave Clarke and Sophia Drossopoulou. Ownership, encapsulation and \nthe disjointness of type and e.ect. In Proceedings of the 17th ACM SIGPLAN Conference on Object-Oriented \nProgramming, Systems, Languages, and Applications, pages 292 310. ACM Press, 2002. [2] David G. Clarke, \nJohn M. Potter, and James Noble. Ownership types for .exible alias protection. In Proceedings of the \n13th ACM SIGPLAN Conference on Object-Oriented Programming, Systems, Languages, and Applications, pages \n48 64. ACM Press, 1998. [3] Microsoft Corporation. Microsoft C# Language Speci.cations. Microsoft Press, \n2001. [4] Robert Bruce Findler, John Clements, Cormac Flanagan, Matthew Flatt, Shriram Krishnamurthi, \nPaul Steckler, and Matthias Felleisen. DrScheme: A programming environment for Scheme. Journal of Functional \nProgramming, 12(2):159 182, March 2002. A preliminary version of this paper appeared in PLILP 1997, LNCS \nvolume 1292, pp. 369 388. [5] Matthew Flatt. PLT MzScheme: Language manual. Technical Report TR97-280, \nRice University, 1997. http://www.plt-scheme.org/software/mzscheme/. [6] Matthew Flatt and Robert Bruce \nFindler. PLT MrEd: Graphical toolbox manual. Technical Report TR97-279, Rice University, 1997. http://www.plt-scheme.org/software/mred/. \n[7] Matthew Flatt, Shriram Krishnamurthi, and Matthias Felleisen. A programmer s reduction semantics \nfor classes and mixins. In Formal Syntax and Semantics of Java, volume 1523 of Springer Lecture Notes \nin Computer Science, pages 241 269. Springer-Verlag, 1999. Preliminary version appeared in proceedings \nof Principles of Programming Languages, 1998. Revised version is Rice University technical report TR \n97-293, June 1999. [8] Martin Fowler and Kendall Scott. UML Distilled: Applying the Standard Object Modeling \nLanguage. Addison-Wesley, Reading, MA, 1997. [9] Jim Fulton. Extension classes, Python extension types \nbecome classes. http://debian.acm.ndsu.nodak.edu/ doc/python-extclass/ExtensionClass.html. [10] Erich \nGamma, Richard Helm, Ralph Johnson, and John Vlissides. Design Patterns: Elements of Reusable Object-Oriented \nSoftware. Addison-Wesley, Reading, MA, 1995. [11] Joseph Gil and David H. Lorenz. Environmental acquisition: \na new inheritance-like abstraction mechanism. In Proceedings of the Eleventh Annual Conference on Object-Oriented \nProgramming Systems, Languages, and Applications, pages 214 231. ACM Press, 1996. [12] Joseph (Yossi) \nGil and David H. Lorenz. Object technology: Design patterns and language design. IEEE Computer, 31(3):118 \n120, March 1998. [13] James Gosling, Bill Joy, and Guy Steele, Jr. The Java Language Speci.cation. Addison-Wesley, \n1996. [14] Alan C. Kay. The early history of Smalltalk. In The Second ACM SIGPLAN Conference on History \nof Programming Languages, pages 69 95. ACM Press, 1993. [15] Shriram Krishnamurthi, Yan-David Erlich, \nand Matthias Felleisen. Expressing structural properties as language constructs. In European Symposium \non Programming, volume 1576 of Springer Lecture Notes in Computer Science, pages 258 272, March 1999. \n[16] Amos Latteier, Michel Pelletier, Chris McDonough, and Peter Sabaini. TheZopeBook. SAMS, 2001. Also \navailable on-line at http://zope.org/Documentation/Books/ZopeBook. [17] Mark Logan, Matthias Felleisen, \nand David Blank-Edelman. Environmental acquisition in network management. In Proceedings of LISA 2002: \nSixteenth Systems Administration Conference, pages 175 184. USENIX Association, 2002. [18] Jacob Matthews, \nRobert Bruce Findler, Matthew Flatt, and Matthias Felleisen. A visual environment for developing context-sensitive \nterm rewriting systems. In International Conference on Rewriting Techniques and Applications, 2004. [19] \nBertrand Meyer. Ei.el: The Language. Prentice Hall, 1992. [20] Sun Microsystems. Java 2 standard edition \nSDK, v1.4.2. http://wwws.sun.com/software/ communitysource/j2se/java2/download.html. [21] Sun Microsystems. \nJava foundation classes (JFC/Swing). http://java.sun.com/products/jfc/index.jsp. [22] Python. http://www.python.org/. \n[23] Andrew K. Wright and Matthias Felleisen. A syntactic approach to type soundness. Information and \nComputation, 115(1):38 94, 1994. First appeared as Technical Report TR160, Rice University, 1991.  \n\t\t\t", "proc_id": "1040305", "abstract": "In 1996, Gil and Lorenz proposed programming language constructs for specifying environmental acquisition in addition to inheritance acquisition for objects. They noticed that in many programs, objects are arranged in containment hierarchies and need to obtain information from their container objects. Therefore, if languages allowed programmers to specify such relationships directly, type systems and run-time environments could enforce the invariants that make these programming patterns work.In this paper, we present a formal version of environmental acquisition for class-based languages. Specifically, we introduce an extension of the ClassicJava model with constructs for environmental acquisition of fields and methods, a type system for the model, a reduction semantics, and a type soundness proof. We also discuss how to scale the model to a full-scale Java-like programming language.", "authors": [{"name": "Richard Cobbe", "author_profile_id": "81100210963", "affiliation": "Northeastern University, Boston, MA", "person_id": "P707745", "email_address": "", "orcid_id": ""}, {"name": "Matthias Felleisen", "author_profile_id": "81100323458", "affiliation": "Northeastern University, Boston, MA", "person_id": "PP39037684", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1040305.1040307", "year": "2005", "article_id": "1040307", "conference": "POPL", "title": "Environmental acquisition revisited", "url": "http://dl.acm.org/citation.cfm?id=1040307"}