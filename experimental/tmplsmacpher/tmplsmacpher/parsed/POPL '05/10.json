{"article_publication_date": "01-12-2005", "fulltext": "\n Proof-Guided Underapproximation-Widening for Multi-Process Systems Orna Grumberg Flavio Lerda Computer \nScience Department Computer Science Department Technion Haifa, Israel Carnegie Mellon Pittsburgh, PA, \nUSA orna@cs.technion.ac.il lerda@cmu.edu Ofer Strichman Michael Theobald Information Systems Engineering \nComputer Science Department Faculty of Industrial Engineering Carnegie Mellon Technion Haifa, Israel \nPittsburgh, PA, USA ofers@ie.technion.ac.il theobald@cs.cmu.edu ABSTRACT This paper presents a procedure \nfor the veri.cation of multi-process systems based on considering a series of underapproximated mod\u00adels. \nThe procedure checks models with an increasing set of al\u00adlowed interleavings of the given set of processes, \nstarting from a single interleaving. The procedure relies on SAT solvers ability to produce proofs of \nunsatis.ability: from these proofs it derives information that guides the process of adding interleavings \non the one hand, and determines termination on the other. The presented approach is integrated in a SAT-based \nBounded Model Checking (BMC) framework. Thus, a BMC formulation of a multi-process system is introduced, \nwhich allows controlling which interleavings are considered. Preliminary experimental results demonstrate \nthe practical impact of the presented method.  Categories and Subject Descriptors D.2.4 [Software/Program \nVeri.cation]: Model checking; F.3.1 [Specifying and Verifying and Reasoning about Programs]: Me\u00adchanical \nveri.cation General Terms Algorithms, Reliability, Veri.cation Keywords Abstraction, Bounded model \nchecking, SAT proofs, Software Ver\u00adi.cation, Underapproximation-Widening Permission to make digital or \nhard copies of all or part of this work for personal or classroom use is granted without fee provided \nthat copies are not made or distributed for pro.t or commercial advantage and that copies bear this notice \nand the full citation on the .rst page. To copy otherwise, to republish, to post on servers or to redistribute \nto lists, requires prior speci.c permission and/or a fee. POPL 05, January 12 14, 2005, Long Beach, California, \nUSA. Copyright 2005 ACM 1-58113-830-X/05/0001 ...$5.00. 1. INTRODUCTION We present a procedure for model \nchecking multi-process sys\u00adtems based on considering a series of underapproximated models. The procedure \nchecks models with an increasing set of allowed in\u00adterleavings of the given set of processes, starting \nfrom a single in\u00adterleaving. Only in the worst case, the procedure attempts to verify a model with the \nsame amount of concurrency as the original one has. The procedure considers underapproximations with \nincreasing amount of concurrency until one of two possible termination con\u00additions holds: The procedure \n.nds a counterexample: in this case, since the considered model is an underapproximation of the origi\u00adnal \none, it concludes that the property is violated.  The procedure proves that all traces in the underapproxi\u00admated \nmodel satisfy the property, and the proof does not rely on the underapproximation. In this case, the \nproof can also serve as a proof for the original model. Hence, the procedure concludes that the property \nholds.  The Underapproximation-Widening (UW) of the model (widen\u00ading is the term we use for adding behaviors \n) progresses by adding concrete behaviors, and this way removes false positive results. Unlike Abstraction-Re.nement \n(AR), which is based on iterations of overapproximation and narrowing (removing spurious behav\u00adiors) \nand can be fully automated [20, 10, 11, 3, 22, 4], we are not aware of a completely automated UW procedure \nfor model check\u00ading of either a single or multiple processes. The reason for the difference is that re.nement \nof overapproximated models in AR is easier to guide, because it can rely on spurious counterexamples \ngenerated by the model checker. Indeed, work on counterexample\u00adguided AR [13, 11] showed how to gradually \nremove spurious counterexamples by investigating the so called failing state , i.e., the .rst state in \nthe spurious trace that cannot be simulated on the concrete model. Such guidance does not naturally exist \nin the UW framework, because there is no counterexample to show what went wrong. A recent investigation \ninto deriving proofs of unsatis.ability from state-of-the-art Boolean satis.ability solvers (SAT solvers) \n[2, 9] enables us to design a fully automated UW process. SAT solvers are used in model checking to verify \nthe validity of a property. In particular, we can check whether a generated proof of unsatis.abil\u00adity \n which is a proof of the validity of the property relies on the underapproximation, and if so, we can \nguide the widening process according to the variables that participate in the proof. Both of the above \nreferences [2, 9] exploit proofs of unsatis.ability in an AR process, in contrast to this paper. To the \nbest of our knowledge, the presented UW approach is the .rst underapproximation model checking algorithm \nthat is fully automated. There are several approaches that use sequences of underapproximations in the \ncontext of Binary Decision Diagrams (BDDs) based model checking, in order to keep the size of the BDDs \nsmall [25, 26, 5], but they include no explicit notion of au\u00adtomatic widening: the sequence is given \na-priori by the user. Our method, on the other hand, computes the initial underapproxima\u00adtion and successively \nwidened underapproximations automatically. Since we generate underapproximations by limiting the number \nof interleavings of concurrent components, our work is aimed at multi-process systems. Another technique, \nalso addressing the ex\u00adponential blow-up due to interleavings, is partial-order reduction [17, 28, 24, \n1, 18, 16]. The way we compute underapproximations is similar to the way partial-order techniques compute \na reduced system. However, partial-order reduction does not work iteratively: it simply generates a restricted \nmodel that is guaranteed to have the same temporal properties over visible behavior (i.e. properties \nexpressed by the global variables of the system, disregarding vari\u00adables that are local to the processes) \nas the original model. Our technique is more aggressive than partial-order reduction, since it considers \nmodels with fewer interleavings. In more fortunate cases it .nds errors in the underapproximated model, \nwhich re.ects a smaller state space and, hence, it is typically easier to analyze. Moreover, we use information \nderived from the proof of unsatis.a\u00adbility to decide which additional behaviors to introduce at the next \niteration. We bene.t from the fact that a bug in a multi-process sys\u00adtem typically corresponds to multiple \ncounterexamples and every counterexample corresponds to a single interleaving. The proposed proof-guided \napproach for adding behaviors often results in under\u00adapproximated models that exhibit the error but include \nmuch fewer interleavings than the original model. Since our approach relies on the ability of SAT solvers \nto gener\u00adate proofs of unsatis.ability, it is incorporated in a Bounded Model Checking (BMC) [8, 6] framework. \nBMC is an iterative proce\u00addure that checks the validity of a property for traces of increas\u00ading length. \nAt each iteration the property is checked for traces of .xed length by encoding them as a Boolean formula. \nA SAT solver is used to determine satisfying assignments of such a for\u00admula, which represent violations \nof the property. We use Under\u00adapproximation/Widening to improve this veri.cation step. Since BMC is only \nable to prove a property for bounded executions, it is mainly aimed at property falsi.cation, i.e., .nding \ncounterexam\u00adples. Our approach extends this technique for the case of multi\u00adprocess systems. The remainder \nof the paper is organized as follows. Section 2 presents preliminaries. Section 3 describes the Underapproxima\u00adtion-Widening \nalgorithm for the BMC/SAT framework. Section 4 describes how to apply the algorithm to multi-process \nsystems. Section 5 presents experimental results, and Section 6 gives con\u00adclusions. Figure 1: The processes \nof a multi-process system. Each pro\u00adcess is given as a control-.ow graph in which nodes are control points \nand edges are statements. 2. PRELIMINARIES 2.1 Multi-Process Systems We consider asynchronous multi-process \nsystems, which can be de.ned as the composition of N processes P1,...,PN according to the standard interleaving \nsemantics. Processes communicate by reading and writing to shared variables that are accessible to all \nprocesses. Processes are modeled in the guarded command framework [14]. Each process can be expressed \nas a control-.ow graph: nodes rep\u00adresent control points, edges represent transitions (or statements). \nAt every control point, there can be none, one, or multiple enabled transitions. Each transition has \na guard associated to it: intuitively a transition is enabled if the condition that guards it is true \nin the cur\u00adrent state and the process to which it belongs is at the control point corresponding to its \nsource. Consider, for example, the following code fragment: if :: b>1->a=1; :: b>2->a=2; fi; At the initial \ncontrol point, if the current state is such that b > 2, then both transitions are enabled, because their \nguards (the condi\u00adtions appearing to the left of -> ) are true. In this case, one of the two transitions \nis selected non-deterministically. If, on the other hand, b = 1, no transition is enabled and the process \nstops until, possibly, b is updated by another process. We say that a process is enabled in a state s \nif at least one of its transitions is enabled in s. EXAMPLE 1. Figure 1 shows the control-.ow graphs \nof three simple processes: A, B, and C. Each has a single transition. The guards of all transitions are \nTRUE, thus only the process control point determines whether a transition is enabled or not. For in\u00adstance, \nthe transition labeled a is enabled if and only if process A is at control point Pa0. Figure 2 (top) \npresents the control-.ow graph of the multi-process system consisting of processes A, B, and C. The top \npart of the .gure includes all possible interleavings. Note that, in the initial control point (upper \nleft node) all transitions are enabled since all processes are in their initial control points. Once \na transition a is taken, a becomes disabled and only transitions b and c remain enabled. The middle and \nbottom control-.ow graphs in Figure 2 present two possible underapproximations of the orig\u00adinal control-.ow \ngraph, where only the marked transitions can be taken. 2.2 Partial and Full Expansions Although, in \ngeneral, it is necessary to consider all possible inter\u00adleavings to verify the correctness of a multi-process \nsystem, there has been a lot of work on reducing the number of interleavings that Figure 2: All interleavings \nof a multi-process system and two underapproximations, given as control-.ow graphs. are actually considered. \nThis section introduces some basic termi\u00adnology. For a given state of a multi-process system, we distinguish \nbe\u00adtween full expansion and partial expansion steps: A full expansion generates the next states for \nall enabled tran\u00adsitions.1  A partial expansion generates the next states for a subset of all enabled \ntransitions. We will consider only subsets that correspond to all enabled transitions of one process. \n In this paper, therefore, full expansions correspond to allowing all enabled processes to execute next \nand partial expansions corre\u00adspond to .xing one process that is to execute next each of the enabled \ntransitions of this process may be taken. The technique presented in this paper uses partial expansion \nsteps to de.ne underapproximations. Restricting the set of transitions that can be executed at each state \nde.nes a reduced model that dis\u00adallows some of the interleavings that are allowed in the original model. \nAnother technique based on partial and full expansions is partial-order reduction (POR) [15]. Unlike \nour approach, however, partial-order reductions build a reduced model which agrees with the original \nmodel on both property veri.cation and refutation. As mentioned earlier, the proposed UW approach is \nmuch more ag\u00adgressive than partial-order reduction in using partial expansions. In particular, each underapproximation \nis guaranteed to agree with the original model only on property refutation. 1Note that each process may \nhave (multiple) enabled transitions each of the transitions in the union of the enabled transitions \nof all processes may be executed next. 2.3 SAT and Proofs of Unsatis.ability We assume that the reader \nis familiar with Boolean satis.ability (SAT) and formulas in conjunctive normal form (CNF formulas). \nHere we mention several well-known terms and observations that we will use to justify the correctness \nof our method. 2.3.1 Underapproximation of CNF Formulas Let . be a CNF formula and let .' be a CNF formula \nobtained 1 n from . by adding to it additional clauses, i.e. .' = . . i=1(ci) where c1,...,cn are arbitrary \nclauses referring to . s variables. Then it is easy to see that . is unsatis.able . .' is unsatis.able \n(1) Notice that the other direction does not hold. That is, it is pos\u00adsible that . is satis.able while \n.' is not due to the additional con\u00adstraints c1,...,cn. .' can be thought of as an underapproximation \nof . (or . as a widening of .') since the set of satisfying interpre\u00adtations to .' is a subset of the \nsatisfying interpretations to ..If .' underapproximates ., every satisfying interpretation to the for\u00admer, \nis a satisfying interpretation to the latter, or, more formally, for every interpretation a it holds \nthat: a |= .'. a |= . (2) assuming the added clauses only refer to . s variables. 2.3.2 Resolution Proofs \nand Unsatis.able Cores A key notion in our discussion is the concept of resolution proofs. When a complete \nSAT solver2 concludes that there is no satisfying assignment to a given instance, its internal steps \nfor reaching this conclusion can be used to construct a resolution proof, i.e. a se\u00adquence of deduction \nsteps based on the rule a1 . .... an . \u00df b1 . .... bm . (\u00ac\u00df) a1 . .... an . b1 . .... bm where a1,...an,b1,...bm,\u00df \nare literals. Modern SAT solvers such as zChaff can output such a sequence that serves as an indepen\u00addently \ncheckable proof of unsatis.ability. The sequence of deduction steps can be represented as a directed \nacyclic graph (DAG), where the nodes are clauses and there is a directed edge from node c to c' iff the \nclause c participates in the ' deduction of c. Hence, every node is either a root or has two in\u00adcoming \nedges. The root nodes are clauses from the original for\u00admula. The internal nodes represent clauses that \nare deduced by the SAT solver at run-time (typically these are deduced when the SAT solver detects a \ncon.ict due to a bad assignment, and are therefore known as con.ict clauses). An unsatis.able core of \nan unsatis.able CNF formula . is a sub\u00adset of its clauses that is unsatis.able. Let S be the set of clauses \nin a given unsatis.able CNF formula . and let S be the set of root nodes in the DAG corresponding to \na resolution proof for the un\u00adsatis.ability of .. Since the conjunction of the clauses in the set S is \nunsatis.able by itself, S is an unsatis.able core of .. There are three observations regarding S that \nare important for our discussion: solver concludes that an instance is unsatis.able without us\u00ading all \nof its constraints. This is possible because some of the constraints may be redundant. 2A complete SAT \nsolver is a SAT solver that is guaranteed to .nd, in a .nite amount of time, a satisfying assignment \nif one exists.   2. By Equation 1, every CNF formula .', with a set of clauses S ' such that S . S \n' , is unsatis.able, and S is an unsatis.able core of .' as well. More formally: THEOREM 1. Let . and \n.' be two unsatis.able CNF for\u00admulas such that the set of clauses of . is contained in the set of clauses \nof .' . Then if S is an unsatis.able core of .,it is also an unsatis.able core of .' . PROOF. S is contained \nin the set of . s clauses and hence also in set of clauses of .'. Therefore, since S is unsatis.able, \nit is an unsatis.able core of .' . In the general case, the other direction of Theorem 1 does not hold. \nHowever: ' THEOREM 2. Let S be an unsatis.able core of a formula 1 ' n .' = . . i=1(ci), and assume that \nfor all 1 = i = n, ci .. S. ' Then . is unsatis.able and S is an unsatis.able core of .. ' PROOF. S is \ncontained in the set of clauses of . and is unsatis.able. Therefore, by Equation 1, . is unsatis.able \n' and S is an unsatis.able core of .. 3. The set S is not unique. In particular, there can be more than \none proof of unsatis.ability, each of which can result in a dif\u00adferent set of root nodes. It is an NP-hard \nproblem3 to .nd the minimum unsatis.able core, and indeed SAT solvers do not attempt to .nd such minimum \ncores. Rather, they produce a proof that re.ects the internal steps that led them to this conclusion. \nThese steps are determined by various heuristics that typically do not .nd the shortest proof or the \nminimum unsatis.able core.  2.4 SAT-Based Bounded Model Checking SAT-Based Bounded Model Checking (BMC) \nis a procedure that given a model M, a Linear-time Temporal Logic (LTL) formula ., and a bound k, checks \nwhether M |=k ., i.e, if all possible traces of M of length k satisfy . (cf. Figure 3). The procedure \ncheck constructs a propositional formula that is satis.able if and only if M |.=k .. The formula can \nbe expressed as the conjunction of two sub-formulas: bmcM,k whose satisfying assignments correspond \nto the pos\u00adsible execution traces of length k of model M;  violates. whose satisfying assignments correspond \nto the set of traces of length k that violate the property ..  Their conjunction represents the bounded \ntraces of length k of the model which violate the property. This formula is then given to a SAT solver: \n if the solver returns Satisfiable , it implies that the prop\u00aderty does not hold (in this case the satisfying \nassignment serves as a counterexample to the proposition M |= .);  if, on the other hand, it returns \nUnsatisfiable , we can conclude that M |=k ., although we cannot conclude that M |= . because there might \nbe a violation of length greater than k.  Thus, in the latter case, k is increased and the procedure \nis re\u00adpeated. BMC terminates either when an error is found, the Com\u00adpleteness Threshold CT [19, 12] is \nreached or, what is more com\u00admon, the problem becomes intractable. Therefore BMC is mainly used for falsi.cation \nrather than for veri.cation. 3To be more accurate, it is S2 p-complete problem, which is the same complexity \nas one alternation QBF. main (M,.) { k =0 repeat forever: if check (M, ., k) = counterexample : return \nproperty fails (M .|= .) k = k +1 } check (M, ., k) {if SAT(bmcM,k . violates.) = Satisfiable : return \ncounterexample else return valid } Figure 3: Bounded Model Checking algorithm. At each itera\u00adtion of \nthe loop of the main procedure, check is invoked to test if there exists a counterexample of length k. \n 3. BOUNDED MODEL CHECKING USING UNDERAPPROXIMATION-WIDENING 3.1 Underapproximation-Widening The Underapproximation-Widening \n(UW) procedure proves or disproves a property by considering a series of underapproxima\u00adtions of a given \nmodel. The procedure uw (see Figure 4) consists of a loop: at each step, an underapproximation of the \noriginal model is considered and the validity of the property on the underapprox\u00adimated model is checked \n(verify procedure) with two possible out\u00adcomes: a counterexample is found. Since the counterexample \nis a valid execution of the underapproximated model, it must also be a valid execution of the original \nmodel and therefore can be used to disprove the property under consideration, and the procedure terminates. \n no counterexample exists. It is then necessary to generate a proof that the underapproximated model \nsatis.es the prop\u00aderty (proof of procedure). Given such a proof, two cases are possible:  the proof \ndepends on the underapproximation itself, i.e., it does not apply to the original model. In this case, \nin\u00adformation from the proof can be used to determine a new underapproximated model (widen procedure), \nand the procedure is repeated.  the proof does not depend on the underapproximation itself, i.e., it \napplies to the original model. In this case, the proof can be used to show that the property holds on \nthe original model, and the procedure terminates.   The presented Underapproximation-Widening procedure \ncan be considered a dual approach to the Abstraction-Re.nement (AR) technique. However, while all model \ncheckers are able to pro\u00adduce a counterexample if the property is violated, most approaches do not produce \na formal proof that the model does not violate the property. This limits the applicability of the Underapproximation-Widening \nalgorithm to approaches that are able to produce such proofs. Hence, in this paper, we apply this algorithm \nto SAT-based Bounded Model Checking. uw (M , M0) { i=0 while true: if verify (Mi, .): proof = proof of \n(Mi, .); if is valid for (proof, M ): return VALID; else Mi+1 = widen (Mi, proof); i++; else return INVALID; \n} Figure 4: Underapproximation-Widening algorithm. The uw procedure receives as arguments a model M and \nan initial un\u00adderapproximation M0. At each iteration of the loop, an un\u00adderapproximated model is analyzed, \nwhich either violates the property, or can be proven to be correct. The proof is used to either terminate \nor widen the model. 3.2 A Framework for BMC using Underap\u00adproximation-Widening The Underapproximation-Widening \n(UW) procedure described above can be used in the framework of Bounded Model Checking to improve the \nveri.cation for a given bound. This section presents a general framework that can be instanti\u00adated with \nvarious methods to perform underapproximation. This framework is the basis for the procedure introduced \nin the next section that can be used to improve Bounded Model Checking of multi-process systems, by checking \nunderapproximated models with an increasing set of allowed interleavings of the given processes, starting \nfrom a single interleaving. Bounded Model Checking consists of a main loop which per\u00adforms the veri.cation \nfor an increasing bound k (procedure main in Figure 3), and a procedure that performs the veri.cation \nfor a given bound k (procedure check in Figure 3). The main loop is repeated until an error is detected \nor the problem becomes intractable. The Underapproximation-Widening procedure is used to perform each \nof the veri.cation steps for a given bound k more ef.ciently. In particular, for a given bound k, procedure \nmain uw calls the pro\u00adcedure check uw (in Figure 5), which tries to prove or disprove the property M \n|=k . by means of a .nite sequence of underapproxi\u00admations of the original model M . The set P in procedure \ncheck uw denotes the set of additional clauses that are used to de.ne an underapproximation. The set \nP is initialized with a .nite set of clauses that may depend on the model M and the bound k. The formula \nbmcM ,k is deter\u00admined as usual, however, the SAT solver is given the conjunction 1 of bmcM ,k . ci.P(ci), \nwhich encodes a subset of the bounded traces of the original model M ,and violates., which encodes the \nbounded traces that violate the property. If the SAT solver returns Satisfiable , the procedure returns \ncounterexample . Otherwise, based on previous work [2, 9], we derive an unsatis.able core S of the SAT \ninstance, i.e., a sub\u00adset of its clauses that are by themselves unsatis.able. The set of clauses in the \nunsatis.able core corresponds to the roots of the proof of unsatis.ability generated by the SAT solver. \nFrom this core, we compute ., the set of clauses of P that belong to the un\u00adsatis.able core of the formula. \nIf the set . is empty, the procedure returns valid ; otherwise one of the clauses belonging to . is removed \nfrom P: we call this process widening, because at the next main uw (M ,.) {k =0 repeat forever: if (check \nuw (M , ., k) = counterexample : return property fails (M .|= .) k = k +1 } check uw (M , ., k) {P = \ninitial clauses (M , k) repeat forever: 1 if SAT(bmcM ,k . ci.P(ci) . violates.)= Satisfiable : return \ncounterexample S = unsatisfiable core . = S n P if . = 0/: return valid Remove from P a clause in . \n } Figure 5: Underapproximation-Widening algorithm. The proce\u00addure check uw considers a set of underapproximations \nof model M until it .nds a counterexample or it is able to prove the prop\u00aderty without relying on the \nunderapproximation. Figure 6: .1 ....3 are sets of clauses of P that belong to the unsatis.able core \nat each step. The boxes denote the initial set of clauses in P. The widening step selects a single clause \nfrom each unsatis.able core (denoted by a black dot) and removes it from the set P. A proof in step i \ncannot rely on clauses removed from P in previous steps. iteration a formula that represents additional \nbehaviors is going to be considered. The procedure is repeated until one of the previous termination \nconditions becomes true. The progress of check uw is depicted schematically in Figure 6. This .gure shows \nthree successive iterations of widening and the clauses that are removed at each step (see caption). \n 3.3 Correctness and Termination PROPOSITION 3. If the procedure check uw(M ,.,k) returns, it returns \nvalid if and only if M |=k .. PROOF.(.) check uw returns valid only if for the current set 1 P, the formula \nbmcM ,k . ci.P(ci) . violates. is unsatis.able and none of the clauses in P belong to the unsatis.able \ncore of the for\u00admula. By Theorem 2, the formula bmcM ,k . violates. must be un\u00adsatis.able, and, therefore, \nM |=k .. (.)If M |=k . holds, the formula bmcM ,k . violates. must be 1 unsatis.able. By Equation 1, \nthe formula bmcM ,k . ci.P(ci) . violates. is also unsatis.able for any set of clauses P. Therefore, \nthe procedure cannot return counterexample , because this only occurs if, for some set P, the previous \nformula is satis.able. Since the procedure can only return counterexample or valid , the pro\u00adcedure must \nhave returned valid . PROPOSITION 4. The procedure check uw(M ,.,k) always ter\u00adminates. PROOF. Ineachiterationofitsmainloop,theprocedure \ncheck uw either returns counterexample if the formula is satis.able, re\u00adturns valid if none of the clauses \nin P belongs to the unsatis.\u00adable core of the formula, or removes one clause from P and repeats the loop. \nSince P is initialized with a .nite set of clauses and at each step the procedure either returns or removes \none clause from P, the pro\u00adcedure must terminate after a .nite number of iterations. Specif\u00adically, if \nthe set P is empty, the body of the loop corresponds to checking the property . on the original model \nM: if the property does not hold, the corresponding formula is satis.able and the pro\u00adcedure returns \ncounterexample ; otherwise the formula is un\u00adsatis.able and, since the set P is empty, the set . must \nbe empty as well and the procedure returns valid .  4. UNDERAPPROXIMATION-WIDENING FOR MULTI-PROCESS \nSYSTEMS This section describes how the Underapproximation-Widening loop can be used to improve Bounded \nModel Checking of a multi\u00adprocess system. In particular, we will de.ne a family of underap\u00adproximations \nobtained by limiting the allowed interleavings of the different processes. The work presented here represents \none possi\u00adble way of de.ning underapproximations: it is however of particu\u00adlar interest since Bounded \nModel Checking is often unable to cope well with concurrent systems. Other families of underapproxima\u00adtions \ncan be de.ned, for both a single or multiple processes, but they are beyond the scope of this paper. \n4.1 Modeling a Multi-Process System We formalize the model M of a multi-process system as follows: M \n= (S,I,P ,V ) (3) where S is a set of states;  I .S is a set of initial states;  P = {P1,...,PN }is \na set of processes.  V = {v1,...,vm}is a set of variables.  The set S is determined as follows. Given \nthe set of variables V , let D1,...,Dm be their domains. Then S = D1 \u00d7...\u00d7Dm, i.e., S is the cross-product \nof the domains of the variables, and represents all the possible states. Note that not every state in \nS is necessarily reachable from one of the initial states in I. Each process itself is a tuple: Pi = \n(Ti,pci,ni,(ati,1,...,ati,ni )) (4) where: Ti : S \u00d7S .{0,1}is the transition relation for process i, \ni.e., ' Ti(s,s ) holds if and only if s ' is a successor of s obtained by executing a transition of process \nPi; pci .V is a special variable called the program counter whose domain is the set of control points \nin process Pi;  ni .N is the number of control points in process Pi;  ati,j : S .{0,1}is a predicate \nover the set of states that holds for a state s if and only if process Pi is at control point j in state \ns, i.e., pci has the value j in s. In this model, we do not discriminate between local and global variables; \nlocal variables are those variables that are syntactically accessible only by one process. Such distinction \nis not necessary for our approach, and a model that makes such a distinction can always be translated \ninto a model as we de.ned it by variable re\u00adnaming. Moreover, we do not require for the transition relations \nTi to be total, i.e., a state s does not need to have a successor. How\u00adever, we assume that processes \nhave control points: in the case of models of concurrent software, control points can correspond to the \nnodes of a control-.ow graph. 4.2 Bounded Model Checking for Multi-Process Systems In order to perform \nBounded Model Checking, we need to de\u00ad.ne the formula bmcM ,k .violates. that encodes all possible coun\u00adterexamples \nof length k for model M . For simple invariant proper\u00adties, the formula has the form: I(s0) .T (s0,s1) \n.....T (sk-1,sk) .F(sk) (5) where I(s0) enforces the .rst state to be one of the initial states;  T \n(sh,sh+1) constraints consecutive states to be related by the transition relation T ;  F(sk) is derived \nfrom the property being checked and asserts that the .nal state violates the property.  The satisfying \nassignments to Formula (5) are those valid bounded traces of model M i.e., the .rst state of the trace \nis an initial state and each pair of successive states is related by the transition relation that violate \nthe property. A similar formula can be constructed in order to check a sys\u00adtem with respect to an LTL \nproperty: F(sk) is then replaced by a more complex formula [7], which may also involve the intermedi\u00adate \nstates. The construction introduced in this section is concerned with limiting the traces of the model, \nand is applicable to the veri\u00ad.cation of LTL formulas as well. The model as described in Section 4.1 \ndoes not directly de.ne the transition relation T for the whole model, but only the transition relations \nTi for each of the processes. It is possible to compute the transition relation T from the transition \nrelations Ti in the following way: ' ' T (s,s )= .1 =i =N : Ti(s,s ) N V ' =(ps = i .Ti(s,s )) (6) i=1 \nwhere ps is a free variable that can assume any value between 1 and N. ' The meaning of this formula \nis that s is a successor of s,ifthere ' exists a value for ps such that s is a successor of s when process \nPps is executed. The variable ps, called the process selector, indicates which process is going to execute \nnext. In Equation (6), since there are no constraints on the values ps can assume, every interleaving \nis possible. In order to build the transition relation for a model that only contains a subset of the \ninterleavings, we place restrictions on the values that the variable ps can assume. This will be explained \nin the next two subsections. 4.3 Introducing the Predicates We want to de.ne underapproximations by \nlimiting the amount of interleavings in a multi-process system. To do so, we will use the concepts of \npartial and full expansion introduced in Section 2.2. At each state, we have two possibilities: perform \na full expansion step;  perform a partial expansion step that corresponds to the tran\u00adsitions of a single \nprocess4.  Therefore, for each state, we need to determine what kind of step we want to perform. This \ninformation will de.ne an underapprox\u00adimation of the original model: for instance, if for every state \nwe perform a full expansion, we obtain the original model. However, a simple mapping from each state \nto the particular type of step that we need to perform would be too expensive to manage since there is \na large number of potentially reachable states. Instead, we will use only part of the information from \nthe current state to make the decision: in particular, we will only consider the current control points \nof the different processes. However, if the system is made of n processes with m control points each, \nthere are still mn possible combinations: this is clearly not going to scale to large systems. Therefore, \ninstead of considering all combinations, we will use the following strategy: each control point is associated \nwith a predicate: the predi\u00adcate being true represents the fact that the process it belongs to cannot \nbe used for a partial expansion;  for any given state, if none of the control points can be used for \na partial expansion, i.e., all predicates corresponding to the current control points of each process \nare true, then a full expansion is performed;  if at least one of the processes can be used for a partial \nex\u00adpansion, i.e., the predicate associated with its current control point is false, then a partial expansion \nis performed that ex\u00adpands the transitions of the .rst process according to some prede.ned .xed order \nthat can perform a partial expansion.  Intuitively, the predicate associated with a given control point \nbeing true means that the statements of the corresponding pro\u00adcess at that speci.c location should be \ninterleaved with other pro\u00adcesses. This allows encoding an underapproximation using only m \u00d7n boolean \npredicates. Formally, given a model M , we introduce a set of predicates pi, j for every i and j such \nthat 1 =i =N and 1 = j =ni. Predicate pi, j is associated with control point j of process Pi. Let s assume \nthat in state s each process Pi is at some control location j. Let P (s)be the set of processes that \nat state s are enabled5 and their corresponding predicate pi, j is FALSE. The successors of state s are \nlimited as follows: if P (s)is not empty, then only one of the processes from P (s)is expanded, i.e. \na partial expansion is performed. Let the transition relation of the underapproximated model be T ' : \n''' then .s ' T (s,s )=Ti(s,s )must hold for some i such that Pi .P (s). 4A partial expansion can be \nde.ned to expand any subset of the enabled transitions, however, for simplicity, we chose to consider \nonly partial expansions that expand all enabled transitions of a sin\u00adgle process. 5A process is enabled \nin s, if it has at least one successor state for s. ''' otherwise, P (s) is empty and .s ' T (s,s )=T \n(s, s ) must hold, i.e., all enabled transitions at s may execute. As described in Section 3, the underapproximation \nis determined by a set of clauses P. In our formulation of UW for multi-process systems, the initial \nvalue for the set P will contain a negative unit clause (\u00acpi, j) for each of the predicates corresponding \nto control points in model M . When a clause is removed from the set P, the corresponding predicate is \nleft unconstrained, i.e., it can be either TRUE or FALSE. It can be shown that the formula we are constructing \nis equiv\u00adalent to the formula corresponding to the original model M if all predicates are left unconstrained. \nIntuitively, if all predicates are unconstrained, it is possible to perform both a partial and a full \nex\u00adpansion: since the original model always performs a full expansion and the set of next states corresponding \nto a partial expansion is a subset of the ones corresponding to a full expansion, they allow the same \nbehaviors. 4.4 The Transition Relation of the Underap\u00adproximated Model '' We now formalize the transition \nrelation T . We construct T in a way that enables us to control the amount of interleavings it represents, \nby limiting the values the process selector variable ps can assume. The strategy described in the previous \nsection can be formulated by adding a predicate valid(s, ps)to the formula for the transition relation. \nThis predicate must be true for all values of ps if, at state s, all enabled processes are at control \npoints whose predicates are true. Otherwise, it must be true only for a single value of ps, such that \nPps is at a control point whose predicate is false and at least ' one transition of Pps is enabled. Therefore, \nthe formula for T , presented below, depends on whether the predicates pi, j are true or false. We .rst \nde.ne a predicate enabledi : S .{0,1}over the states such that enabledi(s)is true if and only if there \nexists a transition ' in Ti from state s to an arbitrary state s : '' enabledi(s)=.s .S : Ti(s,s ) (7) \nWe then de.ne partiali(s)as: partiali(s)= enabledi(s).(.1 = j =ni : (ati, j .\u00acpi, j)) .. ni A .. = enabledi(s). \n(ati, j .\u00acpi, j) (8) j=1 which is true if process Pi is enabled and at a control point whose predicate \nis false, i.e. partiali(s).Pi .P (s). If there is only one process in P (s), then it is suf.cient to \nas\u00adsert that partialps(s) holds, i.e., that process Pps, whose transi\u00adtions are going to be taken, can \nbe partially expanded (the corre\u00adsponding pps, j is false). However, this is not suf.cient for a state \ns where multiple enabled processes are at control points whose pred\u00adicates are false. Therefore, we introduce \nan additional predicate .rst partiali(s)de.ned as follows: .rst partiali(s)= partiali(s).(.1 =i ' < i \n: \u00acpartiali'(s)) i-1 A = partiali(s).\u00acpartiali'(s)(9) i' =1 which is guaranteed to be true for at most \none of the processes. Finally, we need to discriminate between the case where, at state s, there exists \nat least one enabled process that can be partially expanded, and the case where all enabled processes \nmust be ex\u00adpanded. Therefore, we de.ne: exists partial(s)= .1 =i =N : partiali(s) N V = partiali(s) (10) \ni=1 We can now write the predicate that constrains ps as: valid(s,ps)=(exists partial(s)..rst partialps(s)) \n(11) Note that, if exists partial(s)holds then valid(s,ps)holds for ex\u00adactly one value of ps. On the \nother hand, if exists partial(s)does not hold, then valid(s,ps)is true for every value of ps. The latter \nis exactly the case where full expansion is performed. ' The formula for the transition relation T '(s,s \n)can be expressed as: N V '' ' T (s,s )=.ps valid(s,ps). (ps =i .Ti(s,s )) (12) i=1 It is now possible \nto use the expression obtained for the transition relation to write the formula that expresses all bounded \ntraces of the reduced model: ' I(s0).T (s0,s1).....T '(sk-1,sk) (13) Notice that this formula, if the \npredicates are left unconstrained, corresponds to all the bounded traces of model M . This formula will \nbe conjoined during the execution of procedure check uw (cf. Section 3) with the clauses in P. Initially, \nthe set P will contain a negative unit clause for each of the predicates corresponding to the control \npoints of M . The clauses in P constrain these predicates to false, therefore limiting the amount of \nallowed interleavings. EXAMPLE 2. Let us consider again the system from Figure 1 where we want to check \nthat the invariant \u00ac(x =2)holds. We will describe how the Underapproximation-Widening algorithm of Fig\u00adure \n5 proceeds for the case k =3. Initially P contains negative unit clauses for each predicate pi,j for \ni .{A,B,C}and j .{Pa0,Pa1,Pb0,Pb1,Pc0,Pc1}, therefore con\u00adstraining all predicates to be false. As a \nresult, at every state, only the transitions of the enabled process with the smallest index are expanded \n(where we assume A < B <C). For example, only transition a is expanded from the initial state. The control-.ow \ngraph in the middle of Figure 2 shows the transitions taken at each of the reachable states. This iteration \ndid not reveal any counterexamples. The proce\u00addure will then analyze the unsatis.able core for the generated \nfor\u00admula and determine if any of the negative unit clauses we intro\u00adduced was used by the proof of unsatis.ability. \nLet us assume that the clause \u00acpA,Pa0 was used by the proof, and therefore remove it from P and continue \nto the next iteration. This means that pA,Pa0 may now be either TRUE or FALSE, while all other predicates \nmust be FALSE. The control-.ow graph at the bottom of Figure 2 shows which transitions are taken in the \nnext iteration. This is a superset of the ones taken previously. For example, in the initial state, transition \na is expanded when pA,Pa0 is FALSE, while transition b is expanded when pA,Pa0 is TRUE, since, in the \nlatter case, B is the process with the smallest index satisfying the conditions for partial expansion. \nIn the second iteration a counterexample is found: if transition b is executed before transition a, the \n.nal value of x will be 2, which is a violation of the invariant we were checking. At this point a counterexample \nis generated and the procedure terminates without having to ever consider all interleavings in the original \nmodel.  5. EXPERIMENTAL RESULTS In this section, we compare the Underapproximation-Widening loop against \nBounded Model Checking with full interleaving. Given a model and a property, Bounded Model Checking produces \na CNF formula which is satis.able if and only if there is a violation of the property in the given model. \nThe proposed Underapproximation-Widening loop is also based on Bounded Model Checking, but in\u00adstead of \nverifying the model directly as classical Bounded Model Checking would do, it veri.es a series of underapproximated \nmod\u00adels, increasingly including more behavior. We have implemented UW using NuSMV and the SAT solver \nzChaff. We use NuSMV to generate a CNF for the model M , which is parameterized on the values of the \npredicates introduced in Section 4.3. We modify the generated CNF by adding the set of negative unit \nclauses in P. We use zChaff ability to produce an unsatis.able core to decide either termination or which \nclause to remove from the set P. This approach, even if it might require an additional number of iterations, \ncan be advantageous in the following two cases: A counter-example is found that it is present in an \nheavily un\u00adderapproximated model. In this case, the SAT solver is given a much simpler system and it \nis possible to .nd a satisfying assignment more quickly.  No counter-example is found, i.e., the formula \nis unsatis.\u00adable, and, even if we analyzed a restricted model, the proof of unsatis.ability does not \ndepend on the underapproxima\u00adtion. Again, even if this may occur after a few iterations, the reduced \nmodel veri.ed at each iteration can be much simpler than the original model, and therefore require less \ntime and resources.  Both of these cases appear in the examples presented below. Table 1 contains the \nresults obtained in the veri.cation of a reach\u00adability property for a model of a leader election protocol. \nWe can identify three different behaviors: BMC is faster for small values of k For small values of k \n(5 or less), the UW loop additional overhead is too high to compete with BMC. The formulas generated \nfor small values of k are simple enough for the SAT solver to prove their unsatis.ability directly. UW \ncan prove the property using a much simpler model For intermediate values of k (between 6 and 8), the \nUW loop is able to prove the property removing the unit clauses cor\u00adresponding to only a few control \npoints (at most 12 out of 30) and therefore it performs much better than BMC. Even if the number of iteration \nincreases, the number of iteration is equal to the number of clauses that have been removed from P, the \nmodels with a limited set of interleavings are much simpler problems to solve. Table 1: Comparison of \nthe running time of BMC and UW on a reachability property of a leader election protocol. The .rst column \nrepresents the limit k; the second column reports the result of the veri.cation; the last column reports \nthe number of iterations needed to prove or disprove the property. k Result BMC UW iter 0 valid 1.63s \n1.99s 0 1 valid 1.65s 3.53s 1 2 valid 1.84s 4.63s 1 3 valid 2.28s 7.50s 2 4 valid 5.26s 13.75s 3 5 valid \n18.87s 23.58s 4 6 valid 103.27s 55.10s 6 7 valid 191.69s 120.54s 12 8 valid 433.84s 144.83s 10 9 invalid \n57.79s 11.10s 0 10 invalid 151.05s 11.07s 0 11 invalid 40.48s 21.27s 0 12 invalid 41.84s 22.18s 0 UW \ncan produce a counterexample very quickly For k greater or equal to 9, the property is violated: UW is \nable to .nd a counterexample without removing any of the clauses from P. The CNF generated by UW is much \nsimpler than the one generated by BMC, and the SAT solver is able to .nd a counterexample much faster. \nIn conclusion, one of the main advantages of this technique is the ability to detect property violations \nwithout having to look at the full model, but using a series of underapproximations. It is also possible \nto .nd a restricted model that is suf.cient to prove the property. However, if the number of iterations \nnecessary to reach that result is too large or the restricted model is not simpler than the original \none, the overhead involved in additional iterations might become too large to make the procedure advantageous. \n 6. CONCLUSIONS AND FUTURE WORK We presented a new ef.cient procedure for the veri.cation of multi-process \nsystems based on an Underapproximation-Widening loop. While a lot of successful work on automating Abstraction-Re.nement \nloops for model checking has recently been done, the presented approach is, to the best our knowledge, \nthe .rst fully automated approach based on underapproximations and widening. The procedure is mainly \neffective in discovering bugs due to the nature of BMC. The UW approach is not limited to the veri.cation \nof multi\u00adprocess systems. The context of multi-process system veri.cation has been chosen as it is straightforward \nto introduce clauses that limit the state space. Since our algorithm relies on the ability of SAT solvers \nto gener\u00adate proofs of unsatis.ability, it is incorporated in a Bounded Model Checking framework, which, \nin its classical form, is incomplete. As future work, we plan to extend this framework to produce a complete \nBMC procedure, possibly based on existing work such as McMillan s work on interpolation and SAT-based \nmodel checking [23], the work of Sheeran et al. on k-induction [27], and the work of Kroening et al. \non .nding the Completeness Threshold [19, 12]. The procedure, as presented in the context of Bounded \nModel Checking, tries to prove or disprove the property for traces of a given length k, and then proceeds \nto analyze longer traces. Bounded Model Checking is therefore very effective in detecting shallow counterexamples. \nHowever, since the UW procedure analyzes dif\u00adferent models of increasing complexity for the same length \nk,it is possible to explore the generated models in a different order. We plan to investigate this idea. \nAnother topic for future research are heuristics to update the set of clauses in P to be used at the \nnext iteration: in the presented work, when multiple clauses from the set P belong to the unsat\u00adis.able \ncore generated by the SAT solver, no indication is given on how to choose the clause to be removed. Moreover \nit is not strictly necessary to remove a single clause at each step, as long as the set of clauses removed \nfrom the initial value of P are suf.cient to eliminate all the previous proofs. We intend to investigate \nsuch heuristics as well as alternative ways of updating the set P at each iteration. There are similarities \nbetween the way underapproximations are built by the presented algorithm and the way partial-order reduction \napproaches construct a reduced model. Partial-order reduction ap\u00adproaches exploit static analysis as \nwell as syntactic information to determine a set of control points at which it is suf.cient to perform \npartial expansions instead of full expansions. These techniques will perform a partial expansion only \nwhen it is guaranteed that the va\u00adlidity of the property is preserved. While our approach is based on \npartial expansions as well, a main difference is that the reduced models that the proposed approach considers \nare not known a priori to preserve a property. However, partial order algorithms that de\u00adtermine partially \nand fully expanded control points statically [21], may be exploited to improve our procedure, e.g. its \ntermination conditions. Exploiting partial order algorithms in the UW frame\u00adwork will be studied in future \nwork. 7. REFERENCES [1] R. Alur, R. Brayton, T. A. Henzinger, S. Quadeer, and S. Rajamani. Partial-order \nreduction in symbolic state space exploration. In O. Grumberg, editor, Proc. of the 9th conference on \nComputer-Aided Veri.cation (CAV 97), volume 1254 of LNCS, pages 340 351, Haifa, June 1997. [2] N. Amla \nand K. McMillan. Automatic abstraction without counterexamples. In H. Garavel and J. Hatcliff, editors, \n9th Intl. Conf. on Tools And Algorithms For The Construction And Analysis Of Systems (TACAS 03), volume \n2619 of Lect. Notes in Comp. Sci., 2003. [3] F. Balarin and A. Sangiovanni-Vinventelli. An iterative \napproah to language containment. In C. Courcoubetis, editor, Proc. 5th Intl. Conference on Computer Aided \nVeri.cation (CAV 94), volume 697 of Lect. Notes in Comp. Sci., pages 29 40. Springer-Verlag, 1993. [4] \nS. Barner, D. Geist, and A. Gringauze. Symbolic localization reduction with reconstruction layering and \nbacktr acking. In Proc. of Conference on Computer-Aided Veri.cation (CAV), Copenhagen, Denmark, July \n2002. [5] S. Barner and O. Grumberg. Combining symmetry reduction and upper-approximation for symbolic \nmodel checking. In 14th International Conference on Computer Aided Veri.cation (CAV 02), volume 2404 \nof LNCS, Copenhagen, Denmark, July 2002. [6] A. Biere, A. Cimatti, E. Clarke, O. Strichman, and Y. Zue. \nBounded Model Checking, volume 58 of Advances in computers. Academic Press, 2003. [7] A. Biere, A. Cimatti, \nE. M. Clarke, M. Fujita, , and Y. Zhu. Symbolic model checking using SAT procedures instead of BDDs. \nIn Design Automation Conference (DAC 99), 1999. [8] A. Biere, A. Cimatti, E. M. Clarke, and Y. Yhu. Symbolic \nmodel checking without BDDs. In Tools and Algorithms for Construction and Analysis of Systems, pages \n193 207, 1999. [9] P. Chauhan, E. Clarke, J. Kukula, S. Sapra, H. Veith, and D. Wang. Automated abstraction \nre.nement for model checking large state spaces using sat based con.ict analysis. In A. O Leary, editor, \nFourth International Conference on Formal Methods in Computer-Aided Design (FMCAD 02), lncs, Portland, \nOregon, Nov 2002. [10] E. Clarke, O. Grumberg, S. Jha, Y. Lu, and H. Veith. Counterexample-guided abstraction \nre.nement. J. ACM, 50(5):752 794, 2003. [11] E. Clarke, A. Gupta, J. Kukula, and O. Strichman. SAT based \nabstraction -re.nement using ILP and machine learning techniques. In E. Brinksma and K. Larsen, editors, \nProc. 14th Intl. Conference on Computer Aided Veri.cation (CAV 02), volume 2404 of LNCS, pages 265 279, \nCopenhagen, Denmark, July 2002. Springer-Verlag. [12] E. Clarke, D. Kroening, J. Ouaknine, and O. Strichman. \nCompleteness and complexity of bounded model checking. In Proc. 5th Intl. Conference on Veri.cation, \nModel Checking and Abstract Interpretation (VMCAI 04), volume 2937 of Lect. Notes in Comp. Sci., pages \n85 96, Venice, Italy, Jan 2004. [13] E. M. Clarke, O. Grumberg, S. Jha, Y. Lu, and H. Veith. Counterexample-guided \nabstraction re.nement. In E. A. Emerson and A. P. Sistla, editors, Proc. 12th Intl. Conference on Computer \nAided Veri.cation (CAV 00), volume 1855 of Lect. Notes in Comp. Sci. Springer-Verlag, 2000. [14] E. W. \nDijkstra. A discipline of programming. Prentice Hall, 1976. [15] E.M.Clarke, O.Grumberg, and D.Peled. \nModel Checking. MIT Press, Cambridge, MA, 1999. [16] M. Glusman and S. Katz. A mechanized proof environment \nfor the convenient computations proof method. Formal Methods in System Design, 23(2):115 142, 2003. \n[17] P. Godefroid and P. Wolper. Using partial orders for the ef.cient veri.cation of deadlock freedom \nand safety properties. In Workshop on Computer-Aided Veri.cation (CAV 91), volume 575 of LNCS, pages \n332 342, 1991. [18] S. Katz and D. Peled. Veri.cation of distributed programs using representative interleaving \nsequences. Distributed Computing, 6(2):107 120, September 1992. [19] D. Kroening and O. Strichman. Ef.cient \ncomputation of recurrence diameters. In Proc. 4th Intl. Conference on Veri.cation, Model Checking, and \nAbstract Interpretation (VMCAI 03), volume 2575 of Lecture Notes in Computer Science, pages 298 309, \nNYU, New-York, January 2003. Springer Verlag. [20] R. Kurshan. Computer aided veri.cation of coordinating \nprocesses. Princeton University Press, 1994. [21] R. Kurshan, V. Levin, M. Minea, and D. P. H. Yenig\u00a8un. \nCombining software and hardware veri.cation techniques. Formal Methos in System Design, 21(3):251 280, \n2002. [22] J. Lind-Nielsen and H. Andersan. Stepwise CTL model checking of state/event systems. In N. \nHalbwachs and D. Peled, editors, Proc. 11th Intl. Conference on Computer Aided Veri.cation (CAV 99), \nvolume 1633 of Lect. Notes in Comp. Sci., pages 316 327. Springer-Verlag, 1999. [23] K. L. McMillan. \nInterpolation and sat-based model checking. In J. Warren A. Hunt and F. Somenzi, editors, cav03, Lect. \nNotes in Comp. Sci., Jul 2003. [24] D. Peled. Combining partial order reductions with on-the-.y model-checking. \nJournal of Formal Methods in Systems Design, 8 (1):39 64, 1996. also appeared in 6th International Conference \non Computer Aided Veri.cation 1994, Stanford CA, USA, LNCS 818, Springer-Verlag, 377-390. [25] K. Ravi \nand F. Somenzi. High-density reachability analysis. In Proc. Intl. Conf. on Computer-Aided Design, pages \n154 158, November 1995. [26] K. Ravi and F. Somenzi. Hints to accelerate symbolic traversal. In CHARME \n99, LNCS 1703, pages 250 264. Springer-Verlag, 1999. [27] M. Sheeran, S. Singh, and G. Stalmarck. Checking \nsafety properties using induction and a sat-solver. In Hunt and Johnson, editors, Proc. Int. Conf. on \nFormal Methods in Computer-Aided Design (FMCAD 2000), 2000. [28] A. Valmari. A stubborn attack on state \nexplosion. In Workshop on Computer-Aided Veri.cation (CAV 90), volume 531 of LNCS, New Brunswick, 1990. \n  \n\t\t\t", "proc_id": "1040305", "abstract": "This paper presents a procedure for the verification of multi-process systems based on considering a series of underapproximated models. The procedure checks models with an increasing set of allowed interleavings of the given set of processes, starting from a single interleaving. The procedure relies on SAT solvers' ability to produce proofs of unsatisfiability: from these proofs it derives information that guides the process of adding interleavings on the one hand, and determines termination on the other. The presented approach is integrated in a SAT-based Bounded Model Checking (BMC) framework. Thus, a BMC formulation of a multi-process system is introduced, which allows controlling which interleavings are considered. Preliminary experimental results demonstrate the practical impact of the presented method.", "authors": [{"name": "Orna Grumberg", "author_profile_id": "81100493474", "affiliation": "Technion Haifa, Israel", "person_id": "PP39045484", "email_address": "", "orcid_id": ""}, {"name": "Flavio Lerda", "author_profile_id": "81100159996", "affiliation": "Carnegie Mellon, Pittsburgh, PA", "person_id": "P336531", "email_address": "", "orcid_id": ""}, {"name": "Ofer Strichman", "author_profile_id": "81100140389", "affiliation": "Technion Haifa, Israel", "person_id": "PP31029090", "email_address": "", "orcid_id": ""}, {"name": "Michael Theobald", "author_profile_id": "81100251862", "affiliation": "Carnegie Mellon, Pittsburgh, PA", "person_id": "PP43118038", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1040305.1040316", "year": "2005", "article_id": "1040316", "conference": "POPL", "title": "Proof-guided underapproximation-widening for multi-process systems", "url": "http://dl.acm.org/citation.cfm?id=1040316"}