{"article_publication_date": "01-12-2005", "fulltext": "\n From Sequential Programs to Multi-Tier Applications by Program Transformation Matthias Neubauer Peter \nThiemann Institut f\u00a8ur Informatik, Universit\u00a8at Freiburg, Germany {neubauer,thiemann}@informatik.uni-freiburg.de \nABSTRACT Modern applications are designed in multiple tiers to sep\u00adarate concerns. Since each tier may \nrun at a separate lo\u00adcation, middleware is required to mediate access between tiers. However, introducing \nthis middleware is tiresome and error-prone. We propose a multi-tier calculus and a splitting transfor\u00admation \nto address this problem. The multi-tier calculus serves as a sequential core programming language for \ncon\u00adstructing a multi-tier application. The application can be developed in the sequential setting. Splitting \nextracts one process per tier from the sequential program such that their concurrent execution behaves \nlike the original program. The splitting transformation starts from an assignment of primitive operations \nto tiers. A program analysis determines communication requirements and inserts remote procedure calls. \nThe next transformation step performs resource pool\u00ading: it optimizes the communication behavior by transform\u00ading \nsequences of remote procedure calls to a stream-based protocol. The .nal transformation step splits the \nresulting program into separate communicating processes. The multi-tier calculus is also applicable to \nthe construc\u00adtion of interactive Web applications. It facilitates their de\u00advelopment by providing a uniform \nprogramming framework for client-side and server-side programming.  Categories and Subject Descriptors \nD.1.3 [PROGRAMMING TECHNIQUES]: Concurrent Programming Distributed Programming; D.1.2 [PROGRAMMING TECHNIQUES]: \nAutomatic Programming Program Transformation; F.3.2 [LOGICS AND MEANINGS OF PROGRAMS]: Semantics of Programming \nLanguages Operational semantics General Terms Design, Languages, Theory Permission to make digital or \nhard copies of all or part of this work for personal or classroom use is granted without fee provided \nthat copies are not made or distributed for pro.t or commercial advantage and that copies bear this notice \nand the full citation on the .rst page. To copy otherwise, to republish, to post on servers or to redistribute \nto lists, requires prior speci.c permission and/or a fee. POPL 05, January 12 14, 2005, Long Beach, California, \nUSA. Copyright 2005 ACM 1-58113-830-X/05/0001 ...$5.00.  Keywords Type Systems, Concurrency, Application \nPartioning 1. INTRODUCTION Building a modern application is no longer a taskof pro\u00adgramming an isolated \nmachine. In many cases, the applica\u00adtion has a distributed multi-tier architecture. It accesses data \non one or more database servers, its business logic runs on an application server, the presentation logic \nis de\u00adployed on a web server, and the user interface runs on a web browser. Software for each tier is \ndeveloped separately with application-speci.c communication interfaces between the tiers. The designers \ncreate these interfaces and the pro\u00adgrammers implement them using middleware. Hence, on top of their \nusual coding and testing activity, programmers are also burdened with the quirks of distribution: testing \nbecomes more di.cult and .aws in middleware code often created by third-party programmers are potentially \nan ad\u00additional source of errors in the .nal application. The programmer s taskcan be alleviated by a \nprogram\u00adming frameworkthat automatically prepares the program for the physical distribution. Thus, the \nmain development activity takes place in the simpler, non-distributed setting. Only integration testing \nand performance testing (and, of course, .nal deployment of the application) involves the dis\u00adtributed \nproduction setting. The present paper proposes such a programming frame\u00adworkconsisting of a calculus, \na static analysis that per\u00adforms an assignment of code to locations, and a range of program transformations \nthat automatically insert commu\u00adnication primitives, perform resource pooling, and .nally split the program \ninto separate processes to run at separate locations. Locations in our sense are used as an abstraction \nover the di.erent physical or logical places where tiers of the .nal application are supposed to reside. \nAs a starting point, we assume that the application con\u00adsists of sequential programs that run concurrently \non a sin\u00adgle server. Each program runs independently on behalf of a particular client. The programs do \nnot communicate explic\u00aditly among themselves but they access and modify common resources on the server. \nThe taskof the transformation is thus to split a sequential program into pieces that run inde\u00adpendently \nfrom each other on di.erent hosts and to equip them with communication primitives so that the sequential \nsemantics of the original program is preserved. Each operation used in the sequential program carries \nan annotation that indicates whether the operation is location independent. A location independent operation \nmust not have side e.ects and it must not depend on data stored at a particular location. For example, \nany operation on a primi\u00adtive datatypes is location independent whereas accessing or modifying a reference \nis not. Location dependent operations carry a location annotation that indicates where the oper\u00adation \ncan safely take place. The interplay of all location annotations drives the static analysis of the program. \nOp\u00aderations on di.erent locations must not interfere with each other. For example, database queries must \nrun on the appli\u00adcation server because the database connection is a reference that does not make sense \noutside of the application server. In contrast, GUI operations run on the client because the GUI objects \nare not present on the server. In principle, the result of the the splitting transforma\u00adtion is directly \napplicable to annotated programs but it would lead to programs sprinkled with short communica\u00adtions. \nSince repeated connection establishment is expensive, a separate program transformation performs resource \npool\u00ading by reusing established connections between locations. We describe the overall algorithm abstractly \nin terms of transformation steps in a program calculus. The calculus is based on the lambda calculus \nequipped with synchronous communication primitives. It is inspired by Gay and Hole s calculus of session \ntypes [2]. Their calculus is a simply typed variant of the p-calculus with subtyping and models asyn\u00adchronous \ncommunication via ports and channels. Channels transmit heterogeneous data as prescribed by a session \ntype. Unlike Gay and Hole, we have chosen a lambda calculus because it is trivial to embed sequential \nprograms in it. In particular, our variant is based on a simply-typed, applied call-by-value lambda calculus \nin A-normal form[1]. Com\u00admunication in our calculus is stream-based (ports and chan\u00adnels) with similar \noperations as in the calculus of session types. A-normal form simpli.es the de.nition of the static and \ndynamic semantics and has been used as an intermedi\u00adate language in several compilers. The result of \nthe transformation is a program with ex\u00adplicit uses of typed communication primitives analogous to the \nsocket-based communication paradigm [15]. An imple\u00admentation would map the communication primitives to \nthe communication architecture provided by the chosen middle\u00adware. Alternatively, a direct implementation \nin terms of the socket API is possible. A web application is a special case of a multi-tier appli\u00adcation \nwhere one or more tiers run on a web browser. Our frameworkis applicable to this case given a suitable \nme\u00addiator that implements channels on top of HTTP. In this special case, the splitting transformation \nyields a client-side slice and a server-side slice of the application. The client s slice may be implemented \nby applets and the server s slice with an arbitrary server-side scripting technology. The main contribution \nof the paper is the partitioning algorithm. Its presentation consists of three steps: We specify a location \nanalysis that infers required com\u00admunications between abstract locations. The analysis is stated in terms \nof an annotated simple type system with subtyping. It is proved correct with respect to a location-aware \noperational semantics using a type\u00adsoundness argument.  We present a suite of typed transformation rules \nthat merge several communications between identical part\u00adners into larger sections with stream-based \ncommuni\u00ad  let rec show_topic (db, tid, tpc) = let stmt = string_append_4 (\"SELECT * FROM messages\", \n\" WHERE tid= \", tid, \" \") in let msgs = sql_exec (db, stmt) in let hdr = string_append (\"Topic \", tpc) \nin let frame = gui_create_frame (hdr) in let _ = show_rows (db, frame, msgs) in gui_show_frame (frame) \nand show_rows (db, frame, msgs) = let b = sql_cursor_has_more_elements (db, msgs) in if b then let row \n= sql_cursor_get_next_row (db, msgs) in let cts = sql_cursor_get_column (db, row, \"contents\") in let \nlab = gui_create_label (cts) in let _ = gui_frame_add (frame, lab) in show_rows (frame, msgs) else () \nin ... Figure 1: Original sequential program cation. The rules are proven correct with respect to the \nlocation-aware semantics extended with synchronous communication. A splitting transformation .nally extracts \nconcurrently running processes from the transformed expression. This transformation is also proved correct. \nThe target calculus is a language with channel-based communica\u00adtion. Its type system is a novel variant \nof the system of session types [2]. In the rest of the paper, we .rst motivate our suite of transformations \nwith an excerpt of a client-server applica\u00adtion in Section 2. Section 3 introduces the source calculus, \na simply-typed, linearized, call-by-value lambda calculus. Section 4 develops the annotated type system \nthat speci.es location analysis for the source calculus. It formalizes its static and dynamic semantics \nand proves type soundness. Section 5 introduces the multi-tier calculus which extends the source calculus \nwith explicit channel-based communica\u00adtion primitives. Section 6 de.nes the transformation steps to implement \nconnection pooling and Section 7 presents the splitting transformation. Section 8 discusses related work, \nand Section 9 concludes.  2. A TINY MULTI-TIER APPLICATION This section introduces an example application, \na message board, and shows and discusses the results of the location analysis and the splitting transformation. \nFor concreteness, the example is programmed in Ocaml [9] and is easy to trans\u00ad late to the formal calculus \nintroduced in Section 3. A message board application enables its users to view and post messages attached \nto certain topics on a centrally ac\u00adcessible virtual blackboard. A message either starts a new topic \nor it responds to a message in an existing topic. The application draws on at least two kinds of resources \nthat usually reside in di.erent physical locations: a central database server and a windowing environment \nhandling user let rec show_topic (db[S] , tid[S] , tpc[S] )= let stmt = string_append_4[S] (\"SELECT * \nFROM messages\", \" WHERE tid= \", tid, \" \") in let msgs = sql_exec[S] (db, stmt) in [S -> C] let tpc = \ntranstpc in let hdr = string_append[C] (\"Topic \", tpc) in let frame = gui_create_frame[C] (hdr) in let \n_ = show_rows[S,C] (db, frame, msgs) in gui_display_frame[C] (frame) and (db[S] [S] show_rows , frame[C] \n, msgs)= let b = sql_cursor_has_more_elements[S] (db, msgs) in [S ->C] letb=transbin if b then let row \n= sql_cursor_get_next_row[S] (db, msgs) in let cts = sql_cursor_get_column[S] (db, row, \"contents\") in \n[S ->C] let cts = transcts let lab = gui_create_label[C] (cts) in let _ = gui_frame_add[C] (frame, lab) \nin show_rows[S,C] (frame, msgs) else ()[S,C] in ... Figure 2: Program after location analysis (fat client) \ninteractions. The database is accessible via a textual SQL interface and the windowing environment provides \nthe usual GUI widgets. The database contains one relation messages where each tuple describes one message \n(topic, contents, au\u00adthor, etc). Administrative .elds include a topic id (tid)and a .ag indicating whether \nthe message starts a new topic. Figure 1 shows two functions taken from the program.1 Show_topic implements \na basic operation of the message board, the display of a list of messages for a given topic. To do so, \nit .rst queries the database using an existing database connection, db, for a given topic id, tid, and \npresents the content .elds of the resulting message set in a new GUI frame. It relies on show_rows to \npopulate the GUI frame with a text label for each message with that topic id. The code relies on several \nlibrary functions to access the database and to perform GUI operations. In particular, the function sql_exec \nreturns a cursor to the result of an SQL query, the functions sql_cursor_... access the relation un\u00adderlying \nthe cursor, and the gui_... functions create and manipulate appropriate GUI widgets. Not all library \nfunctions are location independent. The sql_... operations are not because all take the database connection \ndb as a parameter. The annotation [S] indi\u00adcates that the connection is only available on the server, \nhence the location analysis prescribes that all sql_... op\u00aderations must take place on the server, too. \nIn contrast, the GUI widgets can be created anywhere (gui_create_frame, gui_create_label,and gui_frame_add), \nbut there is also one operation, gui_display_frame, that must run on the 1In Ocaml, the left-hand side \nof a let is a pattern, which has to match the value of the right-hand side. The pattern _ is a wildcard \npattern that matches any value. client machine (indicated by the [C] annotation). Opera\u00adtions like string_append_... \nare location independent and may execute anywhere. The location analysis assigns to each operation a \nset of locations where the operation must take place. Starting from the operations with a .xed initial \nassignment, loca\u00adtion information is propagated through the program, and an [A -> B] implicit communication \ny = transx is inserted whenever data x available at A is required but not yet available at location B. \nThe outcome of the analysis is determined by a propagation strategy. Depending on this strategy, the \nanalysis may produce fat clients or thin clients and it may choose to duplicate operations at multiple \nlo\u00adcations to avoid the overhead of transmitting their results. Figure 2 shows one possible outcome of \nthe analysis where the GUI widgets are constructed on the client. At this point, the program in Figure \n2 may already be split into a client process and a server process. However, doing so would be ine.cient \nbecause each trans builds a connection between client and server to transmit one data item. Our joining \ntransformation addresses this ine.ciency. It joins adjacent communications, thus switching from a message\u00adbased \nstyle to a stream-based style. The main idea of the joining transformation is to introduce explicit channels \nwith open and close operations and then .oat open operations towards close operations in hopes of merging \nthem. The transformation has to go into some complication to deal smoothly with conditionals and with \nrecursion. Finally, the splitting transformation extracts from the an\u00adnotated program one slice for each \nlocation. Running all slices in parallel is equivalent to running the original pro\u00adgram. Figure 3 contains \nthe .nal program for the example. It contains two processes which share the communication port p 2 . \nEach process has the same structure because it is essentially a slice of the original program. The server \npro\u00adcess .rst opens the server end of a channel through port p using listen. Its slice of show_rows .rst \nsends a boolean indicating whether further data is following. If that is the case, it sends the .rst \ntuple and attempts to process the next tuple recursively. Otherwise, show_rows exits and the channel \nis closed. The client process performs exactly the converse communications: it .rst opens the client \nend of the channel and then receives data as it is sent. Technically, the communication is typed using \na session type of the form (string,\u00b5\u00df.(boolean,.true . (tuple,\u00df) | false . e.)). The type describes the \npossible sequences of communication events on a channel: .rst read a string; then repeatedly read a boolean; \nthen either read a tuple and continue or close the channel. The latter choice depends on the communication \nlabels true and false which are used in the type applica\u00adtions chan{true} and chan{false}. They indicate \non the type level, which branch of the conditional is taken. Hence, true and false are not values, but \nrather communication labels which have a status like record labels. In the explanation above, we have \nglossed over intermedi\u00adate technical steps that introduce additional infrastructure in the term. For \nexample, one step introduces channels with open and close operations. We defer closer discussion of the \nintermediate steps to subsequent sections (Section 6 and 7). 2The newPort expression will be written \n.p in the calculus. let p = newPort in // server process || // client process let rec let rec show_topic \n(db, tid, tpc) = show_topic () = let chan = listen (p) in let chan = connect (p) in let stmt = string_append_4 \nlet tpc = recv (chan) in (\"SELECT * FROM messages\", let hdr = string_append (\"Topic \", tpc) in \" WHERE \ntid= \", tid, \" \") in let frame = gui_create_frame (hdr) in let msgs = sql_exec (db, stmt) in let _ = \nshow_rows [chan] (frame) in let send chan (tpc) in let close (chan) in let _ = show_rows [chan] (db, \nmsgs) in gui_display_frame (frame) let close (chan) in and () show_rows [chan] (frame) = and let b = \nrecv (chan) in show_rows [chan] (db, msgs) = if b then let b = sql_cursor_has_more_elements let chan{true} \nin (db, msgs) in let cts = recv (chan) in let send chan (b) in let lab = gui_create_label (cts) in if \nb then let _ = gui_frame_add (frame, lab) in let chan{true} in show_rows [chan] (frame) let row = sql_cursor_get_next_row \nelse (db, msgs) in let chan{false} in let cts = sql_cursor_get_column () (db, row, \"contents\") in in \n... let send chan (cts) in show_rows [chan] (db, msgs) else let chan{false} in () in ... Figure 3: \nProgram split up into separate processes 3. SOURCE CALCULUS The underlying programming model is the \nsimply-typed call-by-value lambda calculus with integers, primitive oper\u00adations, and recursion. To simplify \nmatters, the calculus .A is an intermediate language. Its syntax is given by x.Var,i.Z Expressions e \n::= halt |let d in e|if x then e else e|x( x) Statements d ::= x= pfun( x) |x= op ( x) |rec {r} r ::= \ne|x( x)= e|r,r A .A expression is a sequence of let-bound statements, d, ending either in a halt instruction, \na conditional, or a jump with parameters. A statement either performs a primitive function, an operation, \nor introduces a set of mutually re\u00adcursive jump labels. All argument subterms in expressions and statements \nare restricted to variables. A primitive function pfun( x)is free of side e.ects. Nullary primitive functions \nserve as con\u00adstants. An operation op( x) has unspeci.ed side e.ects. Ar\u00adguments and results of primitive \nfunctions and operations are restricted to .rst-order values. The notation x stands for the sequence \nx1,...,xn where nderives from the context. We refrain from stating the type system or a semantics for \nthe source calculus because both are straightforward to derive from the de.nitions (for extended calculi) \nin the sub\u00adsequent sections.  4. INTRODUCING LOCATIONS A .A expression describes a computation at one \nlocation. This section extends .A to .. A, which can express that cer\u00adtain computations run on speci.c \nlocations (i.e.,tiers). In ..there is still only one program executing with one cen- A tralized locus \nof control. However, at each location only a subset of the program s e.ect will be visible. Values of \nvariables are only available on a subset of locations, some operations are only available at speci.c \nlocations, and data must be moved explicitly from one location to another. Syn\u00adtactically, there is one \nnew statement and one modi.cation: [A.B] A d ::= \u00b7\u00b7\u00b7|x= transx|x= op ( x) [A.B] The statement x = transy \ntransmits the value of y from location A to location B,where A,B .N, a .nite set of locations. The value \nof y must be available at A before executing the statement. Afterwards, the value is available through \nx at location B as well as at all locations at which it was available through y. Typically, the trans \nstatement is used with x= y so that it just extends the availability of x to include B. Only base values \ncan be transmitted between locations. Functions and pointers (references) cannot be transmitted. The \nstatement op A( x) performs an operation that has a side e.ect on location A and thus is only available \non that location. The values of x must be available at A before executing the statement and the result \nof the operation will be available only at A afterwards. The side e.ect of op A( x) is visible on A but \nnot on any other location. In the rest of this section, we .rst introduce the dynamic semantics of ..in \nterms of a labeled transition system. A Next, we present a type system that tracks the location of values \nin addition to their actual type. The type system ex\u00adtends the system of simple types with location annotations \nand annotation subtyping. Finally, we prove type soundness for this system. 4.1 Dynamic Semantics The \ndynamic semantics of .A is de.ned by a small-step transition system. The intermediate states of the system \nrequire an extension of the syntax, as usual. There are two kinds of computed values in the system: v \n::= val(i; N) | fun(rec { r } ; f) A value can be either a constant i with a set of locations N, which \nindicates where the value is available, or it can be a function consisting of a function name f and a \nset r of mutually recursive function de.nitions (where f selects one of the function of r). Functions \ndo not carry a set of locations because they are assumed to be available at all locations. The original \nexpressions and statements are extended to admit values wherever bound occurrences of variables are allowed \nin the original syntax. Evaluation steps produce traces of observations. Traces of observations, w . \nl * , are words over observations, l: A( l ::= halt | i0 = op i) where halt is intended to register halting \nexpressions, and i0 = op A( i) to register a particular call pattern of operation op () executed on location \nA.With locs(w), we denote the set of all locations, A, found all the observations of operations, i0 = \nop A( i), occurring in the a trace w. Throughout the paper, we specify reductions as families of relations \nindexed w by a trace, -. Figure 4 de.nes several notions of reduction for .A.The relation e wis the core \nreduction relation which re\u00ad -coree mains constant for the rest of this work. It describes eval\u00aduation \nsteps that transform e to e producing no side ef\u00ad w fect. The -t1 reduction deals with the Trans statement. \nw The relation e-op e describes operations with side e.ects. w With -opA , we denote reductions of operations \non loca\u00adtion A. In addition, we make use of the following combined wwwwww relations -imp = -core. -op, \n-.I = -core . -t1, A,pure www -.I = -imp . -t1. A The rule for primitive functions substitutes the result \nof the function as determined by dpfun (a partial function) in the rest of the term. The result is available \nat those loca\u00adtions where all arguments are available. A primitive opera\u00adtion only happens at its designated \nlocation and leaves its trail in the trace. Operations behave nondeterministically so they are modeled \nby a relation d. This choice may seem odd at .rst. However, the model must include the possibil\u00adity that \non each location further processes run in parallel to the program. That is, we cannot model side e.ects \nby pass\u00ading a state for each location because this state may change between two operations of our program \ndue to e.ects from another process. The nondeterministic model avoids pass\u00ading state explicitly and encompasses \narbitrary e.ects from other processes. The de.nition of a set of mutually recursive labels substi\u00adtutes \na function value for each de.ned label. The function value consists of the label identi.er paired with \nthe de.ni\u00adtion group. The conditional dispatches evaluation to the true or the false branch, as usual. \nA function call extracts the selected function de.nition from the de.nition group and substitutes the \narguments into that function s body. Since the function s body may refer to other functions in the de.\u00adnition \ngroup, it is wrapped in a new let with the de.nitions f t = t N1 . N2 f t 2 = t 1 N1 . N2 N1N2 f (b, \nN1) = (b, N2) f t 1 -. 0 = t 2 -. 0 G f a x : t G f a x : tt = t G f a x :G(x)G f a x : t Figure 5: Subtyping \nand argument rules for .A of the same de.nition group.  4.2 Static Semantics Thetypesystemfor .A has \nto model two facets of each value: its shape and the locations where it is available. It keeps track \nof the shape using an underlying simply-typed system and adds location annotations and e.ects to keep \ntrackof the locations. Annotation subtyping produces pre\u00adcise analysis results [16]. An annotated type, \nt , is either a base type b paired with a set of locations N or a function type with a location set N \nas latent e.ect. The meaning of an annotation N is that the associated data item must be present at all \nlocations in N. The e.ect on a function type indicates the set of locations that may execute operations \nwhen the function is applied. N t ::= (b, N) | t -. 0 N .N There are three typing judgments. G f e ! \nN states that e uses variables in G correctly and may perform operations at locations N.  G f d . G! \nN states that d transforms G to G and may perform operations at N.  G f a x : t infers the type for \nan argument position.  Subtyping in the system is structural and induced solely by the location annotations. \nSubtyping as formalized by the judgment f t = t expresses that a value that is present at location set \nN can substitute for a value that is only ex\u00adpected at a subset N . N. Also, the e.ect annotation of \na subtype must be included in the annotation of the super\u00adtype. Figures 5 and 6 contain the subtyping \nrules and the typing rules for expressions and statements. The halt expression has neither requirements \nnor does it perform an e.ect at any location. The e.ect of a let statement is the union of the e.ects \nof the statement and the body expression. A conditional needs only be executed on a location if one of \nthe branches contains code to be executed on that location. Hence, the value of the condition needs only \nbe available on the locations mentioned in the e.ect of the branches. A function application unleashes \nthe latent e.ect of the function. The rules for primitive functions and operations re.ect their operational \nsemantics but use subtyping to intersect the location sets implicitly. A recursive label is implicitly \navailable at all locations. The trans statement copies the value of y (which must be available at location \nA)to location B and binds it to x with appropriately changed type. let x= pfun(...val(ij; Nj ) ...) in \ne n let rec {fi( xi)= ei }i=1 in e if (val(0; N)) then e1 else e2 if (val(i; N)) then e1 else e2 n (fun(rec \n{fi( xi)= ei }i=1; fj)) ( v) let x= op A(...val(ij; Nj ) ...) in e [A.B] let x= trans(val(i; N)) in e \ne -core e -core e -core e -core e -core A( -op i=op i) e -t1 T T e[x.Nj )] if i= dpfun ( i) . Nj = \u00d8 \n.val(i; .e[fj .{fi ...}i=1; fj )]nj=1 .fun(rec n e2 if N =.\u00d8 e1 if i.. =0 and N = \u00d8 let rec xi)= ei \n}ni=1 in ej[ xj .v] {fi( . T e[x. if ii) .d.A. Nj .val(i; {A})] = op( e[x. if A.N .val(i; N .{B})] \n Figure 4: Reduction rules for .A G f e! N G f halt ! \u00d8 G f d.G! Nd G f e! Ne G f let d in e! Nd .Ne \nG fa x:(b,N) N1,N2 .N G f e1 ! N1 G f e2 ! N2 G f if x then e1 else e2 ! N1 .N2 N G fa x1 : t -.0G fa \nx 2 : t G f x1 ( x2)! N G f d.G! N (.1 =i =n)G fa xi :(b,N) G f x= pfun(x1,...,xn) .G(x:(b,N)) ! \u00d8 (.1 \n=i=n)G fxi :(b,{A}) a G f x= op A(x1,...,xn) .G(x:(b,{A})) ! {A} Ni (.1 =j =n)G(fi : ti -.0)ni=1( xj \n: tj) f ej ! Nj nNi G f rec {fi( xi)= ei }-.0)n i=1 .G(fi : tii=1 ! \u00d8 G fa y :(b,N) A.N [A.B] G f x= \ntransy .G(x:(b,N .{B})) ! \u00d8 Figure 6: Typing rules for .A  4.3 Properties of .A s and c which are only \navailable on S and C, respectively. source .rst completion SS x= s1 () x= s1 () [S.C] y = x+1 x= transx \nc C (y) y = x+1 halt c C (y) halt second completion S x= s1 () y = x+1 [S.C] y = transy c C (y) halt \nThere are many further completions that perform additional useless transmissions. The example also shows \nthat there is no obvious notion of optimality or minimality for comple\u00adtions. The .rst completion may \nperform fewer operations on S whereas the second performs fewer operations on C. It is not clear which \nis preferable without more information about C and S. For the moment, we leave this question to an implemen\u00adtation \nof the analysis in future work. The implementation will make its choice based on formalized preferences \nbetween locations. The implementation may even introduce redun\u00addancy by performing a computation at more \nthan one loca\u00adtion. This choice trades communication with computation. It is routine to prove type soundness \nfor the calculus .A. That is, evaluation of a typed closed expression either reaches halt after a .nite \nnumber of steps or it keeps reduc\u00ading forever. The typing rules for values and the intermediate states \nare straightforward. Lemma 2 (Type Preservation). Suppose \u00d8f e ! N w and e-.I e then \u00d8f e ! N , N .N,and \nlocs(w) .N. To connect .A with .A requires an erasure function |\u00b7|that maps an .A expression to an .A \nexpression by forgetting [A.B] A Lemma 3 about locations and removing all trans (Progress). If \u00d8f e!N \nthen e = halt x statements. or On types, the erasure function strips away all location sets w there \nexists e such that e and locs(w) .N. -.I e and all e.ects. Erasure has the following properties with \nrespect to the underlying unannotated calculus whose typing judgment is indicated with f0. Lemma 1. 1. \nIf G f e ! N then |G |f0 |e |. 2. If G f0 e then there exists some G , e ,and N such that G f e ! N and \n|G |=G and e = |e|. The expression e constructed from e in the second part is A w Furthermore, we de.ne \nthe re.exive transitive closure -* of the evaluation relation as follows: III w w e * e-e e-* e e-e I \nII ww e -e Type soundness follows by straightforward induction. Theorem 1. If \u00d8f e! N then either e-w \n* .I halt and A -.I e then there exists e a completion of e. The existence of completions is shown \nw I * by inserting transmission statements to every location after locs(w) .N or, for each e ,if e A \nand locs(w ) .N. every statement. Completions are not uniquely de.ned, in w I general. For example, \nconsider N = {S,C} and operations A such that e-.I e l . Label,x .Var,c .ChannelVar Statements d ::= \nx = pfun( x) |x = op A( x) |rec {r } | c = open[A.B] |c = openP[A.B] (p) [A.B] | close[A.B] (c) |x = \ntransc(x) |c{l} r ::= e |x[ c]( x)= e ; r Expressions e ::= halt |let d in e |if x then e else e | x[ \nc]( x) |.p.e Types and Type Environments N t ::= (b,N) |[ .] t -.0 G ::= \u00d8|G(x : t) Session Types and \nSession Type Environments . ::= e |(b,.) |(b, .) |.li ..i.|\u00df |\u00b5\u00df.. A T ::= \u00d8|T(c :B .) Figure 7: Syntax \nof .MT  5. MULTI-TIER CALCULUS The multi-tier calculus, .MT , is our .rst calculus with ex\u00adplicit communication \ninstructions. In the previous calculus, [A.B] .A, the statement x = transy just states the necessity \nof a communication between nodes A and B in a declara\u00ad [A.B] tive way. In contrast, .MT augments x = \ntransy with a channel argument and provides primitives that explicitly open and close a communication \nchannel. Figure 7 de.nes the syntax of the multi-tier calculus .MT . The main extension of this calculus \nwith respect to .A con\u00adsists of statements to open a channel (open), to transfer data via a connection \n(trans), and close the connection (close). In comparison to .A,the trans statement obtains a channel \nparameter and functions receive additional channel parame\u00adters c. A channel value cannot be bound to \na normal variable because the channel changes its type with every communica\u00adtion. Channel variables are \ntreated linearly to simplify the tracking of the change of type. Further extensions are added already \nat this time so that the remaining transformation steps can all be expressed with\u00adout leaving the calculus \n.MT . After splitting, an open state\u00adment yields two statements that have to open channels of matching \ntype. The calculus has an expression .p.e that introduces a fresh port name and an openP statement that \nopens a channel with a type prescribed by the port p.Open\u00ading channels with the same port ensures that \nthe channels session types match even if they occur in di.erent places in the program. Freshness of port \nnames ensures that each port value occurs at most once during the run of a program. As usual, introduction \nof fresh names is commutative, that is, we consider expressions modulo the smallest compatible equivalence \nrelation =containing .p.e = e if p/.fv(e) .p..p .e = .p ..p.e. Finally, the statement, c{e}, applies \na channel to a stati\u00adcally known label. Like a type application, it has no opera\u00adtional e.ect. Intuitively, \nc{e}selects one of several labeled types for the channel c:if c has session type .e ..,e1 . .1,...., \nthen its type changes to . after the channel appli\u00adcation. Section 5.2 explains more about its role in \ntyping. The translation T[\u00b7] from .A to .MT is straightforward. T,G f e ! N \u00d8,G f halt ! \u00d8 T,G f d .T \n, G! Nd T ,G f e ! Ne T,G f let d in e ! Nd .Ne G fa x :(b,N) N1,N2 .N T,G f e1 ! N1 T,G f e2 ! N2 T,G \nf if x then e1 else e2 ! N1 .N2 N G fa x :[ .] t -.0G fa z : t T=( c : .) T,G f x[ c]( z)! N A T(c :B \n.),G f e ! N T,G f .c[A.B].e ! N T,G(p : Port .) f e ! N T,G f .p.e ! N Figure 9: Typing rules for target \n(.MT ) expressions It replaces each occurrence of a statement [A.B] let x = transy in by a sequence of \nstatements that opens an explicit channel between locations A and B, transmits the current value of y \nfrom A to B, binds the value to x, and closes both ends of the connection: [A.B] let c = openin [A.B] \nlet x = transc(y) in let close[A.B] (c) in 5.1 Dynamic Semantics The de.nition of the dynamic semantics \nrequires the ex\u00adtension of the syntax with the same values as for .Ain Sec\u00adtion 4.1. Additionally, a \nnew binder is needed to model an open communication channel. The expression e ::= ... |.c[A.B].e [A.B] \nintroduces a fresh linear name, c, for a channel be\u00adtween locations A and B. w Figure 8 contains the \nreduction rules, -t2, that handle the new communication statements, together with evalu\u00adation contexts, \nE, that extend the reduction rules under binding constructs. [A.B] E ::=[ ] |.p.E |.c.E Opening a channel \nintroduces a fresh channel name. The transmission of a value is only possible through a channel connecting \nthe appropriate locations. Closing a channel [A.B] amounts to the removal of the channel binder for c. \nThe application of a channel to a label has no operational e.ect. w For .MT , we use three notions of \nreductions: -MT,pure w wwis the E-compatible closure of -core. -t2, -MT is the ww w E-compatible closure \nof -imp. -t2,and -is the MT(A) ww S w E-compatible closure of --\u00ad core. t2 .B.B= A opB .  5.2 Static \nSemantics The judgments of the static semantics of .MT extend the judgments of .A for expressions and \nstatements by a new type linear environment T which associates each channel e [A.B] let c = openin e-t2 \ne let c = openP[A.B] (p) in e1 -t2 e [A.B] let x = transc[A.B](val(i; N)) in e-t2 e [A.B] .c[A.B] \n.let close[A.B] (c) in e-t2 e let c[A.B]{ l} in e-t2 [A.B] .c[A.B].e[c .. c] [A.B] .c[A.B].e[c .. c] \ne[x .if A . N . val(i; N .{ B} )] e e Figure 8: Reduction rules for .MT T,G f d . T , G! N (. 1 = i \n= n)G f a xi :(b,N) T,G f x = pfun(x1,...,xn) . T,G(x :(b,N)) ! e (. 1 = i = n)G f a xi :(b,{ A} ) T,G \nf x = op A(x1,...,xn) . T,G(x :(b,{ A} )) ! op A() Ni (. j)( cj :Aj . j),G(fi :[ .]it i -. 0)in =1( xj \n: tj) f ej ! Nj T,G f rec { fi[ ci]( xi)= ei } n i=1 Ni . T,G(fi :[ .]it i -. 0) ! e G f a y :(b,N) A \n. N A [A.B] T(c :B (b,.)),G f x = transc(y) A . T(c :B .),G(x : t,N .{ B} )! e G f a y :(b,N) A . N B \n[A.B] T(c :A (b,.)),G f x = transc(y) B . T(c :A .),G(x : t,N .{ B} )! e A T,G f c = open[A.B] . T(c \n:B .),G! e G(p)= Port . A T,G f c = openP[A.B] (p) . T(c :B .),G! \u00d8 A T(c :B e),G f close[A.B] (c) . \nT,G! e A A T(c :B . li . .i. ),G f c{ lj}. T(c :B .j),G Figure 10: Typing rules for target (.MT ) statements \nvariable to its session type and the pair of locations con\u00adnected by the channel. A session type, ., \ndenotes an .-regular language that describes the sequence of types that the rest of the ses\u00adsion communicates \nover on the channel. The type e indi\u00adcates that no further communication can take place on a channel, \n(b,.) sends a base value and continues according to .,and (b,.) receives a value and continues. The type \n. l1 . .1,l2 . .2,.... is a conditional session type guarded by the labels l1,l2,... The channel application \nc{ li} changes the type of c to .i. Each application of the recursion oper\u00adator must be expansive, that \nis, a well-formed session type does not have subterms of the form \u00b5\u00df1 ... \u00b5\u00dfn.\u00df1. Such subterms do not \ncorrespond to regular trees. For example, the type from Section 2 (string,\u00b5\u00df.(boolean,. true . (tuple,\u00df) \n| false . e. )) denotes the language { string boolean (tuple boolean)n | n . N}.{ string boolean (tuple \nboolean).} Since each communication on a channel changes its session type, the variables in T must obey \na linear typing discipline. Figure 9 contains the annotated typing rules for expres\u00ad sions. The rules \nre.ect the previous rule set for .A and impose additional demands on the use of channels. The halt expression \nrequires that all channels are closed. The conditional requires that all branches must use the channels \nin the same way. The rule for let indicates that a state\u00adment transforms both environments. A function \ncall pass all channels to the function. The annotated typing rules for statements appear in Fig\u00adure 10. \nOf the original rules, only the rule for function def\u00ad initions changes signi.cantly. The additional \nrequirement is that a function may only refer to the channels passed as parameters, that is, a function \ndoes not have free channel variables. The transmission of a value changes the type of the channel as \nexpected. Closing a channel requires that its session type is e, whereas opening a channel invents a \nsession type. Applying a channel to a label selects the cor\u00adresponding alternative in the channel s session \ntype. The subtyping rules remain unchanged. The argument typing rules change only marginally.  5.3 A \nNotion of Bisimilarity To prove the correctness of the presented program trans\u00adformations we need to \nstate relationships between source programs and their transformed counterparts. To this end, we consider \ntwo programs equivalent if the perform the same side-e.ecting operations in the same order. This notion \nof equivalence is best captured by a weakbisimulation [12]. The de.nition of a suitable bisimulation \nrequires that we split our transition rules in two parts: those reductions that w w do not have a side \ne.ect, -R1 , and those that do, -R2 .The w corresponding observation relation -. R1,R2 makes transi\u00ad \nw w tions using -R1 until we reach a transition with -R2 keep\u00ad w ing only the .nal observation of -R2 \n. Formally, the relation w -. R1,R2 is de.ned as follows: halt halt-. R1,R2 . I w ww e-R2 e e-R1 ee -. \nR1,R2 e ww e-. R1,R2 ee-. R1,R2 e The halt expression is related to a non-terminating term .. w If we \nmake one observable step with -R2 , then the related expressions are also in the observation relation. \nUnobserv\u00adable steps may be prepended to the observation relation. Following Milner [10] and Gordon [3], \nwe de.ne weak bisimilarity co-inductively that is, as greatest .xed point using the following two functions \n[- ],.-. that are parame\u00adterized with respect to four transition relations: def (R 1,R 2,R 3,R 4)[S ]= \nw { (e,f) | if e-. R1,R2 e w then . f with f-. R3,R4 f and e S f } def (R 1,R 2,R 3,R 4).S. = ]op (R \n1,R 2,R 3,R 4)[S ] n (R 1,R 2,R 3,R 4)[S op def R1,R2,R3,R4 =gfpS.. (R 1,R 2,R 3,R 4)[S ]. (R 1,R 2,R \n3,R 4)[S ] denotes pairs that reach a pair in S by a simulated common step, (R 1,R 2,R 3,R 4).S. is the \nre\u00adstriction of the simulation in both ways. Weakbisimilarity, R1,R2,R3,R4 , is the greatest relation \nwith these properties, i.e., the greatest .xpoint of .S. . 5.4 Technical Results First, type soundness \nis established in the usual way from a type preservation result and a progress result. Lemma 4 (Type \nPreservation). If \u00d8 ,\u00d8f e! N and w e-MT e then \u00d8 ,\u00d8f e !N with N . N and locs(w) . N. Lemma 5 (Progress). \nIf \u00d8 ,\u00d8f e! N then either e= w halt or there exists e such that e-MT e and locs(w) . N. The translation \nT [ ] de.ned at the beginning of this sec\u00adtion preserves typing and results in programs with the same \nobservational behavior. Lemma 6. If G f e! N then (. G) \u00d8 ,G fT [e] ! N. Lemma 7. T [\u00b7 ] . www w .I \n,op,MT,pure,op A,pure  6. FROM DATAGRAMS TO STREAMS The transformation T [] from the previous section \nworks correctly, but it produces ine.cient programs. Whenever a value from location A is needed at location \nB, the program sends a datagram: it opens a channel from A to B, sends the value, and closes the channel, \nagain. The ine.ciency lies in the cost of connection establishment. Since this cost is much higher than \nthe cost of transmitting one value, it would be better if the cost for connection establishment were \namortized across as many value transmissions as possible. To avoid repeated connection establishment, \nwe de.ne a set of transformation rules on .MT terms that seekto join close and open statements for a \nchannel with the goal of reusing the channel for multiple communications. Es\u00adsentially, the transformation \nturns a sequence of datagram transmissions between two hosts into a stream connection. Figure 11 speci.es \nthe transformation in terms of a rela\u00ad tion -. ES. The strategy for applying the transformation rules \nis to .oat each open statement upwards in a list of statements until one of the following holds. 1. The \nopen meets a close with matching (or reversed) locations. In this case, the two channels are joined together \nand both statements are eliminated. 2. The open reaches the beginning of a function body. If the function \nis recursive, then the open is split o. in a separate non-recursive wrapper function. Then, the standard \ninlining transformation can transport the open to all call sites of the function [14]. The transfor\u00admation \nstops at functions that are not inlineable (e.g., certain toplevel functions).  3. The open reaches \nthe top of a branch of a conditional. There are two possibilities. If the other branch has amatching \nopen, then the transformation rule .rst inserts a channel application c{ l} with label et in the true-branch \nand ef in the false-branch. If .t and .f are the original types of the channels in the true-and the false-branch, \nthen their type becomes . et . .t,ef . .f. so that the channels can be joined and hoisted in front of \nthe conditional. If no matching open is available in the other branch, then a transformation rule may \nintroduce a new chan\u00adnel between the source and destination host that is opened and immediately closed. \nThen joining takes place as before. Typing is preserved under the compatible closure . ES of the relation \n-. ES. The transformation with . ES leads to weakly bisimilar programs. Lemma 8. If T,G f e! N and e. \nES e then there exists T such that T ,G f e ! N. Lemma 9. . ES . w ww w MT,pure,op,MT,pure,op  7. SPLITTING \nTRANSFORMATION Given a type derivation for a .MT program, the splitting transformation extracts for each \nlocation a program slice such that running all slices in parallel on their respective locations is equivalent \nto running the original program. The transformation proceeds in three steps. The .rst step introduces \nglobal port names for each connection. Port names serve as globally visible points of contact between \nthe processes generated in step number three. The second step pools together all introductions of port \nnames at the beginning of the program. The third step extracts the slices from the type derivation where \neach slice contains a separate process for each location. 7.1 Port Introduction The .rst step of the \nsplitting transformation, the intro\u00adduction of ports, P [\u00b7 ], replaces each occurrence of [A.B] let c \n= openin ... by a let expression with openP header that refers to an explicit port name and is surrounded \nby a . abstraction introducing precisely that port name: .p.(let c = openP[A.B] (p) in ...) The translation \nP [ ] preserves typing. The translation produces weakly bisimilar programs. Lemma 10. If T,G f e! N then \nT,G fP [e] ! N. Lemma 11. P [\u00b7 ] . w ww w MT,pure,op,MT,pure,op  7.2 Port Floating The next step moves \nall port binders to the beginning of the program. Figure 12 speci.es the transformation in terms of a \nrelation -. PB. The second rule lifts a port binder out of an arbitrary function de.nition in the block. \nTyping is preserved under the compatible closure . PB of the relation -. PB. Transforming with . PB leads \nto weakly bisimilar programs. [A.B] let d in let c = openin e [B.A] let c = openin e [A.B] let close[A.B] \n(c) in let c = openin e [A.B] let rec { f[ c]( x)= let c = openin e; r } in e [A.B] if x then (let c \n= openin e1) [A.B] else (let c = openin e2) e -. ES let -. ES let -. ES e[c -. ES let -. ES let [A.B] \nc = openin let d in e if x .. var(d) [A.B] c = openin e . c] rec { f [ c,c ]( x)= e; [A.B] f[ c]( x)= \nlet c = openin f [ c,c]( x); r } in e [A.B] c = openin . if et = ef if x then let c{ et} in e1 else \nlet c{ ef} in e2[c ..c] [A.B] -. ES let c = openin let close[A.B] (c) in e Figure 11: Extending the \nscope of a channel (.MT ) let d in .p.e -. PB .p.let d in e if p .. var(d) let rec { f[ c]( x)= .p.e; \nr } in e -. PB .p.let rec { f[ c]( x)= e; r } in e if p ..var(r) .{ f, x }. fv(e ) Figure 12: Floating \nof port binders Lemma 12. If T,G f e ! N and e . PB e then T,G f e ! N. Lemma 13. . PB . w ww w MT,pure,op,MT,pure,op \n 7.3 .MT Without Magic As a last preparation of the splitting transformation, we replace the multi-location \ncommunication operations in .MT by traditional communication operations and add an op\u00aderator for concurrent \nexecution. For example, the x = [A.B] transc(y) statement of .MT speci.es sending of y at location A \nand receiving of x at location B (via channel c) [A.B] at the same time. Also, the openand close[A.B] \n(c) statements perform operations at two locations. Here is the additional syntax of the .nal calculus \n.MTC. d::= ... | closeA (c) | c = listenA(p) | c = connectB(p) | sendA c(x) | x = recv B (c) e ::= ... \n| e || e The expression e1 || e2 speci.es the interleaved execution of e1 and e2. The other statements \nare the one-sided versions of the previous communication statements. Instead of an un\u00adspeci.c open statement \nfor establishing a channel between two locations, there are now listen and connect to cre\u00adate a server \nend and a client end of a channel for a speci.c port. In the same manner, there are separate communica\u00adtion \noperations to send an outbound message and to recv an inbound message over an established channel. 7.4 \nDynamic Semantics Again, the intermediate states need additional syntax: The .c.e expression introduces \na pair of fresh linear names, c and c, that model the two ends of a channel. w There are two notions \nof reduction for .MTC: -MTC,pure ww w is the E-compatible closure of -core. -t3,and -MTC is ww the E-compatible \nclosure of -imp. -t3 (cf. Figure 13). Evaluation contexts are de.ned by E ::= [ ] | E || e | .p.E |.c.E. \nBoth relations consider expressions modulo the small\u00adest compatible equivalence relation = satisfying \n(for both kinds of .). .x.e = e if x/. fv(e) .x..y.e = .y..x.e e || e = e || e e || (e || e ) = (e || \ne ) || e (.x.e) || e = .x.(e || e )if x/. fv(e ). The reduction rules in Fig. 13 workas follows. The \npair\u00ading of a listen command and a connect command for the same port results in a channel abstraction \nwhere the chan\u00adnel names are replaced by the paired names c and c.A send/recv pair for the same channel \nc results in transfer\u00adring the value v from one end to the other. Closing both ends of a channel amounts \ndropping the channel entirely. The application of a channel to a label is a synchronization construct. \nIt requires the same label application at the other end of the channel to proceed. w For .MTC,weuse -, \nthe E-compatible closure of MTC(A) ww w S -core. -t3 -opB, as the notion of reduction. .B.B=A  7.5 \nStatic Semantics Figure 14 contain the typing rules for the new statements and expression. Each port \ncreated by .p.e has a .xed session type associated with it. Since a port is globally available, its type, \nPort ., does not carry a location set. The idea is that c = listenA(p) binds c to the server end of a \nchannel at lo\u00adcation A. The channel inherits its session type . from port p. c = connectA(p) creates \nthe client end. Since sending and receiving of data is exactly reversed on the client, the session type \nis mirrored indicated by overlining (cf. Fig\u00adure 15) before it is assigned to the new client end. The \nsend and recv operations peel o. one communication event from the channel type; send an outbound event, \nand recv an inbound event. The revised close operation only closes one end of a channel. The rule for \nconcurrent execution splits the linear channel environment into two disjoint parts, one for each subprocess, \nas indicated by the + operator. The value environment is let c1 = listenAe1 || let c2 B(p) in e2 -t3 \n.. (p) in = connecte .c.(e1[c1 . c] || e2[c2 . c])  let sendA c(v) in e1 || let x = recv B(c) in e2 \ne -t3 e1 || e2[x .. v] .c.(let closeA (c) in e1 || let closeB (c) in e2) e -t3 e1 || e2 let c{ l} in \ne1 || let c{ l} in e2 e -t3 e1 || e2 Figure 13: Reduction rules for .MTC T, G f e ! N T1, G f e1 ! N1 \nT2, G f e2 ! N2 T1 +T2, G f e1 || e2 ! N1 . N2 T, G f d . T , G! N G(p)= Port . T, G f c = listenA(p) \n. T(c :A .), G! \u00d8 G(p)= Port . T, G f c = connectA(p) . T(c :A .), G! \u00d8 G f a x :(b, N) A . N T(c :A \n(b, .)), G f sendA c(x) . T(c :A .), G! \u00d8  T(c :A (b, .)), G f x = recv A(c) . T(c :A .), G(x : b)! \n\u00d8 T(c :A e), G f closeA (c) . T, G! \u00d8 Figure 14: Typing for extended target syntax, .MTC . li . .i. = \n. li . .i. e = e \u00b5\u00df.. = \u00b5\u00df.. \u00df = \u00df ., . = .,. .,. = ., . Figure 15: Mirroring of channel types copied \nto both subprocesses and their e.ect is gathered.  7.6 Slice Extraction The .nal step starts with a \ntype derivation for \u00d8 , \u00d8f . The transformation T e p.e] in Figure 16 skips p.e ! N. N [. over the leading \nport binders, extracts for each Ai . N the slice of operationsfor location Ai, and puts them in paral\u00adlel. \nThe resulting program has the form .p. (e1 || ... || em). Strictly speaking, the transformation requires \na type deriva\u00adtion as input. To avoid this clutter, the input term carries annotations. The annotation \n@N provides the inferred ef\u00adfect of an expression or statement. When handling a chan\u00adnel, the transformation \nneeds to know the source and target locations of the channel. Again, the annotation @{ B, C}provides \nthis information. Both pieces of information are present in a type derivation. Lemma 14. Suppose that \n\u00d8 , \u00d8f . p.e ! N. Then \u00d8 , \u00d8f N [. T e p.e] ! N. The transformed program is weakly bisimilar to the \norig\u00adinal one if we consider e.ects on each location A separately. Lemma 15. Let \u00d8 , \u00d8f . For each location \nA . N, p.e!N. it holds that T Ne [\u00b7 ] . www w . MT(A), opA, MTC(A), opA  8. RELATED WORK The splitting \ntransformation is closely related to program slicing [17]. Recent advances in slicing deal with concur\u00adrent \nprograms [11, 8], however, while slicing does not in\u00adtroduce new operations, our transformation maps \na sequen\u00adtial program into a multi-threaded program. Another di.er\u00adence is that slicing is usually driven \nby the program depen\u00addency graph, whereas our transformation is driven by loca\u00adtion analysis which includes \ndependency information through the typing rule for the conditional. Secure program partitioning (SPP) \n[19] is a closely re\u00adlated transformation that maps a sequential program to a distributed program. However, \nthe goals of SPP are quite di.erent. SPP starts from a program with con.dentiality and integrity annotations \nfor functions, data, and a number of hosts. From these annotations, SPP partitions the pro\u00adgram such \nthat each host runs that part of the program for which its credentials are appropriate. The partition \nfurther ensures that the host only receives data up to its con.den\u00adtiality level and that data from the \nhost is only trusted up to its integrity level. In an extension of that work[20], the authors use replication \nto increase the scope of SPP. Binding-time analysis [7, 5] can be seen as a special case of the location \nanalysis. For example, the TRANS construct is closely related to lifting. However, a binding-time analy\u00adsis \ndistinguishes two modes of computation (static and dy\u00adnamic) whereas a location analysis for n locations \ndistin\u00adguishes 2n di.erent modes. Our calculus may be viewed as an instance of the capa\u00adbility calculus \n[18] restricted to simple types and specialized to particular resources (channels and locations). This \nspe\u00adcialization enables us to exploit properties beyond the reach of the capability calculus. Session \ntypes [2] have emerged as an expressive typing dis\u00ad cipline for heterogeneous, bidirectional communication \nchan\u00adnels. Each message may have a di.erent type with the pos\u00adsible sequences of messages determined \nby the channel s ses\u00adsion type. Such a type discipline subsumes typings for data\u00adgram communication as \nwell as for homogeneous channels. Research on the parallel implementation of functional lan\u00adguages is \nconcerned with the automatic detection of implicit parallelism and the speculative evaluation of expressions, \ne.g., [13, 4]. Our analysis does not detect parallelism but de\u00adtermines independent slices of programs \nwith explicit com\u00admunication interfaces. There is no speculative evaluation in our transformed programs, \nalthough the splitting trans\u00adformation (guided by the location analysis) may introduce redundancy by \nperforming location independent operations in more than one location simultaneously. 9. CONCLUSIONS \nAND FUTURE WORK We have presented a location analysis that enables split\u00adting of an application into \nslices that execute independently  Acknowledgment Toplevel Expressions TNe [.p.e] = .p.TNe [e] We \nare indebted to the anonymous reviewers whose numer\u00adT{eA1,...,Am} [e] = Te [e] ||... ||Te [e] if e .=.p.e \nous and extensive comments helped to improve the presen- A1 Am Expressions tation signi.cantly. Te A \n[halt] = halt Te  A [let d in e] = let TAd [d] in TAe [e] 10. REFERENCES Te A [if x then e1 else e2@N] \n . [1] C. Flanagan, A. Sabry, B. F. Duba, and M. Felleisen. The if x then TAe [e1] else TAe [e2] A .N \nessence of compiling with continuations. In Proceedings of the = 1993 Conference on Programming Language \nDesign and Implementation, pages 237 247, Albuquerque, NewMexico, halt otherwise Te A [x[ c]( z)@N] \n. June 1993. (x)[TAt [c ]] TAt [z ] A .N [2] S. Gay and M. Hole. Types and subtypes for client-server \n= halt otherwise interactions. In D. Swierstra, editor, Proceedings of the 1999 European Symposium on \nProgramming, number 1576 in Statements Lecture Notes in Computer Science, pages 74 90, Amsterdam, Td \n A [x = pfun( x)@N] The Netherlands, Apr. 1999. Springer-Verlag. . x = pfun( x) A .N [3] A. Gordon. \nBisimilarity as a theory of functional programming. = Theoretical Computer Science, 228(1-2):5 47, Oct. \n1999. rec {} otherwise } [4] J. Greiner and G. E. Blelloch. A provably time-e.cient parallel Td x = \nop AI ( x) implementation of full speculation. ACM Transactions on A . Programming Languages and Systems, \n21(2):240 285, 1999. x = op AI ( x) A = A [5] F. Henglein. E.cient type inference for higher-order = \n rec {} }otherwise binding-time analysis. In Hughes [6], pages 448 472. [6] J. Hughes, editor. Functional \nProgramming Languages and TAd s = openP[B.C] (p) Computer Architecture, number 523 in Lecture Notes in \n8 Computer Science, Cambridge, MA, 1991. Springer-Verlag. < c = listenA(p) B = A A [7] N. Jones, C. \nGomard, and P. Sestoft. Partial Evaluation and = c = connect(p) C = A Automatic Program Generation. Prentice-Hall, \n1993. : rec {} otherwise [8] J. Krinke. Context-sensitive slicing of concurrent programs. In } Proceedings \n9th European Software Engineering Conference, Td close[B.C] (c) A pages 178 187. ACM Press, 2003. . \n closeA (c) A = B .A = C [9] X. Leroy. The Objective Caml system release 3.02, = Documentation and user \ns manual. INRIA, France, July 2001. rec {} otherwise http://pauillac.inria.fr/caml. n Td A [rec {fi[ \nci]( xi)= ei }i=1] [10] R. Milner. Communication and Concurrency. Prentice Hall, = rec {fi[TAt [c i]](TAt \n[x i])= TAe [ei] }Englewood Cli.s, NJ, 1989. i=1 [B.C] [11] M. G. Nanda and S. Ramesh. Slicing concurrent \nprograms. In } n Td transc(x) A Proceedings of the International Symposium on Software 8 Testing and \nAnalysis, pages 180 190. ACM Press, 2000. < send c(x) A = B [12] D. Park. Concurrency and automata on \nin.nite sequences. In = x = recv (c) A = C Proceedings of the 5th GI-Conference on Theoretical rec {} \notherwise Computer Science, number 104 in Lecture Notes in Computer : B AC  Td c{lj }Science, pages \n167 1183. Springer-Verlag, 1981. . [13] S. L. Peyton Jones. Parallel implementations of functional c{lj \n} A = B .A = C = programming languages. The Computer Journal, rec {} otherwise 32(2):175 186, 1989. \nParameter lists [14] S. L. Peyton Jones and J. Launchbury. Unboxed values as .rst Tt class citizens in \na non-strict functional language. In Hughes [6], A [E] =() . pages 636 666. Tt A [x ] ,x A .N Tt [15] \nW. R. Stevens. UNIX Network Programming.Prentice Hall A [ = x,x@N] Tt A [x ] otherwise Software Series, \n1990. [16] Y. M. Tang and P. Jouvelot. E.ect systems with subtyping. In W. Scherlis, editor, Proc. ACM \nSIGPLAN Symposium on  Figure 16: Slice extraction in .MTC Partial Evaluation and Semantics-Based Program \nManipulation PEPM 95, pages 45 53, La Jolla, CA, USA, June 1995. ACM Press. [17] F. Tip. A survey of \nprogram slicing techniques. J. Programming Languages, 3(3):121 189, 1995. in parallel and that communicate \nvia typed streams. The [18] D. Walker, C. Crary, and G. Morrisett. Typed memory analysis and the accompanying \ntransformations enable the management via static capabilities. ACM Transactions on development of distributed \napplications in a local setting. Programming Languages and Systems, 22(4):701 771, July Each of the transformation \nsteps is proven correct. 2000. [19] S. Zdancewic, L. Zheng, N.Nystrom, andA.C.Myers.Secure Ongoing workconsiders \nthe e.cient implementation of program partitioning. ACM Transactions on Computer the location analysis. \nThe challenge is that the analysis Systems, 20(3):283 328, 2002. must be con.gurable with respect to \nlocation preferences [20] L. Zheng, S. Chong, A. C. Myers, and S. Zdancewic. Using and communication \nrequirements. The present workonly replication and partitioning to build secure distributed systems. \nIn Proceedings of the 2003 IEEE Symposium on gives a speci.cation. Practical experience will show if \na Security and Privacy, page 236. IEEE Computer Society, 2003. polymorphic analysis is required. In general, \nthe mapping to tiers will be a multi-language issue that requires an additional translation step from \nthe framework s language to the desired target languages. Al\u00adternatively, a heterogenous frameworkmight \nbe considered where either the analysis applies directly to di.erent lan\u00adguages.  \n\t\t\t", "proc_id": "1040305", "abstract": "Modern applications are designed in multiple tiers to separate concerns. Since each tier may run at a separate location, middleware is required to mediate access between tiers. However, introducing this middleware is tiresome and error-prone.We propose a <i>multi-tier calculus</i> and a <i>splitting transformation</i> to address this problem. The multi-tier calculus serves as a sequential core programming language for constructing a multi-tier application. The application can be developed in the sequential setting. Splitting extracts one process per tier from the sequential program such that their concurrent execution behaves like the original program.The splitting transformation starts from an assignment of primitive operations to tiers. A program analysis determines communication requirements and inserts remote procedure calls. The next transformation step performs resource pooling: it optimizes the communication behavior by transforming sequences of remote procedure calls to a stream-based protocol. The final transformation step splits the resulting program into separate communicating processes.The multi-tier calculus is also applicable to the construction of interactive Web applications. It facilitates their development by providing a uniform programming framework for client-side and server-side programming.", "authors": [{"name": "Matthias Neubauer", "author_profile_id": "81100042558", "affiliation": "Universit&#228;t Freiburg, Germany", "person_id": "P343130", "email_address": "", "orcid_id": ""}, {"name": "Peter Thiemann", "author_profile_id": "81100458917", "affiliation": "Universit&#228;t Freiburg, Germany", "person_id": "PP39043747", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1040305.1040324", "year": "2005", "article_id": "1040324", "conference": "POPL", "title": "From sequential programs to multi-tier applications by program transformation", "url": "http://dl.acm.org/citation.cfm?id=1040324"}