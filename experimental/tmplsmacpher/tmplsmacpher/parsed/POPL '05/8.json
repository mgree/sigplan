{"article_publication_date": "01-12-2005", "fulltext": "\n Synthesis of Interface Speci.cations for Java Classes Rajeev Alur Pavol .y Cern\u00b4 P. Madhusudan Wonhong \nNam Department of Computer and Information Science University of Pennsylvania Philadelphia, PA 19104 \n {alur, cernyp, madhusudan, wnam}@cis.upenn.edu ABSTRACT While a typical software component has a clearly \nspeci.ed (static) interface in terms of the methods and the input/out\u00adput types they support, information \nabout the correct se\u00adquencing of method calls the client must invoke is usually undocumented. In this \npaper, we propose a novel solution for automatically extracting such temporal speci.cations for Java \nclasses. Given a Java class, and a safety property such as the exception E should not be raised , the \ncorrespond\u00ading (dynamic) interface is the most general way of invoking the methods in the class so that \nthe safety property is not violated. Our synthesis method .rst constructs a symbolic representation of \nthe .nite state-transition system obtained from the class using predicate abstraction.Constructing the \ninterface then corresponds to solving a partial-information two-player game on this symbolic graph. We \npresent a sound approach to solve this computationally-hard problem ap\u00adproximately using algorithms for \nlearning .nite automata and symbolic model checking for branching-time logics. We describe an implementation \nof the proposed techniques in the tool JIST Java Interface Synthesis Tool and demon\u00adstrate that the tool \ncan construct interfaces accurately and e.ciently for sample Java2SDK library classes. Categories and \nSubject Descriptors: D.2.4 [Software Engineering] Software/Program Veri.cation -formal meth\u00adods, model \nchecking; D.2.1 [Software Engineering] Require\u00adments/Speci.cation -methodologies, tools; D.2.2 [Software \nEngineering] Design Tools and Techniques -modules and in\u00adterfaces General Terms: Algorithms, Veri.cation \nKeywords: Behavioral interfaces, synthesis, software com\u00adponents, abstraction, model checking, games, \nlearning reg\u00adular languages. Permission to make digital or hard copies of all or part of this work for \npersonal or classroom use is granted without fee provided that copies are not made or distributed for \npro.t or commercial advantage and that copies bear this notice and the full citation on the .rst page. \nTo copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior speci.c \npermission and/or a fee. POPL 05, January 12 14, 2005, Long Beach, California, USA. Copyright 2005 ACM \n1-58113-830-X/05/0001 ...$5.00. 1. INTRODUCTION Contemporary software development emphasizes compo\u00adnents \nwith clearly speci.ed APIs. In current practice, com\u00adponents such as Java library classes have a clearly \nspeci.ed static interface that consists of all the (public) methods, along with the types of input parameters \nand return val\u00adues that these methods support. However, there are often implicit constraints on the sequencing \nof method calls that capture the intended use of the component. For example, for a .le system, the method \nopen should be invoked before the method read, without an intervening call to close. While such interfaces \ncan be made precise, using for instance regu\u00adlar expressions as types, these kinds of precise speci.cations \nare typically not documented. Such dynamic interfaces for components can help application programmers \nwriting client code for the class, and program analysis tools may even be able to checkautomatically \nwhether the client code invokes the component correctly. In this paper, we propose a rig\u00adorous and automated \napproach for extraction of dynamic interfaces from existing code for Java classes. Formally, a (behavioural) \ninterface I for a Java class C maps a history of method calls and return values to the methods that can \nbe invoked after this history. Given a set E of unsafe valuations for the class variables, we say that \nthe interface I is safe with respect to the requirement E if invoking any of the methods allowed by I \navoids the state of C to reach E. Typically, the safe set will correspond to requirements such as the \nexception e is never raised, or an error value is never returned. Di.erent applications can employ the \nsame class with di.erent requirements, and di.erent interfaces can be safe for di.erent requirements. \nThere is a natural notion of the most permissive interface for a given class C with respect to a given \nrequirement E. Needless to say, typical decision problems concerning this most permissive interface are \nundecidable. In this paper, we propose a method to algorithmically construct a safe, but not necessarily \nmost permissive, interface that can be represented as a .nite-state automaton. The .rst step of our solution \nemploys predicate abstrac\u00adtion, a powerful and popular technique for extracting .nite\u00adstate models from \ncomplex and potentially in.nite-state mod\u00adels [14, 19]. Given a (concrete) Java class C and a .nite set \nP of boolean predicates over the class variables, A is an ab\u00adstraction of C with respect to P such that \nit has the same set of methods as C, but the input parameters, return values, and abstract states are \n(the .nitely many) combinations of truth values to the boolean predicates in P.The abstract transition \nrelation over-approximates the concrete one in the standard way. As a result, the abstract class A is \nnondeter\u00administic: whenever one of its methods is called, there are multiple possible executions that \ncan result in di.erent ab\u00adstract states and return values. The interface computation for the abstract \nclass then cor\u00adresponds to a two-player partial information game. Player 0, the user of the class, chooses \nto invoke one of the methods. Player 1, the abstract class, chooses a corresponding possible execution \nthrough the abstract state-transition graph which results in an abstract return value. Player 0 does \nnot know the current state of the abstract class precisely, and has to choose the next method based on \nthe history of the invoked methods and the values they returned thus far. A strategy for player 0 is \nwinning if the game always stays away from the abstract states satisfying the requirement E. A winning \nstrategy for player 0 in this game is a safe interface for the original class C with respect to the requirement \nE. The second step of our solution corresponds to comput\u00ading a winning strategy in the two-player partial \ninformation game over the abstract class A with respect to the safety requirement. From classical results \nconcerning partial infor\u00admation safety games [26], it follows that the most permissive winning strategy \nin this game can be represented by a deter\u00administic .nite-state automaton (DFA) I of size exponential \nin the number of states of A (which, in turn, is exponential in the number of predicates used for abstraction). \nWe compute the strategy automaton using the L * algo\u00adrithm for learning a regular language using membership \nand equivalence queries [4, 27]. The learning-based approach produces a minimal DFA, and the number of \nqueries is only polynomial in the size of the output automaton. Further\u00admore, this approach allows us \nto encode the abstract class A symbolically, and we use an existing BDD-based symbolic model checker \nNuSMV [10] to answer the queries. The membership query is to test whether all runs of the abstract class \nA corresponding to a given sequence s of method calls and return values stay away from the states that \nsatisfy E, and can be posed as an invariant veri.cation problem for the composed model Ais. The equivalence \ntest is to checkwhether the current strategy automaton J has the same language as the most permissive \nwinning strategy I for A with respect to E.To test L(J)= L(I), we .rst use the subset query L(J) . L(I) \n(i.e., is J safe?). This reduces to checking whether E is an invariant of the model AiJ.The model checker \nNuSMV is used for this test, and if the test fails, the model checker returns a counter-example that \ncan be used by the learning algorithm to update J.The super\u00adset query L(J) . L(I) (i.e., is J most permissive?) \ncannot be naturally posed as a model checking query: a counter\u00adexample is a sequence s . L(J) such that \nevery run of A on s stays within the safe region. In fact, we show that the superset query is NP-hard. \nWe hence use approximate and heuristic techniques that employ symbolic model checking to answer the superset \nquery. In summary, our approach ter\u00adminates with a deterministic .nite-state automaton J such that (1) \nJ is the minimal DFA accepting L(J), (2) the num\u00adber of model checking queries is polynomial in the size \nof J and in the length of the longest counter-examples obtained while synthesizing the automaton (3) \nJ is safe for A with respect to E, and (4) either J is declared to be the most permissive interface for \nA,or J is declared to be approxi\u00admate (and in this case, J is guaranteed to be maximal in the sense that \nif J' is any interface more permissive than J, we are assured that J' has more states than J does). \nWe report on an implementation of our solution in a pro\u00adtotype tool called JIST, the Java Interface Synthesis \nTool. The JIST abstractor processes Jimple, an intermediate rep\u00adresentation of Java byte code used in \nthe Soot framework[30]. Given an input Jimple class, and a set of predicates, the ab\u00adstractor transforms \nthe input class line by line, producing a class with only boolean (or enumerated) variables. Cur\u00adrently, \nonly a subset of Jimple is supported and only those abstraction predicates that compare a variable to \na constant are handled. The transformed class then is rewritten to a symbolic representation compatible \nwith the input format of the model checker NuSMV. The JIST synthesizer imple\u00adments the L * learning algorithm \nvia CTL model checking queries on this symbolic representation using NuSMV. We report on the performance \nof the tool on four classes: AbstractList$ListItr.java, Signature.java, ServerTableEn\u00adtry.java and PipedOutputStream.java. \nIn each case, the class .le has a few (less than 10) methods with about a hundred lines of code. As a \nrequirement, we choose a particular ex\u00adception, and as abstraction predicates, we include all con\u00additions \nof the form a variable is equal to a constant that are checked before raising the exception. After the \ntransfor\u00admations, the input to the symbolic model checker has 20 50 boolean variables. The interface \nis computed by the synthe\u00adsizer within a few minutes. More importantly, the interfaces computed by the \ntool are guaranteed to be safe and max\u00adimal, and in practice, seem to capture useful information. For \nthe class AbstractList$ListItr.java we also show how the choice of initial predicates impacts the synthesized \ninterface. Related Work This workwas inspired by the workof Whaley et al. on extracting interfaces from \nJava classes [32]. In their original work, the focus was on .nding pairs of methods (m, m') such that \ncalling m' after m will certainly raise an exception. The solution used static analysis techniques such \nas constant propagation, augmented with dynamic techniques analyzing execution runs, and extensive experimentation \nwith large applications is reported. Our paper presents a more general and formal solution to interface \nsynthesis. In particular, the interface generated by [32] is not guaranteed to be safe, and the safety \nrequirement, the abstraction, and the states of the interface automaton are hard coded in the solution. \nA relevant line of research is the recent workon software veri.cation tools such as Bandera [13], SLAM \n[6], Feaver [22], and Blast [21]. Our abstraction strategy is closest to the one employed by SLAM for \nabstracting C code using boolean predicates [5]. In all these works, the focus is on verifying the code \nwith respect to user-speci.ed requirements, while our focus is on synthesizing a safe interface. Abstract \ninter\u00adpretation has been used to automatically generate invariants such as linear constraints over program \nvariables [15, 23]. Using automata as types has been explored in program\u00adming languages research, particularly \nfor access control [17, 31]. The focus of these e.orts is on providing the user with a formal way of \nspecifying interfaces, and enforcing type con\u00adsistent usage either statically or at runtime. The proposed \nsynthesis approach can be viewed as type inference in this context, and is complementary. There is a \nrich tradition of research in program analy\u00adsis aimed at extracting speci.cations from sample execution \ntraces and related dynamic techniques [3, 24]. These tech\u00adniques can bee.ectivein learning about thetypical \nusage of the class. However, they cannot provide soundness guar\u00adantees that veri.cation techniques such \nas ours do. There is an extensive literature on games in the context of design and veri.cation of systems \n[2, 28] as well as in pro\u00adgramming languages semantics [1]. The idea of synthesizing interfaces using \ngames does not seem to appear explicitly in this literature. A related project is Chic, where the au\u00adthors \nuse games to formalize and checkcompatibility of user speci.ed interfaces [9, 16]. The workpresented \nin [18] involves synthesis of environ\u00adments that is similar to our setting, but synthesizes inter\u00adfaces \nusing explicit graph techniques that involve a subset construction of the state space, while our techniques \nare symbolic involving graphs constructed using predicate ab\u00adstraction. In [29], the authors present \ntechniques to con\u00adstruct environment models using user-provided environment requirements and by examining \nenvironment implementa\u00adtions. Finally, our use of learning algorithms is related to the workof Cobleigh \net al. [12] (see also [7]) who use the L * al\u00adgorithm to automatically construct assumptions for compo\u00adsitional \nveri.cation. In order to verify that the composition of two components C1 and C2 satis.es a safety requirement \nE, the authors propose to learn the assumption I on inputs to C1 such that C1iI satis.es E and C2 satis.es \nI [12]. In this setting, C2 is given and can be used to answer queries, while in our setting no concrete \nenvironment that can aid answering queries is provided.  2. INTERFACES In this section, we formalize \nthe notion of a symbolic class and its interfaces. A symbolic class is a tuple C = (M,X,{Dx}x.X ,Xr,Init,{Tm}m.M \n,{Rm}m.M )that con\u00adsists of the following components: M is a .nite set of method names. For simplicity, \nwe assume that methods do not have input parameters.  X is a .nite set of variables used in the class. \n For each x.X, Dx is the domain of the variable x.A state s..x.X Dx is a valuation of the variables \nin X. Let S denote the set of all states. A predicate over X is a constraint over the possible valuations, \nand for a predicate p and a state s,weuse s |= p to denote the satisfaction relation.  Xr . X is a set \nof return variables used for return values from method calls. We use Sr to denote the set of all valuations \nfor Xr.  Init(X)is an initial state predicate over X. For any state s,if s |= Init,then s is an initial \nstate.  Let X ' = {x ' | x . X} be the set of primed variables corresponding to the variables in X.For \neach m.M, Tm(X,X ' )is a transition predicate over X.X ' for the method m.  For each m.M, Rm(X)is a \nreturn predicate over X for the method m.  When a method m is invoked in a state s, the transition \nrelation Tm is applied repeatedly until a return state s ' sat\u00adisfying Rm is reached. For any such return \nstate s ' ,the values of the return variables Xr in the state s ' , denoted s ' [Xr ], are the corresponding \nreturn values. Formally, for m states s and s ' and a method m, s -. s ' holds i. there exist states \ns = s0,s1,...,sn = s ' such that s ' |= Rm,and for all 0 =i<n, si |= Rm and Tm(si,si+1). When a program \ninteracts with a class, it invokes a se\u00adquence of methods, say m1,\u00b7\u00b7\u00b7 ,ml, and gets return values v1,\u00b7\u00b7\u00b7 \n,vl,where each vi is in Sr.An interface for a class is a function that takes such a history of interaction \nand prescribes a set of methods that can be called after this in\u00adteraction. Formally, an interface for \na symbolic class C is a function I :(M\u00d7Sr) * .2M . Given a class C and an inter\u00adface I, runs(C, I) is \nthe set of behaviors the class exhibits when used in accordance with the interface, and is the set of \nall (.nite or in.nite) sequences . = s0,m0,s1,m1,s2,\u00b7\u00b7\u00b7 over S.M that satisfy the following conditions: \ns0 |= Init and m0 .I(e). mi For every i=0, si -.si+1.  For every i=0, mi+1 .I((m0,s1[Xr]),\u00b7\u00b7\u00b7 ,(mi,si+1[Xr])). \n  We specify safety requirements using predicates that cap\u00adture the bad states. A run . = s0,m0,s1,m1,s2,\u00b7\u00b7\u00b7 \nis said to be safe with respect to a predicate E over the class variables in X if si |= E for every i \n=0. An interface I for C issaid tobea safe interface with respect to the predicate E if every ..runs(C,I)is \nsafe with respect to E. We refer to E as an exception predicate in what follows. There is a natural ordering \namong interfaces: if I and I ' are two interfaces for a class C,then we say that I is more permissive \nthan I ' if for all s . (M \u00d7Sr) * , I ' (s) . I(s). That is, if I is more permissive than I ' ,then after \nany possible history of calls and returns, I allows invoking any method that is allowed by I ' .The most \npermissive safe interface for C, if one exists, is a safe interface I such that for every safe interface \nI ' , I is more permissive than I ' .For a given exception E, it is easy to see that the most permissive \nsafe interface exists. Example: Signature Class To illustrate the de.nition of an interface, we consider \nthe class Signature from the package java.security from Java2SDK. The Signature class provides the func\u00adtionality \nof a digital signature algorithm. We pick the .ve most interesting methods for interface synthe\u00adsis: \ninitSign(), initVerify(), sign(), verify() and update(). There are eight other methods in the class. \nUsers sign by invoking sign() and checkthe input signa\u00adture using verify(). Both operations need initialization \nvia initSign() and initVerify(), respectively. Once such initialization method is invoked, the user can \nalso update the datatobesigned orveri.ed by update(). A .nite automaton (DFA) over the alphabet (M\u00d7Sr)can \nbe interpreted to represent an interface. For such a DFA J, the corresponding interface I is de.ned as: \nI(s)= {m.M |.sr . Sr,s \u00b7(m,sr) . L(J)}. For example, Figure 1 illus\u00adtrates an interface automaton. In \nthis example, Xr = \u00d8 and  initVerify initSign update update initSign verify  sign initVerify initSign \ninitVerify Figure 1: Signature we use M instead of M \u00d7 Sr; hence the labels on edges are over M. All \nstates are .nal, and missing transitions indicate disallowed calls. For instance, I(initSign initVerify)is \nthe set of all methods on the outgoing transitions from q1, that is, {initSign, initVerify, update, verify}.The \nformal notion of how automata describe interfaces is ex\u00adplained in Section 5.1. It is easy to see that \ninterface au\u00adtomata capturing the most permissive interface do exist if the symbolic class is .nite (i.e. \neach domain Dx is .nite), but may not exist otherwise. We say a safe interface automaton J for a class \nC is max\u00adimal if it is true that for every safe interface automaton J ' with L(J) . L(J ' ) (i.e. where \nJ ' is more permissive than J), J ' has more states than J does. Note that the minimal automaton describing \nthe most permissive safe interface au\u00adtomaton is, by de.nition, maximal.  3. OVERVIEW OF JIST Given \na symbolic class C, presented as a class written in Java, our aim is to .nd a safe (and if possible the \nmost permissive) interface for C. Our solution is in two steps. The .rst step, described in Section 4, \ninvolves abstraction of a Java class into a boolean symbolic class, that is, a class whose variables \nare booleans (or of enumerated type), and all predicates are expressed as propositional formulas. This \nstep obviously introduces a loss of information, but leads to a representation that can be manipulated \nby symbolic computational techniques such as BDD-based model check\u00aders. The second step requires solving \na partial-information 2-player safety game over the abstract boolean class. We wish to output a .nite \ninterface automaton over the alpha\u00adbet M \u00d7 Sr that captures the language of method sequences allowed \nby the interface (as in Figure 1). However, since this problem is hard and infeasible to compute accurately, \nour method strives to construct the most permissive inter\u00adface failing which it will produce an approximation \nwith the guarantee that the interface output is maximal. The syn\u00adthesis step is presented in Section \n5. The complete tool chain is given in Figure 2. On the im\u00adplementation level, the following transformations \nare per\u00adformed: 1. Java to Jimple: The Java source is compiled into Java byte code and then the Soot \ntool is used to transform it to the Jimple format. Jimple is a 3-address represen\u00adtation that has been \ndesigned to simplify analysis and transformation of Java byte code and is thus suitable for our purpose. \nIn the current implementation of the prototype tool, a pre-processing step is done manually on theJavasourcecode \ntoreplace the throwing of exceptions (other than the ones we are interested in for the interface) to \nstatements that return 0. 2. Jimple to Boolean Jimple: The Jimple to Boolean Jim\u00ad  ple conversion is \ndone by the Predicate abstractor.The input to the abstractor is a Jimple .le along with a set of predicates. \nThe algorithm and the implementation are described in Section 4. 3. Boolean Jimple to NuSMV: The boolean \nThe Jimple code is converted to a boolean model in the NuSMV language. 4. Synthesizing an interface:The \nInterface Synthesizer takes in the NuSMV code for the boolean abstract class and an exception predicate \nE, and computes an interface automaton that is either the most permissive interface or a maximal safe \ninterface. We use a regular\u00adlanguage learning algorithm and CTL symbolic model checking for the synthesis. \nThe synthesis algorithm and its implementation are described in Section 5.  Using JIST to synthesize \ninterfaces A user of JIST can go about synthesizing interfaces in the following manner. First, the user \nidenti.es the exception predicate for the class with respect to which the interface is required, and \nalso an initial set of predicates that may be useful in extracting an appropriate interface. In our exper\u00adiments, \nthe exception predicate corresponds to a particular exception being thrown, and the initial predicates \nare chosen as the predicates in the conditionals that guard the throwing of this exception. The user \nthen runs the tool to get a maximal safe interface J with an indication of whether or not the interface \nis guar\u00adanteed to be the most permissive for the chosen abstraction. The user can then examine this interface \nto see whether it adequately describes all behaviors one would expect from the class. For example, in \none of the experiments (ListItr), it turned out that the initial interface was too weakas it completely \nruled out calling certain methods. Checking ad\u00adequacy of the interface is something that is currently \nleft entirely to the user; indeed, there can be several ways to checkthis (for example, the user could \ncheckconformance of typical clients of the class to the interface). If the interface is not adequate \nand the tool has not guar\u00adanteed that J is the most permissive interface, then the user can .nd a method-call \nsequence that she believes must be allowed by the interface. The tool can then take this string and examine \nwhether it is safe (using a membership query as explained in Section 5), and if it is safe, use it as \na counter\u00adexample to the superset query (see below for details) to con\u00adtinue learning a better interface. \nIf the user-supplied string is not safe or if the tool has assured that the current interface is the \nmost permissive, then then the user must provide new predicates that re.ne the abstraction and rerun \nthe tool. Discovering abstraction predicates automatically is an ac\u00adtive area of research in software \nveri.cation (see [6, 20]), and some of these techniques are potentially useful for the purpose of synthesizing \ninterfaces, but this is left for future work. 4. PREDICATE ABSTRACTION 4.1 Sound abstractions for symbolic \nclasses Predicate or boolean abstraction uses boolean variables corresponding to assertions (predicates) \nover the states of a Predicates Exception Predicate E  Figure 2: The complete tool chain program to \nform a coarse model of the program. In predicate abstraction, we take a set of predicates Pover the concrete \nset of variables X and treat these predicates as abstract vari\u00adables. We then transform the class so \nthat it keeps track of these abstract variables rather than the concrete variables. Note that if there \nis a .nite number of predicates, abstrac\u00adtion reduces the (possibly in.nite) concrete state space into \na .nite state space. When abstracting a class, we must ensure that all be\u00adhaviors of the program correspond \nto some behavior in the abstracted class. It will then follow that if we design a safe interface for \nthe abstract class, then the interface will indeed be safe for the concrete class as well. We formalize \nbelow a standard set of rules under which the abstraction captures all concrete behaviors. We restrict \nourselves to abstraction predicates such that if a predicate refers to a variable in Xr, then it refers \nonly to the variables in Xr,that is, to predicates over Xr or over X \\Xr. Let C =(M, X, {Dx}x.X ,Xr, \nInit, {Tm}m.M , {Rm}m.M ) be a symbolic class and let P be a set of abstraction predi\u00adcates. A symbolic \nclass A =(M, Xa , {DA}x.Xa ,Xra , Inita , {m}m.M , {m}m.M ) is said to be an abstraction of C with Ta \nRa respect to P if the following conditions hold. The set of methods stays the same. The abstract domain \nDA is the set {0, 1, *}, where, intuitively, 0 stands for an abstract predi\u00adcate being false, 1 stands \nfor it being true, and *stands for it being unknown. = {xP | P .P} is a set of vari- Xa ables over the \ndomain DA, one for each predicate in P.A state s a of the abstract symbolic class is hence an element \nof Sa =.x.Xa DA.Let . : Sa .S be the concretization function de.ned by: .(s a)= {s |.P .P,s .P .s a[xP \n]=0, s .P .s a[xP ]=1} We say that s a abstracts s if s ..(s a). The abstract class must further satisfy: \n Xra is the set of abstract variables xP such that P is a predicate that involves some variable in Xr. \n For every abstract state s a, if there exists a state s . .(s a) such that s |= Init,then Inita(s a)holds. \n a''a For all m .M,if for some s ..(s )and s ..(s ), a Tm(s,s ' ) holds, then Ta (s ,s 'a)holds. m For \nall m .M,iffor some s ..(s a), s |= Rm,then s a |m. = Ra Also, we require that for all m . M, Rm .P.Note \nthat the abstraction of C with respect to P is not unique, because of the .exibility in the abstraction \nof the transition predicate. Let C be a symbolic class and let A be its abstraction with respect to \nP.Let . * :(M \u00d7Sa) * .(M \u00d7S) * be the natural extension of .. Let J be an interface of the class A.An \ninterface IJ for the class C is a concretization of J if IJ (s)= J(sa) whenever s ...(sa)where ..is the \nnatural extension of . to (M \u00d7DXr ) * and DXr is the product of the domains of return variables of the \nclass A. Lemma 1. runs(C,IJ ) .. * (runs(A,J)) Given the exception predicate E, we de.ne the abstract \npredicate Ea as follows: for all m .M,if for some s ..(s a), s |= E,then s a |= Ea . The next theorem \ncaptures correct\u00adness of the abstraction: whenever an abstract interface is safe for the abstracted class, \nthen the concretization of the interface is safe for the concrete class. Theorem 1. Let C be a symbolic \nclass. Let A be its ab\u00adstraction with respect to P.Let J be a safe interface for the class A with respect \nto the exception predicate Ea.Then IJ is a safe interface for the class C with respect to E. 4.2 Abstracting \nJimple programs A Jimple program can be seen as a symbolic class. Our tool abstracts the Jimple class \ninto a boolean Jimple pro\u00adgram. A boolean Jimple program is simply a Jimple pro\u00adgram that has only boolean \nor enumerated data types. The tool is implemented on top of Soot, a frameworkfor opti\u00admizing Java bytecode. \nThis frameworkis implemented in Java, and supports a number of representations for Java bytecode. Our \ntool uses the API of the Soot frameworkto perform transformations on Jimple code. Our abstractor works \non a subset of Jimple (the grammar of the subset that we handle is available at http://www.cis. upenn.edu/jist). \nA large part of core classes of Java 2 falls into this subset and thus can be analyzed by our tool. The \nmain features Jimple that are not treated here are .oating\u00adpoint types, arrays, recursive function calls, \nand exceptions (apart from the exception with respect to which we are con\u00adstructing the interface). The \nabstraction algorithm proceeds line-by-line on the original program, and is inspired by the SLAM toolkit \n[5]. In the SLAM tool, an automatic theorem prover is used to compute abstractions. In our prototype \nimplementation, the abstractions of Jimple statements can be precomputed, since we use predicates of \na simple form and the tool ab\u00adstracts simple expressions (and safely overapproximates the rest). The \npredicates are of the form x = k where x is a variable and k is a constant. We denote such a predicate \nby the abstract variable b(x,k) over the three-valued domain {0, 1, *}. Since Jimple does not have a \nnondeterministic con\u00additional, we create a class TriBool and make each predicate that we add an instance \nof this class. In abstracting Jim\u00adple code, the values of the TriBool variables are set and read using \nunimplemented methods. As a consequence, our boolean abstractions are valid Jimple programs that can \nbe executed with any implementation of TriBool (for example, it can randomly resolve the nondeterminism). \nLet P be a predicate and Pr be a set of predicates used for abstraction. We need the following notions \nin order to de.ne the abstraction algorithm on Jimple statements: WP(st,P) (weakest precondition) is \nthe weakest pred\u00adicate over the concrete variables X whose truth before a statement st entails the truth \nof P afterwards.  The command assume(P) silently terminates if P evaluates to false. By silently terminates \nwe mean that the method halts without returning and such runs are ignored in the analysis.  Implies(Pr)(P) \nis the best boolean function on Pr that implies P, i.e. Implies(Pr)(P) . P,and if F is a boolean function \non Pr such that F . P,then F  . Implies(Pr)(P). ImpliedBy(Pr)(P) is the best boolean function on Pr \nthat is implied by P, i.e. P . Implies(Pr)(P), and if F is a boolean function on Pr such that P . F,then \nImpliedBy(Pr)(P) . F. In general, a statement st is abstracted into the following sequence of commands: \n(one command for each predicate p in Pr): b(p) = Implies(Pr)(WP(st,p)) ? true : Implies(Pr)(WP(st,not \np)) ? false : * It is well-known that if we abstract a program statement by statement in this way, we \nwill get a sound abstraction. However, it should be noted that in order to prove formal correctness of \nthe abstractor, we need to formally associate a symbolic class C(J) with a Jimple class, and prove that \nif the abstractor transforms a class J to J ' ,then C(J ' )is an abstraction of C(J) as de.ned in Section \n4.1. We present here the abstraction of assignments, condi\u00adtional statements and method calls. The abstraction \nof other statements is quite straightforward in our setting. Abstraction of assignments Consider a sample \nJimple statement x=y+1 Let (y, l1) \u00b7\u00b7\u00b7(y, ln) be the set of predicates involving y. Note that if one \nof these predicates is true, the others are false. For all predicates of the form (x, k), we get the \nfol\u00adlowing series of abstracted statements if (y, k -1) is in the predicate list: b(x,k)=b(y,k-1) If \n(y, k -1) is not in the predicate list, we get: if (b(y,l1)==TRUE or ... or b(y,ln)==TRUE) then b(x,k)=FALSE \nelse b(x,k)=* Abstraction of conditionals Consider a sample statement if (x==k) then C1 else C2 If \n(x, k) is in the predicate list, the abstracted class contains: if b(x,k)==* resolve-nondeterminism{b(x,k1),...,b(x,kn)} \nif b(x,k)==TRUE Abs(C1) // abstracted code for C1 else // b(x,k)==false Abs(C2) // abstracted code for \nC2  If (x, k) is not in the predicate list: if b(x,k1)==* or ... or b(x,kn)==* resolve-nondeterminism{b(x,k1),...,b(x,kn)} \nif b(x,k1)==TRUE or ... or b(x,kn)==TRUE Abs(C2) // abstracted code for C2 else // Every b(x,ki)=FALSE \nAbs(C1) // abstracted code for C1 where (x, k1) \u00b7\u00b7\u00b7(x, kn) are the set of predicates involving x. In \nthe above translation, resolve-nondeterminism(b(x,k1), ...,b(x,kn)) sets all variables whose value is \n* to TRUE or FALSE in such a way that if for any i, b(x, ki)is set to TRUE, then b(x, kj)is set to FALSE, \nfor all j di.erent than i. Abstraction of method calls Currently, calls to other methods are inlined \nin the code and abstracted. If the method is not implemented, then it is abstracted in a coarse way: \nan assignment that contains amethod callto f x=f() is replaced by: b(x,k1)=* ... b(x,kn)=* where (x, \nk1) \u00b7\u00b7\u00b7(x, kn) are the set of predicates involving x. However, if the speci.cations of what the method \nmust do are known, we replace the call with this speci.cation (manually) using appropriate Java code. \n 5. INTERFACE SYNTHESIS In this section, we describe the interface synthesis algo\u00adrithm for a given \n(abstracted) boolean symbolic class A.It turns out from standard results in games that the most per\u00admissive \nsafe interface can be captured by a .nite automaton, and hence corresponds to a regular language that \nwe shall henceforth refer to as U. The standard way to generate the interface would be to generate, using \na subset construction, a new complete-inform\u00adation game. In this new game, after any interaction with \nthe class, the player playing the role of the interface would keep trackof the set of states the original \ngame can be in. This new game can then be solved using a standard .x-point com\u00adputation that computes \nthe winning positions in the game. However, solving a partial information game in this way re\u00adquires \nmanipulating sets of states of A. Recall that a state of A is a valuation of the boolean predicates, \nand the tran\u00adsitions of A are given symbolically. Working with sets of states of A symbolically seems \nhard, and explicitly enumer\u00adating the state space of A is una.ordable. Furthermore, in our setting, we \nexpect the interface to be a much smaller DFA than the abstract class, and solving the game using the \nabove method makes us pay an expo\u00adnential cost in computation time, regardless of the size of the strategy \nwe want to build. To avoid this problem, we have chosen to implement the interface synthesis using a \nlearning algorithm; the learning algorithm tries to learn the most permissive safe interface. We use \na standard algorithm to learn regular languages called the L * algorithm [4, 27]. The L * algorithm is \nan algorithm that learns an unknown regular language U (in our setting, U is the language of the most \npermissive safe interface) by asking two kinds of queries to a teacher who knows U: membership queries \n(i.e. asking whether a given string s is in U) and equivalence queries (i.e. asking whether a given conjecture \nregular language L is precisely U). Ifan equivalence query is answered in the negative, the teacher also \nprovides a counter-example, i.e. a string which is either in L and not in U, or which is in U but not \nin L. The number of queries the L * algorithm makes is depen\u00addent on the size of the interface automaton \nit constructs. We answer the queries of the L * algorithm using calls to a standard symbolic model-checker, \nand thus we do not resort to a subset construction. Hence, the learning-based solu\u00adtion avoids both the \nproblems stated above: the complexity of the algorithm depends on the size of the interface con\u00adstructed, \nand the algorithm is implemented using symbolic model checking techniques. In our setting, we split the \nrole of the teacher answering equivalence queries into two: one that checks subset queries (whether a \ngiven conjecture language is a subset of U)and one that checks superset queries. As we show below, mem\u00adbership \nqueries and subset queries can be e.ciently handled using model-checking algorithms. However, we do not \nknow how to handle the superset query e.ciently. We can in fact show that while the computational complexity \nof member\u00adship queries and subset queries is in polynomial time (in fact in nondeterministic log-space), \nthe superset query is NP\u00adhard, and hence a simple algorithm to answer it is unlikely to exist. We hence \npropose heuristic approximations to handle su\u00adperset queries. We ensure that the equivalence query is \n.rst checked as a subset query, and only if the subset query passes, it is passed on as a superset query. \nThe superset query teacher .rst checks for a certain stronger property, which if true, implies that the \nconjecture language L is in\u00addeed a superset of U, and the superset query can return true. But if this \nproperty fails, we gain no information as to whether L is a superset of U.At this point, if we declare \nthat the language L is indeed U,the L * algorithm will ter\u00adminate with an interface that is a subset \nof U, and is not guaranteed to be exactly U. However, in practice, this kind of termination results some\u00adtimes \nin interfaces that are too restrictive. Hence, we do an additional test that looks for certain simple \ncounter\u00adexamples (strings in U that are not in L)thatwe do not want to miss. If this procedure fails \nto generate a counter\u00adexample, we terminate and output the interface. In summary, our algorithm is guaranteed \nto terminate (since the L * algorithm guarantees termination) and out\u00adput an interface J, which is a \nminimal DFA that is guar\u00adanteed to be safe. Also, the algorithm either declares that J is the most-permissive \ninterface (in which case it is guar\u00adanteed that J is the same as U) or the algorithm declares that J \nmay not be the most-permissive interface. In the latter case, we are assured that J is maximal (this \nfollows from the property of the L * algorithm that it is the mini\u00admal automaton that satis.es the observation \ntable it has maintained). Finally, the algorithm has built-in heuristics that search for a certain class \nof counter-examples that try to make the output interface closer to U. We describe now formally the \nnotion of automata repre\u00adsenting interfaces, the learning algorithm and the handling of queries. 5.1 \nInterfaces Let us start by de.ning formally how .nite automata de\u00adscribe interfaces. We use deterministic \n.nite automata over an alphabet of method-call return-value pairs, whose lan\u00adguage is pre.x-closed, to \ncapture interfaces. Given a boolean class A =(M, X, {Dx}x.X ,Xr, Init, {Tm}m.M , {Rm}m.M ), consider \na deterministic .nite automaton (DFA) J =(Q,q0, F, d) over the alphabet (M \u00d7 Sr), where: M is the set \nof method names of A and Sr is the set of all valuations for return variables of A.  Q is a .nite set \nof states; q0 . Q is the initial state, F . Q is a set of accepting states, and d : Q\u00d7(M\u00d7Sr) . Q is the \ntransition function.  Intuitively, if d(q, (m, r)) = q ' , it means that when at state q, the interface \ncorresponding to the DFA can invoke the method m, and if it receives the return value r,it moves to state \nq ' . Note that if an interface prohibits a sequence s . (M \u00d7 Sr) * , then it prohibits all extensions \nof s and the language of the interface is hence pre.x-closed. We therefore require that there is at most \none non-accepting state and it is a sinkif it exists (i.e., all transitions from it go to itself). For \nq . Q, let the set of legal methods from q, denoted LM (q) be the set of methods m such that for some \nreturn value r, d(q, (m,r)) . F. The transition function d general\u00adizes to strings in (M \u00d7 Sr) * in a \nnatural way: d(q, e)= q, and d(q, s \u00b7 (m,r)) = d(d(q, s), (m,r)), for s . (M \u00d7 Sr) * , (m, r) . M \u00d7 Sr.Now, \na DFA J =(Q, q0,F,d)repre\u00adsents the interface I :(M \u00d7 Sr) * . 2M ,given by I(s)= LM (d(q0,s)), for every \ns . (M \u00d7 Sr) * . Given a boolean class A, an exception predicate E and an automaton J representing an \ninterface, we say J is a safe interface for A with respect to E if J represents a safe interface I for \nA with respect to E. We henceforth refer to automata that represent interfaces also as interfaces and \ntreat them synonymous with the interfaces they represent. L.  5.2 algorithm The L * algorithm learns \nan unknown regular language and generates a minimal DFA that accepts the regular language. This algorithm \nwas introduced by Angluin [4], but we use an improved version by Rivest and Schapire [27]. The algorithm \ninfers the structure of the DFA by asking a teacher, who knows the unknown language, two types of questions: \nmembership queries and equivalence queries.On a membership query, the learner asks whether a string s \nis L * Algorithm 1: S := {e}; E := {e}; 2: foreach (s. S),(a. S) and (e. E) { 3: T[s,e]:= Member(s\u00b7e); \n4: T[s\u00b7a,e]:= Member(s\u00b7a\u00b7e); 5: } 6: repeat: 7: while ((snew := Closed(S,E,T)) = null) { 8: Add(S,snew \n); 9: foreach (a. S) and (e. E) { 10: T[snew \u00b7a,e]:= Member(snew \u00b7a\u00b7e); 11: } 12: } 13: C := MakeConjectureMachine(S,E,T); \n14: if ((cex := Equivalent(C)) = null) then return C; 15: else { 16: enew := FindSu.x (cex ); 17: Add \n(E,enew ); 18: foreach (s. S)and (a. S) { 19: T[s,enew ]:= Member(s\u00b7enew ); 20: T[s\u00b7a,enew ]:= Member(s\u00b7a\u00b7enew \n); 21: } 22: } Figure 3: L * algorithm accepted by the unknown language, and the teacher answers true \nor false. On an equivalence query, the learner conjec\u00adtures that the machine it has constructed is equivalent \nto the unknown language. The teacher replies that the conjecture is either correct or incorrect, and \nin the latter case gives a counter-example which is a string accepted by one but not the other. Figure \n3 illustrates the L * algorithm. Let U be the un\u00adknown regular language and S be its alphabet. At any \ngiven time, the L * algorithm has information about a .\u00adnite collection of strings over S, classi.ed \neither as members or non-members of U. This information is maintained in an observation table (S,E,T)where \nS and E are a set of strings over S, and T is a function from (S . S\u00b7S) \u00b7 E to {true,false}.Intuitively, \nS can be viewed as a set of repre\u00adsentative strings that lead from the initial state (uniquely) to the \nvarious states of the DFA, and E as experiments that are performed at these states in order to distinguish \nstates. T maps strings s in (S . S\u00b7S) \u00b7 E to true if s is in U,and to false otherwise. Initially, S and \nE are set to {e},and T, which is implemented as a two-dimensional array, is initial\u00adized using membership \nqueries for every string in (S.S\u00b7S)\u00b7E (line 2 5). In line 7, it checks whether the observation table \nis closed;that is, for every s . S and a . S, there exists s ' . S such that T[s\u00b7a,e]= T[s ' ,e] for \nevery e . E.If not, each such s\u00b7a (e.g., snew is s\u00b7a in line 8) is simply added to S. The algorithm again \nupdates T with regard to s\u00b7a (line 9 11). Once the table is closed, it constructs a conjec\u00adture machine \nC =(Q,q0,F,d) as follows (line 13): Q = S, q0 = e, F = {s . S | T[s,e]= true},and forevery s . S and \na . S, d(s,a)= s ' such that T[s\u00b7a,e]= T[s ' ,e]for ev\u00adery e. E. Finally, if the answer of the equivalence \nquery is yes, it returns the current machine C; otherwise, a counter\u00adexample cex . ((L(C) \\ U) . (U \\ \nL(C)) is provided by the teacher. The algorithm analyzes the counter-example cex in order to .nd the \nlongest su.x enew of cex that witnesses a di.erence between U and L(C) (line 16). Adding enew to E re.ects \nthe di.erence in the next conjecture by splitting a state in C.It then updates T with respect to enew \n. The L * algorithm guarantees to construct a minimal DFA for the unknown regular language using only \na polynomial number of membership and equivalence queries: more pre\u00adcisely with O(|S|n 2 + nlog m) membership \nqueries and at most n - 1 equivalence queries, where n is the number of states in the .nal DFA and m \nis the length of the longest counter-example provided by the teacher for equivalence queries. 5.3 Synthesis \nof interfaces using L. In this section, we explain how we apply the L * algorithm to synthesize a safe \ninterface. Given a boolean class A and an exception predicate E,we can make the L * algorithm construct \nthe most permissive interface for A with respect to E by providing answers for membership and equivalence \nqueries to the learner. Figure 4 is a high-level pseudo-code for the teacher who answers queries in the \nL * algorithm. We implement teachers for the membership query, the subset query and the superset query, \nusing model-checking procedures for CTL (Compu\u00adtational Tree Logic) model checking [11]. 5.3.1 Membership \nand subset queries Given a string s =(m0,r0),\u00b7\u00b7\u00b7 ,(mn,rn), the teacher for membership queries checks \nwhether the string s is in the language U (i.e., whether s . U). The membership query can be reformulated \nas a subset query, where we .rst con\u00adstruct a simple interface Js with |s| + 2 states that accepts precisely \nthe string s and its pre.xes. It is easy to see that the membership query for s is equivalent to the \nsubset query for Js. Since we know that the language we are trying to learn is pre.x-closed, we ensure \nthat the L * algorithm does not ask membership queries for s if a pre.x of s has already been known to \nbe not in the language. This reduces the number of membership queries [8]. Givenaninterface J, the subset \nquery asks whether the language of J is a subset of the language U (i.e., whether L(J) . U). Since U \nconsists precisely the set of all the safe method-call return-value sequences, this question is equiv\u00adalent \ntoaskingwhether J is a safe interface for A. The teacher for subset queries checks, using a standard \nCTL model checker, whether J is a safe interface for the class Awith respect to E. The state space of \nthe interaction between Aand J, A||J, is de.ned as SA||J = {tA,tJ }\u00d7 M\u00d7 S \u00d7 Q.A state s =(tA,m,sA,q) \n. SA||J means that at the state s,the class A has turn , the currently executing method is m,and the \nclass Aand the interface J are in states sA and q, respectively. Transitions of A||J are as follows. \n Initially, the interface has turn and selects a method m. LM (q0) to be executed. Then, it passes turn \nto the class.  When the class gets turn (let s =(tA,m,sA,q)be the current state of A||J), the method \nm is simulated. The class keeps the turn until it reaches a state sA ' . S with s ' |= Rm, and then passes \nthe turn to the A interface with a return value r = sA' [Xr].  If the interface receives turn with \na return value r from the class (let s =(tJ ,m,sA,q) be the current  Boolean Member(String s) {Js := \nConstructInterface(s); if (Subset(Js)= null) then return true; else return false; } String Equivalent(Interface \nJ) {if ((cex := Subset(J)) = null) then cex := Superset(J); return cex ; } String Subset(Interface J) \n{A:= ReadAbstractClass (); . := AG (E = false); cex := CTLModelChecking(A||J,.); return cex ; } String \nSuperset(Interface J) {A:= ReadAbstractClass (); . := AG((legal =0 . turn = tJ ) . EF E); if ((cex := \nCTLModelChecking(A|||J,.)) = null) then { print ( L(J)is a superset of U. ); } else if (\u00acMember(cex )) \nthen {if ((cex := OneStepFurther (J)) = null) then print ( L(J) may or may not be a superset. ); } return \ncex ; } String OneStepFurther (Interface J) {foreach (q . Q)and (m,r),(m ' ,r ' ) . (M \u00d7 Sr) {if \u00acAccept \n(J,sq(m,r)(m ' ,r ' )) then if (Member(sq(m,r)(m ' ,r ' ))) then return sq(m,r)(m ' ,r ' ); } return \nnull; } Figure 4: Implementation of the L * teacher state of A||J), it changes its state to q ' = d(q,(m,r)) \nand picks a new method m ' . LM (q ' ). It then passes turn to the class and the interaction continues \nas be\u00adfore. A model checker checks (exhaustively) whether all the method-call return-value sequences \nallowed in J keep the class A away from states that satisfy E by checking whether A||J satis.es the CTL \nspeci.cation AG (\u00acE). If it does, then J is a safe interface and the answer to the subset query is true. \nOtherwise, the model checker gives a counter-example path of A||J that reaches a state where E = true. \nThe method-call return-value sequence extracted from this counter-example is provided to the learner \nas a counter-example string s . L(J) \\ U.  5.3.2 Superset query Given a conjecture interface J, the \nsuperset query asks whether the language of J is a superset of the language U (i.e., whether L(J) . U). \n The teacher for superset queries must checkthat .s . (M \u00d7 Sr) * , s/. L(J) . s/. U;that is, for every \nmethod\u00adcall return-value sequence s/. L(J), there is some run of the boolean class A corresponding to \nthe sequence s that does not stay within the safe set (E(X)= false). Wedonot know how to implement this \nexactly and e.ciently. Let us consider the computational complexity of the mem\u00adbership, subset and superset \nqueries to see why we think superset queries are inherently hard. Given a .nite class A, let the size \nof A be the sum of its methods, states, and tran\u00adsitions (i.e., the size of A is the the size of the \nclass when it is represented explicitly). Assume the safety predicate E is given as a subset of the states \nof the class. Now, given a conjecture strategy automaton J, the problem of check\u00ading whether A||J is \nsafe can be done in polynomial time (in fact in nondeterministic log-space). Similarly, member\u00adship queries \ncan be handled in polynomial time. However, it turns out that superset queries are NP-hard: Proposition \n1. Given an (explicit) class A,an unsafe set E and a strategy automaton J, checking whether there is \nsome string s/. L(J) such that L(J) .{s} is safe, is NP-hard. The proof of the above is by a reduction \nfrom 3-SAT ,and crucially uses the fact that the game is a partial information game; we omit the proof. \nWe hence turn to ways that heuristically and approxi\u00admately answer superset queries. Our .rst step is \nto pose a stronger property . that asks whether for every method\u00adcall return-value sequence s/. L(J), \nall runs of the boolean class A corresponding to the sequence s do not stay within the safe set (E(X)= \nfalse). Note that if the property . is true, then L(J) . U; otherwise, we cannot conclude whether L(J) \n. U or not. To checkthe property ., we de.ne a new interaction be\u00adtween Aand J, A|||J, that simulates \nlegal method sequences in J followed by atmostone method notallowed by J.The domain of A|||J is SA|||J \n= {tA,tJ }\u00d7 M \u00d7 S \u00d7 Q\u00d7{0,1}which adds a legal bit to SA||J . Transitions of A|||J are as follows. Initially, \nthe interface has turn and selects a method m . M.If m . LM (q0), it sets legal to 1, otherwise to 0. \nThen, it passes turn to the class.  When the class receives turn , the method m is sim\u00adulated in the \nsame manner as in A||J; however, if legal = 0, then at the end of the method the model halts and does \nnot return to the interface.  If the interface gets back turn with a return value r, let s =(tJ ,m,sA,q)bethe \ncurrent stateof A|||J (legal must be 1). Then, it moves from q to q ' = d(q,(m,r)),  picks a new method \nm ' . M,sets legal to0 i. m ' ./ LM (q ' ), and passes turn to the class. A model checker checks whether \nthe .rst method call not allowed by the interface J always leads to an unsafe state during its execution, \nby checking the following CTL speci.\u00adcation AG ((legal =0 . turn = tJ ) . EF E). Note that the above \nformula captures an inherently branching\u00adtime property and cannot be captured using linear temporal logic \nnor can be checked using a simple invariant checker. If A|||J satis.es the above speci.cation, the teacher \nan\u00adswers true for the superset query and the L * algorithm ter\u00adminates with an interface and reports \nthat it is the most permissive safe interface. Otherwise, the model checker pro\u00advides a counter-example \nwhich is a method-call return-value sequence s. By de.nition, there is at least one run corre\u00adsponding \nto s that is safe, but we do not know whether all runs corresponding to s are safe; hence we cannot return \ns as a counter-example to the superset query, as s may not be in U. We now checkwhether s is indeed in \nU by a mem\u00adbership query on s.If s is in U,then s is a witness for L(J) .U and is returned to the L * \nalgorithm to update the conjecture J.Otherwise, s is not in U and we discard it. If the above method \nfails to produce a counter-example, we turn to some heuristic ways to checkfor natural counter\u00adexamples \nthat the interface may have missed. By a property of the observation table, a conjecture interface always \nallows all the safe method calls from every state since the L * algo\u00adrithm checks membership for every \nstring s . S \u00b7 S(more precisely, s . (S . S\u00b7S) \u00b7 E) and allows calling a method m from a state s if s\u00b7m \nis a member. However, in the examples we have experimented with, there are often scenarios where a safe \nmethod call sequence m\u00b7m ' is disallowed from a par\u00adticular state q even though calling m guarantees \nthat calling m ' is safe. The reason is this: if q ' is the state reached from q on m, then there can \nbe another path to q ' that makes calling m ' from q ' unsafe. To .nd these counter-examples for superset \nqueries (in the above case, calling m\u00b7m ' at q), we checkwhether from ev\u00adery state the conjecture interface \nallows all the safe method call sequences of length 2 (procedure OneStepFurther). For\u00admally, we denote \none representative of the strings that reach q as sq (this representative is the one in the set S,in \nthe L * '' algorithm). We checkwhether .q . Q, (m, r), (m ,r ) . M \u00d7 Sr.sq(m, r)(m ' ,r ' ) ./L(J) . \nsq (m, r)(m ' ,r ' ) . U by traversing J and asking membership queries. If there exists ' ' '' sq (m, \nr)(m ,r ) satisfying the above, we use sq (m, r)(m ,r ) as a counter-example for the superset query. \nOtherwise, our synthesis terminates with the maximal safe interface J (maximality of J is assured by \nthe L * algorithm). In summary, the teacher for superset queries always pro\u00advides a counter-example to \nthe learner, or terminates and says true, and additionally may give the assurance that the superset query \nindeed was true. If it terminates with this assurance, then the L * algorithm has learned the most per\u00admissive \ninterface. If not, the L * algorithm has learned a safe interface that is guaranteed to be maximal. \n  6. EXPERIMENTS In this section, we report results obtained by using JIST on some sample Java classes. \nIn all cases, the tool could generate a useful and safe interface automatically using little computational \nresource. The original Java classes, interme\u00addiate forms (such as the abstracted Jimple .les) and results \nare available at http://www.cis.upenn.edu/jist/ . ListItr Class We present the class ListItr as the .rstexample. \nItis an inner class of AbstractList from the package java.util and supports random access for a list. \nIt has ten meth\u00adods. We focus on the following .ve: next(), remove(), previous(), set() and add().  \nFigure 5: List Iterator (1 predicate) (next. ).(prev. ) (prev.()  (add. ) (next.().(add.() Figure 6: \nListItr (2 predicates) The class is used to navigate and modify a list. Methods next and previous are \nused to traverse the list, add to add a new element, set and remove to modify/remove the last accessed \nelement. The last accessed element is tracked using an index into the list (called lastRet) and is updated \nby the next and previous methods. However, if remove or add are called, this variable is set to -1. If \nany of the methods remove or set is invoked when lastRet is -1, an exception is raised. The exception \npredicate we use corresponds to raising of this exception. The interface shown in Figure 5 is a safe \ninterface. How\u00adever, it is overly restrictive. While it allows calls to next(), previous() and add() \nmethods, it completely disallows calls to remove() and set(). The interface was produced using only one \npredicate, lastRet = -1, i.e. the predicate that triggers the raising of the IllegalStateException exception. \nThe value of lastRet is the index of element returned by most recent call to next or previous. It is \nreset to -1 if this element is deleted by a call to remove. In order to produce a more permissive interface, \nwe add one more predicate, cursor = -1, the predicate that is used as a test in the if statements in \nseveral of the methods. The value of cursor is the index of element to be returned by subsequent call \nto next. We need to keep track of whether or notitis equal to -1, because the code contains the as\u00adsignment \nlastRet = cursor . The resulting interface is shown in Figure 6. The high level description of this interface \nis that the methods next(), previous() must be called successfully (return 1) before remove or set can \nbe called. Furthermore, notice that: When a method is not allowed by the interface at a given state (i.e. \nthere are no outgoing edges labeled with the method s name), then it is not safe to call this method \n(because an exception might be raised). For example, the method set is not allowed at q0.As noted before, \nonly the .nal states of the automata are shown.  uninstall holdDown holdDown activate Figure 7: ServerTableEntry \nif there is an outgoing edge from a given state q for amethod m but the interface does not mention all \npossible return values m from q, it means that the return values that are missing are not feasible. For \nexample, the method next can not return 0 at q0. We also present a case when the ListItr class is abstracted \nusing an additional irrelevant predicate, expectedModCount = 0 (we checked manually that it was irrelevant). \nIn this case, the resulting interface is the same as the one we got with\u00adout it. This suggests that the \ntool is resilient to addition of irrelevant predicates, and we believe that an automatic tool for re.nement \nof predicates will not adversely change the quality of results of our tool. As mentioned previously, \nan interface for this class was computed by the tool presented in [32]. Their interface how\u00adever is not \nsound. For example, their interface declares that one can call remove after a call to prev; however, \nthere are situations where prev may fail (say when one is at the begin\u00adning of the list) in which case \nremove is not allowed. On the other hand, our interface is guaranteed to be safe: for exam\u00adple, in Figure \n6, if prev fails (i.e. after (prev, 0)), remove is disallowed. Our interface also gives more precise \ninfor\u00admation about possible return values: for example, Figure 6 says that calling prev initially will \nalways fail (i.e. return 0). ServerTableEntry Class ServerTableEntry from the package com.sun.corba.se.\u00adinternal.Activation \nis a class related to the server table for Corba objects. It has 19 methods. We choose the fol\u00adlowing \nsix: activate(), register(), registerPorts(), install(), uninstall(), holdDown() to construct the in\u00adterface. \nOnce users activate the system by activate(),they can enroll a server by register() and listeners network \nports by registerPorts(). After ports are registered, the user can install the server or uninstall it. \nUsers can call holdDown whenever they want. We produced the interface for the class using .ve predicates, \nstate =0, state =1, state =2, state =3 and state =4. The resulting interface is illustrated in Figure \n7. Once activate() is called, register or registerPorts can be called at q1. After the registration, \ninstall or uninstall are enabled at q2. holdDown() can be called at any state, and results in returning \nto the initial state q0. Signature Class The class Signature is taken form the package java.secu\u00adrity. \nThis class was described in Section 2. To produce the interface for this class, we used three predicates, \nstate = UNINITIALIZED, state = SIGN and state = VERIFY . The resulting interface is shown in Figure 1. \nIn order to demonstrate how such an interface can help a programmer to discover errors in programs, we \nconsider the Signature class with an arti.cially introduced error. We initSign initVerify update update \nverify initSign initSign initVerify initVerify Figure 8: Signature (programming error) (connect, \n*) flush (connect, 0) write(connect, 1) flush closeclose Figure 9: PipedOutputStream Class modify the \ninitSign method so that in some cases initial\u00adization may fail, thus not making it possible to guarantee \nthat the call to Sign is possible after a call to initSign. The interface produced in this case is in \nthe Figure 8 and the error is clearly visible: it is not possible to call the Sign method. PipedOutputStream \nClass The class PipedOutputStream from the package java.io is an implementation of an abstract class \nOutputStream.It has four methods, connect, write, flush, close. One property that the user of the class \nshould know is that it is necessary to call connect before calling write. This property is captured by \nthe interface produced by the JIST tool. The predicate sink = null was used in construct\u00ading the interface, \nbecause it is the predicate guarding the NullPointerException. Note that while creating this in\u00adterface, \nthe heuristic checkfor the natural counter-examples for the superset query was used. (Note: The prototype \nim\u00adplementation of our tool currently handles only predicates of the form var=integer constant ; so, \nthe abstraction step had to be done manually for this example. However, there is no di.erence conceptually \nbetween the predicates the tool handles and the predicate sink = null.) Experiments Summary All experiments \nwere performed on a PC using a 1GHz Pen\u00adtium III processor, 1.5GB memory and a Linux operating system. \nThe synthesis results for three classes are shown Ta\u00adble 6. It gives the number of predicates used for \nabstraction in the Java program, the number of derived predicates in the corresponding Jimple code (Jimple \nintroduces temporary variables corresponding to Java variables) and the number of variables in the NuSMV \nboolean model (this model has ad\u00additional boolean variables for handling the control .ow, like the program-counter). \nThe table also shows the number of membership, subset and superset queries that the learner asked in \nthe interface synthesis phase, whether the heuristic method (OneStepFurther) found a counter-example \nfor the superset query and the total execution time in seconds. The last column indicates whether it \nwas possible for the tool to conclude that the resulting interface is the most permissive one. Though \nthe tool could not conclude this in two cases, it turns out that even in these cases the interfaces generated \nwere indeed the most permissive ones. Class name Predicates in Java Predicates in Jimple Var MQ SubQ \nSuperQ OneStepFurther found a cex? Time (sec) Tool reports interface is most permissive? Signature 3 \n7 24 83 3 3 N/A 10.3 yes ServerTableEntry 5 9 25 53 3 3 N/A 9.2 yes ListItr (1 pred.) 1 5 20 35 1 1 no \n5.2 no ListItr (2 pred.) 2 17 29 288 5 2 N/A 83.4 yes ListItr (3 pred.) 3 19 31 288 5 2 N/A 101.8 yes \nPipedOutputStream 1 5 19 64 2 2 yes 6.0 no Table 1: Experimental results 7. CONCLUSIONS We have proposed \na technique for automatically synthesiz\u00ading behavioral interface speci.cations for Java classes using \nabstraction and games. Our initial prototype and experi\u00admentation shows promising results. The proposed \nsolution to computing the most permissive winning strategies in par\u00adtial information games using learning \nalgorithms and sym\u00adbolic model checking can be useful in contexts other than interface synthesis. There \nare many directions for future re\u00adsearch. First, the current tool handles a simple subset of Java. We \nwould like to develop similar techniques for ex\u00adtracting interfaces for a set of classes that call one \nanother, and for handling class and exception hierarchies. Second, the current tool allows only simple \nforms of predicates for abstraction. The abstractor can be made much more pow\u00aderful without sacri.cing \nautomation. Coupled with slicing techniques, this will lead to a robust toolkit that will per\u00admit extensive \nexperimentation. Finally, software veri.cation tools can address scalability using our tool for automatically \nabstracting classes by their interfaces for compositional ver\u00adi.cation, and this application deserves \nfurther exploration. Acknowledgments We thankGunjan Gupta and Anshuman Srivastava for their help in implementing \ncomponents of the JIST prototype. This research was partially supported by NSF award CCR\u00ad0306382 and \nARO URI award DAAD19-01-1-0473. 8. REFERENCES [1] S. Abramsky. Semantics of interaction. Technical report, \nOxford University, 2002. [2] R. Alur, T.A. Henzinger, and O. Kupferman. Alternating-time temporal logic. \nJournal of the ACM, 49(5):1 42, 2002. [3] G. Ammons, R. Bod\u00b4ik, and J. Larus. Mining speci.cations. In \nProc. 29th ACM POPL, pages 4 16, 2002. [4] D. Angluin. Learning regular sets from queries and counterexamples. \nInformation and Computation, 75:87 106, 1987. [5] T. Ball, R. Majumdar, T.D. Millstein, and S.K. Rajamani. \nAutomatic predicate abstraction of C programs. In Proc. PLDI, ACM SIGPLAN Notices 36(5), pages 203 213, \n2001. [6] T. Ball and S.K. Rajamani. The SLAM project: Debugging system software via static analysis. \nIn Proc. 29th ACM POPL, pages 1 3, 2002. [7] H.Barringer,C.S.Pasareanu andD.Giannakopolou. Proof rules \nfor automated compositional veri.cation through learning. In Proc. of the 2nd Int l Workshop on Speci.cation \nand Veri.cation of Component Based Systems, 2003. [8] T. Berg, B. Jonsson, M. Leucker, and M. Saksena. \nInsights to Angluin s learning. In Proc. of International Workshop on Software Veri.cation and Validation, \n2003. [9] A. Chakrabarti, L. de Alfaro, T.A. Henzinger, M. Jurdzinski, and F. Mang. Interface compatibility \nchecking for software modules. In Proc. 14th CAV, LNCS 2404, Springer, pages 428 441, 2002. [10] A. Cimatti, \nE. Clarke, E. Giunchiglia, F. Giunchiglia, M. Pistore, M. Roveri, R. Sebastiani, and A. Tacchella. NuSMV \nVersion 2: An Opensource tool for symbolic model  checking. In Proc. 14th CAV, LNCS 2404, Springer, \npages 359 364, 2002. [11] E.M. Clarke and E.A. Emerson. Design and synthesis of synchronization skeletons \nusing branching time temporal logic. In Proc. of Workshop on Logic of Programs, pages 52 71, 1981. [12] \nJ.M. Cobleigh, D. Giannakopoulou, and C.S. Pasareanu. Learning assumptions for compositional veri.cation. \nIn Proc. 9th TACAS, LNCS 2619, Springer, pages 331 346, 2003. [13] J. Corbett, M. Dwyer, J. Hatcli., \nS. Laubach, C.S. Pasareanu, Robby, and H. Zheng. Bandera: Extracting .nite-state models from Java source \ncode. In Proc. 22nd ICSE, pages 439 448, 2000. [14] P. Cousot and R. Cousot. Abstract interpretation: \na uni.ed lattice model for static analysis of programs by construction or approximation of .xpoints. \nIn Proc. 4th ACM POPL, pages 238 252, 1977. [15] P. Cousot and N. Halbwachs. Automatic discovery of linear \nrestraints among variables of a program. In Proc. 5th ACM POPL, pages 84 96, 1978. [16] L. de Alfaro \nand T.A. Henzinger. Interface automata. In Proc. 9th ACM FSE, pages 109 120, 2001. [17] R. DeLine and \nM. F\u00a8ahndrich. Enforcing high-level protocols in low-level software. In Proc. ACM POPL, pages 59 69, \n2001. [18] D. Giannakopoulou, C.S. Pasareanu and H. Barringer. Assumption generation for software component \nveri.cation. In Proc. 17th ASE, pages 3 12, 2002. [19] S. Graf and H. Saidi. Construction of abstract \nstate graphs with PVS. In Proc. 9th CAV, LNCS 1254, pages 72 83, 1997. [20] T.A. Henzinger, R. Jhala, \nR. Majumdar, K.L. McMillan. Abstractions from proofs. In Proc. 31st ACM POPL, pages 232 244, 2004. [21] \nT.A. Henzinger, R. Jhala, R. Majumdar, G. Necula, G. Sutre, and W. Weimer. Temporal-safety proofs for \nsystems code. In Proc. of CAV, LNCS 2404, pages 526 538. Springer, 2002. [22] G. Holzmann and M. Smith. \nSoftware model checking \u00adextracting veri.cation models from source code. In Formal Methods for Protocol \nEngineering and Distributed Systems, pages 481 497, 1999. [23] F. Logozzo. Automatic inference of class \ninvariants. In Proc. of VMCAI, LNCS 2937, pages 211 222, 2004. [24] J. Nimmer and M. Ernst. Automatic \ngeneration of program speci.cation. In Proc.ofISSTA, pages 229 239, 2002. [25] G. Ramalingam, A. Warshavsky, \nJ. Field, D. Goyal and M. Sagiv. Deriving specialized program analyses for certifying component-client \nconformance. In ACM PLDI, pages 83 94, 2002. [26] J.H. Reif. Universal games of incomplete information. \nIn Proc. of the 11th ACM symposium on Theory of computing, pages 288 308. ACM Press, 1979. [27] R. L. \nRivest and R. E. Schapire. Inference of .nite automata using homing sequences. Information and Computation, \n103(2):299 347, 1993. [28] W. Thomas. In.nite games and veri.cation. In Proc. 14th CAV, LNCS 2404, pages \n58 64. Springer, 2002. [29] O. Tkachuk, M.B. Dwyer, and C.S. Pasareanu. Automated environment generation \nfor software model checking. In Proc. 18th ASE, pages 116 127, 2003. [30] R. Vall\u00b4ee-Rai, L. Hendren, \nV. Sundaresan, E.G. Patrick Lam, and P. Co. Soot -a Java optimization framework. In Proc. CASCON, pages \n125 135, 1999. [31] D. Walker. A type system for expressive security policies. In Proc. 27th ACM POPL, \npages 254 267, 2000. [32] J. Whaley, M.C. Martin, and M.S. Lam. Automatic extraction of object-oriented \ncomponent interfaces. In Proc. ISSTA, pages 218 228, 2002.  \n\t\t\t", "proc_id": "1040305", "abstract": "While a typical software component has a clearly specified (static) interface in terms of the methods and the input/output types they support, information about the correct sequencing of method calls the client must invoke is usually undocumented. In this paper, we propose a novel solution for automatically extracting such temporal specifications for Java classes. Given a Java class, and a safety property such as \"the exception <i>E</i> should not be raised\", the corresponding <i>(dynamic) interface</i> is the most general way of invoking the methods in the class so that the safety property is not violated. Our synthesis method first constructs a symbolic representation of the finite state-transition system obtained from the class using <i>predicate abstraction</i>. Constructing the interface then corresponds to solving a <i>partial-information two-player game</i> on this symbolic graph. We present a sound approach to solve this computationally-hard problem approximately using algorithms for learning finite automata and symbolic model checking for branching-time logics. We describe an implementation of the proposed techniques in the tool <i>JIST</i>--- Java Interface Synthesis Tool---and demonstrate that the tool can construct interfaces accurately and efficiently for sample Java2SDK library classes.", "authors": [{"name": "Rajeev Alur", "author_profile_id": "81100359539", "affiliation": "University of Pennsylvania, Philadelphia, PA", "person_id": "P237979", "email_address": "", "orcid_id": ""}, {"name": "Pavol &#268;ern&#253;", "author_profile_id": "81100462652", "affiliation": "University of Pennsylvania, Philadelphia, PA", "person_id": "P707744", "email_address": "", "orcid_id": ""}, {"name": "P. Madhusudan", "author_profile_id": "81100489757", "affiliation": "University of Pennsylvania, Philadelphia, PA", "person_id": "PP14171410", "email_address": "", "orcid_id": ""}, {"name": "Wonhong Nam", "author_profile_id": "81100320493", "affiliation": "University of Pennsylvania, Philadelphia, PA", "person_id": "P682647", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1040305.1040314", "year": "2005", "article_id": "1040314", "conference": "POPL", "title": "Synthesis of interface specifications for Java classes", "url": "http://dl.acm.org/citation.cfm?id=1040314"}