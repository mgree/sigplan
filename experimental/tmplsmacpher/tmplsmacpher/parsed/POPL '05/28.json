{"article_publication_date": "01-12-2005", "fulltext": "\n Scalable Error Detection using Boolean Satis.ability Yichen Xie* Alex Aiken* Computer Science Department \nStanford University Stanford, CA 94305 {yxie,aiken}@cs.stanford.edu  ABSTRACT We describe a software \nerror-detection tool that exploits re\u00adcent advances in boolean satis.ability (SAT) solvers. Our analysis \nis path sensitive, precise down to the bit level, and models pointers and heap data. Our approach is \nalso highly scalable, which we achieve using two techniques. First, for each program function, several \noptimizations compress the size of the boolean formulas that model the control-and data-.ow and the heap \nlocations accessed by a function. Second, summaries in the spirit of type signatures are com\u00adputed for \neach function, allowing inter-procedural analysis without a dramatic increase in the size of the boolean \ncon\u00adstraints to be solved. We demonstrate the e.ectiveness of our approach by con\u00adstructing a lock interface \ninference and checking tool. In an interprocedural analysis of more than 23,000 lock related functions \nin the latest Linux kernel, the checker generated 300 warnings, of which 179 were unique locking errors, \na false positive rate of only 40%. Categories and Subject Descriptors D.2.4 [Software Engineering]: \nSoftware/ProgramVeri.\u00adcation; D.2.3 [Software Engineering]: Coding Tools and Techniques; D.2.5 [Software \nEngineering]: Testing and Debugging General Terms Algorithms, Experimentation, Languages, Veri.cation. \n Keywords Programanalysis, error detection, boolean satis.ability. * Supported by NFS grant CCF-0430378. \nPermission to make digital or hard copies of all or part of this work for personal or classroom use is \ngranted without fee provided that copies are not made or distributed for pro.t or commercial advantage \nand that copies bear this notice and the full citation on the .rst page. To copy otherwise, to republish, \nto post on servers or to redistribute to lists, requires prior speci.c permission and/or a fee. POPL \n05, January 12 14, 2005, Long Beach, California, USA. Copyright 2005 ACM 1-58113-830-X/05/0001 ...$5.00. \n1. INTRODUCTION This paper presents Saturn1 , a software error-detection tool based on exploiting recent \nadvances in solving boolean satis.ability (SAT) constraints. Rapid improvements in al\u00adgorithms for SAT \nhave led to its use in a variety of applica\u00adtions, including recently in programveri.cation [16, 17, \n19, 7, 11]. The contributions of our approach are: We give a translation from a realistic programming \nlanguage to SAT that is substantially more e.cient than previous approaches (Section 2). While we model \neach bit path sensitively as in [19, 8, 24], several tech\u00adniques achieve a substantial reduction in the \nsize of the SAT formulas Saturn must solve.  We describe how to compute a summary, similar to a type \nsignature, for each analyzed function (Section 4), thereby enabling interprocedural analysis. Comput\u00ading \nconcise summaries enables Saturn to analyze much larger programs than previous error checking systems \nbased on SAT, and in fact, the scaling behavior of Saturn is at least competitive with, if not better \nthan, other, non-SAT approaches to bug .nding and veri.\u00adcation. In addition, Saturn is able to infer \nand apply summaries that encode a form of interprocedural path sensitivity via input and output predicates, \nlending it\u00adself well to checking complex value-dependent program behaviors (Section 5.2).  We present \nan interface for de.ning temporal safety properties for Saturn to check, and we show one such speci.cation \nin detail: checking that a single thread correctly manages locks i.e., does not perform two lock or unlock \noperations in a row on any lock (Sec\u00adtion 5.5).  We present a signi.cant experiment in which we per\u00adforman \ninterprocedural analysis of the entire Linux kernel for locking errors (Section 6). In analyzing 4.8 \nmillion lines of code, Saturn generated 300 warnings, of which 179 were unique locking errors, for a \nfalse pos\u00aditive rate of only 40% (i.e., more than half of the warn\u00adings were genuine bugs). For comparison, \ntwo previous studies of the same locking properties using MC [13] and CQual [12] found 31 and 18 locking \nerrors respec\u00adtively, with higher false positive rates (above 80% for both MC and CQual i.e., fewer than \n1 in 5 warnings is a genuine bug) [2, 10, 12].  1SATis.ability-based failURe aNalysis. We have built \na database of all the inferred locking signatures of functions in the Linux kernel. We re\u00adport some interesting \nstatistics, showing that locking behavior in Linux is quite complex and that much of the kernel relies \neither directly or indirectly on correct locking behavior (Section 6.2). It is worth noting that Saturn \ncan do more than analyz\u00ading locks, although we do not report on additional checkers here. Locking analysis \nhas become a standard test case for bug .nding/veri.cation tools, because in practice analyzing locking \nrequires accurate modeling of many features: lock\u00ading is always a .ow sensitive and sometimes a path \nsensitive property, programmers store locks in data structures, pass locks as arguments, use complex \ntests to decide when and where to acquire and release locks, and so on. One thing that Saturn is not, \nat least in its current form, is a veri.cation tool. Tools such as CQual are capable of veri.cation (proving \nthe absence of bugs, or at least as close as one can reasonably come to that goal for C programs). Saturn \nis a bug .nding tool in the spirit of MC, which means it is designed to .nd as many bugs as possible \nwith a low false positive rate, potentially at the cost of missing some bugs. In particular, Saturn currently \nis unsound in its anal\u00adysis of loops (see Section 2) because it is not possible in most cases to construct \na .nite boolean formula represent\u00ading a fully unrolled loop. This problemis shared by all SAT-based analysis \nsystems (see, e.g., [19, 24]) and we leave further investigation as future work. Another source of unsoundness \nis Saturn s treatment of pointers in a function s environment. In order to reduce false positives, Saturn \nmakes the assumption that distinct pointers fromthe environment do not alias each other. The same treatment \nis a.orded to pointer values obtained from aspects of the C language that Saturn does not currently model \n(e.g., arrays, unions, inline assembly, unsafe casts, and function pointers). A sound alternative is \nto use a sep\u00adarate global alias analysis to account for potentially missed aliasing relationships. The \ntreatment of external pointers is further discussed in Section 3.2.  2. THE SATURN FRAMEWORK In this \nsection, we present a low-level programming lan\u00adguage and its translation into our error detection framework. \nBecause our implementation targets C programs, our lan\u00adguage models scalars, structures, pointers, and \nhandles the arbitrary control .ow2 found in C. We begin with a lan\u00adguage and translation that handles \nonly scalar programval\u00adues (Section 2.1), and gradually add features until we have presented the entire \nframework: arbitrary intraprocedural control .ow including loops (Section 2.2), structures (Sec\u00adtion \n2.3), and .nally pointers (Section 2.4). In Section 3 we consider some techniques that substantially \nimprove the performance of our translation. 2.1 Scalar Translation Figure 1 presents a grammar for a \nscalar language. The parenthesized symbol on the left hand side of each produc\u00ad 2The current implementation \nof Saturn handles reducible .ow-graphs, which are by far the most common form even in C code. Irreducible \n.ow-graphs can be converted to re\u00adducible ones by node-splitting [1]. Language Type (t) ::= (n,signed \n|unsigned) Obj (o) ::= v Expr (e) ::= unknown(t) |const(n,t) |o |unop e |e1 binop e2 |(t) e |lifte(c,t) \nCond (c) ::= false |true |\u00acc |e1 comp e2 |c1 .c2 |c1 .c2 |liftc(e) Stmt (s) ::= o .e |assert(c) |assume(c) \n|skip unop .{-,!}binop .{+,-,*,/,mod,band,bor,xor,\u00ab,\u00bbl,\u00bba}comp .{=,>,=,<,=,= } Representation Rep (\u00df) \n::= [bn-1 ...b0]s where s.{signed,unsigned}Bit (b) ::= 0 |1 |x |b1 .b2 |b1 .b2 |\u00acb Figure 1: A scalar \nlanguage. tion is a variable ranging over elements of its syntactic cat\u00adegory. The language is statically \nand explicitly typed; the type rules are completely standard and for the most part we elide types for \nbrevity. There are two base types: booleans (bool) and n-bit signed or unsigned integers (int). Note \nthe base types are syntactically separated in the language as expres\u00adsions, which are integer-valued, \nand conditions, which are boolean-valued. We use t to range solely over di.erent types of integer values. \nThe integer expressions include constants (const), integer variables (v), unary and binary operations, \ninteger casts, and lifting fromconditionals. We give the list of operators that we model precisely using \nboolean formulas (e.g. +, -, bitwise-and, etc.); for other operators (e.g., division, re\u00admainder, etc.), \nwe make approximations. We use a special expression unknown to model unknown values (e.g., in the environment) \nand the result of operations that we do not model precisely. Objects in the scalar language are n-bit \nsigned or un\u00adsigned integers, where n and the signedness are determined by the type t. As shown at the \nbottomof Figure 1, a separate boolean expression models each bit of an integer and thus tracking the \nwidth is important for our transla\u00adtion. The signed/unsigned distinction is needed to precisely model \nlow-level type casts, bit shift operations, and arith\u00admetic operations. The class of Objects (Obj) ultimately \nincludes variables, pointers, and structures, which encompass all the entities that can be the target \nof an assignment. For the moment we describe only scalar variables. The translation for a representative \nselection of constructs is shown in Figure 2; the translations for the omitted cases introduce no new \nideas. The translation rules for expressions have the form .\u00df Expressions which means that under the \nenvironment . mapping vari\u00adables to vectors of boolean expressions (one for each bit in \u00df = .(v) .\u00df EE \n. fe scalar the variable s type), the expression e is translated to the . fv .b vectorofbooleanexpressions \n\u00df. Thetranslationschemeforconditionals C (n,s)= t . fc x0,...,xn-1 are fresh boolean variables .[x E \nunknown . funknown(t) n-1 ...x0]s is similar, except the target is a single boolean expression b modeling \nthe condition. The most interesting rules are for statements, which have the form .[b<bi if 0 =i<n E \n. fe n-1 ...b0]x t =(m,s) . S . bn-1 if s= signed and n =i<m which means that under guard Gand variable \nenvironment G'; .'\u00b8 G,. fs b'i =0 if s= unsigned and n=i<m : E cast . the statement s results in a new \nguard/environment pair .[b' m-1 ...b'0]s . f(t) e (G'; .'). In our system, guards express path sensitivity; \nev\u00adery statement is guarded by a boolean expression express\u00ad .b .[00 \u00b7\u00b7\u00b70 b]s cute. Most statements \ndo not a.ect guards (the exception is | {z } assume); the important operations on guards are discussed \nin Section 2.2. A key statement in our language is assert, which we use to express points at which satis.ability \nqueries n-1 .[bn-1 ...b0]s .[b C EE E (n,s)= t. fc . flifte(c,t) E ing the conditions under which that \nstatement may exe\u00ad lifte . fe must be checked. A statement assert(c) checks that \u00acc ' .[b' n-1 ...b'0]s \n. fe and cannot be true at that programpoint by computing the sat\u00ad ' n-1 .b'0]s n-1 ...b0 .b' . fe band \nis.ability of G.\u00acb,where bis the translation of the condition ec. The overall e.ect of our translation \nis to performstraight\u00adforward symbolic execution, cast in terms of boolean ex- Conditionals .[b. fliftc(e) \nE pressions. Each statement transforms an environment into . fe n-1 ...b0]s W . C liftc a new environment \n(and guard) that captures the e.ect of bi the statement. If all bits in the initial environment .0 are \ni concrete 0 s and 1 s and there are no unknown expressions in the programbeing analyzed, then in fact \nthis translation is exactly symbolic execution and all modeled bits can them\u00adselves be reduced to 0 s \nand 1 s. However, bits may also be Statements .\u00df SEC.b S . fe assign boolean variables (unknowns). Thus \neach bit b represented .\u00df]) G,. f(v .e) . fc .(G; .[v in our translation may be an arbitrary boolean \nexpression over such variables. assume  2.2 Control Flow .(G.b; .) G,. fassume(c) We represent function \nbodies as control-.ow graphs, which we de.ne informally. Each statement s is a node in the assert-ok \ngraph, and each edge (s,s') represents an unconditional trans\u00ad C.b . fc S (G.\u00acb) not satis.able .(G; \n.) G,. fassert(c) fer of control from s to s'. If a statement has multiple suc\u00adcessors, then execution \nmay be transferred to any successor non-deterministically. Figure 2: The translation. To model the deterministic \nsemantics of conventional pro\u00adgrams, we require that if a node has multiple successors, then each successor \nis an assume statement, and further\u00admore, that the conditions in those assumes are mutually  exclusive \nand that their disjunction is equivalent to true. MergeScalar v,(Gi,.i) =[b'...b'0]s m Thus a conditional \nbranch with predicate p is modeled by a . [bim ...bi0]s = .i(v) statement with two successors: one successor \nassumes p(the W where b'j = i(Gi .bij ) true branch) and the other assumes \u00acp (the false branch). .W \n\u00b8 The other important issue is assigning a guard and en- MergeEnv (Gi,.i)= Gi; . i vironment to each \nstatement s. Assume s has an ordered where .(v)= MergeScalar v,(Gi,.i) list of predecessors si. 3 The \ntranslation of si produces an environment .i and guard Gi. The initial guard and en\u00advironment for s is \nthen a combination of the .nal guards Figure 3: Merging control-.ow paths. 3We use the notation Xi as \na shorthand for a vector of similar entities: X1 ...Xn. and environments of its predecessors. The desired \nguard is simply the disjunction of the predecessor guards; as we may arrive at sfromany of the predecessors, \nsmay be executed if any predecessor s guard is true. Note that due to the mutual exclusion assumption \nfor branch conditions, at most one of the predecessor s guard can be true at a time. The desired environment \nis more complex, as we wish to preserve the path-sensitivity of our analysis down to the bit level. Thus, \nthe value of each bit of each variable in the environment for each predecessor si of s must include the \nguard for si as well. This motivates the function MergeScalar in Figure 3, which implements a multiplexer \ncircuit that selects the ap\u00adpropriate bits fromthe input environments (.i(v)) based on the predecessor \nguards (Gi). Finally, MergeEnv combines the two components together to de.ne the initial environment \nand guard for s. Preserving path sensitivity for every modeled bit is clearly expensive and it is easy \nto construct realistic examples where the number of modeled paths is exponential in the size of the control-.ow \ngraph. In Section 3.3 we present an op\u00adtimization that enables us to make this approach work in practice. \nFinally, every control-.ow graph has a distinguished entry statement with no predecessors. The guard \nfor this initial Language Type (t) ::= {(f1,t1),...,(fn,tn)}| ... Obj (o) ::= {(f1,o1),...,(fn,on)}| \n... Shorthand o= {(f1,o1),...,(fn,on)} .eld-access def o.fi = oi Representation Rep (\u00df) ::= {(f1,\u00df1),...,(fn,\u00dfn)}| \n... Translation o = {(f1,o1),...,(fn,on)} E . foi .\u00dfi for i .1..n object-str E . fo .{(f1,\u00df1),...,(fn,\u00dfn)} \nRecAssign(.,v,\u00df)= .[v .\u00df] statement is true. We postpone discussion of the initial environment .0 to \nSection 3.2 where we describe the lazy modeling of the external execution environment. where As mentioned \nin Section 1, we treat loops unsoundly. 8 >>< >>: RecAssign(.,o,\u00df)= . n o = {(f1,o1),...,(fn,on)} \u00df \n= {(f1,\u00df1),...,(f.0 = . n,\u00dfn)} .i = RecAssign(.i-1,oi,\u00dfi)(.i.1..n) Loops are simply unrolled a number \nof times and the backedges removed from the control-.ow graph. Thus, every function E . fe.\u00df body is \nrepresented by an acyclic control-.ow graph. While ' this handling of loops is unsound and a limitation \nof our cur\u00adrent approach, we have found it to be e.ective in practice (see Section 6).  2.3 Structures \nThe programsyntax and translation of structures is given in Figure 4. A structure is a data type with \nnamed .elds, which we represent as a set of (.eld name,object)pairs. We extend the syntax of types (resp. \nobjects) with sets of types (resp. objects) labeled by .eld names, and similarly the rep\u00adresentation \nof a struct in C is the representation of the .elds also labeled by the .eld names. The shorthand notation \no.fi selects the object of .eld fi fromobject o. The function RecAssign does the work of structure assign\u00adment. \nAs expected, assignment of structures is de.ned in terms of assignments of its .elds. Because structures \nmay themselves be .elds of structures, RecAssign is recursively de.ned. 2.4 Pointers The .nal and technically \nmost involved construct in our translation is pointers. The basic idea is to maintain path sensitivity \nfor heap locations, as we do for variables in the environment. As with variables, we must allow for the \npointer to have di.erent values (point to di.erent locations) depend\u00ading on the execution history (the \nguard). The language def\u00adinition and translation rules are given in Figure 5 and 6. Pointers point to \nlocations, which are either an object o or the constant null (i.e., a null pointer). A guarded location \nis a pair of a guard and a location. A guarded location set (GLS),which we write as {| ... |}to distinguish \nfromother . = RecAssign(.,o,\u00df) assign-struct S G,. f(o .e) .(G; . ' ) Figure 4: Translation of structures. \nkinds of sets, is a set of guarded locations. We de.ne {| ...,(G,l),(G ' ,l),... |}={| ...,(G.G ' ,l),... \n|} and we assume that a GLS is normalized using this equiva\u00adlence so that a location occurs at most once \nin the set. We adopt the convention that the guard for null is listed .rst with guard G0. We brie.y explain \nthe rules in Figure 5. As shown in the rule pointer, the mapping from pointers to GLS s is part of the \nenvironment. Taking the address of an object (rule getaddr-obj) simply creates aGLS with asingle entry \nthe object itself with no guard (the guard true). Taking the address of a series of .eld dereferences \nfroma pointer means taking each location the pointer could point to and creating a guarded location fromthe \nobject reached by performing the .eld dereferences.4 The rule liftc-pointer expresses that a pointer \ntreated as a condition is true if it is non-null. The rule malloc creates a fresh object that is the \ntarget of the malloc d pointer. Note that malloc is silent on the contents of the new object; there are \ndi.erent choices (all bits zero, all bits unconstrained) depending on the analysis application and what \none assumes about the memory allocator. The rule store models an indirect assignment through a pointer, \n4 The treatment of null here is needed to be consistent with the ANSI C standard. Language Type (t) ::= \nt pointer | ... Obj (o) ::= p | ... Deref (m) ::= p.f1.\u00b7\u00b7\u00b7 .fn Expr (e) ::= null | &#38;o | &#38;m | \n... Stmt (s) ::= load(m,o) | store(m,e) | malloc(p) | ... Representation Loc (l) ::= null | o Rep (\u00df) \n::= {| (G1,l1),...,(Gk,lk) |} | ... Translation \u00df = .(p) pointer E . fp.\u00df getaddr-obj E . f&#38;o.{| \n(true,o) |} m= p.f1.\u00b7\u00b7\u00b7 .fn E . fp.{| (G0,null),(Gi,oi) |}\u00df = {| (G0,null),(Gi,oi.f1.\u00b7\u00b7\u00b7 .fn) |} getaddr-mem \nE . f&#38;m.\u00df .(p)= {| (G0,null),(Gi,oi) |} CW liftc-pointer . fliftc(p) . i.Gi =0 \u00df = {| (true,o) |} \n(o fresh) malloc S G,. fmalloc(p) .(G; .[p.\u00df]) m= p.f1.\u00b7\u00b7\u00b7 .fn E . fp.{| (G0,null),(G1,o1),...,(Gk,ok) \n|} G ' = G.\u00acG0 S G ' .Gi,. f(oi.f1.\u00b7\u00b7\u00b7 .fn .e) .(Gi; .i) (for i .1..k) store S G,. fstore(m,e) .MergeEnv \n(Gi; .i) Figure 5: Pointers and guarded location sets. Merging AddGuard (G,{| (G1,l1),..,(Gk,lk) |})= \n{| (G.G1,l1),..,(G.Gk,lk) |} S MergePointer p,(Gi,.i)= i AddGuard(Gi,.i(p)) .W \u00b8 MergeEnv (Gi,.i)= Gi; \n. 8 i <.(v)= MergeScalar v,(Gi,.i) where :.(p)= MergePointer p,(Gi,.i) Figure 6: Control-.ow merges \nwith pointers. possibly involving .eld dereferences, by combining the re\u00adsults for each possible location \nthe pointer could point to. The line G ' = G.\u00acG0 adds an assumption that the pointer is not null; if \nwe are interested in null-pointer checks that can be done by a separate null-pointer checker built on \nour framework. We omit the rule for load, as it is very similar to store.  3. DISCUSSION AND IMPROVEMENTS \nIn this section, we discuss how our translation reduces the size of satis.ability queries by achieving \na formof program slicing. We also discuss two improvements to our approach. The .rst (Section 3.2) concerns \nhow we treat inputs of un\u00adknown shape to functions and the second (Section 3.3) is an optimization that \ngreatly reduces the cost of guards. 3.1 Automatic Slicing Programslicing is a technique to simplify a \nprogramby removing the parts that are irrelevant to the property we are interested in. Slicing is commonly \ndone by comput\u00ading control and data dependencies and preserving only the statements that the property \ndepends on. We show that our translation automatically slices a program and only uses clauses that the \ncurrent SAT query requires. Consider the following programsnippet below: if (x) y = a; else y= b; z= \n/* complex computation here */; if (z) ... else .. .; assert(y < 5); The computation of z is irrelevant \nto the property we are checking (y< 5). The variable y is data dependent on a and b and control dependent \non x. Using the translation rules in Section 2, we see that the translation of y< 5 only involves the \nbits in x, a,and b, but not z,because the assign rule accounts for the data dependencies and the merge \nrule pulls in the control dependency, and nothing else is included. Because properties of interest often \ndepend on a small portion of the program, this design helps keep the size of SAT queries under control. \n 3.2 Lazy Construction of the Environment A standard problemin modular programanalysis systems is the \nmodeling of the external environment. In particular, we need a method to model and track data structures \nused, but not created by the code fragment being analyzed. There is no consensus on the best solution \nto this problem. To the best of our knowledge, SLAM [4] and Blast [15] re\u00adquire manual construction of \nthe environment. For example, to analyze a module that manipulates a linked list of locks de.ned elsewhere, \nthese systems likely require a harness that populates an input list with locks. The problemis reduced \nas the target code-bases (e.g., Windows drivers in the case for SLAM) can often share a carefully crafted \nharness (e.g., a model for the Windows kernel) [3]. Nevertheless, the need to close the environment represents \na substantial manual e.ort in the deployment of such systems. Because we achieve scalability by computing \nfunction sum\u00admaries, we must analyze a function independent of its calling context and still model its \narguments. Our solution is sim\u00adilar in spirit to the lazy initialization algorithmdescribed in [18]. \nRecall in Section 2, values of variables referenced but not created in the code, i.e., those fromthe \nexternal en\u00advironment, are de.ned in the initial evaluation environment .0. Saturn lazily constructs \n.0 by calling a special function DefVal, which is supplied by the analysis designer and maps all external \nobjects to a checker-speci.c estimation of their default values. .0 is then de.ned as DefVal(v) for all \nv.Op\u00aderationally, DefVal is applied lazily, only when uninitialized objects are encountered during symbolic \nevaluation. This allows us to model potentially unbounded data structures in the environment. Besides \nits role in de.ning the initial environment .0, DefVal is also used to provide an estima\u00adtion of the \nreturn values and side-e.ects of function calls (Section 5.3). In our implementation, we model scalars \nfrom the envi\u00adronment with a vector of unconstrained boolean variables. For pointers, we use the common \nassumption that distinct pointers fromthe environment do not alias each other. This can be modeled by \na DefVal that returns a fresh location for each unknown pointer dereference.5 A sound alternative would \nbe to use a separate global alias analysis as part of the de.nition of .0. Note once a pointer is initialized, \nSaturn performs an accurate intraprocedural path-sensitive analy\u00adsis, including respecting alias relationships, \non that pointer. 3.3 Using BDDs for Guards Consider the following high-level code fragment: if c then \n... else ... ;s After translation to a control-.ow graph, there are two paths reaching the statement \ns with guards c and \u00acc.Thus the guard of s is c .\u00acc. Since guards are attached to every bit of every \nmodeled location at every program point, it is important to avoid growth in the size of guards at ev\u00adery \ncontrol-.ow merge. One way to accomplish this task is to decompile the unrolled control .ow graph into \nstruc\u00adtured programs with only if statements, so that we know exactly where the branch conditionals cancel. \nHowever, this approach requires code duplication in the presence of goto, break,and continue statements \ncommonly found in C. Our solution is to introduce an intermediate representa\u00adtion of guards using binary \ndecision diagrams [5]. We give each condition (which may be a complex expression) a name and use a BDD \nto represent the boolean combination of all conditions that enable a programpath. At control-.ow merges \nwe join the corresponding BDDs. The BDD join op\u00aderation can simplify the representation of the boolean \nfor\u00admula to a canonical form; for example, the join of the BDDs for c and \u00acc is represented by true. \nIn our translation of a statement, we convert the BDD representing the set of conditions at that programpoint \nto the appropriate guard. The simpli.cation of guards also eliminates trivial control dependencies in \nthe automatic slicing scheme described in Section 3.1. In the small example in that section, had we not \nsimpli.ed guards, the assertion would have been checked under the guard (x .\u00acx) . (z .\u00acz), which pulls \nin the otherwise irrelevant computation of z. 5In the implementation, DefVal(p) returns {| (G,null),(\u00acG,o) \n|},where G is an unconstrained bit variable, and o is a fresh object of the appropriate type. This allows \nus to model common data structures like linked lists and trees of arbitrary length or depth. A slightly \nsmarter variant handles doubly linked lists and trees with parent pointers knowing one node in such a \ndata structure.  4. INTERPROCEDURAL ANALYSIS The misspeci.cation and misunderstanding of function in\u00adterface \nconstraints is a major source of errors in large soft\u00adware systems. To detect such errors, we must perform \nin\u00adterprocedural analysis. There are two well known approaches to interprocedural analysis: function \ninlining and compositional analysis based on summaries. Inlining is a simple technique used by a num\u00adber \nof whole programanalysis algorithms to analyze beyond function boundaries (e.g., [19, 14]). However, \nit discards natural boundaries in software systems and may lead to ex\u00adponential explosion in code size. \nTherefore, this approach does not readily scale to the size of systems we aim to check. In a summary-based \napproach, each function or module is abstracted into a concise representation which summarizes the observable \nbehavior of the function with regard to some property. The bene.t is two fold: First, the summary for \na particular function can be computed once and used at all call sites, thereby avoiding redundant analysis. \nSecond, a function summary is usually expressed in terms of an ab\u00adstraction of the observable behavior \nof a function, thereby hiding irrelevant details of the function and simplifying the analysis of its \ncallers without losing relevant information. However, .nding the right abstraction is crucial, especially \nfor bug detection systems where being overly conservative translates into large false positive rates, \ngreatly reducing the usefulness of the tool. We provide a query-response interface that allows a user\u00adde.ned \nchecker to compute function summaries by posing satis.ability queries about programexecution. In the \nfollow\u00ading section, we give an inference and checking framework for .nite state properties, also known \nas temporal safety prop\u00aderties, using Saturn. 5. CHECKING FINITE STATE PROPERTIES Finite state properties \nare a class of speci.cations that can be described as certain programvalues passing through a .nite set \nof states, over time, under speci.c conditions. Locking, where a lock can legally only go fromthe unlocked \nstate to the locked state and then back to the unlocked state, is a canonical example. These properties \nare also referred to as temporal safety properties. In this section, we focus on .nite state properties, \nand de\u00adscribe a summary based interprocedural analysis that uses the Saturn framework to automatically \ncheck such proper\u00adties. We start by de.ning a common name space for shared objects between the caller \nand the callee (Section 5.1), which we use to de.ne a general summary representation for .\u00adnite state \nproperties (Section 5.2). We then describe algo\u00adrithms for applying (Section 5.3) and inferring (Section \n5.4) function summaries in the Saturn framework. We conclude by describing our implementation of an interprocedural \nlock checker (Section 5.5). 5.1 Interface Objects In C, the two sides of a function invocation share \nthe global name space, but have separate local name spaces. Thus we need a common name space for objects \nreferred to in the summary. Barring external channels and unsafe mem\u00adory accesses, the two parties share \nvalues through global variables and parameters. Therefore, shared objects can be named using a path from \none of these two roots. We formalize this idea using interface objects (IObj)as common names for objects \nshared between caller and callee: IObj (l) ::= parami |global var |ret val |*l |l.f Dependencies across \nfunction calls are expressed by inter\u00adface expressions (IExpr) and conditions (ICond), which are de.ned \nrespectively by replacing references to objects with interface objects in the de.nition of Expr and Cond \n(as de\u00ad.ned in Figure 1, and extended in Figure 5). To performinterprocedural analysis of a function, \nwe must map input interface objects to the names used in the func\u00adtion body, performsymbolic evaluation \nof the function, and map the .nal function state to the .nal state of the interface objects. Thus, we \nneed two mappings to convert between interface objects and those in the native name space of a function: \n-1 [[\u00b7]]args : IObj .Objext and [ \u00b7]]args : Obj .IObj Converting IObj s to native objects is straightforward. \nFor function call r = f(a0,...,an), [[global]]a0...an = global [[parami]]a0...an = ai [[ret val]]a0...an \n= r [[*l]]a0...an = *([[l]]a0...an ) [[l.f]]a0...an =([ l]]a0...an ).f The range of the conversion is \nObjext , which allows deref\u00aderencing of pointers inside the expression. This feature is not in the language \nde.ned in Section 2, but can be elimi\u00adnated by using temporary variables and explicit load/store operations. \nThe inverse conversion is more involved, since there may be multiple aliases of the same object in the \nprogram. We incrementally construct the [ \u00b7]]-1 mapping for objects ac\u00ad args cessed through global variables \nand parameters. For exam\u00adple, in void f(struct str *p) {spin lock(&#38;p->lock); } the corresponding \ninterface object for p is param0, since it is de.ned as the .rst formal parameter of f. Recall that the \nobject pointed to by p.lock is lazily instantiated when p is dereferenced by calling DefVal(p) (see Section \n3). As part of the instantiation, we initialize every .eld of the struct (*p), and compute the appropriate \nIObj foreach.eldat that time. Speci.cally, the interface object for p.lock is (*param0).lock. The conversion \noperations extend to interface expressions and conditionals. For brevity, name space conversions for \nobjects, expressions, and conditionals are mostly kept im\u00adplicit in the discussion below. 5.2 Function \nSummary Representation The language for expressing .nite state summaries is given in Figure 7. Each function \nsummary is a four-tuple consist\u00ading of: a set of input predicates Pin,  a set of output predicates \nPout,  a set of interface objects M,which may be modi.ed during the function call, and  arelation R \nsummarizing the FSM behavior of the function.    FSM States S = {Error,s1,...,sn} Summaries S= (Pin,Pout,M,R) \nwhere Pin = {p1,...,pn} pi .ICond, Pout = {q1,...,qn} qi .ICond, M .IObj,and R .IObj \u00d72|Pin| \u00d7S\u00d72|Pout| \n\u00d7S Figure 7: Function summary representation. The checker need only supply the set of FSM states and \nthe input and output predicates; both M and R are computed automatically for each function by Saturn \n(see Section 5.4). The FSM behavior of a function call is modeled as a set of state transitions of one \nor more interface objects. These transitions map input states to output states based on the values of \na set of input (Pin) and output predicates (Pout). The state transitions are given in the set R.Each \nelement in R is a .ve tuple: (sm,incond,s,outcond,s ' ), which we describe below: sm .IObj is the object \nwhose state is a.ected by the transition relationship. In the lock checker, sm identi\u00ad.es the accessed \nlock objects, as a function may access more than one lock during its execution.  incond . 2|Pin| is \nused to denote the input condition  VV ( pi).( \u00acpi)where Pin = {p1,...,pn}. i.incond i/.incond The value \nof incond is evaluated on entry to the func\u00adtion. s.S is the initial state of sm in the state transition. \n outcond .2|Pout| is de.ned like incond and denotes the output condition of the transition. outcond is \nevalu\u00adated on exit.  s ' .S is the state of sm after the transition.  Figure 8 presents the summary \nof three sample locking functions: spin lock, spin trylock,and complex wrapper.The function complex wrapper \ncaptures some of the more compli\u00adcated locking behavior in Linux. Nevertheless, we are able to express \nits behavior using our summary representation. We describe how function summaries are inferred and used \nin the following subsections. 5.3 Summary Application This subsection describes how the summary of a \nfunction is used to model its behavior at a call site. For a given function invocation f(a0,...,an), \nwe translate the call into a set of statements simulating the observable e.ects of the function. The \ntranslation, given in Figure 9, is composed of two stages: 1. In the .rst stage, we save the values of \nrelevant pro\u00adgramstates before and after the call (line 3-4 and 8 in Figure 9), and account for the side \ne.ects of the function by conservatively assigning unknown values to objects in the modi.ed set M (line \n6). Relevant values before the call include all input predicates pi, and the current states (smi) of \nthe interface objects mentioned in the transition relation R. Relevant val\u00adues after the call include \nall output states qi.We then void complex wrapper(spinlock t*l, int .ag, int *success) { if (.ag) *success \n= spin trylock(l); Assumption else {spin unlock(l); *success = 1; } S(f)= (Pin,PPin 8 >>>< out,M,R) } \n= {p1,...,pout = {q1,...,q m} P States: S = {Error =0,Locked =1,Unlocked =2} n}M = {o1,...,ok} Summary: \nS= (M,R,Pin,Pout) spin lock : Input: Pin = {} Pout = {}Output: M = {*param0}R = { (*param0, ,Unlocked, \n,Locked), (*param0, ,Locked, ,Error)} spin trylock : Input: Pin = {} Pout = {liftc(ret val)} Output: \nM = {*param0,ret val} R = { (*param0, ,Unlocked,true,Locked), (*param0, ,Unlocked,false,Unlocked), \n(*param0, ,Locked, ,Error)}    where R >>>: ' = {(sm1,incond1,s1,outcond1,s (sml,incondl,sl,outcondl,sl)} \n1),..., ' Instrumentation 1: (* Stage 1: Preparation *) 2: (* save useful program states *) 3: pb1 . \np1; ...; pbn . pm; 4: csml . sml;sm1 . sm1; ...; c 5: (* account for the side-e.ects of f *) 6: o1 . \nunknown(to1 ); ...; ok . unknown(tok ); 7: (* save the values of output predicates *) 8: q1 ' . q1; ...; \nqn ' . qn; complex wrapper : Input: Pin = {liftc(param1)} Pout = {liftc(*param2)} Output: M = {*param0,*param2} \n R = { (*param0,true,Locked, ,Error) (*param0,true,Unlocked,true,Locked) (*param0,true,Unlocked,false,Unlocked) \n(*param0,false,Unlocked,true,Error) (*param0,false,Locked,true,Unlocked)} Figure 8: Sample function summaries \nfor the locking property. use an assume statement to rule out impossible combi\u00adnations of input predicates \nand output predicates (line 10; e.g., some functions always return a non-NULL pointer). 2. In the second \nstage, we process the state transitions in R by .rst testing their activation conditions, and when satis.ed, \ncarrying out the transitions (line 14-  W 9: (* rule out infeasible comb. of incond and outcond *) 10: \nassume( i(smi = si . incondi . outcondi)); 11: 12: (* Stage 2: Transitions *) 13: (* record state transitions \nafter the function call *) 14: if (smc1 = s1 . incond1 . outcond1) sm1 . s1' ; 15: ... 16: if (c= sl \n. incondl . outcondl) sml . s ' l; sml Figure 9: Summary application. Pin = {p1,...,pm} Pout = {q1,...,qn} \nM = {v | is satis.able(.0(v)= .(v))} R = { (sm,incond,s,outcond,s ' ) | is satis.able(.0(sm = s) . .0(incond). \n.(outcond) . .(sm = s ' )) } Figure 10: Summary generation. V b 16). incond denotes the condition pi) \n. ( \u00acpbi); V 1. We assume that each function has one unique exit ( and the condition for i.incond i/ \n.incond block. In case the function has multiple return state\u00adoutcond is symmetric. Notice that since \nincond and outcond are a valuation of all input and output pred\u00adicates, no two transitions on the same \nstate machine should be enabled simultaneously (we .ag such cases as errors, since the caller would have \nno way of know\u00ading the exit state of the function). There is one aspect of the translation that is left \nunspeci\u00ad.ed in the description, which is the unknown values used to model the side-e.ects of the function \ncall. For scalar values, we use the translation rule for unknown and conservatively model these values \nwith a set of unconstrained boolean vari\u00adables. For pointers, we extend the DefVal operator described \nin Section 3.2 to obtain a checker-speci.ed estimation of the shape of the object being pointed to. \n5.4 Summary Generation This subsection describes how we compute the summary of a function after analysis. \nBefore we proceed, we .rst state two assumptions about the translation from C to Saturn: ments, we add \na dummy exit block linked to all return sites. The exit block is analyzed last (see Section 2) and the \nenvironment . at that point encodes all paths from function entry to exit. Summary generation is carried \nout after analyzing the exit block. 2. We model return statements in C by assigning the re\u00adturn value \nto a special object rv,and [ rv]]-1 = ret val. args Figure 10 gives the summary generation algorithm. \nThe input is a set of input (Pin) and output predicates (Pout). The algorithminvolves a series of queries \nto the SAT solver based on the initial (.0) and .nal state (.) to determine: (1) the set of modi.ed objects \nM, and (2) the set of transition relationships R. In computing M and R, we use a shorthand .(x) to denote \nthe valuation of x under environment .. The summary generation algorithm proceeds as follows. Intuitively, \nmodi.ed objects are those whose valuation may be di.erent under the initial environment .0 and the .nal \nenvironment .. We compute M by iterating over all inter\u00adface objects v and use the SAT solver to determine \nwhether the values may be di.erent or not. R is computed by enumerating over all relevant interface objects \n(e.g., locks in the lock checker) in the function and all combinations of input predicates and output \npredicates. We again use the SAT solver to determine whether a tran\u00adsition under a particular set of \ninput and output predicates is feasible. As one may have noticed, this process involves many SAT queries. \nWe observe that if done carefully, each SAT query can be separated into two parts: (1) constraints that \nen\u00adcode the programcontrol and data .ow; and (2) the speci.c valuations of the state variables and the \ninput and output predicates. Part (1) is shared among all SAT queries. Incre\u00admental SAT solvers are able \nto share and reuse information learned (e.g., using con.ict clauses) in the common part of the queries \nto speed up the SAT solving process. In practice, SAT queries typically complete in under one second. \n 5.5 A Linux Lock Checker In this section, we use the FSM checking framework de\u00adscribed above to construct \na lock checker for the Linux ker\u00adnel. We start with some background information, and list the challenges \nwe encountered in trying to detect locking bugs in Linux. We then describe the lock checker we have implemented \nin the Saturn framework. The Linux kernel is a widely deployed and well-tested core of the Linux operating \nsystem. The kernel is designed to scale to an array of multiprocessor platforms, and thus is inherently \nconcurrent. It uses a variety of locking mecha\u00adnisms (e.g., spin locks, semaphores, read/write locks, \nprim\u00aditive compare and swap instructions, etc.) to coordinate concurrent accesses of kernel data structures. \nFor e.ciency reasons, most of the code in the kernel runs in the supervi\u00adsor mode, and synchronization \nbugs can thus cause crashes or hangs that result in data losses and systemdown time. For this reason, \nlocking bugs have received the attention of a number of research and commercial checking and veri.ca\u00adtion \ne.orts. Locks (a.k.a. mutexes) are naturally expressed as a .\u00adnite state property with three states: \nLocked, Unlocked,and Error. The lock operation can be modeled as two transi\u00adtions: from Unlocked to Locked,and \nLocked to Error (unlock is similar). There are a few challenges that a checker must deal with to model \nlocking behavior in Linux: Aliasing. In Linux, locks are passed by reference (i.e., by pointers in C). \nOne immediate problem is the need to deal with pointer aliasing. CQual employs a number of techniques \nto infer non-aliasing relation\u00adships to help re.ne the results fromthe alias analy\u00adsis [2]. MC [13] assumes \nnon-aliasing among all point\u00aders, which helps reduce false positives, but also limits the checking power \nof the tool.  Heap Objects. In .ne grained locking, locks are often embedded in heap objects. These \nobjects are stored in the heap and passed around by reference. To detect bugs involving heap objects, \na reasonable model of the heap needs to be constructed (recall Section 3.2). The need to write drivers \nthat construct the check\u00ading environment has proven to be a non-trivial task in traditional model checkers \n[3].  Path Sensitivity. The state machine for locks be\u00adcomes more complex when we consider trylocks.Try\u00adlocks \nare lock operations that can fail. The caller must check the return value of trylocks to determine whether \nthe operation has succeeded or not. Besides trylocks, some functions intentionally exit with locks held \non error paths and expect their callers to carry out error recovery and cleanup work. These constructs \nare used extensively in Linux. In addition to that, one common usage scenario in Linux is the following: \nif (x) spin lock(&#38;l); . . .; if (x) spin unlock(&#38;l); Some form of path sensitivity is necessary \nto handle these cases. Interprocedural Analysis. As we show in Section 6, a large portion of synchronization \nerrors arise from misunderstanding of function interface constraints. The presence of more than 600 lock/unlock/trylock \nwrap\u00adpers further complicates the analysis. Imprecision in the intraprocedural analysis is ampli.ed in \nthe inter\u00adprocedural phase, so we believe a precise interprocedu\u00adral analysis is important in the construction \nof a lock checker. Our lock checker is based on the framework described above(seeFigure8). States arede.ned \nas usual: {Locked, Unlocked, Error}. To accurately model trylocks, we de.ne Pout = {liftc(ret val)} for \nfunctions that return integers or pointers. Tracking this predicate in summaries is also ade\u00adquate for \nmodeling functions that exit in di.erent lock states depending on whether the return value is 0 (null)or \nnot. Pout is de.ned to be the empty set for functions of type void. Pin is de.ned to be the empty set. \nWe detect two types of locking errors in Linux: Type A: double locking/unlocking.These are functions \nthat may acquire or release the same lock twice in a row. The summary relationship R of such functions \ncontains two transitions on the same lock: one leads fromthe Locked state to Error, and the other fromthe \nUnlocked state to Error. This signals an in\u00adternal inconsistency in the function no matter what state \nthe lock is in on entry to the function, there is a path leading to the error state.  Type B: ambiguous \nreturn state. These are func\u00adtions that may exit in both Locked and Unlocked state with no observable \ndi.erence (w.r.t. Pout,which is liftc(ret val)) in the return value. These bugs are com\u00admonly caused \nby missed operations to restore lock states on error paths.   6. EXPERIMENTAL RESULTS Our implementation \nof Saturn is written in O Caml [20] and makes use of several existing software packages. We use a modi.ed \nversion of the GNU C preprocessor to preserve a number of primitive lock operations that would otherwise \nbe macro expanded into inline assembly instructions. Sev\u00aderal panic primitives (e.g., panic, BUG) are \nalso preserved in this phase. The preprocessed code then goes through a modi.ed version of CIL [23], \nwhere it is parsed and trans\u00adlated into the Saturn modeling language described in Sec\u00adtion 2. We use \na GNU DBM (GDBM) database to index Type Count Num. of Files 12455 Total Line Count 4.8 million LOC Total \nNum. Func. 63850 Lock Related Func. 23458 Running time 19h40mCPU time Approx. LOC/sec 67 Table 1: Performance \nstatistics. and store the processed function bodies to avoid redundant parsing and transformation. A \nseparate GDBM database is also used to store function summaries as they are com\u00adputed. During the analysis, \nwe use the BuDDy [21] BDD package to track and simplify CFG block guards. Finally, we use zCha. [25, \n22] as our backend SAT solver because of its performance and incremental SAT solving capabilities. We \nhave implemented the lock checker described in Sec\u00adtion 5.5 as a plugin to the Saturn framework. The \nchecker models locks in Linux (e.g., objects of type spinlock t, rwlock t, rw semaphore,and semaphore) \nusing the state machines de.ned in Section 5. When analyzing a function, we retrieve the lock summaries \nof its callees and use the al\u00adgorithmdescribed in Section 5.3 to simulate their observable e.ects. At \nthe end of the analysis, we compute a summary for the current function using the algorithmdescribed in \nSection 5.4 and store it in the summary database for future use. The order of analysis for functions \nin Linux is determined by topologically sorting the static call graph of the Linux kernel. Recursive \nfunction calls are represented by strongly connected components (SCC) in the call graph. During the bottomup \nanalysis, functions in SCCs are analyzed in arbi\u00adtrary order. We start the analysis by seeding the lock \nsummary database with manual speci.cations of around 40 lock, unlock and trylock primitives in Linux. \nOtherwise the checking process is fully automatic: our tool works on the unmodi.ed source tree and requires \nno human guidance during the analysis. We ran our lock checker on the then latest release of the kernel \nsource tree (v2.6.5). Performance statistics of the ex\u00adperiment are tabulated in Table 1. All experiments \nwere done on a 3.0GHz Pentium IV computer with 1G of mem\u00adory. Our tool parsed and analyzed around 4.8 \nmillion lines of code in 63,850 functions in under 20 hours. Function side-e.ect computation is not currently \nimplemented in the version of the checker reported here. Loops are unrolled a maximum of two iterations \nbased on the belief that most double lock errors manifest themselves by the second itera\u00adtion. We have \nimplemented an optimization that skips func\u00adtions that have no lock primitives and do not call any other \nfunctions with non-trivial lock summaries. These functions are automatically given the trivial No-Op \nsummary. We analyzed the remaining 23,927 lock related functions, and stored their summaries in a GDBM \ndatabase. We set the memory limit for each function to 700MB to prevent thrashing, and the CPU time limit \nto 90 seconds. Our tool failed to analyze 27 functions some of which were written in assembly, and the \nrest due to internal failures of the tool. It failed to terminate on 442 functions in the ker\u00adnel, largely \ndue to resource constraints, with a small number  Type Bugs FP Warnings Accuracy (Bug/Warning) A B \n134 45 99 22 233 67 57% 67% Total 179 121 300 60% Table 2: Bug count. Type A B Total Interprocedural \n108 27 135 Intraprocedural 26 18 44 total 134 45 179 Table 3: Bug breakdown. of them due to implementation \nbugs in our tool. In every case we have investigated, resource exhaustion is caused by exceeding the \ncapacity of an internal cache in Saturn. This represents a failure rate of < 2% on the lock-related func\u00adtions. \nThe result of the analysis consists of a bug report of 179 previously unknown errors6 and a lock summary \ndatabase for the entire kernel, which we describe in the subsections below. 6.1 Errors and False Positives \nAs described in Section 5.5, we detect two types of locking errors in Linux: double lock/unlock (Type \nA) and ambigu\u00adous output states (Type B). We tabulate the bug counts in Table 2. The bugs and false positives \nare classi.ed by manually in\u00adspecting the error reports generated by the tool. One caveat of this approach \nis that errors we diagnose may not be actual errors. To counter this, we only .ag ones we are reasonably \nsure about. We have several years of experience examin\u00ading Linux bugs, so the number of misdiagnosed \nerrors is expected to be low. Table 3 further breaks down the 179 bugs into intraproce\u00addural versus interprocedural \nerrors. We observe that more than three quarters of diagnosed errors are caused by mis\u00adunderstanding \nof function interface constraints. Table 4 classi.es the false positives into six categories. The biggest \ncategory of false positives is caused by inade\u00adquate choice of predicates Pin and Pout.Inasmall num\u00adber \nof widely called utility functions, input and output lock states are correlated with values passed in/out \nthrough the parameter, instead of the return value. To improve this, we need to detect the relevant predicates \neither by manual speci.cation or by using a predicate abstraction algorithm similar to that used in SLAM \nor BLAST, which we will leave to future work. Another large source of false positives is the idiomthat \nuses trylock operations as a way of query\u00ading the current state of the lock. This idiom is commonly used \nin assertions to make sure that a lock is held at a cer\u00adtain point. We believe a better way to accomplish \nthis task is to use the lock query functions, which we model precisely in our tool. Fortunately, this \nusage pattern only occurs in a few macros, and can be easily identi.ed during inspec\u00ad 6The bug reports \nare available online at http://glide.stanford.edu/saturn/results/err{1,2}.php Type A Type B Total Predicates \n26 16 42 Lock Assertions 21 4 25 Semaphores 22 0 22 Saturn Lim. 18 1 19 Readlocks 7 0 7 Others 5 1 7 \nTotal 99 22 121 1 2 3 4 5 6 7 8 9 10 11 Table 4: False positives breakdown. 12 13 14 1 static void \nsscape coproc close(void *dev info, int sub device) 15 2 3 { spin lock irqsave(&#38;devc->lock,.ags); \n16 17 4 5 if (devc->dma allocated) {sscape write(devc, GA DMAA REG, 0x20); 6 .. . 7 .. . 8 } Figure 11: \nAn interprocedural Type A error found in sound/oss/sscape.c.  tion. The third largest source of false \npositives is counting semaphores. Depending on the context, semaphores can be used in Linux either as \nlocks (with down being lock and up being unlock) or counters. Our tool treats all semaphores as locks, \nand therefore may mis.ag consecutive down/up op\u00aderations as double lock/unlock errors. The remaining \nfalse positives are due to readlocks (where double locks are OK), and Saturn limitations in modeling \narrays, void *,etc. Figure 11 shows a sample interprocedural Type A error found by Saturn, where sscape \ncoproc close calls sscape write with &#38;devc.lock held. However, the .rst thing sscape write does is \nto acquire that lock again, resulting in a deadlock on multiprocessor systems. Figure 12 gives a sample \nintraprocedural Type B error. There are two places where the function exits with return value -EBUSY: \none with the lock held, and the other unheld. The programmer has forgotten to release the lock before \nreturning at line 13. We have .led the bug reports to the Linux Kernel Mailing List (LKML) and received \ncon.rmations and patches for a number of reported errors. To the best of our knowledge, Saturn is by \nfar the most e.ective bug detection tool for Linux locking errors.  6.2 The Lock Summary Database Synchronization \nerrors are known to be di.cult to repro\u00adduce and debug dynamically. To help developers diagnose reported \nerrors, and also better understand the often subtle locking behavior in the kernel (e.g., lock states \nunder error conditions), we have built a web interface for the Linux lock summary database7 generated \nduring the analysis. Our own experience with the summary database has been pleasant. During inspection, \nwe use the summary database extensively to match up the derived summary with the im\u00adplementation code \nto determine whether a bug report is a false positive. In our experience the generated summaries 7 The \nweb interface is available online at http://glide.stanford.edu/saturn/results/browse.php   int i2o \nclaim device(struct i2o device *d, struct i2o handler *h) { down(&#38;i2o con.guration lock); if (d->owner) \n{... up(&#38;i2o con.guration lock); return -EBUSY; } ... if(. . .) {... return -EBUSY; } up(&#38;i2o \ncon.guration lock); return 0; } Figure 12: An intraprocedural Type B error found in drivers/message/i2o/i2o \ncore.c. accurately model the locking behavior of the function being analyzed. In fact, shortly after \nwe .led these bugs, we logged more than a thousand queries to the summary database from the Linux community. \nThe summary database also reveals interesting facts about the Linux kernel. To our surprise, locking \nbehavior is far fromsimple in Linux. More than 23,000 of the ~63,000 func\u00adtions in Linux directly or \nindirectly operate on locks. In ad\u00addition, 8873 functions access more than one lock. There are 193 lock \nwrappers, 375 unlock wrappers, and 36 functions where the output state correlates with the return value. \nFur\u00adthermore, more than 17,000 functions directly or indirectly require locks to be in a particular state \non entry. We believe Saturn is the .rst automatic tool that suc\u00adcessfully understands and documents any \naspect of locking behavior in code the size of Linux.  7. RELATED AND FUTURE WORK In this section, we \ndiscuss the relationship of Saturn to several other systems for bug .nding and veri.cation. Saturn was \ninspired by the .rst author s previous work on Meta Compilation (MC) [10, 13] and our project is philo\u00adsophically \naligned with MC in that it is a bug detection, rather than a veri.cation, system. In fact, Saturn began \nas an attempt to improve the accuracy of MC s .ow sensitive but path insensitive analysis. Under the \nhood, MC attaches .nite state machines (FSM) to syntactic program objects (e.g., variables, memory loca\u00adtions, \netc.) and uses an interprocedural data .ow analysis to compute the reachability of the error state. Because \ncon\u00adservative pointer analysis is often a source of false positives for bug .nding purposes [12], MC \nsimply chooses not to model pointers or the heap, thereby preventing false posi\u00adtives fromspurious alias \nrelationships by .at. MC checkers use heuristics (e.g., separate FSM transitions for the true and false \nbranches of interesting if statements) and sta\u00adtistical methods to infer some of the lost information. \nThese techniques usually dramatically reduce false positive rates after several rounds of trial and error. \nHowever, they cannot fully compensate for the information lost during the analy\u00adsis. For example, in \nthe code below,   /* 1: data correlation */ if (x) spin lock(&#38;lock); if (x) spin unlock(&#38;lock); \n /* 2: aliasing */ l=&#38;p->lock; spin lock(&#38;p->lock); spin lock(l); MC emits a spurious warning \nin the .rst case, and misses the error in the second. The .rst scenario occurs frequently in Linux, and \nan interprocedural version of the second is also prevalent. Saturn can be viewed as both a generalization \nand sim\u00adpli.cation of MC because it uniformly relies on boolean sat\u00adis.ability to model all aspects without \nspecial cases. The lock checker presented in Section 5.5 naturally tracks locks that are buried in the \nheap, or conditionally manipulated based on the values of certain predicates. In designing this checker, \nwe focused on two kinds of Linux mutex errors that exhibited high rates of false positives in MC: double \nlock\u00ading and double unlocking (2 errors and 23 false positives [10]). Our experiments show that Saturn \ns improved accu\u00adracy and summary-based interprocedural analysis allow it to better capture locking behavior \nin the Linux kernel and thus .nd more errors at a lower false positive rate. While Blast, SLAM, and other \nsoftware model checking projects have made dramatic progress and now handle hun\u00addreds of thousands of \nlines of code [4, 15, 14], these are whole-programanalyses. ESP, a lower-complexity approach based on \ncontext-free reachability, is similarly whole-program [9]. In contrast, Saturn computes summaries function-by\u00adfunction \nand, based on our experiments, scales to millions of lines of code and should in fact be able to scale \narbitrarily, at least for checking properties that lend themselves to con\u00adcise function summaries. In \naddition, Saturn has the preci\u00adsion of path-sensitive bit-level analysis within function bod\u00adies, which \nmakes handling normally di.cult-to-model con\u00adstructs, such as type casts, easy. In fact, Saturn s code \nsize is only about 25% of the comparable part of Blast (the most advanced software model checker available \nto us), which sup\u00adports our impression that a SAT-based checker is easier to engineer. One weakness of \nSaturn with respect to these sys\u00adtems is its current handling of loops and recursion (which is the primary \nsource of unsoundness). This is an area we intend to examine in future work. CQual is a quite di.erent, \ntype-based approach to pro\u00adgram checking [12, 2]. CQual s primary limitation is that it is path insensitive. \nIn the locking application path sensi\u00adtivity is not particularly important for most locks, but we have \nfound that it is essential for uncovering the numerous trylock errors in Linux. CQual s strength is in \nsophisti\u00adcated global alias analysis that allows for sound reasoning and relatively few false positives \ndue to spurious aliases; an\u00adother possible direction for future work is to integrate this alias analysis \ninto Saturn. PRE.x [6] is a symbolic execution based static error\u00addetection tool. It selectively simulates \na set number of paths through a function using a solver that specializes in detect\u00ading memory errors \nsuch as NULL pointer dereferences and leaks. Information gathered during the simulation is sum\u00admarized \ninto interface constraints for the function, which are subsequently used during the analysis of its callers. \nSat\u00adurn employs a similar architecture in its summary-based bottom-up interprocedural analysis. CBMC \n[19, 8] is a SAT-based bounded model checker for C. It has been used to verify hardware design speci.ca\u00adtions \n[19] and also a component of an air tra.c control sys\u00adtem[8]. Like Saturn, it translates C programs into \nboolean formulas by unrolling loops up to a given bound and uses a SAT solver to analyze relevant properties. \nHowever, there are a few key di.erences between these two systems. On a high level, CBMC is optimized \nas a whole-program asser\u00adtion checker aimed at verifying C programs with hundreds of lines of code. Saturn \nis designed for compositional analysis of large systems with millions of lines of code. The di.erence \nin goals results in low-level technical di.erences in modeling C features. For example, CBMC translates \nassignments as assumptions and feeds them to the SAT solver regardless of whether or not they are relevant \nto the properties being checked. This approach is not usually a problembecause speci.cation code is by \ndesign an abstraction of the imple\u00admentation and thus should likely contain relevant informa\u00adtion. The \nsame cannot be said about the unmodi.ed Linux kernel. In Linux, most of the code analyzed (e.g., complex \nlogic in handling logs in the .le system) is irrelevant to the property (e.g., locking behavior) of interest. \nSaturn models assignments with a map recording the binding of variables to their boolean representations, \nand Saturn only commits the boolean constraints to the SAT solver if they are relevant to the query. \nThis design dramatically cuts the time spent in the solver. Saturn s modeling of pointers using guarded \nlocation sets also lends itself well to the automatic construc\u00adtion of the checking environment. Closer \nto Saturn is Magic [7], a compositional checking tool that veri.es a formof conformance relationship \ncalled weak simulation between two labeled transition systems (LTS): one abstracted fromthe programby \na predicate abstraction tool like SLAM or BLAST, and the other written by the programmer as a form of \nspeci.cation. Checking is done by reducing the conformance query to the satis.ability of a special formof \nboolean formulas (weakly negated HORN formulas) that can be solved in linear time. Magic also fo\u00adcuses \non checking .nite state machine properties. The basic di.erence between Saturn and Magic is that Magic \nis con\u00adceived of as a tool to check user-supplied speci.cation, while Saturn is an inference system. \n 8. CONCLUSIONS We have presented Saturn, a scalable and precise error de\u00adtection framework based on \nboolean satis.ability. Our sys\u00adtemhas a novel combination of features: it models all values, including \nthose in the heap, path sensitively down to the bit level, it computes function summaries automatically, \nand it scales to millions of lines of code. We have demonstrated the utility of tool with a lock checker \nfor Linux, .nding in the process 179 unique locking errors in the Linux kernel. Acknowledgments We thank \nAndy Chou for thoughtful discussions and signif\u00adicant contributions to an earlier SAT-based analysis \ne.ort. We also thank Ted Kremenek, Mayur Naik, Paul Twohey, Junfeng Yang and the anonymous reviewers \nfor providing valuable comments on previous drafts of this paper. 9. REFERENCES [1] A. V.Aho,R. Sethi,and \nJ. D. Ullman. Compilers: Principles, Techniques, and Tools. Addison-Wesley, Reading, Massachusetts, \n1986. [2] A. Aiken, J. S. Foster, J. Kodumal, and T. Terauchi. Checking and inferring local non-aliasing. \nIn Proceedings of the 2003 ACM SIGPLAN Conference on Programming Language Design and Implementation, \npages 129 140, June 2003. [3] T. Ball, B. Cook, V. Levin, and S. Rajamani. SLAM and Static Driver Veri.er: \nTechnology transfer of formal methods inside Microsoft. In Proceedings of FourthInternational Conference \non Integrated Formal Methods. Springer, 2004. [4] T. Ball and S. K. Rajamani. Automatically validating \ntemporal safety properties of interfaces. In Proceedings of SPIN 2001 Workshop on Model Checking of Software, \npages 103 122, May 2001. LNCS 2057. [5] R. E. Bryant. Graph-based algorithms for boolean function manipulation. \nIEEE Transactions on Computers, C-35(8):677 691, Aug. 1986. [6] W. Bush, J. Pincus, and D. Siela.. A \nstatic analyzer for .nding dynamic programming errors. Software Practice &#38; Experience, 30(7):775 \n802, June 2000. [7] S.Chaki,E.Clarke, A. Groce, S. Jha, andH. Veith. Modular veri.cation of software \ncomponents in C. In Proceedings of the 25th International Conference on Software Engineering (ICSE), \npages 385 395, 2003. [8] E. Clarke, D. Kroening, and F. Lerda. A tool for checking ANSI-C programs. \nIn K. Jensen and A. Podelski, editors, Tools and Algorithms for the Construction and Analysis of Systems \n(TACAS), volume 2988 of Lecture Notes in Computer Science, pages 168 176. Springer, 2004. [9] M. Das, \nS. Lerner, and M. Seigle. Path-sensitive program veri.cation in polynomial time. In Proceedings of the \nACM SIGPLAN 2002 Conference on Programming Language Design and Implementation, Berlin, Germany, June \n2002. [10] D. Engler, B. Chelf, A. Chou, and S. Hallem. Checking systemrules using system-speci.c, programmer-written \ncompiler extensions. In Proceedings of Operating Systems Design and Implementation (OSDI), Sept. 2000. \n[11] C. Flanagan and S. Freund. Type inference against races. In Proceedings of 11thStatic Analysis Symposium, \nVerona, Italy, Aug. 2004. [12] J. S. Foster, T. Terauchi, and A. Aiken. Flow-sensitive type quali.ers. \nIn Proceedings of the 2002 ACM SIGPLAN Conference on Programming Language Design and Implementation, \npages 1 12, June 2002. [13] S. Hallem, B. Chelf, Y. Xie, and D. Engler. A system and language for building \nsystem-speci.c, static analyses. In Proceedings of the ACM SIGPLAN 2002 Conference on Programming Language \nDesign and Implementation, Berlin, Germany, June 2002. [14] T. A. Henzinger, R. Jhala, and R. Majumdar. \nLazy abstraction. In Proceedings of the 29th Annual Symposium on Principles of Programming Languages, \nJanuary 2002. [15] T. A. Henzinger, R. Jhala, R. Majumdar, and G. Sutre. Software veri.cation with Blast. \nIn  Proceedings of the SPIN 2003 Workshop on Model Checking Software, pages 235 239, May 2003. LNCS \n2648. [16] D. Jackson. Automating .rst-order relational logic. In Proceedings of the ACM SIGSOFT Symposium \non the Foundations of Software Engineering, 2000. [17] D. Jackson and M. Vaziri. Finding bugs with a \nconstraint solver. In Proceedings of the 2000 ACM SIGSOFT International Symposium on Software Testing \nand Analysis, 2000. [18] S. Khurshid, C. Pasareanu, and W. Visser. Generalized symbolic execution for \nmodel checking and testing. In Proceedings of the 9th International Conference on Tools and Algorithms \nfor the Construction and Analysis of Systems. Springer, 2003. [19] D. Kroening, E. Clarke, and K. Yorav. \nBehavioral consistency of C and Verilog programs using bounded model checking. In Proceedings of DAC \n2003, pages 368 371. ACM Press, 2003. [20] X. Leroy, D. Doligez, J. Garrigue, and J. Vouillon. The Objective \nCaml system. Software and documentation available on the web, http://caml.inria.fr. [21] J. Lind-Nielsen. \nBuDDy, a binary decision diagram package. http://www.itu.dk/research/buddy/. [22] M. Moskewicz, C. Madigan, \nY. Zhao, L. Zhang, and S. Malik. Cha.: Engineering an e.cient sat solver. In  Proceedings of the 39th \nConference on Design Automation Conference, June 2001. [23] G. Necula,S.McPeak, S. Rahul, andW.Weimer. \nCIL: Intermediate language and tools for analysis and transformation of C programs. In Proceedings of \nthe 11thInternational Conference on Compiler Construction, Mar. 2002. [24] Y. Xie and A. Chou. Path sensitive \nanalysis using boolean satis.ability. Technical report, Stanford University, Nov. 2002. [25] L. Zhang, \nC. Madigan, M. Moskewicz, and S. Malik. E.cient con.ict driven learning in a boolean satis.ability solver. \nIn Proceedings of International Conference on Computer-Aided Design,San Jose,CA, Nov. 2001.  \n\t\t\t", "proc_id": "1040305", "abstract": "We describe a software error-detection tool that exploits recent advances in boolean satisfiability (SAT) solvers. Our analysis is path sensitive, precise down to the bit level, and models pointers and heap data. Our approach is also highly scalable, which we achieve using two techniques. First, for each program function, several optimizations compress the size of the boolean formulas that model the control- and data-flow and the heap locations accessed by a function. Second, summaries in the spirit of type signatures are computed for each function, allowing inter-procedural analysis without a dramatic increase in the size of the boolean constraints to be solved.We demonstrate the effectiveness of our approach by constructing a lock interface inference and checking tool. In an interprocedural analysis of more than 23,000 lock related functions in the latest Linux kernel, the checker generated 300 warnings, of which 179 were unique locking errors, a false positive rate of only 40%.", "authors": [{"name": "Yichen Xie", "author_profile_id": "81100418587", "affiliation": "University of Stanford, Stanford, CA", "person_id": "P348282", "email_address": "", "orcid_id": ""}, {"name": "Alex Aiken", "author_profile_id": "81100399954", "affiliation": "University of Stanford, Stanford, CA", "person_id": "PP39041079", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1040305.1040334", "year": "2005", "article_id": "1040334", "conference": "POPL", "title": "Scalable error detection using boolean satisfiability", "url": "http://dl.acm.org/citation.cfm?id=1040334"}