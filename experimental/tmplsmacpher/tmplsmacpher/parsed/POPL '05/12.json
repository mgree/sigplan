{"article_publication_date": "01-12-2005", "fulltext": "\n Communicating Quantum Processes * Simon J. Gay Rajagopal Nagarajan Department of Computing Science \nDepartment of Computer Science University of Glasgow, UK University of Warwick, UK simon@dcs.gla.ac.uk \nbiju@dcs.warwick.ac.uk ABSTRACT We de.ne a language CQP (Communicating Quantum Pro\u00adcesses) for modelling \nsystems which combine quantum and classical communication and computation. CQP combines the communication \nprimitives of the pi-calculus with primi\u00adtives for measurement and transformation of quantum state; in \nparticular, quantum bits (qubits) can be transmitted from process to process along communication channels. \nCQP has a static type system which classi.es channels, distinguishes between quantum and classical data, \nand controls the use of quantum state. We formally de.ne the syntax, opera\u00adtional semantics and type \nsystem of CQP, prove that the semantics preserves typing, and prove that typing guaran\u00adtees that each \nqubit is owned by a unique process within a system. We illustrate CQP by de.ning models of several quantum \ncommunication systems, and outline our plans for using CQP as the foundation for formal analysis and \nveri.\u00adcation of combined quantum and classical systems.  Categories and Subject Descriptors D.3.1 [Programming \nLanguages]: Formal De.nitions and Theory;F.3.1 [Logics and Meanings of Programs]: Spe\u00adcifying and Verifying \nand Reasoning about Programs spec\u00adi.cation techniques;F.3.1 [Logics and Meanings of Pro\u00adgrams]: Semantics \nof Programming Languages operation\u00adal semantics General Terms Languages, Theory, Veri.cation  Keywords \nFormal language, quantum communication, quantum com\u00adputing, semantics, types, veri.cation * Partially \nsupported by the UK EPSRC (GR/S34090) and the EU Sixth Framework Programme (Project SecoQC). Permission \nto make digital or hard copies of all or part of this work for personal or classroom use is granted without \nfee provided that copies are not made or distributed for profit or commercial advantage and that copies \nbear this notice and the full citation on the first page. To copy otherwise, to republish, to post on \nservers or to redistribute to lists, requires prior specific permission and/or a fee. POPL 05, January \n12 14, 2005, Long Beach, California, USA. Copyright 2005 ACM 1-58113-830-X/05/0001 ...$5.00. 1. INTRODUCTION \nQuantum computing and quantum communication have attracted growing interest since their inception as \nresearch areas more than twenty years ago, and there has been a surge of activity among computer scientists \nduring the last few years. While quantum computing o.ers the prospect of vast improvements in algorithmic \ne.ciency for certain problems, quantum cryptography can provide communica\u00adtion systems which will be \nsecure even in the presence of hy\u00adpothetical future quantum computers. As a practical tech\u00adnology, quantum \ncommunication has progressed far more rapidly than quantum computing. Secure communication involving \nquantum cryptography has recently been demon\u00adstrated in a scenario involving banking transactions in \nVi\u00adenna [21], systems are commercially available from Id Quan\u00adtique, MagiQ Technologies and NEC, and \nplans have been reported to establish a nationwide quantum communication network in Singapore. Secure \nquantum communication will undoubtedly become a fundamental part of the technologi\u00adcal infrastructure \nof society, long before quantum computers can tackle computations of a useful size. However, secure quantum \ncommunication is not a solved problem. Although particular protocols have been mathe\u00admatically proved \ncorrect (for example, Mayers analysis [13] of the Bennett-Brassard protocol (BB84) [3] for quantum key \ndistribution), this does not guarantee the security of systems which use them. Experience of classical \nsecurity analysis has shown that even if protocols are theoretically secure, it is di.cult to achieve \nrobust and reliable imple\u00admentations of secure systems: security can be compromised by .aws at the implementation \nlevel or at the boundaries be\u00adtween systems. To address this problem, computer scientists have developed \nan impressive armoury of techniques and tools for formal modelling, analysis and veri.cation of clas\u00adsical \nsecurity protocols and communication systems which use them [23]. These techniques have been remarkably \nsuc\u00adcessful both in establishing the security of new protocols and in demonstrating .aws in protocols \nwhich had previ\u00adously been believed to be secure. Their strength lies in the ability to model systems \nas well as idealized protocols, and the .exibility to easily re-analyze variations in design. Our research \nprogramme is to develop techniques and tools for formal modelling, analysis and veri.cation of quan\u00adtum \ncommunication and cryptographic systems. More pre\u00adcisely we aim to handle systems which combine quantum \nand classical communication and computation, for two reasons: the .rst quantum communication systems \nwill implement communication between classical computers;and protocols such as BB84 typically contain \nclassical communication and computation as well as quantum cryptography. We cannot simply make use of \nexisting techniques for classical secu\u00adrity analysis: for example, treating the security of quantum cryptography \naxiomatically would not permit analysis of the protocols which construct quantum cryptographic keys. \nFurthermore, the inherently probabilistic nature of quantum systems means that not all veri.cation consists \nof checking absolute properties;we need a probabilistic modelling and analysis framework. Any formal \nanalysis which involves automated tools re\u00adquires a modelling language with a precisely-de.ned seman\u00adtics. \nThe purpose of this paper is to de.ne a language, CQP (Communicating Quantum Processes), which will serve \nas the foundation for the programme described above. CQP combines the communication primitives of the \npi-calculus [15, 25] with primitives for transformation and measurement of quantum state. In particular, \nqubits (quantum bits, the basic elements of quantum data) can be transmitted along communication channels. \nIn Section 3 we introduce CQP through a series of examples which cover a wide spectrum of quantum information \nprocessing scenarios: a quantum coin\u00ad.ipping game;a quantum communication protocol known as teleportation;and \na quantum bit-commitment protocol. The latter will lead naturally to a model of the BB84 quan\u00adtum key-distribution \nprotocol in future work. In Section 4 we formalize the syntax of CQP and de.ne an operational semantics \nwhich combines non-determinism (arising in the same way as in pi-calculus) with the probabilistic results \nof quantum measurements. In Section 5 we de.ne a static type system which classi.es data and communication \nchannels, and crucially treats qubits as physical resources: if process P sends qubit q to process Q,then \nP must not access q subsequently, and this restriction can be enforced by static typechecking. In Section \n6 we prove that the invariants of the type system are preserved by the operational semantics, guaranteeing \nin particular that at every point during execu\u00adtion of a system, every qubit is uniquely owned by a single \nparallel component. In Section 7 we outline our plans for further work, focusing on the use of both standard \n(non\u00addeterministic) and probabilistic model-checking systems. Related Work There has been a great deal \nof interest in quantum pro\u00adgramming languages, resulting in a number of proposals in di.erent styles, \nfor example [10, 18, 24, 26, 29]. Such lan\u00adguages can express arbitrary quantum state transformations \nand could be used to model quantum protocols in those terms. However, our view is that any model lacking \nan explicit treatment of communication is essentially incom\u00adplete for the analysis of protocols;certainly \nin the classical world, standard programming languages are not considered adequate frameworks in which \nto analyze or verify proto\u00adcols. Nevertheless, Selinger s functional language QPL [26] in particular \nhas in.uenced our choice of computational op\u00aderators for CQP. The closest work to our own, developed \nsimultaneously but independently, is Jorrand and Lalire s QPAlg [9], which also combines communication \nin process calculus style with transformation and measurement of quantum state. The most distinctive \nfeatures of our work are the type system and associated proofs, the explicit formulation of an expression \nlanguage which can easily be extended, and our emphasis on a methodology for formal veri.cation. The \nwork of Abramsky and Coecke [2] is also relevant. They de.ne a category-theoretic semantic foundation \nfor quantum protocols, which supports reasoning about systems and exposes deep connections between quantum \nsystems and programming language semantics, but they do not de.ne a formal syntax in which to specify \nmodels. It will be inter\u00adesting to investigate the relationship between CQP and the semantic structures \nwhich they propose. Acknowledgements We have bene.tted from discussions with Philippe Jorrand, Marie \nLalire and Nick Papanikolaou, and from the insightful comments of several referees. 2. PRELIMINARIES \nWe brie.y introduce the aspects of quantum theory which are needed for the rest of the paper. For more \ndetailed presentations we refer the reader to the books by Gruska [8] and Nielsen and Chuang [17]. Rie.el \nand Polak [22] give an account aimed at computer scientists. A quantum bit or qubit is a physical system \nwhich has two basis states, conventionally written |0) and |1), corre\u00adsponding to one-bit classical values. \nThese could be, for example, spin states of a particle or polarization states of a photon, but we do \nnot consider physical details. According to quantum theory, a general state of a quantum system is a \nsuperposition or linear combination of basis states. Con\u00adcretely, a qubit has state a|0) + \u00df|1),where \na and \u00df are complex numbers such that |a|2 + |\u00df|2 = 1;states which di.er only by a (complex) scalar factor \nwith modulus 1 are indistinguishable. States can be represented by column vec\u00adtors: a = a|0) + \u00df|1). \n\u00df Superpositions are illustrated by the quantum coin-.ipping game which we discuss in Section 3.1. Formally, \na quantum state is a unit vector in a Hilbert space, i.e. a complex vector space equipped with an inner \nproduct satisfying certain ax\u00adioms. In this paper we will restrict attention to collections of qubits. \nThe basis {|0), |1)} is known as the standard basis. Other bases are sometimes of interest, especially \nthe diagonal (or dual,or Hadamard) basis consisting of the vectors |+) = v1(|0) + |1))and |-) = v1(|0)-|1)). \nFor example, with 22 respect to the diagonal basis, |0) is in a superposition of basis states: 11 |0) \n= v|+) + v |-). 22 Evolution of a closed quantum system can be described by a unitary transformation. \nIf the state of a qubit is repre\u00adsented by a column vector then a unitary transformation U can be represented \nby a complex-valued matrix (uij )such that U-1 = U * ,where U * is the conjugate-transpose of U (i.e. \nelement ij of U * is u\u00afji). U acts by matrix multiplica\u00adtion: au00 u01 a = \u00df; u10 u11\u00df A unitary transformation \ncan also be de.ned by its e.ect on basis states, which is extended linearly to the whole space. For example, \nthe Hadamard transformation is de.ned by |0).1|0)+ 1 . vv |1) 22 |1).v1|0)- v1 .|1) 22 which corresponds \nto the matrix 111 H = v . 1 -12 The Hadamard transformation creates superpositions: H|0)= |+) H|1)= |-). \nWe will also make use of the Pauli transformations, denoted by either I,sx,sy,sz or s0,s1,s2,s3: I or \ns0 sx or s1 sy or s2 sz or s3 10 01 0 -i 10 01 10 i 00 -1 A key feature of quantum physics is the role \nof measure\u00adment. If a qubit is in the state a|0)+ \u00df|1) then measuring its value gives the result 0 with \nprobability |a|2 (leaving it in state |0)) and the result 1 with probability |\u00df|2 (leaving it in state \n|1)). Protocols sometimes specify measurement with respect to a di.erent basis, such as the diagonal \nbasis; this can be expressed as a unitary change of basis followed by a measurement with respect to the \nstandard basis. Note that if a qubit is in state |+) then a measurement with re\u00adspect to the standard \nbasis gives result 0 (and state |0))with probability 1 , and result 1 (and state |1)) with probability \n2 1 . If a qubit is in state |0)then a measurement with respect 2 to the diagonal basis gives result1 \n0 (and state |+))with probability 1 , and result 1 (and state |-))) with probability 2 1 , because of \nthe representation of |0)in the diagonal basis 2 noted above. If a classical bit is represented by a \nqubit using either the standard or diagonal basis, then a measurement with respect to the correct basis \nresults in the original bit, but a measurement with respect to the other basis results in 0 or 1 with \nequal probability. This behaviour is used by the quantum bit-commitment protocol which we discuss in \nSection 3.3. To go beyond single-qubit systems, we consider tensor products of spaces (in contrast to \nthe cartesian products used in classical systems). If spaces U and V have bases {ui}and {vj }then U.V \nhas basis {ui .vj }. In particular, a sys\u00adtem consisting of nqubits has a 2n-dimensional space whose \nstandard basis is |00 ...0)...|11 ...1). We can now consider measurements of single qubits or collective \nmeasurements of multiple qubits. For example, a 2-qubit system has basis |00),|01),|10),|11) and a general \nstate is a|00)+ \u00df|01)+ 222 .|10)+ d|11)with |a|+ |\u00df|+ |.|+ |d|2 = 1. Measuring the .rst qubit gives result \n0 with probability |a|2 + |\u00df|2 (leaving the system in state v 1 (a|00)+ \u00df|01))) and result |a|2+|\u00df|2 \n1 with probability |.|2 + |d|2 (leaving the system in state v 1 (.|10)+ d|11)));in each case we renormalize \nthe |.|2+|d|2 state by multiplying by a suitable scalar factor. Measuring both qubits simultaneously \ngives result 0 with probability |a|2 (leaving the system in state |00)), result 1 with proba\u00adbility |\u00df|2 \n(leaving the system in state |01)) and so on;note 1Strictly speaking, the outcome of the measurement \nis just the .nal state;the speci.c association of numerical results with .nal states is a matter of convention. \nthat the association of basis states |00),|01),|10),|11) with results 0,1,2,3isjustaconventional choice. \nThe powerof quantum computing, in an algorithmic sense, results from calculating with superpositions \nof states;all the states in the superposition are transformed simultaneously (quantum parallelism) and \nthe e.ect increases exponentially with the dimension of the state space. The challenge in quantum al\u00adgorithmdesignistomakemeasurementswhich \nenable this parallelism to be exploited;in general this is very di.cult. We will make use of the conditional \nnot (CNot)trans\u00adformation on pairs of qubits. Its action on basis states is de.ned by |00).|01).|01)|10).|11).|10) \n.|00)..|11). which can be understood as inverting the second qubit if and only if the .rst qubit is set, \nalthough in general we need to consider the e.ect on non-basis states. Systems of two or more qubits \ncan exhibit the phenomenon of entanglement, meaning that the states of the qubits are correlated. For \nexample, consider a measurement of the .rst qubit of the state v1(|00)+ |11)). The result is 0 (and 2 \nresulting state |00)) with probability 1 ,or 1 (and result\u00ad 2 ing state |11)) with probability 1 . In \neither case a subse\u00ad 2 quent measurement of the second qubit gives a de.nite (non\u00adprobabilistic) result \nwhich is always the same as the result of the .rst measurement. This is true even if the entangled qubits \nare physically separated. Entanglement illustrates the key di.erence between the use of tensor product \n(in quantum systems) and cartesian product (in classical sys\u00adtems): an entangled state of two qubits \nis one which cannot be decomposed as a pair of single-qubit states. Entangle\u00adment is used in an essential \nway in the quantum teleporta\u00adtion protocol which we discuss in Section 3.2. That exam\u00adple uses the CNot \ntransformation to create entanglement: CNot((H .I)|00))= v1(|00)+ |11)). 2  3. EXAMPLES OF MODELLING \nIN CQP 3.1 A Quantum Coin-Flipping Game Our .rst example is based on a scenario used by Meyer [14] to \ninitiate the study of quantum game theory. Players P and Q play the following game: P places a coin, \nhead upwards, in a box, and then the players take turns (Q,then P,then Q) to optionally turn the coin \nover, without being able to see it. Finally the box is opened and Q wins if the coin is head upwards. \nClearly neither player has a winning strategy, but the sit\u00aduation changes if the coin is a quantum system, \nrepresented by a qubit (|0)for head upwards, |1)for tail upwards). Turn\u00ading the coin over corresponds \nto the transformation s1,and this is what P can do. But suppose that Q can apply H, which corresponds \nto transforming from head upwards (|0)) to a superposition of head upwards and tail upwards ( v1(|0)+ \n|1))), and does this on both turns. Then we have 2 two possible runs of the game, (a) and (b): (a) (b) \nAction State Action State |0) |0) Q: H v1(|0)+ |1)) Q: H v1(|0)+ |1)) 2 2 v1(|1)+ |0)) P: - v1(|0)+ \n|1)) P: s1 2 2 Q: H |0) Q: H |0) P(s:l[Qbit,l[Qbit]]) = s?[y: Qbit,t:l[Qbit]] .t![y] .0 | s?[y: Qbit,t:l[Qbit]] \n.{y*= s1}.t![y] .0 Q(x: Qbit,s:l[Qbit,l[Qbit]]) = {x*= H}.(new t:l[Qbit])(s![x,t] .t?[z: Qbit] .{z*= \nH}.C (z)) System(x:Qbit)=(new s:l[Qbit,l[Qbit]])(P(s) |Q(x,s)) Figure 1: The quantum coin-.ipping game \nin CQP x= |0); \u00d8; System(x) . expand de.nition x= |0); \u00d8;(new s:l[Qbit,l[Qbit]])(P(s) |Q(x,s)) . create \nchannel s x= |0); s; P(s) |Q(x,s) . expand de.nitions x= |0); s; s?[y: Qbit,t:l[Qbit]] .t![y] .0 |s?[y: \nQbit,t:l[Qbit]] .{y*= s1}.t![y] .0 |{x*= H}.(new t:l[Qbit])(s![x,t] .t?[z: Qbit] .{z*= H}.C (z) . transform \nx 1v x = (|0)+ |1)); s; 2 y*= s1}.t![y] .0 .C (z)) s?[y: Qbit,t:l[Qbit]] .t![y] .0 |s?[y: Qbit,t:l[Qbit]] \n.{|(new t:l[Qbit])(s![x,t] .t?[z:Qbit] .{z*= H} . create channel t x = 1v 2 (|0)+ |1)); s,t; s?[y: Qbit,t:l[Qbit]] \n.t![y] .0 |s?[y: Qbit,t:l[Qbit]] .{|s![x,t] .t?[z: Qbit] .{z*= H}.C (z) ,' y*= s1}.t![y] .0 communication \n1v (|0)+ |1)); s,t; x= 1v 2 (|0)+ |1)); s,t; x* x= 2 t![x] .0 |Garbage Garbage |{= s1}.t![x] .0 |t?[z: \nQbit] .{z*= H}.C (z) |t?[z: Qbit] .{z*= H}.C (z) ..transform x x= 1v 2 (|0)+ |1)); s,t; 0 |Garbage |{x*.C \n(x) x= 1v 2 (|0)+ |1)); s,t; = H}Garbage |t![x] .0 |t?[z: Qbit] .{z*= H}.C (z) ..communication = |0); \ns,t; Garbage |C (x) x= 1v 2 (|0)+ |1)); s,t; x*.C (x) x Garbage |0 |{= H} .transform x x= |0); s,t; Garbage \n|C (x) Figure 2: Execution of the coin-.ipping game Alice(x: Qbit,c:l[0..3],z: Qbit)= {z,x*= CNot}.{z*= \nH}.c![measure z,x] .0 Bob(y:Qbit,c:l[0..3]) = c?[r:0..3] .{y*= sr}.Use(y) System(x:Qbit,y: Qbit,z: Qbit)=(new \nc:l[0..3])(Alice(x,c,z) |Bob(y,c)) Figure 3: Quantum teleportation in CQP x, y, z = 1v 2 |001)+ 1v 2 \n |111); \u00d8; System(x, y, z) .expand de.nition 1v 2 1v 2 |001)+ |111); \u00d8;(new c:l[0..3])(Alice(x, c, z) \n|Bob(y, c)) .create channel c x, y, z = 1v1v x, y, z = 2 |001)+ x, y, z = |111); c ; Alice(x, c, z) |Bob(y, \nc) .expand de.nitions 21v |001)+= H}.c![measure z, x] . 0 | c?[r: 0..3] . {y * .permute x, y, z; transform \nz, x 1v 2 |111); c ; 2 {z, x *= CNot}. {z * = sr}. Use(y) 1v 2 |110)+ 1v 2 |101); c ; {z *= H}.c![measure \nz, x] . 0 | c?[r:0..3] . {y *= sr}. Use(y) .transform z z, x, y = 1 21 2 |010)- 1 2 |101)- 1 2 |110); \nc ; c![measure z, x] . 0 |c?[r:0..3] . {y *= sr}. Use(y) .measure z, x |001)+ z, x, y = 1 41 41 41 4 \n (z, x, y = |001); a, c; c![0] . 0 |c?[r: 0..3] . {y *= sr}. Use(y))  (z, x, y = |010); a, c; c![1] \n. 0 |c?[r: 0..3] . {y *= sr}. Use(y))  (z, x, y = |101); a, c; c![2] . 0 |c?[r: 0..3] . {y *= sr}. Use(y)) \n (z, x, y = |110); a, c; c![3] . 0 |c?[r: 0..3] . {y *= sr}. Use(y))  1 1 11 .... 4444 z, x, y = |001); \nc ; z, x, y = |010); c ; z, x, y = |101); c ; z, x, y = |110); c ; c![0] . 0 |c?[r:0..3] .c![1] . 0 |c?[r: \n0..3] .c![2] . 0 |c?[r:0..3] .c![3] . 0 |c?[r: 0..3] . {y *= sr}. Use(y) {y *= sr}. Use(y) {y *= sr}. \nUse(y) {y *= sr}. Use(y) ... .comm. z, x, y = |001); c ; z, x, y = |010); c ; z, x, y = |101); c ; z, \nx, y = |110); c ; {y *= s0}. Use(y) {y *= s1}. Use(y) {y *= s2}. Use(y) {y *= s3}. Use(y) ... .trans. \ny z, x, y = |001); c ; z, x, y = |011); c ; z, x, y = -i|101); c ; z, x, y = -|111); c ; Use(y) Use(y) \nUse(y) Use(y) Figure 4: Execution of the quantum teleportation protocol and in each case the coin .nishes \nhead upwards. To verify (.rst branch) the transformation s1. Both branches termi\u00ad this we calculate that \nthe state under s1: |)|)(01)is invariant +2 1v nate with the null process 0. The branches are placed \nin parallel2 and the operational semantics means that only one 0111 11 v = v 101 1 22 and that the Hadamard \ntransformation H is self-inverse: 111 111 10 vv = 1 -11 -1 01 22 Meyer considers game-theoretic issues \nrelating to the ex\u00adpected outcome of repeated runs, but we just model a sin\u00adgle run in CQP (Figure 1). \nMost of the syntax of CQP is based on typed pi-calculus, using fairly common nota\u00adtion (for example, \nsee Pierce and Sangiorgi s presentation [20]). P and Q communicate by means of the typed chan\u00adnel s:l[Qbit,l[Qbit]] \nwhich carries qubits. It is a parameter of both P and Q. At the top level, System creates s with (new \ns :l[Qbit,l[Qbit]]) and starts P and Q in parallel. Q and System are also parameterized by x, the qubit \nrepre\u00adsenting the coin in its initial state. Q applies (x *= H) the Hadamard transformation to x; this \nsyntax is based on Selinger s QPL [26]. This expression is converted into an action by {...}. Using a \nstandard pi\u00adcalculus programming style, Q creates a channel t and sends (s![x, t]) it to P along with \nthe qubit x. P will use t to send the qubit back, and Q receives it with t?[z :Qbit], binding it of them \ninteracts with Q. The other branch takes no further part in the execution of the system, because there \nis noth\u00ading for it to interact with;in Figure 2 (see below) we call it Garbage. Figure 2 shows the execution \n(combining some steps) of System according to the operational semantics which we will de.ne formally \nin Section 4. Reduction takes place on con\u00ad.gurations (s; f; P)where s is a list of qubits and their \ncollective state, f lists the channels which have been cre\u00adated, and P is a process term. Note that the \nstate of the qubits must be a global property in order to be physically realistic. We record the channels \nglobally in order to give the semantics a uniform style;this is di.erent from the usual approach to pi-calculus \nsemantics, but (modulo garbage col\u00adlection) is equivalent to expanding the scope of every new before \nbeginning execution. The execution of System tracks the informal calculation which we worked through \nabove. Our CQP model makes the manipulation of the qubit very explicit;there are other ways to express \nthe behaviour (including putting everything into a single process with no communication), but the point \nis that we have a framework in which to discuss such issues. to the name z in the rest of the code. Finally \nQ applies H 2 Simpler de.nitions can be obtained if we add guarded sums again, and continues with some \nbehaviour C(z). to CQP;there is then no need for the channel t.This is P contains two branches of behaviour, \ncorresponding to straightforward but we have chosen instead to simplify the the possibilities of applying \n(second branch) or not applying presentation of the semantics. Alice;(s :l[Qbit],c :l[0..3],z : Qbit)= \ns?[x:Qbit] . Alice(x, c, z) Bob;(t :l[Qbit],c :l[0..3]) = t?[y : Qbit] . Bob(y, c) Source(s:l[Qbit],t \n:l[Qbit]) = (qbit x, y)({x *= H} . {x, y *= CNot} .s![x] .t![y] . 0) System;(z : Qbit)=(new c :l[0..3],s \n:l[Qbit],t :l[Qbit])(Alice;(s, c, z) | Bob;(t, c) | Source(s, t)) Figure 5: Quantum teleportation with \nan EPR source 3.2 Quantum Teleportation The quantum teleportation protocol [4] is a procedure for transmitting \na quantum state via a non-quantum medium. This protocol is particularly important: not only is it a fun\u00addamental \ncomponent of several more complex protocols, but it is likely to be a key enabling technology for the \ndevelop\u00adment of the quantum repeaters [6] which will be necessary in large-scale quantum communication \nnetworks. Figure 3 shows a simple model of the quantum telepor\u00adtation protocol. Alice and Bob each possess \none qubit (x for Alice, y for Bob) of an entangled pair whose state is v1(|00) + |11)). At this point \nwe are assuming that appro\u00ad 2 priate qubits will be supplied to Alice and Bob as parame\u00adters of the system. \nAlice is also parameterized by a qubit z, whose state is to be teleported. She applies (z, x*=CNot)the \nconditional not transformation to z and x and then applies (z *= H) the Hadamard transformation to z, \n.nally measur\u00ading z and x to yield a two-bit classical value which she sends (c![measure z, x]) to Bob \non the typed channel c :l[0..3]and then terminates (0). Bob receives (c?[r : 0..3]) this value and uses \nit to select3 a Pauli transformation s0 ...s3 to apply (y *= sr)to y. The result is that Bob s qubit \ny takes on the state of z, without a physical qubit having been transmitted from Alice to Bob. Bob may \nthen use y in his continuation process Use(y). This example introduces measurement, with a syntax sim\u00adilar \nto that of Selinger s QPL [26]. We treat measurement as an expression, executed for its value as well \nas its side\u00ade.ect on the quantum state. Because the result of a mea\u00adsurement is probabilistic, evaluation \nof a measure expres\u00adsion introduces a probability distribution over con.gura\u00adtions: E0.i.n pi (si; fi; \nPi). The next step is a proba\u00adbilistic transition to one of the con.gurations;no reduction takes place \nunderneath a probability distribution. In gen\u00aderal a con.guration reduces non-deterministically to one \nof a collection of probability distributions over con.gurations (in some cases this is trivial, with \nonly one distribution or only one con.guration within a distribution). A non-trivial probability distribution \nmakes a probabilistic transition to a single con.guration;this step is omitted in the case of a trivial \ndistribution. Figure 4 shows the complete execution of System in the particular case in which z, the \nqubit being teleported, has state |1). The measurement produces a probability distri\u00adbution over four \ncon.gurations, but in all cases the .nal con.guration (process Use(y)) has a state consisting of a single \nbasis vector in which y = |1). To verify the protocol for an arbitrary qubit, we can repeat the calculation \nwith initial state x, y, z = v1(|00) + |11)) . (a|0) + \u00df|1)). 2 Alice and Bob are parameterized by their \nparts (x, y)of the entangled pair (and by the channel c). We can be more explicit about the origin of \nthe entangled pair by intro\u00adducing what is known in the physics literature as an EPR source 4 (computer \nscientists might regard it as an entan\u00adglement server). This process constructs the entangled pair (by \nusing the Hadamard and controlled not transformations; note that our semantics (Section 4) speci.es that \nthe qubits x and y are each initialized to |0)) and sends its components to Alice and Bob on the typed \nchannels s, t :l[Qbit]. Figure 5 shows the revised model.  3.3 Bit-Commitment The bit-commitment problem \nis to design a protocol such that Alice chooses a one-bit value which Bob then attempts to guess. The \nkey issue is that Alice must evaluate Bob s guess with respect to her original choice of bit, without \nchanging her mind;she must be committed to her choice. Similarly, Bob must not .nd out Alice s choice \nbefore mak\u00ading his guess. Bit-commitment turns out to be an impor\u00adtant primitive in cryptographic protocols. \nClassical bit\u00adcommitment schemes rely on assumptions on the compu\u00adtational complexity of certain functions;it \nis natural to ask whether quantum techniques can remove these assumptions. We will discuss a quantum \nbit-commitment protocol due to Bennett and Brassard [3] which is closely related to the quantum key-distribution \nprotocol proposed in the same pa\u00adper and known as BB84. The following description of the protocol is \nbased on Gruska s [8] presentation. 1. Alice randomly chooses a bit x and a sequence of bits xs. She \nencodes xs as a sequence of qubits and sends them to Bob. This encoding uses the standard basis (representing \n0 by |0) and 1 by |1))if x =0, and the diagonal basis (representing 0 by |+) and 1 by |-))if x =1. 2. \nUpon receiving each qubit, Bob randomly chooses to measure it with respect to either the standard basis \nor the diagonal basis. For each measurement he stores the result and his choice of basis. If the basis \nhe chose matches Alice s x then the result of the measurement is the same as the corresponding bit from \nxs;if not, then the result is 0 or 1 with equal probability. After receiving all of the qubits, Bob tells \nAlice his guess at the value of x. 3. Alice tells Bob whether or not he guessed correctly. To certify \nher claim she sends xs to Bob.  3We can easily extend the expression language of CQP to allow explicit \ntesting of r. 4EPR stands for Einstein, Podolsky and Rosen. Alice(x:Bit,xs:Bit List,c:l[Qbit],d:l[Bit],e:l[Int],f:l[Bit \nList]) = e![length(xs)] .AliceSend(x,length(xs),xs,xs,c,d,e,f) AliceSend(x: Bit,n:Int,xs: Bit List,ys: \nBit List,c:l[Qbit],d:l[Bit],e:l[Int],f:l[Bit List]) = if n=0 then AliceReceive(x,length(ys),ys,c,d,e,f) \nelse (qbit q)( {if hd(xs)=1 then q*= sx else unit} .{if x=1 then q*= H else unit} .c![q] . AliceSend(x,n- \n1,tl(xs),ys,c,d,e,f)) AliceReceive(x:Bit,n: Int,ys:Bit List,d:l[Bit],f:l[Bit List]) = d?[g: Bit] .d![x] \n.f![ys] .0 Bob(c:l[Qbit],d:l[Bit],e:l[Int],f:l[Bit List],r:l[Bit]) = e?[n:Int] .BobReceive([ ],n,c,d,f,r) \nBobReceive(m:(Bit * Bit) List,n: Int,c:l[Qbit],d:l[Bit],e:l[Int],f:l[Bit List],r:l[Bit]) = if n=0 then \nr?[g:Bit] .d![g] .d?[a:Bit] .f?[vs: Bit List] .BobVerify(m,vs,a,length(m)) else c?[x:Qbit] .r?[y:Bit] \n.{if y =1 then x*= Helseunit} .BobReceive(m@[(y,measure x)],n- 1,c,d,r) BobVerify(m:(Bit * Bit) List,vs:Bit \nList,a: Bit,n:Int)= if n=0 then Veri.ed else if fst(hd(m)) = a then if snd(hd(m)) = hd(vs) then BobVerify(tl(m),tl(vs),a,n- \n1) else NotVeri.ed else BobVerify(tl(m),tl(vs),a,n- 1) Random(r:l[Bit]) = (qbit q)({q*= H} .r![measure \nq] .Random(r)) System(x: Bit,xs:Bit List)= (new c:l[Qbit],d:l[Bit],e:l[Int],f:l[Bit List],r:l[Bit])(Alice(x,xs,c,d,e,f) \n| Bob(c,d,e,f,r) | Random(r)) Figure 6: Quantum bit-commitment in CQP 4. Bob veri.es Alice s claim by \nlooking at the measure\u00adments in which he used the basis corresponding to x, and checking that the results \nare the same as the cor\u00adresponding bits from xs. He can also check that the results of the other measurements \nare su.ciently ran\u00addom (i.e. not signi.cantly correlated with the corre\u00adsponding bits from xs). Figure \n6 shows our model of this protocol in CQP. The complexity of the de.nitions re.ects the fact that we \nhave elaborated much of the computation which is implicit in the original description. The de.nitions \nuse the following features which are not present in our formalization of CQP, but can easily be added. \n The type constructor List and associated functions and constructors such as hd, tl, length, [], @. \n Product types (*) and functions such as fst, snd.  if - then - else for expressions and processes. \n Recursive process de.nitions.  Alice is parameterized by x and xs;they could be explicitly chosen \nat random if desired. In AliceSend, the encoding of xs relies on the fact that (qbit q) initializes q \nto |0). Bob uses m to record the results of his measurements, and n (received from Alice initially) as \na recursion parameter. Bob receives random bits, for his choices of basis, from the server Random;he \nalso guesses x randomly. The state BobVerify carries out the .rst part of step (4) above, but we have \nnot included a check for non-correlation of the remaining bits. The states Veri.ed and NotVeri.ed stand \nfor whatever action Bob takes after discovering whether or not Alice s statement in step (3) is true. \nAll measurement in CQP is with respect to the standard basis. We express measurements with respect to \nother bases by .rst applying a unitary transformation corresponding to a change of basis. This can be \nseen in the else branch of BobReceive,where thecode {if y =1 then x*= Helseunit}applies a change of basis \nif necessary. Communication between Alice and Bob uses four sepa\u00adrate channels, c,...,f. This proliferation \nof channels is a consequence of the fact that our type system associates a unique message type with each \nchannel. Introducing ses\u00adsion types [27] would allow a single channel to be used for the entire protocol, \nalthough it is worth noting that depend\u00ading on the physical implementation of qubits, separation of classical \nand quantum channels might be the most accurate model. We intend to use this CQP model as the basis for \nvarious kinds of formal analysis of the bit-commitment protocol;we make some speci.c suggestions in Section \n7. We should point out, however, that this bit-commitment protocol is insecure in that it allows Alice \nto cheat: if each qubit which she sends to Bob is part of an entangled pair, then Bob s measurements \ntransmit information back to Alice which she can use to change x after receiving Bob s guess. The real \nvalue of quantum bit-commitment is as a stepping-stone to the BB84 quantum key-distribution protocol, \nwhich has a very similar structure and is already being used in practical quantum communication systems. \n T v e P ::= ::= ::= ::= Int | Unit | Qbit | l[ .T] | Op(1) | Op(2) | ... x | 0 | 1 | ... | unit | H \n| ... v | measure .e | .e*= e | e+e 0 | (P | P) | e?[.x: .T] .P | e![.e] .P |{ e} .P | (new x: T)P | \n(qbit x)P Figure 7: Syntax of CQP v E F ::= ::= ::= ... | q | c [ ] | measure E,.e | measure v,E,.e | \n... | measure .v,E | E,.e*= e | v,E,.e*= e | ... | .v*= E | E+e | v+E [ ]?[.x: .T] .P | []![.e] .P | \nv![[ ],.e] .P | v![v,[],.e] .P | ... | v![.v,[]] .P |{ []} .P Figure 8: Internal syntax of CQP  4. \nSYNTAX AND SEMANTICS We now formally de.ne the syntax and operational seman\u00adtics of the core of CQP, \nexcluding named process de.nitions and recursion, which can easily be added. 4.1 Syntax The syntax of \nCQP is de.ned by the grammar in Figure 7. Types T consist of data types such as Int and Unit (oth\u00aders \ncan easily be added), the type Qbit of qubits, channel types l[T1,...,Tn] (specifying that each message \nis an n\u00adtuple with component types T1,...,Tn) and operator types Op(n) (the type of a unitary operator \non n qubits). The integer range type 0..3 used in the teleportation example is purely for clari.cation \nand should be replaced by Int;we do not expect to typecheck with range types. We use the notation T = \nT1,...,Tn and e.= e1,...,en and write | .e| for the length of a tuple. Values v consist of variables \n(x, y, z etc.), literal values of data types (0,1,... and unit) and unitary operators such as the Hadamard \nop\u00aderator H. Expressions e consist of values, measurements measure e1,...,en, applications e1,...,en \n*= e of unitary operators, and expressions involving data operators such as ; e+ e(others can easily \nbe added). Note that although the syntax refers to measurements and transformation of expres\u00adsions e, \nthe type system will require these expressions to re\u00adfer to qubits. Processes P consist of the null (terminated) \nprocess 0, parallel compositions P| Q, inputs e?[x.: T.] .P (no\u00adtation: x.: T.= x1 : T1,...,xn : Tn, \ndeclaring the types of all the input-bound variables), outputs e![e.] .P,actions { e} .P (typically e \nwill be an application of a unitary operator), channel declarations (new x : T)P and qubit declarations \n(qbit x)P. In inputs and outputs, the expression e will be constrained by the type system to refer to \na channel. The grammar in Figure 8 de.nes the internal syntax of CQP, which is needed in order to de.ne \nthe operational semantics. Values are extended by two new forms: qubit names q, and channel names c. \nEvaluation contexts E[] (for expressions) and F[ ] (for processes) are used in the de.nition of the operational \nsemantics, in the style of Wright and Felleisen [30]. The structure of E[ ] is used to de.ne call\u00adby-value \nevaluation of expressions;the hole [ ] speci.es the .rst part of the expression to be evaluated. The \nstructure of F[ ] is used to de.ne reductions of processes, specifying which expressions within a process \nmust be evaluated. Given a process P we de.ne its free variables fv(P), free qubit names fq(P) and free \nchannel names fc(P) as usual; the binders (of x or x.)are y?[x.: T.], (qbit x)and (new x: T).  4.2 Operational \nSemantics The operational semantics of CQP is de.ned by reduc\u00adtions (small-step evaluations of expressions, \nor inter-process communications) and probabilistic transitions. The general form of a reduction is t \n-. Ei pi ti where t and the ti are con.gurations consisting of expressions or processes with state information. \nThe notation Ei pi ti denotes a prob\u00adability distribution over con.gurations, in which Sipi =1; we may \nalso write this distribution as p1 t1 E\u00b7\u00b7\u00b7 Epn tn.If the probability distribution contains a single \ncon.guration ; (with probability 1) then we simply write t-. t. Probabil\u00adity distributions reduce probabilistically \nto single con.gura\u00ad pi tions: Ei pi ti -. ti (with probability pi, the distribution Ei pi ti reduces \nto ti). This separation of reductions and probabilistic transitions is necessary because of non-determinisim. \nA general state of a process may have a number of possible reductions, arising from communication or \nevaluation of expressions, as well as a possible measurement step with a probabilis\u00adtic outcome. In order \nto meaningfully interpret the proba\u00adbilities in such a state, we must decide whether to resolve the non-determinism \nor the probability .rst. We have cho\u00adsen to resolve the non-determinism .rst;thus, one of the non-deterministic \nreductions is the measurement, resulting in a probability distribution over con.gurations. This means \nthat our semantics is consistent with the PRISM probabilis\u00adtic model-checker [12], which we intend to \nuse for veri.ca\u00adtion. Cazorla et al. [5] discuss this issue further, and survey the approaches taken \nby several authors. The semantics of expressions is de.ned by the reduction relations -. v and -. e (Figure \n10), both on con.gura\u00adtions of the form (s; f; e). If n qubits have been declared then s has the form \nq0,...,qn-1 = | .) where | .) = a0| .0) + \u00b7\u00b7\u00b7 + a2n-1| .2n-1) is an element of the 2n-dimensional vec\u00adtor \nspace with basis | .0) = | 0 ...0) ,...,| .2n-1) = | 1 ...1) . The remaining part of the con.guration, \nf, isalistofchan\u00adnel names, which plays little part in the semantics but allows bookkeeping lemmas to \nbe proved. Reductions -. v are basic steps of evaluation, de.ned by the rules R-Plus (and similar rules \nfor any other data operators), R-Measure and R-Trans.Rule R-Perm allows qubits in the state to be permuted, \ncompensating for the way that R-Measure and (S-Nil) P | 0 = P (S-Comm) P | Q= Q| P (S-Assoc) P | (Q| \nR) = (P | Q) | R Figure 9: Structural congruence R-Trans operate on qubits listed .rst in the state. \nMea\u00adsurement speci.cally measures the values of a collection of qubits;in the future we should generalize \nto measuring ob\u00adservables as allowed by quantum physics. Reductions -. e extend execution to evaluation \ncon\u00adtexts E[ ], as de.ned by rule R-Context. Note that the probability distribution remains at the top \nlevel. Figure 11 de.nes the reduction relation -. on con.gu\u00adrations of the form (s; f; P). Rule R-Expr \nlifts reductions of expressions to F[ ] contexts, again keeping probability dis\u00adtributions at the top \nlevel. Rule R-Com de.nes communica\u00adtion in the style of pi-calculus, making use of substitution, which \nis de.ned in the usual way (we assume that bound identi.ers are renamed to avoid capture). Rule R-Act \ntriv\u00adially removes actions;in general the reduction of the action expression to v will have involved \nside-e.ects such as mea\u00adsurement or transformation of quantum state. Rules R-New and R-Qbit create new \nchannels and qubits, updating the state information in the con.guration;qubits are initialized to | 0) \n. Note that this treatment of channel creation is dif\u00adferent from standard presentations of the pi-calculus;we \ntreat both qubits and channels as elements of a global store. Rule R-Par allows reduction to take place \nin parallel con\u00adtexts, again lifting the probability distribution to the top level, and rule R-Cong allows \nthe use of a structural con\u00adgruence relation as in the pi-calculus. Structural congruence is the smallest \ncongruence relation (closed under the process constructions) containing a-equivalence (with respect to \nthe binders de.ned in Section 4.1) and closed under the rules in Figure 9.  5. TYPE SYSTEM The typing \nrules de.ned in Figure 12 apply to the syn\u00adtax de.ned in Figure 7. Environments G are mappings from variables \nto types in the usual way. Typing judgements are of two kinds. G f e : T means that expression e has \ntype T in environment G. G f P means that process P is well-typed in environment G. The rules for expressions \nare straightfor\u00adward;note that in rule T-Trans, x1,...,xn must be distinct variables of type Qbit. In \nrule T-Par the operation + on environments (De.ni\u00adtion 1) is the key to ensuring that each qubit is controlled \nby a unique part of a system. The hypothesis that G1 +G2 must be de.ned means that it is not possible \nto type a sys\u00adtem in which a qubit is shared by parallel components. This is very similar to the linear \ntype system for the pi-calculus, de.ned by Kobayashi et al. [11]. Definition 1 (Addition of Environments). \nThe partial operation of adding a typed variable to an envi\u00adronment, G+ x:T,isde.nedby G+ x: T =G,x:T \nif x . dom(G) G+ x: T =G if T= Qbit and x: T . G G+ x: T = unde.ned, otherwise This operation is extended \ninductively to a partial operation G+. on environments. Rule T-Out allows output of classical values \nand qubits to be combined, but the qubits must be distinct variables and they cannot be used by the continuation \nof the outputting process (note the hypothesis G f P). The remaining rules are straightforward. According \nto the operational semantics, execution of qbit and new declarations introduces qubit names and channel \nnames. In ordertobeabletouse thetypesystemtoprove results about the behaviour of executing processes, \nwe in\u00adtroduce the internal type system (Figure 13). This uses judgements G;S;F f e : T and G;S;F f P \nwhere S is a set of qubit names and F is a mapping from channel names to channel types. Most of the typing \nrules are straightforward extensions of the corresponding rules in Figure 12. Because references to qubits \nmay now be either variables or explicit qubit names, the rules represent them by general expres\u00adsions \ne and impose conditions that e is either a variable or a qubit name. This is seen in rules IT-Trans and \nIT-Out. Rule IT-Par is similar to T-Par in enforcing non-sharing of qubits, and is generalized to cover \nqubit names as well as variables. By standard techniques for linear type systems, the typ\u00ading rules in \nFigure 12 can be converted into a typechecking algorithm for CQP models. As an illustration of the linear \ncontrol of qubits, consider the coin-.ipping example (Figure 1). In P, any non-trivial continuation replacing \n0 would not be able to use the qubit y, which has been sent on t.In Q, after the qubit x has been sent \non s, the continuation cannot use x. Of course, at run-time, the qubit variable z in t?[z: Qbit] is instantiated \nby x, but that is not a problem because P does not use x after sending it. In System, xis used as an \nactual parameter of Q and therefore could not also be used as an actual parameter of P (if P had a formal \nparameter of type Qbit).  6. SOUNDNESS OF THE TYPE SYSTEM We prove a series of standard lemmas, following \nthe ap\u00adproach of Wright and Felleisen [30], leading to a proof that typing is preserved by execution \nof processes (Theorem 1). We then prove that in a typable process, each qubit is used by at most one \nof any parallel collection of sub-processes (Theorem 2);because of type preservation, this property holds \nat every step of the execution of a typable process. This re.ects the physical reality of the protocols \nwhich we want to model. It is similar to the unique ownership theorem of Ennals et al. [7]. We can also \nprove a standard runtime safety theorem, stating that a typable process generates no communication errors \nor incorrectly-applied operators, but we have not in\u00adcluded it in the present paper. First we work towards \nLemma 4, which is type preser\u00advation for the reductions de.ned in Figure 10. Lemmas 1 and 2 enable the \nstep from Lemma 3 to Lemma 4 in a way that corresponds to rule R-Context in Figure 10. Lemma 1 (Typability \nof Subterms in E). If D is a typing derivation concluding G;S;F f E[e]: T then (s; f; u+v) -. v (s; \nf; w)if u and v are integer literals and u+ v = w (R-Plus) (q0,...,qn-1 = a0| .0) + \u00b7\u00b7\u00b7 + a2n-1| .2n-1); \nf; measure q0,...,qr-1) -. v alm aum E0 m<2r pm (q0,...,qn-1 = | .lm ) + \u00b7\u00b7\u00b7 + | .um ) ; f; m)(R-Measure) \npm pm where lm =2n-r m, um =2n-r(m+1) - 1, pm = | alm | 2 + \u00b7\u00b7\u00b7 + | aum | 2 (q0,...,qn-1 = | .) ; f; \nq0,...,qr-1 *= U) -. v (q0,...,qn-1 =(U . In-r)| .) ; f; unit) (R-Trans) where U is a unitary operator \nof arity r (q0,...,qn-1 = | .) ; f; e) -. v (qp(0),...,qp(n-1) =.| .) ; f; e) (R-Perm) where p is a \npermutation and . is the corresponding unitary operator (s; f; e) -. v Ei pi (si; fi; ei) (R-Context) \n (s; f; E[e]) -. e Ei pi (si; fi; E[ei]) Figure 10: Reduction rules for expression con.gurations (s; \nf; e) -. e Ei pi (si; fi; ei) (s; f; F[e]) -. Ei pi (si; fi; F[ei]) (R-Expr) (s; f; c![.v] .P | c?[.x: \n.T] .Q) -. (s; f; P | Q{ .v/.x} )if | .v| = | .x| (R-Com) (s; f; { v} .P) -. (s; f; P) (R-Act) (s; f;(new \nx: T)P) -. (s; f,c; P{ c/x} )where c is fresh (R-New) (q0,...,qn = | .) ; f;(qbit x)P) -. (q0,...,qn,q \n= | .).|0) ; f; P{ q/x} )where q is fresh (R-Qbit) (s; f; P) -. Ei pi (si; fi; Pi) (s; f; P | Q) -. \nEi pi (si; fi; Pi | Q) (R-Par) P; = P (s; f; P) -. Ei pi (si; fi; Pi) . i.(Pi = P;i ) (s; f; P;) -. \nEi pi (si; fi; P;i ) (R-Cong) Ei pi (si; fi; Pi) pi-. (si; fi; Pi) (R-Prob) Figure 11: Reduction rules \nfor process con.gurations there exists U such that D has a subderivation D ; concluding Lemma 4 (Type \nPreservation for -. e ). G;S;F f e : U and the position of D ; in D corresponds to If G;S;F f e : T and \n(s; f; e) -. e Eipi (si; fi; ei) and the position of the hole in E[]. S= dom(s) and f= dom(F) then . \ni.(si = s) and . i.(fi = f) and . i.(G;S;F f ei : T). Proof. By induction on the structure of E[]. Proof. \n(s; f; e) -. e Eipi (si; fi; ei) is derived by the Lemma 2 (Replacement in E). If rule R-Context, so \nfor some E[] we have e = E[f]and . i.(ei = E[fi]) and (s; f; f) -. v Eipi (si; fi; fi). From 1. D is \na derivation concluding G;S;F f E[e]: T G;S;F f E[f]: T, Lemma 1 gives G;S;F f f : U for some U,Lemma3gives \n. i.(G;S;F f fi : U)and . i.(si = s)and 2. D ; is a subderivation of D concluding G;S;F f e: U . i.(fi \n= f), and Lemma 2 gives . i.(G;S;F f E[fi]: T). 3. the position of D ; in D matches the hole in E[] \nIn a similar way we now work towards Theorem 1. We  ; 4. G;S;F f e: U need substitution lemmas (10 \nand 11) to deal with the re\u00adduction rules R-Com, R-New and R-Qbit (Figure 11), and then G;S;F f E[e;]: \nT. Lemma 12 to deal with R-Cong. ; Proof. Replace D ; by a derivation of G;S;F f e: U. Lemma 5 (Typability \nof Subterms in F). Lemma 3 (Type Preservation for -. v ). If D is a typing derivation concluding G;S;F \nf F[e] then If G;S;F f e : T and (s; f; e) -. v Eipi (si; fi; ei) and there exists T such that D has \na subderivation D ; concluding S= dom(s) and f = dom(F) then . i.(si = s) and . i.(fi = G;S;F f e : T \nand the position of D ; in D corresponds to f) and . i.(G;S;F f ei : T). the position of the hole in \nF[]. Proof. By case-analysis on the structure of F[]. Proof. Examine each case in the de.nition of -. \nv . G fv : Int if v is an integer literal G funit : Unit (T-IntLit/T-Unit) G fH : Op(2) etc. G,x: T \nfx: T (T-Op/T-Var) ; G fe : Int G fe: Int .i.(G fxi : Qbit) x1 ...xn distinct (T-Plus/T-Msure) ; G \nfe+e: Int G fmeasure x1,...,xn : Int .i.(G fxi : Qbit) x1 ...xn distinct G fU : Op(n) (T-Trans) G fx1,...,xn \n*= U : Unit G1 fP G2 fQ G1 +G2 is de.ned G f0 (T-Nil/T-Par) G1 +G2 fP |Q G fx: l[T1,...,Tn]G,y1 : T1,...,yn \n: Tn fP G,x: Qbit fP (T-In/T-Qbit) G fx?[y1 : T1,...,yn :Tn] .P G f(qbit x)P G fx: l[T1,...,Tm,Qbit,...,Qbit] \n.i.(Ti = Qbit) .i.(G fei : Ti) yi distinct G fP (T-Out) G,y1 : Qbit ...,yn :Qbit fx![e1,...,em,y1,...,yn] \n.P G fe: T G fP G,x:l[T1,...,Tn] fP (T-Act/T-New) G f{e}.P G f(new x:l[T1,...,Tn])P Figure 12: Typing \nrules G;S;F fv : Int if v is an integer literal G;S;F funit : Unit (IT-IntLit/IT-Unit) G;S;F fH : Op(2) \netc. G,x: T;S;F fx: T (IT-Op/IT-Var) G;S,q;F fq : Qbit G;S;F,c: T fc : T (IT-IdQ/IT-IdC) ; G;S;F fe: \nInt G;S;F fe: Int (IT-Plus) ; G;S;F fe+e: Int .i.(G;S;F fei : Qbit)each ei is either xi or qi, all distinct \n(IT-Msure) G;S;F fmeasure e1,...,en : Int .i.(G;S;F fei : Qbit) G;S;F fU : Op(n)each ei is either xi \nor qi, all distinct (IT-Trans) G;S;F fe1,...,en *= U : Unit G;S;F f0 (IT-Nil) G1;S1;F fP G2;S2;F fQ G1 \n+G2 is de.ned S1 nS2 = \u00d8 (IT-Par) G1 +G2;S1 .S2;F fP |Q G;S;F fe : l[T1,...,Tn]G,y1 :T1,...,yn :Tn;S;F \nfP G,x: Qbit;S;F fP (IT-In/IT-Qbit) G;S;F fe?[y1 : T1,...,yn : Tn] .P G;S;F f(qbit x)P G;S;F fe: l[T,.Qbit.] \n.i.(Ti = Qbit) .i.(G;S;F fei : Ti) .i.(G;S;F ffi : Qbit) G;S;F fP (IT-Out) f.consists of distinct variables \nf.x and distinct qubit names f.q .x : .f.q : . G,fQbit;S, Qbit;F fe![e1,...,em,f1,...,fn] .P G;S;F fe \n: T G;S;F fP G,x:l[T1,...,Tn];S;F fP (IT-Act/IT-New) G;S;F f{e}.P G;S;F f(new x:l[T1,...,Tn])P Figure \n13: Internal typing rules Lemma 6 (Replacement in F). If 1. D is a derivation concluding G;S;F f F[e] \n 2. D ; is a subderivation of D concluding G;S;F f e : T 3. the position of D ; in D matches the hole \nin F[]  ; 4. G;S;F f e: T then G;S;F f F[e;]. ; Proof. Replace D ; by a derivation of G;S;F f e: T. \nLemma 7 (Weakening for Expressions). If G;S;F f e : T and G . G; and S . S; and F . F; then G;;S;;F; \nf e : T. Proof. Induction on the derivation of G;S;F f e : T. Lemma 8. If G;S;F f e : T then fv(e) . \ndom(G) and fq(e) . S and fc(e) . dom(F). Proof. Induction on the derivation of G;S;F f e : T. Lemma 9. \nIf G;S;F f P then fv(P) . dom(G) and fq(P) . S and fc(P) . dom(F). Proof. Induction on the derivation \nof G;S;F f P. Lemma 10 (Substitution in Expressions). Assume that G,x.: T.;S;F f e : T and let v.be values \nsuch that, for each i: 1. if Ti = Qbit then vi is a variable or a qubit name 2. if Ti = Qbit and vi \n= yi (a var) then yi . dom(G,x.: T.) 3. if Ti = Qbit and vi = qi (a qubit name) then qi . S 4. if Ti \n= Qbit then G;S;F f vi : Ti.  Let y.be the variables of type Qbit from v.(corresponding to condition \n(2)) and assume that they are distinct; let q.be the qubit names from v.(corresponding to condition (3)) \nand assume that they are distinct. Then G, .Qbit;S,q.;F f y: .e{ .x} : T. v/. Proof. Induction on the \nderivation of G,x.: T.;S;F f e : T. The next lemma makes use of the addition operation on environments \n(De.nition 1) in an essential way. Lemma 11 (Substitution in Processes). Assume that G,x.:T.;S;F f P \nand let v.be values such that, for each i: 1. if Ti = Qbit then vi is a variable or a qubit name 2. \nif Ti = Qbit and vi = yi (a var) then yi . dom(G,x.: T.) 3. if Ti = Qbit and vi = qi (a qubit name) \nthen qi . S 4. if Ti = Qbit then G;S;F f vi : Ti.  Let y.be the variables of type Qbit from v.(corresponding \nto condition (2)) and assume that they are distinct; let q.be the qubit names from v.(corresponding to \ncondition (3)) and assume that they are distinct. Then G,y.: .q;F f Qbit;S, .P{ .x} . v/. Proof. By induction \non the derivation of G,x.: T.;S;F f P. The key cases are IT-Par and IT-Out. For IT-Par the .nal step \nin the typing derivation has the form G1;S1;F f P G2;S2;F f Q G1 +G2 def. S1 n S2 = \u00d8 G,x.:T.;S;F f P \n| Q where G1 +G2 =G,x.: T and S1 . S2 =S. Each vari\u00adable of type Qbit in G,x.: T.is in exactly one of \nG1 and G2. Because the free variables of P and Q are contained in G1 and G2 respectively, substitution \ninto P | Q splits into dis\u00adjoint substitutions into P and Q. The induction hypothesis gives typings for \nP{ .x} and Q{ .x} ,which combine (by v/.v/.IT-Par)togiveG,y.: .q;F f P | Q{ .x} . Qbit;S, .v/. Lemma \n12 (Struct. Cong. Preserves Typing). If G;S;F f P and P = Q then G;S;F f Q. Proof. Induction on the derivation \nof P = Q. Theorem 1 (Type Preservation for -. ). If G;S;F f P and (s; f; P) -. Eipi (si; fi; Pi) and \nS= dom(s) and f = dom(F) then . i.(si = s) and . i.(fi = f) and . i.(G;S;F f Pi). Proof. By induction \non the derivation of (s; f; P) -. Eipi (si; fi; Pi), in each case examining the .nal steps in the derivation \nof G;S;F f P. Theorem 2 (Unique Ownership of Qubits). If G;S;F f P | Q then fq(P) n fq(Q)= \u00d8 . Proof. \nThe .nal step in the derivation of G;S;F f P | Q has the form G1;S1;F f P G2;S2;F f Q G1 +G2 def. S1 \nn S2 = \u00d8 G;S;F f P | Q where G = G1 +G2 and S = S1 . S2. By Lemma 9, fq(P) . S1 and fq(Q) . S2. Because \nS1 n S2 = \u00d8 we have fq(P) n fq(Q)= \u00d8 . All of the results up to now have been proved for the internal \ntype system (Figure 13). Our intention is that at the top level, a system should be typechecked in the \noriginal (external) type system (Figure 12), so we need the following straightforward lemma to make the \nconnection between the two systems. Lemma 13 (External/Internal Type System). G f e : T . G; \u00d8 ; \u00d8f e \n: T and G f P . G; \u00d8 ; \u00d8f P. Proof. Induction on the derivations.  7. FUTURE WORK Our aim is to develop \ntechniques for formal veri.cation of systems modelled in CQP. In particular we are working towards an \nanalysis of the BB84 quantum key distribution protocol, including both the core quantum steps and the \nclassical authentication phase. Initially we will use model\u00adchecking, in both standard (non-deterministic) \nand proba\u00adbilistic forms. Standard model-checking is appropriate for absolute properties (for example, \nthe quantum teleportation protocol (Section 3.2) claims that the .nal state of y is al\u00adways the same \nas the initial state of z). In general, however, probabilistic model-checking is needed. For example, \nthe bit-commitment protocol (Section 3.3) guarantees that, with some high probability which is dependent \non the number of bits used by Alice, Bob s veri.cation step is successful. We have obtained preliminary \nresults [16, 19] with the CWB-NC [1] and PRISM [12] systems, working directly with the modelling language \nof each tool. The next step is to de\u00advelop automated translations of CQP into these lower-level modelling \nlanguages;note that our operational semantics matches the semantic model used by PRISM. Another area \nfor future work is to develop a theory of equivalence for CQP processes, as a foundation for com\u00adpositional \ntechniques for reasoning about the behaviour of systems. We can also consider extending the language. \nIt should be straightforward to add purely classical features such as functions and assignable variables. \nExtensions which combine quantum data with enhanced classical control struc\u00adtures require more care. \nValiron s [28] recent formulation of a typed quantum lambda calculus seems very compatible with our approach, \nand should .t into CQP s expression language. 8. CONCLUSIONS We have de.ned a language, CQP, for modelling \nsystems which combine quantum and classical communication and computation. CQP has a formal operational \nsemantics, and a static type system which guarantees that transmitting a qubit on a communication channel \ncorresponds to a physical transfer of ownership. The syntax and semantics of CQP are based on a combination \nof the pi-calculus and an expression language which includes measurement and transformation of quantum \nstate. The style of our de.nitions makes it easy to enrich the language. Our research programme is to \nuse CQP as the basis for analysis and veri.cation of quantum protocols, and we have outlined some possibilities \nfor the use of both standard and probabilistic model-checking. 9. REFERENCES [1] CWB-NC: www.cs.sunysb.edu/~cwb. \n[2] S. Abramsky and B. Coecke. A categorical semantics of quantum protocols. In Proceedings, Nineteenth \nAnnual IEEE Symposium on Logic in Computer Science. IEEE Computer Society Press, 2004. [3] C. H. Bennett \nand G. Brassard. Quantum Cryptography: Public-key Distribution and Coin Tossing. In Proceedings of the \nIEEE International Conference on Computer, Systems and Signal Processing, Bangalore, India, pages 175 \n179, 1984. [4] C. H. Bennett, G. Brassard, C. Cr\u00b4epeau, R. Jozsa, A. Peres, and W. K. Wootters. Teleporting \nan unknown quantum state via dual classical and Einstein-Podolsky-Rosen channels. Phys. Rev. Lett., 70:1895 \n1899, 1993. [5] D. Cazorla, F. Cuartero, V. Valero, F. L. Pelayo, and J. J. Pardo. Algebraic theory of \nprobabilistic and nondeterministic processes. Journal of Logic and Algebraic Programming, 55:57 103, \n2003. [6] H. de Riedmatten, I. Marcikic, W. Tittel, H. Zbinden, D. Collins, and N. Gisin. Long distance \nquantum teleportation in a quantum relay con.guration. Phys. Rev. Lett., 92(4), 2004.  [7] R. Ennals, \nR. Sharp, and A. Mycroft. Linear types for packet processing. In D. Schmidt, editor, ESOP 2004: Proceedings \nof the European Symposium on Programming, volume 2986 of Lecture Notes in Computer Science. Springer-Verlag, \n2004. [8] J. Gruska. Quantum Computing. McGraw-Hill, 1999. [9] P. Jorrand and M. Lalire. Aprocess-algebraic \napproach to concurrent and distributed quantum computation: operational semantics. In P. Selinger, editor, \nProceedings of the 2nd International Workshop on Quantum Programming Languages, 2004. Also in Quantum \nPhysics Archive: arXiv:quant-ph/0407005. [10] E. Knill. Conventions for quantum pseudocode. Technical \nReport LAUR-96-2724, Los Alamos National Laboratory, 1996. [11] N. Kobayashi, B. C. Pierce, and D. N. \nTurner. Linearity and the Pi-Calculus. ACM Transactions on Programming Languages and Systems, 21(5):914 \n947, September 1999. [12] M. Z. Kwiatkowska, G. Norman, and D. Parker. PRISM: Probabilistic symbolic \nmodel checker. In T. Field, P. Harrison, J. Bradley, and U. Harder, editors, Computer Performance Evaluation \n(TOOLS 02), pages 200 204. Springer-Verlag, 2002.  [13] D. Mayers. Unconditional Security in Quantum \nCryptography. Journal of the ACM, 48(3):351 406, May 2001. [14] D. A. Meyer. Quantum strategies. Phys. \nRev. Lett., 82(5), 1999. [15] R. Milner, J. Parrow, and D. Walker. Acalculus of mobile processes, I and \nII. Information and Computation, 100(1):1 77, September 1992. [16] R. Nagarajan and S. J. Gay. Formal \nveri.cation of quantum protocols. Quantum Physics Archive: arXiv:quant-ph/0203086, March 2002. [17] M. \nA. Nielsen and I. L. Chuang. Quantum Computation and Quantum Information. Cambridge University Press, \n2000. \u00a8 Technical University of Vienna, 2000. [18] B. Omer. Quantum programming in QCL. Master s thesis, \n[19] N. Papanikolaou. Techniques for design and validation of quantum protocols. Master s thesis, University \nof Warwick, 2004. [20] B. C. Pierce and D. Sangiorgi. Typing and subtyping for mobile processes. Mathematical \nStructures in Computer Science, 6(5), 1996. [21] A. Poppe, A. Fedrizzi, T. Lor\u00a8unser, O. Maurhardt, R. \nUrsin, H. R. B\u00a8ohm, M. Peev, M. Suda, C. Kurtsiefer, H. Weinfurter, T. Jennewein, and A. Zeilinger. \nPractical quantum key distribution with polarization entangled photons. Quantum Physics Archive: arXiv:quant-ph/0404115, \n2004.  [22] E. G. Rie.el and W. Polak. An introduction to quantum computing for non-physicists. ACM \nComputing Surveys, 32(3):300 335, 2000. [23] P. Ryan, S. Schneider, M. Goldsmith, G. Lowe, and B. Roscoe. \nModelling and Analysis of Security Protocols. Addison-Wesley, 2001. [24] J. W. Sanders and P. Zuliani. \nQuantum programming. In Mathematics of Program Construction, volume 1837 of Springer LNCS, 2000. [25] \nD. Sangiorgi and D. Walker. The p-calculus: a Theory of Mobile Processes. Cambridge University Press, \n2001. [26] P. Selinger. Towards a quantum programming language. Mathematical Structures in Computer Science, \n14(4):527 586, 2004. [27] K. Takeuchi, K. Honda, and M. Kubo. An interaction-based language and its typing \nsystem. In C. Halatsis, D. G. Maritsas, G. Philokyprou, and S. Theodoridis, editors, PARLE 94: Parallel \nArchitectures and Languages Europe, 6th International PARLE Conference, Proceedings, volume 817 of Lecture \nNotes in Computer Science. Springer-Verlag, 1994. [28] B. Valiron. Quantum typing. In P. Selinger, editor, \nProceedings of the Second International Workshop on Quantum Programming Languages, 2004. [29] A. van \nTonder. A lambda calculus for quantum computation. SIAM Journal on Computing, 33(5):1109 1135, 2004. \n[30] A. K. Wright and M. Felleisen. A syntactic approach to type soundness. Information and Computation, \n115(1):38 94, 1994.  \n\t\t\t", "proc_id": "1040305", "abstract": "We define a language CQP (Communicating Quantum Processes) for modelling systems which combine quantum and classical communication and computation. CQP combines the communication primitives of the pi-calculus with primitives for measurement and transformation of quantum state; in particular, quantum bits (qubits) can be transmitted from process to process along communication channels. CQP has a static type system which classifies channels, distinguishes between quantum and classical data, and controls the use of quantum state. We formally define the syntax, operational semantics and type system of CQP, prove that the semantics preserves typing, and prove that typing guarantees that each qubit is owned by a unique process within a system. We illustrate CQP by defining models of several quantum communication systems, and outline our plans for using CQP as the foundation for formal analysis and verification of combined quantum and classical systems.", "authors": [{"name": "Simon J. Gay", "author_profile_id": "81100039420", "affiliation": "University of Glasgow, UK", "person_id": "P265421", "email_address": "", "orcid_id": ""}, {"name": "Rajagopal Nagarajan", "author_profile_id": "81100035355", "affiliation": "University of Warwick, UK", "person_id": "PP36023033", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1040305.1040318", "year": "2005", "article_id": "1040318", "conference": "POPL", "title": "Communicating quantum processes", "url": "http://dl.acm.org/citation.cfm?id=1040318"}