{"article_publication_date": "01-12-2005", "fulltext": "\n Transactors: A Programming Model for Maintaining Globally Consistent Distributed State in Unreliable \nEnvironments John Field CarlosA.Varela IBMT.J.Watson Research Center Departmentof Computer Science RensselaerPolytechnic \nInstitute j.eld@watson.ibm.com cvarela@cs.rpi.edu ABSTRACT We introducetransactors,afault-tolerant programming \nmodel for composing loosely-coupled distributed components running in an unreliable environment such \nas the internet into systems that re\u00adliably maintain globally consistent distributed state. The transac\u00adtor \nmodel incorporates certain elements of traditional transaction processing,but allows these elements to \nbe composed in different ways without the need for central coordination, thusfacilitating the studyof \ndistributedfault-tolerancefroma semanticpointofview. Weformalize our approach via thet -calculus, anextended \nlambda\u00adcalculus based on the actor model, and illustrate its usage througha numberofexamples. The t -calculus \nincorporates constructswhich distributed processes can use to create globally-consistent check\u00adpoints. \nWe provide an operational semantics for the t-calculus, and formalize the following safety and liveness \nproperties: .rst, we show that globally-consistent checkpoints have equivalent exe\u00adcution traces withoutanynodefailuresorapplication-levelfailures, \nand second, we show that it is possible to reach globally-consistent checkpoints provided that thereis \nsome boundedfailure-free inter\u00adval during which checkpointing can occur. Categories and Subject Descriptors \nD.3.3 [Programming Languages]: Language Constructs and Features concurrent programming structures; F.3.2 \n[Logics and Meanings of Programs]: Semantics of Programming Languages operational semantics, process \nmodels; D.4.5 [Operating Systems]: Reliability checkpoint/restart, fault\u00adtolerance; D.1.3 [Programming \nTechniques]: Concurrent Programming distributed programming GeneralTerms Languages, Reliability, Design, \nTheory  Keywords Distributed state,Transactor,Tau-calculus,Actor Permission to make digital or hard \ncopies of all or part of this work for personal or classroom use is granted without fee provided that \ncopies are not made or distributed for pro.t or commercial advantage and that copies bear this notice \nand the full citation on the .rst page. To copyotherwise, to republish, to post on servers or to redistribute \nto lists, requires prior speci.c permission and/or a fee. POPL 05, January 12 14, 2005, Long Beach, California, \nUSA. Copyright 2005ACM 1-58113-830-X/05/0001 ...$5.00. 1. MOTIVATION Many distributed systems must maintain \ndistributed state. By this, we mean that the states of several distributed components in a network-connected \nsystem are interdependent on one another. The classicalexampleof sucha scenarioisa bank transactioninvolving \nthe transfer of moneyfrom one account to another, where we must ensure thatitis not possible(evenin the \npresenceofa systemfail\u00adure) for one account to be debited without a corresponding credit being made to \nthe other account, and vice-versa. Ensuring that these interrelated states are maintained in a con\u00adsistent \nway in a wide-area network where transmission latencies may be high, and where node and linkfailures \nare relatively com\u00admon occurrences is dif.cult. By exposing key semantic con\u00adcepts relatedto maintenanceof \ndistributed stateinacommon, well\u00adfounded language, rather than relegating these issues to system or middleware, \ncomposite distributed applications can reason about thefailure semanticsof their components, and,if appropriate, \nsup\u00adply extra protocol layers (e.g., logging, rollbacks, retries, replica\u00adtion, etc.) to add additional \nreliability. To better illustrate the complexity of maintaining distributed state in a loosely-coupled \ndistributed system, consider a collection of web services that are combined dynamically to manage the \npur\u00adchase of a house. Such a purchase is a complex multi-step trans\u00adactioninvolving manyinteracting participants.Today, \nmanyof the steps required to purchase a house entail tedious requests and re\u00adsponsesfor information via \ntelephone calls,faxes and paper docu\u00adments. However, in the future, it should be possible for virtually \nall the information generated during the process to be exchanged and managed electronically. Figure 1 \ndepicts a subset of the operations that might be per\u00adformed by a collection of web services involved \nin the negotia\u00adtion of a house purchase, and serve to illustrate manyof the issues thatariseinbuildingan \ninfrastructureto supportsuch services.We will consider such services to be concurrent processes that \ncan send and receive messages to other processes as well as spawn new pro\u00adcesses. The negotiation may \ninvolve the failure and subsequent recovery of several sub-processes. In the .gure, the vertical bars \nlabeled by buySrv and sellSrv represent web services acting on behalf of the buyer and seller, respectively. \nlendSrv, apprSrv, and srchSrv represent web services for a lender, appraisal service, and title search \nservice, respectively. lendTrns, apprTrns, and srchTrns represent sub-processes spawnedby the lender, \nappraisal service, and search service speci.cally to manage the interaction with the particularbuyerin \nthisexample. Horizontal arrows depict messages sent between processes or the creation of new processes. \nPortionsofthevertical processbarsthat areblack represent stable states , where the state maintained by \nthe process should not sub\u00adsequently change. Process rollback (arising from various forms of failure)is \ndepictedby dashed diagonal arrows. In the example depicted in Fig. 1, apprTrns generates an esti\u00admated \nprice based on speci.cations (size of house, age, etc.) pro\u00advided electronically. As is typical in such \ntransactions, elements of the process proceeds optimistically under the assumption that the initial speci.cations \nare correct, while a human veri.es by on-site inspection that the electronic speci.cations are indeed \naccurate. In this case, the inspector discovers an inconsistencybetween the ac\u00adtual speci.cations and \nthose provided electronically, and causes the appraisal process to be rolled back and restarted using \nthe correct speci.cations. The system must then somehow reconcile thefact that the components of the \ndistributed state are now inconsistent (e.g., the mortgage applicationwas initiatedby thebuyerbased in\u00adformation \nfrom an inaccurate appraisal), and bring the full system back to a consistent state. Here, a consistent \nstate is restored when lendTrns requests price information from apprTrns and returns a message indicating \nthe mortgage has been approved to buySrv. At that point, the state of buySrv is based on inconsistent \ninfor\u00admation: the original price returned by apprTrns and the approved mortgaged based on an updated \nprice generated by apprTrns after rollback of the initial state. The transactor model serves to maintain \ndependence information needed to detect semantic inconsistencies such as that depicted in Fig. 1, and \nto cause the rollback of the buySrv process to occur automatically. In addition to such semantic failures, \nprocess or networkfailures during the course of the transaction might cause information loss that requires \nan orderly re-establishment of the transaction s distributed state. Note, however, that certain steps \nof the transaction, such as the title search, need not be renegotiated after a semantic or system failure, \nsince the results of the search are unaffected by the inconsistent appraisal values. Such steps can be \ncommitted early in the process, while other steps (such as the .nal transfer of the purchase price) might \nrequire mutual agreement between multiple parties to be reached before becoming durable and binding. \nIn this paper, we describe the transactor model, afault-tolerant programming model for composing loosely-coupled \ndistributed components running in an unreliable environment such as the in\u00adternet into systems that reliably \nmaintain consistent distributed state. Our model is not concerned with certain aspects of tradi\u00adtional \nACID transactions [13] such as isolation or certain forms of atomicity. While such features are beyond \nthe scope of this pa\u00adper, they can be explicitly coded in our model if desired, e.g., in a manner similar \nto [12]; instead, we focus on ensuring consistency of distributed state in the presence of certain types \nof node and net\u00adworkfailures. In particular, we assume thata nodefails eitherby stopping,orbyrevertingtoa \nprogrammatically-de.ned checkpoint saved to stable storage, then restarting. The remainder of the paperis \nstructured as follows: Section2 introduces relatedwork. Section3informally describes the trans\u00adactor \nmodel. Section 4 introduces the syntax of the t-calculus, an extended lambda-calculus based on the actor \nmodel. Section5 illustrates some representative transactorexamples. Section6pro\u00advides an operational \nsemantics for the t -calculus. Section7 for\u00admalizes safety and liveness properties of the model. The \nreader is referred to [10] for complete proofs. Finally, Section8concludes with a discussion and potential \nfuture directions.  2. RELATEDWORK The transactor model is based on the actor model introduced by Hewitt \n[15], and further re.ned and developed by Agha et al. [1, 3, 20]. Actors are inherently independent, \nconcurrent, and au-  Figure 1: A house purchase scenario involving the seman\u00adtic failure and rollback \nof the apprTrns sub-process due to inconsistent information about house speci.cations. This ulti\u00admately \nresults in the rollback of the buySrv process itself, due to the inconsistency between the appraised \nprice used to initi\u00adatethebuyingprocess,andthedifferingprice incorporatedin the mortgage approval sub-process. \ntonomous which enables ef.ciencyin parallel execution [16] and facilitates mobility [2]. The actor model \nand languages provide a very useful framework for understanding and implementing open distributed systems. \nTraditionally, distributed state maintenance has been viewed primarily as a systems or middleware [5] \nproblem, in which, e.g., system infrastructure for message-passing provides guaran\u00adteed message delivery \non an unreliable network substrate [6, 21], or where distributed databases or transaction systems support \nthe il\u00adlusion of shared, atomically-updatable state across multiple nodes [17, 19]. Anumber of projects \nare underway to realize distributed programming models for the internet, e.g., the web services model \nbased on exchange of XML data [22]. Distributed transaction management systems, e.g., those that im\u00adplement \nthe XA system-neutral transaction API [23], typically re\u00adquire that all of the participants in the transaction \ncoordinate their work with a pre-designated transaction manager, and that every transaction has well-de.ned \nbeginning and end points. These prop\u00aderties make it dif.cult tobuild open distributed systems where the \ntopology of the system is determined dynamically, where the scope of and even the need for a transaction \nis situation-dependent, andwhere transactional and non-transactional components can eas\u00adily interact. \nWhile there is much existing foundational work on languages for concurrent, and to a lesser extent, distributed \nsys\u00adtems (e.g., actors [1, 3], the p-calculus [18], the join calculus [11], and mobile ambients [7]), \nformalisms that provide primitives for reasoning about the consistencyof distributed state in the presence \noffailures are not welldeveloped. Liskov s Argus language [17] incorporates constructs for main\u00adtenance \nof distributed state (via nested transactions). Liskov intro\u00adduced two principal abstractions: guardians \nand actions. Argus es\u00adsentially providesaprogramming interface onto centrally-managed nested transactions. \nBy contrast, with transactors, we intend to uniformly modelavarietyoffailure-management techniques, in\u00adcluding \ntransactions and applications with weaker consistency se\u00admantics. Haines et al. designed an extension \nto ML to modularly support .rst-class transactions [14]. That is, atomicity, isolation and durability \nproperties canbe composed as desired.We are con\u00adcerned with distributed state consistencyand durability, \nand do not explicitly model isolation. Atomicity within a transactor is inher\u00adited from the actor model, \nwhere each transactor represents a unit of concurrencyand processes only one message at a time. Other \nactor-based abstractions (such as synchronizers [12]) can be used to provide atomicity for actions performed \nby groups of co-related actors. Chotia and Duggan s abstractions forfault-tolerant global com\u00adputing \n[8] include conclaves as groups of correlated processes whichfail atomically, and logs which abstractoverpersistent \nstor\u00adage. Berger and Honda provide an extension to the p-calculus to model the two-phase commitment protocol \n[4]. While the moti\u00advation of their work is similar to ours, the approaches are quite different. The \ntransactor model does not assume atomicity in pro\u00adcess groupfailures: transactors canfail independently \nand causal dependencies are carried along with messages to ensure that only globally consistent checkpoints \ncanbe reachedbyapplication-level protocols. Our calculus also enables reasoning about and compos\u00ading \nmodules with different transactional semantics and reliability properties. A preliminary account of the \nideas underlying the transactor model was published as [9]; it contained no correctness proofs. While \nthe work presented here shares some of the ideas of the ear\u00adlier paper,almost all of the semantic components \nof t-calculus have been updated and simpli.ed.  3. TRANSACTOR MODEL The goal of the transactor model \nis to enable developing reliable systems composed from potentially unreliable components, which may suffer \nboth systemfailures and application-speci.c semantic inconsistencies. We show that given anytwo checkpointed \nglobal states k and k. of a distributed system such that k and k. are re\u00adlated by an execution trace \ncontaining inconsistent states resulting from node failures, application-level failures, and lost messages, \nthere exists an equivalent execution trace containing only message losses. Hence programmers using our \nmodel need only reason about the possibility of lost messages, not about the other forms offailure. Transactors \nextend the actor model [1] by explicitly modeling node failures, network failures, persistent storage, \nand state im\u00admutability.Atransactor encapsulates state and communicates with other transactors via asynchronous \nmessage passing. In response to a message, a transactor may create new transactors, send messages to \nother transactors, or modify its internal state. In addition to these inherited actor operations, a transactor \nmay stabilize, checkpoint, or rollback. Atransactor s stabilizationisa commitmentnottomodifyitsin\u00adternal \nstate i.e.,to becomeimmutable untilasubsequent check\u00adpoint is performed or until another peer actor causes \nit to rollback due to semantic inconsistencies. Stabilization can be thought of as the .rstphaseofatwo-phase \ncommitmentprotocol. Acheckpoint serves two purposes: .rst, it is a commitment to makethe current transactor \nstate persistent, i.e. able to survivelocal temporary node failures; and second and most important, it \nis a consistencyguarantee, i.e. there are no pending dependencies on the volatile state of peer transactors. \nDependence information is carried along with messages, so that only globally consistent states can be \ncheckpointed. Checkpoint can be thought of as the second phase of a two-phase commitment protocol. A \nrollback operation brings a transactor back to its previously checkpointed state, if any, or makes it \ndisappear otherwise. Node failures have a similar effect. 4. THETAUCALCULUS The t-calculus is based \non an extended, untyped, call-by-value lambda calculus; its terms are depicted in Fig. 2. The basic lambda \ncalculus constructs are standard and we will not comment on them further. The extensions can be divided \ninto two categories, those terms(EA)that encode the traditional actor [1] semantics with ex\u00adplicit state \nmanagement, and additional constructs to support dis\u00adtributed state maintenance. In this section, we \nwill give a brief, intuitive tour of t-calculus constructs, and defer a more detailed discussion of its \nsemantics to Section 6. 4.1 Traditional Actor Constructs The transactor creation construct trans e1 init \ne2 snart cre\u00adates a new transactor with behavior e1, and initial state e2. The behavior must evaluate \nto an abstraction term; intuitively, this term evaluates each incoming message to the created transactor. \nThe expression returns a transactor name, a fresh value that can be subsequently used as the target of \nthe message send construct, send v to t. This construct sends a message with contents v to the transactor \nnamed t. The ready construct indicates that a transactor is waiting to process the next incoming message. \nself yields the transactor s own name. The setstate(v) construct imperatively updates a transactor s \nstate to the value v. A message send can potentially introduce a causal dependency from the sender to \nthe target transactor, if the target transactor modi.es its state in response to the message. When a \ntransactor has committed not to change its state, execution of setstate(v) has no effect; thus the expression \nsetstate(v) returns a boolean value indicating whether or not the state update actually took place. getstate \nretrieves the value of the state. 4.2 State Maintenance Constructs The stabilize construct causes the \ncurrent transactor to ignore subsequent setstate(v) or rollback expressions and become stable;thisfactis \ncommunicatedby the underlying operational se\u00admantics to other transactors with which the current transactor \ncorre\u00adsponds,andisineffecta promise tothe transactor speersthatthe transactor will not attempt to change \nits own state. Note that even after entering a stable state via the stabilize construct, a trans\u00adactor \ncan still process messages, it simply cannot change its own state. The checkpoint construct creates a \ncheckpoint, which is (ef\u00adfectively) a copyof the transactor s current state which can be re\u00adcoveredin \ntheeventof certainfailures. Acheckpoint can only be made if the current transactor is not dependent on \nthe volatile state of one or more other transactors. That is, a state potentially unrecoverablein the \npresenceof nodefailures. The dependent? construct tests whether this is the case. The rollback construct \ncauses a transactor to revert to its previous checkpoint, if one ex\u00adists, and causes the transactor to \ndisappear otherwise. As with the setstate(v) construct, the rollback construct has no effect when the \ntransactor is stable. 4.3 De.nedForms Fig.3depictsanumberof de.nedformsthatprovideconvenient syntactic \nsugar for writing t-calculus programs. Most of these con\u00adstructs are self explanatory, a few deserve \nfurther explanation: The msgcase construct yieldsalambda abstraction whosebody processes incoming messages. \nMessages are assumed to take the A = {true, false, nil,...} Atoms N = {0, 1, 2,...} Natural numbers T \n= {t1,t2,t3,...} Transactor names X = {x1,x2,x3,...} Variable names F = {=, +,...} Primitive operators \nV ::= Values A|N |T |X | .X. E Lambda abstraction | (V, V) Pair constructor EP ::= Pure expressions V \n| (EE) Lambda application | fst(E) First element of pair | snd(E) Second element of pair | if E then \nE else E . Conditional | letrec X = E in E ni Recursive de.nition |F(E,..., E) Primitive operator EA \n::= Traditional actor constructs EP | trans E init E snart New transactor | send E to E Message send \n| ready Ready to receive message | self Reference to own name | setstate(E) Set transactor state | getstate \nRetrieve transactor state E ::= Transactor expressions EA | checkpoint Make failure-resilient | rollback \nRevert to prev. checkpt. | stabilize Prevent state changes | dependent? Test dependence Figure 2:Terms. \nform of a vector of parameters, the .rst of which is an atom that constitutes a message name. The msgcase \nbody tests the value of the incoming message and processes the other message arguments appropriately; \nmessages that are not understood are ignored. The declstate construct declares names foratransactor sstate, \nwhich is presumed to consist of a vector of elements. This con\u00adstruct doesnot expand intoa core t -calculusexpression, \ninstead, it simply de.nes a static name scope for subsequent references of the form !u and u := e, which \nexpand into appropriate operations on the transactor s state vector.  5. TRANSACTOR EXAMPLES In this \nsection, we illustrate a few representative transactor pro\u00adgrams.We referthe readerto[10]foradditionalexamples. \n 5.1 Reference Cells We begin with a simple reference cell and tworeliable versions thereof providing \nprogressively more re.ned notions of consistent state under differentfailure and interaction assumptions. \nThe cell program, shown in Figure 4, is a volatile reference cell that never gets checkpointed: it cannot \ntolerate processfailures and therefore, any other programs which depend on that cell s value will not \nbe able to reach consistent states or checkpoint. The pcell1 program is a .rst attempt to provide a cell \nwhose invariant is to always checkpoint its current value to be able to recover from process failures. \nUpon creation it must receive an initialize message, that creates an initial checkpoint. Notice that \nit .rst needs to become stable to succeed checkpointing. Also no\u00adtice that the creator of that cell needs \nto be stable as well for that checkpoint to succeed. On reception of a set message, the cell will modify \nits value, and checkpoint again. This checkpoint as\u00adsumes that the transactor sending the set message \nis stable, and therefore, does not create spurious dependencies on the cell upon state assignment. On \nreception of a get message, the cell needs to [vec1] (e1,...,en) (e1, (..., (en, nil)) ...), n> 0 [vec2] \n() nil [vec3] x (x1,...,xn) for some n = 0 [seq] e1; e2 ((.x. e2) e1), . fv(e2) x/ [if1] if e1 then e2 \n. if e1 then e2 else nil . [let1] let x = e1 in e2 ni ((.x. e2) e1) [let2] let (x1,...,xn) = e1 in e2 \nni let x1 = fst(e1) in ... let xn = fst(snd(... snd(e1) ...)) in e2 ni ... ni [vabs] .x . e '' .x'. \nlet x = xin e ni,x./fv(e) [msg1] msg xx (msg,x ) [msg2] msgcase msg1 x 1 . e1 | ... | msgxxn . en n \nesac .(m, z'). ( if m = msg1 then ' let xx1 = zin e1 ni else ... if m = msgthen n ' let x n = zin en \nni else ready . ... .; ready ) [sta1] declstate (u1,...,un) in e etats declaration of names for n elements \nof state [sta2] !ui let (x1,...,xi, xz) = getstate in xi ni ui is the ith name declared in the closest \nstatically-enclosing declstate scope, of length n, n = i> 0 [sta3] ui := e setstate((!u1,..., !ui-1, \ne, !ui+1,..., !un)) where ui is the ith name declared in the closest statically-enclosing declstate scope, \nof length n, n = i> 0 Figure3: De.nedforms. stabilize .rst, to ensure that no new dependencies are incurred \nin the cell s customer. And .nally, to preserve the invariant of being just checkpointed (and therefore, \nvolatile) on message reception, it does a .nal checkpoint. The pcell2 program builds on the previous \nexample, but also considers the possibility that the clients setting thevalueof the cell maydoitfromavolatile(i.e., \nunstable) state.Inthiscase,thecell s set message handler checks for anyoutstanding dependencies af\u00adter \nupdating its state, and if the transactor is dependent on other transactors, it rolls back to its previously \n(known to be) consistent state. pcell2 is strictly more reliable than pcell1 in the sense that it considers \ninteraction with potentially volatile clients. 5.2 Electronic MoneyTransfer The traditional electronic \nmoney transfer example depicted in Fig. 5 is implemented with transactors using a a protocol simi\u00adlar \nto classical two-phase commit protocols. teller represents an ATM machine or a similar coordinator for \na transfer between two bankaccounts. All of the transactors are assume to be persistent and checkpointed \ninitially, and we assume that the teller has ex\u00ad let cell = trans declstate (contents) in msgcase set(val).contents \n:= val | get(customer). send data(!contents)to customer esac etats init (0) snart let pcell1 = trans \ndeclstate (contents) in msgcase initialize() .stabilize; checkpoint | set(val).contents := val; stabilize; \ncheckpoint | get(customer). stabilize; send data(!contents)to customer; checkpoint esac etats init (0) \nsnart let pcell2 = trans declstate (contents) in msgcase initialize() . stabilize; checkpoint | set(val).contents \n:= val; if dependent? then rollback else stabilize; checkpoint . | get(customer). stabilize; send data(!contents)to \ncustomer; checkpoint esac etats init (0) snart Figure 4: A progressively more re.ned reference cell. \nThe leftmost example is an unreliable reference cell. The middle one is a persistentreference cell which \nassumes stable clients. The rightmost cellrepresentsa persistentreliablereference cell. clusive access \nto both accounts. Isolation and locking, if needed to ensure exclusive access, can be managed by appropriate \nauxiliary transactors. The basic protocol used in the example is quite simple. The teller sends appropriate \naccount adjustment requests to each ac\u00adcount. Each account separately determines whether it is able to \nful.ll the request. If so, it stabilizes and sends done (with a result message) to the teller. If not, \nit also sends done (with an error mes\u00adsage) to the teller, then rolls back. When the teller has received \ntwo done messages, it stabilizes, then requests that each account send a ping message both to its peer \naccount and to the teller. Note that at this point in the protocol, the teller has no idea whether the \nupdate has been successful or not (assuming that it is not interpreting the messages returned by done). \nHowever, if either of the transactors has rolled back in the meantime due to insuf.cient funds or sponta\u00adneousfailure, \nthe ping messages will incorporate inconsistent de\u00adpendence information, thus effectively resulting in \nrollback when received.Inthe absenceoffailure, each transactor willeventually receive suf.cient ping \nmessages for the checkpoint operation to succeed; until that point, the checkpoint is a no-op. The protocolin \nFig.5 ensures that the transfer willalways com\u00adpleteina consistent state, either with both accounts updated \nappro\u00adpriately, or both left unchanged. The protocol does not deal directly with certain combinations \nof message losses; however, it could eas\u00adily be augmented by adding a timer transactor that periodically \nre-sends ping requests if the participants have not checkpointed. Note that we could easily interpose \na currencyconverter trans\u00adactor between participants which does not need to know that the parties involved \nare part of a transaction the model enables to compose services with full transaction semantics with \nservices that do not have any transactional behavior in a seamless and correct manner.  6. OPERATIONAL \nSEMANTICS In this section, we provide an operational semantics for the t \u00adcalculus.We .rst need to establish \nsome notational conventions. 6.1 Notational Preliminaries Most of the notation we use in the sequel \nis standard or self\u00adexplanatory. Here, we cover a few concepts that are not standard. Grammarsas sets. \nWewill often de.ne sets using context-free grammars,andwillusea non-terminalofthe grammarto represent \nthe set of all terms derivable from that non-terminal. Lists. Given a set S, we will use [S] to denote \nthe set of lists de.ned over S, where [] denotes the empty list, and s :: ls denotes a list cell.We will \nfrequently use [e1; e2; ... ; en] as a shorthand to denote e1 ::(e2 ::(... (en ::[]) ...)). len(l) denotes \nthe length of l, and lastn(n, l) denotes the list consisting of the last n elements of l (for 0 = n = \nlen(l))). f Finite maps. Given sets S1 and S2, S1 . S2 denotes the set of .nite partial maps from S1 \nto S2, where dom(m) and ran(m) denote the domain and range of m, respectively. We will use \u00d8 to denote \nthe empty map, m(x) to denote the element to which m maps x, m[x . e] to denote the map that is the same \nas m, except that x is mapped to e, and m \\ x to denote the map m . that is the same as m, except that \nx ./dom(m .). We will use [x . e] as a shorthand for \u00d8[x . e]. Let m be a map, and f be a function from \nran(m) to ran(m). Then we will use m[x . f] as a shorthand for the map m[x . f(m(x))]. m .(x)= f(m(x)). \nIf we want to apply f to selected elements of a map, we will sometimes use map comprehension expressions \nsuch as {[x . f(e)] | x . dom(m),e = m(x),p(x, e)} to generate new maps from m in the obvious way. Multisets. \nIf S is a set, then {{S}} denotes the set of multisets, (i.e., bags) consisting of collections of elements \nof S. We will use l to denote multiset union.We will also sometimes use multiset comprehension expressions \nsuch as {{f(x) | x .M,p(x)}} to generate new multisets from M in the obvious way (multiple in\u00adstances \nof x generate the same number of instances of f(x)). We will use s\\x to denote the multiset s . which \nis the same as s,except that one instance of x has been removed. let bankaccount = trans let teller = \ntrans declstate (bal) in declstate (inacct, outacct, acks) in msgcase msgcase adj(delta, atm). transfer(delta). \nbal := !bal + delta; send adj(delta, self) to !inacct; if !bal < 0 then send adj(-delta, self) to !outacct \nsend done(\"Not enough funds!\") to atm | done(msg). rollback send println(msg) to stdout; else acks := \n!acks + 1; stabilize; if !acks =2 then send done(\"Balance update successful\") to atm stabilize; . send \npingreq(!inacct) to !outacct; | pingreq(requester). send pingreq(!outacct) to !inacct; send ping() to \nrequester send pingreq(self) to !outacct; | ping() . // may cause rollback send pingreq(self) to !inacct \ncheckpoint . esac | ping() . // may cause rollback etats checkpoint init esac (0)etats snart init (savings, \nchecking, 0) snart Figure 5: Electronic money transfer example. Illustrates nontrivial use of stabilize \nfor a protocol similar to two-phase commit. Note that ping messages are used to communicate status (stable \nor rolled-back) implicitly: checkpoints resulting from receipt of ping messageswill succeedonlyifallpeer \ntransactorshave stabilized;otherwiseitwillbea no-op(ifpingshavenotyetbeenreceived from peers), or cause \nrollback (if peer is inconsistent). Pattern Matching. When writing rules comprising the opera\u00adtional \nsemantics for transactors,we will usevarious pattern match\u00ading constructs, both to determine the applicability \nof a particular rule, and to match components ofterms to variables. In addition to the usual convention \nof building patterns by applying term con\u00adstructors to variables, we will also use the following additional \npattern-related conventions: The underscore character  matches any term. The pattern m[x . p] matches \nanymap m . for which x . dom(m .) and p matches m .(x);the variablem is then bound to the map m . \\x. \nFinally, the pattern sl{x} matches anymultiset s ., in which case x is bound to an arbitrary element \nof s ., and s is bound to the multiset s . \\ x.  6.2 Reduction Contexts Each transition rule of our \noperational semantics will refer to a particular redex term within the lambda term encoding a transac\u00adtor \ns behavior. As is standard for lambda calculi, we will use the notion of reduction contexts of the form \nR(D) to distinguish the redexon which the transition rule will operate. Each reductioncon\u00adtext is a special \nterm with a single hole element D, de.ned such thatatransactorbehavior canbe uniquely decomposed intoexactly \none redex and one reduction context. Our de.nitions for redex and reduction context are completely standard \nand are covered in [10].  6.3 Transactor Con.gurations Fig. 6 depicts a collection of semantic domains \nthat the t \u00adcalculus operational semantics will manipulate. A volatility value w .W encodes thefact thata \ntransactoris volatile (w = V(n) for some n = 0)orstable (w = S(n),n = 0). The value of n will be referred \nto as an incarnation. Ahistory h .H encodes the checkpoint history of a transactor. A historyh = (w, \nlh) encodes thefact that the transactor which refers to h has volatility value w, and has checkpointed \nlen(lh) times since its creation, where the values in the list lh re.ect the incarnation at which each \ncheckpoint occurred. The t-calculus semantics de.nes four operations on histories: 1. When a transactor \nis created, its history is initialized to (V(0), []). 2. When a transactor with history (V(n),lh) rolls \nback, its incarnation is incremented by 1, i.e., its history becomes (V(n + 1),lh). 3. Ifatransactorwith \nhistory (S(n),lh) checkpoints, its history becomes (V(0),n :: lh). 4. If a transactor with history (V(n),lh) \nstabilizes, its history becomes (S(n),lh).  Dependence maps . are critical auxiliary structures that \ncan in\u00adformally be thought of as encoding the states of all transactors on which some value depends. \nMore precisely, a dependence map maps each transactor name t on whichitis de.nedtoahistoryvalue associated \nwith t. Dependence maps are associated with three dis\u00adtinct semantic componentsofatransactor:the transactorsonwhich \nt is dependent for its existence (the creation dependence map), the transactors on which t s current \nstate depends (the state depen\u00addence map), and the transactors on which the value of the current redex \ndepends (the behavioral dependence map). By separating a transactor s dependences into three components, \nwe can distin\u00adguish those dependences related to creationfrom those related to state (which have radically \ndifferent semantic consequences), and avoid the creation of spurious dependences when, e.g., a transactor \nnever reads its state. Atransactor t .S = (b, sv ; e, s ; ds,dc,db) is a 7-tuple con\u00adtaining the following \ncomponents: The volatile state component s contains t s current state; we say that s is volatile since \nits value is lost in the event of t sfailure. By contrast, the persistent state component sv encodes \nthe last value of s storedby a checkpoint operation; this state is resilient tofailure and models stable \nstor\u00adage. The behavior of t, i.e., its .xed response to everyincoming message, is represented by b; in \norder to be well-formed, b must be a lambda expression. The evaluation state component, e, is an expression \n(generally partially evaluated) representing the current W ::= V(N) | S(N ) Volatility value H ::= (W, \n[N ]) Transactor history f .= T .H Dependence map S ::= (V, V ; E, V ;., ., .) Transactor M ::= T .(V, \n.) Message f T= T .S Name service K ::= {{M}} | T Transactor con.guration Figure 6: Semantic domains. \nstate of the evaluation of a transactor s behavior. The state depen\u00addence map component, ds, is a dependence \nmap that encodes the fact that the state of t is dependent (transitively) on the states of all of the \ntransactors in dom(ds), whose histories are encoded in the map. The creation dependence map component, \ndc, is similar to ds, except that it records information about the transitive depen\u00addence of t on the \nparent transactor that initially created t . Finally, the behavioral dependence map component, db, represents \nthe be\u00adhavioral dependences of the transactor, i.e., the dependences of the current redex under evaluation. \nNote that we use both commas and semicolons to separate com\u00adponents of a transactor. There is no semantic \ndistinction between the two; this is a purely syntactic convention designed to sepa\u00adrate transactor components \ninto three (semicolon-separated) log\u00adical clusters for easier reading. These clusters represent, respec\u00adtively, \npersistent (i.e., durable) components that survivefailures(b 9 encodes thefact thata transactor has rolled \nback.A volatile transactor can roll itself back (the .rst case for 9 ) or be rolled back spontaneously \ndue to node failure or inconsistent state; a stable transactor (the second case)only rolls back if its \nstate is found to be inconsistent. The .. transition encodes thefact that a transactor has stabilized, \nand .v encodes thefact thata trans\u00adactor has checkpointed. Since these relations are functions, we will \nsometimes speak of applying them to a history to yield a new history. We can now de.ne the following \ncomposite relation: ( ... ..v) ( is succeeded by ) Intuitively, h1 r* h2 if h1 and h2 are valid histories \nfor the same transactor (say, t ), and h2 occurs after h1 in some execution trace for t. r* de.nes a \npartial order on histories. We will say that histories h1 and h2 are comparable if either h1 r* h2 or \nh2 r* h1. Finally, we have the following relation: \u00b7 * ( is superseded by ) Intuitively, h1 > h2 if \nh2 is a history of a transactor that rolled back from the state represented by history h1, then proceeded \nto do zero or more additional operations. Thus the state represented by h2 supersedes theobsolete state \nrepresentedby h1.We will say that two histories are consistent if neither supersedes the other. Given \nconsistent histories h1 and h2 we de.ne the sharpening operation, notated h1 rh2, as follows: and sv),volatile \ncomponents that generallydonot survivefailures (e and s), and dependence information(ds, dc, and db). \n8< : h ' if there exists h ' such that h ' h1 h2 = h1 .. * h2 h1 otherwise A message m .M contains a \ntarget transactor name encod\u00ading the message s destination, a value representing the message s payload, \nand a dependence map encoding the transitive closure of transactors on which the message s payload is \ndependent. Atransactor con.guration k .K is a pair consisting of a net\u00adwork, a multiset of messages, \nand a nameserver map from trans\u00adactor names to transactors. The network serves tobuffer messages sent \namong the transactors in the con.guration. The multiset rep\u00adresentation for the network encodesthefact \nthat the orderin which messages sent to the same transactor are received is unrelated to the orderin \nwhich they were sent(even from the same sender).  6.4 History and Dependence Map Operations In this \nsection, we de.ne a number of auxiliary operations on histories, dependence maps, and related structures \nthat will be re\u00ad quired by the operational semantics. Basic history operations. We begin by de.ning some \nbasic operations on histories. Let h = (w, lh) be a history. Then h is stable, notated .(h), if w = S(n) \nfor some n; otherwise h Intuitively, if h1 is not stable, and h2 is reachable (via r* ) from h1 via \nan intermediate history h. which is the stable form of h1, then the sharpening operation yields h., otherwise \nit is a no-op. The sharpening operation is used to update dependence infor\u00admation about peer transactors \nthat have stabilized since their last communication. Operations on dependence maps. Let d1 and d2 be \nde\u00adpendence maps. Then d1 is invalidated by d2, notated d1 > d2 if and only if there exists t such that \nt . dom(d1) n dom(d2) and d1(t) >d2(t). Let d1 and d2 be dependence maps. Then their union, denoted d1 \n. d2, is de.ned as follows: (d1 . d2)(t)= 8 >>>>>< >>>>>: max .* (d1(t),d2(t)) when t . dom(d1) n dom(d2) \nand d1(t) and d2(t) are comparable d1(t) when t . dom(d1),t/. dom(d2) d2(t) when t/. dom(d1),t . dom(d2) \nundef. otherwise We extend the sharpening operation on histories to consistent is volatile. If lh is \nnonempty, i.e., it has checkpointed, then h is v dependence maps d1 and d2 as follows: persistent, notated \n(h); otherwise, h is ephemeral. The empty history (V(0), []) willbe denotedby H0. (d1 d2)(t)= 8< : d1(t) \nd2(t) when t . dom(d1) n dom(d2) d1(t) otherwise Relations on histories. Next, we de.ne some relations \non his\u00adtories that will be used in the transition rules in the operational semantics for the t -calculus. \n9 , .. , and .v are the least relations satisfying the following conditions: (V(n),lh) (V(n + 1),lh) \n( rolls back to ) (S(n),lh) (V(n + 1),lh) ( rolls back to ) (V(n),lh)).. (S(n),lh) ( stabilizes to ) \n(S(n),lh).(V(0),n :: lh) ( checkpoints to ) v 9 , .. , and .v represent all of the valid single-step \ntran\u00adsitions that a history associated with a single transactor can make: Let d beadependence map. Then \nd is independent, notated.(d) if for all t . dom(d), .(d(t));otherwise,d is dependent. Characterizing \ntransactors. Let t = (b, sv ; e, s ; ds[t . h],dc,db) be a transactor bound to name t in some transactor \ncon.guration Then we will say that t is stable if .(h) and volatile otherwise. Transactort is independent \nif .(ds . dc \\ t) (i.e., t depends on no unstable transactors other than itself) and dependent otherwise. \nTransactorvt is ready if e = ready, and busyotherwise; it is per\u00adsistent if (h) and ephemeral otherwise; \nit is initial if s = sv and non-initial otherwise. If t is persistent, independent, ready, and initial, \nwe will say that it is resilient. When not otherwise quali.ed, we will refer to the volatile state of \nt , i.e., s, as simply the state of t . If t is both stable and in\u00addependent, we will say that it is \na daemon. Daemons can be used to model humans or other external agents in a system that send and receive \nmessages, are resilientto (system!)failure,butdo not participate in global state. Operations on con.gurations. \nLet k = \u00b5 | . be a con.g\u00aduration. Then we will use net(k) to denote the network \u00b5, and ns(k) to denote \nthe nameserver .. The domain of k, denoted by dom(k) is the set of all transactors in k s name service \nmap, i.e., dom(ns(k)). Given a con.guration k and a transactor name t . dom(k), we will use k(t) as a \nshorthand for the transactor (ns(k))(t).We will say that a con.guration k is ready or resilient ifffor \nall t . dom(k), k(t) is ready or resilient, respectively.  6.5 Transactor Con.guration Transition Rules \nWewill divide the transition rules of thet-calculus into twoprin\u00adcipal classes: those representing normal \ntransitions, where the only formoffailureallowedis messageloss,and node failuretransitions representing \neither spontaneous nodefailures or rules designed to manage inconsistencies resulting from suchfailures. \nThe set of normal transitions will be represented by the com\u00adposite transition relation -. , which is \nthe relational union of the primitive transition rules in Fig. 8 and 9. The transition rules in Figs. \n8 encode the classical semantics of the Actor model [1]. The transition rules in Fig. 9 augment the classical \nsemantics with additional operations for managing consistency(e.g., creating checkpoints). The set of \nnode failure transitions will be represented by the composite transition relation -. , which is the relational \nunion of the primitive transition rules in all of Figs. 10 and 11. The tran\u00adsition rules in Figure 10 \nmodel spontaneous nodefailures; i.e., failures beyond the control of the transactors themselves. The \ntran\u00adsition rules in Figure 11 de.ne the semantics of program-induced failures via therollback operation, \nand other operations to handle inconsistencies resulting fromfailures. We will use -. to denote an arbitrary \nt-calculus transition, t i.e., -.=-. . -. t In the following sections, we will consider each collection \nof rules in turn. While the number of transition rules may appear somewhat daunting initially, we believe \nthat each of them encodes a semantically orthogonal component of t-calculus semantics in a reasonably \nnatural way. Pure Reduction Rules. Fig.7 depictsa setof standard pure reduction rules for lambda terms \nencoding transactor behaviors. These rules are imported into the classical actor calculus whose transition \nrules are depicted in Fig. 8. Transition Rules for Basic Actor Semantics. Fig.8 de\u00adpicts the collection \nof transition rules that encode the semantics of the Actor model [1]. The semantics is loosely modeled \nafter the semanticsofAghaetal.[3],butwitha signi.cantlydifferent treat\u00adment of state. In the rules of \nFig.8 as well as other rules in the [pur1] ((.x. e) v) -.. e[v/x] [pur2] [pur3] [pur4] fst((v1, )) snd(( \n, v2)) if true then e1 else . -.. -.. -.. v1 v2 e1 [pur5] if false then else e2 . -.. e2 [pur6] letrec \nx = v in e ni -.. e[(v[(letrec x = v in e ni)/x])/x] [pur7] f(v1, . . . , vn) -.. v (f . F, v = [ f] \n(v1, . . . , vn)) Figure 7: Pure reduction rules. t sequel, the relation -. is a single-step transition \nrelation on trans\u00ad l actor con.gurations. Single-step transitions will be annotated with both the name \nof the applicable rule and a distinguished transactor name t to which the relation will be said to apply. \nGiven a trans\u00adactor con.guration k that maps transactor name t to transactor t , it will be convenient \nto refer to t by its name, t. We now consider each rule in turn. [pure] This rule applies one of the \npure reduction rules depicted inFig.7tothebehaviorofa transactor. [new] This rule creates a new transactor \nt. withbehavior b. and initial state s . . The persistent state is initially nil since t. has not yet \ncheckpointed. The statedependence map for t. is initialized to refer to itself: a transactor is always \ndependent on itself (while this information may appear to be redundant, it avoids technical problems \nwhen a transactor sends messages to itself, which among other things is a convenient way to encode continuations \nto be performed following checkpoints). The creation dependence map for t. is the dependence map union \nof the creation dependences and behavioral dependences for the creating transactor and a map\u00adping for \nthe creating transactor(t)itself. This map encodes those transactors on whose states t. s creation is \ntransitively dependent. Note that the behavioral dependence map for t is updated to encode a dependence \non the newly-created transactor. This contravari\u00adant dependence is critical for ensuring that the persistent \nstate of a transactor cannot refer to an ephemeral (i.e., noncheckpointed) transactor. [send] This rule \nencodes the act of sending message m with pay\u00adload vm to transactor t2. The message is tagged with the \ncreation and behavioral dependences of the sender (transactor t1), as well as a dependence on t1 itself. \nThus m carries information about the transactors on which it is transitively dependent. Note that it \nis not necessary to incorporate the state dependences of the sender; those are included in the behavioral \ndependence map if the state is ever read. [rcv1] This rule encodes message receipt. Note that messages \nare selected from the network component of a con.guration nondeter\u00administically. Thus while our model \nassumes guaranteed message delivery, it does not guarantee order of delivery. The preconditions of the \nrule ensure that no received message either invalidates the state or creation of the receiver t, nor \nis invalidated by t. The pre\u00adconditionsalwaysholdinthe absenceoffailures; rules addressing thefailureof \nthese preconditions are addressedbelow.Asa result of message receipt, the behavioral dependences of t \nare updated to contain the dependences of the received message, and t s behavior (alambdaexpression)is \nappliedtothe message. Finally, t scurrent state and creationdependence maps are updatedby the sharpening \noperation ( r ) to re.ect new information about those dependences contained in the arriving message. \nIn particular, we need to deter\u00admine if anypreviously volatile transactors on which t is dependent have \nnow become stable. [get], [set1] These rules model retrieving and setting state, which we model as a \nsingle (possibly composite) cell. Note that in the case of rule [get], the updated behavioral dependence \nmap db . en\u00adcodes a dependence on the state, symmetrically, rule [set1] adds information in the behavioral \ndependence map to update the state dependence map, ds. . Among other things, this semantics ensures that \nif a transactor t does not update its state in the course of pro\u00adcessing a message from another transactor \nt. on which t was not previously dependent, t will not become dependent on t. . [self] This rule encodes \nretrieval of the transactor s own name. Core Transactor Transition Rules. The rules depicted in Fig.9augment \nthe basic actor transitions of Fig.8with additional rules for managing distributed state, as follows: \n[set2] This rule causestheexpression setstate(v) to be ignored when target transactor t is stable; this \nencodes a promise to peer transactors that t will not voluntarily update its state or roll back (however,it \nmay nonetheless be rolled back due to inconsistencies). [sta1], [sta2] These rules encode the stabilization \noperation. Sta\u00adbilization inhibits further state updates and rollback operations (via rules [set2] and \n[rol1]), renders the transactor resilient to spon\u00adtaneous failure (due to the absence of rules for such \nfailures in Fig. 10), and is a prerequisite to checkpointing (rule [chk1]). Rule [sta1] applies if the \ntransactor is currently volatile; it simply up\u00addatesthe transactor s historyto re.ectthefactthatitis \nstable. Rule [sta2] encodes thefact that stabilizationisa no-opif the transactor is already stable. [chk1], \n[chk2] These rules encode the checkpoint operation. The preconditions of rules [chk1] and [chk2] determine \nwhether t has received messages from all of the transactors on which it is de\u00adpendent indicating that \nthose transactors have stabilized or check\u00adpointed the relevant dependent states. If the checkpoint operation \nsucceeds (rule [chk1]), the volatile state of t is stored in t s persis\u00adtent state, t s history is updated \nto re.ect the checkpoint, and the state dependences of t are reset, and the creation and behavioral dependence \nmaps are reset to \u00d8. Thusin additionto storingvolatile state persistently, the dependence map resetting \nperformed by the checkpoint operation has the effect of bounding the amount of de\u00adpendence information \nthat must be tracked across checkpoints. The resetting of the creation dependence map to \u00d8 implies that \nthis map is only non-empty for ephemeral transactors. If the preconditions for checkpointing do not hold, \nrule [chk2] causes it to behave like ready. [rol1] Rule [rol1] encodes thefact that programmatic rollbackis \ndisallowed when t is stable; in this case, rollback behaves as if it were ready. [dep1], [dep2] These \nrules determine whether t is dependent on anynon-stable transactors other than itself. [lose] Finally, \nthis rule models thefact that under normal cir\u00adcumstances messages may be lost after being sent. We assume \nthat such losses are relatively rare; however it may initially seem odd to make message loss an element \nof normal transactor behav\u00adior at all. In part, this is a consequence of our global consistency semantics, \nwhich trades the possibility of global inconsistencyfor the possibility of message loss, hence transforming \nthe program\u00admer s burden from reasoning about global failures (about which theycan have no knowledge \nin general), to reasoning about a local failureintheformoflost messages.However,asapractical matter, \neven programs running in systems with guarantees about message delivery must effectively reason about \nthe possibility of message loss, since they typically must incorporate time-outs to deal with protracted \nmessage latencies (which then become indistinguishable from losses). FailureTransitions. The rules depictedinFig.10model \nspon\u00adtaneous nodefailure causedbyfaults. In realistic systems, these rules willbe appliedfar less frequently \nthan thenon-failure rules. [.1] This rule models the transient nodefailureofa persistent, volatile transactor. \nIn such cases, the state of the transactor reverts to the stored persistent state, and the state dependence \ninformation is reinitialized. This rule assumes that a persistent transactor is capable of checkpointing \nintermediate states to stable storage, then restoring such checkpoints afterafailure (e.g., followinga \nreboot or software recovery). [.2] This rule models the permanent node failure of an ephemeral transactor: \nit is annihilated. This rule models systems that cannot checkpoint intermediate states to stable storage; \nthese systems are assumedtofailby stopping permanently. Note thatifa transactoris stable, nofailure rule \napplies. This meansin practicethatthe program counter for intermediateeval\u00aduation states of a stable \ntransactor s behavior must be logged to persistent storage. While this may seem like a rather onerous \nre\u00adquirement,weexpectthatthe numberof intermediate statesin com\u00adputations performed by a stable transactor \nwill be minimal. Also, manyoptimizations are possible to minimize the overhead of this requirement in \npractice, e.g., deferring all side effects (message sends or transactor creations) to cause them to be \nexecuted during a (local)ACID transactionof short duration. Transactor Rules for Managing Inconsistency. \nThe .\u00adnal collection of rules, depicted in Fig. 11, encode programmatic rollback and manage the inconsistencies \nthat result from explicit rollback or inconsistencies due to incoming messages. The incon\u00adsistencymanagement \nrules are as follows: [rol2], [rol3] These rules (along with [rol1])above encode the rollback operation. \nRule [rol1] encodes the fact that program\u00admatic rollback is disallowed when t is stable; in this case, \nroll\u00adback behaves as if it were ready. Rule [rol2] encodes thefact that if an ephemeral (non-checkpointed) \ntransactor rolls back, it disap\u00adpears, i.e., is annihilated (among other things, this behavior allows \ncertain transactors to dispose ofthemselves when their work is done). Otherwise, rule [rol3] encodes \nthefact that rollback resets the(volatile) statetothelast stored persistent state;in addition,the state, \ncreation, and behavioral dependences are reinitialized. [rcv2] This rule applies when the dependences \nassociated with an incoming message are invalidated by the state or creation de\u00adpendences associated \nwith t. This occurs if the message depends on an earlier incarnation of some dependent transactor than \nt does. In this case, the message is ignored to ensure global consistency. [rcv3] This rule applies when \nthe dependences associated with an incoming message m supersede the state dependences (but not the creationdependences) \nassociated with t, and t is persistent. In such cases, t is effectively rolled back to ensure global \nconsistency, and the result is the same as in rule [rol3]. [rcv4] This rule applies when an ephemeral \ntransactor s state or creation dependences are invalidated by an incoming message. In this case, t cannot \nroll back since there is no checkpoint to roll back to; instead, it is annihilated to ensure global consistency. \n 7. FORMAL PROPERTIES In this section, we de.ne what it means for a system such as the t -calculus to \nbe well-behaved. In particular, we prove certain soundness and liveness properties appropriate for the \nt-calculus. For soundness, we show that a trace (i.e., a transition sequence) containingnodefailuresand \ninconsistenciesisequivalenttoanor\u00admal trace, i.e., one containing no nodefailures,but possibly mes\u00adsage \nlosses.Wealsoshowthat checkpointingis possible, assuming [pure] Evaluate pure redex. ' e .Erdx e -.. \ne P t ' \u00b5 | .[t .(b, sv ; R[ e ],s ; ds,dc,db)] -. \u00b5 | .[t .(b, sv ; R[ e ],s ; ds,dc,db)] [pure] [new] \nCreate new transactor. ' \u00b5 | .[t .(b, sv ; R[ trans b ' init s snart ],s ; ds[t . h],dc,db)] ' t ./dom(.) \n.{t} t ' '' -. \u00b5 | .[t .(b, sv ; R[ t ],s ; ds[t . h],dc,db . d ' )][t .(b ' , nil ; ready,s ; d ' ,dc \n. db . [t . h], \u00d8)] d ' =[t ' . H0] [new] [send] Send message, piggybacking dependence information. t \n '' \u00b5 | .[t .(b, sv ; R[ send vm to t ],s ; ds[t . h],dc,db)] -. (\u00b5 {t .(vm,dc . db . [t . h])}) | .[t \n.(b, sv ; R[ nil ],s ; ds[t . h],dc,db)] [send] [rcv1] Message dependencesnotinvalidatedbytransactor;transactor \ndependencesnotinvalidatedby message:process message normally. \u00ac(dsc dm) \u00ac(dm dsc) dsc = ds . dc t (\u00b5 \n{t .(vm,dm)}) | .[t .(b, sv ; R[ ready ],s ; ds,dc, )] -. \u00b5 | .[t .(b, sv ;(bvm),s ; ds dm,dc dm,dm)] \n[rcv1] [get] Retrieve state. t \u00b5 | .[t .(b, sv ; R[ getstate ],s ; ds,dc,db)] -. \u00b5 | .[t .(b, sv ; R[ \ns ],s ; ds,dc,db . ds)] [get] [set1] Transactor is volatile: setting state succeeds. \u00ac.(h) \u00b5 | .[t .(b, \nsv ; R[ setstate(s)], ; ds [self] Yields reference to own name. \u00b5 | .[t .(b, sv ; R[ self ],s ; ds,dc,db)] \nt [t . h],dc,db)] -. \u00b5 | .[t .(b, sv ; R[ true ],s ; ds[t . h] . db,dc,db)] [set1] t -. \u00b5 | .[t .(b, \nsv ; R[ t ],s ; ds,dc,db)] [self] Figure8:Transition rules encoding basic actor semantics. certain reasonablepreconditions. \nFirst, we need some preliminary de.nitions. 7.1 Preliminary De.nitions Traces. If S = {R1,R2,...,Rm} \nis a set of binary relations and R = R1 . R2 . ... . Rm, we will refer to R. as a composite relation \nbased on the basis set S of primitive relations. In general, primitive relations will represent single \nstep transition relations for an operational semantics. If S isabasis setof primitiverelations such that \nfor all R1,R2 . S, R1 n R2 = \u00d8, we will say that S is an orthogonal basis set. Let S = {R1,R2,...,Rn} \nbea set of primitive relations, and R. be the composite relation based on S. Then we will refer to a \n(possibly empty) sequence of primitive relations from the set S as an R.-trace. Given an initial value \nx0 and an R.-trace . = Ri1 Ri2 ... Rim over an orthogonal basis set, there exists a unique sequence x0 \nx1 ... xm such that x0 (Ri1 \u00b7 Ri2 \u00b7\u00b7\u00b7 Rim ) xm In this case, we will use the trace . to refer either \nto the se\u00adquence of relations Ri1 Ri2 ...Rim or the sequence of values x0 x1 ... xm-1, and will also \nfeel free to treat . as the set of val\u00adues {x0,x1,...,xm-1} when convenient. Note that we adopt the convention \nthat the value sequence represented includes the initial elementof the transition sequence,but not the \n.nal element. We . will frequently use the notation x0 -.* xm when . is an S-trace, and -. is the composite \nrelation based on S. We will use E to denote an empty trace, and len(.) to denote the lengthofa trace \n.. Con.guration well-formedness. In this section, we de.ne what it means for a transactor con.guration \nto be sensible with respect to its history annotations. Let t = (b, sv ; e, s; ds,dc,db) be a transactor, \nand let t. be an arbitrary transactor name. Then the set of histories of t. associated with t is denoted \nby histories(t.,t), de.ned by ' histories(t ,t) ''' {h ' | ds(t )= h ' or dc(t )= h ' or db(t )= h ' \n} Note that this set is not necessarily a singleton; e.g., t s creation canbe dependenton one checkpointedversionof \nt., and its current state on a different version. Let \u00b5 be a network, and t be an arbitrary transactor \nname. Then the set of histories of t associated with \u00b5 is denoted by histories(t, \u00b5), de.nedby histories(t, \n\u00b5) {h | ( .( ,dm[t . h])) . \u00b5} Let k be a well-formed transactor con.guration, and t be a trans\u00adactor \nsuch that t . dom(k). Then the principal history of t in k is denotedby history(t, k), and is de.ned \nby history(t, k) ds(t) such that k(t)=((b, sv ; e, s ; ds,dc,db)) Let k be a con.guration. Then the \nset of t-dependent node his\u00adtories in k is denotedby depHists(t, k), andis de.nedby [ ' depHists(t, k)= \nhistories(t ,k(t)) t '.(dom(k)\\t) Thus depHists(t, k) yields the set of all histories of t present in \nnodes of k with the exception of its principal history. Given con.guration k, a transactor t in dom(k) \nis garbage if t ./depHists(t.,k) for anyother transactor t. . Wewillsay thatacon.gurationk is well-formed \niffthe following conditions hold: 1. For all t . dom(k) such that k(t) = ((b, sv ; e, s ; ds, dc, db)),v \n(history(t, k)), then dc = \u00d8. t . dom(ds), and if 2. For all h . depHists(t, k), h r* history(t, k) \n[set2] Transactor is stable: attempt to set state fails. .(h) t \u00b5 | .[t .(b, sv ; R[ setstate( )],s \n; ds[t . h],dc,db)] -. \u00b5 | .[t .(b, sv ; R[ false ],s ; ds[t . h],dc,db)] [set2] [sta1] Transactor is \nvolatile: stabilization causes it to become stable. h .. h ' t \u00b5 | .[t .(b, sv ; R[ stabilize ],s ; ds[t \n. h],dc,db)] -. \u00b5 | .[t .(b, sv ; R[ nil ],s ; ds[t . h ' ],dc,db)] [sta1] [sta2] Transactor currently \nstable:stabilize is a no-op. .(h) t \u00b5 | .[t .(b, sv ; R[ stabilize ],s ; ds[t . h],dc,db)] -. \u00b5 | .[t \n.(b, sv ; R[ nil ],s ; ds[t . h],dc,db)] [sta2] [chk1] Transactor is stable and independent: checkpoint \nsucceeds. .(ds[t . h] . dc) h .v h ' t \u00b5 | .[t .(b, ; R[ checkpoint ],s ; ds[t . h],dc, )] -. \u00b5 | .[t \n.(b, s ; ready,s ;[t . h ' ], \u00d8, \u00d8)] [chk1] [chk2] Transactor is dependent or volatile:checkpoint simply \nbehaves like ready. \u00ac.(ds . dc) t \u00b5 | .[t .(b, sv ; R[ checkpoint ],s ; ds,dc, )] -. \u00b5 | .[t .(b, sv \n; ready,s ; ds,dc, \u00d8)] [chk2] [rol1] Transactor is stable:rollback simply behaves like ready. .(h) \nt \u00b5 | .[t .(b, sv ; R[ rollback ],s ; ds[t . h],dc, )] -. \u00b5 | .[t .(b, sv ; ready,s ; ds[t . h],dc, \u00d8)] \n[rol1] [dep1] Transactor is independent: yields false. .((ds . dc) \\ t) t \u00b5 | .[t .(b, sv ; R[ dependent?],s \n; ds,dc,db)] -. \u00b5 | .[t .(b, sv ; R[ false ],s ; ds,dc,db)] [dep1] [dep2] Transactor is dependent: yields \ntrue. \u00ac.((ds . dc) \\ t) t \u00b5 | .[t .(b, sv ; R[ dependent?],s ; ds,dc,db)] -. \u00b5 | .[t .(b, sv ; R[ true \n],s ; ds,dc,db)] [dep2] [lose] Message loss. m (\u00b5 {m}) | . -. \u00b5 | . [lose] Figure9:Transition rules \nencoding basic transactor semantics. [.1] Spontaneous failure of volatile, persistent transactor causes \nrollback. v (h) \u00ac.(h) hh ' t \u00b5 | .[t .(b, sv ; , ; ds[t . h],dc,db)] -. \u00b5 | .[t .(b, sv ; ready,sv \n; ds[t . h ' ],dc,db)] [fl1] [.2] Spontaneous failure of volatile, ephemeral transactor causes it to \nbe annihilated. \u00acv (h) \u00ac.(h) t \u00b5 | .[t .( , nil ; , ; ds[t . h],, )] -. \u00b5 | . [fl2] Figure 10:Transition \nrules modeling spontaneous failures. In other words, for a con.guration to be well-formed, every trans- \nrations will correspond to transactors whose states are inconsistent actor t musthaveitsown historyinits \nstate dependencemapandits dueto nodefailures. Let t = (b, sv ; e, s ; ds,dc,db) be a transac\u00ad creation \ndependence map must be empty if t has checkpointed. In tor. Then the composite dependence map for t , \nnotated maps(t ) addition, a transactor s principal history must be the most recent is de.ned by maps(t \n) . ds . dc . db. Let k be a con.gura\u00ad of all the histories of t associated with other transactors in \nk. tion, and t . dom(k) be a transactor name. Then the compos\u00adite dependence map for t in k, notated \nmaps(t, k), is de.ned by LEMMA 1 (WELL-FORMEDNESS PRESERVATION). Let k be maps(t, k)= maps(k(t)). awell-formed \ncon.guration, and let k. beacon.guration suchthat . Given a con.guration k, we will say that a transactor \nt . k -. * k.. Then k. is also well-formed. . t dom(k) is consistent (with respect to k) if there exists \nno tin dom(k) such that maps(t, k)(t.) > history(t.,k). In other PROOF. Straightforward induction on \nlen(.). words, k is dependent on no other transactor t. for which the state of t. is currently inconsistent \nwith t. Similarly, a message (t .( ,dm)) . ns(k) is consistent (with respect to k)if there Con.guration \nconsistency. In this section, we de.ne notions exists no t. in dom(k) such that dm(t.) >history(t.,k). \nof consistency for transactor con.gurations. Inconsistent con.gu\u00ad [rol2] Transactor is volatile and \nephemeral: rollbackcauses transactor to be annihilated. \u00ac.(h) \u00acv (h) t \u00b5 | .[t .( , nil ; R[ rollback \n], ; ds[t . h],, )] -. \u00b5 | . [rol2] [rol3] Transactor is volatile and persistent: rollbackreverts state \nto contents of persistent state saved by last checkpoint. \u00ac.(h) v (h) hh ' t \u00b5 | .[t .(b, sv ; R[ rollback \n], ; ds[t . h],, )] -. \u00b5 | .[t .(b, sv ; ready,sv ;[t . h ' ], \u00d8, \u00d8)] [rol3] [rcv2] Message dependencesinvalidatedby \nthoseoftransactorbut not vice-versa: discardmessage. dm dsc \u00ac(dsc dm) dsc = ds . dc t (\u00b5 {t .( ,dm)}) \n| .[t .(b, sv ; R[ ready ],s ; ds,dc, )] -. \u00b5 | .[t .(b, sv ; ready,s ; ds,dc, \u00d8)] [rcv2] [rcv3] State \ndependences(butnotcreation dependences)invalidatedby messageandtransactorispersistent:transactorrollsback. \nv h ' ds[t . h] dm \u00ac(dc dm)(h) h t \u00b5 {t .(vm,dm)} | .[t .(b, sv ; R[ ready ], ; ds[t . h],dc, )] -. \n\u00b5 | .[t .(b, sv ; ready,sv ;[t . h ' ], \u00d8, \u00d8)] [rcv3] [rcv4] Stateorcreation dependencesinvalidatedby \nmessageandtransactoris ephemeral:transactoris annihilated. v dsc dm \u00ac (h) dsc = ds[t . h] . dc t (\u00b5 \n{t .( ,dm)}) | .[t .( , nil ; R[ ready ], ; ds[t . h],dc, )] -. \u00b5 | . [rcv4] Figure 11:Transition rulesforprogrammaticrollback \nand consistency management. Wewill say that nameserver. is consistent if for all t . dom(.), t is consistent. \nA well-formed network \u00b5 is consistent if for all m . \u00b5, m is consistent.Acon.guration k is network consistent \nif net(k) is consistent with respect to k and node consistent if ns(k) is consistent with respect to \nk. Finally, a con.guration k is consis\u00adtent if it is both network consistent and node consistent. Con.guration \nequivalence modulo history. In this sec\u00adtion, we de.ne a simple notion of transactor equivalence that \nis oblivious to certain inconsequential differences in dependence in\u00adformation. Given two histories h \nand h , such that h is a prede\u00adcessor history to h, the reversion operation reverth (h) de.nes a new \nhistory h. that is the same as h, except that the operations representedby h do not occur: Let t be \na transactor, k be t-consistent con.guration, and h = history(t, k). Then k k. if k. = revert (t, k). \nThe relation t,h h , read equivalence modulo history is then de.ned as the least equivalence relation \nsatisfying k t,h k ' for some t, h =. k k ' The relation  is a very weak form of con.guration equiva\u00adlence \nakin to a-equivalence in the lambda calculus or structural congruences in process calculi. The idea is \nthat two con.gurations that are identical up to certain inconsequential differences in de\u00adpendence information \nbehave identically. Thisfact is embodied in the following lemma: revert (h) h = 8 >>< >>: LEMMA 2 (BEHAVIOROF \n-EQUIVALENTCONFIGURATIONS). h ' if there exists . h 0 such that Let k1 and k2 be con.gurations such \nthat k1 k2, and . be h 0 h * h and . . a trace such that k1 -. * k1. . Then there exists k2 . such that \nh ' 0 * h ' t . h otherwise k2 -. * k2 . and k2 k2. . t The de.nition above will be critical to de.ning \na node-failure free trace from a corresponding trace with node failures: if h repre\u00adsentsa setoffailing \noperationsina transactor, we will extract those operations from a trace and update other histories h \nusing reverth (h). Let t be a transactor name, h be a history, and k be a transactor con.guration. Then \nreverth(t, k) is de.ned as follows: reverth(t, \u00b5 | .) \u00b5 ' | . ' where '' \u00b5 = {{ (t .(vm,dm[t . reverth])) \n' | (t .(vm,dm)) . \u00b5 }} and ' . ' = {[ t .( b, sv ; e, s ; ds[t . reverth], dc[t . reverth], db[t . reverth] \n) ] ' | t . dom(.) and ' ((b, sv ; e, s ; ds,dc,db))= .(t ) } (Recall that ds[t . reverth] is shorthand \nfor the map ds[t . reverth(ds(t))];similarly for the other maps). If . isatrace, we will use reverth(t, \n.) to denote the trace .. re\u00adsulting from replacingevery con.guration k . . by reverth(t, k). PROOF. \nStraightforward induction on len(.) and thede.nition of . Cycle Properties. Let . be a -. * trace. Then \na nonempty t trace . isa t-sequence if all primitive transitions in . have the form t -. , i.e., all \ntransitions are applicable to a transactor named t.A l cycle-terminating transition is anyprimitive \ntransition rule in -. * t that either takes the form t \u00b5 | .[t .(b, sv ; e, s ; ds,dc,db)] -. l \u00b5 . \n| .[t .(b, sv ; ready,s ; ds,dc,db)] or t \u00b5 | .[t . t] -. \u00b5 . | . l In other words, a cycle-terminating \ntransition either causes a trans\u00adactor s evaluation state to become ready, or results in the annihi\u00adlationof \nsome transactor.A t-trace c is a t-cycle if c = c . r where c . is a -. trace, and r is a cycle-terminating \ntransition. t LEMMA 3 (CYCLE DECOMPOSITION). Let k1 and k2 be . well-formed and ready con.gurations suchthat \nk1 -. * k2. Then t there exists a trace .. of the form t1 tn . = .0 c1 .1 ... cn .n wherefor all 1 = \ni = n,citi isa ti-cycle,and forall 0 = j = n, .j isa(possibly empty) message loss trace of the form -. \n*, suchthat [lose] . ' k1 -. * k2. We will refer to the trace . as a cycle decomposition t of .. PROOF. \nBy induction on len(.). De.ne a total ordering on all transactor names present in .. Permute pairs of \nprimitive non-loss transitions in . not consistent with the total ordering, and permute loss/non-loss \npairs. The resulting trace has the desired form.  7.2 SimulationWithout NodeFailures Given the preceding \nde.nitions, we are now in a position to prove that arbitrary t -calculus traces can be simulated by traces \ncontaining only the nodefailure free subset of the t-calculus. We .rst require the followingkeylemma: \nLEMMA 4 (SIMULATION). Let k1 a , k2 a , k1 \u00df, and k2 \u00df be well\u00adformed con.gurations, a and \u00df be traces \nsuchthat a\u00df k1 a -. * k2 a and k1 \u00df -. * k2 \u00df t T. and T! be sets of transactor names, and M! be a network \n(i.e., a multiset of messages). Assume k1 a , k2 a , k1 \u00df , k2 \u00df , a, \u00df, T., T!, and M! all satisfy the \nfollowing conditions: 1. k1 a , k1 \u00df , and k2 \u00df are resilient and network consistent. 2. For all k . \n\u00df, k is node consistent. 3. T. . dom(k1 \u00df ), and for all t . T., history(t, k2 a) 9 history(t, k1 \u00df \n) and k1 \u00df(t) is initial. 4. For all t . dom(k1 \u00df ) \\ T., k2 a(t)= k1 \u00df(t). 5. T! . dom(k\u00df)= dom(k2 \na), and for all t . T! such that h = history1 (t, k2 a), \u00ac.(h) and \u00acv (h). 6. M! l net(k1 \u00df )= net(k2 \na), and for all m . M!, m is incon\u00adsistent with respect to k2 a .  \u00df ' \u00df ' Then there exists con.guration \nk2 and trace a. suchthat k2 k2 \u00df and -. k1 a. * k2 \u00df ' t PROOF. By induction on the length of a cycle \ndecomposition of a. Full details may be found in a companion technical report [10]. We are now in a position \nto prove our main simulation theorem: THEOREM 1 (SIMULATION WITHOUT NODE FAILURES). Let k1 and k2 be \nwell-formed, resilient, and consistent con.gura\u00adtions suchthat k1 -. * k2. Then there exists k2 . suchthat \nk2 k2 . t and k1 -. * k2. . PROOF. Follows directly from Lemma 4. De.ne the variables in the premise \nof the lemma as follows: Let k1 a = k1, k2 a = k1 \u00df = a k2 \u00df = k2. Let a be the unique trace such that \nk1 -. * k2, \u00df = E, t and T. = T! = \u00d8. Given these de.nitions, all of the premises of Lemma4are satisfed \ntrivially, and thus the theorem follows imme\u00addiately from the lemma. The proof of this theorem effectively \nshows how global reasoning about state inconsistencies can be reduced to local reasoning about the possibility \nof message loss. 7.3 Universal Checkpointing The other critical t-calculus property is liveness, i.e., \nthat it is possible to reach global checkpoints using the transactor model op\u00aderational semantics. Of \ncourse, not all transactor programs can reach global checkpoints. Indeed, a trivial program with a trans\u00adactor \nthat sends messages introducing dependencies,but never sta\u00adbilizes or tries to checkpoint, will eliminate \nthe ability of its de\u00adpendentsto reach checkpoints.We thereforeintroducea Universal Checkpointing Protocol \n(UCP) that assumes a set of preconditions that will entail globalcheckpointing for a set of transactors \nT . We also prove that under those preconditions, the protocol terminates and therefore, a global checkpoint \nis reached. DEFINITION 1 (UCPPRECONDITIONS). Let D be the set of transactors T andthetransitive closureofits \ndependencies,i.e.,all the transactors that elements of T depend on, the transactors that theydepend on, \nand so forth. A. All transactors in D need to keep a set of acquaintances, ACQ, in their state since \nthe last checkpoint or time of cre\u00adation, including the names of: (1) transactorswhichhave beenatarget \nfor messages sent. (2) transactors whichhave been created. (3) the parent transactor.  B. All transactors \nin D need to eventually stabilize and start the Universal Checkpointing Protocol. Also, all transactors \nin D need to be able to receive ping messages. C. Once the .rst transactor in D stabilizes, no other \ntransac\u00adtors in D will programmatically rollback or be caused to rollback by other transactors in D. \nThis assumes previ\u00adous application-dependent communication that provides this guarantee. D. There can \nbe no failures while the Universal Checkpointing Protocol is taking place. DEFINITION 2 (UNIVERSAL CHECKPOINTING \nPROTOCOL). When a transactor t in D stabilizes, it: I. Pings every transactor in ACQ II. Checks if it \nis dependent, (a) If not, it pings every transactor in ACQ, checkpoints and ends protocol. (b) If so, \nit pings every transactor in ACQ and waits for incoming pings.  III. On reception of a ping message, \ngoes backto II. THEOREM 2 (UNIVERSAL CHECKPOINTING PROPERTY). The Universal Checkpointing Protocol (UCP) \nterminates under UCP preconditions A..D. PROOF. Omitted due to space limitations; details may be found \nin a companion technical report [10].  8. DISCUSSION AND FUTUREWORK In this paper, we have introduced \na formal framework for under\u00adstanding and managing distributed state in the presence of various classes \noffailures. Internet-scale distributed computing is becom\u00ading ever more important as use of Grid mechanisms \nand web ser\u00advices increases.Webelievethatinordertodeveloprobust applica\u00adtions in these settings, it is \nnecessary to incorporate state manage\u00adment constructs that are more .exible than traditional transaction \nmechanisms. In addition to the failure-free simulation and universal check\u00adpointing properties, there \nare a number of additional aspects of the t -calculus that areworthyof further study.Forexample, onewould \nlike to show how certain application properties and topologies al\u00adlow specialized checkpointing techniques. \nAs a trivial example, consider a transactor t application that reads,but does not update the state of \nanother transactor t.. If t. is initially checkpointed, one can easily show that t. can checkpoint without \nrequiring message exchanges witht. More interestingly, one could de.nevariousfail\u00adure rates and scenarios, \nand show situations under which con.gu\u00adrationsarealwaysabletomake progress(under reasonablefairness assumptions) \ndespitefailures. Finally, there are a number of interesting directions for further research thatbuild \non the ideasdeveloped here, including: model\u00ading transactional compensation mechanisms, in which consistency \nis maintained through reversal of actions, rather than rolling back to previous states; modeling isolation \nand atomicity in a modular way; studying type systems for statically constraining dependences andexposingvariousfailure \nmodes;developing techniques for op\u00adtimizing dependence information, and modeling additional classes offailures. \n9. ACKNOWLEDGMENTS We gratefully acknowledge the insightful comments of James Leifer, CarolynTalcott, \nMaria-Cristina Marinescu, and the anony\u00admous referees. 10. REFERENCES [1] G. Agha. Actors:AModelof Concurrent \nComputationin Distributed Systems. MIT Press, 1986. [2] G. Agha,N. Jamali, andC.Varela. Agent naming \nand coordination: Actor based models and infrastructures. In A. Omicini,F. Zambonelli,M. Klusch, andR.Tolksdorf, \neditors, Coordination of Internet Agents: Models, Technologies, and Applications, chapter 9, pages 225 \n246. Springer-Verlag, Mar. 2001. [3] G. Agha,I.A. Mason,S.F.Smith, andC.L.Talcott.A foundation for actor \ncomputation. Journal of Functional Programming, 7:1 72, 1997. [4] M. Berger and K. Honda. The two-phase \ncommitment protocol in an extended pi-calculus. In Prelim. Proc. EXPRESS 00, NS-00-2, pages 105 130. \nBRICS Notes, 2000. [5]P.A. Bernstein. Middleware:Amodel for distributed system services. Communicationsof \ntheACM, 39(2):86 98, 1996. [6] K.P. Birman andR.V. Renesse. Reliable Distributed Computing with the ISISToolkit.Wiley-IEEE \nComputer Society Press, 1994. [7] L. Cardelli and A. Gordon. Mobile ambients. In Foundations of System \nSpeci.cation and Computational Structures, LNCS 1378, pages 140 155.SpringerVerlag, 1998. [8]T. Chothia \nandD. Duggan.Abstractions forfault-tolerant global computing. Electronic Notes in Theoretical Computer \nScience (ENTCS).FoundationsofWide-Area Network Computing (FWAN), 66(3), 2002. Elsevier. [9] J. Field \nandC.Varela.Towardsa programming model for building reliable systems with distributed state.Electronic \nNotesin Theoretical Computer Science (ENTCS).First InternationalWorkshop onFoundationsof Coordination \nLanguages and Software Architectures (FOCLASA), 68(3), 2003. Elsevier. [10] J. Field andC.Varela.Transactors:Aprogramming \nmodel for maintaining globally consistent distributed state in unreliable environments.Technical Report04-15, \nDepartment of Computer Science. Rensselaer Polytechnic Institute,Troy,NY,November 2004. [11] C.Fournet \nandG. Gonthier. The re.exive CHAM and the join-calculus. In Proc.ACM Symp. on Principlesof Programming \nLanguages, pages 372 385, 1996. [12] S. Fr\u00f8lund. Coordinating Distributed Objects: An Actor-Based Approachto \nSynchronization. MIT Press, 1996. [13] J. Gray and A. Reuter. Transaction Processing: Concepts andTechniques. \nMorgan Kaufman, 1993. [14] N. Haines, D. Kindred, J. G. Morrisett, S. M. Nettles, and J.M.Wing. Composing \n.rst-class transactions. ACMTrans. Program. Lang. Syst., 16(6):1719 1736, 1994. [15] C.Hewitt.Viewing \ncontrol structures as patternsof passing messages. Journal of Arti.cial Intelligence, 8-3:323 364, June \n1977. [16] W. Kim and G. Agha. Ef.cient Support of Location Transparencyin Concurrent Object-Oriented \nProgramming Languages. In Proceedings of Supercomputing 95, 1995. [17] B. Liskov. Distributed programmingin \nArgus. Communications of the Association of Computing Machinery, 31(3):300 312, 1988. [18] R. Milner,J.Parrow, \nandD.Walker.Acalculusof mobile processes, parts I-II. Information and Computation, 100(1):1 77, 1992. \n[19] A. Spector,R.Pausch, andG.Bruell. Camelot:A.exible, distributed transaction processing system. In \nProc. IEEE Computer Society International Conf., pages 432 437, San Francisco, March 1988. IEEE Computer \nSociety Press. [20] C.L.Talcott. Composable semantic models for actor theories. Higher-Order and Symbolic \nComputation, 11(3), 1998. [21] R.van Renesse,K.P. Birman, andS. Maffeis. Horus:A .exible group communication \nsystem. Communications of theACM, 39(4):76 83, 1996. [22]WorldWideWeb Consortium.Web services activity \nstatement. http://www.w3.org/2002/ws/, 2002. [23] X/Open CompanyLimited. Distributed transaction processing: \nThe XA speci.cation. X/Open Company Limited, 1991. X/Open CAE Speci.cation XO/CAE/91/300.   \n\t\t\t", "proc_id": "1040305", "abstract": "We introduce <i>transactors</i>, a fault-tolerant programming model for composing loosely-coupled distributed components running in an unreliable environment such as the internet into systems that reliably maintain globally consistent distributed state. The transactor model incorporates certain elements of traditional transaction processing, but allows these elements to be composed in different ways without the need for central coordination, thus facilitating the study of distributed fault-tolerance from a semantic point of view. We formalize our approach via the &#964;-calculus, an extended lambda-calculus based on the <i>actor</i> model, and illustrate its usage through a number of examples. The &#964;-calculus incorporates constructs which distributed processes can use to create globally-consistent <i>checkpoints</i>. We provide an operational semantics for the &#964;-calculus, and formalize the following safety and liveness properties: first, we show that globally-consistent checkpoints have equivalent execution traces without any node failures or application-level failures, and second, we show that it is possible to reach globally-consistent checkpoints provided that there is some bounded failure-free interval during which checkpointing can occur.", "authors": [{"name": "John Field", "author_profile_id": "81100419562", "affiliation": "IBM T.J. Watson Research Center", "person_id": "PP43119729", "email_address": "", "orcid_id": ""}, {"name": "Carlos A. Varela", "author_profile_id": "81100405099", "affiliation": "Rensselaer Polytechnic Institute", "person_id": "P41331", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1040305.1040322", "year": "2005", "article_id": "1040322", "conference": "POPL", "title": "Transactors: a programming model for maintaining globally consistent distributed state in unreliable environments", "url": "http://dl.acm.org/citation.cfm?id=1040322"}