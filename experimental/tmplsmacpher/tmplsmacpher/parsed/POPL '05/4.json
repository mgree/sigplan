{"article_publication_date": "01-12-2005", "fulltext": "\n Parametric Polymorphism for XML Haruo Hosoya Alain Frisch Giuseppe Castagna The University of Tokyo \nINRIA \u00b4 Ecole Normale Sup\u00b4erieuredeParis hahosoya@is.s.u-tokyo.ac.jp Alain.Frisch@inria.fr Giuseppe.Castagna@ens.fr \n ABSTRACT Despite the extensiveness of recent investigations on static typingfor XML, parametric polymorphism \nhas rarely been treated. This well-established typingdiscipline can also be useful in XML processingin \nparticular for programs involv\u00ading parametric schemas, i.e., schemas parameterized over other schemas \n(e.g., SOAP). The di.culty in treating poly\u00admorphism for XML lies in how to extend the semantic ap\u00adproach \nused in the mainstream (monomorphic) XML type systems. A naive extension would be semantic quanti.\u00adcation \nover all substitutions for type variables. However, this approach reduces to an NEXPTIME-complete prob\u00adlem \nfor which no practical algorithm is known. In this paper, we propose a di.erent method that smoothly \nex\u00adtends the semantic approach yet is algorithmically easier. In this, we devise a novel and simple marking \ntechnique, where we interpret a polymorphic type as a set of values with annotations of which subparts \nare parameterized. We exploit this interpretation in every ingredient of our poly\u00admorphic type system \nsuch as subtyping, inference of type arguments, and so on. As a result, we achieve a sensible system \nthat directly represents a usual expected behavior of polymorphic type systems values of variable types \nare never reconstructed in a reminiscence of Reynold s para\u00admetricity theory. Also, we obtain a set of \npractical algo\u00adrithms for typecheckingby local modi.cations to existing ones for a monomorphic system. \nCategories and Subject Descriptors: D.3.3 [Program\u00adming Languages]: Language Constructs and Features \n Polymorphism; Data types and structure; F.3.3 [Logics and Meanings of Programs]: Studies of Program \nConstructs Type structure General Terms: Algorithms, Design, Language, Theory Keywords: XML, polymorphism, \nsubtyping, tree automata 1. INTRODUCTION Recently, static typingfor XML processinghas actively Permission \nto make digital or hard copies of all or part of this work for personal or classroom use is granted without \nfee provided that copies are not made or distributed for pro.t or commercial advantage and that copies \nbear this notice and the full citation on the .rst page. To copy otherwise, to republish, to post on \nservers or to redistribute to lists, requires prior speci.c permission and/or a fee. POPL 05, January \n12 14, 2005, Long Beach, California, USA. Copyright 2005 ACM 1-58113-830-X/05/0001 ...$5.00. been investigated \nin the contexts both of concrete language designs [18; 11; 3; 21, etc] and of theoretical frameworks \n[23; 22, etc]. All these works lack an important typing facility, namely the parametric polymorphism. \nThis typ\u00ading discipline for parameterizing program fragments over types has been exploited in many programming \nlanguages, such as ML [20, 2], Haskell [24], C++ [9], and GJ [4], and already established as an important \ningredient for code reusability. Not surprisingly, this usefulness can be extended to XML processing, \nnot only because one may use, in XML, operations such as map and fold that are standard in func\u00adtional \nlanguages, but also because some types for XML data (usually called schemas) are not stand-alone but \nde.ned in terms of other schemas given as parameters; it is nat\u00adural to want to write programs involving \nsuch parametric schemas and typecheck them. A typical example is SOAP [10], which provides a generic \ntype for envelopes for en\u00adclosing content data whose type is parameterized.1 Con\u00adcretely, suppose that \nwe want to write a generic function for wrappinga given data d in a SOAP envelope as follows: <envelope> \n<header> example envelope </header> <body> d </body> </envelope> We do not know the type of d at the \nmoment of writingthis function. In other words, the function must work for any type. Therefore an appropriate \ntype for this function must be polymorphic: .X. X . SoapEnv(X) Here, SoapEnv(X) is the parameterized \ntype for SOAP en\u00advelopes and may be de.ned by SoapEnv(X) = envelope[header[String], body[X]] in the \nnotation of regular expression types [19]. (The form tag[...] corresponds to the XML structure <tag>...</tag> \nand the comma is a concatenation operation. See Section 2.1 for more details on types.) The need of polymorphism \nfor XML is quite clear, and also certi.ed by the fact that this feature has repeatedly been requested \nto and discussed in various workinggroups of standards (e.g., RELAX NG [7] and XQuery [11]). De\u00adspite \nthat, it has almost never been studied formally. This 1The speci.cation of SOAP itself does not de.ne \ntypes at all (probably because parametric types are not supported by any schema language), but the above \nrequirement is de\u00adscribed informally in a natural language. is probably because the semantic approach \nthe one used by most of current research on type systems for XML is not trivial to extend with polymorphism. \nTo see the di.culty, let us look more closely at the de.nition of subtyping, which is a crucial part \nin XML typechecking. In the monomorphic case, we.rst givethe semantics [ T]] of each type T as a set \nof documents conformingto the type, and then de.ne the sub\u00adtype relation by the subset relation between \nthe semantics of two given types: T . U .. [[T]] . [[U]] Although the subtype relation, which is equivalent \nto the tree automata containment problem [19], has a high worst\u00adcase complexity (EXPTIME-complete), several \nalgorithms are known to work in practice [19, 28]. In the polymorphic case, on the other hand, a naive \nextension of the semantic approach is to allow type variables to be embedded in types and then quantify \nthe subset relation over all substitutions for the type variables: T . U .. . S.[[[X. S] T]] . [[[X. \nS] U]] However, the subtype relation de.ned in this way is substan\u00adtially more di.cult than the monomorphic \ncase. This prob\u00adlem can be reduced to the satis.ability problem for set con\u00adstraint systems with negative \nconstraints [1, 13]; this prob\u00adlem is known to be NEXPTIME-complete [27] and, so far, no practical algorithm \nis known. It still is an open question whether the above subtype problem can be reduced to an easier \nproblem. However, we have noticed some tricky be\u00adhavior that makes us believe that the problem is not \neasy to solve. For example, with the de.nition given above, the followingrelation holds: l[a[]],X . l[a[]],A \n| l[X],a[] Here, a[ ] denotes a type representingthe singleton set con\u00adsistingof the value <a></a>. Weassume \nthetype A to represent the complement of the type a[ ] (which is possible to de.ne since types are essentially \nregular). We can prove that this relation holds by a set-theoretical analysis of cases on the type S \nto be substituted for X. (We defer a con\u00adcrete proof to Appendix A.) Note that the example above is strange \nsince the type variable X occurs in irrelevant positions on both sides, and such a behavior appears to \nbe the hard core in the algorithmics. (This example can further be generalized to a .nite type rather \nthan a singleton type. See Appendix A.) In this paper, we propose a di.erent method for construct\u00adinga \npolymorphic type system that (1) retains the original spirit of the semantic approach, (2) eliminates \ntricky cases observed in the above-mentioned naive extension, and (3) yields practical typecheckingalgorithms. \nThe key idea in our approach is to interpret type variables not as place holders for performingsubstitutions, \nbut as markings in documents for indicatingtheir parameterized subparts. For example, we interpret the \npolymorphic type SoapEnv(X) as a set of documents of the form <envelope> <header> ... </header> <body> \nd </body> </envelope> where the subpart d (which itself can be any fragment of documents) is marked by \nX. Usingthis interpretation of types, we de.ne the subtype relation essentially by the sub\u00adset relation, \nwithout involvingquanti.cation. (We actually need to add a little more .exibility, as we will discuss \nin Sec\u00adtion 2.2.) This indeed removes tricky cases observed above, and thus allows us to reduce the problem \nsimply to a slight variation of the tree automata containment problem (Sec\u00adtion 4.2) and to obtain a \nreasonably e.cient algorithm by incorporatingvarious known algorithmic techniques [19, 28]. We use the \nmarkingtechnique not only as a simple tweak to make the algorithmics easier, but we push forward this \ntechnique to designing a whole type system with a sensi\u00adble meaning. We will present a minimal XDuce-style \ncal\u00adculus with an operational semantics where run-time values carry around explicit markings to indicate \nparameterized subparts and a type system that captures the .ow of such markings. Since we do not allow \na new marking to be cre\u00adated duringevaluation, any parameterized subpart in a re\u00adsult value of a function \nmust come from some parameterized subpart in the input value. In other words, the type sys\u00adtem directly \nrepresents a usual expected behavior of a poly\u00admorphic type system a value of a variable type is never \nreconstructed in a reminiscence of Reynold s parametric\u00adity theory [25]. Note that we would not have \nsuch a property if we adopted the placeholder subtypingsince, by using the example relation given above, \na value that that has the concrete type a[ ] could begiven thevariable type X. Another by-product from \nour interpretation of polymor\u00adphic types is that the semantics of types can actually be formalized in \nthe same way as to that of pattern matches. That is, what both of these do is, given a tree value, .rst \nto check conformance and then to return an association of (term or type) variables to subtrees. This \ncoincidence pro\u00advides us two additional bene.ts. First, we can economize the language speci.cation involving \nboth polymorphic types and pattern matches by sharingmany de.nitions related to these two. Second (and \nmore importantly), we can transfer previously known techniques for pattern matches to simi\u00adlar problems \nrelated to polymorphic types. Speci.cally, at applications of polymorphic functions, typechecker needs \nto infer type arguments to the applications for avoiding ver\u00adbose and obvious type annotations. And relevantly, \nwe need to perform a form of ambiguity check on formal parameter types for ensuringthe existence of a \nminimum solution when inferringtype arguments. Both of these can be obtained by slight modi.cations to \nexisting algorithms [14], as shown in Section 4.3 and 4.4. The rest of the paper is organized as follows. \nIn the next section, we illustrate basic ideas for constructingour poly\u00admorphic type system. Section \n3 formalizes the type system and Section 4 describes a set of algorithms needed for type\u00adchecking. Section \n5 discusses related work and Section 6 concludes this paper and hints at future work. Appendix A discusses \nin more detail the above-mentioned tricky example allowed in the place-holder subtyping. For space limita\u00adtion, \nall proofs of the presented theorems are elided from this paper. They can be found in the full version \nof this paper [15]. 2. BASIC IDEAS In this section, we explain our polymorphic type system by example, \nstartingwith a monomorphic system and then describingour ideas for addingpolymorphism. 2.1 Monomorphic \nsystem We start with considering a minimal, functional language designed for XML processing, in the notation \nof XDuce [18]. The language basically provides values as fragments of XML documents (they are the only \nvalues to be manipulated at run time), types based on XML s schemas for describing structures of values, \nand pattern matching as a main pro\u00adgrammingfeature for analyzingand deconstructingvalues. This paper \naims at formalizingthe core idea for dealingwith polymorphism and concentrates only on the treatment \nof el\u00adement structures of XML data. We leave other extensional features, such as XML attributes and higher-order \nfunctions, for future work. For example, consider the followingXDuce program for searchinga database \nfor a data entry that has a speci.ed key. type BibDB = db[BibEntry*] type BibEntry = entry[key[String], \ncontent[Bib]] type BibResult = found[Bib] | notfound[] fun search (String as key1)(BibDB as d) : BibResult \n= match d with db[BibEntry* as l] -> iter(key1)(l) fun iter (String as key1)(BibEntry* as l) : BibResult \n= match l with () -> notfound[] | entry[key[String as key2], content[Any as c]], Any as rest -> if key1= \nkey2 then found[c] else iter(key1)(rest) We .rst de.ne the type BibDB to be values of label db that contains \na repetition of data of type BibEntry.The BibEntry type is in turn de.ned as values of label entry includinga \nkey with a stringand a content with a value of type Bib. Weassume thetype Bib to be de.ned somewhere \nelse. We then de.ne the type BibResult to be either a label found with a Bib value or a label notfound \nwith no content. The type de.nitions are followed by two de.nitions of functions search and iter. The \nfunction search takes a string key1 and a value d of type BibDB as arguments and returns a value of type \nBibResult. The body is a pattern match on d. It matches any value of type db[BibEntry*] and binds the \nvariable l to the subpart of the input value correspondingto BibEntry*, i.e., the content of db.When \nthe matchingsucceeds, the function proceeds to evaluate the correspondingbody, where it calls the function \niter with ar\u00adguments key1 and l. The function iter takes a string key1 and a value l of type BibEntry* \nas arguments and returns a value of type BibResult. The body is a pattern match on l with two clauses. \nThe .rst clause matches an empty sequence value () and returns a value notfound[].The sec\u00adond clause \nmatches a non-empty sequence that begins with an entry containinga key and a content labels. We ex\u00adtract \nthe content key2 of the key label, the content c of the content label, and the remainder sequence rest \nafter the .rst entry label. In the correspondingbody, if the user\u00adspeci.ed key1 and the extracted key2 \nare equal, then we return c enclosed by a found label; otherwise we continue with the remainder sequence. \nIn general, XDuce values (written v)are sequences of la\u00adbeled values (l[v]), or stringvalues. Types (written \nT) are regular expressions over labeled types (l[T])or String type. Thus, types can also be concatenations \n(T1,T2), unions (T1|T2), repetitions (T*), and the empty sequence type (()). We also allow Any to denote \nany value. We abbreviate l[()] by l[]. As usual, types can be de.ned as type names and, in particular, \nthey can be de.ned recursively for describing arbitrarily nested structures. (For guaranteeing regularity \nof types, we require recursive occurrences of type names to be enclosed by labels. See [19, 14] for more \ndetails.) The main part of a program is a set of (recursively de\u00ad.ned) functions with an explicit declaration \nof argument types and a result type. Each de.ned function contains a body expression, where expressions \n(written e)can be vari\u00adables (x), function calls (f(e)), value constructors (label\u00ading l[e], concatenation \ne1,e2, the empty sequence (),and stringconstants), and pattern matches of the form: match e with P1 ->e1 \n|... | Pn -> en (We omit here describingother standard expressions such as if.) A pattern match form \n.rst tries matchingthe input value e against the patterns P1 through Pn in this order, and then evaluates \nthe body expression correspondingto the .rst matchingpattern under the bindings resulted from the matching. \nPatterns have exactly the same structure as types except that variable binders of the form ... asx can \nbe inserted in their subparts. A pattern is matched by values that have the type of the pattern (that \nis, the type obtained after eliminatingall the binders from the pattern). The matching operation returns \nbindings of each pattern variable to the value s subpart correspondingto the binder of the variable. \nWe restrict patterns by usual linearity requirement to en\u00adsure them to yield bindings of exactly the \nsame set of vari\u00adables for any input value. Also, we take a nondeterministic semantics of patterns, where \nwe choose an arbitrary match when a pattern can have more than one possible match for a given input value. \n(More discussions on pattern matching can be found in [14, 17, 12].) Typechecking XDuce programs is mostly \nstraightforward. We basically construct types of expressions, in a bottom-up, syntax-directed way. For \nexample, the expression () has type ();if e has type T,then l[e] has type l[T];if e1 and e2 have type \nT1 and T2 respectively, then e1,e2 has type T1,T2; and so on. For some important places, we check sub\u00adtyping. \nThose places include function calls (subtype check between the actual argument type and the formal parame\u00adter \ntype), function bodies (between the body s type and the declared result type), and pattern matches (between \nthe in\u00adput s type and the union of the types of the patterns, a.k.a. exhaustiveness check). As mentioned \nin the introduction, we de.ne subtypingin a semantic way. That is, usingthe standard conformance relation \nof types (i.e., a value v has type T ), we say that a type S is a subtype of T if and only if every value \nof type S is also of type T.This way of de.ningsubtypingis quite powerful, and known to be useful in \nparticular for exploiting.exibilities of XML data in pro\u00adcessing programs. Moreover, the feasibility \nis guaranteed by the exact correspondence to .nite tree automata, whose con\u00adtainment problem is known \nto be decidable. (More details are given in [19].) It remains to explain how we obtain types for the \nvari\u00adables bound in patterns. For this, we employ a mechanism for inferringthose types from the input \ntype and the pat\u00adterns. (For example, iter function given above has a pat\u00adtern match and we infer types \nfor the variables key2, c,and rest usingthe type of the input l.) The inference is guar\u00adanteed to have \na property called local precision.That is, for each bound variable x appearingin a pattern P,the type \nin\u00adferred for x contains all and only values that may be bound to x, with the assumption that all and \nonly values from the input type may be matched against the pattern. As one can see, this typingis not \nsyntactic. And indeed, we use a slightly involved algorithm for constructing types assigned for pattern \nvariables. More discussions on the type inference algorithm can be found in [17, 14, 12]. As we will \ndescribe in Section 3.4, this inference scheme for patterns turns out to be reusable for the inference \nof type arguments (types to be passed to polymorphic functions at application). 2.2 Polymorphic system \nIn order to add polymorphism to the system described above, we .rst need to extend the syntax. First, \ntypes can contain type variables, and, accordingly, type names can take type parameters. Second, each \nfunction de.nition can declare type parameters, to which the parameter types and the result type can \nrefer. In principle, function applications also take type arguments to instantiate those type variables. \nHowever, we automatically infer them, as we will describe later. As an example, let us write a program \nthat generalizes theabove exampleso that itnow works with any type for data contents. type DB{X} = db[Entry{X}*] \ntype Entry{X} = entry[key[String], content[X]] type Result{X} = found[X] | notfound[] fun search {X}(String \nas key1)(DB{X} as d) : Result{X} = match d with db[Entry{X}* as l] -> iter{X}(key1)(l) fun iter {X}(String \nas key1)(Entry{X}* as l) : Result{X} = match l with () -> notfound[] | entry[key[String as key2], content[Any \nas c]], Any as rest -> if key1= key2 then found[c] else iter{X}(key1)(rest) Changes from the previous \nprogram are that what used to be Content is now replaced by the type variable X,that all the de.nitions \nof type names and functions now take the type parameters, written {X}, and that all the references to \ntype names are now added type arguments, also written {X}. For the sake of explanation, we also show \ntype arguments to polymorphic functions, but they actually need not be written explicitly. As a result \nof parameterizingthe program in this way, we can now search databases with any types of data contents. \nval contactDB : DB{Contact} = ... (* load a contact database file *) val result1: Result{Contact} = search{Contact}(\"HosoyaHome\")(contactDB) \nval bibDB : DB{Bib} = ... (* load a bibliography database file *) val result2 : Result{Bib} = search{Bib}(\"HosoyaPierce00\")(bibDB) \nNote that the types for the results retain the information that their data contents have speci.c types \n(Contact or Bib). If we did not use polymorphism and instead gave the Any type for data contents, we \nwould not get such precise type information for the results. Now, the question is: how can we typecheck \nsuch a poly\u00admorphic program? Or, more fundamentally, what property should we prove about a polymorphic \nprogram? For the monomorphic case, given a function of type, for example, BibEntry* . BibResult the \ntypecheckingscheme described in Section 2.1 tries to prove that, whenever the input value has type BibEntry*, \nthe result (if any) has type BibResult. In the polymorphic case, given a function of type like .X. Entry{X}* \n. Result{X} we would naturally like to prove that, for any type S, when\u00adever the input value has type \nEntry{S}*, the result has type Result{S}. Although we certainly want this property, this would tempt \nus to construct a type system that requires overly ambitious algorithmics, e.g., subtyping de.ned by \nquanti.cation over all substitutions, as discussed in the in\u00adtroduction. Instead, we adopt a stronger \ncondition as an intended property that the type system should try to prove. This consists of two parts: \n1. whenever the input value has type Entry{Any}*,the result has type Result{Any},and 2. any subpart \ncorrespondingto X in the result value (i.e., the content of the found)must come from some sub\u00adpart correspondingto \nX in the input value (i.e., the content of some content).  Let us call these conditions safety property \nfrom now on. These conditions will remind many readers of the well\u00adknown parametricty property of the \npolymorphic lambda calculus [25]. While a usual treatment is to de.ne a calculus and prove this property \nas a theorem, ours is to formalize a system that directly embodies the property. Our key idea is to employ \na marking semantics outlined as follows. First, each value carries a marking, that is, some subparts \nof the value are marked by type variables. Accordingly, we inter\u00adpret a polymorphic type (which contains \ntype variables) by a set of values whose subparts correspondingto the type vari\u00adables are marked with \nthose type variables. For example, the input type Entry{X}* of the function iter represents a set of \nmarked values of the followingform. entry[key[\"...\"], content[v1]], ... entry[key[\"...\"], content[vn]] \n where each vi is marked X. Similarly, the result type Result{X} denotes a set of marked values that \nhave either the form found[v] where v is marked X or the form notfound[] with no mark. The operational \nsemantics of programs is de.ned in such a way that operations in those programs manipulate marked values, \npreservingall markings from the inputs to the out\u00adput. For example, a labelingexpression l[e] adds the \nlabel l to the marked value resulted from evaluating e, preserving the original markings in e s result; \nlikewise, a concatenation expression e1,e2 combines two marked values resulted from evaluating e1 and \ne2. A pattern match takes a marked value and extracts its subparts for formingbindings, pre\u00adservingthe \nmarkings that were present in those subparts of the input marked value. Then, the job of the type system \nis to guarantee that our operational semantics respects our interpretation of types. That is, for a function, \nwe verify that, whenever the function body starts with a marked value inhabitingin the input type and \nperforms operations as speci.ed by the body expression, it results in a marked value that conforms to \nthe declared result type (if it terminates). Since each operation never modi.es a subpart marked with \nX if its result preserves this marking, the whole function body never modi.es any subpart whose markingis \npreserved in the .nal result. Thus, we attain the above-mentioned safety property. The construction of \nour polymorphic type system is mostly similar to the monomorphic one. First, we use exactly the same \ntypingrules for value construction expressions. For example, if e has type T,then l[e] has type l[T].This \nrule works since all markings in the values of type T are also present in the correspondingsubparts of \nthe values of type l[T]. Also, for pattern matches, we use the same speci.cation as before for the inference \nof types for pattern variables except that all values mentioned there now carry markings. Non-trivial \nchanges from the monomorphic sys\u00adtem are in subtypingand in checkingpolymorphic function applications; \nwe describe these below. It would be ideal if we could de.ne subtypingexactly in thesameway as before: \nS is a subtype of T i. any value of type S is also of type T. However, this de.nition turns out to be \ntoo strong. For example, consider the following function fun f {X} (a[X] as x) : a[Any] = x which simply \nreturns the input value without performing any operation. However, the content of the label a has type \nAny for the output, whereas it has type X for the input. With the above simple de.nition of subtyping, \nthis function does not typecheck since the subtype relation a[X] a[Any] does not hold (the right hand \nside requires that no marking is present). Nevertheless, this function is reasonable to accept since \nit ful.lls our safety conditions. That is, each subpart of the result correspondingto X must be identical \nto some subpart of the input correspondingto X. But such a subpart correspondingto X does not exist in \nthe result; hence, the safety property vacuously holds. Therefore we need to slightly relax the de.nition \nof sub\u00adtyping. What is observed in the last paragraph is that sub\u00adtypingtransfers a marked value from \none context to an\u00adother, where if the latter context requires fewer markings, the transfer is still safe. \nFrom this, we obtain the following new de.nition: S is a subtype of T i., for any marked value v of type \nS, there exists a marked value w of type T such that v and w are identical except that some of the marks \nin v can be absent in w. This relaxation of de.nition is some\u00adwhat analogous to the standard promotion \nrule of a type variable to its least non-variable upper bounds, which often appears in type checkingalgorithms \nof systems that combine subtypingand polymorphism (cf. F . [6]). The typingrule for polymorphic function \napplications is as usual. That is, we check that the argument type is a subtype of the parameter type \nwith the type parameters replaced by the type arguments. Then, the whole function application is given \nthe declared result type with the type parameters replaced by the type arguments. For example, consider \nthe de.nition of search function shown in the beginning of this subsection fun search {X} (String as \nkey) (DB{X} as d) : Result{X} = ... and one of its applications: search{Contact}(\"HosoyaHome\")(contactDB) \n We perform the above-mentioned check for both arguments, where, in particular, the second argument s \ntype DB{Contact} is a subtype of [X . Contact] DB{X} = DB{Contact} (since they are identical). We then \ngive the type [X . Contact] Result{X} = Result{Contact} to the result of the applica\u00adtion. This standard \ntypingrule .ts well with our semantic view to polymorphism. First, accordingto our safety prop\u00aderty, \nthe de.nition of search function declares that, for any input value (as the second argument) of the form \ndb[entry[key[\"...\"], content[ v1 ]], ... entry[key[\"...\"], content[ vn ]]] the result (if any) has the \nform found[vi] for some 1 = i = n,or the form notfound[]. Therefore, since the value contactDB has the \nabove form of db where each vi has type Contact, the result of the function search returns for this input \nhas type either found[Contact] or notfound[], i.e., type Result{Contact}. As in our example, type arguments \ngiven to polymor\u00adphic function applications are usually obvious and tedious to write. Therefore we provide \nan automatic scheme that infers type arguments from argument types and parameter types. The inference \nis speci.ed to compute a minimum type argument that ful.lls the above-described requirement between the \nargument type and the parameter type. For thesameexample, wecomputeaminimum type T such that DB{Contact} \n[X . T] DB{X}. Hence, we obtain T = Contact. (Note that, with no func\u00adtion types, the minimum type argument \nalways minimizes the result type since type parameters occur only in positive positions. We would need \nto change this if we supported higher-order functions. See [15] for a related discussion.) A question \nthat may arise here is: does such a minimum type always exist? The answer is no, with only the speci.\u00adcation \nabove. For example, there does not exist a minimum T such that a[c[]],b[d[]] [X . T] (a[Any],b[X] | a[X],b[Any]). \nIndeed, both c[] and d[] are minimal solutions, but neither is smaller than the other. The problem here \nis that the pa\u00adrameter type (a[Any],b[X]|a[X],b[Any]) allows two ways of marking X on subparts of the \nvalue of the argument type a[c[]],b[d[]]. Our approach to this issue is to reject such an ambiguous parameter \ntype. Then, under this restriction, we can prove that a minimum type argument speci.ed be\u00adfore always \nexists (Section 3.4). In our type system, we additionally support type vari\u00adables with type constraints \nof the form Tas X.This form of type denotes values of type T with a markingof X at the top. Thus, a bare \ntype variable X now can be rewritten by Any asX. Such type constraints have an e.ect some\u00adwhat similar \nto bounded quanti.cation, which often appears in type systems with both subtypingand polymorphism. For \nexample, a function of type usually written .XT. a[X] . b[X], where the type parameter is constrained \nto be a subtype of T,can be simulated by: fun f{X} (a[T asX] as x): b[T asX] =... Of course, both are \nnot exactly the same. For example, di.erent occurrences of type variables may have di.erent bounds. Also, \ntype arguments passed to the function are not required to be a subtype of T, but substitution of any \ntype for X is ensured to be a subtype of T. In fact, what is closer to our as notation is intersection \ntypes. See [15] for more details.  3. FORMAL SYSTEM The subsequent two sections formulate our polymorphic \ntype system outlined in the previous section. In this section, we focus on the semantic aspect of the \nformal system, and, in the next section, we address algorithmic problems. The surface language that we \nhave seen, which we call ex\u00adternal language, would be quite complicated to directly deal with. Therefore, \nin the formalization, we instead treat an internal language where two major simpli.cations are made. \nFirst, instead of sequence values and regular-expression-based types, we use a binary representation \nof values and types in the style of [19, 12]. Second, as mentioned before, the be\u00adhaviors of polymorphic \ntypes and patterns are almost the same (while polymorphic types give markings of type vari\u00adables to subparts \nof values, patterns yield bindings of term variables to subparts of values). Therefore we share many \nde.nitions related to these two. 3.1 Values and marking External values are sequences of labeled values \nor string values. Internally, we represent those values by usingonly labels and pairs. We assume a set \nof labels, ranged over by a, thatcontains atleast a special label .. (Internal) values are then de.ned \nby: v ::= a | (v, v) We translate external values to internal ones in a way similar to Lisp s encodingof \nlists by cons and nil.Each external value v that is not an empty sequence is translated to a pair (vh,vt)where \nvh and vt are the translation of v s .rst element and that of the remainder sequence, respectively. If \nthe .rst element is a labeled value, then vh is another pair (a,vc)where a is the label of the element \nand vc is the translation of its content. If the .rst element is a string, then vh is the label representingthe \nstring. An external value that is an empty sequence is translated to .. As external ones do, internal \nvalues carry marks of vari\u00adables on their subparts. We formalize a marked value by an (unmarked) value \nwith separate information that indi\u00adcates which intermediate node is given a mark. We assume aset X of \nvariables, ranged over by x. Variables are divided into two sets, term variables and type variables. \nPaths are de.ned by: p ::= 1p | 2p | E We take a path to be a function that maps a value to its subnode \nlocatingat the path from the root: inductively, E(v)= v and (ip)(v1,v2)= pvi for i =1, 2. A marking V \nis a relation between variables and paths, written {(x : p),...}and a marked value is a pair (v, V ) \nof a value and a marking. For example, the external value entry[key[\"abc\"], content[\"ABC\"]] where the \npart \"ABC\" is marked x is translated to the inter\u00adnal value ((entry, ((key, (abc,.)), ((content, (ABC,.)),.))),.) \n with the marking {x : 122121}(pointingto the subpart ABC). We let X range over .nite sets of variables. \nWe de.ne the restriction V |X of V by X as {(x : p) . V | x . X}.We write dom(V )= {x |x : p .V }. When \nwe compose two marked values in a pair, the orig\u00adinal marks sink down to deeper places. To express this, \nwe de.ne push-down of V by p, written pV ,to be {y : pp' | y : p' .V } (where pp' is the concatenation \nof the paths p and p'). Then, the pairing(v1,V1) .(v2,V2)of two marked values is de.ned as ((v1,v2), \n(1V1 .2V2)). Likewise, when we extract a subnode from a marked value, the original marks .oat up to shallower \nplaces. For this, we de.ne pull-up of V by a path p, written p-1V ,to be {y : p' |y : pp' .V }. Then, \nthe extraction p(u, U) of a marked value from a path p is de.ned as (pu, p-1U). Note that we never lose \nany marks by push-down, whereas we may by pull-up. Hence, it is always that p-1(pV )= V and p(p-1V ) \n.V , but not necessarily p(p-1V )= V . 3.2 Types External types are regular expressions on labeled values, \nwith recursive top-level type de.nitions. We encode those types by internal types also based on labels \nand pairs. We assume a set of type names ranged over by s.A type de.\u00adnition . is a .nite mappingfrom \ntype names to (internal) types, where types are de.ned by the following. p ::= a | (p, p) | p |p | x \n: p | 1 | 0 | s That is, a type can be a label, a pair, a union, a variable with a type constraint, \na universal type, an empty type, or atype name. We write var(p) to be the set of variables appearingin \np and all types associated with the type names reachable from p. We make two restrictions on types. First, \nany recursive use of type name must go through a pair. Second, for any occurrence of x : p,we require \nthat x. var(p). This ensures that a type never generates a marking where two marks of the same variable \noccur in the same path, i.e., both x : p1 and x : p1p2 are in V for some x, p1, and p2. (Allowingthe \nsame variable in the same path would correspond to F-bounded polymorphism [5], but we do not further \npursue this direction in this paper.) Under a .xed type de.nition ., the semantics of types is described \nby the matching relation, written (v, V ) < p,read marked value (v, V )matches p or value v matches p \nand yields a marking V . The matchingrelation is de.ned by the followingset of rules. MPair MCon (vi,Vi) \n< pi for i =1, 2 (a,\u00d8) < a (v1,V1) .(v2,V2) < (p1,p2) MAlt MVar (v, V ) < pi i =1or2 (v, V ) < p (v, \nV ) < p1|p2 (v, V .{x : E}) < x : p MName MAll (v, V ) < .(s) (v, \u00d8) < 1(v, V ) < s Translation from \nexternal types to internal types is anal\u00ad ogous to the encoding of values. Roughly, each type rep\u00adresentingnon-empty \nsequences is translated to a pair type (ph,pt), where ph and pt are the translation of the type for the \n.rst element and that for the remainder sequence, re\u00adspectively. If the .rst element is a labeled type, \nthen ph is (a,pc)where pc corresponds to the content type. If the .rst element is a String type, then \nph is 1. The empty sequence type is translated to .. The other external con\u00adstructs are translated in \na straightforward manner using the correspondinginternal constructs: an alternation translates to an \nalternation, a repetition to a recursion, a variable to a variable, Any type to 1, and so on. For example, \nthe external type db[entry[key[String], content[X]]*] canbe translatedto the internal type ((db,s1),.) \nwith de.nitions s1 . . | ((entry,s2),s1) s2 . ((key,s3), ((content, X :1),.)) s3 . (1,.) (Note that the \nbare variable X is encoded by X :1 since X is an abbreviation for Any asX.) We refer the reader to the \nliterature (e.g., [19]) for a formalization of a general translation scheme. We call types containingonly \nterm variables pattern and those containingonly type variables polymorphic type or polytype. Note that \nwe do not allow patterns to contain any type variables. One would consider that this might be a lit\u00adtle \ninconvenient since, in the monomorphic system, patterns are a superset of types and one can freely embed \ntypes in\u00adside patterns. However, allowingtype variables in patterns adds a substantial complexity to \nthe type and run-time sys\u00adtem since behaviors of pattern matches could now depend on the types to be \npassed at run time. Although such a fea\u00adture would be interestingby itself, we focus, in this paper, \non the simplest case, which still has a lot to study. Another di.erence between patterns and polymorphic \ntypes is that it makes sense for polymorphic types to yield a mark\u00adingwith an arbitrary number of marks \nof the same variable, whereas it does not for patterns. Thus, whenever we use a type p as a pattern, \nwe require that p is linear:(v, V ) < p implies that dom(V )= var(p)and V is a function (i.e., p = p \n' for any x : p, x : p ' . V ). See the full version of this paper [15] for an algorithm for checking \nlinearity. Note that our internal representation allows a mark to be put only on a single node. A consequence \nof this is that the external representation has the restriction that values can have a mark only on a \ntail-sequence, i.e., a sequence that ends at the tail of the whole sequence. For example, in the value \na[b[],c[],d[]], we can put a mark on the sequence c[],d[] but cannot on b[],c[]. We consider that this \nrestriction is rather undesirable and therefore better to be eliminated by a cleverer encodingof variables. \nIn the case of patterns, we can use known encodingtechniques relyingon the linearity condition [19, 14], \nbut in the case of polytypes, we would need a di.erent technique. We leave this issue for future work. \n(The tail-variable restriction on polytypes might actually be acceptable in many cases since the subpart \nof a value to be parameterized is typically on the whole content of a label, as in the examples in the \nintroduction and in Section 2.) The subtype relation, written pq, is de.ned as, for all v and V ,if(v, \nV ) < p,then (v, W ) < q for some W . V .We present an algorithm for checking subtyping in Section 4.2. \n 3.3 Substitution Later, we will formalize our inference scheme in a way that obtains a substitution \nof types for variables. An X\u00adsubstitution s is a mappingfrom a set X of variables to types. In the de.nition \nof the application sp of a substitution s toatype p, we do not use a usual syntactic way, but instead \nadopt a semantic way. This is because we have type con\u00adstraints on variables for which we need to perform \nan inter\u00adsection operation rather than a simple replacement. For ex\u00adample, when we have a type p =(x \n:1, 1) and a substitution s = {x . (y :1,a)}, we can easily obtain sp =((y : b, a), 1) by replacing x \n:1 with (y :1,a). However, in the case that we have a constraint on x as in p =(x :(b, 1), 1), this interacts \nwith (y :1,a); in this example, we need to take an intersection between (b, 1) and the type (y :1,a), \nwhich results in sp =((y : b, a), 1). This situation is even more complicated when the type constraint \ncontains other variables and we need to do a simultaneous substitution for multiple variables. (Another \ncomplication would also arise when the type p is recursively de.ned.) Thus, we de.ne an application sp \nof a substitution s by what the type sp should satisfy semantically. Let us .rst see an example: p =(x \n:(b, 1), 1) and s = {x . (y :1,a)}. The type sp satis.es the following. For each marked value in p, which \nhas the form ((b, v),w)where v and w are any values and (b, v)is marked x,ifthe x-marked subpart (b, \nv) matches s(x)=(y :1,a) with a marking U, then the type sp contains a marked value ((b, v),w)where the \nmark x is replaced by the new marking U;the type sp contains only such marked values. Therefore each \nmarked value in sp has the form ((b, a),w)where w is any value and b is marked y. Syntactically, sp can \nbe written ((y : b, a), 1) as in the last paragraph. Below, we generalize the above notion of substitution \nfor thecasewhere X contains an arbitrary number of vari\u00adables and p may contain extra variables not in \nX.An X\u00adsubstitution s applied to a type p, written sp,is a type satisfyingthe following. (v, V ) < sp \ni. .W, U1,...,Un. (v, W ) < p V = W|X . SpiUi i=1..n where {(x1 : p1),..., (xn : pn)} = W|X (pi(v),Ui) \n< s(xi)(i =1,...,n). That is, for each marked value (v, W )in p,if each xi-marked subpart pi(v)(where \nxi . X)matches the type s(xi)with amarking Ui,then sp contains the marked value (v, V ) where V contains \nthe markingafter replacingeach xi-mark by the new marking Ui pushed down by pi;the type sp contains only \nsuch marked values. Though the de.nition does not tell, such sp always exists and can be computed algorithmically. \nA concrete algorithm can be found in the full version of the paper [15]. Also, though the de.nition does \nnot specify such sp in a syntactically unique way, we assume some strategy that picks up one of types \nsatisfying the above condition (e.g., the algorithm in [15]). We extend the subtype relation between \ntypes to that between substitutions: ss ' means dom(s)= dom(s ' ) and s(x)(x) for any x .dom(s). s ' \n 3.4 Type Inference At each application of polymorphic function and each pat\u00adtern match, we perform \na form of type inference. Although the inference may appear di.erent for these two cases, it can actually \nbe formalized in a uniform way. Both cases involve a domain type p and a target type q,and a set X of \nvariables. For a function application, the domain p is the actual argument s type, the target q is the \nformal parame\u00adter s type, and X is the set of type parameters, where q may contain type variables in \nX. For a pattern match, the do\u00admain p is the input value s type, the target q is the pattern, and X is \nthe set of pattern variables, where q may contain term variables in X. Below, we describe our inference \nin two steps: (1) a relationship amongthe domain, the target, and the inferred types, and (2) two restrictions \non the domain and the target. The .rst part will directly yield the speci.\u00adcation of the inference for \npatterns, whereas combiningboth parts will yield that of the inference for type arguments. An X-inference \nof a (target) type q with respect toa(do\u00admain) type p is an X-substitution, written p <X q, satisfying \nthe followingfor each x .X. (u, U) < (p <X q)(x) i. .v, V, W, p. (v, V ) < p (v, W .{x : p}) < q (u, \nU)= p-1(v, V ) That is, for each marked value (v, V )in p,if v matches q with (at least) a markingof \nx on a subnode p(v), then the inferred type (p <X q)(x)for x contains the subnode with all the original \nmarks V pulledupby p (note that we lose marks on the nodes that are not descendents of p(v)); the inferred \ntype (p <X q)(x) contains only such marked values. Section 4.3 proves that such p <X q always exists \nand can be found deterministically. For example, let the domain p =((y :1,a), 1) and the target q =(x \n:(b, 1), 1), and let us infer a type for x.Each marked value in p has the form ((v, a),w)where v and \nw are any values and v is marked y. Values of the form ((v, a),w) match q when v = b and yield a markingof \nx on the subnode (b, a). Therefore the inferred type for x contains (b, a)where b is marked y (since \nit is marked so in the original marked value). Syntactically, the type can be written (y : b, a). We \nuse the above de.nition directly as the speci.cation of the inference for patterns. For the inference \nof type ar\u00adguments, however, we want to use a di.erent speci.cation as outlined in Section 2.2: a minimum \nX-substitution s such that p sq.Let us call an X-substitution s satisfying p sq solution. Our intention \nis to use the same infer\u00adence algorithm both for patterns and for type arguments. However, the .rst inference \nspeci.cation given above does not necessarily yield a solution. For example, in the pre\u00advious paragraph, \nfrom the domain p =((y :1,a), 1) and the target q =(x :(b, 1), 1), the inference has yielded the {x}-substitution \ns = {x .(y : b, a)}, which does not sat\u00adisfy p sq. Moreover, even when the inference result is a solution, \nit is not necessarily minimum nor even minimal. For example, consider the domain p =(a, b) and the target \nq =(x :1,b)|(a, x : 1) (similar to an example used in Sec\u00adtion 2.2). The inference yields {x . (a|b)} \nbecause there are two possible ways of matchingthe value in p with q and the type inferred for x captures \nboth values that can be bound to x. This result is not minimal since there are other solutions smaller \nthan this: {x . a} and {x . b}.Fur\u00adthermore, since these two are actually minimal and neither is smaller \nthan the other, there is no minimum substitution. The non-minimality is reasonable in the inference for \npat\u00adtern variables since we do not know which case of (x :1,b) and (a, x : 1) would be taken at run time \nand therefore the type for x should conservatively include information on both cases. In the inference \nfor type parameters, however, the in\u00adferred substitution is more desirable to be minimal so as to make \nthe result type of the application of polymorphic func\u00adtion as small as possible and thereby make the \nremaining program code as typable as possible. Further, the minimum one is even more desirable since \nit makes the result type of the application unique and thereby makes the speci.cation of the inference \neasy to understand (the existence of several minimal solutions would complicate it). Fortunately, by \nimposingtwo restrictions on the domain and the target, we can ensure that the inference always com\u00adputes \na minimum solution. The .rst is for ensuringthat the inference result is a solution: we require that \np is a sub\u00adtype of q ignoring variables in X,that is, for all v and V ,if (v, V ) < p,then(v, W ) < q \nand W|.V for some W.We X write this requirement p X q. The second restriction is for ensuringthat the \ninference result is equal or smaller than any solution: we require that q yields a unique markingfor \nany value, formally, for all value v, wehavethat (v, V ) < q and (v, V ' ) < q imply V |X = V ' |X . \nWhen this holds, we say that q is X-unambiguous. We will show an algorithm for ambiguity check in Section \n4.4. Note that the unambiguity requirement is a su.cient con\u00addition but not a necessary one: there is \nan ambiguous pa\u00adrameter type for which a minimum type argument always exists. For example, a parameter \ntype (x :1)|1 is ambiguous but, for any type argument, the solution {x .0}is always minimum. If one considers \nthat our requirement is too re\u00adstrictive, an alternative design might be to require explicit type arguments \nwhen the parameter types are ambiguous. The above claims are summarized by the followingpropo\u00adsition. \nProposition 1. Let p X q and q be X-unambiguous. Then, (p <X q) is the minimum X-substitution s satisfying \np sq. 3.5 Type system With the de.nitions given above, we can describe our type system in a relatively \nstraightforward way. A program con\u00adsists of a set F of (top-level) functions, ranged over by f,of the \nform fun f{X}(x : p1): p2 = e (where p1 and p2 are polytypes) and an entry-point term e0, where terms \nare de.ned by the followingsyntax. e ::= x | a | (e,e) | f(e) |match e with p1.e1 |... |pn.en That is, \na term is either a variable, a label, a pair, a func\u00adtion call, or a pattern match (where each pi is \na pattern). Note that a function call may be to a polymorphic one, but we do not provide a form to explicitly \nsupply type arguments they are always inferred. In any match expres\u00adsion match e with p1.e1 | ... |pn.en, \nwe assume that var(pi) nvar(pj)= \u00d8for i = j (for convenience), and that each pattern pi is linear. For \na function fun f{X}(x : p1): p2 = e,we require that var(p1) .var(p2) . X.Also, we assume a .xed set F \nof functions from now on, and no two di.erent functions of the same name are declared in F. Fi\u00adnally, \nwe adopt the usual a-renamingconvention of bound variables. The type system is described by the typingrelations \nof the form G . e . p ( under type environment G, term e has polytype p ) and of the form . f for a function \nf =(fun f{X}(x : p): q = e) ( function f is well-typed ) where a type environment G is a mappingfrom \nterm variables to polytypes (hence a substitution of polytypes for term vari\u00adables). We write .F ( all \nfunctions are well-typed ) for .f for all f .F. The typingrelations are de.ned by the fol\u00adlowingset of \nrules. TPair TCon TVar G .ei .pi for i=1,2 G .a.a G .x.G(x)G .(e1,e2) .(p1,p2) TApp fun f{X}(x : p): \nq = e2 .FG .e1 .rr X p G .f(e1) .(r <X p)q TMatch G .e0 .pX = var(p1 |... |pn) p X p1 |... |pn G,(p<X \npi) .ei .ri for i =1,...,n G .match e0 with p1.e1 |... |pn.en .r1 |... |rn TFun x: p.e.r rq p is X-unambiguous \n.fun f{X}(x : p): q = e These rules are quite standard except for TApp, TMatch, and TFun.In TApp, we \n.rst infer the substitution (r <X p) for the type parameters X from the actual argument type r and the \nformal parameter type p, as described in Section 3.4. As already stated, in order to ensure that the \nresult of the inference is minimum, we require that the actual argument type r is a subtype of the formal \nparameter type p,ignor\u00adingthe type parameters X (checked in TApp), and that the formal parameter type \np is X-unambiguous (checked in TFun). In TMatch, we .rst ensure exhaustiveness of the pattern match with \nrespect to the domain type p.For this, we check that p is a subtype of the union of the pat\u00adterns p1,...,pn, \nignoring all the term variables appearing in these patterns. Then, for each pattern pi, we calculate \nthe X-inference (p<X pi) of the pattern pi with respect to the domain type pand, under the current type \nenvironment aug\u00admented with the obtained substitution [p<X pi](recall that [p <X pi] can be seen as a \ntype environment), we typecheck the correspondingbody ei. The type of the whole match expression is the \nunion of the types ri of all the bodies.  3.6 Evaluation semantics The evaluation semantics is fairly \nstraightforward except for its handlingof marking. We describe the semantics by the evaluation relation \nE .e.(v,V) ( under value environ\u00adment E,term e evaluates to marked value (v,V) ) where a value environment \nE is a mappingfrom term variables to marked values. The evaluation relation is de.ned by the followingset \nof rules. SVar SCon E .x.E(x) E .a.(a,\u00d8) SPair E .ei .(vi,Vi)for i =1,2 E .(e1,e2) .(v1,V1) .(v2,V2) \nSApp fun f{X}(x : p): q = e2 .F E .e1 .(v,V) x:(v,V) .e2 .(w,W) E .f(e1) .(w,W) SMatch E .e0 .(v,V) \n(v,V ' ) < pi E,{x: p(v,V) |x: p .V ' }.ei .(w,W) E .match e0 with p1.e1 |... |pn.en .(w,W) In SCon, \na label expression a produces a value a with no mark. In SPair, two marked values yielded by e1 and e2 \nare paired by ..In SApp, a function call to f simply passes the marked value of the argument expression \nto the function and yields the marked value returned from the function. In SMatch, after evaluatingthe \ninput as (v,V), we try match\u00adingthe bare value v against each pattern. If some pattern pi matches with \na marking V ' , then we form a bindingof each pattern variable x to the marked value p(v,V) (i.e., the \nextraction of (v,V) by the path p)where p is the path for the mark x in V ' . (Note that, since each \npattern is lin\u00adear, there is always exactly one x: p in V ' for each variable appearingin the pattern.) \nWith the obtained bindings, we evaluate the correspondingbody ei. Note that the semantics of pattern \nmatchingchooses an arbitrary clause when mul\u00adtiple clauses can match, unlike the usual semantics choosing \nthe .rst clause in such a case. This design choice is just for simplifyingthe formalization. Changingthe \nsemantics to the .rst match should be straightforward, except that the type system would require taking \ndi.erence between types. See [15] for further discussions. Finally, note that no construct creates marks. \nThere\u00adfore, when we start from an entry-point expression and pro\u00adceed evaluation, we will never see any \nmarkingat all during execution. This means that we actually do not need marked values and all run-time \nmechanisms related to markingin an actual implementation bare values are enough. Then, why should we \nnevertheless care about the evaluation seman\u00adtics with marked values? The answer is: for understanding \nour polymorphic type system. That is, the intuition behind what the type system is tryingto prove each \nparameter\u00adized subpart in the result value comes from some parameter\u00adized subpart in the input value \nis best explained in terms of our evaluation semantics. 3.7 Correctness The correctness of our type \nsystem consists of two main theorems, type preservation ( the result of a well-typed ex\u00adpression always \nhas the speci.ed type ) and progress ( no well-typed expression goes wrong ). Type preservation can be \nproved by standard induction on the derivation of the evaluation relation. We write G .E if dom(G) = \ndom(E), and E(x)=(v, V ) implies (v, V ' ) < G(x) for some V ' . V . Note that the values in the value \nenvi\u00adronment may contain extra marks not speci.ed by the cor\u00adrespondingtypes in the type environment. \nTheorem 1 (Type preservation). Let . F.If G . e .p and E .e .(w, W) with G .E,then (w, W ' ) < p for \nsome W ' .W. In order to state the progress theorem, we .rst clarify what we mean by go wrong. Since \njust saying E .e .(v, V ) can mean either e goes wrong or e diverges, we need to de.ne the additional \nfailure relation E . e .. to explic\u00aditly state that e encounters a run-time error. We omit the rules \nfor the failure relation from this paper (the de.nition is straightforward: E . e .. when one of the \nnecessary premises fails), but these can be found in the full version [15]. Theorem 2 (Progress). Let \n. F.If G . E and G . e .p,then E .e .. never holds.  4. ALGORITHMS This section describes algorithms \nnecessary for implement\u00adingthe type system de.ned in the previous section. The algorithms presented here \nare subtype checking, inference, and ambiguity checking. For space limitation, algorithms for checkinglinearity \nof patterns and for substitution are omitted here, but can be found in [15]. 4.1 Marking automata For \ndescribingour algorithms, we use a model called mark\u00adingautomata, which can be seen as a slight variation \nof types in the binary representation given in the previous sec\u00adtion. Let us assume a .nite set S of \nlabels, which may be ob\u00adtained by collecting all labels appearing in a given program. A marking automaton \nA is a tuple (S, I, d, .) where S is a .nite set of states,  I is a set of initial states (I .S), \n d is a set of transition rules of the form either s . (s1,s2)or s .a where s, s1,s2 .S and a .S, and \n . is a mappingfrom states to sets of variables (. : S .P(X)).  Given a markingautomaton A =(S, I, \nd, .), we de.ne the set, written pAs,of reachable states from a given state s by agiven path p as follows. \nEAs = {s} (jp)As = S{pAsj |s .(s1,s2) .d} We de.ne pAS = S{pAs | s . S} for a set S of states. We simply \nsay that a state s is reachable from s ' when s is reachable from s ' by some path. We write varA(s) \nfor the set of variables at the states reachable from s,and varA(S)= S{varA(s) | s . S}.We also require \nthat .(s) n(varA(s1) .varA(s2)) = \u00d8whenever s .(s1,s2) .d (this is to ensure that any accepted marked \nvalue does not contain two markings of the same variable in the same path). In the sequel, we omit the \nsubscript A appearingin these de.nitions whenever it is clear from the context. The semantics of a markingautomaton \nA =(S, I, d, .) is described by the matchingrelation A . (v, V ) < s,read markingautomaton A accepts \nmarked value (v, V )atstate s. The matchingrelation is de.ned by the followingset of rules. ACon s .a \n.d A .(a, .(s) \u00d7{E}) < s APair s .(s1,s2) .dA .(vi,Vi) < si for i =1, 2 A .((v1,v2), 1V1 .2V2 ..(s) \u00d7{E}) \n< s When there is no ambiguity about which marking automa\u00adton wetalkabout, wewrite (v, V ) < s instead \nof A .(v, V ) < s. Also, we write (v, V ) < A when A . (v, V ) < s for some s . I. Note that each state \nis associated with a set of variables rather than a single variable. This is for encod\u00adingtypes like \nx : y :(1, 1) that may mark the same node with several variables. Any type (with a type de.nition) canbe \nencoded by a markingautomatonina straightfor\u00adward way. A concrete encodingprocedure can be found in [15]. \n(Note that a markingautomaton can trivially be en\u00adcoded by a type with a type de.nition.) We transfer \nall the type-related de.nitions (linearity, substitution, subtyping, inference, and ambiguity) to marking \nautomata. (Thus, we write in a way like AB.) Some of the algorithms shown later use an empty elimi\u00adnation \noperation on a given marking automaton A = (S, I, d, .). This operation yields another markingautoma\u00adton \nA ' =(S ' ,I ' ,d ' , . ' )with S ' .S such that A . (v, V ) < s i. A ' . (v, V ) < s for any (v, V \n)and s .S ' (A and A ' behave exactly the same at the same state),  A ' . (v, V ) < s for some (v, V \n) for any s . S ' (any state in A ' accepts some marked value),  I ' = {s . I | A . (v, V ) < s for \nsome (v, V )} (A ' s initial states are A s non-empty initial states), and  s .pI ' for some p for any \ns .S ' (all states in A ' are reachable from an initial state).  We do not describe a concrete procedure \nfor empty elimina\u00adtion, but linear time algorithms can be found in the litera\u00adture, e.g., [8]. 4.2 Subtyping \nThe goal here is, given marking automata A and B,to check whether, whenever (v, V ) < A,we have (v, W \n) < B for some W . V .Let A =(SA,IA,dA, .A)and B = (SB ,IB,dB , .B ). Then, our subtypingalgorithm is \nas fol\u00adlows. 1. Construct C =(SC ,IC ,dC , .C ) such that SC = SA \u00d7P(SB) IC = IA \u00d7{IB} .C ((s, T)) = \n\u00d8 and (S1) (s, T) .((s1,T1), (s2,T2)) .dC i. s .(s1,s2) .dA and for each t . T where .B (t) . .A(s), \nif t . (t1,t2) .dB , then either t1 .T1 or t2 .T2 (S2) (s,T) .a.dC i. s.a.dA and  for each t.T where \n.B (t) ..A(s), we have t.a.dB.  2. Return yes i. C is empty (i.e., .(v,V).(v,V) < C). That is, we .rst \nconstruct a markingautomaton C that accepts marked values (v,\u00d8) such that A accepts (v,V)for some V, \nbut B does not accept (v,W) for any W . V. Then, we check whether the automaton C is empty. The automaton \nC contains states of the form (s,{t1,...,tn}) such that s . SA and each ti . SB . Intuitively, the state \n(s,{t1,...,tn}) accepts (v,\u00d8)where saccepts (v,V)for some V, but any ti does not accept (v,W) for any \nW .V.Hence, we set IA \u00d7{IB } as C s initial states. Rules (S1) and (S2) for constructing C s transition \nrules can be understood as follows. For rule (S1), consider a state (s,T) and a value (v1,v2). Suppose \nthat (1) s accepts ((v1,v2),V), but (2) any t . T does not accept ((v1,v2),W) for any W . V. Condition \n(1) means that a transition rule s . (s1,s2)is in dA where sj accepts (vj ,Vj )for some Vj for j =1,2and \nV =1V1 .2V2 ..A(s) \u00d7{E}. Condition (2) means that, for any t.(t1,t2)in dB where t.T,either.B (t) ..A(s)(in \nwhich case, W .V whenever t accepts ((v1,v2),W)), or t1 does not accept (v1,W1) for any W1 . V1,or t2 \ndoes not accept (v2,W2) for any W2 .V2. Rule (S2) is analogous. The above presentation does not directly \ngive an e.cient algorithm for subtyping. One way of obtaining a practical algorithm is to adapt a subtyping \nalgorithm for monomor\u00adphic types proposed in Hosoya, Vouillon, and Pierce [19]. Their algorithm computes \nessentially what our algorithm above does minus the treatment of variables, but is elabo\u00adrated with various \ntechniques for e.ciency, includinga lazy, top-down strategy for state exploration and a working set data \nstructure for avoidingrepeated computations. Thus, we can easily obtain an e.cient subtypingalgorithm \nfor polymorphic types by just augmenting their algorithm with a rule for treatingvariables.2 Proposition \n2. The subtyping algorithm returns yes i. AB.  4.3 Inference Consider markingautomata A and B and a \nset X = {x1,...,xn} of variables. Our purpose here is to obtain an X-inference of B with respect to A, \nthat is, a mapping {x1 .Dx1 ,...,xn .Dxn } such that A accepts (v,V)and B accepts (v,W)withamark xi : \np .W if and only if Dxi accepts p(v,V) (i.e., the extraction of (v,V) by the path p). Let A =(SA,IA,dA,.A)and \nB =(SB,IB ,dB ,.B ). We assume X .var(B)and var(IA) nvar(IB)= \u00d8. Then, the inference algorithm is as \nfollows. 2For readers familiar with the algorithm in [19], the addi\u00adtional rule would look like: .B (t1) \n..A(s) st2|...|tn st1|t2|...|tn 1. Construct C =(SC ,IC ,dC ,.C ) such that SC = SA \u00d7SB IC = IA \u00d7IB .C \n(s,t)=.A(s) ..B (t) and (I1) (s,t) . ((s1,t1),(s2,t2)) . dC i. s . (s1,s2) . dA and t .(t1,t2) .dB (I2) \n(s,t) .a.dC i. s.a.dA and s.a.dB. 2. Empty-eliminate C 3. For each x . X,construct Dx =(SDx ,IDx ,dDx \n,.Dx ) such that  SDx = SC IDx = {s |x..C (s)}dDx = dC .Dx ((s,t)) = .C (s,t) nvar(IA). That is, we \n.rst compute a product of A and B to obtain a specialization C of the target B with respect to the domain \nA. Thus, the automaton C behaves exactly the same as B except that it accepts only marked values that \nare also accepted by A. Therefore, whenever B matches a marked value (v,V) accepted by A and yields a \nbindingof x to another marked value (u,U), the automaton C accepts the marked value (u,U) at some state \n(s,t)thatmarks x. Each result automaton Dx is essentially a copy of C where Dx starts from C s states \nthat have x in their variable sets. The empty elimination performed in the second step is nec\u00adessary \nto guarantee that each Dx accepts no more than the appropriate marked values. To see this, note .rst \nthat, after the empty elimination of C, each state (s,t)is non-empty and reachable from an initial state. \nTherefore, whenever Dx has an initial state (s,t), or equivalently (empty-eliminated) C has a state (s,t)thatmarks \nx, there is some marked value (v,V) that is accepted by (empty-eliminated) C and produces a bindingof \nx to another marked value (u,U)at the state (s,t). This means that both A and B accept the marked value \n(v,V)and B yields (u,U)atthe state t. The algorithm above can be seen as a straightforward adaptation \nof (monomorphic) type inference algorithms for patterns presented in [17, 14]. Those previous algorithms \nhave treated features not considered here (such as .rst\u00admatch patterns and non-tail variables) whereas \nthe present one treats polymorphic types (which is achieved just by al\u00adlowingvariables in the domain \ntype). Proposition 3. {x1 . Dx1 ,...,xn . Dxn } is an X\u00adinference of B with respect to A. 4.4 Ambiguity \nThe ambiguity check aims to .nd whether, given a mark\u00adingautomaton A,any value matched by A is marked \nin a unique way, that is, V = W whenever A accepts (v,V)and (v,W). Let A =(SA,IA,dA,.A). The ambiguity \ncheck algorithm is as follows. 1. Construct C =(SC ,IC ,dC ,.C ) such that SC = SA \u00d7SA IC = IA \u00d7IA .C \n((s,t)) = (.A(s) \\.A(t)) .(.A(t) \\.A(s)) and (A1) (s, t) . ((s1,t1), (s2,t2)) . dC i. s . (s1,s2) . dA \nand t . (t1,t2) . dA (A2) (s, t) . a . dC i. s . a . dA and s . a . dA. 2. Empty-eliminate C;let D =(SD,ID,dD, \n.D)bethe result. 3. Return unambiguous i. .D(s, t)= \u00d8 for each (s, t) . SD.  That is, we .rst take \nthe self-product C of A,where we set the variables .C ((s, t)) of each state (s, t) such that .C ((s, \nt)) = \u00d8 if and only if .A(s)=.A(t). The second and third steps can be understood as follows. For the \nempty elimination D of C, suppose .D((s, t)) = \u00d8 for all the states (s, t)and A accepts (v, V )and (v, \nW ). Then, the .rst step ensures that, for each subnode of v,the states s ' and t ' as\u00adsigned to this \nnode in these two cases have the same set of variables: .A(s ' )=.A(t ' ). Therefore the whole markings \nV and W must also be the same. On the other hand, suppose .D((s, t)) = \u00d8 for some state (s, t), that \nis, .A(s)=.B (t). Then, since D is empty-eliminated, there is some value v that is matched by D and produces \na markingat the state (s, t). This means that A has two ways of matchingthe value v that put di.erent \nmarks on the same subnode at the states s and t. Proposition 4. The ambiguity-checking algorithm returns \nunambiguous i. A is X-unambiguous.  5. RELATED WORK There have been very few work on static type systems \nfor XML that support parametric polymorphism. In particu\u00adlar, we are not aware of any attempt to extend \nthe semantic approach. However, polymorphism can trivially be treated by adoptingso-called the data-bindingapproach. \nThis ap\u00adproach, in general, is a handy method to attain, to some ex\u00adtent, static typingby mappingXML \ntypes and data values into the structure of an existing programming language. So, if the chosen programming \nlanguage already supports para\u00admetric polymorphism, then we automatically achieve the goal. One such \nwork is HaXML [29], which maps DTDs to Haskell s polymorphic type system [24]. Another work close to \nthis is XMLambda [21, 26], which adds a more .exibility to the usual data-bindingapproach by usinga novel \ntyping discipline called type-index rows and parametric polymor\u00adphism adapted to this. Both their and \nour approaches can express a simple polymorphism as in a type (A|X)repre\u00adsenting at least choice A oratype \n(A, X)representing at least .eld A. However, our approach provides far more .exibilities with the use \nof our semantic subtyping. For ex\u00adample, consider a type ((A|B),X) representing either A or B, then followed \nby X. Our approach can regard this type as (A, X)|(B, X) thanks to our subtypingand therefore can treat \nthetype(A, C)|(B, C) as an instance of this type. Their approach, however, cannot do the same because \ntheir encodingof regular expressions by disjoint union, tuples, lists, and so on does not allow such \n.exible type equivalence or subtyping.  6. CONCLUSIONS In this paper, we have presented a series of \ntheoretical studies on parametric polymorphism for XML. Our type sys\u00adtem smoothly extends the semantic \napproach that is already standard in monomorphic type systems for XML languages. The crucial part is \nto introduce markings so as to give a sen\u00adsible interpretation to type variables and, at the same time, \nobtain practical typecheckingalgorithms. The present work is only a .rst step toward a full-.edged polymorphic \ntype system for XML and various additional in\u00advestigations are in order. In particular, we have not treated \ntype variables in non-tail positions for a technical reason. We consider that the restriction can be \neliminated by im\u00adprovingthe current naive encodingof types in automata. Another important extension is \nfor XML attributes. For this, we plan to investigate whether we can combine exist\u00adingideas treatingattributes \nfor the monomorphic case [16, 12]. 7. REFERENCES [1] A. Aiken, D. Kozen, and E. L. Wimmers. Decidability \nof systems of set constraints with negative constraints. Information and Computation, 122(1):30 44, 1995. \n[2] A. W. Appel and D. B. MacQueen. Standard ML of New Jersey. In Third Int l Symp.on Prog.Lang. Implementation \nand Logic Programming, pages 1 13. Springer-Verlag, Aug. 1991. [3] V. Benzaken, G. Castagna, and A. Frisch. \nCDuce: An XML-centric general-purpose language. In Proceedings of the International Conference on Functional \nProgramming (ICFP), pages 51 63, 2003. [4] G. Bracha, M. Odersky, D. Stoutamire, and P. Wadler. Makingthe \nfuture safe for the past: Addinggenericity to the Java programming language. In C. Chambers, editor, \nACM Symposium on Object Oriented Programming: Systems, Languages, and Applications (OOPSLA), pages 183 \n200, Vancouver, BC, 1998. [5] P. S. Canning, W. R. Cook, W. L. Hill, W. G. Oltho., and J. C. Mitchell. \nF-bounded polymorphism for object-oriented programming. In Conference on Functional Programming Languages \nand Computer Architecture (FPCA), pages 273 280, 1989. [6] L. Cardelli, S. Martini, J. C. Mitchell, and \nA. Scedrov. An extension of System F with subtyping. Information and Computation, 109(1 2):4 56, 1994. \n[7] J. Clark and M. Murata. RELAX NG. http:// www.relaxng.org, 2001. [8] H. Comon, M. Dauchet, R. Gilleron, \nF. Jacquemard, D. Lugiez, S. Tison, and M. Tommasi. Tree automata techniques and applications. Draft \nbook; available electronically on http:// www.grappa.univ-lille3.fr/tata, 1999. [9] M. A. Ellis and B. \nStroustrup. The Annotated C++ Reference Manual. Addison-Wesley, 1990.  [10] D. Fallside and Y. Lafon. \nXML protocol working group. http://www.w3.org/2000/xp/Group/, 2004. [11] P. Fankhauser, M. Fern\u00b4andez, \nA. Malhotra, M. Rys, J. Sim\u00b4eon, and P. Wadler. XQuery 1.0 Formal Semantics. http://www.w3.org/TR/ query-semantics/, \n2001. [12] A. Frisch, G. Castagna, and V. Benzaken. Semantic subtyping. In Seventeenth Annual IEEE Symposium \non Logic In Computer Science, pages 137 146, 2002. [13] R. Gilleron, S. Tison, and M. Tommasi. Set constraints \nand automata. Information and Computation, 149(1):1 41, 1999. [14] H. Hosoya. Regular expression pattern \nmatching a simpler design. Technical Report 1397, RIMS, Kyoto University, 2003. [15] H. Hosoya, A. Frisch, \nand G. Castagna. Parametric polymorphism for XML. http:// arbre.is.s.u-tokyo.ac.jp/~hahosoya/papers/ \npolyx.ps, 2004. Full version. [16] H. Hosoya and M. Murata. Boolean operations and inclusion test for \nattribute-element constraints. In Eighth International Conference on Implementation and Application of \nAutomata, volume 2759 of Lecture Notes in Computer Science, pages 201 212. Springer-Verlag, 2003. [17] \nH. Hosoya and B. C. Pierce. Regular expression pattern matchingfor XML. Journal of Functional Programming, \n13(6):961 1004, 2002. Short version appeared in Proceedings of The 25th Annual ACM SIGPLAN-SIGACT Symposium \non Principles of Programming Languages, pp. 67 80, 2001. [18] H. Hosoya and B. C. Pierce. XDuce: A typed \nXML processing language. ACM Transactions on Internet Technology, 3(2):117 148, 2003. Short version appeared \nin Proceedings of Third International Workshop on the Web and Databases (WebDB2000), volume 1997 of Lecture \nNotes in Computer Science, pp. 226 244, Springer-Verlag. [19] H. Hosoya, J. Vouillon, and B. C. Pierce. \nRegular expression types for XML. ACM Transactions on Programming Languages and Systems, 2004. Short \nversion appeared in Proceedings of the International Conference on Functional Programming (ICFP), pp.11-22, \n2000. [20] X. Leroy, D. Doligez, J. Garrigue, J. Vouillon, and D. R\u00b4emy. The Objective Caml system. Software \nand documentation available on the Web, http:// pauillac.inria.fr/ocaml/, 1996. [21] E. Meijer and M. \nShields. XM.: A functional programming language for constructing and manipulatingXML documents. Manuscript, \n1999. [22] T. Milo, D. Suciu, and V. Vianu. Typecheckingfor XML transformers. In Proceedings of the Nineteenth \nACM SIGMOD-SIGACT-SIGART Symposium on Principles of Database Systems, pages 11 22. ACM, May 2000. [23] \nM. Murata. Extended path expressions for XML. In Proceedings of Symposium on Principles of Database Systems \n(PODS), pages 126 137, 2001. [24] S. L. Peyton Jones, C. V. Hall, K. Hammond, W. Partain, and P. Wadler. \nThe Glasgow Haskell compiler: a technical overview. In Proc.UK Joint Framework for Information Technology \n(JFIT) Technical Conference, July 1993. [25] J. C. Reynolds. Types, abstraction, and parametric polymorphism. \nInformation Processing, 83:513 523, 1983. [26] M. Shields and E. Meijer. Type-indexed rows. In The 25th \nAnnual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, pages 261 275, London, Jan \n2001. [27] K. Stef\u00b4ensson. Systems of set constraints with negative constraints are nexptime-complete. \nIn Proceedings of Ninth Annual IEEE Symposium on Logic in Computer Science, pages 137 141, 1994. [28] \nA. Tozawa and M. Hagiya. XML schema containment checkingbased on semi-implicit techniques. In 8th International \nConference on Implementation and Application of Automata, volume 2759 of Lecture Notes in Computer Science, \npages 213 225. Springer-Verlag, 2003. [29] M. Wallace and C. Runciman. Haskell and XML: Generic combinators \nor type-based translation? In Proceedings of the Fourth ACM SIGPLAN International Conference on Functional \nProgramming (ICFP 99), volume 34-9 of ACM Sigplan Notices, pages 148 159, N.Y., Sept. 27 29 1999. ACM \nPress. APPENDIX A. TRICKY SUBTYPING EXAMPLE This section gives a bit more details on the tricky subtyp\u00adingexample \nshown in the introduction. The example is not allowed by our marking-based subtyping but is allowed by \nthe placeholder-based subtyping, i.e., de.ned by the subset relation holds for all substitutions. The \nexample was: for any type X, (a,X) . (a,a) . (X,a). Here, a is a type representingthe complement of \na,which can easily be de.ned by usingrecursion. (We assume here that there are only a .nite number of \nlabels. To allow an in.nite number of labels, we need to extend the type lan\u00adguage.) Indeed, if X does \nnot contain a, then the left hand side is included by the .rst clause on the right. If X does contain \na, then all the values on the left except (a,a)is in\u00adcluded by the .rst clause on the right and the value \n(a,a)is included by the second clause. Our de.nition of subtypingdoes not permit the above example since \nno occurrence of X on the right corresponds to the occurrence of X on the left. We can generalize the \nabove example for any number of singletons as follows (we use (n+1)-ary tuples for simplicity but they \ncan of course be encoded by pairs). (a1,...,an,X) . (a1,...,an,a1| ...|an) Sn . i=1(a1,...,ai1 ,X,ai+1,...,an,ai) \n  Acknowledgments We would like to express our best gratitude to J\u00b4er ome Vouil\u00adlon, Benjamin Pierce, \nVladimir Gapeyev, and Naoki Kobayashi for precious comments and useful discussions. We thank anonymous \nreferees of POPL 05 whose comments and sug\u00adgestions have greatly improved the presentation of this pa\u00adper. \nThis work was partly supported by The Inamori Foun\u00addation, Japan Society for the Promotion of Science, \nand the European FET contract MyThS , IST-2001-32617. \n\t\t\t", "proc_id": "1040305", "abstract": "Despite the extensiveness of recent investigations on static typing for XML, parametric polymorphism has rarely been treated. This well-established typing discipline can also be useful in XML processing in particular for programs involving \"parametric schemas,\" i.e., schemas parameterized over other schemas (e.g., SOAP). The difficulty in treating polymorphism for XML lies in how to extend the \"semantic\" approach used in the mainstream (monomorphic) XML type systems. A naive extension would be \"semantic\" quantification over all substitutions for type variables. However, this approach reduces to an NEXPTIME-complete problem for which no practical algorithm is known. In this paper, we propose a different method that smoothly extends the semantic approach yet is algorithmically easier. In this, we devise a novel and simple <i>marking</i> technique, where we interpret a polymorphic type as a set of values with annotations of which subparts are parameterized. We exploit this interpretation in every ingredient of our polymorphic type system such as subtyping, inference of type arguments, and so on. As a result, we achieve a sensible system that directly represents a usual expected behavior of polymorphic type systems---\"values of variable types are never reconstructed\"---in a reminiscence of Reynold's parametricity theory. Also, we obtain a set of practical algorithms for typechecking by local modifications to existing ones for a monomorphic system.", "authors": [{"name": "Haruo Hosoya", "author_profile_id": "81100504076", "affiliation": "The University of Tokyo", "person_id": "PP37028416", "email_address": "", "orcid_id": ""}, {"name": "Alain Frisch", "author_profile_id": "81100574832", "affiliation": "INRIA", "person_id": "PP17010293", "email_address": "", "orcid_id": ""}, {"name": "Giuseppe Castagna", "author_profile_id": "81100388576", "affiliation": "&#201;cole Normale Sup&#233;rieurede, Paris", "person_id": "PP31040104", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1040305.1040310", "year": "2005", "article_id": "1040310", "conference": "POPL", "title": "Parametric polymorphism for XML", "url": "http://dl.acm.org/citation.cfm?id=1040310"}