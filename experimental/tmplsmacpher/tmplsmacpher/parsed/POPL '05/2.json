{"article_publication_date": "01-12-2005", "fulltext": "\n Polymorphic Bytecode: Compositional Compilation for Java-like Languages Davide Ancona DISI -Universit`a \ndi Genova davide@disi.unige.it Sophia Drossopoulou Dep. of Computing -Imperial College  sd@doc.ic.ac.uk \nABSTRACT We de.ne compositional compilation as the ability to type\u00adcheck source code fragments in isolation, \ngenerate corre\u00adsponding binaries, and link together fragments whose mu\u00adtual assumptions are satis.ed, \nwithout reinspecting the code. Even though compositional compilation is a highly desirable feature, in \nJava-like languages it can hardly be achieved. This is due to the fact that the bytecode generated for \na fragment (say, a class)is not uniquely determined by its source code, but also depends on the compilation \ncontext. We propose a way to obtain compositional compilation for Java, by introducing a polymorphic \nform of bytecode contain\u00ading type variables (ranging over class names)and equipped with a set of constraints \ninvolving type variables. Thus, polymorphic bytecode provides a representation for all the (standard)bytecode \nthat can be obtained by replacing type variables with classes satisfying the associated constraints. \nWe illustrate our proposal by developing a typing and a linking algorithm. The typing algorithm compiles \na class in isolation generating the corresponding polymorphic byte\u00adcode fragment and constraints on the \nclasses it depends on. The linking algorithm takes a collection of polymor\u00adphic bytecode fragments, checks \ntheir mutual consistency, and possibly simpli.es and specializes them. In particular, linking a self-contained \ncollection of fragments either fails, or produces standard bytecode (the same as what would have been \nproduced by standard compilation of all fragments). Categories and Subject Descriptors: D.3.3[Programming \nlanguages]: Language constructs and features classes and objects; D.3.1[Programming languages]: Formal \nde.nitions and theory syntax, semantics; D.3.4[Programming languages]: Processors incremental compilers \nGeneral Terms: languages, theory, design Permission to make digital or hard copies of all or part of \nthis work for personal or classroom use is granted without fee provided that copies are not made or distributed \nfor pro.t or commercial advantage and that copies bear this notice and the full citation on the .rst \npage. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior \nspeci.c permission and/or a fee. POPL 05, January 12 14, 2005, Long Beach, California, USA. Copyright \n2005 ACM 1-58113-830-X/05/0001 ...$5.00. Ferruccio Damiani Dip. di Informatica -Universit`a di Torino \n  damiani@di.unito.it Elena Zucca DISI -Universit`a di Genova zucca@disi.unige.it Keywords: type systems, \ncompositional analysis 1. INTRODUCTION Compilers have two main tasks: To check that the source code \nadheres to the language rules (which usually means that it typechecks), and to produce target code. Originally, \ncompilers would process the complete source of an application; thus they would apply global compilation. \nIn strongly typed languages execution of a globally compiled application is guaranteed to be type safe. \nIn the 70s, inspired by Parnas s ideas about abstract data types, languages like Mesa, LIS, Modula-2, \nand Ada intro\u00adduced separate compilation, whereby an application would consist of fragments (e.g., modules, \npackages, or classes).1 A fragment would be compiled separately in the context of other, used fragments. \nThe produced target code fragment would re.ect these used fragments, that is, it would re.ect the compilation \nenvironment in which it was created. An application would be put together through safe link\u00ading of target \nfragments; linking of target fragments was legal only with target fragments which corresponded to the \ncom\u00adpilation environment in which the former was created. Thus, linking preserved a correspondence between \nthe compilation and the execution environment, and the ensuing application would correspond to a globally \ncompiled one, and have the same type safety guarantees. In recent years, Java and C. have adopted the \nseparate compilation approach, however combined with dynamic link\u00ading, whereby fragments (in this case, \nclasses in binary form) are loaded lazily at run-time. Thus, dynamic linking does not attempt to preserve \na correspondence between the com\u00adpilation and the execution environment, nor does the en\u00adsuing application \ncorrespond to a globally compiled one; type safety can only be achieved through runtime veri.ca\u00adtion \nchecks. Thus, we argue that in Java (and C. too)there is a clash of philosophy between compilation and \nexecution. Namely, the adoption of separate compilation means that the target fragments re.ect the compilation \nenvironment in which they 1Separate compilation should not be confused with indepen\u00addent compilation, \nintroduced by FORTRAN II, which does not use type information from the used fragments, and thus does \nnot guarantee type-safety [15]. were created, while the adoption of dynamic linking means that there \nis no correspondence between compilation and execution environment. For example, compilation of the source \nmethod declara\u00adtion mds: Em(B x){ return x.f1.f2; } in an environment .1 containing class B with .eld \nf1 of type C,and class C with .eld f2 of type E, generates bytecode mdb 1 with annotations which re.ect \nthe classes where .elds were found and their types, that is: Em(B x){ return x[B.f1 C][C.f2 E]; } On \nthe other hand, compilation of mds in an environment .2 containing a class B with a .eld f1 of type D,and \na class D with a .eld f2 of type F,for some F subclass of E, generates a di.erent bytecode mdb 2: Em(B \nx){ return x[B.f1 D][D.f2 F] } More importantly, execution of mdb 1 in the environment .2 will throw \na FieldNotFoundException, even though compila\u00adtion and subsequent execution of mds in the environment \n.2 would be successful.2 Thus, given the lazy nature of Java dynamic linking, sepa\u00adrate compilation is, \nin some sense, too eager, and too context dependent. In this paper, we consider, instead, compositional \ncompi\u00adlation, whereby target fragments do not re.ect the compi\u00adlation environment in which they were \ncreated, while link\u00ading produces an application which corresponds to a globally compiled one, and which, \ntherefore, has all its type safety guarantees. We de.ne compositional compilation to be the ability to \ntypecheck source code fragments in isolation, to gener\u00adate corresponding binaries, and to link together \nfragments whose mutual assumptions are satis.ed, without reinspect\u00ading the code. We illustrate a new \napproach to compilation and linking for Java-like languages, which will support compositional compilation. \nWe propose a polymorphic form of bytecode containing type variables (ranging over class names)and equipped \nwith a set of constraints involving type variables. Thus, polymorphic bytecode provides a representation \nfor all the (standard Java)bytecode that can be obtained by replacing type variables with class names \nsatisfying the as\u00adsociated constraints. In terms of our example, mds canbe compiledinisola\u00adtion; the \nset of polymorphic constraints associated with mds is { f(B,f1,a),f(a,f2,\u00df),\u00df = E },where a, '\u00df are type \nvariables, and a constraint of the shape f(t,f,t)expresses that type t is expected to declare or inherit \na .eld f of type ' t. Furthermore, the following polymorphic bytecode mdb would be generated: Em(B x){ \nreturn x[B.f1 a][a.f2 \u00df]; } Our approach also supports linking, which checks whether the polymorphic \nbytecode of the various fragments satis.es 2This example shows, in a sense, the most simple case of dependency \nof generated bytecode on the context; Java fea\u00adtures such as method overloading and .eld hiding complicate \nmatters even further, but the essence of the problem remains the same. each other s requirements, without \ninspecting the code it\u00adself. The process involves the replacement of some type variables by concrete \nclass names. In our example, linking mdb in the environment .1 leads to mdb 1, linking mdb in the environment \n.2 leads to mdb 2. The rest of the paper is organized as follows. In Section 2 we de.ne a schema formalizing \nglobal and compositional compilation, introduce the notions of soundness and com\u00adpleteness of compositional \ncompilation w.r.t. global compi\u00adlation, and give su.cient conditions for guaranteeing them. These conditions \nplace requirements on the linking process, and on the relation between global and compositional com\u00adpilation \nof one class. In Sections 3 and 4 we instantiate the schema to model global compilation and compositional \ncom\u00adpilation for a small Java-like language [9]. In Section 5 we give an algorithm for linking which \nsatis.es the properties required by the theorems in Section 2. Finally, in Section 6 we discuss related \nwork and in the Conclusion applicability of our approach and further work. A preliminary version of the \nmaterial from this paper ap\u00adpeared in [1]. Proofs of the main results can be found in an extended version \nof this work [2].  2. FORMALIZING COMPILATION In this section we de.ne a schema formalizing both global \nand compositional compilation. We start by listing the basic syntactic categories and judg\u00adments such \na type system should de.ne. We use a Java\u00adoriented terminology, since a signi.cant class of languages \non which the schema could be instantiated are Java-like (in particular, in the next sections we present \nan instance which de.nes global and compositional compilation for Feather\u00adweight Java [9]). However, \nthe schema is much more general, and is appropriate for any language where, roughly speak\u00ading, generated \nbinary code is context-dependent. Hence, class below can be thought of, in general terms, as lan\u00adguage \nentity . Source and binary class declarations (s and b).  Source fragments (S), which are sequences \nof source class declarations; and binary fragments (B),which are sequences of binary class declarations. \n Class type environments (.), which are sequences of class type assignments (d). A class type assignment \ncan be thought of as the type information which can be extracted from a class declaration (hence the \nmetavari\u00adables . and d); thus a class type environment corre\u00adsponds to a sequence of source class declarations \nde\u00adprived of bodies.  Global compilation (of a class), . hg s : d | b,to be read: The source class declaration \ns has type d and compiles to b in the class type environment ..  Type constraint environments (G), which \nare sequences of type constraints (.). A type constraint expresses expectations from used classes, e.g., \nthat a given class has a .eld of a given type.  Compositional compilation (of a class), hc s : d | G \n| b, to be read: The source class declaration s has type d and compiles to b under the type constraints \nin G.  Linking, . h G | B . G ' | B ' ,to be read: In the class type environment . thetypeconstraints \nG are simpli.ed into G ' , and the binary fragment B becomes B ' . Empty class type environments and \nempty type constraint environments will be denoted by .. The ingredients from above model two di.erent \napproaches to compilation. In the .rst approach, code fragments are compiled in the context of full type \ninformation on other fragments (formal\u00adized by the class type environment .), as shown by the rules in \nFig.1. The global compilation (of a fragment)judgment . ' hG S : . | B means that in . ' the fragment \nS has type . and compiles to B.Here . ' represents (full)type information related to classes which are \nnot being compiled, such as libraries. In particular, . hG S : . | B models the compilation of a self-contained \nfragment. .d hg s : d | b (g-frag1) . hG s : d | b ..1 ... .i-1 .i+1 ... .n hG Si : .i | Bi .i . 1..n \n (g-frag2) n = 2 .hG S1 ... Sn : .1 ... .n | B1 ... Bn Figure 1: Global compilation of a fragment In \nthe second approach, code fragments can be compiled in isolation producing binary code equipped with \ntype con\u00adstraints (both the binary code and the type constraints might contain type variables denoting \nyet unknown classes). Then, it is possible to link together a successfully compiled collec\u00adtion of fragments, \nobtaining, if their mutual requirements are compatible, a new binary fragment with simpli.ed type constraints. \nNotice that this check does not depend on the source code. This is shown by the rules in Fig.2. The com\u00adpositional \ncompilation (of a fragment)judgment h C S : . | G | B means that the source fragment S has type . and \ncompiles to B under the type constraints in G. hc s : d | G ' | b ' d h G ' | b ' . G | b  (c-frag1) \nhC s : d | G | b hC Si : .i | G ' | B ' .i . 1..n ii .1 ... .n h G ' | B ' . G | B n = 2 (c-frag2) \ni.1..n ' ' '' hC S1 ... Sn : .1 ... .n | G | B (G,B )= . (Gi, Bi) Figure 2: Compositional compilation \nof a fragment In rule (c-frag2), we assume an operator . which, given a se\u00adquence of (at least two)pairs \nconsisting of a type constraint environment and a binary fragment, gives a new pair, intu\u00aditively obtained \nby combining them avoiding interferences (typically, this operator will eliminate clashes in type vari\u00adables, \nthrough a-renaming.) Iterating this process, we will eventually obtain a fragment for which no type constraints \nare left, that is, a judgment hC S : . | . | B. This means that we have obtained a self\u00adcontained fragment. \nIn this case, we expect to have obtained the same result as global compilation, that is, compositional \ncompilation to be sound w.r.t. global compilation, and con\u00adversely, that is, compositional compilation \nto be complete w.r.t. global compilation. As a .rst approximation, sound\u00adness and completeness could \nbe expressed as follows: hC S : . | . | B if and only if . hG S : . | B. However, since compositional \ncompilation is obviously ex\u00adpected to be incremental, and since global compilation al\u00adlows for the import \nof some library classes, whose binary may be available, but whose source may not be available, the claim \nabove should be generalized in order to deal with open source fragments, that is, fragments where some \nneeded class is missing. We say that a class type environment . is consistent (w.r.t. global compilation)if \n. hG S : . | B for some S, B. 3 De.nition 1. We say that compositional compilation is sound w.r.t. global \ncompilation i. for consistent . ' .: hC S : . | G | B,and . ' .h G | B. . | B ' imply . ' hG S : . | \nB ' . We now state su.cient conditions for soundness. These conditions (and analogously those which guarantee \ncom\u00adpleteness later on)provide a general schema for proving that compositional compilation is sound (resp. \ncomplete). Indeed, they allow to split the proof in two parts: First, checking that compositional compilation \nof a single class is sound and complete conditions (1)in Theorems 4 and 6. Second, checking that linking \nsatis.es some requirements of well-behaviour conditions (2)and (3)in Theorems 4 and 6. In particular, \nconditions (2)are related to vertical (sequential)composition and conditions (3)to horizontal composition \nof linking steps. Conditions (2)require that, whenever two linking steps in sequence allow to eliminate \nall type constraints, and the latter requires more type in\u00adformation on classes, then starting with this \nricher type in\u00adformation the two steps can be combined in just one step; conversely, given a linking \nstep which allows to eliminate all type constraints under some type information on classes, if we start \nwith only partial type information it is always pos\u00adsible to perform a partial simpli.cation of type \nconstraints. Conditions (3)require that, whenever a linking step allows to eliminate a combination of \ntype constraint environments, it is always possible to eliminate each component, and con\u00adversely. Finally, \ncondition (4)in Theorem 4 is just a trivial requirement needed to express soundness for closed frag\u00adments \nas a particular case of soundness. Note that, in order to prove soundness and completeness, it is not \nnecessary that linking is well-behaved for all type constraint environments, but only for those which \ncan be obtained through the compilation and linking process. This is formalized by the following de.nition: \nDe.nition 2. Relevant type constraint environments are inductively de.ned by the following clauses: if \nhc s : d | G | b holds for some s,d, b,then G is relevant; 3This de.nition assumes the fact that libraries \nused in global compilation have been obtained by correctly compiling some code. if G is relevant and \n. h G | B . G ' | B ' holds for some ., B, B ' ,then G ' is relevant; i.1..n if G1, ..., Gn are relevant \nand (G,B)= . (Gi, Bi) for some B, B1, ..., Bn,then G is relevant. Fact 3. If hC S : . | G | B holds for \nsome S, ., B,then G is relevant. Theorem 4 (Sufficient conditions for soundness). Compositional compilation \nis sound w.r.t. global compilation if the following conditions hold: 1. hc s : d | G ' | b ' ,and . d \nh G ' | b ' . . | b,and . d consistent imply . d hg s : d | b.  2. G ''  relevant, .2 h G '' | B '' \n. G ' | B ' ,and .1.2 h G ' | B ' . . | B imply .1 .2 h G '' | B '' . . | B. i.1..n 3. . h G | B . . \n| B '' ,and (G,B)= . (Gi, Bi) for some B1, ..., Bn and G1, ..., Gn relevant, implies . h Gi | Bi . . \n| B ' i,for some B ' i, for all i .1..n,and B '' = B ' 1 ... Bn' . 4. . h . | B . . | B for all B. De.nition \n5. We say that compositional compilation is complete w.r.t. global compilation i. . ' hG S : . | B ' \nimplies . B, G s.t. hC S : . | G | B and . ' . h G | B . . | B ' . S ::= s1 ... sn s fds ::= ::= class \nc extends c ' { fds mdss }c1 f1; ... cn fn; (c = Object) mdss ::= mds 1 ... mds n mds mh ::= ::= mh {return \ne s;}c0 m(c1 x1 ... cn xn) e s ::= x | e s .f | e s 0.m(e s 1 ... e s n) |new c(e s 1 ... e s n) | (c)e \ns where .eld, method and parameter names in fds, mdss and mh are distinct Figure 3: Source language \nfor the minor di.erence that here class constructors are im\u00adplicitly declared. Every class can contain \ninstance .eld and method declarations and has only one constructor whose pa\u00adrameters correspond to all \nclass .elds (both inherited and declared)in the order of declaration. In class declarations we assume \nthat the name of the class c cannot be Object. Method overloading and .eld hiding are not supported. \nEx\u00adpressions are variables, .eld access, method invocation, in\u00adstance creation and casting; the keyword \nthis is considered a special variable. Finally, in order to simplify the presenta\u00adtion, we assume .eld \nnames in fds, method names in mdss , parameter names in mh to be distinct. In Fig.4 we give the syntax \nof bytecode generated by global compilation that is (an abstraction of)standard Theorem 6 (Sufficient \nconditions for completeness). Compositional compilation is complete w.r.t. global compi\u00adlation if the \nfollowing conditions hold: 1. . d hg s : d | b implies . b ' , G ' s.t. hc s : d | G ' | b ' and . d \nh G ' | b ' . . | b. 2. G '' relevant and .1 .2 h G '' | B '' . . | B imply . G ' , B ' s.t. .2 h G '' \n| B '' . G ' | B ' and .1 .2 h G ' | B ' . . | B. 3. Gi relevant and . h Gi | Bi . . | Bi' ,for i .1..n,with \ni.1..n . (Gi, Bi)=(G, B),imply . h G | B . . | B ' 1 ... Bn' . Note that theorems 4 and 6 imply soundness \nand com\u00adpleteness for closed fragments. Namely, if we take . ' = .= G, applying (4)from theorem 4 we \nget soundness for closed fragments: hC S : . | . | B implies . hG S : . | B. On the other hand, for . \n' =., if there exist B, G s.t. h C S : . | G | B and . h G | B . . | B ' ,we get hC S : . | . | B ' by \napplying rule (c-frag2), and hence we obtain completeness for closed fragments: . hG S : . | B implies \nhC S : . | . | B.  3. FJ GLOBAL COMPILATION In this section, we formalize global compilation of a small \nJava-like language. This models both standard type check\u00ading for Java-like languages (see, e.g., [9, \n16]), as well as bytecode generation (as already in, e.g., [4, 8]). The syntax of the (source)language \nis de.ned in Fig.3. It is basically Featherweight Java [9] (FJ in the sequel)hence a functional subset \nof Java with no primitive types, except Java bytecode. B ::= b1 ... bn b ::= class c extends c ' { fds \nmdsb } mdsb ::= md1 b ... mdb n mdb ::= mh {return e b;} bb' b ' bb e ::= x | e [c.f c ] | e0[c.m(\u00afc)c \n](e1 ... en) bb b | new [cc\u00af](e1 ... en) | (c)e c\u00af::= c1 ... cn where fds and mh are de.ned in Fig.3 \nand method names in mdsb are distinct Figure 4: (Abstract) standard bytecode Our notion of bytecode is \nabstract, since the only di.erences between source code and bytecode of interest here are the annotations \nneeded by the JVM veri.er recall that in Java bytecode a .eld access is annotated with the static type \nof the receiver and the type of the .eld, a method invocation with the static type of the receiver, the \ntype of the parameters and the return type, and an instance creation with the type of the parameters. \nIn Fig.5 we de.ne class type assignments. A class type as\u00adsignment collects the type information needed \nfor compiling other classes which can be extracted from a class declara\u00adtion; it is a 4-tuple consisting \nof the name of the class, the name of the parent class, the set of .eld signatures (type andname of declared.elds)andthe \nset ofmethodsigna\u00adtures (return type, name and parameter types of declared methods). We assume the existence \nof a function type extracting type ' d ::= (c,c ,fss,mss) fss ::= {fs1,...,fsn} fs ::= c f mss ::= {ms1,...,msn} \nms ::= c m(\u00afc) Figure 5: Class type assignments information from a source class declaration. So we will \nwrite type(fds)and type(mdss)to denote the set of .eld signatures and the set of method signatures extracted \nfrom the .eld declarations fds and from the method declarations mdss ,re\u00adspectively. The straightforward \nde.nition of type has been omitted. The typing rules de.ning global compilation of a class are given \nin Fig.6. They are standard rules analogous to those given in other type systems for Java-like languages \n[9, 8, 4]. We use the following auxiliary judgments: .; c hg mdss : mdsb, meaning that method declara\u00adtion(s) \nmdss in class type environment . and current class c (needed for assigning the right type to this) compile(s)to \nmdsb . sb s .; . hg e : c |e , meaning that expression e in class type environment . and local type environment \n. (which maps this and method parameters to class names)has type c and compiles to e b . In rule (g-class), \nfor compiling a class c in a class type environment . we check that . is well-formed (judgment hg .o), \nand compile each method body in . and current class c. A class type environment is well-formed if there \nare no multiple type assignments for the same class name, the inheritance relation is acyclic, each extended \nclass is avail\u00adable, there is no .eld hiding, the Java rule on overriding is respected and there is no \noverloading (the last two condi\u00adtions correspond to the requirement that a class may not declare a method \nwith the same name and di.erent return or parameter types as an inherited method). Note, how\u00adever, that \na class which is only used as a type may not have an assignment in .. This de.nition of well-formedness \nex\u00adactly models the checks which Java compilers perform on the needed compilation context.The formal \nde.nition of hg .o can be found in [2]. It is easy to see that the notion of well-formed class type environment \nis the concrete version in the FJ case of the gen\u00aderal notion of consistent class type environment introduced \nin Section 2 (see [2] for the details). In rules for compiling expressions, we use an auxiliary judgment \nof the form . h., meaning that in the class type environment . thetypeconstraint . holds. Type con\u00adstraints \nare listed in Fig.7. They have the following informal meaning: c =c ' means c is a subtype of c ' . \n .c means c is de.ned .  f(c,f,c ' )means c provides .eld f with type c ' .  . ::= c =c ' |.c ' |f(c,f,c \n' ) |\u00b5(c,m,\u00afc,(c ' ,\u00afc ' )) |.(c,\u00afc,\u00afc ) Figure 7: Type constraints \u00b5(c,m,\u00afc,(c ' ,c\u00af' )) means c provides \nmethod m appli\u00adcable to arguments of type \u00afc, withreturntype c ' and parameters of type \u00afc ' .  .(c,c\u00af,c\u00af' \n)means c provides constructor applicable to arguments of type \u00afc, with parameters of type \u00afc ' .  ' \n' ' Note that both the constraints \u00b5(c,m,\u00afc,(c ,\u00afc )) and .(c,\u00afc,c\u00af) implicitly include the constraint \n\u00afc =c\u00af' . The rules de.ning the judgment . h. (in Fig.8)are in\u00adtuitive and almost self-explanatory. In \nrule (f-2), the side condition f .fss means that f is not declared in fss;analo\u00adgously, in rule (\u00b5-2), \nm .mss means that m is not declared in mss. The type constraints in Fig.7 and the rules in Fig.8 are \nessentially a subset of those de.ned in [5] (where type constraints were called local type assumptions). \nThe rules for the compilation of a class in Fig.6, together with the general rules for the global compilation \nof a frag\u00adment, given in Fig.1, provide an instantiation to FJ of the global compilation schema introduced \nin Section 2.  4. FJ COMPOSITIONAL COMPILATION In this section we formalize compositional compilation \nfor the small Java-like language introduced in Section 3. Classes are compiled in isolation into polymorphic \nbytecode. That is, bytecode where the annotations may contain type vari\u00adables denoting names of yet unknown \nclasses. The syntax of polymorphic bytecode is described by the .rst four produc\u00adtions in Fig.4 (de.ning \nbinary fragments, class declarations, method sequences, and methods, respectively)and by the productions \nin Fig.9 (de.ning binary expressions). b bbb e ::= x |e b[t.f t ' ] |e0[t.m(t\u00af)t ' ](e1 ...e ) n bbb \nb |new [ct\u00af](e1 ...en) |(c)e |\u00abc,t\u00bbe t ::= c | a t\u00af::= t1 ...tn Figure 9: Polymorphic bytecode (expressions) \nBesides the presence of type variables, the only di.erence be\u00adtween polymorphic and standard bytecode \nis the presence of the polymorphic casting annotated expression; if the type variable a is substituted \nwith c ' ,then \u00abc,a\u00bbe b can be specialized either into e b,if c ' =c holds (casting-up), or into (c)e \nb,if c =c ' holds (casting-down), or into \u00abc,c ' \u00bbe b if nothing can be said about c ' =c and c =c ' \n.For the polymorphic casting annotation we use a di.erent nota\u00adtion (double angle brackets rather than \nparentheses)since this annotation is only allowed in polymorphic bytecode. Polymorphic bytecode comes \nwith a sequence of polymor\u00adphic type constraints, which involve type variables and class names. These \nare listed in Fig.10. As for polymorphic byte\u00adcode, the meta-variable t denotes either a type variable \nor a class name. Besides the presence of type variables, the only hg .o .; c hg mdss : mdsb type(mdss)= \nmss (g-class) '' ' . hg class c extends c {fds mdss} :(c, c , fss, mss) | class c extends c {fds mdsb} \ntype(fds)= fss .; c hg mds i : mdb i .i . 1..n (g-methods) n =1 .; c hg mds 1 mds : 1 ... mdb ... n mdb \nn s ' b .; x1:c1 ... xn:cn, this:c hg e : c | e . hc ' = c0 (g-method) .; c hg c0 m(c1 x1 ... cn xn) \n{return es;} : c0 m(c1 x1 ... cn xn) {return eb;} . h.ci .i . 0..n . hx : c .; . hg e s : c | e b ' \n(g-parameter) (g-.eld access) . hf(c, f, c ) .; . hg x : c | x .; . hg es .f : c ' | eb[c.f c '] .; . \nhg e s 0 : c0 | e b 0 .; . hg e s : ci | e b .i . 1..n i i (g-meth call) . h\u00b5(c0, m, (c1,..., cn), \n(c, \u00afc)) ss bb .; . hg e0.m(e1,..., es ): c | e[c0.m(\u00afc)c](e0,..., eb ) .; . hg ei cii n0 n s : | e \nb .i . 1..n (g-new) . h.(c, c1 ... cn, c\u00af) .; . hg new c(es 1 ... es ): c | new [cc\u00af](eb 1 ... eb ) \nn n s ' b s ' b .; . hg e : c | e .; . hg e : c | e ' ' (g-downcast) . hc = c (g-upcast) . hc = c .; \n. hg (c)es : c | (c)eb .; . hg (c)es : c | eb Figure 6: Global compilation ' ''' . ::= t = t |.c | f(t, \nf, t ) | \u00b5(t, m, t\u00af, (t , t\u00af)) | .(c, t\u00af, t\u00af' ) | c ~ t Figure 10: Polymorphic type constraints di.erence \nbetween the polymorphic type constraints and the type constrains listed in Fig.7 is the presence of the \nlast con\u00adstraint in Fig.10, whose informal meaning is the following: c ~ t means c and t are comparable \n(this constraint will be generated when compiling a cast). Polymorphic type constraints not containing \ntype variables will be called monomorphic type constraints. The rules de.ning the judgement for compositional \ncom\u00adpilation of classes are given in Fig.11. We use the following auxiliary judgments: c hc mdss : G \n| mdsb, meaning that method declara\u00adtion(s) mdss in current class c (needed for assigning the right type \nto this)compile to mdsb under the poly\u00admorphic type constraints in G. s s . hc e : t | G | e b, meaning \nthat expression e in lo\u00adcal type environment . (which maps this and method parameters to class names)has \ntype t and compiles to e b under the polymorphic type constraints in G. The intuition behind the compositional \ncompilation rules is that they extract the polymorphic type constraints G nec\u00adessary to compile a given \nsource fragment into a certain polymorphic binary fragment. However, note that the rules do not check \nwhether the inferred collection of constraints G is actually satis.able; in\u00addeed, for any fragment it \nis possible to derive a judgment, even for those that are not statically correct. Consistency checks \nare performed by the rule for the linking judgment (see below). This approach has the advantage that \nthe typ\u00ading rules for separate compilation are very simple and can be implemented in a straightforward \nway. Note also that in the type system a unique judgment can be derived for any class declaration (the \nproof is immedi\u00adate); therefore, we can easily de.ne a type inference algo\u00adrithm, that is, an e.ective \nway for deducing just from the single declaration of a class c the type and the (polymor\u00adphic)bytecode \nof c, and the required type constraints. This is not possible for the systems in [4, 5, 3], where one \nneeds to know the environment where c is compiled. We now de.ne the linking judgment . h G | B . G ' \n| B ' . Linking a fragment of polymorphic bytecode B,equipped with polymorphic type constraints G,ina \ngivenclass type environment ., amounts to .nding a suitable substitution s mapping the type variables \ninto class names. The substi\u00adtution s instantiates some polymorphic type constraints in G into monomorphic \ntype constraints that hold in .,and in\u00adstantiates variables in B correspondingly; these constraints can \nbe eliminated, leaving only the constraints in G ' .In particular, when all constraints are eliminated, \nwe obtain a fragment of standard bytecode (like the one produced by global compilation). Instantiation \nof G w.r.t. substitution s is denoted by s(G); we have omitted the trivial inductive de.nition which \ncoin\u00adcides with conventional variable substitution. Instantiation of B w.r.t. . and s is denoted by Is \n.(B); . is needed for . h. .. .G (G)(.)(.-Obj) . hG., (c, c ' , fss, mss) h.c . h.Object ., (c1, c2, \nfss, mss) hc2 =c3 (=-re.) (=-trans) (=-Obj) . hc =c . hc1 =c3 . hc =Object ' ''' '' ., (c, c , fss, \nmss) hf(c , f, c ) (f-1) c f .fss (f-2) f .fss ' '' ) ' '' ) ., (c, c , fss, mss) hf(c, f, c ., (c, c \n, fss, mss) hf(c, f, c ., (c, c ' , fss, mss) hci =c '' i .i .1..n '' '''' (\u00b5-1) c m(c1 ... c ) .mss \n'' ' '' '' ., (c, c , fss, mss) h\u00b5(c, m, c1 ... cn, (c , c1 ... cn)) n ' ' '''' ., (c, c , fss, mss) \nh\u00b5(c , m, \u00afc, (c , c\u00af)) (\u00b5-2) m .mss ' '' '' ., (c, c , fss, mss) h\u00b5(c, m, c\u00af, (c , c\u00af)) ' ''' ., (c, \nc , fss, mss) h.(c , c1 ... ck, c1 ... ck) ., (c, c ' , fss, mss) hci ' =ci .i .k +1..n (.-1) (.-2) fss \n= {ck+1 fk+1,..., cn fn}. h.(Object,,) ., (c, c ' , fss, mss) h.(c, c1 ' ... cn' , c1 ... cn) Figure \n8: Entailment judgement . h. (rules for the type constraints in Fig.7) . hc =c ' . hc ~c ' (~-1) (~-2) \n. hc ~c ' . hc ' ~c Figure 12: Entailment judgement . h . (rules for the type constraint c1 ~c2) dealing \nwith the case \u00abc, t\u00bbe b: Is b .(\u00abc, t\u00bbe )= Is b'' < .(e )if s(t)= c and . hc =c (c)Is b'' .(e )if s(t)= \nc and . hc =c : b \u00abc,s(t)\u00bbIs )otherwise. .(e In all other cases instantiation of polymorphic bytecode \ncor\u00adresponds to variable substitution. Remark. Note that the ability of instantiating polymorphic bytecode \ninto di.erent kinds of standard bytecode instruc\u00adtions is a key feature for dealing with important issues, \nsuch as resolution of Java syntax ambiguities (see the Conclusion for an example of such ambiguities)and, \nin a wider context, code optimization. The fact that the monomorphic type constraint . holds in the class \ntype environment . is expressed by the judgement . h., which is de.ned by the rules in Fig.8 and in Fig.12. \nhc .o . hG .ls s |G ' (c-linking) . hG |B . G' |Is (B) . Figure 13: Linking Fig.13, which is parameterized \nw.r.t. a linking-simpli.cation relation .ls . A linking-simpli.cation relation models a par\u00adticular way \nof .nding suitable substitutions for simplifying type constraints w.r.t. class type environments. The \nformal de.nition of hc .o(well-formed type environ\u00adments for compositional compilation)can be found in \n[2]. The judgment hc .o is more liberal than hg .o, since it allows extended classes to be unde.ned in \n.. Indeed, the check hg .o in global compilation (rule (g-class)) models the behaviour of standard Java \ncompilers. On the other hand, the premise hc .oin rule (c-linking)corresponds to an intrinsic notion \nof consistency, and expresses that some additional constraints on each compiled class c are satis\u00ad.ed \nin ., that is, that there is no other declaration for c, that the parent class does not have con.icting \n.eld/method declarations, and that the parent class is not a subtype of c. These constraints could be \nequivalently generated dur\u00ading compositional compilation of class c, as done in [4, 5, 3]; here we preferred \na more compact and e.cient formu\u00adlation. Note that for FJ the check of .c constraints could also be moved \nto be part of well-formedness of class type en\u00advironment, since used classes are always mentioned in \n.eld or method declarations; but this is not true in general, for instance if we have local variables. \nThe rules for the compilation of a class in Fig.11 and the rule for linking in Fig.13, together with \nthe general rules for the compositional compilation of a fragment, given in Fig.2, provide an instantiation \nto FJ of the compositional compilation schema introduced in Section 2. In this case the operator .used \nin rule (c-frag2)in Fig.2 in Section 2 just corresponds to pairwise concatenation of sequences (of constraints \nand binary fragments, respectively)with proper a-renaming in order to avoid con.icts of type variables. \nNote that all the type variables occurring in a compo\u00adsitional compilation judgement are (implicitly)universally \nquanti.ed. In fact, in a class compilation judgement h c s : d |G |b, the triple d |G |b represents all \nthe standard binary class declarations of the form Is (b), for some class .. . The linking judgement \nis de.ned by rule (c-linking)in c hc mdss : G |mdsb type(mdss)= mss (c-class) ''' ' hc class c extends \nc {fds mdss} :(c, c , fss, mss) |G, .c |class c extends c {fds mdsb} type(fds)= fss c hmds : Gi |mdb \n.i .1..n c ii (c-methods) n =1 c hmds ... mds : G1 ... Gn |md1 b ... mdb c 1 nn x1:c1 ... xn:cn, this:c \nhc e s : t |G |e b (c-method) i.0..n c hc c0 m(c1 x1 ... cn xn) {return es;} : G, t =c0, .ci |c0 m(c1 \nx1 ... cn xn) {return eb;} . hx : c . hc e s : t |G |e b (c-parameter) (c-.eld access) a fresh . hc x \n: c |. |x. hc es .f : a |G,f(t, f,a) |eb[t.f a] . hc e s 0 : t0 |G0 |e b 0 . hc ei s : ti |Gi |ei b \n.i .1..n (c-meth call) \u00df,\u00afa fresh ss bb . he1 ... es ): \u00df |G0G1 ... Gn,\u00b5(t0, m, t1 ... tn, (\u00df, a\u00af)) |e[t0.m(\u00afa)\u00df](e1,..., \neb ) c 0.m(en0n . hc ei s : ti |Gi |ei b .i .1..n (c-new) a\u00affresh . hc new c(es 1 ... es ): c |G1 ... \nGn,.(c, t1 ... tn,a\u00af) |new [c a\u00af](eb 1 ... eb ) nn . hc e s : t |G |e b (c-cast) . hc (c)es : c |G, c \n~t |\u00abc, t\u00bbeb Figure 11: Compositional compilation type environment . ' and substitution s such that \nhc . ' .o and . ' . hs(G). We prove now that, under suitable hypothesis on the linking\u00adsimpli.cation \nrelation, the compositional compilation which we de.ned for FJ can be safely used in place of global \ncom\u00adpilation, that is, is sound and complete w.r.t. global compi\u00adlation in the sense of Def.1 and Def.5 \nin Section 2. We start by stating some properties of entailment which will be needed in the proof and \nhold independently of the linking-simpli.cation relation we choose. Let s and s ' be two substitutions, \nthat is, .nite mappings from type vari\u00adables to class names. Then ss ' denotes the unique substi\u00adtution \ns.t. (ss ' )(G)= s(s ' (G)) for all G; the empty substi\u00adtution is denoted by . Finally, G \\G ' denotes \nthe sequence of constraints obtained by removing from G all constraints in G ' , while Vars(G)(resp. \nVars(b)) denotes the set of type variables appearing in G (resp. in b). Proposition 7. If hg . do, . \nd hs(G), then for all s, b : s hc s : d |G |b implies . d hg s : d |I. d(b). Proposition 8. If . d hg \ns : d | b, then there exist s, G, b ' s.t. dom(s) .Vars(G),and s hc s : d |G |b ' , . d hs(G), b = I. \nd(b ' ). Proposition 9 (Weakening of entailment). . hG implies .. ' hG. Proposition 10. hc .1.2oimplies \nhc .1o. Note that Prop.10 does not hold for the judgment hg .o de.ning well-formed type environments \nfor global compila\u00adtion; indeed, hg .oholds only if the class hierarchy in . is (upward)complete. In \norder to establish assumptions in Theorem 4 and The\u00adorem 6, we require the simpli.cation relation to \nsatisfy the properties listed in Theorem 11 below, which have the fol\u00adlowing informal meaning. . ls -sound \nguarantees that the simpli.cation step is sound, in the sense that, after applying the given substitution, \nit actually eliminates only type constraints which hold in the current class type environment. . ls \n-complete-1 guarantees that, if . contains enough type information to satisfy all type constraints in \nG,then this simpli.cation step must be possible in .ls . . ls -complete-2 handles the case in which \nthere is not enough type information in a class type environment, say .2, to guarantee that all constraints \nin G hold. However, if it is possible to eliminate these type con\u00adstraints in a larger class type environment \n.1 .2,then it must be possible to partially simplify G in .2,ob\u00adtaining G ' .  Note that the last requirement \nallows many di.erent strate\u00adgies for .ls including the strategy where simpli.cation just does nothing \n(G ' = G in the above)until the class type environment contains su.cient information to simplify all \ntype constraints, in which case it applies all the sub\u00adstitutions. However, algorithms implementing .ls \nshould attempt to .nd as many simpli.cations as possible at any step. We will present such an algorithm \nin the next section. Theorem 11. If the linking-simpli.cation relation .ls satis.es the following properties: \n.ls -sound G relevant and hc .oand . hG .ls s |G ' imply dom(s) .Vars(G) and G ' .s(G) and . hs(G) \\G \n' . .ls -complete-1 G relevant and hc .o and . h s(G) and dom(s) . Vars(G) imply . h G .ls s | .. .ls \n-complete-2 G relevant and hc .1 .2o and .1 .2 h G .ls s | . imply . G ' ,s ' ,s '' s.t. (1) .2 h G . \nls s ' | G ' ,(2) .1 .2 h G ' .ls s '' | .,and (3) s = s ' s '' . Then, compositional compilation of \nFJ is sound and com\u00adplete w.r.t. global compilation.  5. A LINKING ALGORITHM In this section we describe \na particular linking algorithm, thus making rule c-linking e.ective, and we sketch a proof that this \nalgorithm is a correct implementation of the .ls relation. We start with some basic de.nitions which \nspecify theproblem we areaimingtosolve. 5.1 Basic de.nitions Unless speci.ed, in this section we will \nonly consider type environments . s.t. hc .o, that is, possibly open envi\u00adronments with no multiple type \nassignments for the same class name, no inheritance cycles, no .eld hiding and no bad method overriding. \nFurthermore, when more convenient, we will treat . and G as the sets of their elements (regardless possible \nrepetitions in G), and use the standard set theory notations. As a .rst, rather imprecise attempt, the \nproblem could be informally stated as follows: given a type environment . and a sequence of constraints \nG, .nd the possibly maximal G ' . G s.t. . satis.es G ' ; notethat, sinceweare inter\u00adested in incremental \nlinking, . might not satisfy the whole environment G. A .rst problem with the above statement is that \nsatis\u00adfaction of type constraints is under-speci.ed; e.g., for . = (c, Object, \u00d8, \u00d8)and G = f(c1, f,a),a \n= c (with c = c1),one might be tempted to assert that a = c is satis.ed by . with a = c. Nevertheless, \neven though a = c originally seems like the only possible solution, it cannot be considered valid be\u00adcause \nit is sensitive to extensions to .. For instance, if we take . ' = ., (c1, c, {c1 f}, \u00d8)then we discover \nthat a = c is no longer a valid solution, and that the whole G is satis.ed by . ' with a = c1. In terms \nof the linking process, this means that we would need to backtrack from a = c when adding a class c1 \nas speci.ed by . ' . We now formalize the above reasoning. First, a solution is a substitution s for \ntype variables s.t. . satis.es s(G),that is, . h s(G)is valid. Second, in order to avoid backtracking, \ns must be the unique possible choice (up to inclusion of maps)for all extensions of .. De.nition 12. \nFor substitutions s, s ' ,wesay s . s ' i. dom(s) . dom(s ' ) and for all a . dom(s), s(a)= s ' (a). \nDe.nition 13. Asequence of constraints G has solution s w.r.t. a given . i. 1. . h s(G); 2. .s ' , . \n' :if . . . ' and . ' h s ' (G),then s . s ' .  Fact 14. A G has at most one solution w.r.t. a given \n.. Now that we have formalized the notion of solution, we can consider in more detail the situation where \nG has no solution w.r.t. a given .; as already said, this situation oc\u00adcurs quite naturally when considering \nincremental linking, because . is likely to be incomplete, and thus may contain insu.cient information \nto compute a solution for G.Nev\u00adertheless, the algorithm should be able to identify a subse\u00adquence G \n'' . G s.t. G '' has a solution s w.r.t. .,and perform a simpli.cation step: the constraints G '' are \nremoved in order to avoid unnecessary checks in further linking steps, whereas s is applied to the remaining \nconstraints G \\G '' , thus return\u00ading a sequence G ' . Note that if the algorithm was smart enough, then \nG '' would be maximal, that is, there would not . G ''' . G and G ''' We distinguish two possible situations \nw.r.t. remaining constraints G ' : If there exists no extension of . which gives a solution for G ' , \nthen the algorithm should detect a linking error. In this case, we say that G is inconsistent w.r.t. \n.. Otherwise, linking succeeds, but the constraints G ' still need to be satis.ed, therefore the obtained \nfragment needs to be linked further before execution. In this case, we say that G '' is undetermined \nw.r.t. .. exist a G ''' s.t. G '' has solution w.r.t. .. De.nition 15. Asequence of constraints G is \ninconsis\u00adtent w.r.t. a given . i. for all . ' if . . . ' ,there is no s s.t. . ' h s(G);it is consistent \n(w.r.t. .)otherwise. A sequence of constraints G which is inconsistent w.r.t. . (that is, for all .)is \ncalled inconsistent. Conversely, a sequence of constraints G which is consistent w.r.t. some . (hence, \nw.r.t. . as well)is called consistent. De.nition 16. Asequence of constraints G is determined w.r.t. \n. i. G either has a solution or is inconsistent w.r.t. .;it is undetermined (w.r.t. .)otherwise. De.nition \n17. Asequence of constraints G is determined i. for all .,there exists . ' s.t. . . . ' and G is determined \n w.r.t. . ' ;and is undetermined otherwise.  Proposition 18. The constraint . is determined i. it matches \none of the following patterns: . c, c = c ' , f(c, f, t), \u00b5(c, m, \u00afc, (t, t\u00af)), .(c, \u00afc, \u00aft), c ~ c ' \n. Finally, in order to prove that our algorithm implements a .ls relation satisfying properties .ls -sound, \n.ls -complete\u00ad1, and .ls -complete-2 of Theorem 11 hence, soundness and completeness of compositional \ncompilation w.r.t. global compilation is guaranteed we show that each relevant set of constraints satis.es \na quite intuitive syntactic property, and that for constraint sets which satisfy this syntactic prop\u00aderty \nwe can de.ne an algorithm which satis.es the conditions of Theorem 11. This syntactic property is based \non a topological relation . between constraints, with the following intuitive meaning: if . . . ' ,then \n. has to be processed prior to . ' .For this we de.ne the predicates I(a, .), expressing that a appears \nin an in-position in . that is, needs to have been substituted before . can be processed, and O(a, .)expressing \nthat a appears in an out-position in ., that is, processing . will provide a substitution for this variable. \nI(.), I(G), O(.), O(G)have the obvious meaning, that is, the set of I variables in .,or G,and theset \nof O variables in .,or G. Input: this: a well-formed G argument: a well-formed . Output: if it fails \nthen G is inconsistent w.r.t. . else returns s and transforms G into G ' s.t. G ' = s(G \\G '' ) G '' \n .G  s is the solution of G '' w.r.t. .  for all . .G ' , . has no solution w.r.t. .  Pseudo-code: \nSubs solve(Env .)throws fail{s = . this.topsort () // G must be topologically sorted for each . . this \n{ // according to the order try{ ..apply(s) s ' = ..entailedBy(.) this.remove(.) s.update(s ' ) } catch(undetermined){} \n} return s } Figure 14: Constraint solving algorithm solve De.nition 19. For any G, a,and . we de.ne: \n1. I(a, .) i. . = a = t,or . = t = a,or . = c ~ a, or . = f(a, f, t),or . = \u00b5(t, m, t\u00af, (t ' , t\u00af' )) \nwith a = t or a .t\u00af,or . = .(c, t\u00af, t\u00af' ) with a .t\u00af. 2. O(a, .) i. . = f(t, f,a),or . = \u00b5(t, m, t\u00af, \n(t ' , t\u00af' )) with ' '' a .t\u00afor a = t ' ,or . = .(c, \u00aft, \u00aft ) with a .\u00aft . 3. I(.)= {a |I(a, .) }, I(G)= \n...GI(.), O(.)= {a |O(a, .) }, O(G)= ...GO(.). De.nition 20. The following topological relation is de\u00ad.ned \non type constraints: . .. ' i. O(.) nI(. ' )= \u00d8. De.nition 21. Let .+ denote the transitive closure of \n.. Then a set of constraints G is well-formed i. 1. .. .G : I(a, .)=... ' .G : O(a, . ' ), 2. .. .G \n: . .+ ., ' = . '  3. .., . ' .G : O(a, .) and O(a, . )=. .  5.2 Description of the algorithm The \nJava pseudo-code of the main algorithm is de.ned in Figure 14. The method solve takes a class type environment \n. and returns a substitution; it is declared in the class im\u00adplementing sequences of constraints, therefore \nthis denotes acertain G. When invoked, method solve either throws fail or returns a substitution s and \nsimplify G into G ' . The invocation ..entailedBy(.), will throw the exception fail if a . . G is found \nto be inconsistent w.r.t. . (and hence the whole G is inconsistent as well). The method solve returns \na s, if it has found a subse\u00adquence G '' . G which has solution s w.r.t. ., and has modi.ed G to G ' \nby removing G '' and applying s.We can see that G '' is maximal, by proving that for all . . G ' , . \nhas no solution w.r.t. .. However, while all possible sim\u00adpli.cations are always performed, some inconsistencies \nmay be discovered later on, when some new fragment is linked, mainly because each constraint . .G is \nchecked separately. For instance, given . =(c, Object, \u00d8, \u00d8)and G = c1 = c2, c2 = c1 (with all class \nnames distinct), G.solve(.)re\u00adturns the empty substitution and does not modify G,even though G is clearly \ninconsistent; however, such inconsistency can be captured when performing further linking steps. For \ninstance, if we take . ' = ., (c1, Object, \u00d8, \u00d8)then G.solve(. ' ) throws fail since c1 =c2 is clearly \ninconsistent w.r.t. . ' . The constraints are processed respecting the topological order given in De.nition \n20, so that it is possible to scan G only once without failing to simplify some constraints. To see that \nthe topological sorting is needed, consider for instance G = a = c,f(c, f,a), which is not topologically \nsorted, and . =(c, Object, {c f}, \u00d8). The constraint a =c is processed .rst and kept, since is undetermined \nw.r.t. .. Then the constraint f(c, f,a)is removed (since it has solu\u00adtion a = c); however, the already \nexamined constraint a =c cannot be further instantiated into c =c, and, therefore, is not removed. Therefore \nsolve fails to perform a simpli.\u00adcation step. Finally, note that since G is assumed to be well-formed, \nit can always be topologically sorted. Before being processed, each . is instantiated w.r.t. the current \nsubstituion s. Then, the method entailedBy checks whether . has solution w.r.t. .; if so, it returns \nthe corre\u00adsponding substitution s ' , otherwise it throws either fail,if . is inconsistent w.r.t. ., \nor undetermined if . is undeter\u00admined w.r.t. .. As already explained, fail is propagated by solve, whereas \nundetermined is captured; in this way, the constraint is not removed, the current substitution is not \nupdated, and solve continues with the next constraint. Figure 15 contains pseudo-code for entailedBy \nin the class representing constraints of the form t =t ' (the other cases can be found in [2]). If either \nthe left or right hand side of the constraint is a variable, then the constraint is undetermined, therefore \nthe corresponding exception is thrown. Otherwise the con\u00adstraint is ground and we can check whether it \nis satis.ed by .. If the trivial cases do not apply (re.ection and top type), then we perform an inheritance \ngraph traversal from c1 up to Object which can terminate in three di.erent ways: if c2 is found, then \nthe constraint is satis.ed and we return the empty substitution; if Object is reached without .nding \nc2 then the constraint is inconsistent and fail is thrown; other\u00adwise the traversal stops because method \nsuperclass throws undetermined since some superclass of c1 (c1 included)could not be found in .. In the \nlast case, the exception must be caught since the constraint still could be inconsistent if there exists \nc s.t. c2 = c and c = c1. For this reason a new traversal is started from c2 looking for a superclass \nof c2 (c2 included)contained in the set S of all superclasses of c1 (c1 included)collected during the \n.rst traversal. If such a class is found, then fail is thrown, otherwise (if either superclass throws \nundetermined,or Object is reached) undetermined is thrown. 5.3 Correctness of the algorithm In the sequel, \nlet .ls denote the relation implemented by solve, that is, the relation de.ned as follows: Subs entailedBy(Env \n.)throws undetermined , fail{ // . assumed to be well-formed if this.lhs().var() . this.rhs().var()throw \nundetermined c1 =this.lhs() c2 =this.rhs() if c1.equals(c2) . c2.equals(Object)return . c = c1 S = {c1} \n// will contain all c s.t. c1 = c try { while c = Object{ c = ..superclass(c) S.add(c) if c.equals(c2)return \n. } throw fail // chain complete up to Object } catch(undetermined ){} c = c2 // still could fail while \nc = Object{ c = ..superclass(c) if S.contains(c)throw fail } throw undetermined } Figure 15: De.nition \nof entailedBy for t = t ' . h G .ls s | G ' i. G.solve(.)returns s and transforms G into G ' . The following \npropositions ensure that . ls leads to a sound and complete compositional compilation of FJ w.r.t. global \ncompilation. Proposition 22. Any relevant G is well-formed. Proposition 23. The relation . ls satis.es \nproperties .ls -sound, .ls -complete-1, and .ls -complete-2 of Theo\u00adrem 11 for any well-formed G. Finally, \nnote that Prop. 22 ensures also that solve is only invoked for sequences of constraints which can be \nsorted w.r.t. the topological order . de.ned in De.nition 20.  6. RELATED WORK No formal model for separate \ncompilation and linking had been developed until Cardelli s seminal work in 1997 [7], which can be considered \na milestone in the area. It develops a simple formal framework for separate compilation (which, for the \nsake of simpli.cation, is considered to consist only of typechecking), and linking. This framework can \nbe con\u00adsidered to embody the notion of compositional compilation formalized in the present paper. The \nmain di.erences are that we are also interested in code generation, and that the general framework in \nSection 2 abstracts from a particular programming language, and is parametric in the de.nition of separate \ncompilation and linking judgments. Instead, [7] illustrates the concepts on a simple lambda-calculus, \nand linking just amounts in checking that each used entity has the required type and replacing its name \nby its de.nition. Moreover, [7] did not consider the issue of which prop\u00aderties compositional compilation \nshould satisfy in order to produce the same .nal result as global compilation. These properties correspond \nto some form of soundness and com\u00adpleteness as described in the present paper. They have been .rstly \nintroduced and formalized in [5], within a gen\u00aderal framework for separate compilation and linking espe\u00adcially \nsuited for Java-like languages similar to that intro\u00adduced here. However, the framework in [5] did not \ntake into account possible specialization of bytecode during link\u00ading, hence linking was reduced to inter-checking,that \nis, checking that mutual assumptions on fragments are satis\u00ad.ed. As a consequence, in the instantation \nof the frame\u00adwork presented in [5] (again on Featherweight Java)the code generated by separate compilation \nwas standard Java bytecode, rather than the polymorphic bytecode introduced here; hence, since generated \nbytecode is context-dependent, separate compilation of a class was only possible under some given type \nconstraints (or, equivalently, for each possible re\u00adsulting bytecode). The result in [5] was nevertheless \nimportant, since a type system for a Java-like language was .rstly formally proved to guarantee sound \nand complete inter-checking (or, from an\u00adother point of view, to support principal typings,see below). \nOn the practical side, type systems as that in [5] (see also [4, 3])constitute a good basis for selective \nrecompilation, as exploited for full Java in [11, 12, 14], since it is possi\u00adble to check whether a change \nin a source fragment a.ects other fragments by simply checking that their requirements still hold, but \nnot for type inference, since type constraints needed for compiling a class cannot be inferred by just \nin\u00adspecting its source code. In other words, compositional compilation as meant in this paper (compilation \nof a fragment in isolation)is not possible; type constraints can only be inferred for a given resulting \nbytecode. The di.erence between the present paper and [5] becomes clearer by discussing the relation \nof our approach with the notion of principal typing. According to Wells [17]: atyping for aterm T is \nthe collection of all the infor\u00admation other than T which appears in the .nal judge\u00adment of a proof derivation \nshowing that T is typable, and  (roughly speaking)a typing for a term T is principal if it somehow represents \nall the typings for T .  The paper [17] (see also [10])pointed out that the principal typing property \n(that is, every typable term has a principal typing)plays a key role in compositional type inference. \nIn this paper, as in [5], we have formalized compilation (in\u00adcluding code generation)by means of a type \nsystem. There\u00adfore, in our framework, performing compilation amounts to performing type inference. In \nthe type system in [5], the principal typing property holds by taking as terms pairs consisting of a \nsource and a binary fragment (in other words, bytecode is considered part of the term). Instead, in the \ntype system for compositional compilation proposed in this paper, hC , the principal typing property \nholds by taking as terms source fragments S:a typing is a triple . | B | G (notethat bytecodeisconsidered \npart of the typing)and the system has the principal typing property since, for any source fragment S, \nat most one typing (modulo renaming of type variables)can be derived. 7. CONCLUSION In this paper we \naddressed the problem of supporting compositional compilation for languages (like Java and C) where the \nbinary code depends on the compilation context. For this, we de.ned a schema formalizing global and com\u00adpositional \ncompilation for such languages, and instantiated it by providing algorithms supporting compositional \ncom\u00adpilation for Featherweight Java. To the best of our knowl\u00adedge, this is the .rst compositional compilation \nprocedure for a Java-like language. We believe that the results in this paper can be exploited at least \nin two di.erent ways. Firstly, they can be directly applied to the development of a new generation of \ncompilers/interpreters/linkers (sup\u00adporting compositional compilation)for real languages like Java and \nC. In this approach, polymorphic bytecode would be instantiated eagerly, in a step corresponding to static\u00adlinking. \nSuch compilers would naturally support selective recompilation mechanisms, in the same spirit of [11, \n12, 14]. In this respect, note that the application of our approach to, e.g., full Java, does not pose \nsubstantially new problems, though obviously more and more involved forms of type con\u00adstraints, as we \nbrie.y discuss below. Type constraints mod\u00adeling .eld hiding and method overloading were already pre\u00adsented \n(in the non polymorphic approach)in [4, 5, 3], and are omitted in this paper for simplicity. Roughly \nspeaking, allowing method overloading simply leads to a di.erent in\u00adterpretation of the type constraint \n\u00b5(c, m, c\u00af, (c ' , c\u00af' )), which becomes: for a call of method m with receiver of type c and arguments \nof type \u00afc the most speci.c method has re\u00adturn type c ' and parameters of type c\u00af' (and analogously \nfor .eld hiding). Hence, rule (c-meth-call) in Fig.11 is not a.ected, whereas rules de.ning the entailment \njudgment for this type constraint, that is, (\u00b5-1)and (\u00b5-2)in Fig.8, must change in order to re.ect that \nthe type constraint holds when c ' and \u00afc ' are the return and parameter types of the most speci.c method \nfor the call in the given class type envi\u00adronment. The linking simpli.cation algorithm must change accordingly. \nType constraints modeling most other relevant Java features, such as checked exceptions, accessibility \nlev\u00adels, unreachable code, compile-time constants, are presented in [11, 12, 14]. Finally, in [13] it \nis shown how to deal with another Java peculiar feature, that is, the ambiguity in an expression such \nas A.B.C. 4 Secondly, the results in this paper could lead to the de\u00advelopment of a more .exible run-time \nsupport for Java-like languages, allowing execution of bytecode containing type variables. In this approach, \npolymorphic bytecode would be instantiated lazily, during dynamic linking and loading some initial exploration \nappears in [6]. Further work includes extensions of our polymorphic model to other Java features, adapting \nto the polymorphic case the results mentioned above, and, more interestingly, to F\u00adfounded polymorphic \nmethods and classes as introduced by GJ and Java 1.5. We also plan to investigate the extension of the \nsource language so that it may contain type variables as well. Acknowledgements. We are grateful to the \nanonymous ref\u00aderees for detailed and insightful comments and suggestions, and to to Alex Buckley for \nfeedback. This work has been partially supported by Dynamic Assembly, Recon.guration and Type-checking \n-EC project IST-2001-33477, and by APPSEM II -Thematic network IST-2001-38957. 8. REFERENCES [1] D. \nAncona, F. Damiani, S. Drossopoulou, and E. Zucca. Even more principal typings for Java-like languages. \nIn 6th Intl. Workshop on Formal Techniques for Java Programs 2004, June 2004. [2] D. Ancona, F. Damiani, \nS. Drossopoulou, and E. Zucca. Polymorphic bytecode: Compositional compilation for Java-like languages. \nTechnical report, Dipartimento di Informatica e Scienze dell Informazione, Universit`adi Genova, November \n2004. Extended verson with proofs, available at ftp://ftp.disi.unige.it/pub/person/AnconaD/PBCCJL.pdf. \n[3] D. Ancona and G. Lagorio. Stronger Typings for Smarter Recompilation of Java-like Languages. Journal \nof Object Technology, 3(6):5 25, June 2004. Special issue: ECOOP 2003 workshop on Formal Techniques for \nJava-like Programs. [4] D. Ancona, G. Lagorio, and E. Zucca. True separate compilation of Java classes. \nIn ACM SIGPLAN Conference on Principles and Practice of Declarative Programming (PPDP 02), pages 189 \n200. ACM Press, 2002. [5] D. Ancona and E. Zucca. Principal typings for Java-like languages. In ACM Symp. \non Principles of Programming Languages 2004, pages 306 317. ACM Press, January 2004. [6] Alex Buckley \nand Sophia Drossopoulou. Flexible Dynamic Linking. In 6th Intl. Workshop on Formal Techniques for Java \nPrograms 2004, June 2004. [7] L. Cardelli. Program fragments, linking, and modularization. In ACM Symp. \non Principles of Programming Languages 1997, pages 266 277. ACM Press, 1997. [8] Sophia Drossopoulou \nand Susan Eisenbach. Is the Java Type System Sound? In 11th European Conference on Object Oriented Programming \n(ECOOP 97), volume 1241 of LNCS, pages 389 418. Springer-Verlag, June 1997. [9] A. Igarashi, B. Pierce, \nand P. Wadler. Featherweight Java: A minimal core calculus for Java and GJ. In ACM Symp. on Object-Oriented \nProgramming: Systems, Languages and Applications 1999, pages 132 146, November 1999. [10] T. Jim. What \nare principal typings and what are they good for? In Proceedings of the 23rd ACM SIGPLAN-SIGACT symposium \non Principles of programming languages, pages 42 53. ACM Press, 1996. [11] G. Lagorio. Towards a smart \ncompilation manager for Java. In Blundo and Laneve, editors, Italian Conf. on Theoretical Computer Science \n2003, number 2841 in Lecture Notes in Computer Science, pages 302 315. Springer, October 2003. [12] G. \nLagorio. Another step towards a smart compilation manager for Java. In Hisham Haddad, Andrea Omicini, \nRoger L. Wainwright, and Lorie M. Liebrock, editors, ACM Symp. on Applied Computing (SAC 2004), Special \nTrack on Object-Oriented Programming Languages and Systems, pages 1275 1280. ACM Press, March 2004. [13] \nG. Lagorio. Capturing ghost dependencies in Java sources. Journal of Object Technology, 2004. To appear. \n [14] G. Lagorio. Type systems for Java separate compilation and selective recompilation. PhD thesis, \nDipartimento di Informatica e Scienze dell Informazione, Universit`adi Genova, May 2004. [15] Robert \nSebesta. Concepts of Programming Languages. Addison-Wesley, 2004. Seventh edition. [16] D. von Oheimb \nand T. Nipkow. Java is Type Safe -De.nitely. In ACM Symp. on Principles of Programming Languages 1998, \nACM Press, 1998. [17] J.B. Wells. The essence of principal typings. In International Colloquium on Automata, \nLanguages and Programming 2002, number 2380 in Lecture Notes in Computer Science, pages 913 925. Springer, \n2002. 4For instance, A could be a class, B a static .eld, C a.eld, or A could be a class, B a nested \nclass, C a static .ed, or A could be a package, B a class, and C a.eld.  \n\t\t\t", "proc_id": "1040305", "abstract": "We define <i>compositional compilation</i> as the ability to typecheck source code fragments in isolation, generate corresponding binaries,and link together fragments whose mutual assumptions are satisfied, without reinspecting the code. Even though compositional compilation is a highly desirable feature, in Java-like languages it can hardly be achieved. This is due to the fact that the bytecode generated for a fragment (say, a class) is not uniquely determined by its source code, but also depends on the compilation context.We propose a way to obtain compositional compilation for Java, by introducing a <i>polymorphic form of bytecode</i> containing type variables (ranging over class names) and equipped with a set of constraints involving type variables. Thus, polymorphic bytecode provides a representation for all the (standard) bytecode that can be obtained by replacing type variables with classes satisfying the associated constraints.We illustrate our proposal by developing a typing and a linking algorithm. The typing algorithm compiles a class in isolation generating the corresponding polymorphic bytecode fragment and constraints on the classes it depends on. The linking algorithm takes a collection of polymorphic bytecode fragments, checks their mutual consistency, and possibly simplifies and specializes them. In particular, linking a self-contained collection of fragments either fails, or produces standard bytecode (the same as would have been produced by standard compilation of all fragments).", "authors": [{"name": "Davide Ancona", "author_profile_id": "81100231663", "affiliation": "Universit&#224; di Genova, Genova, Italy", "person_id": "P452362", "email_address": "", "orcid_id": ""}, {"name": "Ferruccio Damiani", "author_profile_id": "81100103019", "affiliation": "Universit&#224; di Torino, Torino, Italy", "person_id": "P344770", "email_address": "", "orcid_id": ""}, {"name": "Sophia Drossopoulou", "author_profile_id": "81100331741", "affiliation": "Imperial College, London, UK", "person_id": "PP39038039", "email_address": "", "orcid_id": ""}, {"name": "Elena Zucca", "author_profile_id": "81100312049", "affiliation": "Universit&#224; di Genova, Genova, Italy", "person_id": "P76352", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1040305.1040308", "year": "2005", "article_id": "1040308", "conference": "POPL", "title": "Polymorphic bytecode: compositional compilation for Java-like languages", "url": "http://dl.acm.org/citation.cfm?id=1040308"}