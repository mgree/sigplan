{"article_publication_date": "01-12-2005", "fulltext": "\n Connecting Effects and Uniqueness with Adoption John Tang Boyland* William Retert* University of Wisconsin \nMilwaukee University of Wisconsin Milwaukee Department of EECS Department of EECS POBox784 POBox784 Milwaukee, \nWI, USA 53201 Milwaukee, WI, USA 53201  boyland@cs.uwm.edu williamr@cs.uwm.edu ABSTRACT Adoption is \nwhen one piece of state is logically embed\u00added in another piece of state. Adoption provides informa\u00adtion \nhiding (the adopter can be used as a proxy for the adoptee) and with linear existentials, provides a \nway to store unique pointers in shared state. In this paper, we give an operational semantics of adoption \nin a simple proce\u00addural language with pointers to records. We de.ne a per\u00admission type-system that uses \nadoption to model both ef\u00adfects and uniqueness. We prove type soundness (well-typed programs don t go \nwrong) and state separation (separately\u00adtyped statements cannot access the same state). Then we show \nhow high-level e.ects and uniqueness annotations can be expressed in the type-system. The distinction \nbetween read and write e.ects is ignored in the body of this paper. Categories and Subject Descriptors: \nF.3.2 [Semantics of Programming Languages] : program analysis General Terms: Languages Keywords: uniqueness, \nadoption, permissions, ownership 1. INTRODUCTION In a previous paper [1], we discussed how the concepts \nof uniqueness and e.ects are interdependent. If one wishes to check uniqueness, it can be best done when \nconsidering e.ects, because read e.ects on a unique variable cannot be permitted while it is temporarily \naliased. Checking e.ects on the other hand may require uniqueness, because an e.ect on a unique object \ncan be transferred to the object that cur\u00adrently has the only unique reference. In retrospect, this in\u00adterdependence \ncould be expected because the better-known problems of data-dependence determination and aliasing are \nsimilarly related. Uniqueness involves an aliasing property and e.ects can be used to determine data \ndependencies. * Work supported in part by the National Science Founda\u00adtion (CCR-9984681) and the NASA/Ames \nHigh Depend\u00adability Computing Program (NCC-2-1298). Permission to make digital or hard copies of all \nor part of this work for personal or classroom use is granted without fee provided that copies are not \nmade or distributed for pro.t or commercial advantage and that copies bear this notice and the full citation \non the .rst page. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires \nprior speci.c permission and/or a fee. POPL 05, January 12 14, 2005, Long Beach, California, USA. Copyright \n2005 ACM 1-58113-830-X/05/0001 ...$5.00. 1.1 Background on Uniqueness Unique references that may occur \nin shared structures can be modeled soundly using destructive reads in which the stored pointer variable \n(often a .eld of an object) is nulli\u00ad.ed atomically with the read of that variable. This solution goes \nback at least to Hogg s Islands [2] and has been vari\u00adously used by Baker [3], Minsky s Ei.el * [4], \nAldrich et al s AliasJava [5] (in their proofs), and Clarke and Wrigstad s External Uniqueness [6]. However, \ndestructive reads have several problems: (1) they make it di.cult to query information about a unique \nobject without losing it; (2) they make it impossible to have sound invariants about the non-nullness \nof unique variables; (3) they are inappropriate for use in const methods, which are supposed to treat \ntheir object as read only; (4) they re\u00adquire a language change. Thus several researchers have in\u00addependently \nproposed the use of what we call borrowing reads, which do not nullify the .eld. Unfortunately borrow\u00ading \nreads greatly impact the bene.ts of uniqueness unless it can be shown that a unique .eld is not read \n(or at least not considered unique) during the lifetime of the borrowing. For example, AliasJava permits \nborrowing without checking for possible reads during the lifetime of the borrow and thus can only guarantee \nthat a unique pointer stored in a .eld will not be also available in another .eld. In particular, a class \ncannot prevent outsiders from modifying the con\u00adtents of supposedly unique sub-objects of instances of \nthis class. Consider Figure 1. The method badBorrow() is able to use its borrowed Point to modify a point \nwhich had been transferred to a Rectangle. In particular, the assignment deforms the Rectangle such that \nthe area() method is no longer correct. A related problem occurs in Vault [7] where one cannot store \nunique ( linear ) values inside shared ( nonlinear ) structures. F\u00a8ahndrich and DeLine solve this problem \nwith adoption and focus [8] without using destructive reads, but rather temporary removal of the rights \nto access data that might be in an inconsistent state. The authors give a type system but no formal statement \nor proof of what properties are preserved by the system. Leino, Nelson and Stata [9, 10] propose a pointer \nprop\u00aderty, virginity, related to uniqueness that is required of all initialization of pivot .elds (.elds \nthat refer to wholly\u00adowned subsidiary objects or sub-objects ). The rules have a similar weakness to \nthat of AliasJava: they are (intention\u00adally) not strong enough to prevent a client of an object from \nhaving access to its sub-objects. Leino and others recent work [11] and strong ownership class Rectangle \n{ group Looks; group Dims in Looks; unique Point tl in Dims ; unique Point br in Dims ; shared String \nnm in Looks = \"\"; Rectangle(unique Point topLeft, unique Point bottomRight) { tl = topLeft; br = bottomRight; \nassert(tl.x < br.x); assert(tl.y < br.y); } accesses Dims int area() { return (br.x-tl.x)*(tl.y-br.y); \n} accesses Looks void setName(shared String n) { nm =n; } } class Point { group Loc; int x in Loc ; \nint y in Loc ; Point(int a,int b) { x=a; y=b; } } class RMaker { unique Point p; RMaker() { p = new \nPoint(0,0); } accesses p unique Rectangle rmake() { unique Point tl = p; p = new Point(0,0); unique \nPoint br = new Point(5,5) return new Rectangle(tl,br) } accesses p Rectangle badBorrow() { borrowed \nPoint q =p; Rectangle r = rmake(); q.x = 17; return r; } } Figure 1: Example of dubious borrowing type \nsystems [12, 13] avoid these aliasing problems by not permitting clients to create objects that will \nbe internal to a container. In essence, the system forbids objects from being transferred from one container \nto another. External unique\u00adness extends ownership to cover transferable uniqueness, but does so through \ntemporary destructive reads. With exter\u00adnal uniqueness, the example in Figure 1 will pass all static \nchecks and crash with a null pointer exception when a null Point is passed to the Rectangle constructor. \nThere is no obvious connection between the uniqueness/borrowing error and the null pointer exception. \nIn our earlier work on alias burying [14], we proposed using e.ects annotations to prevent borrowing \nreads from weakening the semantics of uniqueness. With alias burying, no destructive reads are needed. \nThe paper suggested an\u00adnotating every method with the list of .elds of this or any other object that \nis read during the dynamic extent of the method call. Clearly, this not only exposes too much of ob\u00adject \ns internal structure, but is overly conservative since it does not distinguish di.erent objects. We intended \nto use our object-oriented e.ects system [15] instead, but until this work, no one has been able to come \nup with a satisfactory system to combine these two areas. This paper contributes such a type system, \nbased on adoption and focus, and proves correctness with respect to an underlying semantics. 1.2 Contribution \nWe can check that program accesses meet declared e.ects by using a permission system, in which the context \nused to check program elements indicates which parts of the state we are allowed to access. Fractional \npermissions [16] can be used to distinguish reads from writes, but this paper does not formalize this \naspect. E.ects are in terms of state in the program: variables, and .elds of objects on the heap. For \nencapsulation purposes, we aggregate .elds into data groups [15, 17]. This is modeled by having the permis\u00adsion \nto access the .eld nested within the permission to access the data group. For instance, in Figure 1 the \ne.ects of the area() method reference the Dims data group, which includes the references for both points. \nAs these references are unique, they in turn contain permission for the state of the objects referenced. \nNesting is de.ned by extend\u00ading adoption [8] to permit .ne-grained adoption between .elds (rather than \nbetween objects). The extension also permits multiple (distinct) keys with the same guard to be focused \non as well. In a permission system, there is only one permission for each state. Thus permissions can \nalso be used to model uniqueness: a unique pointer is one which is packaged along with the permission \nto access the state pointed to. This conception of uniqueness is weaker than the usual sense of uniqueness \nin which there are no other pointers to the state in the store. However, in our system, any other potential \npointers to the same state come without permission to access it, and thus even the limited sense of uniqueness \nprovided by permissions is su.cient for analysis purposes. The problem is not the existence of aliasing \npointers, but rather the access of the state through these aliasing pointers. Let s return to the method \nbadBorrow() in Figure 1. The borrowing read of p is legal, as q can borrow p s permission to access the \nstate of the Point object. However, the call to rmake() is annotated with an access of p s state. Therefore, \npermission to access p is passed to rmake() and lost to q. 1 Once q loses the permission it had borrowed \nfrom p,the access q.x becomes statically illegal. Of course not all pointers are unique. A shared pointer \nis modeled by having the permission to access the pointed-to state nested in a globally accessible permission. \nNow, we want to make sure that it is impossible for two separate parts of the code to grab the permissions \nto the same shared state. This could be done using dynamic checks, but in our system we use the type \nsystem to prevent the same permission from being removed twice at the same time. Languages often permit \na null pointer to be used in the place of a pointer to actual state. Our system makes this detail explicit: \nthe permissions associated with a possibly\u00adnull pointer are conditional on the boolean formula that the \npointer is not null. Thus the type system described in this paper has the fol\u00adlowing properties: Permissions \nmodel both e.ects and uniqueness.  The nesting (adoption) of permissions models shared state and aggregation \nof state in data groups.  Permission closures model uniqueness.  Conditional permissions make explicit \nthe use of null or other terminating pointers.  In the following section, we describe this type system, \nand then in Section 3 we show how some of our earlier e.ects an\u00adnotations together with the uniqueness \nannotations of our work on Alias Burying can be interpreted in the system pro\u00adposed in this paper. After \nsome extensions to the type sys\u00adtem are considered in Section 4, Section 5 compares our system to closely \nrelated work.  2. THE SYSTEM We de.ne our type system over a simple low-level imper\u00adative language. \n2.1 Operational Semantics The source language has four kinds of values: the unit value, booleans, integers \nand pointer values (that is, object references): (value) v ::= () | true | false | n | . Here . refers \nto an object reference, an absolute memory address. The only absolute memory address that occurs normally \nin unevaluated programs is $0 the value of null pointers. In this simple language, the only kind of variable \nis the .eld of an object (global variables are handled by treating them as .elds of the null object). \nArray elements could be handled with dependent types [18] in a similar manner. Each .eld f has a declared \ndefault value and type chosen 1Actually, the method also returns a permission to access p, but wrapped \nin an existential, making it impossible to prove that q refers to the same object. In this example, of \ncourse, q does not refer to the same object as p after the call. from the following limited set: vf tf \n() unit false bool 0 int $0 ptr($0) Expressions include values, simple arithmetic (represented by addition), \ncomparisons, allocation, .eld reads and writes, sequential composition, conditionals, procedure calls \nand nesting (adoption): v | e+e| e=e| new{f, ... ,f} | e.f |s::= e.f:=e | s;s| if b then s else s| call \np|nest e.f in e.f A program consists of a mapping of procedure names to procedure expressions. A memory \nconsists of a binding of .elds to their values (a function). We also record adoption (the nesting relation). \n(program) g ::= {p. e,...} (location) l ::= ..f (memory) \u00b5 ::= {l . v,...} (adoption) a ::= {l . l,...} \nThere is no requirement that adoption is a functional rela\u00adtion, although we will require it to be acyclic. \nFigure 2 de.nes a small-step semantics for evaluating this language. The three interesting parts are \n(1) the evaluation of new expressions in which an address is found unused in the memory or adoption information, \nand (2) for writes to .elds, we require that the new value of the .eld be storage compatible with the \ndefault value of the .eld (the relation is de.ned using storage compatibility for types), and (3) nesting \nwhich adds an adoption relation fact. Adoption can never be undone. An actual implementation of a runtime \nsystem would not need to check storage compatibility or track the adoption relation; including these \nproperties here enables us to prove that well-typed programs preserve them.  2.2 Permission Types The \nenvironment E = (.; .) in which code is checked has two parts: a type context . which is a set of address \nvariables r; and a bag (or multiset) of permissions . that indicates what state we are permitted to access \nand what type that state will have. Notationally, we use \u00d8 for the empty bag, { ...} to indicate bag \nvalues, and + for bag union. As syntactic sugar, we use a comma operator to represent the .attened bag \nunion operator . .. a,b = { a} + { b} a,B = { a} + BA,B = A+ B Bag unions are commutative, associative \nand have \u00d8 as the identity element. Using a bag instead of an ordinary set enables us to identify duplicate \npermissions. A related operator is , the union of disjoint sets. This operator is commutative, associative, \nand feature the empty set {} as an identity element. The union of disjoint sets, un\u00adlike the standard \ndisjoint union operation, is only partially de.ned; thus AA= Ais true only for A= \u00d8. Additionally, cancellation \nis well-de.ned: A. B = A. C . B = C. E-Plus1 E-Plus2 ''''''E-Plus (\u00b5; a; e1) .g (\u00b5; a; e1)(\u00b5; a; e2) \n.g (\u00b5; a; e2) (\u00b5; a; n1+n2) .g (\u00b5; a; n1 + n2) ''' ''' (\u00b5; a; e1+e2) .g (\u00b5 ; a ; e1+e2)(\u00b5; a; v+e2) .g \n(\u00b5; a; v+e2) E-Equal1 E-Equal2 ''''''E-Equal (\u00b5; a; e1) .g (\u00b5; a; e1)(\u00b5; a; e2) .g (\u00b5; a; e2) (\u00b5; a; \nv1=v2) .g (\u00b5; a; v1 = v2) ''' ''' (\u00b5; a; e1=e2) .g (\u00b5 ; a ; e1 =e2)(\u00b5; a; v=e2) .g (\u00b5; a; v=e2) E-New \nE-Read1 E-Read ''' ./.Rng(\u00b5) .f.F ..f /.Dom(\u00b5) .Dom(a) .Rng(a)(\u00b5; a; e) .g (\u00b5; a; e) \u00b5(..f)= v ''' \n(\u00b5; a; new{f1, ... ,fn}) .g (\u00b5[..fi .vfi |1 =i =n]; a; .)(\u00b5; a; e.f) .g (\u00b5 ; a ; e .f)(\u00b5; a; ..f) .g \n(\u00b5; a; v) E-Write1 E-Write2 E-Write ''''''' (\u00b5; a; e1) .g (\u00b5; a; e1)(\u00b5; a; e2) .g (\u00b5; a; e2) v2 ~vf \u00b5= \n\u00b5[..f .v2] ''' ''' ' (\u00b5; a; e1.f:=e2) .g (\u00b5 ; a ; e1.f:=e2)(\u00b5; a; v1.f:=e2) .g (\u00b5 ; a ; v1.f:=e2)(\u00b5; \na; ..f:=v2) .g (\u00b5; a; ()) E-Seq1 '''E-Seq (\u00b5; a; e1) .g (\u00b5; a; e1) (\u00b5; a; ();e2) .g (\u00b5; a; e2) ''' (\u00b5; \na; e1;e2) .g (\u00b5 ; a ; e1;e2) E-If1 ''' E-IfTrue (\u00b5; a; e1) .g (\u00b5 ; a ; e1) (\u00b5; a; if true then e2 else \ne3) .g (\u00b5; a; e2) '' ' (\u00b5; a; if e1 then e2 else e3) .g (\u00b5 ; a ; if e1 then e2 else e3) E-IfFalse E-Call \n(\u00b5; a; if false then e2 else e3) .g (\u00b5; a; e3)(\u00b5; a; call p) .g (\u00b5; a; gp) E-Adopt1 ''' (\u00b5; a; e1) .g \n(\u00b5 ; a ; e1) '' ' (\u00b5; a; nest e1.f1 in e2.f2) .g (\u00b5 ; a ; nest e1.f1 in e2.f2) E-Adopt2 E-Adopt ''' \n' (\u00b5; a; e2) .g (\u00b5 ; a ; e2) a= a .{(.1.f1) .(.2.f2)} ''' ' (\u00b5; a; nest v1.f1 in e2.f2) .g (\u00b5 ; a ; nest \nv1.f1 in e2.f2)(\u00b5; a; nest .1.f1 in .2.f2) .g (\u00b5; a ; ()) Figure 2: Operational Semantics f() : unit \nfb :bool fn :int f. :ptr(.) Figure 3: Atomic types for values: fv : t fv1 : t1 fv2 : t2 t1 ~t2 t .{unit, \nbool, int, ptr(.) |. .N .R} ' ptr(.) ~ptr(.) v1 ~v2 t ~t Figure 4: Storage compatibility for values \nand types For any environment E = (.; .), we require that all free variables in . are in .. For brevity \npurposes, this restriction is left implicit. We treat . in a somewhat linear fashion, in that permis\u00adsions \ncannot be duplicated. However, making use of per\u00admissions does not consume them. The basic permission \nis the permission for a key k. As mentioned earlier, a key here means a .eld of an object, whereas earlier \nproposals use a whole object as a key. The permission to access a .eld names the object reference . (which \nis either a literal object reference . or a reference variable r) and also includes the type stored there. \nWe have four atomic types: (The use of ... here means there are other forms for types and permissions.) \n(object reference) .::= . | r (key) k ::= ..f (type) t ::= unit | bool | int | ptr(.) | ... (base permission) \n\u00df ::= k : t (permission) p ::= \u00df | ... Two atomic types t and t ' are storage compatible (writ\u00adten t \n~ t ' ) if space storing a value of type t can be reused to store a t ' . This relation (see Fig. 4) \nis only true for the four atomic types listed here, and thus t ~ t if and only if t .{ unit,bool,int,ptr(.) \n| .. N . R} ,where N is the set of all object references and R is the set of all reference vari\u00adables. \nAdditionally all pointer types are interchangeable: ptr(.) ~ ptr(. ' ). Fields of unit type do not store \nany information, but in\u00adstead are used to model data groups (we use the termi\u00adnology of Leino and others \n[17, 11] with the semantics of our regions [15]). Aggregation of .elds into data groups is accomplished \nby nesting, for instance ..x:int . ..loc means the x .eld of the object at . is part of the loc data \ngroup. We assume the existence of a .eld All with type tAll = unit. Conventionally, an object constructor \nmay ensure that all of its .elds are adopted into its All data group, directly or indirectly. Permissions \nmay be combined using the comma operator, as explained above.2 We denote a general bag of permissions \n.= { p,...} , or a bag of base permissions B = { \u00df,...} . The type system described here uses a simple \nlogic that can be represented by boolean formulae over equalities k = k ' and typed adoption facts k \n: t . k ' : (formula) G ::= true | G . G |\u00ac G | k = k | k : t . k | ... ' '' We write k .k as shorthand \nfor \u00ac (k = k ), and . = .= as shorthand for ..All = . ' .All, where All is a data group in which all \nof the .elds of the object are nested, perhaps indirectly. A boolean formula can be used as a permission. \nIt does not give any permission to access the heap, but it does constrain which situations can occur.3 \nBoolean formu\u00adlae represent .xed truth, since the equality of two addresses is immutable and adoption \ncannot be undone. The value of a formula (especially adoption) may be unknown, but once it gains a value, \nthat value cannot change during execution. 2The comma operator is roughly the equivalent of the . in \nseparation logic, while the empty bag is similar to emp. 3Thus our system can be seen as a particular \nmodel of the logic of Bunched Implications [19, 20]. Since adoptions (nesting) can happen at any later \ntime, it will be seen that the consistency rules never give a false value to an adoption fact; either \nit is known to be true (and thus unchangeable) or it is not known. The syntax also pro\u00advides a construct \nfor named recursive formulae t over object references: (formula) G ::= ... | t(l1,... ,ln) The formula \nt is given a de.nition by an implicit global environment T: T(t) is a formula with free variables in \n{ r1,... ,rn} . We implicitly require/assume that all uses of a formula supply the correct number of \narguments. Following Adoption &#38; Focus [8], a conditional permis\u00adsion is written in the form of a \nlinear implication using -. . 4 There are two forms of this operator, G -. .and B-. .. The .rst form \nmeans that we have all the per\u00admissions implied by . if the formula G is true and no per\u00admissions otherwise. \nThe second form means that we have all the permissions implied by . except for those base per\u00admissions \ncontained in B, which must be contained directly or indirectly within .. We don t permit the general \nform .1 -. .2 because of technical di.culties. All permissions are precise [21]: given a particular assignment \nto the ad\u00address variables, and a particular assignment of values in the heap, the permissions can be \nsatis.ed in only a single way. We exploit precision in the way we check and manipulate (conditional) \npermissions. Thus we have the following three remaining forms for per\u00admissions: (permission) p ::= ...| \nG | G -. . | B-. . For example, suppose x is a global variable (represented by a .eld of the null object) \nthat may be null, but if it is not null, we have permission to access all of the .elds of the pointed\u00adto \nobject. This situation is represented by the following bag of permissions: $0.x :ptr(.),. =$0.-. ..All \n: unit Now, we often do not know what the actual pointer value of a variable is and thus need to use \nsome form of quanti.ed types. For this reason a variable may have existential type, for example x : . \nr.ptr(r), but this form is not su.cient, because we need to be able to express permissions about the \nexistentially bound address variable. Thus we have a form for compound types which connects a bag of \npermissions with an existential: (type) t ::= ... |. r.t with . In order to easily maintain precision, \nthe type system de\u00adscribed in this paper only accepts t =ptr(r)inthis context. Suppose that x, if not \nnull, points to some unique object. We can express this situation as follows: $0.x : . r.ptr(r)with r \n=$0.-. r.All : unit This is exactly how we express the concept of a unique pointer. While other .elds \nin the system may have the same pointer value, no one else has the permission to access the pointed-to \nstate, since permissions cannot be duplicated. This formulation is essentially the same as in Vault [7] \nwith 4The separation logic implication operator -. is closer in semantics. the addition of conditional \npermissions which make the pos\u00adsible null-ness of a pointer explicit. The other form of conditional permissions \nis used to rep\u00adresent carvings out in which permissions of the adopted .elds are carved out of the adopter \npermission. We write k : t\\{k1 : t1,... ,kn : tn} as a shorthand precisely for (k1 : t1 .k.....kn : tn \n.k) , ((k1 : t1,... ,kn : tn) -.k : t) One use of this shorthand is that the type system allows this \ncompound permission to be su.cient to access the value stored in .eld k. It is also possible to carve \nout further adoptees that are known to be distinct from the existing carvings out. A procedure may be \npolymorphic over some location vari\u00adables .. It accepts a bag of permissions and returns a (possibly \nnew) bag of permissions, using perhaps some new variables. A program type has a type for each procedure. \nSubstitutions map address variables to other variables or to absolute addresses. (procedure type) a ::= \n...(. .....) (program type) . ::= {p: a,...} (substitution) s ::= {r ..,...} For a procedure type ..1..1 \n...2..2,the free variables of .1 must be includedin.1 and the free variables of .2 must be includedin.1 \n.2. Parameters and results can be passed in global variables or in specially created activation objects. \nSubstitutions are used to transform the permissions into a form accepted by a procedure and to convert \nthe resulting permissions back. Substitutions are typed by their domain and range: Dom(s)=. Rng(s) .. \n' .N s :. .. ' Here N is the set of all absolute (object) addresses. Substi\u00adtutions are lifted to apply \nto permissions in the normal way, andinparticular s acts as the identity function on address variables \noutside of its explicit domain. The type rules corresponding to the syntax are given in Figure 5. Each \nexpression produces a possibly new environ\u00adment after being checked and thus our relation is E f. e : \nt -E ' where . is the program typing. We will often chain '' '' together relations as in E f. e: t -E \nf. e : t ' -E . The If rules bear some explanation: as well as a default rule, we have a special case \nrule for the comparing of point\u00aders. The type system makes the equality or inequality being tested available \nin the corresponding branches. At the end of an if, weneed to mergethe twoenvironments (seeFig\u00adure 6), \nwhich makes use of substitutions. The IfTrue and IfFalse rules are needed for type preservation. Therulefor \nnest expressions requires that the key be\u00ading adopted be fully available (without anything carved out) \nand not equal to any key currently carved out of the adopter. This rule prevents keys from being twice \nadopted by the same adopter, and also prevents self or cyclic adop\u00adtion. It does not prevent a key from \nbeing adopted by two di.erent adopters. The rules enable the following widening lemma (an ana\u00adlogue of \nthe frame axiom of separation logic): Lemma 2.1. Given a type-checked program g (f g : .), an expression \ne that type-checks (.; .1 f. e : t -. ' ;.1' ) and an environment . '' ;.2,then e also type-checks with \na larger set of permissions (. .. '' ;.1,.2 f. e : t \u00ad .. '' . ' ;. ' 1,.2) in which the unused permissions \nare not changed.  2.3 Consistency Types can ensure that programs don t go wrong, but only if the memory \nis in a state matched by the types, or per\u00admissions in our case. This is represented by the consistency \nrelation which is written \u00b5; af.; . consistent using s;(A.,AT ) and is de.ned using the inference rules \nin Fig. 10.5 Con\u00adnecting the static types to the run-time state has two as\u00adpects: object variables must \nbe replaced with absolute ad\u00addresses, and implied permissions (from existentials or adop\u00adtion) must be \nmade explicit. The .rst witness to consistency is therefore a substitution s :. .\u00d8 that maps each object \nvariable to an absolute address: the empty set range meaning that the result of the substitution uses \nno variables. A second witness to consistency is the pair of assumption sets A =(A.,AT ). The .rst part \nof the assumptions is a set of typed adoption facts A. = {l : t .l ' ,...}where t has no free variables. \nThe second set of the assumptions is a set of boolean formulae assumed true AT = {t(.1,... ,.n),...}. \nFigure 7 shows how boolean conditions are evaluated given these assumptions. Adoption facts or applications \noutside of these sets are not assumed to be false; rather they are unknown. Location equality is known \nto be true or false because all addresses are absolute. For consistency checking, the substituted permissions \ns. are .attened into a set . of permissions of the form: (.at permissions) . ::= {l : tatom,...} (primitive \ntype) tatom ::= unit |bool |int |ptr(.) The .attening operation unpacks all existentials and carves out \nall adopted permissions so that one is left with a map that gives an atomic type for every location that \nthe origi\u00adnal permissions implied. Figure 10 shows how the .attened permissions are checked for consistency \nagainst the memory. It is also necessary to ensure that there are not two permis\u00adsions to the same state. \nIf the permissions involve distinct (atomic) types, the memory consistency check will fail. To prevent \ntwo identical permissions from being accepted, the rules only use union of disjoint sets to combine .attened \npermissions. The last two requirements of Figure 10 check the adoption assumptions against the actual \nadoption state, and check the bodies of the assumed predicates. The bulk of the .attening work is done \nin Figure 8 which de.nes the relation \u00b5; A; B f . . The B set consists .. of permissions that are carved \nout of . and thus must be accounted for exactly once while .attening . (and removed), as can be seen \nin rules CP-Imp and CP-Identity. Of special interest here is the CP-Field rule which han\u00addles adoption. \nFor every typed adopted .eld l ' : t ' .l,we .atten this .eld in turn. The acyclicity of adoption ensures \nthat this rule does not lead to in.nite recursion. The re\u00adquirements B are split between B1, which is \nfurther split 5Consistency serves a similar purpose to that of the forcing relation (|=) in separation \nlogic. Unit Num True False Address E f. () : unit -EE f. n :int -EE f. true :bool -EE f. false :bool \n-EE f. . :ptr(.) -E Plus Equal ' '' ''' E f. e1 :int -E f. e2 :int -EE f. e1 : t1 -E f. e2 : t2 -Et1 \n~t2 '' '' E f. e1+e2 :int -EE f. e1=e2 :bool -E New r fresh .; . f. new{fi |1 =i=n} :ptr(r) -{r}..; \nr.fi : tfi |1 =i =n,. Read '' ' E f. e:ptr(.) -.;. .= ..f : t\\{...},.1 t ~t E f. e.f : t -. ' ;. ' \nWrite ' '''''' ' ' E f. e1 :ptr(.) -E f. e2 : t -.;. .= ..f : t \\{...},.1 t ~tt ~tf E f. e1.f:=e2 : \nunit -. '' ; ..f : t\\{...},.1 Seq If '''''' ' '' E f. e: unit -E f. e : t -EE f. e0 :bool -EE f. e1 \n: unit -E1 E f. e2 : unit -E2 E = E1 .E2 ' '' '' E f. e;e : t -EE f. if e0 then e1 else e2 : unit -E \nIfEqual '' ' E f. e:ptr(.) -E f. e :ptr(. ) -.; . ' ''' .; (.= .,.) f. e1 : unit -E1 .; (.=..,.) f. \ne2 : unit -E2 E = E1 .E2 E f. if e=e ' then e1 else e2 : unit -E '' IfTrue IfFalse E f. e1 : unit -E \n' E f. e2 : unit -E ' E f. if true then e1 else e2 : unit -E ' E f. if false then e1 else e2 : unit -E \n' Call .(p)= ..1..1 ...2.s2.2 s1 :.1 ... ' fresh s2 :. ' ..2 .; s1.1,.3 f. call p: unit -. .. ' ; s1.2,.3 \nNest ' ' ' '''' E f. e:ptr(.) -E f. e :ptr(.) -. ;. ' '' '' '' k = ..f k = . .f . =(k : t,k ..n),k : \nt \\{k1 : t1,... ,kn : tn},.1= k1 .....k = k '' '''' ' E f. nest e.f in e .f : unit -. ;(k : t \\{k1 : \nt1,... ,kn : tn}; k : t .k ),.1 Proc Program '' ' .1;.1 f. e: unit -.1; s.2 .1 n.2 = \u00d8 s :.2 ..1 p: a \n.. .f. g(p): a f. e: ..1..1 ...2..2 fg : . Figure 5: Syntactic Type Rules '''' ' .1;.1 = s1.; s1..2;.2 \n= s2.; s2. .=.1 n.2 . -.fresh r .. .sir = r (. ' ;. ' )=(.1;.1) .(.2;.2) Figure 6: Environment Merging \ninto a bag for each adopted .eld, and B2, which is satis.ed by t. All the resulting permissions are combined \nusing union of disjoint sets. Figure 9 handles the possible unpacking of t using the actual memory value \nof the location. If the type is already atomic, it does nothing (not even checking that the value has \nthe designated type). For an existential, we use the value to substitute the object variable.  2.4 Transformation \nThe type rules given above do not have any way to use (or create) conditional permissions, or to carve \nout or replace permissions from their adopters. Thus we add the concept of transforming permissions. \nIn a typing proof, one may insert permission transformations before or after any expression using rule \nTransform in Fig. 11. (This rule is the equiva\u00adlent of Hoare s rule of consequence.) The .gure also shows \nthat the condition for a valid transformation is that consis\u00adtency remains unchanged (using the same \nor larger substitu\u00adtion and adoption assumptions the other assumptions are veri.ed in consistency). We \nprove a lemma that transformations are compositional: Lemma 2.5. If we have two transformations: .; .1 \n= . ' 1;.1 ' and .; .2 = . ' 2;.2 ' where the fresh variables in\u00adtroduced are disjoint (. ' 1 - .) n \n(.2 ' - .) = \u00d8, then the two transformations can be merged: .; .1,.2 = . ' ;. ' 1,. ' 2 where . ' =. \n' 1 . .2' . The de.nition of E = E ' is not constructive, but it is easy to de.ne (and prove soundness) \nof such special cases as in the following lemma: Lemma 2.8. The following rules hold: E = E .; . = .; \n\u00d8 .; \u00d8= .; true ' ' .; G . G = .; G,G .; G = .; \u00ac\u00acG .; t(.1,... ,.n) = .; [r1 . .1,... ,rn . .n]T(t) \n(.; . = .; G) . (.; . = .; .,G) .; \u00acG = .; G -. . .; G,. = .; G,G -. . .;. = .; \u00d8-. . .; \u00d8= .; B-. B \nReduce .; B1 -. B2,(B2,B3) -. .4 = .; (B1,B3) -. .4 Carve-Out G= k : t . k ' . k .= k1 . .... k .= kn \nB = { k1 : t1,...kn : tn} '' ' .; k : t \\{B} ,G = .; k : t\\{k : t,B} ,k : t Pack (.; k :ptr(.),[r . \n.].) = (.; k : .r.ptr(r)with .) Unpack r ' is fresh .'.'' (.; k : .r.ptr(r)with .) = ( r ..; k :ptr(r \n),[r . r ].) The second sample rule shows that keys can be dropped during a transformation. These represent \nwork created for a garbage collector. Alternatively, if this transformation can be used, it shows where \ndeallocation can be done safely. Rule Reduce is a generalization of (linear) Modus Ponens (B1 = B3 = \n\u00d8). Rule Carve-Out shows how one can carve out a key from another key. It can be replaced using the earlier \nmore gen\u00aderal rules involving linear implication. The last rules show how existentials can be introduced \nand eliminated. 2.5 Soundness Consistency enables the progress of evaluation and preser\u00advation of types \nfor well-typed expressions in environment with no address variables: Lemma 2.9. Given a type-checked \nprogram g (f g : .), an expression e that type-checks in a variable-free environ\u00ad '' '' ment E =(\u00d8;.) \n(E f. e : t -E , E =(. '' ;. '' ),we do not require . '' = \u00d8) and a memory and adoption infor\u00admation \nconsistent with E (\u00b5; a f E consistent), then either e is a value or there exists an evaluation step \n((\u00b5; a; e) .g ' ' ' (\u00b5; a ; e )) and for any such evaluation step, there exists a substitution (with \nabsolute addresses) on some of the new type variables s :. .\u00d8 where . . . '' such that the re\u00adsulting \nexpression type-checks in a new environment E ' = '' . '' (\u00d8;. ' ) with the substituted result (E f. \ne : st -- .; s. '' ' ). In addition, the witness A for the new consis\u00adtency will include everything in \nthe witness of the origi\u00adnal consistency A ( A. . A.' ,AT . AT ' ), and further\u00admore the new .attened \npermissions will only include loca\u00adtions from the old permissions or newly allocated memory: Dom(. ' \n) n Dom(\u00b5) . Dom( .). More pertinent to this work than progress and preserva\u00adtion is the fact that if \none does not have the permission to some piece of state, one cannot access it (read, write or adopt) \nas shown in the following lemma: Lemma 2.10. Given a type-checked program g (f g : .), an expression \ne that type-checks in a variable-free environ\u00adment \u00d8;. f. e : t -E '' ) and a memory and adoption consistent \nin an environment with more permissions (\u00b5; af \u00d8;.,.+ consistent), then the evaluation of the expression \n(if any) will not read or write any .eld mentioned in the .attening of the extra permissions (. +). We \nnow can prove a separation theorem: Theorem 2.11. Given a type-checked program g (f g : .), two expressions \ne1,e2 each of which type-checks in a variable-free environment \u00d8;.i f. ei : unit -Ei' )and a memory and \nadoption consistent with the combined environ\u00adments: (\u00b5; a f\u00d8;.1,.2 consistent), then when evaluating \nthe expressions in sequence e1; e2 no state will be accessed by both expressions.  2.6 Future Work The \nwork described here is partial and ongoing. Further work that needs to be addressed includes: Formalizing \nthe = relation as a logic, and coming up with a conservative algorithmic approximation.  Addressing \nthe nondeterminism of the If rules (espe\u00adcially the rule for E1 . E2).  Handling while loops. In the \nsystem here, a while loop must be expressed as a call to an explicitly typed recursive procedure. It \nwould be desirable if the re\u00adquired invariant could be inferred instead.  CB-Axiom. CB-Neg CB-AndFalse1 \nCB-True ' CB-Equal (l :t .l ).A. AfG=bAfG1 =false Aftrue =true Afl=l ' =(l =l ' ) Afl : t .l ' =true \nAf\u00acG=\u00acbAfG1 .G2 =false CB-AndFalse2 CB-AndTrue CB-AxiomT AfG2 =false AfG1 =true AfG2 =true t(.1,... ,.n).AT \nAfG1 .G2 =false AfG1 .G2 =true Aft(.1,... ,.n)=true Figure 7: Consistency rules for boolean formulae: \nAfG=b CP-True CP-FalseImp CP-TrueImp CP-Empty AfG=true AfG=false AfG= true \u00b5;A;B f... \u00b5;A;\u00d8f\u00d8.{} \u00b5;A;\u00d8fG.{} \n\u00b5;A;\u00d8fG-...{} \u00b5;A;B fG-.... CP-Imp CP-Union CP-Identity \u00b5;A;B1,B2 f... \u00b5;A;B1 f.1 .. 1 \u00b5;A;B2 f.2 .. \n2 \u00b5;A;l :t fl : t .{} \u00b5;A;B1 fB2 -.... \u00b5;A;B1,B2 f.1,.2 .. 1 . 2 CP-Field  B1 =Bl':t' \u00b5;A;Bl':t' fl \n' :t ' .. l':t' . 1 =. l':t' \u00b5;A;B2 f\u00b5(l): t .. 2 : tatom (l':t'.l).A. (l':t'.l).A. \u00b5;A;B1,B2 fl :t .. \n1 . 2 {l : tatom} Figure 8: Consistency rules for permissions: \u00b5;A;B f... CT-Unit CT-Bool CT-Int \u00b5;A;\u00d8fv \n:unit.{}:unit \u00b5;A;\u00d8fv :bool .{}:bool \u00b5;A;\u00d8fv :int .{}:int CT-With CT-Ptr \u00b5;A;\u00d8fv :ptr(.).{}:ptr(.) \u00b5;A;B \nf[r ..]. . . \u00b5;A;B f. :.r.ptr(r)with .. .:ptr(.) Figure 9: Consistency rules for types: \u00b5;A;B fv . .:t \n a is acyclic s :..\u00d8 \u00b5;A;\u00d8fs... (l : tatom) .. .f\u00b5(l): tatom .t.(l : t .l ' ).A. .(l .l ' ).at(.1,... \n,.n).AT .Af[r1 ..1,... ,rn ..n]T(t)=true \u00b5;af.;. consistent using s;(A.,AT ) Figure 10: Consistency \nrules for memory ' '' .\u00b5;a;s;A.,AT (\u00b5;afE consistent using s;(A.,AT ))..A',s'.s (\u00b5;afE consistent using \ns ;(A.,AT )) T E =E ' Transform E =E1 f. e:t -E1 ' =E ' E f. e:t -E ' s ' .s means that r ...s ' r \n=sr,and E1 =E2 means E1 =E2 .E2 =E1. Figure 11: Transformation rules  3. REALIZING ANNOTATIONS Instead \nof directly using the low-level types formalized in this paper, we can use them to express commonly pro\u00adposed \nhigher-level annotations. The annotations only use a stylized fragment of the type system, and thus lack \nits full expressive power. As has been done with complex typ\u00adings [22] used for object-oriented languages, \none may be able to provide a simpler type system to check the annotations; the simpler system could then \nbe proven sound against the full type system. The following annotations can be realized with our exten\u00adsion \nof adoption: data groups A class may declare data groups. A .eld is tagged with its parent data group; \na data group may also have a parent. Unlike our earlier work [15] (where data groups were called regions \n), a .eld may be nested in two data groups. However, at most one data group may actually contain the \n.eld at a time. reference annotations A .eld, parameter, receiver or re\u00adturn value is tagged with one \nof the following annota\u00adtions: unique , shared or borrowed , where the latter is legal only for parameters \nand receivers. A weak form of ownership can also be handled as a generalization of shared . e.ects Any \nmethod may be annotated with e.ects. Since this paper does not use fractional permissions, we do not \ndistinguish between read and write e.ects. The state accessed is expressed using one of the following \nforms: this.f where f may be a data group; p.f where p is a formal parameter; other which means anything \naccessible from $0.All. We are looking at ways to extend the system to represent e.ects on state such \nas any.f which represents all f .elds (or data groups) of any object accessible from $0.All. 3.1 Class \nand Field Annotations We represent class types by named, potentially recursive, fact-creating functions \nwith one parameter for the address of the object. The facts include one adoption fact for every .eld \nand data group. For simplicity, we assume the exis\u00adtence of a single root data group All in which all \n.elds are nested (perhaps indirectly). The fact for a .eld includes its type which, for pointers, is \nan existential whose body is a macro-call that takes the reference, the fact-creating func\u00adtion for the \ntype and whether the pointer is good, usually (. .$0).7 = The macro function to use is named by the ref\u00aderence \nannotation and is expanded as part of the realization process: unique (.,t,c)= ptr(.)with c-. (..All \n: unit,t(.)) shared (.,t,c)= ptr(.)with c-. (..All : unit . $0.All . t(.)) borrowed (.,t,c)= ptr(.)with \nc-. t(.) The borrowed annotation is legal only for method param\u00adeters (and receivers), and indicates \nthat the parameter does not come with permissions on its own; any permissions are 7If we were to add \nnon-null annotations (as F\u00a8ahndrich and Leino [23] suggest), the condition could be strengthened to true \nfor non-null pointers. provided in the method e.ects. This formulation of bor\u00adrowed and unique is similar \nto that in Vault [7]. Consider the Point and Rectangle classes in our original example (Figure 1). For \nthese simple examples, we get the following fact-creating functions: class Point { Point(r1)= group Loc; \nr1.Loc : unit . r1.All . int x in Loc ; r1.x :int . r1.Loc . int y in Loc ; r1.y :int . r1.Loc) } Rectangle(r1)= \nr1.Looks : unit . r1.All . r1.Dims : unit . r1.Looks . r1.tl : . r2.unique (r2,Point,r2 = $0) .. r1.Dims \n. r1.br : . r2.unique (r2,Point,r2 = $0) .. r1.Dims . r1.n : . r2.shared (r2,String,r2 .Looks = $0) . \nr1. 3.2 Parameters and Methods Effects The parameters and return value are packed into an ar\u00adgument \nobject pointed to by a global ap. We also give general access to a number of global temporaries. Per\u00admissions \nto access all these globals, the parameters and the return value are passed to and returned from the \nprocedure. When a procedure is called, the return value is uninitialized (if a pointer, has a pointer \ntype with an address variable for which we have no information). At the end, the parameters are uninitialized. \nThe procedure type is polymorphic using a variable for the argument object, the receiver, each pointer \nparameter and the result (if a pointer value). The permis\u00adsions for each parameter are typed on procedure \nentry using the same macros for the pointer annotations, except this time the macro-calls are not wrapped \nin existentials. (The with -bound permissions are simply dropped into the sur\u00adrounding permission bag.) \nThe return value is typed using the annotation macro-call upon exit. Thee.ectsof the method arerealized \nby permissions that are passed to the procedure and then returned. A data group of a receiver or parameter \nis represented by a data group of the corresponding location variable. The state other is represented \nby $0.All. If some of the e.ects state are known to be shared (directly or indirectly adopted into $0.All), \nthe permission will be carved out in advance. For a simple example, consider a method of Rectangle that \nchanges the name of a rectangle: void setName(shared String n) borrowed accesses this.Looks ; Its realized \ntype is . rf ,rt,rn. ($0.ap :ptr(rf ),temps,rt.Looks : unit,(rf .this : borrowed (rt,Rectangle,true), \n) () ( rf .n : shared (rn,String,rn .= $0) . ) ' . rn.($0.ap :ptr(rf ),temps,rf .this :ptr(rt), rf .n \n:ptr(rs' ),rt.Looks : unit) 3.3 Discussion This realization links parameter annotations and e.ects more \nstrongly than in our previous work: it does not per\u00admit (read-write) borrowed parameters to be aliased; \nit does not permit shared state to be passed borrowed to a method that a.ects other. Intersection types \nsolve this prob\u00adlem at the cost of a number of variants, exponential in the number of parameters. On \nthe other hand, the stricter def\u00adinition is probably a good default; a parameter whose state could be \naccessed through another parameter or through a global variable should be declared as such. The stricter \nrule corresponds closely to the new ANSIC restrict quali.er as formalized by Foster and others [24]. \nThe realization described here does not fully handle in\u00adheritance and virtual overriding because there \nis no way to express downcasts. Neither does it handle the problem of partially constructed objects. \nWe hope to use F\u00a8ahndrich and Leino s monotonic heap states [25] to describe how the facts for an object \ngrow from the facts provided by the superclass to the additional ones provided by the sub\u00adclass.  4. \nEXTENSIONS Recursive permissions allow the de.nition of aliased struc\u00adture in a similar way as in recursive \nalias types [26] with the important distinction that since we use conditional per\u00admissions rather than \nunion types, the end points (null pointers or back-pointers) don t need to have a di.erent type: a doubly \nlinked list can be appended to in both direc\u00adtions, and a circular list can be rotated. These operations \nrequire the whole aliased structure to be viewed from a dif\u00adferent angle, which requires transformation \nsteps that can be proved using inductive proofs. For instance, a doubly-linked list between a header \nnode at address h and a tail node at address t can be de.ned by the permission DLLF(h, t): DLLF(h, t)= \n{ h.p : ptr(0), DLLF1(h, t)} {f.n : . n.ptr(n)with }DLLF1(f, l)=f =.l -. (n.p :ptr(f), DLLF1(n, l)),f \n= l -. n =$0 This type, which makes it easy to access the front of the list (to add or remove nodes) \ncan be converted into the sym\u00admetric type (not shown) that views the list from the tail, without any \ndata changes. One simply uses environment transformation. Thus unlike external uniqueness, one can move \nindividual links between two unrelated lists, and un\u00adlike recursive alias types, the structure can be \nadded to at either end without changing the rest of the list. Similarly, a type for circular lists entered \nat address h, CIR(h) can be de.ned: CIR(h)= CIR1(h, h) {} p.n : . n.ptr(n)with CIR1(h, p)= n . = h -. \nCIR1(h, n) This type can be rotated using environment transforma\u00adtion without changing any stored data. \nThese types are very similar to the heap types written using separation logic [27, 20], and thus these \npositive aspects are not particularly sur\u00adprising. The novel twist of this work is the addition of adop\u00adtion \nwhich enables permissions to be captured in non-linear ( intuitionistic ) facts. For instance, the header \nnode of the circularly linked list could be described by the following (non-linear) type: Circle(c)= \nc.h :(. h.ptr(h)with h . =$0 -. CIR(h)) . c.All This type, being non-linear, is immutable and can be \nbroad\u00adcast everywhere, but wherever/whenever the simple (lin\u00adear) permission c.All : unit is available, \nthe circular aliasing structure can be recovered. Another extension that we are actively pursuing is \nthe idea of fractional permissions [16]. A write permission is viewed as a whole permission that can \nbe split up into (frac\u00adtional) read permissions. The write permission can be re\u00adstored after recovering \nall the various read permissions and reassembling the whole permission. Stated simply, we add the equivalence: \n11 . = ., . 22 Read e.ects are modeled by read permissions (of some un\u00adknown fraction) that are sent \nto a procedure and then re\u00adturned. While the procedure is active, the state is tem\u00adporarily immutable. \nFull immutability is achieved by hiding a fraction inside an existential. Here x is a global variable \nthat points to an object with an immutable integer .eld: $0.x : . r.ptr(r)with r .=$0 -. . z.zr.val :int \nAn immutable reference can be split into two by unpacking the existential, splitting the remaining fraction \nin two and then repacking two separate existentials. With fractions, one can also model read-only (shared) \nvariables, and unique\u00adwrite variables. Fractions complicate the type system, which is one rea\u00adson why \nthey were not included in the system described in this paper. The thorniest issue is that the equivalence \ngiven above is not necessarily sound if . is not precise (the two fractions could refer to incomparable \nviews that cannot be added together), but the rule for splitting an immutable reference relies on imprecision \nin the existential. The dilemma can be solved by disallowing the use of an ex\u00adistentially bound fraction \nvariable in negative positions in the permission (on the left-hand side of -. ). Fractions are however \nvery powerful. For a .avor of what they can do, consider modeling iterators in a collection sys\u00adtem such \nas JDK 2. While an iterator is running over the container, the container should not be mutated, except \nthrough the iterator, and then only if there is only one it\u00aderator in action. Thus a container can support \nmultiple read-only iterators, or a single read-write iterator. A read\u00adonly iterator is created by splitting \no. a (read-only) frac\u00adtion of the whole container, from which is obtained a (read\u00adonly) reference to \nthe internal structures which is used for the iterator. When one is done with the iterator, the parts \nare returned, and the container fraction is reassembled and merged back into the rest of the container. \nA read-write iterator is constructed using the same process except with the entire (writable) container. \nMathematically, the process of creating an iterator uses the equivalence zContainer = 1Iterator(z), 1Iterator(z) \n-. zContainer We run the equivalence forward to construct an iterator, and in reverse when we are done \nwith it. If z =1, we are creating a read-write iterator, otherwise a read-only iterator, or more precisely \na mutable iterator over read-only state. 5. RELATED WORK The work is closely related to the work of \nseparation logic [27] and the logic of bunched implications (BI) [19, 20, 21]. Many individual comparisons \nare scattered through the paper. The biggest technical addition of this work is adoption. Our consistency \ncheck is syntactic which causes restrictions in the forms of existential and conditional per\u00admissions, \nnot present in BI. Overall, this work is working toward automatic type-system-like inference of a proof \nof aliasing properties, whereas Reynolds, O Hearn and others are emphasizing a logic used for program \nveri.cation. This work was conceived as an extension to the adoption and focus work of F\u00a8ahndrich and \nDeLine [8]. Their type system permits a linear pointer to be irrevocably adopted by another pointer. \nThen the pointer can be duplicated (i.e. copied nonlinearly) with a guarded type gt where g is the adopter. \nShould some piece of the code need to use the pointer and it has access to the adopter, it can focus \non the adoptee and gain the linear pointer while temporar\u00adily giving up the rights on the adopter. When \nthere is no more need to access the linear pointer (and its linearity and type have been restored), the \nlinear pointer can disappear back into the adopter which is then restored. Our system extends/changes \nadoption and focus in the following ways: 1. Unlike adoption and focus, carving out permissions for a \nnested key ( focusing in their terminology) does not make the nesting key (the adopter ) inaccessible. \nIt only forbids carving out the same nested key again. 2. In our system,adoption(andprotectioningeneral) \nis performed at the level of .elds of an object rather than whole objects. This allows .ner-grained permissions. \n 3. We prove the type soundness of our system using an operational semantics of adoption.  We also intend \nto extend our system to distinguish reads from writes. Adoption and focus uses Alias Types [28], a technique \nto represent aliasing in the type system. Alias types can be used to precisely describe the shape of \nrecursive data structures [26]. E.ects systems have been de.ned for functional languages in order to \nsafely deallocate regions of data that are no longer being accessed [29]. A region encapsulates a (possi\u00adbly \nheterogeneous) set of objects. This work was extended by Walker and others [30] in a capability calculus \nthat has one permission key for each region. These insights were later used in the adoption and focus \nwork. An alternate approach is Monnier s typed regions [31] which combines linear and intuitionistic \nreferences in a single system. The system uses a cast operation that includes a proof of correctness \nin the underlying logic (CiC [32]). It also uses an intended type which appears similar to how the type \nunder adoption is unchanged in our system. Boyapati and others [33, 34] have incorporated unique\u00adness, \ne.ects and regions in an ownership type system for Java-like languages. They use a permission system \nover whole objects (not .elds as in this work) to prevent data\u00adraces. Uniqueness is supported in a few \nspecial situations, such as tree-like structures. For the most part, however, the ownership type system \nprevents object transfer. It appears that transfer could be added to their system using external uniqueness \n[6]. One of the attractive features of external uniqueness is that uniqueness is de.ned for external \npointers and does not prevent aliasing internal to the object. We incorporated this idea into our system \nso that if a structure with internal aliasing is described using recursive types, a unique reference \ncould point to it. Using our permission system for e.ects obviates the need for destructive reads. 6. \nCONCLUSIONS In this paper, we describe how we can use the ideas of adoption and focus to design a type \nsystem that takes into account e.ects and uniqueness in a uni.ed manner. Conditional permissions permit \none to express null pointers without tagged unions. Field adoption allows us to express data groups. \nWe show how high-level annotations (method e.ects and pointer annotations) can be expressed in this system. \nWe prove the type soundness of the system and show how state separation can be guaranteed. It is unlikely \nthat complete algorithmic type inference is possible, but we expect that a practical algorithmic inference \nsystem can be de.ned that will check stylized uses of the type system, such as that used in our realization \nof annotations. Acknowledgments We thank Aaron Greenhouse, Josh Berdine, and Tim Hallo\u00adran for their \nuseful comments and corrections on this paper. We also thank Dave Clarke, Manuel F\u00a8ahndrich, and Jan \nVitek for fruitful conversations. 7. REFERENCES [1] Boyland, J.: The interdependence of e.ects and uniqueness. \nPaper from Workshop on Formal Techniques for Java Programs, 2001 (2001) [2] Hogg, J.: Islands: Aliasing \nprotection in object-oriented languages. In: OOPSLA 91 Conference Proceedings Object-Oriented Programming \nSystems, Languages and Applications, New York, ACM Press (1991) 271 285 [3] Baker, H.G.: Use-once variables \nand linear objects storage management, re.ection and multi-threading. ACM SIGPLAN Notices 30 (1995) 45 \n52 [4] Minsky, N.: Towards alias-free pointers. In Cointe, P., ed.: ECOOP 96 Object-Oriented Programming, \n10th European Conference. Volume 1098 of Lecture Notes in Computer Science., Berlin, Heidelberg, New \nYork, Springer (1996) 189 209 [5] Aldrich, J., Kostadinov, V., Chambers, C.: Alias annotations for program \nunderstanding. In: OOPSLA 02 Conference Proceedings Object-Oriented Programming Systems, Languages and \nApplications, New York, ACM Press (2002) 311 330 [6] Clarke, D., Wrigstad, T.: External uniqueness. In \nPierce, B.C., ed.: Informal Proceedings of International Workshop on Foundations of Object-Oriented Languages \n2003 (FOOL 10). (2003) [7] DeLine, R., F\u00a8ahndrich, M.: Enforcing high-level protocols in low-level software. \nIn: Proceedings of the ACM SIGPLAN 01 Conference on Programming Language Design and Implementation, New \nYork, ACM Press (2001) 59 69 [8] F\u00a8ahndrich, M., DeLine, R.: Adoption and focus: Practial linear types \nfor imperative programming. In: Proceedings of the ACM SIGPLAN 02 Conference on Programming Language \nDesign and Implementation, New York, ACM Press (2002) 13 24 [9] Leino, K.R.M., Stata, R.: Virginity: \nA contribution to the speci.cation of object-oriented software. Information Processing Letters 70 (1999) \n99 105 [10] Leino, K.R.M., Nelson, G.: Data abstraction and information hiding. Research Report 160, \nCompaq Systems Research Center, Palo Alto, California, USA (2000) [11] Leino, K.R.M., Poetzsch-He.ter, \nA., Zhou, Y.: Using data groups to specify and check side e.ects. In: Proceedings of the ACM SIGPLAN \n02 Conference on Programming Language Design and Implementation, New York, ACM Press (2002) 246 257 [12] \nClarke, D.: Object Ownership and Containment. PhD thesis, University of New South Wales, Sydney, Australia \n(2001) [13] M\u00a8uller, P.: Modular Speci.cation and Veri.cation of Object-Oriented Programs. PhD thesis, \nFernuniversit\u00a8at Hagen (2001) [14] Boyland, J.: Alias burying: Unique variables without destructive reads. \nSoftware Practice and Experience 31 (2001) 533 553 [15] Greenhouse, A., Boyland, J.: An object-oriented \ne.ects system. In Guerraoui, R., ed.: ECOOP 99 Object-Oriented Programming, 13th European Conference. \nVolume 1628 of Lecture Notes in Computer Science., Berlin, Heidelberg, New York, Springer (1999) 205 \n229 [16] Boyland, J.: Checking interference with fractional permissions. In Cousot, R., ed.: Static Analysis: \n10th International Symposium. Volume 2694 of Lecture Notes in Computer Science., Berlin, Heidelberg, \nNew York, Springer (2003) 55 72 [17] Leino, K.R.M.: Data groups: Specifying the modi.cation of extended \nstate. In: OOPSLA 98 Conference Proceedings Object-Oriented Programming Systems, Languages and Applications, \nNew York, ACM Press (1998) 144 153 [18] Xi, H.: Dependent Types in Practical Programming. PhD thesis, \nSchool of Computer Science, Carnegie Mellon University, Pittsburgh, Pennsylvania, USA (1998) [19] O Hearn, \nP., Pym, D.: The logic of bunched implications. Bulletin of Symbolic Logic 5 (1999) 215 244 [20] Ishtiaq, \nS.S., O Hearn, P.W.: BI as an assertion language for mutable data structures. In: Conference Record of \nthe Twenty-eighth Annual ACM SIGACT/SIGPLAN Symposium on Principles of Programming Languages, New York, \nACM Press (2001) 14 26 [21] O Hearn, P.W., Yang, H., Reynolds, J.C.: Separation and information hiding. \nIn: Conference Record of POPL 2004: the 31st ACM SIGACT-SIGPLAN Symposium on Principles of Programming \nLanguages, New York, ACM Press (2004) 268 280 [22] Bruce, K.C., Cardelli, L., , Pierce, B.C.: Comparing \nobject encodings. In: Theoretical Aspects of Computer Software. Volume 1281 of Lecture Notes in Computer \nScience. Springer, Berlin, Heidelberg, New York (1997) 415 438 [23] F\u00a8ahndrich, M., Leino, K.R.M.: Declaring \nand checking non-null types in an object-oriented language. In: OOPSLA 03 Conference Proceedings Object-Oriented \nProgramming Systems, Languages and Applications, New York, ACM Press (2003) 302 312 [24] Foster, J.S., \nTerauchi, T., Aiken, A.: Flow-sensitive type quali.ers. In: Proceedings of the ACM SIGPLAN 02 Conference \non Programming Language Design and Implementation, New York, ACM Press (2002) 1 12 [25] F\u00a8ahndrich, M., \nLeino, K.R.M.: Heap monotonic typestates. In: Informal Proceedings of International Workshop on Aliasing, \nCon.nement and Ownership in object-oriented programming (IWACO) , Utrecht University, Netherlands (2003) \n[26] Walker, D., Morrisett, G.: Alias types for recursive data structures. In: Types in Compilation: \nThird International Workshop, TIC 2000. Volume 2071 of Lecture Notes in Computer Science., Berlin, Heidelberg, \nNew York, Springer (2001) 177 206 [27] Reynolds, J.: Separation logic: a logic for shared mutable data \nstructures. In: Logic in Computer Science, Los Alamitos, California, IEEE Computer Society (2002) 55 \n74 [28] Smith, F., Walker, D., Morrisett, J.G.: Alias types. In Smolka, G., ed.: ESOP 00 Programming \nLanguages and Systems, 9th European Symposium on Programming. Volume 1782 of Lecture Notes in Computer \nScience., Berlin, Heidelberg, New York, Springer (2000) 366 381 [29] Tofte, M., Talpin, J.P.: Implementation \nof the typed call-by-value .-calculus using a stack of regions. In: Conference Record of the Twenty-.rst \nAnnual ACM SIGACT/SIGPLAN Symposium on Principles of Programming Languages, New York, ACM Press (1994) \n188 201 [30] Walker, D., Crary, K., Morrisett, G.: Typed memory management via static capabilities. ACM \nTransactions on Programming Languages and Systems 22 (2000) 701 771 [31] Monnier, S.: Typed regions. \nIn: Informal Proceedings of Second workshop on Semantics, Program Analysis, And Computing Environments \nFor Memory Management , University of Copenhagen (2004) [32] Werner, B.: Une Th\u00b4eorie des Constructions \nInductives. PhD thesis, L Universit\u00b4e Paris VII (1994) [33] Boyapati, C., Lee, R., Rinard, M.: Ownership \ntypes for safe programming: preventing data races and deadlocks. In: OOPSLA 02 Conference Proceedings \nObject-Oriented Programming Systems, Languages and Applications, New York, ACM Press (2002) 211 230 [34] \nBoyapati, C., Salcianu, A., Beebee, W., Rinard, M.: Ownership types for safe region-based memory management \nin real-time java. In: Proceedings of the ACM SIGPLAN 03 Conference on Programming Language Design and \nImplementation, New York, ACM Press (2003) 324 337  APPENDIX Most of the lemmas and all of the proofs \nare available in an electronic appendix available from the page http://www.cs.uwm.edu/faculty/boyland/papers/connecting2.html. \n \n\t\t\t", "proc_id": "1040305", "abstract": "\"Adoption\" is when on piece of stat is logically embedded in another piece of state. Adoption provides information hiding (the adopter can be used as a proxy for the adoptee) and with linear existentials, provides a way to store unique pointers in shared state. In this paper, we give an operational semantics of adoption in a simple procedural language with pointers to records. We define a \"permission\" type-system that uses adoption to model both effects and uniqueness. We prove type soundness (well-typed programs don't go wrong) and state separation (separately-typed statements cannot access the same state). Then we show how high-level effects and uniqueness annotations can be expressed in the type-system. The distinction between read and write effects is ignored in the body of this paper.", "authors": [{"name": "John Tang Boyland", "author_profile_id": "81100598730", "affiliation": "University of Wisconsin--Milwaukee, Milwaukee, WI", "person_id": "P143027", "email_address": "", "orcid_id": ""}, {"name": "William Retert", "author_profile_id": "81100150517", "affiliation": "University of Wisconsin--Milwaukee, Milwaukee, WI", "person_id": "P502278", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1040305.1040329", "year": "2005", "article_id": "1040329", "conference": "POPL", "title": "Connecting effects and uniqueness with adoption", "url": "http://dl.acm.org/citation.cfm?id=1040329"}