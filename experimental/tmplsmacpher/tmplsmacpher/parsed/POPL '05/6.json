{"article_publication_date": "01-12-2005", "fulltext": "\n A Syntactic Approach to Eta Equality in Type Theory Healfdene Goguen AT&#38;T Labs 180 Park Ave. Florham \nPark NJ 07932 USA hhg@att.com ABSTRACT This paper outlines an elementary approach for showing the decidability \nof type checking for type theories with \u00df.\u00adequality, relevant to foundations for modules systems and \ntype theory-based proof systems. The key to the approach is a syntactic translation mapping terms in \nthe \u00df. presentation into their full .-expansions in the \u00df presentation. Decidabil\u00adity of type checking \nis lifted from the target \u00df presentation to the \u00df. presentation. The approach extends to other in\u00adductive \nkinds with a single constructor, and is demonstrated for singletons and dependent pairs.  Categories \nand Subject Descriptors F.4.1 [Theory of Computation]: Lambda calculus and related systems General Terms \nTheory, Languages  Keywords Logical frameworks, type checking, decidability, beta-eta equality 1. INTRODUCTION \nIn this article we introduce an elementary approach to the metatheory of type theories with \u00df.-style \nequalities. These weakly extensional equational theories have applications to programming languages, \nespecially for understanding mod\u00adules systems like that of Standard ML [20], to categorical combinators \n[18] and systems of explicit substitution [1], and to the foundations of type theory-based proof assistants \n[19]. Our intention in this article is to justify the weakly exten\u00adsional . rules by translating them \ninto a system with only the traditional \u00df-style computation rules. Practically, our ap\u00adproach provides \na short and direct proof of the decidability Permission to make digital or hard copies of all or part \nof this work for personal or classroom use is granted without fee provided that copies are not made or \ndistributed for pro.t or commercial advantage and that copies bear this notice and the full citation \non the .rst page. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires \nprior speci.c permission and/or a fee. POPL 05, January 12 14, 2005, Long Beach, California, USA. Copyright \n2005 ACM 1-58113-830-X/05/0001 ...$5.00. of type theories with the additional equality rules. This con\u00adtrasts \nwith other approaches to .-reduction by not requir\u00ading extensive redevelopment for a \u00df.-system given \nexisting results for the \u00df-system. Philosophically, our approach ex\u00adplains uniqueness rules without a \nclear computational justi\u00ad.cation in terms of the well-understood computational rules. We begin by studying \nMartin-L\u00a8of s Logical Framework with .-kinds and \u00df. equality. In this case \u00df. reduction is strongly normalizing \nand Church Rosser, and so we could use this relation directly to implement an algorithm for test\u00ading \nconversion. We follow by studying the extension of the Logical Frame\u00adwork with singletons and dependent \npairs at the level of kinds, similar to that of Stone and Harper [22], although our singletons include \nexplicit term constructors and elimi\u00adnation constants. This language has the key di.culties that the \nequalities are type-directed and that the .-equalities di\u00adrected as reductions do not have the Church \nRosser prop\u00aderty, and so conversion must be implemented by a cus\u00adtomized algorithm, as done by Stone \nand Harper, or by conversion in the target language as we do here. Our development of the metatheory \nbegins by de.ning the source language with the additional .-style equalities over fully decorated terms, \nas introduced by Streicher [23] but with full labels for variables and abstraction. Each term constructor \ncontains explicit labels allowing the reconstruc\u00adtion of the premises in the rule of inference; for example, \nthe application constructor AppBx:A(M, N) allows us to infer that M must have kind .x : A.B and N must \nhave kind A, even from a judgement G f AppBx:A(M, N): C. Because of this explicit information in the \nterm structure, we are able to de.ne a total translation from terms in the source language into the target \nlanguage, without reference to derivations of well-kindedness. We reuse the basic de.nition of type-directed \n.-expansion, like that used in de.ning .-long normal forms [6, 9]. The new approach taken here is to \napply that expansion to ev\u00adery subterm of the source term. The labels in the fully dec\u00adorated terms are \nused to provide the kind information for the .-expansion of each term constructor. We give a simple proof \nthat the translation function preserves substitution, and the soundness of the translation follows by \ninduction on derivations of the source language. The target language of the interpretation is formed \nfrom \u00df-equality over unlabeled terms, i.e. the terms of the un\u00adtyped .-calculus. This is necessary because \n\u00df-reduction un\u00adder the translation does not preserve the kind labels of .\u00adreduction: writing .A(M) for \nthe .-expansion of M at kind A, we only have that ..x:C.D(AppDx:C (.Bx:A(M),x A)) reduces to .Dx:C (M), \nnot to .Bx:A(M) as would be required by a fully decorated term language. 1.1 Related Work Deciding \u00df.-equality \nis a long-standing problem in type theory. While various approaches have been studied exten\u00adsively, including \ninterpreting the .-style equality rules as ei\u00adther reduction rules [10, 12, 21] or expansion rules [11], \neach of these approaches su.ers from de.ciencies. The systems arising from interpreting .-equality rules \nas reductions can fail to be con.uent [17, 18], invalidating the primary advan\u00adtage of the reduction \napproach. Interpreting the .-equality rules as expansions appears natural for simple type systems, but \nit becomes increasingly unnatural for more complex type theories: for example, Ghani s treatment of .-expansions \nfor the Calculus of Constructions [11] requires kinds of ex\u00adpanded abstractions to be in normal form. \nBarthe [2] and Joachimski [16] study strong normalization for . expansions given the strong normalization \nof \u00df. reduction for the type theory with \u00df. equality, and so their results will also fol\u00adlow for type \ntheories with \u00df equality where our approach applies. Salvesen [21] gives a syntactic proof of Church \nRosser for \u00df.-reduction, but this proof makes the much stronger as\u00adsumption that \u00df.-reduction is strongly \nnormalizing, instead of just \u00df-reduction. In practice this assumption is di.cult to establish without \nChurch Rosser for most systems. Geuvers [10] also relates systems with \u00df.-reduction to those with \u00df\u00adreduction, \nbut his proof is much more complex and relies on properties of untyped conversion. Di Cosmo and Kesner \n[8] also use .-expansions in a trans\u00adlation to a target language, where a simply-typed source language \nwith . expansions is shown con.uent and strongly normalizing; since the article treats simple types it \nis not clear whether it would extend to dependent types, since the system with \u00df. equality has di.erent \nvalid judgements than the system with \u00df equality. Coquand, Pollack and Takeyama [6] use partial equivalence \nrelations to show that weakly extensional equality in a type theory can be modeled by untyped \u00df-equality, \nand they show the correctness and decidability of type checking for a Logical Framework with singletons \nand dependent pairs. Coquand [5] and Harper and Pfenning [15] treat the decid\u00adability of type checking \nby de.ning logical relations directly over speci.c choices of algorithms for type checking. This article \nonly treats the decidability of type checking for \u00df. equality, as opposed to studying particular algorithms \nfor type checking. A subsequent article [14] begins to study jus\u00adtifying algorithms for type checking \nmore sophisticated than simple reduction to common normal form, including Co\u00adquand s and Harper and Pfenning \ns for the Logical Frame\u00adwork, on the basis of \u00df. normalization. 1.2 Overview In Section 2 we introduce \nthe judgements for the Logical Framework over two separate term languages, fully deco\u00adrated and unlabeled \nterms. In Section 3 we introduce the basic metatheory, primarily for the target language. In Sec\u00adtions \n4 and 5 we show the soundness and completeness of \u00df\u00adequality on unlabeled .-terms for the fully decorated \nterms under \u00df.-equality, and in Section 6 we show that type check\u00ading for the full source language is \ndecidable. In Section 7 we extend the proofs to singletons and dependent pairs, and in Section 8 we summarize \nand outline future work.  2. SYNTAX The term language of the Logical Framework is given by the following \ngrammar: A, B, C, D . Kind ::= Type | El(M) | .x : A.B A | .B M, N, P, Q . Term ::= x x:A(M) | AppB (M, \nN) x:A G, ., F . Ctxt ::= () | G,x : A We identify terms and kinds that are equivalent up to the renaming \nof bound variables, and we write M = N if M and N are equal in this way. We write FV(M) for the free \nvariables in a term M, those variables not bound by abstractions. We write [N/x]M for the usual capture-free \nsubstitution of N for occurrences of the variable x in M. Each of these operations is lifted to kinds \nand contexts in the natural way. As we have mentioned earlier, in this article we consider two versions \nof Martin-L\u00a8of s Logical Framework, with judge\u00adments G f+ M = \u00df N : A and G f+ M = \u00df. N : A. We write \nG f+ M = N : A for the remainder of this section, with the understanding that the rules of inference \npresented here de\u00ad.ne = \u00df., and that = \u00df is de.ned by the same rules without the rule of inference .. \nThe Logical Framework has several judgements: f+ G valid, meaning G is a valid context, G f+ A kind, \nmeaning A is a valid kind in context G,  G f+ M : A, meaning M is a valid term of kind A in context \nG,  G f+ A = B kind, meaning A and B are equal in context G, and  G f+ M = N : A, meaning M and N are \nequal and of kind A in context G.  The derivations are given by the following rules of infer\u00adence. (Emp) \nf+ () valid G f+ A kind x . FV(G) (Ext) f+ G,x : A valid G valid (Type) G f+ Type kind G f+ M : Type \n(El) G f+ El(M) kind G f+ A kind G,x : A f+ B kind (.) G f+ .x : A.B kind Figure 1: Contexts and Kinds \nf+ G valid (Type) G f+ Type = Type kind G f+ M = N : Type (El) G f+ El(M) = El(N) kind G f+ A = C kind \nG,x : A f+ B = D kind (.) G f+ .x : A.B =.x : C.D kind Figure 2: Kind Equality f+ G valid x : A . G (Var)G \nf+ xA : A G f+ A kind G,x : A f+ B kind G,x : A f+ M : B (.) G f+ .Bx:A(M ):.x : A.B G f+ A kind G,x \n: A f+ B kind G f+ M :.x : A.B G f+ N : A (App) G f+ AppBx:A(M, N):[N/x]B G f+ M : A G f+ A = B kind \n(Eq) G f+ M : B Figure 3: Terms 2.1 Unlabeled Terms Finally, our development also requires a type system \nfor unlabeled terms, i.e. the terms of the untyped .-calculus. The reduction relation 1\u00df is exactly the \nreduction of the untyped .-calculus. As mentioned in the introduction, we translate the source language \nto unlabeled .-terms because the labels in .-reduction are not preserved by the transla\u00adtion. The judgement \nforms for the unlabeled target language are the same as those for the fully decorated target language. \nWe distinguish by annotating the turnstile f- \u00df . The rules of inference are also identical: the distinction \nbetween the labeled and unlabeled systems lies in the information that can be extracted from terms, not \nderivations.  3. BASIC METATHEORY 3.1 Properties of the Source Language De.nition 1. De.ne the principal \nkind P(M) by case anal\u00adysis on M: P(x A)= A B P(.x:A(M)) = .x : A.B P(AppBx:A(M, N)) = [N/x]B Lemma 1. \nIf G f+ M : A then G f+ M : P(M) as a \u00df. \u00df. subderivation, and either P(M) = A or G f+ P(M)= \u00df. A kind \nas a subderivation. Proof. By induction on derivations. x : A . G (Var) A G f+ x= xA : A G f+ A = C kind \nG,x : A f+ B = D kind G,x : A f+ M = N : B (.) G f+ .B (M)= .D (N):.x : A.B x:Ax:C G f+ A = C kind G,x \n: A f+ B = D kind G f+ M = P :.x : A.B G f+ N = Q : A (App) G f+ AppB (M, N) = AppD (P, Q):[P/x]B x:Ax:C \nG,x : A f+ M : B G f+ N : A G f+ [N/x]M :[N/x]B (\u00df) G f+ AppB (.B (M),N)=[N/x]M :[N/x]B x:Ax:A G f+ M \n:.x : A.B (.) G f+ .B (AppB (M, xA)) = M :.x : A.B x:Ax:A G f+ M = N : A G f+ A = B kind (Eq) G f+ M \n= N : B G f+ M : A (Re.) G f+ M = M : A G f+ M = N : A (Sym) G f+ N = M : A G f+ M = N : A G f+ N = P \n: A (Trans) G f+ M = P : A Figure 4: Term Equality The following notation x : A . M means that A = B \nfor B all free occurrences of x in M . De.nition 2. De.ne x : A . M inductively as follows: x : A . \nx A .  x : A . y B  if x= y. x : A . .Cx:B(M).  x : A . .C y, x : A . B, x : A . C and  y:B (M) \nif x= x : A . M. x : A . AppCx:B(M, N).  x : A . AppCy:B  (M, N) if x= y, x : A . B, x : A . C, x \n: A . M, and x : A . N. The extension to kinds x : A . B is straightforward. Lemma 2. If G f+ B kind \nand x : A . G then x : A . B. \u00df. If G f+ M : B and x : A . G then x : A . M. \u00df. Proof. By induction on \nderivations. 3.2 Properties of the Target Language We assume that the standard properties hold for the \ntar\u00adget language, the Logical Framework with fully decorated terms and \u00df-equality. We also take 1\u00df to \nbe the usual com\u00adpatible closure of \u00df-reduction with no restrictions on the labels, that is: DB Appx:C \n(.x:A(M),N) \u00df [N/x]M Proposition 1. 1. If G f+ \u00df M : A then FV(M) . FV(A) . dom(G). 2. If G, G. f+ \u00df \nJ, x . dom(G) . dom(G.) and G f+ \u00df A kind then G,x : A, G. f+ \u00df J. 3. If G,x : A, G. f+ J and G f+ N \n: A then G, [N/x]G. f+  \u00df\u00df \u00df [N/x]J. 4. If G f+ \u00df M : A then G f+ \u00df A kind. 5. If G f+ M : A and G \nf+ M : B then G f+ A = B kind.  \u00df\u00df \u00df 6. If G f\u00df + .x : A.B = \u00df .x : C.D kind then G f\u00df + A = \u00df C kind \nand G,x : A f+ \u00df B = \u00df D kind. 7. If G f+ M = \u00df N : A then M = \u00df N.  Proof. This is largely standard, \nfollowing Streicher [23]. One subtlety of our presentation is that the rule \u00df has a premise that G f\u00df \n+ [N/x]M :[N/x]B. The equivalence with the usual presentation can be demonstrated by .rst proving Cases \n2 and 3 for our presentation, and then show\u00ading the equivalence of the two presentations by induction \non derivations of each system. Alternatively, the properties listed here can be shown directly for our \npresentation using a Kripke-style model construction [3, 13]. 3.3 The Unlabeled Target Language The \njudgements in the unlabeled system have the prop\u00aderties of Proposition 1, as well as the following standard \nproperties. Proposition 2. 1. If G f- \u00df M : A and M 1\u00df N then G f- \u00df N : A. 2. If G f- \u00df M : A then \nM is strongly normalizing under 1\u00df . 3. Typechecking for f- \u00df is decidable.   4. SOUNDNESS We now \nshow that the .-expansions of terms typable in the \u00df.-system are typable in the \u00df-system. We begin by \nde.ning two maps on terms, .A(-) and H(-). Intuitively, .A(M) represents the .-expansion of M at kind \nA, and H(M) replaces all subterms of M with their .-expansions at their principal kinds. This translation \nin\u00adserting .-expansions through all subterms clearly models . equality, since the subterm M in an .-redex \n.Bx:A(AppDx:C (M, xE)) will be translated to a .-abstraction, and so the translation of the .-redex is \n\u00df-equal to the translation of its reduct. De.nition 3. De.ne .A(M), for M an unlabeled .-term, by induction \non A: .Type(M)= M .El(P )(M)= M ..x:A.B (M)= .x..[.A(x)/x]B(M(.A(x))) Lemma 3. 1. If G f- \u00df M : A then \nG f- \u00df .A(M): A. 2. If G f- \u00df M = N : A then G f- \u00df .A(M)= .A(N): A.  Proof. Each follows by induction \non the length of A. Lemma 4. 1. [N/x](.A(M)) = .[N/x]A([N/x]M ). 2. If A 1\u00df B then .A(M ) = .B (M). \n 3. .A(.A(M)) 1 * \u00df .A(M) and ..x:A.B (..x:A.B(M)) 1+ \u00df ..x:A.B(M). Proof. Case 1 follows by induction \non A, and Case 2 follows by induction on derivations of A 1\u00df B and inversion of the de.nition of .A(M). \nCase 3 follows by induction on A. We consider .x : A.B, where we assume x . FV(M): ..x:A.B (..x:A.B (M)) \n= .x..[.A(x)/x]B(..x:A.B (M)(.A(x))) = .x..[.A(x)/x]B((.x..[.A(x)/x]B(M(.A(x))))(.A(x))) 1\u00df .x..[.A(x)/x]B(.[.A(x)/x]B \n(M(.A(.A(x))))) 1 * .x..[.A(x)/x]B(M(.A(x))) \u00df = ..x:A.B (M) De.nition 4. De.ne H(A) and H(M) by structural \nin\u00adduction: H(Type) = Type H(El(P )) = El(H(P )) H(.x : A.B)=.x : H(A).H(B) H(x A)= .H(A)(x) B H(.x:A(M)) \n= ..x:H(A).H(B)(.x.H(M)) B H(Appx:A(M, N)) = .[H(N)/x]H(B)(H(M)(H(N))) The H(-) map extends to contexts \nin the obvious way. Lemma 5. .H(P(M))(H(M)) 1 * \u00df H(M). Furthermore, if P(M) = .x : A.B then .H(.x:A.B)(H(M)) \n1+ \u00df H(M ). Proof. By induction on M, using Lemma 4 Case 3 di\u00adrectly for each term constructor. The following \nlemma is similar to typical substitution lem\u00admas. We need to include the side condition that x not occur \nfree in its kind because the de.nition of H(-) is for arbitrary terms and kinds, not only well-formed \nones, and so imposes no conditions on subterms of its argument. The side con\u00addition will always hold \nfor terms and kinds in well-formed judgements. Lemma 6. 1. If x : C . A, H(C)= \u00df H(P(P )) and x . FV(H(C)) \nthen [H(P )/x]H(A) 1 * \u00df H([P/x]A). 2. If x : C . M, H(C)=\u00df H(P(P )) and x . FV(H(C)) then [H(P )/x]H(M) \n1 * \u00df H([P/x]M).  Proof. By induction on A and M. We consider several cases. x A . Then: [H(P )/x].H(A)(x) \n= .[H(P )/x]H(A)(H(P )) = .H(A)(H(P )) = .H(P(P ))(H(P )) 1 * H(P ) \u00df by Lemma 5, since x . FV(H(C)) \nand x : C . x A implies C = A by inversion. y B . Then [H(P )/x].H(B)(y) = .[H(P )/x]H(B)(y) = .H([P/x]B)(y), \nby Lemma 4 Case 2 since [H(P )/x]H(B)1 * \u00df H([P/x]B) by induction hypothesis. .By:A(M). Then, by de.nition, \nLemma 4 Cases 1 and 2 and induction hypothesis: [H(P )/x]H(.By:A(M)) = [H(P )/x]..y:H(A).H(B)(.y.H(M \n)) = ..y:[H(P )/x]H(A).[H(P )/x]H(B)([H(P )/x].y.H(M)) = ..y:H([P/x]A).H([P/x]B)([H(P )/x].y.H(M)) = \n..y:H([P/x]A).H([P/x]B)(.y.[H(P )/x]H(M)) 1 * ..y:H([P/x]A).H([P/x]B)(.y.H([P/x]M)) \u00df [P/x]B = H(.([P/x]M)) \ny:[P/x]A B = H([P/x](.y:A(M))) Theorem 1 (Soundness). If G f+ A kind then H(G) f- H(A) kind. \u00df. \u00df f+ \nf- If G A = \u00df. B kind then H(G) H(A)= \u00df H(B) kind.  If G f+ M : A then H(G) f- H(M): H(A).  \u00df. \u00df \nf+ f- If G M = \u00df. N : A then H(G) H(M)= \u00df H(N): H(A). Proof. By induction on derivations. We consider \nseveral cases. Var. H(G) f- H(x A) = .H(A)(x): H(A) by Var and Lemma 3.  App. By induction hypothesis \nH(G) f- \u00df H(M): H(.x : A.B) = .x : H(A).H(B) and H(G) f- \u00df H(N): H(A), so H(G) f- \u00df H(M)(H(N)) : [H(N)/x]H(B) \nby App.  Then: f- B H(G) H(App(M, N)) \u00dfx:A= .[H(N)/x]H(B)(H(M)(H(N))) :[H(N)/x]H(B) by Lemma 3, and \nH(G) f- [H(N)/x]H(B)=\u00df H([N/x]B) kind by Lemma 6, Proposition 1 Case 4 (for f-) and Sub\u00adject Reduction \n(Proposition 2 Case 1), so H(G) f- \u00df H(AppBx:A(M, N)) : H([N/x]B) by Eq. H(.B H(.x : A.B) and H(G) f- \nH(N): H(A), so H(G) f- H(AppBx:A(.Bx:A(M ),N)) = .[H(N)/x]H(B)(H(M)(H(N))) : [H(N)/x]H(B)= \u00df H([N/x]B) \nby Lemma 3 and rea\u00adsoning similar to App for the kind equality. Further\u00admore, by inversion G,x : A f+ \nM : B, so x : A . M by Lemma 2. By Lemma 1, there either exists a sub\u00adderivation of G f+ P(N)= \u00df. A, \nin which case by in\u00adduction hypothesis H(G) f- H(P(N)) =\u00df H(A) kind, or P(N) = A, in which case H(G) \nf- H(P(N)) = \u00df H(A) kind by Proposition 1 Case 4 and Re.; fur\u00adthermore, in either case x . FV(H(A)) by \nProposi\u00adtion 1 Case 1. Similarly, H(G) f- H(P([N/x]M)) =\u00df H([N/x]B) and x . FV(H([N/x]B)). \u00df. By induction \nhypothesis H(G) f- x:A(M)) : Therefore, by Lemma 4 Cases 2 and 3 and Lemma 6: (.B = .[H(N)/x]H(B)(.H(.x:A.B)(.x.H(M))(H(N))) \n= .[H(N)/x]H(B)(.x..[.H(A)(x)/x]H(B)( H(AppBx:Ax:A(M ),N)) (.x.H(M))(.H(A)(x)))(H(N))) 1\u00df .[H(N)/x]H(B)(.[.H(A)(H(N))/x]H(B)( \n(.x.H(M))(.H(A)(H(N))))) = .[H(N)/x]H(B)(.[.H(P(N))(H(N))/x]H(B)( (.x.H(M))(.H(P(N))(H(N))))) 1 * \u00df .[H(N)/x]H(B)(.[H(N)/x]H(B)( \n(.x.H(M))(H(N)))) 1\u00df .[H(N)/x]H(B)(.[H(N)/x]H(B)([H(N)/x]H(M))) 1 * .[H(N)/x]H(B)(H([N/x]M)) \u00df = .H([N/x]B)(H([N/x]M)) \n= .H(P([N/x]M))(H([N/x]M)) 1 * \u00df H([N/x]M) .. By Lemma 1 either G f+ P(M)=\u00df. .x : A.B as a subderivation, \nin which case by induction hypothesis H(G) f- H(M): H(.x : A.B), or P(M) = .x : A.B; in either case H(G) \nf- H(P(M)) = \u00df H(.x : A.B). Therefore: H(.Bx:A(AppBx:A(M, xA))) = .H(.x:A.B)(.x..[.H(A)(x)/x]H(B)( H(M)(.H(A)(x)))) \n= .H(.x:A.B)(.H(.x:A.B)(H(M )) 1+ \u00df .H(.x:A.B)(H(M)) = .H(P(M))(H(M)) 1 * \u00df H(M)  5. COMPLETENESS This \nsection shows that the judgements in the target lan\u00adguage can be lifted to judgements in the source language: \nthat is, judgements under the .-expansion translation H(-) in the system with unlabeled terms and \u00df equality \ncan be lifted to the system with decorated terms and \u00df. equality. First, we show that lifting equality \nover unlabeled terms to the fully decorated terms is possible: this is because the derivations of well-formedness \nof unlabeled terms contain all of the kind information necessary to assign kinds in the deco\u00adrated terms. \nOur presentation relating fully decorated terms and unlabeled terms is strongly in.uenced by Streicher \n[23]. Then we de.ne an .-expansion translation with fully deco\u00adrated terms as the target, and show that \nall terms are \u00df.\u00adequal to themselves under the translation. The composition of these two operations is \nequivalent to the original transla\u00adtion from fully decorated terms to unlabeled terms, and so Completeness \nfollows from the properties of each component of the translation. We begin by de.ning the stripping function \nfrom fully decorated terms to unlabeled terms. De.nition 5. De.ne the stripping function |M| by induc\u00adtion \non M: |Type| = Type |El(P )| = El(|P |) |.x : A.B| =.x : |A|.|B| |x A| = x B |.x:A(M)| = .x.|M| |AppB \n(M, N)| = |M |(|N |) x:A Lemma 7. If G f+ M : A, G f+ N : A and |M|=|N| \u00df\u00df then G f+ M = \u00df N : A. Proof. \nAs in [23]. Lemma 8. 1. If G f- \u00df M : A then there is a P such that G f+ \u00df P : A and |P |= M. 2. If \nG f- M = \u00df N : A then there are P and Q such that G f+ P = \u00df Q : A, |P |= M and |Q|= N.  Proof. As in \n[23]. The following map H+(M) di.ers from H(M) only by mapping to fully decorated terms instead of unlabeled \nterms. De.nition 6. De.ne .+(M) by induction on A: A .+ Type(M)= M .+ (M)= M El(P ) BB A ..x:A.B(M)= \n.x:A(Appx:A(M, x)) De.ne H+(M) by induction on M: H+ (Type) = Type H+(El(P )) = El(H+(P )) H+(.x : A.B)=.x \n: H+(A).H+(B) H+(x A)= .+ (x A) H+(A)H+(.Bx:A(M)) = H+(B) .+ (.(H+(M ))) .x:H+(A).H+(B)x:H+(A) H+(AppBx:A(M, \nN)) = H+(B) .+ (App(H+(M),H+(N))) [H+(N)/x]H+(B)x:H+(A) The H+(-) map extends to contexts in the obvious \nway. Lemma 9. |H+(M)|= H(M). Proof. Induction on M. Lemma 10. If G f+ M : A then G f+ M = \u00df. H+(M): \u00df. \nA. Proof. By induction on M, using Lemma 1 and the sim\u00adple lemma that G f+ M = \u00df. .A(M): A. Theorem 2 \n(Completeness of Equality). 1. If G f+ M, N : A and H(G) f- H(M)= \u00df H(N): \u00df. H(A) then G f+ M = \u00df. N \n: A. 2. If G f+ A, B kind and H(G) f- H(A)=\u00df H(B) kind \u00df. then G f+ A = \u00df. B kind. Proof. We show Case \n1, where Case 2 is similar. We know by Lemma 9 that H(G) f- |H+(M)| = \u00df |H+(N)| : H(A). By Lemma 8 there \nare P and Q such that G f+ P = \u00df Q : A with |P |=|H+(M)| and |Q|=|H+(N)|. Therefore G f+ P = \u00df H+(M): \nA and G f+ Q = \u00df H+(N): A by Lemma 7, so G f+ H+(M)= \u00df H+(N): A by Trans and G f+ M = \u00df. N : A by Trans \nand Lemma 10. Corollary 1 (Completeness). If G f- J then there are . and J. such that . f+ , |.|= G and \n|J.|= J. J. It is now possible to lift the metatheory of the f\u00df sys\u00adtem to the f\u00df. system. The following \nreduction relation 1|\u00df.| ignores the labels on the fully decorated terms. As we mentioned in the introduction, \nthis relation is strongly normalizing and Church Rosser, and so this could be the basis for an algorithm \nfor testing conversion. De.nition 7. De.ne the relations \u00df and . as: DB Appx:C (.x:A(M),N) \u00df [N/x]M DB \nE .x:C (Appx:A(M),x ) .M De.ne reduction 1|\u00df.| as the compatible closure over term and kind constructors \nthat ignores labels of \u00df.; for example, the compatible closure of application is completely de.ned by: \nIf M 1 P then AppB (M, N) 1 AppB (P, N). x:Ax:A If N 1 P then AppB (M, N) 1 AppB (M, P ). x:Ax:A Lemma \n11. If G f+ M : A and M 1|\u00df.|N then H(M)1+ \u00df. \u00df H(N). Proof. By induction on M 1\u00df. N, where the compatible \nclosure rules follow by induction hypothesis. For \u00df, we need to show that H(AppDx:A(M),N)) 1 * (.B x:C\u00df \nH([N/x]M), where G f+ AppxD :Cx:A(M),N): E. By in\u00ad (.B \u00df. version G f+ .xB :A(M):.x : A.B and G f+ .x \n: A.B = \u00df. \u00df. .x : C.D, so H(G) f- \u00df H(.x : A.B)= \u00df. H(.x : C.D). By Proposition 1 Case 7 and Church \nRosser H(A)= \u00df H(C) and H(B)=\u00df H(D), so: DB BB H(Appx:C (.x:A(M),N)) = H(Appx:A(.x:A(M),N)) and the reduction \nsequence follows as for rule \u00df in Sound\u00adness. The reasoning for .-reduction is similar. The properties \nlisted in Proposition 1 can now be shown directly or transferred from the target language to the source \nlanguage. Proposition 3. 1. If G f+ M : A then FV(M) . FV(A) . FV(G). \u00df. 2. If G, G. f+ J, G f+ A kind \nand x . FV(G) . FV(G.) \u00df. \u00df. then G,x : A, G. f+ J. \u00df. 3. If G,x : A, G. f+ J and G f+ N : A then G, \n[N/x]G. f+ \u00df. \u00df. \u00df. [N/x]J. 4. If G f+ M : A then G f+ A kind. \u00df. \u00df. 5. If G f+ M : A and G f+ M : B \nthen G f+ A = \u00df. \u00df. \u00df. B kind. 6. If G f+ .x : A.B =\u00df. .x : C.D kind then G f+ \u00df. \u00df. A =\u00df. C kind and \nG,x : A f+ B =\u00df. D kind. \u00df. 7. If G f+ M : A and M 1|\u00df.| N then G f+ N : A. \u00df. \u00df. 8. If G f+ M : A then \nM is strongly normalizing under \u00df. 1\u00df..  6. TYPE CHECKING Given the full metatheory of f+ developed \nabove, the de\u00ad \u00df. cidability of type checking is similar to the standard treat\u00adment [19]. The novelty \nin our presentation in this section is that we derive the fully decorated terms, using the standard presentation \nof terms with no labels in variables or applica\u00adtion and a single label for the domain in abstractions. \nDe.nition 8. We de.ne the decorating type checking al\u00adgorithm G; A . B; kind and G; M . P ; A inductively \nas follows: G; Type . Type; kind.  G; El(M) . El(P ); kind if G; M . P ; Type.  G; .x : A.B . .x : \nC.D; kind if G; A . C; kind and G,x : C; B . D; kind.  G; x . x C ; C if x : C . G.  G; .x : A.M . \n.Dx:C (P ); .x : C.D if G; A . C; kind and G,x : C; M . P ; D.  G; M(N ) . AppDx:C (P, Q); [Q/x]D if \nG; M . P ;.x : C.D, G; N . Q; C. and C = |\u00df.| C. .  Lemma 12 (Correctness of the Algorithm). If G; A \n. C; kind then G f+ C kind. \u00df. If G; M . P ; C then G f+ P : C. \u00df. Proof. By induction on derivations \nof G; A . C; kind and G; M . P ; C, using Lemma 3 Case 4 and Completeness for application. We now introduce \na type checking algorithm directly on fully decorated terms to show completeness of the algorithm. Similar \nto our proof of completeness for the target language in the previous section, this allows us to decompose \ncom\u00adpleteness of the algorithm into simpler results about the erasure and the algorithm itself. De.nition \n9. We de.ne the type checking algorithm on fully decorated terms G; A .+ kind and G; P .+ A induc\u00adtively \nas follows: G; Type .+ kind.  G; El(M) .+ kind if G; M .+ Type. .+ .+ A; B .+ kind.  G; .x : A.B \nkind if G; A kind and G,x :  C .+ G; xC if x : C . G.  G; .Dx:C (M ) .+ .x : C.D. if G; C .+ kind, \nG,x : C; D .+ kind, G,x : C; M .+ D. and D = |\u00df.| D. .  G; AppDx:C (M, N) .+ [N/x]D. if G; C .+ kind, \nG,x :  C.. C; D .+ kind, G; M .+ .x : C..D., G; N .+ , C = |\u00df.| C. = |\u00df.| C.. and D = |\u00df.| D. . Lemma \n13. 1. If G f+ A kind then G; A .+ kind. \u00df. 2. If G f+ P : A then there is a C such that G; P .+ C \u00df. \nand G f+ A = C kind. \u00df. Proof. By induction on derivations. Finally, we de.ne a second stripping operation \nstrip(M) that strips o. the labels on variables and applications and the codomain o. of abstractions. \nDe.nition 10. Stripping from the fully decorated terms to the standard presentation of lambda terms is \nde.ned as follows: strip(x A)= x B strip(.x:A(M)) = .x : strip(A).strip(M) B strip(Appx:A(M, N)) = strip(M)(strip(N)) \nObserve that if strip(M) = strip(N) then |M|=|N|, and so Lemma 7 lifts to the map strip(-). Lemma 14. \n1. If G; A .+ kind and strip(G) = strip(G.) then there is an A. such that G; strip(A) . A.; kind and \nstrip(A) = strip(A.). 2. If G; P .+ C and strip(G) = strip(G.) then there are P . and C. such that G.; \nstrip(P ) . P .; C. , strip(C) = strip(C.) and strip(P ) = strip(P .).  Proof. By induction on derivations. \nWe consider P = AppDx:C (M, N). By induction hypothesis G.; strip(M) . M.;.x : C....D.. with strip(.x \n: C....D..) = strip(.x : C..D.), and strip(M) = strip(M.) and G.; strip(N) . ; C.... N.with strip(C..) \n= strip(C....) and strip(N) = strip(N.). = |\u00df.| C... Furthermore, C.... , since by assumption C. = |\u00df.| \nC.. and by Correctness of the Algorithm, Lemma 7 and C.. C.... C... Proposition 1 Case 7 = |\u00df.| and = \n|\u00df.| C. . Therefore: strip([N/x]D.) = strip([N./x]D..) D.. D .. strip(Appx:C (M, N)) = strip(Appx:C... \n(M,N)) .D G; strip(Appx:C (M, N)) = strip(M)(strip(N)) D.. . Appx:C... (M,N); [N/x]D Corollary 2 (Completeness \nof the Algorithm). 1. If G f+ C kind then there is a C. such that G; strip(C) . \u00df. C.; kind. P . 2. If \nG f+ P : C then there are and C. such that \u00df. G; strip(P ) . P .; C. and G f+ C = \u00df. C. kind. Theorem \n3 (Decidability of f+ ). The judgements \u00df. G f+ J are decidable. \u00df. 7. SINGLETONS AND DEPENDENT PAIRS \nWe now extend the above proofs to cover singletons and dependent pairs as well. As we mentioned before, \nthe im\u00adportant di.erence with the earlier sections is that reduction for the system with these kinds \nis not Church Rosser. We begin by presenting the fully decorated syntax for singletons and dependent \npairs, and then outline the metatheory for these new kinds. 7.1 Singletons We introduce new kind and \nterm formers as used in the following rules of inference: G f+ M : A (S) G f+ SA(M) kind G f+ M : A (*) \nG f+ *A(M):SA(M) G f+ N :SA(M) (out) G f+ outA(N): A G f+ M : A (out-*) G f+ outA(*A(M)) = M : A G f+ \nN :SA(M)(*-Uniq) G f+ *A(M)= N :SA(M) plus the obvious compatible closure rules for kind and term formers \nS, * and out. For the unlabeled system, the term formers *(M) and out(M) have no labels. 7.2 Dependent \nPairs G f+ A kind G,x : A f+ B kind (S) G f+ Sx : A.B kind G f+ M : A G f+ N :[M/x]B (pair) G f+ pairBx:A(M, \nN):Sx : A.B G f+ M :Sx : A.B (p) G f+ pBx:A(M ): A G f+ M :Sx : A.B (q) G f+ qB (M) : [pB (M)/x]B x:Ax:A \nG f+ M : A G f+ N :[M/x]B (p-Eq) B G f+ px:A(pairBx:A(M, N)) = M : A G f+ M : A G f+ N :[M/x]B (q-Eq) \nB (pairB (M, N)) = N :[M/x]B G f+ qx:Ax:A G f+ M :Sx : A.B (pair-Uniq) B G f+ pairBx:A(pBx:A(M), qx:A(M)) \n= M :Sx : A.B plus the obvious compatible closure rules for formers S, pair, p and q. Again, for the \nunlabeled system the term formers pair(M, N), p(M) and q(N) have no labels. 7.3 Metatheory We begin \nby assuming that the metatheory of the new kinds is well-behaved for the systems without the weakly extensional \nequalities. These kinds of inductive de.nitions have been studied extensively [12, 24]. The reduction \nrelations are de.ned analogously to those for the Logical Framework with .-kinds. The metatheory of singletons \nand dependent pairs with the weakly extensional equalities closely follows the above development, and \nthe statement of the results in Sections 3, 4 and 5 does not change. We give here the extension of the \nde.nitions to the new kinds and show some examples of the extended proofs for them. De.nition 11. P(* \nA(M)) = SA(M) P(outA(M)) = A P(pairB x:A(M, N)) = Sx : A.B P(pB x:A(M)) = A P(qB x:A(M)) = [pB x:A(M)/x]B \n The de.nitions of x : A . B and x : A . M extend trivially to the new term formers. De.nition 12. .SA(M)(N)= \n*(M) .Sx:A.B (M) = pair(.A(p(M)),.[p(M)/x]B (q(M))) De.nition 13. H(*A(M)) = *(H(M )) H(outA(M)) = .H(A)(out(H(M))) \nB H(pairx:A(M, N)) = .H(Sx:A.B)(pair(H(M),H(N))) B H(px:A(M)) = .H(A)(p(H(M))) H(qBx:A(M)) = .[H(pB (M))/x]H(B)(q(H(M))) \nx:A We now show the case of *-Uniq for Theorem 1. By Lemma 1 G f+ N : P(N) and either P(N) = SA(M) or \nG f+ P(N)=\u00df. SA(M) kind as a subderivation; in the lat\u00adter case we also have P(N) = SA. (M.) and subderivations \nof G f+ M =\u00df. M. : A and G f+ A =\u00df. A. kind, and so by induction hypothesis H(G) f- H(M)=\u00df H(M.): H(A) \nand H(G) f- H(A)= \u00df H(A.) kind. In either case, we have *(H(M)) = .H(P(N))(H(N)) = .H(SA(M))(H(N)) 1 \n* H(N) by Lemma 5, so H(N) =*(H(M)), and so H(G) f- H(N) =*(H(M)) =\u00df *(H(M)) : SH(A)(H(M)) = H(SA(M)). \nFinally, although the equalities corresponding to the weakly extensional equality rules cannot be interpreted \nas reduc\u00adtions because they are not Church Rosser, the translation to the unlabeled terms yields an algorithm \nthat is both strongly normalizing and Church Rosser, and so that algorithm can be used to test conversion \nof the source-language terms.  8. CONCLUSIONS AND FUTURE WORK We have demonstrated that the terms of \nthe source Log\u00adical Framework with \u00df.-equality can be represented in the target language with only \u00df-equality, \nwith the consequence that type checking for the source language is decidable. We further extended our \nresults to show that weakly extensional equality for singletons and dependent pairs is decidable. To \nprovide a complete basis for modules systems, we need to extend our results to include the implicit form \nof single\u00adtons and subtyping. We believe that the additional com\u00adplexity of subtyping in Stone and Harper \ns presentation can be dealt with by applying appropriate .-expansions for the supertype, but we have \nnot studied the technical details: with the interrelated judgements, it is not clear whether the .-expansion \ncan be applied at the judgemental level or if the explicit term language needs to be extended with references \nto subtyping. We are also interested in studying whether the general approach of modeling weakly extensional \nequalities can be extended to include colimit types such as the empty type or sum types. Finally, we \nhave demonstrated [14] that the re\u00adsults established here for the Logical Framework with \u00df. re\u00adduction \nare su.cient to justify the decidability of Coquand s original algorithm for deciding \u00df.-equality [5] \nand Harper and Pfenning s algorithm [15], but we would like to extend this approach to types beyond dependent \nfunction spaces. This article concentrates on type theories su.cient as a theoretical basis for modules \nsystems, and so we are able to avoid a sophisticated model construction for the basic Logical Framework. \nHowever, extending our technique to systems with either impredicativity or higher-order type\u00advalued operators \nwould force us to use some kind of model construction. To see this, consider that for the expansions \nto be sound the type-directed .-expansion function needs to be closed under substitution within its type \nargument, but substituting a type for a type variable in the type argument, for example .x : A.B for \nX, leads to a di.erent expansion. Acknowledgments I would like to thank Mariangiola Dezani for her kind \ninvi\u00adtation to visit the Universit`a di Torino, Robert Harper for suggesting that I study the metatheory \nof singletons, Gilles Barthe for pointing me to [6], Thierry Coquand and Randy Pollack for interesting \ndiscussions on their model construc\u00adtion, Eduardo Bonelli for recommending [8], and Zhaohui Luo for asking \nwhether reduction was preserved by an ear\u00adlier de.nition of the H(-) map. I would also like to thank \nmy wife Adriana Compagnoni both for helpful technical dis\u00adcussions and for her encouragement as I was \nwriting this article. 9. REFERENCES [1] M. Abadi, L. Cardelli, P.-L. Curien, and J.-J. L\u00b4evy. Explicit \nsubstitutions. Journal of Functional Programming, 1(4):375 416, 1991. [2] G. Barthe. Existence and uniqueness \nof normal forms in pure type systems with beta-eta conversion. In Proceedings of Computer Science Logic, \nCSL 98, volume 1584 of Lecture Notes in Computer Science, pages 241 259. Springer Verlag, 1998. [3] A. \nCompagnoni and H. Goguen. Typed operational semantics for higher order subtyping. Technical Report ECS-LFCS-97-361, \nUniversity of Edinburgh, July 1997. A later version is published as [4]. [4] A. Compagnoni and H. Goguen. \nTyped operational semantics for higher-order subtyping. Information and Computation, 184(2):242 297, \nAug. 2003. [5] T. Coquand. An algorithm for testing conversion in type theory. In G. Huet and G. Plotkin, \neditors, Logical Frameworks. Cambridge University Press, 1991. [6] T. Coquand, R. Pollack, and M. Takeyama. \nA logical framework with dependently typed records. Extended version of [7], 2003. [7] T. Coquand, R. \nPollack, and M. Takeyama. A logical framework with dependently typed records. In Proceedings of Typed \nLambda Calculus and Applications, TLCA 03, volume 2701 of Lecture Notes in Computer Science. Springer-Verlag, \n2003. See extended version [6]. [8] R. D. Cosmo and D. Kesner. A con.uent reduction system for the extensional \ntyped lambda-calculus with pairs, sum, recursion and terminal object. In Proceedings of the 20st International \nColloquium on Automata, Languages and Programming (ICALP 93), volume 700 of Lecture Notes in Computer \nScience, pages 645 656. Springer Verlag, July 1993. [9] G. Dowek, G. Huet, and B. Werner. On the de.nition \nof the eta-long normal form in type systems of the cube. In Informal Proceedings of the Workshop on Types \nfor Proofs and Programs, 1993. [10] H. Geuvers. Logics and Type Systems. PhD thesis, Katholieke Universiteit \nNijmegen, Sept. 1993. [11] N. Ghani. Eta-expansions in dependent type theory \u00adthe calculus of constructions. \nIn Typed Lambda Calculus and Applications, volume 1210 of Lecture Notes in Computer Science, pages 164 \n180. Springer Verlag, 1997. [12] H. Goguen. A Typed Operational Semantics for Type Theory. PhD thesis, \nUniversity of Edinburgh, Aug. 1994. [13] H. Goguen. A Kripke-style model for the admissibility of structural \nrules. In Proceedings of TYPES, volume 2277 of Lecture Notes in Computer Science, pages 112 124. Springer \nVerlag, 2000. [14] H. Goguen. Justifying algorithms for beta-eta conversion. 2004. Submitted to FOSSACS \n2005. [15] R. Harper and F. Pfenning. On equivalence and canonical forms in the LF type theory. ACM Trans. \non Computational Logic, 2003. (To appear). [16] F. Joachimski. Syntactic analysis of eta-expansions in \npure type systems. Information and Computation, 182(1):53 71, 2003. [17] J. W. Klop. Combinatory reduction \nsystems. Mathematical Centre Tracts 127, Centre for Mathematics and Computer Science, Amsterdam, 1980. \nPhD thesis [18] J. Lambek and P. J. Scott. Introduction to Higher Order Categorical Logic. Cambridge \nstudies in advanced mathematics. Cambridge University Press, 1989. [19] Z. Luo. Computation and Reasoning. \nOxford University Press, 1994. [20] D. MacQueen. Using dependent types to express modular structure. \nIn Proceedings of the Thirteenth ACM Symposium on the Principles of Programming Languages, 1986. [21] \nA. Salvesen. The Church-Rosser property for pure type systems with \u00df.-reduction, Nov. 1991. Unpublished \nmanuscript. [22] C. A. Stone and R. Harper. Equivalence and singletons. ACM Transactions on Programming \nLanguages and Systems, 2004. Submitted. [23] T. Streicher. Semantics of Type Theory: Correctness, Completeness \nand Independence Results. Birkh\u00a8auser, 1991. [24] B. Werner. Une Th\u00b4eorie des Constructions Inductives. \nPhD thesis, Universit\u00b4e Paris 7, 1994.  \n\t\t\t", "proc_id": "1040305", "abstract": "This paper outlines an elementary approach for showing the decidability of type checking for type theories with &#946;&#951;-equality, relevant to foundations for modules systems and type theory-based proof systems. The key to the approach is a syntactic translation mapping terms in the &#946;&#951; presentation into their full &#951;-expansions in the &#946; presentation. Decidability of type checking is lifted from the target &#946; presentation to the &#946;&#951; presentation. The approach extends to other inductive kinds with a single constructor, and is demonstrated for singletons and dependent pairs.", "authors": [{"name": "Healfdene Goguen", "author_profile_id": "81100630431", "affiliation": "AT&T Labs, Florham Park, NJ", "person_id": "P108442", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1040305.1040312", "year": "2005", "article_id": "1040312", "conference": "POPL", "title": "A syntactic approach to eta equality in type theory", "url": "http://dl.acm.org/citation.cfm?id=1040312"}