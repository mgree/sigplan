{"article_publication_date": "01-12-2005", "fulltext": "\n A Bisimulation for Type Abstraction and Recursion Eijiro Sumii Benjamin C. Pierce University of Pennsylvania \nUniversity of Pennsylvania sumii@saul.cis.upenn.edu bcpierce@cis.upenn.edu ABSTRACT We present a sound, \ncomplete, and elementary proof method, based on bisimulation, for contextual equivalence in a .\u00adcalculus \nwith full universal, existential, and recursive types. Unlike logical relations (either semantic or syntactic), \nour development is elementary, using only sets and relations and avoiding advanced machinery such as \ndomain theory, admissibility, and ..-closure. Unlike other bisimulations, ours is complete even for existential \ntypes. The key idea is to consider sets of relations instead of just relations as bisimulations. Categories \nand Subject Descriptors D.3.3 [Programming Languages]: Language Constructs and Features abstract data \ntypes; F.3.3 [Logics and Mean\u00adings of Programs]: Studies of Program Constructs Type structure General \nTerms Theory, Languages  Keywords Lambda-Calculus, Contextual Equivalence, Bisimulations, Logical Relations, \nExistential Types, Recursive Types 1. INTRODUCTION Proving the equivalence of computer programs is important \nnot only for verifying the correctness of program transfor\u00admations such as compiler optimizations, but \nalso for showing the compatibility of program modules. Consider two mod\u00adules M and M. implementing the \nsame interface I; if these di.erent implementations are equivalent under this common interface, then \nthey are indeed compatible, correctly hiding their di.erences from outside view. Contextual equivalence \nis a natural de.nition of program equivalence: two programs are called contextually equiva\u00adlent if they \nexhibit the same observable behavior when put Permission to make digital or hard copies of all or part \nof this work for personal or classroom use is granted without fee provided that copies are not made or \ndistributed for pro.t or commercial advantage and that copies bear this notice and the full citation \non the .rst page. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires \nprior speci.c permission and/or a fee. POPL 05, January 12 14, 2005, Long Beach, California, USA. Copyright \n2005 ACM 1-58113-830-X/05/0001 ...$5.00. in any legitimate context of the language. However, direct proofs \nof contextual equivalence are typically infeasible, be\u00adcause its de.nition involves a universal quanti.cation \nover an in.nite number of contexts (and naive approaches such as structural induction on the syntax of \ncontexts do not work). This has led to a search for alternative methods for prov\u00ading contextual equivalence, \nwhose fruits can be grouped into two categories: logical relations and bisimulations. Logical relations \n(and their shortcomings). Logical re\u00adlations were .rst developed for denotational semantics of typed \n.-calculi (see, e.g., [24, Chapter 8] for details) and can also be adapted [30, 29] to their term models; \nthis adapta\u00adtion is sometimes called syntactic logical relations [13]. Log\u00adical relations are relations \non terms de.ned by induction on their types: for instance, two pairs are related when their elements \nare pairwise related; two tagged terms ini(M) and inj (N) of a sum type are related when the tags i and \nj are equal and the contents M and N are also related; and, crucially, two functions are related when \nthey map related arguments to related results. The soundness of logical re\u00adlations is proved via the \nFundamental Property (or Basic Lemma), which states that any well-typed term is related to itself. Logical \nrelations are pleasantly straightforward, as long as we stick to the simply typed .-calculus (or even \nthe poly\u00admorphic .-calculus) without recursion. However, their ex\u00adtension with recursion is challenging. \nRecursive functions cause a problem in the proof of the fundamental property that must be addressed by \nintroducing additional unwind\u00ading properties [30, 29, 9, 13]. Recursive types are even more di.cult (in \nparticular with negative occurrences): since log\u00adical relations are de.ned by induction on types, recursive \ntypes require topological properties even in the de.nition of logical relations [9, 13]. Worse, these \ndi.culties are not con.ned to meta-theorems, but are visible to the users of logical relations: in order \nto prove contextual equivalence using logical relations, one often has to prove the admis\u00adsibility, compute \nthe limit, or calculate the ..-closure of particular logical relations. Bisimulations (and their shortcomings). \nBisimulations were originally developed for process calculi [21, 22, 23] and state transition systems \nin general. Abramsky [4] adapted bisimulations to untyped .-calculus and called them applica\u00adtive bisimulations. \nBrie.y, two functions .x. M and .x. M. are bisimilar when (.x. M)N . .. (.x. M ')N . for any N and the \nresults are also bisimilar if these evaluations con\u00adverge. Gordon and Rees [14, 17, 15, 16] extended \napplicative bisimulations to calculi with objects, subtyping, universal polymorphism, and recursive types. \nSangiorgi [32] has de\u00ad.ned context bisimulation, which is a variant of applicative bisimulation for higher-order \np-calculus [32]. Unlike logical relations, bisimulations have no di.culty with recursion (or even concurrency). \nHowever, existing bisimulation methods for typed .-calculi are very weak in the presence of existential \npolymorphism; that is, they are useless for proving interesting equivalence properties of ex\u00adistential \npackages. For instance, consider the two packages int M = pack int, (1, .x : int.x =0) as t ' M= pack \nbool, (true, .x : bool. \u00acx) as t where t = .a. a \u00d7 (a . bool). Existing bisimulation meth\u00adods cannot \nprove the contextual equivalence f M = M' : t of these simple packages, because they cannot capture the \nfact that the only values of type a are 1 in the left-hand world and true in the right-hand world. The \nsame obser\u00advation applies to context bisimulation. The only exceptions to the problem above are bisimula\u00adtions \nfor polymorphic p-calculi [28, 7]. However, p-calculus is name-based and low-level. As a result, it is \nrather di.\u00adcult to encode polymorphic .-calculus into polymorphic p\u00adcalculus while preserving equivalence \n(though there are some results [7] for the case without recursion), so it is at least as di.cult to use \np-calculus for reasoning about abstraction in .-calculus or similar languages with (in particular higher\u00adorder) \nfunctions and recursion. In addition to the problem of encoding, existing bisimulations for polymorphic \np-calculi are incomplete [28] and complex [7]. Encoding existential polymorphism in terms of universal \npolymorphism does not help either. Consider the following encodings of M and M' int N = .f : s. f[int](1, \n.x : int.x =0) ' N= .f : s. f[bool](true, .x : bool. \u00acx) where s = .a. a \u00d7 (a . bool) . ans and ans is \nsome answer type. In order to establish the bisimulation between N and N' , one has at least to prove \nint f[int](1, .x : int.x =0). .. f[bool](true, .x : bool. \u00acx). for any observer function f of type s, \nwhich is almost the same as the de.nition of f M = M' : t . Our solution. We address these problems and \nthereby obtain a sound and complete bisimulation for existential types (as well as universal and recursive \ntypes) by adapt\u00ading key ideas from our previous work [34] on bisimulation for sealing [26, 27], a dynamic \nform of data abstraction. The crucial insight is that we should de.ne bisimulations as sets of relations \nrather than just relations annotated with type information. For instance, a bisimulation X showing the \ncontextual equivalence of M and M' above can be de.ned (roughly) as X = {(\u00d8, R0), (., R1), (., R2), (., \nR3)} where R0 = {(M, M',t )} int R1 = R0 .{((1, .x : int.x =0), (true, .x : bool. \u00acx), a \u00d7 (a . bool))} \nR2 = R1 .{(1, true,a), int (.x : int.x =0, .x : bool. \u00acx, a . bool)} R3 = R2 .{(false, false, bool)} \n.= {(a, int, bool)}. Because we are ultimately interested in the equivalence of M and M', we begin by \nincluding (\u00d8, R0) in X. (The role of the .rst element \u00d8 of this pair will be explained in a moment.) \nNext, since a context can open those packages and examine their contents, we add (., R1) to X, where \n. is a concretion environment mapping the abstract type a to its respective concrete types in the left-hand \nside and the right-hand side. Then, since the contents of the packages are pairs, a context can examine \ntheir elements, so we add (., R2) to X. Last, since the second elements of the pairs are functions of \ntype a . bool, a context can apply them to any arguments of type a; the only such arguments are, in fact, \n1 in the left-hand world and true in the right-hand world, so we add (., R3) to X. Since the results \nof these applications are equal as booleans, there is nothing else that a context can do to distinguish \nthe values in R3. Conceptually, each R occuring in a pair (., R) . X rep\u00adresents the knowledge of a context \nat some point in time, which increases via new observations by the context. In order to prove contextual \nequivalence, it su.ces to .nd a bisimulation X that is closed under this increase of con\u00adtexts knowledge. \n(Thus, in fact, not only X but also the singleton set {(., R3)} is a bisimulation in our de.nition.) \nWhy do we consider a bisimulation X to be a set of Rs (with corresponding .s) instead of taking their \nunion in the .rst place? Because the latter does not exist in general! In other words, the union of two \nvalid Rs is not always a valid R. For instance, consider the union of R3 and its in\u00adverse R-1 = {(V ',V,t) \n| (V,V ',t) .R3}. Although each 3 of them makes perfect sense by itself, taking their union is nonsensical \nbecause it confuses two di.erent worlds (which, in fact, is not even type-safe). This observation is \nabso\u00adlutely fundamental in the presence of type abstraction (or other forms of information hiding such \nas sealing), and it forms the basis of many technicalities in the present work (as well as our previous \nwork [34]). By considering a set of relations instead of taking their union, it becomes straight\u00adforward \nto de.ne bisimilarity to be the largest bisimulation and thereby apply standard co-inductive arguments \nin or\u00adder to prove the completeness of bisimilarity, for instance. (In addition, this also gives a natural \naccount to the gen\u00aderativity of existential types, i.e., to the fact that opening the same package twice \ngives incompatible contents.) Thus, for example, both {(., R3)} and {(.-1 , R-1)} are bisim\u00ad 3 ulations \n(where .-1 = {(a, t, t') | (a, t ',t) . .}) and so is their union {(., R3), (.-1 , R-1)}, but neither \n{(., R3 . 3 R-1 3 )} nor {(.-1 , R3 .R-1)} is. 3 This decision does not incur any signi.cant di.culty \nfor users of our bisimulation: we devise a trick explained be\u00adlow, in the de.nition of bisimulation for \npackages that keeps the set of relations .nite in many cases; even where this trick does not apply, it \nis not very di.cult to de.ne the in.nite set of relations (e.g., by set comprehension or by induction) \nand check it against our de.nition of bisimulation (as we will do in Example 4.3 for generative functors \nor as we did in previous work [34, Examples 4.7 and 4.8] for security pro\u00adtocols). Contributions. This \nis the .rst sound, complete, and ele\u00admentary proof method for contextual equivalence in a lan\u00adguage with \nhigher-order functions, impredicative polymor\u00adphism (both universal and existential), and full recursive \ntypes. As discussed above, previous results in this area were (1) limited to recursive types with no \nnegative occurrence, (2) incomplete for existential types, and/or (3) technically involved.  Many of \nthe ideas used here are drawn from our previous work [34] on a sound and complete bisimulation for untyped \n.-calculus with dynamic sealing (also known as perfect en\u00adcryption). This form of information hiding \nis very di.er\u00adent from static type abstraction. Given the di.erence, it is surprising (and interesting) \nin itself to .nd that similar ideas can be adapted to both settings. Furthermore, the language in the \npresent paper is typed (unlike in our pre\u00advious work), requiring many re.nements to take type infor\u00admation \ninto account throughout the technical development. In general, typed equivalence is much coarser than \nuntyped equivalence in particular with polymorphism because not only terms but also contexts have to \nrespect types. Accord\u00adingly, our bisimulation keeps careful track of the mapping of abstract type variables \nto concrete types, substituting the former with the latter if and only if appropriate. M, N, C, D ::= \nterm x variable fix f(x : t ) : s = M recursive function MN application .a. M type function M[t] type \napplication pack t, M as .a. s packing open M as a, x in N opening (M1, . . . , Mn)#i(M) tupling projection \nini(M) injection case M of in1(x1) . M1 [] ... [] inn(xn) . Mn case branch fold(M) folding unfold(M) \nunfolding U, V, W ::= value fix f(x : t ): s = M recursive function .a. M type function pack t, V as \n.a. s package (V1,...,Vn) tuple ini(V ) injected value fold(V ) folded value p, ., s, t ::= type a type \nvariable t . s function type .a. t universal type .a. t existential type t1 \u00d7 ... \u00d7 tn product type t1 \n+ ... + tn sum type \u00b5a. t recursive type Figure 1: Syntax Overview. The rest of this paper is structured \nas follows. Section 2 presents our language and its contextual equiva\u00adlence, generalized in a non-trivial \nway for open types as re\u00adquired by the technicalities which follow. Section 3 de.nes our bisimulation. \nSection 4 gives examples to illustrate its uses and Section 5 proves soundness and completeness of the \nbisimulation with respect to the generalized contextual equivalence. Section 6 generalizes these results, \nwhich have been restricted to closed values for simplicity, to non-values and open terms. Section 7 discusses \na limitation of our bisimulation concerning higher-order functions. Section 8 discusses related work, \nand Section 9 concludes with future work. Throughout the paper, we use overbars as shorthands for sequences \ne.g., we write x,[V /x], (a, s, s ' ) and x : t in\u00adstead of x1,...,xn,[V1,...,Vn/x1,...,xn], (a1,s1,s \n1' ),..., (an,sn,s n' ) and x1 : t1,...,xn : tn where n = 0.  2. GENERALIZED CONTEXTUAL EQUIVALENCE \nOur language is a standard call-by-value .-calculus with polymorphic and recursive types. (We conjecture \nthat it would also be straightforward to adapt our method to a call-by-name setting.) Its syntax is given \nin Figure 1. The (big-step) semantics M . V and typing rules G f M : t are standard; we omit them for \nbrevity and refer readers to the full version [35] for details. We include recursive functions fix f \n(x : t): s = M as a primitive for the sake of exposition; alternatively, they can be implemented in terms \nof a .xed\u00adpoint operator, which is typable using recursive types. We adopt the standard notion of variable \nbinding with implicit a-conversion and write .x : t. M for fix f(x : t ): s = M when f is not free in \nM. We will write let x : t = M in N for (.x : t. N)M. We sometimes omit type annotations as in .x. M \nand let x = M in N when they are obvious from the context. The semantics is de.ned by the evaluation \nM . V of term M to value V . For simplicity, we consider the equivalence of closed values only. (This \nrestriction entails no loss of generality: see Sec\u00adtion 6.) However, in order to formalize the soundness \nand completeness of our bisimulation with respect to contextual equivalence, it helps to extend the de.nition \nof contextual equivalence to values of open types. For instance, we will have to consider whether .x \n: int.x is contextually equiva\u00adlent to .x : int.x - 1 at type a . int, where the implemen\u00adtation of abstract \ntype a is int in fact. But this clearly de\u00adpends on what values of type a (or, more generally, what val\u00adues \ninvolving type a) exist in the context: for instance, if the only values of type a are 2 in the left-hand \nworld and 3 in the right-hand world, then the equivalence does hold; however, if some integers i on the \nleft and j on the right have type a where i . = j - 1, then it does not hold. In order to capture at \nonce all such values in the context involving type a, we con\u00adsider the equivalence of multiple pairs \nof values annotated with their types such as {(2, 3,a), ((.x : int.x), (.x : int. x - 1),a . int)} and \n{(i, j, a), ((.x : int.x), (.x : int.x - 1), a . int)}; the former should be included in the equivalence \nwhile the latter should not, provided that i . = j - 1. For this reason, we generalize and de.ne contextual \nequivalence as follows. Definition 2.1. A concretion environment . is a .nite set of triples of the form \n(a, s, s ' ) with s and s ' closed and (a, t, t ' ) . . . (a, s, s ' ) . . . t = s . t ' = s ' . The \nintuition is that, under ., abstract type a is imple\u00admented by concrete type s in the left-hand side \nand by an\u00adother concrete type s ' in the right-hand side (of an equiva\u00adlence). For instance, in the example \nin Section 1, the con\u00adcrete implementations of abstract type a were int in the left-hand world and bool \nin the right-hand world, so . was {(a, int, bool)}. We write dom(.) for {a1,...,an} when .= {(a1,s1,s \n1' ),..., (an,sn,s ' )} and write .1 . .2 for n .1 . .2 when dom(.1) n dom(.2)= \u00d8. Definition 2.2. A \ntyped value relation R is a (either .nite or in.nite) set of triples of the form (V, V ' ,t ). The intuition \nis that R relates value V in the left-hand side and value V ' in the right-hand side at type t . 1),..., \n(am,s ' Definition 2.3. Let .= {(a1,s1,s ' ,smm)}. We write . fR if, for any (V, V ' ,t) .R, we have \nf V : [s/a]t and f V ' :[s ' /a]t. Definition 2.4 (Typed Value Relation in Context). We write (., R). \nfor the relation {([U/y][s/a]D, [U ' /y][s ' /a]D, t ) |.= {(a1,s1,s 1' ),..., (am,sm,s ' )}, m(U1,U \n1' ,.1),..., (Un,U n' ,.n) .R, a1,...,am,y1 : .1,...,yn : .n f D : t }. Intuitively, this relation represents \ncontexts into which val\u00adues related by R have been put. Definition 2.5. Generalized contextual equivalence \nis the set = of all pairs (., R) such that: A. . fR. B. For any (M, M ' ,t ) . (., R). , we have M . \n.. M ' .. Note that the standard contextual equivalence between two closed values of a closed type is \nsubsumed by the case where each . is empty and each R is a singleton. Con\u00adversely, the standard contextual \nequivalence is implied by the generalized one in the following sense: if (V,V ' ,t) .R for some (., R) \n.= where V , V ' , and t are closed, then it is immediate by de.nition that K[V ] . .. K[V ' ] . for \nany context K with a hole [ ] for terms of type t. See also Section 6 for discussions on non-values and \nopen terms. We write . f V1,V2,... = V1 ' ,V 2 ' ,... : t1,t2,... for (., {(V1,V 1 ' ,t1), (V2,V 2 ' \n,t2),... }) .=. We also write . f V =R V ' : t for (V, V ' ,t) .R with (., R) .=. Intuitively, this can \nbe read, values V and V ' have type t under concretion environment . and are contextually equivalent \nunder knowledge R. The following properties follow immediately from the def\u00adinition above. Corollary \n2.6 (Reflexivity). If f V1 :[s/a]t1, f V2 :[s/a]t2, ..., then {(a, s, s)}f V1,V2,... = V1,V2,... : t1,t2,.... \nCorollary 2.7 (Symmetry). If V ' {(a, s, s ' )}f V1,V2,... = 1 ,V 2 ' ,... : t1,t2,... then V ' {(a, \ns ' ,s)}f 1 ,V 2 ' ,... = V1,V2,... : t1,t2,.... Corollary 2.8 (Transitivity). If V ' {(a, s, s ' )}f \nV1,V2,... = 1 ,V 2 ' ,... : t1,t2,... and {(a, s ' ,s '' )}f V1 ' ,V 2 ' ,... = V1 '' ,V 2 '' ,... : \nt1,t2,... then {(a, s, s '' )}f V1,V2,... = V1 '' ,V 2 '' ,... : t1,t2,.... Example 2.9. Suppose that \nour language is extended in the obvious way with integers and booleans (these are, of course, de.nable \nin the language we have already given, but we prefer not to clutter examples with encodings), and let \n.= {(a, int, int)}. Then we have: . f 2, (.x : int.x) = 3, (.x : int.x - 1) : a, (a . int) More generally, \n. f i, (.x : int.x) = j, (.x : int.x - 1) : a, (a . int) if and only if i = j - 1. Example 2.10. Let \n.= {(a, int, bool)}. We have int . f 1, (.x : int.x = 0) = true, (.x : bool. \u00acx) : a, (a . bool) int \n. f 1, (.x : int.x = 0) = false, (.x : bool.x) : a, (a . bool) but int int . f 1, (.x : int.x = 0), 1, \n(.x : int.x = 0) .= true, (.x : bool. \u00acx), false, (.x : bool.x) : a, (a . bool), a, (a . bool). The last \nexample shows that, even if (., R1) .= and (., R2) .=, the union (., R1 .R2) does not always belong to \n=. In other words, one should not confuse two di.erent implementations of an abstract type, even if each \nof them is correct in itself.  3. BISIMULATION Contextual equivalence is di.cult to prove directly, \nbecause it involves a universal quanti.cation over arbitrary contexts. Fortunately, we can avoid considering \nall contexts by observ\u00ading that there are actually only a few primitive operations that contexts can \nperform on the values they have access to: for instance, if a context is comparing a pair (v, w) with \nanother pair (v ' ,w ' ), all it can do is to project the .rst elements v and v ' or the second elements \nw and w ' (and add them to its knowledge for later use). Similarly, in or\u00adder to compare functions .x. \nM and .x. M ' , a context has to apply them to some arguments it can make up from its knowledge. Intuitively, \nour bisimulations are sets of rela\u00adtions representing such contextual knowledge, closed under increase \nof knowledge via primitive operations like projec\u00adtion and application. Based on the ideas above, our \nbisimulation is de.ned as follows. More detailed technical intuitions will be given after the de.nition. \nDefinition 3.1 (Bisimulation). A bisimulation is a set X of pairs (., R) such that: 1. . fR. 2. For \neach  '' ' (fix f(x : p): . = M, fix f (x : p ): . = M,t . s) .R and for any (V, V ' ,t) . (., R)., \nwe have (fix f(x : p): . = M)V . '' '' .. (fix f(x : p ): . = M )V .. Furthermore, if (fix f (x : p): \n. = M)V . W and ' )V '' (fix f(x : p ' ): . ' = M . W , then (., R.{(W, W ' ,s)}) . X. 3. Let .= {(a1,s1,s \n1' ),..., (am,sm,s ' )}. For each m (.a. M, .a. M ' , .a. t ) .R and for any . with FTV (.) . dom(.), \nwe have (.a. M)[[s/a].] . .. (.a. M ' )[[s ' /a].] .. Furthermore, if (.a. M)[[s/a].] . W and (.a. M \n' ) [[s ' /a].] . W ' , then (., R.{(W, W ' , [./a]t )}) . X. 4. For each '' ''' (pack s, V as .a. t, \npack s ,V as .a.t , .a. t ) .R, we have either ' ''' (. {(a, s, s )}, R.{(V,V ,t )}) . X, or else (\u00df, \ns, s ' ) . . and (V, V ' , [\u00df/a]t '' ) .R for some \u00df. 5. For each ((V1,...,Vn), (V1 ' ,...,V n' ),t1 \n\u00d7 ... \u00d7 tn) .R and for any 1 = i = n, we have (., R. (Vi,V i ' ,ti)) . X. 6. For each (ini(V ), inj (V \n' ),t1 + ... + tn) .R, we have i = j and (., R. (V, V ' ,ti)) . X. 7. For each (fold(V ), fold(V ' ), \n\u00b5a. t) .R, we have (., R. (V,V ' , [\u00b5a. t/a]t )) . X.  As usual, bisimilarity, written ~, is the largest \nbisimulation; it exists because the union of two bisimulations is again a bisimulation. We write . f \nV1,...,Vn XV1 ' ,...V n ' : t1,...,tn for (., {(V1,V 1 ' ,t1),..., (Vn,V n' ,tn)}) . X. We also write \n. f VXR V ' : t for (V,V ' ,t ) .R with (., R) . X. Intuitively, it can be read: values V and V ' of \ntype t with concretion environment . are bisimilar under knowledge R. We now elaborate the intuitions \nbehind the de.nition of bisimulation. Condition 1 ensures that bisimilar values V and V ' are well typed \nunder the concretion environment .. The other conditions are concerned with the things that a context \ncan do with the values it knows to gain more knowledge. Condition 2 deals with the case where a context \napplies two functions it knows (fix f (x : p): . = M and fix f(x : p ' ) : . ' = M ' ) to some arguments \nV and V ' . To make up these arguments, the context can make use of any values it already knows (U and \nU ' in De.nition 2.4) and assemble them using a term D with free variables y, where the abstract types \na are kept abstract. The crucial observation here is that it su.ces to con\u00adsider value arguments only, \ni.e., only the cases where the assembled terms [U/y][s/a]D and [U ' /y][s ' /a]D ' are val\u00adues. This \nsimpli.cation is essential for proving the bisim\u00adilarity of functions indeed, it is the magic that makes \nour whole approach tractable. Intuitively, it can be under\u00adstood via the fact that any terms of the form \n[U/y][s/a]D and [U ' /y][s ' /a]D evaluate to values of the same form, as proved in Lemma 5.3 below. \nThen, to avoid exhibiting an observable di.erence in be\u00adhaviors, the function applications should either \nboth diverge or else both converge; in the latter case, the resulting values become part of the context \ns knowledge and can be used for further experiments.1 Condition 3 is similar to Condition 2, but for \ntype appli\u00adcation rather than term application. Condition 4 is for packages de.ning an abstract type \na. Essentially, a context can open the two packages and exam\u00adine their contents only abstractly, as expressed \nin the .rst half of this condition. However, if the context happens to know another abstract type \u00df whose \nimplementations coin\u00adcide with a s, there is no need for us to consider them twice. The second half of \nthe condition expresses this simpli.ca\u00adtion. It is not so crucial as the previous simpli.cation in Condition \n2, but it is useful for proving the bisimulation of packages, keeping X .nite in many cases despite the \ngener\u00adativity of open, as we mentioned in the introduction. 1Another technical point may deserve mentioning \nhere: in\u00adstead of (., R.{(W, W ' ,s)}) . X, we could require (W, W ' ,s) .R to reduce the number of Rs \nrequired to be in X by predicting the increase of contexts knowledge a pri\u00adori. We rejected this alternative \nfor the sake of uniformity with Condition 4, which anyway requires the concretion en\u00advironment . to be \nextended. This decision does not make it di.cult to construct a bisimulation, as we will see soon in \nthe examples. Conditions 5, 6, and 7 are for tuples, injected values, and folded values, respectively. \nThey capture the straightfor\u00adward increase of the context s knowledge via projection, case branch, or \nunfolding.  4. EXAMPLES Before presenting our main technical result that bisimu\u00adlation is sound and \ncomplete for contextual equivalence we develop several examples illustrating concrete applica\u00adtions of \nthe bisimulation method. The .rst three examples involve existential packages, whose equivalence cannot \nbe proved by other bisimulations for .-calculi. The fourth ex\u00adample involves recursive types with negative \noccurrences, for which logical relations have di.culties. Our bisimula\u00adtion technique yields a straightforward \nproof of equivalence for each of the examples. 4.1 Warm-Up Consider the following simple packages int \nU = pack int, (1, .x : int.x =0) as t U ' = pack bool, (true, .x : bool. \u00acx) as t where t = .a. a \u00d7 (a \n. bool). We aim to prove that U and U ' are contextually equivalent at type t . To this end, let X = \n{(\u00d8, R0), (., R1), (., R2), (., R3), (., R4), (., R5)} where .=(a, int, bool) R0 = {(U, U ' ,t)} int \nR1 = R0 .{((1, .x : int.x =0), (true, .x : bool. \u00acx), a \u00d7 (a . bool))} R2 = R1 .{(1, true,a)} int R3 \n= R1 .{(.x : int.x =0, .x : bool. \u00acx, a . bool)}R4 = R2 .R3 R5 = R4 .{(false, false, bool)}. Then, X \nis a bisimulation. To prove it, we must check each condition in De.nition 3.1 for every (., R) . X. Most \nof the checks are trivial, except the following cases: Condition 4 on (U, U ' ,t ) .Ri for i = 1, where \nthe second half of the condition holds.  Condition 2 on  int (.x : int.x =0, .x : bool. \u00acx, a . bool) \n.Ri for i = 3. Since V and V ' are values, the D in Def\u00adinition 2.4 is either a value or a variable. \nHowever, if D is a value, it can never satisfy the assumption a, y1 : .1,...,yn : .n f D : a (easy case \nanalysis on the syntax of D). Thus, D must be a variable. Without loss of generality, let D = y1. Then, \nby inversion of (T-Var), .1 = a. Since (U1,U 1' ,.1) .Rn, we have U1 = 1 and U1 ' = true. Thus, V = 1 \nand V ' = true, from which the rest of this condition is obvious. Alternatively, in this particular example, \nwe can just take X = {(., R5)} in the .rst place and prove it to be a bisim\u00adulation by the same arguments \nas above. Since (U, U ' ,t) . R5, this still su.ces for showing the contextual equivalence of U and U \n' , thanks to the soundness of bisimilarity (Corol\u00adlary 5.5) and the generalized de.nition of contextual \nequiv\u00adalence (De.nition 2.5).  4.2 Complex Numbers Suppose now that we have real numbers and operations \nin the language. Then the following two implementations U and U ' of complex numbers should be contextually \nequiva\u00adlent at the appropriate type .a. t. U = pack (real \u00d7 real), (id, id, cmul) as .a. t U ' = pack \n(real \u00d7 real), (ctop, ptoc, pmul) as .a. t t =(real \u00d7 real . a) \u00d7 (a . real \u00d7 real) \u00d7 (a . a . a) id \n= .c : real \u00d7 real.c cmul = .c1 : real \u00d7 real. .c2 : real \u00d7 real. (#1(c1) \u00d7 #1(c2) - #2(c1) \u00d7 #2(c2), \n#2(c1) \u00d7 #1(c2)+#1(c1) \u00d7 #2(c2)) ctop = .c : real \u00d7 real. ((#1(c))2 + (#2(c))2 , atan2(#2(c), #1(c))) \nptoc = .p : real \u00d7 real. (#1(p) \u00d7 cos(#2(p)), #1(p) \u00d7 sin(#2(p))) pmul = .p1 : real \u00d7 real. .p2 : real \n\u00d7 real. (#1(p1) \u00d7 #1(p2), #2(p1)+#2(p2)) The .rst functions in these packages make a complex num\u00adber \nfrom its real and imaginary parts, and the second func\u00adtions perform the converse conversion. The third \nfunctions multiply complex numbers. To prove the contextual equivalence of U and U ' , consider X = {(., \nR)} where .= {(a, real \u00d7 real, real \u00d7 real)} R = {(U, U ' , .a. t ), ((id, id, cmul), (ctop, ptoc, pmul),t \n), (id, ctop, real \u00d7 real . a), (id, ptoc,a . real \u00d7 real), (cmul, pmul,a . a . a)} .{(v, w, a) | w = \n(r, t), (r \u00d7 cos(t),r \u00d7 sin(t)). v, r = 0} .{(c, c, real \u00d7 real) |f c : real \u00d7 real} .{(r, r, real) |f \nr : real}. Then X is a bisimulation, as can be checked in the same manner as in the previous example. \n 4.3 Functions Generating Packages The following functions U and U ' generate packages. (I.e., they \nbehave a bit like functors in ML-style module systems.) U = .y : int.M U ' = .y : int.M ' M = pack int, \n(y, .x : int.x) as t M ' = pack int, (y +1, .x : int.x - 1) as t t = .a. a \u00d7 (a . int) To prove that \nU is contextually equivalent to U ' at type int . t , it su.ces to consider the following in.nite bisimu\u00adlation. \nX = {(., R) | .= {(\u00dfi, int, int) |-n = i = n}, R..-n=i=nRi, n =0, 1, 2,... } Ri = {(U, U ' , int . t \n), ([i/y]M, [i/y]M ' ,t ), ((i, .x : int.x), (i +1, .x : int.x - 1),\u00dfi \u00d7 (\u00dfi . int)), (i, i +1,\u00dfi), (.x \n: int. x, .x : int.x - 1,\u00dfi . int), (i, i, int)} The generativity of U and U ' is given a simple account \nby having a di.erent abstract type \u00dfi for each instantiation of U and U ' with y = i. The inclusion of \nall R..-n=i=nRi in the de.nition of X simpli.es the de.nition of this bisimulation; although it admits \nsome Rs that are not strictly relevant to the proof (such as those with only the elements of tuples, \nbut without the tuples themselves), they are not a problem since they do not violate any of the conditions \nof bisimulation. In other words, to prove the contextual equivalence of two values, one has only to .nd \nsome bisimulation including the values rather than the minimal one. 4.4 Recursive Types with Negative \nOccurrence Consider the packages C and C ' implementing counter ob\u00adjects as follows: each counter is \nimplemented as a pair of its state part (of abstract type st) and its method part; the latter is implemented \nas a function that takes a state and returns the tuple of methods2; in this example, there are two methods \nin the tuple: one returns a new counter object with the state incremented (or, in the second implementa\u00adtion, \ndecremented) by 1, while the other tells whether an\u00adother counter object has been incremented (or decremented) \nthe same number of times as the present one. t = .st.s s = \u00b5self. st \u00d7 (st . .) . = self \u00d7 (self . bool) \nC = pack int, fold((0, M )) as t 2This implementation can be viewed as a variant of the so\u00adcalled recursive \nexistential encoding of objects (see [12] for details), but our goal here is to illustrate the power \nof our bisimulation with existential recursive types, rather than to discuss the object encoding itself. \nC ' = pack int, fold((0, M ' )) as t M = fix f(s : int):[int/st][s/self]. = (fold((s +1,f)), int .c :[int/st]s. \n(s =#1(unfold(c)))) M ' = fix f(s : int):[int/st][s/self]. = (fold((s - 1,f)), int .c :[int/st]s. (s \n=#1(unfold(c)))) Let us prove the contextual equivalence of C and C ' at type t. To do so, we consider \nthe bisimulation X = {(., R)}where: .= {(st, int, int)} R = {(C, C ' ,t ), (fold((n, M)), fold((-n, M \n' )),s), ((n, M), (-n, M ' ), st \u00d7 (st . [s/self].)), (n, -n, st), (M, M ' , st . [s/self].), ((fold((n \n+1,M)), int .c :[int/st]s. (n =#1(unfold(c)))), (fold((-n - 1,M ' )), int .c :[int/st]s. (-n =#1(unfold(c)))), \ns \u00d7 (s . bool)), int (.c :[int/st]s. (n =#1(unfold(c))), int .c :[int/st]s. (-n =#1(unfold(c))), s . \nbool), (true, true, bool), (false, false, bool) | n =0, 1, 2,... } It can indeed be shown to be a bisimulation \njust as the bisimulations in previous examples. That is, unlike logi\u00adcal relations, our bisimulation \nincurs no di.culty at all for recursive functions or recursive types even with negative oc\u00adcurrence. \n 4.5 Higher-Order Functions The following higher-order functions represent the dual of the example in \nSection 4.1. int U = .f : s. f[int](1, .x : int.x =0) U ' = .f : s. f[bool](true, .x : bool. \u00acx) s = \n.a. a \u00d7 (a . bool) . unit It is surprisingly easy to prove the contextual equivalence of U and U ' at \ntype s . unit, i.e., [U/x]C . .. [U ' /x]C . for any x : s . unit f C : t. Since int [U/x]C = [1, (.x \n: int.x = 0)/y, z][int/\u00df]D0 [U ' /x]C =[true, (.x : bool. \u00acx)/y, z][bool/\u00df]D0 for D0 = [(.f : s. f[\u00df](y, \nz))/x]C, it su.ces to prove int [1, (.x : int.x = 0)/y, z][int/\u00df]D . .. [true, (.x : bool. \u00acx)/y, z][bool/\u00df]D \n. for every \u00df, y : \u00df, z : \u00df . bool f D : t. (Note that D0 has the same typing as D thanks to the standard \nsubstitution lemma.) However, this follows immediately from the bisim\u00adulation {(., R)} where .= {(\u00df, \nint, bool)} R = {(1, true,\u00df), int (.x : int.x =0, .x : bool. \u00acx, \u00df . bool), (false, false, bool)} along \nwith the soundness of bisimilarity in the next section.  5. SOUNDNESS AND COMPLETENESS We prove that \nbisimilarity coincides with contextual equiva\u00adlence (in the generalized form presented in Section 2). \nThat is, two values can be proved to be bisimilar if and only if they are contextually equivalent. First, \nwe prove the if part, i.e., that contextual equiva\u00adlence is included in bisimilarity. This direction \nis easier be\u00adcause our bisimulation is de.ned co-inductively: it su.ces simply to prove that contextual \nequivalence is a bisimula\u00adtion. Lemma 5.1 (Completeness of Bisimulation). =. ~. Proof. By checking that \n= satis.es each condition of bisimulation. Next, we show that bisimilarity is included in contextual \nequivalence. To do so, we need to consider the question: When we put bisimilar values into a context \nand evaluate them, what changes? The answer is: Nothing! I.e., evalu\u00adating a pair of expressions, each \nconsisting of some set of bisimilar values placed in some context, results again in a pair of expressions \nthat can be described by some set of bisimilar values placed in some context. Furthermore, this evaluation \nconverges in the left-hand side if and only if it converges in the right-hand side. Since the proof of \nthe lat\u00adter property requires the former property, we formalize the observations above in the following \norder. Definition 5.2 (Bisimilarity in Context). We write . f N ~.' : t if (N, N ' and (., R) .~. R N \n,t) . (., R). The intuition is that ~. relates bisimilar values put in con\u00adtexts. Lemma 5.3 (Fundamental \nProperty, Part I). Sup\u00ad ' '' pose .0 f N ~. N : t. If N . W and N . W , then R0 . f W ~.' : t for some \n. . .0 and R.R0. R W Proof. By induction on the derivation of N . W . Lemma 5.4 (Fundamental Property, \nPart II). If .0 f N ~. N ' : t then N . .. N ' .. R0 Proof. By induction on the derivation of N . together \nwith Lemma 5.3. Corollary 5.5 (Soundness of Bisimilarity). ~. =. Proof. By the de.nitions of = and ~. \ntogether with Lemma 5.4. Combining soundness and completeness, we obtain the main theorem about our bisimulation: \nthat bisimilarity co\u00adincides with contextual equivalence. Theorem 5.6. ~ = =. Proof. By Corollary 5.5 \nand Lemma 5.1. Details of the proofs above are found in the full version [35]. Note that these proofs \nare much simpler than soundness proofs of applicative bisimulations in previous work [19, 14, 17, 15, \n16, 4] thanks to the generalized condition on func\u00adtions (Condition 2), which is anyway required in the \npres\u00adence of existential polymorphism as discussed in the intro\u00adduction.  6. NON-VALUES AND OPEN TERMS \nSo far, we have restricted ourselves to the equivalence of closed values for the sake of simplicity. \nIn this section, we show how our method can be used for proving the standard contextual equivalence of \nnon-values and open terms as well. (Although our approach here may seem ad hoc, it su.ces for the present \npurpose of proving the contextual equivalence of open terms. For other studies on di.erent equivalences \nfor open terms, see [30, 29] for instance.) A context K in the standard sense is a term with some subterm \nreplaced by a hole [ ]. We write K[M] for the term obtained by substituting the hole in K with M (which \ndoes not apply a-conversion and may capture free variables). Then, the standard contextual equivalence \nstd ' a1, . . . , am, x1 : t1, . . . , xn : tn f M = M : t ' for well-typed terms a, x : t f M : t and \na, x : t f M : t can be de.ned as: K[M] . .. K[M ' ] . for every context K with f K[M]: unit and f K[M \n' ]: unit, where unit is the nullary tuple type. (In fact, any closed type works in place of unit.) We \nwill show that the standard contextual equivalence above holds if and only if the closed values V =.a. \n.x : t. M and V ' =.a. .x : t.M ' are bisimilar, i.e., \u00d8f .a1. ... .am. .x1 : t1. ... .xn : tn.M ~ .a1. \n... .am. .x1 : t1. ... .xn : tn.M ' : .a1. ... .am.t1 . ... . tn . t. (If M and M ' have no free term/type \nvariables at all, it su.ces just to take V =.a. M and V ' =.a. M ' for any type variable a.) The only \nif direction is obvious from the de.nitions of contextual equivalences both the stan\u00addard one above and \nthe generalized one in Section 2 and from the completeness of bisimulation. To prove the if direction, \nsuppose \u00d8f V ~ V ' : .a. t . t. By the sound\u00adness of bisimulation, we have \u00d8f V = : .a. t . t. V ' Given \nany K with f K[M]: unit and f K[M ' ]: unit, take C = K[z[a1] ... [am]x1 ...xn] for fresh z. Then, it \nsuf\u00ad.ces to prove K[M] . .. [V/z]C . and K[M ' ] . .. [V ' /z]C .. To this end, we prove the more general \nlemma below in order for induction to work. The intuition is that a term M and its \u00df-expanded version \n(.a. .x : t.M)[a]x should be\u00adhave equivalently under any context. Since the free type/term G f M . M \n' : . {a}. dom(G) G f x : t (B-Exp) G f M . (.a. .x : t.M ' )[a]x : . G f x : t G,f : t . s, x : t f \nM . M ' : s (B-Var) (B-Fix) G f x . x : t G f (fix f (x : t): s = M) . (fix f(x : t ): s = M ' ): t \n. s G f M . M ' : t . s G f N . N ' : t (B-App) G f MN . M ' N ' : s G,a f M . M ' : t G f M . M ' : \n.a. s FTV (t) . G (B-TAbs) (B-TApp) G f .a. M . .a. M ' : .a. t G f M[t ] . M ' [t ]:[t/a]s G f M . M \n' :[t/a]s FTV (t) . G (B-Pack) G f (pack t, M as .a. s) . (pack t,M ' as .a. s): .a. s G f M . M ' \n: .a. t G, a, x : t f N . N ' : sa .. FTV (s) (B-Open) G f (open M as a, x in N) . (open M ' as a, x \nin N ' ): s '' ' G f M1 . M1 : t1 ... G f Mn . Mn : tn G f M . M : t1 \u00d7 ... \u00d7 ti \u00d7 ... \u00d7 tn (B-Tuple) \n(B-Proj) '' ' G f(M1,...,Mn).(M1,...,M n) : t1 \u00d7 ... \u00d7 tn G f #i(M) . #i(M ): ti G f M . M ' : ti FTV \n(t1) . G ... FTV (tn) . G (B-Inj) G f ini(M) . ini(M ' ): t1 + ... + ti + ... + tn ' '' G f M . M : \nt1 + ... + tn G,x1 : t1 f M1 . M1 : t ... G,xn : tn f Mn . Mn : t (B-Case)G f (case M of in1(x1) . M1 \n[] ... [] inn(xn) . Mn) '' ' . (case M of in1(x1) . M1 [] ... [] inn(xn) . Mn): t G f M . M ' :[\u00b5a. \nt/a]t G f M . M ' : \u00b5a. t (B-Fold) (B-Unfold) G f fold(M) . fold(M ' ): \u00b5a. t G f unfold(M) . unfold(M \n' ):[\u00b5a. t/a]t Figure 2: \u00df-Expansion variables a and x are to be substituted by some types/values during \nevaluation under a context, this \u00df-expansion rela\u00adtion needs to be generalized to allow nesting. Thus, \nwe de.ne: Definition 6.1 (\u00df-Expansion). G f M . M ' : t is the smallest relation on pairs of .-terms \nM and M ' (anno\u00adtated with a type environment G and a type t ) satisfying all the rules in Figure 2. \nThe main rule is (B-Exp). The other rules are just for pre\u00adserving the relation . under any context. \nThen, we can prove: Lemma 6.2. For any a1,...,am,x1 : t1,...,xn : tn f M . M ' : t, for any closed s1,...,sm, \nand for any (f V1 . V1 ' :[s/a]t1) .\u00b7 \u00b7\u00b7. (f Vn . Vn ' :[s/a]tn), we have [V /x][s/a]M . .. [V ' /x][s/a]M \n' .. ' Furthermore, if [V /x][s/a]M . W and [V ' /x][s/a]M . W ' , then f W . W ' :[s/a]t . Proof. Straightforward \ninduction on the derivation of a, x : t f M . M ' : t . Theorem 6.3. For any a, x : t f M : t and a, \nx : t f M ' : t , if f .a. .x : t.M ~ .a. .x : t.M ' : .a. t . t , then std a, x : t f M = M ' : t . \nProof. By the soundness of bisimulation, we have [(.a. .x : t.M)/z]C . .. [(.a. .x : t.M ' )/z]C for \nany well\u00adtyped C. Thus, given K, take C = K[z[a]x] and we get K[(.a. .x : t.M)[a]x] . .. K[(.a. .x : \nt.M ' )[a]x] .. Meanwhile, by the de.nition of ., we have f K[M] . K[(.a. .x : t.M)[a]x]: unit and f \nK[M ' ] . K[(.a. .x : t. M ' )[a]x]: unit. By the lemma above, we obtain K[M] . .. K[(.a. .x : t.M)[a]x] \n. and K[M ' ] . .. K[(.a. .x : t.M ' )[a]x] .. Hence K[M] . .. K[M ' ] .. std Example 6.4. We have x \n: int f x +1 = 1+ x : int. That is, x +1 and 1+ x are contextually equivalent (in the standard sense \nabove) at type int provided that x has type int. To show this, it su.ces to prove \u00d8f .x : int.x +1 ~ \n.x : int. 1+ x : int . int, which is trivial. Example 6.5. The packages M = pack int, (y, .x : int.x) \nas t M ' = pack int, (y +1, .x : int.x - 1) as t are contextually equivalent (again in the standard sense \nabove) at type t = .a. a \u00d7 (a . int) provided that y has type int. This follows from the bisim\u00adilarity \nof .y : int.M and .y : int.M ' , which was shown in Section 4.3.  7. LIMITATIONS (OR: THE RETURN OF \nHIGHER-ORDER FUNCTIONS) Although the proof of contextual equivalence in Section 4.5 was strikingly simple, \nthe trick used there does not apply in general. For example, consider the following implemen\u00adtations \nof integer multisets with a higher-order function to compute a weighed sum of all elements. (We assume \nstan\u00addard de.nitions of lists and binary trees.) IntSet = pack intList, Nil, add, weigh as .a. t ' '' \nIntSet = pack intTree, Lf, add , weigh as .a. t t = a \u00d7 (int . a . a) \u00d7 ((int . real) . a . real) add \n= .i : int. .s : intList. Cons(i, s) add ' = .i : int. fix f(s : intTree): intTree = case s of Lf . Nd(i, \nLf, Lf) [] Nd(j, s1,s2) . if i<j then Nd(j, fs1,s2) else Nd(j, s1,fs2) weigh = .g : int . real. fix f(s \n: intList): real = case s of Nil . 0 [] Cons(j, s0) . gj + fs0 weigh ' = .g : int . real. fix f(s : intTree): \nreal = case s of Lf . 0 [] Nd(j, s1,s2) . gj + fs1 + fs2 Unlike the previous example, these implementations \nhave no syntactic similarity, which disables the simple proof. In\u00adstead, we have to put the whole packages \ninto the bisimu\u00adlation along with their elements. Then, by Condition 2 of bisimulation, we need at least \nto prove weigh VW . .. weigh ' V ' W ' . for a certain class of V , W , V ' , and W ' . In particular, \nV and V ' can be of the forms .z : int. [IntSet/y]D and .z : int. [IntSet ' /y]D for any D of appropriate \ntype. Thus, because of the function application gj in weigh and weigh ' , we must prove [IntSet, j/y, \nz]D . .. [IntSet ' , j/y, z]D . for every D (and j). We are stuck, however, since this sub\u00adsumes the \nde.nition of IntSet = IntSet ' and is harder to prove! Resolving this problem requires weakening Condition \n2. By a close examination of the soundness proof [35, Ap\u00adpendix], we .nd the following candidate. 2 ' \n. Take any (fix f(x : p): . = M, fix f(x : p ' ): . ' = M ' ,t . s) .R and any (V, V ' ,t) . (., R). \n. Assume that, for any N . (fix f(x : p): . = M)V ' '' '' N . (fix f(x : p ): . = M )V with (N, N ' ,s) \n. (.0, R0). and (.0, R0) . X, we have N . .. N ' .. Assume furthermore that, if '' ' N . U and N . U \n, then (U,U ,s) . (.1, R1). for some .1 . .0 and R1 .R0 with (.1, R1) . X. Then, we have (fix f(x : p): \n. = M)V . '' '' .. (fix f(x : p ): . = M )V .. Furthermore, if (fix f(x : p): . = M)V . W and (fix f(x \n: p ' ): . ' = M ' )V . W ' , then (W, W ' ,s) . (.2, R2). for some .2 . . and R2 .R with (.2, R2) . \nX. Here, N1 . N2 means that, if N2 ., then N1 . and the former evaluation derivation tree is strictly \ntaller than the latter. (This is reminiscent of indexed models [6, 5], but it is unclear how they extend \nto a relational setting with existential types.) This generalization seems quite powerful: for instance, \nit allows us to conclude that gj in weigh and weigh ' gives the same result when g is substituted by \nV or V ' . Unfortunately, however, the condition above has X in a negative position ((.1, R1) . X) and \nbreaks the property that the union of two bisimulations is a bisimulation. Although it is still possible \nto prove soundness (for an arbitrary bisimulation X instead of ~) and completeness (= is still a bisimulation \nbecause Condition 2 ' is weaker than Condition 2), the new condition is rather technical and hard to \nunderstand. We leave it for future work to .nd a more intuitive principle behind Condition 2 ' that addresses \nthis issue. 8. RELATED WORK Semantic logical relations. Originally, logical relations were devised in \ndenotational semantics for relating models of .-calculus. Although they are indeed useful for this purpose \n(e.g., relating CPS semantics and direct-style semantics), they are not as useful for proving contextual \nequivalence or abstraction properties, for the following reasons. First, denotational semantics tend \nto require more complex math\u00adematics (such as CPOs and categories) than operational se\u00admantics. Second, \nit is hard though not impossible [20] to de.ne a fully abstract model of polymorphic .-calculus, i.e., \na model that always preserves equivalence. Without full abstraction, not all equivalent terms can be \nproved to be equivalent. Logical relations for polymorphic .-calculus are also useful for proving parametricity \nproperties [36], e.g., that all func\u00adtions of type .a. a . a behave like the polymorphic identity function \n(or diverge, if there is recursion in the language). By contrast, our bisimulation is only useful for \nproving the equivalence of two given .-terms and cannot be employed for predicting such properties based \non only types. Syntactic logical relations. Pitts [30] proposed syntactic logical relations, which use \nonly the term model of poly\u00admorphic .-calculus to prove contextual equivalence. He in\u00adtroduced the notion \nof ..-closure (application closure of the two functions in a Galois connection between terms and contexts) \nin order to treat recursive functions without using denotational semantics. He proved that his syntactic \nlogical relations are complete with respect to contextual equiva\u00adlence in call-by-name polymorphic .-calculus \nwith recursive functions and universal types (and lists). Pitts [29] also proposed syntactic logical \nrelations for a variant of call-by-value polymorphic .-calculus with recur\u00adsive functions, universal \ntypes, and existential types, where type abstraction is restricted to values like .a. V instead of .a. \nM. Although he showed (by a counter-example) that these logical relations are incomplete in this language \nand attributed the incompleteness to the presence of recursive functions, we have shown that a similar \ncounter-example can be given without using recursive functions [personal communication, June 2000]. However, \nboth of the counter\u00adexamples depend on the fact that type abstraction is re\u00adstricted to values. It remains \nunclear whether his syntactic logical relations can be made complete in a setting without this restriction. \nBirkedel and Harper [9] and Crary and Harper [13] ex\u00adtended syntactic logical relations with recursive \ntypes by requiring certain unwinding properties. This extension is conjectured to be complete with respect \nto contextual equiv\u00adalence [personal communication, March 2004]. Compared to syntactic logical relations, \nour bisimulation is even more syntactic and elementary, liberating its user from the burden of calculating \n..-closure or proving un\u00adwinding properties even with arbitrary recursive types (and functions). Applicative \nbisimulations. Abramsky [4] proposed applica\u00adtive bisimulations for proving contextual equivalence of \nun\u00adtyped .-terms. Gordon and Rees [14, 17, 15, 16] adapted applicative bisimulations to calculi with \nobjects, subtyping, universal polymorphism, and recursive types. As discussed in Section 1, however, \nthese results do not apply to type abstraction using existential types. We solved this issue by considering \nsets of relations as bisimulations. As a byproduct, it has become much easier to prove the soundness \nof our bisimulation: technically, this simpli.ca\u00adtion is due to the generalization in the condition of \nbisim\u00adulation for functions (Condition 2 in De.nition 3.1), where our bisimulation allows di.erent arguments \nV and V ' while applicative bisimulation requires them to be the same. Bisimulations for polymorphic \np-calculi. Pierce and San\u00adgiorgi [28] developed a bisimulation proof technique for poly\u00admorphic p-calculus, \nusing a separate environment for repre\u00adsenting contexts knowledge. In a sense, our bisimulation uni.es \nthe environmental knowledge with the bisimulation itself by generalizing the latter as a set of relations. \nBecause of the imperative nature of p-calculus, their bisimulation is far from complete in particular, \naliasing of names is prob\u00adlematic. Berger, Honda and Yoshida [7] de.ned two equivalence proof methods \nfor linear p-calculi, one based on the syntac\u00adtic logical relations of Pitts [29, 30] and the other based \non the bisimulations of Pierce and Sangiorgi [28]. Their main goal is to give a generic account for various \nfeatures such as functions, state and concurrency by encoding them into appropriate versions of linear \np-calculi. They proved sound\u00adness and completeness of their logical relations for one of the linear p-calculi, \nwhich directly corresponds to polymor\u00adphic .-calculus (without recursion). They also proved full abstraction \nof the call-by-value and call-by-name encodings of the polymorphic .-calculus to this version of linear \np\u00adcalculus. However, for the other settings (e.g., with recursive functions or types), full abstraction \nof encodings and com\u00adpleteness of their logical relations are unclear. Completness of their bisimulations \nis not discussed either. In addition, their developments are much heavier than ours for the pur\u00adpose \nof just proving the equivalence of typed .-terms. Bisimulations for cryptographic calculi. Various bisim\u00adulations \n[2, 1, 10, 11] have been proposed for extensions of p-calculus with cryptographic primitives [3, 1]. \nTheir main idea is similar to Pierce and Sangiorgi s: using a separate environment to represent attackers \nknowledge. In previous work [34], we have applied our idea of using sets of relations as bisimulations \nto an extension of .-calculus with perfect encryption (also known as dynamic sealing) and obtained a \nsound and complete proof method for contextual equiva\u00adlence in this setting. Although this extension \nwas untyped, it is straightforward to combine the present work with the previous one and obtain a bisimulation \nfor typed .-calculus with perfect encryption. The fact that our idea applies to such apparently di.erent \nforms of information hiding as en\u00adcryption and type abstraction suggests that it is successful in capturing \nthe essence of information hiding in program\u00adming languages and computation models. 9. CONCLUSION We \nhave presented the .rst sound, complete, and elementary bisimulation proof method for .-calculus with \nfull universal, existential, and recursive types. Although full automation is impossible because equiva\u00adlence \nof .-terms (with recursion) is undecidable, some me\u00adchanical support would be useful. The technique of \nbisim\u00adulation up to [33] would also be useful to reduce the size of a bisimulation in some cases, though \nour bisimulations tend to be smaller than bisimulations in process calculi in the .rst place, since ours \nare based on big-step evaluation rather than small-step reduction. Another direction is to extend the \ncalculus with more com\u00adplex features such as state (cf. [31, 8]). For example, it would be possible to \ntreat state by passing around the state throughout the evaluation of terms and their bisimulation. More \nambitiously, one could imagine generalizing this state\u00adpassing approach to more general monadic bisimulation \nby formalizing e.ects via monads [25]. Yet another possibility is to adopt our idea of sets of rela\u00adtions \nas bisimulations to other higher-order calculi with in\u00adformation hiding such as higher-order p-calculus \n[32], where restriction hides names and complicates equivalence and compare the outcome with context \nbisimulation. Finally, as suggested in the previous section, the idea of considering sets of relations \nas bisimulations may be useful for other forms of information hiding such as secrecy typ\u00ading [18]. It \nwould be interesting to see whether such an adaptation is indeed possible and, furthermore, to consider \nif these variations can be generalized into a uni.ed theory of information hiding. Acknowledgements We \nwould like to thank Karl Crary, Andy Gordon, Bob Harper, and Andrew Pitts for information and discussions \non their work and its relationship to ours. Comments from anonymous reviewers, the members of the PL \nClub at the University of Pennsylvania, and Naoki Kobayashi helped us to sharpen the presentation. 10. \nREFERENCES [1] M. Abadi and C. Fournet. Mobile values, new names, and secure communication. In Proceedings \nof the 28th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, pages 104 115, 2001. \n[2] M. Abadi and A. D. Gordon. A bisimulation method for cryptographic protocols. Nordic Journal of Computing, \n5:267 303, 1998. Preliminary version appeared in 7th European Symposium on Programming, Lecture Notes \nin Computer Science, Springer-Verlag, vol. 1381, pp. 12 26, 1998. [3] M. Abadi and A. D. Gordon. A calculus \nfor cryptographic protocols: The spi calculus. Information and Computation, 148(1):1 70, 1999. Preliminary \nversion appeared in Proceedings of the 4th ACM Conference on Computer and Communications Security, pp. \n36 47, 1997. [4] S. Abramsky. The lazy lambda calculus. In D. A. Turner, editor, Research Topics in Functional \nProgramming, pages 65 117. Addison-Wesley, 1990. [5] A. Ahmed, A. W. Appel, and R. Virga. An indexed \nmodel of impredicative polymorphism and mutable references. http://www.cs.princeton.edu/~amal/papers/impred.pdf, \n2003. [6] A. W. Appel and D. McAllester. An indexed model of recursive types for foundational proof-carrying \ncode. ACM Transactions on Programming Languages and Systems, 23(5):657 683, 2001. [7] M. Berger, K. Honda, \nand N. Yoshida. Genericity and the pi-calculus. In Foundations of Software Science and Computation Structures, \nvolume 2620 of Lecture Notes in Computer Science, pages 103 119. Springer-Verlag, 2003. [8] G. M. Bierman, \nA. M. Pitts, and C. V. Russo. Operational properties of Lily, a polymorphic linear lambda calculus with \nrecursion. In Higher Order Operational Techniques in Semantics, volume 41 of Electronic Notes in Theoretical \nComputer Science. Elsevier Science, 2000. [9] L. Birkedal and R. Harper. Relational interpretations of \nrecursive types in an operational setting. Information and Computation, 155(1 2):3 63, 1999. Summary \nappeared in Theoretical Aspects of Computer Software, Lecture Notes in Computer Science, Springer-Verlag, \nvol. 1281, pp. 458 490, 1997. [10] M. Boreale, R. De Nicola, and R. Pugliese. Proof techniques for cryptographic \nprocesses. SIAM Journal on Computing, 31(3):947 986, 2002. Preliminary version appeared in 14th Annual \nIEEE Symposium on Logic in Computer Science, pp. 157 166, 1999. [11] J. Borgstr\u00a8om and U. Nestmann. On \nbisimulations for the spi calculus. In 9th International Conference on Algebraic Methodology and Software \nTechnology, volume 2422 of Lecture Notes in Computer Science, pages 287 303. Springer-Verlag, 2002. [12] \nK. B. Bruce, L. Cardelli, and B. C. Pierce. Comparing object encodings. Information and Computation, \n155(1 2):108 133, 1999. Extended abstract appeared in Theoretical Aspects of Computer Software, Springer-Verlag, \nvol. 1281, pp. 415 338, 1997. [13] K. Crary and R. Harper. Syntactic logical relations over polymorphic \nand recursive types. Draft, 2000. [14] A. D. Gordon. Bisimilarity as a theory of functional programming. \nmini-course. http://research.microsoft. com/~adg/Publications/BRICS-NS-95-3.dvi.gz, 1995. [15] A. D. \nGordon. Operational equivalences for untyped and polymorphic object calculi. In Higher Order Operational \nTechniques in Semantics, pages 9 54, 1995. [16] A. D. Gordon and G. D. Rees. Bisimilarity for F<:. Draft, \n1995. [17] A. D. Gordon and G. D. Rees. Bisimilarity for a .rst-order calculus of objects with subtyping. \nIn Proceedings of the 23rd ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, pages \n386 395, 1996. [18] N. Heintze and J. G. Riecke. The SLam calculus: Programming with secrecy and integrity. \nIn Proceedings of the 25th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, 1998. \n[19] D. J. Howe. Proving congruence of bisimulation in functional programming languages. Information \nand Computation, 124(2):103 112, 1996. [20] D. J. Hughes. Games and de.nability for System F. In Twelfth \nAnnual IEEE Symposium on Logic in Computer Science, pages 76 86, 1997. [21] R. Milner. A Calculus of \nCommunicating Systems. Springer-Verlag, 1980. [22] R. Milner. Communication and Concurrency. Springer-Verlag, \n1995. [23] R. Milner. Communicating and Mobile Systems: The p-Calculus. Cambridge University Press, 1999. \n[24] J. C. Mitchell. Foundations for Programming Languages. MIT Press, 1996. [25] E. Moggi. Notions of \ncomputation and monads. Information and Computation, 93(1):55 92, 1991. [26] J. H. Morris, Jr. Protection \nin programming languages. Communications of the ACM, 16(1):15 21, 1973. [27] J. H. Morris, Jr. Types \nare not sets. In Proceedings of the 1st Annual ACM SIGACT-SIGPLAN Symposium on Principles of Programming \nLanguages, pages 120 124, 1973. [28] B. C. Pierce and D. Sangiorgi. Behavioral equivalence in the polymorphic \npi-calculus. Journal of the ACM, 47(3):531 586, 2000. Extended abstract appeared in Proceedings of the \n24th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, 1997, pp. 531 584. [29] A. \nM. Pitts. Existential types: Logical relations and operational equivalence. In Automata, Languages and \nProgramming, volume 1443 of Lecture Notes in Computer Science, pages 309 326. Springer-Verlag, 1998. \n[30] A. M. Pitts. Parametric polymorphism and operational equivalence. Mathematical Structures in Computer \nScience, 10:321 359, 2000. Preliminary version appeared in HOOTS II Second Workshop on Higher-Order Operational \nTechniques in Semantics, Electronic Notes in Theoretical Computer Science, vol. 10, 1998. [31] A. M. \nPitts and I. Stark. Operational reasoning for functions with local state. In Higher Order Operational \nTechniques in Semantics, pages 227 273. Cambridge University Press, 1998. [32] D. Sangiorgi. Expressing \nMobility in Process Algebras: First-Order and Higher-Order Paradigm. PhD thesis, University of Edinburgh, \n1992. [33] D. Sangiorgi and R. Milner. The problem of weak bisimulation up to . In CONCUR 92, Third International \nConference on Concurrency Theory, volume 630 of Lecture Notes in Computer Science, pages 32 46. Springer-Verlag, \n1992. [34] E. Sumii and B. C. Pierce. A bisimulation for dynamic sealing. In Proceedings of the 31st \nACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, pages 161 172, 2004. [35] E. Sumii \nand B. C. Pierce. A bisimulation for type abstraction and recursion. Technical Report MS-CIS-04-27, Department \nof Computer and Information Science, University of Pennsylvania, 2004. http://www.cis.upenn.edu/~sumii/pub/. \n[36] P. Wadler. Theorems for free! In Proceedings of the Fourth International Conference on Functional \nProgramming Languages and Computer Architecture, pages 347 359. ACM, 1989.   \n\t\t\t", "proc_id": "1040305", "abstract": "We present a sound, complete, and elementary proof method, based on bisimulation, for contextual equivalence in a &#955;-calculus with full universal, existential, and recursive types. Unlike logical relations (either semantic or syntactic), our development is elementary, using only sets and relations and avoiding advanced machinery such as domain theory, admissibility, and &#932;&#932;-closure. Unlike other bisimulations, ours is complete even for existential types. The key idea is to consider <i>sets</i> of relations---instead of just relations---as bisimulations.", "authors": [{"name": "Eijiro Sumii", "author_profile_id": "81100019964", "affiliation": "University of Pennsylvania", "person_id": "P75950", "email_address": "", "orcid_id": ""}, {"name": "Benjamin C. Pierce", "author_profile_id": "81100303310", "affiliation": "University of Pennsylvania", "person_id": "PP14111353", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1040305.1040311", "year": "2005", "article_id": "1040311", "conference": "POPL", "title": "A bisimulation for type abstraction and recursion", "url": "http://dl.acm.org/citation.cfm?id=1040311"}