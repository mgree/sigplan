{"article_publication_date": "01-12-2005", "fulltext": "\n Mutatis Mutandis: Safe and Predictable Dynamic Software Updating Gareth Stoyle Michael Hicks. Gavin \nBierman Peter Sewell Iulian Neamtiu. University of Cambridge Microsoft Research . University of Maryland \nCambridge England Cambridge England College Park, Maryland USA {First.Last}@cl.cam.ac.uk gmb@microsoft.com \n{mwh,neamtiu}@cs.umd.edu  ABSTRACT Dynamic software updates can be used to .x bugs or add features to \na running program without downtime. Essential for some appli\u00adcations and convenient for others, low-level \ndynamic updating has been used for many years. Perhaps surprisingly, there is little high\u00adlevel understanding \nor language support to help programmers write dynamic updates effectively. To bridge this gap, we present \nProteus, a core calculus for dy\u00adnamic software updating in C-like languages that is .exible, safe, and \npredictable. Proteus supports dynamic updates to functions (even active ones), to named types and to \ndata, allowing on-line evolution to match source-code evolution as we have observed it in practice. We \nensure updates are type-safe by checking for a property we call con-freeness for updated types t at the \npoint of update. This means that non-updated code will not use t con\u00adcretely beyond that point (concrete \nusages are via explicit coer\u00adcions) and thus t s representation can safely change. We show how con-freeness \ncan be enforced dynamically for a particular program state. We additionally de.ne a novel and ef.cient \nstatic updateabil\u00adity analysis to establish con-freeness statically, and can thus auto\u00admatically infer \nprogram points at which all future (well-formed) updates will be type-safe. We have implemented our analysis \nfor C and tested it on several well-known programs. Categories and Subject Descriptors D.2.4 [Software \nEngineering]: Software/Program Veri.cation Validation; D.3.3 [Programming Languages]: Formal De.nitions \nand Theory Semantics,Syntax General Terms Design, Languages, Reliability, Theory, Veri.cation  Keywords \ndynamic software updating, updateability analysis, type inference, capability, Proteus Permission to \nmake digital or hard copies of all or part of this work for personal or classroom use is granted without \nfee provided that copies are not made or distributed for pro.t or commercial advantage and that copies \nbear this notice and the full citation on the .rst page. To copy otherwise, to republish, to post on \nservers or to redistribute to lists, requires prior speci.c permission and/or a fee. POPL 05, January \n12 14, 2005, Long Beach, California, USA. Copyright 2005 ACM 1-58113-830-X/05/0001 ...$5.00. 1. INTRODUCTION \nDynamic software updating (DSU) is a technique by which a running program can be updated with new code \nand data with\u00adout interrupting its execution. DSU is critical for non-stop systems such as air-traf.c \ncontrol systems, .nancial transaction processors, enterprise applications, and networks, which must provide \ncontin\u00aduous service but nonetheless be updated to .x bugs and add new features. DSU is also useful for \navoiding the need to stop and start a non-critical system (e.g., reboot a personal operating system) \nev\u00adery time it must be patched. Providing general-purpose DSU is particularly challenging be\u00adcause of \nthe competing concerns of .exibility and safety. On the one hand, the form of dynamic updates should \nbe as unrestricted as possible, since the purpose of DSU is to .x bugs or add features not necessarily \nanticipated in the initial design. On the other hand, supporting completely arbitrary updates (e.g., \nbinary patches to the existing program) makes reasoning about safety impossible, which is unacceptable \nfor mission-critical software. In this paper we present Proteus, a general-purpose DSU formal\u00adism for \nC-like languages that carefully balances these two concerns, and adds assurances of predictability. Proteus \nprograms consist of function and data de.nitions, and de.nitions of named types. In the scope of a named \ntype declaration t = t the programmer can use the name t and representation type t interchangeably but \nthe distinction lets us control updates. Dynamic updates can add new types and new de.nitions, and also \nprovide replacements for exist\u00ading ones, with replacement de.nitions possibly at changed types. Functions \ncan be updated even while they are on the call-stack: the current version will continue (or be returned \nto), and the new ver\u00adsion is activated on the next call. Permitting the update of active functions is \nimportant for making programs more available to dy\u00adnamic updates [1, 12, 4]. We also support updating \nfunction point\u00aders. Based on our experience [12] and a preliminary study on the evolution of C programs \n(\u00a72), we believe Proteus is .exible enough to support a wide variety of dynamic updates. When updating \na named type t from its old representation t to a new one t ', the user provides a type transformer function \nc with type t . t. . This is used to convert existing t values in the pro\u00adgram to the new representation. \nTo ensure an intuitive semantics, we require that at no time can different parts of the program expect \ndifferent representations of a type t; a concept we call representa\u00adtion consistency. The alternative \nwould be to allow new and old de.nitions of a type t be valid simultaneously. Then, we could copy values \nwhen transforming them, where only new code sees the copies [10, 12]. While this approach would be type \nsafe, old and new code could manipulate different copies of the same data, which is likely to be disastrous \nin a language with side-effects. To ensure type safety and representation consistency, we must guarantee \nthe following property: after a dynamic update to some type t, no updated values v . of type t will ever \nbe manipulated con\u00adcretely by code that relies on the old representation. We call this property con-t-freeness \n(or simply con-freeness when not re\u00adferring to a particular type). The fact that we are only concerned \nabout subsequent concrete uses is important: if code simply passes data around without relying on its \nrepresentation, then updating that data poses no problem. Indeed, for our purposes the notion of con-freeness \ngeneralizes notions of encapsulation and type ab\u00adstraction in object-oriented and functional languages. \nThis is be\u00adcause concrete versus abstract uses of data are not con.ned to a single linguistic construct, \nlike a module or object, but could oc\u00adcur at arbitrary points in the program. Moreover, con-freeness \nis a .ow-sensitive property, since a function might manipulate a t value concretely at its outset, but \nnot for the remainder of its execution. To enforce con-freeness, Proteus programs are automatically an\u00adnotated \nwith explicit type coercions: abst e converts e to type t (assuming e has the proper type t), and conte \ndoes the reverse at points where t is used concretely. Thus, when some type t is up\u00addated, we can dynamically \nanalyze the active program to check for the presence of coercions cont, taking into account that subsequent \ncalls to updated functions will always be to their new versions. If any cont occurrences are discovered, \nthen the update is rejected. Unfortunately, the unpredictability of a dynamic con-free check could make \nit hard to tell whether an update failure is transient or permanent, since the dynamic check is for a \nparticular program state. Rather, we would prefer to reason about update behavior statically, to (among \nother things) assess whether there are enough update points. Therefore, we have developed a novel static \nup\u00addateability analysis. We introduce an update expression to label program points at which updates could \nbe applied. For each of these, we estimate those types t for which the program may not be con-t-free. \nWe annotate the update with those types, and at run time ensure that any dynamic update at that point \ndoes not change them. This is simpler than the con-free dynamic check, and more predictable. In particular, \nwe can automatically infer those points at which the program is con-free for all types t, precluding \ndynamic failure. This paper makes the following contributions: We present Proteus, a simple and .exible \ncalculus for reason\u00ading about representation-consistent dynamic software updat\u00ading in C-like languages \n(\u00a73). We motivate our DSU support in Proteus with a brief study of the changes over time to some large \nC programs, taking these as indicative of dynamic up\u00addates that we have to support (\u00a72).  We formally \nde.ne the notion of con-freeness, and prove that it is suf.cient to establish type safety in updated \nprograms (\u00a73.4).  We present a novel updateability analysis that statically in\u00adfers the types for which \na given update point is not con\u00adfree (\u00a74). We present some preliminary experience with an implementation \nof our analysis for C programs (\u00a74.4).  In \u00a76 and \u00a77 we discuss related work and conclude. 2. DYNAMIC \nSOFTWARE UPDATING To enable on-line evolution we must support software changes unanticipated during the \ninitial design. The kind of changes that must be support on-line are, we believe, similar to those that \ncan be observed off-line in the program source tree. Therefore, to motivate our approach to DSU we describe \nthe results of a small study we did on the source code evolution of some long-running services. Using \na custom tool, we compared increasing versions of a few large C programs. These include Linux, version \n2.4.17 (Dec. 2001) to 2.4.21 (Jun. 2003); BIND, versions 9.2.1 (May 2002) to 9.2.3 (Oct. 2003); Apache, \nversion 1.2.6 (Feb. 1998) to 1.3.29 (Oct. 2003); and OpenSSH, version 1.2 (Oct. 1999) to 3.8 (Feb. 2004). \nFor these programs, the changes followed a few key trends: The overwhelming majority of a version change \nconsists of added functions, or changes to existing functions which do not involve a changed type signature. \nFew, if any, functions are deleted. For example, BIND 9.2.2 9.2.3 resulted in 30 new functions added \nand 890 changed (starting from 3214 total functions). Of the changed functions, only 28 had a change \nof signature, of which about two-thirds were to add or remove arguments with the rest changing the type \nof an argument. As another example, Apache 1.3.0 1.3.6 resulted in 51 functions added, 10 deleted, and \n290 changed, of which 4 changed their type signature (starting from 836 total func\u00adtions).  Global variables \ntend to be fairly static, adding a few and deleting a few, but growing over time. For example, OpenSSH \ngrew from 106 to 251 total global variables from version 1.2.2 to 3.7, adding from 3 to 30 new variables \nper release, deleting up to 10. One change in Apache added 88 variables and deleted 37, but most added \nor deleted fewer than 10. It is extremely rare for a global variable to change type.  Data representations, \nwhich is to say type de.nitions, change between versions, though rarely. In C, types are de.ned with \nstruct and union declarations (aggregates), typedefs, and enums. Very often, the changes are to aggregates \nand in\u00advolve adding or removing a .eld. For example, moving from Linux 2.4.20 2.4.21 resulted in 36 changes \nto struct def\u00adinitions (out of 1214 total), of which 21 were the addition or removal of .elds, while \nthe remaining 15 were changes to the types of some .elds. Type de.nitions are rarely deleted.  In short, \nto match these kinds of changes DSU must readily sup\u00adport the addition of new de.nitions (functions, \ndata, or types), and the replacement of existing de.nitions (data or functions) at the same type. It \nmust also allow changes to function types and data representations, but not necessarily to the types \nof global variables. Proteus supports these kinds of changes.  3. PROTEUS This section de.nes a core \ncalculus Proteus that formalizes our ap\u00adproach to dynamic software updating. 3.1 Syntax Proteus models \na type-safe, C-like language augmented with dy\u00adnamic updating; its syntax shown in Figure 1. Programs \nP are a series of top-level de.nitions followed by an expression e.A fun z ... de.nes a top-level recursive \nfunction, and var z : t ... de.nes a top-level mutable variable (i.e., it has type t ref). A type t = \nt ... de.nes the type t. Top-level variables z (a.k.a. ex\u00adternal names) must be unique within P , and \nare not subject to a-conversion, so they can be unambiguously updated at run-time. Expressions e are \nlargely standard. We abuse notation and write multi-argument functions Types t ::= t | int |{l1 : t1,..., \nln : tn} | t ref | t1 . t2 Expressions e ::= n | x | z | r |{l1 = e1,..., ln = en}| e.l | e1 e2 | let \nx : t = e1 in e2 | ref e | !e | e1 := e2 | if e1 = e2 then e3 else e4 | update | abst e | cont e Values \nv ::= z | n |{l1 = v1,..., ln = vn} | r | abst v Programs P ::= fun z(x : t): t. = e in P | var z : \nt = v in P | type t = t in P | e Figure 1: Syntax for Proteus fun f(x1 : t1,...,xn : tn): t = e which \nare really functions that take a record argument, thus having type {x1 : t1,..., xn : tn}. t . We similarly \nsugar calls to such functions. The boxed expressions support dynamic updates; we describe them further \nbelow. The typing rules de.ne the judgment G f P : t , where G is a map from type names t, external names \nz, and local variables x to types t . Aside from our new constructs, type checking is standard. Example. \nFigure 2 shows a simple kernel for handling read and write requests on .les or sockets, which one might \nwant to dynami\u00adcally update. Some functions and type de.nitions have been elided for simplicity. Reading \nfrom the bottom, the function loop is an in\u00ad.nite loop that repeatedly gets req objects (e.g., system \ncalls) and then dispatches them to an appropriate handler using the dispatch function. This function \n.rst calls decode to determine whether a given .le descriptor is a network channel or an open .le (e.g., \nby looking in a table). If it is a network channel, dispatch calls getsock to get a sock object based \non the given .le descriptor (e.g., indexed in an array). Next, it decodes the remaining portion of the \nreq to acquire the transmission .ags. Finally, it .nds an ap\u00adpropriate sockhandler object to handle the \nrequest and calls that handler. Handlers are needed to support different kinds of network channel, e.g., \nfor datagram communications (UDP), for streaming connections (TCP), etc. Different handlers are implemented \nfor each kind, and getsockhandler chooses the right one. A similar set of operations and types would \nbe in place for .les. After dispatch completes, its result is posted to the user, and the loop continues. \nWe now discuss dynamic updates to this kernel and explain our new constructs (the boxed syntax from Figure \n1). Update. The update expression permits a dynamic update to take place, if one is available. That is, \nat run-time a user provides an update through an out-of-band signaling mechanism, and the next time update \nis reached in the program, that update is applied. Informally, an update consists of the following: Replacement \nde.nitions for named types t = t . Along with the new de.nition t = t ', the user provides a type trans\u00adformer \nfunction of type t . t ', used by the runtime to convert existing values of type t in the program to \nthe new representation. type handResult = int in type sockhandler = {sock : sock, buf : buf, s.ags : \ns.ags}. handResult in let udp read(sock : sock, buf : buf, s.ags : s.ags) : handResult = ... in let udp \nwrite(sock : sock, buf : buf, s.ags : s.ags) : handResult = ... in type req = {op : op, fd : int, buf \n: buf, rest : blob} in type fdtype = File | Socket | Unknown in let dispatch (s : req): handResult = \nlet t = decode (s.fd) in if (t = Socket) then let k = getsock (s.fd) in let .ags = decode sockopargs \n(s.rest, s.op) in let h = getsockhandler (s.fd, s.op) in h (k, s.buf, .ags) else if (t = File) then ... \nelse - 1 in let post (r : handResult): int = ... in let loop (i : int): int = let req = getreq (i) in \nlet i = post (dispatch req) in loop i in loop 0 Figure 2: A simple kernel for .les and socket I/O Replacement \nde.nitions for top-level identi.ers z, having the same type as the original.  New type, function, and \nvariable de.nitions.  We consider extending speci.cations to support binding deletion in \u00a75. When writing \nan updateable program, the programmer can insert update manually, and/or the compiler can insert update \nautomatically. Figure 3 shows dispatch from Figure 2 with some added update expressions (it also includes \ntype coercions, dis\u00adcussed next). We consider a strategy for automatic insertion of update in \u00a74. Type \nCoercions. In Figure 2, within the scope of a type def\u00adinition like type sockhandler = ... the type sockhandler \nis a synonym for its de.nition. For example, the expression h (k, s.buf, .ags) in dispatch uses h, which \nhas type sockhandler, as a function. In this case, we say that the named type sockhandler is being used \nconcretely. However, there are also parts of the program that treat data of named type abstractly, i.e., \nthey do not rely on its representation. For example, the getsockhandler function simply returns a sockhandler \nvalue; that the value is a function is incidental. In the Proteus semantics (but not in the user source \nlanguage) all uses of a named type de.nition t = t are made explicit with type coercions: abst e converts \ne to type t (assuming e has the proper type t), and cont e does the reverse. For example, dispatch in \nFigure 3 constructs a handResult value from -1 via the coercion abshandResult - 1. Conversely, to invoke \nh, it must be converted from type sockhandler via the coercion (consockhandler h)(...). Type coercions \nserve two purposes operationally. First, they are used to prevent updates to some type t from occurring \nat a time when existing code still relies on the old representation. In par\u00adticular, the presence of \ncont clearly indicates where the concrete UN : sockhandler . ({sock : sock, buf : buf, s.ags : s.ags, \ncookie : cookie}. int, sockh coer) sock . ({daddr : int,... }, sock coer) AN : sockhandler . (cookie, \nint) UB : dispatch . (req . handResult,.(s).. . . (consockhandler h)(k, (conreq s).buf, .ags, (security \ninfo ()) ... ) AB : udp read' . ({sock : sock, buf : buf, s.ags : s.ags, cookie : cookie}. int,.(x).... \n) udp write' . ({sock : sock, buf : buf, s.ags : s.ags, cookie : cookie}. int,.(x).... ) sockh coer . \n(({sock : sock, buf : buf, s.ags : s.ags}. int) . ({sock : sock, buf : buf, s.ags : s.ags, cookie : cookie}. \nint), .(f).if f= udp read then udp read' else if f= udp write then udp write' ) sock coer . ... security \ninfo . (int . cookie,.(x).. . . ) Figure 4: A sample update to the I/O kernel let dispatch(s : req): \nhandResult = let t= decode((conreq s).fd) in let u1 = update in if (confdtype t) = Socket then let k= \ngetsock((conreq s).fd) in let .ags = decode sockopargs((conreq s).rest, (conreq s).op) in let h= getsockhandler((conreq \ns).fd, (conreq s).op) in let u2 = update in let res = (consockhandler h)(k, (conreq s).buf, .ags) in \nlet u3 = update in res else if (confdtype t) = File then ... else (abshandResult -1 ) Figure 3: dispatch \nwith explicit update and coercions representation of t is relied upon, and therefore can be used as part \nof a static or dynamic analysis to avoid an invalid update (\u00a73.4). Second, coercions are used to tag \nabstract data so it can be converted to a new representation should its type be updated. In particular, \nall instances of type t occurring in the program will have the form abst e. Therefore, given a user-provided \ntransformer function ct which converts from the old representation of t to the new, we can rewrite each \ninstance at update-time to be abst (ct e). This leads to a natural CBV evaluation strategy for transformers \nin conjunction with the rest of the program (\u00a73.3). The typing rules for coercions are simple: G, t . \nt f e : t G, t . t f e : t G, t . t f cont e : t G, t . abst e : t Because variables are explicitly annotated \nwith types, inserting abs and con coercions automatically is a relatively straightfor\u00adward application \nof subtyping-as-coercions [3]; further details will appear in the extended version [19].  3.2 Specifying \nDynamic Updates Formally, a dynamic update upd consists of four elements, writ\u00adten as a record with the \nlabels UN, UB, AN, and AB: UN (Updated Named types) is a map from a type name to a pair of a type and \nan expression. Each entry, t . (t, c), speci.es a named type to replace (t), its new representation type \n(t), and a type transformer function c from the old rep\u00adresentation type to the new.  AN (Added Named \ntypes) is a map from type names t to type environments O, which are lists of type de.nitions. This is \nused to de.ne new named types. The domain speci.es types t in the existing program, and the new de.nitions \nare inserted just above t for scoping purposes.  UB (Updated Bindings) is a map from top-level identi.ers \nto a pair of a type and a binding value bv, which is either  a function .(x).e or a value v. These specify \nreplacement fun and var de.nitions. Each entry z . (t, bv) contains the binding to replace (z), the type \nof the new binding as it appears in the source program (t), which must be equal to the current type, \nand the new binding (bv). AB (Added Bindings) is a map from top-level identi.ers z to pairs of types \nand binding values. These are used to specify new fun and var de.nitions. Because our runtime seman\u00adtics \npermits top-level de.nitions to be mutually recursive, their ordering with the existing program is of \nno consequence (we could easily change the source language to support this). As an example, say we wish \nto modify socket handling in Fig\u00adure 2 to include a cookie argument for tracking security information \n(this was done at one point in Linux). This requires four changes: (1) we modify the de.nition of sockhandler \nto add the additional argument; (2) we modify the sock type to add new information (such as a destination \naddress for which the cookie is relevant); (3) we modify existing handlers, like udp read, to add the \nnew func\u00adtionality, and (4) we modify the dispatch routine to call the handler with the new argument. \nThe user must provide functions to convert existing sock and sockhandler objects. The update is shown \nin Figure 4. The UN component speci.es the new de.nitions of sock and sockhandler, along with type trans\u00adformer \nfunctions sockh coer and sock coer, which are de.ned in AB. The AN component de.nes the new type cookie \n= int, and that it should be inserted above the de.nition of sockhandler (which refers to it). Next, \nUB speci.es a replacement dispatch function that calls the socket handler with the extra security cookie, \nwhich is acquired by calling a new function security info. The AB component speci.es the de.nitions to \nadd. First, it spec\u00adi.es new handler functions udp read' and udp write' to be used in place of the existing \nudp read and udp write functions. The rea\u00adson they are de.ned here, and not in UB, is that the new versions \nof these functions have a different type than the old versions (they take an additional argument). So \nthat code will properly call the new versions from now on, the sock coer maps between the old ones and \nthe new ones. Thus, existing datastructures that contain handler objects (such as the table used by getsockhandler) \nwill be updated to refer to the new versions. If any code in the program called udp read or udp write \ndirectly, we could replace them with stub functions [12, 7], forwarding calls to the new version, and \n.lling in the added argument. Thus, Proteus indirectly supports up\u00addating functions to new types for \nthose rare occasions when this is necessary.  3.3 Operational Semantics The operational semantics is \nshown in Figure 5, de.ned as a judgment of the form O; H, e -. O; H',e' over con.gurations consisting \nof a type environment O, a heap H and an expression ' H, P -. H ' ,P (PROJ) H, {l1 = v1, . . . , ln \n= vn}.li -. H, vi (REF) H, ref v -. (H, r . (\u00b7, v)), r (LET) H, let x : t = v in e -. H, e[x := v] (ASSIGN) \n(H, . . (., e)), . := v -. (H, . . (., v)), v (DEREF) (H, . . (., e)), !. -. (H, . . (., e)), . := e \n(CALL) (H, z . (t, .(x).e )), z v -. (H, z . (t, .(x).e ), e[v/x] (IF-T) H, if v1 = v2 then e1 else e2 \n-. (IF-F) H, if v1 = v2 then e1 else e2 -. H, e1 (where v1 = v2) H, e2 (where v1 .= v2) (CONABS) H, cont \n(abst v) -. H, v (NO-UPDATE) H, update -. H, 1 O; H, P -. O; H ' , P ' updateOK(upd, O, H, E[1]) '' \nH, e -. H ,e upd (CONG)(UPDATE); U[ H ]upd O; H, E[update] - -. U[O]upd, U[ E[0] ]upd O; H, E[e] -. \nO; H, E[e ' ] upd otherwise: O; H, E[update] - -. UpdEx Eval Contexts E ::= | let x = E in e | E e | \nv E | E.l |{l1 = v1,..., li = E,..., ln = en}| ref E| !E| E := e | v := E | cont E| abst E | if E = e \nthen e1 else e2 | if v = Ethen e1 else e2 Heap addresses . ::= z | r Heap type tags . ::= t |\u00b7 Heap bindings \nb ::= .(x).e | e Heap values bv ::= .(x).e | v U[b]upd (updating bindings) U[n]upd U[x]upd U[x]upd = \nn = x = x U[G]upd (updating environments) 8 >>< >>: abst (c U[e]upd ) U[\u00d8]upd ' = types(upd.AB) if \nt . (t, c) . upd.UN abst U[e]upd U[x : t, G]upd = x : t, U[G]upd otherwise U[abst e]upd = For remaining \nb containing subterms e1,...,en, U[r : t, G]upd = r : t, U[G]upd we inductively apply U[ei]upd U[z : \nt, G]upd = j ' ), U[G]upd ' z : heapType(t if upd.UB(z)=(t, ) U[H]upd (updating the heap) z : t, U[G]upd \notherwise t = upd.AN(t), G ' U[ z =(t, b),H ]upd z =(t ' ,b ' ), U[ H ]upd 8 >>< if upd.UB(z)=(t ' ,b \n' ) if t . dom(upd.AN) U[t = t, G]upd = G ' otherwise j 8 >>< t = t ' , U[G]upd ' if upd.UN(t)=(t = \n, ) ), U[ H ]upd z =(t, U[ b ]upd >>: where G ' = otherwise t = t, U[G]upd otherwise >>: )), U[H]updU[r \n=(\u00b7,b),H]upd =(r =(\u00b7, U[b]upd U[\u00d8]upd = upd.AB Auxiliary function to convert update types to heap types: \nheapType(t1 . t2)= t1 . t2 heapType(t)= t ref where t =.t1 . t2 C(O; H; P ) = O; H; e (compilation from \nprograms to con.gurations) C(O; H; e) =O; H; e C(O; H; type t = t in P )= C(O, t = t; H; P ) ' C(O; \nH; fun f(x : t): t = e in P )= C(O; H, f . (t . t ' ,.(x).e ); P ) C(O; H; var z : t = v in P )= C(O; \nH, z . (t, v); P ) Figure 5: Proteus Operational Semantics e. To evaluate a program P , we compile it \ninto a con.guration O; H, e = C(\u00d8; \u00d8; P ), as shown in the Figure. The type environment O de.nes a con.guration \ns named types. Each type in dom(O) maps to a single representation t; some re\u00adlated approaches [6, 12] \nwould permit t to map to a set of repre\u00adsentations indexed by a version. We refer to our non-versioned \nap\u00adproach as being representation consistent since a running program has but one de.nition of a type \nat any given time. The heap H is a map from heap addresses . to pairs (., b), where . is a type tag and \nb is a binding. We use the heap to store both mutable references created with ref and top-level bindings \ncreated with var and fun; therefore . ranges over locations r and external names z. For normal references, \nthe type tag . is simply \u00b7, indicating the absence of a type, and for identi.ers, z, it is the type t \nwhich appeared in the de.nition of z in the program. Type tags are used to type check new and replacement \nde.nitions provided by a dynamic update. The operational semantics is given using evaluation contexts. \nAll expressions e can be uniquely decomposed into E[e ' ] for some eval\u00aduation context Eand e ' , so \nthe choice of rule is unambiguous. Next, we consider how our semantics expresses the interesting operations \nof dynamic updating: (1) updating top-level identi.ers z with new de.nitions, and (2) updating type de.nitions \nt to have a different representation. Replacing Top-level Identi.ers. All top-level identi.ers z from \nthe source program are essentially statically-allocated refer\u00adence cells. As a result, at update-time \nwe can change z s binding in the heap, and afterward any code that accesses (dereferences) z will see \nthe new version. However, our treatment of references differs somewhat from the standard one to facilitate \ndynamic updates. First, since all functions are de.ned at the top-level, they are all references. However, \nrather than give top-level functions the type (t1 . t2) ref, we simply give them type t1 . t2, and perform \nthe dereference as part of the (CALL) rule. This has the pleasant side effect of rendering top-level \nfunctions immutable during nor\u00admal execution, as is typical, while still allowing them to be dynam\u00adically \nupdated. Second, as we have explained already, top-level bindings stored in the heap are paired with \ntheir type t to be able to type check new and replacement bindings. Some formulations of dynamic linking \nde.ne a heap interface, which maps variables z to types t, but we .nd it more convenient to merge this \ninterface into the heap itself. Updating Data of Named Type. As mentioned in \u00a73.1, Pro\u00adteus uses coercions \nto identify where data of a type t is being used abstractly and concretely. The (CONABS) rule allows \nan abstract value abst v to be used concretely when it is provided to cont; this annihilates both coercions \nso that v can be used directly. At update time, given a type transformation function c for an up\u00addated \ntype t, we rewrite each occurrence abst e to be abst (c e). Although only values can be stored in the \nheap initially, heap val\u00adues of the form abst v, will be rewritten to be abst (c v), which is no longer \na value. Therefore, !r can potentially dereference an expression from the heap. While this is not a problem \nin itself, the transformation should be performed only once since it conceptually modi.es the data in \nplace. Therefore, the (DEREF) rule evaluates the contents of the reference and then writes back the result \nbefore proceeding. Update Semantics. A dynamic update upd is modeled with a labeled transition, where \nupd labels the arrow. When no up\u00addate is available, an update expression simply evaluates to 1, by (NO-UPDATE). \nOtherwise, (UPDATE) speci.es that if upd is well\u00adformed (by updateOK(-)), the update evaluates to 0, \nand the program is updated by transforming the current type environment, heap, and expression according \nto U[-]upd . When transforming expressions, U[-]upd applies type transformation functions to all abst \ne expressions of a named type t that has been updated. When transforming the heap, it replaces top-level \nidenti.er de.nitions with their new versions, and adds all of the new bindings. When transforming O,1 \nit replaces type de.nitions with their new ver\u00adsions, and inserts new de.nitions into speci.ed slots \nin the list.  3.4 Update Safety The conditions placed upon an update to guarantee type-safety are formally \nexpressed by the precondition to the (UPDATE) rule given in Figure 7. The updateOK(-) predicate must \ndetermine that at the current point it is valid to apply this update a dynamic property and that the \nupdate is compatible with the program. The latter is a static property, in the sense that the information \nto per\u00adform it is available without recourse to the current state of the pro\u00adgram, provided one has the \noriginal source and the updates previ\u00adously applied. let i= post ( let u2 = update in let res = (consockhandler \nabssockhandler udp read) {sock = vsock, buf =(conreq vreq).buf, s.ags = vs.ags} in let u3 = update in \nres ) in loop i Figure 6: Example active expression Update Timing. To motivate the importance of timing, \nFig\u00adure 6 shows the expression fragment of our example program after some evaluation steps (the outer \nlet i= ... binding comes from loop and the argument to post is the partially\u00adevaluated dispatch function). \nThe let u2 = update ... is in redex position, and suppose that the update described in \u00a73.2 is available, \nwhich updates sockhandler to have an additional cookie argument, amongst other things. After applying \nthe up\u00addate, the user s type transformer sockh coer is inserted to con\u00advert udp read, to be called next. \nEvaluating the transformer re\u00adplaces udp read with udp read ' , and applying (CONABS) yields the expression \nudp read ' (vsock, (conreq vreq).buf,vs.ags). But this is type-incorrect! The new version udp read ' \nexpects a fourth ar\u00adgument, but the existing call only passes three arguments. The problem is that at \nthe time of the update the program is eval\u00aduating the old version of dispatch, which expects sockhandler \nval\u00adues to take only three arguments. That is, this point in the program is not con-t-free since it will \nmanipulate t values concretely. This fact is made manifest by the usage of consockhandler in the active \nex\u00adpression. In general, we say a con.guration O; H, e is con-free for an update upd if for all named \ntypes t that the update will change, cont is not a subexpression of the active expression e or any of \nthe bindings in the heap that are not replaced by the update. We write this as conFree[ - ]upd; the de.nition \nis given in Figure 7. Two other points are worth noting. First, the active expression only uses instances \nof handResult abstractly after the update (pass\u00ading them to post), and so should we wish, handResult \ncould be 1O is just a simpler form of G, so U[O]upd is de.ned by U[G]upd shown in the Figure, with the \nexception that U[\u00d8]upd = \u00d8 (i.e. the types of the new bindings are not added). conFree[ z =(t, b),H \n]upd j updateOK(upd, O, H, e)= tt if z . dom(upd.UB)= conFree[ H ]upd . conFree[ H ]upd. conFree[ b \n]upd otherwise conFree[ e ]upd. conFree[ r =(\u00b7,e),H ]upd = conFree[ e ]upd . conFree[ H ]upd G = types(H). \nconFree[ n ]upd = tt conFree[ x ]upd = tt fU[O]upd. U[O, G]upd j .t . (t, c) . upd.UN. f c : O(t) . \nt. . if t . dom(upd.UN) U[O, G]upd conFree[ cont e ]upd = .z . (t, bv) . upd.UB. f bv : t. tt otherwise \n'' bv = e ..t. G(z)= t ref. heapType(t) = G(z). For remaining b containing subterms e1,...,en: V .z \n. (t, bv) . upd.AB. U[O, G]upd f bv : t conFree[ e ]upd = i ei Figure 7: Proteus updateOK(-)- check and \nauxiliary de.nitions modi.ed (assuming that post is modi.ed as well). Second, the given update is only \nunsafe at the .rst update point; it could be safely applied at let u3 = update ..., since at that point \nthere are no further concrete uses of any of the changed types. Update well-formedness. The conditions \nfor update well\u00adformedness are part of the updateOK(-) predicate in Figure 7. In addition to checking \nproper timing with the conFree[ - ] checks, this predicate ensures that type-safety is maintained following \nthe addition or replacement of code and types. The types(H) predi\u00adcate extracts all of the type tags \nfrom H and constructs a suitable G for typechecking the new or replacement bindings. Since heap ob\u00adjects \nare stored with their declared type t, if they are non-functions, in G they are given type t ref. Next, \nthe updated type environment U[O]upd is checked for well-formedness. Then, using the updated O and G, \nwe check that the type transformer functions, replacement bindings and new bindings are all well-typed. \nThe important fact to notice about these type-checks is that they only apply to expres\u00adsions contained \nin the update. Only the types of existing code, not the code itself, are needed. The extra checks in \nthe replacement bindings clause ensure that a heap cell doesn t change between a function an a reference \ncell and that the type of the cell is preserved.  3.5 Properties Proteus enjoys an essentially standard \ntype safety result. Theorem 3.1 (Type safety). If f O; H, e : t then either ' ''' ' 1. O; H, e . O ' \n; H ,e and f O ' ; H ,e : t for some O ' ,H and e ' ; 2. O; H, e . UpdEx; or 3. e is a value  This \ntheorem states that a well-typed program is either a value, or is able to reduce (and remain well-typed), \nor terminates abruptly due to a failed dynamic update. The most interesting case in proving type preservation \nis the update rule, for which we must prove a lemma that well-formed and well-timed updates lead to well-typed \nprograms: Lemma 3.2 (U[ - ]- preserves types of programs). Given f O; H, e and an update, upd, for which \nwe have updateOK(upd, O, H, e), then f ; U[ H ]upd , U[ e ]upd U[O]upd : t .  4. ASSURING PROPER UPDATE \nTIMING Type safety in the system we have described so far is predicated on a dynamic con-free check. \nUnfortunately, this check could be dif.cult to implement, and moreover could fail if the update is ap\u00adplied \nat a bad time. The main result of this section is that given an unannotated Proteus program (no abst \nor cont or update ex\u00adpressions), we can statically infer all of the program points that are con-free \nwith respect to all types in the program, and insert update there. Thus, we eliminate the need for conFree[ \n- ]2 and we make the update behavior of the program easier to reason about, since many acceptable update \npoints are known statically. In this section, we present our updateability analysis as a type and infer\u00adence \nsystem, establish its soundness, and present some preliminary performance measurements on large C programs \nwhich show that the analysis is quite ef.cient. 4.1 Capabilities Our goal is to de.ne and enforce a notion \nof con-freeness for a program, rather than a program state. In other words, we wish to determine for \na particular update whether it will be accept\u00adable to update some type t. An update to t will be unacceptable \nif an occurrence of cont exists in any old code evaluated in the continuation of the update. Assuming \nwe can discover all such occurrences of cont, we could annotate update with those types t, indicating \nthat they should not be updated. We call this annota\u00adtion . a capability, since it serves as a bound \non what types may be used concretely in the continuation of an update. That is, any code following an \nupdate must type check using G restricted to those types listed in the capability. Since an update could \nchange only types not in the capability, we are certain that existing code will remain type-safe. As \na consequence, if we can type-check our program containing only update points with empty annotations, \nwe can be sure that no update will fail due to bad timing.  4.2 Typing We de.ne a capability type system \nthat tracks the capability at each program point to ensure that updates are annotated soundly. First \nwe change slightly the grammar for types: Capabilities . ::= {t1,... tn}| . n . Updateability \u00b5 ::= U \n| N \u00b5;.;.. Types t ::= \u00b7\u00b7\u00b7 | t -. t We assume that update occurrences are annotated with some ., and \nfunction de.nitions are annotated with some \u00b5; .; . ' (\u00a74.4 explains how to infer such annotations). \n Proofs will appear in the extended version [19]. 2We may wish to combine it with the static analysis. \nSee \u00a74.3. .; G f\u00b5 e : t;. ' .; G f\u00b5 n : int;. (A.Int) .; G,x : t f\u00b5 x : t;. (A.Var) .; G, x : t f\u00b5 x \n: t;. (A.XVar) \u00b5; .' ' .; G f\u00b5 e1 : t1 -. t2;. ' .; .; G f\u00b5 e1 : t ;. ' 1. ''' . . '' . ' ;G f\u00b5 e2 : \nt1;. '' . ' ;G,x : t1 f\u00b5 e2 : t2;. '' (A.Let) (A.App) \u00b5 = U) . (\u00b5 = U . . ''' ( . . ' ) .; G f\u00b5 let x \n: t = e1 in e2 : t2;. '' .; G f\u00b5 e1 e2 : t2;. ''' .i; G f\u00b5 ei+1 : ti+1; .i+1 i . 1..(n - 1) n = 0 .; \nG f\u00b5 e : {l1 : t1, . . . , ln : tn}; . ' (A.Rec) (A.Proj) .0; G f\u00b5 {l1 = e1, . . . , 1n = en} : {l1 : \nt1, . . . , ln : tn}; .n .; G f\u00b5 e.li : ti; . ' .; G f\u00b5 e : t; . ' (A.Ref) .; G f\u00b5 e : t ref; . ' (A.Deref) \n.; G f\u00b5 e1 : t ref; . ' . ' ; G f\u00b5 e2 : t; . '' (A.Assign) .; G f\u00b5 ref e : t ref; . ' .; G f\u00b5 !e : t; \n. ' .; G f\u00b5 e1 := e2 : unit; . '' .; G f\u00b5 e : t; . ' G1.' (t) = t .; G f\u00b5 e : t; . ' G(t) = t (A.Con) \n(A.Abs) .; G f\u00b5 cont e : t; . ' .; G f\u00b5 abst e : t; . ' ' . . '' . ' . . .;G f\u00b5 e : t ' ;. '' G f t<: \nt . ' (A.Update) (A.Sub) .; G fU update.' : unit;. ' .; G f\u00b5 e : t;. ' .; G f\u00b5 e : t; .1 .2; G f\u00b5 e1 \n: t ' ; .3 .1; G f\u00b5 e ' : t; .2 .2; G f\u00b5 e2 : t ' ; .4 (A.If) . ' . . . ' ; G fU e1 : t ' ; .1 .; G fU \ne2 : t ' ; .2 (A.If.Update) .; G f\u00b5 if e = e ' then e1else e2 : t ' ; .3 n .4 .; G fU if update.' = 0 \nthen e1else e2 : t ' ; .1 n .2 G fP P : t ' \u00b5;.;.' G, t = t fP P : t G ' =G,z : t1 -. t2 G f t ' OK \n(A.Type) .; G ' ,x : t1 f\u00b5 e : t2;. ' G ' fP P : t (A.LetF) ' G fP type t = t in P : t \u00b5;.;.' G fP \nfun z(x : t1): t2 = e in P : t '' \u00d8;G fN v : t ; \u00d8 G, z : t ref fP P : t .; G fU e : t;. ' (A.LetV) \n(A.Exp) ' G fP var z : t = v in P : t G fP e : t ' G f t<: t '' G f t<: t G f t<: t G f int <: int \n(A.Sub.Int) G, t = t f t <: t (A.Sub.Type) (A.Sub.Ref) ' G f t ref <: t ref '' G f t2 <: t1 G f t<: t \n 12 ' t1 <: ti . 1..n . ' . . ' (\u00b52 = U) . (\u00b51 = U) 1 21 (A.Sub.Fun) (A.Sub.Rec) '' \u00b51;.1;.'1 ' \u00b52;.2;.'2 \n' {l1 : t1, ..., ln : tn} <: {l1 : t1, ..., ln : tn} G f t1 -. t1 <: t2 -. t 2 G f b : t G f O; H, e \n: t .; G, x : t f\u00b5 e : t ' ; . ' G f .(x).e : t \u00b5;.;.'-. t ' O; F f H (A.Bind.Fun) \u00d8; G fN e : t; \u00d8 G \nf e : t (A.Bind.Expr) f O O; F f H .; G, O, F fU e : t; . ' G f O; H, e : t dom(F) = dom(H) .z . (t, \ne) . H. \u00d8; F fN e : t; \u00d8 . F(z) = t ref .z . (t, .(x).e ) . H. G f .(x).e : t . F(z) = t .r . (\u00b7, e) \n. H. \u00d8; F fN e : t; \u00d8 . F(r) = t ref O; F f H Type environment typing, f O, has a standard de.nition, \nessentially ensuring that there are no free type names. Figure 8: Capability typing for Proteus programs \nThe type system is given in Figure 8, with judgments .; G f\u00b5 e : t ;. ' for expressions, and G fP P : \nt for programs. For expression typings, . is the capability before e is evaluated, and . ' is the capability \nafterward. Each rule is actually a family of rules parameterized by an updateability \u00b5 which indicates \nwhether a dynamic update may be performed while evaluating the given expression. This is used to rule \nout dynamic updates in undesirable contexts, as we explain in the next subsection. Typing update and \ncont e. The capability . ' on update. ' lists those types that must not change due to a dynamic update. \nSince any other type could change, the (A.Update) rule assumes that the capability can be at most . ' \nfollowing the update. The (A.Con) rule states that to concretely access a value of type t, the type t \nmust be de.ned in G, restricted to types listed in ca\u00adpability . ' . Thus, to type check dispatch in \nFigure 3, we must annotate the update in let u1 = update in ... with a capability {fdtype, req, sockhandler}, \nsince these types are used by con expressions following that point within dispatch. By the same reasoning, \nthe annotation on the u2 update would be {req, sockhandler}, and the u3 update annotation can be empty. \nThe (A.Update) rule requires updateability U; updates cannot be performed in a non-updateable (N) context. \n(A.Update) assumes that any update could result in an up\u00addate at run time. However, we can make our analysis \nmore pre\u00adcise by incorporating the effects of a dynamic check. In particular, (A.If.Update) checks if \nwhen the guard is update. ' =0, which will be true only if an update takes place at run time. Therefore, \nthe input capability of e1 is . ' , while the input capability of e2 is .. Function calls. Function types \nhave an annotation \u00b5; .; . ' , where . is the input capability and . ' is the output capabil\u00adity. If \ncalling a function could result in an update, the update\u00adability \u00b5 must be U. Thus, in Figure 3, using \nthe annotations on update mentioned above, the type for dispatch would be U;.;\u00d8 req -. handResult, for \nsome . satisfying the condition {req, fdtype, sockhandler}. . In the (A.Update) rule, the output capability \nis bounded by the an\u00adnotation on the update; in the (A.App) rule, the caller s output capability . ''' \nis bounded by the callee s output capability . ' for the same reason. This is expressed in the conditional \nconstraint ( \u00b5 = U) . (\u00b5 = U ..., which also indicates the caller s up\u00addateability \u00b5 must allow the update. \nIf the called function cannot perform an update, then the caller s capability and updateability need \nnot be restricted. We will take advantage of this fact in how we de.ne type transformer functions, described \nbelow. A perhaps unintuitive effect of (A.App) is that a function f s output capability must mention \nthose types used concretely by its callers following calls to f. To illustrate, say we modify the type \nof post in Figure 2 to be int . int rather than handResult . int. As a result, loop would have to concretize \nthe handResult returned by dispatch before passing it to post, resulting in the code let i = post (conhandResult \n(dispatch req))... To type check the con would require the output capability of dispatch to include handResult, \nwhich in turn would require that handResult appear in the capabilities of each of the update points in \ndispatch, preventing handResult from being updated. Another unintuitive aspect of (A.App) is that to \ncall a function, we would expect that the caller s capability must be compatible with (i.e., must be \na superset of) the function s input capability, but updateOK(upd, O, H, .) = G = types(H). (a) dom(.) \nn dom(upd.UN) = \u00d8. bindOK[ G ]upd . fU[O]upd. .t . (t, c) . upd.UN. (b) N;. ' ;. '' \u00d8; U[O, G]upd fNc \n: O(t) -. t; \u00d8 . U[O, G]upd .z . (t, bv) . upd.UB. f bv : t. '' bv = e ..t. G(z)= t ref (c) U[O]upd \nf heapType(t) <: G(z) . U[O, G]upd .z . (t, bv) . upd.AB. f bv : t Figure 9: Precondition for update. \noperational rule this condition is not necessary. Instead, the type system assumes that all calls will \nbe to a function s most recent version, which will be guaranteed at update-time to be compatible with \nthe program s type de.nitions (see \u00a74.3). In effect, the type system approximates, for a given update \npoint, the concretions in code that an updating function could return to, but not code it will later \ncall, which is guaranteed to be safe. This is critical to avoid restricting updates unnecessarily. Other \nRules. Unlike cont e expressions, abst e expressions place no constraint on the capability. This is because \na dynamic update that changes the de.nition of t from t to t ' requires a well\u00adtyped type transformer \nc to rewrite abst e to abst (c(e)), which will always be well-typed assuming suitable restrictions on \nc de\u00adscribed in the next subsection. Turning to program typing, the (A.type) rule adds a new type de.nition \nto the global environment, and the (A.LetF) rule simply checks the function s body using the capabilities \nand updateability de.ned by its type. Since v is a value and cannot effect an update, the (A.LetV) rule \nchecks it with an empty capability . and update\u00adability N. Finally, the (A.Exp) rule type checks the \nbody of the program using an arbitrary capability and updateability U to allow updates. Allowing subtyping \nadds .exibility to programs and to their up\u00addates. The interesting rule is (A.Sub.Fun) for function types. \nOut\u00adput capabilities are contravariant: if a caller expects a function s output capability to be ., it \nwill be a conservative approximation if the function s output capability is actually larger. There is \nno re\u00adstriction on the input capability for updateable functions, since we always assume them to be compatible \nwith the current set of type de.nitions for the program. A function that performs no updates can be a \nsubtype of one that does, assuming they have compati\u00adble capabilities. During type checking, subtyping \nis invoked by the (A.Sub) rule, which can simultaneously coarsen (makes smaller) the output capability \n.. Intuitively, this is always sound because it will put a stronger restriction on limits imposed by \nprior updates. We need additional typing judgments to ensure the well\u00adformedness of con.gurations and \nthe consistency of heaps. These properties are expressed by the G f O; H, e : t and O; F f H judgments \nrespectively. An additional judgment G f b : t is used for typing heap bindings.  4.3 Operational Semantics \nThe dynamic semantics from Figure 5 remains unchanged with the exception of the updateOK(-) predicate \nfor (UPDATE), shown in Figure 9. The two timing-related changes are highlighted by the boxes labeled \n(a) and (b). First, ., taken from update. , replaces e as the last argument. This is used in (a) to syntactically \ncheck that no types mentioned in . are changed by the update. Change (a) also refers to bindOK[ G ]upd \nto ensure that all top\u00adlevel bindings in the heap that use types in upd.UN concretely, as indicated by \ntheir input capability, are also replaced (the de.nition is straightforward and not shown). This allows \nthe type system to assume that calling a function is always safe, and need not impact its capability. \nTogether, these two checks are analogous to the con\u00adfree dynamic check to ensure proper timing.3 Type \ntransformers provided for updated types must not, when in\u00adserted, violate assumptions made by the updateability \nanalysis. In particular, each abst e appearing in the program type checks with some capability prior \nto an update, i.e., .; G f\u00b5 abst e : t ;. ' . If type t is updated with transformer c, we require .; \nG f\u00b5 abst (c e): t ;. ' . Since abst e expressions could be anywhere at update time, and could require \na different capability . to type check, condition (b) conservatively mandates that transformers c must \ncheck in an empty capability, and may not perform updates (c s type must have updateability N). These \nconditions are suf.\u00adcient to ensure type correctness. Otherwise, a transformer function c is like any \nother function. For example, if it uses some type t con\u00adcretely, it will have to be updated if t is updated. \nThe rami.cations of this fact are explored in \u00a75. Finally, we allow bindings to updated at subtypes, \nas indicated by condition (c). This is crucial for functions, because as they evolve over time, it is \nlikely that their capabilities will change depending on what functions they call or what types they manipulate. \nFor\u00adtunately, we can always update an existing function with a func\u00adtion that causes no updates. In particular, \nsay function f has type U;{t,t ' };{t,t } t -. ' t ' , where t = int and t ' = int. Say we add a new \ntype t '' = int and want to change f to be the following: fun f(x : t): t ' = let y = cont '' abst '' \n1 in let z = cont x in abst ' z + y N;{t,t '' };{t,t '' } The expected type of this function would be \nt -. t ' , but U;{t,t ' ,t '' };{t,t ' ,t '' } it could just as well be given type t -. t ' , which is \na subtype of the original, and thus an acceptable replacement. Replacements that contain update or call \nfunctions that contain update are more rigid in their capabilities. We expect that experi\u00admenting with \nan implementation of Proteus will help us understand how this fact affects the program s ability to update \nitself over time. 4.4 Inference It is straightforward to construct a type inference algorithm for our \ncapability type system. In particular, we simply extend the def\u00adinition of capability . to include variables \n. and updateability \u00b5 to include variables e. Then we take a normal Proteus program and decorate it with \nfresh variables on each function de.nition, func\u00adtion type, and update expression in the program. We \nalso adjust the rules to use an algorithmic treatment of subtyping, eliminating the separate (A.Sub) \nrule and adding subtyping preconditions to the (A.App) and (A.Assign) rules as is standard. This allows \nthe judgment to be syntax-directed. As a result of these changes, conditions imposed on capability variables \nby the typing and subtyping rules become simple set and term constraints [11]. A solution consists of \na substitution s, which is a map from variables . to capabilities {t1,..., tn}, and from 3Note that we \ncould combine this with the con-free dynamic check as follows: let UN ' = UN restricted to those types \nin .. If UN ' is non-empty, and con-free check using UN ' succeeds, then the update is safe. variables \ne to updateabilities either U or N. The constraints can be solved ef.ciently with standard techniques \nin time O(n 3) in the worst case (but far better on average), where n is the number of variables . or \nset constants {\u00b7} mentioned in the constraints. The constraints have the following forms (shown with \nthe rules that in\u00ad duce them): (1) G f t1 <: t2 (A.Sub) (2) e = U (A.Update) (3) ( \u00b5 = U) . C (A.App), \n(A.Sub) (4) . . . (A.Update), (A.App) (5) t . . (A.Con) For updateabilities, we want the greatest solution; \nthat is, we want to allow as many functions as possible to perform updates (with an unannotated program, \nthis will vacuously be the case). For the capabilities, we are interested in the least solution, in which \nwe minimize the set to substitute for ., since it will permit more dy\u00adnamic updates. For update., a minimal \n. imposes fewer restric\u00adtions on the types that may be updated at that point. For functions e,.;. ' t \n-. t ' , the smaller . ' imposes fewer constraints on subtypes, which in turn permits more possible function \nreplacements. When using inference for later versions of a program, we must introduce subtyping constraints \nbetween an old de.nition s (solved) type and the new version s to-be-inferred one. This ensures that \nthe new de.nition will be a suitable dynamic replacement for the old one. Inferring update points. Using \nthe inference system, we can take a program that is absent of update expressions, and in\u00adfer places to \ninsert them that are con-free for all types. De.ne a source-to-source rewriting function rewrite : P \n. P ' that inserts update. at various locations throughout the program. Then we perform inference, and \nremove all occurrences of update. for which . is not \u00d8 (call these universal update points as they do \nnot restrict the types that may be updated). In the simplest case, the rewriting function could insert \nupdate. just before a function is about to return. Adding more points implies greater availability, but \nlonger analysis times and more runtime overhead. Intuitively, this approach will converge because the \nannotations . on update points are unaffected by those on other update points; rather they are only impacted \nby occurrences of con in their continuations. Preliminary Implementation. We are currently implement\u00ading \nProteus for C programs. We use CIL (C Intermediate Lan\u00adguage) [16] for C code parsing and source-to-source \ntransforma\u00adtion, and BANSHEE [14] for constraint solving. We have im\u00adplemented the updateability analysis \nto operate in three stages. First, it automatically inserts abst and cont coercions for uses of typedef, \nproduct (struct), sum(union) and enumeration (enum) types. Second, it considers update checks just before \neach return statement. Third, it performs capability inference, removing update checks within functions \nwith updateability N, and may remove updates that are not universal. C s weak type system and low level \nof abstraction create chal\u00adlenges not present in a higher-level language like ML or Java. For example, \nthe use of unsafe casts and/or the address-of (&#38;) oper\u00adator can reveal a type s representation through \nan alias. Say we have type struct S { int x; int y; }, and variable struct S *p. If we permit taking \nthe address of p s .rst .eld, &#38;(p->x) having type int *, then an update to struct S to change the \ntype of x to int * would lead to p->x and the alias ascribing different types to the same storage. To \nprevent this, for the time being we conservatively restrict struct S from being updated at all. Simi\u00adlarly, \nunsafe casts over function pointers conservatively force them to have updateability N, which can have \na ripple effect throughout the program, reducing the number of possible update points. We have run our \npreliminary analysis implementation on a num\u00adber of open-source server programs: vsftpd, apache, opensshd, \nand bind. This demonstrates the feasibility of our analysis. For example, running it on the 232Kloc bind \ncode takes 80 seconds.4 For vsftpd more than half of the types (9/16) and potential update points (returns) \nwere discovered to be updateable, with roughly half of the latter universal (325/700). For the other \nexamples fewer update points were found, re.ecting the conservatism of the current analysis. We are working \non addressing C s lower-level features which will be critical to making our implementation practical. \nAlso necessary is an investigation of what coding styles would increase updateability; the examples considered \nhere being written without update in mind. 4.5 Properties The two important properties of the updateability \nanalysis are soundness and predictability. As with the dynamic system, sound\u00adness is proved via preservation \nand progress lemmas. The former is stated as follows: Lemma 4.1 (Preservation). If f O; H, e : t then \n'' '' 1. If O; H, e . O; H ,e then f O; H ,e : t. upd '' '' 2. If O; H, e --. O ' ; H ,e then f O ' ; \nH ,e : t or else e ' = UpdEx. The proof of part (1) is mostly standard. However, the proof of part (2) \nis more challenging, and reduces to proving the following lemma, which states that valid updates preserve \ntyping: Lemma 4.2 (Program Update Safety). If f O; H, e : t and ; U[H]upd , U[e]upd updateOK(upd, O, \nH, .) then fU[H]O: t . A core element of this proof is that we must show that by chang\u00ading the named \ntypes listed in upd.UN we will not invalidate code in the existing program. We do this by proving the \nfollowing lemma: Lemma 4.3 (Update Capability Weakening). If .; G f\u00b5 E[update. '' ]: t ;. ' then . '' \n;G f\u00b5 E[update. '' ]: t;. ' . This states that for any expression that has update. '' as its re\u00addex, \nwe can typecheck that whole expression using capability . '' . In turn, this implies that the existing \nprogram could only use the types listed in . '' concretely, and therefore it should be safe to update \nthe other types in the program. Another important element of the Program Update Safety lemma is that \nthe insertion of type transformers will preserve type-safety. This must take into account that an inserted \ntransformer will not have an adverse effect on the capability. The following lemma states that as long \nas a given expression e will not perform an up\u00addate, it is always safe to increase its capability, and \nthus to insert it at an arbitrary program point: Lemma 4.4 (Capability strengthening). If .; G fN e : \nt;. ' . . '' then for all . '' we have . . . '' ;G fN e : t ;. ' . Proofs will appear in the extended \nversion [19]. 4We ran the analysis on a dual Xeon 2.8GHz with 2GB of RAM running Red Hat Enterprise Linux \nWS.   5. EXTENSION: BINDING DELETION While most changes we have observed in source programs are due \nto added or replaced de.nitions, occasionally de.nitions are deleted as well. It is also desirable to \nsupport removing de.nitions dynamically, for two reasons: 1. Dead bindings will unnecessarily consume \nvirtual memory, which could be problematic over time. 2. Dead functions could hamper dynamic updates, \nsince update well-formedness dictates that if some type t is updated, any function f that concretely \nmanipulates t must also be up\u00addated. Therefore, even if some function f has been removed from the program \nsources, a future update to t would neces\u00adsitate updating f. But how does one update a function that \nis no longer of use? This issue also arises with old type trans\u00adformer functions.  Removing dead code \nreduces to a garbage collection problem. The programmer can specify which bindings should be eligible \nfor dele\u00adtion at update-time, and then those bindings not reachable by the current program can be removed. \nBindings that are unreachable but not speci.ed as dead should be preserved, presumably because they still \nexist in the program source and might be used later. For\u00admally, we would modify updates upd to include \na set of external variable names DB to be deleted. The (UPDATE) operational rule could then be changed \nto include the precondition upd.DB . deadVar(H, E[update.]) ' H = delete(H, e, DB) ' updateOK(upd, O,H \n, .) Here, deadVar() traverses the current program to discover which bindings are unreachable, and if \nall those speci.ed in DB are un\u00adreachable, they are removed before the update proceeds (using H ' ). \nWe could also imagine marking bindings eligible for deletion, and removing them as they die. 6. RELATED \nWORK Dynamic software updating has been used in industry for many years and is well-studied in academia. \nTo our knowledge, ap\u00adproaches taken in industry are often application-speci.c, or rely on redundant hardware, \nlimiting their applicability. Academic ap\u00adproaches range from being quite .exible but type-unsafe, to \ntype\u00adsafe but quite in.exible. The systems of which we are aware are either less safe or less .exible \nthan our approach. Many systems are either not type safe at all [7, 13, 10, 4], or could admit dynamic \ntype errors [1]. Some sys\u00adtems are type-safe but not representation consistent [12, 6]. For ex\u00adample, \nHicks [12] ensures type-safety by copying and transforming values from their old representation to the \nnew; existing code will continue to use the old, stale values unless the programmer manu\u00adally ensures \notherwise. Other systems are too restrictive. For ex\u00adample, updates may only be permitted to individual \nclass instances whose type cannot change [17, 5, 13, 18], or else representation changes are only permitted \nfor abstract types or encapsulated ob\u00adjects [2, 18, 8]. In many cases, updates to active code are disal\u00adlowed \n[8, 15, 7, 10, 18], and data stored in local variables may not be transformed [12, 10, 7, 13]. A number \nof systems use techniques that bear some resemblance to our approach. Dynamic ML [8] supports updating \nmodules de.ning abstract types t. Since by de.nition clients of such a mod\u00adule must use values of type \nt abstractly, the module can be updated if none of its functions are on the call-stack (i.e. it is inactive). \nOur use of abst and cont coercions generalizes this idea to non\u00adabstract named types, and permits more \n.ne-grained determination of safe update points. In particular, we could discover points within an abstract \nmodule at which it could be safely updated. This allows our conFree[ - ]- check to be more precise than \nDynamic ML s activeness check. Dynamic ML has no static notion of proper update timing, as we do with \nour updatability analysis. Duggan [6] supports dynamic updates to named types, which use constructs fold \nand unfold to create and destruct values of named type (similar to our abst and cont). However, updated \nprograms are not representation-consistent. Rather, programmers must pro\u00advide transformer functions that \ngo both ways: from the old to the new representation and from the new version back to the old. Oc\u00adcurrences \nof unfold will dynamically compare the expected version of the t value with its actual version and apply \nsome composition of forward or backward transformers to convert the value. This ap\u00adproach ensures well-formed \nupdates are always well-timed. How\u00adever, programs are harder to reason about. We might wonder: will the \nprogram still behave properly when converting a t value for\u00adward for new code, backward for old code, \nand then forward again? Moreover, it may not always be possible to write backward trans\u00adformers, since \nupdated types often contain more information than their older versions (\u00a72). Boyapati et al. [2] and \nthe K42 operating system [18] ensure well-timed updates to objects. Both systems rely on object encap\u00adsulation \nto guarantee that no active code depends on an object s rep\u00adresentation when the object is updated. In \nBoyapati et al., proper timing is enforced by programmer-de.ned database-style transac\u00adtions: if an update \noccurs at an inopportune time, they abort the current transaction, perform the update, and then restart \nthe trans\u00adaction. In K42, an object to be updated is made quiescent by block\u00ading new threads from using \nit, and waiting until all current threads that could be using it have terminated. Our approach uses the \nmore general notion of con-freeness, rather than encapsulation. Transac\u00adtions are approximated by automatically-or \nprogrammer-inserted update points, but without the bene.t of rollback. To mimic this approach in our \nsetting, we could force update points to synchro\u00adnize in different threads; an update could proceed only \nwhen all threads have reached safe update points. We intend to .esh out this idea in future work. While \nour updateability analysis is new, its general formulation is similar to other capability type systems \n[21, 20, 9]. For example, capabilities in the Calculus of Capabilities [21] statically prevent a runtime \ndereference of a dangling pointer by approximating the runtime heap. Our capabilities prevent runtime \naccess to a value whose representation might have changed by approximating the current set of legal types. \n 7. CONCLUSIONS In this paper we have presented Proteus, a simple calculus for modeling type-safe dynamic \nupdates in C-like languages. To en\u00adsure that updates are type-safe in the presence of changes to named \ntypes, Proteus exploits the idea of con-t-freeness: a given update point is con-t-free if the program \nwill never use a value of type t concretely at its old representation from then on. We have shown that \ncon-freeness can be checked dynamically, and automatically inferred statically using our novel updateability \nanalysis. In the short term, we plan to implement Proteus in the context of single-threaded C, to explore \nits feasibility for existing non-stop services. Our next step will be to consider the addition of threads, \nand ultimately move to distributed programs, such as server farms operating concurrently on a shared \ndatabase whose schema must be evolved. We also plan to explore reasoning techniques for other useful \nproperties, such as update availability. Currently we can dis\u00adcover functions for which an update is \nnever possible; conversely, we wish to understand how often an update is possible for some function, \nwhich depends more on runtime behavior. In the longer term, we wish to adapt our techniques to functional \nand object\u00adoriented languages. On the one hand, these languages will be eas\u00adier to reason about due to \ntheir strong abstraction and encapsulation properties. On the other hand, advanced features such as closures \nand objects are more challenging to update. Acknowledgements. We thank Nikhil Swamy, Manuel Oriol, and \nthe anonymous referees for helpful comments on drafts of this paper. This work was supported by a Royal \nSociety University Re\u00adsearch Fellowship, a Marconi EPSRC CASE Studentship, EC FET-GC project IST-2001-33234 \nPEPITO, and NSF Contract #0346989. 8. REFERENCES [1] J. L. Armstrong and R. Virding. Erlang An Experimental \nTelephony Switching Language. In XIII International Switching Symposium, Stockholm, Sweden, May 27 June \n1, 1991. [2] C. Boyapati, B. Liskov, L. Shrira, C-H. Moh, and S. Richman. Lazy modular upgrades in persistent \nobject stores. In Proc. OOPSLA, 2003. [3] V. Breazu-Tannen, T. Coquand, C.A. Gunter, and A. Scedrov. \nInheritance as implicit coercion. Information and computation, 93(1):172 221, 1991. [4] B. Buck and J. \nK. Hollingsworth. An API for runtime code patching. Journal of High Performance Computing Applications, \n14(4):317 329, 2000. [5] S. Drossopoulou and S. Eisenbach. Flexible, source level dynamic linking and \nre-linking. In Proc. ECOOP 2003 Workshop on Formal Techniques for Java Programs, 2003. [6] D. Duggan. \nType-based hot swapping of running modules. In Proc. ICFP, 2001. [7] O. Frieder and M. E. Segal. On dynamically \nupdating a computer program: From concept to prototype. Journal of Systems and Software, 14(2):111 128, \nSeptember 1991. [8] S. Gilmore, D. Kirli, and C. Walton. Dynamic ML without dynamic types. Technical \nReport ECS-LFCS-97-378, LFCS, University of Edinburgh, December 1997. [9] D. Grossman, G. Morrisett, \nT. Jim, M. Hicks, Y. Wang, and J. Cheney. Region-based memory management in Cyclone. In Proc. PLDI, 2002. \n [10] D. Gupta. On-line Software Version Change. PhD thesis, Department of Computer Science and Engineering, \nIndian Institute of Technology, Kanpur, November 1994. [11] N. Heintze. Set-Based Program Analysis. \nPhD thesis, Department of Computer Science, Carnegie Mellon University, October 1992. [12] M. W. Hicks. \nDynamic Software Updating. PhD thesis, Department of Computer and Information Science, The University \nof Pennsylvania, August 2001. [13] G. Hj\u00b4almt\u00b4ysson and R. Gray. Dynamic C++ classes, a lightweight mechanism \nto update code in a running program. In Proc. USENIX, June 1998. [14] J. Kodumal. BANSHEE: A toolkit \nfor building constraint-based analyses. http://bane.cs.berkeley.edu/banshee. [15] S. Malabarba, R. Pandey, \nJ. Gragg, E. Barr, and J. F. Barnes. Runtime support for type-safe dynamic Java classes. In Proc. ECOOP, \n2000. [16] G. C. Necula, S. McPeak, S. P. Rahul, and W. Weimer. CIL: Intermediate language and tools \nfor analysis and transformation of C programs. Lecture Notes in Computer Science, 2304:213 228, 2002. \n [17] A. Orso, A. Rao, and M.J. Harrold. A technique for dynamic updating of Java software. In Proc. \nIEEE International Conference on Software Maintenance (ICSM), 2002. [18] C. Soules, J. Appavoo, K. Hui, \nR. W. Wisniewski, D. Da Silva, G. R. Ganger, O. Krieger, M. Stumm, M. Auslander, M. Ostrowski, B. Rosenburg, \nand J. Xenidis. System support for online recon.guration. In Proc. USENIX, June 2003. [19] G. Stoyle, \nM. Hicks, G. Bierman, P. Sewell, and I. Neamtiu. Mutatis Mutandis: Safe and predictable dynamic software \nupdating (extended version). To appear. [20] D. Walker. A type system for expressive security policies. \nIn Proc. POPL, pages 254 267, January 2000. [21] D. Walker, K. Crary, and G. Morrisett. Typed memory \nmanagement via static capabilities. ACM Transactions on Programming Languages and Systems, 22(4):701 \n771, 2000.  \n\t\t\t", "proc_id": "1040305", "abstract": "Dynamic software updates can be used to fix bugs or add features to a running program without downtime. Essential for some applications and convenient for others, low-level dynamic updating has been used for many years. Perhaps surprisingly, there is little high-level understanding or language support to help programmers write dynamic updates effectively.To bridge this gap, we present Proteus, a core calculus for dynamic software updating in C-like languages that is flexible, safe, and predictable. Proteus supports dynamic updates to functions (even active ones), to named types and to data, allowing on-line evolution to match source-code evolution as we have observed it in practice. We ensure updates are type-safe by checking for a property we call \"con-freeness\" for updated types t at the point of update. This means that non-updated code will not use t <i>concretely</i> beyond that point (concrete usages are via explicit coercions) and thus t's representation can safely change. We show how con-freeness can be enforced dynamically for a particular program state. We additionally define a novel and efficient static <i>updateability analysis</i> to establish con-freeness statically, and can thus automatically infer program points at which all future (well-formed) updates will be type-safe. We have implemented our analysis for C and tested it on several well-known programs.", "authors": [{"name": "Gareth Stoyle", "author_profile_id": "81100523612", "affiliation": "University of Cambridge, Cambridge, England", "person_id": "P639761", "email_address": "", "orcid_id": ""}, {"name": "Michael Hicks", "author_profile_id": "81100060959", "affiliation": "University of Maryland, College Park, Maryland", "person_id": "PP40023253", "email_address": "", "orcid_id": ""}, {"name": "Gavin Bierman", "author_profile_id": "81100249578", "affiliation": "Microsoft Research,Cambridge, England", "person_id": "PP39034558", "email_address": "", "orcid_id": ""}, {"name": "Peter Sewell", "author_profile_id": "81100511814", "affiliation": "University of Cambridge, Cambridge, England", "person_id": "PP14177906", "email_address": "", "orcid_id": ""}, {"name": "Iulian Neamtiu", "author_profile_id": "81100589658", "affiliation": "University of Maryland, College Park, Maryland", "person_id": "P707740", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1040305.1040321", "year": "2005", "article_id": "1040321", "conference": "POPL", "title": "Mutatis mutandis: safe and predictable dynamic software updating", "url": "http://dl.acm.org/citation.cfm?id=1040321"}