{"article_publication_date": "01-12-2005", "fulltext": "\n Associated Types with Class * Manuel M. T. Chakravarty Gabriele Keller Simon Peyton Jones Simon Marlow \nProgramming Languages and Compilers Microsoft Research Ltd. University of New South Wales, Australia \nCambridge, UK {chak,keller}@cse.unsw.edu.au {simonpj,simonmar}@microsoft.com ABSTRACT Haskell s type \nclasses allow ad-hoc overloading, or type\u00adindexing, of functions. A natural generalisation is to allow \ntype-indexing of data types as well. It turns out that this idea directly supports a powerful form of \nabstraction called associated types, which are available in C++ using traits classes. Associated types \nare useful in many applications, especially for self-optimising libraries that adapt their data representations \nand algorithms in a type-directed manner. In this paper, we introduce and motivate associated types as \na rather natural generalisation of Haskell s existing type classes. Formally, we present a type system \nthat includes a type-directed translation into an explicitly typed target language akin to System F; \nthe existence of this translation ensures that the addition of associated data types to an existing Haskell \ncompiler only requires changes to the front end. Categories and Subject Descriptors: D.3.3 Program\u00adming \nLanguages: Language Constructs and Features General Terms: Design, Languages, Theory Keywords: Type classes; \nType-indexed types; Associated types; Type-directed translation; Self-optimising libraries 1. INTRODUCTION \nIn a recent OOPSLA paper, Garcia et al. compare the support for generic programming o.ered by Haskell, \nML, C++, C#, and Java, using a graph-manipulation library as a motivating example [11]. They o.er a table \nof qualitative conclusions, in which Haskell is rated favourably in all re\u00adspects except one: access \nto so-called associated types.For example, we may want to represent arrays in a manner that depends on \nits element type. So, given an element type e, there is an associated type Array e of arrays of those \nele\u00adments. * The .rst two authors have been partly funded by the Aus\u00adtralian Research Council under grant \nnumber DP0211203. Permission to make digital or hard copies of all or part of this work for personal \nor classroom use is granted without fee provided that copies are not made or distributed for pro.t or \ncommercial advantage and that copies bear this notice and the full citation on the .rst page. To copy \notherwise, to republish, to post on servers or to redistribute to lists, requires prior speci.c permission \nand/or a fee. POPL 05, January 12 14, 2005, Long Beach, California, USA. Copyright 2005 ACM 1-58113-830-X/05/0001 \n...$5.00. Extending the syntax of Haskell data declarations, we might de.ne Array as follows: data Array \nInt = IntArray UIntArray data Array Bool = BoolArray BitVector data Array (a, b)= PairArray (Array a)(Array \nb) Here, we represent an array of integers as an unboxed array, an array of booleans as a bit vector, \nand an array of pairs as a pair of arrays. (We assume that UIntArr and BitVector are built-in types representing \nunboxed integer arrays and bit vectors respectively.) These specialised representations are more e.cient, \nin terms of both space and runtime of typical operations, than a type-invariant parametric representation. \nData types whose concrete representation depends on one or more type parameters are called type analysing \n[15] or type indexed [18]. In this paper, we shall demonstrate that type-indexed types can be understood \nas class-local data type declara\u00adtions, and that in fact this is a natural extension of Haskell s type \nclass overloading system. For example, the Array type above would be expressed as a local data type in \na type class of array elements, ArrayElem: class ArrayElem e where data Array e index :: Array e . Int \n. e  The keyword data in a class introduces an associated data type de.nition the type Array is associated \nwith the class ArrayElem. We can now de.ne instances of the ArrayElem class that give instantiations \nfor the Array type, assuming indexUIntArr is a pre-de.ned function indexing unboxed in\u00adteger arrays: \ninstance ArrayElem Int where data Array Int = IntArray UIntArr index (IntArray ar) i = indexUIntArr ar \ni instance (ArrayElem a, ArrayElem b) . ArrayElem (a, b) where data Array (a, b)= PairArray (Array a)(Array \nb) index (PairArray ar br) i =(index ar i, index br i) Together with the associated data type Array,we \nhave included a method index for indexing arrays. The full type of index is index :: ArrayElem e . Array \ne . Int . e This signature makes both the function s dependence on the class ArrayElem as well as on \nthe associated type Array ex\u00adplicit. In other words, for varying instantiations of the el\u00adement type \ne, the concrete array representation on which index operates varies in dependence on the equations de.n\u00ad \ning Array. This variation is more substantial than that of standard Haskell type classes, as the representation \ntype of Array may change in a non-parametric way for di.erent instantiations of the element type e.In \nother words, type\u00adindexed types permit an ad hoc overloading of types in the same way that standard type \nclasses provide ad hoc overload\u00ading of values. To summarise, we make the following contributions: We \nintroduce associated data type declarations as a mechanism to implement type-indexed types, and de\u00admonstrate \ntheir usefulness with a number of motivat\u00ading examples, notably self-optimising libraries (Sec\u00adtions \n2 and 3).  We show that associated data types are a natural ex\u00adtension of Haskell s overloading system. \nWe give typ\u00ading rules for the the new type system, and the evidence translation from source terms into \na target language akin to System F (Sections 3.3 and 4). As most of the novel aspects of the system are \ncon.ned to the Sys\u00adtem F translation, this enables a straightforward in\u00adtegration into existing Haskell \ncompilers, such as the Glasgow Haskell Compiler.  There is a great deal of related work on the subject \nof type\u00adindexed types, which we review in Section 6. Our approach has a particularly close relationship \nto functional dependen\u00adcies [22], which we review in Section 5.  2. MOTIVATION The previous array example \nis representative for a whole class of applications of associated types, namely self-optimis\u00ading libraries. \nThese are libraries that, depending on their use, optimise their implementation i.e., data representa\u00adtion \nand choice of algorithms along lines determined by the library author. The optimisation process is guided \nby type instantiation, as in the ArrayElem class where the el\u00adement type determines a suitable array \nrepresentation. We shall discuss another instance of a representation optimisa\u00adtion by considering generic \n.nite maps in Section 2.1. Then, in Section 2.2, we turn to the more sophisticated example of a generic \ngraph library, where both data representation and algorithms vary in dependence on type parameters. The \nkey feature of self-optimising libraries is that they do not merely rely on general compiler optimisations, \nbut instead the li\u00adbrary code itself contains precise instructions on how the library code is to be specialised \nfor particular applications. Since the introduction of templates, this style of libraries has been highly \nsuccessful in C++ with examples such as the Standard Template Library [35], the Boost Graph Li\u00adbrary \n[33], and the Matrix Template Library [34]. Work on generic programming in Haskell, also illustrates \nthe need for type-dependent data representations [18, 17, 2]. In addition to implementing self-optimising \nlibraries, asso\u00adciated types are also useful for abstract interfaces and other applications of functional \ndependencies. We shall discuss abstract interfaces in Subsection 2.3. 2.1 Self-optimising .nite maps \nA nice example of a data structure whose representation changes in dependence of a type parameter, which \nwas .rst discussed by Hinze [16] and subsequently used as an exam\u00adple for type-indexed types by Hinze, \nJeuring, and L\u00a8oh [18] in the context of Generic Haskell, are generalised tries or generic .nite maps. \nSuch maps change their representation in dependence on the structure of the key type k used to in\u00addex \nthe map. We express this idea by de.ning a type class MapKey, parameterised by the key type, with an \nassociated type Map as one of its components: class MapKey k where data Map k v empty :: Map k v lookup \n:: k . Map k v . v  (Wegiveonly two class operations, empty and lookup, but in reality there would be \nmany.) In addition to the key type, .nite maps are parametrised by a value type that forms the co-domain \nof the map. While the representation of generic .nite maps depends on the type k of keys, it is parametric \nin the value type v. We express the di.erent status of the key type k and value type v by only making \nk aclass param\u00adeter; although the associated representation type Map k v depends on both types. Assuming \na suitable library im\u00adplementing .nite maps with integer trees, such as Patricia trees [31], we may provide \nan instance of MapKey for integer keys as follows: instance MapKey Int where data Map Int v = MI (Patricia.Dict \nv) empty = MI Patricia.emptyDict lookup k (MI d)= Patricia.lookupDict k d  In this instance, the di.erent \ntreatment of the key and value types is obvious in that we .x the key type for an instance, while still \nleaving the value type open. In other words, we can regard Map k as a type-indexed type constructor of \nkind . . . As described in detail by Hinze [16], we can de.ne generic .nite maps on arbitrary algebraic \ndata types by simply giv\u00ading instances for MapKey for unit, product, and sum types. We do so as follows \nfor a detailed motivation of this de.\u00adnition, please see Hinze s work: instance MapKey () where data \nMap () v = MU (Maybe v) empty = MU Nothing lookup Unit (MU Nothing)= error unknown key lookup Unit (MU \n(Just v)) = v instance (MapKey a, MapKey b) . MapKey (a, b) where data Map (a, b) v = MP (Map a (Map \nb v)) empty = MP empty lookup (a, b)(MP fm)= lookup b (lookup a fm) instance (MapKey a, MapKey b) . MapKey \n(Either a b) where data Map (Either a b) v = ME (Map a v)(Map b v) empty = ME Nothing Nothing lookup \n(Left a)(ME fm1 fm2) = lookup a fm1 lookup (Right b)(ME fm1 fm2) = lookup b fm2 To use the class MapKey \non any speci.c algebraic data type, we need to map it to its product/sum representation by means of an \nembedding-projection pair [19, 18, 2]. 2.2 Generic graphs The concept of traits has been introduced \nto C++ with the aim of reducing the number of parameters to templa\u00adtes [27]. Since then, generic programming \nbased on tem\u00adplates with traits has been found to be useful for self-opti\u00admising libraries [33] where \nthe choice of data representation as well as algorithms is guided by way of type instantiation. This \nhas led to an investigation of the support for this style of generic programming in a range of di.erent \nlan\u00adguages by Garcia et al. [11]. The evaluation of Garcia et al., based on a comparative implementation \nof a graph library, concluded that Haskell has excellent support for generic pro\u00adgramming with the exception \nof satisfactory support for as\u00adsociated types. The extension proposed in this paper tackles this shortcoming \nhead-on. Inspired by Garcia et al., we also use a class of graphs as an example. class Graph g where \ndata Edge g data Vertex g src :: Edge g .g .Vertex g tgt :: Edge g .g .Vertex g outEdges :: Vertex g \n.g .[Edge g] In contrast to the ArrayElem and MapKey examples, in which the container type depended \non the element type, here the vertex and edge type depend on the container type. This allows us to de.ne \nseveral distinct instances of graphs which all have the same edge and vertex types, but di.er in the \nrepresentation and algorithms working on the data structure. Here are two possible instances which both \nmodel vertexes as integers, and edges as pairs of source and target vertex, but still are represented \ndi.erently: --adjacency matrix newtype G1 = G1 [[Vertex G1]] instance Graph G1 where data Vertex G1 \n= GV1 Int data Edge G1 = GE1 (Vertex G1)(Vertex G1) --maps vertexes to neighbours newtype G2 = G2 (FiniteMap \n(Vertex G2)(Vertex G2)) instance Graph G2 where data Vertex G2 = GV2 Int data Edge G2 = GE2 (Vertex G2)(Vertex \nG2) Apart from added .exibility, associated types lead to two distinct advantages: .rst, as with traits, \nwe reduce the num\u00adber of parameters to the class; second, in contrast to class parameters, we refer to \nthe associated types by their names, not just the position in the argument list, which further im\u00adproves \nreadability and reduces the potential for confusing the order of arguments.  2.3 Interface abstraction \nAll previous examples used associated types for self-op\u00adtimising libraries specialising data representations \nand al\u00adgorithms in a type-directed manner. An entirely di.erent application is that of de.ning abstract \ninterfaces, not unlike abstract base classes in C++, interfaces in Java, or signa\u00adtures in Standard ML. \nA well-known example of such an interface, motivated by Haskell s hierarchical standard library, is that \nof a monad based on a state transformer that supports mutable refer\u00adences. We can base this interface \non a parametrised family of types as follows: class Monad m .RefM m where data Ref mv newRef :: v .m \n(Ref mv) readRef :: Ref mv .mv writeRef :: Ref mv .v .m () instance RefM IO where data Ref IOv = RefIO \n(IORef v) newRef = liftM RefIO .newIORef ... instance RefM (ST s) where data Ref (ST s) v = RefST (STRef \ns v) newRef = liftM RefST .newSTRef ... Note how here both the type parameter m of the associ\u00adated \ntype Ref as well the representation type Ref m are of higher kind that is, they are of kind . ..The complete \nsignature of newRef is newRef :: RefM m .v .m (Ref mv) A subtlety of the above code is that the de.nition \nof Ref IOv introduces a new type that by Haskell s type equality is not compatible with IORef v. However, \nsometimes we might like to use an existing type as an associated type instead of introducing a new type. \nThis requires associated type syn\u00adonyms, which we plan to discuss in a future paper.  3. ASSOCIATED \nDATA TYPES IN DETAIL In this section, we describe the proposed language exten\u00adsion in enough detail for \na user of the language. Technical details of the type system are deferred until Section 4. We propose \nthat a type class may de.ne, in addition to a set of methods, a set of associated data types. In the \nclass declaration, the data types are declared without any de.nitions; the de.nitions will be given by \nthe instance dec\u00adlarations. The associated data type must be parameterised over all the type variables \nof the class, and these type vari\u00adables must come .rst, and be in the same order as the class type variables. \nRationale for this restriction is given in Sec\u00adtion 4.4. Each associated data type introduces a new type \nconstruc\u00adtor. The kind of the type constructor is inferred in the obvi\u00adous way; we also allow explicit \nkind signatures on the type parameters: class Ca where data Ta (b :: *.*) Instance declarations must \ngive a single de.nition for each associated data type of the class; such a de.nition must repeat the \nclass parameters of the instance; any additional parameters of thedatatypemustbeleft as type variables. \nThe following is a legal instance of the C class above: instance Ca .C [a] where data T [a] b = D [Tab](ba) \nAn instance declaration with associated data types intro\u00adduces new data constructors with top-level scope. \nIn the above example, the data constructor D is introduced with the following type: D :: Ca .[Tab] .(ba) \n.T [a] b The instance of an associated data type may use a newtype declaration instead of a data declaration \nif there is only a single constructor with a single .eld. This enables the compiler to represent the \ndatatype without the intervening constructor at runtime. 3.1 Types involving associated data types The \ntype constructor introduced by an associated data type declaration can be thought of as a type-indexed \ntype. Its representation is dependent on the instantiation of its pa\u00adrameters, and we use Haskell s existing \noverloading machin\u00adery to resolve these types. There is a close analogy between methods of a class and \nassociated data types: methods intro\u00adduce overloaded, or type-indexed, variables, while associated data \ntype declarations introduce type-indexed types. Just as an expression that refers to overloaded identi.ers \nrequires instances to be available or a context to be supplied, the same is now true of types. Going \nback to the Array example from the introduction, consider f :: Array Bool . Bool Our system declares \nthis to be a valid type signature only if there is an instance for ArrayElem Bool. Similarly, f :: Array \ne . e is invalid, because the representation for Array e is unknown. To make the type valid, we have \nto supply a context: f :: ArrayElem e . Array e . e This validity check for programmer-supplied type \nannota\u00adtions is conveniently performed as part of the kind-checking of these annotations. There is one \nfurther restriction on the use of an associated type constructor: wherever the type constructor appears, \nit must be applied to at least as many type arguments as there are class parameters. This is not so surprising \nwhen stated in a di.erent way: a type-indexed type must always be applied to all of its index parameters. \n 3.2 Associated types in data declarations For consistency, the system must support using associated \ntypes everywhere, including within the de.nition of another data type. However, doing this has some interesting \nconse\u00adquences. Consider again the Array example, and suppose we wish to de.ne a new data type T : data \nTe = C (Array e) As just discussed, the type Array e is not a valid type for all e, so we must add a \ncontext to the declaration of T : data ArrayElem e . Te = C (Array e) Haskell 98 already supports contexts \non data declarations, whose e.ect is to add a context to the type of the data constructor, which makes \nit satisfy our validity principle: C :: ArrayElem e . Array e . Te Now, the type constructor T is no \nordinary type construc\u00adtor: it behaves in a similar way to an associated type, in that whenever Te appears \nin a type there must be an appropri\u00adate context or instances in order to deduce ArrayElem e. Furthermore, \nT must always be applied to all of its type\u00adindexed arguments. Just as a top-level function that calls \noverloaded functions itself becomes overloaded, so a data type that mentions type-indexed types itself \nbecomes type indexed. We call such type-indexed data types associated top-level types.  3.3 Translation \nexample An important feature of our system is that we can explain it by translation into an explicitly \ntyped target language akin to System F. To give the idea, we now walk through the translation for the \nMapKey example in Section 2. Recall the class declaration for the MapKey class: class MapKey k where \ndata Map k v empty :: Map k v lookup :: k . Map k v . Maybe v  Its translation is a new data type, CMapKey,which \nis the type of dictionaries of the MapKey class: data CMapKey k mk = CMapKey { empty :: forall v. mk \nv, lookup :: forall v. k . mk v . Maybe v } The CMapKey type has a type parameter for each class type \nvariable as usual, in this case the single type variable k. However, it now also has an extra type parameter \nmk representing the associated type Map k. This isaseach in\u00adstance of the class will give a di.erent \ninstantiation for the type Map k, so the dictionary must abstract over this type. Note that mk has kind \n. . ;the type variable v is still unconstrained as it is not one of the class type variables. In\u00addeed, \nthe class methods empty and lookup are now explicitly parametric polymorphic in this type variable. Our \n.rst instance is the instance for integer keys: instance MapKey Int where data Map Int v = MI (Patricia.Dict \nv) empty = MI Patricia.emptyDict lookup k (MI d)= Patricia.lookupDict k d  Its translation is a new \ndatatype for the associated type and a dictionary value: data MapInt v = MI (Patricia.Dict v) dMapInt \n:: CMapKey Int MapInt dMapInt = CMapKey { empty = MI Patricia.emptyDict, lookup k (MI d)= Patricia.lookupDict \nk d } Next we consider the instance for pairs: instance (MapKey a, MapKey b) . MapKey (a, b) where data \nMap (a, b) v = MP (Map a (Map b v)) empty = MP empty lookup (a, b)(MP m)= lookup b (lookupam) Its translation \nis a new datatype and a dictionary function: data MapPair ma mb v = MP (ma (mb v)) dMapPair :: forall \nab. CMapKey a ma . CMapKey b mb . CMapKey (a, b)(MapPair ma mb)  dMapPair da db = CMapKey { empty = \nMP (empty da), lookup (a, b)(MP m)= (lookup db) b ((lookup da) am) } The new datatype MapPair takes \ntwo additional type ar\u00adguments, ma and mb,representing the types Map a and Map b respectively. Because \nthis instance has a context, the translation is a dictionary function, taking dictionaries for MapKey \na and MapKey b as arguments before delivering a dictionary value. The translation for the Either instance \ndoesn t illustrate anything new, so it is omitted. Instead, we give a translation for an example function \nmaking use of the overloaded lookup function: f :: MapKey a . Map (a, Int) v . a . v fmx = lookup (x, \n42) m The translation looks like this: f :: forall av mk. CMapKey a mk . MapPair mk MapInt v . a . v \nfdamx = lookup (dMapPair da dMapInt)(x, 42) m Note that in translating the type Map (a, Int) v,the in\u00adstances \nfor MapKey (a, b)and MapKey Int must be con\u00adsulted, just as they must be consulted to infer that MapKey \n(a, Int) depends on MapKey a and to construct the dictio\u00adnary for MapKey (a, Int) in the value translation. \n 3.4 Default de.nitions In Haskell, a class method can be given a default de.nition in the declaration \nof the class, and any instance that omits a speci.c de.nition for that method will inherit the default. \nUnfortunately, we cannot provide a similar facility for as\u00adsociated data types. To see why, consider \nthe ArrayElem example from the introduction, and let s add a hypothetical default de.nition for the Array \nassociated type: class ArrayElem e where data Array e = DefaultArray (BoxedArray e) index :: Array e \n. Int . e Now, what type should the DefaultArray constructor have? Presumably, it should be given the \ntype DefaultArray :: ArrayElem e . BoxedArray e . Array e But it cannot have this type. This constructor \nis not valid for those instances of ArrayElem which give their own spe\u00adci.c de.nitions of the Array type. \nThere is no correct type that we can give to a constructor of a default de.nition.  4. TYPE SYSTEM AND \nTRANSLATION In this section, we formalise a type system for a lambda calculus including type classes \nwith associated data types. We then extend the typing rules to include a translation of source programs \ninto an explicitly typed target language akin to the predicative fragment of System F. The type sys\u00adtem \nis based on Jones Overloaded ML (OML) [20, 21]. In fact, associated data types do not change the typing \nrules in any fundamental way; however, they require a substantial extension to the dictionary translation \nof type classes. 4.1 Syntax The syntax of the source language is given in Figure 1. We use overbar notation \nextensively. The notation an means the sequence a1 \u00b7\u00b7\u00b7an;the n may be omitted when it is unimportant. \nMoreover, we use comma to mean sequence nn+1 extension as follows: a ,an+1 \" a . Although we give the \nsyntax of quali.ed and quanti.ed types in a curried way, we also sometimes use equivalent overbar notation, \nthus: pn .t = p1 .\u00b7\u00b7\u00b7.pn .t tn .. = t1 .\u00b7\u00b7\u00b7.tn .. .an.. =.a1 \u00b7\u00b7\u00b7.an..  We accommodate function types \nt1 .t2 by regarding them as the curried application of the function type constructor to two arguments, \nthus (.) t1 t2. The source language has three unusual features. First, class declarations may contain \ndata type signatures in ad\u00addition to method signatures and correspondingly instance declarations may \ncontain data type declarations in addition to method implementations. These data types are the as\u00adsociated \ntypes of the class, and are syntactically separated Symbol Classes a, \u00df, . .(type variable) T .(type \nconstructor) D .(type class) S .(associated type) C .(data constructor) x, f, d .(term variable) Source \ndeclarations pgm .data; cls; inst; val (whole program) data .data Ta = Ct (data type decl) | data Da \n.Sa\u00df = Ct (assoc. type decl) cls .class Da where (class decl) dsig; vsig inst .instance . where (instance \ndecl) adata; val val .x = e (value binding) dsig .data Sa\u00df (assoc. type sig) vsig .x :: s (class method \nsig) adata .data St\u00df = (assoc. data type) Source terms e .v |e1 e2 |.x.e (term) | let x = e1 in e2 |e \n:: s v .x |C (identi.er) Source types t, . .T |a |t1 t2 |. (monotypes) . .t |p .. (quali.ed type) s .. \n|.a.s (type scheme) . .St (associated-type app.) Constraints p .Da |D (at1 \u00b7\u00b7\u00b7tn)(simple constraint) \nf .Dt |p .f (quali.ed constraint) . .f |.a.. (constraint scheme) Environments G .v :s (type environment) \nT .. (instance environment)  Figure 1: Syntax of expressions and types with type constructors ranged \nover by S rather than T .Sec\u00adond, we syntactically distinguish two forms of top-level data type declaration: \nordinary ones T ; and top-level associated types S, that mention associated types in their right-hand \nside (see Section 3.2). In the declaration of associated types, whether in a class declaration or a top-level \ndata declara\u00adtion, the type indexes must come .rst. Third, the syntax of types t includes ., the saturated \napplication of an associ\u00adated type to all its type indexes. (There can be further type arguments by way \nof the t1 t2 production.) We make the following simplifying assumptions to reduce the notational burden: \n Each class has exactly one type parameter, one method, and one associated type.  Each top-level associated \ntype has exactly one type\u00adindex parameter.  Each data type has a single constructor. Furthermore, rather \nthan treat case expressions we assume that each constructor C comes with a projection function prjCi \nthat selects the i th argument of the constructor C.  We do not treat superclasses.  Target declarations \ntd . (x:.)= w | data Ta = C. Target terms w . v |w1 w2 |.(x:.).w |.a.w |w. | let x:. = w1 in w2 Target \ntypes . . T |a |.1 .2 |.a.. Environments . . d:. (dictionary environment) . . . (associated-type environment) \n. ..a.(. . Tt) | . . a Figure 3: Syntax for target terms and types Loosening these restrictions is largely \na matter of adding (a great many) overbars to the typing rules. Introducing superclasses is slightly \nless trivial, as Section 4.5 discusses.  4.2 Type checking A key feature of our system is that the typing \nrules for expressions are very close to those of Haskell 98. We present them in Figure 2. The judgement \nT |G e : s means that, in type environment G and instance environment T, the ex\u00adpression e has type s. \nAll the rules are absolutely standard for a Damas-Milner type system except (.I )and (.E). The former \nallows us to abstract over a constraint, while the latter allows us to discharge a constraint provided \nit is entailed by the environment. The latter judgement, T p is also given in Figure 2, and is also \nentirely standard [21]. The auxiliary judgement T s, which is used in rules (.I ) and (.E), is the kind-checking \njudgement, used when the system guesses a type to ensure that the type is well\u00adkinded. In the interests \nof brevity, however, the rules of Figure 2 elide all mention of kinds, leaving only the well\u00adformedness \ncheck that is distinctive to our system. Speci.\u00adcally, in a well-formed type, every associated type St \nmust be in a context that satis.es the classes D to which S is associated there can be more than one \nin the case of as\u00adsociated top-level data types. It is this side condition that rejects (c.f., Section \n3.1), for example, the typing T |G .x.x : .a.Array a .Int This typing is invalid because the associated \ntype Array a is meaningless without a corresponding ArrayElem a con\u00adstraint. This is as Array is simply \nnot de.ned on all types of kind , but only on the subset for which there is a ArrayElem instance. Thisisakinto \na simple form of re.nement kinds [9]. The rules for class and instance declarations are not quite so \nstandard, because of the possibility of one or more type declarations in the class. We omit the details \nbecause they form part of the more elaborate rules we give next. However, the reason that the type well-formedness \njudgement T . s is speci.ed to work for type schemes (rather than just monotypes) is because it is needed \nto check the validity of the types of class methods.  4.3 Evidence translation A second crucial feature \nof our system is that, like Haskell 98 [10], it can be translated into System F (augmented with data \ntypes) without adding any associated-type extensions to the target language. We gave an example of this \ntransla\u00adtion in Section 3.3. Now we formalise the translation. 4.3.1 Evidence translation for terms \nThe main judgement . |. |G e . w : s means that in environment . | . | G the source term e has type \ns, and translates to the target term w (Figure 5). The rules for this judgement are given in Figure 5; \nfor the most part they are a well-known elaboration of the rules in Figure 2 [12]. The target term w \nis explicitly-typed in the style of Sys\u00adtem F, and its syntax is given in Figure 3. The main typing judgement \nderives a source type s, whereas the target term is decorated with target types. The programmer only \nsees source types s, which include quali.ed types and applica\u00adtions of associated types. In contrast, \na target type . men\u00adtions only data types: no quali.ed types and no associated types appear. The instance \nenvironment T from the plain type-checking rules has split into two components, . and . (see Fig\u00adure \n3). The dictionary environment . associates a dictio\u00adnary (or dictionary-producing function) d with each \ncon\u00adstraint scheme ., but it otherwise contains the same infor\u00admation as the old T. The well-formedness \njudgement T s from Figure 2, used in rules (.I )and (.E), becomes a type\u00adtranslation judgement . . s \n. ., that translates source types to target types. This type translation is driven by the associated-type \nenvironment .. We discuss type translation further in Section 4.3.2. Returning to the rules for terms, \nthe interesting cases are rules (.I )and (.E), which must deal with the associated types. In rule (.I \n), we abstract over the type variable that stands for p s associated type (i.e., only the one directly \nas\u00adsociated with the class mentioned in p; associated top-level types need not be abstracted). Moreover, \nwe need to extend the dictionary environment . to re.ect the constraint that is now satis.ed by the environment \nincluding its witness d; hence, we augment the type-translation environment . to explain how p s associated \ntype (called .) may be rewritten. Dually, rule (.E) applies the target term w1 to the wit\u00adness type . \nas well as the witness term w2.The witness types are derived by the judgement . p . ., while the witness \nterms are derived by . |. p . w, both given in Figure 4. 4.3.2 Translating types The translation of \nsource types to target types is for\u00admalised by the judgement . . s . . of Figure 4, which eliminates \napplications of associated types by consulting the associated-type environment .. This judgement relates \nto the well-formedness judgement T s of Figure 2 in just the same way that the typing judgement . |. \n|G e . w : s relates to T |G e : s. To motivate the rules, here are some type translations copied from \nSection 3.3: . Map Int . MapInt . .a..(MapKey a) .Map (a, Int) . .a .. . .a\u00df..CMapKey a \u00df .MapPair \u00df \nMapInt . .a ..  . .TT .a.. T p .f T p (mono)(spec)(mp) T .T [t/a].T f T Dt S is an associated type \nof D T sa .Fv(T) T,p . T t1 T t2 T St T .a.s T p .. T t1 t2 T a T T (v : s) .GT |G e1 : s1 T |G[x : \ns1] e2 : s2 (var)(let) T |G v : sT |G let x = e1 in e2 : s2 T |G[x:t1] e2 : t2 T t1 T |G e1 : t2 .t1 \nT |G e2 : t2 (.I)(.E) T |G .x.e2 : t1 .t2 T |G e1 e2 : t1 T,p |G e : . T |G e : p .. T p (.I)(.E) T \n|G e : p ..T |G e : . T |G e : s a .Fv(T) .Fv(G) T |G e : .a.s T t T | G e : s (.I) (.E) (sig) T |G e \n: .a.s T | G e :[t/a]s T | G (e :: s): s Figure 2: Standard type checking rules for expressions (.a.(. \n. T t)) .. . [t /a]t . . (. . a) .. (tr.1) (tr.2) . [t /a]. . T . . . . a . a . a . T . T . t1 . .1 \n. t2 . .2 . s . . a .Fv(.) . p . (. . a),.d .[. . a] . . . . t1 t2 . .1 .2 (tr.) . .a.s . .a.. . p .. \n. .a..d .. (trp)  S = the associated type of D . St . . S = the associated type of D a fresh . t . . \n(pE) (pI ) . Dt . . . Dt . (St . a), (D. a) (d : .) ... |. .a.. . w . t . . . |. p .f . w1 . |. p . \nw2 . p . . (mono)(spec)(mp) . |. . . d. |. [t/a]. . w. . |. f . w1 .w2 Figure 4: Translating types The \n.rst example is straightforward, because it arises di\u00adrectly from the instance declaration for MapKey \nInt.There is more going on in the second example. The class constraint is translated to an ordinary function, \nwith argument type CMapKey a\u00df,where the data type CMapKey is thetypeof dictionaries for class MapKey, \nand is generated by translat\u00ading the class declaration. The crucial point is that this data type takes \nan extra type parameter \u00df for each associated type of the class, here just one. Correspondingly, we must \nquantify over the new type \u00df as well. The type Map (a, Int) is .rst translated to MapPair (Map a)(Map \nInt), by apply\u00ading the translation scheme added to . when translating the instance declaration for pairs. \nThen, (Map Int)is translated to MapInt as before, while Map a is precisely the associated type for the \nclass MapKey a, and so is translated to \u00df. The associated-type environment therefore contains two kinds \nof assumptions, . (Figure 3). First, from an instance declaration we get an assumption of the form .a.S \n. . Tt, (v : s) . G. | . | G e1 . w1 : s1 . | . | G[x : s1] e2 . w2 : s2 . s1 . . (var)(let) . | . | \nG v . v : s . | . | G(let x = e1 in e2) . (let x:. = w1 in w2): s2 . | . | G[x:t1] e . w : t2 . t1 . \n.1 . | . | G e1 . w1 : t2 . t1 . | . | G e2 . w2 : t2 (.I)(.E) . | . | G(.x.e) . (.x:.1.w): t1 . t2 . \n| . | G(e1 e2) . (w1 w2): t1 . p . (. . a),. .[. . a] | .[d:p] | G e . w : . . | . | G e . w1 : p . . \n. | . p . w2 . p . . (.I)(.E) . | . | G e . (.a..(d:.).w): p . . . | . | G e . w1 .w2 : . . | . | G e \n. w : sa . Fv(.) . Fv(G) . | . | G e . w : .a.s . t . . . | . | G e . w : s (.I)(.E)(sig) . | . | G e \n. (.a.w): .a.s . | . | G e . w. :[t/a]s . | . | G(e :: s) . w : s Figure 5: Typing rules with translation \nwhere S is an associated data type and T is the correspond\u00ading target data type. For example, consider \nthe instances of class MapKey in Section 3.3. The instances for Int and pairs augment . with the assumptions: \nMap Int . MapInt . a1a2.Map (a1,a2) . MapPair (Map a1)(Map a2) We will see the details of how . is extended \nin this way when we discuss the rule for instance declarations in the next section. Second, when in the \nmidst of translating a type,we extend . with localassumptionsof form St . \u00df which is denoted as . . \u00df \nin rule (trp) of Figure 4 and also (.I ) of Figure 5. For example, when moving inside the MapKey a . \nquali.er in the example above, we add the assumption Map a . \u00df to .. Whenever we need to extend . with \nlocal assumptions of form St . a, we use a judgement of the form . . p . (. . a),. (from Figure 4). Such \na judgement ab\u00adstracts over the associated type of p by introducing a new type variable a that represents \nthe associated type. It also provides the application of the associated type at the class instance p,as \n., and the corresponding dictionary type, as ..  4.3.3 Data type and value declarations The rules for \ntype-directed translation of declarations are given in Figure 6. They are somewhat complex, but that \nis largely because of the notational overheads, and much of the complexity is also present in vanilla \nHaskell 98. There is real work to be done, however, and that is the whole point. The programmer sees \nHaskell s type system more or less unchanged, but the implementation has to do a good deal of paddling \nunder the water to implement the associated types. The translation of vanilla data type declarations \nis easy: all we need to do is translate the constructor argument types, using our auxiliary type-translation \njudgement . . t . .. The handling of associated top-level data types is more involved, but their treatment \nclosely mirrors that of associated types in instance declarations, which we discuss below. Value declarations \nare also straightforward, because all of the work is done in Figures 4 and 5.  4.3.4 Class declarations \nThe interesting cases are class and instance declarations. It may help to refer back to the example of \nSection 3.3 when reading these rules. As noted there, a class declaration for class D is translated to \na data type declaration, also named D, whose data constructor is called CD. This data type will be used \nto represent the dictionary for class D, so the con\u00adstructor has the class method s signature s as its \nargument type, suitably translated of course. The translation uses an associated-type environment . that \nmaps each associated type to a fresh type variable \u00df. The data type must be parameterised over these \nfresh \u00df, because they will presum\u00adably be free in the translated method types .. Finally, we must generate \na binding for the method selector function for the class method f; in the rule, this is implemented by \nthe corresponding projection functions prjCD . In addition to the target declarations de.ning the data \ntype for the dic\u00adtionary and the method selector functions, the Rule (cls) produces an environment G \ngiving the source types of the class methods. We impose the same restriction on method types that Haskell \n98 does, namely that constraints in the method type s must not constrain the class parameter a. Lifting \nthis re\u00adstriction would permit classes like this one: class Da where op :: Ca . a . Ta where the constraint \nCa constrains only the class variable a. In the functional-dependency setting, classes like these are \nknown to be tricky, and the situation is the same for us. In this paper we simply exclude the possibility. \n 4.3.5 Instance declarations Instance declarations are more involved. For each associ\u00adated type S of \nthe class, we must generate a fresh data type declaration T that implements the associated type at the \ninstance type. This data type must be parameterised over (a) the quanti.ed type variables of the instance \ndeclaration itself, a, (b) a type variable for each associated type of each constraint in the instance \ndeclaration, \u00df, and (c) the type variables in which the associated type is parametric in all instances, \n.. Here is an arti.cial example to demonstrate the possibilities: class MK k where data Mkv instance \n(MK a, MK b) . MK (a,b) where data M (a,b) v = MP v a (Mb) b The data type that arises from the instance \ndeclaration is Figure 6: Declaration typing rules with translation the following: data M abmambv = MP \nv a mb b The arguments ma and mb were the \u00df in (b) above. They may not all be needed, as we see in this \nexample. As an optimisation, if any are unused in the (translated) right hand side of the declaration, \nthey can be omitted from the type-parameter list. To produce the right-hand sides .c from the tc of an \ninstance s associated type declarations, we need to replace applications of other associated types by \nthe newly introduced type parameters. This is achieved by theassociated-typeenvironment . in the hypothesis. \nIn addition to promoting the associated data type S to become a fresh top-level data type declaration \nT ,rule(inst) also returns in its conclusion (a) a tiny associated-type envi\u00adronment and dictionary environment \nthat embody the infor\u00admation about the instance declaration for use in the rest of the program, and (b) \na tiny type environment that embodies the types of the new data constructor, C. That concludes the hard \npart of instance declarations. The generation of the dictionary function, df ,and the ex\u00adtension of the \ndictionary environment ., is exactly as in vanilla Haskell. 4.3.6 Tying the knot The .nal judgement \nin Figure 6 glues together the judge\u00adments for types, classes, instances, and value declarations. This \nrule is highly recursive: the associated-type environ\u00adment . that is produced by type checking instance \ndeclara\u00adtions, is consumed by that same judgement and the other three judgements too. Similarly, all \nfour judgements pro\u00adduce a fragment of the environment G, which is consumed by the judgements for instance \nand value declarations. There is a good reason for this recursion. For example, consider the data type \nG1 from Section 2.2. Its constructor mentions the type Vertex G1, and the translation for that type comes \nfrom the instance declaration! In practice, the implementation must unravel the recur\u00adsion somewhat, \nand our new extension makes this slightly harder than before. For example, in Haskell 98 one can type-check \nthe instance declaration heads (the part before the where), to generate the top level ., then check the \nvalue declarations to generate G, and then take a second run at the instance declarations, this time \nchecking the method bodies. But now the instance declarations for one class may be needed to type-check \nthe class declaration for another class, if the associated types for the former appear in the method \ntype signatures for the latter. None of this is rocket science, but it is an unwelcome complication. \n  4.4 Associated type parameters In Section 3, we speci.ed that the type parameters of the associated \ntype should be identical to those of its parent class, plus some optional extra parameters ..Now we can \nsee why. The class parameters must occur .rst so that we can insist that associated-type applications \nare saturated (w.r.t. the class parameters). That in turn ensures that the type translation described \nby . can proceed without concern for partial applications and without clutter arising from the extra \n.. We could in principle permit an associated type to per\u00admute its parent class parameters (where there \nis more than one), at the cost of extra notational bureaucracy in the (inst) rule, but there seems to \nbe no bene.t in doing to. We could also in principle allow an associated type to mention only a subset \nof its parent class parameters; but then we would need to make extra tests to ensure that the instance \ndeclarations did not overlap taking into account only the selected class parameters, to ensure that the \ntype translation described by . is con.uent. (A similar test must be made when func\u00adtional dependencies \nare employed.) Again, the bene.t does not seem to justify the cost. 4.5 Superclasses Our formalisation \nof the type system and evidence trans\u00adlation does not take superclasses into account; i.e., there is \nno context in the head of a class declaration. We made this simpli.cation in the interest of the clarity \nof the for\u00admal rules. Nevertheless, there is a subtlety with respect to the translation of associated \ntypes of classes with super\u00adclasses. In rule (cls)of Figure6, wesee that thegener\u00adated dictionary data \ntype D has a type argument \u00df,which corresponds to the associated type of the class (in general, there \ncan be multiple associated types, and hence, multiple such type arguments). If the class D has superclasses \nwhich themselves contain associated types, each of these associated types needs to appear as an argument \nto the dictionary D, too. In other words, similar to how the dictionaries of su\u00adperclasses must be embedded \nin a class s own dictionary, the associated types of superclasses need to also be embedded.  4.6 Soundness \nAs the evidence translation maps programs from a typed source into a typed intermediate language, we \nexpect it to generate only well typed programs. That this expectation is met is asserted by the formal \nresults sketched in the follow\u00ading (full details are in a companion technical report). Type checking \nof target declarations td and target terms w is de\u00adnoted by F td and G F w : ., respectively, where G \nis a target type environment and . a target type. The type checking rules are standard for a type passing \nlambda cal\u00adculus and omitted for space reasons. Moreover, we lift the type translation judgement . . \ns . . pointwise to trans\u00adlate source to target environments.  Theorem 1. Given a type translation environment \n.,dic\u00adtionary environment ., and type environment G,if a source term e of type s translates as . | . \n| G . e . w : s, its type as . . s . ., and the environment as . . G . GF , then we have GF F w : .. \nProof. The proof proceeds by rule induction over the target term producing translation rules. The tricky \ncases are those for rules (.I )and (.E), whereweabstract over types associated with the class of a context \nand supply cor\u00adresponding representation types, respectively. Moreover, we need to make use of some auxiliary \nproperties of the judg\u00adments of Figure 4.  Theorem 2. Given a source program pgm, if we can trans\u00adlate \nit as . pgm . td, the resulting target program is well typed; i.e., F Proof. The proof considers the \ntarget declaration pro\u00adducing rules from Figure 6 in turn and demonstrates that the type environment \nproduced for the source program cor\u00adresponds to that produced for the target program by the type translation \njudgement . . s . ..  Theorem 2 is not su.cient to ensure soundness, but it provides a strong indication \nthat our translation is sound.  5. COMPARISON TO FUNCTIONAL DEPEN-DENCIES Functional dependencies [22] \nare an experimental addi\u00adtion to multi-parameter type classes that introduce a func\u00adtional relationship \nbetween di.erent parameters of a type class, which is similar to that between class parameters and associated \ntypes. Indeed, the extra type parameters introduced implicitly by our System-F translation appear explicitly \nwhen the program is expressed using functional dependencies. For example, using FDs one might express \nthe Array example like this: class ArrayRep e arr | e . arr where index :: arr . Int . e The functional \ndependency e . arr restricts the binary re\u00adlation ArrayRep to a function from element types e to rep\u00adresentation \ntypes arr. The instance declarations populate the relation represented by ArrayRep. In other words, the \nassociated type is provided as an extra argument to the class instead of being local. Consequently, the \ncorresponding in\u00adstance declarations are as before, but with the local type de.nition replaced by instantiation \nof the second parameter to the class ArrayElem (with methods omitted): instance ArrayRep Int UIntArr \ninstance (ArrayRep a arr, ArrayRep b brr) . ArrayRep (a, b)(arr, brr)   This use of functional dependencies \nto describe type-indexed data types su.ers from three serious shortcomings, which we shall discuss next. \nOn the other hand, functional dependen\u00adcies canbe usedinsituations where associated data types cannot. \nHowever, it appears as if in conjunction with associ\u00adated type synonyms they might cover all major applications \nof functional dependencies. Future work will show whether this is indeed the case. Undecidable type constraints. \nAs Duck et al. [8] point out, the instance for pairs ArrayRep (a, b)(arr, brr) is problematic, as the \ntype variables arr and brr do not oc\u00adcur in the .rst argument (a, b) to the type constraint. If such \ninstances are accepted, type inference in the presence of functional dependencies becomes undecidable. \nMore pre\u00adcisely, it diverges for certain terms that should be rejected as being type incorrect. Jones \n[22] original proposal of func\u00adtional dependencies does not allow such instances. Clutter. In the comparative \nstudy of Garcia et al. [11], mentioned in Section 2.2, Haskell receives full marks in all categories \nexcept the treatment of associated types in type classes with functional dependencies. In essence, the \nre\u00adquirement to make all associated types into extra param\u00adeters of type classes results in more complicated \nand less readable code. This is illustrated by the parameter arr in the type class ArrayRep. These extra \nparameters appear in all signatures involving associates types and can be quite large terms in more involved \nexamples, such as the graph library discussed by Garcia et al. Lack of abstraction. We would expect that \nwe can de\u00ad.ne type-indexed arrays in a module of their own and hide the concrete array representation \nfrom the user of such a module. However, an encoding based on functional depen\u00addencies does not allow \nfor this level of abstraction. To see why this is the case, consider the full type of the index func\u00adtion, \nnamely, index :: ArrayRep e arr . arr . Int . e Avoiding the use of any knowledge of how arrays of integers \nare represented, we would expect to be able to de.ne indexInt :: ArrayRep Int arr . arr . Int . Int indexInt \n= index However, such a de.nition is not admissible, as the type signature is not considered to be an \ninstance of the type in\u00adferred for the function body in the presence of the functional dependency e . \narr (cf. the class declaration of ArrayRep). In fact, we are forced to use the following de.nition instead: \nindexInt :: UArrInt . Int . Int indexInt = index This clearly breaks the intended abstraction barrier! \nIn fact, it suggests that functional dependencies threaten the usual type substitution property. The \nroot of the problem lies deep. A consequence of the evidence translation for type classes is that we \nwould expect there to be a System F term that coerces the translation of indexInt into the translation \nof indexInt . However, no such coercion exists, as it would require a non-parametric operation, which \nis not present in System F [13]. Variations on functional dependencies. Duck et al. [8] propose a more \nliberal form of functional dependencies in which recursive instances, such as that of ArrayRep,donot \nlead to non-termination. However, they also require a radi\u00adcally di.erent form of type checker based \non the HM(X) [30] framework with constraint handling rules. Stuckey &#38; Sulz\u00admann [36] introduce an \nimplementation of multi-parameter type class with functional dependencies that does not de\u00adpend on a \ndictionary translation. As a result, they can avoid some of the problems of the original form of functional \nde\u00adpendencies. Neubauer et al. [28] introduce a functional notation for type classes with a single functional \ndependency that is very much like that of parametric type classes [3]. How\u00adever, their proposal is just \nsyntactic sugar for functional dependencies, as they translate the new form of classes into multi-parameter \nclasses with a functional dependency be\u00adfore passing them on to the type checker. The same authors are \nmore ambitious in a second proposal [29], where they add a full-blown functional logic language to the \ntype sys\u00adtem, based on the HM(X) [30] framework. Neubauer et al. do not address the issue of a suitable \nevidence translation, which means that they can infer types, but not compile their programs. 6. RELATED \nWORK Type classes. There is a signi.cant amount of previous work that studies the relationship between \ntype classes and type-indexed functions [37, 19, 1, 23, 24], mostly with the purpose of expressing generic \nfunctions using standard type classes alone. Chen et al. [3] proposed parametric type classes i.e., type \nclasses with type parameters to represent container classes with overloaded constructors and selectors. \nThey provide a type system and type inference algorithm, but do not present an evidence translation. \nParametric type classes are not unlike a type class with a single associated type syn\u00adonym. Generic Haskell. \nHinze et al. [16, 18] propose a trans\u00adlation of type-indexed data types based on a type speciali\u00adsation \nprocedure. Their e.orts have culminated in Generic Haskell, a pre-processor that translates code including \ntype\u00adindexed types and functions into Haskell including type sys\u00adtem extensions such as rank-n types. \nThey pay special atten\u00adtion to type-indexed data types that are structurally de.ned, such as the Map \ntype from Section 2.1, and automatically perform the mapping from standard Haskell data type de.\u00adnitions \nto a representation based on binary sums and prod\u00aducts. In recent work, L\u00a8oh et al. [26] elaborated on \nthe origi\u00adnal design and introduced Dependency-style Generic Haskell. In fact, our translation of associated \ntypes to additional type parameters is akin to the translation of type-indexed types in Generic Haskell. \nAssociated types are a more lightweight extension to Haskell, but they miss the automatic generation \nof embedding projection pairs. ML modules. It has been repeatedly observed that there is a signi.cant \noverlap in functionality between Haskell type classes and Standard ML modules. The introduction of as\u00adsociated \ntypes has increased this overlap; ML modules have always been an agglomeration of both values and types. \nNevertheless, there are interesting di.erences between type classes and ML modules. In particular, ML \nstructures are a term-level entity and hence a notion of phase distinction [14] is required to separate \nstatic from dynamic semantics, with Leroy [25] proposing a variant. In contrast, type classes are a purely \nstatic concept. In part, due to the involvement of the term level, ML s higher-order modules give rise \nto a very rich design space [7] and it is far from clear how the di.erent concepts relate to type classes. \nDespite these dif\u00adferences, the introduction of associated types shows that the commonality between type \nclasses and ML modules may be more signi.cant than previously assumed. Hence, it would be worthwhile \nto investigate this relationship in more detail. Intensional type analysis. Intensional type analysis \n[15] realises type-indexed types by a type-level Typerec construct and has been proposed to facilitate \nthe type-preserving op\u00adtimisation of polymorphism. Subsequent work [32, 6, 5, 38] elaborated on Harper \nand Morrisett s seminal work that al\u00adready outlined the relationship to type classes. A concep\u00adtual di.erence \nbetween intensional type analysis and type classes is that the former is based on an explicit runtime \nrepresentation of types, whereas the target language of our evidence translation has a standard type-erasure \nsemantics. Nevertheless, Crary et al. [6] proposed an alternative view on intensional type analysis based \non type erasure and we need to pass method dictionaries at runtime, which can be regarded as an implicit \ntype representation. Constrained data types. Xi et al. [39] introduce type\u00adindexed data types by annotating \neach constructor of a data type declarations with a type pattern, which they call a guard, present a \ntype system, and establish its soundness. In their internal language type-indexing is explicit, which \nis in contrast to our approach, where all type-indexing is removed during the evidence translation (a \nphase that they call elab\u00adoration). Cheney &#38; Hinze s [4] present a slightly generalised version of \nguarded data types by permitting equational type constraints at the various alternatives in a data type \ndecla\u00adration. Both of these approaches di.er from our class-based approach in that our type-indexed data \ntypes are open a new class instance can always be added whereas theirs is closed, as data type declarations \ncannot be extended. Re.nement kinds. In Section 4.2, we said that we under\u00adstand a type constraint of \nthe form D a as a restriction of the range of the variable a; i.e., a only ranges over a subset of the \ntypes characterised by kind . In particular, it restricts a such that the term S a is well-de.ned on \na s entire range if S is an associated type of D. This subkinding relationship is related to Duggan s \nnotion of re.nement kinds [9]. How\u00adever, Duggan only considers type-indexed functions, but not type-indexed \ntypes. Object-oriented languages. As we mentioned in Sec\u00adtion 2.2, associated types have a long standing \ntradition in C++ and are often collected in traits classes [27]. Garcia et al. [11] compared the support \nfor generic programming in C++, Standard ML, Haskell, Ei.el, Generic Java, and Generic C#. There exists \na plethora of work on generic pro\u00adgramming in object-oriented programming languages, but it is beyond \nthe scope of this paper to review all of it. 7. CONCLUSIONS We propose to include type declarations \nalongside value declarations in Haskell type classes. Such associated types of a type class are especially \nuseful for implementing self\u00adoptimising libraries, but also serve to implement abstract interfaces and \nother concepts for which functional dependen\u00adcies have been used in the past. For the case of associated \ndata types, we demonstrated that dictionary-based evidence translation, which is standard for implementing \ntype classes can be elegantly extended to handle associated types. In particular, the target language \nis not a.ected by the exten\u00adsion of the source language. In future work, we hope to extend the mechanism \nfrom associated data types to associated type synonyms,a general\u00adisation that has substantial implications \ndue to introducing additional, non-syntactic equalities on the type level. We plan to investigate the \nfeasibility of generic default meth\u00adods [19] for classes involving associated types. Acknowledgements. \nWe thank Amr Sabry for discus\u00adsions on a previous version of this approach and for pointing us to the \nwork of Garcia et al. We thank Roman Leshchin\u00adskiy for his detailed feedback on our work and for sharing \nhis insights into generic programming in C++. We particularly thank Martin Sulzmann for his detailed \nand constructive comments on earlier drafts of the paper. We also thank Dave Abrahams, Brian McNamara, \nand Jeremy Siek for an interesting email exchange comparing Haskell type classes with C++ classes. We \nthank Robert Harper, Greg Mor\u00adrisett, Andr\u00b4e Pang and the anonymous referees for feedback on a previous \nversion of this paper. 8. REFERENCES [1] Artem Alimarine and Rinus Plasmeijer. A generic programming \nextension for Clean. In International Workshop on the Implementation of Functional Languages, number \n2312 in Lecture Notes in Computer Science, pages 168 185. Springer-Verlag, 2001. [2] Manuel M. T. Chakravarty \nand Gabriele Keller. An approach to fast arrays in Haskell. In Johan Jeuring and Simon Peyton Jones, \neditors, Lecture notes for The Summer School and Workshop on Advanced Functional Programming 2002, number \n2638 in Lecture Notes in Computer Science, 2003. [3] Kung Chen, Paul Hudak, and Martin Odersky. Parametric \ntype classes. In ACM Conference on Lisp and Functional Programming. ACM Press, 1992. [4] James Cheney \nand Ralf Hinze. First-class phantom types. CUCIS TR2003-1901, Cornell University, 2003. [5] Karl Crary \nand Stephanie Weirich. Flexible type analysis. In International Conference on Functional Programming, \n1999. [6] Karl Crary, Stephanie Weirich, and Greg Morrisett. Intensional polymorphism in type-erasure \nsemantics. In ACM SIGPLAN International Conference on Functional Programming, pages 301 312. ACM Press, \n1998. [7] Derek Dreyer, Karl Crary, and Robert Harper. A type system for higher-order modules. In Proceedings \nof the 30th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, pages 236 249, 2003. \n[8] Gregory J. Duck, Simon Peyton Jones, Peter J. Stuckey, and Martin Sulzmann. Sound and decidable type \ninference for functional dependencies. In ESOP;04, LNCS. Springer-Verlag, 2004. [9] Dominic Duggan. Dynamic \ntyping for distributed programming in polymorphic languages. Transactions on Programming Languages and \nSystems, 21(1):11 45, 1999. [10] Karl-Filip Fax\u00b4en. A static semantics for Haskell. Journal of Functional \nProgramming, 12(4+5), 2002. [11] Ronald Garcia, Jaakko Jarvi, Andrew Lumsdaine, Jeremy Siek, and Jeremiah \nWillcock. A comparative study of language support for generic programming. In Proceedings of the 18th \nACM SIGPLAN Conference on Object-Oriented Programing, Systems, Languages, and Applications, pages 115 \n134. ACM Press, 2003. [12] Cordelia Hall, Kevin Hammond, Simon Peyton Jones, and Philip Wadler. Type \nclasses in Haskell. In European Symposium On Programming, number 788 in LNCS, pages 241 256. Springer-Verlag, \n1994. [13] Robert Harper and John C. Mitchell. Parametricity and variants of Girard s J operator. Information \nProcessing Letters, 70(1):1 5, 1999. [14] Robert Harper, John C. Mitchell, and Eugenio Moggi. Higher-order \nmodules and the phase distinction. In Proceedings of the 17th ACM SIGPLAN-SIGACT Symposium on Principles \nof Programming Languages, pages 341 354. ACM Press, 1989. [15] Robert Harper and Greg Morrisett. Compiling \npolymorphism using intensional type analysis. In 22nd ACM SIGPLAN-SIGACT Symposium on Principles of Programming \nLanguages, pages 130 141. ACM Press, 1995. [16] Ralf Hinze. Generalizing generalized tries. Journal of \nFunctional Programming, 10(4):327 351, 2000. [17] Ralf Hinze and Johan Jeuring. Generic Haskell: Applications. \nIn Roland Backhouse and Jeremy Gibbons, editors, Lecture notes for The Summer School and Workshop on \nGeneric Programming 2002, number 2793 in Lecture Notes in Computer Science, 2003. [18] Ralf Hinze, Johan \nJeuring, and Andres L\u00a8oh. Type-indexed data types. In Eerke Boiten and Bernhard M\u00a8oller, editors, Proceedings \nof the Sixth International Conference on Mathematics of Program Construction (MPC 2002), number 2386 \nin Lecture Notes in Computer Science, pages 148 174. Springer-Verlag, 2002. [19] Ralf Hinze and Simon \nPeyton Jones. Derivable type classes. In Graham Hutton, editor, Proceedings of the 2000 ACM SIGPLAN Haskell \nWorkshop, volume 41.1 of Electronic Notes in Theoretical Computer Science. Elsevier Science, 2001. [20] \nMark P. Jones. Simplifying and improving quali.ed types. In FPCA 95: Conference on Functional Programming \nLanguages and Computer Architecture. ACM Press, 1995. [21] Mark P. Jones. A system of constructor classes: \nOverloading and implicit higher-order polymorphism. Journal of Functional Programming, 5(1), 1995. [22] \nMark P. Jones. Type classes with functional dependencies. In Proceedings of the 9th European Symposium \non Programming (ESOP 2000),number 1782 in Lecture Notes in Computer Science. Springer-Verlag, 2000. [23] \nRalf L\u00a8ammel. The sketch of a polymorphic symphony. In 2nd International Workshop on Reduction Strategies \nin Rewriting and Programming (WRS 2002),volume 70 of ENTCS. Elsevier Science, 2002. [24] Ralf L\u00a8ammel \nand Simon Peyton Jones. Scrap your boilerplate: a practical approach to generic programming. In Proceedings \nof the ACM SIGPLAN Workshop on Types in Language Design and Implementation (TLDI 2003), pages 26 37, \n2003. [25] Xavier Leroy. Manifest types, modules, and separate compilation. In 21st Symposium Principles \nof Programming Languages, pages 109 122. ACM Press, 1994. [26] Andres L\u00a8oh, Dave Clarke, and Johan Jeuring. \nDependency-style Generic Haskell. In Proceedings of the Eighth ACM SIGPLAN International Conference on \nFunctional Programming, pages 141 152. ACM Press, 2003. [27] Nathan C. Myers. Traits: a new and useful \ntemplate technique. C++ Report, June 1995. [28] Matthias Neubauer, Peter Thiemann, Martin Gasbichler, \nand Michael Sperber. A functional notation for functional dependencies. In 2001 ACM SIGPLAN Haskell Workshop, \n2001. [29] Matthias Neubauer, Peter Thiemann, Martin Gasbichler, and Michael Sperber. Functional logic \noverloading. In Proceedings of the 29th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages. \nACM Press, 2002. [30] Martin Odersky, Martin Sulzmann, and Martin Wehr. Type inference with constrained \ntypes. Theory and Practice of Object Systems, 5(1), 1999. [31] Chris Okasaki and Andy Gill. Fast mergeable \ninteger maps. In Workshop on ML, pages 77 86, 1998. [32] Zhong Shao. Flexible representation analysis. \nIn Proceedings ACM SIGPLAN International Conference on Functional Programming, pages 85 98, 1997. [33] \nJeremy G. Siek, Lie-Quan Lee, and Andrew Lumsdaine. The Boost Graph Library User Guide and Reference \nManual. Addison-Wesley, 2001. [34] Jeremy G. Siek and Andrew Lumsdaine. The matrix template library: \nGeneric components for high-performance scienti.c computing. Computing in Science and Engineering, 1(6):70 \n78, 1999. [35] A. A. Stepanov and M. Lee. The standard template library. Technical Report X3J16/94-0095, \nWG21/N0482, ISO Programming Language C++ Project, 1994. [36] Peter J. Stuckey and Martin Sulzmann. A \ntheory of overloading. ACM Transaction on Programming Languages and Systems, 2004. To appear. [37] Stephanie \nWeirich. Type-safe cast: Functional pearl. In Proceedings of the Fifth ACM SIGPLAN International Conference \non Functional Programming (ICFP 00). ACM Press, 2000. [38] Stephanie Weirich. Higher-order intensional \ntype analysis. In European Symposium on Programming (ESOP02), 2002. [39] Hongwei Xi, Chiyan Chen, and \nGang Chen. Guarded recursive datatype constructors. In Proceedings of the 30th ACM SIGPLAN-SIGACT Symposium \non Principles of Programming Languages, pages 224 235. ACM Press, 2003.  \n\t\t\t", "proc_id": "1040305", "abstract": "Haskell's type classes allow ad-hoc overloading, or type-indexing, of <i>functions</i>. A natural generalisation is to allow type-indexing of <i>data types</i> as well. It turns out that this idea directly supports a powerful form of abstraction called <i>associated types</i>, which are available in C++ using traits classes. Associated types are useful in many applications, especially for self-optimising libraries that adapt their data representations and algorithms in a type-directed manner.In this paper, we introduce and motivate associated types as a rather natural generalisation of Haskell's existing type classes. Formally, we present a type system that includes a type-directed translation into an explicitly typed target language akin to System F; the existence of this translation ensures that the addition of associated data types to an existing Haskell compiler only requires changes to the front end.", "authors": [{"name": "Manuel M. T. Chakravarty", "author_profile_id": "81408595395", "affiliation": "University of New South Wales, Australia", "person_id": "P187027", "email_address": "", "orcid_id": ""}, {"name": "Gabriele Keller", "author_profile_id": "81100011375", "affiliation": "University of New South Wales, Australia", "person_id": "PP39023133", "email_address": "", "orcid_id": ""}, {"name": "Simon Peyton Jones", "author_profile_id": "81100271851", "affiliation": "Microsoft Research Ltd., Cambridge, UK", "person_id": "PP43121273", "email_address": "", "orcid_id": ""}, {"name": "Simon Marlow", "author_profile_id": "81100515135", "affiliation": "Microsoft Research Ltd., Cambridge, UK", "person_id": "P265492", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1040305.1040306", "year": "2005", "article_id": "1040306", "conference": "POPL", "title": "Associated types with class", "url": "http://dl.acm.org/citation.cfm?id=1040306"}