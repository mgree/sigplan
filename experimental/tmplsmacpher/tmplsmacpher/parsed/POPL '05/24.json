{"article_publication_date": "01-12-2005", "fulltext": "\n A Semantics for Procedure Local Heaps and its Abstractions Noam Rinetzky* J\u00a8org Bauer Thomas Reps \n Mooly Sagiv Reinhard Wilhelm Tel Aviv Univ. Univ. des Saarlandes Univ. of Wisconsin Tel Aviv Univ. \nUniv. des Saarlandes Tel Aviv, Israel Saarbr\u00a8ucken, Germany Madison, USA Tel Aviv, Israel Saarbr\u00a8ucken, \nGermany maon@tau.ac.il joba@cs.uni-sb.de reps@cs.wisc.edu msagiv@tau.ac.il wilhelm@cs.uni-sb.de ABSTRACT \nThe goal of this work is to develop compile-time algorithms for automatically verifying properties of \nimperative programs that ma\u00adnipulate dynamically allocated storage. The paper presents an anal\u00adysis method \nthat uses a characterization of a procedure s behavior in which parts of the heap not relevant to the \nprocedure are ig\u00adnored. The paper has two main parts: The .rst part introduces a non-standard concrete \nsemantics, LSL, in which called proce\u00addures are only passed parts of the heap. In this semantics, objects \nare treated specially when they separate the local heap that can be mutated by a procedure from the rest \nof the heap, which from the viewpoint of that procedure is non-accessible and immutable. The second part \nconcerns abstract interpretation of LSL and devel\u00adops a new static-analysis algorithm using canonical \nabstraction.  Categories and Subject Descriptors D.3.1 [Programming Languages]: Formal De.nitions and \nTheory Semantics; F.3.1 [Logics and Meanings of Programs]: Specify\u00ading and Verifying and Reasoning about \nPrograms assertions;invariants; Semantics of Programming Languages Operational semantics; Pro\u00adgram analysis \n General Terms Languages, Theory, Veri.cation  Keywords Abstract interpretation, shape analysis, static \nanalysis, 3-valued logic *Supported in part by a grant from the the Israeli Academy of Sci\u00adence. Supported \nby the German Research Council (DFG) as part of the Transregional Collaborative Research Center Automatic \nVeri.ca\u00adtion and Analysis of Complex Systems (SFB/TR 14 AVACS). See www.avacs.orgfor more information. \nSupported by the of.ce of Naval Research under contract N00014-01-1-0796. Permission to make digital \nor hard copies of all or part of this work for personal or classroom use is granted without fee provided \nthat copies are not made or distributed for pro.t or commercial advantage and that copies bear this notice \nand the full citation on the .rst page. To copy otherwise, to republish, to post on servers or to redistribute \nto lists, requires prior speci.c permission and/or a fee. POPL 05, January 12 14, 2005, Long Beach, California, \nUSA. Copyright 2005 ACM 1-58113-830-X/05/0001 ...$5.00. 1. INTRODUCTION The long-time research goal of \nour work is to develop compile\u00adtime algorithms for automatically verifying properties of impera\u00adtive \nprograms that manipulate dynamically allocated storage. The goal is to verify properties such as the \nabsence of null dereferences, the absence of memory leaks, and the preservation of data-structure invariants. \nThe ability to reason about the effects of procedure calls is a crucial element in program veri.cation, \nprogram analy\u00adsis, and program optimization. This paper presents an approach to the modular analysis \nof imperative languages with procedures and dynamically allocated storage, based on an abstract interpretation \nof a novel non-standard storeless semantics. 1.1 Store-based vs. Storeless Semantics A straightforward \nway to specify semantics of programs with dynamically allocated objects and pointers is by a store-based \nop\u00aderational semantics, e.g., see [15]. This semantics is very natural because it closely corresponds \nto concepts of the machine architec\u00adture. Moreover, it is possible to compute the effect of a procedure \non a large heap from its effect on subheaps. This is the semantic ba\u00adsis for O Hearn s frame rule [8, \n15], which uses assertions about disjoint parts of the heap: the post condition of a procedure call is \ninferred by combining assertions that hold before the call with ones that characterize the effect of \nthe procedure call. In programming languages such as Java, where addresses cannot be used explicitly \n(in contrast to C s caststatements), it is possi\u00adble to represent states in a more abstract way because \nany two heaps with isomorphic reachable parts are indistinguishable. In particu\u00adlar, garbage cells have \nno signi.cance. This leads to the notion of storeless semantics, which was pioneered by [10]. There, \nstates are represented as aliases between pointer access paths. A .rst step in many heap-abstractions \nis to abstract away from speci.c memory addresses, e.g., [5, 7, 9, 18, 20, 21]. A storeless concrete \nsemantics has already done this step, which relieves the designer of an abstraction from having to do \nit. Thus, it is natural to base powerful pointer (shape) analysis algorithms on storeless se\u00admantics. \nUnfortunately, existing storeless semantics associate the entire heap with each procedure invocation \nand class instantiation, which makes it dif.cult to support procedure and data abstraction. Another problem \nwith storeless semantics is that it is hard to relate properties of memory cells before and after a call. \nAs a result, it is hard to scale these methods to prove properties of real-life pro\u00adgrams. By scaling \n, we mean not just cost issues but also preci\u00adsion. In particular, after a procedure call some information \nabout the calling context may be lost. In this paper, we present a .rst step towards addressing the afore\u00admentioned \nscaling issues by (i) developing a storeless semantics that allows representation of parts of the heap \nand relating proper\u00adties before and after a call, and (ii) presenting an abstraction of this semantics. \n 1.2 Main Results In this paper, we develop a method to characterize a procedure s behavior in a way \nthat ignores parts of the heap that are not relevant to the procedure. Toward this end, the paper introduces \na non\u00adstandard storeless concrete semantics, LSL, for Localized-heap Store-Less. In this semantics, a \ncalled procedure is only passed a part of the heap. Based on this semantics, a new static-analysis algorithm \nis developed using canonical abstraction [20]. This al\u00adlows us to prove properties of programs that were \nnot automati\u00adcally veri.ed before. We believe that the modular treatment of the heap will allow the implementation \nof these abstractions to scale better on larger code bases. The approach also provides insights into \nDeutsch s may-analysis algorithm [7]. The paper has two main parts: The .rst part (Sec. 4) concerns LSL, \nthe non-standard concrete storeless semantics. The second part (Sec. 5) concerns abstract-interpretation \nof this semantics. LSL is based on the following ideas: Objects in the heap reach\u00adable from an actual \nparameter are treated differently when they sep\u00adarate the local heap that can be accessed by a procedure \nfrom the rest of the heap, which from the viewpoint of that procedure is non-accessible and immutable. \nWe call these objects cutpoints.An object belongs to the local-heap when it is reachable from a pro\u00adcedure \ns actual parameters. Such an object is a cutpoint when it is reached via a pointer-access path that starts \nat a variable of a pend\u00ading call and does not traverse the local-heap. When a procedure returns, the \ncutpoints are used to update the caller s local-heap with the effect of the call. Because our goal is \nto perform static analy\u00adsis, LSL is a storeless semantics [10]; every dynamically allocated object o \nis represented by the set of access paths that reach o.In particular, unreachable objects are not represented. \nLSL is dif\u00adferent from previous storeless semantics based on pointer-access paths [5,21] in the following \nway. It does not represent access paths that start from variables of pending calls in the local state \nof the current procedure. This means that a procedure has a local view that only includes objects that \nare reachable from the procedure s parameters and, in addition, any objects that it allocates. We characterize \nthe manner in which LSL simulates a standard store-based semantics and identify a class of observations \nfor which LSL is equivalent to the standard store-based semantics. This al\u00adlows us to prove properties \nranging from the absence of runtime errors to partial and total correctness with respect to the standard \nstore-based semantics. The second part of the paper uses LSL as the starting point for static-analysis \nalgorithms that treat the heap in a more local, more modular way than previous work. In this part of \nthe pa\u00adper, we present a new interprocedural shape-analysis algorithm for programs that manipulate dynamically \nallocated storage. The algo\u00adrithm is based on an abstraction of LSL. The new algorithm can prove properties \nof programs that were not automatically veri.ed before (e.g., destructive merge of two singly-linked \nlists by a re\u00adcursive procedure, see Fig. 18). Furthermore, the analysis is done in a way that is more \nlikely to scale up. In particular, our analysis bene.ts from the fact that the heap is localized: the \nbehavior of a procedure only depends on the contents of its local-heap. This allows analysis results \nto be reused for different contexts. 1.3 Outline The remainder of the paper is organized as follows: \nSec. 2 sets the scene by de.ning EAlgol, a simple imperative language, and de.ning its standard store-based \nsemantics. It also introduces our P . prog ::= rcdecl fndecl rcdecl tname fndecl ::= ::= ::= record t \n:= { tname f }int | t tname p(tname x):=vdecl st vdecl ::= tname VarId st c . . stms cnd const ::= ::= \n::= x=c | x=y | x=y op z | x=y.f |x.f= null | x.f=y | x = alloc t |y=p(x) | lb : st | while (cnd) do \nst od |st ; st | if (cnd) then st else st fi x == y | x != y | x == c | x != c null | n Figure 1: Syntax \nof EAlgol. running example. Sec. 3 de.nes cutpoints and describes their use in LSL. Sec. 4 de.nes LSL \nsemantics for EAlgol and states its properties. Sec. 5 presents the shape-analysis algorithm. Sec. 6 \nreviews closely related work. Sec. 7 concludes our work.  2. PRELIMINARIES In this section, we introduce \na simple imperative language called EAlgol. We de.ne its standard semantics, which is operational, large-step, \nstore-based (as opposed to storeless), and global, i.e., the entire heap is passed to a procedure. We \nrefer to this semantics as GSB, for Global-heap Store-Based. 2.1 Syntax of EAlgol Programs in EAlgol \nconsist of a collection of functions includ\u00ading a main function. The programmer can also de.ne her own \ntypes (`ala C structs) and refer to heap-allocated objects of these types using pointer variables. Parameters \nare passed by value. For\u00admal parameters cannot be assigned to. Functions return a value by assigning \nit to a designated variable ret. The syntax of EAlgol is de.ned in Fig. 1. The notation z\u00afde\u00adnotes a \nsequence of z s. We de.ne the syntactic domains x, y . VarId, f . FieldId, p . FuncId, t . TypeId, and \nlb . Labels of variables, .eld names, functions identi.ers, type names, and program-labels, respectively. \nFor a function p, Vp denotes the set of its local variables and Fp denotes the set of its formal parame\u00ad \nters. We assume Fp . Vp and that all the variables in Vp \\ Fp are declared at the beginning of a function \ndeclaration. 2.2 Running Example The EAlgol program shown in Fig. 2 is our running exam\u00adple. The program \nconsists of a type de.nition for an element in a linked list (Sll); three list-manipulating functions: \ncreate (crt), destructive append (app), and destructive reverse (reverse); and a mainfunction. The program \nallocates three acyclic linked lists. It then destruc\u00adtively appends the list pointed-to by t2 to the \ntails of the lists pointed-to by t1 and t3. As a result, at program point lbc, just before reverse is \ninvoked, x points-to an acyclic list with .ve elements, zpoints-to an acyclic list with .ve elements, \nand the two lists share their last two elements as a common tail. The invocation of reverse, which is \nthe core of our running example, (destructively) reverses the list passed as an argument. As a result, \nat lbr, reverse s return-site, y points-to the head of the reversed-list. Note that the shared tail of \nthe list pointed-to by zhas also changed. record Sll := { Slln; intd } Sll reverse(Sll h):= lbe : Sll \np,q,t; p=h; while (p!=null) do q=p.n; p.n=t; t=p; p=q od; ret= t lbx : int main():= Sll x,y,z,t1,t2,t3; \nt1=crt(3); t2=crt(2); t3=crt(3); x=app(t1,t2); z=app(t3,t2); t1=null; t2=null; t3=null; lbc : y = reverse(x); \nlbr : ret=0 Figure 2: The running example. The code of functions crtand appappears in App. A. l . Loc \nv . Val = Loc .{null}. . Envp = Vp . Val h . HeapG = Loc \u00d7 FieldId . Val =2Loc Sp sG,(L,.,h). G \u00d7 Envp \n\u00d7 HeapG Figure 3: Semantic domains of the GSB semantics. 2.3 Global-Heap Store-Based Semantics We now \nde.ne the GSB semantics for EAlgol. For simplic\u00adity, the semantics tracks only pointer values and assumes \nthat every pointer-valued .eld or variable is assigned null before being as\u00adsigned a new value.1 In addition, \nwe assume that before a function terminates it assign a null value to every pointer variable that is \nnot a formal parameter.2 Fig. 3 de.nes the semantic domains. Loc is an unbounded set of memory locations. \nA memory state for a function p, sp . Sp G, keeps track of the allocated memory locations, L, an environment \nmapping p s local variables to values, ., and a mapping from .elds of allocated locations to values, \nh. Due to our simplifying assump\u00adtions, a value is either a memory location or null. The meaning of statements \nis described by a transition relation G G . (sG \u00d7 stms) \u00d7 sG. Fig. 4 shows the axioms for assignments. \nThe inference rule for function calls is given in Fig. 5. All other statements are handled as usual using \na two-level store semantics for pointer languages. Example. The memory state at lbc, the call-site to \nreverse,is c depicted graphically in Fig. 6 (labeled sG). Allocated locations are depicted as rectangles \nlabeled by the location name. The value of each variable is depicted as an arrow from the variable name \nto the 1Special care need to be taken when handling statements in which the same variable appears both \nin left-side of the assignment and in its right-side, e.g., x = x.f. Such statements require additional \nsource-to-source transformations and the introduction of temporary variables. 2These conventions simplify \nthe de.nition of both GSB semantics and LSL; in principle, different ones could be used with minor effects \non the capabilities of our approach. For clarity, our example programs do not adhere to these restrictions. \n(x = null,(L,.,h)) G (L,.[x. null],h) (x = y,(L,.,h)) G (L,.[x. .(y)],h) (x = y.f,(L,.,h)) G. h(.(y),f)],h) \n(1) (L,.[x (x.f (L,.,h[(.(x),f). null]) (2) = null,(L,.,h)) G (x.f = y,(L,.,h)) G(L,.,h[(.(x),f) . \n.(y)]) (2) (x = alloc t,(L,.,h)) G (3)  (L.{l},.[x. l],h.I(l)) Figure 4: Axioms for atomic statements \nin the GSB semantics. The side-conditions are: (1) .(y) null, (2) .(x)= null, and = (3) l . L. I initializes \nall pointer .elds at lto null. G (body of p,(Le,.e,he)) (Lx,.x,hx) G (y = p(x1,... ,xk),(Lc,.c,hc)) (Lr,.r,hr) \nwhere .c(xi) v = zi Le = Lc,.e(v)= ,he = hc null otherwise Lr = Lx,.r = .c[y . .x(ret )],hr = hx Figure \n5: Inference rule for function invocation in the GSB se\u00admantics, assuming the formal variables of pare \nz1,... ,zk and that p s return value is a pointer. memory location it points-to. The value of a .eld \nis depicted by a directed edge labeled with the .eld name. ee The invocation of reversestarts in state \nsG. The heap of sG c is identical to the one of sG, but its environment only maps h, reverse s formal \nparameter, to l0, the value of the actual param\u00adeter x. The execution of reverse s body ends with retpointing \nto the head of the reversed list. The memory state at the exit point, x lbx, is denoted by sG, the state \nafter the invocation of reverse r r is denoted by sG. Note that the heap in sG is as in reverse s exit-point, \nand the environment is as in the call-site, except that the return value (ret) is assigned to y.  2.4 \nObservable Properties In this section, we introduce access paths, which are the only means by which a \nprogram can observe a state. Note that the pro\u00adgram cannot observe location names. * DEFINITION 2.1 \n(FIELD PATHS). A .eld path d . .= FieldId is a (possibly empty) sequence of .eld identi.ers. The empty \nse\u00adquence is denoted by E. DEFINITION 2.2 (ACCESS PATH). An access path a = (x,d). Vp \u00d7 . of a function \npis a pair consisting of a local variable of p and a .eld path. AccPathp denotes the set of all access \npaths of function p. AccPath denotes the union of all access paths of all functions in a program. Apart \nfrom the above formal de.nitions, we will sometimes use the notation x.n.n for access paths, because \nits syntax is famil\u00adiar from a number of programming languages, where it denotes a sequence of .eld dereferences. \nBecause states and access paths are always associated with a (unique) function p, in the rest of the \npaper, we omit p whenever it is clear from the context. Also, to simplify notation, we assume that we \nwork with a .xed arbitrary program P.  Figure 6: Memory states that arise during the execution of the \nrunning example according to the GSB semantics (left column) and the LSL semantics (right column). We \nshow the memory states at lbc, the call-site to reverse (.rst row); lbe, the entry to reverse(second \nrow); lbx, reverse s exit point (third row); and lbr, the return-site from reverse(fourth row). For the \nlocal\u00adheap semantics, the .gure shows only the heap (sets of aliased access paths); the memory states \nat lbc, lbe, lbx, and lbr are de.ned as sc = (\u00d8,Ac), se = ({{h.n.n.n. }},Ae), sx = ({{h.n.n.n. }},Ax), \nand sr = (\u00d8,Ar) respectively. LLL L The value of an access path a = (x, d) in state (L, ., h), denoted \nby [[ a]] G(L, ., h), is de.ned to be h ( .( x) ,d) , where h : Val \u00d7 . . Val such that . {v ifd = E \nh ( v, d)= h ( h( v, f) ,d') ifd = fd',v . Loc null otherwise Note that the value of an access path \nthat traverses a null-valued .eld is de.ned to be null. This de.nition simpli.es the notion of equivalence \nbetween the GSB semantics and LSL, our new se\u00admantics. Alternatively, we could have de.ned the value \nof such a path to be .. The semantics given in Fig. 4 checks that a null\u00addereference is not performed \n(see the side-conditions listed in the caption). DEFINITION 2.3 (ACCESS-PATH EQUALITY). Access paths \na and \u00df are equal in a given state sG, denoted by [[ a = \u00df]] G( sG) ,if they have the same value in that \nstate, i.e., [[ a]] G ( sG)= [ \u00df]] G( sG) . An access path is equal to null, denoted by [[ a = null]] \nG( sG) , if [[ a]] G ( sG)= null. Our semantics is a natural semantics; the stack of activation records \nis maintained implicitly. However, we need the notion of an access path that starts at a variable of \na pending call (i.e., not the current call). In a small-step semantics, this would be an access path \nthat starts at a variable allocated in the activation record of a pending call. We use the term a pending \nvariable for a local variable of a pending call, and a pending access path for an access path that starts \nat a pending variable. When we wish to emphasize that a variable (resp. access path) is of the current \ncall, we use the term a current variable (resp. a current access path). For example, in state se is a \npending variable, and G, at the entry to reverse, x z.n.n.n is a pending access path; the only current \nvariable is h and h.n.n.nis a current access path.  3. CUTPOINTS AND THEIR USE In this section, we \nde.ne cutpoints and describe their use in LSL. To assist the reader, we provide some intuition by referring \nto the global store-based semantics (see Sec. 2.3) and to a small\u00adstep (stack-based) operational semantics. \nLSL is a storeless se\u00admantics, i.e., memory cells are not identi.ed by locations. Thus, we cannot talk \nabout locations as in Sec. 2.3. Instead, we use the term objects. In LSL, every dynamically allocated \nobject o is represented by the set of pointer-access paths that reach o. Unlike existing store\u00adless semantics \n[5], in LSL, pending access paths are not repre\u00adsented as parts of the local state of the current procedure. \nThe advantage of our approach is that when a procedure is invoked, it operates only on a part of the \nheap, namely, the objects that are reachable from the procedure s actual parameters. The downside of \nthis approach is that the memory state just after the call cannot always be de.ned in terms of the state \nprior to the call. The intu\u00aditive reason for this de.ciency is that the description of an object may \nchange due to destructive updates. For example, in the run\u00adning example, to determine that the pointer-access \npaths y.n.n and z.n.n.n are aliased after the invocation of reverse,we need to know that the list element \npointed-to by h.n.n.n when the execution of reverse begins, is pointed-to by ret.n when the execution \nends. To capture this kind of temporal relationship, LSL tracks the effect of a function on cutpoints. \nCutpoints are the objects that separate the part of the heap that an invoked function can access from \nthe rest of the heap (excluding the objects pointed\u00adto by actual parameters). DEFINITION 3.1. (Cutpoints) \nA cutpoint for an invocation of function p is a heap-allocated object that, in the program state in which \nthe execution of p s body starts, is: (i) reachable from a formal parameter of p (but not pointed-to \nby one) and (ii) pointed\u00adto by a pending access path that does not pass through any object that is reachable \nfrom one of p s formal parameters. t h i s S Figure 7: An illustration of the cutpoints for an invocation \nin a store-based small-step (stack-based) operational semantics. The .gure depicts the memory state at \nthe entry to zoo. The stack of activation record is depicted on the left side of the di\u00adagram. Each activation \nrecord is labeled with the name of the function it is associated with. Heap-allocated objects are de\u00adpicted \nas rectangles labeled with their location. The value of a pointer variable (resp. .eld) is depicted by \nan edge labeled with the name of the variable (resp. .eld). The shaded cloud marks the part of the heap \nthat zoocan access. The cutpoints for the invocation of zoo(u7 and u9 ) are heavily shaded. Note that \nu10 is not a cutpoint although it is pointed-to by pending access paths that do not traverse through \nthe shaded part of the heap, e.g., x2 and y.f1.f1. This is because u10 is also pointed-to by h, zoo s \nformal parameter. For example, in memory state sc , the list element at location G l3 is a cutpoint because \nit is pointed-to by the n-.eld of the list element at location l7, which is not reachable from the (only) \nactual parameter x. For an additional example, see Fig. 7. Technically, LSL uses cutpoint-labels to relate \nthe post-state of the function with its pre-state. Cutpoint-labels mark the cutpoints at and throughout \nan invocation. DEFINITION 3.2. (Cutpoint Labels) A cutpoint-label cpl . 2Fp\u00d7. for function p is a set \nof access paths that start at a for\u00admal parameter of p. The set 2Fp\u00d7. is denoted by CPLbsp. In every \nfunction invocation, LSL labels all the cutpoints. A cutpoint-label is the set of all access paths that \nstart with a for\u00admal parameter (of the invoked function) and point-to the cutpoint when the function \nexecution starts. The label of a cutpoint does not change throughout the execution of the function s \nbody, even if the heap is modi.ed by destructive updates. For example, the fourth list element in x s \nlist is a cutpoint for the invocation y=reverse(x). The label of this cutpoint is {h.n.n.n}because h.n.n.n \nis the (only) access path that points-to the cut\u00adpoint at the entry to the function. A good analogy for \nthe role of cutpoint-labels in our semantics is the use of auxiliary variables in formal veri.cation. \nAuxiliary variables are used to record variable values at the entry to a function; a cutpoint-label is \nused to record the access paths that reach a cutpoint at function entry. To empha\u00adsize this similarity, \nwe use the notation .a where a . CPLbsp for cutpoint-labels for function p. LSL is able to infer the \neffect of an invoked function on the heap of its caller by including in the representation of an object \nall the .eld paths that reach it and start at a cutpoint. DEFINITION 3.3 (CUTPOINT-ANCHORED PATHS). A \ncutpoint\u00adanchored path a = (cpl,d). CPLbsp \u00d7 . for a function p is a cutpoint-label for function p and \na (possibly empty) sequence of .elds. For example, at the memory state after the execution of reverse \ns body, the cutpoint-anchored path {h.n.n.n}.n is aliased with the access path ret.n.n. From this information, \nour semantics can in\u00adfer that in the main function, at the state after the invocation of reverse, z.n.n.n.n \nis aliased with y.n.n. Technically, during the invocation of a function, an object is rep\u00adresented by \nthe access paths and cutpoint-anchored paths that point\u00adto it. DEFINITION 3.4 (GENERALIZED ACCESS PATHS). \nA gener\u00adalized access path for a function p is either an access path of p or a cutpoint-anchored path \nof p. GAccPathp denotes the set of all access paths of function p. GAccPath denotes the union of all \naccess paths of all functions in a program. When there is no risk of confusion, we abbreviate a generalized \naccess path of the form (r, E) by r. Note that r can be either a variable, or a cutpoint-label. REMARK \n3.5. Cutpoint-labels isolate the information about the part of the heap that a function cannot access, \nto the sharing pat\u00adtern of the cutpoints, i.e., to the set of access paths that at the entry to the function \npoint-to a cutpoint. Furthermore, the isolation is achieved in a parametric way: although a cutpoint-label \nexpresses the fact that an object is also pointed-to by a pending access path, it is described in terms \nof the invoked function s formal parame\u00adters. This allows us to infer the meaning of a cutpoint-label \nin a context-independent way. REMARK 3.6. Note that because of the garbage-collecting na\u00adture of storeless \nsemantics, there is a non-trivial technical dif\u00ad.culty in obtaining a local semantics for the storeless \nmodel. If a garbage-collection scan was to collect the heap using only the procedure s local variables \nas the roots, then elements would be garbage collected that are accessible in the global state; adding \nthe cutpoint-labels to the set of roots prevent this potential source of unsoundness.  4. THE LOCALIZED-HEAP \nSTORELESS SEMANTICS In this section, we de.ne LSL, the Localized-heap Store-Less semantics. The semantics \nis a natural semantics and, as before, tracks only pointer values. To de.ne the semantics, we use the \nfunction \u00b7.\u00b7, de.ned in Fig. 9. It is used as an in.x operator. The application a.d concatenates the \nsequence of .eld identi.ers d to a. We say that a generalized access path a is a pre.x of a generalized \naccess path \u00df, denoted by a = \u00df, when there is a .eld path d . ., such that \u00df = a.d.We say that a is \na proper pre.x of \u00df, denoted by a<\u00df, when d = E. The function \u00b7.\u00b7 is lifted to handle sets of access \npaths and sets of sequences of .eld identi.ers. In addition, we make use of the .at functional, well-known \nfrom functional programming. .at M returns the set of all elements of def M,if M is a set of sets. Formally, \n.at M = {x |.A . M : x . A}. r . Rootp =Vp . CPLbsp a, \u00df . GAccPathp =Rootp \u00d7 . GAccPathp o . Obj p =2 \nObjects L p A, Ap . Heapp =2ObjL Heaps L CPLbsp \u00d7 Heapp sL . SLp =2L Memory state Figure 8: Semantic \ndomains of memory states for function p. We use the syntactic domains Vp, CPLbsp, and GAccPathp as semantic \ndomains, too (and use italics font to denote a seman\u00adtics value.) 4.1 Memory States In this section, \nwe de.ne the representation of memory states in LSL. Traditionally, a storeless semantics represents \nthe heap by an equivalence relation over a set of access paths, where equivalence classes (implicitly) \nrepresent allocated objects. For readability, we use the equivalence classes directly. A memory state \nfor a function p is a pair (CPLp,Ap) of aset of cutpoint-labels, (denoted by CPLp) and a heap (denoted \nby Ap). A heap is a .nite (but unbounded) set of objects. An object (de\u00adnoted by o) is described by a \n(possibly in.nite) set of generalized access paths. Fig. 8 gives the semantic domains used in LSL for \na memory state of a function p. A memory state (CPLp,Ap) at a given point in an execution is composed \nof the labels of all the cutpoints of the current invocation (CPLp) and a representation of the heap \n(Ap) at that the point in the execution. To exclude states that cannot arise in any program, we now de.ne \nthe notion of admissible states. DEFINITION 4.1 (ADMISSIBLE MEMORY STATES). A memory state (CPLp,Ap) \nfor a function p at a given point in an execution is admissible iff (i) A generalized access path points-to \n(at most) one object, i.e., .o, o ' . Ap if o = o ' , then o n o ' = \u00d8; (ii) A is right-regular, i.e., \n.o1,o2 . Ap if a, \u00df . o1 and a.d . o2 then \u00df.d . o2; (iii) Ap is pre.x-closed, i.e., if a.f . .at Ap, \nthen a . .at Ap; and (iv) a root of every access path in the description of any object is either a local \nvariable of p or a label of one of the cutpoints, i.e., if (r, d). .at Ap then either r . Vp or r . CPLp; \n(v) \u00d8. A; (vi) CPLp satis.es the following requirements: (a) the cutpoint-labels in CPLp are mutually \ndisjoint, (b) CPLp is right\u00adregular (but not necessarily-pre.x closed), (c) \u00d8. CPLp. The .rst three conditions \nare standard in storeless semantics. The fourth condition limits the set of cutpoint-anchored paths that \nare tracked during an invocation to be rooted at a cutpoint of the in\u00advocation. The .fth condition is \nbecause we only represent objects that are pointed-to by a current or a pending access path. The sixth \nrequirement captures the fact that the set of cutpoints is actually a subset of the objects in the heap \nwhen the function is invoked. Because LSL preserves admissibility of states (see [17]), in the sequel, \nwhenever we refer to an LSL state, we mean an admissible LSL state. It is possible to extract aliasing \nrelationships from the sets of generalized access paths that describe the objects in a heap, and in particular \nto observe the heap structure as follows: a current variable x points-to an object o iff the access path \n(x, E) is in o. Similarly, cutpoint-label cpl labels object o iff (cpl,E) is in o. The .eld fof an object \no1 points-to object o2 iff for every generalized access path (r, d) in o1, the generalized access path \n(r, df) is in o2. A generalized access path a points-to (resp. passes through)an object o,if a . o (resp. \n.\u00df<a such that \u00df . o). An object o is reachable from a variable x, if there exists a .eld path d . .such \nthat (x, d). o. Example. The heap of the running example at the state in which reverse is invoked is \nshown in the .rst row in the second col\u00adumn of Fig. 6 (labeled Ac). It shows eight sets of generalized \nac\u00adcess paths. Each set represents one allocated list-element. At Ac , x.n.n.n and z.n.n.n point-to the \nsame object. The set of cutpoint\u00adlabels at the call site is empty. This is always the case for the main \nfunction. The fourth element in x s list is a cutpoint for the invo\u00adcation of reverse: it is reachable \nfrom an actual parameter (its representation includes x.n.n.n) and by a .eld of an object that is not \npassed to the invoked function (the n-.eld of the third ob\u00adject in z s list). The heap at the beginning \nof reverse(shown in Fig. 6, labeled by Ae) differs from Ac in three ways: (i) there are only .ve objects \nin the heap; (ii) the set of cutpoint-labels contains {h.n.n.n}, which labels the fourth element in the \nlist; and (iii) ob\u00adjects are represented in terms of the generalized access paths that start either with \nh or with {h.n.n.n}. 4.2 Inference Rules The meaning of statements is described by a transition relation \nL . (sL \u00d7stms)\u00d7sL. We give axioms for assignments and an in\u00adference rule for procedure calls in Fig. \n10 and Fig. 11, respectively. All other statements are handled in the standard way [11]. To sim\u00adplify \nnotation, we assume A with a certain index (resp. prime) to be the heap component of a state sL with \nthe same index (resp. prime). We use the same convention for indexed (or primed) ver\u00adsions of CPL and \na state s cutpoint-labels component. 4.2.1 Helper Functions To de.ne the inference rules, we use the \nfollowing functions: [\u00b7], rem(\u00b7, \u00b7)and add(\u00b7, \u00b7), which are de.ned in Fig. 9. We use a as \u00b7 a metavariable \nranging over sets of generalized access paths, which are not necessarily objects, whereas o always stands \nfor objects. The function [a]A returns the object that a points-to in heap A. When a does not point-to \nany object, [a]A returns the empty set (which by de.nition never describes an object pointed-to by a \ncur\u00adrent, or even a pending, access path). The function rem takes as its arguments a heap A and a set \nof generalized access paths a. It removes from the description of ev\u00adery object in heap A all the access \npaths that have a pre.x in a. Whenever rem removes all the (generalized) access paths from the description \nof an object, that object is removed from the description of the heap. The function add(A, a, a)yields \na modi.ed version of heap A, where to every object o . A reachable from a by fol\u00adlowing some .eld path \nd . ., the generalized access paths a.d are added. In addition, we make use of map(), another well known \nfunc\u00adtional from functional programming. The functional map(f)M applies f to every element of M and returns \nthe resulting set. For\u00ad def mally, map(f)M = {f(x)| x . M}. 4.2.2 Atomic Statements The axioms for atomic \nstatements are given in Fig. 10. We sim\u00adplify the semantics by making the same assumptions as in Sec. \n2.3. Assigning null to a variable x does not modify the link struc\u00adture of the heap. We only need to \neliminate all the access paths that start with x, using the rem function. The semantics for the assignment \nx=ycopies the value of the variable y into x by adding an access path (x, d) to any object o that can \nbe reached from y by following a .eld path d, i.e., (y, d)points-to o. This is accomplished by applying \nadd to the given . :GAccPath \u00d7 .. GAccPath s.t. def (r, d).d ' = (r, dd ' ) GAccPath GAccPath . :2\u00d7 .. \n2s.t. def a.d = {a.d | a . a} GAccPath GAccPath s.t. . :2\u00d7 2. . 2 def a.D = {a.d | a . a, d . D} []:GAccPath \n\u00d7 HeapL . Obj L s.t. def [a]= {\u00df . a | a . A, a . a} A GAccPath rem :HeapL \u00d7 2. HeapL s.t. def rem(A, \na)=(map(.o.o \\ a..)A)\\ {\u00d8} GAccPath add :HeapL \u00d7 2\u00d7 GAccPath . HeapL s.t. def add(A, a, a)= map(.o. o \n. a.{d . .| a.d . o})A Figure 9: Helper functions. (x =null, (CPL,A)) L (CPL, rem(A, {x})) (x =y, (CPL,A)) \nL (CPL, add(A, {x},y)) (x =y.f, (CPL,A)) L (CPL, add(A, {x},y.f)) (1) (x.f =null, (CPL,A)) L (CPL, rem(A, \n[x]A.f)) (2) (x.f =y, (CPL,A)) L (CPL, add(A, [x]A.f, y)) (2) (x =alloc t, (CPL,A)) L (CPL,A .{{x}}) \nFigure 10: Axioms for atomic statements in the local heap se\u00admantics. Note that the set of cutpoint-labels \nis not changed. The side-conditions are: (1)y . .at A and (2)x . .at A. The side-condition x . .at A \n(resp. y . .at A) means that x s (resp. y) value is not null.  heap, the singleton set {x}, and the \naccess path y. The rule for .eld dereference x = y.f is similar. It adds the access path (x, d) to any \nobject that can be reached from yby fol\u00adlowing .eld f, and then continuing with .eld path d. Note, how\u00adever, \nthat the rule can be applied only if y points-to an object, i.e., the semantics checks that a null-dereference \nis not performed. A destructive update x.f = null (potentially) modi.es the link structure of the heap. \nThus, every generalized access path that has a pre.x aliased with (x, f) is removed from the description \nof every object in the heap. Note, that [x]A returns all the access paths that are aliased with x. Concatenating \n[x]A with f returns the set of pre.xes of affected access paths. Again, the rule can be applied only \nif xpoints-to an object. An assignment x.f =yalso has a (potential) effect on all the access paths that \nare aliased with x. After this assignment, any object o that can be reached by following the .eld path \nd from y, i.e., (y, d). o, is also reachable by traversing some (generalized) access path aliased with \nx, followed by an f-.eld, and continuing with d. As this is a place where cycles can be created, add \ndoes not necessarily return a right-regular heap. Therefore we apply the \u00af operator\u00af\u00b7. A is de.ned to \nbe the set of equivalence classes obtained from the least right-regular, pre.x-closed, equivalence relation \nthat 3 is a superset of the equivalence relation induced by A. Note that this de.nition may only add \naccess paths to the description of ex\u00adisting objects. The (deterministic) semantics of memory allocation \nx = alloc tadds a new object that is described by {x} to the heap. Note that this de.nition (implicitly) \ninitializes the .elds of the new object to null. 4.2.3 Function Calls The inference rule for function \ncalls is de.ned in Fig. 11. The rule de.nes the program state sr that results from an invocation L y=p(x1,... \n, xk) at memory state sc L, assuming that the execu\u00adtion of the body of p at memory state se L results \nin memory state sx L. The heaps Ac and Ar are described by sets of generalized access paths starting \nat the caller s variables and cutpoint-labels, whereas the heaps Ae and Ax are described by sets of generalized \naccess paths that start at the callee s formal parameters, cutpoint\u00adlabels, and return variable. The \nrule provides the means to reconcile the different representations. y=p(x1,... ,xk) y=p(x1,... ,xk) The \nrule uses the functions Callq and Retq , which are parameterized for each call statement in the program. \ny=p(x1,... ,xk) Callq computes the memory state se that results at L the entry of p when y =p(x1,... \n,xk)is invoked by q in mem\u00adory state sc The caller s memory state after the invocation is re- L. y=p(x1,... \n,xk) stored by the function Retq . This function computes the memory state of the caller at the return-site \n(sr ) according Lto q s memory state at the call-site (sc L) and p s memory state at the exit-site (sx \nL). In the rest of this section we describe the rule for an arbitrary call statement y =p(x1,... ,xk)by \nan arbitrary function q. The rule utilizes additional helper functions, de.ned in Fig. 12, which we gradually \nexplain. The main idea behind the rule is to utilize the fact that a function cannot modify objects that \nare not in its local-heap (i.e., in the part of the heap that is not reachable from any actual parameter \nwhen the function is invoked). In particular, because LSL describes ob\u00adjects in terms of the (generalized) \naccess paths that point-to them, these inaccessible objects have the same description before and after \nthe call. Thus, only the description of the objects in the func\u00adtion s local-heap (i.e., in the part \nof the heap that the function can access) is (possibly) updated. The update is carried out using the \ncutpoints of the invocation.4 In essence, the semantics freezes the initial descriptions of the cutpoints \nand arranges for them to persist throughout the execution of the called function. This sets up a re\u00adlation \nbetween values on entry to values on exit. At the return, the frozen information is used to update the \ndescription of objects in the called function s local-heap via an operation that is (roughly) similar \nto a relational join [3]. (The operation is not a pure rela\u00adtional join because of some name adjustments \nthat are needed due to the different representation of objects by the caller and by the callee.) To .nd \nwhich objects are in the local-heap of the called func\u00adtion, i.e., reachable from the actual parameters \n(x1,... ,xk), we .rst compute the set of objects that are pointed-to by p s actual parameters (Oc args \n). Then, the auxiliary function RObjs .nds the part of the caller s heap (Ac) that is reachable from \nthese objects (Opassed c ). The description of the objects after the call should account for 3The operator \n\u00af\u00b7 is similar to the .rstc operator in [6]. 4The same mechanism is used to compute the description of \nobjects that the callee allocates. y=p(x1,... ,xk) qp Callq :SL . SL s.t. y=p(x1,... ,xk) def Callq \n((CPLc,Ac))= Let Oargs ={[xi]| 1= i= k, [xi]=\u00d8} Opassed c)Oargs cAc Ac c =RObjs(Ac Ocp =CPObjs((CPLc,Ac))(Oargs \n,Opassed ) cq cc =.o. Oargs \u00ae bindargs .{(hi,E)| 1= i= k, xi . o} c =.o. Ocp bindcp c .{(sub(bindargs \n)o,E)} o . Oargs =.o. Oargs . Ocp bindargs (o) c bindcall .o . Ocp cc bindcp(o) c in , map(sub(bindcall \n))Opassed (map(sub(bindargs ))Oc cp ) c y=p(x1,... ,xk) qp q Retq :S\u00d7 S. Ss.t. LL L y=p(x1,... ,xk) def \nRetq ((CPLc,Ac),(CPLx,Ax))= Let \u00ae bindret =.a. range(bindcall ). {{(ret ,E)}}. {(y,E)} a={(ret,E)}Bypass(Oc \npassed ). bind-1 (a) otherwise call in (CPLc ,(Ac \\ Oc passed ). map(sub(bindret ))Ax) e sx (body of \np,sL) L L (y =p(x1,... ,xk),sc ) L sr LL where =Cally=p(x1,... ,xk) se (sc Lq L) =Rety=p(x1,... ,xk) \nsr (sc L) Lq L,sx .  { Figure 11: The inference rule for function calls in LSL. The rule is given for \nan arbitrary call statement y =p(x1,... ,xk) by an arbitrary function q. We assume that the formal param\u00ad \n. (2ObjL GAccPath ObjRObjs .Heap2)s.t.L:L def '' RObjs...}{.| O,d ..d(A)OA,oo= oo Obj..(Obj 2)s.t.Bypass \n:2L L def ' GAccPath GAccPath GAccPath ...2)(Obj 2)sub :(2L def . dom(bind)a, Bypass(O)o = {(r,d). o \n|.d <d.(r,d ' ). .at O} s.t. sub(bind)o = .at bind(a).d d . .,a.d . o qq q q . (2ObjL \u00d7 2Obj. 2Obj CPObjsq \n:SL LL )s.t. c))(Oargs ,Opassed def CPObjs((CPLc,A)= qcc Let Opassed \\ Oargs Odeep = cc Ovars = {[(x,E)]Ac \n. Odeep | x. Vq }' c \\ Opassed .o . Ac , O.d = o. Odeep' .f . FieldId,o.f . o Ocpl = {[(cpl ,E)]. Odeep \n| cpl . CPLc} Ac in Ovars . Ocpl . O.d Figure 12: Helper functions for the function-call rule. The function \nCPObjsq is parameterized for every function q in the program. Recall that Vq is the set of q s local \nvariables. quali.ed as a cutpoint if (and only if) one of the following holds: ois pointed-to by a local \nvariable of the caller (Ovars ), or o is pointed-to by an object in the part of the caller s heap that \nis not passed to the function (O.d ), or o separates the heap of the caller from the heap of one of the \npending calls, i.e., ois a cutpoint of the invocation of the eters of pare h1,... ,hk. the mutations \n(destructive updates) of the heap performed by the callee. However, because the invoked function cannot \nmodify ob\u00adjects that it cannot access, it can only modify .elds of objects in Opassed c . Thus, to compute \nthe (possibly) updated description of objects in Oc passed (as well as of objects that the callee allocates) \nit is suf.cient to have a description of every object in Oc passed (and of every object allocated by \nthe callee) comprised of the (general\u00adized) access paths that start at objects that separate Oc passed \nfrom the rest of the caller s heap: When the function returns, we just re\u00adplace any (generalized) access \npaths (rp,dp) in the description of every object in the heap of the callee (Ax) that start at a separating \nobject o ' , by access paths of the caller (rq,dqdp) such that (rq,dq)points-to o ' , but does not pass \nthrough Oc passed (and thus cannot be modi.ed). Technically, this is done as described below. The auxiliary \nfunction CPObjsq (cf. Fig. 12) determines the cutpoints for this function invocation (Oc cp ). Cutpoints \nare the ob\u00adjects that separate Oc passed from the rest of the caller s heap. For expository reasons, \nwe do not want to consider objects that are pointed-to by actual parameters as cutpoints. Thus, the function \nCPObjsq , which is passed the caller s memory state as well as the and Opassed previously computed Oc \nargs c , considers only objects in Opassed \\ Oargs Odeep = cc as possible cutpoints. Following the in\u00adtuition \nof cutpoints as separating objects , an object o . Odeep is caller (Ocpl ). Back in Fig. 11 we de.ne \nseveral binding mappings to bridge the gap between the two different representations of objects (in terms \nof access paths of the caller and in terms of access paths of the callee). The function bindargs maps \nobjects pointed-to by actual parameters to the set of trivial access paths that are made up of the corresponding \nformal parameters. The function bindcp maps every cutpoint (in the caller representation) to the set \nof access paths that start with a formal parameter of the caller and point-to that cutpoint at the entry \nto the function, i.e., bindcp maps a cut\u00adpoint to its label (see Sec. 3). To compute the label of a cutpoint \no, we apply sub(bindargs ). The latter denotes a function that re\u00adplaces every access path that starts \nwith an actual parameter (xi,d)in the representation of oby an access path (hi,d) that starts with the \ncorresponding formal parameter. (sub is de.ned in Fig. 12.) The bindcall combines the previous two mappings \ntrivially as they have disjoint domains. Having de.ned these mapping functions, computing the mem\u00adory \nstate of pin which its body will be evaluated (i.e., the descrip\u00adtion of the heap at the function entry) \nis straightforward. The set of cutpoint-labels (CPLe) is computed by applying bindcp to ev\u00adery cutpoint. \nThe heap component (Ae) is constructed by applying bindcall to every object in Oc passed . Note that \nin the resulting de\u00adscription, objects are described by the set of (generalized) access paths that point-to \nthem and start either at a formal parameter or at a cutpoint object. To handle the return of function \np, we use an additional binding, bindret . This mapping is the inverse of bindcall (hence getting back \nto the caller s representation of the object) composed with the function Bypass( Oc passed ) , which \n.lters out generalized access paths (of the caller) that pass through the part of the heap that p had \naccess to (Oc passed ). In addition, it also takes care of replacing access paths starting with special \nvariable ret with the same access paths starting with result variable y. Note that applying bindret is \nwell de.ned because CPLx and CPLe are equal (the callee cannot modify the set of objects that separate \nits own local-heap from the local-heap of of some pending call5). The cutpoint-labels component of the \nstate after the return of p is the same as before the invocation (CPLc) because the callee (p) cannot \nmodify the set of objects that separate the heap of its caller (q) from the heap of some other (earlier) \npending-call. The new heap is called Ar . It is derived by removing from the heap at the call-site the \npassed objects (Oc passed ), plugging in the heap that results from evaluating p s body (Ax), and substituting \nthe de\u00adscription of all the objects by applying sub( bindret ) to every object in Ax . Example. Applying \nthe function-call rule for the invocation of reversein our running example results in the following sets \nand mappings: Oargs c = {{x}} Opassed c = {{x}, {x.n}, {x.n.n}, {x.n.n.n, z.n.n.n}, {x.n.n.n.n, z.n.n.n.n}}Oc \ncp = {z.n.n.n, x.n.n.n}bindargs = {x}.{h} bindcp = {z.n.n.n, x.n.n.n} .{{h.n.n.n}} bindret = {{x}.{h}, \n{{h.n.n.n}} .{z.n.n.n}, {ret }.{y}} In particular, the fourth element in x s list is a cutpoint for \nthe in\u00advocation of reverse (see Sec. 4.1) and its label is {h.n.n.n}. Thus, when the execution of reverse \ns body starts, the cutpoint is represented by the following set of (generalized) access paths: {h.n.n.n, \n{h.n.n.n}}. When the execution of the function body ends, the cutpoint-anchored paths in the representation \nof every object in Ax (see Fig. 6) are replaced by access paths that start with z.n.n.n, the only access \npath that points-to the cutpoint at the call-site and bypasses the objects that were passed to reverse. \nFor example, the cutpoint-anchored path {h.n.n.n}.n in the rep\u00adresentation of the third element in the \nreturned list is replaced by z.n.n.n.n.  4.3 Properties of the Semantics The only means by which a \nprogram can observe a state is by ac\u00adcess paths. In particular, the program cannot refer to the cutpoint\u00adlabels \ncomponent of the state. To state the theorems, we need some preliminary de.nitions about access-path \nequality and ob\u00adservational equivalence. We use the same simplifying notational conventions as in Sec. \n4.2. Note that in both semantics an access path is equal to nullwhen it has a pre.x which is equal to \nnull. DEFINITION 4.2 (ACCESS PATH EQUALITY). Access paths a and \u00df are equal in a given state sL, denoted \nby [[ a = \u00df]] L( sL) ,if .a . A. a . a .. \u00df . a. An access path a is equal to null in state sL, denoted \nby [[ a = null]] L( sL) ,if a . .at A. s ' component in sL and s ' 5Note that in any transition (sL, \nst) LL, the cutpoint-labels L is the same. DEFINITION 4.3 (OBSERVATIONAL EQUIVALENCE). Let p be a function. \nThe states sL . S p and sG . S p are observationally LG equivalent if for all a, \u00df, . . AccPathp, (i) \n[[ a = \u00df]] L( sL) . [[ a = \u00df]] G( sG) , and (ii) [[ . = null]] L( sL) . [[ . = null]] G( sG) .  4.3.1 \nSemantic Equivalence The following theorem is the main theorem in the paper. It states that LSL is equivalent \nto GSB, in the sense that both be\u00adhave equivalently w.r.t. termination, and that execution of state\u00adments \npreserves observational equivalence. A proof of the theorem is given in [17]. THEOREM 4.4 (EQUIVALENCE). \nLet p be a function. Let sL . S p . S p L and sGG be observationally equivalent states. Let st be an \narbitrary statement in p. The following holds: L ' G ' (st,sL) sL .. (st,sG) sG. Furthermore, s ' G are \nobservationally equivalent. L and s ' The following theorem states that LSL can be used to: (i) verify \ndata-structure invariants that are expressed by access-path equali\u00adties at a program point; and (ii) \nassert the absence of null-valued pointer dereferences. Formally, a property is an invariant at a (la\u00adbeled) \nstatement if is satis.ed in any memory-state that occurs just before the (labeled) statement is executed. \nCOROLLARY 4.5. Let P be a program, p a function , lb apro\u00adgram point in p. For any a, \u00df . AccPathp, [[ \na = \u00df]] L is an invariant of P at lb iff [[ a = \u00df]] G is an invariant of P at lb. The following theorem \nstates that LSL can detect memory leaks6 without investigating reachability from roots of pending access \npaths. A memory leak can occur only when a variable or a .eld is assigned null. The leaked objects are \nthe ones that are not pointed-to only by suf.xes of the nulli.ed variable (or .eld). COROLLARY 4.6. A \nmemory leak can occur only when a vari\u00adable or a .eld is assigned null. Furthermore,  Executing a statement \nx = nullin a memory state (CPL,A)leaks an object o iff o . x.. .  Executing a statement x.f = nullin \na memory state (CPL,A)leaks an object o iff o . [ (x, E)] .f.. .  A Both Cor. 4.5 and Cor. 4.6 are corollaries \nof The. 4.4. In [17] we de.ne a language of assertions over access paths and show that LSL preserves \npartial and total correctness of assertions expressed in this language. 6By a memory leak we mean an \nobject that is not pointed-to by any access path; i.e., neither by an access path of the current call \nnor by one of a pending call.   5. SHAPE ANALYSIS In this section, we use the LSLsemantics to automatically \ncom\u00adpute a safe approximation to the set of possible program states us\u00ading an iterative abstract-interpretation \nalgorithm. The main idea is that every abstract state .nitely represents a potentially in.nite number \nof concrete LSLstates. The program is interpreted ac\u00ad cording to an abstract semantics (L) that over-approximates \nthe concrete transition relation ( L ). Termination of the the abstract\u00adinterpretation algorithm is guaranteed \nby the .niteness of the set of abstract states. The algorithm is conservative, it describes any memory \nstate that can arise (at any program point) in any execution. This means that we can conservatively determine \nproperties of the program such as the absence of null-dereferences, absence of garbage, and va\u00adlidity \nof invariants by checking these properties on the (generated) abstract states. However, because the description \nis conservative, the algorithm might represent concrete states that are infeasible ac\u00adcording to the \nconcrete semantics. This leads to incompleteness in the sense that we may fail to establish assertions \nthat hold for every execution. We present a new interprocedural shape-analysis algorithm for programs \nthat manipulate singly-linked lists. The algorithm .nds a .nite description of all the memory states \nthat arise during pro\u00adgram execution. Useful information regarding the program s be\u00adhavior can be extracted \nfrom the computed descriptors. For exam\u00adple, an analysis of the running example successfully veri.es \nthat the program does not reference null; does not create garbage; and that when reversereturns, the \nvariables zand ypoint-to acyclic linked lists with a shared tail. The algorithm is presented in terms \nof the 3-valued-logic frame\u00adwork for program analysis of [20]. Technically, 3-valued logical structures \nare used to represent unbounded memory states. The tracked properties are encoded as predicates. In this \npaper, we focus on the abstraction of LSLmemory states. Due to lack of space, we do not give the full \ndetails of the analyses. In particular, the abstract transfer functions are not de.ned. Instead, we specify \nthe analysis using the best abstract transformer [4]. A detailed description of the shape-analysis algorithm \nis given in [19]. 5.1 Representing LSLMemory States by 3-Valued Logical Structures Kleene s 3-valued \nlogic is an extension of ordinary 2-valued logic with the special value of 12 (unknown) for cases in \nwhich predicates could have either value, 1(true) or 0(false). We say that 0and 1 are de.nite values, \nwhereas 12 is an inde.nite value. The informa\u00adtion partial order on the set {0, 1 ,1}is de.ned as 0. \n1 ;1, and 22 0U1= 12 . A 3-valued logical structure S is comprised of a set of individu\u00adals (nodes) called \na universe, denoted by US, and an interpretation over that universe for a (.nite) set of predicate symbols. \nThe inter\u00adpretation of a predicate symbol pin S is denoted by p S. For every SS USk 1 ,1}.predicate p \nof arity k, p is a function p :().{0, 2 A 2-valued structure is a 3-valued structure with an interpretation \nlimited to {0,1}. The set of 2-valued logical structure is denoted by 2-Struct, and the set of 3-valued \nlogical structures is denoted by 3-Struct. To establish the Galois connection between the set of program \nstates (ordered by set inclusion) and 3-Struct, it suf.ces to show a representation function that maps \na program state to its most\u00adprecise representation in 3-Struct (e.g., see [14]). We de.ne the function \n\u00dfshape :SL . 3-Struct, which maps a local-heap to its most precise representation as a 3-valued logical \nstructure. \u00dfshape is    to2VLS:SL .2-Struct s.t. to2VLS((CPL,A))=S where US =A.CPL and isListS (v)= \nv .A isLabelS(v)= v .CPL x S(v)= v .Aand x .v n S(v1,v2)= v1 .A,v2 .Aand v1.n .v2 rx S(v1)= .a.v1 s.t. \n(x,E)=a ilsS (v)= .a.n .v, \u00df.n .v s.t. [a]A =[\u00df]A c S(v)= .a.v, \u00df .v s.t. a<\u00df eq S(v1,v2)= v1 =v2 lblS(v1,v2)= \nv1 .CPL,v2 .Aand (v1,E).v2 cp S(v)= .r .CPL s.t. (r,E).v S rcp(v)= .r .CPL,d .. s.t. (r,d).v Figure 13: \nThe function to2VLS maps states in SL to 2-valued logical structures. Predicate Intended Meaning isList(v) \nIs v a list element? isLabel(v) Is v a cutpoint-label? x(v) Is v pointed-to by a (current) variable x? \nn(v1,v2) Does the n-.eld of v1 point-to v2? rx (v) Is v2 reachable from (current) variable xusing n-.elds? \nils(v) Is v locally shared? i.e., is vpointed-to by more than one n-.elds of objects in the local-heap? \nc(v) Does v reside on a directed cycle of n-.elds? eq(v1,v2) Are v1 and v2 the same object or cutpoint-label? \nlbl(v1,v2) Is list element v2 labeled by cutpoint-label v1? cp(v) Is list element va cutpoint? rcp(v) \nIs the list element vreachable from a cutpoint using n-.elds? Table 1: The predicates used to represent \nstates in SL. There are separate predicates xand rx for every program variable x. a composition of two \nfunctions: (i) to2VLS:SL .2-Struct, which maps a local-heap sL to an unbounded 2-valued logical structure \nS, and (ii) canonical abstraction :2-Struct .3-Struct which con\u00adservatively bounds S (de.ned as usual \nin [20]). 5.1.1 Representing a Local-Heap by a 2-Valued Log\u00adical Structure The function to2VLS, de.ned \nin Fig. 13, maps a local heap sL = (CPL,A)to a 2-valued logical structure S. Every object o . A and every \ncutpoint-label cpl . CPL is represented by a unique node in US . Tracked properties of the memory state \nare recorded by the predicates given in Tab. 1. We denote the set of predicates used to represent a memory \nstate by P. 2-valued logical structures are depicted as directed graphs. A directed edge between nodes \nu1 and u2 that is labeled with binary predicate symbol pindicates that p S (u1,u2)=1. Also, for a unary \npredicate symbol p, we draw pinside a node u when p S(u)=1; conversely, when p S(u)=0we do not draw pin \nu. We explain the predicates intended meanings through an exam\u00ad e ple. In the example, we apply to2VLS \nto sL, the memory state at the entry point of reverse (shown in Fig. 6). The resulting 2-valued logical \nstructure, denoted by Se, is depicted in Fig. 14. The universe of Se contains six nodes. The nodes u0 \nu3 rep\u00adresent the list elements. The node u6 represents the cutpoint-label {h.n.n.n}. The predicates \nisList and isLabel record whether a node repre- L ' L ' (st,S){\u00dfshape(sL)|sL ..(S),(st,sL) sL} sents \na list element or a cutpoint. We draw nodes u that repre\u00adsent list elements, i.e., isListS (u)=1, as \nrectangles, e.g., nodes u0 u3; and we draw nodes v that represent cutpoint-labels, i.e., isLabelS (v)=1, \nas circles, e.g., node u6. The predicates h, n, rh , ils, c, and eq are an adaptation to local\u00adheaps \nof the standard predicates used in the analysis of singly linked lists [13, 20]. -For each pointer variable \nh, there is a unary predicate h. The value of hS(u)is 1if variable hpoints-to the list element rep\u00adresented \nby u. The value of the h-predicate is depicted via an edge from the predicate name hto the node that \nrepresents the list element that hpoints-to. -The pointed-to-by-a-.eld relation between list elements \nis rep\u00adresented by the binary predicate n, i.e., n S (v1,v2)=1if the n-.eld of the list element represented \nby v1 points-to the list element represented by v2. -The unary predicate rh holds for list elements that \nare reach\u00adable by an access path that starts at a local variable h of the current call. -The unary predicate \nils captures local-heap sharing informa\u00adtion. The predicate has the value 1at a node uthat represents \na list element that is pointed-to by the n-.elds of two or more list elements in the local heap. Note \nthat the predicate records only local sharing. In particular, ilsSe (u2)=0, although in a global-view \nof the heap, the list element represented by u2 is the n-successor of two list elements: one in the local \nheap (represented by u1b) and one not in the local heap (the third element in the list pointed-to by \nz). -The unary predicate cholds at a node that resides on a cycle of n-.elds. -The binary predicate eq \nrecords the equality relation. It is not drawn in the pictures. The predicates lbl, cp, and rcp record \ninformation that is special for the abstraction of an LSLstate. -The binary predicate lbl relates a node \nthat represents a cutpoint\u00adlabel to the node that represents the corresponding cutpoint. For example, \nlblS (u6,u2)=1, because u6 represents the la\u00adbel of the cutpoint represented by u2. -The unary predicate \ncp records the property that a list element is a cutpoint, e.g., cp Se (u2)=1because u2 represents the \n(only) cutpoint in Se; for all other nodes u, cp Se (u)=0. -The unary predicate rcp records the property \nthat a list ele\u00adment is reachable by a cutpoint-anchored path. For example, Se Se rcp (u2)=1and rcp (u3)=1because \n(only) u2 and u3 rep\u00ad resent list elements that can be reached from the cutpoint (by the cutpoint-anchored \npaths ({h.n.n.n},E)and ({h.n.n.n},n), respectively). For all other nodes u, rcp Se (u)=0. The predicates \ncp and rcp are used to record information regard\u00ading cutpoint-anchored paths in a similar manner to the \nway hand rh record information regarding access-paths. However, unlike local variables, the number of \ncutpoints is unbounded. Thus, we cannot have a predicate recording the reachable list-elements from every \ncutpoint. Instead, we use individuals to represent cutpoint-labels, and mark cutpoint objects with the \ncp predicate. Figure 16: A speci.cation of the abstract inference rules for atomic statements. 5.1.2 \nCanonical Abstraction The main idea in canonical abstraction is to represent several list elements (or \ncutpoint-labels) by a single node, i.e., the map\u00adping from list elements and cutpoint-labels to the universe \nof the 3-valued logical structure is a surjective function, but not neces\u00adsarily an injective function. \nA node that represents more than one list element (or more than one cutpoint-labels), is called a summary \nnode. Formally, a 3-valued logical structure S. is a canonical abstrac\u00adtion of a 2-valued logical structure \nS if there exists a surjective function f:US .US satisfying the following conditions: (i) For all u1,u2 \n.US , f(u1)=f(u2)iff for all unary predicates p.P, p S(u1)=p S(u2), and (ii) For all predicates p .Pof \narity k and L. . .US for all k-tuples u1,u2,... ,u k , . SLL. S p (u1,u2,... ,u k)= p (u1,u2,... ,uk). \nu1,... ,uk.Us f(ui)=u i We say that a node u . . US represents node u . U, when f(u)=u . . Example. The \n3-valued logical structure SeL, depicted in Fig. 15 (.rst row, second column), (conservatively) represents \nthe memory state see. L, represented by S 3-valued logical structures are also drawn as directed graphs. \nDe.nite values are drawn as for 2-valued structures. Binary in\u00adde.nite predicate values (12 ) are drawn \nas dotted directed edges. Summary nodes are depicted by a double frame. The universe of Se contains 6 \nnodes. The only nodes that have the same values for all the unary predicates are u1a and u1b. Thus, the \nuniverse of Se. contains .ve nodes. The mapping f:USe . US e induced by the canonical abstraction is \nf(u0)=u0. , f(u1a)= f(u1b)=u1, f(u2)=u2, f(u3)=u3, and f(u6)=u6. The only summary node is u1. . We see \nthat any memory state represented by Se. contains one cutpoint label (the node u6 . is not a summary \nnode). The cutpoint is represented by u . 2. This is recorded in two ways: (i) the value of the predicate \nlblS e (u6,u2)=1and (ii) u2 represents a list ele\u00adment that is labeled, as indicated by the value of \nthe unary predicate cp S e (u . 2)=1.  5.2 Abstract Interpretation The speci.cation of the abstract \ninterpretation is given by ab\u00adstract inference rules in the same style as the natural semantics. The \nabstract inference rules operate on 3-valued logical structures. Fig. 16 and Fig. 17 shows the speci.cation \nof the abstract inference rules for atomic statements and function-calls respectively. These rules are \ndeclarative in the style of the best abstract transformer [4]: every abstract inference rule emulates \na corresponding concrete in\u00adference rule using represented states . Example. Fig. 15 shows an application \nof the function-call infer\u00adence rule from Fig. 17 to the running example. The logical struc\u00adtures are: \nScL, which arises at lbc, the call-site to reverse; Se. ,  h.n.n.n, h.n.n.n.n, u0 = { h },u1a = { h.n \n},u1b = {h.n.n },u2 = ,u3 = , {h.n.n.n}{h.n.n.n}.n u6 = {h.n.n.n} L, the memory state at the entry point \nof reverse (se L is shown in Fig. 6). We denote this structure by Se.  Figure 15: Representative 3-valued \nlogical structures that arise during the analysis of the running example at lbc, the call-site to reverse \n(.rst row, .rst column); lbe, the entry to reverse (.rst row, second column); lbx, reverse s exit point \n(second row, second column); and lbr, the return-site from reverse(second row, .rst column). which arises \nlbe, the entry to reverse; SxLwhich arises at lbx, the exit-point of reverse; and SrL, the structure \ncomputed at the return-site. In SxL, the list pointed-to by ret is reversed. As a result, uL0 is now \nreachable from the cutpoint at the exit-site. Therefore, even though the list-element pointed-to byzis \nnot explicitly represented in SxL, the inference rule allows us to conclude that at SrL, the return- \nL L site s logical structure, u0 becomes reachable from z. Similarly, u3 is no longer reachable from \nz. To conclude, de.nite values of many of the tracked properties of z can be established after the function \ncall returns.  5.3 Discussion In our abstraction, when a program state is mapped to a 2-valued logical \nstructure, no information is tracked regarding the contents of their labels. Furthermore, we do not differentiate \nbetween differ\u00adent cutpoints. This may lead to a signi.cant loss of precision when multiple cutpoints \narise. For example, passing two lists with shared tails will be handled very conservatively. Nevertheless, \neven with this simple abstraction, our abstract do\u00admain is precise enough to analyze the singly-linked-list-manipulating \nprograms analyzed in [9, 18] and verify that they do not derefer\u00adence null-valued pointers, do not create \ngarbage, and do not create cyclic lists. Moreover, we can handle programs not handled before by [9,18]. \nFor example, we can verify that a recursive function that destructively merges two acyclic lists, returns \nan acyclic list. It is straightforward to allow multiple cutpoints for functions with multiple formal \narguments by discriminating cutpoints reach\u00adable from different formal parameters. This will improve \nthe preci\u00adsion of handling functions that are passed multiple lists. 6. RELATED WORK Storeless Semantics. \nStoreless semantics was .rst introduced by Jonkers [10]. The original work does not handle procedure \ncalls. Intraprocedural storeless semantics is also used in [1] to develop a logic that allows to express \nregular properties of unbounded data structures. A storeless semantics that handles function-calls is \nde.ned in [6]. The semantics is used to develop a may-alias algorithm. In contrast to LSL, in [6] pending \naccess paths are explicitly represented. May-Alias Analysis. May-alias algorithms .nd an upper ap\u00adproximation \nfor the sets of aliased access paths at every program point. Deutsch s interprocedural may-alias algorithm \nof [7] uses a storeless representation of the heap. The algorithm is polynomial and can handle function \ncalls, dynamic memory allocation and de\u00adstructive updates. (body of p,XSp) LL XS ' p L (y = p( x1,... \n,xk) ,XSq) L XSq ' where {CallpL) | sc . q ( scL . .( XSq ) } .( XSp) . sc ( sc sx {L . .( XSq) , RetpL,sxL \n. .( XS ' ) , . .( XS ' ) compatible( scL) qL) pqL,sx } Figure 17: A speci.cation of the abstract inference \nrules y=p(x1,... ,xk) for function calls. The functions Call q and y=p(x1,... ,xk) Retq are de.ned in \nFig. 11. Note that we apply y=p(x1,... ,xk) Retq only for compatible pairs of memory states. Memory states \nscL are compatible when the sharing pat- L and sx tern that results from the invocation of p at sc L \nmatches the de\u00adscription of the context in sx L, the state of p at the exit-site. For\u00admally, compatible( \nscL) ' L,sx .. ( CPLe = CPLx ..h,h . Fp.[[ h = h ' ]] L( se .. [[ h = h ' ]] L( sx ..h . L) L) Fp.[[ \nh = L) .. [[ h = null]] L( sx null]] L( seL)) , where y=p(x1,ldots,xk) se ( sc L = CallqL) . LSL provides \ninsight into Deutsch s work on static may-alias analyses based on pointer-access paths [7] in particular, \nthe treat\u00adment of variables of pending calls, which is one of the most compli\u00adcated aspects of [7]. For \ninstance, a surprising aspect of the method given in [7] is that recursive procedures are handled in \na more pre\u00adcise way than loops. The intuitive reason is that the abstractions of values of variables \nin the current procedure is different from the abstraction used for values of variables in pending procedures. \nFur\u00adthermore, in [17], we show that Deutsch s algorithm can be seen as an abstraction of the LSL semantics \nby we de.ning a Galois con\u00adnection between memory states in LSL with the abstract domain of [7]. Interprocedural \nShape Analysis. The original motivation for our work comes from our attempt to apply interprocedural \nshape analysis (e.g., [20]) to heap-manipulating programs in a modular fashion. In [16, Chap. 6] this \nobjective was achieved, but based on a weaker technique: (i) a procedure operates on the part of the \nheap that is reachable from the actual parameters, where the heap is considered as an undirected graph; \nand (ii) pending access paths that point-to objects in the passed part of the heap are represented. In \nthis paper, the heap is treated as a directed graph and pending access paths are not represented. In \naddition, [16] does not handle recursive procedures. Interprocedural shape analysis has been studied \nin [9,18]. In [18], the main idea is to make the runtime stack an explicit data structure and abstract \nit as a linked list. In this method, the entire heap and run-time stack are represented at every program \npoint. As a result, the abstraction may lose information about properties of the heap, for parts of the \nheap that cannot be affected by the procedure at all. In [9], procedures are considered as transformers \nfrom the (entire) program heap before the call, to the (entire) program heap after the call. Every heap-allocated \nobject is represented at every program point; on the other hand, only the values of the local variables \nof the current procedure are represented, which means that the irrelevant parts of the heap are summarized \nto a single summary node during the analysis of an invoked procedure. A modular interprocedural shape-analysis \nalgorithm is presented in [2]. A procedure is analyzed only in the part of the heap that is reachable \nfrom its parameters. The algorithm is able to relate the memory states at the procedure-entry with the \nmemory states at the procedure-exit by labeling every abstract node. However, the mapping is determined \nby the sharing within the part of the heap that is passed to the procedure, and not by the sharing pattern \nwith the context which is what is needed.  7. CONCLUSIONS In this paper, we develop LSL, a storeless \nsemantics for lan\u00ad guages with dynamic memory allocation, destructive updating and procedure calls. Our \nstoreless semantics is unique in that called procedures are only passed parts of the heap. Our main insight \nis that the side-effects of a procedure invoca\u00adtion on R-values of pending access paths can be delayed \nto the pro\u00adcedure return even though the memory cells do not have unique identi.ers, e.g., locations. \nThe main idea is to track the effect of destructive updates on access paths that start with the set of \nobjects that separate the part of the heap the procedure can reach from the rest of the heap (objects \nthat we call the cutpoints of the invocation). A similar observation regarding the uniform effect of \na procedure on pending access paths was made by [5, 12] for pointer analysis. We believe we are the .rst \nones to use it in semantics. LSL was designed with its precise and ef.cient abstractions in mind: information \nabout the context provided by the rest of the heap is isolated to the sharing patterns of the cutpoints \nwhich are expressible in a context-independent manner. An analysis bene.ts from the fact that the heap \nis localized: the behavior of a procedure only depends on the part of the heap that is reachable from \nactual parameters, and on the sharing patterns that create cutpoints. Fur\u00adthermore, analysis results \ncan be reused for different contexts that have similar sharing patterns. Using an abstraction of the \nnon-standard concrete semantics, we present a new interprocedural shape-analysis algorithm for pro\u00adgrams \nthat manipulate dynamically allocated storage. Our approach is markedly different from previous works \nthat analyze a function invocation in the calling context [9, 18]. The new algorithm can prove properties \nof programs that were not automatically veri.ed before, (e.g., to establish that a recursive, destructive \nmerge of two acyclic singly-linked lists returns an acyclic singly-linked list see Fig. 18). In particular, \nit provides a way to establish proper\u00adties with fewer program-speci.c instrumentation predicates. We \nbelieve that the modular treatment of the heap will allow the im\u00adplementation of these abstractions to \nscale better on larger pieces of code. The approach also provides insights into an existing may\u00adanalysis \nalgorithm [7]. Two design choices were made during the development of the new shape-analysis algorithm: \nOne is to use a storeless seman\u00adtics. The other is to concentrate on a superset of a program s foot\u00adprint, \nbased on reachability, rather than the actual footprint. While the ideas underlying our approach apply \nalso to store-based seman\u00adtics, the choice of a storeless semantics was a natural one to make (see Sec. \n1.2). We speci.ed the semantics using an equivalence relation of pointer access-paths (and not, for example, \nby logical structures as done in [20]) because the naming scheme we use for cutpoints (cutpoint-labels) \n.ts naturally with the explicit manipu\u00adlation of access paths done in this type of semantics. The decision \nto concentrate on a superset of a program s footprint (inferable via static analysis), was a pragmatic \nchoice for the present study. In fu\u00adture work, we plan to investigate the use of user-supplied assertions \nabout preserved portions of the heap.   \n\t\t\t", "proc_id": "1040305", "abstract": "The goal of this work is to develop compile-time algorithms for automatically verifying properties of imperative programs that manipulate dynamically allocated storage. The paper presents an analysis method that uses a characterization of a procedure's behavior in which parts of the heap not relevant to the procedure are ignored. The paper has two main parts: The first part introduces a non-standard concrete semantics, <i>LSL</i>, in which called procedures are only passed <i>parts</i> of the heap. In this semantics, objects are treated specially when they separate the \"local heap\" that can be mutated by a procedure from the rest of the heap, which---from the viewpoint of that procedure---is non-accessible and immutable. The second part concerns abstract interpretation of <i>LSL</i> and develops a new static-analysis algorithm using canonical abstraction.", "authors": [{"name": "Noam Rinetzky", "author_profile_id": "81100129514", "affiliation": "Tel Aviv University, Tel Aviv, Israel", "person_id": "P483756", "email_address": "", "orcid_id": ""}, {"name": "J&#246;rg Bauer", "author_profile_id": "81341488070", "affiliation": "University des Saarlandes, Saarbr&#252;cken, Germany", "person_id": "PP38023594", "email_address": "", "orcid_id": ""}, {"name": "Thomas Reps", "author_profile_id": "81100117392", "affiliation": "University of Wisconsin, Madison, WI", "person_id": "PP40023877", "email_address": "", "orcid_id": ""}, {"name": "Mooly Sagiv", "author_profile_id": "81100150928", "affiliation": "Tel Aviv University, Tel Aviv, Israel", "person_id": "PP39029858", "email_address": "", "orcid_id": ""}, {"name": "Reinhard Wilhelm", "author_profile_id": "81100325916", "affiliation": "University des Saarlandes, Saarbr&#252;cken, Germany", "person_id": "PP39037801", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1040305.1040330", "year": "2005", "article_id": "1040330", "conference": "POPL", "title": "A semantics for procedure local heaps and its abstractions", "url": "http://dl.acm.org/citation.cfm?id=1040330"}