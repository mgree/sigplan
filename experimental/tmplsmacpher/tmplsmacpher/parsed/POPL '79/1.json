{"article_publication_date": "01-01-1979", "fulltext": "\n Permission to make digital or hard copies of part or all of this work or personal or classroom use is \ngranted without fee provided that copies are not made or distributed for profit or commercial advantage \nand that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, \nto post on servers, or to redistribute to lists, requires prior specific permission and/or a fee.&#38;#169; \n1979 ACM 0-12345-678-9 $5.00 A PL/CV PRECIS Robert L. Constable Scott D. Johnson Department of Computer \nScience Cornell University Ithaca, NY 14853 ABSTRACT: PL/CV is a new formal system which mixes commands \nand assertions. It includes axioms and rules for a theory of programming over integers and characters. \nSince arguments in the theory can be checked by the PL/CV Proof Checker, the system offers an approach \nto mechanical program verification . The Proof Checker is efficient enough for classroom use. Early experience \nwith PL/CV indicates that it nicely supports formal verification of elementary arguments. Con\u00adtinued \nwork should enable the formalization of non-elementary reason\u00ading as well. 1. Introduction 1.1 Overview \nHere is a brief presentation and dis\u00adcussion of PL/CV, a new formal system which mixes commands and assertions. \nThe system contains a programming language whose ccmmands can be compiled and execut\u00aded. The rules for \nwriting arguments con\u00adstitute a formal logic, including a theory of the predicate calculus, a theory \ncf ar\u00adithmetic, ai~d a Itheory of programming . The system offers. a style of mechanically assisted reasoning \nin that arguments in the calculus can be checked by the PL/CV Prcof Checker. Since these arguments can \nbe about programs, the system provides a new approach to prcgram verification. The PL/CV system illustrates \nseveral interesting principles cf programming languages. The ideas and techniques used to make high level \nprogramming languages viable are employed to make this high lev\u00adel logic viable, e.g. block structuring \nof proofs, highly flexible definition and abbreviation facilities, conformity with ordinary mathematics, \netc. Moreover the implementation was designed to make proof checking efficient (but for a few well\u00adccntained \nexceptions in arithmetic and tautology checking) . The PL/CV system is the first working example of a \nnew type of programming system i n which the logical and commaqd languages are thoroughly in\u00ad tegrated. \nThe legic is novel, yet simple, and the implementation permits inexpensive experimental verification \n, of a type dis\u00adtinct from that possible in other verifi\u00adcation systems. 1.2 Guiding Principles The \ndesign of PL/CV was begun in 1975, a pilct system was tested in 1976. The version described here was \navailable as of July 1978. The design was guided by experience with the pi Lot system and a few simple \ncriteria, which we enumerate. This work was supported in part by NSF (1) A desire to investigate concepts \ngrants DCR-74-14701, MCS-76-14293, and from the mainstream of modern computingMCS-78-00953. suggests \nthat the command language should be the core of an Algol-like procedural language, suitably restricted \nto commands for which simple rules can be found (as in Pascal , see [121). (2) Experience with mathematical \n reasoning (and nearly a hundred years of study by logicians) suggests that the deductive structure of \nthe system should be based on the familiar and well-known predicate calculus. (3) To permit compact natural \nex\u00adpression of computational reasoning, the steps of an argument should allow commands and programs (hence \narguments are dynam\u00adic!! in the setlSe of [241). Conversely, programs (especially long ones) should permit \narguments within them, as in the asserted programs of [101. (4) Unnecessary notation should be avoided \n. We do not use Hoare s primitive {P}A{Q}, nor do we introduce special ele\u00adments to denote undefined \nobjects. The only notation used is that of ordinary mathematics and procedural programming, along with \nsyntax to combine them. (5) It should be tolerable for peo\u00adple to write and read complete formal proofs \nin the system. Hence, the formal system should mimic as closely as possible informal methods. We therefore \nadopt the Natural Deduction style calculus of Gentzen and Prawitz [251. This system should be to ordinary \nformal proofs as Al\u00adgol is to Turing machines, and it should be as understandable to the average pro\u00adgrammer \nas Algol is. (6) The formal proofs should be good documentation for the reasoning behind the  program. \nThus , it must be possible to ar\u00adgue directly about the program without translating it entirely into \nlogic (as is done in most other verifiers, e.g. Stan\u00adford Pascal , SRI system, Usc system, etc.). (7) \nIt should be possible to effi\u00adciently check the correctness of these formal arguments with a computer. \nThe use of the proof checker should be inexpensive enough to encourage widespread experimen\u00adtation with \nthe system, and to permit its use in the classroom. (8) Based on our experience dealing with partial \ncorrectness , we believe the logic should be confined to describing terminating computations. Commands \ncannot be introduced into an argument unless they are shown to terminate; partial correct\u00adness arguments \ncan be considered only by explicitly assuming termination. (9) The first version of the system should \nmeet the above goals on the class of elementary arguments encountered in be\u00adginning undergraduate courses \nin program\u00adming and discrete mathematics. Modern logic has provided an organization of mathematics which \nmakes it possible to discern, at least roughly, this class of elementary arguments. By beginning with \nthese we can concentrate on the issues of whether a logic @f this type is feasible at all. If we succeed \ncn the elementary arguments, we can then examine more com\u00adplex reascning, e. g. that invclving user defined \ndata types, higher type functions, metamathematical reascning, etc.  1.3 Comparison with other systems \nThe command language of PL/CV is PL/CS, a disciplined subset cf PL/I Which is accepted by the PL/CS, \nPL/C, and PL/I compilers. PL/CV resembles the Stanford Pascal Verifier [13] in that its command language \nis a !Istructured!f subset of an Algol-like language. However, unlike the Pascal verifier, PL/CV dces \nnot translate asserted programs into the predicate cal\u00adculus , but instead prcvides rules for rea\u00adsoning \ndirectly about ccmmands. In this regard , the system is similar to Dijkstra s calculus, [81. Unlike the \nStanford Pascal Verifier, and all other program verifiers we know, PL/CV does not employ a theorem prover. \nInstead arguments are checked by a Proof Checker. In this regard, the system is similar to AUTOMATH [71 \nand FOL [291. Although we have been particularly en\u00adcouraged by the success of AUTOMATH s methods, PL/CV \nuses a number of decision procedures and automatic rules which allow the user to take fairly large proof \nsteps. Unlike verifiers for Lisp [1] or variants such as Cartwright s Typed Lisp [2] and Milner s LCF \n[21], PL/CV is ~on\u00adcerned with procedural languages and their actions, e. g. assignment. The PL/CV log\u00adic \ndoes not consider its domains to be lattices or CPOs as in LCF. It deals directly with partial functions \nover in\u00adtegers and strings. However, in general philosophy, PL/CV is quite close to LCF and was directly \ninspired by it. Both systems present their logic in great de\u00adtail and are concerned with the structure \nof proofs. Both also provide powerful mechanisms for abbreviating proofs. LCF, unlike PL/CV, treats non-elementary \nforms of arguments, including the ability to formalize the metamathematics. We expect to draw heavily \nupon LCF when we attempt extend PL/CV. PL/CV is based on a constructive log\u00adic (all automatic rules are \nconstructive), though classical reasoning can be ex\u00adpressed by making explicit classical as\u00adsumptions. \nBut unlike other systems based on a IIconstructive method! in a quantifier free setting (e. g. Wegbreit \n[281), PL/CV uses the full predicate calculus. A full predicate calculus is fundamental tc our intention \nof providing a very expressive logic . Indeed , soon we will permit full constructive second order predicate \ncal\u00adculus. In the remainder of this paper we consider hcw these gc~als led to the PL/CV system, and we \nbriefly discuss what we have learned from using the system (there being much more to learn). The resulting \nlogic is simple enough that it has been used by undergraduates, yet it is suffi\u00adciently rich to permit \nthe serious study of the problems of computational reason\u00ading, program verification, and the design of \nunderstandable programming languages. 2. The Logic 2.1 The Form of Proofs The PL/CV logic can be viewed \nas an extension cf a natural deduction presenta\u00adtion of the predicate calculus that in\u00adcludes commands, \nand that takes the con\u00adcept of an argument, ri~ther than a formu\u00adla, as the central object. To understand \nthis viewpoint one must know how natural deduction style logics are organized. For each logical operator \nthere is a rule for introducing the operator into an argument and a rule for eliminating that operator. \nPrcofs are trees whose nodes are formulas; the rcot is the formula proved and the leaves are assumptions. \nFor example, let\u00adting &#38;, 1, and => denote and, or, and im\u00adplies , here is an informal proof of (alb \n=> c) => ((a=>c) &#38; (b=>c)): Assume (alb => c). Then a.>c, since if a is assumed, alb fellows immediately, \nand follcws frcm alb and the assumption that (a!b => c). Likewise, frcm b deduce alb and thence c, establishing \nb.>c. qed This argument would be formalized in logic books as the natural deduction tree in Figure 1. \nLines (1) and (6) are the main assumption. Notice the assumption is replicated each time it is needed \nfcr the application of an inference rule. Lines (2) and (7) are also assumptions. Frcm line (2), line \n(3) arises by introducing _ . .-. .__. .\u00ad assume ( dbsume (1) LEMMAI: [ al (2) (A!B=>C) => (A=>C)&#38;(B=>C) \nBY INTRO, (2) (7) ~ I (3) PROOF; / assume I assume I (4) ASSUME Pl: A~B => C; [(1) a! b=>c (3) alb 1(6) \nal b=>c (9) a~b (5) A => C BY INTRO, [ (6) PROOF ;i ? //!// (7) ASSUME A; I k (4) c (8) C (8) P2: AIB; \nI i (9) /i/ FROM PI AND P2 {// I -   -- \u00ad } (lo) QED; ; (5) a=> c (10) b i> C (11) B => C BY INTRO, \n(12) PROOF ; \\ / (13) ASSUME B; (11) (a=>c)&#38;(b=>c) (14) P3: A : B; (15) /#l FROM PI AND P3 #/ Q~D: \n; (16) (12) (al b=>c) => ((a=> c)&#38;(b=>c)) (17) QED; Figure 1 Figure 2 the operator, ~ , into line \n(2). Line (4) (A!B => C) => (A=>C) i? (B=~C) BY INTRO, PROOF ; follows by using line (3) to eliminate \nthe A=>C BY INTRO; implication operator, =>, from line (l). B=>C BY INTRO; QED; Line (5) introduces \n=>. The rule justify\u00ad ing line (5) requires the subargument, in Here are two ether PL/CV propositional \nar\u00ad dotted lines, which deduces c from the as- guments: sumptions a and alb.>c. At line (5), we Al(B&#38;C) \n=> (AIB) &#38; (A;C) IlassUme all at line (2) say the assumption BY INTRO, CASES, A~(B&#38;C); has been \ndischarged. (A=>B) => (-B => A) BY INTRO, INTRO, INTRO; In PL/CV, this two-dimensional tree structure \nis replaced by a linear It By The justification INTRO indi\u00adrepresentation of text. The linear form cates \nthat the main connective of the is rendered compact by eliminating redun\u00ad assertion will be introduced. \nIn the dant occurrences of lines in favor of rules second example, Al(B&#38;C) is implicitly as\u00adfor accessing \na line from a point in the sumed by tINTRO !. Frcm that assumption , proof. Morecver, the scopes of assump\u00ad \n(A!B) &#38; (AIC) can be prcved by a case tions and their intended order of elimina\u00ad analysis on Al (B&#38;C). \nIf A holds, fclear\u00adtion is made apparent by block structure. ly (AIB) &#38; (AIC); likewise if B&#38;C \nhclds. The PL/CV version of this argument is in The automatic reasoning invclved in Figure 2. The proof \nis complete without clearly is discussed in section 2.3. the lines in ccmment delimiters, /#, #/. (The \nline numbers are also not part cf the Notice that these sample PL/CV proofs proof) . The tree form has \nbeen replaced are similar tc their infcrmal ccunter\u00ad by a mere compact and readable representa- parts, \nyet they are completely fcrmal, and tion. The justification BY INTRO ! indi- have been checked by a machine. \ncates that the operator => will be 2.2 Accessibilityintroduced by the argument that follows. Much of \nthe above proof is redundant, and In an crdinary linear representation has been written out here for \nthe sake of of a prcof, every lexically previous line clarity. By making use of abbreviations is available \nas an hypothesis in subse\u00adand automatic rules, the lemma in Figure 2 quent deductions. But in a block \nstruc\u00adcan be proved as follows: tured proof, ncrmal sccpe rules apply, and 10 it is an error to refer \ninto proof blocks from outside them. For example, in the PL/CV proof of llLEMMAI!!, the assertion C is \nmade at line (9), but this assertion is clearly not accessible as a conclusion at line (17). Other restrictions \non accessi\u00adbility are necessary because commands are allowed in arguments. Some of these are discussed \nin section 3.3. 2.3 Automatic Rules and Proofs Certain rules correspond to steps of reasoning that most \npeople perform au\u00adtomatically in their heads. In PL/CV, there are three classes cf automatic rules: Propositional \nrules, Equality rules, and Normalizing rules. Except for => introduction, I elimination, contradic\u00adtion, \nand -introduction, all of the propo\u00adsitional rules are automatic. If all of the propositional rules were \nautomatic, the result would be a tautology checker. Since the tautology prcblem is ccNP\u00adcomplete, a limited \nset of automatic rules was settled upon. The algorithm used for checking propositional inferences follows \nPrawitz s normal form theorem for natural deduction [25]. The automatic equality rules in PL/CV ccmprise \nthe theory of equality with uninterpreted function s ym\u00adbols . The algcrithm used to decide this thecry \nis due tc Kczen [15], and Nelson and Oppen [231, and also Downey and Sethi [91. The Normalizing rules \nare the associ\u00adativity and ccmmutativity of certain pre\u00adpositional and arithmetic connective, and simple \narithmetic facts, such as the equivalence cf A<B and (A>=B) and arith\u00admetic manipulations cf ccnstants. \nNot all cf the automatic rules may be used in a single proof step. As discussed in Krafft [161, allcwing \nunrestricted combinations of these rules leads to exponential-space complete problems. The use of autcmatic \nrules and ether shcrthand notaticns for prcofs are the main methods used to condense proofs. A checker \nof both class~cal and intuitionis\u00adtic tautologies is available with PL/CV, but we have not found its \nuse necessary or even especially convenient . It is our claim that propositional arguments which we understand \nwell correspond to very short PL/CV proofs. Furthermore, any pro\u00adpositional reascning that we do not \nunder\u00adstand well should be spelled out as an aid to the reader, and not buried inside a time-consuming \ndecision procedure. 2.4 Rules for Commands Ccmmands are introduced into argu\u00adments and eliminated from \nthem, just as logical operations are. Thus , for each command there is an introduction and elim\u00adination \nrule. For example, the introduc\u00adtion rule for the DO-WHILE loop is the usual termination rule for loops. \nThe el\u00adimination rule corresponds to Hoare s WHILE rule. Here is a simplified (no loop-exits) version \nof the combination of the DO-WHILE introduction and DO-WHILE el\u00adimination rule: (1) {BEXP well-defined} \n (2) {SOME N FIXED ,. (N>=O &#38; T(N)} (3) {P} (4) DO WHILE(BEXP); (5) /*/ ARBITRARY N FIXED WHERE \nT(N); */ (6) /*/ ASSUME P; */ (7) <procf statements> (8) {-T(0)} (9) <lCCP bcdy>  (lo) {BEXP well-defined] \n(11) {T(N-1)1 (12) {P} (13) END; (14) P &#38; BEXP  The hypotheses of the introduction rule are lines \n(2), (5), (8), and (11). The variables of the body of the loop are related by T to a free variable that \nde\u00adcreases by one on each iteration of the lccp. Since the variables cannot be re\u00ad 11 lated to zero, \nthe loop must halt. The conclusion of the introduction rule is the loop itself: one introduces the 100P \nby proving it terminates. The hypotheses of the elimination rule are lines (3), (6), and (12). At lines \n(1) and (10), BEXP well-defined , is an assertion which guarantees that BEXP will evaluate without error, \nthat is, ar\u00adray subscripts are within bounds, and the arguments to each called function are within its \ndomain. Line (3) asserts that P, the loop invariant, holds before the loop execution begins. Line (6) \nis an in\u00adduction hypothesis. The induction step, that P holds after the execution of the loop body, must \nbe proved at (12). The conclusion is line (14). How this rule is checked by the Proof Checker is discussed \nin section 3. 2.5 A Short Example As an example of ho W the DO-WHILE rules are used in a program, Euclid \ns division algorithm, an obligatory !tbench\u00admark!! example, is shown in Figure 3. It is shown exactly \nas it is input into the Proof Checker. So that the same input may be used for both the compiler and the \nproof checker , all of the PL/CV proof statements are enclosed in special ccmment brackets. Other syntactic \nconventions which may not be immediately clear are that FIXED is the attribute used to indi\u00adcate integral \n(FIXED DECIMAL) values, and SOME and ALL are used for the existential and universal quantifiers. 2.6 \nA Longer Example The procedure FIND_MODE ccmputes the mcde of a one dimensional sorted array. The mode \nof an array is an element occur\u00adring most frequently. We define this prc\u00adperty in terms of a basic function \ncalled COUNT(X,A,L,H) which counts the number of occurrences of X in array A frcm index L < DIVIDE: PROCEDURE(A, \nB, Q, R); /* EUCLIDIS DIVISION ALGORITHM */ */; DECLARE (A, B) FIXED /*: READONLY DECLARE (Q, R) FIXED; \n/%/ ASSUME A>=o, B>O; */ /*/ ATTAIN A . j=j*Q+R, O<=R<B; */ /*/ A.B*O +ABy ARI fH; */ R=A; Q=O; /*/ \nSOME I FIXED . (1>=0 &#38; R<=I) %/ /s/ */ BY INTRO, R; DO WHILE(R-B >= O); /*/ ASSUME A . BMQ+R, R>=o; \n*/ /*/ ARBITRARY I FIXED WHERE R<=I %/ /*/ (R<=O) BY ARITH, R-B>=O, +, B>O; */ /*/ A = B*(Q+l) + (R-B) \n*/ /*/ BY ARITH, A=B*Q+R; */ /*/ R-B <= I-1 BY ARITH, R<=I, -B>O; */ R = R-B; Q=Q+I; END ; /*/ R<B By \nARITH, -(R_B >, 0), +, B.El; */ /*/ A . B*Q+R; ()<=R<B; */ RETURN ; END DIVIDE; Figure 3 to index H. \nA(I) is a mcde of A if COUNT (A(I),A,LOW,HIGH) is greater than or equal to COUNT (X,A,LOW,HIGH) for any \nX, where LOW and HIGH are the lCW and high bounds of the array A. In order to prcve the correctness of \nFIND MODE, we need four lemmas involving COUNT. These lemmas have been listed without proof just before \nthe program. The procfs of these lemmas in turn require several facts abcut COUNT. All cf these facts \nand lemmas have been proved, but the proofs are not included here. This example illustrates several features \nof PL/CV proofs. First, quantif\u00adiers and definitions are used extensively. A(*) The definition FOR FIXED \nDEFINE SEGREGATED(A) = . . . , for example, says that SEGREGATED is a property of cne di\u00admensional integer \narrays defined by the formula or asserticn after the equality. A second noteworthy feature cf the example \nis that the asserted prcgram FIND MODE uses another program, COUNT, in the proof NUMBER = O; DOI = LOWTOHIGH;text \nbut not in the program text. This IF X=A(I) THEN NUMBER = NUMBER+I; feature is used extensively in the \nproofs END; of the lemmas not shown, where various but ,in the proof, COUNT is called recur\u00admathematical \ntheorems are proved induc\u00ad tively and the recursive function rule is tively using DO-WHILE and DO-INDEX \nloops. used for the inductive proof. In the proof of the basic facts about COUNT, this mixing of program \nrules in Although readers not familiar with proofs is even more striking; COUNT is an PL/CV may have \ntrouble with some of the iterative function, essentially: notation used in the logic (such as ALLEL for \nthe name of the all elimination rule), we hope this example will be informative. *pROCESS COUNT: PROCEDURE \n(X,A,L,H) RETURNS(FIXED); DECLARE (X,A(*),L,H) FIXED; /*/  ASSUME l B; /# 1 B MEANS TRUE IN PL/I #/ \nATTAIN H < L => COUNT(X,A,L,H) = O, X = A(H) => COUNT(X,A,L,H) = COUNT (X,A,L,H-I)+I, X-= A(H) => COUNT(X,A,L,H) \n= COUNT(X,A,L,H-I), . (rest of COUNT omitted) END COUNT; *TfjEoREM /*/  /// DOM(A,I) SAYS THAT I BELONGS \nTO THE DOMAIN OF THE ARRAY A. #/ /1} THE DOMAIN OF AN ARRAY A IS THE INTERVAL FROM THE LOW BOUND OF A, \n#/ /# LBOUND(A, I), TO THE HIGH BOUND OF A, HBOUND(A, I). Ii/ //} (LBOUND AND HBOUND ARE BUILTIN PL/I \nFUNCTIONS). #/ FOR (A(*),I) FIXED DEFINE DOM(A,I) = LBOUND(A, I)<=I<=HBOUND(A, l); /# AN ARRAY IS SEGREGATED \nIF AND ONLY IF IDENTICAL ELEMENTS OCCUR #/ /# CONSECUTIVELY. #/ FOR A(*) FIXED DEFINE SEGREGATED(A) = \nALL (I,J,K) FIXED WHERE I<=J<=K &#38; DOM(A,I) &#38; DOM(A,K) &#38; A(I)=A(K) . A(J)=A(K); /# EXTENDING \nTHE INTERVAL COUNTED OVER BY ONE WILL INCREASE THE COUNT #/ /// BY ONE OR LEAVE IT THE SAME. #/ EXTEND \nCOUNT: ALL (X,A(*),U) FIXED WHERE U<=HBOUND(A, I) . COUNT(X, A, LBOUND(A,I), U-1) <= COUNT(X, A, LBOUND(A, \nI), U) <. COUNT(X, A, LBOUND(A,I), U-1)+1 BY . . . (proof emitted) /# IN A SEGREGATED ARRAY, IF A(I-L)-=A(I), \nTHEN THERE ARE NO MC)RE #/ /# THAN L OCCURRENCES OF A(I) UP TO I. #/ BLOCK UPPER: ALL (~(*),I,L) FIXED \nWHERE SEGREGATED(A) &#38; DOM(A,I) &#38; DOM(A,I-L) &#38; L>=O . ( A(I-L)-=A(I) => COUNT(A(I),A,LBOUND(A, \nI),I ) <= L ) BY... (prcof omitted) /# IN A SEGREGATED ARRAY, IF A(I-L)=A(I), THEN THERE ARE AT LEAST \nL+l #/ /1} OCCURRENCES OF A(I) IN A UP TO I. #/ BLOCK LOWER: ALL (~(*),I,L) FIXED WHERE SEGREGATED(A) \n&#38; DOM(A,I-L) &#38; DOM(A,I) &#38; L>=O . ( A(I-L)=A(I) => COUNT(A(I), A,LBOUND(A,l) ,1) >= L+l) \nBY . . . . (proof omitted) *PROCESS FIND MODE: PROCEDURE (MODE,A,L) ; DECL~RE A(*) FIXED /*: READONLY \nDECLARE (MODE,L) FIXED; /* L IS */; THE LENGTH OF MODE BLOCK */ /* /?4 /* /*/ /*/ /%/ /%/ /*/ /*/ ***%****** \nDEFINITIONS *%****%****%*%************* THE MODE OF AN ARRAY Is AN ELEMENT OCCURRING MANY TIMES As ANY \nOTHER ELEMENT. DEFINE Low . LBC)UND(A, I); DEFINE HIGH . H~ouND(A,l); FOR I FIXED DEFINE MODE BOUND(I). \nALL X FIXED . COUNT~X, A,LOW,I)<=L; FOR I FIXED DEFINE MODE TO(I)= COUNT(MODE, A,LOW,~-l)=L &#38; MODE_BOUND(I-l); \nAs */ */ */ */ */ */ */ */ */ /++ /i+/ /?+/ 3fS**iii+#+$** ASSUME AT j AIN PROGRAM SPECIFICATIONS SEGREGATED(A); \nMODE T()(HIGH+I); ****%*****%%%%%* */ */ ++/ DECLARE I FIXED; /!4 /* /* /)4 /* *?$**+$**+I** BODY OF \nTHE ARGUMENT *%***++***%%%%***** IN A SEGREGATED ARRAY, THE LENGTH OF A BLOCK OF cONSECUTIVE ELEMENTS \nIs THE NUMBER OF OCCURRENCES OF THAT ELEMENT. TO FIND THE MODE OF A, WE FIND THE LONGEST BLOCK OF CONSECUTIVE \nELEMENTSO */ */ */ %/ ?4/ /?4 /% *)3*++%*******% As THE BASIS BASIS STEP OF CASE OUR %%*%*S**%%*%%************% \nINDUCTIVE ARGIJMj7NT To */ */ /* FIND THE MOJ)E,CONSIDER THE VACUOUS CASE OF THE */ /* EMPTY ARRAY. THE \nLOOP INVARIANT HOLDS VACUOUSLY. */ L /*/ = O; () /* <= INITIALLY THERE () <= LOW-LOW: ARE NO BLOCKS */ \nLOW-1 < LOW; COUNT (MODE, A,LOW,LOW-I)=O ALL X FIXED . COUNT(X, A, PROOF ; COUNT(X, A, LOW, LOW-1) 0<=0; \nQED ; BY FUNCTION, COUNT(MODE,A,LOW, LOW, LOW-1 )<=0 BY INTRO, = O BY FUNCTION,COUNT(X, A, LOW-l); LOW, \nLOW-l); /l} LOOP INVARIANT HOLDS AT MODE TO(LOW) &#38; O<=L<=LOW-LOW; LOW #/ */ /% /+4 /* /* /* /* /% \n/* ?+*++**%****%* INDUCTIVE CASE %************************/ ASSUME WE HAVE THE MODE up To 1, THEN FIIJD \nTHE MODE up To 1+1 By LOOKING FOR THE LONGEST BLOCK USING THE Loop: DO I = LOW TO HIGH IF A(I-L)=A(I) \nTHEN DO; MODE=A(I); L=L+I; END; END; */ %/ */ */ */ */ %/ /% PROVE LOOP EXECUTES AT LEAST ONCE /*/ (HIGH<LOW) \nBY ARITH,LOW<=HIGH; LOOP: DO I = LBOUND(A, I) TO HBOUND(A, I) /* THE Loop INVARIANT IS THAT THE /* A \nUp TO I IS IN MODE. /* WE FIND THE MODE up To l+l. /*/ ASSUME MODE_T()(I) &#38; O<=L<=I-LC)W; BY 1; MODE \nOF */ */ */%/ */ %/ /* /* /*/ /%/ DOM(A, 1) Is PROVE DON(A, LOW<=I-L By I_L<=HIGH By A CONSEQUENCE OF \nI-L) ARITH, L<=I-LOW, ARITH, I<=HIGH, Do_INDEx RANGE +, Low_L=Low-L; _, L>=o; */ */ */ */ /*/ ATTAIN \nMODE_T()(I+l) &#38; o<= L<. (l+l)-Lo~; %/ IF A(I-L)=A(I) THEN DO; /*/ EXTEND BOUND:  ALL X FIXED . COUNT \n(X, A, LOW, I) <= L+l BY INTRO, PROOF ; Al: COUNT(X, A, LOW, I-I)<=L BY ALLEL, MODE BOUND(I-1), X; A2: \nCOUNT(X, A, LOW, I) <= COUNT(X, A, LOW, I-l)+l BY ALLEL, EXTEND COUNT, X, A, I; COUNT(X, A, LOW, I) <= \n~+1 BY ARITH, Al, A2; QED; Bl: COUNT(A(I), A,LOW,I)<=L+I BY ALLEL, EXTEND BOUND,A(I); B2: COUNT(A(I), \nA,LOW,I)>=L+l BY ALLEL,BLOCK LO~ER,A,I,L; COUNT(A(I ),A,LOW,I)=L+I BY ARITH,Bl,~2; 8/ /* A(I) Is THE \nMODE (JP To 1+10 */ /* L+l Is THE LENGTH OF THE MODE BLOCK up To 1+1 *,/ */ /*/ O <= L+l BY ARITH, O<=L; \n*,/ I*/ L+l <= (1+1)-LOW BY ARITH, L<=I-LOW; MODE = A(I); L = L+l;  /* THE INVARIANT HOLDS AT 1+1 *,/ \n/?+/ MODE T()(I+I); *,( /*/ () <= L <. (l+l)_LOW; * ,f END; ELSE  DO; /* NO MORE THAN L OCCURRENCES \nOF A(I) Up TO 1+1 */r /* THERE ARE L OCCURRENCES OF MODE, SO A(I) DOES */ /* NOT REpLACE MODE AND L DOES \nNOT CHANGE. */ /*/ A(I_L)-=A(I); */ /*/ EXTEND BOUND: ALL x TIXED . COUNT(X, A,LOW,I)<=L BY INTRO, PROOF \n; DISJ: X-=A(I) j X=A(I) BY ARITH; COUNT (X,A,LOW,I)<=L BY CASES,DISJ, PROOF ; CASE X-=A(I); COUNT (X, \nA,LOW,I)=COUNT(X, A,LOW,I-l) BY FUNCTION, COUNT(X,A,LOW,I) ; COUNT(X, A,LOW,I-I)<=L BY ALLEL, MODE_BOUND(I-l \n),X; COUNT (X,A,LOW,I)<=L; CASE X=A(I); COUNT (A(I),A,LOW,I)<=L BY ALLEL, BLOCK_UPPER, A,I,L; QED : QED; \n- Cl: COUNT(MODE, A, LOW, I-1) = L; /# FROM INVARIANT #/ C2: COUNT(MODE, A, LOW, I) >= COUNT(MODE, A, \nLOW, I-1) BY ALLEL, EXTEND COUNT, MODE, A, I; C3: COUNT(MODE, A, LOW, l) <= L BY ALL~L, EXTEND_BOUND, \nMODE; COUNT(MODE, A, LOW, I) = L BY ARITH, Cl, C2, C3; /# THE INVARIANT HOLDS AT 1+1 #/ MODE_TO(I+l) \n; L <= (1+1)-LOW BY ARITH, L<=I-LOW; O <= L <= (1+1)-LOW; */ END; END LOOP; END FIND MODE;  The Proof \nChecker 3.2 The Assertion Table 3.  I-=---l  3.1 Local Context Checker Above is a diagram of the PL/CV \nProof Checker. The asserted prcgram written by the user is processed by the Local Context Checker (LCC). \nThe LCC is responsible for checking all explicitly written applica\u00adtions of rules, producing error messages \nwhen rules are incorrectly applied. Most of the arithmetic reasoning in PL/CV con\u00adsists of applications \nof a powerful rule called ARITH. Hence, a large module of the LCC is a checker of arithmetic inferences. \nThe output of the LCC is known as V-code. V-code is essentially a condensation of the proof, containing \nonly the portion dealing with accessibility and automatic rules. It is checked by the V-code inter\u00adpreter. \nTo illustrate the interaction of the LCC and the V-code interpreter, consider the following line from \nan asserted pro\u00adgram: A+B < C+D BY ARITH, A<C, +, B<=D; The LCC checks that A+B < C+D is indeed a consequence \nof A<C and B<.D. It then gen\u00aderates the following V-code: REQUIRE A<C REQUIRE B<=D PROCLAIM A+B < C+D \n When the V-code interpreter encounters the above instructions , it checks to see that previous instructions \nhave guaranteed that A<C and B<.D, and informs succeeding in\u00ad structions that A+B < C+D. The primary \ndata structure of the V\u00adcode interpreter is the Assertion Table (AT). At each point in the processing \nof the V-code, the AT contains a collection S of all assertions which have been proved . Each V-code \ninstruction specifies scme kind of manipulation on the AT. The V\u00adccde instructions, and the actions they \nspecify are: Instruction Acticn PROCLAIM P Add P to S. REQUIRE P Test to see that P is in S, or is deducible, \nusing au\u00adtomatic rules, from the assertions in S. If not, print an error message. NEW V Create a new \nvariable, V , and replace every occurence ofVin SbyV . OPEN Make a copy of S, pushing it onto a stack. \nCLOSE Restore S from the top Cf the stack, and pop the stack. The instructions are net all implemented \nas described above, but the implementation behaves as though they were.  3.3 V-code Generation The LCC \nis very similar tc a com\u00adpiler, the difference being that V-code, net object code is produced. As an \nexam\u00adple of the type of processing performed, here is a description cf the V-code gen\u00aderated for the \nDO-WHILE rule given in sec\u00adticn 2.3. Lines (1 to 3) translate to RE-QUIRES . Line (4) generates an OPEN \nin\u00adstruction , with the corresponding CLOSE at line (13). These instructions guarantee that assertions \nproved in the bcdy of the lcop will not be used by procf statements after the lccp, which would be a \nviclaticn of accessibility restrictions. Lines (5 to 6) translate into PROCLAIMs of T and P. The procf \nstatements at line (7) are parsed, and appropriate V-code is generat-has been seen, PL/C V has been \nimplemented ed. These statements may be needed if the proof of line (8), which is translated into a REQUIRE, \ninvolves non-automatic rules. At line (9), the body of the loop is parsed , and corresponding V-code \nis generated. Lines (11 to 12) result in RE- QUIRES , and line (14) results in a PR O-CLAIM. Not mentioned \nabove are the NEW in\u00adstructions that are also generated. A NEW instruction is generated by any statement \nthat can change the value of a variable. For example, in the following intended proof: (1) IF (X >10) \n (2) THEN DO; [~] /*/ ~>~ B:OARITH, X>IO; */  /*/ x-:  (5) -10 BY ARITH, X>5; */  The assertion \non line (5) is incorrect, because X is set to -10 by the assignment statement at line (4). Line (3) will \ncause X>5 to be PROCLAIMed, but the RE- QUIRE X>5 generated by line (5) will fail, because the NEW X \ngenerated by line (4) will cause the occurence of X>5 in the assertion table to be changed into X >5. \nIn the DO-WHILE rule, a NEW instruc\u00adtion for every variable that could possi\u00adbly be modified by the body \nof the loop must be inserted just before the OPEN in\u00adstruction generated by line (4). The NEW instruction \nis needed to prevent asser\u00adtions about the state of variables before the execution of the loop from being \nreferenced by proof statements in or after the body of the loop, since those asser\u00adtions are invalidated \nby an execution of the body of the loop. Such references would be violations of accessibility res\u00ad trictions. \nWere it not for these NEW in\u00adstructions (and some forward-referencing problems with procedures and functions), \nthe V-code could be interpreted as it is generated. Since the NEWS cannot be in\u00ad serted until after the \nentire loop body as a two-pass system. 3.4 Particulars PL/CV has been implemented on an IBM 370/168 \nusing the CMS operating system. PL/CV contains a large subset of PL/1, in\u00adcluding assignment, if, do-while, \ndo\u00aduntil, do-index, fcrward goto , return , select, and leave statements, multidimen\u00adsional arrays, recursive \nfunctions and procedures, and external variables. The proof checker was written in PL/I , and contains \nabout thirteen thousand lines. For a typical three-page proof, the pro\u00adgram uses about 550K bytes of \nstorage, of which about lOOK is data area. Asserted programs are usually checked at a speed of about \ntwenty lines per second, although on some examples it has run as slowly as five lines per second. Some \nof this sluggish\u00adness is due to the high overhead encoun\u00adtered when using PL/I on the IBM 370. 4. Conclusions \n4.1 Benefits of a Unified Approach One advantage of the PL/CV logic is that it presents reasoning about \nprograms as a un i form extension of ordinary mathematical reasoning. For example, the approach reveals \nthat the rules for pass\u00ading parameters to procedures are simply special cases of substitution for free \nand bound variables. The rule of substitution for free variables requires that a term t be free for the \nvariable it is replacing. Thus , in the existentially quantified for\u00admula ;Y. (Y > X), the term Z+2 is \nfree for ~, SOJY. (Y > Z+2) is valid, but the term Y+2 is not free for X because its meaning changes \nupon substitution. That . is, in the formula ~! Y . (Y > Y+2), the quantifier has captured a Y. Similarly, \nconsider a procedure with an EXTERNAL (global) variable: ASSIGN: PROCEDURE(Y); DECLARE Y FIXED; DECLARE \nX FIXED EXTERNAL; /S/ ASSUME y > (); */ /*/ ATTAIN x . y _ 1; ?+/ X= Y-I; RETURN; END ASSIGN; But in \nelementary number theory, these im\u00adprovements are not necessary, and we ex\u00adpect most of them to become \nspecial cases of a systematic extension of the system to non-elementary reasoning, e. g. to higher order \npredicate calculus and metamathema\u00ad the variable X is a bound variable, bound tical reasoning. by the \nsubstitution capture sion X = assignment ASSIGN(X) which explains X -1. x = Y -1. Thus, the causes an \nillegal the absurd conclu\u00ad current deal arrays In with contrast to number theory, system is unwieldy \nwhen programs that extensively while maintaining complex the it must modify quanti\u00ad 4.2 Lessons from \nExperience fied invariants about them. The difficul\u00ad theory April We have and 1978. been using PL/CV \nin number the predicate calculus since We have verified dozens of ty the part thesis is that invariants \narray must be of the array research, about every reproved whenever is modified. Scott Johnson part In \nof an y his has small several (under moderate 50 size lines) (100 to examples 200 and lines) discovered \nthat overcomes a much the more useable difficulties array so far rule un\u00ad examples. checking including \nWe have algorithmic fundamental Since July 1978, we have been programming arguments as well, large examples \n(over 300 lines). developed a substantial piece of number theory including the theorem of arithmetic. \ncovered. We will incorporate the new ar\u00adray rule in the next versicn of the Procf Checker because, unlike \nthe other improve\u00adments mentioned, this one is essential to manage many ordinary programming problems. \nThe formalization of elementary number theory and algorithmic number theory is remarkably direct and \nappealing. Formal proofs are congruent to their in\u00adformal counterparts, and only four to six times longer. \nAlthough we have discovered ways to significantly condense arguments by providing higher level rules, \nsuch pro\u00adposed improvements are not overwhelmingly necessary or seductive. For example, spe\u00adcial cases \nof the following general prin\u00adciple frequently arise: Experience with PL/CV has demonstrat\u00aded the extent \nto which even the simplest arguments about programs rely on an exten\u00adsive inventory of previously proved \nfacts. Early work has required formalization of a large number of obvious ! lemmas. We are learning a \ngreat deal about the problem cf providing appropriate mechanisms (scope rules, collections cf theorems, \netc.) for using the information from these theories. By critically examining a large number of arguments, \nwe expect to discover which non-elementary principles of reasoning (ALL (ALL X X WHERE WHERE I<=X<=I \nI<=X<=I+I . P(X)) . P(X)) &#38; P(I+I) => w,i11 of the be most implemented beneficial. system Continuing \nand attempts use to A general rule of this form would be con\u00ad formalize non-elementary arguments are \nvenient, but would save only about six . both essential in learning how to provide lines of proof per \napplication. a more pcwerful programming lcgic. The We have also discovered schemes that could be made \nnew rules, just as the DO I is a seperate form of the common proof into seperate . 1 TO N loop DO WHILE \nloop. current system is evidence discovery process succeeds; vast improvement over PL/CVl. not only a \ncomplex research is also a valuable instructional that this PL/CV2 is a PL/CV2 is tool, but it aid. If \n we succeed to the same extent with non- Automatic Demonstration Lecture Notes elementary arguments, \nwe will produce a in NY, Math, 29-61, Vol. 1970. 125, Springer-Verlag, valuable programming aid. In \napproaching such arguments, we expect to learn a great 8. Dijkstra, Programming, Edsger W. A Prentic~-Hall, \nDiscipline Englewo~ of deal from AUTOMATH and LCF, which we can Cliffs, 1976, 217 pg. combine with our \nown unique experience. 9. Downey, Peter J and Ravi Sethi . Variations on the common subexpres\u00ad sion problem \nJACM, to appear. ACKNOWLEGEMENTS 10. Floyd, Robert W. Assigning meaning to We would like to acknowledge \nthe exc\u00ad programs, Applied Proceedings Mathematics, of VoT~ Symposia in XIX, Amer~ ellent and invaluable \nassistance of Tat\u00ad can Mathematics~ciety, Providence, Hung Chan, Dean B. Krafft, and Daniel R. 1967, \n19-32. Zlatin in implementing PL/CV2. Michael J. 11. Hoare , C.A.R. An Axiomatic Basis for OtDonnell \nis a principal designer of Computer October Programming, 1969, 5 76-581. Comm. ACM 12 PL/CVl and the \nlogic on which PL/CV2 is based [4]. Moreover, he and Tat-Hung Chan 12. Hoare, Axiomatic C.A.R. and Definition \nNiklaus of Wirth. the Pro~ram- An are responsible for the elegant arithmetic ming Language Pascal, Acts \npackage. We also appreciate the advice Informatica, 2, 1973, 333-355. offered by Corky Cartwright, Carl \nHauser, 13. Igarasshi, Shigeru, R. L. London , and Gary Levin. D.C. rification Luckham. I: Automatic \nA Logical Program Basis and Ve\u00adis Implementation, Act; Informatica, 4, 1975, 145-182. REFERENCES 14. \nKleene, S. C. Introduction to Metamathematics, D. Van Nostran~ 1. Boyer, R. S. and Moore, J. S. Prov- \nPrinceton, 1952, 550 pg. ing theorems about LISP functions. JA?M , vol. 22, 1, January 1975; 15. Kozen \n, Dexter C. Complexity of 129-144. Finitely Presented Algebras, Ph.~ Thesis, Cornell ~versity, Computer \n2. Cartwright, Robert S. User defined Science Dept., 1977. data tvDes as an aid to verifvin~ Lisp pr~grams, \nProceedings of T~ir~ 16. Krafft, Dean B. The Assertion Table International Conference on fitomata, System \nfor the PL/CV2 Program Verif- Programming Languages,  Edinburgh ier, Technical Report 78-337, Comput- \nPress, Edinburgh, 1976, 228-256. er Science Dept., Cornell University, 1978. 3. Chan, Tat-Hung. An Algorithm \nfor Checking PL/CV Arithmetic Inferences, 17. Luckham, David C. Program Verifica- Technical Report 77-326, \nComputer tion and Verification Oriented Pro- Science Dept., Cornell University, gramming, Information \nProcessing 77, 1977. B. Gilchrist ~. IFIP, North- Holland, 1977, 7[33-794. 4. Constable, R. L. and M. \nJ. O Donnell. ~ Programming Logic Winthrop, Cam\u00ad 18. Manna, Zohar. Mathematical Theory of bridge, 1978, \n389PP. Computation, ~A-aw Hill, New YorE 7974, 448P. 5. Con way, Richard W. A Primer on Disciplined Programmi~g \nUsing PL/~ 19. Manna, Z. and R. J. Waldinger. PL/CS , and PL/CT , Winth~ -Cam- Studies in Automatic \nProgramming =i~e, ~8, 419PP. Logic , N~th-~olland , Amsterdam, 1977. 6. Con way, Richard, D. Gries. An \nIntroduction Tc Programming, ~ 20. McCarthy, John. Computer Programs for Structured Appr~ch Using PL/I \nand Checking Mathematical Proofs , PL/C-7.7 , Second Ed i~~ Winthrop,  Proceedings of Symposia in Pure \n~mbrldge, Mass., 19 75, 509 pg. Mathematics, ~MS, Providen~, 1~ 219-228. 7. deBruijn, N. G. The Mathematical \nLanguage AUTOMATH, its usage and , 21. Milner, Robin. Implementation and some of its extensions, Symposium \non applications of Scott s Log ic for 22. 23. 24. 25. 26. 27. 28. 29.  Computable Functions, \n~roceedings of ACM Conference on Proving Assertio~ . about Programs, ~s Cruces, New Mexi\u00ad co , 1972, \n1-6. Milner, R., F. L. Morris, and M. A. Newney. A logic for computable func\u00adtions with reflexive and \npolymorphic types, LCF Report No. 1, Department of Computer Science, University of Edinghburgh, January \n1975. Nelson , C.G. and D. C. Oppen. A sim\u00adplifier based on efficient decision algorithms, Conference \nRecord of the Fifth Annual ACM Sympositi on . . miples of Programming Language= ACM, NY, 19773, 141-150. \n Pratt , Vaughan R. Semantical Con\u00ad sideration -on Floyd-Hoare Logic, Proceedings of 17th Annual Symposium \n on Foundati~s of Computer Science, ~uston , October ~76, 109-121. Prawitz, D. Natural Deduction Alm\u00ad \nquist &#38; Wiksell, Stockholm, 1965. Schwartz, J. T. Correct-Program Technology, Courant Computer \nScience Report #12, Courant Institute of Mathematical Sciences, New York University, September 1977. \n Scott, Dana. Data Types as Lattices, SIAM Journal ~ Computing, 5, 3, Sep\u00ad tember 1976. Wegbreit, Ben. \nConstructive Methods in Program Verification , IEEE Transactions on Software Engineer= SE-3, e, May \n~77, 193-209. Weyhrauch, Richard W. A Users Manual for FOL, Report No. STAN-CS-77-432, Computer Science \nDept. , Stanford University, July 1977, 68 pg.   \n\t\t\t", "proc_id": "567752", "abstract": "PL/CV is a new formal system which mixes commands and assertions. It includes axioms and rules for a theory of programming over integers and characters. Since arguments in the theory can be checked by the PL/CV Proof Checker, the system offers an approach to mechanical program verification. The Proof Checker is efficient enough for classroom use. Early experience with PL/CV indicates that it nicely supports formal verification of elementary arguments. Continued work should enable the formalization of non-elementary reasoning as well.", "authors": [{"name": "Robert L. Constable", "author_profile_id": "81100501262", "affiliation": "Cornell University, Ithaca, NY", "person_id": "PP14175048", "email_address": "", "orcid_id": ""}, {"name": "Scott D. Johnson", "author_profile_id": "81100449572", "affiliation": "Cornell University, Ithaca, NY", "person_id": "PP14157952", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/567752.567754", "year": "1979", "article_id": "567754", "conference": "POPL", "title": "A PL/CV precis", "url": "http://dl.acm.org/citation.cfm?id=567754"}