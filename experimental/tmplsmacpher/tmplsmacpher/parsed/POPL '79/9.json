{"article_publication_date": "01-01-1979", "fulltext": "\n Permission to make digital or hard copies of part or all of this work or personal or classroom use is \ngranted without fee provided that copies are not made or distributed for profit or commercial advantage \nand that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, \nto post on servers, or to redistribute to lists, requires prior specific permission and/or a fee.&#38;#169; \n1979 ACM 0-12345-678-9 $5.00 THE LOGIC OF A RELATIONAL DATA MANIPULATION LANGUAGE Marco A. Casanova* \nand Philip A. Bernstein** Aiken Computation Laboratory Harvard University Cambridge, MA 02138 ABSTRACT \nA logic for a relational data manipulation language is defined by augmenting a known logic of programs \nwith rules for two new state\u00adments: the relational assignment, which assign a relational expression to \na relation, and the random tuple selection, which extracts an arbitrary tuple from a relation. The usual \noperations on relations-retriever insert, delete, update-are then defined as special cases of the relational \nassignment, and the for-each construct scanning a relation tuple by tuple is introduced with the help \nof the random tuple selection. 1. Introduction A database contains data that models some aspect of the \nworld. The description of a database consists of a set of data structure descriptions and a set of consistency \ncriteria for data values. To say that the data values in a database satisfy the consistency criteria \nis to say that the data adequately models the world. As a consequence, users expect to observe consistent \ndata and are re\u00adquired to submit updates that will preserve con\u00adsistency. Such updates are called transactions \n[ES2] . Most of the work concerned with the correct\u00adness of multi-user database systems [BE1,ES2,LA2, \nPA1,ST1,TH1] assumes that only transactions access the database and curb the interaction among trans \nactions by a general correctness criterion. HOW\u00adever, we know of no attempt to provide a data manipulation \nlanguage (DML) with a logic permit\u00adting us to prove that a transaction indeed pre\u00adserves consistency, \nor that a set of transactions executed concurrently is correct. A DML logic becomes especially important \nwhen the set of trans\u00adactions is known in advance, as the general correctness criterion can be tailored \nto the application in question and verified beforehand [LA21 . Examples of such database applications \nare credit card verification, airline and hotel reserva\u00adtion, point-of-sale inventory control and electronic \nfunds transfer [BE2]. We will investigate in this paper the logic of a (sequential) data manipulation \nlanguagej in the future, we plan to embed it in a general parallel language in the manner of [OW1]. We \nview our work as the first step towards studying the correctness of database applications such as those \nquoted above. To support our DML logic, we start by selecting a framework that is adequate to describe \ndatabases and that has a reasonable underlying logic. In fact, we will argue that the Relational Model \n[C02] is so close to Predicate Calculus that the former can be subsumed by the latter [cA1,MI1,NI1,VA1]. \nHence, the question of the underlying logic is solved gratuitously. As for the, DML logic, we will augment \na known logic of programs, Dynamic Logic [PRl], with rules for two new statements: the ?e~ationa~ assignment, \nassigning a relational expression to a relation, and the random tuple selection, extracting an arbitrary \ntuple from a relation. The familiar operations [cH1,co1,HE1,LAII --retrieve, insert, delete, update\u00ad-will \nbe defined as special cases of the relational assignment. The for-each construct of [SC1] will also be \ngiven a translational definition. We finally note that our commitment to Dynamic Logic is not essential, \nand our results should be translatable to any .Logic of (non-determini stic) programs. 2. A Iogic for \nData of Type Relation As mentioned in the Introduction, we choose the Relational Model [C02] as our framework \nfor de\u00adscribing databases mainly because it can be assimi\u00adlated into Predicate Calculus. By assimilated \nwe mean that the key notions of the former can be re\u00adphrased as some of the very basic concepts of the \nlatter (see Fig. 1). The similarities between the Relational Model and Predicate Calculus have profi\u00adtably \nbeen used before [cA1,MI1,VALI, but the iden\u00adtification of relational schema and first-order theories, \nalthough clear, appeared only recently (and independently) [NIII. To substantiate the claims of Fig. \n1, let us first review some concepts. In the Relational Model, stored data is viewed as relations (unordered \ntables) and is described by relation schemes giving names to the tables and their columns. An integrity \nasser+ion then becomes a relational expression written in some appropriate language. A relational schema \nR is a set of relation schemes and a set of * Research supported by the Conselho National de Pesquisas, \nCNPq~Brasil , Grant 1112.1248/76. ** Research supported by the National Science Foundation under Grant \nMCS-77-05314. integrity assertions. If a set S of relations, one for each relation scheme of R, satisfies \nall integrity assertions, then S is called a con\u00ad sistent database state of R. FIGURE 1 1. Relational \nModel 2. schema 2.1 attribute name 2.2 relation name 2.3 integrity assertion 3. consistent state \n 3.1 union of underlying domains 3.2 relation extension 1. Predicate Calculus 2. theory 2.1 standard \nunary predicate symbol 2.2 non-standard predicate symbol 2.3 non-logical axiom 3. model  3.1 domain \n3.2 relation Hence, we have paved the way to the following definition: DEFINITION 2.1. A first order \ntheory T= (LT,DT) is called a re~ationa~ schema iff (i) LT, the set of non-logical symbols of T, includes \na finite set of predicate symbols Ri ~Pki (l~i<m) and Aj~lF1 (l~j~n); (ii) the non-logical axioms of \nT, includes T for each Ri exactly one axiom of the form (where ( l:iP~n) k, VX1 . . . Vxk, Ri(xl, . \n. ..xk. )*A~ Ai (X ) 1 Ip=l ) P Moreover, we say that: Ri is a database relation name and is an j att~ibute \nnome (l<i<m; l<j<n); .--\u00ad the special axiom for Ri is the relation scheme (which we abbreviate Ri[Ail, \n.--,Aiki]); of Ri IEDT is an integrity assertion; a model s of T is a consistent database state. 0 However, \nnot all integrity assertions can be translated as axioms. The so-called dynamic inte\u00adgrity assertions \n[ES1,HA1] impose restrictions on the possible state transitions of the database, rather than on the set \nof acceptable states. A well-known example is: (1) the salary of each employee listed in table EMP must \nbe non-decreasing. In [ES1], the prefixes NEW-r and OLD , as in NEW-EMP and OLD-EMP, were proposed to \nindicate which state must provide the value of EMP. We do not judge this approach elegant because it \nalters the definition of interpretation from Predicate Calculus in a fundamental way. Therefore, we pro\u00adpose \na novel rewrite for dynamic integrity assertions, using pairs of formulae, that avoids this problem. \n(1) is then rewritten as follows: (2) (VeVs(EMPo(e,s) ~EMP(e,s)), de Vsb s (EMP(e,s) AEMPo(e,s )*s> s \n)) where EMPO is a defined predicate symbol whose sole purpose is to freeze the value of EMP in the initial \nstate (that is, EMPO plays the role of OLD-EMP). We then define the notion of schema with dynamic integrity \nassertions as follows: DEFINITION 2.2. A triple T= (LT,DT,D+) is called a relatiowl schema with dynamic \nintegrity assertions iff (i) (LT,DT) is a relational schema; (ii) D+ is a finite set of pairs of formulae \nof LT, the dynamic integrity assertions. The role of relational schemas WI1l become clear later on when \nwe discuss the notion of trans\u00adaction. For the time being, it suffices to remember that stored data is \nviewed as relations. Finally, we introduce the notion of a key of a relation: DEFINITION 2.3. Let = \n LT DT) be a re\u00ad lational schema and Ri[Ail, . . ..Aiki] be the relation scheme of RigLT. A key of Ri \nis a set kC[l,ki] such that l-TVIV~R~)AR(~)A~ Xj=Yj-;=i () j Ek where ;={xl, . . ..xk. =}, ;= {Ylr. \n..rYki}. In words, the value of Ri at any consistent database state of T must be a relation such that \nif two tuples agree on the coordinates m k, they are equal. Note that we allow subsets of k to be themselves \nkeys of Ri. Hence, our definition, although sufficient for our purposes, differs from that in [c02]. \n3. A Logic for a Data Manipulation Language Our efforts in this section are directed towards defining \na DML logic by augmenting Dynamic Logic [PR1] with rules for two new statements--the relational assignment \nand the random tuple selection. The logic thus obtained w~ll be called Relational Dynamic Logic (RDL) \n. In $3.1 we discuss the overall architecture of RDL and then proceed to Introduce the two new state\u00adments \nin $$3,2 and 3.3. 3.1 The Architecture of Relational Dynamic Logic Let DL[LE,LA,DA,U] be the Dynamic \nLogic over and U (see Appendix I). We assume E, AJ A that there is a set of d~stinguished predicate symbols \nof LE, LR, the stored relation names. We construct RDL by adding two new statements to DL, the relational \nassignment and the random tuple selectlon, together with their corresponding axioms, as discussed in \n~~3.2 and 3.3. To stress the para\u00admeters of Relational Dynamic Logic, we write RDL[LR,LE,LA,DA,U] . We \nsay that RDL[LR,LE,LA,DA,U] has an adequate universe iff (i) for any variable x of $ and any An example \nmay clarify the construction of Q:: individual a EVU, there is a state 16U such that xl=a; (ii) for anybinary \nstored relation name REIPn and any binary relation u, there is a state R* c Vn I~U such that R1=R*. The \nmotivation for this concept follows closely the note in Appendix I and will become clearw hen we discuss \nrelational assignments. Finally, we say that a schema T=<LT,DT> is a schema of RDL iff LT coincides with \nL$A, the database relation names and attribute names of T are stored relation names, and the underlying \ndeductive system of T is DA. Similarly, we define a dynamic schema of RDL. 3.2 The Relational Assignment \nExamples of relational assignments, using the relation schemes BOOKS IISBN,EDITOR,AUTHOR,TITLE] and WRITERS \nINAME,CITY], are: (1) BOOKSl(a,t) := Zi3e(BOOKS (i,e,a,t) AWRITERS(a, PISA )) that retrieves into BOOKS1 \nauthors and titles of all books written by Piss citizens; (2) WRITERS(n,c) := 3c (WRITERS(n,c ) A (n+ \nGALILEI +c!= c ) A (n= GALILEI +c= PADUA )) that updates the city listed with Galilei to Padua. Likewise, \nwe could give examples of insertions and deletions written as relational assignments. Thus , we achieve \na certain economy by adding the relational assignment to DL, as just one statement suffices to describe \nthe operations commonly pro\u00advided by existing relational DMLs [CH1,CO1,HE1, LAII (i.e., retrieve, insert, \ndelete and update). Our approach to the relational operations iS further justified by the simplicity \nof the relational assignment: DEFINITION 3.1. Formation Rules for the Relational Assignment. R(=) :=A[lI \n={(I,J) 6u2/ I ~JA(V~CV~)(RJ(=) iff I ~ A[~/~1)} is called a relational assigment of RDL[LR,LE,LA, DA,U~, \nwhere R is an n-ary predicate symbol of LR, X={X~, . . ..Xn} is a set of distinct variables of LE, and \nA[X] is an open Wff of E With free variables xiEZ. 0 Hence, (I,J) is in the binary relation associated \nwith iff I and J tR(~) := A[~] !! differ only on R and RJ consists of those tuples =Ev: such that, when \nZ IS given 5 as value, A becomes valid in I. The central result about relational assignments goes as \nfollows: THEOREM 3.1. Suppose that RDL[LR,LE,LA,DA,U] has an adequate universe. Then, for any wff q of \nLA, ~u [R(x) := A[x] ]Q 0 Q: where Q: denotes the Wff of XA obtained by replacing each atomic formula \nin Q of the form R(tl,. ..,tn) by A [tl/X~,..., tn/xn] , where A IS a variant of A created by renaming \nbound variables of A that also occur. in Q. R (3) s= BOOKSl(a,t) := 3i3e(BOOKS (i-,e,a,t) AWRITERS(a, \nPADUA ))  (4) Q~qi(BOOKSl ( GALILEE ,i) AINDEX-PROHIBITORUM(i)) (5) [s]Q~~i (2i qe(BOOKS(i ,e, GALILEI \n,i) AWRITERS ( GALILEE , PADUA )) AINDEX-PROHIBITORUM (i))  Calling A the right-hand side of s, the \nequivalence in (5) is obtained by replacing BOOKS1( GALILEI ,i) in Q by A [ GALILEI /a,i\\t], where A \nis created by renaming i in A by i (avoiding conflict with the use of i in Q). The usual relational operations \nare defined as follows: DEFINITION 3.2. Relational Operations. (a) retPieve R(Z) 2J? 2ere A[~l R(;) \n:= A[~l , where R does not occur in A  (b) insert R(;) tikere A[=I = R(X) :=R(~) vA[=I (c) deZete R(z) \ntikere A[=I = Fi(~) :=R(~) A-A[~] (d) update R(~(;)) wkere A[;I = R(;) := ~~(R(j) A (=A[~]*==~) A (A[~l+~= \n=(~))) .  0 The translation of the update, the only non\u00adtrivial one, should be read as follows (where \nR is the relation name affected in a transition from I to J): (6) fm eack t~ple ?I in RI do if Y1 does \nnot satisfy A tken add ~1 _to Rj; ebe add ~l(yl) to Rj; 3.3 The Random Tuple Selection and the For-each \nConstruct The purpose of introducing the random tuple selection is confined almost entirely to the defi\u00adnition \nof the for-each construe-t, the main theme of this section. The for-each construct has the same flavor \nas the synonymous construct of [SCII: (1) for each WRITERS(a,c) where c= USA key NAME do .:=0; for each \nBOOKS(i ,e ,a ,t )tihePe a =akey ISBN do n:=n+l end; if .>10 then dispZay a; end that only displays American \nauthors with more than 10 books published. In terms c$ a loose ALGOL with the relational assignment, \nthe for-each construct is defined as follows: (2) for each R(=) where A[~] key Kdo s end = A. Ro(~) := \nfake ARo(;) ; B. R (~) := R(~) AA[?); C. uzzZe 37(R ~-(y)) do D. begin RAND MTUPLE (~iz); E. ~(;) :=~(y)vy \n=x; F. s; G. RT(~) := R(j) AA[~] A-3~(Ro(~) A~[K] =~[K]); end where ;= {xl,..., ~} is a set (of distinct \nvariables of K encodes ,3 key of R; and ~ and ~ are E; auxiliary <predicate symbols of LR. The definition \nof the for-each sketched above can be explained as follows: A. the set of tuples already scanned is the \nvalue of ~ (equal to @ initially); B. the set of tuples eligible for scanning comprises the value of \n~ (equal to the set of tuples in the initial value of R and satisfying A, initially) ; c. the loop will \nterminate when all tuples have been scanned. D. a random tuple is selected from those not yet scanned, \nhence giving the system freedom for implementing the scanning operation; E. the tuple selected above \nis added to the value ofR.  o F. s is executed; G. as s can modify the value of R, we have to recompute \nthe set of tuples not yet scanned. This is done with the help of the key K as follows: a tuple in the \ncurrent value of R iS eligible for scanning if it satisfies A and, moreover, its key value does not match \nthat of any tuple already scanned (hence the third conjunct in G). In order to express (2) in DL, we \nneed the relational assignment, which we already have, tests over quantified wff s, which are readily \nobtained, and a new statement, the random tuple selection, defined as: DEFINITION 3.3. Formation Rule \nfor the Random Tuple Selection. RANDOMTUPLE( R;~) ={(I,J) EU2/I~JAR1(;J)} x is called a random tuple \nselection of RDL[LR,LE, LA,DA,U], where R is an n-ary predicate symbol of LR and X= {xl,... ,xn } are \ndistinct variables of 0 E Hence, (I,J) is in the binary relation associated with RANDOMTUPLE(R;~) iff \nI and J differ only on ;, and ~J comes from RI. The central result about the random tuple selection goes \nas follows: THEOREM 3.2. Suppose that RDL(LR,LE,LA,DA,U] has an adequate universe. Thenr for any wff \nQ of LA, ~u[RANDOMTUPLE (R; Z)l Q= Vi2(R(=)+Q). 0 We emphasize that the random tuple selection is in \nitself uninteresting, but it gives precision to the definition of the for each construct sketched in \n(2) . DEFINITION 3.4. The for-each Construct for eaeh R(;) whe~e A[x] keu Kdo s end = ~(y) :=fa2se A~(Y); \nRT(~) :=R(~) AA[7]; (dy(~(j?) ?; RANDOMTUPLE( R.;;); ? is called a for-each construct of RDL[LRrLE,LA,DA, \nand ~ are n-ary predicate Ulr where R? % sYmbOIS in LR (R. and ~ are chosen anew for the translation \nof each for-each construct occurring in a program) , z={xl, . . ..xn } are distinct variables of LE, \nA[~] is a wff of with free variables XiC%, Kc{l, . . . ,n} is aL~On-minimal key of R, s is a statement \nof RDL. 0 Although no special rule for reasoning about the for-each construct is needed, an induction \nrule on the number of tuples already scanned has been found useful [CA2]. The basic idea lies in intro\u00adducing \nan invariant with certain properties in order to hide the translation contained in Defini\u00adtion 3.4. With \nsuch a rule one can prove, for instance, that p-[w]Q, where: (3) P= true Q = di Va dt (BOOKSo(i , SPRINGER \n,a ,t ) = BOOKS(lOi , SPRINGER ,a ,t )) w = for each BOOK(i,eJart) key EDITOR,AUTHOR, TITLE do if e= \nSPRINGER then update BOOKS (lOi ,e ,a ,t ) where i =iAe =eAa = a A t =t; end using as inductive assertion: \n(4) I = Vi da d(B OOKSo(i (, SPRINGERER ,a ,t ) -BOOKS(lOi , SPRINGER ,a rt )) The rule we have in mind \nis stated below. THEOREM 3.3. Suppose that RDL[LR,LE,LA,DA,U] has an adequate universe. Then Rule FE \nstated below is valid in U (FE) 1. -@;(Ro(j)) AP+I, 2. R(~) AA[; ]AI +[s]I,  V;(R(;)AA[;l-31(Ro(~)A \nA Yi=Xi))AI+Q , (-,. P+[w]Q where R,RO are predicate symbols in LR, as in Definition 3.4, P is a wff \nof LA, possibly containing ~, I is a wff of LA, possibly containing R. but with no occurrences of XiCZ, \nI is obtained from I by replacing each atomic formula of I of the form ~(~) by Ro (;) A=+=, and w = \n fop each R(=) ti?tere A[~] key K do s end .n Rule FE should be read as follows (we remind that R. holds \nthe tuples in R already processed) : Premisse 1 assexts that, before entering the for-each, P and the \nfact that no tuple was processed must imply I. premisse 2 asserts that if s is started in a state J where \n~J holds a tuple in RJ satisfying A, ~J iS already in ~ (see Defi\u00adn~tion 3.4) and I holds for all tuples \nin NJ, except ~J, then s must lead to state K where I holds for all tuples in R. (in\u00adcluding =J) . K \n Premisse 3 asserts that, when the fo~-eaeh ends, I and the fact that all tuples have been processed \nmust imply Q. 5. Conclusion In retrospect, Dynamic Logic was augmented to 3.4 Summary include a relational \ndata manipulation language, creating a logic of programs that we called The relational data manipulation \nlanguage we Relational Dynamic Logic (RDL). RDL contains twoconsider in this paper is created by adding \ntwo axioms, in addition to those of DL, for the new basic statements to those considered in DL, the relational \nassiqnrnent and the random tuple selec\u00adrelational assignment and the random tuple tion. These new axioms \nare sound and the wholeselection. The corresponding logic of programs, formal system can be made complete, \nwith certain called Relational Dynamic Logic (RDL) , is obtained provisos as in [HA2]. by adding two \nnew axioms to the system of DL: The virtue we see in our work lies in its simplicity: the four operations \non relations-\u00ad(RS) [WNDOMTUP~(R;z) lQ~Vz(R(z)+Q) retrieve, insert, delete, update--were defined in terms \nof the relational assignment and the for-each Theorems 3.1 and 3.2 assert that Axioms RA and construct \nwas accounted for with just one more RS are sound and, moreover, that the assertion statement, the random \ntuple selection. language is expressive (in the sense of [HA2]) ( Finallyr from the point c)f view of \nprogramfor the new statements. Hence, following [HA2], verification, the Relational Model was shown to \nwe can state: provide a reasonable programmin~ language inter\u00adface to databases. No special. purpose \nlogic isTHEOREM 3.4. RDL Arithmetical Completeness. needed, as the Relational Model can be understoodSuppose \nthat RDL[LR,LE,LA,DA,U] has an adequate as an application of the very basic concepts ofuniverse, LA contains \narithmetic, each stake in Predicate Calculus. the universe U assigns the standard interpretation to arithmetical \nsymbols and the deductive system for LA is complete for U. Then, for any wff Q REFERENCES 0 [BEII Bernsteinr \nP.A. et al. The ConcurrencyThe relational operations--retriever insert, Control Mechanism of SDD-1: A \nSystem fordelete, update -and the for-each construct, as Distributed Databases , Computer Corporationdefined \nsymbols of FU)L, need no special treatment. of America Tech. Rep. 77-09, Dec. 1977. However, an induction \nrule (omitted for reasons of brevity) on the number of tuples already scanned [BE21 Bernstein, P.A. et \nal. An Approach to the can be stated in order to hide some details of the Design and Implementation of \nInteractive definition of the for-each construct. Information Systems , (Draft, Nov. 1977). [CA1 ] Cadiou, \nJ.M. On Semantic Issues in the Relational Model of Data , Proc. Int. Symp. 4. Transactions on Math. Foundations \nof Computer Science, Given a relational dynamic schema Gdansk, Poland, Lecture Notes in Computer T= (LT,DT,D;), \nwe say that a program s is a Science , Springer-Verlag, Sept. 1976. transaction w.r.t. T if s preserves \nthe con\u00ad [CA2 ] Casanova, M-A. The Logic of a Data Mani\u00adsistency of the database described by T, that \nis, pulation Language (technical report iniff s satisfies two conditions: progress). (i) s maps consistent \nstates into con\u00ad [CH1] Chamberlain, D.D. et al. SEQUEL 2: A Uni\u00adsistent StateS; fied Approach to Data \nDefinition, Mani\u00ad (ii) for each dynamic integrity assertion pulation and Control , IBM Tech. Rep. (A,B) \nED:, if s starts in a state satisfying A, RJ1798, June 1976. s mUSt terminate in a state satisfying B. \n[Col] Codd, E.F. A Database Sublanguage Founded It would certainly be helpful if we could on the Relational \nCalculus , Proc. 1971 ACM find a formal characterization of (i) and (ii). SIGFIDET Workshop on Data Description, \nBut as we noted in $3.4, Relational Dynamic Access and Control. Logic is arithmetically complete (in \nthe sense of [C02 ] Codd, E.F. A Relational Model of Data for [HA2], with the necessary provisos stated \nin Large Shared DataBanks , CACM 13, 6, JuneTheorem 3.4). Therefore, we have: 1970. THEOREM 4.1. Let \nRDL be constructed as in [C03] Cook, S.A,, $xiomatic and Interpretative Theorem 3.4 and T= (LA,DT,D~) \nbe a relational Semantics for an ALGOL Fragment , TR 79, dynamic schema of RDL. Then, a program s of \nRDL Univ. of Toronto, Feb. 1975. is a transaction iff [ES1] Eswaran, K.P. and D.D. Chamberlain. Func\u00ad \n(i) for any axiom A~DT, DT l-~LIs]A tional Specifications of a Subsystem for Database :Cntegrity , Prc>c. \nof the Int. (ii) for any dynamic integrity assertion  Conf. on Very Large Data Bases, 1975. c! A~B) \nD $~ T I-RDL + [sIB. [ES2] Eswaranr K.P. et al. The Notion of Con-Thus , at least in theory, we will \nfail to sistency and Predicate Locks in a Data Base not prove that a program is a transaction due to \nweak-System , CACM 19, 11, Nc)v. 1976 (pp. 624\u00adnesses of RDL. Evidentlyr the much more difficult 633) \n. question of finding a proof procedure for our logic remains unanswered. [HAll Hammer, M. PI. and D.J. \nMcLeod. Semantic APPENDIX I Integrity in a Relational Data Base Manage\u00ad ment System , Proc. of the Int. \nConf. on Concepts from Dynamic Logic Very Large Data Bases, 1975. [BA21 Harel, D. Arithmetical Completeness \nin We review here just what is essential to under- Logics of Programs , MIT Laboratory for stand Sections \n3 and 4, referring the reader to Computer Science TM-103, April 1978. [PRII for a full description of \nDynamic Logic (DL for short). [HE1] Held, G.D., M.R. Stonebraker and E. Wong. INGRESS -A Relational Database \nSystem , Proc. AFIPS National Computer Conf., 1975 (pp. 409-416). Dynamic Logic is based on a few parameters: \na first order language LE, the expression language, specifying the expressions allowed in programs; an \nextension of E LA, the assertion Zanguage, whose [LA11 Lacroix, M. and A. Pirotte. Oriented Relational \nLanguages , Int. Conf. on Very Large Data (pp. 370-378). Domain Proc. Bases, of 1977 the wffs are used \nto express correctness assertions; a deductive system DA for formulae of A; and a univeYse U of states \nwith common doma~n vu, each state being a structure for A with domain vu together with an assignment \nof values [YA1] for the [LA21 Lamport, ness for L. Towards Multi-User a Data Theory Base of Correct-Systems \n, variables Dynamic of Logic, LA. we To often stress write these parameters DLILE,LA,DA,UI of . Massachusetts \nComputer Associates Tech. Rep. A program in DL is defined as a binary CA-761Q-0712, Oct. 1976. relation \non U. TWO basic programs (or statements) are provided: [MIII Minker, J. Search Strategy and Selection \nFunction for an Inferential Relational (1) l,X ;= t,, ={(I,J)EU2/I = JAXJ= tl} is called System , ACM \nTODS 3, 1, March 1978 (pp, 1-31). an assignment, where x x is a variable and t [NT: 1 Nicolas, J. First \nOrder Logic Formalization is a term of LE(I=J indicates that I for Functional, Dependencies , Multivalued \nACM SIGMOD and Int. Mutual Conf. on and J differ only x on the value of x). Management of Datar May 1978 \n(pp. 40-46). (2) T!p?Tf = {(I,J) EU2/I ~P} is called a test, [Ow: I Owicki, S-S. Axiomatic Proof Techniques \nwhere P is a wff of LE (I ~P indicates for Parallel Programs , Science, Cornell Univ., Dept. Tech. of \nComp. Rep. 75-251, that P is valid in I). July 1975. Programs are created by the following [PA1 ] Papadimitriou, \nC.H., P.A. Bernstein and J.B. operations : Rothnie\u00ad Some Computational Problems Related Proc. of Waterloo, \nto Database Concurrency Control , Conf. on Theoretical Comp. Science, Aug. 1977 (pp. 275-282). (3) 1;s2 \nand S1US2 reflexive and S*, transitive the composition, closure of their union components. [PR1] Pratt, \nV.R. Semantical Considerations on Floyd-Hoare Wgic , Proc. of the 17th IEEE In order to express facts \nabout programs, a Found. (pp. of Comp. 109-120). Science Conf., Oct. 1976 new formation rule is added \nto those of first-order languages: [Sell Schmidt, J.W. Some High-Level Language Constructs TODS 2, 3, \nfor Sept. Data of 1977 Type (pp. Relation , 247-261). ACM (4) if P program, is a wff then, of <S>P DL \nis or a A wff and of s DL . is a [ST1] Stearns, krantz. R.E., P.M. Concurrency Lewis and Control D-J. \nfor Rosen-Data Base The notion of interpretation is extended to Systems , Proc. of the 17th IEEE Found. \nof <S>p as follows: Comp. Science Conf., Oct. 1976 (pp. 19-32) . (5) I ~<s>P if 3J((I,J)Es AJ ~P) [TH11 \nThomas, Problem R.H. for A Solution Multiple Copy to the Databases Update which [s]P is then introduced \nas ~<s>~P with Uses Distributed COntrOls , BBN Tech. Rep. interpretation; 3340, July 1975. (6) I \\ [SIP \niff VJ((I,J)ES+J ~P) [VA11 van Emdenr M.H. Computational and De\u00ad ductive Information Retrieval% , Proc. \nof DL contains the following axioms and rules of the IFIP Conf. of Formal Specifications the Working \nof Prog. Group Lang., on Aug. inference, in addition to those of A (Q is a 1977 (pp. 17.1-17.19). wff \nof LA): [YA1] Yasuhara, A. Recursive Function Theory and Logic, Academic Press, 1971. (7) [x:=t]Q ~ \nQt (8) [P?]Q : PX* Q (9) [sl U S2]Q = [SIIQA [S2]Q (lo) bi; s21Q = lS1l [S2]!2 (11) Necessitation \n: ~ ls]=[sIQ P=+[S]P (12) Invariance :  -[S*JP DLILE, LA, DA, UI has an adequate universe iff for \nany variable x of LE and any individual aEVu, there is a state 16U such that xl=a. For adequate universes, \nAxioms 7 to 10 are sound and Necessitation and Invariance are valid. We refer the reader to [HA2] for \na discussion of the relative completeness [C03] of DL. Note: Universes are in principle arbitrary. How\u00ad=, \nwhen discussing a logic of programs, atten\u00adtion must be paid to the choice made. For instance, if no \nstate I in U valuates x as 5, the binary relation associated with x:=5 is empty, permitting us to derive \nl% [x: = 51~aZse ~ true, Hence, Axiom 7 is not sound in U. The notion of adequacy of universes cures \nthis anomaly. APPENDIX 11 Proofs Before proving Theorem 3.1, We state a le~ @ about the construction \nof from M (as de\u00ad scribed in the statement of the theorem) . We use MwN to indicate that N is a variant \nof M (that is, N is obtained from M by renaming variables) . LEMMA 3.1. (.M)~ a~~ N~v N~N(MvN)~ 3XM; \n*(~xM)A R (Mi)A N (M:) ~ xx x is free in M and i is a constant. (The proof follows trivially from the \ncon\u00adstruction of M;) . 0 THEOREM 3.1. SUppOSe that RDL[L ,L ,L D R E A A U] has an adequate universe. \nThen, for any wff Q of L A? Pu [R(l) :=AIZll Q~Q; . 0 Proof: Suppose that RDL[LR,LE,LA,DA,U] has an adequate \nuniverse. Let Q be a wff of LA and s = R(~): =A[;l be a relational assignment of RDL . (In the sequel, \ndenotes the domain of u U and n denotes the arity of R). We observe initially that (1) $Q;~ [s]Q = (VI@) \n(IF Q; = [sIQ) =(VIEU)(I/+Q~= (VJEU)( (:[,J)6S+JEQ) ) = (h I@J) (11= Q; = s(I) I=Q) by Def. 3.1. and \nRDL has an adequate universe, s is a total function on U. Therefore, all we have to prove is that for \n(I,J) Es: . (2) I/=Q:=J~Q Moreover, by Def. 3.1, we know that (I,J) E s i ff  (3) I ~ J A (V;E~)(RJ(;) \niff I l=A[;/;]) We then fix (I,J) CU2 satisfying (3) and prove  (2) by induction on the height of Q. \nBasis: Assume Q = S(;), S a,predicate symbol of L  A Case 1: S=R (4) J/=Q . J l=R(~) = RJ(;J) . I /=A[~J/;] \n. by (3) . I l=A[~@ . by . I l=A [~/;] . A is a, variant of A with no variable of Q bound . construction \nof Q; I I=Q; . Case 2: S # R (follows similarly) Induction step: Assume (2) for formulae of height less \nthan k and let Q be of height k. We consider only the case where Q = 3XM: (5) J I=Q . J /=&#38;l . J \n/=Mi i is the name of some in-. x dividual of J, by clef. of J l=~xM . 1 1= (Mi)A induction hypothesis, \nas ML XR x and M h,ave the same height . I I=(FR): Lemma 3.1 and Variant Theorem . I @X~ i is also the \nname of some individual of I, as I and J have the same domain, and by clef. of J ~~xN . I ~ (axM); Lemma \n3.1 A . I I=Q; construction of Q R This conciudes the proof. 0 THEOREM 3.2. Suppose that RULILR,LE,LA,DA,U] \nhas an adequate universe. Then, for any wff Q of LA, hUIRAWDOMTUpLE (R; ~)1 Q~ &#38;(R(l) *Q) . D Proof: \nSuppose that RDL[LR,LE,LA,DA,U] has an adequate universe. Let Q be awff of LA and s = IRANDOMTupLE(R; \n~) ,, be a random tuple selection of RDL. (In the sequel, v denotes the domain u of U and n denotes the \narity of R). Let IEU. Then we have: (1) I I=[s]Q = (VJEU)( (I,J)ES=+JI=Q) . clef. of I l=k]Q = (VJEU)(R1(;J) \nAI E J+JI=Q) . clef. 3.3 x = (VJCU)(R1(;J) AI ~ J+Il=Q[~J/~] . I and x J differ only on G . FU)L has \nan ade\u00adquate universe = (V;CV~)(Il=R1(;)*Q[~/;]) clef. of II=M*N . 11= /j(R(j) =+Q[~/;]) . clef. of 11= \nV;M Il=V;(R(~) *Q) From (1) we can conclude our result: (.2) (VICU)(I~ [s]Q = Il=V~(R(~) *Q)) 1 iff (VIEU)(II=[SIQ \n~ V=(R(Z) *Q)) clef. of I 1= MEN iff &#38;s]Q ~Vi(R(=) -Q) This concludes the proof. 0 THEOREM 3.3. \nSuppose that RDL[LR,LE,LA,DA,U] has an adequate universe. Then Rule FE is valid in u. 0 Proof: The proof \nis a straightforward appli\u00adcation of the system of RDL. For brevity, we present just a summary in the \nstyle of [OW1]. : {P} 1 : Ro(~):=@&#38;AR o(x); 1 : {T3Z(Ro(Z))Ap} 2 : {T3X(RO(Z)) AI} 3 W2: RT (:) \n:=R(i?) AA[~]; : {VZ(~(Z)~R(2)AA1xl A&#38;~(Ro(~)) AI} 4 P5: {V~(~(X) =R(i)AAIZl A&#38;(Ro(~)A~n=~n) \n)AI) ({3=(~(z))*P5} W3: 3;(@) ?;{P51 P6: {VZ(~(Z) ZR(Z)AAIZl AT3~(R.o(~) A~k=~k) AI} W4: RANDOMTUPLE(RR;z); \nP7: {R(2) AA[Z]A72j(Ro(j) Ajk=2k) AI} {R(Z) AAI1] AI} 8: 5: P: 9 6: lo: w: 7 u 11: 8: 12 P 13: 14: \nTHEOREM 3.4. RDL Arithmetical Completeness Suppose that RDL[LR,LE,LA,DA,U] has an adequate universe, \nL contains arithmetic, each state in A the universe U assigns the standard interpreta\u00adtion to arithmetical \nsymbols and the deductive system for L is complete for U. Then, for A any Wff Q of RDL, ~UQ iff I=mL \nQ. 0 Proof: We argue here that the completeness of DL [HA2] extends to the completeness of RDL. It follows \nfrom Theorems 3.1 and 3.2 that, for any relational assignment or random tuple selection s andanywff P \nand Qof LA: (1) there is a wff R of LA such that I=u [s]Q2R  (2) \\uP*[s]Q iff I-DL p+[sIQ (3) I=u P*<s>Q \niff I-DL P=<s>Q Hence, using the completeness of DL and the above results, by induction on the structure \nof a formula S of RDL and on the structure of a program s of RDL, we can prove: (4) for any wff S of \nRDL, there is a wff S of L such that /%s;s! ( expressibility  A of LA for RDL)  (5) for any program \ns of RDL and any wffs P and Q of LA, l~p*[sIQ iff twLR[sl Q (6) for any program s of RDL and any wffs \nP  and Q of LA, lfiP+<s~ Iff l-mLP*<s>Q From (4), (5), (6) we can then conclude the result: (7) for \nanywff P of RDL, &#38;P iff I-mL P 0 THEOREM 4.1. Let RDL be constructed as in Theorem 3.4 and T = <L \n,D ,D > be a dynamic TTT schema of RDL. Then, a program s of RDL is a transaction of T iff (i) for any \naxiom A~DT, D~ l-mL [s.IA; and (ii) for any dynamic integrity assertion (A, B) ~D;, DT t~L A+[s]B  \n0 Proof: Let s be a program of RDL. Let is the univexsal closure A~D ~= A A ,where Al T of A. Then s \nis a transaction of T iff (1) (VI@) (VJf3J)(Il=i +( (I,J)Es*J~=~)) and for any (A,B) ~D~, (VIEU)(VJEU)(Il=fi \n*(II=A*( (I,J)6s-J1=B))) BY definition of [s]Q, (1) is equivalent to:  (2) ~u ~-[sl~ and, for any (A,B) \nED; , ~u ~=+(A-[.s]B) By Theorem 3.4 and assumptions on RDL, (2) is equivalent to: (3) I-mL ~+(s]~ \nand, for any (A,B) CD; , l-mLI*(A+[S]B)  Finally, by the Deduction Theorem and ~ is closed, s is a transaction \niff (4) i I-mL [S]z and, for any (A,B) (lD~ , ~ I-mL A+ [s]B. 0 \n\t\t\t", "proc_id": "567752", "abstract": "A logic for a relational data manipulation language is defined by augmenting a known logic of programs with rules for two new statements: the relational assignment, which assign a relational expression to a relation, and the random tuple selection, which extracts an arbitrary tuple from a relation. The usual operations on relations-retrieve, insert, delete, update-are then defined as special cases of the relational assignment, and the for-each construct scanning a relation tuple by tuple is introduced with the help of the random tuple selection.", "authors": [{"name": "Marco A. Casanova", "author_profile_id": "81452610133", "affiliation": "Harvard University, Cambridge, MA", "person_id": "PP95032851", "email_address": "", "orcid_id": ""}, {"name": "Philip A. Bernstein", "author_profile_id": "81100134982", "affiliation": "Harvard University, Cambridge, MA", "person_id": "P226116", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/567752.567762", "year": "1979", "article_id": "567762", "conference": "POPL", "title": "The logic of a relational data manipulation language", "url": "http://dl.acm.org/citation.cfm?id=567762"}