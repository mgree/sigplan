{"article_publication_date": "01-01-1979", "fulltext": "\n Permission to make digital or hard copies of part or all of this work or personal or classroom use is \ngranted without fee provided that copies are not made or distributed for profit or commercial advantage \nand that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, \nto post on servers, or to redistribute to lists, requires prior specific permission and/or a fee.&#38;#169; \n1979 ACM 0-12345-678-9 $5.00 THE FUNCTIONAL POWER OF PARAMETER PASSAGE MECHANISMS Adrienne Critcher Baylor \nUniversity Waco, Texas 76To3 1. INTRODUCTION The effects of parameter transmission to re\u00adcursive procedures \nhave been investigated widely (e.g. ,in [2], [5], [6], [T], [81, [IO], [12], [13]) and have been shown \nto be a consideration in such diverse topics as program verification ([2]), hard\u00adware design ([13]), \nand the use of the fix Point rule of computation ([5], [61, [10]). It is the ease in most of the works \ncited above that the ef feets of only one or two mechanisms for parameter transmission are at issue, \nprompting us to question whether or not there exist other parameter passage mechanisms which would be \nas powerful as the origi\u00adnal mechanism but have fewer effects to be consid\u00adered in conjunction with other \nlanguage features. Motivated by this same line of questioning, Snyder [14] undertook a comparative analysis \nof several well-known parameter passage mechanisms using the techniques of comparative schematology [III \nin program schemata-~. Using these techniques on sim pIe program schemes (no arrays) whose actual param \neters can be arbitrary expressions, Snyder has shown call by value, copy, and reference all to be equivalent \nbut each weaker than call by name. Sny\u00adder assumes all basic functions and predicates to be total. Also \nusing the techniques of compara\u00adtive schematology, but on program schemes which are augmented with finite \ndynamically-allocated arrays, whose actual parameters can be arbitra~ expres\u00adsions including arrays and \narray cells, and whose basic functions and predicates are partial., Lein\u00adbaugh [9] has shown that call \nby value, copy (termed value/result), and reference are all equi\u00advalent but each conjectured to be weaker \nthan call by name. When an index equality test (an equality test on array indices) is added to the schemes, \nall the parameter passage mechanisms are shown to be equivalent. (In addition , when the index equality \ntest is allowed Leinbaugh shows that his finite arrays are as powerful as the infinite arrays i Program \nschemata deals with abstract programe called program schemes which, in general, are ALGOL-like and consist \nof assignment, if then\u00ad else , go to, and halt statements. In program schemes the domain and basic functions \nand predi\u00adcates are left unspecified turtil an interpreta\u00adtion is applied to the scheme. Two program \nschemes are considered equivalent if and only if for any interpretation they both halt with the same \nvalue or both diverge. introduced by Constable and Gries [3], but the relationship is not established \nwhen the index equality test is removed, even when basic functions and predicates are total.) To summarize, \nSnyder and Leinbaugh distinguish only the mechanisms call by vaSue, copy, and reference from the mechanism \ncall by name, and at times Leinbaugh finds no distinctions at all among anY of the mechanisms. Because \nSnyder and Lein baugh used the traditional techniques of compara\u00adtive schematolo~, their results are \ntranslatabili ty results arrived at with constructive proofs that are step by step translations to be \nperformed on arbitrary program schemes whose defined functions (ALGOL-like procedures) utilize a particular \nparam\u00adeter passage mechanism transforming them into equi valent program schemes whose defined functions \n utilize a different parameter passage mechanism. Since application of these results requires the translation \nof entire programs, rather than just the translation of defined functions, these results could be useful \nto a compiler writer but clearly could not be used. to effectively translate indivi\u00addual procedures utilizing \none parameter passage mechanism into procedures utilizing another param eter passage mechanism. In addition, \nusers are un likely to use these translatability results in their programs to simulate parameter passage \nmechanisms not implemented in the language they have chosen. Hence, we propose that Snyder s and Leinbaugh \ns results do not yield a strict compari son of the various parameter passage mechanisms from which a \nreasonable hierarchy of power can be established for users and language designers be\u00adcause the salient \nfeatures of each mechanism can be obscured by translations made on the surrounding scheme prior to the \nact of parameter transmission. The various parameter passage mechanisms are distinguished at three points \n[14]: 1) defined function initiation operations per formed at the time of call but before execution \nof the defined function begins , 2) interpretation of formal parameters method by which a reference \nto a formal parameter is resolved, 3) defined function termination --operations per\u00adformed after execution \nof the defined function but before execution resumes immediately fol\u00adlowing the point of call. When Snyder \nand Leinbaugh showed that two mecha\u00adnisms were equivalent in power by speci~ing how to translate any \nprogram scheme whose defined func tions used one mechanism into an equivalent program 158 scheme whose \nf~~ti~fls ~~~d t,h~ ot,h~r m~~h~ism, defined function initiation, interpretation of for\u00admal parameters \n, and defined function termination for functions in the two program s ehemes were usu\u00adally made with \nrespect t o different sets o I? varia\u00adbles and domain values. We suggest that to more accurately measure \nthe relative powers of the various parameter passage mechanisms, two mecha\u00adnisms should be considered \nequivalent in pc>wer if and only if any defined fanction using either of the mechanisms can be translated \ninto an ec~uivalent defined function using the other mechanism. Since the translation involves functions \nonly, the two functions, if equivalent, Perfom the same compu\u00adtation with their respective defined function \ninitiations , interpretations of formal parameters, and defined function terminations taking place on \nthe same sets of variables and domain values. We believe basing the relationships among parameter passage \nmechanisms on function equivalence rather than on program scheme equivalence is more valid as the various \nmechanisms are co~pared within the same calling environment, hence their respective de~ined function \ninitiations, interpretations of formal parameters , and defined function terminations are all made with \nrespect to the same environment. Hence we introduce into the theory of program schemata a new formalism \nwhich we call function schemata through which we introduce function classes and the concepts of function \nequivalence and function class equivalence. Function classes are defined which contain defined functions. \nThe function class to which a defined function belongs determines defined function initiation, interpre\u00adtation \nof formal parameters, and defined function termination for that defined function. Our function class \ndefinitions allow for the case that all functions in any program scheme belong to the same function class, \nor for the case that any function in any program scheme may belong to any function class. Note that only \nthe semantics of parameter transmission for a defined functicm are specified by its function class. The \nsyntax of a Ciefined function is still specified by the same grammar which defines its surrounding program \nscheme. The equivalence of two defined functions is defined with respect to an underlying class of program \nschemes. We specify a basic grammar which we modify as necessary to define the classes of underlying \nprogram schemes considered. Because Leinbaugh assumes basic functions and predicates to be partial and \nbecause Snyder s assumption of total basic functions and predicates is not crucial to the results in \n[14] of interest here, we assume basic functions and predicates to be partial. 2. DEFINITIONS We speci~ \na grammar [4] based on Const:ible and Gries grammar in [3] which we use and modify to define four classes \nof program schemes. The class P(R,V) has no arrays and allows only sj.mple variables as actual parameters \nto defined functions. The class P(R) has no arrays and allows arbitrary expressions as actuals to defined \nfunctions. The class P(R.A] include~ (one way infir,ite) arrays and allows arbitrary expressions including \narrays and array cells-as actuals to defined functions. The class P(R,Ae) merely adds the index equality \ntest. Our grammar allows a defined function to have subfunctions which can be invoked only by that defined \nfunction or by other subfunctions within that defined function. The semantics of parameter transmission \nfor defined functions depend on the func>ion class to which the defined function belongs, and any subfunction \nof a defined function must belong to the same function class as the defined function. A program scheme \nS represents an abstract program while a program scheme S with an interpre\u00adtation I computes a partial \nfunction where the result of the scheme is called Val(S,I). In most of our proofs we speci~ an interpretation \nand then consider the free interpretation corresponding to that interpretation. Definition 2.1: An interpretation \nI, for a scheme S, is free if 1) th~main of I consists of finite strings of symbols: the (fully-parenthesized) \nbasic function symbols of S and input variables of S and Q+, 2) the function associated with the basic \nfunction symbol fi is a function Fi of rank Rfi, with the property that for strings tl , . . .. .f. \n, 1 Fi( tl ,. .., tRf. ) = fi(tl,.. .,tRf ) , 1i 3) each input variable x is initialized to the value \nx . Definition 2.2: Giyen an interpretation I, the . free interpretation 1 corresponding to I is the \nfree interpretation whose predicates are defined as . . follows: if the predicate associated with the \npredicate symbol pi is a predicate Pi of rank Rpi and x x ,..., x are elements of the 1 2 Rpi domain \nof IF, then Pi( xl x2 ,2 ,. .., x Rp ) is true ~pi) ls true inin IF if and only if pi(xl,x2,. ... I. \nWe now introduce the concept of function equivalence. Definition 2.3: A defined function G is equivalent \nto a defined function G with respect to a class C of program schemes if and only if for every program \nscheme S E (! in which G appears, if we a) replace the function definition of G by that of G , and b) \nreplace each occurrence of G by G , to obtain program scheme S E C, then S Z S . Similarly the condition \nmust hold with the roles of G and G interchanged. Stated informally, two defined functions are equi\u00advalent \nwith respect to a class of program schemes if they can be used interchangeably in all program schemes \nwithin that program class. Based on this concept of function equivalence we next define function class \nequivalence and other function class relationships (which are analogous to program ? Q is added to every \n&#38;omaln to .ep.eseni the undefined value, i.e. , the unpredictable value a basic function might return. \nWhen we say Val(S,I) is undefined, we mean S diverges on 1, not Val(S,I) = Q.  scheme class equivalence \nand other program scheme class relationships). Definition 2.4: A class of defined functions C is as powerful \nas a class of defined functions C, ccc , if for every defined function G E C there ex~sts an equivalent \ndefined function G E C! . Definition 2.5: A class of defined functions C is equivalent to a class of \ndefined functions C , c~c! , ifC <C! and C! <C. Definition 2.6: A class of defined functions C! is strictly \nmore powerful than a class of defined fuctions C, C < C , if C ~ C and there exists some defined function \nG E C for which no equiva\u00adlent defined function exists in C. Definition 2.7: Two classes of defined functions \nC and C are incomparable if C $c andc Jc. We initially define five function classes based on the following \nparameter passage mechanisms which are well-known and widely considered through out the literature: callby \nvalue (e.g., inALGOL 60 and ALGOL W), callby copy (e.g., in some versions of FORTRAN), call by value/result \n(e.g. , in ALGOL W), callby reference (e.g., in PL/I and some versions of FORTRAN). and callbyn ame (e.g., \ninALGOL 60 andAL&#38;L W). The five function classes are F(value), F(copy), F(vr), F(ref), and F(name), \nand each contains all syntactically correct defined functions as specified by the grammar for the class \nof program schemes being considered; however, the defined functions in F(value) are transmitted parameters \nby value, and similarly for the defined functions in F(copy), F(vr), F(ref), and F(name). Formal definitions \nof each function class can be found in [4]. 3. PROOF METHODS Some of our proofs are construction proofs \nwhich specify an effective translation of a defined function in one function class into an equivalent \ndefined function in some other function class. These construction proofs are used when we want to show \nthat one function class is as powerful as some other function class or that two function classes are \nequivalent. The majority of our proofs, how ever, show that one function class is not as power ful as \nsome other function class or that two func\u00adtion classes are incomparable. These proofs involve negative \nresults, i.e., results which show that for some particular defined function in one function class there \nexisks no equivalent defined function in some other function class. We begin these proofs by applying \na lemma on redundant basic functions and predicates in defined functions which is analogous to Chandra \ns theorem on redundant basic functions and predicates in program schemes [I]. The lemma establishes that \nif we want to find 3 defined function equivalent to some given defined function G, then the defined function \nto be found need not have any basic func\u00adtions or predicates other than those in G. So we carefully choose \na particular defined function G in the function class we believe to be more power ful and assume there \nexists an equivalent defined function G in the function class we believe to be less powerful. By virtue \nof the lemma we can pick G so that it contains no basic functions or predi\u00adcates other than those found \nin G. We next select one or more pairs of program schemes and interpre tations for these schemes. The \ntwo program schemes in each pair differ only in that one member of the pair contains G and the other \nmember contains G!. Since G and G are assumed to be equivalent the two program schemes in each pair must \nbe equivalent for all interpretations, so by careful selection of these schemes and interpretations we \ncan determine somewhat the behavior of Gf . Having determined enough about the behavior of G we finally \nchoose a pair of schemes as described above and an inter pret,ation for which the two schemes cannot \nhalt with the same value. Thus our assumption of the existence of G! is contradicted. The critical aspect \nof these proofs is a sufficient determina\u00adtion of the behavior of G to arrive at a contra\u00addiction. This \ndetermination is made, of course, as a result of very careful selection and manipulation of specific \nprogram schemes and interpretations for these schemes. Details of proofs can be found in [4]. The following \ndefinition contains notation that will be useful in our proofs. Definition 3.1: Let S be a program scheme \ncontain ing the defined function G. If in S we replace each occurrence of G by G! and replace the function \nand subfunction definitions of G by those of G1 to obtain.program scheme S , then we say that S is the \nG image of S with respect to G and write S =S[G+ G ]. 4. SIM?LE VARIABLES AS ACTUAL PARPJTETERS Throughout \nthis section we consider defined function equivalence with respect to the class P(R,V) of program schemes \nwithout arrays which restrict actual parameters to simple variables. This hypothesis will be understood \nand will not necessarily be restated whenever function and class relations are shown. With respect to \nthe class P(R,V) of program schemes we show that F( value) is strictly the least powerful class, F(copy) \nand F(vr) are equivalent, and F(ref) and F(name) are strictly the most powerful classes: F(value) < F(copy) \n~ F(vr) < F(ref) = F(name). The relations indicating equivalence are due merely to the definitions of \nthe function classes at this point because of the restrictions on actual param eters . Theorem 4.1: F(value) \n< F(mechanism), where mechanisn s {copy,vr,ref,name}. Based on the definition in [15] of the effect of \ncall by value, a construction can be given for an arbitrary defined function in F(value) to be translated \ninto an equivalent defined function in F(mechanism) . We then use the fact that there can be no side \neffects on actual parameters to defined functions in F(value) to show that F(value) is strictly less \npowerful than the other function classes. 160 Theorem 4.2: F(vr) < F(ref). Proof: Based on the definition \nin [15] of the effect of call by value/result, a construction can be given for an arbitrary defined function \nin F(vr) to be translated into an equivalent defined func\u00adtion in F(ref). Now consider the program scheme \nS E P(R,,V), (V,u): u + G(v,v) halt(v) G(x1,x2): xl + fl(xl); X2 + fl(x2) halt(xl). - If G E F(ref) \nthen Val(S,IF) = fl(fl(v)), for all I, while if G &#38; F(vr) then Val(S,IF) = fl(v),, for all I. Let \nG E F(ref ) amd assume there exists a defined function G E F(vr) such that G = G . Let S =S[G+ G ]. Now \nG! must contain some code which causes fl(fl(v)) rather than fl(v) to be returned to actual parameter \nv. Without loss of generality, assume that G contains no basic func\u00adtions other than fl and no predicates. \nHence the code in G which modifies the value returned to v contains no predicates, but is straight-line \ncode. Since G contains no predicates, the same sequence of statements is executed upon each call of G \n. Now in F(vr) the formal parameters are treated as local variables and are reassigned to their corre\u00adsponding \nactual parameters sequentially, left to right, at the time of return. Hence for ~ = fl(fl(v)) after G \nis invoked, then we must  necessarily have x = fl(fl(xl)) or x = f1(fl(x2)) 22 after x2fs final assignment \nin G Hence we can assume that after any call of G! that = fl(fl(xl))or X2 = fl(f1(x2) after x s final \n 2 2 assignment in G . Consider the scheme S E P(R,V), 1 (V,u) , w+ G(u,v) halt(v) G(x1,x2): xl + fl(xl); \nX2 + f1(x2) halt(xl) ad let S = Sl[G+ G ]. Now Val(S1 ,IF) E 1 I, while{fl(fl(u) ),fl(fl(v))}, for \nall Val(S1,IF) = fl(v), for all I. Hence Val(Sl,EF) # Val(S1 ,IF) => S1 z S1 => G z G . But this contradicts \nour assumption of the existence of G! , hence there exists no defined function G E F(vr) such that G \n-G , q.e.d. 5. ARBITRARY EXPRESSIONS AS ACTUAL PARAMETERS Throughout this section we consider defined \nfunction equivalence with respect to the class P(R) of program schemes without arrays which allow arbi\u00adtrary \nexpressions as actual parameters. This hypo\u00adthesis will be understood and will not neC&#38;3SWily be \nrestated whenever functiOn and class relations are shown. With respect to the class P(R) of program schemes \nthe hierarchy of power of function classes established when actual parameters were only slmpLe varlaDles \n1s mOdlSled only sllgnt\u00ad ly . The same results hold except that while still strictly more powerful than \nthe other classes, F(ref) and F(name) are now incomparable. To show that call by name cannot be simulated \nby the other mechanisms we will specify a function\u00adal which can be computed by a defined function in \nF(name), but not by any defined function in any of the other function classes. This functional was first \ndescribed by Paterson and Hewitt [11] and has since become known as leaftest. The behavior of leaftest \ncan be stated as follows: u(x) if there exists u c {r,JL}% such that leafiest = P(u(x)) is true -y.ndefined \notherwise[ where r and L are basic functions and p is a basic predicate. Leaftest requires a search for \na domain element satisfying some predicate where the domain may be thought of as a binary tree. Paterson \nand Hewitt [11] assert that leaftest cannot be computed by recursive functions using call by value and \nstate that the proof is based on the intuitive notion that recursive equations (using call by value) \ncan scan only a bounded number of nodes in the binary tree and an interpretation may be speci\u00ad fied for \nwhich some crucial node does not get tested. Using this idea we will show that there exists no defined \nfunction in I (value), F(copy), F(vr), or F(ref) which computes leaftest. Because of complications which \ncan arise when more than one formal in a function in the class F(ref) corre\u00ad sponds to the same actual, \nthe class F(ref) will be considered separately in a corollary to the next theorem. Theorem 5.1: F(name) \n~F(mechanism), where mechanism &#38; {value,copy,vr}. Proof sketch: Snyder [14] has specified a program \nscheme using call by name which computes leaftest. Based on that program scheme, we specify 8 defined \nfunction (with subfunctions) in F(name) which computes leaftest. Assume there exists a defined function \nin F(value), F(copy), or F (vr) which computes leaf\u00ad test. Without loss of generality assume that defined \nfunction contains only basic functions r and E and basic predicate p. Now consider the computation of \nthis defined function on a free interpretation where all p(x) are false. Some defined function G is called \nrecursively if leaf\u00ad test is computed [11], and this defined function must be in a loop, since the only \npredicate is p = false [3]. Thus the same sequence of state\u00ad ments will be executed in the interval between \nsuccessive calls of G. Call this interval a cycle of computation or, simply, a cycle. Let cycle O be \nthe sequence of statements in the interval following the first call of G through the first recursive \ncall of G. Let cycle j be the sequence of statements in the interval following the jth through the j+lst \nrecursive call of G. Let nbe the rank of G, let z ,...,z n be the formal 1 parameters of G, and let Xl,. \n..,xn be the actual parameters to the recursive calls of G. P: = {t I Xt + u(zs) occurs in each cycle,J+1 \nu E {r,L}*, SEp~}, j~(). If we think of the domain of leaftest organ\u00adized as a binary tree, then the \ndomain elements are the nodes of the tree, hence the values of the We characterize the set P by showing \nthat for actual parameters to G are nodes of the tree. each r E Pl, the values of Xr begin repeating \nafter (Actually, the domain will usuallybe represented by two trees: the root node of one is Q and if \nthe the kith recursive call of G, and for each r E P;, argument to leaftest is x # Q then x is the root \n()~j~n_3, the values of Xr begin repeating after node of the other.) We first show that the values of \nall actuals to any (after the first) recursive the j+kith recursive call of G. call of G are descendant \nnodes of the values of the actuals to the previous recursive call of G. We The last set i is the union \nof the sets below next categorize the actual parameters of G by show-which are defined, where 1 < i < \nn: . ing how they are partitioned into three sets according to the way in which their values are Wl={t \nI ts {i =jo,jl,. ..,j}, l~l~ jo<jm~n, determined in the first, and hence, in each 1 succeeding cycle \nof computation. The first set K l< m< ki, joandjl and . . . andjk is the union of the sets below which \nare defined, i where 1 ~ i < n: are distinct, ki zO, Uu E {r,L}*, . r l<a<k,+l,uu  {t I + +U(zi) occurs \nin each cycle, 1 ~2 ~i+l# k, and t where 1 < t < n, u s {r,L}*}, if Xj o +1 Ul(zj ), x. + @zj2 ),J1 \n 1 x. + z. occurs in each cycle 11 x.. + u (z. ),... , x. + Lji+l(zj )3 J3 J2 Jki o K: = occur in some \norder in each cycle} {i}, ifxi + U(zj), u &#38; {r,!L}*, 1 ~j ~n, does not occur in each cycle, i.e., \nxi W;={tlxt + u(zs) occurs in each cycle, is assigned some constant node in u E {r,!J}*, s c WI} W2 \neach cycle = {t \\ Xt l!+!! K? = {t I Xt + u(zs) occurs in each cycle, J+l w: u(zS) occurs in each cycle, \n J+1 u c {r,k}*, sEw;}, jzl. where 1 <t <n, u &#38; {r,!L}*, s E K;} U {i}, j 21. We characterize the \nset W by showing the following, for m ~ O: We characterize the set K by showing that by the nth recursive \ncall of G the values of all 1) for each r E Wl, the value of Xr to the actuals x r E K, become fixed \nand never change. r m(k.+l)st recursive call of G is on at least ~ev:l mt in a tree The next set P is \nthe union of the sets below , which are defined, where 1 < i < n: 2) for each r EW;, 1 < j <n 1, the \nvalue of Xr  P1 = {t ltE{i=jo,jl,. ..,jk} ,15 jo<j <n,to the m(k,+l)+jth recursive call of G is on at \nm 1 least level m in a tree. l<m<k.,1 j. ad jl and ... =d jk, are 1 By using a graph to represent the \nassignment distinct, ki > 0, and x. + z. , of values to actuals, we next show that our cate Jo J1 gorization \nof the actuals is complete, i.e., that II+!t Xj ~ lr+ft zj2, xj2 Z.,. ..,x. + z. forallr, l~r~n, r &#38; \nKor r E P or r EW. J3 Jo k. 1 We then determine a level L in a tree such occur in some order in each \ncycle} that : l)L>n, 2) if r EKor r cPthen the values of all Pi = {t I Xt + u(z~) occurs in each cycle, \no actuals x are above level L, u E {r,L}*, s EP1} P1 r 3) ifrcW~,l~i~n,l~ j< n-l, the values of all \nactuals Xr before the jth recursive call of G are above level L. Now if r E W then the value of x on \nthe L(k+l)+Jth +X + E means the value that the expression E r m has at the beginning of a cycle is the \nvalue that is passed as the mth actual to the next ? Level m means the level in a binary tree where recursive \ncall of G. the width is 2m nodes. 162 recursive call of G is on at least level L, where k is the greatest \nki as defined for all W. , 1 <: i < n, 1 .\u00adand J is the greatest j such that W1 # ~, for all i ~dj, l<i<~, \nl<j< n-l. (Ifjno such J exists th ~n J = O, a d i= no such k exists then W = @ and W can be disregarded \nin the remainder of the proof.) In addition, we assume that for each r E W, the value of Xr on the first \ncall thrcmgh the L(k+l)+~Jth recursive call of G is on at most level T, T >L.  Since n < L ST there \nexists at least one node on level T such that this node is not the value of my actual parameter to the \nL(k+l)+Jth recursive call of G. We then show that there exists such a node, say q, such that neither \nq nor any of its descendants is the value of any actual parameter to this or any future call of G, and \nthat none cf q s proper descendants has been the value of any actual parameter to any previous call of \nG. But q s proper descendants must be tested with predicate p during a cycle of computation or before \nG is ever called. Only a finite number of nodes, say w, cam be tested by p before G is ever called. And \nonly a finite number of nodes, say m, can be tested in each cycle. These nodes may be: 1) fixed nodes, \nin which case the same nodes are tested by p in each cycle, so clearly nave already been tested before \ncycle L(k+l)+J. 2) values of actual parameters to G. 3) descendants of nodes which are the values of \nactual parameters x r &#38; K+ P. Since all r possible values of these parameters have already appeared \nin calls to G before cycle L(k+l)+J then clearly all descendants of these argument nodes have already \nbeen tested by p before cycle L(k+l)+J. 4) descendants of nodes which are the values of actual parameters \nXr, r c W. Then before cycle O and from cycle O through cycle L(k+l)+J 1, u+(L(k+l)+J)m nodes are tested \nby P. Now a path in a tree from node q through u+(L(k+l)+J)m+l of its proper descendants includes at \nleast one proper descendant node of q which could not have been tested with p before cycle L(k+l)+J. \nBut this untested node cannot be tested during or after cycle L(k+l)+J because it is not of type 1) or \n3) above (else it would already have been tested), has been shown not to be of type 2), and by cycle \nL(k+l)+J is shown not to be of type 4). Therefore this proper descendant node of q is never tested with \np. Now if we consider another interpretation which differs only by making predicate p be true on this \nuntested node alone, then the computation of our defined function will never test that node and will \ndiverge as before, whereas leaftest should halt on this interpretation contradicting our assumption that \nour defined function in F(value), F(copy), or F(vr) computes leaftest. Corollary 5.2: F(name) ~F(ref). \nProof: Since leaftest can be computed by a defined function in F(name), assume there exists a dellned \nfunction G s F(ref) such that G computes leaf-test, G(x): <function body>. Let S E P(R) be the following \nprogram scheme, (x): u + G(x) halt(u) G(x) : <function body>. Clearly G computes leaftest if and only \nif S computes leaftest. Now all defined functions in S (G and its subfunctions) are in F(ref). Snyder \n[14] has shown that there exists a program scheme S s P(R), (x): ~ody of S > such that S E S and all \ndefined functions in S1 are in F(value). Therefore S computes leaftest if and only if S computes leaftest. \nNow consider the following defined function G E F(value), G (x): ~ody of S >. Clearly S computes leaftest \nif and only if G computes leaftest. Therefore G computes leaftest if and only if G computes leaftest. \nBut Theorem 5.1 showed that there exists no defined function  in F( value) which computes leafiest. \nTherefore G , and hence G, do not compute leaftest, contradicting our assumption that some G E F(ref) \ncomputes leaftest. q.e.d. Theorem 5.3: F(vr) < F(name). We know F(name) ~F(vr) by Theorem 5.1, and again \nbased on the definition in [15] of the effect of call by value/result, the construction used in Theorem \n4.2 can be used to translate an arbitrary defined function in F(vr) into an equivalent defined function \nin F(name). Theorem 5.4: F(ref) and F(name) are incomparable. F(ref) and F(name) handle actuals that \nare simple variables in a similar manner, but are distinguished by their respective treatments of actuals \nwhich are not simple variables. For a defined function in F(ref), these actuals are evaluated once at \ndefined function initiation and this value is used whenever a value for the corre\u00adsponding formal is \nrequired, whereas, such an actual to a defined function in F(name) is not evaluated until (and is repeatedly \nevaluated when\u00adever) its corresponding formal is encountered. It is possible to specify code for a defined \nfunction in F(name) which would simulate the effects of call by reference on an actual that is not a \nsimple variable, but the type of actual (simple variable or not) can vary from program scheme to program \nscheme and it is not possible to vary application of the simulation code accordingly. 6. ARRAYS AND ARRAY \nCELLS AS ACTUAL PARAMETERS Throughout this section we consider defined function equivalence with respect \nto the class P(R,A) of program schemes with arrays which allow arbitrary expressions including arrays \nand array celle as actual paramete~s . This hypothesis will be understood and will not necessarily be \nrestated whenever function and class relations are shown. With respect to the class P(R,A) every function \nclass is found to be incomparable to every other pi(v) is false, function class. We found it particularly \nsur\u00adp3(h(v)) is false, prising that the class F(value) turned out to be not only no more but also no \nless powerful than p2(h(v)) is false and P2(Y) is true othewise. the other function classes. Call by \nvalue guarantees that no array cell of any actual array Then Val(S,IIF) = v while S under I IF diverges. \nwill ha~e its value changed. The other mechanisms Therefore, G invokes H. cannot make this guarantee \nsince a defined function cannot save all values from an infinite array Now the formal array A, in G , \nmust be the (or even a finite array for which the bounds are actual parameter to H rather tham a surrogateunknown) \nand the formal array can be passed as an array, say B, in which only a finite number (whichactual to \na defined function which changes the is fixed and independent of the interpretationvalue of some unsaved \narray cell, which is clearly since G consists of straight-line code) of cells beyond the scope of knowledge \nof the original of A can be stored. Otherwise, let cell A[m] be function. one of the cells not stored \nin some cell of array B, and consider an interpretation 12 for which, Theorem 6.1: F(value) and F(mechanism) \nare incomparable , where mechanism E {copy,m,ref, pl(~(v)) is false, k > m, and PI(Y) is true name}. \notherwise , Proof: We know F(mechamism) ~F(value) by Theorem p3(h(fm(~))) is false anfl P3(Y) is true \n4.1. So consider the following defined function otherwise, G E F(value), p2(h(fm(v))) is false and P2(Y) \nis true G(A) : x + H(A) halt(~). otherwise. Assume there exists a defined function G E Then Val(S,12F) \n= v while S under 12F diverges. F(copy) such that G ~ G . Without loss of Therefore, A must be the actual \nparameter to H. generality, assume G contains no basic functions or predicates, hence G? consists of \nstraight-line Now G must pass the same sequence of distinct code , i.e. , the same sequence of statements \nwill values in A to H that G does. Otherwise assume G be executed upon each call of G . And assume. \npasses to H the distinct values a. and an in cells without loss ~f generality, that G has no sub-1 L \nfunctions. A[i] and A[j where i < j, and G! passes the values and a in cells A[r] and A[S] where r > \ns. Now consider the following program s theme al 2 S e P(R,A), where H &#38; F(copy), and G is as defined \nThen conside: an interpretation I for which, above, P3( al ) is false, p3(a2) is und~fined, and (v): \ni+O; H(A) : i+o; is true otherwise. P3(Y AIO] + v; AIO] +h(AIO] ; F Then Val(S,13F) is defined while \nS under I 3 do while pl(v)~ . . do while p3(A i]) diverges. And assume, without loss of generality, \nv + f(v); i 4 i+l; that G passes the same sequence of (perhaps non distinct) values in A to H that G \ndoes. i + i+l; A[i] +h(A i]); A[i] + v; end Now only the same array cells of A (which are fixed and \nindependent of the interpretation since end; halt(A[i]). G consists of straight-line code), say cells \nO u + G(A); through n, cqn be restored to their values when G! was invoked. So G must invoke H only once. \ni+o; Otherwise consider an interpretation I for which, do while p2(u) 94 . p3(h(fJ(v))) is false, J \n> n, p3(h-(z)) is u + g(u); undefined for all z, and p3(y) is true i + i+l; otherwise , end  P2(&#38; \n +l(h(fj(v)))) is false andp2(y is true halt(A[i]) o+herwi~e , pl(~(v)) is false, k > j, andpl(y is true \n Now, Val(S,IF), when defined, will be either fl(v), otherwise. for some i >0, or Q, for all I. Let \nThen Val(S,14F) = fn+l (v) while S under 14F S = S[G+ G ]. Since G does not contain p3 or h, diverges. \nTherefore G invokes H once. then clearly G must invoke H. Otherwise consider an interpretation I ~ \nfor which, But consider interpretation Ih again. Now Val(S,ILF) = fn+l (v), i.e., the value of A[n+l], \n ? The do while control structure can be simulated while Val(S ,14F) = h(fn+l(v)), i.e., the value OY \nby statements defined by our grammar. A[n+l]. Hence Val(S,14F) # Val(S ,14F) => s j! s => G $ G which \ncontradicts our assumption of the existence of G . Therefore there exists no defined function G E F(copy) \nsuch that G ~ G . The result follows similarly when G s {F(vr), F(ref), F(name)}. q.e.d. ~~eorern 6.2: \nF(vr) and F(copy) are incomparable, and F(vr) and F(ref) are incomparable. Call by copy and call by \nvalue/result are distinguished by their defined function termination actions with respect to array cells \nwhich are actual parameters. If an actual parameter is an array cell, the defined function termination \naction for the class F(vr) causes the index of the actual array cell to be evaluated immediately before \nthe value of the corresponding formal is assigned to the array cell. Hence the array cell index is evaluated \nin terms of the current environ\u00adment at defined function termination, rather than in terms of the environment \nat defined function initiation. So in the actual parameter list ( . . . ,i,. ..,A[t],. . . ), where t \nis an arbitraqf expression, if the expression t contains i and if i is assigned a new value at defined \nfunction termination, then this new value will be used in evaluating t as the index of actual A[t] at \ndefined function termination. In contrast, if an array cell is an act71al parameter to a function in \nthe class F(coPy),, then at defined function initiation its index is saved so that at defined function \ntermination the value of its corresponding formal will be assigned to the same array cell that was the \nactual at defined function initiation. Hence the array cell index used at both defined function initiaticm \nand termination is evalua%ed in terme of the environ\u00adment at defined function initiation. Actual array \ncell indices are handled similarly in functicns in F(ref) . Theorem 6.3: F(nsme) ~ F(mechanism), where \nmechanism &#38; {value,copy,vr,ref}. Now that the function classes are augmented with arrays, we cannot \nuse the result of Theorem 5.1 to show that F(name) ~F(mechanism), where mechanism s {value,copy,vr] \nor the result of Corollary 5.2 to show that F(name) ~F(ref) because Constable and Gries [3] have specifiei \na progrsm scheme (which we can represent as a defined fuction) augmented with arrays which computes \nleaftest. Hence a new approach for this result is needed. We note that call by name ?LS distinguished \nfrom the other mechanisms when an array cell with a simple or subscripted variable index and the simple \nor subscripted variable l.ndex both appear as actual parameters to a defined function. Through the index \nparameter a function in the class F(name) can reference and hence modify the value of any cell of the \narray. Theorem 6.4: F(copy) and F(name) are incomparable, F(copy) and F(ref) are incomparable, and F(vr) \nand F(name) are incomparable. When two call by copy or value/result formals have the same corresponding \nactusl, at defined function initiation each formal is given a dupli\u00adcate of the actual and these formals \nare used as two completely independent copies of that (one) actual parameter. But when two call by reference \nor name formals have the same corresponding actual, both formals refer to the single instance of the \nactual. When actuals are not arrays, call by reference or name can easily remedy this difference by making \ncopies of each formal parameter and using these copies throughout the function. However, now that actuals \ncan be arrays, copies cannot be made of infinite arrays (or even of finite arrays whose bounds are unknown). \nTheorem 6.5: F(ref) and F(name) are incomparable, Proof: F(ref) ~F(name) by Theorem 5.4, and F(name) \n~F(ref) by Theorem 6.3,  7. THE INDEX EQUALITY TEST Throughout this section we consider defined function \nequivalence with respect to the class P(R,Ae) of program schemes with arrays and an index equality test. \nWith respect to the class P(R,Ae) every function class is still found to be incompar\u00adable to every other \nfunction class. In general, the proofs which show the function classes incomparable with respect to the \nclass P(R,A) also hold with respect to the class P(R,Ae). Some clarification is needed for the proofs \nof the previous section which use the fact that a defined function G containing no predicates consists \nof straight-line code causing the same sequence of statements to be executed whenever that function is \ninvoked. Even though G now may contain index equality tests which can cause branching, for given arguments \nthe same sequence of statements will still be executed upon each call of G . If no actual parameter to \nG! contains an array index at the time of call of G , and if no defined function invoked by G returns \nan array inde~ through parameters or as the function value (as is the case in the proofs under discussion), \nthen by Lemma 9.3 of [3], the same sequence of statements will be executed upon each call of G . Hence \nthe results of section 6 also hold for this section. 8. PARAMETER PASSAGE MECHANISMS IN COMBINATION \n Our results show as fewer restrictions are placed on actual parameter types, that the distinctions among \nthe mechanisms increase. Once arrays are added to schemes, distinctions are found among all the mechanisms \nso that each parameter passage mechanism considered separately is seen to lack certain powers. Therefore \n, we next look at certain combinations of parameter passage mechanisms, and consider the combinations: \ncallby reference and value (e. g., in PL/1) call by reference and copy (e.g., in some versions of FORTRAN) \ncallby name and value (e.g., inALGOL 60) call by name, value/result, and value (e.g., in ALCOL W) call \nby name, reference, and value (e.g. , in EULER ) , which are represented, respectively, by the function \nclasses F(ref,value), F(ref,copy), F(name,value), F(name,vr,value), and F(name,ref,value). The semantics \nof parameter transmission for a parameter passed to a defined function in, say, F(ref, value) depend \non whether the parameter is passed by reference or by value. If the parameter is passed by reference \nthen the defined function initiation, interpretation of formal parameters, and defined function termination \nas specified for the class F(ref) hold for the parameter, and, similarly if the parameter is passed by \nvalue. A new class of ,A) is defined which includes rogrm Chemes (R~D formal parameter dec aration statements \nin defined functions. These declarations specify whether the formal is passed by value, copy, value/result, \nreference, or name; however, the declaration type must be one of the parameter passage mechanisms of \nthe function class containing the defined function. In addition, in keeping with the language implementations \non which our function classes are based, array parameters to defined functions in a) F(ref,val.ue) and \nF(ref,copy) will always be passed by reference b) F(name,vr,value) will always be passed by name. In \nthe results which follow, defined function equivalence with respect to the class P(RFD,A) will be understood. \nThese results are depicted in Figure 1. F(name,ref,value) ~G[~;\\  L--!L_J Figure 1. Function class relationships \nwith respect to P(RD,A). Theorem 8.1: F(name,vr,value) < F(na.me,value). Proof: We first show F(name,vr,value) \n~ F(name,value ). Let G be an arbitrary defined function in F(name,vr,value), G(xl,. ..,xRG): name X. \n,...,xi ; 11 m value x. ,. .. ,x. ; J1 Jn value/result %1  % ; q *ody> where 1 _< i ~,. . . ,i <RG, \nl~jl,.. .,jn~RG, and m l~kl<k2<.., <k <RG. Then we can con\u00ad ~ struct G! c F(nsrne,value) such that G \n~ G! where G is defined as: G (xl,.. %G) X1  %G; t + G (xl,.. .,xRG,~ ,...,~ ) 1 c1 ~(t) G (yl,.. \n.,yRG,zk ,.-. >z.k ): 1Q name yi ,...,y. ,Z ,. . . ,2 1 1 m 1 q; value yjl ,...>Yj ,Ykl>. ..>Yk ; nq \n<body > where ~ody > is the <body> of G with 1) each occurrence of x replaced by yw, w l<w<RG,  2) each \nstatement, halt(x) replaced by the state\u00ad ments , t+tl; ; halt(t) kl kl; ;zk k q~ where , r ifx=x inG, \nl<w<RG Yw w t = x otherwise. L Note, all arrays which are formal parameters in defined functions in \nF(name,vr,value) are passed by name, hence in G no z l~t~q,is t replaced by an array name. And if z \nis not t replaced textually by a simple or subscripted variable, then the statement, Zk + y , is t t \nignored, which is the desired effect. To show F(name,value) $F(name,vr,value) consider defined function \nG of Theorem 6.1 and let G &#38; F(name,value) where formal array parameter A is declared a value parameter. \nSince all formal array parameters of any defined function in F(name,vr,value) must be declared name, \nour result follows immediately from Theorem 6.1. q.e.d. Theorem 8.2: F(ref,value) < F(ref,copy). Call \nby value formals can be simulated easily by call by copy formals. But all call by copy formals are evaluated \nand have their values saved at defined function initiation while only call by reference formals which \nare not simple or sub\u00adscripted variables or arrays are evaluated and have their values saved at defined \nfunction initiation. This difference in defined function initiation action distinguishes the classes \nF(ref,value) and F(ref,copy). Theorem 8.3: F(name,vr,value) and F(ref,value) are incomparable, F(name,vr,value) \nand F(ref,copy) are incomparable, F(name,value) and F(ref,value) are incomparable, and F(name,value) \nand F(ref,copy) are incomparable. Theorem 6.3 shows that call by name cannot be simulated by any other \nparameter passage mechanism. At defined function initiation the indices of call by reference array cell \nactuals are evaluated and the value is fixed as the index of the array cell actual throughout execution \nof the defined function. This is not the case for call by name or value/result array cell actuals. Hence \nthe classes including call by name or value/result and the classes including call by reference are found \nto be incomparable. Corollary 8.4: F(nane,value) < F(name,ref,value). Proof: Obviously, F(name,value) \n~ F(name,ref,value) . The proof of Theorem 8.3 shows that there exists no defined function G E F(name,value) \nsuch that G ~ G where G E F(ref,copy) and all formal parameters of G are declared reference. Clearly \nG s F(name,ref,value), therefore F(name,ref,value) $F(name,value). q.e.d. Theorem 8.5: F(ref,copy) < \nF(name,ref,value). The proof that F(name,ref,value) ~ F(ref,copy) is similar to the proof of Theorem \n6 .3. To prove that F(ref,copy) ~ F(name,ref,value) we show that defined functions in F(ref,copy) using \ncall by reference and call by copy can be simulated by defined functions in F(name,ref,value) using call \nby name and call by reference. Simulating call by reference is clearly no problem. However in F(ref,copy) \nwhen the formal parameter list is examined from left to right at defined .function initiation, all alstual \ncopy parameters are evaluated and assigned to their formals when they are examined. If these copy parameters \nare all passed by reference in F(name,ref,value) then simple and subscripted variables won t be evaluated \nwhen they are examined at defined function initiation. So in order to ensure that the parameters passed \nby copy in F(ref,copy) are evaluated in the ProPer sequence in F(name,ref,value), in F(name,ref,value) \nwe will have as many defined functions as there are parameters and each param eter is passed to every \nfunction. Parameters will be passed by reference to these functions in the same order in which they would \nbe examined in F(ref,copy). Parameters which would not yet have been examined in F(ref,copy) are passed \nby name, thus delaying defined function initiation. Parameters which would already have been eXElmined \nin F(ref,copy) could be passed either by reference or name, so we have chosen to pass them by reference. \nWhen a parameter is passedby reference for the first time in F(name,ref,value), if the parameter is declared \nreference in F(ref,copy) then the defined function calls proceed. However, if the parameter is declared \ncopy in F(ref,copy) then the value of the reference formal is assigned to a locaS variable which is used \nthroughout the remainder of the function and whose value is reassigned to the reference formal prior \nto defined function termination. The function calls then proceed. 9. CONCLUSION Comparing our results \nwith Snyder s and Leinbaugh s, we see that the techniques of  function schemata did allow us to derive \na new (andwe propose, more precise) characterization of parsmeter passage mechanisms. Most of Snyder \ns and Leinbaughfs translation constructions were quite inefficient and in [IL] Snyder states about his \nresults that if our constructions cannot be mad@ more optimal, then this suggests that there is a difference \nbetween these classes [of program schemata based on different parameter passage mechanisms] which we \nhave not had the mechanism to recognize . We suggest that function schemata is this mechanism. It forces \nthe defined function initiations , interpretations of formal parameters, and defined function terminations \nfor the mecha\u00adnisms under analysis to be made with respect to the same environment, thus providing a \nstronger yet still quite reasonable notion of equivalence. This stronger notion of equivalence has formed \nthe basis for our results which illuminate differences in the mechanisms which Snyder referred to while \nyielding efficient and easily implemented trans\u00adlations between defined functions in classes where translations \nare shown to exist. REFERENCES [1] Chandra, A.K., On the properties and applica\u00adtions of program schemes, \nStanford Univers\u00adity, STAN-CS-73-336, 1973. [2] Clarke, E.M., Jr., Programming language constructs for \nwhich it is impossible to obtain good Hoare-like axiom systems, Proceedings of the Fourth ACM Symposium \non Principles of Programming Languages, 1977. [31 Constable, R.L. , and Gries , David, On classes of \nprogram schemata, SIAM J. Comput. , 1, 1972, 66-118. [4] Critcher, A., Function schemata, Computer Science, \nThe University of Iowa, TR 78-05, (Ph.D. Thesis), 1978. [51 de Bakker, J.W., Least fixed points revisited, \nProceedings of the Symposium Held in Rome, Lambda Calculus and Computer Science Theory, March 25-27, \n1975, from Lecture Notes in Computer Science, 37, 1975, Springer-Verlag, edited by G. GOOS and J. Hartmanis. \n[6] de Roever, W.P., Recursion and parameter mechanisms: an axiomatic approach, proceed\u00adings of the Second \nSymposium on Automata, Languages, and Programming, Saarbrucken, July 29-Aug. 2, 1974, from Lecture Notes \nin Computer Science, 14, 1974, Springer-Verlag, edited by Jacques Loeckx. [71 Fleck, A.C., On the impossibility \nof content exchange through the by-name parameter trans\u00admission mechanism, SIGPLAN Notices, 11, Nov. \n, 1976, 38-41. [8] Langmaacker, H. , On correct procedure param\u00adeter transmission in the higher programming \nlanguages, ACTA Informatica, 2, 1973, 110-142. [91 Leinbaugh, D.W., Finite array schemata, Computer Science, \nThe University of Iowa, TR 75-05, (Ph.D. Thesis), 19 75.  [10] Manna, Z. , and Vuillemin, J. , Fixpoint \napproach to the theory of computation, corm. ACM, 15, 1972, 528-536. [II. ] Paterson, M. S., and Hewitt, \nC. E., Compara\u00ad tive schematology, Conference Record of Project MAC, Conference on Concurrent Systems \nand Parallel Computation, ACM, New York, 1970, 119-128. [12] Plotkin, G.D., Call-by-name, call-by-value, \nand the lambda calculus, Theoretical Computer Science, 1, 1975, 125-159. [13] Robertson, E.L., The use \nof associative memory in implementing call-by-name param\u00adeters, Computer Science, Pennsylvania State \nUniversity, TR-175, 1975. [1~] Snyder, L., An analysis of parameter evaluation for recursive procedures, \nPh.D. Thesis , Carnegie-Mellon University, 1973. [15] Wirth, Niklaus, and Hoare, C.A.R., A contribution \nto the development of ALGOL, COMM. ACM, 9, 1966, 413-431.  \n\t\t\t", "proc_id": "567752", "abstract": "", "authors": [{"name": "Adrienne Critcher", "author_profile_id": "81100159744", "affiliation": "Baylor University, Waco, Texas", "person_id": "PP39030255", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/567752.567767", "year": "1979", "article_id": "567767", "conference": "POPL", "title": "The functional power of parameter passage mechanism", "url": "http://dl.acm.org/citation.cfm?id=567767"}