{"article_publication_date": "01-01-1979", "fulltext": "\n SPECIFYING Permission to make digital or hard copies of part or all of this work or personal or classroom \nuse is granted without fee provided that copies are not made or distributed for profit or commercial \nadvantage and that copies bear this notice and the full citation on the first page. To copy otherwise, \nto republish, to post on servers, or to redistribute to lists, requires prior specific permission and/or \na fee.&#38;#169; 1979 ACM 0-12345-678-9 $5.00 PROGRAMMING LANGUAGE SEMANTICS: A Tutorial and Critique \nof a Paper by Hoare and Lauer by 1. Gretf and A. Meyer Massachusetts Institute of Technology Cambridge, \n1, Introduction Hoare and Lauer [1974] have advocated us!ng a variety of styles of programming language \ndeftnltlons to fit the variety of users from Implementers to program verifiers. They consider the question \nof whether different definitions and specifications determine the same language by showing that the definitions \nare what they call consistent . 1Iowever, their treatment skirts the quesrlon of whether their definlt}ons \ncan each be taken to specify the language adequately. Although, as we WIII show, any one of the kinds \nof semantics they discuss -\u00ad-operational, relational, deductive --can be used to Specify meaning uniquely, \nHoare and Lauer do not make the case in their paper. In fact, both their relational and deductive definitions \nare satlsfled by several different semantics, only one of which n desired. Thus, the main point of this \npaper IS to clarify the characteristics of a proper specification of language semantics and to formulate \nalternative specifications each of which IS equally good as the language deflnltlon. We basically agree \nwith Hoare and Lauer that several speclflcatlons can and should be given, but are disturbed by confusions \nabout such speciflcattons. some of which are Illustrated in their paper. In particular we refer to confusions \nbetween the mathematical object which is designated to be the meaning of a program and methods for specifying \nthat object; the similar confusion between predicate and expression; between consistency and equivalence \nof two deflnltlons; between completeness of a theory and its having a unique model. While these issues \nare fam]llar in mathematical logic, we take this opportunity to survey them m the context of programrmng \nlanguage semantics. This paper can be read w!thout prior fam]}larity with Hoare and Lauer s paper. The \nauthors plan another paper extending this work which will include a more comprehensive bibhography. \n2. The Programming Language Following Hoare and Lauer, we Will examine alternative types of deflnltlons \nof a trivial language with primitive statements, rukile statements, and statement lists. The syntax, \nommmg details of the form of predicate expressions is as follows Massachusetts <program> := <prlmlttve \nstatement> I <while statement> <program> ;<program> I NOP <while statement> ::= while <predicate expression> \ndo <program> As M usual with abstract syntax, we will not concern ourselves with ambiguity in parsing \nor wjth detailed syntax of expressions and pr]mltlve statements. We assume that programs run on machines \nwith states. We treat the states slmpiy as abstract elements In some fixed set S, Ignoring their jnternal \nstructure In many familiar examples prilmltive statements define total functions from states to states, \nbut we need not make this assumption. Primitive statements may be. partial, I.e. for some state J there \nmay be no related state, and nonfuncfLona12, I.e for some states s there may be more than one related \nstate. A prlmlttve statement, A, thus has an effect on states which can be defined by giving a relatlon \nRA c SXS such that (J, J ) e RA iff A executed in s can term{nate Instate J . For example, if states \nassoctate values with variables, and prvmltlve statements are assignments u := e where u IS a variable \nand e IS an expression which can be evaluated ]n any state, then an assignment certain states which differ \nonly at the value of A predicate P IS a mapping from values, Predicate expressions p, q,.. appear WIII \nuse P, 0+ , respectively, to denote statement relates the variable U. states to truth In programs. We \nthe predicates corresponding to these expressions. For slnlpl~clty, we assume that predlca[e expressions \nalways yield values, so that the predicate P assoctatetl with an expression p IS true or false at each \nstate and IS never undefined. Hoare and Lauer give two operatlonai this simple lan~uage The ftrst M an \nabstract can execute program steps The second IS a maps programs Into their computations, where a fmlte \nsequence of states, namely the successive reached during execution of the program. definitions of rnachlne \nwhich function which a computation IS states which are These two cieflnltlons are said to be consistent \n In that for any program a both define the same relatlon Ra of Initial to final states. This relation \nRa c SXS ls such that (J, J ) G Ra if and only if, when started In state $, program a halts (It has a \nflnlte computahon) and the final state of that computation M S$. 180 We use the followlng notation throughout \nwhat follows a, b, c programs, A primitive statements, J, t states (elements of the set S of all states), \npredicate expressions,P, q predicates on states, f , Q L, M, R binary relations on states (subsets of \nSXS). Each of these letters may appear with subscripts or multiply primed, e.g., $2 s , ~, WC 3. Relational \nSemantics A relat!otlal semantics assigns to each program a an mitlal-state, final-state relauon. We \ncan express the proper relational semantics for our language directly by defining the relations Induced \nby programs as In [deBakker, 197a Pratt, 1976; de Bakker and Meertens, 1975]. Hoare and Lauer give an \naxiom system for triples s(a)~ such that (s, J ) IS in the relation Induced by a. We present both a complete \naxiom system and a deductive system for these triples. 3.1 The Standard Relational Semantics A slrnple \ndef;nitlon of the relatlon Ra to be associated with any program rr can be given by Induction on the syntax \nof programs, using only familiar rnathernatlcal operations on relatlons In order to do this It M convenient \nto define R p for any predicate expression p to be {(s, J) I P(J)}. For RI, R2 C SXS, let RI : be the \nreflexlve transitive closure of R,, and R1~R2 the composmon of RI and R2 We assume that relations RA \nfor each [JrlfIMtl Ve statement A are given. That Is, we assume that we know what the prlm!t[ve statements \nmean. Let 1 be the ident!ty relation {(J, J) I J e S}. Then the relations associated with programs are \ndefined as follows: R1. RNOP = 1, R2. Rfl;b = RaoRb, 3 R while p do a = RpORa)~OR -q3- These relations \ndescribe the standard semantics for our language To see this, note that NOP does not change the state \nand that the program a;b started in state J w(II end in state s Iff there is a state f such that a started \nin s ends in state t and 6 started In t ends ]n $ . Slmllarly, for wkilc loops there must be a sequence \nof stztes between Initial state, 5, and final state, J , such that m each state but the last P IS true \nand each pair of successive states is related by Ra. In the final state -P must be t] ue. If 1P(s) is \ntrue for some state s, then while p do u acts like a Nc3P, that IS, (s, S) E Rluhl[e p ~0 a. This relational \nsemantics obviously gives exactly the same mean]ng to programs as do the Interpretive and computational \nsemantics of Hoare and Lauer. We shall henceforth refer to this as the standard relational semantics \nR. 3.2 Some Axioms for the Standard Relational Semantics Hoare and Lauer choose to specify the standard \nrelational semantics by glvmg a system of axioms for statements of the form started In s, program a \nterminates In state J . We shall refer to such assertions as transition assertion s-, and follow Hoare \nand Lauer in using the notation s(a)s to denote such a statement. Thus s(a)J M true for M iff (s, s \n) G .Ma, where M is an arbitrary relational semantics which assigns to each program a some relation MUCS \nxS. Their axioms3 are as follows: HLI, J(A)J ++(J, J ) c RA, HL2. s(a;b)s + 3t[+z)t A t(b)s 1, HL3. \ns(w~ile p do a)s -+ 7P(s ), HL4. Vsl, J2[(OJS1) A P(sl) A S1(IZ)S2)+ C&#38;2)1 + [(QQ) A s(whi~e p do \na)s ) +QJs )1, HL5. f(NoP)s ++J = s . They go on to prove that the standard relational semantics R n \na model of HL1-5, that Is, every instance of HLl\u00ad5 IS true for R, so that any conclusion wh]ch logically \nfollows from these axioms will be true of the standard semantics. Of course this meets only half the \nrequirements for specifying the semantics, since one must also show that any transition assertion which \nIS true of the standard semanttcs follows loglcally from the axjoms, Unfortunately HLI-5 do not Imply \nall the true assertions, contrary to the intuitive confidence in the completeness of the theory expressed \nby Hoare and Lauer (cf. [Hoare and Lauerl p. 144), as we now Illustrate. We can understand the s}gniflcance \nof HL1-5 as follows. If ~ is a model of Hl, we can conclude that MA = RA for each atomic statement A. \nSimtlarly, from HL5 we conclude that MNOP = I = RNOP, and from HL2 that Ma;b . kfaof vfb. It follows \nthat Ma = Ra for every while-free program a whenever M is a model of HLI, 2, 5. 181 Now consider the \nparticular divergent loop relational semantics L defined as follows: La = Ra if a is whi[e-~ree, La \n= C#Iotherwise. Then L M obvmusly a model of HLI, 2, 5. But dwhile p do a)J is aiways false for L, so \nHL3-4 are true, vacuously, for L. Hence L is also a model of HLI-5. The divergent loop semantics corresponds \nto an implementation In which the Interpreter simply 100fJs unconditionally whenever It starts to execute \na wAi[e statement. Since L is a model, statements which Ioglcally follow from HLI-5 must always be true \nof this implementation. I.n particular, no transition assertion lnvolvtng a program containing a witile-loop \nfollows from HL1-5, and so It seems hard to imagine circumstances In which HLI-5 would serve as an adequate \ncharacterization of the standard semanttcs. (However, In section 4.4 we shall indicate a natural sense \nin which HLI-5 do In fact specify R ) 3.3 A Complete Set of Axioms for the Standard Relational Semantics \nThere n no inherent obstacle to presenting axioms in the splrlt of HLI-5 which correctly and completely \nspecify the intended semantics. Indeed, adding two more axioms will suffice; HL6. ---IP(s) + s(while \np do a)s, HL 7. P(s) A s(a)s A s (whi[e p do a)t + s(w/iile p do a)t. it IS easy to ver]fy that the standard \nsemantics is a model of HLI-7. In the appendix we prove Theorem 1: The standard relational semantics \nis the only model of HL1-7. We remark that HL1-7 can be shown to be independent, I.e., Theorem 1 M not \ntrue when any one of HLI-7 IS omitted. 3.4 A Deductive System for the Standard Relzjtlonal Semantics \nAnother, perhaps more straightforward, way to specify the standard relational semantics is to give a \nsystem of axioms and Inference rules for deducing trans!tlon statements. One such system is: Axioms ~ \nTl, s(A)s , for all s, J G S such that ($, $ ) G RA, T2. J(NOP)S, T3. s(w~ile p do a)s, for all $ e S \nsuch that --IP(J). Inference Rules: T5 s(a)t, [(while p do a)s I-s(cuhtle p do a)s , for all s E S such \nthat P(J). Let Th(T1-5) be the set of transition statements provable from TI-3 using T4-5. A routine \nproof, the details of which we omit, Impltes that ~(a)s G Th(T1-5) tf and only if ($, J ) e Ra. That \nIs, Theorem 2: The set of transition assertions derivable in the system TI-5 is equal to the set of transition \nassertions true for the standard relational semantics. Thus, the deductive system T1-5 specif[es the \nsame re]ationai semantics as RI-3, and either can serve as the definitive spectficatlon (We caution the \nreader not to confuse this deductive specification of a relational semantics with the deductive ~emarrtics \nof Hoare and Lauer menttoned in section 4.5 of this paper.) 4 Partial-Correctness Semantics AssertIons \nof the form if P holds before executing a, then If and when a halts, Q WIII hold occur frequently when \nthe behav]or of programs IS being described. Such assertions are called par[ial correctness assertions \n(pea s) and are abbreviated P{a}O< We define a partial correctness semantics for our programming language \nto be an arbitrary set of pca s. Any relational semantics M naturally determines a corresponding partial \ncorrectness semantics ~ cons, sting of those pea s P{cz}Q which are true when the jnltlal-state, final-state \nrelatlon of a is that given by M. The thests that a programming language semantics could be specified \nby glvlng all the before-after assertions true of programs has been espoused by Dljkstra [1975, 1976]. \nAn effort by Hoare and Wlrth [1973] to specify the semantics of a fragment of PASCAL using pea s supports \nthe practical Our desire to Investigate this aPPllcablllt Y of this thesis general thes}s motivates our \ndefinition and analysis of partial comectness semantics in this section. We show how a relational semantics \ncan determine a partial correctness semantic and vice versa. We give a complete deductive system for \npea s and an axiom system for pca s. The sig n Iflcance of spectficatlons which have many relational \nmodels is considered, and we analyze several such speclflcatlons. 182 4.1 The Standard Partial Correctness \nSemantics Definition 1: Let R be a binary reiatlon on states. P{u)Q is true for the relation R iff (Vs,s \n) (P(s) A (s, s ) e R + @ )). P{a)Q is true for c relational semantics M lff It is true for Ma, The partial \ncorrectness semantics containing exactly the pea s which are true for R is referred to as the standard \npartial correctness semantics, Il. An arbitrary set of par[lal correctness assertmns for a program a \nalso determines a relatlon. The relatiom is the maximum relation, M, such that all the pea s in the set \nare true for M. (That there always is such a maximum relation is shown in the appendix, Lemma Cl.) The \nrationale for taking this relation to be the one determined by a partial correctness semantics is njcely \nexpressed by Schwarz [1974]: Asserting a partial correctness statement is essentially asserting that \ncertain environments are not the results of executing some command starting in certain olther environments. \nThis is a negative requ!rernent, it does not force any environment to be the result of any execution, \nSince this is the inherent nature of the formalism it indicates that the proper kincl of definition of \nthe semantics determined by a system should have the form: largest possible semantics. - Dejirrition \n2: Let ~ be an arbitrary set of pea s and for any program a, let ma be the set of all pea s In ~ of the \nform P{a}O< Then rnax(~a) IS the maximum relation M such that all pea s in ma are true for M. We prove \nm the appendix that taking the maximum relations determined by any partial correctness semant]cs provides \na way to recover an underlying relational semantics If there is one. Formally we have Lerrrma 1: Let \n~ be the set of pea s true for a relational semantics M. Then Ma = max(~a). In particula~r, Ra \u00ad max(~c). \nThe slgnlflcance of Def~nltlon 2 and Lemma 1 is that R and R convey exactly the same Information --either \none uniquely determmes the other. 4 This implies that, If we prefer, we can choose a partial correctness \nsemantics to specify meaning. Such a partial correctness semantics sacrifices nothing provided by a relational \nsemantics, since any desired relational semantics, M, can always be recovered from an appropriate partial \ncorrectness semantics, namely, the one which consis[s of the partial correctness assertions true for \nM. 4.2 Deducing Partial Correctness The standard partial correctness semantics can, hke the standard \nrelational semantics, be speclfled by a simple system of ax!oms and inference rules. The notion of the \nrsreake$t antecedent, [R]Od of a ptedlcate Q under a relation R M used in the axioms for prvmttlve instructions. \n]nformally, [R]Q is the predicate on states which is true of a state s providing that: if and when a \nprogram with initial-state, final-state relation R halts after being started in s, the predicate Q will \nhold. Definition 3: Let R be a binary relation on states. For any predicate Q on states, the weakest \nantecedent of Q under R is a predicate, [R]Qon states defined by ([RIQ(J) iff (VS )[($ s ) ~ R + QJs \n)]. It follows immediately from Deflnitlons 1 and 3 that ([ MalQ){a}O~is true for any relational semantics \nM. We abbreviate VS(P(J) + C&#38;)) by t=(P + Q and note that P{a}Q is true for R ]ff I=(P + [R#J, which \nis why [M=]Q is called weakest . (cf. [Pratt, 1976; Harel, Meyer, Pratt, 1975; Schwarz, 1974)). The followlng \nsystem IS usually referred to as the Floyd-Hoare system for partial correctness. Axioms: FHI. P{ NOP}P, \nFH2. ([RA]OJ{A}Q Inftrence Rules: FH3. P{a]P , P {b]Ow +-P{a; b]~ FH4. (P A OJ{a)Qw I-Qjw/rile p do a](Q \nA Y P), FH5. P{a]Q+-(P A P ){a}(Q V ~) We prove in the appendix, Theorem 3: The set of pea s derivable \nfrom FH1-5, is equal to ~, the standard partlai correctness semantics. We have formulated Theorem 3 to \nemphasize our view of the system FH1-5 as a specification of a mathematical object, namely the set Th(FH1-5) \nof derivable pca s. The more farmhar viewpoint m the literature would be to presume that truth of pea \ns was always to be reckoned relative to the standard relational semantics. Theorem 3 could then be formulated \nas say]ng that FHI-5 M $ound --only true pea s can be derived -\u00adand complete --all the true pea s can \nbe derived. The system FH2-4 corresponds to the Deductive Theory5 D1-3 of Hoare and Lauer, p. 146. The \nsystem FH1-4 is not complete, but we will see m section 4.5 that there IS a sense in which the incomplete. \nsystem FHI-4 specifies the standard semantics. 43 Axioms for Partial Correctness Semantics 4.4 Relational \nModels for Partial Correctness Specifications Although a deductive system resembling FH1-5 is the more \nusual specification of the standard partial correctness semantics, we can also write an ax[om system \nto specify It. The axioms are suggested straightforwardly by the deductive systent PCI. [P{ NoP]QJ -I=(p \n+ C??, PC2. [P{A)QJ ++ I=(P + [RAIQJ PC3. [P{a;b)Q ++ 3P (P{a}P A p {bK?J, PC4. [Qwhile p do alQ 1 + \n3Q [ [(p A Q ){a)Wl A I=(Q -Q) Al=((Q A-p)+Q )]. To say how these axioms specify the partial correctness \nsemantics we must give a technical meaning to the term model and dlstlngulsh several special kinds of \nmodels. A mathematical object M said to be a model for a set of assertions jf all the assertions are \ntrue for the object. We have already used this notion In section 3 where the objects were relational \nsemantics and the assertions were translt[on assertions. We will be using different kinds of objects, \nfor example, both relatlons and sets of pea s, as models of sets of assertions. The assertions themselves \nmay simply be pea s, or they may be more complicated kinds of mathematical assertions such as PC1-4. \n(We will not need and therefore ornlt a more precise explanation of what mathernatlcai assertions are \nthan ]s provided by the example of PCi-4,) The following definition establishes how a partial correctness \nsemant[cs can serve as a model. De~tnitiorr 4: A partial correctness semantics ~ satisfies a mathematical \nassertion (In wh[ch pea s may appear as subassertlons) lff the assertion s value can be calculated to \nbe true when precisely the pea s in ~ are assigned the value true. A partial correctness semantics M \na model for a set of assertions If It satisfies every assertion m the set. A partial correctness semantics \nIs a partta~ correctness model for an axiom system (such as PCI-4) If It is a model for the set of all \nInstances of those axioms. Theorem 4(deBakker6): H M the only partial correctness model of PCI-4. The \nproof M m the appendix. Again, we have formulated this theorem to emphasize our view of PCI-4 as uniquely \nspecifying a particular partial correctness semantics. We consider next the more usual view of PCI-4 \nas specifying a relational semantics. We have Just considered FH1-5 and PC1-4 as direct specifications \nof partial correctness semantics. However, since relational semantics detelmlne truth values for pea \ns by Deflnitlon 1, we can regard a relational semantics as a possible model of a set of pea s or similar \nmathematical assertions. Therefore we can also consider FHI-5 and PC1-4 as speclflcat!ons of telatlonal \nsemantics according to their relational models, Thus we can rephrase Theorems 2, 3 and 4 in part by saying \nthat R M a mopel of TI-5, FH1-5 and PC1-4.7 Notice that despite Theorems 2 and 3, we cannot say that \nR is the only model of T1-5 or FH1-5. For example, the empty semantics which assigns the empty relation \nto every program n a model of FH1-5, and the semantics which assigns the total relation SXS to every \nprogram M a model of TI-5. A set of pea s WIII generally fail to have a unique relational model because \npea s are antj-monotone In the foliowlng sense, If M and N are relational semantics then we shall say \nthat N IS larger than ~ Iff Na o Ma for all programs a. Then by Deflnltlon 1 we see that If P{a}Q IS \ntrue for N, and N is larger than ~, then P{c}QM also true for M. Thus, since R is a model of FHI-5, so \n]s any relational semantics smaiier than R.8 On the ot}ler hand, Theorem 3 and Lemma 1 together umply \nthat R IS larger than any model of FHI-5, so we can conclude Theorem 5; The standard relational semantics \nis the largest model of FHI-5. Similarly, transition assertions are monotone m the sense that If s(a)~ \nIS true for M, and N IS larrrer L, than M, then s(a)~ IS true for N. We conclude from Theorem 2 that \nTAeo?em 6: The standard relational semantics 1s the smallest model of TI-5. Finally, we . ,] deduce flom \nTheorem 4 that Thotcm 7: The standard rciatlonal semantics IS the only model of PC1-4 Thus, Theorems \n5, 6, and 7 treveal precisely the dlffereni ways In which R IS decermlned uniquely by the specifications \nFH1-5, T1-5, PG1-4. We should point out that Theorem 7 IS technically a slightly weaker lresult than \nTheorem 4. Theorem 7 in effect asserts that among the partial correctness semantics which are dctcrmlned \nby relational semantics, only the partial correctness semantics ~ determined by R IS a model of PC1-4. \nOn the other hand, Theorem 4 asserts that among all partial correctness semantics, not just those determined \nby relattons, R IS the unique model. 184 45 Implications Between Incomplete Semantical Specifications \nLemma 2: If M is a model of FHI-2 and the inference rules FH3-4 are sound for M, then M IS a model of \nFH1-5. The need to deal with specifications having several models of a given kind was allowed for by \nHoare and L,auer in their formulation of what they call consistency-between semanttcal speclf]cations. \nThey say that one specification is consistent with another Iff every model of the latter M a model of \nthe former. Notice that this definition IS asymmetrical, and so con fllcts with orclmary usage of the \nword consistency. For this reason, we shall ~efer to implication between speclficatlons, that is, speclflcatlon \nS m]phes speclficat!on T Iff every model of S is a model of T. Seimanucal speclflcatlons with more than \none model can be useful. We have just seen that while FHI-5 and TI-5 technically speaking have many models, \nnevertheless they uniquely specify R in a natural way as the largest relational model and sma Ilest relational \nmodel, respectively. Eveln more generally there may be situations in which any of several models would \nsuffice for some appilcatlon, and we wish only to specify this set of appropriate models --not necessarily \ndlstlngunhlng a canonical model in the set by some criterion such as maxlmallty or minlmallty. For example, \nin the specification of practical programming languages It is typical to leave undefined the meaning \nof certain syntactically well-formed programs. In such cases there will be many acceptable semantics \ndiffering only on the meanings, e.g., error messages, they assign to meaningless programs. In addltlon \nto the axioms HLI-5 considered above, Hoare and Lauer offer the first four rules FH1-4 of the Floyd-Hoare \nsystem (cf. footnote 5) as a spec(flcatlon with rnultq31e relational models, and they seem to suggest \nthat these rnultlple models represent possible acceptable semantics. However, when we look more closely \nat the Hoare-Lauer and Floyd -Hoare axioms we shall see that an example of a speciflcatiorr which could \nbe met by many acceptable semantics does not arise here; there is only one Intended model of these particular \nspecifications, although it takes some effort to discover the sense In which these spectflcatlons determine \nthat model. In particular, Hoare and Lauer observe [Hoare and Lauer, Theorem 41 that HLI-5 Implles the \nfirst four Floyd- Hoare rules FHI-4.9 For some reason they do not consider the converse question of whether \nFHI-4 imphes HL1-5. In fact, It does not; not even the full Floyd-Hoare system FH1-5 implles HL1-5. This \nIS because any M smaller than R is a relational model of FHi-5, so that, for example, the empty semantics \nis a model of FH1-5 but not of HLI-5. However, Hoare and Lauer s proof that HL1-5 implles FHI-4 actually \nestabhshes a sbghtly stronger result which we can use to reveal the connections between HL1-5, FH1-4, \nand ~. An Inference rule such as any of FH3-5, T4-5 WII1 be called sound for a relational semantics M, \nIf, whenever the conditions (such as those for T5) for applicability of the rule are satnfled and the \nantecedent(s) of the rule is true for ~[, so IS the consequent, III other words, an Inference rule is \nscmnd if appijcat]on of It preserves truth. Proof: It is easy to see that FH5 is sound for all M. I Theorem \n9: R is the largest model of FH1-2 for which the jnference rules FH3-4 are sound. Proof: We let the reader \nconvince himself that FH3-4 are sound for the standard relational semantics E (cf. [Hoare and Lauerl, \nTheorem 4). Thus, R IS a model; that it IS the largest model is immediate from Theorem 5 and Lemma 2.i \nLemma 3( Hoare and Lauer): Let M be a model of HL1-5. Then M is a model of FH1-2 and the Inference rules \nFH3-4 are sound for M. We shall not repeat the proof (cf. [Hoare and Lauer], page 147). Theorem 9: R \nIS the largest model of HLI-5. Proof: lmmedlate from Theorem 7 and Lemma 3.1 The preceding theorems thus \nreveal the sense in which HLI-5 and the first four Floyd-Hoare rules FH1-4 serve as semantlcal specifications \neqtslvalent to the others we have considered --a rather obscure sense which was Ietl implicit in [Hoare \nand Lauerl.]o Our point here is that while we agree with Hoare and Lauer that reiatlonshlps hke Imphcations \nbetween specifications with multiple models are Important Ideas, It is even more mlportant to have a \nclear understanding of the family of models which are to be regarded as meeting the specifications. This \nis illustrated by the fact that the semantics L of section 3.2 is a relational model both of HLI-5 and \nFH1-5, yet we certainly do not mean to accept an Implementation of our language in which all while-loops \ndiverge. 5. Concitrslon We have looked at two kinds of semantics --relational and partial correctness \n--and several means of specifying a semantics --Inductive deflnltlons, axiom systems, deduction systems, \nEach semantics can be specified in several ways. There was no particular technical problem In rigorously \ndeflnmg how specifications determined semantics. The set of all partial correctness assertions true \nfor our trivial programming language gives exactly the same reformation as the relational semantics; \na speclflcatlon which determines the pca sernanrlcs also determines the relational semantics. This IS \ntrue despite the fact that In a certain narrow technical sense partla I correctness assertions cannot \nbe used to express termination of programs. Either kind of semantics can be specified using an axiom \nsysten,l or a deductive system; either semantics determines the other, Independent of, means of specification. \nThe results of this paper can be extended to other semantics and other means of specification, for example. \npredicate transformer semantics. For determtnlstlc programs, the results are slmllar to those for pca \ns. The situation is more complicated for non-deterministic programs (cf. [HQare, 1978; Harel and Pratt, \n1978]). Syntax played a secondary role In this paper. Only programs were syntactic objects; predicates \nwere treated as mathematical, set-theoretic objects. The next refinement of the study begun here Involves \nrestricting predicates to those which are definable In some agreed-upon formal notation, e.g., first \nor second order Ioglcs of appropriate structures. When we restrict predicates In this way the situation \nbecomes more complicated \u00adand more interesting -and the conclusions we reached above about the equivalence \nof various kinds of semantics must be refined Thus, there are cases where the set of all true definable \npea s may not determine the proper relational semantics; In other cases a restricted deductive theory \nmay contain only a subset of all true definable pea s and yet determine the right semantics. We postpone \nto a later paper further discussion of predicate transformer semantics and the restriction to deftnable \npredicates. In sum, we have Illustrated that attempting to specify the meaning of a language in several \nways can be made to work at least for very simple programming languages when we -. place no restrictions \non the language for predicates. However, care had to be taken to lndlcate how each speclflcatlon was \nto be understood before it could be apphed by any of the variety of possible users. 6. References [The \nreference section of this paper does not constitute a complete blbhography on the subject.] deBakker, \nJ.W. 1975. Flow of Control ]n the Proof Theory of Structured Programming. 16th Annual Symposium on Foundrztionj \noj Computer Science. IEEE Computer Society. Long Beach, Ca. pp 29-33. de Bakker, J.W. 1977. Recursive \nPrograms as Predicate Transformers. Proc. IFIp Conf. on Formai Specifications of Programming Constructs. \nSt. Andrews, Canada. pp 7.1-7.15. de Bakker, J.W. and L. G.L.T. Meertens. 1975. On the Completeness of \nthe Inductive Assertion Method. Journal of Computer and Systems Science, 11, pp 323-357. Dljkstra, E \nW.D. 1975. Guarded C.ornmands, Non-determ]nacy and Formal Derlvatlon of Programs. CACM 18. 8. pp 453-+57. \nDljkstra, E.W.D. 1976. A LMcipline of Programming, Prentice-HaIi, Englewood Chffs, N.J., 217 pp. Harel, \nD. 1978. Log]cI of Programs: Axiomatic and Descrtptlve Power. Laboratory for Computer Science Technical \nReport 200. M. I. T.,Cambridge, Mass., 152 pp. Harel, D., A R. Meyer, and V. Pratt. 1977. Computability \nand Completeness in Log Ics of Programs. Proc. OJ 9th Annual ACh! Symposium on Theory of Computing. Boulcler, \nColorado. pp 261-268. Harel, D. and V. Pratt. 1978. Nondetermlnism Ln Logics of Programs. Conference \nRecord of the Fifth Annual Sym/sosium on Principles of Programming Languages. Tuscon, Arizona. pp 203-213. \nHoare, CAR. 1978. Some Properties of Predicate Transformers JACM 25, 3 pp 461-480. Hoare, C.A. R. 1969. \nAn Axlomatfc Basis for Computer Programming. CACM 12, 10. pi) 576-583. Hoare, C A.R. and P. Lauer. 1974. \nConsistent and Complementary Formal Theories of the Semantics of Programming Languages. Acts /nformatica \n3, pp 135-155. Hoare, C A.R. and N. Wjrth. 1973. An Axlomatlc Deflnttlon of the Programming Language \nPASCAL. Acfa Irrformatica 2, pp 335-355. Manna, Z. 1974. Mathematical Theory of Computation. McGraw-Hlli, \nNew York, 429 pp. Pratt, V. 1976, Semantlcal Considerations on Floyd-Hoare Log!c 17th Annual SVrnbosiurn \non Founcfatio P~ nf ,.. Compute? Science. IEEE Computer Society. Lon,g Beat;, Ca. pp 109-121. Schwarz, \nJ.S. 1974. Semantics of Partial Correctness Formalisms, Ph.D. Thesis, Syracuse University. Syracuse, \nNY. 126 pp. 7. Appendix 7,1 Proof of Theorem 1. T/morem 1: The standard relational semantics is the \nonly model of HLI-7. Let T be the set of transitive assertions $(a)s true for a relational model T of \nHLI-7 We WIII prove by InductIon on a that (s,s ) e Ra iff ~(a)s e T Thus T = R. lfats NO Pther~ by HL5, \ns(N0P)s ET e~ =5 e(s, s ) E RNOP. similarly If a ]s a prlmltlve statement, A, then by HLI. s(A)s GT ++(&#38;$ \n) ~RA. If a IS b;c then by HL2, ]nductton, and R2, s(b,c)s e T + 3r[s(b)t=T A I(C)S d7 + 3/[(~, t)e \nRbA (f,$ ) =Rbl + (s,J )G RL,oRC  + (~, s ) ~ R/l,c The cmc of ofhI/t statements follows cflrectly \nfrom the fallowing lemmas Al and AZ Lemma Al: (s. $ ) E Rtuhi[e p do b + s(whiie p do b)s E T., Proof: \nLlefimtion Al: For states s, s , program b and predicate P, let disfb,p(s, J ) be the least nonnegative \nInteger k, If any, such that there IS a sequence SO. ... Sk of states with the property thilt (1) so= \n$, ({i) Jk = s , and (111)p(sl) A (sl, s,+,) e Rb for ail nonnegative Integers il<k; If no such k exists \nthe distance distb,p ($, s ) is said to be mfmite. We take the followlng two facts as obvious from Definition \nAl. First, If dtstt,,p($, s ) = n+l, then P(s) and there is an S1 such that (s, sl)e Rb and distb ,P($l,s \n) = n. Second, s>s )GRwhile p do b iff dzstb,P(J. 3 ) IS finite and YP(S ). Lemma Al follows by induction \non disfb,p(s ,S ). If the dls[ance 1s zero, then s = s and from the second fact above we conclude that \n7P(s). Then by HL6, s(utAile p do b)s CZT. By the first fact above, If ffi$tb,p(s, s ) = n + 1 we have \nP(s) and (s, +) c Rb for some S1such that dt~rb,lj($[, J ) = n. From (s, $1) e Rb, by InductIon we have \ns(b)sl c T. By induction on n, we have $l(zohi/e p do b)s c T. Therefore, by H L7, s(7u/li/4 p do b)s \n e 7-.1 Lemma A2: s(while [J do b)$ e T + (s, s ) E Rluhi[e p do b,. P?oof: Let OJ() be the predicate \n(s, t) E (RpORb). CkrCm: O~sl) A P(~l) A sj(b)q + 0J$2). Proof of C./aim: S@)$2ET + (sl, S2) E Rb by \nmain induction on a, hence the claim follows trlvlally.1 We have OJS) by deflnit]on, and s(ruhite p \ndo b)s c: T by hypothesm By HL4, we can conclude OJS ), and by HIL3 and s(while p do b)s c T, we have \n7P(J ). Now Cjs ) A -IP(s ) + (J, s ) e RzuAite p do b by defmitjon of while p do b 7.2 Proof of Lemma \n1, Let ma be a set of pea s of the form P{a]Q LSefjrrition Cl. max(~a) = {($,1)1 P($) + O)t) for all \nP{a}Q.e~a). Let R be a binary relatlon on states. Definition C2. ~a(R) = {P{a]O)J P{a}Ow IS true for \nR}. The followlng lemma formally establishes that Definition 2 and Cl are equivalent. Lemma Cl, Rc max(~a) \niff fia(R) > ma. Proof: Suppose R c rnax(~a ) and that P{a}P e ma. Then for any s, s , P(s) A (s, s ) \nG R ]mplies P(s) A (s, s ) G max(~a). By definition of nzax and the fact that P{a}P~ E ma, we can then \nconclude P (s ). Thus P{a)P G RJR), by the definition of ~a(R). Now assume that ma c Ra(R) and (J, s \n) E R. For any OJa}Q e ma such that Q(s), we have by the definition of ~a(R) that ~(s ). Thus, (s, s \n) E max(~a). I ,ernrna c2: R = rrmx(Ra(R)) Proof: R c max(Ra(R)) by Lemma Cl. To show equahty, suppose \n($1, S2) @ R. Let E$ be the predicate true only of state J. Then Esl{a} YE $2 c ~a(R) by defmltion of \nR=(R), so (~1, S2) @ max(Ra(R)) by definition of rnax.1 Note that if M is a relational semantics and \n~ is the set of pea s true for M, then ma . RU(MU), So Lemma I follows immediately from Lemma C2. 7.3 \nProof of Theorem 3 Tlworem 3: The set of pea s derivable from FH1-5, is equal to R, the standard partial \ncorrectness semantics. The proof that P{a}Q true for R implles P{a)Q derivable is by induction on the \nstructure of programs. if P{iVOP]Q IS true forR, then by D.efjnition i and R] we conclude that P Implies \nQ Hence P{ AfOP}Q is derivable by aPPIYIng FH5 to tile FH1 axiom p{~oplp. If P{A)O~ is true for R, then \nby Definltlons 1 and 3, P Implies [R A]04 so P{A)Q IS Clerlvable by applyjng FH5 to the FH2 axiom ([RA]OJ(A}O< \nIf P{rr;b}Q is true for R, then P{a}([Rb]@ must be true for R, as the reader can verify from Definitions \n1, 3, and R2. Also, ([ Rb]OJ{b}Oe IS true for R by Deflnjtjons 1 and 3. By mductlon we may conclude that \np{a}([Rb]@ and ([ Rb]Q){b]Q are derivable, and therefore P{a;b}Q is derivable by applying FH3. Fmaily, \nsuppose Pl{while p do a}P2 IS true for R. Let Q \u00ad1P2 Then again It follows directly from the Rwrlile \np do adefinltlo&#38; that (i) P1 imphes Q (2) Q A 7P implies P2, and (3) (Q A P){a)Q1s true for R. \n 187 Then by reduction, we conclude from (3) that (Q A P){a]Q IS dertvable. Applylng FH4, we can therefore \nderive OJwhile p do C}(OWA ~P). But we can apply FH5 to the latter assertion to derive (Pl A O~{while \np do a}(P2 V (Q A vP)) which by (1) and (2) IS the same as Pl{wfiile p do a}P2. We omit the proof that \nif P{a}Q is derivable then P{a)Qis true for R. I 7.4 Proof of Theorem 4 Theorem 4: ~ is the only partial \ncorrectness model of PCI-4. ProoJ:The followlng lemma summarizes some facts about weakest antecedent \nwhich are used m the proof. Lemma Bl: Let R, R,, and R2 be relatlons on states. (a) 3P (*( P+[R]P ) \nA *(P -@) iff I=(P+[R]QJ. (b) [Rl][R21Q = [R10R21Q (c) *([R :]Q+Q (d) *([R <]OW+[R][RY]OJ  Proof \nof Bl: (a) the If d[rectlon ]s trlvlal and the only if direction is equivalent to soundness of FH1-5, \n (b) and (c) follow from definition 3. We omit the details. (d) We use the followlng facts which again \nfollow directly from deflnltlons:  (I) RV=IURU R2U,., =IUROR < where RI UR2 M the union of RI and R2. \n  (11) *([RI U R21Q ++ E([R11QA[R2]Q)). By (i) [R ~]Ojs) equals [1 U R. R :]@ s). Thus [R <]~s) implies \n(by II) [I IQ(S) AIR O,R : IQ(S) Implles (by definition 3) OJS)AIRORPIO (S) which ,mplles [R. R*] Q(s). \nThus *([ R i]O&#38;[R OR ~]Qi Let ~ be any partial correctness model of PCi-4. We show that ~a = Ra \nby Induction on structure of program a. P{ NOP}Q e ~ lff (by PCI) I=(P + OJ Iff (by clef. 1) P{ NOP]O%C \nA. P{,4)Q e ~ iff (by PC2) *(P + [RA]OJ Iff (by clefs. 1 and 3) P{A}Qe ~. 188 Suppose a = b;c. Then \nO~a)Q E ~ lff (by PC3) 3P (O~b}P E ~ and P {c)Q c ~) Iff 3P ((*O&#38;[Rb]P ) A *(P + [RCl~)) lff (by \nlemma BI (a)) =(OW+ [Rb][Rc]Q ) lff (by lemma Bl (b)) *(Ow + [RboRCIOw ) lff OJa)Q E ~ We need the followlng \ntwo lemmas for the case of a = whi[e P do b. Lemma B2: O\\{zoAi/e p do b}O~ c ~ lmplles 30> (*((PAO~ ) \n+[Rb]O> )A k(O~-+0- ) A 1=((0~ A~P)A~ )). Proof of B2: OJrtihile p (io b }0- E ~ Implies which Implles, \n ( Q+[Rwhi/e p do bIOe ) by R3, I=(Oe+[(Rp ORb) :OR ~plq). By lemma B1 (b) this ]rnplles 3Q#==(Q+[(Rp0Rb)]~)A \n~(~ + [R YPIQ )). Then by deflnltlon 3, 304( K(0.-[(RpORb)10q)A ~((04 A-P)+o~ )). Let 0) = [( Ril.Rb)J04, \nThen by deflnltton of ~, t=(Q+~), By lemma Bl(c), *(OX -04). This fact and *((% A-IP)-+Q ), imply that \n*(( OW A7P)+Q ). Thus we need only show that *(( Ow AP)-[R/,l O~ ). By lemma B1 (c) and (d), k(Q +[R \nOR ]Q ) which by Bl(b) and definition 3 implies pb H(OS Ap)+[t7b10~19 I +Cs)J (!=(Q-Own) Ai=((O> AP)@]ow \n)A*( (oA+)4Q)4Q )). (v) 3s, $ (Q(J) A (JJ )~Rzuhi/c p do b -~$ ) = (Rp.Rb~DR 7P. Since (S,S ) ~ RIUhi/e \np do b and while p cio b there IS a sequence of states JO,..,sk such that etther k=o, J*S and 7P(J ) \nor the followlng conditions hold: k>O S=so Sk=s P($l) for l<k lp(~k) (s,, si+l) =Rb for t<k Now assume \nQ exists and satlsfles (1) *(C? + Q ) (II) *((~AP) + [RblQ 9  (iIi) *((~A7P)@ ). If k=O, then (I) \nand (ill) Imply Q(s) -Q (s ) IS trW which contradicts (v). If k>o, then by (i) Q (so) IS tr ue. By Induction \nwe fln~~ that O% (S1)is true for l<k. Then (III) lmplles that Q (J ) i!s true, again contradicting (2).1 \n Suppose u = wAi/e p do b. Then OJa]Q e ~ Iff (by PC4) 3Q [(PAOW ) {b)O: E ~ and =( Q+OW ) and I=((Q \nA=P)@ )1 Iff (by mductlon) 3Q [(PAO~ ){b}Q e R and *( OY-Q ) and *(( OW A-IP)+Q )1 )ff 3Q [~((p AO% \n)+[Rb]~) A K(Q+Q )A~((Q AYP;@. )] Jff (by lemmas Bl and B2) Qa]Q e R.1 8. Notes 1. In a later paper \n[f-oare, 1978] Hoare emphasizes the vetuflcation aspects of p oof rules rather than their use as an alternative \nspeciflcatjon of the semantics. Nevertheless, others [cf. Dljkstra, 19751 have used proof rules as a \nmea[ns of def)nltlon. It M this issue which we address. 2. We avoid the use of the word nondeterminlstlc \nhere because nondetermlnism is a property of how final states rzrI? comfiu(cd ftom ]nltlal states, rather \nthan merely being a property of which inlual states map to which final states. Nonfunctlonai relations \ncan only arise from nondetermlnlstlc programs. but functional relat[ons do not necessarily arise only \nfrom deternunst]c programs.  3. Technically speaking, HLI-5 are axiom schemes in which u, b may be any \nprograms, Q an y predicate, etc. 4. A similar observation is made by Pratt [1976]. 5. They omit FH1 \n--a minor oversight. Their D3 is misprinted, but It IS clear from their Lemma 9 that they intended to \nstate FH4. 6. Theorem 4, in particular the characterization of whiie statements by PC4, M imphclt In \nLemma 2.3 of deBakker [1975]. 7. Technically speaking, we should say that R is a model of Th(FH1-5) \nand Th(T1-5) where Th(3) refers to the Set of theorems deducible m deductive system ~. 8. This seems \nto be the technical content of the frequently heard that pea s cannot be used to demonstrate termination, \n(cf. e.g. [Hoare, 19691, [Manna, 19741). The remark is correct, but must not be taken to mislead the \nreader into thtnking :that pea s are an Inherently inadequate semantics. As we have seen in Theorem 6, \nthe complete set of true pea s determines everytltirrg about R despite the anti-monotonicily of pca s. \n 9. Hoare and Lauer refer to theorems... proved in the relational theory , rather than mentionmg models \nexplicitly. But since the relational theory HL1-5 consists solely of axioms without inference rules, \nwe must assume they refer to the usual model\u00adtheoretic notion of theorem, namely, an asseruon is a theorem \nwhen It IS true of all models of the axioms. With this interpretation, theu formulation of consistency \nIS equivalent to ours. 10. TO emphasize the obscurity of Theorem 7, we note that although FHI-4 specify \nR according to Theorem 7, it is not true that Th(FH1-4) = Th(FH1-5) or even that R ISthe largest model \nof Th(FH1-4).  We regard the characterization of R m Theorem 8 as subtle because there N no particular \nreason to look at largest models in the context of an axlomatizatlon hke HL1-5. Indeed, we saw that by \nadding HL6-7 only one mode{ is possible, so there IS no reason to expect or rely on a condition like \nrnaxlrnahty to force uniqueness.  \n\t\t\t", "proc_id": "567752", "abstract": "Hoare and Lauer [1974] have advocated using a variety of styles of programming language definitions to fit the variety of users from implementers to program verifiers. They consider the question of whether different definitions and specifications determine the same language by showing that the definitions are what they call \"consistent\". However, their treatment skirts the question of whether their definitions can each be taken to specify the language adequately. Although, as we will show, any one of the kinds of semantics they discuss -- operational, relational, deductive -- can be used to specify meaning uniquely, Hoare and Lauer do not make the case in their paper. In fact, both their relational and deductive definitions are satisfied by several different semantics, only one of which is desired.Thus, the main point of this paper is to clarify the characteristics of a proper specification of language semantics and to formulate alternative specifications each of which is equally good as the language definition. We basically agree with Hoare and Lauer that several specifications can and should be given, but are disturbed by confusions about such specifications, some of which are illustrated in their paper. In particular we refer to confusions between the mathematical object which is designated to be the meaning of a program and methods for specifying that object; the similar confusion between predicate and expression; between consistency and equivalence of two definitions; between completeness of a theory and its having a unique model. While these issues are familiar in mathematical logic, we take this opportunity to survey them in the context of programming language semantics.This paper can be read without prior familiarity with Hoare and Lauer's paper. The authors plan another paper extending this work which will include a more comprehensive bibliography.", "authors": [{"name": "I. Greif", "author_profile_id": "81100427186", "affiliation": "Massachusetts Institute of Technology, Cambridge, Massachusetts", "person_id": "PP42051808", "email_address": "", "orcid_id": ""}, {"name": "A. Meyer", "author_profile_id": "81100572937", "affiliation": "Massachusetts Institute of Technology, Cambridge, Massachusetts", "person_id": "PP15036549", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/567752.567769", "year": "1979", "article_id": "567769", "conference": "POPL", "title": "Specifying programming language semantics: a tutorial and critique of a paper by Hoare and Lauer", "url": "http://dl.acm.org/citation.cfm?id=567769"}