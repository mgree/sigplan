{"article_publication_date": "01-01-1979", "fulltext": "\n Synthesis of Resource Invariant for Concurrent Programs Permission to make digital or hard copies of \npart or all of this work or personal or classroom use is granted without fee provided that copies are \nnot made or distributed for profit or commercial advantage and that copies bear this notice and the full \ncitation on the first page. To copy otherwise, to republish, to post on servers, or to redistribute to \nlists, requires prior specific permission and/or a fee.&#38;#169; 1979 ACM 0-12345-678-9 $5.00 Edmund \nMelson Clarke, Jr.f Aiken Computation Laboratory Harvard University Cambridge, Mass. 02138 Abstract Owicki \nand Gries have developed a proof system for eondit<onal critical regions. In their system logically related \nvariables accessed by more than one process are grouped together as resources, and processes are allowed \naccess to a resource only in a critical region for that resource. Proofs of synchronization properties \nare constructed by devising predicates called resowce <nv&#38;ant;s which describe relationships among \nthe variables of a resource when no process is in a critical region for the resource. In constructing \nproofs using the system of Owicki and Gries, the programmer is re\u00adquired to supply the resource invariants. \nWe show that convex{ty plays a key role in the derivation of strong resource invariants. We also develop \nmethods for automatically synthesizing resource invariants. Specifically, we characterize the resource \ninvariants of a concurrent program as ~eash fixpofnts of a functional which can be ob\u00adtained from the \ntext of the program. By using this fixpoint characterization and a widening operator which exploits our \nobservation on the importance of convexity, good approximations may be obtained for the resource invariants \nof many con\u00adcurrent programs. 1. Introduction Owicki and Gries [OW76] have developed a, proof system \nfor cond{t{onal critigal regions. In their system logically related variables accessed by more than one \nprocess are grouped together as resources, and processes are allowed access to a resource only in a critical \nregion for that resource. Proofs of synchronization properties are constructed by devising predicates \ncalled resource invariant. These predicates describe relationships among the variables of a resource \nwhen no process is in a critical region for the resource. Related methods for verifying concurrent programs \nhave been discussed by Lamport [LM771 and Pneuli [PN771. In constructing proofs using the system of Owicki \nand Gries, the programmer is required to ?This research has been partially supported by National Science \nFoundation Grant No. MCS\u00ad7508146. supply the resource invariants. we investigate the possibility of automatically \nsynthesizing resource invariants for a simple concurrent programming language (SCL) in which processes \naccess shared data via conditional critical regions. We consider only invariance [PN77] or safety properties \n[LM77] of SCL programs. This class of properties includes mutual exclusion and absence of deadlock and \nis analogous to partial correctness for sequential programs. Correctness proofs of SCL programs are expressed \nin a proof system similar to that of Owicki and Gries. To gain insight on the synthesis of resource invariants \nwe restrict the SCL language so that all processes are nonterminating loops, and the only statements \nallowed in a process axe P and V operations on semaphores. We call this class of SCL programs pv programs. \nFor PV programs there is a simple method for generating resource invariants, i.e., the semaphore invariant \nmethod of Habermann [HA721 which expresses the current value of a sema\u00adphore in terms of its initial \nvalue and the number of P and V operations which have been executed. Although the semaphore invariant \nmethod is simple to state, it is a powerful technique for proving PV programs; we show that it is as \npowerful as the .veduct-ton method of Lipton [L175] for proving freedom from deadlock. The semaphore \ninvariant method, however, is not complete for proving either absence of deadlock or mutual exclusion \nof PV programs. We show that there exist PV programs for which deadlock (mutual exclusion) is impossible, \nbut the semaphore in\u00advariant method is insufficiently powerful to es\u00adtablish this fact. This incompleteness \nresult is important because it demonstrates the role of eonvex<ty in the generation of powerful resource \ninvariants. We also give a characterization of the class of PV programs for which the semaphore in\u00advariant \nmethod is complete for proving absence of deadlock (mutual exclusion). The semaphore invariant method \nis generalized to the class of ~inear SCL programs in which solu\u00adtions to many synchronization problems \ncan be ex\u00adpressed. Although the generalized semaphore in\u00advariant also fails to be complete, it is suffi\u00adciently \npowerful to permit proofs of mutual exclu\u00adsion and absence of deadlock for a significant class of concurrent \nprograms. When the generalized semaphore invariant is insufficiently powerful to prove some desired property \nof an SCL program, is it possible to synthesize a stronger resource in\u00advariant? We argue that resource \ninvariants are fixpoinzis, and that by viewing them as fixpoints it is possible to generate invariants \nwhich are stron\u00adger than the semaphore invariants previously de\u00adscribed. We show that the resource invariants \nof an SCL program C are fixpoints of a functional FC which can be obtqined from the text of program C \nand that the least fiXpOint H(Fc) of FC is the strongest such resource invariant. Since the functional \nFC is continuous, the least fixpoint P (Fc) may be expressed as the limit . U(FC) = U F~(false) . j =1 \nClearlyr this characterization of u (Fc) cannot be used directly to compute ll(Fc) unless C has only \na finite number of different states or unless a good initial approximation is available for U(FC) . By \nusing the notion of widen{ng of Cousot [C077] however, we are able to speed up the conver\u00ad gence of the \nchain F~(false) and obtain a close approximation to P (Fc) in a finite number of steps. The widening \noperator which we use exploits our observation on the importance of convexity in the generation of resource \ninvariants. Although fix\u00adpoint techniques have been previously used in the study of resource invariants \n( [LA761 , [FL771) , we believe that this is the first research on methods for speeding up the convergence \nof the sequence of * approximations to U(FC) . Examples are given in the text to illustrate the power \nof this new technique. The SCL language and its semantics are dis\u00adcussed in Sections 2 and 3 of this \npaper. Sections 4 and 5 contain a description of the semaphore in\u00advariant method and a discussion of \nwhy it is incom\u00adplete. Section 6 introduces the class of linear SCL programs and briefly describes how \nthe semaphore invariant can be generalized to this class of pro\u00adgrams. The fixpoint theory of resource \ninvariants is presented in Section 7. Section 8 contains an account of Cousot s widening operator and \nhow it can be used in approximating resource invariants. The paper concludes with a discussion of the \nresults and some remaining open problems. 2. A Simple Concurrent Programming Language (SCL) An SCL program \nwill consist of two parts : (1) an in{t{alizat{on part 9:=Z!T in which initial values are assigned to \nthe synchronization variables %, and (2) a concurrent execution part resource R(x): cobegin P1//P2//...Pn \ncoend which permits the simultaneous or interleaved execu\u00adtion of the statements in the processes Plr.. \n.,Pn. All variables accessed by more than one process must aPPear in &#38;he prefix R(R) of the concurrent \nexecu tion part. Processes have the form Pi: cycle S;; S$; . . ..S~ end i .Si ,, where S;; s;;..., ~, \nis a list of conditional critical regions. Th~ cycle construct is a non\u00adterminating loop with the property \nthat the next statement to be executed after S1 is the first ki Si statement of the loop. Although the \ncycle 1 statement simplifies the generation of loop invari\u00ad ants, the results of this paper also apply \nto termi\u00adnating loops (e.g., while loops). The extension of SCL to allow multiple resources is straightforward \nand will not be treated in this paper. Conditional c~it{cal regions have the form with R when b do A \nod. Only variables listed in R . can appear in the boolean expression b and the body A of the conditional \ncritical region. When execution of a process reaches the conditional critical region with R when b do \nA &#38;, the process is delayed until no other proce~ is using R and the condition b is satisfied. Then \nthe statement A is executed as an indivisible action. Let C be an SCL program with the format de\u00adscribed \nabove; a program state U is an ordered list (pcl, pcz, . . ..pcn. s), where (1) PCi is the p~ogrzm counter \nfor process Pi and is in the range 1 < pci ~ki.   (2) s maps the set of synchronization variables to \nthe set Z of integers and is called the pro\u00adgram sto~e.  We will write b(s) to denote the value of predi\u00adcate \nb in store s; A(s) will be the new store resulting when the sequential statement A is executed in store \nS. A COT7ipU7h7t{O? t of an SCL program C is a sequence of program states Oo, Olr.. .,ujr . . . . The \n{nitial state o~ has the ~orm (1, 1,. ..,;.; so) where so reflects the assignments made in the initlal~zation \npart of C. Consecutive states = (pC:, and j Cr = (Pc;+l, . . ..p+l.sj+l)l) 0 . . ..PC.; Sj) j+1 n are \nrelated as follows: There exists an m, 1 < m< n SUCh that . 1 (1) PC;+l = PC?if i+m I 3 + 1 if PC] <k \n(2) Dc]+l = ,Pcm m m m otherwise (1 . (3) if statement pc~ in process m is with R when b do A g, then \nb(s. = true and 1 =~). j+l Note that concurrency in the execution of an SCL program is modeled by nondeterminism \nin the selec\u00adtion of successor states. If there exists a computation U~, . ..Oj . . . . ~o of program \nC, then we say that state Oj is ~eachable from the initial state LSO of C and write Uosoj. Note that \nthe next statement to be executed by process pi in state 0 = (pcl, . . ..pcn.s) is always S=We say that \nprogram C is blocked pCi . in state O if the condition of the next statement to be executed in each process \nis false in state 0. A state 0 of c is a deadZoek state if o is reachable from the initial state of C \nand C is blocked in state O. Two statements S1 and S2 in different processes of C are mutually exclusive \nif there does not exist a state 5, reachable from the initial state of C, in which and S2 are % next \nto execute in their respective processes. Frequently it will be convenient to identify a THEOREM 3.1. \nLet RSc be a ~esouxwe invariant predicate U with the set of program states which system for the SCL program \nC. If a is rvachable make U true. If ~ is the set of all program 2Z will be the set of all possible states, \nthen in c and S: is the next statement of p~ocess pi predicates, false will correspond to the empty state \nto execute in state 0, then OCpre(S$). set, and true will correspond to the set Z of all program states. \nAlso logical operations on predi- Proof: See [OW76]. [ cates can be interpreted as set theoretic operations \nResource invariant systems may be used to prove on subsets of Z i.e., or becomes union, , and absence \nof deadlock and mutual exclusion of an SCL becomes intersection , not becomee complement , program C. \nTO prove mutual exci!us$on of statements and implies ! becomes ris a subset of . S1 and S2 in C it is \nsufficient to give a SP[A] (U) will denote the strongest posteon-resource invariant system Xc for C such \nthat di$ion corresponding to the sequential stakement A M(PSC) = pre(S1) A pre(S2) A IR and the preeond{t?on \nU. If the predicate U is identified with the set of states which satisfy is unsatisfiable. To prove that \nit is impossible it, then SPIA] (U) may be defined by SPIA] (U) = for c to become deadlocked it is sufficient \nto {(PCl, . . ..PCn. A(S))/(PCl,...,PCn; s)6U} exhibit a resource invariant system F&#38;c such that \nthe predicate THEOREM 2.1. Let A be a sequential statement. ki n (A) (Monoton~cit.zj) if U, v~X and U~V, \nthen D(RSC) = A ( V pre(S~) A mb~) A IR SP [A] (U) C=SP [Al (V) . i=l j=l (B) (Addit{vi~y) {f {Ul}, i \nLO KS afam-ily of predicates, then is unsatisfiable. Local deadlock, in which only a SP[A] ( U Ui) = \n~ SP[A] (Ui) . subset of the processes are blocked, may be handled 1 in a similar manner. Proof: See \n[CL77]. [ 4. The Semaphore Invariant Method 3. Resource Invariant Proofs P and V operations on a semaphore \na can be treated as conditional critical regions: P(x) is In this section we adapt the proof system of \nequivalent to with R when x>O do x:=x-1 od and v(x) to with R when true do x~~+l o~. % this Owicki and \nGries to SCL programs. We use the stan\u00ad dard notation {P}A{Q} of Hoare to express the . section we restrict \nthe class of SCL programs so part<al co~yectness of the sequential statement A that the only statements \nallowed within processes with respect to the precond{t{on P and postcondi\u00ad are P and V operations on \nsemaphores; we call tion Q. The triple {p}A{Q} is true (/= {P} A{ Q}) euch programs PVprogrwnls. iff \nI=SP [A] (P) + Q. Proof systems for partial The semaphore invariant method [HA72] is based correctness \nof sequential statements will not be on the use of a&#38;~;a~ variables. Let a be a discussed in this \npaper. semaphore with initial value m occurring in a PV Let C be an SCL program and let ST be the program \nC. For each statement Si corresponding set of statements occurring within the processes of to a P operation \nwe introduce an auxiliary vari\u00ad c. A resource invatiant system RSc for C will able a; which is incremented \neach time the P consist of two parts: operation is executed. Similarly for each state\u00ad (1) A predicate \nIR called the resource invatiant. ment Si corresponding to a V operation we intro- All free variables \nof IR must appear in the resource prefix R(X) of the program C. duce a variable ai.2 All auxiliary variables \nare (2) Proofs of sequential correctness for each of initialized to zero at the beginning of the program \nthe individual processes of C. c. The semaphore <nvariant states that the predicate For our purposes, \nthese correctness proofs are Ia ? {a=m+~a~-~a~Aa~O} mustbe satisfiedby represented by a set VC of assertions \ncalled c whenever C is not executing a P or V opera\u00adve~ificat~on c.ond{tions and two functions pre!,, \ntion on the semaphore a. post: ST + VC which give the precondition and post\u00adcondition for each statement \nC in the proof. To When auxiliary variables are added to C in insure that the proofs of sequential correctness \nthis manner, there is a simple method of generating for the individual processes are interference free \nappropriate pre and post functions for c. Let [OW76], we require that the free variables in the Pi: cycle \nS1;...;S: end be the ith process in verification conditions for process i do nc,t 1 i aPP:+r as free \nvariables in the verification ~on\u00adthe program C, and let, d~,...,d~, be the auxil\u00ad dlt~ons for any process \nj with j#i. Xf c! is an SCL program with the format described in Section 2, iary variables for this process. \n$he pre and post then the functions pre and post for process Pi must functions for process pi will be \ndefined induc\u00ad also satisfy the following conditions: tively: (a) (1) pre(S~) ~ post(S~ ) ~ {d~=d~ =... \n=d~ } 1=~=~ + Pre(s~) A IR i i (b) l=post(S~ ) + pre (S;) (c) l=wst(+~ + w=(Sj+l) for 1 _< j _< ki-l. \nassociated auxiliary variable . ; then (d) if s; is the conditional critical region post(s~) = pre(s~) \n(d~-1)/d~ 1[  (.2) If S: is a conditional critical region with J 1 with R when b; ~ A!j ~ We refer to \nthe resource invariant system consisting of the conjunction of the semaphore invariants Ia then ~ {pre \n(S;) A b~ A IR}A~{post (S~) A IR}. and the annotation obtained by the above procedure Feasible computations \nof this program can be re\u00adas the semaphore ;nvatiant system (SIC) correspon-presented by a graph in which \nthe number of instruc\u00adding to C. tions executed by a process is used as a measure of the progress of \nthe process, e.g., Consider, for example, the PV program C a: =1 cobeqin A: cycle P(a); SA; V(a) end \n // B: cycle P(a); SB; V(a) end coend SA and SB represent the bodies of the critical regions established \nby the P and V operations and will be treated as null statements in the analysis which follows. Annotating \nC as described in the previous paragraph we obtain: {a~=OAa~=O Aa~=OAa~=O Aa=l} 1 resource R(a, al, a~, \na;, a:): cobeqin A: cycle {a} = a~}L L l:=al+l; a:=a-1 Q; ~R_a>Od&#38; a 1-; 11 {a~-l=a~} b ab a-Progress \nfor process B 1L 2 with R when true SQ a2:=a +1; a:=a+l o~; 11 The dashed line represents a computation \nof the end .rxogram C in which process B executes P(b) and process A executes P(a). The shaded region \nof // the graph represents those program states which fail to satisfy the semaphore invariants for a \nor B: cycle The {a; =a~} point labeled x in the graph is a deadloek state; 1 the state X is reachable \nfrom the initial state b; such states are called unfeasible states. ~Rha>O&#38; a :=al+l; a:=a-l~; 22 \nof C but further progress for either process A {a~-1 = a;} or process B would violate one of the semaphore \ninvariants (i.e., both processes are blocked) . SB ; Those points in the graph (states of C) which are \n{a~-l=a~} not reachable from the origin (initial state) by a 22 polygonal path composed of horizontal \nand vertical with R when true &#38; a :=a +1; a:=a+l oc&#38;; 22 line segments which never cross an unfeasible \n&#38; region (by a valid computation sequence of C) are coend called unreaehab2e points (states) . All \nunfeasible woints are unreachable. The point labeled Y in The invariant Ia for semaphore a is ~he graph \nis an example of an unreaelzabZe feasible I {a=l+af+a~ -a~-a~Aa~O} . point; if the program C were started \nin state Y, a the semaphore invariants would not be violated. Since the predicate M(SIC) = pre(SA) Apre(SB) \nAIa Next consider the PV program C: is unsatisfiable, it follows that statements SA and SB are mutually \nexclusive. Similarly we see that C a:=b:=c:=d:=l is free from deadlock, since the predicate D(SIC) cobegin \nis also unsatisfiable. A: cycle P(a); P(b); P(d); V(a); P(c); V(b); V(c); V(d) end 5. Incompleteness \nof the Semaphore Invariant Method // B: cycle P(a); P(b); P(c); V(b); p(d); V(a); V(c):The incompleteness \nof the semaphore invariant V(d) end method is best explained by means of progress graphs coend [D176] \n. The progress graph is a graphical method for representing the feasible states of a PV program. The \nprogress graph for C is shown on the next page. Consider, for example, the program C: Note that deadlock \ncan never occur during execution a:=l; b:=l of program C. Let SIC be the semaphore invariant cobeqin \nsystem for the program C. Thus , if auxiliaryA: cycle P(a); P(b) ; V(a); V(b) S@ variables are added \nas described in Section 4, // B: cvcle P(b); P(a); V(b); V(a) a A c1 c b c a d b a a bcbdacde the invariant \nI will be given by I = {a=l+a~+a~-al-al Aa>l) 12 Ab=l+b; +b~-b~-b~Ab > 0 AC=1+C2 +C; -C; -C; AC>O 1 Ad=l+d:+d:-d:-d~Ad \n> 0 1 Aa~~OAa~~I)Aal l~0Aa2~0 2> OAb2 >OAb:>OAbl>O bl 2-2\u00ad 21 Ac >0 AC! >OAC >OAC ;~o 1-2 ; Ad:>OAd \n2 OAdl~OAd:~O} 2 It is not difficult to show that the condition D(SIc) for absence of deadlock is satisfied \nby the state Z in which a=O, a2=l, a22=0, a;=l, a:=l 1 b=O, b;=O, b:=l, b:=l, b:=l C=o, C:=or C;=o, c11 \n=01 c; =1 d=O, d:=O, d:=O, d+=l, d~=O Thus absence of deadlock cannot be proven by means of the semaphore \ninvariant method. The state Z which satisfies D(SIC) is an example of an un\u00ad reachable feasible state \nin which each process of C is blocked; we will call such states trap states. THEOREM 5.1. The semuphore \ninvariant method $s complete for proving deadlock freedom for those PV programs whose progress graphs \ndo not contain any trap states. Proof: Let C be a PV program whose progress graph does not contain any \ntrap states. Thus any state of C in which all processes are blocksd must be reachable from c s initial \nstate. I,e t SIC be the semaphore invariant system for C. We show that the condition D(SIC) is unsatisfiable \nif and only if deadlock is impossible for the pro\u00adgram C. Clearly, if D(SIC) is unsatisfiable than deadlock \nis impossible. Thus assume that D(SIC) is satisfied by some state U. By con\u00adstruction of the predicate \nD all processes are blocked in state G. Since O is reachable from the initial state of C, it is a deadlock \nstate. A similar characterization may be given for mutual exclusion. How can the semaphore invariant \nmethod be strengthened to handle trap states? Since trap states correspond to holes in the un\u00adfeasible \nregion of a progress graph, a method based on convexity is worthy of investigation. We return to this \nquestion in Section 8. Although the eemaphore invariant method is not complete for proving absence of \ndeadlock or mutual exclusion of PV programs, it is a powerful tool for proving correctness of PV programs \nwhich occur in practice as the examples of [HA721 demonstrate. Additional evidence for the power of the \nsemaphore invariant method may be obtained by comparing it to other methods which have been proposed \nfor proving deadlock freedom of PV programs. We prove, for example, that the semaphore invariant method \nis as powerful as the Feauction method of Lipton [L1741: If a PV program has a reduction proof of deadlock \nfreedom, then it also has a proof using the sema\u00adphore invariant method. Reduction is a technique for \ndecreasing the number of interleavings of statements which must be considered in the proof of a concurrent \nprogram. Let C be a concurrent program and S a statement contained in C. The reduction C/S is the con\u00adcurrent \nprogram obtained from C by making S into a single indivisible (i.e., uninterruptible) action. To prove \nthat program C has some pro\u00adperty U, it is sufficient to produce a sequence of programs c=c~, c2,... \n,cn and statements sl, . . ..sn_~ such that (1) ci+~=Ci/si for i=l,. ..,l-l. (2) If Ci hae property \nU, then Ci/Si also has property U.  (3) Cn trivially has property U.  Lipton gives a class of statements \ncalled D-~~duc\u00adtions with the property that if C is a concurrent program and S is a D-reduction, then \nC is deadlock-free iff C/S is deadlock free. For PV programs D-reductions have the form S=sl, s2,.. .,sn \nwhere Slv. ..,sl-l are P operations, Si+~, . . ..Sn are V operations and Sz, . . ..sn can always execute. \nIn view of con\u00ad dition (3) above we will assume that the progress graph of the final program Cn in a \nreduction proof of deadlock freedom does not contain any trap states. LEMMA 5.2. If the ppog~ess gnzph \nof a PVp~o\u00adgrm C conta{ns a trap state, then the progress gmph of the D-reduct{on c/s also eonta~ns a \ntrap state. Proof: Let U be a trap state for the PV program C. By definition, u is an unreachable feasible \nstate of C in which every procees iS blocked. Let C/S be a D-reduction where s=s~; Sz;...;sn has the \nform described above. Assume that U is not a trap state for C/S. If o were a feasible state of C/S, then \nit would be called the canonical annotation. a trap state of C/S since every computation of C/S is a \ncomputation of C. Thus, 0 must not be a feasible state of C/S. Since S=sl; s.2; . . ..sn must be executed \nas an atomic statement in c/s , the process containing S must be blocked in state G while attempting \nto execute one of the statements S2, s3,... ,sn. Since by definition of a D-reduction the statements \nS2, s3r. ..,sn can always executer this is a contradiction. [ THEOREM 5.3. Ifa PYprogmm has a proofof \ndeadlock freedom using the rwduct{on method, then it also has a proof of deadLock freedom using the semaphore \n-hvarbat method. Proof: Assume that CO has a proof of dead\u00adlock freedom using the reduction method. Then \nthere exists a sequence of D-reductions Cl=CO/SO,...,Cn=Cn_Sn_l_l where Cn is free from deadlock and \ndoes not contain any trap states. By Lemma 5.2 co must also be free from deadlock and not contain any \ntrap states. By Theorem 5.1, it is possible to prove that CO is free from deadlock by means of the semaphore \ninvariant method. [ 6. Generalization of the Semaphore Invariant Method Since a large class of synchronization \ntech\u00adniques can be modeled by counting operations on shared variables, the class of linear SCL programs \nis of particular interest. The conditional criti\u00adcal regions of a linear SCL program have the form with \nR when B(x ~, x2r*.. ) _do A(x1, X2,.. .,Xn) @ rxn where (1) the variables xl, x2, . . ..xn belong to \nresource R.  (2) the condition B(x1, X2,. ..,Xn) is a truth functional combination of atomic formulas \nof the form alxl+a2x2 +... +anxn+an+l ~ O  (3) the body A(x1, X2, . . ..Xn) is a series of assignment \nstatements which increment the shared variables Xlr. ..,xn e.g.,  Xl +blxl:= X2:=X2 +b2 . : Xn + bn \nn Note that semaphores are special cases of linear SCL programs. Many other standard synchronization \nproblems including the dining philosophers problem, the readers and writers problem, and the cigarette \nsmoker s problem can all be expressed as linear SCL programs. Arguments are given in [SC76] and [AG74] \nthat linear SCL programs are universal in their power to express synchronization constraints for concurrent \nprograms. It is also poss~ble to prove that mutual exclusion and deadlock freedom are undecidable for \nthis class of programs. We briefly outline how the semaphore invariant can be generalized to linear \nSCL programs. Let C be an SCL program. For each conditional critical region Si in C we introduce a new \nauxiliary variable dSi which counts the number of times Si has been executed. Thus, the algorithm of \nSection 4 may be used to generate pre and post functions for C; the resulting annotation of C will be \nLet Hi(Z) =a~xl +aix + . . . a~n+ ain+l be a 22 linear form occurring in the condition of some critical \nregion of C. We will use the notation ~H1/~Sj to denote the change in value of H1 caused by the execution \nof statement S<; note that J ~H,/8S. is given by Let dHi = H(Z) -H(io) where ;O gives the initial values \nof the synchronization variables. Then, the relationship dHi = ~~Hi/aSj dSj j must hold if no process \nis executing a critical region for R. Although the generalized semaphore invariant is sufficiently powerful \nto permit proofs of mutual exclusion and absence of deadlock for a significant class of linear SCL programs, \nit fails to be complete for exactly the same reason as the original semaphore invariant. 7. A Fixpoint \nTheory of Resource Invariants Let L be the set of program states and let F: 2X+2Z. If UZZ and F(U)=U, \nthen U is a fiXpO~nt for the functional F. If U is a fix\u00adpoint of F and U ~ V for all other fixpoints \nV of F, then U is the least f~xpo{nt of F. F is contzkuous if for every ascending chain of subsets of \nz, O=ul=...sujs... co m FUU, = U F(Uj) . ()j=~ ] j=() If F is continuous, then F has a least fixpoint \nu(F) which 1s given by co, p(F) = U F] (false) j=() where FO(U) = U and F]+l = F(F] (U)). The resource \ninvariants of an SCL program C are fixpoints of a functional which can be Fc obtained from the text of \nC. Let C be the SCL program X:=E; resource R(x) cobegin P1//P2//...Pn coend We assume that C contains \nK critical regions s~, s.2r...rsK and that the ith critical region has the form Si ~with R when bi &#38; \nAi ~. The algorithm of Sections 4 and 6 will be used to generate the pre and poet functions for C. Let \n.Z be the set of possible states of C and let Fc: 2Z+ 2Z be defined by K FC(J) =JOVJV V SP[Ai](pre(Si) \nAbiA J) i=~ where the predicate Jo={~=~} describes the initial state of C. THEOFUIM 7.1. l he fU7ZCt~On \nFC <s a eontinuom mapping on 2X. Thus, FC has a least fhpoint P(FC) which is g<ven by 03. !-I(FC) = u \nF~(false) j =~ Proof: The continuity of Fc follows directly from the additivity of SP. [ THEOREM 7.2. \nAll resource invariant lR of C are f?kpo{nts of FC. Also p(FC) ~s a .vesou.rve for c. Proof: Let IR be \na resource invariant for c. Clearly, IRS FC(IR). We must show that FC(IR) ~ IR. By condition (a) in the \ndefinition of a resource invariant system {~=6} ~IR. BY condition (e) we see that for l<i<Kr l=~Pre(Si)Abi \nAIR} Ai {POSZ(Si~AIR} . It follows that for 1~ i < K SP[Ai](pre(Si) AbiA IR) ~post(Si) AIR . Hence, K \nV SPIAi](pre(Si) AbiAIR) ~ IR . i=l so, K FC(IR) = .JOVIRV V SPIAi](pre(Si) AbiAIR) ~ IR . i=l Thus, \nevery resource invariant IR is a fixpoint of Fc. Since p(Fc) is a fixpoint of we have c K p(Fc) = JOvp(Fc) \nV V SP[Ai](pre(Si) Abi AN(Fc)) i=l Thus , JO~ P(FC) and for 1<i <K SP[Ai](pre(Si) Abi AP(Fc)) ~l.I(Fc) \n. By construction of the pre and post functions, we also have SP[Ai](pre(Si)) ~post(Si). By monotonicity \nSP[Ai](pre(Si) Abi AU(Fc)) ~post(Si) . It follows that for 1<i <K . SP[Ai](pre(Si) AbiAp(Fc)) ~post(Si) \nAp(Fc) or, equivalently that 1= {pre (Si) A bi A V(FC)} Ai {postal} . Thus, P(FC) is a resource invariant \ncorresponding to the canonical annotation given in Section 6. D THEOREM 7.3. U(FC) = {aloO&#38;} . Proof: \nLet IR= {cs100~6}. We show that IR is a fixpoint of Fc and that IRS U(FC). Since U(FC) is the least fixpoint \nof , it c follows that p(Fc) = IR. [A) FC(IR) =IR: Clearly IRS FC(IR). Let OEFC(IR) =JOVIRV $ SP[Ai](pre(Si)Abi \nAIR) i=l then either Isg Jo~IR or ISg IR or there exists iO such that OESPIAiO] (pre(SiO) AbiO AIR) . \nOnly the third case is interesting. If UC SPIAiO] (pre(SiO)AbiOAIR)~ then there is a state U 6pre(SiO) \nAbiOAIR such that AiO(U )=C. Since 0 EIR, there is a computation OO,O1,.. .,OI of C with Or=O . Because \nO Epre(SiO)AbiO and O=A(CI ), (70, . . ..crr.o is also a computation of C and CJ~IR. (B) IR~P(Fc): Let \nOc IR then there exists a computation CJotCf~r... r~r in which Or=a. We prove by induction on r that \n0r6F~+1(false). Since F~(false) =JO, the basis case cfOEF~(false) is true. Assume that for all computations \naololr...for_l of c, Clr_l~ F~(false). Let Do,al, . . . ror_l,cfr be a computation of length r, then \nthere exists and such that o o r-l~pre(Sio)Abio and O =Aio(Or_l). Thus r UrCSPIAio] (pre(Sio) AbiOAF~(falSe)) \n~ F ~+l(false). It follows that co IR~ U F~(false) = V(FC). n i=() THEOREM 7.4. The resource system \nRSc con\u00adSiSt_tn.g of P(FC) and the canonical annotation is relatively complete for p~oving absence of \ndead\u00adlock and mutual exclus{on ofSCL programs. Proof: We prove that for the resource invari\u00adant system \nPSc, the condition D(RSC) is unsatis\u00adfiable ijff deadlock is impossible. Clearly, if D(RSC) is unsatisfiable \nthen deadlock is impossible. We must show that if D(RSC) is satisfiable, then there exists a state ~d \nwhich is reachable from the initial state of C in which every process of C is blocked. Let Ud be a program \nstate which satisfies D(RSC) . Since Cd satisfies D(RSC), it follows that Od~U(FC) and also that each \nprocess of C is blocked in state ad. Since 6d6p(FC), ad is reachable from the initial state 00 of C. \nThus, Dd is a deadlock state for the program C. The proof of completeness for mutual exclusion is similar \nand will be left to the reader. [ Theorem 7.4 shows that V(FC) is the strongest resource invariant for \nprogram C. The next theorem is important because it gives a method for improving approximations to P(FC) \n. THEOREM 7.5. If L is a pred-icate such. that LC(Fc), then m lJ(Fc) = U F](L) . j=o Proof: It is easy \nto show that for all j ~ O Fl (false) cFj(L) ~Fj(P(FC)) Thus m . U(FC) = U F] (false) ~ U F](L) ~ ~ F](P(FC)) \nH(FC) j=Q j=0 j=Q [ To illustrate theorems 7.1 -7.5 we consider the following solution to the mutual \nexclusion problem: a:=o; b:=o; resource R(a,b) : cobegin A: cycle Al: with R when b=O do a:=a+l od; \nSA; A2: with R when true do a:=a-1 od end // B: cycle Bl: with R when a=O do b:=b+l od; SB ; B2: with \nR when true do b:=b-1 od end coend Adding auxiliary variables and using the algorithm of Section 6 to \ngenerate pre and post functions we obtain: {a=OAb=OAal=O Aa2=OAbl=OAb~=O} resource (a, b, al, a2, bl, \nb2) : cobegin A: cycle {al=a2} Al: with R when b=O do a:=a+l; al:=al+l od; {a~m=a2} SA; {a~-l=a21 . \nA2: with R when true do a:=a-l; a2:=a2+l od . end // B: cycle {b1=b2} Bl: with R when a=O Qo_ b:=b+l; \nbl:=bl+l Q; {bl-l=b2} SB ; {bl-l=b2} B2: with R when true do b:=b-l; b z : =b2+l od - end coend In \nthis case the function c s FC(J) =a=o Ab=OAal=O Aa2=0 Abl=OAb2=0 VJ vSP[a:=a+l; a~:=al+l] (b=O Aa1=a2 \nAJ) VSP[a:=a-l; a~:=a2+l] (trUe Aal-l=a2AJ) vSP[b:=b+l; bl :=bl+l] (a=OAb1=b2 AJ) vSP[b:=b-l; b2:=b2+l] \n(true Abl-l=b2 AJ) Since a(b) is incremented in statement A1(B1) and decremented in statement A2(B2) \n, an obvious guess for a resource invariant is IR={a=al-a2 Ab=bl-b2Aa1~0 Aa2~OAbl~0 Ab2~O} . It is easily \nchecked that Fc(IR) = IR so that IR is a fixpoint of FC. Since D = pre(Al) Ab=O Apre(Bl) Aa=OAIR is unsatisfiable, \nthe invariant IR may be used to prove absence of deadlock for C. The invariant IR is not strong enough, \nhowever, to prove mutual exclusion of statements SA and SB, since the predicate M = pre(SA) Apre(SB) \nAIR is satisfiable. By using Theorem 7.5 we may compute the strongest resource invariant p(FC). Let L= \n{IRAa1=a2Abl=b2} then L ~ LI(FC). Since F;(L) =F~(L) =... ={IRAa=l. +b=OAb=l+a=O}, we see that ~ B(FC) \n= U F~(L)=F~(L) {a=al-a2A b=b1-b2Aa=l b=o i=o Ab=l+a=OAa@A a2~Q Abl~ 0Ab2~O} Using the resource invariant \nu(Fc) it is easy to show that the predicate M =pre(SA)A pre(SB)A P(FC) is unsatisfiable; thus the statements \nSA and SB are mutually exclusive. Note that Theorem 7.5 can only be used to obtain p(Fc) if program C \nhas a finite number of different possible states or unless a good approximation is already available \nto U(FC). In the next section we will examine more powerful techniques for obtaining strong resource \ninvariants. 8. Speeding up the Convergence of Fixpoint Tech\u00adniques for Approximating Resource Invariants \nFor linear SCL programs the notion of W~d~n?kg of Cousot [C077] may be used to speed up conver\u00adgence \nto U(FC) . The widening operator * is characterized by the following two properties: (A) for all adm<ssabl~ \npredicates U and V, U~ U*V and Vc U*V   (B) for any ascending chain of admissible pre\u00addicates uo~u1~u2~... \nthe ascending  chain defined by V. = Uo, Vi+~=Vi*Ui+~ is eventually stable i.e., there exists a k>Q_ \nsuch that for i>k,Vi=V . k In this paper the adnissable predicates are the polygonal convex sets of Qm \nwhere Q is the set of rational numbers and m is the number of resource variables belonging to R. The \nwidening operator * that we use is a modification of the one used by Cousot [C0781. Let U and V be polygonal \nconvex sets. Then U and V can be represented as conjunctions 9 h U= Ayj and V= Ad j =1 k=l k where each \nconiunct is a linear inequality of the form We further assume alxl +... amxm+am+l s 0 that the representation \nof U and V is minimal, i.e. , no conjunct can be dropped without changing U or V. We say that two linear \ninequalities y. and 6 are equivalent if they determine the same k half space of ~. U*V is the conjunction \nOf all t+l e+l CH~+l *Gt+k+2=H:+2 those yj in the representation of U for which k+l = k * t+k+2 there \nis an equivalent 6 in the representationk Note that H~lCH~+l implies H~l~H~+l. Thus of v. Thus the widening \noperator throws out all those constraints in the representation of U ~t+l m =UH~l~;Ht .It and the sequence \nwhich do not occur in the representation of V. k=O k=O +1 #1 lJ(Fc) chain We now . Since F~(false) describe \nthe the predicates ~ F~(false) strategy for approximating F~(false) in the ~ . . . may not be 10311312~ \n--In . practice is when a decreasing computing It chain we in stop 2.. 0 polygonal convex sets, let \nGi=CVIF~(false)] generating the predicates H:, UJ. H:, . . . as soon as where CV is the convex hull operato~. \nThe a predicate ; is found such that Ht= 1 H ;+1 . lf sequence GO~G1~... is a chain of polygonal the \nlimit convex sets. The sequence tI will be used in ob\u00ad taining a good approximation to the strongest \nresource invariant for R and is defined by , It=lJH. t of ant the for truncated C, then chain fails \nadditional to be predicates a resource in the invari\u00adse\u00ad where j=~ H;=G t 3 and H!3+1 =H~*G J t+j+l quence \nstruction ~t j of may It have to provides be computed. a procedure Thus the con\u00adwhich may be (A) THEOREM \nEach It 8.1. can be corrputed in a finite number used to to the obtain strongest successively resource \nbetter invariant approximations V(FC) . of steps. We demonstrate this method of synthesizing (B) H(FC) \n~It for t ~~. resource invariants by considering the program C (C) The sequence It ~S a decreasing chain. \nin z a:=l cobegin i.e., 11a12013_ _ . . . A: cycle P(a); SA; V(a) end tion Proof of a of (A): widening \nBy condition operator the 2 in sequence the defini\u00ad // B: coend cycle P(a); SB; V(a) end tttHo, HI, H2, \n. . . must eventually stabilize. Thus discussed in Section 4. The function c in thie there exists a \nk such that caee is given by It = k UH: . FC(J) =a~=O Aaf=O Aa~=o Aa~=o Aa=o j=~ 3 VJ Proof of (B) : \nv SP [a; :=a~+l; a:=a-l] (a~=a~Aa>OA J) co. p(FC) = U F1(false) vSP [a: :=a~+l; a:=a+l] (a~-l=a~AJ) i=l) \nco VSP[a~:=a&#38;; a:= ~11(al=a2Aa>o 22 AJ) c . U CVIF1(false)] i=o VSP[a2:=a~+l;2 a:=a+l] (a~-l=a~AJ) \nm c U G. While C is quite simple and can be handled by the j=o 1 methods of Section 4, there are potentially \nan in\u00ad co finite number of states and the chain c UG j=() t+] . F~(false) ~F~(false) ~ F~(false) 5 . \n. . does not c ; ~t converge. tions It By computing however, we the obtain: sequence of approxima\u00ad j=o \nj c It Proof of (C): Let U and V be poly\u00ad gonal convex sets, we write UCV if for every conjunct 6 in \nV, there is an equivalent con\u00ad junct in U. We prove by induction on k that ~t+l k CH:+l . (1) Basis step: \n~t+l CH~*Gt+l .H~ o = Gt+l (2) Induction step: Assume t+l k t Hk+l then Note that is a resource invariant \nfor C and 4 that I implies the semaphore invariant I used a in the proof of absence of deadlock and \nmutual exclusion in Section 4. For the PV program used in Section 5 to illus\u00adtrate the incompleteness \nof the semaphore invariant 16 method, I is strong enough to permit a proof of deadlock freedom. The trap \nstate Z no longer 16 causes a problem since I contains the restraint (b2-d:) +(d;-b;) ~ 1 which is not \nsatisfied by 1 the unreachable feasible points in the progress graph of the program. As a final example \nwe consider the standard solution to the readers and wtiters problem tiith Wtiter priority [BH73] where \nthere are two reader processes and one writer process, e.g., rr:=o; rw:=O; aw:=O; :=0; bl:=O; al az:=o; \nb2:=o; c:=O; d:=O; e:=O; resource (rr, rw, aw, al, bl, a2, b2, c, d, e) : cobegin reader 1 // \u00adreader \n2 // \u00ad writer coend Each reader process has the form: reader i: cycle Ai : with R when aw<O do a. :=ai+l; \n 1 rr:=rr+l O&#38;; read; B,: with R when true do bi:=bi+l; l rr:=rr-1 od; . end The writer process \nis: writer Sr!sE C: with R when true do c:=c+l; aw:=aw+l od; D: wit~R when rNOAn?~O do d:=d+l; . . rw:==rw+l \nO&#38;; E: with R when true do e:=e+l; aw:=aw-l; . rw:=rw-1 Q; end . Note that auxiliary variables al, \nbl? a2, b2, c r d, and e have been added to the program to count the number of times critical regions \nAl, Bl, A2, B2, c, D, and. E are executed. The predicate 15 generated by our approximation procedure \nis: 15 ={aw-c+e=O Arw-d +e = O Arr-al+b -a2+b2=0 1 Aal-bl+d-e~l Aa2-b2+d-e~l Ac-e<l . a2~b2~0 Ac>d>e>O} \n This predicate is a resource invariant for the program and is sufficiently strong to prove absence \nof deadlock and mutual exclusion of read and write statements. 9. Open Problems If a concurrent program \ncontains a large number of critical regions, then the combinatorial explosion in the number of possible \nstates which must be considered by the approximation procedure of Section 8 may prevent convergence to \na suitable resource invariant. We are currently investigating techniques for minimizing this combinatorial \nexplosion. Two techniques which seem promising are: (A) preprocessing the program to obtain information \nabout which states can follow a given state during a computation of the program. For example, in the \nreaders and writers problem, assume that reader 1 is waiting for entry into critical region Al an~ that \naw>O. If reader 2 executes critical region B2, it is unnecessary ~o check whether reader 1 is enabled \nto enter Al since execution of i32 doe; not affect the value of aw. A similar analysis is currkntly used \nin obtaining efficient implementa\u00adtions of conditional critical regions [sc76]. (B) Construct the program \nand its correctness proof simultaneously. Although the programmer may not precisely know the resource \ninvariant for the program he is writing, he may be able to deduce a first approximation to the invariant \nfrom the problem specification. In this case the technique of Sections 7 and 8 may be used to strengthen \nthe approximation. Techniques for deriving correct concurrent programs have been investigated by van \nLansweerde and Sinkzoff [LA76j. A number of additional questions arise re\u00adgarding the power of the generalized \nsemaphore invariant of Section 6 and the fixpoint methods for generating resource invariants in Sections \n7 and 8. It would be interesting to compare these proof techniques with other techniques which do not \nuse resource invariants, e.g., the Church-Rosser approach of Rosen [R076] and the reach\u00adability tree \nconstruction of Keller [KE77]. Al SO it is not clear how the techniques of this paper generalize to synchronization \nmethods such as path expressions [HA75] for which linear restraints are not explicitly given. Currently \nthe author is building an automatic verification system for concurrent programs based on the ideas in \nthis paper. This system will ex\u00adtract the synchronization skeleton of a con\u00adcurrent program and use the \ntechniques of Sections 6 and 8 to generate the appropriate resource invariants . The examples of Section \n8 were all obtained with the aid of this system. References [AG741 [BH731 [CL77] [c076] [C078] [D167] \n[FL77] [HA721 [HA75] [H072] [KE77] [LA76] [L1751 [LM771 [OW76] [PN77] [R0761 Agerwala, T. senting the \nprocesses. John Hopkins A complete model for repre\u00adcoordination of asynchronous Computer Research Report \n32, University, Baltimore, MD. [SC76] Schmid, mentation and the Informatica, H. A. On the of conditional \nconstruction 6:227-249,. efficient critical of monitors. 1976. imple\u00adregions Ac ta Brinch Hansen, Prentice-Hall, \nP. Operatin NJ, 1973. System Principles, Clarke, fixedpoints. Foundations E. M. of Program invariants \nas 18th Annual Symposium of Computer Science, Nov. 1977. Cousot, P. and Cousot, R. Static mination of \ndynemic properties of Proc. 2nd International Symposium graming, B. Robinetr Ed., Dunod, April 1976. \ndeter\u00adprograms. on Pro-Paris, Cousot, P. and Halbwachs, N. discovery of linear restraints ables of a \nprogram. Proceedings ACM Symposium on Principles of Languages, 84-96, 1978. Automatic among vari\u00adof 5th \nProgranuning Dijkstra, E. processes. Ed. , Academic W. Cooperating sequential Programming Languages, \nG. Genuys, Press, NY, 1968. Flon, L. and Suzuki, N. Nondeterminism the correctness of parallel programs. \nDepartment of Computer Science, Carneyie Mellon University, 1977. and Habermann, communicating 176, 1972. \nA. N. Synchronization processes. CACM, . of com\u00ad15(3):171- Habermann, A. N. Path expressions. partment \nof Computer Science, Carnegie Mellon University, 1975. De- Hoare, C. A. R. Towards a theory parallel \nprogramming. Operating Techniquesr C. A. R. Hoare, R. H. Ed., Academic Press, 1972. of Systems Perrot, \nKeller, models Science University R. M. Generalized for system verification. Department Technical of \nUtah, 1977. petri nets as Computer Report, z van Lamsveerde, A. and derivation of strongly programs. \nM8LE Research Belgium, 1976. Sintzoff, correct Report, M. Formal parallel Brussele, Liptont R. J. Reduction: \nA new proving properties of systems of Proceedings of 2nd ACM Symposium ciples of Programming Lang ages, \n1975. method of processes. on Prin\u00ad78-86, Lamport, multiprocess on Software L. Proving programs. Engineering, \nthe correctness of IEEE Transactions ~(2) :125-143, 1977. Owicki, perties approach. S. and Gries, D. \nVerifying pro\u00adof parallel programs: An axiomatic CACM 19(5):279-284, 1976. . Pneuli, A. The temporal \n18th Annual Symposium on Cbmputer Science, November logic of Foundations 1977. programs. of Rosen, B. \nK. Correctness grams: The Church-Rosser Theoretical Computer 1976: of parallel Approach. Science, ~183-207, \n,prO \n\t\t\t", "proc_id": "567752", "abstract": "Owicki and Gries have developed a proof system for <i>conditional critical regions.</i> In their system logically related variables accessed by more than one process are grouped together as <i>resources,</i> and processes are allowed access to a resource only in a critical region for that resource. Proofs of synchronization properties are constructed by devising predicates called <i>resource invariants</i> which describe relationships among the variables of a resource when no process is in a critical region for the resource. In constructing proofs using the system of Owicki and Gries, the programmer is required to supply the resource invariants.We show that <i>convexity</i> plays a key role in the derivation of strong resource invariants. We also develop methods for automatically synthesizing resource invariants. Specifically, we characterize the resource invariants of a concurrent program as <i>least fixpoints</i> of a functional which can be obtained from the text of the program. By using this fixpoint characterization and a <i>widening operator</i> which exploits our observation on the importance of convexity, good approximations may be obtained for the resource invariants of many concurrent programs.", "authors": [{"name": "Edmund Melson Clarke", "author_profile_id": "81100393517", "affiliation": "Harvard University, Cambridge, Mass.", "person_id": "P74802", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/567752.567772", "year": "1979", "article_id": "567772", "conference": "POPL", "title": "Synthesis of resource invariants for concurrent programs", "url": "http://dl.acm.org/citation.cfm?id=567772"}