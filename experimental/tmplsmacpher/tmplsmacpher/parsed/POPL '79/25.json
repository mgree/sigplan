{"article_publication_date": "01-01-1979", "fulltext": "\n Permission to make digital or hard copies of part or all of this work or personal or classroom use is \ngranted without fee provided that copies are not made or distributed for profit or commercial advantage \nand that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, \nto post on servers, or to redistribute to lists, requires prior specific permission and/or a fee.&#38;#169; \n1979 ACM 0-12345-678-9 $5.00 SYSTEMATIC DESIGN OF PROGRAM ANALYSIS FRAMEWORKS Patrick Cousot* and Radhia \nCousot** Laboratoire d Informatique,U.S,M.G. , BP.53X 38041 Grenoble cedex, France 1. INTRODUCTION and \nSUMMARY Semantic analysis of programs is essential in optimizing compilers and program verification sys\u00adtems. \nIt encompasses data flow analysis, data type determination, generation of approximate invariant assertions, \netc. Several recent papers (among others Cou.sot &#38; Cousot[77a], Graham $3 Wegman[761, Kam 8 Ullman[76], \nKildall[731, Rosen[781, Tarjan[76], Wegbreit[75]) have introduced abstract approaches to program anal\u00adysis \nwhich are tantamount to the use of a prmgrwm cnzazysis j%zmework (A,t,y) where A is a lattice of (approximate) \nassertions, t is an [approximate) pred\u00adicate transformer and Y is an often implicit func\u00adtion specifying \nthe meaning of the elements of A. This paper is devoted to the systematic and correct design of program \nanalysis frameworks with respect to a formal semantics. Preliminary definitions are given in Section \n2 concerning the merge over all paths and (least] fixpoint program-wide analysis methods. In Section \n3 we briefly define the [forward and backward) deduc\u00adtive semantics of programs which is later used as \na formal basis in order to prove the correctness of the approximate program analysis frameworks. Section \n4 very shortly recall the main elements of the lattice theoretic approach to approximate semantic analysis \nof programs. The design of a space of approximate assertions A is studied in Section 5. We first justify \nthe very reasonable assumption that A must be chosen such that the exact invariant assertions of any \nprogram must have an upper approximation in A and that the approx\u00adimate analysis of any program must \nbe performed using a deterministic process. These assumptions are shown to imply that A is a Moore family, \nthat the approxi\u00admation operator (with defines the least upper approx\u00adimation of any assertion] is an \nupper closure operator and that A is necessarily a complete lattice. We next show that the connection \nbetween a space of approxi\u00adnlate assertions and a computer representation is nat\u00adurally made using a \npair of isotone adjoined func\u00adtions. This type of connection between two complete lattices is related \nto Galois connections thus making available classical mathematical results. Additional results are proved, \nthey hold when no two approximate assertions have the same meaning. This work wae supported in part by \n(*) CNRS, Laboratoire ~ssoci6 n07 and ATP-Informatique D3119 and in part by (**) IRIA-SESORI. In Section \n6 we study and examplify various methods which can be used in order to define a space of approximate \nassertions or equivalently an approx\u00adimation function. They include the characterization of the least \nMoore family containing an arbitrary set of assertions, the construction of the least closure operator \ngreater than or equal to an arbitrary approx\u00adimation function, the definition of closure operators by \ncomposition, the definition of a space of approxi\u00admate assertions by means of a complete join congruence \nrelation or by means of a family of principal ideals. Section 7 is dedicated to the design of the approximate \npredicate transformer induced by a space of approximate assertions. First we look for a rea\u00adsonable definition \nof the correctness of approximate predicate transformers and show that a local correct\u00adness condition \ncan be given which has to be verified for every type of elementary statement. This local correctness \ncondition ensures that the (merge over all paths or fixpointl global analysis of any program is correct. \nSince isotony is not required for approx\u00adimate predicate transformers to be correct it is shown that \nnon-isotone program analysis frameworks are man\u00adageable although it is later argued that the isotony \nhypothesis is natural. We next show that among all possible approximate predicate transformers which \ncan be used with a given space of approximate assertions there exists a best one which provides the maximum \ninformation relative to a program-wide analysis method. The best approximate predicate transformer induced.by \na space of approximate assertions turns out to be isotone. .Some interesting consequences of the existence \nof a best predicate transformer are examined. One is that we have in hand a formal spec\u00adification of \nthe programs which have to be written in order to implement a program analysis framework once a representation \nof the space of approximate asser\u00adtions has been chosen. Examples are given, including ones where the \nsemantics of programs Is formalized using Hoare[78] s sets of traces. In Section 8 we shqw that a hierarchy \nof approx\u00adimate analysas can be defined according to the fine\u00adness of the approximations specified by \na program analysis framework. Some elements of the hierarchy are shortly exhibited and related to the \nrelevant literature. In Section 9 we consider global program analysis methods. The distinction between \ndistributive and ! non-distributive program analysis frameworks is studied. It is shown that when the \nbest approximate predicate transformer is considered the coincidence or not of the merge over all paths \nand least fixpoint global analyses of programs is a consequence of the choice of the space of approximate \nassertions. It is shown that the space of approximate assertions can where DdZ(i)L is the set of Daths \nfrom the entrv J always analysis be refined so of a program that can the be merge defined over by all \npaths means of a point ni to the vertex i and ~~ (E*+ (A+A]] is re\u00ad least fixpoint of isotone equations. \ncursively defined as follows : if p is an empty path Section 10 is devoted to the combination of program \nanalysis frameworks. We study and examplify then ~[pl is the identity map on A else p= (q,al how to perform \nthe sum , ~product)~ and ~~power~~ of where qcE *, acE and ~(p) =A@.t[C(a)I[~(q) ($)l. program analysis \nframeworks. It is shown that comb\u00ad ined the analyses conjunction lead of to the more accurate corresponding \ninformation separate than ana- The system of aquaixbns P=Fm(t,@) [P) czssoeiated lyses but this can only \nbe achieved by a new design vith the program n us{ng (A,tl and @ is defined as of the approximate predicate \ntransformer induced by follows : the combined program analysis frameworks. P =4 ni 2. PRELIMINARY DEFINITIONS \n1 P= j i u cpred(j) t[C[<i,j> ) [Pil if j.c[l,n]-{nil Notation : If M(E,l.T,lJ,ll] is a complete lattice \nAp?ogrczm T is a pair (V,G] where G ima pro\u00adgram graph and V is the universe in which the pro\u00adgram variables \ntake their values. The set L of elementary commands consists in elementary tests and elementary assignments \n: L=LtuL, An elementary test qeL is a total mapt from cbm~ql~v into ~={tme,j%zse]. An elementary as.s-tgnment \nee La is a total map from dom(e] SV into then the set [L+MI of total maps from the set M is a complete \nlattice (L +-M] (S ,l ,T~,U ,n ) the pointwise ordering fE g iff VXEL, f[x]~g(x]. In the following the \ndistinction between S, 1, NandS , 1 , T , u , n will be determined by context. Also a map f< (L+M] will \nbe extended (2L+2M) as ASe2L.{f[x) :xeS} and to (Ln+Mn) A<xl ,. ..,xn(< f(xl),), f(xn)>ln)>l . L into \nfor T, U, the to as v. A progmm gmph G is a tuple (n,E,n.,n 10 ,C) where n is the number of vertices \n(therefore n> 11, 30 DEDUCTIVE SEMANTICS OF PROGRAMS Es[l,n]2 is the (non-empty] set of edges, nie[l,n] \nis the entry point, no c[l,n] is the exit point and Cc [E+~l defines the command C[<i,j~l associated \n3.1 Forward Semantics with each <i,j> in E. Let predc[~,n]+2[ n] be Aj.{ie[l,nl Xi.{jc[l,nl pred(ni) \n=@, : <i,j>~E} : <i,j>c suee(nol and s~~e~[l,n]+z [I,nl E}, then we assume that =@ and for any vc[l,n]\u00ad \nbe The forwa~d semantic anazys zk of a programm consists in determining at each program point an in\u00advariant \nassertion which characterizes the set of states which are the descendants of the input states {ni,no}, \npred(v]#@ and suee(v) *@. satisfying a given entry assertion $. ExaypZe 2.0.1 V More into R. precisely \nThe set an assertion is a total A= (V +B)(=>,lX~V.~aZse, map from The program : lX~~.true,v,A,-) of assertions \nis a complete boolean ~,1 begin lattice partially ordered by the implication >. , {2} whiZe xSIOO do \n{3} x := X+1; {41 Ocz; end will be represented by its {x is an integer {no overflow can program graph \n: variable] occur} Let Sp(S] [P) be Floyd[67] s stron est post-condi\u00adtion derived from the pre-condition \nPCf for the ele\u00admentary command SL. We assume that the operational semantics of the elementary commands \nis such that for an elementary test we have : l%. sp(q) =APc~,[AxEV. [P(X) AXedom(q] Aq(x))] XX. [x<loo] \nAx. (x>loo) whereas for an elementary assignment e we have : \\ sp(el =kPcA.CIX<~.[~Y~~ : P(Y) AYedOm[e) \nAX=e(Y))~ ? (Notice that for all SEL, SP(SI is a complete join\u00admorphism (i.e. VAGA, sp(S) (VA] =vsp[S) \n[A)]). We assume that the operational semantics of the program K is such that at each program point i~[l,n] \nax[x oo ck=;o) the invariant assertion pi which characterizes the End of exampZe. set of states which \nare the descendants of the input states satisfying a given entry assertion @A is the If A(S,l,T,U,n) \nis a complete lattice, merge over all paths analysis of T using Sp and $. tc(L+(A+A)) and ~cA then the \nmerge over aZZ paths P is the least fixpoint L~p[FT[Sp, $]] of the system anaZysZs of m using [A,t) and \n@ (MoPm[t,@)) is PcAn of equations P Fm[Sp,$] (P) associated with the pro\u00ad defined as : gram IT using \nSp and $. Vie[l,nl, Pi = u ;(p) [0) p~path(i) Examp2e 3.1.0,1 The system of forward semantic equations \nasso\u00adciated with the program 2.0.1 is : PI =4 P* = sp(ax.[xslooll (P1vP3) P3 = SP(XX.[X+II)(P2] I P4 \n= sp(kx.[x>lool) (P1vP3) taking @=Ax.(x=ll its least fixpoint characterizes the descendants of the input \nstates satisfying @ : PI = ax, (x=l] P2 = lX. (ISXSIOO) P3 = Ax. (2~x~lol) P* = Ax. [x=lollI End of \nExample. 3.2 Backward Semantics The backward semantic analysis of a program con\u00adsists in determining \nat each program point an invari\u00adant assertion which characterizes the set of states which are the ascendants \nof the output states satis\u00adfying a given exit specification $. Since we can consider the inverse of the \nstat e transition rela cion defined by the operational seman\u00adtics no new formalism is necessary in order \nto treat backward program analysis. Instead of Floydts for\u00adward predicate transformer we just have to \nconsider Hoare[69]-Dijkstra[76] s backward predicate trans\u00adformer : ?@(q) =AP<A.[AX.V.(P(XI AXe&#38;m(q] \nAq(X])] #p[e] =lp~A.[LXeV. (Xcdom(e] AP(e(X)))] (notice that WSCL, tip[S) is a complete join and meet \nmorphism) and the inverted ppograrn grwph ~J=(n,EJ,nO, ni,C ) where E~={<i,j> : <j,i>~E}, C =A<i,j>eE~, \n[C(<j,i>ll. Examp Le 3.2.O.1~ The inverted program graph corresponding to 2.0.1 is : 1 ax. [xslool ax. \n(x>loo) 24 Xx. [xsloo) XX. [x+l) AX. (x>loo) &#38; 3. The corresponding system of backward semantic \nequations is P1=Vp Ax.Ex<looll (P2)vtip[ax.[x> ool)[Pk) P2=wp AX.[X+II)(P3) P3=?Jp AX.[XSIOO])(P2) VZJP[AX.[X> \n001) [P41 P4=l$ The merge over all paths and least fixDoint char\u00adacterizations of the ascendants of \nthe output states satisfying the exit specification $=Ax. (x=IOI) are both equal to : PI = ax. (xslol) \nP2 = Ax. (xslool P3 = Ax. [x<loll P4 = @ = Ax. (x=lollI End of Example. In the following no distinction \nwill be made be\u00adtween forward and backward program analyses because of the above mentioned symmetry. \n4. APPROXIMATEANALYSIS OF PROGRAMS The semantic analysis of programs cannot be au\u00adtomatized since neither \nthe merge over all paths nor the least fixpoint characterization of the invariant assertions to be generated \nleads to a computable func\u00adtion. Therefore optimizing compilers and program verification systems are \nonly concerned with the dis\u00adcovery of approximate invariants assertions. Here an approximate invariant \nassertion Q will be one which is implied by the exact invariant assertion P defi\u00adned by the deductive \nsemantics. DEFINITION 4.0.1 If P,QGA then Q approximate P iff P=~Q. This definition of approximate is \nthe one which is useful in logical analysis of programs, data type determination and data flow analysis.(The \ndual one might be useful (e.g. for proving termination)]. The now classical lattice theoretic approach \nt.o approximate analysis of programs can be briefly sketched as follows : the representation of an ap\u00adproximate \nassertion is an element of a complete lat\u00adtice A(~,l,T.U,n). The meaning of the elements of A is specified \nby a (tob often implicit)_order morphism Y mapping A to a subset of assertions A=Y(A) GA. The intention \nis that A is an implementable image of those aspecta Y(AI of the program properties which are to be understood \nat each program point whereas the assertions belonging to A-Y(A) are ignored (that is approximated from \nabove in Y(A)]. To each elem\u00adentary command SeL is associated an isot one map t(S) from A to A. The intent \nis that t[S) is an approx\u00adimate predicate transformer such that t[S)(il repre\u00adsents the propagation of \nthe information icA through the etatement S. The ideal merge over all paths program-wide anal\u00adysis (Graham \n&#38;Wegman[761, Kam&#38;Llllman[77], Rosen[781, Tarjan[76]) is often approximated by a fixpoint solu\u00adtion \n(Cousot &#38;Cousot[77al, Jones RMuchnick[76], Kaplan &#38; Ullman[78], Kildall[73], Tenenbaum[74], WegbreitE7511. \nA fixpoint system of isotone equations X=F(X) where Fe (An+An) is associated with the pro\u00adgram graph. \nThe approximate invariant assertions are generated by computing iteratively the least fixpoint of F starting \nfrom the infimum of An and using any chaotic or asynchronous iteration strategy (Cousot [77]) or the \nleast fixpoint is approximated from above using an extrapolation technique in order to accelerate the \nconvergence of the iterates whenever A does not satisfy the ascending chain condition (Cou50t&#38;Cousoti \n77a11. The design of A, t, the implicit y and the de\u00ad termination of the construction rules for F are \noften empirical. The correctness of the least fix\u00adpoint analysis is usually proved with respect to the \napproximate merge over all paths analysis, the cor\u00adrectness of which is taken for granted. As opposed \nto this empirical approach we now provide a formal approach to the systematic design of an approximate \nprogram analysi~ framework [A,t,yl given (V,A,T) where T is Sp for forward and ?@ for backward pro\u00adgram \nanalyses. 5. DESIGN OF A SPACEz.OFcAPPROXIMATE ASSERTIONS 5.1 A Very Reasonable Assumption Assume that \nfor a specific-purpose analysis of prcgrams a subset 7%A of assertions has been found to provide meaningful \ninformation. Since any invariant assertion P<A for any pro\u00adgram must have an upper approximation Q in \n~, the set {Qc~ : P=>Q} must be non empty. Let PeA be an assertion and assume that we want to analyze \na program m using the merge over all paths eemantic analysis and an entry condition Q which is an upper \napproximation of P in X. What is the best choice for Q ? It is clear that if P=> Q =>Q then FT[ C,Q )=>Fn[T,Q) \nand by isotony the analysis Z~p(Fn[T,Q ]l is more precise than Zfp(FT( T,Q)). Hence Q muet be a minimal \nupper approximation of P in ~ (that is such that {P*Q A (~Q e ~-{Q] : P-Q A Q => Q]}). Assume that the \nset U of mini\u00admal upper approximations of P in ~ has a cardinality greater than 1. What is the best possible \nchoice for Q in U? If Q1,Q2cU and QIzQ2 then QI and Q2 are not necessarily comparable so that Z~p(FT(T,Ql)) \nand 2@(FT(T,Q2)) may be not comparable. Hence best cannot be defined using the preciseness criterion \nprovided by the ordering ~. The only way to deter\u00ad mine which of the two alternatives will be the most \nuseful in order to answer a given set of application dependent questions about the program is to try \nboth of them. Also the best choice may vary from one program to another. This try and see choice method \nleads to a non-determinist analysis method which is unacceptable because of obvious efficiency consider\u00ad \nations. Therefore it is reasonable to choose ~ such that Card(U)=l. Example 5,1.0.1 Assume that A= (2x2)+73 \nwhere Z is the set of integers and ~= {A(x,yl.[Px(x) APY(Y)] : PX,P E {Au.faZse,lu.u20,Au.usO,Au.trv@]}. \nThe aese~tton P=k(x,y). (x>O A y~Ol has two distinct minimal upper approximations in A namely QI A[x,Y). \n[x20 A YSOI and Q2 =k[x,yl .(x20 A YSO). Now the choice of the most useful upper approximation of the \nentry asser\u00ad tion P is program-dependent. For example the best choice is QI for the program x:=x+Y. This \npositive declaration can only be justified by performing the two semantic.analyses (i.e. SP(X:=X+YIIQI) \n= I(x,yl. (xzy A y201 and Sp(x:=x+y)(Q2] = A(x,y). (x>y A Y~Ol) and nex c comparing them, Since these \nanal\u00adyses are not related by the ordering >, the comar\u00adison criterion must be application dependent. \nFor example using QI we can prove that sp(~x.x+Y)[Ql ~ X(x,y). (x~O) whereas this is impossible with \nQ2. On the contrary the best choice is Q2 for the Program x:=-x; X:.x+y since sp(x:=-x; X:=X+y)(Q2) = \n~[x,yl. (x<y A y<(i) which impliee l(x,y). (x<O) whereas sp[x:=-x; X:=X+Y)(QII = AIX,Y1. (X~Y A Y~Ol \ndoss not imply l(x,yl. (xSOl. End of Example. If any program must have an ~nalysis which can be approximated \nfrom above using A, and the process for deriving the most useful approximate analysis of any program \nis required to be determinist then it is reasonable to make the following : ASSUMPTION 5.1.0.2 The set \n~zA of approximate assertions must be chosen such that for all PCA ~he set {Qc~: P=>Q} of upper approximations \nof P in A has a least element. THEOREM 5.1.0.3 For all PeA the set {Qc~:P+Q] has a laast alement if and \nonly if ~ is a Moore fti2y (i.e. T contains the supremum of A and is closed under conjunction).  5.2 \nThe Approximation Operator DEFINITION 5.2.0.1 Approximation Operator p < A+Z p . lP.A{Q61 : PsOI O(P) \nis the least u~per approximation of p in ,. ,. 7, Since ~ is a Moore family it follows from Monteiro \n&#38;Ribeiro[42,Th. 5.3and 5.11 that : THEOREM 5.2.0.2 [1) p is an upper closure operatol (that is P \nis isotone [if P,QcA and P-Q then Pap, axtensive (for all PCA, P=> P[P)] and idempo\u00adtent [p=p P) (2)- \nP[A) =~ (3) -P is the unique upper closure oparator on A such that P(A) =~ Since ~ is equal to the image \nof the complete lattice AC=>,lX.faZse,kx.t~ue,v,Al by the upper clo\u00adsure operator p we derive from Ward[42,Th.4.1] \nthe following : THEOREM 5.2.0.3 faZse ) , (1]-~is a complete lattica PIAI(=>,P(~x Ax.*zw,ls.P(%),A) \n2) -p is a quasi-complet~ join-morphism i.e. VSGA, p[VS) = p(vp(S))]  3) -7$ is a complete sub-lattice \nof A iff p is a com\u00adplete join-morphism (i.e. WSSA, P[VS) VP(S)) If the initial choice of ~ does not \nsatiefy assumption 5,1.0.2 we can use the following : THEOREM 5.2.0.4 If IsA, the upper closure operator \nP on A such that p(A) ie the least Moore family containing X is : p = lP.A{Qc{Tu {kX.-b-Wll : P=Q} p(A) \n= A{S : ss~u{~x.true}} A S:@}  Exanple 5.2.0.5 Returning to example 5.I.o.I where A=(Z+B) and ~= {ku.~~LS@,lu.u20,ku.u<O,Xu.~pu@} \nthe least Moore fam~ly containing ~ is the one containing Au.~n@, A and the meets of the non-empty subeets \nof ~ that is the complete lattice : Au.true Au.u<o AU.U20 Au.u=o 9 Au.false The corresponding approximation \noperator is : P = Ap.if p=Au.YaZse then Au.fa2se els{~ P=>~u.u=O then ~u.u=O etsif P=> Au.u~O then Au.u20 \nekif ?=> Xu.u~O then lu.u<O else Au.trwe fi End of Example. 5.3 Representation of the Lattice of Approximate \n,, Assertions  In order to represent the approximate asser\u00adtions in a computer memory we must use a \ncomplete lattice A(!=,l,T,lJ,fll such that the similar algebras 7i=p(A) (=>,lX.faZsa,iX.tzwe,AS.p [vSI,AI \nand AIE,I, T,u,n) be isomorphic. Let ye [A+~l be the corres\u00adponding lattice isomorphism. Let CIC(A+AI \nbe -1 Y P. a(P) is the representation of the least upper approximation of the assertion PCA whereas \nY(QI provides the meaning of QeA. The connection <a,y> between A and A has the following propert y : \nDEFINITION 5.3.0.1 Let Ll[~I) and L2(G2) be posets. <~,y> is a pa~p of adjoined functions if and only \nif : -uc [Ll +L2) is isotone -y< (L2+LI) is isotone r VXCLI, WycL~, {X EIY(y)} e {a(X] E2y} (Contrary \nto Scott[72] sdefinition, L1 and L2 are not required to be continuous lattices and a, Y need not be continuous]. \nTHEOREM 5.3.0.2 If p is an upper closure operator on A, the image y(A) of A(E,l,T,U,n) through the lattice \niso\u00admorphism y is equal to p(A) (-, p(kX.~aZse),XX.*ru@, AS,p(VS),A] and a, = ~-~op then -<a,y> is a \npair of adjoined functions . -a is onto, y is one-to-one Reciprocally the approximation process can be \ndefined by the lattice A[51,T,l],nl and a pair of adjoined functions. Such a pair @.,y> defines a Galois \ncon\u00adnection between A and the dual of A : DEFINITION 5.3,0.3 Let Ll(sl) and L2(E2) be posets, ae (L1+L2), \ny= (L2+L1). The pair <u,y> defines a GaZo;s eon\u00adnec~~on between L1 and Lz if and only if : (1) -a is \nantitone (Vxl, x7.~L1, {XI 51 x2} > {arxl132a (x2)}l (21 -y is ant it one Wy1,y2eLZ, {yl E2Y2} {y(yll \n21y(y211) (31 -AxcL1. (xI SI y J~ (4) -lyeL2, (y) 52 ~ y The above conditions [3) and (4) are equivalent \nto : VXCLI, VycL2, {XEI y[y)] + {C4(X) 22 Y] (Birkhoff[67]), hence we have : THEOREM 5.3.0.4 Let LIIs1), \nL2(s21 be posets, ac (LI+L2)J yf(L2+Ll). <~,y> is a pair of adjoined functions if and only if <a,y> defines \na Galois connection between LIIGII and L~[Ell =L2(221, [i.e. iff a and y are isotone, lxox51yoa, aoyE21y.yl \nTheorem 5.3.0.4, 0re[44,Th.2] and pickert[521 imply : cOROLLARY 5.3.0.5 Let LI(S1] and L2[s2) be posets \nand ~e (LI+L2). y~ [L2+L1] be adjoined functions : [1) -YOU is an upper closure operator on LI, UOY is \nr a lower closure operator on Lz(i.e. isotone~ reductive [a y~a x.x) and idempotent) Moreover if LI(EI,ll,TI,UI,D1) \nand L2(E2,J2,T2#U2Jf12) are complete lattices then : (2) -YOCI(LII and aoY(L2) are comPlete lattices. \n~ is an isomorphism from yoci(LI) onto CIOY(L2) and y is an isomorphism from CXOY(L2) onto YOCX(L1) (31 \n-Each function in the pair <cx,y> of adjoined functions uniquely determines the other, more precisely \n: (3.1) -a =Ax~Ll.n2{y~L2 :x% Y(Y]} [3.2)-Y=AY~LZ.UI{XeLl :a[xl~2Y} (41 -U is a complete join-morphiem, \n~(11]=J2, Y is a complete meet-morphism, Y(T2]=T1 In complement we will need the following : THEOREM \n5.3.0.6 Let Ll(SI,ll,T1,l]I,Vll and Lz[52,~2,T2,D2s~2) Tbe complete lattices and ~c (L1+L2), Y< (L2+L1~ \nbe I adjoined functions : I (l; -a is onto (eur~ectivel if and only If y is one\u00adto-one [inject~ve) and \nif and only if a y AycL2. [y) (2) -if one of the above conditions holde then -y = Xye L2.Ul{Xc LI : \na(x)=yl -a is an isomorphism from the complete lattice yoci[Ll) onto the complete lattice L2 the in\u00ad \nverse of which is Y. (31 -a is one-to-one if and only if y is onto and if and only if yoa = AxsLI. (x) \nWe use the notation LI~ci,Y>L2 to state that LI and L2 are connected by the pair <CI,Y> of adjoined functions \nwhich are respectively subjective and in\u00adjective. If a is a complete join-morphism from LI onto L2 (respectively \ny is a one-to-one complete meet-morphism from L2 into Lll we write L1~cx,>L2 [L1P<,Y>L2) and assume that \nthe adjoined y(a) is determined by 5.3.0.5.(3.2) (5.3.0.5.(3.111. In the literature the meet usual method \nfor defining a program analysis framework is to specify the complete lattice A(G,l,T,U,~] representing \nap\u00adproximate assertions and to informally deecribe the meaning of its elements (e.g. conetant propagation, \nKildall[73], Kam&#38;Ullman[77]). Hence the function Ye (A+A) remains implicit. It is often the case \nthat A is only assumed to be a (complete] join-semi-lattice A(=,T,U) (or dual\u00adly meet-semi-lattice for \nsome authors] but since an infimum is adjoined to A it is in fact e complete lattice (even when the meet-operation \nis not used or what is called meet is not n (e.g. Wegbreit[751)l. When Y< (A+A) is isotone but not a \ncomplete meet-morphism the set y(A] does not fulfill assump\u00ad tion 5.1.0.2 with the consequences examined \nat para\u00ad graph 5.1. The design of y(A) and A can be revised as stated by theorem 5.2.0.4. When ye (A+AI \nis a complete meet-morphism but not one-to-one, several distinct elements of A have the same meaning. \nSince this is useless, the deeign of A and Y can be revised as follows : THEORE~ 5,3.0.7 Let AIE,l,T,U,fl) \nbe a complete lattice and ye (A+A) be a complete me~t-morphism. L~t IS~ [A+AI be Ax.~{yeA : Y(X]=Y(Y)}, \nA=cf(Al, ~=[Y\\A) : -b xeA, y(x) y[O(X]) -u is a lower closure operator on A -y is a one-to-one-complete \nmeet-morphism from the complete lattice A(E,l,OIT),U,~S.C(nS)) into A Since y(A) =7(X), A and ~ have \nthe same expres\u00adsive Dower. Among all subsets of A which have the expressive power of A, X is one with \nminimal cardi\u00adnality. THEOREM 5.3.0.8 [11-VLGA, {YIL)=YIA)I=> {IS(LI ~} r [2)-VLSA, {Y(L) =Y(A)} + {Card[~l \nSCard(Ll}I(31 - dxcAiVy&#38;% {yix)=y[y)}=> {ysxl 6. EQUIVALENT METHODSFOR SPECIFYINGA SPACE OF APPROXIMATE \nASSERTIONS A space o+ approximate assertions can be speci\u00adfied either by a Moore family or by an upper \nclosure operator. Moore families can be characterized using definition 5.3.0.2 or theorems 5.1.0.3 and \n5.2.0.4. In addition to theorems 5.2.0.2. (1) and 5.3.006 we now study and examplify various equivalent \nmethods which can be used to define an upper closure opera\u00adtor.  6.1 Least Closure Operator Greater \nthan or Equal to an Arbitrary Function THEOREM 6.1.0.1 Let L(E,l,T,U.n] be a comPlete lattice and c[L+L). \nLet LscJc([L+L)+[L+ L)) be kf.[~x.U{f(Yl :YSx~l iso(f) is the least isotone operator on L greatar than \nor equal to f Let ezrte([L+L)+(L+L)) be Af.[kx.[xUf[x)]]. ad(f) is the least extensive operator on L \ngreater than or equal to f Let ~dec ([L+L)+(L+L)] be Ax.[zuis(f ](x)] where h&#38;[f)(x) is the limit \nof the increasing and 8 ultimately constant sequence {X } such that XO=x, 8+1 for every ordinal 6, X \n=f(X61 and for every limit ordinal ~, X6 = U Xa ~<~ eb(f) = tde(ezt(_tso(f)]) is the least closure operator \ngraater than or equal to f and eZO(fl(L) is the greateet Moore family contained in f[L) i.2. Definition \nof a Space of Approximate Assertions by Composition of Upper Closure Operators The composition of two \nupper closure operators m. A is usuallv not a closure operator (Ore[qal]. However the space of approximate \nassertions call be designed by successive approximations using the following composition of upper closure \noperators : THEOREM 6.2.0.1 Let LIS,l,T,U,n) be a complete lattice, p an upper closure operator on L \nand n ba an uPPer closure operator on P(L). Then rIOp is an upper closure oper\u00adator on L and PS~OP. \nExampZe 6.2.0.2 Many program analysis frameworks are designed in order to describe some properties of \neach program variable but so that the relationships among the values of these variables are ignored. \nAn example is Jones &#38; Muchnick[76] s type determination scheme, a counter-example is the determination \nof linear relationships among numerical variables, Cousot K Halbwachs [78]. The corr~sponding approximation \ncan be characterized as follows : Assume that ~=Qm, let Am be [~+~1 and Al be (D+B). Let us define : \nVjc[l,m], ISj:(Am+AI) 0 =a.PcA .[XX<~.[~<V ,...,V j-l,vj+l>..nJ v>m j m1 evm-1 ,.. .,vm)~l : (vi  vj-l \nX vj+l o=[A +A I ,...,xm)dl[ .[ T o (Pl(xj)ll 1 j=l 3Cr=XP!m.~X[X 274 o is an upper closure operator \non Am and an assertion PeAm does not state relationships among the program variables if and only if O(P)=P. \nThe approximate as\u00adsertions on each individual program variable xj are next defined using an upper closure \noperator Pj on A~. The induced closure operation p on O(AMI 1s de\u00ad fined by p(P) =k[xl, . . ..xm~. .~ \nP.(Pj)(xjl where Pe ~=1 J o(Am) is [necessarily) of the form P= a[xl, . . ..xm). m j~lPj(Xj). It follows \nfrom theorem 6.2.0.1 that the composition : pQO=APEAm.[A(Xl, . . ..Xm)~O[.[ ~ pj(~j(pl)(xj)ll j=~  is \nan upper closure operator on Am. End ofExarnple. 6.3 Definition of a Space of Approximate Assertions \nby Means of a Complete Join Congruence Relation Considering the equivalence relation (PI induced by an \nupper closure operator p on A and defined as P~Q(p) if and only if P(PI =p(Q), the approximation process \ncan be understood as essentially consisting in partitionning the space of assertions so that no distinction \nis made between equivalent assertions which are all approximated by a representant of their equivalence \nclass. Since the approximation is from above and a least one must exist (assumption 5.1.0.2) not all \nequivalence relations are acceptable : DEFINITION 6.3.0.1 Let L(E,l,T,u,n) be a complete lattice. A bin\u00adary \nrelation 6 on L is a eompzete .join-congruence rezation if and only if : (11 -e is an equivalence relation \n[21 -o satisfies the join-substitut~on property : dx,y,ueL, X~y[8) ~ XUU = yUU(6) [3) -o satisfies the \n~oin-completeness property : WxeL, x= U[xlf3 (8) where [xIO={YCL :x~y[el] is the congruence class containing \nx. THEOREM 6.3.0.2 If p is an upper closure operator on L(~,l,T, J,n) and 14x,ycL, xsy(p) if and only \nif p(x)=p[y] then : (11 -(P) is a complete join-congruence relation on L (21-P = Ax. u([xl(pll Reciprocally \na complete join-congruence rela\u00adtion on A defines an upper closure operator on A whence a space of approximate \nassertions : THEOREM 6.3.0.3 Let 8 be a complete join-congruence relation on the complete lattice LIE,l,T,U,n). \nAx. U[[XIO) is an upper closure operator on L. (Similar results were already proved in Cousot &#38; Cousot[77b] \nexcept that the above definition of complete join-congruence relations has baen substan tially simplified]. \nThe following result can somatimes facilitate the proof tha c a given relation is a join-congruence \nrelation (satisfying 6.3.0.1. [11 and 6.3.0.1. [2)]. It can be compared with Gr%zer&#38; Schmidt[581 \ns theorem which is relative to congruence relations. THEOREM 6.3.0.4 4A reflexive and symmetric binary \nrelation 6 on a complete lattice Lf5,1,T,U,n) is a join-congruence relation iff the following three properties \nare sat\u00adisfied for x,y,z,t~L : [11 -{x:y(6)}~{3ueL : (x~Jy)GuA U=X(6) A U=y(6)] (21- {x5y5zA X=y(6) A \ny=Z(6)}+ {X=2(8)} (3)- {X~yA X=y(o)]+ {(Xht):(yht) (8)] E&#38;arnpZe 6.3.0.5 Let V be a non-empty eet \nof integers included between two bounds -m and +~ (either V=.zU{-m,+~} and ~iez, -ca<-~<i<+~<+~ or {-co,+co} \n52 and V ={iez : -~<i<+~]l. The binary relation e defined on A = . [~+~) by : {P= Q(6)} = {tim{xCV :p(X)}= \nti~{X~V:Q(Xj ] A {rnac{x=U : P[xl} =max{xcV : Q(x)]} (where min(@l =+~ and rnax[@) =-m) is a complete \njoin congruence relation. The quotient lattice L/@ is isomorphic to P(A) where p is the upper closure \noperator induced by o : p = lP.v[[Ple) XPEA.[lxeV.[min{y : p(y)}~x~mady :P(YIIII In conjunction with \n6.2.0.2, P can be used for sta\u00ad tic analysis of the ranges of values of numerical variables [Cousot &#38;CousotE77al). \nEnd of Exar?pZe. 6.4. Definition of a Space of Approximate Assertions by Means of a Family of Principal \nIdeals The equivalence classes of the complete join\u00adcongruence relation [PI induced by a closure opera\u00adtor \np have the followin~ property : THEOREM 6.4.0.1 fit e be a complete join-congruence relation on the \ncomplete lattice L(E,l,T,U,n), then WxcL, [xIO is a complete and convex sub-join-semilattice of L. [Let \nus recall that SSL is eo~oe~ iff a.bcS, c=L land a= c=b imply that CCSI - Here is another representation \nof convex sub\u00adjoin-semilattices of L (which can be compared with Gr3tzer[71] s representation of convex \nsublattices) An ideaZ is a nonvoid subset J of a lattice L(E,l,LI) with the properties (al {{aeJ,xeL,x \nEa} > {xcJ}] and (b) {{acJ,beJ} *{a UbcJ}]. It is easy to show that J is an ideal when (aUb)=J holds \nif and only if aeJ and beJ (Caste property). Since L has an inf.i.mum 1, the intersection of an infinite \nfamily of ideals in a lattice L is an ideal of L. Given an element a in a lattice L, the set {XCL :xGa} \nis evidently an ideal: it is Called a p? tneipal ideaz of L. If every ascending chain in L is finite, \nevery ideal is principal. A semi-ideaZ is a nonvoid subset I of L with the propgrty {{acI, xcL.x Ea]=>{xeI}]. \nThe dual notion is the one of duaZ semi-ideal. THEOREM 6.4.0.2 (11 -Let 1 be a principal ideal and J \nbe a dual semi\u00adideal of a complete lattice L(~,l,T,l..l,ll). If InJ is nonvoid then InJ i.s a complete \nand convax sub-join-semilattice of L. [2] -Every complete and convex sub-join-semilattice C of L can \nbe expressed in this form with I={xeL:xE (UC)} and {XCL:{lYeC :Y5X}}SJo THEOREM 6.4.0.3 Let {IieA} be \na family of principal ideals of the complete lattice L(E,l,T,U,nl containing L. Then Ax.U{nIi : i~A A \nxeIi} is an upper closure operator on L. Exwnp U 6.4.0,4 The following lattice can be used for static \nanalysis of the signs of values of numerical varia\u00adbles : T : $ Zo + 0 @ 1 . (where 1. -~ +, -, Zo, \n$, T r~spectively stand for Ax.faZse, Ax.x<O, AXOX>O, Ax.xsO, Ax.xzo, XX.X20, Ax.true]. A further approximation \ncan be defined by the following family of principal ideals : 11 12 which induces an upper closure operator \nP: n LJ and the space ample 5.2.0.5) of approximate assertions rused in ex\u00ad ;\\ 7. DESIGN OF THE APPROXIMATEPREDICATE \nTRANSFORMER INDUCED BY A SPACEOF APPROXIMATEASSERTIONS In addition to A and Y the specification of a \nprogram analysis framework also includes the choica of an approximate predicate transformer t~(~+ (A+A)) \n[or a monoid of maps on A plus a rule for associa\u00ad .\u00adting maps to program statements [e.g. RosenL78Jl). \nWe now show that in fact this is not indispensable since there exists a best correct choice of T which \nis induced by ~ and the formal semantics of the con\u00adsidered programming language. 7.1 A Reasonable Definition \nof Correct Approximate Predicate Transformers At paragraph 3, given (~,A,T] the minimal asser\u00adtion which \nis invariant at point i of a program T with entry specification @ was defined as : P= v T(p)($) i pcpaz%[il \nTherefore the minimal approximate invariant asser ci.on is the least upper approximation of Pi in F that \nis : P(F il = P( v T(p) [o)) pcPath(i] Even when path~i) is a finite set of finite paths the evaluation \nof r(p)(~) is hardly machine-implementable since for each path p=al, . . ..am the computation se\u00adquence \nXO =$, Xl =TIC(al))(Xo], . . . . xm=~(c(a~~l(xm-l) does not necessarily only involve elements of A and \n(~+~) . Therefore using ~c~ and t&#38;(L_+(~+~)) a machine representable sequence 70=$, xl=~(c[all)(~ol, \n. . . . Tm=7[C(am]][~m_lJ is used instead of XO, . . ..XM which leads to the expression : Tha choice \nof ~ and ~ is correct if_and only if Qi is an upper approximation of Pi in A that is if and only if : \n(v ;(p)($)) -p( v ~(p)(~)) p=path(i) pcpatk[i) In_pa~ticular for the entry point we must have $ > P(~)=$ \nso that we can state the following : DEFINITION 7.1,0.1 (1) -An appr~xi~ate predicate transformer tc[L+(A+Al) \nis said to be a eorrget upper approximation of TC(L+(A+A)I inl=p(A) if and only if for all 4wA, ~c~ such \nthat $~~ and program m we have : MOPT(T,@l ~MOPm(t,~) [2) -similarly if AD<a,Y>A, t~(L+(A+A)) is said \nto be a correct upper approximation of Tc(L+(A+Al) in A=a(A) if and only~f V@, @: $*y(Tl, Vw, a(MOPm(T,$)) \nE MOPm(t,@]l, (i.e. MOPT(T,$) ~ Y(MOPT(t,$))) This global correctness condition for ~ is very difficult \nto check since for any program ~ and any program point i all pathe pepatk(il must be consi\u00ad dered. However \nit is possible to use instead the following equivalent local condition which can be checked for every \ntype of statements : End of ExonipZe. 276 THEOREM 7.1.0.2 [1) -Ze (L+(~+~ll is a c~rrect upper approxim@ion \nof ~= (L+(~+AII j.n A.p(AI iff {W3e~, VPCA, -C(SI (PI -t(sl [p)} [21 te (L+(A+AII is a correct upper \napproximation o+ TC (L+[A+A)) in A=u(A) (where AHCI,Y>AI fff {ifSe~, VPCA, a( r(S][Y[P))) 5 t(sl(Pl}. \n If ~c [L+(~+~II is ~ correct upper approxima\u00adtion of~c (1-+ (A+A)) in A=P(A) we have MOQTIT,$) ~ MOPT[t,p(@)) \nwhence p(MOPT(t,$) )-> MOPm(t,p($) ]. The cases when equality holds are not easy to distin\u00adguish. Yet \nthe following sufficient condition turns out to be ueeful afterwards : THEOREM 7.1.0.3 (1) -If ~ is a \ncorrect upper approxima~ion of T in p(A) and {VSe~, VPeA, p(T[S](p)]= t[S) [p(p)]} then vm, V$, p[MOPr(T,@)] \n=MOPT(~,P($)l  (2) -If t is a correct upper approximation of T in A where AD<GX,Y>A and {vscL., VPCA, \nCI(T(S) [P)) = t[Sl(a[Pl)} then Wr, V@, a(MOP~(T,@)) = MOPn(t,a(@ll  Similar results hold for fixpoint \nanalysis of programs : THEOREM 7.1.0.4 Let te[L+(A+A)l be an isotone correct upper approximation of \nTc(L~(A+A)), in_.A=~[A] where 4DQ,pA then W$CA, W$e A:$=>y($), VT, [ll-Fm(k,T) is isotone andao~n[T,$)OY~Fm(t,Tl \n(2) -a[lJ%(Fm(T,$l)) EZ@[Fm(t,$l) (31-If $=Y(~ and {VS=L, VPeA, CY,(T[ S](P)] = t(Sl(a(P)l} then equality \nholds in (2) Notice that in theorem 7.1.0.2 the maps {~(Sl : .. SCLJ are not assumed to be isotone. \nyet i~otony is assumed in theorem 7.1.0.4 and is a customary hypo\u00adthesis in the li cerature. An apparent \njustifica\u00adtion of this additional requirement gs to ensure that the system of equations X=Fm(t,@) [X) \nassocia\u00adted with a program IT has fixpoints which can be obtained as limits of iteration sequences. But \nthis could also be achiev~d without isotony hyp~\u00ad thesis taking AX.XUFT(t,$l (Xl instead of Fn(t,$) : \nTHEOREM 7.1.0.5 Let te(L+(A+A)) be a correct upper approx\u00adimation of TC[L+ (A+A)) in A=u[A) where ADQ,Y>A \nthen !4$cA,V3CA : ~=>y(~], VT, [l) -aOFm[T,@)OYE Fm(t,T) (2) -a(Z@(Fm(T,0)]) E Zuis[Xx.xU Fm(t,~l(x)l[ll \n(where ZU~S(F] [l) is the limit of the station\u00ad 6 ($-1 ary iteration sequence XO=l, X =F(X ) for successor \nordinals, X6 = ~~6XU for limit ordi\u00adnals) Hence the isotony hypothesis is even not nece\u00adssary for technical \npurposes. However the profound justification of this hypothesis can be found in the fact that among all \npossible approximate predicate transformers which can be used with a given set A of approximate assertions \nthe designer of a program ana\u00adlysis framework intuitively thinks co the best approximate predicate transformer \nwhich happens to be isotone. This property also explains the fact that no significant counter-examples \nto the isotony hypothesis have ever been found. 7.2 The Best Approximate Predicate Transformer Induced \nby a Space of Approximate Assertions DEFINITION 7.2.0.1 If ~1, F2 ar~ correct upper apprcxim@ions of \ntc(L+ [A+A)) in A=p(A] then we say that tl iS bette~ tlmn~z iff~or all &#38;~ and all programs n, rMOPn(tl,~l \n> MOPT(tz,~) LEMMA 7.2.0.2 Let ~1, ;2 be correct upper app~oximations of T~[L+_[A+A~) in fi.p(A). If \n(v~cL, tl[S)~72[S]~ r and [tl or tz is isotone) then tl is better than tz. (Notice that the above isotony \ncondition is suffi\u00adcient but not necessary). THEOREM 7.2.0.3 Let~~e kSeL&#38;[k~C~.[PIT(Sl (Pllll (1] \n-~scL, T~S)_E [A+A) is isotone (2) -t~(L+(A+A)) is a c~rrect upper appro~imation ~f T=[L+ [A+A)) in A=P[A) \niff {VSCL, T(S) => ~(sl} (3) -T is the best correct upper approximation of T in A COROLLARY 7.2.0.4 \nIf A%,,y>A(5,1,T,U,n] then kscL.[AP~A.[~(T(sI (Y(P)) 11 is isotone, it is the rbest correct upper approximation \nof T in A. The most interesting consequence is that we have in hand a formal specification of the programs \nwhich have to be written in order to implement any specific program analysis framework once A and y have \nbeen chosen. As a challenge to automatic pro\u00adgram synthesizers let us consider a simple ExampZe 7.2.0.5 \nComing back to examples 6.2.0.2 and 6.3.0.5 assume that V is the set of integers included bet\u00adween two \nbounds -m and +CCand V.Omo For simplicity we shall assume that m=2. Let L be the complete lattice {l]U{[a,b] \nia,bc~ A a~b] with ordering [a,b] 5 [c,dl iff asb~c<d and 1 is the infimum . Let y e (L+(~+~)) be such \nthat yg(ll=Ax.&#38;Lse, y [[a,b])= Ax. (a~x~b). Let Abe ~DLwhere LDM= {xny : xcL A yeM} and XUY = zf \nx=1 or y.L then C.L,L> else <X,y> fi. Let yc(A+A).where A=[02-+B] be A<x,y>. [Y [xl Ay (y]). Given A \nand Y let us determine the best corract upper approximation of Sp in A. Again for lack of space we just \nstudy the case of sp(A<x,y>. [xsy]]. Since y is an injective complete meet-morphism the adjoined function \nu E[(O-+B]+L) is determined 1 .~p-if p=Ax.faZse then 1 Qlse by 5.3.0.5. [3.1) : a [m-bz{x : P(x)],macdx \n:PIx)]I f;. The same way, a. e (A+L13L) is XP.(a (Ux(P) )lla [CSy(Plll where LSx = AP.[XX.[3YCQ :P[X,Y)II \nand CJY=XP.[XY.[]XEQ :P(X,Y)]I According to theorem 7.2,0.4 the best upper ap\u00ad proximation of sp(A<x,y>m(x<y)) \nin A is t. W sp[a<x,y>. [xsy))oys If P@A equals <1,1> then t(P)= <1,1> else p.<[a,b],[~,d]> where a<b \nand ~<d in which case t[P)=a[Q) where Q=a<x,y>.(a<x<b A c~y<d A X<y)O IJx(Q)=kx. (3y : a<x<b A c<y<d \nA x<y).~x. [a<x<b A mczx[c,x]sdl =Ax. (a<x~b A xsd) since csd. The same way Oy(Q)=ky. (r??czZ[c,a)Sy<d] \n. Therefore t(P) =~~ a>d then <1,1> ezse <[a,m-ln[b,d)],[max(c,a),d]> j%=<[a,b]fl [-m,d],[c,d] fl[a,+~]> \nproving that this choice in Coueot ECousot[77al was optimal. End of Exanp le. .ExampZe 7.2,0.6 Some \nprogram analyses (such as reaching defi\u00ad nitions , available expressions , live variables!?, . . . Aho \n&#38;Ullman[77]) are history sensitive because the approximate assertions which are useful at each program \npoint p characterize sets of sequences of states [or execution paths from the entry point to p) and not \nsets of states. In such a case Hoare[781 s formal definition of languages using sets of sequen\u00ad tial \ntraces is more convenient that the deductive semantics of paragraph 3. 7.2.0.6.1. Associating a Set \nof Traces with a Program Given a universe ~ of values, a set La of ele\u00admentary assignments, a set L.t \nof elementary tests, the set of s@quentiaZ traces is the free monoid T[;,o] generated by L= LaULt. The \nconcatenation operation . is extended to elements of the complete lattice zT(G,@,T,u,nl by S;T={s;t:ses \nA tcT]. Let us define a forward set of tracestransfor\u00admer fte (L+[zT+2T)) as As.EIT.[TJ{s]II. The set \nof traces associated with a program 7T and an entry specification $cASLt is MOPn(ft,{$}l. 7.2.0,6.2. \nApproximating a Set of Traces by an Assertfon Characterizing the Descendwts of the Entq States The connection \nwith the deductive semantics of paragraph 3 is made using aE(2?_+A) such that for any set T of traces, \nu(T) characterizes the poseible descendants of the entry states (belonging to ~] when the traces teT \nare executed. From an [obvious hence not given here) operational semantics of se\u00adquential traces we derive \nthat u=AT.[v{~~(t) :teT}] where a E(T+A) is euch that u~(<>).lxcV.tr~e and b!3eL, vteT, a (t;s]=sp(s] \n(a~[t)), Since a is a complete join-morphism from 2T onto A, thaorem 5.3.0.5.(3.21 defines an adjoined \nfunction y.5[A+2T). According to theorem 7.2.0.4 the best correct upper approximation of f% in A is R=As=L.CXP=A. \n[a(ft(sl [y(Plllll. VSeL, wIPcd, we have R(Sl (P)= a[ft(s) (y(Pl)l=a[y(P1. {sl l=cx[{t.s v{a~(t;s) : \nt.y,P,, :V{SP,S,(JIJ::Y1!+:;;,. Since VSCL, sp(S) is a complete v-morphism, W(S)(P)= sp[s](v{a~ (t] : \ntcy(P)}) =sp[sl(a(y[Pl)l =sp(sl[Pl [theorem 5.3.0.5.(1)). Hence the best correct upper approximation \nof j% in Ais Spm Since ?4s~L, ft(Sl and sp(S) are complete join\u00ad morphisms, b T~T, a(ft(S](Tll =sp(S)(a(Tl] \nand bt$cA sLt, o,[,{~}l =$ theorems 9.1.0.1 and 7.1.0.3.(2) im\u00adply that for all programs 7T, a[Zfp[Fm(fp,{$]))] \n= Cl(MOPT(fp,{+})) = MOPT(SP,I$) = ZfPIFm(sp,@l). 7.2.0.6.3. Justifying the Data Flow Equations of llAvai~ble \nE~r@SS~OnSr Let E be the set of expressions. The set avaiz(t] of expressions which are available at \nexit of a path teT is defined by avaiZ[<>)=@ and VSCL, czOaiZ(t;Sl = (avail[t) ntrans[S)) Ugen(S] where \ntrans(S) is the set of expressions in ~ not killed by the command S while gen(S] is the set of expre\u00adssions \ngenerated by S. An expression is available at some program p~int q if it is available at exit of every \npath from the entry point ni to q. Therefore the set of expressions available at q ie Cl(MOPm(fP,f.lX.tP2@})q) \nwhere ae(2T+2E] is AT.n{avaiZ[t] :tcT}. Since u is a complete join-morphism from 2T[~,@,T,u,n) onto zE(~,E,@,n,u), \ntheorem 5.3.o.5. (3.2] defines an adjoined function y. According to theorem 7.2.Q.4 the best correct \nupper approximation of ft in 2k is at = AScL.ElEe2E.[a[ft(s] [y[E)]l ]]=k.[kE.[(E ntm-zs(sl) ugen[S]ll. \nSince dT=l_, U(ft[S) [T)) =at(S)[a(Tl) and ct({xX.trwe]l =@ and VSeL, at(Sl is a complete join-morphiem \non 2E[2,E,@,rl,U), theorems 9.1.0.1 and 7.1.0.3.(21 imply a(MOPm[@,{kX.trwe})) = MOPm(at,@] =Zfp(Fm(at,@)]. \nNotice that Fm(at,@] (as defined at paragraph 2 taking L[5,1,T,U,nl to be zE(z,E,@,n,u]] is the classical \nsystem of data flow equations for available expressions (Aho&#38; Ullman[77]) and that the largest possible \nsolution (least for ?1 is desired. End of ExqZe. 8. HIERARCHY OF PROGRAM ANALYSIS FRAMEWORKS Once the \nsemantics of programs has been defined by (A,T) all program analysis frameworks [A,t,y) are specified \nup to the isomorphism Y by (P(AI, kS.[pOT(S)]l where p=y.a is an upper closure operator on A and AMO,,Y>A. \nProgram analysis frameworks can be partially ordered using the order\u00ading of the corresponding closure \noperators on A since whenever PI E P2, P2(A] ZPIIAI so that program analysis frameworks corresponding \nto PI yield sharp\u00ader information than the ones corresponding to P2 (whichever global program analysis \nmethod is used]. The following theorem is a constructive version of Ward[42,Th.5.3] : THEOREM 5.0.1 The \neet of upper closure operators on a com\u00adplete lattice L(E,l,T,U,n) is a complete la ctice eZOIL+Ll [E,Xx.x,Ax.T,AS.ide \n[US],n). ExampZe 8.0.2 In order to briefly illustrate the hierarchy of program analysis frameworks, let \nus consider three comparable examples the approximation func\u00ad tion of which can be sketched using a geometrical \nanalogy. Let P be a predicate over two numerical variables x and y the characteristic eet of which is \nthe following : Y + P[x,y) +.+ + + + o L x The upper closure operator of example 5.2.0.5 defines a very \nrough approximation consisting in ap\u00adproximating this set by the quarter of plane contain\u00ading all its \npoint!s : A more precise approximation (example 6.3.0.5] consists in approximating the characteristic \nset of P by the emallest rectangle including it and whose sides run parallel with the axee : P(P) [X,Y) \ny y/,, / ]@ o~ x A refinement consists in approximating the char\u00adacteristic set of P by its convex-hull \n:   Y pa PIPI(X,Y) /+flp //+ o~x The corresponding framework was used for the automa\u00ad tic discovery \nof linear restraints among variables of programs [Cousot &#38;Halbwachs [78]). End of Example. 90 MERGEOVERALL \nPATHS VERSUSLEAST FIXPOINT GLOBAL ANALYSIS OF PROGRAMS 9.1 Distributive Program Analysis Frameworks We \nrecalled at paragraph 4 that once a program analysis framework [A,t,y) has been designed, the program-wide \nanalysis problem has various solutions including the merge over all paths and least fix\u00adpoint solutions. \nIt is known [Kam EUllman[77]l that when A satisfies the ascending chain condition and WSCL, t(S) is isotone \nwe have MOPm[t,$) E Z~p[Fm[t,@]]. Also the additional hypothesis that V!%L, t[Sl is a join-morphism (sometimes \ncalled join-distributive map) implies MOPm(t,@) = Zfp(Fn(t,$)]. Slightly more general is the fol\u00ad lowing \n: THEOREM 9.1.0.1 If AIG,l,T,U,N) is a complete lattice and tc(L+[A+All ie such that WSe/-, t(S) is \nisotone then for all programs IT and &#38;A, MOPm(k,$) E Z@[Fm[t,@ll. If moreover tfSeL, t[S] is a complete \nrU-morphism then MOPT(t,$) =Z~p(Fm(t,$)]. (This theorem is implicitly used at paragraph 3 taking A= \n(~+B)(=>,lX.faZse,XX.tTwe,v,A) for A(S,l, T,u,n] and either sp or Z@ for t). If AD<a,Y>A and cc[L+ (A+A]] \nthen the above theorem establishes the correctness of Zfp[Fn[t,$)] with respect to NOPT(t,@). In the \nliterature the correctness of MOPm[t,$l is generally taken for gran\u00ad ted. Also MOPn(t,$) is considered \nae the desired solution to program-wida analysis problems since whenever some t(S] is not a complete \njoin-morphism PIOPn(t,$) can be strictly better than Z~p[Fn(t,@l]. When A satisfies the ascending chain \ncondition Z~(Fm(t,@ll is computable, which is not necessarily the case of MOPm(t,@). In that case a variety \nof methods can be used [e.g. Rosen[78]) which can find sharper information that fixpoint methods and \nthere\u00ad fore approach the ideal merge over all paths solution which provides the maximum information relevant \nto A, tandY. In our opinion the above argument is not entire\u00adly convincing since for different correct \napproximate predicate transformers tl, t2~[L+(A+A)) ;;g:~e~e the case that Z@[FT[tl,$l lEMOPm(t2,@l. \nto relieve from the burden of badly chosen approx\u00adimate predicate transformers the argument must con\u00adsider \nthe best approximate predicate transformer relevant to A (theoram 7.2.0.4). Then the following result \nis a useful complement to theorem 9.1.0.1 : THEOREM 9.1.0.2 Let ~e(L-+(~+~)1 be the best_correct uPP@r \napproximation of Te(L+[A+All in A=P[A~. If P(AI is a complete eubla ctice of A then MOpT[~.@) = Z~~[F=(~,$)). \nExampZe 9. 1.O.3 If A= (Z+B) and ~=Y(Al where : . T 1 and y[ll=Au.@Zse, Y(-l=ku. [u<Ol, Y(OI=AU. (U=OI, \netc. then~is not a sublattice of A since Y(-)vY(+]~y(A). The merge over all paths analysis of the program \n: {f x>O then tih;Ze x#O do x :=-x; od; fi; [which is powerful enough in order to determine that the \nwhile-loop does not terminate) is strictly better than the least fixpoint analyeis (which fails to die\u00ad \ncover that 1 is invariant on the exit path of the loop] . End of Examp Le. 9.2 Non-Distributive Program \nAnalysis Frameworks The marge over all paths analysis of a program using some non-distributive program \nanalysis frame\u00adwork can always be defined by means of the least fixpoint of a system of isotone equations \nassociated with that program : THEOREM 9.2.0.1 Let AIG,l,T,u,n) be a complete la ctice, te(L+(A+A)) \nbe an approximate predicate trans\u00ad former, 2A[s,@,A,u,nl be the complete lat cice of all subsets of A. \nTC(L+(2A+2A)) be k3.[lP.{t(Sl (x):xeP}] apd U.C(2A+A) be AP.[ UP]. \\ V. cL, T(S) ie a complete u-morphism \n:< Wr\\ d@EA, p[ZfP(Fm(T,{$}))) = MOPm(t,$) \\ The above construction is not fully satisfac\u00adtory since \n~~A,T) is not isomorphic to [A,t] whan t is a complete\\\\Join-morphism, so that the choica of (2A,T) in \nordeh,to define FIOPT[t,$) as a least \\ OF PROGRAM fixpoint is unnecessarily too complicated. The fol-10. \nCOMBINATIONANALYSIS FRAMEWORKS lowing construction is preferable : LEMMA 9.2.0.2 Let LIE,l,T,U,n) be \na complete lattice and~, ~~[2L+2L) be defined as : ii= lli.~fii=$ then ~,else {lJs : se(2H -@)} fi ~= \nAH.zf H=@ theno eZse {~s : SG(2H -011 f; V and ~ are upper closure operators on ZL. Let 0C(ZL+2L) be \nthe join ZU-tSIEUUI of ~ and ~ in the lattice of upper closure operat~rs on zL, (theorems 6.0.1 and 6.1.0.1). \nVHc(2L -@), fJ(H] is r the least complete sublattice of L containing H. LEMMA 9.2.0.3 r Let P be an \nupper closure operator on L[Z,L,T, u,n). Then lI=kx.~{yea(p[L]) : x~y] is the great\u00adest closure operator \non L which is less than or equal to p and which is a complete join-morphism. THEOREM 9.2.0.4 (1) -Let \nP be_an_upper closure operator on A, tlc(L+ (A+A)] be a correct upper approximation of TC(L+[A+AII in~=p(A). \nLet rIe(A+A) be lPeA{QCO(p(A) ?:P~Q} and tze(L+[n(A)+n[A))] be AS.[~OTIS]]. Then liT, @eX, p(Z~P(Fm(t2,$)ll \n+ MOPm(tl,$l Moreover p(Z~p(FT[t2,$)ll = MOPm[tl,$l whenever one of the following three conditions holds \n: (2)-p ie a complete join morphism and tl=k3.[po~(S)] (3)-W%L, vPe~, p(T(s)(Pll=t (s) (P(P)) (4) -o(P(A))=u(P(AI) \nand tl= i s.[poT(s)]_is the best correct upper approximation of T in A=P(AI. ExwnpZe 9,2.0.5 Coming back \nto example 9.1.0.3 where A= (Z+131 and p(A) ={lu.~aZse,Au. (u=O),lu. (u<O),XU.(U<O), Au. [u>Ol,Au. (u201,Xu.~rue} \nand applying theorem 9.2.0.4 we get T)(A) =P[A] u{Au. (u*OI} so that accor\u00ad ding to 9.2.0.4. [3), W, \nt@ep[A), P(Zfp[Fm(lS. (rIOT(S)l,@))) = MOPT[~S. (POT(S)),$). End of Exwnp le. It is clear that when \nP(AI satisfies the ascen\u00adding chain condition, the construction of theorem  9.2.0.4 may lead to a refined \nspace of approximate assertions n(A) which does not satisfy the ascending chain condition. Then the iterative \ncomputation of-Zfp(Fn(kS.[TloTIS)],$)) may not be naturally conver\u00adging in a finite number of steps. \nNevertheless this least fixpoint can be approximated from above using an extrapolation technique in order \nto accelerate the convergence of the iterates. Such a technique was developed i.n Cousot 8Cousot[77al \nusing a wide\u00adning operator vc(rI(A)xvIA) +rIIA)). In our case a possible choice of V is k<P,Q>.[p(Pv \nQ)l. Thie choice will guarantee that the refined fixpoint anal\u00adysis (based on 11 and VI will be more \nprecise than the original one (based on p) (but other application dependent definitions of V might even \nbe more effi\u00adcient) . The ideal method in order to construct a pro\u00adgram analyser (to be integrated in \noptimizing com\u00adpilers or program verification systems) would consist in a separate design and implementation \nof various complementary program analysis frameworks which could then be systematically combined using \na once for all implemented assembler. In thie section, we show that such an automatic combination of \nindependently desi\u00adgned parts would not lead to an optimal analyser and that unfortunately the efficient \ncombination of pro\u00adgram analysis frameworks often necessitates the revi\u00adsion of the original design phase. \n10.1 Reduced Cardinal Product of Program Analysis Frameworks THEOREM 10.1.0.1 Let (Al,tI,yl), (A2,t2,y2) \nbe two program analy\u00adsis frameworks such that Alp<,yl>A, A2P<,Y2>A and tl, tz are correct upper approximatione \nof T in Al, 42,. The direct product (A,t,y) of (Al,tl,Yl) and [A2,tz,Y.2) is defined as A=AIXA2, t=tlxt2=lS.[k<Pl,p2>. \n[<tl(S) (Pl),t2[S)(P2)>]], Y=1~P~,P2>. [y~(PI)AY2(P2)]. [ l] -b TT, W$lCA1, W$2CA2, MOPn(t,<@l,$z>) = \n, <MOPm(tl,$l] ,MOPm(t2,@z)> (2) -If moreover tl and cZ are isotone, then Lfp[Fr[tlxtz,f$l,$z>l) = <Z@(Pm[tl,@l)),Z~p[Fm(tz,$z) \n) This definition of direct product is not satis\u00adfactory since y is not necessarily injective and t \nis not necessarily optimal. Hence given a global program analysis algorithm we can get sharper infor\u00adma \ncion than the one obtained by the separate analyses just by revising the definition of A and t as stated \nin theorems 5.3.0.7 and 7.2.0.4 : THEOREM 10.1.0.2 -Let [Al,tl,yl) and (A2,t2.,y2) be two program anal\u00adysis \nframeworks such that AI D<aI,Y1>A, A2DQ2,y2>A, tl =AS. (alOT(S)Oyl] and t2 = lS. [a20T[S10y21 are respectively \nthe best upper aPProximation of T in A. Let CT=([AIXA2 )+[AIXA21) be defin~d as l<P1.Pz>.n{<Ql,Qz> :Y1(PII \nAYZ(PZ1 = y*[oll Ay2[Q21}. The redueedprodwt (A1,tl,yll* [A2,t7,yzl is (A,t,y) where A= 0[AIXA2) (S,l,CJ(T),U,AS. \n( U( (7S1)), t= kS.[aOTIS]Oy], Y= 1<PI,P2>. (YI(P1) Ay2[p211, a= aP. (o[<aI(Pl,a2[P)>l 1 Awa,Y>A, kK3eL, \n[ci.T(S).y) =u[(tlxt2] (S)) and this inequality can be strict. Since YOCt=YIOaI Ayzoaz, CT(A1 XA2) is \na repre\u00adsentation of the space o; a~proximate assertions corresponding to the meet of the closure operators \nYIO~l and Y20a2 (theorem 8.0.1) viz. to the join {nP:P s yl(AI] UY.2(A2)} of the Moore families yl(A1) \nand Y2[A21. Exarnp le 10.1.0.3 Remcmk 10.I.o.4 Let L][El], Lz[=z) be posets. The cardinal sum TT of L1 \nand L2 is the set of all elements in LI or Lz, considered as disjoint. When LI(~I,lI,TI,mI,UI) and L2[Ez,12,T2,h2,n2] \nare complete la ttices we can de\u00adfine the disjoint sum L1+L2 as LI uL2u{L,T} with L ordering x~y iff \n(x=1) or (y=T] or (x,yeLl,and x51Y)1 or (X,YCLZ and xE2y). The meaning of elements of 1 L1+L2 can be \ndefined as Y(l]=Y1(ll] AY2(12], Y(x]= Y1[x) if x~LI, Y[X)=Y3.(X) if x~L2, Y(T)=Ax.~~~e. Even Yl(ll=ax,fazse, \nyI[ol=XX. (X=o), YI(!I=AX. (X20), yl[~)= when yl and y2 are one-to-one complete meet-morphisms, ixo(x~Ol, \nYl(T)=ax.tme, y2[l)=Ax.faZse, y2(ev]= y may be neither one-to-one nor a complete meet\u00adkx.(x~dhb 2 = O), \ny2(od)=Ax. [xmociuZo 2 = 1), morphism. In order to satisfy assumption 5.1.0.2 the y2(T]=kX.t~tle, b x~Al, \nb ycA3,, a(<x,l>)=~(<~,y>]= set YIL1+Lz) must be completed using theorem 5.2.0.4. U[<O,od>)=<l,l>. U[<O,ev>).U[<O,T>]=<O, \nev> otherwise Then it turns out that the least Moore family contain\u00adG(<x,y>)=<x,y>. The product is : \ning Y[L1+L21 is equal to y! [L1*L21 [y! as defined in <T, T> theorem 10.1.0.2]. Therefore the use of \ndisjoint sums amounts to the use of reduced products. End of Rema~k. 10.2 Reduced Cardinal Power of Program \nAnalysis Frameworks <$, The cardinal power L\\l with base L2[E2,12,T2, Llz,il.),and exponent L1(51,11,TI,UI,!%) \n(hereafter noted 2SO(Ll+ Lz)[5,1,T,U,nl ] is the set of all iso\u00adtone maps from L1 to Lz with f~g if and \nonly if f(x) EZg(xl for all x in L1. Two program analysie <1,1> frameworks [Al,tl,yl] and (Az,tz,yzl \ncan be combined The following program (Manna[74 ,p.179] computes by letting geZ.S0(Ll+L21 mean that for \nall x in Al, YS X:2 (with the convention 0\u00b0 =11 for every integer yz(g(x)) holds whenever yl(x] holde. \nXI and natural number X2 : THEOREM 10.2.0.1 <y18y2,y3> := <X1,X2,1>: {1}  {2] Unt<zy2=o do The reduced \ncardinaZ power with base [Az,tz,Yzl z~ odd(yz] then and exponent (Al,tl,yl) is (A,t,y) where {3} <yz,y3> \n:Z<Y,2- l,~l*Y3>; A= O(ZSO(A1+A2)), OG[iso(AI-*A2) +iso(AI+A2)] is {4} else Ag.n{feiso[Al-+Azl : Y(f)=y(g)}, \nYc(iso[Al+A2)+A) {51 is ~g,[~X,A{y~ [v] (X]~y2(g[v]) (Xl :VCAI}],~Y19Y2~ := <yl*y1,y2div z>;{6} t=k. \n[UOT(S)OY) and w(A+~so(A1+A211 is {71 fi; kP.[O(aV.[a2(P AYI(v111)1. Ab<~,Y>A and VSe~, t(S) ~lg.[Av.U,2{tz(S) \n(g(z]) : ZCA1 A tl(Sl[zl ~v]l [with Lh2@ 12). The fixpoint analysis with entry condition ~81 od; ~(yl,y2,y3,xl,x2) \n.(x2~O] USing Al leads to the fOl\u00adlowing result for the variable yz : Example 10.2.0.2 Tz The fixpoint \nanalysie using AZ leads to the follo\u00adwing result for the variable y2 : I {1} {2} {3} {41 {5} {6} {7} \n{8} y2T Tod ev ev T Tev 1.2 According to theorem 10,1.0.1 the direct product of the above analyses cannot \nyield sharper information. Yl(lll=Y2(121 =A(b,xl.@tse, yl(Tl)=Yz[Tz)=A(b,x].tme, On the other hand using \nthe reduced direct product yl(tl=a(b,xl. (bl, yl(f)=l(b,x) .(-b), Y2(-1= [A-{<1,1>])5 U{<<l,l> ,,..,<1,1>>} \nand the correspond-A(b,x). (x<O), etc. ing optimal approximate predicate transformer (which takes account \nof the rule <$,od>-1 = <$,ev>) we get : The analysis of the program : {1} {2} {3} {4} {5} {6} {7} {8} \nx :=100; b :=t.vue; {1} y2 <?,T> <;,T> <$,od> <Z,ev> <$,= > <.t,T> <;,T> <O,QV> ~21 tih~te b &#38; x \n:=x-l; {31 b := [x>O);End of Exomp le. {4}~5j od: using the reduced cardinal product of Al and A2 Gr%tzer \nG. &#38; Schmidt E.T. [1958], IdeaZs and congru\u00ad yields no information since no relationship can be ence \n~elat{ons <n ~attiees, Acts Math. Acad. discovered between b and x. Sci. Hungar., 9(1958), 137-175. Following \ntheorem 10.2.0.1 we determine that if gc(Al+Azl then Y[gl=(Yl (i5)AYz [g(t))v(Yl[~)AYz (g(~)]. Therefore \nO[gl=h where h(lll=lz, h(t)=g(t), h(~)= g(~], h(Tl)=g[t)Uzg(f ). It follows that cs[iscJ(A1+A211 is isomorphic \nto ({t,~}-+A2) (or A2xA2). The syetem of equatione aeeociatad with the above program and the entry specification \nkb.T2 is then : gl = ~b.~~ b=t then + else 12 f$ gz = ab.z~ b=t then gl[t)Llzgk(tl e2se 12 fi g3 = Ab.decr(g2[b)l \ng4 = ~b.~~ b=t then [g3[t)n2+l L12 (g3wn2+) ekif b=~ then (g3(t)Hz1]U2(g3(f]~z~) fi gs = ab.i~ b=fthen \ngl(f)&#38;g4[f) Q2SQ 12 j% where~deer(lz)=lz, deer(Ol=deer[-)=decr(ll=-, deer[+)=$, de@[*O)=deer($)=deer(T2] \n=T2. The iterative resolution of this eystem of equa\u00adtions starting from the infimum kb.lz yields y(gl)= \nY[gz)=x(b,x) .(b Ax>Ol, Y[g3)=X[b,xl .(b Ax~Ol, Y(g4)= k(b,x). [[b Ax>O]v(-b Ax=O]) , y[gsl=k(b,x] .[-b \nAx=O). End of Example. 11. REFERENCES Aho A.V. &#38; IJllrnan J.D. [1977], Pz+ineiptes ofeompiZer design, \nAddison Wesley Pub. Co., (1977). Birkhoff G. [1967], Lattice theory, AMS Colloquium Pub, , XXV, Third \ncd., Providence, R.I., (1967]. Coueot P. [19771, Asyneh~onous iterative methods for soZving a fixed po{nt \nsystem of motone equations in a eorrpzete Zatt<ce, Rapport de Recherche n 88, Laboratoire IMAG, Grenoble, \n[Sept. 1977). Coueot P. &#38; Cousot R. [1977aI, Abstract _interpreta\u00adt<on:a unified Zattice model for \nstatic analy\u00ads<s of programs by construction or approxima\u00adtion of fizpo~nts, Conf. Rec. of the 4th ACM \nSymp. on Principles of Programming Languages, Los Angeles, Calif., [Jan. 19771, 238-252. Cousot P. &#38; \nCouaot R. [1977b], static detefinat~on of dynomric p~opert{es of reeurw{ve procedures, IFIP WG.2.2 Working \nConf. on Formal Description of Programming Concepts, St-Andrews, Canada, North-Holland Pub. Co., (Aug. \n1977). Coueot P. &#38; Halbwachs N. [19781, Automatic discovery of Zinecw restraints among variabZes \nof a pro\u00adgram, Conf. Rec. of the 5th ACM Symp. on Prin\u00adciples of Programming Languages, Tucson, Ariz., \n(Jan. 19761, 84-97, Dijketra E.W. [1976], A disdpZine ofprogrdng, Prentice Hall, Englewood Cliffs, N.J., \n[1976). Floyd R.W. [1967], Assigning mean{ng to programs, Proc. Symp. in Applied Math., VO1.19, AMS, \nProvidence, R.I., [1967), 19-32. Graham S.L. &#38; Wegman M. [1976], A fast and usuaZZy ~inear algor-ithm \nfor gZ,obal flm analysis, JACM 23, 1(19761, 172-202. GrGtzer G. [19711, Lattice tfieo~, fi~st eoneepts \nand distributive lattices, W.H. Freeman and Co., San Francisco, Calif., [1971). Hoare C.A.R. [~9691, \nAn axiomat<c qpproach to com\u00adputer programming, CACM 12, 10(Oct. 1969), 576\u00ad560,583. Hoare C.A.R. [1978], \nSome p~operties of predicate transformers, JACM 25, 3(July 19781. 461-480. Jones N.D. &#38; Muchnick \nS.S. [1976], I%&#38;ng t;me opt{tizat{on in programming Zanguages : some thoughts toward the design of \nan {deal Zanguage, Conf. Rec. of the 3rd ACM Symp. on Principles of Programming Languages, Atlanta, GA., \n(Jan. 19761, 77-91. Kaplan M.A. &#38; IJllman J.D. [1978], A generaz scheme for the automatic inference \nofvatiabZe types, Conf. Rec. of the 5th ACM Symp. on Principles of Programming Languagas, Tucson, Ariz., \n(Jan. 19781, 60-75. Kam J.B. &#38; Unman J,D. [1977], Monotone data fzoti ana2ysis frameworks, Acts Informatica, \n7[19771, 305-317. Kildall G.A. [19731, A unified approach to gZobaZ program optimization, Conf. Rec. \nof tha ACM Symp. on Principles of Programming Languages, Boston, Mass., (Oct. 1973), 194-206. Manna \n2. [1974], MathematieaZ theory of computation, Mc-Graw Hill Book Co., (1974). Monteiro A. &#38; Ribeiro \nH. [1942], LropEration de fer\u00admeture et ses <nvatiants duns Zes syst~mes par\u00adtieZ2ement ordonne%, Portugal. \nMath. 3, 171-184. Ore O. [1943], Combination of eZosure reZations, Ann. of Math., 44[1943), 514-533. \nOre O. [1944], GaZois connections, Trans. AMS, 55 (1944), 493-513. Pickert G. [1952], Bemerkungen Dber \nGaZo_h-verbZn\u00addungen, Archv. Math. J. 3[1952), 285-289. Rosen B. [1976], Monoids for rapfd data fZow \nanaZysis Conf. Rec. of the 5th ACM Symp. on Principles of Programming Languages, Tucson, Ariz.,47-59. \nScott D. [1972], Continuous Zatt bes, Lect. Notes in Math. 274, Springer Verlag, 97-136. Scott O. [1976], \nData types as Zattiees, SIAM Comp. 5, 3(Sept. 1976), 522-587. Shamir A. &#38; Wadge W.W. [1977], Data \ntypes as objects, Lact. Notes in Comp. Sci. 52. Springer Verlag. (1977), 465-479. Tarjan R.E. [1976], \nIterative aZgotithms for gZobaZ fZow ana2ysfs, in Algorithms and eompZexZty, new di~ections and Yecent \nresults, (J.F. Traub cd.), Acad. Press Inc., (1976), 71-101. Tenenbaum A.M. [19741, Type determination \nfor very high ZeveZ Zanguages, Rep. NSO-3, Comp. Sci. Dept., N.Y. Univ., (Oct. 1974). Ward M. [1942], \nThe eZosure operators of a lattice, Annals Math., 43(1942), 191-196. Wegbreit B. [1975], Property extraction \nin welZ-foun\u00addedp~operty sets, IEEE Trans. on soft. Eng., SE-1 , 3(sept. le75), 27 0-285. 282   \n\t\t\t", "proc_id": "567752", "abstract": "<p>Semantic analysis of programs is essential in optimizingcompilers and program verification systems. It encompasses dataflow analysis, data type determination, generation of approximateinvariant assertions, etc.</p><p>Several recent papers (among others Cousot &amp; Cousot[77a],Graham &amp; Wegman[76], Kam &amp; Ullman[76], Kildall[73],Rosen[78], Tarjan[76], Wegbreit[75]) have introduced abstractapproaches to program analysis which are tantamount to the use of a<i>program analysis framework</i> (A,t,&#227;) where A is alattice of (approximate) assertions, t is an (approximate)predicate transformer and &#227; is an often implicit functionspecifying the meaning of the elements of A. This paper is devotedto the systematic and correct design of program analysis frameworkswith respect to a formal semantics.</p><p>Preliminary definitions are given in Section 2 concerning themerge over all paths and (least) fixpoint program-wide analysismethods. In Section 3 we briefly define the (forward and backward)deductive semantics of programs which is later used as a formalbasis in order to prove the correctness of the approximate programanalysis frameworks. Section 4 very shortly recall the mainelements of the lattice theoretic approach to approximate semanticanalysis of programs.</p><p>The design of a space of approximate assertions A is studied inSection 5. We first justify the very reasonable assumption that Amust be chosen such that the exact invariant assertions of anyprogram must have an upper approximation in A and that theapproximate analysis of any program must be performed using adeterministic process. These assumptions are shown to imply that Ais a Moore family, that the approximation operator (wich definesthe least upper approximation of any assertion) is an upper closureoperator and that A is necessarily a complete lattice. We next showthat the connection between a space of approximate assertions and acomputer representation is naturally made using a pair of isotoneadjoined functions. This type of connection between two completelattices is related to Galois connections thus making availableclassical mathematical results. Additional results are proved, theyhold when no two approximate assertions have the same meaning.</p><p>In Section 6 we study and examplify various methods which can beused in order to define a space of approximate assertions orequivalently an approximation function. They include thecharacterization of the least Moore family containing an arbitraryset of assertions, the construction of the least closure operatorgreater than or equal to an arbitrary approximation function, thedefinition of closure operators by composition, the definition of aspace of approximate assertions by means of a complete joincongruence relation or by means of a family of principalideals.</p><p>Section 7 is dedicated to the design of the approximatepredicate transformer induced by a space of approximate assertions.First we look for a reasonable definition of the correctness ofapproximate predicate transformers and show that a localcorrectness condition can be given which has to be verified forevery type of elementary statement. This local correctnesscondition ensures that the (merge over all paths or fixpoint)global analysis of any program is correct. Since isotony is notrequired for approximate predicate transformers to be correct it isshown that non-isotone program analysis frameworks are manageablealthough it is later argued that the isotony hypothesis is natural.We next show that among all possible approximate predicatetransformers which can be used with a given space of approximateassertions there exists a best one which provides the maximuminformation relative to a program-wide analysis method. The bestapproximate predicate transformer induced by a space of approximateassertions turns out to be isotone. Some interesting consequencesof the existence of a best predicate transformer are examined. Oneis that we have in hand a formal specification of the programswhich have to be written in order to implement a program analysisframework once a representation of the space of approximateassertions has been chosen. Examples are given, including oneswhere the semantics of programs is formalized using Hoare[78]'ssets of traces.</p><p>In Section 8 we show that a hierarchy of approximate analysescan be defined according to the fineness of the approximationsspecified by a program analysis framework. Some elements of thehierarchy are shortly exhibited and related to the relevantliterature.</p><p>In Section 9 we consider global program analysis methods. Thedistinction between \"distributive\" and \"non-distributive\" programanalysis frameworks is studied. It is shown that when the bestapproximate predicate transformer is considered the coincidence ornot of the merge over all paths and least fixpoint global analysesof programs is a consequence of the choice of the space ofapproximate assertions. It is shown that the space of approximateassertions can always be refined so that the merge over all pathsanalysis of a program can be defined by means of a least fixpointof isotone equations.</p><p>Section 10 is devoted to the combination of program analysisframeworks. We study and examplify how to perform the \"sum\",\"product\" and \"power\" of program analysis frameworks. It is shownthat combined analyses lead to more accurate information than theconjunction of the corresponding separate analyses but this canonly be achieved by a new design of the approximate predicatetransformer induced by the combined program analysisframeworks.</p>", "authors": [{"name": "Patrick Cousot", "author_profile_id": "81100592699", "affiliation": "Laboratoire d'Informatique,U.S.M.G., BP.53X, 38041 Grenoble cedex, France", "person_id": "PP39049972", "email_address": "", "orcid_id": ""}, {"name": "Radhia Cousot", "author_profile_id": "81100592574", "affiliation": "Laboratoire d'Informatique,U.S.M.G., BP.53X, 38041 Grenoble cedex, France", "person_id": "PP14204543", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/567752.567778", "year": "1979", "article_id": "567778", "conference": "POPL", "title": "Systematic design of program analysis frameworks", "url": "http://dl.acm.org/citation.cfm?id=567778"}