{"article_publication_date": "01-01-1979", "fulltext": "\n Permission to make digital or hard copies of part or all of this work or personal or classroom use is \ngranted without fee provided that copies are not made or distributed for profit or commercial advantage \nand that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, \nto post on servers, or to redistribute to lists, requires prior specific permission and/or a fee.&#38;#169; \n1979 ACM 0-12345-678-9 $5.00 Process Logic: Preliminary Report V. R. Pratt M. LT. Abstract We discuss \nproblems arising in reasoning about on-going processes, using the modal constructs after, throughout, \nduring, and #reserves. Earlier work established decidability of the theory whose language included only \nthe first two of these, along with program connective I , ; and *. Here we give a complete Gentzen-type \naxiomatization for useful combinations of the other modalities, We also indicate how such Gentzen-type \naxiomatizations lead to deterministic exponential time upper bounds on the complexity of decision procedures \nfor these languages. It remains an open problem how to completely axiomatize the combination of modalities \nduring and preserves. Introduction This paper treats a language for discussing on-going processes. The \nimportance of developing such logics can be readily appreciated frum the fact that Hoare-type !ogics \nonly describe the halting state(s) of the computation. The logic we propose here stays as close as seems \nto us possible to the Hoare-Dijkstra approach while still not depending on the computation to halt. While \nwe make no claim to the exhaustiveness of the constructs in our language, we do feel that any worthwhile \nlanguage for reasoning about processes must include at least the constructs we treat here. The problems \npresented by these connective alone have been challenging to say the least, and we are pleased to be \nable to report complete axiomatizations for each of the connective taken in any combination except 1 \nwith ~, in the absence of terms (hence the propositional case) and program connective. The problem of \ncombining 1 with ~ remains open, and we are now at a point in our work where we would be most excited \nto see a treatment of this combination from any source. The mathematical framework within which we carry \ncnst this work is that of dynamic Iogiq a framework first described in [111, though not under that name. \nThe purpose of dynamic logic is to make possible a mathematical account of some of the Iogics of imperative \nprograms that have appeared during the past decade, most notably those of Hoare [61 and Dijkstra [21. \n$alwicki s system of algorithmic logic [1,141 has a similar objective to ours, but with narrower scope, \nignoring the issue of nondeterminism raised in Dijkstra s logic. The language extends propositional dynamic \nlogic [3] to treat processes wlhich may not halt yet about which one may have useful things to say. The \nextension is accomplished by augmenting the single modality construct of dynamic logic (written [alp \nin earlier papers, and aJp here for uniformity with the other modalities of this paper, and expressing \nafter a happens, p must hold ) with other modalities expressing concepts that deal with the ongoing computation \nof programs ( throughout ~ p, sometime during % P, and a preserves p ), These four modalities were first \ndescribed in [12], where two of them were completely axiomatized and also shown to have a decidable theory, \nusing a [technique quite different from that used in [31 to show the decidability of the theory of J \n(to use our terminology). Here we continue this work for the remaining modalities, which present difficulties \nnot encountered in derivinlg the results in [121. We give complete axiomatizatibns of useful fragments \nof the language, anti indicate how these axiomatizations may be converted into exponential-time decision \nmethods for validity. Practicality of One-exponential Algorithms It is fashionable to consider exponential-time \nalgorithms as not particularly useful, However in the context of a proof-checker, where the user can \nstructure his proof in such a way that each step is manageably small, an exponential-time algorithm for \nverifying the soundness of a step may present a quite useful approach to verifying steps. The more traditional \napproach of verifying that the form of a step of an argument matches one of a small set of forms such \nas modus ponens is very constraining. Being permitted to use any sound inference involving say a dozen \nconnective in effect gives the user access to thousands of inference rules. In such a context anl improvement \nof an upper bound from two exponential to one may make all the difference between having a checker little \nbetter than a finite-number-of-rules checker and one that gives the user considerable flexibility. The \nexponential upper bound will only be approached in practice when the proof construction ends up considering \na substantial fraction of the exponentially many possible theories (sets of formulas arising during execution \nof our method). Using the approach outlined in [12], our experience with the sort of problems Ithat arise \nin practical program verification suggests that fewer than a few thousand theories should arise even \nin very complicated steps of the argument, provided the arguments are not so abbreviated that even a \ngood mathematician-programmer would have difficulty following them. Related Work Parikh [81 has given \na decision method for a very general language he calls L-, permitting quantification over states and \ntrajectories and subsuming our language That such a powerful language should have a decidable theory \nis remarkable. However, his method is not elementary recursive, making the result of academic interest \nonly. There also remains the problem of completely axiomatizing L-. Pnueli [9] has described a logic \nhaving the same concern as ours for ongoing processes. In the absence of an adequate model theory for \nPnueli s logic we are unable to make comparisons between the systems. It seems likely however that the \ntrajectory-oriented model theory behind our system would be adequate for Pnueli s logic, though the details \nremain to be worked out. h a recent talk H03 Pnueli has proposed such a model. Synta+v of the Language \nThe expressions of the language are partitioned into a set @ of formulae and a set X of ~rograms. We \nlet p,q range over formulas, Ab over programs. The symbols of the language atw propositional variables \nP, CAR,..., program variables A, B, C,,.. program connective I (dZOO$e),; (seguerz$e), * (iterate), and \n? (te~t), and modalities J (a~rer), w (tfiro~gha~t), 1 (d~r~ng), and J (Pre5er~e$). The syntax of the \nlanguage is as follows. * PQR ... -p pAq dp ~p ~p tip 22 AB C... alb ~b a* p? We obtain other logical \nconnective as abbreviations, namely pvq for dupAq), p~q for -pvq, and p~q fOr (p~q)A(q 3P). We will use \nthe syntactic convention of having the following operators have progressively increasing . X ?, with \nthe four modalities ail priority~~vA*Jl, being at the same level and being right associative, and also \n~ being right associative. Thus pAq~r is (pAq)~r, a;bJp is (a;b)Jp, aJbJp is aJ(bJdt WN -is P=h d e~ \n Semantics We postulate a set W of states. W has two functions. It offers places for formulas to be \ntrue in (facts), and it offers places for programs to travel between (actions). A trajectory s = (sO}sl,...,sms) \nis a sequence of states drawn from W; ms (or just m when context supplies the s) is the length of s. \nWhen m5 is infinite s has no final state. We write W! for the set of all trajectories over W, and let \ns,t range over trajectories, S,T over sets of trajectories. The need arises to distinguish between trajectories \ncorresponding to halting versus non-halting computations. No difficulty arises with infinite non-halting \ncomputations but the possibility exists that a program may deadlock/abort/faill all of which we shall \nconsider to be the same thing. A failing computation is indicated by a trajectory whose final state is \nA, a distinguished limbo state used only for this purpose. Any occurrence of A in a trajectory must be \nas the final state. A halting trajectory is one whose final state is not A. For convenience we write \nw-{A} as W . A fact is a pair (w,p) drawn from W X@, expressing the notion that formula p is true in \nnon-A state w. We let m range over sets of facts. For any fixed m (usually determined by context) we \nwrite w~p for (w,p)6r (w satisfzes p) and m(p) for { wlw~p} (the extension of formula p). An action is \na pair (sja) drawn from W!XZ, expressing the notion that program a can bring about trajectory s. (For \nexample, if we had assignment statements then x:=x +l;Y=x could bring about any trajectory (u,v, w) where \nin state v x is 1 larger than in u, and otherwise v is the same as u, and in state w y equals x and otherwise \nw is the same as v.) We let ~ range over sets of actions. For any fixed r, analogously to r, we write \nr(a) for {sl(s,a)c~} (the extension of formula a). Following [31, we define a structure to be a triple \n(W,m,r). (We depart from [31 in using T for trajectories where they use p for relations. ) The meaning \nof the symbols of the language will be expressed in terms of constraints on m and r, as described in \nthe next two sections. Semantics of Formulae The semantics of formulas are captured in the following \nconditions on r. 5r(%J = W -T(p) ?dpAq) = dp)ndq) Wl= alp iff Vscr(a)(so=w A sm#A = Sm@ Wl= alup iff \nVs{7(a)(sO=w =1 Vsz#A(szl=p)) Wk alp iff Vsc7(a)(sO=w ~ 3sz#A(szkp)) Wp alup iff Vs{r(a)(sO=w ~ Vsysz#A(y<z \n~ (syPp ~ Szkp))) Thus the meaning of N is that -p is true in w just when p is not true in w, and for \nA it is that pAq is true in w Just when p and q are both true in w. Common to all four modality conditions \nis the connection between the state w in which the formula s truth is being established and the initial \nstate of all relevant trajectories s in ~(a), namely that so must be w. Also common is the quantification \nover such trajectories, namely universal quantification. The differences are as follows. alp Every s \nthat halts satisfies p when it halts. alllp Every s satisfies p throughout (ignoring A). alp Every s \nsatisfies p at some non-A state in s. aJp In every s, once p is true it stays true in non-A states of \ns. O~erations on Trajectories The choice of trajectory sets, SIT, could be taken to be simply their union. \nHowever we would like to capture the idea that a computation does not execute a failing test when it \nhas an alternative command to execute. (A similar concern motivated the use of computation trees in [51. \n) We say that (s&#38;..., sk,A) is a @ej%c of any trajectory beginning (sO,...,Sk,... ), where Sk is \npermitted to be either final or non-final. A trajectory set S is a prefix set of trajectories when no \ntrajectory in S is a prefix of any other trajectory in S. The /srejh dowre of S is the largest prefix \nset contained in S; it cab be obtained merely by removing all trajectories that are prefixes of other \ntrajectories. Then SIT is taken to be the prefix closure of SIT. The difference between SIT and SUT affects \nonly L When m5 is infinite or Sm = to, sj is defined and satisfies (S;t)z = s~ for O<z<ms ($J)m5+z = \nt~ for O<z<mt the latter holding only for finite my Intuitively sy is the trajectory obtained by fusing \nthe last state of s with the first state of t when they are the same. Then S;T, the fusion @duct of S \nand T, is {@CS, tCT, and s;t is defined}. We take I to be {(w)lwfW}, that is, the set of al! zero-length \ntrajectories. We take S*, the ancestral of S, to be 11S1S;S1,.. We say that S is total when for every \nw in W it contains some s with so = w. Semantics of Agents We may now impose constraints on r. r(a) is \ntotal ?(alb) = r(a)lr(b) r(~b) = ?(a);r(b) r(a*) = 7(a)* ?(p?) = {(w)IwI=PI I {(w, A)IwYP} I {(A)] Thus \nalb means the program having the choice of bringing about any trajectory that either a or b can bring \nabout; ~b brings about a trajectory of A then follows it up with one of b; a* brings about trajectories \nof a repeatedly, hdefinitely often; p? does nothing if p holds, otherwise it vanishes into limbo. Satisfiability \nA formula p is satisfiable when there exists a structure (W,m, r) (a model of p) for which m(p) is non-empty. \nWe will sometimes distinguish a state of w(p) as the base state of the model. We call p valid when -p \nis not satisfiable. Validities The following formulas may be seen to be valid. albJp ~bJp a*Jp p?Jq \nalblllp ~blllp a*lUp p?ulq albJ.p p?lq alb~p itqb~p a*Ip p?rq Axiomatization One might well want to \ntake some or all of the above validities as axioms. The problem arises of giving a complete axiomatization \nof the valid formulas of the language w A J N 1 I \\ ; * ?. In [121 a complete axiomatization for J and \nill is given. We do not as yet have a complete axiomatization for all the connective taken togethe~ in \nparticular we do not as yet know how to axiomatize the combination of 1 and ~. All other combinations \nare understood however, and we outline proofs of completeness here. The reader is probably more accustomed \nto axiom systems which manipulate formulas. In this paper, as in [121, we will arrive at our completeness \nresults via systems that manipulate sets of formulas, which we shall call theories. We shall confine \nourselves to finite theories here. Such an approach, first suggested by Gentzen [4], makes it rather \neasier to make the connection between model theory and proof theory that is needed for proofs of soundness \nand completeness. A theory is satisfiable (has a model) when the base state of some structure (the model \nof the theory) satisfies all the formulas of the theory. The sequent naltation for a theory, also due \nto Gentzen, collects some or all the negative formulas (formulas of the form -p) on the right of an arrow \n+ and omits their negations. Thus a sequent notation for the theory {-(pAq),pVr,-p,q} ~ould be pVr,q+pAq,*p. \nIf in this example q happened to be -s then pVr+pA@,*fS,S would also be a sequent notation for this theory. \nThe advantage of sequent notation lies not so much in its saving negations as in making a theory look \nmore like an implication. Thus the above theory being unsatisfiable is the same thing as (pVr)Aq D (pAq)V-p \nbeing valid. For this reason we shall use valid sequent as a synonym for unsatisfiable theory, anld \ncall a model olf a theory a counterexample to the corresponding sequent. Thus P~QQ~R + -P, R is a valid \nsequent because the corresponding theory .. {pnQQ~R,NNp,NR} is unsatisfiable, as the reader may verify. \nPnQQ~R + p,R has as a counterexample a model with one state in which P~QR are all false. It is this illusion \nof implication that makes the sequent notation helpful in keeping track of the connection between proof \ntheory and model theory. Gentzers systems Consider the theory {r,r ,r }, where r,r ,r are arbitrary formulas. \nIf this theory is unsatisfiable then so is {r , rAr }. (In this instance the converse is also true.) \nSimilarly, if {r,r } and {r , r } are both unsatisfiable, so is {r ,rVr }. And the theory {r,r ,~r} is \nevidently unsatisfiable regardless of what r and r are. Such derivations of one unsatisfiable theory \n(the conclusion) from zero or more other unsatisfiable theories (the premises) are the concern of Gentzen \nsystems of inference ru Ies. The examples above can be described by the following rules. pAq+ P+ q+ P?q+ \n pvq+ P+P The first rule says that from any theory containing pAq one can infer a theory in which pAq \nis replaced by the two formulas p and q. The second says that from a theory containing p, and another \nwhich is the same theory with p replaced by q, one can infer the same theory with p replaced by pvq. \nThe last says that one can always infer a theory containing a formula and its negation. Evidently all \nthree of these rules preserve unsatisfiability of theories, or what amounts to the same thing, validity \nof sequents. Such rules are called sound. A system is sound when all its rules are sound. So far we have \nbeen able to settle all questions of satisfiability using a structure with one state. A more complicated \ninference is, from {-r} infer {r ,~a-k, r }. If -r is unsatisfiable r must be true in every state of \nevery structure, whence so must air, whence {*aJr} is unsatisfiable, Adding r ,r cannot make this theory \nany more satisfiable. This leads to the following rule. &#38;PJ -@_lp A feature of this rule is that \nwe have placed the rule s premise +p inside set braces. This is to indicate that we do not mean that \nthe inference may start from any theory containing -p, but rather that the inference must be from the \nsingleton theory {*P}. The, inferred theory must contain -@_Ip, and may contain any other formulas as \nwell. Here is a more complicated rule using this notation. {Pi,-,t= k+q]dpl,...idpk+dq and (2) . . \n. and (k) every trajectory of a leads only to states satisfying pk, then every trajectory of a from u \nleads only to states satisfying q. The reader should verify that this rule (suggested to the author by \nR. Parikh) is sound. Proofs. A jmoof is a rooted tree whose vertices are Iabelled with seq uents, such \nthat every sequent follows from its predecessors by some rule. (The predecessors of a vertex v are further \nfrom the root than v, and adjacent to v.) The proof proves the sequent Iabellirsg the root_ The height \nof a proof is the length of the longest path from the root to a leaf. It should be clear that only valid \nsequents can be proved in a sound system. A system is complete when every valid sequent can be proved. \nA proof of +p may be interpreted as a proof of the formula p, which is the application of Centzen systems \nthat makes them of interest. System P. The following system will supply all our propositional needs, \nasssuming N and A are the only logical con nectwes we use. Adding rules to cater for other connective \nis straightforward, but unnecessary if we consider pvq to be just an abbreviation of 4NpAw), etc. PL \nP2. p+ P3. p,q+ P4. *p *q P*P ~ pAq+ +pAq The following rule is needed if one intends to distinguish \nbetween a negated antecedent and the corresponding un-negated consequent, as Gentzen did, and as as we \ndid in [12]. In this paper we have chosen not to make such a dntinction, making this rule redundant. \n.+P The soundness of this system should be obvious. For completeness we may give a method of constructing \na proof of a valid sequent. (This style of completeness proof will be repeated later with the more complex \nsystems. ) If the sequent contains only Iiterals (propositional variables and their negations), then \nto be valid it must contain both P and -P for some variable P. Hence it may be proved immediately via \nrule PL If it contains N.Up it may be proved via P2 from a sequent whose validity should be evident and \nwhich contains two fewer logical connective. If It contains pAq, then It may be proved via P3 from a \nclearly valid sequent containing one less logical connective. If it c~ntams -(pAq) then it may be proved \nvia P4 from two valid seq uents each having fewer logical connective. In all cases the importance of \nthe premises being valid is that one can continue constructing the proof. The importance of their having \nfewer connective is that it guarantees that the proof construction must eventually halt. The content \nof this rule is that if in every state, plA... Apk implies q, then in each state u from which (1) every \ntrajectory of a leads only to states satisfying pl, System 1 We now give a system for the language * \nA J and ~. That we omit 1 reflects our inability to axiomatize J in combination with 1. That we omit \nthe program connective I ; * ? reflects the difficulty of axiomatizing even program variables alone. \nIn fact dealing with program connective is a relatively trivial matter. In this system Wp is an abbreviation \nfor pA&#38;f p. The rules consist of those of system P, together with n p,a.rp+ a.rp+p al-p+ 12. {Pi,...$Ppql#Jk.#Jk \n+ r} ~pl,...,~pj,~ql, ~qk,~qk + dr ,r3. {Pi,...,pj + q=f(pi+l,...jpk)} (f monotonic) ~pll... ,~pj,LdPj+l,..., \n~Pk + ~q Theorem. System J_ is sound. Proof. Rule 11 is simply a cut rule, whose content is that if .f$Vp \nand SV-p are both valid, so is S. The rule mentions Up only to emphasize that we do not need the rule \nother than when tip is present. Omitting the three occurrences of a~p would preserve both soundness and \ncompleteness of the System. Rule 12 says that when the truth of the p s and q s jmplies the truth of \nr in every state, then if the p s hold at the end of every trajectory of a leaving state u, and the q \ns hold throughout every trajectory of a leaving state U, r holds at the end of every trajectory of a \nleaving state u. Rule 13 says that if the truth value of q depends monotonically on the truth values \nof Pj+l,...,pk in states satisfying pi}... pj, then if pl,...,pj hold throughout every trajectory of \na leaving state u, and Pj+l>... JPk are preserved in every tra&#38;ctory of a leaving state u, then q \nis preserved in every trajectory of a leaving state u. All these should be evident truths. ~ Theorem. \nSystem 1 is complete. Proof. We frost show that any valid sequent S follows from valid sequents via some \nrule, The cases are: (i) S contains only Iiterals. If S is valid, P1 must apply. (ii) One of --p, pAq, \n4pAq) C S. One of P2-P4 applies.  (iii) dp 4 S, p,-p ~ S. Rule 1 applies non-trivially, (If P,*P are \npresent Rule 2 still applies, but only trivially in that the only new sequent it could produce would \nbe one that fell immediately to rule PI.) (iv) -d (-aJr) 6 S, S valid without it. Mark it as irrelevant. \nIn this way it will no longer be a consideration in deciding which of these six cases S falls under, \nwith the exception of case (iii), which should take note of it in deciding whether p,~p f S. (v) -d \n~ S, S-~aJr has a counterexample K (with base state u). If rule 2 does not apply then its premise has \na  97 counterexample K? (with base state u ), which we may assume without loss of generality has an \nalmost dis~int set of states from K, with only A in common. Combine K and K and add the trajectory ((u, \nu ,A),a) and the fact u~~a-lr to form a single structure (WIW ,mI#l{u@a.Jr], rl#l{((u,u ,A), a)}). The \nreader may verify that the resulting structure is a counterexarnple to S, contradicting our assumption \nthat S was valid. (vi) -dr f S, S-%i_r has a cotmterexample K. If rule 3 does not apply then the truth \nvalutes of q in states satisfying Pi,... ,P j does not depencl monotonically on Hehce there exist K ,K \nin whose respective base states u ,u q is respectively false and true, yet such that pi,... ,pJ are true \nin u ,u , ruxl if pi is true in u for j<i<k then pi IIS also true in u . Now pj+l,... Pj+lv..,P~ ~Pk \nnlaY be assumed tlo be all fake in u. Hence K, K , K may be combined to form one structure, with trajectory \n((u, u ,u ,A),a) and fact ulp+dr added, along the lines of case (v). This may similarly be verified to \nbe a counterexample to S. We have thus far established that the first step of constructing a proof may \nbe carried out for a valid sequent containing -aJr or -fir. We now need to show that this proof construction \nterminates. Applicaticm of P2-P4 and Rule Jl (non-trivial applications), and marking of irrelevant formulas, \nclearly cannot proceed indefinitely. Hence eventually the proof construction must terminate or one of \n12,13 must become applicable. Define the duration of a sequent to be the maximum number of modalities \nencountered on any path from root to leaf in any formula of the !!equent. It is apparent that 12 and \n13 reduce the duration of sequents. Furthermore, P1-P4, Jl, and marking, do not increase duration. Hence \neventually our proof construction must reduce duration to zero, at which ploint the rules of system ~ \ncease to be relevant, a{l modalities having disappeared. ~ A Hilbert System From the completeness of \nsystem 1 we can infer the completeness of the following Hilbert-type system. Rules: Modus Ponens (from \np, p=~q infer q) J-Necessitation (from p infer aJp) I-Necessitation {from p infer ~p) Axioms In this \nsystem it is possible to derive all the rules of systems P i~tld .f, a tedious but straightforward exercise \nwe leave tata more polished version of this paper. Program connectiues Let S be a valid sequent. It \nsuffices to show how to infer Dealing with program cosmectives in system 1 is simplified by the existence \nof proofs of completeness of systems for the language -A J I ; * ? [7,12,151. The reader may verify the \nsoundness of each of the following formulas. albJp ~ aJp A bJp ~bJp = aJbJp p?Jq ~ p~q alb~p ~ flp A \nb~p ~b~p = idp A a-lb~p a*lp = a*J~p p?.rq  The adequacy of these axioms follows from the fact that \neach equivalence shows how to eliminate a program connective. (In the case of the axiom for * with J \nwhat we have is a way of isolating * from 1, thereby reducing the problem to axiomatizing * with J. The \naxiom for ? with ~ may be considered to assert the equivalence of p?~q with true. ) Only a*Jp is not \ncatered for. The following axioms for * are adequate, though this fact is far from apparenL axJp ~p a*Jp \n~ aJa*Jp P A zd(p~a-ip) ~ a*Jp  Together with the Hilbert-style axiomatization of the language -A J \n1, these formulas when taken as axioms yeild a complete axiomatization of the language * A J ~ I ; * \n?. This can be proved along the lines of [12], using the appropriate Gentzen versions of the above equivalences. \nFor example the equivalence for a*J_p becomes a* JaIp+ +a*JaJp axfp+ +a*Jp This rule is used analogously \nto the other Gentzwr rules we have encountered in showing how to construct a proof backwards from the \nsequent to be proved. We now abandon J and turn our attention to L System 1 11. {pi,-wpk + q} dpl,...,dpk+ildq \n 12. {P+} &#38;Lp + aJq  13. +p +alp  14. {P-W) dp +dq  Theorem. System 1 is complete. Proof. We \nproceed as for the proof of completeness of system 1. S from lesser valid sequents. The cases are: (i), \n(ii) As for the corresponding cases with system 1. (iii) -a_lq 6 S, there is a counterexample K to $-%dq. \nIf rule 11 does not apply there must be a counterexample K toPi,... jpk+q. If rule 12 does not apply \nthere must be a counterexample Ki to pi+ for each al.pi in S. Combine these counterexamples, adding trajectory \n((%ul,...,uk,),a)a) and fact (u,~~q) (the u s being the base states of the corresponding K s) to form \na counterexample to S, contradicting the validity of S. (iv) ~dq c S, there is a counterexample to S--dq \n(which we shall not use). If rule 13 does not apply there is a counterexample K for Sl{-q } (one that \nmakes q false). If rule 14 does not apply there is a counterexample Ki to pi+q for each al.pi in S. Combine \nthe counterexamples and add trajectory ((u,u1,... Uk,A),a) and fact (tr,dq) to yield a counterexample \nto S. Choosing the final state to be A avoids falsifying any aJp s in S. Termination is easier to prove \nfor system 1 than for system 1. Every rule reduces the total number of connective in the sequent. Program \nConnective and 1 Although System 1 turned out to be a little more tractable than System 1, adding program \nconnective to the language N A J 1 is more difficult to axiomatize. The problem is the lack of a satisfactory. \nequivalence for ~blp. The formula ~blp ~ dp A a-lblp is not valid, and replacing A by v does not make \nit valid. We would like to see an axiomatization of * A J 1 ;j with or without I * and ?. There is a \nstronger language which we do know how to axiomatize, using the modality ~. Unlike all other modalities, \nwhich take one program and one formula to yield a formula, this one takes two formulas, and is written \ndp,q. Its informal meaning is either p holds sometime during x or a doesn t halt, or q holds when a halts. \n entire meaning applies individually to each trajectory of ~(a), as the following formal definition \nshows. w~a-llp,q iff Vs{~(a)(so=w ~ llsz#A(szl=p)Vsm=AVsml=q) We now have as obvious validities albllp,q \n~ dp, q A bJlp,q ~bJJp,q = a.Up,(blp,q) p?Jlq,r ~ q v (Pa) dp = dF,p (F abbreviates PANP) It can be \nseen from this that the difficulty with ; has been banished. Moreover the last axiom permits us to treat \n-1 as an abbreviation. It remains to verify that we can completely axiomatize the language * A J in order \nto establish that we have a complete axiomatization of -A J I ; ?. System 4 M. P %.Jlp,q  42. aJJF,r+aJJq,s \n{p+q) allp,r + allq,s 43. pi,. -Pk+q dF,pl,...,dF,pk+dp,q  Notice the mixed premise rule 42, where \none premise is {}-type. The soundness of the system should be clear. Theorem. System li is complete. \nProof. The proof construction techniques carry over unchanged to this system. Rule .J2 should not be \napplied when p is already F. When allp,q is present in S, S is not valid without it, but S does not follow \nfrom valid sequents using any rule, it becomes possible to construct a counterexample as before. The \nmethod of construction of the counterexample should be evident from the rules. ~ For axiomatizing * the \nfollowing appears to be useful. We have not yet established whether it suffices for a complete axiomatization, \nthough if it did the proof ought then to follow along the same lines as that of [12]. q A a*JJp,(q = \nallp,q) ~ a*Jp,q (due to D. Hare!) axllp,q ~ pvq ax.llp,q ~ a.Up,(a*Jlp,q) allp,(q=v) = dlp,q ~ ~p,r \naJlp,*p p = allp,q  Decision Methods Our present concern with Gentzen-type axiom atizations is motivated \nfor us primarily by the problem of giving useful decision methods. Although we have also used them to \ndemonstrate completeness of less useful (algorithmically speaking) Hilbert-type systems, this application \nis of marginal interest to us. As remarked in [12], the decision method of [3] is not useful in practice, \nbecause it always achieves its worst case of two exponential. The algorithm described in [12] resulted \nfrom observing that not all valid formulas required the extensive search of the method of [3] simply \nto demonstrate validity because quite short proofs of their validity existed. We asked whether there \nwas a systematic way to find such proofs, and this led to our development of the decision method of [12]. \nThis algorithm has since been improved in its worst case performance to one exponential [131. Gentzen \nsystems were a constant source of inspiration in developing such algorithms, and the techniques of converting \na Gentzen system into a useful decision method carry over to the systems described here. In particular \nthe technique for constructing a tableau described in [131 leads to single-exponential algorithms for \nall of the Iogics considered here. In outline, the possibility of such fast algorithms depends on the \nfact that all the proof construction methods described here produce theories drawn from a set of formulas \nof cardinality m proportional to the length of the formula to be tested for satisfiability. At most 2nl \ndistinct such theories will therefore ever be considered. It is possible to deduce satisfiability from \na single graph having those theories for vertices, in time a polynomial in the size of the graph. Constructing \na ~graph with all 2nl theories is not always necessary. Just those theories that, arise in attempting \nto construct a proof need be considered. While it is possible to produce examples that force consideration \nof exponentially many theories with our method, such pathologies do not seem to arise in practice in \nthe context of verifying steps in a proof of program correctness. Open Problems The following problems \nhave already been mentioned; we collect them here for ease of reference,, L Axiomatize u A 1 ~. The valiclity \naJpn(~p=aJp) has not escaped our notice. The existence of more obscure validities has plagued our search \nfor an adequate system. 2. Axiomatize -.A J I ; *. Are thle axioms above complete? If they are it is \nlikely that the technique used in [12] in the absence of 1 will carry over here. Bib[iogra~?sy [11 Banachowski, \nL,, A. Kreczmar, G. Mirkowsk~ H. Rasiowa, A, Salwicki. An Introduction to Algorithmic Logiq Metamathematical \nInvestigations in the Theory of Programs . In Math. Found. of Camp. Sc. (eds. Mazurkiewicz and Pawlak), \nBanach Center Publications, Warsaw. 1977. [21 Di jkstr~ E. W. A Disci/Aine of ,Programming. Prentice-Hall. \n1976 [31 Fischer, M.J. and R, E. Ladner. Propositional Modal Logic of Programs. Proc. 9th Ann. ACM Symp. \non Theory of Computing, 286-294, Boulder, CoI., May 1977. [41 Gentzen, G. Untersuchungen uelber das Logische \nSchliessen, Math. Zeitschr, 39, 176-210, 405-431. 1934-5. (English tr.: Investigations into Logical Deduction, \nin The Coilected Papers of G. G/!nczen, 69-131. 1969.) [51 Harel, D. and V.R. Pratt. Nondeterminism in \nLogics of Programs. Proc. Sth Ann. ACM Symp. on Principles of Programming Languages, 203-213, Tucson,, \nArizon~ Jan. 1978. [61 Hoare, C. A. R. An Axiomatic Basis for Computer Programming. CACM 12, 576-S80, \n1969. [73 Parikh, R. A Completeness Result for PDL. Symposium on Mathematical Foundations of Computer \nScience, Zakopane, Warsaw, Sept. 1978. [81 Parikh, R. Second Order Process Logic. Internal Report, MIT, \nApril 1978. [91 Pnueli, A. The Temporal Logic of Programs. 18th IEEE Symposium on Foundations of Computer \nScience, 46-S7. Oct. 1977. [101 Pnueli, A. Correctness of Concurrent Programs The Temporal Logic Approach. \nUnpublished talk, NSF-CBMS Conference on the Logic of Computer Programming, Troy, NY. June 1978. [111 \nPratt, V. R. Semantical Considerations on Floyd-Hoare Logic. Proc. 17th Ann. IEEE Symp. on Foundations \nof Comp. Sci., 109-121. 1976. [121 Pratt, V. R. A Practical Decision Method for Propositional Dynamic \nLogic. Proc. 10th Ann. ACM Symp. on Theory of Computing, 326-337, San Diego, Calif,, May 1977. [131 Pratt, \nV.R. A Near Optimal Method for Reasoning About Action. MIT/LCS/TM-113, M. I. T., Oct. 1978. [141 Salwicki, \nA. Formalized Algorithmic Languages. Bull. Acad. Pol. Sci., Ser. Sci. Math. Astr. Phys. vol. 18. No. \n5. 1970. [1s1 Segerberg, K. A Completeness Theorem in the Modal Logic of Programs. Preliminary report. \nNotices of the AMS, 24, 6, A-552. Oct. 1977. \n\t\t\t", "proc_id": "567752", "abstract": "We discuss problems arising in reasoning about on-going processes, using the modal constructs <i>after, throughout, during,</i> and <i>preserves.</i> Earlier work established decidability of the theory whose language included only the first two of these, along with program connectives | , ; and *. Here we give a complete Gentzen-type axiomatizations for useful combinations of the other modalities. We also indicate how such Gentzen-type axiomatizations lead to deterministic exponential time upper bounds on the complexity of decision procedures for these languages. It remains an open problem how to completely axiomatize the combination of modalities <i>during</i> and <i>preserves.</i>", "authors": [{"name": "V. R. Pratt", "author_profile_id": "81100298352", "affiliation": "M.I.T.", "person_id": "PP39036584", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/567752.567761", "year": "1979", "article_id": "567761", "conference": "POPL", "title": "Process logic: preliminary report", "url": "http://dl.acm.org/citation.cfm?id=567761"}