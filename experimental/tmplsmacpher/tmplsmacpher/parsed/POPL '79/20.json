{"article_publication_date": "01-01-1979", "fulltext": "\n Permission to make digital or hard copies of part or all of this work or personal or classroom use is \ngranted without fee provided that copies are not made or distributed for profit or commercial advantage \nand that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, \nto post on servers, or to redistribute to lists, requires prior specific permission and/or a fee.&#38;#169; \n1979 ACM 0-12345-678-9 $5.00 STRING PATTERN MATCHING IN POLYNOMIAL TIME* (Extended Abstract) K. C. Liu \nA. C. Fleck University of Wisconsin Milwaukee The University of Iowa 1. INTRODUCTION. There is a wide \nrange of applications for string processing and SNOBOL4 (Griswold, et al. [1971]) has come to be the \nmost widely implemented \\ and accepted language for such applications. No doubt one of the principle \nreasons for this accep tance is the data structure around which the lan\u00adguage is organized, the string \npattern. This structure together with the associated pattern matching process provide great flexibility. \nNever theless it has been widely recognized in informal terms that the pattern matching process is often \ngrossly inefficient (Ripley &#38; Griswold [1975], Dewar &#38; McCann [1977]) and that the pattern struc\u00adture \nis notoriously difficult to explain and use (Ripley &#38; Griswold [1975], Stewart [1975]). Each of these \nareas of difficulty relates to such things as two modes of operation (quick-full scan), prob\u00adlems with \nleft-recursion, heuristics in the scan, etc. Some difficulties are inherent with string patterns but \nmany are not ; we feel the developments described here help to clarify this situation. In section 2 we \ndescribe the formal model upon which we base this work. This allows the careful analysis of the variety \nof sets of strings which may be specified by the patterns which we admit and deduction to be made concerning \nthe possibility/ impossibility of algorithms of interest. With SNOBOL4 it has been the case that the \ncareful defi\u00adnition of the meaning of a pattern is in terms of the actions taken by the pattern matching \nalgo rithm. This has led to the incorporation of idio syncrasies of a particular algorithm into the understanding \nof the pattern structure. This seems akin to using a compiler as the definition of a progrming language \nand we believe it is impor tant to future progress to have other alternatives. In section 3 we point \nout that the worst case execution time of the usual SNOBOL pattern match ing algorithm is exponential \nin the length of the subject string, even on some quite simple patterns. We then present an algorithm \nwhose worst-case time is polynomial and that operates on patterns which include a true set complement \noperator. As side benefits we find that the algorithm is not multi modal and correctly handles the null \nstring as an *The work of both authors in the project was sup\u00adported by the National Science Foundation \nunder grant DCR-75-05296. alternative and left recursion. In order to conserve space we will assume throughout \nthis paper that the reader is familiar with the idea of a string pattern in the sense that it is described \nin Griswold et al. [1971] . Also it is probably necessary that the reader ha~e some general knowledge \nof the formal languages area. 2. THE FORMAL MODEL. As we remarked in the introduction, we feel that it \nis crucial that the concept of a string pattern be given a meaning completely independent of whatever \nmatching algorithm(s) might be em ployed. Recently, Gimpel [1973] and Stewart [1975] have discussed formal \nmodels for certain classes of string patterns. Their models were directed at the pattern matching process, \nparticularly as it is af fected by the combination of patterns under cer\u00adtain operations. These models \ndo not seem well suited to extension to the operations we consider here or generally to the concerns \nwe follow. The analogy between BNF (or context-free gram mars) and SNOBOL4 patterns has sometimes been \nmade and is informally but systematically treated in Fleck [19T8]. We use the formal grammars approach \nand for the operations of interest we have devel\u00adoped the details of the definition of an appropri\u00adate \nrewriting system. Informally, in SNOBOL4 terms, we will con sider patterns which can be defined by means \nof the following operations: assignment (written :=), alternation (written I), concatenation (written \nas juxtaposition), immediate value assignment (written $), and complementation (written -I). As operands \nwe admit string constants and simple vari ables (i.e., identifiers). We insist that the variables used \nfor immediate value assignment be disjoint from those used with ordinary assignment and that they have \nsome specified initial string value. The informal interpretation of n is that a string matches 1P if \nand only if it does not match pattern P. Some precautions must be taken when the corn- plement operator \nis allowed, so that logically in consistent definitions cannot be made. For exam pie, the pattern definition \nP :=mP (in SNOBOL4 the unevaluated expression operator would be 222 required on the right side) obliges \nany string P :=al(P $X)X. which does not match P to match P and vice versa. Inconsistent systems may \nbe less obvious Note that the parentheses are meta-symbols used of course, for example the system only \nto emphasize associations. Also this exsmple conforms exactly to SNOBOL4 (if unevaluated expres-P:=alQ \nsion is added to P and X). Now as (explicit) rewriting rules we would have Q:=blnP. p+a We disallow any \nsystem of pattern definitions and where the complement operator occurs along the P+(P $x)x. chain of \na recursive definition and show that the resulting systems are always well-defined. Rules which contain \nneither immediate value assign\u00adment ($) nor complementation (--I) maybe re- It should also be noted that \nsince we a:re garded as ordinary context-free rewriting rules. considering a static model of string patterns \n(pat-To deal with immediate value assignment, each step terns are considered in isolation, not as part \nof of a derivation is regarded as having an additional a broader progrming system) all occurrences of \ncomponent for each immediate value variable which an identifier on the right-hand side of an assign \ncontains its current value (actually each component me~t (:=) are regarded as unevaluated in the must \ncarry a stack of values). The rewriting rules SNOB3L sense. which involve $ must then manipulate these \ncom\u00ad ponents. Also when an immediate value variable is A canonical pattern definition system essen\u00adto \nbe rewritten (i.e. , it occurs other than as tially provides for a collection of assignments to the right-argument \nof $), it is replacedby the identifiers. The expressions on the right-hand value of the corresponding \ncomponent of the step. side of the assignments each consist of one or For instance, for this example \nwe have more alternatives; the alternation operation con\u00ad sidered is essentially that of SNOBOL~ (see \nGris- P> (P$X)X+ (((P$ X)X$X)X ~ ((aX) $X)X wold , et al. [19T1]) with the exception of being X.s. commutative. \nEach alternative consists of a con\u00adcatenation of factors, where a factor is either a S (aa)X=2-aaaa. \nstring constant, an identifier, a complemented X=aa identifier or a factor with the immediate value operator \napplied. The immediate value wnment The rewriting of the clause P$X by the pro operator is understood \nin the sense of SNOBOL4. duction P+a replaces the entire clause by a We assume that the identifiers used \nwith the ime and in addition establishes this as the value of diate value operation are disjoint from \nthose x. Then in the clause (aX) $X, the leftmost X which occur in the collection of assignments. We \nis rewritten as a so the entire clause is re\u00adalso assume a given initial string value for all placed \nby aa and in addition this value is immediate value variables which we take here to established as the \nvalue of X. always be the null string. Example 2. A pattern U describing With each canonical pattern \ndefinition system {a%ncn I na 1]. we associate a characteristic digraph where the nodes of the digraph \nconsist of the identifiers P:=PCIQ,C P+Pc,P+Qc,\u00ad occurring in the assignments of the system and there \nis an unlabeled edge from ~ to @ if in Q := ab taQb Q+a b, Q+aQb, [ the assignment a :=6, ~ occurs in \nexpression &#38; R:=aR]aS ~R+aR,R+aS, without complementation and there is an edge lab\u00adelled v (complement) \nif ~ occurs in 6 with S := bc lbSc S +bc, S +bSc, complementation. Our algorithm and results then I T \n:=~P1-IR ,T+-P, T+-R, 3224!L=E sYstems &#38;which ~ Characteristic digraph contains no cycle which uses \nan edge lab-U :=-IT 1u-t+ . elled ~. It may be proven that each such system does give a well defined \ndescription of a collec-To avoid circularity in the definition of the tion of strings. derivation relation \nfor complementation one must exercise care. We depend in a crucial way on the If P is a canonical pattern \ndefinition sys earlier mentioned restriction that complementation tern, the set of strings described \nby P consists does not occur along a chain of recursive defini\u00adof all strings which match P in their \nentirety tions. This means that there is only a finite (in SNOBOL4 terms, pattern matching would succeed \ndepth of complementation possible in a deriva\u00adfor E OS(@)PRPOS(@)) and is written L(P). A tion and that \nwhen complementation is used it can derivation relation (using the productions) can be only be in conjunction \nwith a more shallow vari rigorously defined to exactly result in L(P) . able. Hence the derivation relation \ncan be de-Space limitations do not allow for the presenta-fined by induction on the depth in the derivation \ntion of the formal definitions but we suggest the where the anchor for depth zero is essentially the \nnature of the rewriting rules with the examples context free case (augmented by $-facilities men\u00adbelow. \nThe details of the formal definitions tioned in Example 1). For instance, in this exam\u00adappear in Liu \n[1977]. ple we note: Example 1. A pattern P describing {a2n]n2z O}. A. P %w6{a,b,c]* fff w=apbpcq for \np,q>l; 223 B. R % w&#38;{a,b, c]* iff w=arbscs for r,szl; c. Hence T %w~{a,b, c]* iff w ~ {apbpcqlp, \nq> 1] or wt{arbscslr, s> l]; D. Hence U %wE[a,b, c]* iff W6 {apbpcqlp, qzl] and w~{arbscslr, s> l], \nand the claim for the example is established. The descriptive power of the class of pattern definition \nsystems under consideration can be re lated to the usual formal languages hierarchy by the following \nresults, Theorem. The collection of sets of strings de\u00adscribed by canonical pattern definition systems \nproperly includes the context free languages and is closed under union, complement, intersection, con \ncatenation and iteration (star) but is not closed under homomorphism. Proof omitted. Hence the family \nof languages described by canonical pattern definition systems includes the enbire hierarchy of k-intersection \nlanguages de\u00adscribed by Liu and Weiner [1973]. Also it can be verified that if a system does not contain \nimmedi ate value (i.e., the only extension is complementa tion) and the terminal alphabet has just one \nsymbol, then the language described is regular. This observation in conjunction with Example 1 shows \nthe independence of the immediate value operation from complementation. Theorem. There is no algorithm \nwhich, given an arbitrary canonical pattern definition system P, will determine if (a) L(P) O, (b) L(P) \nis finite (or infinite).  Proof omitted. Of course since the context free grammars occur as a special \ncase of pattern definition sys\u00adt ems , all the other usual decision problems (e.g., equality) are also \nunsolvable. 3. THE ALGORITHM. Our first observation is to quantify the widely recognized inefficiency \nof the SNOBOL4 pat\u00adtern matching algorithm. Assertion. The SNOBOLh patte~n matching algorithm requires \ntime proportional to 2n for cer tain (context-free) patterns , where n is the length of the subject string. \nThe assertion can be verified by evaluating performance of the algorithm (see Griswold [19T2] or Waite \n[1973]) on a pattern definition such as P=bla*Pcla*Pd. Because of space limitations and particularly \n lacking the precise grammar definitions omitted in the last section, we can only informally describe \nthe operation of our polynomial time pattern match ing algorithm for canonical pattern definition sys \nt ems. The algorithm is derived from Earley s con text-free parsing algorithm (Earley [19 70]). In fact \nin the case of context free patterns (i.e., those canonical pattern systems not inyolv%ng $ or 1) the \nalgorithm essentially reduces to Earley s (and hence operates in cubic time). As,a coincidental benefit \nwe obtain an algorithm which has no difficulty with left recursion or null string alternatives. The following \ndiscussion of the algorithm presumes the reader is familiar with the details of Earley s algorithm. The \nPolynomial Time Pattern Matching Algorithm (PTPMA): 1) the states of Earley are augmented so that for \neach immediate value variable x in the pat tern there are 4 additional components LX,RX, Ix and S The \ncomponents LX,RX and Ix x are integers (whose range is bounded by the length of the subject string) and \nSx is a push down stack of integers (whose maximum depth is the maximum depth of nesting of imme\u00addiate \nassignments to x and whose elements are bounded in size by the length of the sub ject string). 2) the \nsets of states (i.e., Si) are manipulated as in Earley s algorithm with the following additions : (a) \nwhen immediate assignment to x is to take place, the value of x is a sub string of the subject string \nand is re\u00adcorded as L and R the left and x x right indices of this substring (with exceptional values \ndesignating reference to the initial value); (b) while an immediate value variable x is being processed, \nthe characters of its value are compared to the subject string and the index I tracks the progress of \n x the processing through this value; (c) as left most positions of (nested) imme diate assignment to \nx are encountered they are stacked in Sx, at the time of assignment the top value is used for L  x and \npopped . 3) in addition the algoritlnn maintains sets of complement states. The complement states have \n224 all of the components mentioned above for (ordinary) states plus a component to record the starting \nindex in the subject string of a substring that can be derived from a comple\u00admented variable and a flag \nthat records comple\u00adtion of the variable. 4) the algorithm also manipulates sets of comple\u00adment states \n(Ni) in the following manner: (a) when the predictor encounters a comple\u00ad mented variable, it adds a \ncomplement state to N. with i and the appropriate1 flag added; (b) after each of the states in Si have \nbeen processed, the complement states in Ni are processed by a completer for comple\u00adment. Basically if \na variable did not complete, then its complement did and another state may be added to Si. 5) some other \ntechnical changes are required in the processors described by Earley that are not discussed here. The \nfirst result we mention for the algorithm reinforces the importance of the formal model.. Theorem (correctness). \nFor any canonical pattern definition system P, the PTPMA applied to P with subject string s gives SUCCESS \nif and only if sCL(P). Proof omitted. Given a formal justification of correctness, we turn our attention \nto performance. Theorem. Given a canonical pattern definition sys\u00ad tem P, there is a constant kp so that \nfor any subject string of length n, the operating time of ~ *n3m(d+2)+c+3 PTPMA is bounded by ~ where \nm , is the number of immediate assignment variables, d is the maximum depth of nesting of immediate \nassignment to a variable, and 1, if 7occurs in P ~= o, otherwise. { Proof omitted. Several special cases \nare of note in the above result. If neither complement nor immediate value assignment is used, then c=m= \nO and performance is cubic. If only complement is used the perform\u00adance is quartic. However for immediate \nvalue assignment both the number of variables and the depth of assignment nesting play dominant roles \nand a very large value for either badly deteriorates performance (though, of course, it is always poly\u00adnomial). \nAnticipating that the reader may feel uneasy due to the omission of so many details, we would like to \nclose by pointing out that in addition to having fully developed the definitions and proofs alluded \nto here, the authors have produced (and extensively tested) an implementation of the algo\u00adrithm outlined \nhere. A report of some of the experience with this implementation (and other details) is given in Liu \n[1977]. REFERENCES R.B.K. Dewar &#38; A.P. McCann [1977], Macro SPITBOL\u00ada SNOBOL4 Compiler, Software-Pratt. \nand ~. , vol. 1, 95-113. J. Earley [1970], An efficient context-free pars\u00ading algoritlun, Comm. ~, Vol. \n13, No. 2, 9b\u00ad 102. A.C. Fleck [1978], Formal models for string pat\u00ad terns, in Current Trends in Program \nming Method\u00ad ology vol. 4: Data =u~ng (R. Yeh, e~ Prentice-Hall. J.F. Gimpel [1973], A theory of discrete \npatterns and their implementation in SNOBOL~, Comm. ~, Vol. 16, No. 2, 91-100. R.E. Griswold [1972], \nThe Macro Implementation of SNOBOL4, W.H. Freeman Co.  R.E. Griswold, J.F. Poage &#38; I.P. Polansky \n[1972], The SNOBOL4 Progrming Language (2nd cd.), Prentice-Hall. K.C. Liu [1977], An efficient algorithm \nfor string pattern matching, doctoral thesis, Computer Science Dept., University of Iowa. L.Y. Liu and \nP. Weiner [1973], An infinite hier\u00adarchy of intersections of context-free lan\u00adguages, Math. Sys. Theory, \n7, 2, 185-192. G.D. Ripley &#38; R.E. Griswold [1975], The measure\u00adment of SNOBOL4 programs, SIGPLAN \nNotices, Vol. 10, No. 5, 36-53. G.F. Stewart [1975], An algebraic model for string patterns, ACM 2nd \nSymp. on Principles of Pro\u00adgramming Languages, Palo Alto, Calif., 167-184. W.M. Waite [1973], Implementing \nSoftware for Non\u00adnumeric Applications, Prentice-Hall. \n\t\t\t", "proc_id": "567752", "abstract": "There is a wide range of applications for string processing and SNOBOL4 (Griswold, et al. [1971]) has come to be the most widely implemented and accepted language for such applications. No doubt one of the principle reasons for this acceptance is the data structure around which the language is organized, the string pattern. This structure together with the associated pattern matching process provide great flexibility. Nevertheless it has been widely recognized in informal terms that the pattern matching process is often grossly inefficient (Ripley & Griswold [1975], Dewar & McCann [1977]) and that the pattern structure is notoriously difficult to explain and use (Ripley & Griswold [1975], Stewart [1975]). Each of these areas of difficulty relates to such things as two modes of operation (quick-full scan), problems with left-recursion, heuristics in the scan, etc. Some difficulties are inherent with string patterns but many are not; we feel the developments described here help to clarify this situation.In section 2 we describe the formal model upon which we base this work. This allows the careful analysis of the variety of sets of strings which may be specified by the patterns which we admit and deduction to be made concerning the possibility/impossibility of algorithms of interest. With SNOBOL4 it has been the case that the careful definition of the \"meaning\" of a pattern is in terms of the actions taken by the pattern matching algorithm. This has led to the incorporation of idiosyncrasies of a particular algorithm into the understanding of the pattern structure. This seems akin to using a compiler as the definition of a programming language and we believe it is important to future progress to have other alternatives.In section 3 we point out that the worst-case execution time of the usual SNOBOL pattern matching algorithm is exponential in the length of the subject string, even on some quite simple patterns. We then present an algorithm whose worst-case time is polynomial and that operates on patterns which include a true set complement operator. As side benefits we find that the algorithm is not multi-modal and correctly handles the null string as an alternative and left-recursion.In order to conserve space we will assume throughout this paper that the reader is familiar with the idea of a string pattern in the sense that it is described in Griswold et al. [1971]. Also it is probably necessary that the reader have some general knowledge of the formal languages area.", "authors": [{"name": "K. C. Liu", "author_profile_id": "81540900556", "affiliation": "University of Wisconsin---Milwaukee", "person_id": "PP309750000", "email_address": "", "orcid_id": ""}, {"name": "A. C. Fleck", "author_profile_id": "81100014013", "affiliation": "The University of Iowa", "person_id": "P3810", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/567752.567773", "year": "1979", "article_id": "567773", "conference": "POPL", "title": "String pattern matching in polynomial time", "url": "http://dl.acm.org/citation.cfm?id=567773"}