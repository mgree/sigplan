{"article_publication_date": "01-01-1979", "fulltext": "\n Permission to make digital or hard copies of part or all of this work or personal or classroom use is \ngranted without fee provided that copies are not made or distributed for profit or commercial advantage \nand that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, \nto post on servers, or to redistribute to lists, requires prior specific permission and/or a fee.&#38;#169; \n1979 ACM 0-12345-678-9 $5.00 ?_Jniversality of Data Retrieval Languages Alfred V. Aho Bell Laboratories \n Murray Hill, New Jersey and Jeffrey D. UllmanT Princeton Unwers@ Princeton, New Jersey Abstract. We \nconsider the question of how powerful a relational query language should be and state two principles \nthat we feel any query language should satisfy. We show that although relational algebra and relational \ncalculus satisfy these principles, there are certain queries involving least fixed points that cannot \nbe expressed by these languages, yet that also satisfy the principles. We then consider various extensions \nof relational algebra to enable it to answer such queries. Finally, we discuss our extensions to relational \nalgebra in terms of a new programming language oriented model for queries 1. Introduction benefits, such \nas simplifying the optimization of both the computational and the query operations. We therefore postulate \ntwo principles that a queryOne facility provided by a database system is a query, or language should \nobey. In essence, these principles statedata maruptdation, language whose primary function is the (1) \nthat the value produced by a query should be in\u00adextraction of information from the database. The data \nre\u00addependent of the manner in which the data are actuallytrieved by a single query can range from a small \nsimple stored in a database and (2) that a query language shouldsubset of the database, as in <print \nthe name and address treat data values as essentially uninterpreted objects,of the employee with employee \nnumber 12345, to a although certain properties, such as a linear ordering onlarge complex subset, as \nin print the names of all em\u00adcertain domains can be built into the query language. ployees under 40 whose \nlast three raises have been above These principles are defined more formally in Section 2. average. \nA query will be treated as a mapping on the The relational algebra and calculus of Codd [C 11 satisfy \ncontents of the database, which we here regard as a col\u00adthese principles and are often used as models \nof a query lection of relations [Cl 1. The value returned by a query language. One purpose for which \nCodd introduced thesewill also be a relation, that is, a set of k -tuples for some languages was to provide \na yardstick for measuring the re\u00adk>l. lative power of query languages. One key question concerning query \nlanguages is what There is, however, an important family of least fixed power they should have. For \nexample, should a query point operations that still satisfy our principles but yet language be able to \nspecify any mapping whatsoever from cannot be expressed in relational algebra or calculus. lists of relations \nto relations? It is our point of view, and Such fixed point operations arise naturally in a variety of \none held widely, that a query language should provide common database applications. In an airline reservations \nphysical data independence; that is, the result of a query system, for example, one may wish to determine \nthe should not depend on the representation of the data. We number of possible flights between two cities \nduring a also feel that the role of a query language should be pri\u00adgiven time period. In a network analysis \nsystem, one may marily the selection of data from a database, rather than wish to determine whether there \nis an active circuit con\u00ad arithmetic computation on this data. The computational necting two points. \nIn a business management system, capability, if desired, should be separate from the retrieval one may \nwish to determine the lowest-level manager capability. This separation of function has a number of common \nto a group of employees. None of these queries can be couched in relational algebra. In the appendix, \nwe t Work partially supported by NSF grant MCS-76-15255 give a formal proof that the transitive closure \nof a binary e relation, an elementary example of a least fixed point operation, cannot be expressed in \nrelational calculus. In Sections 4 and 5 we consider extensions to relational algebra to enable queries \nsuch as these to be expressed. In Section 6 we discuss various methods by which rela\u00adtional algebra expressions \ncontaining least fixed point operators can be efficiently implemented. Finally, in Section 7 we examine \nthe universality of our extensions in terms of a new, stylized programming language that is intended \nto serve as a model of computa\u00adtion for query languages. We show that the programming language is at \nleast as powerful as relational algebra with a least fixed point operator. We also show that Codd s ori\u00adginal \nformulation of relational algebra is equivalent to this language with a restrictive interpretation of \nthe semantics of the for statement in this language. 2. Two Principles for Data Retrieval Languages The \ngeneral consensus is that, at least for query languages based on the relational model, one does not wish \nto have general Turing machine (see [HU], e.g.) capabilities. In particular, one wants the query language \nto be sufficiently high level that it deals with relations as sets of tuples, meaning that the order \nin which the tuples are considered should not influence the result. In this sense, the Turing machine \nworking on an input tape con\u00adtaining lists of tuples is too powerful a model. This is the basis of the \nfirst of our two principles regarding what pro\u00adperties a relational query language should have. Pr/nciple \n2. The result of a function on relations should depend only on the values of the relations as sets of \ntu\u00adpies. The result should not depend on the order in which the tuples are stored. Our formalization \nof the second principle is related to an idea used independently by Paredaenn[P] and Bancilhon [B] to \ncharacterize certain aspects of relational queries. Their idea is that queries should preserve symmetries \nthat exist among the values that appear in argument relations. More formally, assume D is the domain \nfrom which all values for the components of relations are taken. Let K be a 1-1 mapping of D into itself. \n(D is presumably infinite.) Call ~ a renaming. If f is a function that takes n relations as arguments, \nwe say f commutes with K if p(f(rl, . . . ,r. )) = f(~(rl), . . . ,w(r.)). Let us call f an acceptable \nque~ if f commutes with every renaming. In this sense, operations like the union or Cartesian pro\u00ad duct \nof relations are acceptable; so is the transitive clo\u00ad sure of a binary relation. There are, however, \nother queries we might well regard as acceptable that do not commute with arbitrary renam\u00adings. For example, \nprint the name of the employee with employee number 12345 does not commute with renam\u00adings that do not \nmap 12345 to itself. Saying that the renaming should also apply to 12345 in the query skirts the issue \nthat we are concerned with a class of abstract functions on relations, and such functions need not have \na concrete representation where a specially treated con\u00adstant like 12345 is explicitly named. Another \nproblem comes up when we want to use a relationship like <, as in AGE < 40. We would not expect such \na function to commute with those renamings that did not preserve the < order on D. Paredaeos. We thus \nextend the Bancilhon-cconcept in the following way. We postulate the existence of a collection of medicates \nP on the domain D. These could be anv sort of predicates; for example, a unary predicate like x = 12345 \nor a binary predicate like X <. y. Intuitively, one might expect that a function f uses some finite sub\u00adset \nof the available predicates in P to (extract or select in\u00adformation from its argument relations. We would \nnot, therefore, expect that ~ would commute with renamings that did not preserve the predicates. We say \np preserves predicate p (xl, . . . , x.) if F.L(P(X1, . . . ,Xn)) is true if and only if P(p(xl), . . \n., P(xn)) is true. For example, if p is x = 12345 , then p preserves p if and only if it maps 12345 (and \ntherefore no other value) to 12345. K preserves < if P(x) <K(y) if and cmly if x <y. We can now state \nour second principle formally. Principle 2. A function f is allowable with respect to a set of predicates \nP on domain D if anld only if there is a finite subset PI C P such that f commutes with every renaming \nthat preserves the predicates in PI. In what follows, we shall always talk as though D were a set containing \nintegers, reals, and character strings, with < defined in the obvious manner when applied to values of \nthe same type. We shall also take the set of predicates P to be boolean combinations of statements of \nthe form x < y and x = c, for some constant c in D. The ideas extend to other sets of predicates, although \nif we use too rich a set, such as x+-y=z and UXV=W, we can with a finite set of predicates PI assure \nthat only the identity mapping preserves PI, thus making every f allowable. We shall not take ii position \non the correct set of underlying predicates, but we shall take the two principles above as a definition \nof what properties a complete query language should have, relative to a given set of built-in predicates \nP. Codd s relational algebra [Cl] is often used as a model of a query language, that is, as a minimal \nset of opera\u00adtions that every query language should have. We shall describe relational algebra in the \nnext section, whereupon it will be obvious that all queries posable in relational algebra satisfy the \ntwo principles above, if the allowable predicates are taken to be x < y and x = c for all con\u00adstants \nc. 3. Relational Algebra In this section we shall define a set of relational algebra expressions that \nis complete for relational calculus, which is the first order theory of relations arid tuples with com\u00adparison \noperators = and < on components of tuples [C2]. The operands of an expression are either constant unary \nrelations or variables representing relations. The operators of an expression are the following: (1) \nCartesian Product. If R and S are relations consist\u00ading of r -tuples and s -tuples, respectively, then \nR x S is the set of (r+s) -tupkx of which the first r components are an r -tuple in R and the last s \ncomponents are an There is a stronger condition called add[tnwy, expressed s -tuple in S. by (2) Set \nUnion. If R and S are relations whose tuples are of the same length, then R U S is the union of the tuples \nin R and S. (3) Set Dl~erence. If R and S are reIations whose tu\u00adples are of the same length, then R \n S is the set of tu\u00adples that are in R but not in S. (4) Selection. Let F be a predicate built from \n (i) the logical operators: and (A), or (V), not (-), (ii) the arithmetic relational operators: =,<, \n>, G,>,+,and  (iii) operands of the form $i standing for the i h com\u00ad ponent of a tuple. Then UF (R \n) = {t I for some tuple t in R, F becomes true when $ i is replaced by the i h component of t}. (5) Projection. \n7T$,1,$,Z,.. ,$1~ (R) ={ t I for some t in R, t is the k -tuple whose jth component is the ~h com\u00adponent \nof t}. We assume /1,/2, . . . , ik have no repeti\u00adtions (although this constraint is not essential), \nand the ~ s are not assumed to be in any particular order. All expressions in relational algebra produce \nrelations as values, when given relations as arguments. Moreover, the value of an expression cannot involve \na symbol in a tuple if that symbol was not part of some tuple of some argument relation. Therefore, if \nthe operands in a rela\u00adtional expression are all finite relations, then the value of the expression is \nalso a finite relation. Example 1. Let R = {012, 121, 001].t Then UN<W. (R) = {012,121}, and TrW,S1(R) \n= {20,11,10}. As another example, we can define the composition of two binary (two-component) relations \nR and S by R 0 S = m$l,$4(U$2=$3 (R x S)). This shorthand will be used subsequently. D 4. The Least Fixed \nPoint Operator Consider an equation of the form R =f(R) (1) where f(R) is a relational algebra expression \nwith operand R, perhaps among other operands, such that the degree (i.e., the number of components in \neach tuple) of R and f(R) are the same. A least fixed pojnt of equation (l), denoted LFP(R = f(R)), is \na relation R* such that (i) R* = f(R*) and (ii) If R is any relation such that R = f(R), then R*c R. \n In general, there may not be any R * satisfying (i) or any satisfying (ii). However, Tarski [T] assures \nus that a unique least fixed point exists if f is monotone, which in the context of the partial order \nC on relations means that if RI G R2, then f(R1) C f(R2) (2) or equivalently f(RI U R2) = f(Rl) U f(R2) \n(3) T Throughout, we shall indicate a tuple such as (0,1 ,2) by the se\u00adquence 012 f(Rl U ~2) = f(Rl) \nU f(RJ (4) Obviously (4) implies (3), so every additive f is mono\u00adtone. If f is monotone, then by induction \non i we can show that f - (0) c f (0) where f is f applied i times. If all argument relations are finite, \nthen since no new component values are intro\u00adduced by the relational algebra operators, we know that \nthere is some finite relation of which each f (0) is a sub\u00adset. Therefore, there must be some no such \nthat 0 ~ f (0) .$ fz(a) > . . . ~ fno(a) = f o+ (a) (5) We shall use the term lim f (0) n-~ for fnO(0). \nIt is easy to check that f 0(0) is a fixed point of R. An induction on i shows that f (0) is contained \nin any fixed point of equation (1). Therefore lim f n (0) is the n-\u00adleast fixed point of (l). Example \n2. The transitive closure of a binary relation R. is the least fixed point of R= ROROURO If we let f(R) \n= R ORO tJ Ro, then fl(0)= ~Roo RoO . . . ORO (i times) ,=1 as may be proved by an easy induction on \nn. Thus by (5), the least fixed point of R = .f(R ) is what we nor\u00admally call the transitive closure, \nthat is, ~ ROOROO . . . ORO (i times) ,=1 Example 3. Suppose we have a database representing airline \nflights, containing the relation FLIGHTS(SOURCE, DEST, D_TIME, A_TIME) where SOURCE and DEST indicate \nthe source and desti\u00adnation cities; D_TIME and A_TIME indicate the depar\u00adture and arrival times. We might \nwish to compute a rela\u00adtion FLIGHTS* with the same four components that in\u00adcludes FLIGHTS and, in addition, \nrepresents all finite se\u00ad quences of flights such that in each sequence (i) the destination of each flight \n(except the last) is the source of the next, and (ii) the arrival time of each flight (except the last) \noc\u00ad  curs before the departure time of the next. We could express this relation as the least fixed point \nof the equation FLIGHTS* = FLIGHTS U $1,$6,$3.$8 h2=$5 md $4<$7@L1GHTS x FLIGHTS*)) (6) Note that when \nwe treat (6) as an equation of the form R =f(R), then ~(n) is FLIGHTS U ~$,,$fj,$~,$g(~$zn$~,n~ $4<$7(FL1GHTS \nx R )) and FLIGHTS is an operand that is presumed to be a constant as far as the taking of a fixed point \nis concerned. D The following theorem is easy to prove by induction on the number of operators in a relational \nexpression. Theorem 1. Any relational algebra expression that does not use the set difference operator \nis additive in all its variables. D On the other hand, a nonmonotone expression can have a least fixed \npoint and not every expression involv\u00ading the difference operator fails to be monotone. 5. Embedding \nthe Least Fixed Point Operator in a Query Language The problem of how to incorporate a least fixed point \n(LFP) operator into a query language in a useful manner is not trivial. To begin, it may be hard just \nto determine whether the LFP of an equation exists, let alone to visu\u00adalize what it is. Also, evaluating \na LFP in a straightfor\u00adward way may be computationally infeasible unless some advantage is taken of the \nsparseness of a relation or the special nature of the expression involved. In this section, we propose \nthree syntactic mechanisms whereby the LFP operator can be made available to a query language modeled \nafter relational algebra. (1) Provide specialized operators such as * (reflexive\u00ad and-transitive closure) \nor + (transitive closure) that can be applied to certain relations. Such shorthands are clear\u00adly useful, \nbut they do not provide us with the versatility of the LFP operator; witness Example 2. Standard methods \nfor computing the transitive closure [AHUI will probably be prohibitively expensive unless they take \ninto consideration the likely sparseness of a re\u00adlation: Recently, an algorithm for transitive closure \nthat is optimal in an expected time sense has been given [S1. A facility to define transitive closures \n(but not general LFP s) is available in Query-by-Example [Z]. (2) Provide a syntactically sugared way \nof saying let S be the LFP of R = f(R), where f is an expression in relational algebra, perhaps with \nother fixed point opera\u00adtors. In essence, here we are proposing that the user be able to write down an \nequation that his desilred relation satisfies, but no smaller relation satisfies. If he does so, and \nhis intuition is correct, R = f(R) will have a LFP. If f is monotone, the LFP can be computed using (5), \nwhere, as we have mentioned, only a finite number of terms need be taken before we obtain the limit; \nthere is, however, no a priori upper bound on the number of terms to be taken. (3) Provide a procedural \nmethod of constructing a re\u00adlation R inductively. That is, we provide a basis rule that says R. G R for \nsome relation Ro, which may be an alge\u00adbraic expression of existing relations. We then provide an inductive \nrule that says g (1?) G R, where g is some function of R, expressed in relational algebra, that has as \nvalue a relation with the same degree as R. By implica\u00adtion, we assume an exclusion clause saying that \nnothing is  in R unless it follows from the basis and induction rules. We might express such a procedure \nin terms of a simple while-loop: R+RO do R +R R -- R u g(R) while (R # R) Now the value of R can be computed \nas the limit of the sequence Xo, Xl, . . . . where X. = R. and T = g(&#38;l) U -K-I for i>l. If g is \nmonotone, and f (R) = RO U g(R) U R, then f is also monotone, and X, G f +1(0) G X,+1 for all i > 0, \nas an easy induc\u00adtion on i shows. As the limit of f n (0) exists, the limit of X. exists, and the limits \nare the same. Conversely, if f is monotone, then the LFP of R = f(R) can be expressed by giving the basis \nrule: @ G R and the induction rule f(R) G R. As f -1(0) C f (0) follows from monotonicity and induc\u00adtion \non i, we see that Jf, = f (0). Therefore, for mono\u00adtone functions, methocis (2) and (3) are equivalent \nin their ability to define relations. However, method (3) has the additional advantage that the limit \nIim X, is known to ~.-CO exist independent of whether g is monotone, since when g is a relational algebra \nexpression, there are only a finite number of symbols that can appear in the tuples of any X,, and XoGX1CX2C \n. . . . 6. Optimization of Queries with the LFP Operator The mechanical optimization of queries that \nis possible when the operators are union, selection, projection, and Cartesian product [CM., ASU, SYI \ndoes not seem to be available when the LFP operator is included. A next\u00adbest alternative is to develop \ncommutation laws for the LFP operator, similar to those developed for other rela\u00adtional operators by \n[SC]. Most important is a method for evaluating selections ahead of LFP operators. For exam\u00adple, this \nchange can convert a general transitive closure problem into a single source shortest path problem. We \nshall present a method for commuting selections over a LFP operation, provided that in the expression \nLFP(R = f(R)) the function f is such that it has only one instance of R. There are certain restrictions \non the form of the selection as well, since selection does not commute with Cartesian product, in gerieral. \nWe also as\u00adsume either that f is monotone, or that the semantics of the LFP operator are such that the \nlimit of the series (5) is what is wanted. Let us begin with an example that will introduce the general \nmethod. Example 5. The transitive closure ojf a relation R. is LFP(R = R o R. IJ R(,). If we want to \nknow the points accessible from a given point ao, we could write U$l..o (LFP(R = R o R. (J Ro)). However, \ncomputing the desired relation S = {aob ] aob is in RJ ) requires that we first compute J?$, an operation \nthat is far more expensive than we need. Our goal is to., in a sense, move U$I=.O inside the LFP operator, \nso S can be computed directly. Our approach is to replace the expression CW.O(LFP(R = R ORO U RJ by its \ninfinite expansion U$,=ao(((((  )oRo)URO)ORO)URO) (7) obtained by repeatedly replacing R by R o R. U \nRo. Ex\u00adpression (7) has the form U$l=.O(X U Ro). Since selec\u00adtion distributes across union, we can rewrite \n(7) as a$l=ao(x) u U$,=.O(RO) (8) where expression X has the form Y o Ro, and Y= (((((... ) ORO) URO) \nORO) URO) We would now like to distribute the selection operator across the composition, but we may not \ndo this in gen\u00aderal. If the selection involves only the first or second ar\u00adgument of the composition, \nhowever, then it is possible to move the selection through the composition operator. Since cr$l=~o involves \nonly the first argument here, we can replace (8) by W$l=do( Y) o RO U W=.O(RO) (9) We now note that a$l=ao( \nY) looks exactly like (7), our original expression. If we use E to denote the value of (7), we obtain \nthe following fixed point equation for E E = E ORO U U$I.GO(RO) (lo) The value of equation (10) can be \ncomputed relatively efficiently by expanding according to (5). Note that we never put into T any tuple \nab with a # ao. D The above example works because several conditions hold. (1) The function f(R) = R \no RO U RO is monotone, so the infinite expansion makes sense, and the con\u00adstructed function (1O) is \nalso monotone. (2) We are able to distribute the selection operator through every subexpression of C7). \n (3) We obtain a subexpression which has the same form as our original expression.  Condition (3) turns \nout to hold without loss of general\u00adity, providedthat (2) holds. This follows from the faCt that the \nselection cannot change substantially as it is dis\u00adtributed; it can only apply to different components \nor disappear entirely. Thus only a finite number of selec\u00adtions are ever applied to the various subexpressions. \nWe can now state our general algorithm for taking an expression of the form a~ (LFP(R = f(R))), where \nf(R) has only one occurrence of R, and is monotone, and converting it to a particular expression h (LFP \n(S=g (S))). The work involved in computing the latter expression is of no greater order than that to \ncom\u00adpute the former, and in some circumstances will be an order of magnitude less. Algorithm 1. Distribution \nof selection through the LFP operator. Input. An expression UF (LFP (R = f(R))) where f(R) has only one \noccurrence of R and is monotone. Ouiput An equivalent expression h(LFP(S = g(~))). Method We construct \na sequence of expressions Eo, El, ..., each with one occurrence of the operand R, by the following rules. \nBasis. EO is UF(R). Induction. Suppose we have constructed E,. If E, has a subexpression of the form \nUC(R), then in E, replace WC(R) by UC (.f (R )). Since f(R) has one occurrence of R, the resulting expression \nwill also have one occurrence of R. We now attempt to distribute the selection operator through f(R) \nas far as possible using the following iden\u00adtities. (1) If UC is applied to YX Z, the following rules \napply. (i) uc(yx.z) = (~~(y))xz if ~C applies only to components that come from Y. (ii) UG ( Yxz) = \nyxa~f(z) if UC applies only to components from Z. G is G with the component numbers adjusted appropriately. \n (iii) If neither Y nor Z by itself includes all com\u00adponents mentioned in G, we cannot distribute the \nselection through the Cartesian product. (2) cr~(Y lJ z) =0-G(Y) u a.(z) (3)UG (Y-Z)=U~(Y)-mC(Z) (4) \nUG(UH(Y)) = crH(wG(Y))T (5) mG(n~ (Y)) = ~L(~G(Y)) where G is G with component numbers adjusted appropriately. \n As a special case, if the selection is not distributed to the subexpression of f(R) that contains R, \nthen apply the trivial selection that is satisfied by every tuple to that subexpression. This is done \nfor convenience, to ensure some selection will eventually reach the argument R. Expression E,+l results \nfrom applying these rules as far as possible. We continue the induction with E,+l in place of E, except \nin two cases. (1) If we are unable to pass a selection through a Cartesian product of terms, one of which \ninvolves the ar\u00adgument R, then we fail to commute OF with the LFP operator. (2) If E,+, is of the form \nh (g( mF(R))) and for some .j < /, E, is of the form h (UF(R )), then we have found g and h. From E,+l \nwe construct the expression h(LFP(S = g(S))).  Theorem 2. If f is monotone, Algorithm 1 succeeds in \nproducing an equivalent expression h (LFP(S = g(S))). If no relation appearing as an operand in f, or \nas the result of evaluating a subexpression of f is empty, then the time to evaluate h (LFP (S=g (S)) \nis no greater than a constant times that needed to evaluate m~ (R =f (R )) (and in general may be much \nless). Some Extensions The same technique as described above for selections can also be used to distribute \nsome projections into a LFP operator. In fact, projections always pass through a Cartesian product, so \nthere is no risk of failure from that t We could combine the two selections, but we assume selections \nwithin f have been distributed as much as possible, and to com\u00adbine selections here may make it impossible \nto pass our selection through a Cartesian product. source. We may also generalize what we have done to \nLFP operators that simultaneously define several rela\u00adtions. 7. Toward an Improved Model fora Relational \nQuery Language In this section we define a language that we feel can serve as a model of computation \nfor relational database retrieval operations. The language obeys the principles specified in Section \n2 and has the ability to: (1) Create new tuples from given tuples by selecting certain components from \nthe given tuples and arranging them in some order. (2) Create new relations. (3) Copy relations. (4) \nIterate over all tuples of a relation in an unspecified order. (5) Make tests based on some property \nof a given tu\u00adple, provided that property involves only arithmetic com\u00ad  parisons among components of \nthe tuple and, perhaps, constants. (6) Make tests based onthemembership ofatuple ina relation. Although \nwe cannot prove that we have found the maximal class of queries that respect the two principles of Section \n2, we nevertheless feel that our language serves as one natural benchmark against which other notations \nforoperating onrelations can reevaluated, inexactly the same way that relational calculus serves as a \nbenchmark. Under one natural interpretation of the iteration state\u00adment our language is equivalent to \nrelation calculus or algebra; under another more general interpretation it is at least as powerful asrelational \nalgebra with the fixed point operator, and we conjecture that it is strictly more power\u00adful. A Language \nfor Data Retrieval We now define our data retrieval language, The state\u00adments of the language are as \nfollows. (1) t+y(t,, . . ..tn) Here tand t,are tuple-valued variables and~ is a func\u00adtion that produces \nfrom tuples tl,...,tna particular tu\u00adple t,l(.h)c,2(j2) . . C,k(jk), where t,(j) is the jth com\u00ad ponent \noftuple t,. (2) insert(t, R)anddelete(t, R) Here, tisatuple variable andl? a relation variable. (3) \nR-S R is a relation variable and S is a relational variable or constant. (4) fortin R do <statement> \nHere tis a tuple variable whose scope is local to the for statement and R isa relation variable. Any \ntuple variable assigned within the for statement is assumed local to that for statement. We shall see \nthat the precise semantics of the for statement determines the class of functions definable in the language. \n (5) ifp(t)then <statement> [else <statement>] Here t is a tuple variable andp is a predicate built from \nthe arithmetic comparison operators and the logical con\u00ad  nective (and, or, not). (6) iftin R then <statement> \n[else <statement>] Again, tisatuple variableandR a relation variable. (7) begin <statement list> end \n (8) localt This statement defines a tuple varialble twhose scope is local to the begin-end block in \nwhich this define satement is contained.  A program in this language is a statement, which can be a \nbegin-end block. The input to a program is the set of relation variables in the program that are referenced \nbut not previously defined. One relation variable is desig\u00adnated as being the (output relation variable. \nThus a pro\u00adgram computes a function whose arguments are the input relation variables and whose value \nis that of the output relation variable. We assume that for each relation variable there is a fixed degree, \nand all tuples in the relation have this number of components. We also a:wume that there is a fixed arity \nfor each tuple variable. Finally, we assume each component of each relation is selected from a known \nfinite domain for th~lt component. The Four Interpretations of the for Statement The semantics of lthe \nfor statement for tin R do <statement> can be defined in ssveral different ways. There are two orthogonal \nissues. The <statement:> should be executed for each tuple of R. But should the execution be in parallel, \nor should we iterate over leach tin R serially? The second issue is, should the value of R be bound on \nentry to the for loop, or should it be allowed to change within the loop? In each case we get a diflerent \nclass of functions. Let us consider the four interpretations and the resulting classes of functions in \nturn. 7.1. R Bound Before the Loop; Parallel Execution In this interpretation we associate with each \ntuple vari\u00adable a set of tuples. The following rules are used to inter\u00adpret the statements: (1) t+.f(t,,...,tn).Assign \nto t the set of tuples formed by taking one tuple in each set for t,,1<i< n and applying f to those tuples. \nFor example, if the assign\u00adment is t+ tlt2(juxtaposition of tuples denotes concate\u00adnation), then the \nset for tis the Cartesian product of the sets for tland t2. (2) insert(t, R) and delete(r, R ) are executed \nby set\u00adting R to R U T ;and R T, respectively, where T is the set of tuples associated with t. (3) \nR -S has the obvious meaning and does not affe~t the sets associated with tuple variables. (4) for tinR \ndo <statement > The set associated with tis R at the beginning of <state\u00adment >. The tuple variable t \nis local to the for statement. (5) if p(t) then <statement 1> [else <statement2 >1 Let T be the set \nassociated with the tuple variable tbe\u00adfore the if statement. Let T be the set {.s I s is in T and p(s) \n). Within <statement 1>, set T is associated with tuple variable t and within < statement2 >, if it is \n 115 present, T T is associated with t. After the if state\u00adment T is again associated with t,even if \nat that time the union of the two sets associated with t is not T. Note that we in effect define a new \ntlocal to the if statement. (6) if tinR then <statement> [else <statement2 >1 The meaning of this statement \nis similar to (5) with T;= T R. (7) begin <statement >; <statement > end Any changes to the set associated \nwith a tuple variable lo\u00adcal to the block made by <statement i > carry over to the next statement, unless \nthe rule for <statement i > causes the value for that variable to be changed (as in (1)). Example 6. \nConsider the program in Fig. 5, which com\u00adputes T= RoS. Suppose R = {ab, ac, bc} and S = {aa, cb ] initially. \nAfter statement t+ rs the sets as\u00adsociated with t,r and s are {abaa, abcb, acaa, accb, bcaa, bccb], {ah, \nac, be}, and {aa, cb}, respectively. The state\u00adment insert (u, T) sets T to {ab, bb), which is R oS. \nD begin T-a; for sin Sdo for rin Rdo begin local u; t+-rs; if t(2) = t(3) then begin u + t(1) t(4); insert \n(u, T) end end end Fig. 5. Program to compute composition. Theorem 3. The set of functions computable \nby pro\u00adgrams with tbound to the current value of R in for T in R do and parallel interpretation of for \nloops is coexten\u00adsive with the functions computed by relational algebra ex\u00adpressions. 7.2. R Not Bound \nBefore the Loop; Parallel Execution There is the possibility that R changes within a for loop, and if \nso, we might wish to consider the possibility that the set associated with t in the loop for tin R do \nchanges as R changes. One way to effect such changes might be to modify the set associated with t after \nan as\u00adsignment, insertion or deletion to R within the loop. It is not hard to show that such an interpretation \ndoes not add to the capability of the language to produce new func\u00adtions; the language is still equivalent \nto relational algebra. A second interpretation is to fix the set associated with t,but to repeat the \nfor loop with tassociated with the set of tuples added to R at the previous repetition, until at some \npoint no new tuples are added to R. Let us call this interpretation the iterative-parallel interpretation \nof pro\u00adgrams. Theorem 4. Every function expressible by the basis\u00ad induction method (method 3) of specifying \nfixed points can be computed under the iterative-parallel interpreta\u00ad tion. 7.3. Serial Execution Let \nus now consider interpretations of for t in R do <statement > that select an arbitrary ordering for the \nmembers of R and execute the <statement> once for each value of t.We may either fix the set of t s before \nentering the loop or we may allow the set to adapt to changes in R within the loop. The method of adaptation \ncould be either of those suggested in Section 7.2, or we could at each iteration of the for loop select \na tcurrently in R that has not been selected before. Unlike the iterative-parallel interpretation, this \ninterpretation permits the loop to respond to deletions within the loop. We shall not fix on a serial \ninterpretation with R not bound on entry to the loop because our negative remarks about the serial interpretation \nwith R bound on entry to the loop apply to all these interpretations as well, and our conclusion is that \nserial interpr.etations must be rejected as candidates for universal database languages. Our principal \nobjection to serial interpretations is that they can violate the first principle: order independence. \nIt is easy to construct programs whose output is determined by the order in which tuples in some relation \nare con\u00adsidered. While we do not advocate serial interpretations of our language as candidates for the \nnotion of a universal data manipulation language, we shall state the following theorem which places the \ninterpretation above into per\u00adspect ive. Theorem 5. Every relational algebra expression can be computed \nby a program under the fixed binding, serial in\u00adterpretation. -. Kelerences [AHUI A. V. Aho, J. E. Hopcroft, \nand J. D. Unman, The Design and A nalysls of Computer Algorithms, Addison-Wesley, Reading, Mass., 1974. \n[ASU] A. V. Aho, Y. Sagiv, and J. D. Unman, Equivalences Among Relational Expressions, SIAM J. Computing, \n1978. [B] F. Bancilhon, On the completeness of query languages for relational expressions, Rapport de \nRecherche No. 297, IRIA, Rocquencourt, France, May, 1978. [cl] E. F. Codd, A Relational Model for Large \nShared Data Banks, Comm. ACM 13:6 (June, 1970), 377-387. [C21 E. F. Codd, Relational Completeness of \nData Base Sublanguages, in Data Base Systems (R. Rustin, cd.), Prentice-Hall, Englewood Cliffs, N. J., \n1972, pp. 65-98. , [Ch] A. Church, Introduction to Mathematical Logic, Vol. 1, Princeton University \nPress, 1956. [CM] A. K. Chandra and P. M. Merlin, Optimal im\u00ad plementation of Conjunctive Queries in \nRelational Data Bases, Proc. Ninth A nnua[ A CM Symposium on Theory of Computing, May 1976, pp. 77-90. \n[D] C. J. Date, An introduction to Database Systems, Addison-Wesley, Reading, Mass., 1975. [HUI J. E. \nHopcroft and J. D. Unman, Formal Languages and their Relation to Automata, Addison-Wesley, Reading, Mass., \n1969. [P] J. Paredaerq Information Processing Letters 7:2, 1978. [S1 C. P. Schnorr, An Algorithm for \nTransitive Clo\u00ad sure with Linear Expected Time, SIAM J. Com\u00adputing 7:2 (May, 1978), 127-133. [SC] J. \nM. Smith alnd P. Y.-T. Chang, Optimizing the Performance of a Relational Algebra Database in\u00adterface, \n Comm. ACM 18:1OI (Oct., 1975), 568\u00ad 579. [Syl Y. Sagiv and M. Yannikakis, Equivalence Among Relational \nExpressions with the Union and Difference Operation s, Proc. ACM Interna\u00adtional Conference on Ve~ Large \nData Bases, Sept., 1978. [T] A. Tarski, A Lattice-Theoretical Fixpoint Theorem and its Applications, \nPac/jc J Mathematics 5:2 (June, 1955), 285-309. [Z] M. M. Zloo~, Query-by-Example: a Database Language, \n IBM Syst. J., 16):4 (1977), pp. 324\u00ad 343. Appendix In this appendix. we prove that the transitive \nclosure of a relation cannot be couched as an expression of relation\u00adal algebra.t It is interesting to \nnote that both Bancilhon [B] andParedaena[P] in essence characterize relational alge\u00adbra as equivalent \nto the set of mappings obeying principle 2 with respect to an empty set of predicates. However, transitive \nclosure obeys this principle. There is no con\u00adtradiction. In [B,P] it is shown that for every relation \nr there is a relational algebra expression E such that E (R )= R+, the transitive closure of R. What \nwe show is that for no relational algebra expression E is E(R) =R+ for all r. Theorem 6. For an arbitrary \nbinary relation R, there is no expression E(R) in relational algebra equivalent to R+, the transitive \nclosure of R. Suppose we have an expression E(R) that is the transi\u00adtive closure of R. Let Z/ = (al, \naj, . . . ,al) be aset of 1 arbitrary symbols. Let RI be the finite relation {a~a,, a,a~, . . . . al_l \nal]. RI represents the graph  @+@- -o We shall show that, for any relational expression E, there is \nsome value of 1 for which E (Rl) is not R/+. In particu\u00adlar, we shall show by induction on the number \nof opera\u00adtors in E, that E(R1) can be expressed as {b, b,.. b~ I W(bl, bz, . . . ,b~)} where T is the \nlogical or of clauses; each clause is the logical and of atoms. An atom is a formula b,=c, b,#c, b,= \nbj+corb, # bj+c, where cisa (not necessarily positive) constant, and bj + c is short for that am such \nthat b, = am_ C. The b s are assumed to range over {al, a2, . . . , al], where I is understood. The assertion \nb, = b~ + c says that b, is c nodes down the chain, formed by the graph of R/, from bj. Note that ~ is \nnot precisely a predicate of relational calculus, since the b s have a fixed domain {al, . . . . al]. \nAlso., it should be understood that the al s are abstract objects and may not be ordered by arithmetic \n< (although superficially, RI ap\u00adpears to do this). That is, the expression U$l<$2(n$1 (Rl) x 7r$2(R/)) \ndoes not compute R/+; rather it is meaningless, because U$l <$2 makes no sense when applied to a set \nof pairs of abstract a, s. The following lemma states a useful fact about logical expressions we shall \nmanipulate. Lemma 1. Any logical expression consisting of the logi\u00adcal operators A, V, -, applied to \natoms is equivalent to an expression consisting of clauses separated by or s. (Such an expression is \nsaid to be in disjunctive normal form or DNF) Proof Any expression in propositional calculus [Chl can \nbe written as the disjunction of clauses consisting of the logical and of literak, which are propositional \nvari\u00ad ables or their negation. The lemma follows since the ne- T This claim appears in [D], p. 145, without \nProof or citation. gation of an atom is an atom. D We now prove the characterization of the values that \nE(RI) may take for any relational algebra expression E. Lemma 2. If E is any relational algebra expression, \nthen for sufficiently large 1, E(R,) = {bl ..0 b~ I W(bl, . . . ,~k)} for some k and some DNF expression \nV, where the b, s range over the set {al, az, . . . , al). Proof The proof is an induction on the number \nof operators in E. Basis. Zero operators. Either the operand is R, or a constant relation of degree 1. \nThe relation RI can be ex\u00ad pressed as {bjb2[b2=b1+l} while the constant set {cl, C2, . . . , cm,} can \nbe expressed as {bilbl= cl\\dbl= czV. . Vbl=c~} Note the c, s must be a, s for expression E to make sense. \nZnduction. All but projections are easy. Case1.E=EluEz,El Ej, orElxEz. LetEl have value (bl . . . bk \nI Wl((q  o b~)] and Ez have value {b , ... b~ IW2(b 1 .. b~}. If E= E1UE2, or E = E1 E2, then m == k \nfor E to make sense. The value ofEl U E2is {b, ... b~ I P1(bl, . . . ,b~) v~l(bl, . . . ,b~)). The value \nof E1 E2 is {b, ... bk[Wl(bll, ... ,b~) A-Wj(bl, ... ,bk)]. In this case, T, A - P2 must be transformed \nto DNF, which we know can be done by Lemma 1. The value of El XE2 is {b, . . . b~b l . ~. bj I ~,(bl, \n. . . ,b~) AW,(b ,, . . . ,b:)}. In this case, V, A If2 lmust be transformed into DNF. Case 2. E = cr~(E1). \nLet the value of El be {b, . . . bk I Pl(bl, . . . . bk) ]. If formula F involves an arithmetic comparison \nother than = or #, then E makes no sense, since the a, s are not comparable by <. Thus F involves only \n=, # and logical operators. We may, therefore, express E as {b, ... b~ I Pl(bl, . . .,b~) AF(bl, . ... \nb~)} and put the resulting formula into DNIF. Case 3. E = m, (El). To begin, we can express each projection \nas a cascade of (1) projections that permute the order of components, and (2) projections that eliminate \nthe last component only.  Let El have value [bl  bkI W(bl, ....b~)]. If ~, is a permutation, then the \nvalue of E is easily obtained by permuting bl, . . ., b~ in ~ appropriately. Now consider the case where \nm, projects out b~. The value of El is (bl. . b~_], I (~bk)w(bl, . . . . bk)}. As V is in DNF, we can \nwrite ~=~,v~zv.. V Tm, where each T, is the logical and of atoms. For sufficiently large 1, the value \nof E is substitute into bk = a, b. = b~+d b~ = b.+d aJ true if j=r b~ aj~d bw = a,.~ false if j+r (false \nif d< j) (fake if d>j) b, c b, = a,~C b~ = b,+(d c) b, = bm+(c+d) (false if c < r) b,+c b, = a,_C b~ \n= b,+(c+d) b, ~ b~+(d c) (false If c < r) Fig. 1. Result of substitutions. ~ {b, bk_l \\ (~bk) W,(bl, \n. . . . bk)}. As we can handle unions by Case 1, let us consider only the case where ~ itself is a single \nclause. Subcase 1. There is no atom of the form bk=a,, b,= bk+corbk=b, +cin V. Thenlet Wbe the logical \nand of all the atoms of W that do not involve bk (any such must have the # relation). Then the value \nof E is {bl ... b~ 1IW (bl, ... ,bk-1}. in Proof note that for any fixed tuple bl . bk_l that satisfies \nW, we can pick bk to be al for some 1 sufficiently large that all atomsOfthe fOrmSbk# (ZJ,b, # bk+cOr \nbk# b,+C are true. Thus if bl  . b&#38;l satisfies ~ , it also satisfies (~bk)~(b,, . . . . bk). Conversely, \nif b] ~ . . bk-1 satisfies (3bk)W(b,, . . . ,bk), then surely bl . . . bk_l satisfies all atoms that \ndo not mention bk. Subcase 2. There is some atom bk = aJ, b, = bk + c or bk = b, + c. Substitute for \nbk in all the other atoms of ~ the expression a,, b, c or b, + c, respectively. The result is always \nequivalent to some atom, or a logi\u00adcal constant, which we take to be the result of the substi\u00adtution \nas indicated in Fig. 1. An atom with the value true disappears. A false atom causes the value of E to \nbecome the empty set, which we may represent by {b, . . . bk_l I bl # bl]. If no atom is false, the value \nof E is {bl . . . bk_l I W (b,, . . . . bk-l)}, where ~ COr_tSiStS of the logical and of the following \natoms: (1) The atoms of W modified by the substitution of Fig. 1, (2) In the case bk = b,+c, c >0, was \nthe substituted atom, we add the atoms b, # a,, for l c <j< 1, and (3) In the case bk = b, c, c >0 was \nthe substituted atom, we add the atoms b, # aJ for 1<j< c. D  Now we return to the proof of the theorem. \nSuppose that E(R) = R+ for some expression E and any relation R. Then, for sufficiently large 1, RI+ \ncan be expressed as {blb, \\ W(bl, b2)], where V is in DNF. Case 1. Every clause of ~ has an atom of the \nform bl = a,, bz = a,, or bl = bj +C (or equivalently, b2 = bl c). Consider the pair b1b2 = a~a~+d, and \nwhere m is larger than any i such that bl = a, or b2 = a, is an atom in ~, where d is positive and larger \nin magnitude thananycsuchthat bl=b2+ cisanatomofV. Then bl = am, b2 = a~+d satisfies no clause of ~. \nHowever, for sufficiently large 1, am a~+~ is in R,+ but not in E (Rl), a contradiction. Case 2. Some \nclause of T has only atoms with the # relation. Then consider the pair a~+da~, where no atom b, # am \nor b, # a~+d appears in ~, and d is positive and larger in magnitude than any c such that bl # bz + c \nor b2 # bl + c appears in V. Note that from the construc\u00adtion of W in the case of projections in Lemma \n2 that all atoms b, # aJ added have j either close to zero or close to I, where close means within some \nconstant that depends on E but not on 1. Thus, for sufficiently large 1, a~+da~ is in E (Rl) but not \nin RI+, another contradiction. We conclude that for any E, there is always an 1 for which E(Z$) # R/+. \nD \n\t\t\t", "proc_id": "567752", "abstract": "We consider the question of how powerful a relational query language should be and state two principles that we feel any query language should satisfy. We show that although relational algebra and relational calculus satisfy these principles, there are certain queries involving least fixed points that cannot be expressed by these languages, yet that also satisfy the principles. We then consider various extensions of relational algebra to enable it to answer such queries. Finally, we discuss our extensions to relational algebra in terms of a new programming language oriented model for queries.", "authors": [{"name": "Alfred V. Aho", "author_profile_id": "81100024612", "affiliation": "Bell Laboratories, Murray Hill, New Jersey", "person_id": "PP14021473", "email_address": "", "orcid_id": ""}, {"name": "Jeffrey D. Ullman", "author_profile_id": "81100314798", "affiliation": "Princeton University, Princeton, New Jersey", "person_id": "PP39037330", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/567752.567763", "year": "1979", "article_id": "567763", "conference": "POPL", "title": "Universality of data retrieval languages", "url": "http://dl.acm.org/citation.cfm?id=567763"}