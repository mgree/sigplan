{"article_publication_date": "01-01-1979", "fulltext": "\n Permission to make digital or hard copies of part or all of this work or personal or classroom use is \ngranted without fee provided that copies are not made or distributed for profit or commercial advantage \nand that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, \nto post on servers, or to redistribute to lists, requires prior specific permission and/or a fee.&#38;#169; \n1979 ACM 0-12345-678-9 $5.00 Recursion in Logics of Progrssms David Harel t Laboratory for Computer Science \nMassachusetts Institute of Technology Cambridge, MA 02139 Abstract The problem of reasoning about recursive \nprograms is apparent complications, tend to obscure whatever basic considered. Utlbzing a simple analogy \nbetween iterative and concepts and ideas were involved in the essence of the recursive programs viewed \nas unfimte unions of finite terms, augmentation from regular to context-free reasoning. we carry out \nan investigation analogous to that carried out recently for iterative programs. The main results are \nthe This paper is concerned with the problem of clean reasoning arlthmet!cal completeness of axiom systems \nfor (1) about recursive programs. We establish a very simple analogy context-free dynamic logic and (2) \nIts extension for dealing between iterative and recursive programs and use it to obtain with infinite \ncomflutatiorzs. Having the power of expression of results, similar in spirit to those known for iterative \nones, these Iogics in mind, these results can be seen to supply (as but usually somewhat harder to come \nby. corollaries) complete proof methods for the various kinds of correctness of recursive programs. In \norder to be able to put this analogy to good use we choose to carry out our investigation with a simple \nrecursive program construct which we write c*(j), This is the program, specified by the program-term \nC(X), which consists of executing ~ with every appearance of the special A majority of the work done \nto date in reasoning about place-holder symb,ol X standing for a recursive call to C computer programs \nseems to be concerned with re.@ar programs Conventional notations for ~*(j) include pXC( X) [5,203, (e.g. \nWlziie programs or flowcharts etc.). Some of the better motivated by work on the least fixpomts of functional. \nThe known examples are [6,7,8,9,10,19,21,25,281. When reading analogous simple iterative construct is \na*, namely the program this and other relevant hterature it becomes apparent that consisting of carrying \nout a any ZO number of times. With when these programs are replaced by recur5ive programs ( i.e true? \nand false? standing respectively for the identity (skip) context-free programs) the problems become much \nharder. For and empty ( abort) programs, we define example, the Important paper of de Bakker and Meertens \n[3] seemed to indicate that Floyd -Hoare-hke methods for proving a = true? C (false?) = false?, the partial \ncorrectness of recursive programs using invariant ai+l = a;a Ci+l(fa/se?) = T( Ci(falw?) ), assertions, \nrequired infinitely many such assertions. Subsequent work by Crelbach [131, Goreiick [12], Apt and where \na;@ IS the usual composition of programs and ~(~) is Meertens [11, Harel, Pnueh and Stavi [17,181 and \nCalher the application of programs, i.e. ~ with all free appearances [111, pointed to the fact that thn \nwas not quite so. Namely, of X replaced by (1 The meanmgs of a* and C*(f) are binary by aliowlng the \nassertion preceding a recursive call to relations over states, defined respectively (inductively, that \nfreeze the values of all the program variables in order to IS assummg knowledge of the semantics of a \nand t(~) for any refer to them upon completion of that call, a natural /9) as follows: extension of the \nFloyd -Hoare technique to recursive programs IS possible, using only fmItely many assertions. C)ther \nwork m(a*) = Ui~om(ai) m( C*(Y)) = Ui~om( ti(~alse?) ). has been done regarding recursive programs: Hitchcock \nand Park [201 have equated the termination of a recursive program rhis then, illustrates the essence \nof the analogy the with the well -foundedness of a certain binary relation, and Iterative ( recursive) \nconstruct IS an infinite union of terms [173 and [291 contain approaches to the problem of consisting \nof fmttary composition ( apphcation) of simpler ax Ionlatlzing the total correctness of (deterministic) \n ones, starting with the skip (abort) program. recursive programs. Major parts of all of [1,12,17,18,291 \nare devoted to one or both of the tasks of (1) designing In most of the recent work on dynamic /ogic \nand its substitution rules or rules of adaptation for dealing with variants [14,15,16,19$281 emphasis \nhas been placed on working parameters or local variables, and (2) presenting the methods with a simple \nbut powerful iterative programming language, and for mutual recursion. our point IS that these, and other \npart of the appeal of this work seems to come from the slrnphcny which a corzstruct such as a* brings \n-with it. The t Present address: Mathematical Sciences Department, work we report upon here makes use \nof the experience and IBM T.J. Watson Research Center, Yorktown Heights, NY 10S98. knowledge attained \nin [14,1 S,19] for the regular operator u*, in order to investigate the problems encountered when reasoning \nabout recursive programs via the simple but powerful context-free analogue, ~*(~). Although we would \nhke to stress that we regard the a#@ach developed in this paper, and the potential it might carry for \nfurther research, as its most important contribution, we point to the specific results proved: Context-free \ndynamic logic (CFDL) is defined and an axlomatlzatlon R of It constructed. R is proved to be complete \nfor CFDL relative to arithmetical universes (arithmetically complete [14,1S]). This result subsumes those \nof [1,3,11,12,13,17,181 much as the completeness of the axiomatlzatlon of DL in [14,1 S,161 subsumes \nCook s [81 completeness result for Hoare s [211 system for partial correctness. As an upshot, it also \nsettles the problem of supplying a complete natural axiomatlzation of the total correctness of (deterministic) \nrecursive programs. The result also seems to answer a question of de Bakker [2] regarding the weakest \nprecondition [9] of recursive programs. In passing it IS shown that the main rule of inference for the \npartial correctness of recursive programs appearing m [1,11,12,13,181 M simply an instance of Park s \n[271 fixpoint induction principle. Next, the question of the divergence of a recursive program is considered, \nprompting us to extend the binary relation semantics of the programs to computation-tree semantics. This \ngives rise to the definition of the special formula /oo,ba for a program CY,being true in a state whenever \nu, started in that state, can diverge (enter an infinite loop). This concept has been shown to be essential \nfor the definition of the total correctness and weakest precondition of a nondeterministic program [1 \nS,19,221 and, besides a similar concept defined in [20] for different purposes, has not been defined \nyet for recursive programs. We prove, using a result of Wlnklmann [311, that /ooPa IS expressible in \nCFDL. However, the proof results in an extremely undesirable formula, Justifying the addition of &#38;ooPa \nto CFDL as a primitive. This addition, we show, gives rise to an arithmetically complete axiomatization \nof the resulting logic. 2. Context-free Dynamic Logic (CFDL) Svntax: we are given sets of function symbols \nand $redicate symbo/s, each symbol with a fixed nonnegative arity. We assume the inclusion of the special \nbinary predicate symbol = (equality) in the latter set. We denote predicate symbols by p, q,... and k-ary \nfunction symbols for k>O by f, g,... Zeroary function symbols are denoted by Z,X ,Y,... and are called \nvariables, A term is some k-ary function symbol followed by a k-tuple of terms, where we restrict ourselves \nto terms resulting from applying this formation rule finitely many times only. For a varlabie x we abbreviate \nx( ) to x, thus f(g( x) ,Y) IS a term provided f and g are binary and unary respectively. An atomic formula \nIS a k-ary predicate symbol followed by a k -tuple of terms. The set of first-order formulae is defined \nas the closure, under V, ~ and 3X (for variable x), of the set of atomic formulae. We define the set \nT of program terms as follows, using the special place-holder symbol X: (1) For any variable x, term \ne and first-order formula P, the assignment x+-e, the test P? and the symbol X are ali in T, (2) For \nall program terms cl and T2, T1 ;c2, ~1U~2 and T1*(~) are m T. ( Remark:~ IS not a function  symbol, \nit is merely of mnemonic value and is used to signify the difference between rx* and T*,) An occurrence \nof the symbol X in a term cl is said to be bound if it is in a subterm of the form ~2*(~), and free otherwise. \nA term with no free occurrences of any program variable is called closed. The C*(f) clause IS intended, \nintultlvely, to represent the program consisting of an execution of c where the free occurrences of the \nsymbol X in C represent t calling itself recursively. The set CF of context-free programs IS taken to \nbe the set of closed terms m T. For example, ( y+y+l ;X u Y>O?)*(f) is a legal program In CF. The set \nof wett formuie formulae of Context-free DL (CFDL-wffs) is defined just as DL in [14,15,161, but using \nCF instead of the set KG of regular programs: (1) Any atomic formula IS a CFDL-wff, (2) For any CFDL-wffs \nP and Q, a in CF and  variable x, .P, (PvQ), 3xP and <tY>P are CFDL-wffs. We use A, D, ~ and V as abbrevlat]ons \nm the standard way, and m addltlon abbreviate =<a>.P to [a]P. Note that a fwst-order formula is a CFDL-wff. \nThroughout, we denote by var(rx) the tuple conslstmg, in some fixed order, of all variables appearing \nin a to the left of a + symbol Semantics: The semantics of CFDL IS based on the concept of a state. A \n$tate ~ consists of a non empty domain D and a mapping from the sets of function and predicate symbols \nto the sets of functions and predicates over D, such that to a k-ary function symbol f ( resp. predicate \nsymbol p) there corresponds a total k-ary function ( resp. predicate) over D denoted by f~ ( resp. Pj). \nIn particular, to a variable there corresponds an element of the domain and to a O-ary predicate symbol \n( propositional letter) a truth value (true or fal,e). The standard equality predicate over D is that \ncorresponding to the equality symbol ( =). We will sometimes ~efer to the domain of .j as Dj. 82 el = \nft(elj,...,ekj). We now define by simultaneous induction the binary relation over r, the set of ail states, \ncorresponding to a program a of CF, and those states ~ in I which satisfy a CFDL-wff P. The relation \nwill be denoted by m(a) and for the latter we write .lEP. ( ~,$) being an element of m(a) can be thought \nof as representing the fact that there exists a cwn/rutatiors sequence (or @sth) of sx starting in state \n~ and terminating in $. Thus, JI%sYIP will be seen to be making an assertion about all terminating computations \nof a starting in state J; namely the assertion that the final states of these computations satisfy P. \nSimilarly, &#38;<a>P asserts the existence of a terminahng computation of a starting in state ~ and ending \nin a state satisfying P. Notation: For any function C: D + fY, arbitrary element e, and afD, we define \n[e / a]C to be the function with domain D and range D u{eJ giving the same values at points in D-{a} \nas G, and such that C(a)=e. (a) For any variable x and term e, m(xf-e) = {(~,j)l $[ej /xl~},  (b) for \nany program-free CFDL-wff P, m(P?) = {( f,J)l JFP},  (c) ForanyaanddInCF andtermcinT, m(a ;@) = m(a) \no m(fl), (composition of binary relations)  n3(aL@) = m(a) u m(p), (union of binary relations) m( T*(j)) \n= u,~~m(~i(fa[$e?) ), where t (a)=a, d+l(a)=C(Ci(a)) and ~(19) is the CF program obtained by replacing \nevery free occurrence of X in c by I% (d) For an atormc formula p(el,...,ek), $kp(el,...,ek) whenever \npj(elj,...,ekj) is true,  (e) For any CFDL-wffs P and Q, a in CF and variable x, .lk~P lff it N not \nthe case that &#38;P, ~k( PvQ) iff either JFP or .WQ,  .jF3xP iff there exists d6Dj such that [d / \nxlj b P, ~F<ss>P iff there exists $<1 such that ( $,$) tin(a) and #FP. V/e will be interested in special \nsubsets of r namely simple universes. A pseudo-universe U is a set of states all of which have a common \ndomain D. A function symbol f ( resp. predicate symbol p) is called uninter#veted in U if for every state \n.lf U and for every function F ( resp. predicate P) over D there exists $(U such that ~ and $ differ \nat most in the value of f (resp. p) which in $ 1s F (resp. P). A symbol is called fixed in U if its value \n1s the same in all states of U. Thus, = N fixed in any universe. A universe is a pseudo-universe in which \nevery predicate symbol IS fixed and in which every function symbol is either fixed or uninterpreted, \nA universe is called simfite if the only uninterpreted symbols in it are a designated set of variables. \n In a simple universe the fixed variables will sometimes be called constants following ordinary usage. \nIn this paper we will primarily be interested in mvestigatmg the truth of CFDL-wffs in a given simple \nuniverse U. However, one can see that for some ~cU and some assignment x+e the unique state ~ such that \n( ~,$)fm(x+e), i.e. the state [ej / xI.1, might not be in U at all. We outlaw this phenomenon by adopting, \nfrom now on, the convention that in the context of a given universe the only programs we consider are \nthose in which the variables assigned to (e.g. x in x-e) and the quantified variables (e.g. x in 3xP) \nare uninterpreted. Thus, for .lfU and for any CFDL-wff P the truth of ~ in P can be seen to depend only \non states in U. We will often omit the adjective simple when no confusion can arise. An arithmetical \nuniverse A is a universe in which the domain includes the set of natural numbers, the binary function \nsymbols + and are fixed and given their standard meanings ( addition and multiplication respectively) \nwhen apphed to the natural numbers in the domain, and O and 1 are fixed zeroary-order function symbols \ninterpreted as the natural numbers zero and one respectively, Furthermore there is a fixed unary predicate \nsymbol mzt with the Interpretation nutj[d) is true iff d is a natural number , that is, for every state \n~, {dfDJl natj(d) ~ is the set of natural numbers. Tlhus, we are able to distinguish the natural numbers \nin the domam from the other elements and we do not care, say, what the value of x+y is in state j when \nit is not the case that nat ~( x ~) holds. An additional property we require of an arlthmlettcai universe \nis the ability to encode finite sequences of ellements into one element. The formal definition of this \nproperty 1s as follows There exists a total predicate R( x ,i,y) over the domain of A, such that for \nany natural number n it is the case that we have (k xl ....xn)(21y) (Vi)((nadi)mzi)zi) ~ (R(x,i,y) E \nX=xi)). rhe Intuition is that R( x,i,y) holds iff x is the i th component of y , so that any finite sequence \nX1....Xn can be encoded as such a y, Note that one particular arithmetical universe is the univmse N \nof pure arithmetic ; that m, the universe in which the domain is precisely the set of natural numbers, \nand , , O, = and nat (which in this case is Identically true), are the only function and predicate symbols. \nCoedel s #-.functlon serves as the finite sequence encoding function for this universe. When talking \nabout arithmetical universes we will often want to use n, m,...to stand for variables ranging only over \nthe natural numbers. We do this by adopting the following convention: any L-wff we will use in which \nwe have explicitly mentioned, say, the variable n as a free variable, is assumed to be preceded by nat( \nn) ~ . Thus, for example, ~K( P( n) ~Q) stands for .j F(mzt(n)l =( P(n) ~Q) ), asserting that in state \n~, (P(n) ~Q) is true [f nj happens to be a natural number. Furthermore, by convention, VnP(n) stands \nfor Vn(nat(n) =@(n)), and hence 3nP(n) abbreviates ~n(nct(n)Ap(n)). ]t is important to note that any \nuniverse U can be extended to an arithmetical universe by augmenting it, if necessary, with the natural \nnumbers and additional apparatus for encoding finite sequences. Thus, reasoning about any kmd of program, \nwritten over any domain, can m principle be carried out with a suitable arithmetical universe. A CFDL-wff \nP is U-valid (written PUP) if it is true in all states of the universe 1-1,and is valid ( PP) if it is \nU-valid for every universe U. Example: Consider the program a: Zex ; ( ( Z=()?; y+l) IJ ( z#()? ;2+-2-1 \n; x ;Z+z+l ; yey z) ) *()) which is of the form z-x ;Cx(f), The following is ~3(jzk?): ( ( Z=o?;y+l) \nu ( z#o?;z+-z-l ; ( ( Z=o?;y+l) u (z#o?;z+z-1 ; ( (Z=o?;yel) u (z#o?;z+z-1 ; false?; 2+2+1 ;y+y z) ) \n; Z+z+l ; y*y z) ) ; Z+z+l ; y+y z) ) . In general it can be seen that the meaning m(a) restricted to \nthe universe N of pure arithmetic is the binary relation {(~,$)1 $ = [(xj)!/YIJ ), and thus a is a program \ncomputing factoriat over the natural numbers. m One can see that ( ~,$)~m(~*(f) ) iff there exists a \nnonnegative integer n such that ( $,$) cm(~n(~alse?) ). h t other words the intuition is that executing \na recursive program T(X) which calls itself in effect at each appearance of X, is executing, for some \nn, the program consisting of allowing calls of at most depth n. (We remark that in fact this defmltion \nis in perfect agreement with j7xpoint semantics of recursive programs, as defined, say, in [41 or [51. \nUsing terminology from these papers our l?s are all continuous over the domain of binary relatlons, and \ntherefore defining the meanmg of C*(\\) to be the least solution of the relational equation X = C( X), \nin the sense of [41 and [201, is, by Kieene s [231 theorem, consistent with our definition of ~x(~), \nwhich is really Jlxr(x). ) In the sequel we will need a fundamental notion to aid in constructing our \nrules of inference and in conducting our meta -reasoning. We allow in this reasoning a special kind of \nprogram , the achieve program PZ, defined for any first-order formula P and tuple Z consisting of pawwise \ndisjoint variables. The meaning of PZ is given by the following additional clause to the definition of \nm: m(PZ) = { (~,$)1 # = [V/Zl~ for some tuple V of etements from Dj, and [Z~ / Z 1~ ~ P }. Thus, P is \nthought of as having free variables Z and Z , where Z is a tuple of primed versions of the members of \nZ. For 7 example, ( x,y) is (x ,y ). Intuitwely then, P is the program which assigns ( nondeterministically) \nto Z any value V such that in state j P is true of the value of Z in j and V. Thus, PZ achieves between \n~ and $ the relatlon induced by P(Z,Z ). Examfile: With Z=(x) and P(Z,Z ) being ( X =X V x =f(x) ), we \nhave m(PZ) = m(true? U xf-f(x))), ~ Now let CF = CF u {PZI P and Z as above). CF DL is defined exactly \nas CFDL, but replacing CF with CF . Our axioms and rules will take advantage of being able, in arithmetical \nuniverses, to construct an achieve program of the form PZ to correspond to a given real program (i.e. \na first-order formula P which expresses the relation induced by the program). 3. Preliminary Results \nThe facts estabhshed in this section are instrumental in estabhshmg the main result of Section 4. First \nwe show that the regular programs are embedded in CF. Recall that U* was defined in [281 such that m(a*)=(m(a) \n)*, i.e. the reflexive transitive closure of m(a). Lemma 1: For every rYfCF, m(a*) = m((trrfe? u a; X)*(~)) \n= m((true? u X;u)*(~)). P=: m(a*) = U(~~o m(al) = m(trrze?) U m(a) U m(a; a) u ... = m(~alse?) u m(frue?) \nu m(a ;true?) u m(a; a;true?) u ... = U ~o m( (true? u a ;X)i(~alse?) ) = m((trwe? u a; X)*(j)) . Similarly \nfor the second equality. ~ Theorem 2: For any arvthmet!cal universe A, the first-order language is A-expressive \nfor CFDL, I.e. for any CFDL-wff P there exists a first-order formula, Q, such that PA ( PsQ). ~: The \nTheorem is proved similarly to Theorem 3.2 in [151 and the reader 1s refered to that reference for details. \nHowever, here a shg.htly different treatment for ~x(~) is necessary. It can be shown, by the encoding \nof finite sequences of elements of the domain of A that there exists, for every term C( X), a ftrst-order \nformula lTR=(n) such that for every n lTR=( n) expresses @(jalse?), in the sense that m(lTR=(n)Z) = \nm(tn(~alse?)), where Z=vur(c). AS in Theorem 3.2 of [151, if QL is a first-order equivalent of Q then \nan equivalent of <c*(~)>Q Is 3n3Z (nat(n) A lTR=(n) A (QL)~). z In the sequel we will write Z=Z to abbreviate \nAxeZ(x=x ), and by convention will assume that for Programs of the form P z , the tuples Z and Z appear \nm that order in the paranthesised hst of free variables of P. Thus for example, P(Z ,Z ) will abbreviate \nP with members of Z Lemma 5: For every umverse 1-1, @ al,...fc, , and term replacing free corresponding \nmembers of Z. We now show how to C(X), if mu(txO)=4 and if furthermore for all i~o we have express the \nfact that PZ is an upper or lower bound on the mu(ui+l) ~mu(~(ai))j then for all i~o) mU(ui)~mU(~*(J)) \nrelation represented by a program a, using notions from CFDL. ~: By induction on i. For i=O we have T/reorern \n3: For any universe U and afCF , let mu(~) be m(a) mu(fxl)~mU( ~(qJ) m U(Wa~$e?))~ (Umnzo mU(Cn(Yalse?)))= \nrestricted to elements of U. If Z=zmr( a) then mu(~*(f)). Assume mu(a,)~mu(~*(~)), so that by (1) I=U(Z \n=Z 2 [alP(Z ,Z)) iff mu(a) ~ mlf(pZ), monotinicity mu(~(all )Gmu(T(~*(t) ) ). Thus we have mu(txl+l) \n~mu(~(ui) )~mu(~(~*(j))). However> one can show by induction on the structure of c that ~: (l): Assume \nku(Z =Z ~ [alP(Z ,Z)) and assume mu(c(w mn=o ~n(~ahe?l ) ) = U~=o mu(t(tn(~alse?) ) ). (~,$)6mU(a). We \nhave to show that j=[V/ZIJ for some tuple (This follows from the continuity of c over the domain of V \nof elements of DJ, and that [Z / Z I~FP(Z,Z ). The first (2) I=U(P(Z,Z ) =1 <a>Z =Z) iff mJPz) ~ mu(a). \nbinary relations; cf . [s].) And so we have mu(ai+l) ~ is trivial by the fact that Z=rmr(a 1 . NOW, by \nthe definition u ~=1mU(d(fde?) )=mu(T*(j) ). S of mU(cc), and since a does not change z , if (~,$)~mu(u) \nthen also ( Y,$)fmu(a), where j =[Z ~ / Z IJ and $ = [Zj / Z 1$ = [Zj / Z l[Z~ / Zl~. However, by the \nassumption, since we 4. Axiomatization of CFDL have constructed ~ such that ~ b(il=z ), we must have \n$ bP(Z ,Z), or [Zj / Z IIZ$ /ZIJbP(Z ,Z), which is the same Consider the following axiom system R for \nCFDL: as saying [Z~ / Z l&#38;P(Z,% ). Axioms: Conversely, assume mu(a)~mu( Pz), and assume that for \n(A) AH tautologies of propositional calculus. (B) [~+e]p = p;, for a first-order formula P. some J(U \nwe have JF(Z =Z), and that (~,$)~mu(u). We must [Q?]p . (Q=p). (c) show that $=P(Z , Z). By assumption, \n( ~,~)~mu(pz) ~ so that (D) [a ;ISIP = Eal[~lP. [Z~ / Z IJFP(Z,Z ), which by ~k(Z =Z) is equivalent \nto  (E) [aublP : (EalP A U31P). [zj/zlJPP(z ,z). However, by ( $,$) CmU(a) we know that  (F) [PZIQ \n= (VZ )(P(Z,Z ) = &#38;;) $=CZj /Zl~, so that &#38;P(Z ,Z).  for first-order formulae P and Q. (c) \n(P 2 [c*(j)lQ) ~ ((PAR) =1[c*(j) l(QAR)) (2): Assume ku(P(Z,Z ) ~ <a>Z =Z)), and assume where wr( R) \nfhsr( K)=*. ( ~,$) ~mu( pZ). We prove ( J,j)fa. BY the second assumption, Inference rules: [Zf / Z \nl&#38;P(Z,Z ), so that by the first we have ([Z~,z 1~ , [Zj /Zl[Z~ /Z lJ)fmU(u). Thus, we can conclude \nthat (~ , (H) P , P3Q EZ4,Zl~)fmll(d). Finally, from $f=[V / Zlj for some V we co~clude that-$ =[Z~,Z]~, \nand hence that ( ~,$)fmu(u). Q conversely, assume mu( PZ) ~mu(a), and that for some .jl=P( Z,Z ). We \nshow the existence of $6U such that (~,~)cmu(a) and Z ~- Z~. Take $ to be [Z j / Z]~. EalP ~ [alQ Certainly \n77 =Z . Furthermore, by the definition of Pz, $ (1) Z =z ~ [l:(P~)lP(Z ,z) since [Z j / Z ] f ]s simply \n~ itself, and since we assumed where Z=var( C), that jl=P(Z,Z ), we conclude that (~,$)fmu(px), and \nZ =z = [c*(f) lP(Z ,z) hence (J,.$)fmu(a). m (K) P(n+l,Z,Z ) ~ <~(P(n)Z)>Z=Z , ~P(O,Z,~) It is straightforward \nto show that our T S are monotonic in the sense that If m(a)~m(d) then m(c(a))~m(c(fi)). We  1?(n, Z,Z \n) ~ <~*(j) >Z=Z restate Park s flxpomt induction principle: for a f !rst-order formula P with Z=var( \nC), n~ rxzr( t). Lernrrm 4 ( Park [273): For any universe U, afCF and term c(X), For any arithmetical \nuniverse A denote by R(A) the axiom if mu(~(a))~mu(a) then mu(T*(f))Gmu(a). system obtained by augmenting \nR with the set of all A -valid first-order formulae as additional axioms. Provability in F/( A) is defined \nas usual. The intuition behind axiom (C) is that 1[ allows carry!ng R across a program when that program \ncannot affect the truth of R. The inttsltion in rule (J) is that if upon freezing the values of Z in \n~ execution of t, with the relatlon P plugged in whenever a recursive call was to be performed, results \nin P holding between the initial values and the current ones, then P holds when the recursive calls are \nindeed honestly carried out. We now prove the soundness of R. Lemma 6: For any first-order formulas T \nand P(Z,Z ), CF DL-wffs Q, R and S, term C( X), the following are valid (1) EPZJT z ( fZ )(P(Z,Z ) o \n1:), (2) (S s [c*(~)lQ) =1 ((SAR) =J [r*(Y) l(QAR)), where var( R) flvar(c)=gf  &#38;: Straightforward \nfrom the definitions. H Lemma 7: For any universe U, first-order formula P(Z,Z ) and term ~, where Z=var(~), \nIf bu(Z =Z ~ [~(Pz)lP(Z ,Z)) then &#38;u(Z =Z o [T-*(~) lP(Z ,Z)). ~: By Iheorem 3(1) the hypothesis \nis simply mu(C(Pz) ) ~mU( P7 ), By Park s prlnclple ( Lemma 4) we obtain mu(~*(~))~m U(PZ), which, again \nby Theorem 3(1), is precisely the conclusion. n Lemma 8: For any first-order formula P( n, Z, Z ) and \nterm C, where n$ zw(~) and Z=uur(C), If FA~P(O,Z,Z ) and kA(P(n+l,Z,Z ) ~ <T(P(n)Z)>Z=Z ), then l=A(P(n,Z,Z \n) =s <T*(J) >Z=Z ). ~: ne can how hat A p(O>Z?Z ) s n act .\u00adequivalent to saying that mA(p(0) )=~. Furthermore, \nby Theorem 3(2) the second assumption amounts to asserting that mA(p(n+l)Z) SmA(c(p(n)Z)). BY Lemma \n5 we conclude that mA(p(n)Z) ~mA(C*(~)) for ali n. Thus, again by Theorem 3(2),, we have the conclusion. \nB TAeorern 9 ( A-soundness of R): For any CF DL-wff P, if l_R(Aj P then bAP. .12@ FOllOWS from the soundness \nof our axlomatlzation of regular DL (cf. Thrn. 3.6 of [151) and Lemmas 6,7,8. 1 We will apply Theorem \n11 of [141 (which is Theorem 3.1 of [15]) to prove the arithmetical completeness of R, but we are required \nfwst to prove the appropriate completeness theorems for formulae with one box or one diamond. These will \nbe established with the a[d OC Lemma 10: The followlng are derived rules of R where Z and n are as in \n(J) and (K): (J ) Z =Z ~ MPZ)IP(Z ,Z) , WIPZIQ R=[c*(f)]Q (K ) P(n+l,Z,Z ) ~ <d P(n)z)>Z=Z , ~P(O,Z,Z \n) , R~~n<p(n)Z>Q .. ~: (J ): Assume kR(A)(Z =Z ~ [T(PL)IP(Z ,Z)). We apply (J) to obtain F~(A)(Z =Z \n~ E c*(~)lP(Z ,Z)). Using axiom (C) we get F~(A)((Z =Z A (VZ )(P(Z ,Z) ~@ )) ~ [T*(~) l(P(Z ,Z) A (VZ \n)(P(Z ,Z ) )))),), from which we .. deduce ~R(A)( (VZ )(P(Z,Z ) ~&#38;) ) ~ [T*(~)lQ). Thus, by . ax \nlom (K) and the second assumption the conclusion follows. (K ): Similar to (J ). m We now show that rule \n(J ) can indeed always be applied when its conclusion is A-valid. Lemma 11 ( invariance Lemma for CF \nDL): For every term T(X) and CF DL-wffs R and Q, If PA( R2[T*(j)lQ) then there exists a first-order formula \nP(Z,Z ) with Zwar(T), such that PA(R~[PZIQ) and I=A(Z =Z n [C(PZ)IP(Z ,Z)I. ~: lmphed by the way Theorem \n2 is proved is the fact that there exists a fwst order formula of arithmetic P(Z,Z ) which expresses \nthe program Cx(f) in the sense that mA( P z )=m A( T*(f) ). Certainly then, by the assumption, we .. \nhave PA( R=I[P7 IQ). Also, as noted in the proof of Lemma 5, mA(r(C*(j) ))=mA(c*(~) ), and so we have \nmA(r(pZ) )CmA(Pz), which by Theorem 3(1) N kA(Z =Z ~ [C(PZ)IP(Z ,Z)). ~ T/~eorem 12 ( Box -completeness \nTheorem for CF DL): For every c&#38;CP and first-order formulas R and Q, If ~A(Rda]Q) then kR( A) (R~[a3Q). \nJ2LQLK Strwhrforward proof by induction on the structure of a. The Connectlves +, ?, ; and u are treated \nprecisely as In [14,1 S]. The case c*(Y) is treated using derived rule (J ) and Lemma 11. 5 Similarly \nto Lemma 11, rule ( K ) can be apphed when needed: Lemma 15 (Convergence Lemma for CF DL): For every \nterm C(X) and CF DL-wffs R and Q, If kA( R=I<~*(j) >Q) then there exists a first-order formula p(n,Z,i \n, ) such that bA(p(fl+l$Z,Z ) ~ .. <T(P(n)z)>Z=Z ), b,. P(O,Z,Z ), and l=, (R~3n<P(n)z>Q). n,. .n &#38;: \nAgain, by the method used in the proof of Theorem 2, there exists a fwst-order formula P( n, Z,Z ) representing \nCn(yahe?) in the sense that for every n we have mA( P(fl)Z) =mA(@(~d$@?)). It is easy to see that all \nthree A -vahdities hold for P, S T/reorem 14 ( Diamond-completeness Theorem for CF DL): For every afCF \nand first-order formulas R and Q, if kA(Ro<tx>Q) then kR(A)(R~<cx>Q).  2G?$?L but 1; and precIselY \nS f heoIwI W usingLemma rule (K ) instead of Lemma 11 and rule (J ). We conclude that for CF DL-wffs, \nA-validity and provability in I?(A) are equivalent conceptw Theorem 15 ( Arithmetical Soundness and Completeness \nfor CF DL): For every arithmetical universe A and CF DL-wff P, ~A p iff R(A) M: One direction IS Theorem \n9) and the other follows from the general Theorem 11 of [14] (which is Thin. 3.1 of [151) and the present \nTheorems 2, 12 and 14. fl The results in thn section mdlcate that, as far as CFDL is concerned, reasoning \nabout pure recursion is analogous to (albeit more complicated than) that of reasoning about pure iteration. \nHere we are using the integers to count how deep we are in the recursion ( using P(n)Z in rule ( K)), \nwhereas for a* we counted how far we are in the iteration. It Is Interesting to note that the proof \nmethod for formulae of the form R 3[alQ which is incorporated into R boils down to Floyd s C1OI inductive \na$sertion method and to Morrm and Wegbrelt s [261 subgoal induction method respectively, when regular \nprograms are translated into recursive ones vla the two methods appearing in Lemma 1. Thus the duahty \nholding between these two methods, which was described in length in [263, shows up concisely as stemming \nfrom the two dual ways of viewing a*. The reader familiar with [261 can convince himself of this fact \nquite easily by deriving formulae (3.1-3.3) and (3.4-3.6) of [261 from our rule (J) by using the two \nequalities of Lemma 1. [n Section 4.4 of [1S1 we extend this system to the generai mutual recur3iorr \noperator #iX1...Xn( Cl, .....Cn). Appendices of [1S1 contain examples of proofs in R and l?+ of Section \n6. 5. Divergence of Recursive programs In this section we define the operational notion of the diverging \nof %recurslve program, I.e. It entering an infinite loop. rhis is done by introducing, for any state \n~, the J--computation tret of a program a, denoted by ct(u,l). We show that computation trees are in \nfact an extension of the semantics of CF. The trees however, in addition to the input-output information, \ncontain information regarding the presence or absence of divergences. The concept of diverging has been \nshown inl [15,19,223 to be essential for describing the total correctness of nondeterministic programs, \nand hence the importance of investigating it for recursive programs as well as iterative ones, The main \nresult in this section, based on a result of K, Winklmann, is the fact that diverging is expressible \nin CIFDL. Each node of ct( a,j) will be labeled with a state in r or with the special symbol F, and will \nbe of outdegree at most 2. The root is labeled with ~ and nodes labeled with F will always be leaves. \nThe inttrltion is that a path from the root represents a iegal computation of a starting in state ~. \nAccordingly, a leaf represents a termination state if it is labeled with a state in r, or reaching a \nfalse test if it is labeled with F. Any node with descendants represents an intermediate state of a. \nIf a node has two descendants then there Is, so to speak, a choice as to how to continue execution . \nA node will be represented by a pair ( t,l), where t is a finite string over {0,1) describing the location \nof the node m the tree by O denoting go ieft and 1 go right , and [ ( the label of the node) IS either \na state in r or the symbol F. 1 bus, for example, the tree ~ Q $ dJ A F M represented as {( A,~), (0,~), \n(l,$),(lO,F) ~(ll,$ )}. AS can be seen, A, the empty string, marks the root of the tree. By convention, \na single descendant is marked as going left , I.e. by O. Formally, for any jfr and a6RC, ct(a,j) is defined, \nby reduction on the structure of a, to be a subset of {0,1}* (r u {F}) as follows, where we use I to \nrange over (1 u {F}), and s, t,... to range over {0,1}*: (1) ct(x+e,~) = {(A,~),(Wj/xl~)}, {( A, J)} \nif 3t=P (2) ct(P?,J) = ,{(A,F)} if Jk.P, ( (3) ct(aub,~) = {( A,~)} u {(%1)1 (t,l)~ct(%~)} u {(141)1 \n(Ll)fc~(l%~)J>  (4) Let E = {(t,$)fct(a,J)l $fr A (Vb~(O,l)) (Vlf(ru{F})) ((tb,l)$ct(@)},  and let \nC = ct(a, $) -E. Then ct(a;fi,j) = C U {(ts,l)t (3c0((t,$fE A (%l)~ct(~,$))}, (s) ct(r*(f) ,~) = Ct(fahe? \nu dc*(f)),n  Informally, to construct ct( T*(~), ~ ) one starts constructing ct(~alse? u T(X)), and \nwhenever, so to speak, ct( X,j) was to be attached to a node labeled ~, ct( c*(~) ,$) is attached instead. \nC)f course, this process might lead to an infinite tree. The additional union with fatse? is introduced \nso that the process of calhng recursively would itself cost an edge in the tree, so that e.g. the program \n(X)x(j) will diverge (see below). L?xam@le: Let j be some state m N for which Yj=O, and in the diagram \nwe let i stand for [i/ yl~. Take a to be the program ( (Y=o?;y+-y+l) u (y#o?;Y+Y-l ;X;Y+Y+l))*(f). Then \nct(a,[l / yl~) is 1 F1 F1 %2 o FO  ($OF4?3 1 2 H We omit the proof of the following fact, which serves \nto show that computation trees are consistent with the binary relation semantics defined above: Lemma \n16: For every a6CF, ( J,$)6m(a) Iff ct(a,l) has a leaf labeled $. Define now, for any u(CF a Boolean \nconstant Loo)a by: Jkloopa iff ct(a, j ) is infinite, Note that, ct(a,~) being of fmlte outdegree, we \ncan apply Koenig s lemma ( see [241) tc. conclude that in fact ~~toopa iff there exists an injlrrile \npath from the root; i.e. there is an infinite sequence of nodes in ct(a, f), of the form (~,~) , (bl,~l), \n(blb2,~2), .... . (bl...b,,~i), ..... We would like to supply a syntactic characterization of /oo#=*~ \n. Recall that in [191 it was proved that a divergence m the iterative a* M due either to a local divergence, \ni.e. a divergence in some reachable execution of tY, or to a global one, i.e. being able to execute a \ns for ever. The former posslblhty was captured by <a*>/oopa which can be written llnloopan, and the latter \nis Vn<an>true, So we can wsxte 1=(loops* = (3nloo~an v Vn<an>true) ). Characterizing loo~T*W M similar; \nhere a local divergence IS a divergence lnslde some application of a reachable C, and can be expressed \nby ~nloop=n~a~$e?). Global diverging, on the other hand, is more subtle. Here we want to express the \npossibility of being able to apply C for ever , which amounts to being able to proceed infinitely deep \nInto the recursion . [n order to do this we apply, m the sequel, the following mild restriction on the \nuniverses we consider. The domain is to have at least two dlstmct elements and the set of symbols ]s \nto Include two fixed variables having these two elements as values. We will therefore use the symbols \na and b freely as two fixed-valued variables with dlstmct values. Now, for any term T, define the term \nC which, intuitively, allows sklpplng tests, recursive calls to T, and other recursive constructs, but \nforces any such skip to be recorded in a new flag variable x. given T( X), let x,y~ cxzr(t) be two variables, \nand let c (X) be C(X) with every (free in the case of X) appearance of a subterm a of one of the forms \nX, P? or C *(~) replaced by ( a u x+ b). Also define a: (y#a? u (y=a?;x=a?;y+-b)). For any n>O denote \nthe program x+-a; y+a;l?n(u) by ~n. We can now present our characterization of loofl=*W: Theorem 17: \nFor any afCF, *( loop=*~ = (3nloop=nwa1$e?) v Vn<Cn>y b) ). ~: Assume we have &#38;3nlooPTnUal$e?l. lt \nis quite easy to see that ct(T*(~) ,1) has at least as many nodes as ct( K (fde?),~ ), and hence we also \nhave &#38;loo~C*W. For the rest of the proof we wIII be needing some additional notation. For any i20 \nand jfr we would like to define the set S( 1,~,~) conslstmg of those states which occur Immediately before \nan application of c at depth i . Define where V is the set of states $ such that the process of constructing \nct( C(X+X ;C*(f) ) ,J) for xi var(~) requires constructing ct( x+x,.$). In other words, V is the set \nof states which execut}on of c*(~) can reach just prior to calling ~ recursively at level 1. Certainly \nif for some i we have ~6S( i,~,~), then $ labels some node m ct(~*(f) ,~), and furthermore the path from \nthe root of ct(~*(~) ,~) to that node M of length at least 1. ( Note that this would not be the case \nIf we were to deftne ct(C*(f) ,~) tobe ct(C( T*(f) ) ,~).) Assume now that ~~Vn<Tn>y=b. We show that \nfor any i>O we have S(i, C, f)#A , and thus ct(T*(f),.f) has paths of 88 sufficient, where 3(~1 reads \nthere exist infinitely many n , so that Vn can be replaced by 2mn in the statement of the Theorem.) Indeed, \nfor any such i, by assumption, we have ~k<~i>y=b, or ~b<x+a;y+a;l?i( u)>y=b, so that there exists a finite \npath p m ct(~i, ~), starting from the root, which termmates in a node labeled by a statem which thevahreof \ny is b. The Iabeisof thesuccesslve nodes ofp can be denoted by (~, [a/xIJ, [a/yl[a/xlJ, $0, .....jk) \nwhere ygk=b. Let i be the least integer such that y~i=b. By the construction of c (u) tt is evident that \nin order for y to have changed value from a to b, it must be the case that the value of x was a all along. \nMore precisely, for all J>j >(1 we have x ,=al so that tests P? and subprograms of $J the form C x(y) \nwere indeed cartved out and not avoided by executing x-b instead. In other words, the initial segment \nof the path p ending m ~j can be thought of as being a simulation, In @i( u), of a path from the root \nto the ~a~se? In ct( ~l(.@se?) ,~). Consequently, we have $J$S( ,,~,~). This completes the proof of \none direction of the theorem. Conversely, assume now that ~Fhm~=*w holds and that for all n~(l we have \n~F-kw~Tn~a~Jt?). Consider the Infinite sequence s of successive labels of the nodes of an infinite path \nfrom the root in ct( c*(j), $). It IS easy to see that by the second hypothesis, there must exist a subsequence \nof s, say ( ~0,$1, ....). such that for every i we have ~iCS(I,~,$) and such that ~1 corresponds to the \nfirst tmne m s that depth i of recursion was reached. We show that ~P<t,>y=b holds for every i by glvmg \nan algorithm for executing Ci m such a way as to termmate m a state in which the value of y 1s b. (liven \n1, simulate the path corresponding to the initial segment of the sequence s ending in ~i, i.e. assign \nx+-a and y~a, and then proceed in C i(u) exactly as s proceeded In ~*(y), executing tests and recursive \nconstructs and nor the x-b parts. By the defmitlon of ~i, reaching ~i in s corresponds to reaching u \nfor the first time m C i(U). Thus, we have reached u with yji=a and x ~,=a and therefore y IS assigned \nb. Execution in l?i(u) M then to be continued by choosing the x+b parts instead of tests, appearances \nof X and recursive constructs. Certainly this execution will terminate (no tests to fail; no recursive \nconstructs or recursive calls to diverge). Moreover, by the construction of u any subsequent arrival \nat u will not change the value of y, and since yi rw(~), this value is not changed by any other part \nof the rest of the execution. Thus, y=b upon termination. 9 An obvious quest]on arising now is whether \n100pa is expres.slble m CFDL, I.e. whether for any aCCF there exists a to deal with both dlsjuncts of \nTheorem 1 ?. We state the following two results and prove the second. The proof of the f!rst, due to \nK. Winklmann, is omitted here. Theorem 19 ( Wmklmann [311): For every term C(X), u~CF and first-order \nformula P there exists a CFDL-wff Q such that E(Q ~: 3 %<cn(u)>P). Theorem 1% For every term C(X) there \nexists a CFDL-wff Q such that 1=(Q z 3n100P=n~alse?) ) And hence from Theorems 17, 18 and 19, and the \nremark in the proof of Thin. 17, which justifies replacing Vn in its statement by 3mn, we obtain: . Corot \nlury 20: 100pa is expressible in CFDL. Proof of Theorem l!~: Consider the set Z; s W~oS( i,c,~) which, \nintuitively, is the set of states labeling those nodes In ct( c*(Y), ~ ) corresponding to points just \nprior to a recursive call to C. Assume we have defined, for any CFDL-wff Q and term T( X), a formula \na20ng(~,Q) such that I.e. ~kalorrg( T,Q) holds iff Q n true immediately prior to some reachable recursive \ncall to T in an execution of C*(~) starting In state j. Assume also that we have defined, for every program \ncr6CF and term C(X), a formula /p=,a such that, intumveiy, jbfp= * holds lff there is a divergence Ill \nct(~(u) ,~) whiclh is due to the ~ part and not to the a Part ( I.e. the divergence came from some recursive \nconstruct appearing in C(X) ). lt is quite clear that Jk~n@f@(fa[se?) holds Iff at some state $ in the \nexecution of r*(~) ]ust prior to a recurswe call to ~, it is the case that there N a divergence m ct( \nT(T*(~) ) ,$) which is due to the first c and not to the inner C*(Y). in other words &#38;a/orzg( c, \n/p=,c*~fl ). Now we proceed to define these concepts, and then observe that they give rise to CFDL-wffs. \nFor any a,B,~~CF and terms ~1( X) and K2( X) define Now for defmmg alorzg( T,Q) we use tricks similar \nto those used In conswuctmg 1: and u for Theorem 17 . Given C(X), let x ,y$ zx-m(~) be two variables, \nlet Z=zwr( T) and let ~ be a tuple of dmjoint primed versions of the varvables in var( C). Define c ( \nX) to be T(X) with every appearance of a subprogram a of the form P? or C x(f) replaced by (u u x+b), \nand every appearance of the program variable X replaced by ((x=a7;y=a?;y+b ;Z +-Z) u x+b u X) where \nZ +-Z abbreviates the composition of the assignments z +-z for all z(Z. Now, define a?ong( c,Q) to be \n<X+a ;y@a;@*(~)>( y=b A <Z+-Z >Q). The Inttrltlon is that m x+-a ;y+a;T *(f) one has the option of, \nwhenever X is reached, storing the current values of the variables Z in Z , as long as the computation \nuntil that point has been an honest simulation of a computation in c*(j). once such a store has been \ncarried out it cannot be carried out again because of the y=a? guard. Furthermore, as in the proof of \nFheorem 17, execution can always choose to surface quickly to the end of T *(~) by executing x+b whenever \npossible. Then, when the execution fmaliy termmates, we assert that Q M true for the values of Z which \nwe stored in ~ just before the recursive call. It should now be clear that I he reason the theorem now \nfollows IS that, when using Induction on the structure of c and assummg the theorem holds for the subterms \nof T, we can deduce that our inductive hypothesis M in fact that too)a is expressible in CFDL for a which \nappears in C. This follows from Theorems 17 and 18. Thus, the definmon of 1P, which uses 100pa for such \na, gives rise to a CFDL-wff. n 6. Augmented CFDL In this section we augment CFDL with the abihty to reason \n about divergences directly without having to go through the translation of 100pa into tts equivalent \nCFDL-wff. The resultlng language will be called CFDL+. The reason for doing so, even though by the previous \nsection CFDL and CFDL+ are equivalent in expressive power, is rooted m the fact that the CFDL equivalent \nof loo~a supplled above ( including the part commg from the omitted construction in the proof of Thin. \n18) has the unpleasant property of being strongly dependent on the structure of a and on the variables \nappearing In a. Calling that equivalent Pa , one can see that Pa, cannot be obtained from Pa by substituting \na for a throughout. Consequently, proving a formula with an appearance of 100pa will inevitably involve \ncarrying out the transformation of 100PU to Pa , and then reasoning in CFDL. The point is that the intuition \none might have about ~oopa is, in a strong sense, lost in the process. Our axiomatlzatlon here too wIII \nbe of an extension CF DL+ which Is Cleflned as CFDL+ but with the programs coming from the set CF . As \nin SectIon 4, we wIII be using the fact that in an arithmetical universe A there exists, for any afCF, \na first-order formula P such that Pz expresses a. The problem that arises !s that of defmmg IOOP(PZ). \nWe would like It to be the case that for any P z, Woop( Pzl holds. However, for a given ~~r it is possible \nthat the set J(PZ) = {$1 ( J,$)fm(pZ)} IS Infinite., One solution to this problem IS to define ct( a,~) \nto be a tree of possibly infinite outdegree, with the Iocahon of the node given by a hst of natural numbers \n(as opposed to a list, or string, of 0 s and l s) ; for PZ the tree would be defined (roughly) as ct(Pz,l) \n= {( X, J)} u {(l,ji)l (~,$l)~m(Pz)l Then, we would define ~PlooPa to hold iff ct(a, f) has an mfiolte \npath (which In this case N not necessarily equivalent to ct( a,~) being mfmlte). Another, equivalent \nmethod N to associate with any u(CF and ~fl a set of computauon trees CT(a, ~), For PZ we would define \nl-he rest of the defmltfon is carried out analogously to the def!nitlon of ct(a, ~) above. For example, \nCT(a;~,~) is the set of trees obtatned by following the construction of ct(a; d,~) for every tree in \nCT(a, ~), attaching any tree in CT(~,$) to a node labeled ~ whenever ct( @,$) was to be attached to that \nnode in constructing ct(a ;fl,~). Exarnl~la Let a: x+x+1, P: XCX and Z=(x). For any jflf such that XJ=O \nwe have: CT(a,~) = { {( A,$),(O,[l/xl~)} }, cT(P~,[l/xlf) = { {( A, E1/xlf),(o,j )1 I X$>l }, and thus \nCT(a;PZ, j) = { {( X,~),(O,[l /xl~,(OO,~)} I X$>l }. E Now define ~kloopa to hold Iff there is an infinite \ntree in CT( a,~ ). We remark that either way /oopd IS uniquely defined for afCF , and that for afCF, \nCT(a, ~) = {ct(a,~)}. Now consider the axiom system R+ for CFDL+ defined as ~ of SectIon 4 augmented \nwith the following axioms and rules: (In the following, P and Q are first-order, R M a CF DL+-wff, T(X) \nis a term, x and y are variables x,y$ uar(~) , Z=uar(C) , V ]s the tuple of variables obtained by augmenting \nZ with x and y, and u, T and d are as defined in the proofs of Theorems 17 and 19 respectively.) CFDL+ \nis defined to be CFDL u {toopal acCF}, with the semantics of the CFDL part being as in CFDL and the semantics \nof /OOpa as defined m SectIon 5. (L) [oo~x+e ~ false, that Vn<x*a; y+a; P(n) >y=b implies Vn<~n>y=b. \n~ (M) !oo~p? Efalse,  (N) /OOpa ;8 = (/oopa V <&#38;>100@) , In order to prove the arithmetical completeness \nof R+ we need to show that A-valid CF DL+-wffs of one of the forms (o) loopoup= (100pa v looP/lj) , \n  R =loopa or R~~lOOP,x, where R is first-order, are provable in(P) /oop( Pz) = false. ??+( A). Then \nthe general theorem (11 in [14], 3.1 in [1S]) Ru[es of Inference: is used to obtain the final result. \nMore details can be found in [1S1. (Q) R D ( <x*a ;y+a;@ *(j) >( y=b A <~+~>looPC(Q~) ) V f Aeorerrs \n22: For every sY~CF and first-order formula R, Vn<x+a;y+a;P(n) v>y=b ) , if FA( R3/OOpa) then ER+( A) \n( R~loo~J. P(O,V,V )~<u>V=V , Q(Z,Z ) =1 <c*(j) >Z=Z , P(n+l,V,V ) ~ <~ (P(n)v)>V=V  ~: By mducticm \non the structure of u, The only nontrivial case is when a IS of the form C*(f) for some term t. Assurmng \nPA ( R~loopa), we show the existence of first-order formulas Q and P(n) such that the premises of rule \n(Q) are (R) A-valid. Since these premises involve only CF DL-wffs and the R ~ ( [x+a;y~a;C *(~)]( y#b \nv ~l+~l&#38;OOP=(Q~) ) A formula /oopT( QZ,, m which the program is of complexity 3n[x+a;y+a; P(n)vly#b \n) , lower than T*(j), the result WIII follow, Indeed, by Theorem 2 v=v %rIP(o, V ,V) , Z =Z ~ [c*(~) \nlQ(Z ,Z) , we can take Q and P(n) to be first-order formulae involving, respectively, only variables \nin Z and V, and such that kA( Q ~ V =V ~ [C (P(n)v)]P(n+l, V ,V) C*(Y) ) and for all n ~A(P(n) ~ C n(a)). \nAll the premises R ~ +oOp=*~ are easily seen to be A-valid for this choice. ~ Let A be any arithmetical \nuniverse. l?+(A) is defined Slmiiarly we hav~ analogously to R( A). Provability in R+(A) is defined as \nusual. TAeorem 2?: For every csHX and first-order formula R, Theorem 21 ( A-soundness of R+): For any \nCF DL-wff P, If R+(A) P then Ap. And thus, as remarked, we conclude: ~: The proof of the A-validity of(L) \n-(P) is left to T/Ieot em 24 ( A rithmeltical Soundness and Completeness for the reader. We show that \nrule (Q) is sound, noting that the CF DL+): For every CF DL+-wff P, soundness of the dual rule ( R) follows \nImmediately. k,AP iff ~R+( A) P. Consider rule (Q). We argue that the A-vahdity of the first premise \nof this rule, under the assumption that the other Acknowledgments  three are A-valid, asserts that We \nwish to thank A. Pnueh for suggesting a f!rst version I=A( R 2 (3n/oopCnUal$e?) v Vn<rn>y=b), of rule \n( K), and N. Dershowltz, A. Shamir and V.R. Pratt for heik+ful discussions. The research was supported \nby the which, by Theorem 17, mlplies that bA(RZOO/J=*W ). Yad-Avi Foundation in Israel and by NSF Grant \nno. MCS76-18461. ( Recall that Tn is an abbreviation of (x+-a ;y+a;C n(@) ).) And indeed, by Theorem \n3 in Section 3 the premises, other than References the first, assert, respectively, mA(p(0)v)~mA(@), \nand Apt, L.C.L.T. Completeness One can then show, by InductIon on n using monotonicity, that Finite Systems \nof Intermediate AssertIons for Recursive Vn(nlA(p(n) v)~mA(~ln(u) )). Consequently, since Qz is Program \nSchemes. IW 84/ 77, Math. Cent. Amsterdam. Sept. 1977. mA(Qz)=?l/$~*(j)),Vt;(mA(p(n+l) v)~mA(d(P(n)v))). \n[1] K.R. and Meertens. with smaller as a relation than ~*(~) but is divergence-free, one can see that \n100PC( &#38;) Implles lP=,=XW, and [2] deBakker, J.W. Recursive Programs as Predicate hence also that \natong( T,/oopC( &#38;) ) implles ~ransformers, Proc, IFIP conf. on Formal Specifications of along( c,lpT,=*~ \n). However, by the proof of Theorem Programmmg Constructs. St. Andrews, Canada. Aug. 1977. 19 the latter \nis 3nloop=n Wal$e?l. Moreover, since [31 de Bakker, J.W. and L.G.L.T. Meertens. On the Completeness of \nthe Inductive Assertion Method. J. of Computer and System Sciences, 11, 323-3S7. 1975. [41 de Bakker, \nJ.W. and W.P. deRoever. A Calculus for Recursive Program Schemes. in Automata, Languages and Pro.grarrrrrcirrg \n( ed. Nivat), 167-196. North Holland. 1972. [S1 de Bakker, J.W., and D. Scott. An outhne of a theory \nof programs. Unpubhshed manuscript, 1969. [61 Banachowskl, L., A. Kreczmar, G. Mlrkowska, H. Rasiowa \nand A. Salwlcki. An Introduction to Algorithmic Logic; Metamathematlcal Invest! gatlons in the Theory \nof Programs. In Mazurkiewltcz and Pawlak (editors) Math. Found. of Comp. Sc. Banach Center Publications. \nWarsaw. 1977. [71 Burstall, R.M. Program Proving as Hand Simulation with a Little induction. IFIP 1974, \nStockholm. [81 Cook, S.A. Soundness and Completeness of an Axiom System for Program Verification. S1AM \nJ. Comp. Vol. 7, no. 1. Feb. 1978. ( A revision ofi Axiomatic and interpretive Semantics for an Algoi \nFragment. TR-79. Dept. of Computer Science, U. of Toronto. 1975.) L91 DiJkstra, E. W. Guarded Commands, \nNondeterminacy and Formal Derivation of Programs, Comm, of the ACM. VOI 18, no.8. 1975 [101 Floyd, R.W. \nAssigning Meaning to Programs. In J.T. Schwartz (cd.) Mathematical Aspects of Computer Science. Proc. \nSymp. in Apphed Math. 19. Providence, R.1. American Math. Sot. 19-32. 1967. [111 Galher, J. Semantics \nand Correctness of Nondeterministlc Flowcharts with Recursive Procedures. [n Sth Automata, Languages \nand Programming. Springer-Verlag. July 1978. [121 Corellck, C.A. A Complete Axiomatic System for Proving \nAssertIons about Recursive and Nonrecursive Programs. TR -7S. Dept. of Computer Science, U. of Toronto. \n1975. [13] Crelbach, S.A. Theory of Prog-ram Structures. Lecture Notes m Computer Science, 36. Sprmger-Verlag. \n197S. [141 Harel, D. Arithmetical Completeness in Loglcs of programs. in Sth Automata, Languages and \nProgramming. Springer-Verlag. July 1978. [151 Hare}, D. Logics of Programs Axiomatic and Descrlptlve \nPower. Ph.D. Thesis. MIT. Available as MIT/ LCS/ TR-200. May 1978. [161 Harel, D., A.R. Meyer and V.R. \nPratt. Computabihty and Completeness in Loglcs of Programs. Proc. 9th Ann. ACM Symp. on Theory of Computing, \nBoulder, Col., May 1977. [171 Harei, D., A. Pnuell and J, Stavi, Completeness Issues for lnduchve AssertIons \nand Hoare s Method. Tech. Rep., Dept. of A pphed Math. Tel-Aviv U. lsrael. Aug. 1976. [181 Harel, D., \nA. Pnueh and J. Stavi. A Complete Axiomatic System for Proving Deductions about Recursive Programs. Proc. \n9th Ann. ACM Symp. on Theory of Computing, Boulder, CoL, May 1977. [191 Harel} D. and V.R. Pratt. Nondeterminlsm \nin Logics of Programs. Proc. 5th ACM Symp. on Principles of Programming Languages. Tucson, Ariz. Jan. \n1978. [201 Hltchcock, P. and D. Park. Jnduction Rules and rermlnation proofs. In Automata, Lan~.ages \na.. ~ Programming (cd. NIvat, M.), lRIA. North-Holland, 1973. [211 Hoare, C.A.R. An Axiomatic Basis \nfor Computer Programming. Comm. of the ACM, vol. 12, S76-580, 1969, [221 Hoare, C.A.R. Some Properties \nof Predicate Transformers. JACM, VOI.2S, no,3. July 1978. [231 Kleene, S.C. Introduction to Metamathematics. \nD. Van Nostrand. 19S2. C241 Koen~g, D. Theorie der endlichen und unendlichen Grapen. Leipzig. 1936. \nReprinted by Chelsea, New York. 1950. [251 Manna, Z. and R. Waldlnger. 1s Sometime Sometimes Better \nthan Always ? Intermittent AssertIons in Proving Program Correctness. Proc. 2nd lnt. Conf. on Software \n Engineering, Oct. 1976. [261 Morris, J.H. Jr. and B. Wegbrelt. Subgoal Induction. Comm. of the ACM. \nvol. 20. no. 4. April 1977. [271 Park, D. Fixpolnt InductIon and Proofs of Program properties. In Machine \nintelligence 5. Edinburgh University Press. 1969. [281 Pratt, V.R. Semantlcai Considerations on Floyd-Hoare \n Logic. Proc. 17th lEEE Symp. on Foundations of Computer Science. 109-121. Oct. 1976. [291 Sokolowskl, \nS. Total Correctness for Procedures. Manuscript. Univ. of Gdansk, Poland. 1977. [301 Tarskl, A. The semantic \nconception of truth and the foundations of semantics, Phllos, and Phenom, Res, 4, 341-376. 1944. [311 \nWlnklmann, K. private communication. 92 \n\t\t\t", "proc_id": "567752", "abstract": "The problem of reasoning about recursive programs is considered. Utilizing a simple analogy between iterative and recursive programs viewed as unfinite unions of finite terms, we carry out an investigation analogous to that carried out recently for iterative programs. The main results are the arithmetical completeness of axiom systems for (1) <i>context-free dynamic logic</i> and (2) its extension for dealing with <i>infinite computations.</i> Having the power of expression of these logics in mind, these results can be seen to supply (as corollaries) complete proof methods for the various kinds of correctness of recursive programs.", "authors": [{"name": "David Harel", "author_profile_id": "81100197485", "affiliation": "Massachusetts Institute of Technology, Cambridge, MA and IBM T.J. Watson Research Center, Yorktown Heights, NY", "person_id": "PP14078578", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/567752.567760", "year": "1979", "article_id": "567760", "conference": "POPL", "title": "Recursion in logics of programs", "url": "http://dl.acm.org/citation.cfm?id=567760"}