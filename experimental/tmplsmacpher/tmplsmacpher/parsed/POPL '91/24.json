{"article_publication_date": "01-03-1991", "fulltext": "\n static Type Inference in a Dynamically Typed Language Alexander Aiken Brian R. Murphy IBM Almaden Research \nCenter Computer Science Department 650 Harry Rd. Stanford University San Jose, CA 95120 Stanford, CA \n94305 email: aiken@ibm. com email: brm @neon. Stanford. edu Abstract We present a type inference system \nfor FL based on an operational, rather than a denotational, formula\u00adtion of types. The essential elements \nof the system are a type language based on regular trees and a type inference logic that implements an \nabstract interpre\u00adtation of the operational semantics of FL. We use a non-standard approach to type inference \nbecause our requirements using type information in the optimiza\u00adtion of functional programs differ substantially \nfrom those of other type systems. 1 Introduction Compilers derive at least two benefits from static type \ninference: the ability to detect and report potential run-time errors at compile-time, and the use of \ntype information in program optimization. Traditionally, type systems have emphasized the detection of \ntype errors. Statically typed functional languages such as Haskell [HWA*88] and ML [HMT89] include type \ncon\u00adstraints as part of the language definition, making some type inference necessary to ensure that \ntype con- Permission to copy without fee all or part of this matertial is granted provided that the copies \nare not made or distributed for direct commercial advantage, the ACM copyright notice and the title of \nthe publication and its date appear, and notice is given that the copying is by permission of the Association \nfor Computing Machinery. To copy other\u00adwise, or to republish, requires a fee and/or specific permission. \n@ 1990 ACM 089791419-8/90/0012/0279 $1.50 straints are satisfied (i.e., to ensure that a program has \nno type errors). We, however, are interested in using type inference as a tool for the optimization of \npro\u00ad grams written in a functional language. We present a type inference system for FL [B*89], a functional \nlanguage based on FP [Bac78]. Unlike ML and Haskell, the FL language definition does not include any \ntype constraints. In standard terminology, FL is dynamically typed, meaning that run-time type checks \nare required. However, static type information is still very useful for the compilation of FL programs \nand particularly for enabling program optimization. Two characteristics distinguish type inference in \nour setting from the traditional type inference problem. First, for type information to be useful for \noptimiza\u00adtion, it should be as precise as possible. This is not the case in type inference for ML, for \nexample, where the only requirement is to infer information that is ac\u00adcurate enough to prove that the \nlanguage s type con\u00adstraints are satisfied. Second, because FL h= no static type restrictions, it is \ndesirable that an FL type infer\u00adence algorithm infer some useful type information for many programs that \nother type systems would reject entirely as untypeable . Type systems for languages such as ML and Haskell \ncan be characterized roughly as follows. A type is a set of values. There is a formal language to describe \ntypes and a logic to assign types to the subexpressions of a program. There is usually a particular algorithm, \nthe type infe~ence algorithm, for applying the rules of the logic. The correctness of the type inference \nalgo\u00adrithm is derived from the denotational semantics of the language. Our type system for FL differs \nsubstantially from the standard approach. Nevertheless, there are close parallels, and for this reason \nwe choose to use the terms type and type infeTence, despite the non-standard in\u00ad terpretation. For us, \na type is a set of normal-foTm expressions. We give a formal language based on reg\u00adular trees [GS84] \nto describe types. We give a logic to assign types to the subexpressions of a program. Our type inference \nalgorithm applies this logic to carry out an abstract interpretation [CC79, Nie85] of the opera\u00adtional \nsemantics of FL. The correctness of this type in\u00adference algorithm is established using the operational \nsemantics. Our approach can be viewed as an operational (or intentional) formulation of types. For first-order \nval\u00adues (e.g., the atoms, sequences of atoms, etc. ) our formulation is equivalent to the standard one, \nbecause there is a one-to-one ccmrespondence between the first\u00adorder expressions and the values they \ndenote. For higher-order values (e.g., functions and structures con\u00adtaining functions) this correspondence \nbreaks down, and two functions that denote the same value may be members of different (and incomparable) \ntypes. As discussed in Section 3, the main reason for adopting this approach is that it appears to provide \ngreater pre\u00adcision on a wider range of FL programs than the stan\u00addard approach. Using this operational \nformulation of types, we con\u00adstruct a type language using regular trees in which type containment is \ndecidable (Section 4). Further\u00admore, when types are sets of expressions, all the major features of FL, \nincluding higher-order func\u00ad tions, sequences, recursive structures, and user-defined datat ypes, are \nprecisely captured by regular trees. Section 5 solves a simplified type inference prob\u00adlem using an abstract \ninterpretation of an operational (rewrite) semantics of FL. The abstract interpreta\u00adtion is presented \nas a logical inference system. For many recursive functions, proofs in this logic do not exist i.e., \nthe abstract interpretation does not termi\u00adnate. Section 6 adds new inference rules to the logic to guarantee \ntermination and to type recursive func\u00adtions precisely. Section 7 presents a solution to the full type \ninference problem, using a simple way of defining a collecting interpretation [Nie85, HY88] directly \nfrom the structure of a proof in the logic. Section 8 con\u00adcludes with a brief discussion of the implementation \nand outstanding problems. This paper concentrates on the theoretical basis for the type system; detailed \ndescriptions of some of the algorithms and the implementation appear in [Mur90]. An implementation of \nour type inference system for the full FL language has been in use at IBM Almaden for several months. \nDuring this time, the system has been used to analyze a wide variety of small-to medium-size (50 O lines \nof FL) programs. Our initial experience indicates that the system is very precise. More importantly, \nthe type information has proven to be of great benefit in program optimization. We be\u00adlieve these results \nshould be applicable to other func\u00adtional languages, especially those without static type restrictions \nsuch as the functional subsets of Lisp and Scheme. 2 An Overview of FL The FL domain consists of noTmal \nand exceptional val\u00adues. The normal values are the atoms (integers, reals, characters, and the values \ntrue and false), sequences, tagged normal values, and functions. The exceptional 280 f denotes a function \nf:x denotes function application (xl,., xn) denotes sequence construction + integer, x * denotes tag \npairs < err, x + denotes exceptions abc abbreviates the sequence of chars ( a, b, c) comp: x = < em, \n( camp , x) > if x # (fl, . . ..fn) f:x = cons:x = < em, ( cons , x) > ifx + (fl, . . ..fn) idx = condx \n= + er?, ( cond , x) > if x # (f~,fz,fs) K:xy = COZqX(fl, . . .. fn). X = fl:(. ..(fn: X)) isint:i = \ncorls:(fl, . . .. fn). x = (fl:X, . . .. fn. X) signalx = *:( Xl, . . ..Xn) = fl:x iffl:xE~FL si:(Xl, \n. . ..Xn) = cond(fl, f2, f3):x = f3:x if fl:x = false tl:(Xl, X2, . . ..Xn) = { fz:x other wise al:(x, \n(yl, . . .,yn)) = mini s.t. f:Xl C ~~~ seqof:f: (xl, . . .,Xn) = f:i:: 3i s.t. f:Xl = false { true otherwise \nFigure 1: A subset of FL. XifX~~FL x x true if i E Int, false O.W. + err, x + XI *... *xn if xi ENum \n Xi (X2, .... Xn) (x, Yi,...7Yn) values are specially tagged normal values and 1. The + err, < f , x \n>>. Note that exceptions are legiti\u00adset of all exceptional values is &#38;FL. Figure 1 gives mate normal \nforms. the subset of FL needed to understand the examples that follow. Some features of the language \nare ignored 3 The Type Inference Problem altogether; in particular, input/output functions and The following \nexample shows a very simple use oft ypesyntactic sugar are omitted. Note that all FL func\u00adinformation \nin program optimization. Consider an ex\u00adtions are strict with respect to exceptions. We use the pression \nE(*). If, in the context of E(), the functionfollowing abbreviations: + is guaranteed to be applied to \nsequences of integers, fog = comp: (f, g) then * can be replaced by integer multiplication *int, [f~,..., \nfn] = cons: (f~,..., fn) which is a faster operation. This small example illustrates certain characteristics \np-+q; r = cond (p, q, r) that allow a type system to be useful in optimization: Some functions in Figure \n1 are defined only for some the type system should associate with each function arguments; for all other \narguments, the application f in a program a set of possible arguments, ~arg. (It f: x returns the exception \n~ err, < f , x >+. The also useful to have a set of possible results; the neces\u00adevaluation order of FL \nis leftmost-innermost; thus, in sary modifications to the type system are simple and [f, g]: x, f: x \nis evaluated and then g: x is evaluated. omitted. ) To be correct, type information must be The function \ndefinitions in Figure 1 can be inter\u00ad conservative farg must be a superset of the actu~ preted as rewrite \nrules, where the rewriting consists set of possible arguments of ~.1 Finally, it should be of substituting \nthe right-hand side of the definition possible to compare types, and in particular to test for the left-hand \nside. An expression is in normal whether one type is a subset of another type. In the fomn if no rewrite \nrule applies. Examples of nor\u00ad 1A formal definition of conservative requires more develop mal form expressions \nare: 1, id, (1, id), K o id, and ment; see Section 7. tion is that fa~~ ~ sequences_of_integers. 3.1 \nTypes as Sets of Values Let e be an expression, let p. :: Expressions .-+ Values be the meaning function \nmapping expressions to val\u00ad ues, and let a type T be a set of values. The statement e has type T is formalized \nas the assertion p(e) E T. In type systems where types are sets of values, typ\u00ading an application el \n: ez involves computing a type T1 for el and T2 for e2, and then applying a rule App(T1, T2 ) to derive \na type for el: e2. In general, the rule App may constrain the types TI and T2, thereby gaining information \nabout the behavior of el and e2 in the context el: e2. For example, in cond: (seqof: isint, *, signal) \nthe argument of * is always a sequence of integers; thus *int can rePlace *, as discussed above, provided \nthe type information for * is precise. Suppose cond has type T1 and (seqof : isint, *, signal) has type \nT2. For APP(T1, T2) to tightly constrain the type of * s ar\u00adgument, the type Tl should express the following \nprop\u00aderties: comi takes a sequence of functions (f 1, f z, fs) as its first argument; f 1 is applied \nto cond s second ar\u00adgument to determine which arm of the conditional to use; and finally, f z is applied \nto values for which f 1 is true. Thus, if we wish to infer precise information for *, the type of cond \nis highly constrained ideally, the type should be {p(cond)} to avoid losing information. Similar arguments \ncan be constructed for many of the primitive functions using simple and typical pro\u00adgrams. Within the \nframework of types as sets of val\u00adues} the most general solution to this problem is to ad\u00admit arbitrary \nfunctions from types to types as types; this allows unlimited precision in the types of primitive functions. \nHowever, if types are arbitrary functions, it is very difficult to test whether T1 ~ T2. As we shall \nsee, the ability to compare types is important not only for enabling optimization, but also for the precision \nof type inference itself. Our solution to this dilemma is to redefine types as sets of expressions. The \ntype of cond becomes just the set of expressions {cond], and knowledge about the behavior of cond is \ncaptured through a separate mechanism of type rewrite males. The advantage of this approach is that types \nhave simple semantics (making it possible to test whether T1 ~ T2) while still allow\u00ading arbitrary precision \n(embodied in the type rewrite rules).  3.2 Related Work It is interesting to examine the effect defining \ntypes as sets of values has had on other type systems for dy\u00adnamically typed languages. Thatte presents \na type system for Lisp designed to detect statically some type errors [Tha88]. The system extends the \nHind\u00adley/Milner type system [Mi178] with one new type representing the set of all values; thus, every \nexpres\u00adsion has type Q. This is probably the simplest ext en\u00adsion of Hindley/Milner that is adequate \nfor dynami\u00adcally typed languages. Unfortunately, the typing al\u00adgorithm Thatte presents for this minimal \nextension may diverge. Furthermore, the system cannot pre\u00adcisely type some simple expressions; for example, \nthe expression s i: (1, a) has type Q because heterogeneous sequences have type List(Q). At the other \nextreme, Young and O Keefe present a type evaluatoT for a lazy dialect of Scheme [Y088]. This system \nis strikingly similar to our system in some respects, but types are sets of values. Scheme itself serves \nas the type language; thus, any function from types to types is a type. As discussed above, this presents \nserious problems in comparing types. Young and O Keefe use a conservative test for type equality. In \ncent rast, a different definition of type leads us to a more robust subset test, other algorithms on \ntypes (such as type intersection and union) are also corre\u00adspondingly weaker in their approach because \nof the TE ::= W(o, a) = {} 1: IzJ(a, u) = c(a) [ TEI V TEZ V(TEI V TE2, u) = V(TEI, a) U Y(TE2, a) I \nTEI A TE2 V(TEI A TE2, u) = !l(TEl, u) rl IZ(TE2, a) I jiz a.TEl W(jlz a.TEl, u) = least T s.t. T = V(TEI, \nu[a + ~) I C(TEI, . . . . TEarit (C)) see Figl.lre 3 Figure 2: Syntax and semantics of type expressions. \n difficulty of handling function types. Several type systems have been proposed for FP [GHW81,Fra81,Kat84]. \nThe drawbacks of using these approaches for FL type inference are the essential first\u00adorder nature of \nthe systems and the inability to auto\u00admatically infer types for recursive data structures. Regular trees \nhave been used before in a type lan\u00adguage for a statically-typed, first-order functional lan\u00adguage [MR85]. \nThere are two essential differences in our approach. First, in our system regular trees are the only \nmechanism for expressing types; in [MR85] a separate function-space constructor is used for func\u00adtion \ntypes, Second, we require arbitrary type union, whereas [MR85] uses discriminate ed unions. Regular trees \nhave also been used in the static analysis of logic programs [HJ90].   4 The Type Language Let E be \na set of type constructors and let A be a set of type variables. We use c for elements of 2 and a,p, \n. . . for elements of A. A syntax and semantics for type expressions is given in Figure 2. Let T be a \ntype expression. An occurrence of a in T is bound if it is in the scope of fix a. T ; otherwise a is \nfree. Except for the presence of free variables, type expressions are regular trees [GS84]. An environment \nu is a function from type variables tc, sets of expressions, The type meaning function IZ maps type expressions \nand envi\u00adronments to sets of expressions. Definition 4.1 Let T1 and T2 be type expressions. Then T1 ~ \nT2 if Vu II(TI, u) < W(T2, u), and TI = T2 ifT1 sT2and T2GT1. Recall from Section 3 that the goal of \ntype inference is to assign conservative argument types to every func\u00adtion in a program. Since FL has \ncall-by-value seman\u00adtics, the argument of a function is always in normal form. This leads to the following \ndefinition oft ype. Definition 4.2 Let fl be the set of all normal forms, let 7 be the substitution such \nthat Vcz T(cz) = S2, and let T be a type expression. T is a type if W(T, -r) ~ L?. From this point, we \nuse e for arbitrary expressions, w for expressions in normal form, T for type expressions, and V for \ntypes. We omit environments and write e &#38; T for e E W(T, u) when a statement is quantified over all \nenvironments a. A subset of the constructors for our type language is given in Figure 3. We use infix \nnotation for construc\u00adtors to emphasize the relationship with the syntax of FL (Figure 1). In addition \nto the constructors listed, there is a constructor ~ for each primitive function f. There are also constructors \ncovering the atoms: Char, Int, Real, and False are used in examples. Other useful types are listed in \nFigure 4. Type expressions precisely describe common pro\u00adgramming structures. Every primitive function \nf is ex\u00adactly described, since ~ = {f}. Applications are also captured; for example, the expression cond: \n(seqof: isint, *, id) is the only element of the type cond: -~,% ~-Regular trees natura~y describe recursive \nstructures. The set of sequences of type V (henceforth Seqof(V)) is jiz a.null V V I+ a. Binary TE ::= \nTE1 R TEz 17(TE1 +-+ TE2, o-) = {(eO,..., em)\\eO c V2(TEl, m)A (cl,...,e~) C v(TE2, ~)} W(TE1:TE2,0-) \n= {el:e21el E V(TEI, U) A ez G T(TE2,17)} IJl(< tag, TE1 >,u) = {< tag, e > \\e E !Jl(TEl, c)} V(NU1l, \na) = {()} V(n, u) = {ele is a normal form} V(Int, u) = {..., l,O,l,.. .} il(cond, a) = {cond} Figure \n3: The constructors. Num = Int VReal Exc = %em,0> True = =( False V Exe) Seq = ji% a.Null V (Q w a) Func \n= {TJ[V is a function } [Tl,...,Tn] = T1 ~ (... +-+ (Z ~Nu~)-..) Figure 4: Some useful type expressions. \ntrees with leaves oft ype V are fiz a. [a, a] V V. More stead of its type (e.g., Int) insofar as possible.2 \nFor interestingly, a type expression for an iterated constant clarity, atoms are used in types in the \nexamples. Sec\u00adfunction that (eventually) returns an element of V is ond, while the definition of type \nexpressions given in jiz a.~ (a V V). Finally, type expressions support un-Figure 2 is easy to understand, \nit does not lead to the restricted type union. This is necessary for the precise best algorithms. An \nalternative representation, known typing of conditionals, for example, since the types of as regular \nXX-grammars [GS84] or leaf-linear systems the two branches need not be the same. of equations [M R85], \nis used in our implementation. Type expressions have many useful properties. From Figure 2 type expressions \nare closed under union, 5 Type Rewriting intersection, and least fixed-point operations. Type Our type \ninference algorithm is an abstract interpreta\u00adexpressions with no free variables are closed under i!ion \n[CC79,Nie85] of an operational semantics of FL. complementation. It is also decidable whether T = 0 \nThe correctness of type inference is established by [GS84] and whether TI C Tz [Mur90]. We have devel\u00adcomparing \ntwo rewrite relations: the standard ev~ua\u00adoped a fast heuristic (based on the work of [MR85]) tion relation \n+.. on FL expressions, and an abstract for the following problem: Given two types T1 and T2, evaluation \nrelation ---+~ on type expressions. This sec\u00adfind a most general substitution a such that W(T1, u) ~ \ntion solves a simplified type inference problem: De\u00adV(T2, a). A heuristic is required because finding \na sub\u00adfine --+, on type expressions such that when e E T,stitution is PSPACE-hard in general [Mur90]. \nThe e -+FL V, and T +~ V, then v E V. Section 6 alters heuristic works well; we have yet to find an \nexample the abstract rewrite relation to guarantee termination in practice where its use adversely affects \nthe precision and to precisely type recursive functions. Section ? of type inference. presents a full \nsolution to the type inference problemWe conclude this section with two brief comments based on the abstract \nrewrite relation. on the implementation of types. First, for increased We begin by writing the operational \nrewrite rules of precision, our system propagates an atom (e.g., 1) in-FL in the structural style advocated \nby Plotkin [Plo]. 2Including atoms as types prevents a crisp statement of some results; thus, the exclusion \nis for pedagogical reasons. l*wl*. ..*vn ifv=(vl, . . . , Vm) vi 6 Num MULT *: V +FL < em, < * , v >> \notherwise { v # (vl, v2, v3) V ~Z v; @ Func V1:V4 -+m, v5, V5 c EXC conct v --+~~ ~ err, cond , v > \n+ cond (vi, vz, v3): v4 ~FI, 5 CONDERR COND1 VI: V4 --+FL V5, v5 e True, vz: v4 FL 6 VI: VA +~~ v5, \nV5 C False, v3: V4 ~FL v6 Gond (vi, vz, v3):v4 __+,L V6 COn&#38; (~1, V2, v3):~4 FL v6 COND2 COND3 Figure \n5: Sample FL rewrite rules. Rewrite rules in this style are presented as inference type rewriting is \nconservative with respect to the stan\u00adrules of a formal logic; a rule is read as asserting that dard \nsemantics. if the subgoals above the line hold, then the conclu- Theorem 5.2 Suppose e +,, v and T += \nV. If type sion below the line holds. A proof of e --+~~ v in this rewrite rules are conservative and \ne G T, then v 6 V. logic is a computation tree showing the evaluation of e. Examples of FL rewrite rules \nfor the functions * Sample type rewrite rules for * and cond are given and cond are given in Figure 5. \nin Figure 7. In practice, we have found that precise Type rewrite rules rewrite type expressions to types. \ntype inference requires sophisticated type rewrite rules Type rewrite rules are given in the same style \nas FL such as TCOND. For precision, it is important to know rewrite rules, with one type rewrite rule \ncorresponding for which arguments the functions in V1 are true and to each FL rewrite rule. The general \nform of an FL false. To approximate this, we have implemented a rewrite rule and its corresponding type \nrewrite rule conservative type inversion function with the property is given in Figure 6. (The constraint \nthat the num\u00adV-l(v ) 3 {V]v : v +~L v , v e v , vi E v}  ber of subgoals be the same in corresponding \nFL and type rewrite rules can always be satisfied by padding Using TCC)ND, and others rules not specified \nhere, rules with dummy subgoals. ) The following defini-the type system proves the following: tion provides \na condition for the correctness of a type a, [=a,~,- :~ T rewrite rule. Int V < em, -%.eqof(Int) > \n Constraint 5.1 (Conservative Rules) Let RFL 6 Termination and R~ be corresponding FL and type rewrite \nrules as shown in Figure 6. R* is conservative with respect An implementation of type rewriting as defined \nso far to R,= if would be correct but would also frequently fail to ter-Vi, T, Vi,.. .,~_l {Ei(e, vi,. \n... vi_l)Ie ~ Tjvj @Vj} minate. Consider the following function, which is the <.&#38;( T, VI, . . .. \nVi_I) identity on sequences: If all type rewrite rules satisfy this constraint, then def f = isnull \n--+ O;alo [sl, f otl] Vi < n e~ +FL vi Vi~nTi+,~ where where e +Ffi v T-+. V e~ = .E~_l(e, vl, . . ..v~_l) \nTi = &#38;~_l(T, VI,...,l)I) v= En(e, vi,..., vn ) V = c$n(T, VI,..., Vn) Figure 6: The general form \nof an FL rewrite rule and its type rewrite rule abstraction. (IF V A Seaof(Int) # 0 THEN Int ELSE 0) \nV TMULT % V --+. (IF V A Seqof(Nurn) A ~Seqo~(Int) # O THEN Num ELSE 0) V < em, [ * , V A -3eqof(Num)] \n> V ~ X whereX = [Func, Func, Func] TCONDERR ~&#38; V +~ conct (V A X)V < em-, < cond , V A 7X >> V1:V4 \n-+. V5, V2:(V1-l(True) A V4) --+. V6, V3:(V1-l (False) A V4) --+. V7 TCOND Conrt [Vi, Vj, V3]:V4 AT (V5 \nA Exe) V V6 V VT Figure 7: Sample type rewrite rules. This example introduces I?L s function definition \ntermination of type rewriting is embodied in REC and mechanism. We assume, without loss of generality, \nASSUME. In general, to use a REC rule a substitution that the right hand side of a function definition \nis a u is needed such that T u ~ TIY and Vu ~ V a. The function in normal form. For each function definition \nsystem tries to find a most general substitution u that def f ~ v in a program, a constructor ~ is added \nmaximizes the domain T of the type rewriting and to the type language, a type V is computed such that \nminimizes the range V. v E V, and a new type rewrite rule ~ +~ V is defined. Our implementation uses \nseveral heuristics to dis- Consider the type application ~: Seq. A proof P of cover a valid assumption \nT +~ V for REC. We illus- Z: Seq +. V must correspond, step for step, with trate the most important \nheuristic using the function proofs pa off: v -+,L v] for every v G Seq. But there is f above. In evaluating \nT: Seq , the system first dis\u00ad no finite proof P, since there is no bound on the size of covers that \nthis recursively involves the computation all p.. In an implementation, type rewriting diverges of Z: \nSeq, when the occurrence of f in the body is searching for the proof P. applied. Since E Seq &#38; F: \nSeq the system adds the as- Figure 8 defines new type rewrite rules TERM and sumption ?: Seq +~ a, where \na is a new type variable, ASSUME; REC is a scheme for modifying all type and applies ASSUME. In the last \nstep of the proof, rewrite rules of the form given in Figure 6. The rule the system has derived TERM \ncan always be applied to prevent type rewriting {7: Seq --+T V } t F: Seq -+T V where from diverging. \nHowe~er, using TERM usually results V=&#38; in a great loss of information, so it is used only if other \nV = Null V (0 w (Q A Seq))V < err, ( al , a A ~Seq) > techniques fail. The most important technique \nfor guaranteeing the At this point, to apply a REC rule a substitution u vi<n AU{ T ~.V }k Ti+.E T ~TV~V \nT--i. fl AI-T-+TV AU{ T+= V}t T-+, V TERM REC ASSUME Figure 8: Type rewrite rules to guarantee termination. \ns ~ {v} U{X13Y @ s St. Fun(Y):fl~ +T x} n~:v+=sl~v ~ x CONTEXT X:.9 where Fun(V) = {flj is a subexpression \nofe EV] TERM T -+. flL~/@) Figure 9: Additional type rewrite rules. is needed such that Vu ~ V u. In \nthis case the sys-lowing [HY88], we extend FL s syntax to distinguish tem finds the most general substitution \n[a +---fLz a. V]. occurrences of a primitive function t by labelling each Since fix a.V = Seq, the final \nresult is a proof that wit h a unique label 1 (writing 1.f ).3 For higher-order Z Seq += Seq. functions, \nit is useful to have type information for ev- Note that the type V precisely describes the possible ery \ncurried argument, not just the first. Thus, the outcomes of the body of f under the assumption that result \nof type inference is a histo? y function (see Fig\u00adf returns type a. In particular, V shows that the body \nure 10) which associates a type with each label 1 and off produces a modified sequence for every sequence \nin argument number n. CI, and an append-left ( al ) exception for every non. It is straightforward to \nmodify the FL and type sequence in a. The application of REC in the final rewrite rules to propagate, \nbut otherwise ignore, la\u00adstep proves that no append-left exceptions can arise. bels. Introducing labels \nchanges the definition of types, however: /1. f and 12. f are distinct expressions if 7 Type Inference \n11 # 12, since we wish to track occurrences of functions individually. Define Lab(e) (resp. Lab(T)) to \nbe the A collecting inte~pretation [Nie85,HY88] is an ab\u00adset of labels in e (resp. T). Let L be a set \nof labels. stract interpretation that gathers information about We define a family of types fl~ = {vlLab(v) \nc L}. the subexpressions of an expression. This section uses The next step is to identify the proofs \nin -+T that proofs in the logic +., and a simple way of defining express the type information we wish \nto capture about collecting interpretations to solve the type inference functions in v. Type information \nmust be computed problem stated in Section 3: to determine constraints for all surrounding contexts \nin which v might be used; upon every function s use in a given context. With\u00ad that is, type information \nis needed for vI: v for all con\u00ad out loss of generality, we assume that the context is a texts v . The \nrule CONTEXT in Figure 9 accomplishes normal form expression. 3Labels may be drawn from any countable \nset. We first formalize the result of type inference. Fol\u00ad H: Label x Int + Type (H, u H,)(l, n) = Hl(/, \nn) u H2(2, n) Ifl ~ H2 4+ W,n HI(2, n) < ~2(Z,n) ~e(l,n) = {vn\\vn # lAZ. f:vl:. .Jvn C u Conc(lq} PCP. \n~Jj if T +. ~A ~ Conc(P~) A 1 c L where L = Lab(T ) T(l ) = { l,l{vnll.j vi:. ..:VmE Com(l% )} otherwise \nFigure 10: History functions. this; it analyzes not just v, but also any components space. Let P, be \nthe set of au Proofs of e FL v, and of v that are accessible (e.g., if v is a sequence of func-let Cone(P) \nbe the set of all conclusions VI: vz +,. tions) and any functions that v might return (if v is a V3 in \na proof P. The history function He defined in higher-order function). In general, finding a finite set \nFigure 10 is precise in that all the steps of the proof S in rule CONTEXT requires use of the rule TERM \nare recorded (thus the name history ). to ensure closure, alt hcmgh this is rare in practice. For Let \nPT be the proof of the form H T -+~ V discov\u00adincreased accuracy in the presence of labels, the rule ered \nby the type system. The definition of a history TERM is modified as shown in Figure 9. function H for \n+. is given in Figure 10. The only The conclusion of rule CONTEXT may seem difficult y is the rule TERM; \nthe most precise history strange for a precise type system; after au, ~A contains information inferable \nfrOm T T nkb(T) is that func\u00adevery computable function. We are not interested in tions in T could be \napplied to any argument. the conclusion, however, but in the structure of the Theorem 7.2 The definition \nof 17T given in Figure 10 proof itself and what it shows about the possible argu\u00adis conservative. ments \nof functions. The rest of this section develops two history functions, H, for proofs in +,. and HT Let \nv be an FL expression in which every primitive for proofs in +.. The following definition formalizes \nfunction has a unique label. The result of type infer\u00ada correctness condition for HT. ence is the history \nfunction HT, where T = Qo: V and Definition 7.1 (Conservative) Let T be a type ex-VGv. pression and let \nHT be a history function. HT is con\u00ad 8 Conclusions and Future servative if HT ~ u, ~:r ~. Work We first \ndefine a history function for +,~. This is complicated by the fact that no proof of the form We have \npresented a type inference algorithm for FL e +FG v exists in general (i.e., e may diverge). To based \non an operational view of types where types are account for histories of non-terminating computations, \nsets of expressions. This approach inherently sacrifices a new rewrite rule e ~~~ 1 is added and all \nother are some of the potential power in a system where types rules are modified to enforce strictness \nwith respect to are sets of values. For example, in our system there 1. The modifications are easy and \nomitted for lack of is no direct way to prove any relationship between the functions id and id o id , \neven though these expres\u00adsions denote the same value. However, a system such as ours requires heuristics \nat some level, since perfectly precise information is uncomput able. Our implemen\u00ad tation has convinced \nus that this design is a good one; this approach seems to match very well with program\u00adming styles used \nin practice. The main barrier tc~ a completely practical system is performance. The current implementation \ntries to make the proof search fast. Memoization [Mic68] is used extensively to avoid recomputation and \nthere is no backtracking. However, the underlying algorithm is still exponential in the worst case, since \nthe size of the proof may be exponential in the size of the original program. A promising solution to \nthis problem is to adapt the idea of principal types from statically typed languages [DM82]. Consider \nthe function f from Section 6. At present, the system must derive the entire proof f: Seqof(V) --+T Seqof(V) \nevery time it is needed. In\u00adstead, the system could prove once that f: Seqof(a) +~ Seqof(a) and then \nspecialize this fact when needed. This introduces no new ideas; the system is already powerful enough \nto prove f: Seqof(a) +. Seqof(a). The difficulty is that, in general, there is no most gen\u00aderal rewriting \nf: V -+~ V of f for which every other rewriting is obtainable by substitution. The problem, then, is \nto identify heuristics which accurately predict when the potential cost in precision is small enough \nthat it is worthwhile to use a specialization of a gen\u00aderal fact.  Acknowledgements The authors would \nlike to thank the FL group (John Backus, Thorn Linden, Peter Lucas, Paul Tucker, John Williams, and Ed \nWimmers) for many useful discus\u00ad sions and a congenial working environment. Discus\u00ad sions with Ed Wimmers \nhelped to clarify many oft he semantic issues. Paul Tucker assisted with the imple\u00adment ation. It is \nalso a pleasure to thank Carl Gunt er, John Mitchell, Uday Reddy, Moshe Vardi, Jennifer Widom, John Williams, \nand Ed Wimmers for their comments on earlier versions of this paper. [B*89] [BaC78] [CC79] [DM82] [Fra81] \n[GHw81] [GS84] [HJ901 [HMT89] [HWA*88] J. Backus et al. FL Language Manual, Parts 1 and 2? Research Report \nRJ 7100, IBM, 1989. J. Backus. Can programming be liberated from the von Neumann style? a functional \nstyle and its algebra of programs. Commu\u00adnications of the A CM, 21:8, 1978. P. C!ousot and R. cousot. \nSystem\u00adatic design of program analysis frame\u00adworks. In Sizih Annual ACM Symposium on Principles of Programming \nLanguages, pages 269 282, January 1979. L. Damas and R, Milner. Principle type\u00adschemes for functional \nprograms. In Pro\u00adceedings of the Ninth Annual ACM Sym\u00adposium on the Principles of Programming Languages, \npages 207-212, 1982. G. Frank. Specification of data structures for FP programs. In Proceedings of the \n1981 Conference on ming Languages and ture, pages 221-228, J. Guttag, J. Horning, with data abstraction \nFunctional Program-Computer Architec\u00ad1981. and J. Williams. FP and strong typing. In Proceedings of the \n1981 Conference on Functional Programming Languages and Computer Architecture, pages 11-24, 1981. F. \nGecseg and M. Academei Kaido, N. Heintze and J. tion theorem for grams. In POPL uary 1990. Steinby. Tree \nA utomaia. Budapest, 1984. Jaffar. A finite presenta\u00adapproximating logic pro\u00ad17, pages 197-209, Jan- \nR. Harper, R. Milner, and M. Tofte. The Definition of ,5 Yandard ML Version 3. Technical Report ECFS-LFCS-89-81, \nLab\u00ad oratory for Foundations of Computer Sci\u00ad ence, University of Edinburgh, 1989. P. Hudak, P. Wadler, \nArvind, B. Boutel, J. Fairbairn, J. Fasel, J. Hughes, T. Johns\u00adson, D. Kieburtz, S. P. Jones, R. Nikhil, \nM. Reeve, D. Wise, and J. Young. Report on the Functional Programming Language Haskell. Technical Report \nDCS/RR-666, Yale University, December 1988. [Kat84] [Mic68] [Mi178] [MR85] [Mur90] [Nie85] [Plo] [Tha88] \n[Y088] pretation of expressions (without powerdo\u00admains). In Proceedings of the 15th Annual ACM Symposium \non the Principles of Pro\u00adgramming Languages, pages 107 1 18, 1988. T. Katayama. Type inference and type \nchecking for functional languages: a re\u00adduced computation approach. In Con\u00adference Record of -the 1984 \nACM Sym\u00adposium on Lisp and Functional Program\u00adming, pages 263 272, August 1984. D. Michie. Memo functions \nand machine learning. Naiure, (218):19-22, April 1968. R. Milner. A theory of type polymorphism in programming. \nJ. Comp. @ Sys. Sci., 17:348-375, P. Mishra free type the Twelfth the Principles pages 7-21, 1978. and \nU. Reddy. Declaration\u00adchecking. In proceedings of Annual ACM Symposium on of Programming Languages, 1985. \nB. R. Murphy. A Type Inference System for FL. Master s thesis, MIT, 1990. F. Nielson. Program transformations \nin a denotational setting. ACM Transactions on Programming Languages and Systems, 7(3):359-379, July \n1985. G. D. Plotkin. A structural approach to operational University S. Thatte. types. In gramming: semantics. \nText prepared at of Aarhus. Type inference with partial Automata, Languages and Pro\u00ad15th International \nColloquium, pages 615 629, Springer-Verlag Lecture Notes in Computer Science, vol. 317, July 1988. J. \nYoung and P. O Keefe. Experience with a type evaluator. In D. Bj@rner, A. P. Ershov, and N. D. Jones, \neditors, PaT\u00ad tial Evaluation and Mixed Computation, pages 573 581, North-Holland, 1988. \n\t\t\t", "proc_id": "99583", "abstract": "", "authors": [{"name": "Alex Aiken", "author_profile_id": "81100399954", "affiliation": "IBM Almaden Research Center, 650 Harry Rd., San Jose, CA", "person_id": "PP39041079", "email_address": "", "orcid_id": ""}, {"name": "Brian Murphy", "author_profile_id": "81405594128", "affiliation": "Computer Science Department, Stanford University, Stanford, CA", "person_id": "PP14189643", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/99583.99621", "year": "1991", "article_id": "99621", "conference": "POPL", "title": "Static type inference in a dynamically typed language", "url": "http://dl.acm.org/citation.cfm?id=99621"}