{"article_publication_date": "01-03-1991", "fulltext": "\n Polymorphic type inference and assignment Xavier Leroy* Ecole Normale Sup&#38;-ieure Abstract We present \na new approach to the polymorphic typing of data accepting in-place modification in ML-like lan\u00adguages. \nThis approach is based on restrictions over type generalization, and a refined typing of functions. The \ntype system given here leads to a better integration of imperative programming style with the purely \napplica\u00adtive kernel of ML. In particular, generic functions that allocate mutable data can safely be \ngiven fully polymor\u00adphic types. We show the soundness of this type system, and give a type reconstruction \nalgorithm. 1 Introduction Polymorphic type disciplines originate in the study of }\u00adcalculus and its connections \nto constructive logic [7, 14], so it is no surprise it fits very nicely within purely applicative languages, \nwithout side effects. However, polymorphism becomes problematic when we move to\u00adward conventional imperative \nlanguages (Algol, Pas\u00adcal), and allow physical modification of data structures. The problem appeared \nat an early stage of the design of ML [8, p. 52], when assignment operators were provided for the primitive \ndata types of references and vectors. Consider the following example, in MLI: let r =ref [] in r := [1]; \nif head(!r) then ... else ...  If we naively give type #a. a list ref to the reference r, we can first \nuse it with type int list ref, and store in it *Authors address: B. P.105, 78153 Le Chesnay, France. \nE-maik xleroy@marge.ux. inria. fr, weis@margaux. inria. fr. 1Survival kit for the reader unfamiliar with \nML: [ ] is the (poly\u00admorphic) empty list, [al; . ;an] the list with elements al . . . aw. ref z allocates \na new reference (indirection cell), initialized to z. r := x updates the contents of reference r by x. \n!r returns the current contents of reference r. Permission to copy without fee afl or part of this material \nis granted provided that tfte copies are not made or distributed for direct commercial advantage, the \nACM copyright notice and the title of the publication and its date appear, and notice is given that copying \nis by permission of the Association for Computing Machinery. To copy other\u00ad wise, or to republish, requires \na fee and[or specific permission. @ 1990 ACM 089791419-8/90/0012/0291 $1.50 Pierre Weis* INRIA Rocquencourt \n the list with 1 as single element an int list, indeed. Given its type, we can also consider T as having \ntype bool list Tef, hence head(!r) has type bool, and the if statement is well-typed. However, head (! \nr) evaluates to 1, which is not a valid boolean. This example shows that physical modification of data \ncompromises type safety, since it can invalidate static typing assumptions. As demonstrated here, the \nuse of polymorphic mu\u00adtable data (that is, data structures that can be mod\u00adified in place) must be restricted. \nAn obvious way to tackle this problem, used in early implementations of ML [3], is to require all such \ndata to have monomor\u00adphic, statically-known types. This restriction trivially solves the problem, but \nit also makes it impossible to write polymorphic functions that create mutable values. This fact has \nunfortunate consequences. A first drawback is that it is not possible to provide generic, eflicient implementations \nof most data struc\u00adtures (vectors, hash tables, graphs, B-trees, . . . ), as they require physical modification. \nEven a trivial func\u00adtion such as taking a vector of an arbitrary type and returning a copy of it is not \nwell-typed with the policy above, since it creates a vector with a statically un\u00adknown type. Another \ndrawback is that polymorphic mutable val\u00adues are prohibited even if they are not returned, but used for \ninternal computation only. As a consequence, most generic functions cannot be written in an impera\u00adtive \nstyle, with references holding intermediate results. Consider the familiar map functional: let rec applicative-map \n~ 1 = if null 1 then [] else f (head 1):: applicative. map ~ (tad 1) Here is an alternate implementation \nof map in impera\u00adtive style: let imperative. map f 1 = let argument = ref 1 and result = ref. [] in while \nnot (nuil !argument) do result := f (head ! argument) :: !r-esult; argument := tail !aryument done; reverse \n!7-esu/t Some ML type systems reject imperative.map as ill\u00adtyped. Others give it a less general type \nthan its purely applicative version. In any case, the imperative version cannot be substituted for the \napplicative one, even though they have exactly the same semantics. As demonstrated here, the programming \nstyle (imperative vs. applicative) interferes with the type specifications. This clearly goes against \nmodular programming. Some enhancements to the ML type system have been proposed [4, 16, 17, 1], that \nweaken the restrictions over polymorphic mutable data. Standard ML [11] incorpo\u00adrates some of these ideas. \nThese enhanced type systems make it possible to define many useful generic functions over mutable data \nstructures, such as the function that copies a vector. However, these systems are still not powerful \nenough: they fail to infer the most general type for the imperative.map example above; and they do not \nwork well in conjunction with higher-order func\u00adtions. Because of these shortcomings, Standard ML does \nnot provide adequate support for the imperative programming style. This is a major weakness for a general-purpose \nprogramming language. In this paper, we present a new way to typecheck mu\u00adtable data within a polymorphic \ntype discipline. Our type system is a simple extension of the one of ML. It permits type reconstruction \nand possesses the prin\u00adcipal type property. It requires minimal modifications to the ML type algebra. \nYet it definitely improves the support for imperative programming in ML. It allows generic functions \nover mutable data structures to have fully polymorphic types. It is powerful enough to assign to a function \nwritten in imperative style the same type as its purely applicative counterpart. For example, in this \nsystem, the imperative implementation of map can\u00adnot be distinguished from the usual, applicative one, \nas far as types are concerned. The remainder of the paper is organized as follows, In section 2, we introduce \ninformally our type system, and show the need for a more precise typechecking of functions. Section 3 \nformalizes the ideas above. We state the typechecking rules, show their soundness, and give a type reconstruction \nalgorithm. Section 4 briefly compares our approach with previous ones. We give a few concluding remarks \nin section 5.  Informal presentation In this section, we informally introduce our typing dis\u00adcipline \nfor mutable data, focusing on references to be more specific. Unlike the Standard ML approach, we do \nnot attempt to detect the creation of polymorphic references. What we prohibit is the use of a reference \nwith two diflerent types. The only way to use a value with several types is to generalize its type first, \nthat is, to universally quantify over some of its type variables. (In ML, the only construct that generalizes \ntypes is the let binding.) Hence, what we restrict is type general\u00adization: we never generalize a type \nvariable that may be free in the type of a reference, Such a type variable is said to be dangerous. Not \ngeneralizing dangerous type variables ensures that a mutable value always possesses a monotype. It remains \nto detect dangerous type variables at generalization-time. Though this suggests a complex and expensive \nstatic analysis, this turns out not to be the case: dangerous variables can be determined by mere examination \nof the type being generalized, as we shall now illustrate.  2.1 Datatypes Consider the example given \nin introduction: let r=ref [] in r := [1]; if head(!r) then ... else ... The expression ref [] has type \nA = CYlist ref. This type is a ref type, and Q is free in it, hence a is dan\u00adgerous in A. The let construct \ndoes not generalize a, hence a gets instantiated to int when typing r := [1], and typing if head(!r) \n. . . leads to a type clash. References may be embedded into more complex data structures (pairs, lists, \nconcrete datatypes). Fortu\u00adnately, the type of a data structure contains enough information to retrieve \nthe types of the components of the structure. For instance, a pair with type A x B contains one value \nof type A and one value of type B. Therefore, any variable which is dangerous in A or in B is also dangerous \nin A x B. For instance, in let r= ([], ref []) in e the expression ([], ref []) has type a list x ~ iist \nref, where ~ is dangerous but not cu. Hence in e, variable r has type Vcr. a list x /3 list ref. The \ntreatment of user-defined datatypes is similar. Parameterless datatypes cannot contain polymorphic data, \nso there is no dangerous variable in them. Pa\u00adramet erized datat ypes come in two flavors: those which \nintroduce new ref types (such as type a foo = A \\ B of a ref ), and those which don t. The former are \ntreat ed like re~ types: all variables free in their parame\u00adter(s) are considered dangerous. The latter \nare treated like product types: their dangerous variables are the dangerous variables of their parameter(s). \n  2.2 Functions 2.3 Functions with free variables Function types pretreated specially. Thereason is \nthat a value with type A + B does not contain a value of type A, nor a value of type B, h contrast with \nregular datatypes such as A x B or A list. Hence it seems there are no dangerous variables in type A \n-+ B, even if A or B contain dangerous variables themselves. For instance, the function let make.re~ \n= function x + ref x has type a + a Tej, and o. is not dangerous in it, so it is fully polymorphic. \nIt is actually harmless by itself. What s harmful is to apply malce.ref to a poly\u00admorphic argument such \nas [], bind the result with a let construct, and use it with two different types. But this is not possible \nin the proposed type system, since make-rej [] has type ~ list ref, and this type will not be generalized, \nas /3 is dangerous in it. In our approach, generic functions that create and return mutable ob\u00adjects \nare given very general types. Type safety is en\u00adsured by cent rolling what can be done with the result \nof their application, as described above. The analysis above is based solely on the type of the function \nresult. Hence, the usage of a polymor\u00adphic function is unrestricted if the function does not ret urn \nany references, as witnessed by the absence of rej types in its codomain type. This holds even if the \nfunction allocates references with statically unknown types for internal purposes, but does not return \nthem. For instance, this is the case for the imperative-map functional given in the introduction: it \nis given type Va, /3. (a --i ~) + Q list + ~ list, the very same type as its purely applicative counterpart \napplicative-map. The imperative-map functional can be substituted for applicative-map in any cent ext. \nIn particular, it can be applied to highly polymorphic arguments: the expres\u00adsion imperative. map (f \nunct ion x + x) [] is well:typed, and returns the fully polymorphic empty list, even though two references \nwere created with type a list ref. The type system guarantees that these ref\u00aderences are used consistently \ninside the function, and are not exported outside. Another strength of this type-based analysis is its \ngood handling of higher-order functions and partial applications. Consider the partial application of \napplicative-map to make.ref: our type system correctly recognize it as harmless, and gives it the fully \npolymor\u00adphic type Va. Q list + a rej list. This is not the case for ML type systems that attempt to control \nthe cre\u00adation of references (see section 4). The careful reader may have noticed a flaw in the dis\u00adcussion \nabove: we have neglected the fact that a func\u00adtion may possess free variables. Suppose that a function \n.f has a free variable r which is bound to a reference out\u00adside the function. Function ~ can access and \nupdate the reference, yet the type of T does not necessarily appear in the type of ~. A classic example \nis the functional presentation of references as a pair of functions, one for access, the other for update: \nlet finctional-ref x = let r=ref xin (function ()+ !r), (function z + r:=.) The expression functional.ref \n[] has type (unit + a list) x (a list + unit), where no type variable is dangerous, so it is fully polymorphic, \nyet it breaks type safety just as ref [ ] does. The problem is that the types of the free variables of \na function do not appear in the type of the function. In this context, it is useful to think of functions \nas closures. Closures, in contrast with any other data structure, are not adequately described by their \n(functional) type: we do not know anything about the types of the values contained in the environment \npart of a closure. Our solution is to keep track of what is inside a clo\u00adsure. We associate with any \nfunction type a set of types, the types of all variables free in the function. We could put this set \nof types as a third argument to the arrow type constructor. For technical reasons, we find it more convenient \nto add an extra level of indirection in record\u00ading this set of types. Therefore, each function type is \nadorned with a label. Labels are written L, M, and labeled function types are written A 1 B. Separately, \nwe record constraints on those labels. Constraints have the format A D L, meaning that objects of type \nA are allowed to occur in environments of type L. An envi\u00adronment of type L is not required to contain \na value of type A. It is not allowed to contain a value of a type B unless B D L is one of the recorded \nconstraints. This way, function type labels allow typings of the environment parts of closures. For instance, \nfunctional.ref now has type: hence jknctional_ref [] has type: thus revealing the presence of a polymorphic \nreference in each function of the pair, and preventing the gen\u00ad eralization of ~. The rule is that in \na functional type A ~ B, a variable Q is dangerous iff there exists a constraint C P ill with a dangerous \nin C. This typing of closures gives a precise account of the interleaving of internal computation and \nparameter passing in (curried) functions, and of the possible data sharing between invocations. For instance, \nit succeeds in distinguishing the following two functions: function () 4 ref [] : unit ~ a list 7-ef \nlet 7-=ref [] injunction () + r : unit 5 a list Tef with Q list Tef D L The former is harmless, since \nit returns a fresh refer\u00adence each time, so it can be generalized. The latter always return the same \nreference, which is therefore shared between all calls to the function. It must re\u00admain monomorphic, \nwhich is indeed the case, since Q is a dangerous variable in its type. Before presenting the type system \nformally, we now give the main intuitions behind the typing of closures. Constraints are synthesized \nduring the typing of ab\u00ad stractions, as follows: when giving type A z B to the abstraction e = f unct \nion z + . . . . for each variable y free in e, we look up the type Cy of y in the typing environment \nand record the constraint C y D ill. It is always safe to add new constraints, since the constraints \nover a label L are intended to give an upper bound for what can go inside closures of type L. (This may \nlead to less general types, however, since more vari\u00adables will be declared dangerous.) Unifying two \nlabeled function types A 5 B and C ~ D is easy: it suffices to identify both labels L and ill, resulting \nin a single label which bears the previous constraints on Jl as well as those on L. For instance, assuming \nf : int ~ int, the expression if ... then f else letz=linfunctionx~ z+.z has type int &#38; int as well, \nwith the additional con\u00adstraint that int p L. Finally, to give the most general type to function\u00adal, \nwe must be able to generalize over labels, in the same way as we generalize over regular type variables. \nConsider the functional: function f + 2+ (j 1) It must be possible to apply it to any function mapping \nintegers to integers, whatever its closure may contain. Yet if we give it the type (int 3 int) X int \nwithout generalizing over L, we could only apply it to functions without free variables, assuming there \nis no constraint over L in the current environment. Instead, the right typing is VL. (int 2 int ) M int. \nIn more complex sit\u00aduations, the current environment contains constraints over the label to be generalized. \nThese constraints are discharged in the type schema, and reintroduced at spe\u00adcialization time. Type schemas \ntherefore have the for\u00admat VV1 . . . Vn. A with I , where the Vi are either labels or type variables, \nand 17 is a sequence of constraints. 3 Formalization In this section, we formalize a calculus baaed \non the ideas above. 3.1 Syntax The language we consider is the core ML language, A\u00adcalculus plus a distinguished \nlet construct. We shall assume a built-in int type, with integer constants, The store is presented through \nthe type A Tef of references to a term of type A, and the operations ref(a), to al\u00adlocate a new reference \nto term u, !a to get the contents of the reference a, and a := b to update the content of a by b. We \nassume given a countable set Var of term vari\u00ad ables, with typical elements ~, y. In the following, i \nranges over integers. The syntax of terms, with typical elements a, b, is as follows: a ::= zli[k.a l(ba)lletz=ainb \nI ref(a) I!a Ia := b  3.2 Typechecking Type expressions, with typical elements A, B, have the following \nsyntax: A ::= Xlintl A~BIAr-ef In the definition above, X stands for a type variable, ranging over a \ngiven countable set TVar. Function types A ~ B are annotated by a label L, taken from a count able set \nLbl. LabeIs are distinct from term vari\u00adables and type variables. Type schemas, with typical element \nE, are composed of type expressions with some type variables and some labels universally quantified. \nThey also contain a se\u00adquence of constraints l?. Constraints have the format E~L. (IiWT) E1-i:intwithr \n E(z) =VX1... XJL~.. L~.Aw ithI (VARSPEC) Ei-x :A{Xi + B~, Lj +-J/lj} with I {Xi + Bi, Lj + ~j} u~ 13[z+A]l-b:Bvithl? \nfor ali y free in k. b, (E(y) D L) C r (FUN) Et-Ax. b: A5B with I E1-b:A<Bwith I E1-a:Awith P (APP) \nE1-(ba):Bwith17 Et-a: Awithr (Z, 17 ) = Gen(A, E, I ) E[x+x]l-b: Bwithr ur (LETGEN) E1-letx =ainb:Bwith17 \nUI E1-a:Awith I Eba:Arefwithr (REF) (DEREF) E~!a:Awithr E 1-ref(a) : A ref with I Eta: Arefwithr EF8:AWithr \n(ASSIGN) E1-a:=b:Awith17 Figure 1: The typing rules. To complete the definition above, we extend FV \nand DV to type schemas and to typing environments in the z ::= AI VV1... Vn, Auith17 obvious way: r .. \n< 6\\XbL,r FV((Vfi . . . V.. A with I ) with I ) = v ::= X]L FV(A with I u I ) \\ {Vl... Y n} Given a \ntype A in the context of a constraint se-DV((VVI . . . Vn. A with !7 ) with I ) = \\. , quence I_ , we \ndefine its free variables (labels as well as DV(A with 17U I ) \\ {Vl ...V.} type variables) FV(A with \n17) and its dangerous free FV(E with I ) = U FV(E(S) with I ) variables DV(A with I ) as follows. The \nintuition be-xCDom(E) hind the de fi~ition of F V is that the components of a functional type A 2 B are \nnot only A, B and L, but The typing rules are given in figure 1. They are very also any type expression \nC such that C ~ L is one of the similar to the rules for ML, except for the additional recorded constraints. \nhandling of constraints, reminiscent of the treatment of subtyping hypotheses in type inference systems \nwith IT (X with 17) = {x} subtypes [12, 6]. FV(int with l?) 0 The rules define the proposition term a \nhas type = A under assumptions E and constraints l? , written -W(A ref with I ) = FV(A with 17) E t-a \n: A with I . The typing environment E is a FV(A ~ B with 17) = {L} uFV(A with r) u partial mapping from \nterm variables to type schemas. FV(B with I ) u We write E[x + A] for the environment identical to E, \nU F V(Z with I ) except that x is mapped to A. We assume the usual set (8DL)@ operations are defined \nover constraints I in the obvious D1 (X with r) = 0 way. As in Standard ML [11, p. 21], the Gen operator \n ing as many type variables as possible in a type. Here, DV(A ~ B with I ) = u DV(Z with I ) we also \ngeneralize over labels whenever possible. In ad\u00ad(mL)Gr dition, we prohibit generalization over dangerous \ntype i[s] =% int(i) [s] Z[S] + e(z)[s] (kc. a)[s] + C1OS(Z, o,, el~v~a~)[s] el [z+!+] b[s] +% C1OS(Z, \nc, e~)[s~] a[sl] + Uz[sz] C[S2] * V3 [s3] (b a)[s] + v3[s3] U[s] =% 01[s1] b[s~] [=YJ zq[sz] a[s] + v[s \n] 1 z Dom(s ) (let x = a in b)[s] =% ?jz[sz] ref(a)[s] =% loc(l)[s [1 + v]] a[s] =% lochs ] a[s] A loc(/?)[sI] \nb[sl] =+ V[S2] !a[s] 4 s (l)[s ] (a:= b)[s] =3 V[S2[I -v]] Figure 2: The evaluation rules variables. \nA tentative definition would therefore be To account for run-time type errors, we introduce Gen(A, E,17) \n= VV1 . . . Vn. A where the set {Vl .,. Vn} the special result wrong, and state that if none of the is \nFV(A with I ) \\ DV(A with r) \\ IV(E with I ). evaluation rules match, then a[s] ~ wrong. This However, \nit would be incorrect to generalize over a vari-way, we can distinguish between type errors and non\u00adable \nwhich remains free in the constraint sequence used termination. later. Therefore, Gen also discharges \nin the schema all generic constraints, i.e. the constraints in 17 where 3.4 Soundness of typing one of \nthe Vi is free, and returns the remaining con\u00ad straints, to be used further in the typing derivation. \n The type system presented here is sensible with respect to the evaluation mechanism above: no well-typed \nterm Definition 1 (Generalization) Let A be a type ex\u00ad can evaluate to wrong. pression, E be a typing \nenvironment, 17 be a constraint Proposition 1 Let a be a term, A be a type, r be a sequence. Define: \nsequence of constraints such that we can derive 0 t-a ; {~... vn}= A with r. Then, for all stores so, \na[so] does not evalu\u00ad FV(A with I )\\ DV(A with 17)\\ FV(E with I ). ate to wrong; that is, we cannot derive \na[so] &#38; wrong. Let I be the sequence of those constraints Z b L in r The proof can be found in appendix. \nIt closely fol\u00ad such that L is one of the Vi. Then: lows Tofte s [16, chapter 5]. The crucial point is \nthat closure labels and constraints give a better control over Gen(A, E, I ) = (VK... V.. A with I ), \n(17\\ I ) the types of store locations than in ML. As a conse\u00adquence, a variable cannot be free in the \ntype of a loca\u00ad 3.3 Evaluation tion reachable from a value without being dangerous in the type of that \nvalue. This guarantees the soundness We give here an evaluation mechanism for terms of our of type generalization. \ncalculus, using structural operational semantics. The evaluation relation a[s] ~ v[s ] maps a term a, \nin the context of an evaluation environment e and a store .s,  3.5 Type reconstruction to some value \nu, and a modified store S1. Values have In this section, we consider an adaptation to our lan\u00adthe following \nsyntax: guage of the well-known Damas-Milner type reconstruc\u00adtion algorithm for ML (algorithm W of [5]), \nIn the fol\u00ad v ::= int(i) I c1os(X, a, e) I lot(l) lowing, we write rngu(A, B) for the principal unifier \nof Here, / ranges over a countable set Loc of locations. types A and l?, if A and B are unifiable. (Otherwise, \nStores are partial mappings from locations to values. the type inference algorithm fails.) Type expressions \nSince we assume call-by-value, evaluation environments are terms of a two-sorted free algebra, hence \nthis en\u00adare partial mappings from term variables to values. The sures the existence of a principal unifier, \nthat can be rules given in figure 2 define precisely the evaluation re-obtained by the classical unification \nalgorithm between lation, assuming standard left-to-right evaluation order. terms of a free algebra. \nLet a be a term, E be a typing environment, and I be an initial sequence of constraints. We define in~er(l?, \na, I ) as the triple (A, a, A), where A is a type expression, u a substitution and A a constraint se\u00adquence, \nas follows: 2n~er(E, i, r) = (int, Id, r) infer (E, Z, r) = let (VX~ ...Xn, L~ ... Lm. A with A) = E(z) \nlet Yl,... , Yn be fresh type variables (not free in E nor in A) andl.fl, ..., Mm be fresh labels let \nm= {Xi + u,Lj + ~j} in (mA, Id, r UaA)  zn~er(E, k. b, I ) = let X, L be fresh variables let @= {E(y) \nbL Iy free in Ax, b} let B,a, A = in~er(E[z + X], b,I u ~) in (aX 3 B,c, A) in~er(ll , (b a), I ) = \nlet l?, p,@ = infer (E, b, I ) let A, a, A = in~er(pE, a, Q) let X, L be fresh variables let p= mgu(aB, \nA3 X) in (pX, pap, pA)  infer(.E, let r = a in b, 17) = let A, a, A = in~er(E, a, I ) let D, A = Gen(A, \ncrE, A) let .l?, p, @ = in~er((ul?)[x +-2], b, A ) in (B, pm, ~) infer (E, ref (a), r) = let A, CT,A \n= in~er(E, a, I ) in (A ref, a, A) 2n~e~(E, !a, r) = let A, a, A = infer (E, a, I ) let X be a fresh \nvariable let p = mgu(A, X ref) in (pX, pcJ, wA) in~er(E, a := b, I ) = let A, a, A = in~er(E, a, 17) \nlet B, p, @ = in~er(aE, b, A) let p = mgw,(pA, B ref) in (pB, ppv, p~) This algorithm enjoys the good \nproperties of the Damas-Milner algorithm: it is correct and complete with respect to the typing rules, \nand the inferred type is the most general one. The proof is very similar to Damas proof [4].  3.6 Relation \nto ML We have introduced closure typing as a way to keep track of mutable values embedded in functions. \nAs a consequence, two expressions having the same func\u00adtional type in ML may now be distinguished by \ntheir closure type, and we may fear that this leads to a type system more restrictive than the one of \nML, Ideally, we would like the purely applicative fragment of our cal\u00adculus (that is, without the ref \ntype constructor, and the ref, := and ! term constructors) to be a conser\u00advative extension of ML: any \npure, closed term that is well-typed in ML should also be well-typed in our cal-CUIUS. Unfortunately, \nthis is not the case but for more subtle reasons than the one outlined above. Actually, two type expressions \nin our system cannot be distinguished by their closure labels only. The rea\u00adson is that unification cannot \nfail because of the labels: given the syntax of type expressions, a label can only be matched against \nanother label, and labels are treated as variables as far as unification is concerned. Therefore, in \nour system, unification between types is conservative with respect to unification between the corresponding \nML types. To be more precise, we introduce the strip operator J, that maps type expressions in our calculus \nto ML type expressions, by erasing the labels from func\u00adtion types: intJ = int XJ. =X (A ref)J = A.J \nref (A~B)J=AJ+B$ Then, two type expressions A and B are unifiable if and only if AJ. and BJ are, and \nin this case, taking cr = mgu(A, B) and p = mgti(AJ, B.J,), we have (aC)J = P(CJ) for all types C. This \nlemma, along with the close resemblance be\u00adtween our algorithm infer and Damae-Milner s W al\u00adgorithm, \nlead us to believe that, given the same pure term, both algorithms infer the same type, modulo clo\u00adsure \nlabels. However, this does not hold because of the generalization step in the case of a let construct. \nConsider the typing of let x = a in b. Assume that, starting from typing environment E, algorithm infer \ninfers type A with I for a, while algorithm W, start\u00ading from the corresponding ML typing environment \nEJ, infers the corresponding ML type Al. We must check that both algorithms generalize exactly the same \ntype variables, im that they will type b in compatible envi\u00adronments. This could be not the case for \ntwo reasons. The first reason is that algorithm infer does not gen\u00aderalize dangerous type variables, \nwhile W does. But this is no problem here, since we consider only the pure fragment of our cakulus, without \nthe Tef type construc\u00adtor, hence the set of dangerous variables of any type is always empty. The second, \nmore serious reason is that closure typ\u00ading int reduces additional free variables in a given type. In \ngeneral, FZ V(A with I ), the set of free type vari\u00adables in A with 17, is a superset of I V(AJ). (Take \nfor instance A = int 2 int and r = X bL.) Soit isnot obvious that FZ V(A with 17) \\ IL! V(.E with I ), \nthe set of type variables generalized by in~er, is the same as FV(AJ.) \\ FV(EJ); the set of type variables \ngeneral\u00adized by W. Indeed, there are cases where infer does not generalize some type variable X, while \nW does, because X is free in E with I , but not in EJ. Consider: Az.let id = Az. (if ... then z else \n(~~. x; y)); z in idid Assuming z : X and y : Y, the term (Jy. x; y) is given type Y ~ Y with X D Al, \nand the if construct forces z to have the same type. Therefore, when we attempt to generalize X 3 X (the \ntype of k. . . . . z), we have E(z) = Y ~ Y under constraints I = X >M, Y ~ Y ~ L, and we cannot generalize \nover X, since it is free in the type of .z. Hence, id remains monomorphic, and the application id id \nis ill-typed. In ML, we would have z : Y + Y, so we could freely generalize over X, getting id : VX. \nX + X, and the whole term would be well-typed. The example above is quite convoluted, and it is the simplest \none we know that exhibits this variable cap\u00adture through labels phenomenon. We need more expe\u00adrience \nwith the proposed type system to find whether this phenomenon happens in more practical situations. However, \nin case this turns out to be a serious flaw of our closure typing system, we are investigating two possible \nimprovements that seem to avoid variable cap\u00adtures. One direction is to record less constraints when \ntyp\u00ad ing a A-abstraction, In the example above, one could argue that the constraint XD&#38;f should not \nbe recorded, on the grounds that x is not actually used in the body of the function, as witnessed by \nthe fact that the type variable X is not free in the type of the function result, nor in the type of \nthe parameter. The other direction is to check that two function types are compatible without actually \nidentifying their closure types. This way, we could avoid the propagation of the constraint X D ikf to \nthe type of z.  3.7 Pragmatic of constraint handling Practically, the main concern with the type inference \nalgorithm above is the additional overhead introduced by the handling of constraints. First, it is possible \nto simplify sequences of constraints. Here are some possi\u00adble simplification rules: EPM, EPM -+ EPlw \nEPM -i 6 if Z is closed AxBb~ + Ab&#38;f,Bb~ These three simplifications are obviously sound with respect \nto the computation of free and dangerous vari\u00adables. The third rule actually generate more con\u00adstraints, \nbut this may open the way to further simplifi\u00adcations, e.g. if A = 1?, or if A is closed. In addition, \nconstraint handling becomes quite cheap if we distribute constraints inside types, instead of han\u00addling \na single list of constraints. We suggest grouping together all constraints over the same label L, arranged \nas a list of type schemes. This list represents the label L itself. To identify two iabels, we just have \nto con\u00adcatenate the two lists, and this can be done in constant time, using e.g. difference lists. Hence, \nwhen unifying two type expressions A and B, the additional work of identifying labels takes time at most \nproportional to the size of A, B. Therefore, unification can be performed in linear time, as in ML. \n 4 Comparison with other type syst ems In this section, we compare our type system with pre\u00advious proposals \nof polymorphic type systems for lan\u00adguages featuring physical modification, 4.1 Standard ML We consider \nfirst the systems proposed for ML. All these systems rely on detecting the creation of mutable val\u00adues \n(e.g. by special typechecking rules for the ref con\u00adstruct), and ensuring that the resulting mutable \nvalues have monomorphic type~. The first system we consider is the one proposed by Tofte [16, 17], and \nadopted in Standard ML [II]. It makes use of weak type variables (written with a * su\u00adperscript) to prohibit \npolymorphic references. Weak type variables cannot be generalized by a let binding, unless the corresponding \nexpression is guaranteed to be non-expansive, i.e. that it does not create any refer\u00ad ences. Damas [4] \nproposed a related, but slightly dif\u00ad ferent scheme, that gives similar results in most cases. Standard \nML rnake.re~ &#38; + a re~ mdce.ref [] rejected imperative-map (a + p ) + Cl* list + B* list imperative.map \nid [] rejected applicative-map make-ref rejected id malie-ref rejected (raise Ezit : a ref) CYref Figure \n3: Comparison The other system is an extension of Tofte s, used in the Standard ML of New Jersey implementation \n[11. In this scheme, type variables are no longer partitioned into weak and non-weak variables; instead, \neach type variable has an associated integer, its degree of weak\u00adness , or strength . This degree measures \nthe number of abstractions that have to be applied before the cor\u00adresponding reference is actually created. \nRegular, un\u00adconstrained type variables have strength infinity. Vari\u00adables with strength zero cannot be \ngeneralized. Vari\u00adables with strength n >0 can be generalized, but each function application decrements \nthe strength of vari\u00adables. The comparative results are given in figure 3. For each test program, we \ngive its most general type in each system. We assume these are top-level phrases. As in most ML implementations, \nwe reject top-level phrases whose types cannot be closed (because some free vari\u00adables cannot be generalized). \nThe first test is the make_ref function, defined as function z + ref x. It exercises the possibility \nof writing generic functions that create and return up\u00addatable data structures. Most functions over vectors, \nmatrixes, doubly linked lists, . . . are typed similarly. All type systems considered here capture the \nfact that make.ref should be applicable to monomorphic values only. The second test is the imperative. \nmap functional given in the introduction. It illustrates the use of poly\u00admorphic references as auxiliaries \ninside a generic func\u00adtion. Our type system is the only one which gives a fully polymorphic type to imperative \n_rnap. The others restrict it to be used with monomorphic type. The third test is the partial application \nof applicative_map, defined in the introduction, to the make-w$ functkm. It e~erciees the compatibility \nbe\u00adtween functions that create mutable data and higher\u00adorder functions. SML and SML-NJ refuse to generalize \nits type, hence reject it. They are unable to detect that SML-NJ Our system al + al rej a~are~ rejected \nrejected (a +@) + (C J@LYlistz + list a= list p= ~listwitha5~bN rejected o! list reject ed a list 3 \n@ ref list rejected cy2~ref a ref rejected with other type systems applicative. map does not apply make-ref \nimmediately, hence that applicative-map make-ref does not create any polymorphic reference. A simplified \nversion of this test, shown below, is to apply the identity function id to the make-ref function. Our \ntype system gives the same type to id make-ref and to make -ref, The others don t, and we take this as \nstrong evidence that they do not handle full function\u00adality correctly. The last example illustrates a \nweakness of our type\u00adbased approach. By using exceptions, for instance, one may mimic the creation of \na reference as far as types are concerned, without actually creating one. In the expression (raise Exit \n: a ref ), our type system con\u00adsiders that a is dangerous and does not generalize it. Other type systems \nrecognize that no references are cre\u00ad ated, hence they correctly generalize it. This flaw of our method \nhas little impact on actual programming, how\u00ad ever.  4.2 Quest In our system, we made no attempt at \nrestricting the creation of mutable values, and concentrated on type generalization instead. We were \ninspired by Cardelli s Quest language [2], which departs significantly from ML, but features mutable \ndata structures and polymor\u00adphic typing. Quest makes almost no typing restrictions for muta\u00adble values. \nSoundness is ensured by different seman\u00adtics for type specialization. Namely, an expression with polymorphic \ntype is evaluated each time its type is spe\u00adcialized, in contrast with ML, where it would be eval\u00aduated \nonly once. This is consistent with the fact that polymorphism is explicit in Quest programs: polymor\u00adphic \nobjectg are actually pregented aQ functions that take a type as argument and return a specialized ver\u00adsion \nof the object. But these semantics are incompat\u00adible with ML, where generalization and specialization \n299 are kept implicit in the source program. 4.3 FX The FX effect system [9] is a polymorphic type system \nthat performs purity analysis as well: the type of an expression indicates what kind of side-effects \nits eval\u00aduation can perform. This provides a simple way to deal with the problem of mutable values: the \ntype of an expression cannot be generalized unless this expres\u00adsion is referentially transparent. It \nis easy to see that such pure expressions can safely be used with differ\u00adent types. Though this approach \nis attractive for other purposes (e.g. automatic program parallelization), it definitely does not address \nthe main issue considered here: how to give the same type to semantically equivalent func\u00adtions, whether \nwritten in applicative style or in impera\u00adtive style. The reason is that the purity analysis of FX makes \nit apparent in the types whether a function al\u00adlocates mutable data for local purposes. For instance, \nimperative. map and applicative. map do not have the same type in FX.   5 Conclusion We have presented \nherein an extension of the ML type system that considerably enhances the support for data accepting in-place \nmodification. This is a significant step toward the integration of polymorphic type disci\u00adpline and imperative \nprogramming style. We have in\u00adtroduced the notion of closure typing, which is essential to the soundness \nof this approach. We have given one type system that performs this closure typing, based upon labels \nand constraints. Our system is simple, but falls short of being a conservative extension of ML. Fur\u00adther \nwork includes investigating alternate, more subtle ways to typecheck closures, that would not reject \nany well-typed ML program, while correctly keeping track of mutable data. The scope of this work is not \nstrictly limited to the problem of mutable data structures, For instance, it is well-known that polymorphic \nexceptions raise the same issues as references, and can be handled in the same way. More generally, similar \nproblems arise in the in\u00adtegration of polymorphic typing within several other programming paradigms. \nFor instance, one approach to the integration of functional and logic programming is to allow partially \ndefined values containing logical variables within a conventional functional language [15]. Polymorphic \nlogical variables break type safety just as polymorphic references do, and are amenable to the same treatment. \nIn object-oriented programming, sta\u00adtus variables of objects can be seen as references sys\u00adtematically \nencapsulated in functions (the methods). Closure typing seems relevant to the polymorphic type\u00adchecking \nof such objects. Finally, some calculi of com\u00admunicating systems feature channels as first-class values \n[10]. Polymorphic typing of these channels must guar\u00adantee that senders and receivers agree on the types \nof transmitted values, and this is similar to ensuring that writers and readers of a reference use it \nconsistently [13]. Acknowledgments Didier R6my suggested the use of constraints in the typing rules. \nWe also benefited from his expertise in type inference and unification problems. Many thanks to Brad \nChen for his editorial help.  A Proof of soundness In this appendix, we sketch the proof of soundness \nof the type system with respect to the operational semantics given in section 3.3. We formalize the fact \nthat a value v semantically be\u00adlongs to a type expression A under constraints I . We write this S ~ v \n: A with 17. The hypothesis S is a store typing, that is, a partial mapping from locations to type expressions. \nThe store typing is needed to take into account the sharing of values introduced by the store. Definition \n2 (Semantic typing judgments) Let S be a store typing, v a value, A a type, 17 a constraint sequence. \nThe predicate S ~ v : A with I is defined by induction on v: S ~ int(i) : ?M with r.  S + 1oc(4) : \n(A ref) with 17 @ / belongs to the domain of S, and S(t) = A.  S # clos(z, b,e) : (A ~ B) with 17 zff \n for all x c Dom(e), there exists a type schema E such that DbAI is in I , and S \\ e(x) : E with l?; \n and there exists a typing environment E such that E[z + A] 1-b:B with r.   The predicate above is \nextended to type schemas by tak\u00adzng S > v : (VW... V.. A with I ) with I ifl for all substitutions p \nover VI . . . V j we have S ~ v : PA with r u~r Let e be an evaluation environment, and E be a typ\u00ading \nenvironment. We say that S > e : E with r ifl Don(e) ~ Dorn(E) and for all z c Dorn(e), we have S > \ne(z) : E(z) with I . Similarly, let s be a store. We say that ~ s : S with I ij Dom(s) ~ Dorn(S) ana! \nfor ajz / 6 Don(s), we have S ~ s(I?) : S(./) with I . In the proof of soundness, we will use the fact \nthat the semantic typing judgement is stable under substitution. Lemma 1 (Semantic substitution) 1 S \n+ v : A with I , then pS /= v : pA with p17 for all substitutions P. Starting from a given value v, it \nis not possible in general to access any location in the store, The set R(v) of locations reachable from \nv is defined by induction on v, as follows. Definition 3 (Reachable locations) R(int(i)) = 0 R(loc(l)) \n= {f} l?(clos(z, a, e)) = u R(e(Y)) ~~~orn(e) In the definition of S # v : A with 17, the types of the \nlocations that cannot be reached from v are irrele\u00advant. We can actually assume any other type for those \nlocations: Lemma 2 (Garbage collection) Let S, S he two store typings such that S(l) = S (l) for all \n1 c R(v). If S~v:Awith I , then S ~v:A with I Our type expressions are informative enough to allow us \nto connect the type of a location 1 reachable from a value v with the type A of v, More precisely, we \nhave the following key lemma which relates the variables free in the type of 1 with the dangerous variables \nof A. Lemma 3 (Store typing control) Assume S + v : A with I . Let! be a location in R(v). Then FV(S(I) \nwith I ) g DV(A with r). Proof: By induction on v. Case 1: A = int and v = int(i). Obvious, since there \nare no locations reachable from v. Case 2: A = B ref, v = 1oc(P), and S(/ ) = B. By definition of the \nreachable locations, 1 = 1 . Hence FV(S(l) with 17) = FV(B with r) = DV(A with I ). Case 3: A = AI ~ \nAz, and v = C1OS(X, a,e). Let y be a variable such that 1?is reachable from e(y). Let Z be a type scheme \nsuch that S ~ e(y) : Z and (S p L) c I . We write YVI ... V.. B with 17 for Z. For all substitutions \np over V1 . . . Vn, since S + e(y) : @ with I U @ , we get by induction hypothesis: Fv(s(l) with r u \n~r ) ~ Dv(pl? with r u pr ) Taking well-chosen substitutions V, it follows that: FV(S(l) with l?) s DV(B \nwith 17 u I ) \\ {VI... V.} Hence the desired result: FV(S(l) with I ) ~ DV(Z with r) C DV(A with I ) \n1 We are now ready to show the soundness of the typing rules. Proposition 2 (Soundness) Assume E 1-a \n: A with 17. Let e be an evaluation environment, s a store, S a store typing such that: S+e:Ewith I +s:SWithr. \nAssume a[s] ~ w. Then, w = v[s ], and there exists a store typing S extending S, such that: S +u:AWithr \n~ s : S with r Proofi By induction on the length of the evaluation. All cases proceed as in Tofte s proof \n[16, chapter 5], except when a is a let binding. Then, the last step of the typing derivation is: E1-a:Awithr \n(~, I ) = Gen(A, E, I ) E[x+---#Z] b:l?Withl? l? EFletz= ainb:B with I Applying the induction hypothesis \nto the first premise, we get v., Sa, S. extending S such that: a[s] A v. [s.] Sa~va:AwithI + S. : S. \nwith 17. To apply the induction hypothesis to the last premise, we need to show that: S= + e[z + v.] \n:E[x t-E] with 17 where we write (Z, I ) for Gen(A, E, I ), and Vvl ..! V.. A with l? for Z. Since S. \nextends S, and VI ,.. V. are not free in E, we already have S. # e : E with 17 as a corollary of lemma \n2. It remains to show that: Sa+va:(vvl . . . V.. A with r ) with I . To do so, we must prove that, for \nany substitution p over the Vi, (1) sa + V.: MA with r u fir . Since S. ~ v. : A with I , we have, by \nlemma 1, [9] J. M. Lucassen and D. K. Gifford. Polymorphic effect systems. In Proc. Symp. Principles \nof Pro\u00ad (2) @. ~ V. :PA with ~1 . gramming Languages, 1988. By definition of Gen, none of the ~ appears \nin any [10] R. Milner, J. Parrow, and D. Walker. A calculus constraint of 17 , hence of mobile processes: \npart 1. Research report ECS\u00adLFCS-89-85, University of Edinburgh, 1989. (3) ~(r) = ~(17 u r ) = r u pr \n. [11] R. Milner, M. Tofte, and R. Harper. The definition By lemma 3, for any location 1 reachable from \nv., we of Standard ML. The MIT Press, 1990. have FV(Sa(l) with I ) s DV(A with I ), and none of the Vi \nis dangerous in A with I , hence none of the Vi [12] J. C. Mitchell. Coercion and type inference. is \nfree in S.(1). Therefore, In Proc. Symp. Principles of Programming Lan\u00adguages, 1984. (4) (pS.)(/) = S.(l) \nfor all 1 C R(va) [13] J. H. Reppy. First-class synchronous operations and the claim (1) above follows \nfrom (2), (3), (4), and in Standard ML. Technical Report TR 89-1068,lemma 2. Therefore, we can apply \nthe induction hy-Cornell University, 1989. pothesis to the right branch of the typing derivation, getting \nWb, ~b, sb extending S. such that: [14] J. C. Reynolds. Toward a theory of type structure, In Colloquium \non Programming, volume 19 of Lec\u00ad (3[s.] [=$ ]vb[sb] ture Notes in C omputer Science. Springer-Verlag, \n1974. which is the expected result. o [15] G. Smolka. FRESH: a higher-order language with unification \nand multiple results. In Logic Pro\u00adgramming: Functions, Relations, and Equations. Prentice-Hall, 1986. \n References [16] M. Tofte. Operational semantics and polymorphic [1] A. W. Appel and D. B. MacQueen. \nStandard ML type inference. PhD thesis, University of Edin\u00adreference manual (preliminary). AT&#38;T Bell \nLab\u00adburgh, 1987. oratories, 1989. [17] M. Tofte. Type inference for polymorphic refer\u00ad [2] L. Cardelli. \nTypeful programming. Research re\u00adences. To appear in Information and Computation, port 45, DEC Systems \nResearch Center, 1989. 1990. [3] G. Cousineau and G. Huet. The CAML primer. Technical report 122, INRIA, \n1990. [4] L. Damas. Type assignment in programming lan\u00adguages. PhD thesis, University of Edinburgh, \n1985. [5] L. Damas and R. Milner. Principal type-schemas for functional programs. In PTOC, Symp. Principles \nof Programming Languages, 1982. [6] Y.-C. Fuh and P. Mishra. Type inference with sub\u00adtypes. In ESOP \n88, volume 300 of Lecture Notes in Computer Science, pages 94 1 14. Springer Ver\u00adlag, 1988. [7] J.-Y. \nGirard. Interpretation fonctionnelle et &#38; lamination des coupures de 1 arithmktique d ordre sup%eur. \nTh>se d Etat, Universit6 Paris VII, 1972. [8] M. J. Gordon, A. J. Milner, and C. P. Wadsworth. Edinburgh \nL CF, volume 78 of Lecture Notes in Computer Science. Springer-Verlag, 1979.  \n\t\t\t", "proc_id": "99583", "abstract": "", "authors": [{"name": "Xavier Leroy", "author_profile_id": "81100078576", "affiliation": "Ecole Normale Sup&#233;rieure, B.P.105, 78153 Le Chesnay, France", "person_id": "PP39026141", "email_address": "", "orcid_id": ""}, {"name": "Pierre Weis", "author_profile_id": "81100380431", "affiliation": "INRIA Rocquencourt, B.P.105, 78153 Le Chesnay, France", "person_id": "P227434", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/99583.99622", "year": "1991", "article_id": "99622", "conference": "POPL", "title": "Polymorphic type inference and assignment", "url": "http://dl.acm.org/citation.cfm?id=99622"}