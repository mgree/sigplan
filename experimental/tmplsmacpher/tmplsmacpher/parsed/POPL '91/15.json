{"article_publication_date": "01-03-1991", "fulltext": "\n A Dynamic Extent Control Operator for Partial Continuations * Christian Queinnect Bernard Serpette$ \nEcole Polytechnique &#38; INRIA-Rocquencourt Abstract: A partial continuation is a prefix of the computation \nthat remains to be done. We propose in this paper a new operator which precisely controls which prefix \nis to be abstracted into a partial continua\u00adtion. This operator is strongly related to the notion of \ndynamic extent which we denotationally characterize. Some programming examples are commented and we also \nshow how to express previously proposed control operators. A suggested implementation is eventually discussed. \nKeywords: continuation, partial continuation, dy\u00adnamic and indefinite extent, escape feature. Continuations \nwere introduced within denotational semantics to express the rest of the computation in these cases where \nsome constructs of a language can alter it. Non local exits or jumps (stop, goto), ex\u00adception handling, \nfailure semantics in Prolog-like lan\u00adguages are usually described with continuations [Stoy 77, Schmidt \n86]. The Scheme language [Rees &#38; Clinger 86] offers procedural first-class continuations with in\u00addefinite \nextent. Like functions (lexical closures) which reinstall the environment of variables that was active \nwhen they were defined, continuations reinstall the rest of the computation which remains to be done \nwhen they were defined. Continuations have been proved to be valuable tools in Scheme where they are \nused to program non local exits [Haynes &#38; Friedman 87b], *Thk work has been partially funded by GDR \nProgrammation. t LIX, ~cole Polytechrique, 91128 Palaiseau Cedex, France, Email address: queinnec~poly \n.polytechnique .fr $INRIA Rocquencourt, Domaine de Voluceau, 78153 Le Chesnay Cedex, France, Email address: \nserpett e@inria. f r Permission to copy without fee all or part of this material is granted provided \nthat the copies are not made or distributed for direct commercial advantage, the ACM copyright notice \nand the title of the publication and its date appear, and notice is given that copying is by permission \nof the Association for Computing Machinery. To copy other\u00adwise, or to republish, requires a fee and/or \nspecific permission. @ 1990 ACM 089791-419-8/90/0012/0174 $1.50 multitasking [Wand 80], engines [Haynes \n&#38; Friedman 87a] etc. The problem of continuations is that they are too powerful [Haynes &#38; Friedman \n87b] since they reify [Friedman &#38; Wand 84] the whole rest of the computa\u00adtion. To call one of them \nmeans losing control since they never return. A partial continuation [Johnson 87] is only a prefix of \nthe computation that remains to be done. A partial continuation is thus a function that returns to its \ncaller therefore partial continuations are composable like regular functions. Yet full con\u00adtinuations \nare still useful since they allow imperative (abortive) transfer control. Programming languages widely \ndiffer with their of\u00adfer of continuations. Continuations can be first-class or not, procedural or not, \nbe accessed from a different namespace or from the regular lexical variable-environ\u00adment. Continuations \ncan have a dynamic or indefinite extent, they can behave lexically or dynamically. More\u00adover two main \nuses of continuations can be recognized. First, continuations are a non-local exit facility and can be \nmet in COMMON LISP as block/return-from or catch fthrow, in Modula-3 as try exceptiraise and in C as \nset jmpilong j mp. These constructs allow to escape from a computation and to return to a previous control \npoint. They are often used to handle excep\u00adtional situations. Since these continuations can only be used \nwhile in their dynamic extent, their implemen\u00adtation is therefore very efficient. The second use of continuations \nis particular to Scheme and is closely related to their indefinite extent. A computation may be reified \n(frozen) into a continu\u00ad ation, passed along as a normal value and finally un\u00adfrozen later on. This allows \nto easily implement a non preemptive multitasking facility [Wand 80]. But the most intriguing feature \nthat makes them differ from threads (or lightweight processes) is that continuations are immutable objects \nthat may be resumed more than once. From a naive implementation side, reifying a con\u00adtinuation roughly \ncorresponds to save the current eval\u00aduation stackl; resuming a continuation reinstalls the 1This is straightforward \nfor heap-based implementation of the 174 saved stack overwriting the current stack. The evalua\u00adtion \nstack represents the above mentioned rest of the computation therefore, to copy back a saved stack im\u00adplies \nthat these continuations are not composable since there is no means to return to an overwritten stack. \nPartial continuations are usually based on a couple of features: one which marks the beginning of contin\u00aduations \nthat might be abstracted late]r on and another feature which reifies them, Several models of partial \ncontinuations exist: mainly [Felleisen &#38; Wand &#38; Fried\u00adman &#38; Dubs 88] with run/control and \n[Danvy &#38; Fil\u00adinski 90] with reset/shift. These constructs do not permit to easily pair related control \noperators i.e. to precisely specify up to which context partial continua\u00adtions must be reified. The paper \ntherefore presents, in tlhe framework of Scheme, a new control operator named splitter (cf. section 2) \nwhich creates pairs of associated control operators: one is a non-local exit facility whilst the other \nreifies partial continuations upto the point where splitter was called. Various dressings for splitter \nare compared in section 4 as well as how they are typed. The splitter construct reconciles the two previ\u00adously \nrecognized uses of continuations: dynamic extent full continuations and indefinite extent partial contin\u00aduations. \nThe basic idea is that a classical evaluation stack (or a list of linked activation records) may be marked \nin order to be later on split into two parts: the lower part, under the mark, represents the rest of \nthe computation that can be escaped into. The upper part, above the mark, may be abstracted into a partial \ncon\u00adtinuation and therefore multiply applied, stored etc. A partial continuation abstracts the lpart \nof the con\u00adtrol between a mark and the point where it is reified. Therefore partial continuations can \nonly be taken upto a mark which must exist i.e. be in the dynamic extent of the progenitor splitter, \ncf. section 1. Eventually the paper suggests an implementation technique inspired from, at least, [Danvy \n87] and [Hieb &#38; Dybvig &#38; Bruggeman 90] that avc)ids copying ac\u00adtivation records from and back \nto stack (cf. section 5). A partial continuation freezes its associated ac\u00adtivation records. Popping \nframes from the stack is non-destructive since it is only a pointer translation. Conversely pushing new \nframes may overwrite frozen frames. An extra pointer (free-stac:k) exists above which it is always possible \nto push new frames. To push frames in a regular zone is done as usual i.e. relatively to the regular \nstack pointer; conversely to push frames in a frozen zone is done relatively to free-stack with the necessary \n(and then explicit) control links. This tech\u00adnique allows allocating mutable locations in the stack since \nthese locations are not duplicated. evaluation stack i.e. a linked list of activation records; it usually \ninvolves some copy for stack-based implementation [Clinger 88, Hieb &#38; Dybvig &#38; Bruggeman 90]. \n1 Semantical Framework This section presents much of the semantics of a Scheme-like language and formalizes \nour conception of dynamic extent, see also [Steele 90, chapter 3]. The term extent refers to a period \nof time: the life\u00adtime of an entityz. Any entity of Scheme has an indefi\u00adnite extent i.e. entities exist \nforever. In most languages (Scheme excepted) applications have a dynamic extent. The extent of the application \nof a function on its argu\u00adments is the time during which is computed the body of the function, this includes \nthe time taken by the computation of all subforms that appear in this body. In that sense, dynamic extents \nare always nested or disjoint. When the language offers non-local exits, the dynamic extent of an application \nmight be interrupted before its natural end which is when the function re\u00adturns a value to its continuation. \nTo finish a dynamic extent forces the end of all inner-nested dynamic ex\u00adtents. Dynamic extent is strongly \nrelated to the height of the evaluation stack and governs the possibility of stack-allocating various \nentities such as lexical environ\u00adments. It is a common compiling optimization to deter\u00admine (or conservatively \napproximate) the exact extent that entities have and to allocate them accordingly. n-Prog = The set of \nfowns v Id = The set of identifiers Env =Id ~ LOC a Loc = The set of locations u Store = Loc -i Val &#38; \nVal = Fun+ Pair +Num +... pllm= Val* x Store x Ext x Cent ~ PAns K Cent = Store x Val x Ext + PAns < \nExt = Loc ~ Bool E = Prog ~ Env x Store x Ext x Cent -+ PAns S = Prog* -Env x Store x Ext x Cent _ PAns \nP Figure 1: Domains of Scheme with explicit dynamic extent When continuations have an indefinite extent \nas in Scheme, it is possible that an expression multiply re\u00adturn results. In that case the concept of \napplications having a dynamic extent must be precisely defined. We therefore propose a denotational semantics \nfor Scheme formally expressing our notion of dynamic extent. The main question concerning an entity with \nsuch an ex\u00adtent is whether it is alive or not ? We thus add the do\u00admain Ext to the standard denotation \nof Scheme [Rees &#38; Clinger 86] mapping active locations to the boolean true, see figure 1. Initially \nno location is active. Like the store, this map is passed to functions and con\u00ad 2 First-or second-class \nobjects form entities. 175 tinuations. Locations were chosen since they can be compared and thus distinguished. \nThe PAns domain is the domain of partial answers yielded by regular (splitter-free) computations. This \ndomain will be explicated when describing the semantics of splitter. Except for PAns which stands as \nif it is the domain of the final answers and Ext which is not yet used, the denotations are fairly standard \nand should not pose problems, see figure 2. 2 The splitter operator The Scheme philosophy tries to reduce \nthe number of special forms (even if introducing very special functions like call/cc), sticks to a single \nnamespace and makes nearly all concepts first-class citizens. Le jin dzt fin is to represent new concepts \nprocedurally. We thus express our solution with respect to these tenets: a single function, named split \nt er, is necessary: (splitter (lambda (abort cuil/z.w) ezpressz on) ) ) with (abort (lambda () . ..)) \nand (call/pc (lambda (c) . ..)) and (c expression) When splitter is invoked, the evaluation stack is \nmarked. The argument of splitter is a binary func\u00adtion which is then applied on two new synthesized func\u00adtions \ntied to this mark. These two functions can only be safely invoked during the dynamic extent of splitter \notherwise they provoke a run-time error. If neither abort nor callipc is used, splitter returns what \nre\u00adturns its argument. (splitter (lambda (abort call/pc) foo )) + foo  The first function abort takes \na single argument, a thunk, and invokes it with the continuation of splitter as continuation. This allows \nto abandon a computation and to return to the level of the mark set by the progenitor splitter. For instance, \nto multiply the elements of a list of numbers and exit if a zero is found, may be written as: (define \n(multllst 1) (splitter (lambda (abort call/pc) (define (mult 1) (if (pair? 1) (if (= (car 1) O) (abort \n(lambda () O)) (* (car 1) (mult (cdr l))) ) 1)) (mult 1) )) ) When abort is invoked, all waiting computations \nupto splitter are discarded and the thunk (lambda () O) is invoked as if it replaces the original splitter \n form. The second function cal!/pc3 takes an unary function as single argument. It then reifies the partial \ncontinua\u00adtion upto its parent splitter and invokes its argument on it. When reified, the partial continuation \nis left in place i.e. is still the current continuation. For instance, (splitter (lambda (abort call/pc) \n(cons (call/pc (lambda (c) ; c = (A (x] (cons x a)) (cons b (c (c d))) )) a ))) This form returns ((b \n. ((d . a) . a)) . a). As regular objects, abort and caii/pc have an indef\u00adinite extent but since they \nremove or reify the par\u00adtial continuation upto the associated parent splitter, they must be invoked in \nthe dynamic extent of splitter: their safe behavior has a dynamic extent. Contrarily the reified partial \ncontinuation has an in\u00ad definite extent behavior; once created, it can be used forever: ( (cdr (splitter \n; returns (a partial-cent) (lambda (abortl call/pcl ) (cons a (splitter (lambda (abort2 call/pc2) (cons \n ~~all/pcl (lambda (c) ; c = (A(x) (cons a (cons b z))) (abort2 (lambda () c)) ))))))))) )C ) ~(ab. c) \n Since partial continuations have an indefinite ex\u00adtent behavior, splitter can be used to simulate the \ncall/cc operator of Scheme. A toplevel expression of regular Scheme is equivalent to the following: (splitter \n(lambda (abortO call/pc) (let ( [call/cc (lambda (f) (call/pc (lambda (c) (f (lambda (v) (aborto (lambda \n() (c v) )) )))) )1) expression ) ) ) There is no restriction on expression which can arbi\u00ad 3 call/pc \nstands for (call with partial continuation . 4 A slight difference might exist if one uses a toplevel \nloop since a new call/cc is synthesized every cycle. 176 let K = Au p( . let K = Au &#38;* ( .$o(&#38;* \n, u , ( , K) in &#38;*[7r*](p, u , ( , ~ ) in ~[nj(p, u, (, d) $*[7r T*] = @7<K. let /$ = k c( . let \nK = Au s < .lc,d , < &#38; > gc , ( ) in ~ [m ](p, a , ( , K ) in :[TI(A U,<, K ) t ~ = Apa<K.K(a, <>,<) \nPinit (v) = W ong( undef ined variable , v) a~n~t(cr) = wrong( Unknown location , a) Figure 2: Semantics \nof main Scheme special forms trarily invokes call/cc or splitter without interfer-The splitter operator \nfirst extends the set of active ence. objects with a fresh location yielding ( . It then creates abort \nand call/pc (p and p ) and invokes its argument on them. The new continuation is tcretu,~ while the The \nsplitter function separates two effects i.e. former K is pushed onto K*. When a value is sent toreifying \nthe partial continuation and removing it from Rreturn, ~,etti,n will consider the current sequence of \nthe current continuation, The abort function is a kind continuations and send the value to the first \nof them. of tail-recursivor which takes a thunk and invokes it The abort function just invokes its argument \nat theas if it was in tail position with respect to the associ\u00adlevel of splitter: it resets the set of \nactive objectsated splitter. abort clearly involves a side-effect on and the continuation to these of \nsplitter. Contrarilycontrol. It closely corresponds to how exceptions are calZ\\pc does not affect the \nset of active objects. Observesometimes handled: the erroneous cornput ations is es\u00adthat last and butlasi \naccess K from the tail whereas caped and the appropriate handler is invoked at the other models count \ncontexts from the head. level where this handler was bound to that exception. On the other hand call/pc \ndoes not affect control. To express the formal semantics5 of splitter, see figure 3 Generators 3, we \ndefine the PAns domain of partial answers to be: Our splitter operator can be put to work on the well-PAns \n= Cent ~ Ans known same-fringe problem. Two or more binary trees are compared: same-fringe returns true \nif theywhere Ans is the domain of final answers and Cent all have a similar fringe i.e. the same sequence \nof leaves. is the domain of sequences of continuations. In a com-Classical solutions involve only two \ntrees and explicitly putation (&#38;[m]pcT<tc)R*, K and K* forlm together the interleaves two coroutines \nenumerating sequentially the regular full continuation. leaves of the two trees. Non-classical solutions \ncan also 5A simulation of splitter written in regular scheme appears be found for example in [Gabriel \n89]. Our solution sat\u00adin appendix. isfies two goals (i) it handles an arbitrary number of (~n~t(a) = \nfalse t[splitter] = Ac a(~.~~ . allocate(~, 1,kr a . let < = <[a J-I-+ true] K = hT &#38;( .~K* . if \n#tC* = #K* then K(u , &#38;,<)(K* ) else K(u , c, < )(K* ) endif in let p = k* u ( K . if < (a ~1) then \n~K* .&#38;* ~1 (<>, u , < , KretUrn)(iast(~* , 1 + #K*)) else torong( obsolet e escape ) endif p = k* \nc7 ( K . if ( (cz* JI) then AK* . let K* = hilast(< K > jK* , 1 + #fc*) in let p = AC* C7 < K .AK* \n. %m(m , C* ~,, < )(K* $ < K > SK ) in E* JI (< p >,c7 , ~ , )( K*()* ) else wrong( out of extent ) \nendif in &#38;*JI (< p,@ >Im ! < , Kr,,uvI)(< K > ~K*)) Kntwn(u, C, <) = ~K*.K* 1, (~, C, c)(K*tl) iast(~ \n, ~) /* returns the last b elements of K */ butlast(~ , L) /* returns all but the last L elements of \nK */ Figure 3: Semantics of splitter trees and (ii) it is independent of how the tree is walked (cons \nthrough. leaf Visiting the leafs of a tree, in prefix order, can be (lambda (v) done thanks to: (splitter \n(define (visit tree fn) (lambda (k j ) (if (pair? tree) (set! grab j) (begin (visit (car tree) fn) (set! \nexit k) (visit (cdr tree) fn) ) (c V))))) (fn tree) ) ) )))))))))) We now abstract over this tree walk. \nFor each tree When a leaf is found, a pair made of this leaf and the comparing process must receive the \nleaf and the the partial continuation is returned. The splitter partial continuation expressing the rest \nof the visit (and controlling this partial continuation is thus no longer not the rest of the computation). \nIf they are all equal valid and cannot be reused. The partial continuation the comparison goes on otherwise \nit is aborted. We which is returned is thus wrapped inside a new invoca\u00ad thus wrap visit into a new function \nwhich allows to tion of splitter, the new grab and exit functions are return at the same time the leaf \nand the rest of the also updated with respect to this new splitter. It will visit. therefore be possible \nto make a partial continuation of (define (rnake-tree-walker visit) the restarted partial continuation. \n(lambda (tree) We can now simply compare fringes i.e. sequences of (splitter pairs (leaf. continuation) \nas enumerated by a particular (lambda (exit grab) tree-walker: (visit (clef ine (compare-fringes walk \ntrees) tree (let ((end (list end))) ; semtlnei (lambda (leaf) (clef ine (end? leaf) (eq? leaf end)) \n(grab (define (loop leafs) (lambda (c) (define (same-leaf? leaf) (exit (lambda () (eq? (car leaf) (caar \nleafs)) ) 178 (or ; all trees are finished ? (every? end? leafs) ; some trees are jinished ? (if (some? \nend? leafs) ??f (and (every? same-leaf? (cdr leafs) ) ; all leaves are equal ! (loop (mapcar (lambda \n(leaf) ((cdr leaf) end) ) leafs )) )))) (loop (mapcar walk trees)) ) ) Finally same-fringe isjust: (define \n(same-fringe , trees) (compare-fri,nges (make-tree-walker vi,sit) trees ) ) Observe the modularity ofthis \nsolution. The visit function is expressed in direct style and can be var\u00adied, for instance to visit every \nother leaf or numeric leaves only, This visit function dc}es not have to know how it is used; in particular \nit does not bear the burden of interleaving the various visits of the different trees. Similarly compare-fringe \nonly han\u00ad dles the multiplicity of trees, compares leaves and re\u00adsumes the visiting processes; it is \nnot concerned with the details of the tree-walking. The whole burden is borne by make-tree-walker which \nmakes computa\u00adtions progress step by step. This example shows that splitter has the ability to construct \ncomplex generators not restricted tosim\u00adple and reduced internal state held in some variables. Complex \ngenerators can compute arbitrary things, be saved in their current state of computation and later on \nresumed. Note that computations within such gen\u00aderators are not restricted and can even use partial con\u00adtinuations. \nVariants Other dressings can be imagined for splitter, we investigate two of them that can be put to \nwork in Scheme or other languages. It might be tempting to create a new type to rep\u00adresent marks of the \nevaluation stack. The interface to splitter would become: (splitter (lambda (mark) . ..) Such marks can \nbe used thanks to two new func\u00adtions which only know how to handle marks: abort and call/pc: (abort mark \n(lambda () ,.. )) (call/pc mark (lambda (c) . ..)) can be asked whether it isalive or not thanks to a \nthird specialized function: (alive-mark? mark) This variant leads to simple type equations, where (Mark \nr) is the type of marks created in a context where splitter must yield a T value. splitter: ((Mark ~) \n-+ r) ~ r abort : (Mark ~) x (Unit ~ ~) ~ r call/pc : (Mark ~) x ((r ~ I-) .+ ~ ) ~ r Obviously we gain \na little power since it is now pos\u00adsible to explicitly test if the mark is alive or not but the neat \ninterest of this dressing is that only one object is allocated (the mark) instead of the two synthesized \nfunctions abort and call/pc. On the other hand the interface is more complex since at least one type \nand three more specialized functions have been added to Scheme. Another variant is to consider that marks \nare no more first-class objects but must be accessed &#38; /aCOM-MON LISP6 with ad-hoc special forms. \n(splitter label body) (abort label new-body) (call/pc label (lambda (c) expression)) This introduces \na new namespace, the space of Iabe[s which associates names to marks. This space is lexi\u00adcally managed: \na label can only be used in the body of the splitter special form binding it. This does not restrict \nthe power of this variant since an abort or call/pc special form referencing this label can be closed \nin a lambda abstraction and exported outside. Using this solution makes simpler for a compiler to recognize \nthe places where some optimizations might be performed such as the validity of a mark, static com\u00adputation \nof partial continuations or abortion. It also makes the compiler more complex since it introduces new \nspecial forms. Depending on the natural inclination of the embed\u00adding language, the splitter facility \ncan be provided under multiple forms. To have first-class marks and specialized functions might be a \ngood choice, 5 Implementation From the viewpoint of the implementor, splitter in\u00adduces the same problems \nas call/cc in Scheme. Above all is the management of the evaluation stack. A partial continuation is \nrepresented by a slice of the execution stack. We propose an implementation scheme where partial continuations \nare not copied in the heap nor copied back onto the execution etadi,The technique ia closely related \nto [Hieb &#38; Dybvig &#38; Bruggeman 90]. The partial continuation is still functional but the 6 It \nis local exit a .sImple facilities exercise to write the structured lexical of COMMON LISP, see [Steele \n90]: block non. and mark is now a first class non-procedural object which return-from with this variant \nof splitter. 179 Once a partial continuation is reified, the correspond\u00ad ing stack slice is considered \nas frozen and must not be overwritten before the Garbage Collector unfreezes it. Let us only consider \npush and pop as the only opera\u00adtions on the evaluation stack, Push allocates new ac\u00adtivation records \nand increments the stack pointer (SP) while pop just decrements it. Observe that pop is non destructive. \nWe must then forbid pushing while SP is in a frozen zone. We thus suppose to have an extra pointer (free-stack \nor, FS, for short) above which there is no frozen zone: therefore it is always safe to al\u00adlocate new \nactivation records there, see figurefigstackl. In regular mode only SP is used. When a partial contin\u00aduation \nis created or activated, FS is set to SP. Popping activation records is always done with respect to SP. \nConversely pushing a frame depends on the mode: in regular mode, pushing a frame is done relatively to \nSP but if SP is in a frozen slice i.e. if SP<FS then push\u00ading must be done relatively to FS. A special \nframe (or return address) *R* is then pushed at FS to save the current SP. Afterthat SP is reset to FS \n(plus some off\u00adset) and pushing is performed as usually since we are now in a non-frozen zone. This extra \nwork is only done once since afterthat SP is higher than FS. When re\u00adturning to *R*, SP is reset to its \nold value somewhere in the frozen zone. frozen zone evaluation stack Figure 4: Calling a function from \na frozen zone An extra stack, the control stack, is necessary. Each times split t er is called, its \ncontinuation is pushed onto the control stack, When a partial continuation is created, the corresponding \nslice of the control stack is copied in the heap, see figure 5. When a partial continuation is called, \nthe current SP is pushed onto the control stack as well as the saved slice. Then SP is set to the top \nof the partial continuation. Its last frame (*contPOP*) is a special activation record imposing to return \nwhere the control stack specifies it. The benefits of this implementation are: (i) a stack\u00adbased discipline \nwith implicit control linkage is used, (ii) copying stack slices is avoided, (iii) mutable loca\u00adtions \ncan be directly put in the stack since stack slices are never duplicated. There are also inconveniences. \np?rtial. continuation call/pc-+ = splitter + *contPOP control stack H-II evaluation stack Figure 5: \nPartial continuation reification The technique puts a fix cost on every push (two in\u00adstructions) to \ncheck the current mode i.e. to compare FS and SP. When a stack slice is frozen when set\u00adting FS, the \nwhole bottom of the stack is frozen. The stack must now be scavenged (as in [Hieb &#38; Dybvig &#38; \nBruggeman 90]) and this requires cooperation of the GC and a perfect knowledge of the stack, This prob\u00adably \nprecludes conservative GCS, but to compact the stack may allow some frame elimination as illustrated \nin [Saint-James 84, Hanson 90]. The above implementation of splitter is not tail\u00adoptimal: the synthesized \nfunctions abort and cal!/pc have to be invalidated when splitter returns. On the other hand, call\\pc \nis tail-optimal. Yet another in\u00adconvenience is that strictly tail-recursive calls are not possible from \na frozen zone since a new frame has to be pushed at FS. The tail-recursion property is immedi\u00adately regained \nsince afterthat calls are performed from a free zone. 6 Related Works Felleisen and others have introduced \nprompts and partial continuations in a series of paper [Felleisen 88, Felleisen &#38; Wand &#38; Friedman \n&#38; Duba 88, Sitaram &#38; Felleisen 90]. Their control operators behave dynam\u00adically since control \ncan only abstract control upto the most recent run. We can easily provide these opera\u00adtors: (let ((run-stack \n ())) (set! run (lambda (thunk) (let ((old-rs run-stack) ) (beginO (splitter (lambda (abort call/pc) \n(define (cpc f) (call/pc (lambda (c) (abort (lambda ( ) 180 (f c))) )) ) (set! run-stack (cons cpc run-stack) \n) (thunk) ) ) (set! run-stack old-rs) ) ) ) ) (set! control (lambda (f) ((car run-stack) f) )) ) The \nabove programmation records all call/pcs in a stack in order for control to abstract upto the last run7. \nOur construct is not limited to the latest con\u00adtext; it is possible to take partial continuations upto \ndifferent splitters . Sitaram and Felleisen [Sitaram&#38; Felleisen 90] introduced hierarchies to solve \nthe prob\u00adlem of correctly pairing runs and controls but require some protocol to be respected. Oursolution \nsolves nat\u00adurally this problem. Another major point is that our construct reintro\u00adduces dynamic extent \ncontinuations which are both useful and efficient. The AbstractingC ontrol paper [Danvy&#38; Filinski \n90] introduced twospecial forms acting ascontrolop\u00aderators: shift and reset. A denotational semantics \naccompanies them. Intuitively, a program using these special forms is translated into aregular program \nwith explicit continuations i.e. written in an Extended Con\u00adtinuation Passing Style. These programs can \nalso be directly typed thanks to complex judgments involving the natural type of the expression and of \nits continua\u00adtion yielding another natural type for the final result, see [Danvy &#38; Filinski 89]. \nThe main difference with our work is that they only consider thle first embed\u00adding contexts (i.e. the \nhead of < ~ > j~* in our ter\u00adminology) whereas we count them from the tail. To change (lambda (v* ) r) \ninto (lambda (v*) (reset r) ) might deeply affect the meaning o,f a whole pro\u00adgram. But to replace it \nwith (lambda (v ) (splitter (lambda (k j) T)) ) does not alter it. This property eases modularity. Hieb \nand Dybvig introduced a new construct spawn in [Hieb &#38; Dybvig 90 b]. Although close to our work there \nare some fundamental differences. spawn is de\u00adfined in a concurrent context and allows to suspend or \n~ol)me bunches of Processes. (spawn (lambda (Con. . . . ) ) creates a new process controlled by con\u00adtrol. \nWhen control is invoked, it applies its argument, a monadic function, on the partial continuation up \nto spawn. Moreover it freezes all the concurrent sub\u00adcomputations initiated between spawn and the invo\u00adcation \nof control. These subcomputations will be re\u00adsumed when the partial continuation is called. control can \nonly be used while the process is not suspended. 7A dynamic binding facility would simplify the management \nof run-stack. spawn can be accurately written with splitter. But since the suspend/resume capabilities \nare needless but to handle concurrency and forbid to write sequential programs calling control inside \ncontrol, we therefore simplify spawn to the following sequential version: (define (spawn f) (clef ine \n(mk-cpc curr-cpc curr-abort ) (lambda (c) (curr-cpc ; takes the current partial continuation (lambda \n(cc) (curr-abort ; and aborts it (lambda () (c (lambda (v) (splitter (lambda (na ncpc) ; resets the root \nof the process (set ! curr-cpc ncpc) (set ! curr-abort na) (cc V))))))))))) (splitter (lambda (abort \ncall/pc) (f (mk-cpc call/pc abort)))) ) The first difference concerns the lifetime of contro~ which \nis not reduced to the dynamic extent of spawn. Every times the partial continuation is invoked, it is \nle\u00adgal to call control again. We simulated this behavior by wrapping the partial continuation itself \nwithin a new splitter. This eases to multiply suspend a computa\u00adtion upto its root (see, for instance, \nthe same-fringe example) but makes more difficult to know what is the partial continuation since it is \nupto the last point where it has been invoked. Assume that the evaluation order of arguments is from \nright to left, and consider the following example where the partial continuation itself contains another \ncall to control: (spawn (lambda (f) (cons (f (lambda (cl) (cons 1 (cl 4)) )) (f (lambda (c2) (cons 2 \n(c2 3)) )) ))) The value is (2 1 4 . 3). The reason is when calling f oo, the partial continuation C2 \nis (lambda (u) (cons (f (lambda (cl) (foo c1 4))) u)), The new par\u00adtial continuation reified by the second \nf in c I is: (lambda (y) (cons y 3)) and not the whole par\u00adtial continuation upto spawn i.e. (lambda \n(v) (cons (cons v 3))). In effect in this case there are two si\u00admultaneous roots and Hieb and Dybvig \nrestrict the par\u00ad tial continuation to take upto the most recent root i.e. the partial continuation is \nrestricted upto the calling site off. The analog form using splitter is: (splitter 181 (lambda (abort \ncall/pc) (cons (call/pc (lambda (cl) (abort (lambda () (foo CI 4))) ) ) (call/pc (lambda (c2) (abort \n(lambda () (cons2 (c23)))))) ) )) The value, assuming thesameorderof evaluation8, is (124. 3) since the \nsecond canto call/pc reifies upto splitter. [Danvy 87] Olivier Danvy, Memory Allocation and Higher-Order \nFunctions, SIFPLAN 87 Conference, pp 241-252.  To sum up, our construct controls more precisely ex\u00adtent \nand still offers spawn. Conclusions Partial continuations are new and very powerful tools. Their use \nis nevertheless complex. Not being able to know up to where, escapes (provoked by abort) or partial continuations \nare created (thanks to call/pc), makes partial continuations nearly useless except for toy programs. \nOur splitter construct allows to ap\u00adpropriately pair two moments: marking the evalua\u00adtion stack, referring \nto the lower part of this evalu\u00adation stack (under the mark) or referring to the inter\u00admediate slice \n(above the mark) between this mark and the current control point. It is thus possible to write programs \nusing simultaneously multiple marks without interferences. We showed how to use splitter to pro\u00adgram \ngenerators enumerating leaves of trees as well as we showed how to rebuild call/cc from splitter. Our \nview of computation recognizes that computa\u00adtions involves a structure of nested control points. A partial \ncontinuation is therefore taken upto an active control point. It is interesting to observe that this \nview supports the concept of dynamic extent but still allows to define indefinite extent partial continuations. \nAcknowledgements Thanks to Matthiaa Felleisen, Dorai Sitaram, Olivier Danvy, Pierre Weis and Damien Doligez \nfor their help while drafting, revising and discussing this paper. Bibliography [Clinger 88] William \nClinger, Anne Hartheimer, lrn\u00adpiementation Strategies for Continuations, Pro\u00adceedings of the 1988 ACM \nLisp and Functional Pro\u00adgramming, Snowbird, Utah, July 1988, pp 124-131. 8Remark that the final value \nstrongly depends on the order of evaluation. Partial continuations are at their best when used in unary \ncontexts. [Danvy &#38; Filinski 89] Olivier Danvy, Andrzej Filinski, A Functional Abstraction of Typed \nContexts, DIKU report 89/12, DIKU, University of Copenhagen, Denmark, August 1989. [Danvy &#38; Filinski \n90] Olivier Danvy, Andrzej Filinski, Abstracting Control, ACM conference on Lisp and Functional Programming, \nNice, France, Juin 1990. [Felleisen &#38; Wand &#38; Friedman&#38; Duba 88] Matthias Felleisen, Mitchell \nWand, Daniel P Fried\u00adman, Bruce Duba, Abstract Continuations: A Maihematica! Semantics for Handling Full \nFunc\u00adtional Jumps, ACM conference on Lisp and Func\u00adtional Programming, Snowbird, Utah, July 1988. [Felleisen \n88] Matthias Felleisen, The Theory and Practice of First-Class Prompts, ACM SIGACT-SIGPLAN Symposium \non Principles of Program\u00adming Languages, San Diego, CA, january 1988. [Friedman &#38; Wand 84] Daniel \nP. Friedman, Mitchell Wand, Reification: Reflection without Metaphysics, Proceedings of the 1984 ACM \nSymposium on Lisp and Functional Programming, pp 348 355. [Gabriel 89] Richard P. Gabriel, Using CL OS-iike \nConcepts in a Prototyping System, Common Lisp Object System Workshop, OOPSLA 89, October 1989. [Hanson \n90] Chris Hanson, Ejjicient Stack Allocation for Tail-Recursive Languages, ACM conference on Lisp and \nFunctional Programming, Nice, France, Juin 1990. [Haynes &#38; Friedman 87a] Christopher T. Haynes, Daniel \nP. Friedman, Abstracting Timed Preemption with Engines, Computer Languages, Volume 12, # 2, 1987, pp \n109-121. [Haynes &#38; Friedman 87b] Christopher T. Haynes, Daniel P. Friedman, Embedding Continuations \nin Procedural Objectsj ACM TOPLAS, Volume 9, # 4, October 1987, pp 582-598. [Hieb &#38; Dybvig &#38; \nBruggeman 90] Robert Hieb, R. Kent Dybvig, Carl Bruggeman, Representing Con\u00adtrol in the Presence of First-Class \nContinuations, Proceedings of the ACM SIGPLAN 90 Conference on Programming Language Design and Implemen\u00ad \ntation, White Plains, NY, June 1990. [Hieb &#38; Dybvig 90b] Robert Hieb, R. Kent Dybvig, Continuations \nand Concurrency, Second ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming, 1990, \npp 128 136. BIBLIOGRAPHY 182 [Johnson 87] Gregory F. Johnson, GL -A Deno\u00adtational Test bed with Continuations \nand Partial Continuations, proceedings of the SIGPLAN 87 Symposium on Interpreters and Interpretive Tech\u00adniques, \nSaint-Paul, MA, June 1987. [Johnson &#38; Duggan 88] Gregory F. Johnson, Dominic Duggan, Stores and Partial \nContinuations as First-Ciass Objects in a Language and its Environment, ACM SIGACT-SIGPLAN Symposium \non Princi\u00adples of Programming Languages, San Diego, CA, january 1988. [Rees &#38; Clinger 86] Jonathan \nA. Rees, William Clinger, Reviseds Re\u00adport on the Algorithmic Language Scheme, ACM SIGPLAN Notices, 21, \n12, Dec 86, pp 37-79. [Saint-James 84] Emmanuel Saint-James, Recursion is More Efficient i!han Iteration, \n1984 ACM sympo\u00adsium on Lisp and Functional Programming, Austin, Texas. [Schmidt 86] David A. Schmidt, \nDenotational Seman\u00adtics, A Methodology for Language Development, AL lyn and Bacon, Inc., Newton, Mass., \n1986. [Sitaram &#38; Felleisen 90] Dorai Sitaram, Matthias Felleisen, Control Delimiters and Their Hierarchies, \nLisp and Symbolic Computation: An International Journal, Volume 3, # 1, January 1990, pp 67-99. [Steele \n90] Guy L. Steele Jr., Common Lisp, the Lan\u00adguage, Second Edition, Digital Press, Burlington MA, 1990. \n[Stoy 77] Joseph E. Stoy, Denotational Semantics: The Scott-Strachey Approach to Programming Lan\u00adguage \nTheory, MIT Press, Cambridge, Mass., 1977. [Wand 80] Mitchell Wand, Continuation-Based MuL tiprocessing, \nConference Record of the 1980 Lisp Conference. Appendix: Embedding splitter in stan\u00addard Scheme In [Sitaram \n&#38; Felleisen 90] was explained how to pro\u00adgram control/run in Scheme. We like this idea since it helps \nto popularize the concept of partial continua\u00adtions. The embedding that follows haa been designed to \nmimic a native implementation. A call to call/cc must be thought of just as a copy of the stack-pointer. \nPush and pop operations are simu\u00adlated with cons and cdr. Other allocaticms in the heap are named with \na make- prefix. We make explicit the data that are necessary and do not use implicit closures to keep \nthem, (clef lne stack-of-marker ()) (define (splitter f) (let ((marker () ) (v ()) (topmarker ()) ) \n(set! v (call/cc (lambda (kk) (set ! marker (cons kk ())) (set ! stack-of-marker (cons marker stack-of \n-marker) ) (let ((v (f (make-abort marker) (make-call/pc rnarlcer) ) ) ) (set-car ! (car stack-of-marker) \n() ) v)))) (if (not (null? (caar stack-of-marker))) II Someone did (kk thunk) (begin ; ; markers downto \nmarker are obsolete. (obsolete-stack ! marker) . Compute thunk with continuation kk. t;et! v (v)) (set-car \n! (car stack-of-marker) () ))) (set ! topmarlrer (car stack-of-marker)) (set! stack-of-marker (cdr stack-of-marker) \n) (cond ;; The continuation is return ((null? (cdr topmarker)) V) end of a partiai continuation. t~lse \n((cdr topmarker) v)) ) ) ) (define (make-abort marker) (lambda (thunk) (if (null? (car marker)) (wrong \nobsolete splitter ) ;; Return to the marker. ((car marker) thunk) ) ) )  (define (make-call/pc marker) \n(lambda (g) (if (null? (car marker)) (wrong out of extent ) (call/cc (lambda (kj) (g (make-pckj marker)) \n))))) (define (make-pc kj marker) (let ((slice (marker-prefix stack-of-marker marker ))) (lambda (v) \n 183 (call/cc (lambda (kc) (set! stack-of-marker (append slice (cons (cons Xt kc) stack-of-marker ) ) \n) (kj v)))))) (define (marker-prefix 1 m) (if (eq? (earl) m) () (cons (cons #t (cdar 1)) (marker-prefix \n(cdr 1) m) ))) (define (obsolete-stack! marker) (if (eq? (car stack-of-marker) marker) marker (begin \n(set-car! (car stack-of-marker) () ) (set! stack-of-marker (cdr stack-of-marker) ) (obsolete-stack! marker) \n) ) ) \n\t\t\t", "proc_id": "99583", "abstract": "", "authors": [{"name": "Christian Queinnec", "author_profile_id": "81100373159", "affiliation": "&#201;cole Polytechnique & INRIA-Rocquencourt and LIX, &#201;&#201;cole Polytechnique, 91128 Palaiseau Cedex, France", "person_id": "PP14132326", "email_address": "", "orcid_id": ""}, {"name": "Bernard Serpette", "author_profile_id": "81100037529", "affiliation": "&#201;cole Polytechnique & INRIA-Rocquencourt and LIX, Ecole Polytechnique, 91128 Palaiseau Cedex, France", "person_id": "P29398", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/99583.99610", "year": "1991", "article_id": "99610", "conference": "POPL", "title": "A dynamic extent control operator for partial continuations", "url": "http://dl.acm.org/citation.cfm?id=99610"}