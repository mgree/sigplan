{"article_publication_date": "01-03-1991", "fulltext": "\n Coordinating First-Order Multiparty Interactions Yuh-Jzer Joung Scott A. Smolka joung@cs.sunysb. edu \nsas@cs.sunysb. edu Department of Computer Science SUNY at Stony Brook Stony Brook, NY 11794-4400 Introduction \nA multiparty interaction is a set of 1/0 actions ex\u00ad ecuted jointly by a number of processes, each of \nwhich must be ready to execute its own action for any of the actions in the set to occur. An attempt \nto participate in an interaction delays a process until all other participants are available. After the \nactions are executed, the participating processes continue their local computation, usually asynchronously. \nLanguages like C SP and Ada sup\u00ad port interaction ordy between two processes. How\u00ad ever, for many applications \na higher level of ab\u00ad straction can be obtained by permitting interac\u00ad tion among an arbitrary number \nof processes. For example, consider the well-known dining philoso\u00ad phers problem. The natural unit of \nprocess inter\u00ad action in this setting is between a philosopher and its two neighboring forks; i.e., a \nmultiparty syn\u00adchronization involving three processes. It is useful to distinguish between ze~oth-oder \nmultiparty interactions where the participants are fixed in advance, and jirst-onier multiparty inter\u00adactions \nwhere the participants may vary dynami\u00adcally. For example, a zeroth-order multicast inter\u00adaction in which \nprocess .P sends a message m to Q and B is captured by the code: P::B[] Q :: B[z := m] *Research supported \nby the National Science Foundation under Grant CCR-8704309. Permission to copy without fee all or part \nof this material is granted provided that the copies are not made or distributed for direct commercial \nadvaotage, the ACM copyright notice and the title of the publication and its date appear, and notice \nis given that copying is by permission of the Association for Compudng Machinery. To copy other\u00ad wise, \nor to republish, requires a fee and/or specific permission. R :: B[y := m] The notation we use is based \non 1P [7, 8]: 1? is the interaction name and m, z, and y are variables local to P, Q, and R, respectively. \nAn interaction body [. ..] describes the action taken by a process engaged in the interaction; e.g., \nz := m means that Q assigns z the non-local value of m. Many of the existing constructs for multiparty \ninteraction are zeroth-order, including shared actions [16], joint actions [1], interactions in Raddle \n[4], interactions in IP, and interaction types [13]. A first-order multiparty interaction is an ab\u00adstraction \nmechanism that defines activities among a set of roles, which serve as formal process param\u00adeters. Actual \nprocesses participate in an interac\u00adtion by enrolingl into the roles. We first consider partnem-unnamed \nenrollment [9] where a process is not permitted to name any other potential par\u00adticipants for the interaction \nin question. In this scheme, an instance of the interaction is activated when all roles are filled by \ndistinct processes; the enrolers then communicate in the manner as de\u00adscribed by the interaction. The \nnotion of ScTipt [9] and the team construct of Raddle and 1P all sup\u00adport first-order multiparty interactions. \nConsider once again the multicast example. We can define a first-order interaction having three roles, \na transmitter and two recipients, as follows: first-order interaction %cast :: [ role tTansmitter(z: \nin) :: skip role Tecipientl (z: out) :: z := z role recipientz(y: out) :: y := z ] 1N. Francez and I. \nR. Forman suggest the new word en\u00adrole to mean to enter a role. Now, P, Q, and R can execute the following \nen\u00adrollment stat ements to activate an inst ante of the first-order interaction: P :: enrole t~ansmitter(nz) \n@,2?-cast Q :: enrole rec@ientl(z) @2-cast R :: enrole ~ecipientz(y) @.2-cast Any other three processes \ncan reuse this 2-cast interaction to communicant e, and thus a decision must be made whether to allow \nconcurrent activa\u00adtions of the same first-order interaction. In Rad\u00addle and Script, first-order interactions \nare reentrant thereby permitting concurrent activations, while in 1P, this decision is currently left \nunspecified. In this paper, we also view first-order interactions as reentrant: the pot ential concurrency \ncan lead to increased performance, and, as pointed out by N. 17rancez [5], the absence of any sequentialization \nof activations leaves the interaction itself as the sole source of process synchronization. However, \nas also pointed out in [5], the accompanying proof system may become more complex in light of concurrent \nactivations. As in CSP, multiparty interactions both zeroth-order and fist-order-can serve as guards \nin alternative and repetitive commands. In the zeroth-order case, an int eraction st at ement appear\u00ading \nas a guard can be executed only if all the other participants are in agreement. For example, con\u00adsider \nthe following program P::* [ Cl[]+ . . D6[] ---+ ...] Q::* [a[ ]+... IJc[ ]+...] R::* [a[]+ .,. Dc[ ]+...] \nP can execute a[ ] if and when Q and R agree to ex\u00adecut e their own a[ ] actions. The guard-scheduling \nproblem for zeroth-order interactions has been ele\u00adgantly characterized by Chandy and Misra as one of \ncommittee coordination [3]: each professor in a university serves on one or more committees, the members \nof which are fixed; furthermore, a com\u00admittee cannot convene until all its members are present (as such, \nno two committees with a com\u00admon member can convene simultaneously). For the first-order case, an enrollment \nstatement appearing as a guard in a process P can be exe\u00adcuted only if a set of processes, including \nP itself, agree to fill all roles of the targeted interaction.2 To illustrate, consider the following \nprogram: P::* [ enrole s~@S -+ . . . l enrole tlftll --+ . . . 1 Q::* [ enrole sz@S ~ ... El enrole \nS3@)S -.. . 1 R::* [ enrole sz@S ---+ . . . D enrole tl@T -+ . . . 1 U::* [ enrole sI@S ---+ . . . l \nenrole tz@T --+ ... 1 S and T are first-order interactions having roles S1, S2, S3 and tl, t2, respectively. \nF can execute en\u00adrole S1 @S if and when two other processes agree to enrole into S2 and S3. The following \nissues are peculiar to the imple\u00admentation of first-order guards: Since the participants of a first-order \ninterac\u00adtion vary dynamically, determining which set of processes together can enrole in an instance \nof the interaction is more complex than in the zeroth-order case. In fact, we show that it is closely \nrelated to the mazinzum matching problem [11]. Instances of a first-order interaction can be concurrently \nactivated. As more than one process can enrole into the same role, the failure of any one of them should \nnot preclude the others from filling the role. Thus, fist-order interact ions are inher\u00adently fault -t \nolerant. The distributed algorithms of [17, 3,2,13, 15] for multiparty interaction guard scheduling are \nzeroth\u00adorder in nature. The algorithms of [3, Z, 15] em\u00adploy a fixed coordinator for each interaction \nand 21rs 1P the situation is somewhat ditTerent. 1P s team is an abstraction mechanism for muttipmty \ninteractions, the zeroth-order construct of 1P. Enrollment into a team does not d:lay a process, but \nrather the multiparty interactions to be executed first within the role [6]. thus cannot realize concurrent \nactivations of a first\u00adorder interaction, nor can they tolerate the failure of the coordinator, The algorithms \nof [17, 13] em\u00adploy mutual coordination among the participants, but are highly dependent on the fact \nthat the par\u00adticipants of each interaction are fixed. Therefore, there is no straightforward way to adapt \nthese al\u00adgorithms to a first-order setting. Summary of Technical Results The main contribution of this \npaper (Section 3) is a distributed algorithm for the enrollment guard scheduling problem, the first first-order \nsolution of which we are aware. The algorithm admits the possibility y for any process, upon reaching \nan alter\u00adnative command, to behave as the coordinator of a fist-order interaction. Thus, unlike the zeroth\u00adorder \nalgorithms, it permits concurrent activations: each activation will have its own coordinator. It is also \nfault-tolerant as the coordinator is not des\u00adignated in advance. Moreover, the algorithm has low message \ncomplexity: at most 6n2 messages per process, per interaction guard, where m is number of processes that \ncan potentially enrole into the interaction. In the above algorithm, a bi-partite graph data structure \nis used to associate processes with their potential roles, and the coordinator is required to perform \nmaximum matching on this graph to de\u00adcide which processes to schedule, The best-known bound for this \nproblem is currently 0(n2 5) time, where n is the number of nodes in the graph [11]. In Section 5, we \nshow that in a setting in which a process can target at most one role of an inter\u00adaction at any one time, \nmaximum mat thing can be safely avoided and, instead, a coordinator can decide which processes to schedule \nin linear time. Moreover, through the use of generic roles, we ar\u00adgue that this restriction on alternative \ncommands is quite palatable in practice. In Section 6, we then consider partners-named enrollment, where \nan enroler can name some or all of the other participants in a fist-order interaction. This type of enrollment \nwas initially presented in the context of Script [9]. We show that, in gen\u00aderal, enrollment guard scheduling \nin this setting is NP-complet e, even when enrollment statements cannot act as guards. However, partners-named \nenrollment is desirable in some applications. For example, a process .P may at times desire to mul\u00adticast \nto a particular group G of recipients. To ensure that the message is received only by pro\u00adcesses in G, \nP names exactly these processes as the recipients. We present two restricted naming conventions, which \nseem reasonable in practice, for which the problem can be solved efficiently. Finally, in Section 7, \nwe extend our algorithm to work in a dynamically changing environment where processes may be created \nand destroyed at run time, a problem suggested in [9, 6]. 2 A Simple Model of First-Order Multiparty \nInteractions We consider a distributed system to be a set of con\u00adcurrent processes that interact by engaging \nin first\u00adorder multiparty interact ions. Each interactions has a fixed set 72(1) of roles into which \nprocesses can enrole. For each role r c 7?(1) there is a fixed set P(r) of processes that can potentially \nenrole into role r. Further, we let T(1) = lJ,eR(q ~(~)~ i.e., the set of processes that can potentially \nenrole into some role of I. We assume that %3(1) and each ~(~) are finite and known to every process \nin P(1). From time to time, a process enters its enro2e\u00adment phase, where it is ready to enrole into \nany single role from a set of potential roles, possibly from different interactions. We define a quorum \nof 1to be aset { (I%, ri), 1< i < 1~(~)1 [ process p; is ready to enrole into I as r; } Additionally, \nthe pairs of a quorum are required to be component-wise mutually distinct. These pi s together can leave \ntheir enrollment phase and ac\u00adtivate an instance of I with pi filling role ~i. The jlrst-order guard \nscheduling problem then is to establish quorums involving mutually disjoint sets of processes from the \nprocesses currently in their enrollment phases. 31n the sequel, unless stated otherwise, by interaction \nwe mean of the first-order type. 3 Description of the Algorithm We assume an underlying network of processes \nthat is completely connected via reliable, FIFO commu\u00adnicant ion channels, and that processes communicant \ne exclusively by message passing. Furthermore, mes\u00ad sages are timestamped; processes use the times\u00ad tamps \nto maintain their logical clocks [14]. 3.1 Overview When a process pi enters its enrollment phase, it \nchooses an interaction 1 in which it is ready to enrole, and then attempts to establish a quorum of 1. \npi builds its quorum incrementally. Initially, the partial quorum of I is { (Pi, T) [pi is ready to assume \nrole ~ of I } pi is called the coow-iinator of the partizd quorum. pi then tries to capture processes \nto fill all the roles of 1. For each role r, pi chooses a process p.j in T(r) and sends it a captu~e \nrequest. If Pj is ready to assume any role r of 1, and is willing to be captured by pi, pi grants pi \ns capture request and provides pi with the set Rj of roles of 1 that p.j is ready to assume. p; then \nadds the pairs (Pj, T) such that T E Rj to its partial quorum, However, if pj rejects pi s request because \nit is not ready to assume a role of 1 or because it does not wish to be captured by pi, then pi must \nfind another process for role r. pi s efforts succeed when its partial quorum con\u00adtains a quorum. It \nthen directs each process of the quorum to assume its role in the quorum, and releases any additional \nprocesses it may have cap\u00adtured. However, if pi determines that there is a role of 1 for which it camot \ncapture a process, it aborts the attempt and releases all members of its partial quorum. If pi has another \ninteraction 1 in which it is ready to enrvle, it attempts to build a quorum of I ; otherwise, it enters \nan idle state waiting to be captured. To reduce the message complexity of the algo\u00adrithm, we allow a \ncoordinator to only capture older processes. Here we measure the age of a process by the unique entry \ntime obtained from the contents of the process s logical clock when it entered its current enrollment \nphase.4 The larger the entry time a process possesses, the younger the process is. Allowing a coordinator \nto only capture older processes means that only the youngest process in a quorum can assemble the quorum, \nand prevents the other processes from wasting too many mes\u00adsages in an attempt to build the quorum only \nto learn that a younger process is not yet ready. To ensure coordinators establish quorums that involve \nmutually disjoint sets of processes, a pro\u00adcess can be captured by only one coordinator at a time. Obviously, \nthe requirements of different coordinators may conflict. These conflicts are re\u00adsolved using the unique \nentry times obtained by each coordinator. (The same technique has also proven usefid in implementing \ndynamically struc\u00adtured multiparty interactions [12].) A conflict arises when a coordinator attempts \nto capture a process that already belongs to another coordinator. Conflicts are resolved in favor of \nolder coordinators in order to prevent a coordinator from being locked out from capturing processes. \nThat is, we let the older of the two coordinators cap\u00ad ture/ret ain the process, say p, under cent ention. \nThe younger coordinator has then to find an al\u00ad ternative process for the same role as played by IT or \nwait hoping that p will eventually be released by the older coordinator either because the older coordinator \ncould not build a quorum or because it decided on a quorum which excluded p. When a coordinator pi is \nwaiting for a captured process pi to be released by an older coordinator Pk, we say that pi s capture \nrequest has been de\u00adferredby Pj. p; andPj both maintain this wait\u00ading for relation until either one of \nthe following occurs: pi finishes (succeeds or aborts) its coordina\u00adtion and withdraws its capture request \nto pj.  D; s captor successfully builds a quorum in\u00advolving Pj. So Pj rejects pi s capture request. \n pj s captor releases pj as it cannot build a quo\u00adrum involving pj. SO pj now grants p~ S cap\u00adture request. \n 4Entry times can be made unique by additionally consid\u00adering process ids, We show in Section 4 that \nour algorithm guar-request by coor~. antees that any quorum contained in the partial quorum of pi involves \npi itself. This prevents pi from coordinating one quorum after another from a given enrollment phase, \nassuming that pi is old enough to win most cent entions. Allowing pi to coordinate too many quorums could \nseverely limit the system s concurrency. In fact we can show that if for a given enrollment phase there \nexists at least k quorums that involve mutually disjoint sets of processes, then at least k coordinators \nwill estab\u00adlish quorums that involve mutually disjoint sets of processes. 3.2 The Algorithm Each process \npi executes concurrently two compo\u00adnents, coo@ and slav~. We use cored to realize the behavior of pi \nwhen pi acts as a coordinator of a part ial quorum as described earlier, and slav~ for pi s behavior \nin reacting to capture requests. In our algorithm, coordinators communicate exclu\u00ad sively with slaves, \nand vice versa. Recall that a coordinator pi starts out with a partial quorum involving itself; that \nis, siavei is initially captured by cooro?i. Our strategy for re\u00adsolving conflicts guarantees that slavq \nwill remain captured by coor~ until coo@ has established a quorum or has entered its idle state due to \nits in\u00adability to build any quorum. This is because when a Coonij attempts to capture slavq, if pj is \nolder than pi, then coordj is not allowed to capture slavei. However, if pi is younger, then coo~~ wins \nthe con\u00adtention and retains slav~. Therefore, it will never be the case that the two components get out-of\u00adsynch, \ne.g., coor~ is still busy in building a quo\u00adrum while tdavq has already advanced to the next enrollment \nphase. Coor~ proceeds as follows: coor~ maintains the following variables: P: the current partial quorum. \nIt contains pairs (Pj, ~) such that Pj is ready to assume role r and slavej is captured by COO~~. D: \nset of pairs (pj) r) such that pj is ready to as\u00adsume role Y but slavej has deferred a capture l?: the \nset of slaves coor~ has requested for cap\u00adture. cooml starts its quorum-building activity when process \npi enters its enrollment phase. It be\u00adgins by selecting an interaction 1 in which pro\u00adcess pi is ready \nto enrole, and sets P = { (Pi, ~) I Pi is ready to assume role r of 1}, D = 0, and R = {pi}. coordj then \nexecutes the fol\u00adlowing procedure to build a quorum of 1, If suc\u00adcessful, i.e., P cent ains a quorum \nQ, then coor~ sends S uccess(l, ~i) to slavej for each (p~, ~j) c Q, directing pj to enrole in 1 as role \n7 j. coordi also releases any additional slaves it may have captured by sending each slave of -P Q a \nRelease message, and withdraws the capture request it made to each slave of D by sending it a WWubawal \nmessage. If coor~ fails to establish a quorum of 1, it releases every captured slave except slav~ and \nwithdraws the capture request it made to each slave of D. If COOT4 has another yet-to-be-tried interaction \nI , it continues by attempting to build a quorum of 1 ; otherwise, it releases slav%, ceases all quorum\u00ad \nbuilding activity, and then becomes idle. The procedure to build a quorum of 1 is as fol\u00adlows: If P \ncontains a quorum Q (which must involve pi), then coora!i has succeeded. Conversely, coo~~ fails to \nbuild a quorum if either: there exists a role r such that every slave of P(T) when requested by coor~ \nwas not ready to as\u00adsume role r; or every slave of P(1) is either captured by coord or has rejected capture \nby cooroj, and P does not cent ain any quorum.  If COOTL has not yet succeeded nor failed, then it can \nproceed conservatively by waiting for the slave of a process in D to grant or reject its deferred capture \nrequest, or aggressively by sending a new capture request to the slave of a process p not in R, hoping \nthat p is ready to fill a role of I that would assist coorh to reach a quorum. The choice constitutes \na fine tuning of the algorithm the conservative ap\u00adproach may result in fewer messages, while the aggressive \napproach may give bet t er response time.   When a sluvej of D grants coor~ s de\u00adferred request, coor~ \nmoves all pairs of the form (pj, ~) from D to P. If slavej rejects COOT4 s deferred request, coorh deletes \nall such pairs from D.  If coor~ wishes to capture another slavek, itadds ph to R, sends Request(ti, \nI) to slave~, and then waits for a response from slavek. Here ti is the entry time of pi. If the response \nis Yes(ti, 1, RI), coor~ adds (Ph, ? ) to P for each ? E RI; if the response is Deferred (RI), itadds \nthe  (ph, r) s to ~; otherwise it does nothing. Meanwhile, if cooT~ receives a Switch message from a \ncaptured slavej, asking it to release sla~ej because a coordina\u00ad tor older than coo@ wishes to capture \nslavej, then coor~ replies Switch.ok to the request and moves all pairs of the form (pi, r) from P to \nD. Slave; nroceeds as follows: slavq maintains a priorit y queue of triples (pj, tj, -I) such that slav% \nhas deferred the capture request Request(tj, I) by coordj. The highest priority is given to the triple \nwith the smallest timestamp. si?avei waits for its captor, cooTdh, if any, to estab\u00adlish a quorum. (slavq \nis initially captured by cooToj when coor~ starts its quorum-building activity.) If szav~ receives fhmcess(~, \nT;) from Coordh, it sends NO(ti, 1 ) to cooTdj for each triple (pj, tj,1 )in the queue; i.e., all deferred \nrequests are now reject ed. slavq then enroles into I as role ri, However, if coordh sends a Release \nmessage to slav~ without placing p; in a quorum, slavq deletes from the queue the triple (pj, tj, 1 ) \nthat has the smallest ti,and sends Yes(tj, I , l?l,) to coordi. Rp is the set of roles pi can assume \nin interaction It. That is, slavq grants the oldest of its deferred capture requests, which is consistent \nwith our strategy for resolving conflicts. If the queue is empty, slav~ idles, waiting to be captured. \nslavei may also receive Request (t~, 1 ) from a co\u00adordinator coordj. If pi is not ready to enrole in \n1 or pi is younger than pj, then slavej rejects cooTd~ s request. Otherwise, there are two cases. (1) \nslavq is not captured by any coordinator: it grants cooTdj s request. (2) slavq is captured by some cooTdh: \nif ph is older than pj, then slav~ re\u00admains captured by COoTdh, inserts triple (pj, tj, ~ ) into its \npriority queue, and sends Deferred (l?IJ) to coordj, where RI, is the set of roles pi can as\u00adsume in \ninteraction I . Else, siave.i sends Switch to coodk askhlg it to release slave. After receiving the confirmation \nSwitch.ok, slav~ grants coordi s request, and inserts the triple (ph, th, ~) into the queue thereby now \ndeferring cooTdh s capture re\u00adquest Request(th, ~). Also, when slavei receives Withdrawal from some cooTdl, \nit simply deletes coordz s capture request from the queue. The algorithms for cooTdj and slavq are given \nin Figures 1 and 2, respectively. Together they constitute our algorithm for the first-order guard scheduling \nproblem. Each algorithm is pre\u00adsented as a CSP-like repetitive construct, and each guarded command is \nnumbered for ease of refer\u00adence. We assume weak-fairness, i, e., every com\u00admand whose guard is continuously \nenabled is even\u00adtually executed. Note that the coordinator and slave of a process p; are logically separate: \nthe guarded commands of both components can be combined into a single repetitive construct. In Figures \n1 and 2, the entry time of process pi, with respect to its current enrollment phase, is given by variable \nti.Also, the variable G; repre\u00ad sents the set of roles that pi is ready to assume, i.e., G~ contains \npairs (1, RI) such that pi is ready to assume the set RI of roles of 1. Gi is updated by pi whenever \npi enters its enrollment phase, and is reset to @when pi leaves this phase.  3.3 An Example To illustrate \nour algorithm s behavior, consider an interaction 1 with three roles rl, T2, and ~3. As\u00adsume that ~ and \n~ are ready for role ~1, ~ and P4 for rz, and P5 and P6 for TS. Furthermore, the entry times of the six \nprocesses are in increasing or\u00adder; so ps is the youngest. In the following we give a possible scenario \nof events for the six processes executing the algoritlmx 1.4 receive Yes(t, RI, ) from davej -+1.1 active; \ntarget = nil; aborted (P, D, R) --i [pj ED; t=t~; I =I \u00adsend Release to sbej ; for TcRIdo [P:=PLJ {(Pj, \nT)}i forpj, (pj,7) 6 D do send Withdrawal to dmej ; D:=D {(Pj, T)}]; P:= D:=i3; o dat)ej = target; \nt = ti; I = I \u00adforr~RIdolJ:=Pu {(pj, ~)}; [ V (1 , RI,) G Gi, tried(I ) \u00adtarget := nil ; send Release \nto 81avq ; R:=fl; l else --+ skip ] ; active:= false;   1.5 receive No(t, 1 ) from .&#38;wej + D 3 \n(1 , RI,) c Gi, li!ried(I ) - I := I ; [pjED;t=ti;~ =~\u00adfor (pj, r) cDdo P:={(pi, r)13TERr, }; D:=D {(pj, \nT)} ; R:= {pi} ]; Cldavej = target; t = ti; I = I + 1.2 active; target = nil; recruit (P, D, R) # nil \n\u00ad target := nil ; target:= recruit (P, D, R); D else -sldp ] ; send Request (ti, 1) to target ; R:=Ru \n{pj};  1.6 receive Switch from .davej -+ 1.3 active; target = nil; [ P does not contain any quomnn; \nP contains a quorum Q -3(~j, ? )~P \u00adfor (pj)~~) c Q do send Swztch.ok to davej; send .$uccess (~, rk) \ntO Shvej ; for (pj, r) G P do P:= P Q; [P:= P-{(pj, T)}; forpj, (pjj~) P do D:= DU{(pj, ~)}] send Release \nto davej ; D else + skip ]; for pj, (Pj,~) cD do  1.7 receive Deferred (RI) from sbej ---+ send Withdrawal \nto davej ; active:= false; for TERrdo D:=lll.J {(pj, T)}; target:= nil ; P: the current partial quorum. \naborted (P, D, R): returns true if the attempt to build a quorum of I has failed, i.e., either + C D: \na set of pairs (pj, ~) such that pj is ready to assume ~(~) Vpj ~P(r)) (pj, r) @ 1 A (Pj, T) @ DApj ~ \nrole r but davej has deferred a capture request by R, or P(I) = R A D = 0but P does not contain coor~. \nany quorum of 1. Initially, aborted (0, !3, 0) = true R: the set of slaves pi has requested for capture. \nso that command 1.1 will be applied. active: a flag that is true iff coor~ is coordinating a recruit \n(P, D, R): returns the slave of a process pj, quorum of an interaction. pi @ R, that coor~ can now attempt \nto capture, I: when active, I denotes the interaction for which or returns nil otherwise. For fewer \nmessages, it cooro!i is coordinating. can ret urn nil whenever D # 0; or, for better re\u00adsponse time, \nit can return the slave of a process target: the slave to which coor~ has sent a capture re\u00adpj ~ (T (T) \n R) whenever there is a role ~ such quest but has not yet received any response. that coordi needs some \nprocess to assume r. tried(l): a flag that is true iff coor~ has tried to estab\u00adlish a quorum of ~. Figure \n1: Algorithm for coor~  2.4 receive Swit ch.ok from coordj ---+ 2.1 receive Success (I, T) from coordj \n+ queue := queue U { captor}; for (p~, tk, ~ ) q~e~e do captured := false; send ~O(tk, ~ ) to coordk \n; queue := 0;  2.5 receive Withdrawal from coordj + enrole into I as role r; [ pj = captor --+ captured \n:= false; 2.2 receive Release from coordj --+ D 3 (pj, tj, 1 ) C queue\u00adcaptured := false; queue := queue \n { (pj, tj, I ) } ; [ pj C repty -reply := reply {Pj } ] ; 2.3 receive Request (ti, I ) from coordj + \nD else + skip ]; [ti <tj; 3 (1 , RII) eGi \u00ad  2.61 captured; queue # @ \u00ad queue := queue U { (pj, tj, \n~ ) }; [ captured\u00ad delete (pj, t j, I) from queue; let captor= (pk, tk, ~) ; let (1, RI) c Gi ; send \nYes(-tj, lY~) to coordj ; [tj<tk+ reply := reply U { Pj } ; captor := (pj, tj, 1) ; [ msu$ag -[ pj 6 \nreply + reply := reply {Pj } ] ; send Suit ch to COOI dk ; for pk e reply do swflag := true ] ; [ let \n(pk, t~, ~ ) ~ queue; Qtk<tj \u00ad let (1 , RII) c Gi ; send Deferred to Coodj]; send Deferred (tk, RI!) \nt O coord~ D 1 captured \u00ad reply := reply {pk }]; reply := reply U {pj }]; swjlag := false D else -send \nNo(i!j, 1 ) to coordj ] ; queue: a priority queue of triples (pj, tj, 1 ) such thatcaptured: a flag \nthat is true if slavq is captured. slav~ the capture request Request (t j, I ) by coordj is de\u00ad sets \ncaptured to true upon entering the enrollment ferred by slave. The highest priority is given to phase. \n the triple which has the smallest (oldest ) tj; a swftag: a flag that is true iff slave has already \nsent a delete operation then returns that triple. Switch to its current captor because some coordi\u00ad reply: \nthe set of coordinators to which slav~ has notnator older than slav~ s captor wishes to capture yet replied \nto their capture requests. .dauei. captor: a triple (pj, tj,1)such that slavq is captured by coordj, \nwhich has entry time t j and is coordinating interaction I. aku% sets captor i= (pi, ta, ) UpQJ.I entering \nthe enrollment phase.  Figure 2: Algorithm for slavq coordl requests capture of slave3 but is re\u00adjected. \nIt then issues a request to slave4 but again is rejected because M is older than both of pS and p4. coordl \nthen releases slavel and idles.  Similarly, coord2 and coord3 release their com\u00adpanion slaves and become \nidle after each being reject ed by both slave5 and 8Zave&#38;  coord4 captures slavel.  coord5 and \ncoon&#38; both request capture of slave4 which belongs to coord4. Their requests are deferred by slave4 \nas p5 and pS are younger than p4.  e coord4 s requests to capture slave5 and Slavee are rejected. It \nreleases slavel and slave4 and then idles. slave4 grants coord5 s capture request.  coor&#38; captures \nslavq.  coord5 requests capture of stavel. Since p5 is older than W, coord5 captures slav~ and  cooro&#38; \ns capture request is deferred by slavel. coord5 then has established a quorum involv\u00ading ~, p4 and p5. \no After capturing slave2 and slave3, coorc&#38; then has established another quorum of I.   4 Analysis \nof the Algorithm In this section we prove that our algorithm satis\u00adfies the requisite safety and liveness \nproperties, and analyze its message complexity. Theorem 1 (Safety) At any time a process can participate \nin at most one established quorum. Proofi This is a consequence of the fact that a coordinator can establish \na quorum only if it cap\u00adtures all of the processes involved in the quorum, and that a process can be \ncaptured by only one coordinator at a time. Lemma 1 A capture request cannot be deferred forever nor \ninfinitely ofien. Proof: A capture request issued by a coordinator p; to a slave pj may be granted, \nrejected, or de\u00adferred by pi. However, a capture request that is granted may later need to be deferred \nin order to resolve a conflict. If pj were to defer pi s capture request forever or infinitely often, \nthen there must exist a pk older than pi such that pj remains captured by p~ for\u00adever, or pk continually \nrecaptures pi ifitely of\u00adten. However, p~ must stay in the same enroll\u00adment phase each time it recaptures \npj: pk will be younger than pi when pk obtains a new entry time. Therefore, some slave would also have \ndeferred pk s capture request forever or infinitely often, This would imply the existence of an infinite \nsequence of coordinators with strictly increasing ages. Con\u00adtradiction. D Theorem 2 (Liveness) Whenever \nthere ezists a quorum, then, within a jinite amount of time, some process in the quorum will enrole in \nsome interac\u00adtion. Proof (sketch): Suppose there exists a quorum Q of an interaction I and let pm be \nthe youngest process in Q. Then, either (1) a process in Q par\u00adticipates in some other established quorum, \nor (2) pm will eventually establish Q since, no process in Q can reject pm, and by Lemma 1, eventually \nall processes in Q will be captured by pm. In either case the theorem has been proven. D Lemma 2 Any \nquorum established by a process pm must involve pm itself. In fact, pm is the youngest process in the \nquorum. Proof: A process pm cannot be captured by a dif\u00adferent process unless pm has entered its idle \nstate due to its inability to build any quorum. So, if there exists a quorum Q of an interaction 1 in \nwhich pm is the youngest process, then no other process can capture pm until pm has attempted to build \na quorum of 1. By the proof of Theorem 2, pm will succeed in establishing Q, unless some pro\u00adcess in \nQ has participated in some other established quorum. 1 To analyze the algorithm s message complexity, \nwe define #(pi[I] ) to be the number of messages transmitted by pi itself or generated by other pro\u00adcesses \nin response to pi s messages while pi is co\u00adordinat ing I. We consider a worst-case scenario, 1. coor~ \nsends a Request message to slavej. 2. slavej is captured by coordk which is younger than coordi. So, \nslavej sends a Switch message to Coordk.  3. Coordk sends the confirmation Switch-ok to SlaVej. coord~ \ns capture request is now de\u00ad ferred by slavej. 4. slavej sends a Yes message to coord. !5. coor~ establishes \na quorum involving pj. It sends a Success message to slavej. 6. After pj is placed into a quorum, slavei \nsends No to ;oordk, rejecting coordk s deferred cap\u00adture request. In a somewhat different scenario in \nwhich coor~ fails to place pj into a quorum and thus sends a Release to slavej, slavej would send coordk \na Yes message to grant its deferred capture request. Therefore, in its attempt to capture slavej, coordi \ngenerates at most 6 messages. Theorem 3 Let #(pi[l ] ) be the number of mes\u00adsages transmitted by pi itself \nor generated by other processes in response to pi 7s messages while pi is coordinating I. Then, #(pi[~]) \n< 61~(-f) \\  5 Maximum Matching and Symmetric Roles The activation of an inst ante of an interaction \nre\u00adquires that each role is filled by a distinct process. However, a process in its enrollment phase \nmaybe ready for different roles of the same interaction. Let P be the partial quorum of a coordinator \npi. To decide whether P contains a quorum, pi needs to find in P a subset Q of size ]72(1)/ such that \nno two elements in Q specify the same role or process. This is just an instance of the maximum match\u00ading \nproblem, and thus can be solved in 0(m2 5 ) time [II]; here m is the number of processes cap\u00adtured by \nthe coordinator pi. Clearly, we can avoid performing maximum mat thing and, therefore reduce the time \ncomplex\u00adity to linear, if we do not allow a process to be ready for more than one role of the same inter\u00adaction. \nIn fact, in many multiparty applications certain roles of an interaction are symmetric in the sense that \na process can enrole into any one of them without observing any difference. A process tries all of the \nsymmetric roles because it is unaware of which of them are being targeted by other pro\u00adcesses and wants \nto avoid being locked out. For example, the recipient roles of the fist-order mul\u00adticast interaction \n(Section 1 ) ares ymmetric. Dead\u00adlock could arise if two processes were both to spec\u00adify unwittingly \nonly role recipient even though role recipient2 would equally suffice. To avoid this dilemma, a process \nattempting to participate as a recipient would, somewhat unnaturally, target all recipient roles. To \nfacilitate a more pleasant form of enrollment, symmetric roles can be replaced by a single generic role \nwith a constant indicating the number of in\u00adstances of the role to be filled. A process can then target \nthis generic role without concern as to which inst ante it will actually fill. The constant could even \nbe parametrized and supplied at run time by another enroler. Considering again our multi\u00adcast example, \nwe can define a first-order int erac\u00adtion with a transmitter and a generic recipient role which can be \nfilled by m processes; the transmit\u00adter would supply the actual value of m. Therefore, instances of the \ninteraction can be activated with somewhat different role structures. Within the setting of generic roles, \nwe can rea\u00ad sonably restrict a process to be ready for at most one role of an interaction at a time without \nraising the risk of deadlock.  6 Partners-Named Enrollment In partners-named enrollment a process can \nname some or all of the other enrolers [9]. For a set of processes to activate an interaction, their \nnaming specifications must be consistent in the sense that if p; names pj to fill role rk, then pj indeed \nenroles into rk. Note that the naming does not need to be bilateral. Unfortunately, the guard scheduling \nproblem becomes intractable, even when a process can be ready for only one interaction in the enroll\u00adment \nphase (i.e., enrollment stat ements cannot act aS guards). Theorem 4 Given a set of partners-named en\u00adrollment \nstatements each specijied by a distinct process, the problem of deciding whether there is a subset consistent \nin naming their partners is NP\u00adcomplete. Proofi By reduction from Monotone One-In-Three 3SAT [10]. D \nAs discussed in the introduction, partners\u00adnamed enrollment is desirable in some applica\u00adtions. In the \nfollowing we present two less se\u00advere forms of this scheme that have efficient im\u00adplementations, even \nwhen enrollment stat ements can serve as guards. First we define the com\u00admunication graph of an interaction \n1 to be the undirected graph having node set %?(1) and edges (r~, r.j) whenever role ri and rj directly \ncormmmi\u00adcat e. Partners-fully-named enrollment: A process, if it wants to name its partners, names all \nof them. Direct-partners-named enrollment: A pro\u00ad cess names the processes with which it commu\u00adnicates \ndirectly. Moreover, the set of enrollment guards of an alternative command must satisfy the disjointedness \ncondition: no two guards that tar\u00adget the same role name a common partner. The first restriction is simpler \nto formulate, but the second may be more useful in practice. For example, in a multicast, it is reasonable \nthat the transmitter names the recipients, but the recipients should only be required to name the transmitter \nand not fellow recipients. The disjointedness condition of the second form is crucial in allowing enrollment \nstatements to serve as guards. Otherwise, one can show that the guard scheduling problem is still intractable. \nRegarding the two restricted forms of partners\u00adnamed enrollment, finding a set of enrollment statements \nconsistent in naming specifications can be done in linear time, assuming that an inter\u00adaction s communication \ngraph is connected. The algorithm presented in Section 3 can be easily ex\u00ad tended to implement the two \nforms. 7 Dynamically Changing Envi\u00adronments Our algorithm can also be extended to a dynam\u00adically changing \nenvironment where processes are created and destroyed at run time. We assume a model in which, at any \ntime, processes can spawn new processes. However, a process can be de\u00adstroyed, by itself or by its parent, \nonly when it is not in the enrollment phase. Further, when a process pj creates a new child that is capable \nof playing role r of I, it informs each existing process pi < 7(1) of the identity of the new process \nso that Pi can update its ~(r). ~ ret~n, p; sends Pj an ac\u00adknowledgement message, having timestamp t;.Pj \nsets the logical clock of the new process to be larger than all the ti s. While waiting for its parent \nto set its clock, the new child defers any capture requests that may arrive, These deferred requests \nwill then be rejected by the new process when its clock is finally set. Similarly, when a process pj \nE P(1) is destroyed, it informs the existing processes in 7(1) to remove pj from their P(1). Since a \nprocess is not destroyed when it is in the enrollment phase, the safety property of The\u00adorem 1 is still \nguaranteed. The liveness property holds as well because a newly created process pj is always younger \nthan any existing coordinator pi. Hence, pj cannot interfere with p;as pj is unable to contend with pi \nin capturing a slave (see Section 3). Also, pineed not attempt to capture Pj such an attempt is doomed \nto fail anyway as a coordinator cannot capture a younger slave, Therefore, p; need only request capture \nof those processes created be\u00adfore pi entered its current enrollment phase, For\u00adtunately, this set of \nprocesses is finite. 8 Conclusion We have presented an efficient distributed algo\u00adrithm for the first-order \nguard scheduling problem, 219 the We first have such also algorithm described of which we are several \nextensions aware. of the [8] algorithm including generic roles, direct -partners\u00adnamed enrollment, and \ndynamically changing en\u00advironments. Up to now, we have not addressed the possibil\u00adityy of allowing enrollment \nstatements within roles. This leads to a notion of nested enrollment an [9] nth-order interaction, ment \nexists in some Our algorithm can of enrollment: level if you will. Nested enroll\u00adform already in 1P and \nScript. be safely applied at each level n enrollment will involve roles [10] of level n processes, rollment. \n 1,which reducing are the eventually problem filled by actual to first-order en\u00ad [11] Future work will \nfocus on lowering the constant of the message complexity, currently O (6m), and finding a probabilistic, \ncompletely symmetric solu\u00adtion to the problem. [12] Acknowledgement We thank Prof. Nissim Francez for \nproviding us with several references on 1P and some valuable insights into the language; and Shaji Bhaskar \nfor his constructive comments on the presentation of the algorithm. [13] [14] References [15] [1] Back, \nR.J.R. cooperation Prog. Lang. 513-544. and Kurki-Suonio, R., Distributed with action systems, ACM Trans. \non and Systems, Vol. 10, No. 4, 1988, pp. [16] [2] [3] Bagrodia, R. Process synchronization: design and \nperformance evaluation of distributed algorithms, IEEE Trans. on Soft. Engr., Vol. 15, No. 9, Sep. 1989, \npp. 1053-1065. Chandy, K. M. and Misra, J. A Foundation of Par\u00adallel Program De8ignt Addison-Wesley, \n1988. [17] [4] Forman, I. R. On the design of large distributed systems, ) in proc. First Int 11Conference \non C om\u00adputer Languages, Miami, Florida, 1986, pp. 84-95. [5] Francez, N. private communication, July, \n1990, [6] Francez, N. and Forman, I. R. Conflict propaga\u00adtion, in Proc. Third Int 1 Conference on Computer \nLanguages, New Orleans, Louisiana, 1990. [7] Francez, cesses: tributed N. and Forman, I. R. A Multiparty \nApproach to Programming. Forthcoming Interacting Pro-Coordinated Dis\u00adbook, 1990. Francez, N. and Forman, \nI. R. Interacting Pro\u00adcesses: A language for coordinated distributed pro\u00adgramming, invited paper for \nJerusalem Confer\u00adence on Information Technology, Jerusalem, Octo\u00adber, 1990.  Francez, N., Hailpern, \nB. and Taubenfeld, G. Script: A communication abstraction mecha\u00adnism, Science of Computer Programming \n6(l), Jan. 1986, pp. 35-88. Garey, M.R. and Johnson, D.S. Computers and Intractability: A Guide to The \nTheory of NP\u00adcompleteness, 1979. Hopcroft, J.E. and Karp, R. M. An n5/2 algo\u00adrithm for maximum matching \nin bipartite graph, J. SIAM Comp., 2 (1973), 225-31. Joung, Y.H. and Smolka, S. A. Efficient, dynam\u00adically \nstructured multiprocess communication, Proc. 28th Annual Allerton Conference on Com\u00ad munication, Control, \nand Computing, October, 1990. Kumar, D. An implementation of N-party syn\u00adchronization using tokens, Proc. \nTenth Int 1 Con\u00adference on Distributed Computing Systems, 1990. Lamport, L. Time, clocks and the ordering \nof events in a distributed system, Communications of the ACM, VOL21, No.7, July 1978, pp. 558-565. Park, \nM. H. and Kim, M. A distributed syn\u00ad chronization scheme for fair multi-process hand\u00ad shakes, Information \nProcessing Letters 34, April 1990, pp. 131-138. Ramesh, S. and Mehndiratta, S. L. A new class of high-level \nprograms for distributed computing systems, in Proc. Fifth Conference on FST-TCS. Lecture Notes in Computer \nScience 206, Springer-Verlag, Berlin, 1985, pp. 42-72. Ramesh, S. A new and etiicient implementation \nof multiprocess synchronization, in: Proc, Confer\u00adence on PARLE, Lecture Notes in Computer Sci\u00adence 259, \nSpringer-Verlag, Berlin, 1987, pp. 387\u00ad 401.  \n\t\t\t", "proc_id": "99583", "abstract": "", "authors": [{"name": "Yuh-Jzer Joung", "author_profile_id": "81100204016", "affiliation": "Department of Computer Science, SUNY at Stony Brook, Stony Brook, NY", "person_id": "PP39032324", "email_address": "", "orcid_id": ""}, {"name": "Scott A. Smolka", "author_profile_id": "81100533015", "affiliation": "Department of Computer Science, SUNY at Stony Brook, Stony Brook, NY", "person_id": "P261162", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/99583.99614", "year": "1991", "article_id": "99614", "conference": "POPL", "title": "Coordinating first-order multiparty interactions", "url": "http://dl.acm.org/citation.cfm?id=99614"}