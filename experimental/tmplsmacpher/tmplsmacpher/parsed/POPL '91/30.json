{"article_publication_date": "01-03-1991", "fulltext": "\n Temporal Proof Met homologies for Real-time Systems t Thomas A. Henzinger$ Zohar Manna$f Amir Pnueli~ \nAbstract. We extend the specification language of tem\u00adporal logic, the corresponding verification framework, \nand the underlying computational model to deal with real-time properties of reactive systems. The abstract \nnotion of a real-time transition system is defined as a conservative ex\u00adtension of traditional transition \nsystems: qualitative fair\u00adness requirements are replaced (and superseded) by quan\u00adtitative lower-bound \nand upper-bound real-time require\u00adments for transitions. We exhibit two styles for the specification \nof real-time properties. The first approach uses bounded versions of the temporal operators, while the \nsecond approach allows ex\u00adplicit references to the current time through a special clock variable. Corresponding \nto the two styles of specification, we present and compare two very different proof method\u00adologies for \nthe verification of real-time properties that are expressed in these styles. 1 Introduction It is self-evident \nthat the most sensitive and critical among reactive systems, and therefore the ones for which formal \napproaches are needed most direly, are real-time systems. The qualitative requirement of re\u00adsponsiveness, \nthat every environment stimulus p must be followed by a system response q, is no longer ade\u00adquate for \nreal-time systems; it has to be replaced by the stronger quantitative requirement of timedresponsive\u00adness, \nwhich imposes a bound on the time interval that is allowed between the stimulus p and the response q. \n*The fulf version of this paper is available as a technical report ([HMP91]). t This research was supported \nin part by an IBM graduate fellowship, by the National Science Foundation grants CCR\u00ad89-11512 and CC \nR-89-13641, by the Defense Advanced Re\u00adsearch Projects Agency under contract NOO03%84C-0211, by the United \nStates Air Force Office of Scientific Research un\u00adder contract AFOSR-W-0057, and by the European Community \nESPRIT Basic Research Action project 3096 (SPEC). t Department of Computer Science, Stanford University, \nStanford, CA 94305. ~Department of Applied Mathematics, The Weizmann In\u00adstitute of Science, Rehovot, \nIsrael 76100. Permission to copy without fee all or part of this material is granted provided that the \ncopies are not made or distributed for direct conunercial advantage, the ACM copyright notice and the \ntitle of the publication and its date appear, and notice is given that copying is by permission of the \nAssociation for Computing Machinery, To copy other\u00ad wise, or to republish, requires a fee and/or specific \npermission. @ 1990 ACM 089791419-8/90/0012/0353 $1.50 353 Over the past few years, there have been several \nsug\u00adgestions for extending the expressive power of temporal logic, which has been used successfully to \nspecify qual\u00aditative properties of reactive systems, to handle timing constraints. These attempts can \nbe roughly classified into two approaches. The first approach, to which we refer as the bounded\u00adoperator \napproach, introduces for each temporal opera\u00adtor, such as O, one or more time-bounded versions, For example, \nwhile the formula Oq states that the event q will happen eventually but puts no time bound on when it \nwill happen, the formula 0<3 q predicts an occurrence of q within 3 time units fro m now. This approach \nto the specification of timing properties has been advocated first in [KVdR83] and [K089], where the \nlanguage is called MTL; it is analyzed for its com\u00adplexity and expressiveness in [EMSS89] and [AH90]. \nAn alternative approach to the specification of tim\u00ading constraints of reactive syst ems int reduces \nno new temporal operators but interprets one of the nonrigid state variables (we use the variable t) \nas the current time at each state. We refer to this approach as the explicit-clock approach, because \nthe only new element is the ability to refer explicitly to the clock. Scat\u00adtered examples of this method \nto express timing prop\u00aderties are presented in [PdR82], [R084], and in [Ha88], [PH88], where it is referred \nto as GCTL. A more sys\u00adtematic exposition of this logic and its applications can be found in [0s90], \nwhere it is called RTTL. To compare the two approaches, consider the re\u00adquirement of a timed response \nof q top within at most 3 time units. In the bounded-operator approach, this requirement is specified \nby the formula P + o<3q) while in the explicit-clock approach it is expressed by the formula (p At= \nT)~O(q At< T+3), where the rigid variable T is used to record the time at the pstate. The main contribution \nof this paper is the elabora\u00adtion oft wo proof systems that correspond, respectively, to the two styles \nfor the specification of timing require\u00adments. It is a well-known observation that with the in\u00adtroduction \nof an explicit clock, all properties become safety properties. For example, the timed response property \nthat, in either style, is expressed above by a liven ess-like formula (employing the operator O) can \nalternatively be specified by a formula that uses the clock variable t and the safety operator U (unless): \n(PAt=T) -+ (t<7 +3)uq. This formula states that if p happens at time T, then from this point on, the \ntime will not exceed 7 +3 either forever (which is ruled out by an axiom that requires the time to progress \neventually) or until q happens. It follows that q must occur within 3 time units from p. Consequently, \nno new proof rules are necessary for the explicit-clock style of timed specification; all prop\u00aderties \ncan, in principle, be verified using a standard, uniform set of timeless rules. On the other hand, when \npursuing the bounded\u00adoperator style of specification, one discerns a clear dichotomy between upper-bound \nproperties such as the bounded-response formula p + 0<s q considered above, and lower-bound properties, \nsuch as the bounded-invariance formula P+ <3-W) which states that q cannot happen sooner than 3 time \nunits after any occurrence of p. Upper-bound prop\u00ad erties assert that something good will happen within \na specified amount of time, while lower-bound proper\u00ad ties assert that nothing bad will happen for a \ncertain amount of time. Clearly, the class of upper-bound properties bears a close resemblance to liveness \nproperties, while the class of lower-bound properties closely resembles safety properties. The proof \nsystem we present cultivates this similarity by including separate proof principles for the classes of \nlower-and upper-bound properties. These proof principles can easily be seen to be natural ex\u00adtensions \nof the proof rules for the untimed safety and liveness classes, respectively. In our model, we assume \na global, discrete, and asyn\u00ad chronous clock, whose actions (clock ticks) are inter\u00adleaved with the \nother system actions ([HMP90]). In some other work aimed at the formal analysis of real\u00adtime systems, \nit has been claimed that while this in\u00adter~eaving model of computation may be adequate for the qualitative \nanalysis of reactive systems, it is inap\u00adpropriate for the real-time analysis of programs, and a more \nrealistic model, such as maximal parallelism or even continuous time, is needed. One of the points that \nwe demonstrate in this paper is a refutation of this claim. We show that by a careful incorporation oft \nime into the interleaving model, we can still model ade\u00adquately most of the phenomena that occur in the \ntimed execution of programs. Yet we retain the important economic advantage of interleaving models, namely, \nthat at any point only one transition can occur and has to be analyzed. In Section 2, we define the abstract \ncomputational model of a real-time transition system and illustrate how concrete real-time systems and \nreal-time phenom\u00adena can be mapped into this model. Section 3 in\u00adtroduces the bounded-operator specification \nlanguage, and Section 4 presents a proof system for this language. In Section 5, we discuss the alternative, \nexplicit-clock, approach. Section 6 concludes by giving completeness results for both methods. 2 Computational \nModel We define the semantics of a real-time system as a set of timed behaviors. This is done in two \nsteps. First, we int reduce the abstract notion of a real-time t ransi\u00adtion system and identify the possible \ntimed behaviors (computations) of any such system. Then, we consider the concrete model of real-time \nmultiprocessing sys\u00adtems that communicate through shared variables, and show how to interpret the concrete \nconstructs within the abstract model. In the full paper, we also show how message-passing and multiprogramming \nsystems can be modeled in this framework ([HMP91]). 2.1 Abstract model: Real-time transition system The \nbasic computational model we use is that of a transition system ([MP89a]), which we generalize by adding \nreal-time constraints. We classify the real\u00adtime constraints into two categories: lower. and uPPer\u00adbound \nrequirements. They assure that transitions are taken neither too early nor too late, respectively.1 A \nreal-time transition system S = (V, E, (3, T, 1, u) consists of the following components: a finite set \nV of variables, including the boolean variable jirst. o a set X of states. Every state u G X is an inter\u00adpretation \nof V; that is, it assigns to every variable z G V a value a(x) in its domain. 1To simplify the verification \nmethods, the detition of a real\u00adtime transition system has been significantly changed since in\u00adtroduced \nin [H MP90]. That preliminary work is, in the current paper, also extended by the treatment of nondeterminism \nand by completeness results. a set @ G X of initial states. We require that s = (v, x,tl, T,/, u ) iff \nit satisfies the following re\u00ada(jkst) = true for all initial states a ~ @. quirements:  a finite set \nT of transitions, including the idle tran-[Initialiiy] U. c @ and To = O; that is, the time of sition \n~1. Every transition T E ~ is a binary acces-the initial state is O. sibility y relation on ~; that is, \nit defines for every [Conse.zdion] For all i >0 there is a transition state a G X a (possibly empty) \nset of ~-successors r 6 7 such that ai+l ~ r(ai). We say that r ~(a) ~ Z. We require that m (fhw!) = \nfalse for all is taken at position i and completed at position ~-successors u e I-(u) of every state \na. i + 1. At both stuttering steps and clock ticks, the The transition r is enabied on a iff ~(u) # 0. \nLet idle transition TI is taken. ~+ denote the state that differs from a at most in [Lower bound] For \nevery transition ~ c T and all the interpretation of the variable first, to which at positions i >0 and \nj ~ i such that Tj < Ti + 1,, assigns the value false. The idle (stutter) transi\u00adif ~ is taken at position \nj, tion then Tj ~ 17 and r is enabled on ~i. T1= {(u, U+) :U ~ ~} In other words, once enabled, r is \ndelayed for at is enabled on every state. least 1, clock ticks; it can be taken only after being  a \nminimal delay 1. E N for every transition T E ,7. cent inuousl y enabled for 1~ time units. In particular, \nl~r = O.  [Upper bound] For every transition T c 7 and po\u00ad  a maximal delay UT G N U{cm} for every \ntransition sition i > 0, there is some position j > i with r GT. We require that u, ~ [T for all T c \nT, and Tj s Ti + u, such that U,I = co (for notational convenience, we assume  either r is not enabled \non Oj, that oo z n for alln GN). or r is taken at position j. Let To ~ T be the set of transitions with \nthe max-In other words, once enabled, ~ is delayed for at imal delay O. To allow time to progress, we \nput a most UT clock ticks; it cannot be continuously en\u00ad restriction on these transitions. We require \nthat abled for more than U7 time units without being there is no sequence of states Uoul . . . an such \nthat taken. n > ITOI and, for all O ~ i < n, Ci+l E r(cri) for some transition r &#38; To. The computations \nof a real-time transition system are obtained by closing the set of initialized compu- A timed state \nsequence p = (u, T) consists of an infi\u00ad., tations under suffices: the timed state sequence p is nite \nsequence u of states Ui E E, i ~ O, and an infinite an computation of S iff p is a sufiix of an initialized \nsequence T of corresponding times T~ c N, i z O, that computation of S. satisfy the following conditions: \nNote that we consider all computations of the system [Bounded monoionicity] For all i ~ O, S to be infinite; \nfinite (terminating as well as deadlock\u00adeither Ti+l = Ti, ing) computations can be represented by infinite \nex\u00ador Ti+l = Ti + 1 and ~i+l = ~i; tensions that add only idle transitions TI. The compu\u00ad tations of \nany real-time transition system are, further\u00ad that is, the time never decreases. It may increase, more, \nclosed under stuttering: the addition of finitely by at most 1, only between two consecutive states many \nstuttering steps to a timed state sequence does that are identical. The case that the time stays the \nnot alter the property of being a computation of S. same between two identical states is referred to \nas Also observe that the state component of any com\u00ad a stuttering step; the case that the time increases \nputation of S is, in the sense of [MP89a], a computa\u00ad is called a clock tick. tion of the (untimed) transition \nsystem S-that results [Progress] For all i ~ O there is some j > i such from S by disregarding all delays. \nIt follows that or\u00adthat Ti < Tj; that 1s, the time never stagnates. dinary timeless reasoning is sound \nfor real-time transi-Thus there are infinitely many clock ticks. tion systems. By pi = (m;, Ti) we denote \nthe i-th sufix of p; it con-The timing constraints of S can be viewed as filters sists of the infinite \nsequence Ui = uiui+l . . . of states that prohibit certain possible behaviors of the under\u00adand the infinite \nsequence Ti = TiTi+l . . . of times. lying untimed system S-. Special cases are a minimal Note that pi \nis, for all i ~ O, again a timed state delay O and a maximal delay m for a transition r. sequence; that \nis, the set of timed state sequences is While the former does not rule out any computations closed under \nsuffices. of S-, the latter adds to 5 -a weak-fairness assurnP- The timed state sequence p = (a, T) is \nan initialized tion: r cannot be continuously enabled without being computation (run) of the real-time \ntransition system taken. 2.2 Concrete model: Shared variables The concrete real-time systems we consider \nconsist of a fixed number of sequential programs that are executed in parallel, on separate processors, \nand communicate through a shared memory. A shared-variables multiprocessing system P has the form {o}[P,ll... \n[[Pm]. Each process P~, 1 < i < m, is a sequential nonde\u00adterministic real-time program over the finite \nset Ui of private (local) data variables, and the finite set U. of shared data variables. The formula \n6, called the data precondition of P, restricts the initial values of the vari\u00adables in U = U. U IJl<i<m \nU~. The real-time prog~ati Pi can be alternatively pre\u00adsented in a textual programming language, or as \ntran\u00adsition diagrams. We shall use the latter, graphical, representation. A transition diagram for the \nprocess Pi is a finite di\u00adrected graph whose vertices Li = {l?:, . . . l~i } are called locations; l; \nis considered to be the entry location: 4 The intended meaning of the entry location is that the control \nof the process Pi starts at the location 1: at time O. Each edge in the graph is labeled by a guarded \nin\u00ad struction, a minimal delay 1 c N and a maximal delay u c NU{m} such that u > 1: c-+x:=e where the \nguard c is a boolean expression, x is a vari\u00ad able, and e an expression (the guard true and the delay \ninterval [0, m] are usually suppressed; the instruction c ~ z := x is often abbreviated to c?). We require \nthat every cycle in the graph consists of no fewer than two edges, at least one of which is labeled by \na posi\u00ad tive (nonzero) maximal delay. The intended operational meaning of the given edge is as follows. \nThe minimal delay 1 guarantees that whenever the control of the process Pi has resided at the location \nl; for at least 1 time units during which the guard c has been continuously true, then Pi may proceed \nto the location f~. The maximal delay u en\u00adsures that whenever the control of the process Pi has resided \nat l; for u time units during which the guard c has been continuously true, then Pi must proceed to f!~. \nIn doing so, the control of Pi moves to the loca\u00adtion t; instantaneously, and the current value of e \nis assigned to x. In general, a process may have to proceed via several edges all of whose guards have \nbeen continuously true for their corresponding maximal delays. In this case, any such edge is chosen \nnondeterministic ally. To demonstrate the scope of this model, we show how the typical real-time application \nof a timeout situ\u00adation can be represented. Consider the process P with the following transition diagram: \nWhen at the location 10, the process P attempts to proceed to the location/1 for 10 time units, by checking \nthe value of x at least once every time unit. If the value of z is different from O at least once every \ntime unit, then P may not succeed and has to proceed to the alternative location /2 at time 10. This \noperational view of the concrete model can be captured by a simple translation. With the given shared-variables \nmultiprocessing system P, we associate the following real-time transition system  Sp= (v, x,e,7, i,u): \n V=uu{?rl,... first}. Each control m,m,variable 7ri, 1< i < m, ranges over the locations Li of the corresponding \nprocess Pi.  22 contains all interpretations of V.  @ is the set of all states a c X such that O is \ntrue in U, cr(ni) = 4$for all 1~ i s m, and u(jirst) = true.  T contains, in addition to TI, a transition \nTE for every edge E in the transition diagrams for PI, . . . Pm. If E connects the source location ~ \n to the target location l; and is labeled by the in\u00adstruction c -+ z := e, then a G TE(0) iff a(~i) \n= l; and ~ (ni) = -!?~, c is true in a, a (x) = u(e), a (jirst) = false, c7 (y) = a(y) for ally E V {7r~, \nz, first}. If TE is uniquely determined by its source and tar\u00adget locations, we often write r~+k. e \nFor every edge E labeled by the minimal delay 1, let 1~~= 1. For every edge E labeled by the maximal \ndelay u, let u~E= u. This translation defines the set of possible computa\u00adtions of the concrete system \nP as a set of timed state sequences. We remark that the translation is conservative over the untimed \ncase. Suppose that the system P contains no delay labels (recall that, in this case, all minimal delays \nare O and all maximal delays are cm). Then the state components of the initialized computations of Sp \nare precisely the legal execution sequences of P, as de\u00adfined in the interleaving model of concurrency, \nthat are weakly fair with respect to every transition ([MP89a]); weak fairness (progress) for every individual \ntransition and, thus, for every process is guaranteed by the max\u00adimal delays co. 2.3 Other concrete models \nThe interleaving model for concurrency identifies true parallelism with (sequential) nondeterminism. \nHow\u00adever, when time is of the essence, we can no longer ignore the difference between multiprocessing, \nwhere each parallel task is executed on a separate machine, and multiprogramming, where several tasks \nreside on the same machine. This is because questions of prior\u00adities, interrupts, and scheduling of tasks \nmay strongly influence the ability of a system to meet its timing con\u00adst raints. Consider the following \nexample of a real-time system in a multiprogramming environment. Suppose that the process PI responds \nto an external event el and the process P2 responds to the event ez, and that the re\u00adsponse to el is \nmore urgent. In the simplest case, every process is assigned a static prior-it y; thatis, we assign a \nhigher priority t o PI than to P2. Then, whenever P2 is executed and el happens, P2 is interrupted and \nPI responds to el, after which P2 resumes. Given the frequencies with which el and ea occur as well as \nupper bounds on the times that the processes take to respond if they are not interrupted, a typical real-time \nanalysis of the system infers upper bounds on the response times. In a more general setting, priorities \nare assigned to regions of processes or even individual transitions. This is to disallow certain critical \nregions to be in\u00adterrupted by other processes. Priorities can be in\u00adcoropated into the shared-variables \nmodel by restrict\u00ading the enableness of transitions: a transition is only enabled if no transition with \na higher priority is en\u00adabled. If a more flexible scheduling policy than static pri\u00adorit ies is required, \nwe may add an additional process, the scheduler, which has the highest priority and de\u00adtermines which \nprocess is executed at any given time. We model scheduling transitions such as interrupt and resume by \na shared variable, whose value determines the process whose transitions are currently enabled. A formal \ntreatment of priorities and scheduling, as well as real-time systems that communicate by message passing, \nis given in the full paper ([HMP91]).  3 Specification Language Having settled on our computational \nmodel, we need a sufficiently expressive language that is interpreted over timed state sequences in order \nto specify real-time sys\u00adtems. We distinguish between state formulas, which assert properties of individual \nstates of a computation, and temporal formulas, which assert properties of en\u00adtire computations. 3.1 \nState formulas Let S = (V, 2, @, T, /, u) be a real-time transition sys\u00adtem. We assume a first-order \nlanguage with equality that contains interpreted function and predicate sym\u00adbols to express operations \nand relations on the domains of the variables in V. Formulas of this language are interpreted over the \nstates in X, and called state for\u00admulas. If the state formula p is true in state a, we say that u is \na p-state. We use the following abbreviations for state formu\u00adlas: . The starting condition start holds \nprecisely in the initial states Cl. For any transition r ~ T and state formulas p and q, the tierijication \ncondition {p} r {q} asserts that ifpistrue ofastate aEZ, then qistrue of all r-successors of a. For any \nset T ~ T of transitions, we write {p} T {q} for the conjunction A,ET{P}T{q} ofallindividualverification \n  condi\u00ad tions. . For any transition T E T, the enabling condition enabled(r) asserts that r is enabled. \nIn particular, enabled(~~) is equivalent to true. For the case that the real-time transition system \nS is associated with a shared-variables multiprocessing system P, itis easy to see that the starting \ncondi\u00adtion, verification conditions, and enabling conditions can indeed be expressed by state formulas. \nSuppose that P consists of the m processes Pi, 1< i ~ m. Let atyj stand for ~i = l;; that is, the control \nof the process Pi is at the location l}. We ab\u00adbreviate any disjunction at d; V at _l?~ further, to at \nl~,k. If 6 is the data precondition of P, then the starting condition start is equivalent to Let r E \nT be a transition of S, and E the corre\u00adsponding edge in the transition diagram for P; assume that E \nconnects the location 1~ to the location Ii and is labeled by the instruction c + z := e. Then, the enabling \ncondition enabied(r) is equivalent to at~~ A c, and the verification condition {p}t-{q} is equivalent \nto (pA enab~ed(r) A (at~~) A qfirst A (z = ) A =Y)) e  AyW-{mC,fi.St}(Y where q) is obtained from q \nby replacing every variable with its primed version (for example, ( ai~j ) stands for 7r( = 1~). 3.2 \nTemporal formulas Temporal formulas are constructed from state formulas by boolean connective and bounded \ntemporal opera\u00adtors; they are interpreted over timed state sequences. In this paper, we are mostly interested \nin proving two important classes of real-time properties bounded\u00adinvariance and bounded-response properties. \nThus we rest rict ourselves to the following temporal formulas: Every state formula p is a temporal \nformula; it is true over the timed state sequence p = (u, T) iff the initial state a. is a p-state. \n Every boolean combination of temporal formulas is a temporal formula, whose truth over a timed state \nsequence is determined from the truth of its components in the obvious way.  If p is a state formula, \nI#Ja temporal formula, and 1 c N, then p U>r ~ is a temporal formula; it is true over the tified state \nsequence p = (o, T) iff either all a~, i z O, are pstates, or there is some position i ~ O such that \nTi z To+ 1, # is true over the i-th suffix pi of p, and all Uj, O ~ j < i, are p-states.  Note that \nthe formula p U>. q is true over p iff the untimed urdess formula p U q is true over the state component \nu of p. We use the abbreviations pU@, <iP, and pU~l 4 for the formulas pU20 4, pU2/ true, and pA(jU>rqiJ). \nIf @ is a temporal formula and u c N, then ~<u + is a temporal formula; it is true over the ti med state \nsequence p = (u, T) iff there is some position i ~ Osuch that Ti ~ To + u and ~ is true over the i-th \nSUf&#38; p; Of p. Temporal-logic aficionados will readily recognize the operators U>/, <r, and O<U as \ntime-bounded ver\u00adsions of the c-onventional (un~med) unless, akvays, and eveniual/y operators ([MP89]). \nWith these bounded temporal operators we can express two important classes of real-time properties (for \na general addition of time-bounded operators to linear temporal logic, see [AH90]). A bounded-invariance \nproperty asserts that some\u00adthing will hold continuously for a certain amount of time; it is often used \nto specify that some\u00adthing will not happen for a certain amount of time. A typical application of bounded \ninvariance is to state a lower bound 1 on the termination of a sys\u00adtem S: if started at time O, then \nS will not reach a final state before time 1. Formally, we express bounded-invariance proper\u00adties by \ntemporal formulas of the form P + </q, for state formulas p and q and 1 c N. Recall that the formula \np + <r q is true over the timed state sequence p = (u)T) H, for all i z Oand j ~ i, if Ui is ap-state \nand Tj < Ti + 1, then Uj is a q-state; that is, no p-state is followed by a ~q-state within time less \nthan 1. A bounded-response property asserts that some\u00adthing wilI happen within a certain amount of time. \nA typical application of bounded response is to state an upper bound u on the termination of a system \nS: if started at time 0, then S is guaran\u00adteed to reach a final state no later than at time u. Formally, \nwe express bounded-response properties by temporal formulas of the form p -O<uq, for state formulas p \nand q and u e N. Recall that the formula p + O<U q is true over the timed state sequence p = (o-, T~ \niff, for all i z O, if a~ is a p-state, then there is some q-state Cj, j ~ i, such that Tj <T;+u; that \nis, every pstate is followed by a q-state within time u. From now cm, we use the convention that the \nletters P, q, r as well as q (and primed versions) denote state formulas, while the letters ~, ~, and \nx stand for arbi\u00adtrary temporal formulas. We say that a temporal formula is S-valid iff it is true over \nall computations of the real-time transition system S; (general) validity (i.e., truth under every in\u00adterpretation) \nimplies of course S-validity for every sys\u00adtem S. Aproofrule iscalled S-soumt iffthe S-validity of all \npremises implies the S-validity of the conclusion. Any S-sound rule can be used for verifying proper\u00adties \nof the system S. Consider the following mono\u00adtonicity rule U-MON, which allows us to weaken any oft he \nthree arguments of the bounded-unless operator: U-MON p + p 4++ V<! (pu~J4) + (p u~il~ ) It is not hard \nto see that this rule is S-sound for every real-time transition system S. A similar, also universally \nS-sound, monotonic it y rule holds for the bounded-eventuality operator: O-MON ~-+qS U >u (0<. 4) + (o<u~4 \n) We will refer to applications of these two weakening rules in derivations through the simple annotation \nby monotonicit y.  4 Verification by Bounded-operator Reasoning We show how to prove that a given a \nreal-time tran\u00adsition system S = (V, X, O, T,l,U) satisfies its speci\u00adfication. In particular, we present \na deductive system to establish the s-validity of bounded-invariance and bounded-response properties. \nThe proof rules fall into three categories: the single-step rules derive real-time properties that follow \nfrom the lower-or upper-bound requirement for a single transition, while the transitiv\u00adity and induction \nrules combine real-time properties into more complicated ones. First we present the methodology to verify \ndetermin\u00adistic systems (S is deterministic if any two guards that are associated with outgoing edges \nof the same vertex in the transition diagram of S are disjoint). Nondeter\u00administic systems require more \ncomplex (conditional) single-step reasoning and are treated at the end of this section. 4.1 Single-step \nrules The single-step lower-bound rule uses the minimal de\u00adlay 1, E N of a transition T E ~ to infer \na bounded\u00adunless formula (by T r we denote the set difference T {T}): The rule U-SS derives a temporai \n(bounded-unless) formula from premises all of which are state formu\u00adlas. The state formula p is called \nthe invariant of the rule. Choosing r to be true, the rule infers a bounded\u00adinvariance property, (note \nthat the last premise holds trivially in this case), To see why the rule U-SS is S-sound, observe that \nwhenever the transition r is not enabled, it cannot be taken for at least 17 time units. Also, -r cannot \nbe taken within the first IT time units of any initialized computation. The single-step upper-bound rule \nuses the maximal delay UT c N of a transition T E T to infer a bounded\u00adresponse formula m {p}T{q} \u00ad \n p * O<urq This rule derives a temporal bounded-response formula from premises all of which are state \nformulas. The state formula p is again called the invum ant of the rule. To see why the rule 0-SS is \ns-sound, recall that the transition r has to be taken before it would be continuously enabled for more \nthan U7 time units. To demonstrate a typical application of the single\u00adstep rules, consider the single-process \nsystem P with the data precondition x = O and the following transi\u00adtion diagram: The process P confirms \nthat z = O and proceeds to the location YI. Because of the delay interval [2,3] of the transition ~o+l, \nthe final location /1 cannot be reached before time 2 and must be reached by time 3. Using single-step \nreasoning, we can carry out a for\u00admal proof of this analysis. The bounded-invariance property that P \ndoes not terminate before time 2, start + I<2 Yat_Ql, is established by an application of the single-step \nlower\u00adbound rule U-SS with respect to the transition ~o+l (let the invariant q be atl,). The bounded-response \nproperty that P terminates by time 3, follows from the single-step upper-bound rule 0-SS with respect \nto the transition To+ 1 (use the invariant af&#38;Az= O). 4.2 Transitivity y rules To join a finite \nnumber of successive real-time con\u00ad straints into a more complicated real-time property, we introduce \ntransitivity rules. The transitive lower-bound rule combines two bounded-unless formulas: U-TRANS @ \n~ pU2/1 X I We refer to the formula x as the link of the rule. The transitive upper-bound rule combines \ntwo bounded-response formulas: I O-TRANS q!I+ O,m, x I The formula x is again called the link of the \nrule. Both transit ivit y rules are easily seen to be S-sound for every real-time transition system S. \nWe demonstrate the application of the transitivity rules by examining the single-process system P with \nthe following transition diagram: x=()? x=()? We want to show that P terminates not before time 4 and \nnot after time 6. First, we prove the lower bound on the termination of P: start + <4 Yat12. By the transitive \nlower-bound rule U -TRANS, it suf\u00adfices to show the two premises Both premises can be established by \nsingle-step lower\u00adbound reasoning. To show the premise (1), we apply the rule U-SS with respect to the \ntransition ro+l, using the invariant at J?.; the premise (2) follows from the rule U-SS with respect \nto the transition ~1+2 and the invariant at _lo,l. The upper bound on the termination of P, sta~ ~ 656 \nat~z, is concluded by the transitive upper-bound rule O-TRANS. It suffices to show the premises start \n-+ 0<3(at-./1 A a= O), (at_./l A z= O) -+ 0<3atJ?2, both of which can be established by single-step upper\u00adbound \nreasoning (use the invariants at J20 A x = O and at~l A z = O, respectively). Note that for lower-bound \nreasoning the link at~o identifies the last state before the transition To-l is taken, while for upper-bound \nreasoning the link atJ1 A z = O refers to the first state afler ~o+l is taken, For an example with a \n(deterministic) branching structure, consider the process P with the following transition diagram w We \nshow that P terminates either at time 3 or at time 4. The proof requires a case analysis on the initial \nvalue of x, which determines which path of the transition diagram is taken. The lower bound start -+ \n<B1at&#38; is implied by the two bounded-invariance formulas (start A x = O) ~ <31at_f?3, (start A z \n#O) + l<3mat_13, each of which can be derived by transitive lower-bound reasoning (use the links at 10 \nA x = O and at .!O A x # (), respectively). The upper bound follows by a similar case analysis and transitive \nupper\u00adbound reasoning. So far we have examined only single-process exam\u00adples. In general, several processes \nthat communicate through shared variables interfere with each other. Consider the two-process system \nwith the data pre\u00adcondition x = 1 and the following transition diagrams: The first process, PI, is identical \nto a previous example; with a minimal delay of 2 time units and a maximal delay of 3 time units, it confirms \nthat z = O and pro\u00adceeds to the location l+. However, this time the value of x is not O from the very \nbeginning, but set to O by the second process, P2, only at time 1. Thus, PI can reach its final location \nl; no earlier than at time 3 and no later than at time 4. For a formal proof we need the transitivity \nrules. The bounded-invariance property is established by an application of the transitive lower\u00adbound \nrule U-TRANS. It suffices to show the premises both of which follow from single-step lower-bound rea\u00adsoning. \nSimilarly, the transitive upper-bound rule O-TRANS is used to show the bounded-response property start \n+ 0c4 atl~ from the link at~~ A x = O. 4.3 Induction rules To prove lower and upper bounds on the execution \ntime of program loops, we need to combine a state\u00addependent number of bounded-invariance or bounded\u00adresponse \nproperties. For this purpose it is economical to have induction schemes. The inductive lower-bound rule \nU-IND generalizes the transitive lower-bound rule U-TRANS: it com\u00adbines a potentially large number of \nsimilar bounded\u00adunless formulas in a single proof step. Assume that the new, rigid (static) variable \ni c V (i.e., i @ V and i = i ) ranges over the natural numbers N; for any n6N: U-IND (~(i) A i > O) ~ \nZJU>~p(i 1) p(n) + p u~n.rp(o) By p(i 1) we denote the state formula that results from the inductive \ninvariant p(i) by replacing all oc\u00adcurrences of the variable i with the expression i 1; the formulas \np(n) and P(O) are obtained analogously. Note that every instance of the rule U-IND, for any constant \nn c N, is derivable from the transitive lower\u00adbound rule U-TRANS. For a demonstration of inductive lower-bound \nrea\u00adsoning, consider the following single-process system P: z:=z 1 [2,3] [o,o]]x#o? The process P decrements \nthe value of z until it is O, at which point P proceeds to the location 12. Since x starts out with the \nvalue 5, and each decrement op\u00aderation takes at least 2 time units, while the tests are instantaneous, \nthe final location 42 cannot be reached before time 10. This lower bound, start -+ 13<10=atiz, follows \nby transitivity and monotonicity from the two bounded-unless properties The first property, (1), is enforced \nby two single-step lower bounds; the second property, (2), can be derived by the inductive lower-bound \nrule U-IND from the premise (at21Az = i+l Ai > O) a (=at_~2)u22(at21Ax = i), which is concluded by transitive \nreasoning. The inductive lower-bound rule has a twin that com\u00adbines several similar bounded-response \nformulas by adding up there upper bounds u. In fact, both induc\u00adtion rules can be generalized, by letting \nthe bounds 1 and u vary as functions of i. In its more general form, we state only the inductive upper-bound \nrule. It uses again a new, rigid variable i c V that ranges over the natural numbers N; for any n c N: \nO-IND (p(i) A i > O) -0<., ~(i 1) g(n) + ogo<i<n~ip(o) Every instance of this rule is derivable from \nthe tran\u00adsitive upper-bound rule O-TRANS. The general form of the inductive upper-bound rule is useful \nto prove upper bounds for programs with loops whose execution time is not uniform. An example for such \na system is the odd-even variant of the process P in Figure 1. odd(x)? + x:=x 1 even(x)? -+ *:=x l x=()? \n{x= 5} Figure 1: Odd-even 4.4 Conditional rules Unfortunately, our proof system is not strong enough \nto show tight bounds on nondeterministic systems. To see this, consider the following nondeterministic \nvari\u00adant P of a process encountered previously: This presentation represents really two rules, depend\u00ading \non whether t = O, which is, strictly speaking, not a state formula. The rule is U-CSS S-sound for anytrae? \ntemporal formula ~. In our example, we use the conditional single-step lower-bound rule U-CSS with respect \nto the transi\u00ad true? tions ~o+l and ~o+2 to derive the conditional single\u00adstep bounds As before, P terminates \neither at time 3 or at time 4. (start U+ attio U+ atfll) + (start U+ atlo Uj, ail,), However, during \nan execution of P, one of the two tran-(start U+ aiYo U+ atYz) -+ (start U+ at.lo U~l at_12). sitions \nro~ 1 and 7.+2 is chosen nondet erminist ically. They allow us to conclude, from (~),Thus we cannot carry \nout a case analysis with respect to a state formula that selects a unique guard. ( start U+ at.to U$2 \natJ l V Instead, we proceed in two steps. First we estab-start + (t) start U+ atJ?o iJ~l atlz lish \nan untimed formula that enumerates all possible ). nondet erministic choices. Then we decorate the un- \nTo collapse nested unless operators, we use the valid bounded temporal formula with time bounds. temporal \nformula U-C OLL: Step 1. To establish the S-validity of a temporal formula @ that is built only from \nconnect ives and U (i.e., U20) operators, it suffices to show that ~ is true over all (untimed) computations \nof the transition sys\u00adtem S underlying S. This can be achieved with the This formula can be derived from \nthe transitive lower\u00ad help of any conventional (timeless) proof system (for bound rule U-TRANS. instance, \nthe proof system of [MPS9b]). From (~) we obtain by collapsing and monotonicity To derive the lower \nbound 3 on the termination of our example P, we show the untimed formula start --i (at_/o UJ2 atfll V \nat-t?o Ujl at J?2);  ( start LJ~ atl~ lJ~ atll V that is, using the (untimed) validity p ~ p U p and \nstart -+ (t) start U+ at-lo U+ atJ?Z ) monotonicity, (nested unless operators associate to the right). \n Step 2. To add time bounds to this disjunction of nested unless formulas, we need conditional single\u00adstep \nrules. They establish single-step real-time bounds Adding conditional single-step lower bounds for the \nunder the assumption that a particular disjunct has transitions rl -3 and TZ-3 gives been chosen. The \nconditional single-step lower-bound rule uses the minimal delay ir E N of a transition r c T: and by \ncollapsing and monotonicity we finally arrive This extension is interesting, because once we are at the \ndesired bounded-invariance property given explicit access to the global clock through a clock variable \nt, both bounded-invariance and bounded\u00adstart -<3-at.L3. response properties can alternatively be formulated \nas unbounded unless properties and, consequently, ver-Conditional upper-bound reasoning does not require \nified by conventional (timeless) techniques for estab\u00adthe nesting of unless operators. The conditional \nsingle\u00ad lishing safety properties. step upper-bound rule uses the maximal delay UT E N of a transition \nT 6 T: 5.1 Explicit-clock transition systems Let S = (V, 2, Cl, T, 1, u} be a real-time transition sys\u00adtem. \nWe introduce the following new variables:   r2iEE2J The clock variable tranges over the natural num\u00adbers \nN; it records, in every state Ui of a computa- Note that the second premise of this rule is trivially \ntion p = (u, T), the corresponding time Ti. valid if T becomes disabled by being taken, as is the case \nfor all transitions of a real-time transition system The delay counters 6T, r c T, range over N; they \nthat is associated with a shared-variables multiprocess-record, in every state of a computation, for \nhow ing system (recall that we have ruled out selfloops in many clock ticks the transition 7 has been \ncontin\u00adtransition diagrams). uously enabled without being taken. It is also worth pointing out that both \nconditional We often write d~+k short for 6,{ ~-k lower-bound and conditional upper-bound reasoning \nThe ezp!icit-clock transition system rely only on assumptions that are safety (unless) for\u00admulas. S*=(V*, \nX*, CI*,7*, W,7) To derive the upper bound 4 on the termination of our example P, we show first the untimed \nformula associated with S is defined to be the following (un\u00adtimed) fair transition system (in the sense \nof [MP89a]): start -(atdo U at~l V atJ?O U atJ?Z).  V*= VU{t}U{&#38;:r CT}. By the conditional single-step \nupper-bound rule  Z* contains all interpretations of V*. O-CSS with respect to the transitions TO+ I \nand TO+2,  @* contains all extensions a* of interpretations we derive the conditional single-step bounds \na c @ such that, for all r c T, (atJ?o U atll) + OSZ atfll, u*(t) = O and (atYo U atflz) -+ O~Z atJ&#38;. \n (7 (8,) = o. They allow us to conclude . T* contains, for every r c T, a transition r* such that (cry, \nu;) c ~ iff, for all r G z , (q, q) (s r, Now we can proceed by unconditional upper-bound (7; (C$T) \n> 1,, reasoning to arrive at the desired bounded-response a;(t)= a;(t), property a~(d~,) if r # T is \nenabled on U2 u;(6T/) = ostart + 0<4 atls. otherwise. {  Note that the second clause, a; (8,) z /7, \nenforces 5 Verification by all lower bounds. In addition, T contains the tick transition TT Explicit-clock \nReasoning such that (a;, u;) G 7T iff, for all r E T, We point out that none of our state formulas is \nable u~= q> to refer to the value of the time, and the only real\u00ad a;(t)= q(t)+ 1, time references that \nare admitted in temporal formulas u~(6r~) + 1 if r is enabled on al are bounded temporal operators. \nIn this section, we u; (6./) = o otherwise, { investigate the consequences of extending the notion of \n17; (&#38;f) < UT,. state, by adding a variable t that represents, in every state, the current time. \nThe last clause enforces all finite upper bounds. W contains, for every transition r* with r G T, a \nweak-fairness requirement that assures that no transition T* can be continuously enabled without being \ntaken. F contains a strong-fairness requirement for the tick transition rT that assures that TT cannot \nbe enabled infinitely often without being taken. The real-time transition system S and the explicit\u00adclock \ntransition system S* are related in the following way: for every initialized computation p = (u, T) of \nS, there is a unique (untimed) initialized computation a of S* such that, for all i z O, the state u; \nis an exten\u00adsion of ai to V* and a;(t) = Ti; and for every com\u00adputation a of S*, the timed state sequence \n(a, ~ (t)) is a computation of S if every state Ui, i > 0, is the restriction of u: to V. 5.2 Explicit-clock \nformulas Now we translate every bounded-invariance and bounded-response formula q5 over V into an untimed \nunless formula ~ that contains the clock variable t. The explicit-clock formula ~ is constructed such \nthat it it S*-valid iff ~ is S-valid: The explicit-clock translation of the bounded\u00adinvariance formula \np -+ < ~q is (pAt=T)~qu(t2~+~), for a new, rigid variable T (i.e., T # V* and T= T ). The explicit-clock \ntranslation of the bounded\u00adresponse formula p -+ O<U q is (@ At=T) -+ (t~T+u)Uq. for a new, rigid variable \nT. Both unless formulas use the rigid variable T to record the time of the p-state. In the case of bounded-response \nproperties the explicit-clock translation exploits the fact that the time is guaranteed to reach and \nsurpass T+ u, for any value of T. The proof that the explicit-clock formula ~ is in\u00addeed S*-valid iff \n~ is S-valid is given in the full paper ([HMP91]). This result leads to an alternative and quite differ\u00adent \napproach to the verification of real-time properties: to prove the S-validity of a real-time property \n~ (over V), we establish instead the S*-validity of the untimed safety formula O* (in fact, the S-validity \nof any t em\u00adporal formula @ can be concluded in this way). To show the unbounded unless formulas that \nresult from translating bounded-invariance and bounded\u00adresponse properties, a single timeless unless \nrule suf\u00adfices: We emphasize that all premises are state formulas; the state formula p is called the \ninvariant of the rule. To demonstrate this kind of explicit-clock real\u00adtime reasoning, consider again \nthe single-process sys\u00adtem P with the data precondition x = O and the fol\u00adlowing transition diagram: \nZ=o? Both the lower and the upper bound on the termi\u00adnation of P, start + (=atJl) U (t z 2), and start \n-+ (t< 3) U atJl, respectively, can be derived by the unless rule from the invariant at Jo Ax= OAO<t<3 \nAt =60-+1. While the (hidden-clock verification style presented in the previous section refers to time \nonly through time-bounded temporal operators, explicit-clock rea\u00adsoning uses ordinary, timeless, temporal \noperators and refers to the time in state formulas. Both styles trade off the complexity of the temporal \nproof structure against the complexity of the state invariants: the hidden-clock approach relies on complex \nproof struc\u00adtures similar to the proof lattices used to establish ordinary (untimed) liveness properties \n([OL82]), and uses relatively simple local invariants; the explicit-clock method employs only the simple \nunless rule a (time\u00adless) safety rule , but requires a powerful giobai in\u00advariant. This trade-off is \nillustrated vividly by a more elab\u00adorate exampIe of real-time verification that is given at the end of \nthe following section,  6 Completeness The unless rule is known to be complete, relative to state reasoning, \nfor establishing unless properties ([MP89b]). From the results of the previous section it follows immediately \nthat explicit-clock reasoning is rel\u00adative complete for showing bounded-invariance as well as bounded-response \nproperties. As for bounded-operator reasoning, we show com\u00adpleteness in the case that all real-time constraints \nare either lower or upper bounds. Theorem. Let S = (V, Z, 6), 7 ,/, u) be a real-time transition system \nsuch that either [T = 0 for all T E ~ or uT = co for all i-GT. Let ~ beabounded\u00adinvariance or a bounded-response \nformula. If ~ is S-valid, then it can be derived by the monotonicity, transitivity, and conditional single-step \nrules relative to untimed reasoning. Proof. We consider here only the case in which all maximal delays \nof S are co; the argument for the other case proceeds similarly and is given in the full paper ([HMP91]). \nFirst we observe that, under the given restrictions, untimed reasoning is complete for timeless properties \nof S. This is because in the absence of finite maximal delays there is, modulo stuttering, a time sequence \nT for every (untimed) computation u of the weakly-fair transition system S; underlying S such that (c, \nT) is a computation of S (add sufficiently many clock ticks between any two states). It follows that \nany untimed temporal formula that is S-valid is also S~-valid and, thus, can be established by untimed \nreasoning. Any bounded-response property is either trivially not S-valid or can be established by untimed \nreasoning. Now suppose that the bounded-invariance property is S-valid; we show that it can be derived \nwithin our proof system. The main idea is to see that in order for (f) to be valid, for any p-state in \na computation of S there has to be a sequence of nonoverlapping single-step lower bounds that add up \nto at least 1 before a q-state can be reached. We show that there are only finitely many such ways in \nwhich a q-state can be delayed for 1 time units; hence they can be enumerated by a single un\u00adtimed formula. \nConsider an arbitrary computation p = (a, T) of S such that ai, i ~ O, is a p-state. Let Uj be the first \ng-state with j z i; if no such state exists, let j = co. We write rk for the transition that is completed \nat position k ~ O of p. An l-constraint pattern for Vij is a finite sequence of nonoverlapping single-step \nlower bounds between i and j that add up to at least 1, Formally, a constraint pattern C is a sequence \nof transitions T~,, . . . Tin. The pattern G is an ~-constraint pattern iff it is a constraint pattern \nfor u~,,~ iff i = io < il < . ..< in ~ j and, for all 1< k < n, ~;~ is not enabled on some i~_l ~~k < \ni~ (or k= 1and i= O). Two constraint patterns are equivalent iff one is a subpattern of the other (i.e., \ncan be obtained by omitting transitions). The proofs of the following two claims can be found in [HMP91]. \nClaim 1: There is an l-constraint pattern for ~i..j. Claim 2: There are only finitely many different \nequivalence classes of I-constraint patterns. We add, for every transition r E T, the boolean vari\u00adable \ncompteted(~) to our language; it is intended to be true in a state a~, i ~ O, of a computation p = (a, \nr) iff the transition T is completed at position i of p. For our purpose, it turns out to be sufficient \nthat completed(r) satisfies the axiom {true} T -~ {=completed(~)}. (*) By Claim 1, there is an untimed \nformula of the form (yq)u(~q A (first V lenab/ed(riO))) l.J+(~q)lJ+ (=g A completed(riO))U+ . . . U+(lq \nA completed(~in))  that is true over the i-th sutlix of p. Since there are, by Claim 2, only finitely \nmany formulas of this form, p + ~ for some finite disjunction @ of nested unless formulas is S-valid \nand, thus, given by untimed rea\u00adsoning. From ($) we infer by the conditional single-step lower-bound \nrule U-CSS with respect to any transi\u00ad tion TE T that for any state formula p and temporal formula ~. \nHence we can decorate the untimed nested unless formula with time bounds. By repeated collapsing and \nmono\u00adtonicity similar to the sample lower-bound derivation of Section 4.4, we arrive at the desired \nbounded\u00ad invariance property (t). In general, the situation is more complicated: both the lower\u00ad and \nupper-bound rules may be necessary to derive a bounded-invariance (or bounded-response) property. This \nis demonstrated by the increment-decrement example in Figure 2. In this two-process system, the first \nprocess, PI, consumes the maximal amount of time if its first loop, in which the value of y is in\u00adcremented, \nis executed as often (fast) as possible 11 times. In this worst (slowest) case, PI terminates by time \n130. Assuming that assignments cost at least 2 time units (instead of 1), tests still being free, the \nmaximal value of y would be only 6, implying termination by time 80. It follows that the modification \nof individual lower bounds may affect a composite upper bound! The proof of timely termination relies, \naccordingly, on an interplay of lower-and upper-bound rules. We PI: {&#38;c=l, y=o} x:=()P~ : [1, 10] \nFigure 2: Increment-decrement give only a brief sketch of the proof of the bounded-References response \nproperty [AH90] R. Alur, T.A. Henzinger, Real-time logics: com\u00adstart -+ O~130 atd~; plexity and expressiveness, \n5th IEEE LICS, 1990. [EMSS89] E.A. Emerson, A.K. Mok, A.P. Sistla, J. Srini\u00admore details, as well as \na proof of the corresponding vasan, Quantitative temporal reasoning, Automatic lower bound on termination, \ncan be found in the full Verification of Finite-state Systems (J. Sifakis, cd.), paper ([HMP91]). Springer \nLiVCS 407, 1989. The formal derivation follows the informal argument [Ha88] E. Harel, Temporal Analysis \nof Real-time Systems, given above. First we show that within 10 time units M.S. Thesis, Weizmann Institute, \n1988. PI can increase the value of y at most to 10: [HMP90] T.A. Henzinger, Z. Manna, A. Pnueli, An in\u00adterleaving \nmodel for real time, 5th Jerusalem Conf. on start ~ <ll (O~ y ~ 10); Information Technology, 1990. [HMP91] \nT.A. Henzinger, Z. Manna, A. Pnueli, Tempor\u00adal Proof Methodologies for Real-time Systems, Techni\u00adthis \nis done by inductive lower-bound reasoning. Then we apply the new rule cal Report, Stanford University, \n1991. MIX U<l [K089] R. Koymans, Speci~ing Message Passing and (o<.~ A D<(V) ~ O~V(~A@) Time-critical \nSystems with Temporal Logic, Ph.D. The\u00adsis, Eindhoven Univ. of Tech., 1989. to the single-step upper \nbound [KVdR83] R. Koymans, J. Vytopil, W.-P. de Roever, Real-time programming and asynchronous messagestart \n~ 0510 (atfl~ A x = ()), passing, 2nd ACM PODC, 1983. [MP89a] Z. Manna, A. Pnueli, The anchored version \nof the temporal framework, Linear Time, Branching start a 0<10(0 ~y~ 10 A at~~ A z= O). Time, and Partial \nOrder in Logics and Models for Con\u00adcurrency (J.W. deBakker, W.-P. de Roever, and G. From here we proceed \nby pure upper-bound reasoning, thus obtaining the bounded-response property Rozenberg, eds.), Springer \nLNCS 354, 1989. performing a case analysis on the locations of PI. [MP89b] Z. Mauna, A. Pnueli, Completing \nthe temporal Alternatively, we can establish the upper bound 130 picture, 16th EATCS ICALP, 1989. on \nthe termination of PI by explicit-clock reasoning [OL82] S. Owicki, L. Lamport, Proving Iiveness proper\u00adfrom \nthe following global invariant (add that all vari\u00ad ties of concurrent pro grams, ACM TOPLAS 4, 1982. \nables are nonnegative): [0s90] J.S. Ostroff, Temporal Logic for Real-time S~sterns, (atfl~ Aat~~ A(g=t=6~+1 \n=0V1< y< t= 6~+,))v eSearch tudies ress1989 [PdRQ2] A. Pnu&#38;, W.-P. de RQ.v.x, (R.ndez-v~us +th (aty~ \nA at_fZ~ Ay+ ~~+o ~ t = b~+l) V Ada a proof-theoretical view, Sigl?hn A&#38;TEc, (atfl~A at_E~Al <y<ll \nAt<20)V 1982. (at~~ A atfl~ Ay <10 At < 10+6~+o) V [PH88] A, Pnueli, E. Harel, Applications of temporal \nlogic (atJ?~Aat_/~Ay~ llAt+lOy< 130) V to the specification of real-time systems, Formal Tech\u00ad(atJ?j \nAatl~Al < YS llAt+lOy S 130+ 6~+,). niques in Real-time and Fault-tolerant Sgstems, Springer LNCS 331, \n1988. Acknowledgements. We thank Rajeev Alur for [R084] D. Ron, Temporal Verification of Communication \nmany helpful discussions. Protocols, M.S. Thesis, Weizmann Institute, 1984. \n\t\t\t", "proc_id": "99583", "abstract": "", "authors": [{"name": "Tom Henzinger", "author_profile_id": "81100034124", "affiliation": "Department of Computer Science, Stanford University, Stanford, CA", "person_id": "P283533", "email_address": "", "orcid_id": ""}, {"name": "Zohar Manna", "author_profile_id": "81100089034", "affiliation": "Department of Computer Science, Stanford University, Stanford, CA and Department of Applied Mathematics, The Weizmann Institute of Science, Rehovot, Israel 76100", "person_id": "PP15021756", "email_address": "", "orcid_id": ""}, {"name": "Amir Pnueli", "author_profile_id": "81100648459", "affiliation": "Department of Applied Mathematics, The Weizmann Institute of Science, Rehovot, Israel 76100", "person_id": "PP15038449", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/99583.99629", "year": "1991", "article_id": "99629", "conference": "POPL", "title": "Temporal proof methodologies for real-time systems", "url": "http://dl.acm.org/citation.cfm?id=99629"}