{"article_publication_date": "01-03-1991", "fulltext": "\n A Relational Approach to Strictness Analysis for Higher-Order Polymorphic Functions Samson Abramsky \nThomas P. Jensen* Imperial Colleget Abstract This paper defines the categorical notions of relators and \ntransformations and shows that these concepts enable us to give a semantics for polymorphic, higher order \nfunctional programs. We demonstrate the pertinence of this semantics to the analysis of polymorphic programs \nby proving that strictness analysis is a polymorphic invariant. 1 Introduction Recently, there has been \nsome effort to construe the seman\u00adtics of polymorphic functional programming languages using the categorical \nnotion of a natural transformation. The idea can be sketched as follows: we have a universe of compu\u00adt \national discourse given by some category C (in practice, a suitable category of domains). Types are objects \nof C. Type constructions (e.g. product, function space) are func\u00adtors (of appropriate arity) over C. \n.kfonornorphic functional programs are morphisms of C; polyrrsorphic programs are natural transformations. \nE.g. append : vt. t* x t* + t* append : (.)* x (.)* L (.)* where (.)* : C ~ C is the list construction \nfunctor. These ideas are used in [10] to develop a general frame\u00ad work for abstract interpretation of \nfirst-order, polymorphic functions. We extend the basic approach of [10] to cover higher-order functions \nand show that with this extension, the short-cut techniques for computing function abstractions given \nin [10] can no longer work; thus our main emphasis is on re-establishing the polymorphic invariance results \nof [1] in this framework. The obvious problem in extending this framework to higher-order functions \nis that function-space is contravariant in its first argument: [.+.] ,C p xc+ c This work was supported \nby ESPRIT grant BRA 3124 SEMANTIQUE *Authors address: Dept. of Computing, Imperial College, 180 Queen \ns Gate, London SW7 2BZ, U.K. Email: {sa,tpj}@doc.ic. ac.uk permission to copy witirout fee all or part \nof this material is granted provided that the copies are not made or distributed for direct commercial \nadvantage, the ACM copyright notice and the title of the publication and its date appear, and notice \nis given that copying is by permission of the Association for Computing Machinery. To copy other\u00adwise \n, or to republish, requires a fee and/or specific permission. @ 1990 ACM 089791-419-8/90/0012/0049 $1.50 \n49 (we assume throughout that ~ is cartesian closed). Several solutions to this problem have been suggested \ninvolving di\u00adnatural transformations [5], structors [9], section-retraction pairs on domains etc. In \nthis paper we pursue Reynolds idea of viewing a type as a relation [14]. We give this a categorical formulation \nintroducing the concepts of relators and trmsforrrsdions and arrive at characterizing polymor\u00adphic functions \nas transformations between relators instead of natural transformations between functors. In this setting, \nwe can define the notion of semantic polymorphic invariance: a property P(f) of polymorphic programs \nis a semantic polymorphic invariant if, for each f: F~G, either ~(~A) for all A Or ~(fA) for no A. In \n[1] it was shown that strictness analysis is a polymor\u00adphic invariant, i.e., the analysis would find \nthat an inst ante is strict if and only if it would find this for all instances. This result, which was \nthen obtained at some labour using an operational semantics, can now be proved easily from naturality. \nFurthermore, we conjecture that relators and transformations form a general basis for extending abstract \ninterpretations of monomorphic programs to cover polymor\u00adphic programs. The paper is organised as follows. \nIn section 2 we in\u00adtroduce the notion of relator and transformations between relators. Sections 3 and \n4 introduce a higher-order, polymor\u00adphic functional language and show how polymorphic types can be modelled \nas relators and polymorphic programs as transformations between relators. In section 5 we define polymorphic \ninvariance and demonstrate how our model of polymorphism enables us to prove a polymorphic invariance \nresult for strictness analysis. The practical use of this fact and its relation to the results in [1 \nO] is discussed in section 6. We assume some familiarity with basic notions of category theory, see [12] \nor [6]. 2 Relators and transformations This section defines the notion of a relator and transjorrna\u00ad \ntions between relators, Relators and transformations can be seen as a categorical framework for formulating \nReynolds types-as-relations paradigm. Let Rel be the category with sets as objects and relations as morphisms \nand let C be a category that can be embedded into Rel via a faithful func\u00adtor U. We have DEFINITION 1 \nA retator R : Cn+C maps objects in C to objects in C and morphisms in C to morphlsms in C, such that \nfA-+B is mapped to R(.f)B(A)+~(B). Fur\u00ad thermore R must preserve identity i.e., R(idA) = idR(A) O DEF1 \nNote, that relators differ from functors in that they are not required to preserve composition. Next, \nwe define what we mean by a transformation be\u00adtween relators. Assume that we have two categories, Cl \nand CZ, with the same collection of objects. Assume furthermore we have embedding /ll : CI +Rel and Z.4z: \nC2%Rel such that U1 and Z-/z agree on objects of Cl and Cz. DEFINITION 2 A C2-trar@ormation T between \ntwo Cl\u00adrelators R, S : C~+CI is a family of Cz-morphisms, 7A : R(A)+ S(A), indexed by the objects of \nCl such that for all morphisms r from A to B in C? the following property holds in Rel f4(TB) O i?il(R(r)) \n~ UI(S(r)) O U2(TA) O DEF2 We write T : F ++ G to say that T is a transformation from relator F to relator \nG. When working in concrete categories, the embedding usually just mean that the same entity is seen \nfrom two different categorical viewpoints. We omit them when they can be derived from context. This convention \nwill allow us to express the above requirement by the following diagram: A R(A) A > S(A) i (4c>}(r) B \nR(B) B S(B) We shall study the case where (TA) is a family of functions. In this case the above condition \nreduces to: Loosely speaking this says that a family of functions, (TA), is a transformation from R to \nS if it maps Fi( r-)-related ele\u00adments to S( r)-related elements. We can define the composition of two \ntransformations componentwise, i.e., if T : F --+ G and u : G ---+ H are transformations then a o T : \nF -+ H is defined by (a o T)A = CA o TA. With this definition it is easy to verify PROPOSITION 3 Relators \nand transformations form a cat\u00adegory with relators as objects and transformations as mor\u00adphisms. o PROP3 \n3 Types as relators It is our intention to give semantics to a polymorphic, func\u00adtional language using \nrelators and transformations. As we intend to include a fixpoint operator in our language, we shall take \nas our base category the cartesian closed category of complete partial orders and continuous functions, \ndenoted by CPOC. From this category we can construct a new cat\u00adegory, CPO~,, with cpo s as objects and \nstrict, inductive relations as morphisms. We will now show how polymorphic type expressions can be interpreted \nas relators over CPO~,. DEFINITION 4 Let R and S CPO.; + CPO.i be two relators. I he relator R x S : \nCl? 0$, n+ CPO~~ is defined by: 1. (R x S)(A) is the product of the objects R(A) and S(A). 2. Given \na relation r : A+ I.? the relation (R x $(r) is defined by  ~ A)xS)(A) (Rx $( ) li@xSYBJ (a, a ) (RxS)(r) \n(b, b ) ifla R(r) b and a S(r) b o DEF4 We have to verify that this defines a relator on CPOsi. Firstly, \nit is straightforward to check that (1? x $(idA) = Secondly, we have to ensure that the relation +?x \nS)(A) so defined is strict and inductive. Strictness is by defi\u00adnition and inductiveness follows from \nstructural induction on the types and the fact that if the n th elements of two chains (an, a;) and (b~, \nb~) are related then u(a~, a;) = (U(an), U(a~)) (R x $)(r) (U(bm),U(b~)) = LJ(bn, b:). We can model the \nfunction type constructor by using the concept of logical relation [13] DEFINITION 5 Given two relators \nR and S we can define a new relator 1. [~;p~(A) is the function space object R(A)+-S(A) c. 2. For r : \nA-++B a strict, inductive relation, R + S(r) is the relation from (R +-S)(A) to (R + S)(B) defined by \n~ (R + S)(r) g ifl Vx, z : x R(r) z implies ~(z) S(r) g(z )  o DEF5 Again, we can easily check that \n(R + ~(idA) ==id(R~S)(A) Strictness is checked as follows: For proving inductiveness let r : A-B be an \narbitrary strict, inductive relation, let (f,m), (g~) be chains in (R + S)(A) and (R+ S)(B) resp., and \nassume that Vn :f. (R+ S)(r) g. 1A relation r 1s termed strzct if J. r 1. It 1s termed znductzve if \nfor all chains (an) and (bn) we have Vn : a. r bn implies Ua. r U a. i.e., Vn : z R(T-) d + jn(x)s(?-)gn(z \n) But since, for fixed x and x , (~~(z)) and (g~(x )) are chains in S(A) and S(B) resp., we have that \nz l?(r) z =+ Vn : jn(z) S(r) gn(z ) * (w-~))(~) s( ) (wn))(~ ) 4 Terms as transformations We now give \na semantics for the expressions in our polymor\u00adphic higher order language. We shall interpret a polymor\u00adphic \nexpression of (polymorphic) type A-LB as a CPO.\u00ad transformation bet ween the CPO.i-relators corresponding \ntoA and B. Polymorphic functional programs are built up from the constants id, Ap, fst, snd, fix and \nvariables by the construc\u00adtors ; , ( , ) and A(.). The type assignments for these expressions can safely \nbe left to the reader. Semantically, we define for domains A, B, C: fstA,B(x, ~) = $ sndA,B(z, y) = g \n(f, 9) A, B,c(~) = (.f(~),9(~)) f;9($) = 9(.f(~)) ~pA,B(-f, ) = f(z) A(f)(z)(y) = f(r, y) fix(t) = unEw \n~n(~) etc. LEMMA 6 Let F, G, H be relators. Then (~) fstF (.).G(.) is a transformation from F x G to \nF. (ii) Similarly, snd : FxG -Gand Ap : (F ~ G)x F w G are transformations. (iii) fix : (F+ F) --+ F \nis a transformation. (i.) Let ~ : F -+ G, g : F --H be transformations; then (f, g): F --+ G x H is a \ntransformation. (v) Let ~ : F x G -H be a transformation; then A(f) : F * (G +. H) is a transformation, \n (vi) Let f: F-+ Gandg:G+H. Then f;g:F *His a transformation.  PROOF We prove (i), (iii) and (v). (i) \nTo show that fst is a transformation we must show that for any strict, inductive relation ~ : A-B we \nhave: fstF(A)xG(A) (F X G)(A) > F(A) (F x G)(r) ~ F(r) 1 $ fstF(E) x G(E?) (F X G)(B) > F(B) But if (z, \ny) fst o (F x G)(r) z then there exists g E F(A) such that (z, Y) (F x G)(r) (z, y ) i.e., x F(r) z and \nso (x, y) F(r) o fst z. (iii) Showing that fix is a transformation from F + F to F amounts to showing \nthat for r : A+ B strict, inductive the following diagram semi-commutes : A (F+-F)(A) ixA > F(A) (F+-F)(r) \ng F(r)r1$ 1 B (F+ F)(B) xB > F(B) which asserts that if two continuous functions ~, g are related by \n(F + F)(r) then their fixpoints are related by F(r). But since F(r) is inductive, fixA(~) is related \nto fix~(g) if ~n(l) F(r) gn(l) for all n which follows from 1 F(r) -L and ~ (F + F)(r) g. (v) We have \nto show that A(f) : F + (G+ H) is a trans\u00adformation provided ~ : F x G --+ H is. In diagrams A( f )A \nA F(A) > (G +-H)(A) rIIF(r) ~ (G+-H)(r) I A(f)B B F(B) > (G* H)(B) This states that under the assumption \nthat zF(T)x we can prove A(f)A(Z) (G * H)(r) AU)B(Z ) which is equivalent to Vy, / : ~G(r)/ implies fA(~, \ny) H(r) fzr(z#, y ) The last property follows from zF(T)z and the fact that f is a transformation from \nF x G to H. o LEMMA6 We can summarise the results obtained so far as: THEOREM 7 Let e be a polymorphic \nexpression that maps arguments of (polymorphic) type 1 to a result of (poly\u00admorphic) type G. Then e can \nbe interpreted as a CPO.\u00adtransformation between the CPO~;-relators corresponding to types F and G. o \nTHEOREM7 The general import of the results so far is that we can de\u00adrive from a cart esian closed category \n(i. e., a model of our monomorphic ally typed, higher order language) a new carte\u00adsian closed category \nof relators and transformations in which we can interpret ML-style parametric polymorphism. For further \ndetails, see [4]. 5 Semantic Polymorphic Invariance and Strictness The aim of this section is to provide \nsome initial evidence that the relator-semantics for polymorphism can be a use\u00adful tool when trying to \nextend methods for analysing mo\u00adnomorphic programs to cover polymorphic programs. The framework for analysis \nwhich we have in mind is abstract interpretation [3]. In the following, we demonstrate how a particular \nanalysis, strictness analysis of higher-order, mo\u00adnomorphic functions, can give information about polymor\u00adphic \nfunctions. 5.1 Strictness analysis A function is strict if its result is undefined whenever its argument \nis undefined. The use of strictness information to implement functional languages efficiently is widely \nstud\u00adied [7] ,[1 I]. In [8] it was shown how to perform strict\u00adness analysis of higher-order, monomorphically \ntyped pro\u00adgrams by abstract interpretation. The method works by interpreting the program text over non-standard \ndomains built up from the two-point domain 2 using the usual do\u00admain constructors x and ~. The abstract \ninterpretation of a function ~ : Irzt+ Int,say, would then be the function ~# : 2 -+ 2 obtained from \n~ by replacing the operations associated with type lnt, like +, by their abstract interpre\u00adtation on \nthe domain 2. The main result in [8] is that ~# gives safe information about the strictness properties \nof f, i.e., .f#(l) = 1 ~ ~(l) = 1. As domains built over 2 are all finite lattices, @ can be computed \nby a fixpoint iteration that is guaranteed to terminate. This gives a comput able method for doing strictness \nanal\u00adysis of monomorphic, higher-order functions. Strictness prop\u00aderties of a polymorphic function can \nbe obtained by applying the method to the monomorphic instances of the function. There are, however, \ntwo problems connected with this ap\u00ad proach: The number of monomorphic instances of a polymor\u00adphic function \nbecomes infinite as soon as we allow structured or higher-order types. c The size of the abstract domain \nfor structured and higher-order types grows so fast that fixpoint compu\u00adt ations become infeasible The \nsolution to these problems is to prove that the strict\u00adness analysis described here is polymorphically \ninvariant. We prove that all abstract functions corresponding to mono\u00admorphic instances have the same \nstrictness properties. This implies that we only have to compute the abstraction of the simplest instance \nof the function to obtain all information about strictness that the analysis can provide.  5.2 Polymorphic \ninvariance Polymorphic invariance of a property P of a polymorphic program means that P holds for all \nmonomorphic instances or none. The notion of polymorphic invariance can be trans\u00ad ferred to the semantic \nlevel as follows: DEFINITION 8 Let P be a property of morphisms. P is a semantic polymorphic invariant \n(with respect to a class of objects T and a class of transformations F) if, for every A,B~ Tand ~EY: \nP(fA) ++ P(fB). o DEF8 The particular property we shall be interested in is that of strictness of a \nfunction: strict(~) ~f ~1 = J_. The proof of polymorphic invariance of strictness is based on two rela\u00adtions, \nr,efl and rpre, defined as follows: DEFINITION 9 Let 2 denote the two-point lattice and let A be a domain \nwith a greatest element T different from 1. Define the relatlons rpre S, r~ef~ : z++A by o DEF9 In the \nfollowing, let F denote an arbitrary relator built using x and q. LEMMA 10 F(rP,e,) and F(r,~~[) is strict, \ninductive and relates T to T. PROOF Straightforward l LEMMA lO LEMMA 11 F( r,efl) is l-reflecting and \nF(rp~,,) is 1\u00adpreserving, i.e., 1F(2) ~p.es d + d = -b(d) PROOF That rre~t is J--reflecting is essentially \nProposition 4.2 in [2], The proof that rPre, is J--preserving proceeds by induction on the structure \nof F. We shall only give the case when F is a function type. So suppose F has the form G a H and that \n/1z.1 (G * H)(rP~~.) f for some t ~ (G ~ H)(A). From lemma 10 we have that T G(rp,es) T, hence, as (G \n=+-H)(rPreA) is a logicid relation we get that J_ H(rP,es)~(T) and by induction hypothesis that ~(T) \n= 1. The monotonicity of ~ now implies that f = Jz.1 as required. o LEMMA 11 With these lemmas at hand \nwe can now prove PROPOSITION 12 Strictness is a semantic polymorphic invariant with respect to the class \nof all non-trivial domains with top-elements in CPOC (i.e. those with more than one element), and all \ntransformations. PROOF Let ~ be a transformation from relator F to relator G i.e., fA is a continuous \nfunction from F(A) to G(A) for any domain A. We now prove -fA is strict iff f2 is strict. The relations \nrref~ and rp,e, are strict and inductive, so from the fact that ~ is a transformation we get the following \ndiagram, where r stands for either rrefl or rPT~S: f2 2 F(2) > G(2) i (r)$  : k(r) A F(A) > G(A) So \nsuppose fz is strict and that fA(~) = d. we show that d = 1. Take r to be rP,eS. As F( rP,.,) is strict \nwe have that -L ~, r o F(rp,,s) d and hence 1 G(rP~e~) o fz d i.% fz(J-) G(rp~.s) d. AS fz is strict \nwe@ 1 G(rp,,.) d al~d lemma 11 gives that d = ~ i.e., fA is strict. For the converse, assume fA is strict \nand let r be r,ef~ in the diagram. The lower part of the diagram is thus a strict relation hence the \nupper part of the diagram is a strict relation, so J-G(r,efl) o ~2 1. Lemma 11 tells us that G(r,e$~) \nis -1-reflecting, so f2(l) = 1 hence f2 is strict. Q pROP12 6 Related Approaches In [10], an ingenious \nmethod is given to compute any in-St.311C6!, ~A, Of an abstract function frOm its SimpleSt inStanCe f2. \nThe method works for any abstract interpretation, but is limited to first-order functions, The basic \nresult from [10] which underlies the method given there is: PROPOSITION 13 If A is a type built from \nproduct, lifting and 1, and ~ : F J G is a polymorphic program, where F, G are first-order types (i.e. \nnot using function space), then for some function @A, depending on A but not on f, fA = @A(f2). o pROP13 \nEven if a property can be shown to polymorphic invariant, information about the abstract functions at \nnon-basic types might be needed. This occurs when a function g calls an\u00adother function f with an argument \nof non-basic type. In this case the abstract function of g will be defined in terms of a non-basic instance \nof the abstract function off. An ob\u00advious question is thus whether the result in proposition 13 carries \nover in the presence of function spaces. The next result shows that it does not. PROPOSITION 14 The \nprevious proposition fails when F and G are allowed to be higher-order. PROOF Consider the polymorphic \nintegers: ii =f Af.h. f( qz) :W.(t + t) + (t + t) (n e N). For n # m we can find a finite lattice type \nA such that fiA # rnA (let k = max(m, n), and take A = 2k). But there are only finitely many functions \nin [[2 * 2] * [2 * 2]]. o pROP14 Note that this result holds for any finite domain in place of 2, and \neven when A is built from product and lifting (so it is independent of what our abstract interpretation \nof function space happens to be). The conclusion of all this is that analysis of higher-order, polymorphic \nfunctions is best done by proving a polymorphic invariance result for the analysis at hand and then computing \nthose non-basic instances of the abstract functions necessary to compute all basic instances of the abstract \nfunctions. 7 Conclusion The major achievements of this paper can be summarised as: We have given a semantics \nfor a first order polymor\u00adphic, higher order functional language. The semantics is a combination of Reynolds \ntypes-as-relations idea and the idea of naturality from category theory. This approach to polymorphism \nis treated in depth in [4]. using the natura~lty property we can give a simple proof of the polymorphic \ninvariance of strictness anal\u00adysis. We take this as initial evidence of the fact that relators and transformations \ncan be of use in analysis of polymorphic programs. They seem especially useful for establishing poly\u00admorphic \ninvariance results, which is the best one can hope for when dealing with higher-order functions. Future \nwork should investigate if polymorphic invariance can be proved for abstract interpretation in general \nusing the relator se\u00admantics of polymorphism. 8 Acknowledgements The authors would like to thank the \nmembers of the Ab\u00adstract Interpretation Group at Imperial College (Geoff Burn, Chris Hankin, Sebastian \nHunt and David Sands) for numer\u00adous discussions related to this topic. Thanks are also due to Paul Taylor \nfor letting us use his TEX-macros for drawing diagrams. References [1] S. Abramsky. Strictness analysis \nand polymorphic in\u00advariance. In H. Ganzinger and N. D. Jones, editors, Programs as Data Objects, pages \n1 23, Berlin, 1986. Springer Verlag. Lecture Notes in Computer Science vol. 21 7. [2] S. Abramsky. Abstract \ninterpretation, logical relations and Kan extensions. Journal of Logic and Computation, 1, 1990. [3] \nS. Abramsky and C. Hankin. .4 bstract Interpretation of Declarative Languages. Ellis Horwood, 1987. [4] \nS. Abramsky, J. Mitchell, A. Scedrov, and P. Wadler. Relators. Draft paper, 1990. [5] E. S. Bainbridge, \nP. J. Freyd, A. Scedrov, and P. J. Scott. Functorial polymorphism. In G. Huet, editor, Logical Foundations \nof Functional Programming. Addi\u00adson Wesley, 1990. [6] M. Barr and C. Wells, Category Theory for Computing \nScience, Prentice Hall, 1990. [7] G.L. Burn. Abstract Interpretatiora and the Parallel Evaluation of \nFunctional Languages. PhD thesis, Im\u00adperial College, University of London, 1987. [8] G.L. Burn, C.L. \nHankin, and S. Abramsky. The the\u00adory and practice of strictness analysis for higher order functions. \nScience of Computer Programming, 7:249\u00ad278, 1986. [9] P, Freyd. Structural polymorphism. Unpublished, \n1989. [10] R.J.M. Hughes. Abstract interpretation of first-order polymorphic functions. In Glasgow Workshop \non Func\u00adtional Programming, University of Glasgow, Depart\u00ad ment of Computing Science, August 1988. Research \nReport 89/R4. [11] S. L. Peyton Jones. The Implementation of Functions/ Programming Languages. Prentice-Hall, \n1987. [12] S. MacLane. Categories for the Working Mathemati\u00adcian. Springer Verlag, 1971. [13] G. D. \nPlotkin. A-definability and logical relations. Tech\u00adnical Report SAI-RM-4, School of A. I., University \nof Edinburgh, 1973. [14] J. C. Reynolds. Types, abstraction and parametric polymorphism, In Information \nProcessing 85 . North Holland, 1983. \n\t\t\t", "proc_id": "99583", "abstract": "", "authors": [{"name": "Samson Abramsky", "author_profile_id": "81100261879", "affiliation": "Dept. of Computing, Imperial College, 180, Queen's Gate, London SW7 2BZ, U.K.", "person_id": "PP14099388", "email_address": "", "orcid_id": ""}, {"name": "Thomas P. Jensen", "author_profile_id": "81100640174", "affiliation": "Dept. of Computing, Imperial College, 180, Queen's Gate, London SW7 2BZ, U.K.", "person_id": "PP39073810", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/99583.99593", "year": "1991", "article_id": "99593", "conference": "POPL", "title": "A relational approach to strictness analysis for higher-order polymorphic functions", "url": "http://dl.acm.org/citation.cfm?id=99593"}