{"article_publication_date": "01-03-1991", "fulltext": "\n Algebraic Reconstruction of Types and Effects Pierre Jouvelot 1~2 David K. Gifford2 Ecoledes Mines \nde Parisl MIT Laboratory for Computer Science2 Abstract We present the first algorithm for reconstructing \nthe types and effects of expressions in the presence of first class pro\u00adcedures in a polymorphic typed \nlanguage, Effects are static descriptions of the dynamic behavior of expressions. Just as a type describes \nwhat an expression computes, an ef\u00adfect describes howan expression computes. Types are more complicated \nto reconstruct in the presence of effects because the algebra of effects induces complex constraints \non both effects and types. In this paper we show how to perform reconstruction in the presence of such \nconstraints with a new algorithm called algebraic reconstruction, prove that it is sound and complete, \nand discuss its practical import. This research was supported by DARPA under ONR Contract NOO014-89-J-1988. \n 1 Introduction Type reconstruction systems compute the type declarations that a programmer has omitted \nfrom a program, and thus provide a programmer with the performance and safety ben\u00adefits of static typing \nwithout the burden of writing declara\u00adtions. Type reconstruction may also aid software reuse be\u00adcause \nit always guarantees to find the most general type of a program, while most programmers simply use declarations \nthat suffice for the immediate application at hand. Because of their utility, type reconstruction systems \nare now finding their way into modern programming languages [M78] and are the subject of much theoretical \nand practical interest. We examine in this paper how declaration reconstruc\u00adtion can be extended to effect \nsystems. An effect system [LG88] is a dual to a type system. Just as types describe what expressions \ncompute, effects describe how expressions compute. In a language with an effect system, every proce\u00addure \ntype includes a latent eflect. A latent effect is used to communicate the side-effects of a procedure \nbody horn the point of its definition (via lambda abstraction) to the points of its use (via application). \nBecause types include effects, type reconstruction and effect reconstruction are necessarily dependent \non one another. We are interested in effect systems because they can be used to compute a wide variety \nof useful properties about a Permission to copy without fee sfl or part of this material is granted \nprovided that the copies are not made or distributed for direct commercial advantage, the ACM copyright \nnotice and the title of the publication and its date appear, and notice is given that copying is by permission \nof the Association for Computing Machinery. To copy other\u00adwise, or to republish, requires a fee and/or \nspecific permission. Cl 1990 ACM 089791419-8/90/0012/0303 $1.50 program. To date we have used them to \ncompute store ef\u00adfects [GJLS87] (read, write, and initialize regions of the store), communication effects \n[J G89a] (in and out effects on channels), and control effects [JG89b] (goto and comefrom). Store effects \ncan be used in direct support of parallel com\u00adputing because they determine an expression dependency \ngraph that can be used to automatically schedule expres\u00adsions for parallel execution [HG88]. Morris [M68] \nrecognized that type reconstruction is a constraint satisfaction problem. All that is necessary to re\u00adconstruct \nthe types of expressions in a program is to gather together all of the constraints placed on the variables \nby expressions, and then compute the most general type that could be safely assigned to the variables \nsubject to the con\u00adst raints. Contemporary type reconstruction systems use struc\u00adtural constraints, and \nthus we will refer to them as structural reconstruction systems. Structural reconstruction systems use \nRobinson s algorithm [R65] to solve constraints based upon structure matching in a set of simultaneous \nequations. For example, ML [M78] uses a structural reconstruction sys\u00adtem that is based upon Robinson \ns algorithm. Effect reconstruction is also a constraint satisfaction problem, but the algebra of effects \nis richer than most type algebras. In specific, effects form a commutative monoid with idempotence under \nthe effect union operator, au+xeff. Thus when a program undergoes type and effect reconstruc\u00ad tion a \nsystem of simultaneous algebraic equations is gener\u00ad ated. A program is well-typed if and only if the \nsystem of algebraic equations induced by a program has a solution. Structural reconstruction can only \nhandle free algebras, and thus it can not be used to reconstruct types in the pres\u00ad ence of effects. \nThere are two underlying causes to this limit ation. First, Robinson s algorithm is limited to the syntactic \nequivalence of expressions, and thus can not deal with complex algebraic axioms. Second, structural recon\u00ad \nstruction is based upon the idea that every expression has a single most general type that can be specialized \nby simple syntactic substitutions. We have developed a new algebraic reconstruction sys\u00ad tem for types \nand effects that uses algebraic constraints to overcome the problems of structural reconstruction. In \nour algebraic reconstruction system, an expression is well-typed iff a given constraint system of algebraic \nequations is satis\u00ad fiable. Algebraic reconstruction is based upon: (1) a unifi\u00ad cation algorithm that \nsolves sets of algebraic equations, and (2) a generalization of principaJ type schemes beyond syn\u00adtactic \nsubstitution to include constraints. As we discuss at the end of this paper, algebraic recon\u00adstruction \ncan also be applied to complex type algebras. For example, computing the field names of a record is a \nsimple instance of a constraint-based problem that is not handled in a natural way by Robinson s unification \nalgorithm. In the remainder of this paper we discuss previous work (Section 2), a static semantics for \na simple language with types and effects (Section 3), our reconstruction algorithm (Section 4), proofs \nof soundness and completeness (Section 5), extension to ML-style generic polymorphism (section 6) and \na view towards the import and application of our result (Sectiou 7). Related Work The closest related \nwork to algebraic reconstruction is recent research that extends structural reconstruction to cope with \nthe algebraic properties of record types. Record types are a bit more complex than other types because: \n(1) the field names that must appear in a record type are discovered incrementally, and (2) the order \nof field names in a record type often does not matter. For example, .Jategaonkar [J89] shows how to add \nthe algebraic properties of record types to a structural reconstruction system and proves her resulting \nsystem sound and complete. Wand [W89] extends [W87] by considering concatenation of records as a way \nof formalizing multiple inheritance. Wand uses disjunctions of constraints on record types to generate \nmultiple possible types for an expression. Any kind of structural reconstruction depends upon the existence \nof syntactic principal types. A syntactic princi\u00adpal type describes all of the possible types of an expression \nvia permissible syntactic substitutions for certain type vari\u00adables. Syntactic principaJ types can often \nbe preserved when one wants to extend the language with constructs such as records [C84, W87], although \none has to be careful not to introduce too much flexibility [W88]. In the latter case, syntactic principal \ntyping is lost because a simple syntactic substitution is not powerful enough to describe the set of \ntypes an expression might have. The advantage of algebraic reconstruction is that it can cope with complex \nalgebraic constraints on types that can not be handled by extended structural reconstruction. For example, \nstructural reconstruction can not be extended to deal with the algebra of effects because expressions \nno longer have a syntactic principal type. The algebra of effects, in. troduced in [LG88], has a wealth \nof properties (e.g., com\u00admutativity and idempotence) that makes principal typing modulo substitution \nimpossible. The ACUI-unification (Associative, Commutative, Uni\u00adtary, Idempotent) procedure [LC89] is \nalso related to our work because we will use it to show the decidability of type and effect reconstruction, \nAlthough ACUI-unification is NP-complete [KN86], we expect most cases to be tractable, in the same manner \nML s inference system has proved to be useful while being DEXPTIME-complete [M90]. In fact, since we \ndon t have to deal with free function symbols, the full power of ACUI-unification is not needed and we \nshow how a simpler polynomial algorithm [MB90] can be used in\u00adstead to solve constraints. We will discuss \nthis issue in more detail later in the paper. Other related work seeks to understand the ultimate se\u00admantic \nlimits of structural reconstruction, Although ML doesn t provide the full power of the second-order poly\u00ad \nmorphic lambda-calculus [FL083], [GR88] shows how this constraint-based approach can be extended to the \nfull\u00adfledged calculus. Partial type reconstruction for the full lan\u00adguage is known to be undecidable \n[B85, P88], even though the complete problem is still open. [OG89] proposes an in\u00adteresting way to mix \ntogether M L s generic type schemes with explicit polymorphic types while preserving type re\u00adconstruction \ndecidability on non-polymorphic types. 3 The Type and Effect System In this section we present the type \nand effect system that we will use throughout the paper. For pedagogical purposes, we will study effect \nreconstruction in the context of KFX, a simplified version of the FX-87 language. FX-87 [GJLS87] is a \nkinded polymorphic typed language that allows side-effects and first-class procedures and uses an effect \nsystem. The language KFX has the following Kind, Description (Effect and Type) and Expression domains: \nK ::= effect I type D ::= FIT ,. F ., 1 (maxef f F. F1 ) combination of effects .. (proc F (To) Tl) \nprocedure (poly (I K) T) polymorphic T .. M .. M .. 1 (proc F (Mo) MI) procedure E ::= I (lambda (I \nT) E) typed lambda (lambda (I) E) implicitly typed lambda (plambda (I K) E) polymorphic abstraction (proj \nE D) projection (E, El) application .. I ..-li constant v user variable v unification variable  H is \nthe class of types that will be inferred bv our a.LQo\u00adrithm. It consists of-~ariables and procedures \nthat do not include polymorphic types in them. Note that procedure types include a latent effect, and \nthat inferred procedure types are not required to have pure latent effects. Unifica\u00adtion variables cannot \nappear in user programs. KFX descriptions have a much richer algebra than nor\u00admal type expressions. The \nconversion equivalence relation w bet ween descriptions, beside the USUSJ a-renaming of bound variables \nin polymorphic types, supports structural equiva\u00ad lence ([Y/x] is the substitution that maps x to y and \nis the identity elsewhere and FV(T) denotes the free variables of T) : TO -J T o T1-T l FzF (proc F (To) \nTI ) w (proc F (T o) T l ) 4 Type and Effect Reconstruction I @ W(T) (poly (I K) T) -(poly (I K) [1 \n/I]T) but rdso includes the whole algebra of effects induced by the maxef f construct, namely Associativit \ny, Commutativity, Unitary and Idempotence: (maxeff F, (maxeff FI Fz))*(maxeff (maxeff FO Fl) F,) (maxef \nf F. Fl)~(maxef f Fi F,) (maxeff F pure)~F (maxeff F F)*F Because of the algebraic properties of effects, \nthe equivalence on procedure types requires reasoning over the effect rdgebra rules. The kind rules for \neffects and types follow. The relation has kind , noted :: , is used to denote the kind of any description \nin a given assignment. A is the kind assignment function that maps variables to their kind: I::K EA AI-I::K \nAl-F :: effect A 1-TO :: type A 1-T, :: tvpe .. A F (proc F (To) Tl) :: type AII :: K] 1-T :: type A \n1-(poly (I K) T) :: type The type and effect rules for variable, lambda abstraction (with and without \nexplicit type), application, polymorphic abstraction, projection and description equivalence follow. \nJust aa : is used to denote the has type relation, ! is used to denote the baa effect relation. Effect \nand type information flow back and forth between the has type and has effect relations as can be seen \nby looking at the (+ IT) and (+E) rules where the latent effect of procedures is re\u00adspectively computed \nand used, A is extended to map vari\u00adables to types: I:T cA (Var) A ~ l:T!puI-e AII:T] 1-E: T !F +IT) \nA E (lambda (I T) E) : (proc F (T) T ) ! pure AII:M] 1-E:T!F (-+IM) A l--(lambda (I) E) : ( proc F (M) \nT) ! pure (+E) A 1- A 1-At\u00ad(E. El) EO : El: : T (proc fo!Fl ! (maxe ff F (To] F. T) ! FiJ (maxeff F1 \nF)) (pOlyl) A F AII::K] (plambda (I t-K) E) E : :T! (poly pure (I K) T) ! Pure A ~ E:(poly(IK)T)!F (PoIYE) \nA 1-D::K A 1-(proj E D) : [D/I]T ! F AK E:T!F (-) T-T F-F AFE:T !F In this section we will describe \nhow to reconstruct the types and effects of expressions in the language we have just pre\u00adsented. Before \nwe launch into the technical details of re\u00adconstruction, we will first consider an example that will \nmo\u00adtivate a major design decision. Assume for a moment that the following effect equation describes the \nlatent effect e of a procedure: iirite w (maxeff e write). Now e can be either be pure or write. We can \nnow see that a type that contains an effect can have multiple possible forms, and there is no simple \nsyntactic way to describe this diversity. Here is a procedure whose argument in fact has latent effect \ne and thus haa two different typesl: (lambda (f) (lambda (g (proc write (bool) bool) ) (if #t 13 (lambda \n(x) (begin (f x) (g x)))))) Thus in order to handle the algebraic properties of KFX we must generalize \nthe idea of principal typing [DM82] be\u00adyond syntactic substitution on type schemes to include sub\u00adstitution \nthat observes algebraic constraints. This is be\u00adcause syntactic type schemes cannot describe the most \ngen\u00aderal type of an expression in our system. 4.1 Algebraic Unification We will now describe a unification \nalgorithm that can handle algebraic constraints. Robinson s unification algorithm is used in syntactic \nreconstruction to enforce type constraints between type expressions by computing a substitution that \nmaps one type to the other. It also ensures that the most general type (modulo substit ution) is obtained \nafter type re\u00adconstruction. However, the effect constraints that arise in an effect system cannot be \nenforced by this simple unification technique. The unification rdgorithm U that follows computes both \na substitution and a constraint set. We use a substitution to describe constraints on types, while we \nuse a constraint set to describe constraints on effects. A substitution maps uni\u00adfication variables to \ntypes in H, and a constraint set cent ains pairs of effects, where the left and right element of each \npair must be the same effect. When U is applied to two types T1 and Tz, it returns a pair (S, C) where \nS is a substitution and C a constraint set. In our description 1$ is the empty set, v is a unification \nvariable, N is a constant, and D is the identity substitution. U(T1, T2)= Tl= v=> if T2 c M then ([T2/Tl], \n+) else fail T2= v=> if T1 C M then ([T1/Tz], ~) else fail T1= I=> if T2= I then ([] , +) else fail T] \n= (proc FI (Tll ) TIZ) => if Tz = (proc FZ (T21 ) T22) then let (S1, Cl) =U( Tll , T21 ) let (S2 , C2) \n= U( SITIZ , S1T2Z ) (s2s1 , c1 u C2 u {( F,, F2)}) else fail begin and if are the usual sequence and \nalternative special forms. TI = (poly (II K) T ]) > if TZ = (poly (Iz K) T z) then U( [N/Il]T l, [N/IZ]T \nZ ) where N i.s fresh else fail else fail In U two polymorphic types unify iff they are abstracted over \nthe same kind and their bodies unify when the ab\u00adstraction variable has been substituted by the same \nnewly created constarat description. This definition corresponds to an extensional view of equality of \npolymorphic types: (pOI.y (I, K) T,) -(poIY (IZ K) T2) iff VD. [D/Il]Tl w [D/12]T2 Using anew constant \nisawayto ensure that thetwopoly\u00admorphic types are the same, whatever they might be pro\u00adjected upon later. \nTwo type expressions unify if and only if the constraint set returned by Uis satisfiable. Satisfiabilityof \na constraint set can be checked, e.g. by using an ACUI-unification proce\u00addure. When effect constraints \nare checked is a trade-off be\u00adtween providing users with early notification of errors (eager checking) \nvs. optimum performance of the reconstruction system (lazy checking). Definition 1 (Satisflability) A \nconstraint set C = {(F~, F ~)} is satisfied under the rnode2 m (that maps uni\u00adfication variables of C \nonto F), written m ~ C, iff for all i, mFl ~mF ; . Models, being ground substitutions on effects, are \nstraightforwardly extended to types by induction. Theorem 1 (Correctness) Let (S, C) be U( T1, Tz ) and \nm be a model: (m + C) * rn(ST~) N m(STz) Proof. By induction on type expressions, using the fact that \nmT ~ mT ==+ m(ST) w m(ST ). 0  4.2 The Algebraic Reconstruction Algorithm Our algebraic reconstruction \nalgorithm R uses the unifica\u00adtion procedure U to compute the type and effect of an ex\u00adpression E. The \ntwo input parameters to the reconstruction algorithm R are a type environment A that binds identifiers \nto types or kinds, and an expression E. We assume that the expression E haa been alpha-renamed so there \nare no identi\u00adfier name conflicts. The reconstruction algorithm R returns a quadruple (T, F, C, S) where \nT is the type of E in the en\u00advironment A and F its effect. Both T and F are subject to the constraint \nset C. R(A, E)=case Ein I => if [1 : T] c A then (T, pure, ~, n) else fail (lambda (I T) E) => let (T \n, F ,C, S) = R( AII :T], E ) ((prmc F (T) T ), pure, C, S) (lambda (I) E) let (T, F,C,S) = R( AII: P], \nE ) where v is fresh (EO ~1 ~ ~~proc F (S~) T), pure, C, S) let (TO, FO,CO, SO) = R( A, EO ) let (T1, \nF1, C1, S1) = R( SOA, El ) let (S, C) = U( SITO, (proc VI (Tl) v2) ) where u: are fresh let ~ = (maxef \nf FO (maxef f FI VI)) (Svz, F , CO U C, U C, SSISO) (rhmbda (1 K) E) => .. &#38; (T, F ,C,S) = R( AII \n:: K], E ) let C = (C U {( F,pure)}) let {I,} = FV(C ) FV(S(AII :: K])) ((POIY (lW:~rj)~pure, [N/I] \n[vi/Ii]C u c ,s) , w are fresh (proj E D) => let (T , F,C,S) = R( A, E ) if T = (poly (I K) T) then ([D/I]T, \nF,[D/I]C, S) else fail else fail where FV is extended to constraint sets and environments, with FVII \n: T] = FV(T) and FVII :: K] = {I}. In the case of the polymorphic abstraction operator plambda, a compound \nconstraint set is constructed. The second part C of the constraint set propagates the current effect \nbindings. The purpose of the first part is twofold. [N/I] [vi/I,]C ensures that the constraint set is \nactually poly\u00admorphic over the abstraction variable, using the same idea as in the unification procedure \n(i.e., by simulating a projection upon a new constant description N). [N/I] [w/Ii]{ (F, pure)} arranges \nfor the body of the expression to always pure. New unification variables r+ are introduced to decouple \nthe check for polymorphism from the propagation of constraint bind\u00adings. 5 Correctness Theorems The following \ntheorems show the termination, soundness and completeness of the type reconstruction algorithm with respect \nto the typing rules of KFX and study the complexity of R. 5.1 Termination Theorem 2 (Termination) R{ \nA, E ) terminates. Proof. R works by induction on the structure of expres\u00adsions, which are of finite \nheight. u 5.2 Soundness Theorem 3 (Soundness) Let (T, F, C, S) = R(A, E) and m be a model: (m+ C)+mSA \n1-E : rnT. !mF Proof. By case analysis of the typing rules and induction on the structure of expressions. \nWe describe the interesting cases of proj (which takes advantage of the compound con\u00ad straint created \nby planrbda) and application (which uses the unification theorem). For proj, suppose that: ([D/I]T, F, \n[D/I]C, S) = R(A, (proj E D)) and m ~ [D/I]C. We want to prove: mSA F (proj E D) : m([D/I]T) ! mF (1) \nSince m is defined only on unification variables: m([D/I]T) = [D/I](~T). Thus, for (1) to be true, we \nneed to prove, according to the typing rule (polyE): mSA k E : (poly (I K)mT) !mF Since, by definition \nof R, ((POIY (I K) T), F,C, S) = R(A, E) then by induction: (m ~ c) ~ m SA 1-E : m (poly (I K) T) ! m \nF Since, as before, m (poly (I K) T) = (poly (I K) m T) we just have to show that m 1= C. But, by hypothesis, \nm > [D/I]C. Since C is the constraint associated to a poly\u00admorphic type, it comes from either 1) an explicit \nplambda, in which case we took care to check that C is satisfiable for any 1, or 2) from a formal argument \nthat has a polymorphic type, in which case C is equivalent to ~. Thus, m &#38; C. For application, suppose \nthat R(A, (Eo EI )) is equal to (SLq, (nmxeff FO (rnaxeff F, 1/1)), CO U C, U C, SSIS.) and m ~ Co U \nCl U C. We want to prove that in the envi\u00adronment mSS1 So A: (I% !%) : m(Srq ) ! m(maxef f FO (maxef \nf F1 VI)) (2) However, by using structural induction, we can apply SSI to mSoA 1-E. : mTo ! mFO and apply \nS to mSl SOA 1-El : mTl !mFl, since m + COand m + Cl. By the unification lemma, since m + C: mSSITO w \n(proc mvl (mSTl) mSv2) To complete the proof of (2), we thus only have to use the typing rule (+ E). \n0  5.3 Completeness Theorem 4 (Completeness) If mSA 1-E : T ! F, there exist (T , F , C!, S ), a model \nm! and a substitution P such that: (T , F , C , S ) = R(A, E) m P S A = mSA, on FV(E) 1 m EC T N m P \nT [ F -m F Proof. As before, by induction on the typing deriva\u00adtion and induction on the size of terms. \nWe will prove the case of lambda abstraction on F! types, which shows how to deal with unification variables, \nand polymorphic abstrac\u00adtion, which checks for pureness of expressions. For lambda on M types, assume \nthat mSA E (lambda (I) E) : (proc F (M) T) ! pure  By (+IM), this requires mSAII:M]!-E:T!F which is \nequivalent to m(S[M/v])(AII : v]) t-E : T ! F where v is fresh. By induction, there exist (T , F , C \n, S ), m and P that verify the theorem for E in the environment m(S[M/v])(AII : v]). In particular: m \nP S (A[I : v]) = m(S[M/u])(AII : v]) To prove the theorem, pick: T = (proc F (S v) T ) F = pure   \nc1= c y = C&#38;f m =m P =P The theorem is verified since m P S A = m P S A on the free variables of \nthe lambda expression, m ~ C = m + C and m P T = (proc m F (m P S v) m P T ) = (proc F (M) T) For plambda, \nassume that mSA E (plambda (I K) E) : (poly (I K) T) ! pure By (polyI), this requires (mSA)[I ::K]RE \n: T!pure which is equivalent to mS(AII :: K]) 1-E : T ! pure By induction, there exist (T., F., Co, \nSo), m. and P. that verify the theorem for E in the environment mSAII :: K]. Since we know that the polymorphic \nplembda expression has a type, it also has one when projected upon any description. Thus, for any constant \nN: mSA E [N/I]E : [N/I]T ! pure By induction, there exist T1, F1, C I, S1, ml and PI that ver\u00adify the \ntheorem for [N/I]E in the environment mSA. To prove the theorem, pick: T = (Poly (I K) To) F = pure C \n= [N/I] [~i/Ii](Co U {( Fo, pure)}) U (C. U {( Fo, pure)}) s =so m = [ml ll/~l]mo P =P. where {I, } \n= (FV(FO) U FV(CO)) FV(SO(AII :: K])) and vi are fresh. The theorem is trivially verified, except for \nthe verification of constraints. Since rno 1= Co and mOFO N pure, then m 1= CO U {(Fo, pure)}. For the \nfirst term C l of C defined by C l = [N/l] [~:/I:](Co U {( Fojpure)}) m ~ C I can be successively rewritten \nSS: m ]=(7 1= [ml L/~i]mo 1= [N/I] [~i/Ii](co u {(Fo,pure)}) = mO + [N/I] [ml It/I,] (CO U {( FO, pure)}) \n= (ml ~ Cl) A (miFl * pure) since the set of free variables {Ii} of FO and CO is the same (more precisely, \nis isomorphic to) the one of F] and Cl. 0 5.4 Cor@exity Type checking a program now amounts to running \nR in an initial environment that binds predefine variables (such as cons, set, ! or bool) to their types \nor kinds. Deciding whether the program is type-safe is equivalent to finding a model m that satisfies \nthe constraint set C. Theorem 5 (Decidability) The type and eflect recon\u00adstruction problem for I(FX is \ndecidable. Proof. KFX type reconstruction depends on the decid\u00adability of the satisfiability problem \nfor constraint sets. Since maxeff is an ACUI operator, constraint satisfiability can be decided by an \nACUI-unification algorithm [LC89]. 0 ACUI-unification is an NP-cornplete problem [KN86]. This intractability \nis rooted into the presence of free func\u00adtion symbols in terms. The definition of KFX does not sup\u00adport \nfree effect functions, and thus constraint set satisfaction is a function-free ACUI unification problem. \nThe following theorem, due to McAllister and Blair, implies that the sat\u00adisfiability problem for constraint \nset satisfiability is polyno\u00admial time decidable. Definition 2 (Function-free ACUI Unification) An A \nCUI unification problem will be called function-free if the ord~ function symbol in the problem is the \nA CUI operator. Theorem 6 (Complexity [MB90] ) Function-free A CUI unification is polynomial time decidable. \nProof. Each equation in a function-free ACUI unifica\u00adtion problem has the form: (maxeff XI ... Xm) w \n(maxeff Y1 ... Y.) where maxeff is the ACUI operator and Xl and Yj are either variables or constants. \nWithout loss of generality, we will consider the special case of effect equations, and we have extended \nthe maxeff constructor to allow a variable number of arguments in which duplicates and pure are eliminated. \nIf we consider the universe of N effect constants El to EN drawn from the constraint set, we can rewrite \nan equation as the following set of N double implications: This set of double implications is identical \nto the original equation because they will be true if and only if the set of effects on both sides of \nthe original equation were equal. We now rewrite each double implication, say for Ei, into the following \nset of single implications: This rewriting transforms a single constraint into (m+ n)N implications. \nTaking the contrapositive of each implication, we have: Ei@Xj+(E: @YIA... AEi @).) and similarly for \nYs. Thus if we start with k constraints with sides having at most n terms, we will have O ( kn N ) sin\u00adgle \nsided implications. These implications are propositional Horn clauses and thus their satisfiability can \nbe determined in linear time [DG84] starting with the following polynomial number of axioms: E; @ EJ \nif z is different from j 1 KFX type reconstruction is not necessarily polynomial in the size of the input \nprogram, even though the satisfiabllity of constraint sets can be decided in polynomial time. The reason \nis that the constraint set built by R doubles in size each time a plambda construct is encountered. Thus \ncon\u00adstraint set size is exponential in the nesting level of plearbda constructs. We expect this not to \nbe a major problem in practice since plambda nesting is usually shallow. 6 Extension to Generic Types \nIt is possible to add to our system the notion of generic types used in structural reconstru ction systems \nfor type checking let constructs.  6.1 Definitions The language KFX1et adds the let binding construct \nto KFX: E + = (let (I Eo) El) local binding We will create generic types for a let variable that is bound \nto a pure expression. Following [T87], we will only create a generic type for a variable that is bound \nto a non\u00adexpansive expression: Definition 3 (Expansive) An expression E is expansive ifl E is not a variable, \na lambda expression or a plambda expression. The astute reader might question why we do not nse our own \neffect information to determine which bindings to gen\u00aderalize. The reason is that there is no guarantee \nthat we can solve the effect equations that describe the effect of binding expressions at the time we \nexamine a let. An implementa\u00adtion could use backtracking to solve this problem. Our typing rule for let \ndoes not compute a type scheme in order to avoid the difficulty of describing in the rule sys\u00adtem how \nto adapt type schemes to include effect constraints. However, our reconstruction algorithm for let in \nthe next section does in fact compute an algebraic type scheme. We later prove the consistency of this \napproach. The typing rule system for KFX1et includes all the rules used in KFX, plus the (Glet)2 and \n(let) rules: A 1-EO:TO! pure A t-[~/I]E1 : T1 ! F1 (G1et) &#38; is not expansive A 1-(let (I ~) El) : \nT1!F1 A ~ &#38;j: To!Fo AII: To] 1-E1 :T1!F1 (let) EO is expansive A 1-(let (I M) El) : TI ! (rnaxeff \nFO Fl)  6.2 Generic Reconstruction We describe the type of a let bound variable in our recon\u00adstruction \nalgorithm with an algebraic type scheme. An alge\u00adbraic type scheme packages together a syntactic t ype \nscheme and a constraint set. As we have already seen, we can not use syntactic type schemes to represent \nthe most general type of an expression in our system. This is because our re\u00adconstruction algorithm returns \na type that is subject to an effect constraint set. Thus there is no way to describe the possible types \nof an expression via synt attic substitutions. Definition 4 (Algebraic Type Schemes) An algebraic type \nscheme is noted (V {Ii} (T, C)). By convention, T w (b 4 (T, $J)). The A environment maps identifiers \nto algebraic type schemes. The previous definition of R can then be expanded in the following way: R(A, \nE)=... I => if [1:(V {I, } (T,C))] cA then ([~~/Il]T, pure, [~,/Il]C, u) where ~; are fresh else fail \n(let (I E.) El) and E. expansive => let (TO, FO,CO, SO) = R( A, E. ) let (TI, FI, C1, SI) = R( SO(AII \n: To]), E] ) (Ti, (maxeff FO FI), CO U C,, .% SO) (let (I E.) El) and EO not expensive => let (TO, FO,CO, \nSO) = R( A, E. ) let {1;} = (lW (To) U FV(CO)) -FV(SOA) let A e AII : (V {Ii} (TO, CO))] let (TI, F1, \nCI, SI) = R( SOA , El ) (T,, F,, CO UC,, SISO) The most interesting part deals with the non-expansive \ncase of a let expression. The let body is reconstructed in an environment that binds I to an algebraic \ntype scheme packaged by collecting To and Co. This type scheme is ab\u00adstracted over all the free variables \nthat do not occur in A. The type scheme is instantiated when I is used, thus mim\u00adicking the syntactic \nsubstitution of EO inside El. 2One can show [Ms9] that, in ML, this is equivalent to the usual type-scheme \nbased approach.  6.3 Correctness Theorems Theorem 7 (KFX1et) All the previous theorems about KFX stated \nin Section 5 extend trivially to KFX1et. Proof. The soundness and completeness properties of R w,r,t. \nthe expansive (let) rule can be shown by a straight\u00adforward structural induction. The reconstruction \nalgorithm for the non-expansive let implements the textual substitution required by the (Glet) rule. \nThis is easily seen by noticing that the type and constraint set of a non-expansive expression E only \nde\u00adpend on the free variables of E, i.e. of the environment A. Algebraic type schemes simply cache the \ntype and effect constraint that would have to be recomputed each time EO appeared in the substituted \nbody. o 7 Conclusion We have presented the first algorithm for reconstructing the types and effects of \nexpressions in the preseuce of first class procedures in a polymorphic typed language. Effects are more \ncomplicated to reconstruct than types because the al\u00adgebra of effects induces complex constraints on \nboth effects and types that must be solved during reconstruction. Alge\u00adbraic reconstruction was introduced \nto deal with these con\u00adstraints. We proved that it is sound and complete and we studied its complexity, \nIt is likely that algebraic reconstruction will find appli\u00adcation in systems without effects. For example, \nalgebraic reconstruction could prove useful for type systems with al\u00adgebraic properties; a simple example \nis the type algebra of records [W87]. Algebraic reconstruction is being implemented inside the FX compiler \nunder development at MIT in order to assess the practicality of our approach. Acknowledgnvmts We thank \nDavid McAllister and Michael Blair, who discov\u00adered the polynomial reduction of constraint set satisfiability \nto satisfiability of propositional Horn clauses. We also thank Hans Boehm, Vincent Dornic, James O Toole, \nMark Shel\u00addon and Jean-Pierre Talpin for their insightful comments, References [B85] Boehm, H. J. Partial \nPolymorphic Type Inference is Undecidable. In Proceedings of the 26th FOCS Sym\u00adposium. IEEE, 1985. [C84] \nCardelli, L. A Semantics of Multiple Inheritance. In Proceedings of the Inter. Syrnp. on Semantics of \nData Types, LNCS 173, Springer-Verlag, 1984. [DG84] Dowling, W. F., and Gallier, J. H. Linear-time Al\u00adgorithms \nfor Testing the Satisfiabllity of Proportional Horn Formulae. J. Logic Programming (3), 1984. [DhJf82] \nDamas, L,, and Milner, R. Principal Type Schemes for Functional Programs. In Proceedings of the 9th An\u00adnual \nACM Conference on Principles of Programming Languages. ACM, New York, 1982, [FL083] Fortune, S., Leivant, \nD., and O Donnell, M. Sim\u00adple and Second-Order Type Structures. JA CM, Jan. 1983. [GJLS87] Gifford, D. \nK., Jouvelot, P., Lucassen, J. M., and Sheldon, M. A. The FX-87 Reference Manual. Mas\u00adsachusetts Institute \nof Technology, LCS/TR-407, 1987. [GR88] Giannini, P., and Ronchi Della Rocca, S. Charac\u00adterization of \nTypings in Polymorphic Type Discipline. In Proceedings of the IEEE LICS Syrnposiuna. IEEE, 1988. [HG88] \nHammel, R. T., and Gifford, D. K. FX-87 Per\u00adformance Measurements: Dataf70w Implementation. Massachusetts \nInstitute of Technology, LCS/TR-421, 1988. [J89] Jategaonkar, L. A., ML With Extended Pattern Matching \nand Subtypes. Massachusetts Institute of Technology, LCS/TR-468, August 1989. [JG89a] Jouvelot, P., and \nGifford, D. K. Communica\u00adtion E#ects for Message-Based Concurrency Mas\u00adsachusetts Institute of Technology, \nLCS/TM-386, February 1989. [J G89b] Jouvelot, P,, and Gifford, D. K. Reasoning about Continuations with \nControl Effects. In Proceedings of the ACM SIGPLAN Conference on Programming Lan\u00adguage Design and Implementation. \nACM, New York, 1989. [KN86] Kapur, D., and Narendran, P. NP-Completeness of the Set Unification and Matching \nProblems. In Pro\u00adceedings of the 8th Inter. Conference on Automated Deduction. LNCS 230, Springer-Verlag, \n1986, [LC89] Lincoln, P., and Christian, J. Adventures in Associative-Commutative Unification. J. of \nSgrnbolic Computation (8), 1989. [LG88] Lucassen, J. M., and Gifford, D. K. Polymorphic Effect Systems. \nIn Proceedings of the 15th Annual ACM Conference on Principles of Programming Lan\u00adguages. ACM, New York, \n1988, pp. 47-57. [M68] Morris, J. H. Larnbda-Calculus Models of Program\u00adming Languages, Massachusetts \nInstitute of Technol\u00adogy, MAC-TR-57, 1968. [M78] Milner, R. A Theory of Type Polymorphism in Pro\u00adgramming. \nJournal of Computer and System Sciences, vol. 17, 1978, pp. 349-375. [M89] Mitchell, J. Type Systems \nfor Programming Lam guages. Stanford Rep. CS-89-1277, 1989. [M90] Mairson, H. G. Deciding ML Typability \nis Complete for Deterministic Exponential T:me, In Proceedirzgt of the ACM Conference on Principles of \nProgramming Languages. ACM, New York, 1990. [MB90] McAllister, D., and Blair, M. Private communica\u00adtion. \nJuly 1990, [OG89] O Toole, J., and Gifford, D. K. Polymorphic Type Reconstruction. In Proceeding. of \nthe ACM SIGPLA N Conference on Programming Language Design and Im\u00adplementation. ACM, New York, 1989. \n[P88] Pfenning, F. Partial Polymorphic Type Inference and Higher-Order Unification. In Proceedings of \nthe ACM Conference on Lisp and Functional Program\u00adming. ACM, New York, 1988. [R65] Robinson, J. A. A \nmachine-oriented logic based on the resolution principle. JA CM 12,1 (1965), pp. 23-41. [T87] Tofte, \nM. Operational Semantics and Polymorphic Type Inference. Ph. D. Thesis, Edinburgh University, 1987. [W87] \nWand, M. Complete Type Inference for Simple Ob\u00adjects. In Proceedings of the IEEE LICS Symposium. IEEE, \n1987. [W88] Wand, M. Corrigendum: Complete Type Inference for Simple Objects. In Proceedings of the IEEE \nLICS Symposium. IEEE, 1988. [W89] Wand, M, Type Inference for Record Concatenation and Multiple Inherit \nante. In Proceedings of the IEEE LICS Symposium. IEEE, 1989.   \n\t\t\t", "proc_id": "99583", "abstract": "", "authors": [{"name": "Pierre Jouvelot", "author_profile_id": "81100056957", "affiliation": "Ecole des Mines de Paris and MIT Laboratory for Computer Science", "person_id": "PP31083642", "email_address": "", "orcid_id": ""}, {"name": "David Gifford", "author_profile_id": "81100151844", "affiliation": "MIT Laboratory for Computer Science", "person_id": "PP14063007", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/99583.99623", "year": "1991", "article_id": "99623", "conference": "POPL", "title": "Algebraic reconstruction of types and effects", "url": "http://dl.acm.org/citation.cfm?id=99623"}