{"article_publication_date": "01-03-1991", "fulltext": "\n An extension of Standard ML modules with subtyping and inheritance John Mitchell* Sigurd Dept. of Computer \nScience Dept. of Abstract We describe data types, framework with three rived from Stanford University \nUniversity Stanford, CA 94305 Bergen, mitchellQcs.stanford .edu sigurd~eik.ii a general module language \nintegrating abstract specifications and object-oriented concepts. The is based on the Standard ML module \nsystem, main extensions: subtyping, a form of object de-ML structures, and inherit ante primitives. The \nlanguage aims at supporting a range of programming styles, including mixtures of object-oriented programming \nand pro\u00adgrams built around specified algebraic or higher-order ab\u00adstract data types. We separate specification \nfrom implemen\u00adtation, and provide independent inheritance mechanisms for each. In order to support binary \noperations on objects within this framework, we introduce internal interfaces which govern the way that \nfunction components of one struc\u00adture may access components of another. The language de\u00adsign has been \ntested by writing a number of program exam\u00ad ples; an implementation is under development in the context \nof a larger project. Introduction This paper describes a general module system which pro\u00advides approximately \nthe same functionality as a combina\u00adtion of Standard ML modules (signatures, structures and functors) \n[HMM86], C++ classes [Str86], and Ada packages [US 80], enhanced with a form of specification. Our de\u00adsign \neffort stems from a larger project to produce a pro\u00adtotyping language and programming environment. How\u00adever, \nsince our modules most closely resemble Standard ML [Mac85, HMM86], we have chosen to present the module \ndesign as an extension of that language. Many of the sub\u00adtyping ideas we use here have appeared in previous \nwork, e.g., [CM89]. The primary new features of this language are Supported in part by an NSF PYI Award, \nmatching funds from Digital Equipment Corporation, the Powell Foundation, and Xerox Corporation; NSF \ngrant CCR-S814921 and the Wallace F. and Lucille M. Davis Faculty Scholarship tSupported Agency/Information \nNaval Research fice of Scientific Supported the Humanities. by the Defense Advanced Research Projects \nSystems Technology Office under the Office of contract NOO01490-J1232 and by the Air Force Of- Research \nunder Grant AFOSRS3-0255. by the Norwegian Research Council for Science and Permission to copy without \nfee all or part of this matertial is granted provided that the copies are not made or dkributed for direct \ncommercial publication permission wise, or to @ 1990 advantage, the ACM copyright notice and the title \nof the and its date appear, and notice is given that the copying is by of the Association for Computing \nMachinery. To copy other\u00ad republish, requires a fee and/or specific permission. ACM 089791-419-81901001210270 \n$1.50 Meldalt~ Neel Madhavt Informatics Dept. of Computer Science of Bergen Stanford University Norway \nStanford, CA 94305 .uib .no madhav@cs.st anford.edu the generalization of structures to encompass typed \n%rst\u00adclass objects, and inheritance primitives for specifications and structures. Our module design is \na proper extension of Standard ML. We extend signatures to specifications, which may contain axioms as \nwell as the types of structure components, and ex\u00adtend the basic typing discipline to include subtyping. \nA new feature is a set of inheritance primitives for specifications, and a parallel mechanism for structures. \nA major change is that we essentially allow signatures (specifications ) t o be used as ordinary types. \nThis has the consequence of allow\u00ading structures to be passed as function arguments, returned as function \nresults, or stored in reference cells. In imprecise but suggestive jargon, we generalize Standard ML \nstructures to first-class objects. To keep the typing problem for this language tractable, we must change \nour notion of equality for type components of structures. In effect, we make use of the first class abstract \ndata type approach of [MP88], also used in the programming language Quest [Car89]. How\u00adever, this change \nis applied in a systematic way which co\u00adincides wit h Standard ML typing for top-level structures and \nfunctors (the cases allowed in Standard ML). Another change is that we allow a specification name to \nappear in the type of one of its components (a form of recursive type), and provide an expression self \nfor defining such compo\u00adnents of structures. A novel feature, in comparison with other object-oriented \nlanguages, is the use of internai in\u00adterfaces in specifications. The need for this new construct arises \nin part from our separation of specification and imple\u00ad mentation, and our flexible forms of inheritance; \nsee ~Section . 6.1. Finally, we allow parametrized specifications (which seem especially useful for \nobject-oriented programming) and use bounded quantification [CW85, CCH+ 89, CM89] rather than unconstrained \nML polymorphism. One of our language design goals of programming styles within a single of interest is \nthe traditional program wise refinement , using abstract data is to support a range framework. One style \ndevelopment by step\u00adtypes and specifica\u00ad tions. However, it is recognized that for realistic, large-scale \nprograms, this idealized approach is not always effective. The main drawback is that in the pure style \nadvocated in the early 1970 s [Dij72, Par72], a significant amount of ef\u00ad fort may be put into the design \nbefore Therefore, program behavior cannot be program design until relatively late in cle. It is often \nbetter to write a simple the life of a project and use properties gram as a basis for further refinement \n 270 any code is written. used to evaluate the the development cy\u00ad prototype early in of the prototype \npro\u00adof either the design or implementation. We therefore envision an approach to program development \nwhich involves successive refinement of working code, with substantial code reuse from one pro\u00adtot ype \nto the next. Further discussion of our protot yping model may be found in [BL90]. We are unsatisfied \nwith previous object-oriented lang\u00ad uages for a number of reasons. One is the lack of sup\u00adport for specified \nalgebraic data types, which are familiar to and valued by our intended user community. Another is the \nway that specifications (typically signature information only) and implementation are identified in a \nsingle language construct. (An exception is Emerald [B HEL86], which has several similar feat ures, but \nlacks inherit ante. ) We believe that the separation of specification from implementation will prove \nbeneficial to the development of large object-oriented programs, both by allowing independent use of \neither spec\u00adification or implementation inheritance (see [Sny86]), and by allowing multiple implementations \nof a single class to coexist peacefully within a single program. Thus we pro\u00advide explicit lauguage support \nfor what is often achieved by the programming technique of so-called abstract classes [GR83, page 66-72]. \nIn addition, our unified approach to abstract data types and objects allows object-oriented con\u00adcepts \nto be mixed with other programming styles, and pro\u00advides inheritance of specification and implementation \nfor al\u00adgebraic data types. Finally, we provide a compile-time typ\u00ading discipline which is more flexible \nthan C++, wit bout the type insecurity of Elffel [CO089]. Our type system is an ex\u00adtension of ML polymorphism, \nbased in part on the record calculus of [C M89], and including F-bounded quantifica\u00adtion [CCH+ 89] for \nspecifying uniform behavior over func\u00adtionally similar classes of objects. An additional goal of our \nproject, not reported here, is the integration of a form of concurrency based on objects with concurrent \nmethods. An implementation is underway encompassing most of the fea\u00adtures discussed in this paper, as \nwell as concurrency at the method level and various debugging tools. In this paper, we will focus primarily \non the program\u00adstructuring aspects of our language, leaving further discus\u00adsion of specifications and \ntheir use to later publications. The basis for our specification language and development tools is [LvHKB087, \nLHM+ 86]. To a large extent, when restricted to the context of Standard ML, our specifications do not \ndif\u00adfer substantially from Sanella and Tarlecki s Extended ML [ST89]. Since we have not fully investigated \nthe problem of ML-style type inference with subtyping, we will consider ML an explicitly typed language, \nas explained in [MH88]. However, based on past experience, we do not foresee any serious obstacles in \nextending ML-style type inference to our language. The reader concerned with type inference and subtyping \nmay consult [Mit84, Wan87, R6m89, JM88]. In Section 2, we give an informal introduction to the module \nlanguage by describing two simple stack examples. Section 3 follows with a brief glossary of basic terminology. \nIn Section 4, we briefly outline our use of subt yping. The main features of our form of modules are \ndescribed in Sec\u00adtion 5, with motivating examples for certain design decisions given in Section 6. Section \n7 places our extension of Stan\u00addard ML in a type theoretic perspective. 2 Exa~les of abstract data types \nand classes To give some feel for the module extension, we will compare two forms of stack specification, \none as an abstract data type (ADT) and the other as a class of objects. While these both use the same \nlanguage constructs, the two program\u00adming styles are distinctly different. In both examples, as an expository \nconvenience, we use equality freely without considering its logical interpret ation. In the traditional \nADT approach, stacks might be intro\u00adduced by the following form of specification, which is our extension \nof Standard ML signature: specification Stack=pec = external type S[type t]; val empty [type t] : S[t]; \nfun push[type t]: t * S[t] + S[t]; fun pop[type t]: S[t] + S[t]; fun top[type t] : S[t] + t; ,.. constraint \nfor all type t, x: t,s : S[t]. pop[t](push[t](x, S)) = S; top[t](push[t](x, S)) = X; . .. end  Except \nfor the explicit type parameters and axioms, this is essentially the usual Standard ML signature. (The \nkey\u00adword external indicates that the named components are accessible outside the structure body; we also \nhave internal interfaces, described later. ) A module implementing stacks would then give a representation \nof stacks (as a function of the type of elements stored), and code for the associated operations. Although \nour construct is slightly different, we will use the Standard ML term structure for a basic module. structure \nStack_impl : Stack_spec = struct datatype S[type t] = empty.stk[t] I stk of t * S[t]; val empty [type \nt] = empty -stk[t]; fun push[type t](x: t,s : S[t]) : S[t] = stk(x, s); ... end For the purpose of writing \nStandard ML-style programs, our most significant extensions are subtyping and inheri\u00adt ante. Inherit \nante is useful for defining one module from another, and subtyping allows the programmer to indicate \nthat elements of one type are substitutable for elements of another. For example, we might specify that \na type of stacks with an additional operation is a subtype of the stacks im\u00adplemented as above. (A similar \nuse of subt yping and ML abstract data types was presented in [J M88], where a type inference algorithm \nis developed. ) A pervasive difference between our module system and Standard ML is our treat\u00adment of \ntype equality, specifically, equality of type compo\u00adnents of structures. We allow structures to be used \nas first\u00adclass values, with the consequence that within certain well\u00addelineated contexts, type components \nmay become (hidden as opposed to visible types. This is discussed in more de\u00adtail in Section 5.3 and \nfrom a type-theoretic perspective in Section 7. An object-oriented approach to stacks involves a class \nof objects, each of which implements a single stack. We will have one type of objects for each type of \nstack entry, given by the following parameterized specification. specification Stack-class[type t] = \nexternal fun is.empty :unit--+bool; fun push: t+ Stack-class[t]; fun pop:unit +Stack.class[t]; fun top:unit-+t; \n ... constraint for all type t, s: Stack-class[t], x:t. (s.push(x)).top = X; (s.push(x)).pop = S; ... \nend A structure M satisfying the specification Stack_class[t], for some type t, is essentially an object \nwith operations M.push, M.pop, and soon. (The Standard MLtypeunitis a trivial, one-element type used \nto indicate that M.pop, for example, has an empty parameter list and returns a value when called, possibly \nhaving a side effect. ) Objects are implemented as structures. Following Stan\u00addard ML terminology, we \nrefer to parameterized structures as}unctors. AgeneraJ implementation ofstack objects would be afunctor \nwhich creates objects of type Stack.class[t] when called with type parameter t. functor Stack-object[type \nt] :Stack_class[t] = struct val contents:ref List[t]=ref nil; fun is-emptyo: bool= (contents =0); fun \npush(x: t) :Stack-class[t] = (contents := cons(x, !contents)); self; end The list pointer contents is \nprivate to an object since it does not appear in the Stack_class external interface. For the reader unfamiliar \nwith Standard ML, we note that the op\u00aderator ! returns the contents of an assignable reference cell. \nThe body of push deserves explanation. This is asequence of expressions. The value returned is the value \nof the sec\u00adond expression, self, after evaluating the first for side effect. Since thevalue of self, \nwhich is not part of Standard ML, is the entire structure, the effect of s.push(x) is to add x tothe \ncontents list of s and return the resulting stack struc\u00adture. Although without self wecould write a similar \npush function with only aside effect, this would make compound expressions such as s.push(x) top meaningless. \nSince we separate the interface to an object from the function which creates objects, it is straightforward \nto give several implementations of a single class. This leads to a difficulty with binary operations \n[Mit90a], which is resolved using internal interfaces, as discussed in Section 5. Basic concepts andteminology \nstructure: Syntactically, a structure is an encapsulated set of declarations, including types, functions \n(procedures) and other values. Semantically, a structure is a com\u00adposite value determined by a set of \nsuch declarations. functor: Afunctor isaparameterized definition ofastruc\u00adture, asin Standard ML. specification: \nA specification defines two interfaces, called the externcai inter~ace and the internal interface. Each \ninterface consists of a signature, giving names of com\u00adponents and their types, and an optional set of \ncon\u00adstraints (axioms) restricting the behavior of structure components. The external interface defines \nthe visi\u00adblecomponents of the specification, while theinternaJ interface may impose additional demands \non all imple\u00admentations of the specification. These are described in greater detail in Sections 5.1 and \n6.1. We consider a specification a form of type, namely, the type of all structures meeting this specification. \nOur use of speci\u00adfication corresponds to Standard ML signature or Ada package specification, extended \nwith an internal inter\u00adface and constraints. type: A type is a collection defined by a type expression \nor specification. Types are separated into two khds, which we call srncdt types and large types. This \ndis\u00adtinction corresponds to the Standard ML distinction between signatures and types. Thesmall types \nare ba\u00adsic types such as int, bool, string, types obtained from these using constructors such as record \nand array, and specifications with only abstract type components. Values from any small type may be stored \nin a refer\u00adence cell, for example, or returned as the result of a conditional expression. Specifications, \nin general, de\u00ad fine large types. Implicit coercion from large to small types isdiscussed in Section \n5.3. Thenames small and large are related toconstructive type theory (see, e.g., [Mar84, C+86, Mac86, \nMit90b]). subtype: A type A is a subtype of B if every expression of type A may be used in any context \nrequiring an expression oftype B, without type error. In fact not all subtypes are recognized by the \ncompiler, just as most languages do not recognize allpossible type equalities. The compiler only recognizes \nA as a subtype of B if this follows from the form or declaration of at least one of these types. inheritance: \nWe use inheritance informally to refer to various mechanisms for using one declaration in writ\u00ading another. \nWehaveseparate inheritance mechanisms for specifications and for structures. 4 Extending MLwith subtypes \nSubtypingis a general extension to Standard ML which ef\u00adfectsboth these-called corelanguage of basic \nexpressions and declarations, as well as the module system. Since the subtyping ideas we use, outside \nof the module system, have been proposed in previous papers [CW85, Mit84, JM88] [CM89], we will only \ngive a brief summary of subtyping. More detailed discussion ofsubtyping for specifications and structures \nappears in Section 5. We use the notation A <: B to indicate that A is asubtypeof B. There are five ways \nthat atype A may become a subtype of B, depending on the forms of A and B. basic types: If A and B are \nbasic, predefine types, then A<: B iff this is given as part of the language definition. type constructors: \nIf A and B are types defined using the same type constructor, then A <: B iff this follows from the subtyping \nproperties for this constructor. For ex\u00adample, if A= Al x A2 and B= B1 x B2 are both carte\u00adsian products, \nthen A<: B ill Al <: B1 and A2 <: B2. specifications: If A and B are specifications, then A <: B iff \nspecification A includes all of the component declara\u00adtions and constraints of B, and the declaration \nof either A or B makes it clear that subtyping is intended. declared type identifier: If the declaration \nof a type id\u00adentifier t specifies that t is a subtype of A, then t <: B iff A <: B. A similar rule holds \nfor formal parame\u00adters: a formal parameter t is a subtype of B only if thk follows from a subtype or \nsharing constraint in the formal parameter list containing t. predefinecl supertypes: Several designated \nbasic types are supertypes of all types of a given form. For example, record is a supertype of all record \ntypes. Subtyping is essentially a generalization of type equality. In Standard ML, and most typed languages, \nwe generally assume that if A and B are equal types, then any expression with one of these types also \nhas the other. With subtyping, we augment type equality with the so-called subsumption rule: If A <: \nB and expression e has type A, then expression e has type B. Subtyping may also be used in parameter \nlists, to restrict the possible values of formal parameters. This is illustrated by example in Section \n6.2. A point worth mentioning briefly is the lack of connection between snbtyping of specifications and \nsubtyping of ab\u00adstract data types defined by these specifications. Consider, for example, a specification \nQ_spec introducing a type Q of queues with the usual operations, and a similar specifica\u00adtion DQ_spec \nintroducing a type DQ of double-ended queues. Since any structure satisfying DQ_spec also satisfies Q-epec, \nit is reasonable to consider Dq=pec <: Q.spec. In common terms, this means that any implementation of \ndoubly-ended queues is also an implementation of queues. However, if M : Q_spec is a structure satisfying \nQ-spec and DM: DQ-spec is a structure satisfying DIJ-spec, the component type DM.DQ is not necessarily \na subtype of M.Q. 5 General description of specifications and structures 5.1 Specifications Syntactically, \na specification has three main parts: an in\u00adheritance list, an external interface and an internal inter\u00adface. \nThe inheritance list may give one or more specifications which may be extended, restricted or copied, \nas described in Section 5.2 below. Each interface condists of a signa\u00adture, giving names of components \nand their types, and an optional set of constraints restricting the behavior of struc\u00adture components. \nFor the purpose of this paper, the con\u00adstraints may be regarded as axioms about the components, written \nin a version of multi-sorted first-order logic whose sorts are the types of the programming language. \nThe ex\u00adternal interface describes the structure components that are available outside the structure and \nthe internal interface de\u00ad scribes components that are visible only to other instances of that specification \nand its subtypes. The motivation for having separate internal and external interfaces is illustrated \nin Section 6.1. When a type component is listed as part of a specification, a list of subtypes and supert \nypes of this type may be given.  5.2 Specification inheritance There are three inheritance operations \non specifications. The first is extend. If specification A is defined by extending B, then the declaration \nof A need only mention components and axioms that are not given in B. The result is that spec\u00adification \nA is equivalent to the union of the declarations of A and B, and the type A becomes a subtype of B. The \nconverse operation is restrict. If A is defined by restricting B, then the declaration of A lists components \nand axioms of B that are to be omitted from A. The result is that A is a super\u00adtype of B. A specification \nmay extend several specifications, defining a subtype of each. The third operation is copy, which is \nessentially equiva\u00adlent to inserting a textual copy of a specification, and does not result in a subtype \nor supertype. Either an entire spec\u00adification may be copied, or the two forms copy (specification-name) \nexcept . . . copy (specification-name) only . . . may be used. In the first case, all components of \na spec\u00adification are copied, except those listed. The second form only includes the listed components, \nwhich may be more convenient if only a relatively small part of a specification is required. An added \nfeature of extend and restrict is the ability to rename components. This adds some complexity to sub\u00adtyping \nfor specifications, since the names of the components in one type may not correspond directly to the \nnames of components in a supertype. However, the conversion from one type to another is straightforward \n(and easily imple\u00admented), and this feature seems to provide a very effective way for the programmer \nto resolve name conflicts in mul\u00adtiple inheritance. Renaming with copy is straightforward since copy-ing \na specification is not required to result in a subtype. 5.3 Structures Our structures are similar to \nStandard ML structures, with inherit ante primitives added. The most significant differ\u00ad ence is in our \ntreatment of type equality. The desire for decidable compile-time type checking im\u00adposes certain restrictions \non computations with ML modules ([MH88, HMM90]). For instance, ML signatures, structures and functors \nmay only be declared at top level, and func\u00adtor application is restricted to top level. This is because \nthe type part of a functor application is required at compile\u00adtime [MTH90, HMM90]. This conflicts with \nour desire to support object-oriented programming, since we would like to allow arbitrary computation \non structures such as the object-oriented style stacks mention in Section 2. Our solution to this problem \nis to allow arbitrary com\u00adputation with structures, but to limit type equality to what may be determined \nat compile time. In a sense, where Stan\u00addard ML restricts the language, we choose instead to restrict \nthe degree of dataflow analysis used in type checking. If a structure has no type components, then computing \ntype equality simply does not enter into the picture: A structure without type components is essentially \na record, and arbi\u00ad trary computation may be allowed without complication. Similarly, as shown in [MP88], \nif all type components are abstract types, there is no need to restrict computation on structures. The \nonly problem arises when a structure has a type component which we expect to be equal to another type. \nIn this case, we cannot expect to test equality at com\u00adpile time, if the structure is a result of an \narbitrary function call or conditional expression. Using a systematic criterion which is related to the \ndistinction between small and large types (see [Mac85, MH88, HMM90]), we identify a class of compile-time \nevaluable structure expressions. These include the application of a top-level functor to a top-level \nstructure. If usage dictates that the type component of a structure must be equal to another type, then \nthe type checker de\u00ad termines whether the structure is given by a compile-time expression. If so, then \nthe test for equahty is based on the actual structure value. If not, then the type is considered abstract, \n and distinct from other types, and the test may therefore fail. This mechanism is supplanted by the \nsharing constraints of Standard ML, which we generalize to subtype assertions. If a structure is a formal \nparameter, then the type relationships guaranteed by sharing constraints in the parameter list are acknowledged \nwithin the function body. Although the above description of type equality has an operational, algorithmic \nquality, the basic method has a straightforward explanation using standard type-theoretic concepts. This \nis summarized in Section 7. Essentially, when a structure is used in a conditional expression, we view \nthis as an implicit coercion of visible type components to abstract types. Since structures have many \nsimilarities to records, it might seem natural to identify objects with ML records in\u00ad stead of structures. \nIf ML typing were extended with a flexible form of record typing, as in [Wan87, R6m89, CM89] for example, \nthis would allow much of the object-oriented capability we provide. One important difference, however, \nis inheritance. Rather than extend ML records with inheri\u00ad tance, we have chosen to integrate objects \ninto the module system. This has the beneficial effect of allowing the same primitives to be used for \nspecification and implementation of abstract data types, objects, and various hybrids.  5.4 Structure \ninheritance One motivation for allowing separate inheritance of specifi\u00ad cation and implement ation comes \nfrom the fact that these two quite often work most naturally in opposite directions ([Sny86]). This maybe \nillustrated by considering queues and double-ended queues. It is natural to specify double-ended queues \nby extending the specification of queues, since half of the specification of double-ended queues is already \npresent in the specification of queues. On the other hand, if we have an implementation of double-ended \nqueues, then it is easy to implement queues by simply hiding some operations. This implementation of \nqueues does not depend on how the im\u00ad plementation of double-ended queues works, and so we could change \nthe latter without needing to redefine the former. However, if we tried to implement double-ended queues \nby adding operations to the implementation of queues, we lose this abstraction. A change in the implementation \nof queues might require us to change the implementation of double\u00ad ended queues. In this case, separate \ninheritance allows us to define both our specifications and implementations in the most natural way. \nThere is one inheritance operation on structures, COPY, with several options. The options allow inheritance \nof any or all components, renaming, and visibility restrictions. The following examples, using both options, \ninclude all but one of the basic keywords. copy (specification .mame) only . . . rename . . . hide ... \ncopy (specification.name) except . . . rename . . . show ... In the first example, only the listed components \nare copied. A list of renaming clauses, of the form (component-name) to (component_name), indicate which \ncomponents are rena\u00admed, and how. All of the copied components become visible components of the new structure, \nexcept those listed in the hide clause. The names except and show are complements of only and hide. The \nsimplest semantic description is textual copy. To give an example, an operation copy A only f, g in the \ndec\u00adlaration of structure B indicates that B will have visible com\u00adponents B. f and B. g derived from \nA. The behavior off and g is exactly the same as if both of their declarations in A (if that is where \nthey are declared) had been textually copied into the declaration of B. In particular, if f is a function \ncall\u00ading g, then this call in the body of f refers to the inherited g. If f also calls a function h, \nthen this call will go to the func\u00adtion h declared in B, not A. This is essentially the usual form of \ninheritance, as in Smalltalk, for example, except that we do not require all of a structure to be inherited. \nWe are able to provide this flexibility as a result of the fact that we do not force the two structures \nto have related types (sig\u00adnatures or specifications). The more complicated example copy A only f, g \nrename f to k may be understood as a textual copy, but with f renamed to k, including renaming all occurrences \nof f in the bodies of f and g. The effect of hide is straightforward. 6 Motivating Exar@es 6.1 Internal \ninterface We present two examples that illustrate the use of internal interfaces. 6.1.1 Time-stamped \nevents Consider time-stamped events. A specification for these might look as follows: specification time-stamped.event \n= external fun precedes : time_stamped_event + bool; fun eventname : unit + string: end Our implicit \nintention is that each structure of type time-stamped-event will have a local real variable which stores \nthe time of the event. Since the only time-related operation on time-stamped events is precedes, this \nvariable in not part of the external interface. However, if evi, ev2 : time-stamped-event are two events, \nthen evl . precedes (ev2) should compa~e the times of the two events, returning a boolean value. This \nrequires evl to have access to the time of ev2. If the function precedes must be implemented us\u00ading only \npublic operations on its argument, then the only solution is to make the time of an event public. This \nseems undesirable, since only other time-stamped events need to see the time of an event. The internal \ninterface solves this problem appropriately by letting us specify that every time-stamped event must \nhave a time component. By putting this requirement in the internal interface, we make the time component \nof one event accessible to the function components of other events, wit bout making time generally available. \nWit h an internal interface added, the specification will now appear as follows: specification time-etaraped-event( \n. . . ) = external fun precedes : time= tamped.event -+ bool; fun eventname : unit + string; ,.. internal \nval time : ref real; end  6.1.2 Sets with union Suppose we wish to specify and implement a class of \nset ob\u00adjects with a union operation. In object-oriented style, the union of two sets is computed by sending \none set as an ar\u00adgument to another. A first attempt at specifying set objects might be as follows. For \nexpository convenience, we assume that equality on type elem is provided in some way, and that an equation \ne I = e2 has a meaningful interpretation, even when evaluating one of these expressions might ordinarily \nside-effect the other. We may explicitly require equrdity on elem using means similar to those described \nin Section 6.2. specification SET[type elem] = external fun empty : unit -+ bool; fun element. : elem \n--+ bool; fun insert elem+ SET[elem]; fun delete : elem + SET[elem]; fun union SET[elem] + SET[elem]; \nfun intersect : SET[elem] -+ SET[elem]; constraint SET[elem].empty; (* all sets initially empty *) for \nall ol,02:SET[elem], el,e2:elem. ol.empty=> not ol.element(el); ol.insert(el).element(e2) <=> el=e2 or \nol.element(e2); ol.delete(el).element(e2) <=> el#e2 and ol.element(e2); ol.union(02).element(el) <=> \noi.element(ei) or 02.element(el); ol.intersect(02).element(el) <=> ol.element(el) and 02.element(el); \nend SET; If we try to implement the above specification, we run into difficulties with union (s: SET[elem]). \nThe problem is that the natural, efficient implementations ofunion need to iterate over the list of the \nelements in the argument s, but there is no apparent waytodo thisu sing only thepuNicop\u00aderations allowed \non s. One not quite satisfactory approach is to implement sets in a lazy style. While this makes union \neasy to compute, it becomes difficult to implement empty properly in the presence of intersection. A \nmore realistic approach is to extend the external interface with a. function element~ist which returns \na list of all the elements in the set. This has the undesirable effect of making more opera\u00adtions public \nthan required. Amoresubtle reason for keeping element~ist out of the external interfaces that we expect \nequality to be a congruence relation, but we do not require equal sets to have the same ordered element \nlist. Wemaysolve this problem using internal interfaces. An internal interface requiring an element~ist \nfunction forces each set to define a function element-list. However, this function is not publicly visible \n it may only be used by other set objects. The following example illustrates theuse of con\u00adstraints to \nstate correctness properties of internal interface functions. internal fun elementJ.ist : unit + List[elem]; \n constraint local in~i.st : elem*LLst[elem] -+ bool for all s: SET[elem], l: List[elem], e:elem. in-.list(e,l \n)<=> e=hd(l) or h.list(e, tl(l)); s.element(e) <=> in.list(e, s.elementlisto) end The declaration local \nin-list . . . indicates that the predicate identifier in-list is local to the constraint, and not part \nof the interface. With this internal interface, im\u00adplementing SET is straightforward. We should emphasize \nthe fact that theinternrd interface makesit easier for a single program to contain several differ\u00adent \nimplementations of the same specification. In the pure object-oriented style, any operation in a specification \nthat needs an argument of the same type (binary operations, in essence) cannot make any assumptions about \nthe argument, since it could have an arbitrary internal representation. The internal interface makes \nit easier to write binary operations byallowing the specification to impose restrictionsin addi\u00adtion \nto the external interface. Internal interfaces are used in a variant of the C++ friend concept. If elements \nof type A need access to the internal interface of B structures then the specification of B may list \nA as a friend type,  6.2 Pcriyrnorphisrn over structurally simkr types ofob\u00adjects In many situations, \nit is useful to define structures or func\u00ad tions which work uniformly over all types of objects with \ncertain operations. Although it is a simple example, sort\u00ad ing illustrates the main points. Using abstract \ndata types, a polymorphic sorting function would require a comparison (order) relation onthetype of list \nelements to besotted. This form of sort function would have type sort[type t] : (t*t +bool)* List[t]+List[t] \n In an object-oriented style, we would expect, each object in the input list to have a comparison function \ncomponent. This requirement must be incorporated into the type of sort, as a restriction on the type \nof list elements. Based on previous investigation [CCH+89], the appropriate way to restrict the type \nof list element appears to be through the introduction of a parameterized specification ordered [type \nt]. A parameterized specification ordered [type t] is es\u00adsentially a function which, given any type t, \nreturns a spec\u00adification requiring each x : t to have a comparison function x.less-thsn of type x.less-thsn \n: t + bool. Intuitively, the function x.less-than tells, for any y:t, whether x is less than y. Given \nthis parametrized specification, we can write the type of sort as sort[type t<:ordered[t]] : List[t]+List[t] \nIntuitively, if t is a type of objects, each having a com\u00adparison function component, then sort maps \nlists of t s to lists of t s. Although the reader might see the restriction type t<:ordered[t] on the \ntype of list elements as recur\u00adsive, it is not; see [CCH+89] for further discussion. Note that the same \nform of parameterization would be required if we wish to parametrize a binary search tree specification \nor implementation by the type of ordered records inserted into trees. If specifications of objects are \nsimply signatures, then the straightforward form of qualified polymorphism described above is sufficient. \nHowever, since we wish to give con\u00adstraintsin addition to signature information, a problem arises. This \nmay be seen by trying to define the parameterized spec\u00adification ordered [type t]. A naive first attempt \nmight be the following. specification ordered[type t] = external fun less_than:t-+bool constraint for \nall x,y, z:t. not x.less.than(x) x.less.than(y) and y.less.than(z) implies x.less.than(z) end Although \nthis specification might at first appear to express the intended restriction on t, it is not syntactically \nwell\u00adformed. The problem is that thecoustraint section assumes that ifx:t, then xhas a function component \nx.less.than. However, there is no assumption about the type t which justifies this. The inquisitive reader \nmay wish to ponder this point, and attempt to devise a solution before reading further. One solution \ntothisproblem istouse two specifications, one giving the signature part of this specification, and the \nother (depending on the first) expressing the constraint. More specifically, we may write the following \ntwo specifi\u00adcations. specification order-sig[type t]= external fun less_than:t -+ bool end specification \norder_constraint[type t<:ordersig[t]]= constraint for all x,y,z:t. not x.less-than(x) x.less_than(y) \nand y.less_than(z) implies x.less-than(z) end The important change f~om the single specification is that \nthe parameter t of the order_constraint is explicitly re\u00adquired to be a subtype of order-s ig[tl, and \nso itis clear within the specification body that any x : t has a less-than component of the appropriate \ntype. Since the parameterized specification we originally de\u00ad sired is a kind of (sequential conjunction \n of two specifica\u00ad tions, we may define ordered by the following declaration. specification ordered[type \nt] = order.sig[t] andthen order-constraint [t] Wealsoprovide syntax for defining ordered and similar \nparameterized specifications directly. 7 Type-theoretic perspective Our extension of Standard ML may \nbe understood within the type-theoretic framework used in [Mac86, MH88, HMM90] to explain the Standard \nML module system. While the in\u00addexed categorical view of [HMM90] provides some interest\u00ading insight into \nthe distinction between compile-time and run-time, we will restrict ourselves to the simpler and more \naccessible framework of [MH88], based on a predicative typed lambda calculus XML with two universes of \ntypes (see also [Set89]). In this section, we will briefly review XML and then describe an extension \nXML+ with subtyping and constructs illustrating theessential features of our extended module system. \nSince the basic subtyping features of XML+ are subsumed by the more ambitious system of [CM89], we emphasize \nthe modules as opposed to subtyping in this doc\u00adument. The language XMLis atypedlarnbd acalculus with \ntwo universes of types, U1 and Uz, which we have referred to informally as the small and large types, \nrespectively. Since the language may be defined with respect to any choice of basic types, type constructors \nand expression constants, the small types of XML may include basic types such as inte\u00adgersand booleans, \nandtype constructors such as list. The expressions of these types may be polymorphic, depending on type \nvariables, or may depend on structures. The modules of XML are constructs of the second uni\u00adverse (Uz), \nwhich contains general products and sums over the small types, and U1 itself. For those unfamiliar with \nbasic type theory, we review the notion of general sums and general products. If A is a collection (such \nas a type) and 13(z) is an expression defining a collection for each x G A, then the generaJprociuct \ntype fIz:A. B is the collection (or type) of functions ~from Ato the union Ut~,.I~Ofall~(~) such that \nfor each z c A, we have j(z) ~ B(z). For exam\u00adple, if list(t) is the type of tlists, for any small type \nt:UI, and nil(t) is the empty list of type list(t~, %en we can say that the function nil has type Ift:For \ncollection A UI.list(t).and A-indexed family of collections B(z) as above, the general sum type Du : \nA. B is the collection (or type) of pairs (a, b) such that a : A and b : l?(a). For example, Zt : UZ. \nZZst(t) is the type of pairs 1)withlist 4 belonging to type list(tt).(t?, AS explained in [Ma,c86, MH88], \nthe signatures, struc\u00adtures and functors may be regarded as syntactic sugar for general products and \nsums, and their membem. More specif\u00adically, the signature of a. Standard ML structure may be regarded \nas a general sum type, and a structure itself as an element of such a type, since a structure is essentially \na kind of tuple. Although functor signatures are omitted from Standard ML, the type of a Standard ML \nfunctor is a general product type IIz : A. B, with type A giving the type of the functor parameter and \ntype b defining the type of the resulting structure. The reason a functor does not have an ordinary function \ntype is that the t~pe of structure In our extension of Standard ML modules, we have both general sum \ntypes, as specifications of structures, and gen\u00aderal product type specifications for functors. In addition, \nwe have parameterized specifications, which actually have types of the form U2 + U2 + . . . + U2, technically \ntaking us beyond U2. produced may depend on the actucd structure parameter, as in the following example: \nfnnctor M(S : spec type t; val x : t end) : spec type s; val x : list[S.t] end One novel feature of \nour module system, in comparison with Standard ML, is an impredicative treatment of existen\u00adtial types \nand a related implicit coercion from U2 to U]. As described in [MP88], see also [CW85], existentially \nquanti\u00adfied types correspond to the programming language notion of abstract types. Like Quest [Car89], \nour existential types are impredicative, so that a specification with only abstract (or, in Ada terminology, \nprivate ) types maybe considered a U1 type instead of a Uz type. For example, the following Standard \nML specification specification S = spec type t; valx:t end would ordinarily be regarded as a general \nsum type  s ::= m:ul. t Since this type is in Uz and not UI, a fnnction such as condi\u00adtional could \nnot be applied to structures of this type. More precisely, conditional is an operation with type (in \ncurried form) 8 Conclusion We have developed an extension of Standard ML modules which incorporates subtyping, \ninheritance and a form of ob\u00adject in a uniform way. The language design has been tested by writing a \nnumber of examples, and an implementation is under development. While the language design does not solve \nall of the problems discussed in [Mit90a], for example, the current design seems practically useful, \nand more flex\u00adible in certain respects than existing typed object-oriented languages. In particular, \nthe separation of specification from implementation and the use of internal interfaces to allow ef\u00adficient, \ntype-safe implement ation of binary operations seem useful. We have found F-bounded polymorphism, ) intro\u00adduced \nin [CCH+89], to be a useful primitive, and sufficiently expressive for describing families of classes \nsatisfying cer\u00ad tain axiomatic specifications. A direction we are currently exploring is an extension \nof objects (Standard ML struc\u00ad tures) with concurrent methods. In particular, the design and use of an \nappropriate specification language seem to require some consideration. Acknowledgements: This module \ndesign is part of the design of a prototyping language and system, under development in collaboration \nwith a team lead by David Luckham (Stan\u00adford), Frank Belz (TRW), Sigurd Meldal and John Mitchell. We \nare grateful to members of this team for discussion, guid\u00ad ance and feedback. We also thank Dinesh Katiyar \nfor a number of helpful discussions and suggestions. References [BHEL86] A. Black, N. Hutchinson, E. \nJul, and H. Levy. Object structure in the Emerald system. In Pvoc. ACM Symp. on Object-Oriented Pro\u00adgramming: \nSystems, Languagesl and Appli\u00adcations, pages 78 86, October 1986. cond:IIt: U1. bool+t-+t +t. The reason \nhigher level for restricting conditional conditional would interfere to U1 typesis that with compile-time \na [BL90] F. Belz ancl D.C. Luckham. A new approach type checking by allowing, for example, type expressions \nto prototyping ada-based hardware/software such as cond (e > .5) int bool, for arbitrary integer expres\u00ad \nsystems. In Proc. ACM Tri-Ada 9o Confere\u00ad sion e. Since conditional only applies to UI arguments, we \nnce, December 1990. To appear. cannot apply cond to a structure However, if the type component is hidden, \nthen there is no problem Al : S. of some structure III: with using a conditional S [C+86] R.L. Constable \net al. Implementing Mathe\u00admatics with the Nuprl Proof Development Sys\u00adtem, volume 37 of Graduate Texts \nin Mathe\u00ad expression. including Some examples of an example choosing this are discussed between sparse \nin [M P88], and dense matics. Prentice-HaJl, 1986. matrix implementations at run time. In order to achieve \n[Car89] L. Cardelli. Typeful programming. Techni\u00ad this flexibility, we recognize that if the type component \nof cal Report, 45, DEC Systems Research Cen- M : S is to be considered abstract, then we may think of \nS ter, 1989. presented at IFIP Advanced Sem\u00ad as the existential (as opposed to general sum) type inar \non Formal Descriptions of Programming S3 ::= %:ul. t Concepts. belonging recognizes to U1 instead that \nthere is of Uz. a canonical In effect, map the typechecker [CCH+89] P. Canning, W. Cook, W. Hill, J. \nMitchell, and W. Olthoff. F-bounded quantification for object-oriented programming. In Functional hide: \nXt:U1. t-+3t:Ul. t Prog. and Computer Architecture, pages 273\u00ad 280, 1989. which does nothing but hide \n the identity of the type com\u00ad ponent of a structure by mapping a pair into a type which [CM89] L. Cardelli \nand J.C. Mitchell. Operations on does not have a first projection function. By automatically records. \nIn Math. Foundations of Prog. Lang. coercing structures from Uz to UI, we allow structures to Semantics, \n1989. To appear. Also available as be treated as first-class values, essentially losing only the DEC \nSRC Technical Report 48, August 1989, ability to test equality between type components. 60 pages. [CO089] \n[CW85] [Dij72] [GR83] [HMM86] [HMM90] [JM88] [LHM+86] [LvHKB087] [Mac85] [Mac86] [Mar84] [MH88] [Mit84] \nW.R. cook. A proposal for making Eif\u00adfel type-safe. In European Conf. on Object-Oriented Programming, \npages 57-72, 1989. L. Cardelli and P. Wegner. On understanding types, data abstraction, and polymorphism. \nComputing Szsroeys, 17(4):471-522, 1985.  E.W. Dijkstra. Notes on structured program\u00adming. In O.J. \nDahl, E.W. Dijkstra, and C.A.R. Hoare, editors, Structured Program\u00adming. Academic Press, 1972. A. Goldberg \nand D. Robson. Sm alltal&#38;80:  The language and its implementation. Addi\u00adson Wesley, 1983. R. Harper, \nD.B. MacQueen, and R. Milner. Standard ML. Technical Report ECS-LFCS\u00ad86 2, Lab. for Foundations of Computer \nSci\u00adence, University of Edinburgh, March 1986. R. Harper, J.C. Mitchell, and E. Moggi. Higher-order modules \nand the phase distinc\u00adtion. In Proc. 17-th ACM Symp. on Princi\u00adples of Programming Languages, pages 341 \n354, January 1990. L. Jategaonkar and J.C. Mitchell. ML with extended pattern matching and subtypes. \nIn Proc. ACM Symp. Lisp and Functional Pro\u00adgramming Languages, pages 198 212, July 1988. D. C. Luckham, \nD. P. Helmbold, S. Meldal, D. L. Bryan, and M. A. Haberler. Task se\u00adquencing language for specifying \ndistributed ada systems. In Lecture Notes in Com\u00adputer Science, lVumber 275, pages 249-305. Springer-Verlag, \nMay 1986. David Luckham, Friedrich W. von Henke, Bernd Krieg-Bruckner, and Olaf Owe. Anna -A Language \nfor Annotating Ada Programs. In Lecture Notes in Computer Science, Number 260. Springer-Verlag, July \n1987. D.B. MacQueen. Modules for Standard ML. Polymorphism, 2(2), 1985. 35 pages. An earlier version \nappeared in Proc. 1984 ACM Symp. on Lisp and Functional Programming. D.B. MacQueen. Using dependent \ntypes to express modular structure. In Pr-oc. 13-th ACM Symp. on Principles of Programming Languages, \npages 277-286, 1986. P. Martin-Lof. Intuitionistic Type Theory. Bibliopolis, Napoli, 1984.  J.C. Mitchell \nand R. Harper. The essence of ML. In Proc. 15-th ACM Symp. on Princi\u00adples of Programming Languc&#38;ges, \npages 28 46, January 1988. J.C. Mitchell. Coercion and type inference (summary). In Proc. 11-th ACM \nSymp. on Principles of Programming Languages, pages 175 185, January 1984.  [Mit90a] [Mit90b] [MP88] \n[MTH90] [Par72] [R6m89] [Set89] [Sny86] [ST89] [Str86] [US 80] [Wan87] J.C. Mitchell. Toward a typed \nfoundation for method specialization and inheritance. In Proc. 17-th ACM Symp. on Principles of Pro\u00adgramming \nLanguages, pages 109 124, January 1990. J.C. Mitchell. Type systems for programming languages. In J. \nvan Leeuwen, editor, Hand\u00adbook of Theoretical Computer Science. North-Holland, 1990. (To appear.). J.C. \nMitchell and G.D. Plotkin. Abstract types have existential types. ACM Trans. on Programming Languages \nand Systems, 10(3):470 502, 1988. Preliminary version ap\u00adpeared in Proc. 12-th ACM Symp. on Princi\u00adples \nof Programming Languages, 1985.  Robin Milner, Mads Tofte, and Robert Harper. The Definition of Standard \nML. MIT Press, 1990. D. Parnas. On the criteria to be used in de\u00adcomposing systems into modules. Communi\u00adcations \nof the A CM, 5(12):1053 1058, Decem\u00adber 1972. D. R&#38;my. Typechecking records and vari\u00adants in a natural \nextension of ML. In 16-th ACM Symposium on Principles of Program\u00adming Languages, pages 60 76, 1989. R. \nSethi. Programming Languages: Concepts and Constructs. Addison-Wesley, 1989. A. Snyder. Encapsulation \nand inherit ante in object-oriented programming languages. In Proc. I-st ACM Symp. on Object-Oriented \nProgramming Systems, Languages, and Appli\u00adcations, pages 38 46, October 1986. D. Sanella and A. Tarlecki. \nTowards formal development of ML programs: foundations and methodology. Technical Report ECS\u00adLFCS-89-71, \nLaboratory for Foundations of Computer Science, February 1989. B. Stroustrop. The C++ Programming Lan\u00adguage. \nAddison-Wesley#986. US Dept. of Defense. Re}erence Manual for the Ada Programming Language. GPO 008\u00ad000-00354-8, \n1980. M. Wand. Complete type inference for simple objects. In Proc. %nd IEEE Symp. on Logic in Computer \nScience, pages 37 44, 1987. Cor\u00adrigendum in Proc. .!?-rd IEEE 2ymp. oa Logic in Computer Science, page \n132, 1988. \n\t\t\t", "proc_id": "99583", "abstract": "", "authors": [{"name": "John Mitchell", "author_profile_id": "81338490160", "affiliation": "Dept. of Computer Science, Stanford University, Stanford, CA", "person_id": "PP39076064", "email_address": "", "orcid_id": ""}, {"name": "Sigurd Meldal", "author_profile_id": "81100378629", "affiliation": "Dept. of Informatics, University of Bergen, Bergen, Norway", "person_id": "PP18001444", "email_address": "", "orcid_id": ""}, {"name": "Neel Madhav", "author_profile_id": "81100467757", "affiliation": "Dept. of Computer Science, Stanford University, Stanford, CA", "person_id": "P207858", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/99583.99620", "year": "1991", "article_id": "99620", "conference": "POPL", "title": "An extension of standard ML modules with subtyping and inheritance", "url": "http://dl.acm.org/citation.cfm?id=99620"}