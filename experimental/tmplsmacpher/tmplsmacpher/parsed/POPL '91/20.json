{"article_publication_date": "01-03-1991", "fulltext": "\n PARAMETER-PASSING AND THE LAMBDA CALCULUS Erik Crank* Matthias Felleisen Department of Computer Science \nRice University Houston, TX 77251-1892 Abstract The choice of a parameter-passing technique is an important \ndecision in the design of a high-level pro\u00adgramming language. To clarify some of the seman\u00adtic aspects \nof the decision, we develop, analyze, and compare modifications of the J-calculus for the most common \nparameter-passing techniques, i.e., call-by\u00advalue and call-by-name combined with pass-by-worth and pass-by-reference, \nrespectively. More specifically, for each parameter-passing technique we provide 1. a program rewriting \nsemantics for a language with side-effects and first-class procedures based on the respective parameter-passing \ntechnique; 2. an equational theory that is derived from the re\u00adwriting semantics in a uniform manner; \n 3. a formal analysis of the correspondence between the calculus and the semantics; and 4. a strong \nnormalization theorem for the impera\u00adtive fragment of the theory (when applicable).  A comparison of \nthe various systems reveals that Al\u00adgol s call-by-name indeed satisfies the well-known ,8 rule of the \noriginal ~-calculus, but at the cost of com\u00adplicated axioms for the imperative part of the theory. *The \nauthors are supported in part by NSF and DARPA. The Instituto de Computation of the Universidad de la \nRe\u00adpublics Oriental del Uruguay generously provided facilities for preparing the final version of the \npaper. Permission to copy without fee all or part of this material is granted provided that the copies \nare not made or distributed for direct commercial advantage, the ACM copyright notice and the title of \nthe publication and its date appear, and notice is given that copying is by permission of the Association \nfnr Computing Machinery. To copy other\u00adwise , or to republish, requires a fee and/or specific permission. \n@ 1990 ACM 089791-419-8/90/0012/0233 $1.50 233 The simplest and most appealing axiom system ap\u00adpears \nto be the one for a call-by-value/pass-by-worth language with reference cells as first-class values. \n1 Parameter-Passing and Lambda Calculi The choice of a parameter-passing technique is an im\u00adportant element \nin the design of a high-level program\u00adming language. The wide variety of techniques in modern languages, \ne.g., call-by-value, call-by-name, pass-by-reference, suggests a lack of consensus about the advantages \nand disadvantages of the various tech\u00adniques. In this paper we analyze the most com\u00admon techniques by \nstudying and comparing equa\u00adtional theories for each of them. Plotkin [20] was the first to consider \nequational the\u00adories for the analysis of parameter-passing techniques. Starting from the folklore that \nChurch s A-calculus captures the essence of call-by-name in a ~rmctionai language, he developed a variant \nof the calculus, the ~.-calculus, to formalize the notion of call-by-value in a simple framework comparable \nto the ~-calculus. More importantly, he used these two examples, call\u00adby-name and call-by-value, to analyze \nthe formal re\u00adlationship between programming languages and cal\u00adculi. Both the ~-calculus and the Av-calculus \nsatisfy general correspondence conditions with respect to the appropriate semantics: (1) the calculi \nare sufficiently strong to evaluate a program to its answer and (2) they are sound in the sense that \nthe equality of terms in the calculus implies their interchangeability in all program contexts. Recently, \nFelleisen with Friedman [9] and Hieb [10] extended Plotkin s work to call-by-value program\u00adming languages \nwith imperative constructs like as\u00adsignments and jumps, Their result shows that, like functional constructs, \nimperative constructs have a simple rewriting semantics, and that there are con\u00adservative extensions \nof the Au-calculus for reasoning about them, namely the Av-{C,S,CS}-calculi. The extension of Plotkin \ns work to imperative lan\u00adguages is important because it enables us to con\u00adsider the whole spectrum of \nconventional parameter\u00adpassing techniques. Specifically, it is only through the addition of imperative \nconstructs that the design options for alternative parameter-passing techniques become interesting. Whereas \nin a functional setting the only observable differences between call-by-value and call-by-name versions \nof a program is the termi\u00adnation behavior, the two versions of the same pro\u00adgram can produce different \nresults in imperative lan\u00adguages. Moreover, in the presence of assignments, it is also possible to distinguish \nparameter-passing tech\u00adniques that bind parameters to values from those that bind parameters to references \nto values. Based on these observations, we classify parameter\u00ad passing techniques according to their \nrespective eval\u00ad uation and binding strategies. The evaluation strat\u00ad egy determines when -10 evaluate \nprocedure arguments, while the binding strategy determines what part of the argument to bind to formal \nparameters. The two prevailing evaluation strategies are eager evaluation (call-by-value), which evaluates \nthe argu\u00ad ment to a procedure call before binding the param\u00ad eter, and delayed evaluation (call-by-name), \nwhich does not evaluate the argument until the value of the parameter is needed.1 As for binding strategies, \nwe consider pass-by\u00ad worth, which binds the parameter to the value, i.e., worth, of the argument, and \npass-by-reference, which binds the parameter to a variable, i.e., a ref\u00ad erence to a value. A third strategy, \npass-by-vaJue\u00ad resuli, has properties of both pass-by-worth and pass\u00ad by-reference. In this paper, we \nanalyze the parameter-passing techniques produced by the various combinations of evaluation and binding \nstrategies. Also included is a discussion of the reference cell, a language construct that provides an \nalternative to the pass-by-reference binding technique. For each technique we develop a rewriting semantics \nand a calculus for a higher-order programming language that uses the technique. The calculi satisfy variants \nof Plotkin s correspondence criteria. In addition, their imperative fragments sat\u00ad ] Two other delayed \nevaluation strategies, which we do not consider in this paper, are call-by-text and call-by-need. Call\u00adby-text \nnever evaluates procedure arguments, thus, delaying evaluation forever. Muller [17] recently analyzed \nsome of the problems of deriving equational theories in the presence of call\u00adby-text. Call-by-need is \nan optimization of call-by-name in a functional language, but produces different answers than caU\u00adby-name \nin the presence of side-effects. The extended version of this paper [4] contains a brief discussion of \ncall-by-need. isfy strong normalization theorems and are therefore decidable. The next section of this \npaper describes in more detail the steps of the analysis: the definition of an operational semantics, \nthe derivation of an equational calculus, and the formal analysis of correspondence between the semantics \nand the calculus. Section 3 examines each of the parameter-passing techniques using the methods outlined \nin Section 2. We discuss related work and compare the different techniques in Sections 4 and 5.   2 \nFrom Operational Semantics to Calculi In our analysis of parameter-passing, there are three main steps. \nFirst, we define an operational semantics for a language with a particular parameter-passing technique. \nNext, we derive an equational calculus directly from the semantics, and finally, we analyze the correspondence \nbetween the calculus and the se\u00admantics. This section describes each of these steps in more detail. Definition \nof a Language and its Operational Semantics The definition of a language consists of two parts: the specification \nof a syntax and an operational se\u00admantics. We provide one for each of the parameter\u00adpassing techniques. \nThe core of our languages, A, consists of const ants (c), variables (z), A-abstractions and applications \nof the A-calculus: e ::= 8 Iv I(ee) v ::= c I Xr.e The languages extend A with constructs for side\u00ad effects, \nwhich we describe in later sections. Following Barendregt s [1] conventions, we assume that, in the following \ndefinitions and theorems, the bound variables are distinct from the free variables in expressions, and \nwe identify expressions that dif\u00ad fer only by a renaming of the bound variables. The expression e [z \n+-e ] denotes the expression resulting from the substitution of all free occurrences of the variable \n~ in e with the expression e . The set of free variables in an expression e is denoted by FV(e). An expression \nwith no free variables is closed. Below we need the notion of a context for several definitions. A context, \nC, is a term with a hole ([]) in the place of a subexpression; C[e] is the expression produced by replacing \nthe hole in a context C with the expression e. The operational semantics of a language is a par\u00adtial \nfunction, eval, from programs to answers. A pro\u00adgram is a closed expression; an answer is some (yet\u00adto-be-defined) \nsyntactic class of expressions (and pro\u00adgrams). The eval function is based on an abstract machine. The \nstate space of the machine is the set of programs; an evaluation step in the machine cor\u00adresponds to \nthe rewriting of an entire program: P D p . Thus, the transitive closure of the transformation function \ndefines the semantics:2 evai(p) = a iffp D* a, for program p and answer a. Every evaluation step on the \nmachine begins with partitioning the program into an evaluation context and a redex. The evaluation context \nis a special kind of context that specifies the evaluation order of subexpressions in a compound expression. \nIntu\u00aditively, the hole in an evaluation context points to the next subexpression to be evaluated. A redex \nis an expression that determines how the transforma\u00adtion function rewrites the program. For each redex \nthere is a rewriting rule that specifies how to trans\u00adform a program that contains the redex in the hole \nof an evaluation context into a new program. The union of these rewriting rules defines the machine transfor\u00admat \nion function. Although we vary the evaluation and binding strategies for user defined procedures below, \nwe as\u00adsume that primitives have a fixed interpretation. Specifically, we assume that primitives are strict \nand that they only accept proper values. The set of values ( Vaiues) consists of constants and ~\u00adabstractions. \nTo avoid an overspecification of these constants ( Consts), we only require the existence of a partial \nfunction, 6, from functional constants (l?Consts) and closed values to closed values. We restrict 6 so \nthat functional constants cannot distin\u00adguish the intensional aspects of A-abstractions. That is, if \n6(~, v) is defined for some A-abstraction v, then there exists a context C[ ] such that C[v] is a value \nand for all A-abstractions v , 6(~, v ) s C[v ]. This re\u00adstriction on functional constants is reasonable \nin the context of most programming languages. Essentially, it prohibits from the language only those \nprimitive functions that can examine the text of procedure bod\u00adies. But, the restriction still permits \nfunctions that can distinguish constants from procedures (e.g., pred\u00adicates such as int? and proc?) or \nthat can build larger 2 This ~hwacterization is too simple. For charity, we omit the added complications \nthat are described in the next section. values composed of procedures (e.g., arrays or lists of procedures). \nObservational Equality and Calculi Since an implementation of a language generally pro\u00advides the programmer \nwith nothing but the eval\u00aduation function, the programmer can only observe the behavior of expressions \nwhen they are a part of the program. This fact induces a natural notion of equivalence for arbitrary \nphrases of a program\u00adming language. Intuitively, two terms are observa\u00adtionally equivalent if they are \ninterchangeable in all programs without affecting the observable behavior of the programs.3 Two programs \nhave the same observ\u00adable behavior if either they both diverge or they both converge, and if one evaluates \nto a basic constant then the other evaluates to the same constant. Definition 2.1. (Observational Equality) \nTwo terms are observationally equivalent, e ~ e , if for all contexts C such that both C[e] and C[e ] \nare pro\u00adgrams, 1. eval(C[e]) is defined iff eval(C[e ]) is defined, and 2. eva/(C[e]) is a basic constant \niff evai(C[e ]) is the same constant.  Proving the observational equivalence of two terms is a difficult \ntask. A proof must show that for all program contexts, the two terms are interchangeable without affecting \nthe program behavior. For this rea\u00adson, programming language research attempts to con\u00adstruct theories \nfor proving observational equivalences in an axiomatic fashion. Such theories are often re\u00adferred to \nas calculi in analogy to the J-calculus. In the following sections, we will attempt to de\u00adrive an equational \ntheory from the operational se\u00admantics of each parameter-passing technique. The most straightforward \nattempt is to make the trans\u00adformation steps for programs into equational axioms for arbitrary terms. \nDefinition 2.2. (Natural Calculus) The relation = is the least congruence relation generated by the transformation \nfunction D, extended to arbitrary ex\u00ad 3 For hi~toric~ re~ons, some authors Cd t~s relation op\u00ad eTational \nequivalence. To avoid confusion, we use the term observational because the relation is based upon observable \ncharacteristics, independent of an operational semantics. pressions: 3 Equational Theories of Para\u00ad \nelbe2 + el=e2 (Axioms) el = ez +-C[el] = C [e2] (Compatible) el = el (Reflexive) el=ez * ez=e~ (Symmetric) \nel =ez,ez =e3 * el=e3 (Transitive) For a specific theory th, we write th 1-el = ez if el = e2 by the \nabove axioms and rules. If el = ez without use of the symmetry axiom, we also write el -e2 and refer \nto the relation as a reduction. The Analysis of Calculi Given a semantics, its observational equivalence \nrela\u00adtion and a calculus, it is natural to ask how the latter relates to the former. Plotkin [20] gave \ntwo criteria for correspondence between a calculus and a seman\u00adtics. First, the calculus must be capable \nof evaluating programs. In particular, if the semantics defines the meaning of a program e to be a, then \nthe two should be provably equivalent in the calculus. Similarly, if the calculus proves that a program \nis equivalent to an answer, then the meaning of the program must be defined by the semantics. Second, \nthe calculus must be sound with respect to the observational equiva\u00adlence relation: If two terms are \nequal in the calculus, they must be observationally equivalent with respect to eva~. Definition 2.3. \n( Correspondence) A theory th cor\u00adresponds to a semantics eval: th &#38; Corr(eva/), if the following \nconditions hold: 1. th is adequate: (a) if evai(e) = u, then th 1-e = a, (b) if th t-e = a, where a \nis an answer, then evat(e) is defined,  2. th is sound with respect to H: th 1-el = ez implies el &#38; \ne2 A secondary question about a calculus is whether it is decidable. Although our calculi are not decid\u00adable, \nin most cases the imperative fragment of the languages has a decidable subtheory. For these cases we \nshow that there is a strongly normalizing notion of reduction that corresponds to the subtheory. We write \nr ~ SN, if the notion of reduction r is strongly normalizing. meter-Passing Techniques 3.1 Call-by-value/ \nPass-by-worth Many common programming languages, e.g., C, ML, Pascal and Scheme, employ the calLby-vaiue/pass\u00ad \nby-worth parameter-passing technique. In these lan\u00adguages, a procedure application evaluates the argu\u00adment \nexpression before binding the formal parameter to the value of the argument. In this section, we present \na calLby-value/pass-by-worth language with assignment, derive a calculus for reasoning about the language, \nand show that it corresponds to the seman\u00adtics. Both the language and calculus are variations on the \nwork by Felleisen and Hieb [10]. The call-by-value term language, Idealized Scheme or ISU, extends A \nwith two new expressions. First, there is an assignment statement, (set! z e), which assigns to the variable \nx the value of the expression e. The result of an assignment expression is the value that is assigned \nto the variable. Second, there is a p\u00adexpression, which is similar to a block in Algol and the letrec \nexpression in Scheme. It contains a sequence of variable-value pairs and a sub-expression. The p\u00adexpression \nestablishes mutually recursive bindings of the variables to their associated values and returns the value \nof the sub-expression. The term language 1S. is given in the first part of Figure 1. There are two basic \ndifferences between this lan\u00ad guage and the language of Felleisen and Hieb [10]. First, we use the assignment \nstatement set! instead of the sigma capability. Although the sigma capabil\u00ad it y is a powerful programming \nconstruct, most lan\u00ad guages implement weaker constructs such as the set! expression. Second, like in \nScheme, all variables are assignable, that is, they may occur in the variable po\u00ad sition of a set! expression. \nTherefore, unlike in the Au-calculus [20] and the J.-S-calculus [10], variables in our language are expressions, \nnot values.4 In addition to adopting Barendregt s conventions for free and bound variables, we identify \np-lists that differ only by the ordering of their pairs: (Z,, vl)...(%, %) = (%,, %l). ..(zin, vin), \nfor all permutations i~, ....&#38; of 1, ....n. 4 Although variables are values in the ~~-calculus, the \nad\u00addition of an assignment statement to the language requires that assignable variables not be values. \nFelleisen et al [9, 10] conservatively extend the ,)0-calculus by enlarging the set of variables with \na set of assignable variables. The original unassignable variables of the Au-calculus are values, whereas \nthe additional assignable variables are not. Since this property is highly context-sensitive and possibly \ndifficult to determine by a programmer, we abandon this distinction. Syntax, 1S.: e ::= v I z I (e e) \nI (set! z e) I pf3.e (Expressions) x e Vars !.= c I kz. e (Values) cc Con$ts ; ::= E I o(z, v), where \n(z, v ) @ 8 (p-lists) f e FConsts .. a ,# ?J I po.v (Answers) Evaluation Contexts < Ev ::= [] I(v Ea) \nI(Ev e) I(set! zJ!%) Transformation Function: Pe..l% [f V] p8.EU[(kr.e)v] pO.EV[(Az.e)v] pe u {( Z, V)}.EV[Z] \nPOU {(z, u)}. Eti[(set! z u)] pO.EV[p#.e]  Semantics: evalVW(e) = a, if p@. e b~w pd. v, and a is the \ngc-normal form of P8. v. Figure 1: Call-by-value/Pass-by-worth Language Put differently, we treat p-lists \nas sets of pairs and in lations: some circumstances as finite functions. Accordingly, pL90U (?l.e + p191.e \nwe refer to a p-list as a p-set and use standard set if00# 0 and operations on these sets. F V(pOl.e) \n(l Dorn(Oo) = 0 The set of assigned variables in an expression e, pO.e+ e denoted AV(e), is the set \nof free variables in e that occur in the variable position of a set! expression. It is easy to verify \nthat the notion of reduction gc is strongly normalizing and Church-Rosser. Therefore, all expressions \nin ISV have a unique ge-normal form Semantics (gc-nf). Furthermore, the gc-nf of an answer is also an \nanswer. The semantics of the call-by-value/pass-by-worth lan-The program transformation function, BVW, \nand guage is the partial function, evaio ~, from programs the semantics, evaivw, for the call-by-value/pass-by\u00adto \nanswers, where an answer is either a value, or a worth language, are defined in the second part of Fig\u00adp-expression \nwhose body is a value. As discussed in ure 1. The first two rules, E.6 and E.&#38;, provide the the previous \nsection, the program rewriting function call-by-value semantics for A; the others specify the first partitions \na program into an evaluation context effects of imperative constructs. and a redex and then transforms \nit to a new program. A ca!l-by-value evaluation context specifies the eager Calculus evaluation strategy: \nWe derive an equational theory, AU-W or the Av- E. ::= [] I (v EV) I (EV e) I (set! z E.) W-calculus, \nfor the call-by-value/pass-by-worth lan\u00ad guage by generating an equivalence relation, =.W, The call-by-value/pass-by-worth \nlanguage redexes based upon the compatible closure of the program are the following expressions: ~v, \n(Xz.e)w, z, transformation function and the notion of reduction (set! z v), and pO.e. gc. We write AU-W \n1-el = ez if el =OW ez. The The machine rewrites the program until it produces J.-W-calculus corresponds \nto the semantics evaluw. an answer and then removes all unneeded p-bindings Theorem 3.1 AU-W ~ Corr(evalvW). \nby applying garbage collection reductions to the answer. More technically, the garbage collect ion no-Proof. \nAdequacy follows from the fact that ~~~ and tion of reduction gc is the union of the following re-gc \nare subsets of =,W. For soundness, we derive a notion of reduction vw from bv~ and gc. The re\u00adduction \nsatisfies Church-Rosser and Curry-Feys Stan\u00addardization lemmas that imply the soundness of the calculus. \nOtherwise, the proof is an adaptation of the proofs for the calculi of Plotkin [20] and Felleisen et \nal [9, 10]. For details, we refer the reader to the extended re\u00adport [4]. # Finally, we examine the question \nof whether there are decidable subsets of the calculus. In our case, the imperative subtheory pu, that \nis, the theory based upon the transition relations that do not deal with procedure applications, is decidable. \nSpecifically, the notion of reduction consisting of these relations is strongly normalizing. This is \na new result, which does not hold for the imperative fragment of the AU\u00adS-calculus. It is motivated by \nthe completeness the\u00adorem for a non-recursive fragment of first-order Lisp by Mason and Talcott [16]. \nTheorem 3.2 Let 6. be the modi$cation of the rela\u00ad tion E.6 as follows: (~ v) + ti(f, v), where 6(f, \nv) G Consts (tic) Lets =6CUDVUaVUpu Ugc. Then, s#SN. Proof. The proof uses a size argument. We define \na potential function, P : Expressions + N x N, such that P(e) > P(e ), by lexicographical ordering, if \ne --+8 et. The naive approaches to defining a size function fail, because certain reductions increase \nthe size of the term and the number of redexes in the term. For example, the following reduction increases \nthe size of the term and the number of redexes be\u00adcause the subexpression e is replicated: P{(z, Az.e)}.E[z] \n-, P{(x, Xu.e)}.E[A~.e] Therefore, the function P not only counts the number of redexes in a term, but \nalso takes into account po\u00adtential redexes that may be introduced in reductions such as this. Again, \nthe details can be found in the extended report [4]. m  3.2 Call-by -value/Pass-by-reference Pascal, \nFortran and other languages allow pass-by\u00adreference procedure parameters in addition to pass\u00adby-worth \nparameters. Generally, these languages re\u00adquire that the actual argument for a pass-by-reference parameter \nbe a variable. A procedure application binds the parameter to the variable so that during the evaluation \nof the procedure body, references and assignments to the formal parameter are equivalent to references \nand assignments to the actual argu\u00adment. Our semantics generalizes pass-by-reference and allows arbitrary \nexpressions as arguments to pro\u00adcedures. If the argument is not a variable, the trans\u00adformation function \nevaluates the argument until it becomes a variable before the procedure call. If the argument does not \nevaluate to a variable, then the meaning of the program is undefined. Semantics The term language for \nthe pass-by-reference seman\u00adtics is 1S., except that we interpret k .e as a pass\u00adby-reference procedure. \nTwo changes to the pass-by\u00adworth program transformation function in Figure are necessary to obtain the \ntransformation function for the pass-by-reference semantics: When a variable occurs as an argument to \na A-Abstraction, the transition function substitutes the argument variable for the bound variable within \nthe body of a A-abstraction: pO.Ev[(Az.e)y] > pO.EV[e[z + y]] (E.&#38;)  The transition function does \nnot dereference a variable when it occurs as an argument to a lambda abstraction:  f~.-EO [z] b p6.EV \n[v] (E. D:) if O(Z) = v, and E. # E; [( Jy.e)[ 11 The pass-by-reference transformation function, D,,, \nis the union of the two new rules and previously de\u00adfined rules in Figure 1: Pu, = E.6 UE.@, UE.Dj UCvUp~ \n The semantic function evalV, and observational equivalence relation rxu~ are defined in the usual way. \nCalculus The first difference between the by-value and by\u00adreference parameter passing systems is that \nthe nat\u00adural derivation of the calculus from the semantics (as specified in Section 2) results in an \nunsound theory. Specifically, the variable dereference relation E.Dj is an unsound axiom with respect \nto the observational equivalence relation. However, since this is only the case when the variable occurs \nin the empty context, adding a restriction solves the problem: p8.EV [z] = p6.EV [v] (D:) ifO(Z) =v, \n-EV # E~[(Ju.e)[ 11, and EV #[] With this axiom replacing E.D~, the derivation of the AV-R-calculus \nproceeds as usual by constructing the appropriate equivalence relation from the modi\u00adfied transformation \nfunction and the notion of reduc\u00adtion gc. Because of the soundness problem encountered wit h the E ..D~ \nrule, the calculus does not exactly cor\u00adrespond to the semantics by Plotkin s criteria. The condition \non the D~ reduction relation restricts the ability of the calculus to evaluate programs, i.e., the calculus \ncan only evaluate the programs to an expres\u00adsion that is one step away from the answer by the program \ntransformation function. Based on this ob\u00adservation, we prove the following weak correspondence theorem.5 \nTheorem 3.3 The AU-n-calculus weakly corre\u00ad sponds to the calLby-value/pa ss-by-reference seman\u00ad tics \nof 1S., AV -R ~ WCorr(evalVr). In particular, 1. A.-R is almost adequate: ( a) if eval.r(e) = a then \neither AV-Rte=a, or e Av-lll-e=pOU{(z, v)}.z and AO-RF p6 U {(z, w)}.v = a. (b) if AV -R F e = a, then \nevalVr(e) is defined. l?. AU-R is sound with respect to ZUv: AV -R f-el = e2 implies el ZUr ez The \nimperative fragment of the pass-by-reference calculus, p;, as well as its procedure call reduction, ,&#38;, \nare strongly normalizing for the full language. Theorem 3.4 Let s = 6CU D; U aV U pU U gc. Then, s ~ \nSN and ~r ~SN. 3.3 Call-by-value-result The programming languages Ada [23] and Algol W [24] specify \na parameter-passing technique known as ca!!-by-value-result, or copy-in/copy-out.6 This parameter-passing \ntechnique uses the eager evalua\u00adtion strategy and is similar to both the pass-by-worth 5An alternative \nto formulating a weak correspondence re\u00adlationship would be to redefine the semantics to correspond to \nthe calculus. In particular, if we treat the expression pb .x as an answer in the semantics, then the \ncalculus satisfies the correspondence criteria. However, existing programmi ng lan\u00adguages do not use \nthis notion of call-by-valuelpass-by-reference semantics. 6 Tec~callY, the tem ~~c~-bY-value/pass-by-value-res~t \nis the name consistent with our terminology. We use the more popular name call-b y-value-result for simplicity. \nand pass-by-reference binding techniques. Like pass\u00adby-reference, arguments to procedures must be vari\u00adables. \nLike pass-by-worth, the procedure applications bind the formal parameter to the value of the argu\u00adment \nvariable. However, after evaluation of the pro\u00adcedure body, the argument variable receives the value \nof the formal parameter. Semantics The sequential nature of the call-by-value-result pro\u00adtocol requires \nthe specification of a sequence state\u00adment for 1S., (e; e), and an appropriate extension of evaluation \ncontexts: Ev::= ... I (EV; e). The expression (el; ez; . ..en) abbreviates (el; (ez; . . . en)). The \nsemantics of the sequence ex\u00adpression is straightforward; the left sub-expression is evaluated first, \nfollowed by the right: pO.EV [(v; e)] D pt3.EU [e] (E.seq) A procedure application requires four steps. \nFirst, the application binds the procedure parameter to the value of its argument. Second, evaluation \ncent inues with the procedure body. Third, the value bound to the parameter is copied back to the argument, \nFinally, the result of the application is the value ob\u00adtained from evaluation of the procedure body. \nWe use the sequence expression to specify this series of events: pO.Ev [(kc.e)y] D (E.&#38;) pd. EV[p{(z, \nA%.x), (r, Az.z)}. ((set! z y); (set! r e); (set! y z); r)] The variable r is a new variable that holds \nthe return value oft he procedure. The value h.3 is an arbitrary initial value. The complete rewriting \nfunction relies on these and previously defined rules: D,C = E.c$ UE./?c UE.D~ U a. Upu U E.seq As usual, \nthe transitive closure of D.= and the notion of reduction gc determine evalcc, Calculus The equational \ncalculus for the call-by-value-result language closely resembles the A.-R-calculus for the call-by-value/pass-by-reference \nlanguage. The prob\u00adlems encountered with the dereference axiom in the previous section also occur with \nthe call-by-value\u00adresult calculus. The same D; axiom solves the prob\u00adlem. The call-by-value-result calculus \nonly weakly corresponds to the semantics in the same way as the call-by-value/p ass-by-reference calculus. \nTheorem 3.5 &#38; -VR ~ WCorr(evaZCC) The imperative fragment of this calculus extends the imperative \nfragment of the call-by-value/pass-by\u00adreference calculus with the seq reduction. With this addition, \nthe Strong Normalization Theorem for the notion of reduction s also holds for s U seq. 3.4 Call-by-name/Pass-by-reference \nThe Revised Report on Algol 60 [18] informally defined the semantics of call-by-name parameter\u00adpassing \nwith the copy rule. The intention was to implement Church s [3] /3 relation from the original %-calculus \nas the parameter-passing technique of the new language. Copying an argument to every param\u00adeter occurrence \nwas thought to be the computational equivalent to function evaluation in ordinary mathe\u00admatics. A hidden \nmotive may have been the desire to perceive Algol as an extension of the A-calculus as a language as \nwell as an equational theory. The requirements of the copy rule imply a pass-by\u00adreference semantics. \nIf the formal parameter is as\u00adsigned, then the procedure argument should evaluate to a variable. Assignments \nto the parameter become assignments to this variable argument, and these ef\u00adfects on the argument will \nbe visible in the context of the procedure application. Semantics The term language for the call-by-name/pass-by\u00ad \nreference language, 1S., differs from ISO in two ways. First, to exploit the freedom of the delayed evaluation \nstrategy, p-expressions can bind variables to arbitrary expressions: Second, since the copy rule substitutes \nexpressions for free variables, the language must permit expressions to occur in any position where variables \nare allowed. In particular, we extend the syntax of ]Sn to allow expressions in the variable position \nof set! expres\u00adsions: (set ! e e) replaces (set! z e) in the definition of the term language, The rest \nof lSn is the same as ISO, with kc.e representing a call-by-name/pass-by\u00adreference procedure. The call-by-name \nevaluation contexts specify the delayed evaluation strategy. Since the context (Axe) E specifies the \nevaluation of procedure argu\u00adments prior to the procedure call, it cannot be an evaluation context for \nthe delayed evaluation strat\u00ad egy.on theotherhand, the application of functional constants remains strict. \nThe definitions of the evalu\u00adation contexts and the program transformation func\u00adtion are given in Figure \n2. Remark. Although some of the relations in Figure have the same names as relations introduced for the \ncall-by-value language, there are differences due to change in the definition of evaluation contexts. \nRe\u00adlations with the same name share reduction schema. The textual context will disambiguate all uses \nof these names. End. The transformation function uses only the E.,B rule for defining the behavior of \nall procedure applications. The restriction on the E.Dn rule is necessary to dis\u00adallow dereference of \na variable when it occurs in the variable position of an assignment, The semantics eual ~, is determined \nby the transitive closure of Dnr and gc as in previous sections. Calculus The derivation of a calculus \nfrom the semantics fol\u00adlows the same course as the call-by-value/pass-by\u00adreference language, but the \nnatural approach results in an unsound system. Again, the dereferencing rule causes the problem. Adding \nan appropriate condition to the dereference rule solves the problem: p6.En [x] + pd.En [e] (D.) if6(z) \n=e, En # E~[(set! [ ] e )], and En #[] We then derive the calculus by constructing the ap\u00adpropriate \nequivalence relation from a modified trans\u00adformation function in which D. replaces E.Dn. The call-by-name/pass-by-reference \nand call-by\u00ad value/pass-by-reference languages have several sim\u00adilarities. Both require a modified dereference \nrule to prohibit variable dereference in certain positions. Similarly, the direct derivation of a calculus \nfrom the semantics results in an unsound system. Not surpris\u00adingly, as with the ~V-R-calculus, the An-R-calculus \nonly weakly corresponds to the semant its. How\u00adever, this weak correspondence is even weaker than for \nthe call-by-value language. The remon is that while neither calculus can perform a variable derefer\u00adence \nin an empty context, this kind of dereference in Ew ::= [] I(f En) I(En e) I(set! x En) I(set! En e) \n/JO.EJfv] pO.En[(Az.e)e ] @ U {(x, e)}. E~[z] ,06 U {(x, e)}. -%[(set! z v)] p(?.E~[pO .e] bm b~, t%, \nb~, b~~ P@.En[6($, v)] p8.E~[e[z +-e ]] ,08 U {(z, e)}. E~[e], PO U {(z, v)}. J%[v] PO UO .E~[e] if En \n# E~[(set! [ ] e )] (E.6) (E.@ (E. D.) (an) (Al) Figure 2: Call-by-name/Pass-by-reference Semantics \nthe call-by-value language would return a value and thus an answer, whereas in the call-by-name language \nit does not. As a result, the AV-R-calculus can evalu\u00adate programs to expressions that are just one trans\u00adformation \nstep from an answer, but the J.-R-calculus requires an arbitrary number of these transformation steps \nthroughout the derivation.7 Theorem 3.6 The An-R-calculus only very weakly corresponds to the ca!l-by-name/pa \nss-by-reference se\u00admantics of ISn, evalnr. In particular, 1. An-R is weakly adequate: (a,) if evalnr(e) \n= a then either An-R 1-e = a, or there exists an m such that for all n between 0 and m: An-R 1-e = pdl \nU {(xl, e~)}.zl An-R i-pen U {(%n,e~)}.e~ = P6 n+I u {( Zn+I, e~+l)}.~n+l A.-R 1-p~~ U {(z~,e~)}.e~ = \na (b) if An-R 1-e = a, then evalnr(e) is defined; and g. An-R is sound with respect to Znr: A.-R F el \n= e2 implies el ~nr e2. Because p-sets may have recursive references, the imperative subtheory, pn, \nis not decidable on the full language LSn. For example, there are infinite reduc\u00ad tion sequences in pn \nfor the diverging IS. program P{(z, z)} .z. On the other hand, pn is strongly nor\u00ad malizing over the \nsubset of lSn in which the ranges of all p-sets are in Values. Theorem 3.7 The notion of reduction s. \n= 6. U D: U u. U pu U gc is strongly normalizing over the subset of ISn in which the ranges of p-sets \nare re\u00adstricted to values. TA~ above, &#38;=ging the semantics would fix the problem! too: this time \nthunks would have to be valid answers. But again, existing languages are strict at the top level. Finally, \nas intended by the designers of Algol, the An\u00ad R-calculus is indeed a conservative extension of the A-calculus. \n Theorem 3.8 A = An-RIA Proof. Clearly, any proof in A is also a proof in A.-R. On the other hand, a \nproof in &#38;-R may use axioms that are not in A. In this case, the Church-Rosser property ensures that \ntwo equivalent expressions re\u00ad duce to a third expression. These reductions must only use the ~ and 6 \naxioms of the A-calculus since the expressions are in A. I 3.5 Call-by-value/Pass-by-worth: Reference \nCells as Values The motivation for the pass-by-reference parameter\u00adpassing technique is the need to affect \nargument vari\u00adables. To accomplish this, the pass-by-reference pass\u00ading technique binds the formal parameter \nto the ar\u00adgument variable so that assignments to the param\u00adeter become assignments to the argument. Lan\u00adguages \nsuch as C, ML and Scheme do not use pass\u00adby-reference, but instead have a new class of values, namely, \npointers, reference cells or boxes that can achieve a similar result. A reference cell is a language \nobject that refers to a value. A dereference expression returns the value to which a cell refers; an \nassignment expression changes this value. When a cell occurs as the argument to a procedure, the application \nbinds the formal parameter to the cell because a cell is a value. In this way, an assignment to the formal \npa\u00adrameter becomes visible in the context of the proce\u00addure application, as in pass-by-reference. Although \nthe reference cell concept is not a proper parameter\u00adpassing technique, we consider it here because of \nits relation to both pass-by-worth and pass-by-reference parameter-passing. Syntax, 1.$,: e ::= v I \n(e e) I pO.e (Expressions) b G Boxes v ::= c I b I z I Xz. e I box I setbox! I unbox I (setbox! ZI) (Values) \n6 ::= c I @(b, o), where (b, v ) @ 0 (p-lists) Semantics: E::=[]l (v E) I (E e) p6.E[f v] b b. pO. E[&#38;(f, \nv)] if ~(~, v) defined. (E.8) pO.E[(kc.e)v] b b. pO.E[e[z + u]] (E.~ti) ,06.E[box v] k b. pO.E[p{(b, \nv)}.b] (E.boz) pf9 u {(b, v)}. E[unbox b] ~ b. p6 U {(b, v)}. E[?J] (&#38;) p8 U {(b, u)}. E[(setbox! \nb)v] b b. ,06 U {(b, v)}. E[tJ] (ISb) @ .E[p@ .e] b b. PO U #.E[e] (Pu) Figure 3: Reference Cell Language \nSemantics we abandon the assignment of ISV in favor of the ref\u00aderence cell assignment expression. Since \nvariables are no longer assignable, we treat them as values. The term language ISb extends the language \nof the ~V\u00adcalculus with the p-expression, a set of reference cells and expressions for creating, assigning \nand derefer\u00adencing cells. Adopting Chez Scheme terminology [7], we use the primitives box, setbox!, and \nunbox to perform these operations in IS6. The first part of Fig\u00adure 3 contains the specification of the \nterm language ISb. As usual, both A-abstractions and p-expressions are binding expressions, but while \n~ binds variables, p binds reference cells. There is also a notion of free cells analogous to free variables. \nThe evaluation contexts and the transformation function are also defined in Figure 3. As usual, the transitive \nclosure of the transformation function and the garbage collection reductions define the seman\u00adtics, eoalb~. \nThe notion of reduction gc is slightly different in this setting because it uses the notion of free cells \ninstead of free variables to determine the unneeded items in psets, calculus We derive the Au-B-calculus \nfor reasoning with refer\u00adence cells directly from the semantics by generating an equivalence relation \nfrom the transformation func\u00adtion and the garbage collection reduction as in previ\u00adous sections. The \nresulting theory, AU-B, corresponds to the semantics, eva~b~: Theorem 3.9 A. -B ~ corr(e~a~bfl) Furthermore, \nthe imperative fragment of this calcu\u00adlus, Pb, is decidable: Theorem 3.1O Let sb = 6~U~6U~bU@Ugc. Then, \ns~ 1= SN. Finally, the A.-B-calculus is a conservative extension of the Au-calculus. Thus, the equivalence \nproofs from the AV-calculus also hold in the ~V-B-calculus. Theorem 3.11 Au = AV-BIA The reference cell \nis interesting because of its re\u00adlation to both pass-by-worth and pass-by-reference languages. The connection \nto the pass-by-worth lan\u00adguage is apparent: the reference cell language em\u00adploys call-by-value/pass-by-worth \nparameter passing, and box assignments in ISb are similar to variable as\u00adsignments in ISV. In fact, it \nis possible to show that ISb and 1S. are equivalent in the formal sense of pro\u00adgramming language expressiveness \n[8]. For the pass\u00adby-reference language, the connection is not as clear, and we have no formal expressibility \nresults. How\u00adever, reference cells in the pass-by-worth language provide the ability to abstract over \nassignments to formal arguments (cells in this case), which was the original mot ivat ion for pass-by-reference, \nThe reason is that cells are values and can be passed as argu\u00adments, whereas variables in lSO are not \nvalues and are dereferenced when they occur as arguments in the pass-by-worth semantics. The pass-by-reference \nsemantics provides an alternative: it passes only vari\u00adables and does not allow dereferencing variables \nwhen they occur as arguments. Reference cells in a call-by\u00advalue/pass-by-worth language provide both \noptions within the same, simple language. , Evaluation , Binding Corres- Beta Axiom Decidable Strategy \nStrategy pondence Param Arg Fragment call-by-value worth exact p. non-assign ~~ value p. reference weak \nb, any variable P:; A value-result weak b. - - , p~Useq call-by-name reference very weak /3 any  any \nrestricted pn call-by-value &#38; reference cells exact P. any value @ Table 1: Summary  Related Work \nOur equational systems were motivated by the work of Plotkin [20], who studied equational reasoning sys\u00adtems \nfor call-by-name and call-by-value in functional languages, and Felleisen et al [9, 10] who developed \ncalculi for call-by-value imperative languages. Demers and Donahue [5] give an equational logic for reasoning \nabout a higher-order language that uses call-by-value parameter-passing and has memory objects similar \nto reference cells. The equational theory cent ains sev\u00aderal dozen axioms for which they present no formal \nresults. Mason and Talcot t [16] present a conditional deduction system for observational equivalences \nof Lisp expressions with side-effects, a language similar to the imperative fragment of our reference \ncell lan\u00adguage. Their logic is complete for the recursion-free, first-order fragment of Lisp with side-effects. \nIn the area of denotational semantics, several au\u00adthors [11, 22] have given denotational descriptions \nof the different parameter-passing techniques. Such de\u00adscriptions specify precise set-theoretic interpretations \nof parameter-passing but do not provide an intuitive and simple set of equations nor other axiomatic \nthe\u00ad ories. Finally, a number of researchers have studied parameter-passing in the context of Hoare-like \nax\u00adiomat ic semantics [14, 12, 6], These syst ems are gen\u00aderally for first-order subsets of Pascal and \nhave a num\u00adber of restrictions on procedure calls, such as alias\u00ading. Cartwright and Oppen [2] overcome \nthe aliasing restriction, but still do not allow procedures as ar\u00adguments. Olderog [19] eliminates the \nrestrictions on procedures, but his Hoare-like calculi explicitly re\u00adquire operational specifications \nof procedure calls us\u00ading the copy rule. Conclusions For several common parameter-passing techniques \nwe presented a program rewriting semantics and de\u00ad rived a corresponding calculus, The calculi of pass\u00adby-value \nlanguages are simply the equational theo\u00adries over the rewriting semantics but the calculi for pass-by-reference \nlanguages are weaker. In the latter cases, the rewriting rule for dereferencing variables is not sound \nwith respect to observational equivalence. As a result, the correspondence between the calculi and the \nsemantics is weaker for pass-by-reference lan\u00adguages than for pass-by-value languages. All of the calculi \nare sound but the calculi for pass-b y-reference are too weak to serve as a substitute for an evaluator. \nThe underlying reduction systems of the calculi are always Church-Rosser and have the standard reduc\u00ad \ntion property. Finally, the imperative fragments of most calculi are strongly normalizing and therefore \ndecidable. Table 1 summarizes our results, The Correspon\u00addence column refers to how closely a calculus \ncorre\u00adsponds to the semantics. The necessary modifications to the familiar @ axiom are shown under the \nBeta Axiom heading. The I aram and Arg columns show the restrictions on the formal parameter and on the \nargument in procedure applications. The entry non\u00adassign indicates that the rule only applies to applica\u00adtions \nin which the formal parameter is not assigned in the procedure body. The last column indicates which \nfragments are strongly normalizing. A comparison of the calculi reveals some aspects of the relative \nsemantic complexity of the parameter\u00adpassing techniques. Although this study verifies the folklore that \nAlgol s call-by-name/pass-by-reference parameter-passing technique satisfies the full ,8 ax\u00adiom, it also \nreveals that this comes at the expense of a weak correspondence relationship and of strange restrictions \non the axioms for the imperative frag\u00adment of the language. Indeed, call-by-value/pass-by\u00adreference as \nwell as copy-in-copy-out share these prob\u00adlems. Of the two remaining combinations, call-by\u00advalue/pass-by-worth \nwith boxes has the better char\u00adacteristics: 1. the calculus is the equational closure of a reduc\u00adtion \nsemantics; 2. because of (l), there is a strong correspondence between the semantics and the calculus; \n 3. the axioms are simple, without complicated re\u00adstrictions; 4. and the calculus is a conservative \nextension of the functional core language.  Because of the above properties, using call-by-value with \nboxes and reasoning about programs in such lan\u00adguage seems the most attractive choice. Acknowledgement. \nWe thank Amr Sabry and Re\u00adbecca Selke for comments on an early draft. References 1.BARENDREGT, H.P. \nThe Lambda Calculus: Its Syntax and Semantics. Revised Edition. Studies in Logic and the Foundations \nof Mathematics 103. North-Holland, Amsterdam, 1984. 2. CARTWRIGHT, R. AND D. OPPEN. The logic of aliasing. \nActs Inf. 15, 1981, 365 384. 3. CHURCH, A. The Calculi of Lambda-Conversion. Princeton University Press, \nPrinceton, 1941.  4. CRANK, E. Parameter-passing and the lambda\u00adcalculus. Master s Thesis, Rice University, \nAu\u00adgust 1990. 5. DEMERS, A. AND J. DONAHUE. Making vari\u00adables abstract: an equational theory for Russell. \nIn Proc. 10th ACM Symposium on Principles of Programming Languages, 1983, 59-72. 6. DONAHUE, J.E. Complementary \nDefinitions of Programming Language Semantics. Lecture Notes in Computer Science 42, Springer-Verlag, \nHeidelberg, 1980. 7. DYBVIG, R. K. The Scheme Programming Lan\u00adguage, Prentice-Hall, Englewood Cliffs, \nNew Jer\u00adsey, 1987. 8. FELLEESEN, M. On the expressive power of programming languages. In Proc. 1990 \nEuro. pean Symposium on Programming. Neil Jones, Ed. Lecture Notes in Computer Science, 432. Springer \nVerlag, Berlin, 1990, 134-151. 9. FELLEISEN, M. AND D.P. FRIEDMAN. A syn\u00adtactic theory of sequential \nstate. Theor. Comput. Sci. 69(3), 1989, 243 287. Preliminary version in: Proc. l~th ACM Symposium on \nPrinciples of Programming Languages, 1987, 314-325.  10. FELLEISEN, M. AND R. HIEB. The revised re\u00adport \non the syntactic theories of sequential control and state. Technical Report 100, Rice University, June \n1989. 11. GORDON, M.J. The Denotational Description of Programming Languages, Springer-Verlag, New York, \n1979. 12. GRIES, D. AND G. LEVIN. Assignment and Pro\u00adcedure Call Proof Rules. ACM Trans. Program. Lang. \nSyst. 2(4), 1980, 564-579. 13. HO ARE, C. A. R. An axiomatic basis for com\u00adputer programming. Commun. \nACM 12, 1969, 576-580. 14. HOARE, C .A .R. Procedures and parameters: An axiomatic approach. In Symposium \non Semantics of Algorithmic Languages, E. Engeler (Ed.). Lec\u00adture Notes in Mathematics 188. Springer-Verlag, \nBerlin, 1971, 102 116. 15. LAND IN, P .J. The next 700 programming lan\u00adguages. Commun. ACM 9(3), 1966, \n157-166. 16. MASON, I.A. AND C. TALCOTT. A sound and complete axiomatization of operational equiva\u00adlence \nbetween programs with memory. In Proc. Symposium on Logic in Computer Science, 1989, 284 293. An extended \nversion will appear in Theor. Comput. Sci.  17. MULLER, R. The operational semantics and equational \nlogic of eval and fexprs. Unpublished manuscript. Harvard University, 1990. 18. NAUR, P. (Ed.). Revised \nreport on the algorith\u00admic language ALGOL 60. Comm. ACM 6(l), 1963, 1-17. 19. OLDEROG, E. Sound and \ncomplete Hoare-like calculi based on copy rules. Act a Inf. 16, 1981, 161-197.  20. PLOTKIN, G .D. Call-by-name, \ncall-by-value, and the A-calculus. Theor. Comput. Sci. 1, 1975, 125-159.  21. REES, J. AND W. CLINGER \n(Eds.). The rev\u00adised3 report on the algorithmic language Scheme. SIGPLAN Notices 21(12), 1986, 37-79. \n 22. SCHMIDT, D.A. Denotational Semantics: A Methodology for Language Development. Allyn and Bacon, Newton, \nMass., 1986. 23. US DEPARTMENT OF DEFENSE. The Program\u00adming Language Ada Reference Manualj Lecture Notes \nin Computer Science 106, Springer-Verlag, 1981. 24. WIRTH N. AND C.A. R. HOARE. A contribution  to \nthe development of ALGOL. Commun. ACM 9(6), 1966, 413-432. \n\t\t\t", "proc_id": "99583", "abstract": "", "authors": [{"name": "Erik Crank", "author_profile_id": "81100222164", "affiliation": "Department of Computer Science, Rice University, Houston, TX", "person_id": "P78734", "email_address": "", "orcid_id": ""}, {"name": "Matthias Felleisen", "author_profile_id": "81100323458", "affiliation": "Department of Computer Science, Rice University, Houston, TX", "person_id": "PP39037684", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/99583.99616", "year": "1991", "article_id": "99616", "conference": "POPL", "title": "Parameter-passing and the lambda calculus", "url": "http://dl.acm.org/citation.cfm?id=99616"}