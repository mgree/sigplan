{"article_publication_date": "01-03-1991", "fulltext": "\n On the Power and Limitation of Strictness Analysis based on Abstract Interpretation* R.C. Sekar, Prateek \nMishra and I.V. Ramakrishnan Dept. of Computer Science, SUNY at Stony Brook, NY 11794 E-mail: {rcs,mishra,ram} \n@sbcs.sunysb.edu Abstract 1 Introduction Strictness analysis based on abstract interpretation is an important \ntechnique for optimization of lazy func- Mycroft [MYc80] pioneered the concept of strictness tional languages. \nIt is well known that all strictness analysis as a technique for optimizing lazy functional analysis \nmethods are incomplete, i.e., fail to report some languages by transforming call-by-need to call-by-value. \nstrictness properties. In this paper, we provide the first His results have had major impact on techniques \nfor precise and formal characterization of the loss of infor\u00ad compilation, optimization and parallel \nevaluation of mation that leads to this incompleteness. Specifically, lazy functional languages [Cla85, \nAug84, KrHud]. My\u00ad we establish the following characterization theorem for croft s work was based on \nabstract interpretation of Mycroft s strictness analysis method and its natural first-order functions \ndefined over flat domains. Sub\u00ad generalization to non-flat domains called ee-analysis: sequently, there \nhas been much research into develop\u00ad Mycroft s method will deduce a strictness property for ing strictness \nanalysis techniques for higher-order func\u00ad program P iff the property is independent of any con\u00ad tions \n[BHA85, Hud86, KuoMis89] and non-flat domains stant appearing in any evaluation of P. To prove this, \n[Wad87, Hug85, Lin86, Hal187, Sek90, Wad]. we specify a small set of equations called E-axioms, It is \nwell-known folklore that no strictness analysis that capture the information loss in Mycroft s method \nmethod can deduce all the strictness properties of a and develop a new proof technique called E-rewriting. \nfunction. For example, consider the function F(z, y) = E-rewriting extends the standard notion of rewriting \nit P(z) then y else O where P(z) is always true for all to permit the use of reductions using E-axioms \ninter\u00ad values of x. Observe that F is strict in y, but this fact spersed with standard reduction steps. \nE-axioms are is impossible to detect uniformly. Therefore, any strict\u00ad a syntactic characterization of \ninformation loss and E\u00ad ness analysis method must be incomplete, i.e., fail to rewriting provides an \nalgorithm independent proof tech\u00ad report some strictness properties. This incompleteness nique for characterizing \nthe power of strictness analysis may arise from a variety of sources such as inability to methods. It \ncan be used to answer questions on com\u00ad represent all possible strictness properties, inability to pleteness \nand incompleteness of Mycroft s method on analyze accurately function composition or recursion, certain \nnatural classes of programs. Finally, the tech\u00ad etc. Such inaccuracy leads to some information loss niques \ndeveloped in this paper provide a generzd prin\u00ad in any strictness analy$is method. ciple for establishing \nsimilar results for other strictness analysis methods based on abstract interpretation. As Despite a \ndecade of research into strictness analysis a demonstration of the generality of our technique, we methods \nbased on abstract interpretation, the impor\u00ad give a characterization theorem for another variation of \ntant problem of discovering a precise and formal charac\u00ad Mycroft s method called old-analysis. terization \nof this loss of information has remained open. Such results, which we call characterization theorems, \n*Partially supported by NSF grants CCR-8706973, 8805734 are important because they provide an unequivocal \nba\u00ad sis for comparing different strictness analysis methods, They also enable us to pinpoint weaknesses \nof existing Permission to copy without fee all or part of this material is granted methods, improve them \nand aid us in discovering new provided that the copies are not made or distributed for direct commercial \nadvantage, the ACM copyright notice and the title of the and more powerful methods. publication and ha \ndate appear, and notice is given that copying is by permission of the Association for Computing Machinery. \nTo copy other\u00ad wise , or to republish, requires a fee and/or specific permission. @ 1990 ACM 089791-419-8/90/0012/0037 \n$1.50 37 1.1 Main Results changing true to false or vice-versa. In this paper we present the first such \ncharacterization theorems for Mycroft s method and its natural general\u00adization to non-flat domains (called \nee-analysis) that we reported in POPL 90 [Sek90]. Our main theorem is: MycToft s method will deduce a \nstrictness property for program P ifl the property is independent of any con\u00ad stant appearing in any \nevaluation of P, For instance, in the function F above, deducing that F is strict in y is based on the \nfact that P(a) always eval\u00aduates to the constant true and thus Mycroft s method cannot deduce this. In \nMycroft s method all cons tants are mapped to a single value in the abstract domain. This obvi\u00ad ously \nmust contribute to loss of information. However there are several other steps in the abstraction that \nmight also cent ribut e to information loss: the choice of abstract representations for the primitive \nfunctions, the use of composition and fixpoint iteration to ana\u00adlyze user-defined functions, etc. Our \ncontribution is to show that surprisingly the information loss in Mycroft s method is only due to the \nmapping of all constants to a single value; all other abstract ion steps are lossless. An important consequence \nof our result is that any method that uniformly ignores constants cannot be any more powerful than M \nycroft s method. Thus, our result on the power of Mycroft s method together with results on its computational \ncomplexity in [Hud86] now completes the investigation of its fundamental properties. 1.2 Overview of \nApproach To state our characterization theorem formally and prove it, we needed to devise new concepts \nand proof techniques. First, we specify a small set of equational axioms (called E-azionw) thatmake all \nconstant terms interconvertible, thereby capturing the information loss incurred by mapping all constants \nto the same value. These E-axioms induce an equivalence relation =E (called E-equivalence) on programs, \ngiven by P =~ Q iff P can be obtained from Q by changing its con\u00adstant parts . Based on this notion of \nEquivalence of programs, our main theorem can be formally stated as: Mycroft s (and our ee-analysis) \nmethod will deduce strictness property p of program P iff p is a 9trictness property shared by every \nprogram Q =E P. For illustration, the following two programs are E equivalent since one can be obtained \nfrom the other by F1(z, y) = if true then z else y F2(z, y) = if false then x else y  Note that F1 is \nstrict in z, whereas F2 is strict in y. However, neither of these properties are shared by both programs. \nThus, these two properties will not be in\u00adferred by Mycroft s method. On the other hand, the property \nz v y is shared by both and hence will be in\u00adferred by Mycroft s method. For the only if part of the \ncharacterization theorem we show that if P =E Q then we compute the same strictness properties for P \nand Q. For establishing the if part we need to show that for any strictness proP\u00aderty p of P that is \nnot inferred by Mycroft s method, there exists a Q =E P for which p is not a strictness property. The \nconstruction of such a Q is quite com\u00adplex and cumbersome. Instead, we develop a new proof technique \ncalled Erewriting that precisely formalizes the notion of performing reductions with any Q =N P. Erewriting \nextends the standard notion of rewriting to permit the use of equational steps interspersed with standard \nreduction steps from P. Thus constants can be interchanged at any point in the reduction sequence. Eaxioms \nare a syntactic characterization of informa\u00adtion loss and E-rewriting provides an algorithm inde\u00adpendent \nproof technique for characterizing the power of strictness analysis based on abstract interpretation. \nIt can be used to answer questions of completeness of such methods with respect to classes of programs. \nFor instance, we can show that M ycroft s (and our re\u00ad analysis) method is complete for the important \nclass of non-erasing programsl. In contrast, it appears difficult to deal with such questions using the \nsetup of abstract interpretation. Section 5 describes in detail our com\u00adpleteness results based on Erewriting. \nThe techniques developed in this paper provide a gen\u00aderal principle for establishing similar characterization \ntheorems for other strictness analysis methods based on abstract interpret ation, As a demonstration \noft he gen\u00aderality of our technique, we have given a characteriza\u00adtion theorem for another variation \nof Mycroft s method called old-analysis (reported in POPL 90 [Sek90] ). dd\u00adanalysis is an enhancement \nof Mycroft s method to rea\u00adson about head normal forms in non-flat domains and is described in section \n4. Among other applications, old-analysis has been shown to be a valuable tool for repairing violations \nof strong sequentiality, a concept 1In such programs, all the variables appearing on the lhs of a rule \nalso appear on the rhs, pioneered by Huet and Levy for lazy evaluation of equa\u00adtional programs [Huet79]. \nThe rest of this paper is organized as follows: Sec\u00adtion 2 is an overview of the ee-analysis method. \nTech\u00adnical details of lZrewriting and the main theorem ap\u00adpear in section 3. In section 4 we give a characteri~ation \ntheorem for old-analysis. Implications and significance of our results appear in section 5 together with \nremarks on its generality.  2 Preliminaries The language we consider is a constructor-based term rewriting \nsystem (TRS). Such a system consists of a set of oriented equations (called rewrite rrde.s) of the form \n1 + ~ where the left-hand side (lhs) 1 and right\u00adhand side (rhs) r are terms that may contain variables. \nThe lhs must be linear, i.e., no variable in them can occur more than once. Furthermore, the nonvariable \nsymbols are partitioned into two disjoint sets the set of function symbols F, and the set of constructor \nsymbols C, such that the outermost symbol of every Ihs is in P while the rest are in C. First-order programs \nwritten in functional languages, as well as the recursion equations studied by M ycroft, follow this \ndiscipline. A srdwiiirdion maps variables to terms. By t[z +-v] we refer to the term obtained from t \nby substituting the variable z with the term v. If u is a term with n variables Z1, . . . . Zn then I@,. \n. . . tn] is shorthand for U[zl t-tl, ...,Zm + -tn].instance tfl of a term t is An obtained by replacing \nz by /3(z) for each variable z in t.A redez in term u is an occurrence of an instance of an lhs. A term \ntis in normal form (NF) if it contains no redexes. By t ~ u we mean that u is obtained by replacing a \nredex 1P in t by r~, where [1 --+ r] is a rewrite rule. The reflexive and transitive closure of+ is denoted \nby + . We use the notations tj.NF and tTNF to denote respectively that tcan or cannot be reduced to a \nterm in NF. A term t is in head normal form (HNF) if there is no redex t such that t+8 t!. 2.1 Overview \nof ee-analysis Our characterization theorem is based on ee-analysis which is a strictness analysis method \nfor non-flat do\u00admains, This analysis tells us which subterms of a term are to be normalized in order \nto normalize the entire term. As usual, our analysis is based on interpret\u00ading programs as functions \nover the domain {O, 1} (or equivalently, the domain {false, true}). We review this method and remark \nthat it reduces to M ycroft s method for programs on flat domains. Therefore our results for ee-analysis \ndirectly apply to Mycroft s method as well. First we define strictness property of a term t as follows, \nDefinition 1 (Strictness Property I) .Let t be a term and (zll AZ12A . .. Azl., ) V (Z21 A . .. Az2., \n)V ... V(#mA ..-A Za,n ) be the disjunctive normal form (DNF) of a boolean formula P, where xij $ denote \nvari\u00adables in t. We say that p is a strictness property oft ifl whenever any .s = t~ possesses NF then \nthere must be a j such that every subterm @(zjl), ....~(zjrj) in tp has a normal form. For instance, \nift = $(zl, Z2, 23) and Z1AZ2VX1AiZ3 is a strict ness property oft, thento normalize any inst ante ~(sl, \nS2, S3) oft, we must normalize SI and one of Sz and 83. We now describe our ee-analysis method that com\u00adputes \nstrictness properties of arbitrary terms. The strictness property teeof a term is computed from [C(ZI, \n.... z-)] and [~(zl, .... Zn)]ee (abbreviated as c and ~e respectively), and the following rule to compute \nthe strictness of an instance. Rule of Substitution [tfl]ee = tee [zij e-@(zii )] ] We specify 2 , c(z1, \n.... Zn)e and ~(zl, .... Zn)ee as fol\u00adlows. For a variable z, its substitution instance is to be normalized \nand hence z = z, For c(z1, . . ..zn). the normal form of its instance C(S1, .... Sn) is obtained only \nby normalizing each of S1, .... Sn. Hence c is the con\u00adjunction of xi s. Note that if c is a zeroary \nconstructor then c = 1. In order to compute f e, let be the equations defining f. Thus any in\u00adstance \nf(81, .... 8n) can be rewritten into only one of el, ,.., e~ and so j e is a disjunction of e~e, for \nj = 1, ...lk. However, f e is a formula on Zl, . . ..zn whereas e~e is a formula in vari\u00adables Zll, ...!21? \n1)2211...) 2272, .... Zni, .... $&#38;,n (where Zil, .... au,i are the variables in t:).Hence we need \na function gi that transforms a formula on the variables .. m f.?j mto one on xl, . . . . zn. Thus, ee \n= z z (1) [C(Z,,..., Z+t)]ee = irI A o~OA G (2) [f(a!,, .... %)] = ~ gj(c?~e) (3) j=l Each gj is specified \nas follows, where p and ~ stand for arbitrary boolean formulas. (4) 93(4 v w) = 9j(@) v 9j($J ) ~j(P) \n= ( A z,) Agi(~) (5) i I t; contains no variables gj(~ilA...A*i~iAP) = %Agj(~) (6) (7) gj ( f) = 1, \notherwise, To justify these equations, note that if ~(sl, .... Sn) is rewritten by the jth equation \nthen s~ = t~/3.If the substitutions for all the variables Zil, .... zi~i are to be normalized in order \nto normalize ej, then $i must be normalized and hence equation (6). Otherwise we can\u00adnot determine if \nsi is to be normalized and hence (7). Equation (5) is actually a special case of (6). When f is recursive \nwe compute f e using fixpoint iteration as follows. Let f, h, . . . denote all functions in the program. \nDefine fee o = O and fee {+l as V;=l9Jeje[fee -fee , ~e + ~ e i) .-l) (~ee etc. are defined analogously). \nThe limit of the sequence fee,O, fee,l , . . . is defined to be fee. For any term t we can analogously \ndefine t 9Pwhich is obtained by sub\u00adstituting f J in place of f for every f in t. It is clear that for \nsome finite p, f J = f e. We illustrate ee-analysis using the following program: f(rd,l!,y) + z + y Example \n2 f(z : nil, ~, z) ~ f(nir, Y, ~) f(u :w, y,z) + f(w, y, z) We begin with fee o = 0. Note that e~e o \n= x A y (by definition of + ) and gl(~ A y) = al A gl(z A y) (by (5)), which can then be simplified to \n~1 A =2 A a3 using 2 applications of (6). It can be easily seen that e~ = ee, O es = O and so fee l \n= Z1 A X2 A X3. Substituting this, we get gl(eje l) = ml A Z2 A a33. Observe that e~e l = z A y and so \ng2(e~ 1) = Z1 A g2(y) = Z1 A Z2 (by two applications of (6)). Also note g3(e~ 1 ) = g3(w A y A z) which \ncan be reduced to icZA=aAgs(w) (two applications of (6)) and then to X2 A Z3 (by 7). Therefore fee12 \n= Z2 A (zl V Z3). Following the same procedure, we arrive at fee*3 = X2 = fee 4. Thus, f is ee-strict \nonly in its second argument. To derive M ycroft s method from ee-analysis, observe that each function \nin his recursion equation notation is defined using a single rewrite rule. Therefore the dis\u00ad junction \nin rule (3) is unnecessary. Furthermore, since these equations have no constructors on the lhs (no pat\u00ad \ntern matching), it can be easily shown that the gj S re\u00adduce to identity function. Finally, note that \nthe primi\u00adtive functions used by Mycroft can be defined using pat\u00ad tern matching. The strictness properties \nderived by our analysis for such functions are exactly those assumed by Mycroft.  3 Characterization \nTheorem for ee-analysis We start this section with an alternative definition of strictness property that \nis used in our proofs. For this definition, we need to relate substitutions and truth as\u00adsignments as \nfollows. Let A be a (truth assignment) function assigning tpue or false to Z1, .... Zn and c be a (substitution) \nfunction assigning terms to Z1, .... Zm. We say a <C Aiff VI < i < TZ [U(Zi)J. NF ~ A(z;)]. In other \nwords, A assigns true to a variable whenever u substitutes a term possessing NF in its place. Similarly, \nu >= A means that Vi, A(zi) > cr(zi) J.NF. Definition 3 (Strictness Property II) yY zs a strictness property \noft zff 1A(P) +-VU <e A i%~NF. Note that this definition is a compact version of My\u00adcroft s original \ndefinition (pp.275 in [Myc80]) of strict\u00adness property. Now we show that the two definitions of strictness \nproperty are equivalent. To show that defini\u00adtion 1 implies definition 3, we proceed as follows. Let \nA(yY) be false. Then A must assign false to one lit\u00aderal in each conjunct in the DNF of p. Therefore \nev\u00adery u <e A must substitute a term with no NF for one literal in every conjunct. From the contrapositive \nof definition 1, the consequent tuTNF of definition 3 follows. To show that definition 3 implies 1, assume \nthat the antecedent of the contrapositive of definition 1 holds (i.e., Vj % ~(zij) ~ NF). Now let A(z;i) \n= true M /3(~ij) J NF. Note that d(~) = false, ,b <, A and hence by definition 3, tflTNF. m The set of \nstrictness properties forms a lattice and hence every term t has a maximal strictness property, which \nis defined as follows. Definition 4 (Maximal Strictness Property) A strictness property p oft is said \nto be maximal if either of the following (equivalent) conditions hold. 1. If@ is a strictness property \nfort then p ~ $. 2.~(~) a 3U<cA. taJNF. In Example 2, Z2, Z2 Vzl and izl V Z2VZ3 are all strict\u00ad ness \nproperties off whereas ~ z is its maximal strictness property. We establish the equivalence of the two \nconditions for maximal strictness property as follows. In what follows we assume that ~ is in DNF. To \nshow that (2) implies the (contrapositive) of (l), pick any arbitrary ~. If i = q then (1) holds. Otherwise, \nwe can find an A such that A(p) = true and A(d) = false. For this A, there is a u <. A such that tu J \nNF (by 2). Note that tuJNF although A(@) = false and hence @ is not a strictness property oft. Now we \nshow that 72 +-71 (i.e., 1 + 2). Assuming 12, there is an A such that d(p) = tTue and Vu <c A i%~NF. \nSince A(q) = tmte, there is a conjunct PI of p such that A(pl ) = tTue. Define A (isi) = true iff Zi \nisin VI. Note VU[U <. J ~ u <. A ]and so VU<= A tu~NF. Let V2 be the disjunction of all the remaining \nclauses in q other than ~1. Let @ = 92. VIV=l=Et,=@W, W1 Az* ( )1. Note $ ~ p. We now show that + is \na strictness prop\u00adert y oft, thus contradicting 1. To do this, consider any d such that d(~) = false. \nIf ~(p) is also false, then since ~ is a strictness property, we have VU SC d i%T NF. Otherwise, (i.e., \nd(~) = false, A(p) = true) it must be the case that A(91 ) = true and PI A z = f sise (for all z @WI, \nz in t).This means that ~(z) = true iff z E pl and hence ~ = A . Since we already know that Va <c A taTNF, \nwe have established that @ is a strictness property oft. B 3.1 lil-axioms and 17-Rewriting We introduce \nthe following equations (henceforth called E-axioms) to capture the notion that we cannot distin\u00ad guish \nbetween constants in ee-analysis. x= C(cl, . . . . c~, z, Ci+l, . . ..C%). vc,c~,...,cn ~ C (8) c= c \n, Vc, c Gc (9) Note that a constructor term C(C1, .... Ci, ?, .... Cn) can be built from E using equation \n(8). By repeating this process, we can build any constructor term containing ~ starting with ~. All such \nterms are equal. Since any two zeroary constructors are equal by equation (9), any two constructor terms \nare made equal by these equations. We say t =Jj s whenever t can be obtained from s using the above two \nequations. This relation can be naturally lifted to rewrite rules and programs as follows: 1~ r =E V \n--t r iff 1=E V and ? =E r . For programs P and Q, P =&#38; Q iff for every rule 1~ T in P there is a \nrule ~ -r =Jj 1 ~ T in Q and vice versa. Henceforth P and Q stand for programs. Finally we define E-derivation \nto+ tl+ ...+ t% where each t~ is obtained from ti_1 by applying one of the rewrite rules in the program \nor one of the above equations. We call the reduction step a P-step (denoted ti-+P ti+l)in the former \ncase and an E-step (denoted t~ ~E ti+l ) in the latter case. If it is a P or an E-step then we denote \nit as ti_i(p,,g) ti+l. Note that in an E-step equation (8) can be applied either right-to-left, denoted \n(87), or left-to-right, denoted (81). We say that a term t is in E-normal form iff it contains no function \nsymbols and use the notation s J E-NF to denote that s possesses an E-NF. As noted in the introduction, \nE-rewriting formalizes the notion that constants can be interchanged at any point in the reduction sequence \nand therefore we achieve the effect of performing reductions w.r.t. to any Q =E P. Formally, heorem 5 \nt {PIE) s + 3t E ; E ~Q E P such that t) --i; S{ Proof: By definition of E-equivalence of programs, \na Q-reduction step Vu -+ ~ a (here V ~ r c Q) is equiv\u00adalent to a (P, E)-reduction sequence .l u --+> \nb +P TV -+; TJU (where 1 ~ r ~ P). Therefore every Q\u00adderivation can be viewed as a special type of (P, \nE)\u00ad derivation and hence the proof in (<) direction. For the proof in the other direction, we need to \ntransform an arbitrary (P, E)-derivation sequence into one of this special type. To do such a transformation \nrequires re\u00ad arranging the order in which the E-steps and P-steps are performed. It is straightforward \nto rearrange a se\u00ad quence consisting of an E-step followed by a P-step (or P-step followed by a E-step) \ninto one consisting of zero or more P-steps followed by zero or more E-steps (or zero or more E-steps \nfollowed by zero or more P-steps). However, simply repeating this process may create ar\u00ad bitrarily many \nnew E or P-steps and so this process of rearrangement may not terminate. Therefore a sophis\u00ad ticated \nanalysis of the interaction between the E and P-steps is necessary to construct the desired reduction \nsequence. An outline of such a construction is given below and the details appear in the appendix. 1. \nLet tk ~ tk+l be the first application of (8r) in the sequence t -+~p,~) s. We show that either this \nre\u00adduction and the one immediately preceding it can be interchanged, or that the preceding equation uses \na pro\u00adgram rule 1 + T and the effect of performing these two reductions can be achieved by performing \none reduction using a rule 1 ~ r (here ~ =JJ r ). 2. We repeat step 1 till the reduction using (8r) \nrule disappears or is moved ahead of all other reductions.  3. Repeat step 2 on the next application \nof (8r) rule and so on. At this point, we have a reduction sequence which can be partitioned into two \nparts. The initial part t+* icontains a sequence of reductions using (8r) rules alone. The latter part \ncontains reductions using (81), (9) and rules of the form 1 ~ r , where 1 -+ ~ is a rule inPand T=E r \n. Let f =~. 4. In a manner analogous to the steps above, we push all applications of rules i ~ d (where \n1 ~ r is a rule in P and ? =E T ) ahead of all applications of (81) and (9) steps.  Now we have constructed \nthe reduction sequence s. Note that Q consists only of t fS,) b ~:81,9) n.des ~ -+ T that are E-equivalent \nto some rule 1 -+ T inPand thus Q=E P. 9 3.2 Main Theorem and Proof Outline We now require notation \nto denote strictness properties of a term w.r.t. different programs. We denote the strictness property \nq oft w.r.t. P as P(P), where P may be dropped when it is irrelevant or obvious from context. Definition \n6 (Shared Strictness Property) p is a shared strictness property oft w.r.t. P if eitheT of the following \n(equivalent) conditions hold: 1. P 25 a &#38;%ictne55 p9 0pe9 ty Of e?Jery term $ GE t W.T.i eveTy pTogram \nQ =E P. 2. +(p) ~ VU<=A tuTE-NF.  Equivalence of the above two conditions follow directly from theorem \n5. Now we are ready to present our main theorem. Theorem 7 (Main Theorem) t (P) +-~ ifl@ is a shared \nstrictness pr opeTty oft w.r. t P. To prove the only if part of this theorem, we need the concept of \nstrictness properties of two terms s and tbeing syntactically identical (denoted see ~ tee),i.e., these \ntwo formulas are identical even without expand\u00ading out the strictness property of some subterms in s \nand t. Consider for example, the terms ~(z) and f(c(z)), where f 67 and c c C. Note [f(c(z))]e s :;[;;;) \n[Z1 + [c(@)leel (f(al))e (zl +-a?) = ee Lemma 8 (a) ds,t, s=E t 3 sees tee. (b) VP, Q,Vt, P =~ Q + t \ne(P) G tee(Q). Proof: For part (a), we show that see and t are syn\u00adtactically identical whenever s can \nbe obtained from t by one application of an E-axiom. By induction on number of applications of E-axioms \nrequired to get t from s, part (a) of the lemma follows. Let t= t [z+--la] and s = t [z + mr] where I \n= r is the E-axiom ap\u00adplied. Note that teeE -# [z + (lu)ee]and see ~ itee~ + (TV) ]. Observe that for \nboth E-axioms, [ (b)ee ~ (Ta)ee and so see E tee. For part (b), it suffices to show that the expres\u00adsions \nobtained for tee (using the rule of substitution and rules (1), (2) and (3) in section 2) are syntacti\u00adcally \nidentical for programs P and Q. Since the ex\u00adpression for teeare obtained from fee and the rule of substitution, \ntee(P) and tee (Q) will be identical when\u00adever fee (P) and jee (Q) are identical for all functions ~. \nLet 11 -+ rl, ...,l~ + Tn and l; d r;, . ...1A -t T~ be the rules defining j in P and Q respectively. \nBy definition, fee(p) = v~=l gj(~~e(p)). Note that Vj there is an 11 ~ r: =E Zj + Tj in Q. By part (a) \nof this theorem, Tje ~ T:ee. Also observe that the equations in E do not change the variables in t;, \nt~(recall lj = f(t~, .... tn . ..> n f)) and so gj and g; are identical. Furthermore, note that foreach.!j-+TjEPthere \nisanl;~ T; EQandhence each disjunct in the expression for fee (P) also appears in f e (Q). By interchanging \nP and Q in the above ar\u00adgument, we see that the converse of this also holds and therefore fee (P) s f \ne(Q). i Thus we have established the only if part of our main theorem. In what follows, we establish \nthe if part. Our proof strategy here is to show that ee-analysis infers the maximal shared strictness \nproperty. In other words, if tee(P) = p then we wish to show (cf. definition 4): We call a strictness \nproperty that satisfies (10) as an E\u00ad maximal strictness property (abbreviated EMS P). For the purposes \nof proof we choose to show that tee(P) =q satisfies the stronger property: VA [A(p) a VU ~c A tcr J E-NF] \n(11) Note that stronger property (11) implies (10). We now show that (11) also implies the if part of \ntheorem 7. Assume (11) and that @ is a shared strictness property. By (11), ifA(p = tee(P)) = tmte then \nVCT >C A taJ E-NF. From the contrapositive of the second condition in definition 6, it follows that A(z) \n= true and hence we have tee(P)=++. For the proof of (11) we need the concept of depth of a reduction \nsequence t~ = to-+*tn w.r. t. t.Label all occurrences of function symbols in t (exclude func\u00ad tion symbols \nwithin u) with O. Let -ti+lbe obtained from tiusing the rule 1 ~ r. If the root of the redex is Iabelled \n(say, with j), then label all occurrences of func\u00adtion symbols in ~ with j+ 1 before rewrite. If the \nroot of the redex is not labelled then proceed as usual. Then the depth of to -t . . . -+ tn is the maximum \namong all the labels assigned to any function symbol in any of tl, . . . . tn. we use the notation s \njk,~ E-NF to denote that s can be E-normalized using a reduction sequence of depth < k w.r.t. z!; analogously, \ns lk,~ NF can be similarly defined. Now recall the fixed point computational method used in ee-analysis. \nJust as fee specifies all the arguments that must have an NF whenever f(s~,..., sn ) j NF, we remark \nthat f e k specifies all the arguments that must have an NF whenever f(sl,..., sn ) l~,tt~,,...,~~) NF. \nIn Example 2, if f(sl, 82, 83) Jl,t(al,za>m) NF then Sl, S2, S3 must have NF; if f(sl, s2, s3) 12,~(~,,~2,.,) \nNF then S1 and one of S2 or S3 must have NF as so on. The above remark implies that fee !k are maximal \nin some sense and moti\u00advates the following definition of a k -mazimal property p oft. VA [A(p) a Va >CA \ntalk,,E-NF] (12) Observe that property (12) implies (11). We show that tee k is a k-maximal property. \nThen, by soundness of ee-analysis, teeis a strictness property oft that satisfies (11) and hence is an \nEMSP.  3.3 Proof of Main Theorem We first show that the rule of substitution preserves k-maximal properties, \ni.e., Lemma 9 Let tl, .... tm be arbii!rary terms and PI, . . . . Pn be the respective k-maximal properties, \nAlso let ~ be a k-maximal property of d(xl, . . . . Zn), where d c C U F. Then ~ = +[zi + pi] is a k-maximal \nprop\u00aderty of d(tl, .... tn). Proof: The theorem is proved by showing in three steps that V~[~(@ ~ Va \n>= ~ d(tl, .... tn)u $k,d(t,,,.,,$~l E-NF] 1. Given ~ we construct an A such that A(#) = A(J). 2. Given \na u >. d, we construct a @ such that  Ci(tl,....tn)ucan be reduced to ct(zl, . . . . %m)/3 by an E\u00adderivation \nwhose depth w.r.t. d(tl, . . . . tn) is < k. We also show that /? >= A. 3. Since # is a k-maximal property \nof d(al, . . . . Zn) and since A(+) = true, for every /3 ~C A, there exists an E-derivation of depth \n< k (w.r.t. d(zl, .,., isn)) to normalize d(zl, .... Zn)fl . We select a suitable /3 and from such a \nderivation for d(iul, . . . . Zn)fl , we construct another E-derivation to normalize d(zl, . . . . zn)/J \nin a depth < k w,r.t. d(tl, . . ..tn). Step 1 Let A be such that A(zi ) = ~(pj ). To show that A(+) = \n~(~), let @l, .... @m be all the conjuncts intheDNF of~. Then ~=@lV...v &#38; where &#38; = @i[zi -vj]. \nNote that ~(~) is true ifl ~~i that k true. But then A(+i) = tTue iff .d(@i) = tTue (by definition of \nA). Step 2 Let u >. ~. Since pj is a k-maximal prop\u00aderty for tj,there exists an E-derivation (of depth \n< k w,r.t. tj)that normalizes tjuwhenever ~(~j ) = true. Let NF(tju) denote the normal form reached by \nsuch a derivation. Now let ~(zi ) = NF(-tj u) whenever ~(~j) = true and fl(zi) = tju otherwise. By concate\u00adnating \nE-derivations to normalize each tju such that ~(~j ) = true, we obtain an E-derivation A that re\u00adduces \nd(tl, ....tn)a to d(zl, .... am)~. Observe, by def\u00adinition of depth, that this derivation is of depth \n< k w.r.t. d(tl, .... tfi). Furthermore, note that ~(~j ) is in NF whenever ~(pi ) = A(zj) = true, and \nso ~ >C A. Step 3 Let @ be such that /3 (~j) = @(zj ) whenever ~(~j ) = true and @(zj ) = 12 otherwise. \nNotice @ >C A and A(l) = tTue. Therefore there exists an E-derivation I that normalizes d(al, , ,., z~)fl \nwithin a depth of k with respect to d(zl,..., Zn). Observe that in I all subterms that do not possess \na HNF must be discarded. Therefore all reductions performed within /3 (Sj ) for Zj such that A(~j ) = \nfalse are irrelevant and can be removed from I to obtain a new derivation I . Now, observe that whenever \nA(zj) = false, @(zj) is discarded by 1 without ever reducing any redex in\u00adside it and that ~ (~j ) = \nfl(aj ) for other j. Therefore I can be used to normalize d(zl, . . . . zm)~ in a depth < k w.r.t. d(zl, \n. . . . Zm). Now consider the E-derivation ~ obtained by con\u00adcatenating A (from Step 2) and I . Note \nthat no func\u00adtion symbol in any tjsuch that A(zj ) = ikue appears in d(zl, .,., zn)~ and so the maximum \nlabel assigned to any of these function symbols in ~ is ~ k w.r.t d(tl, tz, . . . . tin). Also observe \nthat the labels of func\u00adtion symbols in tjfor those j such that A(xj ) = f sise, remain zero since no \nredex with these function symbols is ever reduced in A or 17. Furthermore, since the label of d in d(zl, \n.... Zn)u is zero and since depth of r w.r.t. 2-L st ends for any term lacking head normal form. d(xl, \n. . . . z~) is < k, its label never increases beyond k. Therefore the depth of ~ is < k w.r.t. d(-tl, \n. . . . tn). ~ Now we show that equation 3 (in section 2) computes (k + I)-maximal property of ~, given \nthe k-maximal properties of the ej s. Lemma 10 Let pj s be respective k -maximal properties of ej s. \nThen p = @=l gj(~j) zs a (k + I)-maxima/ property of f(zl, . . . . zm). Proof: This theorem is proved \nin three steps by show\u00ading that 1. Given an A. such that A(p) = true, we select one rule f(i!l , .... \ntn) ~ ej and construct an s =E f(zl, . . . . Zn) such that VU ZC A an instance su can be reduced into \nan instance ej,f3. 2. We show that /3 kc A for some A such that A (pj) = t~ue.  3, Finally, we construct \nan E-derivation to normalize ~(zl, . . . . an) in depth < k+l (w.r.t. f(zl, . ..rzn)) based on the the \nderivation sequence to reduce f(zl, . . . . wn)u into ej/3 and the fact that Pj is a k-maximal property \nOf ej. Step 1 Given any A such that A(p) = true, there is a j such that A(gj(pj)) = true. Let @ be a \nconjunct in the DNF of gj (pj ) that is made true by A. By equation (4) (in section 2) defining the gj \ns, there is a conjunct ~ in the DNF of pj such that ~ = gj (~ ). Now we let s = f(sl, .... Sn), where \neach s; is further specified by one of the following two cases. Case 1. c~ is in ?+5:Si = z; Case .2. \nZi is not in $: Let Zil, .... Zi7, be the vari\u00adables in ti.Then, by equations 6 (in section 2), ~zil \n(1 < J< ri) that is not in @ or otherwise Z, c V. Let si = ti[ziz + Zi, Zim = c ,Vnz # 1]where c is a \ncon\u00adstructor. It can be easily seen that sj =E ai and so s=~ f(zl, zz,. ... zn). Observe that A(zi ) \nis true for z; in ~ and since u ~c A, U(ai) can be normalized into some term u. Since u consists of only \nconstructors, it can be reduced into an instance t; [zim + c] (for every variable Zim in ti and for some \nconstructor c) using E-reductions. Thus there is an E-derivation that reduces Siu into t; [~im +-c] for \nZi c +. Also note that for Zi $? ~, si itself is an instance of ti and therefore Sicr is an instance \nof ti. By concatenating such E-derivations for each Zi in $ we obtain an E-derivation A that reduces \nsu into an instance f(tl , . . . . tn)~. This can now be reduced using the rule f(tl , . . ..tn) -+ ej \ninto E?j/3. Step 2 Let A be defined by A (zim) = true iff ~im E 4 . Clearly A (yY) = true and since # \nis a conjunct in ~jl true. ~r(qyj) = We consider the cases 1 and (of step 1) to show that /3 >C d , or \nequivalently that ~(~im) j E-NF whenever aim appears in ~ . In case 1, every zi~ in tiis in ~! and the \nsubstitution for every one of them is c and so is in ENF. In the second case also, the substitution for \nevery variable Zim that appears in d is C. Therefore /3(~im) J E-NF in both cases. Step 3 Since Pj is \na k-maximal property of ei and A (~j) = tvue, and since /3 ~= A , there is an E\u00ad derivation I of depth \n< k w.r.t. ej that normal\u00adizes ej~. Consider the E-derivation obtained by con\u00ad catenating A, the reduction \nf (tl, . . . . tn)~ ~ ej/3 and I . This derivation normalizes f (zl, . . . . zn)u and is of depth < k \n+ 1 w.r.t. f (zl, .... Zn) because in the step f(t~,tz, . . . , t~)~ ~ ejp the label of all function \nsYm\u00adbols in ej is one and these labels increase by at most k inr!. m Lemma 11 tee~k is a k-maximal property \noft. Proof: By induction on k. For the basis, note that ! O = fa~$e and so lZ holds vacuously. Using \nlemma 9 and the definition of tee~kin terms of f ,h, we can establish by simple induction on the structure \noft that tee~o is a O-complete property oft. For the induction step, assume that e~e ~ s are the respective \nk-complete properties of ej s. By lemma 10, we see that f e k+l is a k + l-complete property of f. As \nin the basis step, using the definition of tee~k+l (in terms of fee k+l) and lemma 9, we can show that \ntee~ktl is a k + l-complete property of t. B Now, by soundness of ee-analysis, cOrObry 12 tee ~8 EMSP \nOft.  4 Characterization Theorem for old-Analysis To illustrate the generality of our technique we briefly \noutline its use in proving a similar characterization the\u00adorem for old-analysis. This analysis is concerned \nwith propagating head normal form demand on functional output to its input arguments. The equations to \ncom\u00ad pute tddare as follows (See [Sek90] for details). ~dd _ ~ (13) [c(~l, . . .. %)]da = 1 (14) [f(z?,, \n,,,, %)]dd = ~ ~j(e~) (15) j=l  The gj s are defined as follows, 5 Significance and Implications 9j(9) \n= ( A w) Agj(w) (16) ili!f isa nonvariable 9j(Pl V 92) = gj(wl) v9j(92) (17) gj(~l A P2) = %(wl)Agj(Pz) \n(18) 9j(Z;l) = z;, if t:is a variable (19) 9j(W) = 1, if t: is a nonvariable (20) To obtain a characterization \ntheorem, the first step is to specify E-axioms appropriate for old-analysis. C(tl, . . .,tn)=c , vc, \nc ec (21) The effect of this equation is to equate any two terms that are in head normal form. In the \nremainder of this section, we specify the neces\u00adsary changes to definitions and theorems (used in prov\u00ading \nthe characterization theorem for ee-analysis) so as to obtain a similar result for old-analysis. In all \ndefi\u00adnitions, theorems and lemmas we replace NF by HNF, E-NF by E-HNF and term without normal form by \nterm lacking head normal form . We can prove theorem 5 with respect to the E-axioms for old-analysis \nusing essentially the same proof used for ee-analysis. In lemma 8, for part (a) note that dd of right-hand \nside is precisely the dd of the left-hand side in equation (21). For part (b) we only need to argue that \ngj functions of equivalent programs remain unchanged. To do so, we only need consider equations (16), \n(19) and (20) above. Observe that these rules depend only on whether tjis a variable or non-variable. \nBut this property is left unchanged by the E-axiom. Lemma 9 carries over without any changes in the ar\u00adguments. \nFor lemma 10, the following observations are necessary. In case 2 of step 1, we observe that z @ @ implies \nthat Z;l @ # and ti= Zil.Therefore, in both cases Si is identical to Zi. Also observe that whenever A(w) \nis true for z; c # and u >C A, then U(ei) can be head normalized to some term u. As u is in HNF it can \nbe E-reduced to ti [~il + c]. The remainder of the reasoning carries over unchanged. With these changes, \nwe have the following result for old-analysis as well. Theorem 13 told(P) ~ v zff v is a shared (old) \n.drict\u00ad ness property for t.  of our Results Strictness analysis methods based on abstract interpre\u00adtation \nare defined by a non-standard semantics obtained by re-interpreting programs over a simpler abstract \ndo\u00admain. This is useful for computing strictness proper\u00adties but is not helpful in answering questions \ndealing with the power of the method in a manner indepen\u00ad dent of the computational procedure used. Such \nques\u00adtions take the form: given a class of programs P is the method complete for this class? What is \nthe in\u00adformation lost by the method? How can its power be enhanced? etc. In contrast, we give a proof \ntechnique to answer these questions in a computation independent manner. Specifically, E-axioms are a \nsyntactic charac\u00adterization of the information lost by the method and E-rewriting provides a powerful \nalgorithm-independent tool for answering questions such as above. Thus, us\u00ading our approach we can draw \nthe following conclusions about M ycroft s method. The information lOSS in M ycroft s method is only \ndue to the mapping of all constants to a single value; all other abstraction steps are Iossless. . Any \nmethod that uniformly ignores constants can be no more powerful than Mycroft s method. More pre\u00adcisely, \nif such a method computes the same strictness properties for the lhs and rhs of the E-axioms then it \nwill not have any additional power. Therefore the only source of improvement is to enrich the abstract \ndomain by adding more points to it. We show that Mycroft s method is complete for non-emsing programs, \nwherein all the variables in the lhs of a rule appears on the rhs. There are many important functions \nthat are non-erasing such as ap\u00adpend, reverse, matrix multiplication, etc. It is easy to see that non-erasing \nprograms are strict in all their ar\u00adguments. Observe that if P is non-erasing, so is any Q =~ P. By our \nmain theorem, Mycroft s method de\u00adduces all shared strictness properties and so it is com\u00adplete for the \nclass of non-erasing programs. Note that this proof makes no reference to the computational pro\u00adcedure \nused in deducing strictness properties. We can enhance the above class by permitting the use of if-then-else \n(an erasing function) in the following way: if-then-else must not be used to potentially throw away function \narguments. For example, if z then y else z must t brow away one of y or z, whereas if z then y *Z else \ny/z does not throw away any arguments. Mycroft s method is also complete for this class of programs. \n On the other hand, Mycroft s method is incomplete even for the simple class of non-recursive programs \nwith linear rhs. Functions F1 and Fz (Section 1) illustrate the incompleteness. Finally, the technique \ndeveloped in this paper pro\u00advides a general principle for establishing similar charac\u00adterization theorems \nfor other strictness analysis meth\u00adods based on abstract interpretation. The main idea is to first discover \nequational axioms to capture the loss of information in the analysis method. These axioms induce an equivalence \nrelation over classes of programs. It then remains to show that inferred strictness proper\u00adties are related \nto equivalence classes of programs. As a demonstration of the generality of our technique, we have also \ngiven a characterization theorem for an en\u00adhancement of Mycroft s method to reason about head normal \nform demand which we call old-analysis. It is important to note that discovering E-axioms that not only \ncapture loss of information but are also useful in proving completeness results, may require con\u00adsiderable \ningenuity. For example, we leave as an open problem the discovery of such E-axioms for Wadler s method \nthat reasons about lists using a four point do\u00ad main [Wad].  References [Aug84] L. AUGUSTSSON, A compiler \nfor Lazy ML, Proc. of the 198~ LISP and Functional Programming Conference. [BHA85] BURN, G. L., C.L. \nHANKIN AND S. ABRAMSKY, Theory and Practice of Strict\u00adness Analysis for Higher Order Functions, Workshop \non Programs as Data Objects, edited by N. JONES AND H. GAZINGER, Springer-Vedag LNCS 217, 1985. [Cla85] \nC. CLACK AND S.L. PEYTON JONES, Strictness Analysis a Practical Approach, Functional Programming and \nComputer Architecture, Springer-Verlag LNCS .201, 1985, pp. 95-49. [Hal187] CORDELIA V. HALL AND DAVID \nS. WISE, Compiling Strictness into Streams, l~th ACM Symp. on Principles of Programming Languages, 1987, \npp. 13,2-143. [Hud86] P. HUDAK AND J. YOUNG, Higher Or\u00adder Strictness Analysis for Untyped Lambda Calculus, \n33th ACM Symp. on Principles of Programming 109. Languages, 1986, pp. 97\u00ad [Huet79] HUET, G. AND LEVY, \nJ. J., Computa\u00adtions in Nonambiguous Linear Term Rewrit\u00ading Systems, Tech. Rep. No. 5 59(1979), INRIA, \nLe Chesney, France. [Hug85] R.J. M. HUGHES, Strictness Detection in non-flat Domains, Workshop on Programs \nas Data Objects, edited by N. JONES AND H. GAZINGER, Springer-Verlag LNCS 217, 1985. [KrHud] HUDAK, P \nAND D. Combinator-based Compiler Language, POPL XI, 1984 KRANZ , A for a Functional [KuoMis89] Kuo, T.M. \nAND P. MISHRA, Strictness Analysis: A New Perspective based on Type Inference, Conference on Functional \nProgramming and Computer Architecture, 1989 [Lin86] GARY LINDSTROM, Static Evaluation of Functional Programs, \nProc. of SIG-PLAN 86 Symp. on Compiler Construc\u00adtion, SIGPLAN Notices 21, 7, 1986, pp. 196-206. [Myc80] \nALAN MYCROFT, tice of Transforming by-value, International gramming, Springer The Theory and Prac\u00adCall-by-need \ninto Call-Symposium on Pro-LNCS 83, 1980. [Sek90] SEKAR, R. C., SHAUNAK PAWAGI AND RAMAKRISHNAN, I. V., \nSmall Domains Spell Fast Strictness Analysis, Proceedings of the ACM Conf.:rence on Principles of Programming \nLanguages, 1990 [Wad] P. WADLER, Strictness Analysis on Non-Flat Domains (by Abstract Interpretation \nover Finite Domains), Abstract Interpreta\u00adtion of Declarative Languages, Ellis Hor\u00adwood, 1987 EDITED \nBY ABRAMSICY AND HANKIN [Wad87] PHILIP WADLER AND Projections for Strictness Conf. on Functional Computer \nArchitecture, R.J. M. HUGHES, Analysis, %d Int. Programming and 1987.  tk= ttl [U2 [la]] ~1 [U2 [d] \n= tk+l l+T U1 [c(cl , . . ..c.,uz[b], . . ..cn)] ul[c(cI, . . ..ci. u2[Tu], . . ..cm)] = tk+2 Figure \n1: Case la of proof of theorem 5 tk= v[c ] (9) v[c ] = tk+l tk+z = VIC(CI$.... CijC . ....ck)]  U[c(cl, \n.wc~,c ,wc k)] Figure 2: Case lc.1 of proof of theorem 5 Appendix: Proof of Theorem 5 3. Repeat step \n2 on the next application of (81) rule and so on. At this point, we have a reduction sequence Segt =Et+ \n=ES~Q=E  Theorem 1 t -- ;P,.E) which can be partitioned into two parts. The initial p t -+; s part \nt-+*icontains a sequence of reductions using (81) Proof: (s) Let 1 ~ r be a rule in Q used to rewrite \nrules alone. The latter part contains reductions using tk-+tk+Iin (a step of) the reduction sequence \n-t --+6 (8r) rules, (9) rules and applications of rules of the form s . Observe that there is a rule \n1 -+ r in P such that i -+ ~ (where 1~ ~is a rule in P and r =~ ~ ). Let 1 =E 1 and ~ =E ~ . Therefore \ntk can be reduced to t =$, ih+l using rules in P and E-axioms as follows: 4. In a manner analogous to \nthe steps above, we tk= i[l u]t[h]-p t[?W]t[? U]= tk+l push all applications of rules Z ~ T (where Z \n-+ r is a ~~ 43  rule in P and r =E ~ ) ahead of all applications of (8r) In this manner, each reduction \nstep in i! -~ can be and (9) steps. replaced by a sequence of reductions using rules in P We have now \nconstructed the reduction sequenceand the E-axioms to obtain a reduction sequence t+~ s. Note that each \nreduction in t 4~81) ~ b 4;8r),(9) +P,E) h the middle part uses a rule 1 ~ r , that is E-equivalent(+) \nThe proof in this direction is given by construct\u00adto a rule in P. The program Q =B P consists of all \ning t!, S{, Q and the reduction sequence t ~~ S from these rules and the middle part constitutes the \ndesired the sequence t -+~p,~l s. The main steps in this con\u00adreduction sequence. Now we present the details \nof stepsstruction are as follows. 1 and 4. 1. Let tk-tk+~be the first application of (81) in the Step \n1 Let tk+l ~ tk+z be the first reduction step reduction sequence t -~P,B) s. We show that either that \nuses the (81) rule and let 1 A r be the rule used a) this reduction and the one immediately preceding \nin the reduction tk -+ th+l immediately preceding it. it can be interchanged, or Noting that tk+lmust \nbe of the form u[ru], we have the following cases depending upon whether the (81) rule is applied inside \nu (case la) or inside a (case lb) b) the preceding equation uses a program rule 1-~ and the effect of \nperforming these two reductions can be achieved by performing one reduction using a rule or inside T \n(case lc). Case la: Let u = U1 [uz] where WI is a term at whose1 + r , where T =E ? . root the reduction \nusing (81) is performed. Figure2. We repeat step 1 till the reduction using (81) rule illustrates how \nthe order of these reductions can be in\u00adterchanged. disappears (as in case b) or becomes the first reduc\u00ad \ntion in the sequence. tk= UIC(CI, Figure 3: Case 4a of proof of theorem 5 Case lb; In this case, (81) \nmust have been applied Case Ja: Note that this case is not possible if the rule inside some subterm s \n= a(z) for a variable z in ~ applied in the step th + tk+l was a (9) rule and so it and must have rewritten \ns into some s . Thus tk = must have been a (8r) rule. Figure 3 illustrates how the ~[Z[Z -S, . ..]] -+ \nU[T[Z -s, . ..]] = i!k+~. Let S1, . . . . Sn two reductions can be interchanged. be the other subterms \nthat are substitutions for x (i.e., Case Jb: In this case, the (8r) or (9) rule must have the variable \nz occurs n + 1 times in r). SO tk+l is of been applied within some subterm S1 and must have the form \nti[s, Sl, . . . . Sr] and tk+z = it[s , s1, . . ..sn]. We rewritten into s;, where s; is a substitution \nfor a vari\u00adcan interchange the order of these reductions as follows: able z in 1. Assume that z occurs \nn times in ~ and let sj, ....s. denote the substitutions for these occurrences k = [Z[Z -s, -11 ~(SI) \n~[l[w -s , . ..]] ~z~r U[T[Z +\u00ad8 ]] = a[s , 8(, . ..] = t~+l. NOW t~+l can be reduced to inth+z. Soth+z \n= ~[s{, . . . . s:]. We can now interchange tk+z by n applications of (8r) rules to reduce each s: the \norder of these reductions as follows: back to Si. tk = u[l[z! +-s~, ...]] ~ly, ~[r[~ + S1, .O$]] = tj+l \n= Case Ic: Note that in this case 1 --i T cannot itself a[sl, . . ..sn]. We can now apply rule (8r) on \nsubterms be a (81) rule since the first application of (81) rule was 81, ...> Sn to reduce tj+linto tk+2. \nin tk+l--+tk+z.It cannot be a (8r) rule since in that Case 4c: Figure 5 shows how we can get another \npro\u00adcase ~ = z and we cannot apply (81) rule within T. If gram rule 1 ~ T =E Z a r that achieves the \neffect of it is the (9) rule (case lc.1), then we have the diagram both these reductions. shown in figure \n2. Otherwise, if it is a program rule (case lc.2), we have tk= U[Z U] I@] = tk+~ (ST) the diagram shown \nin figure 4 This completes the proof of step 1. Step 4 Let tk+l + tk+z be the jirst application of a \nprogram rule Z ~ r. Therefore tk+l = u[la] and we again have three cases to consider depending upon whether \nthe preceding reduction (using (8r) or (9) was performed within u (case 4a) or within u (case 4b) or \nwithin 1 (case 4c), Figure 5: Case 4C of proof of theorem 5 V[T U] Figure 4: Case lc.2 of proof of theorem \n5  \n\t\t\t", "proc_id": "99583", "abstract": "", "authors": [{"name": "R. C. Sekar", "author_profile_id": "81100540236", "affiliation": "Dept. of Computer Science, SUNY at Stony Brook, NY", "person_id": "PP15035690", "email_address": "", "orcid_id": ""}, {"name": "Prateek Mishra", "author_profile_id": "81339517422", "affiliation": "Dept. of Computer Science, SUNY at Stony Brook, NY", "person_id": "PP39080631", "email_address": "", "orcid_id": ""}, {"name": "I. V. Ramakrishnan", "author_profile_id": "81452611166", "affiliation": "Dept. of Computer Science, SUNY at Stony Brook, NY", "person_id": "PP39054624", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/99583.99591", "year": "1991", "article_id": "99591", "conference": "POPL", "title": "On the power and limitation of strictness analysis based on abstract interpretation", "url": "http://dl.acm.org/citation.cfm?id=99591"}