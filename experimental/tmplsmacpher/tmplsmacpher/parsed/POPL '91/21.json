{"article_publication_date": "01-03-1991", "fulltext": "\n Fully Abstract Translations between Functional Languages (Preliminary Report) Jon G. Riecke MIT Laboratory \nfor Computer Science Abstract We address the problem of finding fully abstract trans\u00adlations between \nprogramming languages, i.e., transla\u00adtions that preserve code equivalence and nonequiva\u00adlence. We give \nthree fully abstract translations be\u00adtween versions of PCF: one from call-by-name [14, 21] to call-by-value \n[18, 22, 23], one from call-by-value to lazy [4, 5], and one from lazy to call-by-value. The translations \nyield lower bounds on decision procedures for proving equivalences of code. We finally give a def\u00adinition \nof functional translation and show that no such translation exists from call-by-value to call-by\u00adname, \nor from lazy to call-by-name. Introduction There are many ways to compare the expressive power of programming \nlanguages. For instance, the relative time efficiency of compiled programs might be one basis for comparing \ntwo languages. Another criterion might be the constructs provided by the programming lan\u00adguages: language \nA is more powerful than language B if language A can define all of the operators of lan\u00adguage B. (This \nidea of definable operators is explored in [6]. ) We might also say that language A is more powerful \nthan language B if it can type-check more expressions. Of course, we would not want to define expressive \npower based on recursion theory, since most languages compute precisely the partial recursive func\u00adtions \nover, say, integers. Here we explore another notion of expressiveness: whether a language can be translated \ninto another language. A translation is a meaning-preserving, *Supported by an NSF Graduate Fellowship, \nNSF Grant Nos. 8511190-DCR and 8819761 -CCR, and ONR grant No. Nooo14\u00ad83-K-0125. Permission to copy without \nfee all or part of this material is granted provided that the copies are not made or distributed for \ndirect commercial advantage, the ACM copyright notice and the title of the publication and its date appear, \nand notice is given that copying is by permission of the Association for Computing Machinery. To copy \nother\u00ad wise , or to republish, requires a fee and/or specific permission. synt acticall y-defined map \nthat transforms programs of language A into programs of language B. Trans\u00adlations generalize the notion \nof definable opera\u00adtors: the difference is that entire programs not just subexpressions are mapped to \nprograms in the target language in some uniform manner. To keep the study focused, we consider translations \nbetween various versions of the simply-typed, func\u00adtional language PCF [14, 21]. A full definition of \nthe syntax of PCF appears in Section 2 along with the specification of the three interpreters, call-by-name, \ncall-by-value, and lazy. The word (lazy does not re\u00adfer to infinite lists; here, a lazy language is a \ncall-by\u00adname language in which the programmer can observe higher-order termination to }-abstractions \nas well aa evaluation to ground constants [1, 5, 11, 12]. One translation from call-by-value to lazy \nPCF may found in [12]. The idea behind this translation is famil\u00adiar and simple: since the call-by-value \ninterpreter eval\u00aduates operands in function applications in essence, forcing all functions to be strict \ntranslated terms use the constants conv r7 of lazy PCF to ensure that the evaluation of an operand terminates. \nThe operator conv r of type u -+ r + ~ forces reduction of its first argument; if this reduction halts \nat either a A-Abstraction or constant, the operator returns its sec\u00adond argument, otherwise it diverges \n[1, 4, 5, 11, 12]. The translation is defined by structural induction: p=zo Jx .lkf = kr .(convo~T a \n~), M haa type ~ (MN) = (M iv) The translation of constants and conditionals may be found in Section \n3.1. In what sense should a translation preserve the meaning of code? At the very least, we expect a \ntrans\u00adlated program to produce the same observable out\u00adcomes as the original code. Definition 1 A translation \nM w ~ from ,CI to L2 is ade~uate if M produces an observable in O under L1 iff M produces -the same observable \nunder .C2. @ 1990 ACM 089791419-819010012/0245 $1.50 245 The translation defined above is adequate: ibf \nhalts un\u00adder the call-by-value interpreter iff ~ halts under the lazy interpreter, and moreover, A4 call-by-value \nevalu\u00adates to a numeral n iff ~ lazy evaluates to n [12]. We can ask for a stronger condition and require \nthat a translation preserve equivalences of arbitrary pieces of code (e. g., code in which functions \nor procedures have not yet been declared). By equivalence we mean observational congruence. Definition \n2 A term M observationally approx\u00adimates a term N with respect to observable 0 and language L (written \nM ~~ N) if for any L-context C[.], C [M] yields an observable outcome implies that C [N] yields the same \noutcome. Two terms M and N are observationally congruent (written M -~ N) ifbothM~~ NandN~~ M. A translation \nwill be called fully abstract if it preserves observational approximations (cf. [14]): Definition 3 Let \n01 and 02-be the observable of L1 and L2. A translation P w P from Cl to L2 is fully abstract if 01 ~ \n02 and A simple example shows that the translation above is not fully abstract. Consider the terms Ml \n= kc + .z and M2 = Ax _ b .~y .(~ g), where L is the base type of numerals. If we observe numerals and \ntermination to A-abstractions or constants (the observations termin) under the call-by-value interpreter, \nMl -~a~min Mz. But the terms M2 = W+ .conv z (Ay .conv y (z y)) are not lazy observat ion ally congruent: \nthe context (7[.] = [.] (AZ.3) Q (where Q is any divergent term of type ~) causes the first term to return \n3 and the second to diverge under the lazy interpreter. Similar problems arise in other translations, \ne.g., continuation-passing trans\u00adforms, while adequate, fail to be fully abstract [7, 13]. Fully abstract \ntranslations are important for a num\u00adber of reasons. First, fully abstract translations can be used to \ntranslate questions about code equivalence or nonequivalence from one language to another. For example, \nif there is an effective means of proving ob\u00adservational congruences in language B and we have an effective, \nfully abstract translation from language A to language B, then we have an effective proof proce\u00ad dure \nfor observational congruences in language A: first translate terms and then reason about them. More\u00adover, \nif the translation is time-bounded, we may be able to deduce lower and upper bounds on decision procedures \nfor proving equivalences. Second, the concept of fully abstract translations yields a notion of expressiveness: \nlanguage A is no more expressive than B if there is a fully abstract translation from A to B. This idea \nis not new; Mitchell [9] uses the idea of well-structured, fully abstract translations to compare languages. \nObtaining a defi\u00adnition of well-structured translation seems difficult, but we will make an attempt at \nsuch a definition in Section 4. It turns out that the translation from call-by-value PCF to lazy PCF \ncan be made fully abstract. The ex\u00adample above provides the clue for fixing the translation. Intuitively, \nMl and M2 are distinguished precisely be\u00adcause variables in lazy terms range over non-strict as well \nw strict functions. The variable x in Ml can be in\u00adstantiated with any lazy function; the term ~, on \nthe other hand, forces z to be strict in its first argument. The key to repairing the translation is \nto force all variables of functional type to be strict. In Section 3 we show how to define a lazy PCF \nterm 15U_ T that, when given a function f of type u --+ r, returns the strict version f. Applying this \nterm to variables will make the translation above fully abstract. The proof of full abstraction relies \nupon logical relations built be\u00adtween fully abstract models, a technique also developed independently \nby Sieber for obtaining full abstraction theorems from others [22]. Section 3 describes the translation \nfrom call-by-value to lazy PCF in greater detail and sketches the proof of full abstraction. Section \n3 also gives fully abstract translations from call-by-name PCF to call-by-value PCF, and from lazy PCF \nto call-by-value PCF. These translations rely upon definable retractions, and the proofs of full abstraction \nuse the same basic technique as the call-by-value to lazy case. Section 3 finally dis\u00adcusses corollaries \nto the full abstraction theorems re\u00adgarding the complexity of proving observational con\u00adgruences in fragments \nof the languages. Other effective, fully abstract translations based on Godel numberings of terms can \nbe given. Section 4 de\u00adfines the notion of a functional translation (based on logical relations) that \neliminates such Godel number\u00ading translations from consideration. We then show that call-by-value and \nlazy PCF cannot be translated into call-by-name PCF via a functional translation. This is evidence that \nthe notion of a functional translation leads to a nontrivial expressiveness theory. Section 5 concludes \nthe paper with a discussion of some open problems.  2 Preliminaries 2.1 Syntax of Language Simple types \nrange over t (the base type of nonnegative integers) and u -t ~ (functions from a to r). As is standard, \n+ associates to the right; e.g., t ~ L 4 L is shorthand for L -+ (L -+ L). The set of PCF terms, with \ntheir associated types, is given by the following inductive definition (cf. [14, 21]): Z is a variable \nand a term of type u; 0,1,2,... are constants of type L; SUCC,pred are constants of type L -L; Y is a \nconstant of type (u + a) + a, where u#L; Ax .&#38;f is a term of type u + T if&#38;f has type r; (M IV) \nisaterm oftype r if&#38;l has type u+ r and N has type ~; cond M N P isaterm of type u if M has type \nL and N and P have type U; pcond M N P isaterm of type Lif M, N, and P have type L. Here, pcond is parallel \nconditional, a constructor that is needed to make standard models of the language fully abstract [4, \n14, 19, 23]. Also note that the type of Y is restricted; this technical restriction makes the call-by-value \ninterpreter easier to define [18, 23]. A term is a value if it is either a variable, constant, or J-abstraction. \nTo simplify the exposition, values are denoted by V and arbitrary terms are denoted by M, N, P,and Q. \n 2.2 Three Operational Semantics We define three interpreters, call-by-name, call-by\u00advalue, and lazy, \nvia three binary relations ~n, $V, and !,. The (generic) notation M JJ N is read M halts with answer \nN. We write M J when there is some N with M J N, and M ~ otherwise. The three languages exhibit the same \nbehavior when interpreting conditionals and applications of constants (except for Y) to terms. Figure \n1 contains rules for reducing constants and conditionals to canonical forms. Additional rules for the \nthree interpreters appear in Figure 2. The definition of the call-by-name interpreter re\u00adquires only \ntwo more rules: the usual ~-reduction rule for applying A-abstractions to terms, and the rule for applying \nthe fixpoint combinator Y to a term. Under call-by-name, numerals are the only observable out\u00adcomes of \ncomputations [14]: Definition 4 M P~~&#38; N iffor any PCF context C[.] and numeral k, C [M] J.n k implies \nC [N] .&#38; k. The lazy interpreter also passes arguments by name; the main difference between the call-by-name \nand lazy interpreters lies in the observations one makes about code. In addition to numerals, one may \nobserve in lazy PCF whether a term of functional type halts at a A abstraction or constant. These observations \nare called the termin observations. Lazy PCF also differs from call-by-name PCF in its constants. In \norder to give the programmer the ability to test the termination behavior, we add convergence\u00adtesting \nconstants conv to PCF and call the resulting language LPCF. The observational approximation re\u00adlation \nfor LPCF is defined as follows: Definition 5 M ~~~j~n N if for any LPCF context C[.], 1. C[M] J.l implies \nC[N] J.[; and 2. C[M] 41 k implies C[N] JIz k, fork a numeral.  Call-by-value PCF, in contrast, requires \nthat all arguments in applications be reduced to values. Eval\u00aduating applications of Y also differs from \nthe call-by\u00adname and lazy cases for technical reasons. As in the lazy case, we observe both termination \nand numerals: Definition 6 M ~~~min N if for any PCF context  C[.], 1. C[M] Jlu implies C[N] J.v and \n 2. C[M] .tJ k implies C[N] $V k, fork a numeral.  We need not add the constants conv to call-by-value, \nsince they are definable by Az .Ayr .y. 3 Examples of Fully Abstract Translations 3.1 Call-by-value to \nLazy Figure 3 describes the complete translation of call\u00adby-value to lazy PCF, proceeding by induction \non the structure of terms. In order to achieve full abstraction, the translation forces variables and \nhence any lazy function that instantiates a variabl~to be strict using the auxiliary functions 6 - . \nInformally, 6 +7 checks its second argument y to make sure it halts; the strict version of y is passed \nto z and the result is made strict. V J V, V avalue M J Succ Nun Al J. pred NJ(n+l) (A4N)lJ(n+l) (ihf \nN)urz MJO Nuk A4 .(l pred NJ.10 pcond MN F Jk (M N)JJO JIv(n+l) PJ. k MJJO NJJ. V pcond MNP~k cond MNPJV \nNJJk PJJk MJ(n+l) PJV pcond MN P.lJk cond MN PJ. V Figure 1: Structured rules for applying constants \nand reducing conditionals. r M&#38; ~x.M M [z :=N]&#38; V MJJ. Y (N(YN)) U.V Call-by-name (MN) U. V \n(MN) JJn V M .lJI kr.M M [z := N] J.i V MJJ/Y (N (Y N)) JJ/ V (MN) JJr V (MN) $/ V Lazy M JJ.I conv \n NJJIV (MN) $, kc .z ii I M &#38; ~x.M NUUV M [z := V] Jv V M$OY NJJVV Call-by-value (MN) JJv V (MN) \nu. kz.V (Y V) z uI Figure 2: Additional rules for each of the three interpreters. Succ = Succ pred = \npred Basic Translation F = izu+ .conv z (Y (k .~yo .(6 -0 z) z y)), ~=C71+u2 Axe. M = Ax .conv x % (MN) \n= (ill N) . cond MNP = condikf NP . pcond M NP = pcond MNP 6 = Ax .x Retractions ~.-+, = Azo+ .convz \n(Aya.conv y (6 (x (6 y)))) Figure 3: The complete translation of call-by-value PCF to lazy PCF. 248 Technically, \nthe functions 6\u00b0 are retractions. The fact that 6\u00b0 is a retraction, i.e.,   ~;:;pn (6 (6 M)) (6 M) \n for any term Al of type u, follows by a simple induction on types. Intuitively, this fact states that \nmaking a strict function strict does not change the function. With the addition of these retractions, \nthe transla\u00adtion briefly outlined in the introduction becomes fully abstract: Theorem 7 The translation \nM w ~ from call-by\u00advalue PCF io lazy PCF is fully abstract. That is, M ~~a~min N ~ ~ ~j~:~i ~. Proofi \n(Sketch) We rely on denotational models for call-by-value PCF and lazy PCF. The two models, CVOI and \nC1=ZY, are built using Scott domains of lifted, con\u00adtinuous functions. In the case of Coal, only strict \ncon\u00adtinuous functions are in the model. (Various equiv\u00adalent definitions of these models may be found \nin [4, 5, 18, 22, 23].) Importantly, both models are fully abstract, i.e., The key idea is to show how \nto relate values in C.a/ to values in Cla=v. We use logical relations to relate these two models. Let \nC~d~ denote the values in C.al of type u, and define C~Zu similarly. Then define the relations RO ~ Cfa, \nx Cfizg by induction on types as follows: 1. dR eiffd=e; and 2. f R - giff(f= l~g=l), and for any dR \ne,(f d)R (ge).  This definition should be compared to the definitions in [5, 15, 18]. Two crucial facts \nhold about this logi\u00ad cal relation. First, each RO is subjective on the range of ClaZU[6U]. Second, the \nanalog of the Fundamental Theorem of Logical Relations [25] holds: for any closed M, CVol[ikf] R Clazy \n[~]. The (<) direction of full abstraction follows some\u00ad what routinely from the second fact above. \nFor the converse, suppose ~ ~~j~~i ~ for closed M and N. By the full abstraction theorem, Cla:y [~] ~ \nCla,y [~]. Thus, there are values d~ for which either 1. (Cfa.v [m] rtl . . . A) # ~ &#38; (CI.. VIN] \ndl . ..dn) = 1; or 2. (C/a.v[~] dl --,dn) = k, (CIdzv[N] dl . . .dn) = k , for k, k numerals and k # \nk .  Since all variables are translated to variables applied to the retractions, we may assume that \nthe di are in the range of CI.ZV [&#38; j. By the subjectivity of the log\u00adical relation, there are dj \nsuch that dj R ; di. By the fact that CUal[M] R C/aZv ~, these dj distinguish C~~IIMl and C ~~[Nll, so \nC~~~[M] Q C ~~[N]. BY full abstraction of CVal, M ~~~min N. N 3.2 Call-by-name to Call-by-value We need \na different idea to translate call-by-name PCF to call-by-value PCF. We adopt the familiar idea of thunks, \nviz., A-abstractions that are constant in their first argument, to translate call-by-name PCF to call\u00adby-value \nPCF. All call-by-name terms are mapped ei\u00adther to thunks or to terms that reduce to thunks. This guarantees \nthat all terms and hence all operands in applications terminate, so that the call-by-value in\u00adterpreter \nnever gets stuck evaluating an operand. Unlike the previous example, the translation changes the types \nof terms. For simplicity, we make every term take a dummy argument of type ~ although a dummy argument \nof any type would suffice. Terms of type u are translated to terms of type &#38;, where 1 = /,+/, (U-T) \n= L+a + r The full translation from call-by-name to call-by\u00advalue appears in Figure 4. Again, we need \nto apply retractions to the variables to make the translation fully abstract. In this case, the retractions \ny force terms to be constant functions in their first argument. The definition of the retractions appears \nin Figure 4, and, as before, proceeds by induction on types. Like the translation from call-by-value \nto lazy, this translation is fully abstract: Theorem 8 The translation M H ~ from call-by\u00ad name PCF to \ncall-by-val~e PCF is f~lly abstract. That isMCnum N ~ M~~a~min N. 1 name The proof of the theorem follows \nthe outline of the proof of Theorem 7, and involves constructing a logical relation from the standard \nScott model C~ame for call\u00adby-name [14, 21] to the C.ai model for call-by-value. 3.3 Lazy to Call-by-value \nFigure 4 also gives a translation for lazy to call-by\u00ad value PCF similar to the translation for call-by-name \nto call-by-value. Here, most of the clauses for terms are identical to the call-by-name to call-by-value \ncase. The only exceptions are the definition of the retrac\u00ad tions Xa, the clauses involving these retractions, \nand the additional clause for translating conv. ; = Az .k Smc = AZ . AX - .Az .succ (z 3) p= = W.k + \n.h .pred (x 3) Basic Translation ~x~M = Az .kra .fi, .z # IV (M) (M N) = ((R 3) ti) cond=N P = h .cond \n(~ 3) (R 3) (~~) pcond M N P = k .pcond (fi 3) (R 3) (P 3) ~. -(y z ) P = AZ . AZJ + ) .Y((7 - z) 3) \nCall-by-name to call-by-value 7 = AX . AX .X 3 -f 0+7 = ~z(~+r) .~z~.~y .(7 (Az .x 3 (ya y) z)) p \n== (~ z ) f = AZ . AX( - ) .Y((X +C x) 3) m T conv , = A2 .AX0 .A(AW(AU. (6 . (6 u)) (x 3)Lazy to call-by-value \n= AX . AX .X 3 x U*T = ~z(m+ ) .~z .(~~yay(x.(x (Az .z 3 (f y) z))) (x 3) x Figure 4: Translations of \ncall-by-name and lazy PCF to call-by-value PCF. This translation turns out to be fully abstract as M \n~~~&#38; N for pure terms in elementary recursive well: time: first translate and check whether ~ ~~,%~i \n~. . .-. This is a contradiction, so M c~~min N cannot be Theorem 9 The translation M H ~ from lazy decided \nin elementary recursive time. H PCF to call-by-value ~CF is full~ abstract. That is, M ~;jj~in N ~ M \n~;jmin N. This corollary implies that deciding M ~$.{mi N re\u00adquires at least iterated exponential time. \n Again, the proof of full abstraction follows along the Along similar lines, one can show that the problem \nsame lines, by constructing a logical relation from lazy of deciding M ~j~~~in N for pure conv-terms \n(those model Cr~ZV to the call-by-value model Cv~~. cent aining only the constant conv) is not elementary \nrecursive. In fact, the decision problems M ~~~~~in N  3.4 Bounds on Deckion Procedures for pure conv-terms, \nand M ~~~min N for pure terms, Proving M C mN for pure terms i. e., constant are equivalent under polynomial-time \nreducibility: this name and conditional-free terms coincides with ~q-equality follows immediately from \nthe fact that there are linear for pure terms [15]. Thus, since ~~-equality of pure time reductions via \nthe translations between these terms is not elementary recursive [24], testing to see two problems. whether \nM ~~~~e N for pure M and N is not ele-We conjecture the following upper bound: ment ar y recursive. From \nthe fact that the translation from call-by-name to call-by-value PCF works in lin- Conjecture 11 The \ndecision problem M ~fiJmin N ear time, we can obtain a lower bound on the decision for pure M and N can \nbe solved in iterated exponential procedure for call-by-value PCF. time. Thus, the problem of deciding \nM c~~~~tn N for M and N pure conv-terms can also be solved in iterated Corollary 10 The following question \ncannot be de\u00adexponential time. cided in elementary recursive time: given two pure PCF terms M and N, \nis it the case that M ~~a~min N ? It is already known that the problem of M E m N for name Proof: Suppose \nthe question can be decided in ele-pure M and N can be decided in iterated exponential mentary recursive \ntime. Then one may decide whether time [20, 24]. Functional Translations 4.2 Definition of Functional \nTransla\u00ad 4.1 Godel numbering Translations Not all translations between programming languages share the \nstructure of the two translations above. It is reasonably easy, for instance, to design fully abstract \ntranslations that are not effective. But even the condi\u00adtion of effectiveness is not sufficiently strong \nto rule out unreasonable translations based on Godel numbers. Consider the case of translating lazy into \ncall-by-name. Theorem 12 There exisi!s an effective translation of lazy PCF to call-by-name PCF preserving \no&#38;erva\u00adtional congruences. That is, there exists M w M such that M ~f:;3in N u ~ ~:::e fi. Proofi \n(Sketch) We translate an LPCF term M to (1 #Lf), for some G6del numbering #of LPCF terms. Here, the closed \nterm 1:1 + t + t represents a two\u00adargument interpreter for lazy PCF written in call-by\u00ad name PCF, where \nthe first argument is the term to in\u00adterpret and the second argument is a Godel-numbered tuple of arguments \nto ill (possibly an empty tuple). It is not hard to design such an interpreter meeting the following \nrequirements: 1. (1 #A4 (n~,..., rim)) fin if any of n~,..., nm is not the Godel number of a closed term; \n 2. (I #M (#NI ,..., #Nm)) fin if the lazy term (M N1... Nm ) is not well-typed; 3. (l#M(#N,,..., #Nm)) \n&#38; iff itis the case that (M N,.. .N~)$/; and 4. (~ #M (# N1,..., #Nm)) J$n k iff it is the case \nthat (i14 Nl . . .Nm) lJ.l k;  To verify that the translation preserves observational congruences, \nsuppose M $~~~~in N with M and N having type al + ... + an + 1. By the Context Lemma for Lazy PCF ( cj. \n[8, 14, 17]), there are terms PI, ..., Pm such that either l.(MP1.. .Pm) $1 but (N PI . .. Pm) ~r; or \n2.( MP1.. .Pm) lJl k but (N PI . . .Pm) $( k , where k#k andm=n. By the properties of 1, (fiJ#P1, . \n. . . #Pm)) yields a different observation than (N (#Pl, . . . . #Pm)). Thus, ~ ~~~~e X. The converse \nfollows similarly and is omitted. Similar translations based on Godel numbers can be found between almost \nall universal programming lan\u00adguages. tions The existence of fully abstract translations becomes a trivial \nproblem unless we limit translations in some way. Mitchell, for example, considers only composi\u00adtional \ntranslations [9]. Nevertheless, compositionality alone is too weak to rule out translations based on \nGodel numbers. The above translation from lazy to call-by-name can, for instance, be made compositional \nby explicitly computing the Godel number and apply\u00ading the resultant term to the interpreter function \n1. The translations of Section 3 enjoy a few other prop\u00aderties. It is instructive to first consider the \ntranslation from call-by-value PCF to lazy PCF. This translation not only preserves observational congruences, \nbut also translates call-by-value functions into strict lazy func\u00adtions. The lazy versions of call-by-value \nterms are in some sense functionally equivalent to their original versions: the translates of terms of \ntype J produce the same values as the original terms, and the translations of functionally-typed terms, \nwhen provided with strict functions, return strict results. The connection between call-by-name terms \nand their call-by-value translates is not so clear: trans\u00adlated terms take dummy arguments and hence \nrepre\u00adsent different functions. Nevertheless, some of the be\u00adhavior of a translated term maybe recovered \nthrough a call-by-value definable function proj. At ground type, proj : t -+ t is the function that applies \na (call-by\u00advalue) term of type t to a dummy argument (say 3) to obtain a numeric result. An inverse to \nproj , called inj L : L + L , is also definable in call-by-value PCF; this function maps a number n to \nthe constant func\u00adtion Az .n. Similarly, one can define call-by-value functions proj + :(a+T) +c7 +T \ninjg-r : (a + T )+ (a + T)  at higher type. Informally, (proj - M) applies M to 3 to obtain a function \nfrom representations of type u to results of type r . The term inj - is the inverse of proj U*T: (proj \n(inj N) ~~min N. In fact, one can define inj and proj with (inj (proj N)) EfJm*n (~ N). Finally, the \ntranslations each use a uniform repre\u00adsent ation of source language code. We use a general form of logical \nrelations to capture the idea of a rep\u00adresent at ion. Let Z be the set of closed Z-terms of type a. If \nM w E takes Ll terms to .@ terms, the relations R will relate Z? terms to C; terms. To simplify the definition, \nwe allow only those lan\u00adguages in which applicative contexts are sufficient to distinguish non-observationally \ncongruent terms. For\u00admally, a simply-typed language ,C1 is operationally ez\u00adtensional if &#38;f ~~~ N \nimplies that for some terms Pi, (M P,... P~) and (N PI. . . P~) produce different observable [2, 3]. \nAlso, suppose~l and C2 be simply\u00adtyped languages with observable 01 and 02, where 01 ~ 02; then we write \nibf * N, for M a closed ,C1-term and N a closed &#38; term, if M produces an observable in 01 under Z1 \niff N produces the same observable under L2. Definition 13 Let L1 and C2 be simply-typed lan\u00adguages with \nobservab~s 01 and 02, where 01 C 02. A translation M H M of L; to L; is a functional translation if there \nexist L2-definable maps proj :L -+L inj L :L--+L proj - :(u+T) +a +T injo+T : (u + T )+ (u --i r) such \nthat 1. Logical relation: M R %, where (a) MR NiflM+(proj N); and (b) M R +r N iff M $ (proj + N), and \nP R Q implies that (M P) R (N Q), where N Q = ((proj +T N) Q). 2. Non-congruent representations are \ndistinguishable by applicative contexts: Suppose M and N are in the range of R and M $~~ N. Then there \nare Pi where (proj (M o PI . . . Pk)) produces a different O1-observable than (proj (NOPIO. . . Pk)). \n 3. Injections are the inverses of projections: For any closed L2 term N, (proj (inj N)) ~~~ N.  Representations \ncan be built by injections: For any closed ,C2-ierm N, (inj (proj N)) is in the range of R . Also, if \nN is in the range of R , (inj (proj N)) ~~~ N. 4 5. Projections force arguments to be in the range of \nR: For any terms M and N, M N =~~ inj (proj (M o (inj (proj N)))) This definition should be compared \nto the definition of the relations given in the proof of Theorem 7. Every functional translation is fully \nabstract: Theorem 14 Let L1 be any simply-typed, oper~ tionally extensional language, and suppose M I-+ \nM is a functional translation from L~ to Lz wifi projec\u00ad tions proj and injections inj . Then M w M is \nfully abstract. Proofi Suppose first that lf ~~~ N. Then by opera\u00adtional extensionality, there exist \nterms Pi and k > 0 with (M PI . . . P~ ) producing a different observable than (N PI . . . P~ ). By the \ndefinition of logical trans\u00ad lation, (proj (Me PI .. . ~)) produces a different ob\u00ad - servable than \n(proj (N OPIO. . .oPk)). Thus, M ~~~ N. Conversely, suppose fi +$; X. As E and X are in the ran~e of \nR , there exist closed ,C2-terms Pi with (proj(Mo P1 o... pk )) producing a different fll\u00ad observable \nthan (proj (X P1 ... pk )). Without loss of generality, the definition implies that we may choose \nPi in the range of Rot. Thus, let (P1 R Pi); then by the definition of the relations R, (M P/... P{) \nproduces a different observable than (N P/... Pi). It follows that M #~: N.  4.3 Distinctions Made by \nFunctional Translations The translations of Section 3 demonstrate that, in some sense, call-by-value \nPCF and lazy PCF are equiva\u00ad lent under the notion of functional translation: each can be translated \ninto the other. Call-by-name PCF can be translated into call-by-value as well, but call-by\u00adname PCF is \nstrictly less expressive than call-by-value PCF under the notion of functional translation. To keep the \nset of observations uniform between the two languages, we say that a closed call-by-name term M of type \na -+ T converges iff !2\u00b0+ +~~fle M. (Note that this is an r.e. property of terms, and adding this observation \ndoes not refine the relation ~~~&#38;. ) Then Theorem 15 There is no functional translation from call-by-value \nPCF to call-by-name PCF. Proof: Suppose M * fi is a functional translation with projections proj u and \ninjections inj , Let fll and Q2 be divergent lazy PCF terms of types t + L and ~ respectively. By the \ndefinition of functional trans\u00ad lation, fll R - % and ~x.S12 R - A~Q2. Thus, Q, * (proj - ~) and Ax.f12 \n+ (proj + A~Q2). As !21 and /lx.i22 produce different observable outcomes under the call-by-value PCF \ninterpreter, (proj + Z) 7%2 (proj - AZ.Q2) since they must produce different observable under the call-by-name \nPCF interpreter. However, by the definition of functional translation, ((proj +4 kz.Q2) N) for any closed \nN diverges. Sim\u00ad ilarly, ((proj + ~) N) diverges. As we are dealing with the call-by-name theory, (proj \n- R) %%e (woj - iZ22) This is a contradiction, so there can be no functional translation from call-by-value \nPCF to call-by-name PCF. A similar proof shows that there is no functional trans\u00adlation from lazy PCF \nto call-by-name PCF. The notion of a functional translation can also be used to compare languages with \nmore features to those with fewer features. For example, let sequential call\u00adby-name PCF be call-by-name \nPCF without parallel conditional. Then Theorem 16 There a s no functional translation from call-by-name \nPCF to sequential call-by-name PCF. Proof: Suppose, by way of contradiction, M w E is a functional translation \nwith projections proj and injections inj . Let por :t+L+hbea termof call-by-name PCF with the following \nbehavior: (per ON) s~g%. O (per NO) ~~~~e O (per m n) S~~&#38; 1 if m, n are nonzero numerals where \nN is any closed term of type ~. Note that por is definable in call-by-name PCF but not in sequential \ncall-by-name PCF [14, 19]. However, the term P = Xr .J~ .proj (p%r (inj z) (inj y)) defines por in \nsequential call-by-name PCF. This is a contradiction, so there can be no functional translation from \n(parallel) call-by-name PCF to sequential call-by\u00adname PCF. H Open Problems We have explored situations \nin which well-structured, fully abstract translations exist. The three fully ab\u00adstract translations of-Section \n3 differ in one respect from the well-known translations: retractions are used on variables to force \ntarget language terms to be le\u00adgal representations. We have also given a definition of good translations \nthat rules out Godel number\u00ading translations, and shown that certain languages are strictly more powerful \nthan other programming lan\u00adguages. It seems quite likely that other structured, fully ab\u00adstract translations \nexist between other functional lan\u00adguages. For instance, the examples above deal only with simply-typed \nlanguages. Using a fairly natural modification of the retractions in the call-by-value to lazy case, \nthere is a well-structured translation from the untyped call-by-value J-calculus to the untyped lazy \n%calculus. The proof relies on two models: the fully abstract model for the lazy A-calculus [1, 11, 12], \nand the fully abstract model for the call-by-value A\u00adcalculus composed of lifted, strict continuous functions \n(Felleisen and Sitaram, personal communication). In\u00adstead of logical relations, we use inclusive predicates \n[16]. This example should provide clues for adding gen\u00aderal recursive types, as well w sums and products. \nAll three of the languages we have explored incor\u00adporate parallel conditional. Of course, we would like \nsequential fully abstract translations as well, e.g., from sequential call-by-value PCF to sequential \nlazy PCF. We believe our methods will carry over to this problem with little modification. Extending \nthe languages with other features, such as those captured by monads [10] (e. g., exceptions), also would \nbe useful. We expect that the definition of logical relations to be different in these cases, and hence \nan expanded definition of (functional translation may be necessary. We have also only briefly discussed \nhow the notion of functional translations leads to a definition of expressiveness. Our translations show \nthat, in some sense, call-by-value and lazy PCF are equally expres\u00adsive whereas call-by-name PCF is strictly \nless expres\u00adsive than either of these languages. But there is much more work to be done in exploring \nthis definition of expressiveness. Examining the algebraic properties of functional translations would \nbe a good start; for ex\u00adample, functional translations should be closed under composition. We leave this \ninvestigate ion open as well. Acknowledgments I especially thank Albert Meyer for the suggestion of \nthis problem and many productive conversations. I also thank Samson Abramsky, Val Breazu-Tannen, Stavros \nCosmadakis, Matthias Felleisen, Carl Gunter, Eugenio Moggi, and Gordon Plotkin for helpful discus\u00adsions, \nand Michael Ernst, Lalita Jategaonkar, Trevor Jim, Arthur Lent, and David Wald for comments on drafts \nof this paper, References [1] Samson Abramsky. The lazy lambda calculus. In David A. Turner, editor, \nResearch Topics in Functional Programming, pages 65 1 17, Addison-Wesley, 1990. [2] Bard Bloom. Can LCF \nbe topped? In 3rd Symp. Logic in Computer Science, pages 282-295. IEEE, 1988. [3] Bard Bloom. Can LCF \nbe topped? flat lat\u00adtice models of typed A-calculus. Information and Computation, 87:264-301, 1990. [4] \nBard Bloom and Jon G. Riecke. LCF should be lifted. In Teodor Rus, editor, Proc. Conf. A/ge\u00adbraic Methodology \nand Software Technology, pages 133 136. Department of Computer Science, Uni\u00adversity of Iowa, 1989. [5] \nStavros S. Cosmadakis, Albert R. Meyer, and Jon G. Riecke. Completeness for typed lazy in\u00adequalities \n(preliminary report). In 5th Symp. Logic in Computer Science, pages 312 320. IEEE, 1990. [6] Matthias \nFelleisen. On the expressive power of programming languages. In Proc. of European Symp. on Programming, \nLect. Notes in Computer Sci., pages 134-151. Springer-Verlag, 1990. [7] Albert R. Meyer and Jon G. Riecke. \nContinua\u00adtions may be unreasonable. In Proc. C onf. LISP and Functional Programming, pages 63 71. ACM, \n1988. [8] Robin Milner. Fully abstract models of the typed lambda calculus. Theoretical Computer Sci., \n4:1\u00ad22, 1977. [9] John C. Mitchell. Lisp is not universal (summary). Unpublished manuscript, August 1986. \n [10] Eugenio Moggi. Computational lambda-calculus and monads. In 4tb Symp. Logic in Computer ScZ\u00adence, \npages 14 23. IEEE, 1989. [11] Chih-Hao Luke Ong. Fully abstract models of the lazy lambda calculus. In \n29th Symp. Foundations of Computer Science, pages 368 376. IEEE, 1988. [12] Chih-Hao Luke Ong. The Lazy \nLambda Calculus: An Investigation into the Foundations of Func\u00adtional Programming. PhD thesis, Imperial \nCol\u00adlege, University of London, 1988. [13] Gordon D. Plotkin. Call-by-name, call-by-value and the ~-calculus. \nTheoretical Computer Sci,, 1:125-159>1975. [14] Gordon D. Plotkin. LCF considered as a program\u00adming \nlanguage. Theoretical Computer Sci., 5:223 257, 1977. [15] Gordon D. Plotkin. Notes on completeness of \nthe full continuous type hierarchy. Unpublished manuscript, MIT, November 1982. [16] John C, Reynolds. \nOn the relation between direct and continuation semantics. In Proceedings of the Second Colloquium on \nAutomata, Languages, and Programming, Lecture Notes in Computer Science 14, pages 141-156. Springer-Verlag, \n1974. [17] Jon G. Riecke. Should a function continue? Mas\u00adter s thesis, Dept. Electrical Engineering \n&#38; Com\u00adputer Sci., Massachusetts Institute of Technology, January 1989. Supervised by A.R. Meyer. \n[18] Jon G, Riecke, A complete and decidable proof system for call-by-value equalities (preliminary re\u00adport). \nIn 17 h ICALP, volume 443 of Lect. Notes in Computer Sci., pages 20 31. Springer-Verlag, 1990. [19] V.YU. \nSazonov. Expressibility of functions in D. Scott s LCF language. Algebra i Logika, 15:308\u00ad330, 1976. \n(Russian). [20] Helmut Schwichtenberg. Complexity of normal\u00adization in the pure typed lambda-calculus. \nIn A.S. Troelstra and D. van Dalen, editors, The L.E. J. Brouwer Centenary Symposium, pages 453-457. \nNorth Holland, 1982. [21] Dana Scott. A type theoretical alternative to CUCH, ISWIM, OWHY. Oxford University, \nun\u00adpublished manuscript, 1969. [22] Kurt Sieber. Relating full abstraction results for different programming \nlanguages. In Foundations of Sofiware Technology and Theoretical Computer Science, Bangalore, India, \nDecember 1990. To ap\u00adpear. [23] Dorai Sitaram and Matthiaa Felleisen. Reasoning with continuations II: \nFull abstraction for models of control. In Proc. Conf. LISP and Functional Programming, pages 161-175. \nACM, 1990. [24] Richard Statman. The typed A-calculus is not el\u00adement ary recursive. Theoretical Computer \nSci., 9:73-81, 1979. [25] Richard Statman. Logical relations in the typed A-calculus. Information and \nControl, 65:86-97, 1985. -Cambridge, MA October 22, 1990  \n\t\t\t", "proc_id": "99583", "abstract": "", "authors": [{"name": "Jon G. Riecke", "author_profile_id": "81339524439", "affiliation": "MIT Laboratory for Computer Science", "person_id": "PP39077806", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/99583.99617", "year": "1991", "article_id": "99617", "conference": "POPL", "title": "Fully abstract translations between functional languages", "url": "http://dl.acm.org/citation.cfm?id=99617"}