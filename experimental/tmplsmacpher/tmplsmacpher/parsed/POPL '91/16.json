{"article_publication_date": "01-03-1991", "fulltext": "\n Modeling Continuations without Continuations Dorai Sitaram* anld Matthias Felleisen* I)epartment of \nComputer Science Rice University Houston, TX 77251-1892 Abstract Traditional denotational models of \nlanguages with control operators rely on Strachey and Wadsworth s continuation semantics. Such models \nrepresent the ef\u00adfects of control operations by tacking on an additional function argument, the continuation, \nto all denota\u00adtions. In essence, a continuation semantics encodes a stack machine for the language where \nthe continu\u00adation is a functional representation of the stack. As we have shown recently, a continuaticm \nmodel can ac\u00adcuratel y describe the behavior of a control language, provided the latter has a sufficiently \nstrong control structure. In this paper we investigate a new class of models for control operators. These \nmodels do not rely on the continuation-passing technique but build the required information for control \noperations upon demand. In cent rast to the cent inuat ion framework, there is a pair of simple projection/injection \nfunctions between the direct model for the core language without con\u00adtrol operators and the extended \nmodel for the full lan\u00adguage. Like the continuation model, the new models provide accurate descriptions \nof languages with con\u00adtrol operators and control delimiters. For the design of programming languages, \nour analysis points out that control operators need a cooperative exception\u00adhandling facility. Supported \nin part by NSF and DARPA. Permission to copy without fee afl or part of this material is granted provided \nthat the copies are not made or distributed for direct commercial advantage, the ACM copyright notice \nand the title of the publication and ita date appear, and notice is given that copying is by permission \nof the Association for Computing Machinery. To copy other\u00adwise, or to republish, requires a fee and/or \nspecific permission. @ 1990 ACM 089791-419-81901001210183 $1,50 1 Modeling control without special effects \nProgramming language operators for control manip\u00adulation provide expressive and efficient programming \nabstractions. These constructs grant access to (ftrst\u00adclass) abstractions of the control state in the \nform of control objects. Virtually all programming languages are equipped wit h some form of cent rol \noperators. Although the study of denotational models is use\u00adful for understanding and reasoning about \nlanguages, these analysis techniques have not been exploited for languages with control. The traditional \nsemantics for control operators and control objects uses the Strachey and Wadsworth con\u00adtinuation model \n[25]. Our recent study of this model showed that it has the ability to restrict the reach of control \noperators. This capability is usually not avail\u00adable in modern languages. The language requires a control-delimiting \noperator to allow an accurate cor\u00adrespondence between model and language. However, the continuation model, \nwhile popular (indeed, the control objects provided by the language are often dubbed continuations ), \ndiffers radically from the basic direct model for languages without control. The denotations of language \nphrases demand an additional continuation argument, and it is diffi\u00adcult to relate them to the denotations \nin the direct model for the language without control [19, 21, 24]. In this work, we investigate the consequences \nof us\u00ading the more uniform approach of having extensions of the basic direct semantics [8] as models \nfor lan\u00adguage extensions. Extending a direct model requires only an incremental alteration to the base \nmodel. In our specific case, languages wit h continuations have models without special continuation functions. \nOur study also shows that, like the continuation model, the extended direct model furnishes a perfect \nmatch with a language, provided the latter has a sufficiently expressive control structure. The following \nsection introduces the syntax and an informal description of the language PS and some of its control \nextensions. Section 3 describes the direct model for PS. The fourth section explains the tech\u00adniques \nused to obtain extended models for PS en\u00adhanced with control facilities. Section 5 discusses re\u00adlated \nwork, and the final section interprets our techni\u00adcal results for the design of programming languages. \n 2 PS and its control extensions PS is the purely functional subset of Scheme. It is essentially the \nuntyped call-by-value A-calculus [16] with integers and some basic procedures, A control extension of \nPS is plain PS enhanced with one or more cent rol constructs. 2.1 Ps Figure 1 describes the syntax of \nPS. PS terms are ei\u00adther values such as numbers, basic procedures, and A-abstractions, or non-values \nsuch as variables and (procedure) applications, The basic procedures in\u00adclude a conditional (with O serving \nas false and any\u00adthing else as true), arithmetic functions and the pred\u00adicate int?. The A-abstractions \nintroduce new by-value procedures. A program is a PS term without free variables. On evaluation, a program \neither converges to an answer value or diverges. In the evaluation process, basic procedures have their \nexpected behavior; applications are evaluated from left to right before the argument is passed to the \nprocedure. 2.2 Control extensions Evaluating subterms in a PS program involves keep\u00ading track of the \nrest of the evaluation, or the evaiua\u00adiion context. In a machine, this information is usually represented \nas a stack; in rewriting systems, it is the textual context surrounding the current redex. Con\u00adtrol operators \nexploit an abstraction of the evaluation context to allow manipulation of the control flow in a program. \nWe shall consider abort, call/cc [26], C [10], and control [9] as additions to PS: abort stops the normal \nevaluation of a program, and replaces its evaluation context with its subexpression. can/cc is a procedure \nthat applies its argument to a procedure that is an abstracted form of the sur\u00adrounding evaluation context. \nIt leaves the evalu\u00adation context intact. In analogy to denotational semantics, Scheme refers to the \nabstracted con\u00adtext as a continuation. (Indeed, call/cc abbre\u00adviates call-with-c urrent-continuation \n.) On ap\u00ad plication, this cent inuation replaces its current evaluation context in favor of the one that \nwas captured, sending its argument to the old con\u00ad text. C is similar to can/cc except that a C-application \ndoes not implicitly invoke its continuation. and the combination abort and call/cc can ex\u00adpress [7] each \nother: see Figure 2. control, in contrast to call/cc and C, provides a func\u00adtional continuation to its \nargument. Upon in\u00advocation, the functional continuation installs its context without throwing away the \ncurrent one. As shown in Figure 2, control can express all the other constructs. A different kind of \ncontrol construct is the control delimiter or prompt (#) [6, 22]: # constrains control manipulation occurring \nwithin its dynamic extent. In other words, a prompt\u00adexpression treats its sub expression as an inde\u00adpendent \nprogram, insofar as control action is concerned, Prompts are an important component of the full abstraction \nresult for cps models [23]; we shall find them useful here, too. These operators are sufficiently abstract \nto capture other popular variations such as escape [18], Iswim s J [13], GL s state [12], spawn [11], \nshift and reset [5].  2.3 A small library Many elementary procedures and forms are easy derivations \nfrom the core of PS. Here we list a couple that are useful below. A conditional form if is the syntactic \nextension (d@ N, P): if M N P = (ef M (Ad. N) (Ad. P))rO . Here, Ad.iV is the thunk form of IV, and is \ndis\u00adcharged by applying it to a dummy value, rol, . A typical PS program that fails to converge is The \nfixpoint combinator Y provides a tool for defining recursive procedures: Y s Af. (Aw.ww)(Az.f(Az. (z2)z)), \n  M := Vlzlkfiw v := Cl flk.kf (values) c . (integers) f ;: t+ I 1 I int? ef (basic procedures) Control \nadditions to PS ill := abort J4 Icall/cc M IC M Icontrol M I# M Figure 1: Syntax of PS. abort M s C(M.M) \ncall/cc s Af.c(Ak.k(f-k)) C ~ Af.call/cc (Jk.abort (fk)) C s Aj.contrd(M.f(Av. control (M.ku))) Figure \n2: The expressiveness e Any value that is not a number is a procedure: proc? E Av.if (int? V) () 1 , \n  3 Modeling PS A model for a language consists of a structure, the domain, and an interpretation or \nmeaning function that maps phrases from the language to values in the structure. This section summarizes \nthe tools for building models, the direct model for PS, and some of its properties. 3.1 Information systems \nWe use Scott s [20] information systems approach to construct the domains for the basic direct model \nand its extensions. The appendix summarizes the salient features of information systems. An information \nsystem domain is a collection of consistent, deductively closed sets of propositions. A finite element \nis (the deductive closure of) a finite set of propositions. The complete domain is isomorphic to the \nideal closure of its finite elements, and hence the latter suffice for studying the domain. The sub\u00adset \nrelation on the sets composing the elements gives an ordering ~ on the domain. e.g., disjoint sums (~), \nstrict reflexi~e dorrmim, etc., consist nite elements in terms of the constituent domains. Domain constructions, \nfuncticm spaces (~~), in enu,merat ing the fi\u00ad finite elements of the of abort, call/cc, C, and control. \n 3.2 The direct model for PS The direct model for PS is a reflexive domain D that contains integers and \nstrict functions on itself D= &#38;, @ (D+. D). integers procedures The appendix shows how to build \nsuch a domain as an information system. The tags inO and inP refer to elements in the sub domains for \natomic Observables and Procedures, respective y. E.g., the elements for the number 9 and the procedure \nthat maps 1 to 1 (and everything else to 1) are respectively inO(9) and in P({(inO(l), inO(l))}). In \nthe latter case, the set containing the pair denotes a finite consistent proposition in the information \nsystem for D ~ D and the overline denotes its deductive closure. This notation rapidly becomes unwieldy \nfor larger proce\u00addures. We subsequently use the more concise notation in P(inO(l) = inO(l)) to denote \nthe same procedure. To avoid clutter, we can further omit the tags when there is no ambiguity. The function \nZl (Figure 3) defines the meanings of PS terms. Enu is a pings from variables to 1), The meaning of \nfliJIP] = ?XIP]l, where In the following, the D + D are the semantic set of environments or map\u00addomain \nvalues (other than a PS program P is simply 1 is the empty environment, functions freeze and thaw : counterpart \nof forming and discharging a thunk: jree.ze(v) = inP(~d.v) thaw(j) = apply (f, inO(0))  3.3 Semantic \nequivalence relations The model determines two natural equivalence rela\u00adtions on the language terms [14]. \nFirst, there is the relation based on their meanings in the model. Definition 3.1 Two terms M and N are \ndenotation\u00ad ally equivalent, M S N, if Zl[ill] = Z[N]. The second relation describes the behavior of \nterms as it appears to the programmer. For the latter, the only way to witness a term s effect is by \nusing it as a subterm in a program, and then observing the program s behavior (meaning). In this view, \ntwo terms are indistinguishable if one can be substituted for the other in any program without affecting \nthat program s meaning. For our purposes, it is enough to measure the termination behavior .1 In the \nfollowing, a context C[ ] is a PS term with a hole where a subterm should be; a program context for a \nterm is a context that becomes a program when filled with that term. Definition 3.2 Two terms Al and \nN are observa\u00adtionally equivalent, M H N, if for all C[ ] that are program contexts for Al and N, 24 \n[C[lvf]] = 1 iff LI [C[N]] = 1. For example, A~.f2 N ~~.(fll )f): no program context can distinguish \nthem. On the other hand, Az .!2x # 0: the first term converges in the empty context, whereas the latter \ndiverges. Owing to the compositional definition of X, it fol\u00ad lows that A4 = N implies C[&#38;f] = C[N] \nfor all pro\u00ad gram contexts C[ ], i.e., ill LX iV. The converse prop\u00ad erty is more interesting, viz., \na model should not give different meanings to two language terms, if it cannot distinguish their behavior \nthrough any program con\u00ad text. This property is called full abstraction [14, 17]. Definition 3.3 A model \nis fuily abstract if for any two terms M and IV in the language, M ~ N iff MEN. 3.4 Full abstraction \nof the direct model for PS+pif Full abstraction fails for a model when the latter has some capability \nthat cannot be mimicked in ] For a better understanding of higher-order data, we would have to use a \nmore sophisticated denotational framework [4]. the language. For PS, this capability is the deter\u00administic \nparallel conditional [17]. The model uses this conditional to distinguish the terms MU (u = o, 1): Mu \n= Az.if (ic(M. l )(M.$J)) (if (X(kl.fl)Od.rl )) (if (8( M. 0 )(M. 01)) Q u ) Q) Q. Although M = N, M \n# N, for applying their deno\u00adtations to the denotation for parallel disjunction on thunks: i nO(0) if \nboth thaw(m) and thaw(n) are pore = inP~m, n. zero J_ if both are J\u00adinO( 1) otherwise { yields O and \n1 respectively. In other words, 21[Mo]p and !2i[M1]p are different functions in D +~ D. To rectify this, \nPS is enhanced with the operator pif, which is similar to if, but can yield a result even when the test \nfails to converge. For convenience we shall use the thunk form pif@ where: pif M N P G pifd (M.M) (M.N) \n(kl.P). The semantics of pife is given by: fl[pife]p = inP(pi~O) where pif e~ { thaw(t) if thaw(b) is \nneither zero nor 1\u00adthaw(e) if thaw(b) is zero inO(i) if thaw(t) = thaw(e) = &#38;b, t,e. { inO(i), a \nnumber in P(~v.pif ~ t (freeze) (freeze (PV))) if %[N]p = in P(n), 2i[P]p = inP(p), i.e., both are procedures \n\\ The form pif defines parallel-or on thunks as fol\u00adlows; por = )irn, n.pif (rnrO ) 11 (pif (n O ) 1 \n O ) It is easy to verify that %[por] 1 = poro, and that by using the context [ ]por in PS+pif, MO + \nMl. Unlike the typed languages PCF and PCF , [17, 23], the PS form of pif has to deal with procedures \nin the branches of the conditional, in D = O(B(D+,D) !2(: Tevms + Env + D Xrn ]p = inO(n) fl[f]p = inP(f) \nz!qz]p = p[.] 2i[k.M]p = inP(Av : D.fl[Mlp[~/~1) 21[ikrN]p = c4pphJ(2q ]p, !2qfv]p) apply : DXD+. D \napph(inp(f), a) = $(a) appig(f, a) = 1, for other domain values Figure 3: The semantic functions for \nPS. which case it postpones the decision until the proce\u00addures are applied. Call-by-name versions of \nPS with\u00adout constants require similar treatment [1, 15]. The proof of full abstraction for PS+pif requires \nthat all finite elements of the model be definable in the language. Lemma 3.4 For all finite elements \ne, ~, 1. e is definable; 2. inP(e + 1), if it exists, is definable (this is a proce\u00addure that takes \ne and anything above it to true, others to 1); and  3. inP((e * l)u(~ + O)), if it exists, is definable \n(this is a procedure that takes anything dominating e to true, anything dominating ~ to false, and the \nrest to 1).  Proof sketch. The proof of the lemma basically follows Plotkin s proof for PCF [17], with \ntwo excep\u00adtions. First, there are no strong types that allow an induction on the type structure. Second, \nsince the dynamic type of an application is unpredictable, tak\u00ading lubs does not translate to checking \nthe equality of integer values as in the PCF proofs. .4n induction on the size (based on the constituent \npropositions) of a finite element and the generalized pif address these issues, The proof of full abstraction \nof the model follows from the lemma. Theorem 3.5 The direct model is fully abstract for PS+pif, Proof \nsketch. Assume that M $ N. We now need to show that M # N, i.e., there is a program context 189 distinguishing \nthe terms. Both 2i[M]p and fl~~]p (for any p) cannot be 1. If one of them is 1, a con\u00adtext that merely \ncloses the terms differentiates them. If one of them is a number and the other a proce\u00ad dure, the procedure \nint? tells them apart. If both are numbers, simple arithmetic operations suffice. And if both are procedures, \nthen applying them to a finite number of finite elements produces a number or J_ for one and something \nelse for the other, which can then be distinguished as above.  4 Modeling PS S control ex\u00adtensions Extended \ndirect models [8] accommodate the lan\u00adguage extensions of PS. The basic domain D satisfies: integers \nprocedures P\\ ~1 = Q @ D+ SD D=D An extended domain introduces an additional subdo\u00admain for the denotations \nintroduced by the language extension: integers procedures /\\ D: = T @(D:-, De) De= D:@ r(% e) extension \nvalues We use tags in L and in R to refer to the left and right sub domains of De. Additional clauses \nfor the semantic function X de\u00adfine the meanings associated with the language ex\u00adtensions: M. : PSe +Env \n+Da. The environments map variables to values that are neither 1 nor the extended values. A modified \nver\u00adsion of the semantic function app~y shows the deno\u00adtational effect of the new domain values. Finally, \na function strip transforms the meanings of programs into denotations that are the counterparts of values \nfrom the original subdomains. Extending a domain may modify some existing sub\u00addomains that depend reflexively \non the whole do\u00admain, but it does so in an easily predictable manner. More precisely, a pair of functions \n@ : D ~ D, and V : D. A D connect the domain D and its extended counterpart De. @ injects values from \nthe unextended domain D to their counterparts in the larger domain D.; Q projects values from the extended \ndomain D, to the smaller D: inL(v) if v = inO(n) o(v) = inL(in P(@ o f o W)) if v = inP(~) { w if w \n= in L(inO(rt)) w(w) = inP(Vo~o Q) if w = inL(inP(~)) L if w = inR(u) { In short, the two mappings are \na pair of projections. With these projections, it is possible to approximate the extended denotations \nof phrases in the core lan\u00adguage using their old denotations, and to recover the old meanings of such \nphrases using their new mean\u00adings. Theorem 4.1 ([8]) If M is a PS expression, and p and p are environments \nsuch that p : Vars + D and p : Vars + D:, then n[l$f]p = w(!2te[M](outl o @ o p)) and 0( ZI[A4](T o inL \no p )) ~ 21. [M]p where outl removes the in L tag of its argument. 4.1 Modeling PS +abort The extended \nmodel for PS+abort illustrates the technique of extending a direct semantics to include a new language \nfeature. The extended domain Da satisfies the following equat ione: integers procedures /% ill: = 9 @(D: \n+, Da) Da= D:@ Da abort values The tag inA (same as in R) refers to elements in the subdomain for Abort \nvalues. The semantic function tia maps terms in PS+abort and environments to values in Da, an d is similar \nto 2( for terms that do not include abort. The additional semantic clause for abort is: !Xa[abort M]p \n= W(fl. [M]p), where W = inL o strip. Figure 4 defines apply and strip. The new func\u00adtion app~y describes \nhow abort-values ignore their surrounding context. Unlike in the cps model, it is trivial to specify \nleft-to-right or right-to-left evalua\u00adtion for applications involving aborts. The function strip removes \nthe tags associated with abort values to yield the result of a program. The denotation of a program P \nis !ilj [P]= strip(%a [P]l). The parallel-if construct for PS+abort differs slightly from the one for \nplain PSI since it must ac\u00ad commodate control action in the branches. The se\u00ad mantics of the new pif \nis: %[pifO]p = . . . as for plain PS abort(pif@ b (freeze(p)) (freeze(g))) if thaw(t) = inA(p) and thaw(e) \n= inA(q){\u00ad l?ull abstraction for PS+abort Models for control usually have the ability to de\u00ad limit control \n[23]. This is also case for the extended direct model, e.g., D: ~ D: contains the function ~0.strip(thaw \n(0)) that constrains the aborts in its argument thunk. This function can distinguish the denotations \nof the terms MU S Az.equal? (.z(ki.abort l )) (.z(kt.abort u )), where u = 1, 2, and equal? has the \nusual defini\u00ad tion. Differentiating the terms in a program con\u00ad text requires that the context should \nboth invoke the abort s and perform the equal? test. An abort\u00ad delimiter in the language solves this \nproblem by al\u00ad lowing the procedure z to prevent the abort ~ from escaping past the equal?. Thus, to \nrestore full abstraction to the extended direct model for control, the language requires a fur\u00ad ther \nextension in the form of a control delimiting con\u00ad struct. We choose the prompt [6]. The denotational \nsemantics of prompt is an ab\u00ad straction of the strip function: : appJy(inP(inL(f)), inL(a)) = appzy(inA(a), \nb) = CVJply(a, inA(b)) = applg(a, b) = ~PP~Y strip : drip(inA(a)) = strip(inL(a)) = Figure 4: The semantic \nfunctions With pif and prompt added to the language, the extended model for PS+abort becomes fully ab\u00adstract. \nTheorem 4.2 The extended direct model (with domain Da) is fully abstract for PS+abort +pif+#. Proof sketch. \nAs a slight variation on Lemma 3.4, we now need to show that for all finite elements e, ~ in Da: 1.e \nis definable; 2. in P((O + e) + 1),2 if it exists, is clefinable (this is a procedure that takes the \nthunk form of e, ~d.e (discharged only with O), and anything above it to true, others to 1); and 3. \nin P(((O * e) * 1) 1-l ((O +~) * ())), if it exists, is definable (this is a procedure that takes an~\u00adthing \ndominating the thunk ~d.e to true, any\u00ad  thing dominating the thunk ~d,f to false, and all else to -L). \n The proof that the extended direct model is fully abstract follows from the above lemma, using a strat\u00adegy \nsimilar to that of the last section. In addition to int? and proc?, the proof needs a predicate that \ntests if its argument t hunk aborts: abort? E Af. sameint? (#((Ad. rO )(~O ))) (#(( Ad.rl )(~O ))). \nwhere sa mei nt? returns false only if its arguments are unequal numbers: sameint? s k, y.if (and (int? \nit) (int? y)) $qual? z V)I 2Actually, inP(inP(inO(0) + e) + inL(inO(l)))! Dax Da+s Da fa inA(a) inA(b) \nL for other domain values Da -+sD: a a apply and strip for PS+abort. 4.2 Modeling PS with control As \nfor PS+abort, the extended direct model for PS with a higher-order control operators such as call/cc, \nC, or control requires an additional sub domain, this time a domain of procedures called receivers , \nA receiver denotes the argument procedure of a control construct, and receives the latter s continuation \nob\u00adject as its argument. Taking X to be any one of {call/cc, C, control}, the specifications of the corresponding \nextended domain D. are as follows: integers procedures P A\\ D: = T &#38;3(g +-, D=) Dc=D~f?3D. X-receivers \n The tag inX indicates elements belonging to the sub\u00addomain for X-receivers. The semantic clause for \nthe X s are : 21C[X M]p = inX( 21z[M]p). Figure 5 shows the semantic function for PS+control along with \nthe auxiliaries apply and strip. The func\u00adtion apply deals with receiver arguments by expand\u00ading them \nto include progressively more surrounding context through the pending applications. The func\u00adtion strip \nsimulates the final discharge of the accu\u00admulated receiver procedure with an identity continu\u00adation. \nBoth apply and strip change based on the control operator, and furthermore, call/cc requires an addi\u00adtional \nsubdomain for abort-values as for PS+abort. Figure 7 describes the modified functions. Full abstraction \nThe programming languages PS+X need control de\u00adlimiters too, to make their models fully abstract. D: \no@(D: +, D.) . D. D:@ D.  Z: Terms + D: 2:[M] st~ip(ZXJM]l, in L(in P(Az.inL(x))) xc Terms + Env \n+ Dc Mcvn ]p = inL(inO(n)) %C[f]p inL(inP(f)) = %JX]P inL(p[z]) !21C[kc.kf]p . inL(inP@v : DL.~c[Jf]P[x/v])) \n. !2ic[MN]p appty(%[lkf]p, flc[~lP) ?21C[control M]p inC(21[M]p) %.[% M H]p . inL(strip(~c[M] p, flc[H]p)) \nD. xD. --+.D. . apply applg(inL(in P(f)), inL(a)) fa apply (in C(a), b) . inC(in L(in P(~k : D:. apptg(a, \ninL(inP(~v : W.apph(inl-(lc), aPPMinL(~),~) ))))))) apply (inL(a), inC(b)) inC(in L(in P(~k : D:. appiy(b, \ninL(inP@v : D~. apply (inL(k), appb(inL(a), inL(~))))))))) L for other domain values aPpMa, ~) strip \nD= xDC-, D: strip(a, inC(f)) . L 9tr2p(inC(f), h) . strip(applg(applu(h, j), inL(in P(&#38; : ~j.inL(z)))), \nh) strip(in L(a), h) a Figure 5: The semantic functions for PS+control. awb(inC(a), b) = as for PS+control \nawb(in L(a), inC(b)) = as for Ps+control striPinC(~), h) = strip(appig(appi~ (h, j), inL(inP(&#38;z.inC( \ninL(inp(&#38;LinL(~ )))))))) Figure 6: Modified apply and strip clauses for PS+C. aMNnK(a), b) = in K(in \nL(in P(~k : IDj. apply (applv(a, inL(inP(~u : Dj. apply (inL(k), apphJinL(v), b))))), b)))) apply (in \nL(a), in K(b)) = in K(in L(in P@k : Dj. applg(inL(a), apply (b, inL(inP(~v : Dj. appig(inL(k), awk(inL(a), \ninL(~)))))))))) str-ip(inK(f), h) = strip(applg(apply(h, ~), inL(inP@x : W.inN~)))), ~) strip(inA(z), \nh) = apply (applg(h, inL(inP(~v : Dj. inL(v)))), inL(z)) Figure 7: Modified appiy and strip clauses for \nPS+call/cc. However, this control delimiter should not only con\u00adstrain control but also identify the \nnumber of invoca\u00adtions of the control operator in its dynamic extent. Here, we shall consider the most \ngeneral of these lan\u00adguages, viz., PS+control; the others allow a similar treatment. For example, the \nterms control (M.r3 ) and control (Ak.control (M.r3 )), though indistiguishable wit h the plain prompt, \nhave different denot at ions. The first term invokes cent rol twice, whereas the sec\u00adond does it just \nonce. A new form of prompt, (% M M), that takes a han\u00addler expression as an additional parameter solves \nthis mismatch.3 The additional subexpression is a han\u00addier. If the first subexpression returns without \nany control incident, the prompt does nothing. However, a control-application inside a prompt sends both \nre\u00adceiver and continuation to the handler, which is then invoked on them in a fresh prompt with the same \nhandler. A program is always run within an initial prompt with the identity handler, A $, k. f k. This \nextended prompt can distinguish the two terms above as follows. Letting H E Y(Ah.Af, k.l+(%(fk)h)), the \nprograms % (control (M.r3 )) H and % (control (M.control (Ak.r3 ))) H yield The the 4 and function handler \n5 respectively. strip in in addition Figure to the 5 reflects prompt s the effect control of de\u00ad limiting \naspect. On encountering a receiver aa an argument, strip supplies the identity function as the functional \ncontinuation to the composition of the han\u00addler and the receiver, and awaits the result for further receivers \nthat may turn up. The semantic clause for a prompt-expression and the semantic function %; for complete \nprograms is shown in Figure =5. The parallel-if construct for PS+control undergoes the same change as \nfor PS+abort to address control action in its branches. Further, a predicate control? is defined along \nthe same lines as abort?. The model for PS+control+pif is fully abstract, provided the language is enhanced \nwith the prompt\u00adwith-a-handler. The related languages PS+call/cc and PS+C go through in like fashion. \nTheorem 4.3 1. The extended direct model with domain Dc is fully abstract for PS+control+pif+%. 3 Bruce \nDubs ~uggested prompts with han~ers. 2. An extended direct model is fully abstract for PS+call/cc+pif+%. \n 3. An extended direct model is fully abstract for PS+C+pif+%.  The proof is as for PS and PS+abort, \nwith special care taken for receiver denotations. One interesting consequence of having the enhanced \nprompt is that it dissolves the differences between the control oper\u00adators. Each pair of prompt and control \noperator can simulate any other pair. Thus, the extended direct model demands a delimiter that compensates \nfor the drawbacks of the particular control operator in the language.  5 Related Work Previous studies \non the relationship between direct and continuation semantics [19, 21, 24] rely on re\u00adtraction functions, \nand do not furnish the projec\u00adtion/injection maps supported by extensible direct models. The Vienna \nSchool of denotational se\u00admantics [2, 3] treats gotos in a first-order imper\u00adative setting using an extension \nof a direct seman\u00adtics, but contains no investigation of the formal as\u00adpects of these models or their \nrelationship to direct models. Felleisen and Cartwright s work on ex\u00adtended direct semantics [8] introduces \nthe extension technique aa a generalized mechanism to accommo\u00addate a variety of language extensions and \nstudies the projection relations between their models. However, they do not seek extensions with a view \nto full ab\u00ad straction. The local reduction rules for C and cent rot [9, 10] motivated the work on the \ndenot ational framework of extended direct models. Indeed, they are the operational counterpart of the \napply clauses for the denotations of receivers in the extended model for Ps+x. 6 Conclusions In this \nstudy, we investigated fully abstract, ex\u00adtended direct models for the purely functional subset of Scheme \nand its cent rol extensions. In particular, studying the correspondence between the meanings of language \nphrases in the model and the observable effect that these phrases have in complete programs both pinpoints \nand suggests remedies for deficiencies in the language design. The direct models for the extended languages \nare the extensions of the basic direct model for pure PS. Projections connect the basic model and its \nextensions. All the models are fully abstract for their respective languages, provided the latter contain \nparallel-if and, in the case of the control extensions, a suitable control delimiter. The new form of \nthe control delimiter not only con\u00adstrains control action but also invokes a handler pro\u00adcedure for every \ncontrol-application in its dynamic ex\u00adtent. Such prompts allow easy implementations and form a powerful \ngeneralization of existing exception handling mechanisms. Acknowledgment. We gratefully acknowledge discussions \nwith Robert Cartwright and Bruce Duba. Mitch Wand s Semantic Prototyping System helped in type-checking \nthe denotational semantics.  A Domains as information sys\u00adtems This work approaches the construction \nof reflexive domains using Scott s information systems [20]. The following outlines the definition of \nsuch domains from finite sets of propositions, constructions of domains from other domains, and their \nsalient properties. Information systems An information system is a structure (D, A, Con, fi) where D \nis a set of data objects or propositions;  A is the [east informative member of D;  Con is a set of \nfinite subsets of D, the finite con\u00adsistent sets of propositions; and  . t--, entailment, is a binary \nrelation on Con. The set of consistent propositions and the entailment relation satisfy the following \nproperties: Properties of Con: if u ~ vGCon, then uc Con;  ifX cD, then {X} cCon;  oifu~v, then uUv \nECon; Properties of ~: . if u ECon, then u+{ A}; ifu EConandu~v, then u~v; .ifu~vandv~w, then u~w. The \nelements of the information system A = ( DA, AA, ConA, fi~) are all those subsets z of DA such that: \nall finite subsets of z are in ConA; e if, a finite (i. e., E ConA) u G z and u t v, then vgz; The deductive \nclosure ~ of an element u G Conn is the union of all v G ConA such that u ~~ v: From the definition of \nthe elements of A, if u E ConA, then EEA. The class of domains studied here are exclusively information \nsyst ems. A domain element is thus a deductively closed (closed under I---) and consistent (all its finite \nsubsets are in Con) set of propositions. The subset relation forms an ordering relation (~) be\u00adtween \nthe domain elements. The information-system\u00adas-domain with its ordering relation G is a complete partial \norder. Domain properties Finite elements: A domain element d E A is jinite if for all directed subsets \n(d.s.) X ~ A, d ~-U X implies d~ efor some eEX. Alternately, an element is finite if it is the de\u00adductive \nclosure (d.c.) li for some u G ConA. The two definitions are equivalent. Minimal representations of finit \ne elements: A minimal representation (it need not be unique) of a finite element d is a finite consistent \nset u E cOf IA such that d = E and for any v E COnA, ifd=5andup--v,then uCv.Forfunction do\u00ad mains, minimal \nrepresent at;ons form a succinct finite description of the finite elements. Most proofs involving finite \nelements need only con\u00ad sider their minimal representations. Algebraicit y: A domain A is algebraic if \nfor any x E A, the set {d I d is finite and d ~ z} is directed with x as its Iub. Consistent completeness: \nA domain is consis\u00adtently complete if two elements with an upper bound also have a least upper bound. \nDomain constructions Information systems provide a succinct description of various domain constructions, \nincluding /ifiing, dis\u00adjoint unions, function spaces, and reflexive domains. /11: Lifiing a domain A \nadds a new bottom to the space. The set of propositions DA ~ is DA U {AAL}, where the new l.i.m. A~4 \nis consistent with all the original propositions. N: The traditional cpo of natural numbers. The set \nof propositions corresponding to N treated as an information system {AN, 0,1,2,.. .}, with no t~o ele~nts \nbeing consistent unless one of them is AN. A @ El: This is the disjoint union domain of A and ~. The \npropositions in VA~~ are of the form DA@~ = {inL(X) I X G DA} the left subdomain U{inR(Y) I Y GDB} the \nright sub domain u {-LA@B} a new least inform. member 1 A proposition in the left subdomain is always \nin\u00ad consistent with a proposition in the right subdo\u00ad main. Within the propositions stemming from one \nof the constituent domains, the entailment relation ~A~~ is exactly that domain s entail\u00ad ment relation, \nviz., &#38;A or ~~ respectively. A + El: This is the function domazjt from A to B. The set of propositions \nDA+~ consists of pairs (u, v) where u G ConA and v G Con~. The least informative member AA+~ is (Q5, \n0). The set w = {.. . , (ui, vi), . ..} belongs to corm.+~ iff (forQeJ })ECOnA implies u {W} E Corm. \nfor the smne z s ( ) A finite function c E A + El hss a minimal rep\u00adresentation w, where w E ConA+~ \nand G = c. A finite step function (a* b) E A -+ B, where a G A and b CEEl are finite elements, is the \nfunc\u00adtion that takeg anything dominating a to b and everything else to 1. A function c 6 A + B can thus \nbe represented more directly as the Iub of a finite number of step functions (rather than data objects) \napproximating it: c=. . .Uai+bi u.... A ~. B: This is the strict function domain from A to B. The construction \nis as above with the restric\u00adtion that if w = {.. .,(u~, v~)} ...} e ConA_,~, then @ *A u~ implies @ \n~~ Vi. Reflexive construct ions: A reflexive domain is one that satisfies an equation such as, e.g., \nDHA(B(D--+D), where D cent ains some at omit values and all the functions on itself. To construct the \ninforma\u00adtion system D, given A, the usual methods for @ and ~ are followed, but the constructions of \nsets of propositions and the set of consistent proposi\u00ad tions interlace as foilows: 1. inR((u, v)) G \nDD if u,v E Con~; 2. {.. .,inR(u ,, v), ,...} G COnD ifinR(w, v~) G % and implies u {vi} c Con~, for \nthe satne i s ( )  All domain constructions preserve consistent com\u00adpleteness and algebraicity. Environments \nThe semantic function M that maps language phrases to denotations uses an auxiliary argument, the envi\u00adronment. \nAn environment is a map from a finite set of variables to domain values. The not at ion 1 denotes the \nempty environment. The lookup p[z] denotes the image of z in the environment p. Extending an environment \np to include the map z * v gives the environment p[z/v]. Both these operations are strict, and hence, \nin particular, it is impossible to extend an environment with the map z * 1.  References [1] S. Abram.ky \nThe lazy L.dculus. In D. Tuxner, editor, Declarative Programming, pages 65 1 16. Addison Wesley, 1988. \n[2] D. Bj@ner and C. Jones. Formal Specification and Sofiware Development. Prentice-Hall Inter\u00ad national, \n1982. [3] A. Blikle and A. Tarlecki. Naive denotational semantics. In Proc. IFIP 9th World Computer \nCongress: Information Processing 83, pages 345 355, Amsterdam, 1983. North Holland. [4] R. Cartwright \nand A. Demers. The topology of program termination. In Proc. Symposium on Logic in Computer Science, \npages 296-308, 1988. [5] 0. Danvy and A. Filinski. Abstracting con\u00adtrol. In Proc. 1990 ACM Conference \non Lisp and Functiona[ Programming, pages 151-160, 1990. [6] M. Felleisen. The theory and practice of \nfirst\u00adclass prompts. In Proc. 15th ACM Symposium on Principles of Programming Languages, pages 180-190, \n1988. [7] M. Felleisen. On the expressive power of pro\u00adgramming languages. In N. Jones, editor, Proc. \n1990 European Symposium on Programming, pages 134 151. Lecture Notes in Computer Sci\u00adence 432, 1990. \n[8] M, Felleisen and R.S. Cartwright. Extended di\u00adrect semantics. Technical Report 105, Rice Uni\u00adversity, \nJanuary 1990. [9] M. Felleisen and D .P. Friedman. A reduction se\u00admant ics for imperative higher-order \nlanguages. In Proc. Conference on Parallel Architectures and Languages Europe, VoIume II: Para[lel Lan\u00adguages, \npages 206 223, Heidelberg, 1987. Lec\u00adture Notes in Computer Science 259, Springer Verlag. [10] M. Felleisen, \nD.P. Friedman, E. Kohlbecker, and B. Dubs. A syntactic theory of sequential con\u00adtrol. Z%eor. Comput, \nSci., 52(3):205-237, 1987. Preliminary version: Reasoning with Continua\u00adtions, Proc. Symposium on Logic \nin Computer Science, 1986, 131-141. [11] R. Hieb and R.K. Dybvig. Continuations and concurrency. In Second \nACM SIGPLAN Sytnpo\u00ad sium on Principles and Practice of Parallel Pro\u00adgramming, pages 128-136, 1990. [12] \nG.F. Johnson and D. Duggan. Stores and partial continuations as first-class objects in a language and \nits environment. Proc. 15th ACM Sympo\u00adsium on Principles of Programming Languages, pages 158 168, 1988. \n[13] F .J. Landin. A correspondence between ALGOL 30 and Church s lambda notation. Commune ACM, 8(2):89-101; \n158-165, 1965. [14] R,. Milner. Fully abstract models of typed Y calculi. Theoretical Computer Science, \n4:1-22, 1977. [15] L. C.-H. Ong. Fully abstract models of the lazy lambda-calculus. In Proc. 29th Symposium \non Foundations of Computer Science, pages 368\u00ad376, 1988. [16] G.D. Plotkin. Call-by-name, call-by-value, \nand the J-calculus. Theor. Comput. Sci., 1:125 159, 1975. [17] G.D. Plotkin. LCF considered as a programming \nlanguage. Theor. Comput. Sci., 5:223-255, 1977. [18] J .C. Reynolds. Definitional interpreters for higher-order \nprogramming languages. In Proc. ACM Conference, pages 717-740, 1972. [19] J .C. Reynolds. On the relation \nbetween direct and continuation semantics. In Proc. Interna\u00adtional Conference on Automata, Languages \nand Programming, pages 141-156, 1974. [20] D .S. Scott. Domains for denotational semantics. ICALP, July \n1982. [21] R. Sethi and A. Tang. Constructing call-by-value continuation semantics. J. ACM, 27(3) :580 \n597, 1980. [22] D. Sit aram and M. Felleisen. Control delimiters and their hierarchies. Lisp and Symbolic \nCom\u00adputation, 3(1):67-99, 1990. [23] D. Sitaram and M. Felleisen. Reasoning with continuations II: How \nto get full abstraction for models of control. In Proc. 1990 Conference on Lisp and Functional Programming, \npages 161\u00ad175, 1990. [24] J .E. Stoy. The congruence of two program\u00adming language definitions. Theor. \nComput. Sci., 13:151-174, 1981. [25] C. Strachey and C.P. Wadsworth. Cent in\u00aduations: A mathematical \nsemantics for han\u00ad dling full jumps. Technical Report PRG-11, Oxford University Computing Laboratory, \nPro\u00adgramming Research Group, 1974. [26] G.J. Sussman and G.L. Steele Jr. Scheme: An interpreter for extended \nlambda calculus. Memo 349, MIT AI Lab, 1975.  \n\t\t\t", "proc_id": "99583", "abstract": "", "authors": [{"name": "Dorai Sitaram", "author_profile_id": "81100164410", "affiliation": "Department of Computer Science, Rice University, Houston, TX", "person_id": "PP31030217", "email_address": "", "orcid_id": ""}, {"name": "Matthias Felleisen", "author_profile_id": "81100323458", "affiliation": "Department of Computer Science, Rice University, Houston, TX", "person_id": "PP39037684", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/99583.99611", "year": "1991", "article_id": "99611", "conference": "POPL", "title": "Models of continuations without continuations", "url": "http://dl.acm.org/citation.cfm?id=99611"}