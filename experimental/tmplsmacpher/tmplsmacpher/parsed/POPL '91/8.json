{"article_publication_date": "01-03-1991", "fulltext": "\n Pointer-induced Aliasing: A Problem Classification* William Landi Barbara G. Ryder (landi@cs.rutgers. \nedu) (ryder@cs.rutgers. edu) Department of Computer Science Rutgers University, New Brunswick, NJ 08903 \n Abstract A?iasing occurs at some program point during execu\u00adtion when two or more names exist for the \nsame loca\u00adtion. We have isolated various programming language mechanisms which create aliases. We have \nclassified the complexity of the fllas problem induced by each mech\u00adanism alone and in combination, as \nAfP-hard, comple\u00adment tip-hard, or polynomial ( P). We present our problem classification, give an overview \nof our proof that finding interprocedural aliases in the presence of single level pointers is in 7, and \npresent a represent tive proof for the NP-hard problems. 1 Introduction Aliasing occurs at some program \npoint during program execution when two or more names exist for the same location. The aliases of a name \nat a program point tare all other names that may refer to the same memory loca\u00adt ion on some execution \npath to t.While the calculation of aliases for FORTRAN is well understood [1, 5, 6, 18], if general pointers \nare added as a language construct, the problem of computing aliases becomes A/p-hard and no good approximation \nalgorithms exist. Moreover, alias\u00ading complicates most data flow analysis problems, and the absence of \nalias information can prevent many opti\u00admization. Our results show which aspects of aliae problems are \nprovably hard and need to be approximated. A clear un\u00adderstanding of what makes aliasing hard, lends \ninsight *The research reported here was supported, in part, by the New Jersey Commission on Science and \nTechnology, the CAIP Center s Industrial Members, NSF grant CCR\u00ad8920078, and Siemens Research Corporation. \nPermission to copy without fee all or part of this material is granted provided that the copies are not \nmade or distributed for direct commercial advantage, the ACM copyright notice and the title of the publication \nand its date appear, and notice is given that copying is by permission of the Association for Computing \nMachinery. To copy other\u00adwise, or to republish, requires a fee and/or specific permission, @ 1990 ACM \n089791-419-8/90/0012/0093 $1.50 into where information is lost in various approximations and whether \nthat loss of information is justified. Also, an understanding of how easier alias problems can be handled \nprecisely, can be useful as a framework for ap\u00adproximating harder alias problems. Theoretical Complexity \nResults In this paper, we present the theoretical complexity of solving the In\u00adtraprocedural May Alias, \nIntraprocedural Must Alias, In\u00adter-procedural May Alias, and InterProcedural Must Alias problems in the \npresence of several programming lan\u00adguage mechanisms that create aliases, The following mechanisms are \nconsidered alone and in combination: reference formal parameters, single level pointers, multi\u00adple level \npointers (i.e., pointers whose dereferenced val\u00adues are pointers), and pointers to structures containing \nsingle level pointers. Informally, our results show that multiple levels of indirection lead to Af P-hard \nor co-tiP\u00adhard alias problems, whereas a single level of indirection introduces aliases that can be found \nin polynomial time. Comparison to FORTRAN Aliasing In FOR-TRAN, the only dynamic method for creating \naliases is through the use of reference formals. Solving for alias\u00ading in the presence of pointers presents \nseveral additional complications. The most obvious difference is that with only reference formals, aliases \nthat hold at invocation of a procedure, hold during the entire execution of the called procedure. However, \nwhen pointers are present, this is not the case, because pointer assignments can change aliases in the \ncalled procedure. In addition, with only reference formals, a call to a procedure cannot af\u00adfect the \naliases in the calling procedure, but if pointers are present, this is no longer true. Both these facts \nin\u00addicate that existing FORTRAN alias algorithms are not very imprecise because it ignores control flow. \nChow and Rudmik [3] also presented an algorithm for find\u00ading aliases in the presence of pointers; however, \ntheir algorithm is inadequate, because they treat interproce\u00ad extensible to handle pointers. Related \nWork Weihl devised an approxi mation al\u00ad gorithm for finding aliases in the presence of pointers [21, \n22]. Essentially relational in approach, his algorithm is dural aliasing as an intraprocedural problem. \nBenjamin Cooper [4] has developed an algorithm which uses ex\u00adplicit path information in the form of alias \nhistories to insure (for interprocedural paths) that a procedure re\u00adturns to the call site that invoked \nit. This method seems infeasible for an implementation and is reminiscent of the work of Sharir and Pnueli \n[20]. A related area of research is the work done by the compiling community on conflict detection in \nrecursive structures [2, 8, 9, 11, 15], A conflict occurs between two statements when one statement writes \na location and the other accesses (reads or writes) the same location, thus preventing the possibility \nof those statements be\u00ading executed in parallel. Aliasing occurs at a program point, and conflicts, in \ngeneral, occur between two or more program points. The research on conflict detection has largely been \nconcerned with statically representing and determining the structure of dynamically allocated objects \n(e.g. trees, dags, lists). It has not addressed the interprocedural complications that result because \ncalls must return to the call site which invoked them; we, conversely, concentrate on these interprocedural \nissues. Overview Section 2 states relevant definitions and a summary of our theoretical results. Section \n3 presents an overview of the Interprocedural May Alias proof by specifying a polynomial algorithm. Section \n4 presents the proof that Intraprocedural May Alias in the presence of multiple level pointers is Af?-hard. \nSection 5 previews future work. 2 Alias Problem Classification tuitively, the union of the control flow \ngraphs (CFGS)l [7] for each procedure, with calls connected to the pro\u00adcedures they invoke. Formally, \nan ICFG is a triple (Af, E, p) where: p is the entry node for mairq hf contains one node for each statement \nin the program, an entry and ed node for each procedure, a call and Teturn node for each call site; and \n&#38; contains all edges in the CFG for each procedure, with a slight modification of edges involving \ncall sites. In the ICFG, a call site is split into a call and a return node. An intraprocedural edge \ninto a call node represents execution flow into a call site, while an intraprocedural edge out of a return \nnode represents flow from a call site. In addition to the intraprocedu\u00adral edges, two interprocedural \nedges are added for each call site: one from the call node to the entry node of the invoked procedure, \nand one from the exit node of the procedure to the return node of the call site. See Figure 1 for an \nexample of an ICFG. Definitions The following definitions will be used throughout the paper: realizable: \nA path is realizable iff itis a path in the ICFG (CFG in intraprocedural problems) such that whenever \na procedure on this path returns, it returns to the call site which invoked it. Basically, realizable \nmeans potentially executable under the common as\u00adsumption of static analysis that all program paths are \nexecutable. holds: Alias <a, b> holds on the realizable path ~1n2...ni iff a and b refer to the same \nlocation at program point ni whenever the execution sequence de\u00adfined by the path occurs. Note that aliases \nare sym. metric, thus <a, b> holds on a path iff <b, a> also holds on that path. Interprocedmral May \nAlias: The precise solution for Interprocedural May Alias is 3 a realizable path, pnlnz . ..ni _ In,[n, \n<a, b>] in the ICFG on which <a, b> holds { Program Representation We represent programs by 1Each node \nin our CFG is a source code statement. interp? ocedural control j?ow graphs, (ICFGS) that are in\u00ad int \n*q, void A(f) int *R { q=fi } main( ) { int *q, *G A(q); r=~s A(p); } &#38;  Figure 1: A program Int \nerprocedural Must Alias: The precise solution for Interprocedural Must Alias is V realizable paths, pnlnz. \n,.ni _ In,[n, <a, b>] in the ICPG <a, b> holds {} visible: At a call site, an object name (e.g. *z) \nin the calling procedure is visible in the called procedure iff the called procedure is in the scope \nof the object name and at run time, the object name refers to the same object in both the calling and \nthe called procedure. z Problem Classification We have analyzed the the\u00adoretical difficulty of solving \nfor aliases (assuming no pro\u00adcedure variables) in the presence of reference formals, single level pointers, \nmultiple level pointers, and struc\u00adtures containing single level pointers. The results our analyses are \nshown in Table 1, Blanks in Table 1 cor\u00adrespond to problems which involve reference parameters and thus \nare inherently interprocedural. Surprisingly, 2The notion of visibility is needed to define precisely \nthe aliases of objects in recursive procedures. We are assuming that all program variables have unique \nnames. 95 and its ICFG there is no difference in problem difficulty between in\u00adtraprocedural and interprocedural \nproblems, at least in terms of Afp-hard vs P. The salient property is the number of possible levels of \nindirection, regardless of the mechanism used to create the indirection. If only one level of indirection \nis possible, then aliasing can be pre\u00adcisely solved in a polynomial amount of time, but as soon as two \nlevels are present, the problem becomes MP-hard, There must be at least two distinct approximations in \nany practical aliasing algorithm. In any program that contains recursive data structures, there are potentially \nan infinite number of objects which can have aliases. Any aliasing algorithm will have to represent all \npossible ob\u00adjects by a finite (polynomial) number of objects3. The type of representation and its precision \nare what distin\u00adguishes the different conflict detection methods. There is a second source of approximation \nillustrated by the following scenario. Suppose there is an assign\u00adment p = z at program point i, alias \npair <p, q> holds on 3For example, k-limited as defined by Jones and Muchnick [11]. Intraprocedural Intraprocedural \nInterprocedural Interprocedural Alias Mechanism May Alias Must Alias May Alias Must Alias Polynomial[l, \n5] Polynomial [l, 5] Reference Formals, No Pointers, No Structures Single level pointers,  Polynomial \nPolynomial Polynomial Polynomial No Reference Formals, No Structures Polynomial Polynomial Single level \npointers,  Reference Formals, No Pointer Reference Formals, No Structures Multiple level pointers, Af~-hard \nComplement ALP-hard Complement No Reference Formals, is AfP-hard is hfP-hard No Structures hfP-hard \nComplement Single level pointers, is N?-hard Pointer Reference Formals, No Structures Single level pointers, \nAf P-hard[14]  Complement NP-hard[14] Complement Structures, is Afp-hard is hfp-hard No Reference Formals \nTable 1: Alias problem decomposition and classification some path to tand <*z, *y> also holds on some \npath to these two problems are, surprisingly, fairly disparate). t. If both <p, q> and <*x, *Y> occur \non the same path, The key ideas used in the proof that the Interprocedural then <*q, *y> holds at t;therefore, \nto be safe we must May Alias problem in the presence of single level point\u00ad conclude this, even though \nit may not be true. Thus, to ers is in P are presented in Section 3. The proof that the solve for alias \npairs precisely, we need information about Intraprocedural May Alias problem is NP-hard is given multiple \nalias pairs on a path. Unfortunately, this prop-in Section 4. This proof is representative of all those \nfor ert y generalizes; that is, to determine precisely if there hf~-hard problems. Other proofs are omitted \nbut can is a single path on which a set of i alias pairs hold, you be found in [13]. need information \nabout sets of more than i alias pairs. 3 Inteqxocedural May Alias Since it is hf~-hard even in the presence \nof single level  with Single Level Pointers pointers to determine if there is an intraprocedural path \nThe main difficulty in solving Interprocedural May Aliason which a set of O(n) (n, the number of variables \nin is to determine how to restrict information propagationa program) aliases hold [13], some approximate \nion must only to realizable paths. To accomplish this, we solveoccur. data flow problems for a procedure \nassuming an aliasAll the A.fP-hardness proofs are variations of proofs condition on entry; that is, we \nsolve data flow condition. by Myers [18]; a similar, although independently discov\u00adally based on some \nassumption at procedure entry. This ered, proof for recursive structure aliasing (as indicated is somewhat \nreminiscent of Lomet s approach to solvingin Table 1) was developed by Larus [14]. All problems data \nflow problems under different aliasing conditionswhich are categorized as polynomial are corollaries \nof [16] and Marlowe s notion of a representative data flowproofs that the Interprocedural May Alias and \nInterpro\u00adproblem within a region[17]. cedural Must Alias problems in the presence of single level pointers \nare polynomially solvable (the proofs for We use a two step algorithm to solve for aliases. In the first \nstep, we solve for conditional aliases, that is, we answer the question If there is a path to the entry \nnode of the procedure containing n~ on which the alias set A holds, then may a be aliased to b at n~? \n. In the second step, we use these conditional aliases to solve for the actual aliases. This two step \napproach avoids the unrealizable path problem. In the first step, the edges from call nodes to entry \nnodes in the ICFG are ignored. Information is propagated from procedure entry nodes to exits; the calculation \nat a return node combines information from its corresponding call node and the called procedures exit \nnode. Thus, potential alias effects of the called pro\u00adcedure on the calling procedure are incorporated; \nhow\u00adever, the aliases introduced by the call itself are ignored. In the second step, aliases introduced \nare propagated through a call node to the corresponding entry node of the called procedure, ignoring \nedges from exit nodes to return nodes. Conceptually, this is analogous to propa\u00adgation on the program \ncall graph [7]. Related ideas for handling the unrealizable path problem were presented in [10]. This \nidea of using conditional aliases does not seem promising at first, as there are an exponential number \nof possible sets of aliases. But Lemma 3.1 insures that it is sufficient to consider sets A where I A \nI~ 1. If more than one level of indirection is possible, it is no longer precise to use I ~ 1<1, but \nit is safe (i.e., our alias solution will be imprecise, but all actual alias pairs will be contained \nwithin the calculated solution). Lemma 3.1 If pointeT usage is restricted to single level pointers then \n for aii ? ealizabie paths P == nlnz . ..n~ (where nl is the entry node of the procedure containing ni \nand the number of calls on the path nl, n2, . . . . ni equals the number of returns),  and for all possible \nalias pairs <a, b>;  If all alias pairs in the set d = {Al, A2, . . . . Am} hold\u00ad ing at nl and the \nexecution of path P implies that <a, b> holds at ni then either assuming no aliases at nl and ezecuting \npath P forces <a, b> to hold at ni OT %(1 ~ k ~ m) such that when assuming only the alias Ak at nl, executing \nthe path P forces <a, b> to hold at ni. The proof of Lemma 3.1 is by induction on IPI, the basis is trivially \ntrue and the induction step is an easy, but messy, case analysis on possible ni [12]. 0 We use the holds \nrelation to represent conditional alias information. holds([(ICFG-node, assumed-alias-pair), alias-pair]) \nis tme iff alias-pair holds on some path to ICFG-node, assuming there is a path to the entry of the proce\u00addure \ncontaining ICFG-node on which assumed-alias\u00adpaiT holds. By Lemma 3.1, assumed-alias-psi? is either a \nsingle alias pair or 0, where 0 represents assuming no aliases on procedure entry, 3.1 Computing May \nAlias using Conditional May Alias Given the holds relation, Interprocedural May Alias in\u00adformation can \nbe computed by a simple data flow prob\u00adlem on the ICFG. We will use the function bindcalr to model the \neffects of parameter bindings at each call site. bindcafl (A) is the set of aliases which hold on the \npath pnl...ni_2[cail] [entryP] if A holds on pnl . ..ni_2[call]. bindcall (A) is formally defined in \nFigure 2. Given holds and the bind functions, for any node n in the ICFG=(JV, $, p), may-alias(n) can \nbe defined as follows: may-alias(p) = 0  if n is an entry node then may-alias(n) =  otherwise, may-a \njias(n) = [holds([(n, 0), <a, b>])= true] V <a, b> [(3<c, d> E may-alias(entTy( n))) hoids([(n, <c, d>), \n<a, b>]) = true] { } Theorem 3.1 There ezista a polynomial algorithm for determining precise Interprocedural \nMay Alias sets in the presence of single level pointers. ~i and ~j are pointer formals u <*fi, *fj> \n with actuals ai and aj respectively, and ai = aj } { fi is a pointer formal with actual aa, bind~al,(0) \n= <*fi, *Ui> u and ai is visible in the called procedure 1 { fi is a pointer formal with actual ai,<*CJi, \n*f~> and ai is visible in the called procedure } { { <a, b> I if a and b are visible in the called procedure \n} U if a is visible in the called procedure, fi is <a, *f~> u a pointer formal with actual aa, and *ai \n= b {} bind~all(<a, b>) = if b is visible in the called procedure, ji is <*fi, b> u a pointer formal \nwith actual ai, and *ai = a { } if fi and fj are pointer formals with corresponding<*fi, *fj> actuals \nai and aj, and *a~ = a and +aj = b 1 { Figure 2: Specification of bindeall (A) The claim is that calculating \nthe fixed point of if n is not an assignment to a pointer may-alias is such an algorithm. We can prove \nthat the hoids([(n, d.4), <a, b>]) is true iff for some immediate holds calculation can be computed in \npolynomial time predecessor m of n, ho~ds([(m, old), <a, b>]) is true. (Lemma 3,2 in Section 3.2). Therefore, \nthe fixed point , if nis p = q {or p = &#38;v } for pand qpointers calculation for Interprocedural May \nAlias takes polyno\u00ad  if a is *p then holds([(n, old), <*p, b>]) is true mial time because, for each \nnode in the ICFG, may-alias iff for some immediate predecessor m of n, can change its value at most 0(v2) \ntimes, where w is the hoids([(m, AA), <*g, b>]) {holds([(m, AA), <v, b>]) number of variables in the \nprogram. The precision of our for p = &#38;v } is true. algorithm stems from Lemmas 3.1 and 3.2. The \nformal if b is *p then holds ([(n, .4.4), <a, *P>]) is true proof is by induction on path length and \nby induction on iff for some immediate predecessor m of n, number of iterations of the fixed point calculation \n[12]. 0 holds([(wz, w.4./t), <u, w>]) {holds([(m,AA), <a, w>]) 3.2 Computing Conditional May Alias for \np = &#38;v } is true. We handle the intraprocedural aspects of Interproce\u00ad otherwise, dural May Alias \nsimilarly to Chow and Rudmik [3]. hozds([(n, old), <a, b>]) is true iff for some imme. On an execution \npath, we consider the relationship be\u00ad diate predecessor m of n, hohls([(m, fl), <a, b>]) tween aliases \nthat hold before a statement is executed is true. and aliases that hold after it is executed. Consider\u00ad \nif n is p = malloco or p = null . (We are mallocing ing holds ([(n, AA), <a, b>]), the following statements \nare a primitive type here, not a structure. ) true: if a or b is *P then hohis([(n, d.A), <a, ZI>]) must \nbe false (<a, b> does not hold on any path).  otherwise, holds([(n, Ad), <a, b>]) is true iff for some \nimme\u00addiate predecessor m of n, holds([(m, AA), <a, b>]) is true. Recall that the main problem in computing \npre\u00adcise Interprocedural May Alias is insuring that only realizable paths are considered. However, this \nis easily handled by our conditional alias formulation. hozds([(entrv, AA), <a, b>]) is true if (AA = \n<a, b>) or (a= b) and otherwise is false. call and exit nodes sim\u00adply collect alias information. Thus: \nholds([(caU/ezit, AA), <a, b>]) = (hokis([(w4..4),<cz! b])) V<m,rxS1/e.it>G&#38; Now, for simplicity, \nassume that we are dealing with a programming language that haa no local variables, and thus no formal \nparameters. We are interested in whether holds([(retumt, assumed-alias), <a, b>]) is true (see Figure \n3). Clearly it is true if <a, b> holds at the corresponding ezit node, conditional on assumed-alias \nholding at its entry and assumed-alias , conditional on assumed-alias, holds at the corresponding call \nnode. Let ASSUM/Z?3 be the set of all possible assumed aliases in the program. Holds for a return node \nis defined as: holds([(return, assumed-alias), <a, b>]) = holds([(ezit, 0), <a, b>]) V holds([(ezit,AA), \n<a, b>]) A VAAeASSUMtW hoids([(.all, aswwned-alia.), old]) () Factoring in local variables Unfortunately, \nadding local variables complicates matters considerably. A pro\u00adcedure call can both create and destroy \nan alias in the calling procedure, involving a non-visible object in the called procedure. For example, \nthe second call of A in Figure 1 creates the alias <*q, *p> and destroys the alias <*q, *r> at returnA(p) \neven though *p and *r are not visible in A. However, only references to a visible object in an alias \npair can affect whether the alias holds on a path (i.e., there can be no direct references to a non\u00advisible \nobject ). Fortunately, a procedure has the same effect on all alias pairs which contain visible object \nw and any non-visible object. Thus for every object w, which may have aliases, we introduce the alias \npair <w, .>, representing w aliased to a non-visible object, into the set of possible alias pairs and \nthe set of possible assumed aliases. As in Interprocedural May Alias, we need to be able to model the \neffects of parameter bindings. How\u00adever, we now have a different perspective and will use the functions \nbaclc-bindCallP and back-bind~allP for each call site to model parameter bindings. baci&#38;bindCallP \n(assumed-alias) specifies the alias holding on any path p.. .[callp] that guarantees assumed-alias holds \non p,., [callp][entryp]. back-bind~al~p (<a, .>, o) specifies the alias holding on any path p... [callp] \nthat guarantees a will be aliased to the non-visible object o on p... [callP] [entryP]. back-bind and \nback-bind are for\u00admally defined in Figure 4. Assume that we are interested in whether <a, b> holds on \nthe realizable path PTetUrnQ to node ? etu? nQ. We will use the following conventions: Preturnq =~l...n~[entry~] \nmmj[CU~~Q][e~try Q] OlQ,,l.,, ok [e*~tQ] [r(?t?.H ~Q] l ezit~ = P??l ...ni[e~try~] ml . ..mj [d~Q] [enf? \nyQ]ol.., @ [f?dQ] pentry~ =~1 ...~i [entryR]ml . ..mj [d/Q] [e d? yQ] call~ =Pnl ...n~ [ent~~~]ml. ..mj \n[d/Q] pentry~ = pnl ...ni [entry~] where ? durnQ is in procedure R, both ml . ..mj and 01.. .ok are realizable \npaths with the same number of calls as returns, and ent? yQ, I%i?itQ, dlQ, and ? du? %Q are the entry, \nexit, call, and return nodes, respectively, as\u00adsociated with the call. Consider the following cases: \na and b are both not visible in the called procedure; It is impossible for the called procedure to create \nor destroy this alias pair, thus <a, b> holds on Pretu,nQ iff itholds on PCallQ. This implies Rule 1 \nof Figure 5. holds([(Entr_yA holds([(CallA( ~ ,assumed-alias) , assumed-alias ]) = true holds([(Retur~( \n~ ,assuwd-alias), ca,b>]) = true Figure 3: holds at a return a and b are both visible in the called \nprocedure; If <a, b> holds on Preiurnq, it must also hold on By Lemma 3.1, either no aliases need hold \non PentrY~ for <a, b> to hold on pezitQ or there exists a <c, d> such that only <c, d> must hold on PentrYQ \nfor <a, b> to hold on p.zit~. In the first case, holds([(ezit, 0), <a, b>]) will be true (by definition \nof holds). In the sec\u00adond case, hotds([(ezit, <c, d>), <a, b>]) must be true and back-bindCallQ (<c, \nd>) must hold on pcallQ . pexitQ . Again by Lemma 3.1 there is an assumed-alias (either 0 or a single \nalias pair) which must hold on Pent,Y~ and by definition of holds, hOkh([(Cal~Q, aS$U Wted-dk9), bdd~?d..~lq \n(< Cad>)]) k true. Thus holds obeys Rule 2 of Figure 5. a is visible but b is not (the symmetric case \nis simi\u00adlar); The alias <a, b> holds on P,~t~,~Q iff <a, > holds on PeZ;t Q and b is the non-visible \nobject . . By Lemma 3.1 there is a single <a , t> which must hold on P,nt,yQ and thus bac?c-bhzd~allQ \n(<a , ->, b) must hold on PCWQ. By Lemma 3.1 there is an assumed-alias (either 0 or a single alias pair) \nwhich must hold on P~nt~vn and by definition of holds, hokls([(cailQ, assumed-alias)), back-bind~~,,Q \n(<a , .>, b)]) is true. This justifies Rule 3 of Figure 5. Lemma 3.2 In the presence of single level \npointers, ,assummed-aiias ),ass~d-alias 1) = true ! holds([(ExitA ,assumed-alias ),<a,b>]) = true node \n(no local variables) holds can be precisely computed in polynomial time. The computation of holds is \na simple fixed point computation (initial value of holds at nodes is false). The calculation takes time \npolynomial in the size of the program because each hoids([(node, U), PA]) can only change its value once \nand there is only a polynomial number of such triples (polynomial in the size of the ICFG and the number \nof variables in the program). The proof of precision is by induction on number of itera\u00adtions of the \nfixed point algorithm and induction on path length[12]. 0   q Intraprocedural May Alias with Multiple \nLevel Pointers Theorem 4.1 In the presence of two level pointers, the problem of determining precise \nIntraprocedural May Alias sets is ~P-hard. The proof of Theorem 4.1 is by reduction from the 3-SAT problem \nfor A~=l(li,l V li,2 V /i,3) with variables {Vi, vz,...um}m}. The reduction is specified by the pro\u00adgram \nin Figure 6 which is polynomial in the size of the 3-SAT problem. The conditionals are not specified \nin the program since we are assuming that all paths are executable. 0 back-bindcalln (0) = @ ( <a, b> \nif a and b are both visible in the procedure called by cailp <a, *Uj > if a is visible in the procedure \ncalled by callP, and b is the dereferenced formal *fj with corresponding actual Uj <*aj, b> if b is visible \nin the procedure called by callP, and a is the back-bindcall, (<a, b>) = dereferenced formal * fj with \ncorresponding actual aj { < *aj, *ak > if a is the dereferenced formal * fj with corresponding actual \naj ,and b is the dereferenced formal *fk with corresponding actual ak [ false otherwise (either a or \nb is a local [non-parameter] object) I <a, o> if a is visible in the procedure called by callP <*aj, \no> if a is the dereferenced formal * fj with corresponding back-bind~allp(<a, .>, o) = actual (lj fa18e \notherwise (a is a local [non-parameter] object) Figure 4: Specification of bath-bind,allp (assumed-alias) \nand back-bindcanp (<a, ,>, o) Rule 1 If a and b are both not visible in the called procedure: holds([(retwm, \nassumed-alias), <a, b>]) = hoids([(ca~l, assumed-alias), <a, b>]) ( Rule 2 If a and b are both visible \nin the called procedure: holds([(rettirn, assumed-alias), <a, b>]) = holds([(ezit, AA), <a, b>]) A holds([(ezit, \n0), <a, b>]) V VAA&#38;ASSUMcn hoids([(call, a.mnned-alia.), back-bindC.ll(AA)]) ) ( Rule 3 If a is visible \nbut b is not (the symmetric case is similar): holds([(edt, <o, .>), <a, .>]) A holds([(return, aa.sumed-alias), \n<a, b>]) = V<o,,>ee ASSUM.fV holds([(call, ag.wmed-ahas), back-bhd~all(<o, .>, b)]) ) Figure 5: holds \nrelation at return nodes 5 Future Work int **vi, **v2, ...,**%; int ** fi, **~, . . ..**~. int *%rue, \n*false; int yes, no; /* A path through this section of code corresponds to a truth assignment */ Li : \nif (-) {VI = &#38;true; ~ = &#38;false} else {vl = &#38;false; ~ = &#38;true} if ( ) {wz = &#38;true; \n~ = &#38;false} else {q = &#38;false; ~ = &#38;true} ... if (-) {vm = &#38;true; ~ = &#38;false} else \n{v~ = &#38;false; K = &#38;true} L2: false = &#38;no; /+ The code below will break the <*~alse,no> alias \nbefore reaching L3 iff the truth assignment fronr above makes the formula false */ if (-) *l~,~t= &#38;yes \nelse if (-) *11,2 = &#38;yes else *11,3 = &#38;yes; if (-) *lz,~ = &#38;yes else if (-) *~z,z = &#38;yes \nelse *lz,3 = &#38;yes; ,.. if (-) *lm,~ = &#38;yes else if (-) *ln,z = &#38;yes else *ln,3 = &#38;yes; \nL3 : tli)j is not thestringli,j, but theliteral it represents (i.e. v, or ~ for some k). Figure 6: 3-SAT \nsolution iff [L3,<*~alse, no>] in In\u00adtraprocedural May Alias Naively calculating the fixed point yields \na polyno\u00admial time O(n * V6) algorithm where n is the num\u00adber of ICFG nodes and w is the number of objects \nthat may have aliases; thus, our theoretical algorithm is not practically viable. However, by intelligent \ncalcu\u00adlation of the fixed point, we can reduce the complexity to 0( Isize of conditional alias solution12/n) \nin the worst case. We expect a solution of conditional alias to be sparse in comparison to the possible \nsolution space and have hopes foran O(lsize ofalias solutionl) average case complexity. Our goal is to \ndevelop agood alias approximation al\u00adgorithm for general pointer usage in C. Currently, we are working \non a practical approximation algorithm for In\u00adterprocedural May Alias in the presence ofmultiple level \npointers. Our algorithm design combines ideas from the proof infection 3, with modifications aimedat \naccept\u00adable performance and precision. We plan to implement this algorithm and empirically test its performance \non actual C programs. We intend to both theoretically and empirically examine the amount of imprecision \nof our approximations (i.e., the percentage of spurious aliases reported). Avalidationofthe usefulness \nofour algorithm willbe its incorporation in various data flow analyses, including interprocedural modification \nside effect analysis for C systems. Specifically, we intend to use our algorithm in a new version of \nISMM, our semantic change impact analyzer for C [19]. We also plan to include the analysis work on recursive \ndata structures in our framework for pointer aliasing,  6 Conclusions We have presented a classification \nof pointer-induced aliasing problems including Intraprocedural May Alias, Intraprocedural Must Alias, \nInterprocedural May Alias and Interprocedural Must Alias. Each problem has been defined by the programming \nlanguage constructs that cause aliasing alone and in combination: reference for\u00adreals, single level pointers, \nmultiple level pointers and structures with embedded pointers. We have categorized the theoretical complexity \nof these problems, noting that the presence of multiple levels of indirection leads to AfP-hard and co-hfP-hard \nproblems. An explanation of a polynomial time Interprocedural May Alias algorithm has been given. Current \nwork focuses on design and im\u00ad plementation of a practical, approximate interprocedural aliasing algorithm \nbased, in part, on the ideas in these complexity results. Acknowledgments: We thank Hemant Pande for \nhis help in improving this presentation.  References [1] J. Banning. An efficient way to find the side \neffects of procedure calls and the aliases of variables. In Con\u00adference Record of the Sixth Annual ACM \nSymposium on Principles of Programming Languages, pages 29 41, January 1979. [2] D. R. Chase, M. Wegman, \nand F. K. %adeck. Analysis of pointers and structures. In Proceedings of the SIGPLAN 90 Conference on \nProgramming Language Design and Implementation, pages 296-310, June 1990. SIGPLAN Notices, Vol 25, No \n6. [3] A. Chow and A. Rudmik. The design of a data flow ana\u00adlyzer. In Proceedings of the ACM SIGPLAN \nSymposium on Compiler Construction, pages 106 113, June 1982. [4] B. G. Cooper. Ambitious data flow analysis \nof procedu\u00adral programs. Master s thesis, University of Minnesota, May 1989. [5] K. Cooper. Analyzing \naliases of reference formal param\u00adeters. In Conference Record of the Twelfth Annual A CM Symposium on \nPrinciples of Programming Languages, pages 281 290, January 1985, [6] K. Cooper and K. Kennedy. Fast \ninterprocedural alias analysis. In Conference Record of the Sixteenth Annual ACM Symposium on Principles \nof Programming Lan\u00adguages, pages 49-59, January 1989. [7] M. S. Hecht. Flow Analysis of Computer Programs. \nEl\u00adsevier North-Holland, 1977. [8] L. J. Hendren and A. Nicolau. Parallelizing programs with recursive \ndata structures. In Proceedings of the 1989 International Conference on Parallel Processing, pages 49 \n56, August 1989. [9] S. Horwitz, P. Pfeiffer, and T. Reps. Dependence anal\u00adysis for pointer variables. \nIn Proceedings of the ACM SIGPLA N Symposium on Compiler Construction, pages 28-40, June 1989. [10] \nS. Horwitz, T. Reps, and D. Binjdey. Interprocedural slicing using dependence graphs. In Proceedings \no} the SIGPLAN 88 Conference on Programming Language Design and Implementation, pages 35 46, July 13B6. \nSIGPLAN NOTICES, Vol. 23, No. 7. [11] N. Jones and S. Muchnick. A survey of data flow anal. ysis techniques. \nIn S. Muchnick and N. Jones, editors, Program Flow Analysis: Theory and Applications, pages 102 131. \nPrentice Hall, 1979. [12] W. LandL Inter-procedural Aliasing in the Presence of Pointers. PhD thesis, \nRutgers University, 1991. in preparation. [13] W. Landi and B. G. Ryder. Aliasing with and with\u00adout pointers: \nA problem taxonomy. Center for Com\u00adputer Aids for Industrial Productivity Technical Report CAIP-TR-125, \nRutgers University, September 1990. [14] J. R. Larus. Restructuring Symbolic Programs for Con\u00adcurrent \nEzecution on Multiprocessors. PhD thesis, Uni\u00adversit y of California Berkeley, May 1989, [15] J. R. Larus \nand P. N. Hilfinger. Detecting conflicts be\u00adtween structure accesses. In Proceedings of the SIG-PLAN \n88 Conference on Programming Language De\u00adsign and Implementation, pages 21-34, July 1988. SIG-PLAN NOTICES, \nVol. 23, No. 7. [16] D. Lomet. Data flow analysis in the presence of pro\u00adcedure calls. Journal of Research \nand Development, 21(6):559-571, November 1977. [17] T. J. Marlowe and B. G. Ryder. An efficient hybrid \nalgo\u00adrithm for incremental data flow analysis. In Conference Record of the Seventeenth Annual ACM Symposium \non Principles of Programming Languages, pages 184-196, January 1990. [18] E. M. Myers. A precise interprocedural \ndata flow algo\u00adrithm. In Conference Record of the Eighth Annual ACM Symposium on Principles of Programming \nLanguages, pages 219-230, January 1981. [19] B. G. Ryder. Ismm: Incremental software maintenance manager. \nIn Proceedings of the IEEE Computer Society Conference on Software Maintenance, pages 142-164, October \n1989. [20] M. Sharir and A. Pnueli. Two approaches to interproce\u00addural data flow analysis. In S. Muchnick \nand N. Jones, ed~tors, Program Flow Analysis: Theory and Applica\u00adtions, pages 189-234. Prentice Hall, \n1981. [21] W. E. Weihl. Interprocedural data flow analysis in the presence of pointers, procedure variables \nand label vari\u00adables. Master s thesis, M. I. T., June 1980. [22] W. E. Weihl. Interprocedural data flow \nanalysis in the presence of pointers, procedure variables and label vari\u00adables. In Conference Record \nof the Seventh Annual A CM Symposium on Principles of Programming Languages, pages 83-94, January 1980. \n\t\t\t", "proc_id": "99583", "abstract": "", "authors": [{"name": "William Landi", "author_profile_id": "81452618010", "affiliation": "Department of Computer Science, Rutgers University, New Brunswick, NJ", "person_id": "PP31030929", "email_address": "", "orcid_id": ""}, {"name": "Barbara G. Ryder", "author_profile_id": "81100632248", "affiliation": "Department of Computer Science, Rutgers University, New Brunswick, NJ", "person_id": "PP14217204", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/99583.99599", "year": "1991", "article_id": "99599", "conference": "POPL", "title": "Pointer-induced aliasing: a problem classification", "url": "http://dl.acm.org/citation.cfm?id=99599"}