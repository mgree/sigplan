{"article_publication_date": "01-08-2014", "fulltext": "\n Backpack: Retro.tting Haskell with Interfaces Scott Kilpatrick Derek Dreyer MPI-SWS MPI-SWS skilpat@mpi-sws.org \ndreyer@mpi-sws.org Abstract Module systems like that of Haskell permit only a weak form of modularity \nin which module implementations depend directly on other implementations and must be processed in dependency \nor\u00adder. Module systems like that of ML, on the other hand, permit a stronger form of modularity in which \nexplicit interfaces express assumptions about dependencies, and each module can be type\u00adchecked and reasoned \nabout independently. In this paper, we present Backpack, a new language for build\u00ading separately-typecheckable \npackages on top of a weak module system like Haskell s. The design of Backpack is inspired by the MixML \nmodule calculus of Rossberg and Dreyer, but differs sig\u00adni.cantly in detail. Like MixML, Backpack supports \nexplicit in\u00adterfaces and recursive linking. Unlike MixML, Backpack supports a more .exible applicative \nsemantics of instantiation. Moreover, its design is motivated less by foundational concerns and more \nby the practical concern of integration into Haskell, which has led us to advocate simplicity in both \nthe syntax and semantics of Backpack over raw expressive power. The semantics of Back\u00adpack packages is \nde.ned by elaboration to sets of Haskell modules and binary interface .les, thus showing how Backpack \nmaintains interoperability with Haskell while extending it with separate type\u00adchecking. Lastly, although \nBackpack is geared toward integration into Haskell, its design and semantics are largely agnostic with \nre\u00adspect to the details of the underlying core language. Categories and Subject Descriptors D.3.1 [Programming \nLan\u00adguages]: Formal De.nitions and Theory; D.3.3 [Programming Languages]: Language Constructs and Features \nRecursion, Ab\u00adstract data types, Modules; F.3.3 [Logics and Meanings of Pro\u00adgrams]: Studies of Program \nConstructs Type structure Keywords Type systems; mixin modules; Haskell modules; ap\u00adplicative instantiation; \nrecursive modules; separate modular devel\u00adopment; packages; module systems 1. Introduction Suppose an \nauthor A wants to write, test, and publish a software component (or package ) P, that needs to call a \nrandom-number generator. But A wants each customer C to be able to supply his or her own random-number \ngenerator. In a typed language, the author A must de.ne the interface to the random-number generator, \nPermission to make digital or hard copies of all or part of this work for personal or classroom use is \ngranted without fee provided that copies are not made or distributed for pro.t or commercial advantage \nand that copies bear this notice and the full citation on the .rst page. Copyrights for components of \nthis work owned by others than the author(s) must be honored. Abstracting with credit is permitted. To \ncopy otherwise, or republish, to post on servers or to redistribute to lists, requires prior speci.c \npermission and/or a fee. Request permissions from permissions@acm.org. POPL 14, January 22 24, 2014, \nSan Diego, CA, USA. Copyright is held by the owner/author(s). Publication rights licensed to ACM. ACM \n978-1-4503-2544-8/14/01. . . $15.00. http://dx.doi.org/10.1145/2535838.2535884 Simon Peyton Jones Simon \nMarlow Microsoft Research Facebook simonpj@microsoft.com marlowsd@gmail.com typecheck P with respect \nto the interface, and publish P. The client C then links P with a particular random-number generator \nthat matches the interface. We refer to this style of development as separate modular development (SMD), \nas distinct from the style of incremental modular development (IMD) in which a package can only be typechecked \nwhen the implementations of its dependencies are available. One of the most prominent approaches to SMD \nis that taken by the ML module system and its many variants [22, 21]. ML provides functors, which enable \na module M to be parameterized over the implementations of its dependencies; the dependencies can then \nbe instantiated by functor application in multiple different ways, even within a single program. An alternative \napproach is to use mixin modules [4, 3, 13, 11]. Instead of relying on parameterization, mixin modules \nsup\u00ad port SMD by combining within their namespaces both de.ned and unde.ned components, the latter speci.ed \nvia interfaces. Unlike functors, mixin modules support recursive linking; and since link\u00ading is implicitly \nby-name , mixins also avoid the propagation of coherence (or sharing ) constraints so common with functor \npro\u00adgramming. Moreover, recent work by Rossberg and Dreyer on the MixML type system [27] has demonstrated \nthat mixin modules have the capacity to subsume the functionality of ML modules. However, despite their \nadvantages, mixin modules have yet to be adopted by any widely-used statically-typed functional lan\u00adguage.1 \nIn the case of the ML languages, this is understandable: ML already has a powerful module system, and \nthe extra bene.t afforded by mixins is arguably not worth the replacement cost. What about Haskell? Haskell \ns existing module system was consciously designed as a weak namespace management sys\u00adtem without a proper \nnotion of interface [17, Section 8.2], and hence supports only IMD, not SMD. Tools like the Cabal package \nmanagement system pick up the slack, enabling users to (ab)use version-range dependencies in order to \nwork around the lack of interfaces. But the Haskell community recognizes that this is a makeshift solution \nand is actively seeking ways to support SMD properly. In short, Haskell is a prime example of a language \nthat is ripe for extension with interfaces and mixins. The trouble is that the foundational accounts \nof mixin modules that have appeared in the literature [3, 16, 27] employ a variety of complex and unconven\u00ad \ntional type systems, and it is not at all clear how to convert any of them into a practical design that \ncould be realistically incorporated into a language like Haskell. With this in mind, we make the following \ncontributions: We present Backpack, a new language for building mixin-style packages on top of an existing \n(weak) module system like Haskell s (Section 2). Like MixML [27], Backpack supports interfaces, recursive \nlinking, abstract data types, and SMD. 1 We are not counting Scala [24]: it supports mixin composition, \nbut in a way that is integrally tied to its object-oriented mechanisms.  Package Names P . PkgNames \nModule Path Names p . ModPaths Package Respositories R ::= D Package De.nitions D ::= package P t where \nB Bindings B ::= p = [M] | p :: [S] | p = p | include P t r Thinning Specs t ::= (p) Renaming Specs r \n::= (p . p) Module Expressions M ::= . . . Signature Expressions S ::= . . . Figure 1. Backpack syntax. \n Unlike MixML, Backpack supports a more .exible applicative (rather than generative) semantics of instantiation \n[20], thereby extending mixin modules into new territory (Section 2.4). It would be easy to support generativity \nas well.  Unlike other strong module systems, Backpack subordinates expressive power to simplicity, \npracticality, and orthogonality from the core language and its type system. The main technical device \nthat supports this orthogonality is the central notion of module identity (Section 3.1), which we can \ntreat largely independently from the type system of the core language. The type system for Backpack is \nmuch simpler than that of MixML.  We give a formal description (Sections 3.2 3.4) of how to elab\u00ad orate \na Backpack package into a set of ordinary Haskell mod\u00adules and module types (the latter corresponding \nto GHC s exist\u00ading notion of binary interface .le ). If the package is complete (i.e., fully implemented), \nit can be compiled and executed. But regardless, the Haskell modules output by elaboration can be typechecked \nseparately from their missing dependencies.  We prove soundness of Backpack s elaboration, which guaran\u00adtees \nthat a complete package will elaborate to a well-typed set of Haskell modules (Section 3.5). Even stating \nsoundness re\u00adquired us to de.ne a formal semantics for separate typechecking of (recursive) Haskell modules, \nwhich did not exist previously.  Finally, we conclude the paper in Sections 4 and 5 with a detailed \ndiscussion of related and future work. For space reasons, we leave a number of formal details to our \naccompanying technical appendix, available at http://plv.mpi-sws.org/backpack/. 2. A Backpack Tour Figure \n1 gives the syntax of Backpack. A package de.nition D gives a package name P to a a sequence of bindings \nB. The simplest form of binding is a concrete module binding, of the form p = [M], which binds the module \nname p to the implementation [M]. For example: package ab-1 where A = [x = True] B = [import A; y = not \nx] The code in square brackets represents module implementations, whose syntax is just that of a Haskell \nmodule (details in the techni\u00adcal appendix; Appendix \u00a75). Indeed, in a practical implementation of Backpack, \nthe term [M] might be realized as the name of a .le containing the module s code. However, note that \nthe module lacks a header module M where ... because the module s name is given by the Backpack description.2 \nPackage ab-1 binds two modules named A and B. The .rst module, bound to A, imports nothing and de.nes \na core value x, and the second module, bound to B, imports the .rst module and makes use of that x in \nits de.nition of y. The type of this package 2 We still provide syntax for optional export lists of core \nlanguage entities; only the module name disappears. expresses that it contains a module A which de.nes \nx :: Bool and a module B which de.nes y :: Bool. (We will more precisely discuss types, at the package \nand module levels, in Section 3.) The module bindings in a package are explicitly sequenced: each module \ncan refer only to the modules bound earlier in the sequence. In fact the bindings should be interpreted \nas iteratively building up a local module context that tracks the name and type of each module encountered. \nFor example, if the order of the two bindings were reversed, then this package would cease to be well\u00adtyped, \nas the module reference A would no longer make sense. Module bindings do not shadow. Rather, if the same \nmodule name is bound twice, the two bindings are linked; see Section 2.3. 2.1 Top Level and Dependencies \nA package repository consists of an ordered list of package de.ni\u00adtions. Each package in a repository \nsees only those packages whose de.nitions occur earlier in the sequence. To make use of those ear\u00adlier \npackages i.e., to depend on them a package includes them using the include binding form, thus: package \nabcd-1 where C = [x = False] include ab-1 e import quali.ed A D = import quali.ed C z = A.x &#38;&#38; \nC.x One should think of an include construct as picking up a package and dumping all of its contents \ninto the current namespace. In this case, the modules A and B are inserted into the package abcd-1 as \nif they were bound between C and D. Consequently the mod\u00adule bound to D can import both A and C. The \ntype of abcd-1 says that it provides four modules: C (which provides x :: Bool), D (which provides z \n:: Bool), and the two modules A and B from package ab-1, even though they were de.ned there and merely \nin\u00adcluded here. (The modules exposed by a package can be controlled with syntax that resembles that of \nthe module level; this feature is discussed as a special case of thinning in Section 2.4.) In this paper, \nwe will treat the example package de.nitions as the bindings in a single package repository. At this \npoint, that top level includes the de.nition for ab-1 followed by abcd-1.  2.2 Abstraction via Interfaces \nUp to this point, the package system appears only to support IMD since each module can only be checked \nafter those that it depends on. For example, abcd-1 could only be developed and checked after the package \nab-1 had already been developed and checked; other\u00adwise we would not be able to make sense of the import \ndeclaration import quali.ed A and the subsequent usage of A.x as a Bool. To support SMD as well, Backpack \npackages may additionally contain abstract module bindings, or holes. To specify a hole, a developer \nprovides a set of core-language declarations, called a signature S, and binds a module name p to it by \nwriting p :: [S]. One should think of holes as obligations to eventually provide implementing modules; \na package is not complete until all such obligations are met. Concrete modules, on the other hand, are \nsimply those bound to actual implementations (as in all previous examples). This combination of abstract \nand concrete components re.ects the mixin-module basis of our package system. As our .rst example, we \nsimulate how the abcd-1 package might have been developed modularly by specifying holes for the other \ncomponents, A and B:  package abcd-holes-1 where A :: [x :: Bool] B :: [y :: Bool] C = [... as before \n...] D = [... as before ...] By stubbing out the other components, the developer of abcd\u00adholes-1 can \ntypecheck her code (in C and D) entirely separately from the developer who provides A and B. In contrast, \nin the existing Cabal package system, developers cannot typecheck their package code without .rst choosing \nparticular version instances of their dependencies. Effectively, they test the well-typedness of their \ncode with respect to individual con.gurations of dependencies which may or may not be the ones their \nusers have installed. Manually writing the holes for depended-upon components, as above, involves too \nmuch duplication. Instead a developer can de.ne a package full of holes that designates the interface \nof an entire component. A client developer includes that package of holes and thus brings them into her \nown package without writing all those signatures by hand. The following two packages achieve the same \nnet result (and have the same type) as abcd-holes-1, but without signatures in the client package: package \nab-sigs where package abcd-holes-2 where A :: [x :: Bool] include ab-sigs B :: [y :: Bool] C = [... as \nbefore ...] D = [... as before ...] Holes are included in exactly the same manner as concrete mod\u00adules, \nand they retain their status as holes after inclusion. Under the interpretation of holes as obligations, \ninclusion propagates the obli\u00adgations into the including package. In these two examples we have named \nthe packages abcd-holes\u00ad1 and abcd-holes-2, which might suggest multiple versions of a single package \nabcd-holes (e.g., in Cabal). However, while they may convey that informal intuition, in the present work \nwe focus on modularity of packages, leaving a semantic account of versioning for future work.  2.3 Linking \nand Signature Matching So far, all package examples have contained bindings with distinct names. What \nhas appeared to be mere sequencing of bindings is ac\u00adtually a special case of a more general by-name \nlinking mechanism: linking two mixin modules with strictly distinct names merely con\u00adcatenates them. \nWhenever two bindings share the same name, how\u00adever, the modules to which they are bound must themselves \nlink together. This gives rise to three cases: hole-hole, mod-mod, and mod-hole. First, when linking \ntwo holes together, we merge their two in\u00adterfaces into one. This effectively joins together all the \ncore lan\u00adguage declarations from their respective signatures. The resulting hole provides exactly the \nentities that both original holes provided. package yourlib where Prelude :: [data List a = ...] Yours \n= [import Prelude; ...] package mylib where Prelude :: [data Bool = ...] include yourlib Mine = [import \nPrelude; import Yours; ...] The mylib package above declares its own hole for Prelude and also includes \nthe hole for Prelude from yourlib. Before the binding for Mine is checked, the previous bindings of Prelude \nmust have linked together. This module can see both List and Bool since they are both in the interface \nof the linked hole, whereas the Yours module could only see the List datatype in Prelude. (Swapping the \norder of the .rst two bindings of mylib has no effect here.) This example highlights another aspect of \nprogramming with mixin-based packages: each package has the option of writing precise interfaces for \nthe other packages (i.e., modules) it depends on. Speci.cally, yourlib only needs the List datatype from \nthe standard library s Prelude module, rather than the entire module s myriad other entities. This results \nin a stronger type for yourlib since the assumptions it makes about the Prelude module are more precise \nand focused. Not all interface merges are valid. For example, if mylib had also declared a List datatype, \nbut of a different kind from that in yourlib (e.g., data List a b = ...), then the merge would be invalid \nand the package would be ill-typed. Second, when linking two module implementations together, it intuitively \nmakes no sense to link together two different implemen\u00adtations since they de.ne different code and different \ntypes. Rather than rejecting all mod-mod linkages, as for instance MixML [27] does, we instead insist \nthat mod-mod linking only succeed if the two implementations are the same, in which case the linkage \nis a no-op. To test this, we require equivalence of their module identities (about which see Sections \n2.4 and 3.1). Consider the following classic diamond dependency: package top where Top = [...] package \nright where include top Right = [...] package left where include top Left = [...] package bottom where \ninclude left; include right Bottom = [...] The bottom package of the diamond links together the packages \nleft and right, each of which provides a module named Top that it got from the top package. The linking \nresulting from the inclusions in bottom is well-typed because left and right provide the same module \nTop from package top. Third, when linking a module with a hole, the module s type must be a subtype of \nthe hole s, and we say that the module .lls, matches, or implements that hole. This form of linking \nmost closely resembles the traditional concept of linking, or of functor application; it also corresponds \nto how structures match signatures in ML. Roughly, a module implements a hole if it de.nes all the entities \ndeclared in that hole and with the exact same speci.cations. The mylib package above has a hole for the \nPrelude module. As this package is not yet complete, it can be typechecked, but not yet compiled and \nexecuted. (Supporting separate compilation would require sweeping changes to GHC s existing infrastructure.) \nWe therefore link mylib with a particular implementation of its Prelude hole so that it may now be compiled \nand used: package mylib-complete-1 where include mylib e data List a = ... Prelude = data Bool = ... \nnull xs = ... The implementation of Prelude provides the two entities declared in the hole (included \nfrom mylib) and an additional third entity, the value null. This implementation matches the interface \nof the hole, so the linkage is well-typed. For simplicity, our de.nition of when a module matches a hole \nis based on width rather than depth subtyping. In other words, a module may provide more entities than \nspeci.ed by the hole it is .lling, but the types of any values it provides must be the same as the types \ndeclared for those values in the hole s signature. In particular, the match will be invalid if the implemented \ntypes are more general than the declared types. For example, a polymorphic  package prelude-sig where \nPrelude :: [data List a = Nil | Cons a (List a)] package arrays-sig where include prelude-sig e import \nPrelude Array :: data Arr (i::*) (e::*) something :: List (Arr i e) package structures where include \narrays-sig Set = [import Prelude; data S ...] Graph = [import Prelude; import Array; data G ...] Tree \n= [import Prelude; import Graph; data T ...] package arrays-a where include prelude-sig e import quali.ed \nPrelude as P Array = data Arr i e = MkArr ... something = P.Nil package arrays-b where include prelude-sig \ne import Prelude Array = data Arr i e = ANil | ... something = Cons ANil Nil package graph-a (Graph, \nPrelude) where include arrays-a include structures (Graph, Prelude, Array) package graph-b (Graph, Prelude) \nwhere include arrays-b include structures (Graph, Prelude, Array) package multinst where include graph-a \n(Graph . GA) include graph-b (Graph . GB) . . import quali.ed GA .import quali.ed GB . Client = . . export \n(main, GA.G) main = ... GA.G ... GB.G ... Figure 2. Running example: Data structures library and client. \nidentity function of type forall a :: *. a -> a will not match a hole that declares it as having type \nInt -> Int.  2.4 Instantiation and Reuse Developers can reuse a package s concrete modules in different \nways by including the package multiple times and linking it with distinct implementations for its holes; \nwe call each such linkage an instantiation of the package. Furthermore, in Backpack, packages can be \ninstantiated multiple times, and those distinct instantiations can even coexist in the same linked result. \n(In contrast, both Cabal and GHC currently prevent users from ever having two instantia\u00adtions of a single \npackage in the same program.) Figure 2 provides an example of multiple instantiations in the multinst \npackage, but this example employs a couple features of Backpack we must .rst introduce thinning and renaming. \n3 3 In our examples so far, we have omitted thinning specs entirely. But actually, according to Figure \n1, all package de.nitions and inclusions should contain a thinning spec. To infer a thinning spec where \none is omitted, one can simply list all module paths provided by the corresponding package. The syntax \nused in our examples can thus be translated into our formal language with a straightforward (type-directed) \nrewriting. Moreover, the syntax for package inclusion given in Figure 1 requires that all inclusions \nadditionally contain a renaming. When we omit renaming, it means that one should use the empty renaming, \n(). The two packages arrays-a and arrays-b provide two distinct implementations of the Array module described \nby the hole speci\u00ad.cation in the earlier arrays-sig package. The next two packages grab the Graph implementation \nfrom structures and implement its Array hole with the respective array implementations. Since structures \nalso de.nes Set and Tree, these (unwanted) modules would naively be included along with Prelude and Array \nand would thus pollute the namespaces of graph-a and graph-b. Instead, these packages thin the structures \npackage upon inclusion so that only the desired modules, Prelude and Array, are added to graph-a and \ngraph-b. (This closely resembles the import lists of Haskell mod\u00adules, which may select speci.c entities \nto be imported.) Similarly, implementation details of a package de.nition can be hidden rather than provided \nto clients by thinning the de.nition to expose only certain module names. (This closely resembles the \nexport lists of Haskell modules.) By thinning their de.nitions to expose only Prelude and Graph, both \npackages graph-a and graph-b hide the internal Array modules used to implement their Graph modules. At \nthis point, graph-a and graph-b provide distinct instantia\u00adtions of the Graph module from structures, \ndistinct in the sense that they do not have the same module identity. The identity of a module a crucial \nnotion in Backpack s semantics (see Sec\u00adtion 3.1) essentially encodes a dependency graph of the module \ns source code. Since the Graph modules in graph-a and graph-b im\u00adport two different module sources for \nthe Array hole one from arrays-a and the other from arrays-b they do not share the same dependency graph \nand hence have distinct identities. Thus, if the .nal package multinst were to naively include both graph-a \nand graph-b, Backpack would complain that multinst was trying to merge two distinct implementations with \nthe same name. To avoid this error, the inclusions of graph-a and graph-b employ renaming clauses that \nrename Graph to GA and GB, respectively, so that the two Graph implementations do not clash. One may \nwonder whether it is necessary to track dependency in\u00adformation in module identities: why not just generate \nfresh module identities to represent each instantiation of a package? To see the motivation for tracking \nmore precise dependency information, con\u00adsider the example in Figure 3. Both the applic-left and applic-right \npackages separately instantiate the Graph module from structures with the same Array implementation from \narrays-a i.e., both in\u00adstantiations refer to the same identity for Array. Backpack thus treats the two \nresulting Graph modules (and their G types) as one and the same, which means the code in applic-bot is \nwell-typed. In other words, the identity of Graph inside applic-left is equivalent to that of Graph inside \napplic-right, and thus the G types mentioned in both packages are compatible. As this example indicates, \nour treatment of identity instantiation exhibits sharing behavior. We call this an applicative semantics \nof identity instantiation, as opposed to a potential generative seman\u00adtics in which the two instantiations \neven when instantiated with the same identity would produce distinct identities. As is well known in \nthe ML modules literature [20, 28], applica\u00ad tivity enables signi.cantly more .exibility regarding when \nmodule instantiation must occur in the hierarchy of dependencies. In the previous example, the authors \nof applic-left and applic-right were free to instantiate Graph inside their own packages. Under a gener\u00adative \nsemantics, on the other hand, in order to get the same Graph instantiation in both packages, it would \nneed to be instantiated in an earlier package (like graph-a from Figure 2) and then included in both \napplic-left and applic-right; hence, the code as written in Figure 3 would under a generative semantics \nproduce two distinct Graph identities and G types. As Rossberg et al. have noted [28], applicative semantics \nis generally safe only when used in conjunc\u00adtion with purely functional modules. It is thus ideally suited \nto Haskell, which isolates computational effects monadically.  package applic-left (Prelude, Left) where \ninclude structures include arrays-a Left = [import Graph; x :: G = ...] package applic-right (Prelude, \nRight) where include arrays-a include structures Right = [import Graph; f :: G -> G = ...] package applic-bot \nwhere include applic-left include applic-right Bot = [import Left; import Right; ... f x ...] Figure \n3. Example of applicativity.  2.5 Aliases Occasionally one wants to link two holes whose names differ. \nThe binding form p = p in Figure 1 allows the programmer to add such aliases, which may be viewed as \nsharing constraints. For example: package share where include foo1 (A, X) include foo2 (B, Y) X = Y \nHere, A (from foo1) depends on hole X, and B (from foo2) on hole Y, and we want to require the two holes \nto be ultimately instantiated by the same module. The binding X = Y expresses this constraint.  2.6 \nRecursive Modules By using holes as forward declarations of implementations, pack\u00adages can de.ne recursive \nmodules, i.e., modules that transitively import themselves. The Haskell Language Report ostensibly allows \nrecursive modules, but it leaves them almost entirely unspeci.ed, letting Haskell implementations decide \nhow to handle them. Our approach to handling recursive modules follows that of MixML. The example below \nde.nes two modules, A and B, which im\u00adport each other. By forward-declaring the parts of B that A depends \non, the .rst implementation makes sense i.e., it knows the names and types of entities it imports from \nB and, naturally, the second implementation makes sense after that. This de.nition is analogous to how \nthese modules would be de.ned in GHC today.4 package ab-rec where B :: [SB ] A = [import B; ...] B = \n[import A; ...] Normal mixin linking ties the recursive knot, ensuring that the import B actually resolves \nto the B implementation in the end. GHC allows recursive modules only within a single (Cabal) package. \nBackpack, on the other hand, allows more .exible re\u00adcursion. Although packages themselves are not de.ned \nrecursively, they may be recursively linked. Consider the following: package ab-sigs where package b-from-a \nwhere A :: [SA] include ab-sigs B :: [SB ] B = [import A; ...] package a-from-b where package ab-rec-sep \nwhere include ab-sigs include a-from-b A = [import B; ...] include b-from-a 4 In GHC, instead of explicit \nbindings to a signature and two modules, there would be the two module source .les and an additional \nboot .le for B that looks exactly like SB. Moreover, the import B within the A module would include a \nsource pragma that tells the compiler to import the boot .le instead of the full module. At the level \nof packages, these de.nitions do not involve any recur\u00adsive inclusion, which is good, because that would \nbe illegal! Rather, they form a diamond dependency, like the earlier packages top, left, right, and bottom. \nThere is no recursion within the de.nitions of ab-sigs, a-from-b, and b-from-a either. The recursion \ninstead occurs implicitly, as a result of the mixin linking of modules A and B in the package ab-rec-sep. \n(Separately typechecked, recursive units may be de.ned in MixML in roughly the same way.) Finally, we \nnote that Backpack s semantics (presented in the next section) explicitly addresses one of the key stumbling \nblocks in supporting recursive linking in the presence of abstract data types, namely the so-called double \nvision problem [6, 8]. In the context of the above example, the problem is that, in ab-sigs, the speci.cation \nSA of the hole A may specify an abstract type T, which SB then depends on in the types of its core-level \nentities. Subsequently, in a-from-b, when the implementation of A imports B, it will want to know that \nthe type T that it de.nes is the same as the one mentioned in SB , or else it will suffer from double \nvision , seeing two distinct names for the same underlying type. Avoiding double vision is known to be \nchallenging [8, 9, 27], but crucial for enabling common patterns of recursive module programming. Backpack \ns semantics avoids double vision completely. 3. The Semantics of Backpack The main top-level judgment \nde.ning the semantics of Backpack is . f D : .a.. . .a.dexp Given a package de.nition D, along with a \npackage environment . describing the types and elaborations of other packages on which D depends, this \njudgment ascribes D a package type .a.., and also elaborates D into a parameterized directory expression \n.a.dexp, which is essentially a set of well-typed Haskell module .les. The above judgment is implemented \nby a two-pass algorithm.5 The .rst pass, called shaping, synthesizes a package shape . for D, which effectively \nexplains the macro-level structure of the package, i.e., the modules contained in D, the names of all \nthe entities de.ned in those modules, and how they all depend on one another. The second pass, called \ntyping, augments the structural information in . with additional information about the micro-level structure \nof D. In particular, it .lls in the types of core-language entities, forming a package type . and checking \nthat D is well-formed at .. Our goal in the present section is to explain in detail this two\u00adpass typechecking \nalgorithm, as well as the elaboration of Back\u00adpack into Haskell. Central to both passes of Backpack typecheck\u00ading \nis a notion of module identity. Using the multinst package (and its dependencies) from Figure 2 as a \nrunning example, we will mo\u00ad tivate the role and structure of module identities, and then in sub\u00adsequent \nsubsections explain the implementation of shaping, typing, and elaboration. Full details are given in \nAppendix \u00a76. 3.1 Module Identities Figure 5 shows the shapes and types of multinst and its dependen\u00adcies. \nWe proceed by explaining Figure 5 in a left-to-right fashion. The .rst column of Figure 5 contains the \n.rst key component of package types: a mapping from modules logical names p (i.e., their names at the \nlevel of Backpack) to their physical identities . (i.e., the names of the Haskell modules to which they \nelaborate). The reason for distinguishing between logical names and physical identities is simple: due \nto aliasing (Section 2.5), there may be 5 The reason for splitting typechecking into two passes has to \ndo with the double vision problem [8], as discussed in Section 2.6. See Section 4 for further discussion, \nas well as a detailed explanation of how our solution to double vision compares with MixML s.  Identity \nVariables a, \u00df . IdentVars Identity Constructors K . IdentCtors Identities . ::= a | \u00b5a.K . Identity \nSubstitutions f, . ::= {a := .} Figure 4. Module identities. multiple logical names for the same physical \nmodule. (For further technical justi.cations for the logical/physical distinction, see the discussion \nin Section 4.) In order to motivate the particular logical mappings in Figure 5, let us .rst explore \nwhat physical identities are, which means re\u00adviewing how module names work in Haskell. Module Names in \nHaskell Modules in Haskell have .xed names, which we call physical because they are globally unique in \na program, and module de.nitions may then depend on one another by importing these physical names. Modules \nserve two related roles: (1) as points of origin for core-level entities, and (2) as syntactic namespaces. \nConcerning (1), a module may de.ne new entities, such as values or abstract data types. Concerning (2), \na module may export a set of entities, some of which it has de.ned itself and others of which it has \nimported from other modules. For example, a module Foo may de.ne a data type named T. A subsequent module \nBar may then import Foo.T and re-export it as Bar.T. To ensure that type identity is tracked properly, \nthe Haskell type system models each core-level entity semantically as a pair [.]T of its core-level name \nT and its provenance ., i.e., the module that originally de.ned it (in this example, Foo). Thus, Foo.T \nand Bar.T will be viewed as equal by Haskell since they are both just different names for the same semantic \nentity [Foo]T. To ensure compatibility with Haskell, our semantics for Back\u00adpack inherits Haskell s use \nof physical names to identify abstract types. However, Haskell s .at physical module namespace is not \nexpressive enough to support Backpack s holes, applicative module instantiation, and recursive linking. \nTo account for these features, we enrich the language of physical names with a bit more interest\u00ading \nstructure. Figure 4 displays this enriched language of as we call them physical module identities. 6 \nVariable and Applicative Identities Physical module identities . are either (1) variables a, which are \nused to represent holes; (2) applications of identity constructors K, which are used to model dependency \nof modules on one another, as needed to implement applicative instantiation; or (3) recursive module \nidentities, de.ned via \u00b5-constructors. We start by explaining the .rst two. Each explicit module expression \n[M] that occurs in a package de.nition corresponds (statically) to a globally unique identity con\u00adstructor \nK that encodes it. For example, if a single module source M appears on the right-hand side of three distinct \nmodule bindings in a package P , then the three distinct identity constructors of those modules are, \nroughly, (P.M.1), (P.M.2), and (P.M.3). 7 In the absence of recursive modules, each module identity . \nis then a .nite tree term either a variable a, or a constructor K applied to zero or more subterms, .. \nThe identity of a module is the constructor K that encodes its source M, applied to the n identities \nto which M s n import statements resolved (in order). For instance, in the very .rst example from Section \n2, ab-1, the identities of A and B are Ka and Kb Ka, respectively, where Ka encodes the .rst module expression \nand Kb the second. In a package with holes, each hole gets a fresh variable (within the package de.nition) \nas its 6 To make use of these enriched physical names in our elaboration, we embed them into the space \nof Haskell s physical names; see Section 3.4. 7 We write simply (P.M ), eliding the integer part of the \nidentity construc\u00adtor, when only one instance of [M] exists in the de.nition of package P. identity; \nin abcd-holes-1 the identities of the four modules are, in order, aa, ab, Kc, and Kd aa Kc. Consider \nnow the module identities in the Graph instanti\u00adations in multinst, as shown in Figure 5. In the de.nition \nof structures, assume that the variables for Prelude and Array are aP and aA respectively, and that MG \nis the module source that Graph is bound to. Then the identity of Graph is .G = (structures.MG) aP aA. \nSimilarly, the identities of the two ar\u00adray implementations in Figure 2 are .AA = (arrays-a.MA) aP and \n.AB = (arrays-b.MB) aP . The package graph-a is more interesting because it links the packages arrays-a \nand structures together, with the imple\u00admentation of Array from arrays-a instantiating the hole Array \nfrom structures. This linking is re.ected in the identity of the Graph module in graph-a: whereas in \nstructures it was .G = (structures.MG) aP aA, in graph-a it is .GA = .G[.AA/aA] = (structures.MG) aP \n.AA. Similarly, the identity of Graph in graph-b is .GB = .G[.AB/aA] = (structures.MG) aP .AB . Thus, \nlinking consists of substituting the variable identity of a hole by the concrete identity of the module \n.lling that hole. Lastly, multinst makes use of both of these Graph modules, under the aliases GA and \nGB, respectively. Consequently, in the Client module, GA.G and GB.G will be correctly viewed as distinct \ntypes since they originate in modules with distinct identities. As multinst illustrates, module identities \neffectively encode de\u00adpendency graphs. The primary motivation for encoding this infor\u00admation in identities \nis our desire for an applicative semantics of instantiation, as needed for instance in the example of \nFigure 3. In that example, both the packages applic-left and applic-right indi\u00advidually link arrays-a \nwith structures. The client package applic\u00adbot subsequently wishes to use both the Left module from applic\u00adleft \nand the Right module from applic-right, and depends on the fact that both modules operate over the same \nGraph.G type. This fact will be checked when the packages applic-left and applic-right are both included \nin the same namespace of applic-bot, and the se\u00admantics of mixin linking will insist that their Graph \nmodules have the same identity. Thanks to the dependency tracking in our mod\u00adule identities, we know \nthat the Graph module has identity .GA in both packages. Recursive Module Identities In the presence \nof recursive mod\u00adules, module identities are no longer simple .nite trees. Consider again the ab-rec-sep \nexample from the end of Sec\u00adtion 2. (Although this example does not concern our current focus, multinst, \nthe careful treatment of recursive module identities de\u00adserves explanation.) Suppose that .A and .B are \nthe identities of A and B, and that MA and MB are those modules de.ning module expressions, respectively. \nBecause MA imports B and MB imports A, the two identities should satisfy the recursive equations .A = \n(a-from-b.MA) .B .B = (b-from-a.MB ) .A These identity equations have no solution in the domain of .nite \ntrees, but they do in the domain of regular, in.nite trees, which we denote (.nitely) as .A = \u00b5aA.(a-from-b.MA) \n((b-from-a.MB) aA) .B = \u00b5aB .(b-from-a.MB ) ((a-from-b.MA) aB) The semantics of Backpack relies on the \nability to perform both uni.cation and equivalence testing on identities. In the presence of recursive \nidentities, however, simple uni.cation and syntactic equivalence of identities no longer suf.ces since, \ne.g., the identity (a-from-b.MA) .B represents the exact same module as .A, albeit in a syntactically \ndistinct way. Fortunately, we can use Huet s well\u00adknown uni.cation algorithm for regular trees instead \n[18, 14].  Logical Mapping Physical Shapes Physical Types prelude-sig Prelude . aP FP FP arrays-sig \nPrelude . aP Array . aA FP , FA FP , FA structures Prelude . aP Array . aA Set . .S Graph . .G Tree \n. .T FP , FA, .S :(|S(. . . ) ; [.S ]S(. . . )|)+ .G:(|G(. . . ) ; [.G]G(. . . )|)+ .T :(|T(. . . ) \n; [.T ]T(. . . )|)+ FP , FA, .S:(|data S . . . ; [.S]S(. . . )|)+ .G:(|data G . . . ; [.G]G(. . . )|)+ \n.T :(|data T . . . ; [.T ]T(. . . )|)+ arrays-a Prelude . aP Array . .AA FP , FAA FP , FAA arrays-b \nPrelude . aP Array . .AB FP , FAB FP , FAB graph-a Prelude . aP Graph . .GA FP , FAA, .GA:(|G(. . . \n) ; [.GA]G(. . . )|)+ FP , FAA, .GA:(|data G . . . ; [.GA]G(. . . )|)+ graph-b Prelude . aP Graph . .GB \n FP , FAB , .GB :(|G(. . . ) ; [.GB ]G(. . . )|)+ FP , FAB , .GB :(|data G . . . ; [.GB ]G(. . . )|)+ \nmultinst Prelude . aP GA . .GA GB . .GB Client . .C FP , FAA, FAB , .GA:(|G(. . . ) ; [.GA]G(. . . )|)+ \n.GB :(|G(. . . ) ; [.GB ]G(. . . )|)+ .C :(|main ; [.C ]main, [.GA]G()|)+ FP , FAA, FAB , .GA:(|data \nG . . . ; [.GA]G(. . . )|)+ .GB :(|data G . . . ; [.GA]G(. . . )|)+ .C :(|main :: . . . ; [.C ]main, \n[.GA]G()|)+ .AA . (arrays-a.MA) aP .S . (structures.MS ) aP .GA . (structures.MG) aP .AA .T . (structures.MT \n) aP .G .AB . (arrays-b.MB) aP .G . (structures.MG) aP aA .GB . (structures.MG) aP .AB .C . (multinst.MC \n) .GA .GB . . aP : (| \u00d8 ; [\u00dfPL]List(Nil, Cons)|)- aP :(| \u00d8 ; [\u00dfPL]List(Nil, Cons) |)- 4 - . F P i \nFP . . data List(a :: *) = \u00dfPL:(| List(Nil, Cons) ; [\u00dfPL]List(Nil, Cons) |)- ; [\u00dfPL]List(Nil, Cons) \u00dfPL: \nNil | Cons a ([\u00dfPL]List a) . . aA :(| \u00d8 ; [\u00dfAA]Arr(), [\u00dfAS ]something |)- F A . . \u00dfAA:(| Arr ; [\u00dfAA]Arr() \n|)- . \u00dfAS :(| something ; [\u00dfAS ]something |)- . . aA :(| \u00d8 ; [\u00dfAA]Arr(), [\u00dfAS ]something |)- FA . . \u00dfAA:(| \ndata Arr (i :: *) (e :: *) ; [\u00dfAA]Arr() |)- . \u00dfAS :(| something :: [\u00dfPL]List ([\u00dfAA]Arr i e) ; [\u00dfAS ]something \n|)-  . Arr(MkArr), something ; [.AA]Arr(MkArr), [.AA]something |)+ data Arr (i :: *) (e :: *) = MkArr \n. . . FAA .AA:4(| + ; [.AA]Arr(MkArr), [.AA]something FAA . .AA: something :: [\u00dfPL]List ([.AA]Arr i \ne)  . Arr(ANil, . . . ), something ; [.AB ]Arr(ANil, . . . ), [.AB ]something |)+ FAB .AB :4(| + data \nArr (i :: *) (e :: *) = ANil| . . . ; [.AB ]Arr(ANil, . . . ), [.AB ]something FAB . .AB : something \n:: [\u00dfPL]List ([.AB ]Arr i e) Figure 5. Example package types and shapes for the multinst package and \nits dependencies. 3.2 Shaping Constructing the mapping from logical names to physical identities is \nbut one part of a larger task we call shaping, which constitutes the most unusual and interesting part \nof Backpack s type system. The goal of shaping is to compute the shape (i.e., the macro\u00adlevel structure) \nof the package. Formally, a package shape . = ( F; L ) has two parts.8 The .rst is a physical shape context \nF = .: tm, which, for each module in the package, maps its physical identity . to a polarity m and a \nmodule shape t . The polarity m speci.es whether the module . is implemented (+) or a hole (-). The module \nshape t = (|dent ; espc|) enumerates . s de.ned entities dent i.e., the entities that the module . itself \nde.nes as 8 We write a tilde ( \u00b7) on the metavariables of certain shape objects (e.g., t ) not to denote \na meta-level operation, but to highlight these objects similar\u00adity to their corresponding type objects \n(e.g., t). well as export specs espc, which list the names and provenances of the entities that . exports. \nNote that these are not the same thing: a module . may import and re-export entities that originated \nin (i.e., whose provenances are) some other modules .', and it may also choose not to export all of the \nentities that it de.nes internally. In our running example in Figure 5, the physical shape contexts F \ncomputed for each package are shown in the second column. The second part of the package shape is a logical \nshape context L = p . .@t , which, for each module in the package, maps its logical name p to its physical \nidentity .. (This is the mapping shown in the .rst column of Figure 5, which we have already discussed \nin detail in Section 3.1). In addition, L also maps p to a shape t , which is required to be a subset \nof the principal shape of . (as recorded in the physical shape context F ). This may seem mysterious: \nif L maps p to ., and F maps . to t 0, say, then why does L record another t as well? The reason is \ntwofold: (1) it is  Core Level: Value Names x . ValNames Type Names T . TypeNames Constructor Names \nK . CtorNames Kind Environments kenv ::= . . . Semantic Types typ ::= [.]T typ | . . . De.ned Entity \nSpecs dspc ::= data T kenv = K typ | data T kenv | x :: typ Export Specs espc ::= [.]dent Module Level: \nPolarities m ::= + | - Types t , s ::= (|dspc ; espc|)Physical Type Ctxts F ::= .:tm Logical Type Ctxts \nL ::= p . .@t Package Level: Package Types ., G ::= (F; L) Package Environments . ::= \u00b7 | ., P = .a.dexp \n: .a.. Shaping Objects: De.ned Entities dent ::= x | T | T (K) Module Shapes t ::= (|dent ; espc|)Physical \nShape Ctxts F ::= .: tm Logical Shape Ctxts L ::= p . .@t Package Shapes ., F; G ::= ( L) Figure 6. \nSemantic objects for shaping and typing. convenient in some of the inference rules to be able to look \nup the shape of a module by merely inspecting the logical shape context L, and (2) it is possible for \ndifferent logical module names to re.ect different restricted subnamespaces of the same underlying module \n(see the technical appendix for an example of this; Appendix \u00a73). In our running example, however, the \nreader may ignore this subtlety and assume that all the t s associated with . in L and F are equal (which \nis why we omit them from the .rst column of Figure 5). Figure 6 de.nes the semantic objects for shaping \nand typing, and Figure 7 gives some of the key rules implementing shaping. Shaping Rules The main shaping \njudgment, . B . ., takes as input the body of a package de.nition, which is just a sequence of bindings \nB. Rule SHSE Q synthesizes the shape of B by proceeding, in left-to-right order, to synthesize the shape \nof each individual binding B (via the judgment .; G B . . ) and then merge it with the shapes of the \nprevious bindings (via the judgment . 1 + . 2 . . ). Let us begin with the judgment that shapes an individual \nbind\u00ading. The rule SHALI A S should be self-explanatory. The rule SHINC is simple as well, choosing fresh \nidentity vari\u00adables a to represent the holes in package P and applying the re\u00adnaming r to P s shape. \n(Note that it uses some simple auxiliary de.nitions: rename, for applying a renaming to the L part of \na shape, and shape, for erasing a package type . to a shape by re\u00admoving typing information. Moreover, \nby alpha-varying the type of P we rename its variables to match the freshly chosen a.) The rule SHMOD \ngenerates the appropriate globally unique identity .0 to represent [M], and then calls out to a shaping \njudg\u00adment for Haskell modules, G; .0 c M : t (Appendix \u00a75.1.1), which generates the shape t of M assuming \nthat .0 is the mod\u00adule s identity. As an example of this, observe the shape generated for the Client \nmodule .C in multinst in Figure 5. The shape as\u00ad cribes provenance .C to the main entity, since it is \nfreshly de.ned in Client, while ascribing provenance .GA to the G type, since it was imported from GA \nand is only being re-exported by Client. The rule SHSI G, for shaping hole declarations, is a bit subtler \nthan the other rules. Perhaps surprisingly, the generated shape de\u00adclares not only a fresh identity variable \na for the hole itself, but also a set of fresh identity variables \u00df, one for each entity speci\u00ad ' p . \n.@t . G .; G B . . (SHAL I A S) ' .; G p = p . (\u00d8; p . .@t ) .0 = mkident(M; G; .0 t G) c M : (SHMO \nD) .; G p = [M] . (.0: t+; p . .0@t ) a, \u00df fresh t 0 = (|\u00d8 ; [\u00df]dent|) G; t0 c S t ; F ' (SHSI G) .; \nG p :: [S] . ((a: t- , F ' ); p . a@t ) a fresh (P : .a..) . . = rename(r; .) . ' (SHIN C) .; G include \nP r . shape(. ' ) . B . . (SHNI L) . \u00d8 . (\u00d8; \u00d8) . B1 . . 1 .; . 1 B2 . . 2 . 1 + . 2 . . (SHSE Q) . B1, \nB2 . . Figure 7. Shaping rules (ignoring thinning). .ed in the hole signature S. (The intermediate t \n0 merely encodes these fresh identities as input to the signature shaping judgment.) The reason for this \nis simply to maximize .exibility: there is no reason to demand a priori that the module that .lls in \nthe hole (i.e., the module whose identity . will end up getting substituted for a) must itself be responsible \nfor de.ning all the entities speci.ed in the hole signature it need only be responsible for exporting \nthose entities, which may very well have been de.ned in other modules. The shape F A in Figure 5 illustrates \nthe output of SHSI G on the Array hole in package arrays-sig. This shape speci.es that \u00dfAA is a module \nde.ning an entity called Arr, that \u00dfAS is a module de.ning an entity called something, and that aA is \na module bringing [\u00dfAA]Arr and [\u00dfAS ]something together in its export spec. Of course, when the hole \nis eventually .lled (e.g., in the graph-a package, whose shaping is discussed below), it may indeed be \nthe case that the same module identity . is substituted for aA, \u00dfAA, and \u00dfAS i.e., that . both de.nes \nand exports Arr and something but SHSIG does not require this. Returning now to the merging judgment \n. 1 + . 2 . . that is invoked in the last premise of (SHSE Q): This merging judgment (Appendix \u00a76.6) \nis where the real meat of shaping occurs in particular, this is where mixin linking is performed by uni.cation \nof module identities. If a module with logical name p is mapped by . 1 and . 2 to physical identities \n.1 and .2, respectively, the merging judgment will unify .1 and .2 together. Moreover, if .1 and .2 are \nspeci.ed by . 1 and . 2 as having different module shapes t 1 and t 2, respectively, those shapes will \nbe merged as well, with the resulting shape containing all of the components speci.ed in either t 1 and \nt 2. For any entities appearing in both t 1 and t 2, their provenances will be uni.ed. To see a concrete \ninstance of this, consider the merging that occurs during the shaping of the graph-a package in our running \nexample in Figure 5. The graph-a package includes two packages de.ned earlier: arrays-a and structures. \nAs per rule (SHINC), each inclusion will generate fresh identity variables for the packages holes (say, \naP , \u00dfPL, aA, \u00dfAA, \u00dfAS for structures, and a ' PL for P , \u00df ' arrays-a). Since both packages export Prelude, \nthe merging judg\u00adment will unify aP and a ' P , the physical identities associated with Prelude in the \nshapes of the two packages; consequently, the shape of aP , namely (|\u00d8 ; [\u00dfPL]List(Nil, Cons)|), will \nbe uni.ed with the shape of a ' PL]List(Nil, Cons)|), resulting P , namely (|\u00d8 ; [\u00df ' in the uni.cation \nof \u00dfPL and \u00df ' PL as well. Similarly, since both packages export Array, the merging judg\u00adment will link \nthe implementation of Array in arrays-a with the hole for Array in structures by unifying aA, \u00dfAA, and \n\u00dfAS with .AA. As a result, the occurrences of aA, \u00dfAA, and \u00dfAS in .G (and its shape) get substituted \nwith .AA, which explains why the shape of graph-a maps Graph to .GA = .G[.AA/aA]. Lastly, merging will \ncheck that the implementation of Array in arrays-a actually provides all the entities required by the \nhole speci.cation in struc\u00adtures, i.e., that F AA subsumes F A, which indeed it does.  3.3 Typing In \nour running example thus far, we have not yet performed any typechecking of core-level code, such as \nthe code inside multinst s Client module. There is a good reason for this: before shaping, we don t know \nwhether core-level types such as GA.G and GB.G (imported by Client) are equal, because we don t know \nwhat the identities of GA and GB are. But after shaping, we have all the identity information we need \nto perform typechecking proper. Thus, as seen in the top-level package rule TYPKG in Figure 8, the output \nof the shaping judgment namely, . pkg is passed as input to the typing judgment, .; . pkg f B : . dexp \n. Typing, in turn, produces a package type ., which enriches the package shape . pkg with core-level \n(i.e., Haskell-level) typing information. The .nal type returned for the package, .a.., then just quanti.es \nover the variable identities a of the holes in ., so that they may be instantiated in different ways \nby subsequent package de.nitions. The package types . generated for the packages in our running example \nappear in the third column of Figure 5. Formally, the only difference between these package types and \nthe package shapes in the second column of Figure 5 lies in the difference between their constituent \nmodule types t = (|dspc ; espc|) and module shapes t = (|dent ; espc|). Whereas the de.ned entities component \n(dent) of t only names the entities de.ned by a module, the de.ned entity specs component (dspc ) of \nt additionally speci.es their core-level kinds/types. For example, observe the module type ascribed to \narrays-a s module .AA in FAA. This type enriches the pre-computed shape (in F AA) with additional information \nabout the kind of Arr and the type of something. Let us now explain the typing rules in Figure 8. For \nthe moment, we will ignore the shaded parts of the rules concerning elaboration into Haskell; we will \nreturn to them in Section 3.4. The rules TYNIL and TYSE Q implement typing of a sequence of bindings \nB. The procedure is structurally very similar to the one used in the shaping of B: we process (in left-to-right \norder) each constituent binding B, producing a type that we merge into the types of the previous bindings. \nThe key difference is that the partial merge operator . does not perform any uni.cation on mod\u00adule identities \nit merely performs a mixin merge, which checks that all speci.cations (kinds or types) assigned to any \nparticular core-level entity are equal. For instance, when typing graph-a, the mixin merge will check \nthat the type of something in the Array implementation from arrays-a is equal to the type of something \nin the Array hole from structures, and thus that the implementation satis.es the requirements of the \nhole. The remaining rules concern the typing of individual bindings, .; G; . pkg f B : . dexp . The typing \nrules TYMOD and TYSI G are structurally very similar to the corresponding shaping rules given in Figure \n7. The key difference is that, whereas SHMO D and SHSIG generate appropriate identities for their module/hole, \nTYMO D and TYSIG instead look up the pre-computed identities in the package shape . pkg. As an example \nof this, observe what happens when we type the Array module in arrays-a using rule TYMO D. The package \nshape . pkg we pre-computed in the shap\u00ading pass tells us that the physical module identity associated \nwith the logical module name Array is .AA, so we can go ahead and assume .AA is the identity of Array \nwhen typing its implementa\u00ad .; G; . pkg f B : . dexp ' p . .@t . G (TYAL I A S) ' .; G; . pkg f p = p \n: (\u00d8; p . .@t) {} p . .0@t 0 . . pkg G; .0 fc M : t hsmod (TYMO D) .; G; . pkg f p = [M] : (.0:t+; p \n. .0@t) {.0* . hsmod : t*} p . .0@t 0 . . pkg G; t0 fc S t; F ' F '' = .0:t- . F ' de.ned (TYSI G) .; \nG; . pkg f p :: [S] : (F '' ; p . .0@t) {.* . - : s* | .:s- . F '' } a fresh (P =.a.dexp : .a..) . . \n. ' =rename(r; .) . '' f . pkg =a . ' f = apply(f; . ' ) de.ned (TYIN C) .; G; . pkg f include P r : \n. '' apply(f*; dexp) .; . pkg f B : . dexp (TYNI L) .; . pkg f \u00d8 : (\u00d8; \u00d8) {} .; . pkg f B1 : .1 dexp1 \n. = .1 . .2 de.ned .; .1; . pkg f B2 : .2 dexp2 (TYSE Q) .; . pkg f B1, B2 : . dexp1 . dexp2 . f D : \n.a.. .a.dexp . B . . pkg .; . pkg f B : . dexp a=fv(.) (TYPK G) . f package P where B : .a.. .a.dexp \nFigure 8. Typing and elaboration rules (ignoring thinning). tion. Note that TYMO D and TYSIG call out \nto typing judgments for Haskell modules and signatures (fc). Like the analogous shap\u00ading judgments, these \nare de.ned formally in the appendix (Ap\u00adpendix \u00a75.1.1). Like TYMOD and TYSIG, the rule TYIN C also inspects \n. pkg to determine the pre-computed identities of the modules/holes in the package P being included. \nThe only difference is that an in\u00adcluded package contains a whole bunch of subcomponents (rather than \nonly one), so looking up their identities is a bit more in\u00advolved. It is performed by appealing to a \nmatching judgment f . pkg =a . ' f, similar to the one needed for signature match\u00ading in ML module systems \n[28]. This judgment looks up the instan\u00ad tiations of all the included holes by matching . ' (the type \nof the included package P after applying the renaming r) against . pkg. This produces a substitution \nf with domain a, which then gets ap\u00adplied to . ' to produce the type of the include binding. For example, \nwhen typing the package graph-a, we know after shaping that the identity of the Array module is .AA. \nWhen we include structures, the matching judgment will glean this information from . pkg, and produce \na substitution f mapping structures aA parameter to the actual Array implementation .AA.  3.4 Elaborating \nBackpack to Haskell We substantiate our claim to retro.t Haskell with SMD through an elaboration of Backpack, \nour external language (EL), into a model of GHC Haskell, our internal language (IL). The EL, as we have \n (Module Names) f . IlModNames .aP \u00dfPL . (Module Sources) hsmod ::= . . . .. aP . . (File Expressions) \nfexp ::= hsmod | - (File Types) ftyp ::= (|dspc * ; espc *|)tfexp ::= fexp : ftyp \u00dfPL . (Typed File Expressions) \n. . (Directory Expressions) dexp ::= {f . tfexp} module .AA (Arr(MkArr)) where import quali.ed aP as \nP (List(Nil,Cons)) . .. . .. (-) * . Identities/=\u00b5 > IlModNames (Identity Translation) . .AA data Arr \ni e = MkArr ... something = P.Nil :: P.List (Arr i e) Figure 9. IL syntax. (dspc * and espc * mention \nf instead of ..) module .AB (Arr(ANil, ...)) where import aP as Prelude (List(Nil, Cons)) . . .. .. . \n.. demonstrated so far, extends across the package, module, and core .AB data Arr i e = ANil | ... . \n. . . levels, while the IL de.nes only module and core levels; effectively something = Cons ANil Nil \n. . the outer, package level gets compiled away into mere modules in the IL. Figure 9 gives the syntax \nof the IL; for its semantics, includ\u00ad module .GA (G(...)) where import aP as Prelude (List(Nil, Cons)) \nimport .AA as Array (Arr(), something) .. .GA ing the typing judgment, see the technical appendix (Appendix \n\u00a77). Elaboration translates a Backpack package into a parameter\u00adized directory expression .a.dexp, which \nis a mapping from a set data G ... . module .GB (G(...)) where of module names f to typed .le expressions \ntfexp, parameterized over the identities a of the package s holes. We assume an embed\u00adding (-) * import \naP as Prelude (List(Nil, Cons)) import .AB as Array (Arr(), something) ... .. . . .. .GB from module \nidentities into IL module names, which respects the equi-recursive equivalence on module identities that \ndata G ... module .C (main, GA.G()) where . the Backpack type system relies on. However, for readability, \nwe import quali.ed .GA as GA (G()) import quali.ed .GB as GB (G()) .. .C . . . . will leave the embedding \nimplicit in the remainder of this section. main = ... GA.G ... GB.G ... As for the typed .le expressions \ntfexp, they can either be de.ned .le expressions (hsmod : ftyp), which provide both an implemen\u00adtation \nof a module along with its type, or unde.ned .le expressions (- : ftyp), which describe a hole with type \nftyp. Thus, all com\u00adponents of a dexp are explicitly-typed. This has the bene.t that the modules in a \ndexp can be typechecked in any order, since all static information about them is speci.ed in their explicit \n.le types. As a continuation of our running example, Figure 10 displays the elaboration of the multinst \npackage, except with the .le types stripped off for brevity. First, note that each module identity . \nin the physical type FM of multinst (lower-right hand corner of the table in Figure 5) corresponds to \none of the Haskell modules in the elaboration of the package, and for each ., its type in FM is (modulo \nthe embedding (-) *) precisely the .le type of . that we have omitted from Figure 10. The concrete module \nidentities in FM map to de.ned .le expressions, while the identity variables aP and \u00dfPL (representing \nholes) map to unde.ned .le expressions. The elaboration of packages (marked with shaded text ) is al\u00admost \nentirely straightforward, following the typing rules. More in\u00adteresting is the elaboration of Haskell \nmodules, which is appealed to in the second premise of rule TYMOD (and formalized in the appendix; Appendix \n\u00a76). Offhand, one might expect module elabo\u00adration to be the identity translation, but in fact it is \na bit more subtle than that. Consider the .C entry in the directory, corresponding to the Client module, \nas a concrete example. The module header: Unlike the original EL implementation of Client, which was \nanonymous, its elaborated IL version has a module header specifying .C as its .xed physical name, and \nmain and GA.G() as its exported entities. More generally, the exported entities should re.ect those listed \nin the module s type t . The import statements: Our elaboration rewrites imports of log\u00adical names like \nGA into imports of physical module identities like .GA, since the physical identities are the actual \nnames of Haskell modules in the elaborated directory expression. We must therefore take care to preserve \nthe logical module names that the de.nitions in the module s body expect to be able to refer to. For \nexample, the reference GA.G is seen to have provenance [.GA]G during Backpack typechecking of Client, \nso in the elaborated IL version of Client we want GA.G to mean the same thing. We achieve this by means \nof Haskell s import aliases , which support renaming of imported module names; e.g., the .rst import \nstatement in .C imports the Figure 10. Elaboration of multinst. (For readability, the transla\u00adtion from \nidentities to module names, (-) * , and the .le type anno\u00adtation on each module .le have been omitted. \nSee Figure 5 for the latter.) physical name .GA but gives it the logical name GA in the body, thus ensuring \nthat the reference GA.G still has (the same) meaning as it did during Backpack typechecking. The body: \nThanks to the import aliasing we just described, the entity de.nitions in the body of .C can remain syntactically \nidentical to those in the original Client module. Explicitness of imports and exports: All imported and \nexported entities are given as explicitly as the Haskell module syntax allows, even when the original \nEL modules neglect to make them explicit; e.g., the original code for Graph lists neither its imports \nnor its exports, but its elaboration (as .GA and .GB ) does. The primary reason for this explicitness \nis that it enables us to prove a weak\u00adening property on IL modules, which is critical for the proof of \nsoundness of elaboration. If modules are not explicit about which core-level entities they are importing \nand exporting, their module types will not be stable under weakening.  3.5 Formalization of Haskell \nModules and Soundness We have proven the following key soundness theorem about the elaboration: if a \npackage de.nition D has type .a.(F; L) and elaborates into a parameterized directory expression .a.dexp, \nthen every module in dexp is well-typed in the IL, and the identities and types in F directly match those \nof dexp. (For example, soundness means that the identities and EL module types appearing in the type \nof multinst in Figure 5 correspond precisely to the names and types of the IL modules in Figure 10.) \nAs part of this effort, our IL constitutes a new formal model of the Haskell module system. This model \nfollows the Haskell Lan\u00adguage Report as closely as possible in its de.nition of well-formed modules i.e., \nthe processing of module dependencies through im\u00adport statements and export lists. Unlike previous work \non formal\u00adizing the Haskell module system [7, 12], our model supports (sep\u00adarately typechecked) recursive \nmodules; furthermore, we have de\u00adveloped some basic metatheory for the IL (e.g., substitution and weakening \n) in order to prove soundness of elaboration, a non\u00adtrivial undertaking given that substitution can result \nin the merging of module/signature bindings. Full details of the IL are given in the accompanying technical \nappendix (Appendix \u00a77).  We do not provide any kind of dynamic semantics in Backpack and thus we cannot \nprove (or even state) any conventional type safety theorem. Instead, the soundness of Backpack s elaboration \nsimply reduces the question of whether Backpack is type-safe to the question of whether Haskell is type-safe. \n4. Related Work and Technical Discussion Detailed Comparison with MixML ML modules provide a very expressive \nand convenient language for programming with ab\u00adstract data types. However, due to the double vision \nproblem (Sec\u00adtion 2.6), functors are fundamentally incompatible with recursive linking [27]. There have \ntherefore been several attempts to synthe\u00ad size aspects of ML modules and mixin modules in a single system, \nincluding Owens and Flatt s typed unit calculus [25] and Duggan s type system for recursive DLLs [10]. \nArguably the most advanced system in this space is Rossberg and Dreyer s MixML [27], which aims to be \na highly expressive foundational calculus of mixin modules for an ML-like core lan\u00adguage. Backpack s \ndesign and semantics are inspired by those of MixML, but our design decisions, driven by our goal of \nretro.tting Haskell with SMD, have led to considerable simpli.cations. MixML supports .rst-class and \nhigher-order units (i.e., instan\u00adtiable mixins), whereas Backpack s units packages only exist at the \ntop level. We believe Backpack s units to be suf.cient for practical programming, and restricting them \nto top level stream\u00adlines the semantics of applicative identities. MixML also supports hierarchical mixin \nmodules with deep linking , but Backpack re\u00adstricts packages to be .at namespaces of modules. Deep linking \nlets MixML express many different ML constructs (e.g., n-ary sig\u00adnatures) using just one form of linking. \nSince our focus is on prac\u00adticality rather than expressiveness, we sacri.ce features like .rst\u00adclass \nunits and deep linking for simplicity of syntax and seman\u00adtics, optimizing instead for common usage patterns. \nIn particular, our include construct is more straightforward to program with than MixML s binary linking/binding \nconstruct, and .ts better with the feel of the Haskell module language (e.g., its import statements). \nBackpack also provides some features that MixML lacks, such as renaming, thinning, and an applicative \nsemantics of instantiation. Concerning the double vision problem, MixML solves it through the use of \na two-pass algorithm for typechecking linked modules: the .rst pass computes all information about type \ncomponents in the modules, and the second pass performs full typechecking. In MixML, these two passes \nare de.ned using a single set of infer\u00adence rules, with the .rst pass de.ned by conveniently ignoring \ncertain premises. Backpack adopts the same two-pass idea in or\u00adder to compute the physical module identities \ninvolved in a pack\u00adage before typechecking it. However, Backpack distinguishes the two passes shaping \nand typing using completely separate judg\u00adments and rules. Although this leads to a doubling of rules, \nthe rules themselves are (we feel) much easier to understand. In particular, the account of linking given \nby the sequencing rules SHSEQ and TYSE Q is considerably simpler than MixML s formidable linking rule. \nMoreover, Backpack stages the shaping pass over a whole package entirely before the typing pass, leading \nto a clearer con\u00adceptual split between the two phases of package typechecking than in MixML, where the \ntwo passes are interleaved. A key reason we can get by with a simpler semantics of linking is that we \nare deliberately less ambitious than MixML in a certain sense: unlike MixML, we do not aim to completely \nsubsume the functionality of ML modules. MixML does, and this means that its semantics must deal with \nnested uses of translucent sealing (i.e., the ability to de.ne types that are transparent inside a module \nbut opaque outside), a de.ning feature of ML modules which compounds the already-tricky double-vision \nproblem. In contrast, Backpack does not attempt to support translucent sealing and thus does not suffer \nthe attendant complexities for the simple reason that Haskell, our target of elaboration, cannot support \nit. Finally, MixML is de.ned by elaboration into an internal lan\u00adguage, LTG, which was designed speci.cally \nto capture all the nec\u00adessary features of MixML. (LTG is an extension, with linear kinds, of an earlier \nIL, similarly specialized for recursive ML module sys\u00adtems, called RTG [9].) LTG s unconventional metatheory \nunder\u00ad scores MixML s status as a foundational calculus rather than a prac\u00adtical language design, in \ncontrast to Backpack, whose IL is a for\u00admalization of an existing implementation artifact, the GHC module \nsystem. A major bene.t of our approach is that the semantics (via elaboration) of a Backpack package \nmay be understood by Haskell programmers essentially in terms of a reshuf.ing of import and ex\u00adport lists \nin their Haskell modules. The elaboration in Figure 10 is a case in point. Logical Module Names vs. Physical \nModule Identities Module identities, which establish canonical physical names for modules (as distinct \nfrom program-level logical names), serve two important roles in Backpack s semantics: (1) they simplify \nand regularize the elaboration into Haskell modules (and its soundness proof), and (2) they are the principal \ncomponent of our solution for how to support applicative mixin linking. Concerning the .rst point: The \ndistinction between logical and physical names is a central technical element enabling and con\u00adceptually \nreinforcing the elaboration into our Haskell-based IL. In particular, a key invariant of elaboration \nis that the physical part of a package s EL type gives a precise description of the IL mod\u00adules that \nit elaborates to; the logical part of its type is only relevant for namespace management during Backpack-level \ntypechecking. Concerning the second point: The idea of distinguishing be\u00adtween logical and physical names \nis not new. A number of prior for\u00admalisms for ML-style modules including the De.nition of Stan\u00addard ML \nitself rely on a similar distinction [22, 29, 28]. The key advantage of this approach (as opposed to \nmore direct, syntactic type systems for modules, e.g., [20, 15]) is that physical identities greatly \nsimplify the treatment of type equality in the presence of aliasing: no matter their logical names, two \ntypes are equal iff they have the same physical identity. This eliminates the need for fancier mechanisms \nfor handling type sharing, like translucent sums or sin\u00adgleton kinds (see Rossberg et al. [28] for further \ndiscussion). More\u00ad over, for recursive and mixin module extensions of ML [8, 27], the logical/physical \ndistinction has enabled clean solutions to the dou\u00adble vision problem, as discussed above. (There is \nsome recent work by Im et al. [19] on solving double vision syntactically i.e., us\u00ading only logical names \nbut it does not account for separate type\u00adchecking of mutually recursive modules in general.) What distinguishes \nBackpack from these prior systems is its support for both separate typechecking of recursive modules \nand an applicative semantics of instantiation, as appropriate for a pure language like Haskell. To handle \nthe combination, we needed to enrich the language of module identities with both (equi-)recursive \u00b5-binders \nand constructor applications, and employ (standard) uni\u00ad.cation and equivalence-checking algorithms that \nwork for these recursive identities [18, 14]. To see why, consider the example from Section 2.6, in which \nthe modules A and B in package ab-rec-sep have the recursive identities .A and .B de.ned on the subsequent \npage. If one were to de.ne another package ab-rec-sep2 in the same way, the identities of A and B would \nbe exactly the same. In contrast, were we to code up this example in MixML, each dis\u00adtinct package de.ned \nlike ab-rec-sep would produce modules with fresh (distinct) identities, as one would expect given MixML \ns generative semantics of instantiation. Nevertheless, we observe that recursive identities do not complicate \nthe semantics much, a testa\u00adment to the scalability of the logical/physical approach.  Separate Compilation \nfor ML Setting aside the lack of support for recursive linking, ML functors are not by themselves really \na practical mechanism for SMD due to the proliferation of sharing constraints that are known to arise \nwhen programming in a fully functorized style (i.e., in which modules are parameterized explic\u00aditly, \nvia the functor mechanism, over all their dependencies). Con\u00adsequently, a number of systems have been \nproposed for building a better SMD framework on top of the existing ML module system. Before discussing \nthese systems in more detail, let us observe two important ways in which they all differ from Backpack. \nFirst, unlike Backpack, the separate compilation systems for ML build improved SMD support on top of \nthe already-powerful ML module system, which offers instantiation, reuse, and at least some form of SMD \nvia functors. In contrast, Backpack is built on top of Haskell, which lacks those features, and thus \nthe expressiveness boost it offers over the underlying language is in some sense more signi.cant. Second, \nwe realize this boost not through functors but through mixins; as a result, Backpack supports recursive \nlinking, and avoids the need for any separate notion of sharing constraints. To address the lack of separate \ncompilation in ML, Cardelli introduced a foundational calculus of linksets [5]. However, as a foundational \ncalculus, this framework lacks support for user\u00adde.ned abstract data types, as well as recursion at the \nmodule or core level two prominent features that drive the complexity of state-of-the-art module systems. \nBuilding on Cardelli s linkset foundation, Swasey et al. [31] designed a typed language of pro\u00ad gram \nfragments, SMLSC, that organizes lists of top-level SML def\u00adinitions (e.g., modules) into what they call \nunits. Linking happens automatically by name when unit de.nitions are considered in the same linkset. \nIn particular, when multiple units in a linkset have interface imports on some common name, those dependencies \nunify automatically without extra annotations. SMLSC units there\u00adfore eliminate the need for sharing \nconstraints on dependencies as mixin modules do but they do not permit recursive linking. In a different \nvein, targeting open modular programming, the Acute language of Sewell et al. [30] and the Alice ML language \nof Rossberg et al. [26] support not only separate compilation, but dy\u00ad namic linking, marshalling/pickling, \nand (in the case of Acute) ver\u00adsioning of components, all of which are beyond the scope of Back\u00adpack. \nWhile Acute repurposes modules (with new primitive opera\u00adtions) as a mechanism for compilation units \nand linking, Alice ML de.nes components by reduction to a simpler construct of pack\u00adages (modules as \n.rst-class core values). Linking in Acute con\u00adsists of (non-recursive) chains of module de.nitions and \nimports, whereas Alice ML employs a more .exible and dynamic compo\u00adnent manager approach based on Java \nclass-loading (rather than linksets). Neither Acute nor Alice ML supports recursive modules. As part \nof the OCaml module system [21], the ocamlc compila\u00adtion tool performs separate compilation on .les that \ncontain module components. The tool treats the .le system rather like a mixin: each component (i.e., \na .le) can be de.ned as an implementation (i.e., a .ml .le) or a hole (i.e., a .mli .le), and components \ncan be re\u00ad cursively linked. Like SMLSC but unlike Backpack, though, these object-oriented community, \nmixins have already seen signi.cant uptake. Both Scala [24] and J&#38; [23], for instance, incorporate \nmixin-style composition into the very fabric of their designs. How\u00adever, as we have explained, we are \nparticularly interested in the question of how to retro.t existing languages with mixin-based SMD, and \nto our knowledge there is relatively little work on that. The SMARTJAVA MO D/component systems of Ancona \net al. [2] de.ne a new level of mixin modules to encapsulate existing Java classes. A component contains \nde.ned classes and deferred classes, the latter of which are speci.ed as abstract class names with various \nconstraints. The bind construct, which performs mixin linking, instantiates components generatively, \nproducing a unique copy of all the classes inside the merged result (and thus fresh abstract types). \nIn contrast, Backpack supports an applicative semantics of instantiation. The SM A RT JAVA MO D/component \nlanguages are implemented with a translation into polymorphic bytecode [1], essentially an extension \nof JVM bytecode with markers and constraints for the de\u00adferred classes (i.e., holes) in the component. \nFor that reason, their IL resembles Backpack s, although they present no formal de.ni\u00adtion of their elaboration \ninto this language. Instead, they de.ne a reduction semantics on components that .attens them into fully \nin\u00adstantiated Java class de.nitions. In Backpack, following much work on ML module systems [15, 28, 27], \npackages do not have a direct reduction semantics rather, their meaning is given by a formal translation \ninto a typed IL, in our case based on Haskell. As is the tradition in object-oriented languages, the \naforemen\u00adtioned systems emphasize dynamic binding, virtual methods, over\u00adriding, etc., and do not consider \nthe issue of the double vision prob\u00adlem. In contrast, Backpack supports only static binding, does not \npermit overriding, and invests great effort to avoid double vision. 5. Future Work Type Classes Backpack \nmodules only allow data types and val\u00adues; type classes and type class instances are conspicuously absent. \nWe have left them out of the system deliberately in order to focus attention on the essential features \nof Backpack that we hope will be broadly applicable, not just to Haskell. That being said, we believe \nthat incorporating type classes into Backpack should be feasible. In the extension we envision, type \nclasses and instances would both be new kinds of core entities, although the latter would differ from \nexisting entities in that (1) they do not have simple syntactic names and (2) import resolution treats \nthem differently (see below). As with all entities, the export specs (espc ) listed in a module type \nwould denote which instances a module provides to its clients. The interaction between instances and \nsignatures poses an in\u00adteresting challenge: linking an implementation for a hole, or even linking two \nholes together through aliasing, might result in the exis\u00adtence of two distinct instances for the same \ntype class and type that are visible within a single module. For example, in the bindings P = [class \nEq a where ...] A :: [data T] B :: [data. T] . import P C = .... import quali.ed A import quali.ed \nB .... mixins cannot be instantiated and reused: a separately-compiled .le cannot be linked with multiple \nimplementations of its depen\u00ad dencies. In essence, ocamlc implements something similar to the target \nIL of Backpack s elaboration, albeit for OCaml (obviously) well-typedness of C requires that A.T and \nB.T be distinct types. and extended with full separate compilation rather than just sep-But if we then \nadd an alias binding A = B, these two types are arate typechecking. It does not, however, provide a language \nfor uni.ed into a single one, and now C de.nes two different instances building and linking components, \nas Backpack does. for a single class and type, making it ill-typed. Mixin Modules for OO Languages Our \nfocus has been on mixin-To prevent this form of error, we would need to amend the based SMD in the setting \nof a typed functional language. In the de.nition of merging for sets of export specs (espc) to prevent \n two distinct instances for the same class and type from merging together successfully. This would be \nenough to guarantee that the substitution that links A and B together would not be well de.ned on the \npackage type for the previous four bindings, thus rejecting the addition of the alias binding A = B. \nWe would also need to extend the IL in order to maintain a crucial invariant of the elaboration translation, \nnamely that the IL translation of a module only imports the entities that were visible to that module \nduring Backpack-level typechecking (Section 3.4). Naively, this invariant would not be preserved in the \npresence of type classes because Haskell does not support named instances, so there is no way to explicitly \ndelimit the instances that one module imports from another. For example, suppose a module Y imports a \nhole X, and then the hole is subsequently .lled with an implementation de.ning an instance that was not \nin the signature for X. In that case, we do not want the elaboration of Y to suddenly see that new instance, \nsince it might break Y s well-typedness, but there is no way a priori to prevent it. To restore this \ninvariant in the presence of type classes, we would need to introduce only in the IL the ability to explicitly \nname instances on import statements. This capability, which would require a minor extension to GHC, would \nthen allow us, when elab\u00adorating Y in the above example, to explicitly restrict the import of X to only \ninclude those instances that were visible in X s signature. Type Synonyms and newtype We could straightforwardly \nex\u00adtend Backpack with both type synonyms and Haskell s newtype mechanism for de.ning abstract data types. \nBoth would be sepa\u00adrate entities along with datatypes and values, with accompanying de.ned entity specs \n(dspc); because they are core entities, they would be imported, exported, and recorded in module types \njust like datatypes and values. However, for compatibility with GHC, neither would be declarable abstractly \nin signatures (i.e., by omit\u00adting the right-hand sides ), unlike regular data types. In the case of type \nsynonyms, we would need to treat them as transparently equal to their de.ning types. To accomplish this, \nwe would simply expand type synonyms as part of Backpack elabo\u00adration, ensuring that they never appeared \nin our semantic objects (the F-ing modules approach of Rossberg et al. [28] works sim\u00ad ilarly). Since \nthe synonyms themselves would never appear in any semantic types (typ), they would not complicate type \nequality. In contrast, newtypes would not be automatically equated with their de.ning types; in semantic \ntypes (typ) they would look and behave essentially like regular data types. Versioning Lastly, while \nthe support for versioning in Cabal (Haskell s existing package management system) does not obvi\u00adate \ninterfaces and mixins, neither do interfaces and mixins obviate versioning. An important direction for \nfuture work is to investigate how best to integrate versioning into Backpack. Acknowledgments We are \ngrateful for innumerable impromptu whiteboard discussions with Neel Krishnaswami, Joshua Dun.eld, Aaron \nTuron, Beta Zil\u00adiani, and Georg Neis; for early design discussions with Claudio Russo, Dimitrios Vytiniotis, \nand Duncan Coutts; and for detailed technical feedback from Andreas Rossberg. References [1] Davide Ancona, \nFerruccio Damiani, Sophia Drossopoulou, and Elena Zucca. Polymorphic bytecode: compositional compilation \nfor Java\u00adlike languages. In POPL 05. [2] Davide Ancona, Giovanni Lagorio, and Elena Zucca. Flexible type\u00adsafe \nlinking of components for Java-like languages. In JMLC 06. [3] Davide Ancona and Elena Zucca. A calculus \nof module systems. JFP, 12(2), 2002. [4] Gilad Bracha and Gary Lindstrom. Modularity meets inheritance. \nIn ICCL 92. [5] Luca Cardelli. Program fragments, linking, and modularization. In POPL 97. [6] Karl Crary, \nRobert Harper, and Sidd Puri. What is a recursive module? In PLDI 99. [7] Iavor S. Diatchki, Mark P. \nJones, and Thomas Hallgren. A formal speci.cation of the Haskell 98 module system. In Haskell 02. [8] \nDerek Dreyer. A type system for recursive modules. In ICFP 07. [9] Derek Dreyer. Recursive type generativity. \nJFP, 17(4&#38;5), 2007. [10] Dominic Duggan. Type-safe linking with recursive DLLs and shared libraries. \nACM TOPLAS, 24(6):711 804, 2002. [11] Dominic Duggan and Constantinos Sourelis. Mixin modules. In ICFP \n96. [12] Karl-Filip Fax \u00b4en. A static semantics for Haskell. JFP, 12(5), 2002. [13] Matthew Flatt and \nMatthias Felleisen. Units: Cool modules for HOT languages. In PLDI 98. [14] Nadji Gauthier and Franc\u00b8 \nois Pottier. Numbering matters: First-order canonical forms for second-order recursive types. In ICFP \n04. [15] Robert Harper and Chris Stone. A type-theoretic interpretation of Standard ML. In Proof, Language, \nand Interaction: Essays in Honor of Robin Milner. MIT Press, 2000. [16] Tom Hirschowitz and Xavier Leroy. \nMixin modules in a call-by-value setting. ACM TOPLAS, 27(5):857 881, 2005. [17] Paul Hudak, John Hughes, \nSimon Peyton Jones, and Philip Wadler. A history of Haskell: Being lazy with class. In HOPL III, 2007. \n[18] Gerard Huet. \u00b4R\u00b4esolution d \u00b4equations dans des langages d ordre 1, 2, . . ., .. PhD thesis, Universit \n\u00b4e Paris 7, September 1976. [19] Hyeonseung Im, Keiko Nakata, Jacques Garrigue, and Sungwoo Park. A syntactic \ntype system for recursive modules. In OOPSLA 11. [20] Xavier Leroy. Applicative functors and fully transparent \nhigher-order modules. In POPL 95. [21] Xavier Leroy. The Objective Caml system: Documentation and user \ns manual. http://caml.inria.fr/ocaml/htmlman/. [22] Robin Milner, Mads Tofte, Robert Harper, and David \nMacQueen. The De.nition of Standard ML (Revised). MIT Press, 1997. [23] Nathaniel Nystrom, Xin Qi, and \nAndrew Myers. J&#38;: Nested intersec\u00adtion for scalable software composition. In OOPSLA 06. [24] Martin \nOdersky and Matthias Zenger. Scalable component abstrac\u00adtions. In OOPSLA 05. [25] Scott Owens and Matthew \nFlatt. From structures and functors to modules and units. In ICFP 06. [26] Andreas Rossberg. The missing \nlink dynamic components for ML. In ICFP 06. [27] Andreas Rossberg and Derek Dreyer. Mixin up the ML \nmodule system. ACM TOPLAS, 35(1), 2013. [28] Andreas Rossberg, Claudio V. Russo, and Derek Dreyer. F-ing \nmod\u00adules. In TLDI 10. Extended version available from the author s web\u00adsite at: http://www.mpi-sws.org/~rossberg/f-ing. \n[29] Claudio V. Russo. Types for Modules. PhD thesis, University of Edinburgh, 1998. [30] Peter Sewell, \nJames J. Leifer, Keith Wansbrough, Francesco Zappa Nardelli, Mair Allen-Williams, Pierre Habouzit, and \nViktor Vafeiadis. Acute: High-level programming language design for distributed com\u00adputation. JFP, 17(4 \n5), 2007. [31] David Swasey, Tom Murphy VII, Karl Crary, and Robert Harper. A separate compilation extension \nto Standard ML. In ML 06.   \n\t\t\t", "proc_id": "2535838", "abstract": "<p>Module systems like that of Haskell permit only a weak form of modularity in which module implementations depend directly on other implementations and must be processed in dependency order. Module systems like that of ML, on the other hand, permit a stronger form of modularity in which explicit interfaces express assumptions about dependencies, and each module can be typechecked and reasoned about independently.</p> <p>In this paper, we present Backpack, a new language for building separately-typecheckable *packages* on top of a weak module system like Haskell's. The design of Backpack is inspired by the MixML module calculus of Rossberg and Dreyer, but differs significantly in detail. Like MixML, Backpack supports explicit interfaces and recursive linking. Unlike MixML, Backpack supports a more flexible applicative semantics of instantiation. Moreover, its design is motivated less by foundational concerns and more by the practical concern of integration into Haskell, which has led us to advocate simplicity---in both the syntax and semantics of Backpack---over raw expressive power. The semantics of Backpack packages is defined by elaboration to sets of Haskell modules and binary interface files, thus showing how Backpack maintains interoperability with Haskell while extending it with separate typechecking. Lastly, although Backpack is geared toward integration into Haskell, its design and semantics are largely agnostic with respect to the details of the underlying core language.</p>", "authors": [{"name": "Scott Kilpatrick", "author_profile_id": "81490691999", "affiliation": "MPI-SWS, Saarbruecken, Germany", "person_id": "P4383736", "email_address": "skilpat@mpi-sws.org", "orcid_id": ""}, {"name": "Derek Dreyer", "author_profile_id": "81548019178", "affiliation": "MPI-SWS, Saarbruecken, Germany", "person_id": "P4383737", "email_address": "dreyer@mpi-sws.org", "orcid_id": ""}, {"name": "Simon Peyton Jones", "author_profile_id": "81100271851", "affiliation": "Microsoft Research, Cambridge, United Kingdom", "person_id": "P4383738", "email_address": "simonpj@microsoft.com", "orcid_id": ""}, {"name": "Simon Marlow", "author_profile_id": "81548018677", "affiliation": "Facebook, London, United Kingdom", "person_id": "P4383739", "email_address": "marlowsd@gmail.com", "orcid_id": ""}], "doi_number": "10.1145/2535838.2535884", "year": "2014", "article_id": "2535884", "conference": "POPL", "title": "Backpack: retrofitting Haskell with interfaces", "url": "http://dl.acm.org/citation.cfm?id=2535884"}