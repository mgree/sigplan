{"article_publication_date": "01-08-2014", "fulltext": "\n Consistency Analysis of Decision-Making Programs * Swarat Chaudhuri Azadeh Farzan Zachary Kincaid Rice \nUniversity University of Toronto University of Toronto swarat@rice.edu azadeh@cs.toronto.edu zkincaid@cs.toronto.edu \n Abstract Applications in many areas of computing make discrete decisions under uncertainty, for reasons \nsuch as limited numerical precision in calculations and errors in sensor-derived inputs. As a result, \nindi\u00advidual decisions made by such programs may be nondeterministic, and lead to contradictory decisions \nat different points of an execu\u00adtion. This means that an otherwise correct program may execute along \npaths, that it would not follow under its ideal semantics, vi\u00adolating essential program invariants on \nthe way. A program is said to be consistent if it does not suffer from this problem despite un\u00adcertainty \nin decisions. In this paper, we present a sound, automatic program analysis for verifying that a program \nis consistent in this sense. Our analysis proves that each decision made along a program execution is \ncon\u00adsistent with the decisions made earlier in the execution. The proof is done by generating an invariant \nthat abstracts the set of all deci\u00adsions made along executions that end at a program location l, then \nverifying, using a .xpoint constraint-solver, that no contradiction can be derived when these decisions \nare combined with new deci\u00adsions made at l. We evaluate our analysis on a collection of programs imple\u00admenting \nalgorithms in computational geometry. Consistency is known to be a critical, frequently-violated, and \nthoroughly stud\u00adied correctness property in geometry, but ours is the .rst attempt at automated veri.cation \nof consistency of geometric algorithms. Our benchmark suite consists of implementations of convex hull \ncomputation, triangulation, and point location algorithms. On al\u00admost all examples that are not consistent \n(with two exceptions), our analysis is able to verify consistency within a few minutes. Categories and \nSubject Descriptors D.2.4 [Software/Program Veri.cation]: Correctness proofs; F.3.2 [Semantics of Program\u00adming \nLanguages]: Program analysis; F.2.2 [Computational Ge\u00adometry and Object Modelling]: Geometric algorithms, \nlanguages, and systems; G.4 [Mathematical Software]: Reliability and ro\u00adbustness Keywords Program Analysis; \nUncertainty; Consistency; Geome\u00adtry; Robustness * This research was partially supported by NSF Award \n#1156059 and an NSERC Discover Grant. Permission to make digital or hard copies of all or part of this \nwork for personal or classroom use is granted without fee provided that copies are not made or distributed \nfor pro.t or commercial advantage and that copies bear this notice and the full citation on the .rst \npage. Copyrights for components of this work owned by others than ACM must be honored. Abstracting with \ncredit is permitted. To copy otherwise, or republish, to post on servers or to redistribute to lists, \nrequires prior speci.c permission and/or a fee. Request permissions from permissions@acm.org. POPL 14, \nJanuary 22 24, 2014, San Diego, CA, USA. Copyright c &#38;#169; 2014 ACM 978-1-4503-2544-8/14/01. . . \n$15.00. http://dx.doi.org/10.1145/2535838.2535858 if (Left(p, q)) then L1 else L4; if (Left(q, r)) then \nL2 else L5; if (Left(p, r)) then L3 else L6 Figure 1. A possibly-inconsistent code snippet 1. Introduction \nThe problem of making decisions under uncertainty has fascinated computer scientists for a long time \n[13]. Abstractly, a decision\u00admaking process is a program that gathers information about an ex\u00adternal \nworld using a set of queries, and based on this information, makes changes to its discrete internal state. \nAn issue with such pro\u00adgrams is that the information that they gather from the world may be uncertain, \nand this uncertainty may affect program s decisions. Even a single wrong decision may lead the program \ndown code paths that were never meant to be followed, leading to unforeseen errors. For example, consider \na program that queries the world for the relative positions of three points p, q, and r on a line. Let \nLeft(u, v) denote the decision by the program that u lies to the left of v, and Left (u, v) the fact \nthat u is actually to the left of v. Now suppose the program makes the decisions Left(p, q) and Left(q, \nr). In this case, the program should also decide that Left(p, r), as the laws of geometry demand that \n(Left (p, q) . Left (q, r)) =. Left (p, r). (1) However, uncertainty creates a difference between what \nought to be and what is. Different queries to the world can be indepen\u00addently uncertain, and if p, q \nand r are close enough to be within the margin of error, the program may very well decide from the .nal \nquery that not Left(p, r) holds. Suppose now that the program in question looks like the one in Fig. \n1. Then, in the above scenario, it will execute the code L1 ; L2 ; L6 , a sequence that would not be \nex\u00adecuted under any input in the program s ideal semantics, where the laws of geometry hold. Since algorithm \ndesign often does not con\u00adsider this scenario, the consequence could be a serious error. A decision-making \nprogram is consistent if it is immune from errors like the one described above. Abstractly, let R be \nan ax\u00adiomatic speci.cation of the laws that we know to hold in a world T (e.g. Eqn. 1). A program is \nconsistent if it does not contradict any axioms in R no matter what answers it receives as the result \nof its queries to the world T. Consistency is an essential concern in applications where pro\u00adgrams make \nboolean decisions under uncertainty. It is, for example, a thoroughly studied problem in computational \ngeometry [7, 15, 16, 21, 26], where programs make decisions about relative positions of objects in continuous \ngeometric spaces1. Often, these positions can 1 In the geometry literature, consistency is known as robustness. \nWe avoid the latter term given its recent use [4, 5, 19] in the program veri.cation literature to denote \nan entirely different concept.  1 if Left(p, q) 2 then L1; 3 if Left(q, r) 4 then L2; L3 5 else L5; \nif Left(p, r) then L3 else L6 6 else 7 L4; 8 if Left(q, r) 9 then L2; if Left(p, r) then L3 else L6 10 \nelse L5; L6 Figure 2. Consistent variant of code in Fig. 1. only be known with limited degree of certainty \nand up to a limited level of accuracy. For instance, a robot doing geometric reasoning to detect collisions \nwith other objects must base its discrete deci\u00adsions on uncertain sensor data. Even on a standalone computer, \nthe outcomes of discrete queries about geometric datasets are typically uncertain due to numerical inaccuracies \n[22]. It is well-known that inconsistency between such decisions can cause everyday geomet\u00adric algorithms \nto crash, go into in.nite loops, and violate essential postconditions [21]. At the same time, consistency \nin our sense is not easily enforced through usual software engineering practices. It is dif.cult to test \na program for consistency since, by de.nition, errors due to uncer\u00adtainty may not be reproducible. Furthermore, \nas software is typi\u00adcally designed without uncertainty in mind, consistency is usually outside the scope \nof manual reasoning about algorithms. For ex\u00adample, most algorithm designers assume the axioms of geometry \nto hold to reason about correctness of their designs, and would not imagine situations where they might \nbreak down when these axioms are contradicted. Finally, reasoning about consistency re\u00adquires one to \nrelate decisions made at different points in a program execution to each other. Most programmers .nd \nthis type of global reasoning about programs to be inherently dif.cult. Given all this, the problem of \nautomatic formal veri.cation of the consistency of a decision-making program seems to be impor\u00adtant. \nIntriguingly, there is very little prior work on this problem. Researchers in application areas like \ncomputational geometry have traditionally steered clear of static reasoning about consistency, instead \nfocusing on dynamic approaches [21]. While there is an emerging literature on quantitative reasoning \nabout uncertain pro\u00adgrams [4, 5, 19] in the formal methods community, to our knowl\u00adedge there has been \nno prior work on verifying that a program makes sequences of discrete decisions consistently. In this \npaper, we present a sound, automatic program analysis to address this ver\u00adi.cation problem. Our analysis \napplies to in.nite-state programs that query a world consisting of an arbitrary number of abstractly \nde.ned data objects. A decision is the outcome of a query. We model uncertainty using nondeterminism, \nassuming that each query by the program can return either true or false. To see how a program can be \ncon\u00adsistent under such a model, consider the code in Fig. 2, which is equivalent to the program in Fig. \n1 in the absence of uncertainty (i.e., when Left(x, y) if and only if Left (x, y)). However, even if \nthe Left queries resolve nondeterministically due to uncertainty, this code is still guaranteed to satisfy \nthe axiom in Eqn. (1). The subtle difference between the two codes is that the one in Fig. 1 does not \nquery a fact when, from the context and the set of axioms, the only non-contradictory answer to the query \nis known. To automatically prove the consistency of programs like the one in Fig. 1, we must track the \npath-sensitive dependencies between different decisions made by the program. This is especially chal\u00adlenging \nwhen the program manipulates an unbounded number of objects. For example, suppose that a program decides, \nby repeat\u00adedly querying the world, that Left(p1, p2), Left(p2, p3), . . . , Left(pn-1, pn) for objects \np1, . . . , pn. If the program now also queries for the rel\u00adative positions of p1 and pn, we may have \na consistency violation. This is because we have Left(p1, pn) as a logical consequence of the program \ns decisions by Eqn. 1 while due to uncertainty the re\u00adsult of this query may very well be not Left(p1, \npn). To prove consistency, we must be able to reason that this type of violations, namely those that \nare derived through unbounded trees of reason\u00ading, cannot occur. Our approach to the automation of such \nproofs is based on an inductive argument. First, for each program location l, we compute an invariant \nHl called the history invariant that abstracts the set of all decisions made along all possible executions \nleading to l. Inductively, we assume the decisions in Hl to be mutually consis\u00adtent. Next we compute \na current-decision invariant dl that abstracts the set of new decisions that may be made at l. Consistency \nveri.\u00adcation now amounts to establishing that no decision in the set rep\u00adresented by dl, taken together \nwith a subset of decisions in Hl, can violate an axiom. We show that this check can be accomplished us\u00ading \na standard .xpoint constraint solver [14]. Decisions taken dur\u00ading the execution of a program, over a \ncollection of input objects, are abstracted by tuples of integers (where integers stand for object identi.ers); \ne.g. (1, 2) may stand for the decision Left(p1, p2). This then accommodates the abstraction of decision \ninvariants (as de.ned above) by integer linear arithmetic formulae. We evaluate our analysis by applying \nit to a suite of programs from the domain of computational geometry [7, 21], including im\u00adplementations \nof standard algorithms for convex hull computations, triangulation, and point location algorithms. While \nsmall in size, programs like these are at the heart of geometric libraries used by large real-world systems \nsuch as CAD, Geographical Information Systems, Computer Graphics, and various Scienti.c Computing applications. \nThese examples are also complex: the reasons why they satisfy consistency or fail to do so are often \nsubtle, and small, innocent-looking changes to the code can turn a consistent algo\u00adrithm into an inconsistent \none, or vice versa. However, in almost all of the programs that are actually consistent, our analysis \nis able to prove consistency automatically and ef.ciently. We summarize the contributions of this paper \nas follows: We formulate the problem of verifying the consistency of in.nite-state decision-making programs \n(Sec. 2), and give a sound, automatic program analysis to solve it. (Sec. 4).  We identify an application \ndomain for our analysis where con\u00adsistency is a critical correctness property, and where program analysis \nhas not been tried before (Sec. 3).  We provide a prototype implementation of our system, and eval\u00aduate \nthe practical utility of the system using a comprehensive suite of convex hull and triangulation algorithms. \n(Sec. 5).  2. Formalizing consistency In this section, we formalize the property of consistency for \ndecision-making programs. We start by de.ning the worlds that are queried by our programs. These queries \nare answered with un\u00adcertainty, and it is this uncertainty that may cause a violation of consistency. \n 2.1 Modelling the world A world consists of a set of typed objects together with a set of predicates \nthat are used to query various relationships between these objects. Formally, a world is a tuple T = \n(Base, O, Q, R), where Base is a set of base types, O is universe of objects with types ranging over \nBase, Q is a set of predicate symbols whose arguments have types in Base, and R is a .nite set of axioms, \nwhere an axiom is a universally quanti.ed .rst-order formula over the predicates in Q.  Intuitively, \nthe predicates in Q form the interface between programs and the world T. We assume for easier exposition \nthat each A . Q has the same arity m. The axioms R codify the laws of the world e.g., the laws of geometry. \nSince the understanding of nontrivial worlds is often partial, we do not expect our axioms to be complete \nin a mathematical sense. Example 1. Let Ttc = ({1DPoint}, O, Qtc, Rtc) be a world in which 1DPoint is \nthe type of points arranged on a line, O is a set of such points, and Qtc consists of a single predicate \nLeft . The predicate Left (u, v) holds for 1DPoints u and v iff u lies to the left of v i.e., if u.x \n< v.x, where u.x and v.x are respectively the coordinates of u and v with respect to a .xed origin. A \nsensible set of axioms Rtc for Ttc is as follows: 1. The transitivity axiom used in the introduction: \n.y1, y2, y3 : y1 = = y2 . y2= y3 . y3= y1 . (Left (y1, y2) . Left (y2, y3) =. Left (y1, y3)). 2. An \naxiom that asserts that Left is complete i.e., any two distinct points on the line are related by Left \n: .y1, y2 : y1 == y2 . (Left (y1, y2) . Left (y2, y1)). To reduce notation, we adopt two simple syntactic \nconventions while writing down axioms. First, we drop the explicit universal quanti.ers over the axiom \nvariables. Second, without loss of gen\u00aderality, we use distinct variable names in the axioms to represent \ndistinct objects in models of the theory. For example, the .rst ax\u00adiom in the above example is written \nsimply as Left (y1, y2) . Left (y2, y3) =. Left (y1, y3), the assumptions (y1 y2), (y2= y3), and (y1 \ny3) following = = from the fact that y1 and y2 are different symbols. It is acceptable, however, to write \nthe axiom R(x, x) to state that a predicate R is re.exive.  2.2 Programs Next we de.ne a core language \nDMP of decision-making programs. Programs in this language are a symbolic transition systems that can \nmanipulate both individual objects and lists of objects. There is a key modelling question in the de.nition \nof DM P: how do we model the uncertainty in a program s queries about the world? Our de.nition does this \nvia nondeterminism: we assume that every call of a program to a world predicate may return an incorrect \nanswer. This model may appear too conservative at .rst sight, given that we do not model uncertainty \nquantitatively. However, it has several advantages. The .rst and foremost is its generality: the model \nis equally applicable to settings where uncertainty is the result of sensing errors as it is to the settings \nwhere .oating-point error is the source of uncertainty. Any reasonable quantitative model of uncertainty, \non the other hand, would have to be domain-speci.c, and perhaps consider low-level details of the hardware \nused for sensing or computation. Second, our model is simpler and therefore more amenable to automated \nreasoning than quantitative models. Indeed, given the highly challenging nature of the consistency analysis \nproblem, this model offers a sweet spot for static analysis. Finally, our empirical experience with the \nmodel is satisfactory. We ran some experiments with our benchmark examples from Sec. 5 for the case when \nuncertainty is only due to numerical error. For the examples that are inconsistent under our model, it \nwas always possible to produce a concrete input that forces the program to violate basic invariants under \n.oating-point semantics. In other words, these examples would be inconsistent under any other reasonable \nde.nition of consistency. Program syntax. Let us .x a world T = (Base, O, Q, R) and a universe of variables. \nEach variable represents either an object in O or a list of such objects. Variables of base types are \ndenoted by x, x1, x2, . . . , and variables of list types (representing collections of objects) are denoted \nby X, X1, X2, . . . . We assume an alphabet2 Q of symbols whose members have a one-to-one correspondence \nwith the predicates in Q. For A . Q, we denote the corresponding symbol in Q by A. Also, we de.ne a symbol \nA for each A . Q and let Q be the set of such symbols. It is assumed that Q and Q do not have any overlap \nwith each other or with Q. Intuitively, for objects p1, . . . , pm, the notation A(p1, . . . , pm) represents \nthe decision made by the program that the fact A(p1, . . . , pm) holds, and A(p1, . . . , pm) represents \nthe decision that the fact \u00acA(p1, . . . , pm) holds. We allow a program to test and manipulate its local \nvariables using the following primitives: We allow boolean expressions that test whether a list is empty: \nX = \u00d8 and X= \u00d8.  We allow the following kinds of assignments to variables: 1. x1 := x2. An assignment \nwhere an object-valued variable x1 is set to the value of another object-valued variable x2. 2. x := \n.rst(X) and x := last(X). Respectively set x to the value of the .rst and last element of the list X. \nThe list X is not updated. 3. x := next(X) and x := pop (X). Respectively remove the .rst and last elements \nof the list X, and set x to the value of this element. 4. X := \u00d8. Sets X to the empty list. 5. X1 := \nX2. Sets the list X1 to the value of the list X2. 6. prepend (x, X ). Adds the object x to the front \nof the list X. 7. append (x, X ). Adds the object x to the end of the list X.   The syntax of DMP \nprograms is now given as follows: De.nition 1 (Programs). A program over a world T is a tuple P = (Loc, \nl0, T ), where Loc is a .nite set of locations, l0 . Loc is the initial location, and T is a set of transitions. \nA transition (l |T | l') from a location l to a location l' is of one of the following forms: 1. (l |A(x1, \n. . . , xm) | l') 2. (l |A(x1, . . . , xm) | l')  3. (l |assume(b)| l') 4. (l |U | l') where A . Q; \nA . Q; xi . Var ; b is a boolean expression; and each U is an assignment of one the forms above. Each \ntransition (l | T | l') takes the program from location l to location l'. Transitions of forms (1) and \n(2) represent queries to the world and decisions made on basis of those queries. A transition of form \n(1) is taken when a call to A . Q returns true, and one of form (2) is taken when it returns false. Transitions \nof form (3) are local tests on program variables while those of form (4) are updates to variables. For \ninstance, the transition (l | x := .rst(X) | l')is executed when control is at l, sets x to the .rst \nelement of X (without updating X), and moves the control to l'. 2 Note the typewriter font used for Q, \nwhich distinguishes this set from Q.  The sets of locations and variables of P are respectively denoted \nby Loc(P ) and Var(P ). Note that a location may have multiple outgoing or incoming transitions. However, \nwe assume, without loss of generality, that whenever P has a query transition (l |a(. . . ) | l ' ), \nthen it has no other outgoing transition at l. We denote by Loca the set of locations in P that have \nan outgoing transition P of the above form. Collectively, locations like this are known as query locations. \nWe assume all predicates in P to be well-typed: if a transition is guarded by A(x1, . . . , xm) and xi \nis of type ti, then the type of A is (t1 \u00d7 \u00b7 \u00b7 \u00b7 \u00d7 tm). Uncertain Semantics. Now we sketch the semantics \nof programs under uncertainty. Let a state of P be a pair s = (l, s), where l is a location and s is \na function that maps variables xi and Xi to appropriately typed values. The set of states of P is denoted \nby S(P ). The semantics of P is de.ned using a labelled transition system (S, --is a set of semantic \ntransitions and Sin is -, Sin), where -a set of initial states. An initial state of P is a state of the \nform (l0, s) for some s, and where each object o appears at most once in at most one list in the domain \nof s (i.e., initially the contents of the lists are repetition-free and pairwise disjoint). The set - \n-is the least relation such that for all transitions t = (l |T | l ' ) in P , If T is a query a(x1, . \n. . , xm) (for a . Q . Q), then we have (l, s) -t, s) for all s. -(l ' If T is an assignment x := e \nor X := E, then for each state (l, s), we have (l, s) -t, s ' ), where s ' is obtained -(l ' by updating \nthe variables of P according to the semantics of assignments sketched earlier.  If T is a test assume(b) \nand (l, s) is a state that satis.es b, then we have (l, s) -t, s).  -(l ' We de.ne an (uncertain) execution \nof P as a .nite sequence . = (l0, s0) -t0\u00b7 \u00b7 (ln, sn) such that (l0, s0) . Sin -(l1, s1)\u00b7 and for all \ni, (li, si) -ti -(li+1, si+1). For each location l, the set of executions ending at a state (l, s) (for \nsome s) is denoted by Exec(l). The set of all executions of P is denoted by Exec(P ). It seems intuitive \nto de.ne a semantics of programs in ab\u00adsence of uncertainty where queries obtain true information about \nthe world e.g., a query transition (l | A(x1, . . . , xm) | l ' ) is en\u00adabled at a state where xi has \nvalue pi if and only if the relation A(p1, . . . , pm) holds in the world. However, such an ideal seman\u00adtics \nis of no use to our analysis where the core concern is the effect of uncertainty, and therefore, we do \nnot develop this semantics.  2.3 Consistency An uncertain execution of a DMP program P , may issue a \nsequence of queries whose answers, taken together, violate R. We say that P is consistent if this cannot \nhappen in any uncertain execution. To formalize this notion of consistency we need a formal de.nition \nfor decisions: a decision in the world T is a literal d = a(p1, . . . , pm), where a . (Q . Q), p1, . \n. . , pm . O, and the type of pi matches the expected type of the i-th input to Q. We denote the set \nof decisions over T by Dec(T) or sim\u00adply Dec. For a decision d, [ d] denotes the literal A(p1, . . . \n, pm) when d equals A(p1, . . . , pm), and \u00acA(p1, . . . , pm) when d equals A(p1, . . . , pm). t0tn Now \nlet . = (l0, s0) --(l1, s1)\u00b7 \u00b7 \u00b7 --(ln+1, sn+1) be an execution of P . We de.ne a decision of . to be \nany decision d = a(p1, . . . , pm) . Dec such that for some i, we have: 1. ti = (li |a(x1, . . . , xm)| \nli+1) 2. for all j . {1, ..., m}, pj = si(xj ). The set of decisions of . is denoted by Dec(.). One can \ncollectively represent the decisions made during an execution . of P using a logical formula, which we \ncall the decision formula of that execution, which is de.ned as: .(.)=[ d] . d.Dec(.) Consistency of \nP is now de.ned as follows: De.nition 2 (Consistency). The program P is consistent (with respect to the \nworld T) if for all executions . . Exec(P ), the or f formula .(.) . R.R R is satis.able. Thus our goal \nis to verify that a given program P is consistent under the above de.nition. Example 2. Let us consider \nthe code in Fig. 2 once again. It is easy to translate this code to a DMP program over the world Ttc \nfrom Example 1 (we assume L1 -L6 are simple assignments). This program manipulates a bounded number of \nobjects and has a bounded number of executions; by enumerating these executions, we .nd that it is consistent. \nNow let us consider a more involved program, also over Ttc, that issues queries over an unbounded number \nof objects. As with the previous example, we write the program in a more readable structured syntax which \ncan be easily translated into DMP: 1 x1 := next(X); x2 := next(X) 2 while X = \u00d8 3 do if Left(x1, x2) \nthen skip else skip 4 x1 := x2; x2 := next(X) In our model, the test in Line 3 can always evaluate incorrectly. \nHowever, we can argue that this program is consistent nonetheless. Let the objects in the input list \nX have identi.ers 1 to n. Consider the execution . that takes the true-branch of the code in all iterations. \nThe decision formula for . is .(.) = Left(1, 2) . Left(2, 3) . Left(3, 4) . . . Left(n - 1, n). Now note \nthat (.(.) . R), where R is the conjunction of the axioms in Example 1, is satis.able. It is not hard \nto see that for every execution . ' of Ptc, (.(. ' ) . R) is satis.able. Therefore, the program is consistent. \nOn the other hand, if the program made an extra decision Left(n, 1) somewhere in the execution, then \nthe conjunct Left(n, 1) would be added to .(.), and the above property would no longer hold. 3. Consistency \nin geometric programs In this section, we show how the notion of consistency plays out in the context \nof computational geometry. We do so using two examples. Both are algorithms for computing a convex hull \nfor a set of points in two dimensions (2D); one of the algorithms is not consistent, while the other \nis. As before, we describe the algorithms using a more readable, structured syntax rather than that of \nDMP. 3.1 The world Any convex hull algorithm queries a geometric space about posi\u00adtions of points in \nit this space Tch is our world. Formally, we let Tch = ({2DPoint}, O, Qch , Rch ), where 2DPoint is \nthe type of points on the 2D plane, O is the set of all 2D points, and Qch consists of a single orientation \npredicate Lturn(u, v, w). The se\u00admantics of this predicate is that Lturn(u, v, w) is true when w is to \nthe left of the in.nite directed line -. uv. For example, in Fig. 6(a), we have Lturn(p1, p2, p3). Under \nthe ideal semantics of reals, this  1. Cyclic symmetry: Lturn(x, y, z) =. Lturn(y, z, x). 2. Antisymmetry: \nLturn(x, y, z) =. \u00acLturn(x, z, y). 3. Nondegeneracy: Lturn(x, y, z) . Lturn(x, z, y). 4. Interiority: \nLturn(x, y, t) . Lturn(y, z, t) . Lturn(z, x, t) =. Lturn(x, y, z). 5. Transitivity: Lturn(x, y, z) \n. Lturn(x, y, t) . Lturn(y, z, t) . Lturn(y, z, w) . Lturn(t, y, w) =. Lturn(x, y, w).  Figure 3. Knuth \ns axioms for convex hull algorithms predicate can be de.ned as (v.x - u.x)(w.y - u.y) - (v.y - u.y)(w.x \n- u.x) > 0 where u.x and u.y are respectively the x-and y-coordinates of u. We de.ne Rch using an axiomatization \nof convex hull predi\u00adcates (Fig. 3) by Knuth [17]. Consider Fig. 6(a) again, and note that Lturn(p1, \np2, p3). Axiom 1 says that this implies the facts Lturn(p3, p1, p2) and Lturn(p2, p3, p1); Axiom 2 says \nthat we cannot have Lturn(p1, p3, p2) in this case. Axiom 3 is an assump\u00adtion that no three input points \nare collinear (collinear points form a degenerate case for convex hull algorithms). -. Axiom 4 says that \n(Fig. 4 (a)) if p2 is to the left of -p1p2, --. -. p2p3 and -p3p1, then p4 is inside the triangle Lp1p2p3, \nand more over the triangle is oriented counter clockwise, or p3 is to the -. left of -p1p2. Axiom 5 de.nes \na transitivity property of Lturn: to understand its geometric intuition, consider Fig. 4(b) with x = \np1, y = p2, z = p3, t = p4, and w = p5. In this case, we have Lturn(p1, p2, p3), Lturn(p1, p2, p4), Lturn(p2, \np3, p4), Lturn(p2, p3, p5), Lturn(p4, p2, p5). The axiom demands that we also have Lturn(p1, p2, p5), \nwhich is indeed true here. Figure 4. Interiority and transitivity axioms Axioms 1 5 are easily seen \nto be consistent with Euclidean geometry. In [17], Knuth argues that if the results of all Lturn predicate \nchecks for a set of points satisfy these axioms, then a convex hull always exists. While the above axioms \nare speci.c to convex hulls, similar axiomatizations are known for other classes of geometric computations. \n 3.2 Inconsistent convex hull Consider the algorithm SI M P L ECO N VE XHU LL [7] in Fig. 5, which is \na naive (and slow) algorithm for computing the convex hull of a set of points S. Note that it is standard \nfor convex hulls to have a counterclockwise orientation. Following the convention de\u00adveloped earlier, \nwe use Lturn(u, v, w) to denote the decision made by the algorithm that \u00acLturn(u, v, w). The algorithm \niterates over all pairs of points (u, v) (as potential convex hull edges); if there exists a point w \nsuch that the decision Lturn(u, v, w) is made, then (u, v) is removed from the set of edges forming the \nconvex hull (since if (u, v) is an edge of the convex hull (in the counter\u00adclockwise direction), then \nevery other point must lie to the left of (u, v)). It is easy to see that if the algorithm is implemented \nusing Input: A set S of points in the 2D plane. Output: A list E containing the edges of the convex hull \nSI M P L E CONV EX HU L L(S) 1 E := \u00d8 2 for all o rdered pairs (u, v) . S \u00d7 S with u = v 3 do valid \n:= true 4 for all w . S with u = w and v = w 5 do if \u00acLturn(u, v, w) 6 then valid := false 7 if valid \n8 then add the directed edge (u, v) to E Figure 5. Inconsistent convex hull ideal reals, without any \nuncertainty, then SI MPL E CO N V E X HUL L in fact computes a convex hull. On the other hand, under \nuncertainty (for example, due to .oating-point error), the decision Lturn(u, v, w) can evaluate non\u00addeterministically. \nConsider the input set in Fig. 6 where the correct hull is illustrated in (a). Lturn(p1, p2, p3) is true, \nbut the points p1, p2, p3 are nearly collinear. First, note that the algorithm may evaluate Lturn for \nall permutations of the three points p1, p2, and p3. If, due to numerical uncertainty, the program decides \nthat Lturn(p1, p2, p3), Lturn(p2, p3, p1), and Lturn(p1, p3, p2), then none of the three edges (p1, p2), \n(p2, p3), and (p1, p3) will belong to the convex hull, and the resulting hull will be as illustrated \nin (b), which is not even a closed curve. Similarly, we could have a scenario where all three edges end \nup in the convex hull, where all the three queries return true, and the result will be as in (c); again, \ncompletely wrong, since it has two cycles. Figure 6. Inconsistency in convex hull The main problem is \nthat, for both cases (b) and (c), where de\u00adcisions Lturn(p1, p2, p3) and Lturn(p1, p3, p2) are both taken, \nthere is an inconsistency with the antisymmetry axiom of Fig. 3. The consistent executions of this program \nresult in either (a) or (d). The convex hull in (d) is obtained from deciding that Lturn(p1, p2, p3), \nLturn(p2, p3, p1), and Lturn(p1, p3, p2); these decisions are not all correct, but they are consistent. \nConse\u00adquently, while Figure (d) is slightly different from the ideal answer, it is structurally a convex \nhull: an output that would be produced by the ideal real-number algorithm on some input (this is an input \nin -. which p2 is perturbed to move to the left of line -p1p3 ). In contrast, (b) and (c) are outputs \nthat the ideal algorithm could never produce.  To see why this difference is substantial, consider a \nprocedure that iterates over the hull computed by the convex hull routine, starting with p2 and terminating \nwhen it comes back to p2 again. In case (d), it will terminate as usual. In case (b), it will not be \nable to proceed past p2. In (c), it could get stuck in an in.nite loop. The inconsistency of the above \nalgorithm is by no means a rare anomaly. Many everyday implementations of convex hulls (and other geometric \ncomputations) are inconsistent. The crashes, in.\u00adnite loops, and other errors that inconsistency can \nlead to are well\u00addocumented. We refer the reader to [21] for an in depth discussion of the consequences \nof inconsistent geometric computations.  3.3 Consistent convex hull: Graham Scan [12] Graham scan [12] \n(Fig. 8) is an example of a consistent convex hull algorithm. The point p0, which we know belongs to \nH, is our sen\u00adtinel . In the main loop, we check if the last two points u and v of H together with a \nnew point w from S make a left turn (this test is encoded using the Lturn predicate). If so, then we \nspeculatively assume that these points belong to the hull and add w to H. If not, then v cannot belong \nto the convex hull of S (since both edges adjacent to v have a point to the right of them, and therefore, \nthey cannot be convex hull edges), and we delete it from H. For example, upon considering (p1, p2, p3) \nin the .gure, p2 is deleted from H. In gen\u00aderal, we keep deleting until the last two points in H together \nwith w make a left turn. Note that there is no bound on the number of points that may be deleted during \nthis step. The Graham Scan algorithm, unlike the naive algorithm, is con\u00adsistent (we discuss why in Sec. \n5). It is very dif.cult to reason about consistency of this algorithm manually. One needs to reason about \nall program paths containing unboundedly many facts (dependent on the size of input) and argue that none \ncontains an inconsistency with respect to the axioms. An expert user may be able to argue why none of \nthe .rst 3 axioms (in Fig. 3) can ever be falsi.ed by this algorithm. The algorithm progresses in a way \nthat, for every three points p, q, and r, it evaluates the Lturn(p, q, r) predicate exactly once (the \nlast point r is always a fresh new point). There\u00adfore, it is not possible to .nd two predicate evaluations \nthat are not consistent with any of the .rst three axioms (which all need two different evaluations of \nthe predicate on two different permutations of the same 3 points). But, extending this reasoning to axioms \n4 and 5 manually is dif.cult. In the next section, we present an analysis that is able to easily verify \nthe consistency of the above algorithm. We note that the assumption that the input points are sorted \non basis of their polar angle from p0 is needed for the algorithm s functional correctness. However, \nit is irrelevant to the program s consistency: even if the input points were ordered arbitrarily, the \ndecisions made in an execution of the algorithm would not violate Knuth s axioms, and structurally, the \noutput would still be a simple closed cycle. Our analysis chooses to ignore the assumption that the input \nlist is sorted in this way (this information is lost in ab\u00adstraction), and still discovers an automated \nproof that the algorithm is consistent. 4. Verifying consistency In this section, we describe our method \nfor algorithmic veri.cation of consistency. Let us .x a world T = (Base, O, Q, R) and a program P . The \nbroad idea of our algorithm is to prove P Input: A point p0 (right-most bottom-most point in the set) \nand (non\u00adempty) list of S of points. The points in S are assumed to be sorted on basis of increasing \npolar angle from p0. Output: List H containing the points forming the convex hull, also sorted on basis \nof their polar angle from p0 GR A H A M SC A N(p0, S) 1 if |S| < 3 then return [p0; S] 2 H := [next(S); \nnext(S)] 3 for w := next(S) 4 do 5 v := last(H); u := secondLast (H) 6 while \u00ac Lturn(u, v, w) 7 do pop(H) \n8 if |H| = 2 9 then v := last(H) ; u := secondLast (H) 10 else break 11 Append w to H 12 w := p0; v \n:= last(H); u := secondLast (H) 13 while \u00ac Lturn(u, v, w) 14 do pop(H) 15 if |H| = 2 16 then v := last(H) \n; u := secondLast (H) 17 else break 18 Append p0 to H 19 return H Figure 8. Consistent Convex Hull Algorithm: \nGraham Scan. The operation secondLast returns the second last element of the list, without modifying \nthe list. consistent by an inductive argument: each time a new decision is made, we assume that the set \nof decisions that have already been made are consistent and prove that the new decision does not violate \nconsistency (in combination with past decisions). We automate this reasoning in two phases as follows. \nIn the .rst phase, we approximate the sets of decisions that can be made by executions of P by constructing \nan integer abstraction . of P and then computing numerical invariants for .. Example 2 illustrates the \nidea behind the integer abstraction, which models objects as integer identi.ers, and sets of decisions \nwith sets of integer tuples. We analyze . with an abstract interpreter to compute for each query location \nl of P : 1. A current-decision invariant dl that symbolically represents the set of decisions that can \nbe made at l. 2. A history invariant Hl that symbolically represents the set of all decisions made along \nexecutions that end at location l.  Our representation of a set of decisions by a numerical invariant \nmakes use of a set of integer auxiliary variables which represent the arguments of queries (recalling \nthat our encoding represents objects as integer identi.ers). A set of decisions (i.e., a set of tuples \nof objects) is represented by an arithmetic formula over the program variables as well as the auxiliary \nvariables. The set of models of such a formula can be interpreted as a set of decisions (or more accurately, \nas a function mapping program states to a set of decisions). For example, let us revisit the program \nof Example 2 (repro\u00adduced here for convenience). 1 x1 := next(X); x2 := next(X) 2 while X = \u00d8 3 do if \nLeft(x1, x2) then skip else skip 4 x1 := x2; x2 := next(X) Let us assume that the objects in the list \nhave strictly increasing IDs (e.g. the .rst point on the list has ID 1, the second ID 2, and so on), \nand let us use auxiliary variables #1 and #2 to respectively  Left Left represent the IDs of the .rst \nand second arguments of the call to Left. At line 3, we have the invariant x1 < x2, and we have outgoing \nquery transitions A(x1, x2) and A(x1, x2). The current\u00addecision invariant at this location is: dl : #Left \n1 = x1 < x2 = #Left 2 . On the other hand, in a history invariant, #1 and #2 refer Left Left to the IDs \nof the arguments of an arbitrarily selected past call to Left, while x1 and x2 refer to the current program \nvariables. Since the program processes list elements in order of increasing IDs, the following history \ninvariant holds at Line 3: 1 2 Hl : #Left < #Left = x1 < x2 In the second phase of the algorithm, we \nverify that for each query location l in the program P , there is a model of the world that is consistent \nwith the decisions dl and Hl (i.e., dl, Hl, and the world axioms R together cannot derive false). The \nchallenge here is that there may be no obvious inconsistency between dl and Hl, but false may be derived \nusing the axioms in R (and there is no a priori bound on the size of such a proof). To overcome this \nchallenge, we generate a logic program from the world axioms R that, given a current-decision invariant \ndl and a history invariant Hl, generates every decision that can follow from the decisions in dl and \nHl. The problem now reduces to verify\u00ading that this system cannot possibly derive a contradiction. This \ntask can be solved automatically using existing .xpoint constraint solvers, such as \u00b5Z [14]. Next, we \ndescribe the two phases of the algorithm in detail. 4.1 Generating history and current-decision invariants \nTo generate the history and current-decision invariants used by our consistency veri.cation procedure, \nwe .rst abstract P by a program . over the integers. In ., each object accessed by P is modelled as a \ninteger ID.3 In addition to simulating the execution of P , . records the decisions it makes using a \nset of auxiliary variables (denoted by #). Constructing . We abstract lists . by pairs consisting of \nthe IDs of the .rst and last element of .. The challenge in this list abstraction is to maintain information \nabout a list . as objects are added to it or removed from it. Our approach to doing so is to maintain \nthe invariant that the objects in . appear in an order sorted by their IDs (note that there is no relation \nbetween these IDs and any values associated with the objects themselves; we just assign the IDs to the \nelements of the list in order in which they appear on the list). For instance, let X0 and X1 respectively \ndenote the IDs of the .rst and last items in a list X. Assuming that our sortedness invariant holds, \nthe integer abstraction of next(X) returns the value of X0 and sets X0 to a nondeterministically chosen \nvalue between the current values of X0 and X1. Note that since the abstraction assigns the integer IDs \n(they are not part of original object information), all the input lists to the program are initially \nassumed to satisfy this invariant (based on the precondition about the disjointness of the lists and \nthe elements on each list that we already mentioned in Section 2.2). Of course, the sortedness invariant \ncan be violated when the program tries to insert an item x into a list X. We detect such vio\u00adlations \nby comparing the ID of x with the value X1; if sortedness is violated, we conservatively .ag the program \nas inconsistent. 3 Our analysis can be generalized to one where object IDs are not integers but tuples \nof integers, or even more generally, elements of a partially ordered set. For simplicity, we stick to \ninteger IDs in this paper. We now present the construction of . formally. To avoid in\u00adtroducing more \nnotation, we describe the program . in a DM P-like syntax. An integer program is a tuple (Loc, Var , \nl0, T ), where Loc is a set of locations, Var is a set of variables ranging over the in\u00adtegers and booleans, \nl0 . Loc is an initial location, and T is a set of transitions. Transitions between locations l and l \n' have the following forms: Test transitions (l | assume(b) | l ' ), where b is a linear arithmetic \nformula,  (l |havoc (x)| l ' ), which changes the value of the variable, x to an arbitrary integer value, \n (l |x := e | l ' ), an assignment to variable x, and  (l |assert(b) | l ' ), which asserts that a \nproperty b (expressed as a linear arithmetic formula) holds.  We do not give a detailed semantics for \nthese transitions as they are standard. For simplicity, we sometimes write sequential com\u00adpositions of \ntransitions as a single transition e.g., the syntax (l |x := e; havoc (x) | l ' ) is abbreviation for \na pair of transitions (l | x := e | l '' ) and (l '' | havoc (x) | l ' ), where l '' is a location that \nis not used anywhere else in the program. Now, let P = (LocP , Var P , l0,P , TP ). We construct the \npro\u00adgram . = (Loc., Var ., l0,., T.) as follows: The initial location l0,. of . is a fresh location, \nnot in Loc P . Loc . contains LocP and l0,., and also a number of auxiliary locations introduced in the \ntranslation of transitions (Fig. 9). . inherits a notion of query locations from P : for all a . Q . \nQ, we de.ne Loca = Loca . P . Var . is the least set such that: 1. For each object-valued variable \nx in P , Var . contains an integer-valued variable that tracks the ID of x. Abusing notation, we call \nthis variable x as well. 2. For every list-valued variable X in P , Var . contains two integer-valued \nvariables X0 and X1 that track the IDs of the .rst and last elements of X. 3. For each A . Q and each \n1 = i = m, Var . has an integer-valued variable #i A ranging over the integers. These variables are used \nto record A-decisions. 4. Var . contains a special boolean-valued variable .agA for each A . Q. This \nvariable is set to true when the #i A variables are initialized i.e., the arguments of some query is \nassigned to them. Initially, each .agA variable is false.   The set of transitions T. of . is de.ned \nby the rules in Fig. 9. Here, the rule INI T captures the fact that the #i A s are unini\u00adtialized at \nthe beginning of program executions. The two rules QUE RY-1 and QU E RY-2 abstract query transitions. \nOne of them sets the #A variables while the other does nothing together, they model a nondeterministic \nchoice to save the arguments of a decision in the #A variables. The remaining rules are inte\u00adger abstractions \nof updates to and tests of object and list-valued variables.  Current-decision and History Invariants \nHaving constructed an integer program abstraction . of P , we may use standard techniques to generate \nfor each location l . Loc. a (numerical) history invariant Hl. Our implementation employs an abstract \ninterpreter over a domain of partitioned octagons, which we describe further in Sec. 5.1. Each Hl is \na linear arithmetic formula over the variables Var ., which includes the variables which correspond to \nobject-valued variables of P as well as the auxiliary # and .agvariables.  Q = {A1 , ..., A|Q|} (l | \nx1 := x2 | l ') . TP (Init) (Asgn) (l0,. |.agA1 := false; . . . ; .agA|Q| := false | l0) . T. (l | x1 \n:= x2 | l ') . T. = \u00d8) | l ' (l | assume(X = \u00d8) | l ') . TP (l | assume(X ) . TP (Test-empty) (Test-not-empty) \n(l | assume(X0 > X 1) | l ') . T. (l | assume(X0 = X1) | l ') . T. (l|a(x1, . . . , xm)| l ') . TP a \n. {A} . {A} (l |a(x1, . . . , xm)| l ') . TP a . {A} . {A} (Query-1) (Query-2) (l | #1 := x1; . . . ; \n#m := xm; .agA := true | l ') . T. (l | assume(true) | l ') . T. A A (l | x := .rst(X) | l ') . TP (l \n| x := next(X) | l ') . TP (First) (Next) (l | assert(X0 = X1); x := X0 | l ') . T. (l |x := X0; havoc(X0); \nassume(x < X 0 = max(X1, X 0 + 1) | l ') . T. (l | x := last(X) | l ') . TP (l | x := pop(X) | l ') . \nTP (Last) (TL) (l | assert(X0 = X1); x := X1 | l ') . T. (l |x := X1; havoc(X1); assume(min(X0, X 1 \n- 1) = X1 < x)| l ') . T. (l | X1 := X2 | l ') . TP (l|X := \u00d8 | l ') . TP (LA) (Empty) (l | X0 := X0; \nX1 := X1 | l ') . T. (l |havoc(X0); havoc(X1); assume(X0 > X 1)| l ') . T. 1 21 2 (l | append (x, X \n) | l ') . TP (l | prepend (x, X ) | l ') . TP (App) (AF) (l |assume(X0 > X 1); X0 := x; X1 := x| l ') \n. T. (l |assume(X0 > X 1); X0 := x; X1 := x| l ') (l |assume(X0 = X1); assert(x > X 1); X1 := x| l ') \n. T.. (l |assume(X0 = X1); assert(x < X 0); X0 := x| l ') Figure 9. Construction of the transitions T. \nof . from P = (LocP , Var P , l0,P , TP ) Our construction of . ensures that any such formula Hl can \nbe interpreted as a mapping from traces to sets of decisions made along those traces. The intuition behind \nthis interpretation is as follows. Let . be a program trace, which ends in a state (l, s). For any A, \nconsider the set of models of Hl which send each variable to its value in s and in which the #A variables \nhave been initialized (.agA is true). Each such model M corresponds to an A-decision, namely, the decision \nA(M(#1 A ), ..., M (#m A )) (where M(#i A ) denotes M s interpretation of the variable #i A ). The set \nof decisions obtained from models of Hl in this way is a superset of the set of decisions made along \n.. The precise statement of this interpretation of Hl is the following lemma. Lemma 1. Suppose that . \nis an execution of P , ending in a state (l, s). Let id be any mapping from the objects accessed in . \nto integer IDs such that IDs increase along every list in the initial state of .. Let A . Q, and let \nV be the set of all variables in Var . except the #A variables. De.ne Hl,A = .V.Hl . .agA = true . x \n= id(s(x)). x.Var P Then for any A(p1, ..., pm) . Dec(.), the model M that sends each #i A to pi is \na model of Hl,A (and similarly for any A(p1, ..., pm) . Dec(.)). t0 Proof. Let . = (l0, s0) --(l1, s1)\u00b7 \n\u00b7 \u00b7 (ln, sn), with ln = l. Let a(p1, ..., pm) . Dec(.). Then there is some i such that ti = (li |a(x1, \n. . . , xm)| li+1)  for all j . {1, ..., m}, pj = si(xj ).  With the exception of query, append, and \nprepend transitions, for any transition of P , there is a unique sequence of correspond\u00ading transitions \nin ., given in Fig. 9. For append and prepend tran\u00adsitions, there are two corresponding transitions, \nbut their guards are disjoint so there is a unique choice for the translation of these tran\u00adsitions when \nthe pre-state is .xed. For query transitions there are two corresponding transition sequences given by \nthe (Query-1) and (Query-2) rules. Consider the execution .. of . which executes the sequence of transitions \ncorresponding to ., using the (Query-1) rule for the query transition ti and (Query-2) for all other \nquery transi\u00adtions along ., (and which chooses the correct non-deterministic updates to the list variables \nto make the executions . and .. agree). Let (l, s.) be the .nal state of ... Then s. sends each object\u00advalued \nvariable x to id(s(x)), sends each #i A to id(pi), and sends .agA to true. Since Hl is an invariant at \nlocation l, we must have s. |= Hl. It follows that M, the restriction of s. to the #i A variables, is \na model of Hl,A . Now we describe how to compute current-decision invariants. Consider a query location \nl with an outgoing query transition (l |a(x1, . . . , xm) | l ' ), where a . {A, A} for some A . Q. By \nthe syntactic assumptions laid out in Sec. 2, l has no other outgoing transition. The current-decision \ninvariant at l can be computed from Hl as: m dl = (.#.Hl) .(xi = #A i )i=1 where .# denotes the existential \nquanti.cation of each #-variable. Intuitively, dl constrains the relationships between the program variables \nand the objects involved in the new decision made at l.  4.2 Proving Consistency of Decisions Once the \nhistory (Hl) and current-decision (dl) invariants have been generated for each query location l, consistency \nveri.cation can be reduced to the problem of proving false cannot be derived from the combination of \nHl, dl, and the world axioms R. Our reduction makes use of our inductive assumption that there is no \nderivation of false using only decisions from Hl. Now we show how to automate this proof obligation. \nDecision proof systems For expository purposes, we will begin by de.ning decision proof systems, a Datalog-like \nnormal form for the world axioms R. After, we proceed to the construction of a logic program that can \nbe used to verify consistency of the program P . Normalized axioms can be of two forms: Generators: These \nrules derive new decisions that are logical consequences of decisions taken by the program. Formally, \na generator is a rule of the form  a(y1, . . . , ym) . a1(y11, . . . , y1m).\u00b7 \u00b7 \u00b7.ak(yk1, . . . , ykm) \nwhere a, ai are in (Q . Q), and the yij s range over objects. Violators: These rules identify direct \ncontradictions between decisions that have either been made by the program or derived by the generators. \nSuch a rule has the form . . Ai(y1, . . . , ym) . Ai(y1, . . . , ym). where . is a special symbol (intuitively \nindicating false), A . Q and the yi s range over objects. We interpret the relations in the above rules \nas sets of decisions, and the rule as a way to derive new decisions or derive contradictions. Now we \ndescribe how to construct a decision proof system MR r from a set of axioms R. First, we construct the \nformula R.R R and convert it into the conjunctive normal form (per our current notation, we assume that \nthe initial quanti.ers are omitted from formulas in R). Let the resultant formula have clauses C1, . \n. . , Cn. Now consider any clause Cj = t1 . \u00b7 \u00b7 \u00b7 . tk of the formula constructed in the previous step. \nHere, each ti is either of the form Ai(yi1, . . . , yim1 ) or of the form \u00acAi(yi1, . . . , yim). We de.ne \ntwo literals ti and ti for each ti. If ti = Ai(yi1, . . . , yim), then we have ti = Ai(yi1, . . . , yim) \nti = Ai(yi1, . . . , yim). If ti = \u00acAi(yi1, . . . , yim), then we have ti = Ai(yi1, . . . , yim) ti = \nAi(yi1, . . . , yim). MR is de.ned to be the least set of rules such that: 1. For each clause Cj = t1 \n. \u00b7 \u00b7 \u00b7 . tk and each r . {1, ..., k}, MR has the generator tr . t1 . \u00b7 \u00b7 \u00b7 . tr-1 . tr+1 . \u00b7 \u00b7 \u00b7 . tk. \n2. For each predicate A . Q, MR has the violator . . A(y1, ..., ym) . A(y1, ..., ym). Example 3. Consider \nonce again the world Ttc of Example 1, which supports the predicate Left over 1-D points. The following \ndecision proof system MRtc is obtained from the axioms of Ttc: Left(y1, y2) . Left(y2, y1) Left(y1, y2) \n. Left(y2, y1) Left(y1, y3) . Left(y1, y2) . Left(y2, y3) Left(y2, y3) . Left(y1, y2) . Left(y1, y3) \nLeft(y1, y2) . Left(y2, y3) . Left(y1, y3) . . Left(y1, y2) . Left(y1, y2) Proving consistency We now \nshow how to construct (from the current-decision invari\u00adants, and history invariants, and the decision \nproof system) a logic program which derives the symbol . if P is inconsistent. If this logic program \ncannot derive ., this proves that P is consistent. First, we provide some intuition. Let l be a query \nlocation. We compute for each predicate A . Q a relation Histl,A which relates the .nal states of program \nexecutions that end at l to the decisions of the form A(...) or A(...) which are logical consequences \nof the decisions made along those executions.4 We also compute for each a . Q . Q a relation Newl,a, \nwhich is similar to Histl,A except that 4 Note that since the outcome of decisions are uncertain, we \nneed not compute a corresponding Histl,A relations, because it would be they would be identical to the \nHistl,A relations. it includes the decision made at l, but not necessarily the decisions which are consequences \nof decisions in Histl,A . The sets Histl,A and Newl,a can be described using a set of Datalog-style rules, \ngiven in the following. We use xx = (x1, . . . , xn) to denote the list of the variables corresponding \nto object-valued variables of P . These variables will be threaded through each of the inference rules, \nso they may be thought of as symbolic constants that help to mediate relationships between the current \ndecision and previous decisions. Alternately, they may be thought of as a way of adding a degree of path-sensitivity \nto our analysis: we may think of each valuation of the variables xx as a universe , and threading xx \nthrough each inference rule as a way of keeping universes separate. We begin with rules that initialize \nHistl,A and Newl,a using the history and current-decision invariants: Histl,A (y1, . . . , ym, x. Hl[#A1 \nA x) . y1; . . . ; #m . ym] . .agA Newl,a(y1, . . . , ym, xx) . dl[#1 A . y1; . . . ; #m A . ym] a if \nl . Loc. and a . {A, A} Newl,a(y1, . . . , ym, xx) . \u00d8 otherwise Now we give rules to derive the consequences \nof decisions in dl taken together with decisions in Hl. For each generator Rg . MR of the form a(y1, \n. . . , ym) . a1(y11, . . . , y1m) . \u00b7 \u00b7 \u00b7 . ak(yk1, . . . , ykm), where a . {A, A} and for all i, ai \n. {Ai , Ai }, we add: Histl,A (y1, . . . , ym, xx) . Histl,A1 (y11, . . . , y1m, xx) . . . . .Histl,Ak \n(yk1, . . . , ykm, xx) Newl,a(y1, . . . , ym, xx) . Ol,a1 (y11, . . . , y1m, xx) . . . . .Ol,ak (yk1, \n. . . , ykm, xx) where Ol,ai . {Newl,ai , Histl,Ai } and such that at least one of the Ol,ai s is Newl,ai \n. The requirement that at least one of the Ol,ai s is Newl,ai ensures that Newl,a does not include decisions \nthat are solely derived from decisions in Hl. This is used to encode our inductive assumption that there \nare no inconsistencies in Hl. Finally, for each predicate A . Q, we generate three violator rules that \ndetect direct contradictions: . . Newl,A (y1, ..., ym, xx) . Histl,A (y1, ..., ym, xx) . . Newl,A (y1, \n..., ym, xx) . Histl,A (y1, ..., ym, xx) . . Newl,A (y1, ..., ym, xx) . Newl,A (y1, ..., ym, xx) Let \nM.,R be the system of all rules constructed as above. We have the following lemma: Lemma 2. Suppose that \nprogram P is inconsistent. Then . be\u00adlongs to the least .xpoint of M.,R. t0 Proof. Let . = (l0, s0) --(l1, \ns1)\u00b7 \u00b7 \u00b7 (ln, sn) be an execution of the program P such that MR can derive . from Dec(.). Without loss \nof generality, we may assume no proper pre.x of . satis.es this property. It follows that tn-1, the last \ntransition of ., must be a decision transition (ln-1 | a(z1, ..., zm) | ln) for some a, z1, . . . , zm. \nFor notational convenience, we use l to denote ln-1, and use . ' to denote the trace . with its last \naction omitted. Let id be any mapping form the object accessed in . to integer IDs such that IDs increase \nalong every list in the initial state s0. Let x be the vector of the object-valued variables of P , and \nde.ne xp = (id(sn-1(x1)), ..., id(sn-1(xn))) Let T be a derivation tree for . using the inference rules \nin MR, with the elements of Dec(.) taken as axioms.  Initialization: NewLeft (y1, y2, x1, x2) . x1 = \ny1 < y2 = x2 NewLeft (y1, y2, x1, x2) . x1 = y1 < y2 = x2 HistLeft (y1, y2, x1, x2) . y1 < y2 = x1 < \nx2 Totality: HistLeft (y1, y2, x1, x2) . HistLeft (y2, y1, x1, x2) HistLeft (y1, y2, x1, x2) . HistLeft \n(y2, y1, x1, x2) NewLeft (y1, y2, x1, x2) . NewLeft (y2, y1, x1, x2) NewLeft (y1, y2, x1, x2) . NewLeft \n(y2, y1, x1, x2) Violators: . . HistLeft (y1, y2, x1, x2) . NewLeft (y1, y2, x1, x2) . . NewLeft (y1, \ny2, x1, x2) . HistLeft (y1, y2, x1, x2) . . NewLeft (y1, y2, x1, x2) . NewLeft (y1, y2, x1, x2) Transitivity: \nHistLeft (y1, y3, x1, x2) . HistLeft (y1, y2, x1, x2) . HistLeft (y2, y3, x1, x2) HistLeft (y2, y3, x1, \nx2) . HistLeft (y1, y2, x1, x2) . HistLeft (y1, y3, x1, x2) HistLeft (y1, y2, x1, x2) . HistLeft (y1, \ny2, x1, x2) . HistLeft (y1, y3, x1, x2) NewLeft (y1, y3, x1, x2) . NewLeft (y1, y2, x1, x2) . NewLeft \n(y2, y3, x1, x2) NewLeft (y1, y3, x1, x2) . HistLeft (y1, y2, x1, x2) . NewLeft (y2, y3, x1, x2) NewLeft \n(y1, y3, x1, x2) . NewLeft (y1, y2, x1, x2) . HistLeft (y2, y3, x1, x2) NewLeft (y2, y3, x1, x2) . NewLeft \n(y1, y2, x1, x2) . NewLeft (y1, y3, x1, x2) (y2, y3, x1, x2) . HistLeft (y1, y2, x1, x2) . NewLeft (y1, \ny3, x1, x2) NewLeft NewLeft (y2, y3, x1, x2) . NewLeft (y1, y2, x1, x2) . HistLeft (y1, y3, x1, x2) NewLeft \n(y1, y2, x1, x2) . NewLeft (y1, y2, x1, x2) . NewLeft (y1, y3, x1, x2) NewLeft (y1, y2, x1, x2) . HistLeft \n(y1, y2, x1, x2) . NewLeft (y1, y3, x1, x2) NewLeft (y1, y2, x1, x2) . NewLeft (y1, y2, x1, x2) . HistLeft \n(y1, y3, x1, x2) Figure 10. M.,Rtc for the program in Example 2. For any subtree T ' of T , we say that \nT ' is new if one of its axioms is a(sn-1(z1), ..., sn-1(zm)); otherwise, we say T ' is old. We .rst \nprove that for any old subtree T ' of T with root a ' (q1, ..., qm), we have (id(sn-1(z1)), ..., id(sn-1(zm)), \nxp) . Histl,A (where a ' . {A, A}). Base case: T ' is an axiom, so we must have a ' (p1, ..., pm) . Dec(. \n' ) It follows from Lemma 1 and the fact that Histl,A is closed under the following inference rule: Histl,A \n(y1, . . . , ym, x ) . Hl[#A 1 . y1; . . . ; #A . ym] m . .agA that (p1, . . . , pm, xp) . Histl,A . \nInductive step: T ' ends with the application of a generator rule Rg . MR, say a(q1, . . . , qm) . a1(q11, \n. . . , q1m) . \u00b7\u00b7\u00b7 . ak(qk1, . . . , qkm) (where a . {A, A} and ai . {Ai , Ai }). Let T1, . . . , Tk \nbe the subtrees of T corresponding to the premises of Rg. Since each of T1, . . . , Tk is a proper subtree \nof T , we have (qi1, ..., qim, xp) . Histl,Ai for each i by our inductive hypoth\u00adesis. Since Histl,A \nis closed under the following inference rule: Histl,A (y1, . . . , ym, x ) . Histl,A1 (y11, . . . , y1m, \nx ) . \u00b7 \u00b7 \u00b7 .Histl,Ak (yk1, . . . , ykm, x ) we have that (q1, . . . , qm, xp) . Histl,A . We can use \na similar argument to show that for any new sub\u00adtree T ' of T with root a ' (q1, ..., qm), we have (q1, \n..., qm, xp) . Newl,aJ . The .nal inference rule used in T must be the application of a violator rule. \nAt least one of the immediate subtrees of T must be new, since if they are all old, the axioms of T are \ncontained in Dec(. ' ) which violates our minimality assumption. It follows that we may use one of the \nviolator rules to derive ., and therefore . belongs to the least .xpoint of M.,R. Example 4. The logic \nprogram M.,Rtc constructed for the pro\u00adgram program Ptc in Example 2 (with respect to the speci.cation \nof the world Ttc) is given in Figure 10. Since the only query loca\u00adtion is Line 3 of the program, we \nomit location subscripts in this .gure. \u00b5Z is able to determine that this program cannot derive ., so \nthe program Ptc is certi.ed consistent. Summarizing, our algorithm CHECK-CONSISTENCY for veri\u00adfying the \nconsistency of P is as follows. First we construct an integer abstraction . and generate numerical invariants \nusing an abstract interpreter. We check that each assertion in the program is safe according to the invariants \nproduced by the abstract interpreter; if a assertion violation is found (indicating a violation of our \nsorted list abstraction), we report P to be possibly inconsistent. Second, we construct the logic program \nM.,R and check if M.,R can de\u00adrive .. If it can, we report P to be possibly inconsistent, otherwise we \nreport P to be consistent. By Lemma 2, we immediately have: Theorem 1. If the algorithm CHECK-CONSISTENCY \ncerti.es a program P to be consistent, then P is consistent.  4.3 Limitations Our algorithm is sound \nbut incomplete. There are several possible sources of loss of precision here: (1) the abstraction of \nlists by pairs of integers, which require to maintain the invariant that the lists are sorted by IDs; \n(2) the limitations of the abstract interpretation used to compute the history and current-decision invariants; \nand (3) the incompleteness of \u00b5Z. In our empirical experience so far, these inaccuracies have not mattered \nmuch. The only substantial source of imprecision has been the abstraction of lists by pairs, but as elaborated \nin the next section, only in two of our benchmark examples does this pose a problem. Also, one could \npresumably eliminate this issue with a more sophisticated list abstraction. 5. Implementation and evaluation \nWe have implemented our approach and experimented with a col\u00adlection of standard geometric algorithms. \nIn this section, we report on the results. It is important to bear in mind that (1) it is very dif.cult \nto declare an algorithm consistent/inconsistent by a light inspection (even by an expert user), and (2) \nit is even more dif.cult to manually prove it is consistent.  5.1 Implementation Our tool is implemented \nin OCaml on top of a CIL [23] frontend. In addition to taking a C .le as input, the tool requires the \nuser to supply a proof system M (in the form of a set of rules; see Fig. 3). The tool operates in three \nphases. First, an integer C program is generated from the original program. Then, numerical invariants \nare generated for the integer program using an abstract domain we will describe below. Then, for each \ncontrol point in the program at which a decision is made, two Datalog programs are generated (using the \ninvariants from the .rst phase and the decision proof system M): one Datalog program for the case that \nthe new decision is positive, and one for the case that its negative. Lastly, we use \u00b5Z [14] to check \nwhether a query in any of these Datalog programs succeeds; if all queries fail, then the input program \nis consistent. The abstract domain we use to generate numerical invariants is a partitioned octagon domain. \nPartitioning is a technique used to reduce the precision lost in an abstract domain due to an imprecise \njoin operator [3]. An element of this domain is a partial function f from a .nite set of cells to octagons. \nThe cells form a covering of the state space, and we require that for every cell c, the concretiza\u00adtion \nof the octagon f(c) lies inside c; such a function represents a .nite disjunction of octagons, where \neach octagon belongs to a dif\u00adferent cell. In our partitioning scheme, the cells corresponds to sets \nof program variable equalities. We built our partitioned octagon do\u00admain on top of the octagon domain \nimplemented in AP RO N [2]. 5.2 Benchmarks We collected a set of geometric algorithms from computational \nge\u00adometry textbooks [8, 9]. These include several convex hull algo\u00adrithms, a few point location algorithms, \nand a few triangulation al\u00adgorithms. Algorithms like this are the core building blocks of geo\u00admetric \nlibraries such as CGAL [1]. The algorithms are presented in the books as pseudocode, and therefore, there \nis occasionally more than one way of implementing them. Note that we are not referring to implementation \ndetails such as choice of data structures; we included more than one version of the same algorithm whenever \nthere was an algorithmic choice about list traversal strategies and other similar notions that can make \na difference in the outcome of our veri.cation algorithm. Below, we provide a high level summary of the \nbenchmarks. Convex Hulls. We have already discussed two convex hull algo\u00adrithms: SIMPLE CO N V E X HUL \nL and GR A HAM SC A N in Sec. 3. The former is not consistent. We discuss the details of the consistency \ncheck for the latter in the following. The set of benchmarks consists of three other convex hull algorithms: \nthe Gift Wrapping algorithm, the Incremental Hull algorithm, and Fortune s algorithm. For the Gift Wrapping \nalgorithm, we present two different variations on how the point set is traversed. The incremental hull \nis a recursive algorithm which has three variations on how the recursive step is performed. Fortune s \nalgorithm uses a major subroutine that com\u00adputes a half of a convex hull (which is effectively called \ntwice); we include this subroutine as a separate benchmark. Note that For\u00adtune s consistency is not trivially \nimplied by the consistency of this subroutine. In [8], a slight variation of Fortune s original algorithm \n[10] was presented which is inconsistent (in contrast to the origi\u00adnal algorithm being designed speci.cally \nto be consistent). Since all other examples were collected from textbooks, we included this version in \nthe set of benchmarks as well. Triangulation. A triangulation of a planar point set P is a sub\u00addivision \nof the plane determined by a maximal set of non-crossing edges whose vertex set is P . The word maximal \nin the de.nition in\u00addicates that any edge not in triangulation must intersect the interior of at least \none of the edges in the triangulation. (Rule G1) Lturn(y, z, x) . Lturn(x, y, z) (Rule G2) Lturn(y, x, \nz) . Lturn(x, y, z) (Rule G4) Lturn(x, y, z) . Lturn(x, y, s) . Lturn(y, z, s) . Lturn(z, x, s) (Rule \nG5) Lturn(x, y, t) . Lturn(x, y, z) . Lturn(x, y, s) . Lturn(y, z, s) . Lturn(y, z, t) . Lturn(s, y, \nt) (Rule V1) . . Lturn(x, y, z) . Lturn(x, y, z) Figure 11. Decision proof system for the Lturn predicate. \nIn our benchmarks we have Triangle Splitting, Incremental tri\u00adangulation, and Delaunay triangulation. \nTriangle Splitting makes use of a point location algorithm (see below), and therefore, its consistency \ndepends on the consistency of the underlying point lo\u00adcation algorithm (i.e., if the latter is inconsistent, \nthen the former is also inconsistent). Since we have two different point location al\u00adgorithms in our \nbenchmarks, we have two versions of the Triangle Splitting algorithm respectively. Incremental triangulation \nis algo\u00adrithmically similar to the incremental convex hull and we similarly included three versions of \nit depending on the recursing strategy. Both Triangle Splitting and Incremental triangulation algorithms \nuse the same Lturn predicate that is used by the convex hull algo\u00adrithms. Delaunay triangulation is a \nspeci.c type of triangulation that has special uses in many areas, e.g. in terrain reconstruction. These \nalgorithms use an operation called .ipping to turn an arbitrary tri\u00adangulation into a Delaunay one or \nto construct a Delaunay trian\u00adgulation incrementally. Flipping relies on a new predicate called InCircle \nthat tests if a given point lies within a given circle. The predicate comes with its own complete set \nof axioms [17] for brevity, we omit the de.nition of this new predicate and its corre\u00adsponding axioms \nhere and refer the interested reader to [17]. Unfor\u00adtunately, all textbook Delaunay triangulation algorithms \nare incon\u00adsistent, and this inconsistency leads to nontermination under some inputs. Point Location. \nIn a point location algorithm, the input is usually a triangulation (of a point set) and a point p, and \nthe goal is to .nd the particular triangle that contains p. Point location queries arise in various settings, \nsuch as .nding one s location on a map and com\u00adputer graphics (it is an essential part of ray-tracing \nalgorithms). In the example that we now consider, the location is a target trian\u00adgle. There are various \ninconsistent point location algorithms; For\u00adtune [10] proposed a consistent algorithm for point location. \nWe included Fortune s algorithm and a standard inconsistent algorithm that is routinely used in ray tracer \nimplementations. Axioms and decision proof system. All our benchmarks use the Lturn predicate introduced \nearlier; we assume an axiomatization as in Fig. 3 for this predicate. Fig. 11 offers a sketch of the \ndecision proof system derived from these axioms. Here, Rules G1 and G2 represent the nondegeneracy case \nof axiom 3 in Fig. 3. Rules G1 corresponds to the cyclic symmetry and antisymmetry axioms, while rules \nG4 and G5 represent the interiority and transitivity axioms. Rule V1 is the violator rule for the Lturn \npredicate.  5.3 Experimental Results Table 1 presents the result of the experiments carried out using \nour tool. The upper, middle, and the lower part of the table respectively show the results for a variety \nof convex hull, point location, and triangulation algorithms. The .rst two columns (after the benchmark \nnames) indicate whether the benchmark is consistent and whether our tool man\u00adaged to prove it consistent. \nA NO answer by the tool means that a counterexample was found for the consistency of the integer C Table \n1. Automated Consistency Veri.cation Results. Invariant Generation Time refers to the time that it takes \nfor the invariants to be generated for the integer program. Consistency Analysis time refers to the time \nthat it takes \u00b5Z to prove the consistency claims. Invariant Size refers to the size of the invariants \n(in number of conjuncts); where there is more than one decision location in the program, we add the invariants \nup into a total number, but indicate the number of claims within parentheses.  Benchmark Consistent? \nProved Consistent? Invariant Generation Time Consistency Analysis Time Invariant Size SlowHull NO NO \n14s 2s 780 (2) Graham Scan YES YES 22s 38s 4188 (4) Gift Wrapping v1 NO NO 24s 2s 1494 (2) Gift Wrapping \nv2 NO NO Incremental Hull v1 YES YES 1m5s 44s 4454 (2) Incremental Hull v2 YES YES 1m1s 2m23s 5904 (2) \nIncremental Hull v3 YES NO 1m35s 22s 22658 (4) Fortune (half) Hull YES YES 10s 13s 774 (2) Fortune Hull \nYES YES 2m43s 5m17s 30088 (8) Fortune Hull (t) NO NO 48s 10s 10440 (6) Point Location v1 Point Location \nv2 Hull Triangle Location YES NO NO YES NO NO 25s 1m26s 1m38s 2m28s 2s 4s 2608 (4) 566 (6) 2202 (6) Incremental \nTriangulation v1 YES YES 1m12s 44s 4454 (2) Incremental Triangulation v2 YES YES 1m8s 2m23s 5904 (2) \nIncremental Triangulation v3 YES NO 1m38s 31s 22658 (2) Triangle Splitting v1.1 YES YES 40s 2m28s 2608 \n(4) Triangle Splitting v1.2 NO NO 1m45s 2s 566 (6) Triangle Splitting v2 NO NO Delaunay Triangulation \nv1 NO NO 6s 0s 152 (2) Delaunay Triangulation v2 NO NO program. However, since this integer program \nis an overapproxi\u00admation of the behaviour of the original C program, the counterex\u00adample may not be a \nreal one. Note that since our tool is sound, a NO/YES combination is not a possibility for these two \ncolumns. And, since it is not complete, a YES/NO option is a possibility. For some of the benchmarks, \nno times are reported. This is be\u00adcause the benchmark was declared inconsistent in the integer pro\u00adgram \ngeneration phase, since the proper ordering constraints were not followed while manipulating lists in \nthe program. Interestingly, in all such cases, the program is indeed inconsistent. Summary of Results. \nOut of the 21 benchmarks, 9 are consistent. There are 3 inconsistent benchmarks that are declared inconsistent \nwhen the integer program generation fails to generate a meaningful program. Note that the \u00b5Z terminates \nmuch faster in the case where an inconsistency is found since it .nds a satis.able assignment relatively \nquickly in these cases, whereas for the consistent cases, it has to effectively prove the lack of a satis.able \nassignment. For almost all (except two) benchmarks, if the program is con\u00adsistent, our tool succeeds \nto prove it. For a variation of Incremental convex hull (v3) and the corresponding incremental triangulation \nalgorithm (v3), the list abstraction is too coarse to prove the exam\u00adple consistent. The reason for inconsistency \nis that in the integer program, the program is practically making repeat queries. In our uncertain semantics, \nwe assume that repeat queries may get differ\u00adent result from the original ones. If we drop this assumption, \nthen the tool can be easily tuned to prove these two benchmarks consis\u00adtent as well. The fact that we \ncan prove almost all consistent exam\u00adples correct using our tool suggests that our proposed abstraction \ntechnique is powerful despite its simplicity.  5.4 Detailed Discussion of Graham Scan We discussed the \nGraham Scan algorithm as an example in Sec. 3. Here we provide a more detailed consistency argument, \nto provide some intuition why our tool succeeds in proving it consistent. First, an integer program is \ngenerated from this program. Here, we assume that the points in S are assigned integer IDs in the order \nthat they are fetched from the input list (from 1 to |S|). The point p0 has an ID 0. As stated earlier, \nwe ignore the assumption that the input points are sorted according to their polar angle. From this point \non, we just refer to the points by their numeric identi.ers. Now consider line 6 of the Graham Scan code \n(Fig. 8), where the query Lturn(u, v, w) is made. We note that u < v < w is an invariant here, and from \nthis observation, we can deduce the following history invariant for this location: H(#1, #2, #3, u, v, \nw, p0) = p0 < #1 < #2 < #3. Now consider the new decision that is about to be made at line 6: Lturn(u, \nv, w). Invariant generation provides us with the following facts about values of u,v, and w: (#1, #2, \n#3, u, v, w, p0) = u < v < w . w > #3 dLturn . p0 < #1 < #2 < #3 Note that the actual invariant generated \nby our tool contains many more conjuncts and variables. Here, we are stripping it to the essential core \nto demonstrate the reasoning. Also, this is a speci.c case where the outcome of the query was false. \nThere will be a similar case where the outcome of the query is true, dLturn (#1, #2, #3, u, v, w, p0) \n= u < v < w . w > #3 . p0 < #1 < #2 < #3 but the reasoning below will be the same (though done separately \nfor each of) the two cases. Combining the information for the history and the current deci\u00adsion, it is \neasy to argue that if the history is already consistent, then the new decision added will not create \nany new inconsistencies with respect to any of the rules in Fig. 11. Since the third argument w is (provably) \nstrictly greater than the arguments #1, #2, #3 which characterize all past decisions, it is easy to see \nwhy this is the case. Each argument of the Lturn predicate appears at least twice among the premises \nof every single rule in Fig. 11; therefore, any decision with fresh new point w cannot be involved in \ngenerating any new facts or causing a violation. The actual reasoning for this is done by \u00b5Z in our implementation. \nNow consider the decision at line 14. Here, w never changes and always points to p0 (i.e. idw = 0). Naturally, \nthe history for line 6 is also part of the history for line 14. But the history for line 14 also includes \nthe decisions made previously in the same loop.  Our analysis produces the following history invariant: \nH(#1, #2, #3, u, v, w, p0) = (p0 < #1 < #2 < #3) . (p0 < #1 < #2 . #3 = p0) where the .rst disjunct refers \nto the history based on the decisions made at line 6 and the second disjunct refers to the history based \non the decisions made at line 14. The current decision invariant is: (#1, #2, #3, u, v, w, p0) = ((u \n< v) . w = p0 . (p0 < #1 < #2 < #3)) . ((u < v) . (w = p0) . (v > #2) . (p0 < #1 < #2) . #3 = p0)) dLturn \nand, similar to above, there is a positive version of this decision. It is a bit harder to manually reason \nabout this case. Intuitively, it is easy to reason that the decision, where the last argument is always \na fresh new value 0, cannot generate any new facts or violations when considered together with the history \ndecisions that are generated at line 6 (in which 0 never appears). The argument about why no new violations \nare created as a result of combining the new decision with the part of history that comes from line 14 \nis similar to the case of line 6. 6. Related work The problem of consistency has been studied in depth \nin the com\u00adputational geometry literature [15, 16, 21, 26]. This literature has developed several subtly \ndifferent notions of consistency for geo\u00admetric programs; our de.nition coincides with a de.nition used \nby, among others, Fortune [10]. However, so far as we know, there is no prior work on static veri.cation \nof consistency in this area: to the extent that veri.cation is mentioned at all, it is stated to be too \ndif.cult to be realistic [20]. Instead, existing approaches focus on dynamic techniques that are often \nbased on high-precision library operations. The inherent limitation of such approaches is that they do \nnot reason globally about uncertain decisions made at differ\u00adent program points, and hence do not give \nend-to-end guarantees of consistency. The only work on formal veri.cation of geometric programs that \nwe know of comes from the theorem proving com\u00admunity [24], and this work does not study consistency. \nThere is an emerging body of work on reasoning about program behaviour in the presence of uncertainty \n[4, 5, 18, 19, 25]. How\u00adever, none of these analyses can reason about the notion of consis\u00adtency considered \nin this paper; instead, they focus on quantitative differences in a program s behaviour due to uncertainty. \nAlso not applicable are abstract-interpretation-based techniques for quanti\u00adfying numerical errors in \nprograms [6, 11], as none of these meth\u00adods reason about divergence in control .ow caused by uncertainty. \nIn contrast, uncertain control .ow is perhaps the most central aspect of the geometric programs studied \nhere. 7. Conclusion We have introduced the problem of automatically verifying the consistency of programs \nthat make decisions under uncertainty, and taken the .rst steps towards solving the problem. Our solution \ncan automatically verify the consistency of a comprehensive set of algorithms for computing convex hulls \nand triangulations. While this paper focused on .nding proofs of robustness, the dual problem of .nding \ninputs that cause a geometric program to violate robustness is also of interest. Also, we restricted \nour\u00adselves in this paper to a model of uncertainty where every predicate can evaluate nondeterministically. \nAs we showed, even under this highly adversarial execution model, many everyday computations are consistent. \nHowever, future work should also study less hostile models of numerical uncertainty. There are several \nways to account for this fact. For instance, a possibility is to consider quantitative models of uncertainty \nproperties where a query .ips with a cer\u00adtain probability, or under certain conditions on the inputs. \nReferences [1] CG A L, Computational Geometry Algorithms Library. http://www.cgal.org. [2] J. Bertrand \nand A. Min e.\u00b4Apron: A library of numerical abstract domains for static analysis. In CAV, pages 661 667, \n2009. [3] Franc\u00b8 ois Bourdoncle. Abstract interpretation by dynamic partitioning. Journal of Functional \nProgramming, 2(04):407 435, 1992. [4] S. Chaudhuri, S. Gulwani, and R. Lublinerman. Continuity analysis \nof programs. In POPL, pages 57 70, 2010. [5] S. Chaudhuri, S. Gulwani, and R. Lublinerman. Continuity \nand ro\u00adbustness s of programs. Commun. ACM, 55(8):107 115, 2012. [6] L. Chen, A. Min \u00b4e, J. Wang, and \nP. Cousot. Interval polyhedra: An abstract domain to infer interval linear relationships. In SAS, 2009. \n[7] M. De Berg, O. Cheong, and M. Van Kreveld. Computational geome\u00adtry: algorithms and applications. \nSpringer-Verlag, 2008. [8] Mark de Berg, Marc van Kreveld, Mark Overmars, and Otfried Schwarzkopf. Computational \nGeometry: Algorithms and Applica\u00adtions. Springer-Verlag, 2000. [9] S. Devadoss and J. O Rourke. Discrete \nand Computational Geometry. Princeton University Press, 2011. [10] S. Fortune. Stable maintenance of \npoint set triangulations in two dimensions. In FOCS, pages 494 499, 1989. [11] E. Goubault. Static analyses \nof the precision of .oating-point opera\u00adtions. In SAS, pages 234 259, 2001. [12] Ronald L. Graham. An \nef.cient algorithm for determining the convex hull of a .nite planar set. Inf. Process. Lett., 1(4):132 \n133, 1972. [13] J. Halpern. Reasoning about uncertainty. The MIT Press, 2003. [14] K. Hoder, N. Bj\u00f8rner, \nand L. de Moura. \u00b5Z -an ef.cient engine for .xed points with constraints. In CAV, 2011. [15] C. Hoffmann, \nJ. Hopcroft, and M. Karasick. Towards implementing robust geometric computations. In SoCG, pages 106 \n117, 1988. [16] C.M. Hoffmann. The problems of accuracy and robustness in geomet\u00adric computation. Computer, \n22(3):31 39, 1989. [17] D.E. Knuth. Axioms and Hulls (LNCS #606). Springer-Verlag, 1992. [18] R. Majumdar, \nE. Render, and P. Tabuada. A theory of robust software synthesis. CoRR, abs/1108.3540, 2011. [19] R. \nMajumdar and I. Saha. Symbolic robustness analysis. Real-Time Systems Symposium, IEEE International, \n0:355 363, 2009. [20] K. Mehlhorn. The reliable algorithmic software challenge RASC, pages 255 263. 2003. \n[21] K. Mehlhorn and C. Yap. Robust geometric computation. http://cs.nyu.edu/~yap/book/egc, 2011. [22] \nD. Monniaux. The pitfalls of verifying .oating-point computations. ACM Trans. Program. Lang. Syst., 30(3), \n2008. [23] George C. Necula, Scott McPeak, Shree Prakash Rahul, and Westley Weimer. CIL: Intermediate \nlanguage and tools for analysis and trans\u00adformation of C programs. In CC, pages 213 228, 2002. [24] D. \nPichardie and Y. Bertot. Formalizing convex hull algorithms. In TPHOLs, volume 2152 of LNCS, pages 346 \n361. Springer, 2001. [25] J. Reed and B. Pierce. Distance makes the types grow stronger: A calculus for \ndifferential privacy. In ICFP, 2010. [26] R. Shewchuk. Adaptive precision .oating-point arithmetic and \nfast robust geometric predicates. Discrete &#38; Computational Geometry, 18(3):305 363, 1997.    \n\t\t\t", "proc_id": "2535838", "abstract": "<p>Applications in many areas of computing make discrete decisions under <i>uncertainty</i>, for reasons such as limited numerical precision in calculations and errors in sensor-derived inputs. As a result, individual decisions made by such programs may be nondeterministic, and lead to contradictory decisions at different points of an execution. This means that an otherwise correct program may execute along paths, that it would not follow under its ideal semantics, violating essential program invariants on the way. A program is said to be <i>consistent</i> if it does not suffer from this problem despite uncertainty in decisions.</p> <p>In this paper, we present a sound, automatic program analysis for verifying that a program is consistent in this sense. Our analysis proves that each decision made along a program execution is consistent with the decisions made earlier in the execution. The proof is done by generating an invariant that abstracts the set of all decisions made along executions that end at a program location <i>l</i>, then verifying, using a fixpoint constraint-solver, that no contradiction can be derived when these decisions are combined with new decisions made at <i>l</i>.</p> <p>We evaluate our analysis on a collection of programs implementing algorithms in <i>computational geometry</i>. Consistency is known to be a critical, frequently-violated, and thoroughly studied correctness property in geometry, but ours is the first attempt at automated verification of consistency of geometric algorithms. Our benchmark suite consists of implementations of convex hull computation, triangulation, and point location algorithms. On almost all examples that are not consistent (with two exceptions), our analysis is able to verify consistency within a few minutes.</p>", "authors": [{"name": "Swarat Chaudhuri", "author_profile_id": "81309496839", "affiliation": "Rice University, Houston, TX, USA", "person_id": "P4383901", "email_address": "swarat@rice.edu", "orcid_id": ""}, {"name": "Azadeh Farzan", "author_profile_id": "81350568899", "affiliation": "University of Toronto, Toronto, ON, Canada", "person_id": "P4383902", "email_address": "azadeh@cs.toronto.edu", "orcid_id": ""}, {"name": "Zachary Kincaid", "author_profile_id": "81472649374", "affiliation": "University of Toronto, Toronto, ON, Canada", "person_id": "P4383903", "email_address": "zkincaid@cs.toronto.edu", "orcid_id": ""}], "doi_number": "10.1145/2535838.2535858", "year": "2014", "article_id": "2535858", "conference": "POPL", "title": "Consistency analysis of decision-making programs", "url": "http://dl.acm.org/citation.cfm?id=2535858"}