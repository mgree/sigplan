{"article_publication_date": "01-08-2014", "fulltext": "\n Applying Quantitative Semantics to Higher-Order Quantum Computing * Michele Pagani Peter Selinger Beno \nit Valiron Universit\u00b4e Paris 13, Sorbonne Paris Cit\u00b4e Dalhousie University CIS Dept, University of Pennsylvania \nVilletaneuse, France Halifax, Canada Philadelphia, U.S.A. michele.pagani@lipn.univ-paris13.fr selinger@mathstat.dal.ca \nbenoit.valiron@monoidal.net Abstract Finding a denotational semantics for higher order quantum com\u00adputation \nis a long-standing problem in the semantics of quantum programming languages. Most past approaches to \nthis problem fell short in one way or another, either limiting the language to an un\u00adusably small .nitary \nfragment, or giving up important features of quantum physics such as entanglement. In this paper, we \npropose a denotational semantics for a quantum lambda calculus with recur\u00adsion and an in.nite data type, \nusing constructions from quantitative semantics of linear logic. Categories and Subject Descriptors F.3.2 \n[Semantics of Pro\u00adgramming Languages]: Denotational semantics Keywords higher-order; quantum computation; \nfunctional pro\u00adgramming; completely positive maps; categorical model 1. Introduction Type theory and \ndenotational semantics have been successfully used to model, design, and reason about programming languages \nfor almost half a century. The application of such methods to quantum computing is much more recent, \ngoing back only about 10 years [18]. An important problem in the semantics of quantum computing is how \nto combine quantum computing with higher-order functions, or in other words, how to design a functional \nquantum program\u00adming language. A syntactic answer to this question was arguably given with the design \nof the quantum lambda calculus [20, 23]. The quantum lambda calculus has a well-de.ned syntax and operational \nsemantics, with a strong type system and a practical type inference algorithm. However, the question \nof how to give a denotational se\u00admantics to the quantum lambda calculus turned out to be dif.cult, and \nhas remained open for many years [19, 22]. One reason that designing such a semantics is dif.cult is \nthat quantum computation is inherently de.ned on .nite dimensional Hilbert spaces, whereas * Partially \nfounded by French ANR project COQUAS (number 12 JS02 006 01) and CNRS chair Logique lin\u00b4eaire et calcul \n. Permission to make digital or hard copies of all or part of this work for personal or classroom use \nis granted without fee provided that copies are not made or distributed for pro.t or commercial advantage \nand that copies bear this notice and the full citation on the .rst page. Copyrights for components of \nthis work owned by others than the author(s) must be honored. Abstracting with credit is permitted. To \ncopy otherwise, or republish, to post on servers or to redistribute to lists, requires prior speci.c \npermission and/or a fee. Request permissions from permissions@acm.org. POPL 14, January 22 24, 2014, \nSan Diego, CA, USA. Copyright is held by the owner/author(s). Publication rights licensed to ACM. ACM \n978-1-4503-2544-8/14/01. . . $15.00. http://dx.doi.org/10.1145/2535838.2535879 the semantics of higher-order \nfunctional programming languages, including such features as in.nite data types and recursion, is in\u00adherently \nin.nitary. In recent years, a number of solutions have been proposed to the problem of .nding a denotational \nsemantics of higher-order quantum computation, with varying degrees of success. The .rst approach [21]was \nto restrict the language to strict linearity, mean\u00ading that each function had to use each argument exactly \nonce, in the spirit of linear logic. In this way, all in.nitary concepts (such as in.nite types and recursion) \nwere eliminated from the language. Not surprisingly, the resulting .nitary language permitted a fully \nabstract semantics in terms of .nite dimensional spaces; this was hardly an acceptable solution to the \ngeneral problem. The second approach [14]was to construct a semantics of higher-order quan\u00adtum computation \nby methods from category theory; speci.cally, by applying a presheaf construction to a model of .rst-order \nquan\u00adtum computation. This indeed succeeds in yielding a model of the full quantum lambda calculus, albeit \nwithout recursion. The main drawbacks of the presheaf model are the absence of recursion, and the fact \nthat such models are relatively dif.cult to reason about. The third approach [6]was based on the Geometry \nof Interaction. Starting from a traced monoidal category of basic quantum oper\u00adations, Hasuo and Hoshino \napplied a sequence of categorical con\u00adstructions, which eventually yielded a model of higher-order quan\u00adtum \ncomputation. The problem with this approach is that the tensor product constructed from the geometry-of-interaction \nconstruction does not coincide with the tensor product of the underlying physical data types. Therefore, \nthe model drops the possibility of entangled states, and thereby fails to model one of the de.ning features \nof quantum computation. Our contribution. In this paper, we give a novel denotational semantics of higher-order \nquantum computation, based on meth\u00adods from quantitative semantics. Quantitative semantics refers to \na family of semantics of linear logic that interpret proofs as linear mappings between vector spaces \n(or more generally, modules), and standard lambda terms as power series. The original idea comes from \nGirard s normal functor semantics [4]. More recently, quanti\u00adtative semantics has been used to give a \nsolid, denotational seman\u00adtics for various algebraic extensions of lambda calculus, such as probabilistic \nand differential lambda calculi (e.g. [1], [2]). One feature of our model is that it can represent in.nite \ndi\u00admensional structures, and is expressive enough to describe recur\u00adsive types, such as lists of qubits, \nand to model recursion. This is achieved by providing an exponential structure ` a la linear logic. Unlike \nthe Hasuo-Hoshino model, our model permits general en\u00adtanglement. We interpret (a minor variant of) the \nquantum lambda calculus in this model. Our main result is the adequacy of the model with respect to the \noperational semantics.  M (i) (ii) x,y  . qubit 2: |0) H location A qubit 3: |0) . location B \nqubit 1: |f)      |f) Uxy (iii) Figure 1: The quantum teleportation protocol. state |1). The box \nM is a measurement. The unitaries Uxy are (1 0 (0 1 (10 01 U00 = ), U01 = ), U10 = ), U11 = ( ). 01 \n10 0 -1 -1 0 The goal is to send a quantum bit in an unknown state |f)from Location A to Location B using \ntwo classical bits. The procedure can be reversed to send two classical bits using a quantum bit. In \nthis case it is called the dense coding algorithm [17]. The algorithm consists of three parts. In (i), \ntwo quantum bits (qubits 2 and 3) are entangled in state v1(|00)+ |11)). In (ii), 2 the input qubit 1 \nin state |f)is entangled with qubit 2, then both are measured. The result is sent over location B, where \nin (iii)an correction Uxy is applied on qubit 3, settingit to state |f). 2.2 Densitymatrices and completelypositive \nmaps ( 1 0 ) and ( If we identify |0)and |1)with the standard basis vectors ) , the state of a qubit \ncan be expressed as a two-dimensional 0 1 The model is the juxtaposition of a simple, .nite-dimensional \nmodel of quantum computation together with a canonical comple\u00adtion yieldingthe structures oflinear logic. \nOur modeldemonstrates that the quantum and the classical universes work well together, but also surprisingly \n that they do not mix too much, even at higher order types. Outline. In Section 2, we brie.y review some \nbackground. Sec\u00adtion 3 presents the version of the quantum lambda calculus that we use in this paper, \nincluding its operational semantics. Section 4 presents the denotational semantics of the quantum lambda \ncalcu\u00adlus, and Section 5 proves the adequacy theorem. Section 6 con\u00adcludes withsome properties of the \nrepresentable elements. 2. Background 2.1 Quantum computation in a nutshell Quantum computation is a \ncomputational paradigm based on the laws of quantum physics. We brie.y recall some basic notions; please \nsee [17] for a more complete treatment. The basic unit of information in quantum computation is a quantum \nbit or qubit, whose state is given bya normalized vector in the two-dimensional Hilbert space C2. It \nis customaryto write the canonical basis ofC2 as {|0), |1)}, and to identify these basis vectors with \nthe booleans false and true, respectively. The state of a qubit can therefore be thought of as a complex \nlinear combination a|0)+ \u00df|1)of booleans, calleda quantum superposition. More generally, the state ofn \nqubits is an element ofthe n-foldtensor product C2.. . ..C2 . There are three kinds of basic operations \non quantum data: ini\u00adtializations, unitarymaps andmeasurements. Initialization prepares a new qubit in \nstate |0)or |1). A unitary map, or gate, is an in- U-1 vertible linear map U such that U * = ; here U \n* denotes the complex conjugate transpose of U. Finally, the operation of mea\u00adsurement consumes a qubit \nand returns a classical bit. If n qubits are in state a|0).f0+\u00df|1).f1, where f0 andf1 are normalized \nstates ofn-1qubits, then measuringthe leftmost qubit yields false with probability |a|2, leavingthe remaining \nqubits in state f0, and true with probability|\u00df|2, leavingthe remainingqubits in state f1. Example 1. \nA small algorithm is the simulation of an unbiased coin toss:initialize one quantum bitto |0), applythe \nHadamardgate sending|0)to v1 (|0)+|1))and|1)to v1 (|0)-|1)), then measure. 2 2 The result is true withprobability \n1 2 and false withprobability 1 2 . Example 2. A slightly more involved algorithm is the quantum teleportation \nalgorithm (see [17] for details). The procedure is summarized in Figure 1. Wires represent the path of \nquantum bits in the computation, and time .ows from left to right. The gate H stands for an application \nof the Hadamard gate, whereas the gate . is a controlled-not: it negates the bottom qubit ifthe upper \none is in () a vector v = a|0)+ \u00df|1)= . Similarly, the state of an n-qubit \u00df system can be expressed \nas an 2n -dimensional column vector. Of\u00adten, it is necessary to consider probability distributions on \nquan\u00adtum states;these are also known as mixed states. Consider a quan\u00adtum system that is in one of several \nstates v1, . . . , vk with proba\u00adbilities p1, . . . , pk, respectively. The density matrix of this mixed \nL* state is de.ned to be A = i pivivi , where (-) * denotes the ad\u00adjoint operator. By a theorem of Von \nNeumann, the density matrix is a good representation of mixed states, in the following sense: two mixed \nstates are indistinguishable by any physical experiment if and only if they have the same density matrix \n[17]. Note that trA = p1 + . . . + pk. For our purposes, it is often convenient to permit sub-probability \ndistributions, so that p1 + . . . + pk . 1. Let us write Cn\u00d7n for the space of n \u00d7 n-matrices. Recall \nthat a matrix A . Cn\u00d7n is called positive if v * Av ? 0 for all v . Cn . Given A, B . Cn\u00d7n , we write \nA . B iff B - A is positive; this is the so-called L\u00a8owner partial order. A linear : Cn\u00d7n . Cm\u00d7m map \nF is called positive if A . 0 implies F (A) . 0, and completely positive if F . idk is positive for all \nk, where idk is the identity function on Ck\u00d7k . If F moreover satis.es tr(F (A)) . trA for all positive \nA, then it is called a superoperator. The density matrices are precisely the positive matrices A of trace \n. 1. Moreover, the superoperators correspond precisely to those functions from mixed states to mixed \nstates that are physicallypossible [17, 18].  2.3 The category CPM The category CPMs is de.ned as follows: \nthe objects are natural numbers, and a morphism F : n . m is a completely positive : Cn\u00d7n . Cm\u00d7m map \nF . Let CPM be the free completion of CPMs under .nite biproducts;speci.cally, the objects ofCPMare sequences \nn = (n1, . . . , nk)of natural numbers, and a morphism F : nm is a matrix (Fij ) : nj . mi of n . nof \nmorphisms Fij CPMs. The categories CPMs and CPM are symmetric monoidal, and in fact, compact closed [18]. \n 2.4 Limitations of CPM as a model The categoryCPMcan serve as a fullyabstract modelfor a simple, strictlylinear, \n.nitaryquantum lambda calculus [21]. For example, the type bit is interpreted as (1, 1), and the type \nqubit is inter\u00adpreted as (2). Measurement, as a map from qubit to bit, sends (a b c d )to (a, d). The \ncoin toss is a map (1) . (1, 1)sending (p) to (p 2, p 2). Function spaces are interpreted via the compact \nclosed structure. As mentioned in the introduction, the semantics of [21]is ex\u00adtremely limited, because \nit is completely .nitary. Thus recursion, in.nite data types, and non-linear functions (i.e., those that \ncan use their argument more than once)hadto be completelyremovedfrom  Terms M, N, P ::= x .xA.M M N \nskip M;N M .N let x A .y B = M in N A B inl M inr M match P with (x : M |y : N ) splitA letrec fA.B \nx = M in N meas new U Values V, W ::= x c .xA.M V .W inl V inr W Types A, B, C ::= Al qubit A.B !(A . \nB) 1 A .B A .B . Table 1: Grammars of terms, values and types. the language in order to .t the model. \nFor example, even the simple squaring function f . .x.f (f x)is not representable in CPM. The purpose \nof the present paper is to remove all of these restrictions. As an example, consider the following pseudo-code \n(in ML-style): val qlist : qubit -> qubit list let rec qlist q = if (cointoss) then [q] else let (x,y) \n= entangle q in x::(qlist y) Here, cointoss is a fair coin toss, and the function entangle sends a|0)+\u00df|1)to \na|00)+ \u00df|11). So if the function qlist is applied to a qubit a|0)+ \u00df|1), the output is a|0)+ \u00df|1)with \nprobability 1 , a|00)+ \u00df|11)with 2 probability 1 , a|000)+ \u00df|111)with probability 1, and so on. Its 4 \n8 semantics should be of type 2 . (2, 4, 8, . . .), mapping (1 (a 0 0 b )) (a b (a b 1 0 0 0 0 ) . ), \n,.... cd cd 0 0 0 0 2 4 c 0 0 d The category CPM is almost capable of handling this case, but not quite, \nbecause it cannot express in.nite tuples of matrices. The model we propose in this paper is essentially \nan extension of CPM to in.nite biproducts, using methods developed in [5, 11, 12, 16]. 3. A quantum lambda \ncalculus We de.ne a variant of the typed quantum lambda calculus of [22]. The main difference is that \nthe language in this present paper is a true extension of linear logic (see the type assignment system \nof Table 2). In particular, in contrast with [22], !(A . B) . !A.!B is not provable and there is no need \nfor a subtyping relation. The operational semantics implements a call-by-value strategy. An untyped call-by-name \nvariant has been studied in [10]. The classes of terms, values and types are de.ned in Table 1. The symbol \nc ranges over the set of term constants {skip, splitA , meas, new, U }. The constant U ranges over a \nset of elementary unitary transformations on quantum bits. In the examples below, we will be using the \nHadamard gate H and the controlled-not gate Nc, de.ned as follows [17]: (1 1 ) (1 0 0 0 ) 1 0 1 0 0 H \n= v Nc = (1) 1 -1 0001 2 0 0 1 0 Notice that bound variables are given in Church style, i.e., with a \ntype annotation. This enables Proposition 4, and simpli.es the se\u00admantic interpretation of the typed \nterms. We omit such annotations in the sequel if uninteresting or obvious. We have two kinds of arrows: \nthe linear arrow A.B, and the intuitionistic arrow !(A . B), which is obtained by the call-by\u00advalue translation \nof the intuitionistic implication into linear logic [3]. Intuitively, only the terms of type !(A . B)represent \nfunc\u00adtions that can be used repeatedly, whereas terms of type A.B must be used exactly once. A type of \nthe form !A is called a !-type or non-linear type, and all other types are called linear. The distinc\u00adtion \nbetween linear and non-linear types is crucial for allowing the type system to enforce the no-cloning \nproperty of quantum physics. By convention, . is associative to the right, while application and tensor \nare associative to the left. We use the notation A.n for A tensored n times. The type Al denotes .nite \nlists of type A. When doing structural induction on types, we assume that Al is greater than A.n, for \nany n . N. The set of terms and types is somewhat spartan; however it can be easily extended by introducing \nsyntactic sugar. Note that, for technical convenience, we have only allowed types of the form !A when \nA is an arrow type. However, for an arbitrary type A, the type !A can be simulated by using !(1 . A)instead. \nNotation 3. We write bit = 1 . 1, tt = inr skip, ff = inl skip, nil = inl skip and M :: N = inr (M .N). \nWe write .skip.M for the term .z1 .(z;M), where z is a fresh variable, and if P then M else N for match \nP with (x 1 : N |y 1 : M). A context .is a function from a .nite set of variables to types. We denote \nthe domain of . by |.|, and we write . = x1 : A1, . . . , xn : An whenever |.|= {x1, . . . , xn}and .(xi) \n= Ai. We call . exponential (resp. linear) whenever all Ai are !\u00adtypes (resp. no Ai is a !-type). We \nwrite !. for a context that is exponential. The notation G, S refers to the union of the two contexts \nGand Sand assumes that |G|and |S|are disjoint. A judgement is a triple G . M : A of a context G, a term \nM and a type A. A judgement is called valid if it can be inferred from the typing rules in Figure 2, \nusing the convention that the contexts Gand Sare linear. Proposition 4. There is at most one derivation \ninferring a given typing judgement G . M : A. Example 5. In Section 2.4, we wrote the informal program \nqlist. Our language is expressive enough to represent it. The term cointoss can be de.ned as meas(H(new \ntt)), and it has type bit. The term entangle is .xqubit .Nc(x .(new ff)), which has type qubit . qubit \n.qubit. Then, qlist is qubit .qubitl letrec f q = if cointoss then q :: nil qubit qubit else let x.y= \nentangle q in x :: f y which has type qubit . qubitl . In Examples 9 and 28 we discuss its operational \nand denotational semantics, respectively. Example 6. In Example 2 and Figure 1, we sketched the quantum \nteleportation algorithm. We said that the algorithm can be decom\u00adposed into 3 parts. Each of these parts \ncan be described and typed in the quantum lambda calculus, yielding a higher-order term. This is an adaptation \nof an example provided in [20]. (i) generates an EPR pair of entangled quantum bits. Its type is therefore \n1 . qubit .qubit. The corresponding term is EPR = .skip.Nc ((H(new ff)) .(new ff)) . (ii) performs a \nBell measurement on two quantum bits and outputs two classical bits x, y. Its type is thus qubit . qubit \n. bit .bit, and the term BellMeasure is de.ned as ( ) let x .y = Nc (q1 .q2) .q1..q2. . in (meas (H x)) \n.(meas y)  A linear !. . V : A . B V value ax axd p 1I !., x : A . x : A !., x : !(A . B). x : A . B \n!. . V : !(A . B) !. . skip : 1 ., x : A . M : B !., G . M : A . B !., S . N : A !., G . M : 1 !., S \n. N : A .I .E 1E . . .xA.M : A . B !., G, S . M N : B !., G, S . M;N : A !., G . M : A !., S . N : B \n!., G . M : A .B !., S, x : A, y : B . N : C .E .I B !., G, S . M .N : A .B !., G, S . let x A .y = \nM in N : C !., G . M : A !., G . M : B .r .l I !., G . inl M : A .B I !., G . inr M : A .B !., G . M \n: 1 .(A.Al) -l I split !., G . M : Al !. . splitA : Al.1.(A.Al) !., S, x : A . M : C !., G . P : A .B \n!., S, y : B . N : C .E !., G, S . match P with (x A : M |y B : N): C !., f : !(A . B), x : A . M : \nB !., G, f : !(A . B). N : C rec !., G . letrec fA.B x = M in N : C U of arity n U meas new !. . meas \n: qubit . bit !. . new : bit . qubit !. . U : qubit.n . qubit.n Table 2: Typing rules. The contexts Gand \nSare assumed to be linear. (iii) performs a correction. It takes one quantum bit, two classical bits, \nand outputs a quantum bit. It has a type of the form qubit . bit .bit . qubit. The term is U = .q..x \n.y.if x then (if y then U11 q else U10 q) else (if y then U01 q else U00 q). We can now write the term \ntelep = .skip.let x .y = let f = let g = in f .g. It can then be shown that EPR skip in BellMeasure x \nin U y . telep :!(1 . (qubit . bit .bit).(bit.bit . qubit)) is a valid typing judgement. In other words, \nthe teleportation algo\u00adrithm produces a pair of entangled functions f : qubit . bit . bit and g : bit.bit \n. qubit. These functions have the property that g(f(|f))) = |f)for all qubits |f), and f(g(x .y)) = (x \n.y) for all booleans x and y. These two functions are each other s in\u00adverse, but because they contain \nan embedded qubit each, they can only be used once. They can be said to form a single-use isomor\u00adphism \nbetween the (otherwise non-isomorphic) types qubit and bit . bit. However, the whole procedure is duplicable: \none can generate as many one-time-use isomorphism pairs as desired. 3.1 Operational semantics The operational \nsemantics is de.ned in terms of an abstract ma\u00adchine simulating the behavior of Knill s QRAM model [8]. \nIt is similar to the semantics given in [22]. De.nition 7. Aquantum closure is a triple [q, l, M ]where \n q is a normalized vector of C2n , for some integer n ? 0. The vector q is called the quantum state; \n M is a term, not necessarily closed;  l is a one-to-one map from the set of free variables of M to \nthe set {1, . . . , n}. It is called the linking function.  We write |l|for the domain of l. By abuse \nof language we may call a closure [q, l, V ] a value when the term V is a value. We denote the set of \nquantum closures by Cl and the set of quantum closures that are values by Val. We write l|M for the linking \nfunction whose domain is restricted to the set of free variables of M. We say that the quantum closure \n[q, l, M ] is total when |l|has cardinality n, the size of the quantum state. In that case, if |l|= {x1, \n. . . , xn}and l(xi) = i, we write l as |x1, . . . , xn). A quantum closure [q, |x1, . . . , xn), M ]has \na type A, whenever x1 : qubit, . . . , xn : qubit . M : A. In case l = |x1, . . . , xn)we can also write \nl . M : A. The purpose of a quantum closure is to provide a mechanism to talk about terms with embedded \nquantum data. The idea is that a variable y . FV(M)is bound in the closure [q, l, M ]to qubit number \nl(y) of the quantum state q. So for example, the quantum closure [v1(|00)+ |11)), |x1, x2), .yA .yx1x2]denotes \n2 a term .yA .yx1x2 with two embedded qubits x1, x2 in the entan\u00adgled state |x1x2)= v1(|00)+|11)). 2 \nThe notion of a-equivalence extends naturally to quantum clo\u00adsures, for instance, the states [q, |x), \n.yA .x]and [q, |z), .yA .z]are equivalent. From now on, we tacitly identify quantum closures up to renaming \nof bound variables. The evaluation of a term is de.ned as a probabilistic rewriting procedure on quantum \nclosures, using a call-by-value reduction p strategy. We use the notation [q, l, M ]. [q ' , l ' , M \n' ]to mean that the left-hand side closure reduces in one step to the right-hand side with probability \np . [0, 1]. De.nition 8. The reduction rules are shown in Table 3. The rules split into three categories: \n(a) rules handling the classical part of the calculus; (b) rules dealing with quantum data; and (c) congruence \nrules for the call-by-value strategy. Note that in the statement of the rules, V and W refer to values. \nIn the rules in Table 3(b), the quantum state q has size n. The quantum state q ' in the .rst rule is \nobtained by applying the k-ary unitary gate U to the qubits l(x1), . . . , l(xk). Precisely, ' q = (s \n. (U . id). s-1)(q), where s is the action on C2n of any permutation over {1, . . . , n}such that s(i)= \nl(xi)whenever i k. In the rules about measurements, we assume that if q0 and q1 are normalized quantum \nstates of the form L j aj |fj ). |0). |.j ), L j \u00dfj |fj ). |1). |.j ), (2) ' ' then q0 and q1 are respectively \nL j aj |fj ). |.j ), L j \u00dfj |fj ). |.j ), (3)  1B 1 [q, l, (.xA .M)V ]. [q, l, M{V/x}] [q, l, let x \nA .y = V .W in N]. [q, l, N{V/x, W/y}] 1A B 1 [q, l, skip;N]. [q, l, N] [q, l, match (inl V )with (x \n: M |y : N)]. [q, l, M{V/x}] 1A B 1 [q, l, split V ]. [q, l, V ] [q, l, match (inV )with (x : M |y : \nN)]. [q, l, N{V/y}] r 1 [q, l, letrec fA.B x = M in N]. [q, l, N{(.xA .letrec fA.B x = M in M)/f}] (a)Classical \ncontrol. 1 [q, l, U(x1 .\u00b7 \u00b7 \u00b7 .xk)]. [q ' , l, x1 .\u00b7 \u00b7 \u00b7 .xk] |\u00df|2 1' [q, \u00d8, new ff]. [q .|0), {y . \nn + 1}, y] [aq0 + \u00dfq1, {x . i}, meas x]--. [q1, \u00d8, tt] |a|2 1' [q, \u00d8, new tt]. [q .|1), {y . n + 1}, \ny] [aq0 + \u00dfq1, {x . i}, meas x]- -. [q0, \u00d8, ff] (b)Quantum data. The variable y is fresh. The decomposition \nof the quantum array in the case of meas x is explained in De.nition 8. ppp ' [q, l, MN]. [q ' , l ' \n, M ' N] [q, l, M .N]. [q ' , l ' , M .N] [q, l, inl M]. [q ' , l ' , inl M ' ] ppp [q, l, V M]. [q ' \n, l ' , V M ' ] [q, l, V .M]. [q ' , l ' , V .M ' ] [q, l, inM]. [q ' , l ' , inM ' ] r r pp ' B B ' \n[q, l, M;N]. [q ' , l ' , M ;N] [q, l, let x A .y = M in N]. [q ' , l ' , let x A .y = M in N] p A B \n' A B [q, l, match M with (x : P |y : N)]. [q ' , l ' , match M with (x : P |y : N)] p (c)Congruence \nrules, under the hypothesis that for some l0 we have l = l0 .l|M , l ' = l0 .l ' |M ' and [q, l|M , M].[q \n' , l ' |M ' , M ' ]. Table 3: Reduction rules on closures. where the vectors fj have dimension l(x)-1(so \nthat the measured qubit is l(x)). In summary, the quantum state acts as a sharedglobal store that is \nupdated destructivelyby the various quantum operations. Note that the only probabilistic reduction step \nis the one cor\u00adresponding to measurement. Also, we underline that the hypothe\u00ad p sis associated witha \ncongruence rule [q, l, C[M]].[q ' , l ' , C[M ' ]] takes into account the whole quantum states q and \nq ' . In fact, be\u00adcause of the entanglement, the evaluation of [q, l|M , M ]may have a side-effect on \nthe state of the qubits pointed to by the variables occurring in the context C[]. The rules assume that \nthe involved closures are well-de.ned. p In particular, whenever [q, l, M] . [q, l, M ' ], the two terms \nM and M ' have the same free variables. For example, the clo\u00adsure [|00), |yz), (.x.y)z]cannot reduce \nand it represents an error: it would reduce to the erroneous quantum closure [|00), |yz), z], where the \ndomain of the linkingfunction is not the set of free vari\u00adables, as speci.ed by De.nition 7. The type \nsystem will prevent such an error as proven in Proposition 12. 1 Example 9. Recall Example 5. We have \n[|), |), cointoss] . 1 [|1), |x), meas(Hx)] . [v1(|0)+ |1)), |x), meas x], the latter 2 reducing to either \n[|), |), tt]or [|), |), ff], with equal probability 1 2. As for entangle, we have that [a|0)+ \u00df|1), |x), \nentangle x] 1 . [a|0)+ \u00df|1), |x), Nc(x .(new ff))] . [a|00)+ \u00df|10), |xy), Nc(x .y)] . [a|00)+ \u00df|11), \n|xy), x .y].  1 1 Similarly, one can check that [a|0)+ \u00df|1), |q), qlist q]behaves as described in Section \n2.4, reducing to [a|0)+ \u00df|1), |q), q :: nil] 1 ' ' with probability , to [a|00)+ \u00df|11), |qq ), q :: q \n:: nil] with 2 probability 1 4, etc. In particular, notice that in any single reduc\u00adtion sequence the \nvariable q has not been duplicated, as correctly asserted by the type of qlist. Lemma 10 (Substitution). \nSuppose !., G, x : A . M : B and !., S . V : A, where G and S are linear contexts with disjoint domain. \nThen !., G, S . M{V /x}: B. p Proposition 11 (Subject reduction). When [q, |y1 . . . yn), M] . [q ' , \n|x1 . . . xn ' ), M ' ]and y1 : qubit, . . . , yn : qubit . M : A, then x1 : qubit, . . . , xn ' : qubit \n. M ' : A. Proposition 12 (Type safety). If[q, l, M]is typable then either M p is a value or there is \na closure [q ' , l ' , M ' ]such that [q, l, M ] . [q ' , l ' , M ' ]. Moreover, if M is not a value, \nthe total probability of all possible single-step reductions from [q, l, M]is 1. p Lemma 13 (Totality). \nIf [q, l, M ] . [q ' , l ' , M ' ]and [q, l, M ]is total, then [q ' , l ' , M ' ]is total too. p Proof. \nByinduction on a derivation of[q, l, M]. [q ' , l ' , M ' ], one proves that dim(q ' )= dim(q)+dim(l \n' )-dim(l)where dim(q) is the size ofthe quantum state q anddim(l)is the cardinalityofthe domain set \nof the linking function l. Then, one gets the statement, since [q, l, M ]is total iffdim(q)= dim(l). \nNotation 14. The reduction relation . de.nes the probability that a closure reduces to another one in \na single step. We extend this relation to an arbitrary large (but .nite)number of reduction steps with \nthe notation Redn ' ,l ' ,V ]: it is the total proba\u00ad [q,l,M],[q bility of [q, l, M ] reducing to a value \n[q ' , l ' , V ]. It is de.ned as p1pm the sum of all fm i=1 pi, where [q, l, M ] . [q1, l1, M1]\u00b7 \u00b7 \u00b7 \n. [q, l ' , V ]is a .nite reduction sequence of m n steps. We write Red8 ' ,l ' ,V ] for the sup over \nn of Redn ' ,l ' ,V ]. Fi\u00ad [q,l,M],[q [q,l,M],[q nally, we de.ne the total probability Halt[q,l,M] of \n[q, l, M ]con\u00advergingto any value as L Red8 . [q ' ,l ' ,V ].Val [q,l,M],[q ' ,l ' ,V ] 4. Denotationalsemantics \nWe interpret the quantum lambda calculus in a suitable extension CPMs . of the category CPM described \nin Section 2. What CPM to introduce it via the equation  8 E .k !A := A, (4) k=0 where E8 is the in.nite \nbiproduct of the family {A.k}k, each k=0 A.k being the symmetric k-fold tensor power of A, i.e., the \nequal\u00adizer of the k!symmetries of the k-ary tensor A.k := A .\u00b7 \u00b7 \u00b7 .A. The category CPM cannot express \nthis equation because it lacks both in.nite biproducts and a convenient de.nition of symmetric tensor \npowers. The category CPMs . is in some sense the minimal extension of CPM having these two missing ingredients. \nThe plan of the section is as follows. Section 4.1 presents some preliminary material. Section 4.2 de.nes \nCPMs . and Section 4.3 develops the categorical structure allowing us to interpret the quan\u00adtum lambda \ncalculus. Section 4.4 sketches the proof of the sound\u00adness of the model with respect to the operational \nsemantics. Finally, Section 4.5 discusses the denotations of the programs qlist and tele\u00adport. 4.1 Preliminaries: \nfrom CPM to CPMs Permutation groups. Let Sn be the symmetric group of degree n, i.e., the group of permutations \nof n = {0, . . . , n - 1}. Any . Cn\u00d7n permutation g . Sn gives rise to a matrix Pg , de.ned by Pg(ei)= \neg(i), where ei is the ith standard basis vector. We de.ne an action of g on Cn\u00d7n by g \u00b7 M := PgM P g \n-1. Moreover, for a subgroup G . Sn, we de.ne 1 L G \u00b7 M := g \u00b7 M, (5) #G g.G where #G is the number of \nelements of G. Lemma 15. Given a subgroup G . Sn, its action on Cn\u00d7n is idempotent (i.e., G \u00b7 G \u00b7 M = \nG \u00b7 M for all M)and completely positive. Proof. For the idempotence, notice that for every g . G, gG \n= G, therefore: G \u00b7 G \u00b7 M = 1 L gG \u00b7 M = G \u00b7 M. The complete #G g.G positivity of G is derived from the \ncomplete positivity of each map M . g \u00b7 M = PgM P g -1 . In the sequel, we use the notation G both for \na subgroup of Sn and for the completely positive map de.ned by it. The above Lemma allows us to de.ne \nthe set of completely positive maps from Cn\u00d7n to Cm\u00d7m invariant under the actions of two subgroups G \n. Sn, H . Sm by CPMs(G, H ):= {f . CPM(n, m)|G ;f ;H = f}, where f;g is the diagrammatic composition \n(f;g)(x)= g(f(x)), and CPM(n, m)is the set of completely positive maps from Cn\u00d7n to Cm\u00d7m . Completion \nof the L \u00a8owner positive cone. The set CPMs(G, H ) is a module over the semi-ring R+ of the non-negative \nreal num\u00adthe least upper bound VI exists in P , then VI . S. We say (P ) at in.nity . We call these \nthe elements of in.nite are c. A a that a monotone function between posets f : P . Q is Scott\u00ad if it \npreserves all least upper bounds of directed continuous existing A a subsets. Let G(P ) be the set of \nScott-closed subsets of P ; this forms a dcpo under the subset ordering. The D-completion c(P ) is de.ned \nto be the smallest sub-dcpo of G(P )containing all sets of the form .x. Then c(P ) is a dcpo, and there \nis a canonical injective Scott-continuous map . : P . c(P ), de.ned by .(x)= .x, which allows us to regard \nP as a subset of c(P ). The D\u00adcompletion preserves all existing least upper bounds of directed sets, \nis idempotent, and satis.es the following universal property: given any other dcpo E and Scott-continuous \nmap f : P . E, there exists a unique Scott-continuous g : c(P ) . E such that f = . ;g. It follows that \nthe D-completion is functorial. Moreover, if P is a bounded directed complete partial order, then P is \nan initial subset of c(P ), i.e., the only new elements added by the completion The homset CPMs(G, H \n)is then extended by D-completion, namely, CPMs(G, H ) := c(CPMs(G, H )). The categorical op\u00aderations \nare extended in the unique Scott-continuous way, using the universal property of D-completion. This allows \nus to de\u00ad.ne indexed sums over CPMs(G, H ), as follows. If {fi}i.I . CPMs(G, H ) is a (possibly in.nite) \nindexed family, L i.I fi is de.ned as V(L fi). Indeed, the set {L fi ; F ..n i.F i.F F .fin I I}is always \ndirected, so has a least upper bound in the order com\u00adpletion CPMs(G, H )of CPMs(G, H ). .  4.2 The \ncategory CPMs Given a set A and a, a ' . A, de.ne the Kronecker symbol da,a ' . N which takes value 1if \na = a ' and 0if a a ' = . Objects are given by indexed families A = {(dA a , GA a )}a.|A|, where the \nindex set |A|is called the web of A and, for every a . |A|, dA a is a natural non-negative integer, and \nGA a a subgroup of permutations of degree dA a , called respectively the dimension and the permutation \ngroup of Aa. Morphisms from A to B are matrices f indexed by |A|\u00d7 |B|and such that fa,b . CPMs(Ga A, \nGb B). Composition of f . CPMs . (A, B) and . . CPMs . (B, C) is the matrix f ; . de.ned by, for a . \n|A|and c . |C|, L (f ;.)a,c := b.|B|fa,b ;.b,c . Identity is the diagonal matrix built with the symmetries \nof A, i.e., for a, a ' . |A|, idA := da,a ' GA . a,a ' a The description of the objects and the morphisms \nas indexed families is crucial for inferring the structure of a compact closed Lafont category (Section \n4.3). However, it is worthwhile to notice that CPMs . can also be presented as a concrete category of \nmod\u00adules and linear maps between modules. Let us sketch such an alter\u00adnative presentation. Let A be an \nobject of CPMs . . We de.ne a module Pos(A) over R+ = . {8} as follows. For every a in |A|, let us write \nR+ Pos(a)for the cone of the positive matrices in GA a (Cd \u00d7d ), this bers. The L\u00a8owner order . on completely \npositive maps [18] en\u00ad dows this module with the structure of a bounded directed com\u00ad latter being the \nsubspace of the matrices in Cd A a \u00d7d A a invariant under plete partial order (bdcpo), i.e., there \nis a minimum element (the zero function 0), and any directed set D that is bounded (i.e., such that there \nexists f . CPMs(G, H )such that for all g . D, g . f) has a least upper bound VD . CPMs(G, H ). However \nthere exist unbounded directed subsets in CPMs(G, H ). We therefore need to complete CPMs(G, H )to a \ndcpo. The relevant construction is the D-completion of [24], which we brie.y recall. Given any poset \nP , say that a subset X is Scott\u00adclosed if it is down-closed and for every directed I . S, if GA a . \nThis positive cone Pos(a)is an R+-module. We then de.ne: E Pos(A):= (c(Pos(a))}). (6) a.|A| In fact, \nwe have that Pos(a) . CPMs(S1, Ga A)and Pos(A) . E CPMs(S1, GA a ). Hence, Pos(A)is a continuous module \na.|A| over R+: addition and scalar multiplication are de.ned pointwise and are continuous operations \nwith respect to the L\u00a8owner order.  continuous module homomorphism (in particular it is monotone), m \n= nff, a if n[]and b = the set {fn}is directedcomplete. We de.ne Y(f)as its leastupper n d if n[]and \nb = bound. m = [meas]!..qubit.bit (a \u00df = m ,(*,b) . d ). . .. .. tt, 0 otherwise. 4.3.1 Biproduct (A \n.B) nLetI be a (possiblyin.nite)setofindexes. The biproduct E Ai ) if n[]and b = i.I m = ff, . .. .. \n(a 0 0 0 . [new]!..bit.qubit m ,(b,*) (0 0 nof a family{Ai}i.I of objects in CPMs is de.ned by = a . \n0 a ) if n[]and b = m = tt,  E Ai Aj Ai Aj i.I 0 otherwise. i.I | Ai|:= {i}\u00d7|Ai|, d := d G := G a \n, . a(j,a) (j,a) i.I i.I n UMU-1 if n[], m = !..qubit.n .qubit.n [U] M . The corresponding projections \nand injections are denoted respec\u00ad = m ,(m*,m*) 0 otherwise. tivelybypj and .j and de.ned as: j j Ai \np:= .' G. (i,a),a ' a ' ,(i,a) := dj,ida,a a The tupling (fi)i.I morphisms fi elements of CPMs (resp. \n(co)-tupling [.i]i.I ) of a family of . (A, Bi)(resp. .i elements of Table 4: Interpretation ofthe quantum \nconstants. The writing m stands for m a sequence of multisets in |[!.]|, the equality m = []meaning that \neach \u00d72n of these multisets is empty. U and M have the same dimension C2n , U being unitary. Let f : \nPos(A). Pos(B)be a continuous module homomor\u00adphism. We saythat f is completelypositive ifallthe module \nhomo\u00admorphisms fa,b = .a ;f ;pb are completely positive maps, for all a . |A|and b . |B|. (Indeed, since \nthe positive matrices span the complex vector space of square matrices (of corresponding size), one can \ncanonically extend the de.nition of complete positivity to module homomorphisms Pos(a). Pos(b)). Proposition \n16. There is an isomorphism between the homset CPMs . (A, B)and the continuous module homomorphisms from \nPos(A)to Pos(B)that are completely positive. .  4.3 CPMs as a model of the quantum lambda calculus \nAcompact closedcategoryis a specialcase ofsymmetric monoidal closed category. A symmetric monoidal closed \ncategory with.nite products, such that each object has a corresponding free commuta\u00adtive comonoid, is \ncalled a Lafont category, which is known to be a model of intuitionistic linear logic [9, 15]. The category \nCPMs . can be endowed with such a structure, as we will show in Sec\u00adtions 4.3.1 4.3.4 below. We can therefore \ninterpret the quantum . lambda calculus in CPMs . The denotation [A] ofa type A is an object of CPMs \n. . In case A is the ground type (i.e., 1, qubit), its denotation is: !qubit1 !qubit1 |[qubit]|:= {.}, \nd. := 2, G. := {id}, !11 !11 |[1]|:= {.}, d. := 1, G. := {id}. The denotation of the other types is given \nby structural induction, followingthe compact closedLafont structure ofCPMs . . We note in particular \nthat the permutation groups play a role only when interpreting!-formulas. Let G = x1:A1, . . . , xn:An. \nThe denotation of a typing judge\u00adment G . M : A is a morphism [M]G.A : [A1 .\u00b7 \u00b7 \u00b7 .An] . [A]. The de.nition \nis by structural induction on the unique type derivation p ofG . M : A (see Proposition 4). The denotations \nof the constants meas, new and the unitary transformations are given in Table 4. Table 5 brie.yrecalls \nthe denotation of the usual linear CPMs . (Ai, B))is de.ned by ((fi)i.I )a,(j,b) := (fj )a,b (resp. ([.i]i.I \n)(j,a),b := (.j )a,b). Example 17. Recall that in Notation 3, the type bit is inter\u00adpreted as the biproduct \n[1] .[1], which is the two-element family {(1, {id})tt , (1, {id})ff }. The positive cones associatedwith1and \nbit are: Pos([1])= R+ and Pos([bit])= R+ 2 . The typing judgement . tt : bit is interpreted as the right \ninjection, which can be seen both as a family of two completely positive maps from C to C (i.e., [tt].bit \n= p . p and[tt].bit = .,tt .,ff p . 0)and as a quantum compatible and completely positive map sending \np . R+ to (0, p). R+ 2 . Symmetrically, [ff].bit is the mapp . (p, 0). As an example of a term with free \nvariables, consider Negx := if x then ff else tt. The denotation of x : bit . Negx : bit ]bit.bit can \nbe seen both as a family of four constant maps [Neg x b,b ' b ' from C to C of value 1 if b = and 0 otherwise, \nand as a single 2 2 mapfrom R+ to R+ sending (p, p ' )to (p ' , p). 4.3.2 Symmetric monoidal structure \n(A .B, 1 and Al) .. . The bifunctor . : CPMs \u00d7 CPMs . CPMs is de.ned on objects A, B by: A.B AB |A .B|:= \n|A|\u00d7|B|, d:= da \u00d7 db , (a,b) A.B AB G:= {(g, h); g . G,h . Gb }, (a,b) a where dA a \u00d7 dB b is the multiplication \nof the two numbers dA a and dB b , which can be seen as the lexicographically ordered set ofpairs dA \ndB (i, j), for i < a , j < b . Hence, the action of a permuta\u00adtion (g, h) . GA.B on dA a \u00d7 dB can be \ndescribed as (i, j) . (a,b) b (g(i), h(j)). The bifunctor .on morphisms is de.nedcomponentwise, using \nthe standardtensor ofthe categoryCPMextendedto the in.nite el\u00adements bythe universalpropertyofthe D-completion \n(Section 4.1). The tensor unit is the object [1] interpretingthe unit type. The associativity, unit, \nand symmetry isomorphisms are de\u00ad.ned componentwise from the corresponding isomorphisms in CPM, composed \nwith the actions of the groups of the objects. A a ,d B b A,B sd(a,b),(b ' ,a (a,b) ' ) := da,a ' db,b \n' GA.B ; logic rules. Here, the morphisms f, ., fA, fB refer to the denota-E.g., the symmetry is s, \ntion ofthe premises ofthe lastrule ofp, whichare uniquelyde.ned where sd A a ,d B b is the symmetry \nin CPM between Cd A a \u00d7d A a . given G . M : A. Cd B b \u00d7d B b and Cd B b \u00d7d B b . Cd A a \u00d7d A \na . Notice that it is suf.cientIn the interpretation of the letrec constructor, the .xed point operator \nY is de.ned as follows. Let f be a morphism in the set to pre-compose sd A a ,d B b with GA.B (a,b) \n(or, symmetrically, post- CPMs . (!C .!A, !A). Byinduction on n, we de.ne the morphism compose with \nGB.A), in order to have a map invariant under (b,a) . w;!0 c . !A, fn+1 fn . CPMs (!C, !A): f0 := !C \n-:= !C . both the permutation groups GA.B and GB.A . This is because -- (a,b) (b,a) id.fn f - --. !C \n. !A -. !A. Since f can be regarded as a ;sd A a ,d = GA a .GB b A aB b sd ,d !C . !C  w.id w.d \ndig m !f .(f) 1.A . A !. !..A 1.A . A !..!A  !!. !(!.) !A !..G A . B  (a)!., x : A . x : A (b)!., \nx : !A . x : A (c)!., . V : !A (d)!., G . .xA .M : A . B c.id f.. eval w c.id f.id . !.  1 !..G.S !..G.!..S \nA .A . B B  !..G.S !..G.!..S 1.!..S . !..S A (e)!., G, S . MN : B (f)!. . skip : 1 (g)!., G, S \n. M;N : A l c.id f.. c.id f.id . f . !..G.S !..G.!..S A .B !..G.S  !..G.!..S A .B .!..S C !..G \n A A .B B (h)!., G, S . M .N : A .B (i)!., G, S . let xA .y= M in N : C (j)!., G . inM : A .B l f \n.r c.id ..id distr fA.fB !..G B A .B !..G.S  !..G.!..S (A .B).!..S (A .!..S).(B .!..S) C (k)!., \nG . inr M : A .B (l)!., G, S . match M with (xA : N |yB : L): C c id.Y(dig;m;!(.f)) . f id.distr  !..G \n-- --------- - . !..G.!. . !..G.!(A . B) . C1.(A .Al)!..G 1.(E8 n=1 A.n)= Al (m)!., G . M : Al (n)!., \nG . letrec f x = M in N : C Table 5: Sketch of the interpretation of the typing judgements, using the \nLafont structure of CPMs . de.ned in Section 4.3. The morphisms f, ., fA, fB refer to the denotation \nof the premises of the unique derivation concluding a typing judgement. In (c)and (n), the morphism m \nstands for m1 or the suitable sequence of m ., depending on the context !!.. sdA ,dB GB.A L 1 a b A ; \n. Similar simpli.cations will be done henceforth (b,a) o(a,a ' ),. := (Ei,j .Ei ' ,j ' ). dg(i),g ' \n(i ' )dg(j),g ' (j ' ). #GA without explicitlymentioning it. a g,g ' .GA a Example 18. The denotation \nof qubit . qubit is the sin-Compact closed categories are monoidal closed. Let us recall gleton web family \n{(4, {id}).}. This object is associated with the monoidal closure structure, which is needed to model \nthe ab\u00adthe cone of positive matrices of dimension 4 \u00d7 4 plus the in-straction and the application of \nthe quantum lambda calculus. The .nite elements needed to complete the L\u00a8owner order. The de-internalhom \nobject is de.nedas A . B := (A. .B)= A .B. notation of bit . bit instead has a web of cardinality 4, \ni.e., The evaluation morphism EvalA,B : CPMs . ((A . B).A, B) {(ff, ff), (ff, tt), (tt, ff), (ff, ff)}, \nand, for each index b . . and the currying isomorphism .(-)from CPMs (C . A, B)to !bit.bit1 !bit.bit1 \n |[bit .bit]|, we have d= 1 and G= {id}. . b b CPMs (C, A . B)are, This object is associated withthe \nbiproduct R+ .R+ .R+ .R+ . A,B -1-1 Eval:= s;a;(o.id);., .(f):= .;(..id);a;(id.(s;f)), Notice that in \nthe above example the tensor product distributes where a, ., and s are the associative, left unit and \nsymmetric over the biproducts: [bit .bit] = [(1.1).(1.1)] = isomorphisms associated with.. [1.1.1.1]. \nThis is true in general: the isomorphism between A .(E Bi)and E (A .Bi)is i.I i.I Example 20. Let us \nconsider the abstraction .x.Negx of the term .bit.bit Negdiscussedin Example 17. The denotation [.x.Neg] \n A.Bi x x distr(a,(i,b)),(i ' ,(a ' ,b ' )) := di,i ' da,a ' db,b ' G(a,b) . ]x:bit.bit is obtained from \n[Negx just by shifting the matrix in\u00ad .bit.bit ]x:bit.bit dexes: [.x.Neg]= [Neg. Looking at this This \nisomorphism allows us to de.ne the list constructor as the x .,(b,b ' ) x b,b ' E8 A.n .bit.bit in.nite \nbiproduct of tensor powers Al := . In fact, we matrix as a module homomorphism, the map [.x.Neg] n=0 \nx have Al . 1.(A .Al). is p . (0, p, p, 0), which is a map from R+ to R+ (ff,ff) . R+ (ff,tt) . R+ (tt,ff) \n. R+ (tt,tt), where we make explicit the Example 19. The denotation of the unit type list is: |[1l]|= \nN correspondence between the web elements of [bit . bit] and !1l1 !1l1 and, for every n . N, dn = 1, \nGn = {id}. This object the components ofthe biproduct associated with. can be associated with the module \nR+ N and is suitable for de-Application corresponds basically to matrix multiplication. For )(meas y)]y:qubit.bit \n noting the numerals in unary notation. Indeed, writing n for the example, [(.x.Negis the function de.ned \nx .,b .1 ].bit.bit[meas y]y:qubit.bit list skip :: . . . skip :: nil of length n, we have [n]l = p . \nas L b ' .{tt,ff}[.x.Negx .,(b ' ,b) .,b ' , which is (0, . . . , 0, p, 0, . . . ). sending (a \u00df )to \nd if b = ff, a ifb = tt, and 0otherwise. . . d n-1 times  4.3.4 Free commutative comonoids (A.k , \n!A) 4.3.3 Compact closure (A. , A . B) Let us now focus on the crucial structure modeling the linear \nlogic modality!. We .rstde.ne the notion ofk-thsymmetric power ofan Dual objects coincide: we have A. \n:= A. The unit .A . . . object and then we show how the biproduct of all such symmetric CPMs (1, A. \n. A)and co-unit oA . CPMs (A . A. , 1)are powers yields an exponential structure. de.ned componentwise \ncomposing the unit and co-unit of CPM with the correspondent permutation group. Writing Ei,j for the \nNotation 21. Given a set X, a multiset \u00b5 over X is a function matrix that has 0everywhere except 1at \n(i, j), we have: X . N. The support of \u00b5 is the set |\u00b5|= {a |\u00b5(a) = 0}. X, the disjoint union is (\u00b5 . \n.)(a) = \u00b5(a)+ .(a), and the .A L GA empty multiset is the zero constant function. The cardinality of \n\u00b5 .,(a,a ' ) := 1 . a (Ei,j ).Ga A(Ei,j ) is L \u00b5(a) . N . {8}. A multiset is .nite if it has .nite i,j<dA \na.X cardinality. Mk(X) (resp. Mf (X)) is the set of the multisets over X with cardinality k (resp. .nite). \nFinite multisets can be denoted by listing the occurrences of their elements between square brackets, \ni.e., \u00b5 = [a, a, b]is \u00b5(a)= 2, \u00b5(b)= 1 and zero on the other elements, and [ ] is the empty multiset. \nIn a symmetric monoidal category, given a natural number k, the k-th symmetric power of an object A is \na pair (A.k , eq A.k )of an object A.k and a morphism eq A.k from A.k to A.k, which is an equalizer of \nthe k! symmetries of the k-ary tensor A.k. Such equalizers do not exist in general, but they do exist \nin CPMs . and can be concretely represented using the multisets notation, as follows: .k dA.k I )\u00b5(a) \n|A|:= Mk(|A|), := (dA , \u00b5 a a.|\u00b5| A.k 1 \u00b5(a) i A G\u00b5 := {(ha, g a, . . . , ga )a.|\u00b5|; ha . S\u00b5(a), g a \n. Ga }, where (ha, g a1 , . . . , ga \u00b5(a))a.|\u00b5| is a |\u00b5|-indexed family of se\u00adGA.k quences of permutations \nand is a group (composition being \u00b5 .k .k \u00b5 \u00b5 de.ned componentwise) whose action on CdA\u00d7dAcan be de\u00ad \nscribed by seeing dA.k as the set of families of sequences of the \u00b5(a))\u00b5 a.|\u00b5|, with ij < dA form (i1 \na, . . . , ia a a for every j \u00b5(a). Then, 1 \u00b5(a) the action of (ha, g a, . . . , ga )a.|\u00b5|on such families \nis: 1 1 ha(1) \u00b5(a) ha(\u00b5(a)) (ia, . . . , i\u00b5a (a))a.|\u00b5|. (ga(ia ), . . . , ga (ia ))a.|\u00b5|. A.k The morphism \neq is given by GA.k A.k \u00b5 if \u00b5 = [a1, . . . , ak], eq \u00b5,(a1 ,...,ak) := 0 otherwise. Remark 22. The object \n[A].k describes k unordered uses of an element of type A. The fact that our model uses the symmetric \ntensor power A.k instead of the k-fold tensor A.k means opera\u00adtionally that the behavior of a program \ncalling its input k times does not depend on the order of the calls. Example 23. In Example 18, we have \nseen that [qubit].2 = {(4, {id}).}. The symmetric 2-power [qubit].2 is instead the singleton web family \n{(4, {id, s}).}, where 4 is represented as the lexicographically ordered set {(0, 0), (0, 1), (1, 0), \n(1, 1)}and the permutation s acts on it by (b, b ' ) . (b ' , b). The group of permutations {id, s}shrinks \nthe set of possible morphisms to or from [qubit].2. For example, the matrix Nc associated with the controlled-not \ngate (Equation (1)) de.nes a complete positive endo\u00admap of C4\u00d74, which is an endo-morphism of [qubit].2 \nbut not of [qubit].2, because Nc is not invariant under the action of {id, s}: (2 0 0 0 ) 1 1 0 1 0 1 \n{id, s}(Nc)= (id(Nc) + s(Nc)) = = Nc. 0 0 1 1 2 2 0 1 1 0 Concerning the module associated with symmetric \ntensor powers, Pos([qubit].2)is the D-completion of ( a1 a2 a2 a3 ) a4 a5 a6 a7 a4 a6 a5 a7 positive \n; .i, ai . C a8 a9 a9 a10 which is a subcone of the positive cone of C4\u00d74 of dimension 10. Concerning \nbiproducts, the denotation of qubit . qubit is given by {(2, {id})tt , (2, {id})ff }, while its symmetric \ntensor power [qubit .qubit].2 is given by the three-element family {(4, {id, s})[tt,tt], (4, {id})[tt,ff], \n(4, {id, s})[ff,ff]}. Notice the difference between the pair (4, {id})associated with [tt, ff]and the \npair (4, {id, s})associated with the two multisets of singleton support. E8 A.k The biproduct !A := k=0 \nof all symmetric powers of A can be de.ned as A.k A.k !A !A |!A|= Mf (|A|), d\u00b5 = d\u00b5 , G\u00b5 = G\u00b5 (\u00b5 . Mk(|A|)) \nThis object yields a concrete representation of the free commutative comonoid generated by A. The counit \n(also called weakening) w . CPMs . (!A, 1)and the comultiplication (or contraction)c . CPMs . (!A, !A \n.!A)are: !A !A w\u00b5,. := d\u00b5,[ ]G[] , c\u00b5,(\u00b5 ' ,\u00b5 '' ) := d\u00b5,\u00b5 ' +\u00b5 '' G\u00b5 . The freeness of the comonoid \ngives the structure of exponential comonad. The functorial promotion maps an object A to !A and a morphism \nf . CPMs . (A, B)to !f . CPMs . (!A, !B)de.ned by, for \u00b5 . Mf (|A|)and . = [b1, . . . , bk]. Mf (|B|), \nk L !A !B !f\u00b5,. := G\u00b5 ; fai,bi ;G. . (a1 ,...,ak), st i=1 [a1 ,...,ak]=\u00b5 The counit of the comonad (or \ndereliction) d . CPMs . (!A, A) and the comultiplication (or digging)dig . CPMs . (!A, !!A)are A L!A \nd\u00b5,a := d\u00b5,[a]Ga , dig\u00b5,M := d\u00b5,M G\u00b5 , where M . |!!A|is a multiset of multisets . over |A|and LM . |!A|is \nthe multiset union of such . s, i.e., for every a . |A|, L LM(a)= ..|M|.(a)M(.) . Finally, the last two \nmorphisms that are essential to interpret our calculus are Bierman s m . . CPMs . (!A . !B, !(A . B)) \n1 . . !(A.B) and m . CPMs (1, !1), given by m := d.,\u00b5\u00d7. G. (\u00b5,.),. and m.,\u00b5 := d\u00b5,[.]G1 1 \u00b5, where \u00b5 \n\u00d7 . is the multiset in |!(A .B)|de.ned by, \u00b5 \u00d7 .(a, b):= \u00b5(a).(b). Example 24. Using the isomorphism \nbetween Mf ({.})and the set N, and between Mf ({tt, ff}) and N \u00d7 N, the free com\u00admutative comonoids associated \nwith [1] and [bit] are ![1] = {(1, {id})n}n.N, and ![bit] = {(1, {id})(n,m)}n,m.N . In gen\u00aderal, notice \nthat all constructions of the Lafont category pre\u00adserve the underlying pair (1, {id}) and act only at \nthe level of webs. For more involved examples, one should look for objects with larger dimension, like \n[qubit]. For example, ![qubit] = {(2n, Sn)n}n.N. Notice that !1, !bit and !qubit are not allowed by our \ntype grammar. In fact, !qubit is meaningless because of the no-cloning constraint on quantum bits. However, \nsuch spaces should exist in the model since they are isomorphic to the denota\u00adtions of legal types, like \n!(1 . 1), !(1 . bit)and !(1 . qubit).  4.4 The soundness theorem The soundness of CPMs . with respect \nto the operational semantics given in Figure 3 is an easy consequence of the fact that the category gives \na (dcpo-enriched) model of linear logic. In fact, the operational semantics is a trivial extension of \na head-reduction strategy of linear logic cut-elimination. . Proposition 25. The category CPMs is a dcpo-enriched \ncompact . closed Lafont category, hence CPMs is a model of linear logic. Proof (Sketch). This basically \namounts to showing that CPMs . is the result of a categorical construction applied to CPMs which is known \nto give, under certain circumstances, a dcpo-enriched Lafont category and to preserve the compact closed \nstructure of CPMs. This construction was sketched in [5]and detailed in [11, 12, 16]. It consists in \nmoving: (i) from CPMs to a category CPMs with symmetric tensors, which is actually a full sub-category \nof the Karoubi envelope of CPMs; (ii) to a dcpo-enriched category  CPMs using the D-completion de.ned \nin [7, 24];and, .nally, (iii) constructing the free biproduct completion CPMs . of CPMs and applying \nEquation (4). Given a linking l = |y1, . . . , ym), we write l . M : A for the judgement y1 : qubit, \n. . . , ym : qubit . M : A. Proposition 26 (Invariance of the interpretation). Let l be the linking |y1, \n. . . , ym), and assume l . M : A. If M is not a value, C2m then for all quantum states q . , row, i.e., \na choice of two left-sided booleans, amounts to choosing the two booleans that will be passed to the \nfunction g. Picking a column, i.e., a choice of two right-sided booleans, amounts to decidingon the probabilistic \nresult we get from the function f. The intersection of a column and a row is therefore the representation \nofa mapqubit . qubit. This mapis a description ofa possible path in the control .ow of the algorithm. \nThe matrices on the diagonal correspond to a run of the algo\u00adrithm as it was intended: applying g to \nthe result of f. Since they are supposed to be the identity on qubit, we can therefore de- L l ' .A ' \n'* l.A * [M] (qq )= p \u00b7 [N](q q ). (7) duce that the matrices A00,00, A01,01, A10,10 and A11,11 are all \n(1 0 0 1 0 0 0 0 equalto 0 0 0 0 1 0 0 1 sor of two 2 \u00d7 2 matrices, we conclude that the denotation A \nof ) . Since this matrix cannot be written as the ten\u00ad p ' [q,l,M].[q ,l ' ,N] Proof. By hypothesis, \n[q, l, M]is a typable total closure, and so, by Proposition 11 and Lemma 13, all of its reducts [q ' \n, l ' , N]are l ' .A ' '* typable totalclosures, so that [N](q q )is well-de.ned. Equation 7 is proven \nby cases, depending on the rule applied to [q, l, M ]. The cases of Table 3(a) follows from the fact \nthat CPMs . is a dcpo-enriched model of linear logic. The quantum rules (Table 3(b)) are trivial consequences \nof Table 4, and the congruence rules of Table 3(c)are done by induction on M, using the fact that the \ncategoryCPMs . is linear. Corollary 27. We have [M].1 ? Halt[|.,|.,M]. * Proof. Byinduction on n andusingProposition \n7we can show that l.1 * [M]* (qq ) is greater or equal to L [q ' ,l ' ,V ]Redn [l,q,M],[q ' ,l ' ,V ]. \nThen [M]l.1(qq * ) ? Halt[q,l,M] follows by taking the limit as * n . 8,and invoking the monotonicity \nof {Redn}n.  4.5 The denotations of qlist and teleport Example 28. Recallthe terms ofExample 5. The \nwebof[qubitl] is N, while [qubitl]=(2n , {id}). Note that Pos([qubitl]) is n equivalent to the D-completion \nof E n P (C2n\u00d72n )where the set P (C2n\u00d72n )is the cone of 2n \u00d7 2n positive matrices. The denota\u00adtion \nof the term qlist is a morphism in CPMs . (qubit, qubitl), thatis, a mapsendinga 2\u00d72positive matrix onto \nE n P (C2n\u00d72n ). The program qlist is de.ned using recursion: its semantics is the limit of the morphisms \nfn sending (a b )to the in.nite sequence c d (0, 2 1 e1, . . ., 21 n en, 0, 0, . . .)where ei is the \n2i\u00d72i positive matrix (teleportskip)is indeed entangled. We can compute the other matrices Axy,zt using \nthe same argument: in general, Axy,zt is a composition of f and g, except that instead of applying g \nto (x, y), we apply it to (z, t). We therefore get a function qubit . qubit constructed out of the U-- \nthat might (if xy = zt) or might not be the identity. In general, the matrix Axy,zt is the denotation \nof the unitaryUztU * . xy The denotation A is given in full detailin Table 6. Remark30. Example 29is \na good illustration ofwhat we claimed in the introduction: the model re.ects the juxtaposition of quan\u00adtum \nand classical structures, even at higher-order types. Here, the control-.ow is handledbythe biproduct \nstructure, andthe quantum part of the algorithm is split across the list of 4\u00d74matrices. 5. Adequacy \nIn the following, we prove the adequacy ofCPMs . (Theorem 38). This amounts to achieving the converse \ninequalityof Corollary27. The proof uses a syntactic approach, following[6]. We introduce a bounded letrecn \n, which can be unfolded at most n times. On the one hand, the language allowing only bounded letrec is \nstrongly normalizing (Lemma 33), hence the adequacy for it can be easily achieved by induction on the \nlongest reduction sequence of a term (Corollary 34). On the other hand, the unbounded letrec can be expressed \nas the supremum of its bounded approximants, both semantically (Lemma 36)and syntactically (Lemma 37). \nWe then conclude the adequacy for the whole quantum lambda calculus by continuity. .. a 0 \u00b7 \u00b7 \u00b7 0 b De.nition \n31. Let us extend the grammar of terms (Table 1) by 0 0 \u00b7 \u00b7 \u00b7 0 0 .. .. . .. . .. . .. .. 0 0 \u00b7 \u00b7 \u00b7 0 \n0 ..... ..... adding: (i) a new term OA; (ii) a family of new term constructs. n fA.B letrecx = M in \nN indexed bynaturalnumbers n ? 0. c 0 \u00b7 \u00b7 \u00b7 0 d This limit is the map sending (a b )to the sequence of \nin.nitely c d increasing matrices (0, 1 2e1, . . . , 21 n en, . . .). Note that the .rst el\u00adement of \nthe sequence is 0, as the program qlist never return the empty list. Also note that all the positive \nmatrices in the sequence represent entangled states of arbitrary sizes. Our semantics is the .rst one \nto be able to account for such a case: in [6], only .xed sizes were allowed for entangled states. Example \n29. We claim in the introduction that the model is ex\u00adpressive enough to describe entanglement at higher-order \ntypes. As we discuss in Example 6, the encoding of the quantum teleporta\u00adtion algorithm produces two \nentangled, mutuallyinverse functions: f : qubit . bit .bit and g : bit .bit . qubit. The term (teleportskip)of \ntype (qubit . bit . bit). (bit .bit . qubit)is one instance of such a pair of functions. Its denotation \nis a .nite sequence of 16 square matrices of size 4\u00d74. Usinga lexicographic convention, we can laythem \nout as in Fig. 6. Because of the convention, morally each row corresponds to an element of type bit .bit \n. qubit whereas each column corresponds to an element of type qubit . bit .bit. Pickinga The typing rules \nfor these new constructs are !., f : !(A . B), x : A . M : B !., G, f : !(A . B). N : C n fA.B !. . OA \n: A !., G . letrecx = M in N : C Their denotations are given, respectively, by the map 0 and the familyof \nmaps c id.(dig;m;!(.f))n . !..G -- --------- . !..G.!. . !..G.!(A . B) . C, where f . CPMs . (!. . !(A \n. B) . A, B) and . . CPMs . (!. . G . !(A . B), C) are the denotations of the premises and (dig;m;!(.f))n \n. CPMs . (!., !(A . B))is de\u00ad.ned in a similar fashion as in Table 5. The reduction rules are updated \nas follows. 0 fA.B 1 [q, l, letrecx = M in N]-.OB )/f}] . [q, l, N{(.xA n+1 fA.B [q, l, letrecx = M in \nN ] 1 -.letrecn fA.B M in M )/f}]. . [q, l, N{(.xA x =  ( (1 0 0 1 )(0 0 0 0 )(1 0 0 -1 )(0 0 0 0 )1 \n0 0 0 0 0 1 1 0 0 0 0 0 0 1 -1 0 A = A00,00 = , A00,01 = , A00,10 = , A00,11 = , 4 0 0 0 0 0 1 1 0 0 \n0 0 0 0 -1 1 0 1 0 0 1 0 0 0 0 -1 0 0 1 0 0 0 0 (0 0 0 0 )(1 0 0 1 )(0 0 0 0 )(1 0 0 -1 )0 1 1 0 0 0 \n0 0 0 1 -1 0 0 0 0 0 A01,00 = , A01,01 = , A01,10 = , A01,11 = , 0 1 1 0 0 0 0 0 0 -1 1 0 0 0 0 0 0 0 \n0 0 1 0 0 1 0 0 0 0 -1 0 0 1 (1 0 0 -1 )(0 0 0 0 )(1 0 0 1 )(0 0 0 0 )0 0 0 0 0 1 -1 0 0 0 0 0 0 1 1 \n0 A10,00 = , A10,01 = , A10,10 = , A10,11 = , 0 0 0 0 0 -1 1 0 0 0 0 0 0 1 1 0 -1 0 0 1 0 0 0 0 1 0 0 \n1 0 0 0 0 (0 0 0 0 )(1 0 0 -1 )(0 0 0 0 )(1 0 0 1 ) ) 0 1 -1 0 0 0 0 0 0 1 1 0 0 0 0 0 A11,00 = , A11,01 \n= , A11,10 = , A11,11 = . 0 -1 1 0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 0 -1 0 0 1 0 0 0 0 1 0 0 1 Table 6: \nThe denotation of the quantum teleportation algorithm. The additions to the language do not modify the \nproperties of the language: subject reduction (Proposition 11) and totality (Lemma 13) hold as they are \nstated, while type safety (Proposi\u00adtion 12)and soundness (Proposition 26)are satis.ed, with the pro\u00adviso \nof considering the set of normal forms to consist of the set of values and the set of terms containing \nOin evaluating position. De.nition 32. A term is called .nitary when it does not contain any occurrence \nof the un-indexed letrec construct. It can however contain O and any of the indexed letrecn . We call \na closure .nitary when its term is .nitary. Lemma 33 (Strong normalization). If [q1, l1, M1]is .nitary \nand p1 typable, then every reduction sequence of the form [q1, l1, M1]-. p2p3 [q2, l2, M2]-. [q3, l3, \nM3]-. \u00b7 \u00b7 \u00b7 is .nite. Proof (Sketch). We reduce the .nitary quantum lambda calculus to a simply typed \nnon-deterministic language without quantum states, for which a standard proof technique can be used. \nThe terms of this language are the terms of the extended quantum lambda calculus, minus the letrec construct. \nThe operational semantics is obtained from Table 3 and the rules for letrecn by replacing closures with \nthe respective terms and the rules of Table 3b by dummy reduction rules: like U( .\u00b7 \u00b7 \u00b7 . ). .\u00b7 \u00b7 \u00b7 . \n, or new ff . . The symbol denotes a distinct term variable, which, by convention, it is never bound \nby an abstraction. Clearly, the strong normalization of this language implies that of the .nitary quantum \nlambda calculus. Corollary 34 (Finitary adequacy). Let M be a closed .nitary term of unit type. Then \n[M].1 = Halt[|.,|.,M ]. * Proof (Sketch). We prove that, for any total .nitary quantum clo\u00adsure of unit \ntype [q, l, M ]we have [M]l.1(qq * ) = Halt[q,l,M ]. In fact, by Lemma 33, there exists m . N such that \nHalt[q,l,M ] = L Redm ' l ' V ]. We conclude by induction on m. [q ' ,l ' ,V ] [q,l,M],[q,, De.nition \n35. Let . be a relation between .nitary terms and general terms de.ned as the smallest congruence relation \non terms satisfying, for every M . M ' and N . N ' : A B ' ' N{(.x.O)/f }. (letrec f x = M in N ), n \n' ' (letrec f x = M in N). (letrec f x = M in N ). G.A ' G.A Lemma 36. If G . M : A, then [M]= V M ' \n.M [M ]. ' M .nitary ' Lemma 37. If M . M , then Halt[q,l,M ] Halt[q,l,M ' ]. Proof (Sketch). By induction \non n, one proves the inequality: L L Redn Redn [q ' ,l ' ,V ] [q,l,M ],[q ' ,l ' ,V ] [q ' ,l ' ,V ] \n[q,l,M ' ],[q ' ,l ' ,V ], from which the statement follows trivially. Theorem 38. Let M be a program, \ni.e., a closed term of unit type. Then [M].1 = Halt[|.,|.,M ]. * Proof. By Corollary 27 we have [M].1 \n? Halt[|.,|.,M ]. Con\u00ad .1 ' .1versely, by Lemma 36, [M]= V * [M ], which is equal * M ' .M * V to Halt[|.,|.,M \n' ] by Corollary 34, which is less or equal to M ' .M Halt[|.,|.,M ] by Lemma 37. 6. Structure of the \nsets of representable elements We conclude this paper with an analysis of some of the properties of the \ndenotation of terms. Recall that a morphism in CPMs . is an indexed family of either completely positive \nmaps, or in.nite elements added during D-completion. We show that (1) all types have a non-zero inhabitant; \n(2) provided that the term constant U ranges over arbitrary unitary matrices, the representable elements \nof a given homset form a convex set including 0; and (3) in.nite elements are not part of any representable \nmap. We .rst need two auxiliary de.nitions. De.nition 39. We de.ne two type-indexed families of terms \n.A and .A by mutual induction in Table 7. The term c represents the fair coin toss meas (H (new ff)) \n(recall Example 1) and the notation \u00b5f x.M stands for letrec f x = M in f . Lemma 40. For all types A, \nwe have . .A : 1 . A and . .A : .1.A .A.1 A . 1. Moreover, the morphisms [.A]and [.A], seen as indexed \nfamilies, do not contain the zero map. Corollary 41. All types are inhabited by at least one closed value \nof non-null denotation. Proof. Immediate with Lemma 40: for a given type A, choose the term (.A skip). \nProposition 42. Given a type A and a context G, the denotations [M]G.A of valid typing judgements G . \nM : A form a convex set including 0. Proof. Suppose that G is x1 : A1, . . . , xn : An. A term M mapping \nto 0 is (.A1 x1;. . . ;.An xn;O)where the term O is a shortcut for letrec f x = f x in f skip, of denotation \n0. Now, suppose that f = [M1]G.A and g = [M2]G.A, and choose two non-negative real numbers .1, .2 such \nthat .1 + .2 = 1. There exists an angle f such that (cos f)2 = .1 and that (sin f)2 = .2. As the term \nconstants U range over cos f -sin f arbitrary unitaries, the unitary matrix Vf = () is sin f cos f representable \nin the quantum lambda calculus. The term c ' = meas (Vf (new ff)) has denotation (.1, .2). We then conclude \nthat the term if c ' then M1 else M2 has denotation .1f + .2g. Proposition 43. If G . M : A is valid, \nthen no in.nite element is part of the denotation [M]G.A of M. Proof. Suppose that one of the in.nite \nelements of the D-comple\u00adtion were to be found in the interpretation of x1 : A1, . . . , xn :  .xqubit \n .qubit = .skip.new ff .qubit = .if meas x then skip else skip .A.B = .skip..xA .(.A x);(.B skip) .A.B \n= .f A.B ..B (f (.A skip)) .!(A.B) = .skip..xA .(.A.B skip)x .!(A.B) = \u00b5gf !(A.B) .if c then skip else \n(.A.B f); (g f ) .1 = .skip.skip .1 = .skip.skip .A.B = .skip.(.A skip).(.B skip) .A.B = .xA.B .let z1 \n.z2 = x in (.A z1);(.B z2) .A.B = .skip.if c then (.A skip)else (.B skip) .A.B = .xA.B .match x with \n(z1 A : .A z1 |z2 B : .B z2) .Al = \u00b5f skip.if c then (skip)else (.A skip) :: (f skip) .Al = \u00b5f xAl .match \nsplit x with 1 A.Al (z1 : z1 z2 : let y1 .y2 = z2 in (.A y1);(f y2)) Table 7: Two mutually recursive \nfamilies of terms An . M : A. Then the closed term (.x1 . . . xn..A M)(.A1 skip). . . (.An skip) of type \n1has in.nite denotation, contradicting Theorem 38. This last proposition indicates that in.nite elements \nintroduced during the D-completion are really an artifact only needed for the categorical construction. \nThe representable elements in the model are only built out of families of completely positive maps. 7. \nConclusion We presented a higher-order lambda calculus for quantum compu\u00adtation featuring classical and \nquantum data, duplication, recursion, and an in.nite parametric type for lists. We then answered a long\u00adstanding \nopen question: the description of a model for the full quan\u00adtum lambda calculus. The model we propose \nis a free construction based on the known model of completely positive maps, but never\u00adtheless has a \nconcrete presentation. One thing that this model explains and illustrates is the distinc\u00adtion between \nthe quantum and classical parts of the language. The quantum part is described by completely positive \nmaps (.nite di\u00admension), whereas the classical control is given by the Lafont cate\u00adgory (i.e., linear \nlogic). The model demonstrates that the two uni\u00adverses work well together, but also surprisingly that \nthey do not mix too much, even at higher order types (we always have an in.nite list of .nite dimensional \nCPMs). The control .ow is com\u00adpletely handled by the biproduct completion, and not by the CPM structure. \nThe adequacy result, moreover, validates that the model is a good representation of the language. One \nshould also note that the product and the coproduct co\u00adincide in our model. For example, the model has \nmorphisms that correspond to a program returning true with probability 1and false with probability 1. \nWe would like to point out that our interpreta\u00adtion is not surjective. For example, there are also morphisms \nin the model corresponding to probability 2 . (Incidentally, adding terms with such behavior makes it \npossible to build a term whose denota\u00adtion is 8 so the fact that this provably does not happen somehow \ncaptures the sanity of the model). Interpretations in denotational models are often not surjective. In \nfact, it is an open problem to give a non-syntactic characterization of the image of our interpre\u00adtation. \nSimilarly, the problem of full-abstraction is still open. References [1] V. Danos and T. Ehrhard. Probabilistic \ncoherence spaces as a model of higher-order probabilistic computation. Inform. Comput., 2011. [2] T. \nEhrhard. Finiteness spaces. MSCS, 15(4):615 646, 2005. [3] J.-Y. Girard. Linear logic. Th. Comp. Sc., \n50:1 102, 1987. [4] J.-Y. Girard. Normal functors, power series and lambda-calculus. Ann. Pure Appl. \nLogic, 37(2):129 177, 1988. [5] J.-Y. Girard. Coherent Banach spaces: a continuous denotational semantics. \nTheoretical Computer Science, 227:297, 1999. [6] I. Hasuo and N. Hoshino. Semantics of higher-order quantum \ncom\u00adputation via geometry of interaction. In Proceedings of LICS, pages 237 246, 2011. [7] K. Keimel \nand J. D. Lawson. D-completions and the d-topology. Annals of Pure and Applied Logic, 159(3):292 306, \n2009. [8] E. H. Knill. Conventions for quantum pseudocode. Technical Report LAUR-96-2724, Los Alamos \nNational Laboratory, 1996. [9] Y. Lafont. Logiques, cat\u00b4egories et machines. PhD thesis, Universit\u00b4e \nParis 7, 1988. [10] U. D. Lago, A. Masini, and M. Zorzi. Con.uence results for a quantum lambda calculus \nwith measurements. Electr. Notes Theor. Comput. Sci., 270(2):251 261, 2011. [11] J. Laird, G. Manzonetto, \nand G. McCusker. Constructing differential categories and deconstructing categories of games. Information \nand Computation, 222:247 264, 2013. [12] J. Laird, G. McCusker, G. Manzonetto, and M. Pagani. Weighted \nrelational models of typed lambda-calculi. In LICS 13, 2013. [13] S. Mac Lane. Categories for the Working \nMathematician. Springer, 2nd edition, Sept. 1998. [14] O. Malherbe. Categorical models of computation: \npartially traced categories and presheaf models of quantum computation. PhD thesis, University of Ottawa, \n2010. [15] P.-A. Melli`es. Categorical semantics of linear logic. Panoramas et Synth`eses, 12, 2009. \n[16] P.-A. Melli`es, N. Tabareau, and C. Tasson. An explicit formula for the free exponential modality \nof linear logic. In ICALP 09 (2), pages 247 260, 2009. [17] M. A. Nielsen and I. L. Chuang. Quantum Computation \nand Quantum Information. Cambridge University Press, 2002. [18] P. Selinger. Towards a quantum programming \nlanguage. Mathematical Structures in Computer Science, 14(4):527 586, 2004. [19] P. Selinger. Towards \na semantics for higher-order quantum computa\u00adtion. In QPL 04, TUCS Gen. Publi. No 33, pages 127 143, \n2004. [20] P. Selinger and B. Valiron. A lambda calculus for quantum compu\u00adtation with classical control. \nMathematical Structures in Computer Science, 16(3):527 552, 2006. [21] P. Selinger and B. Valiron. On \na fully abstract model for a quantum linear functional language. In QPL 06, 2008. [22] P. Selinger and \nB. Valiron. Quantum lambda calculus. In S. Gay and I. Mackie, editors, Semantic Techniques in Quantum \nComputation, chapter 9, pages 135 172. Cambridge University Press, 2009. [23] B. Valiron. Semantics for \na higher-order functional programming lan\u00adguage for quantum computation. PhD thesis, Univ. of Ottawa, \n2008. [24] D. Zhao and T. Fan. Dcpo-completion of posets. Th. Comp. Sc., 411 (22 24):2167 2173, 2010. \n   \n\t\t\t", "proc_id": "2535838", "abstract": "<p>Finding a denotational semantics for higher order quantum computation is a long-standing problem in the semantics of quantum programming languages. Most past approaches to this problem fell short in one way or another, either limiting the language to an unusably small finitary fragment, or giving up important features of quantum physics such as entanglement. In this paper, we propose a denotational semantics for a quantum lambda calculus with recursion and an infinite data type, using constructions from quantitative semantics of linear logic.</p>", "authors": [{"name": "Michele Pagani", "author_profile_id": "81447594194", "affiliation": "Universit&#233; Paris 13, Sorbonne Paris Cit&#233;, Villetaneuse, France", "person_id": "P4383923", "email_address": "michele.pagani@lipn.univ-paris13.fr", "orcid_id": ""}, {"name": "Peter Selinger", "author_profile_id": "81100088668", "affiliation": "Dalhousie University, Halifax, Canada", "person_id": "P4383924", "email_address": "selinger@mathstat.dal.ca", "orcid_id": ""}, {"name": "Beno&#238;t Valiron", "author_profile_id": "81430646806", "affiliation": "University of Pennsylvania, Philadelphia, USA", "person_id": "P4383925", "email_address": "benoit.valiron@monoidal.net", "orcid_id": ""}], "doi_number": "10.1145/2535838.2535879", "year": "2014", "article_id": "2535879", "conference": "POPL", "title": "Applying quantitative semantics to higher-order quantum computing", "url": "http://dl.acm.org/citation.cfm?id=2535879"}