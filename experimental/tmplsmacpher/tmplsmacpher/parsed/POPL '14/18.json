{"article_publication_date": "01-08-2014", "fulltext": "\n A Constraint-Based Approach to Solving Games on In.nite Graphs Tewodros A. Beyene Swarat Chaudhuri \nCorneliu Popeea Technische Universtit\u00a8unchen Technische Universtit\u00a8unchenat M \u00a8Rice University at M \u00a8 \nAndrey Rybalchenko Microsoft Research Cambridge and Technische Universtit\u00a8at M \u00a8unchen Abstract We present \na constraint-based approach to computing winning strategies in two-player graph games over the state \nspace of in.nite\u00adstate programs. Such games have numerous applications in pro\u00adgram veri.cation and synthesis, \nincluding the synthesis of in.nite\u00adstate reactive programs and branching-time veri.cation of in.nite\u00adstate \nprograms. Our method handles games with winning con\u00additions given by safety, reachability, and general \nLinear Tempo\u00adral Logic (LTL) properties. For each property class, we give a deductive proof rule that \n provided a symbolic representation of the game players describes a winning strategy for a par\u00adticular \nplayer. Our rules are sound and relatively complete. We show that these rules can be automated by using \nan off-the-shelf Horn constraint solver that supports existential quanti.cation in clause heads. The \npractical promise of the rules is demonstrated through several case studies, including a challenging \nCinderella-Stepmother game that allows in.nite alternation of discrete and continuous choices by two \nplayers, as well as examples derived from prior work on program repair and synthesis. Categories and \nSubject Descriptors D.2.4 [Software Engineer\u00ading]: Software/Program Veri.cation; F.3.1 [Logics and Meanings \nof Programs]: Specifying and Verifying and Reasoning about Pro\u00adgrams Keywords program synthesis; games; \nreactive synthesis; proof rules; static analysis; Horn clauses 1. Introduction Many fundamental questions \nin formal methods reduce to comput\u00ading winning strategies in turn-based graph games [18], i.e., games \nwhere two players take turns in moving a token along the edges of Permission to make digital or hard \ncopies of all or part of this work for personal or classroom use is granted without fee provided that \ncopies are not made or distributed for pro.t or commercial advantage and that copies bear this notice \nand the full citation on the .rst page. Copyrights for components of this work owned by others than ACM \nmust be honored. Abstracting with credit is permitted. To copy otherwise, or republish, to post on servers \nor to redistribute to lists, requires prior speci.c permission and/or a fee. Request permissions from \npermissions@acm.org. POPL 14, January 22 24, 2014, San Diego, CA, USA. Copyright c &#38;#169; 2014 ACM \n978-1-4503-2544-8/14/01. . . $15.00. http://dx.doi.org/10.1145/2535838.2535860 a graph, and a player \nwins if the sequence of nodes visited by the token satis.es a certain .-regular winning condition. For \nexample: To synthesize a reactive system from a temporal speci.ca\u00adtion [7, 38, 43], one constructs a \ngraph game where the goal of one player is to satisfy the speci.cation and the goal of the other is to \nviolate it. The desired system is realizable if and only if the .rst player has a winning strategy in \nthis game.  The problem of verifying a branching-time property of a system is naturally framed as a \ngraph game [14]. Here, one player models the existential path quanti.ers in the property; the other player \nmodels the universal quanti.ers. The system satis.es the property if and only if the existential player \nhas a winning strategy.  Graph games are a natural model for open systems [32] that explicitly model \ninteractions between a controller (one player) and its environment (the other player). To prove such \na system correct, we show that the controller has a strategy to enforce its requirements no matter how \nthe environment behaves.  There is a rich literature on algorithmic approaches to graph games motivated \nby applications in formal methods [10, 12, 30, 47]. The majority of these approaches focus on decidable \nclasses of games, such as games on .nite graphs. This focus limits the applications of these techniques. \nFor example, an algorithm that requires a .nite game graph can only be applied to the veri.ca\u00adtion and \nsynthesis of .nite-state systems. To use games in the anal\u00adysis and synthesis of in.nite-state programs, \nwe need symbolic, abstraction-based algorithms for solving games on the state spaces of such programs. \nWhile a few such algorithms exist in the litera\u00adture [12, 26], much more remains to be done on this topic. \nThis paper presents a new approach to this problem space. Our contribution is an algorithmic technique \nbased on automated de\u00adduction for solving (turn-based) games over in.nite-state symbolic transition systems. \nSpeci.cally, we target three classes of games over in.nite graphs: safety games, reachability games, \nand Linear Temporal Logic (LTL) games [18]. These games differ in the winning condi\u00adtion for the player \nfor whom we are computing a winning strategy (call this player Eve; the other player is called Adam). \nIn a safety game, Eve wins a play (an in.nite sequence of nodes visited by the game token) if and only \nif the play avoids a certain unsafe set of nodes. In a reachability game, a play is winning for Eve if \nand only if it reaches a certain target set of nodes. In LTL games, Eve wins a play if and only if the \nplay satis.es an LTL property. We note that, LTL games subsume parity games, an important class of games \nwhere each node of the game graph is labeled with a color from the set {1, . . . , N }, and a play is \nwinning for Eve if and only if the minimum color seen in.nitely often in the play is odd. The importance \nof solving the above types of games to formal methods is well-established in the literature. For instance, \nthe prob\u00adlem of solving a parity game over a program s state space is equiv\u00adalent to that of verifying \nprogram properties written in the modal \u00b5-calculus [14, 18] (note that the \u00b5-calculus subsumes popular \ntem\u00adporal logics like LT L, CT L, and CTL *). The solution of LTL games is also at the core of reactive \nsynthesis from temporal speci.ca\u00adtions. Reachability and safety games are important special cases of \nLTL games that are suf.cient for many applications, including pro\u00adgram repair [21, 29], program synthesis \n[41], synthesis of interface speci.cations [1], and veri.cation of the fragment of the \u00b5-calculus without \nalternation of .xpoint quanti.ers. For each of the above types of games, we give a deductive proof rule \nthat, given a symbolic representation of the game graph, sym\u00adbolically represents a winning strategy \nin the game using quanti.ed Horn constraints. The rule is then automated by applying the EH SF engine \nfor automated deduction [3]. To understand how our rules work, consider a safety game where the objective \nof Eve is to satisfy the state property p at all points in all plays. To .nd a winning strategy for Eve, \nour rule for safety games computes an invariant inv that describes the set of states from which Eve can \nwin the game. This invariant needs to satisfy the following criteria: (a) the initial condition of the \ngame implies inv; (b) inv implies p; and (c) for all Adam transitions out of inv (let us say to a destination \nstate s), s satis.es p and there is a Eve transition from s back to inv. Strategy computation in reachability \ngames relies on well\u00adfounded transition invariants [39] to guarantee that a target state is reached after \na .nite number of rounds of the game. We solve LTL games with temporal objective . by converting \u00ac. into \na nondeter\u00administic B \u00a8uchi automaton, then performing a fair termination check on the product of this \nautomaton and the game graph. All of our rules are sound, meaning that if they derive a strategy for \na player, then the player actually wins under the strategy, as well as relatively complete, meaning that \nthey can always derive a winning strategy when one exists, assuming a suitably powerful assertion language. \nFrom a practical point of view, the appeal of our rules is that they leverage the most recent developments \nin SMT-solving, invariant generation, and termination veri.cation [3, 20]. Speci.cally, our implementation \nCO N SY N TH feeds our proof rules to the EHSF en\u00adgine in the form of Horn-like clauses (in some cases \nwith existen\u00adtial quanti.ers in clause heads). Solving the game now amounts to resolving these clauses \nto a bounded depth, proving the unsatis.a\u00adbility of the resolvent, repeating the process and generalizing \nfrom proofs of unsatis.ability to a solution for the original clauses. EH SF does so using a combination \nof counterexample-guided abstraction\u00adre.nement (CEGAR), interpolation, and SMT solving, and with help \nfrom user-provided templates that capture high-level intuitions about the strategy. We evaluate CON SY \nN TH using several challenging case studies, including the Cinderella-Stepmother game an existing chal\u00adlenge \nproblem for in.nite-state graph games that allows in.nite al\u00adternation of discrete and continuous choices \nby the two players and games arising out of prior work on program repair [29] and synthesis [45]. Now \nwe summarize the main contributions of the paper: We take on the problem of solving games over state \nspaces of in.nite-state programs using the power of modern automated software analysis technology. We \npresent three deductive proof rules for solving such games under the safety, reachability, and LTL winning \nconditions. Our rules are sound and relatively complete, and our automata\u00adtheoretic rule for LTL games \navoids the need to determinize a B \u00a8 uchi automaton.  We offer a prototype implementation of our rules \non top of an existing automated deduction engine. We illustrate the promise of the system through several \ncase studies using examples posed in prior work.  This paper is organized as follows. In Section 2, \nwe describe the Cinderella-Stepmother game as a motivating example. Section 3 formally de.nes graph games \nand the strategy computation prob\u00adlem. Section 4 gives our proof rules for solving games and proves them \ncorrect, i.e., sound and relatively complete. Section 5 revisits the example from Section 2 and applies \nour rules to variants of it; Section 6 presents applications of our rules to repair and synthesis problems \nfrom prior work. Section 7 presents concrete experimen\u00adtal results. Related work is described in Section \n8; we conclude with some discussion in Section 9. 2. The Cinderella-Stepmother game In this section, \nwe describe a synthesis problem that motivated this work, and that we use in a case study later in the \npaper. A version of the problem was previously posed by Rajeev Alur as a challenge problem for the software \nsynthesis community (see Bodlaender et al. [4] and Hurkens et al. [28] for more on the problem). The \nproblem involves a turn-based game between the mythical Cinderella, and her nemesis, the Stepmother. \nThe game setup in\u00advolves .ve buckets arranged in a circle. Each bucket can hold up to c (a constant) \nunits of water; initially, all buckets are empty. In each round of the game, Stepmother brings 1 unit \nof additional water and splits it among the .ve buckets. If any of the buckets over.ow, Stepmother wins. \nIf not, Cinderella empties two adjacent buckets. Cinderella wins if the game goes on forever. We can \nmodel the Cinderella-Stepmother game using the fol\u00adlowing symbolic transition system. Let v be a set \nof system vari\u00adables that represent the amount of water in the .ve buckets, v = (b1, b2, b3, b4, b5). \nAll the buckets are initially empty this fact is speci.ed as the initial condition init(v) = (b1 = 0 \n. \u00b7 \u00b7 \u00b7 . b5 = 0). The transition relation of Stepmother represents a non\u00addeterministic choice of buckets \nin which 1 unit of additional water is added: ( stepmother(v, v) = (b(1 + \u00b7 \u00b7 \u00b7 + b(5 = b1 + \u00b7 \u00b7 \u00b7 + \nb5 + 1 . b(1 = b1 . \u00b7 \u00b7 \u00b7 . b5(= b5). The transition relation of the Cinderella player represents a \nnon\u00addeterministic choice of two consecutive buckets that are emptied. cinderella (v, v() = . . b( i = \n0 . b(= 0 (i+1)%5 =O = . . j ;;. = i . j = (i + 1)%5 . i.{1...5} j.{1..5} . b(j = bj The condition that \none of the buckets over.ows is described by the assertion over.ow(v) = (b1 > c . \u00b7 \u00b7 \u00b7 . b5 > c). Safety \ngame We observe that in the above game, Cinderella wants to enforce a safety property speci.cally, the \nproperty G(\u00acover.ow(v)) in every play of the game. This property is Cinderella s winning condition. \nGames are classi.ed according to the winning condition of the player for whom we want to compute a strategy. \nSpeci.cally, suppose we want to compute a strategy for Cinderella. In that case, we are trying to solve \na safety game. Reachability game Now suppose we want to compute a strategy for Stepmother instead. We \nnote that the winning condition for Stepmother is the reachability property F over.ow(v). The game is \na reachability game. LTL and parity games It is easy to de.ne generalizations of the game where the winning \ncondition for a player is a general Lin\u00adear Temporal Logic (LTL) property. Such a game is called an LTL \ngame. LTL games are an extremely challenging class of games the problem of solving such games on .nite \ngame graphs is 2EXPTIME-complete [38]. The intuitive reason for this hardness is that it requires a conversion \nfrom an LTL formula to a nonde\u00adterministic B \u00a8 uchi automaton (an exponential blowup) and then the determinization \nof this automaton (another exponential blowup). An important special case of LTL games is parity games \n[18]. Here, each state of the transition system is assigned a color (a number in {1, . . . , N }), and \nthe winning condition for a play is that the minimum color seen in.nitely often in the play is odd. (The \ncondition can be stated in LTL in an obvious way.) In Section 7, we use CO NSY NT H on a parity game \ngeneralizing our original game. Discussion From the determinacy of the classes of graph games that we \nstudy [35], it follows that for every value of c, either Cinderella or Stepmother has a winning strategy \nin each of the above games. Now we give some intuitions about what such a winning strategy would look \nlike in the game as originally stated. The discussion of how to automatically solve the problem using \nCON SYN TH is postponed until Section 5. First note that if c < 1.5 units, then Stepmother wins. Her \nstrategy is as follows: in the .rst round, she divides 1 unit into two non-adjacent buckets. Then no \nmatter what Cinderella does, there will be a bucket with 0.5 units at the end of the round, and Stepmother \ncan cause a spill in second round by adding 1 unit in that bucket. If c = 3 units, Cinderella wins: she \ncan just select the buckets in a round-robin order, emptying two buckets in each round, and this strategy \nis winning no matter what Stepmother does. The problem becomes more challenging for 1.5 = c < 3. We leave \nthis case as a challenge for the reader it will soon be apparent that it is highly nontrivial. In such \ncases, fully automated strategy synthesis seems unrealistic, and computer-assisted proofs driven by user-provided \nhints or templates are more plausible. This is the strategy that our approach takes. 3. Preliminaries \nIn this section we formally de.ne games and strategies, and also sketch the deduction framework used \nto automate them. 3.1 Games Syntax A (two-player, turn-based, graph) game is a pair consist\u00ading of a \nsymbolic transition system and a winning condition: We consider symbolic transition systems that are \ncomposed from two players, Adam and Eve. Let v be a tuple of variables. We assume that valuations of \nv describe states of the system under consideration. (For simplicity, we do not distinguish be\u00adtween \nvariables controlled by Eve and Adam.) We represent the initial states of the transition system by an \nassertion init(v). The transition relations of Adam and Eve are given by assertions adam(v, v() and eve(v, \nv(), respectively.  A winning condition obj for a game is given by a set of in.nite sequences of system \nstates. A game is said to be a safety game, a reachability game, and an LTL game respectively when its \n winning condition is a safety property, a reachability property, and a general LTL property. Semantics \nWe present the semantics of games in two steps. First, we de.ne strategies of the individual players. \nA strategy s for Eve is a set of in.nite trees over the states of the system that satis.es the following \nconditions: The roots of trees in s coincide with the set of initial states, and are considered to be \non the .rst level of the tree. (Here, the level of a node is the length of the path to the root plus \none.)  The set of successors of each tree node s at an odd level consists of the following set of states. \n (( ( {s| (s, s) |= adam(v, v)} The set of successors of each tree node s at an even level consists \nof a non-empty subset of the following set of states. (( ( {s| (s, s) |= eve(v, v)} Thus, a strategy \nfor Eve alternates between universal choices of Adam and existential choices of Eve. We call each in.nite \nsequence of system states that starts at a root of a strategy s and follows some branch a play p determined \nby s. A strategy s for Eve is winning if every play determined by s is included in the winning condition. \nFor the given system and a formula . that describes a winning condition in some temporal logic, we write \n(init(v), eve(v, v(), adam(v, v()) |= . when Eve has a winning strategy. We also consider Adam s perspective. \nA strategy s for Adam is de.ned in a similar way. The roots of s represent a non-empty subset of init(v). \ns alternates between existential choices of Adam and universal choices of Eve. If a tree node s is on \nan odd level, then its successors form a non-empty subset of {s( | (s, s() |= adam(v, v()}. Otherwise, \nthe set of successors is {s( | (s, s() |= eve(v, v()}. 3.2 The EH S F engine Our proof rules are automated \nusing the EHSF [3] engine for resolv\u00ading forall-exists Horn-like clauses extended with well-foundedness \ncriteria. We skip the syntax and semantics of the clauses targeted by this system see [3] for more details. \nInstead, we illustrate these clauses with the following example: x = 0 . .y : x = y . rank (x, y), rank \n(x, y) . ti(x, y), ti(x, y) . rank (y, z) . ti(x, z), dwf (ti). Intuitively, these clauses represent \nan assertion over the inter\u00adpretation of query symbols rank and ti (the predicate dwf rep\u00adresents disjunctive \nwell-foundedness, and is not a query symbol). The semantics of these clauses maps each predicate symbol \noccur\u00adring in them into a constraint over v. Speci.cally, the above set of clauses has a solution that \nmaps both rank (x, y) and ti(x, y) to the constraint (x = 0.y = x-1). EH SF resolves clauses like the \nabove using a CEGAR scheme to discover witnesses for existentially quanti.ed variables. The re.ne\u00adment \nloop collects a global constraint that declaratively determines which witnesses can be chosen. The chosen \nwitnesses are used to replace existential quanti.cation, and then the resulting universally quanti.ed \nclauses are passed to a solver for such clauses. At this step, we can bene.t from emergent tools in the \narea of solving Horn clauses over decidable theories, e.g., HSF [19] or \u00b5Z [27]. Such a solver either \n.nds a solution, i.e., a model for uninterpreted relations constrained by the clauses, or returns a counterexample, \nwhich is a resolution tree (or DAG) representing a contradiction. EHS F turns the counterexample into \nan additional constraint on the set of witness candidates, and continues with the next itera\u00adtion of \nthe re.nement loop. Notably, this re.nement loop conjoins constraints that are obtained for all discovered \ncounterexamples. This way EHSF guarantees that previously handled counterexam\u00adples are not rediscovered \nand that a wrong choice of witnesses can be mended. For the existential clause above, EHS F introduces \na wit\u00adness/Skolem relation sk over variables x and y, i.e., x = 0 . sk(x, y) . x = y . rank (x, y). In \naddition, since for each x such that x = 0 holds we need a value y, we require that such x is in the \ndomain of the Skolem relation using an additional clause x = 0 . .y : sk(x, y). In the EH S F approach, \nthe search space of a skolem relation sk(x, y) is restricted by a template function TEMPL(sk)(x, y). \nIn general, a template is required for both the Skolem relation as well as for its guard. For this paper, \ntemplates for the guards can be derived automatically as the projection from the template of the corresponding \nSkolem relation, therefore we omit them from our presentation. 4. Proof rules for games In this section, \nwe present proof rules for three kind of games: safety, reachability and parity/LTL games. These proof \nrules con\u00adclude that Eve has a winning strategy by imposing implication and well-foundedness conditions \non auxiliary assertions over system variables. For each proof rule we prove its soundness, i.e., a win\u00adning \nstrategy exists if the premises are satis.ed by some auxiliary assertions, and relative completeness, \ni.e., if a winning strategy ex\u00adists then auxiliary assertions satisfying the premises exist under an \nassumption that the assertion language of our choice is suf.\u00adciently expressive. Such correctness criteria \nare standard for tem\u00adporal proof rules [33]. 4.1 Safety games We consider a safety game for which Eve \nhas a winning strategy if only states from safe(v) are visited by all plays. We present the corresponding \nproof rule in Figure 1. The proof rule relies on an invariant assertion inv(v) that represents a set \nof states reached by Eve in a winning strategy. We connect the invari\u00adant assertion with the reachable \nstates by resorting to reasoning by induction on the number of steps to reach a state. The condition \nS1 requires that the initial state of the game are considered in inv(v). S2 represent the induction step. \nHere, we require that for every step from inv(v) executed by Adam there exist a step by Eve that leads \nback to inv(v). Of course, since the winning condition requires that all states of a play need to satisfy \nsafe(v), we require that all states reached after Adam made a step as well as inv(v) satisfy the assertion \nsafe(v). The former condition is enforced by a conjunct ( safe(v) in the head of S2. The later condition \nis guaranteed by S3. Theorem 1 (Correctness of rule RU LE SA F E). The proof rule RU L E SA F E is sound \nand relatively complete. Proof. We split the proof into two parts: soundness and complete\u00adness. Soundness \nWe prove the soundness by contradiction. Assume that there exists an assertion inv(v) that satis.es the \npremises of RULE SA F E, yet the conclusion of RU L E SAF E does not hold. That is, there is no winning \nstrategy for Eve. Hence, there exists a strategy s for Adam in which each play reaches a state that violates \nsafe(v). This strategy s alternates between existential choices of Adam and universal choices of Eve. \nLet aux(v) be a set of states for which s provides existentially chosen successors wrt. Adam. We derive \na contradiction by relying on a certain play p that is determined by s. The play p is constructed iteratively. \nWe start from some root state s1 of s, which also satis.es the ini\u00adtial condition init(v). Note that \ns1 |= inv(v), due to S1, and s1 |= aux(v) due to s. Each iteration round extends the play ob\u00adtained so \nfar by two states, say s( and s((. We maintain a condition that each such s(( satis.es inv(v) and aux(v). \nLet s be the last state of the play p constructed so far. Due to our condition, we have s |= inv(v) . \naux(v). Then, s determines a successor state s( such that (s, s() |= adam(v, v(), and S2 guarantees that \nthere exists a state s(( such that (s(, s(() |= eve(v, v() and s(( |= inv(v). Furthermore, s(( satis.es \naux(v) due to s. Finally, from S2 and S3 follows that s( |= safe(v) and s(( |= safe(v), respectively. \nBy iteratively constructing p using the above step we obtain a play that satis.es the strategy s. Thus, \nwe obtain a contradiction, since according to our construction all states in p satis.es safe(v), however \ns guarantees that each play eventually reaches a state that violates safe(v). Completeness Assume that \nEve has a winning strategy, say s, i.e., the conclusion of RU LE SA F E holds. We prove the complete\u00adness \nclaim by showing how to construct inv(v) that satis.es the premises of RU L E SA F E. This strategy s \nalternates between universal choices of Adam and existential choices of Eve. Let inv(v) be a set of states \nfor which s provides universally chosen successors wrt. Adam. Since s is a winning strategy, all states \nsatisfying inv(v) also sat\u00adisfy safe(v), i.e., inv(v) satis.es S3. inv(v) satis.es S1, since s guarantees \nthat Eve wins from every initial state. Now we consider an arbitrary state s that satis.es inv(v). s \nguarantees that for every successor s( of s wrt. Adam there exists a successor s(( wrt. Eve such that \ns(( |= inv(v). Furthermore, since s is winning, we have s( |= safe(v). Thus we conclude that inv(v) satis.es \nthe condi\u00adtion S2 as well. 4.2 Reachability games In contrast to safety games, the winning condition \nof reachability games ensures that a certain set of states called dst(v) is eventually reached by each \nplay. Reasoning about such eventuality properties demands the use of well-founded orders. We present \na rule RU L E RE AC H for proving that Eve has a win\u00adning strategy for a reachability property given \nby an LTL formula F dst(v) in Figure 2. RUL E RE AC H requires an invariant assertion ( inv(v) together \nwith a binary relation round (v, v). Similarly to RUL E SA F E, we use inv(v) to keep track of states \nthat are reached by Eve. This is captured by R1 and a part of R2. To ensure that Adam makes progress \nwhen aiming at the set dst(v) we keep track ( of pairs of states towards reaching it in round (v, v), \nsee the last conjunct in R2. We note that the proof rule only imposes conditions when dst(v) is not yet \nreached, as encoded by the second conjunct in R2. Finally, to ensure that dst(v) is eventually reached \nby each ( play we require that round (v, v) represents a well-founded rela\u00adtion. Thus, it is impossible \nto return to inv(v) . \u00acdst(v) in.nitely many times. Theorem 2 (Correctness of rule RU L E RE AC H). The \nproof rule RUL E RE AC H is sound and relatively complete. Proof. We split the proof into two parts: \nsoundness and complete\u00adness. Soundness We prove the soundness by contradiction. Assume ( that there \nexist assertions inv(v) and round (v, v) that satisfy the premises of RU LERE AC H, yet the conclusion \nof RUL E RE AC H does not hold. That is, there is no winning strategy for Eve. Hence, there exists a \nstrategy s for Adam in which each play never reaches a Find assertion inv(v) such that: S1 : init(v) \n. inv(v) S2 : inv(v) . adam(v, v() . safe(v() . .v(( : eve(v(, v(() . inv(v(() S3 : inv(v) . safe(v) \n (init(v), eve(v, v(), adam(v, v()) |= G safe(v) Figure 1. Proof rule RU L ESAFE for a safety game, i.e., \nthe winning condition is given by a formula G safe(v). ( Find assertions inv(v) and round (v, v) such \nthat: R1 : init(v) . inv(v) R2 : inv(v) . \u00acdst(v) . adam(v, v() . \u00acdst(v() . .v(( : eve(v(, v(() . inv(v(() \n. round (v, v(() R3 : well -founded (round (v, v()) (init(v), eve(v, v(), adam(v, v()) |= F dst(v) Figure \n2. Proof rule RU L ERE AC H for a reachability game, i.e., the winning condition is given by a formula \nF dst(v). state that satis.es dst(v). This strategy s alternates between exis\u00adtential choices of Adam \nand universal choices of Eve. Let aux(v) be a set of states for which s provides existentially chosen \nsucces\u00adsors wrt. Adam. Note that the implication aux(v) . \u00acdst(v) is valid, since no play determined \nby s visits dst(v). We derive a contradiction by relying on a certain play p that is determined by s. \nThe play p is constructed iteratively, in a similar way as done in the proof of Theorem 1. We start from \nsome root state s1 of s, which satis.es the initial condition init(v). Note that s1 |= inv(v), due to \nR1, and s1 |= aux(v) due to s. Each (iteration round extends the play obtained so far by two states, \nsay sand s((. We maintain a condition that each such s(( satis.es inv(v) and aux(v). Let s be the last \nstate of the play p constructed so far. Due to our condition, we have s |= inv(v) . aux(v). Then, s determines \na successor state s( such that (s, s() |= adam(v, v(), and R2 guarantees that there exists a state s(( \nsuch that (s(, s(() |= eve(v, v() and s(( |= inv(v). Furthermore, s(( satis.es aux(v) due to s. Finally, \nfrom R2 also follows that s( |= \u00acdst(v) and (s, s(() |= round (v, v(). By iteratively constructing p \n= s1, s2, . . . using the above step we obtain a play that satis.es the strategy s. Thus, there is an \nin.nite sequence of states s1, s3, s5, . . . that takes states occurring at odd positions in p such that \neach pair of consecutive ( states s2i-1 and s2i+1 is connected by round (v, v), for i = 1. The existence \nof such an in.nite sequence contradicts the well\u00adfoundedness condition imposed by R3. Completeness Assume \nthat Eve has a winning strategy, say s, i.e., the conclusion of RU L ERE AC H holds. We prove the complete\u00adness \nclaim by showing how to construct inv(v) and round (v, v() that satisfy the premises of RUL E RE AC H. \nThe strategy s alternates between universal choices of Adam and existential choices of Eve. Each play \np = s1, s2, s3, . . . ( contributes elements to inv(v) and round (v, v) as follows. Let k be the position \nof the .rst occurrence of a state in p that satis.es dst(v), i.e., we have sk |= dst(v) and si ;|= dst(v) \nfor each i . 1..k - 1. Such position exists, since the play satis.es F dst(v). Then, for each i = 1 \nsuch that 2i - 1 = k we add the state s2i-1 to inv(v). Furthermore, for each i = 1 such that 2i + 1 = \nk we ( add the pair of states s2i-1 and s2i+1 to round (v, v). We note that the above construction ensures \nthat for each pair of states s and s(( such that (s, s(() |= round (v, v(() holds: i) we have s ;|= dst(v), \nand ii) there exists a state s( such that s( ;|= dst(v), ( ( ( (( ( (s, s) |= adam(v, v), and (s, s) \n|= eve(v, v). We observe that inv(v) satis.es R1, since s guarantees that Eve wins from every initial \nstate. Now we consider each pair of states s and s( that satis.es the left hand side of R2. s guarantees \nthat there exists a successor s(( wrt. Eve. Regardless whether s(( |= dst(v) the above construction guarantees \nthat the right-hand side of R2 is satis.ed by assigning s, s(, and s(( to v, v(, and v((, respectively. \n( Now we show by contradiction that round (v, v) is well\u00adfounded. Assume otherwise, i.e., there exists \nan in.nite sequence of ( states s1, s2, . . . induced by round (v, v). As noted previously, for each \npair of consecutive states si and si+1 there exists an interme\u00ad ((( diate state si such that the sequence \ns1, s1, s2, . . . , si, si, si+1, . . . is a play. Since this play does not visit any state that satis.es \ndst(v), we obtain a contradiction to the assumption that Eve has a winning strategy. Hence, we conclude \nthat R3 is satis.ed. 4.3 LTL and parity games Now we show how to solve LTL games and, as a special case, \nparity games. To state the parity winning condition we assume that the set of all states is partitioned \ninto N subsets that are denoted by the assertions p1(v), . . . , pN (v). Thus, p1(v) . \u00b7 \u00b7 \u00b7 . pN (v) \nis valid and for each 1 = i < j = N we have that pi(v) . pj (v) is unsatis.able. Without loss of generality \nwe assume that N is an odd number. The parity condition states that the system wins the game for a given \ncomputation if among the subsets pi1 (v), . . . , piK (v) that are visited in.nitely many times by the \ncomputation the minimal identi.er is odd, i.e., min{i1, . . . , iK } is odd. We can represent the parity \ncondition by the following LTL formula .. . = GF p1(v) . GF p3(v) . F G\u00ac(p1(v) . p2(v)) \u00b7 \u00b7 \u00b7 . GF pN \n(v) . F G\u00ac(p1(v) . \u00b7 \u00b7 \u00b7 . pN-1(v)) The .rst disjunct states that p1(v) is visited in.nitely often, while \nthe second disjunct states that p3(v) is visited in.nitely often and there exists a suf.x that neither \nvisits p1(v) nor p2(v). The last disjunct states that pN (v) is visited in.nitely often and there is \na suf.x that visits no other subset. To solve games where the winning condition is an LTL for\u00admula ., \nwe negate . and apply a standard technique, e.g., [17], for translating LTL formulas to B \u00a8 uchi automata \non the result\u00ading \u00ac.. Let B be the obtained automaton. We represent B using assertions over the program \ncounter of the automaton pc B and the system variables v. Let the initial condition of the automaton \nbe given by initB(pcB). We represent the transition relation of B by ( nextB(pcB, v, pcB). This transition \nrelation evolves the value of the program counter of the automaton while taking into consid\u00aderation the \ncurrent state of the system given by a valuation of v. Finally, we assume that accB(pcB) represents the \naccepting states of the automaton. Given a sequence of states p = s1, s2, . . . we de.ne a run of B on \np to be an in.nite sequence of automaton states q0, q1, q2, . . . such that q0 |= initB(pcB) and (qi-1, \nsi, qi) |= ( nextB(pcB, v, pcB) for each i = 1. A run is accepting wrt. the B \u00a8uchi acceptance condition \nif it contains in.nitely many states that satisfy accB(pcB). The automaton B accepts a play p if there \nex\u00adists an accepting run on p. Note that our construction ensures that if B accepts p then p ;|= .. A \nproof rule B \u00a8for LTL games based on the UC H ITE R M above automata-theoretic approach [44] is presented \nin Figure 3. B \u00a8 UC H ITE RM requires that the negation of the winning condition is translated into a \nB \u00a8uchi automaton B, which together with the sys\u00adtem description appears in the proof rule. An interesting \nproperty of this proof rule is that it relies on a non-deterministic B \u00a8uchi au\u00adtomaton representation \nof the negated winning condition, and does not require any determinization via Rabin, Muller, or Streett \naccep\u00adtance conditions. We consider a synchronous parallel product of the transition relations of the \nplayers and the transition relation of the B \u00a8uchi automaton, which is expressed in the proof rule by \nappropriate conjunctions. We use w = (v, pc B) to refer to the vector of the system variables and the \nprogram counter of the automaton. The existence of a winning strategy for Eve depends on ( ((), the identi.cation \nof auxiliary assertions inv(w), aux(w, w, v ( round (w, w, w((), and fair(w, w() as follows. inv(w) keeps \ntrack of the system states reached by Adam, similarly to RU L E SAFE and RU L E RE AC H. To deal with \nthe non-determinism in the transi\u00adtion relation of the automaton, we introduce an intermediate book\u00ad \n( (( keeping assertion aux(w, w, v), which allows us to decouple (( the treatment of the automaton state \nq(( from the selection of s. ( (( round (w, w, w) contains all triples of adjacent program states occurring \nin plays. Here, it is more .ne-grained than the counter\u00adpart in RU L ERE AC H, as we keep track of intermediate \nstates vis\u00adited by Eve instead of only considering the combined steps (vis\u00ad ( ited by Adam). For keeping \ntrack of acceptance fair(w, w) con\u00adtains all pairs of program states that describe play segments visiting \n( B\u00a8) from uchi accepting states at least once. We derive fair(w, w ( (( round (w, w, w) using transitive \nclosure-like conditions B4 and B5. Finally, the well-foundedness condition B6 shows that accept\u00ading states \ncannot be visited in.nitely many times. Theorem 3 (Correctness of rule B \u00a8The proof rule U CHI TER M). \nB \u00a8 U C HI TE RM is sound and relatively complete. Proof. We split the proof into two parts: soundness \nand complete\u00adness. Soundness We prove the soundness by contradiction. As\u00ad ( (( sume that there exist \nassertions inv(w), aux(w, w, v), ( (( ( round (w, w, w), and fair(w, w) that satisfy the premises of \nB \u00a8U C H I TE R M does not hold. U C HI TE RM, yet the conclusion of B \u00a8That is, there is no winning \nstrategy for Eve. Hence, there exists a strategy s for Adam in which each play violates .. This strategy \ns alternates between existential choices of Adam and universal choices of Eve. We derive a contradiction \nby relying on a certain set of trees whose branches are sequences (s1, q1), (s2, q2), . . . that are \njointly determined by s and the assumed assertions (via B \u00a8 U C HI TE RM). The requisite branches are \nconstructed iteratively, in a similar way as the play construction is done in the proof of Theorem 1. \nWe start from some root state s1 of s, which satis.es the initial condition init(v). Then the play is \nextended from a state s by considering an existential choice s( offered by s that is followed by an existential \nchoice s(( offered by B2. We obtain appropriate runs q0, q1, . . . by applying B1, B2, and B3 for values \nof v, v(, and v(( determined by currently considered s, s(, and s((, respectively. (( Since the automaton \nB is non-deterministic, for each s, s(, and sthere is a set of appropriate automaton states. Considering \neach choice leads to a tree construction, as described below. First, we consider s1 and B1, and for each \nq1 such that there exists q0 with init(s1) . initB(q0) . nextB(q0, s1, q1) we add a (s1, q1) as a root \nto our tree. We remember the state q0 that was used to create each (s1, q1). Then, for each tree leaf \n(s, q) we perform the following tree expansion. First, we consider the state s( that s provides as a \nsuccessor of s. Then, we rely on B2, and for ( ( each q( such that nextB(q, s, q() holds we add (s, \nq() as a child ( node of (s, q). Furthermore, for given s and q, and each s( and q ( (( we take s(( \nsuch that eve(s, s(() . aux(s, q, s, q, s((). Now we ( (( (( rely on B3, and for each q(( such that \nnextB(q, s, q) holds we (( (( ( ( add (s, q) as a child node of the corresponding (s, q). By applying \nthe above tree expansion steps we construct a set of trees where every branch is a sequence (s1, q1), \n(s2, q2), . . . that comes with the corresponding initial automaton state q0. Note that s1, s2, . . . \nis a play determined by s, hence it violates .. Thus, there exists a branch for which the sequence q0, \nq1, . . . is an accepting run of B for the corresponding play determined by the branch. Let (si1 , qi1 \n), (si2 , qi2 ), . . . be a subsequence such that qij |= accB(pcB) for each j = 1. Then, each pair (sij \n, qij ) contributes ((sij , qij , qij+1 )) ), (sij+1 (or its closest neighbour visited by Adam) to fair(w, \nw(). Thus, the condition B6 is violated. Completeness Assume that Eve has a winning strategy, say s, \ni.e., the conclusion of B \u00a8 UC H ITE R M holds. We prove the complete\u00ad ( ((), ness claim by showing \nhow to construct inv(w), aux(v, w, v ( round (v, w, w((), and fair(w, w() that satisfy the premises \nof B \u00a8 U C HI TE RM. The strategy s alternates between universal choices of Adam and existential choices \nof Eve. Each play p = ( (( s1, s2, s3, . . . contributes elements to inv(w), aux(v, w, v), and ( (( \n round (w, w, w) in the following way through an appropriate sequence of automaton states q0, q1, q2, \n. . . . Since p |= ., we note that p is not accepted by B. Hence, either there is an in.\u00adnite run q0, \nq1, q2, . . . that is not accepting, or the exists a .nite run q0, . . . , qn that cannot be extended \n(i.e., there is no automaton ( (( ( (( ( Find assertions inv(w), aux(w, w, v), round (w, w, w), and \nfair(w, w) where w = (v, pcB) such that: B1 : init(v) . initB(pcB) . nextB(pcB, v, pc(B) . inv(v, pc(B) \nB2 : inv(w) . adam(v, v() . nextB(pc B, v(, pc (B) . .v(( : eve(v(, v(() . aux(w, w(, v(() B3 : aux(w, \nw(, v(() . nextB(pc(B, v((, pc((B) . inv(w(() . round (w, w(, w(() B4 : round (w, w(, w(() . (accB(pcB) \n. accB(pc (B)) . fair(w, w(() B5 : fair(w, w() . round (w(, w((, w((() . fair(w, w((() B6 : well -founded \n(fair(w, w()) (init(v), eve(v, v(), adam(v, v()) |= . Figure 3. Proof rule B \u00a8uchi U C H I TE RM for \nan LTL game, i.e., the winning condition is given by an LTL formula .. From \u00ac. we obtain a B \u00a8 ( automaton \nB with an initial condition initB(pcB), a transition relation nextB(pcB, v, pcB), and accepting states \naccB(pcB). state qn+1 such that nextB(qn, sn, sn+1)). In either case, for each i = 0 (and 2i + 1 = n \nif the run is .nite) we let (s2i-1, q2i-1) be an element of inv(w), (s2i-1, q2i-1, s2i, q2i, s2i+1) be \nan element ( (( of aux(w, w, v), and (s2i-1, q2i-1, s2i, q2i, s2i+1, q2i+1) be an ( (( ( element of round \n(w, w, w). Then we de.ne fair(w, w) for the ( (( obtained round (w, w, w) as the least solution of B4 \nand B5. Since the run is not accepting, it visits accepting states only ( .nitely many times. Hence, \nfair(w, w) is well-founded. 5. Case study: Cinderella-Stepmother games In this section we illustrate \nour constraint-based approach to solv\u00ading games applying it to the Cinderella-Stepmother game intro\u00adduced \nin Section 2. We consider .ve variants of this game corre\u00adsponding to different winning conditions. In \nSection 7 we report on running times required for solving these games using CO N SY N T H. 5.1 Games \nwith Cinderella s safety objective In these games, we attempt to obtain winning strategies for Cin\u00adderella \nin her attempt to keep the buckets from over.owing. The winning condition for Cinderella is G \u00acover.ow(v). \nAs men\u00adtioned in Section 2, the Cinderella player has simple winning strate\u00adgies for bucket capacity \nc = 3. For values 2 = c = 3, the strategies are more involved. (For values c = 2 there are no strategies \nfor the player Cinderella to win the game). Round strategy We de.ne the .rst game using the value c = \n3 for the bucket capacity. A winning strategy might follow an al\u00adternation of consecutive buckets that \nare emptied. Accordingly, we use an auxiliary variable r for a pair of buckets to be emp\u00adtied, to remember \nthe previous choice made by the Cinderella player. The tuple of game variables contains the .ve bucket \nvari\u00adables from v and is extended with the round variable r as follows: w = (b1, b2, b3, b4, b5, r). \nThe initial states assertion sets the round variable to r = 1. We let Adam play the role of Stepmother \nand therefore the transition relation of Adam is based on the assertion ( stepmother(v, v), while the \ntransition relation of Eve is given by ( cinderella (v, v). (Both constraints are given in Section 2.) \ninit(w) = (b1 = 0 . \u00b7 \u00b7 \u00b7 . b5 = 0 . r = 1) eve(w, w() = cinderella (v, v() ( (( adam(w, w) = (stepmother(v, \nv) . r= r) Considering the safety condition obj (w) = G(\u00acover.ow(v)), we instantiate the proof rule from \nFigure 1 as follows. (init(w), adam(w, w(), eve(w, w()) |= obj (w) There exists a strategy for Eve provided \nthat the premises of the proof rule are satis.ed. These premises are Horn clauses over the auxiliary \nassertion inv(w). We apply a solver, e.g., CO NSY NT H, to .nd a solution for the auxiliary assertion. \nThe clauses S1 and S3 are universally quanti.ed over the game variables, while the existentially quanti.ed \nclause S2 is skolemized in the CON SYN TH ( (( approach. We use the skolem relation sk(w, w, w) to denote \nthe witness constraint corresponding to the existentially quanti.ed (( variables w. ( ( ( (( inv(w) \n. stepmother(v, v) . r= r . sk(w, w, w) . ( (( (( cinderella (v,v) . inv(w) CO N SY N T H requires a \ntemplate for the skolem relation and we present below the intuition behind this constraint. For each \nof ( the .ve disjuncts from cinderella (v, v) transition relation, we add guards (one guard exclusive \nto the others) and update the ( ( value of the round variable. We use c1(v, v) to c5(v, v) to denote \nthe .ve disjuncts from the transition relation of the Cinderella player introduced in Section 2. We obtain \nthe following template constraint. ( (( ( (( ( (( TE M P L(sk)(w, w, w) = (r= 1 . r=?1 . c1(v, v) . ( \n(( ( (( r= 2 . r=?2 . c2(v,v) . ( (( ( (( r= 3 . r=?3 . c3(v,v) . ( (( ( (( r= 4 . r=?4 . c4(v,v) . ( \nr( = 5 . r(( =?5 . c5(v, v(()) The template parameters are denoted by ? -variables and different subscripts \nindicate distinct template parameters. Our approach is able to synthesize automatically the values used \nto update the round and implicitly the order in which the Cinderella player should alternate emptying \nthe buckets. CONSYNTH returns the solution ?1 = 4, ?2 = 1, ?3 = 1, ?4 = 3, ?5 = 1. Correspond\u00ading to \nthis solution, the strategy for the Cinderella player consists of a repeating sequence of three player \nmoves: 1. Since initially r = 1 and the .rst disjunct is enabled, decide to empty buckets 1 and 2 and \nupdate the round variable r(( = 4. 2. Since the disjunct r( = 4 . r(( =?4 is enabled, decide to empty \n((  buckets 4 and 5 and update the round variable to r= 3. ( (( 3. Since the disjunct r= 3 . r=?3 is \nenabled, decide to empty (( buckets 3 and 4 and update the round variable to r= 1. After these three \nmoves, r has value 1, the .rst disjunct is again enabled and the strategy will continue with the .rst \nmove/decision above. This strategy ensures that the Cinderella player empties often enough all the buckets \nand therefore the Stepmother player cannot enforce an over.ow. This game is won by the Cinderella player \nbased on the round strategy described above. Second strategy We show how our approach can be used to \nob\u00adtain a strategy for the case of the game that is more dif.cult for Cinderella to win, i.e., c = 2. \nWe .x the roles of the two players similar to the previous paragraph: eve(v, v() = cinderella (v, v() \nand adam(v, v() = stepmother(v, v(). To explain the rationale behind the Cinderella s decisions for this \ncase, we refer to the proof rule from Figure 1. We repeat the second clause S2 instantiated for the two \nplayers of the C-S game: ( ( (( ( (() inv(v).stepmother(v, v) . safe(v) ..v: cinderella (v, v (( . inv(v) \nTo change the state of the system from v( to v((, the strategy for the Cinderella player takes into consideration \nher previous move (re.ected in variables v) and the reply by Stepmother (re.ected in variables v(). Therefore \nthe template for the strategy considers .ve cases depending on which buckets the Cinderella player may \nhave emptied in the previous turn: ( (( ( (( TEM P L(sk)(v, v, v) = (b1 = 0 . b2 = 0 . T12(v, v) . ( \n(() . b2 = 0 . b3 = 0 . T23(v,v ( (( b3 = 0 . b4 = 0 . T34(v,v) . ( (( b4 = 0 . b5 = 0 . T45(v,v) . ( \n(( b5 = 0 . b1 = 0 . T51(v,v)). The Tij conjuncts refer to non-obvious knowledge and relate to an invariant \nstating that each pair of non-adjacent buckets should have total contents at most 1 [28]. The .rst part \nof the template, i.e., T12, is based on the intuition that if in the previous round Cinderella emptied \nbuckets 1 and 2 (b1 = 0 . b2 = 0), then during the next round she will decide to empty another pair of \nbuckets. That is, either the pair of buckets 3 and 4 (b((3 4 0) or the pair of = 0 . b((= 0 . b(( buckets \n4 and 5 (b((4 = 5 = 0) will be emptied. However, the condition on which to decide if to empty buckets \n3 and 4 or buckets 4 and 5 is not straightforward. We use template parameters and leave the decision \nto be automated by our game solving approach. The formula T12 is provided as follows. ( (( 2 = 1 . b(( \nT12(v, v) = (?5 * b(5+?2 * b(3 = 0 . b((4 = 0 . 3 = 1 . b(( ?1 * b(1+?3 * b(4 = 0 . b5((= 0) Following \na similar argument, we obtain the formulas that complete ( (( the de.nition of the template TEMPL(sk)(v, \nv, v): ( (( 3 = 1 . b(( T23(v, v) = (?1 * b1(+?3 * b(4 = 0 . b((5 = 0 . 4 = 1 . b(( ?2 * b(2+?4 * b(5 \n= 0 . b1((= 0) ( 4 = 1 . b(( T34(v, v(() = (?2 * b(2+?4 * b(5 = 0 . b((1 = 0 . 5 = 1 . b(( ?3 * b(3+?5 \n* b(1 = 0 . b((2 = 0) ( (( 5 = 1 . b(( , v) = (?3 * b3(+?5 * b(= 0 . b((= 0 . 1 = 1 . b(( T45(v1 2 ?4 \n* b(4+?1 * b(2 = 0 . b((3 = 0) ( (( 1 = 1 . b(( T51(v, v) = (?4 * b4(+?1 * b(2 = 0 . b((3 = 0 . 2 = 1 \n. b(( ?5 * b(5+?2 * b(3 = 0 . b((4 = 0). The template parameters are marked as before by ? -variables \nand we aim to obtain solutions for the .ve template parameters ?1, ?2, ?3, ?4, ?5. Our approach is indeed \nable to synthesize auto\u00admatically values for these parameters. The tool CONSYNTH re\u00adturns the solutions \n?1 = 1, ?2 = 1, ?3 = 1, ?4 = 1, ?5 = 1. The resulting strategy for the Cinderella player guarantees that \nno state with over.ow can be reached. For a different perspective, we refer the interested reader to \nan article on (non-automated) reason\u00ading and invariants needed to establish strategies for the Cinderella-Stepmother \ngame similar to the ones we synthesize [28].  5.2 Game with Stepmother s reachability objective We continue \nillustrating our approach with the Cinderella-Stepmother game, this time based on a reachability objective: \nthe winning condition for the Stepmother player requires that a state with over.ow is reached, obj (v) \n= F over.ow(v). For this game, we use the bucket capacity c = 1.4, a value for which the Step\u00admother \nhas indeed a winning strategy. To derive this strategy, we instantiate the proof rule for the reachability \ngame as follows. init(v) = (b1 = 0 . \u00b7 \u00b7 \u00b7 . b5 = 0) ( ( eve(v, v) = stepmother(v, v) ( ( adam(v, v) \n= cinderella (v, v) Next we provide a template corresponding to the existentially quan\u00adti.ed clause. \nThe insight behind the template is that the quantity of water from each bucket increases during the turn \nof Stepmother, but without specifying the amount, i.e., (b((i = bi(+?i .?i = 0). ( (( TEM P L(sk)(v, \nv, v) = (?1 + \u00b7 \u00b7 \u00b7 +?5 = 1 . O (b(( i = b(i+?i .?i = 0) i.{1..5} Our approach computes the auxiliary \nassertions that are required by the reachability proof rule and a witness for the existential quan\u00adti.er. \nThe witness instantiates the template parameters and repre\u00adsents the Stepmother s strategy to ensure \nthat the buckets eventually over.ow no matter what moves are made by the Cinderella player. ( sk(v, v) \n= (b1(= b1 + 0.8 . b2(= b2 . b(3 = b3 + 0.1 . b4(= b4 . b5(= b5 + 0.1) In this case, since the addition \nof water is done in non-adjacent buckets, e.g., b1 and b3, eventually the game reaches an over.ow state, \nand the Stepmother is the player to win this game. 5.3 Games with Cinderella s LTL objectives Apart \nfrom games with safety and reachability objectives, our ap\u00adproach is able to handle games with more general \nLTL objectives. For this game, we use the following player roles. init(v) = (b1 = 0 . \u00b7 \u00b7 \u00b7 . b5 = 0) \n( ( eve(v, v) = cinderella (v, v) ( ( adam(v, v) = stepmother(v, v) We use the value c = 1.4 for the \nbucket capacity, similar to Sec\u00adtion 5.2. As already explained, with this value Stepmother has a strategy \nto win the game with the objective .(v) = F over.ow(v). Consequently, Cinderella does not have a strategy \nto win the game with the objective set to the complement formula, i.e., \u00ac.(v) = G \u00acover.ow(v). For this \nsection, we formalize a win\u00adning condition that is a weaker logical formula than \u00ac.(v) for which Cinderella \nhas a winning strategy. The objective constraint GF \u00acover.ow(v) states that an over.ow state does not \noccur in\u00ad.nitely often in the plays of the game. More generally, we use color to indicate the most signi.cant \nbucket for which an over.ow occurs. A state without over.ow: (color = 0).  A state with over.ow such \nthat i is the smallest index of those that correspond to buckets that have over.own: (color = i).  \n We group the states of the system based on the truth value of the predicates color = i as follows. p0(v) \n= (color = 0) = (b1 = 1.4 . \u00b7 \u00b7 \u00b7 . b5 = 1.4) p1(v) = (color = 1) = (b1 > 1.4) p2(v) = (color = 2) = \n(b1 = 1.4 . b2 > 1.4) p3(v) = (color = 3 . color = 4 . color = 5) = . . . A winning condition corresponding \nto a value i ensures that states from pi(v) occur in.nitely often in the plays of the system, and that \ni is the smallest value for which states occur in.nitely often. win(v, i) = (GF pi(v) .F G \u00acpj (v)) \nj.{0,..,i-1} Our approach for solving games with LTL objectives proceeds in three steps: 1) complement \nthe LTL formula . representing the winning condition; 2) construct a B \u00a8 uchi automaton corresponding \nto the complemented formula \u00ac.; 3) instantiate the proof rule from Figure 3 using the B \u00a8uchi automaton \nrepresentation. LTL game 1 For the .rst LTL game, we de.ne the objective for the Cinderella player obj \n(v) = win(v, 0) = GF p0(v). We complement the objective formula to obtain F G \u00acp0(v) = F G over.ow(v), \nthen construct the B \u00a8 uchi automaton correspond\u00ading to the complemented formula as follows. initB(pcB) \n= (pcB = 0) (( nextB(pcB, v, pcB) = (pcB = 0 . pcB = 0 . ( pcB = 0 . pcB = 1 . over.ow(v) . ( pcB = \n1 . pcB = 1 . over.ow(v)) accB(pcB) = (pcB = 1) We instantiate the proof rule from Figure 3 as follows. \n(init(v), adam(v, v(), eve(v, v()) |= obj (v) There exists a strategy for Eve provided that the premises \nof the proof rule are satis.ed. These premises are Horn clauses over the ( (( ( (( auxiliary assertion \ninv(w), aux(w, w, v), round (w, w, w), ( and fair(w, w). We apply CO NSY NT H to .nd a solution for the \nauxiliary assertions. The clause B2 is an existentially quanti.ed clause. By skolemization of the existential \nclause B2 we obtain the following. ( inv(w) . stepmother(v, v() . nextB(pcB, v, pcB) ( (( ( (( ( (( \n. sk(w, w, v) . cinderella (v, v) . aux(w, w, v) Using the template described in the paragraph Second \nstrategy from Section 5.1, our approach is able to derive solutions for the auxiliary assertions and \nthe following template parameters ?1 = ?2 =?3 =?4 =?5 = 1. We conclude that Cinderella is the player \nto win this game, and that her strategy ensures that states without over.ow occur in.nitely often in \nthe plays of the game. LTL game 2 For the second LTL game, we de.ne the objective for the Cinderella \nplayer win(v, 0) . win(v, 2). The objective for the Stepmother player is win(v, 1) . win(v, 3). The formula \ncorresponding to the Cinderella s objective: . = (GF p0(v) . (GF p2(v) . F G \u00acp1(v) . F G \u00acp0(v))). The \ncomplemented formula is \u00ac. = (F G \u00acp0(v) . (F G \u00acp2(v) . GF p1(v) . GF p0(v))). The B \u00a8 uchi automaton \ncorresponding to the complemented formula contains 10 distinct control states, from which two are accepting \nstates. Using our proof rule, we are able to compute automatically auxiliary assertions and obtain that \nthe same second strategy is winning for the Cinderella player. Note that for the player Cinderella, \nthe LTL game 2 (with objec\u00adtive win(v, 0) . win(v, 2)) is easier to win than the LTL game 1 (with objective \nwin(v, 0)). However, the relation between the two objectives is not immediately usable in a deductive \napproach like ours. We presented both LTL games 1 and 2, since our approach based on the proof rule from \nFigure 3 constructs different Buechi automata and different auxiliary assertions for the two objectives. \n6. Case study: program repair/synthesis games In this section we illustrate how our constraint-based \napproach to solving games applies to the synthesis of reactive programs from temporal speci.cations. \nWe consider synthesis problems obtained from program repair questions, see Section 6.1 and Section 6.2, \nas well as inference of thread synchronization, see Section 6.3. In Section 7 we report on running times \nrequired for solving these games using CO N SY N T H. 6.1 Program repair game with safety objective We \nmodel program repair as a game following [29]. That is, given a set of suspect statements, we look for \na modi.cation of those program statements such that the modi.ed program satis.es its speci.cation. For \nthe .rst repair game, we assume that a program is given by a tuple (init(v), next(v, v(), error (v)) \nthat represents initial states, a transition relation, and error states, respectively. As an example \nwe consider the program shown in Figure 3 in [29]. The program has three program variables v = (l, gl, \npc). The variable l models a lock, the variable gl is used to keep track of the status of the lock, while \nthe variable pc is the program counter variable. The initial states of the program are init(v) = (gl \n= 0 . l = 0 . pc = e0). We show the control-.ow graph of the program below. .1 .2 .7 .3 .4 .5 .6 The \ntransition relation is de.ned as follows. ( ( .1(v, v) = (pc = e0 . pc ( ( .2(v, v) = (pc = e0 . pc ( \n.3(v, v() = (pc = e2 . pc ( ( .4(v, v) = (pc = e4 . pc ( ( .5(v, v) = (pc = e4 . pc ( ( .6(v, v) = (pc \n= e5 . pc ( .7(v, v() = (pc = e6 . pc ( ( next(v, v) = (.1(v, v) . \u00b7 \u00b7 = e2 . l( = l . gl( = gl) = e4 \n. l( = l . gl( = gl) = e4 . l = 0 . l( = 1) = e5 . gl ;= l . gl( = 0 . l( = e6 . gl = 0 . l( = l . gl( \n= e6 . l = 1 . l( = 0 . gl( = e0 . l( = l) ( \u00b7 . .7(v, v)) = gl) = gl) = gl) ( ( Note that in .3(v, \nv) and .7(v, v) the variable gl is assigned a non-deterministic value, since it is not constrained by \nthe corre\u00adsponding assertions. The execution of the program enters an error state at location e2 if the \nlock variable l is held, and at location e5 if the lock variable l is not held, i.e., we have error (v) \n= (pc = e2 . l = 1 . pc = e5 . l = 0). We instantiate the safety game proof rule such that the system \nrole is played by the program transition relation and the environ\u00adment role is to provide inputs to the \nprogram (in this case, the pro\u00adgram does not expect any inputs). ( ( eve(v, v) = next(v, v) ( ( adam(v, \nv) = skip(v, v) obj (v) = G \u00acerror (v) A repair of the program restricts the transition relation of the \npro\u00adgram such that G \u00acerror (v) holds. To this end, we provide a template corresponding to the existentially \nquanti.ed clause of the proof rule: ( (( ( (( = e4 . gl(( TEM P L(sk)(v, v, v) = (pc= e2 . pc=?1 ( (( \n. pc= e6 . pc= e0 . gl(( =?2) Our algorithm returns the witness for the existential quanti.er clause \nthat instantiates the template parameters ?1 = 1 and ?2 = 0. This corresponds to a repaired program that \nassigns the value 1 to gl at location e2, and assigns the value 0 to gl at location e6. We obtain the \nsame program repair as the solution originally presented in [29].  6.2 Concurrent program repair games \nwith safety and response objectives We illustrate how our approach can be applied to concurrent pro\u00adgram \nrepair problems, and in particular to repair problems under fairness assumptions. We use the CR I T IC \nA L SEC T I O N example from Figure 5 in [29] for this purpose. In this example, the assign\u00adment turn1B \n= false at location e2 is faulty. The goal is to re\u00adpair this assignment, and hence, the entire program \nby checking if there exists an assignment to the variable turn1B from its domain {true, false} such that \nthe resulting program satis.es certain tem\u00adporal properties. These properties are used in directing the \nrepair process towards the correct version of the program. Let (f1a, f1b, t1b, f2a, f2b, t2b) be abbreviations \nof origi\u00adnal variable names (.ag1A, .ag1B, turn1B, .ag2A, .ag2B, turn2B). We encode the original program \nover variables v = (pc 1, pc2, x, y, f1a, f1b, t1b, f2a, f2b, t2b) using an initial condi\u00adtion init(v) \nsuch that init(v) = (f1a = 0 . f1b = 0 . t1b = 0 . f2a = 0 . f2b = 0 . t2b = 0 . pc1 = e1 . pc2 = e1), \nand a transition relation next(v, v(). Since the program is multi\u00ad ( threaded with two threads, we give \nnext(v, v) as a disjunction of transition relations of individual threads (( (( next1(v, v) . pc2 = pc2 \n. next2(v, v) . pc1 = pc1. For the .rst thread we de.ne (note that we explicate assignments of ( a non-deterministic \nvalue to a variable z by z= ND and we omit equalities for variables that do not change, hence, each variable \nz ( ( that does not appear in z= . . . is constrained by z= z): ( ( next1(v, v) = (pc1 = e1 . pc1 = e2 \n. f1a( = 1 . ( pc1 = e2 . pc1 = e3 . t1b( = ND . ( pc1 = e3 . f1b = 1 . t1b = 1 . pc 1 = e3 . ( pc1 = \ne3 . (f1b = 0 . t1b = 0) . pc1 = e4 . ( pc1 = e4 . pc1 = e5 . f1a( = 0 . ( pc1 = e5 . t1b = 1 . pc1 = \ne6 . f2a( = 1 . ( pc1 = e5 . t1b = 1 . pc1 = e9 . ( pc1 = e6 . pc1 = e7 . t2b( = 1 . ( pc1 = e7 . f2b \n= 1 . t2b = 1 . pc1 = e7 . ( pc1 = e7 . (f2b = 0 . t2b = 0) . pc1 = e8 . ( pc1 = e8 . pc1 = e9 . f2a( \n= 0 . ( pc1 = e9 . pc1 = e1). Note that the second disjunct above leaves the value of t1b un\u00adrestricted, \nas denoted by t1b( = ND. For the second thread we de.ne: ( ( next2(v, v) = (pc2 = e1 . pc2 = e2 . f1b( \n= 1 . ( pc2 = e2 . pc2 = e3 . t1b( = 0 . ( pc2 = e3 . f1a = 1 . t1b = 0 . pc2 = e3 . ( pc2 = e3 . (f1a \n= 0 . t1b = 1) . pc2 = e4 . ( pc2 = e4 . pc2 = e5 . f2b( = 1 . ( pc2 = e5 . pc2 = e6 . t2b( = 0 . ( pc2 \n= e6 . f2a = 1 . t2b = 0 . pc2 = e6 . ( pc2 = e6 . (f2a = 0 . t2b = 1) . pc2 = e7 . ( pc2 = e7 . pc2 \n= e8 . f2b( = 0 . ( pc2 = e8 . pc2 = e9 . f1b( = 0 . ( pc2 = e9 . pc2 = e1). In the original problem \nthere are two properties directed by which the program should be repaired. The .rst property requires \nthat the two threads do not enter their critical sections at the same time. This property is speci.ed \nwith the following LTL formula. .1(v) = G ((pc1 = e4 . pc2 =;e4) . (pc1 = e8 . pc2 =;e7)) The second \nproperty requires that neither of the threads can be in a deadlock state. This property is speci.ed as \nfollows. .2(v) = G ((pc1 = e3 . F (pc1 = e4)) . (pc1 = e7 . F (pc1 = e8)) . (pc2 = e3 . F (pc2 = e4)) \n. (pc2 = e6 . F (pc2 = e7))) Safety game Doing the program repair using the .rst prop\u00aderty amounts to \napplying the safety proof rule from Figure 1 to .nd inv(v). Since there is no interaction with the environment, \n( ( adam(v, v) will simply be equivalent with skip(v, v). To apply ( ( our proof rule, we use next(v, \nv) for eve(v, v) and .1(v) as the winning condition obj . We use the following template for the exis\u00adtential \nclause: ( (( (( TE M PL(sk)(v, v, v) = (t1b =?1). CO N SY N T H computes the solution ?1 = 1, and correspond\u00adingly \nwe obtain a modi.ed version of next1(v, v() where the non\u00addeterministic assignment t1b( = ND from the \nsecond disjunct is replaced by t1b( = 1. Fair LTL game The second property relies on fairness assump\u00adtions. \nTo deal with the fairness, we apply a transformation tech\u00adnique from [36] that reduces fair parallelism \nsemantics to the usual parallelism semantics. The idea is to use the equivalence P |= f air F if and \nonly Tf air (P ) |= F, where P is the original program, Tf air is the fair transformation function, Tf \nair (P ) is the transformed program with embedded tracking of fairness, and F is the property to check. \nThe transformation does not change the ini\u00adtial states of the program, but it signi.cantly modi.es the \nsemantics of the transition relation of the program. A counter variable is in\u00adtroduced for each thread \nfrom the program, and the .rst statement of each loop is strengthened by adding a guard and an update \nin\u00advolving the counter variables. See [36] for details. For our example program, the transformation: \n introduces the counters k1 and k2,  adds the guard k1 = k2 and the update constraint (k1(= ND . k2(= \nk2 - 1) to the .rst, third and ninth disjunct  ( from next1(v, v),  adds the guard k2 = k1 and the \nupdate constraint (k1(= k1 - 1 . k2(= ND) to the .rst, third and sixth disjunct in next2(v, v(). Let \ninitT (v, k1, k2) = init(v) be the initial condition of the trans\u00adformed program. We refer to the transformed \ntransition relations ( ( as nextT 1(v, k1, k2, v, k1(, k2() and nextT 2(v, k1, k2, v, k1(, k2(), and \npresent them below. nextT 1(v, k1, k2, v(, k1(, k2() = ( (pc1 = e1 . pc1 = e2 . f1a( = 1 . k1 = k2 . \nk1(= ND . k2(= k2 - 1 . . . . . ( pc1 = e3 . f1b = 1 . t1b = 1 . pc1 = e3 . k1 = k2 . k1(= ND . k2(= \nk2 - 1 . . . . . ( pc1 = e7 . f2b = 1 . t2b = 1 . pc1 = e7 . k1 = k2 . k1(= ND . k2(= k2 - 1 . . . . \n) nextT 2(v, k1, k2, v(, k1(, k2() = ( (pc2 = e1 . pc2 = e2 . f1b( = 1 . k2 = k1 . k1(= k1 - 1 . k2(= \nND . . . . . ( pc 2 = e3 . f1a = 1 . t1b = 0 . pc2 = e3 . k2 = k1 . k1(= k1 - 1 . k2(= ND . . . . . ( \npc 2 = e6 . f2a = 1 . t2b = 0 . pc2 = e6 . k2 = k1 . k1(= k1 - 1 . k2(= ND . . . . ) The second property \nis more complicated than the .rst property since it involves nesting of temporal operators. Like the \ncase for ( the .rst property, we assume adam(v, v) to be equivalent with (( ( skip(v, v). We make nextT \n(v, v) to play the role of eve(v, v), and G ((pc1 = e3 . F pc1 = e4) . (pc 1 = e7 . F pc1 = e8) . (pc2 \n= e3 . F pc2 = e4) . (pc2 = e6 . F pc2 = e7)) is now a winning condition obj . We reuse the template \nused for the previous game and we get exactly the same solution. That is, we determine t1b( = ND to ( \nt1b( = 1 in the second disjunct of nextT 1(v, k1, k2, v, k1(, k2().  6.3 Synthesis of synchronization \ngame with safety objective Synthesis of synchronization in multi-threaded programs [45] can be automated \nusing our approach. For illustration, we use the example program from Figure 1 in [45] and represent \nit using a tuple (init(v), next(v, v(), error (v)) for the case when three threads are involved in computation. \nThe program variables are v = (x, y1, y2, z, pc1, pc2, pc3), the initial states are described by init(v) \n= (x = 0 . z = 0 . pc1 = e1 . pc2 = e1 . pc3 = e1). The transition relation of the program is ( ((( next(v, \nv) = (next1(v, v) . pc2 = pc2 . pc3 = pc3 . ((( next2(v, v) . pc1 = pc1 . pc3 = pc3 . ((( next3(v, v) \n. pc1 = pc1 . pc2 = pc2) such that ( next1(v, v) = (( (pc1 = e1 . pc1 = e2 . x= x + z . skip(y1, y2, \nz) . (( pc1 = e2 . pc1 = e3 . x= x + z . skip(y1, y2, z)) next2(v, v() = (( (pc2 = e1 . pc= z + 1 . skip(x, \ny1, y2) . 2 = e2 . z (( pc2 = e2 . pc= z + 1 . skip(x, y1, y2)) 2 = e3 . z next3(v, v() = (( (pc3 = e1 \n. pc 3 = e2 . x = 1 . y1 = 3 . skip(x, y2, z) . (( pc3 = e1 . pc 3 = e2 . x = 2 . y1 = 6 . skip(x, y2, \nz) . (( pc3 = e1 . pc 3 = e2 . (x = 0 . x = 3) . y1 = 5 . skip(x, y2, z) . (( pc3 = e2 . pc 3 = e3 . \ny2 = x . skip(x, y1, z) . ( pc3 = e3 . pc ; 3 = e4 . y1 = y2 . skip(x, y1, y2, z)). Different interleavings \nof the three threads lead to different values of y1 and y2. An assertion in the third thread at location \ne3 requires that the values given to y1 and y2 are not equal, i.e., we have error (v) = (pc3 = e3 . y1 \n= y2). For the given program, some interleavings lead to the values of y1 and y2 being equal, while \nother interleavings lead to distinct values for the two variables. The goal of [45] is to add synchronization \nto the program such that the assertion holds on all executions. To apply our proof rule to this problem, \nwe encode the choice between executing a single step and executing an atomic section using auxiliary \nvariables. The transition relation of the program is augmented with guards deciding a single step or \nan atomic section based on the values of the auxiliary variables. For our example, we use four auxiliary \nvariables (c11, c21, c31, c32). We obtain an extended tuple of variables w = (v, c11, c21, c31, c32). \nA constraint cij = e is used in thread i to decide that the control .ows from location ej to location \ne. Correspondingly, the transition relation of the .rst thread is augmented to: ( next1(w, w) = (( \n(pc1 = e1 . c11 = e2 . pc1 = e2 . x= x + z . skip(. . . ) . (( pc1 = e1 . c11 = e3 . pc1 = e3 . x= x \n+ 2 * z . skip(. . . ) . (( pc1 = e2 . pc 1 = e3 . x= x + z . skip(. . . )) The transition relations \nof the second and third thread are instru\u00admented similarly. We instantiate the safety game proof rule \nsuch that the system role is played by the instrumented program transi\u00adtion relation and the environment \nrole is to provide inputs to the program (similar to the previous case, this example program does not \nexpect any inputs). init(w) = init(v) eve(w, w() = (next1(w, w() . next2(w, w() . next3(w, w()) ( ( \nadam(w, w) = skip(w, w) Furthermore, we represent the search of initial parameter values us\u00ading a strengthening \nof the original initial condition with an assertion mid(w, t) such that: init(w) . .t : mid(w, t) (mid(w, \nt), eve(w, w(), adam(w, w()) |= G \u00acerror (w) We use CO NSY NT H and provide the following template for \nthe existential clause involving the initial states. TE M P L(sk)(w, t) = (c11 =?11 . c21 =?21 . c31 \n=?31 . c32 =?32).  Name Game Player p Objective for player p Result Time (z3) Time (Barcelogic) G1 Cinderella \n(c = 3) Cinderella G \u00acover.ow . 3.2s 1.2s G2 Cinderella (c = 2) Cinderella G \u00acover.ow . 1m52s 1m52s G3 \nCinderella (c = 1.4) Stepmother F over.ow . 18s 1m14s G4 Cinderella (c = 1.4) Cinderella win(0) . 7m16s \nSysError G5 Cinderella (c = 1.4) Cinderella win(0) . win(2) . 4.7s 4.7s G6 Repair-Lock Program G \u00acerror \n. 0.3s 0.3s G7 Repair-Critical Program G \u00acerror . 17.7s 16.9s G8 Repair-Critical Program G (at p . F \n\u00acat p) . 53.3s 3m6s G9 Synth-Synchronization Program G \u00acerror . T/O 1s Table 1. Statistics for case \nstudies. A T/O-mark stands for time out after 15 minutes. A solution to mid(w, t) sets the auxiliary \nvariables to target program locations so that the objective of the game is satis.ed, i.e., the error \nstates are not reachable. CO N SY N T H returns the following witness for the existential quanti.er clause: \nsk(w, t) = (c11 = 3 . c21 = 3 . c31 = 4 . c32 = 3). We note that our proof rule does not represent an \noptimization prob\u00adlem. The solutions we obtain correspond to a synthesized program that is not necessarily \nthe most ef.cient one, i.e., the longest atomic sections may be picked instead of smaller steps. Dealing \nwith opti\u00admality is a subject for future work. 7. Experimental results In this section we describe how \nwe used CON SYN TH as a proof\u00adof-concept implementation of our proposed approach to solving in.nite-state \ngames. CO N SY N T H is implemented in SICStus Pro\u00adlog and is a solver for Horn clauses over linear inequalities. \nThe implementation uses two SMT solvers for handling non-linear con\u00adstraints: the Z3 solver [13] and \nthe Barcelogic solver [5, 6]. For our experiments we used a computer with an Intel Core 2 Duo 2.53 GHz \nCPU and 4 GB of RAM. Table 1 shows the results corresponding to the case studies described in the paper: \nCinderella-Stepmother games with safety objectives (G1 and G2), with reachability objectives (G3) and \nwith more general LTL ob\u00adjectives (G4 and G5). Lastly, we show results on the program re\u00adpair/synthesis \ngames (G6, G7, G8 and G9). For each game we report the player and the objective for which we synthesize \nstrategies (see Columns 3 and 4). Column 5 shows the result obtained from our tool: an .-mark stands \nfor a strategy successfully synthesized by our tool using either Z3 or Barcelogic as solving back-ends. \nIn one case (G5), due to the general LTL ob\u00adjective we obtain a large B \u00a8uchi automaton. Our normal encoding \ntimes-out for both Z3 and Barcelogic. However, CONSYNTH can synthesize a winning strategy quickly if \nwe exploit an optimization where we treat in.nite datatypes symbolically using a decision pro\u00adcedure, \nand .nite domain datatypes explicitly without abstraction. Because the control locations of the B \u00a8uchi \nautomaton pc B range over a .nite domain, this optimization allows the tool to track the states of pcB \nexplicitly, and this simpli.es the proof obligations. We believe our approach will bene.t from future \nimprovements in constraint solving. The cases when either Z3 or Barcelogic times out are challenging \nSMT problems and of potential interest to the SMT-solving community. 8. Related work There is a rich \nliterature on decision procedures for graph games with application to formal methods [14, 32, 38, 43]. \nIn particular, many techniques, both explicit-state [43] and symbolic [25, 37], are known for games on \n.nite graphs. Decidability results are also known for games on certain restricted classes of in.nite \ngraphs, such as pushdown graphs [8, 46] and pre.x-recognizable graphs [9]. Known approaches to games \non graphs that represent state spaces of general in.nite-state programs can be divided into two categories: \nthose based on symbolic execution and those based on abstraction-re.nement. De Alfaro et al [12] offer \nan example of the .rst kind of approach. In this work, a symbolic semi-algorithm is used to explore the \nstate space of the game directly. In contrast, we reduce the problem of solving a game to Horn constraint \nsolving, leaving the constraints to be solved by a dedicated solver relying on CEGAR and interpolation. \nThe second category of methods [2, 15, 16, 22 24] lift predi\u00adcate abstraction and CEGAR, originally proposed \nfor safety veri\u00ad.cation, to games. The core idea here is the use of abstract tran\u00adsition systems where \noverapproximate ( may ) and underapprox\u00adimate ( must ) transitions are permitted, and which are model\u00adchecked \nagainst properties with 3-valued semantics. In contrast to existing approaches of this sort, we do not \ndirectly construct a pro\u00adgram abstraction with must-transitions or 3-valued semantics. In\u00adstead, we use \na Skolem relation that is iteratively re.ned. More\u00adover, our backend solver uses disjunctively well-founded \ntransition invariants [39] to resolve liveness goals for players, which (so far as we are aware) existing \napproaches do not do. This algorithmic difference has a signi.cant impact in practice. Our approach is \nperhaps more closely related to a recent paper by Cook and Koskinen [11], which uses a combination of \nCEGAR with a form of Skolemization for veri.cation of branching-time properties of programs. However, \nthis method only studies veri.ca\u00adtion of CTL the class of properties that we handle is signi.cantly \nlarger (e.g., it includes the full \u00b5-calculus). Games have a particularly close connection to program \nsyn\u00adthesis and repair, areas that have seen a .urry of activity in the last few years. However, in recent \nas well as classical algorithms in these areas, the focus is tends to be either on .nite-state sys\u00adtems \n[29, 38, 41], or on functional, rather than reactive, pro\u00adgrams [31, 42, 45]. In contrast, the natural \napplication of our ap\u00adproach is in the repair and synthesis of in.nite-state reactive pro\u00adgrams. Finally, \nour work here was inspired by the rich tradition of on deductive program synthesis [34, 38, 40]. The \nmain difference between this line of work and ours lies in our focus on automation. For example, Slanina \n[40] also offers a deductive rule for games with response objectives. However, the proof rule demands \nglobal ranking functions and justice and compassion assumptions, which are known to be dif.cult to discharge \nautomatically. 9. Conclusion We have presented a constraint based approach to computing win\u00adning strategies \nin in.nite-state games. The approach consists of: (1) a set of sound and relatively complete proof rules \nfor solving such games, and (2) automation of the rules on top of an existing auto\u00admated deduction engine. \nWe demonstrate the practical promise of our approach through several case studies using examples derived \nfrom prior work on program repair and synthesis. Many avenues for future work remain open. The system \nwe have presented is a prototype. Much more remains to be done on engineering it for greater scalability. \nIn particular, we are especially interested in applying the system to reactive synthesis questions arising \nout of embedded systems and robotics. On the theoretical end, exploring opportunities of synergy between \nour approach and abstraction-based [22, 24] and automata-theoretic approaches to games [43] remains a \nfascinating open question. Acknowledgements This research was supported in part by the ERC project 308125, \nby the DFG Graduiertenkolleg 1480 (PUMA), and by NSF Awards #1162076 and #1156059. References [1] R. \nAlur, P. Cern \u00b4y, P. Madhusudan, and W. Nam. Synthesis of interface speci.cations for java classes. In \nPOPL, pages 98 109, 2005. [2] T. Ball and O. Kupferman. An abstraction-re.nement framework for multi-agent \nsystems. In LICS, pages 379 388. IEEE, 2006. [3] T. Beyene, C. Popeea, and A. Rybalchenko. Solving existentially \nquanti.ed Horn clauses. In CAV, 2013. [4] M. Bodlaender, C. Hurkens, V. Kusters, F. Staals, G. Woeginger, \nand H. Zantema. Cinderella versus the Wicked Stepmother. In IFIP TCS, pages 57 71, 2012. [5] M. Bo.ll, \nR. Nieuwenhuis, A. Oliveras, E. Rodr\u00b4iguez-Carbonell, and A. Rubio. The Barcelogic SMT solver. In CAV, \npages 294 298, 2008. [6] C. Borralleras, S. Lucas, A. Oliveras, E. Rodr\u00b4iguez-Carbonell, and A. Rubio. \nSAT modulo linear arithmetic for solving polynomial constraints. J. Autom. Reasoning, 48(1):107 131, \n2012. [7] J. R. B \u00a8uchi and L. Landweber. Solving sequential conditions by .nite\u00adstate strategies. Trans. \nAmer. Math. Soc., 138:295 311, 1969. [8] T. Cachat. Symbolic strategy synthesis for games on pushdown \ngraphs. In ICALP, pages 704 715. 2002. [9] T. Cachat. Uniform solution of parity games on pre.x-recognizable \ngraphs. Electronic Notes in Theoretical Computer Science, 68(6):71 84, 2003. [10] K. Chatterjee and L. \nDoyen. Energy parity games. TCS, 2012. [11] B. Cook and E. Koskinen. Reasoning about nondeterminism in \npro\u00adgrams. In PLDI, 2013. [12] L. De Alfaro, T. Henzinger, and R. Majumdar. Symbolic algorithms for in.nite-state \ngames. In CONCUR, pages 536 550. Springer, 2001. [13] L. M. de Moura and N. Bj\u00f8rner. Z3: An ef.cient \nSMT solver. In TACAS, 2008. [14] E. A. Emerson and C. Jutla. Tree automata, mu-calculus and determi\u00adnacy. \nIn FOCS, pages 368 377. IEEE, 1991. [15] H. Fecher and M. Huth. Ranked predicate abstraction for branching \ntime: Complete, incremental, and precise. In ATVA, pages 322 336. Springer, 2006. [16] H. Fecher and \nS. Shoham. Local abstraction re.nement for the \u00b5\u00adcalculus. STTT, 13(4):289 306, 2011. [17] P. Gastin \nand D. Oddoux. Fast LTL to B \u00a8uchi automata translation. In CAV, pages 53 65, 2001. [18] E. Gr \u00a8adel, \nW. Thomas, and T. Wilke, editors. Automata, Logics, and In.nite Games: A Guide to Current Research, 2002. \n[19] S. Grebenshchikov, A. Gupta, N. P. Lopes, C. Popeea, and A. Ry\u00adbalchenko. HSF(C): A software veri.er \nbased on Horn clauses -(com\u00adpetition contribution). In TACAS, 2012. [20] S. Grebenshchikov, N. P. Lopes, \nC. Popeea, and A. Rybalchenko. Synthesizing software veri.ers from proof rules. In PLDI, 2012. [21] A. \nGriesmayer, R. Bloem, and B. Cook. Repair of boolean programs with an application to C. In CAV, pages \n358 371. Springer, 2006. [22] O. Grumberg, M. Lange, M. Leucker, and S. Shoham. Dont know in the \u00b5-calculus. \nIn VMCAI, pages 233 249, 2005. [23] O. Grumberg, M. Lange, M. Leucker, and S. Shoham. When not losing \nis better than winning: Abstraction and re.nement for the full \u00b5-calculus. Information and Computation, \n205(8):1130 1148, 2007. [24] A. Gur.nkel and M. Chechik. Why waste a perfectly good abstrac\u00adtion? In \nTACAS, pages 212 226. 2006. [25] A. Harding, M. Ryan, and P.-Y. Schobbens. A new algorithm for strategy \nsynthesis in ltl games. In TACASs, pages 477 492. Springer, 2005. [26] T. A. Henzinger, R. Jhala, and \nR. Majumdar. Counterexample-guided control. In ICALP, pages 886 902, 2003. [27] K. Hoder, N. Bj\u00f8rner, \nand L. M. de Moura. Z-an ef.cient engine for .xed points with constraints. In CAV, pages 457 462, 2011. \n[28] A. J. C. Hurkens, C. A. J. Hurkens, and G. J. Woeginger. How Cin\u00adderella won the bucket game (and \nlived happily ever after). Mathemat\u00adics Magazine, 84(4):pp. 278 283, 2011. [29] B. Jobstmann, A. Griesmayer, \nand R. Bloem. Program repair as a game. In CAV, pages 226 238, 2005. [30] M. Jurdzi \u00b4nski. Small progress \nmeasures for solving parity games. In STACS, pages 290 301, 2000. [31] V. Kuncak, M. Mayer, R. Piskac, \nand P. Suter. Complete functional synthesis. In PLDI, 2010. [32] O. Kupferman and M. Y. Vardi. Robust \nsatisfaction. In CONCUR, pages 383 398, 1999. [33] Z. Manna and A. Pnueli. Completing the temporal picture. \nTheor. Comput. Sci., 83(1):91 130, 1991. [34] Z. Manna and R. Waldinger. A deductive approach to program \nsyn\u00adthesis. TOPLAS, 2(1):90 121, 1980. [35] D. Martin. Borel determinacy. The Annals of Mathematics, \n102(2): 363 371, 1975. [36] E.-R. Olderog and K. R. Apt. Fairness in parallel programs: The transformational \napproach. TOPLAS, 10(3), 1988. [37] N. Piterman, A. Pnueli, and Y. Saar. Synthesis of reactive(1) designs. \nIn VMCAI, pages 364 380, 2006. [38] A. Pnueli and R. Rosner. On the synthesis of a reactive module. In \nPOPL, pages 179 190. ACM, 1989. [39] A. Podelski and A. Rybalchenko. Transition invariants. In LICS, \n2004. [40] M. Slanina. Control rules for reactive system games. In AAAI Spring Symposium on Logic-Based \nProgram Synthesis, 2002. [41] A. Solar-Lezama, L. Tancau, R. Bod\u00b4ik, S. A. Seshia, and V. A. Saraswat. \nCombinatorial sketching for .nite programs. In ASPLOS, pages 404 415, 2006. [42] S. Srivastava, S. Gulwani, \nand J. S. Foster. From program veri.cation to program synthesis. In POPL, pages 313 326, 2010. [43] W. \nThomas. On the synthesis of strategies in in.nite games. In STACS, pages 1 13, 1995. [44] M. Y. Vardi. \nVeri.cation of concurrent programs: The automata\u00adtheoretic framework. Ann. Pure Appl. Logic, 51(1-2):79 \n98, 1991. [45] M. T. Vechev, E. Yahav, and G. Yorsh. Abstraction-guided synthesis of synchronization. \nIn POPL, 2010. [46] I. Walukiewicz. Pushdown processes: Games and model-checking. Information and computation, \n164(2):234 263, 2001. [47] W. Zielonka. In.nite games on .nitely coloured graphs with applica\u00adtions to \nautomata on in.nite trees. Theoretical Computer Science, 200 (1):135 183, 1998.   \n\t\t\t", "proc_id": "2535838", "abstract": "<p>We present a constraint-based approach to computing winning strategies in two-player graph games over the state space of infinite-state programs. Such games have numerous applications in program verification and synthesis, including the synthesis of infinite-state reactive programs and branching-time verification of infinite-state programs. Our method handles games with winning conditions given by safety, reachability, and general Linear Temporal Logic (LTL) properties. For each property class, we give a deductive proof rule that --- provided a symbolic representation of the game players --- describes a winning strategy for a particular player. Our rules are sound and relatively complete. We show that these rules can be automated by using an off-the-shelf Horn constraint solver that supports existential quantification in clause heads. The practical promise of the rules is demonstrated through several case studies, including a challenging \"Cinderella-Stepmother game\" that allows infinite alternation of discrete and continuous choices by two players, as well as examples derived from prior work on program repair and synthesis.</p>", "authors": [{"name": "Tewodros Beyene", "author_profile_id": "82858720357", "affiliation": "Technische Universtit&#228;t Munchen, Munich, Germany", "person_id": "P4383803", "email_address": "tewodros@model.in.tum.de", "orcid_id": ""}, {"name": "Swarat Chaudhuri", "author_profile_id": "81309496839", "affiliation": "Rice University, Houston, USA", "person_id": "P4383804", "email_address": "swarat@rice.edu", "orcid_id": ""}, {"name": "Corneliu Popeea", "author_profile_id": "81100461244", "affiliation": "Technische Universtit&#228;t Munchen, Munich, Germany", "person_id": "P4383805", "email_address": "popeea@model.in.tum.de", "orcid_id": ""}, {"name": "Andrey Rybalchenko", "author_profile_id": "81100483883", "affiliation": "Microsoft Research Cambridge and Technische Universtit&#228;t Munchen, Cambridge, United Kingdom", "person_id": "P4383806", "email_address": "rybal@in.tum.de", "orcid_id": ""}], "doi_number": "10.1145/2535838.2535860", "year": "2014", "article_id": "2535860", "conference": "POPL", "title": "A constraint-based approach to solving games on infinite graphs", "url": "http://dl.acm.org/citation.cfm?id=2535860"}