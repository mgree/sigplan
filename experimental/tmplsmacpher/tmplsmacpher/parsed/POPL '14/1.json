{"article_publication_date": "01-08-2014", "fulltext": "\n A Galois Connection Calculus for Abstract Interpretation. Patrick Cousot Radhia Cousot CIMS.. , NYU, \nUSA pc uso @cims yu. u CNRS Emeritus, ENS, France rco ot ens.fr o t .n ed us@ Abstract We introduce \na Galois connection calculus for language independent3. Basic GC semantics Basic GCs are primitive abstractions \nof speci.cation of abstract interpretations used in programming language semantics, properties. Classical \nexamples are the identity abstraction S 1[hC, formal veri.cation, and static analysis. This Galois connection \ncalculus and its type K vi, >] JJ J [[C]h}(C), .iwith .}(P ) , S P , 1}(Q) , system are typed by abstract \ninterpretation. hC, vi, the top abstraction S vi], hC, vi >[hC, > Q .Q  ! > P .P Categories and Subject \nDescriptorsGeneral Terms D.2.4 [Software/Program Veri.cation] Algorithms, Languages, Reliability, Security, \nTheory, Veri.cation. Keywords Abstract Interpretation, Galois connection, Static Analysis, Veri.cation. \n1} , h}(}(C)), .i ! }(Q), the complement abstraction S .i, the .nite/in.nite sequence abstraction S \n\u00ac h}(C), .iwith .1(P ) , {Oi | O 2P ^i 2 , hC, vi  ! _ dom(O)} and 11(Q) , {O 2 transformer abstraction \nS [ ! }(C2), > Q .> > P .> K K hC, vi, the join abstraction S .} 1. Galois connections in Abstract \nInterpretation In Abstract interpretation [3, 4, 6, 7] concrete properties (for example (e.g.) JK \u00ac \u00ac[C], \nh}(C), .i ! of computations) are related to abstract properties (e.g. types). The abstract properties \nare always sound approximations of the con- JK 1[C] h}(C), , 11 h}(C1), .i ! crete properties (abstract \nproofs/static analyzes are always correct in the concrete) and are sometimes complete (proofs/analyzes \nof abstract properties can all be done in the abstract only). E.g. types are sound but incomplete [2] \nwhile abstract semantics are usually .1 J K 1 C1 | 8i 2dom(O): Oi 2Q}, the [C1,C2] , h}(C1 .C2), .i \n! . .i mapping relations to join-preserving (R) , A X . {y | 9x 2 complete [9]. The concrete domain hC, \nviand abstract domain .h}(C1) hA, 4iof properties are posets (partial orders being interpreted as transformers \nwith . X : hx, yi2R}, g({x})}, the function abstraction implication). When concrete properties all have \na 4-most precise 1 (g) , {hx, yi | y 2 7![C1,C2], h}(C1 abstraction, the correspondence is a Galois connection \n(GC) hC, 1 vi hA, 4iwith abstraction . 2C 7!A and concretiza\u00ad ! . 17! ! .7! J .i S 7!C2), .ih}(C1) \n7! }(C2), . K with .7!(P ) , A X . {f(x) | f 2P ^x 2X}, 17!(g) , C1 7!C2 }(C1): 8x 2X : f(x) 2 tion 1 \n2A 7!C satisfying 8P 2C : 8Q 2A : .(x) 4 y , x v J K F 1(y) ()expresses soundness and (best abstraction). \nEach adjoint ./1 uniquely determines the other 1/..A Galois retrac\u00adtion (or insertion) has . onto, so \n1 is one-to-one, and . o 1 is the identity. E.g. the interval abstraction [3, 4] of the power set }(C) \nof complete .-totally ordered sets C [{ 1, 1} is S I[hC, . 1I i, 1, 1]  hI(C[{ 1, 1}, .), iwith, h}(C), \n.i ! .I .I(X) , [min X, max X], min ;, 1, max ;, 1, 1I([a, b]) , {x 2C | a .x .b}, intervals S I(C \n[{ 1, 1}, .) JK {f 2 | 8X 2 g(X)}, 1. the cartesian abstraction S .[I, C], h}(I 7! C), .i ! .. . hI \n7!}(C), .iwith ..(X) , A i 2I . {x 2C | 9f 2I 7! C : f[i x] 2X}, 1.(Y ) , {f | 8i 2I : f(i) 2Y (i)}, \nand the pointwise extension ..of .to I, etc. 4. Galois connector semantics Galois connectors build a \nGC from GCs provided as parameters. Unary Galois connectors in- J1 K . 1 > . . 1o. > . . .o. hA, 4i \n ! vi C}, 4iand the pointwise connec\u00ad _  , clude the reduction connector S R[hC, vi !hA, 4i], . JK \n {[a, b] | a 2C [{ 1} ^b 2C [{1} ^a .b} [{[1, 1]}, 1 hC, vi ! and inclusion [a, b] [c, d] , c .a ^b \n.d.A Galois isomor- h{.(P ) | P 2 J hX 7! K , hX 7!C, . for the pointwise orderings v 4. Binary Ga\u00adlois \nconnectors include the composition connector S hA, 4ihas both . and 1 bijective. E.g. global tor S hC, \nvi X ! .1  phism hC, .i ! . F and local invariants are isomorphic by the right image abstraction \n.. 4i . and A, JK y[L, M] .y(P ) , A 11 . .iwith 1y  ! .y S # , h}(L.M), .i ` . {m | h`,mi2P }, 1y(Q) \n, {h`,mi | m 2 hA1, bi Q(`)}, and ..is the pointwise extension of inclusion .. 11o12 ! .2o.1 Equivalent \nformalizations of GC-based Abstract Interpre\u00ad uct connector S hL 7!}(M), J = hA2, vi? hC, hC,.i ! .1 \n12 hA2, vi ! .2 K : .) (where . is a static error), the prod\u00ad hA1, vi hA3, 4i , (hA1, bi hA3, 4i.i \n2. 11 12 J , hC1 .C2, ..bi hC1, .i* hC2, bi ! !hA2, hA, 4iare Galois retracts of/Galois iso\u00ad 1 tation \nGCs hC, vi ! . .1 .2 11.12 ! K morphic to numerous equivalent mathematical structures [6] such 4ias \njoin-preserving maps (.), meet-preserving maps (1), upper\u00adclosures (1 o .), Moore families ({1(Q) | Q \n2A}), Sierpi\u00b4nski topologies [5]({\u00ac1(Q) | Q 2A} where \u00ac is unique complemen\u00ad hA1 .A2, v.4i (gen\u00ad .1..2 \nJ !C2, hC1, ZK eralizing to tuples), the higher-order functional connector S 11 12 .i !hA1, vi=)hC2, \n4i !hA2, 6i .1 .2 > g !16ifor increasing maps and pointwise orderings . , hC1 1 . 12ogo.1 tation in \nthe concrete domain C, if any), principal downset families ! . 4i . hA1 A2, > f . .2ofo11 ({#v1(Q) | \nQ 2A} where #v x , {y 2C| y vx}), maximal convex congruences ({{P 2C| .(P )= .(1(Q))}| Q 2 vand 6.. # \n# # A}, soundness relations (also called abstraction relation, logical rela\u00adtion, or tensor product, \n. 4 = {hP, Qi| .(P ) 4 Q} = {hP, Qi | P v 1(Q)} = v 1-1 where f . {hx, f(x)i | x 2 dom(f)}, r r 0 = {hx, \nzi| 9y : hx, yi2r ^hy, zi2r 0}), and, for powersets C = }(C), A = }(A), polarities of rela\u00adtions (1(Q)= \n{x 2C | 8y 2Q : R(x, y)} where R = {hx, yi| x 21({y})}). . See the auxiliary materials. .. Work supported \nin part by the CMACS NSF award 0926166. Permission to make digital or hard copies of part or all of this \nwork for personal or classroom useis granted without fee provided that copies are not made or distributed \nfor pro.t or commercialadvantage and that copies bear this notice and the full citation on the .rst page. \nCopyrights for third\u00adparty components of this work must be honored. For all other uses, contact the owner/author(s). \nPOPL 14, January 22 24, 2014, San Diego, CA, USA. Copyright is held by the owner/author(s). ACM 978-1-4503-2544-8/14/01. \nhttp://dx.doi.org/10.1145/2535838.2537850 F # Z JK 5. Galois connection calculus The GC calculus G (to \nspecify veri.ers/analyzers compositionally) is x,. .. 2 X for program variables, `,. .. 2L for labels, \ne 2E for elements e ::= true |1 | 1| x | ` | e | .. ., s 2S for sets s ::= B | Z | X | L |{e}| [e, e] \n| I(s, o) | s 1 | s [s | s 7!s | s .s | }(s) | .. ., o 2 O for partial orders o ::= ) | , | . | . | | \n= |o-1 | o1 .o2 | o.| o\u00a8| .. ., p 2P for posets p ::= hs, oi, and g 2G for GCs g ::= 1[p] | >[p, e] | \nI[p, e, e] | y[s, s] | [[s] | \u00ac[s] | 1[s] | [s, s] | 7![s, s] | .[s, s] | .. . | R[g] | s g |g g | g \n* g | g =) g | .. .. The semantics of interval sets is S I(C, 4), (4 .C .C ? {[a, b]4 | a, b 2C} : !) \nwhere ! is a dynamic error (maybe not detectable by typing).  # # #_ #_ F J K PP PP 6. Abstraction Papers \nin semantics, veri.cation, and static analysis can be understood by extracting the semantic domain and \nGC which are used. For the interval example [3, 4, p. 247], J K the semantic domain S , }(^1) is that \nof (nonempty) sets of J K JKJK nonempty .nite or in.nite sequences of states in ^ , L .M made of a control \nstate in L and a memory state in M , X 7!V J KP JK mapping variables X to a complete total order hV, \n.i(e.g. hZ, J K 6ior h[minint, maxint], 6i). The static (or collecting) seman\u00adtics is the reachability \nabstraction of program properties in }(S) that is G. , [[^1] 1[^] y[L, M] with abstract domain hL 7! \n}(M), .i. The reduced interval cartesian reachabil\u00ad . ity abstraction is G = . , R[G. (L (.[X, V] (X \n I[hV, .i, 1, 1])))] that is the abstraction h}(}((L .(X 7! V))1)), .i1 hL 7! X 7! I(V [{ 1, 1}), iwhere \n\u00a8 . ! .(P ) , A ` . smash(A x . .I(..((.y(.1(.}(P ))))(`))(x))) and smash(A x 2X .[ax ,bx ]) reduces \nto A x 2X .[1, 1] when some [ax ,bx ] is the empty interval [1, 1] else to A x2X .[ax ,bx ]. 7. Typing \nAs usual with syntactic de.nitions, GC expression semantics may be unde.ned (i.e. . or !). This can be \n.xed for . by a type system that is an Abstract Interpretation of the properties }(Gc) of the semantics \nS g2Gc of expressions g 2G belong\u00ading to the class Gc , {hC, vi1 !hA, 4i|C, A are sets ^v2 }(C .C) ^4 \n2 }(A .A)} . [{., !}. Typing is formalized by a GC [2] h}(Gc), .i.T ! hT/., iwhere the preorder (.when \n1T is injective). In absence of a -most precise i.e. principal type, hence of a best abstraction .T , \nas e.g. in [15] for the poly-on types is_T , 1T(T) . 1T(T0) so that types T/.are considered up to the \nequivalence .= for this preorder = = is = 1T _ = T0 JK hedral abstraction, only one of . or 1 is used \n[7]. A GC expres- KJK JK JK sion g 2G has sound types T 2T such that {S g} .1T(T) K JJKJ i.e. S g2 1T(T) \nor .Gc(S g, Tg) for the soundness rela- J K JK JK JK tion .Gc(S, T ) , S 2 1T(T ). For GCs, this is \nequivalent to . T({S g}) T, where {S g} is the strongest property (col\u00adlecting semantics) of g and .T({S \ng}) is the best abstraction of g. The type soundness proof is by induction on the structure of the GC \nexpressions as in [2] (instead of operational subject reduction  i.e. induction on program computation \nsteps). 8. Types For elements E 2E, E ::= var | lab | bool | int |err with 1E(int) , Z [{ 1, 1}, 1E(err) \n, S(E) [{., !}. For sets S 2 S, S ::= P E | P S | seq S | S .! S | S .S | err with 1S(P E) , }(1E(E)), \n1S(P S) , }(1S(S)), 1S(seq S) , {X1 | X 21S(S)}, 1S(S1 .!S2) , {X 7!Y |X 21S(S1) ^Y 21S(S2)}, 1S(S1 .S2) \n, {X .Y | X 2 1S(S1) ^Y 21S(S2)}, 1S(err) , S(S) [{., !}. For partial orders O 2O, O ::= )| ,| .| .| \n= | O -1 |O?O | .O | .. . | err with 1O(O) , {O}, O 2{), ,, ., ., =}, ), {hfalse, falsei, htrue, truei}, \netc. For posets P 2P, P ::= S ~ O | err with componentwise concretization 1P(S ~ O) , 1S(S) .1O(O). \nFor GCs, T 2 T, T ::= = P | S . T | errP =! with 1 P 0 P 0 1T(P =!= P0) , {P.!| P 2 1P(P) ^ 2 1P(P0)} \n10 . . and 1T(S . T) , {hX 7!C, vi !hX 7!A, 4i| X 2 .0 1S(S) ^hC, vi1 !hA, 4i21T(T)}. . 9. Type inference \nThe type inference algorithm is Etrue, bool,. . . , E e, ( Ee= bool _Ee= int ? Ee: err ). For sets S \nB,P bool,. . . , S{e} ,( Ee=6err ? P Ee : . err ),. . . , Ss1 [ ,(err = S= S6s1 s2 6s1 s2 = err ? S: \nerr ) (note the approximation that s1 and s2 must have equivalent types as for alternatives of conditionals \nin functional languages). JK JKJKJK JKJK JKJKJK JKJK JFK JK JKK JK JKJKJK JKJ JJK JKJKJKJKJK JKJK JKJK \nJKJJKJ = JKJ KJK =P SJK JKJKJK KJJKKJK =P SJK JKJKJK JK = JK JK .JKJKJ_K JK_ JKJKJKJK JK JKJKJJKJK JKJK \nJK JK JK Ignoring error propagation, Ss 1 , seq Ss, Ss1 7! s2 ,  J K JK JK Ss1 .!Ss2 , Ss1 .s2 , Ss1 \n.Ss2 , S}(s), P Ss. J KJK For orders and posets, Oo, o, o 2 {), ,, ., ., =}, O, .,. . . , Oo\u00a8, ((O. o)), \nand P hs, oi, Ss~ Oo. For GCs, T1[p], Pp =Pp, Ty[sL,sM], P(SsL =! . SsM ) ~ =SsL .!P SsM ., T[[s], KP \n(P Ss) ~ =.=!= P Ss~ ., T\u00ac[s], P Ss~ .=!P Ss~ .-1 , T1[s] , .P =!(seq Ss) ~ .K=!P ~ S.s~ ., JT[s1,s2], \nP (S s1 .Ss2 )~.=!s1 .!P Ss2 ~.., T7![s1,s2], J K P P (Ss1 .!Ss2 ) ~.=!s1 .!P Ss2 ~.., T.[s1,s2], P (Ss1 \n.!Ss2 ) ~ .=!Ss1 .!P Ss2 ~ ., TR[g], Tg, Ts g, Ss. Tg,... Examples of type errors are T>[p, e], ( Ee=6err \n^9S 2 S, O 2O : Pp= S ~ O ^Ee S ? Pp=!p: err ) or=PTI[hs, oi,b, t] , (err 6Eb Ss6err ^err 6Et = == =(P \nS Ss? (P Ss~ .) =!s~ .) : err ) where abstracts set membership 2of top/botton elements to the abstracted \nset. This functional presentation is equivalent to a rule-based sys\u00ad g1 ` P1 =!P3 =!=P3P2,g2 ` P4, P2.tem \ne.g. = = = (where err is not deriv\u00ad g1#g2 ` P1 =!P4 g1 ` S1 ~O1 =!=S2 ~O2,g2 ` S3 ~O3 =!S4 ~O4 able), \n= , Id. for *.  g1=)g2 ` S1.!S3 ~O.3 =!=S2.!S4 ~O.4 Z. For example TG = = P (P (seq(P lab .(P var .!P \nint)))) = ~ \u00a8 ~ .=!(P lab .!P var .!P P int .) i.e. sets of sets of se\u00adquences of states are abstracted \nto a map of labels to variables to sets of integers (which includes intervals), ordered pointwise. 10. \nType soundness Typable expressions g 2 G (for which Tg6= err) cannot go wrong since then S g21T(Tg) [{!}and \n. 621T(Tg). However, dynamic errors (S g= !) cannot be excluded (e.g. int does not prevent over.ows). \n 11. Principal type Arbitrary concrete properties in }(Gc) may have no best abstraction (e.g. ;so we \nadd the empty type ?). Yet, by considering only semantic properties P = {S gi | i 2L} of GC expressions, \nthe principal type is .T(;) , ?, .T(P ) , [T].  .= when 8i 2 L 6; : T= T else .T(P ) , err so = gi 1T \nh}({S g| g 2G}), .i h(T [{?})/., i(.T onto). ! = .T 12. Types of types Types T ,{E, S, O, P, T} have \nproperties P , }(S T ) can be abstracted to types of types T::=?|E|S |O| P|T |err by .T(P ) , (P = ;? \n?| P .T, T 2T ? T : err). 13. Static analyzers In static analyzers [1, 12, 14] GCs specify abstract domains \nmodules and Galois connectors their combina\u00adtions by functors. For scalability, rapid convergence acceleration \nof in.nite .xpoint computations by widening/narrowing abstracting induction and/or their duals for co-induction \n[3 5] is effective and more precise than .nite abstractions [8]. Acknowledgments We warmly thank the \nACM SIGPLAN Awards Committee for awarding us the2013 Programming Languages Achievement Award and the \nprogramming languages community forits support. References [1] B. Blanchet, P. Cousot, R. Cousot, J. \nFeret, L. Mauborgne, A. Min\u00e9, D. Monniaux, and X. Rival. A static analyzerfor large safety-critical software. \nPLDI 03, 196 207. [2] P. Cousot. Types as abstract interpretations. POPL 97, 316 331. [3] P. Cousot and \nR. Cousot. Static determination of dynamic properties of programs. Proc. 2nd Int. Symp. on Programming, \n106 130, Paris, 1976. Dunod. [4] P. Cousot and R. Cousot. Abstract interpretation: A uni.ed lattice \nmodel for static analysis of programs by construction or approximation of .xpoints. POPL 77, 238 252. \n [5] P. Cousot and R. Cousot. Static determination of dynamic properties of recursive procedures. IFIP \nConf. on Formal Description of Programming Concepts, St-Andrews, N.B., CN, 237 277. North-Holland Pub. \nCo., 1977. [6] P. Cousot and R. Cousot. Systematic design of program analysis frameworks. POPL 79, 269 \n282. [7] P. Cousot and R. Cousot. Abstract interpretation frameworks. J. Logic and Comp., 2(4):511 547, \n1992. [8] P. Cousot and R. Cousot. Comparing the Galois connection and widening/narrowing approaches \nto abstract interpretation. PLILP 92, LNCS 631, 269 295. [9] P. Cousot and R. Cousot. Inductive de.nitions, \nsemantics and abstract interpretation. POPL 92, 83 94. [10] P. Cousot and R. Cousot. Temporal abstract \ninterpretation. POPL 00, 12 25. [11] P. Cousot and R. Cousot. Systematic design of program transformation \nframeworks by abstract interpretation.POPL 02, 178 190. [12] P. Cousot and R. Cousot. An abstract interpretation-based \nframework for software watermarking. POPL 04, 173 185. [13] P. Cousot and R. Cousot. An abstract interpretation \nframework for termination. POPL 12, 245 258. [14] P. Cousot, R. Cousot, and F. Logozzo. A parametric \nsegmentation functor for fully automatic and scalable arraycontent analysis. POPL 11, 105 118. [15] P. \nCousot and N. Halbwachs. Automatic discovery of linear restraints among variables of a program. POPL \n78, 84 96.  \n\t\t\t", "proc_id": "2535838", "abstract": "<p>We introduce a Galois connection calculus for language independent specification of abstract interpretations used in programming language semantics, formal verification, and static analysis. This Galois connection calculus and its type system are typed by abstract interpretation.</p>", "authors": [{"name": "Patrick` Cousot", "author_profile_id": "81100592699", "affiliation": "New York University, New York, NY, USA", "person_id": "P4383727", "email_address": "pcousot@cims.nyu.edu", "orcid_id": ""}, {"name": "Radhia Cousot", "author_profile_id": "81100592574", "affiliation": "&#201;cole normale sup&#233;reiure, Paris, France", "person_id": "P4383728", "email_address": "rcousot@ens.fr", "orcid_id": ""}], "doi_number": "10.1145/2535838.2537850", "year": "2014", "article_id": "2537850", "conference": "POPL", "title": "A galois connection calculus for abstract interpretation", "url": "http://dl.acm.org/citation.cfm?id=2537850"}