{"article_publication_date": "01-08-2014", "fulltext": "\n Sound Input Filter Generation for Integer Over.ow Errors Fan Long Stelios Sidiroglou-Douskos Deokhwan \nKim Martin Rinard {fanl, stelios, dkim, rinard}@csail.mit.edu MIT CSAIL Abstract We present a system, \nSIFT, for generating input .lters that nullify integer over.ow errors associated with critical program \nsites such as memory allocation or block copy sites. SIFT uses a static pro\u00adgram analysis to generate \n.lters that discard inputs that may trigger integer over.ow errors in the computations of the sizes of \nallocated memory blocks or the number of copied bytes in block copy opera\u00adtions. Unlike all previous \ntechniques of which we are aware, SIFT is sound if an input passes the .lter, it will not trigger an \ninteger over.ow error at any analyzed site. Our results show that SIFT successfully analyzes (and therefore \ngenerates sound input .lters for) 56 out of 58 memory allocation and block memory copy sites in analyzed \ninput processing modules from .ve applications (VLC, Dillo, Swfdec, Swftools, and GIMP). These nulli.ed \nerrors include six known integer over.ow vulnera\u00adbilities. Our results also show that applying these \n.lters to 62895 real-world inputs produces no false positives. The analysis and .l\u00adter generation times \nare all less than a second. Categories and Subject Descriptors F.3.2 [Semantics of Pro\u00adgramming Languages]: \nProgram Analysis; D.4.6 [Operating Sys\u00adtems]: Security and Protection General Terms Security; Program \nAnalysis Keywords Integer Over.ow; Abstraction; Soundness 1. Introduction Many security exploits target \nsoftware errors in deployed applica\u00adtions. One approach to nullifying vulnerabilities is to deploy input \n.lters that discard inputs that may trigger the errors. We present a new static analysis technique and \nimplemented system, SIFT, for automatically generating .lters that discard in\u00adputs that may trigger integer \nover.ow errors at analyzed memory allocation and block copy sites. We focus on this problem, in part, \nbecause of its practical importance. Because integer over.ows may enable code injection or other attacks, \nthey are an important source of security vulnerabilities [25, 33, 35]. 1.1 Previous Filter Generation \nSystems Standard .lter generation systems start with an input that triggers an error [10 12, 26, 36]. \nThey next use the input to generate an ex- Permission to make digital or hard copies of part or all of \nthis work for personal or classroom use is granted without fee provided that copies are not made or distributed \nfor pro.t or commercial advantage and that copies bear this notice and the full citation on the .rst \npage. Copyrights for third-party components of this work must be honored. For all other uses, contact \nthe owner/author(s). POPL 14, January 22 24, 2014, San Diego, CA, USA. Copyright is held by the owner/author(s). \nACM 978-1-4503-2544-8/14/01. http://dx.doi.org/10.1145/2535838.2535888  ecution trace and discover the \npath the program takes to the error. They then use a forward symbolic execution on the discovered path \n(and, in some cases, heuristically related paths) to derive a vulnera\u00adbility signature a boolean condition \nthat the input must satisfy to follow the same execution path through the program to trigger the same \nerror. The generated .lter discards inputs that satisfy the vul\u00adnerability signature. Because other unconsidered \npaths to the error may exist, these techniques are unsound (i.e., the .lter may miss inputs that exploit \nthe error). It is also possible to start with a potentially vulnerable site and use a weakest precondition \nanalysis to obtain an input .lter for that site. To the best of our knowledge, the only previous technique \nthat uses this approach [5] is unsound in that 1) it uses loop unrolling to eliminate loops and therefore \nanalyzes only a subset of the possible execution paths and 2) it does not specify a technique for dealing \nwith potentially aliased values. As is standard, the generated .lter incorporates execution path constraints, \ni.e., checks from conditional statements along the analyzed execution paths. The goal is to avoid .ltering \npotentially problematic inputs that the program would (because of safety checks at conditionals along \nthe execution path) process correctly. As a result, the generated input .lters perform a substantial \n(between 106 and 1010) number of operations. 1.2 SIFT SIFT starts with a set of critical expressions \nfrom memory allo\u00adcation and block copy sites. These expressions control the sizes of allocated or copied \nmemory blocks at these sites. SIFT then uses an interprocedural, demand-driven, weakest precondition \nstatic analy\u00adsis to propagate the critical expression backwards against the con\u00adtrol .ow. The result \nis a symbolic condition that captures all expres\u00adsions that the application may evaluate (in any execution) \nto obtain the values of critical expressions. The free variables in the sym\u00adbolic condition represent \nthe values of input .elds. In effect, the symbolic condition captures all of the possible computations \nthat the program may perform on the input .elds to obtain the values of critical expressions. Given an \ninput, the generated input .lter eval\u00aduates this condition over the corresponding input .elds to discard \ninputs that may cause an over.ow. Because SIFT takes all paths to analyzed memory allocation and block \ncopy sites into account, it generates sound .lters if an input passes the .lter, it will not trigger \nan over.ow in the evaluation of any critical expression (including the evaluation of intermediate expressions \nat distant program points that contribute to the value of the critical expression).1 1 As is standard \nin the .eld, SIFT is designed to work with programs that do not access uninitialized memory. Our analysis \ntherefore comes with the fol\u00adlowing soundness guarantee. If an input passes the .lter for a given critical \nexpression e, the input .eld annotations are correct (see Section 3.4), and the program has not yet accessed \nuninitialized memory when the program computes a value of e, then no integer over.ow occurs during the \nevaluation  1.3 No Execution Path Constraints Unlike standard techniques, SIFT incorporates no checks \nfrom the program s conditional statements and works only with arithmetic expressions that contribute \ndirectly to the values of the critical expressions. This design decision has the following consequences: \n Sound and Ef.cient Analysis: Ignoring execution path con\u00adstraints improves the ef.ciency of the analysis \nbecause it elimi\u00adnates the need to track the different constraints that may appear on the many different \nexecution paths to each memory alloca\u00adtion or block copy site. Indeed, this ef.ciency is critical to \nthe soundness of SIFT s analysis in general, there may be an intractably large or even statically unbounded \nnumber of paths to a given memory allocation or block copy site. Attempting to enumerate all of these \ndifferent execution paths to derive the complete set of execution path constraints is clearly infeasible \nand a major source of the unsoundness of previous techniques.  Ef.cient Filters: Because SIFT ignores \nchecks from condi\u00adtional statements, it generates much more ef.cient .lters than standard techniques \n(SIFT s .lters perform tens of operations as opposed to tens of thousands or more). Indeed, our experi\u00admental \nresults show that, in contrast to standard .lters, SIFT s .lters spend essentially all of their time \nreading the input (as opposed to checking if the input may trigger an over.ow error).  Accurate Filters: \nOne potential concern is that the program may contain safety checks that enable it to safely process \ninputs that would otherwise trigger over.ows. Ignoring these safety checks may cause the generated .lter \nto discard inputs even though the program can process them safely.  Our experimental results show that, \nin practice, ignoring execu\u00adtion path constraints results in no loss of accuracy. Speci.cally, we tested \nour generated .lters on 62895 real-world inputs for six benchmark applications and found no false positives \n(in\u00adcorrectly .ltered inputs that the program would have processed correctly). We attribute this potentially \ncounterintuitive result to the fact that standard integer data types usually contain enough bits to represent \nthe memory allocation sizes and block copy lengths that benign inputs typically elicit.  1.4 Input Fields \nWith Multiple Instantiations Input .les often contain multiple instantiations of the same input .eld \n(for example, when the input .le contains repeated compo\u00adnents that have the same format). SIFT works \nwith an abstraction in which free variables in the propagated symbolic expressions (and the .nal symbolic \ncondition) represent all instantiations of the cor\u00adresponding input .elds that they reference i.e., \nSIFT does not attempt to determine the precise correspondence between variables and different instantiations \nof the same input .eld. This design decision simpli.es and extends the range of the analysis. All variables \nthat reference the same input .eld are in\u00adterchangeable (because they all represent all possible instantiations \nof the corresponding input .eld). SIFT can therefore successfully analyze programs for which it is not \npossible to statically deter\u00admine the precise correspondence between variables and different instantiations \nof the same input .eld. This design decision also en\u00adables SIFT to analyze programs in which a single \nvariable may reference different instantiations of the same input .eld over the course of the execution. \nInterchangeability also enables a new ex\u00adpression normalization algorithm that renumbers variables during \nthe analysis of loops to obtain loop invariant expressions (see Sec\u00adtion 3.2). These expressions soundly \ncharacterize the effect (on the of e (including the evaluations of intermediate expressions that contribute \nto the .nal value of the critical expression). propagated symbolic expression) of loops that may access \nmultiple potentially different instantiations of the same input .eld. One .nal consequence of this design \ndecision is that the gener\u00adated input .lter must check all combinations of input .eld instanti\u00adations \nwhen it checks for potential over.ows (see Section 3.5). Our experimental results show that, for our \nbenchmark applications, this approach causes, at most, negligible overhead the generated .l\u00adters spend \nessentially all of their time reading the input. 1.5 Pointer Analysis and Precondition Generation SIFT \ngroups pointers into equivalence sets based on an analysis of the potential aliasing relationships between \ndifferent pointers. To analyze a load statement that loads a value via a pointer, SIFT generates a new \nvariable that represents the loaded value. In the propagated symbolic conditions, each such variable \nrepresents all values that may be stored via any alias of the pointer. This decision produces an appropriately \nimprecise abstraction that enables SIFT to successfully analyze programs for which it is not possible \nto statically determine the precise value that each vari\u00adable references. It also enables SIFT to work \nwith any sound pointer or alias analysis that provides SIFT with the aliasing information required to \nsoundly update the propagated symbolic condition at statements that access values via pointers (see Section \n3.2). To the best of our knowledge, this is the .rst paper to show how to soundly incorporate an arbitrary \noff-the-shelf alias or pointer analysis into a precondition generation algorithm. 1.6 SIFT Usage Model \nSIFT implements the following usage model: Module Identi.cation. Starting with an application that is \nde\u00adsigned to process inputs presented in one or more input formats, the developer identi.es the modules \nwithin the application that process inputs of interest. SIFT will analyze these modules to generate an \ninput .lter for the inputs that these modules process. Input Statement Annotation. The developer annotates \nthe rele\u00advant input statements in the source code of the modules to identify the input .eld that each \ninput statement reads. Critical Site Identi.cation. SIFT scans the modules to .nd all critical sites \n(currently, memory allocation and block copy sites). Each critical site has a critical expression that \ndetermines the size of the allocated or copied block of memory. The generated input .lter will discard \ninputs that may trigger an integer over.ow error during the computation of the value of the critical \nexpression. Static Analysis. For each critical expression, SIFT uses a demand\u00addriven backwards static \nprogram analysis to automatically derive the corresponding symbolic condition. Each conjunct expression \nin this condition speci.es, as a function of the input .elds, how the value of the critical expression \nis computed along one of the program paths to the corresponding critical site. Input Parser Acquisition. \nThe developer obtains (typically from open-source repositories such as Hachoir [1]) a parser for the \nde\u00adsired input format. This parser groups the input bit stream into input .elds, then makes these .elds \navailable via a standard API. Filter Generation. SIFT uses the input parser and symbolic condi\u00adtions \nto automatically generate the input .lter. When presented with an input, the .lter reads the .elds of \nthe input and, for each sym\u00adbolic expression in the conditions, determines if an integer over\u00ad.ow may \noccur when the expression is evaluated. If so, the .lter discards the input. Otherwise, it passes the \ninput along to the appli\u00adcation. The generated .lters can be deployed anywhere along the path from the \ninput source to the application that ultimately pro\u00adcesses the input.  1.7 Experimental Results We used \nSIFT to generate input .lters for modules in .ve real\u00adworld applications: VLC 0.8.6h (a network media \nplayer), Dillo 2.1 (a lightweight web browser), Swfdec 0.5.5 (a .ash video player), Swftools 0.9.1 (SWF \nmanipulation and generation utilities), and GIMP 2.8.0 (an image manipulation application). Together, \nthe analyzed modules contain 58 critical memory allocation and block copy sites. SIFT successfully generated \n.lters for 56 of these 58 critical sites (SIFT s static analysis was unable to derive symbolic conditions \nfor the remaining two critical sites, see Section 5.2 for more details). These applications contain six \nknown integer over.ow vulnerabilities at their critical sites. SIFT s .lters nullify all of these vulnerabilities. \nAnalysis and Filter Generation Times. We con.gured SIFT to analyze all critical sites in the analyzed \nmodules, then generate a single, high-performance composite .lter that checks for integer over.ow errors \nat all of the sites. The maximum time required to analyze all of the sites and generate the composite \n.lter was less than a second for each benchmark application. False Positive Evaluation. We used a web \ncrawler to obtain a set of at least 6000 real-world inputs for each application (for a total of 62895 \ninput .les). We found no false positives the corresponding composite .lters accept all of the input \n.les in this test set. Filter Performance. We measured the composite .lter execution time for each of \nthe 62895 input .les in our test set. The average time required to read and .lter each input was at most \n16 millisec\u00adonds, with this time dominated by the time required to read in the input .le.  1.8 Contributions \nThis paper makes the following contributions: SIFT: We present SIFT, a sound .lter generation system \nfor nullifying integer over.ow vulnerabilities. SIFT scans modules to .nd critical memory allocation \nand block copy sites, stati\u00adcally analyzes the code to automatically derive symbolic con\u00additions that \ncharacterize how the application may compute the sizes of the allocated or copied memory blocks, and \ngenerates input .lters that discard inputs that may trigger integer over.ow errors in the evaluation \nof these expressions. Unlike all previous techniques of which we are aware, SIFT is sound because it \ntakes all execution paths into consideration, if an input passes the generated .lter, it will not trigger \nan integer over.ow error at any analyzed site. Also unlike previous techniques, SIFT generates ef.cient \n.lters because SIFT ignores execution path constraints, the generated .lters perform tens of operations \n(as opposed to previous techniques, which incorporate execution path constraints and therefore perform \ntens of thousands or more operations).  Sound and Ef.cient Static Analysis: We present a new static \nanalysis that automatically derives symbolic conditions that capture, as a function of the input .elds, \nhow the integer values of critical expressions are computed along the various possible execution paths \nto the corresponding critical site. Unlike stan\u00addard precondition generation techniques, the SIFT static \nanaly\u00adsis does not incorporate checks from the program s conditional statements it instead works only \nwith the arithmetic opera\u00adtions that contribute directly to the values of the critical expres\u00adsions. \n Input Fields With Multiple Instantiations: We present a novel abstraction for input .elds with multiple \ninstantiations. This abstraction enables SIFT to analyze programs for which it is impossible to statically \ndetermine the precise correspondence  between variables and different instantiations of the same input \n.eld. With this abstraction, all variables that reference the same input .eld are interchangable (because \nthey all represent all in\u00adstantiations of that input .eld). This interchangability enables a new expression \nnormalization technique that SIFT deploys to automatically obtain invariants for loops that access the \nvalues of input .elds.  Pointer Analysis and Precondition Generation: We also present a novel abstraction \nfor values that load statements ac\u00adcess via pointers. This abstraction enables SIFT to analyze pro\u00adgrams \nfor which it is impossible to statically determine the precise value that each pointer references. We \nbelieve that this paper is the .rst to show how to soundly incorporate an arbi\u00adtrary off-the-shelf alias \nor pointer analysis into a precondition generation algorithm.  Experimental Results: We present experimental \nresults that illustrate the practical viability of our approach in protecting applications against integer \nover.ow vulnerabilities at memory allocation and block copy sites.  The rest of this paper is organized \nas follows. Section 2 presents a motivating example that illustrates how SIFT works. Section 3 presents \nthe core SIFT static analysis for C programs. Section 4 presents the formalization of the static analysis \nand discusses the soundness of the analysis. Section 5 presents the experimental results. Section 6 discusses \nrelated work. We conclude in Section 7. 2. Example We next present an example that illustrates how SIFT \nnulli.es an integer over.ow vulnerability in Swfdec 0.5.5, an open source shockwave .ash player. Figure \n1 presents (simpli.ed) source code from Swfdec. When Swfdec opens an SWF .le with embedded JPEG images, \nit calls jpeg_decoder_decode() (line 1 in Figure 1) to decode each JPEG image in the .le. This function \nin turn calls the func\u00adtion jpeg_decoder_start_of_frame() (line 7) to read the im\u00adage metadata and the \nfunction jpeg_decoder_init_decoder() (line 22) to allocate memory buffers for the JPEG image. There is \nan integer over.ow vulnerability at lines 43 47 where Swfdec calculates the size of the buffer for a \nJPEG image as: rowstride * (dec->height_block * 8 * max_v_sample / dec->components[i].v_subsample) At \nthis program point, rowstride equals: ((jpeg_width + 8 * max_h_sample -1) / (8 * max_h_sample)) * 8 * \nmax_h_sample / (max_h_sample / h_sample) while the rest of the expression equals ((jpeg_height + 8 * \nmax_v_sample -1) / (8 * max_v_sample)) * 8 * max_v_sample / (max_v_sample / v_sample) where jpeg_height \nis the 16-bit height input .eld value that Swfdec reads at line 9 and jpeg_width is the 16-bit width \ninput .eld value that Swfdec reads at line 11. h_sample is one of the horizontal sampling factor values \nthat Swfdec reads at line 14, while max_h_sample is the maximum horizontal sampling factor value. v_sample \nis one of the vertical sampling factor values that Swfdec reads at line 17, while max_v_sample is the \nmaximum vertical sampling factor value. Malicious inputs with speci.cally crafted values in these input \n.elds can cause the image buffer size calculation to over.ow. In this case Swfdec allocates an image \nbuffer that is smaller than required and eventually writes beyond the end of the allocated buffer. The \nloop at lines 13 20 reads multiple instantiations of the h_sample .eld and the v_sample .eld. Swfdec \ncomputes the , 32) - 1[32])/(8[32] C : safe((((sext(jpeg_width[16] , 32) + 8[32] \u00d7 sext(h_sample(1)[4] \n\u00d7 sext(h_sample(1)[4] , 32)) \u00d78[32] \u00d7 sext(h_sample(1)[4] , 32))/(sext(h_sample(1)[4] , 32)/ sext(h_sample(2)[4] \n, 32))) , 32) - 1[32])/(8[32] \u00d7(((sext(jpeg_height[16] , 32) + 8[32] \u00d7 sext(v_sample(1)[4] \u00d7 sext(v_sample(1)[4] \n, 32)) \u00d78[32] \u00d7 sext(v_sample(1)[4] , 32))/(sext(v_sample(1)[4] , 32)/ sext(v_sample(2)[4] , 32)))) Figure \n2. The symbolic condition C for the Swfdec example. Subexpressions in C are bit vector expressions. The \nsuperscript indicates the bit width of each expression atom. sext(v, w)\" is the signed extension operation \nthat transforms the value v to the bit width w. 1 int jpeg_decoder_decode(JpegDecoder *dec) { 2 ... 3 \njpeg_decoder_start_of_frame(dec, ...); 4 jpeg_decoder_init_decoder (dec); 5 ... 6 } 7 void jpeg_decoder_start_of_frame(JpegDecoder*dec){ \n8 ... 9 dec->height = jpeg_bits_get_u16_be (bits);  10 /* dec->height = SIFT_input(\"jpeg_height\", 16);*/ \n11 dec->width = jpeg_bits_get_u16_be (bits); 12 /* dec->width = SIFT_input(\"jpeg_width\", 16); */ 13 for \n(i = 0; i < dec->n_components; i++) { 14 dec->components[i].h_sample =getbits(bits, 4); 15 /* dec->components[i].h_sample \n= 16 SIFT_input(\"h_sample\", 4); */ 17 dec->components[i].v_sample =getbits(bits, 4); 18 /* dec->components[i].v_sample \n= 19 SIFT_input(\"v_sample\", 4); */ 20 } 21 } 22 void jpeg_decoder_init_decoder(JpegDecoder*dec){ 23 int \nmax_h_sample = 0; 24 int max_v_sample = 0; 25 int i; 26 for (i=0; i < dec->n_components; i++) { 27 max_h_sample \n= MAX(max_h_sample, 28 dec->components[i].h_sample); 29 max_v_sample = MAX(max_v_sample, 30 dec->components[i].v_sample); \n31 } 32 dec->width_blocks=(dec->width+8*max_h_sample-1) 33 / (8*max_h_sample); 34 dec->height_blocks=(dec->height+8*max_v_sample-1) \n35 / (8*max_v_sample); 36 for (i = 0; i < dec->n_components; i++) { 37 int rowstride; 38 int image_size; \n39 dec->components[i].h_subsample=max_h_sample / 40 dec->components[i].h_sample; 41 dec->components[i].v_subsample=max_v_sample \n/ 42 dec->components[i].v_sample; 43 rowstride=dec->width_blocks * 8 * max_h_sample / 44 dec->components[i].h_subsample; \n45 image_size=rowstride * (dec->height_blocks * 8 * 46 max_v_sample / dec->components[i].v_subsample); \n47 dec->components[i].image = malloc (image_size); 48 } 49 } Figure 1. Simpli.ed Swfdec source code. \nInput statement annota\u00adtions appear in comments. maximum values of these instantiations in the loop at \nlines 26 31. It then uses these maximum values to compute the size of the allocated buffer at each iteration \nin the loop (lines 36 48). Analysis Challenges: This example highlights several challenges that SIFT \nmust overcome to successfully analyze and generate a .lter for this program. First, the computation of \nthe expression for the size of the buffer uses the max_h_sample variable and the max_v_sample variable, \nwhich correspond to the maximum values of all instantiations of the h_sample .eld and the v_sample .eld. \nIt is impossible to statically determine the precise instantiation that these two variables represent. \nTo overcome this challenge, SIFT uses a novel abstraction in which variables in the propagated symbolic \ncondition represent all instantiations of the corresponding input .elds. Second, the source code snippet \ncontains many load/store state\u00adments that access values derived from input .elds via pointers. To reason \nsoundly about these load/store statements, SIFT uses an abstraction that enables SIFT to incorporate \nan off-the-shelf alias analysis [20]. Finally, Swfdec reads the input .elds (lines 14 and 17) and com\u00adputes \nthe size of the allocated memory block (lines 45-46) in the loops at different procedures. SIFT therefore \nuses an interprocedu\u00adral analysis that propagates the symbolic conditions across proce\u00addure boundaries \nto obtain precise symbolic conditions. SIFT also deploys a combination of a .xed point analysis and a \nnovel expres\u00adsion normalization technique to obtain loop invariants that success\u00adfully characterize the \neffect of loops on propagated expressions. We next describe how SIFT generates a sound input .lter to \nnullify this integer over.ow error. Source Code Annotations: SIFT provides a declarative speci.ca\u00adtion \ninterface that enables the developer to specify which state\u00adments read which input .elds. In this example, \nthe developer speci.es that the application reads the input .elds jpeg_height, jpeg_width, h_sample, \nand v_sample at lines 10, 12, 15 16, and 18 19 in Figure 1. SIFT uses this speci.cation to map the variables \ndec->height, dec->width, dec->components[i].h_sample, and dec->components[i].v_sample at lines 9, 11, \n14, and 17 to the corresponding input .eld values. Note that the input .elds h_sample and v_sample may \ncontain multiple instantiations, which Swfdec reads in the loop at lines 14 and 17. Compute Symbolic \nCondition: SIFT uses a demand-driven, inter\u00adprocedural, backward static analysis to compute the symbolic \ncon\u00addition C in Figure 2. We use the notation safe(e)\" in Figure 2 to denote that over.ow errors should \nnot occur in any step of the eval\u00aduation of the expression e. Subexpressions in C are in bit vector expression \nform so that the expressions accurately re.ect the rep\u00adresentation of the numbers inside the computer \nas .xed-length bit vectors as well as the semantics of arithmetic and logical operations as implemented \ninside the computer on these bit vectors. In Figure 2, the superscripts indicate the bit width of each \nexpression atom. sext(v, w) is the signed extension operation that transforms the value v to the bit \nwidth w. SIFT also tracks the sign of each arithmetic operation in C. For simplicity, Figure 2 omits \nthis information. Note that SIFT soundly handles the loops that access the in\u00adstantiations of the input \n.elds h_sample and v_sample. In the resulting .nal symbolic condition C, h_sample(1) represents the instantiation \nof the input .eld h_sample that corresponds to the program variable max_h_sample, while h_sample(2) rep\u00adresents \nthe instantiation that corresponds to the program vari\u00adable dec->components[i].h_sample. SIFT does not \nattempt to determine the precise instantiations that h_sample(1) and h_sample(2) represent. Instead, \nSIFT conservatively assumes that = h_sample(1) and h_sample(2) may independently represent any .rstS \n(s\") s = s\"; s\"\" .rstS (s) = instantiation of the .eld h_sample. SIFT handles v_sample simi-s otherwise \n.rstL(s) = the label of .rstS (s) = larly. \"\") \"\" s = s\"; s C includes all intermediate expressions \nevaluated at lines 32 last(s last(s) = i otherwise, i is the label of s 35 and 39 46. In this example, \nC contains only a single term of the form safe(e). In general, however, different program paths may \ncompute different values for the critical expression. In this case, labels(s) = the .nal symbolic condition \nC will contain multiple conjuncts of . .. .. \"\") \"\" labels(s\") . labels(ss = s\"; s {i} . labels(s\") s \n= i: while (x) { s\" } \"\" \" else s \"\") \") . labels(s s = i: if (x) s the form safe(e). Each conjuct captures \none of the ways that the program computes the value of the critical expression. Generate Input Filter: \nStarting with the symbolic condition C, SIFT generates an input .lter that discards any input that vio\u00ad \n{i} . labels(s {i} otherwise, i is the label of s Figure 4. De.nitions of .rstS , .rstL, last, and labels \nlates C, i.e., for any term safe(e) in C, the input triggers inte\u00adger over.ow errors when evaluating \ne (including all subexpres\u00adsions). The generated .lter extracts all instantiations of the in\u00adput .elds \njpeg_height, jpeg_width, h_sample, and v_sample (these are the input .elds that appear in C) from an \nincoming input. It then iterates over all combinations of pairs of the instantiations of the input .elds \nh_sample and v_sample to consider all possi\u00adble bindings of h_sample(1), h_sample(2), v_sample(1), and \nv_sample(2) in C. For each binding, it checks the entire evalua\u00adtion of C (including the evaluation of \nall subexpressions) for over\u00ad.ow. If there is no over.ow in any evaluation, the .lter accepts the input, \notherwise it rejects the input. 3. Static Analysis This section presents the SIFT static analysis algorithm. \nWe have implemented our static analysis for C programs using the LLVM Compiler Infrastructure [3]. 3.1 \nCore Language and Notation s := e: x = read(f) | e: x = c | e: x = y | e: x = y op z | e: x = *p | e: \n*p = x | e: p = malloc | e: skip | s\"; s\"\" | e: if (x) s\" else s\"\" | e: while (x) { s\" }  \" s, s, s\"\" \n. Statement f . InputField x, y, z, p . Var c . Int e . Label Figure 3. The core programming language \nFigure 3 presents the core language that we use to present the analysis. The language is modeled on a \nstandard lowered program representation in which 1) nested expressions are converted into sequences of \nstatements of the form e: x = y op z (where x, y, and z are either non-aliased variables or automatically \ngenerated temporaries, op represents binary arithmetic operations) and 2) all accesses to potentially \naliased memory locations occur in load or store statements of the form e: x = *p or e: *p = x. Each statement \ncontains a unique label e . Label. A statement of the form e: x = read(f) reads a value from an input \n.eld f . Because the input may contain multiple instantiations of the .eld f, different executions of \nthe statement may return different values. For example, the loop at lines 14 17 in Figure 1 reads multiple \ninstantiations of the h_sample and v_sample input .elds. Labels and Pointer Analysis: Figure 4 presents \nfour utility func\u00adtions 1) .rstS : Statement . Statement, 2) .rstL : Statement . Label, 3) last : Statement \n. Label, and 4) labels : Statement . Label in our notations. Given a statement s, .rstS (s) maps s to \nthe .rst atomic statement inside s, .rstL(s) maps s to the label that corresponds to the .rst atomic \nstatement inside s, last(s) maps s to the label that corresponds to the last atomic statement inside \ns, and labels(s) maps s to the set of labels that are inside s. We use LoadLabel and StoreLabel to denote \nthe set of la\u00adbels that correspond to load and store statements, respectively. LoadLabel . Label and \nStoreLabel . Label. Our static analysis uses the DSA pointer analysis [20] in combi\u00adnation with the basic \npointer analysis pass in LLVM [2] to disam\u00adbiguate aliases at load and store statements. Our underlying \npointer analysis [2, 20] provides two functions no_alias and must_alias: no_alias : (StoreLabel \u00d7 LoadLabel) \n. Bool must_alias : (StoreLabel \u00d7 LoadLabel) . Bool We assume that the underlying pointer analysis is \nsound so that 1) no_alias(estore, eload) = true only if the load statement at the label eload will never \nretrieve a value stored by the store statement at label estore; 2) must_alias(estore, eload) = true only \nif the load statement at the label eload will always retrieve the last value stored by the store statement \nat label estore (see Section 4.2 for a formal de.nition of the soundness requirements that the alias \nanalysis must satisfy). 3.2 Intraprocedural Analysis Because it works with a lowered representation, \nour static analysis starts with a variable v at a critical program point. It then propagates v backward \nagainst the control .ow to the program entry point. In this way the analysis computes a symbolic condition \nthat soundly captures how the program, starting with input .eld values, may compute the value of v at \nthe critical program point. The generated .lters use the analysis results to check whether the input \nmay trigger an integer over.ow error in any of these computations. C := C . safe(e) | safe(e) e := e\" \nop e\"\" | atom atom := x | c | f(id) | e(id) id . Index = {1, 2, . . .} x . Var c . Int e . LoadLabel \nf . InputField Figure 5. The condition syntax Condition Syntax: Figure 5 presents the de.nition of symbolic \nconditions that our analysis manipulates and propagates. A con\u00addition C consists of a set of conjuncts \nof the form safe(e). Each conjuct safe(e) requires that the evaluation of the symbolic expres\u00adsion e \n(including all subcomputations in the evaluation, see Sec\u00adtion 4.5) should not trigger an over.ow. Symbolic \nconditions C may contain four kinds of atoms: c represents a constant, x represents the variable x, f(id) \nrepresents a value from the input .eld f, and e(id) represents a value returned by the load statement \nwith the label e. Abstraction for Input Field Instantiations: An atom f (id) in a symbolic condition \nC represents the value of an arbitrary instantia\u00adtion of the input .eld f. The analysis uses the natural \nnumber id to distinguish values of potentially different instantiations of f . So all occurrences of \na given atom f(id) in a symbolic condition C rep\u00adresent the same value. If id1 id2, then f(id1) and f \n(id2) may =  F (e: x = c , e F (e: x = y , e F (e: x = y op z , e \" \"\" \" F (s ; s , e \" \"\" \"\" F (s ; \ns , e \" \"\" F (e: if (v) s else s , e \" \"\" \" F (e: if (v) s else s , e \" \"\" \"\" F (e: if (v) s else s \n, e F (e: while (v) { s \" } , e F (e: while (v) { s \" } , e \" F (e: p = malloc , e F (e: x = read(f) \n, e F (e: x = *p , e F (e: *p = x , e , C) = C[c/x] , C) = C[y/x] , C) = C[y op z/x] . labels(s \" ) \n, C) = F (s \" , e \" , C ) \"\" \" \" \"\" \"\" . labels(s ), C) = F (s , last(s ), F (s , e , C )) \" \" \"\" \"\" \n, C) = F (s , last(s ), C ) . F (s , last(s ), C ) . labels(s \" ) , C) = F (s \" , e \" , C ) \"\" \"\" \"\" \n . labels(s ), C) = F (s , e , C ) , C) = C.x . C where C.x = norm(F (s \" , last(s \" ), C.x . C)) . \nlabels(s \" ) , C) = F (s, e, F (s \" , e \" , C )) , C) = C , C) = C[f(id)/x] where id is fresh , C) = \nC[e(id)/x] where id is fresh , C) = C(e1(id1), e, x)(e2(id2), e, x) \u00b7 \u00b7 \u00b7 (en(idn), e, x) for all e1(id1), \n\u00b7 \u00b7 \u00b7 , en(idn) in C . . C if no_alias(e, ei) where C(ei(idi), e, x) = C[x/ei(idi)] if \u00ac no_alias(e, \nei) . must_alias(e, ei) . C[x/ei(idi)] . C if \u00ac no_alias(e, ei) . \u00ac must_alias(e, ei) Figure 6. Static \nanalysis rules. The notation C[e \" /e] denotes the symbolic condition obtained by replacing every occurrence \nof e in C with e \" . norm(C) is the normalization function that transforms the symbolic condition C to \nan equivalent normalized condition. represent different instantiations of f (and may therefore represent \ndifferent values). Abstraction for Values Accessed via Pointers: An atom e(id)in a symbolic condition \nC represents an arbitrary value returned by the load statement at the label e. The analysis uses the \nnatural number id to distinguish potentially different values loaded at different executions of the load \nstatement. Our analysis materializes atoms of the form e(id) in the propagated symbolic condition when \nit analyzes the load statement at the label e. The analysis will eventually replace these atoms with \nappropriate expressions based on the aliasing information when it analyzes store statements that may \nstore the corresponding value from the previously analyzed load statement at e. In our abstraction, e(id) \nrepresents an arbitrary value that may be stored via any alias of the pointer dereferenced at e during \nthe execution from the starting point of the program to the current program point of the propagated symbolic \ncondition C along any possible execution path (see Section 4.5). Analysis Framework: Given a sequence \nof statements s, a label e within s (e . labels(s)), and a symbolic condition C at the program point \nafter the corresponding statement at the label e, our demand-driven backwards analysis computes a symbolic \ncondition F (s, e, C ). The analysis ensures that if F (s, e, C ) holds before executing s, then C will \nhold whenever the execution reaches the program point after the corresponding statement at the label \ne (see Section 4.6 for the formal de.nition). Given a program s0 as a sequence of statements and a variable \nv at a critical site associated with the label e, our analysis generates the condition F (s0, e, safe(v)) \nto create an input .lter that checks whether the input may trigger an integer over.ow error in the computations \nthat the program performs to obtain the value of v at the critical site. Analysis of Assignment, Conditional, \nand Sequence State\u00adments: Figure 6 presents the analysis rules for basic program statements. The analysis \nof assignment statements replaces the as\u00adsigned variable x with the assigned value (c, y, y op z, or \nf(id), depending on the assignment statement). Here the notation C[e \" /e] denotes the new symbolic condition \nobtained by replacing every occurrence of e in C with e \". The analysis rule for the input read statement \nmaterializes a new id to represent the read value f(id), because the variable x may get the value of \na fresh instantiation of the input .eld f after the statement. This mechanism enables the analysis to \ncorrectly distinguish potentially different instantiations of the same input .eld (because values from \npotentially different instantiations have different ids). If the label e identi.es the end of a conditional \nstatement, the analysis of the statement takes the union of the symbolic condi\u00adtions from the analysis \nof the true and false branches of the condi\u00adtional statement. The resulting symbolic condition correctly \ntakes the execution of both branches into account. If the label e identi.es a program point within one \nof the branches of a conditional state\u00adment, the analysis will propagate the condition from that branch \nonly. The analysis of sequences of statements propagates the sym\u00adbolic condition backwards through the \nstatements in sequence. Analysis of Load and Store Statements: The analysis of a load statement x = *p \nreplaces the assigned variable x with a material\u00adized abstract value e(id) that represents the loaded \nvalue. For input read statements, the analysis uses a newly materialized id to distin\u00adguish values read \non different executions of the load statement. The analysis of a store statement *p = x uses the alias \nanalysis to appropriately match the stored value x against all loads that may return that value. Speci.cally, \nthe analysis locates all e(id) atoms in C that either may or must load a value v that the store state\u00adment \nstores into the location p. If the alias analysis determines that the e(id) expression must load x (i.e., \nthe corresponding load state\u00adment will always access the last value that the store statement stored into \nlocation p), then the analysis of the store statement replaces all occurrences of e(id) with x. If the \nalias analysis determines that the e(id) expression may load x (i.e., on some executions the cor\u00adresponding \nload statement may load x, on others it may not), then the analysis produces two symbolic conditions: \none with e(id) re\u00adplaced by x (for executions in which the load statement loads x) and one that leaves \ne(id) in place (for executions in which the load statement loads a value other than x). We note that, \nif the pointer analysis is imprecise, the symbolic condition may become intractably large. SIFT uses \nthe DSA algo\u00adrithm [20], a context-sensitive, uni.cation-based pointer analysis. We found that, in practice, \nthis analysis is precise enough to en\u00adable SIFT to ef.ciently analyze our benchmark applications (see \nFigure 13 in Section 5.2). Analysis of Loop Statements: The analysis uses a .xed-point al\u00adgorithm to \nsynthesize the loop invariant C.x required to analyze while loops. Speci.cally, the analysis of a statement \nwhile (x) { s \" } computes a sequence of symbolic conditions Ci, where C0 = \u00d8 and Ci = norm(F (s \" , \nlast(s \" ), C .Ci-1)). Conceptually, Input : original expression eorig Output: normalized expression \nenorm 1 enorm .- eorig 2 counter.eld .- {_ . 0}3 counterlabel .- {_ . 0}4 for a in atoms(eorig) do 5 \nif a is in form f(id) then 6 n \" .- counter.eld(f) + 1 7 counter.eld .- counter.eld[f . n \" ] \" 8 \nenorm .- enorm[*f(n )/f(id)] 9 else if a is in form e(id) then 10 n \" .- counterlabel (e) + 1 11 counterlabel \n.- counterlabel [e . n \" ] 12 enorm .- enorm[*e(n \" )/e(id)] 13 for a in atoms(enorm) do 14 if a is \nin form *f(id) then 15 enorm .- enorm[f(id)/ * f(id)] 16 else if a is in form *e(id) then 17 enorm \n.- enorm[e(id)/ * e(id)] Figure 7. Normalization function norm(e). atoms(e) is a list that iterates over \nthe distinct atoms in the expression e from left to right in order. The pseudo-code introduces temporary \natoms of the forms *f (id) and *e(id) to avoid con.icts with existing original atoms in enorm. each successive \nsymbolic condition Ci captures the effect of exe\u00adcuting an additional loop iteration. The analysis terminates \nwhen it reaches a .xed point (i.e., when it has performed n iterations such that Cn = Cn-1). Here Cn \nis the discovered loop invariant. This .xed point correctly summarizes the effect of the loop (regardless \nof the number of iterations that it may perform). The loop analysis normalizes the analysis result F \n(s \" , last(s \" ), C . Ci-1) after each iteration. For a sym\u00adbolic condition C = safe(e1) . \u00b7 \u00b7 \u00b7 . safe(en), \nthe normalization of C is norm(C) = remove_dup(safe(norm(e1)) . \u00b7 \u00b7 \u00b7 . safe(norm(en))), where norm(ei) \nis the normalization of each individual expression in C (using the algorithm presented in Figure 7) and \nremove_dup() removes duplicate conjuncts from the condition. Normalization facilitates loop invariant \ndiscovery for loops that read input .elds or load values via pointers. Each analysis of the loop body \nduring the .xed point computation produces new mate\u00adrialized values f(id) and e(id) with fresh id s. \nThe materialized f(id) represent values of input .eld instantiations that the current loop iteration \nreads; the materialized e(id) represent values that the current loop iteration loads via pointers. The \nnormalization algo\u00adrithm appropriately renumbers these ids in the new symbolic con\u00addition so that the \n.rst appearance of each id is in lexicographic order. This normalization enables the analysis to recognize \nloop in\u00advariants that show up as equivalent successive analysis results that differ only in the materialized \nid s that they use to represent input .eld instantiations and values accessed via pointers. The normalization \nalgorithm is sound because 1) all occur\u00adrences of f(id1), ..., f (idk) are interchangeable, and 2) the \nnor\u00admalization only renumbers the id1, ..., idk. The normalized con\u00addition is therefore equivalent to \nthe original condition (see Sec\u00adtion 4.6). The normalization algorithm will reach a .xed point and termi\u00adnate \nif it computes the symbolic condition of a value that depends on at most a statically .xed number of \nvalues from the loop itera\u00adtions. For example, our algorithm is able to compute the symbolic 1 F (i: \nv = call proc v1 \u00b7 \u00b7 \u00b7 vk, i, C ) 2 where proc = proc(a1, a2, \u00b7 \u00b7 \u00b7 , ak) { s; return vret } and 3 i1(id1), \n\u00b7 \u00b7 \u00b7 , in(idn) are all atoms of the form i(id) in C 4 begin \" 5 C .- \u00d8 6 Cv .- F (s, last(s), safe(vret \n)) 7 for ev in exprs(Cv[v1/a1] \u00b7 \u00b7 \u00b7 [vk/ak]) do 8 C1 .- F (s, last(s), safe(i1(id1))) 9 for e1 in \nexprs(C1[v1/a1] \u00b7 \u00b7 \u00b7 [vk/ak]) do 10 \u00b7 \u00b7 \u00b7 11 Cn .- F (s, last(s), safe(in(idn))) 12 for en in exprs(Cn[v1/a1] \n\u00b7 \u00b7 \u00b7 [vk/ak]) do \" 13 e .- make_fresh(ev, C ) v \" 14 e1 .- make_fresh(e1, C ) 15 \u00b7 \u00b7 \u00b7 \" 16 e .- \nmake_fresh(en, C ) n 17 C \" . \"\" \" C \" . C[e /v][e /i1(id1)] \u00b7 \u00b7 \u00b7 [e /in(idn)] v 1 n \" 18 return C \nFigure 8. Procedure call analysis algorithm. exprs(C) re\u00ad turns the set of expressions that appear in \nthe conjuncts of C. For example, exprs(safe(e1) . safe(e2)) = {e1, e2}. make_fresh(e, C ) renumbers ids \nin e so that atoms of the forms e(id) and f (id) will not con.ict with existing atoms in C. condition \nof the size parameter value of the memory allocation sites in Figure 1 the value of this size parameter \ndepends only on the values of jpeg_width and jpeg_height, the current values of h_sample and v_sample, \nand the maximum values of h_sample and v_sample, each of which comes from one previous iteration of the \nloop at line 26 31. Note that the algorithm will not reach a .xed point if it attempts to compute a symbolic \ncondition that contains an unbounded num\u00adber of values from different loop iterations. For example, the \nalgo\u00adrithm will not reach a .xed point if it attempts to compute a sym\u00adbolic condition for the sum of \na set of numbers computed within the loop (the sum depends on values from all loop iterations). To ensure \ntermination, our current implemented algorithm terminates the analysis and fails to generate a symbolic \ncondition C if it fails to reach a .xed point after ten iterations. In practice, we expect that many \nprograms may contain expres\u00adsions whose values depend on an unbounded number of values from different \nloop iterations. Our analysis can successfully ana\u00adlyze such programs because it is demand driven it \nonly attempts to obtain precise symbolic representations of expressions that may contribute to the values \nof expressions in the analyzed symbolic condition C (which, in our current system, are ultimately derived \nfrom expressions that appear at memory allocation and block copy sites). Our experimental results indicate \nthat our approach is, in practice, effective for this set of expressions, speci.cally because these expressions \ntend to depend on at most a .xed number of val\u00adues from loop iterations. 3.3 Interprocedural Analysis \nAnalyzing Procedure Calls: Figure 8 presents the interprocedural analysis for procedure call sites. Given \na symbolic condition C and a function call statement e: v = call proc v1 \u00b7 \u00b7 \u00b7 vk that invokes a procedure \nproc(a1, a2, \u00b7 \u00b7 \u00b7 , ak) { s; return vret }, the analysis computes F (e: v = call proc v1 \u00b7 \u00b7 \u00b7 vk, e, \nC ). Conceptually, the analysis performs two tasks. First, it replaces any occurrences of the procedure \nreturn value v in C (the sym\u00adbolic condition after the procedure call) with symbolic expressions that \nrepresent the values that the procedure may return. Second, it transforms C to re.ect the effect of any \nstore instructions that the procedure may execute. Speci.cally, the analysis .nds expressions e(id) in \nC that represent values that 1) the procedure may store into a location p 2) that the computation following \nthe procedure may access via a load instruction that may access (a potentially aliased version of) p. \nIt then replaces occurrences of e(id) in C with sym\u00adbolic expressions that represent the corresponding \nvalues computed (and stored into p) within the procedure. The analysis examines the invoked procedural \nbody s to obtain the symbolic expressions that corresponds to the return value (see line 6) or the value \nof e(id) (see lines 8 and 11). The analysis avoids redundant analysis of the invoked procedure by caching \nthe analy\u00adsis results F (s, last(s), safe(vret )) and F (s, last(s), safe(e(id))) for reuse. Note that \nsymbolic expressions derived from an analysis of the invoked procedure may contain occurrences of the \nformal param\u00adeters a1, ..., ak. The interprocedural analysis translates these sym\u00adbolic expressions into \nthe name space of the caller by replacing oc\u00adcurrences of the formal parameters a1, ..., ak with the \ncorrespond\u00ading actual parameters v1, ..., vk from the call site (see lines 7, 9, and 12 in Figure 8). \nAlso note that the analysis renumbers the ids in the symbolic expressions derived from an analysis of \nthe invoked procedure before the replacements (see lines 13 16). This ensures that the atoms of the forms \nf(id) and e(id) in the expressions are fresh and will not con.ict with existing atoms in C after replacements. \nPropagation to Program Entry: To derive the .nal symbolic condition at the start of the program, the \nanalysis propagates the current symbolic condition up the call tree through procedure calls until it \nreaches the start of the program. When the propagation reaches the entry of the current procedure proc, \nthe algorithm uses the procedure call graph to .nd all call sites that may invoke proc. It then propagates \nthe current symbolic condition C to the callers of proc, appropriately translating C into the naming \ncontext of the caller by substituting any formal parameters of proc that appear in C with the corresponding \nactual parameters from the call site. The analysis continues this propagation until it has traced out \nall paths in the call graph from the initial critical site where the analysis started to the program \nentry point. The .nal symbolic condition C is the conjunction of the conditions derived along all of \nthese paths.  3.4 Extension to C Programs We next describe how to extend our analysis to real world \nC programs to generate input .lters. Identify Critical Sites: SIFT transforms the application source \ncode into the LLVM intermediate representation (IR) [3], scans the IR to identify critical values (i.e., \nsize parameters of memory al\u00adlocation and block copy call sites) inside the developer speci.ed module, \nand then performs the static analysis for each identi.ed critical value. By default, SIFT recognizes \ncalls to standard C mem\u00adory allocation routines (such as malloc, calloc, and realloc) and block copy \nroutines (such as memcpy) as critical sites. SIFT can also be con.gured to recognize additional memory \nallocation and block copy routines (for example, dMalloc in Dillo). Bit Width and Signedness: SIFT extends \nthe analysis described above to track the bit width of each expression atom. It also tracks the sign \nof each expression atom and arithmetic operation and cor\u00adrectly handles extension and truncation operations \n(i.e., signed ex\u00adtension, unsigned extension, and truncation) that change the width of a bit vector. \nSIFT therefore faithfully implements the represen\u00adtation of integer values in the C program. Function \nPointers and Library Calls: SIFT uses its underlying pointer analysis [20] to disambiguate function pointers. \nIt can ana\u00adlyze programs that invoke functions via function pointers. The static analysis may encounter \nprocedure calls (for example, calls to standard C library functions) for which the source code of the \ncallee is not available. A standard way to handle this situation is to work with an annotated procedure \ndeclaration that gives the static analysis information that it can use to analyze calls to the procedure. \nSIFT currently contains prede.ned annotations for a small set of important standard library functions \nthat in.uence our integer over.ow analysis (e.g., memset() and strlen()). If both the source code and \nthe annotation for an invoked pro\u00adcedure are not available, by default SIFT currently synthesizes in\u00adformation \nthat indicates that symbolic expressions are not available for the return value or for any values accessible \n(and therefore po\u00adtentially stored) via procedure parameters (code following the pro\u00adcedure call may \nload such values). This information enables the analysis to determine if the return value or values accessible \nvia the procedure parameters may affect the analyzed symbolic con\u00addition C. If so, SIFT does not generate \na .lter. Because SIFT is demand-driven, this mechanism enables SIFT to successfully an\u00adalyze programs \nwith library calls (all of our benchmark programs have such calls) as long as the calls do not affect \nthe analyzed sym\u00adbolic conditions. Command Line Arguments: At four of the 56 critical sites in our analyzed \nbenchmark modules, the absence of over.ow depends, in part, on the lengths of the command line arguments. \nThe gener\u00adated .nal symbolic condition that SIFT uses to generate the input .lter therefore contains \nvariables that represent these lengths. Our currently implemented system sets these lengths to a speci.c \ncon\u00adstant value greater than the maximum length of the command line arguments of all benchmark applications. \nIn production use, we ex\u00adpect SIFT deployments to either 1) check that the command line argument lengths \nare less than this constant value before launching the application or 2) dynamically extract the command \nline argu\u00adment lengths when the application is launched, then provide these lengths to the .lter. Annotations \nfor Input Read Statements: SIFT provides a declar\u00adative speci.cation language that developers use to \nindicate which input statements read which input .elds. In our current implemen\u00adtation, these statements \nappear in the source code in comments di\u00adrectly below the C statement that reads the input .eld. See \nlines 10, 12, 15-16, and 18-19 in Figure 1 for examples that illustrate the use of the speci.cation language \nin the Swfdec example. The SIFT annotation generator scans the comments, .nds the input speci.ca\u00adtion \nstatements, then inserts new nodes into the LLVM IR that con\u00adtain the speci.ed information. Formally, \nthis information appears as procedure calls of the following form: v = SIFT_Input(\".eld_name\", w); where \nv is a program variable that holds the value of the input .eld with the .eld name field_name. The width \n(in bits) of the input .eld is w. The SIFT static analyzer recognizes such procedure calls as specifying \nthe correspondence between input .elds and program variables and applies the appropriate analysis rule \nfor input read statements (see Figure 6). 3.5 Input Filter Generation The SIFT .lter generator prunes \nany conjuncts that contain resid\u00adual occurrences of abstract materialized values e(id) in the .nal symbolic \ncondition C. It also replaces every residual occurrence of program variables v with 0. These residual \noccurrences corre\u00adspond to initial values in the program state s and \u00afh in the abstract semantics (see \nSection 4.3). After pruning, the .nal condition CInp contains only input .eld variables of the form f(id) \nand constant atoms. In effect, the pruning algorithm eliminates any checks involving uninitialized data \nfrom the .lter SIFT .lters are not designed to nullify over.ow errors that may occur when the program \naccesses uninitialized data (which, in C, may contain arbitrary values). The SIFT soundness theorem (Theorem \n4) re.ects this restriction. For languages such as Java which initialize data to speci.c values, the \nSIFT .lter generator would not prune conjuncts involving refer\u00adences to uninitialized data. It would \ninstead protect against over\u00ad.ows involving uninitialized data by replacing residual occurrences of abstract \nmaterialized values and program variables with the cor\u00adresponding initial values. The generated .lter \noperates as follows. It .rst uses an existing parser for the input format to parse the input and extract \nthe input .elds used in the input condition CInp. Open source parsers are available for a wide range \nof input .le formats, including all of the formats in our experimental evaluation [1]. These parsers \nprovide a standard API that enables clients to access the parsed input .elds. The generated .lter evaluates \neach conjunct expression in CInp by replacing each symbolic input variable in the expression with the \ncorresponding concrete value from the parsed input. If an integer over.ow may occur in the evaluation \nof any expression in CInp, the .lter discards the input and optionally raises an alarm. For input .eld \narrays such as h_sample and v_sample in the Swfdec example (see Section 2), the input .lter enumerates \nall possible combinations of concrete values (see Figure 11 for the formal de.nition of condition evaluation). \nThe .lter discards the input if any combination can trigger the integer over.ow error. Given multiple \nsymbolic conditions generated from multiple critical program points, SIFT can create a single ef.cient \n.lter that .rst parses the input, then checks the parsed input against all .nal symbolic conditions in \nsequence. This approach amortizes the overhead of reading the input (in practice, reading the input consumes \nessentially all of the time required to execute the .lter, see Figure 14) over all of the .nal symbolic \ncondition checks. 4. Soundness of the Static Analysis We next formalize our static analysis algorithm \non the core lan\u00adguage in Figure 3 and discuss the soundness of the analysis. We focus on the intraprocedural \nanalysis and omit a discussion of the interprocedural analysis as it uses standard techniques based on \nsummary tables. 4.1 Dynamic Semantics of the Core Language Program State: We de.ne the program state \n(s, ., . , e, Inp) as follows: s: Var . (Loc+Int+{undef}) .: Var . Bool .: Loc . (Loc+Int+{undef}) e: \nLoc . Bool Inp: InputField . P (Int) s and . map variables and memory locations to their corre\u00adsponding \nvalues. We use undef to represent uninitialized values. We de.ne that if any operand of an arithmetic \noperation is undef, the result of the operation is also undef. Inp(f) maps the input .eld f to the corresponding \nset of the values of all instantiations of the .eld f in the input .le. I np therefore represents the \ninput .le, which remains unchanged during the execution. . maps each vari\u00adable to a boolean .ag, which \ntracks whether the computation that generates the value of the variable (including all subcomputations) \ngenerates an over.ow. e maps each memory location to a boolean over.ow .ag similar to .. In the initial \nstate (s0, .0, .0, e0, Inp), s0 and .0 map all vari\u00adables and locations to undef. .0 and e0 map all variables \nand lo\u00adcations to false. The values of uninitialized variables and memory locations are unde.ned as per \nthe C language speci.cation stan\u00ad dard. Small Step Rules: Figure 9 presents the small step dynamic se\u00ad \nmantics of the language. Note that in Figure 9, over.ow(a, b, op) is a function that returns true if \nand only if the computation a op b causes over.ow. A main point of departure from standard lan\u00ad guages \nis that we also update . and e to track over.ow errors during each execution step. For example, the binop \nrule in Figure 9 appro\u00ad priately updates the over.ow .ag of x in . by checking whether the computation \nthat generates the value of x (including the subcom\u00ad putations that generates the value of y and z) results \nin an over.ow condition. Also note that the rule for the input read statement nondetermin\u00ad istically \nupdates the value of x with an arbitrary element chosen from the set Inp(f), which contains the values \nof all instantiations of the input .eld f in the input .le. This semantics conservatively models the \nbehavior of input read statements in C programs. 4.2 Soundness of the Pointer Analysis Our analysis \nuses an underlying pointer analysis [20] to analyze programs that use pointers. The underlying pointer \nanalysis pro\u00advides two functions no_alias and must_alias to our main analysis. We formally state our \nassumptions about the soundness of the un\u00adderlying pointer alias analysis as follows: De.nition 1 (Soundness \nof no_alias and must_alias). Given any execution sequence (s0, s0, .0, .0, e0) -. (s1, s1, .1, .1, e1) \n-. . . . and two statements sstore (estore : *p = x) and sload (eload: x \" = *p \"), we have: no_alias(estore \n, eload) =. .i < j : (.rstL(si) = estore . .rstL(sj ) = eload) . si(p) = sj (p \" ) must_alias(estore \n, eload) =. .i < j :  (.rstL(si) = estore . .rstL(sj ) = eload . (.rstL(sk) = estore )) k.(i,j) . (si(p) \n= sj (p \" )) 4.3 Abstract Semantics We next de.ne an abstract semantics that allows us to prove the \nsoundness of our static analysis algorithm. There are two key dif\u00ad ferences between the abstract and \noriginal semantics. First, for if and while statements, the abstract semantics conservatively ignores \nthe condition and nondeterministically executes one of the two con\u00ad trol .ow branches. Second, the abstract \nsemantics conservatively groups values that load and store statements access via pointers into equivalence \nclasses based on the aliasing information from the underlying pointer or alias analysis. It then conservatively \nmod\u00ad els reads via pointers as nondeterministically returning an arbitrary stored value from the corresponding \nequivalence class. We adopt this abstract semantics because it more closely re.ects how SIFT incorporates \nthe underlying pointer or alias analysis and analyzes if, while, store, and load statements. Abstract \nProgram State: We de.ne the abstract program state (s, ., \u00af h, Inp) as follows: s: Var . Int .: Var . \nBool \u00af h: LoadLabel . P (Int \u00d7 Bool) Intuitively, s and . are the counterparts of s and . in the original \n semantics, but s and . only track values and .ags for variables that have integer values. \u00afh maps the \nlabel of each load statement to the set of values that the load statement may obtain from the memory. \nIn the initial state (s0, .0, \u00afh0, Inp), s0 and .0 map all variables to 0 and false respectively. \u00afh0 \nmaps all labels of load statements to the empty set. c . Inp(f) s1 = s[x . c] .1 = .[x . false] s1 = \ns[x . c] .1 = .[x . false] read const (\u00a3 : x = read(f), s, ., . , 1, Inp) -. (nil: skip, s1, ., . 1, \n1, Inp) (\u00a3 : x = c, s, ., . , 1, Inp) -. (nil: skip, s1, ., . 1, 1, Inp) s1 = s[x . s(y)] .1 = .[x . \n.(y)] . . Loc . is fresh s1 = s[p . .] .1 = .[p . false] assign malloc (\u00a3 : x = y, s, ., . , 1, Inp) \n-. (nil: skip, s1, ., . 1, 1, Inp) (\u00a3 : p = malloc, s, ., . , 1, Inp) -. (nil: skip, s1, ., .1, 1, Inp) \ns(p) = . . . Loc s1 = s[x . .(.)] .1 = .[x . 1(.)] seq-1 load (nil: skip; s, s, ., . , 1, Inp) -. (s, \ns, ., . , 1, Inp) (\u00a3 : x = *p, s, ., . , 1, Inp) -. (nil: skip, s1, ., . 1, 1, Inp) 11 .1 1 (s, s, ., \n. , 1, Inp) -. (s, s1, .1, . 1, 11, Inp) s(p) = . . . Loc = .[. . s(x)] 1= 1[. . .(x)] seq-2 store 1 \n11 1 1 (s; s, s, ., . , 1, Inp) -. (s; s, s1, .1, . 1, 11, Inp) (\u00a3 : *p = x, s, ., . , 1, Inp) -. (nil: \nskip, s, .1, . , 1, Inp) s(y) ./Loc s(z) ./Loc b = .(y) . .(z) . over.ow(s(y), s(z), op) op (\u00a3 : x = \ny op z, s, ., . , 1, Inp) -. (nil: skip, s[x . s(y) op s(z)], ., . [x . b], 1, Inp) s(x) s(x) = 0 = 0 \n if-t if-f 1 11 (\u00a3 : if (x) s else s , s, ., . , 1, Inp) -. (s, s, ., . , 1, Inp) (\u00a3 : if (x) s else \ns , s, ., . , 1, Inp) -. (s, s, ., . , 1, Inp) s(x) = 0 s(x)= 0 s1 = s; \u00a3 : while (x) {s} while-f while-t \n1 (\u00a3 : while (x) {s}, s, ., . , 1, Inp) -. (nil: skip, s, ., . , 1, Inp) (\u00a3 : while (x) {s}, s, ., . \n, 1, Inp) -. (s, s, ., . , 1, I np) Figure 9. The small step operational semantics of the language. nil\" \nis a special label reserved by the semantics. if-t (\u00a3 : if (x) s else s1, s, . , \u00afh, Inp) -.a (s, s, \n. , \u00afh, Inp) op b = .(y) . .(z) . over.ow(s(y), s(z), op) s1 = s[x . s(y) op s(z)] (\u00a3 : x = y op z, s, \n. , \u00afh, Inp) -.a (nil: skip, s1, .[x . b], \u00afh, Inp) if-f malloc (\u00a3 : if (x) s else s1, s, . , \u00afh, Inp) \n-.a (s1, s, . , \u00afh, Inp) (\u00a3 : p = malloc, s, . , \u00afh, Inp) -.a (nil: skip, s, . , \u00afh, Inp) load (c, b) \n. \u00afh(\u00a3) s1 = s[x . c] .1 = .[x . b] (\u00a3 : x = *p, s, . , \u00afh, Inp) -.a (nil: skip, s1, .1, \u00afh, Inp) store \n\u00afh1 satis.es (*) (\u00a3 : *p = x, s, . , \u00afh, Inp) -.a (nil: skip, s, . , \u00afh1, Inp) . .\u00a3load . LoadLabel : \n\u00afh 1 (\u00a3load) = . . \u00afh(\u00a3load) {(s(x), .(x))}{(s(x), .(x))} . \u00afh(\u00a3load) no_alias(\u00a3, \u00a3load) \u00ac no_alias(\u00a3, \n\u00a3load ) . must_alias(\u00a3, \u00a3load ) \u00ac no_alias(\u00a3, \u00a3load ) . \u00ac must_alias(\u00a3, \u00a3load ) (*) Figure 10. The small \nstep abstract semantics. nil\" is a special label reserved by the semantics.  Small Step Rules: Figure \n10 presents the small step rules for the abstract semantics. We omit rules for simple assignment state\u00adments, \nwhile statements, and sequence statements for brevity. The rules for if, while, malloc, load, and store \nstatements re.ect the primary differences between the abstract and original seman\u00adtics. The rules for \nif and while statements (if-t, if-f, and the omit\u00adted while statement rules) in the abstract semantics \nconservatively ignore the condition and nondeterministically execute one of the two control .ow branches. \nThe rule for store statements maintains the state \u00afh according to the aliasing information. The rule \nfor load statements nondeterministically returns an element from the corre\u00adsponding set in \u00afh.  4.4 \nRelationship of the Original and the Abstract Semantics We formally state the relationship between the \noriginal and abstract semantics as follows. Theorem 2. For any execution trace in the original semantics: \n(s0, s0, .0, .0, e0) -. (s1, s1, .1, .1, e1) -. . . . there is an execution trace in the abstract semantics: \n(s0, s0, .0, \u00afh0) -.a (s1, s1, .1, \u00afh1) -.a . . . such that the following conditions hold: .i .x . Var \n: si(x) ./Int . (si(x) = si(x) . .i(x) = .i(x)) .i : .rstS (si) = e : x = *p . (.i(si(p)) ./Int . (.i(si(p)), \nei(si(p))) . \u00afhi(e)) The intuition behind the .rst condition is that si and si as well as .i and .i \nalways agree on the variables holding integer values. The intuition behind the second condition is that \n\u00afhi(e) corresponds to the possible values that the corresponding load statement of the label e may obtain \nfrom the memory. When a load statement executes in the original semantics, the obtained integer value \nis in the corresponding set in \u00afhi in the abstract semantics. This theorem connects an arbitrary program \nexecution in the original semantics to a corresponding execution in the abstract semantics. An important \nconsequence of this theorem is that the soundness of our analysis in the abstract semantics implies the \nsoundness of the analysis in the original semantics. See our techni\u00adcal report [23] for the proof sketch \nof this theorem. 4.5 Evaluation of the Symbolic Condition Our static analysis maintains and propagates \na symbolic condition C. Figure 11 de.nes the evaluation rules of the symbolic con\u00addition C over an abstract \nprogram state (s, ., \u00af h, Inp) The nota\u00adtion (s, ., \u00afh, Inp) |= C denotes that the abstract program state \n(s, ., \u00afThe evaluation rule for h, Inp) satis.es the condition C. safe(e1 op e2) checks that no over.ow \nerror occurs in any subcom\u00adputation that contributes to the .nal value of (e1 op e2). In our abstraction, \neach atom of the form f(id) corresponds to the value of an arbitrary instantiation of the input .eld \nf i.e., f(id) corresponds to an arbitrary element of the set Inp(f). Each atom of the form e(id) corresponds \nto an arbitrary value that may be stored via any alias of the corresponding pointer i.e., e(id) .c \n. Inp(f) : (s, ., h,\u00afInp) |= C[c/f(id)] h(\u00a3) : (s[tmp . c], .[tmp . b], \u00af= C[tmp/l(id)] tmp is fresh \nin C.(c, b) . \u00afh, Inp) |(s, ., h,\u00afInp) |= C h, Inp) |(s, ., \u00af= C (s, ., \u00afh, Inp) |= C h, Inp) |= safe(e) \nh, Inp) |= safe(e1) . safe(e2) over.ow([[e1]](s), [[e2]](s), op) = false (s, ., \u00af(s, ., \u00af (s, ., \u00af= C \n. safe(e) h, Inp) |= safe(e1 op e2) h, Inp) |(s, ., \u00af .(x) = false [[c]](s) = c [[x]](s) = s(x) [[e1 \nop e2]](s) = [[e1]](s) op [[e2]](s) (s, ., \u00af h, Inp) |= safe(x) Figure 11. Symbolic condition evaluation \nrules. corresponds to an arbitrary element of the set \u00afh(e). The evaluation rules enumerate all possible \nbindings of f(id) and e(id) to check that no binding causes an over.ow. The de.nition of the evaluation \nrules also ensures that all oc\u00adcurrences of f(id) which reference the same input .eld f and all occurrences \nof e(id) materialized from the same load statement e are interchangable. This interchangability ensures \nthat the normal\u00adization algorithm in Section 3.2 is sound i.e., that renumbering ids in a symbolic condition \nC does not change the meaning of the condition. Therefore, given symbolic condition C, the normaliza\u00adtion \nalgorithm produces an equivalent condition norm(C).  4.6 Soundness of the Analysis Soundness of the \nAnalysis over the Abstract Semantics: We formally state the soundness of our analysis over the abstract \nse\u00admantics as follows. Theorem 3. Given a series of statements si, a program point e . labels(si) and \na start condition C, our analysis generates a condition F (si, e, C ), such that if (si, .i, \u00afhi, Inp) \n|= F (si, e, C ), then (((si, si, .i, \u00afhi) -. * a (sj-1, sj-1, .j-1, \u00afhj-1) -.a (sj , sj , .j , \u00afhj )) \n. (.rstL(sj-1) = e)) =. ((sj , .j , \u00afhj , Inp) |= C) This theorem guarantees that if the abstract program \nstate before executing si satis.es F (si, e, C ), then the abstract program state at the program point \nafter the statement at label e will always satisfy C (here the notation -. * a denotes the execution \nof the program for an arbitrary number of steps in the abstract semantics). Soundness of the Analysis \nover the Original Semantics: Be\u00adcause of the consistency of the abstract semantics and the original semantics \n(see Section 4.3), we can derive the following soundness property of our analysis over the original semantics \nbased on the soundness property over the abstract semantics: Theorem 4. Given a program s0, a program \npoint e . labels(s0), and a program variable v, our analysis generates a condition C = F (s0, e, safe(v)), \nsuch that if (s0, .0, \u00afh0, I np) |= C, then (((s0, s0, .0, .0, e0) -. * (sn-1, sn-1, .n-1, .n-1, en-1) \n-. (sn, sn, .n, .n, en)) . (.rstL(sn-1) = e)) =. (sn(v) ./Int . .n(v) = false) This theorem guarantees \nthat if the input satis.es the generated condition C (note that (s0, .0, \u00afh0, Inp) is the prede.ned constant \ninitial state in Section 4.3), then for any execution in the original semantics (here the notation -. \n* denotes the execution of the program for an arbitrary number of steps in the original semantics), \nat the program point after the statement of the label e, as long as the variable v holds an integer value \n(not an unde.ned value due to uninitialized access), the computation history for obtaining this integer \nvalue contains no over.ow error. Application Distinct Fields Relevant Fields VLC 25 2 Dillo 47 3 Swfdec \n219* 6 png2swf 47 4 jpeg2swf 300 2 GIMP 189 2 Figure 12. The number of distinct input .elds and the number \nof relevant input .elds for analyzed input formats. (*) For Swfdec the second column shows the number \nof distinct .elds in embedded JPEG images in collected SWF .les.  5. Experimental Results We evaluate \nSIFT on modules from .ve open source applications: VLC 0.8.6h (a network media player), Dillo 2.1 (a \nlightweight web browser), Swfdec 0.5.5 (a .ash video player), Swftools 0.9.1 (SWF manipulation and generation \nutilities), and GIMP 2.8.0 (an image manipulation application). Each application uses a publicly avail\u00adable \ninput format speci.cation and contains at least one known in\u00adteger over.ow vulnerability (described in \neither the CVE database or the Buzzfuzz paper [15]). All experiments were conducted on an Intel Xeon \nX5363 3.00GHz machine running Ubuntu 12.04. We focus on media and browser applications (client applica\u00adtions) \nin our experiments due to the ease of obtaining inputs re\u00adquired to evaluate our system against false \npositives. Other types of applications (e.g., server applications) would require additional in\u00adfrastructure \n(i.e., recording network traf.c) to test. By design, SIFT is applicable to a wide range of applications. \n5.1 Methodology Input Format and Module Selection: For each application, we used SIFT to generate .lters \nfor the input format that triggers the known integer over.ow vulnerability. We therefore ran SIFT on \nthe module that processes inputs in that format. The generated .lters nullify not only the known vulnerabilities, \nbut also any integer over.ow vulnerabilities at any of the 56 memory allocation or block copy sites in \nthe modules for which SIFT was able to generate symbolic conditions (recall that there are 58 critical \nsites in these modules in total). Input Statement Annotation: After selecting each module, we added annotations \nto identify the input statements that read relevant input .elds (i.e., input .elds that may affect the \nvalues of critical expressions at memory allocation or block copy sites). Figure 12 presents, for each \nmodule, the total number of distinct .elds in our collected inputs for each format, the number of annotated \ninput statements (in all of the modules the number of relevant .elds equals the number of annotated input \nstatements each relevant .eld is read by a single input statement). We note that the number of relevant \n.elds is signi.cantly smaller than the total number of distinct .elds (re.ecting the fact that typically \nonly a relatively small number of .elds in each input format may affect the sizes of allocated or copied \nmemory blocks). Application Module # of IR Total Input Relevant Inside Loop Max Condition Size Analysis \nTime VLC demux/wav.c 1.5k 5 3 0 2 <0.1s Dillo png.c 39.1k 4 3 3 410 0.8s Swfdec jpeg/*.c 8.4k 22 19 2 \n144 0.2s png2swf all 11.0k 21 18 18 16 0.2s jpeg2swf all 2.5k 4 4 4 2 <0.1s GIMP .le-gif-load.c 3.2k \n2 2 2 2 <0.1s Figure 13. Static analysis and .lter generation results  The maximum amount of time required \nto annotate any module was approximately half an hour (Swfdec). The total annotation time required to \nannotate all benchmarks, including Swfdec, was less than an hour. This annotation effort re.ects the \nfact that, in each input format, there are only a relatively small number of relevant input .elds. Filter \nGeneration and Test: We next used SIFT to generate a single composite input .lter for each analyzed module. \nWe then downloaded at least 6000 real-world inputs for each input format and ran all of the downloaded \ninputs through the generated .lters. There were no false positives (the .lters accepted all of the inputs). \nVulnerability and Filter Con.rmation: For each known integer over.ow vulnerability, we collected a test \ninput that triggered the integer over.ow. We con.rmed that each generated composite .l\u00adter, as expected, \ndiscarded the input because it correctly recognized that the input would cause an integer over.ow.  \n5.2 Analysis and Filter Evaluation Analysis Evaluation: Figure 13 presents static analysis and .lter \ngeneration results. This .gure contains a row for each analyzed module. The .rst column (Application) \npresents the application name, the second column (Module) identi.es the analyzed mod\u00adule within the application. \nThe third column (# of IR) presents the number of analyzed statements in the LLVM intermediate repre\u00adsentation. \nThis number of statements includes not only statements directly present in the module, but also statements \nfrom analyzed code in other modules invoked by the original module. The fourth column (Total) presents \nthe total number of memory allocation and block copy sites in the analyzed module. The .fth column (Input \nRelevant) presents the number of memory allocation and block copy sites in which the size of the allocated \nor copied block depends on the values of input .elds. For these modules, the sizes at 49 of the 58 sites \ndepend on the values of input .elds. The sizes at the remaining nine sites are unconditionally safe \nSIFT veri.es that they depend only on constants embedded in the program (and that there is no over.ow \nwhen the sizes are computed from these constants). The sixth column (Inside Loop) presents the number \nof memory allocation and block copy sites in which the size parameter depends on variables that occurred \ninside loops. The sizes at 29 of the 58 sites depend on values computed inside loops. To generate input \n.lters for these sites, SIFT must therefore compute loop invariants that capture the effect of the loop \non the sizes that occur at these sites. The seventh column (Max Condition Size) presents, for each application \nmodule, the maximum number of conjuncts in any symbolic condition that occurs in the analysis of that \nmodule. The conditions are reasonably compact (and more than compact enough to enable an ef.cient analysis) \n the maximum condition size over all modules is less than 500. Application Format # of Input Average \nTime VLC WAV 10976 3ms (3ms) Dillo PNG 18983 16ms (16ms) Swfdec SWF 7240 6ms (5ms) png2swf PNG 18983 \n16ms (16ms) jpeg2swf JPEG 6049 4ms (4ms) GIMP GIF 19647 9ms (9ms) Figure 14. Generated .lter results. \n  The .nal column (Analysis Time) presents the time required to analyze the module and generate a single \ncomposite .lter for all of the successfully analyzed critical sites. The analysis times for all modules \nare less than a second. SIFT is unable to generate symbolic conditions for two of the 58 call sites (one \nin Swfdec and one in png2swf). The expressions at these two sites contain subexpressions whose values \ndepend on an unbounded number of values computed in loops. To analyze such expressions, our analysis \ncurrently requires an upper bound on the number of loop iterations. Such an upper bound could be provided, \nfor example, by additional analysis or developer annotations. Filter Evaluation: For each input format, \nwe used a custom web crawler to locate and download at least 6000 inputs in that format. The web crawler \nstarts from a Google search page for the .le extension of the speci.c input format, then follows links \nin each search result page to download .les in the correct format. Figure 14 presents, for each generated \n.lter, the number of downloaded input .les and the average time required to .lter each input. We present \nthe average times in the form Xms (Yms), where Xms is the average time required to .lter an input and \nYms is the average time required to read in the input (but not apply the integer over.ow check). These \ndata show that essentially all of the .lter time is spent reading in the input. 5.3 Filter Con.rmation \non Vulnerabilities Each benchmark application contains a known integer over.ow vulnerability. To con.rm \nthat the generated .lters operate correctly, we obtained, for each vulnerability, a malicious input that \ntriggers the integer over.ow error. We con.rmed that the .lters successfully identi.ed and discarded \nall of these malicious inputs. We also man\u00adually examined the root cause of each vulnerability and con.rmed \nthat the generated .lters completely nulli.ed the vulnerability if an input passes the .lter, it will \nnot trigger the over.ow error that enables the vulnerability. See our technical report [23] for the detailed \ncase study of each vulnerability. 5.4 Discussion The experimental results highlight the combination \nof properties that, together, enable SIFT to effectively nullify potential integer over.ow errors at \nmemory allocation and block copy sites. SIFT is ef.cient enough to deploy in production on real-world \nmodules (the combined program analysis and .lter generation times are always under a second), the analysis \nis precise enough to successfully generate input .lters for the majority of memory allocation and block \ncopy sites, the results provide encouraging evidence that the generated .lters are precise enough to \nhave few or even no false positives in practice, and the .lters execute ef.ciently enough to deploy with \nacceptable .ltering overhead. 6. Related Work Weakest Precondition Analysis: Madhavan et. al. present \nan ap\u00adproximate weakest precondition analysis to verify the absence of null dereference errors in Java \nprograms [24]. The goal is to ver\u00adify that, for each pointer dereference, there are appropriate null \nchecks within the program that guard the dereference to ensure that the program will never execute the \ndereference with a null pointer value. The analysis tracks only pointer dereferences, pointer assign\u00adments, \nand conditions involving null pointer checks. SIFT faces different challenges and therefore uses different \ntechniques. Instead of using a .nite domain to track dereferenced pointers and pointer assignments, SIFT \nmust track potentially un\u00adbounded arithmetic symbolic expressions involving input .elds and values accessed \nvia pointers. To successfully analyze loops, SIFT s abstraction and expression normalization algorithms \nwork together to discover invariants for loops that may access a statically un\u00adbounded number of input \n.eld instantiaions (as long as the value of the analyzed expression depends only on a statically bounded \nnumber of input .eld instantiations). Flanagan et. al. present a general intraprocedural weakest precondition \nanalysis for generating veri.cation conditions for ESC/JAVA programs [14]. SIFT differs in that it focuses \non in\u00adteger over.ow errors. Because of this focus, SIFT can synthesize its own loop invariants (Flanagan \net. al. rely on developer-provided invariants). In addition, SIFT is interprocedural and uses the anal\u00adysis \nresults to generate sound .lters that nullify integer over.ow errors. Anomaly Detection: Anomaly detection \ntechniques generate (un\u00adsound) input .lters by empirically learning properties of success\u00adfully or unsuccessfully \nprocessed inputs [16, 19, 34]. Two key dif\u00adferences are that SIFT statically analyzes the application, \nnot its in\u00adputs, and takes all execution paths into account to generate a sound .lter. Input Recti.cation: \nInput recti.cation [22, 30] empirically learns input constraints from benign training inputs. It then \nmonitors in\u00adputs for violations of the learned constraints. Instead of discarding inputs that violate \nthe learned constraints, input recti.cation modi\u00ad.es the input so that it satis.es the constraints. The \ngoal is to nul\u00adlify potential errors while still enabling the program to successfully process as much \ninput data as possible. Because it learns the con\u00adstraints from examples, this technique is not sound \n the generated .lter may miss some inputs that target the error. It would be possi\u00adble to combine SIFT \nwith input recti.cation to obtain a sound input recti.cation technique. Runtime Repair: Researchers have \ndeveloped a range of tech\u00adniques for dynamically detecting and repairing errors in the pro\u00adgram s execution \n[18, 27 29]. These techniques all purposefully change the program s semantics in an attempt to enable \nthe pro\u00adgram to successfully process inputs that it would otherwise be un\u00adable to process without error. \nThe goal of SIFT, in contrast, is to nullify errors without changing the program s semantics by dis\u00adcarding \ninputs that might trigger the errors. Static Analysis for Finding Integer Over.ow and Sign Errors: Several \nstatic analysis tools have been proposed to .nd integer over.ow and/or sign errors [7, 31, 35]. KINT \n[35], for example, analyzes individual procedures, with the developer optionally pro\u00adviding procedure \nspeci.cations that characterize the value ranges of the parameters. KINT also unsoundly avoids the loop \ninvariant synthesis problem by replacing each loop with the loop body (in effect, unrolling the loop \nonce). Despite substantial effort, KINT reports a large number of false positives [35]. SIFT addresses \na different problem: it is designed to nullify, not detect, over.ow errors. In pursuit of this goal, \nit uses an interpro\u00adcedural analysis, synthesizes symbolic loop invariants, and soundly analyzes all \nexecution paths to produce a sound .lter. Symbolic Bug Finding and Validation: DART [17] and KLEE [6] \nuse symbolic execution to automatically generate test inputs that systematically exercise different control-.ow \npaths in a program. One goal is to .nd inputs that expose errors in the program. IntScope [33] and SmartFuzz \n[25] are symbolic execution sys\u00adtems designed speci.cally to expose integer over.ow and/or sign errors. \nIt would be possible to combine these systems with previous input-driven .lter generation techniques \nto obtain .lters that dis\u00adcard inputs that take the discovered path to the error. As discussed previously, \nSIFT differs in that it considers all possible paths so that its generated .lters come with a soundness \nguarantee that if an input passes the .lter, it will not exploit the integer over.ow error. Snugglebug \n[8] is a backward symbolic analysis engine for error validation the goal is to generate an input that \ncan trigger a potential error identi.ed by some other means. As with other symbolic execution systems, \nSnugglebug is designed to enumerate all potential paths that the program may take to reach the error. \nIf the number of paths is large or unbounded (for example, if the program contains loops), it may be \ninfeasible to enumerate all paths. SIFT, in contrast, uses a precondition generation technique that can \nsuccessfully analyze large programs while soundly taking all paths into consideration. Runtime Checks \nand Library Support: To alleviate the problem of false positives, several research projects have focused \non run\u00adtime detection tools that dynamically insert runtime checks before integer operations [4, 9, 13, \n37]. Another technique is to use safe integer libraries such as SafeInt [21] and CERT s IntegerLib [32] \nto perform sanity checks at runtime. Using these libraries requires developers to rewrite existing code \nto use safe versions of integer operations. However, the inserted code typically imposes non-negligible \noverhead. When they detect an error, these techniques typically generate a warning and terminate the \nexecution (effectively turning any integer over.ow attack into a denial of service attack). SIFT, in \ncontrast, inserts no code into the application and nulli.es integer over.ow errors by discarding inputs \nthat trigger such errors. Benign Integer Over.ows: In some cases, developers may inten\u00adtionally write \ncode that contains benign integer over.ows [13, 33, 35]. A potential concern is that techniques that \nnullify over.ows may interfere with the intended behavior of such programs [13, 33, 35]. Because SIFT \nfocuses on critical memory allocation and block copy sites that are unlikely to have such intentional \ninteger over\u00ad.ows, it is unlikely to nullify benign integer over.ows and there\u00adfore unlikely interfere \nwith the intended behavior of the program. 7. Conclusion Integer over.ow errors can lead to security \nvulnerabilities. SIFT analyzes how the application computes integer values that appear at memory allocation \nand block copy sites to generate input .lters that discard inputs that may trigger over.ow errors in \nthese compu\u00adtations. Our results show that SIFT can quickly generate sound, ef.cient, and precise input \n.lters for the vast majority of mem\u00adory allocation and block copy call sites in our analyzed benchmark \nmodules. Acknowledgements We thank Michael Carbin, Sasa Misailovic, and the anonymous re\u00adviewers for \ntheir insightful comments. We note our earlier tech\u00adnical report [23]. This research was supported by \nDARPA (Grant FA8650-11-C-7192). References [1] Hachoir. http://bitbucket.org/haypo/hachoir/wiki/Home. \n[2] LLVM Basic Alias Analysis Pass. http://llvm.org/docs/ AliasAnalysis.html#the-basicaa-pass. [3] The \nLLVM compiler infrastructure. http://www.llvm.org/. [4] D. Brumley, T. Chiueh, R. Johnson, H. Lin, and \nD. Song. Rich: Auto\u00admatically protecting against integer-based vulnerabilities. Department of Electrical \nand Computing Engineering, page 28, 2007. [5] D. Brumley, H. Wang, S. Jha, and D. Song. Creating vulnerability \nsignatures using weakest preconditions. In Proceedings of the 20th IEEE Computer Security Foundations \nSymposium, CSF 07 , pages 311 325, Washington, DC, USA, 2007. IEEE Computer Society. [6] C. Cadar, D. \nDunbar, and D. Engler. Klee: unassisted and automatic generation of high-coverage tests for complex systems \nprograms. In Proceedings of the 8th USENIX conference on Operating systems design and implementation, \nOSDI 08, pages 209 224, Berkeley, CA, USA, 2008. USENIX Association. [7] E. Ceesay, J. Zhou, M. Gertz, \nK. Levitt, and M. Bishop. Using type quali.ers to analyze untrusted integers and detecting security .aws \nin c programs. Detection of Intrusions and Malware &#38; Vulnerability Assessment, pages 1 16, 2006. \n[8] S. Chandra, S. J. Fink, and M. Sridharan. Snugglebug: a powerful approach to weakest preconditions. \nIn Proceedings of the 2009 ACM SIGPLAN conference on Programming language design and imple\u00admentation, \nPLDI 09, pages 363 374, New York, NY, USA, 2009. ACM. [9] R. Chinchani, A. Iyer, B. Jayaraman, and S. \nUpadhyaya. Archerr: Runtime environment driven program safety. Computer Security ESORICS 2004, pages \n385 406, 2004. [10] M. Costa, M. Castro, L. Zhou, L. Zhang, and M. Peinado. Bouncer: securing software \nby blocking bad input. In Proceedings of twenty-.rst ACM SIGOPS symposium on Operating systems principles, \nSOSP 07. ACM, 2007. [11] M. Costa, J. Crowcroft, M. Castro, A. Rowstron, L. Zhou, L. Zhang, and P. Barham. \nVigilante: end-to-end containment of internet worms. In Proceedings of the twentieth ACM symposium on \nOperating systems principles, SOSP 05. ACM, 2005. [12] W. Cui, M. Peinado, and H. J. Wang. Shieldgen: \nAutomatic data patch generation for unknown vulnerabilities with informed probing. In Proceedings of \n2007 IEEE Symposium on Security and Privacy. IEEE Computer Society, 2007. [13] W. Dietz, P. Li, J. Regehr, \nand V. Adve. Understanding integer over\u00ad.ow in c/c++. In Proceedings of the 2012 International Conference \non Software Engineering, pages 760 770. IEEE Press, 2012. [14] C. Flanagan and J. B. Saxe. Avoiding exponential \nexplosion: gen\u00aderating compact veri.cation conditions. In Proceedings of the 28th ACM SIGPLAN-SIGACT \nsymposium on Principles of programming languages, POPL 01 , pages 193 205, New York, NY, USA, 2001. ACM. \n[15] V. Ganesh, T. Leek, and M. Rinard. Taint-based directed whitebox fuzzing. In ICSE 09: Proceedings \nof the 31st International Confer\u00adence on Software Engineering. IEEE Computer Society, 2009. [16] D. Gao, \nM. K. Reiter, and D. Song. On gray-box program tracking for anomaly detection. In Proceedings of the \n13th conference on USENIX Security Symposium -Volume 13, SSYM 04. USENIX Association, 2004. [17] P. Godefroid, \nN. Klarlund, and K. Sen. Dart: directed automated ran\u00addom testing. In Proceedings of the 2005 ACM SIGPLAN \nconference on Programming language design and implementation, PLDI 05, pages 213 223, New York, NY, USA, \n2005. ACM. [18] M. Kling, S. Misailovic, M. Carbin, and M. Rinard. Bolt: on-demand in.nite loop escape \nin unmodi.ed binaries. In Proceedings of the ACM international conference on Object oriented programming \nsystems languages and applications, OOPSLA 12 , pages 431 450, New York, NY, USA, 2012. ACM. [19] C. \nKruegel and G. Vigna. Anomaly detection of web-based attacks. In Proceedings of the 10th ACM conference \non Computer and communi\u00adcations security, CCS 03. ACM, 2003. [20] C. Lattner, A. Lenharth, and V. Adve. \nMaking context-sensitive points-to analysis with heap cloning practical for the real world. In Proceedings \nof the 2007 ACM SIGPLAN conference on Programming language design and implementation, PLDI 07, pages \n278 289, New York, NY, USA, 2007. ACM. [21] D. LeBlanc. Integer handling with the c++ safeint class. \nurl\u00adhttp://msdn. microsoft. com/en-us/library/ms972705, 2004. [22] F. Long, V. Ganesh, M. Carbin, S. \nSidiroglou, and M. Rinard. Auto\u00admatic input recti.cation. ICSE 12, 2012. [23] F. Long, S. Sidiroglou, \nD. Kim, and M. Rinard. Sound input .lter generation for integer over.ow errors. MIT-CSAIL-TR-2013-018. \n[24] R. Madhavan and R. Komondoor. Null dereference veri.cation via over-approximated weakest pre-conditions \nanalysis. In Proceedings of the 2011 ACM international conference on Object oriented pro\u00adgramming systems \nlanguages and applications, OOPSLA 11, pages 1033 1052, New York, NY, USA, 2011. ACM. [25] D. Molnar, \nX. C. Li, and D. A. Wagner. Dynamic test generation to .nd integer bugs in x86 binary linux programs. \nUsenix Security 09. [26] J. Newsome, D. Brumley, and D. X. Song. Vulnerability-speci.c execution .ltering \nfor exploit prevention on commodity software. In NDSS, 2006. [27] G. Novark, E. D. Berger, and B. G. \nZorn. Exterminator: Automatically correcting memory errors with high probability. In In Proceedings of \nthe 2007 ACM SIGPLAN Conference on Programming Language Design and Implementation, ACM. Press, 2007. \n[28] J. H. Perkins, S. Kim, S. Larsen, S. Amarasinghe, J. Bachrach, M. Carbin, C. Pacheco, F. Sherwood, \nS. Sidiroglou, G. Sullivan, W.-F. Wong, Y. Zibin, M. D. Ernst, and M. Rinard. Automatically patch\u00ading \nerrors in deployed software. In Proceedings of the ACM SIGOPS 22nd symposium on Operating systems principles, \nSOSP 09, pages 87 102, New York, NY, USA, 2009. ACM. [29] M. Rinard, C. Cadar, D. Dumitran, D. M. Roy, \nT. Leu, and W. S. Beebee. Enhancing server availability and security through failure\u00adoblivious computing. \nIn In Proceedings 6 th Symposium on Operating Systems Design and Implementation (OSDI), pages 303 316, \n2004. [30] M. C. Rinard. Living in the comfort zone. In Proceedings of the 22nd annual ACM SIGPLAN conference \non Object-oriented programming systems and applications, OOPSLA 07. ACM, 2007. [31] D. Sarkar, M. Jagannathan, \nJ. Thiagarajan, and R. Venkatapathy. Flow\u00adinsensitive static analysis for detecting integer anomalies \nin programs. In IASTED, 2007. [32] R. Seacord. The CERT C secure coding standard. Addison-Wesley Professional, \n2008. [33] W. Tielei, W. Tao, L. Zhiqiang, and Z. Wei. IntScope: Automatically Detecting Integer Over.ow \nVulnerability In X86 Binary Using Sym\u00adbolic Execution. In 16th Annual Network &#38; Distributed System \nSecu\u00adrity Symposium, 2009. [34] K. Wang and S. J. Stolfo. Anomalous payload-based network intrusion detection. \nIn RAID, 2004. [35] X. Wang, H. Chen, Z. Jia, N. Zeldovich, and M. Kaashoek. Improving integer security \nfor systems with kint. In OSDI. USENIX Association, 2012. [36] X. Wang, Z. Li, J. Xu, M. K. Reiter, C. \nKil, and J. Y. Choi. Packet vaccine: black-box exploit detection and signature generation. CCS 06. ACM, \n2006. [37] C. Zhang, T. Wang, T. Wei, Y. Chen, and W. Zou. Intpatch: Automati\u00adcally .x integer-over.ow-to-buffer-over.ow \nvulnerability at compile\u00adtime. Computer Security ESORICS 2010, pages 71 86, 2010.   \n\t\t\t", "proc_id": "2535838", "abstract": "<p>We present a system, SIFT, for generating input filters that nullify integer overflow errors associated with critical program sites such as memory allocation or block copy sites. SIFT uses a static pro- gram analysis to generate filters that discard inputs that may trigger integer overflow errors in the computations of the sizes of allocated memory blocks or the number of copied bytes in block copy operations. Unlike all previous techniques of which we are aware, SIFT is sound -- if an input passes the filter, it will not trigger an integer overflow error at any analyzed site. Our results show that SIFT successfully analyzes (and therefore generates sound input filters for) 56 out of 58 memory allocation and block memory copy sites in analyzed input processing modules from five applications (VLC, Dillo, Swfdec, Swftools, and GIMP). These nullified errors include six known integer overflow vulnerabilities. Our results also show that applying these filters to 62895 real-world inputs produces no false positives. The analysis and filter generation times are all less than a second.</p>", "authors": [{"name": "Fan Long", "author_profile_id": "81503684022", "affiliation": "Massachusetts Institute of Technology, Cambridge, MA, USA", "person_id": "P4383875", "email_address": "fanl@csail.mit.edu", "orcid_id": ""}, {"name": "Stelios Sidiroglou-Douskos", "author_profile_id": "81488668093", "affiliation": "Massachusetts Institute of Technology, Cambridge, MA, USA", "person_id": "P4383876", "email_address": "stelios@csail.mit.edu", "orcid_id": ""}, {"name": "Deokhwan Kim", "author_profile_id": "81485643254", "affiliation": "Massachusetts Institute of Technology, Cambridge, MA, USA", "person_id": "P4383877", "email_address": "dkim@csail.mit.edu", "orcid_id": ""}, {"name": "Martin Rinard", "author_profile_id": "81100087275", "affiliation": "Massachusetts Institute of Technology, Cambridge, MA, USA", "person_id": "P4383878", "email_address": "rinard@csail.mit.edu", "orcid_id": ""}], "doi_number": "10.1145/2535838.2535888", "year": "2014", "article_id": "2535888", "conference": "POPL", "title": "Sound input filter generation for integer overflow errors", "url": "http://dl.acm.org/citation.cfm?id=2535888"}