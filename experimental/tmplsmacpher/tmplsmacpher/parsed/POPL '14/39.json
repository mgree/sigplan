{"article_publication_date": "01-08-2014", "fulltext": "\n A Proof System for Separation Logic with Magic Wand Wonyeol Lee Sungwoo Park Department of Computer \nScience and Engineering Pohang University of Science and Technology (POSTECH) Republic of Korea {leewy,gla}@postech.ac.kr \nAbstract Separation logic is an extension of Hoare logic which is acknowl\u00adedged as an enabling technology \nfor large-scale program veri.ca\u00adtion. It features two new logical connectives, separating conjunc\u00adtion \nand separating implication, but most of the applications of sep\u00adaration logic have exploited only separating \nconjunction without considering separating implication. Nevertheless the power of sep\u00adarating implication \nhas been well recognized and there is a grow\u00ading interest in its use for program veri.cation. This paper \ndevelops a proof system for full separation logic which supports not only separating conjunction but \nalso separating implication. The proof system is developed in the style of sequent calculus and satis.es \nthe admissibility of cut. The key challenge in the development is to devise a set of inference rules \nfor manipulating heap structures that ensure the completeness of the proof system with respect to separation \nlogic. We show that our proof of completeness directly translates to a proof search strategy. Categories \nand Subject Descriptors F.4.1 [Mathematical Logic]: Mechanical theorem proving, Proof theory General \nTerms Veri.cation Keywords Separation logic; Proof system; Theorem prover 1. Introduction Separation \nlogic [28] is an extension of Hoare logic designed to simplify reasoning about programs manipulating \nmutable data structures with potential pointer aliasing. It features two new log\u00adical connectives, separating \nconjunction * and separating implica\u00adtion -*, whose semantics directly assumes memory heaps struc\u00adtured \nas a monoid. Separating conjunction allows us to describe properties of two disjoint heaps with a single \nlogical formula: A * B means that a given heap can be divided into two disjoint heaps satisfying A and \nB respectively. Separating implication, commonly known as magic wand, allows us to reason about hy\u00adpothetical \nheaps extending a given heap: A -* B means that if a given heap is extended with a disjoint heap satisfying \nA, the re\u00adsultant heap satis.es B. The use of the two separating connectives naturally leads to local \nreasoning in program veri.cation in that we Permission to make digital or hard copies of all or part \nof this work for personal or classroom use is granted without fee provided that copies are not made or \ndistributed for pro.t or commercial advantage and that copies bear this notice and the full citation \non the .rst page. Copyrights for components of this work owned by others than ACM must be honored. Abstracting \nwith credit is permitted. To copy otherwise, or republish, to post on servers or to redistribute to lists, \nrequires prior speci.c permission and/or a fee. Request permissions from permissions@acm.org. POPL 14, \nJanuary 22 24, 2014, San Diego, CA, USA. Copyright c &#38;#169; 2014 ACM 978-1-4503-2544-8/14/01. . . \n$15.00. http://dx.doi.org/10.1145/2535838.2535871 only need to reason locally about those heaps directly \naffected by the program. So far, most of the applications of separation logic have ex\u00adploited only separating \nconjunction. For example, all existing ver\u00adi.cation tools based on separation logic, such as Smallfoot \n[3], Space Invader [11], THOR [23], SLAyer [1], HIP [25], jStar [12], Xisa [10], VeriFast [19], Infer \n[7], and Predator [14], use a decid\u00adable fragment by Berdine et al. [2] or its extension which provides \nonly separating conjunction. By virtue of the principle of local rea\u00adsoning, however, these tools are \nhighly successful in their individ\u00adual veri.cation domains despite not using separating implication at \nall. Although separating implication is not discussed as extensively as separating conjunction in the \nliterature, its power in program veri.cation has nevertheless been well recognized. Just around the inception \nof separation logic, Yang [29] already gives an elegant proof of the correctness of the Schorr-Waite \nalgorithm which relies crucially on the use of separating implication in the main loop in\u00advariant. Krishnaswami \n[20] shows how to reason abstractly about an iterator protocol with separation logic by exploiting separating \nimplication in the speci.cation of iterators. Maeda et al. [22] adopt the idea of separating implication \nin extending an alias type sys\u00adtem in order to express tail-recursive operations on recursive data structures. \nRecently Hobor and Villard [17] give a concise proof of the correctness of Cheney s garbage collector \nin a proof system based on the ramify rule, a cousin of the frame rule of separation logic, whose premise \nchecks a logical entailment involving sepa\u00adrating implication. These promising results arguably suggest \nthat introducing separating implication alone raises the level of tech\u00adnology for program veri.cation \nas much as separation logic only with separating conjunction improves on Hoare logic. Despite the potential \nbene.t of separating implication in pro\u00adgram veri.cation, however, there is still no practical theorem \nprover for full separation logic. The state-of-the-art theorem provers for separation logic such as SeLoger \n[16] and SLP [24] support only separating conjunction, and the labelled tableau calculus by Galmiche \nand M\u00b4 ery [15] does not directly give rise to a proof search strategy. Because of the unavailability \nof such a theorem prover, all proofs exploiting separating implication should be man\u00adually checked, which \ncan be time-consuming even with the help of lemmas provided by the proof system (as in [17]). Another \ncon\u00adsequence is that no existing veri.cation tools based on separation logic can fully support backward \nreasoning by weakest precondi\u00adtion generation, which requires separating implication whenever verifying \nheap assignments (see Ishtiaq and O Hearn [18]). This paper develops a proof system PSL for full separation \nlogic which supports not only separating conjunction but also separating implication. Its design is based \non the principle of proof by con\u00adtradiction from classical logic, and we develop its inference rules \nin the style of sequent calculus. PSL uses a new form of sequent, called world sequent, in order to give \na complete description of the world of heaps, and its use of world sequents allows us to treat separating \nimplication in the same way that it treats separating con\u00adjunction. The key challenge in the development \nof PSL is to devise a set of inference rules for manipulating heap structures so as to correctly analyze \nseparating conjunction and separating implica\u00adtion. We show that PSL satis.es the admissibility of cut \nand that it is sound and complete with respect to separation logic. The proof of completeness directly \ntranslates to a proof search strategy, which is the basis for our prototype implementation of PSL. We \nshow that it is easy to extend PSL with new logical connectives and pred\u00adicates, such as an overlapping \nconjunction A .* B by Hobor and Villard [17].  Separating implication has been commonly considered to \nbe much harder to reason about than separating conjunction, as par\u00adtially evidenced by lack of theorem \nprovers supporting separat\u00ading implication and abundance of veri.cation systems supporting separating \nconjunction. Our development of PSL, however, sug\u00adgests that a proof system designed in a principled \nway can support both logical connectives in a coherent way without requiring dis\u00adtinct treatments. Our \nprototype implementation of PSL also sug\u00adgests that such a proof system can develop into a practical \ntheorem prover for separation logic. To the best of our knowledge, PSL is the .rst proof system for full \nseparation logic that satis.es the ad\u00admissibility of cut and provides a concrete proof search strategy. \nThis paper is organized as follows. Section 2 gives preliminar\u00adies on separation logic. Section 3 develops \nour proof system PSL and Section 4 gives three examples of proving world sequents. Sec\u00adtion 6 proves \nthe soundness and completeness of PSL with respect to separation logic and Section 7 discusses the implementation \nand extension of PSL. Section 8 discusses related work and Section 9 concludes. 2. Semantics of separation \nlogic Separation logic extends classical .rst-order logic with multiplica\u00adtive formulas from intuitionistic \nlinear logic: formula primitive formula expression location expression value location A, B, C ::= P ::= \nE ::= l ::= V ::= L1, L2, L3, \u00b7 \u00b7 \u00b7 P | . | \u00acA | A . A |I | A * A | A -* A | .a.A [l . E] | E = E | \u00b7 \n\u00b7 \u00b7 x | a | L | \u00b7 \u00b7 \u00b7 x | a | L L | \u00b7 \u00b7 \u00b7 stack variable x, y, z local variable a, b, c ., \u00acA, A . B, \nand .a.A are from classical .rst-order logic. I is the multiplicative unit. A * B is a separating conjunction \nand A -* B is a separating implication. We de.ne T as \u00ac., A . B as \u00ac(\u00acA . \u00acB), and A . B as \u00acA . B. We \nuse conventional precedence rules for logical connectives: \u00ac > * > . > -* > .. In this work, we do not \nconsider inductively de.ned predicates. Primitive formulas include a points-to relation [l . E] for de\u00adscribing \na singleton heap. All other primitive formulas describe re\u00adlations between expressions; for simplicity, \nwe consider only an equality relation E = E'. Expressions denote values which include locations L. Location \nexpressions are a special class of expressions that denote locations. In the present work, we allow only \nlocations as values, but it should be straightforward to introduce additional forms of expressions for \nnew types of values such as booleans and integers. We syntactically distinguish between stack variables \nwhich originate from the program being veri.ed (and thus may be called global variables instead) and \nlocal variables which are intro\u00adduced by existential quanti.ers (and thus can never appear outside corresponding \nexistential formulas). We specify the semantics of separation logic with respect to a stack and a heap. \nA stack S is a .nite partial mapping Var -Val from stack variables to values where Var denotes the set \nof stack variables and Val denotes the set of values. Given a stack S, we can determine a unique value \nfor every expression E, which we write as [E]S. A heap H is a .nite partial mapping Loc -Val from locations \nto values where Loc denotes the set of locations. We write H1#H2 to mean that heaps H1 and H2 are disjoint, \ni.e., dom(H1) n dom(H2) = \u00d8. We write H1 . H2 for the union of disjoint heaps H1 and H2 where H1#H2 is \nassumed, and E for an empty heap. Heaps form a commutative cancellative monoid with . as the associative \noperation and E as the identity: (neutrality) H . E = H (commutativity) H1 . H2 = H2 . H1 (associativity) \nH1 . (H2 . H3) = (H1 . H2) . H3 (cancellativity) H . H1 = H . H2 implies H1 = H2. Given a stack S and \na heap H, we obtain the semantics of sepa\u00adration logic from the satisfaction relation (S, H ) |= A for \nformulas de.ned as follows: (S, H ) |= [l . E] iff. H = ([l]S . [E]S), i.e., H is a sin\u00adgleton heap mapping \n[l]S to [E]S . (S, H ) |= E = E' iff. [E]S = [E']S . (S, H ) |= . iff. never. (S, H ) |= \u00acA iff. (S, \nH ) |= A.  (S, H ) |= A . B iff. (S, H ) |= A or (S, H ) |= B.  (S, H ) |= I iff. dom(H) = \u00d8, i.e., \nH = E. (S, H ) |= A * B iff. H = H1 . H2 and (S, H1) |= A and (S, H2) |= B for some heaps H1 and H2. \n (S, H ) |= A -* B iff. H2 = H . H1 implies (S, H1) |= A or (S, H2) |= B for any heaps H1 and H2.  \n(S, H ) |= .a.A iff. (S, H ) |= [V /a]A for some value V .  Note that the de.nition of (S, H ) |= .a.A \ndirectly substitutes value V for local variable a in formula A (in [V /a]A) without extending stack S \nbecause we syntactically distinguish between stack variables and local variables. Although the satisfaction \nrelation (S, H ) |= A is enough for specifying the semantics of separation logic, we deliberately derive \nthe de.nition of its negation (S, H ) |= A, which plays an equally important role in the development \nof our proof system: (S, H ) |= [l . E] iff. H ([l]S . [E]S ), i.e., dom(H)= = {[l]S } or H([l]S) = [E]S \n. (S, H ) |= E = E' iff. [E]S = [E']S . (S, H ) |= . iff. always. (S, H ) |= \u00acA iff. (S, H ) |= A. \n (S, H ) |= A . B iff. (S, H ) |= A and (S, H ) |= B.  (S, H ) |= I iff. dom(H) = \u00d8, i.e., H = E. (S, \nH ) |= A * B iff. H = H1 . H2 implies (S, H1) |= A or (S, H2) |= B for any heaps H1 and H2.  (S, H ) \n|= A -* B iff. H2 = H . H1 and (S, H1) |= A and (S, H2) |= B for some heaps H1 and H2.  (S, H ) |= .a.A \niff. (S, H ) |= [V /a]A for any value V .  We observe that the de.nition for separating implication \nis sym\u00admetric to the de.nition for separating conjunction: (S, H ) |= A * B should .nd a certain pair \nof heaps whereas (S, H ) |= A * B should analyze an unspeci.ed pair of heaps.  (S, H ) |= A -* B should \nanalyze an unspeci.ed pair of heaps whereas (S, H ) |= A -* B should .nd a certain pair of heaps.  \n This symmetry suggests that we can incorporate separating impli\u00adcation into the proof system in an analogous \nway to separating con\u00adjunction. A formula A is valid, written |= A, if (S, H ) |= A holds for every stack \nS and heap H. Our proof system PSL can check the validity of every formula in separation logic. 3. Proof \nsystem PSL for separation logic This section presents the proof system PSL for separation logic which \nis developed in the style of sequent calculus. We .rst explain world sequents, the main judgment in PSL, \nand then present the inference rules. 3.1 World sequents The design of PSL is based on the principle \nof proof by contradic\u00adtion from classical logic. We describe the state of each heap with a set of true \nformulas and another set of false formulas. A world se\u00adquent in PSL gives a description of the entire \nworld of heaps, and a derivation of it means that the description is self-contradictory. Hence, in order \nto check the validity of a formula in separation logic, we use it as a false formula about an arbitrary \nheap w (about which nothing is known) and attempt to produce a logical contra\u00addiction by proving a world \nsequent consisting solely of heap w. The de.nition of world sequents and the principle of proof by contra\u00addiction \nare inherited from the nested sequent calculus for Boolean BI by Park et al. [26]. Since PSL is designed \nto check the validity of a formula, it assumes an arbitrary stack, which implies that every stack variable \ndenotes an arbitrary value. This in turn implies that in a derivation of a world sequent, we may use \na fresh stack variable to denote an arbitrary value. We exploit this interpretation of stack variables \nin an inference rule for .rst-order formulas. A world sequent consists of expression relations T, heap \nrela\u00adtions S, and heap sequents .: expression relation . ::= E = E ' | E = E ' expression relations T \n= .1, \u00b7 \u00b7 \u00b7 , .n heap variable w, u, v . . heap relation s ::= w = E | w = E | . . w = [l . E] | w = \n[l . E] | . w = w1 . w2 heap relations S = s1, \u00b7 \u00b7 \u00b7 , sn truth context G ::= \u00b7 | G, A falsehood context \n. ::= \u00b7 | ., A heap sequent p ::= [G =. .]w heap sequents . = p1, \u00b7 \u00b7 \u00b7 , pn world sequent T; S I . \nAn expression relation . is an equality or inequality between two expressions. If we introduce new forms \nof primitive formu\u00adlas (e.g., E < E '), we should introduce corresponding forms of expression relations. \n We assign a heap variable to each heap, and a heap relation s  . . relates a heap to an empty heap \n(w = E and w = E), a singleton . . heap (w = [l . E] and w = [l . E]), or the union of two . disjoint \nheaps (w = w1 . w2). We refer to those heap relation involving an empty heap or a singleton heap as atomic \nheap relations. As heaps form a commutative (cancellative) monoid, we assume commutativity of . and use \nw1 . w2 and w2 . w1 interchangeably. A heap sequent [G =. .]w describes heap w with truth con\u00adtext G \nand falsehood context . which contain true formulas and false formulas, respectively, about heap w. In \nthis way, a world sequent T; S I . gives a complete description of the world of heaps. We require that \nno local variable appear in expression relations and heap relations, and that a world sequent contain \na unique heap sequent for each heap variable. A world sequent represents a graph of heaps induced by \nheap . relations. Given a heap relation w = w1 . w2, we say that parent heap w has two child heaps w1 \nand w2 which are sibling heaps to each other. We can also extend parent-child relations to derive ancestor-descendant \nrelations. If a heap has no pair of child heaps, we call it a terminal heap (where we ignore such a heap \nrelation . . as w = w . wE with wE = E); otherwise we call it a non-terminal . . heap. Note that a heap \nrelation w = E or w = [l . E] does not immediately mean that w is a terminal heap because we may have \n. another heap relation w = w1 . w2. PSL, however, allows us to normalize all heap relations and turn \nw into a terminal heap. PSL also uses an expression contradiction judgment T f . which is an abbreviation \nof a particular form of a world sequent T; \u00b7 I \u00b7 and means that expression relations T produce a logical \ncontradiction. Since the de.nition of expression relations is ex\u00adtensible, we do not give inference rules \nfor the expression con\u00adtradiction judgment and just assume a decidable system for it. For simplicity, \nwe write T f E = E ' for T, E = E ' f ., and T f E = E ' for T, E = E ' f .. We write T f [l . E] = [l \n' . E ' ] for T f l = l ' and T f E = E ', and T f [l . E] = [l ' . E ' ] for T f l = l ' or T f E = \nE ' . PSL consists of logical rules in Figure 1, structural rules in Fig\u00adure 2, and heap contradiction \nrules in Figure 3. The logical rules deal with formulas in heap sequents ., the structural rules reor\u00adganize \ngraphs of heaps induced by heap relations S, and the heap contradiction rules detect logical contradictions \nin heap relations S, or heap contradictions. PSL shares the logical rules (for propo\u00adsitional and multiplicative \nformulas) with the nested sequent cal\u00adculus for Boolean BI in [26], but the structural rules and the \nheap contradiction rules are speci.c to separation logic. We read every inference rule from the conclusion \nto the premise, and the deriva\u00adtion of a world sequent always terminates with a proof of a logical contradiction. \nHence, in order to show the validity of a formula A, we try to prove a world sequent \u00b7; \u00b7 I [\u00b7 =. A]w \n.  3.2 Logical rules of PSL Figure 1 shows the logical rules of PSL. Except for the rule ExpCont, a \nlogical rule focuses on a principal formula in a heap sequent and either produces a logical contradiction \n(in the rule .L) or rewrites the world sequent of the conclusion according to the semantics of separation \nlogic in Section 2. For each type of formu\u00adlas, PSL has both a left rule, which analyzes a true formula \nabout a heap, and a right rule, which analyzes a false formula about a heap, as in a typical sequent \ncalculus. The rules for points-to relations in\u00adtroduce a corresponding heap relation. The rules for propositional \nand .rst-order formulas are from .rst-order classical logic. In the rule .L, the fresh stack variable \nx denotes an arbitrary value. In the rules .L and .R, we write [E/a]A for substituting expression E for \nlocal variable a in formula A. The rules =L and =R are the only rules that add expression relations, \nand the rule ExpCont checks if expression relations T produce a logical contradiction. The rules IL and \nIR use the fact the I is true only at an empty heap. The rules *L and *R are based on the following interpretation \nof multiplicative conjunction * which closely matches the seman\u00adtics of separation logic in Section 2: \n. A * B is true at heap w iff. w = w1 . w2 and A is true at heap w1 and B is true at heap w2 for some \nheaps w1 and w2. .  A * B is false at heap w iff. w = w1 . w2 implies that A is false at heap w1 or \nthat B is false at heap w2 for any heaps w1 and w2.  Hence the rule *L creates (some) fresh child heaps \nw1 and w2, whereas the rule *R chooses (any) existing child heaps w1 and  Rules for points-to relations: \n . . T; S, w = [l . E] ., [G =. .]w T; S, w= [l . E] ., [G =. .]w .L .R T; S ., [G, [l . E] =. .]wT; \nS ., [G =. ., [l . E]]w Rules for propositional formulas: T; S ., [G =. ., A]w T; S ., [G, A =. .]w \n.L \u00acL \u00acR T; S ., [G, . =. .]w T; S ., [G, \u00acA =. .]w T; S ., [G =. ., \u00acA]w T; S ., [G, A =. .]w T; S ., \n[G, B =. .]w T; S ., [G =. ., A, B]w .L .R T; S ., [G, A . B =. .]w T; S ., [G =. ., A . B]w Rules for \nmultiplicative formulas: . . T; S, w = E ., [G =. .]w T; S, w= E ., [G =. .]w IL IR T; S ., [G, I =. \n.]w T; S ., [G =. ., I]w . fresh w1, w2 T; S, w = w1 . w2 ., [G =. .]w , [A =. \u00b7]w1 , [B =. \u00b7]w2 T; S \n., [G,A* B =. .]w *L T; S ., [G =. ., A * B ]w , [G1 =. .1, A]w1 , [G2 =. .2]w2 . w = w1 . w2 . S T; \nS ., [G =. ., A * B ]w , [G1 =. .1]w1 , [G2 =. .2, B ]w2 T; S ., [G =. ., A * B]w , [G1 =. .1]w1 , [G2 \n=. .2]w2 *R T; S ., [G, A -* B =. .]w , [G1 =. .1, A]w1 , [G2 =. .2]w2 . w2 = w . w1 . S T; S ., [G, \nA -* B =. .]w , [G1 =. .1]w1 , [G2, B =. .2]w2 -*L T; S ., [G, A -* B =. .]w , [G1 =. .1]w1 , [G2 =. \n.2]w2 . fresh w1, w2 T; S, w2 = w . w1 ., [G =. .]w , [A =. \u00b7]w1 , [\u00b7 =. B]w2 -*R T; S ., [G =. ., A \n-* B]w Rules for .rst-order formulas: fresh x T; S ., [G, [x/a]A =. .]w T; S ., [G =. ., [E /a]A, .a.A]w \n.L .R T; S ., [G, .a.A =. .]w T; S ., [G =. ., .a.A]w Rules for primitive formulas for expressions: \nT, E = E ' ; S ., [G =. .]w T f . T, E= E ' ; S ., [G =. .]w =L =R ExpCont T; S ., [G, E = E ' =. .]w \nT; S ., [G =. ., E = E ' ]w T; S . Figure 1. Logical rules in the proof system PSL for separation logic \nw2. Similarly the rules -*L and -*R are based on the following interpretation of multiplicative implication \n-*: . A -* B is true at heap w iff. w2 = w . w1 implies that A is false at heap w1 or that B is true \nat heap w2 for any heaps w1 and w2. . A -* B is false at heap w iff. w2 = w . w1 and A is true at heap \nw1 and B is false at heap w2 for some heaps w1 and w2. Hence the rule -*L chooses (any) existing sibling \nheap w1 and parent heap w2, whereas as the rule -*R creates (some) fresh sibling heap w1 and parent heap \nw2. The rules *L and -*R are the only logical rules that add parent-child heap relations to extend the \ngraph of heaps, and introduce fresh heap variables w1 and w2 that are not found in the world sequent \nin the conclusion. The rules *R and -*L are the only logical rules that replicate the principal formula \ninto world sequents in the premise. In the rules *R and -*L, we allow equalities between heap variables \nw1, w2, and w. Since an equality between these heap variables invalidates the requirement that a world \nsequent contain a unique heap sequent for each heap variable, we interpret heap sequents for the same \nheap variable in the rules *R and -*L as follows: In the conclusion, we implicitly replicate the same \nheap sequent as necessary. In the premise, we combine all changes made to individual heap sequents for \nthe same heap variable to produce a single heap sequent. For example, an equality w = w1 in the rule \n*R yields the follow\u00ad ing special instance: T; S I ., [G =. ., A * B, A]w , [G2 =. .2]w2 . w = w . w2 \n. S T; S I ., [G =. ., A * B]w , [G2 =. .2, B]w2 T; S I ., [G =. ., A * B]w , [G2 =. .2]w2 The rule *R \nhas two more special instances (corresponding to heap . . relations w = w1 . w1 and w = w . w), and similarly \nthe rule -*L has a total of three special instances. Now we can decompose each individual formula by \napplying its corresponding logical rule, thus accumulating expression rela\u00adtions and heap relations and \ncreating fresh heaps. When expression relations become self-contradictory, we apply the rule ExpCont \nto complete the proof search. In order to obtain a complete proof search strategy, however, we should \nalso be able to: 1) enumerate . . all heap relations w = w1 . w2 and w2 = w . w1 for a given heap w for \nthe rules *R and -*L; 2) produce heap contradictions, for . . example, from w = E and w = [l . E]. (We \nassume that we can make a correct guess on expression E in the rule .R.) The remain\u00ading challenge is \nto devise a set of structural rules and another set of heap contradiction rules satisfying these two \nrequirements, which would enable us to enumerate all feasible heap relations from those  Rules for disambiguating \nheap relations and leaving only disjoint terminal heaps: . u1 = w1 . w2, [\u00b7 =. \u00b7]w1 , . u2 = w3 . w4, \n[\u00b7 =. \u00b7]w2 , . v1 = w1 . w3, [\u00b7 =. \u00b7]w3 , .. . {w = u1 . u2, w = v1 . v2} . S fresh w1, w2, w3, w4 T; \nS, v2 = w2 . w4 ., [\u00b7 =. \u00b7]w4 Disj* T; S . . w = w1 . v3, [\u00b7 =. \u00b7]w , . w = v1 . w2, [\u00b7 =. \u00b7]v1 , . u1 \n= v1 . v2, [\u00b7 =. \u00b7]v2 , .. . {w1 = u1 . u2, w2 = u2 . u3} . S fresh w, v1, v2, v3 T; S, u3 = v2 . v3 \n., [\u00b7 =. \u00b7]v3 Disj-* T; S . Rules for applying associativity of the union of disjoint heaps. .. .. 1 \n'' ' {w = u . v, u = u1 . u2} . S fresh u T; S, u = u2 . v, w = u1 . u ., [\u00b7 =. \u00b7]u Assoc T; S . Rules \nfor propagating atomic heap relations: .. .. {w = E, w = w1 . w2} . S T; S, w1 = E, w2 = E . PropE T; \nS . .. .. .. {w = [l . E], w = w1 . w2} . S T; S, w1 = [l . E], w2 = E . T; S, w1 = E, w2 = [l . E] \n. Prop. T; S . .. .. {w = E, w = w1 . w2} . S T; S, w1 = E . T; S, w2 = E . . PropE= T; S . .. .. T; \nS, w1 = E, w1 = [l . E] . T; S, w1 = [l . E], w2 = [l . E] . .. .. .. {w = [l . E], w = w1 . w2} . S \nT; S, w1 = E, w2 = E . T; S, w2 = E, w2 = [l . E] . . Prop.= T; S . Rules for normalizing heap relations: \n. T; [w/w ' ]S, w = u . v ., [G, G ' =. ., . ' ]w NormEq . . 1 ' T; S, w = u . v, w = u . v ., [G \n=. .]w , [G ' =. . ' ]w . . T; [w/u]S, v = E ., [G, G ' =. ., . ' ]w T; [w/u]S, w = E ., [G, G ' =. ., \n. ' ]w . . NormPC . . NormEmpty T; S, w = u . v, v = E ., [G =. .]w , [G ' =. . ' ]u T; S, w = E, u \n= E ., [G =. .]w , [G ' =. . ' ]u Rules for creating an empty heap and applying the monoid laws for empty \nheaps: . .... fresh wE T; S, wE = E ., [\u00b7 =. \u00b7]w' wE = E . S T; S, w = w . wE . w = w . u . S T; S, u \n= E . ENew EJoin ECancel T; S . T; S . T; S . Figure 2. Structural rules in the proof system PSL for \nseparation logic generated by the logical rules and detect all types of heap contra\u00addictions.  3.3 Structural \nrules of PSL The structural rules of PSL are divided into .ve groups according to their roles in reorganizing \ngraphs of heaps represented by world sequents. The order of the structural rules in Figure 2 roughly \nfol\u00adlows their use in the proof of the completeness of PSL with respect to separation logic (Theorem \n6.4). In a certain sense, we design the structural rules so as to obtain a complete proof search strat\u00adegy \nfor separation logic when the logical rules are already given as in Figure 1. Below we informally discuss \nthe key properties of the structural rules, which we formally present as part of the proof of the completeness \nof PSL in Section 6.2. 3.3.1 Rules for disambiguating heap relations The rules Disj* and Disj-* disambiguate \nheap relations in order to leave only disjoint terminal heaps. Roughly speaking, two heaps are disjoint \nif they share a common ancestor which has a heap relation separating them. In the premise of the rule \nDisj*, child heaps ui and vj (i, j = 1, 2) share a common parent heap w, but their exact relations are \nunknown. For example, heap u1 may completely subsume, partially overlap with, or be disjoint from heap \nv1. In general, each pair of child heaps ui and vj are allowed to share a common child heap, so the rule \nDisj* disambiguates their relations by introducing four fresh terminal heaps, w1 to w4, which are all \ndisjoint from each other: Disj* =. Now, for example, we may assume that the intersection of heaps u1 \nand v1 is represented by heap w1. Note that if heap ui or vj is not a terminal heap, the rule Disj* gives \nrise to unknown relations between the existing child heaps of ui or vj and two of the fresh terminal \nheaps. The rule Disj* corresponds to the cross-split axiom for separation algebras [13].  The rule Disj-* \ndisambiguates relations between two sibling heaps u1 and u3 of heap u2 by introducing three fresh terminal \nheaps, v1 to v3, which are all disjoint from each other: Disj-* =. Similarly to the rule Disj*, the \nrule Disj-* may give rise to new unknown relations involving heap w1, w2, u1, or u3. Unlike the rule \nDisj*, however, it also creates a common ancestor w of all heaps. Otherwise the fresh terminal heaps \nthemselves come to have unknown relations, thereby defeating the purpose of applying the rule Disj-*. \nThus the rule Disj* eliminates unknown relations between child heaps and the rule Disj-* eliminates unknown \nrelations between sibling heaps of a certain heap, both potentially creating similar unknown relations. \nBy repeatedly applying these rules, we can eventually obtain a graph of heaps such that: 1) there exists \na root heap that is an ancestor of all other heaps; 2) all terminal heaps in the graph are disjoint. \n 3.3.2 Rule for applying associativity of . The rule Assoc creates new heap relations according to associativ\u00adity \nof the union of disjoint heaps. Suppose that we have two heap . . relations w = u . v and u = u1 . u2. \nThe rule Assoc introduces a fresh heap u ' in order to associate two heaps u2 and v which are known to \nbe disjoint but do not have a common parent heap yet; it also assigns heap w as the common parent heap \nof heaps u1 and u ' : Assoc =. Note that unlike the rules Disj* and Disj-*, the rule Assoc creates \nno fresh terminal heaps. The rule Assoc is crucial for enumerating all heap relations in\u00advolving a particular \nheap. The basic observation is that by repeat\u00adedly applying the rule Assoc to a graph of heaps, we can \neventually obtain another graph of heaps with the same set of terminal heaps such that for each combination \nof terminal heaps, there is at least one heap subsuming exactly these terminal heaps and no others. By \nstarting with a graph of heaps obtained by repeatedly applying the rules Disj* and Disj-*, then, we can \nenumerate all feasible heap . . relations w = w1 . w2 and w2 = w . w1 for a particular heap w where we \nassume that heaps w1 and w2 are in the graph. For the case that w1 or w2 is an empty heap, however, we \nneed another set of structural rules for dealing with empty heaps. We should also combine heap sequents \nfor the same heap. (Hence we have not yet accomplished the .rst requirement for obtaining a complete \nproof search strategy.) 3.3.3 Rules for propagating atomic heap relations The rules for propagating \natomic heap relations, or propagation . rules, are designed to propagate all atomic heap relations (w \n= E, .. . w = E, w = [l . E], w = [l . E]) from non-terminal heaps to terminal heaps. A propagation rule \nconverts an atomic heap relation for a heap w into semantically equivalent heap relations for its child \n. heaps w1 and w2 (with w = w1 . w2). It rewrites world sequents according to the following fact on atomic \nheap relations where we . assume w = w1 . w2: ... . w = E iff. w1 = E and w2 = E (for the rules Prop \nE and PropE = ). . ...  w = [l . E] iff. either w1 = [l . E] and w2 = E, or w1 = E  . . and w2 = [l \n. E] (for the rules Prop . and Prop .= ). For example, we negate the second clause to derive the rule \n. Prop .= which has four world sequents in the premise: . ... w = [l . E] iff. 1) w1 = [l . E] and w1 \n= E; 2) w1 = [l . E] . ... and w2 = [l . E]; 3) w2 = E and w1 = E; or 4) w2 = E and . w2 = [l . E]. Note \nthat although the new heap relations for the child heaps w1 and w2 collectively imply the original heap \nrelation s, we have to preserve s in every world sequent of the premise because it may still interact \nwith another pair of child heaps w1 ' and w2 ' (with . ' ' w = w1 . w2). After considering all such interactions, \nhowever, we may safely discard s (by the rule Weaken to be introduced in Section 6.2). The propagation \nrules are the .rst step toward a complete pro\u00adcedure for producing heap contradictions (which detect \nall types of heap contradictions). Suppose that we repeatedly apply the prop\u00adagation rules until no more \nnew heap relations arise from atomic heap relations. After discarding atomic heap relations for non\u00adterminal \nheaps, we obtain a set of graphs of heaps (with the same structure as the original graph) in which atomic \nheap relations re\u00adside only for terminal heaps. Now, in order to produce heap contra\u00addictions from atomic \nheap relations, we need to inspect only termi\u00adnal heaps of these graphs, which makes it much easier to \ndevelop a complete procedure for producing heap contradictions.  3.3.4 Rules for normalizing heap relations \nThe rules for normalizing heap relations, or normalization rules, merge two identical heaps and isolate \nempty heaps while simulta\u00adneously shrinking the graph of heaps. In the rule NormEq, heaps w and w ' are \nidentical and we merge the two heaps by combin\u00ading their heap sequents. Here we write [w/w ' ]S for substituting \nw for w ' in every heap relation in S. Note that the rule NormEq im\u00ad . plies that . is (partial) deterministic. \nIn the rule NormPC, v = E implies that heaps w and u are identical. Hence we merge the two heaps by combining \ntheir heap sequents and isolate the empty heap v from the graph of heaps. Similarly the rule NormEmpty \nmerges two empty heaps w and u by combining their heap sequents. In effect, it allows us to collect all \nempty heaps, which do not need to be distinguished for the purpose of proof search, into a single empty \nheap. Note that the rule NormEmpty implies the existence of a single unit of .. By repeatedly applying \nthe normalization rules to a graph of heaps, we can eventually obtain an equivalent graph which maintains \na unique world sequent for each heap and possibly a unique empty heap isolated from the graph. It is \nimportant that the normalization rules shrink the graph of heaps, but preserve all the properties established \nby the previous structural rules. For example, if the graph satis.es the property that all terminal heaps \nare disjoint (established by the rules Disj* and Disj-*), it continues to satisfy the same property after \nan appli\u00adcation of any normalization rule. Hence it is safe to aggressively apply the normalization rules \nafter applying the previous structural rules.  T f [l . E] = [l ' . E ' ] . . . . ContE. . . ContE= \n. . Cont.= T; S, w = E, w = [l . E] . T; S, w = E, w = E . T; S, w = [l . E], w = [l ' . E ' ] . T f \n[l . E] = [l ' . E ' ] . T f l1 = l2 . . Cont.= .. . Cont . . T; S, w = [l . E], w = [l ' . E ' ] . T; \nS, w = w1 . w2, w1 = [l1 . E1], w2 = [l2 . E2] . Figure 3. Heap contradiction rules in the proof system \nPSL for separation logic 3.3.5 Rules for dealing with empty heaps The last group of structural rules \ncreate an empty heap and apply the monoid laws for empty heaps. We use the rule ENew when no rule can \ndirectly produce an empty heap. The rule EJoin, which is based on neutrality of E, is sound because extending \na heap with an empty heap makes no change. The rule ECancel creates an empty heap when a heap is shown \nto be a child heap of itself. It is . based on cancellativity of . : we can always generate w = w . wE \n. . and wE = E by the rules ENew and EJoin, and w = w . u and . . w = w . wE imply u = E by cancellativity \nof .. (Similarly the rule NormPC is based on cancellativity of .: we can always generate . .. w = w . \nv by the rule EJoin, and w = u . v and w = w . v imply w = u.) It turns out that we need the rule ECancel \nfor the proof of admissibility of cut (Theorem 5.1), but not for the proof of the completeness of PSL \n(Theorem 6.4). Now we can accomplish the .rst requirement for obtaining a complete proof search strategy. \nIn order to enumerate all heap . . relations w = w1 . w2 and w2 = w . w1 for a heap w, we .rst analyze \nthe graph of heaps obtained by repeatedly applying the previous structural rules. This produces all such \nheap relations that involve only non-empty heaps. Then we apply the rule EJoin as necessary to produce \nall such heap relations that involve empty heaps. We may think of the rule EJoin as extending heap relations \nfor heap w with a pair of child heaps w and wE, or a pair of sibling heap wE and parent heap w. It is \nthe only rule in PSL that is capable of creating new heap relations for an arbitrary heap. Thus, whenever \nan arbitrary heap with no heap relation needs a pair of child heaps or a pair of sibling and parent heaps, \nwe should apply the rule EJoin which inevitably reuses an existing empty heap. For example, we prove \nthe validity of T * T as follows: . . .L \u00b7; wE = E, w = w . wE I [. =. T * T]w , [\u00b7 =. \u00b7]w' . . . \u00acR \n. \u00b7; wE = E, w = w . wE I [\u00b7 =. T * T, T]w , [\u00b7 =. \u00b7]w' . .. *R \u00b7; wE = E, w = w . wE I [\u00b7 =. T * T]w \n, [\u00b7 =. \u00b7]w' . EJoin \u00b7; wE = E I [\u00b7 =. T * T]w , [\u00b7 =. \u00b7]w' \u00b7; \u00b7 I [\u00b7 =. T * T]w ENew Note that there \nis no need to create fresh child heaps w1 and w2 . with w = w1 . w2: if we can prove the world sequent \nusing fresh child heaps about which nothing is known, we should be able to prove it equally by reusing \nan existing empty heap. Similarly we prove the validity of \u00ac(T -* .) as follows: . . . .L . . \u00b7; wE = \nE, w = w . wE I [T -* ., . =. \u00b7]w , [\u00b7 =. \u00b7]w' . . -*L \u00b7; wE = E, w = w . wE I [T -* . =. \u00b7]w , [\u00b7 =. \n\u00b7]w' . EJoin \u00b7; wE = E I [T -* . =. \u00b7]w , [\u00b7 =. \u00b7]w' \u00b7; \u00b7 I [T -* . =. \u00b7]w ENew \u00b7; \u00b7 I [\u00b7 =. \u00ac(T -* .)]w \n\u00acR Again we do not create fresh sibling and parent heaps and instead reuse an existing empty heap.  \n3.4 Heap contradiction rules of PSL . The proof system PSL has .ve rules, Cont E= to Cont . ., for producing \nheap contradictions. In conjunction with the structural rules, these rules enable us to detect all types \nof heap contradic\u00adtions, thereby accomplishing the second requirement for obtaining a complete proof \nstrategy. To see why, assume a world sequent T; S I .. By repeat\u00adedly applying the structural rules in \nthe same order as presented above, we can obtain a semantically equivalent set of world se\u00adquents T; \nSi I .i (i = 1, \u00b7 \u00b7 \u00b7 , n) such that: 1) Si induces a graph of heaps in which all terminal heaps are \ndisjoint; 2) atomic heap relations reside only for terminal heaps and we need to con\u00adsider only terminal \nheaps to detect heap contradictions. For an . empty heap, we use the rules ContE = and ContE . which \nex\u00adpress the only ways to produce heap contradictions from an empty . .. heap with w = E. Note that w \n= E and w = [l . E] do not pro\u00adduce a heap contradiction because the former implies the latter. . For \na terminal singleton heap, we use the rules Cont .= and . Cont.= which express the only ways to produce \nheap contra\u00ad . dictions from a terminal singleton heap with w = [l . E]. Note . .. that w = [l . E] implies \nw = E always and w = [l ' . E ' ] if T f [l . E] = [l ' . E ' ] holds. We do not need to consider other \nforms of terminal heaps, for example, those with no atomic heap relations. Finally the rule Cont . . \nexpresses the only way to produce heap contradictions from two disjoint terminal singleton . . heaps \nwith w1 = [l1 . E1] and w2 = [l2 . E2]. This is because if T f l1 = l2 holds, the two heap relations \nare consistent with . w = w1 . w2 and we cannot produce a heap contradiction. In this way, we can detect \nall types of heap contradictions in heap rela\u00adtions. 4. Examples of proving world sequents This section \npresents three examples of proving world sequents in PSL. We write [l . \u00b7] to denote [l . E] for some \nexpression E and assume two distinct location expressions l and l ' (l = l ').  4.1 \u00ac(([l . \u00b7] * [l \n' . \u00b7]) . ([l . \u00b7] * \u00ac[l ' . \u00b7])) The goal formula implies that given a fragment of a heap, we can uniquely \ndetermine the remaining fragment. Its proof illustrates that the rule Disj* indirectly applies cancellativity \nof . to two pairs of child heaps. We begin with a world sequent \u00b7; \u00b7 I [\u00b7 =. C]w where C is the goal \nformula. After applying the logical rules, we obtain the following graph of heaps where heap relations \nare displayed for child heaps: Then we apply the rule Disj* and the propagation rules Prop. and . Prop \n.= to generate 2 \u00d7 2 \u00d7 2 \u00d7 4 = 32 different world sequents as new goals. All these new goals are immediately \nprovable by the . . rules Cont E., ContE= , and Cont .= . An example of such a  . world sequent has \nheap relations w4 = [l ' . \u00b7], originating from . heap u2 by the rule Prop., and w4 = [l ' . \u00b7], originating \nfrom . heap v2 by the rule Prop .= : . By applying the rule Cont .= to heap w4, we complete the proof. \n4.2 A * A . A where A = \u00ac(T -* \u00acI) The goal formula is valid in separation logic because heaps form a \npartial deterministic monoid: H1 . H2 may be unde.ned (when H1#H2 does not hold), but if it is de.ned, \nthe result is unique. In contrast, the same formula is not valid in Boolean BI, the underly\u00ading theory \nof separation logic, which assumes a non-deterministic monoid [21]. The proof illustrates the use of \nthe rule EJoin in proving a non\u00adtrivial formula. After applying the logical rules to a world sequent \n\u00b7; \u00b7 I [\u00b7 =. A * A . A]w, we obtain the following graph of heaps: Since heap w has no sibling and parent \nheaps, we cannot apply the rule -*L to T -* \u00acI at this point. To make further progress, we apply either \nthe rule Disj-* or the rule EJoin after creating an empty heap. If we apply the rule EJoin, we obtain \nthe following graph: An application of the rule -*L to T -* \u00acI at heap w generates two new goals, and \nthe interesting case produces \u00acI as a true formula at the same heap (where we omit T -* \u00acI): By applying \nthe logical rules to heap w and the propagation rule Prop E, we obtain the following graph: . Now we \ncan either apply the propagation rule Prop E= to heap w or use the rule NormPC to complete the proof. \n 4.3 \u00ac(([l ' . \u00b7] -* .) . ([l . \u00b7] * \u00ac([l . \u00b7] -* ([l ' . \u00b7] -* .)))) The goal formula is an example \nof a formula that cannot be proven without an application of the rule Disj-*. After applying the logi\u00adcal \nrules to a world sequent \u00b7; \u00b7 I [\u00b7 =. C]w1 where C is the goal formula, we obtain the following graph: \n We wish to identify heaps w1 and w2 (because heaps u1 and u3 are identical), but there is no way to \nmake further progress toward identifying w1 and w2 without applying the rule Disj-*. Hence we apply the \nrule Disj-* and the propagation rule Prop . to heaps u1 and u3. After eliminating three new goals that \nare immediately provable, we obtain the following graph: By applying the rule NormPC to merge heaps \nw1 and w2, we obtain a heap sequent [[l ' . \u00b7] -* . =. [l ' . \u00b7] -* .]w, which is easily provable. 5. \nAdmissibility of cut We state the admissibility of cut in PSL as follows: Theorem 5.1 (Admissibility \nof cut). If T; S I ., [G =. ., C ]w and T; S I ., [G, C =. .]w, then T; S I ., [G =. .]w . Theorem 5.1 \nassumes a few properties, such as weakening and contraction, of the expression contradiction judgment \nT f . (for which we do not provide inference rules). In particular, we assume its own admissibility of \ncut (where \u00ac. denotes the negation of .): T1, . f . and T2, \u00ac. f . imply T1, T2 f .. The .rst step in \nthe proof of Theorem 5.1 is to show that it is safe to merge two arbitrary heap sequents: Lemma 5.2. \nIf T; S I ., [G1 =. .1]u , [G2 =. .2]v, then T; [u/v]S I ., [G1, G2 =. .1, .2]u . Intuitively the second \nworld sequent inherits every heap relation from the .rst world sequent, so we should be able to prove \nthe second by the same sequence of rules in the proof of the .rst or its subsequence.  Next we prove \nthe contraction property for heap relations: Proposition 5.3. If T; S, s, s I ., then T; S, s I .. The \nstatement in Proposition 5.3 implicitly assumes that we may apply the rules Disj*, Disj-*, and Assoc \nto the same heap relation. For the rules Disj* and Disj-*, the proof for such an application, which essentially \nhas no effect, requires the rules ENew and EJoin, which are necessary for the completeness of PSL anyway. \nFor the rule Assoc, however, the proof for such an application requires the rule ECancel, which is unnecessary \nfor the completeness of PSL. Hence, if we never apply the rule Assoc to the same heap relation, we may \ndiscard the rule ECancel. To prove Theorem 5.1, we generalize its statement as follows: Lemma 5.4. If \nT1; S1 I .1, [G1 =. .1, C]w and T2; S2 I .2, [G2, C =. .2]w , then T1, T2; S1, S2 I .1 l .2, [G1, G2 \n=. .1, .2]w . Here .1 l .2 denotes the result of combining heap sequents for the same heap variable. \nIn conjunction with the contraction prop\u00aderty for formulas, Lemma 5.4 implies Theorem 5.1. 6. Soundness \nand completeness of PSL This section proves the soundness and completeness of the proof system PSL with \nrespect to separation logic. The proof of sound\u00adness is straightforward, whereas the proof of completeness \nuses several subtle properties of graphs of heaps represented by world sequents. In this section, metavariable \nW denotes world sequents and heap variables directly refer to heaps. For simplicity, we do not consider \n.rst-order formulas. 6.1 Soundness The soundness property states that a derivation of a world sequent \nmeans that its semantic interpretation is self-contradictory. As a special case, we obtain Theorem 6.1: \nTheorem 6.1 (Soundness). If \u00b7; \u00b7 I [\u00b7 =. A]w , then |= A. The key step in the proof of soundness is to \nshow that in any inference rule of PSL, the world sequent in the conclusion is ei\u00adther self-contradictory \nin itself or semantically implies the disjunc\u00adtion of all world sequents in the premise. Given a stack \nS, let us write [W ]S for the interpretation of world sequent W accord\u00ading to the semantics of separation \nlogic (which is formally de\u00ad.ned below). We wish to prove that a derivation of W implies \u00ac[W ]S , i.e., \n[W ]S is self-contradictory, for any stack S. Sup\u00adpose that the last inference rule in the derivation \nof W is not an axiom and has world sequents W1, \u00b7 \u00b7 \u00b7 , Wn in its premise (n = 1). By induction hypothesis, \nwe have \u00b7 \u00b7 \u00b7 , \u00ac[Wn]S, or ( \u00ac[W1]S, equivalently, \u00ac[Wi]S . Then, by proving that [W ]S im\u00ad a i=1,\u00b7\u00b7\u00b7 \n,n ( plies Wi]S , we prove that \u00ac[Wi]S implies i=1,\u00b7\u00b7\u00b7 ,n i=1,\u00b7\u00b7\u00b7 ,n \u00ac[W ]S . Now \u00ac[ W ]S immediately \nfollows. Formally we de.ne [W ]S using three auxiliary semantic func\u00adtions [.]S, [s]S , and [p]S, all \nof which follow our intuition on world sequents given in Section 3.1: E = E ' S = E S = E ' S = E ' \n[ E . S = [ E] S = [ E '] S w = E S = w = E . = E S = w = E [ w . w = [l . E] S = w = ( l S . E S ) \n. w = [l . E] S = w = ([ l] S . [ E] S ) . = w1 . w2 = w = w1 . w2 [ w S ( ( [[G =. .]w S = (S, w) |= \nA . (S, w) |= B (A.G ( B.. ( [T; S I .] S = ..T [.]S . s.S [s]S . p.. [p]S Now we prove the key step \nin the proof of soundness: Lemma 6.2. For every inference rule with the conclusion W and the premise \nconsisting of W1, \u00b7 \u00b7 \u00b7 , Wn, it holds that [W ]S implies a ,n [Wi]S for any stack S. If n = 0, we have \n\u00ac[W ]S . i=1,\u00b7\u00b7\u00b7 As a corollary, we prove that a derivation of a world sequent means that its semantic \ninterpretation is self-contradictory. Corollary 6.3. If there is a derivation of a world sequent W in \nPSL, then \u00ac[W ]S holds for any stack S. For the rule ExpCont, we assume that T f . implies \u00ac[T f .]S \n. Then a derivation of \u00b7; \u00b7 I [\u00b7 =. A]w implies (S, w) |= A: \u00ac[\u00b7; \u00b7 I [\u00b7 =. A]w ]S = \u00ac(S, w) |= A = (S, \nw) |= A Since w denotes an arbitrary heap, we have |= A and Theorem 6.1 follows.  6.2 Completeness The \ncompleteness property states that a valid formula in separation logic has a proof of its negation in \nPSL: Theorem 6.4 (Completeness). If |= A, then \u00b7; \u00b7 I [\u00b7 =. A]w . For the proof of completeness, we weaken \nthe rules *R and -*L by discarding their principal formula in the premise. The original rules are invertible \nand useless applications with wrong heap rela\u00adtions are safe, but only because the principal formula \nsurvives in the premise and we can always try different heap relations without having to backtrack. This \nis, however, inadequate for the proof of completeness, which must show how to actually .nd a right heap \nrelation. Hence we weaken the rules *R and -*L to directly re.ect the semantics of * and -*, but also \npresent a scheme for com\u00adputing the complete set of heap relations for a given heap. We also introduce \nan explicit weakening rule for eliminating an atomic heap relation (which is admissible) as a new structural \nrule: s is an atomic heap relation T; S I . Weaken T; S, s I . We use the rule Weaken to eliminate all \natomic heap relations at non-terminal heaps when the propagation rules can produce no more new heap relations. \nAs explained in Section 5, we do not use the rule ECancel. Our proof of Theorem 6.4 uses three new concepts: \ncanonical world sequents, disjunctive derivation states, and conjunctive proof goals. A canonical world \nsequent Z is a special form of a world sequent such that if \u00ac[Z]S holds for any stack S, we can construct \nits derivation using only the rules .L, ExpCont, and the heap contradiction rules. (In Proposition 6.12, \nwe introduce a class of world sequents that are shown to be canonical.) A disjunctive derivation state \n. for a world sequent W is a set of world sequents that constitute all the leaves in a partial derivation \nof W . That is, a disjunctive derivation state . = {W1, \u00b7 \u00b7 \u00b7 , Wn}for a world sequent W means that there \nis a partial derivation of the following form: W1 \u00b7 \u00b7 \u00b7 Wn . . . . . . . . . W R We use a reduction judgment \n. . . ' to mean that such a partial derivation expands to another partial derivation with disjunctive \nderivation state . ' by an application of the logical or structural rule R to some world sequent Wi (1 \n= i = n). That is, we have . ' = . - {Wi} . {W 1 \u00b7 \u00b7 \u00b7 , W m} with: i , i  W 1 i \u00b7 \u00b7 \u00b7 W m i W1 \u00b7 \u00b7 \n\u00b7 Wi . . . . . . . . . \u00b7 \u00b7 \u00b7 R Wn W We write . . * . ' for the re.exive and transitive closure of .. \na For a stack S, we de.ne the interpretation [.]S = Wi.. [Wi]S . A conjunctive proof goal O is a set \nof disjunctive derivation states for a common world sequent. Given a logical or structural R rule R, \nwe use a reduction judgment O O ' to mean that we can generate O ' by applying the rule R to some disjunctive \nderivation state . in O. That is, we have O ' = O - {.} . {. ' \u00b7 \u00b7 \u00b7 , . ' } 1, n R and . . .i ' for \ni = 1, \u00b7 \u00b7 \u00b7 , n. If R is the rule *R or -*L, we have n = 1 and produce each . ' i by focusing on the \nsame formula in the same heap sequent in the same world sequent in .. For all the other rules, we have \nn = 1 and replace . by . ' 1. We write O * O ' for the re.exive and transitive closure of . For a stack \nS, we de.ne the interpretation [O]S = (.i.O [.i]S . In order to prove Theorem 6.4, assume a goal formula \nA such that |= A. We aim to build a sequence of conjunctive proof goals O1 , \u00b7 \u00b7 \u00b7 , ON such that: O1 \n= {{W }} where W = \u00b7; \u00b7 I [\u00b7 =. A]w . Oi+1 Oi Ri for i = 1, \u00b7 \u00b7 \u00b7 , N - 1 where Ri is a logical or structural \nrule. [Oi+1]S implies [Oi]S for i = 1, \u00b7 \u00b7 \u00b7 , N - 1 and any stack S.  ON contains only canonical world \nsequents.  With such a sequence of conjunctive proof goals, we can build a derivation of W as follows: \n Since we have |= A, we have (S, w) |= A = \u00ac(S, w) |= A = \u00ac[W ]S = \u00ac[O1 ]S for any stack S.  Since \n[ON ]S implies [O1]S , we have \u00ac[ON ]S .  Since every disjunctive derivation state in ON contains only \ncanonical world sequents, we may write ON = j .j and  Zj .j = k k. Since we have \u00ac[ON ]S = \u00ac (j [.j \n]S = a j \u00ac[.j ]S , there exists a disjunctive derivation state .j such that \u00ac[.j ]S holds.  Since we \nhave \u00ac[.j ]S = \u00ac a k [Zk j ]S = (k \u00ac[Zk j ]S , we have \u00ac[Zk j ]S for each k.  Since O1 * ON , we have \n{W } . * .j .  Since we have \u00ac[Zk j ]S for each k, there is a derivation of Zj  k for each k by the \nde.nition of canonical world sequents. By combining {W } . * .j and the derivation of Zj for each k k, \nwe obtain a derivation of W . Below we explain how to build such a sequence of conjunctive proof goals. \n6.2.1 Completeness of the invertible rules Suppose that a world sequent in Oi contains a formula to which \nwe can apply a rule R other than .L, *R, and -*L. By applying the R rule R, we obtain Oi Oi+1. By Corollary \n6.6, [Oi+1]S implies [Oi]S for any stack S. In this way, we can eliminate all such formulas without losing \ncompleteness. Proposition 6.5. Except for the rules .L, ExpCont, *R, -*L, and Weaken, every logical or \nstructural rule with the conclusion W and the premise consisting of W1, \u00b7 \u00b7 \u00b7 , Wn is invertible in that \na ,n [Wi]S implies [W ]S for any stack S.i=1,\u00b7\u00b7\u00b7 Corollary 6.6 (Completeness of the invertible rules). \nFor such an invertible rule R and any stack S, R if {W } . ., then [.]S implies [{W }]S .  6.2.2 Completeness \nof the rules *R, -*L, and Weaken We now show how to recover the completeness of the rules *R and -*L. \nWe introduce several notations in order to concisely describe properties of graphs of heaps: w / u means \nthat there is a sequence of zero or more child\u00adparent relations from heap w to heap u in the graph: w \n= w0, . ' . ' w1 = w0 . w0, \u00b7 \u00b7 \u00b7 , wn = wn-1 . wn-1, and wn = u for n = 0. Hence, if w = u, heap w is \na descendant of heap u, or equivalently, heap u is an ancestor of heap w. Note that we allow w / w. w \n. means that w is a terminal heap, i.e., there is no heap . relation w = u . v. T(w) denotes the set \nof terminal descendants of heap w, i.e., T(w) = {v | v . and v / w}. We assume that heap relations in \nevery world sequent induce not only a graph of heaps but also a special empty heap wE with . heap relation \nwE = E that is separate from the graph. This assump\u00adtion is safe because we can always generate such \na special empty heap with the rule ENew if there is none, and combine multiple empty heaps with the rule \nNormEmpty if there are many. We clas\u00adsify world sequents according to the property of graphs of heaps \nin\u00adduced by their heap relations (without considering its special empty heap wE) as follows: . 1. Elementary: \nif w = w1 . w2, then T (w1) n T (w2) = \u00d8. 2. Rooted: elementary and there is a root heap w such that \nv / w for every heap v. . .  3. Consistent: rooted and if w = u1 . u2 and w = v1 . v2, then T(u1) . \nT (u2) = T (v1) . T (v2). 4. Full: consistent and for any non-empty set S of terminal heaps, there exists \nat least one heap w with T (w) = S. 5. *-ready for heap w: full and for any pair of non-empty sets S1 \nand S2 of terminal heaps such that S1 n S2 = \u00d8 and S1 . S2 = T (w), there exist heaps w1 and w2 such \nthat  . w = w1 . w2 with T (w1) = S1 and T (w2) = S2. 6. -*-ready for heap w: full and for any pair \nof non-empty sets S1 and S2 of terminal heaps such that T (w) n S1 = \u00d8 and T(w) . S1 = S2, there exist \nheaps w1 and w2 such that . w2 = w . w1 with T (w1) = S1 and T (w2) = S2. 7. Saturated: full and applications \nof the propagation rules pro\u00adduce no more new heap relations. 8. Sanitized: full and non-terminal heaps \nhave no atomic heap relations. 9. Normalized: sanitized with no empty heaps and for any non\u00adempty set \nS of terminal heaps, there exists a unique heap w with T (w) = S. 10. Expanded: obtained by applying \nonly the logical rules except *R and -*L to some consistent world sequent.  Suppose that a world sequent \nin Oi contains a false formula A * B or a true formula A -* B about heap w. By converting it into normalized \nworld sequents that are also *-ready or -*-ready for heap w according to Corollary 6.10, we obtain Oi \n* Oi+1 such that [Oi+1]S implies [Oi]S for any stack S. By Propo\u00adsition 6.11, we can apply the rule *R \nor -*L to obtain Oi+2 .ROi+2 .L or Oi+1 - Oi+2 with Oi+1 such that [Oi+2]S implies [Oi+1]S for any stack \nS. In this way, we can eliminate every false  formula A * B or true formula A -* B without losing complete\u00adness. \nLemma 6.7. For a world sequent W of a particular kind, there exists a world sequent W ' of another kind \nsuch that: 1) {W } . * {W ' } by applying only the structural rules; 2) [{W ' }]S implies [{W }]S for \nany stack S, where one of the following holds: 1. W is expanded and W ' is rooted; 2. W is rooted (generated \nin step 1) and W ' is consistent; 3. W is consistent and W ' is full; 4. W is full and W ' is *-ready \nfor a given heap w; 4 . W is full and W ' is -*-ready for a given heap w;  8. W is sanitized and *-ready \n( -*-ready) for a given heap w, and W ' is normalized and *-ready ( -*-ready) for heap w. Lemma 6.8. \nFor a world sequent W of a particular kind, there exists a disjunctive derivation state . such that: \n1) {W } . * . by applying only the propagation rules; 2) [.]S implies [{W }]S for any stack S, where \none of the following holds: 5. W is *-ready for a given heap w, and every world sequent in . is saturated \nas well as *-ready for heap w. 6. W is -*-ready for a given heap w, and every world sequent in . is \nsaturated as well as -*-ready for heap w.  Lemma 6.9 (Completeness of the rule Weaken). For any satu\u00adrated \nworld sequent W , there exists a sanitized world sequent W ' such that: 1) {W } . * {W ' } by applying \nonly the rule Weaken; 2) [{W ' }]S implies [{W }]S for any stack S. Corollary 6.10. For any expanded \nworld sequent W and heap w, there exists a disjunctive derivation state . such that: 1) {W } . * . by \napplying only the structural rules; 2) . contains only normalized world sequents that are also *-ready \nor -* -ready for heap w; 3) [.]S implies [{W }]S for any stack S. Proposition 6.11 (Completeness of the \nrules *R and -*L). Consider a normalized world sequent W that is also *-ready for heap w. Suppose that \nwe obtain {W } .R.i by applying the rule *R to a false formula A * B about heap w for each heap rela\u00ad. \n' R tion w = wi . wi (i = 1, \u00b7 \u00b7 \u00b7 , n), and {W } . .E by applying the . rule *R to the same formula \nfor another heap relation w = w . wE. Then a conjunctive proof goal O = {.1, \u00b7 \u00b7 \u00b7 , .n, .E} satis.es: \n1) {{W }} R O; 2) [O]S implies [{{W }}]S for any stack S; 3) No world sequent in O contains the false \nformula A * B about heap w; 4) Every world sequent in O is still normalized and thus consis\u00adtent. Similarly \nfor the rule -*L where we use each heap relation . ' wi = w . wi.  6.2.3 Completeness of the heap contradiction \nrules Suppose that after eliminating all formulas other than ., we obtain a conjunctive proof goal Oi \nwhich contains only expanded world sequents. By Corollary 6.10, we can obtain Oi * Oi+1 such that every \nworld sequent in Oi+1 is normalized and [Oi+1]S implies [Oi]S for any stack S. Proposition 6.12 shows \nthat Oi+1 contains only canonical world sequents. Proposition 6.12 (Completeness of the heap contradiction \nrules). A normalized world sequent W with no formulas other than . is canonical. That is, if \u00ac[W ]S holds \nfor any stack S, we can construct its derivation using only the rules .L, ExpCont, and the  Figure 4. \nProof search strategy based on the proof of Theorem 6.4 heap contradiction rules. For the rule ExpCont, \nwe assume that \u00ac[T f .]S implies T f .. Thus we conclude the proof of Theorem 6.4.  6.3 Proof search \nstrategy Figure 4 shows the proof search strategy based on the proof of The\u00adorem 6.4. Given a world sequent \nof the form \u00b7; \u00b7 I [\u00b7 =. A]w, we repeatedly apply the logical rules other than the rules *R and -*L to \nobtain expanded world sequents according to Corollary 6.6 (from initial to expanded). Then we apply a \nseries of structural rules to ob\u00adtain normalized world sequents according to Corollary 6.10 (from expanded \nto normalized). If no formulas other than . remain, we attempt to generate a logical contradiction according \nto Proposi\u00adtion 6.12 (from normalized to contradiction). Otherwise we apply the rule *R or -*L to obtain \nconsistent world sequents according to Proposition 6.11 (from normalized to consistent). By repeatedly \napplying the logical rules other than the rules *R and -*L again, we obtain another set of expanded world \nsequents according to Corol\u00adlary 6.6 (from consistent to expanded). In this way, we can eventu\u00adally decompose \nall formulas other than . and complete the proof search. As it directly translates to a proof search \nstrategy, the proof of Theorem 6.4 agrees with the result that propositional separation logic is decidable \n[9]. Since .rst-order separation logic is undecid\u00adable [5], the proof system PSL becomes undecidable \nin the pres\u00adence of the rule .R. We also remark that in the presence of propo\u00adsitional variables, even \npropositional separation logic is undecid\u00adable [6].  6.4 Validity of formulas in PSL As established \nby Theorems 6.1 and 6.4, the notion of validity in PSL means that a formula is true (or an assumption \nof its falsehood leads to a logical contradiction) at an arbitrary heap about which nothing is known. \nAn important implication of assuming such an arbitrary heap is that we in effect assume an arbitrary \nworld of heaps, since even the relationship with an external heap can be thought of as a property of \nthe arbitrary heap, which is assumed to be unknown. In particular, we may not assume the existence of \na singleton heap with location L even if the goal formula contains a points-to relation [L . E].  As \nan example, consider a formula A = I . \u00ac([L . E] -* \u00ac[L . E]) which states that an empty heap combined \nwith a heap satisfying [L . E] cannot be a heap where [L . E] is false. According to the semantics of \nseparation logic in Section 2, this formula is valid but only provided that a singleton heap satisfying \n[L . E] is known to exist. The existence of such a singleton heap, however, is an assumption that can \nbe justi.ed only by inspecting the formula at the meta-logical level. Since PSL assumes an arbitrary \nworld of heaps without knowing the existence of such a singleton heap, it fails to prove the above formula. \nIf we are to show the validity of a formula by exploiting prior knowledge on the world of heaps, we should \nprove an extended formula that incorporates its meta-logical property as well. For example, in order \nto show the validity of the above formula A when the existence of a singleton heap satisfying [L . E] \nis already known, we should instead prove an extended formula [L . E] * T . \u00ac(\u00acA * T) which states that \nif the world of heaps contains a heap satisfying [L . E], there cannot exist a heap where A is false, \ni.e., A is true at any heap. An attempt to prove the extended formula produces a world sequent [\u00b7 =. \n\u00b7]w , [[L . E] =. \u00b7]u1 , [T =. \u00b7]u2 , . w = u1 . u2, [\u00b7 =. A]v1 , . \u00b7; w = v1 . v2 I [T =. \u00b7]v2 which \nessentially expresses that formula A is false at an arbitrary heap when there exists a heap satisfying \n[L . E]. A proof of this world sequent complies with the validity of formula A in separation logic. 7. \nDiscussion Our prototype implementation of PSL (without .rst-order formu\u00adlas) is based on the proof of \nTheorem 6.4, but with a few changes. In particular, it internally uses a different type of normalized \nworld sequents which maintain a unique heap corresponding to each non\u00adempty set of terminal heaps, but \npermit unknown relations be\u00adtween heaps. The decision is based on the observation that it is the rules \nDisj* and Disj-* (for eliminating unknown relations be\u00adtween heaps) that contributes the most to the \ncomplexity of graphs of heaps. Thus it selectively applies the rules Disj* and Disj-* only when it cannot \ncomplete the proof search otherwise. Our experience with the prototype implementation of PSL shows that \nit allows us to incorporate new logical connectives and predicates in a principled way without having \nto introduce addi\u00adtional structural rules. As an example, consider an overlapping conjunction A.* B by \nHobor and Villard [17] which can be de.ned in the framework of PSL as follows: . . A .* B is true at \nheap w iff. w = w1 . v2, w = v1 . w2, . . w1 = v1 . u, w2 = u . v2, and A is true at heap w1 and B is \ntrue at heap w2 for some heaps w1, w2, v1, v2, and u. . . A .* B is false at heap w iff. w = w1 . v2, \nw = v1 . w2, . . w1 = v1 . u, and w2 = u . v2 implies that A is false at heap w1 or that B is false at \nheap w2 for any heaps w1, w2, v1, v2, and u. We directly translate this de.nition into two inference \nrules for .*: fresh w1, w2, v1, v2, u [A =. \u00b7]w1 , . w = w1 . v2, [B =. \u00b7]w2 , . w = v1 . w2, [\u00b7 =. \n\u00b7]v1 , . w1 = v1 . u, [\u00b7 =. \u00b7]v2 , . T; S, w2 = u . v2 I ., [G =. .]w , [\u00b7 =. \u00b7]u T; S I ., [G, A .* \nB =. .]w .*L [G =. ., A .* B]w , T; S I ., [G1 =. .1, A]w1 , . w = w1 . v2, [G2 =. .2]w2 . w = v1 . w2, \n. w1 = v1 . u, [G =. ., A .* B]w , . { w2 = u . v2 } . S T; S I ., [G1 =. .1]w1 , [G2 =. .2, B]w2 [G \n=. ., A .* B]w , .*R T; S I ., [G1 =. .1]w1 , [G2 =. .2]w2 Note that we obtain the rules .*L and .*R \nexactly in the same way that we derive the rules *L and *R from the interpretation of multiplicative \nconjunction *. The only difference is that we create .ve fresh heaps in the rule .*L and try to detect \na subgraph consisting of six existing heaps in the rule .*R. Equally important is that we need no additional \nstructural or heap contradiction rules because overlapping conjunction does not require new forms of \nheap relations. Thus, in principle, it is relatively easy to incorporate overlapping conjunction into \nour prototype implementation of PSL. Overall we may think of PSL as a highly extensible proof system \nfor separation logic. 8. Related work 8.1 Automated veri.cation tools based on separation logic Separation \nlogic has been the basis for a number of automated veri\u00ad.cation tools targeting programs using mutable \ndata structures. The .rst such tool is Smallfoot by Berdine et al. [3] which aims to test the feasibility \nof automated veri.cation using separation logic. To achieve full automation, it permits no pointer arithmetic \nand ver\u00adi.es only shape properties of linked lists and trees. Space Invader by Distefano et al. [11] \npermits pointer arithmetic by integrating the abstract interpretation method into the symbolic execution \nmethod in [4]. THOR by Magill et al. [23] is an extension of Space Invader which is capable of tracking \nthe length of linked lists. SLAyer by Berdine et al. [1] is another extension of Space Invader which \nuses higher-order predicates to express common properties of nodes in linked lists. The use of higher-order \npredicates enables SLAyer to verify shape properties of composite linked lists such as linked lists of \ncircular linked lists. There are also several tools supporting arbitrary data structures. HIP by Nguyen \nand Chin [25] allows users to specify invariants on arbitrary data structures in terms of inductive predicates. \nSince checking these invariants usually relies on basic properties of in\u00adductive predicates that are \neasy to prove but dif.cult to discover automatically, HIP requires users to explicitly state such proper\u00adties \nin the form of lemmas, which are automatically proven and then applied as necessary. Similarly to HIP, \nVeriFast by Jacobs et al. [19] relies on user-supplied inductive predicates and lemmas. Unlike HIP, however, \nVeriFast requires users to provide proofs of these lemmas and specify when to apply them. jStar by Distefano \nand Parkinson [12] is an extension of Space Invader which exploits user-supplied abstraction rules in \norder to support arbitrary data structures. Its distinguishing feature is the ability to infer loop in\u00advariants \nautomatically. Xisa by Chang and Rival [10] takes a differ\u00adent approach by indirectly specifying invariants \non data structures with validation code. Xisa analyzes validation code to extract in\u00adductive predicates \nfor describing invariants as well as lemmas for describing their basic properties. Since validation code \ncan be writ\u00adten in common programming languages, users of Xisa do not need the expertise to specify invariants \nof interest in terms of inductive predicates.  All these tools use as their logical foundation not full \nseparation logic but only its decidable fragment by Berdine et al. [2], which does not include separating \nimplication -*. As shown by Ishtiaq and O Hearn [18], lack of separating implication implies no sup\u00adport \nfor backward reasoning by weakest precondition generation for those programs performing heap assignments \nor allocation. As a result, these tools allow only forward reasoning based on sym\u00adbolic execution as \nin [4] and do not demonstrate the full potential of separation logic in program veri.cation.  8.2 Proof \nsearch in full separation logic Despite the practical importance of separating implication, proof search \nin full separation logic has not drawn much attention from researchers. Calcagno et al. [8] present a \ntranslation from proposi\u00adtional separation logic to .rst-order logic (with only propositional connectives \nand no multiplicative connectives) for which a decision procedure already exists. The labelled tableau \ncalculus for sepa\u00adration logic by Galmiche and M \u00b4ery [15] supports both separating conjunction and separating \nimplication. Similarly to our proof sys\u00adtem PSL, their calculus combines both syntactic (tableau) and \nse\u00admantic (labelled) formulations and uses labels to directly refer to heaps. Although it is shown to \nbe sound and complete, their cal\u00adculus does not give rise to a proof search strategy. Speci.cally, in \norder to check that all branches in a tableau are logically or struc\u00adturally inconsistent, we need two \nsemantic functions, a measure and an interpretation, for each branch. Their calculus, however, does not \nexplain how to construct such semantic functions for each branch and it is not clear how to extract a \nconcrete proof search strategy. The closest proof system to ours is the nested sequent calculus SBBI \nfor Boolean BI by Park et al. [26], which inspired the over\u00adall design of PSL. Similarly to world sequents \nin PSL, sequents in SBBI use a truth context consisting of true formulas and a false\u00adhood context consisting \nof false formulas, and both systems are based on the principle of proof by contradiction. Because of \nthe similarity in syntactic formulations, their approach to dealing with separating conjunction and separating \nimplication in SBBI equally applies to our setting for PSL, which is not surprising considering that \nseparation logic is just an instance of Boolean BI with addi\u00adtional restrictions on the semantic structure. \nThe structural rules of PSL, however, are speci.c to separation logic and are designed in\u00addependently \nof SBBI. Since SBBI allows propositional variables, we may use its theorem prover as a supplementary \nsystem for our implementation of PSL. For theorem provers based on the decidable fragment of sep\u00adaration \nlogic by Berdine et al. [2] (without separating implica\u00adtion), see, for example, SeLoger [16] and SLP \n[24]. For an iso\u00admorphism between (intuitionistic) separation logic and implicit dy\u00adnamic frames, see \n[27]. 9. Conclusion We have presented a proof system PSL for full separation logic with separating implication. \nConsidering the potential bene.t of separating implication, we envision that program veri.cation sys\u00adtems \nin the future will provide separating implication and support backward reasoning by weakest precondition \ngeneration for their scalability in program veri.cation. We also envision that proof as\u00adsistants can \ninterface with theorem provers for separation logic and provide a powerful automation tactic for dealing \nwith logical con\u00adnectives from separation logic. When extended with inductively de\u00ad.ned predicates, PSL \nmay serve as a practical foundation for such systems. Acknowledgments We are grateful to the anonymous \nreviewers for their helpful com\u00adments and Zh \u00b4e H \u00b4ou for a comment on the completeness of PSL that led \nto the discussion in Section 6.4. This work was supported by the Engineering Research Center of Excellence \nProgram of Ko\u00adrea Ministry of Science, ICT &#38; Future Planning (MSIP)/National Research Foundation \nof Korea (NRF) (Grant NRF-2008-0062609) and Mid-career Researcher Program through NRF funded by the MEST \n(2010-0022061). References [1] Josh Berdine, Cristiano Calcagno, Byron Cook, Dino Distefano, Pe\u00adter W. \nO Hearn, Thomas Wies, and Hongseok Yang. Shape analysis for composite data structures. In Proc. CAV, \npages 178 192, 2007. [2] Josh Berdine, Cristiano Calcagno, and Peter W. O Hearn. A decidable fragment \nof separation logic. In Proc. FSTTCS, pages 97 109, 2004. [3] Josh Berdine, Cristiano Calcagno, and Peter \nW. O Hearn. Smallfoot: Modular automatic assertion checking with separation logic. In Proc. FMCO, pages \n115 137, 2005. [4] Josh Berdine, Cristiano Calcagno, and Peter W. O Hearn. Symbolic execution with separation \nlogic. In Proc. APLAS, pages 52 68, 2005. [5] R\u00b4emi Brochenin, St \u00b4ephane Demri, and Etienne Lozes. On \nthe almighty wand. Information and Computation, 211:106 137, 2012. [6] James Brotherston and Max Kanovich. \nUndecidability of proposi\u00adtional separation logic and its neighbours. In Proc. LICS, pages 130 139, 2010. \n[7] Cristiano Calcagno and Dino Distefano. Infer: an automatic program veri.er for memory safety of C \nprograms. In Proceedings of the Third international conference on NASA Formal methods, pages 459 465, \n2011. [8] Cristiano Calcagno, Philippa Gardner, and Matthew Hague. From separation logic to .rst-order \nlogic. In Proc. FOSSACS, pages 395 409, 2005. [9] Cristiano Calcagno, Hongseok Yang, and Peter W. O Hearn. \nCom\u00adputability and complexity results for a spatial assertion language for data structures. In Proceedings \nof the 21st Conference on Foun\u00addations of Software Technology and Theoretical Computer Science, pages \n108 119, 2001. [10] Bor-Yuh Evan Chang and Xavier Rival. Relational inductive shape analysis. In Proc. \nPOPL, pages 247 260, 2008. [11] Dino Distefano, Peter W. O Hearn, and Hongseok Yang. A local shape analysis \nbased on separation logic. In Proc. TACAS, pages 287 302, 2006. [12] Dino Distefano and Matthew J. Parkinson. \njStar: towards practical veri.cation for Java. In Proc. OOPSLA, pages 213 226, 2008. [13] Robert Dockins, \nAquinas Hobor, and Andrew W. Appel. A fresh look at separation algebras and share accounting. In Proc. \nAPLAS, pages 161 177, 2009. [14] Kamil Dudka, Petr M \u00a8uller, Petr Peringer, and Tom \u00b4a.s Vojnar. Predator: \na tool for veri.cation of low-level list manipulation. In Proc. TACAS, pages 627 629, 2013. [15] Didier \nGalmiche and Daniel M\u00b4 ery. Tableaux and resource graphs for separation logic. Journal of Logic and Computation, \n20:189 231, 2010. [16] Christoph Haase, Samin Ishtiaq, Jo\u00a8el Ouaknine, and Matthew J. Parkinson. SeLoger: \nA tool for graph-based reasoning in separation logic. In Proc. CAV, pages 790 795, 2013. [17] Aquinas \nHobor and Jules Villard. The rami.cations of sharing in data structures. In Proc. POPL, pages 523 536, \n2013.  [18] Samin S. Ishtiaq and Peter W. O Hearn. BI as an assertion language for mutable data structures. \nIn Proc. POPL, pages 14 26, 2001. [19] Bart Jacobs, Jan Smans, and Frank Piessens. VeriFast: Imperative \nprograms as proofs. In Proc. VSTTE, pages 59 68, 2010. [20] Neelakantan R. Krishnaswami. Reasoning about \niterators with sepa\u00adration logic. In Proc. SAVCBS, pages 83 86, 2006. [21] Dominique Larchey-Wendling \nand Didier Galmiche. The undecid\u00adability of boolean BI through phase semantics. In Proc. LICS, pages \n140 149, 2010. [22] Toshiyuki Maeda, Haruki Sato, and Akinori Yonezawa. Extended alias type system using \nseparating implication. In Proc. TLDI, pages 29 42, 2011. [23] Stephen Magill, Josh Berdine, Edmund M. \nClarke, and Byron Cook. Arithmetic strengthening for shape analysis. In Proc. SAS, pages 419 436, 2007. \n[24] Juan Antonio Navarro P\u00b4 Separation erez and Andrey Rybalchenko. logic + superposition calculus = \nheap theorem prover. In Proc. PLDI, pages 556 566, 2011. [25] Huu Hai Nguyen and Wei-Ngan Chin. Enhancing \nprogram veri.cation with lemmas. In Proc. CAV, pages 355 369, 2008. [26] Jonghyun Park, Jeongbong Seo, \nand Sungwoo Park. A theorem prover for Boolean BI. In Proc. POPL, pages 219 232, 2013. [27] Matthew J. \nParkinson and Alexander J. Summers. The relationship between separation logic and implicit dynamic frames. \nIn Proc. ESOP, pages 439 458, 2011. [28] John C. Reynolds. Separation logic: A logic for shared mutable \ndata structures. In Proc. LICS, pages 55 74, 2002. [29] Hongseok Yang. An example of local reasoning \nin BI pointer logic: the Schorr-Waite graph marking algorithm. In Proceedings of the 1st Workshop on \nSemantics, Program Analysis, and Computing Environ\u00adments for Memory Management, pages 41 68, 2001.  \n  \n\t\t\t", "proc_id": "2535838", "abstract": "<p>Separation logic is an extension of Hoare logic which is acknowledged as an enabling technology for large-scale program verification. It features two new logical connectives, separating conjunction and separating implication, but most of the applications of separation logic have exploited only separating conjunction without considering separating implication. Nevertheless the power of separating implication has been well recognized and there is a growing interest in its use for program verification. This paper develops a proof system for full separation logic which supports not only separating conjunction but also separating implication. The proof system is developed in the style of sequent calculus and satisfies the admissibility of cut. The key challenge in the development is to devise a set of inference rules for manipulating heap structures that ensure the completeness of the proof system with respect to separation logic. We show that our proof of completeness directly translates to a proof search strategy.</p>", "authors": [{"name": "Wonyeol Lee", "author_profile_id": "86158666457", "affiliation": "Pohang University of Science and Technology (POSTECH), Gyeongbuk, South Korea", "person_id": "P4383886", "email_address": "leewy@postech.ac.kr", "orcid_id": ""}, {"name": "Sungwoo Park", "author_profile_id": "81100161164", "affiliation": "Pohang University of Science and Technology (POSTECH), Gyeongbuk, South Korea", "person_id": "P4383887", "email_address": "gla@postech.ac.kr", "orcid_id": ""}], "doi_number": "10.1145/2535838.2535871", "year": "2014", "article_id": "2535871", "conference": "POPL", "title": "A proof system for separation logic with magic wand", "url": "http://dl.acm.org/citation.cfm?id=2535871"}