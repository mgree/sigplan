{"article_publication_date": "01-08-2014", "fulltext": "\n Modular Reasoning about Concurrent Higher-Order Imperative Programs Lars Birkedal Department of Computer \nScience, Aarhus University birkedal@cs.au.dk Categories and Subject Descriptors D.3.1 [Programming Lan\u00adguages]: \nFormal De.nitions and Theory semantics; D.2.4 [Soft\u00adware Engineering]: Software/Program Veri.cation \nKeywords contextual equivalence; data abstraction; program log\u00adics 1. Introduction Modern mainstream \nprogramming languages permit a powerful combination of language features: concurrency, higher-order func\u00adtions, \nand mutable shared data structures. These features are all very important for programming in practice. \nHowever, it is well\u00adknown that the combination of them makes it dif.cult to write cor\u00adrect and secure \nprograms, and it is therefore important to develop mathematically-based techniques for formal reasoning \nabout cor\u00adrectness and security of programs with these features. To get scalable methods that apply to \nrealistic programs, it is crucial that the mathematical models and logics support modular reasoning, \nmeaning that (1) speci.cations and proofs are composi\u00adtional wrt. the program structure; and (2) speci.cations \nand proofs can concentrate on the resources that a program actually acts upon, instead of its entire \nstate. In this talk I will give an overview of some of the central devel\u00adopments that my group has worked \non when generalizing reason\u00ading techniques for simpler programming languages to concurrent, higher-order, \nimperative languages. I will consider both relational models and program logics based on higher-order \nseparation logic. 2. Kripke Logical Relations One of the most fundamental notions in formal reasoning \nabout programs is contextual re.nement, which expresses when one pro\u00adgram fragment may be replaced by \nanother one, without changing the overall behaviour of a complete program. This is the notion of correctness \nthat one is interested in when, e.g., reasoning about data abstraction or proving compiler optimizations \ncorrect. It is dif\u00ad.cult to reason directly about contextual re.nement of programs and thus there has \nbeen a lot of work on extending the techniques of (bi)simulations and logical relations from simply-typed \npurely functional programming languages to programming languages with Permission to make digital or hard \ncopies of part or all of this work for personal or classroom use is granted without fee provided that \ncopies are not made or distributed for pro.t or commercial advantage and that copies bear this notice \nand the full citation on the .rst page. Copyrights for third-party components of this work must be honored. \nFor all other uses, contact the owner/author(s). POPL 14, January 22 24, 2014, San Diego, CA, USA. Copyright \nis held by the owner/author(s). ACM 978-1-4503-2544-8/14/01. http://dx.doi.org/10.1145/2535838.2537849 \n recursive types, polymorphism, dynamically allocated mutable ref\u00aderences, and, lately, also concurrency. \nFor the work on logical re\u00adlations, the main challenges have been: (1) to develop mathemat\u00adical techniques \nthat are expressive enough to construct the inter\u00adpretation of all the types this is dif.cult when the \nprogramming language includes recursive types and general references, which preclude a de.nition of the \nrelation by direct induction over the types; (2) to develop models that are suf.ciently expressive for \nrea\u00adsoning about uses of local state, i.e., to de.ne the logical relations in such a way that one can \nshow that two programs that use local state in very different ways to implement the same functionality \nare indeed related; and (3) to develop logical relations for concurrent languages which allow one to \nreason about one thread at a time, while still accounting for the possible interference of other running \nthreads. To address these challenges we have developed new kinds of Kripke logical relations using guarded \nrecursion. The resulting models have been used, e.g., (1) to prove correctness of a paral\u00adlelization \ntheorem, which expresses when it is sound to evaluate two expressions in parallel instead of sequentially, \nby giving a rela\u00adtional model for a type-and-effect system; and (2) to show correct\u00adness of .ne-grained \nconcurrent data structures by showing that they are contextual re.nements of their coarse-grained counterparts, \nso that clients can reason about .ne-grained concurrent data structures as if all accessses to them were \nsequentialized. 3. Higher-Order Separation Logics Instead of specifying a program by relating it to another \nprogram, we can specify programs using program logics. Separation logic allows speci.cations and proofs \nto concentrate on the resources that a program actually acts upon, instead of its entire state. To allow \nspeci.cations and proofs to be compositional wrt. the pro\u00adgram structure we developed higher-order separation \nlogic. To rea\u00adson about higher-order imperative programs, we introduced nested triples. These features \nfacilitate modular reasoning about sequen\u00adtial higher-order programs with limited forms of sharing. To \nalso cater for concurrency and sharing, we make use of earlier work that extend rely-guarantee versions \nof separation logic with proto\u00adcols governing access to shared mutable state. For modularity, we use \nhigher-order quanti.cation over so-called impredicative proto\u00adcols. To show soundness of the logic we \nbuild a non-trivial model using guarded recursion. The resulting logic can be used, e.g., to give modular \nspeci.cations of layered and recursive higher-order abstractions, as used ubiquitously in GUI and network \napplications for implementing asynchronous I/O.  \n\t\t\t", "proc_id": "2535838", "abstract": "", "authors": [{"name": "Lars Birkedal", "author_profile_id": "81100622053", "affiliation": "Aarhus University, Aarhus, Denmark", "person_id": "P4383724", "email_address": "birkedal@cs.au.dk", "orcid_id": ""}], "doi_number": "10.1145/2535838.2537849", "year": "2014", "article_id": "2537849", "conference": "POPL", "title": "Modular reasoning about concurrent higher-order imperative programs", "url": "http://dl.acm.org/citation.cfm?id=2537849"}