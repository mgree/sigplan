{"article_publication_date": "01-08-2014", "fulltext": "\n The Essence of Reynolds Stephen Brookes Peter W. O Hearn Uday Reddy Carnegie Mellon University Facebook \nUniversity of Birmingham Abstract John Reynolds (1935-2013) was a pioneer of programming lan\u00adguages \nresearch. In this paper we pay tribute to the man, his ideas, and his in.uence. Categories and Subject \nDescriptors D.3 [Programming Lan\u00ad guages]; F.3 [Logics and Meanings of Programs] Keywords Polymorphic \n.-calculus, Separation Logic, Parametric\u00adity, Data Abstraction, Subtypes, Defunctionalization, Substructural \nLogic and Typing, Possible World Semantics 1. Introduction John Reynolds died on April 28, 2013. He will \nbe remembered for his fundamental and far-sighted research on programming languages: semantics, speci.cations, \nlanguage design, logics and proof methodology. John was born on June 1, 1935, and was raised in Glen \nEllyn, Illinois, a suburb of Chicago. He attended Purdue University as an undergraduate, graduating in \n1956. His Ph.D. thesis in Theoretical Physics (Harvard University, 1961) was titled Surface Properties \nof Nuclear Matter . In later years, with typical modesty and hu\u00admility, John would describe this, one \nof his earliest experiences in computer science, as a big number-crunching program designed to produce \nan uninteresting computation of an unimportant quan\u00adtity in a bad approximation . At Harvard John met \nMary A. Allen, and they married in 1960. John is survived by Mary and their sons, Edward (born 1963) \nand Matthew (born 1965). After Harvard, with a burgeoning interest in computer science, John worked as \na physicist at Argonne National Laboratory. While at Argonne, he developed a compiler for compilers, \ncalled CO-GENT (1965), and he designed the language GEDANKEN (1969). In 1970 he left Argonne for academia, \nmoving to Syracuse Uni\u00adversity as a Professor of Computer and Information Science. Af\u00adter a long and \nfruitful period at Syracuse he moved to Carnegie Mellon University in 1986, where he stayed until retirement \nat the end of 2012. Over the years he enjoyed sabbaticals and visiting positions at many universities \nand institutions, including Stanford University, INRIA (Rocquencourt and Sophia Antipolis), Impe\u00adrial \nCollege (University of London), Lucent Technologies, Queen Mary (University of London), Edinburgh University, \nAarhus Uni\u00adversity, and Microsoft Research (Cambridge, England). He forged Permission to make digital \nor hard copies of all or part of this work for personal or classroom use is granted without fee provided \nthat copies are not made or distributed for pro.t or commercial advantage and that copies bear this notice \nand the full citation on the .rst page. Copyrights for components of this work owned by others than the \nauthor(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or republish, to \npost on servers or to redistribute to lists, requires prior speci.c permission and/or a fee. Request \npermissions from permissions@acm.org. POPL 14, January 22 24, 2014, San Diego, CA, USA. Copyright is \nheld by the owner/author(s). Publication rights licensed to ACM. ACM 978-1-4503-2544-8/14/01. . . $15.00. \nhttp://dx.doi.org/10.1145/10.1145/2535838.2537851 long-lasting ties with many researchers and was highly \nvalued as a colleague. He was an invited speaker at conferences and symposia spanning the world. John \nwas an active member of the Association for Computing Machinery (ACM) for many years, including a long \nstint as editor of the Communications of the ACM and the Journal of the ACM. He became an ACM Fellow \nin 2001, and received the ACM SIG-PLAN Programming Language Achievement Award in 2003. He was a prominent \nmember of IFIP Working Group 2.3. (Program\u00adming Methodology), which he joined in 1969, and IFIP Working \nGroup 2.2 (Formal Language De.nition), in which he participated from 1977 to 1991. The British Computer \nSociety awarded him the Lovelace Medal in 2011. He was a proud recipient of an Honorary D. Sc. degree \nconferred by Queen Mary, University of London, in July 2007. Carnegie Mellon University honored him with \nthe Dana Scott Distinguished Research Award in April 2006. In November 2013 ACM SIGPLAN honoured John \ns memory by renaming their Outstanding Doctoral Dissertation Award to the John C. Reynolds Doctoral Dissertation \nAward. John laid the foundations for the work of many of us in the programming languages research community. \nThe in.uence of his more widely known work on parametric polymorphism and on Separation Logic is very \nplain to see, for example by browsing the pages of recent POPL conferences. What is less well known, \nand perhaps even more striking, is the sheer number of absolutely .rst-rate contributions made by John \nacross a broad range, all of which display his characteristic deep insight. In remembering him, and what \nhe was like as a researcher and colleague, there is no better place to start than with a simple recollection \nof these results. 2. Main works. Early Works. While working at Argonne John became interested in both \nprogramming languages and in automatic theorem proving. He produced COGENT, an early compiler-compiler. \nHe then pro\u00adduced a very signi.cant, yet somewhat overlooked, paper: Automatic computation of data set \nde.nitions. IFIP Congress (1) 1968: 456-461 In modern terminology, this paper computed an over-approximation \nof the kinds of data structures reached in a program, where the data was constructed using Lisp-style \noperations (car, cdr, etc). There is a story associated with this paper. Years later, people were pursuing \nautomatic shape analysis based on Separation Logic, as represented in tools such as SPAC E IN VA D ER, \nSLAYE R, TH O R and IN FE R. Reynolds wanted to pursue proofs of full functional correctness, beyond \nthe reach of mere program analysis, leading to many good-natured arguments and discussions. In arguing \nhis position, John seemed to be eerily skilled at pinpointing the limi\u00adtations of the techniques in these \ntools, even though he could see and appreciate the excitement. It turns out that the people work\u00ading \non these tools were not aware that Automatic Computation of Data Set De.nitions could be regarded as \nan early shape analysis.  You can .nd yourself at a disadvantage when your opponent just happens to \nbe the source of the founding works underpinning the position you are defending! This story is typical. \nAgain and again during his career Reynolds was seen to be years ahead of the .eld, and it became a kind \nof joke amongst friends that John had gotten there 10 years or more before everyone else. Once, when \nhearing a talk on types, Reynolds com\u00adplimented the speaker on one of the ideas he explained, and the \nspeaker said that the idea was taken from a Reynolds paper. At this point a round of jokes began on the \ntheme of Reynolds being 10 years ahead of himself; John joined in, teasing himself gleefully. The next \nimportant paper was in the direction of John s other early interest, theorem proving. Transformational \nsystems and the algebraic structure of atomic formulas. Machine Intelligence 5, pages 135151. 1969. \nThis paper developed an anti-uni.cation algorithm, which solves the dual problem to uni.cation: it seeks \nthe most speci.c common generalization of two terms. This is a fundamental idea that forms part of the \nbasis of the .eld of inductive logic programming. These two papers, which are probably not so well known \nin the PL community, would already have given a very respectable career. But it was now that John entered \na kind of golden of period, an extended run of high productivity and extreme quality. Golden Period. \n1970-1984. There are so many top-.ight papers here that we simply list them with brief comments, a kind \nof annotated bibliography. GEDANKEN -a simple typeless language based on the principle of completeness \nand the reference concept. CACM 13(5): 308-319 (1970) This was an untyped call-by-value programming language \nwhose way of mixing imperative features and functions is sim\u00adilar to the core of ML. This paper won the \n1971 ACM Annual Programming Systems and Languages Paper Award, 1971 De.nitional Interpreters for Higher-Order \nProgramming Languages, Proceedings, 25th National ACM Conference (Au\u00adgust 1972), pp. 717-740. Reprinted \nin Higher-Order and Sym\u00adbolic Computation, 11 (1998), pp. 363-397. This paper showed how to transform \na series of interpreters, eventually ending up with a compiler. This work helped to pop\u00adularize continuations \nas a tool in language implementation, and introduced the concept of defunctionalization where functions \nin the interpreter are replaced by their representations (such as closures) in more concrete data structures. \nOn the Relation between Direct and Continuation Seman\u00ad tics. ICALP 1974 : 141-156 At the time the power \nof continuations was becoming apparent, and John asked the simple question of whether continuation and \ndirect semantics can be connected by a precise theorem. The question was non-trivial because, as the \nabstract states, The heart of the problem is the construction of a relation which must be a .xed-point \nof a non-monotonic relational functor . The paper introduced a general technique for constructing relations \nbetween recursively-de.ned domains. Towards a theory of type structure. Symposium on Program\u00ad ming 1974: \n408-423 Introduced the Polymorphic .-calculus, the .rst type theory of polymorphic functions. Reynolds \ns work on Poly. as well as his later work on parametricity in.uenced the designs of gener\u00adics in Java \nand in .Net (Phil Wadler and Andrew Kennedy, personal communication). The polymorphic lambda calculus \nis beautiful as well as powerful. It consists of just .ve constructs, yet it can de.ne many of the data \nstructures of central impor\u00adtance in programming. Like many timeless scienti.c discover\u00adies, this calculus \nwas invented twice, in this case by Reynolds and by the logician Jean-Yves Girard (who called it System \nF). In this paper John attempted, not for the last time, to make a model of the polymorphic calculus. \nThis was dif.cult because of the impredicative (circular) nature of the calculus, which made it seem \nto be skirting Russell s paradox. He almost got there, but stated: we must admit a serious lacuna in \nour chain of argument . Later, John said (jokingly) that the lacuna admis\u00adsion was one of the most fortunate \nphrases he had ever included in a paper. User-De.ned Types and Procedural Data Structures as Complementary \nApproaches to Data Abstraction, New Di\u00adrections in Algorithmic Languages 1975 This paper was ahead of \nits time in pinpointing the essential dif\u00adference between object-oriented approaches to data abstraction \nand abstract data types... a topic often revisited decades later. Essentially, procedural approaches \nare easy to extend because their data representations are decentralized, ADT s provide for binary and \nmulti-nary operations because they are centralized, and the strengths of one are the limitations of the \nother.  Syntactic Control of Interference. POPL 1978: 39-46 A strikingly original paper on using what \nis now called an af.ne .-calculus to control aliasing and other forms of interference between program \nparts. Possibly the .rst use of substructural type theory to control resources, 9 years before the appearance \nof linear logic.  Programming with Transition Diagrams. Programming Method\u00adology, A Collection of Papers \nby Members of IFIP WG 2.3, ed.  D. Gries, Springer-Verlag, 1978, pp. 153 165. In this paper, Reynolds \ngoes against the grain, demonstrating how well-designed programs with goto statements can be easy to \nprove correct. Reasoning about Arrays, CACM 22(5): 290 299 (1979) An early application of separation \nprinciples for reasoning about arrays using a notation called partition diagrams that Reynolds invented \nfor this purpose. The material is also cov\u00adered in Chapter 2 of Craft of Programming. A technique that \nReynolds often used for motivating this material was to ask stu\u00addents to write a binary search program \nand let them discover for themselves how it is hard it is to get it right. With Reynolds s technique, \nit is almost impossible to get it wrong. Using category theory to design implicit conversions and generic \noperators, Semantics-Directed Compiler Generation 1980: 211-258 A generalization of many-sorted algebras, \ncategory-sorted al\u00adgebras, is de.ned and used to account for generic operators ap\u00adplied to different \ntypes in the presence of implicit conversions between types, ensuring that the order of applying the \nconver\u00adsions does not affect the .nal result. The Essence of Algol, Algorithmic Languages, ed. J. W. \nde Bakker and J. C. van Vliet, North-Holland, 1981, pp. 345-372. In this highly in.uential and oft cited \npaper, Reynolds con\u00adtended that Algol should be considered as an applied call-by\u00adname .-calculus, and \ndescribed Idealized Algol to illustrate a number of principles of language design that he proposed as \nconstituting Algol s essence. This paper made signi.cant tech\u00adnical inventions that go far beyond Idealized \nAlgol. Explained how types encapsulate effects naturally in the call-by-name design, and consequently \nfull \u00df. laws are valid. This idea was echoed in the use of types to control effects in Haskell, which \nused similar principles to insulate functions from effects and went beyond Algol s monoid of  commands \nto monads (a sort of parameterized commands). Possible world (functor category) semantics of local state, \nwhich is still in.uencing technical developments at the edge of programming language theory, as in recent \nPOPL papers of Ahmed, Dreyer, Birkedal and others on reasoning about local state with Kripke relations. \nTyped .-calculus with subtypes, which has been used sig\u00adni.cantly in the foundations of object-oriented \nlanguages and elsewhere. Typically, John did not make a big deal about any of these spe\u00adci.c contributions, \nor single out any one for special attention; it was as if they were mere intellectual tools used in crafting \nhis larger points about language design. But what tools! One won\u00adders in retrospect how he managed to \ncram so many signi.cant and original ideas into a single paper. The Craft of Programming. Prentice Hall \nInternational se\u00adries in computer science, Prentice Hall 1981, ISBN 978-0-13\u00ad188862-3, pp. I-XIII, 1-434 \nand Idealized Algol and its Speci.cation Logic, Tools and Notions for Program Construction, ed. D. Neel, \nCambridge University Press (1982), pp. 121-161. In this book and paper Reynolds s ideas about program \nproving are developing. There is a signi.cant focus on abstraction and re.nement in craft , and on controlling \ninterference as an aid to modular reasoning. Types, Abstraction and Parametric Polymorphism. IFIP Congress \n1983: 513-523 Perhaps the only computer science paper in which the phrase moral turpitude features, in \na not-to-be-missed fable involving Bessel and Descartes. Arguably the best article ever written on the \npoint and purpose of types, exploring the idea that types enforce abstraction. Written as a counterpoint \nto the prevailing attitude at the time, in which types (only) classify values and rule out errors; while \nthe conventional view emphasized one laudable aspect, Reynolds was convinced that there was more to types \nand makes a compelling case. Technically, the paper is notable for formalizing the Abstraction Theorem \nand for introducing Relational Parametricity. Polymorphism is not Set-Theoretic. Semantics of Data Types \n1984: 145-156 Reynolds had been convinced that the polymorphic .-calculus should have a set-theoretic \nmodel, because types are not lim\u00adited to computation , and he set out to .nd a set-theoretic model. Instead, \nhe ended up showing that there actually is no non-trivial model of the polymorphic .-calculus in which \ntypes denote sets and where the function type denotes the collection of all set-theoretic functions from \none type to another. Interest\u00adingly, this was done assuming classical set theory, and obser\u00advations of \nHyland, Moggi, Pitts and others later demonstrated the possibility of set-theoretic models assuming intuitionistic \nset theory. Nowadays there are many models of the polymor\u00adphic calculus. Although he did not question \nthe truth of his result, John was never satis.ed with the models of polymorphism that have been obtained, \nand upon questioning he would become .dgety: it was as if he felt there was something missing in his \nown insight (if not that of others). 1985-2000. In this period John continued producing high-quality \nwork, but not at quite the same pace as in the golden period. Some of the key works are the following. \n Syntactic Control of Interference, Part 2, ICALP 89  On Functors Expressible in the Polymorphic Typed \nLambda Calculus. Inf. Comput. 105(1): 1-29, 1993 (with Plotkin)  Using Functor Categories to Generate \nIntermediate Code. POPL 1995: 25-36  Theories of programming languages. Cambridge University Press 1998, \nISBN 978-0-521-59414-1, pp. I-XII, 1-500  From Algol to polymorphic linear lambda-calculus. J. ACM 47(1): \n167-223, 2000. (with O Hearn)  The JACM 00 paper connected up his interests on Algol and on polymorphism; \nmore on that in the next section. The POPL 95 paper is remarkable for connecting category the\u00adory to \ncompilation. John used category theory, and semantics in general, as a tool for guiding design (of a \nlanguage or a compiler), and not just for after-the-fact study. This attitude is summed up neatly in \nhis remark: Programming language semanticists should be the obste\u00ad tricians of programming languages, \nnot their coroners. John C. Reynolds Separation Logic. In 1999, at age 64, John produced one of his most \nstunning papers. Intuitionistic Reasoning about Shared Mutable Data Struc\u00adture, Millennial Perspectives \nin Computer Science: Proceed\u00adings of the 1999 Oxford-Microsoft Symposium in Honour of Sir Tony Hoare, \nPalgrave, 2000. This paper came like a bolt from the blue. In it, John showed proofs of heap-mutating \nprograms that were almost as simple as those for purely-functional programs. The key insight was how \nlinked data structures could be described using inductive de.nitions and a connective which we now call \nthe separating conjunction. One could fold and unfold the de.nitions, and work in isolation on components \nof the separating conjunction. John s paper built on an early work of Burstall (Some tech\u00adniques for \nproving programs which alter data structures. Machine Intelligence, 1972). Reynolds extended it by using \na form of sub\u00adstructural logic, which turned out to be an instance of the Bunched Logic of O Hearn and \nPym. After a POPL 01 paper by O Hearn and Ishtiaq detailing this connection, there was one further paper. \nLocal Reasoning about Programs that Alter Data Struc\u00adtures. CSL 2001: 1-19 (with O Hearn and Yang) This \npaper described the canonical semantics and proof theory of Separation Logic as it is now understood. \nIt used a boolean rather than an intuitionistic form of logic and it worked for a low-level programming \nlanguage closer to assembly, whereas the 1999 paper was formulated for a language without memory deallocation \nor address arithmetic. Although Reynolds was a proponent of in.uential ideas, he never regarded the positions \nhe adopted as cast in stone. Indeed, it might seem strange that John Reynolds, one of the leading pro\u00adponents \nof safe programming languages, would advance a logic for an unsafe language in his work. Here was the \ninventor of GEDANKEN, Idealized Algol, and the Polymorphic .-calculus, working with a language with dirty \nfeatures. But, armed with pro\u00adgram logic, safety could be achieved. Reynolds proved a number of low-level \nprograms to test his ideas, such as for a form of doubly\u00adlinked lists which save space by storing the \nxor of forward and back pointers rather than each separately, and the inductive de.nition in Separation \nLogic and the proof came out surprisingly easily. Next, John wrote an in.uential survey article covering \nthese papers and others on Separation Logic up to 2002.  Separation Logic: A Logic for Shared Mutable \nData Struc\u00adtures. LICS 2002: 55-74 This paper was associated with an invited talk by John at the LICS \n02 conference. At the end of his talk John started to try to sum up where we had got to and then stopped, \nlooked at the audience, and simply said: a growing number of people are working on this formalism and... \nwell... we think we re on to something . John Reynolds was humble and not prone to overstatement, and \ncoming from him this was a strong statement. The next section will provide more context for this work \non Separation Logic. Later Papers. After the founding of Separation Logic, John pro\u00adduced several further \npapers. Separation and information hiding. POPL 2004: 268-280 (with O Hearn and Yang)  Local reasoning \nabout a copying garbage collector. POPL 2004: 220-231 (with Birkedal and Torp-Smith)  Towards a Grainless \nSemantics for Shared Variable Con\u00adcurrency, FSTTCS 2004: Foundations of Software Technol\u00adogy and Theoretical \nComputer Science, LNCS 3328, pp. 35-48, 2004  Syntactic Control of interference for Separation Logic. \nPOPL 2012: 323-336 (with Reddy)  The paper on grainless semantics picks up an old bugbear of his, in.uenced \nby Dijkstra s idea that the understanding of concurrent programs should not be dependent on a particular \ngrain to time . His .nal paper, with Reddy, .ttingly brings together two of his major contributions. \n3. State and abstraction The issues of state and abstraction were central themes in Reynolds s research, \nespecially during the time of his golden period. State is of the kind represented in imperative Algol-like \nlanguages, with Algol W being his favorite. This preference was because the effects are concentrated \nin the base types of expressions and commands, and the function types remain pure, subject to full \u00df. \nequivalence. Thus, Algol-like meant an integration of imper\u00adative and functional aspects, preserving \nboth of their fundamen\u00adtal properties without any corruption. Abstraction is represented in strong type \nsystems, semantically based, as well as in how the store is viewed in Algol-like languages. Reynolds \nsaw intimate connec\u00adtions between these two views of abstraction and sought to build bridges so that \nthe ideas could be carried back and forth between them. In addition to the abstraction inherent in the \nstore, Reynolds also wanted additional modularity in the management of store, go\u00ading beyond what is representable \nin conventional language designs. This desire led him to new proposals for type systems, logics and semantic \nframeworks, as represented in syntactic control of inter\u00adference, Separation Logic and grainless semantics. \nReynolds s golden period coincides with his teaching of a grad\u00aduate course on programming at Syracuse. \nThe material he devel\u00adoped for this course is published as The Craft of Programming (1981). It contains \na wealth of information about what imperative programming means,  how to develop imperative programs \nrigorously,  the type structure of imperative programs,  reasoning principles (both practical, e.g., \narrays, and abstract, e.g., Speci.cation Logic), and  how to reason about data abstraction (or information \nhiding).  His analysis of this material gave rise to a series of insightful pa\u00adpers, the most prominent \nof which are The Essence of Algol (1981), and Idealized Algol and its Speci.cation Logic (1982). However, \nthe most novel material of the book, the chapter on Data represen\u00adtation structuring, is not directly \nrepresented in these papers. So, one must go to the source to understand these ideas. However, we believe \nthat these insights in.uenced Reynolds s papers on types: A theory of type structure (1974) and Types, \nabstraction and para\u00admetric polymorphism (1983). These are the bridges we speak of. Reynolds always thought \nof the store in imperative programs as an abstract type, whose full information is hidden from the program. \nSoon after de.ning the polymorphic lambda calculus in 1974, he worked on a project titled A polymorphic \nmodel of Algol. We have a copy of his handwritten notes, dated 9 23 75, which contain these key equations \n~ Bsta[S] = S . S Bw1.w2 [S] = .S'. Bw1 [S \u00d7 S'] . Bw2 [S \u00d7 S'] We see here that Reynolds thinks of the \n(Idealized) Algol types for statements (sta) and procedures (w1 . w2) as type constructors Bsta and Bw1.w2 \n. These type constructors are parametrized by a type variable S representing the set of states for a \nstore. This is in marked contrast to Strachey s denotational semantics where the store is .xed and global. \nHere the store is a type variable. In essence, this means that the program can work with whatever type \nof store we supply, as long as it has all the required data variables. An intuitive interpretation of \nparametric polymorphism immediately implies that the program will act the same way for all these different \ntypes of stores. This model of Algol could not be .nished in 1975 because it did not satisfy the \u00df equivalence \nof Algol. In 1981, Reynolds moved from type constructors to functors in the Essence of Al\u00adgol model, \nwhich depend on the postulation of morphisms between store types. We suspect that he was never fully \nsatis.ed with func\u00adtors. In 2000, he returned to the original equations in the joint paper with O Hearn, \nFrom Algol to polymorphic linear lambda calculus, where these equations appear again, adapted to the \nlinear context. So, what happened to the problem with \u00df equivalence? It is still open! Linearity rules \nout the obvious counterexamples and enough evidence is gathered to show that the model is worthy even \nif it does not satisfy \u00df equivalence. This is one direction of the bridge. We expect that the other direction \nwas implicit in Reynolds s thinking. The chapter on Data representation structuring contains programming \nexamples where graph algorithms are treated (including Tarjan s algorithm for strong components, posed \nas a challenge problem by Knuth for program correctness) using data re.nement. An initial algo\u00adrithm \nexpressed in terms of sets of nodes and edges is gradually re.ned to an algorithm involving concrete \ndata objects within Al\u00adgol W. The relationship between the two sets of data structures is captured using \na technique that Reynolds invents for this purpose: general invariants, which are true throughout a particular \nregion of the program (as opposed to Floyd-Hoare invariants that are true at particular points in the \nprogram). Transporting these ideas back across the bridge, we notice that the programs are operating \non two independent state spaces SA and SC , and the general invariants are relations R . SA \u00d7 SC that \nare maintained by the two slices of the program without any observable difference. Here, we see the principles \nof relational parametricity taking shape, not in an abstract theoretical setting, but in concrete programming \nexamples involving data abstraction. The essence of relational parametricity is that, if a program term \nis parametrized by a type variable (or an opaque type), then the in\u00adformation about the type is hidden \nfrom the term, and the term be\u00adhaves the same way for all possible instantiations of the type vari\u00adable. \nHence, if we consider two instantiations A and A ' of the type variable and allow ourselves the freedom \nto substitute particular el\u00adements x . A by elements x ' . A ' then the results produced by the program \nterm should be the same, modulo the substitution we have made. What kind of substitutions can one make? \nIn early years of modern mathematics, isomorphisms, i.e., structure-preserving one\u00adto-one correspondences, \nwere allowed. After the advent of category theory, homomorphisms, i.e., many-to-one correspondences, \nwere allowed. But, if A and A ' are two arbitrary instantiations, there is no intuitive reason why the \nallowed correspondences should be asymmetric. Hence, logical relations, i.e., structure-preserving many-to-many \ncorrespondences, are the only intuitively appealing answer to the question for programming applications. \nThey form the basis of relational parametricity. In a good theory of para\u00admetricity, both isomorphism \nparametricity and homomorphism parametricity (natural transformations) become special cases of relational \nparametricity.  While we mentioned program terms above for the sake of ex\u00adplanation, these ideas are \nby no means limited to programs. Any mathematical formula, any algorithmic process or any mechanism in \nwhich output quantities are causally derived from input quanti\u00adties, whether discrete or continuous, \ncan have the notion of being parametrized by types and, if so, we might expect it to be paramet\u00adric. \nBob Atkey makes a beginning with this line of enquiry in the present POPL. He shows that the symmetries \nof physical system as required for the Noether s theorem in classical mechanics can be viewed as instances \nof parametricity. This should pave the way for broader applications of the relational parametricity principle \nin mathematics and science. With the formulation of relational parametricity, the bridge is completed. \nThe reasoning principles of Data representation struc\u00adturing are translated into the parametricity principles \nof the poly\u00admorphic lambda calculus, via the translation of the 1975 notes (or the 2000 paper employing \npolymorphic linear lambda calculus). Imperative programs are complicated for a variety of reasons and \nthose complications do not go away just by de.ning seman\u00adtics. Reynolds repeatedly sought to create intellectual \ntools to con\u00adtrol and master the complications. A key idea was that the state should not be treated as \na monolithic entity; rather it should be par\u00adtitioned into separate portions and distributed to different \nparts of the program to operate on independently. In Syntactic Control of Interference (1978), he proposed \na system of rules that allows pro\u00adgram terms to be viewed as owning portions of the store, based on their \nfree identi.ers, and only terms that own separate portions can be combined using the procedure mechanism. \nThis is roughly the meaning of saying that a procedure and its argument should not interfere. Speci.cation \nlogic (1982) involves subtler notions of non-interference, which were investigated in a novel semantics \nof Tennent (Semantical Analysis of Speci.cation Logic, Inform. Com\u00adput. 1985) and in O Hearn s 1991 Ph.D. \nthesis. In Reasoning about Arrays (1979), Reynolds applied the separation principle to arrays, inventing \na powerful notation called partition diagrams to docu\u00adment such separation. All of this was perhaps only \nsetting the stage for the powerful Separation Logic for dynamic data structures to come in 1999\u00ad2001 \nwhich came as a surprising tour de force even to those of us that had thought about the problem and knew \nall the technical tools that Reynolds, O Hearn and others deployed in solving it. Separation Logic represents \na giant intellectual leap in recognizing that ownership (what can be accessed) and separation (divisions \nof the state) are not static, spanning all states, but can vary from state to state. In his 2000 paper \nIntuitionistic Reasoning about Shared Muta\u00adble Data Structure, Reynolds introduced the separating conjunc\u00adtion, \nwhich allows the pre-conditions of operations to break the state into components. Reynolds demonstrated \nthat this allowed for simple proofs of heap-mutating programs and, more deeply enabled a new spatial \ndimension to modular reasoning which complements that of abstraction. In a sense, the pre-conditions \nnot only specify what is true in a state but also describe the structure of the store (mainly the heap). \nThis idea has far-reaching consequences, and it is extremely fortunate that Reynolds made this step forward \nat the time he did, because he opened the .ood gates for new ideas. The foremost of the new ideas was \nthe resolution of the frame problem by O Hearn. In Local reasoning about programs that al\u00adter data structures \n(2001, by Reynolds jointly with O Hearn and Yang), pre-conditions specify not merely what portion of \nthe store can be used from a program point, but only that portion of the store that will be so used. \nThis has the remarkable consequence that spec\u00adi.cations need to talk about only the portion of the store \nactually manipulated by program fragments, referred to as their footprint . A general rule called the \nframe rule allows such local speci.cations to be extended to larger contexts as needed; and, using the \nseparat\u00ading conjunction, this passage from smaller to larger contexts can be described extremely directly \nand compactly. Separation Logic, as represented in the Local Reasoning paper and .nally in Reynolds s \nLICS 02 paper, can be seen as the culmi\u00adnation of his theme of making the structure of the store explicit \nin programming language theories (be they semantics or logics). In the end, Separation Logic derives \nmuch of its power from the in\u00adterplay between dynamic separation and framing. And, the passage from local \nspeci.cations to larger contexts by framing can be seen as a logical analogue of Reynolds s idea of expanding \na store shape in his work on possible world semantics, going back as far as the 1975 notes mentioned \nabove, but with the separating conjunction providing a more .exible form of extension. Today, Separation \nLogic is a thriving research direction with a tremendous investment in building automated tools and solving \na variety of reasoning problems that have been perceived as too dif.cult or impossible for a long time. \nIt represents a major force for taming the looming problem of concurrent software to be run on multi-core \nprocessors. 4. Conclusion John Reynolds was one of the greatest minds programming re\u00adsearch has seen. \nWhat was his secret? What was the essence of Reynolds? Certainly, he had great talent, and he also had \ngreat determina\u00adtion. But his way of working and interacting with others, conveying what was important \nto him, was special and inspiring to those who knew him. John Reynolds was as pure a scientist as you \nwould ever meet, and this is what made him tick. It was not academic politics, or funding, or fame, it \nwas just the ideas. It was not uncommon for John to talk to someone about their own ideas for hours at \na time. Not only 20 minutes, or one hour, but three, four or .ve hours. This was especially true for \nstudents and junior faculty, but also held for more senior people as well. He would set everything else \naside, his own time included, in his desire to get to the heart of the matter. These were intense sessions \nof deep concentration and back-and-forth discussion, and while John would argue vigorously and ask probing \nquestions he always managed to be patient and pleasant with whoever he was talking to. It was as if programming \nand programming languages held wonderful treasures waiting to be uncovered, and he wanted to see them. \nJohn Reynolds just wanted to understand. And he came to understand a lot. In the course of his career \nhe discovered numerous deep ideas of lasting value anti-uni.cation, defunctionalization, theory of subtypes, \npossible world semantics of state, polymorphic .-calculus, relational parametricity, Separa\u00adtion Logic, \nand others and we are much the richer for it.  \n\t\t\t", "proc_id": "2535838", "abstract": "<p>John Reynolds (1935-2013) was a pioneer of programming languages research. In this paper we pay tribute to the man, his ideas, and his influence.</p>", "authors": [{"name": "Stephen Brookes", "author_profile_id": "81100532140", "affiliation": "Carnegie Mellon University, Pittsburgh, PA, USA", "person_id": "P4383811", "email_address": "brookes@cs.cmu.edu", "orcid_id": ""}, {"name": "Peter W. O'Hearn", "author_profile_id": "86159055857", "affiliation": "Facebook, London, United Kingdom", "person_id": "P4383812", "email_address": "peterohearn0@gmail.com", "orcid_id": ""}, {"name": "Uday Reddy", "author_profile_id": "81100154268", "affiliation": "University of Birmingham, Birmingham, United Kingdom", "person_id": "P4383813", "email_address": "u.s.reddy@cs.bham.ac.uk", "orcid_id": ""}], "doi_number": "10.1145/2535838.2537851", "year": "2014", "article_id": "2537851", "conference": "POPL", "title": "The essence of Reynolds", "url": "http://dl.acm.org/citation.cfm?id=2537851"}