{"article_publication_date": "01-08-2014", "fulltext": "\n A Trusted Mechanised JavaScript Speci.cation Martin Bodin Arthur Chargu\u00e9raud Daniele Filaretti Inria \n&#38; ENS Lyon Inria &#38; LRI, Universit\u00e9 Paris Sud, CNRS Imperial College London martin.bodin@inria.fr \narthur.chargueraud@inria.fr d..laretti11@imperial.ac.uk Philippa Gardner Sergio Maffeis Daiva Naud i \n\u00afunien.e Imperial College London Imperial College London Imperial College London philippa.gardner@imperial.ac.uk \nsergio.ma.eis@imperial.ac.uk d.naudziuniene11@imperial.ac.uk Alan Schmitt Gareth Smith Inria Imperial \nCollege London alan.schmitt@inria.fr gareth.smith05@imperial.ac.uk Abstract JavaScript is the most widely \nused web language for client-side ap\u00adplications. Whilst the development of JavaScript was initially just \nled by implementation, there is now increasing momentum behind the ECMA standardisation process. The \ntime is ripe for a formal, mechanised speci.cation of JavaScript, to clarify ambiguities in the ECMA \nstandards, to serve as a trusted reference for high-level lan\u00adguage compilation and JavaScript implementations, \nand to provide a platform for high-assurance proofs of language properties. We present JSCert, a formalisation \nof the current ECMA stan\u00addard in the Coq proof assistant, and JSRef, a reference interpreter for JavaScript \nextracted from Coq to OCaml. We give a Coq proof that JSRef is correct with respect to JSCert and assess \nJSRef using test262, the ECMA conformance test suite. Our methodology en\u00adsures that JSCert is a comparatively \naccurate formulation of the En\u00adglish standard, which will only improve as time goes on. We have demonstrated \nthat modern techniques of mechanised speci.cation can handle the complexity of JavaScript. Categories \nand Subject Descriptors D.3.1 [Programming Lan\u00adguages]: Formal De.nitions and Theory Keywords JavaScript, \nmechanised semantics, Coq 1. Introduction JavaScript is by far the most widely used web language for \nclient\u00adside applications. Initially, JavaScript development was entirely led by implementation, with \nNetscape releasing the .rst JavaScript im\u00adplementation in 1996 and Microsoft responding with their own \nver\u00adsion in the same year. Netscape quickly realised that standardi- Permission to make digital or hard \ncopies of all or part of this work for personal or classroom use is granted without fee provided that \ncopies are not made or distributed for pro.t or commercial advantage and that copies bear this notice \nand the full citation on the .rst page. Copyrights for components of this work owned by others than the \nauthor(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or republish, to \npost on servers or to redistribute to lists, requires prior speci.c permission and/or a fee. Request \npermissions from permissions@acm.org. POPL 14, January 22 24, 2014, San Diego, CA, USA. Copyright is \nheld by the owner/author(s). Publication rights licensed to ACM. ACM 978-1-4503-2544-8/14/01. . . $15.00. \nhttp://dx.doi.org/10.1145/2535838.2535876 sation was crucial. Client code that works on some of the \nmain browsers, and not others, is not useful. The .rst of.cial standard appeared in 1997. Now we have \nECMAScript 3 (ES3, 1999) and ECMAScript 5 (ES5, 2009), supported by all browsers. There is increasing \nmomentum behind the ECMA standardisation process, with plans for ES6 and 7 well under way. JavaScript \nis the only language supported natively by all major web browsers. Programs written for the browser are \neither writ\u00adten directly in JavaScript, or in other languages which compile to JavaScript. This fundamental \nrole seems unlikely to change. How\u00adever, JavaScript is very complex. The ECMAScript standards, by necessity, \nare large and full of corner cases. Despite the best ef\u00adforts of their editors, these documents are sometimes \nunclear and, in some isolated cases, even inconsistent. We believe the time is ripe for a formal, mechanised \nspeci.cation of JavaScript, to clar\u00adify ambiguities in the ECMA standards, to serve as a trusted ref\u00aderence \nfor high-level language compilation and JavaScript imple\u00admentations, and to provide a platform for high-assurance \nproofs of language properties. We introduce JSCert, a mechanised speci.cation of ES5 written in the interactive \nproof assistant Coq. We also introduce JSRef, an executable reference interpreter extracted from Coq \nto OCaml. We give a Coq proof that JSRef is correct with respect to JSCert. The correctness proof ensures \nthat we can have full con.dence that a JSRef program has the behaviour speci.ed by JSCert. All our Coq \ncode is available at http://www.jscert.org. We believe that both JSCert and JSRef are necessary: JSCert, \nunlike JSRef, is well-suited for developing inductive proofs about the semantics of JavaScript; JSRef, \nunlike JSCert, can be used to run JavaScript programs. Our challenge is to convince ourselves and others \nthat JSCert is indeed an accurate formulation of the ES5 English speci.cation. We designed JSCert to \nfollow the structure of the ES5 English stan\u00addard as much as possible. Whenever we found parts of ES5 \nEn\u00adglish prose to be ambiguous, we checked the browser implementa\u00adtions and were active on discussion \ngroups such as es-discuss. We also ran JSRef on the of.cial ECMA test suite, test262. Since JSRef is \ncorrect with respect to JSCert, failed tests meant discrep\u00adancies between ES5, JSCert, and the tests. \nUsing this methodol\u00adogy, we were able to correct several bugs in JSCert and JSRef. We also discovered, \nand reported [58, 60], a number of bugs in all the browser implementations, the ECMA standards, and test262. \nWe have demonstrated that modern techniques of mechanised speci.\u00adcation can handle the complexity of \nJavaScript.  JSCert. We introduce JSCert, a mechanised Coq speci.cation of ES5. In 2008, Maffeis, with \nMitchell and Taly from Stanford, de\u00adveloped a hand-written, small-step operational semantics for for\u00admally \ndescribing the full behaviour of JavaScript [36, 37], faithfully following ES3 except when the English \nstandard was incorrect or ambiguous. Apart from moving to ES5, we also differ from [36] in that we use \na big-step semantics to be closer to the style of the English prose. However, the traditional big-step \napproach would lead to many duplicated rules, since the JavaScript control .ow is quite complex. We use \na pretty-big-step semantics, an approach re\u00adcently developed by Chargu\u00e9raudfor a simple ML dialect [11]. \nOur work here demonstrates that the technique scales to a real-world standard, and yields a close connection \nbetween ES5 and JSCert. Note that we are not trying to usurp ES5, which has an ease of readability that \nwould be dif.cult to match with a mechanised speci.cation. We are aiming for an accurate, mechanised \nspeci.\u00adcation of ES5 which can be used for clari.cation when the ES5 prose is unclear. By gathering a \nteam of Coq and JavaScript ex\u00adperts, we have been able to handle the size and the complexity of the JavaScript \nsemantics. As with most large speci.cation projects, a signi.cant ques\u00adtion is when to stop. We have \nformally speci.ed the core language, where we believe most of the interest for our project lies. We have \nnot speci.ed the for-in command, because in trying to do so we discovered that ES5 and ES6 are broken \nin this respect.1 We have not speci.ed the parsing of JavaScript source code, which would be a challenging, \northogonal task. Also, our formalisation of native libraries is partial. We have formalised nearly all \nof the library functions that expose internal features of JavaScript, with the exception of functions \ninvolving arrays which is future work. In particular, we have formalised most of the functions from li\u00adbraries \nObject, Function, Boolean, Number, and Errors. We are not planning to formalise the other native libraries. \nThey con\u00adtain hundreds of library functions that do not interact with internal JavaScript features, in \nthe sense that they could be implemented as plain JavaScript code. JSRef. We introduce JSRef, an executable \nreference interpreter, which we have proved correct with respect to JSCert and tested using the ECMAScript \nconformance test suite, test262. By design, JSCert is not directly executable. It is presented as an \ninductive de.nition, essential for developing safety proofs, and it matches the looseness of ES5 s implementation-dependent \nfeatures. We therefore developed a computable Coq speci.cation and, from this, automatically extracted \nthe corresponding OCaml code, obtaining the executable reference interpreter JSRef. Our computable Coq \nspeci.cation follows the ES5 pseudo-code as much as possible. Where the implementation details were left \nunspeci.ed, we made arbitrary but natural choices. In fact, we developed JSCert and JSRef in parallel. \nThis ap\u00adproach was invaluable when understanding an unclear part of ES5: we sometimes needed the speci.er \ns broad intuition; sometimes the implementer s pragmatic intuition about what was really meant. Recall \nthat JSCert speci.es the core language of ES5, but does not specify the parser nor many of the native \nlibraries. The same re\u00adstrictions apply for JSRef. In particular, we rely on an off-the-shelf JavaScript \nparser, taken from the Google Closure Compiler [25], for parsing the initial source code and for implementing \neval. 1 We have .led a bug report (n. 1444 of [58]) for ES6. Trust. Our methodology for obtaining trust \nin our mechanised semantics can be summarised as follows: eyeball correctness running tests For JSCert, \ntrust arises from the eyeball closeness of JSCert to ES5. We can place the English prose and the formal \nrules side\u00adby-side, and compare the two: one line of ES5 pseudo-code corre\u00adsponds to one or two rules \nin JSCert. If commands need changing, as inevitably they will for future standards, it is relatively \nstraight\u00adforward to see which part of JSCert needs changing. For JSRef, we have a machine-checked correctness \nproof that it satis.es JSCert. More precisely, we prove in Coq that, if the execution of a JavaScript \nprogram in JSRef returns a result, then there exists a reduction derivation in JSCert relating this program \nto this result. Because of the looseness of ES5, our interpreter cannot be proved complete. Nevertheless, \nwe believe that, on the deterministic subset of ES5, our interpreter is complete. We trust the extraction \nmechanism of Coq, used to obtain the OCaml code of JSRef, since it is standard and widely-used (e.g., \nin [8]). We also test JSRef using test262 [18]. JSRef successfully exe\u00ad cutes all the tests that we expect \nto pass given our coverage of JS-Ref. There are 2782 tests associated with the core language (chap\u00adters \n8 14): we pass 1796 tests; the others fail due to for-in, calls to libraries we have not speci.ed, or \nthe parser. We also use the OCaml bisect tool [14] to investigate the coverage of these tests. Our emphasis \non testing provides a different level of trust from that usually found in Coq development (see related \nwork), which is per\u00adhaps more accessible to JavaScript implementers and programmers. It also provides \na .rst step in the analysis of what it means to trust test262. As we were developing the proof of correctness \nand running the tests, we inevitably found bugs in JSCert and JSRef. It was necessary to go around the \nloop many times, .xing inaccuracies, continuing with the correctness proof and testing, and so on. Our \ncorrectness proof guarantees that JSRef is an accurate reference interpreter for JSCert (up to our trust \nof the Coq extraction process). However, despite our principled development of JSCert and JSRef, we cannot \nyet guarantee that JSCert is bug free in the sense that there may well be mismatches with ES5. A few \nmismatches will be due to the ambiguity of ES5. The ECMA authors have been very responsive to our queries \non es-discuss and it has always been possible to reach consensus. Other mismatches, however, will be \ndue to inaccuracies in JSCert. We do believe that, over time, with more proof reading and testing by \nourselves, and with help from others, we will be able to eliminate all the bugs. Applications. There \nare many potential applications of JSCert and JSRef. For example, we can investigate properties of fragments \nof JavaScript used for secure sandboxing by companies such as Yahoo!, Google, and Facebook. Several high-level \nlanguages are compiled to JavaScript. JSCert provides a formal target to verify the correctness of the \ncompilation. A natural .rst language to explore in this respect is Microsoft s F* compilation to JavaScript \n(and back for full abstraction, see related work). JavaScript implementers can compare their implementation \nwith JSRef. For example, a direct extension of our work would be to characterise the differences between \nFirefox and JSRef by running the Firefox test suite on JSRef. A dream is that our mechanised speci.cation \nmight even be used as part of the creation of future ECMA standards: ES6 is already taking shape, but \nES7 is only just being planned. This paper demonstrates that it is feasible to provide a Coq speci.cation \nof ES5 together with a reference interpreter passing the ES5 tests. We are impacting on ES6 with bug \nreports. It may not be beyond reach to provide a mechanised speci.cation for ES7 as part of the of.cial \nstandard.  2. Related work A real-world language speci.cation can come in many forms: an implementation \nof the compiler/VM as speci.cation (e.g., PHP); an English de.nition with varying degrees of rigour (e.g., \nthe C standard [10] and ES5 are fairly precise and complete); a formal mathematical speci.cation (e.g., \nStandard ML [41]); and mecha\u00ad nised speci.cation. Our work on JavaScript is part of the estab\u00adlished \ntradition to mechanise existing, real-world programming lan\u00adguage speci.cations. In this section, we \nsurvey related work on the large-scale mechanisations of programming languages in general, and on various \nformalisations of JavaScript in particular. 2.1 Large-scale mechanised speci.cations One of the most \nprominent, fully formalised presentations of a programming language is Standard ML by Milner, Tofte, \nHarper, and Macqueen [41]. A mechanised speci.cation was given by Lee, Crary, and Harper [34] in the \nTwelf theorem prover [48]. Unlike ML, many real-world languages are designed without formalism in mind. \nSuch languages provide a considerable challenge to mecha\u00adnisation. There has been a wide body of work \non mechanised language speci.cations in HOL. For example, Norrish [44] speci.es a small\u00ad step operational \nsemantics of C in HOL [43], and proves substantial meta-properties of the semantics. Norrish s formalism \nhas not been tested for conformance with implementations. Another example is Sewell et al. s work [7] \non formalising transmission control protocols (TCP) in Isabelle/HOL [43]. They created a post-hoc speci.cation \nof TCP from several prominent implementations, an enterprise not so far off the creation of the original \nECMA standard for JavaScript. Although not focusing on language speci.cation, their work is notable in \nthe context of our work as it validates the speci.cation against several thousand test traces captured \nfrom implementations, using a special-purpose symbolic model checker programmed above HOL. In the CompCert \nproject [15], Blazy and Leroy [8] built a ver\u00adi.ed optimising compiler for CLight, a signi.cant fragment \nof C, with a Coq proof that the generated compiled code behaves exactly as prescribed by the semantics \nof the source program. The Comp-Cert project initiated major technological breakthroughs in Coq mechanisation, \nsome of which we substantially use in this project. The aims of the projects are different. CLight was \nnot intended to capture precisely the C speci.cation. Also, CLight is not directly executable, although \nit would be possible to obtain an interpreter without too much additional effort, by leveraging the Coq \ncode ex\u00adtraction mechanism. Several substantial projects build on Comp-Cert: Appel s veri.ed software \ntool chain [3] combining program veri.cation with veri.ed compilation; Shao s project to certify an OS \nkernel; Zhao et al. s veri.ed LLVM which extracts an inter\u00adpreter from Coq code that is tested using \nthe LLVM regression suite (134 out of 145 runnable tests); and Sewell s CompCertTSO [61], verifying compilation \nthe x86 weak memory model [1]. The use of proof assistants such as HOL and Coq requires quite a substantial \nlearning curve. Researchers are beginning to explore how to make mechanised speci.cation easier. The \nK framework is designed speci.cally for writing and analysing language de.ni\u00adtions using a rewrite logic \n[19]. In particular, Ellison and Rosu [19] have de.ned an executable formal semantics of C in K [53]. \nTheir formalisation has been extensively tested against the GCC torture suite [22]. Besides being executable, \ntheir semantics also comes with an explicit-state model checker. Their aim is to de.ne an accu\u00adrate reference \ninterpreter, justi.ed by testing, rather than provide a full semantics of the C standard. Their work \nis analogous to JSRef. In addition, the Ott tool [55] provides a lightweight environment using ASCII \nnotation for writing de.nitions of programming lan\u00adguages and calculi, which automatically translate \nto HOL, Isabelle, and Coq. Owens et al. have developed a mechanised semantics of OCaml Light using Ott. \nFor space reasons, we cannot detail all the interesting exam\u00adples of mechanised speci.cations of programming \nlanguages. In\u00adevitably, there is a wide body of work on mechanised speci.cations of Java and C#: e.g., \nSyme s HOL semantics [56] of Drossopoulou and Eisenbach s formal Java semantics [17]; the executable \nformal\u00ad isation of the C# standard by B\u00f6rger et al. [9] using Abstract State Machines [29]; and the executable \nformal semantics of Java 1.4 in rewrite logic by Farzan et al. [20]. We should also mention the for\u00ad \nmal semantics of Batty et al. on C++ concurrency [4, 5], which is currently having real impact on the \nC11 standard [10]. The work is currently not mechanised but, considering the research group, it will \nsurely happen soon. Our mechanised speci.cation of ES5 shares many of the dif\u00ad.cult challenges faced \nby the work described above, and involves many new ones due to the complex dynamic nature of JavaScript. \nThey are detailed in \u00a7 4. We now provide a more detailed survey on formalising and mechanising the JavaScript \nsemantics.  2.2 Formal JavaScript speci.cations In 2005, Anderson et al. [2] and Thiemann [59] were \nthe .rst to propose formal type systems for subsets of JavaScript. To prove type-soundness, they formalised \nidealised cores of the language that abstracted away features not crucial for the type analysis at hand, \nfocusing instead on the challenges addressed by their analy\u00adses. Since then, researchers have studied \nvarious typed JavaScript subsets and static analyses, including [12, 13, 26, 27, 30, 32, 33, 45 47]. \nFor example, Jensen et al. [33] used abstract interpretation to develop a tool to infer abstract types \nfor the full language, al\u00adthough the formal theory only works for subsets. Others have stud\u00adied information \n.ow [13], with [30] proving their results in Coq. All these techniques have been helpful for addressing \nspeci.c safety problems. None provide general-purpose analyses, most do not work with the full language \nand, of those that prove soundness, all do so with respect to their abstract models rather than the ECMA \nsemantics or an actual concrete implementation. The security issues identi.ed in [35, 38, 39] demonstrate \nthat the semantic subtleties of corner cases of the language matter crucially. Moreover, the empirical \nanalysis by Richards et al. [52] con.rms that some of the language features, excluded by construction \nfrom the work mentioned so far, are in fact important for actual web programmers. In 2007, Herman and \nFlanagan [31] proposed a formalisation of the JavaScript semantics as a de.nitional interpreter written \nin ML. Their interpreter was the .rst executable formal semantics for a non-trivial subset of JavaScript. \nThe advantages of their approach were the ability to test their interpreter and the familiarity of their \nwork to functional programmers. The drawbacks were a loose correspondence with the speci.cation and implementation \ndetails that sometimes obscured the semantics of the language features. In 2008, Maffeis, Mitchell, and \nTaly [37] de.ned the .rst full operational semantics for the ES3 language. They covered the whole language, \napart from a few corner cases such as regular expressions, dates, and machine arithmetic. The formalisation \ncon\u00adsists of a large set of small-step operational semantics rules and some theorems about the determinacy \nand well-de.nedness of the language. This work has been useful to prove soundness of security-related \nJavaScript subsets [35, 38, 39], and in.uenced the de.nition of further JavaScript formalisations. For \nexample, the se\u00admantics of Secure ECMAScript underlying [57], and the big-step operational semantics \nof core JavaScript, proposed in [24] and used in [6], is based on this work. This formal semantics differentiates \nit\u00ad self from the work described above because its goals were to cover the entire language, without excluding \nuncomfortable features, to serve as a basis for formal proofs of real language properties. The main shortcomings \nof this work is that, since the rules are not mechanised, the proof of language properties is labour \nintensive, the maintenance and extension of the semantics is not easy, and a comparison with implementations \nis impossible.  In 2010, Guha et al. [28] came up with a completely differ\u00ad ent approach to developing \nlanguage semantics. They provide a translation from JavaScript to a Scheme-like, executable language, \ncalled .JS, which has as its core a simple .-calculus with refer\u00adences. Their aim was to develop provably \nsound type systems to reason about the safety of client-side web applications. They target the Firefox \nimplementation of ES3, and validate their semantics by testing it against the test262 and Mozilla test \nsuites [18, 42]. More recently, .JS has been extended to model the strict mode of ES5 [50], and an unpublished, \nsmall-scale Coq formalisation of .JS has been announced on the Brown PLT blog [51]. The work on .JS has \nbeen in.uential in proving properties of well-behaved JavaScript typed subsets, where the programmer \nac\u00adcepts restrictions on full JavaScript in exchange for safety guar\u00adantees. For example, Politz et al. \n[49] de.ne a type system for .JS that captures the informal restrictions enforced by Crockford s AD-Safe \n[16], a subset of JavaScript for sandboxing web advertising. Fournet et al. [21] de.ne a translation \nbetween F*, a subset of Mi\u00ad crosoft F# with re.nement types, and .JS. They show that their encoding is \nfully abstract, hence the safety properties enjoyed by a source F* program are preserved when it is translated \nto JavaScript and run on a trusted web page. The .JSwork has also been a signif\u00adicant source of inspiration \nfor our development of our executable semantics, JSRef, and our focus on testing. We have tested JSRef \nusing the test262 conformance tests, and in future will use the Fire\u00adfox test suite to compare JSRef \nwith the Firefox implementation. Our work is not the .rst to give a formal and/or executable se\u00admantics \nto JavaScript. However, JSCert is the .rst semantics for the entire language, closely re.ecting the of.cial \nstandard, which is both executable and formalised in a proof assistant. Working with the source language \nitself, and re.ecting the structure of the spec\u00adi.cation has several advantages over a translational \napproach: the JavaScript programmer intuition is better re.ected; the semantics is robust to local changes \nof the standard, such as those anticipated for ECMAScript 6 and 7; and the correctness of the semantics \ndoes not rely on possibly unknown assumptions associated with transla\u00adtion.2 Throughout this project, \nit has been important for us to estab\u00adlish trust in our mechanised semantics. As JSCert and JSRef are \nexplored by ourselves and other formalists, by people compiling to JavaScript, by JavaScript implementers, \nand maybe even by ECMA authors, so our trust will increase. If someone questions our inter\u00adpretation \nof ES5 or if a test fails, we know which part of JSCert to check and alter. Building on much of the work \ndetailed above, we believe we have developed a methodology for providing a trusted mechanised speci.cation \nof an English language standard. We do just wonder if this methodology has been fully demonstrated be\u00adfore. \n3. The JavaScript standard We give an overview of the semantics of JavaScript, as described in the ECMAScript \n5 standard and implemented in current browsers 2 In order to prove the correctness of such a translation, \none needs a formal semantics for the source language in the .rst place. In this sense, our work will \nmake it possible to prove the correctness of the encoding of JavaScript in .JS, increasing con.dence \nin the validity of .JS or F* safety properties on actual JavaScript programs. (\u00a7 3.1). We introduce our \nrunning example (\u00a7 3.2), and identify the parts of the standard that have not been included in our mechanised \nspeci.cation (\u00a7 3.3). 3.1 ECMAScript 5 ECMAScript 5 (ES5) is the current standard for JavaScript. Ex\u00adisting \nbrowsers largely implement ES5, but sometimes introduce custom extensions or make different choices in \nhow to implement certain cases that the speci.cation de.nes as implementation de\u00adpendent . In addition \nto the language, ES5 also describes a col\u00adlection of native libraries, which provide convenient functionality \n(e.g., handling of regular expressions, date formats) as well as a few extra language features (useful \nfor re.ection). In this paper, we focus on the language itself, only specifying the native libraries \nnecessary for the extra language features. The grammar of JavaScript is divided into three main cate\u00adgories: \nexpressions, statements, and programs. A JavaScript pro\u00adgram consists of a list of statements. The body \nof a function de.\u00adnition is a JavaScript program. Similarly, the argument of the no\u00adtorious eval statement, \nonce parsed, is a JavaScript program. The result of the evaluation of an expression, statement, or program \nis a completion triple. A completion triple is composed of a type, a value, and a label. The type is \none of Normal, Return, Break, Continue, or Throw, corresponding to the termination mode of the evaluation. \nThe value, which can be empty, describes the result of an expression or statement (if the type is Normal), \nthe value carried by a return statement (if the type is Return), or the object describ\u00ading the exception \nbeing thrown (if the type is Throw). The label, which can also be empty, is only used for Break and Continue \ntypes, in order to divert the execution .ow to the instruction anno\u00adtated with the target label. One \nof the reasons we were attracted to study ES5 is that it has not been de.ned with mechanised speci.cation \nin mind. The standard is not optimised for conciseness and reuse. It has a lot of copy/paste which increases \nthe workload of our formalisation. The standard uses representations that are practical for e.g., VM \nimple\u00admenters, but less helpful for reasoning. For example, completion triples have implicit invariants \nthat for our purposes would be better captured with an inductive de.nitions. Also, the standard becomes \nvery particular when describing browser-speci.c extensions, and is not explicit about whether under-speci.ed \nfunctions should have deterministic behaviours. Apart from this determinism issue, we have found ES5 \nto be precise and non-ambiguous, with two exceptions. First, the speci\u00ad.cation of data attributes, used \nto represent parameters of proper\u00adties (object .elds) such as writable and enumerable .ags, has two different \nrepresentations in different parts of the speci.cation. We give both representations in our speci.cation \nand prove that they are equivalent, so that we can follow ES5 as closely as possible. Second, the speci.cation \nof for-in suffers from major issues re\u00adlated to the loose speci.cation of the order of enumeration of \nthe property names [58].  3.2 Running example: the while statement There are many interesting features \nin the semantics of JavaScript. These include prototype-based inheritance, return value propaga\u00adtion \nthrough empty statements, implicit type conversion (which may result in arbitrary side effects), the \nunique JavaScript approach to variable resolution, and the notorious with and eval statements. All of \nthese features are properly described by our JSCert seman\u00adtics. Since space is limited, we chose just \none language feature to demonstrate our approach, and at least some of the subtleties of the JavaScript \nlanguage. Our running example will be the while statement.  while ( Expression ) Statement is evaluated \nas follows: 1. Let V = empty. 2. Repeat  a. Let exprRef be the result of evaluating Expression. b. \nIf ToBoolean(GetValue(exprRef)) is false, return (normal, V, empty). c. Let stmt be the result of evaluating \nStatement. d. If stmt.value is not empty, let V = stmt.value. e. If stmt.type is not continue || stmt.target \nis not in the current label set, then  i. If stmt.type is break and stmt.target is in the current label \nset, then return (normal, V, empty). ii. If stmt is an abrupt completion, return stmt. Figure 1. ECMAScript \n5 semantics of while loops Fig. 1 shows the English speci.cation of while exactly as it ap\u00adpears in the \nES5 standard. The text should be interpreted as pseudo\u00adcode, executing each statement in order. The ES5 \nspeci.cation of while is relatively short in comparison with other constructs, such as switch, whose \nspeci.cation spans more than one full page. This ES5 pseudo-code, like a traditional imperative programming \nlan\u00adguage, leaves completely implicit three major aspects of the se\u00admantics. The .rst aspect is divergence; \nES5 never talks explicitly about diverging programs, but it should be understood that if the evaluation \nof a sub-expression diverges, then the parent expression will also diverge. The second aspect is the \nthreading of the mu\u00adtable state; ES5 assumes that there is one global heap storing ob\u00adjects, and that \nthe instructions in the pseudo-code can modify such heap. The third is the propagation of exceptions \nthrough expres\u00adsions; ES5 describes the semantics of expressions in terms of the result of the sub-expressions, \nbut does not recall every time that exceptions propagate outwards from expressions.3 Unlike ES5, our \nJSCert speci.cation is fully explicit about divergence, mutation, and exceptions. We describe the pseudo-code \nfrom Fig. 1 in more detail. The basic skeleton is standard: repeat the loop body until the loop con\u00addition \nbecomes false, or until the body of the loop produces a break, a return, or an exception. Step 2b is \nnon-standard, illustrating one of the mechanisms necessary to interact with JavaScript s variable store. \nThe result of an expression is not necessarily ready to be used, but may be a reference to a variable \nstored as a .eld of an object. The internal GetValue function is used to de-reference it. In addition, \nJavaScript uses the internal function ToBoolean to im\u00adplicitly coerce the loop guard to a boolean before \nattempting to test it. A further complication comes from the fact that JavaScript al\u00adlows labelled break \nand continue statements that may refer to an outer loop. A current loop may be interrupted by such labelled \nbreak and continue operations, just like it would be interrupted if an exception was thrown. In Fig. \n1, the current label set refers to the set of labels that are associated with the current loop (since \na loop might have several labels as in e.g., a:b:c:while(1){break b;}). Finally, notice that while loops \nhave a return value in JavaScript. The de.nition of the JavaScript syntax forbids us from writing statements \nlike 1+while(x>3){x--}, however it does allow 1+eval (\"while(x>3){x--}\"). The assignments to the internal \npseudo\u00adcode variable V in Fig. 1 are aimed at maintaining the value that will serve as the result of \nthe current while loop. The value V is 3 In ES5, the propagation of exceptions out of expressions is \nimplicit, whereas the propagation of exceptions out of statements is explicit. This asymmetry is not \nonly awkward, it is also a potential source of ambiguities. This issue has been resolved in ES6, where, \nlike in our formalisation, the propagation of exceptions is always explicitly speci.ed. used in one of \ntwo cases: a break or a continue has been issued for this loop, or a break or a continue has been issued \nfor an outer loop and does not yet carry a non-empty value. Without further details, the reader may appreciate \nthe complex\u00adity of JavaScript semantics with respect to output values of state\u00adments by looking at the \nfollowing while loop examples, which re\u00adturn the last value that was produced by a statement in their \nbody (if any): eval(\"a: while(1){ while(1){ break a; }}\") ==> undefined eval(\"a: while(1){ while(1){ \ny=2; break a; }}\") ==> 2 eval(\"a: while(1){ x=3; while(1){ y=2; break a; }}\") ==> 2 eval(\"a: while(1){ \nx=3; while(1){ break a; }}\") ==> 3 The most surprising example is the fourth one: 3 is returned be\u00adcause \nthe statement x=3 has completion value 3 and the statement while(1){ break a; } has an empty completion \nvalue.  3.3 What we do not specify The ES5 standard is a document of 16 chapters, ranging over 209 pages, \nplus some additional annexes. It consists largely of pseudo\u00adcode in the style of Fig. 1, with clari.cations \nin English. The docu\u00adment includes: the speci.cation of parsing; the speci.cation of the syntax (e.g., \nobjects, heaps, environment records); the pseudo-code describing the semantics of expressions, statements, \nprograms, and internal properties; and the pseudo-code describing the semantics of native library functions. \nWe have given a mechanised Coq speci.cation for the impor\u00adtant part of the language: the syntax (as an \nabstract syntax tree); the semantics of expressions, statements and programs; and most na\u00adtive library \nfunctions that expose internal features of JavaScript. In particular, we have speci.ed the Object, Function \nand Errors libraries, with the only exception being functions involving the ma\u00adnipulation of arrays. \nWe also have speci.cations for the construc\u00adtors and most functions from the libraries Boolean and Number. \nFor .oating-point numbers, we rely on the Coq formalisation of IEEE 754 standard provided by the Flocq \nlibrary [40]. We have not formalised other standard libraries, such as Array, String and Date. These \nlibraries involve hundreds of functions. The vast majority of them do not interact with any internal \nfea\u00adture of JavaScript, and could be implemented as plain JavaScript code [54]. The speci.cation of these \nJavaScript standard library functions is orthogonal to the formalisation of the JavaScript pro\u00adgramming \nlanguage per se. We also have not speci.ed the parsing of JavaScript programs. Parsing is important because \nof JavaScript s eval statement, which requires parsing source code at runtime. The normalisation of the \nformal grammar of a programming language is more complicated than one might expect. The parsing of JavaScript \nprograms is made particularly tricky by the treatment of implicit semi-colons, as it in\u00advolves a one \ntoken look-ahead. We therefore leave the speci.cation of parsing to future work, and use the parser of \nthe Google Closure Compiler [25] in our reference interpreter JSRef. 4. JSCert: JavaScript speci.cation \nin Coq Our formal development in Coq, available from our project s web\u00adpage http://www.jscert.org, consists \nof .ve main parts:    Inductive restype := (* result type *) | restype_normal | restype_break | restype_continue \n| restype_return | restype_throw. Inductive resvalue := (* result value *) | resvalue_empty : resvalue \n| resvalue_value : value . resvalue | resvalue_ref : ref . resvalue. Inductive reslabel := (* result \nlabel *) | reslabel_empty : reslabel | reslabel_string : string . reslabel. Record res := { (* completion \ntriple *) res_type : restype; res_value : resvalue; res_label : reslabel }. Figure 2. JSCert completion \ntriples The .rst part describes the syntax and data structures, such as heaps and scopes, that are used \nto describe the formal semantics. The second part contains a collection of auxiliary de.nitions, such \nas functions used to convert a primitive value (a value that is not object) into a boolean, a number, \nor a string. These .rst two parts are described in \u00a7 4.1. The next two parts correspond to JSCert (\u00a7 \n4.2) and JSRef (\u00a7 5). The last part contains the correctness proof, that any result computed by JSRef \nis correct with respect to the semantics from JSCert (\u00a7 6). 4.1 Syntax and auxiliary de.nitions We give \na simple summary of the syntax and auxiliary de.nitions shared by JSCert and JSRef. The full Coq speci.cations \nare given in the .le JsPreliminary.v. Abstract syntax tree. Following common practice, we do not model \nthe parsing of language source code. Instead we work di\u00adrectly on the AST (abstract syntax tree). We \nobtain the AST by running the parser of the Google Closure Compiler [25], extended with some additional \ninterface code de.ned by us. The grammar of JavaScript expressions and statements is de\u00ad.ned, in .le \nJsSyntax.v, through a conventional inductive def\u00adinition that represents the abstract syntax tree. This \nde.nition is relatively short, since there are only 13 kinds of expressions and 17 kinds of statements. \nWe should note that we have factorised sim\u00adilar forms of if-statements and try-statements using option \ntypes, and that the de.nition of expressions depends on the grammar of literals (null, bool, number, \nstring), the grammar of the 11 unary op\u00aderators, and the grammar of the 24 binary operators. A JavaScript \nprogram consists of a list of statements, plus a strictness .ag which stipulates the evaluation order \nof the list of statements. The body of a function de.nition is itself a JavaScript program. The argument \nof a call to eval, once parsed, is also a JavaScript program. Completions. As we noted in \u00a7 3, the result \nof the evaluation of an expression, a statement or a program produces a completion triple, as given in \nFig. 2. A completion triple (type res) is made of a type, an optional value (or reference, if the expression \nis a variable name), and an optional label. The type is one of Normal, Return, Break, Continue, or Throw, \ncorresponding to the control .ow directive obtained from an evaluation. The value, if any, is either \na primitive value (a literal or undefined) or the location of an allocated object. This value describes \nthe result of a Normal expression or statement, the value carried by a Return statement, or the exception \nbeing thrown in a Throw result. The optional label of a completion triple is only used for Break and \nContinue types, in order to implement the break label and continue label instructions. A number of invariants \napply to completion triples. For exam\u00adple, if a completion triple carries a non-empty label, then it \nmust be of type Break or Continue. In order to better capture all the invariants on completion triples, \nwe were tempted to use a clean inductive de.nition with one constructor per type, and different ar\u00adguments \nfor each type. However, recall that one of our goals is a direct correspondence between our JSCert speci.cation \nand the ES5 standard. A change in the representation of something as fun\u00addamental as completion triples \nwould put considerable distance be\u00adtween the English prose of the ES5 and our formalisation of it. Forced \nto choose between a more elegant Coq representation and a more direct correspondence with the ECMA standard, \nwe chose the latter. Program execution. A JavaScript program is always executed in a given state and \nin a given execution context. The state consists of the set of allocated objects (the heap), plus the \nset of allocated environment records. The heap. The JavaScript object heap is represented as a .nite \nmap from locations to objects. An object is represented as a record with 25 .elds, including the prototype \nobject, the class name, a boolean extensible property, an optional primitive value (for objects of class \nBoolean, Number or String), the property map, as well as internal methods such as get or put, optional \n.elds such as body and scope for functions, and optional internal methods such as call or construct. \nEach internal method may have a small number of different behaviours depending on the object on which \nit is called (Arguments objects, for instance, have a differ\u00adent implementation of [[Get]]). We distinguish \nthese different be\u00adhaviours using a tag that describes how the internal method should be processed. Object \nproperties. The property map binds .eld names to prop\u00aderty attributes, rather than directly to values. \nA property at\u00adtribute is a record that contains a number of .elds. There are two kinds of property attributes: \ndata property attributes which have a value .eld, a writable .eld, an enumerable .eld, and a configurable \n.eld; and data accessor attributes which have a get .eld, a set .eld, an enumerable .eld, and a configurable \n.eld. The ES5 standard suggests that property attributes should be represented as a record with 6 optional \n.elds. In particular, the speci.cation of the function DefineOwnProperty involves the construction of \na property attribute, which explicitly manipulates records using arbitrary subsets of the 6 optional \n.elds. At the same time, in many other places, the standard uses exactly 4 .elds, (loosely) making the \nassumption that particular .elds are present and implicitly exploiting the fact that the property attribute \nis known to be either a data property or a data accessor attribute from the context and implicit invariants. \nSince we wanted to be faithful to the standard everywhere, we chose to provide two distinct representations \nof data properties: the .rst consists of a record with 6 optional .elds; and the second con\u00adsists of \nan inductive type with two cases, one for data property at\u00adtributes and one for data accessor attributes, \nboth represented as records with exactly 4 mandatory .elds. The overhead of de.ning conversion functions \nbetween the two forms was negligible com\u00adpared to the bene.ts of avoiding the pollution of many rules \nwith accesses to optional .elds. Environment records. Recall that the JavaScript state consists of the \nheap and the set of allocated environment records. We store environment records in a similar data structure \nto that used for the object heap, using a pointer to refer to a given environment record. An environment \nrecord can take one of two forms: a declarative environment record, which maps variable names to values \n(and to mutability .ags); or an object environment record, which consists of the location of a JavaScript \nobject (and some provide-this .ags). Declarative environment records provide the local scoping associated \nwith function calls, while object environment records provide the dynamic scoping associated with the \nwith construct. In addition, there is always at least one object environment record which points to the \nglobal object. To properly model function closures, a given function object represents the environment \nit closes over as a lexical environment stored in one of its internal .elds.  Execution context. The \nexecution context is represented as a triple that consists of the scope (both the lexical environment \nand the variable environment, as speci.ed by ES5), the current this object, and the current strictness \n.ag. We represent both lexical en\u00advironments and variable environments as a stack (a list) of pointers \nto environment records.  4.2 JSCert Based on the syntax and auxiliary de.nitions described above, the \nmain JSCert rules are de.ned in the .le JsPrettyRules.v. We formalise the semantics of JavaScript statements \nusing a judgement of the form t/S/C .s o, where: t denotes a statement; S denotes the state comprising \nthe object heap and the environment record heap; C denotes the context comprising the lexical and variable \nenvironment, the ES5 this object, and the strictness .ag; and o denotes the output. We have similar judgements \n.e, .i and .p for expressions, internal reductions, and full programs. For terminating computations, \nthe output is a pair made of the .nal state and the completion triple produced by the evaluation. Our \nJSCert semantics, expressed in pretty-big-step style [11], also captures diverging computations, using \na coinductive interpretation of the same set of evaluation rules. We discuss this further below. One \nkey ingredient to the factorisation of the evaluation rules is the de.nition of the output of an evaluation \nas a sum type, shown below, that describes either termination in a given state with a given result, or \ndivergence: Inductive out := | out_ter : state . res . out | out_div : out. Internal reductions, however, \nreturn results of many different types. Some, for instance, return property descriptors. We thus use \na more general return type, specret T, that is parameterised by the type T of what is returned. To add \nfurther complexity, internal reductions may call arbitrary user code which may terminate with an abrupt \ntermination, such as throwing an exception, or which may diverge. Their return type is, thus, not uniform: \nit returns a modi.ed state and a term of type T when the computation is successful; it returns a term \nof type out when the computation diverges or results in an abrupt termination. This behaviour is captured \nby the following type: Inductive specret T := | specret_val : state . T . specret T | specret_out : out \n. specret T. Pretty-big-step semantics. We express the JSCert semantics us\u00ading the pretty-big-step operational \nsemantics recently developed by Chargu\u00e9raud [11]. The key difference between the traditional big\u00ad step \nsemantics and Chargu\u00e9raud s pretty-big-step semantics is that we can decompose the evaluation of a single \nprogram construct using intermediate forms (de.ned in JsPrettyInterm.v), which extend the grammar of \nprogram statements and can be evaluated just like any other program. This style of semantics allows us \nto more effectively match the modularity of the ES5 standard. The advantages of the pretty-big-step semantics \nhave been de\u00adscribed in [11]. Here, we only recall the arguments applicable to large existing language \nstandards such as ES5. Nearly all English standards for industrial programming languages, including ES5, \nuse sentences of the form let R be the result of evaluating t . These sentences relate a term directly \nto its result, just as a big\u00adstep judgement would do. Because we want to be close to ES5, we cannot work \nwith a small-step presentation, as in [37], with rules of the form to evaluate if e then t1 else t2, \nexecute one step to reduce e into e1, and then evaluate if e1 then t1 else t2. If we attempt to use traditional \nbig-step semantics, we quickly .nd that we have to duplicate a signi.cant amount of material across several \nrules. For example, consider the loop while(e){ t }. In big-step, we need a rule to handle the case where \ne evaluates to an exception, another rule for the case where e evaluates to a value converted to the \nboolean false, yet another rule for the case where e evaluates to a value converted to the boolean true \nand the body of the loop evaluates to an exception, and so on. The problem here is that the steps made \nby a big-step semantics are too big to cleanly correspond to ES5. As suggested by our example, if we \nattempt to shoehorn ES5 into a big-step presenta\u00adtion, our repetition of premises will lead to a quadratic \nexplosion in the size of our rule set. For an idealised research programming lan\u00adguage, this sort of \nduplication may not present much of a problem. However, we soon realised that formalising ES5 in this \nway would quickly become unmanageable. This observation motivated the de\u00advelopment of the pretty-big-step \nsemantics, which has enabled us to write rules which very closely follow the structure of ES5. Pretty-big-step \nsemantics for while loops. Consider the ES5 de\u00adscription of while loops given in Fig. 1. The corresponding \nJSCert semantics is given in Fig. 3. Notice the close correspondence be\u00ad tween the steps of the ES5 pseudo-code \nand the JSCert rules. Step 1 of the ES5 pseudo-code says Let V=empty . The corresponding rule red_while_1 \nuses the notation stat_while L e1 t2 to refer to a while construct with guard e1, body t2 and label set \nL (used for managing break and continue statements). The rule says that in a given state, the loop may \nevaluate to the output o if the intermediate form stat_while_1 L e1 t2 resvalue_empty also evaluates \nto o. This intermediate form carries all the informa\u00adtion of the original while construct, and also carries \nthe additional information that the value of V is resvalue_empty, which is our Coq representation of \nthe ES5 empty value. Step 2 of Fig. 1 begins the loop in the ES5 pseudo-code. In our JSCert rules, we \nmay loop back to this point at any time, by using the stat_while_1 intermediate form as a premise of \na rule. Now let us consider Steps 2a and 2b. These steps represent a pattern which is very common in \nES5. First we evaluate some sub-expression, then we perform a GetValue and a type conver\u00adsion on the \nresult of that evaluation. In this case, we are convert\u00ading to a boolean. Notice that a great deal is \nleft implicit in the ES5 pseudo-code, which we wish to make explicit in our rules: the sub-expression \nor statement could diverge or throw an ex\u00adception; the type conversion could diverge or throw an excep\u00adtion;4 \nand both the sub-evaluation and the type conversion could have side effects on the program state. This \npattern occurs so fre\u00adquently that we introduced a special intermediate form to handle 4 This is actually \nnot the case for conversions to booleans, but it may happen in conversions to other types, such as String \nor Number.  red_while_1 stat_while_1 L e1 t2 resvalue_empty/S/C .s o stat_while L e1 t2/S/C .s o red_while_2b \n_false stat_while_2 L e1 t2 rv (vret S false)/_/C .s out_ter S rv red_while_2d ' If res_value R = resvalue_empty \nrv=then res_value R else rv stat_while_4 L e1 t2 rv R/S/C .s o stat_while_3 L e1 t2 rv (out_ter S R)/_/C \n.s o red_while_2e_true \u00ac(res_type R = restype_continue . res_label_in R L) stat_while_5 L e1 t2 rv R/S/C \n.s o stat_while_4 L e1 t2 rv R/S/C .s o red_while_2e_i_true res_type R = restype_break . res_label_in \nR L stat_while_5 L e1 t2 rv R/S/C .s out_ter S rv red_while_2e_ii_true res_type R = restype_normal stat_while_6 \nL e1 t2 rv R/S/C .s out_ter S R red_while_2a_2b spec_expr_get_value_conv spec_to_boolean e1/S/C .i y1 \nstat_while_2 L e1 t2 rv y1/S/C .s o stat_while_1 L e1 t2 rv/S/C .s o red_while_2b _true_2c t2/S/C .s \no1 stat_while_3 L e1 t2 rv o1/S/C .s o stat_while_2 L e1 t2 rv (vret S true)/_/C .s o red_while_2e_false \nres_type R = restype_continue . res_label_in R L stat_while_1 L e1 t2 rv/S/C .s o stat_while_4 L e1 \nt2 rv R/S/C .s o red_stat_exception out_of_ext_stat t = Some o abort o \u00ac(abort_intercepted_stat t) t/S/C \n.s o red_while_2e_i_false \u00ac(res_type R = restype_break . res_label_in R L) stat_while_6 L e1 t2 rv R/S/C \n.s o stat_while_5 L e1 t2 rv R/S/C .s o red_while_2e_ii_false res_type R = restype_normal stat_while_1 \nL e1 t2 rv/S/C .s o stat_while_6 L e1 t2 rv R/S/C .s o Figure 3. JSCert semantics of while loops it, \nwhile making these side effects, divergence, and exception prop\u00adagation clear. The reader may see this \nspecial intermediate form at work in the rule red_while_2a_2b. Here, the intermediate form spec_expr_get_value_conv \ntakes care of the evaluation of e1, its GetValue, and its type conversion. In this case, we specify which \ntype to convert to using the .ag spec_to_boolean. The re\u00admaining work of Step 2b is performed by rule \nred_while_2b _false. Notice that since the type-conversion may have side effects, the rule red_while_2b \n_false takes its initial state S from the result of the type conversion as given by the intermediate \nform. Rule red_while_2b _false is a terminating rule, since the corresponding ES5 step says to return \n(normal, V, empty) . In our formalisation, the pseudo-code variable V corresponds to the variable rv. \nSince we do not mention a completion type, our formalism assumes the completion type normal , and since \nwe do not mention a label set, our formalism assumes the label set empty . This is done in Coq using \na type coercion: Coercion res_normal rv := { res_type = restype_normal; res_value = rv; res_label = label_empty \n} Step 2c (which corresponds to rule red_while_2b _true_2c) fol\u00adlows the pretty-big-step pattern: evaluate \nsome sub-expression or statement (in this case t2), and store the result in some pseudo\u00adcode variable. \nEach new pseudo-code variable becomes a param\u00adeter of a new intermediate form in this case the o1 parame\u00adter \nof stat_while_3. Notice that the rules red_while_2b _false and red_while_2b _true_2c both assume that \nthe result of the type\u00adconversion performed by rule red_while_2a_2b was successful. In the event that \nthe type conversion diverges, or throws an excep\u00adtion, that aborting computation will be propagated by \nthe gen\u00aderal rule red_stat_exception5 . We handle divergence and excep\u00ad 5 We have similar aborting computation \nrules for expressions, internal reductions, and full programs. tional termination of the loop body (Statement \nin ES5 and t2 in our formalism) in exactly the same way. The rule red_stat_exception uses the out_of_ext_stat \nfunction to extract the output from any intermediate form, checks that this output is an aborting one, \nand checks that this aborting computation should not be inter\u00adcepted by a more speci.c rule. For example, \nin a while loop com\u00adputation, if an exception or divergence happens in Step 2c, in\u00adstead of always propagating \nthe exception/divergence, in some cases we want to intercept it. That is, the part of the de.nition of \nabort_intercepted_stat t is the case where t can be pattern\u00admatched with stat_while_3 L e1 t2 rv (out_ter \nS R). In this case the value of abort_intercepted_stat t is: res_label_in R L . r res_type R = restype_continue \n. res_type R = restype_break This condition checks for exceptional terminations caused by continue and \nbreak statements that target the particular loop that we are currently evaluating, and should be properly \nhandled by Step 2e (below). Step 2d is another conditional assignment, which we handle with a condition \nof our own in rule red_while_2d. Notice that we insist that we will only proceed with step 2d if our \nprevious steps terminated. This insistence is encoded in our pattern matching for out_ter S R which \nis the result of a terminating computation. The case in which the previous computation did not terminate \nis handled also by the abort rule which propagates diverging results. Step 2e begins a nested conditional \nexpression. It is simplest to describe the false case .rst, since this results in simply loop\u00ading back \nto the beginning of Step 2. This case is handled by rule red_while_2e_false, the .rst premise of which \nis the negation of the guard written in Fig. 1. The second premise of this rule be\u00ad gins the next iteration \nof the loop by re-using the intermediate form stat_while_1. In the true case, rule red_while_2e_true \ncontin\u00adues with a new intermediate form.  Step 2e(i) is another conditional expression, which we describe \nwith two simple rules. The true case which describes the ter\u00adminating computation breaking out of the \nloop corresponds to rule red_while_2e_i_true. The false case, which continues to step 2e(ii) corresponds \nto rule red_while_2e_i_false. Finally, we come to step 2e(ii): another conditional, modelled with a pair \nof rules. The abrupt completion case, which termi\u00adnates the computation corresponds to rule red_while_2e_ii_true. \nThe normal case, which loops back to the beginning of Step 2 using the stat_while_1 intermediate form \ncorresponds to rule red_while_2e_ii_false. It is a simple matter to express the rules given above as \nCoq de.nitions.6 For example the rule red_while_2e_ii_false can be written in Coq as follows. | red_while_2e_ii_false \n: .S C labs e1 t2 rv R o, res_type R = restype_normal . red_stat S C (stat_while_1 labs e1 t2 rv) o . \nred_stat S C (stat_while_6 labs e1 t2 rv R) o JavaScript formalisation challenges. The .rst challenge \nwith formalising ES5 is the size of the de.nition. ES5 consists of 16 chapters (209 pages, plus some \nadditional annexes) of English lan\u00adguage and pseudo-code description. While we do not aim to for\u00admalise \nthe parsing of concrete JavaScript syntax (most of chap\u00adters 1-7), JSCert and JSRef cover, and have a \ncorrectness proof for, all of chapters 8-14 and 16, except for the for-in statement (chap\u00adter 12), array \ninitialisation (chapter 11) and some type conversions (chapter 9). See http://www.jscert.org for the \ncurrent state of our JSCert speci.cation, which will grow over time. We choose not to formalise for-in \nat this stage because it is loosely speci\u00ad.ed and broken: based on the ES5 standard and conversations \nwith ES5 authors and browser implementors, we .led bugs in the current draft of the upcoming ES6 standard \n(bugs 1444 and 1443 of [58]). Still, it is an interesting challenge to give a more precise descrip\u00adtion \nof the semantics of for-in and we leave it for future work. Chapter 15 contains the native libraries, \nand would be consider\u00adable work to specify in full. We have JSCert rules and JSRef code (but no correctness \nproof) for those parts of chapter 15 where the libraries expose important JavaScript features. The inductive \nde.nition of JSCert is sometimes a little verbose, as illustrated by the rules for while. This verbosity \nis due to the fact that we closely follow ES5, which is itself quite verbose, and we are being fully \nexplicit about the evolution of the state and the context. In contrast, we shall see that the JSRef .x-point \npresen\u00adtation is signi.cantly more compact (\u00a7 5). Despite its verbosity, the inductive presentation of \nJSCert is ideally suited to conducting formal proofs, because it gives a .ne-grained view of the different \nsteps, allowing modular reasoning about the evaluation of a given JavaScript language construct. Moreover, \nas we have experienced with the veri.cation of the code of JSRef with respect to JSCert, the regularity \nof the pretty-big-step rules (which never have more than two evaluation premises), signi.cantly eases \nthe development of specialised tactics that help automate formal proofs. The second main challenge with \nformalising ES5 is the high complexity of the behaviour of a few features such as the represen\u00adtation \nof scopes and variable lookup, the non-obvious representa\u00adtion of data attributes, the treatment of function \ncalls and arguments 6 In our Coq development, we use a slightly different naming convention for the evaluation \nrules, which we believe will be easier to maintain when migrating from one version of the ECMA standard \nto the next. That said, for pseudo-code involving more than 5 steps, we left a comment next to each evaluation \nrule indicating its corresponding ES5 step number. object, and the aforementioned evaluation of for-in. \nSeveral fea\u00adtures introduced in ES5, such as execution contexts and strict mode, are spread throughout \nthe speci.cation and hence are non-trivial to capture. Finally, JavaScript internal methods can return \ntypes not al\u00adlowed to user code, and yet may call user code. We thus had to devise a de.nition that was \n.exible, yet allowed for proofs to be au\u00adtomated as much as possible. The next section on JSRef illustrates \nhow such an effort enabled us to factorise much of the presentation using a monadic approach. Semantics \nof diverging programs. ES5 never explicitly mentions diverging programs a program diverges as soon as \nthe evaluation of any subprogram diverges. Even though we have not conducted so far any formal reasoning \nrelated to divergence, we could for\u00admally capture the semantics of diverging JavaScript programs with\u00adout \nrequiring additional work. The constant out_div, which we in\u00adtroduced in the grammar of outputs o, materialises \ndivergence. This constant is propagated through the evaluation rules, just as excep\u00adtions are propagated. \nWe derive the judgement capturing the se\u00admantics of diverging programs by considering a coinductive inter\u00adpretation \n(greatest .xed-point) of the exact same set of evaluation rules as we have for terminating programs. \nAdditional details may be found in [11]. 5. JSRef: a reference interpreter for JavaScript Our goal in \nde.ning JSRef is to obtain an executable JavaScript interpreter, whose de.nition closely follows ES5 \nand can be proved correct with respect to JSCert. Note that JSRef does not need to be fast. It simply \nneeds to be ef.cient enough to interpret programs such as those found in the JavaScript test suites. \nHost language for JSRef. We have chosen to write JSRef directly in Coq: that is, in a core, purely-functional \nlanguage that admits only total functions. We could have chosen to use an imperative language with implicit \nstate in the hope that this would make trans\u00adlating ES5 pseudo-code easier. However, this would have \nmade the correspondence between our interpreter and our formal speci.ca\u00adtion much more dif.cult to establish. \nBy using Coq as a program\u00adming language, we make JavaScript s state and exception propaga\u00adtion explicit \n(which we consider an advantage), and make the for\u00admal statement and proof that our interpreter is sound \ncomparatively straightforward, as described in \u00a7 6. Structure of JSRef. The interpreter consists of a \nrecord that con\u00adtains functions for evaluating programs, statements, expressions, function calls, and \nso forth. The record type, slightly simpli.ed for clarity, appears below: Record runs_type : Type := \nruns_type_intro { runs_type_expr : state . execution_ctx . expr . result; runs_type_stat : state . execution_ctx \n. stat . result; runs_type_prog : state . execution_ctx . prog . result; runs_type_stat_while : state \n. execution_ctx . resvalue . label_set . expr . stat . result; ...}. Since our Coq implementation must \nconsist only of terminating functions, we bound the number of steps that JSRef may take in any given \nrun, a standard technique in ACL2 and Coq. This is similar to decide in advance If it hasn t .nished \nin 30 days, I ll hit Control-C . The token result_bottom is the result of a com\u00adputation that was interrupted \nin this way. In practice, it is rare to observe result_bottom, because we can specify a very large bound \non the number of steps. We thus de.ne our runs function as a .xpoint which takes an integer as an argument \nand returns a record of functions with the type of the record above:  Fixpoint runs max_step : runs_type \n:= match max_step with | O . { runs_type_expr := fun S _ _ .result_bottom S; runs_type_stat := fun S \n_ _ .result_bottom S; runs_type_prog := fun S _ _ .result_bottom S; runs_type_stat_while := fun S _ _ \n_ _ _ .result_bottom S; ...} | S max_step .(* max_step = 1 + max_step *) { runs_type_expr := fun S .run_expr \n(runs max_step ) S; runs_type_stat := fun S .run_stat (runs max_step ) S; runs_type_prog := fun S .run_prog \n(runs max_step ) S; runs_type_stat_while := fun S . run_stat_while (runs max_step ) S; ...} end. Each \nfunction in the record takes the record itself as its .rst pa\u00adrameter, instantiated with one fewer step, \nand all recursive calls are routed through the record. For example, run_stat runs S C s eval\u00aduates the \nstatement s in the state S (heap of objects and environ\u00adment records) and in the evaluation context C \n(used for variable 1 lookups), so long as the record runs contains functions for running 2 any kind of \nterm (programs, statements, expressions, etc.). As a 3 .rst approximation, the reader may simply think \nof the projections 4 runs.runs_type_expr as a direct recursive call to the function for 5 evaluating \nexpressions. 6 The function run_javascript below uses a record runs built 7 with a suf.ciently large \nnumber to serve as a bound on our recursive 8 calls. Since the bound is handled by this record, it does \nnot pollute 9 our main development. 10 11 Definition run_javascript runs p : result := 12 runs.runs_type_prog \nstate_init execution_ctx_init p. 13 An evaluation using a function from JSRef returns a result, 14 which \nis either a completed computation, or a special token that 15 states the interpreter has reached an impossible \nstate or that the 16 17 computation did not terminate in the allocated time. As with 18 JSCert, the type \nof the result may depend on what is being evalu-19 ated (typically for internal reductions); we thus \nde.ne the following 20 polymorphic resultof type: 21 22 Inductive resultof T := | result_some : T . resultof \nT | result_impossible | result_bottom : state . resultof T. The token result_impossible is returned \nby the interpreter if an invariant of the JavaScript language is violated: e.g., if the ES5 internal \nGetOwnProperty method is somehow called on a primi\u00adtive value. We claim that starting from a well-formed \ninitial state, the interpreter will never return result_impossible because we conjecture than all invariants \nare preserved by execution. As .rst approximation, terminating programs have a result of type resultof \nout (as de.ned in \u00a7 4.2, except that out_div is never used), whereas internal reduction have a result \nof type resultof ( specret T) for some T. In fact, for purpose of better code factorisa\u00adtion, terminating \nprograms have the following result type, which is isomorphic to resultof out: Inductive nothing : Type \n:=. (* uninhabited *) Definition result := resultof (specret nothing). Since there is no inhabitant of \nthe nothing type, the only way to obtain a result_some of the result type is through specret_out, which \ncarries a value of type out. This approach guarantees that every result type is an instance of specres \nT = resultof (specret T), greatly simplifying the de.nition of monadic operators. Monadic-style programming \nin JSRef. In order to avoid clut\u00adter, JSRef is programmed in a monadic style. For example, say Definition \nif_result_some (A B : Type) (W : resultof A) (K : A . resultof B) : resultof B := match W with | result_some \na .K a | result_impossible S .result_impossible S | result_bottom S .result_bottom S end. Definition \nif_spec (A B : Type) (W : specres A) (K : state . A . specres B) : specres B := if_result_some W (fun \nsp . match sp with | specret_val S0 a .K S0 a | specret_out o . if_abort o (fun _ .result_some (specret_out \no)) end). Figure 4. Two JSRef monadic operators Definition run_stat_while runs S C rv labs e1 t2 : result \n:= if_spec (run_expr_get_value runs S C e1) (fun S1 v1 . Let b := convert_value_to_boolean v1 in if b \nthen if_ter (runs.runs_type_stat S1 C t2) (fun S2 R . Let rv := ifb res_value R =resvalue_empty then \nres_value R else rv in Let loop := fun _ .runs.runs_type_stat_while S2 C rv labs e1 t2 in ifb res_type \nR =restype_continue . res_label_in R labs then (ifb res_type R = restype_break . res_label_in R labs \nthen res_ter S2 rv else (ifb res_type R =restype_normal then res_ter S2 R else loop tt)) else loop tt) \nelse res_ter S1 rv). Definition run_stat runs S C t : result := match t with | stat_while ls e1 t2 . \nruns.runs_type_stat_while S C ls e1 t2 resvalue_empty ... Figure 5. JSRef semantics of while loops we \nwant to evaluate a composite expression e which contains sub\u00adexpression e1. First we evaluate e1. If \nthis evaluation terminates with a completion triple of type normal, then we want to use the value produced \nby e1. However, if the evaluation of e1 produces either result_bottom or result_impossible, we want to \nprop\u00adagate this result immediately, without executing the rest of the code for processing e. In JSRef, \nthis pattern requires a simple use of the if_spec monadic operator: if_spec (runs.run_expr_get_value \nS C e1)(fun S v1 . ...), where the ... contains the code for process\u00ading the result value v1 of e1 in \nthe updated state S1. Fig. 4 shows the de.nition of if_spec. It depends on if_result_some which .rst \n.l\u00adters out the cases where the computation failed. Otherwise, the con\u00adtinuation K is called on the result. \nThe if_spec function constructs such a continuation (fun sp ....), which ensures that the result of the \ncomputation is not an abrupt termination (a result of the form specret_out o where o satis.es the predicate \nabort). JSRef function for while loops. Fig. 5 shows the function run_stat_while used to interpret while \nstatements. The three .rst arguments have been described before. Arguments e1 and t2 are respectively \nthe condition and body of the while loop. Argument labs is a set of labels annotating the loop (to deal \nwith break and continue statements). Finally, rv is the current value to return in the completion triple. \nIt corresponds to the V of Fig. 1. Intuitively, calling this function amounts to executing the JavaScript \nstatement labs:while(e1){t2} starting from heap S and execution context C. As we reuse this function \nfor the next step of the loop, we also need to carry around the last computed value rv. As shown in the \nextract from run_stat, rv is initially set to the empty value.  We now detail the code of the loop. \nWe .rst evaluate the condi\u00adtion e1 and capture its result using the continuation (fun S1 v1 ....). Remember \nthat this continuation runs only if the result of the com\u00adputation is successful and if it is not an \nabrupt termination. The value v1 is then converted to a boolean to choose which branch of the if to execute. \nIf it is false, the else branch is taken (Line 17), and the current state is returned alongside with \nthe last computed value rv (coerced to the triple (normal,rv ,empty)). Otherwise, the statement t2 is \nevaluated using the monadic operator if_ter. This operator is very similar to if_spec, except that it \napplies the con\u00adtinuation even if the result is an abrupt termination. This allows us to check for a \nbreak or continue result from running the statement. Lines 6 and 7 update rv if the result value of the \nstatement was not empty. We then inspect the termination type of the result to proceed. Line 16 is taken \nif it is a continue with its label in labs. Otherwise, if the result is a break with its label in labs, \nthen the computation terminates as a normal result (Line 13). If the result is not normal (e.g., a return \nor a break with a different label), then it is returned as such (Line 15, then branch). Finally, if the \nresult is normal, then the next iteration of the while loop is run (else branch). Note how the while \nloop code in JSRef is more concise than that in JSCert. This observation applies in general to most parts \nof the de.nitions. Overall, the full de.nition of JSCert is ~3,000 lines of Coq, whereas the corresponding \nde.nition of JSRef is ~2,000 lines. Running the interpreter. The Coq system provides a way to au\u00adtomatically \nextract OCaml code from the de.nition of computable functions. This is crucial to our ability to run \nour interpreter and test it against existing test suites. There are experimental tools that allow the \nextraction of OCaml code directly from an inductive def\u00adinition, such as the one of JSCert. We did not \npursue this approach for the following reasons: these tools are not yet mature; the de\u00advelopment of JSRef \nis independently interesting; and, this way, we could make natural choices when ES5 was underspeci.ed. \nAt the expense of some trust, Coq provides the ability to lo\u00adcally override the default mapping from \nCoq values and types to OCaml values and types. Of course, this feature should be used sparingly. We \nuse it in two ways. First, as previously explained, we rely on an untrusted parser. More precisely, our \ndevelopment as\u00adsumes the existence of a parser returning either some AST or none in case of a parse error: \nAxiom run_parse : string . option prog In order to run tests and execute the eval operator, we provide \nan OCaml function that implements run_parse by calling an existing JavaScript parser [25] and then translating \nthe output to the OCaml representation of our AST for JavaScript code. The second cus\u00adtomisation regards \nnumbers. In JavaScript, all numbers are IEEE 754 double precision .oating-point numbers. In our formalisation, \nwe use the Flocq library [40] to precisely model IEEE 754 .oating\u00ad point numbers and their operations. \nSince the OCaml type float corresponds to IEEE 754, it is safe for us to extract JavaScript num\u00adbers \ndirectly to OCaml float. Similarly, we provide direct OCaml implementations for other operations on numbers \nmentioned in ES5, such as conversion to and from Int32 types. 6. Evaluation: establishing trust An important \naim for us was to design JSCert and JSRef in such a way that they could be evaluated, and hence eventually \ntrusted, by e.g., ECMA authors, implementors of JavaScript virtual machines, designers of secure subsets \nor compilers targeting JavaScript, and developers of JavaScript analysis tools. In this section, we describe \nour methodology for establishing trust, how to extend our results in future to strengthen such trust, \nand the bugs that we have found in ES5 and ES6, test262, and several major browsers. Our methodology \nfor establishing trust involves four compo\u00adnents: the English standard ES5 and the ECMA conformance test \nsuite, test 262, pre-existed our work; the mechanised speci.cation, JSCert, and the certi.ed interpreter, \nJSRef, are introduced in this paper. We establish connections between ES5, JSCert, JSRef and test 262, \nto justify our claim that JSCert and JSRef have been de\u00adsigned in such a way that they can be evaluated \nand trusted. We also explore ways of establishing further connections in future. We have constructed \nJSCert to be as close as possible to ES5, and have proved JSRef correct with respect to JSCert. Indepen\u00addently, \nengineers have developed test 262 to cover as many aspects of ES5 as they reasonably could. We have been \nable to check that JSRef behaves as expected on all the appropriate tests, given our coverage of ES5. \nJSCert and JSRef can therefore be challenged through two distinct paths: through the eyeball correspondence \nwith ES5; and through the execution of tests by our reference inter\u00adpreter. Having these two independent \npaths signi.cantly decreases the likelihood of bugs remaining in JSCert. 6.1 Connections to establish \ntrust Eyeball closeness. As discussed in \u00a7 4, we have designed JSCert to be as close to ES5 as we can. \nWe follow the ES5 data structures precisely. Every line of pseudocode in ES5 corresponds to one or two \nrules in JSCert, and our code is commented to make these correspondences explicit. Anyone with basic \ntraining in reading Coq speci.cations should be able to check the correspondence between the ES5 prose \nand our JSCert de.nitions. We have intentionally chosen to differ from ES5 at a few places. We make explicit \nseveral constructs that are left implicit in ES5, to help with the eyeball assessment that JSCert is \na correct formalisa\u00adtion of ES5. Unlike ES5, we treat the state, exceptions, and diver\u00adgence explicitly. \nWe always mention the current evaluation context and strictness .ag, whereas ES5 only describes places \nwhere they are modi.ed. Moreover, contrary to ES5 pseudo-code, in JSCert we do not use a repeat statement \nbut rely instead on an explicit control-.ow jump. We did experiment with an higher-order inter\u00admediate \nform to capture repeat loops in the inductive semantics. However, we concluded that it obfuscated the \nde.nitions and added technicalities for very limited bene.t. Setting aside these differ\u00adences in the \nstyle of presentation, we believe that JSCert is close enough to ES5 that (at least several) ECMA authors \nshould be able to proof read our de.nitions Correctness. We have formally proved in Coq that JSRef is \ncor\u00adrect with respect to JSCert. More precisely, if the JSRef interpreter evaluates program p to output \no, in a .nite number of steps bounded by n, then it must be the case that the program p is related to \nthe output o by the inductive semantics of JSCert. More formally, the Coq statement of the theorem is \nTheorem run_javascript_correct : .(n:nat) (p:prog) (o:out), run_javascript (runs n) p = result_some (specret_out \no) . red_javascript p o. where red_javascript corresponds to the evaluation judgement .p specialised \nto the initial state. The proof of this theorem consists of 3500 lines of Coq and is relatively straightforward. \nWe inspect the code of JSRef line by line, following the case analyses and the function call performed \nand showing that each of these operations corresponds to the application of one or two pretty-big-step \nevalu\u00adation rules from JSCert.  More precisely, recall from \u00a7 5 that JSRef is written in a monadic style. \nTo step through the code of JSRef, we need to reason about the behaviour of the monadic operators. To \ndo this, we prove, for each monadic operator, a lemma specifying its be\u00adhaviour. We then de.ne a custom \nCoq tactic that looks at the head monadic operator of the JSRef piece of code at hand, and automat\u00adically \napplies the corresponding lemma. Thanks to this tactic, we are able to automate the reasoning on the \nabrupt termination cases. As a result, our proof script basically consists of case analyses and calls \nto our custom tactic with the names of the evaluation rules to be applied given as arguments. As we were \nproving correctness, we were able to detect and correct many typos, and also a small number of more serious \nmis\u00adinterpretations of ES5. JSCert and JSRef were intentionally devel\u00adoped by different researchers. \nDespite close interaction between re\u00adsearchers, there were inevitable discrepancies in interpretation \nbe\u00adtween JSCert and JSRef, which were picked up during the course of proving correctness. This proof \nis a cornerstone of our work, as it enables us directly to validate our JSCert speci.cation with testing. \nTests. We ran JSRef against test262, the ES5 conformance test suite. JSRef successfully executed all \nthe tests that we expected it to pass, given our coverage of ES5. In test262, there are 11746 tests, \norganised by chapters. There are no tests for chapters 1 5. Chapters 6 and 7 relate to the parser rather \nthan the language, chapter 15 corresponds to native libraries, and there are some additional test directories \n(e.g. best practice and intl402 ) which we do not study. There are 2782 main tests associated with chapters \n8 14. Our of these, we pass 1796. We have been able to check (with the help of search tools) that all \nthe remaining tests fail because: either they use for-in; or they use chapter 15 library functionalities \nwhich we have not implemented; or they fail due to the Google Closure parser being slightly more permissive \nthan ES5 and hence not failing where expected. Running JSRef over thousands of tests has been very useful, \nas it allowed us to detect and .x several bugs in JSRef and JSCert. Most of these bugs were simple typos, \nbut a few of them were more serious: e.g., converting a record to a data property instead of a data accessor. \n 6.2 Increasing trust in JSCert and JSRef Since we are discussing trust, we ought to also recall that, \nby design, the correctness of our development relies on the formal tools, formal libraries, parsers, \ncompilers and glue code involved in our tool chain. More precisely, trust in JSCert and JSRef requires \ntrust in Coq, Coq s extraction mechanism, the OCaml compiler, the Google Closure parser, our glue code \nfor linking the parser to the extracted code of JSRef, and our glue code for binding boolean and .oating-point \nJavaScript values to their OCaml counterparts. There are three main ways in which we may further increase \nour trust in JSCert and JSRef: by establishing determinacy for most of the evaluation rules for JSCert; \nby establishing the completeness of JSRef with respect to JSCert; and by using a code-coverage analysis \nof JSRef to help us complete existing test suites so as to cover all aspects of ES5. The last two correspond \nto the dotted arrows in the following diagram: eyeball correctness running tests completeness test \ngeneration ES5 does not explicitly say that the semantics of JavaScript is deterministic. Yet, it turns \nout that, with the exception of the loosely-speci.ed for-in statement and implementation\u00addependent constructs, \nthe standard only describes deterministic behaviour. We should be able to prove this. Conducting such \na proof would ensure that JSCert does not contain errors leading to more behaviours being accepted by \nJSCert than ES5. If JSCert was erroneous in this way, it could compromise e.g. the veri.cation of tools \nthat compile other programming languages into JavaScript. In future, we would like to prove in Coq that \nJSCert is deterministic. We have not attempted to do this proof yet due to a limitation of the case-analysis \ntactic of Coq. This tactic leads to an (unnecessary) quadratic explosion of the size of the proof-term \nwhen performing a nested case analysis on two derivations, precisely what is neces\u00adsary for proving determinacy. \nWe are waiting for the release of the new case-analysis tactic, under development, which should enable \nus to build proof terms of size linear in that of the proof. We would also like to prove the completeness \nof JSRef with re\u00adspect to JSCert. Currently, when executing a JavaScript program that terminates within \na reasonable amount of time, our interpreter might, in theory, return result_impossible or result_bottom \nin\u00adstead of the expected result. (Note that, as established by the cor\u00adrectness result, if JSRef produces \nsome result then it must be the right result.) In practice, on all the tests that we considered, we never \nobtained result_impossible or result_bottom. This sit\u00aduation is very unlikely to happen because, from \nlooking at the source code of JSRef, it appears obvious that we never return result_bottom except when \nthe bound on the number of steps is reached, and it is relatively straightforward to check we would only \nreturn result_impossible if the invariants on the state (e.g., there are no dandling pointers) were to \nbe broken. That said, it would be more satisfying to prove in Coq that if a program is related to some \noutput using JSCert, then executing this program using JSRef would produce the same output. The reason \nwe have not done it yet is because the invariants on the states involved are numerous and quite arduous \nto de.ne, and because completeness is not critical to safety. Another way to increase the trust in JSCert \nand JSRef would be to extend existing test suites so as to include suf.ciently many tests to cover all \nthe paths of ES5. With such full coverage, we would signi.cantly increase the degree of con.dence in \nthe correctness of JSRef through the testing path. The ECMAScript community acknowledges that the test262 \ncoverage needs improvement, and in fact has a long-standing open bug on the test262 bugzilla enti\u00adtled \nNeed academic-like review of existing test coverage versus ES5.1 [23]. Using JSRef in combination with \na coverage analy\u00ad sis tool for OCaml programs, called the Bisect tool [14], we have been able to visualise \nthe lines of JSRef that are never executed by any test program. We therefore have at least some technology \nfor investigating the coverage of JSRef, and hence of ES5 (provided that JSRef does not miss entire pieces \nof ES5). We need more man\u00adpower to extend test262 with the missing tests. An alternative approach to \nproducing tests manually would be to generate them automatically, by using automated theorem provers \nto exhibit tests whose execution is able to reach a particular line of JSRef code. As these tests would \nbe generated from JSRef, they would certainly not trigger bugs in JSRef. However, if these tests were \nto fail on other JavaScript virtual machines, then we would know that there is either a bug in JSRef \nor in the virtual machines. This alternative approach to producing tests would in\u00adcrease our trust in \nJSRef, by showing that it mainly behaves like existing JavaScript implementations on tests that cover \nall of its source code and by highlighting where it diverges from particular implementations.  6.3 Bugs \ndiscovered Through our work, we have been trying to understand and ex\u00adpress in Coq the semantics of JavaScript, \nincluding its darkest cor\u00adners. To understand the semantics intended by ECMA authors and the semantics \nintended by implementers of JavaScript virtual ma\u00adchines, we looked not only at ES5, but also at the \nnext version of ECMAScript (ES6), at several test suites, and at the behaviour of the major browsers. \nWe spotted bugs in all of these places, obtain\u00ading con.rmation from ECMA authors and JavaScript implementers \nthat they were indeed bugs.  In ES6, we discovered three bugs, ranging from simple typos to an informative \nalgorithm which did not correctly implement the behaviour it was claiming. In test262, we discovered \nthree bugs, the most interesting being a test which contains code that seems to do nothing and whose \npurpose is unknown to the current main\u00adtainers. V8 and Webkit incorrectly implement enumeration in the \npresence of shadowing, as used by for-in. This was discovered by Miller [60] and strengthened by ourselves. \nAll browser implemen\u00ad tations give (different) incorrect completion values for try...catch ...finally, \nalso discovered in part by Bargull [60]. In addition, we observed in V8 that dead code after a try...catch...finally \nblock may incorrectly change the value that is returned by the block [60]. Finding bugs in browsers, \nstandards and industry tests was not the main motivation for the work presented here. The bugs men\u00adtioned \nare simply a side effect of attempting to understand ES5 well enough to build JSCert and JSRef. In future, \nwe hope to use JSRef to construct more complete test suites, for potentially detect\u00ading unknown bugs \nin existing browsers. 7. Conclusions and future work This paper investigates a scienti.c method for developing \na trusted, mechanised speci.cation of a programming language. We focused on JavaScript because the language \nis and will continue to be used by many people, the standards are quite mature and still evolving, and, \nfor many applications, JavaScript programs need to be secure. There are a few key tools used to support \nlarge\u00adscale language formalisations; see related work. We used the Coq theorem prover, because it supports \nlarge-scale mechanised proof as well as speci.cation, and it has a well-used mechanism for extracting \nexecutable OCaml code. We have introduced JSCert, a Coq speci.cation of ES5, and JS-Ref, an executable \nreference interpreter which is provably correct with respect to JSCert. JSCert closely corresponds to \nES5, follow\u00ading its natural modularity. JSRef is tested against industrial test suites. Our design methodology \nmeans that (assuming you trust Coq), if you trust either the eyeball connection to ES5 or the in\u00addustrial \ntests, you can trust both JSCert and JSRef. It remains to be seen what impact might be possible with \nthe ECMA standards. For ES6, which is nearing the end of its devel\u00adopment, we have .led bug reports and \nare having on-going discus\u00adsions with some of its authors. For ES7, our work demonstrates that it might \nbe feasible for a Coq speci.cation to evolve at nearly the same time as the English standard. One key \nquestion is what might we be able to offer the ECMA standards. It is not our role to make key design \ndecisions for ECMAScript. We do, however, believe that providing an of.cial mechanised speci.cation along\u00adside \nthe English prose standard would add signi.cant value for tool developers and language analysts. Moreover, \nan executable refer\u00adence interpreter that provably complies with the Coq speci.cation and passes the \nECMA tests can help validate language implementa\u00adtions or optimisations, by providing an oracle to de.ne \nthe expected results of new tests. We have many future plans. To begin with, we would like to increase \nas much as possible the trust in our de.nitions, as explained in \u00a7 6, by formalising determinacy and \ncompleteness in Coq, by running additional test suites (e.g., Firefox tests), and by designing new tests \ntowards achieving full coverage of ES5. Then, we would also like to extend our formalisation. First, \nit could be interesting to investigate the formalisation of parsing. Second, we may want to formalise \nbrowser-speci.c behaviours. Third, we would be interested in extending our work to ES6 and ES7. We are, \nof course, also interested in many of the practical applications of our work, as discussed in \u00a7 1. Acknowledgements. \nWe are grateful to the POPL 14 reviewers for their insightful comments and suggestions. We would like \nto thank our interns Lorenz Breidenbach for help with testing and debugging, and Benjamin Farinier for \nhis help in setting up the code coverage tool. Bodin and Schmitt are partially supported by the French \nANR-10-LABX-07-01 Laboratoire d excellence CominLabs. Filaretti and Maffeis are supported by EPSRC grant \nEP/I004246/1. Gardner and Smith are partially supported by EP-SRC grant EP/K032089/1 and EPSRC programme \ngrant EP/H008373. Naudziuniene is supported by an EPSRC DTA award. References [1] J. Alglave, L. Maranget, \nS. Sarkar, and P. Sewell. Fences in weak memory models. In Proc. CAV: 22nd International Conference on \nComputer Aided Veri.cation, LNCS 6174, pages 258 272, 2010. [2] C. Anderson, P. Giannini, and S. Drossopoulou. \nTowards type infer\u00adence for JavaScript. In ECOOP 05, pages 428 452. Springer, 2005. [3] A. W. Appel. \nVeri.ed software toolchain -(invited talk). In ESOP, pages 1 17, 2011. [4] M. Batty, S. Owens, S. Sarkar, \nP. Sewell, and T. Weber. Mathematizing C++ concurrency. In POPL, pages 55 66, 2011. [5] M. Batty, M. \nDodds, and A. Gotsman. Library abstraction for C/C++ concurrency. In POPL, 2013. [6] K. Bhargavan, A. \nDelignat-Lavaud, and S. Maffeis. Language-based defenses against untrusted browser origins. In USENIX \nSecurity Sym\u00adposium, 2013. [7] S. Bishop, M. Fairbairn, M. Norrish, P. Sewell, M. Smith, and K. Wansbrough. \nEngineering with logic: HOL speci.cation and symbolic-evaluation testing for TCP implementations. In \nPOPL, pages 55 66, 2006. [8] S. Blazy and X. Leroy. Mechanized semantics for the Clight subset of the \nC language. J. Autom. Reasoning, 43(3):263 288, 2009. [9] E. B\u00f6rger, N. G. Fruja, V. Gervasi, and R. \nF. St\u00e4rk. A high-level modular de.nition of the semantics of C#. Theor. Comput. Sci., 336 (2-3):235 284, \n2005. [10] C11. ISO/IEC 9899:2011. http://www.iso.org/iso/ iso_catalogue/catalogue_tc/catalogue_detail.htm? \ncsnumber=57853, 2011. [11] A. Chargu\u00e9raud. Pretty-big-step semantics. In ESOP, pages 41 60, 2013. [12] \nR. Chugh and R. Jhala. Dependent types for JavaScript. CoRR, abs/1112.4106, 2011. [13] R. Chugh, J. A. \nMeister, R. Jhala, and S. Lerner. Staged information .ow for JavaScript. In PLDI 09, pages 50 62. ACM, \n2009. [14] X. Clerc. Bisect. http://bisect.x9c.fr/, 2012. [15] Compcert Team. Compcert. http://compcert.inria.fr/, \n2013. [16] D. Crockford. ADSafe: Making JavaScript safe for advertising. http: //adsafe.org/, 2007. [17] \nS. Drossopoulou and S. Eisenbach. Is the Java type system sound? In FOOL4, 1997. [18] ECMA International. \nTest262. http://test262.ecmascript. org/, 2010. [19] C. Ellison and G. Rosu. An executable formal semantics \nof C with applications. In POPL, pages 533 544, 2012. [20] A. Farzan, F. Chen, J. Meseguer, and G. Rosu. \nFormal analysis of Java programs in JavaFAN. In CAV, pages 501 505, 2004. [21] C. Fournet, N. Swamy, \nJ. Chen, P.-\u00c9. Dagand, P.-Y. Strub, and B. Livshits. Fully abstract compilation to JavaScript. In POPL, \npages 371 384, 2013.  [22] Free Software Foundation. C language testsuites: C-torture\" version 4.4.2. \nhttp://gcc.gnu.org/onlinedocs/gccint/C-Tests. html, 2010. [23] D. Fugate. Test262 bug 56. https://bugs.ecmascript.org/ \nshow_bug.cgi?id=56, 2011. [24] P. Gardner, S. Maffeis, and G. D. Smith. Towards a program logic for JavaScript. \nIn POPL 12, pages 31 44. ACM, 2012. [25] Google Inc. The Closure Compiler. https://developers. google.com/closure/compiler/, \n2009. [26] S. Guarnieri and V. B. Livshits. GATEKEEPER: Mostly static en\u00adforcement of security and reliability \npolicies for JavaScript code. In USENIX Security Symposium, pages 151 168, 2009. [27] S. Guarnieri, M. \nPistoia, O. Tripp, J. Dolby, S. Teilhet, and R. Berg. Saving the world wide web from vulnerable JavaScript. \nIn ISSTA, pages 177 187, 2011. [28] A. Guha, C. Saftoiu, and S. Krishnamurthi. The essence of JavaScript. \nECOOP 2010, pages 126 150, 2010. [29] Y. Gurevich. Evolving algebras. In IFIP Congress (1), pages 423 \n427, 1994. [30] D. Hedin and A. Sabelfeld. Information-.ow security for a core of JavaScript. In CSF \n12, pages 3 18. IEEE, 2012. [31] D. Herman and C. Flanagan. Status report: specifying JavaScript with \nML. In ML, pages 47 52, 2007. [32] D. Jang and K. Choe. Points-to analysis for JavaScript. Proc. of SAC \n09, page 1930, 2009. [33] S. H. Jensen, A. M\u00f8ller, and P. Thiemann. Type analysis for JavaScript. In \nSAS 09. Springer, 2009. [34] D. K. Lee, K. Crary, and R. Harper. Towards a mechanized metatheory of Standard \nML. In POPL, pages 173 184, 2007. [35] S. Maffeis and A. Taly. Language-based isolation of untrusted \nJavaScript. In CSF 09. IEEE, 2009. [36] S. Maffeis, J. Mitchell, and A. Taly. ECMA 262-3 operational \nseman\u00adtics. http://jssec.net/semantics/, 2007. [37] S. Maffeis, J. Mitchell, and A. Taly. An operational \nsemantics for JavaScript. In APLAS 08, pages 307 325. Springer, 2008. [38] S. Maffeis, J. Mitchell, and \nA. Taly. Isolating JavaScript with .lters, rewriting, and wrappers. In ESORICS 09. Springer, 2009. [39] \nS. Maffeis, J. C. Mitchell, and A. Taly. Object capabilities and iso\u00adlation of untrusted web applications. \nIn Security and Privacy (SP), pages 125 140. IEEE, 2010. [40] G. Melquiond. Floats for Coq 2.1.0. http://flocq.gforge. \ninria.fr/, 2012. [41] R. Milner, M. Tofte, and D. Macqueen. The De.nition of Standard ML. MIT Press, \nCambridge, MA, USA, 1997. ISBN 0262631814. [42] Mozilla. Mozilla automated JavaScript tests. https: //developer.mozilla.org/en-US/docs/SpiderMonkey/ \nRunning_Automated_JavaScript_Tests, 2013. [43] T. Nipkow, L. C. Paulson, and M. Wenzel. Isabelle/HOL \n-A Proof Assistant for Higher-Order Logic, volume 2283 of Lecture Notes in Computer Science. Springer, \n2002. [44] M. Norrish. Formalising C in HOL. PhD thesis, Computer Lab., University of Cambridge, 1998. \n[45] D. S. P. Phung and A. Chudnov. Lightweight self protecting JavaScript. In ASIACCS 2009. ACM Press, \n2009. [46] C. Park, H. Lee, and S. Ryu. An empirical study on the rewritability of the with statement \nin JavaScript. In FOOL, 2011. [47] C. Park, H. Lee, and S. Ryu. SAFE: Formal speci.cation and im\u00adplementation \nof a scalable analysis framewrok for ECMAscript. In FOOL, 2012. [48] F. Pfenning and C. Sch\u00fcrmann. System \ndescription: Twelf -a meta\u00adlogical framework for deductive systems. In CADE, pages 202 206, 1999. [49] \nJ. G. Politz, S. A. Eliopoulos, A. Guha, and S. Krishnamurthi. AD\u00adsafety: Type-based veri.cation of JavaScript \nsandboxing. In USENIX Security Symposium, 2011. [50] J. G. Politz, M. J. Carroll, B. S. Lerner, J. Pombrio, \nand S. Krishna\u00admurthi. A tested semantics for getters, setters, and eval in JavaScript. SIGPLAN Not., \n48(2):1 16, Oct. 2012. [51] J. G. Politz, B. S. Lerner, H. Q. de la Vallee, T. Nelson, A. Guha, M. Carroll, \nand S. Krishnamurthi. Mechanized .JS. http://blog. brownplt.org/2012/06/04/lambdajs-coq.html, 2012. [52] \nG. Richards, C. Hammer, B. Burg, and J. Vitek. The eval that men do -A large-scale study of the use of \neval in JavaScript applications. In ECOOP 11, pages 52 78. Springer, 2011. [53] G. Ro\u00b8su and T. F. \u00b8anu\u00b8a. \nAn overview of the K semantic frame- Serb.t.work. Journal of Logic and Algebraic Programming, 79(6):397 \n434, 2010. [54] T. Schneidereit. Convert some array extras to self-hosted js imple\u00admentations. https://hg.mozilla.org/mozilla-central/rev/ \n5593cd83590e, 2012. [55] P. Sewell, F. Z. Nardelli, S. Owens, G. Peskine, T. Ridge, S. Sarkar, and R. \nStrnisa. Ott: Effective tool support for the working semanticist. J. Funct. Program., 20(1):71 122, 2010. \n[56] D. Syme. Proving Java type soundness. In Formal Syntax and Semantics of Java, pages 83 118, 1999. \n[57] A. Taly, \u00da. Erlingsson, J. C. Mitchell, M. S. Miller, and J. Nagra. Automated analysis of security-critical \nJavaScript APIs. In IEEE Symposium on Security and Privacy, pages 363 378, 2011. [58] The JSCert Team. \nMozilla Bug 862771, V8 Issue 2529, ES6 Bugs 1442-1444, Test262 Bug 1445, 1450, 1600. https://bugzilla.mozilla.org/show_bug.cgi?id=862771, \nhttp://code.google.com/p/v8/issues/detail?id=2529, https://bugs.ecmascript.org/show_bug.cgi?id= {1442-1445,1450,1600}, \n2013. [59] P. Thiemann. Towards a type system for analyzing JavaScript pro\u00adgrams. In ESOP 05, pages 140 \n140. Springer, 2005. [60] Various developers. Bugs in ES6, Test262 and browsers. https:// bugs.webkit.org/show_bug.cgi?id={38970,104309} \nhttp: //code.google.com/p/v8/issues/detail?id={705,2446} https://bugzilla.mozilla.org/show_bug.cgi?id=819125, \n2010 2012. [61] J. ev .c\u00edk, V. Vafeiadis, F. Zappa Nardelli, S. Jagannathan, and P. Sewell. Relaxed-memory \nconcurrency and veri.ed compilation. In Proc. POPL, 2011.    \n\t\t\t", "proc_id": "2535838", "abstract": "<p>JavaScript is the most widely used web language for client-side applications. Whilst the development of JavaScript was initially just led by implementation, there is now increasing momentum behind the ECMA standardisation process. The time is ripe for a formal, mechanised specification of JavaScript, to clarify ambiguities in the ECMA standards, to serve as a trusted reference for high-level language compilation and JavaScript implementations, and to provide a platform for high-assurance proofs of language properties.</p> <p>We present JSCert, a formalisation of the current ECMA standard in the Coq proof assistant, and JSRef, a reference interpreter for JavaScript extracted from Coq to OCaml. We give a Coq proof that JSRef is correct with respect to JSCert and assess JSRef using test262, the ECMA conformance test suite. Our methodology ensures that JSCert is a comparatively accurate formulation of the English standard, which will only improve as time goes on. We have demonstrated that modern techniques of mechanised specification can handle the complexity of JavaScript.</p>", "authors": [{"name": "Martin Bodin", "author_profile_id": "81501684896", "affiliation": "Inria &#38; ENS Lyon, Rennes, France", "person_id": "P4383753", "email_address": "martin.bodin@inria.fr", "orcid_id": ""}, {"name": "Arthur Chargueraud", "author_profile_id": "81372592434", "affiliation": "Inria &#38; LRI, Universite Paris Sud, CNRS, Saclay, France", "person_id": "P4383754", "email_address": "arthur.chargueraud@inria.fr", "orcid_id": ""}, {"name": "Daniele Filaretti", "author_profile_id": "86158872757", "affiliation": "Imperial College London, London, United Kingdom", "person_id": "P4383755", "email_address": "d.filaretti11@imperial.ac.uk", "orcid_id": ""}, {"name": "Philippa Gardner", "author_profile_id": "81351597297", "affiliation": "Imperial College London, London, United Kingdom", "person_id": "P4383756", "email_address": "philippa.gardner@imperial.ac.uk", "orcid_id": ""}, {"name": "Sergio Maffeis", "author_profile_id": "81100507240", "affiliation": "Imperial College London, London, United Kingdom", "person_id": "P4383757", "email_address": "sergio.maffeis@imperial.ac.uk", "orcid_id": ""}, {"name": "Daiva Naudziuniene", "author_profile_id": "81488668610", "affiliation": "Imperial College London, London, United Kingdom", "person_id": "P4383758", "email_address": "d.naudziuniene11@imperial.ac.uk", "orcid_id": ""}, {"name": "Alan Schmitt", "author_profile_id": "81326492348", "affiliation": "Inria, Rennes, France", "person_id": "P4383759", "email_address": "alan.schmitt@inria.fr", "orcid_id": ""}, {"name": "Gareth Smith", "author_profile_id": "81351602806", "affiliation": "Imperial College London, London, United Kingdom", "person_id": "P4383760", "email_address": "gareth.smith05@imperial.ac.uk", "orcid_id": ""}], "doi_number": "10.1145/2535838.2535876", "year": "2014", "article_id": "2535876", "conference": "POPL", "title": "A trusted mechanised JavaSript specification", "url": "http://dl.acm.org/citation.cfm?id=2535876"}