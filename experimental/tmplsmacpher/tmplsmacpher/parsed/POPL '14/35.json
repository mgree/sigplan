{"article_publication_date": "01-08-2014", "fulltext": "\n Gradual Typing Embedded Securely in JavaScript Nikhil Swamy1 C\u00b4edric Fournet1 Aseem Rastogi2 Karthikeyan \nBhargavan3 Juan Chen1 Pierre-Yves Strub4 Gavin Bierman1 Microsoft Research1 University of Maryland2 INRIA3 \nIMDEA Software Institute4 {nswamy, fournet, juanchen, gmb}@microsoft.com, aseem@cs.umd.edu, karthikeyan.bhargavan@inria.fr, \npierre-yves@strub.nu Abstract JavaScript s .exible semantics makes writing correct code hard and writing \nsecure code extremely dif.cult. To address the former prob\u00adlem, various forms of gradual typing have \nbeen proposed, such as Closure and TypeScript. However, supporting all common pro\u00adgramming idioms is \nnot easy; for example, TypeScript deliberately gives up type soundness for programming convenience. In \nthis pa\u00adper, we propose a gradual type system and implementation tech\u00adniques that provide important safety \nand security guarantees. We present T S*, a gradual type system and source-to-source compiler for JavaScript. \nIn contrast to prior gradual type systems, T S* features full runtime re.ection over three kinds of types: \n(1) simple types for higher-order functions, recursive datatypes and dictionary-based extensible records; \n(2) the type any, for dynami\u00adcally type-safe T S* expressions; and (3) the type un, for untrusted, potentially \nmalicious JavaScript contexts in which T S* is embed\u00added. After type-checking, the compiler instruments \nthe program with various checks to ensure the type safety of T S* despite its interactions with arbitrary \nJavaScript contexts, which are free to use eval, stack walks, prototype customizations, and other offen\u00adsive \nfeatures. The proof of our main theorem employs a form of type-preserving compilation, wherein we prove \nall the runtime in\u00advariants of the translation of T S* to JavaScript by showing that translated programs \nare well-typed in JS*, a previously proposed dependently typed language for proving functional correctness \nof JavaScript programs. We describe a prototype compiler, a secure runtime, and sample applications for \nTS*. Our examples illustrate how web security pat\u00adterns that developers currently program in JavaScript \n(with much dif.culty and still with dubious results) can instead be programmed naturally in TS*, retaining \na .avor of idiomatic JavaScript, while providing strong safety guarantees by virtue of typing. Categories \nand Subject Descriptors D.3.1 [Programming Lan\u00adguages]: Formal De.nitions and Theory Semantics; D.4.6 \n[Op\u00aderating Systems]: Security and Protection Veri.cation. Keywords type systems; language-based security; \ncompilers Permission to make digital or hard copies of all or part of this work for personal or classroom \nuse is granted without fee provided that copies are not made or distributed for pro.t or commercial advantage \nand that copies bear this notice and the full citation on the .rst page. Copyrights for components of \nthis work owned by others than ACM must be honored. Abstracting with credit is permitted. To copy otherwise, \nor republish, to post on servers or to redistribute to lists, requires prior speci.c permission and/or \na fee. Request permissions from permissions@acm.org. POPL 14, January 22 24, 2014, San Diego, CA, USA. \nCopyright c &#38;#169; 2014 ACM 978-1-4503-2544-8/14/01. . . $15.00. http://dx.doi.org/10.1145/2535838.2535889 \n1. Introduction Writing secure JavaScript is notoriously dif.cult. Even simple functions, which appear \nsafe on the surface, can be easily broken. As an illustration, consider the script below, simpli.ed from \nac\u00adtual scripts in the ( ) and ( ), security-critical JavaScript libraries that aim to impose ac\u00adcess \ncontrols on the networking APIs provided by web browsers. f u n c t i o n s e n d ( u , m ) { / * S t \na n d -i n f o r X M L H t t p R e q u e s t * / } f u n c t i o n p r o t e c t ( s e n d ) { v a r \nw h i t e l i s t = { \" h t t p s : / / m i c r o s o f t . c o m / m a i l \" : t r u e , \" h t t p s \n: / / m i c r o s o f t . c o m / o w a \" : t r u e } ; r e t u r n f u n c t i o n ( u r l , m s g ) \n{ i f ( w h i t e l i s t [ u r l ] ) s e n d ( u r l , m s g ) ; } ; } s e n d = p r o t e c t ( s e \nn d ) ; The function call protect(send) on the last line returns a function that interposes an access \ncontrol check on send. If this script were to run in isolation, it would achieve its intended functionality. \nHow\u00adever, JavaScript programs rarely run in isolation programmers ex\u00adplicitly link their code with third-party \nframeworks, and, worse, un\u00adexpected code fragments can be injected into the web sandbox by cross-site \nscripting attacks. For example, the following script run\u00adning in the same sandbox as protect could succeed \nin sending a message to an unintended recipient. O b j e c t . p r o t o t y p e [ \" h t t p : / / e \nv i l . c o m \" ] = t r u e ; s e n d ( \" h t t p : / / e v i l . c o m \" , \" b y p a s s ! \" ) ; This \nis just one attack on protect; similar attacks are often the consequence of unintended callbacks to untrusted \ncode (caused, for example, by implicit coercions, getters or setters, prototype hack\u00ading, and global \nobject overwriting). Experimentally, we found and reported several such security .aws in the OWASP CSRFGuard \nand Facebook API scripts, suggesting that untrusted callbacks re\u00admain dif.cult both to prevent and to \ncontain. 1.1 Attacks Type Errors Arguably, each of these attacks can be blamed on JavaScript s lax notion \nof dynamic type-safety. Many runtime behaviors that are traditionally viewed as dynamic type er\u00adrors \n(e.g., accessing non-existent properties from an object) are not errors in JavaScript. However, almost \nany such error while running a sensitive script can be exploited by a malicious context, as fol\u00adlows. \nAnticipating that the script will dereference an otherwise un\u00adde.ned property x, which in JavaScript \nwould just return the value undefined, a hostile context can de.ne O b j e c t . d e f i n e P r o p \ne r t y ( O b j e c t . p r o t o t y p e , \" x \" , { g e t : f u n c t i o n ( ) { / * e x p l o i t \n* / } } ) ; then run the script and, as x is dereferenced and triggers the call\u00adback, access any argument \non the caller stack. Thus, for protecting good scripts from bad ones, silent type errors in JavaScript \nare just  OWASP CSRFGuard 2010 Facebook API 2013 OWASP CSRFGuard 2010 Facebook API 2013 Bhargavan et \nal. 2013 Chugh et al. 2012 Guarnieri and Livshits 2009 Guha et al. 2011 Hedin and Sabelfeld 2012 Swamy \net al. 2013 Taly et al. 2011 http://www.adsafe.org http://code.google.com/p/google-caja Politz et al. \n2011 Siek and Taha 2006 http://www.typescriptlang.org https://developers.google.com/closure/compiler \nBhargavan et al. 2013 Chugh et al. 2012 Guarnieri and Livshits 2009 Guha et al. 2011 Hedin and Sabelfeld \n2012 Swamy et al. 2013 Taly et al. 2011 http://www.adsafe.org http://code.google.com/p/google-caja Politz \net al. 2011 Siek and Taha 2006 http://www.typescriptlang.org https://developers.google.com/closure/compiler \nas dangerous as buffer overruns in C. Despite the numerous dy\u00adnamic checks performed by the JavaScript \nruntime, some stronger notion of type safety is called for. Other researchers have made similar observations. \nFor exam\u00adple, ( ) show several attacks on a similar piece of code and argue that carefully mediating \nthe interaction be\u00adtween a script and its context is essential for security. They show how to compile \nf*, a statically typed, ML-like source language to JavaScript in a fully abstract way, allowing programmers \nto write and reason about functions like protect in ML, and to let their com\u00adpiler generate secure JavaScript \nautomatically. This is an attractive design, but the sad truth is that millions of JavaScript program\u00admers \nare unlikely to switch to ML. Meanwhile, ( ) have developed DJS, a minimal, statically typed, secure \ncore of JavaScript, primarily for writing .rst-order, string-processing functions using arrays of .xed \nsize. DJS is suitable for writing security-critical code, like cryptographic libraries, and Bharga\u00advan \net al. prove that the behavior of programs accepted by the DJS type checker is independent of the JavaScript \nenvironment in which they may run. Many others propose analyses for sub\u00adsets of JavaScript ( ; ; ; ;; \n), although the guarantees provided only hold if the entire environment in which the program runs is \nalso in the subset in question. Efforts like AdSafe ( ) and Caja ( ) address the problem of safely loading \nuntrusted JavaScript into a program s environ\u00adment after analyzing and rewriting it. However, in order \nto do this reliably, various JavaScript features are forbidden, e.g., ( ) show that by ruling out many \ncommonly used JavaScript features (e.g., eval or explicit prototype manipulation), AdSafe can safely \nsandbox untrusted code. Although we .nd the work on JavaScript subsets a promising line to pursue (indeed, \neven the EC-MAScript standard is evolving towards the de.nition of subsets, such as the strict mode), \nassumptions about subsetting the environ\u00adment are hard to validate in the presence of cross-site scripts. \n1.2 T S*: a gradually type-safe language within JavaScript This paper presents T S*, a source programming \nlanguage that re\u00adtains many of the dynamic programming idioms of JavaScript, while ensuring type-safety \neven in an untrusted JavaScript environ\u00adment. T S* supports writing functions like protect exactly as \nshown, while a compiler from TS* to JavaScript ensures that the access control check in protect cannot \nbe subverted. Although signi.cantly more .exible than f* or DJS, TS* still rules out many inherently \nunsafe features of JavaScript for the code we protect, thereby enforcing a stricter programming disci\u00adpline \nand facilitating security code reviews. We intend T S* to be used to protect security-critical scripts \nguarding, for instance, sensitive resources and capabilities executed on web pages that also include \ndynamically loaded, untrusted, potentially malicious scripts. By necessity, most of the code running \non these pages is provided by third parties; we leave such code unchanged (and un\u00adprotected). Nonetheless, \nby lightly rewriting the security-critical scripts, and gradually typing them ( ), we en\u00adforce a strong \nnotion of dynamic type-safety. In addition, we protect our scripts using type-directed wrappers to shield \nthem from adversarial JavaScript environments. This places them on a robust type-safe foundation, from \nwhich we can reason about their security. In comparison, other gradually typed extensions to JavaScript, \nlike TypeScript ( ) and Closure ( ), aim pri\u00admarily to increase programmer productivity by using types \nfor doc\u00adumentation and code completion, but provide no safety guarantee. The concrete syntax of TS * \nextends JavaScript with a type\u00adannotation language based on TypeScript. Our implementation Fournet et \nal. 2013 Fournet et al. 2013 works by .rst using TypeScript to infer types for every sub-term. It then \nuses the inferred types to type-check the program once again, this time using a more restrictive type \nsystem. If this step is suc\u00ad cessful, the program is compiled to plain JavaScript (instrumented with \nvarious runtime checks to enforce type-safety) for execution. The T S * type system itself has the following \nprominent features: A statically typed core of functions, datatypes and records The base type system \nof TS* includes primitive types like bool, number and string; higher-order function types; recursive \ndatatypes; and extensible records of .elds with optional immutability annotations. Records are equipped \nwith a structural subtyping relation. For example, the type point de.ned below is a subtype of a record \nthat omits some of its .elds, and function subtyping is, as usual, contravariant on the arguments and \ncovariant on the results. { x : n u m b e r ; y : n u m b e r ; s e t X : c o n s t ( n u m b e r -> \nu n i t ) } Dynamically typed fragment The type any is for dynamically typed T S* expressions. All the \ntypes from the statically typed core are subtypes of any, and all T S* terms whose subterms all have \ntype any can always be given the type any. In the spirit of JavaScript, in the any-fragment, we view \nrecords as extensible dic\u00adtionaries with string-valued keys. T S* supports the use of computed properties, \ne.g., in any-typed code, expressions like p[\"set\"+\"X\"] or whitelist[url] are legal ways to safely project \nthe appropriate .eld from the underlying object, if it exists. Dynamically typed code and its interactions \nwith statically typed code are instrumented by our compiler for safety. As far as we are aware, ours \nis the .rst gradual type system to soundly support dictionary-based mutable records and computed properties. \nRuntime re.ection over types Case analysis on the runtime type of a value is a common idiom in JavaScript \nand other dynamically typed languages ( ) present several typical uses of JavaScript s typeof operator. \nTS* embraces this idiom and compiles programs with runtime type information (RTTI) to support intro\u00adspection \non all source types at runtime, e.g., isTag<point>p checks whether the RTTI of p is a structural subtype \nof point. In addition to providing an expressive source programming construct, RTTI also forms the basis \nof an ef.cient and simple enforcement mecha\u00adnism for gradual typing, an alternative to prior proposals \nbased on higher-order contracts ( ). un, the type of the adversary, mediated by wrappers Finally, and \nmost distinctively, T S* provides a second dynamic type, un. Any JavaScript term which cannot be typed \neither statically or dy\u00adnamically can be given the type un and simply passes through our compiler without \nfurther analysis or modi.cation. As such, un is the type of arbitrary, potentially adversarial JavaScript \nexpressions. Our un type is reminiscent of types for adversaries, as proposed by ( ). However, unlike \nprior uses of un in the context of secure compilers (e.g. ), un is a .rst-class type in T S*: un values \nmay be stored in records, used as arguments and results of functions, etc. The type un is incompara\u00adble \nto any in the subtyping relation and, in contrast with any, all operations on un values are mediated \nby wrappers that safely build coercions to and from un (as well as other types). The wrappers enforce \na strict heap separation between the un-context and typed T S*, ensuring that adversarial code cannot \nbreak type invariants. 1.3 Evaluating T S*: theory and practice We specify our com\u00adpiler as a type-directed \ntranslation relation (\u00a7 ). To formalize properties of the translated program, we give TS * a translation \nsemantics to J S *, a dependently typed model of JavaScript de\u00adveloped by ( ), which is in turn based \non . JS by ( ). Precise monadic re.nement types in J S * allow us to conveniently phrase our metatheory \n(\u00a7 ) in terms of type-correctness of J S*, yielding three main properties:  Guha et al. 2011 Findler \nand Felleisen 2002 Gordon and Jeffrey 2001 Fournet et al. 2013 Guha et al. 2011 Findler and Felleisen \n2002 Gordon and Jeffrey 2001 Fournet et al. 2013 3 Swamy et al. 2013 Guha et al. 2010 4 3 Swamy et al. \n2013 Guha et al. 2010 4 Memory isolation: un-typed code (i.e., the adversary) cannot di\u00ad rectly call, \nread, write, or tamper with typed values. Static safety: statically typed code is safely compiled without \nany runtime checks, even in the presence of type-changing updates. Dynamic safety: runtime type information \nis sound and at least as precise as the static type. Experimentally, we evaluate T S* by programming \nand adapting several security-sensitive JavaScript web libraries (\u00a7 ). Our exam\u00ad ples include a OWASP \nreference library to protect against cross-site request forgeries (CSRF) ( ); and an adaptation of secure \nlogin and JSON-validation scripts within the Facebook API. In summary, our main contributions include: \n(1) a type system and runtime support for safely composing stati\u00ad cally typed, dynamically typed, and \narbitrary JavaScript; (\u00a7 ) (2) a type safety theorem and its proof by translation to JS *; (\u00a7 ) (3) a \nprototype implementation, including a protocol to ensure that our runtime support runs .rst on pages \nhosting compiled T S* , and securely initializes our type invariant; (\u00a7 ) (4) security applications, \nillustrating a series of authorization and access control patterns taken from popular security-sensitive \nweb applications and libraries, motivated by new attacks. (\u00a7 ) As such, T S* is the .rst system to provide \na notion of type safety useful for secure programming, while handling all of JavaScript. The latest version \nof our compiler, programming examples, at\u00ad tacks, sample web-application deployments, and a technical \nre\u00ad port with the full formalization and proofs are all available from . 2. An overview of T S* We begin \nby presenting the design of T S * informally, using sev\u00ad eral small examples for illustration. We use \nthe concrete syntax of TypeScript with minor simpli.cations; for instance we write func\u00ad tion types as \nt -> t rather than TypeScript s (x:t) => t . We also extend the syntax of TypeScript with datatype declarations \nand im\u00ad mutability quali.ers. 2.1 Gradually securing programs by moving from un to any While we envisage \nT S* as the basis of a full-.edged gradually typed web-programming language, we initially consider JavaScript \npro\u00ad grammers willing to harden safety-and security-critical fragments of their code. They can start \nby giving their existing JavaScript code the type un in T S*, and then gradually migrating selected fragments \nto (dynamically) type-safe code in T S* using the type any. This exercise is valuable since any code \nin TS* enjoys a memory isolation property, a robust foundation upon which to build secure sub-systems \nof a larger program. Memory isolation alone prevents many common attacks. For example, the prototype \npoisoning attack of \u00a7 occurs because of a failure of memory isolation: the com\u00ad mand whitelist[url] causes \na prototype-chain traversal that ends with reading a .eld of Object.prototype which, unfortunately, is \na reference to an object controlled by the adversary. Passing protect (unchanged) through the TS* compiler \nwhile giving whitelist the type any produces an instrumented version of protect with checks to prevent \nany property dereferences from whitelist from accessing Object.prototype (or any other un object), thereby \nfoiling the attack. Speci.cally, from memory isolation, we can prove that every deref\u00ad erence of a .eld \nof any object in T S * will only read the immediate .elds of that object, and will never access a prototype \ncontrolled by the adversary. This ensures that whitelist[url] returns true only if url is immediately \nde.ned in whitelist. Undecorated T S * programs can generally be given the type any (as long as they \nare well-scoped). Every function parameter in an 1 6 Barth et al. 2008 3 4 Fournet et al. 2013 5 6 http://research.microsoft.com/fstar \n1 6 Barth et al. 2008 3 4 Fournet et al. 2013 5 6 http://research.microsoft.com/fstar 2.3 5 1 2.3 5 1 \nunannotated T S* program defaults to the type any; every var-bound variable is given the type of its \ninitializer. Under this convention, in the program from \u00a7 , the type of protect is any -> (any,any)-> \nany, which is a subtype of any. When deploying a TS* program, we assume that the JavaScript global object \n(the window object in most browsers) and all objects reachable from it are under control of the attacker. \nThus, it is not safe to simply store protect(send) into window.send, since that would break memory isolation \nand leak a value of type any to un-safe code our type system prevents the programmer from doing this \nby mistake. Instead, T S* provides wrappers to safely export values to the context. The TS* expression \nwrap<un>(protect(send)) wraps the protect(send) closure and yields a value of type un, indicating that \nit is safe to hand to any JavaScript context while preserving mem\u00adory isolation. Dually, for e:un, the \nexpression wrap<any>(e) safely imports e from the context and gives it the type any. Providing a JavaScript \nimplementation of wrap is non-trivial. We base our implementation on wrappers de.ned by ( ). Their wrappers \nare designed to safely export statically typed values from the translation of an f* program (roughly, \na sim\u00adply typed subset of ML) to its JavaScript context; and to import untyped values from the context \ninto f* at speci.c types. For ex\u00adample, Fournet et al. s down(t*u) exports a pair of translated f* val\u00adues \n(v1,v2) of type (t * u) to the context, by building a new object with two .elds initialized to downt \n(v1) and downu(v2). A correspond\u00ading wrapper up(t*u) does the converse, safely copying a pair from the \ncontext and building a value that is the translation of an f* pair of type (t * u). Fournet et al. provide \nupt and downt wrappers for types t including unit, bool, string, number, pairs, recursive datatypes, \nand functions. We extend their constructions to additionally build wrappers to and from the type any, \nand to handle cyclic data struc\u00adtures that can be constructed using records with mutable .elds. To illustrate \nwrappers in action, we elaborate on our .rst ex\u00adample. Suppose we wished to protect window.send (a .ctitious \nbut simpler stand-in for JavaScript s XMLHttpRequest object) with an ac\u00adcess control check. To support \nthis, the standard library of T S* pro\u00advides a facility to read .elds from, and write .elds to, the global \nobject by including the following safe interface to the window ob\u00adject implemented in JavaScript. The \nwin object, whose interface is shown partially below, shadows the .elds of the window object, safely \nreading and writing it within a wrapper to ensure that the attacker-controlled window does not break \ntype safety. Using win within a T S* program, we can safely import window.send, protect it, and export \nit back to the context using the following snippet of code, typed in a context where the win object has \nmutable un-typed .elds. Of course, the attacker may a priori obtain a copy, and even rede.ne window.send \nbefore our code has the chance to protect and update it, but this is an orthogonal problem, solved once \nfor all T S* programs \u00a7 and \u00a7 present our mechanisms to ensure that our scripts run .rst on a web page. \ni n t e r f a c e w i n { s e n d : u n ; . . . } w i n . s e n d = w r a p < u n > ( p r o t e c t ( \nw r a p < a n y > ( w i n . s e n d ) ) ) ; Wrappers are expensive, since they deeply copy the contents \nof objects back and forth, and by design they are not necessarily semantics-preserving. (For instance, \nthey sanitize values, .lter out some properties, and prevent some aliasing.) Thus, in an attempt to minimize \nthe amount of copying, we may rewrite protect, by adding a few types, as shown below. f u n c t i o n \np r o t e c t ( s e n d : ( s t r i n g , u n ) -> u n ) { v a r w h i t e l i s t = { \" h t t p : / \n/ m i c r o s o f t . c o m / m a i l \" : t r u e , \" h t t p : / / m i c r o s o f t . c o m / o w a \n\" : t r u e } ; r e t u r n f u n c t i o n ( u r l : s t r i n g , m s g : u n ) { i f ( w h i t e l \ni s t [ u r l ] ) s e n d ( u r l , m s g ) ; } ; } ; win . send = w r a p < u n > ( p r o t e c t ( \nw r a p < ( s t r i n g , u n ) -> u n > ( w i n . s e n d ) ) ) ;  Intuitively, the msg argument in \nthe closure returned by protect is treated abstractly, that is, our script does not directly access it. \nThus, there is no need to import that argument from the context (potentially performing a deep copy). \nOn the other hand, the url argument is not abstract it is used to project a .eld from the whitelist, \nand, as such, it had better be a string. The type system of TS * gives us the .exibility to express exactly \nwhat should be imported from the context, helping us .nd a good balance between security and performance. \nThe explicit use of un and wrap are advances of T S * relative to prior languages such as f* or, for \nthat matter, any prior gradually typed programming language. 2.2 Expressing invariants with assertions \nover runtime types As can be expected of gradual typing, a T S * program migrated from un to any can \nthen, with some effort, be made increasingly statically typed. Static types can improve runtime safety, \nrobustness of code, modularity, as well as provide better IDE support. Static types in T S * also improve \nperformance relative to any-typed code and, relying on RTTI, can enforce data invariants. This is enabled \nby static safety and dynamic safety, two properties (in addition to memory isolation) provided by T S* \n. Static safety T S* ensures that, at runtime, no failures happen during the execution of statically \ntyped parts of the source program. Since there are no runtime checks in the compiled JavaScript for such \nparts, as a bonus, the performance of statically typed T S * code will approach that of native JavaScript \n(and potentially exceed it, if the type information can be communicated to the VM). Dynamic safety Every \nT S* value v : t (where t= un) is compiled to JavaScript with runtime type information (RTTI) that initially \nre.ects v s static type t. T S* ensures that, while v s RTTI may evolve during execution (e.g., as .elds \nare added to an extensible record), it is always (a) a subtype of v s static type t, and (b) a sound \napproximation (supertype) of v s most-precise current type, i.e., the RTTI of v may evolve only monotonically \nwith respect to the subtyping relation. We call this property dynamic safety. As an illustration, consider \nthe example below, which codes up a lightweight form of objects with extensible records and closures \nin T S *, where point is the type de.ned in \u00a7 . f u n c t i o n P o i n t ( x , y ) { var self = {}; \nself .x=x; self .y=y; s e l f . s e t X = f u n c t i o n ( d : n u m b e r ) { s e l f . x = d ; } ; \nr e t u r n s e t T a g < p o i n t > ( s e l f ) ; } The function Point creates a new point. It allocates \na new empty record and stores it in the local variable self, then it adds three .elds x, y, and setX. \nThe static type of self is just the empty record. However, T S* allows us to add more .elds to self than \nthose documented in its static type. As such, the static type of a record only describes a subset of \nthe .elds in the term, as is usual with width-subtyping. Deleting .elds from records is also possible \nwe discuss this in more detail in \u00a7 . In the last line of Point, setTag<point>(self) checks at runtime \nif the content of self is compatible with the point type, and fails oth\u00aderwise. The term setTag<point>(self) \nhas static type point, although the static type of self remains unchanged. Assertions like setTag allow \nsource programmers to safely up\u00addate RTTI while maintaining the runtime type invariant. Once a value \nhas been tagged as a point, then it is guaranteed to always remain a point. A programmer may choose to \nadd .elds to a point, or to further update its type information (e.g., turning it into a coloredPoint), \nbut it will always contain at least the .elds of a point. Any attempt to delete, say, the x .eld, or \nto change it in a type\u00adincompatible way (using for instance a dynamically typed alias to the point) will \ncause a runtime error. 1 1 1 1 1 3 5 http://davidwalsh.name/json-validation http://tools.ietf.org/html/draft-zyp-json-schema-03 \n3 5 http://davidwalsh.name/json-validation http://tools.ietf.org/html/draft-zyp-json-schema-03 In contrast, \nstatically typed code raises no such errors. T S* infers that function Point has type (any,any)-> point, \nso the code below is statically type safe and does not require any runtime checks. v a r o = P o i n \nt ( 0 , 0 ) ; o . s e t X ( 1 7 ) ; As another example, consider that popular web frameworks, like Dojo, \nprovide implementations of the JSON Schema standard. This allows programmers to validate JSON data, writing \nverbose schemas for them also as JSON objects. In T S*, data invariants can be expressed and enforced \ndirectly using types, rather than via schemas. For example, to check that a JSON string can be parsed \ninto an array of user identities, we can write the T S* code below, assuming that JSON.parse has type \nstring -> any. (See online materials for a T S* implementation of a JSON parser.) t y p e u s e r s = \n{ i d : n u m b e r ; u s e r : s t r i n g } [ ] f u n c t i o n c h e c k ( j : s t r i n g ) : u s \ne r s { v a r o = J S O N . p a r s e ( j ) ; i f ( c a n T a g < u s e r s > ( o ) ) r e t u r n s e \nt T a g < u s e r s > ( o ) ; else return []; } The schema is captured by the type users. We parse a \nstring j as JSON using JSON.parse, then use the T S* operator canTag<t>(o) to check that o s contents \nare consistent with t. If the check succeeds, we stamp o as a valid users object and return it. 2.3 Reliable \nprimitive operations Since the global window ob\u00adject is shared with the adversary, all objects reachable \nfrom window may be compromised. This includes all built-in objects provided by the VM, e.g., Object.prototype, \nArray.prototype, the default String object, and others. In order to ensure memory isolation, translated \nT S* programs should never read from any of those objects. This is remarkably dif.cult to arrange in \nJavaScript, since several primitive operations, e.g., reading and writing .elds, depend on base proto\u00adtypes, \nas illustrated in \u00a7 . Thus, in the face of attacker-controlled prototypes, even simple manipulations \nof objects are unreliable. Thankfully, there is a relatively simple way out. JavaScript (since ECMAScript \n5) provides a function Object.create, such that Object.create(arg) creates a new object with its prototype \n.eld initialized to arg. As a special case, Object.create(null) creates an object with a null prototype, \nmeaning that the created object does not inherit the attacker-controlled Object.prototype. Our compiler \nuses Object.create(null) to create new objects in the translation of a T S* program, allowing manipulations \nof object .elds simply as o.f=v or o[\"f\"]=v, without worrying that a traversal of o s prototype chain \nwill reach an attacker-controlled object. There is one exception, however. Function objects cannot be \nallocated using Object.create they must inherit from the attacker\u00adcontrolled Function.prototype. However, \nby an invariant of the translation, we can ensure that the only .eld ever accessed of a non-un-typed \nfunction f is rtti . So, as long as Function.prototype contains a safe, immutable rtti .eld, accessing \nf.rtti will never trigger adversarial code. The correctness of our translation then requires a reliable \nway to call Object.create(null) and to initialize Function.prototype.rtti. To achieve this, compiled \nT S* programs are linked with a library called boot.js. This library is intended to be the .rst piece \nof JavaScript that runs on a page \u00a7 discusses how to make a script run .rst, reliably, before any adversarial \nscript. boot.js takes a clean copy of Object.create and stores it in an immutable .eld. Later, the translated \nTS* code accesses Object.create from this .eld, rather than as window.Object.create, which is an attacker-controlled \npath. We show a fragment of boot.js below, simpli.ed slightly to use 1 1 Based on . 2  .eld names such \nas rtti, instead of the longer names (less likely to clash with source code) used in our implementation. \n1 f u n c t i o n b o o t ( ) { 2 v a r C l e a n = O b j e c t . c r e a t e ( n u l l ) ; 3 C l e a \nn . c r e a t e = O b j e c t . c r e a t e ; 4 C l e a n . i s T a g = f u n c t i o n ( t , s , x ) \n{ . . . } ; . . . 5 C l e a n . w r a p = f u n c t i o n ( t , s , x ) { . . . } ; 6 O b j e c t . f \nr e e z e ( C l e a n ) ; 7 O b j e c t . d e f i n e P r o p e r t y ( F u n c t i o n . p r o t o t \ny p e , \" r t t i \" , 8 { v a l u e : n u l l , w r i t a b l e : f a l s e , c o n f i g u r a b l e \n: f a l s e } ) ; 9 O b j e c t . d e f i n e P r o p e r t y ( w i n d o w , \" C l e a n \" , 10 { v \na l u e : C l e a n , w r i t a b l e : f a l s e , c o n f i g u r a b l e : f a l s e } ) ; 11 } ; \n12 b o o t ( ) ; b o o t = u n d e f i n e d ; The listing above de.nes a function boot that is run once \nand then discarded. Within the scope of the function, we construct a Clean object in which to maintain \npristine copies of functions like Object.create, on which our translation relies. Lines de\u00ad .ne functions \nthat implement queries and coercions on runtime types and values we discuss their implementation in detail \nin \u00a7 . Line calls the JavaScript function freeze, to make Clean im\u00ad mutable. Line initializes Function.prototype.rtti \nand line regis\u00ad ters the Clean object at the path window.Clean both use JavaScript s defineProperty, \nto de.ne immutable, non-con.gurable properties. 2.4 Embedding TS* in JavaScript The Clean object in boot.js \nprovides trusted core functionality upon which we can build a se\u00ad cure compiler. In this section, we \noutline the end-to-end embedding within JavaScript of the Point example from \u00a7 . There are a few broad \nfeatures of the translation that we focus on: Adding runtime-type information to every object and function. \nChecking runtime type information in the any fragment. Embedding wrappers to safely export/import values. \nThe listing below shows the translation of the T S* function Point to JavaScript. The translated code \nis placed within a single enclosing function to introduce a fresh local scope. Without this precaution, \nT S* de.nitions would implicitly leak into the global un-typed ob\u00ad ject. The type annotations in T S* \nare all erased in JavaScript. 1 function () { 2 v a r P o i n t = f u n c t i o n ( x , y ) { 3 v a r \ns e l f = C l e a n . c r e a t e ( n u l l ) ; 4 self . rtti = (|{}|); 5 writ e( s e l f , \" x \" , x \n) ; 6 writ e( s e l f , \" y \" , y ) ; 7 v a r t m p = f u n c t i o n ( d ) {writ e( s e l f , \" x \" \n, d ) ; } 8 t m p . r t t i = (|number . unit|); 9 writ e( s e l f , \" s e t X \" , t m p ) ; 10 r e t \nu r n C l e a n . s e t T a g ( (|{}|),(|point|), s e l f ) ; 11 } 12 P o i n t . r t t i = (|(any,any) \n. point|); 13 v a r o = P o i n t ( 0 , 0 ) ; 14 o.setX (17); 15 } ( ) Line : the source empty record \n{} is compiled to a new null\u00ad prototype object. Line : we set the rtti .eld of self to the transla\u00ad tion \nof a source empty record type. Lines and : we use the macro write to add two properties to the self object. \nThis macro (de.ned in \u00a7 ) checks that the RTTI of the assigned .eld (if any) is compat\u00ad ible with the \nRTTI of the assignee. In this case, since the rtti .eld of self is just the empty record, it does not \nconstrain the contents of any of its .elds, so these assignments succeed and the .elds are added to self. \nLine : we translate setX and, line : we tag it with an rtti .eld recording its source type. We then add \nit to self using write. Line : the call to Clean.setTag checks whether self, whose static type is represented \nby (|{}|), contains a valid representation of a source point. For this, it examines the representation \nof the type (|point|); notice that the type requires three .elds, x, y, and setX; 4 5 3 6 7 9 12 13 14 \n2.2 14 4 5 3 6 7 9 12 13 14 2.2 14 3 4 5 6 3 7 8 10 1 3 4 5 6 3 7 8 10 Value v ::= x | true | false \n| . x:t.e | D v E x pr. e ::= v | { f = e} | e. f | e. f = e' | e[e'] | e[e'] = e'' | let x = e in e' \n| e e' | D e | if e then e' else e'' | q(t)e | c(t)e Query q ::= isTag | canTag | canWrap Coercion c \n::= setTag | wrap Ty pe t,u ::= bool | T | any | un | t . u | { f\u00af : \u00aft} a \u00afAccess a ::= r | w Sig. S \n::= . | D:t . T | S,S' E nv. G ::= . | x:t | G,G' Figure 1. Formal syntax of TS * then it checks that \nthe self object contains values in those three .elds whose RTTIs are compatible with the requested types \nnumber, number, and number -> unit, respectively. Once this check succeeds, setTag updates the rtti .eld \nof self to (|point|). An invariant of our translation is that the rtti .eld of every object evolves monotoni\u00adcally \nwith respect to the subtyping relation. That is, self.rtti was initially (|{}|) and evolves to (|point|), \nwhere point <: {}. The RTTI of self may evolve further, but it is guaranteed to always remain a subtype \nof point. Line : we add an rtti .eld to the Point. Finally, lines and : we see the translation of a statically \ntyped fragment of T S*. Pleasantly, the translation there is just the identity. As shown, the translated \nprogram does not interact with its con\u00adtext at all. However, the programmer can choose to export certain \nvalues to the context by writing export function Point(x,y){. . .} in\u00adstead. This instructs the compiler \nto wrap and export Point to the context by inserting the following code after Line . w i n . P o i n \nt = C l e a n . w r a p ( (|(any,any) . point|), (|un|), P o i n t ) ; 3. Formalizing T S* This section \nformalizes T S* by presenting its type system and type\u00addirected translation to JavaScript. We describe \nin particular our runtime representation of types and the JavaScript implementations of Q.wrap, Q.setTag \nand related functions that manipulate translated terms and their types. We conclude this section with \na detailed comparison of T S* with prior gradual type systems. 3.1 Syntax Figure presents our source \nsyntax. To aid in the readability of the formalization, we employ compact, . -calculus style notation, \nwriting for example . x:t.e instead of function(x:t) {return e;}. We also write e for a sequence of expressions \ne1, . . . , en, f (e) for the application f (e1, . . . , en), and so on. Our formal syntax does not cover \nthe un-typed fragment, since its typing and com\u00adpilation are both trivial, although, of course, our theorems \nspeci.\u00adcally address the composition of compiled T S* code with arbitrary JavaScript. Values v include \nvariables x, Booleans, typed . -abstractions, and data constructors D applied to a sequence of values. \nFor con\u00adciseness, we exclude primitives like numbers and strings, since they can in principle be encoded \nusing data constructors. In practice, our implementation supports JavaScript primitives, and so we use \nthem in our examples. This requires some care, however, since some op\u00aderations on primitive types can \nbe overwritten by the adversary. In such cases, we cache reliable versions of those primitive operations \nin the Clean object built by boot.js In addition to values, expressions e include record literals, pro\u00adjections \nof static .elds, and assignments to static .elds. We also in\u00adclude projections of computed .elds e[e'] \nand assignment to com\u00adputed .elds e[e'] = e''. It is important to note that records, even records of \nvalues, are not values, as in JavaScript evaluating a record returns the heap location where the record \nvalue is stored. We have let-bindings (corresponding to immutable var bindings in our concrete syntax); \nfunction application; data constructor appli\u00ad  1 G f e : u s S f u <: t G f e\u00af: t\u00af s\u00af{ f\u00af :a\u00aft\u00af} = \nt l u S f unFree(t)(T-SU B ) (T-X) (T-REC )G f e : t s G f e : t s G f x : G(x) x G f { f = e} : u record( \nf :s,u) ' S(D) = t . T G f e : t s G,x:t f e : t ' s G f e : u l { f :w t} s G f e ' : t s (T-D) (T-LA \nM ) (T-WR) ' G f D e : T data(D,s\u00af, T ) G f . x:t.e : t . t ' fun(x,e,s,t . t ' ) G f e. f = e ' : t \ns. f = s ' ' G f e:u l { f :a t} s G f e : t1 . t2 s G f e ' : t1 s G f e : u s G, x:u f e ' : t s (T-RD) \n(T-AP P ) (T-LE T ) ' G f e. f : t s. f G f e e ' : t2 s s G f let x = e in e ' : t (x = s,s ' ) G f \ne : any s .i.G f ei : t si G f e : t ' s t ' ~ t G f e : t ' s t ' ~ t (T-IF) (T-Q) (A-C) G f if e then \ne1 else e2 : t if (s) {s1} else {s2} G f q(t)e : bool Clean.q((|t ' |),(|t|),s) G f c(t)e : t Clean.c((|t \n' |),(|t|),s) .i.G f ei : any si .i.G f ei : any si .i.G f ei : any si (A-AP P ) (A-RD) (A-WR) G f e1 \ne2 : any apply(s1, s2) G f e1[e2] : any read(s1,s2) G f e1[e2] = e3 : any write(s1,s2,s3) S f t <: t \n'' S f t '' ' <: t ' S f t ' <: t S f u <: u S f t <: t ' S f unFree(t) S f unFree(t) ' S f t <: t ' \nS f t <: t S f t <: t ' S f t . u <: t ' . u S f { f :r t} l u <: { f :r t ' } l u S f t <: any S f t \nl u <: u .D:t\u00af. T . S[T ].S f unFree(t\u00af) .i.S f unFree(ti) S f unFree(t\u00af) S f unFree(t) a \u00af S f unFree(bool) \nS f unFree(any) S f unFree(T ) S f unFree(t1 . t2) S f unFree({ f\u00af : \u00aft}) ' t ' ~ t t ~ t ' ' .elds(u0) \nn .elds(u1) = 0/. j.a j = a j . tj ~ t ' j u ~ u ' a ' \u00af t ~ t ' t ~ t t ~ t ' any ~ t un ~ t t . t \n~ t ' . u { f\u00af :a\u00aft\u00af} l u0 ~ { f\u00af : t\u00af' } l u1 where let x = s in s ' function(x){return s ' ;}(s) record( \nf : s,t) = let x=Clean.create(null) in (x. f =s, x.rtti=(|t|)) data(D,s, T ) = let x=Clean.create(null) \nin (x[i]=s, x.c=(|D|), x.rtti=(|T |), x) fun(x, e,s,t . t ' ) = let f=function(x){var locals(e); return \ns;} in (f.rtti=(|t . t ' |), f) apply(s1,s2) = let f=s1 in let x=s2 in typeof(x)===\"function\" ? f(Clean.setTag((|any|), \nf.rtti.arg,x)) : Clean.die() read(s1,s2) = let x=s1 in let f=s2 in typeof(x)===\"object\" &#38;&#38; Clean.hasField(x,f) \n? x[f] : Clean.die() write(s1,s2,s3) = let x=s1 in let f=s2 in let v=s3 in let t = typeof(x)===\"object\" \n? x.rtti : Clean.die() in Clean.mutable(t, f) ? x[f]=Clean.setTag((|any|), Clean.hasField(t,f) ? t[f] \n: Clean.Any(v) : Clean.die() (|any|) = Clean.Any (|t . t ' |) = Clean.arrow((|t|), (|t ' |)) (|un|) = \nClean.Un (|T |) = Clean.data(\"T\") (|{ f :a t}|) = let o = Clean.rec()in Clean.addField(o, f, (|t|), a===\"w\") \nFigure 2. A type-directed translation of T S* to JavaScript cation; and conditionals. Finally, we have \nRTTI-based query oper\u00adations q(t)e, and coercions c(t)e. Types t,u include a number of primitive types \n(bool for boolean values, and any and un for dynamic values), abstract data types ranged over by T , \nand records. Record types are written using the shorthand { f\u00af :a\u00aft\u00af} to denote the type { f1 :a1 t1, \n. . . , fn :an tn} where the fi are distinct and the ai are accessibility annotations: r for read\u00adonly, \nand w for mutable. We also write t l u for the record type { f\u00af 1 :a\u00af1 t\u00af 1, f\u00af 2 :a\u00af2 t\u00af2}, where t \n= { f\u00af 1 :a\u00af1 t\u00af 1} and u = { f\u00af 2 :a\u00af2 t\u00af 2}. The type system is given with respect to a signature S \nwhich maps data constructors D to their type signature, written t . T . In places we need to refer to \nall the data constructors for a given abstract data type T in the signature S. We use the shorthand S[T \n] which is de.ned as {D : t . T | S(D) = t . T }. We also have a standard type environment G binding \nvariables to their types. Although we have data constructors, pattern matching in TS* is not primitive. \nInstead, it can be encoded in terms of the other constructs, as de.ned below. Note that we freely use \n&#38;&#38; and other Boolean operators, as well as ===, physical equality on T S* values. match e with \nDt\u00af.T x . e1 else e2 let y = e in if (isTag(T )y &#38;&#38; y.c === \"D\") then let x = y[i] in e1 else \ne2 3.2 Type system and translation Figure de.nes the judgment G f e : t s, which states that in an environment \nG (along with an implicit signature S), the expression e can be given the type t 2 2 decorated AST produced \nby the type inference algorithm of Type-Script, so implementing the system in Figure is straightforward. \n(A precise description of this type inference algorithm is beyond the scope of this paper.) At a high \nlevel, the type system is designed to enforce the following three properties mentioned in \u00a7 : Static \nsafety T S* programs have no failing dynamic checks during the execution of statically typed sub-terms. \nWe achieve this via two mechanisms: (a) the rules pre.xed by (T-) enforce the static typing discipline \nand they never insert any runtime checks when compil\u00ad ing the program; (b) when a value v:any is passed \nto a context that expects a precise type, e.g. point, the compiler inserts instrumen\u00ad tation to ensure \nthat v is indeed at least a point. Instrumentation inserted elsewhere in dynamic code also ensures that \nv henceforth remains at least a point. This protects statically typed code from future modi.cations to \nv. In the other direction, the type system allows for v :point to be passed to any-typed context via \nsubtyping. Dynamic safety The RTTI of v:t is always a subtype of t and a sound approximation of v s most \nprecise type by two mecha\u00ad nisms: (a) v s RTTI initially re.ects t and the setTag operation en\u00ad sures \nthat RTTI always evolves towards the more precise types per subtyping, and (b) the rules pre.xed by (A-) \ninstrument the transla\u00ad tion of the any-typed parts of the source to enforce that modi.ca\u00ad tions to v \nrespect its RTTI. (We envision that an IDE can highlight uses of (A-) rules to the programmer as potential \nfailure points.) 2 2 and be translated to the JavaScript program s. We present the type Memory isolation \nun-typed code cannot directly access an object system declaratively. In practice, our type checker analyzes \na fully reference that T S* code may dereference; this is enforced by ensur\u00ad ing that the un type is \ntreated abstractly. The only way to manipu\u00ad late un values is via defensive wrappers, which means that \ntyped code never dereferences an un-typed memory location, and that any-typed references are never be \nhanded directly to the adversary. The subtyping rules are designed to prevent masking the presence of \nun-values in records using width-subtyping or subtyping to any. We now turn to describing each of the \nrules in detail. The .rst rule in the judgment, (T-SU B ), is a subsumption form which shows that a use \nof subtyping in T S * does not change the translation of a term. The subtyping relation S f t <: t ' \n(also in Figure ) is mostly standard. Depth subtyping on records is permitted only for immutable .elds. \nThe penultimate rule allows all types that do not contain the un type to be a subtype of any. (The auxiliary \npredicate unFree detects occurrences of un in a type.) Allowing un <: any would clearly break our invariants. \nAllowing {f:un} <: any is also problematic, since if a value v:{f:un} could be promoted to v:any, then \nv[\"f\"] would also have type any, even though it produces an untrusted value. The last subtyping rule \nprovides width-subtyping on records, forgetting the .elds to weaken t l u to u, only so long as t contains \nno occurrences of un. The rule (T-X) for typing variables is standard. (T-RE C ) introduces a record \nat type u, such that u includes all the un-.elds (necessary for compatibility with subtyping). Its compilation \nallocates a new object, safely sets the .elds f\u00af to s\u00af, and .nally adds an rtti .eld containing (|u|). \nThe rule (T-D) for typing data constructors is simi\u00ad lar. The typing of functions with (T-LA M ) is standard; \nhowever, the translation to JavaScript is a bit subtle: it de.nes a JavaScript func\u00ad tion tagged with \nan rtti .eld, whose body s is preceded by decla\u00ad rations of all the let-bound variables in e, the source \nfunction body. These (and other) rules use the JavaScript form (e), which evaluates every ei in e and \nreturns the last one. The rules (T-WR), (T-RD), and (T-APP ) are standard. One slight wrinkle in (T-IF) \nis that we rely on JavaScript implicitly converting u to a boolean this implicit conversion is a safe \nprimitive operation. One could imagine a stricter variant of (T-IF) with a runtime check to ensure that \nu is a boolean, without applying implicit conversions. However, (T-IF) as shown is more idiomatic of \nJavaScript. On the other hand, our treatment of local variables in (T-LE T) deviates from JavaScript \ns var-statements local variables are always immutable in T S*. We make this choice since mutability, \nif desired, can be encoded by boxing the let-bound value in a mutable record .eld. In contrast, encoding \nimmutable local variables given only mutable ones is impossible (even with immutable record .elds). The \nrules (T-Q) and (A-C) cover queries q(t)e and coercions c(t)e. In each case, we have an expression e:t \n' compiled to s, and we apply q or c at type t, so long as t and t ' are compatible. Type compatibil\u00ad \nity is a simple re.exive, symmetric, and non-transitive relation, in the spirit of ( ). We discuss the \nimplementation of these operations in the next subsection. The remaining (A-) rules instrument the translated \nprograms to ensure safety. In (A-AP P ), we .rst check that s is a function. Then, before calling the \nfunction, we tag the argument with the type of the function s parameter. (A-RD) simply checks that s1 \nis an object and that s1 has .eld s2. (A-WR) checks that s1 is an object. It then checks that s1 s RTTI \nallows for .eld s2 to be written. If s1 s RTTI does not contain s2, it is treated as a new property addition \ndeleting a property if it is not present in the RTTI is also straightforward, although we do not cover \nit here. Otherwise, it should contain a mutable s2 .eld, and before writing, s3 is tagged with the type \nexpected by s1 s RTTI. 3.3 Implementing RTTI-based coercions and wrappers As described in \u00a7 , runtime \nsupport for compiled TS * programs is provided by the immutable Clean object installed in the global \nnamespace by the .rst-starter script boot.js. This section discusses in detail the setTag and wrap operations \nprovided by the runtime. 2 11 21 7 4 3 2 Siek and Taha 2006 7 8 2 11 21 7 4 3 2 Siek and Taha 2006 7 \n8 Updating RTTI with setTag The form setTag(t)(e:t ' ) is compiled to Clean.setTag((|t ' |),(|t|),s), \nwhere e compiles to s. In this case, the .rst argument (|t ' |) is redundant, since it can be recovered \nfrom the RTTI of s (which, by dynamic safety, must be a re.nement of t ') we keep the .rst argument for \nuniformity with wrappers, as discussed below. The call Clean.setTag((|t ' |),(|t|),s) boils down to setTagAux(s,(|t|),false), \nwhose implementation is shown in Figure (on the left). This code tries to update the RTTI of s to be \nsome sub\u00adtype of (|t|) and fails otherwise. There are two main concerns that the code addresses: (1) \nthe code should not diverge if s is a cyclic data structure (unless die is called); (2) if the tag of \ns is updated, then s must represent a value of type t and the new tag must be a subtype of both the old \ntag and t. These two concerns are com\u00adplementary, since certain types (e.g., non-recursive types or types \nwithout mutable .elds) speci.cally require all their values to be acyclic. The main idea of setTagAux(x,t,b) \nis to traverse the objects reachable from x in a depth-.rst manner, at each point checking that each \n.eld required by t is present in the object at the expected type (lines and ). Each object encountered \nin the traversal is temporarily marked (line ) as visited by assigning meet(curTag,t) to x.tmp. The assigned \nvalue is the greatest subtype of both curTag and t (which may not exist, in which case the operation \nfails by calling die). Cycles are only permissible when traversing mutable object references and cycles \nare detected by looking for a marker in x.tmp. If the traversal succeeds, the temporary marker is made \nper\u00admanent by updating x.rtti (line ); if it fails, a fatal error is raised by calling die, which exhausts \nthe JavaScript stack. This is drastic but effective; friendlier failure modes are feasible too. Coercions \nbased on setTag can be overly conservative, particu\u00adlarly on higher-order values. For example, trying \nto coerce the iden\u00adtity function id : any -> any to the type bool -> bool using setTag will fail, since \nany <: bool. As such, RTTI-based coercions are most effective when working with mutable .rst-order objects. \nOne way to broaden the scope of RTTI-based coercions is, of course, to en\u00adrich the type language, e.g., \nto include polymorphism, or even re\u00ad.nement types we plan to explore this in the future. Additionally, \nwe provide operations to query RTTI, isTag(t)e and canTag(t)e, that (respectively) allow programmers \nto query the current tag of e and to test whether or not a setTag operation on e would succeed. When \nRTTI-based coercions are inapplicable (e.g., on un-typed values) or overly conservative (e.g., on functions), \nthe wrap form is handy we describe it next. Wrappers When e:t ' compiles to s, wrap(t)(e:t ' ) compiles \nto Clean.wrap((|t|),(|t ' |),s) Figure shows part of its implementation (on the right). Line is the case \nwhere both (|t|) and (|t ' |) are function types. As expected, we apply a higher-order cast to s, wrapping \nthe argument, applying s, and then wrapping the result. Thus, wrap((|any . any|), (|bool . bool|), id) \nsucceeds where the cor\u00adresponding setTag fails. Securely importing from un The more interesting case \nof wrap is when the source type is un and the target type is any (line ), which occurs when importing \nan un-typed value from the adversary into the typed fragment of T S*. At line , we use JavaScript s typeof \noperator to examine the simple type of x, the un-typed value being coerced. If x has a primitive type, \nthen the coercion is just the iden\u00adtity. If x is an object, we aim to enumerate all its .elds, then wrap \nand copy each of those .elds into a newly allocated any-typed ob\u00adject. This requires some care, however, \nsince directly enumerating or accessing the .elds of an un-typed objects causes callbacks to the un-typed \nadversary, potentially breaking memory isolation by leak\u00ading any-typed objects on the stack to the context. \nAs a defense, we build on an idea from ( ), as follows. At line , we allocate a new object r into which \nwe will wrap and copy the .elds of x. Next, we build a closure (stub at line ) which captures  Fournet \net al. 2013 15 Fournet et al. 2013 15 1 f u n c t i o n s e t T a g A u x ( x , t , c y c l e o k ) { \n2 v a r c u r T a g = t a g O f ( x ) ; 3 i f ( t m p i n x ) { c y c l e o k ? c u r T a g = x . t m \np : d i e ( ) ; } 4 f u n c t i o n o k ( ) { x . r t t i = x . t m p ; d e l e t e x . t m p ; r e t \nu r n x ; 5 i f ( s u b t y p e ( c u r T a g , t ) ) r e t u r n x ; 6 i f ( t y p e o f x ! = = \" o \nb j e c t \" | | x . t m p ) d i e ( ) ; 7 x . t m p = m e e t ( c u r T a g , t ) ; 8 switch (t.t) { \n9 case \"record\": 10 i f ( c u r T a g . t ! = = \" r e c o r d \" | | c u r T a g . t ! = = \" A n y \" \n) d i e ( ) ; 11 f o r e a c h ( t , f u n c t i o n ( f l d , f t ) { 12 i f ( ! h a s F i e l d ( x \n, f l d ) ) d i e ( ) ; 13 i f ( h a s F i e l d ( c u r T a g , f l d ) &#38; &#38; 14 f t . m u t ! \n= = c u r T a g [ f l d ] . m u t ) ) d i e ( ) ; 15 s e t T a g A u x ( x [ f l d ] , f t . t y p , \nf t . m u t ) ; 16 }); return ok(); 17 case \" data \" : 18 i f ( c u r T a g . t ! = = \" A n y \" ) d i \ne ( ) ; 19 i f ( ! h a s F i e l d ( x , \" c \" ) ) d i e ( ) ; 20 v a r c t = c o n s t r u c t o r s \n( t ) [ x . c ] ; 21 f o r e a c h ( c t , f u n c t i o n ( i x , a r g ) { 22 i f ( ! h a s F i e l \nd ( x , i x ) ) d i e ( ) ; 23 s e t T a g A u x ( x [ i x ] , a r g , f a l s e ) ; 24 }); return ok(); \n25 default : die(); 26 } } 1 f u n c t i o n w r a p ( s r c , t g t , x ) { 2 i f ( s r c . t = = = \n\" a r r o w \" &#38; &#38; t g t . t = = = \" a r r o w \" ) { 3 v a r f = f u n c t i o n ( y ) { r e t \nu r n } 4 w r a p ( s r c . r e t , t g t . r e t , x ( w r a p ( t g t . a r g , s r c . a r g , y ) \n) ) ; 5 } ; f . r t t i = t g t ; r e t u r n f ; 6 } . . . 7 e l s e i f ( s r c . t = = = \" u n \" &#38; \n&#38; t g t . t = = = \" a n y \" ) { 8 s w i t c h ( t y p e o f x ) { 9 c a s e \" u n d e f i n e d \" \n: 10 case \"string\": 11 case \"number\": 12 c a s e \" b o o l e a n \" : r e t u r n x ; 13 case \"object\": \n14 v a r r = C l e a n . c r e a t e ( n u l l ) ; 15 v a r s t u b = f u n c t i o n ( ) { 16 f o r \ne a c h ( x , f u n c t i o n ( p , v ) { 17 r [ p ] = w r a p ( (|un|), (|any|), v ) ; 18 }) }; 19 c \na l l U n ( s t u b ) ; r e t u r n r ; 20 c a s e \" f u n c t i o n \" : 21 v a r u n 2 a n y = f u n \nc t i o n ( x ) { r e t u r n w r a p ( (|un|),(|any|), x ) ; } 22 v a r a n y 2 u n = f u n c t i o \nn ( x ) { r e t u r n w r a p ( (|any|),(|un|), x ) ; } 23 v a r f = u p f u n ( a n y 2 u n , u n 2 \na n y ) ( x ) ; 24 f . r t t i = (|any . any|); r e t u r n f ; 25 default: die(); 26 } } } Figure 3. \nImplementations of Clean.setTag(u,t,x) r and x, but otherwise takes no arguments and returns nothing. \nAs such, the stub can be viewed as a function from un to un. In the body of stub, we enumerate the .elds \nof x, then wrap and copy each of them into r. All that remains is to call stub and return r. The call \nitself is done using callUn, which provides a safe way to call an un\u00adtyped function without breaking \nmemory isolation. The function callUn(f) is de.ned as upfun(id,id)(f)(undefined), where id is the identity \nfunction, and upfun is the wrapper for importing un-typed functions from ( ) (see Figure 4 in that paper). \nWhen x is a function (line ), we again use upfun, this time export\u00ading the argument and then importing \nthe result back the returned value has type any -> any. Securely exporting to un The implementation of \nwrap((|t|), (|un|))(s) for t = un, exports s to the context. This case is somewhat simpler, since s is \na typed value with RTTI which can be safely probed. If s is a primitive, it can be exported as is. If \ns is an object, wrap creates an empty object x, enumerates all the .elds f of s, exports them recursively \nand adds them to x. For functions, it uses Fournet et. al. s downfun to export it at type un -> un. 3.4 \nDiscussion and related work on gradual typing Lan\u00adguages that mix static and dynamic types date back \nat least to ( ) and ( ). Gradual typing is a technique .rst proposed by ( ), ini\u00adtially for a functional \nlanguage with references, and subsequently for languages with various other features including objects. \nSeveral others have worked in this space. For example, ( ) introduces hybrid typing, mixing static, dynamic \nand re.nement types; ( ) add blame to a gradual type system; ( ) present gradual typing with space\u00ad ef.cient \nwrappers; C.; and ( ( ) describe type dynamic in ) add gradual typing to generic Java. Our system is \ndistinct from all others in that it is the .rst to consider gradual typing for a language embedded within \na larger, potentially adversarial environment via the type un. We are also, to the best of our knowledge, \nthe .rst to consider gradual typing as a means of achieving security. To compare more closely with other \nsystems, let us set aside un for the moment, and focus on the interaction between any and statically \ntyped TS*. Previous type systems mediate the interactions Siek et al. 2009 Fournet et al. 2013 20 \nHerman et al. 2010 Abadi et al. 1991 Bracha and Griswold 1993 Siek and Taha 2006 Flanagan 2006 Wadler \nand Findler 2009 Herman et al. 2010 Bierman et al. 2010 Herman et al. 2010 Ina and Igarashi 2011 Siek \net al. 2009 Fournet et al. 2013 20 Herman et al. 2010 Abadi et al. 1991 Bracha and Griswold 1993 Siek \nand Taha 2006 Flanagan 2006 Wadler and Findler 2009 Herman et al. 2010 Bierman et al. 2010 Herman et \nal. 2010 Ina and Igarashi 2011 setTagAux(x,t,false) and Clean.wrap (selected fragments) between static-and \nany-typed code by implicitly attaching casts to values. Higher order casts may fail at a program point \nfar from the point where it was inserted. To account for such failures, blame calculi identify the cast \n(with a label to indicate the term or con\u00adtext) that causes the failure ( ) survey blame cal\u00adculi based \non the errors they detect, points of failures, and casts they blame. In contrast, Interactions between \nstatic-and any-typed T S*is based primarily on RTTI. Casts (wrappers in our terminol\u00adogy) are never inserted \nimplicitly, although they are made available to the programmer. This design has the following advantages. \nPreservation of object identity Object identity in JavaScript is a commonly used feature. Since TS* does \nnot implicitly attach casts to values, it never implicitly breaks object identity in the source during \ncompilation. Previous gradual type systems with implicit casts would always break object identity. Space \nef.ciency Casts can pile up around a value, making the program inef.cient. ( ) introduce a novel cast\u00adreduction \nsemantics to gain space-ef.ciency. Our approach is also space ef.cient (there is only one RTTI per object) \nbut does not require cast-reduction machinery. Static safety and eager failures In contrast to our RTTI-based \nmechanism, statically typed code in other gradual type systems could fail (although blame would help \nthem ascribe it to the any\u00adtyped code). Consider the following T S* example. l e t v : a n y = { f : \nt r u e } i n (. r : { f : w i n t } . r . f ) v Compiling this term using (A-A P P) introduces a setTag \non the argu\u00adment v at type {f:wint}. The setTag operation, at runtime, recur\u00adsively checks that v is \na {f:w int}, and expectedly fails. Thus, the failure happens prior to the application, a failure strategy \ncalled ea\u00adger in prior works. ( ) also argue that their system can provide eager failures, but transposed \nto their notation (with the record replaced by a ref any), the failure occurs at the property read within \nthe statically typed . -term, breaking static safety. When ea\u00adger runtime checking seems too strict, \nT S* wrappers provide an escape hatch. Arguably, for our security applications, a predictably uniform \neager-failure strategy is a suitable default. Dynamic safety and blame With no failures inside statically \ntyped code to explain at runtime, blame seems less useful with RTTI\u00adbased coercions. However, because \nwe enforce dynamic safety Fournet et al. 2013  Swamy et al. 2013 Guha et al. 2010 Swamy et al. 2011 \nFournet et al. 2013 Fournet et al. 2013 Swamy et al. 2013 Guha et al. 2010 Swamy et al. 2011 Fournet \net al. 2013 (RTTI evolves monotonically), failures may now arise in any-typed code, as in the following \nexample. l e t v : a n y = { f : t r u e } i n (. r : { f : w b o o l } . r . f ) v ; v . f = \" h i \" \nThis time, the setTag of v to {f:w int} succeeds, and it modi.es v s RTTI to be {f:w int}. But now, the \nupdate of v.f to \"hi\" fails. This failure in the any-typed fragment should be blamed on the setTag operation \ninstrumented at the application. We plan to pursue the details of this seemingly new notion of blame \nas future work. Gradual typing for monotonic objects Independently, in an un\u00adpublished manuscript, ( \n) investigate gradual typing for a Python-like language (based on an earlier abstract presented at the \nSTOP workshop in 2012). Like us, they notice that constrain\u00ading the type of a mutable object to evolve \nmonotonically at run\u00adtime enables statically typed code to be compiled without runtime checks, leading \nto improved performance and safety for that frag\u00adment. There are some important differences, however. \nFirst, Siek et al. require monotonicity with respect to an intentionally na\u00a8ive sub\u00adtyping relation. \nFor example, (transposed to our notation) the type of an object can evolve from t ={f :w any} to t ' \n={f :w number}, although t ' is not a subtype of t. This means that, in their system, writing o.f = true \ncan fail at runtime, even if o has static type t, which is prevented by T S*. This difference stems perhaps \nfrom dif\u00adfering perspectives on static safety: Siek et al. are willing to tolerate runtime errors in \ncode whose typing somewhere employs the type any; in our system, runtime errors may occur only when any-typed \nvalues are eliminated (i.e., in our (A-) rules only). Syntactically lo\u00adcalizing errors in this manner \ndoes not appear as straightforward with na\u00a8ive subtyping. Additionally, Siek et al. do not aim to model \nan adversarial context there is a single dynamic type, not two (i.e., only any, no un). Exploring how \nto adapt our type un to defend against adversarial Python contexts would be an interesting line of future \nwork. 4. Metatheory This section formally establishes memory isolation, static safety, and dynamic safety \nfor T S* programs translated to JavaScript. Clearly, such a proof requires a formal semantics for JavaScript \nwe rely on JS*, a translation semantics for JavaScript developed by ( ), which is in turn based on . \nJS ( ). We provide a brief review of JS*, de.ne the central in\u00advariants of our translation, and describe \nour main theorem. A full formalism, including all proofs, is available online. 4.1 A review of JS* and \nour high-level proof strategy J S* is a subset of F* ( ), a programming language whose type system allows \nexpressing functional-correctness properties of higher-order effectful programs. Prior work de.nes a \nsemantics for JavaScript via translation to J S* . The semantics is implemented by a tool, called JS2JS*, \nthat translates JavaScript concrete syntax to J S*. This semantics for JavaScript has been used previously \nboth as a means of verifying JavaScript source programs (after trans\u00adlation to J S*) as well as in Fournet \net al. s proof of full abstrac\u00adtion from f* to JavaScript. At its core, J S* provides a mechanically \nveri.ed library called JSVerify that tries to faithfully model most security-relevant details of JavaScript, \nincluding, for example, its object model and its calling convention. The metatheory of TS* is stated \nin terms of its translation to J S*, i.e., programs that can be type-checked against the JSVerify API. \nThe validity of our theorem depends on J S* being a faithful model of JavaScript, an assumption that \ncan be checked separately, e.g., by semantics testing. To set up the formal machinery, we develop a model \nof our compiler by transposing the translation judgment in Figure to instead generate J S* code. The \nrelationship among these transla\u00adtions is depicted alongside. The translation from T S* to J S* can be \nseen as the composition of the translation from TS* to JavaScript, and then from JavaScript to JS* . \nOur main theorem is stated as a type-preservation result from T S * to JS *, where the types in J S * \nare  Siek et al. 2013Siek et al. 2013 22 precise enough to capture our desired invariants, i.e., static \nsafety, dynamic safety, and memory isolation. Monadic computation types with heap invariants All computa\u00adtions \nin js* are typed in a state monad of predicate transformers, iDST, which is parametrized by a heap-invariant \npredicate HeapInv and a heap-evolution predicate d . The type iDST a WP is the type of a computation, \nwhich for any post-condition post, when run in an initial heap h, may diverge or else produce a result \nv:a and a .\u00adnal heap h' that satisfy the formula post v h' . HeapInv h' . d h h' , so long as HeapInv \nh . WP post h is valid. Additionally, all intermediate heaps in the computation satisfy HeapInv, and \nevery intermediate heap is related to all its successors by d . That is, in iDST a WP, a is the result \ntype, and WP is a predicate transformer that computes a pre-condition for the computation with respect \nto post, any de\u00adsired post-condition; HeapInv is an invariant on a heap, and d is a re.exive and transitive \nrelation constraining how the heap evolves. Our online materials also account for exceptions and fatal \nerrors; however, we gloss over them here for lack of space. The main idea behind our proof is that a \nT S* term e:t is trans\u00ad ' lated to a JS* term e of type iDST dyn WP[[t]] , where W P[[t]] = .post..h. \nOk (loc(e)) h . .v h' . [[t]] v h' =. post v h' This ensures that, if e ' is run in an initial heap h \nsatisfying HeapInv h and Ok (loc(e)) h (meaning that all free-variables of the source-term e are correctly \npromoted to the heap in J S*), then either (1) it will terminate with a result v and a .nal heap h' satisfying \n[[t]] v h'; or (2) it will diverge. The code may also raise an exception or throw a ' fatal error, but \nall the while during the execution of e , HeapInv will be true, and the heap will evolve according to \nd . This result holds even when e ' is linked with arbitrary JavaScript code adapting the universal typability \nlemma of ( ), JavaScript code can always be typed in JS* at a type corresponding to un. Our main task \nthen is to carefully de.ne HeapInv, d and [[t]] such that they capture our desired invariants, and then \nto prove that translated programs are well-typed in J S* . 4.2 Invariants of the translation To prove \nmemory isolation, J S* provides a partitioned heap model. Every object reference l:loc carries a tag, \nl.tag, which records the name of the compartment into which the reference points, i.e., each compartment \nis a disjoint fragment of the domain of the heap. There are six compartments in the heap model. The Ref \ncompartment holds objects corresponding to TS* records, datatypes, and RTTI; the Abs compartment holds \nfunction objects; the Clean compartment holds the Clean object initialized and then frozen by boot.js; \nand the Un compartment belongs to the adversary. We focus primarily on properties of these .rst four \ncompartments. The remaining two compartments, Inv and Stub, are inherited unchanged from ( ) the former \nis for maintaining local variables, and the latter for tracking function objects used to make safe callbacks \nto the attacker. Re.ned type dynamic All JavaScript values (including the transla\u00adtion of T S *) are \nrepresented as J S * values of type dyn, de.ned below. We show only three representative cases. d=Str \ns is an injection of s:string into type dyn, where the re.nement TypeOf d=string recalls the static type. \nFor object references Obj (l:loc), the re.nement is l s tag, i.e., {Ref, Abs, Un, Clean}. Finally, for \nfunctions, Fun o f builds a value of type dyn from a function closure f and the JavaScript object o for \nthat closure. Its re.nement is the predicate transformer of f.  type dyn = . . . | Str: string .d:dyn{TypeOf \nd=string} | Obj: l:loc .d:dyn{TypeOf d=l.tag} | Fun: .WP. o:dyn .(this:dyn .args:dyn .iDST dyn (WP o \nargs this)) .d:dyn{TypeOf d=WP} Translation of types To recover the precision of T S* types in J S* \n, we translate source types to predicates on dyn-typed values and the heap: [[t]] d h states that the \nvalue d:dyn is the translation of a source value of type t in the heap h. The translation of a type is \nwith respect to a heap, since a source value allocated at the type { f :a number}, may evolve to become \na value of type { f :a number, g :a number}in some subsequent heap. This is in contrast to, and a signi.cant \ngeneralization of, the translation of f* to J S*, where a value s type does not evolve and is not subject \nto subtyping. [[string]] d h = TypeOf d=string [[un]] d h = IsUn d [[t]] d h = .u <: t. Tagged u d h \nif t . {string, un} Tagged u d h = \"rtti\". dom h[d] . Re p u (h[d][\"rtti\"]) h . Is u d h Is any d h = \nPrim d . Fun is d . (TypeOf d=Ref . restAny {} d h) Is T d h = TypeOf d=Ref .h[d][\"c\"]=Str \"D\" Dt\u00af.T \n. .i [[ti]] (h[d][i]) h . restAny {1..n} d h Is { f\u00af : \u00aft} d h = TypeOf d=Ref . f\u00af . dom h[d] a \u00af \u00afIs \n(t1 . t2) d h = TypeOf d = .o args this..p..h. [[t1]] h[args][\"0\"] h . .r h' . [[t2]] r h' =. p r h' \nrestAny fs d h = .f.dom(h[d])\\fs. \u00acReserved f =. [[any]] h[d][f] h . [[t\u00af]] h[d][ f\u00af] h . restAny f d \nh Since strings are immutable [[string]] d h does not depend on h. Likewise, an un-typed value always \nremains un-typed we de.ne IsUn shortly. For other types, [[t]] d h captures the subtyping relation, stating \nthat there exists a type u <: t such that the value s rtti is tagged with the runtime representation \nof u (the predicate Rep u (h[d][\"rtti\"]) h), and Is u d h, i.e., the value d can be typed at u in h. \nIs any d h states that d is either a primitive (e.g., a string), a function, or a location in the Ref \nheap where all its non-reserved .elds (excluding, e.g., \"rtti\") are typeable at any (restAny). For datatypes \nand records, we require d to be a location in the Ref heap, with the .elds typed as expected, and with \nall other .elds not mentioned in the type being any. The case for functions is most interesting. Is (t1 \n.t2) d h states that d s predicate transformer builds a pre-condition that requires the .rst argument \nto satisfy [[t1]]. (All JavaScript functions are variable arity, receiving their arguments in an array; \nhowever a non-un-typed T S* function will only read the .rst one.) In return, the predicate transformer \nensures that the result r (if any) will satisfy [[t2]] (recall that we are ignoring exceptions here). \nUn values The predicate IsUn v de.nes when the value v could have been produced by, can be given to, \nor is accessible by the context. Un values include primitives; references to objects in the Un heap; \nor the immutable Clean object (which is reachable from the global object). Additionally, Un values can \nbe functions whose speci.cation indicates that it takes Un arguments to Un results. IsUn x TypeOf x . \n{bool, string, .oat, Un, Clean} . TypeOf x=Un2Un Un2Un .o args this post h. IsUn o . IsUn this . IsUn \nargs . (. r h' . IsUn r =. post r h') HeapInv, the global heap invariant Our main heap invariant is a \nproperty of every location x in the heap. Its full de.nition contains seven clauses; we show the most \nimportant ones. HeapInv h .x. x . dom h =. (1) (x.tag=Un =. .x . dom h[x]. IsUn h[x]) (2) . (x.tag.{Ref,Abs} \n. \"rtti\".dom h[x] =. .t. Tagged t d h) (3) . (x.tag=Ref =. TypeOf h[x][\"@proto\"]=Null) (4) . (x.tag=Clean \n=. CleanSpec h[x] h)  Clause (1) asserts that all the contents of an Un object are also Un. Clause (2) \nasserts that every object in the Ref and Abs compartment with an \"rtti\" .eld is tagged properly. Clause \n(3) additionally speci.es that every object in the Ref heap has a null prototype. Clause (4) asserts \nthat the Clean object is speci.ed by CleanSpec, which gives a type to each of its .elds. Within this \ninvariant are two key properties of TS *. The .rst clause guarantees that the only values reachable from \na location in the Un heap are themselves un-values. Therein lies our memory iso\u00adlation property the adversary \ncan never meddle with T S * objects directly, since these reside in the Ref and Abs heap, which are dis\u00adjoint \nfrom Un. The invariant, in its second clause, also captures dy\u00adnamic safety, i.e., every object in the \nRef and Abs heap, once tagged with RTTI are properly typed according to it. d , the heap evolution invariant \nThe full de.nition of d has 4 clauses; we show the main one below: d ensures that, for all objects in \nthe Ref and Abs heaps, their \"rtti\" .elds only evolve monotonically downward, according to the subtyping \nhierarchy. d h0 h1 .l . dom h0, t0, t1. l.tag . {Ref,Abs} . Rep t0 h0[l][\"rtti\"] h0 . Rep t1 h1[l][\"rtti\"] \nh1 =. t1 <: t0 A relatively easy lemma derivable from these de.nitions implies our static safety property. \nIn particular, Lemma guarantees that if a value v (potentially a location to a heap-resident record) \nis typeable at type t in some initial heap h0 then as the program s heap evolves according to d , v remains \ntypeable at t. This ensures that it is safe for T S* to ascribe a value a static type, since that type \nis an invariant of the value at runtime. Lemma 1 (Static safety: d preserves the interpretation of types). \nFor all values v, heaps h0 and h1 such that HeapInv h0, HeapInv h1 and d h0 h1, if for some t we have \n[[t]] v h0 then [[t]] v h1. Finally, our main theorem, as promised, is a type preservation result that \nguarantees memory isolation, dynamic safety and static safety for T S* programs translated to J S*. In \nthe hypothesis, the ' relation G ff e : t e is the formal translation of TS* to J S* (the index f is \nthe name of the current function object in e '; a technical detail). The judgment in the conclusion of \nthe theorem asserts that, ' in a translated environment, e has a type that is described by the predicate \ntransformer corresponding to the source type t. As explained in \u00a7 , this ensures that the translated \nprogram respects the heap invariants and, if it terminates normally, produces a t-typed result. Theorem \n1 (Type preservation). Given a T S* context G, an expression e and a type t , ' if G ff e : t e for \nsome JS* expression e' and function object f , then [[G]], f :dyn,Gloc(e) f e ' : iDST dyn WP[[t]] . \nWe conclude our formal development with a few remarks on the scope of our theorem and the style of its \nproof. First, our result is applicable to the translation of TS* to JavaScript only inasmuch as J S* \nis an accurate model of all of JavaScript ( ) argue for how J S* is adequate for all security-relevant \nfeatures of JavaScript. Regardless, the availability of these semantics together with its program logic \nis what made our proof feasible. Given an operational semantics, but lacking a program logic, our proof \nwould have been mired in tedious inductions over the operational semantics. With JS *, we were able to \ncarry out our proof as an induction over the compilation relation, and use the type system of J S * to \nstructure and prove our invariants. Second, our result includes within its trusted computing base the \ncorrespondence of boot.js to the CleanSpec predicate in the last clause of HeapInv. While it is perhaps \nstandard for compiler and veri.cation projects to rely on a small amount of trusted code, we  1 4.1 \nFournet et al. 2013 1 4.1 Fournet et al. 2013 Swamy et al. 2013Swamy et al. 2013 would like to do better. \nIn particular, we aim to use the JavaScript veri.cation toolchain developed by ( ) to verify boot.js \nfor compliance with CleanSpec at the time of writing, this was still incomplete. More substantially, \nwe would also like to build a translation validation pipeline for our compiler implemen\u00ad tation, re.ecting \nthe generated JavaScript back into JS * for veri.\u00ad cation, i.e., we would like our compiler implementation \nto be also formally type-preserving. 5. Securely deploying T S* programs The guarantees of TS* depend \non boot.js being the .rst script to run on a web page. Many prior works have implicitly assumed that \nscripts are always executed in the order in which they appear on the page ( ; ; ), but, as we explain, \nthis is a na\u00a8ive view. Instead, we develop a standards\u00ad based mechanism that ensures that our scripts \nrun .rst. 5.1 Securely bootstrapping the T S* runtime Suppose a script s is lexically the .rst element \nin the header of a page located at a URL U = http://W.com/page.html; one may expect that it will be guaran\u00ad \nteed to run .rst on any window loaded from U. However, this intu\u00ad ition is correct only if the page has \nnot been loaded programmat\u00ad ically from JavaScript by another web page, e.g., within another frame. On \na page loaded initially from U, the script s will indeed run .rst. Still, a malicious script running \nlater on the page, or on a different page with the same origin http://W.com, may open a win\u00ad dow or frame \nat U, and modify all the essential primitives before s begins to run inside the new window frame. This \nexecution order is consistent with the HTML standard ( ) and we have con.rmed it experimentally on all \nmainstream browsers. Hence, any simple .rst-starter implementation that relies on lexical ordering of \nscript elements will fail if other scripts on the same origin are allowed to open windows or frames. \nIndeed, the web browser only provides security guarantees at the granularity of an origin ( ); .ner-grained \nprivilege separation between good and bad scripts within the same origin require application\u00ad level mechanisms, \nsuch as restricting all untrusted scripts to a sub\u00ad language like SESlight ( ); loading them in sand\u00ad \nboxed iframes with few privileges ( ); or mod\u00ad ifying the browser to allow the .rst-starter script to \ncertify all other scripts running on the page ( ). Rather than restrict the functionality of untrusted \nscripts, we propose a mechanism that ensures that our scripts run .rst. For a given website, we use two \ndistinct origins: http://W.com, used primarily as the service origin; it does not serve any resource. \nhttp://start.W.com, that serves HTML pages, including scripts compiled from T S*, but where the .rst \ntwo <script> elements on every page are as follows: <script src=\"http://start.W.com/boot.js\"></script> \n<script>document.domain = \"W.com\"</script> The crucial step here is that, after boot.js has loaded, the \npage sets document.domain to the parent domain W.com. This is a standards\u00ad based mechanism ( , 5.3.1) \nby which the page voluntarily gives up its rights to the http://start.W.com/ origin for client-side same-origin \naccess across frames and windows. Instead, it adopts an effective script origin of http://W.com. All \nsubsequent scripts on the page are unrestricted except that they can only read or write into frames or \nwindows that have an effective script origin of http://W.com, and hence they cannot tam\u00ad per with pages \non http://start.W.com, even if such pages are loaded programmatically into other frames or windows. In \nall other ways, their functionality is unimpeded, without the need for expensive translations or messaging \nprotocols, as in previous approaches. Jim et al. 2007 Magazinius et al. 2010 Taly et al. 2011 Berjon \net al. 2013 Barth 2011 Taly et al. 2011 Akhawe et al. 2012 Jim et al. 2007 6.1 Berjon et al. 2013 Berjon \net al. 2013 Jim et al. 2007 Magazinius et al. 2010 Taly et al. 2011 Berjon et al. 2013 Barth 2011 Taly \net al. 2011 Akhawe et al. 2012 Jim et al. 2007 6.1 Berjon et al. 2013 Berjon et al. 2013 More generally, \nby placing other trusted scripts after boot.js and before the assignment to document.domain, we can run \nscripts that grab reliable copies of builtin libraries, such as JSON and XMLHttpRequest, for use by subsequent \ncode. 5.2 Loading scripts with embedded secrets Our .rst-starter protocol reliably allows boot.js to \nbuild a trustworthy environment for our compiled scripts. Conversely, we sometimes need a way for scripts \nto be able to verify that their environment is trustworthy. This is particularly important when compiled \nscripts contain se\u00adcret tokens embedded within them, e.g., to authenticate themselves to other servers. \nEmbedding secrets as constants within program text may seem like an elementary mistake, but this is the \npredomi\u00adnant way of distributing these tokens in a JavaScript setting. Secrets within scripts must .rst \nbe protected from malicious websites that may try to load our scripts, and second from malicious scripts \non our own website W.com. In this threat model, many simple counter\u00admeasures one may think of are inadequate. \nEven if we require a login cookie for authentication before serv\u00ading the script, a malicious website \nthat an innocent user visits when logged into W.com can make a cross-site script request and obtain the \nscript (an attack sometimes called JavaScript hijacking). If we inline the scripts into our page, malicious \nscripts can read their source code and obtain the token. Even if they are not inlined but served from \nhttp://start.W.com, malicious scripts can perform an XMLHttpRequest to obtain their source code and then \nread them. In\u00addeed, these are all methods commonly used by cross-site scripting attacks (e.g., the Samy \nworm) to break token-based security pro\u00adtections on the web. To protect our scripts from same-origin \nattackers, we use a third distinct origin to serve our scripts: https://src.W.com, the secure source \nserver, only serves GET re\u00adquests for scripts that may embed secret tokens to be shared be\u00adtween the \nserver and the script. The server refuses cross-origin requests and returns scripts as text/javascript, \nso attackers on https://start.W.com can execute these scripts but not read its source, due to the same-origin \npolicy. We recommend the use of HTTPS for any pages that contain secrets, but HTTP is ade\u00adquate if we \nexclude network adversaries from our threat model. To protect our scripts against other websites, we \nneed an ad\u00additional check. Every script served from src.W.com is pre.xed by a condition on the current \nwebpage location, that is, be\u00adfore making any use of its secret token, the script checks that window.location.href \nactually begins with http://start.W.com/. This ensures that the script has a reliable Clean object on \nthat page, in\u00adtroduced by boot.js. Experimentally, we found that checking the current location of a script \nis quite error-prone. Some scripts try to read document.domain (see e.g., OWASP CSRFGuard in \u00a7 ) or document.location; \noth\u00aders rely on window.location.href but then use regular expression or string matching to check it against \na target origin. All these techniques lead to attacks because a malicious website could have tampered \nwith its document object or with the regular expression li\u00adbraries. We found and reported such attacks \nto vendors. Notably, many browsers allow properties like document.domain and window.location.origin to \nbe overwritten. Our origin check re\u00adlies on the window.location.href object which is speci.ed as un\u00adforgeable \nin the HTML speci.cation ( , 5.2). In practice, however, we found that some browsers incorrectly al\u00adlow \neven supposedly unforgeable objects like window.document and window.location to be shadowed. We have \nreported these bugs to various browsers and are in discussions about .xes. If the unforge\u00adability of \nwindow.location.href turns out to be too strong an as\u00adsumption, we advocate the use of the origin authentication \nprotocol of ( ).  Bhargavan et al. 2013Bhargavan et al. 2013 6. Secure web programming with T S* We \nhave evaluated our compiler by gradually migrating JavaScript sources to T S*, while ensuring that the \nmigrated code (after compi\u00adlation) exports the same API as the original. We have also written from scratch \nvarious utilities like a JSON parser and a reference monitor for HTML5 localStorage. All the code is \navailable online. We have yet to conduct a thorough performance analysis of our compiler, and to implement \nfurther optimizations. But, as men\u00adtioned previously, statically typed TS* should incur little, if any, \nruntime overhead, while un-typed code is unchanged. Understand\u00ading and optimizing the performance pro.le \nof any-typed code is left as future work. In this section, we describe how T S* can be used to gradually \nsecure existing access control patterns, as deployed in popular JavaScript APIs. We focus on client-sided, \nlanguage-based security, relegating most other details to the online materials (notably a description \nof same-origin policies, protocol-and browser speci.c security assumptions, and current attacks against \nthem; see also e.g., ). 6.1 OWASP CSRFGuard We .rst consider the task of securing client code that performs \nan XMLHttpRequest to the page s server. Cross-Site Request Forgeries (CSRF) Suppose a website W has an \nAPI available from JavaScript. Authenticating and authorizing access using cookies ensures that only \nrequests from a logged-in user s browser are accepted. Conversely, if the user has any another websites \nopen in her browser, their scripts also get access to the API, and can thus steal or tamper with the \nuser s data on W. Such request forgery attacks are persistently listed in OWASP Top 10 vulnerabilities, \nand have a serious impact on a variety of websites. CSRF Tokens As a countermeasure to CSRF, a website \nW can inject a fresh, session-speci.c, random token into every page it serves, and only accept requests \nthat include this token. Other websites cannot see W s pages (thanks to the same origin pol\u00adicy) hence \ncannot forge requests. Additionally, cookies and to\u00adkens can be protected while in transit by using the \nHTTPS proto\u00adcol. OWASP CSRFGuard 3 is the most widely-referenced CSRF protection library. As an advanced \nfeature, it provides a token\u00adinjection script that transparently protects AJAX calls by intercept\u00ading \nany XMLHttpRequest. (Similar protections exist for frameworks like Django and Ruby-On-Rails.) Crucially, \nthe token must be kept secret from other websites, and also from other scripts loaded on the page; otherwise \nthose scripts may use it to perform arbitrary requests directly, or leak it to some other website. Attacks \nThe original, unwrapped version of their code relies on window.location, String.startsWith, and XMLHttpRequest, \nwhich can be tampered with by a malicious script. We found several such attacks where a malicious website \ncould load the OWASP CSRFGuard script, forge the location, and trick it into releasing the token; we \nare in discussion with the author towards more robust designs, such as the one proposed here for TS * \n. CSRFGuard in T S* Following the approach of \u00a7 , we migrate to T S* the OWASP proxy that uses the token \nto provide authentication RPCs to the rest of the library. This small script is typed in T S* , guaranteeing \nthat no malicious script that runs alongside (including the rest of the library) can tamper with its \nexecution. The TS*proxy, listed below, takes three string arguments: the target URL, the API function \nname, and the JSON-formatted argu\u00adments. It checks that the URL is well-formed and belongs to the current \nsite (to avoid leaking the token to any other site), then it se\u00adrializes the request as a query string, \nattaches the token, and makes an AJAX call. Once wrapped, it exports the same interface as be\u00adfore to \nany (untrusted) scripts loaded on the page. Additionally, it could be directly used by further T S* code. \n Bhargavan et al. 2013Bhargavan et al. 2013 var csrfToken: string = \"%GENERATED_TOKEN%\" var targetOrigin: \nstring = \"%TARGET_ORIGIN%\" function Rpc(url:string,apifun:string,args:string): any { if (String.startsWith(url,String.concat(targetOrigin,\"/\")) \n&#38;&#38; String.noQueryHash(url)) { var m = {method:apifun, args:args, token: csrfToken}; var request \n= String.concat(\"?\",QueryString.encode(m)); var response = xhrGet(String.concat(url,request));} return \nQueryString.decode(response); } else return \"unauthorized URL\"; } The .rst two lines de.ne string literals, \ninlined by the server as it generates the script the T S * compilation process ensures, via lexical scoping, \nthat these two strings are private to this script. The Rpc function is our secure replacement for xhrGet, \nwhich performs the actual XMLHttpRequest. Compared with the original JavaScript, it includes a few type \nannotations, and uses either safe copies of builtin libraries, such as xhrGet and String, or typed T \nS* libraries, such as QueryString (outlined below). Relying on memory isolation and secure loading from \nT S*, a simple (informal) security review of this script lets us conclude that it does not leak csrfToken. \nExperimentally, we modi.ed the OWASP library, to isolate and protect the few scripts that directly use \nthe token (such as the proxy above) from the rest of the code, which deals with complex formatting and \nbrowser-speci.c extensions, and is kept unchanged and untrusted. The modi.ed library retains its original \ninterface and functionality, with stronger security guarantees, based on strict, type-based isolation \nof the token. Its code and sample client-and server-side code are available online. To our knowledge, \nit is the .rst CSRF library that provides protection from untrusted scripts. 6.2 Facebook API Taking \nadvantage of Cross-Origin Resource Sharing (CORS), Facebook provides a client-side JavaScript API, so \nthat trusted websites may access their personal data once the user has opted in. Interestingly, Facebook \nalso provides a debug\u00admode library, with systematic dynamic typechecks somewhat sim\u00adilar to those automated \nby TS*, to help programmers catch client\u00adside errors. We focus on two aspects of their large API: the \nencod\u00ading of strings, and cross-domain messaging. QueryString encoding We give a TS* implementation of \nthe QueryString module (mentioned above) for the REST message for\u00admat used in the Facebook API. function \ndecode (s:string) : any { var res = {}; if (s === \"\") return res; else { var params = String.split(s,\"&#38;\"); \nfor (var k in params) { var kv = String.split(params[k],\"=\"); res[kv[\"0\"]] = kv[\"1\"]; }; return res;} \n} (The encode function is dual.) Our function illustrates support for arrays provided by our compiler,.Importantly, \nthis code may be used to parse untrusted messages; our wrapper for un to string is straightforward if \nthe argument is already a string, it is just the identity. Hence, one can write ef.cient T S* that calls \ndecode to parse messages received from the adversary; this coding style is idiomatic in JavaScript, while \nthe checks performed by our type system and runtime prevent many pitfalls. Another T S*sample illustrates \nthe usage of Rpc and our typed JSON library (generalizing QueryString) to program a higher-level, statically \ntyped API. It shows, for instance, how to program a client-side proxy for the /me method of the Facebook \nAPI, which retrieves the user pro.le; this T S* function has the return type: type profile = {id: string; \nemail: string; age_range: {min:number}; ... }  Cross-Domain Messaging The Facebook API is meant to run \non any website and protects itself from a malicious host by using iframes. For example, if the website \ncalls FB.login, the API loads an iframe from facebook.com that retrieves the current user s access token \nand then only sends it to the host website (via postMessage) if the host is in a list of authorized origins. \n( ) report attacks on a prior version of this authorization code that were due to typing errors (and \nhave now been patched). We re-implement this code in T S* and show how programmers can rely on typing \nto avoid such attacks. The checkOrigins function below is given the current host ori\u00adgin and veri.es \nit against an array of authorized origins. The proxyMessage function uses this check to guard the release \nof the token to the parent (host) website, using a safe copy of the primi\u00adtive postMessage function. \nfunction checkOrigins (given:string,expected:array string):bool{ for (var k in expected) { if(given === \nexpected[k]) return true;} return false;} function proxyMessage(h:string,tok,origins:array string) { \nif(checkOrigins(h,origins)) postMessage( parent ,tok,h);} In a previous version of the Facebook API, \nproxyMessage was accidentally called with an origins parameter of type string, rather than array string. \nThis innocuous type error leads to an attack, be\u00adcause the untyped version of the code succeeds with \nboth strings and arrays, but with different results. To see the core problem, consider a call to checkOrigins \nwhere given = \"h\" and expected = \"http://W.com\". The for loop iterates over each character of expected, \nand hence succeeds, when it should not. In TS*, iteration is well-typed only for arrays and, unlike JavaScript, \nthis enumer\u00adates only the own properties of the array. Thus, in our code, this error is caught statically \n(if the incorrect call to proxyMessage is lo\u00adcal) or dynamically (if the call is from another iframe); \nthe check fails in both cases and the token is not leaked. 7. Conclusions and prospects This paper aims \nto broaden the scope of gradual typing: not only it is useful for migrating dynamically type-safe code \nto more struc\u00adtured statically typed code, it is also useful for moving from unsafe code, vulnerable \nto security attacks, to a robust mixture of dynam\u00adically and statically type-safe code. Within the context \nof JavaScript, we have presented TS*, a lan\u00adguage with a gradual type system, a compiler, and runtime \nsupport that provides several useful safety and con.nement properties. Our preliminary experience suggests \nthat T S* is effective in protecting security-critical scripts from attacks without safety and con.ne\u00adment, \nsuch properties are dif.cult to obtain for JavaScript, and in\u00addeed security for such scripts has previously \nbeen thought unob\u00adtainable in the presence of cross-site scripts. Even excluding the adversary, TS* develops \na new point in the design space of gradual typing, using an approach based on runtime type information. \nThis has several useful characteristics, including a simple and uniform failure semantics, and its applicability \nto a language with extensible objects and object identity. In the future, we plan to develop TS* along \nseveral dimensions. On the practical side, we expect to integrate our ideas in an exper\u00adimental branch \nof the open source TypeScript compiler, targeting the construction of larger secure libraries. On the \ntheoretical side, we plan to explore the formal certi.cation of our compiler and run\u00adtime. We also hope \nto develop our preliminary ideas on new notions of blame to explain runtime failures in T S* . Acknowledgments \nMany thanks to Mart\u00b4in Abadi, Antoine Deli\u00adgnat-Lavaud, Jeremy Siek, Phil Wadler, and all the anonymous \nreviewers. Bhargavan et al. 2013Bhargavan et al. 2013 References M. Abadi, L. Cardelli, B. Pierce, and \nG. Plotkin. Dynamic typing in a statically typed language. ACM ToPLAS, 13(2):237 268, 1991. D. Akhawe, \nP. Saxena, and D. Song. Privilege separation in HTML5 applications. In Proceedings of USENIX Security, \n2012. A. Barth. The web origin concept, 2011. IETF RFC6454. A. Barth, C. Jackson, and J. C. Mitchell. \nRobust defenses for cross-site request forgery. In Proceedings of CCS, 2008. R. Berjon, T. Leithead, \nE. Navara, E.D.and O Conner, and S. Pfeiffer. HTML5. , 2013. W3C Cand. Reco. K. Bhargavan, A. Delignat-Lavaud, \nand S. Maffeis. Language-based de\u00adfenses against untrusted browser origins. In Proceedings of USENIX \nSecurity, 2013. G. Bierman, E. Meijer, and M. Torgersen. Adding dynamic types to C . In Proceedings of \nECOOP, 2010. G. Bracha and D. Griswold. Strongtalk: Typechecking Smalltalk in a production environment. \nIn Proceedings of OOPSLA, 1993. R. Chugh, D. Herman, and R. Jhala. Dependent types for JavaScript. In \nOOPSLA, 2012. Facebook API. FB.API, 2013. . R. B. Findler and M. Felleisen. Contracts for higher-order \nfunctions. In Proceedings of ICFP, 2002. C. Flanagan. Hybrid type checking. In Proceedings of POPL, 2006. \nC. Fournet, N. Swamy, J. Chen, P.-E. Dagand, P.-Y. Strub, and B. Livshits. Fully abstract compilation \nto JavaScript. In Proceedings of POPL, 2013. A. D. Gordon and A. Jeffrey. Authenticity by typing for \nsecurity protocols. In Proceedings of CSFW, 2001. S. Guarnieri and B. Livshits. Gatekeeper: mostly static \nenforcement of security and reliability policies for javascript code. In USENIX security symposium, SSYM \n09. USENIX Association, 2009. A. Guha, C. Saftoiu, and S. Krishnamurthi. The essence of JavaScript. In \nProceedings of ECOOP, 2010. A. Guha, C. Saftoiu, and S. Krishnamurthi. Typing local control and state \nusing .ow analysis. In Proceedings of ESOP, 2011. D. Hedin and A. Sabelfeld. Information-.ow security \nfor a core of JavaScript. In Proceedings of CSF, 2012. D. Herman, A. Tomb, and C. Flanagan. Space-ef.cient \ngradual typing. Higher Order Symbol. Comput., 2010. L. Ina and A. Igarashi. Gradual typing for generics. \nIn Proceedings of OOPSLA, 2011. T. Jim, N. Swamy, and M. Hicks. Defeating script injection attacks with \nbrowser-enforced embedded policies. In Proceedings of WWW, 2007. J. Magazinius, P. H. Phung, and D. Sands. \nSafe wrappers and sane policies for self protecting JavaScript. In Proceedings of NordSec, 2010. OWASP \nCSRFGuard. CSRFGuard 3 user manual, 2010. . J. G. Politz, S. A. Eliopoulos, A. Guha, and S. Krishnamurthi. \nAdsafety: type-based veri.cation of javascript sandboxing. In USENIX Security, 2011. J. G. Siek and W. \nTaha. Gradual typing for functional languages. In Scheme and Functional Programming Workshop, 2006. J. \nG. Siek, R. Garcia, and W. Taha. Exploring the design space of higher\u00adorder casts. In Proceedings of \nESOP, 2009. J. G. Siek, M. M. Vitousek, and S. Bharadwaj. Gradual typing for mutable objects. , 2013. \nN. Swamy, J. Chen, C. Fournet, P.-Y. Strub, K. Bhargavan, and J. Yang. Secure distributed programming \nwith value-dependent types. In Pro\u00adceedings of ICFP, 2011. N. Swamy, J. Weinberger, C. Schlesinger, J. \nChen, and B. Livshits. Verify\u00ading higher-order programs with the Dijkstra monad. In PLDI, 2013. A. Taly, \nU. Erlingsson, J. C. Mitchell, M. S. Miller, and J. Nagra. Automated analysis of security-critical JavaScript \nAPIs. In Proceedings of S&#38;P, 2011. P. Wadler and R. B. Findler. Well-typed programs can t be blamed. \nIn Proceedings of ESOP, 2009.  http://www.w3.org/TR/html5/ http://developers.facebook.com/docs/reference/javascript/ \nhttps://www.owasp.org/index.php/CSRFGuard_3_User_Manual http://ecee.colorado.edu/~siek/gtmo.pdf http://www.w3.org/TR/html5/ \nhttp://developers.facebook.com/docs/reference/javascript/ https://www.owasp.org/index.php/CSRFGuard_3_User_Manual \nhttp://ecee.colorado.edu/~siek/gtmo.pdf \n\t\t\t", "proc_id": "2535838", "abstract": "<p>JavaScript's flexible semantics makes writing correct code hard and writing secure code extremely difficult. To address the former problem, various forms of gradual typing have been proposed, such as Closure and TypeScript. However, supporting all common programming idioms is not easy; for example, TypeScript deliberately gives up type soundness for programming convenience. In this paper, we propose a gradual type system and implementation techniques that provide important safety and security guarantees.</p> <p>We present TS# , a gradual type system and source-to-source compiler for JavaScript. In contrast to prior gradual type systems, TS# features full runtime reflection over three kinds of types: (1) simple types for higher-order functions, recursive datatypes and dictionary-based extensible records; (2) the type any, for dynamically type-safe TS# expressions; and (3) the type un, for untrusted, potentially malicious JavaScript contexts in which TS# is embedded. After type-checking, the compiler instruments the program with various checks to ensure the type safety of TS# despite its interactions with arbitrary JavaScript contexts, which are free to use eval, stack walks, prototype customizations, and other offensive features. The proof of our main theorem employs a form of type-preserving compilation, wherein we prove all the runtime invariants of the translation of TS# to JavaScript by showing that translated programs are well-typed in JS# , a previously proposed dependently typed language for proving functional correctness of JavaScript programs.</p> <p>We describe a prototype compiler, a secure runtime, and sample applications for TS#. Our examples illustrate how web security patterns that developers currently program in JavaScript (with much difficulty and still with dubious results) can instead be programmed naturally in TS#, retaining a flavor of idiomatic JavaScript, while providing strong safety guarantees by virtue of typing.</p>", "authors": [{"name": "Nikhil Swamy", "author_profile_id": "81342513197", "affiliation": "Microsoft Research, Redmond, USA", "person_id": "P4383868", "email_address": "nswamy@microsoft.com", "orcid_id": ""}, {"name": "Cedric Fournet", "author_profile_id": "81100547450", "affiliation": "Microsoft Research, Cambridge, United Kingdom", "person_id": "P4383869", "email_address": "fournet@microsoft.com", "orcid_id": ""}, {"name": "Aseem Rastogi", "author_profile_id": "81496682403", "affiliation": "University of Maryland, College Park, USA", "person_id": "P4383870", "email_address": "aseem@cs.umd.edu", "orcid_id": ""}, {"name": "Karthikeyan Bhargavan", "author_profile_id": "81100070918", "affiliation": "INRIA, Paris, France", "person_id": "P4383871", "email_address": "karthikeyan.bhargavan@inria.fr", "orcid_id": ""}, {"name": "Juan Chen", "author_profile_id": "81100119052", "affiliation": "Microsoft Research, Redmond, USA", "person_id": "P4383872", "email_address": "juanchen@microsoft.com", "orcid_id": ""}, {"name": "Pierre-Yves Strub", "author_profile_id": "81488661455", "affiliation": "IMDEA Software Institute, Madrid, Spain", "person_id": "P4383873", "email_address": "pierre-yves@strub.nu", "orcid_id": ""}, {"name": "Gavin Bierman", "author_profile_id": "81100249578", "affiliation": "Microsoft Research, Cambridge, United Kingdom", "person_id": "P4383874", "email_address": "gmb@microsoft.com", "orcid_id": ""}], "doi_number": "10.1145/2535838.2535889", "year": "2014", "article_id": "2535889", "conference": "POPL", "title": "Gradual typing embedded securely in JavaScript", "url": "http://dl.acm.org/citation.cfm?id=2535889"}