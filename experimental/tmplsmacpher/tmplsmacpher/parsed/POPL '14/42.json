{"article_publication_date": "01-08-2014", "fulltext": "\n Game Semantics for Interface Middleweight Java * Andrzej S. Murawski Nikos Tzevelekos DIMAP and Department \nof Computer Science School of Electronic Engineering and Computer Science University of Warwick Queen \nMary, University of London Abstract We consider an object calculus in which open terms interact with \nthe environment through interfaces. The calculus is intended to capture the essence of contextual interactions \nof Middleweight Java code. Using game semantics, we provide fully abstract models for the induced notions \nof contextual approximation and equivalence. These are the .rst denotational models of this kind. Categories \nand Subject Descriptors D.3.1 [Formal De.nitions and Theory]: Semantics; F.3.2 [Semantics of Programming \nLan\u00adguages]: Denotational semantics Keywords Full Abstraction, Game Semantics, Contextual Equiv\u00adalence, \nJava 1. Introduction Denotational semantics is charged with the construction of mathe\u00admatical universes \n(denotations) that capture program behaviour. It concentrates on compositional, syntax-independent modelling \nwith the aim of illuminating the structure of computation and facilitat\u00ading reasoning about programs. \nMany developments in denotational semantics have been driven by the quest for full abstraction [21]: \na model is fully abstract if the interpretations of two programs are the same precisely when the programs \nbehave in the same way (i.e. are contextually equivalent). A faithful correspondence like this opens \nthe path to a broad range of applications, such as compiler opti\u00admisation and program transformation, \nin which the preservation of semantics is of paramount importance. Recent years have seen game semantics \nemerge as a robust de\u00adnotational paradigm [4, 6, 12]. It has been used to construct the .rst fully abstract \nmodels for a wide spectrum of programming lan\u00adguages, previously out of reach of denotational semantics. \nGame semantics models computation as an exchange of moves between two players, representing respectively \nthe program and its compu\u00adtational environment. Accordingly, a program is interpreted as a strategy in \na game corresponding to its type. Intuitively, the plays that game semantics generates constitute the \nobservable patterns * Research supported by the Engineering and Physical Sciences Research Council (EP/J019577/1) \nand a Royal Academy of Engineering Research Fellowship (Tzevelekos). Permission to make digital or hard \ncopies of all or part of this work for personal or classroom use is granted without fee provided that \ncopies are not made or distributed for pro.t or commercial advantage and that copies bear this notice \nand the full citation on the .rst page. Copyrights for components of this work owned by others than the \nauthor(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or republish, to \npost on servers or to redistribute to lists, requires prior speci.c permission and/or a fee. Request \npermissions from permissions@acm.org. POPL 14, January 22 24, 2014, San Diego, CA, USA. Copyright is \nheld by the owner/author(s). Publication rights licensed to ACM. ACM 978-1-4503-2544-8/14/01. . . $15.00. \nhttp://dx.doi.org/10.1145/2535838 that a program produces when interacting with its environment, and \nthis is what underlies the full abstraction results. Game semantics is compositional: the strategy corresponding \nto a compound program phrase is obtained by canonical combinations of those correspond\u00ading to its sub-phrases. \nAn important advance in game semantics was the development of nominal games [3, 17, 26], which under\u00adpinned \nfull abstraction results for languages with dynamic gener\u00adative behaviours, such as the .-calculus [3], \nhigher-order concur\u00adrency [18] and ML references [24]. A distinctive feature of nominal game models is \nthe presence of names (e.g. memory locations, ref\u00aderences names) in game moves, often along with some \nabstraction of the store. The aim of the present paper is to extend the range of the game approach towards \nreal-life programming languages, by fo\u00adcussing on Java-style objects. To that end, we de.ne an impera\u00adtive \nobject calculus, called Interface Middleweight Java (IMJ), in\u00adtended to capture contextual interactions \nof code written in Mid\u00addleweight Java (MJ) [9], as speci.ed by interfaces with inheritance. We present \nboth equational (contextual equivalence) and inequa\u00adtional (contextual approximation) full abstraction \nresults for the language. To the best of our knowledge, these are the .rst deno\u00adtational models of this \nkind. Related Work While the operational semantics of Java has been researched extensively [7], there \nhave been relatively few results regarding its denotational semantics. More generally, most existing \nmodels of object-oriented languages, such as [8, 15], have been based on global state and consequently \ncould not be fully abstract. On the other hand, contextual equivalence in Java-like lan\u00adguages has been \nstudied successfully using operational approaches such as trace semantics [2, 13, 14] and environmental \nbisimu\u00adlation [16]. The trace-based approaches are closest to ours and the three papers listed also provide \ncharacterizations of contextual equivalence. The main difference is that traces are derived opera\u00adtionally \nthrough a carefully designed labelled transition system and, thus, do not admit an immediate compositional \ndescription in the style of denotational semantics. However, similarities between traces and plays in \ngame seman\u00adtics indicate a deeper correspondence between the two areas, which also manifested itself \nin other cases, e.g. [20] vs [19]. At the time of writing, there is no general methodology for moving \nsmoothly between the two approaches, but we believe that there is scope for unifying the two .elds in \nthe not so distant future. In comparison to other game models, ours has quite lightweight structure. \nFor the most part, playing consists of calling the oppo\u00adnent s methods and returning results to calls \nmade by the opponent. In particular, there are no justi.cation pointers between moves. This can be attributed \nto the fact that Java does not feature .rst\u00adclass higher-order functions and that methods in Java objects \ncan\u00adnot be updated. On the other hand, the absence of pointers makes de.nitions of simple notions, such \nas well-bracketing, less direct, since the dependencies between moves are not given explicitly any  \n(x:.).G (a:I).G I.dom(.) .|G f x : . .|G f a : I .|G f skip : void .|G f null : I .|G f i : int .|G f \nM : int .|G f M' : int .|G, x : .' f M : . .|G f M ' : .' .|G f M : I .|G f M' : I .|G f M : I' .lI=I' \n .|G f M . M' : int .|G f let x = M' in M : . .|G f M = M' : int .|G f (I)M : I ..lI'=I .|G f M : int \n.|G f M', M'' : . .|G, x : I f M : T .|G f M : I .|G f M ' : . .(I)IMeths=T .(I).f=. .|G f if M then \nM' else M'' : . .|G f new(x : I; M) : I .|G f M.f := M' : void V V xi : x.i} f Mi : .i) (.|G l {x.|G \nf M : T T={mi:.xi..i | 1=i=n} M={mi:.x i.Mi | 1=i=n} n n .|G f M : I .|G f M.f : . .(I).f=. .|G f M \n: I .|G f M.m(M1, (.|G f Mi : .i) \u00b7 , Mn) : . i=1 .(I).m= i=1 x ... \u00b7 \u00b7 Figure 1. Typing rules for \nIMJ terms and method-set implementations more and need to be inferred from plays. The latter renders \nstrategy composition non-standard. Because it is impossible to determine statically to which arena a \nmove belongs, the switching conditions (cf. [6]) governing interactions become crucial for determining \nthe strategy responsible for each move. Finally, it is worth noting that traditional copycat links are \nby de.nition excluded from our set\u00adting: a call/return move for a given object cannot be copycatted by \nthe other player, as the move has a .xed polarity, determined by the ownership of the object. In fact, \nidentity strategies contain plays of length at most two! Further Directions In future work, we would \nlike to look for automata-theoretic representations of fragments of our model in order to use them as \na foundation for a program veri.cation tool for Java programs. Our aim is to take advantage of the latest \ndevel\u00adopments in automata theory over in.nite alphabets [10], and fresh\u00adregister automata in particular \n[23, 27], to account for the nominal features of the model. 2. The language IMJ We introduce an imperative \nobject calculus, called Interface Mid\u00addleweight Java (IMJ), in which objects are typed using interfaces. \nThe calculus is a stripped down version of Middleweight Java (MJ), expressive enough to expose the interactions \nof MJ-style objects with the environment. 8 >< De.nition 1. Let Ints, Flds and Meths be sets of interface, \n.eld and method identi.ers. We range over them respectively by I, f, m and variants. The types . of IMJ \nare given below, where x. stands for a sequence .1, ..., .n of types (for any n). An interface de.nition \nT is a .nite set of typed .elds and methods. An interface table . is a .nite assignment of interface \nde.nitions to interface identi.ers. Types 3 . ::= void | int | I IDfns 3 T ::= \u00d8 | (f : .), T | (m : \n.x. .), T ITbls 3 . ::= \u00d8 | (I : T), . | (I(I) : T), . We write I(I') : T for interface extension: interface \nI extends I' with .elds and methods from T. We stipulate that the extension relation must not lead to \ncircular dependencies. Moreover, each identi.er f, m can appear at most once in each T, and each I can \nbe de.ned at most once in . (i.e. there is at most one element of . of the form I : T or I(I') : T). \nThus, each T can be seen as a .nite partial function T : (Flds . Meths) -Types * . We write T.f for T(f) \nand T.m for T(m). Similarly, . de.nes a partial function . : Ints -IDfns given by An interface table \n. is well-formed if, for all interface types I, I': if I' appears in .(I) then I' . dom(.),  if (I(I') \n: T) . . then dom(.(I')) n dom(T) = \u00d8.  Henceforth we assume that interface tables are well-formed. \nIn\u00adterface extensions yield a subtyping relation. Given a table ., we de.ne . f .1 = .2 by the following \nrules. (I(I') : T), . f I=I' . f .1 = .2 . f .2 = .3 . f . = . . f .1 = .3 We might omit . from subtyping \njudgements for economy. De.nition 2. Let A be a countably in.nite set of object names, which we range \nover by a and variants. IMJ terms are listed below, where we let x range over a set of variables Vars, \nand i over Z. Moreover, . is selected from some set of binary numeric opera\u00adtions. M is a method-set \nimplementation. Again, we stipulate that each m appear in each M at most once. M ::= x | a | skip | null \n| i | M . M | let x = M in M | M = M | if M then M else M | (I)M | new(x : I; M) - . | M.f | M.f := M \n| M.m(M ) MImps 3 M ::= \u00d8 | (m : .xx.M ), M The terms are typed in contexts comprising an interface table \n. and a variable context G = {x1 : .1, \u00b7 \u00b7 \u00b7 , xn : .n} . {a1 : I1, \u00b7 \u00b7 \u00b7 , am : Im} such that any interface \nin G occurs in dom(.). The typing rules are given in Figure 1. For the operational semantics, we de.ne \nthe sets of term values, heap con.gurations and states by: TVals 3 v ::= skip | i | null | a HCnfs 3 \nV ::= \u00d8 | (f : v), V States 3 S : A -Ints \u00d7 (HCnfs \u00d7 MImps) If S(a) = (I, (V, M)) then we write S(a) \n: I, while S(a).f and S(a).m stand for V.f and M.m respectively, for each f and m. Given an interface \ntable . such that I . dom(.), we let the default heap con.guration of type I be .(I) = >: (S, i . \ni ' ) -. (S, j), if j = i . i ' (S, let x = v in M) -. (S, M[v/x]) (S, (I)null) -. (S, null) (S, if 0 \nthen M else M ' ) -. (S, M ' ) (S, if 1 then M else M ' ) -. (S, M) (S, a = a) -. (S, 1) '' ' (S, (I)a) \n-. (S, a), if S(a) : I . I = I (S, a = a ' ) -. (S, 0), if a= a (S, a.f) -. (S, S(a).f) (S, new(x : I; \nM)) -. (S l {(a, I, (VI , M[a/x]))}, a) (S, a.m(xv)) -. (S, M[xv/x ]), if S(a).m = .xx.M (S, a.f := v) \n-. (S[a . (I, (V [f . v], M)], skip), if S(a) = (I, (V, M)) (S, E[M]) -. (S ' , E[M ' ]), if (S, M) -. \n(S ' , M ' ) Figure 2. Operational semantics of IMJ. between terms-in-state, presented in Figure 2. \nThe transition rela\u00adtion uses evaluation contexts E that are de.ned as follows. E ::= let x = in M | \n. M | i . | = M | a = | if then M else M ' | (I) | .f | .f := M | a.f := - . | .m(M) | a.m(v1, \u00b7 \u00b7 \u00b7 \n, vi, , Mi+2, \u00b7 \u00b7 \u00b7 , Mn) Given .|\u00d8 f M : void, we write M . if there exists S such that (\u00d8, M) -. * \n(S, skip). De.nition 3. Given .|G f Mi : . (i = 1, 2), we shall say that .|G f M1 : . contextually approximates \n.|G f M2 : . if, for all . ' . . and all contexts C such that . ' |\u00d8 f C[Mi] : void, if C[M1] . then \nC[M2] .. We then write .|G f M1 . ~ M2 : .. Two ~ terms are contextually equivalent (written .|G f M1 \n= M2 : .) if they approximate each other. For technical convenience, IMJ features the let construct, \neven though it is de.nable: given .|G, x : . ' f M : . and .|G f M ' : . ' , consider new( x : I; m : \n.x.M ).m(M ' ), where I is a fresh interface with a single method m : . . . ' . As usual, we write M; \nM ' for let x = M in M ' , where x is not free in M ' . Although IMJ does not have explicit local variables, \nthey could easily be introduced by taking let (x = new(y : I.; )) in \u00b7 \u00b7 \u00b7 , where I. has a single .eld \nof type .. In the same manner, one can de.ne variables and methods that are private to objects, and invisible \nto the environment through interfaces. Example 1 ([16]). Let . = {Empty : \u00d8, Cell : (get : void . Empty, \nset : Empty . void), VarE : (val : Empty), VarI : (val : int)}and consider the terms .|\u00d8 f Mi : Cell \n(i = 1, 2) de.ned by M1 = let v = new(x : VarE ; ) in new(x : Cell; M1) M2 = let b = new(x : VarI ; ) \nin let v1 = new(x : VarE ; ) in let v2 = new(x : VarE ; )in new(x : Cell; M2) with M1 = (get : .().v.val, \nset : .y.(v.val := y)) M2 = (get : .().if (b.val) then (b.val := 0; v1.val) else (b.val := 1; v2.val), \nset : .y.(v1.val := y; v2.val := y)). ~ We have .|\u00d8 f M1 = M2 : Cell. Intuitively, each of the two im\u00adplementations \nof Cell corresponds to recording a single value of type Empty (using set) and providing access to it \nvia get. The dif\u00adference lies in the way the value is stored: a single private variable is used in M1, \nwhile two variables are used in M2. However, in the latter case the variables always hold the same value, \nso it does not matter which of the variables is used to return the value. The game semantics of the two \nterms will turn out to consist of S0 G * plays of the shape *\u00d8 n 0 S1 G * 1 \u00b7 \u00b7 \u00b7 Sk G * k, where ( S0 \nS0 call n.get(*)ret n.get(nul)i = 0 Gi = call n.get(*)Si ret n.get(ni)Si i > 0 Si = call n.set(ni)Si \nret n.set(*)Si and Si = {n . (Cell, \u00d8)} . {nj . (Empty, \u00d8) | 0 < j = i}. Intuitively, the plays describe \nall possible interactions of a Cell object. The .rst two moves *\u00d8 n S0 correspond to object creation. \nAfter that, the Gi segments represent the environment reading the current content (initially having null \nvalue), while the Si segments correspond to updating the content with a reference name provided by the \nenvironment. The stores Si attached to moves consist of all names that have been introduced during the \ninteraction so far. It is worth noting that, because IMJ has explicit casting, a context can always guess \nthe actual interface of an object and extract any information we may want to hide through casting. Example \n2. Let . = {Empty : \u00d8, Point(Empty) :(x : int, y : int)}and consider the terms .|\u00d8 f Mi : Empty (i = \n1, 2) de.ned by: M1 = new(x : Empty; ), M2 = let p = new(x : Point; ) in p.x := 0; p.y := 1; (Empty)p. \nIn our model they will be interpreted by the strategies s1 = {E, *\u00d8 n{nm.(Empty,\u00d8)}} and s2 = {E, *\u00d8 \nn{nm.(Point,{xm.0,ym.1})} respectively. Using e.g. the casting context C = (Point) ; skip, we can see \nthat .|\u00d8 f M2.. ~ M1 : Empty. On the other hand, Theorem 20 will imply .|\u00d8 f M1 ~ M2 : Empty. On the \nwhole, IMJ is a compact calculus that strips down Mid\u00addleweight Java to the essentials needed for interface-based \ninterac\u00adtion. Accordingly, we suppressed the introduction of explicit class hierarchy, as it would remain \ninvisible to the environment anyway and any class-based internal computations can be represented using \nstandard object encodings [1]. At the moment the calculus allows for single inheritance for interfaces \nonly, but extending it to multiple inheritance is not prob\u00adlematic. The following semantic developments \nonly rely on the as\u00adsumption that = must not give rise to circularities. 3. The game model In our discussion \nbelow we assume a .xed interface table .. The game model will be constructed using mathematical objects \n(moves, plays, strategies) that feature names drawn from the set A. Although names underpin various elements \nof our model, we do not want to delve into the precise nature of the sets containing them. Hence, all \nof our de.nitions preserve name-invariance, i.e. our objects are (strong) nominal sets [11, 26]. Note \nthat we do not need the full power of the theory but mainly the basic notion of name-permutation. For \nan element x belonging to a (nominal) set X we write .(x) for its name-support, which is the set of names \noccurring in x. Moreover, for any x, y . X, we write x ~ y if there is a permutation p such that x = \np \u00b7 y.  We proceed to de.ne a category of games. The objects of our category will be arenas, which are \nnominal sets carrying speci.c type information. De.nition 4. An arena is a pair A = (MA, .A) where: \nMA is a nominal set of moves;  .A : MA . (A -Ints) is a nominal typing function;  such that, for all \nm . MA, dom(.A(m)) = .(m). We start by de.ning the following basic arenas, 1 = ({*}, {(*, \u00d8)}, Z = (Z, \n{(i, \u00d8)}, I = (A. {nul}, {(nul, \u00d8)} . {(a, a, I)}), for all interfaces I. Given arenas A and B, we can \nform the arena A \u00d7 B by: MA\u00d7B = {(m, n) . MA \u00d7 MB | a . .(m) n .(n) =. .A(m, a) = .B(n, a) . .B (n, a) \n= .A(m, a)} ( .A(m, a) if a /. .(n) . .A(m, a) = .B (n, a).A\u00d7B((m, n), a) = .B(n, a) otherwise Another \nimportant arena is #(I1, \u00b7 \u00b7 \u00b7 , In), with: M= {(a1, \u00b7 \u00b7 \u00b7 , an) . An | ai s distinct} #(Ix) .((a1, \u00b7 \n\u00b7 \u00b7 , an), ai) = Ii #(Ix) for all n . N. In particular, A#0 = 1. For each type ., we set Val . to be \nthe set of semantic values of type ., given by: Val void = M1, Val int = MZ, Val I = MI. For each type \nsequence x. = .1, \u00b7 \u00b7 \u00b7 , .n, we set Val .x= Val .1 \u00d7 \u00b7 \u00b7 \u00b7 \u00d7 Val .n . We let a store S be a type-preserving \n.nite partial function from names to object types and .eld assignments, that is, S : A -Ints \u00d7 (Flds \n-Val ) such that |S| is .nite and S(a) : I . .(I).f = . =. S(a).f = v . S f v = ., where the new notation \nis explained below. First, assuming S(a) = (I ' , f), the judgement S(a) : I holds iff I = I ' and S(a).f \nstands for f(f). Next we de.ne typing rules for values in store contexts: v . Val void v . Val int S(v) \n: I . v = nul S f v : void S f v : int S f v : I and write S f v = . for S f v : . . (S f v : I ' . I \n' = .). We let Sto be the set of all stores. We write dom(S(a)) for the set of all f such that S(a).f \nis de.ned. We let Sto0 contain all stores S such that: .a . dom(S), f . dom(S(a)). S(a).f . {*, 0, nul} \nand we call such a S a default store. Given arenas A and B, plays in AB will consist of sequences of \nmoves (with store) which will be either moves from MA . MB, or moves representing method calls and returns. \nFormally, we de.ne: MAB = MA . MB . Calls . Retns where we set Calls = {call a.m(xv) | a . A.xv . Val \n* } and Retns = {ret a.m(v) | a . A. v . Val }. De.nition 5. A legal sequence in AB is a sequence of \nmoves from MAB that adheres to the following grammar (Well-Bracketing), where mA and mB range over MA \nand MB respectively. LAB ::= E | mAX | mAY mBX X ::= Y | Y (call a.m(xv)) X Y ::= E | Y Y | (call a.m(xv)) \nY (ret a.m(v)) We write LAB for the set of legal sequences in AB. In the last clause above, we say that \ncall a.m(xv) justi.es ret a.m(v). To each s . LAB we assign a polarity function p from move occurrences \nin s to the set Pol1 = {O, P }. Polarities represent the two players in our game reading of programs: \nO is the Opponent and P is the Proponent in the game. The latter corresponds to the modelled program, \nwhile the former models the possible computa\u00adtional environments surrounding the program. Polarities \nare com\u00adplemented via O = {P } and P = {O}. In addition, the polarity function must satisfy the condition: \n For all mX . MX (X = A, B) occurring in s we have p(mA) = O and p(mB ) = P ; (O-starting)  If mn are \nconsecutive moves in s then p(n) . p(m). (Alterna\u00adtion)  It follows that there is a unique p for each \nlegal sequence s, namely the one which assigns O precisely to those moves appearing in odd positions \nin s. A move-with-store in AB is a pair m S with S . Sto and m . MAB . For each sequence s of moves-with-store \nwe de.ne the set of available names of s by: Av(E) = \u00d8, Av(sm S) = S * (Av(s) . .(m)) Si where, for each \nX . A, we let S * (X) = S i (X), with 0 i+1 i S(X) = X, S(X) = .(S(S(X))). That is, a name is available \nin s just if it appears inside a move in s, or it can be reached from an available name through some \nstore in s. We write s for the underlying sequence of moves of s (i.e. p1(s)), and let . denote the pre.x \nrelation between sequences. If s ' m S . s and a . .(m S ) \\ .(s ' ) then we say a is introduced by m \nS in s. 1 In such a case, we de.ne the owner of the name a in s, written o(a), to be p(m) (where p is \nthe polarity associated with s). For each polarity X . {O, P } we let X(s) = {a . .(s) | o(a) = X} be \nthe set of names in s owned by X. De.nition 6. A play in AB is a sequence of moves-with-store s such \nthat s is a legal sequence and, moreover, for all s ' m S . s: It holds that dom(S) = Av(s ' m S ). \n(Frugality)  If a . dom(S) with S(a) : I then: if m . MX , for X . {A, B}, then I = .X (m, a); for all \nn T in s ', if a . dom(T ) then T (a) : I;  if .(I).m = x. . . then: - if m = call a.m(xv) then S f \nxv : .x' for some .x' = x., - if m = ret a.m(v) then S f v : . ' for some . ' = .. (Well-classing) If \nm = call a.m(xv) then o(a) . p(m). (Well-calling) We write PAB for the set of plays in AB. 1 By abuse \nof notation, we frequently write instead a is introduced by m in s . Recall also that .(s) collects all \nnames appearing in s; in particular, S1 Si .(m \u00b7 \u00b7 \u00b7 m ) = .(m1) . .(S1) . \u00b7 \u00b7 \u00b7 1 i . .(mi) . .(Si). \n Note above that, because of well-bracketing and alternation, if m = ret a.m(v) then well-calling implies \no(a) = p(m). Thus, the frugality condition stipulates that names cannot appear in a play in unreachable \nparts of a store (cf. [17]). Moreover, well\u00adclassing ensures that the typing information in stores is \nconsistent and adheres to the constraints imposed by . and the underlying arenas. Finally, well-calling \nimplements the speci.cation that each player need only call the other player s methods. This is because \ncalls to each player s own methods cannot in general be observed and so should not be accounted for in \nplays. Given arenas A, B, C , next we de.ne interaction sequences, which show how plays from AB and BC \ncan interact to produce a play in AC. The sequences will rely on moves with stores, where the moves come \nfrom the set: MABC = MA . MB . MC . Calls . Retns . The moves will be assigned polarities from the set: \nPol2 = { OL, PL, OLPR, PLOR, OR, PR } . The index L stands for left , while R means right . The indices \nindicate which part of the interaction (A, B or C) a move comes from, and what polarity it has therein. \nWe also consider an auxiliary notion of pseudo-polarities: OO = {OL, OR}, P O = {PL, PLOR}, OP = {PR, \nOLPR}. Each polarity has an opposite pseudo-polarity determined by: OL = OLPR = P O, OR = PLOR = OP, \nPL = PR = OO. Finally, each X . {AB, BC, AC } has a designated set of polari\u00adties given by: p(AB) = {OL, \nPL, OLPR, PLOR}, p(BC ) = {OR, PR, OLPR, PLOR}, p(AC) = {OL, PL, OR, PR}. Note the slight abuse of notation \nwith p, as it is also used for move polarities. Suppose X . {AB, BC, AC }. Consider a sequence s of moves-with-store \nfrom ABC (i.e. a sequence with elements m S with m . MABC ) along with an assignment p of polarities \nfrom Pol2 to moves of s. Let s I X be the subsequence of s containing those moves-with-store m S of s \nfor which p(m) . p(X). Addi\u00adtionally, we de.ne s I. X to be .(s I X), where the function . acts on moves-with-store \nby restricting the domains of stores to available names: S SIAv(sm S ) .(E) = E, .(sm ) = .(s) m . De.nition \n7. An interaction sequence in ABC is a sequence s of moves-with-store in ABC satisfying the following \nconditions. ' S ' S For each s m s, dom(S) = Av(s m ). (Frugality)  If s ' m S s and a . dom(S) with \nS(a) : I then: if m . MX , for X . {A, B, C }, then I = .X (m, a); for all n T in s ', if a . dom(T ) \nthen T (a) : I;  if .(I).m = x. . . then: - if m = call a.m(xv) then S f xv : .x' for some .x' = .x, \n- if m = ret a.m(v) then S f v : . ' for some . ' = .. (Well-classing)  There is a polarity function \np from move occurrences in s to  Pol 2 such that: For all mX . MX (X = A, B, C ) occurring in s we have \np(mA) = OL, p(mB) = PLOR and p(mC ) = PR; If mn are consecutive moves in s then p(n) . p(m). (Alternation) \nOO OL ORPL PRPLOR    P O OP OLPR Figure 3. Interaction diagram for Int(ABC ). The diagram spec\u00adi.es \nthe alternation of polarities in interaction sequences. Transi\u00adtions are labelled by move polarities, \nwhile OO is the initial state. If s ' m S s then m = call a.m(v) implies o(a) . p(m). (Well-calling) \n For each X . {AB, BC, AC }, s I X . LX . (Projecting)  ' S T If s m s and m = ret a.m(v) then there \nis a move n in s ' such that, for all X such that p(m) . p(X), n is the justi.er of m in s I X. (Well-returning) \n Laird s conditions [17]:  P (s I. AB) n P (s I. BC ) = \u00d8; (P (s I. AB) . P (s I. BC )) n O(s I. AC) \n= \u00d8; ' S T For each s s ending in m n and each a . dom(T ), if - p(m) . P O and a /. .(s ' I. AB), - \nor p(m) . OP and a /. .(s ' I. BC ), - or p(m) . OO and a /. .(s ' I. AC), then S(a) = T (a). We write \nInt(ABC ) for the set of interaction sequences in ABC . Note that, by projecting and well-returning, \neach return move in s has a unique justi.er. Next we show that the polarities of moves inside an interaction \nsequence are uniquely determined by the interaction diagram of Figure 3. The diagram can be seen as an \nautomaton accepting s, for each s . Int(ABC ). The edges represent moves by their polarities, while the \nlabels of vertices specify the polarity of the next (outgoing) move. For example, from OO we can only \nhave a move m with p(m) . {OL, OR}, for any p. Lemma 1. Each s . Int(ABC ) has a unique polarity function \np. Proof. Suppose s . Int(ABC ). We claim that the alternation, well-calling, projecting and well-returning \nconditions uniquely specify p. Consider the interaction diagram of Figure 3, which we read as an automaton \naccepting s, call it A. The edges represent moves by their polarities, while the labels of vertices specify \nthe polarity of the next (outgoing) move. By projecting we obtain that the .rst element of s is some \nmA and, by alternation, its polarity is OL. Thus, OO is the initial state. We now use induction on |s| \nto show that A has a unique run on s. The base case is trivial, so suppose s = s ' m. By induction hy\u00adpothesis, \nA has a unique run on s ', which reaches some state X. We do a case analysis on m. If m . MA . MB . MC \nthen there is a unique edge accepting m and, by alternation, this edge must depart from X. If, on the \nother hand, m = call a.m(xv) then the fact that o(a) . p(m) gives two possible edges for accepting m. \nBut observe that no combination of such edges can depart from X. Finally, let m = ret a.m(v) be justi.ed \nby some n in s '. Then, by well-bracketing, n is the justi.er of m in all projections, and hence the \nedge accepting m must be the opposite of the one accepting n (e.g. if m is accepted by OL then n is accepted \nby PL). Next we show that interaction sequences project to plays. The projection of interaction sequences \nin ABC on AB, BC and AC leads to the following de.nition of projections of polarities,  pAB(XL) = X \npAB (XLYR) = X pAB(YR) = undef. pBC (XL) = undef. pBC (XLYR) = Y pBC (YR) = Y pAC (XL) = X pAC (XLYR) \n= undef. pAC (YR) = Y where X, Y . {O, P }. We can now show the following. Lemma 2. Let s . Int(ABC ). \nThen, for each X . {AB, BC, AC }and each m S in s, if p(m) . p(X) then pX (p(m)) = pX (m), where pX is \nthe polarity function of s I X. Proof. We show this for X = AB, the other cases are proven similarly, \nby induction on |s| = 0; the base case is trivial. For the inductive case, if m is the .rst move in s \nwith polarity in p(AB) then, by projecting, m . MA and therefore p(m) = OL and pAB (m) = O, as required. \nOtherwise, let n be the last move in s with polarity in p(AB) before m. By IH, pAB(n) = pAB (p(n)). Now, \nby projecting, pAB(m) = pAB (n) and observe that, for all X . p(n), pAB (X) = pAB (p(n)), so in particular \npAB (p(m)) = pAB(p(n)) = pAB(n) = pAB(m). The following lemma formulates a taxonomy on names appear\u00ading \nin interaction sequences. Lemma 3. Let s . Int(ABC ). Then, 1. .(s) = O(s I. AC) l P (s I. AB) l P (s \nI. BC ); 2. if s = tmS and:  p(m) . OO and s I. AC = t ' m S ' , or p(m) . P O and s I. AB = t ' m \nS ' , or p(m) . OP and s I. BC = t ' m S ' , ' then .(t) n .(m S ' ) . .(t ) and, in particular, if m \nintroduces S ' name a in t ' m then m introduces a in s. Proof. For 1, by de.nition of interactions we \nhave that these sets are disjoint. It therefore suf.ces to show the left-to-right inclusion. Suppose \nthat a . .(s) is introduced in some m S in s, with S ' S ' p(m) . P O, and let s I. AB = \u00b7 \u00b7 \u00b7 m \u00b7 \u00b7 \n\u00b7 . If a . .(m ) then a . P (s I. AB), as required. Otherwise, by Laird s last set of conditions, a is \ncopied from the store of the move preceding m S in s, a contradiction to its being introduced at m S \n. Similarly if p(m) . OP . Finally, if p(m) . OO then we work similarly, considering O(s I. AC). For \n2, we show the .rst case, and the other cases are similar. It ' suf.ces to show that (.(m S ' ) \\ .(t \n)) n .(t) = \u00d8. So suppose ' a . .(m S ' ) \\ .(t ), therefore a . O(s I. AC). But then we cannot have \na . .(t) as the latter, by item 1, would imply a . P (s I. AB) . P (s I. BC ). Proposition 4. For all \ns . Int(ABC ), the projections s I. AB, s I. BC and s I. AC are plays in AB, BC and AC respectively. \nProof. By frugality of s and application of ., all projections satisfy frugality. Moreover, well-classing \nis preserved by projections. For well-calling, let m = call a.m(xv) be a move in s and let n T be the \nmove introducing a in s. Suppose p(m) . p(AB) and let us assume pAB(m) = O. We need to show that oAB \n(m) = P . By pAB (m) = O we obtain that p(m) . {OL, OLPR} and, by well-calling of s, we have that o(a) \n. P O. Thus, p(n) . P O and, by Lemma 3, n introduces a in s I. AB and therefore oAB (n) = P , as required. \nIf, on the other hand, pAB (m) = P then we obtain p(n) . OO . OP and therefore, by Lemma 3, a . P (s \nI. BC ) . O(s I. AC). Thus, by the same lemma, a /. P (s I. AB) and hence oAB(a) = O. The cases for the \nother projections are shown similarly. In our setting programs will be represented by strategies be\u00adtween \narenas. We shall introduce them next after a few auxiliary de.nitions. Intuitively, strategies capture \nthe observable computa\u00adtional patterns produced by a program. Let us de.ne the following notion of subtyping \nbetween stores. For S, S ' . Sto, S = S ' holds if, for all names a, '''' ' S (a) : I =. S(a) = I ..f \n. dom(S (a)).S(a).f = S (a).f In particular, if a is in the domain of S ' , S may contain more information \nabout a because of assigning to a a larger interface. Accordingly, for plays s, s ' . PAB , we say that \ns is an O-extension of s ' if s and s ' agree on their underlying sequences, while their stores may differ \ndue to subtyping related to O-names. Where such subtyping leads to s having stores with more .elds than \nthose in s ' , P is assumed to copy the values of those .elds. Formally, s =O s ' is de.ned by the rules: \ns =O s ' S = S ' S I P (sm S ) . S ' p(m)=O ' S ' E =O E smS =O s m sn T =O s ' S = S ' S extends S ' \nby T p(m)=P T ' S ' snmS =O s m where S extends S ' by T if: for all a . dom(S) \\ dom(S ' ), S(a) = \nT (a);  for all a and f . dom(S(a)) \\ dom(S ' (a)), S(a).f = T (a).f.  The utility of O-extension is \nto express semantically the fact that the environment of a program may use up-casting to inject in its \nobjects additional .elds (and methods) not accessible to the program. De.nition 8. A strategy s in AB \nis a non-empty set of even-length plays from PAB satisfying the conditions: If sm S n T . s then s . \ns. (Even-pre.x closure)  If sm S , sn T . s then sm S ~ sn T . (Determinacy)  If s . s and s ~ t then \nt . s. (Equivariance)2  If s . s and t =O s then t . s. (O-extension)  We write s : A . B when s is \na strategy in AB. If s : A . B and t : B . C, we de.ne their composition s; t by: s; t = {s I. AC | s \n. sIt } where sIt = {s . Int(ABC ) | s I. AB . s . s I. BC . t }. In de.nitions of strategies we may \noften leave the presence of the empty sequence implicit, as the latter is a member of every strategy. \nFor example, for each arena A, we de.ne the strategy: idA : A . A = {m S S A mA . PAA} The next series \nof lemmata allow us to show that strategy com\u00adposition is well de.ned. ST S Lemma 5. If sm , sn . sIt \nwith p(m) ./OO then sm ~ sn T . Hence, if s1m S , s2n T . sIt with p(m) ./OO and s1 ~ s2 then s1m S ~ \ns2n T . Proof. For the latter part, if s1 = p \u00b7 s2 then, since p \u00b7 (s2n T ) . sIt, by former part of \nthe claim we have s1m S ~ p \u00b7 (s2n T ) so s1m S ~ s2n T . Now, for the former part, suppose WLOG that \np(m) . P O. Then, by the interaction diagram, we also have p(n) . P O. As S T ' S ' ' T sm , sn I. AB \n. s, by determinacy of s we get s m ~ s n ' ,  ' S ' S ' T T with s m = sm I. AB and s n ' = sn I. AB. \nWe there\u00ad ' S ' ' T ' ' fore have (s , m ) ~ (s , n ) and, trivially, (s, s ) ~ (s, s ). S ' ' T Moreover, \nby Lemma 3, .(m ) n .(s) . .(s ) and .(n ' ) n .(s) . .(s ' ) hence, by Strong Support Lemma [26], sm \nS ' ~ sn T ' . By Laird s last set of conditions, the remaining values of S, T are determined by the \nlast store in s, hence sm S ~ sn T . Lemma 6. If s1, s2 . sIt end in moves with polarities in p(AC) and \ns1 I. AC = s2 I. AC then s1 ~ s2. Proof. By induction on |s1 I. AC| > 0. The base case is encom\u00adpassed \nin si = si ' m Si with p(m) . OO, i = 1, 2, where note that by IH m will have the same polarity in s1, \ns2. Then, by IH we get ' ' '' s1 = p \u00b7 s2, for some p. Let si m S ' = si I. AC, for i = 1, 2, so '' '' \n' '' ' '' in particular s1 = p \u00b7 s2 and therefore (s1, s1 ) ~ (s2, s2 ). More\u00ad S ' S ' '' '' over, by \nhypothesis, we trivially have (m , s1 ) ~ (m , s2 ) and hence, by Lemma 3 and Strong Support Lemma [26], \nwe obtain S ' S ' s1 ' m ~ s2 ' m which implies s1 ~ s2 by Laird s conditions. ' '' Si Suppose now si \n= sisi m , i = 1, 2, with p(m) . P (AC)\\OO ' ' '' and the last move in si being the last move in sisi \nhaving polarity in p(AC). By IH, s1 ' ~ s2 ' . Then, by consecutive applications of Lemma 5, we obtain \ns1 ~ s2. Proposition 7. If s : A . B and t : B . C then s; t : A . C. Proof. We show that s; t is a strategy. \nEven-pre.x closure and equivariance are clear. Moreover, since each s . sIt has even\u00adlength projections \nin AB and BC, we can show that its projection in AC is even-length too. For O-extension, if s . s; t \nand t =O s with s = u I. AC and u . sIt , we can construct v . Int(ABC) such that t = v I. AC and v =O \nu, where =O is de.ned for interaction sequences in an analogous way as for plays (with condition p(m) \n= O replaced by p(m) . OO, and p(m) = P by p(m) . P O . OP ). Moreover, v I. AB =O u I. AB and v I. BC \n=O u I. BC, so t . s; t. Finally, for S T ' S ' ' T determinacy, let sm , sn . s; t be due to s1s1m , \ns2s2n ' . sIt respectively, where s1, s2 both end in the last move of s. By Lemma 6, we have s1 ~ s2 \nand thus, by consecutive applications of Lemma 5, we get s1s1 ' m S ' ~ s2s2 ' n T ' , so sm S ~ sn T \n. The above result shows that strategies are closed under com\u00adposition. We can prove that composition \nis associative and, conse\u00adquently, obtain a category of games. Proposition 8. For all . : A . B, s : \nB . C and t : C . D, (.; s); t = .; (s; t ). De.nition 9. Given a class table ., we de.ne the category \nG. having arenas as objects and strategies as morphisms. Identity morphisms are given by idA, for each \narena A. Note that neutrality of identity strategies easily follows from the de.nitions and, hence, G. \nis well de.ned. In the sequel, when . can be inferred from the context, we shall write G. simply as G. \nAs a .nal note, for class tables . . . ' , we can de.ne a functor ./. ' : G. . G. ' which acts as the \nidentity map on arenas, and sends each s : A . B of G. to: . ' (./. ' )(s) = {s . PAB | .t . s. s =O \nt} where P . ' refers to plays in G. ' . In the other direction, we can AB de.ne a strategy transformation: \n' . (. /.)(s) = s n PAB which satis.es . ' /.(./. ' (s)) = s. 4. Soundness Here we introduce constructions \nthat will allow us to build a model of IMJ. We begin by de.ning a special class of strategies. A strategy \ns : A . B is called evaluated if there is a function fs : MA . MB such that: S S s = {mA mB . PAB | mB \n= fs(mA)} . Note that equivariance of s implies that, for all mA . MA and permutations p, it holds that \np \u00b7 fs(mA) = fs(p \u00b7 mA). Thus, in particular, .(fs(mA)) . .(mA). Recall that, for arenas A and B, we \ncan construct a product arena A \u00d7 B. We can also de.ne projection strategies: p1 : A \u00d7 B . A = {(mA, \nmB )S m S A . P(A\u00d7B)A} and, analogously, p2 : A \u00d7 B . B. Note that the projections are evaluated. Moreover, \nfor each object A, S S !A = {mA *S | mA . PA1} is the unique evaluated strategy of type A . 1. Given \nstrategies s : A . B and t : A . C, with t evaluated, we de.ne: S S (s, t) : A . B \u00d7C = {mA s[(mB , ft \n(mA))/mB] | mA s . s} where we write s[m ' /mB ] for the sequence obtained from s by replacing any occurrences \nof mB in it by m ' (note that there can be at most one occurrence of mB in s). The above structure yields \nproducts for evaluated strategies. Lemma 9. Evaluated strategies form a wide subcategory of G which has \n.nite products, given by the above constructions. Moreover, for all s : A . B and t : A . C with t evaluated, \n(s, t); p1 = s and (s, t) = (s, idA); (p1, p2; t ). Using the above result, we can extend pairings to \ngeneral s : A . B and t : A . C by: ((p2;t,p1)~ s,idA) = (s, t) = A - ---. B \u00d7 A - ----. C \u00d7 B -. B \u00d7 \nC where ~= is the isomorphism (p2, p1). The above represents a notion of left-pairing of s and t , where \nthe effects of s precede those of t. We can also de.ne a left-tensor between strategies: (p1;s,p2) (p1,p2;t) \n' '' s \u00d7 t = A \u00d7 B ------. A \u00d7 B - ----. A \u00d7 B for any s : A . A ' and t : B . B ' . ' A ' Lemma 10. \nLet t : . A, s : A . B1, t : A . B2, s1 : B1 \u00d7 B2 . C1 and s2 : B2 . C2, with t and t ' evaluated. ' \n'' Then t ; (s, t); (s1, p2; s2) = (t ; (s, t ); s1, t ; t ; s2). Proof. The result follows from the \nsimpler statements: t; (s, id) = (t ; s, t ), (s, id); (s ' , p2) = ((s; id); s ' , id), for all appropriately \ntyped s, s ' , t , with t evaluated, and Lemma 9. An immediate consequence of the above is: (s;t) s1\u00d7s2 \n(s;s1,t;s2) A ---. B1 \u00d7 B2 ----. C1 \u00d7 C2 = A -------. C1 \u00d7 C2 More generally, Lemma 10 provides us with \nnaturality conditions similar to those present in Freyd categories [25] or, equivalently, categories \nwith monadic products [22]. We also introduce the following weak notion of coproduct. Given strategies \ns, t : A . B, we de.ne: S S [s, t ] : Z\u00d7 A . B = {(1, mA)s | mA s . s} S S . {(0, mA)s | mA s . t } \n Setting i : 1 . Z = {* i}, for each i . Z, we can show the following. Lemma 11. For all strategies s \n' : A ' . A and s, t : A . B, (!; 0, id); [s, t] = t and (!; 1, id); [s, t] = s; if s ' is evaluated \nthen (idZ \u00d7 s ' ); [s, t] = [s ' ; s, s ' ; t]. Method de.nitions in IMJ induce a form of exponentiation: \nn i=1(.|G l {x i : .xi} f Mi : .i) T={mi:x.i..i | 1=i=n} .|G f M : T . M={mi:.x i.Mi | 1=i=n} the modelling \nof which requires some extra semantic machinery. Traditionally, in call-by-value game models, exponentiation \nleads to effectless strategies, corresponding to higher-order value terms. In our case, higher-order \nvalues are methods, manifesting them\u00adselves via the objects they may inhabit. Hence, exponentiation nec\u00adessarily \npasses through generation of fresh object names containing these values. These considerations give rise \nto two classes of strate\u00adgies introduced below. We say that an even-length play s . PAB is total if it \nis either S SfT ' empty or s = mA mB s and: T . Sto0 and .(mB ) n .(S) . .(mA), S ' S0fT ' '' T S0 ' \nif s = s m n ' and a . dom(S) \\ .(.(mA mB s )), for S0 S0fT ' S0 . Sto0 such that .(mA mB s ) . PAB , \nthen a /. .(n) and T ' (a) = S ' (a). We write P t AB for the set of total plays in AB. Thus, in total \nplays, the initial move mA is immediately followed by a move mB, and the initial store S is invisible \nto P in the sense that P cannot use its names nor their values. A strategy f : A . B is called single\u00adthreaded \nif it consists of total plays and satis.es the conditions:3 S ST for all mA . PAB there is mA mB . f; \nS SfT S0 S0fT if mA mB s . f then .(mA mB s) . f, for S0 . Sto0; S SfT v)S ' ' if mA mB s call a.m(xs \n. f and a . .(T ) then s = E. S Thus, single-threaded strategies reply to every initial move mA T with \na move mB which depends only on mA (i.e. P does not read T before playing). Moreover, mB does not change \nthe values of S (P does not write) and may introduce some fresh objects, albeit with default values. \nFinally, plays of single-threaded strategies consist of just one thread, where a thread is a total play \nin which there can be at most one call to names introduced by its second move. S SfT Conversely, given \na total play starting with mA mB , we can extract its threads by tracing back for each move in s the \nmethod call of the object a . .(T ) it is related to. Formally, for each total S SfT ' play s = mA m \ns with |s ' | > 0, the threader move of s, B written thrr(s), is given by induction: thrr(s ' m S ' ) \n= thrr(s ' ), if p(m) = P ; S ' S ' thrr(s ' call a.m(xv)) = call a.m(xv), if a . .(T ); ' T v)S ' ' \nT thrr(s n ' s '' call a.m(x) = thrr(s n ' ), if a . P (s)\\.(T ) and n introduces a. ' T '' S ' ' T thrr(s \nn s ' m ) = thrr(s n ' ), if p(m) = O and n justi.es m. ' '' ' T '' T ' T If s = s n s with |s ' | = \n2, we set thrr(n ) = thrr(s n ). Then, the current thread of s is the subsequence of s containing only \nmoves with the same threader move as s, that is, if thrr(s) = S ' S SfT ' m and s = mA mB s then S SfT \n' S ' lsl = mA mB (s I m ) 3 Note that the use of the term thread here is internal to game semantics \nparlance and in particular should not be confused with Java threads. where the restriction retains only \nthose moves n T ' of s ' such that T S ' thrr(n ' ) = m . We extend this to the case of |s| = 2 by setting \nlsl = s. Finally, we call a total play s . PAB thread-independent ' S ' even if for all s m s with |s \n' | > 2: S ' S '' ' '' ' '' if .(ls m l) = s m then .(S '' ) n .(s ) . .(s );  if s ' ends in some \nn T ' and a . dom(S ' )\\.(.(ls ' m S ' l)) then S ' (a) = T ' (a).  We write P ti AB for the set of \nthread-independent plays in AB. We can now de.ne strategies which occur as interleavings of single-threaded \nones. Let f : A . B be a single-threaded strategy. = {s . P ti ' even We de.ne: f AB | .s s. .(ls 'l) \n. f}. Lemma 12. f is a strategy, for each single-threaded f. Proof. Equivariance, Even-pre.x closure \nand O-extension fol\u00adlow from the corresponding conditions on f. For determinacy, if sm S , sn T . f with \n|s| > 0 then, using determinacy of f and the fact that P-moves do not change the current thread, nor \ndo they modify or use names from other threads, we can show that sm S ~ sn T . We say that a strategy \ns is thread-independent if s = t for some single-threaded strategy t . Thus, thread-independent strate\u00adgies \ndo not depend on initial stores and behave in each of their threads in an independent manner. Note in \nparticular that evaluated strategies are thread-independent (and single-threaded). Lemma 13. Let s : \nA . B and t : A . C be strategies with t thread-independent. Then, (s, t); p1 = s and: (t,s) ~ = (s, \nt) = A ---. C \u00d7 B -. B \u00d7 C . Proof. The former claim is straightforward. For the latter, we ob\u00adserve \nthat the initial effects of s and t commute: on initial move S mA , t does not read the store updates \nthat s includes in its re\u00ad S ' sponse mB , while s cannot access the names created by t in its S ' fT \nsecond move mC . It is worth noting that the above lemma does not suf.ce for ob\u00adtaining categorical products. \nAllowing thread-independent strate\u00adgies to create fresh names in their second move breaks universality \nof pairings. Considering, for example, the strategy: s : 1 . I \u00d7 I = {* (a, a)S . P1(I\u00d7I) | S . Sto0} \nwe can see that s = (s; p1, s; p2), as the right-hand-side contains plays of the form * (a, b)T with \na = b. We can now de.ne an appropriate notion of exponential for our games. Let us assume a translation \nassigning an arena [x.] to each type sequence x.. Moreover, let I be an interface such that .(I) I Meths \n= {m1 : .x1 . .1, \u00b7 \u00b7 \u00b7 , mn : x.n . .n} where .xi = .i1, \u00b7 \u00b7 \u00b7 , .imi , for each i. For any arena A, \ngiven single-threaded strategies f1, \u00b7 \u00b7 \u00b7 , fn : A . I such that, for each S SfT i, if mA a s . fi then \na /. .(S) . T (a) : I . (call a.m(xv) . s =. m = mi), we can group them into one single-threaded strategy: \n[n ((f1, . . . , fn)) : A . I = fi . i=1 S S Note that the a above is fresh for each mA (i.e. a /. .(mA \n)).  Let now s1, \u00b7 \u00b7 \u00b7 , sn be strategies with si : A \u00d7 [x.i] . [.i]. For each i, we de.ne the single-threaded \nstrategy .(si) : A . I: S SfTS ' S ' .(si) = {mA a call a.mi(xv)s . PAt I | .((mA, xv)s) . si} S SfT \nS ' T ' . P t . {mA a call a.mi(xv)s ret a.mi(v)' s AI | S ' T ' S SfT .((mA, xv)s v ' s ) . si} . {mA \na . PAt I} where a ./.(S, xv, v, s, s ' , S ' , T ' ) and T (a) : I. By de.nition, .(si) is single-threaded. \nTherefore, setting .(s1, . . . , sn) = ((.(s1), . . . , .(sn))) : A . I, we obtain a thread-independent \nstrategy implementing a simultane\u00adous currying of s1, \u00b7 \u00b7 \u00b7 , sn. In particular, given translations [Mi]for \neach method in a method-set implementation M, we can con\u00adstruct: [M] : [G] . I = .([M1], \u00b7 \u00b7 \u00b7 , [Mn]). \nFinally, we de.ne evaluation strategies evmi : I \u00d7 [.xi] . [.i] by (taking even-length pre.xes of): S \nSTT evmi = {(a, xv)call a.mi(xv)ret a.mi(v)v . PAi | S(a) = I} where Ai = (I\u00d7[.xi])[.i]. We can now show \nthe following natural mapping from groups of strategies in A \u00d7 [.xi] . [.i] to thread\u00adindependent ones \nin A . I. Lemma 14. Let s1, \u00b7 \u00b7 \u00b7 , sn be as above, and let t : A ' . A be evaluated. Then, .(s1, . \n. . , sn) \u00d7 id; evmi = si,  t; .(s1, . . . , sn) = .((t \u00d7 id); s1, . . . , (t \u00d7 id); sn).  Apart from \ndealing with exponentials, in order to complete our translation we need also to address the appearance \nof x : I in the rule4 G, x : I, . f M : T .(I)IMeths=T. G, . f new(x : I; M) : I Recall that [M] : [G] \n\u00d7I .I (1) is obtained using exponentiation. Thus, the second move of [M]will appear in the right-hand-side \nI above and will be a fresh name b which will serve as a handle to the methods of M: in order to invoke \nm : .xx.M on input xv, the Opponent would have to call b.m(xv). The remaining challenge is to merge the \ntwo occurrences of I in (1). We achieve this as follows. Let us assume a well-formed extension . ' of \n.: ' '' . =(I : (f : I)), . that is, I ' contains a single .eld f ' of type I. We next de.ne the strategy \n.I : 1 . I ' \u00d7 I of G. ' : ' S STT .I = {* (a , a)S0 call a.m(xv)call b.m(xv)ret b.m(v)ret a.m(v)} where \nm . dom(.(I)), b = S(a ' ).f ' , and S0 . Sto0 is such that S0(a) : I and S0(a ' ) : I ' . We let [new(x \n: I; M)] be the strategy:5 (id,!;.I);~id\u00d7([M],p2)(asn\u00d7id);p2 = ' ' f ' [G] - -----. I \u00d7[G]\u00d7I --------. \nI \u00d7I\u00d7I --------. I and asnf is the assignment strategy: *S[a.fm.v] asnf : I \u00d7 [.] . 1 = {(a, v)S . P(I\u00d7[.])1}, \n4 Note that x may appear free in M; it stands for the keyword this of Java. 5 Here we omit wrapping [M] \ninside ./. ' , as well as wrapping the whole [new(x : I; M)] in . ' /., for conciseness. for each .eld \nf. Thus, object creation involves creating a pair of names (a ' , a) with a : I and a ' : I ' , where \na is the name of the object we want to return. The name a ' serves as a store where the handle of the \nmethod implementations, that is, the name created by the second move of [M], will be passed. The strategy \n.I , upon receiving a request call a.m(xv)S , simply forwards it to the respective method of a ' .f ' \nand, once it receives a return value, copies it back as the return value of the original call. -. -S \nS. Let #(Ix) : I . #( I ) = {xa xa | ais distinct}, for each . sequence of interfaces -I . The latter \nhas a right inverse #(Ix)-r : -. - . #( I ) . I with the same plays. We can now de.ne the semantic translation \nof terms. De.nition 10. The semantic translation is given as follows. Contexts G = {x1 : .1, \u00b7 \u00b7 \u00b7, xn \n: .n}.{a1 : I1,\u00b7 \u00b7 \u00b7 , am : Im} are translated into arenas by [G] = [.1] \u00d7 \u00b7 \u00b7 \u00b7 \u00d7 [.n] \u00d7 #(I1, \u00b7 \u00b7 \n\u00b7 , Im), where [void] = 1, [int] = Zand [I] = I. Terms are translated as in Figure 4 (top part). In order \nto prove that the semantics is sound, we will also need to interpret terms inside state contexts. Let \nG f M : ., with G = G1 . G2, where G1 contains only variables and dom(G2) = dom(S). A term-in-state-context \n(S, M) is translated into the strat\u00adegy: -. id\u00d7#(Ix) - S] [G1 f (S, M)] = [G1] [I - - M] ------. [G] \n[ . [G1] \u00d7 . [.]. The semantic translation of states (Figure 4, lower part), comprises two stages: -. \n[S]2- . [G1 f S] = [G1] [S]1. [G1] \u00d7 - -I - -I . . [G1] \u00d7 The .rst stage, [S]1, creates the objects in \ndom(S) and implements their methods. The second stage of the translation, [S]2, initialises the .elds \nof the newly created objects. In the rest of this section we show soundness of the seman\u00adtics. Let us \ncall NEW, FIELDUP, FIELDAC and METHODCL re\u00adspectively the transition rules in Figure 2 which involve \nstate. r Given a rule r, we write (S, M) -. (S ' , M ' ) if the transition (S, M) -. (S ' , M ' ) involves \napplying r and context rules. Proposition 15 (Correctness). Let (S, M) be a term-in-state\u00ad r context \nand suppose (S, M) -. (S ' , M ' ). 1. If the transition r is not stateful then [M] = [M ' ]. 2. If \nr is one of FIELDAC or FIELDUP then [S]2; (id\u00d7#(Ix)); [M] = [S ' ]2; (id \u00d7 #(Ix)); [M ' ]. 3. If r is \none of METHODCL or NEW then [(S, M)] = [(S ' , M ' )].  Thus, in every case, [(S, M)] = [(S ' , M ' \n)]. Proof. Claim 1 is proved by using the naturality results of this section. For the let construct, \nwe show by induction on M that [M[v/x]] = (id, [v]); [M]. For 2 we use the following properties of .eld \nassignment and access: (asnf , p1); p2; drff = (asnf , p2); p2 : I \u00d7 [.] . [.] (asnf , p1) \u00d7 id; p2; \nasnf = id \u00d7 p2; asnf : I \u00d7 [.] \u00d7 [.] . 1 which are easily veri.able (the former one states that assigning \na .eld value and accessing it returns the same value; the latter that two assignments in a row have the \nsame effect as just the last one). The .nal claim follows by showing that the diagrams below  -#(Ix)-r \n. pi pn+1. -pi - ---. #( I ) - ---. I -. Ii; [G f xi : .i] = [G] . [.i]; [G f ai : Ii] = [G] ! !; nul \n [G f skip : void] = [G] - [G f null : I] = [G] . I, where nul : 1 . I . 1; - - = {* nul}; ' !; i (id,[M \n. [G] \u00d7 [. ' . [.]; [G f i : int] = [G] -. Z; [G f let x = M ' in M : .] = [G] ------]) ] [- - M] stpI \n' I ' ' S [G f (I)M : I] = [G] [- - M]-. I, where stpI ' I : I . I = {nul nul} . {a a S . PI ' I | S(a) \n= I};. I --- [G f M . M ' : int] = [G] ([M],[M ' ])-. Z, where . : Z\u00d7 Z . Z = {(i, j) (i . j)}; -------. \nZ\u00d7 Z . ' eq ' ([M],[M ]) [G f M = M : int] = [G] -------. I \u00d7 I -. Z, where eq = {(a, a)S 1S . P(I\u00d7I)Z} \n. {(a, b)S 0S . P(I\u00d7I)Z | a = b}; ' '' '' ([M],id)[[M ],[M ]] [G f if M then M ' else M : .] = [G] -----. \nZ\u00d7 [G] --------. [.]; (id,!;.I);~id\u00d7([M],p2)asn\u00d7id = f ' ' p2 [G f new(x : I; M) : I] = [G] - -----. \nI \u00d7 [G] \u00d7 I --------. I ' \u00d7 I \u00d7 I -----. 1 \u00d7 I -. I, .([M1],...,[Mn]) where [M] = [G] \u00d7 I -----------. \nI if M = {m1 : .x 1.M1, \u00b7 \u00b7 \u00b7 , mn : .x n.Mn}; ' asnf ' ([M],[M ]) [G f M.f := M : void] = [G] -------. \nI \u00d7 [.] --. 1; drff S [G f M.f : .] = [G] [- - M . I]--. [.], where drff : I . [.] = {a v S . PI[.] \n| S(a).f = v}; - -evm . . . - ([M],[M]) [G f M.m(M) : .] = [G] - -----. I \u00d7 [.x] --. [.], where [M] \n= ((([M1], [M2]), \u00b7 \u00b7 \u00b7 ), [Mn]). . -.-----. ~---.---~-. - (id,.I)= . . id\u00d7(p2;[M],id) . . =\u00d7id----. \n[G1 f S] = [G1] - ---. [G1]\u00d7(I ' \u00d7 I) -. I ' \u00d7([G1]\u00d7 I ) ----------. I ' \u00d7 I \u00d7([G1]\u00d7 I ) ---. (I ' \u00d7 \nI)\u00d7([G1]\u00d7 I ) ---.---.- ----.- . . . . (asnf ' \u00d7id);p2 .-(id,(id,[V ]))-. -. -. id\u00d7~-. - ----. (id\u00d7asnf \n);p1-. = --------. [G1] \u00d7 I --------. ([G1] \u00d7 I ) \u00d7 I \u00d7 [.] ---. ([G1] \u00d7 I ) \u00d7 (I \u00d7 [.]) - ------. [G1] \n\u00d7 I , -. -- . . -. '' ' where dom(S) = {a1, \u00b7 \u00b7 \u00b7 , an}, .I = (.I1 , \u00b7 \u00b7 \u00b7 , .In ), S(ai) : Ii, I = \nI1 \u00d7 \u00b7 \u00b7 \u00b7 \u00d7 In, I = I1 \u00d7 \u00b7 \u00b7 \u00b7 \u00d7 In, M = (M1, \u00b7 \u00b7 \u00b7 , Mn), -. . . - - Mi = S(ai) I MImps, [ \u00b7 \u00b7 \u00b7 , \n[Mn]), asnf ' = asnf ' \u00d7\u00b7 \u00b7 \u00b7\u00d7asnf ' , V = (V1, \u00b7 \u00b7 \u00b7 , Vn), Vi = S(ai) I HCnfs, [ M] = ([M1], 1 n V \n] = 1 ni 1 ni --. ([V1], \u00b7 \u00b7 \u00b7 , [Vn]), Vi = (f1 : v \u00b7 \u00b7 \u00b7 , fi ni : vi ), [Vi] = ([vi ], \u00b7 \u00b7 \u00b7 , [vi \n]), asnf = asnfi \u00d7\u00b7 \u00b7 \u00b7\u00d7asnfn , asnfi = asnf1 \u00d7\u00b7 \u00b7 \u00b7\u00d7asnf . i i , ni i i Figure 4. The semantic translation \nof IMJ. - . commute (we write A for [G] \u00d7 I ), that the copy of Mi differs from the original just in \nthe handle name (the one returned in the codomain of [Mi]), but the latter . -. id\u00d7[ -M]\u00d7id .-.-(~=,p2;pi)\u00d7id \n----. is hidden via composition with evm. The latter diagram stipulates ' - ' - -. I \u00d7A\u00d7[.x] I \u00d7 I \n\u00d7[.x](I ' \u00d7I)\u00d7Ii\u00d7[x.] that if we create xa with methods M, then calling ai on m is the same as calling \nMi on m. The latter holds because of the way that -. -. (-\u00d7evm);p2 asn id\u00d7([M],[Mi])\u00d7id f ' .Ii manipulates \ncalls inside the interaction, by delegating calls to -. -t ~=\u00d7id ----(asn--. f ' \u00d7evm);p2 t methods of \nai to Mi. . . ' - - I \u00d7 I \u00d7Ii\u00d7[.x] (I ' \u00d7I)\u00d7Ii\u00d7[.x] [.] Proposition 16 (Computational Soundness). For \nall f M : void, [G1]if M . then [M] = {* *} (i.e. [M] = [skip]). . . Proof. This directly follows from \nCorrectness. t - id\u00d7(p2;pi,s ' ). id\u00d7[M]\u00d7id . . -. - -- - ' - ' I ' \u00d7A\u00d7A I \u00d7A\u00d7Ii\u00d7[x.] I \u00d7 I \u00d7Ii\u00d7[x.] \nProposition 17 (Computational Adequacy). For all f M : void, if [M] = {* *} then M .. =\u00d7id id\u00d7s ' ~ t \nt -. ----. I ' \u00d7A\u00d7[.x] (I ' \u00d7I)\u00d7Ii\u00d7[.x] Proof. Suppose, for the sake of contradiction, that [M] = {* \n*}and M .. We notice that, by de.nition of the translation for . - - -. id\u00d7[M]\u00d7id (asn\u00d7evm);p2 f ' ' \n. t - . (--. - t to Correctness, if blocking constructs (castings and conditionals may block) and due \nM . were due to some reduction step being -. -(~=,p2;pi)\u00d7id----asnf ' \u00d7evm);p2 I \u00d7 I \u00d7[x.](I ' \u00d7I)\u00d7Ii\u00d7[.x] \n[.] blocked then the semantics would also block. Thus, M . must be due to divergence. Now, the reduction \nrelation restricted to all where s ' : A . [.x] a combination of values and assignments, and --rules \nbut METHODCL is strongly normalising, as each transition -.. . (id,.I ). = -(d\u00d7id\u00d7d);~ - ---I ' \u00d7 I \n-------. I ' \u00d7 A \u00d7 A decreases the size of the term. Hence, if M diverges then it must . = [G1] . [G1] \n\u00d7 involve in.nitely many METHODCL reductions and our argumentwith d = (id, id). The former diagram says \nthat, assigning method below shows that the latter would imply [M] = {E}. -. implementations M to object \nstores xa ' and calling Mi on some For any term G f N : . and a . A\\ dom(G), construct Ga f Na, -. ' \n method m is the same as assigning M to xa and evaluating instead where Ga = G l{a : VarI }, by recursively \nreplacing each subterm a new copy of Mi on m. The reason the diagram commutes is of N of the shape N \n' .m(Nx) with a.f := (a.f + 1); N ' .m(Nx). VarI is an interface with a sole .eld f : int. Observe that \neach s . [G f N] induces some s ' . [Ga f Na] such that a appears in s ' only in stores (and in a single \nplace in the initial move) and O never changes the value of a.f, while P never decreases the value of \na.f. We write [Ga f Na]a for the subset of [Ga f Na] containing precisely these plays. Then, take M0 \nto be the term let x = new(x : VarI ; ) in (Ma[x/a]; x.f), where x a fresh variable. Because ** . [M], \nwe get *j . [M0] for some j . Z. Consider now the in.nite reduction sequence of (\u00d8, M). It must have \nin.nitely many METHODCL steps, so suppose (\u00d8, M) -. * (S, M ' ) contains j + 1 such steps. Then, we obtain \n(\u00d8, M0) -. * (Sa, (M ' )a; a.f), with Sa(a).f = j + 1. By Correctness, we have that *j . [Sa, (M ' )a; \na.f] = [Sa]; (id\u00d7#); [(M ' )a; a.f]a. Since in [(M ' )a]a the value of a cannot decrease, and its initial \nvalue is j + 1 (as stipulated by Sa), we reach a contradiction. 5. Full Abstraction Recall that, given \nplays s, s ' , we call s an O-extension of s ' (written s =O s ') if s, s ' are identical except the \ntype information regarding O-names present in stores: the types of O-names in s may be subtypes of those \nin s ' . We shall write s =P s ' for the dual notion involving P-names, i.e., s =P s ' if s, s ' are \nthe same, but the types of P-names in s ' may be subtypes of those in s. Then, given X . {O, P } and \n.xed A, B, let us de.ne clX (s) = {s ' . S PAB | s ' =X s} and clX (s) = clX (s). We write P.|Gl. s.s \nfor P[G][.]. A play will be called complete if it is of the form mAY mB Y . Next we establish a de.nability \nresult stating that any complete play (together with other plays implied by O-closure) originates from \na term. Lemma 18 (De.nability). Let s . P.|Gl. be a complete play. There exists . ' . . and . ' |G f \nM : . such that [. ' |G f M : .] = clO(s). Proof. The argument proceeds by induction on |s|. For s = \nE, any divergent term suf.ces. For example, one can take . ' = . . {Div . (m : void . void)}, and pre-compose \nany term of type . with new(x : Div; m : .().m() ).m(). Suppose s = E. Then the second move can be a \nquestion or an answer. We .rst show how to reduce the former case to the latter, so that only the latter \nneeds to be attacked directly. Suppose Sq S1 S2 S3 s = q call o.m(xu)s1 ret o.m(v)s2 w s3, -. where o \n: I ' and .(I ' )(m) : IL . IR. Consider . ' = ---. ''' ' . . {I . (f : IL, m : IR . .)} and the following \nplay from P. ' |GlI '' : S ' S ' S ' ' Sq 1 ' ' 2 ' ' 3 ' s = q p s call p.m (v) s ret p.m (v) s3, 1 \n2 ----. where p . .(s), S ' = Si . S, S = {p . (I '' , f ' . u)} and i sj ' is the same as sj except \nthat each store is extended by S. If . ' |G f M ' : I ' satis.es the Lemma for s ' then, for s, one can \ntake - -. let xp = M ' in xp.m ' (y.m(xp.f ' )), where y refers to o, i.e., y is -. - . of the shape \nx. f , where x . dom G and f is a sequence of .elds that points at o in Sq. Thanks to the reduction given \nabove we can now assume that s . P.|Gl. is non-empty and Sq S0 S1 S2k s = q m m \u00b7 \u00b7 \u00b7 m , 01 2k where \nm0 is an answer. We are going to enrich s in two ways so that it is easier to decompose. Ultimately, \nthe decomposition of s will S1 S2k be based on the observation that the m1 \u00b7 \u00b7 \u00b7 m2k segment can be viewed \nas an interleaving of threads, each of which is started by a move of the form call p for some P-name \np. A thread consists of the starting move and is generated according to the following two rules: m2i \nbelongs to the thread of m2i-1 and every answer-move belongs to the same thread as the corresponding \nquestion-move. The .rst transformation of s brings forward the point of P-name creation to the second \nmove. In this way, threads will never create objects and, consequently, it will be possible to compose \nthem without facing the problem of object fusion. - . Suppose P (s) = pi and pi : Ipi . Let . ' = . . \n{IP . ----. S ' S ' S ' ' 01 2k fi : Ipi }. Consider s = (n, q)S ' m m \u00b7 \u00b7 \u00b7 m , where -. q 01 2k S ' \nq = Sq . {n . (IP , null)} and S ' i = Si . {n . -.- . (IP , pi )}.{pi . (Ipi , null) | Si(pi) unde.ned, \npi . P (s)}. Let G ' = {xn : IP } . G. Observe that s ' . P. ' |G ' l.. The second transformation consists \nin storing the unfolding play in a global variable. It should be clear that the recursive structure of \ntypes along with the ability to store names is suf\u00ad.cient to store plays in objects. Let Iplay be a signature \nthat makes this possible. This will be used to enforce the intended interleaving of threads after their \ncomposition (in the style of Innocent Factorization [5]). Let . '' = . ' . {History . play : Iplay } \nand G '' = {xh : History} . G. Consider S '' S '' S '' S '' q 01 2k s '' = (h, n, q)m m \u00b7 \u00b7 \u00b7 m 01 2k \nwith Sq '' = Sq ' . {h . (History, play . null)}, S '' = S2' i . {h . (History, play . s ' )}, 2i =m2i \nS '' = S2' i+1 . {h . (History, play . s ' )}. 2i+1 =m2i Observe that s '' . P. '' |G ' l.. S '' S '' \nNow we shall decompose m1 1 \u00b7 \u00b7 \u00b7 m2k 2k into threads. Recall that each of them is a subsequence of s \n'' of the form -. Sc Sr call p.m(u )t ret p.m(v) where the segment t contains moves of the form call \no or ret o for some o . O(s). We would now like to invoke the IH for each thread but, since a thread \nis not a play, we do so for the closely -u )Sc ' related play (h, n, q, . t v Sr . Let us call the resultant \nterm Mp,m, -. Next we combine terms related to the same p : Ip into . u ,Sc an object de.nition by -. \n- . - . Mp = new(x : Ip; m : .u .case(u , Sc)[Mp,m, u ,Sc]]). The case statement, which can be implemented \nin IMJ using nested . if s, is needed to recognize instances of -u and Sc that really occur in threads \nrelated to p. In such cases the corresponding term Mp,m, u ,Sc will be run. Otherwise, the statement \nleads to - . divergence. The term M for s can now be obtained by taking let xn = new(x : IP ; ) in let \nxh = new(x : History; ) in - -----. let xpi = Mpi in - ------. assert(q Sq ); xn.fi = xpi ; make(S '' \n0 ); play(m0) - -----. where xpi = Mpi represents a series of bindings (one for each P-name pi . P (s)), \nassert((h, n, q)S q '' ) is a conditional that converges if and only if the initial values of free G \nidenti.ers as well as values accessible through them are consistent with q and Sq respectively, make(S \n'' 0 ) is a sequence of assignments that set values to those speci.ed in S '' 0 (up-casts need to be \nperformed to ensure typability) and play(m0) is skip, i, null or, if m0 is a name,  it is a term of \nthe form (.)y. fx, where y is xn or (x : Ix) . G such that y. fxgives an access path to m0 in S '' 0 \n. We conclude with full abstraction results both in inequational and equational forms. For technical \nconvenience, we shall use a modi.ed (but equivalent) de.nition of contextual approximation. Lemma 19. \nLet G = {x1 : I1, \u00b7 \u00b7 \u00b7 , xk : Ik}, .|G f Mi : . (i = 1, 2), and . ' = . . {WrapG,I . (f : (I1, \u00b7 \u00b7 \u00b7 \n, Ik) . .)}. Then .|G f M1 ~ M2 if and only if, for all . '' . and . ' . '' , z : WrapG,I f test : void, \nif Ctest[M1] . then Ctest[M2] ., - . where Ctest[-] = let z = new(x : WrapG,I ; f : .xi .[-]) in test. \nProof. The Lemma holds because, on the one hand, it relies on contexts of a speci.c shape and, on the \nother hand, any closing context C[-] for Mi can be presented in the above form with test = C[z.f (x1, \n\u00b7 \u00b7 \u00b7 , xk)]. Given a term .|G f M : ., let us write [.|G f M : .]comp for the set of complete plays \nfrom [.|G f M : .]. In what follows, we shall often omit .|G, f for brevity. Theorem 20 (Inequational \nfull abstraction). Given .|G f Mi : . (i = 1, 2), we have .|G f M1 ~ M2 : . if and only if clP ([.|G \nf M1 : .]comp ) . clP ([.|G f M2 : .]comp ). Proof. The proof uses the following play transformation. \nGiven Sq Sa t = q s1a s2 . P.|Gl., we de.ne t . P. ' ,WrapG,Ilvoid as Sn .Sn .Sn *S.Sn n call n.f(q)Sq.Sn \ns1 ret n.f(a)Sa.Sn s2 , where . ' , WrapG,I are the same as in the above Lemma, Sn = {n . (WrapG,I, \u00d8)}, \ns .Sn stands for s in which each store was augmented by Sn and S is the store of the last move in t. \nIntuitively, t is the play that Ctest[-] needs to provide for a terminating interaction with t. (.) Let \ns . clP ([M1]comp ). Then there exists s ' . [M1]comp with s . clP (s ' ). Apply De.nability to s ' to \nobtain . '' , z : WrapG,I f test : void such that [test] = clO(s ' ). Because s ' . [M1]comp and Adequacy \nholds, we must have Ctest[M1] .. From M1 ~ M2 we obtain Ctest[M2] .. Hence, because of Soundness, there \nexists s '' . [M2]comp such that s '' . [test]. Since [test] = clO(s '), it follows that s '' . clO(s \n') and, consequently, s ' . clP (s '' ). Thus, ' ' '' '' s . clP (s ) and s . clP (s ). Hence, s . clP \n(s ) and, because s '' . [M2]comp , we can conclude s . clP ([M2]comp ). (.) Let Ctest[-] be such that \nCtest[M1] .. By Soundness, there exists s . [M1]comp such that s . [test]. Because [M1]comp . clP ([M1]comp \n) and clP ([M1]comp ) . clP ([M2]comp ), we also have s . clP ([M2]comp ). Thus, there exists s ' . [M2]comp \nsuch that s . clP (s ' ). Consequently, s ' . clO(s). Since s . [test], we also have s ' . [test]. Because \ns ' . [M2]comp and s ' . [test], by Adequacy, we can conclude that Ctest[M2] .. Example 3. Let us revisit \nExample 2. We have clP (s1) = s1 and clP (s2) = s2 . {*\u00d8 , n{nm.(Empty,\u00d8)}}, i.e. clP (s1) S clP (s2). \nThus, it follows from Theorem 20 that .|\u00d8 f M1 ~ M2 and ~ .|\u00d8 f M1 = M2. Theorem 21 (Equational full \nabstraction). Given .|G f Mi : . ~ (i = 1, 2), .|G f M1 = M2 : . if and only if [.|G f M1 : .]comp = \n[.|G f M2 : .]comp . ~ Proof. The preceding result implies that M1 = M2 if and only if clP ([M1]comp \n) = clP ([M2]comp ). We show that this implies [M1]comp = [M2]comp . Let s . [M1]comp . By clP ([M1]comp \n) = clP ([M2]comp ), it must be the case that s . clP ([M2]comp ), i.e., there exists s ' . [M2]comp \nsuch that s . clP (s ' ). Again, by clP ([M1]comp ) = clP ([M2]comp ), it follows that s ' . clP ([M1]comp \n), i.e., there exists s '' . [M1]comp such that ' '' ' ' '' s . clP (s ). So, we have s . clP (s ) and \ns . clP (s ), which '' '' '' implies s . clP (s ). However, s, s . [M1]comp , so s . clP (s ) '' ' entails \ns = s ''. Hence, s . clP (s ) and s . clP (s), and s = s follows. Because s ' . [M2]comp , we showed \ns . [M2]comp . The other inclusion is derived analogously. References [1] M. Abadi and L. Cardelli. A \ntheory of objects. Springer Verlag, 1996. [2] E. \u00b4 Abraham, M. M. Bonsangue, F. S. de Boer, A. Gruener, \nand M. Stef\u00adfen. Observability, connectivity, and replay in a sequential calculus ofclasses. In Proceedings \nof FMCO, 2004. [3] S. Abramsky, D. R. Ghica, A. S. Murawski, C.-H. L. Ong, and I. D. B.Stark. Nominal \ngames and full abstraction for the nu-calculus. In Proceedings of LICS, 2004. [4] S. Abramsky, R. Jagadeesan, \nand P. Malacaria. Full abstraction for PCF. Information and Computation, 163:409 470, 2000. [5] S. Abramsky \nand G. McCusker. Linearity, sharing and state: a fullyabstract game semantics for Idealized Algol with \nactive expressions.In Algol-like languages, pages 297 329. Birkha \u00a8 user, 1997. [6] S. Abramsky and G. \nMcCusker. Game semantics. In Logic and Computation: Marktoberdorf Proceedings. Springer-Verlag, 1998. \n[7] J. Alves-Foss, editor. Formal Syntax and Semantics of Java, volume 1523 of Lecture Notes in Computer \nScience. Springer, 1999. [8] J. Alves-Foss and F. S. Lam. Dynamic denotational semantics of Java.In Formal \nSyntax and Semantics of Java, pages 201 240. 1999. [9] G.M. Bierman, M.J. Parkinson, and A.M. Pitts. \nMJ: An imperative core calculus for Java and Java with effects. Technical Report 563,Computer Laboratory, \nUniversity of Cambridge, 2002. [10] H. Bj \u00a8 On notions of regularity for data orklund and T. Schwentick. \nlanguages. Theor. Comput. Sci., 411(4-5):702 715, 2010. [11] M. J. Gabbay and A. M. Pitts. A new approach \nto abstract syntax withvariable binding. Formal Aspects of Computing, 13:341 363, 2002. [12] J. M. E. \nHyland and C.-H. L. Ong. On Full Abstraction for PCF. Information and Computation, 163(2):285 408, 2000. \n[13] A. Jeffrey and J. Rathke. Java Jr: Fully abstract trace semantics for acore Java language. In Proceedings \nof ESOP, 2003. [14] A. Jeffrey and J. Rathke. A fully abstract may testing semantics for concurrent objects. \nTheor. Comput. Sci., 338(1-3):17 63, 2005. [15] S. N. Kamin and U. S. Reddy. Two semantic models of object-orientedlanguages. \nIn Theoretical Aspects of Object Oriented Programming, pages 463 495. MIT Press, 1994. [16] V. Koutavas \nand M. Wand. Reasoning about class behavior. In Proceedings of FOOL/WOOD, 2007. [17] J. Laird. A game \nsemantics of local names and good variables. In Proceedings of FOSSACS, 2004. [18] J. Laird. Game semantics \nfor higher-order concurrency. In Proceed\u00adings of FSTTCS, 2006. [19] J. Laird. Game semantics for call-by-value \npolymorphism. In Pro\u00adceedings of ICALP, 2010. [20] S. B. Lassen and P. B. Levy. Typed normal form bisimulation \nfor parametric polymorphism. In Proceedings of LICS, 2008. [21] R. Milner. Fully abstract models of typed \nlambda-calculi. Theoretical Computer Science, 4(1):1 22, 1977. [22] E. Moggi. Computational lambda-calculus \nand monads. In Proceed\u00adings of LICS, 1989. [23] A. S. Murawski and N. Tzevelekos. Algorithmic nominal \ngame se\u00admantics. In Proceedings of ESOP, 2011. [24] A. S. Murawski and N. Tzevelekos. Game semantics \nfor good generalreferences. In Proceedings of LICS, 2011. [25] J. Power and E. Robinson. Premonoidal \ncategories and notions of computation. Math. Struct. in Comput. Sci., 7:453 468, 1997. [26] N. Tzevelekos. \nFull abstraction for nominal general references. Logi\u00adcal Methods in Computer Science, 5(3), 2009. [27] \nN. Tzevelekos. Fresh-register automata. In Proc. of POPL, 2011.  \n\t\t\t", "proc_id": "2535838", "abstract": "<p>We consider an object calculus in which open terms interact with the environment through interfaces. The calculus is intended to capture the essence of contextual interactions of Middleweight Java code. Using game semantics, we provide fully abstract models for the induced notions of contextual approximation and equivalence. These are the first denotational models of this kind.</p>", "authors": [{"name": "Andrzej S. Murawski", "author_profile_id": "81100634552", "affiliation": "University of Warwick, Coventry, United Kingdom", "person_id": "P4383893", "email_address": "andrzej.s.murawski@gmail.com", "orcid_id": ""}, {"name": "Nikos Tzevelekos", "author_profile_id": "81319502901", "affiliation": "Queen Mary University of London, London, United Kingdom", "person_id": "P4383894", "email_address": "nikos.tzevelekos@qmul.ac.uk", "orcid_id": ""}], "doi_number": "10.1145/2535838.2535880", "year": "2014", "article_id": "2535880", "conference": "POPL", "title": "Game semantics for interface middleweight Java", "url": "http://dl.acm.org/citation.cfm?id=2535880"}