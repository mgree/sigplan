{"article_publication_date": "01-08-2014", "fulltext": "\n Verifying Eventual Consistency of Optimistic Replication Systems Ahmed Bouajjani Constantin Enea Jad \nHamza LIAFA, Univ Paris Diderot, Sorbonne Paris Cit\u00b4 e, Paris, France. {abou,cenea,jhamza}@liafa.univ-paris-diderot.fr \nAbstract We address the veri.cation problem of eventual consistency of optimistic replication systems. \nSuch systems are typically used to implement distributed data structures over large scale networks. We \nintroduce a formal de.nition of eventual consistency that applies to a wide class of existing implementations, \nincluding the ones using speculative executions. Then, we reduce the problem of checking eventual consistency \nto reachability and model checking problems. This reduction enables the use of existing veri.cation tools \nfor message-passing programs in the context of verifying optimistic replication systems. Furthermore, \nwe derive from these reductions decision procedures for checking eventual consistency of systems implemented \nas .nite-state programs communicating through unbounded unordered channels. Categories and Subject Descriptors \nTheory of Computation [Log\u00adics and meanings of programs]: General Keywords message passing concurrency, \nmodel checking, static program analysis 1. Introduction Optimistic data replication is a key technology \nfor achieving high availability and performance in distributed systems. It consists of a set of techniques \nfor maintaining multiple copies of the same data, called replicas, on different sites in a large-scale \nnetwork. Many interactive collaborative applications, ranging from social networks to collaborative spaces \nand online shops, use this technology, in order to increase the quality of their services. In fact, they \nuse this technology even though the latter lets replicas temporarily diverge, and thus users may see \ninconsistent data from time to time. This is due to the fact that ensuring strong consistency (i.e., \nmaking all replicas always consistent) which can only be achieved by synchro\u00adnizing all replicas after \neach update is practically infeasible, and therefore users generally prefer high responsiveness and \navailability to strong consistency. In fact, systems implementing optimistic data replication, called \noptimistic replication systems (ORS), can only ensure weak consistency notions, and one of the important \nissues in this context is to determine what are precisely these notions. By the Permission to make digital \nor hard copies of all or part of this work for personal or classroom use is granted without fee provided \nthat copies are not made or distributed for pro.t or commercial advantage and that copies bear this notice \nand the full citation on the .rst page. Copyrights for components of this work owned by others than ACM \nmust be honored. Abstracting with credit is permitted. To copy otherwise, or republish, to post on servers \nor to redistribute to lists, requires prior speci.c permission and/or a fee. Request permissions from \npermissions@acm.org. POPL 14, January 22 24, 2014, San Diego, CA, USA. Copyright c &#38;#169; 2014 ACM \n978-1-4503-2544-8/14/01. . . $15.00. http://dx.doi.org/10.1145/2535838.2535877 CAP theorem [10], ensuring \nsequential consistency or linearizability together with availability and partition tolerance is not possible, \nand thus, the correctness criteria adopted for ORS must in general be weaker than these ones (that are \nmore suitable for shared memory systems). One of the most popular correctness criteria for ORS (and which \nis in some sense the weakest that can be accepted) is eventual consistency. Many ORS that are widely \nused in practical applica\u00adtions, e.g., Amazon Simple Storage Service and Google App Engine Datastore, \n(are supposed to) satisfy eventual consistency. Optimistic replication systems, such as those mentioned \nabove, are extremely complex and hard to get right, and therefore, there is a real need in developing \nautomated formal methods for reasoning about their behaviors and verifying their correctness w.r.t. criteria \nsuch as eventual consistency. However, the .rst issue to be addressed to achieve that is de.ning precisely \nand formally these criteria that are still not well understood in general. For instance, many works adopt \ndifferent variants of what is called eventual consistency. Then, the second issue to address is (1) investigating \nthe limits of decidability and complexity bounds for checking these criteria, and (2) designing effective \nalgorithmic methods for their veri.cation. In this paper, we address both of these semantical and algorithmic \nissues for eventual consistency. We introduce a formal de.nition of eventual consistency that is applicable \nto a wide class of ORS, including systems with speculative executions and roll-backs, and we provide \nan approach for its automatic veri.cation based on effective reductions to reachability and model-checking \nqueries. In the following, we explain in more details the context and the nature of our contributions. \nOptimistic replication systems: Many variants of ORS have been de.ned, e.g., [2, 7, 15 18, 20, 23]. In \ngeneral, they are based on the following scenario: (1) users submit operations (i.e., self-contained \nupdates or queries) to one of the sites, (2) operations are immediately applied to the local replica \nto let users continue working based on the effect of those operations, and (3) in the background, sites \nexchange and apply remote operations. Actually, this is the scenario used by operation transfer systems. \nThere also exist state transfer systems, where the sites exchange the contents of their replicas. Although \nthey may use different techniques, state transfer systems can be emulated by operation transfer systems, \nwhere the allowed operations are only to read and overwrite an entire object [20]. Therefore, we focus \nin this paper on operation transfer systems. The communication between sites is usually based on epidemic \npropagation, which allows every operation to be communicated to all sites independently of the communication \ntopology. When applying remote operations several critical components come into play (see Saito and Shapiro \n[19] for a survey): scheduling policies, used to order operations in a way expected by users, and to \nmake sites eventually agree on some ordering, (a generic scheduling policy is to label operations by \ntimestamps and execute them in the order of their timestamps),  con.ict detection, used to detect operations \nthat are submitted concurrently by users to different sites and touch the same data (e.g., two requests \nto a room-booking system that concern the same room and the same time slot),  con.ict resolution, used \nto de.ne the effect of a set of con.icting operations (e.g., in the room-booking system, the system might \nrequire that each request comes with some alternative time slots, and in the case of two con.icting requests, \none will get an alternative time slot),  commitment protocols, used to make sites agree about the order \nin which they execute the operations.  In particular, a large class of ORS, e.g., Bayou [23], C- Praxis \n[18], IceCube [16], Telex [2], use speculative executions, i.e., operations are tentatively applied as \nthey are received from the user or from the other sites. In such systems, the sites may receive the operations \nin different orders and thus, they may have to repeatedly roll-back some operations as they gradually \nconverge towards a .nal order (for example, in the case of Bayou, the .nal order is decided by a designated \nprimary site). Eventual consistency: In its simplest formulation1, eventual con\u00ad sistency requires that \nif the users stop submitting operations, then all the sites will eventually reach a consistent state \n(i.e., they agree on the way operations should be executed). However, as mentioned in Burckhardt et al. \n[6], this formulation is too loose and the reason is twofold. First, this de.nition does not impose some \nnotion of correctness for the operations executed by the system, i.e., the fact that they should satisfy \nsome well-de.ned speci.cation. Second, this property offers no guarantees when the system never stops, \ni.e., when the users continuously submit new operations. For that, eventual consistency should take into \naccount in.nite executions of the system involving in.nitely many operations. In fact, works investigating \nthe formal de.nition of eventual consistency (and correctness criteria for distributed data structures \nin general) are still very rare. To our knowledge, Burckhardt et al. [6] is the .rst attempt to provide \na formal framework for reasoning about eventual consistency. However, the proposed formalization in that \npaper does not allow to reason about ORS, that use speculative executions and roll-backs (as the authors \nof that paper mention). So, the .rst issue that we address in this paper is providing a general formal \nde.nition of eventual consistency, that is applicable to a wider class of ORS. We de.ne eventual consistency \nas a property over traces. A trace models the view of an external observer of the system; it is a set \nof sequences of operations, where one sequence consists of all the operations submitted to one site. \nIt abstracts away implementation details such as the messages exchanged between sites. Eventual consistency \nis de.ned as the composition of a safety property that speci.es the correct effects of the operations, \nand a liveness property guaranteeing that sites will eventually agree on the order in which the operations \nshould be executed. Let us look closer to each of these components. Safety: Following the scenario described \nearlier, the return value of an operation o submitted to some site N depends on (1) the operations received \nand scheduled by N before o, and the order in which these operations are executed, (2) the con.ict detection \nand con.ict resolution policies applied by N, and (3) the behavior of the executed operations2 . A trace \nis called safe iff the return values of all its operations are correct in a sense described hereafter. \nFirst, the correctness is de.ned with respect to a speci.cation that, roughly, models 1Also called, \nquiescent consistency [12] 2In this paper, we make the simplifying assumption that replicas are copies \nof the same object. In general, a replica may be composed of copies of multiple objects but most replication \nsystems manage each object independently. the expected outcome of executing a poset of operations on \na single site. Concretely, a poset of operations models a schedule, where incomparable elements are considered \nto be in con.ict (i.e., submitted concurrently to different sites) and executing a poset of operations \ninvolves the actual implementations of the operations together with the con.ict resolution policy (that \nde.nes the effect of concurrently submitted operations). A speci.cation S associates return values of \noperations with posets of operations. Intuitively, the return value r of an operation o is associated \nwith some poset . if o returns r whenever it is executed after the poset of operations .. More precisely, \na trace t is safe w.r.t a speci.cation S iff for each operation o, there exists a poset li[o] of operations \nin t , which is associated by S with the return value of o. The poset li[o] is called the local interpretation \nof o. Additionally, because of physical constraints, we de.ne an executed-before relation eb over ' the \noperations in the trace such that (o, o) . eb iff o' belongs to the local interpretation of o, and we \nrequire that the union of eb with the program order relation is an acyclic relation. Concretely, ' (o, \no) . eb iff o is an operation submitted to some site N and o' is scheduled by N before o while the local \ninterpretation li[o] models the result of applying the scheduling and con.ict detection policies. Note \nthat, for ORS that use speculative executions and roll\u00adbacks, the local interpretations associated with \ntwo operations are arbitrarily different, even if the two operations are submitted to the same site. \n(The issue of convergence is left to the liveness part.) Liveness: The liveness part of eventual consistency \nrequires that there exists some partial order relation gi (for global interpretation) over all the operations \nin an in.nite trace, such that it is possible to choose some local interpretations satisfying the safety \nproperty, which converge towards gi. The convergence is formally stated as follows: for any pre.x P of \ngi (a pre.x of a poset is a restriction of the poset to a downward closed subset) there exists only .nitely \nmany local interpretations for which P is not a pre.x. This corre\u00adsponds to the informal de.nition given \nin Saito and Shapiro [19]. Verifying eventual consistency: After providing a formal and general de.nition \nof eventual consistency, we address the problem of checking whether a given ORS satis.es eventual consistency \nw.r.t some given speci.cation. Our aim is twofold. First, we investigate the question of de.ning a generic \nalgorithmic veri.cation method for eventual consistency which is independent from the class of programs \nused for the implementation. This is actually a hard problem since, regardless of the complexity of the \nimplementation, eventual consistency requires reasoning about nested quanti.ers over (in.nite) partial \norders. Then, our second goal is to derive from the generic veri.cation method decidability and complexity \nresults for particular, as large as possible, classes of implementations. Let us then examine each of \nthese points. From eventual consistency to model-checking problems: We show that the static veri.cation \nof (the safety and liveness parts of) eventual consistency can be reduced to reachability and model checking \nproblems. This reduction allows to use any existing tools for exact/approximate veri.cation of concurrent \n(message-passing) programs in the context of verifying eventual consistency. The reduction is done by \nde.ning a monitor which, when composed in parallel with the system, reaches some speci.c error state \nor violates some temporal logic formula (in LTL extended with Presburger predicates) if and only if there \nexists an execution of the system that violates eventual consistency. The monitor is a sequential program \nthat observes, in a centralized way, the operations submitted to all the sites in the network. Therefore, \nits observations are interleavings of operations performed by the ORS. Reasoning about such centralized \nobservations is possible since we are concerned with the static (of.ine) veri.cation of ORS. The monitor \nis the parallel composition of two monitors, one for checking the safety part in eventual consistency \nand one for checking the liveness part. These monitors are abstractly de.ned as state transition systems \nthat take a step each time an operation is executed in the system. Actually, they can be seen as a way \nof instrumenting every operation performed by the system in order to obtain a program on which the reachability \nand model-checking queries mentioned above are applied.  For these reductions, we assume that the operations \nare instances of a .nite set of methods with a .nite set of possible input/return values. However, system \nimplementations can still be very complex: users are allowed to submit unboundedly many operations, and \nsystems can use unbounded domains for timestamps or unbounded channels for communication. The constructions \nwe provide are based on subtle arguments. Indeed, one of the issues is that return values of operations \ndepend on arbitrarily large sets of prior operations, and unbounded number of possible orders between \nthese operations. The effect of each operation depends on the local view of the site N to which it is \nsubmitted. The local view consists of the set of operations known by N and the order in which N believes \nthey were executed by other sites. In fact, when considering the safety part, we only need to check that, \nfor each operation, such a local view exists and it is consistent with the return value of the operation. \nUnlike for the liveness part, we do not need to check the convergence of the local views toward a global \nview which is a partial order over the in.nite set of operations in the trace. In order to know if such \nlocal views exist, it is suf.cient to count the number of methods previously issued. A careful analysis \nof the de.nition allows to show that it is possible to count only up to some .nite bound, and thus only \nconsider the minimal posets in the speci.cation. Therefore, the problem of .nding a violation for the \nsafety property can be reduced to some bounded counting argument where the monitor counts the number \nof times the system executes each of the methods and then compares the counter values to the number of \nmethods in the minimal posets of the speci.cations. This raises the problem of computing the number of \nmethods in the minimal posets of the speci.cation. In order to address this problem, we need to consider \nsome concrete formalism for describing the speci.cations. Therefore, we introduce a class of automata \nfor describing speci.cations of ORS. Essentially, each poset of operations in the speci.cation is abstracted \ninto a sequence of multisets of methods (each method in these multisets corresponds to the method instantiated \nby an operation in the poset) which is then recognized by an automaton, called multiset automaton, where \nthe transitions, instead of being labeled by symbols as in the case of automata over words, are labeled \nby Presburger formulas. The sequence of multisets corresponds to a decomposition of the poset in levels, \nused in algorithms for parallel tasks scheduling [22], where a level is a set of elements for which the \nlength of the longest path to a maximal element is the same. These automata offer a good compromise between \ntractability and expressive power. In particular, they allow to de.ne a wide-class of speci.cations, \ne.g., speci.cations of replication systems that use the Last Writer Wins con.ict resolution policy [15] \nor commutative con.ict resolution policies like in the case of the CRDTs [7, 20]. We then prove that \nfor speci.cations recognized by multiset automata, it is possible to effectively compute the number of \nmethods in the minimal posets. For the liveness part of eventual consistency, we consider again a parallel \ncomposition between the system and a monitor that counts the number of times the system executes each \nof the methods. We show that the problem of .nding a violation can be reduced to the problem of checking \nthat the monitor reaches a state where its counters satisfy some speci.c property, and from there on, \nthe methods executed by the system return only some particular set of values. The property that the counters \nshould satisfy is quite complex; it characterizes the number of methods occurring .nitely\u00adoften in the \nlimit of an in.nite sequence of posets belonging to the speci.cation. However, we show that for speci.cations \nrecognized by multiset automata, this property is de.nable by a Presburger formula, which can be effectively \ncomputed. Decidability and complexity: Based on these reductions, we de.ne decision procedures for checking \neventual consistency of ORS, which are de.ned as the parallel composition of a .xed set of boolean programs \ncommunicating through unbounded unordered channels. Indeed, we consider that it is natural in our context \nto assume that channels are unordered since in general large-scale networks offer no guarantees on the \norder in which messages arrive even if they are sent by the same site. These decidability results are \nbased on the fact that (1) this class of systems can be modeled by Vector Addition Systems with States \n(VASS, for short), since unbounded channels can be encoded as counters, and (2) the problems to which \nwe reduce checking the safety, resp., the liveness, part of eventual consistency are decidable for VASS. \n2. Preliminaries Sets, relations: For a set A, P(A) denotes the set of all subsets of A. Let R . A \u00d7 \nB be a relation. For any y . B, R-1(y) denotes the set of elements x . A such that (x, y) . R. The notation \nis extended to subsets of B as usual. Sequences: Let S be a .nite alphabet. The set of all .nite, resp., \nin\u00ad.nite, sequences over S is denoted by S * , resp., S.. Also, S8 = S * . S.. A set of sequences is \ncalled pre.x-closed if the pre.x of any sequence in the set is also in the set. Posets: Let (A, =) be \na possibly in.nite partially-ordered set (poset, for short). A path of length n in (A, =) is a sequence \nof elements x0,x1,. . .,xn such that for all 0 = i = n - 1, xi = xi+1. The downward closure of B . A \nw.r.t. =, denoted by .=B, is the set of all elements in A smaller than B, i.e., .=B = =-1(B). Similarly, \nthe upward closure of B . A w.r.t. =, denoted by .=B, is the set of all elements in x . A such that y \n= x, for some y . B. The superscript may be omitted when the partial order = is clear from the context. \nWe say that B is downward closed, resp., upward closed, w.r.t. = iff B = .B, resp., B = .B. The poset \n(A1, =1) is called a pre.x of (A2, =2), denoted by (A1, =1) : (A2, =2), iff A1 . A2, =1 is the intersection \nof =2 and A1 \u00d7 A1, and A1 is downward closed w.r.t. =2. We say that a poset (A, =) is pre.x-founded iff \nfor all .nite sets B . A, . B is .nite. Labeled posets: A S-labeled poset is a triple (A, =, e), where \n(A, =) is a poset and e : A . S is a function that labels each element of A with a symbol in S. The set \nof all S-labeled posets is denoted by PoSetS. Given S ' . S, the projection of a S-labeled poset (A, \n=, e) over S ' is the S '-labeled poset (B, = ' , e ' ), where B is the subset of A containing all the \nelements labeled by symbols in S ', i.e., B = {a | e(a) . S ' }, and = ' , resp., e ' are the projections \nof =, resp., e over B \u00d7 B, resp., B. The Parikh image of a possibly in.nite S-labeled poset . = (A, \n=, e) is the multiset .S(.) : S . N . {.} mapping each symbol a . S to the number of elements x of A \nsuch that e(x) = a. If some symbol a occurs in.nitely often then .S(s)(a) = .. Note that the Parikh image \nof a labeled poset . can be also interpreted as the multiset of symbols in .. The notion is extended \nto sets of labeled posets as usual. A labeled poset .1 = (A1, =1, e1) is called a pre.x of .2 = (A2, \n=2, e2) iff the poset (A1, =2) is a pre.x of (A2, =2) and e1(y) = e2(y), for all y . A1. We also say \nthat .2 is a completion of .1. This is denoted by .1 : .2. Moreoever, if e2(A2 \\ A1) . S ' where S ' \n. S, we say that .2 is a S '-completion of .1. Two labeled posets (A1, =1, e1) and (A2, =2, e2) are isomor\u00adphic \niff there exists a bijection h : A1 . A2 such that for all x, y . A1, x =1 y iff h(x) =2 h(y) and e1(x) \n= e2(h(x)). A set of labeled posets A is called isomorphism-closed iff any labeled poset isomorphic to \nsome labeled poset in A belongs also to A.  Functions: Let A and B be two sets. We denote by A . B the \nset of functions from A to B. For a function f . A . B, and a . A, b . B, f[a . b] is the function which \nmaps all elements a ' a to f(a = {a1, . . . , an}, = ' ), and which maps a to b. If A and b1, . . . , \nbn are (possibly equal) elements of B, we denote by (a1 . b1, . . . , an . bn) the function f . A . B \nwhich maps ai to bi for all 1 = i = n. Likewise, for b . B, we denote by (a . A . b) the function which \nmaps every a . A to b. For functions f : A . N, and g : A ' . N with A ' . A, f + g : A . Nmaps each \na ' . A ' to (f + g)(a ' ) = f (a ' ) + g(a ' ) and each a . A \\ A ' to (f + g)(a) = f(a). 3. Modeling \noptimistic replication systems A concrete execution of an ORS is modeled as a trace, that abstracts away \nmany implementation details. A trace is a poset of operations, where all the operations submitted to \nthe same site are totally ordered. We suppose that operations are instances of a .xed set of methods. \nFor static veri.cation of eventual consistency, an ORS is viewed as a pre.x-closed set of sequential \nobservations. These are sequences of pairs of the form (N, o), where N is a site name and o is an operation. \nSuch a pair denotes an operation o submitted to site N. The trace represented by a sequential observation \n. contains all the operations in . such that any two operations submitted to different sites are incomparable \nand the order between any two operations submitted to the same site is consistent with the order in which \nthese two operations appear in the sequence .. Let M be the set of method names and D the domain of return \nvalues. For simplicity, we suppose that input parameters are encoded in the method names. A method synopsis \nis a pair m r r, where m . M and r . D. We denote by Mr D the set of all method synopses. An operation \no is a pair (i, a) formed of an identity i . N and a method synopsis a . Mr D. We denote by O the set \nof all operations. Given a method synopsis a = m r r, we let meth(a) = m, rval(a) = r, and given an operation \no = (i, m r r), we let id(o) = i, meth(o) = m, rval(o) = r, and syn(o) = m r r. An operation o = (i, \nm r r) may be called an m-operation or an m r r-operation. Also, given a set of method names M . M (resp., \na set of method synopses Y . Mr D) o is called an M \u00adoperation (resp., Y -operation) iff m . M (resp., \nm r r . Y ). A trace t is a (possibly in.nite) poset (O, po), where O . O and po, called the program \norder, is a disjoint union of a set of pre.x-founded irre.exive total orders over O. We assume that a \ntrace does not contain two operations with the same identity. The set of operations, resp., the program \norder, in a trace t are denoted by Ot , resp., pot . Given a .xed set N of site names, a sequential observation \n(observation, for short) of an ORS is a possibly in.nite sequence over ON = N \u00d7 O (we assume that such \na sequence does not contain two operations with the same identity). A sequential observation models the \nview of a centralized sequential observer over the concrete executions of the replication system. Then, \nan optimistic replication system I is a state machine that produces a pre.x-closed subset of (ON )8. \nBy an abuse of notation, the set of sequences produced by I is denoted also by I. Given an observation \n., let O. denote the set of operations that occur in ., i.e., the set of operations o for which there \nexists N . N such that (N, o) occurs in .. Given an observation . . (ON )8, the trace of . is de.ned \nby trace(.) = (O, po), where O = O. and  po = {(o, o ' ) | .N . N s.t. (N, o) occurs before (N, o ' \n) in .}  Next, we give examples of ORS that we use throughout the paper. Example 1 (One-value Register). \nThe One-Value Register (Regis\u00adter) maintains an integer register and supports the set of methods MR = \n{wr(i) | i . N} . {rd}, where wr(i) assigns value i to the register and rd reads the current value of \nthe register. A method rd can return any value from Nwhile the methods wr(i) return some special value \nT, i.e., the domain of return values is DR = N. {T}. We thus have Mr DR = {wr(i) r T, rd r i | i . N}. \nExample 2 (Multi-Value Register). The Multi-Value Register [7, 14] (MV-Register) maintains an integer \nregister and supports the same set of methods as the Register. A method rd can return any set of values \nfrom N. Thus, the domain of return values of the MV-Register is DMV-R = P(N) . {T} and its set of method \nsynopses is Mr DMV-R = {wr(i) r T, rd r I | i . Nand I . N}. Example 3 (Observed-Remove Set). The Observed-Remove \nSet [20] (OR-Set) maintains a set of integers over which one can apply the set of methods MOR-S = {add(i), \nrem(i), lookup(i) |i . N}, where add(i) adds the integer i to the set, rem(i) re\u00admoves i from the set, \nand lookup(i) tests if the integer i is in the set. We assume that the methods add and rem return some \n.xed value T, while lookup(i) can return 1 or 0. Thus, the set of return values is DOR-S = {1, 0, T} \nand Mr DOR-S = {add(i) r T, rem(i) r T, lookup(i) r 1, lookup(i) r 0 | i . N}. 4. Eventual consistency \nIn this section, we introduce a formal de.nition for eventual consis\u00adtency, whose main artifacts are \npresented hereafter. Speci.cation: In the context of shared-memory, resp., ORS, the correctness of the \noperations associated to some object usually involves some mechanism of con.ict resolution in order to \nde.ne the effect of a set of operations executed by different threads, resp., submitted concurrently \nat different sites. In the case of shared\u00admemory systems, the con.ict resolution mechanism is usually \nspeci.ed by the notion of linearizability [13], which requires that the effect of a set of concurrent \noperations (that overlap in time) is the same as the one of a sequential execution of the same set of \noperations. In the context of ORS, where each site maintains its own copy of the object, some more general \nmechanisms of con.ict resolution are required. To specify both the sequential semantics of the operations \nand the con.ict resolution mechanisms we use posets of operations instead of sequences of operations, \nas in the case of linearizable objects. We don t use a total order because, in general, it is unfeasible \nthat all sites agree on a total order of operations, and sometimes even unnecessary, in case of commutative \noperations for instance. Moreover, the mechanisms used to detect con.icting (causally unrelated) operations \nare not always precise. We assume that the speci.cation can t distinguish between two posets that are \nidentical (i.e., isomorphic) when ignoring the identities and the return values of the operations. The \ninsensitivity to return values is motivated by the fact that, in real implementations, the sites exchange \noperations without their return values (in such systems, it is not expected that an operation returns \nthe same value when executed at different sites). A speci.cation associates to each method synopsis m \nr r an isomorphism-closed set of M-labeled posets. The closure under isomorphism and the fact that we \nuse labeled posets model the fact that the speci.cation doesn t observe identities and return values. \nThe fact that a poset . is associated to m r r means that any site that sees the set of operations in \n. in that order reaches a state where the call to m produces the value r. De.nition 1 (Speci.cation). \nA speci.cation is a function S : Mr D . P (PoSetM), where for each method synopsis a . Mr D, S(a) is \nan isomorphism-closed set of M-labeled posets.  SR(rd C 0) : wr(0) wr(2) SMV-R(rd C {0, 1, 2}) : wr(1) \nrd wr(2) wr(0) rd wr(0) rd wr(4) wr(3) rd wr(1) wr(0) wr(2)  wr(1) wr(0) (b) (a) SOR-S(lookup(1) \nC 1), SOR-S(lookup(0) C 0) : add(1) rem(0) add(1) rem(1) rem(1) add(0) rem(1) rem(0) rem(0) add(1) \n(c) Figure 1: Examples of labeled posets belonging to (a) the speci.ca\u00adtion of the Register (b) the speci.cation \nof the MV-Register, and (c) the speci.cation of the OR-Set. The order relations are de.ned by arrows: \nan arrow from an element x to some element y means that x is ordered before y. We omit arrows implied \nby transitivity. We give several examples of speci.cations for the replication systems mentioned in the \nprevious section. Example 4 (Register speci.cation). The speci.cation SR of the Register is given by: \n(1) for every a = wr(i) r T, SR(a) is the set of all MR-labeled totally-ordered sets, and (2) for every \na = rd r i, SR(a) is the set of all MR-labeled totally-ordered sets where the maximal element labeled \nby a write is labeled by wr(i). Figure 1a contains two examples of totally-ordered sets in SR(rd r 0). \nExample 5. [MV-Register speci.cation] The speci.cation SMV-R of the MV-Register is de.ned by: (1) for \nany a = wr(i) r T, SMV-R(a) is the set of all MR-labeled posets and (2) for any a = rd r I , SMV-R(a) \nis the set of all MR-labeled posets . such that i . I iff there exists a maximal element labeled by wr(i) \nin the projection of . over the elements labeled by write methods {wr(i) | i . N}. Figure 1b contains \nan MR-labeled poset in SR(rd r {0, 1, 2}). Example 6. [OR-Set speci.cation] The speci.cation SOR-S is \ngiven by: (1) for any a = add(i) r T or a = rem(i) r T, SOR-S(a) is the set of all MOR-S-labeled posets, \nand (2) for any a = lookup(i) r 1, resp., a = lookup(i) r 0, SOR-S(a) is the set of all MOR-S-labeled \nposets . such that the projection of . over the elements labeled by add(i) or rem(i) contains a maximal \nelement labeled by add(i), resp., contains no maximal element labeled by add(i). Figure 1c contains an \nexample of a labeled poset that belongs to both SOR-S(lookup(1) r 1) and SOR-S(lookup(0) r 0). Local \ninterpretation: The return value of some operation o sub\u00admitted to some site N depends on the set of \noperations applied at N before o and on the the effect of applying the scheduling and con.ict detection \npolicies over this set of operations. Taken together they can be represented by a poset of operations, \ncalled the local interpretation of o and denoted by li[o]. Because of speculative exe\u00adcutions, one has \nto consider a local interpretation for each operation o in the trace (the order in which known operations \nare executed can change at any time). The local interpretations de.ne another relation over the oper\u00adations \nin the trace, called executed-before and denoted by eb. We say that some operation o ' is executed before \nanother operation wr(0) wr(1) rd t 1 rd t 2 rd t 1 rd t 0 wr(2) wr(1) rd t 0 wr(2) (a) (b) Figure 2: \nTraces of the Register. For simplicity, the return values of the wr operations and the ids of each operation \nare omitted. The program order is de.ned by the vertical lines, from top to bottom. o, i.e., (o ' , o) \n. eb, iff o ' belongs to the local interpretation of o. For example, Figure 2a pictures a trace of the \nRegister, where the arrows de.ne a possible eb relation. Note that the wr(1)-operation is executed before \nthe .rst occurrence of rd r 0 but not before the second occurrence of rd r 0. We say that the return \nvalue of some operation o is correct iff the labeled poset de.ned by li[o], where every operation o ' \nis labeled by meth(o ' ), belongs to S(syn(o)). Then, a trace t is safe iff the return values of all \noperations in t are correct. For example, in the case of the .rst rd r 0-operation in Figure 2a, one \ncan choose to order the wr(1)-operation before the wr(0)\u00adoperation. This local interpretation de.nes \nan MR-labeled poset, which belongs to the speci.cation of the Register, SR(rd r 0). Similarly, one can \nshow that all return values in Figure 2a are correct. Because of physical constraints, eb must not create \ncycles together with the program order. For example, the trace in Figure 2b could be one of the Register \nif the relation eb is de.ned by the arrows in the .gure (we assume that the initial value of the register \nis 0). However, this means that the site executing the operations in the left received a message from \nthe other site containing the wr(1) operation and this message was created after rd r 2 has .nished. \nThus, in real time, rd r 2 has happened before the wr(2)-operation, which contradicts the eb relation. \nGlobal interpretation: The fact that the sites will eventually agree on the way operations should be \nexecuted is de.ned as a liveness property over in.nite traces of the system. Given an in.nite trace t, \nwe consider a partial-order over all the operations in t , called the global interpretation and denoted \nby gi. The liveness property requires that the local interpretations de.ned for the operations in t converge \ntowards gi. More precisely, for any .nite pre.x P of gi, the number of local interpretations for which \nP is not a pre.x is .nite. Note that this implies that any operation o in the trace is executed before \nall operations in t , except some .nite set. A system that satis.es only this property will be called \nweak eventually consistent. We will require that gi satis.es some sanity condition, i.e., that it is \npre.x-founded, which basically, means that every operation can be executed after only .nitely many other \noperations. For example, let us consider the in.nite trace in Figure 3. We consider a global interpretation \ngi, which in this case is a total order, that arranges the write operations in a sequence of the form \n( wr(0) wr(1) )., and keeps the same order as in the trace for the wr(0) operations (resp., the wr(1) \noperations). In the following, we ignore the order between the rd-operations because they are not important \nfor justifying the correctness of the return values. We show that it is possible to choose local interpretations \nfor the rd r 0 operations such that the return values are correct, and such that the orders converge \ntowards gi. In a similar way, this can be shown for all the other operations in the trace. For each rd \nr 0-operation o, the local interpretation li[o] is the poset that consists of all the write operations \nthat occur before o (i.e., if o is the ith occurrence of rd r 0 then the poset li[o] contains  wr(0) \n wr(1) wr(1), wr(0) rd t 0 rd t 1 wr(0) wr(1) wr(0), wr(1), wr(1), wr(0) rd t 0 rd t 1 wr(0), wr(1), \nwr(0), wr(1), wr(1), wr(0) . . . (wr(0) wr(1))* wr(1) wr(0) Figure 3: An in.nite trace of Register, where \none site executes ( wr(0) rd r 0 ). and another site executes ( wr(1) rd r 1 ). . the jth occurrence \nof wr(1) and wr(0), for all j < i), totally ordered in a sequence of the form (wr(0) wr(1)) * wr(1) wr(0) \nconsistent with the program order. The relation eb is pictured by arrows in Figure 3. De.ned as such, \nthe local interpretations converge towards the global interpretation gi. We now give the de.nition of \neventual consistency. For any poset li[o] = (A, =) as above, liM[o] denotes the labeled poset li[o] where \nevery operation is labeled by the corresponding method name in M, i.e., liM[o] = (A, =, meth). De.nition \n2. [Safety, (Weak) Eventual consistency] A trace t = (O, po) is called eventually consistent w.r.t. a \nspeci.cation S iff: . gi an irre.exive partial order over O . o . O . li[o] an irre.exive poset. GIPF \n. TH INAIR . RVA L . EV E N T UAL It is said to be weak eventually consistent w.r.t S iff EV E N T UAL \nis replaced by WE A K EV E N T UAL in the condition above (thus, gi and GIPF can be removed). Finally, \nit is said to be safe w.r.t S iff only the axioms TH I NAI R and RVAL are satis.ed, i.e., . o . O . li[o] \nan irre.exive poset. TH I NAIR . RVA L The relation eb is de.ned by: (o ' , o) . eb iff o ' . li[o] TH \nI NAIR eb . po is acyclic RVAL for all o = (i, a) . O, liM[o] . S(a) GIP F gi is pre.x-founded WE A K \nEV EN TUA L EV E N T UAL for all o . O, {o ' | (o, o ' ) . eb} is .nite for any .nite pre.x P of the \nposet (O, gi), {o | P : li[o]} is .nite Table 1: The list of axioms used in De.nition 2. Axioms TH I \nNAI R and RVA L are thus safety conditions, and ensure that the operations respect the speci.cation S. \nAxiom WEAKEVE N TUA L is a liveness condition, which ensures that eventu\u00adally, every operation will be \nexecuted before all the other operations in the system. Axiom EV E N T UA L is a stronger liveness condition \nwhich ensures that all nodes eventually agree on a (possibly partial) order in which to execute all the \noperations. An ORS I is said to be (weak) eventually consistent, resp., safe, iff for every observation \n. of I, trace(.) is (weak) eventually consistent, resp., safe. In the next sections, we consider the \nproblem of verifying eventual consistency and we assume that Mr Dis .nite. rd t 1 rd t 1  rd t 3 wr(1) \nrd t 2 wr(1) wr(2) wr(3) wr(2) wr(3) (a) A safe trace, with one possible total order e depicted with \narrows (b) An unsafe trace  Figure 4: Examples of traces of the Register 5. Safety We consider the problem \nof checking that an ORS is safe and we prove that it can be reduced to a reachability problem. First, \nwe show that in any total ordering over the operations of an unsafe trace t , consistent with the program \norder, one can .nd an operation o such that there are not suf.ciently many operations before o (in this \ntotal ordering) to construct a labeled poset belonging to its speci.cation (i.e., S(syn(o))). For example, \nfor an unsafe trace of the Register, e.g., the trace in Figure 4b, with read and write operations, this \nmeans that, no matter in which order consistent with the program order it is read, there will always \nexist a read that returns a value not written by a previous write. This allows us to de.ne a monitor \nfor checking the safety of a replication system I, that records all the operations executed by I, and \nstops with a negative answer at any time that it detects an operation o for which, with the recorded \nset of operations, it cann t build a labeled poset belonging to the speci.cation of o. Actually, we prove \nthat it is suf.cient that the monitor only counts the number of times the system executes each of the \nmethods in M(until some bound) and then, compare the counter values with the minimal vectors in the Parikh \nimage of the speci.cation. The next lemma states the characterization of (un)safe traces. Lemma 1. A \ntrace t is safe w.r.t S iff there exists a pre.x-founded total order e called the issue order on Ot \n, consistent with po, such that for every operation o of t , there exists a poset (Vo, =o), where Vo \nis a subset of e -1(o) and (Vo, =o, meth) . S(syn(o)). Proof. (.) For each o, de.ne li[o] = (Vo, =o). \nThis ensures that axiom RVA L holds. Moreover, the relations eb and po are both consistent with e, which \nimplies that axiom THI NAI R holds. (.) Conversely, assume that for each operation o, there exists li[o] \nsuch that TH I NAI R and RVA L hold. Let e be any total order compatible with eb and po, which exists \nsince eb . po has no cycle. Figure 4a illustrates one such total order on a safe trace. Then, for each \noperation o, de.ne (Vo, =o) as the poset li[o]. Lemma 1 implies that if t is the trace of an observation \n. and it is unsafe, then there exists a pre.x of . which ends in an operation whose return value is not \ncorrect, i.e., it is not possible to de.ne a labeled poset that contains only operations in this pre.x \nthat belongs to the speci.cation of o. This is stated in the following lemma. Lemma 2. Given an ORS I, \nthe following are equivalent: 1. there exists an observation . . I such that trace(.) is not safe 2. \nthere exists an observation . = . ' (N, (id, a)) . I such that there exists no poset (Vo, =o) whose elements \nare a subset of O./ , such that (Vo, =o, meth) . S(a).  Proof. Assume that (2) holds for . = . ' (N, \n(id, a)). Let o = (id, a) be the last operation of .. If . was safe, we would have a local interpretation \nli[o] such that liM[o] . S(a). Note that the operations in li[o] belong to O./ , which contradicts (2). \nThus, . is not safe and (2) implies (1). Conversely, if we have an observation . such that trace(.) is \nnot safe, then by Lemma 1, there exists a pre.x .p of . such that .p satis.es (2). Indeed, if there were \nno such pre.x, the total order on O. induced by . would satisfy the condition of Lemma 1, which would \ncontradict the fact that trace(.) is not safe.  The following corollary is a reformulation of Lemma \n2 in terms of Parikh images. For any .nite observation ., the M-Parikh image of . is a function .M(.) \n: M . N, that maps each m . M to the number of operations o in . with m = meth(o). The M-Parikh image \nof a .nite trace t , denoted by .M(t ), is de.ned similarly. Corollary 1. An optimistic replication system \nI is not safe iff there exists . ' (N, (id, a)) . I such that .M(. ' . . .M(S(a)). ) / Given an observation \n. and an integer i, .i M(.) is the Parikh image of ., where all the components larger than i are set \nto i, that is .i M(.) = (m . M . min(i, .M(.)(m))). For each a . Mr D, let Va be the set of minimal elements \nof .M(S(a)) (w.r.t. the ordering relation over vectors of natural num\u00adbers), so that . .M(S(a)) = . Va, \nand let ia be the maximum value appearing in the vectors of Va. Let i = max {ia | a . Mr D}. We remark \nthat .M(. ' ) / . . .M(S(a)) is equivalent to the fact that .M(. ' ) is not greater than one of the minimal \nelements va . Va. Moreover, since all the components of the vectors of Va are smaller than i, .M(. ' \n) . . .M(S(a)) is equivalent to / V M(. ' .i ) i va. va.Va In general, the sets Va cannot be computed, \nbut in Section 7, we give a class of speci.cations for which they can. We de.ne a monitor Msafe , which \ncounts all the methods it sees up to the bound i, and every time it reads a symbol (N, (id, a)), it goes \nto an error state qerr iff the vector of methods seen is not larger than some va . Va. Formally, Msafe \nis a deterministic .nite-state transition system (Q, Q0, d), where Q = (M . {0, . . . , i}) . {qerr \n} is the .nite set of states  Q0, the set of initial states, only contains q0 = (m . M . 0)  d . Q \n\u00d7 ON \u00d7 Q with  V (q, (N, (id, a)), qerr ) . d iff q i va va.Va (q1, (N, (id, a)), q2) . d iffq = va \nand va.Va q2 = q1[meth(a) . min(q1(meth(a)) + 1, i)] Theorem 1 (Safety Monitoring). An optimistic replication \nsystem I is not safe if and only if the parallel composition I IMsafe can reach the error state qerr \n. 6. Liveness In this section, we give properties which characterize (weak) even\u00adtually consistent traces \nthat will be used to de.ne reductions of deciding (weak) eventual consistency to LTL model checking. \n 6.1 Weak Eventual Consistency We .rst consider the case of weak eventual consistency because it is simpler \nwhile already showing some of the dif.culties we have to solve. Moreover, for some systems, weak eventual \nconsistency implies eventual consistency, for instance, when all the operations are commutative. For \nan in.nite trace t to be weak eventually consistent there must exist some local interpretations which \nshow that t is safe but also, which ensure that each operation o . Ot is executed-before all the other \noperations, except for some .nite set. The latter implies that any .nite set of operations is executed-before \nevery operation after some .nite pre.x. Thus, for any a . Mr D, if there are in.nitely many a-operations \nin t, then S(a), the speci.cation of a, must contain arbitrarily large posets. This property of S(a) \ncan be stated as a property of the Parikh image of S(a) and this allows us to de.ne a reduction of checking \nif some replication system I is weak eventually consistent to checking if I is safe and if the parallel \ncomposition of I with a monitor that counts the methods executed by I satis.es some LTL formula. Mainly, \nthe temporal operators in this formula are used to identify the in.nitely occurring method synopses in \nsome execution. In the following lemma, we characterize weak eventually consis\u00adtent traces. To identify \nthe in.nitely occurring method synopses in some trace t we use the following notation. Given B . Mr Dand \na .nite trace tp, let tpB. be the set of all traces t which extend tp (i.e., tp is a pre.x of t ) by \nan in.nite set of B-operations such that there are in.nitely many a-operations in t , for each a . B. \nLemma 3. [Characterization of Weak Eventual Consistency] Given B . Mr D such that meth(B) = {m1, . . \n. , mk}, a trace t . tpB. is weak eventually consistent w.r.t. S if and only if t is safe and  .a . \nB..n . N..n1, . . . , nk = n. .M(tp) + (m1 . n1, . . . , mk . nk) . .M(S(a))  Proof. (.) If t is eventually \nconsistent, then for each operation o . Ot , there exists a local interpretation li[o] such that the \naxioms THI NAI R, RVA L, and WEA K EV EN TUA L hold. Let a . B, and n . N. Since there are in.nitely \nmany a\u00adoperations in t, we deduce from axiom WEA K EV E N T UA L that there exists one, noted o, such \nthat li[o] (or equivalently, eb-1(o)) contains the operations of tp and at least n additional m-operations \nfor each m . meth(B). From axiom RVAL, we know that liM[o] . S(a), which shows that there exists n1, \n. . . , nk = n such that .M(tp) + (m1 . n1, . . . , mk . nk) . .M(S(a)). (.) Since t is safe, there exists \nan issue order e over Ot that satis.es the conditions in Lemma 1. In the following, we consider that \nthe operations in t are totally ordered according to e. For each n . N*, let on be the last operation \nin t, which occurs after at most n mi-operations for each mi . meth(B). For each a a a . B and n . N*, \nlet n1 , . . . , n k = n such that .M(tp) + (m1 . n1 a , . . . , mk . nk a) . .M(S(a)) and let o a be \nthe .rst operation in t such that the pre.x t ' of t that n ends in on a , satis.es ' a a .M(t ) = .M(tp) \n+ (m1 . n1 , . . . , mk . nk). (1) The existence of on a is ensured by the fact that t contains in.nitely \nmany a-operations, for each a . B. a a For all n . N* and a-operation o in t between on and on+1, the \nlocal interpretation li[o] = (Vo, =o) is de.ned as follows. The set Vo consists of all the operations \nof tp, all the mi-operations before on, and some mi-operations before o s.t. .M(Vo) = .M(tp) + (m1 . \nn1 a , . . . , mk . n a k). This is possible because, for each mi . meth(B), there are at most n mi-operations \nbefore on, and o occurs after o a , that satis.es (1). n Now, since .M(Vo) . .M(S(a)), there exists a \npartial order =o over the set Vo such that (Vo, =o, meth) . S(a). For the .nite number of a-operations \no that occur in t before o1 a, we use the local interpretations whose existence is ensured by the safety \nof t . Since both eb and po are consistent with the total order e, axiom THINAI R holds. For each operation, \nwe have chosen li[o] so that axiom RVA L holds. Moreover, for all n . N*, each operation o that occurs \nbefore on is executed-before all operations, except for a .nite set those that precede some on a with \na . B. Thus, eb satis.es axiom WE AKEV E N T UA L, which concludes the proof. By Lemma 3, an ORS I violates \nweak eventual consistency iff it violates safety or if it produces a trace in tpB., for some tp and B \n. Mr Dwith {m1, . . . , mk} = meth(B), such that there exists a method synopsis a . B satisfying: .n \n. N..n1, . . . , nk = n. .M(tp) + (m1 . n1, . . . , mk . nk) ./.M(S(a)) (2)  Given B . Mr Dand a . B, \nlet .notWEC(S, B, a) ={v | .n . N..n1, . . . , nk = n. v + (m1 . n1, . . . , mk . nk) ./.M(S(a))}. Then, \n(2) can be rewritten as .M(tp) . .notWEC(S, B, a). Like for safety, we construct a monitor Mlive , which \ncounts the methods executed by the ORS, but this time without any bound. Finding a violation of weak \neventual consistency reduces to .nding a B . Mr D and a .nite execution .p in the monitored system I \nIMlive , such that a.B .M(.p) . .notWEC(S, B, a) and .p can be extended by only using B-operations as \nwell as in.nitely many a-operations, for each a . B. The latter can be checked using LTL model checking \nby adding to each state of the monitor, a register recording the method synopsis of the last transition. \nFormally, Mlive is a transition system (Q, Q0, d), where Q = (M . N) \u00d7 Mr D,  I is the set of initial \nstates: (q0, a) . I iff q0 = (m . M . 0) and a . Mr D,  d . Q \u00d7 ON \u00d7 Q where ((q1, b), (N, (id, a)), \n(q2, a)) . d iff q2 = q1[meth(a) . q1(meth(a)) + 1] and a, b . Mr D.  Now, given a replication system \nI, we consider the monitored system I IMlive de.ned as the parallel composition of I and Mlive . De.ne \nthe following LTL formula: .notWEC =<(.notWEC(S, B, a) . QoB .o<b). B.M Da.B b.B By an abuse of notation, \n.notWEC(S, B, a) denotes also an atomic proposition, which holds in a state of the monitored system iff \nthe vector formed by the counters of Mlive is in .notWEC(S, B, a). As for the minimal elements used in \nmonitoring safety, the sets .notWEC(S, B, a) cannot be computed in general. In Section 7, we give a class \nof speci.cations for which they can. For each B . Mr D(resp., b . Mr D), B (resp., b) is an atomic proposition \nwhich holds in a state iff the second part of the state of Mlive is in B (resp., is b). Also, <, Q, and \no denote the temporal operators of LTL eventually, next, and always, respectively. Theorem 2 (Weak Eventual \nConsistency Monitoring). An opti\u00admistic replication system I is weak eventually consistent if and only \nif I IMsafe cannot reach qerr and I IMlive |= \u00ac.notWEC.  6.2 Eventual Consistency By following the same \nline of reasoning as the one used for weak eventual consistency, we .rst derive a necessary and suf.cient \ncondition for a trace to be eventually consistent. In the case of an eventually consistent in.nite trace \nt , axiom EV E N T UA L ensures that, for every .nite pre.x P of the global interpretation order gi, \nafter some .nite pre.x of t , all the operations have P as a pre.x of their local interpretations. If \nB . Mr D is the set of all a such that t contains in.nitely many a-operations, then the speci.cation \nof each a . B must contain an in.nite sequence of M-labeled posets such that any pre.x P of gi is a pre.x \nof all these posets, except for some .nite set. Thus, any pre.x P of gi can be extended in order to belong \nto each of the S(a) with a . B. Moreover, if P contains all the .nitely occurring operations in t, then \nthe extension can only add elements labeled by methods in meth(B). The set of labeled posets which can \nbe extended in such a way is denoted by Quot(S, B). This implies that an in.nite sequence of increasing \npre.xes of gi must belong to Quot(S, B), which, by extending a classical de.nition of limit from words \nto labeled posets, can be stated as the poset de.ned by gi is in the limit of Quot(S, B). Now, since \ngi is a reordering of t, this is equivalent to the fact that the multiset of methods that occur in t \nis the same as the multiset of methods that occur in some in.nite labeled poset belonging to the limit \nof Quot(S, B). Thus, the eventual consistency of a trace t can also be characterized in terms of Parikh \nimages. We show in the following that the same monitor Mlive de.ned previously can be used to reduce \nthe problem of checking eventual consistency to LTL model checking. Next, we formally de.ne Quot(S, B) \nand the notion of limit. De.nition 3 (Quotient). Given a speci.cation S, B . Mr D, and a . B, let S(a)meth(B)-1 \n the quotient of S by meth(B) be the set of labeled posets for which there exists an meth(B)\u00adcompletion \nin S(a). Then, let Quot(S, B) =S(a)meth(B)-1 . a.B De.nition 4 (Limit). Given a set A of .nite labeled \nposets, we denote by lim(A) the set of in.nite labeled posets (A, =, e) which have an in.nite sequence \nof increasing pre.xes in A such that every element in A is in a pre.x (and all greater ones). Remark \n1. In the context of totally-ordered sets, the condition that every element in A is in a pre.x is already \nimplied by the rest of the de.nition. However, this is not true in the general case. For instance, let \n(A, =, e) be an in.nite labeled poset, where A = {ai | i . N} . {bi | i . N}, e(ai) = a, e(bi) = b for \nall i = 0, a0 = a1 = . . . , and b0 = b1 = . . . . This poset is not in the limit of A, the set of all \n.nite totally-ordered sets where all elements are labeled by a, even though it has an in.nite increasing \nsequence of pre.xes which are in A. This is due to the fact that the pre.xes don t contain all the elements \nof (A, =, e). This leads us to the following necessary and suf.cient condition for eventual consistency. \n Lemma 4 (Characterization of Eventual Consistency). Let t = (Ot , po) be an in.nite in tpB.. The trace \nt is eventually consistent iff it is safe and .M(t ) . .M(lim(Quot(S, B))). Proof. (.) If t is eventually \nconsistent, then there exist gi . Ot \u00d7 Ot , and for each operation o . Ot , li[o] . Ot \u00d7 Ot satisfying \nthe axioms GIP F, TH I NAI R, RVAL, EV EN TUA L. It is enough to show that (Ot , gi, meth) . lim(Quot(S, \nB)). Let P be a .nite pre.x of (Ot , gi, meth) containing at least the operations of tp. For any a . \nB, by axiom EV EN TUAL, since there are in.nitely many a-operations, there exists at least one, o, such \nthat P is a pre.x of liM[o]. By RVAL, liM[o] belongs to S(a), and by the fact that P contains all operations \nin tp, liM[o] is a meth(B)\u00adcompletion of P . Thus, P . Quot(S, B). Since we can .nd an in.nite increasing \nsequence of such pre.xes P containing every operation of Ot , we have (Ot , gi, meth) . lim(Quot(S, B)). \n(.) This part of the proof is illustrated on Figure 5. Let (A, =, e) be an M-labeled poset in .M(lim(Quot(S, \nB))) with .M(t ) = .M(A). De.ne gi such that (Ot , gi, meth) is isomorphic to (A, = , e) and let f be \nan isomorphism from A to Ot . There exists an in.nite sequence of increasing pre.xes A1, A2, . . . of \nA such that every f(Ai) contains the operations of tp and such that, for all a . B, and for all n . N* \n, An . S(a)meth(B)-1 . Moreover, each operation of Ot appears in at least one f(Ai), for some i (and \nin every f(Aj ) with j = i). Since t is safe, there exists an issue order e over Ot that satis.es the \nconditions in Lemma 1. In the following, we consider that the operations in t are totally ordered according \nto e. The properties on A1, A2, . . . imply that, for every a . B and every n . N*, there exists an meth(B)-completion \nAa of f(An) n such that Aa . S(a). We assume that the elements added to f(An) n to obtain Aa come from \nOt and that they occur after the operations n in f(An). This is possible because t contains in.nitely \nmany a\u00ad  t ordered by e A tp pre.x containing the operations of f-1(tp) ob 1 occurs after A1 . Quot(S, \nB) b o 1 f all operations in Ab 1 P c f-1 A2 . Quot(S, B) o1 occurs after c o 1 all operations in Ac \n1 A3 . Quot(S, B) b every o after ohas A2 2 b o (and P ) as a pre.x of their 2 local interpretations \nFigure 5: Illustration of the proof of the second part of Lemma 4 for B = {b, c} a operations, for each \na . B. For every a . B and n . N*, let on be the .rst operation that occurs in t after all the operations \nin Aa n. In the following, we de.ne li[o], for every o, such that all the axioms of eventual consistency \nhold: for every a . B, for the .nite number of a-operations o, that occur in t before o1 a, we use the \nlocal interpretations whose existence is ensured by the fact that t is safe. Similarly, for every a ' \n. Mr Dsuch that t contains .nitely many a '-operations.  for every n . N* , a . B, and for every a-operation \no between  o a n and o a n+1, we de.ne li[o] = Aa n. Note that this implies that f(An) : liM[o] and \nthat liM[o] . S(a). Axioms TH INAI R and RVA L hold for the same reasons given in the proof of Lemma \n3. Axiom GIP F holds because of the way we have de.ned the limit of a set of labeled posets. It remains \nto show that axiom EVEN T UAL holds. Let P be a pre.x of (Ot , gi). Let An be one of the previously de.ned \npre.xes such that P : f(An). For every a . B and for every a-operation o that occurs after o a , n P \nis a pre.x of li[o]. Thus, there are only .nitely many operations which do not have P as a pre.x of their \nlocal interpretations, which concludes the proof. Monitoring for eventual consistency is similar to the \nmonitoring used for weak eventual consistency. Let .notEC(S, B) be the set .notEC(S, B) = {v . M . N \n|v + (m . meth(B) . .) ./.M(lim(Quot(S, B)))} According to Lemma 4, in order to .nd a trace which is \nnot eventually consistent, it is enough to look for a trace in tpB. for some tp and some B . Mr Dsuch \nthat .M(tp) . .notEC(S, B). This problem can be again reduced to LTL model checking over the parallel \ncomposition of I and the same monitor Mlive . In this case, the LTL formula to be checked is: .notEC \n= <(.notEC(S, B) . QoB . o<b) B.M D b.B As previously, for any B . Mr D, .notEC(S, B) holds in a state \nof the monitored system if and only if the vector formed by the counters of Mlive is in .notEC(S, B). \nTheorem 3 (Eventual Consistency Monitoring). An optimistic replication system I is eventually consistent \nif and only if I IMsafe cannot reach qerr and I IMlive |= \u00ac.notEC. 7. Speci.cations of .nite-state optimistic \nreplication systems The reductions of eventual consistency to reachability and LTL model checking are \neffective if one can compute the set of min\u00adimal elements in the Parikh image of the speci.cation and \neffec\u00adtive representations for the sets of vectors .notWEC(S, B, a) and .notEC(S, B) de.ned in Section \n6.1 and 6.2. In the following, we introduce automata-based representations for speci.cations of .nite\u00adstate \noptimistic replication systems, for which this is possible. Essentially, each S-labeled poset is abstracted \nas a sequence of multisets of symbols in S which is then recognized by a .nite-state automaton where \nthe transitions, instead of being labeled by symbols as in the case of automata over words, are labeled \nby Presburger constraints. By viewing multisets of symbols as vectors of integers, a sequence of multisets \nis recognized by an automaton if there exists a run such that the sequence satis.es the constraints imposed \nby the transitions of this run at each step. The abstraction of a poset as a sequence of multisets is \nde.ned based on its decomposition in levels, used in algorithms for parallel tasks scheduling [22]. These \nautomata offer a good compromise between simplicity and expressiveness. Since they can recognize words \nover an alphabet S, they can represent speci.cations, that contain only totally-ordered sets, required \nby ORS based on the Last Writer Wins con.ict resolution policy [15]. They are also able to represent \nspeci.cations of ORS with commutative con.ict resolution policies (i.e., the effect of a set of con.icting \noperations does not depend on the order in which they are read) such as the CRDTs [7, 20] (see Example \n8). For the latter case, the speci.cations represented by multiset automata are not exactly the ones \nintroduced by the designers of these systems. However, we can prove that eventual consistency w.r.t the \noriginal speci.cation is equivalent to eventual consistency w.r.t. the speci.cation recognized by the \nmultiset automaton. In the following, we give a precise statement of this result. Let S : Mr D . P(PoSetM) \nbe a speci.cation and ~ a symmetric binary relation over M, called commutativity relation. We say that \nan M-labeled poset (A, =, e) is canonical w.r.t. ~ iff any two elements labeled by symbols, that are \nin the relation ~, are incomparable, i.e., for any x, y . A, e(x) ~ e(y) implies that x = y and y = x. \nThen, the speci.cation S is called ~-closed iff, for every a . Mr D, if S(a) contains a labeled poset \n. = (A, =, e), then S(a) also contains a labeled poset . ' = (A, = ' , e), which is canonical w.r.t. \n~ and such that = ' .=. Furthermore, let S~ be a speci.cation s.t. for every a . Mr D, S~(a) is the set \nof posets in S(a), that are canonical w.r.t. ~. For example, the labeled poset in Figure 1c, belonging \nto the OR-Set speci.cation, is canonical w.r.t the relation ~O that consists of any pair of methods having \ndifferent arguments (e.g., add(i) and rem(j) with i = j), and any pair formed of an add or a remove and \nrespectively, a lookup (e.g., add(i) and lookup(i)). The OR-Set speci.cation in Example 6 is ~O-closed. \nAlso, the MV-Register speci.cation in Example 5 is ~M -closed, where ~M contains any pair of a wr(i) \nmethod and a rd method. The following result follows from the fact that eventual consis\u00adtency imposes \nrather weak constraints on the local interpretations associated to the operations in a trace. Proposition \n1. Let I be an ORS, ~ a symmetric binary relation over M, and S a ~-closed speci.cation. Then, I is eventually \nconsistent w.r.t S iff I is eventually consistent w.r.t S~. A speci.cation S is called canonical w.r.t. \n~ iff for every a . Mr D, S(a) contains only posets, that are canonical w.r.t. ~. Proposition 1 shows \nthat, for ORS like the MV-Register and the OR-Set, it is enough to consider canonical speci.cations. \nIn the following, we de.ne multiset automata and show how they can be used to represent canonical speci.cations. \nLet . = (A, =, e) be a S-labeled poset. The ith level of . is the set of elements x in A such that the \nlength of the longest path starting in x is i. A decomposition of . is a sequence An-1, . . . , A0, where \nn - 1 is the length of the longest path in . and, for all 0 = i = n - 1, Ai is the ith level of .. Note \nthat the decomposition of a labeled poset is unique. The S-decomposition of . is the Figure 6: Some transitions \nof a multiset automaton that recognizes a speci.cation of an OR-Set with at most two elements. The method \nsynopsis lookup(0) r 0 labels the states \u00d8 and {1}, lookup(0) r 1 labels the states {0} and {0, 1}, and \nso on.  sequence Gn-1, . . . , G0, where for all 0 = i = n - 1, Gi is the Parikh image of Ai. By de.nition, \nthe length of Gn-1, . . . , G0 is n. Example 7. [S-decomposition] Consider the MOR-S-labeled poset in \nFigure 1c. The MOR-S-decomposition of this labeled poset is: G2 = {add(1), rem(1)}, G1 = {add(1), rem(1), \nrem(1), add(0)}, G0 = {add(1), rem(1), rem(0), rem(0)}. We de.ne an effective representation for isomorphism-closed \nsets of M-labeled posets by .nite automata that recognize their M\u00addecompositions, i.e., sequences of \nnon-empty multisets of symbols from M. In order to represent multisets of symbols from M, we consider \nPresburger formulas . over a set of free variables {#m |m . M}, where #m denotes the number of occurrences \nof the symbol m. Let FM denote the set of all such formulas. Also, for any Presburger formula ., let \n[.] denote the set of models of .. De.nition 5 (Multiset Automata). A multiset automaton over M and Mr \nDis a tuple A = (Q, d, Q0, (Qa | a . Mr D)), where Q is a .nite set of states, d . Q \u00d7 FM \u00d7 Q is the \ntransition relation, Q0 . Q is the set of initial states, and, for any a . Mr D, Qa . Q (we say that \nthe states in Qa are labeled by a). Intuitively, an M-labeled poset is recognized by A iff there exists \na run in A starting in the initial state such that the transitions are labeled by formulas that are satis.ed \nsuccessively by the Parikh images of the n - 1th level, n - 2th level, etc. (where n - 1 is the length \nof the longest path). For example, the multiset automaton in Figure 6 recognizes the labeled poset in \nFigure 1c because there exists a run starting in the initial state that goes through the states labeled \nby \u00d8, {1}, {0, 1}, {1} such that the associated sequence of formulas describe the MOR-S-decomposition \nin Example 7. .0.1 A run of a multiset automaton A is a sequence q0 . q1 . .n-1 . . . . qn, s.t. for \nevery 0 = i = n - 1, (qi, .i, qi+1) . d. Such a run recognizes an M-labeled poset . iff the M-decomposition \nof . is Gn-1Gn-2 . . . G0 and for every 0 = i = n - 1, Gn-1-i . [.i]. We say that the length of this \nrun is n. Given q . Q, the set of all M-labeled posets recognized by a run of a A, that ends in q, is \ndenoted by L(A, q). The labeled posets in L(A, q) are said to be interpreted to q. Given a set of states \nF . Q, L(A, F ) denotes the union of L(A, q) with q . F . De.nition 6 (Canonical speci.cations and multiset \nautomata). A speci.cation S canonical w.r.t ~ is recognized by a multiset au\u00adtomaton A iff for every \na . Mr D, S(a) is the set of posets in L(A, Qa), that are canonical w.r.t. ~. Example 8. [A multiset \nautomaton for the OR-Set] Let S2 OR-S be a .nite-state restriction of the OR-Set speci.cation in Example \n6 s.t. (1) the set object contains at most two elements 0 and 1 and (2) S2 OR-S contains only posets \ncanonical w.r.t ~O. This speci.cation is de.ned over the set of methods add, rem, and lookup with arguments \n0 and 1, denoted by M2 OR-S. The automaton in Figure 6 recognizes S2 OR-S. The following theorem is a \ndirect consequence of the fact that, for any multiset automaton A, one can construct a .nite-automaton \nover sequences whose language has exactly the same Parikh image as the set of labeled posets recognized \nby A. Theorem 4. Let S be a speci.cation recognized by a multiset automaton A. Then, for every a . Mr \nD, there exists an effectively computable Presburger formula .a s.t. .(S(a)) = [.a]. Theorem 4 implies \nthat, for every a . Mr D, the set of minimal elements in .(S(a)) is effectively computable and that there \nexists a computable Presburger formula describing .notWEC(S, B, a). Given B . Mr D, we show that .notEC(S, \nB) de.ned in Section 6.2 is de.nable as an effectively computable Presburger formula provided that the \nspeci.cation S is recognized by a multiset automaton A satisfying some conditions. First, A must recognize \na pre.x-closed set of labeled posets, i.e., q L(A, q) is pre.x-closed. This is quite natural since the \n set of all posets in some speci.cation, i.e., a S(a), is usually pre.x-closed. Another condition that \nA must satisfy can be roughly stated as follows: given a set of methods M and a labeled poset . interpreted \nto some state q, the fact that there exists an M\u00adcompletion of . interpreted to q ' depends only on the \nstates q, q ' , and the set of methods M. Formally, for all q, q ' . Q, M . M, and .1, .2 . L(A, q), \n.1 . L(A, q ' )M-1 iff .2 . L(A, q ' )M -1 . For example, if we consider the automaton in Figure 6, for \nany labeled poset interpreted to the state labeled by {1} there exists an {add(0)}-completion interpreted \nto the state labeled by {0, 1}. In the case of the poset in Figure 1c this completion contains one more \nelement labeled by add(0), which is greater than all the elements labeled by rem(0). Finally, we require \nthat either A is a word automaton, i.e., the transitions are labeled by Presburger formulas that describe \nsingleton multisets, or that for all q, if the limit of L(A, q) contains an in.nite poset ., then it \nalso contains an in.nite poset . ' with the same Parikh image as . and such that the decomposition of \n. ' has at most |Q| levels. This last condition is satis.ed by the automaton in Figure 6 (and an automaton \nrepresenting an MV-Register speci.cation). Actually, the bound |Q|can be replaced by the constant 2. \nIt is satis.ed also by an automaton that describes a speci.cation for the MV-Register. An automaton A \nsatisfying all these conditions is called completion-bounded. Theorem 5. Let S be a speci.cation recognized \nby a completion\u00adbounded multiset automaton A. Then, for every B . S, there exists an effectively computable \nPresburger formula .B such that [.B ] = .notEC(S, B). Proof sketch. Given a . Mr D and M . M, we can \nprove that there exists a maximal set of states FM,a such that S(a)M-1 = L(A, FM,a ). To decide if a \nstate q belongs to FM,a , one has to consider a minimal labeled poset interpreted to q and search for \nan M-completion interpreted to a state in Qa. It can be proved that if there exists such a completion \nthere also exists one of bounded size. o Let B . Mr D, MB = meth(B) and FB = a.B FMB,a. If FB = \u00d8 then \n.B = true. Otherwise, we compute a Presburger formula . that describes the complement of .notEC(S, B), \ni.e., the  set of vectors v . M . Nsuch that v + (m . meth(B) . .) . .M(lim(Quot(S, B))). By de.nition, \nQuot(S, B) = L(A, FB). First, we prove that lim(L(A, FB )) is the union of lim(L(A, q)) with q . FB. \nLet . be an in.nite labeled poset, which has an in.nite set of increasing pre.xes .0, .1, . . . in L(A, \nFB ). Also, let .0, .1, . . . be an in.nite sequence of runs in A such that, for all i, .i is a run that \nrecognizes .i. By Ramsey s theorem, there exist in.nitely many runs .j1 , .j2 ,. . ., that end in the \nsame state q . FB . Thus, the in.nitely many posets .j1 , .j2 ,. . . belong to L(A, q), which shows that \n. . lim(L(A, q)). Next, we compute for each q . FB, a formula .q that describes the set of vectors v \n. M . Nsuch that v + (m . meth(B) . .) . .M(lim(L(A, q))). If A is a word automaton, then .q describes \nthe Parikh image of all the sequences accepted by a run of A that ends in a cycle on q with at least \none transition for each symbol in MB and only transitions labeled by symbols in MB . Thus, .q is effectively \ncomputable. Otherwise, we .0.1.n-1 enumerate all the runs q0 . q1 . . . . . qn = q of A of length at \nmost |Q|. For every such run ., every index 0 = i = n - 1, and every surjective mapping f : MB . {i, \n. . . , n - 1}, we de.ne a run .f as follows. For each i = j = n - 1, let . ' j be a formula describing \nthe set of all multisets v of symbols from M\\ MB s.t. for every integer L, there exists a multiset modeled \nby .j , that consists of v, at least L symbols m, for all m . f-1(j), and possibly other symbols from \nMB . The run .f is obtained from . by replacing .j with .j . . ' j , for all i = j = n - 1. The models \nof .q are the Parikh images of all the posets, which are recognized by a run .f as above. To prove that \nthe formula .q is effectively computable, one can use the same reasoning as in the proof of Theorem 4. \nFinally, . is the disjunction of .q with q . FB and .B = \u00ac.. 8. Decidability Results We give decidability \nresults for the case where the speci.cations are given by multiset automata, and where the optimistic \nreplication system is composed of a .xed number of boolean programs com\u00admunicating through uni-directional \nunbounded unordered channels. Each boolean program has instructions send(msg, j) that can be used to \nsend a message msg, which belongs to a .nite set of mes\u00adsages, to the site identi.ed by j. When a message \nis sent from a site i to a site j, it is put in an unbounded unordered channel chi,j from which site \nj can read by using an instruction receive(msg, i). Such systems are called .nite-state optimistic replication \nsystems. In order to de.ne an operational model for .nite-state optimistic replication systems, we use \nVector Addition Systems with States (VASSs for short). Formally, a VASS V is a tuple (Q, d, d) where \nQ is a .nite set of states, d . Nis the number of counter variables in the VASS, and d . Q \u00d7 Nd \u00d7 Q is \nthe transition relation. The transition system induced by V is de.ned in the usual way. A con.guration \nof V is a pair (q, v) where q . Q and v . Nd . There is a transition from a con.guration (q, v) to a \ncon.guration (q ' , v ' ) iff there exists a transition (q, u, q ' ) such that v ' = v + u. We brie.y \ndescribe how to model a .nite-state optimistic repli\u00adcation system I using a VASS V. A con.guration of \nI is composed of two parts: the .rst part is a tuple where each component describes the state of a boolean \nprogram; the second part is a function, describ\u00ading the content of each channel. In V, the .rst part \ncan be encoded in the .nite set of states Q. Moreover, if Msg denotes the set of mes\u00adsages exchanged \nby the sites, the content of an unbounded unordered channel ch of an optimistic replication system can \nbe modeled by |Msg| counters ch1, . . . , ch|Msg| used to count how many of each kind of messages there \nare in ch. We are given a .nite-state optimistic replication system I and a speci.cation S described \nby a multiset automaton A. As a direct consequence of Theorem 4, given a . Mr D, the set of minimal elements \nin .(S(a)) is effectively computable. This implies that also the safety monitor Msafe can be effectively \nconstructed. Moreover, if V is a VASS modeling I, we can construct the parallel composition V IMsafe \nof V with Msafe . We get a VASS Vsafe , on which we can solve the problem of control state reachability, \nin order to know if it is possible to reach the error state qerr of the monitor. The bound i for the \nminimal vectors Va used to construct Msafe is exponential in |A| and thus, the number of states in Msafe \n(and in V IMsafe ) is also exponential in |A|. Moreover solving control-state reachability in VASS is \nknown to be EXPSPACE-complete, which leads to the following theorem. Theorem 6 (Decidability of Safety). \nFor a .nite-state optimistic replication system I (given as a VASS), and a speci.cation S described by \na multiset automaton, the problem of checking the safety of I w.r.t. S is decidable, and in 2-EXPSPACE. \nThe following lemma is used for proving the decidability of both weak eventual consistency and eventual \nconsistency. Lemma 5. Let V = (Q, d, d) be a VASS where the states are labeled with atomic propositions \ncoming from a .nite set AP . Let . be a Presburger formula with d free variables, and P . AP . The problem \nof checking the LTL formula V |= \u00ac<(. . QoP . o<p) p.P is decidable, and can be reduced to reachability \nin VASS. Proof. For the formula to be satis.ed, there must exist an in.nite execution in V of the form \n(q0, v0) . . . (qi, vi) . . . where (1) the valuation of the counters in vi satis.es ., (2) for all j \n> i, qj is labeled by a proposition in P , and (3) for each p . P , there are in.nitely many qj labeled \nby p. First, Th. 2.14 in Valk and Jantzen [24] shows that it is possible to compute the minimal elements \nof the upward-closed set of con.gurations UP from which there exists an in.nite execution visiting only \nstates labeled by a proposition in P and in.nitely many states labeled by p, for each p . P . Then, we \nconstruct a Presburger formula . ' representing the intersection of [.] and UP . The problem of checking \nif there exists a reachable con.guration in V satisfying . ' can be reduced to (con.guration) reachability \nin VASS [4]. Theorem 7 (Decidability of (Weak) Eventual Consistency). Given a .nite-state optimistic \nreplication system I, and a speci.cation S described by a multiset automaton, the problem of checking \nthe (weak) eventual consistency of I w.r.t. S is decidable. 9. Related Work Our de.nition of eventual \nconsistency is inspired by the one given in Burckhardt et al. [6] but it differs from it on several points. \nIn that paper, eventual consistency is de.ned over traces that are also posets of operations, but the \npartial order, called session order, is de.ned such that all the operations performed by an user in a \nsession are totally ordered and operations from different sessions are incomparable. Then, a trace is \neventually consistent iff there exist two relations over the operations in the trace, called arbitration \nand resp., visibility relation (denoted by ar and resp., vis), such that (1) the union of vis with the \nsession order is acyclic, (2) for every operation o, the return value of o is associated by the speci.cation \nto the pair formed of the M-labeled poset (vis-1(o), vis, meth) and the projection of ar over the operations \nin vis-1(o), (3) ar is a total order, and (4) every operation o is not visible only to some .nite set \nof operations, i.e., for every o, {o ' | (o, o ' ) . vis} is .nite. First, the partial orders over operations \nthat de.ne a trace have different meanings. The operations in a session can be submitted to multiple \nsites and thus, an in.nite extension of the execution in Fig. 2b, where each operation appearing in the \n.gure is executed in a different session, is declared to be eventually consistent although the union \nof vis with the session order is acyclic. Then, the de.nition of a speci.cation in Burckhardt et al. \n[6] is different because it contains labeled posets augmented with a total order. With our understanding \nof ORS we think that it is not necessary to add such total orders. A speci.cation should model only the \nsemantics of the operations and some abstraction of the con.ict resolution policy. The formalization \nof the fact that sites will eventually see a consistent state is also different. In fact, the formalization \nin Burckhardt et al.  [6] does not apply to systems that perform speculative executions (this is remarked \nalso by the authors). Intuitively, the order in which two operations are executed cann t change once \nthey are visible. For example, two operations o1, o2 with vis-1(o1) = vis-1(o2), which are instances \nof the same method, must return the same value. But, for this class of systems, it is possible that the \norder in which the operations in vis-1(o1) are executed changes in between the execution of o1 and the \nexecution of o2 and thus, it is possible that the two operations return different values. Another difference \nis that in our case the local interpretations may converge toward a partial order over the operations \nin the trace, while in Burckhardt et al. [6] they can converge only toward a total order. For instance, \nthis allows that the sites don t have to agree on the order between two con.icting operations, which \nare commutative. There are other works that provide formal de.nitions for eventual consistency, e.g., \n[3, 9, 20, 21], but they either consider its weaker form, i.e., quiescent consistency, or they use a \nparticular model for the ORS. In general, there exist ORS that guarantee stronger criteria than eventual \nconsistency, e.g., strong eventual consistency [20] or causal+ consistency [17]. Stronger notions for \nthe safety part of eventual consistency, e.g., causal consistency or session guarantees, are formalized \nin Burckhardt et al. [6] by adding more requirements on the session order and the relation vis. With \nslight modi.cations, such requirements can be also added to our de.nition. There are works that de.ne \ndecision procedures for the veri\u00ad.cation of correctness criteria like sequential consistency or lin\u00adearizability, \ne.g., [1, 5, 8, 11]. The techniques used in these cases are different from the ones introduced in this \npaper for eventual consistency, in particular because they are de.ned over .nite traces. 10. Conclusion \nWe provide an algorithmic approach for verifying eventual consis\u00adtency of ORS. Our approach is based \non reducing the problem of checking eventual consistency to reachability and model-checking problems. \nThis connection is a fundamental result which opens the doors to using existing exact or approximate \n veri.cation tools for message-passing programs (depending on the considered class of systems for the \nimplementation) in the context of verifying ORS. Our reduction is de.ned for a general, formally de.ned, \nnotion of eventual consistency, allowing to reason about a wide class of systems, including those using \nspeculative executions and roll-backs such as Bayou [23] or Telex [2]. In fact, one of the contributions \nof our paper is to provide such a de.nition of eventual consistency, as well as a new class of automata \nthat is expressive enough to capture usual speci.cations of distributed data structures, and which has \nthe needed properties for use in algorithmic veri.cation. We have in addition shown that when implementations \nare de.ned as communicating boolean programs through unbounded unordered channels, the problem of verifying \neventual consistency is decidable. As for complexity, our algorithm for checking the safety part of eventual \nconsistency is in 2EXPSPACE, but the problem is EXPSPACE-hard (it is at least as hard as state reachability \nin VASS). Therefore, an interesting question is whether it is possible to match the two bounds in this \ncase. For the general case of eventual consistency (with liveness), we know that the problem is also \nEXPSPACE-hard, and that it can be solved using con.guration reachability in VASS, which is decidable \nbut with an unknown upper-bound. Then, an interesting question is whether con.guration reachability in \nVASS is needed. We believe that this is the case. References [1] R. Alur, K. L. McMillan, and D. Peled. \nModel-checking of correctness conditions for concurrent objects. Inf. Comput., 160(1-2):167 188, 2000. \n[2] L. Benmouffok, J.-M. Busca, J. M. Marqu `es, M. Shapiro, P. Sutra, and G. Tsoukalas. Telex: A semantic \nplatform for cooperative application development. In CFSE, Toulouse, France, 2009. [3] A.-M. Bosneag \nand M. Brockmeyer. A formal model for eventual consistency semantics. In IASTED PDCS, pages 204 209, \n2002. [4] A. Bouajjani and P. Habermehl. Constrained properties, semilinear systems, and petri nets. \nIn CONCUR, pages 481 497, 1996. [5] A. Bouajjani, M. Emmi, C. Enea, and J. Hamza. Verifying concurrent \nprograms against sequential speci.cations. In ESOP, 2013. [6] S. Burckhardt, A. Gotsman, and H. Yang. \nUnderstanding eventual consistency. Technical Report MSR-TR-2013-39, Microsoft Research. [7] G. DeCandia, \nD. Hastorun, M. Jampani, G. Kakulapati, A. Lakshman, A. Pilchin, S. Sivasubramanian, P. Vosshall, and \nW. Vogels. Dynamo: amazon s highly available key-value store. In SOSP, 2007. [8] A. Farzan and P. Madhusudan. \nMonitoring atomicity in concurrent programs. In CAV 2008, pages 52 65. Springer. [9] A. Fekete, D. Gupta, \nV. Luchangco, N. A. Lynch, and A. A. Shvartsman. Eventually-serializable data services. In PODC, pages \n300 309, 1996. [10] S. Gilbert and N. A. Lynch. Brewer s conjecture and the feasibility of consistent, \navailable, partition-tolerant web services. SIGACT News, 33(2):51 59, 2002. [11] T. A. Henzinger, S. \nQadeer, and S. K. Rajamani. Verifying sequential consistency on shared-memory multiprocessor systems. \nIn CAV, volume 1633 of LNCS, pages 301 315, 1999. [12] M. Herlihy and N. Shavit. The art of multiprocessor \nprogramming. [13] M. Herlihy and J. M. Wing. Linearizability: A correctness condition for concurrent \nobjects. ACM Trans. Program. Lang. Syst., 12(3):463 492, 1990. [14] J. H. Howard, M. L. Kazar, S. G. \nMenees, D. A. Nichols, M. Satya\u00adnarayanan, R. N. Sidebotham, and M. J. West. Scale and performance in \na distributed .le system. ACM Trans. Comput. Syst., 6(1):51 81, 1988. [15] P. R. Johnson and R. H. Thomas. \nThe maintenance of duplicate databases. Technical Report Internet Request for Comments RFC 677, Information \nSciences Institute, January 1976. [16] A.-M. Kermarrec, A. I. T. Rowstron, M. Shapiro, and P. Druschel. \nThe icecube approach to the reconciliation of divergent replicas. In PODC, pages 210 218, 2001. [17] \nW. Lloyd, M. J. Freedman, M. Kaminsky, and D. G. Andersen. Don t settle for eventual: scalable causal \nconsistency for wide-area storage with COPS. In SOSP, pages 401 416, 2011. [18] J. Michaux, X. Blanc, \nM. Shapiro, and P. Sutra. A semantically rich approach for collaborative model edition. In SAC, pages \n1470 1475, 2011. [19] Y. Saito and M. Shapiro. Optimistic replication. ACM Comput. Surv., 37(1):42 81, \n2005. [20] M. Shapiro, N. Preguic\u00b8a, C. Baquero, and M. Zawirski. A compre\u00adhensive study of Convergent \nand Commutative Replicated Data Types. Rapport de recherche RR-7506, INRIA, Jan. 2011. [21] M. Shapiro, \nN. M. Preguic\u00b8a, C. Baquero, and M. Zawirski. Con.ict-free replicated data types. In SSS, pages 386 400, \n2011. [22] O. Sinnen. Task Scheduling for Parallel Systems. 2007. [23] D. B. Terry, M. M. Theimer, K. \nPetersen, A. J. Demers, M. J. Spreitzer, and C. H. Hauser. Managing update con.icts in bayou, a weakly \nconnected replicated storage system. SIGOPS Oper. Syst. Rev., 29(5): 172 182, Dec. 1995. [24] R. Valk \nand M. Jantzen. The residue of vector sets with applications to decidability problems in petri nets. \nActa Inf., 21:643 674, 1985.  \n\t\t\t", "proc_id": "2535838", "abstract": "<p>We address the verification problem of eventual consistency of optimistic replication systems. Such systems are typically used to implement distributed data structures over large scale networks. We introduce a formal definition of eventual consistency that applies to a wide class of existing implementations, including the ones using speculative executions. Then, we reduce the problem of checking eventual consistency to reachability and model checking problems. This reduction enables the use of existing verification tools for message-passing programs in the context of verifying optimistic replication systems. Furthermore, we derive from these reductions decision procedures for checking eventual consistency of systems implemented as finite-state programs communicating through unbounded unordered channels.</p>", "authors": [{"name": "Ahmed Bouajjani", "author_profile_id": "81100358502", "affiliation": "LIAFA, Univ Paris Diderot, Sorbonne Paris Cite, Paris, France., Paris, France", "person_id": "P4383823", "email_address": "abou@liafa.univ-paris-diderot.fr", "orcid_id": ""}, {"name": "Constantin Enea", "author_profile_id": "81384607518", "affiliation": "LIAFA, Univ Paris Diderot, Sorbonne Paris Cite, Paris, France., Paris, France", "person_id": "P4383824", "email_address": "cenea@liafa.univ-paris-diderot.fr", "orcid_id": ""}, {"name": "Jad Hamza", "author_profile_id": "81486656690", "affiliation": "LIAFA, Univ Paris Diderot, Sorbonne Paris Cite, Paris, France., Paris, France", "person_id": "P4383825", "email_address": "jhamza@liafa.univ-paris-diderot.fr", "orcid_id": ""}], "doi_number": "10.1145/2535838.2535877", "year": "2014", "article_id": "2535877", "conference": "POPL", "title": "Verifying eventual consistency of optimistic replication systems", "url": "http://dl.acm.org/citation.cfm?id=2535877"}