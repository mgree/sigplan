{"article_publication_date": "01-08-2014", "fulltext": "\n Modular Reasoning about Heap Paths via Effectively Propositional Formulas Shachar Itzhaky Anindya Banerjee \nNeil Immerman Tel Aviv University IMDEA Software Institute, Madrid, University of Massachusetts, Amherst, \nshachar@tau.ac.il Spain USA anindya.banerjee@imdea.org immerman@cs.umass.edu Ori Lahav Aleksandar Nanevski \nMooly Sagiv Tel Aviv University IMDEA Software Institute, Madrid, Tel Aviv University orilahav@post.tau.ac.il \nSpain msagiv@acm.org aleks.nanevski@imdea.org Abstract concentrate on proving safety properties of imperative \nprograms manipulating linked data structures which is challenging since we First order logic with transitive \nclosure, and separation logic enable need to reason about unbounded memory and destructive pointer elegant \ninteractive veri.cation of heap-manipulating programs. updates. The tricky part is to identify a logic \nwhich is expressive However, undecidabilty results and high asymptotic complexity of enough to enable \nthe modular veri.cation of interesting procedures checking validity preclude complete automatic veri.cation \nof such and properties and weak enough to enable sound and complete programs, even when loop invariants \nand procedure contracts are veri.cation using SAT solvers. speci.ed as formulas in these logics. This \npaper tackles the prob-Recently it was shown [11] how to employ effectively propo\u00ad lem of procedure-modular \nveri.cation of reachability properties sitional logic (or BSR logic1) for verifying programs manipulating \nof heap-manipulating programs using ef.cient decision procedures linked lists. It decides the validity \nof formulas of the form . * . * qthat are complete: that is, a SAT solver must generate a counterex\u00adusing \nSAT solvers where q is a quanti.er free relational formula ample whenever a program does not satisfy \nits speci.cation. By (or equivalently decides the satis.ability of . * . * q formulas). It has (a) requiring \neach procedure modi.es a .xed set of heap partitions been successfully used in many other contexts [18]. \n and creates a bounded amount of heap sharing, and (b) restrict-In this paper we show that effectively \npropositional logic does ing program contracts and loop invariants to use only deterministic not suf.ce \nto naturally express the effect on the global heap when paths in the heap, we show that heap reachability \nupdates can be the local heap of a procedure is accessible via shared nodes from described in a simple \nmanner. The restrictions force program spec\u00adoutside. For example, Fig. 1 shows a pre-and post-heap before \ni.cations and veri.cation conditions to lie within a fragment of a list pointed-to by h is reversed. \nThe problem is how to express .rst-order logic with transitive closure that is reducible to effec\u00adthe \nchange in reachability between nodes such as zi and list nodes tively propositional logic, and hence \nfacilitate sound, complete and 1, 2, . . . , 5: note that, e.g., nodes 3, 4, 5 are unreachable from z1 \ninef.cient veri.cation. We implemented a tool atop Z3 and report the post-heap. on preliminary experiments \nthat establish the correctness of several This paper shows that in many cases, including the above exam\u00adprograms \nthat manipulate linked data structures. ple, reachability can be checked precisely using SAT solvers. \nOur Categories and Subject Descriptors D.3.3 [Programming Lan-solution is based on the following principles: \nguages]: Dynamic storage management We follow the standard techniques (e.g., see [2, 14, 25, 29]) Keywords \nlinked list; SMT; veri.cation by requiring that the programmer de.nes the set of potentially modi.ed \nelements. 1. Introduction The programmer only speci.es postconditions on local heaps This paper shows \nhow to harness existing SAT solvers for proving and ignores the effect of paths from the global heap. \nthat a potentially recursive procedure satis.es its speci.cation and We provide a general and exact \nadaptation rule for adapting for automatically producing counterexamples when it does not. We postconditions \nto the global heap. This adaptation rule is ex\u00adpressible in a generalized version of BSR called AEAR \n. AEAR Permission to make digital or hard copies of all or part of this work for personal or allows an \nextra entry function symbol which maps each node classroom use is granted without fee provided that \ncopies are not made or distributed for pro.t or commercial advantage and that copies bear this notice \nand the full citation u in the global heap into the .rst node accessible from u in the on the .rst page. \nCopyrights for components of this work owned by others than the local heap. In Fig. 1, z1, z2 and z3 \nare mapped to 2, 3 and 4, author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, \nor respectively. The key facts are that AEAR suf.ces to precisely republish, to post on servers or to \nredistribute to lists, requires prior speci.c permission de.ne the global reachability relationship after \neach procedure and/or a fee. Request permissions from permissions@acm.org. call and yet any AEAR formula \ncan be simulated by a BSR POPL 14, January 22 24, 2014, San Diego, CA, USA. Copyright is held by the \nowner/author(s). Publication rights licensed to ACM. ACM 978-1-4503-2544-8/14/01. . . $15.00. http://dx.doi.org/10.1145/2535838.2535854 \n1 Due to Bernays, Sch\u00f6n.nkel and Ramsey.  reverse x z1 z2 z3z1 z2 z3 Figure 1. Reversing a list pointed \nto by a head h with many shared nodes accessible from outside the local heap (surrounded by a rounded \nrectangle). formula. Thus the automatic methods of [11] still apply to this signi.cantly more general \nsetting. We restrict the veri.ed procedures in order to guarantee that the generated veri.cation condition \nof every procedure remains in AEAR. The main restrictions are: type correctness, determinis\u00adtic paths \nin the heap, limited number of changed list segments in the local heap (each of which may be unbounded) \nand lim\u00adited amount of newly created heap sharing by each procedure call. These restrictions are enforced \nby the generated veri.ca\u00adtion condition in AEAR. This formula is automatically checked by the SAT solver. \n1.1 Main Results The results in this paper can be summarized as follows: We de.ne a new logic, AEAR, \nwhich extends BSR with a limited idempotent function and yet is equi-satis.able with BSR.  We provide \na precise adaptation rule in AEAR, which expresses the locality property of the change, and in conjunction \nwith the postcondition on the local heap, precisely updates the reacha\u00adbility relation of the global \nheap.  We generate a modular veri.cation formula in AEAR for each procedure, asserting that the procedure \nsatis.es its pre-and post-conditions and the above restrictions. This veri.cation condition is sound \nand complete, i.e., it is valid if and only if the procedure adheres to the restrictions and satis.es \nits re\u00adquirements. We implemented this tool on top of Z3.  We show that many programs can be modularly \nveri.ed using our methods. They satisfy our restrictions and their BSR invari\u00adants can be naturally expressed. \n  1.2 A Running Example To make the discussion more clear, we start with an example pro\u00adgram. We use \nthe union-.nd data structure2, which maintains a for\u00ad est using a parent pointer at each node (see Fig. \n2) [24]. The method find requires that the argument x is not null. The formula tailf (x, rx ) asserts \nthat the auxiliary variable rx is equal to the root of x. The procedure changes the pointers of some \nnodes in the closed interval [x, rx ]f to point directly to rx . Intervals are formally de.ned later \n(De.nition 5). Intuitively, the closed interval [a, b]f denotes the set of nodes pointed to by a, a.f \n, a.f .f and so on up until b inclusive. The return value of find (denoted by retval) is rx . The post\u00adcondition \nuses the symbol f that denotes the value of f before the method was invoked. Since find compresses paths \nfrom ancestors of x to single edges to rx , this root may be shared via new parent pointers. Fig. 3 depicts \na typical run of find. @ requires x ) = null . tailf (x, rx @ mod [x, rx ]f retval = rx . @ ensures \n.a, \u00df . mod : a(f *)\u00df . a = \u00df . \u00df = rx Node find(Node x) { Node i = x.f; if (i != null) { i = find(i); \nx.f = i; } else { i = x; } return i;  } @ requires x = null . y= null . tailf (x, rx ) . tailf (y, \nry ) @ mod [x, rx ]f . [y, ry ]f @ ensures (x(f *)a . (a(f *)\u00df . .a, \u00df . mod : \u00df = a . \u00df = rx . \u00df = ry \n)) .(y(f *)a . (a(f *)\u00df . \u00df = a . \u00df = ry )) void union(Node x, Node y){ Node t = find(x); Node s = find(y); \nif (t != s) t.f = s; } Figure 2. An annotated implementation of Union-Find in Java. f is the backbone \n.eld denoting the parent of a tree node. x find x x r r  y y Figure 3. An example scenario of running \nfind ( = return value). The method union requires that both its arguments are not null. It potentially \nmodi.es the ancestors of x and y, i.e., [x, rx ]f . [y, ry ]f . Fig. 4 depicts a typical run of union. \nNotice that we support an unbounded number of cutpoints [21] (see Section 8). 1.3 Working Assumptions \nType correct The procedure manipulates references to dynami\u00adcally created objects in a type-safe way. \nFor example, we do not support pointer arithmetic. Deterministic Reachability The speci.cation may use \narbitrary 2 We have simpli.ed union by not keeping track of the sizes of sets in order uninterpreted \nrelations. It may also use the reachability formula to attach the smaller set to the larger. a(f *)\u00df \nmeaning that \u00df is reachable from a via zero or more y s y s union x, y t t x Figure 4. An example \nscenario of running union. steps along the functional backbone .eld f . It may not use f in any other \nway. Until Section 6, we require f to be acyclic and we restrict our attention to only one backbone .eld. \nPrecondition There is a requires clause de.ning the precondition which is written in alternation-free \nrelational .rst-order logic (AF R) and may use the relation f* [11]. Mod-set There is a modi.es clause \nde.ning the mod-set (modf ), which is the set of potentially changed memory locations (We include both \nsource and target of every edge that is added or deleted). The modi.ed set may have an unbounded number \nof vertices, but we require it to be the union of a bounded number of f -intervals, that is chains of \nvertices through f -pointers. Postcondition There is an ensures clause which exactly de.nes the new reachability \nrelation f* restricted to modf . The ensures clause, written in AF R, may use two vocabularies (employing \nboth f and f to refer to the reachability relations before and after. Bounded new sharing All the new \nshared nodes nodes pointed to by more than one node must be pointed to by local vari\u00adables at the end \nof the procedure s execution. This requires that only a bounded number of new shared nodes can be introduced \nby each procedure call. Note that many heap-manipulating pro\u00adgrams exhibit limited sharing as noted in \nthe experimental mea\u00adsurements of Mitchell [16]. A similar restriction is also used in shape analysis \ntechniques for device driver programs [27]. Loop-free We assume that all code is loop free, with loops \nre\u00adplaced by recursive calls.  1.4 Outline of the rest of this paper Section 2 provides a rule for adapting \nlocal changes to states con\u00ad taining a global heap. The idea is that the programmer only spec\u00adi.es changes \nin a small, local area of the heap. Section 3 intro\u00ad duces a new logic called AEAR. Section 4 formalizes \nthe require\u00ad ments for specifying the meaning of commands and procedures. The technique for generating \nveri.cation conditions is presented in Section 5. Extensions to the frameworks are discussed in Section \n6. Our preliminary veri.cation experience appears in Section 7. Sec\u00ad tion 8 discusses related work and \nSection 9 concludes. Details of the logical proof are contained in [10, Appendix A]. 2. Adaptation of \nLocal Effect to the Global Heap Our goal is to reason modularly about a procedure that modi.es a subset \nof the heap. We wish to automatically update the reachabil\u00adity relation in the entire heap based on the \nchanges to the modi.ed subset. We remark that in this paper we are concerned with reacha\u00adbility between \nany two nodes in the heap, as opposed to only those pointed to by program variables. When we discuss \nsharing we mean sharing via pointer .elds in the heap as opposed to aliasing from stack variables, which \ndoes not concern us in this paper. 2.1 Non-Local Effects Reachability is inherently non-local: a single \nedge mutation can af\u00adfect the reachability of an unbounded number of points that are an modf *  modf \n* find x z z  Figure 5. A case where changes made by find have a non-local effect: y(f * )c, but \u00acy(f \n* )c. unbounded distance from the point of change. Fig. 5 contains a typ\u00ad ical run of find. Two kinds \nof frames are depicted: (i) modf = [x, rx )f , speci.ed by the programmer, denotes the nodes whose edges \ncan be directly changed by find this is the standard no\u00adtion of a frame condition; (ii) modf * denotes \nnodes for which f * , the path relation, has changed. We do not and, in general we can\u00adnot, specify modf \n* in a modular way because it usually depends on variables outside the scope of this function such as \ny in Fig. 5. In the example shown, there is a path from y to c before the call which does not exist after \nthe call. Furthermore, modf * can be an arbitrarily large set: in particular, it may not be expressible \nas the union of a bounded set of intervals: for example, when adding a subtree as a child of some node \nin another tree, modf spans only one edge, whereas modf * is the entire subtree added which may contain \nan unbounded number of branches. The postcondition of find is sound (every execution of find satis.es \nit), but incomplete: it does not provide a way to determine information concerning paths outside mod, \nsuch as from y to c in Fig. 5. Therefore, this rule is often not enough in order to verify the correctness \nof programs that invoke find in larger contexts. Notice the dif.culty of updating the global heap, especially \nthe part modf * \\modf . In particular, using only the local speci.cation of find, one would not be able \nto prove that \u00acy(f * )c. Indeed, the problem is updating the reachability of elements that are outside \nmod; in more complex situations, these elements may be far from the changed interval, and their number \nmay be unbounded. One possibility to avoid the problem of incompleteness is to specify a postcondition \nwhich is speci.c to the context in which the invocation occurs. However, such a solution requires reasoning \nper call site and is thus not modular. We wish to develop a rule that will .t in all contexts. Reasoning \nabout all contexts is naturally done by quanti.cation. 2.2 An FO(TC) Adaptation Rule A standard way \nto modularize speci.cations is to specify the local effect of a procedure and then to use a general adaptation \nrule (or frame rule) to derive the global effect. In our case, we know that locations outside mod are \nnot modi.ed. Therefore, for example, after a call to find, a new path from node s to node t is either \nan old path from s to t , or it consists of an old path to a node a . mod, a new path from a to a node \n\u00df . mod and an old path from \u00df to t . We express this below, .rst letting q denote an old edge that is \nnot inside mod: .a, \u00df : a(q)\u00df . a(f )\u00df . (a /. mod . \u00df /. mod) .s, t : s(f * )t . s(q * )t . .a, \u00df . \nmod : (1) s(q * )a . a(f * )\u00df . \u00df(q * )t eq (1) is a completely general adaptation rule: it de.nes f \n* on the global heap assuming we know f * on the local heap and we also have access to the old path relation \nq *. The problem with this rule is that it uses a logic that is too expressive and thus hard for automated \nreasoning: FO(TC) is not decidable (in fact, not even (a) (b) 2 3 4 a 2 3 4 a 2 2 3 4 a a (c) \n(d) del (2, 3) del (2, 3) Figure 6. Memory states with non-unique pointers where global reasoning about \nreachability is hard. In the memory state (a), there is one edge from a into the modi.ed-set {1, 2, 3, \n4}, and in mem\u00adory state (b), there are two edges from a into the same modi.ed-set, {1, 2, 3, 4}. The \ntwo memory states have the same reachability re\u00adlation and therefore are indistinguishable in terms of \nreachability. The memory states (c) and (d) are obtained from the memory states (a) and (b), respectively, \nby deleting the edge (2, 3). The reacha\u00adbility in (c) is not the same as in (d), which shows it is impossible \nto update reachability in general w.r.t. edge deletion, without using the edge relation. enmod enmod \n: V . mod mod enmod Figure 7. The function enmod maps every node s to the .rst node in mod reachable \nfrom s. Notice that for any a . mod, enmod (a) = a by de.nition. recursively enumerable). The .rst problem \nis that the q * relation is not usually .rst order expressible and generally requires transitive closure. \nFor example, Fig. 6 shows that in general the adaptation rule is not necessarily de.nable using only \nthe reachability relation, when there are multiple outgoing edges per node. We avoid this problem by \nonly reasoning about functional .elds, f . The second problem with eq (1) is that it contains quanti.er \nalternation. a matches an arbitrary node in mod which may be of arbitrary size. Therefore, it is not \ncompletely obvious how to avoid existential quanti.cations.  2.3 An Adaptation Rule in a Restricted \nLogic We now present an equivalent adaptation rule in a restricted logic, without transitive closure \nor extra quanti.er-alternations. This is possible due to our assumptions from Section 1.3 and it greatly \nsimpli.es reasoning about modi.ed paths in the entire heap. We require a new function symbol, enmod . \nWe call enmod (s) the entry point of s in mod, i.e., the .rst node on the (unique) path from s that enters \nmod, and null if no such node exists (see Figure 7). Note that since transitive closure is only applied \nto functions, entry points such as a in eq (1) are uniquely determined by s, the origin of the path. \nA key property of enmod is that on mod itself, enmod is the identity, and therefore for any s . V it \nholds that mod (enmod (s)) mod is en= enmod (s)) that is, the function enidempotent. It is important \nto note that enmod does not change as a result of local modi.cations in mod. Hence, we do not need to \n . . . s t mod Figure 8. This diagram depicts how an arbitrary path from s ./ mod to t ./mod is constructed \nfrom three segments: [s, a]f , [a, ti ]f , and [ti , t ]f (here i = 2). Arrows in the diagram denote \npaths; thick arrows entering and exiting the box denote paths that were not modi.ed since they are outside \nof mod. Here, a = enmod (s) is an entry-point and t1, t2 are exit-points. worry about enmod in the pre-state \nas opposed to the post-state. Formally, enmod is characterized by the following formula: .s : (enmod \n(s) = null . .a . mod : \u00acs(f * )a) . mod mod (s(f * )en(s) . en(s) . mod . (2) .a . mod : s(f * )a . \nenmod (s)(f * )a) Using enmod the new adaptation rule adapt[mod] is obtained by considering, for every \nsource and target, the following three cases: Out-In: The source is out of mod; the target is in; In-Out: \nThe source is in mod; the target is out; Out-Out: The source and target are both out of mod. The full \nadaptation rule is obtained by taking the conjunction of the formulas for each case (eq (3), eq (4), \neq (5)), that are described below, and the formula de.ning enmod (eq (2)). Out-In Paths Using enmod we \ncan easily handle paths that enter mod. Such paths originate at some s /. mod and terminate at some t \n. mod. Any such path therefore has to go through enmod (s) as depicted in Fig. 8. Thus, the following \nsimple formula can be used: * mod * .s /. mod, t . mod : s(f )t . en (s)(f )t (3) Observe that for any \n\u00df . mod, the atomic formula used above, enmod (s)(f * )\u00df, corresponds to the FO(TC) sub-formula .a . \nmod : s(q * )a . a(f * )\u00df from eq (1). In-Out Paths We now shift attention to paths that exit mod. Exit \npoints, that is, last points on some path that belong to mod, are more subtle since both ends of the \npath are needed to determine them. The end of the path is not enough since it can be shared, and the \norigin of the path is not enough since it can exit the set multiple times, because a path may exit mod \nand enter it again later. Therefore, we cannot de.ne a function in a similar manner to enmod . The fact \nthat transitive closure is only applied to functions is useful here: every interval [a, \u00df] has at most \none exit \u00df. We therefore utilize the fact that mod is expressed as a bounded union of intervals which \nbounds the potential exit points to a bounded set of terms. We will denote the exit points of mod by \nti . For example, in the procedure swap shown in Fig. 9, mod = [x, f 3] and there is one exit point t1 \n= f 3 (f 3 is a constant set by x xx the precondition to have the value of f (f (f (x))) using the inversion \nformula eq (6) to be introduced formally in Section 3.1). Any path that originates in mod and terminates \noutside mod must leave through a last exit point ti (see Fig. 10). Notice that the exit points also do \nnot change as a result of modifying edges between nodes in mod. Let p be a path from s to t and let ti \nbe the last exit point along p. Note that the part of the path from ti to @ requires Ef (x, fx 1) . \nEf (fx 1 , fx 2) . Ef (fx 3 , fx 2). x = null . f 1 = null . f 2 = null x x @ mod [x, fx 3] @ ensures \n. . . void swap(Node x) { Node t = x.f; x.f = t.f; t.f = x.f.f;  modn x.f.f = t; } Figure 9. A simple \nfunction that swaps two adjacent elements following x in a singly-linked list. Dotted lines denote the \nnew state after the swap. The notation e.g. Ef (x, fx 1) denotes the single edge from x to fx 1 following \nthe f .eld. s t1 t2 mod Figure 10. A subtle situation occurs when the path from s passes through multiple \nexit-points. In such a case, the relevant exit-point for s(f * )t1 is t1, whereas for s(f * )t2 and t1(f \n* )t2 it would be t2. void swap_two(Node a, Node b) { swap(a); swap(b); } Figure 11. An example of a \nprocedure where the mod-set is not (essentially) convex. t consists only of unchanged edges since they \nare all outside of mod. We can therefore safely use f *, rather than q *, to characterize it. The part \nof the path from s to ti can be characterized by f * , because s and ti are both in mod. Therefore the \nentire path can be expressed as s(f * )ti . ti (f * )t. Thus, we obtain the following formula: .s . mod, \nt /. mod : s(f * )t . m (s(f * )ti . ti (f * )t .tj ./[ti , t ]f ) (4) ti tj'=ti Note that eq (4) corresponds \nthe sub-formula .\u00df : a(f * )\u00df . \u00df(q * )t in eq (1). Out-Out Paths For paths between s and t , both outside \nmod, there are two possible situations: The path goes through mod (as in Fig. 8). In this case, we can \nreuse the in-out case, by taking enmod (s) instead of s.  The path is entirely outside of mod (see Fig. \n12).  The corresponding formula in this case is: .s /. mod, t /. mod : s(f * )t .m (enmod (s)(f * )ti \n. ti (f * )t . tj ./[ti , t ]f ) (5) ti tj'=ti mod mod . en(s) = en(t ) . s(f * )t s1 t1 a mod  s2 \nt2 Figure 12. Paths that go entirely untouched. enmod (s1) = a, whereas enmod (s2) = null. Notice that \nthe second disjunct covers the case where there is a mod mod path from t to mod (en(s) = en(t ) = null) \nand the case mod mod where there is none (en(s) = en(t ) = null). In conclusion, our adaptation rule, \nadapt[mod], is the conjunc\u00adtion of the three formulas in eq (3), eq (4), eq (5), and the for\u00ad mula de.ning \nenmod (eq (2)). We need some more formalism, in\u00ad troduced in the next section, before we show that adapt[mod] \nmeets our needs. 3. Adaptable Heap Reachability Logic In this section we introduce an extension of AER \nfrom [11], called adaptable heap reachability logic, and denoted by AEAR. This extension still has the \nattractive property of AER, as it is effectively reducible to the function-free . * . *-fragment of .rst-order \nlogic, and thus its validity can be checked by a SAT-solver. 3.1 Preliminaries This section reviews the \nAF R (alternation free) and AER (..) log\u00adics from [11]. They are decidable for validity since their negation \ncorresponds to the BSR fragment [18]. These logics include the re\u00ad lation f * (the re.exive transitive \nclosure of f ) but forbid the explicit use of function symbols including f . Until Section 6 we will \nuse at most one designated backbone function (f ) per formula. De.nition 1. A vocabulary V = (C, {f }, \nR) is a triple of constant symbols, function symbol, relation symbols. A term, t, is a variable or constant \nsymbol. An atomic formula is one of the following: (i) t1 = t2; (ii) r(t1, t2, . . . , ta ) where r \nis a relation symbol of arity a; (iii) t1(f * )t2. A quanti.er-free formula (QF R) is a boolean combination \nof atomic formulas. A universal formula begins with zero or more universal quanti.ers followed by a quanti.er-free \nformula. An alternation-free formula (AF R) is a boolean combination of universal formulas. AER consists \nof formulas with quanti.er\u00adpre.x .*.* . In particular, QF R . AFR . AER. The preconditions and the postconditions \nin Fig. 2 are all AFR formulas. Decidability and Inversion Every AER formula can be trans\u00adlated to a \n.rst-order . * . * formula via the following steps [11]. (i) Add a new uninterpreted relation Rf which \nis intended to rep\u00adresent (f * ), the re.exive transitive closure of reachability via f , (ii) Add the \nconsistency rule GlinOrd shown in Table 1, which re\u00ad quires that Rf is a total order, i.e., re.exive, \ntransitive, acyclic, and linear, and (iii) Replace all occurrences of t1(f * )t2 by Rf (t1, t2).  Proposition \n1 (Simulation of AER). [12, Proposition 3, Appendix A.1] Consider AER formula . over vocabulary V = (C, \n{f }, R). def Let .1 = .[Rf (t1, t2)/t1(f * )t2]. Then .1 is a .rst-order formula over vocabulary V1 \n= (C, \u00d8, R . {Rf }) and GlinOrd . .1 is valid if and only if the original formula . is valid. .a : Rf \n(a, a) . re.exivity .a, \u00df, . : Rf (a, \u00df) . Rf (\u00df, .) . Rf (a, .) . transitivity .a, \u00df : Rf (a, \u00df) . Rf \n(\u00df, a) . a = \u00df . acyclicity .a, \u00df, . : Rf (a, \u00df) . Rf (a, . ) . (Rf (\u00df, .) . Rf (., \u00df)) linearity Table \n1. A universal formula GlinOrd requiring that all points reachable from a given point are linearly ordered. \nWhen the graph of f is acyclic, the relation Ef characterizing the function f can be recovered from its \nre.exive transitive closure, f *, at the cost of an extra universal quanti.er: def * Ef (a, \u00df) = a(f \n+)\u00df . .. : a(f +). . \u00df(f ). (6) def Here a(f +)\u00df = a(f * )\u00df . a = \u00df.  3.2 Adaptable Heap Reachability \nLogic The new logic AEAR is obtained by augmenting AER with unary function symbols, denoted by g, h1, \n. . . , hn where: g must be interpreted as an idempotent function.  The images h1, . . . , hn are all \nbounded by some pre-determined parameter N , that is: each hi takes at most N distinct values.  Function \nsymbols may not be nested, i.e., all terms involving function symbols have the form f (z), where z is \na variable.  We later show that AEAR suf.ces for expressing the veri.ca\u00adtion conditions of the programs \ndiscussed above. In the typical use case, the function g assigns the entry point in the mod-set for ev\u00adery \nnode (called enmodf above), and the functions h1, . . . , hn are used for expressing the entry points \nin inner mod-sets. The main attractive feature of this logic is given in the following theorem. Theorem \n1. Any AEAR-formula . can be translated to an equi\u00advalid (.rst-order) function-free . * . *-formula. \nThe proof of Theorem 1, given in [10, Appendix A], begins by translating . to a . * . *-formula .1 as \ndescribed in Proposition 1, without modifying the function symbols g, h1, . . . , hn . The func\u00adtion \nsymbols are then replaced by new relation and constant sym\u00adbols. We add new universal formulas to express \nthe above semantic restrictions on the functions. 4. Modular Speci.cations of Procedure Behaviours 4.1 \nNotations De.nition 2. Let V = (C, {f }, R) be a vocabulary including the constant symbol null. A state, \nM , is a logical structure with domain M f M M |M |, including null, and null = null = (null), where \ns is the interpretation of the symbol s in the structure M . A state is appropriate for an annotated \nprocedure proc if its vocabulary includes every symbol occurring in its annotations, and constants corresponding \nto all of the program variables occurring in proc. The diagrams in this paper denote states. For example \nFig. 1 shows a transition between two states. Below we de.ne the notion of two-vocabulary structures, \nwhich are useful to describe relations between pre-and post-states. De.nition 3 (Two-vocabulary Structure). \nFor states M and M over the same vocabulary V = (C, {f }, R) and with the same domain (|M | = |M |), \nwe denote by M /M the structure over the two-vocabulary V1 = (C . C \\ {null}, {f , f }, R . R) obtained \nby combining M , M in the following way: f is interpreted as f M and f is interpreted as f M , and similarly \nfor all the other symbols. De.nition 4 (Backbone Differences). For states M and M over the same vocabulary \nV = (C, {f }, R) and with the same domain (|M | = |M |), the set M . M consists of the differences between \nM and M w.r.t. f , excluding null , i.e. all elements u of |M | such that f M (u) = f M (u), as well \nas their non-null images in f M and f M . For example, in Fig. 3, let M be the left structure and M \nthe right structure. Then M .M = {x, r, D}, where D is the unlabeled node with an edge from x in the \nleft diagram. 4.2 Modi.cation Set We must specify the mod-set, mod, containing all the endpoints of \nedges that are modi.ed. Therefore when adding or deleting an edge (s, t), both ends the source, s, and \nthe target, t are included in mod. Often in programming language semantics, only the source is considered \nmodi.ed. However, thinking of the heap as a graph, it is useful to consider both ends of a modi.ed edge \nas modi.ed. For example, in the running example program find (Fig. 2), since new references to rx may \nbe introduced as a result of path compression, the root rx is also considered as part of mod. Our mod-sets \nare built from two kinds of intervals: De.nition 5 (Intervals). The closed interval [a, b]f is def * \n* [a, b]f = {. | a(f ). . .(f )b} and the half-open interval [a, null)f is: def * [a, null)f = {. | \na(f ). . .(f +)null} (notice that .(f * )null is always true in acyclic heaps). De.nition 6 (mod-set). \nThe mod-set, mod, of a procedure is a union I1 . I2 . . . . . Ik , where each Ii may be [si , ti ]f or \n[si , null)f , si , ti are parameters of the procedure or constant symbols occur\u00adring in the pre-condition. \nIn our examples, the mod-sets of find and union are written above each procedure, preceded by the symbol \n@ mod (Fig. 2). Note that it follows from De.nition 6 that a . mod, is expressible as a quanti.er-free \nformula. De.nition 7. Given an appropriate state M for proc with modset mod, modM is the set of all elements \nin |M | that are in one of the intervals de.ning mod (see De.nition 5). 4.3 Pre-and Post-Conditions \nThe programmer speci.es AF R pre-and post-conditions. Two\u00advocabulary formulas may be used in the post-conditions \nwhere f denotes the value of f before the call. 4.4 Specifying Atomic Commands Table 2 provides speci.cation \nof atomic commands. They describe the memory changed by atomic statements and the changes on the local \nheap. Accessing a pointer .eld The statement ret = y.f reads the content of the f -.eld of y, into ret. \nIt requires that y is not null and that an auxiliary variable s points to the f -.eld of y (which may \nbe null). It does not modify the heap at all. It sets ret to s. Command Pre Mod Post retval = y.f y \n= null . Ef (y, s) \u00d8 retval = s y.f = null y = null . Ef (y, s) [y, s]f \u00acy(f * )s . \u00acs(f * )y assume \ny.f==null; y.f = x y = null . Ef (y, null) . \u00acx(f * )y [y, y]f . [x, x]f y(f * )x . \u00acx(f * )y Table \n2. The speci.cations of atomic commands. s is a local constant denoting the f -.eld of y. Ef is the inversion \nformula de.ned in eq (6). It is interesting to note that the postcondition is quant.er free and much \nsimpler than the one provided in [11]. The reason is that we do not need to specify the effect on the \nwhole heap. Edge Removals The statement y.f = null sets the content of the f -.eld of y, to null. It \nrequires that y is not null and that an auxiliary variable s points to the f -.eld of y (which may be \nnull). It modi.es the node pointed-to by y and potentially the node pointed-to by s. Notice that the \nmodset includes the elements pointed to by y and s, the two end-points of the edge. It removes paths \nbetween y and s. The postcondition asserts that there are no paths from y to s. Also, since s is potentially \nmodi.ed, it asserts that there are no paths from s to y. Edge Additions The statement y.f = x is speci.ed \nassuming without loss of generality, that the statement y.f = null was applied before it. Thus, it only \nhandles edge additions. It therefore requires that y is not null and its f -.eld is null. It modi.es \nthe node pointed-to by y and potentially the node pointed-to by x. It creates a new path from y to x \nand asserts the absence of new paths from x back to y. Again the absence of back paths (denoted by \u00acx(f \n* )y) is needed for completeness. The reason is that both the node pointed-to by x and y are potentially \nmodi.ed. Since x is potentially modi.ed, without this assertion, a post-state in which x.f == y will \nbe allowed by the postcondition. 4.4.1 Soundness and Completeness We now formalize the notion of soundness \nand completeness of modular speci.cations and assert that the speci.cations of atomic commands are sound \nand complete. De.nition 8 (Soundness and Completeness of Procedure Speci.\u00adcation). Consider a procedure \nproc with precondition P, modset mod, post-condition Q. We say that (P, mod, Q) is sound with re\u00adspect \nto proc if for every appropriate pre-state M such that M |= P, and appropriate post-state M which is \na potential outcome of the body of proc when executed on M : (i) M . M . modM , (ii) M /M |= Q. Such \na triple (P, mod, Q) is complete with respect to proc if for every appropriate states M , M such that \n(i) M |= P, (ii) M /M |= Q, and (iii) M . M . modM , then there exists an execution of the body of proc \non M whose outcome is M . The following proposition establishes the correctness of atomic statements. \nProposition 2 (Soundness and Completeness of Atomic Com\u00admands). The speci.cations of atomic commands \ngiven in Table 2 are sound and complete. The following lemma establishes the correctness of find and \nunion, which is interesting since they update an unbounded amount of memory. Lemma 1 (Soundness and Completeness \nof Union-Find). The speci.cation of find and union in Fig. 2 is sound and complete. We can now state \nthe following proposition: Proposition 3 (Soundness and Completeness of adapt[]). Let mod be a mod-set \nof some procedure proc. Let M and M be two wp[ skip]](Q) def = Q wp[ x := y] , Q) wp[ S1 ; S2]](Q) def \n= def = Q[y/x] wp[ S1] wp[ S2]](Q) wp[ if B then S1 else S2]](Q) def = [ B] . wp[ S1]](Q) . \u00ac[ B] . \nwp[ S2]](Q) Table 3. Standard rules for computing weakest liberal precondi\u00adtions for loop free code \nwithout pointer accesses. [ B] is the AFR formula for program conditions and Q is the postcondition ex\u00adpressed \nas an AF R formula. appropriate states for proc. Then, M . M . modM iff M /M augmented with some interpretation \nfor the function symbol enmod is a model of adapt[mod]. 5. Generating Veri.cation Condition for Procedure \nWith Sub-calls in AEAR We follow the standard procedures, e.g. [26], which generates a ver\u00adi.cation condition \nfor a procedure annotated with speci.cation us\u00ading weakest (liberal) preconditions. Roughly speaking, \nfor a Hoare triple {P}prog{Q}, we generate the usual veri.cation condition vc[prog] = P . wp[ prog]](Q). \nFor the basic commands (assignment, composition, and condi\u00adtional) we employ the standard de.nitions, \ngiven in Table 3. 5.1 Modular Veri.cation Conditions The modular veri.cation condition would also contain \na conjunct for checking that mod affected by the invoked procedure is a subset of the outer mod. This \nway the speci.ed restriction can be checked in AEAR and the SMT solver can therefore be used to enforce \nit automatically. 5.2 Weakest-precondition of Call Statements As discussed in Section 2, the speci.cation \nas it appears in the en\u00adsures clause of a procedure s contract is a local one, and in order to make reasoning \ncomplete we need to adapt it in order to handle arbitrary contexts. This is done by conjoining Qproc \noccurring in the ensures clause from the speci.cation of proc with the uni\u00adversal adaptation rule adapt[mod], \nwhere mod is replaced with the mod-set as speci.ed in the modi.es clause of proc. Table 4 presents a \nformula for the weakest-precondition of a statement containing the single procedure call, where the invoked \nprocedure has the speci.cations as in Fig. 13, where proc has the formal parameters x = x1, . . . , xk \n, and it is used with a = a1, . . . , ak (used in the formula) as the actual arguments for a speci.c \nprocedure call; we assume w.l.g. that each ai is a local variable of the calling procedure. In general \nit is not obvious how to enforce that the set of locations modi.ed by inner calls is a subset of the \nset of locations declared by the outer procedure. Moreover, this can be tricky to check since it depends \non aliasing and paths between nodes pointed @ requires Pproc @ mod modproc @ ensures Qproc return-type \nproc(x) { ... } Figure 13. Speci.cation of proc with placeholders. def wp[ r := proc(a)]](Q) = Pproc[a/x] \n. .a : a . modproc[a/x] . a . modprog . .. : Qproc[a/x, f/f , f /f , ./retval]. JI J adaptmodproc[f /f \n] [a/x, f/f , f /f ] . J Q[f/f , ./r] Table 4. Computing the weakest (liberal) precondition for a state\u00adment \ncontaining a procedure call. r is a local variable that is as- J signed the return value; a are the actual \narguments passed. fis a fresh function symbol. to by different variables. Fortunately, the sub-formula \n.a : a . modproc[a/x] . a . modprog captures this property, ensuring that the outer procedure does not \nexceed its own mod speci.cation, taking advantage of the interval-union structure of the mod. Since all \nthe modi.cations (even atomic ones) are done by means of procedure calls, this ensures that no edges \nincident to nodes outside mod are changed. Proposition 4. The rule for wp[[]] of call statements is sound \nand complete, that is, when proc is a procedure with speci.cation as in Fig. 13, called in the context \nof prog whose mod-set is mod: M |= wp[ r := proc(a)]](Q) M M |= Pproc[a/x] . modproc . modM . (7) M .M \n: M /M |= Qproc[a/x] . M . M . modproc . M [r . retvalM ] |= Q  5.3 Reducing Function Symbols Notice \nthat when we apply the adaptation rule for AEAR , as dis\u00adcussed above, it introduces a new function symbol \nenmod depend\u00ading on the concrete mod-set of the called procedure. This introduces a complication: the \nmod-sets of separate procedure calls may differ from the one of the top procedure, hence multiple applications \nof Table 4 naturally require a separate function symbol enmod for ev\u00adery such invocation. Consider for \nexample the situation of union making two invocations to find. In Fig. 14 one can see that the mod of \nunion is [x, rx ]f . [y, ry ]f , while the mod of the .rst call t := find(x) is [x, rx ]f , which may \nbe a proper subset of the former. The mod of the second invocation is [y, ry ]f , which may overlap with \n[x, rx ]f . To meet the requirement of AEAR concerning the function symbols, we observe that: (a) the \namount of sharing any particular function call creates, as well as the entire call, is bounded, and we \ncan pre-determine a bound for it; (b) the modi.cation set of any sub-call must be a subset of the top \ncall, as otherwise it violates the obligation not to change any edge outside mod. These two properties \nallow us to express the functions enmod of the sub\u00adcalls using enmod of the top procedure and extra intermediate \nfunctions with bounded image. Thus, we replace all of the function symbols enS introduced by adapt[S] \nfor different S s, with a single (global, idempotent) function symbol together with a set of bounded \nfunction symbols. [x, rx ]f . [y, ry ]f [x, rx ]f . [y, ry ]f A d en mod = A  B|A composing with an \nauxiliary function en. Consider a statement r := proc(a) in a procedure prog. Let A denote the mod-set \nof prog, and B the mod-set of proc. We show how enB can be expressed using enA and one more function, \nB|A where the latter has a bounded range. We de.ne en: A \\ B . B a new function that is the restriction \nof enB to the domain A \\ B. enB|A is de.ned as follows: B def enA(s) enA(s) . B en (s) =(8) B|A A en(en(s)) \notherwise Using equality the nesting of function symbols can be reduced (without affecting the quanti.er \nalternation). Consult Fig. 15; notice that enB|A(s) is always either: The beginning si of one of the \nintervals [si , ti ]f of B (such as 1 in the .gure);  A node that is shared by backbone pointers from \ntwo nodes in A (such as 3 );  The value null.  A bound on the number of si s is given in the modular \nspeci.ca\u00adtion of proc. A bound on the number of shared nodes is given in the next subsection. This bound \nis effective for all the procedure calls in prog; hence enB|A can be used in the restricted logic AEAR \n. 5.4 Bounding the Amount of Sharing We show that under the restrictions of the speci.cation given in \nSection 2 and Section 4, the number of shared nodes inside mod that is, nodes in mod that are pointed \nto by more than one f \u00adpointer of other nodes in mod has a .xed bound throughout the procedure s execution. \nConsider a typical loop-free program prog containing calls of the form vi := proci (ai ). Assume that \nthe mod-set of prog is a union of k intervals. We show how to compute a bound on the number of shared \nnodes inside the mod-set. Since there are k start points, at most k 2 elements can be shared when prog \nstarts executing. Each sub-procedure invoked from prog may introduce, by our restriction, at most as \nmany shared nodes as there are local variables in the sub-procedure. Therefore, by computing the sum \nover all invocation statements in prog, plus k 2 , we get a .xed bound on the number of shared nodes \ninside the mod-set.  k Nshared = k ++|Pvarproci | 2 proci Pvarproci signi.es the set of local variables \nin the procedure proci . Notice that if the same procedure is invoked twice, it has to be included twice \nin the sum as well.  5.5 Veri.cation Condition for the Entire Procedure Since every procedure on its \nown is loop-free, the veri.cation condition is straightforward: vc[prog] = Pprog . wp[ prog] Qprog . \nshared . Pvar where shared . Pvar is a shorthand for the (AER) formula: .a, \u00df, . . mod : Ef (a, .) . \nEf (\u00df, .) . m (9) a = \u00df . = v v.Pvar . See eq (6) for the de.nition of Ef . It expresses the obligation \nmentioned in Section 1.3 that all the shared nodes in mod should be pointed to by local variables, effectively \nlimiting newly introduced sharing to a bounded number of memory locations. Now vc[prog] is expressed \nin AEAR , and it is valid if-and-only\u00adif the program meets its speci.cation. Its validity can be checked \nusing effectively-propositional logic according to Section 3. 6. Extensions 6.1 Explicit Memory Management \nThis section sketches how to handle explicit allocation and recla\u00admation of memory and exempli.es it \non simple procedures shown in Fig. 16 and Fig. 17. The procedures push and pushMany extend a list at \nthe beginning by an unbounded of fresh elements allocated using new. The procedure deleteAll takes as \nargument a list that has no foreign pointers into it, and explicitly frees all elements. We verify that \nthe procedures do not introduce dangling pointers. Table 5 updates the speci.cation of atomic commands \n(provided in Table 2) to handle explicit memory management operations. For simplicity, we follow Ansii \nC semantics but do not handle arrays and pointer arithmetic. The allocation statement assigns a freed \nlocation denoted by s to retval and sets its value to be non-freed. All accesses to memory locations \npointed-to by y in statements retval = y.f, y.f = x, and x = y are required to access non\u00adfreed memory. \nFinally, free(y) sets the free predicate to true for the node pointed-to by y. As a result, all the nodes \nreachable from y cannot be accessed. The adaptation rule needs to be augmented in order to accom\u00admodate \nthe change. Since nodes that are about to be allocated do not have names, the mod shall refer only to \nallocated nodes; free nodes can always be changed and they need not be speci.ed in the mod. Of course, \nthe procedure s post-condition should describe the new structure of the allocated area in terms of reachability, \nif modular reasoning is desired. The change would be as follows: whenever there is a reference to some \ns . mod (in eq (3), eq (4), and eq (5)), we would now consider only s . (mod . free). This way the adaptation \nrule makes no claims regarding the free nodes. Everything else remains just the same. @ requires \u00acfree(h) \n@ mod [h, h]f .a : free(a) . free(a) . a = retval @ ensures retval(f * )h . \u00ach(f * )retval Node push(Node \nh) { Node e = new Node(); e.f = h; return e; } @ requires \u00acfree(h) @ mod [h, h]f .a : free(a) . free(a) \n@ ensures .a : free(a) . \u00acfree(a) . h(f * )a . a(f +)h Node pushMany(Node h) { if (?) { h = push(h); \nh = pushMany(h);  } return h; } Figure 16. The procedure push allocates a new element and in\u00adserts it \nto the beginning of the list. The procedure pushMany calls pushon the same list an arbitrary number of \ntimes. .a, \u00df : h(f * )a . \u00df(f * )a . h(f * )\u00df /* dominance */ @ requires .a : \u00aca(f +)h @ mod [h, null)f \n.a, \u00df . mod : \u00aca(f +)\u00df @ ensures .a : free(a) . free(a) . h(f * )a Node deleteAll(Node h) { if (h != \nnull) { j = h.f; h.f = null; free(h); deleteAll(j);  } } Figure 17. The procedure deleteAll explicitly \nreclaims the ele\u00adments of a list dominated by its head, where no other pointers to this list exist. \n6.2 Cyclic Linked-Lists For data structures with a single pointer, the acyclicity restriction may be \nlifted by using an alternative formulation that keeps and maintains more auxiliary information [7, 13]. \nThis can be easily done in AFR , see [11]. 6.3 Doubly-linked lists To verify a program that manipulates \na doubly-linked list, we need to support two .elds b and f . AF R supports this as long as the only atomic \nformulas used in assertions are a(f * )\u00df and a(b * )\u00df (and not, for example, a((b|f ) * )\u00df). In particular, \nwe can specify the doubly-linked list property: .a, \u00df : h(f * )a . h(f * )\u00df . (a(f * )\u00df . \u00df(b * )a). \n Command Pre Mod Post retval = new() free(s) \u00d8 retval = s . \u00acfree(s) access y \u00acfree(y) \u00d8 free(y) y = \nnull . \u00acfree(y) \u00d8 free(y) Table 5. The speci.cations of atomic commands for resource allocations in \na C like language. Unfortunately modularity presents another challenge: how the modset should be speci.ed, \nand how to formulate the adaptation rule. Since there are two pointer .elds (forward and backward), the \nadaptation rule (eq (1)) has to be instantiated twice. However that would require mod to be de.ned as \na union of intervals also according to b in addition to its being de.ned as such using f ; otherwise \nour logical arguments from Section 2.3 no longer hold. When the input is a valid doubly-linked list this \ncan always be done, since [a, \u00df]f = [\u00df, a]b. In cases such where the input is somewhat altered or corrupt \n(for example [23]), the logic will have to be modi.ed to incorporate the volatile exit points of back\u00adpointers \npotentially pointing to arbitrary nodes. This extension is out of the current scope. 7. Experimental \nResults 7.1 Implementation Details A VC generator described in Section 5 is implemented in Python, and \nPLY (Python Lex-Yacc) is employed at the front-end to parse modular recursive procedure speci.cations \nas de.ned in Section 4. The tool checks that the pre and the post-conditions are speci.ed in AFR and \nthat the modset is de.ned. SMT-LIB v2 [3] standard notation is used to format the VC and to invoke Z3. \nThe validity of the VC can be checked by providing its negation to Z3. If Z3 exhibits a satisfying assignment \nthen that serves as counterexample for the correctness of the assertions. If no satisfying assignment \nexists, then the generated VC is valid, and therefore the program satis.es the assertions. The output \nmodel/counterexample (S-Expression), if one is generated, is then also parsed and f * is evaluated on \nall pairs of nodes. This structure represents the state of the program either at the input or at the \nbeginning of a loop iteration: running the pro\u00adgram from this point will violate one or more invariants. \nTo provide feedback to the user, f is recovered by computing eq (6)), and then the pygraphviz tool is \nused to visualize and present to the user a directed graph, whose vertices are nodes in the heap, and \nwhose edges are the f pointer .elds.  7.2 Veri.cation Examples We have written modular speci.cations \nfor the example procedures shown in Table 7. We are encouraged by the fact that it was not dif\u00ad .cult \nto express assertions in AF R for these procedures. The an\u00adnotated examples and the VC generation tool \nare publicly available with the submission. We only picked examples with interesting cut\u00adpoints to show \nthe bene.ts of our approach in contrast to [11]. To give some account of the programs sizes, we observe \nthe program summary speci.cation given as pre-and postcondition, count the number of atomic formulas \nin each of them, and note the depth of quanti.er nesting; all our samples had only universal quanti.ers \nin the speci.cation. We did the same for the generated VC; naturally, the the VC is much larger than \nthe speci.cation even for small programs. Still, the time required by Z3 to prove that the VC is valid \nis short. Thanks to the fact that FOL-based tools, and in particular SAT solvers, permit multiple relation \nsymbols we were able to express UF: .nd, UF: union Implementation of a Union-Find dy\u00ad namic data structure. \nSLL: .lter Takes a linked list and deletes all ele\u00ad ments not satisfying some predicate C . SLL: quicksort \n Sorts a linked-list in-place using the Quicksort algorithm. SLL: insert-sort Creates a new, sorted \nlinked-list from a given list by repeatedly running insert on the elements of the input list.  Table \n6. Description of some pointer manipulating programs veri\u00ad.ed by our tool. Formula size Solving Benchmark \nP,Q mod VC time # . # # . (Z3) SLL: .lter 7 2 1 217 6 0.48s SLL: quicksort 25 2 1 745 9 1.06s SLL: insert-sort \n21 2 1 284 11 0.37s UF: .nd 13 2 1 203 6 0.40s UF: union 20 2 2 188 6 1.39s Table 7. Implementation \nBenchmarks; P,Q program s speci.\u00adcation given as pre-and post-condition, mod mod-set, VC veri.cation \ncondition, # number of atomic formulas/intervals, . quanti.er nesting The tests were conducted on a \n1.7GHz In\u00adtel Core i5 machine with 4GB of RAM, running OS X 10.7.5. The version of Z3 used was 4.2, complied \nfor 64-bit Intel architecture (using gcc 4.2, LLVM). The solving time reported is wall clock time of \nthe execution of Z3. ordering properties in sorted lists, and thus in the sorting routines implementing \nQuicksort and insertion-sort. Checked properties. For Table 6, apart from .nd and union, we also checked \nfull functional correctness of the other examples (.l\u00adter, quicksort, insertion sort). For .lter, we \nchecked that elements remain in the same order and that only the elements satisfying the .ltering predicate \nwere removed. For the sorting routines, we checked that the resulting list contains the same elements \nand is indeed sorted (via an order relation). 7.3 Buggy Examples We also applied the tool to erroneous \nprograms and programs with incorrect assertions. The results, including run-time statistics and formula \nsizes, are reported in Table 8. The table lists four kinds of deliberately-introduced bugs that were \nprovided as input to the tool. Formula sizes are measured in the same way as in Table 7. In addition, \nfor every detected bug, our tool generates a con\u00adcrete counterexample depicting a state of the heap violating \nsome assertion. We measured the size of the model generated, by observ\u00ading the size of the generated \ndomain which re.ects the number of nodes in the heap. As expected, Z3 was able to produce con\u00adcrete \ncounterexample of reasonable size, producing output which is readable for the programmer and useful for \ndebugging. In fact, our tool converts Z3 models into directed graph diagrams which facili\u00adFormula size \nSolving C.e.   Benchmark P,Q VC time size (+ Nature of defect) # . # . (Z3) (|L|) UF: .nd 27 3 201 \n6 1.60s 2 Incorrect handling of cor\u00adner case UF: union 19 2 186 6 0.70s 8 Incorrect speci.cation SLL: \n.lter 36 4 317 6 0.49s 14 Uncontrolled sharing SLL: insert-sort 21 2 283 9 0.88s 8 Unmet call precondition \nTable 8. Information about benchmarks that demonstrate detection of several kinds of bugs in pointer \nprograms. In addition to the pre\u00advious measurements, the last column lists the size of the generated \ncounterexample in terms of the number of vertices linked-list or tree nodes. tate debugging our assertions. \nSince the counterexamples are slight variations of the correct programs, size and running time statistics \nare similar. 8. Related Work 8.1 Modular Veri.cation The area of modular procedure speci.cation is heavily \nstudied. Many of these works require that the user declare potential changes similar to the modset (e.g., \nsee [2, 14, 25, 29]). The frame rule of separation logic [9] naturally supports modular reasoning where \nthe separating conjunction combines the local postcondition with the assertion at the call site. Unlike \nseparation, reachability is a higher abstraction which relies on type correctness and naturally abstracts \noperations such as garbage collection. Nevertheless, in Section 6.1 we show that it can also deal with \nexplicit memory reclamations. We believe that our work in this paper pioneers the usage of an effectively \npropositional logic which is a weak logic to perform modular reasoning in a sound and complete way. Our \nadaptation rule is more complex than the frame rule as it automatically updates reachability. The idea \nof using the idempotent entry point function to enable local reasoning about list-manipulating programs \n(includ\u00ading an EPR reduction) has been explored independently by Piskac et al. [19], where it was used \nto automate the frame rule in sep\u00ad aration logic. In this paper we identify a general EPR fragment of \nassertions for which this idea of the idempotent entry point function is sound and complete. 8.1.1 Cutpoints \nRinetzky et al. [21] introduce cutpoint objects which are objects that can reach the area of the heap \naccessible by the procedure without passing through objects directly pointed-to by parameters. Cutpoints \ncomplicate program reasoning. They are used in model checking [1] and static analysis [6, 22]. Examples \nsuch as the ones in [23] which include (unbounded) cutpoints from the stack are handled by our method \nwithout any changes. These extra cutpoints cannot change the reachabilty and thus have no effect. Interestingly, \nwe can also handle certain programs which manipulate unbounded cutpoints. Instead, we do limit the amount \nof new sharing in paths which are necessary for the veri.cation. For example, the .nd procedure shown \nin Fig. 2 includes unbounded sharing which can be created by the client program. A typical client such \nas a spanning tree construction algorithm will indeed create unbounded sharing. In the future, we plan \nto verify such clients by abstracting away the pointers inside the union-.nd tree.  8.2 Decision Procedures \nMany decision procedures for reasoning about linked lists have been proposed [4, 15, 17, 28]. All these \nlogics are based on monadic second-order logic on trees which has a non-elementary time (and space) asymptotic \ncomplexity. We follow [11] in using a weak logic which permits sound and complete reasoning using off \nthe shelf SAT solvers which are ef.cient in practice and can be imple\u00admented in polynomial space. Indeed \nour preliminary experimental results reported Section 7 show that Z3 is fast enough and may be even useful \nfor automatically generating abstract interpreters as suggested by [20]. Interestingly, the adaptation \nrule drastically simpli.es the Weakest-Precondition rules given in [11]. Notice the speci.cations in \nTable 2 do not use quanti.ers at all, whereas in [11] the formulas contain quanti.ers with alternations. \nIndeed the appropriate quanti.ers are added in a generic manner by the adaptation rule and weakest\u00adprecondition. \n 8.3 Incremental Reachability Update Formulas for updating transitive closure w.r.t., graph mutations \nhave been developed by various authors (e.g., [5, 7, 8, 13]). These works assume that a single edge is \nadded and deleted. This sub\u00admission generalizes these results to procedures which perform un\u00adbounded \nmutations. Indeed our adaptation rule generalizes [7, 11, 13]) which provides reachability update formula \nw.r.t. the removal of a single edge. 9. Conclusion A crucial method for simplifying the reasoning about \nlinked data structures is partitioning them into basic blocks, where each basic block has only one entry \npoint and one exit point. This paper slightly generalizes by reasoning about blocks with a potentially \nunbounded number of entry points, as demonstrated by find and union. Notice that this unboundedness supports \nmodularity: even in the case where in every particular call context there is a bounded number of paths \n(e.g. when there is a bounded number of roots in the heap), the bound is not known in advance, therefore \nthe programmer has to prepare for an unbounded number of cases. It is important to note that the adaptation \nrule adds expressive power to verifying programs: it is in general impossible for the programmer to de.ne, \nin AF R, a modular speci.cation for all the procedures. Generation of a veri.cation condition requires \ncoordi\u00adnation between the separate call sites as mentioned above, in par\u00adticular taking note of potential \nsharing. This coordination requires per-call-site instantiation, which, thanks to having the adaptation \nrule in the framework, is done automatically. Finally we remark that there is a trade-off between mod \nand the post-condition: de.ning a simpler, but larger mod may cause the post-condition to become more \ncomplicated, sometimes not even AF R-expressible. Also notice that if mod = V (the entire heap), modular \nreasoning becomes trivial since it can be done by relational composition, but this puts the burden of \nwriting the most complete post-conditions on the programmer, which sometimes is not even possible in \na limited logic. Therefore, we believe that this paper takes a step towards modu\u00adlar reasoning about \nreachability in programs that manipulate linked lists. Lifting such reasoning to more complex data structures \nsuch as trees and graphs remains future work. Acknowledgement. Thanks to the anonymous referees for their \ncomments. Itzhaky, Lahav and Sagiv were funded by the Eu\u00adropean Research Council under the European Union \ns Seventh Framework Program (FP7/2007-2013) / ERC grant agreement no. [321174-VSSC] and by a grant from \nthe Israel Science Founda\u00adtion (652/11). Banerjee and Nanevski were partially supported by by Spanish \nMINECO projects TIN2009-14599-C03-02 Desa.os, TIN2010-20639 Paran10, TIN2012-39391-C04-01 Strongsoft, \nEU NoE Project 256980 Nessos, AMAROUT grant PCOFUND-GA\u00ad2008-229599, and Ramon y Cajal grant RYC-2010-0743. \nImmer\u00adman was partially supported by NSF grant CCF 1115448. References [1] M. F. Atig, A. Bouajjani, \nand S. Qadeer. Context-bounded analysis for concurrent programs with dynamic creation of threads. Logical \nMethods in Computer Science, 7(4), 2011. [2] M. Barnett, M. F\u00e4hndrich, K. R. M. Leino, P. M\u00fcller, W. \nSchulte, and H. Venter. Speci.cation and veri.cation: the spec# experience. Commun. ACM, 54(6):81 91, \n2011. [3] C. Barrett, A. Stump, , and C. Tinelli. SMTLIB: Satis.ability Modulo Theories Library, 2013. \nhttp://smtlib.cs.uiowa.edu/docs.html. [4] A. Bouajjani, C. Dragoi, C. Enea, and M. Sighireanu. Accurate \ninvariant checking for programs manipulating lists and arrays with in.nite data. In ATVA, pages 167 182, \n2012. [5] G. Dong and J. Su. Incremental and decremental evaluation of tran\u00adsitive closure by .rst-order \nqueries. Inf. &#38; Comput., 120:101 106, 1995. [6] A. Gotsman, J. Berdine, and B. Cook. Interprocedural \nshape analysis with separated heap abstractions. In SAS, pages 240 260, 2006. [7] W. Hesse. Dynamic Computational \nComplexity. PhD thesis, UMass in Computer Science, June 2003. [8] N. Immerman. Descriptive complexity. \nGraduate texts in computer science. Springer, 1999. [9] S. S. Ishtiaq and P. W. O Hearn. Bi as an assertion \nlanguage for mutable data structures. In POPL, pages 14 26, 2001. [10] S. Itzhaky, A. Banerjee, N. Immerman, \nO. Lahav, A. Nanevski, and M. Sagiv. Modular reasoning about heap paths via effectively propo\u00adsitional \nformulas. Technical report, Tel Aviv University, 2013. http: //www.cs.tau.ac.il/~shachar/dl/tr-2013b.pdf. \n[11] S. Itzhaky, A. Banerjee, N. Immerman, A. Nanevski, and M. Sagiv. Effectively-propositional reasoning \nabout reachability in linked data structures. In CAV, pages 756 772, 2013. [12] S. Itzhaky, A. Banerjee, \nN. Immerman, A. Nanevski, and M. Sagiv. Effectively-propositional reasoning about reachability in linked \ndata structures. Technical report, Tel Aviv University, 2013. http://www. cs.tau.ac.il/~shachar/dl/tr-2013.pdf. \n [13] S. K. Lahiri and S. Qadeer. Back to the future: revisiting precise program veri.cation using smt \nsolvers. In POPL, pages 171 182, 2008. [14] G. T. Leavens, A. L. Baker, and C. Ruby. Preliminary design \nof JML: a behavioral interface speci.cation language for Java. ACM SIGSOFT Software Engineering Notes, \n31(3):1 38, 2006. [15] P. Madhusudan, G. Parlato, and X. Qiu. Decidable logics combining heap structures \nand data. In POPL, pages 611 622. ACM, 2011. [16] N. Mitchell, E. Schonberg, and G. Sevitsky. Making \nsense of large heaps. In ECOOP, pages 77 97, 2009. [17] A. M\u00f8ller and M. I. Schwartzbach. The pointer \nassertion logic engine. In PLDI, pages 221 231. ACM, 2001. [18] R. Piskac, L. M. de Moura, and N. Bj\u00f8rner. \nDeciding effectively propositional logic using dpll and substitution sets. J. Autom. Reasoning, 44(4):401 \n424, 2010. [19] R. Piskac, T. Wies, and D. Zufferey. Automating separation logic using smt. In CAV, pages \n773 789, 2013. [20] T. W. Reps, S. Sagiv, and G. Yorsh. Symbolic implementation of the best transformer. \nIn VMCAI, pages 252 266, 2004. [21] N. Rinetzky, J. Bauer, T. W. Reps, S. Sagiv, and R. Wilhelm. A semantics \nfor procedure local heaps and its abstractions. In POPL, pages 296 309, 2005. [22] N. Rinetzky, M. Sagiv, \nand E. Yahav. Interprocedural shape analysis for cutpoint-free programs. In SAS, pages 284 302, 2005. \n[23] X. Rival and B.-Y. E. Chang. Calling context abstraction with shapes. In POPL, pages 173 186, 2011. \n[24] R. E. Tarjan. Ef.ciency of a good but not linear set union algorithm. Journal of the ACM, 22(2):215 \n225, 1975. [25] J. Wing. The CMU Larch Project. 1995. URL http://www.cs. cmu.edu/afs/cs/project/larch/www/home.html. \n[26] G. Winskel. The Formal Semantics of Programming Languages: An Introduction. Foundations of Computing \nSeries. Zone Books, U.S., 1993. ISBN 9780262731034. [27] H. Yang, O. Lee, J. Berdine, C. Calcagno, B. \nCook, D. Distefano, and P. W. O Hearn. Scalable shape analysis for systems code. In CAV, pages 385 398, \n2008. [28] G. Yorsh, A. M. Rabinovich, M. Sagiv, A. Meyer, and A. Bouajjani. A logic of reachable patterns \nin linked data-structures. J. Log. Algebr. Program., 73(1 2):111 142, 2007. [29] K. Zee, V. Kuncak, and \nM. C. Rinard. Full functional veri.cation of linked data structures. In PLDI, pages 349 361, 2008.  \n    \n\t\t\t", "proc_id": "2535838", "abstract": "<p>First order logic with transitive closure, and separation logic enable elegant interactive verification of heap-manipulating programs. However, undecidabilty results and high asymptotic complexity of checking validity preclude complete automatic verification of such programs, even when loop invariants and procedure contracts are specified as formulas in these logics. This paper tackles the problem of procedure-modular verification of reachability properties of heap-manipulating programs using efficient decision procedures that are complete: that is, a SAT solver must generate a counterexample whenever a program does not satisfy its specification. By (a) requiring each procedure modifies a fixed set of heap partitions and creates a bounded amount of heap sharing, and (b) restricting program contracts and loop invariants to use only deterministic paths in the heap, we show that heap reachability updates can be described in a simple manner. The restrictions force program specifications and verification conditions to lie within a fragment of first-order logic with transitive closure that is reducible to effectively propositional logic, and hence facilitate sound, complete and efficient verification. We implemented a tool atop Z3 and report on preliminary experiments that establish the correctness of several programs that manipulate linked data structures.</p>", "authors": [{"name": "Shachar Itzhaky", "author_profile_id": "81470654446", "affiliation": "Tel Aviv University, Tel Aviv, Israel", "person_id": "P4383854", "email_address": "shachar@tau.ac.il", "orcid_id": ""}, {"name": "Anindya Banerjee", "author_profile_id": "81100144615", "affiliation": "IMDEA Software Institute, Madrid, Spain", "person_id": "P4383855", "email_address": "anindya.banerjee@imdea.org", "orcid_id": ""}, {"name": "Neil Immerman", "author_profile_id": "81408601113", "affiliation": "UMASS Amherst, Amherst, MA, USA", "person_id": "P4383856", "email_address": "immerman@cs.umass.edu", "orcid_id": ""}, {"name": "Ori Lahav", "author_profile_id": "81453612033", "affiliation": "Tel Aviv University, Tel Aviv, Israel", "person_id": "P4383857", "email_address": "orilahav@post.tau.ac.il", "orcid_id": ""}, {"name": "Aleksandar Nanevski", "author_profile_id": "81100503327", "affiliation": "IMDEA Software Institute, Madrid, Spain", "person_id": "P4383858", "email_address": "aleks.nanevski@imdea.org", "orcid_id": ""}, {"name": "Mooly Sagiv", "author_profile_id": "81100150928", "affiliation": "Tel Aviv University, Tel Aviv, Israel", "person_id": "P4383859", "email_address": "msagiv@acm.org", "orcid_id": ""}], "doi_number": "10.1145/2535838.2535854", "year": "2014", "article_id": "2535854", "conference": "POPL", "title": "Modular reasoning about heap paths via effectively propositional formulas", "url": "http://dl.acm.org/citation.cfm?id=2535854"}