{"article_publication_date": "01-08-2014", "fulltext": "\n From Parametricity to Conservation Laws, via Noether s Theorem Robert Atkey bob.atkey@gmail.com Abstract \nInvariance is of paramount importance in programming languages and in physics. In programming languages, \nJohn Reynolds theory of relational parametricity demonstrates that parametric polymor\u00adphic programs are \ninvariant under change of data representation, a property that yields free theorems about programs just \nfrom their types. In physics, Emmy Noether showed that if the action of a physical system is invariant \nunder change of coordinates, then the physical system has a conserved quantity: a quantity that remains \nconstant for all time. Knowledge of conserved quantities can reveal deep properties of physical systems. \nFor example, the conservation of energy is by Noether s theorem a consequence of a system s in\u00advariance \nunder time-shifting. In this paper, we link Reynolds relational parametricity with Noether s theorem \nfor deriving conserved quantities. We propose an extension of System F. with new kinds, types and term \ncon\u00adstants for writing programs that describe classical mechanical sys\u00adtems in terms of their Lagrangians. \nWe show, by constructing a re\u00adlationally parametric model of our extension of F., that relational parametricity \nis enough to satisfy the hypotheses of Noether s the\u00adorem, and so to derive conserved quantities for \nfree, directly from the polymorphic types of Lagrangians expressed in our system. Categories and Subject \nDescriptors D.3.1 [Programming Lan\u00adguages]: Formal De.nitions and Theory; J.2 [Physical Sciences and \nEngineering]: Physics General Terms Languages, Theory, Types, Physics Keywords classical mechanics; relational \nparametricity; higher\u00adkinded types; invariance; conservation laws 1. Introduction Reynolds theory of \nrelational parametricity [18] tells us that para\u00admetrically polymorphic programs automatically satisfy \ninvariance properties. Such invariance properties are often called Free Theo\u00adrems, after Wadler [22], \nsince they follow for free from the types of programs, rather than through detailed study of the program \ntext. An illustrative example is the free theorem for programs f with the following type: f : .a. List \na . Nat Permission to make digital or hard copies of all or part of this work for personal or classroom \nuse is granted without fee provided that copies are not made or distributed for pro.t or commercial advantage \nand that copies bear this notice and the full citation on the .rst page. Copyrights for components of \nthis work owned by others than the author(s) must be honored. Abstracting with credit is permitted. To \ncopy otherwise, or republish, to post on servers or to redistribute to lists, requires prior speci.c \npermission and/or a fee. Request permissions from permissions@acm.org. POPL 14, January 22 24, 2014, \nSan Diego, CA, USA. Copyright is held by the owner/author(s). Publication rights licensed to ACM. ACM \n978-1-4503-2544-8/14/01. . . $15.00. http://dx.doi.org/10.1145/2535838.2535867 Such programs take lists \nof as, for any type a, and return natu\u00adral numbers. Using Reynolds theory of relational parametricity, \nWadler showed that any f with this type satis.es the following property: .a, \u00df, g : a . \u00df, l : List a. \nf [a] l = f [\u00df] (map g l) Thus, any f with the type given above is invariant under mapping some arbitrary \nfunction g over its input. Thinking in terms of ab\u00adstract data types and change of data representation, \nthis free theo\u00adrem states that f is invariant under change of data representation from an arbitrary type \na to another arbitrary type \u00df, via g. The use of invariance under change to derive useful conse\u00adquences \nis a technique much older than programming languages. In physics, Noether s theorem [14] provides a general \nway to derive conservation laws for physical systems from invariance properties. Informally speaking, \nNoether s theorem states that every continu\u00adous symmetry of a physical system implies the existence of \na cor\u00adresponding conserved quantity. A conserved quantity is a function of the state of the system that \nis constant for all time. We illustrate the use of Noether s theorem with a simple example of a classical \nsystem consisting of two particles of equal mass m connected by a spring with spring constant k, such \nthat the particles are constrained to move one-dimensionally. Noether s theorem applies to systems described \nin terms of Lagrangians. For classical mechanics, a Lagrangian is a function of time and the positions \nand velocities of all the particles in the system, to the difference between the kinetic energy and the \npotential energy of the system. For our system with two particles at positions x1 and x2 with velocities \nx.1 and x.2 the Lagrangian is: 22 2 L(t, x1, x2, x.1, x.2) = 1 m( .x1 + x.2 ) - 1 k(x1 - x2)(1) 2 2 The \n.rst summand represents the total kinetic energy of the system in terms of the mass and velocities, while \nthe second summand represents the potential energy contained within the spring due to the distance between \nthe particles. From the Lagrangian (1), using the principle of stationary ac\u00adtion, we can derive the \nfollowing two equations of motion for this system. (We describe the principle of stationary action, and \nthe pro\u00adcess for deriving the equations of motion fully in Section 2.) For this system, the equations \nof motion are a pair of ordinary differen\u00adtial equations (ODEs) that describe how the positions and velocities \nof the particles evolve over time (the second derivative with respect to time, x\u00a8i, denotes the acceleration \nof the ith particle): mx\u00a81 = -k(x1 - x2) mx\u00a82 = -k(x2 - x1) We could now proceed to solve these ODEs \nto further analyse the behaviour of this system. However, Noether s theorem gives us a powerful way of \ngaining insight into properties of these ODEs for free , without necessarily having to .nd solutions \nto them. This is accomplished by .nding invariance properties of the Lagrangian.  The Lagrangian (1) \ndoes not refer to any .xed point in space; only the relative distance between the two particles, along \nwith their velocities, is relevant. Therefore, the Lagrangian (1) is invariant under translation in space \nby some arbitrary displacement y: L(t, x1, x2, x.1, x.2) = L(t, x1 + y, x2 + y, x.1, x.2) (2) By Noether \ns theorem, invariance under spatial translation implies that the linear momentum of the whole system \nis constant for all time. For this system, conservation of linear momentum is stated mathematically as \nthe vanishing of the derivative with respect to time of the total linear momentum of the system: d m( \n.x1 + x.2) = 0 (3) dt In general, Noether s theorem gives us a way of deriving conserved properties like \n(3) from invariance properties like (2). In this case, we have used invariance under translation in space \nto derive con\u00adservation of linear momentum. Other common examples include invariance under translation \nin time, yielding conservation of en\u00adergy, and invariance under rotation, yielding conservation of an\u00adgular \nmomentum. We will see examples of each of these kinds of invariance, and their consequent conservation \nlaws, in Section 5. The invariance property stated in Equation (2) is highly remi\u00adniscent of the free \ntheorem we stated for the polymorphic program at the start of this introduction. A change in representation \nin the input, whether a change in data representation from a type a to a type \u00df, or a change in where \ntime zero is counted from, results in no change in the output. Since Reynolds relational parametricity \nallowed us to derive the invariance properties for the program f just by looking at its type, we ask \nthe following question: Question: Is it possible to use Reynolds theory of relational para\u00admetricity \nto derive the invariance properties of Lagrangians re\u00adquired for Noether s theorem to derive conservation \nlaws? In this paper, we answer this question positively. We show that it is indeed the case that we can \nuse a generalised version of Reynolds theory of relational parametricity to prove the geometric invariance \nproperties required for the hypotheses of Noether s the\u00adorem. We construct an extension of System F. \nsuitable for writing invariant Lagrangians, with a relationally parametric model that al\u00adlows us to prove \ninvariance properties as free theorems. In our sys\u00adtem, the Lagrangian (1) we gave above for describing \na system of two particles coupled by a spring will have the type: .y:T(1). C8(R(1, 0) \u00d7 R(1, y) \u00d7 R(1, \ny) \u00d7 R(1, 0) \u00d7 R(1, 0), R(1, 0)) We explain this type by breaking it down from left to right. The quanti.er \n.y:T(1) indicates that we are quantifying over all trans\u00adlations y in one-dimensional space, just as \nwe did implicitly in Equation (2). The notation C8(-, -) denotes the type of smooth functions between \nspaces. (A smooth function is a function that is in.nitely differentiable.) All the functions that we \nwish to use as Lagrangians must be smooth (at least up to second order) for the theory to work. The type \nR(g, x) denotes real numbers that vary with some linear transformation g and translation x. In this case, \nall the linear transformations are 1, indicating no transformation. Likewise, when the translation component \nis 0, there is no transla\u00adtion. Thus a value of type R(1, 0) is invariant, but a value of type R(1, y) \nvaries with the translation y. In the smooth function type above, the domain space consists of vectors \nof .ve real numbers: the time, the two particle positions, which vary with the translation y, and the \ntwo particle velocities. Atkey, Johann and Kennedy [5], building on work by Kennedy [11], have already \npresented a polymorphic type system for ex\u00adpressing geometric invariance properties similar to the translation \ninvariance property in Equation (2). In the present work, we extend their type system by embedding it \nwithin System F.. The bene.ts of this embedding are twofold. Firstly, by using the richer type\u00adlevel \nstructure of System F., we can easily add useful indexed types like length indexed vectors and smooth \nfunction types, both of which would have required special treatment in the special pur\u00adpose type system \npresented by Atkey et al.. Secondly, by using Sys\u00adtem F. as our base, we are able to reuse the re.exive \ngraph-based relationally parametric semantics presented by Atkey [3], extend\u00ading it as appropriate for \nour geometric setting. Contributions Our core contributions are threefold: 1. We reformulate the type \nsystem for geometric invariance of Atkey, Johann and Kennedy [5] as an extension of System F.. This shows \nthat the special status of the group-indexed types in Atkey et al. s work can be incorporated into a \nstandard framework for indexed types. 2. We present a relationally parametric semantics of our extension \nof System F.. In this model, following Atkey s model for ba\u00adsic System F. [3], each kind is interpreted \nas a re.exive graph. Our key technical contribution is to note that the many geo\u00admetric groups that we \nwish to incorporate are expressible as groupoids, and hence as re.exive graphs. We therefore show that \nReynolds theory of relational parametricity, suitably gen\u00aderalised to indexed types by considering re.exive \ngraphs, al\u00adready accommodates geometric invariance properties. 3. Finally, we connect the free theorems \nderivable from our rela\u00adtionally parametric semantics with Noether s theorem for deriv\u00ading conservation \nlaws. We present many examples of invariant Lagrangians expressible in our type system, along with the \ncon\u00adsequent conservation laws for physical systems. In each case, the necessary invariance property is \nderived from the type of the Lagrangian.  Outline In the next section, Section 2, we describe the necessary \nback\u00adground to understand Noether s theorem and the conservation laws it generates. We brie.y introduce \nthe Lagrangian formula\u00adtion of classical mechanics, de.ne precisely what it means for a physical system \nto be invariant under transformations, and state Noether s theorem.  Having shown how invariance generates \nconservation laws in Section 2, in Section 3 we show how to derive invariance prop\u00aderties from indexed \ntypes. We present a relationally parametric semantics for System F., and show how geometric invariance \nproperties can be accomodated within this semantics.  In Section 4 we construct a type system for classical \nmechan\u00adics by extending System F. with the necessary constants for smooth function types and combinators \nfor constructing smooth functions. Programming directly with our combinators in raw System F. is awkward, \ndue to the point-free style required, so in Section 4.2 we de.ne a surface syntax for de.ning smooth \nfunctions that is translated into our applied System F..  In Section 5 we present several examples of \nusing our extension of System F. for writing invariant Lagrangians that describe physical systems.  \nSection 6 concludes, and offers directions for further work.  2. Conservation Laws from Invariance Noether \ns theorem applies to systems described using the formal\u00adism of Lagrangian mechanics, a reformulation \nof Newtonian clas\u00adsical mechanics. In this section we can only offer a very brief in\u00adtroduction to the \nconcepts of Lagrangian mechanics. The reader is referred to other sources, such as Landau and Lifschitz \n[12] or Arnol d [2] for the necessary background in the mathematical the\u00adory of classical mechanics. \nLagrangian mechanics, and Noether s theorem, make crucial use of the Calculus of Variations. Gelfand \nand Fomin [7] provide a good introduction to this topic.  In this section, we will endeavour to keep \nthe presentation rel\u00adatively elementary. However, some knowledge of differential and integral calculus \nwill be required. Knowledge of basic Newtonian mechanics will also be helpful. We will use standard notation \nfrom physics and mathematics for integrals and (partial) derivatives. In particular, when discussing \nderivatives with respect to time, we use dot notation: x.for the .rst derivative of x with respect to \ntime, and x\u00a8for the second derivative. 2.1 Lagrangian Mechanics Lagrangian mechanics is a branch of analytical \nmechanics, along with Hamiltonian mechanics [2, 12]. Analytical mechanics seeks to discover the underlying \nstructure of Newtonian classical mechanics by reformulating it in different terms. Lagrangian and Action \nFor Lagrangian mechanics, classical me\u00adchanical systems are described in terms of Lagrangians L = T - \nV , where T is the total kinetic energy of the system, and V is the total potential energy. The Lagrangian \nis a function of time, the po\u00adsitions of all the particles in the system, and their velocities. This \nis usually written like so, with abuse of notation for q. which is a variable here, not the derivative \nof a function: L(t, q, q.) = T - V In this expression, q and q. are actually vectors containing the components \nof the position and velocity vectors for each particle. A key feature of Lagrangian mechanics is that \nthe coordinate system used to describe the system need not necessarily be the usual cartesian coordinates. \nFor example, one of the components of q might be the angle of swing of a pendulum. This use of generalised \ncoordinates is one of the advantages of Lagrangian mechanics over the Newtonian presentation in terms \nof positions and forces. The Lagrangian for a particular system is used to de.ne the action of that system. \nFor a particular path q : R . Rn and endpoints a < b in time, the action of the Lagrangian L over this \npath is de.ned by the following integral: b S[q; a; b] =L(t, q(t), q.(t))dt a Below, we will use the \nprinciple of stationary action to select the physically realisable paths from all the possible paths \nq : R . Rn . Example 1. We have already seen an example of a Lagrangian, in the introduction, describing \na system of two particles coupled by a spring. Another example of a Lagrangian describes a system consisting \nof a single particle of mass m acted upon by a constant downward gravitational .eld with gravitational \npotential g: 2 2 L(t, x, y, x,.y.) = 1 m( .x + .y ) - mgy (4) 2 Again, the left summand represents the \nkinetic energy of the system in terms of the mass and horizontal and vertical velocities of the particle. \nThe right summand represents the potential energy of the system due to the gravitational .eld s strength \ndetermined by the particle s distance from a .xed baseline at y = 0. The Principle of Stationary Action \nThe principle of stationary action states that the physically realisable paths q are the paths that yield \nstationary points (i.e., either minima or maxima) of the action S[q; a; b], for all a and b. De.ning \nwhat is exactly meant by a stationary point of the action is beyond the scope of this paper, and can \nbe found in standard references on the calculus of variations, such as Gelfand and Fomin [7]. The key \npoint for our purposes is that a path q satis.es the principle of stationary action if and only if it \nsatis.es a system of ODEs derived from the Lagrangian L, called the Euler-Lagrange equations: d .L .L \n- = 0 (5) dt .q.i .qi The ODEs derived from the Lagrangian for a classical mechanical system are called \nthe equations of motion for the system. The notation in the Euler-Lagrange equation, while standard, \nis not exactly clear, especially to a programming language theorist used to a more careful treatment \nof variables. The two partial derivatives .L and .L take partial derivatives of L with respect to .q.i \n.qi d q.i and qi as variables. The derivative with respect to time, dt , then treats q.i as a function \nof time, hence the appearance of the second derivatives q\u00a8i in the equations of motion. Sussman and Wisdom \n[20] criticise the standard presentation of Lagrangian mechanics for this kind of confusing notation, \nand de.ne a clearer notation based on the Scheme programming language. We elect to stick with the standard \nnotation as used in physics textbooks just for familiarity. Example 2. Computing the Euler-Lagrange equations \nfor the La\u00adgrangian (4), above, yields a pair of ODEs, one each for the x and y coordinates of the single \nparticle of the system: mx\u00a8= 0 my\u00a8= -mg Note that both these ODEs have the form F = mx\u00a8, just as in Newton \ns second law. Lagrangian mechanics allows, from the principle of stationary action, the derivation of \nNewton s second law, instead of postulating it as an axiom.  2.2 Noether s Theorem As we described in \nthe introduction, Noether s theorem provides us with deep insights into the properties of the solutions \nof the Euler-Lagrange equations. Formally, Noether s theorem requires the in\u00advariance of the action S, \nrather than invariance of the Lagrangian itself. We therefore .rst de.ne what is meant by invariance \nof the action, and then state Noether s theorem. Invariance of the Action Let b S[q; a; b] =L(t, q(t), \nq.(t))dt a be the action of some physical system described by the Lagrangian L. Assume a differentiable \ninvertible function F : R . R that transforms time in some way and a function . : Rn . Rn that transforms \nthe vector of generalised coordinates qq to another vector of generalised coordinates .(q ). The action \nS is invariant between the endpoints a and b, under the transformations F and ., if it is the case that \nfor all paths q: b F(b) * dq * L(t, q(t), q.(t))dt =L(s, q (s), (s))ds (6) ds a F(a) where q * (s) = \n(. . q . F-1)(s) is the path q transformed by F and .. By change of variables, the right hand integral \nin the above equation is equal to the following integral: b * dq * L(F(t), q (F(t)), F(t)|dt (F(t))) \n\u00b7 | . a ds For our application to classical mechanics, the endpoints a and b are arbitrary, so we can \nrewrite Equation (6) to the following equation between applications of the Lagrangian: * dq * L(t, q(t), \nq.(t)) = L(F(t), q (F(t)), F(t)| (F(t))) \u00b7 | .(7) ds  For most examples, it will be the case that F \nhas the form F(t) = t + t' and . is an af.ne transformation .(q) = Gq + x, where G is an n\u00d7n real matrix \nand x . Rn. In this case, Equation (7) simpli.es further, using the de.nition of q * and the chain rule \nof differentiation, to: ' L(t, q(t), q.(t)) = L(t + t, Gq(t) + x, Gq.(t)) (8) Equation (8) is obviously \nimplied by the following equation, where we treat q and q. as universally quanti.ed variables, instead \nof as functions of time: ' L(t, q, q.) = L(t + t, Gq + x, Gq.) (9) Equation (9) is the form of invariance \nthat the free theorems we derive from the types of our typed language for classical mechanics will usually \ntake. We de.ne our type system for classical mechanics in Sections 3 and 4 below. Example 3. In the introduction, \nwe stated that the Lagrangian (1) describing the spring-coupled system is invariant under translation \nin space. Our running example in this section, the Lagrangian (4) for the single particle under gravity, \nis not invariant under all spatial translations, due to the reference in the potential energy term to \nthe distance from the .xed baseline at y = 0. It is invariant under translations along the x-axis, however. \nBoth Lagrangians are also invariant under translations in time, a special case of Equation (9): ' L(t, \nq, q.) = L(t + t, q, q.) This invariance property is simply a consequence of the fact that neither Lagrangian \nexplicitly mentions the time t. Noether s Theorem Noether s theorem applies to actions that are continuously \ninvariant. Being continuously invariant means that, instead of having .xed transformations F and ., we \nhave two families of transformations, FE and .E, differentiably indexed by a real parameter E, such that \nF0 and .0 are the identity function. Theorem 1 (Noether). If the action b S[q; a; b] = L(t, q(t), q.(t)) \ndt a is invariant under E-indexed families of transformations FE and .E, then the equation  d n.L n.L \n.i +L - q.i f= 0 (10) dt.q.i .q.i i=1 i=1 holds for all paths q satisfying the Euler-Lagrange equations \n(5), ee ..e.Fe where . = and f = . .E E=0 .E E=0 Proof. E.g., Gelfand and Fomin [7], Section 20. Example \n4. In Example 3, we noted that the Lagrangians (1) and (4) are both invariant under arbitrary translations \nin time. In terms of continuous invariance, their corresponding actions are invariant under the families \nFE(t) = t + E and .E(q) = q. Plugging these de.nitions into Equation (10), we learn that, for these systems: \n 2 d .L L - q.i = 0 dt.q.i i=1 For the spring-coupled particles Lagrangian, (1), we obtain: d 1 1 22 \n2 m( .x1 + x.2 ) + k(x1 - x2)= 0 dt2 2 and for the single particle under gravity Lagrangian (4), we obtain: \n d 1 m( .x 2 + .y 2) + mgy= 0 dt2 In both cases, we have discovered that, as a consequence of in\u00advariance \nunder translation in time, the total energy of the system is conserved (note that the - signs in the \noriginal Lagrangians have turned into +s). In general, invariance under translation in time im\u00adplies, \nvia Noether s theorem, conservation of energy. This .nishes our short introduction to Lagrangian mechanics \nand Noether s theorem. We have shown how Noether s theorem can be used to derive conservation laws from \ninvariance properties. We now go on to showing how suitable invariance properties can be derived from \ntypes, building towards Section 4, where we construct a type system for writing Lagrangians that expresses \ninvariance properties directly in the types. In Section 5, we give examples of invariant Lagrangians \nand their consequent conservation laws. 3. Invariance from Types We derive invariance properties from \ntypes by constructing a re\u00adlationally parametric model of System F., which we then extend with suitable \nkind-, type-, and term-level constants for writing in\u00advariant Lagrangians. Our relationally parametric \nmodel is based on the re.exive graph model presented by Atkey [3] (based on previ\u00adous work on re.exive \ngraph models of relational parametricity by Robinson and Rosolini [19] and Hasegawa [9]). In re.exive \ngraph models of relational parametricity, the kinds of System F. are in\u00adterpreted as re.exive graphs, \nwhile types are interpreted as mor\u00adphisms of re.exive graphs. As demonstrated by Atkey, uniformly interpreting \nkinds as re.exive graphs allows for a straightforward interpretation of higher kinds like * . *. In the \npresent setting, re.exive graphs will allow us to accomodate arbitrary groupoids as kinds (Section 3.3). \nGroupoid kinds are the key technical tool that we need to derive the kinds of geometric invariance properties \nwe need for Noether s theorem. 3.1 System F.: Syntax and Relationally Parametric Model We now present \nthe syntax and relationally parametric semantics of System F.. Since we will incrementally extend the \nsyntax of the system throughout this section and the next, we do not state a .nal triple of theorems \nstating that we have correctly interpreted kinds, types and terms. Rather, we state the necessary properties \nof the interpretation as three separate properties (Properties 1, 2, and 3, below), and maintain them \nas we extend the system. We deviate from the standard presentation of System F. in that we distinguish \nbetween large and small kinds, and only allow quanti.cation over small kinds. In particular, the kind \nof types * is not small. The reason for this choice is that we desire a simple set-theoretic model. However, \nrequiring that we have a set of sets closed under large products, in order to interpret quanti.cation \nover the kind *, would force us to use an intuitionistic metatheory [17]. The basic results of the Calculus \nof Variations that we are relying on, such as the derivation of the Euler-Lagrange equations, use excluded \nmiddle in their proofs, so an intuitionistic metatheory is not an option. We therefore just assume that \nwe have a set of small sets, which includes the real numbers and is closed under subsets, products, function \nspaces and set comprehensions. Syntax The kinds of System F. include at least the base kind of types, \n*, and function and product kinds, as generated by the following grammar: . ::= * | .1 . .2 | .1 \u00d7 .2 \n| \u00b7 \u00b7 \u00b7 We will extend the collection of kinds in Section 3.2 with type-level natural numbers, and in \nSection 3.3 with groupoid kinds. We use the judgement . small to denote when the kind . will be interpreted \nby a small re.exive graph (to be de.ned below). The kind * is not small, but the construction of function \nand product  a : . . T T, a : .1 f A : .2 T f a : . T f .a : .1. A : .1 . .2 T f F : .1 . .2 T f A : \n.1 T f F A : .2 T f A : .1 T f B : .2 T f (A, B) : .1 \u00d7 .2 T f A : * T f B : * T f A \u00d7 B : * T f A : \n.1 \u00d7 .2 T f pi A : .i i . {1, 2} T f A : * T f B : * T f A . B : * T, a : . f A : * . small T f .a:.. \nA : * Figure 1. Types and their Kinds T, a : .1 f A : .2 T f B : .1 \u00df T f (.a : .1.A) B = A{B/a} : .2 \nT f A : .1 . .2 . T f (.a : .1.A a) = A : .1 . .2 T f A1 : .1 T f A2 : .2 \u00df T f pi (A1, A2) = Ai : .i \nT f A : .1 \u00d7 .2 . T f (p1A, p2A) = A : .1 \u00d7 .2 plus: re.exivity, symmetry, transitivity and congruence \nFigure 2. Type equality kinds preserves smallness: .1 small .2 small .1 small .2 small .1 . .2 small \n.1 \u00d7 .2 small The additional kinds we introduce below will all be small. The well-kinded types, type \nequalities, and well-typed terms of System F. are shown in Figures 1, 2 and 3, respectively. Kinding \ncontexts a1 : .1, ..., an : .n are denoted by T and typing contexts x1 : A1, ..., xn : An are denoted \nby G. Note that typing contexts G only contain well-kinded types of kind *. Terms also have an equational \ntheory, with \u00df.-laws for functions, products, and universal quanti.cation, which we omit. Our presentation \nof System F. is entirely standard (see, e.g., Pierce [16]), except for the restriction to small kinds \nin the formation of universal kinds .a:..A. As is the case for kinds, we will extend the types, type \nequalities, and terms in Sections 3.2, 3.3 and 4, below. Re.exive Graphs and the Interpretation of Kinds \nWe will in\u00adterpret every kind . as a re.exive graph, which we now de.ne. A re.exive graph is a triple \n(O, R, id), where O is a large set of ob\u00adjects, R : O \u00d7 O . Set assigns a small set of directed edges \nto each pair of objects, and id : .o . O. R(o, o) assigns a dis\u00adtinguished identity edge from every object \nto itself. We think of the edges of a re.exive graph as abstract relations between the objects. Indeed, \nin the interpretation of the kind of types, *, below, the edges will be exactly relations. x : A . G \nT | G f e : A T f A = B : * T | G f x : A T | G f e : B T | G f e1 : A1 T | G f e2 : A2 T | G f e : A1 \n\u00d7 A2 i . {1, 2} T | G f (e1, e2) : A1 \u00d7 A2 T | G f pie : Ai T | G, x : A f e : B T | G f .x : A. e : \nA . B T | G f e1 : A . B T | G f e2 : A T | G f e1e2 : B T, a : . | G f e : A a . fv(G) T | G f .a:.. \ne : .a:..A T | G f e : .a:..A T f B : . T | G f e [B] : A{B/a} Figure 3. Terms and their Types A small \nre.exive graph is a re.exive graph (O, R, id) where O is a small set of objects. We use small re.exive \ngraphs as the semantic interpretation of small kinds. The interpretation of kinds as re.exive graphs, \nand small kinds as small re.exive graphs is a key property of our semantics that we will maintain as \nwe add additional kinds in Sections 3.2 and 3.3, below. We state this as Property 1 of our semantics: \nProperty 1. Each kind . is interpreted as a re.exive graph [.]. If . small, then [.] is a small re.exive \ngraph. An appealing interpretation of re.exive graphs is as categories without composition . Following \nthis intuition, we de.ne mor\u00adphisms of re.exive graphs as functors , without the preserva\u00adtion of composition \ncondition. A morphism of re.exive graphs (O1, R1, id1) and (O2, R2, id2) is a pair of mappings f : O1 \n. O2 and r : .o, o ' . O1. R1(o, o ' ) . R2(f o, f o ' ) such that iden\u00adtities are preserved: r o o (id1 \no) = id2 (f o). We use morphisms of re.exive graphs below to interpret well-kinded types. We will use \nthe notation -O , -R and -id for the .rst, second and third projections out of tuples representing re.exive \ngraphs. Similarly, we use -f and -r for the .rst and second projections out of tuples representing re.exive \ngraph morphisms. We now de.ne the interpretations of the basic kinds of System F. we de.ned above, making \nsure that we maintain Property 1. At base kind, the collection of objects is simply the (large) set of \nall small sets; edges between A and B are binary relations on A and B (i.e., subsets of A \u00d7 B); and the \ndistinguished identity edge is exactly the equality relation: [*] = (Set, Rel, =) The re.exive graph \n[*] is not small, due to the collection of all small sets Set not forming a small set. For higher kinds \n.1 . .2, the collection of objects consists of re.exive graph morphisms from the interpretation of .1 \nto the in\u00adterpretation of .2; the edges between morphisms (f, r) and (f ' , r ' ) are edge transformers; \nand the distinguished identity relation for (f, r) is just r: [.1 . .2] = ({(f, r) | (f, r) : [.1] . \n[.2]}, '''' '' ((f, r), (f , r )) . .o, o .[.1]R(o, o ) . [.2]R(f o, f o ), (f, r) . r )  By the assumption \nthat our collection of small sets is closed under the formation of function spaces and set comprehension, \nif [.1]and [.2] are small re.exive graphs, then so is [.1 . .2]. Product kinds are interpreted by taking \nthe product of their interpretations as re.exive graphs: [.1 \u00d7 .2] = ([.1]O \u00d7 [.2]O , ' ' R ' R ' ((o1, \no2), (o1, o2)) . [.1](o1, o1) \u00d7 [.2](o2, o2), (o1, o2) . ([.1]id(o1), [.2]id(o2))) The collection of \nobjects of the interpretation of a product kind is the product of the underlying collections of objects \nof the two parts, and the relational component is simply the product of the relational components. This \nnaturally leads to the identity component being de.ned as the tuple of the identity components of the \ntwo parts. Again, by assumption that our collection of small sets is closed under products, if [.1] and \n[.2] are small re.exive graphs, then so is [.1 \u00d7 .2]. Product kinds generalise to the interpretation \nof kinding contexts T = a1 : .1, ..., an : .n, which are interpreted as the product of the re.exive graph \ninterpretations of .1, ..., .n: [a1 : .1, ..., an : .n] = ([.1]O \u00d7 ... \u00d7 [.n]O , (., . ' ) . [.1]R(p1., \np1. ' ) \u00d7 ... \u00d7 [.n]R(pn., pn. ' ), id id . . ([.1](p1.), ..., [.n](pn.))) In Sections 3.2 and 3.3 below, \nwe will extend System F. with additional kinds, and assign them re.exive graph interpretations, making \nsure that we maintain Property 1. Interpretation of Types Well-kinded types T f A : . from Figure 1 are \ninterpreted as re.exive graph morphisms [A] : [T] . [.]. We sum this up as a property of our semantics: \nProperty 2. Each well-kinded type T f A : . is interpreted as a re.exive graph morphism [A] : [T] . [.], \nsuch that if T f A = B : . then [A] = [B]. The interpretation of the .-calculus fragment (i.e., variables, \n.-abstraction and application, and products) of the language of well-kinded types is displayed in Figure \n4. The interpretations are unsurprising given the re.exive graph interpretation of the kinds .1 . .2 \nand .1 \u00d7 .2 we gave above. Figure 5 shows the interpretations of the basic type construc\u00adtors for function \nand product types, and of universal quanti.cation. Each of these constructs builds an object of kind \n*, so the object\u00adlevel interpretation is a small set in Set, and the relation-level in\u00adterpretation is \nan actual relation. In the cases of the function and product types, the object-level interpretation is \njust as set-theoretic function and product respectively, and the relation-level interpreta\u00adtion uses \nthe standard logical relations interpretations of these type constructors. Universal quanti.cation, .a:.. \nA, is interpreted at the object level by taking the dependent product over the objects of the interpretation \nof . (this product exists because we have stipu\u00adlated that . must be small), and then restricting to \nthose elements of the dependent product that preserve relations. This restriction is required for this \ninterpretation to preserve identity edges, and so be a re.exive graph morphism. The relation-level interpretation \nof universal quanti.cation is the standard relational interpretation of such types, albeit here generalised \nto kinds interpreted as arbitrary re.exive graphs. Well-kinded typing contexts T f G are interpreted \nas re.exive graph morphisms [G] : [T] . [*] by taking the product of the in\u00adterpretations of their constituent \ntypes, similar to the interpretation of the product types A \u00d7 B. We will extend basic System F. with \nadditional types and type equalities in Sections 3.2, 3.3, and 4, below. These new types will also be \nassigned interpretations as re.exive graph morphisms, and we will ensure that Property 2 is maintained. \nInterpretation of Terms We omit the straightforward and rela\u00adtively uninteresting interpretation of well-typed \nterms T | G f e : A, and just state that there is a well-de.ned function interpreting each well-typed \nterm, with the property that it takes related en\u00advironments to related results; this is the fundamental \ntheorem of logical relations for System F.: Property 3. For all well-typed terms T | G f e : A there \nis a Of f function [e . (.. . [T]. [G]. . [A].), such that, for all OR ff ., . ' (., . ' . and . ' . \n' , if . [T] , . . [T]), . . [G]. [G] ' r ' r (., . ) . [G].. ' . then ([e].., [e]. ' . ) . [A].. ' .. \nMoreover, this interpretation is sound for the \u00df. equational theory of terms.  3.2 Discrete Kinds In \nSection 3.1, we only had a single base kind: the kind * of proper types, with a speci.c interpretation \nas the re.exive graph of sets and relations. We now describe two families of base kinds with interpretations \nthat are particular sorts of re.exive graph. In this section, we look at discrete kinds; kinds whose \nre.exive graph interpretations are such that the re.exive edges are the only edges between objects. In \nthe following section (Section 3.3), we look at groupoid kinds, where edges are composable and invertible. \nDiscrete kinds can be seen as the natural way of lifting types up to the kind level. For our purposes, \nwe will only require a kind of natural numbers, which we will use for constructing n-ary vectors of positions \nand velocities when we use our type system for writing Lagrangians in Section 4. The kind of natural \nnumbers is small: . ::= \u00b7\u00b7\u00b7 | nat nat small The interpretation of this kind as a re.exive graph goes \nas follows: [nat] = (N, (n1, n2) . {* | n1 = n2}, n . *) The collection of objects of this re.exive graph \nis simply the set of natural numbers. The only edges in the graph are unique edges be\u00adtween equal numbers. \nSince we have assumed that our collection of small sets contains the natural numbers, we have clearly \nmaintained Property 1 of our semantics. We add new type-level constructs for the kind Nat of natural \nnumbers, representing zero and successor, and a kind-generic re\u00adcursion operator: T f A : nat T f zero \n: nat T f succ A : nat T f A : nat T f B : . T f C : . . . T f natrec. A B C : . These three constructs \nall have the evident interpretations in terms of the inductive structure of the natural numbers, and \nsatisfy the following \u00df-laws, maintaining Property 2 of our semantics: natrec. zero B C = B natrec. (succ \nA) B C = C (natrec. A B C)  3.3 Groupoid Kinds Discrete kinds are useful for lifting types up to the \nkind level, but they do not really exploit the .exibility of re.exive graphs. More\u00adover, they do not \nprovide us with the invariance properties we re\u00adquire to apply Noether s theorem. By considering kinds \nwhose in\u00adterpretations are groupoids, we will be able to derive the invariance properties that we need. \nRecall that a groupoid is a category in which all morphisms have inverses [15]. Functors between categories \nalways preserve  T f ai : .i f . = pi.[ T f ai : .i] r.. ' . = pi. fOf OR ' T f .a:.1. A : .1 . .2 \n. = (.o . [.1]. [A](., o), .o, o ' . [.1], r . [.1](o, o[ T f .a:.1. A : .1 . .2] r.. ' . = .o, o ' . \n[.1]O , r . [.1]R(o, o ' ). [A]r(., o)(. ' , o ' )(., r) T f F A : .2 f . r [ T f F A : .2] .. ' . T \nf (A, B) : .1 \u00d7 .2 f[ T f (A, B) : .1 \u00d7 .2] r T f piA : .i f . r [ T f piA : .i] .. ' . T f A . B : * \nf . r .. ' . [ T f A . B : *] T f A \u00d7 B : * f . r [ T f A \u00d7 B : *] .. ' . T f .a:.. A : * f . r [ T f \n.a:.. A : *] .. ' = p1([F ]f .) ([A]f .) r ffr . ' . = ( A f ., [B]f .) = [F ].. ' . ([A].)([A])([A].. \n' .) r r .. ' . = ([ A] .. ' ., [B].. ' .) = pi( A f .) = pi([ A] r .. ' .) = {x . (.o . [.]. [A], r \n. [.]' ) . [A] ' ' R ' '' r ' . = {(x, x ) | .o, o , r . [.](o, o ). (x o, x o ) . [A](., o)(. ' , o \n)(., r)} Figure 5. Interpretation of basic types as re.exive graph morphisms ). [A]r(., o)(., o ' )([T]id., \nr)) Figure 4. Interpretation of type-level .-calculus as re.exive graph morphisms = [A]f . . [B]f . \n ' ' r ' ' r = {(f, f ) | .(a, a ) . [A].. ' .. (f a, f a ) . [B].. ' .} = [A]f . \u00d7 [B]f . ' ' r r = \n{((a, b), (a , b ' )) | (a, a ) . [A].. ' ., (b, b ' ) . [B].. ' .} O f (., o)) | .o, o ' R(o, o ' ). \n(x o, x o r(., o)(., o ' )([T]id., r)} isomorphisms, so morphisms of groupoids are just functors. Every \ngroup is a groupoid with one object, and a morphism from this object to itself for every element of the \ngroup: composition is the group operation, inverses are given by the group inverses, and the identity \nmorphism is given by the group unit. Homomorphisms between groups are in one-to-one correspondence with \nfunctors between the corresponding groupoids. An example of a groupoid that is not a group is given by \nthe collection of cartesian spaces (i.e., Rn for some n), with all diffeomorphisms (smooth functions \nwith smooth inverses) as the morphisms. Trivially, every groupoid is a re.exive graph, simply by for\u00adgetting \nthe composition and inverses. Likewise, every functor be\u00adtween groupoids is a morphism of re.exive graphs, \nby forgetting the preservation of composition. Therefore, given any groupoid, we can add a new kind to \nSystem F. that is interpreted by that groupoid, and given any functor f : [G1] . [G2] between groupoids \ninterpreting kinds G1 and G2, we obtain a type constant of kind G1 . G2, with interpretation f. Integers \nOur .rst groupoid kind is Z, interpreted by additive group of integers. We will use this kind to state \nthe types of the trigonometric functions sin and cos in Section 4.1, which are peri\u00adodic with period \n2p. The kind Z is small: . ::= \u00b7\u00b7\u00b7 | Z Z small The kind Z has the following interpretation as a re.exive \ngraph: [Z] = ({*}, .(*, *). Z, .*. 0) Note the difference between this interpretation and the interpreta\u00adtion \nof the kind Nat in the previous section. In the interpretation of Nat, the objects were complex and the \nrelations were trivial. The re.exive graph interpreting Z has a trivial collection of objects, but a \nrich structure at the relation level, given by the group of integers. This structure means that we can \nadd the following type-level con\u00adstants to our system: T f A : Z T f B : Z T f A : Z T f 0 : Z T f A \n+ B : Z T f -A : Z Each of these constants has a trivial object-level interpretation, due to the trivial \ncollection of objects in the re.exive graph [Z]. At the relation-level, the interpretations are simply \ngiven using the group structure of the integers. These interpretations satisfy the abelian group axioms, \nso we add these axioms to the type-level equations. Translation and Linear Transformation Groups The \ngroup of integers is not suitable for stating the invariance properties we require to apply Noether s \ntheorem. To do so, we require groups of translations and invertible linear transformations. We extend \nour type system with small kinds representing n-dimensional (n = 0) translations, invertible linear transformations, \nand orthogonal transformations: . ::= \u00b7 \u00b7 \u00b7 | T(n) | GL(n) | O(n) T(n), GL(n), O(n) small The interpretations \nof these kinds follow the same pattern as for the kind Z above. Each interpretation is a re.exive graph \nwith a triv\u00adial collection of objects, and relations taken from the appropriate group: q = ({*}, .(*, \n*). Rn , .*. 0) GL(n)] = ({*}, .(*, *). GL(n), .*.I)[ O(n)] [T(n)] = ({*}, .(*, *). O(n), .*.I) Here, \nwe take GL(n) to be exactly the group of invertible real n\u00d7n matricies, and O(n) to be the group of n \n\u00d7 n orthogonal matricies (recall that an orthogonal matrix is one whose transpose is equal to its inverse). \nWe add the group operations and group axioms for each of these groupoid kinds in the same way as we did \nfor the kind Z above, except that we use multiplicative notation for the kinds GL(n) and O(n). Note that, \nexcept for GL(0), GL(1), O(0) and O(1), the groups GL(n) and O(n) are not abelian.  We also extend our \ntype system with the following type-level constants. Each of these is interpreted by the correspondingly \nnamed homomorphism between the groups involved. For exam\u00adple, scalen is interpreted by the homomorphism \nGL(1) . GL(n) that takes a non-zero real number s to the matrix with ss along the diagonal and zeros \nelsewhere. exp : T(1) . GL(1) orthon : O(n) . GL(n) scalen : GL(1) . GL(n) c * - : Z . T(1) In the last \nof these c stands for an arbitrary real constant. Since each of these is interpreted by a group homomorphism, \nwe are justi.ed in adding the group homomorphism laws as axioms to our type\u00adlevel equational theory, \nmaintaining Property 2. The Groupoid of Cartesian Spaces Finally in this section, we introduce the groupoid \nkind of cartesian spaces, which we will use for the con.guration spaces of the classical mechanical systems \nwe describe in our system. As we noted above, the collection of cartesian spaces is a groupoid with a \nnon-trivial collection of objects. We extend our system with a kind of cartesian spaces: . ::= \u00b7\u00b7\u00b7 | \nCartSp with the following interpretation: [CartSp] = (N, .m, n. {f : Rm . Rn | f a diffeomorphism}, .n. \nidRn ) We have chosen to represent cartesian spaces of dimension n just as the natural number n. This \ngives us a canonical representation of n-dimensional space for each n, avoiding tricky problems with \nisomorphic constructions of the same space. Cartesian spaces are closed under products: T f X : CartSp \nT f Y : CartSp T f X \u00d7 Y : CartSp with the following interpretation, where the cartesian product of cartesian \nspaces adds their dimensions, and composes diffeomor\u00adphisms in parallel : f ff X \u00d7 Y. . = [X]. + [Y r \nrr [ X \u00d7 Y ] .. ' . = .(qx, qy). ([X] .. ' .qx, [Y ].. ' .qy) Cartesian spaces are generated by the following \nconstruct that yields the n-dimensional cartesian space (n = 0) that varies with the given invertible \nlinear transformation and translation: T f G : GL(n) T f T : T(n) T f Rn(G, T ) : CartSp As a notational \nconvenience, we write R1(G, T ) as just R(G, T )and R0(G, T ) as just R0 . The type Rn(G, T ) has the \nfollowing interpretation as a re.ex\u00adive graph morphism: Rn(G, T ) f . = n [ Rn(G, T )] r.. ' . = .qx. \n([G]r.. ' .)qx + [T ]r.. ' . Note that [Rn(G, T )]r.. ' ([T]id.) is the identity diffeomorphism, so this \ninterpretation preserves identity edges, exactly as required in the de.nition of re.exive graph morphisms. \nConsequently, the interpretation of Rn(G, T ), and also the interpretation for products of cartesian \nspaces, preserves Property 2. Using the type-level natural numbers and their recursion opera\u00adtor, we \ncan de.ne a type of n-ary products of a cartesian space: vec = .n:Nat, X:CartSp. natrec n R0 (.x. X \u00d7 \nx) n-ary products of cartesian spaces will be useful in Section 5 when we de.ne Lagrangians describing \nsystems that are generic in the number of particles involved. Finally, we include an operator that takes \nany cartesian space to its corresponding proper type: T f X : CartSp T f lXs : * with the following straightforward \ninterpretation: f X . = RIXJf . r q'} [l Xs] r.. ' . = {(qx, xq' ) | ([X].. ' .)qx = x 4. A Type System \nfor Classical Mechanics In the previous section we constructed a way to derive invariance properties \nfrom types. In Section 2, we saw that Noether s theorem is a method for deriving conservation laws for \nclassical mechanical systems from their invariance properties. In this section, we con\u00adstruct a type \nsystem for constructing invariant Lagrangians. In the following section, Section 5, we present several \nuses of our type system for de.ning invariant Lagrangians that describe many dif\u00adferent kinds of classical \nmechanical systems. 4.1 Extending System F. with Smooth Functions The Type of Smooth Functions Given \na pair of cartesian spaces X and Y we provide a way to construct the type of smooth invariant smooth \nfunctions from X to Y : T f X : CartSp T f Y : CartSp T f C8(X, Y ) : * with the following interpretation. \nSince C8(X, Y ) is a proper type, the relational interpretation in this case is a genuine relation. We \nrelate functions that are invariant under the diffeomorphism interpretations of X and Y in the current \nrelational context .: C8(X, Y ) f . = {f : RIXJf . . RIY Jf . | f smooth} x . RIXJf . r ' r [ C8(X, Y \n)] f .. ' . = {(f, f ' ) | .q. ([Y ].. ' .)(f qx) = f ([X].. ' .qx)} An Example Free Theorem We are now \nin a position to formally show how we can use the relationally parametric model we have de.ned to derive \ninvariance properties. Consider a closed term with the following type: 8(Rn e : .o : O(n). C (orthon(o), \n0), R(1, 0)) We can deduce, from Property 3 and the relational interpretations of all the types involved, \nthat the denotation of e satis.es the following free theorem: .O . O(n). .qx . Rn . [e](Oqx) = [e](qx) \nThis free theorem is exactly the kind of invariance property we re\u00adquire to apply Noether s theorem. \nCompare the form of the state\u00adment here, with the mildly more general statement of Equation 9, back in \nSection 2. Moreover, [e] is a smooth function from Rn to R, just as we require for Lagrangian mechanics. \nCombinators for Smooth Functions Of course, such free theo\u00adrems are pointless without ways to build elements \nof the smooth function spaces. We now extend our type system, for the last time, with a set of term-level \nconstants for constructing smooth func\u00adtions, invariant under linear transformations and translations. \n Our .rst set of combinators constructs constant and identity smooth functions, and composes smooth \nfunctions between carte\u00adsian spaces. We also have combinators for pairing and projection for the product \nof cartesian spaces. const : lY . C8(X, Y ) s id : C8(X, X) (> ) : C8(X, Y ) . C8(Y, Z) . C8(X, Z) pair \n: C8(X, Y ) . C8(X, Z) . C8(X, Y \u00d7 Z) proj1 : C8(X \u00d7 Y, X) proj2 : C8(X \u00d7 Y, Y ) Next, we include combinators \nfor constant, invariant, vectors, the zero vector, vector addition, subtraction and scaling. We also \ninclude the Euclidean dot product of vectors. The type dot product operation is where the orthogonal \ngroup kind O(n) is used: the dot product of vectors is invariant under orthogonal transformations. qc \n: lRn(1, 0) 0 : .g:GL(n)s . l Rn(g, 0) s (+) : .g:GL(n), t1, t2:T(n). C8(Rn(g, t1) \u00d7 Rn(g, t2), Rn(g, \nt1 + t2)) (-) : .g:GL(n), t1, t2:T(n). C8(Rn(g, t1) \u00d7 Rn(g, t2), Rn(g, t1 - t2)) (*) : .g1:GL(1), g2:GL(n). \nC8(R(g1, 0) \u00d7 Rn(g2, 0), Rn(scalen(g1)g2, 0)) (\u00b7) : .g:GL(1), o:O(n). C8(Rn((scalen g)(orthon o), 0)\u00d7 \nRn((scalen g)(orthon o), 0), R((scalen g)2 , 0)) Each of these combinators has a straightforward interpretation \nas a smooth function, and the proof that the fundamental theorem of logical relations is maintained for \nour system (i.e., that Property 3 is maintained) follows directly from elementary facts about linear \nalgebra. It will be useful for our examples to have the following trigono\u00admetric functions, exponential \nfunction and division operation. The types of each of these functions describes some of their invariance \nproperties, such as the periodicity of the sin and cos functions. A technical problem with our current \nsystem is that we do not account for the non-de.nedness of division at 0, nor do we account for the square \nroot of negative numbers. However, division and square root will be useful in our examples in Section \n5, so we take a pragmatic approach, in common with most physics textbooks, and informally treat them \nas total functions. sin : .z:Z. C8(R(1, 2p * z), R(1, 0)) cos : .z:Z. C8(R(1, 2p * z), R(1, 0)) exp : \n.t:T(1). C8(R(1, t), R(exp t, 0)) (/) : .g1, g2:GL(1). C8(R(g1, 0) \u00d7 R(g2, 0), R(g1g -1 , 0)) 2 sqrt \n: .g:GL(1). C8(R(g \u00b7 g, 0), R(g, 0)) Finally, we include three primitive combinators for dealing with \nn-ary products of vectors. These combinators will be useful when de.ning Lagrangians that are generic \nin the number of particles. sum : .n:Nat, g:GL(1).C8(vec n (R(g, 0)), R(g, 0)) map : .n:Nat.C8(Z \u00d7 X, \nY ) . C8(Z \u00d7 vec n X, vec n Y ) cross : .m, n:Nat. C8 (vec m X \u00d7 vec n Y, vec (m * n) (X \u00d7 Y )) The combinator \nsum sums the list of real numbers it is given, while cross takes the cartesian product of two vectors \nof elements of cartesian spaces, and map maps the given smooth function over a vector. The multiplication \nof natural numbers m * n is straightforwardly de.ned in terms of the natrec recursion operator. We will \nuse cross in Section 5 to de.ne Lagrangians in terms of the interactions between systems of particles. \nLzJ. = const z LxJ. = project.(x) Llet qx = e1 in e2J. = pair id Le1J. > Le2J.,x L(e1, ..., en)J. = pairn(Le1J., \n..., LenJ.) Le1(e2)J. = Le2J. > e1 LqcJ. = const qc L0J. = const 0 Le1 + e2J. = pair Le1J. Le2J. > (+) \nLe1 - e2J. = pair Le1J. Le2J. > (-) Le1e2J. = pair Le1J. Le2J. > (*) Le1 \u00b7 e2J. = pair Le1J. Le2J. > \n(\u00b7) Lsin eJ. = LeJ. > sin Lcos eJ. = LeJ. > cos Lexp eJ. = LeJ. > exp Le1/e2J. = pair Le1J. Le2J. > (/) \nLsqrt eJ. = LeJ. > sqrt Lsum eJ. = LeJ. > sum Lmap (x. e1) e2J. = pair id Le2J. > (map Le1J.,x) Lcross \ne1 e2J. = pair Le1J. Le2J. > cross Figure 7. Desugaring of the surface syntax  4.2 A Surface Syntax \nfor Smooth Functions The combinators we have presented allow the construction of smooth invariant functions, \nbut doing so is painful due to the point\u00adfree style that they force. In order to be able to actually \nde.ne readable Lagrangians in our calculus, we de.ne a surface syntax for writing smooth functions that \nis desugared into our extended version of System F.. We de.ne a typing judgement of smooth terms T | \nG; . f e : X by the rules in Figure 6, where T and G are the kinding and typing contexts of our extension \nof F., and . = x1 : X1, ..., xn : Xn is a context of cartesian spaces. That is, for each x : X in ., \nwe have T f X : CartSp. The desugaring of smooth function terms into our extension of System F. is via \nthe operation L-J., de.ned in Figure 7. In this de.nition, we make use of two derived combinators for \nprojection and pairing: project(x) = proj1 x:X,. project(x) = proj2 > project.(x) (x = y) y:Y,. and pair1(e) \n= e pair(e, qe) = pair e (pair(qe)) n+1 n The following theorem follows easily by induction on the typing \nderivations of smooth terms, where L.J = Lx1 : X1, ..., xn : XnJ = X1 \u00d7 ... \u00d7 Xn: Theorem 2. If T|G; \n. f e : X then T|G f LeJ. : C8(L.J, X). 5. Examples of Conservation Laws from Types We now present a \nnumber of examples of classical mechanical sys\u00adtems expressible in the type system we constructed in \nthe previ\u00adous section, and derive the free theorems and consequent conserved properties for each one. \nThese examples are all standard examples demonstrating the application of Lagrangian mechanics (see, \nfor example, Landau and Lifschitz [12]). Our contribution here is to express them in a type system that \nmakes clear their invariance properties.  Administrative rules z : lX . G x : X . . T | G; . f e1 : \nX1 \u00d7 ... \u00d7 Xn T | G; ., x1 : X1, ..., xn : Xn f e2 : Y s T | G; . f z : X T | G; . f x : X T | G; . \nf let x1, ..., xn = e1 in e2 : Y T | G f e1 : C8(X, Y ) T | G; . f e2 : X T | G; . f e1 : X ... T | G; \n. f en : Xn T | G; . f e1(e2) : Y T | G; . f (e1, ..., en) : X1 \u00d7 ... \u00d7 Xn Vector space operations, and \ndot product qc . Rn T f G : GL(n) T | G; . f e1 : Rn(G, T1) T | G; . f e2 : Rn(G, T2)T | G; . f qc : \nRn(1, 0) T | G; . f 0 : Rn(G, 0) T | G; . f e1 + e2 : Rn(G, T1 + T2) T | G; . f e1 : Rn(G, T1) T | G; \n. f e2 : Rn(G, T2) T | G; . f e1 : R(G1, 0) T | G; . f e2 : Rn(G2, 0)T | G; . f e1 - e2 : Rn(G, T1 - \nT2) T | G; . f e1e2 : Rn(scale n(G1)G2, 0) T | G; . f e1 : Rn(scale n(G)orthon(O), 0) T | G; . f e2 : \nRn(scale n(G)orthon(O), 0) T | G; . f e1 \u00b7 e2 : R(scale n(G)2 , 0) Transcendental functions T | G; . \nf e : R(1, T ) T | G; . f e : R(1, 2p * Z) T | G; . f e : R(1, 2p * Z)T | G; . f exp e : R(exp T , 0) \nT | G; . f sin e : R(1, 0) T | G; . f cos e : R(1, 0) Division, square root, sum, and cross T | G; . \nf e1 : R(G1, 0) T | G; . f e2 : R(G2, 0) T | G; . f e : R(G2 , 0) T | G; . f e : vec N (R(G, 0)) e1 \nT | G; . f : R(G1G-1 , 0)2 T | G; . f sqrt e : R(G, 0) T | G; . f sum e : R(G, 0) e2 T | G; ., x : \nX f e1 : Y T | G; . f e2 : vec N X T | G; . f e1 : vec M X T | G; . f e2 : vec N Y T | G; . f map (x. \ne1) e2 : vec N Y T | G; . f cross e1 e2 : vec (M * N) (X \u00d7 Y ) Figure 6. A surface syntax for smooth \nfunctions 5.1 Single Particles Free Particle Our .rst example is of a simple Lagrangian for a single \nfree particle in 3-dimensional space, with no external forces. We de.ne the Lagrangian using the syntax \nfor smooth terms we de.ned in the previous section, in the following kinding, typing and cartesian space \ncontexts: T = tt : T(1), tx : T(3), o : O(3) G = m : lR(1, 0) s . = t : R(1, tt), x : R3(ortho3(o), tx), \nx.: R3(ortho3(o), 0) where o represents an arbitrary orthogonal transformation of the space, tt represents \na translation in time, tx represents a 3\u00addimensional translation in space, m is the constant mass of \nthe free particle, t is the current time, x is the current position of the particle, and x.is the current \nvelocity. We write the Lagrangian like so, which in the absence of exter\u00adnal forces just consists of \nthe kinetic energy term: 1 L = m( .x \u00b7 x.) : R(1, 0) 2 By the fundamental theorem of logical relations \nfor our calculus (Property 3), we can derive the following free theorems, one each for the three group \nparameters tt, tx and o. Quantifying over trans\u00adlations in time, tt, gives us invariance under translation \nin time: .. .tt . R. [L](t + tt, qx, qx) = [L](t, qx, qx) As we saw in Example 4, Noether s theorem tells \nus that invariance under translation in time yields conservation of energy. Likewise, quantifying over \ntranslations in space, tx, gives us invariance under translation in space: .. .tqx . R3 . [L](t, qx + \ntqx, qx) = [L](t, qx, qx) Similar to the example of the spring-coupled particles in the intro\u00adduction, \ninvariance under translations in space yields conservation of linear momentum. Quanti.cation over orthogonal \ntransformations o : O(3) yields the following free theorem, which states that the Lagrangian is in\u00advariant \nunder modi.cation of the positions and velocities by arbi\u00adtrary orthogonal transformations O: . .O . \nO(3). [L](t, Oqx, O qx.) = [L](t, qx, qx) We are particularly interested in the orthogonal transformations \nderived from rotations, since these will give us the continuous transformations we need to apply Noether \ns theorem. For example, rotation by an angle E around the x3-axis is given by the following E-indexed \nfamily of orthogonal matricies: . . cos E sin E 0 OE = . - sin E cos E 0 . 0 0 1 This leads to the following \nE-indexed family of transformations, suitable for Noether s theorem: .. ... . x1 x1 x1 cos E + x2 sin \nE .E .x2. = OE .x2. = .-x1 sin E + x2 cos E. x3 x3 x3  Plugging this into Equation 10, and using the \nde.nition of L above, we obtain the following conservation law: d (m .xx1) = 0 xx2 - m . dt This is exactly \nconservation of angular momentum around the x3 \u00adaxis [12]. By considering the families of orthogonal \nmatrices for rotation around other axes, we can also derive conservation laws for angular momentum around \narbitrary axes. Particle in a Potential Field If we now extend the typing con\u00adtext of our example with \nan arbitrary potential energy function V , depending on the position of the particle, we can de.ne the \nLa\u00adgrangian for a single particle acted upon by a potential .eld that depends on the position of the \nparticle. The invariance properties of the whole system will depend upon the invariance properties of \nthe potential .eld. If we assume the following contexts: T = tt : T(1), o : O(3) G = m : lR(1, 0)s, V \n: .o:O(3). C 8(R3(ortho3(o), 0), R(1, 0)) . = t : R(1, tt), x : R3(ortho3(o), 0), x.: R3(ortho3(o), 0) \n where everything is as in the previous example, except for the addi\u00adtion of the polymophic potential \nenergy function V . We incorporate this into our Lagrangian like so: 1 L = m( .x \u00b7 x.) - V (x) : R(1, \n0) 2 Even though V is left abstract, the types of t, x, x.and L tell us that this Lagrangian is invariant \nunder translations in time and also un\u00adder all orthogonal transformations. Hence, by Noether s theorem, \nthe system this Lagrangian describes has energy and angular mo\u00admentum as conserved quantities.  5.2 \nThe n-Body Problem Using the constructs of our calculus for dealing with n-ary vectors of positions and \nvelocities, we can compactly write Lagrangians that describe systems of n particles interacting through \nNewtonian gravitational attraction. We use the following kinding, typing and cartesian space contexts, \nwhere the type-level parameter n repre\u00adsents the number of particles that we are considering. For simplic\u00adity, \nwe assume that all the bodies involved in the system have equal mass m. T = n : Nat, tt : T(1), tx : \nT(3), o : O(3) G = m : lR(1, 0) . = t : R(1, tt), s x : vec n (R3(ortho3(o), tx)), x.: vec n (R3(ortho3(o), \n0)) The Lagrangian for this system is de.ned as follows in our surface syntax for smooth terms. The kinetic \nenergy component is the sum of the kinetic energies of all the particles in the system. The potential \nenergy components sums up all the gravitational potential energies due to the interactions between each \npair of bodies, where G is the gravitational constant. L = 2 1 m(sum (map ( .xi. x.i \u00b7 x.i)) .x)- sum \n(map ((xi, xj ). Gm2/|xi - xj |) (cross x x)) : R(1, 0) We have used the notation |e| as shorthand for \nsqrt (e \u00b7 e), i.e., the norm of the vector e. Again, just by looking at the types of t, x, x., and L, \nwe can determine via free theorems that this Lagrangian is invariant under translation in time and space, \nand under all orthogonal transfor\u00admations. Hence, by Noether s theorem, this system has energy and linear \nand angular momentum as conserved quantities.  5.3 Pendulum All our examples above have used rectangular \ncoordinate systems. Part of the power of the Lagrangian formulation of classical me\u00adchanics is the ability \nto use appropriate generalised coordinates to describe systems in simple terms. A standard example is \nthat of a pendulum, where we take the angle . of swing from the vertical as the coordinate. We use the \nfollowing kinding, typing and cartesian space con\u00adtexts: T = tt : T(1), z : Z G = m : lR(1, 0), l : lR(1, \n0) ss . = t : R(1, tt), . : R(1, 2p * z), .. : R(1, 0) where m is the mass at the end of the pendulum \n(we assume the rod of the pendulum to be massless), l is the length of the pendulum, . is the angle of \nswing and .. is the current rate of change of the angle of swing. De.ning the Lagrangian for this system \nis a matter of simple trigonometry and differential calculus: L = let y = l sin . in let x.= l.. cos \n. in let y.= -l.. sin . in 1 2 m( .x 2 + .y 2) - mgy : R(1, 0) From the type of t, we can easily determine \nthat this Lagrangian is invariant under translation in time, and hence the total energy is a conserved \nquantity of this system. We can also derive another free theorem due to the quanti.cation over the group \nof integers via the variable z. However, this does not yield a continuous invariance of the Lagrangian, \nand hence no conserved quantity via Noether s theorem.  5.4 Oscillators Coupled Particles Our .rst example \nof a Lagrangian in the intro\u00adduction was of a pair of particles of equal mass coupled by a spring, for \nwhich we derived conservation of linear momentum and energy. In terms of our type system, we have the \nfollowing kinding, typing and cartesian space contexts, where m is the individual mass of the two particles, \nand k is the spring constant: T = tt : T(1), tx : T(1) G = m : lR(1, 0), k : lR(1, 0) . = t : R(1, tt), \nxs1 : R(1, tx), xs 2 : R(1, tx), x.1 : R(1, 0), x.2 : R(1, 0) In our surface syntax for smooth terms, \nthe Lagrangian is written just as it was in the introduction: 1 1 222 2 L = m( .x1 + x.2 ) - k(x1 - x2): \nR(1, 0) 2 2 The free theorems for this term state the invariance in time and space translation: .tt : \nR. [L](t + tt, x1, x2, x.1, x.2) = [L](t, x1, x2, x.1, x.2) .tx : R. [L](t, x1 + tx, x2 + tx, x.1, x.2) \n= [L](t, x1, x2, x.1, x.2) As we saw in Section 2, these invariance properties allow us to de\u00adduce conservation \nof energy and linear momentum for this system. Damped Oscillator All of the example Lagrangians we have \nlooked at so far have had no dependence on time, and so they have all described systems with total energy \nas a conserved quan\u00adtity. A system with a single particle attached to a damped spring (whose other endpoint \nis .xed at position 0) provides an example of system that does not have energy as a conserved quantity. \nThis example is taken from Neuenschwander s book [13]. We use the following kinding, typing and cartesian \nspace contexts:  T = tt : T(1) G = k : lR(1, 0) . = t : R(1, tt +stt), x : R(exp(-tt), 0), x.: R(exp(-tt), \n0) Here, the position and velocity of the single particle scale with the exponential of the translation \nin time. This will account for the exponential damping we apply to the system. For simplicity, we assume \nthat the mass of the particle and the spring constant are both 1. The Lagrangian for this system looks \nsimilar to the coupled pair above, except for an additional damping factor: 1 1 L = x.2 - x 2 exp(t) \n: R(1, 0) 2 2 From the types of t, x and x., we learn that this system is invariant under the families \nof transformations FE(t) = t + 2E and .E(x) = e E x. This leads to the following conservation law for \nthis system, linking energy and linear momentum: d 1 11 2 2 t xx.+ x.+ x e = 0 dt2 22 6. Conclusions \nWe have presented a type system for writing invariant Langrangians, with a relationally parametric semantics \nthat allows the derivation of free theorems that can be used with Noether s theorem to dis\u00adcover conservation \nlaws for classical mechanical systems. Our key technical contribution has been the observation that relationally \nparametric models of System F. admit kinds that are interpreted as groupoids, allowing geometric invariance \nproperties to be inte\u00adgrated directly into the model. Related Work We are not aware of any other work \nlinking type systems or relational parametricity with invariance properties for classical mechanics, \nor with Noether s theorem. We have already mentioned the work of Atkey, Johann and Kennedy [5] that uses \nrelational parametricity with a specialised type system to derive geometric invariance properties, albeit \nin a setting without smooth functions, and without an application to Noether s theorem. In this paper, \nwe have placed Atkey et al. s work in a more general setting by framing it as an extension of System \nF., which allows us to (a) incorporate type-level computation, as we used to de.ne the n-ary vectors \nof coordinates; and (b) to reuse previous work on relationally parametric models of System F. by Atkey \n[3]. Sussman and Wisdom [20] reformulate Lagrangian and Hamil\u00adtonian mechanics in a more programming \nlanguage style so that it can be implemented within the programming language Scheme. In doing so, they \nclear up some of the ambiguous syntax common in the standard presentations of classical mechanics. However, \nthey do not attempt to incorporate invariance properties into types, as we have done here. There has \nbeen prior work on programming languages inspired by theoretical physics. Quantum programming languages, \nwhich hope to exploit the properties of quantum computation in an under\u00adstandable way, have been the \nsubject of study for several years now. We cite Abramsky [1] as an introduction to this .eld. Future \nWork We have barely scratched the surface of the appli\u00adcability of Noether s theorem to theoretical physics. \nConservation laws for classical and quantum .eld theories are derivable from the much more general theorem \nthat Noether originally proved [14]. Neuenschwander s book [13] describes in an easy to read way how \nNoether s theorem applies to .eld theories, allowing for relativistic and quantum systems to be studied, \nand how it naturally leads to the notion of Gauge invariance, an important principle in modern theories \nof particle physics. From the type system point of view, it seems clear that greater precision in the \ntypes will be required in order to accomodate more detailed physical theories. Study of relational parametricity \nfor dependent types, as done for example by Bernardy et al. [6] and Atkey et al. [4] may be useful here. \nAlso, recent work on homotopy type theory and, in particular 8-groupoid models of type theory is almost \ncertainly relevant [21]. For each of the examples in Section 5, we computed the neces\u00adsary typing derivations \nby hand. Type inference for the system was have presented here, or some variant of it, is a key item \nof future work. Ideally, the user would enter the description of a Lagrangian, and the system would be \nable to tell them the free theorems, and consequent conservation laws that hold. Kennedy [10] and Gundry \n[8] have studied type inference for the related, but simpler, setting of dimension types. References \n[1] S. Abramsky. High-Level Methods for Quantum Computation and Information. Proceedings, LICS, 2004. \n[2] V. I. Arnol d. Mathematical Methods of Classical Mechanics. Springer, 1989. [3] R. Atkey. Relational \nParametricity for Higher Kinds. Proceedings, CSL, 2012. [4] R. Atkey, N. Ghani, and P. Johann. A Relationally \nParametric Model of Dependent Type Theory. Proceedings, POPL, 2014. [5] R. Atkey, P. Johann, and A. J. \nKennedy. Abstraction and Invariance for Algebraically Indexed Types. Proceedings, POPL, 2013. [6] J.-P. \nBernardy, P. Jansson, R. Paterson. Proofs for Free: Parametricity for Dependent Types. Journal of Functional \nProgramming 22(2), pp. 107-152, 2012. [7] I. M. Gelfand and S. V. Fomin, R. A. Silverman (ed.). Calculus \nof Variations. Dover Publications, 2000. [8] A. Gundry. Type Inference for Units of Measure. Technical \nReport, University of Strathclyde, 2011. [9] R. Hasegawa. Relational Limits in General Polymorphism. \nPubli\u00adcations of the Research Institute for Mathematical Sciences 30, pp. 535 576, 1994. [10] A. J. Kennedy. \nDimension Types. Proceedings, ESOP, 1994. [11] A. J. Kennedy. Relational Parametricity and Units of Measure. \nProceedings, POPL, pp. 442-455, 1997. [12] L. D. Landau and E. M. Lifschitz. Mechanics. Pergamon Press. \n1967. [13] D. E. Neuenschwander. Emmy Noether s Wonderful Theorem. The John Hopkins University Press, \n2011. [14] E. Noether, M. Tavel (translator). Invariant Variation Problems. Transport Theory and Statistical \nPhysics 1(3), pp. 186-207, 1971. Original in Gott. Nachr., 1918:235-257, 1918. [15] S. Mac Lane. Categories \nfor the Working Mathematician, 2nd edition. Springer, 1998. [16] B. Pierce. Types and Programming Languages. \nMIT Press, 2002. [17] A. M. Pitts. Polymorphism is Set Theoretic, Constructively. Proc., Category Theory \nand Computer Science, pp. 12 39, 1987. [18] J. C. Reynolds. Types, Abstraction and Parametric Polymorphism. \nInformation Processing 83, pp. 513-523, 1983. [19] E. Robinson and G. Rosolini. Re.exive Graphs and Parametric \nPolymorphism. Proc., Logic in Computer Science, pp. 364 371, 1994. [20] G. J. Sussman and J. Wisdom. \nStructure and Interpretation of Classical Mechanics. MIT Press, 2001 [21] The Univalent Foundations Program. \nHomotopy Type Theory. Institute for Advanced Study, 2013. [22] P. Wadler. Theorems for Free!. Proceedings, \nFPCA, pp. 347-359, 1989.    \n\t\t\t", "proc_id": "2535838", "abstract": "<p>Invariance is of paramount importance in programming languages and in physics. In programming languages, John Reynolds' theory of relational parametricity demonstrates that parametric polymorphic programs are invariant under change of data representation, a property that yields \"free\" theorems about programs just from their types. In physics, Emmy Noether showed that if the action of a physical system is invariant under change of coordinates, then the physical system has a conserved quantity: a quantity that remains constant for all time. Knowledge of conserved quantities can reveal deep properties of physical systems. For example, the conservation of energy is by Noether's theorem a consequence of a system's invariance under time-shifting.</p> <p>In this paper, we link Reynolds' relational parametricity with Noether's theorem for deriving conserved quantities. We propose an extension of System F$\\omega$ with new kinds, types and term constants for writing programs that describe classical mechanical systems in terms of their Lagrangians. We show, by constructing a relationally parametric model of our extension of F$\\omega$, that relational parametricity is enough to satisfy the hypotheses of Noether's theorem, and so to derive conserved quantities for free, directly from the polymorphic types of Lagrangians expressed in our system.</p>", "authors": [{"name": "Robert Atkey", "author_profile_id": "81436601799", "affiliation": "United Kingdom", "person_id": "P4383889", "email_address": "bob.atkey@gmail.com", "orcid_id": ""}], "doi_number": "10.1145/2535838.2535867", "year": "2014", "article_id": "2535867", "conference": "POPL", "title": "From parametricity to conservation laws, via Noether's theorem", "url": "http://dl.acm.org/citation.cfm?id=2535867"}