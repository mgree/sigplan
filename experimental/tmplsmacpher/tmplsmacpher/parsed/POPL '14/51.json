{"article_publication_date": "01-08-2014", "fulltext": "\n Parametric E.ect Monads and Semantics of E.ect Systems Shin-ya Katsumata Research Institute for Mathematical \nSciences, Kyoto University, Kyoto, Japan sinya@kurims.kyoto-u.ac.jp Abstract We study fundamental properties \nof a generalisation of monad called parametric e.ect monad, and apply it to the interpretation of general \ne.ect systems whose e.ects have sequential composition operators. We show that parametric e.ect monads \nadmit analogues of the structures and concepts that exist for monads, such as Kleisli triples, the state \nmonad and the continuation monad, Plotkin and Power s algebraic operations, and the categorical ..-lifting. \nWe also show a systematic method to generate both e.ects and a parametric e.ect monad from a monad morphism. \nFinally, we introduce two e.ect systems with explicit and implicit sube.ecting, and discuss their denotational \nsemantics and the soundness of e.ect systems. Categories and Subject Descriptors D.3.1 [Programming Lan\u00adguages]: \nFormal De.nitions and Theory Semantics; F.3.3 [Log\u00adics and Meanings of Programs]: Studies of Program \nConstructs Type structure Keywords algebrac operation; computational e.ect; e.ect sys\u00adtem; lax monoidal \nfunctor; monad; parametric e.ect monad 1. Introduction E.ect system is a type-based approach to statically \nestimate compu\u00adtational e.ects caused by programs. The basic idea of e.ect system is to add to each typing \njudgement G . M : t an expression e that estimates the scope of M s computational e.ect. The expression \ne is called e.ect. The de.nition of e.ects depends on the computa\u00adtional e.ect that the programming language \nsupports, and also the property we would like to know about the computational e.ect. For instance, Various \ne.ect systems and their semantics are studied for the analysis of memory usage during the execution of \nprograms [6, 7, 22, 32, 34, 37]. E.ects are de.ned to be sets of atoms rd.,wr.,init. tagged with regions. \n In [27], an e.ect system for concurrent ML (an extension of ML with communication primitives) is designed \nto analyse the communication behaviour of programs. There, e.ects are expressions of a process calculus. \n Permission to make digital or hard copies of all or part of this work for personal or classroom use \nis granted without fee provided that copies are not made or distributed for pro.t or commercial advantage \nand that copies bear this notice and the full citation on the .rst page. Copyrights for components of \nthis work owned by others than the author(s) must be honored. Abstracting with credit is permitted. To \ncopy otherwise, or republish, to post on servers or to redistribute to lists, requires prior speci.c \npermission and/or a fee. Request permissions from permissions@acm.org. POPL 14, January 22 24, 2014, \nSan Diego, CA, USA. In [13], Kammar and Plotkin designs an e.ect system that estimates the set of algebraic \noperations invoked during the execution of programs. Statically estimating properties of computational \ne.ects brings various bene.ts to the analysis and transformation of programs. The main purpose of the \npioneering work by Lucassen and Gi.ord [22] was to design the e.ect system that assists safe scheduling \nof expressions in parallel computing. Since then, many e.ect systems have been designed for analysing \nthe behaviour of programs. For instance, control .ow analysis can be concisely captured as an ef\u00adfect \nsystem [28]. The region-based memory management in func\u00adtional languages is developed based on the idea \nof e.ect system [35]. A series of papers [6 8, 34] study a semantic foundation for some aggressive program \ntransformations that depend on the result of e.ect analysis. Kammar and Plotkin gave a general algebraic \nac\u00adcount of the e.ect-dependent optimisations based on the property of algebraic theories [13]. In the \nseminal paper [37, 38], Wadler integrated the e.ect anno\u00adtation and Moggi s monadic interpretation of \ncomputational e.ects into e.ect-annotated monadic type T (e, t). He then posed a ques\u00adtion: What is the \ndenotational semantics of the e.ect-annotated monadic type? The main theme of this paper is to propose \nan an\u00adswer to this problem. Semantic Structures for E.ect-Annotated Monadic Types An answer to Wadler \ns question consists of 1) a formulation of the concept of e.ect, and 2) a mathematical structure corresponding \nto the e.ect-annotated monadic type. One type of solution formulates e.ects as join semilattices, and \nuse the join operator to compute the e.ect of let expressions. In this solution, each e.ect represents \na set of events, and an e.ect\u00adannotated monadic type T(e, t) is given to the programs that cause the \ncomputational e.ects (regarded as events) in e. The typing rule for let expressions is: G . M : T(e, \nt) G, x : t . N : T(e ' , s) (1) G . let x be M in N : T(e .e ' , s). This type of solutions captures \nwell the feature of the e.ect systems for memory usage analysis in [6, 7, 22, 32, 34, 37]. One of the \nearliest solutions of this type is Filli atre s generalised monad [10]. However, using the join operator \nto compute the e.ect of let expressions is not always satisfactory. Here are some examples: 1. Let us \nconsider an e.ect system that estimates exceptions raised by programs (we ignore exception handlers). \nWe de.ne an ef\u00adfect to be a set of exceptions. Then e.ects form a join semilat\u00adtice by the set union. \nAn instance of the typing rule (1) is the following derivation: Copyright is held by the owner/author(s). \nPublication rights licensed to ACM. G . raiseE1 : T({E1}, t) G, x : t . raiseE2 : T({E2}, s) t s ACM \n978-1-4503-2544-8/14/01. . . $15.00. http://dx.doi.org/10.1145/2535838.2535846 G . let x be raiseE1 in \nraiseE2 : T({E1} . {E2}, s) t s  The union of exceptions in the second line is sound, but not precise, \nbecause E2 willnever be raised. 2. Let us consider an e.ect system that estimates output strings of programs. \nA natural de.nition of an e.ect is thus a set of strings. Although e.ects form a join semilattice by \nthe set union, it is inadequate to use the join operator in the typingrule (1)to compute the output strings \nof let expressions. Rather, we should use the language concatenation {l@l ' |l . e, l ' . e ' }. Problem \n1.1 To compute the e.ect oflet expressions, what kindof a structure shall we assume on e.ects ? Problem \n1.2 When the structure on e.ects is given in the answer to Problem 1.1, what is an appropriate semantic \nstructure for the e.ect-annotated monadic type? Problem 1.3 How do we construct the structures proposed \nas a solution to Problem 1.2? Algebraic Operations with E.ects The operations that manipu\u00adlate computationale.ects, \nsuchas raise for exception raising, read /write for store access, etc., are important ingredients to \nmake pro\u00adgramming languages rich and expressive. To represent such opera\u00adtions in the monadic semantics \nof programminglanguages, Plotkin and Power introduced algebraic operations [30]. Problem 1.4 How do we \nextendalgebraic operations to the seman\u00adtic structure given as an answer to Problem 1.2? The Meaning \nof Delimiting Monads by E.ects Wadler pointed out the essence of e.ects as follows: e.ects delimit the \nscope of computationale.ects [37, 38]. 1 To elaborate this, suppose thatwe have a programming language \nL with computational e.ects, and a denotational semantics of L using a monad T0. An e.ect system designedfor \nLintroduces an e.ect-annotatedmonadic type T(e,t), andit is given to the terms whose computational e.ects \nis within e. This suggests that we maysee T(e,t)as a predicate on T0[t]. Problem 1.5 How do we denotationally \nformulate that e.ects delimit the scope of computational e.ects ? Another issue is the soundness of e.ect \nsystem. When the e.ect system asserts that a program M of a base type b has an e.ect e, then we expect \nthat the execution of M causes the computational e.ect within the scope denoted by e. We formulate this \nas follows. We .rst specify the scope of computational e.ects of an e.ect e by a predicate Sbe on T0[b]. \nThen we consider whether for all judgements M : T(e,b)in the e.ect system, we have [M] . Sbe. Ifthis \nholds, then we saythatthe e.ectsystem is soundwithrespect to the speci.cations of e.ects. Problem 1.6 \nHow do we establish the soundness of e.ect systems with respect to given speci.cations of e.ects? 1.1 \nContributions of this Paper This paper proposes the followingsolutions to the above problems. Especially, \nsolutions to Problem 1.3-1.6 are the technical contribu\u00adtions of this paper. Solution to Problem 1.1 \nWe postulate that e.ects form a pre\u00adordered monoid. The monoid structure is to compute the e.ect of let \nexpressions, and the preorder is to compare the scope of e.ects. The typing rule (1)for let expressions \nis re.ned to G . M : T(e,t) G, x : t . N : T(e ' , s) . (2) G . let x be M in N : T(e \u00b7 e ' , s) Actually, \nthis typing rule had already appeared in [3]to sketch the idea of e.ect system, but its semantic account \nwas not given there. 1In this paper, the word delimit is irrelevant to the delimited continuation. Solution \nto Problem 1.2 Corresponding to the above solution, for a preordered monoid E = (E, :,1, \u00b7)of e.ects, \nwe employ the followingtriple (plus a strength, which we omit here): T : E . [C,C], T1 : Id . T1, Te,e \n' : Te .Te ' . T(e \u00b7 e ' ) satisfying the axioms of lax monoidal functor as a semantic struc\u00adture for \ninterpreting the e.ect-annotated monadic type. The mor\u00adphisms T1 and Te,e ' replace the unit and multiplication \nof monad. The axioms ofmonad become the followingcommuting diagrams: T1.Te Te.Te ' ,e '' . . ' '' ) Te \nT1.Te Te .Te ' .Te '' Te .T(e \u00b7 e   Te.T1 T1,e T' .Te '' T' '' e,e e,e \u00b7e t ttt  . .. ' '' ) Te \n.T1 Te T(e \u00b7 e ' ).Te '' T(e \u00b7 e \u00b7 e Te,1 T' '' e\u00b7e ,e Such a structure is called a parametric monad \nby Melli`es [25], and is introduced as an underlying categorical structure for estab\u00adlishinga bridge \nbetween linear logic and the theoryof strongmon\u00adads. In this paper, we consider itas a directcounterpart \nofthe e.ect\u00adannotated monadic type, and study it from the viewpoint of e.ect system. As we focus on the \nparametric monads whose parameter categories are preordered monoids of e.ects, we call them para\u00admetric \ne.ect monads to emphasise the restriction. We show that there are parametric analogues of the concepts \nthat exist in the theory of monad, such as Kleisli triples, the state monad, the continuation monad, \nalgebraic operations [30], and the categorical ..-lifting[14]. This situation suggests that parametric \ne.ect monads are a natural generalisation of monads. Moreover, preordered monoids and lax monoidal functors \nare standard con\u00adcepts in the theory of monoidal category. Therefore, the tools and results on monoidalcategories \nare available for them (e.g. [24, 25]). We mention the recent work [33]by Tate, where he introduces respectively \ne.ectors and productors as a solution to Problem 1.1 and 1.2. They are more expressive than parametric \ne.ect monads (see Section 6.1). Yet, the aforementioned features of parametric e.ect monad shows that \ntheyhave rich structures to be studied. Solution to Problem 1.3 We give a systematic method to con\u00adstruct \nboth a preordered monoid E of e.ects and a parametric E-monad on Set from a monad morphism a : T . (S,.); \nits codomain is a preordered monad [16]. We then extend this con\u00adstruction to domain-theoretic setting. \nCompared to giving e.ects and parametric e.ect monads by hand, it is relatively easy to give e.ect observations. \nWe demonstrate this method with the case where T is the writer monad, exception monad, free algebra monad \nand probabilistic writer monad, derivingparametric e.ect versions of these monads. Solution to Problem \n1.4 We extend algebraic operations to para\u00admetric e.ect monads in two ways. One wayis to add to the arityof \nan algebraic operation an e.ect e that describes its computational e.ect. An extended algebraic operation \nhas a triple (I, J,e) as its arity, and it is a natural transformation: ae ' ,K : J . Te ' K . I . T(e \n\u00b7 e ' , K) satisfyingcertain equational axioms. It bijectivelycorresponds to a morphism oftype I . TeJ. \nHowever, when using an algebraic operation of the above type, we have to align the e.ect ofallthe arguments \nto e ' . This constraint decreases the accuracy of the estimation of e.ects in some situa\u00adtions. To remedythis \nproblem, we introduce another wayto extend algebraic operations with e.ects. We allow algebraic operations \nto have di.erent e.ects in their argument positions, anddescribe their e.ect byan e.ect function o. Then \nan algebraic operation extended in this way has a tuple (n,o)as its arity, and it is a certain natural \ntransformation:  ae1,\u00b7\u00b7\u00b7 ,en,I : T e1I \u00d7 \u00b7 \u00b7 \u00b7 \u00d7 T enI . T(o(e1,\u00b7 \u00b7 \u00b7 ,en))I. Solution to Problem 1.5 \nOur solution takes two steps. First, we introduce the e.ect system EFi that is designed as a re.nement \ntype system over Moggi s computational metalanguage (.ML for short). Each EFi-type tre.nes its e.ect \nerasure |t|, which is always a .ML \u00adtype. We next give a denotational semantics of EFi in a faithful \nfunctor p : P . C with certain structures. We regard P as a category of predicates on objects in C, and \nan object X in P as a predicate on the object pX in C. We then interpret each re.nement type t as an \nobject (t)in P and its e.ect erasure as an object [|t|] in C, so that we have p(t) = [|t|], that is, \nthe denotation of a re.nement type gives a predicate on the denotation of its erasure. To express that \ne.ects delimit the computational e.ects modelled by a monad T on C, we interpret e.ect-annotated types \nby an parametric e.ect monad T.on P such that p(T.(e, X)) = T(pX). Solution to Problem 1.6 After categorically \nformulating the ef\u00adfect soundness, we give a su.cient conditions for the e.ect system EFi to be sound \nwith respect to a given speci.cation of e.ects. This su.cient condition is natural and applicable to \nany monad, pre\u00adordered monoid of e.ects, e.ect speci.cation and algebraic opera\u00adtion. The proof employs \nan parametric e.ect version of categorical ..-lifting [14]. Preliminaries Notation We write l@l ' for \nthe concatenation of two sequences l and l ' . We write 1for 1) the one-point set {*}, 2) a terminal \nobject in a category, and 3) a trivial category whose unique object is *. The disjoint union of sets \nI1,\u00b7 \u00b7 \u00b7 , In tagged with l1,\u00b7 \u00b7 \u00b7 ,ln is denoted by l1(I1)+ \u00b7 \u00b7 \u00b7 + ln(In). Category Theory A thin category \nis the one whose homsets have cardinality at most 1. Thin small categories are exactly preordered sets. \nIn this paper, by a bi-CCC we mean a category with chosen .nite products, .nite coproducts and exponentials. \nWe write .CPO for the category of all .-complete posets (which may not contain the least element) and \ncontinuous func\u00adtions between them. We also write Pre for the cartesian monoidal category of preordered \nsets and monotone functions between them. We use for the vertical composition and * for the horizontal \ncomposition of natural transformations; see [23, Section XII-3] for these operations. For a natural transformation \na and a functor F, we write a. F for a* idF and F .afor idF * a, respectively. Monad We use sans-serif \ncapital letters T, S,\u00b7 \u00b7 \u00b7 to denote mon\u00adads. Its functor part is referred by Roman capital letters T,S,\u00b7 \n\u00b7 \u00b7 . For a monad T = (T, .T, \u00b5T)and a morphism f : I . TJ, by f#T (or f# if T is obvious from the context) \nwe mean the Kleisli lifting \u00b5T J .Tf of f. The monads used in this paper are de.ned in Table 1. Computational \nMetalanguage In this paper, by computational metalanguage (.ML for short) we mean the simply typed lambda \ncalculus with products, coproducts, monadic types and algebraic operations; see [26, 30]. The set TypML(B)of \n.ML-types generated from a set B is de.ned by the following BNF: OU t ::= b | (t, \u00b7 \u00b7 \u00b7 , t)| (t, \u00b7 \u00b7 \n\u00b7 , t)|t . t|Tt (b . B). We specify a .ML by a .ML-signature . = (B,O, s), where B and O are sets of \nbase types and operator symbols respectively, and s : O . H(GTyp(B)2)+I(N) is a function assigning an \narity to each operator symbol o . O; here GTyp(B)is the subset of TypML(B) consisting only of base types, \nproduct types and coproduct types. See Section 4 for the distinction on arities. A semantics of .ML(.) \nis speci.ed by a .ML(.)-structure: a tuple (C,T, [-])where C is a bi-CCC, T is a strong monad on C and \n[-] assigns: Category Symbol De.nition of functor (object part) Powerset monad /non-empty powerset monad \nSet P/P+ PI = 2I , P+I = 2I\\{\u00d8} Writer monad Set Wr(S) Wr(S)(I)= S* \u00d7 I Exception monad Set Ex(E) Ex(E)(I)= \nEr(E)+ Ok(I) Distribution monad Set Ds Ds I = {f : I . [0,1] | supp( f): .nite,li.I f(i)= 1} Lifting \nmonad .CPO L LI = I. Table 1. De.nition of Monads 1. an object [b] . C to each b . B (we extend this \nto GTyp(B) using the bi-cartesian structure of C), 2. a ([\u00df],[\u00df ' ])-ary algebraic operation [o] for \nT to each o . O such that s(o)= H(\u00df, \u00df ' ), and 3. an n-ary algebraic operation [o] for T to each o \n. O such that s(o)= I(n).  Monoidal category A monoidal category consists of a category C, an object \nI . C called the tensor unit, a bifunctor . . C2 . C called the tensor product, and natural isomorphisms \nl,r,a satisfy\u00ading coherence axioms; see [23, Section XI-1]. A monoidal category is strict if l,r,a are \nall identities. For every category C, the functor category [C,C]together with the identity functor IdC \nand the func\u00adtor composition forms a strict monoidal category [23, Exercise XI\u00ad3.1]. We use this strict \nmonoidal structure as the default one on [C,C]. A lax monoidal functor ( lax is dropped in [23, Section \nXI\u00ad2]) between monoidal categories C,D consists of a functor F : C . D, a morphism FI : I . FI and a \nnatural transformation FI,J : FI . FJ . F(I . J) satisfying certain conditions. When FI and FI,J are \nidentities, we replace lax with strict . We write LaxMonCAT (resp. StrictMonCAT) for the super-large \ncategory of strict monoidal categories and lax (resp. strict) monoidal functors between them. 2. Parametric \nE.ect Monads 2.1 Preordered Monoids as E.ects The role of e.ects in various e.ect systems is to represent \nscopes of computational e.ects caused by programs. As we stated in Section 1, we adopt the following \nabstract formalisation of the concept of e.ect. Postulate 2.1 E.ects form a preordered monoid. A preordered \nmonoid is exactly a monoid object in the cartesian monoidal category Pre; it consists of a preorder (E, \n:), an element 1 . E and a monotone function (\u00b7) : (E, :)2 . (E, :) that satisfy the axioms of monoid. \nBelow, by e ~ e ' we mean (e : e ' ). (e ' : e). To save space, by the juxtaposition of e and e ' we \nmean e \u00b7 e ' . A partially ordered monoid is a preordered monoid such that e ~ e ' .. e = e ' . By join \nsemilattice we mean a partially ordered monoid whose monoid structure is given by the join operator. \nWe identify preordered monoids and strict monoidal thin small categories.  2.2 Parametric E.ect Monads \nWe introduce the main subject of this paper, parametric e.ect monad.  De.nition 2.2 Let E be a preordered \nmonoid. A parametric E\u00admonad on a category C is a lax monoidal functor T : E . [C,C]. This is expanded \nto the followingelementary de.nition: De.nition 2.2-bis Let E = (E, :,1, \u00b7)be a preordered monoid. A \nparametric E-monad consists of the followingdata. 1. An endofunctor Te : C . C for every e . E. 2. Anaturaltransformation \nT(e : e ' ): Te . Te ' for everye : e ' . This satis.es:  ' '' ' '' T(e : e)= idTe, T(e : e ) T(e : \ne )= T(e : e ). 3. A natural transformation T1 : Id . T1. 4. A natural transformation Te,e ' : Te . \nTe ' . T(ee ' )for every e,e ' . E.  These data make the followingdiagrams commute: T ' e1,e Te1 .Te \n' 1 1 . T(e1e1' ) '' '' T(e1:e2)*T(e :e ) T(e1e :e2e ) 1212 t t Te2 .Te ' 2 . T(e2e2' ) T ' e2,e 2 T1.Te \ne ,e Te.T' '' ' '' ) Te .Te ' .Te '' Te .T(eT1.Te Te . . e   Te.T1 t t t t  Kleisli triples \non C. bot tot De.nition 2.5 Let C be category with .nite products and E be a preordered monoid. A strong \nparametric E-monad is a lax monoidal functor T : E . [C,C]s. We can alternatively de.ne the tensorial \nstrength as a commuta\u00adtor between a parametric e.ect monad T and the action of C to itself;see [25, Section \n4]. We note that [Set,Set]s is isomorphic to [Set,Set], thus there is no di.erence between parametric \nE-monads and strong ones on Set.  2.3 Maps from Parametric E.ect Monads to Monads We introduce a particular \ntype of morphism for parametric e.ect monads. This will be used in Section 5.2 to express the situation \nthat a parametric e.ect monad speci.es predicates on the underly\u00adingmonad.f De.nition 2.6 Let p : C . \nD be a functor, T be a parametric e.ect monadon C andS = (S,.,\u00b5)be a monadon D. We saythat pmaps T to \nS if p(TeX)= S(pX), p((T1)X)= .pX, p((Te,e ' )X)= \u00b5pX. Though we omit the detail, there are other variations \nof morphism for parametric e.ect monads. Theyare analogues ofthe morphisms for monads studied in e.g. \n[19].  2.4 Examples of Parametric E.ect Monads Example 2.7 (Monads) Parametric e.ect monads subsume \nmon\u00ad ads. Let us write 1 for the trivial, one-point preordered monoid. T' .Te '' T' '' T1,e e,e e,e e \nThen parametric 1-monads on a category C bijectively correspond . . ' '' ) Te .T1 Te T(ee ' ).Te '' T(ee \ne Te,1 T' '' ee ,e Parametric e.ect monads can be equivalently presented in the form of Kleislitriple. \nDe.nition 2.3 Let E = (E, :,1, \u00b7) be a preordered monoid. An parametric E-Kleisli triple on a category \nC consists of the follow\u00adingdata. 1. A functor T - I : E . C for every I . C. 2. A morphism .I : I . \nT1I for every I . C. 3. A mapping (-)e#e ' : C(I,Te ' J) . C(TeI,T(ee ' )J) for every I, J . C and e,e \n' . E. We call this mapping Kleisli lifting.  These data satisfy(below f : I . TeJ and g : J . Te ' \nK) (T(e : e '' )J . f)e ' #e '' = T(e ' e : e ' e '' )J . fe ' #e fe ' #e .T(e '' : e ' )I = T(e '' e \n: e ' e)J . fe '' #e f1#e ..I = f (.I)e#1 = idTeI (g e#e ' . f)e '' #(ee ' ) = g(e '' e)#e ' . fe '' \n#e . Proposition 2.4 Let E be a preordered monoid. Then parametric E-monads on a category C bijectively \ncorrespond to parametric E to monads on C. This is an instance of the fact that monoids in a monoidal \ncategory V bijectively correspond to lax monoidal func\u00adtors oftype 1 . V. Example 2.8 (Parametric Writer \nMonad) This example shows the writer monad whose output strings are delimited by a given language. Let \nS be a set of alphabets. We consider the following partiallyordered monoid E of languages over S: E = \n(P(S * ),.,{o},\u00b7) where e \u00b7 e ' = {l@l ' |l . e,l ' . e ' }. Then the followingdata: TeI = e \u00d7 I, (T1)I(i)= \n(o,i), (Te,e ' )I(l,(l ' ,i))= (l@l ' ,i) give a parametric E-monad on Set. Although T inherits the struc\u00adture \nfrom the writer monad Wr(S), each Te is not a monad. Example 2.9 (Totality Types) This is the semantic \nanalogue ofto\u00adtalitytypes byNielsen et al. [31]. We consider the partiallyordered monoid E = ({tot, par,bot}, \n=,tot, \u00b7) whose order and multiplica\u00adtion are de.ned as follows: par . .... .... bot (x = bot .y = bot) \n // / / / / x \u00b7 y = tot (x = tot .y = tot) par (otherwise) ' ' The functor T : E . [.CPO,.CPO]mapping \nthe above Hasse Parametric e.ect monads are yet insu.cient to interpret the diagram to the following \ndiagram in [.CPO,.CPO]: typing rule (2). We need tensorial strengths on them so that we   can add \nan extra parameter to the Kleislilifting: L   k. Y Y Y Y Y Y Y  ' ' ' ' .L '' (-)e#e : C(I \u00d7 J,TeK). \nC(I \u00d7 Te ' J,T(e ' K1I = 1e)K). (k.)I(*) = . We derive the concept ofstrongparametric e.ectmonadas follows. \nK1 IdFor a category C with .nite products, we write [C,C]s for the categoryofstrongendofunctors andstrongnaturaltransformations \nextends to a parametric E-monad on .CPO. between them [18]. We then equip it with the strict monoidal \nstructure given by the identity functor and the composition of We next give parametric e.ect versions \nof the state monad and the strongendofunctors. continuation monad. For this, we employa categoricalconstruction \ncalled end [23, Section IX-5]. Let E = (E, :)be a preordered set. L The end of a functor F : Eo p \u00d7 \nE . Set is denoted by F(e, e), and consists of the tuples a . O e.E F(e, e)such that e.E '''' ' .e,e \n. E . e : e . F(e : e ,e )(ae ' )= F(e, e : e )(ae). Example 2.10 (Parametric State Monad) Let E = (E, \n:,1, \u00b7)be a preordered monoid and S : E . Set be a (mere) functor. Then the following end l T eI = S \nd . (I \u00d7 S(de)) d.E extends to a parametric E-monad. This end collects the state trans\u00adformers that take \na state of type S d, and update it to a state of type S(de). The e.ect e abstractly represents what state \ntransformers perform on states. It is added after d because e is the latest action performed on the state. \nExample 2.11 (Parametric Continuation Monad) We continue using E and S in the above example. The following \nend: l T eI = (I . S d). S(ed) d.E extends to a parametric E-monad. An element in T eI is a compu\u00adtation \nc that takes a continuation k of type I . S d, and computes a value in the return type S(ed). The e.ect \ne abstractly represents what c performs on the return type. As continuations are invoked after the main \ncomputation of c, d is added after e.  2.5 Monads Indexed by Join-Semilattices Let E be a poset. Let \nus call a functor of type E . Mnd(C) an E-indexed monad, where Mnd(C) is the category of monads on C \nand monad morphisms between them. It is employed to model the layered structure of computational e.ects \nin Filinski s multi-monadic meta language M3L [9]. The typing rule for let expressions in M3L: G . M \n: T(e, s) G, x : s . N : T(e ' , t) e = e ' G . let x be M in N : T(e ' , t) is reminiscent to the one \nin general e.ect system. Indeed, when E is a join semilattice, the general typing scheme (2) augmented \nwith the side condition e = e ' yields the above rule, because T(e.e ' , t)= T(e ' , t). We can say more \nthan this syntactic relationship. Theorem 2.12 Let E be a join semilattice. Then E-indexed monads bijectively \ncorrespond to parametric E-monads. This theorem is an analogue of [33, Theorem 3], which is stated within \ne.ector /productor framework. Filli atre s generalized mon\u00adads [10] also determine join-semilattice indexed \nmonads that map the least element to the identity monad. There are many examples of monads indexed by \njoin semilattices; see e.g. [13, 33]. 3. Parametric E.ect Monads via E.ect Observations We next introduce \na construction of both a preordered monoid E and a parametric E-monad on Set from e.ect observations. \nThis construction is based on the following nature of e.ects. 1. E.ects are expressions of an ordered \nalgebra. This point be\u00adcomes clear when moving to an elaborated e.ect system, such as the one for behaviour \nanalysis of concurrent ML programs [27]. There, e.ects are process algebra expressions ordered by their \nbehaviour. We capture an ordered algebra structures on e.ects by a pre\u00adordered monad (S,.)on Set [16]. \nIt is a pair of a monad S on Set and an assignment . of a preorder .I on SI to each set I satisfying: \n(substitutivity) for every function f : I . SJ, f# is a mono\u00adtone function of type (SI,.I). (SJ,.J)and \n(congruence) for every function f,g : I . SJ, f .J g implies f# .J g # (here .J is extended to the pointwise \norder for functions). The assignment . bijectively corresponds to a pointwise Pre\u00adenrichment on SetS;see \n[16] for the detail. 2. E.ects are abstractions of computational e.ects. Each e.ect abstractly expresses \nsome aspects of actual computational ef\u00adfects caused by programs. We capture this situation by considering \na monad T that models programming language s computational e.ects, and a monad morphism a : T . S that \nobserves computational e.ects and gives their abstract representations (i.e. e.ects). We package the \nabove data into an e.ect observation. De.nition 3.1 An e.ect observation of a monad T on Set consists \nof the following data: 1. A preordered monad (S,.)on Set. 2. Amonad morphism a : T . S.  The notation \nfor an e.ect observation (of T) is a : T . (S, .). First, from an e.ect observation we construct a preordered \nmonoid of e.ects. Let us write ThS for the algebraic theory cor\u00adresponding to S. We then de.ne an e.ect \nto be a ThS-polynomial in one variable *; in other words, an element in S1. Such polyno\u00admials carry the \ncanonical monoid structure given by the variable substitution: the monoid unit 1 is the variable * itself, \nand the mul\u00adtiplication \u00b7 is the substitution e \u00b7 e ' = e[e ' /*]of e ' into * in e. We express this \nmonoid structure in terms of S: De.nition 3.2 Let (S, .) be a preordered monad on Set. We de.ne the preordered \nmonoid (S1,.1,1,\u00b7) by .S ' ' )#S 1 = 1(*), e \u00b7 e = (.x . 1 . e (e). (3) We denote this by S1. Next, we \nconstruct a parametric S1-monad. Let e . S1 be an e.ect. We consider the composite function vI = a1.T!I \n: TI . S1. It .rst extracts the computation part of x . TI by replacing all the values inside x to * \n(. 1). Then the monad morphism a1 gives its abstract representation as an e.ect. We then express that \nthe computational e.ect of x is included in the scope of e by the inequality vI(x).1 e, which we use \nto delimit TI by e.ects. Theorem 3.3 Let a : T . (S, .) be an e.ect observation of a monad T on Set. \nWe de.ne the following assignment D of sets: DeI = {x . TI |a1 .T!I(x).1 e} (e . S1, I . Set) together \nwith the inclusion function iI : DeI . T I. Then: 1. The unit .T I restricts to a function of type I \n. D1I. 2. For all function f : I . De ' J, (iJ . f)#T restricts to a function of type DeI . D(ee ' )J. \n 3. The tuple of D, .T and (f)e#e ' = (i . f)#T is a parametric S1-Kleisli triple.  When giving an e.ect \nsystem, it is desirable to have the join operator on e.ects (apart from a monoid structure), because \nwe can use it to unify the e.ects given to di.erent branches of case expressions. The following examples \nmainly observe a Set-monad T that models computational e.ects by means of another monad S whose preorder \nadmits the join operator, so that S1 also admits the join operator. In some cases S is given as the extension \nof T with the join operator.  Example 3.4 We construct a parametric e.ect monad that is suit\u00adable for \nestimating exceptions raised by programs. There is a dis\u00adtributive law Ex(E).P+ . P+ .Ex(E), and from \nthis we obtain an e.ect observation of Ex(E): .P+ .Ex(E): Ex(E). (P+ .Ex(E), .). De.nition 3.2 gives \nthe following partially ordered monoid: (P+(Ex 1),.,{Ok(*)},\u00b7), whose monoidal product is given by ' \ne Ok(*)f e e \u00b7 = e ' (e\\{Ok(*)}).e Ok(*). e. The parametric P+(Ex 1)-monad D induced by Theorem 3.3 is \nDeI = {Er(a)|Er(a). e} . {Ok(v)|v . I,Ok(*). e}. We illustrate how e.ects in P+(Ex 1) and the parametric \ne.ect monad D describes computational e.ects. c1 . D{Ok(*)}I is a computation that terminates normally, \nwithout raising any exception.  c2 . D{Er(a), Ok(*)}I is a computation that either terminates normally \nor may raise an exception a, but no other exception will be raised.  c3 . D{Er(b), Er(c)}I is a computation \nthat will raise either an exception b or c, but do nothing else, including normal termination.  The \nmonoid structure of P+(Ex1) appropriately captures the fact that the exception raising cancels the rest \nof the computation. For instance, consider the sequential execution of the computation c3 followed by \nc2. As c3 never terminates normally, we will not ob\u00adserve the computational e.ect caused by c2. The monoid \nmulti\u00adplication of P+(Ex1) gives the following e.ect to the sequential execution c3;c2: {Er(b), Er(c)}\u00b7 \n{Er(a), Ok(*)}= {Er(b), Er(c)}, which correctly captures the computational e.ect of c3;c2. Example 3.5 \nGeneralising the previous example, let S be a .rst\u00adorder single-sorted signature (without equational \naxioms) and O be the set of symbols de.ned in S. We write TS for the monad of free-S algebra, and aim \nto design the parametric e.ect monad that estimates the occurrences of operators in t . TSI, and also \nthe closedness of t. The monad morphism we use to observe TS is the following | - | : TS . P(Op(O)+ Var(-)): \n|x|= {Var(x)}, |o(t1,\u00b7 \u00b7 \u00b7 ,tn)|= {Op(o)} . |t1| . \u00b7 \u00b7 \u00b7 . |tn| It collects the operator symbols and \nvariables occurring in t. The partially ordered monoid derived from the e.ect observation | - | : TS \n. (P(Op(O)+ Var(-)),.) is (P(Op(O)+ Var(1)),.,{Var(*)},\u00b7), whose multiplication is given by e Var(*)f \ne ' e \u00b7 e = ' (e\\{Var(*)}).e Var(*). e. The parametric P(Op(O)+Var1)-monad Dderived by Theorem 3.3 is \nDeI = {t . TSI | |t[*/i]| . e}. We illustrate how this parametric e.ect monad estimates occur\u00adrences \nof operator symbols and closedness of S-terms. t . D{Op(s),Op(z),Var(*)}I is a S-term consisting of \noperator symbols s,z and variables. It may be closed. No other operator occurs in t.  t . D{Op(c),Op(f)}I \nis a closed S-term consisting of the operator symbols f,c only.  Example 3.6 We derive Example 2.8 by \nTheorem 3.3. We consider the writer monad Wr(S). There is a distributive law Wr(S). P . P.Wr(S), and \nfrom this we obtain an e.ect observation of Wr(S): .P .Wr(S): Wr(S). (P .Wr(S),.) De.nition 3.2 yields \nthe partially ordered monoid of languages over S, and Theorem 3.3 yields the parametric e.ect monad that \nis (isomorphic to) the one in Example 2.8. Example 3.7 We consider modelling the programming language \nthat has a character output operator outc and a binary probabilistic choice operator - .p -, which chooses \nthe left computation with probability p or the right one with probability 1 - p. We model these computational \ne.ects by the composite monad Ds .Wr(S)of the distribution monad and the writer monad. We .rst derive \na parametric e.ect monad that estimates output strings of programs, ignoring their output probability. \nFor this, we use the monad morphism supp : Ds . P+ that computes the support of a given distribution: \nsuppI(d)= {i . I |d(i)* 0}. By composing the writer monad, we obtain the following e.ect observation \nof Ds .Wr(S): supp .Wr(S): Ds .Wr(S). (P+ .Wr(S), .). We apply Theorem 3.3 to this situation. It yields \nthe partially or\u00addered monoid of non-empty languages P+(S*)over S (c.f. Example 2.8). The parametric \nP+(S*)-monad is then given as DeI = {d . Ds(Wr(S)(I)) |suppWr(1) .Ds(Wr(S)(!I))(d). e} = {d . Ds(S * \n\u00d7 I)| .l . S * ,i . I . d(l,i)* 0 =. l . e}. Example 3.8 (Continued from the above example) We next derive \nanother parametric e.ect monad that takes it into account the prob\u00adability of output strings. Following \nthe pattern of Example 3.4 and 2.8, we extend the (algebraic theory of) distribution monad Ds with the \njoin operator, then use the embedding of Ds to the extended monad as an e.ect observation. The extension \nof Ds with the join operator is known to yield the monad that collects convex subsets of distributions \n[12, 36], which we explain below. Let X . Ds I be a subset of probability distributions over I. The convex \nclosure of X collects all the probabilistic combinations of distributions in X: 8 {En } CX = i=1 t(i)\u00b7 \ndi |t . Ds{1,\u00b7 \u00b7 \u00b7 ,n},d : Xn . n=0 When CX = X, we call X convex. The monad Cv of convex subsets of \ndistributions then collects all the .nitely generated non-empty convex subsets of Ds I: Cv I = {CX | \n\u00d8 < X ..n Ds I}. The inclusion relation between convex subsets gives a preorder on Cv. We write .p,I \n: (Cv I)2 . Cv I for the probabilistic summation of two convex subsets: X .p,I Y = {d .p d ' |d . X,d \n' . Y}. The singleton set function {-}I : Ds I . Cv I is a monad morphism, hence we obtain an e.ect observation \n{-} . Wr(S): Ds .Wr(S). (Cv .Wr(S),.).  By applying Theorem 3.3, we obtain the partially ordered monoid \n(Cv(S*),.,{{o : 1}},\u00b7), and a parametric Cv(S*)-monad: DeI = {d . Ds(S * \u00d7 I)|{d}. e}, where d . Ds(S*)is \nthe distribution given byd(l)= i.I d(l,i). We see the role ofthe convexity in e.ects. Consider the follow\u00adingconditional \nexpression. M = if N then outa()else outb(). This is a deterministic program that outputs either a or \nb. The summary of the side e.ect is thus M outputs a with probability 1 or b withprobability1 , but it \nis yet unclear what is the probability . of choosing then branch and else branch by the conditional \nexpression. The monad Cv handles this situation by taking the convex closure: C({{a : 1},{b : 1}})= {{a \n: p,b : (1- p)}| p . [0,1]} to give the overall probability of the output strings of M. 3.1 E.ect Observations \nin an Order-EnrichedSetting We next give an analogue of Theorem 3.3 in a Pre-enriched cate\u00adgory C. We \nassume that C has a terminal object 1, and that C has chosen comma objects of the followingform: f . \nj ! 1 l pf,j : j (4) t t  .  . .  . . I J f An informal way to see the comma object f . j is that \nit is the .J along f. . j. pullback of the inclusion of the downset Below we write C0 for the underlying \nordinary (i.e. Set\u00adenriched)category ofC. An e.ect observation ofa monad T on C0 bya Pre-enrichedmonadS \non C is a monadmorphism a : T . S0, where S0 is the underlying ordinary monad on C0. Theorem 3.9 Under \nthe above C and an e.ect observation a : T . S0, the following E is a preordered monoid, and D is a parametric \nE-monad on C0. E = (C(1,S1), :1,S1, .S 1, .fg. g #S . f) DeI = (a1 .T!I). e Example 3.10 We derive a \nparametric e.ect monad whose e.ects can capture the behaviour of non-terminating programs. We con\u00adsider \nthe computational e.ect of divergence and bell ringing, and represent it bya monad on ADCPO, the categoryofalgebraic \nDC-POs and all continuous functions between them. This category is Pos-enriched, has a terminal object \n1 and has the comma object of the form (4). It is also closed under the lower powerdomain con\u00adstruction \n(see e.g. [1]). We use the lazy counter monad, which is denoted by B in this example, to represent divergence \nand bell ringing. The ADCPO BI is given as the least solution of the recursive domain equation X . (I \n+ X)., and its Hasse diagram is depicted below (in the diagram, i ranges over I, and x . y means x = \ny): (0,i) (1,i) (2, i) \u00b7 \u00b7 \u00b7 BI = \u00b5Y.(I + Y). 0. 1. 2. \u00b7 \u00b7 \u00b7 8. Each element in BI denotes a phenomenon \nthat may happen by executing a program. An element x. (x . N) stands for the phenomenon that the program \nrings the bell x times and it is stillrunning . The element 8. stands for the phenomenon that x. holds \nfor . ...... all x . N . Thus the program rings the bell forever. The element (x,i)stands for the phenomenon \nthat the program rings the bell x times, then it terminates and returns a value i . Especially, when \nI = 1, the element (x,*)stands for that the program rings the bell x times and terminates . The order \n= on these elements captures the implication relation between corresponding phenomena. . ...... The order \n(x,i)= x. re.ects that if a program terminates after ringing the bell x times, then the program is indeed \nrunning right after the x-th bell. . ...... The order x. = (x - 1). re.ects that if the phenomenon x. \nhappens then (x -1). also happens before the x-thbell. . ...... The phenomenon 0. always happens for \nany program because there is a silent moment right after the program starts. Thus 0. is the least element. \nWe next consider the composite functor Pl . B, where Pl is the lower powerdomain construction. The composite \nextends to a Pos\u00ad (i.e. locallymonotone)monad over the Pos-categoryADCPO. We then obtain a monad morphism \n.pl .B : B . Pl .B, to which we can apply Theorem 3.9. The carrier set of the partiallyordered monoid \nPl(B1)given by Theorem 3.9 is isomorphic to the full-sub poset C of (N . {8},= )\u00d7(P(N),.)consistingofpairs \n(k, X)suchthat X = k. Eachpair (k, X)encodes the following subset of B1 (below . x denotes the downset \nof x):  F(k, X)=. (k.). . (x,*), x.X and an e.ect (k, X) means that one of the phenomena in F(k, X) \nhappens. We note that (k, \u00d8) . C expresses the behaviour of pro\u00adgrams that never terminate. The unit \nof E is (0,{0}), and the multiplication is (k, X)\u00b7 (l,Y)= k . (x + l) ,{x + y|x . X,y . Y} . x.X We especiallyhave \n(k, \u00d8)\u00b7 (l,Y)= (k,\u00d8), correspondingto thatwhen the .rst expression of the sequential composition never \nterminates, the second expression willnever be executed, thus its e.ect willbe discarded. The parametric \nPl(B1)-monad byTheorem 3.9is the following. Withthe helper function . : BI . Pl(B1)de.ned by: .(x,i)= \n(x,{x}), .(x.)= (x, \u00d8) the parametric Pl(B1)-monad D is given by DeI = {x . BI |.(x). F(e)}. 4. Algebraic \nOperations for Parametric E.ect Monads We extend Plotkin and Power s algebraic operations introduced \nin [30]to strong parametric e.ect monads. A straightforward exten\u00adsion is the following: De.nition 4.1 \nLet E be a preordered monoid and T be an strong parametric E-monad on a CCC C. For I, J . C and e . E, \nan (I, J, e)-ary algebraic operation for T is a family of morphisms ae ' ,K : J . Te ' K . I . T(ee ' \n)K, natural on e ' , such that for any f : L\u00d7 K . Te '' M, the followingsquare commute:  J.f# . . ' \n'' )M L\u00d7 (J . Te ' K) c J . (L\u00d7 Te ' K) J . T(e e L\u00d7ae,K ae,M t t . . ' '' )M L\u00d7 (I . T(ee ' )K) c I \n. (L\u00d7 T(ee ' )K) I . T(ee e I.f# For n . N and e . E, an (n,e)-ary algebraic operation is similarly de.ned \nby replacing J . - with (-)n and I . - with Id in the above diagram. An easycalculation shows that (I, \nJ,e)-aryalgebraic operations for T bijectivelycorrespond to morphisms oftype I . TeJ. This is an analogue \nof the correspondence between algebraic operations and generic e.ects stated in [30]. 4.1 Algebraic \nOperations with Di.erent E.ect Arguments The above extension of algebraic operations is natural, but \nnot satisfactory in some situations. The reason is twofold: 1)a single e.ect e may not be precise enough \nto capture the e.ect of an algebraic operation, and2)the arguments ofan algebraic operation has to have \nthe same e.ect. Let us see these problems with the parametric Cv(S*)-monad D over the distribution monad \nDs in Example 3.8. We consider restrictingthe domain andthe codomain of.p to obtain a (2, e ' )-ary algebraic \noperation for D. Following De.nition 4.1, it is a certain familyof functions of the followingtype: .p,I \n: DeI \u00d7 DeI . D(e ' e)I. What is an appropriate choice for e ' ? Actually 1 = {{o : 1}} is the the best. \nSince the choice operator itself does not output any string, ife ' contains some output strings with \nnon-zero probability, then it introduces garbage to the estimation of output strings. We then realise \nthat the e.ect 1 does not describe the behaviour of the computational e.ect .p. Even if we accept e ' \n= 1, we have another unsatisfactory point in usingthe algebraic operation ofthe above type. When supplying \ntwo computations c1 . De1I and c2 . De2I having di.erent e.ects to .p,I, we .rst need to align their \ne.ects to, for example, c1,c2 . D(e1 . e2)I. Then the probabilistic choice of them yields the computation \nc1 .p,I c2 . D(e1 . e2)I, but this is too rough; for instance even when p = 0(i.e. discardingthe left \nargument)the e.ect ofthe leftcomputation survives after the probabilistic choice. Our solution to these \nproblems is to allow the e.ects in the argument position of algebraic operations to be di.erent with \neach other. For instance, in the context of Example 3.8, we give the followingdomain and codomain to \n.p: (.p)e1,e2,I : De1I \u00d7 De2I . D(e1 .p,S* e2)I (5) so that the e.ect can say more precisely how argument \ne.ects are processedbythe algebraic operation. We formalise this idea below. De.nition 4.2 LetE = (E, \n:,1,\u00b7)be a preorderedmonoidandT be an strongparametric E-monadon a categoryC with.nite products. 1. An \nn-arye.ect function on E is a functor o : En . E such that '' ' o(e1,\u00b7 \u00b7 \u00b7 ,en)\u00b7 e = o(e1e , \u00b7 \u00b7 \u00b7 , \nene ). ' '' Below we abbreviate the sequence e1e ,\u00b7 \u00b7 \u00b7 ,ene to .ee . 2. Let o be an n-ary e.ect function \non E. An (n, o)-ary algebraic operation for T is a familyof morphisms ae1,\u00b7\u00b7\u00b7 ,en,I : Te1I \u00d7 \u00b7 \u00b7 \u00b7 \u00d7 \nTenI . T(o(e1,\u00b7 \u00b7 \u00b7 ,en))I, whichis naturalon e1,\u00b7 \u00b7 \u00b7 ,en . E, suchthat for any f : K\u00d7I . Te ' J, the \nfollowing diagram commute: ' (K\u00d7pi)n O fei#e O i=1 . O. O K \u00d7 TeiI (K \u00d7 TeiI) T(eie ' )J a.' K\u00d7a.e,I \nee ,I t t . K \u00d7 T(o(.e))I T(o(.e)e ' )J T(o(.ee ' ))J ' fo(.e)#e In the above diagram, fe#e ' : K \u00d7 \nTeI . T(ee ' )J is the parametrised Kleisliliftingof f using the strength of T. Currently, it is not \nclear how to extend the arity in the above de.nition to arbitrary objects in C. This technical limitation \nalso a.ects the design of e.ect systems in Section 5; there, algebraic operations in e.ect systems are \nclassi.ed into two groups, one corresponding to De.nition 4.1 and the other corresponding to the above \nde.nition. We gave a construction of the parametric e.ect monad D from an e.ect observation a : T . (S,.)in \nTheorem 3.3. We next show that every n-ary algebraic operation a for T can be restricted to an (n,o)-ary \nalgebraic operation for D, where o is constructed from a anda. Recallthat the monad morphism amaps the \nn-aryalgebraic operation a for T to the one for S. We denote it bya(a). Theorem 4.3 Let a : T . (S, .) \nbe an e.ect observation of a monad T on Set, and a be an n-ary algebraic operation for T. We write D \nfor the parametric e.ect monad derived from the e.ect observation aby Theorem 3.3. 1. Function a(a)1 \n: (S1)n . S1 is an n-ary e.ect function on S1. 2. Each aI restricts to a function of the following type: \n aI : De1I \u00d7 \u00b7 \u00b7 \u00b7 DenI . D(a(a)1(e1,\u00b7 \u00b7 \u00b7 ,en))I, and this is an (n,a(a)1)-ary algebraic operation \nfor D. Example 4.4 (Continued from Example 3.8) From Theorem 4.3, the binary algebraic operation .p for \nDs . Wr restricts to an (2,.p,S* )-ary algebraic operation for the parametric e.ect monad in Example \n3.8. Example 4.5 Let Sbe a .rst-order single-sortedsignature (without equational axioms)and TS be the \nmonad of free S-algebra. There always exists a distributive law TS .P . P .TS, andwe obtain the e.ect \nobservation . : TS . (P .TS,.). De.nition 3.2appliedto this situation yields the preorderedmonoid P(TS(1)). \nThe parametric P(TS(1))-monad D of Theorem 3.3 is DeI = {t . TSI |t[*/i]i.I . e}. Each term t . TS{1,\u00b7 \n\u00b7 \u00b7 ,n} gives the following n-ary algebraic operation at for TS: (at)I(t1,..,tn)= t[ti/i]n i=1. Theorem \n4.3 associates to this algebraic operation the following e.ect function on P(TS(1)): a(at)1(e1,\u00b7 \u00b7 \u00b7 \n,en)= {t[ti/i]n i=1 |ti . ei} and at restricts to the following (n, a(at)1)-ary algebraic operation for \nD: (at)I : De1I \u00d7 \u00b7 \u00b7 \u00b7 \u00d7 DenI . D{t[ti/i]n | ei}I. i=1 ti .  5. EFe/EFi: Simply-Typed Monomorphic E.ect \nSystems with E.ect Subtyping We introduce two simply typed monomorphic e.ect systems, EFe and EFi. These \ntwo systems di.er in handling e.ect subtyping. Both styles are adopted in many works. For instance, \nThe calculus EFe adopts explicit sube.ecting by e.ect coercion operators Te:e ' . This language is close \nto the one considered in Fillinski s M3L [9], where the point we can up-cast e.ect\u00adannotated types is \nlimited to let expressions. Another example of the e.ect system that adopts explicit sube.ecting is [13]. \n The calculus EFi adopts implicit sube.ecting. Subjects of EFi judgements are .ML-terms, and the sube.ecting \nrule does not change subjects of judgements. Each type of EFi is a re.nement of its underlying .ML-type. \nSee e.g. [4, 8].  These systems are speci.ed by an EF-signature. We de.ne the set GTyp(B)of ground types \ngenerated from Bby the following BNF: GTyp(B). \u00df ::= b |O(\u00df, \u00b7 \u00b7 \u00b7 , \u00df)|U(\u00df, \u00b7 \u00b7 \u00b7 , \u00df) (b . B). n We \nwrite 1 for O() and n for U(1,\u00b7 \u00b7 \u00b7 ,1). De.nition 5.1 An EF-signature S consists of the following data: \n1. A preordered monoid E = (E, :,1, \u00b7). 2. A set Bof base types. 3. A set O of symbols for algebraic \noperations. 4. A function giving arities to algebraic operation symbols:  s : O . H(GTyp(B)2 \u00d7 E) + \nI{(n, o)|n . N, o : n-ary e.ect function on E}. The arity H(\u00df, \u00df ' , e) and I(n, o) are given to the \nalgebraic oper\u00adations in the style of De.nition 4.1 and 4.2, respectively. Every EF-signature S = (E, \nB,O, s) determines an .ML-signature S0 = (B,O, s ' ) by discarding the e.ect information from s. Throughout \nthis section, we use a .xed EF-signature S = (E, B,O, s) with E = (E, :,1, \u00b7). Both calculi EFe(S) and \nEFi(S) share the same set TypEF(S)of types de.ned as follows: TypEF(S). t ::= b |O(t, \u00b7 \u00b7 \u00b7 , t)|U(t, \n\u00b7 \u00b7 \u00b7 , t)|t . t|T(e, t) (b . B,e . E). We de.ne the erasure function |- | : TypEF(S) . TypML (S0)by \nthe one that recursively replaces T(e, t)by T|t|. We extend | - | to typing contexts in the canonical \nway. 5.1 Explicit Sube.ecting Calculus EFe(S) The calculus EFe(S)extends the simply typed lambda calculus \nwith products and coproducts with the following raw terms: t Te:e [M], lete,e ' x be M in N, ' M, o(M), \no(M,\u00b7 \u00b7 \u00b7 , M) The .rst two are parametric analogues of pure-computation con\u00adstructors and let expressions \nin .ML. The third one is the (e.ect) coercion operator. The last two are the syntax for algebraic opera\u00adtions. \nThe typing rules are displayed in Figure 1. The equational the\u00adory of EFe(S)extends the \u00df.-equational \ntheory for the simply typed lambda calculus with products and coproducts by the equational ax\u00adioms displayed \nin Figure 2. The axioms (6) and (7) guarantee the functoriality of T(-, t). The axioms (8)-(12) are a \nsyntax represen\u00adtation of the axioms of parametric e.ect Kleisli triple (De.nition 2.3). The axioms (13) \nand (14) guarantee that each o . O behave as an algebraic operation for T. The axiom (13) is for the \nsymbol o . O such that s(o)= H(\u00df, \u00df ' ,e), while (14) is for o . O such that s(o)= I(n, o). The semantics \nof EFe(S) is speci.ed by an EFe(S)-structure. De.nition 5.2 An EFe(S)-structure consists of the following \ndata. 1. A bi-CCC C and an strong parametric E-monad T on C. 2. An object [b] . C for each b . B. We \nextend this assignment of C-objects to base types to ground types GTyp( B) (see Pre\u00adliminaries section) \nusing the bi-cartesian structure on C in the canonical way. 3. A ([\u00df],[\u00df ' ],e)-ary algebraic operation \n[o] for T, for each  o . O such that s(o)= H(\u00df, \u00df ' ,e). 4. An (n, o)-ary algebraic operation [o] for \nT, for each o . Osuch that s(o)= I(n, o). Interpretations of EFe(S)-types and terms are straightforward. \nTheorem 5.3 Let (C,T,[-]) be an EFe(S)-structure. For every EFe(S)-judgements G . M, N : t, if M = N \nholds in the equational theory of EFe(S), then we have [M] = [N].  5.2 Implicit Sube.ecting Calculus \nEFi(S) The implicit sube.ecting calculus EFi(S) is designed to be a re\u00ad.nement type system for the computational \nmetalanguage .ML(S0). The subject M of an EFi(S)-judgement G . M : t is an .ML(S0)\u00adterm. Thus raw terms \ndo not contain coercion operators Te:e ' , and e.ect annotations on let expressions are removed. Variable \nbinders are also annotated with .ML(S0)-types instead of EFi(S)-types. Proposition 5.4 If G . M : tthen \n|G| .ML M : |t|. We move to the semantics of EFi(S). The basic idea of re.ne\u00adment type is that each re.nement \ntype t speci.es a certain part, or a predicate, of its underlying type |t|. To model this idea, we em\u00adploy \na categorical setting that provides the concept of predicate on objects in a category. Asimple setting \nto talk about predicates on objects in a category C is to consider a faithful functor p : P . C. We then \nregard: P as the category of predicates on objects in C,  pX = I as X . P is a predicate over I . C \n,  p(f.: X . Y)= f : I . J as f-image of X is included by Y , and the morphism f.as the unique witness \nof this statement.  Below, for objects X,Y . P and a morphism f : pX . pY in C, by f : X ..Y we mean \nthe statement there exists a unique f. : X . Y in P such that pf. = f . From the above viewpoint, idI \n: X ..Y corresponds to X implies Y for predicates X,Y over I . C. Thus the category consisting of objects \nX such that pX = I and morphisms f.such that p(f.)= idI may be seen as the preorder of predicates on \nI. We name this category PI, and call it the .bre category over I. Besides, there are products, coproducts, \narrow types and e.ect\u00adannotated monadic types on re.nement types; we thus assume that P is a bi-CCC, \nand that a parametric e.ect monad T.is given on P. The introduction and elimination of these type structures \nare synchronised with those of the underlying .ML-types. We capture this situation by that p strictly \npreserves the bi-CC structure on P, and maps T.to T (see De.nition 2.6). The following two de.nitions \nsummarises the above discussion. De.nition 5.5 Let .be a .ML-signature. An .ML(.)-structure with predicates \nconsists of the following data. 1. A.ML(.)-structure (C,T, [-]). 2. A bi-CCC P. We denote the bi-CC \nstructure with a dot, like \u00d7.,+.,..,p, .\u00b7 \u00b7 \u00b7 . 3. A faithful functor p : P . C such that p strictly \npreserves the bi-CC structure, and each PI has the largest element .I.   |t|) The common typing rules \nfor EFe(S)and EFi(S) (in EFi(S)the type annotation x t at a variable binder is replaced by x O G . Mi \n: ti 1 = i = n G . M : (t1,\u00b7 \u00b7 \u00b7 , tn) 1 = i = n G . (M1, \u00b7 \u00b7 \u00b7 , Mn): O(t1,\u00b7 \u00b7 \u00b7 , tn) G . pi M : ti \nU G . M : ti 1 G . M : (t1, , tn) G, xi : ti . Mi : t 1 = i = = i = n \u00b7 \u00b7 \u00b7 n Ut1 tn G . .i M : (t1,\u00b7 \n\u00b7 \u00b7 , tn) G . case M with .1 x1 . M1,\u00b7 \u00b7 \u00b7 , .n xn . Mn : t G, x : t . M : t ' G . M : t . t ' G . N \n: t t . t ' G . .x . M : t G . MN : t ' G . M : \u00df ' . T(e ' , t) s(o)= H(\u00df, \u00df ' ,e) G . M1 : T(e1, t) \n\u00b7 \u00b7 \u00b7 G . Mn : T(en, t) s(o)= I(n, o) G . o(M): \u00df . T(ee ' , t) G . o(M1,\u00b7 \u00b7 \u00b7 , Mn): T(o(e1, \u00b7 \u00b7 \u00b7 , \nen), t) Typing rules speci.c to EFe(S) ' G . M : T(e, t) e = e G . M : T(e, t) G, x : t . N : T(e ' \n, t ' ) G . Te=e ' M : T(e ' , t) G . lete,e ' x t be M in N : T(e \u00b7 e ' , t ' ) Typing rules speci.c \nto EFi(S) G . M : T(e, t) e = e G . M : T(e, t) G, x : t . N : T(e ' , t ' ) ' G . M : T(e ' , t) G \n. let x|t| be M in N : T(e \u00b7 e ' , t ' ) G . [M]: T(1, t) Figure 1. Typing Rules of EFe(S)and EFi(S) \nTe:e M = M (6) ' '' ' '' Te :e (Te:e M) = Te:e M (7) ,e t Tee :e e t ' '' ' '' ' '' '' lete x be Te:e \nM in N = (lete,e x be M in N) (8) '' ' ' '' '' ' '' ,e t e:e e ,e t lete x be M in Te:e N = Te (lete \nx be M in N) (9) let1,e x t be [M]in N = N[M/x] (10) t lete,1 x be M in [x] = M (11) ' '' ' '' ' '' \n' e t ,e s ,e s t lete,e x be M in lete y be N in L = letee y be (lete,e x be M in N)in L (12) ' '' ' \n'' ,e t \u00df,e t letee x be o(M)N in L = o(.y . lete x be M y in L)N (s(o)= H(\u00df, \u00df ' , e)) (13) ' '' ,en),e \nt tt leto(e1,\u00b7\u00b7\u00b7 x be o(M1, \u00b7 \u00b7 \u00b7 , Mn)in N = o(lete1,e x be M1 in N,\u00b7 \u00b7 \u00b7 ,leten,e x be Mn in N) (s(o)= \nI(n, o)) (14) Figure 2. Equational Axioms for EFe(S) The notation for a .ML(.)-structure with predicates \nis p : P . (C,T,[-]). We note that the largest element .I in the .bre PI corresponds to I itself in P, \nor the predicate true. De.nition 5.6 An EFi(S)-structure is a pair of a .ML(S0)-structure p : P . (C,T,[-]) \nwith predicates and a strong parametric E\u00admonad T.on P such that 1. The functor p maps T.to T (see De.nition \n2.6). 2. For each o . O such that s(o)= H(\u00df, \u00df ' , e), the ([\u00df],[\u00df ' ])-ary algebraic operation [o] \nfor T satis.es: for all e ' . E, X . P,  [o]pX : .[\u00df ' ] ..T e .' . .[\u00df] . . X ..T(ee ' )X. 3. For each \no . O such that s(o) = I(n, o), the n-ary algebraic operation [o] for T satis.es: for all e1,\u00b7 \u00b7 \u00b7 ,en \n. E, X . P, [o]pX : .\u00d7 \u00b7 \u00b7 \u00b7 .Ten . .\u00b7 \u00b7 \u00b7 ))X. Te1X .\u00d7 .X .T(o(e1, ,en The notation for an EFi(S)-structure \nis p : (P,T). (C,T,[-]). .Given an EFi(S)-structure p : (P,T) . (C,T,[-]), we interpret .the calculus \nEFi(S)as follows. We interpret each type t . TypEF(S) by an object (t). P: (b) = .[b] O (O(t1,\u00b7 \u00b7 \u00b7 , \ntn)) = .((t1),\u00b7 \u00b7 \u00b7 ,(tn)) U (U(t1,\u00b7 \u00b7 \u00b7 , tn)) = .((t1),\u00b7 \u00b7 \u00b7 ,(tn)) (t . t ' ) = (t) .) .(t ' (T et) \n= Te(t). . We have p(t)= [|t|], thus re.nement types are indeed interpreted by a predicate over [|t|]. \nWe then show that the interpretation of the underlying .ML(S0)-judgement of an EFi(S)-judgement respects \nthe predicates given by re.nement types. .For all EFi(S)-judgements x : t1,\u00b7 \u00b7 \u00b7 , xn : tn . M : t, the \ninterpretation of the .ML(S0)-judgement x : |t1|,\u00b7 \u00b7 \u00b7 , xn : |tn|. M : |t|(which is derivable by Proposition \n5.4) in the .ML(S0)-structure (C,T,[-])satis.es: Theorem 5.7 Let p : (P,T). (C,T,[-])be an EFi(S)-structure. \n[M] : (t1) .\u00b7 \u00b7 \u00b7 \u00d7 (tn . (t). \u00d7 .) .  5.3 Soundness of EFi to E.ect Speci.cations We next discuss the \nsoundness of EFi with respect to e.ect spec\u00adi.cations. Recall that the primary purpose of e.ect system \nis to statically estimate computational e.ects caused by programs. To show the soundness of the estimation, \nwe .rst need to specify the meaning, that is, the scope of computational e.ects, of each e.ect. Then \nthe soundness ofan e.ect system is that for everyprogram M having an e.ect e, the computational e.ect \nof M is included in the scope assigned to e.  In our semantic framework, this discussion is roughly \nformu\u00adlated as follows. Let p : P . (C,T,[-])be a .ML(S0)-structure with predicates. We specify the meaning \nof each e.ect e as a P\u00adobject Sbe above T[b]; here b is a base type. We then say that EFi(S)is sound \nwith respect to the speci.cation S of e.ects if for all judgements M : T(e,b)in EFi, [M] . Sbe. We actually \nallow certain type of free variables to occur in M. De.nition 5.8 Let p : P . (C,T,[-]) be a .ML(S0)-structure \nwith predicates. An e.ect speci.cation of S in p is just a family of functors (i.e. monotone mappings){Sb \n: E . PT[b]}b.B. De.nition 5.9 Let p : P . (C,T, [-])be a .ML(S0)-structure with predicates and S be \nan e.ect speci.cation of S in p. We say that EFi(S)is: 1. rank-0 sound with respect to S iffor allEFi(S)-judgements \nx1 : b1,\u00b7 \u00b7 \u00b7 , xn : bn . M : T(e,b), the interpretation [M] of its .ML(S0)-judgement in (C,T, [-]) satis.es \n[M] : .[b1] .\u00b7 \u00b7 \u00b7 \u00d7 .[bn] ..Sbe.\u00d7 . 2. rank-1 sound with respect to S iffor allEFi(S)-judgements x1 \n: \u00df1 . T(e1,b1),\u00b7 \u00b7 \u00b7 , xn : \u00dfn . T(en,bn). M : \u00df . T(e,b), the interpretation [M] of its .ML(S0)-judgement \nsatis.es On [M] : .i=1(.[\u00dfi] ..Sbiei)..(.[\u00df] ..Sbe). Below, by imposing a mild condition on the faithful \nfunctor p : P . C of a .ML-structure with predicates, we show that the soundness ofEFiis derivable from \n(a combination of)the following closure properties on e.ect speci.cations. De.nition 5.10 (Continued \nfrom De.nition 5.8)We saythat: S is closed under algebraic operations in S if it satis.es the followingtwo \nsub-conditions: A)For each o . O such that s(o)= H(\u00df,\u00df ' ,e), the ([\u00df],[\u00df ' ])\u00adaryalgebraic operation \n[o] for T satis.es: for alle ' . E,b . B, [o][b] : .[\u00df ' ] .Sbe ' ..[\u00df] ..Sb(ee ' ..). B)For each o . \nO such that s(o) = I(n,o), the n-ary algebraic operation [o] for T satis.es: for alle1,\u00b7 \u00b7 \u00b7 ,en . E,b \n. B, [o][b] : O.in =1Sbei ..Sb(o(e1,\u00b7 \u00b7 \u00b7 ,en)). S contains values if for all b . B, .[b] : .[b] ..Sb1. \n S is closed under liftingifthe unit  sT,R I : TI . (I . TR). TR of the continuation monad transformer \n[5] satis.es: for all e,e ' . E,b, b ' . B, sT,[b ' ] ' ' [b] : Sbe ..(.[b] ..Sb ' e )..Sb ' (ee ). The \ncondition we impose on pis that: pis a .bration with.bred small products. Such .brations are often used \nin the categorical formulation oflogical relations;see [11, 15]. Under this condition, we can construct \na strong parametric E-monad on P from e.ect speci.cations. It is a variation of the categorical..-liftingin \n[14]. The construction proceeds as follows. Let p : P . (C,T, [-]) be a .ML(S0)-structure with predicates \nsuch that p : P . C is a .bration with .bred small products. Also, let S be an e.ect speci.cation of \nS in p. For each X . P, we .rst de.ne an auxiliary T.e ' P-object ' ,beX (e,e . E,b . B)by the following \ninverse image in the .bration p: T.e ' . ' ) .' ) (X ..Sbe .Sb(ee P,beX p t . T(pX) (pX . T[b]). T[b] \nT,[b] s pX (see also Example 2.11). We then de.ne T.S eX to be the following smallproduct (i.e. meet)in \nthe .bre category PT(pX): . ' T.S T.e ,b eX = eX. e ' .E,b.B Theorem 5.11 Let p : P . (C,T, [-]) be a \n.ML(S0)-structure withpredicates suchthat pis a .bration with.bredsmallproducts. Also, let S be an e.ect \nspeci.cation of S in p. 1. T.S is a strong parametric E-monad on P, and pmaps T.S to T. 2. If S is closed \nunder algebraic operations, then we have an EFi(S)-structure p : (P,T.S ). (C,T,[-]). 3. If S is closed \nunder algebraic operations and contains values, then EFi(S)is rank-0 sound with respect to S. 4. S is \nclosed under algebraic operations, contains values and is closed under lifting if and only if EFi(S)is \nrank-1 sound with respect to S.  Theorem 5.11-3 is a parametric analogue of [15, Theorem 7]. Example \n5.12 Let . = (B,O, s)be a .ML-signature, (Set,T,[-]) be a .ML(.)-structure and a : T . (S,.) be an e.ect \nobserva\u00adtion. We assume that . contains onlynatural number-aryalgebraic operations. The subobject .bration \np : Sub(Set) . Set (see[11, Chapter 0])provides the data 2 and 3 of De.nition 5.5, and has .\u00adbred small \nproducts. Therefore p : Sub(Set) . (Set,T,[-])is a .ML(.)-structure with predicates. We next derive an \nEF-signature S. = (S1, B,O, s ' )where s ' is de.ned by s ' (o)= (n, a([o])1) (s(o)= I(n)). This s ' \nassigns the e.ect function to each operator symbol in O by Theorem 4.3-1. We give an e.ect speci.cation \nS of S. in p by means of the parametric e.ect monad D derived by Theorem 3.3: Sbe = (De[b] . T[b]). This \nis closed under algebraic operations in S. thanks to Theorem 4.3-2, and moreover S contains values and \nis closed under lifting because D is a parametric e.ect monad. By Theorem 5.11-4, EFi(S)is rank-1 sound \nwith respect to S, that is, for everyEFi(S.)-judgement x1 : \u00df1 . T(e1,b1),\u00b7 \u00b7 \u00b7 , xn : \u00dfn . T(en,bn). \nM : \u00df . T(e,b), the interpretation [M] of its .ML(.)-judgement in (Set,T,[-]) satis.es: for all functions \nfi : [\u00dfi] . Dei[bi] and x . [\u00df ' ], we have [M]{x1 : f1,\u00b7 \u00b7 \u00b7 , xn : fn}(x). De ' [b ' ]. 6. Related \nWork 6.1 E.ectors and Productors Tate introduceda semantic structure callede.ectors andproductors in \n[33]as a solution to Problem 1.1 and 1.2. Through a characteri\u00adsation ofe.ectors /productors in terms \nofmulticategorytheory, we show that parametric e.ect monads are productors on total princi\u00adpallede.ectoids. \nAgoodreference for multicategorytheoryis [20]. Let us write MultCAT for the (super-large)category of \nmulti\u00adcategories and maps between them. There is an adjunction relating multicategories and strict monoidal \ncategories [20, Section 2.3]:  U . StrictMonCAT - . MultCAT F The right adjoint U maps a strict monoidal \ncategory (C,I,.)to its underlying multicategory UC [20, Example 2.1.3]. It has the same objects as C, \nand its homsets are de.ned by (UC)([I1,\u00b7 \u00b7 \u00b7 , In], J)= C(I1 .\u00b7 \u00b7 \u00b7 . In, J). The functor U preserves \nthinness. We also mention a relationship between lax monoidalfunctors andmaps for multicategories, stated \nas Example 2.1.10in [20]. For eachstrict monoidal categoryB and D, we have the following bijection: LaxMonCAT(B,D). \nMultCAT(UB,UD). (15) We omit the de.nition ofe.ectors andproductors;see [33, Sec\u00adtion 5&#38;6]. We give \nthe followingmulticategoricalcharacterisation of e.ectors and productors: Theorem 6.1 1. [33, Section \n9] E.ectors bijectively correspond to thin small multicategories. (Below we identify these two concepts.) \n2. Let F be an e.ector. Then F-productors bijectively correspond to maps (for multicategories)of type \nF . U[C,C]. For a preordered monoid E, UE is an e.ector called total prin\u00adcipalled e.ectoid [33, Section \n9]. The following proposition is a consequence of (15): Proposition 6.2 Let E be a preordered monoid. \nThen paramet\u00adric E-monads on a category C bijectively correspond to UE\u00adproductors on C. We end this section \nwith the discussion about the uni.cation of productors and parametric e.ect monads. Let F be an e.ec\u00adtor. \nUsing the adjunction F . U and the inclusion of categories StrictMonCAT . LaxMonCAT, we obtain MultiCAT(F,U[C,C]) \n. StrictMonCAT(FF, [C,C]) . LaxMonCAT(FF,[C,C]). We note that FF is not thin in general. This suggests \nthat productors can be encoded by general parametric monads [25].  6.2 Actions of Monoidal Categories \nParametric e.ect monads are an instance of the broader concept of action of monoidal categories. Depending \non the degree of the preservation of monoidal structure, there are several variations of this concept, \neach of which corresponds to strong, lax and oplax monoidal functors oftype M . [C,C]. In mathematics, \na category equipped with a strong action of a monoidal category is sometimes called an actegory (not \na typo!), and studied in e.g. [17]. In Levy s call-by-push-value, a strong action ofa categorywith.nite \nproducts is usedas a part ofa CBPV value /producer model [21]. Parametric e.ect monads are exactly lax \nactions of preordered monoids. Lax actions of general monoidal categories are called parametric monads \nin [25]andnegative M-categories in [24]. They are introduced to give a uni.ed account of the tensorial \nstrength of the continuation monad and the weak distributive law in linear logic. The categorical analysis \nof parametric monads in [24, 25] are readily applicable to parametric e.ect monads. Especially, the concept \nof commutator for parametric monads in [25]willprovide a method to synthesise parametric e.ect monads, \nhence e.ect sys\u00adtems as well. Compared to [24, 25], this paper provides new exam\u00adples and constructions \nof parametric (e.ect)monads arising from the study of a semantics of e.ect system. We note that parametric \ne.ect Kleisli triples and the parametric state /continuation monad can be de.ned for general monoidal \ncategories. Recently, Petricek et al. study oplax actions of monoids to categories under the name indexed \ncomonad [29, De.nition 2]. Althoughtheyare the dualofparametric e.ect monads, the spiritof their workis \nveryclose to this work. It is interestingto see whether we can dualise the construction of parametric \ne.ect monads using e.ect observations. We .nally mention a possible generalisation of parametric (ef\u00adfect)monads. \nA monoidal category M and a lax monoidal functor oftype M . [C,C]bijectivelycorresponds to the one-object \nbicat\u00adegory BM and a lax functor of type BM . B[C,C], respectively. This shift to the bicategory theory \nsuggests us to take a bicategory E and a lax functor of type E . B[C,C] as a generalisation of the monoid \nstructure on e.ects and the parametric e.ect monad. An e.ect is now a 1-cell e : X . Y in E, and a parametric \ne.ect monad is indexed by the domain and codomain of e, like TX,Y(e). A future work is to examine whether \nwe can extend the techniques developed in this paper to bicategorical parametric monads. 6.3 Parameterised \nMoands Atkey s parameterised monads [2] are another generalisation of monads. They seem to be fundamentally \ndi.erent from parametric e.ect monads. To exhibit this di.erence, we recall that one-object [C,C]-enriched \ncategories are monads on C. Thus [C,C]-enriched categories are a generalisation of monads; they correspond \nto dis\u00adcretely parameterised monads. Parameterisedmonads are a further generalisation ofsuch enriched \ncategories. Tate shows an encoding of preorder-parameterised monads as productors [33, Section 7]. At \nthis moment we do not know if it is possible to directly encode parameterised monads as parametric e.ect \nmonads.  6.4 Denotational Semantics of E.ect Systems The implicit sube.ectingsystem and its denotational \nsemantics are used in the study of e.ect-dependent program optimisation [4, 6 8]. The semantic frameworkwe \nintroducedin De.nition 5.5and5.6 is in.uenced by these works, which use PER-like categories as the categories \nofpredicates. Theymanuallyconstruct the denotation of e.ect-annotatedmonadic types on the categoryofpredicates, \nwhile in this paper we give a mechanical method to construct parametric e.ect monads bya variant of the \nsemantic ..-lifting. 7. Conclusion Under the formulation of preordered monoids as a structure on ef\u00adfects \nand parametric e.ect monads as a semantic structure for the e.ect-annotated monadic type, we studied \ntheir properties, con\u00adstructions andapplications to the semantics ofe.ect systems. Para\u00admetric e.ect \nmonads admit various analogues ofthe structures that exist in the theory of monad. We gave a construction \nof parametric e.ect monads from e.ect observations, and semantics of implicit sube.ecting calculus EFi. \nWe then discussed the soundness of EFi withrespect to a given speci.cation of e.ects. Afuture workis \nto extendthe arityofDe.nition 4.2to arbitrary objects so that we can handle freshname creations andlocalstores. \nIt is also interesting to extend the construction in Theorem 3.3 to the one over a general categoryC. \nAcknowledgment Thanks to Masahito Hasegawa, Susumu Nishimura, Paul-Andr\u00b4e Melli`es, Marco Gaboardi and \nanonymous reviewers for their help\u00adfulcomments andsuggestions on this paper. Additionally, thanks to \nKoheiSuenaga for an insightfuldiscussion in Tanakaya. This work was supported by JSPSKAKENHIGrant Number \n24700012.  References [1] R. M. Amadio and P.-L. Curien. Domains and lambda-calculi. Cam\u00adbridge University \nPress, New York, NY, USA, 1998. [2] R. Atkey. Parameterised notions of computation. J. Funct. Program., \n19(3-4):335 376, 2009. [3] G. Barthe, P. Dybjer, L. Pinto, and J. Saraiva, editors. Applied Seman\u00adtics, \nInternational Summer School, APPSEM 2000, Caminha, Portu\u00adgal, September 9-15, 2000, Advanced Lectures, \nvolume 2395 of LNCS. Springer, 2002. [4] N. Benton and P. Buchlovsky. Semantics of an e.ect analysis \nfor exceptions. In Proceedings of 2007 ACM SIGPLAN International Workshop on Types in Languages Design \nand Implementation, pages 15 26. ACM, 2007. [5] N. Benton, J. Hughes, and E. Moggi. Monads and e.ects. \nIn Barthe et al. [3], pages 42 122. [6] N. Benton, A. Kennedy, L. Beringer, and M. Hofmann. Relational \nsemantics for e.ect-based program transformations with dynamic al\u00adlocation. In Proceedings of the 9th \nInternational ACM SIGPLAN Conference on Principles and Practice of Declarative Programming, pages 87 \n96. ACM, 2007. [7] N. Benton, A. Kennedy, L. Beringer, and M. Hofmann. Relational se\u00admantics for e.ect-based \nprogram transformations: higher-order store. In Proceedings of the 11th International ACM SIGPLAN Conference \non Principles and Practice of Declarative Programming, pages 301 312. ACM, 2009. [8] N. Benton, A. Kennedy, \nM. Hofmann, and L. Beringer. Reading, writing and relations. In Programming Languages and Systems, 4th \nAsian Symposium, APLAS 2006, Proceedings, volume 4279 of LNCS, pages 114 130. Springer, 2006. [9] A. \nFilinski. Representing layered monads. In Proc. POPL 1999, pages 175 188, 1999. [10] J.-C. Filli atre. \nA theory of monads parameterized by e.ects. Research Report 1367, LRI, Universit\u00b4e Paris Sud, November \n1999. [11] B. Jacobs. Categorical Logic and Type Theory. Elsevier, 1999. [12] B. Jacobs. Coalgebraic \ntrace semantics for combined possibilitis\u00adtic and probabilistic systems. Electr. Notes Theor. Comput. \nSci., 203(5):131 152, 2008. [13] O. Kammar and G. D. Plotkin. Algebraic foundations for e.ect\u00addependent \noptimisations. In Proceedings of the 39th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, \npages 349 360. ACM, 2012. [14] S. Katsumata. A semantic formulation of ..-lifting and logical predicates \nfor computational metalanguage. In Proc. CSL 05, volume 3634 of LNCS, pages 87 102. Springer, 2005. [15] \nS. Katsumata. Relating computational e.ects by ..-lifting. Inf. Comput., 222:228 246, 2013. [16] S. Katsumata \nand T. Sato. Preorders on monads and coalgebraic simulations. In Foundations of Software Science and \nComputation Structures -16th International Conference, Proceedings, volume 7794 of LNCS, pages 145 160. \nSpringer, 2013. [17] G.M. Kelly and G. Janelidze. A note on actions of a monoidal category. Theory and \nApplications of Categories, 9(4):61 91, 2001. [18] A. Kock. Strong functors and monoidal monads. Archiv \nder Mathe\u00admatik, 23(1):113 120, 1972. [19] S. Lack and R. Street. The formal theory of monads ii. Journal \nof Pure and Applied Algebra, 175(1-3):243 265, 2002. [20] T. Leinster. Higher Operads, Higher Categories. \nLondon Mathemati\u00adcal Society Lecture Note Series. Cambridge University Press, 2004. [21] P. B. Levy. \nCall-by-Push-Value A Functiona/Imperative Synthesis. Springer, 2004. [22] J. M. Lucassen and D. K. Gi.ord. \nPolymorphic e.ect systems. In Proceedings of the 15th ACM SIGPLAN-SIGACT symposium on Prin\u00adciples of \nprogramming languages, pages 47 57. ACM, 1988. [23] S. MacLane. Categories for the Working Mathematician \n(Second Edition), volume 5 of Graduate Texts in Mathematics. Springer, 1998. [24] P.-A. Mellies. Parametric \nmonads and enriched adjunctions. Manuscript. [25] P.-A. Mellies. The parametric continuation monad. Mathematical \nStructures in Computer Science, Festschrift in honor of Corrado B\u00a8ohm for his 90th birthday, 2013. [26] \nE. Moggi. Notions of computation and monads. Inf. Comput., 93(1):55 92, 1991. [27] F. Nielson and H. \nR. Nielson. From CML to its process algebra. Theor. Comput. Sci., 155:179 219, February 1996. [28] F. \nNielson, H. R. Nielson, and C. Hankin. Principles of program analysis (2. corr. print). Springer, 2005. \n[29] T. Petricek, D. A. Orchard, and A. Mycroft. Coe.ects: Uni.ed static analysis of context-dependence. \nIn Automata, Languages, and Programming -40th International Colloquium, Proceedings, volume 7966 of LNCS, \npages 385 397. Springer, 2013. [30] G. Plotkin and J. Power. Algebraic operations and generic e.ects. \nApplied Categorical Structures, 11(1):69 94, 2003. [31] L. Solberg, H. R. Nielson, and F. Nielson. Strictness \nand totality analysis. In Static Analysis, volume 864 of LNCS, pages 408 422. Springer Berlin Heidelberg, \n1994. [32] J.-P. Talpin and P. Jouvelot. The type and e.ect discipline. Inf. Comput., 111(2):245 296, \n1994. [33] R. Tate. The sequential semantics of producer e.ect systems. In The 40th Annual ACM SIGPLAN-SIGACT \nSymposium on Principles of Programming Languages, pages 15 26. ACM, 2013. [34] J. Thamsborg and L. Birkedal. \nA kripke logical relation for e.ect\u00adbased program transformations. In Proceeding of the 16th ACM SIG-PLAN \nInternational Conference on Functional Programming, pages 445 456. ACM, 2011. [35] M. Tofte and J.-P. \nTalpin. Implementation of the typed call-by-value lambda-calculus using a stack of regions. In Proceedings \nof the 21st ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, pages 188 201, 1994. \n[36] D. Varacca and G. Winskel. Distributing probability over non\u00addeterminism. Mathematical Structures \nin Computer Science, 16(1):87 113, 2006. [37] P. Wadler. The marriage of e.ects and monads. In Proceedings \nof the third ACM SIGPLAN International Conference on Functional Programming (ICFP 98), pages 63 74. ACM, \n1998. [38] P. Wadler and P. Thiemann. The marriage of e.ects and monads. ACM Trans. Comput. Log., 4(1):1 \n32, 2003.     \n\t\t\t", "proc_id": "2535838", "abstract": "<p>We study fundamental properties of a generalisation of monad called <i>parametric effect monad</i>, and apply it to the interpretation of general effect systems whose effects have sequential composition operators. We show that parametric effect monads admit analogues of the structures and concepts that exist for monads, such as Kleisli triples, the state monad and the continuation monad, Plotkin and Power's algebraic operations, and the categorical &#9516;&#9516;-lifting. We also show a systematic method to generate both effects and a parametric effect monad from a monad morphism. Finally, we introduce two effect systems with explicit and implicit subeffecting, and discuss their denotational semantics and the soundness of effect systems.</p>", "authors": [{"name": "Shin-ya Katsumata", "author_profile_id": "81100315732", "affiliation": "Kyoto Univeristy, Kyoto, Japan", "person_id": "P4383922", "email_address": "sinya@kurims.kyoto-u.ac.jp", "orcid_id": ""}], "doi_number": "10.1145/2535838.2535846", "year": "2014", "article_id": "2535846", "conference": "POPL", "title": "Parametric effect monads and semantics of effect systems", "url": "http://dl.acm.org/citation.cfm?id=2535846"}