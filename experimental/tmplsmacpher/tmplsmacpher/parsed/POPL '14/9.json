{"article_publication_date": "01-08-2014", "fulltext": "\n An Operational and Axiomatic Semantics for Non-determinism and Sequence Points in C Robbert Krebbers \n* ICIS, Radboud University Nijmegen, The Netherlands mail@robbertkrebbers.nl Abstract The C11 standard \nof the C programming language does not specify the execution order of expressions. Besides, to make more \neffective optimizations possible (e.g. delaying of side-effects and interleav\u00ading), it gives compilers \nin certain cases the freedom to use even more behaviors than just those of all execution orders. Widely \nused C compilers actually exploit this freedom given by the C standard for optimizations, so it should \nbe taken seriously in formal veri.cation. This paper presents an operational and ax\u00adiomatic semantics \n(based on separation logic) for non-determinism and sequence points in C. We prove soundness of our axiomatic \nse\u00admantics with respect to our operational semantics. This proof has been fully formalized using the \nCoq proof assistant. Categories and Subject Descriptors D.3.1 [Programming Lan\u00adguages]: Formal De.nitions \nand Theory; F.3.1 [Logics and Mean\u00adings of Programs]: Specifying and Verifying and Reasoning about Programs \nKeywords Operational Semantics, Separation Logic, C Veri.ca\u00adtion, Interactive Theorem Proving, Coq 1. \nIntroduction The C programming language [16, 17] is not only among the most popular programming languages \nin the world, but it is also among the most dangerous programming languages. Due to weak static typing \nand the absence of runtime checks, it is extremely easy for C programs to have bugs that make the program \ncrash or behave badly in other ways. NULL-pointers can be dereferenced, arrays can be accessed outside \ntheir bounds, memory can be used after it is freed, etc. Furthermore, C programs can be developed with \na too speci.c interpretation of the language in mind, giving portability and maintenance problems later. \nInstead of forcing compilers to use a prede.ned execution order for expressions (e.g. left to right), \nthe C standard does not specify it. This is a common cause of portability and maintenance prob\u00adlems, \nas a compiler may use an arbitrary execution order for each * Part of this research has been done while \nthe author was visiting INRIA-Paris Rocquencourt, France. Permission to make digital or hard copies of \npart or all of this work for personal or classroom use is granted without fee provided that copies are \nnot made or distributed for pro.t or commercial advantage and that copies bear this notice and the full \ncitation on the .rst page. Copyrights for third-party components of this work must be honored. For all \nother uses, contact the owner/author(s). POPL 14, January 22 24, 2014, San Diego, CA, USA. Copyright \nis held by the owner/author(s). ACM 978-1-4503-2544-8/14/01. http://dx.doi.org/10.1145/2535838.2535878 \n expression. Hence, to prove the correctness of a C program with respect to an arbitrary compiler, one \nhas to verify that each possi\u00adble execution order is legal and gives the correct result. To make more \neffective optimizations possible (e.g. delaying of side-effects and interleaving), the C standard requires \nthe programmer to ensure that all execution orders satisfy certain conditions. If these condi\u00adtions are \nnot met, the program may do anything. Let us take a look at an example where one of those conditions \nis not met. int main() { int x; int y = (x = 3) + (x = 4); printf(\"%d %d\\n\", x, y); } By considering \nall possible execution orders, one would naively expect this program to print 4 7 or 3 7, depending on \nwhether the assignment x = 3 or x = 4 is executed .rst. However, the sequence point restriction does \nnot allow an object to be modi.ed more than once (or being read after being modi.ed) between two sequence \npoints [16, 6.5p2]. A sequence point occurs for example at the end ; of a full expression, before a function \ncall, and after the .rst operand of the conditional ? : operator [16, Annex C]. Hence, both execution \norders lead to a sequence point violation, and are thus illegal. As a result, the execution of this program \nexhibits unde.ned behavior, meaning it may do literally anything. The C standard uses a garbage in, garbage \nout principle for unde.ned behavior so that compilers do not have to generate (pos\u00adsibly expensive) runtime \nchecks to handle corner cases. A com\u00adpiler therefore does not have to generate code to test whether a \nse\u00adquence point violation occurs, but instead is allowed to assume no sequence point violations will \noccur and can use this information to perform more effective optimizations. Indeed, when compiled with \ngcc -O1 (version 4.7.2), the above program prints 4 8, which does not correspond to any of the execution \norders. Non-determinism in C is even more unrestrained than some may think. That the execution order \nin e1 + e2 is unspeci.ed, does not mean that either e1 or e2 will be executed entirely before the other. \nInstead, it means that execution can be interleaved; .rst a part of e1, then a part of e2, then another \npart of e1, and so on. . . Hence, the following expression is also allowed to print bac. printf(\"a\") \n+ (printf(\"b\") + printf(\"c\")); Many existing tools for C veri.cation determinize the target program in \none of their .rst phases, and let the user verify the correctness of the determinized version. When targeting \na speci.c compiler for which the execution order is known, and which does not perform optimizations based \non the sequence point restriction, this approach works. But to prove the correctness of a program with \nrespect to an arbitrary compiler, this approach is insuf.cient even if all possible execution orders \nare considered (see the counterex\u00adample in gcc above).  Some veri.cation tools perform syntactical checks \nto exclude sequence points violations. However, as it is undecidable whether a sequence point violation \nmay occur [12], determinization com\u00ad bined with such checks is either unsound (slides 13 and 15 of El\u00adlison \nand Rosu s POPL 2012 talk [13] present some examples in existing tools), or will exclude valid C programs. \nApproach. As a step towards taking non-determinism and the se\u00adquence point restriction seriously in C \nveri.cation, we extend the small step operational and separation logic for non-local control .ow by Krebbers \nand Wiedijk [21] with non-deterministic expres\u00ad sions with side-effects and the sequence point restriction. \nSound\u00adness of the axiomatic semantics is proved with respect to the oper\u00adational semantics using the \nCoq proof assistant. The straightforward approach to veri.cation of programs with non-determinism is \nto consider all possible execution orders. How\u00adever, naively this may result in a combinatorial explosion, \nand also it is not entirely clear how to use this approach in an axiomatic se\u00admantics that also handles \nthe sequence point restriction. Hence, we take a different approach: we extend the axiomatic semantics \nwith a Hoare judgment {P } e {Q} for expressions. As usual, P is an assertion called the precondition. \nLike Von Oheimb [29], we let the postcondition Q be a function from values to assertions, because expressions \nnot only have side-effects but primarily yield a value. Intuitively, the judgment {P } e {Q} means that \nif P holds for the memory beforehand, and execution of e yields a value v, then Q v holds for the resulting \nmemory afterwards. Besides partial program correctness, the judgment {P } e {Q}ensures that e exhibits \nno unde.ned behavior due to the sequence point restriction. To deal with the unrestrained non-determinism \nin C, we observe that non-determinism in expressions corresponds to a form of concurrency, which separation \nlogic is well capable of dealing with. Inspired by the rule for the parallel composition of separation \nlogic (see [27]), we propose the following kind of rules for each operator @. {Pl} el {Ql} {Pr} er {Qr} \n{Pl * Ql} el @ er {Pr * Qr} The idea is that, if the memory can be split up into two disjoint parts (using \nthe separating conjunction *), in which the subexpressions el respectively er can be executed safely, \nthen the full expression el @ er can be executed safely in the whole memory. The actual rules of the \naxiomatic semantics (see Section 5) are more complicated. We have to deal with the return value, and \nhave to account for unde.ned behavior due to integer over.ow. To ensure no sequence point violations \noccur, we use separation logic with permission accounting. Like in ordinary separation logic with . permissions \n[6], the singleton assertion becomes e1 . e2 where . is the permission of the object e2 at address e1, \nbut we introduce a special class of locked permissions. The inference rules of our axiomatic semantics \nare set up in such a way that reads and writes are only allowed for objects that are not locked, and \nmoreover such that objects become locked after they have been written to. At constructs that contain \na sequence point, the inference rules ensure that these locks are released. Fractional permissions [7] \nare used to allow memory that will not be written to be shared by multiple subexpressions. Our approach \nto handling non-determinism and sequence points at the level of the operational semantics is inspired \nby Ellison and Rosu [12] and Norrish [25]. We annotate each object in memory with a permission, that \nis changed into a locked variant whenever a write occurs. This permission is changed back into the unlocked \nvariant at the subsequent sequence point. Furthermore, we have a special state undef for unde.ned behavior \nthat is used for example whenever a write to a locked object occurs. To bring the operational semantics \ncloser to our axiomatic se\u00admantics, we make locks local to the subexpression where they were created. \nThat means, at a sequence point we only unlock objects that have been locked by that particular subexpression, \ninstead of unlocking all objects. This modi.cation lets some arti.cial pro\u00adgrams that were legal by the \nC standard exhibit unde.ned behavior (see page 5), but is not unsound for program veri.cation. An important \npart of both the operational and axiomatic seman\u00adtics is the underlying permission system. We give an \nabstract spec\u00adi.cation of it (as an extension of permission algebras [8]), and give various instances \nof this abstraction. Related work. Non-determinism, side-effects in expressions, and sequence points \nhave been treated numerous times in formal treat\u00adments of C, but to our surprise, there is little evidence \nof work on program veri.cation and program logics for these concepts. The .rst formalization of a signi.cant \npart of C is due to Nor\u00adrish [25] using the proof assistant HOL4. An important part of his work was to \naccurately formalize non-determinism and sequence points as described by the C89 standard. He proved \nvarious Hoare rules for statements to facilitate reasoning about C programs. To reason about non-deterministic \nexpressions, he proved that execu\u00adtion of sequence point free expressions is con.uent [26]. This re\u00ad \nsult is also useful for more ef.cient symbolic execution. Reasoning about arbitrary C expressions was \nleft as an open problem. Papaspyrou [30] has given a denotational semantics for a part of C89, including \nnon-determinism and sequence points. He has implemented his semantics in Haskell to obtain a tool that \ncan be used to explore all behaviors of a C program. Papaspyrou did not consider an axiomatic semantics. \nMore recently, Ellison and Rosu [12] have de.ned an executable semantics of the C11 standard using the \nK-framework. Their se\u00admantics is very comprehensive and also describes non-determinism and the sequence \npoint restriction. Moreover, since their semantics is effectively executable, it can be used as a debugger \nand an in\u00adterpreter to explore all behaviors of a C program. It has been thor\u00adoughly tested against C \ntest suites, and has been used by Regehr et al. to .nd bugs in widely used C compilers [31]. CompCert, \na veri.ed compiler C compiler by Leroy et al. writ\u00adten in Coq [23], supports non-determinism in expressions \nin the semantics of its source language. The interpreter by Campbell [9] can be used to explore this \nnon-determinism. Krebbers [18] has extended CompCert s source language and interpreter with the se\u00adquence \npoint restriction in the style of Ellison and Rosu [12]. There have been various efforts to verify programs \nin CompCert C. Appel and Blazy s axiomatic semantics for CompCert [2] oper\u00ad ates on an intermediate language \nin which expressions have been determinized and side-effects have been removed. Their axiomatic semantics \nis thus limited to veri.cation of programs compiled with CompCert, and will not work for arbitrary compilers. \nHerms [15] has formalized a veri.cation condition generator based on the Why platform in Coq that can \nbe used as a standalone tool via Coq s ex\u00adtraction mechanism. He proved the tool s soundness with respect \nto an intermediate language of CompCert, and it thus suffers from the same limitations as Appel and Blazy \ns work. Black and Windley [5] have developed an axiomatic semantics for C. They de.ne inference rules \nto factor out side-effects of ex\u00adpressions by translating these into semantically equivalent versions. \nTheir axiomatic semantics seems rather limited, and soundness has not been proven with respect to an \noperational semantics. Extending an axiomatic semantics with a judgment for expres\u00adsions is not new, \nand has been done for example by Von Ohe\u00adimb [29] for Java in the proof assistant Isabelle. His judgments \nfor expressions are quite similar to ours, but his inference rules are not. Since he considered Java, \nhe was able to use that the execution or\u00adder of expressions is fully de.ned, which is not the case for \nC.  Contribution. Our contribution is fourfold: We de.ne an abstract interface for permissions on top \nof which the memory model is de.ned, and present an algebraic method to reason about disjoint memories \n(Section 2).  We de.ne a small step operational semantics that handles non\u00addeterminism and sequence \npoints (Section 3 and 4).  We give an axiomatic semantics that allows reasoning about programs with \nnon-determinism. This axiomatic semantics en\u00adsures that no unde.ned behavior (e.g. sequence point violations \nand integer over.ow) occurs (Section 5).  We prove the soundness of our axiomatic semantics (Section \n6). This proof, together with some extensions (Section 7), has been fully formalized using Coq (Section \n8).  As this paper describes a large formalization effort, we often omit details and proofs. The interested \nreader can .nd all details online as part of our Coq formalization. 2. The memory and permissions We \nmodel memories as .nite partial functions from some count\u00adable set of memory indices (b . index) to pairs \nof values and per\u00admissions. A value is either indet (which is used for uninitialized memory and the return \nvalue of functions without explicit return), a bounded integer, a pointer, or a NULL-pointer. Values \nare un\u00adtyped (apart from integer values) and intentionally kept simple to focus on the issues of the \npaper. DE FI NI TI O N 2.1. A partial function from A to B is a (total) func\u00adtion from A to Bopt, where \nBopt is the option type, de.ned as con\u00adtaining either . or x for some x . B. A partial function is called \n.nite if its domain is .nite. The operation f[x := y] stores the value y at index x, and f[x := .] deletes \nthe value at index x. DE FI NI TI O N 2.2. Integer types and values are de.ned as: t . inttype ::= signed \nchar | unsigned char | signed int | . . . v . val ::= indet | intt n | ptr b | NULL For an integer value \nintt n, the mathematical integer n . Zshould be within the bounds of t . A value v is true, notation \nistrue v, if it is of the shape intt n with n 0, or ptr b. It is false, notation = isfalse v, if it is \nof the shape intt 0 or NULL. Notice that indet is neither true nor false, because at an actual machine \nuninitialized memory has arbitrary contents. In order to abstract from a concrete choice for a permission \nsys\u00adtem (no permissions, simple read/write/free permissions, fractional permissions, etc.) in the de.nition \nof the memory, we de.ne an abstract interface for permissions. We organize permissions using four different \npermission kinds (pkind): Free, which allows all operations (read, write, free),  Write, which allows \njust reading and writing,  Read, which allows solely reading, and  Locked, which is temporarily used \nto lock an object between a write to it and a subsequent sequence point.  This organization is inspired \nby Leroy et al. [24], but differs by the fact that we abstract away from a concrete implementation and \nallow much more complex permission systems (e.g. those based on fractional permissions). These are needed \nfor our separation logic. We de.ne a partial order on permission kinds as the re.exive\u00adtransitive closure \nof Read . Write, Locked . Write and Write . Free. Since read-only memory cannot be used for writing, \nand therefore cannot be locked, the kinds Locked and Read are incom\u00adparable on purpose. DE FIN I T I \nON 2.3. A permission system consists of a set P , binary relations . and ., binary operations . and \\, \nand functions kind : P . pkind and lock, unlock : P . P , satisfying: 1. (P, .) is a partial order 2. \n. is symmetric 3. (P, .) is a commutative semigroup 4. If x . y, then kind x . kind y 5. If x . y, \nthen kind x = Read 6. If Write . kind x, then unlock (lock x) = x 7. If kind x  = Locked, then unlock \nx = x 8. kind (unlock x) = Locked 9. If x . y and x' . x, then x' . y 10. If x . y . z, then x . z and \nx . y . z 11. If x . y, then x . x . y 12. If x . y, then z . x . z . y 13. If z . x, z . y, and z \n. x . z . y, then x . y 14. If x . y, then x . y \\ x and x . y \\ x = y  Permission systems extend permission \nalgebras by Calcagno et al. [8] by organizing permissions using kinds, and by having opera\u00ad tions for \nlocking and unlocking. Whereas . is a partial function in a permission algebra, we require it to be a \ntotal function, and account for partiality using a relation . to describe that two permissions are disjoint \nand may be joined. For permissions that are not disjoint, the result of . is not speci.ed in the de.nition \nof a permission system. This relieves us from dealing with partial functions in Coq. Lastly, we require \n\\ to be a primitive so we can lift it to an operation on memories (see De.nition 2.9) that is an actual \nCoq function. Dockins et al. [11] remedy the issue of partially by de.ning . as a relation instead of \na function. But as for the operation \\, we prefer to use functions to ease reasoning about memories. \nRule 5 ensures that only permissions whose kind is Read are disjoint. This is to ensure that only readable \nparts of disjoint mem\u00adories may overlap. Before we de.ne memories, we de.ne three instances of per\u00admission \nsystems. We begin with fractional permissions [7]. DE FIN I T I ON 2.4. Fractional permissions (z . frac) \nare rational numbers within (0, 1]. We let z1 . z2 iff z1 = z2, and z1 . z2 iff z1 + z2 = 1. The operations \nare de.ned as: z1 + z2 if z1 + z2 = 1 z1 . z2 := Write if z = 1 1 otherwise kind z := Read otherwise \nz1 - z2 if 0 < z1 - z2 z1 \\ z2 :=lock z := unlock z := z 1 otherwise Notice that in the above de.nition \nwe yield the dummy value 1 for z1 . z2 if z1 . z2, and z1 \\ z2 if z2 . z1. To account for locks due to \nthe sequence point restriction, we extend fractional permissions with a special permission Seq. DE FIN \nI T I ON 2.5. Sequenceable permissions are de.ned as: .s . seqfrac ::= Seq | UnSeq z Disjointness . is \ninductively de.ned as: 1. if z1 . z2 then UnSeq z1 . UnSeq z2 The order . is inductively de.ned as: 1. \nSeq . Seq 2. if z1 . z2, then UnSeq z1 . UnSeq z2 The operations . and \\ are de.ned point-wise, and: \nkind Seq := Locked kind (UnSeq z) := kind z lock Seq := Seq lock (UnSeq z) := Seq unlock Seq := UnSeq \n1 unlock (UnSeq z) := UnSeq z  We extend sequenceable permissions to account for some sub\u00adtleties of \nC. First of all, we need to deal with objects that are de\u00adclared using the const quali.er (those are \nread-only). Secondly, whereas dynamically allocated memory obtained via alloc can be freed manually using \nfree, memory of block scope variables can\u00adnot be freed using free. Freeing it should therefore be prohibited \nby the permission system. DE FI NI TI O N 2.6. Full permissions are de.ned as: . . perm ::= Freeable \n.s | Writable .s | ReadOnly z Here, all relations and operations are de.ned point-wise by lifting those \non fractional and sequenceable permissions. We use the ab\u00adbreviations F, W and R for the permissions \nFreeable (UnSeq 1), Writable (UnSeq 1) and ReadOnly 1, respectively. Given an arbitrary permission system \nwith carrier P , the de.ni\u00adtion of the memory is now straightforward. DE FI NI TI O N 2.7. Memories (m \n. mem) are .nite partial func\u00adtions from memory indices to pairs (v, x) with v . val and x . P . First \nwe de.ne the operations that are used by the operational semantics (Section 4) to interact with the memory. \nDE FI NI TI O N 2.8. The memory operations are de.ned as: x if m b = (v, x) perm b m := . otherwise \n v if m b = (v, x) and kind x = Locked m !! b := . otherwise m[b := (v, x)] if m b = (v ' , x) m[b := \nv] := m otherwise alloc b v x m := m[b := (v, x)] free b m := m[b := .] locks m := {b | m b = (v, x) \n. kind x = Locked} m[b := (v, lock x)] if m b = (v, x) lock b m := m otherwise unlock O m := {(b, (v, \nunlock x)) | b . O . m b = (v, x)}. {(b, (v, x)) | b /. O . m b = (v, x)} Here, we have O ..n index. \nThe function perm is used to obtain the permission of an object. Allocation alloc b v x m of an object \nwith value v and permis\u00adsion x should only be used with unused indices b in m (i.e. with perm b m = .). \nLikewise, a store [ := ] and deallocation using free, should only be used when the permissions are appropri\u00adate. \nWe will take care of these side-conditionals in the rules of the operational semantics. Next, we de.ne \nthe memory operations that are used by the axiomatic semantics (Section 5). DE FI NI TI O N 2.9. The \nseparation memory relations are de.ned as: We let m1 . m2 iff for all b, v1, x1, v2 and x2 with m1 b \n= (v1, x2) and m2 b = (v2, x2) we have v1 = v2 and x1 . x2.  We let m1 . m2 iff for all b, v1 and x1 \nwith m1 b = (v, x1) there exists an x2 . x1 with m2 b = (v, x2).  The separation memory operations are \nde.ned as: m1 . m2 := {(b, (v1, x1 . x2)) | m1 b = (v1, x1) . m2 b = (v2, x2)} . {(b, (v1, x1)) | m1 \nb = (v1, x1) . m2 b = .} . {(b, (v2, x2)) | m1 b = . . m2 b = (v2, x2)} m1 \\ m2 := {(b, (v1, x1 \\ x2)) \n| m1 b = (v1, x1) . m2 b = (v2, x2) . x2 . x1} . {(b, (v1, x1)) | m1 b = (v1, x1) . m2 b = .} The union \n. and empty memory \u00d8 form a monoid that is com\u00admutative and cancellative for disjoint memories. For the \nsoundness proof of our axiomatic semantics (Section 6) we often need to reason about preservation of \ndisjointness under memory operations. To ease that kind of reasoning, we de.ne a relation i=. m2 that \ndescribes that the memories im2 m1 im1 and ibehave equivalently with respect to disjointness. DE FIN \nI T I ON 2.10. Disjointness of a list of memories i m, notation . i m, is inductively de.ned as: 1. . \n[ ] 2. If m . im, then . (m :: i  m and. im) Notice that . i. mj for m is stronger than merely having \nmi each i = j. For example, using fractional permissions, we do not have . [ {(b, (v, 0.5))}, {(b, (v, \n0.5))}, {(b, (v, 0.5))} ], whereas we clearly do have {(b, (v, 0.5))} . {(b, (v, 0.5))}. DE FIN I T I \nON 2.11. Equivalence of iand iwith respect to m1 m2 disjointness, notation im2, is de.ned as: m1 =. i \nim2 := .m .. (m :: im2) m1 =. im1) . . (m :: i im2 := im2 . im1 m1 =. im1 =. im2 =. i It is straightforward \nto show that =. is re.exive and transitive, being respected by concatenation of sequences, and is being \npre\u00adserved by list containment. Hence, =. is an equivalence relation, a congruence with respect to concatenation \nof sequences, and also being preserved by permutations. The following results allow us to reason algebraically \nabout disjoint memories. FAC T 2.12. If im2 and. im2. m1 =. im1, then . i TH E O R E M 2.13. We have \nthe following algebraic properties: 1. \u00d8 :: im m =. i 2. (m1 . m2) :: im provided that m1 . m2 m =. m1 \n:: m2 :: i 3. im2 =. im2 provided that . i m1 :: im1 ++ im1 4. m[b := v] :: im provided that perm b \nm x for m =. m :: i= some x that is not a fragment 5. {(b, (v1, x))} :: im provided x is not a  m \n=. {(b, (v2, x))} :: i fragment 6. m2 :: im provided that m1 . m2 m =. m1 :: (m2 \\ m1) :: i 7. m :: im \nprovided that perm b m x for m =. lock b m :: i= some x that is not a fragment 8. m :: im m =. unlock \nO m :: i Here, a permission x is a fragment if there is a y such that x . y. 3. The language In this \nsection we de.ne the syntax of expressions and statements. DE FIN I T I ON 3.1. Expressions are de.ned \nas: @ . binop ::= == | <= | + | -| * | / | % | . . . e . expr ::= xi | [v]O | e1 := e2 | f (ie) | load \ne | alloc | free e | e1 @ e2 | e1 ? e2 : e3 | (t ) e Instead of [v]\u00d8, we just write v. Expressions may \ncontain side-effects: assignments e1 := e2, function calls f(ie), and allocation alloc and deallocation \nfree e of dynamic memory. Unary operators, pre.x and post.x increment and decrement, assignment operators, \nand the comma operator, are omitted in this paper, but are included in the Coq formalization. The logical \noperators are de.ned in terms of the conditional.  Values [v]O are annotated with a .nite set O of locked \nmemory indices. This set is initially empty, but whenever a write is per\u00adformed, the written object is \nlocked in memory and its memory index is added to O (see Section 4). Whenever a sequence point occurs, \nthe locked objects in O will be unlocked in memory. The operation locks e collects the annotated locks \nin e. Stacks (. . stack) are lists of memory indices. Variables are De Bruijn indices, i.e. the variable \nxi refers to the ith memory index on the stack. De Bruijn indices avoid us from having to deal with shadowing \ndue to block scope variables. Especially in the axiomatic semantics this is useful, as we do not want \nto lose information by a local variable shadowing an already existing one. The stack contains references \nto the value of each variable instead of the values itself so as to treat pointers to both local and \nallocated storage in a uniform way. Execution of a variable xi thus consists of looking up its address \nb at position i in the stack, and returning a pointer ptr b to that address. Execution of load e consists \nof evaluating e to ptr b and looking up b in the memory. DE FI NI TI O N 3.2. Statements are de.ned as: \ns . stmt ::= e | skip | goto l | return e | block c s | s1 ; s2 | l : s | while(e) s | if (e) s1 else \ns2 The statement syntax is adapted from Krebbers and Wiedijk [21], but we treat assignments and function \ncalls as expression constructs instead of statements constructs. Hence, assignments and function calls \ncan be nested, and can occur in the expressions of a return, while, and conditional statement. The construct \nblock c s opens a block scope with one local variable, where the boolean c speci.es whether the variable \nis const-quali.ed or not. The permission blockperm c is de.ned as: blockperm True := R and blockperm \nFalse := W. Since we use De Bruijn indices, the construct block c s is nameless. 4. Operational semantics \nWe de.ne the semantics of expressions and statements by a small step operational semantics. That means, \ncomputation is de.ned by the re.exive transitive closure of a reduction relation _ on pro\u00adgram states. \nTo de.ne this reduction, we .rst de.ne head reduction of expressions, and then use evaluation contexts \n(as introduced by Felleisen et al. [14]) to de.ne reduction of whole programs. In the remainder of this \npaper, we will use a memory instantiated with full permissions (De.nition 2.6). DE FI NI TI O N 4.1. \nGiven a stack ., head reduction of expressions (e1, m1) _h (e2, m2) is inductively de.ned as: 1. (xi, \nm) _h (ptr b, m), in case . i = b 2. ([ptr b]O1 := [v]O2 , m) _h ([v]{b}.O1.O2 , lock b (m[b:= v])), \nin case perm b m = . and Write . kind . 3. (load [ptr b]O, m) _h ([v]O, m), for any v with m !! b = \nv  4. (alloc, m)_h (ptr b, alloc b indet F m), for any b with perm b m = .  5. (free [ptr b]O, m) _h \n([indet]O, free b m), in case perm b m = . and kind . = Free  6. ([v1]O1 @[v2]O2 , m) _h ([v ' ]O1.O2 \n, m), in case v1 @ v2 = v ' 7. ([v]O ? e2 : e3, m) _h (e2, unlock O m), in case istrue v 8. ([v]O ? \ne2 : e3, m) _h (e3, unlock O m), in case isfalse v  9. ((t ) [v]O, m)_h ([v ' ]O, m), in case (t ) v \n= v ' If the stack . is not clear from the context, we write . f (e1, m1) _h (e2, m2). Note that picking \nan unused index for allocation in Rule 4 is non-deterministic. In Rules 6 and 9, v1 @ v2 and (t) v are \npartial functions that evaluate a binary operation on values and integer cast on values respectively. \nThese functions fail in case of integer over.ow, or if an operation is used wrongly (e.g. division by \nzero). An assignment [ptr b]O1 := [v]O2 (Rule 2) not only stores the value v at index b, but also locks \nb in the memory. Locking b enforces the sequence point restriction, because consecutive reads and writes \nto b will fail (as ensured by the side-condition of the assignment rule, and De.nition 2.8 of the !! \noperation). In order to keep track of the lock of b, we add b to the set {b}.O1.O2. Rules 7 and 8 for \nthe conditional [v]O ? e2 : e3 model a sequence point by unlocking the indices O in the memory, making \nfuture reads and writes possible again. Other constructs with a sequence point will be given a similar \nsemantics (see De.nition 4.10). Like Ellison and Rosu [12], we implicitly use non-determinism to capture \nunde.ned behavior due to sequence point violations. For example, in x + (x = 10) only one execution order \n(performing the read after the assignment) leads to a sequence point violation. In Norrish s semantics \n[25] both execution orders lead to a sequence point violation as he also keeps track of reads. Our treatment \nof sequence points assigns unde.ned behavior to more programs than the C standard, and Ellison and Rosu \ndo. Ellison and Rosu release the locks of all objects at a sequence point, whereas we just release the \nlocks that have been created by the subexpression where the sequence point occurred. For example, we \nassign unde.ned behavior to the following program of Ellison. int x, y, *p = &#38;y; int f() { if (x) \n{ p = &#38;x; } return 0; } int main() { return (x = 1) + (*p = 2) + f(); } The execution order that \nleads to unde.ned behavior is (a) x = 1, (b) call f which changes p to &#38;x, (c) *p = 2. Here, the \nlock of &#38;x survives the function call. In the semantics of Ellison and Rosu, this program has de.ned \nbehavior, as the sequence point before the function call releases all locks, so also the lock of &#38;x. \nWe believe that this is a reasonable trade-off, because dealing with sequence points locally instead \nof globally brings the oper\u00adational semantics closer to the axiomatic semantics as separation logic only \ntalks about a local part of the memory. We believe only arti.cial programs become illegal, because different \nfunction calls in the same expression can still write to a shared part of the memory (which is useful \nfor memoization). For example, given int f(int y) { static int map[MAP_SIZE]; if (map[y]) { return map[y]; \n} return map[y] = expensive_function(y); } the expression f(3) + f(3) has de.ned behavior according to \nour semantics of sequence points. Since the C standard does not allow interleaved execution of function \ncalls [16, 6.5.2.2p10], these are not described by the head reduction _h. Instead, a function call changes \nthe whole program state to a state in which its body is executed. When execution of the function body \nis .nished, the result will be plugged back into the whole expression. To describe this behavior, and \nto select a head redex in an expression, we de.ne expression contexts. DE FIN I T I ON 4.2. Singular \nexpression contexts are de.ned as: Es . ectxs ::= D := e | e := D | f(ie1, D, ie2) | load D | free D \n| D @ e2 | e1 @ D | D ? e2 : e3 | (t ) D  Expression contexts (E . ectx) are lists of singular contexts. \nGiven an expression context E and an expression e, the substitution of e for D in E, notation E[ e ], \nis de.ned as usual. In the reduction of whole programs (De.nition 4.10), we allow E[ e1 ] to reduce to \nE[ e2 ] provided that (e1, m1) h (e2, m2). To _ enforce that the .rst operand of the conditional e1 ? \ne2 : e3 is executed entirely before the others, it is essential that we omit the contexts e1 ? D : e3 \nand e1 ? e2 : D. The reduction of whole programs uses a zipper-like data struc\u00adture, called a program \ncontext [21], to store the location of the sub\u00ad statement that is being executed. Execution of the program \noccurs by traversal through the program context in the direction down ', up /, jump \", or top ... When \na goto l statement is executed, the direction is changed to \"l, and the semantics performs a small step \ntraversal through the program context until the label l has been reached. Program contexts extend the \nzipper by annotating each block scope variable with its associated memory index, and fur\u00adthermore contain \nthe full call stack of the program. Program contexts can also be seen as a generalization of contin\u00aduations \n(as for example being used in CompCert [2, 23]). However, there are some notable differences. Program \ncontexts implicitly contain the stack, whereas a con\u00adtinuation semantics typically stores the stack separately. \n Program contexts also contain the part of the program that has been executed, whereas continuations \nonly contain the part that remains to be done.  Since the complete program is preserved, looping constructs \nlike the while statement do not have to duplicate code.  The fact that program contexts do not throw \naway the parts of the statement that have been executed is essential for the treatment of goto. Upon \nan invocation of a goto, the semantics traverses through the program context until the corresponding \nlabel has been found. During this traversal it passes all block scope variables that go out of scope, \nallowing it to perform required allocations and deallocations in a natural way. Hence, the point of this \ntraversal is not so much to search for the label, but much more to incrementally calculate the required \nallocations and deallocations. DE FI NI TI O N 4.3. Singular statement contexts are de.ned as: Ss . sctxs \n::= D ; s2 | s1 ; D | l : D | while(e) D | if (e) D else s2 | if (e) s1 else D Given a singular statement \ncontext Ss and a statement s, substitu\u00adtion of s for D in Ss, notation Ss[ s ], is de.ned as usual. A \npair (Sis, s) consisting of a list Sis of singular statement contexts and a statement s forms a zipper \nfor statements without block scope variables. That means, Sis is a statement turned inside\u00adout that represents \na path from the focused substatement s to the top of the whole statement. DE FI NI TI O N 4.4. Expression \nstatement contexts and singular pro\u00adgram contexts are de.ned as: Se . sctxe ::= D | return D | while(D) \ns | if (D) s1 else s2 i Ps . ctxs ::= Ss | blockb c D | (Se, e) | resume E | params b Program contexts \n(k . ctx) are lists of singular program contexts. Given an expression statement context Se and an expression \ne, substitution of e for D in Se, notation Se[ e ], is de.ned as usual. The previously de.ned program \ncontexts will be used as follows in the operational semantics. When entering a block scope block c s, \nthe singular context blockb c D is appended to the head of the program context. It associates the block \nscope with its memory index b.  When executing a statement construct Se[ e ] that contains an expression \ne, the singular context (Se, e) is appended to the head of the program context to keep track of the statement. \nWe need to keep track of the expression e as well so that it can be restored when execution of the expression \nis .nished.  When executing a function call E[ f(iv) ], the singular context resume E is appended to \nthe head of the program context. When the function returns with value v, execution of the expression \nE[ v ] with the return value v plugged in, is continued.  When a function body is entered, the singular \ncontext params ib is appended to the head of the program context. It contains a list ib of memory indices \nof the function parameters.  As program contexts implicitly contain the stack, we de.ne a function to \nextract it from them. DE FIN I T I ON 4.5. The corresponding stack getstack k of a pro\u00adgram context k \nis de.ned as: getstack (Ss :: k) := getstack k getstack (blockb c D :: k) := b :: getstack k getstack \n((Se, e) :: k) := getstack k getstack (resume E :: k) := [ ] getstack (params ib :: k) := ib ++ getstack \nk We de.ne getstack (resume E :: k) as [ ] instead of getstack k, as otherwise it would be possible to \nrefer to the local variables of the calling function. DE FIN I T I ON 4.6. Directions, focuses and program \nstates are de\u00ad.ned as: d . direction ::= ' | / | \"l | .. v f . focus ::= (d, s) | e | call f iv | return \nv | undef S . state ::= S(k, f, m) A program state S(k, f, m) consists of a program context k, the part \nof the program f that is focused, and the memory m. Similar to Leroy s Cmedium [23], we have .ve kinds \nof states: (d, s) for execution of a statement s in direction d,  e for execution of an expression \ne,  call f iv for calling a function f with arguments v,  return v for returning from a function with \nreturn value v, and  undef to capture unde.ned behavior.  We have additional states for execution of \nexpressions and un\u00adde.ned behavior. The semantics of Leroy s Cminor [22], and the semantics of Krebbers \nand Wiedijk [21], do not have such states, because their expressions are deterministic and side-effect \nfree. They capture unde.ned behavior by letting the reduction get stuck, whereas that will not work in \nthe presence of non-determinism. DE FIN I T I ON 4.7. The relation allocparams . m1 ib iv m2 allo\u00adcates \nfresh blocks ib for function parameters iv with permission . (non-deterministically). It is inductively \nde.ned as: 1. allocparams . m [] [] m 2. If allocparams . m1 ib iv m2 and perm b m2 = ., then allocparams \n. m1 (b :: ib) (v :: iv) (alloc b v . m2)   DE FI NI TI O N 4.8. An expression is a redex if it is \nof the following shape: (a) xi, (b) [v1]O1 := [v2]O2 , (c) f ([v1]O1 , . . . , [v2]O2 ), (d) load [v]O, \n(e) alloc (f) free [v]O, (g) [v1]O1 @ [v2]O2 , (h) [v]O ? e2 : e3, or (i) (t) [v]O.  DE FI NI TI O \nN 4.9. An expression is safe in stack . and memory m if: (a) it is of the shape f(ie), or (b) there is \nan expression e ' and memory m ' such that . f (e, m) h (e ' , m ' ). _ DE FI NI TI O N 4.10. Given a \n.nite partial function d mapping func\u00adtion names to statements, the small step reduction S1 S2 is _ inductively \nde.ned as: 1. For simple statements: (a) S(k, (., skip), m) -S(k, ((, skip), m) (b) S(k, (., goto l), \nm) -S(k, (\"l, goto l), m) (c) S(k, (., Se[ e ]), m) -S((Se, e) :: k, e, m)  2. For expressions: (a) \nS(k, E[ e1 ], m1) -S(k, E[ e2 ], m2) for any e2 and m2 s.t. getstack k f (e1, m1)-h (e2, m2) (b) S(k, \n(., E[ f([v0]O0 , . . . , [vn]On ) ]), m) \u00ad b  S(resume E :: k, call f bv, unlock ( O) m) (c) S(k, \n(., E[ e ]), m) -S(k, undef, m), provided that e is an unsafe redex 3. For .nished expressions: (a) \nS((D, e) :: k, [v]O, m) -S(k, ((, e), unlock O m) (b) S((return D, e) :: k, [v]O, m) \u00adS(k, (.. v, return \ne), unlock O m)  (c) S((while(D) s, e) :: k, [v]O, m) \u00adS(while(e) D :: k, (., s), unlock O m) provided \nthat istrue v  (d) S((while(D) s, e) :: k, [v]O, m) \u00adS(k, ((, while(e) s), unlock O m) provided that \nisfalse v  (e) S((if (D) s1 else s2, e) :: k, [v]O, m) \u00adS(if (e) D else s2 :: k, (., s1), unlock O \nm) provided that istrue v  (f) S((if (D) s1 else s2, e) :: k, [v]O, m) \u00adS(if (e) s1 else D :: k, (., \ns2), unlock O m) provided that isfalse v  4. For compound statements: (a) S(k, (., block c s), m) \u00adS((blockb \nc D) :: k, (., s), alloc b indet (blockperm c) m) for any b such that perm b m = . (b) S(k, (., s1 ; \ns2), m) -S((D ; s2) :: k, (., s1), m) (c) S(k, (., l : s), m) -S((l : D) :: k, (., s), m) (d) S((blockb \nc D) :: k, ((, s), m) \u00adS(k, ((, block c s), free b m)  (e) S((D ; s2) :: k, ((, s1), m) -S((s1 ; D) \n:: k, (., s2), m) (f) S((s1 ; D) :: k, ((, s2), m) -S(k, ((, s1 ; s2), m) (g) S(while(e) D :: k, ((, \ns), m) -S(k, (., while(e) s), m) (h) S((if (e) D else s2) :: k, ((, s1), m) \u00adS(k, ((, if (e) s1 else \ns2), m)  (i) S((if (e) s1 else D) :: k, ((, s2), m) \u00adS(k, ((, if (e) s1 else s2), m)  (j) S((l : D) \n:: k, ((, s), m) -S(k, ((, l : s), m)  5. For function calls: (a) S(k, call f bv, m1) -S(params bb :: \nk, (., s), m2) bb for any s, b and m2 s.t. d f = s and allocparams W m1 b bv m2 (b) S(params bb :: k, \n((, s), m) -S(k, return indet, free bb m) (c) S(params bb :: k, (.. v, s), m) -S(k, return v, free bb \nm) (d) S(resume E :: k, return v, m) -S(k, E[ v ], m) 6. For non-local control .ow: (a) S((blockb c D) \n:: k, (.. v, s), m) \u00adS(k, (.. v, block c s), free b m)  (b) S(Ss :: k, (.. v, s), m) -S(k, (.. v, Ss[ \ns ]), m) (c) S(k, (\"l, l : s), m) -S((l : D) :: k, (., s), m)  (d) S(k, (\"l, block c s), m) \u00adS((blockb \nc D) :: k, (\"l, s), alloc b indet (blockperm c) m) for any b such that perm b m = ., and provided that \nl . labels s (e) S(blockb c D :: k, (\"l, s), m) \u00adS(k, (\"l, block c s), free b m) provided that l /. labels \ns (f) S(k, (\"l, Ss[ s ]), m) -S(Ss :: k, (\"l, s), m) provided that l . labels s  (g) S(Ss :: k, (\"l, \ns), m) -S(k, (\"l, Ss[ s ]), m) provided that l /. labels s  Note that the selection of redexes in Rule \n2a, 2b, and 2c is non\u00ad deterministic. Moreover, note that the rules 6c and 6f overlap, and that the splitting \ninto Ss and s in rule 6f is non-deterministic. DE FIN I T I ON 4.11. We let * denote the re.exive-transitive \nclo\u00ad _ sure of , and let n denote paths of = n -reduction steps. Execution of a statement S(k, (d, s), \nm) is performed by traversing through the program context k and statement s in di\u00adrection d. The direction \ndown ' (respectively up /) is used to tra\u00adverse downwards (respectively upwards) to the next substatement \nthat has to be executed. When a substatement Se[ e ] containing an expression e has been reached (Rule \n1c), the location of the expression Se is stored on the program context, and execution is continued in \nS((Se, e) :: k, e, m). Execution of an expression S(k, e, m) is performed by non\u00addeterministically decomposing \ne into E[ e ' ]. Rule 2a allows e ' to perform a h-step, and Rule 2b allows e ' to perform a function \n_ ' call. If the redex e is unsafe and thereby cannot be contracted (e.g. because of a sequence violation \nor integer over.ow), Rule 2c ensures that the whole program reduces to the undef state. When execution \nof an expression has resulted in a value [v]O, we model a sequence point by unlocking O in memory (Rule \n3a-3f). For a function call S(k, E[ f([v0]O0 , . . . , [vn]On ) ], m), two reductions occur before the \nfunction body will be executed. The i .rst to S(resume E :: k, call f iv, unlock ( O) m) (Rule 2b) stores \nthe location of the caller on the program context and takes care of the sequence point before the function \ncall. The subsequent reduction to S(params ib :: resume E :: k, (' , s), m ' ) (Rule 5a) looks up the \ncallee s body s, allocates the parameters iv, and then performs a transition to execute the function \nbody s. We consider two directions for non-local control .ow: jump \"l and top .. v. After a goto l (Rule \n1b), the direction \"l is used to traverse to the substatement labeled l (Rule 6c-6g). Although this traversal \nis non-deterministic (in the case of duplicate labels), there are some side-conditions in order to ensure \nthat the reduction is not going back and forth between the same locations. This is re\u00adquired because \nwe may otherwise impose non-terminating behavior on terminating programs. The non-determinism could be \nremoved entirely by adding additional side-conditions. However, as we al\u00adready have other sources of \nnon-determinism, we omitted doing so to ease formalization. When execution of the expression e of a return \ne statement has resulted in a value v (Rule 3b), the direction .. v is used to tra\u00adverse to the top of \nthe whole statement (Rule 6a and 6b). When this traversal reaches the top of the statement, there are \ntwo reductions to give the return value v to the caller. The .rst reduction, from i S(params b :: resume \nE :: k, (.. v, s), m) to S(resume E :: k, return v, free ib m) (Rule 5c), deallocates the function parame\u00ad \nters, and the second reduction, to S(k, E[ v ], free ib m) (Rule 5d), resumes execution of the expression \nE[ v ] at the caller.  5. Axiomatic semantics Judgments of Hoare logic are triples {P } s {Q}, where \ns is a state\u00adment, and P and Q are assertions called the pre-and postcondition. The intuitive reading \nof such a triple is: if P holds for the memory before executing s, and execution of s terminates, then \nQ holds af\u00adterwards. For our language, we have two such judgments: one for expressions and one for statements. \nOur expression judgments are quadruples . f {P } e {Q}. As usual, P and Q are the pre-and postcondition \nof e respectively, but whereas P is just an assertion, Q is a function from values to assertions. It \nensures that if execution of e yields a value v, then Q v holds afterwards. The environment . is a .nite \nfunction from function names to their pre-and postconditions that is used to cope with (mutually) recursive \nfunctions. As in Krebbers and Wiedijk [21], our judgments for statements are sextuples .; R; J f {P } \ns {Q}, where R is a function from values to assertions, and J is a function from labels to assertions. \nThe assertion R v has to hold when executing a return e (for each value v obtained by execution of e), \nand J l is the jumping condition that has to hold when executing a goto l. We use a shallow embedding \nto represent assertions. This treat\u00adment is similar to that of Appel and Blazy [2], Von Oheimb [29], \nKrebbers and Wiedijk [21], etc. In order to talk about expressions without side-effects (assignments, \nallocation and deallocation, and function calls) in assertions (we need this for various rules of our \naxiomatic semantics, see De.nition 5.9), we de.ne an evaluation function for pure expressions. DEFINITION \n5.1. Evaluation [ e ] .,m of an expression e in a stack . and memory m is a partial function that is \nde.ned as: [ xi ] .,m := ptr b if . i = b [ v ] .,m := v [ load e ] .,m := m !! b if [ e ] .,m = ptr \nb [ e1 @ e2 ] .,m := [ e1 ] .,m @ [ e2 ] .,m [ e2 ] .,m if [ e1 ] .,m = v and istrue v [ e1 ? e2 : e3 \n] .,m := [ e3 ] .,m if [ e1 ] .,m = v and isfalse v [ (t ) e ] .,m := (t ) [ e ] .,m DEFINITION 5.2. \nAssertions are predicates over the the stack and the memory. We de.ne the following connectives on assertions. \nP . Q := .. m . P . m . Q . m .x . P x := .. m . .x . P x . m P . Q := .. m . P . m . Q . m .x . P x \n:= .. m . .x . P x . m P . Q := .. m . P . m . Q . m 'P ' := .. m . P \u00acP := .. m . \u00acP . m e . v := .. \nm . [ e ] .,m = v We treat ' ' as an implicit coercion, e.g. we write True instead of 'True'. Also, we \noften lift these connectives to functions to assertions, e.g. we write P . Q instead of .v . P v . Q \nv. DEFINITION 5.3. We let P F Q denote that for all stacks . and memories m we have P . m implies Q . \nm. DEFINITION 5.4. An assertion P is called stack independent if for all .1, .2 . stack and m . mem with \nP .1 m we have P .2 m. Similarly, P is called unlock independent if for all . . stack, m . mem and O \n. index with P . m we have P . (unlock O m). Next, we de.ne the assertions of separation logic [28]. \nThe separating conjunction P * Q asserts that the memory can be split into two disjoint parts such that \nP holds in the one part, and Q in the other (due to the use of fractional permissions, these parts may \noverlap as long as their permissions are disjoint and their values . agree). Finally, e1 . e2 asserts \nthat the memory consists of exactly one object at e1 with contents e2 and permission .. DEFINITION 5.5. \nThe connectives of separation logic are: emp := .. m . m = \u00d8 P * Q := .. m . .m1 m2 . m = m1 . m2 . m1 \n. m2 . P .m1 . Q . m2 . e1 . e2 := .. m . .b v . [ e1 ] .,m = ptr b . [ e2 ] .,m = v . m = {(b, (v, .))} \n.. e1 . := .e2 . e1 . e2 To enforce the sequence point restriction, the rule for assign\u00ad . ment changes \nthe permission . of e1 . e2 into lock .. Subsequent reads and writes are therefore no longer possible. \nAt constructs that have a sequence point, we use the assertion P C to release these locks, and to make \nfuture reads and writes possible again. DEFINITION 5.6. The unlocking assertion P C is de.ned as: P C \n:= .. m . P . (unlock (locks m) m). We proved properties as P C * Q C F (P * Q) C to push the C-connective \nthrough an assertion. Similar to Krebbers and Wiedijk [21], we need to lift an asser\u00adtion such that the \nDe Bruijn indices of its variables are increased so as to deal with block scope variables. The lifting \nP . of P is de.ned semantically, and we prove that it behaves as expected. DEFINITION 5.7. The lifting \nassertion P . is de.ned as: P . := .. m . P (tail .) m. LEMMA 5.8. The operation ( ) . distributes over \nthe connectives ., ., ., \u00ac, ., ., and *. We have (e . v) . = (e .) . v and .. (e1 . e2) . = (e1 .) . \n(e2 .), where the operation e. replaces each variable xi in e by xi+1. The speci.cation of a function \nwith parameters iv consists of an assertion P iy iv called the precondition, and a function Q iy iv from \n(return) values to assertions called the postcondition. We allow universal quanti.cation over arbitrary \nlogical variables iy in order to relate the pre-and postcondition. The pre-and postcondition should moreover \nbe stack independent because local variables will have a different meaning at the caller than at callee. \nWe denote such a speci.cation as .iy .iv . {P iy iv} {Q iy iv}. DEFINITION 5.9. Given a .nite partial \nfunction d mapping func\u00adtion names to statements, the expression judgment . f {P } e {Q}and statement \njudgment .; R; J f {P } s {Q} of the axiomatic semantics are mutually inductively de.ned as shown in \nFigure 1. We have a frame, weaken, and exist rule for both the expression and statement judgments. The \ntraditional frame rule of separation logic [28] includes a side-condition modi.es s n free A = \u00d8. Like \nKrebbers and Wiedijk [21], we do not need this side-condition as our local variables are (immutable) \nreferences into the memory. Since the return and goto statements leave the normal control .ow, the postconditions \nof the (goto) and (return) rules are arbitrary. The rules for function calls are based on those by Krebbers \nand Wiedijk [21]. The (e-call) rule is used to call a function f(ie) that is already in .. The assertion \nB iv is used to frame a part of the memory that is used by ie but not by the f itself. The (add funs) \nrule can be used to add an arbitrary family . ' of speci.cations of (possibly mutually recursive) functions \nto .. For each function f in . ' with precondition P ' and postcondition Q ' , it has to be veri.ed that \nthe function body d f is correct for all instantiations of the logical variables iy and input values \niv. The pre\u00ad W.i condition .*[ xi . vi ] * P ' iy iv, where .*[ ei . e ' i ] denotes the  ' . f {P \n} e {Q} .x . (. f {P x} e {Q}) P F P . f {P } e {Q} (.v . Q v F Q ' v) (e-frame) (e-exists) (e-weaken) \n. f {A * P } e {A * Q} . f {.x . P x} e {Q} . f {P ' } e {Q ' } F P F e . v . f {P } e {.a . Q * a . \n} (e-base) (e-alloc) (e-free) ' F . f {P } e {.v ' . v = v . P } . f {emp} alloc {.a . a . } . f {P } \nfree e {. . Q} . kind . . f {P } e {.a . .v . Q a v * a = Locked . v} (e-load) . . f {P } load e {.v \n. .a . Q a v * a . v} . Write . kind . . f {P1} e1 {Q1} . f {P2} e2 {Q2} .av . (Q1 a * Q2 v F a . * \nR a v) (e-assign) . . f {P1 * P2} e1 := e2 {.v . .a . a . v * R a v} . f {P1} e1 {Q1} . f {P2} e2 {Q2} \n.v1 v2 . (Q1 v1 * Q2 v2 F .v . R v v1 v2 . v1 @ v2 . v) (e-binop) . f {P1 * P2} e1 @ e2 {.v . .v1 v2 \n. R v v1 v2} . f = (.bz . b' bz bz b.i . (. f {Pi} ei {Qi}) v . (.*[ Qi vi ] F P ' bv * A b.by bv F R \nv) w . {P w} {Q ' bw}) .by bv) v v . (Q ' bv v * A b (e-call) . f {.*[ Pb]} f(be) {R} '' ' . f {P } \ne1 {.v . v v C} . f {.v . istrue v . P v} e2 {Q} . f {.v . isfalse v . P v} e2 {Q} = indet . P (e-if) \n . f {P } e1 ? e2 : e3 {Q} .; R; J f {P } s {Q} .x . (.; R; J f {P x} s {Q}) (frame) (exists) .; A * \nR; A * J f {A * P } s {A * Q} .; R; J f {.x . P x} s {Q} ' .v . (R v F R ' v) .l . labels s . (J ' l \nF J l) .l /. labels s . (J l F J ' l) P F P .; R; J f {P } s {Q} Q F Q ' (weaken) ' .; R ' ; J f {P \n' } s {Q ' } . f {P } e {. . Q C} .; R; J f {P } s1 {P ' } .; R; J f {P ' } s2 {Q} (expr) (skip) (comp) \n.; R; J f {P } e {Q} .; R; J f {P } skip {P } .; R; J f {P } s1 ; s2 {Q} . f {P } e {R C} .; R; J f {J \nl} s {Q} (return) (label) (goto) .; R; J f {P } return e {Q} .; R; J f {J l} l : s {Q} .; R; J f {J \nl} goto l {Q} .... . = blockperm c .; x0 . * J .; x0 . * R . f {x0 . * P .} s {x0 . * Q .} (block) \n .; R; J f {P } block c s {Q} . f {P } e {.v . v .; R; J f {.v . istrue v . Q v} s {P } = indet . Q v \nC} (while) .; R; J f {P } while(e) s {.v . isfalse v . Q v} '' ' . f {P } e {.v . v v C} .; R; J f {.v \n. istrue v . P v} s1 {Q} .; R; J f {.v . isfalse v . P v} s1 {Q} (if) = indet . P .; R; J f {P } if (e) \ns1 else s2 {Q} .f P ' Q ' . . ' f = (.bw . {P ' bw} {Q ' bw}) . .bv z . bzbzbyb WWW ' b. ' . .; R; J \nf {P } s {Q} dom . ' . dom d (. ' . .; .l . False; .v . .*[ xi . ] * Q ' by bv v f {.*[ xi . vi ] * \nP y bv} d f {.*[ xi . ] * Q ' by bv indet}) (add funs) .; R; J f {P } s {Q} Figure 1. The rules of \nthe axiomatic semantics. .0' .n' assertion e0 . e0 * \u00b7 \u00b7 \u00b7 * en . en, states that the function param\u00adeters \nix are allocated with values iv for which the precondition P ' of W the function holds. The postcondition \n.*[ xi . ] * Q ' iy iv indet and returning condition .v . .*[ xi . ] * Q ' iv v ensure that the Wy \niparameters have not been deallocated during the execution of the function and that the postcondition \nQ ' holds for the return value. The jumping condition .l . False ensures that all gotos jump to a label \nthat occurs in the function body. Our axiomatic semantics is at least as powerful as an ordinary separation \nlogic for C because not only variants of the ordinary inference rules can be derived, but also derived \nrules for more complex constructs. For example .1.2 e1 . * e2 . * P F e3 . v .1.2.1.2 {e1 . * e2 . \n * P } e1 := e2 := e3 {e1 . v * e2 . v * P } provided that e1 and e2 are load-free, P is unlock independent \nand Write . kind .1, kind .2. 6. Soundness of the axiomatic semantics We will de.ne judgments . F {P \n} e {Q} (De.nition 6.6) and .; J; R F {P } s {Q} (De.nition 6.7) to describe partial program correctness. \nThe judgment . F {P } e {Q} guaranties that if the precondition P holds in m and S([ ], e, m) * S([ ], \n[v]O, m ' ), _ then the postcondition Q v holds in m '. Also, it ensures no unde\u00ad.ned behavior occurs \nfor each possible execution order. Soundness of the axiomatic semantics means that . f {P } e {Q} implies \n. F {P } e {Q} (and likewise for .; J; R F {P } s {Q}). We prove soundness (Theorem 6.8) by mutual induction \non the derivations of . f {P } e {Q} and .; J; R f {P } s {Q}. Hence, . F {P } e {Q} and .; J; R F {P \n} s {Q} should be suf.ciently strong so that we get appropriate induction hypotheses. The main dif.culty \nis that the subexpressions el and er in el @ er can do interleaved reduction steps. A simple minded de.nition \nof . F {P } e {Q} that only talks about the end result of executing e does not work, because we also \nneed to have information about states in between. Since the de.nitions of . F {P } e {Q} and .; J; R \nF {P } s {Q} have a lot in common, we de.ne a more general notion to factor out similarities.  Like \nKrebbers and Wiedijk [21], we have to enforce the reduc\u00adtion S(k, f, m) * S(k ' , f ' , m ' ) to remain \nbelow a certain pro\u00ad _ gram context. DEFINITION 6.1. The k-restricted reduction S1 k S2 is de.ned _ as \nS1 S2 provided k is a suf.x of the program context of S2. _ \u00af DEFINITION 6.2. Given a predicate P . stack \n\u00d7 mem \u00d7 focus, the judgment P\u00afFn l S (k, f, m) is inductively de.ned as: P\u00afF0 1. l S(k, f, m) 2. If \nP\u00af(getstack l) m f, then P\u00afFn l S (l, f, m). 3. If for all mf with m . mf we have  (a) S(k, f, m . \nmf ) is l-reducible, and _ (b) if S(k, f, m . mf ) l S2, then the state S2 is of the _ shape S(k2, f2, \nm2 . mf ) with m2 . mf , f = undef, locks f2 . locks m2, and P\u00afFn l S (k2, f2, m2), P\u00afF1+n then l S(k, \nf, m). \u00afFn The intuitive meaning of P l S(k, f, m) is that all l \u00ad _ reductions paths of at most n steps \nstarting at S(k, f, m . mf ): do not get stuck, and do not end up in the undef state,  always satisfy \nlocks f . locks m during the execution, and  \u00af the end-state satis.es P and has program context l. To \nhandle interleaving of expressions, we allow the framing mem\u00adory mf to change at each step during the \nexecution. Hence, instead of de.ning P\u00afFn l S (k, f, m) using the re.exive transitive closure of l, we \nde.ned it inductively using single steps. The condition _ locks f2 . locks m2 on the annotated locks \nwith respect to the locks in the memory is used to separate the locks of subexpressions. We use a step-indexed \napproach to handle function calls. \u00afFn The judgment P l S(k, f, m) enjoys a nice composition property, \nand satis.es an abstract version of the weakening and frame rule of separation logic. LEMMA 6.3. Given \ncontexts k1, k2 and k3 with k2 a suf.x of k1 P\u00afFn and k3 a suf.x of k2. If (a) k2 S(k1, f, m), and (b) \nfor all m ' ' f ' and f ' with P\u00af(getstack k2) m we have Q\u00afFn k3 S (k2, f ' , m ' ), \u00af then .nally we \nhave Q Fn k3 S(k1, f ' , m). LEMMA 6.4. Given memories m and m2 such that m . m2. If (a) P\u00afFn l S (k, \nf, m), and (b) for all m ' and f ' with m ' . m2 and P\u00af(getstack l) m ' f ' we have Q\u00af(getstack l) (m \n' . m2) f, then .nally we have Q\u00afFn l S (k, f, m . m2). DEFINITION 6.5. Validity of the environment ., \nnotation Fn . is de.ned as: for all f with . f = (.iy . .iv . {P iy iv} {Q iy iv}) and P iy iv (getstack \nk) m we have Q\u00afgy,gv Fn k S (call f iv, k, m). Here, \u00af Qgv is de.ned as: y,g \u00af Qgv := .. f m ' . .v . \nf = return v . locks m = \u00d8 . Q by bv v . m ' . y,g DEFINITION 6.6. Partial correctness of an expression \ne, notation . F {P } e {Q} is de.ned as: if Fn ., locks e = locks m = \u00d8 Q\u00afFn \u00af and P d (getstack k) m, \nthen k S(e, k, m). Here Q is de.ned as: \u00af Q := .. f m ' . .v O . f = [v]O . locks m = O . Q v . m ' . \nKrebbers and Wiedijk [21] noticed that the assertions P , Q, J and R in .; J; R F {P } s {Q} correspond \nto the four directions ' , /, \" and .. in which traversal through a statement is performed. Hence, we \ntreat .; J; R F {P } s {Q} as a triple .; PiF s, where Piis a function from directions to assertions \nsuch that Pi' = P , Pi/ = Q, Pi(\"l) = J l and Pi(.. v) = R v. DEFINITION 6.7. Partial correctness of \na statement s, notation .; PiF s is de.ned as: if Fn ., down d s, locks s = locks m = \u00d8 i\u00afFn and P d \n(getstack k) m, then Ps k S((d, s), k, m). Here, '' ' down holds if down ' s or down (\"l) s with l . \nlabels s , and Ps is de.ned as: \u00af ' P\u00afs := .. f m ' . .d ' s . f = (d ' , s ' ) . \u00acdown d ' s P d ' . \nm ' ' . locks m = \u00d8 . b. THEOREM 6.8 (Soundness). We have: 1. . f {P } e {Q} implies . F {P } e {Q}, \nand 2. .; J; R f {P } s {Q} implies .; J; R F {P } s {Q}.  This theorem is proven by mutual induction \non the derivation of . f {P } e {Q} and .; J; R f {P } s {Q}. Thus, for each rule of the axiomatic semantics, \nwe have to show that it holds in the model. In order to prove the (e-base) case, we need to show that \nthe expression evaluation [ e ] .,m is sound with respect to the operational semantics. To prove the \ncases of the other expressions constructs, we use the following generic lemma that deals with the subtleties \nof interleaving subexpressions. LEMMA 6.9. Given a singular expression context E with u holes and locks \nE = \u00d8, memories m with . ie with im, expressions ilocks ei . locks mi for each i < u, and functions of \nvalues to assertions Piand Q. Now, if 1. P\u00afi Fk n S (k, ei, mi) for each i < u, and 2. for all Oi, im \n' m ' ,  v and iwith. i (a) locks mi = Oi for each i < u, and (b) Pi vi k, m ' i for each i < u, we \nhave Q\u00afFk n S (k, E[ [v0]O0 . . . [vn]On ], m i' ), Q\u00afFn then k S(k, E[ ii e ], m). The previous lemma \nis proven by induction on the number of steps n. Theorem 2.13 is used to reason about disjoint memories. \nThe proofs of the cases for the statement judgments are quite similar to those by Krebbers and Wiedijk \n[21]; they involve chasing all possible reduction paths and use Lemma 6.3. We refer to the Coq formalization \nfor the actual proofs. 7. Extensions In this section we describe two extensions of our axiomatic se\u00admantics \nthat improve handling of function calls. The .rst exten\u00adsion makes it easier to deal with pure functions \n(i.e. functions that have no side-effects), whereas the second extension enables differ\u00adent function \ncalls in the same expression to have access to a shared writable part of the memory. These extensions \ndo not change the memory model or the operational semantics. We make it possible to associate a mathematical \nfunction to a pure function. For example, this can be used to smoothly use Coq s gcd function to reason \nabout its counterpart in C. We extend the environment . to map function names to: 1. Speci.cations of \npure functions by partial Coq functions, or, 2. Speci.cations of impure functions using their pre-and \npostcon\u00addition .iy .iv . {P iy iv} {Q iy iv}.   The (add funs) rule is extended so that a pure function \nf with corresponding Coq function F : list val . valopt can be added to . by proving .iv . {emp . F iv \n= .} {.v . emp . F iv = v}. Assertions are made parametric with respect to the environment . so that \npure functions can be given an interpretation by [ e ] .,m. The (e-base) rule becomes: P F. e . v . f \n{P } e {.v ' . v = v ' . P } Apart from the parametrization by ., most rules of the axiomatic semantics \nremain unchanged. To prove soundness of the (e-base) rule, we now also have to deal with pure function \ncalls. The rules for expressions of our axiomatic semantics require the memory to be separated into disjoint \nparts for the subexpressions el and er at each operator el @ er. Hence, only read-only memory can be \nshared by function calls that appear in both el and er. This is not very satisfactory, as functions (even \nwhen used in the same expression) often need to have access to shared data structures (e.g. a buffer \nor hash-table). To that end, we extend the expression judgment .; B f {P } e {Q} with an assertion B \nthat can be used to describe the invariant of shared memory by all function calls in e. The following \nframe rule can be used to move the memory out of the pre-and postcondition into the assertion B.  .; \nA * B f {P } e {Q} .; B f {P * A} e {Q * A} The rule (e-call) for function calls is changed so that B \ncan be used to prove the precondition, and so that B has to be reobtained from the postcondition when \nthe function call is .nished. For the soundness proof, we need to generalize De.nition 6.2 so that the \nmemory of B is part of the framing memory mf during execution of the expression, and so that is will \nbe transferred to the active memory at a function call. This extension still does not give completeness \nof the axiomatic semantics though. Consider: int x = 0; int f(int y) { return (x = y); } int main() { \nf(3) + f(4); return x; } Since the invariant B should hold before, after, and in between the function \ncalls in the expression f(3) + f(4), the best choice for WWW it is x . 0 . x . 3 . x . 4. Hence, one \ncan only prove that the program returns 0, 3 or 4 in the end, whereas it actually returns 3 or 4. We \nbelieve programs as the above are arti.cial, and such non-determinism is not frequent in actual C programs. \n8. Formalization in Coq All proofs in this paper have been fully formalized using the Coq proof assistant. \nFormalization has been of great help in order to develop and debug the semantics. We used Coq s notation \nmech\u00adanism combined with unicode symbols and type classes for over\u00adloading to let the Coq development \ncorrespond as well as possible to the de.nitions in this paper. However, in this paper, we presented \nthe axiomatic semantics as an inference system, and showed that it has a model. Since we did not consider \ncompleteness, we directly proved all rules to be derivable with respect to the model. We used Coq s type \nclasses to provide abstract interfaces for commonly used structures like .nite sets and .nite partial \nfunc\u00adtions, so that we were able to prove theory and implement automa\u00adtion in an abstract way. Our approach \nis greatly inspired by the un\u00adbundled approach of Spitters and van der Weegen [33]. However, whereas \ntheir work heavily relies on setoids (types equipped with an equivalence relation), we tried to avoid \nthat by using Leibniz equality as much as possible. In particular, our interface for .nite partial functions \nrequires extensionality with respect to Leibniz equality, i.e. m1 = m2 iff .x . m1 x = m2 x. Extensional \nequality of .nite partial functions is particularly useful for dealing with assertions, which are de.ned \nas predicates on the stack and memory (De.nition 5.2). Due to extensionality, we did not have to equip \nassertions with a proof that they respect extensional equality on memories. Although intensional type \ntheories like Coq do not satisfy exten\u00adsionality, .nite functions indexed by a countable type can still \nbe implemented in a way that extensionality holds. This is achieved by representing .nite functions as \ntrees in canonical form. Coq s support for dependent types has been particularly useful to formulate \nLemma 6.9 where we have to deal with expression contexts with multiple holes. We represented these expression \ncon\u00adtexts using a type indexed by the number of holes. Because the semantics described in this paper \nis rather big, it is quite cumbersome to prove properties about it without automation. In particular, \nthe reduction (De.nition 4.10) is de.ned as an _ inductive type consisting of 33 constructors. To this \nend, we have automated many steps of the proofs. For example, we implemented a tactic do_cstep to automatically \nperform reduction steps and to solve the required side-conditions, a tactic inv_cstep to per\u00adform case \nanalyzes on reductions and to automatically discharge impossible cases, and a tactic solve_mem_disjoint \nto automat\u00adically prove disjointness of memories using the algebraic method described in Section 2. Ongoing \nexperiments show that this ap\u00adproach is successful, as the semantics can be extended easily with\u00adout \nhaving to redo many proofs. Our Coq code, available at http://robbertkrebbers.nl/ research/ch2o, is about \n10 000 lines of code including comments and white space. Apart from that, our library on general purpose \ntheory (.nite sets, .nite functions, lists, etc.) is about 9 000 lines. 9. Conclusions and further research \nThe further reaching goal of this work is to develop an operational and axiomatic semantics for a large \npart of the C11 programming language [20]. Formal treatment of non-determinism and sequence points in \nexpressions with side-effects is a necessary step towards this goal. Our next step is to integrate the \nwork of Krebbers [19] on the C memory model and type system into our formalization, and make the language \ntyped. Once integrated, we intend to develop a veri.ed type checker and interpreter so we can test the \nsemantics using actual C programs. Extending our operational semantics to deal with concurrency is also \nan interesting topic for future research. For example, it would be useful to investigate whether our \nsemantics can be extended to weak memories in the same way as CompCert has been extended to CompCert \nTSO [32]. In order to turn the theory presented in this paper into an actual tool for veri.cation of \nC programs, we need to develop a veri.ca\u00adtion condition generator. A veri.cation condition generator \ntakes a program with logical annotations and generates a set of veri.ca\u00adtion conditions that need to \nbe veri.ed. For ordinary Hoare logic, the most common approach is to use a variant of Dijkstra s weak\u00adest \nprecondition calculus. For separation logic, one typically uses symbolic execution (see for example Berdine \net al. [4]). In case of our axiomatic semantics, it is not directly clear whether any of these two approaches \ncan be applied. The problematic part is that in the rules for binary operations, one has to split the \nmemory in two parts using the separating conjunction *. It would be interesting to investigate how this \ncan be automated. Another challenge to use our axiomatic semantics for program veri.cation is strong \nautomation for separation logic. Speci.c to the Coq proof assistant there has been work on this by for \nexample Appel [1], Chlipala [10], and Bengtson et al. [3]. As shown in Section 7, our axiomatic semantics \nis not complete with respect to the operational semantics. Nonetheless, as demon\u00adstrated in Section 5, \nwe can derive the ordinary rules of separation logic, and rules speci.cally tailored for certain constructs. \nIt would be useful to investigate whether it is complete for another variant of the operational semantics. \n Due to our local treatment of locks to model the sequence point restriction, our operational semantics \nassigns unde.ned behavior to more programs than the C11 standard does (see page 5). We believe that this \nis a reasonable trade-off, because it brings the operational semantics closer to the axiomatic semantics, \nand only makes arti.cial programs illegal. Moreover, this treatment of locks may enable some useful optimizations \nthat are not allowed by the C11 standard. A particular optimization that is not justi.ed by the C11 stan\u00addard \nis CompCert [23] s passing by reference of struct and union values through expressions. In CompCert, \ncopies of struct and union values are made only at function calls and assignments. Let us take a look \nat the following example. struct S { int x; } s1 = { 1 }, s2 = { 2 }; int f() { if (s1.x == 2) { s2.x \n= 40; } return 0; } int main() { return (s1 = s2).x + f(); } The execution order where the CompCert semantics \ndeviates from the C11 standard is: (a) perform the assignment s1 = s2 whose result is a reference to \ns2 instead of a copy of s2, (b) call f, which uses an if (s1.x == 2) to detect that the assignment s1 \n= s2 has been executed, and .nally (c) the .eld x of the struct that has been modi.ed by f is taken. \nThe return value for this execution order is 40, which cannot be obtained from any execution order if \nstructs were passed by value. Using a global treatment of sequence points (as in Ellison and Rosu [12] \nor Norrish [26]), no execution order of this program leads to a sequence point violation. However, with \nour local treatment of sequence points, the execution order described above will exhibit a sequence point \nviolation, and hence our treatment would justify by reference passing of struct values for this program. \nIt would be interesting to investigate whether our semantics of sequence points justi.es by reference \npassing of struct and union values through expressions for arbitrary programs. Acknowledgments I thank \nmy advisors Freek Wiedijk and Herman Geuvers, and the anonymous referees for their helpful suggestions. \nI am indebted to Xavier Leroy for many useful discussions. This work is .nanced by the Netherlands Organisation \nfor Scienti.c Research (NWO). References [1] A. W. Appel. Tactics for Separation Logic, 2006. Available \nat http: //www.cs.princeton.edu/~appel/papers/septacs.pdf. [2] A. W. Appel and S. Blazy. Separation Logic \nfor Small-Step Cminor. In TPHOLs, volume 4732 of LNCS, pages 5 21, 2007. [3] J. Bengtson, J. B. Jensen, \nand L. Birkedal. Charge! -A Framework for Higher-Order Separation Logic in Coq. In ITP, volume 7406 of \nLNCS, pages 315 331, 2012. [4] J. Berdine, C. Calcagno, and P. W. O Hearn. Symbolic Execution with Separation \nLogic. In APLAS, volume 3780 of LNCS, pages 52 68, 2005. [5] P. E. Black and P. J. Windley. Inference \nRules for Programming Languages with Side Effects in Expressions. In TPHOLs, volume 1125 of LNCS, pages \n51 60, 1996. [6] R. Bornat, C. Calcagno, P. W. O Hearn, and M. J. Parkinson. Per\u00admission Accounting in \nSeparation Logic. In POPL, pages 259 270, 2005. [7] J. Boyland. Checking Interference with Fractional \nPermissions. In SAS, volume 2694 of LNCS, pages 55 72, 2003. [8] C. Calcagno, P. W. O Hearn, and H. Yang. \nLocal Action and Abstract Separation Logic. In LICS, pages 366 378, 2007. [9] B. Campbell. An Executable \nSemantics for CompCert C. In CPP, volume 7679 of LNCS, pages 60 75, 2012. [10] A. Chlipala. Mostly-automated \nveri.cation of low-level programs in computational separation logic. In PLDI, pages 234 245. ACM, 2011. \n[11] R. Dockins, A. Hobor, and A. W. Appel. A Fresh Look at Separation Algebras and Share Accounting. \nIn APLAS, volume 5904 of LNCS, pages 161 177, 2009. [12] C. Ellison and G. Rosu. An executable formal \nsemantics of C with applications. In POPL, pages 533 544, 2012. [13] C. Ellison and G. Rosu. Slides of \n[12], 2012. http://fsl.cs.uiuc. edu/pubs/ellison-rosu-2012-popl-slides.pdf. [14] M. Felleisen, D. P. \nFriedman, E. E. Kohlbecker, and B. F. Duba. A syntactic theory of sequential control. Theoretical Computer \nScience, 52:205 237, 1987. [15] P. Herms. Certi.cation of a Tool Chain for Deductive Program Veri.cation. \nPhD thesis, l Universit\u00b4e Paris-Sud, 2013. [16] International Organization for Standardization. ISO/IEC \n9899-2011: Programming languages C. ISO Working Group 14, 2012. [17] B. W. Kernighan and D. M. Ritchie. \nThe C Programming Language. Prentice Hall, 2nd edition, 1988. [18] R. Krebbers. Non-determinism and sequence \npoints in C (blog post), 2013. Available at http://gallium.inria.fr/blog/ non-determinism-and-sequence-points-in-c/. \n[19] R. Krebbers. Aliasing restrictions of C11 formalized in Coq. In CPP, volume 8307 of LNCS, 2013. \n[20] R. Krebbers and F. Wiedijk. A Formalization of the C99 Standard in HOL, Isabelle and Coq. In CICM, \nvolume 6824 of LNAI, pages 297 299, 2011. [21] R. Krebbers and F. Wiedijk. Separation Logic for Non-local \nControl Flow and Block Scope Variables. In FoSSaCS, volume 7794 of LNCS, pages 257 272, 2013. [22] X. \nLeroy. A formally veri.ed compiler back-end. Journal of Auto\u00admated Reasoning, 43(4):363 446, 2009. [23] \nX. Leroy. The CompCert veri.ed compiler, software and commented proof. Available at http://compcert.inria.fr/, \n2012. [24] X. Leroy, A. W. Appel, S. Blazy, and G. Stewart. The CompCert Memory Model, Version 2. Research \nreport RR-7987, INRIA, 2012. [25] M. Norrish. C formalised in HOL. PhD thesis, University of Cam\u00adbridge, \n1998. [26] M. Norrish. Deterministic Expressions in C. In ESOP, volume 1576 of LNCS, pages 147 161, 1999. \n[27] P. W. O Hearn. Resources, Concurrency and Local Reasoning. In CONCUR, volume 3170 of LNCS, pages \n49 67, 2004. [28] P. W. O Hearn, J. C. Reynolds, and H. Yang. Local Reasoning about Programs that Alter \nData Structures. In CSL, volume 2142 of LNCS, pages 1 19, 2001. [29] D. v. Oheimb. Hoare logic for Java \nin Isabelle/HOL. Concurrency and Computation: Practice and Experience, 13(13):1173 1214, 2001. [30] N. \nPapaspyrou. A Formal Semantics for the C Programming Lan\u00adguage. PhD thesis, National Technical University \nof Athens, 1998. [31] J. Regehr, Y. Chen, P. Cuoq, E. Eide, C. Ellison, and X. Yang. Test\u00adcase reduction \nfor C compiler bugs. In PLDI, pages 335 346, 2012. [32] J. Sevc\u00b4ik, V. Vafeiadis, F. Z. Nardelli, S. \nJagannathan, and P. Sewell. CompCertTSO: A Veri.ed Compiler for Relaxed-Memory Concur\u00adrency. Journal \nof the ACM, 60(3):22, 2013. [33] B. Spitters and E. van der Weegen. Type classes for mathematics in type \ntheory. Mathematical Structures in Computer Science, 21(4): 795 825, 2011.  \n\t\t\t", "proc_id": "2535838", "abstract": "<p>The C11 standard of the C programming language does not specify the execution order of expressions. Besides, to make more effective optimizations possible (eg. delaying of side-effects and interleaving), it gives compilers in certain cases the freedom to use even more behaviors than just those of all execution orders.</p> <p>Widely used C compilers actually exploit this freedom given by the C standard for optimizations, so it should be taken seriously in formal verification. This paper presents an operational and axiomatic semantics (based on separation logic) for non-determinism and sequence points in C. We prove soundness of our axiomatic semantics with respect to our operational semantics. This proof has been fully formalized using the Coq proof assistant.</p>", "authors": [{"name": "Robbert Krebbers", "author_profile_id": "81488669469", "affiliation": "ICIS, Radboud University Nijmegen, Nijmegen, Netherlands", "person_id": "P4383761", "email_address": "mail@robbertkrebbers.nl", "orcid_id": ""}], "doi_number": "10.1145/2535838.2535878", "year": "2014", "article_id": "2535878", "conference": "POPL", "title": "An operational and axiomatic semantics for non-determinism and sequence points in C", "url": "http://dl.acm.org/citation.cfm?id=2535878"}