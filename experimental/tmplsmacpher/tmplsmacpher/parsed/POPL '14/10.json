{"article_publication_date": "01-08-2014", "fulltext": "\n NetKAT: Semantic Foundations for Networks Carolyn Jane Anderson Nate Foster Arjun Guha Swarthmore College \n* Cornell University University of Massachusetts Amherst * Jean-Baptiste Jeannin Dexter Kozen Carnegie \nMellon University * Cornell University Abstract Recent years have seen growing interest in high-level \nlanguages for programming networks. But the design of these languages has been largely ad hoc, driven \nmore by the needs of applications and the capabilities of network hardware than by foundational principles. \nThe lack of a semantic foundation has left language designers with little guidance in determining how \nto incorporate new features, and programmers without a means to reason precisely about their code. This \npaper presents NetK AT, a new network programming lan\u00adguage that is based on a solid mathematical foundation \nand comes equipped with a sound and complete equational theory. We describe the design of NetK AT, including \nprimitives for .ltering, modifying, and transmitting packets; union and sequential composition oper\u00adators; \nand a Kleene star operator that iterates programs. We show that NetK AT is an instance of a canonical \nand well-studied mathe\u00admatical structure called a Kleene algebra with tests (KAT) and prove that its \nequational theory is sound and complete with respect to its denotational semantics. Finally, we present \npractical applications of the equational theory including syntactic techniques for checking reachability, \nproving non-interference properties that ensure isola\u00adtion between programs, and establishing the correctness \nof compi\u00adlation algorithms. Categories and Subject Descriptors D.3.2 [Programming Lan\u00adguages]: Language \nClassi.cations Specialized application lan\u00adguages Keywords Software-de.ned networking, Frenetic, Network \npro\u00adgramming languages, Domain-speci.c languages, Kleene algebra with tests, NetKAT. 1. Introduction \nTraditional network devices have been called the last bastion of mainframe computing [9]. Unlike modern \ncomputers, which are * This work performed at Cornell University. Permission to make digital or hard \ncopies of all or part of this work for personal or classroom use is granted without fee provided that \ncopies are not made or distributed for pro.t or commercial advantage and that copies bear this notice \nand the full citation on the .rst page. Copyrights for components of this work owned by others than ACM \nmust be honored. Abstracting with credit is permitted. To copy otherwise, or republish, to post on servers \nor to redistribute to lists, requires prior speci.c permission and/or a fee. Request permissions from \npermissions@acm.org. POPL 14, January 22 24, 2014, San Diego, CA, USA. Copyright c &#38;#169; 2014 ACM \n978-1-4503-2544-8/14/01. . . $15.00. http://dx.doi.org/10.1145/2535838.2535862 Cole Schlesinger David \nWalker Princeton University Princeton University implemented with commodity hardware and programmed \nusing standard interfaces, networks have been built the same way since the 1970s: out of special-purpose \ndevices such as routers, switches, .rewalls, load balancers, and middle-boxes, each implemented with \ncustom hardware and programmed using proprietary inter\u00adfaces. This design makes it dif.cult to extend \nnetworks with new functionality and effectively impossible to reason precisely about their behavior. \nHowever, a revolution has taken place with the recent rise of software-de.ned networking (SDN). In SD \nN, a general-purpose con\u00adtroller machine manages a collection of programmable switches. The controller \nresponds to network events such as new connec\u00adtions from hosts, topology changes, and shifts in traf.c \nload by re-programming the switches accordingly. Because the controller has a global view of the network, \nit is easy to use S DN to imple\u00adment a wide variety of standard applications such as shortest-path routing, \ntraf.c monitoring, and access control, as well as more so\u00adphisticated applications such as load balancing, \nintrusion detection, and fault-tolerance. A major appeal of S D N is that it de.nes open standards that \nany vendor can implement. For example, the OpenFlow A P I [21] clearly speci.es the capabilities and \nbehavior of switch hardware and de.nes a low-level language for manipulating their con.gura\u00adtions. However, \nprograms written directly for S D N platforms such as OpenFlow are akin to assembly: easy for hardware \nto implement, but dif.cult for humans to write. Network programming languages. In recent years, several \ndif\u00adferent research groups have proposed domain-speci.c languages for S D N [5 7, 23 25, 31, 32]. The \ngoal of these network pro\u00adgramming languages is to raise the level of abstraction of net\u00adwork programs \nabove hardware-oriented A PIs such as OpenFlow, thereby making it easier to build sophisticated and reliable \nS DN applications. For example, the languages developed in the Frenetic project [30] support a two-phase \nprogramming model: (i) a general\u00adpurpose program responds to network events by generating a static forwarding \npolicy; and (ii) the static policy is compiled and passed to a run-time system that con.gures the switches \nusing OpenFlow messages. This model balances expressiveness dynamic policies can be expressed by having \nthe general-purpose program generate a sequence of static policies and simplicity forwarding policies \nare written in a simple domain-speci.c language with a clear se\u00admantics, so programs can be analyzed \nand even veri.ed using au\u00adtomated tools [7, 26]. Still, it has never been clear what features a static \npolicy lan\u00adguage should support. The initial version of Frenetic [6] used sim\u00adple lists of predicate-action \nrules as policies, where the actions in\u00adcluded constructs for .ltering, forwarding, duplicating, and \nmodi\u00adfying packets. Subsequent versions of the language added (and later removed) the ability to embed \narbitrary packet-processing func\u00adtions in policies [23], as well as constructs for composing policies \nin parallel and sequence [24]. As Frenetic evolved, its designers added, removed, and modi.ed the meaning \nof primitives as dictated by the needs of applications. Without principles or metatheory to guide its \ndevelopment, its evolution has lacked clear direction and foresight. The ad hoc semantics has not made \nclear which primi\u00adtives are essential and which ones can be derived, and when new constructs have been \nadded to the language, it has not been clear how they should interact with existing constructs and what \nbehav\u00adioral laws they should obey.  An even more pressing issue is that these static policy lan\u00adguages \nonly specify the forwarding behavior of the switches in the network. However, when a network program \nis actually executed, end-to-end functionality is determined both by the behavior of the switches and \nby the structure of the network topology. To answer almost any interesting question about the network \nsuch as Can X connect to Y? , Is traf.c from A to B routed through Z? , or Is there a loop involving \nS? , the programmer must step outside the con.nes of the linguistic model and the abstractions it provides. \nTo summarize, we believe that a foundational model for network programming languages is essential. Such \na model should (i) iden\u00adtify the essential constructs for programming networks, (ii) provide guidelines \nfor incorporating new features, and (iii) unify reasoning about switches, topology and end-to-end behavior. \nSemantic foundations. This paper presents the .rst network pro\u00adgramming language that meets these criteria. \nTo begin, we focus on the global behavior of the network, unlike previous network programming languages, \nwhich have focused on the local behav\u00adior of individual switches. Abstractly, a network can be seen as \nan automaton that moves packets from node to node along the links in its topology. Hence, from a linguistic \nperspective, it is natural to use regular expressions, the language of .nite automata. Regu\u00adlar expressions \nare a standard way to specify the packet-processing behavior of a network: a path is encoded as a concatenation \nof pro\u00adcessing steps (p\u00b7q\u00b7\u00b7 \u00b7 \u00b7 ), a set of paths is encoded as a union of paths (p + q + \u00b7 \u00b7 \u00b7 ), and \niterated processing is encoded using Kleene star. Moreover, by modeling the network in this way, we get \na ready\u00admade theory for reasoning about formal properties: Kleene algebra (K A), a decades-old sound \nand complete equational theory of regu\u00adlar expressions. With Kleene algebra as the choice for representing \nglobal network structure, we can turn our attention to specifying local switch-processing functionality. \nFundamentally, a switch imple\u00adments predicates to match packets and actions that transform and forward \nmatching packets. Existing languages build various ab\u00adstractions atop the predicates and actions supplied \nby the hardware, but predicates and actions are essential. As a consequence, a foun\u00addational model for \nSD N must incorporate both Kleene algebra for reasoning about network structure and Boolean algebra for \nreason\u00ading about the predicates that de.ne switch behavior. Fortunately, these classic mathematical structures \nhave already been uni.ed in previous work on Kleene algebra with tests (K AT) [14]. By now K AT has a \nwell-developed metatheory, including an extensive model theory and results on expressiveness, deductive \ncompleteness, and complexity. The axioms of K AT are sound and complete over a variety of popular semantic \nmodels, including lan\u00adguage, relational, and trace models, and KAT has been applied suc\u00adcessfully in \na number of application areas, including compiler, de\u00advice driver, and communication protocol veri.cation \n[3, 15, 16, 22]. Moreover, equivalence in K AT has a P S PACE decision procedure. This paper applies \nthis theory to a new domain: networks. Figure 1. Example network. NetKAT. NetKAT is a new framework \nfor specifying, program\u00adming, and reasoning about networks based on Kleene algebra with tests. As a programming \nlanguage, NetK AT has a simple denota\u00adtional semantics inspired by NetCore [23], but modi.ed and ex\u00adtended \nin key ways to make it sound for KAT (which NetCore is not). In this respect, the semantic foundation \nprovided by K AT has delivered true guidance: the axioms of KAT dictate the interactions between primitive \nprogram actions, predicates, and other operators. Moreover, any future proposed primitive that violates \na K AT axiom can be summarily rejected for breaking the equations that allow us to reason effectively \nabout the network. NetK AT thus provides a foundational structure and consistent reasoning principles \nthat other network programming languages lack. For speci.cation and reasoning, NetK AT also provides \na .nite set of equations that capture equivalences between NetK AT pro\u00adgrams. The equational theory includes \nthe axioms of K AT, as well as domain-speci.c axioms that capture transformations on packets. This set \nof axioms enables reasoning about local switch processing functionality (needed in compilation and optimization) \nas well as global network behavior (needed to check reachability and traf.c isolation properties). We \nprove that the equational theory is sound and complete with respect to the denotational semantics. While \nthe soundness proof is straightforward, our proof of completeness is novel: we construct an alternate \nlanguage model for NetK AT and leverage the completeness of KA. To evaluate the practical utility of \nour theory and the expres\u00adsive power of NetK AT, we demonstrate how it can be used to rea\u00adson about a \ndiverse collection of applications. First, we show that NetKAT can answer a variety of interesting reachability \nqueries useful to network operators. Next, we state and prove a non\u00adinterference property for networks \nthat provides a strong form of isolation between NetKAT programs. Finally, we prove that NetK AT can \nbe correctly compiled to a low-level form analogous to switch .ow tables. In summary, the contributions \nof this paper are as follows: We develop a new semantic foundation for network program\u00adming languages \nbased on Kleene algebra with tests (KAT).  We formalize the NetKAT language in terms of a denotational \nsemantics and an axiomatic semantics based on KAT; we prove the equational axioms sound and complete \nwith respect to the denotational semantics.  We apply the equational theory in several diverse domains \nin\u00adcluding reasoning about reachability, traf.c isolation, and com\u00adpiler correctness.  The next section \npresents a simple example to motivate NetK AT and introduces the key elements of its design. The subsequent \nsections de.ne the language formally, develop its main theoretical properties, and present applications. \n2. Overview This section introduces the syntax and semantics of NetK AT using a simple example. Consider \nthe network shown in Figure 1. It consists of switches A and B, each with ports labeled 1 and 2, and \ntwo hosts. The switches and hosts are connected together in series. Suppose we want to con.gure the network \nto implement the following policies:  Forwarding: transfer packets between hosts, but  Access control: \nblock SSH packets.  The forwarding component is straightforward con.gure both switches to forward packets \ndestined for host 1 out port 1, and likewise for host 2 but there are several ways to implement the access \ncontrol component. We will develop two implementations and prove them equivalent using NetK AT s equational \ntheory. Forwarding. To warm up, let us de.ne a simple NetK AT policy that implements the forwarding component. \nTo a .rst approxima\u00adtion, a NetKAT policy can be thought of as a function from packets to sets of packets. \n(In the next section we will generalize this type to functions from lists of packets to sets of lists \nof packets, where the lists encode packet-processing histories, to support reasoning about network-wide \nproperties.) We represent a packet as a record with .elds for standard headers such as source address \n(src), desti\u00adnation address (dst), and protocol type (typ), as well as two .elds, switch (sw) and port \n(pt), that identify the current location of the packet in the network. Atomic NetK AT policies .lter \nand modify packets. A .lter (f = n) takes any input packet pk and yields the singleton set {pk} if .eld \nf of pk equals n, and {} otherwise. A modi.cation (f . n) takes any input packet pk and yields the singleton \nset {pk'}, where pk' is the packet obtained from pk by setting f to n. To allow programmers to express \nmore sophisticated policies, NetK AT also has policy combinators that build bigger policies out of smaller \nones. The union combinator (p + q) generates the union of the sets produced by applying each of p and \nq to the input packet, while the sequential composition combinator (p\u00b7q) .rst applies p to the input \npacket, then applies q to each packet in the resulting set, and .nally takes the union of all of the \nresulting sets. With these operators, we can implement the forwarding policy as follows: p . (dst = H1 \n\u00b7 pt . 1) + (dst = H2 \u00b7 pt . 2) At the top level, this policy is the union of two sub-policies. The .rst \nupdates the pt .eld of all packets destined for H1 to 1 and drops all other packets, while the second \nupdates the pt .eld of all packets destined for H2 to 2. The union of the two generates the union of \ntheir behaviors in other words, the policy forwards packets across switches A and B in both directions. \nAccess control. Next, we extend the policy with access control. The simplest way to do this is to compose \na .lter that blocks S S H traf.c with the forwarding policy in sequence: pAC . \u00ac(typ = SSH) \u00b7 p This \npolicy drops the input packet if its typ .eld is S S H and oth\u00aderwise forwards it using p. Of course, \na quick inspection of the network topology shows that it is not necessary to test all packets at all \nlocations in the network to block S S H traf.c packets travel\u00ading between host 1 and host 2 must traverse \nboth switches, so it is suf.cient to .lter only at switch A, pA . (sw = A \u00b7 \u00ac(typ = SS H) \u00b7 p) + (sw \n= B \u00b7 p) or at switch B: pB . (sw = A \u00b7 p) + (sw = B \u00b7 \u00ac(typ = SSH) \u00b7 p) Both of these policies are more \ncomplicated than the original pol\u00adicy, but more ef.cient because they avoid having to store and en\u00adforce \nthe access control policy at both switches. Naturally, we would prefer one of the optimized policies. \nIn addition, we would like to be able to answer the following questions: Are non-S S H packets forwarded? \n Are S S H packets dropped?  Are pAC , pA, and pB equivalent?  Network administrators ask these sorts \nof questions whenever they write a network policy. However, note that we cannot answer them by inspecting \nthe policies alone the answers depend fundamen\u00adtally on the network topology. We will see how to incorporate \ntopol\u00adogy information into a NetKAT program next. Topology. A network topology is a directed graph with \nhosts and switches as nodes and links as edges. We can model the topology as the union of smaller policies \nthat encode the behavior of each link. To model an internal link, we use the sequential composition of \na .lter that retains packets located at one end of the link and a modi.cation that updates the sw and \npt .elds to the location at the other end of the link, thereby capturing the effect of sending a packet \nacross the link. To model a link at the perimeter of the network, we simply use a .lter that retains \npackets located at the ingress port. We assume that links are uni-directional, and encode bi-directional \nlinks using pairs of uni-directional links. For example, the following policy models the internal links \nbetween switches A and B, and the links at the perimeter to hosts 1 and 2: t = (sw = A \u00b7 pt = 2 \u00b7 sw \n. B \u00b7 pt . 1) + (sw = B \u00b7 pt = 1 \u00b7 sw . A \u00b7 pt . 2) + (sw = A \u00b7 pt = 1) + (sw = B \u00b7 pt = 2) Note that \nalthough we represent the links as policies, unlike switch policies, these link policies cannot actually \nbe controlled programmatically they must be consistent with the structure of the underlying physical \ntopology. Switches meet topology. A packet traverses the network in inter\u00adleaved steps of processing \nby the switches and topology. In our example, if host 1 sends a non-SSH packet to host 2, it is .rst \npro\u00adcessed by switch A, then the link between A and B, and .nally by switch B. This can be encoded by \nthe NetKAT term pAC \u00b7t\u00b7pAC . More generally, a packet may require an arbitrary number of steps in particular, \nif the topology has a cycle. Using the Kleene star oper\u00adator, which iterates a policy zero or more times, \nwe can encode the overall behavior of the network: (pAC \u00b7 t)* Note however that this policy processes \npackets that enter and exit the network at arbitrary locations, including at internal locations such \nas on the link between switches A and B. It is often useful to restrict attention to packets that enter \nand exit the network at speci.ed external locations e: e . (sw = A \u00b7 pt = 1) + (sw = B \u00b7 pt = 2) Using \nthis predicate, we can restrict the policy to packets sent or received by one of the hosts: pnet . e \n\u00b7 (pAC \u00b7 t)* \u00b7 e More generally, the input and output predicates may be distinct: in \u00b7 (p \u00b7 t)* \u00b7 out \nThis encoding is inspired by the model used in Header Space Analysis [10]. We call a network modeled \nin this way a logical crossbar [20], since it encodes end-to-end processing behavior (and elides internal \nprocessing steps). Section 3 discusses a more re.ned model that encodes hop-by-hop processing. Formal \nreasoning. We now turn to formal reasoning and inves\u00adtigate whether the logical crossbar correctly implements \nthe spec\u00adi.ed forwarding and access control policies. It turns out that these  Syntax Fields f ::= f1 \n| \u00b7 \u00b7\u00b7 | fk Packets pk ::= {f1 = v1, \u00b7 \u00b7 \u00b7 , fk = vk}Histories h ::= pk::() | pk::h Predicates a, b ::= \n1 Identity | 0 Drop | f = n Test | a + b Disjunction | a \u00b7 b Conjunction | \u00aca Negation Policies p, q \n::= a Filter | f . n Modi.cation | p + q Union | p \u00b7 q Sequential composition | p* Kleene star | dup \nDuplication Semantics [p] . H . P (H) [1] h {h} [0] h {} j Kleene Algebra Axioms p + (q + r) = (p + \nq) + r KA -PL U S -AS S O C p + q = q + p KA -PL U S -CO M M p + 0 = p KA -PL U S -Z E RO p + p = p KA \n-PL U S -ID E M p \u00b7 (q \u00b7 r) = (p \u00b7 q) \u00b7 r KA -SE Q -AS S O C 1 \u00b7 p = p KA -ON E -SE Q p \u00b7 1 = p KA -SE \nQ -ON E p \u00b7 (q + r) = p \u00b7 q + p \u00b7 r KA -SE Q -DI S T-L (p + q) \u00b7 r = p \u00b7 r + q \u00b7 r KA -SE Q -DI S T-R \n0 \u00b7 p = 0 KA -ZE RO -S E Q p \u00b7 0 = 0 KA -SE Q -ZE RO 1 + p \u00b7 p* = p* KA -UN RO L L -L q + p \u00b7 r = r . \np* \u00b7 q = r KA -LF P -L 1 + p* \u00b7 p = p* KA -UN RO L L -R p + q \u00b7 r = q . p \u00b7 r * = q KA -LF P -R Additional \nBoolean Algebra Axioms a + (b \u00b7 c) = (a + b) \u00b7 (a + c) BA -PL U S -DI S T a + 1 = 1 BA -PL U S -ON E \na + \u00aca = 1 BA -EX C L -MI D a \u00b7 b = b \u00b7 a BA -SE Q -C O M M a \u00b7 \u00aca = 0 BA -C O N T R A a \u00b7 a = a BA -SE \nQ -I D E M {pk::h} if pk.f = n {} otherwise [f = n] (pk::h) [\u00aca] h Packet Algebra Axioms '''' ' f . \nn \u00b7 f . n = f . n \u00b7 f . n, if f PA-MO D -MO D -C O M M = f '''' ' f . n \u00b7 f = n = f = n \u00b7 f . n, if \nf PA-MO D -FI LT E R -CO M M = f {h} \\ ([a] h) [f . n] (pk::h) {pk[f := n]::h} [p] h . [q] h [p + q] \nh dup \u00b7 f = n = f = n \u00b7 dup PA-DU P -FI LT E R -CO M M f . n \u00b7 f = n = f . n PA-MO D -FI LT E R f = \nn \u00b7 f . n = f = n PA-FI LT E R -MO D ' ' f . n \u00b7 f . n = f . n PA-MO D -MO D [p \u00b7 q] h [q]) h ([p] \n[p*] h i.N F i h where F 0 h {h} and F i+1 h S F i) h ([p] ' ' = 0, if n PA-CO N T R A = n P = n \u00b7 \nf {pk::(pk::h)} f = i = 1 PA-MAT C H -A L L i f = n [dup] (pk::h) Figure 2. NetKAT: syntax, semantics, \nand equational axioms. questions, and many others, can be reduced to policy equivalence. We write p = \nq when p and q return the same set of packets on all inputs, and p = q when p returns a subset of the \npackets returned by q on all inputs. (Note that p = q can be treated as an abbrevia\u00adtion for p + q = \nq.) To establish that pnet correctly .lters all S S H packets going from port 1 on switch A to port 2 \non switch B, we check the following equivalence, where 0 is the .ltering policy that drops all packets: \nFinally, to establish that pAC correctly forwards non-S S H packets from H1 to H2, we check the following \ninclusion: (\u00ac(typ = S SH) \u00b7 sw = A \u00b7 pt = 1 \u00b7 sw . B \u00b7 pt . 2) = (pAC \u00b7 t)* and similarly for non-SS \nH packets H2 to H1. Of course, to actually check these equivalences formally, we need a proof system. \nNetKAT is designed to not only be an expres\u00adsive programming language, but also one that satis.es the \naxioms 0 @ typ = S S H \u00b7 sw = A \u00b7 pt = 1 \u00b7 (pAC \u00b7 t)* \u00b7 1 A = 0 of a Kleene algebra with tests (KAT). \nMoreover, by extending K AT with additional axioms that capture the domain-speci.c features of sw = \nB \u00b7 pt = 2 networks, the equational theory is complete i.e., it can answer all the questions posed in \nthis section, and many more. The follow-To establish that the optimized policies pA and pB correctly \n.lter ing sections present the syntax, semantics, and equational theory S S H packets going from port \n1 on switch A to port 2 on switch B, of NetKAT formally (Section 3); prove that the equational theory \nwe check the following equivalences, is sound and complete with respect to the semantics (Section 4); \ntyp = S S H \u00b7 sw = A \u00b7 pt = 1 \u00b7 (pA \u00b7 t)* \u00b7 1 A = 0 and illustrate its effectiveness on a broad range \nof questions includ\u00ading additional reachability properties (Section 5), program isolation (Section 6) \nand compiler correctness (Section 7). 0 @ sw = B \u00b7 pt = 2 3. NetKAT and: typ = S S H \u00b7 sw = A \u00b7 pt \n= 1 \u00b7 (pB \u00b7 t)* \u00b7 1 A = 0 This section de.nes the syntax and semantics of NetKAT formally. Preliminaries. \nA packet pk is a record with .elds f1, . . . , fk map\u00ad sw = B \u00b7 pt = 2 ping to .xed-width integers n. \nWe assume a .nite set of packet headers, including Ethernet source and destination addresses, V L A \nN tag, IP source and destination addresses, T C P and U DP source and destination ports, along with special \n.elds for the switch (sw), port (pt), and payload. For simplicity, we assume that every packet contains \nthe same .elds. We write pk.f for the value in .eld f of pk, and pk[f := n] for the packet obtained from \npk by updating .eld f to n. To facilitate reasoning about the paths a packet takes through the network, \nwe maintain a packet history that records the state of each packet as it travels from switch to switch. \nFormally, a packet history h is a non-empty sequence of packets. We write pk::() to denote a history \nwith one element, pk::h to denote the history constructed by prepending pk on to h, and (pk1, . . . , \npk ) for the history with n elements pk1 to pkn. By convention, the .rst element of a history is the \ncurrent packet; other elements represent previously-processed packets. We write H for the set of all \nhistories, and P(H) for the powerset of H. Syntax. Syntactically, NetKAT expressions are divided into \ntwo categories: predicates (a, b) and policies (p, q). Predicates include constants true (1) and false \n(0), tests (f = n), and negation (\u00aca), disjunction (a+b), and conjunction (a\u00b7b) operators. Policies include \npredicates, modi.cations (f . n), union (p + q) and sequential composition (p \u00b7 q), iteration (p*), and \na special policy that records the current packet in the history (dup). The complete syntax of NetK AT \nis given in Figure 2. By convention, (*) binds tighter than (\u00b7), which binds tighter than (+). Hence, \na \u00b7 b + c \u00b7 d* is the same as (a \u00b7 b) + (c \u00b7 (d*)). Semantics. Semantically, every NetK AT predicate \nand policy de\u00adnotes a function that takes a history h and produces a (possibly empty) set of histories \n{h1, . . . , hn}. Producing the empty set mod\u00adels dropping the packet (and its history); producing a \nsingleton set models modifying or forwarding the packet to a single location; and producing a set with \nmultiple histories models modifying the packet in several ways or forwarding the packet to multiple loca\u00adtions. \nNote that policies only ever inspect or modify the .rst (cur\u00adrent) packet in the history. This means \nthat an implementation need not actually record histories they are only needed for reasoning. Figure \n2 de.nes the denotational semantics of NetK AT. Note that there is no separate de.nition for predicates \nevery predicate is a policy, and the semantics of (\u00b7) and (+) are the same whether they are composing \npolicies or predicates. The syntactic distinction between policies and predicates arises solely to ensure \nthat negation is only applied to a predicate, and not, for example, to a policy such as p*. Formally, \na predicate denotes a function that returns either the singleton {h} or the empty set {} when applied \nto a history h. Hence, predicates behave like .lters. A modi.cation (f . n) denotes a function that returns \na singleton history in which the .eld f of the current packet has been updated to n. The union operator \n(p + q) denotes a function that produces the union of the sets generated by p and q, and sequential composition \n(p\u00b7q) denotes the Kleisli composition ( ) of the functions p and q, where the Kleisli composition of \nfunctions of type H . P (H) is de.ned as: [ (f g) x {g y | y . f x} . Policy iteration p* is interpreted \nas a union of semantic functions Fi of h, where each Fi is the Kleisli composition of function denoted \nby p i times. Finally, dup denotes a function that duplicates the current packet and adds it to the history. \nSince modi.cation updates the packet at the head of the history, dup freezes the current state of the \npacket and makes it observable. Readers familiar with Frenetic and NetCore may notice some differences \nbetween the syntax used in previous network program\u00adming languages. This paper focuses on theoretical \nfoundations, so we use the traditional algebraic syntax for K AT, which con.ates a, b ::= 1 a,b ::= true \n| 0 | false | f = n | f = n | a + b | a or b | a \u00b7 b | a and b | \u00aca | not a p, q ::= a p,q ::= filter \na | f . n | f := n | p + q | p | q | p \u00b7 q | p ; q | p* | p* | dup | dup Figure 3. NetK AT algebraic \nand surface syntax. the (\u00b7) and (+) operators for predicates and programs and has con\u00adstants 0 and 1. \nFigure 3 shows the relationship between this alge\u00adbraic syntax and the surface syntax we use in programs. \nEquational theory. As its name suggests, NetKAT is a Kleene algebra with tests. Formally, a Kleene algebra \n(KA) is an algebraic structure, (K, +, \u00b7, * , 0, 1) where K is an idempotent semiring under (+, \u00b7, 0, \n1), and p* \u00b7 q (respectively q\u00b7p*) is the least solution of the af.ne linear inequality p \u00b7 r + q = r \n(respectively r \u00b7 p + q = r), where p = q is an abbreviation for p + q = q. The axioms of KA are listed \nin Figure 2. A Kleene algebra with tests (KAT) is a two-sorted algebraic structure, (K, B, +, \u00b7, * , \n0, 1, \u00ac) where \u00ac is a unary operator de.ned only on B, such that (K, +, \u00b7, * , 0, 1) is a Kleene algebra, \n (B, +, \u00b7, \u00ac , 0, 1) is a Boolean algebra, and  (B, +, \u00b7, 0, 1) is a subalgebra of (K, +, \u00b7, 0, 1). \n The axioms of Boolean algebra consist of the axioms of idempotent semirings (already listed as K A \naxioms) and the additional axioms listed in Figure 2. In previous work on KAT, the elements of B and \nK have usually been called tests and actions respectively; in this paper we will refer to them as predicates \nand policies. It is easy to see that NetKAT has the required syntactic structure to be a K AT. However, \nthe K AT axioms are not complete for the underlying NetK AT packet model. To establish completeness, \nwe also need the packet algebra axioms listed in Figure 2. The .rst three axioms specify commutativity \nconditions. For example, the axiom PA-MO D -MO D -C O M M states that assignments src . X and dst . Y \ncan be applied in either order, as src and dst are different: src . X \u00b7 dst . Y = dst . Y \u00b7 src . X Similarly, \naxiom PA -MO D -FI LT E R -C O M M states that the assignment src . X and predicate sw = A can be applied \nin either order. The axiom PA-D U P -F I LT E R -CO M M states that every predicate commutes with dup. \nInterestingly, only this single axiom is needed to char\u00adacterize dup in the equational theory. The next \nfew axioms charac\u00adterize modi.cations. The PA-M O D -F I LT E R axiom states that modi\u00adfying a .eld f \nto n and then .ltering on packets with f equal to n is equivalent to the modi.cation alone. Similarly, \nthe axiom PA -FI LT E R -M O D states that .ltering on packets with .eld f equal to n and then modifying \nthat .eld to n is equivalent to just the .lter. PA-M O D -M O D states that only the last assignment \nin a sequence of assignments to the same f has any effect. The .nal two axioms characterize .lters. The \naxiom PA-CO N T R A states that a .eld cannot be equal to two different values at the same time, while \nthe axiom  K AT-IN VA R I A N T If a \u00b7 p = p \u00b7 a then a \u00b7 p* = a \u00b7 (p \u00b7 a)* Lemma 2.3.2 in [14] K AT-SL \nI D I N G p \u00b7 (q \u00b7 p)* = (p \u00b7 q)* \u00b7 p Identity 19 in [14] K AT-DE N E S T I N G p* \u00b7 (q \u00b7 p*)* = (p + \nq)* Identity 20 in [14] K AT-CO M M U T E If for all atomic x in q, x \u00b7 p = p \u00b7 x then q \u00b7 p = p \u00b7 q \nCorollary of Lemma 4.4 in [2] Figure 4. K AT theorems. PA-MAT C H -AL L states that the sum of .lters \non every possible value is equivalent to the identity. This implies packet values are drawn from a .nite \ndomain, such as .xed-width integers. Example: access control. To illustrate the NetK AT equational theory, \nwe prove a simple equivalence in Figure 5 using the policies from Section 2. Recall that the policy pA \n.lters SSH packets on switch A while pB .lters S S H packets on switch B. We prove that these programs \nare equivalent on SSH traf.c going from left to right across the network topology shown in Figure 1. \nThis can be seen as a simple form of code motion relocating the .lter from switch A to switch B. We use \nthe logical crossbar encoding with the following input and output predicates: in (sw = A \u00b7 pt = 1) out \n(sw = B \u00b7 pt = 2) As a warm up, we .rst prove two simpler lemmas that will be useful for the main code \nmotion proof. The proofs of these lemmas are straightforward calculations using the NetKAT axioms and \nsome standard K AT theorems (given in Figure 4). We shade the term(s) on each line that will be changed \non the next step of the proof. To lighten the notation, we elide uses of axioms related to associativity, \nand use the following abbreviations: aA (sw = A) a1 (pt = 1) aB (sw = B) a2 (pt = 2) mA (sw . A) m1 (pt \n. 1) mB (sw . B) m2 (pt . 2) S S H (typ = S S H) Lemma 1 states that the sequential composition of the \ninput predicate, the predicate aB, and an arbitrary policy q is equivalent to the policy that drops all \npackets. Intuitively this holds because the input predicate matches packets on switch A and aB matches \npackets on switch B. Lemma 2 states that the sequential composi\u00adtion of an arbitrary policy q, the predicate \naA, the topology t from Section 2, and the output predicate is equivalent to the policy that drops all \npackets. Intuitively this holds because the topology does not forward packets located on any port of \nswitch A to port 2 of switch B. The proof is essentially a case analysis on the links in the topology. \nUsing these lemmas, we then prove Lemma 3, which states that pA and pB both drop SSH traf.c going from \nhost 1 to host 2. Formal statements of these lemmas and proofs using the NetK AT equational axioms can \nbe found in Figure 5. 4. Soundness, Completeness, and Decidability This section proves the soundness \nand completeness of the NetK AT axioms with respect to the denotational semantics de.ned in Sec\u00adtion \n3. More formally, these results state that every equivalence provable using the NetK AT axioms also holds \nin the denotational model (Theorem 1), and that every equivalence which holds in the denotational model \nis provable using the axioms (Theorem 2). We also prove the decidability of NetK AT equivalence, and \nshow that the problem is P S PACE-complete. To obtain these results, we prove theorems that are stronger \nand more enlightening from a theoretical point of view. For soundness, we prove that the packet-history \nmodel used in the denotational semantics is isomorphic to a model based on binary relations, and appeal \nto the soundness of K AT over binary relation models. For completeness, we develop a language model for \nNetKAT that plays the same role as regular sets of strings and guarded strings do for K A and K AT respectively. \nWe then relate the packet-history and language models, which allows us to leverage the completeness of \nK A to prove the completeness of the NetKAT axioms. 4.1 Soundness To prove soundness, we begin by reformulating \nthe standard packet-history semantics introduced in Section 3 in terms of bi\u00adnary relations. In the standard \nsemantics, policies and predicates are modeled as functions [p] . H . P (H). This semantics is isomorphic \nto a relational semantics [\u00b7] in which each policy and predicate is interpreted as a binary relation \n[p] . H \u00d7 H: (h1, h2) . [p] . h2 . [p] (h1). Intuitively, [p] is the set of input-output pairs of the \npolicy p. Formally, the maps [p] . H . P (H) are morphisms of type H . H in Kl P, the Kleisli category \nof the powerset monad. It is well known that the Kleisli category Kl P is isomorphic to the category \nRel of sets and binary relations, as witnessed by currying: = X . Y . 2 ~= P(X \u00d7 Y ). X . P (Y ) ~= X \n\u00d7 Y . 2 ~ In the relational model [\u00b7], product is interpreted as ordinary re\u00adlational composition, and \nthe remaining K AT operations translate under the isomorphism to the usual KAT operations on binary re\u00adlations. \nSince the relational model with these distinguished opera\u00adtions satis.es the axioms of K AT (see e.g. \n[14, 17]), so do NetK AT models with the packet-history semantics of Section 3. Let f denote provability \nin NetK AT. The following Theorem states the soundness of the NetK AT axioms. Theorem 1 (Soundness). \nThe KAT axioms and packet algebra axioms listed in Figure 2 are sound with respect to the semantics of \nSection 3. That is, if f p = q, then [p] = [q]. Proof sketch. We have already argued that the packet-history \nse\u00admantics is isomorphic to a relational K AT, and therefore satis.es the K AT axioms listed in Figure \n2. It remains to show that the addi\u00adtional packet algebra axioms on the right-hand side of Figure 2 are \nalso satis.ed. These can all be veri.ed by elementary arguments in relational algebra (see e.g. [28]). \nSome are special cases of [2, Equations (6) (11)], whose soundness is proved in [2, Theorem 4.3]. See \nthe long version of this paper for the full proof.  4.2 Completeness The proof of completeness proceeds \nin four steps: 1. We .rst de.ne reduced NetK AT, a subset of NetKAT where poli\u00adcies are regular expressions \nover complete tests (a normal form for sequences of tests), complete assignments (a normal form for sequences \nof modi.cations), and dup. We show that every NetKAT policy is provably equivalent to a reduced NetK \nAT pol\u00adicy and that reduced terms have a simpli.ed set of axioms per\u00adtaining to assignments and tests. \n 2. Inspired by past proofs of completeness for KA and KAT, we then develop a language model for reduced \nNetK AT. This lan\u00adguage model gives semantics to policies via sets of guarded   Lemma 1. in \u00b7 aB \u00b7 \nq = 0 Proof. in \u00b7 aB \u00b7 q = { de.nition in }aA \u00b7 a1 \u00b7 aB \u00b7 q = { K AT-CO M M U T E }aA \u00b7 aB \u00b7 a1 \u00b7 q = \n{ PA -CO N T R A }0 \u00b7 a1 \u00b7 q = { K A-ZE RO -SE Q } 0 Lemma 2. q \u00b7 aA \u00b7 t \u00b7 out = 0 Proof. q \u00b7 aA \u00b7 t \n\u00b7 out = { de.nition t } q \u00b7 aA \u00b7 (aA \u00b7 a2 \u00b7 mB \u00b7 m1 + aB \u00b7 a1 \u00b7 mA \u00b7 m2 + aA \u00b7 a1 + aB \u00b7 a2) \u00b7 out = \n{ KA-SE Q -DI S T-L, KA-SE Q -DI S T-R }q \u00b7 aA \u00b7 aA \u00b7 a2 \u00b7 mB \u00b7 m1 \u00b7 out + q \u00b7 aA \u00b7 aB \u00b7 a1 \u00b7 mA \u00b7 m2 \n\u00b7 out + q \u00b7 aA \u00b7 aA \u00b7 a1 \u00b7 out + q \u00b7 aA \u00b7 aB \u00b7 a2 \u00b7 out = { de.nition out }q \u00b7 aA \u00b7 aA \u00b7 a2 \u00b7 mB \u00b7 m1 \n\u00b7 aB \u00b7 a2 + q \u00b7 aA \u00b7 aB \u00b7 a1 \u00b7 mA \u00b7 m2 \u00b7 aB \u00b7 a2 + q \u00b7 aA \u00b7 aA \u00b7 a1 \u00b7 aB \u00b7 a2 + q \u00b7 aA \u00b7 aB \u00b7 a2 \u00b7 aB \n\u00b7 a2 = { PA-MO D -FI LT E R }q \u00b7 aA \u00b7 aA \u00b7 a2 \u00b7 mB \u00b7 m1 \u00b7 a1 \u00b7 aB \u00b7 a2 + q \u00b7 aA \u00b7 aB \u00b7 a1 \u00b7 mA \u00b7 aA \u00b7 \nm2 \u00b7 aB \u00b7 a2 + q \u00b7 aA \u00b7 aA \u00b7 a1 \u00b7 aB \u00b7 a2 + q \u00b7 aA \u00b7 aB \u00b7 a2 \u00b7 aB \u00b7 a2 = { KAT-C O M M U T E }q \u00b7 aA \n\u00b7 aA \u00b7 a2 \u00b7 mB \u00b7 m1 \u00b7 aB \u00b7 a1 \u00b7 a2 + q \u00b7 aA \u00b7 aB \u00b7 a1 \u00b7 mA \u00b7 m2 \u00b7 aA \u00b7 aB \u00b7 a2 + q \u00b7 aA \u00b7 aA \u00b7 aB \u00b7 a1 \n\u00b7 a2 + q \u00b7 aA \u00b7 aB \u00b7 a2 \u00b7 aB \u00b7 a2 = { PA-CO N T R A }q \u00b7 aA \u00b7 aA \u00b7 a2 \u00b7 mB \u00b7 m1 \u00b7 aB \u00b7 0 + q \u00b7 aA \u00b7 aB \n\u00b7 a1 \u00b7 mA \u00b7 m2 \u00b7 0 \u00b7 a2 + q \u00b7 aA \u00b7 aA \u00b7 aB \u00b7 0 + q \u00b7 0 \u00b7 a2 \u00b7 aB \u00b7 a2 = { KA-SE Q -Z E RO, KA-ZE RO -SE \nQ } 0 + 0 + 0 + 0 = { KA-PL U S -ID E M } 0 Lemma 3. in \u00b7 S SH \u00b7 (pA \u00b7 t)* \u00b7 out = in \u00b7 SSH \u00b7 (pB \u00b7 \nt)* \u00b7 out Proof. in \u00b7 S SH \u00b7 (pA \u00b7 t)* \u00b7 out = { K AT-IN VA R I A N T, de.nition pA }in \u00b7 S SH \u00b7 ((aA \n\u00b7 \u00acSSH \u00b7 p + aB \u00b7 p) \u00b7 t \u00b7 SSH)* \u00b7 out = { K A-S E Q -D I S T-R }in \u00b7 S SH \u00b7 (aA \u00b7 \u00acS SH \u00b7 p \u00b7 t \u00b7 S \nS H + aB \u00b7 p \u00b7 t \u00b7 S S H)* \u00b7 out = { K AT-C O M M U T E }in \u00b7 S SH \u00b7 (aA \u00b7 \u00acS SH \u00b7 S S H \u00b7 p \u00b7 t + aB \n\u00b7 p \u00b7 t \u00b7 S S H)* \u00b7 out = { BA-CO N T R A }in \u00b7 S SH \u00b7 (aA \u00b7 0 \u00b7 p \u00b7 t + aB \u00b7 p \u00b7 t \u00b7 SSH)* \u00b7 out = { \nK A-S E Q -ZE RO /ZE RO -S E Q, K A-P L U S -CO M M, KA -PL U S -Z E RO }in \u00b7 S SH \u00b7 (aB \u00b7 p \u00b7 t \u00b7 S \nS H)* \u00b7 out = { K A-U N RO L L -L }in \u00b7 S SH \u00b7 (1 + (aB \u00b7 p \u00b7 t \u00b7 SS H) \u00b7 (aB \u00b7 p \u00b7 t \u00b7 S S H)*) \u00b7 out \n= { K A-S E Q -D I S T-L, KA-S E Q -DI S T-R, de.nition out } in \u00b7 S SH \u00b7 aB \u00b7 a2 + in \u00b7 S SH \u00b7 aB \u00b7 \np \u00b7 t \u00b7 SS H \u00b7 (aB \u00b7 p \u00b7 t \u00b7 S S H)* \u00b7 aB \u00b7 a2 = { K AT-C O M M U T E } in \u00b7 aB \u00b7 S S H \u00b7 a2 + in \u00b7 \naB \u00b7 S S H \u00b7 p \u00b7 t \u00b7 SS H \u00b7 (aB \u00b7 p \u00b7 t \u00b7 S S H)* \u00b7 aB \u00b7 a2 = { Lemma 1 } 0 + 0 = { K A-P L U S -I D \nE M } 0 = { K A-P L U S -I D E M } 0 + 0 = { Lemma 1, Lemma 2 } in \u00b7 aB \u00b7 S S H \u00b7 a2 + in \u00b7 S SH \u00b7 (aA \n\u00b7 p \u00b7 t \u00b7 S S H)* \u00b7 p \u00b7 S S H \u00b7 aA \u00b7 t \u00b7 out = { K AT-C O M M U T E, de.nition out } in \u00b7 S SH \u00b7 out \n+ in \u00b7 S SH \u00b7 (aA \u00b7 p \u00b7 t \u00b7 S S H)* \u00b7 aA \u00b7 p \u00b7 t \u00b7 S S H \u00b7 out = { K A-S E Q -D I S T-L, KA-S E Q -DI \nS T-R } in \u00b7 S SH \u00b7 (1 + (aA \u00b7 p \u00b7 t \u00b7 S S H)* \u00b7 (aA \u00b7 p \u00b7 t \u00b7 S S H)) \u00b7 out = { K A-U N RO L L -R } \nin \u00b7 S SH \u00b7 (aA \u00b7 p \u00b7 t \u00b7 S S H)* \u00b7 out = { K A-S E Q -ZE RO /ZE RO -S E Q, K A-P L U S -ZE RO } in \u00b7 \nS SH \u00b7 (aA \u00b7 p \u00b7 t \u00b7 S S H + aB \u00b7 0 \u00b7 p \u00b7 t)* \u00b7 out = { BA-CO N T R A } in \u00b7 S SH \u00b7 (aA \u00b7 p \u00b7 t \u00b7 S S \nH + aB \u00b7 \u00acS S H \u00b7 S S H \u00b7 p \u00b7 t)* \u00b7 out = { K AT-C O M M U T E } in \u00b7 S SH \u00b7 (aA \u00b7 p \u00b7 t \u00b7 S S H + aB \n\u00b7 \u00acS S H \u00b7 p \u00b7 t \u00b7 S S H)* \u00b7 out = { K A-S E Q -D I S T-R } in \u00b7 S SH \u00b7 ((aA \u00b7 p + aB \u00b7 \u00acSS H \u00b7 p) \u00b7 \nt \u00b7 SSH)* \u00b7 out = { K AT-IN VA R I A N T, de.nition pB } in \u00b7 S SH \u00b7 (pB \u00b7 t)* \u00b7 out Figure 5. Code \nmotion proofs. strings. We prove the language model and the standard model The rest of this section outlines \nthe key steps of this proof. The of NetKAT given by the denotational semantics are isomorphic. long version \nof this paper gives further details. 3. We then de.ne a normal form for NetK AT policies, and show  \nthat every policy is provably equivalent to its normal form. Step 1: Reduced NetKAT. Let f1, . . . , \nfk be a list of all .elds of a packet in some (.xed) order. For each tuple n\u00af= n1, . . . , nk of 4. \nFinally, we relate NetK AT normal forms to regular sets of  \u00af\u00af values, let f = n\u00afand f . n\u00afdenote the \nexpressions guarded strings, and obtain the completeness of NetKAT from the completeness of K A. f1 \n= n1 \u00b7 \u00b7 \u00b7 fk = nk f1 . n1 \u00b7 \u00b7 \u00b7 fk . nk,  Reduced NetK AT syntax Complete assignments p f1 . n1 \u00b7 \u00b7 \n\u00b7 fk . nk Complete tests a , \u00df f1 = n1 \u00b7 \u00b7 \u00b7 fk = nk Reduced terms p, q ::= a Complete test | p Complete \nassignment | p + q Union | p \u00b7 q Sequence | p* Kleene star | dup Duplication Simpli.ed axioms for A and \nP P p = p \u00b7 ap a \u00b7 dup = dup \u00b7 a a = 1, a a = a \u00b7 pa p \u00b7 p ' = p ' a \u00b7 \u00df = 0, a = \u00df Regular interpretation: \nR(p) . (. + A + dup)* R(p) = {p} R(p + q) = R(p) . R(q) R(a) = {a} R(p \u00b7 q) = {xy | x . R(p), y . R(q)} \nR(dup) = {dup} [ R(p*) = R(p n) n=0 Figure 6. Reduced NetKAT. Language model: G(p) . I = A \u00b7 (. \u00b7 dup)* \n\u00b7 . G(p) = {a \u00b7 p | a . A} G(p + q) = G(p) . G(q) G(a) = {a \u00b7 pa } G(p \u00b7 q) = G(p) o G(q) G(dup) = {a \n\u00b7 pa \u00b7 dup \u00b7 pa | a . A} [ G(p*) = G(p n) n=0 Guarded concatenation ( ' a \u00b7 p \u00b7 q \u00b7 p ' if \u00df = apa \u00b7 \np \u00b7 p o \u00df \u00b7 q \u00b7 p = unde.ned if \u00df = ap A o B = {p o q | p . A, q . B} . I Figure 7. NetKAT language model. \nrespectively. We call these expressions complete tests and complete assignments respectively. We often \ncall complete tests atoms be\u00adcause they are atoms (minimal nonzero elements) of the Boolean algebra generated \nby the tests. Note that complete tests and com\u00adplete assignments are in one-to-one correspondence according \nto the values n\u00af. Hence, if a is an atom, we denote the corresponding complete assignment by pa , and \nif p is a complete assignment, we denote the corresponding atom by ap . We let A denote the set of atoms \nand . the set of complete assignments. Now that we have de.ned atoms and complete assignments, we investigate \ntheir properties. Figure 6 gives a collection of simple axioms for reduced policies that are easily provable \nusing the full NetKAT axioms. One useful consequence of these axioms is P a.A a \u00b7 pa = 1. Any policy \nis provably equivalent to a policy in which all atomic assignments f . n appear in the context of a complete \nassignment. The proof of this fact is straightforward. f . n = 1 \u00b7 f . n P = ( a \u00b7 pa ) \u00b7 (f . n) P a.A \n= a.A a \u00b7 p ' a where p ' is pa with the assignment to f replaced by f . n. Similarly, every test is \nequivalent to a sum of complete tests: a P b = a=b a Since all modi.cations can be replaced by complete \nassignments and all tests by atoms, any NetK AT policy p can be viewed as a regular expression over the \nalphabet ..A. {dup}. The bottom of Figure 6 shows this by de.ning a mapping R from reduced NetK AT to \nregular sets over this alphabet. We assume for the remainder of this section that all NetK AT policies \nare in reduced form. Step 2: Language model. Both K A and K AT have language mod\u00adels in which expressions \nare interpreted as regular sets of minimal nonzero terms (often called join-irreducible terms). For K \nA, the lan\u00adguage model is the regular sets of strings, and for KAT, it is the regular sets of guarded \nstrings [17]. NetKAT also has a language model. It consists of regular subsets of a restricted class \nof guarded strings I = A \u00b7 (. \u00b7 dup)* \u00b7 .. Each string in this set has the form a \u00b7 p0 \u00b7 dup \u00b7 p1 \u00b7 dup \n\u00b7 \u00b7 \u00b7 dup \u00b7 pn for some n = 0. These strings represent the minimal nonzero elements of the standard model \nof NetK AT. Figure 7 de.nes the language model as a mapping G from reduced NetK AT expressions to regular \nsubsets of I. The case for sequential composition makes use of the concatenation operator (o) over strings \nfrom I, which we lift to concatenation of sets of guarded strings from I. Both de.nitions appear at the \nbottom of Figure 7. Note that o is a partial function on strings but a total function on sets of strings. \nUsing the simpli.ed axioms of Figure 6, it is easy to show that o is associative on strings and sets, \ndistributes over union, and has two-sided identity {a \u00b7 pa | a . A}. Also note that if a \u00b7 p \u00b7 p o \u00df \n\u00b7 q \u00b7 p ' exists, then f a \u00b7 p \u00b7 p \u00b7 \u00df \u00b7 q \u00b7 p ' = a \u00b7 p \u00b7 p o \u00df \u00b7 q \u00b7 p ' . I and otherwise: f a \u00b7 p \n\u00b7 p \u00b7 \u00df \u00b7 q \u00b7 p ' = 0 Having de.ned the language model, we now show that it is iso\u00admorphic to the standard \npacket model presented in Section 3. We .rst show that the standard semantics of every NetK AT expression \nis equal to the union of its minimal nonzero terms.1 The proof is straightforward by induction on p. \nS Lemma 4. For all policies p, we have [p] = x.G(p) [x]. Next we prove that every x in I is completely \ndetermined by [x]. Lemma 5. If x, y . I, then [x] = [y] if and only if x = y. Finally, using Lemmas 4 \nand 5, we conclude that the language model is isomorphic to the denotational model presented earlier. \nLemma 6. For all policies p and q, we have [p] = [q] if and only if G(p) = G(q). 1 We abuse notation \nslightly here by applying the union operator S to func- S S tions H . P (H). This is interpreted pointwise: \n[p] = .s . [p] (s).  Step 3: Normal forms. Next we de.ne a normal form for NetK AT policies and prove \nthat every policy is provably equivalent to one in normal form. De.nition 1. A NetK AT policy p is in \nnormal form if R(p) . I. A policy is normalizable if it is provably equivalent to a policy in normal \nform. Lemma 7. Every policy p is normalizable. Proof. The inductive proof requires a slightly strengthened \ninduc\u00adtive hypothesis. Let us say that a policy is in strong normal form if it is in normal form and \nis a sum of zero or more guarded policies, where a policy is guarded if it is of the form either a \u00b7 \np \u00b7 x \u00b7 p ' or a \u00b7 p. We show by induction on p that every policy is equivalent to a policy in strong \nnormal form. The cases for atomic policies are straightforward: P a \u00b7 p ' h . n = a Pa.A dup = a \u00b7 pa \n\u00b7 dup \u00b7 pa Pa.A b = a=b a \u00b7 pa The case for union is trivial, and the case for sequential composition \nfollows by a simple argument: ! \u00ab P P PP PP si \u00b7 tj = si \u00b7 tj = si o tj . i jij ij The most interesting \ncase is for Kleene star. Consider an expression p*, where p is in strong normal form. We .rst prove the \nuniform case: when all guarded terms in p have the same initial atom a, that is, p = a \u00b7 t where t is \na union of terms each with a leading and trailing p, and R(t) . . \u00b7 (dup \u00b7 .)*. Let u be t with all terms \nwhose trailing p is not pa deleted and with the trailing pa deleted from all remaining terms. By the \nsimpli.ed axioms of Figure 6, we have t \u00b7 a \u00b7 t = u \u00b7 t, therefore t \u00b7 a \u00b7 t \u00b7 a = u \u00b7 t \u00b7 a. Using KAT-C \nO M M U T E [2, Lemma 4.4], (t \u00b7 a)* \u00b7 t = t + t \u00b7 a \u00b7 (t \u00b7 a)* \u00b7 t = t + u * \u00b7 t \u00b7 a \u00b7 t = t + u * \u00b7 \nu \u00b7 t = u * \u00b7 t, and hence p* = 1 + p* \u00b7 p = 1 + (a \u00b7 t)* \u00b7 a \u00b7 t = 1 + a \u00b7 (t \u00b7 a)* \u00b7 t = 1 + a \u00b7 u \n* \u00b7 t = 1 + a \u00b7 t + a \u00b7 u \u00b7 u * \u00b7 t, which after normalizing the 1 is in strong normal form. For the \ncase p* where the initial tests in p are not uniform, the argument is by induction on the number of terms \nin the union. If p = a \u00b7x+q, then by the inductive hypothesis, q* has an equivalent strong normal form \nq *. Using K AT-DE N E S T I N G (Figure 4), we obtain p* = (a \u00b7 x + q)* = q* \u00b7 (a \u00b7 x \u00b7 q*)* = q * \u00b7 \n(a \u00b7 x \u00b7 q *)* , then proceed as in the previous case. Step 4: Completeness. We need just one more lemma \nbefore delivering the completeness result, which says that the regular interpretation and language model \ncoincide for NetK AT policies in normal form. Lemma 8. If R(p) . I, then R(p) = G(p). Proof. Suppose \nR(p) . I. It is straightforward to show that G(p) is equal to the union of the elements of R(p), by induction \non p: [ G(p) = G(x). x.R(p) Then, since G(x) = {x} for x . I, we have [ G(p) = {x} = R(p). x.R(p) The \nproof of completeness for NetK AT now follows from the completeness of K A [12]. Theorem 2 (Completeness). \nEvery semantically equivalent pair of NetK AT expressions is provably equivalent using the NetK AT axioms. \nThat is, if [p] = [q], then f p = q. Proof. Let p and q be the normal forms of p and q. By Lemma 7, we \ncan prove that each is equivalent to its normal form: f p = p and f q = q . By soundness we have [p] \n= [p ] and [q] = [q ], hence [p ] = [q ]. By Lemma 6, we have G( p) = G( q). Moreover, by Lemma 8, we \nhave G( p) = R( p) and G( q) = R( q), thus R( p) = R( q). Since R( p) and R( q) are regular sets, we \nhave f p = q by the completeness of KA. Finally, as f p = p and f q = q and f p = q , we conclude that \nf p = q.  4.3 Decidability The .nal theorem presented in this section shows that deciding the equational \ntheory of NetK AT is no more nor less dif.cult than for K A or K AT. Theorem 3. The equational theory \nof NetK AT is PSPAC E-complete. Proof sketch. To show P S PAC E-hardness, reduce K A to NetKAT as follows. \nLet S be a .nite alphabet. For a regular expression e over S, let R(e) be the regular set of strings \nover S as de.ned in \u00a74. Transform e to a NetK AT expression e ' by replacing each occurrence in e of \na symbol p . S with (p \u00b7 dup) and prepending with an arbitrary but .xed atom a. It follows from Lemmas \n6 and 8 that R(e1) = R(e2) if and only if R(e1 ' ) = R(e2 ' ) if and only if '' '' G(e1) = G(e2) if and \nonly if [e1] = [e2]. To show that the problem is in P S PACE, given two NetK AT expressions e1 and e2, \nwe know that [e1] = [e2] if and only if there is a packet pk and packet history h such that h . [e1] \n(pk) \\ [e2] (pk) or h . [e2] (pk) \\ [e1] (pk); let us say the former without loss of generality. We guess \npk nondeterministically and follow a nondeterministically-guessed trajectory through e1 that produces \nsome h . [e1] (pk). At the same time, we trace all possible trajectories through e2 that could generate \na pre.x of h, ensuring that none of these produce h . [e2]. It takes only polynomial space to represent \nthe current values of the .elds of the head packet and the possible positions in e2 for the current pre.x \nof h. The algorithm is nondeterministic, but can be made deterministic using Savitch s theorem. 5. Reachability \nProperties Network administrators often ask questions such as, Can all hosts talk to each other? , or \nAre managed hosts kept separate from un\u00admanaged hosts? , or Does all untrusted traf.c traverse the intru\u00adsion \ndetection system? , and so on. Automated tools for answering these and other questions about reachability \nproperties have been the focus of several recent research projects [10, 11, 19]. Most ex\u00adisting tools \nwork by encoding the topology and policy as a log\u00adical structure, and then translating the reachability \nproperty into a formula whose satis.ability can be checked using a SAT solver or other tool. This section \npresents a different approach: we show how to encode two important classes of reachability properties \nas NetKAT equations. We then prove the equations are sound and com\u00adplete with respect to intuitive, semantic \nde.nitions of reachability using the language model developed in Section 4.  Reachability. The simplest \nreachability properties answer ques\u00adtions such as, Can host A send packets to host B? If A can send packets \nto B, then the denotational model of the network must in\u00adclude a packet history that starts from host \nA and ends at host B: (pkB, \u00b7 \u00b7 \u00b7 , pkA). More generally, we can ask if packets satisfying some predicate \na can be transformed so that they satisfy some pred\u00adicate b. These predicates may denote single hosts, \ngroups of hosts, or even arbitrary classes of traf.c, such as Web traf.c. To reason about reachability, \nwe use a small generalization of the logical crossbar model introduced in Section 2. In the logical crossbar \nmodel, we model the end-to-end behavior of the network using the following NetKAT expression, in \u00b7 (p \n\u00b7 t)* \u00b7 out where p and t de.ne the behavior of switches and links as dup\u00adfree NetKAT policies. Because \nthe policy does not contain dup, it does not record the individual hops that packets take as they go \nthrough the network. To do this, we must augment the logical crossbar to record the state of the packet \nat each intermediate hop: in \u00b7 dup \u00b7 (p \u00b7 t \u00b7 dup)* \u00b7 out Using this encoding, we can de.ne reachability \nas follows: De.nition 2 (Reachability). We say b is reachable from a if and only if there exists a trace \n(pk1, \u00b7 \u00b7 \u00b7 , pk ) . rng([dup \u00b7 (p \u00b7 t \u00b7 dup)*]) n such that [a] (pk ) = {(pk )} and [b] (pk1) = {(pk1)}. \nn n To decide whether b is reachable from a we check the following NetKAT equivalence: a \u00b7 dup \u00b7 (p \u00b7 \nt \u00b7 dup)* \u00b7 b = 0 Intuitively, the pre.x predicate, a, .lters the policy to only include histories that \nbegin with packets satisfying a. Similarly, the post.x predicate, b, .lters the policy to only include \nhistories that end with packets satisfying b. We do need to prove that this equation holds if and only \nif b is reachable from a. The key to the proof is to translate both the denotational de.nition of reachability \nand the reachability equation to the language model, where they are easy to relate. Theorem 4 (Reachability \nCorrectness). For predicates a and b, policy p, and topology t, a \u00b7 dup \u00b7 (p \u00b7 t \u00b7 dup)* \u00b7 b = 0, if \nand only if b is reachable from a. Proof. We translate the NetKAT equation into the language model: a \n\u00b7 dup \u00b7 (p \u00b7 t \u00b7 dup)* \u00b7 b = 0 . .a, pn, \u00b7 \u00b7 \u00b7 , p1. a \u00b7 pn \u00b7 dup \u00b7 \u00b7 \u00b7 dup \u00b7 p1 . G(a \u00b7 dup \u00b7 (p \u00b7 t \n\u00b7 dup)* \u00b7 b) We also translate each term in the semantic de.nition of reachabil\u00adity into the language \nmodel: .pk1, \u00b7 \u00b7 \u00b7 , pk . (pk1, \u00b7 \u00b7 \u00b7 , pk n ) . rng( [dup \u00b7 (p \u00b7 t \u00b7 dup)*]), n a] (pk ) = {(pk )} and \nn n [ b] (pk1) = {(pk1)}. .p ' \u00b7 \u00b7 \u00b7 , p ' 1, m. \u00b7 p ' \u00b7 dup \u00b7 \u00b7 \u00b7 dup \u00b7 p1 ' . G(dup \u00b7 (p \u00b7 t \u00b7 dup)*), \nap'm m \u00b7 p ' ap' m . G(a) and m ap'\u00b7 p1 ' . G(b) 1 To prove soundness we let a = apn and m = n to show \nthat if a \u00b7 pn \u00b7 dup \u00b7 \u00b7 \u00b7 dup \u00b7 p1 . G(a \u00b7 dup \u00b7 (p \u00b7 t \u00b7 dup)* \u00b7 b) then, ' ' ap'\u00b7 pm \u00b7 dup \u00b7 \u00b7 \u00b7 dup \n\u00b7 p1 . G(dup \u00b7 (p \u00b7 t \u00b7 dup)*) m Figure 8. A simple network controlled by two parties. which holds by \nde.nition of o. The proof of completeness follows by a similar argument. Waypointing. A waypoint, w, \nfrom a to b is a location that all packets traverse en route from a to b. For example, a network operator \nmight want to ensure that all traf.c from untrusted hosts to trusted hosts traverses a .rewall. De.nition \n3 (Waypoint). We say w is a waypoint from a to b, if and only if, for all histories (pk1 \u00b7 \u00b7 \u00b7 pk ) . \nrng( [dup \u00b7 (p \u00b7 t \u00b7 dup)*]) n where [a] (pk ) = {(pk )} and [b] (pk1) = {(pk1)}, there ex\u00ad n n ists \na pkx . (pk1 \u00b7 \u00b7 \u00b7 pk ) such that: n w] (pk ) = {(pk )}, x x [ b] pki = {} for all 1 < i < x, and  [a] \npkj = {} for all x < j < n.  To decide whether w is a waypoint from a to b, we check the following NetKAT \ninequality: a \u00b7 dup \u00b7 (p \u00b7 t \u00b7 dup)* \u00b7 b = a \u00b7 dup \u00b7 (\u00acb \u00b7 p \u00b7 t \u00b7 dup)* \u00b7 w \u00b7 (\u00aca \u00b7 p \u00b7 t \u00b7 dup)* \u00b7 \nb The left-hand side is exactly hop-by-hop reachability from a to b. The right-hand side is also a hop-by-hop \nexpression, but it has a predicate to check that packets traverse w. Furthermore, it tests that packets \ndo not prematurely visit b before w or return to a after reaching w. Theorem 5 (Waypoint Correctness). \nFor predicates a, b, and w, a \u00b7 dup \u00b7 (p \u00b7 t \u00b7 dup)* \u00b7 b = a \u00b7 dup \u00b7 (\u00acb \u00b7 p \u00b7 t \u00b7 dup)* \u00b7 w \u00b7 (\u00aca \u00b7 \np \u00b7 t \u00b7 dup)* \u00b7 b if and only if all packets from a to b are waypointed through w. Proof. Similar to \nthe proof of reachability correctness above. See the long version of this paper for the full proofs. \nUsing these encodings and theorems as building blocks, we can develop techniques for checking other reachability \nproperties as well. For example, we can check for self-loops, test whether a .re\u00adwall policy is correctly \nimplemented, and string together multiple waypoints into composite tests. 6. Traf.c Isolation NetKAT \ns policy combinators help programmers construct complex network policies out of simple parts. The most \nbasic combinator is union, which combines two policies by taking the union of the results generated by \nthe sub-policies. However, naive use of union can lead to undesirable results, because each sub-policy \nmay receive and modify packets intended for the other sub-policy.  Example. Consider the network in \nFigure 8. Suppose the task of routing traf.c between hosts 1 and 2 has been assigned to one programmer, \nwhile the task of routing traf.c between hosts 3 and 4 has been assigned to another programmer. The .rst \nprogrammer might produce the following policy for switch B, pB1 sw = B \u00b7 (pt = 6 \u00b7 pt . 2 + pt = 2 \u00b7 \npt . 6) and the second programmer might produce a similar switch policy for B. This second policy differs \nfrom the .rst only by sending traf.c from port 6 out port 4 rather than port 2: pB2 sw = B \u00b7 (pt = 6 \n\u00b7 pt . 4 + pt = 4 \u00b7 pt . 6) Similar policies pA1 and pA2 de.ne the behavior at switch A. Now, if we assume \nt captures the topology of the network properly, then ((pA1 + pB1) \u00b7 t)* correctly sends traf.c from \nhost 1 to host 2. However, when the second policy is added in, (((pA1 + pB1) + (pA2 + pB2)) \u00b7 t)* packets \nsent from host 1 will be copied to host 4 as well as host 2. In this instance, union actually produces \ntoo many behaviors. In the best case, sending additional packets to host 4 from host 1 leads to unnecessary \ncongestion. In the worst case, it may violate the security policy for host 1. Either alternative demonstrates \nthe need for better ways of composing forwarding policies. Slices. A network slice [8] is a lightweight \nabstraction that facil\u00aditates modular construction of policies. Intuitively, a slice de.nes a piece of \nthe network that can be programmed independently of the rest of the network. The boundaries of a slice \nare de.ned by ingress (in) and egress (out) predicates, while the behavior in the slice is determined \nby the internal policy p. Each slice also has a unique identi.er (w) to differentiate it from other slices.2 \nPackets that match in are injected into the slice. Once in a slice, packets stay in the slice and obey \np until they match the predicate out, at which point they are ejected. We write slices as follows: {in} \nw : (p) {out} where in and out are the ingress and egress predicates and p de.nes the internal policy. \nTo de.ne slices in NetKAT, we begin by picking a header .eld, for example, tag, to record the packet \ns current slice.3 In order for our elaboration to have the desired properties, however, the tag .eld \nmust not be used elsewhere in the policy or in the ingress or egress predicates. We call a predicate \ntag-free if it commutes with any modi.cation of the tag .eld, and a policy tag-free if it commutes with \nany test of the tag .eld. Given tag-free predicates in, out and policy p, and a tag w0 representing packets \nnot in any slice, we can compile a slice into NetK AT as follows: {in} w : (p) {out}.w0 Wlet pre = (tag \n= w0 \u00b7 in \u00b7 tag . w + tag = w) in let post = (out \u00b7 tag . w0 + \u00acout) in (pre \u00b7 p \u00b7 post) Compilation \nwraps the slice policy with pre-and post-processing policies, pre and post. The pre policy tests whether \na packet (i) is outside the slice (tagged with w0) and matches the ingress pred\u00adicate, in which case \nit is injected by tagging it with w, or (ii) has 2 The unique identi.er w may be de.ned by the compiler \nand need not appear in the surface syntax. 3 In practice, the vlan .eld is often used to differentiate \ndifferent classes of network traf.c [34]. already been injected (already tagged with w). Once injected, \npack\u00adets are processed by p. If p emits a packet that matches the egress predicate out, then post strips \nthe tag, restoring w0. Otherwise, the packet remains in the slice and is left unmodi.ed. Isolation. A \nkey property of slices is that once a packet enters a slice, it is processed solely by the policy of \nthat one slice until it is ejected, even across multiple hops in the topology. The following theorem \ncaptures this idea more precisely. Theorem 6 (Slice Composition). For all tag-free slice ingress and \negress predicates in and out, identi.ers w, policies s, q, tag-free policies p, and topologies t, if \n{in} w : (p) {out}.w0 , s = W w = w0, out \u00b7 t \u00b7 dup \u00b7 q = 0,  q \u00b7 t \u00b7 dup \u00b7 in = 0,  q drops w-tagged \ntraf.c,  then ((s + q) \u00b7 t \u00b7 dup)* = (s \u00b7 t \u00b7 dup)* + (q \u00b7 t \u00b7 dup)* . In a nutshell, this theorem says \nthat executing the union of s and q is the same as sending packets through two separate copies of the \nnetwork, one containing the slice and the other containing q. The proof of the theorem is by equational \nreasoning and makes use of the K AT-DE N E S T I N G theorem from Figure 4. An interesting corollary \nof the result above is that when the ingress slice boundary of s and the domain of q do not overlap, \nfor traf.c destined for the ingress of s, the union of s and q is equivalent to s alone. Corollary 1. \nFor all tag-free slice ingress and egress predicates in and out, identi.ers w, policies s, q, and topologies \nt, such that {in} w : (p) {out}.w0 , s = W w = w0, out \u00b7 t \u00b7 dup \u00b7 q = 0,  q \u00b7 t \u00b7 dup \u00b7 in = 0, \n in \u00b7 q = 0, then  in \u00b7 tag = w0 \u00b7 ((s + q) \u00b7 t \u00b7 dup)* = in \u00b7 tag = w0 \u00b7 (s \u00b7 t \u00b7 dup)* Corollary 1 \nconnects to traditional language-based information .ow properties [27]. If s de.nes public, low-security \ndata and q de.nes private, high security data, the corollary implies that the observable behavior of \nthe network remains unchanged regardless of whether the high-security data (q) is present, absent, or \nreplaced by some alternate high security data (q '). Example, redux. Slices provide a solution to the \nscenario de\u00adscribed in the example at the beginning of the section. We can assign each programmer a unique \nslice with boundaries that cor\u00adrespond to the locations of the end hosts under control of that slice. \nFor instance, the .rst programmer s in and out predicates include the network access points for hosts \n1 and 2, while the second pro\u00adgrammer s in and out predicates include the network access points for hosts \n3 and 4. in1 sw = A \u00b7 pt = 1 + sw = B \u00b7 pt = 2 out1 sw = A \u00b7 pt = 1 + sw = B \u00b7 pt = 2 s1 {in1} w1 : (pA1 \n+ pB1) {out1} in2 sw = A \u00b7 pt = 3 + sw = B \u00b7 pt = 4 out2 sw = A \u00b7 pt = 3 + sw = B \u00b7 pt = 4 s2 {in2} w2 \n: (pA2 + pB2) {out2}  Pattern Action typ=SSH Drop port=1 Output 2 port=2 Output 1 * Drop if typ=S S \nH then 0 else if pt=1 then pt:=2 else if pt=2 then pt:=1 else 0 Figure 9. A .ow table and an equivalent \nNetK AT policy. ONF Action Sequence a ::= 1 | f . n \u00b7 a ONF Action Sum as ::= 0 | a + as ONF Predicate \nb ::= 1 | f = n \u00b7 b ONF Local e ::= as | if b then as else e ONF p ::= 0 | (sw = sw \u00b7 e) + p Figure 10. \nOpenFlow Normal Form. The original dif.culty with this example was caused by packet duplication when, \nfor example, a packet was sent from host 1 to host 2. Corollary 1 proves that we can use slices to solve \nthe problem: host 1 is connected to slice 1, and restricting the input to that of slice 1 implies that \nthe behavior of the entire program is precisely that of slice 1 alone. 7. Compilation In order to execute \na NetK AT program on an OpenFlow switch, we must compile it to a .ow table, the low-level programming \nabstraction that OpenFlow supports. A .ow table is a prioritized list of rules, where each rule consists \nof a pattern to match packet headers and actions to apply to matching packets. When a packet arrives \nat a switch, the actions associated with the highest priority matching rule are applied to it. For example, \nthe .ow table on the left-hand side of .gure 9 blocks SSH packets, but forwards all other traf.c between \nports 1 and 2. Alongside the .ow table is an equivalent NetK AT policy. To make the connection between \nthese two equivalent representations obvious, we introduce a conditional construct as shorthand: if b \nthen as else e def (b \u00b7 as) + (\u00acb \u00b7 e) = Logically, a .ow table pattern is a conjunction of positive \nlit\u00aderals, and each action is a combination of modi.cations. We can interpret prioritized rules as cascades \nof conditional expressions. In this section we describe the design of a compiler based on this idea. \nThe input to the compiler is NetK AT without dup or sw := n terms. These constructs are necessary to \nmodel network topology, but the output produced by the compiler is meant to execute on switches. Therefore, \nit is reasonable to exclude these features. The output of the compiler is a stylized subset of NetKAT \ncalled Open-Flow Normal Form (ONF). An ONF policy is a sum of conditional cascades, where each cascade \nis guarded by a test for a switch: (sw = sw1 \u00b7 e1) + \u00b7 \u00b7 \u00b7 + (sw = swn \u00b7 en) Each term can be interpreted \nas a complete .ow table for a given switch. Figure 10 presents the full grammar for ONF. Mapping ONF \nto .ow tables, is mostly straightforward, and many of the low-level details have been addressed in previous \nwork [7]. The rest of this section outlines the major steps required to com\u00adpile NetK AT to ONF. Each \nstep eliminates or restricts an element of NetK AT syntax. In other words, each step translates from \none intermediate representation to another until we arrive at ONF. We write NetKAT -(op) to denote NetK \nAT expressions that do not use the op operator. For example, if: -(dup,sw.) p . NetK AT then p does not \ncontain dup and does not modify the sw .eld. This is the source language for the compiler, as described \nabove. Step 1: Star elimination. The .rst step is to eliminate Kleene star from the input policy. This \nstep is critical as switches do not sup\u00adport iterated processing of packets indeed, many switches only \nsupport a single phase of processing by a table! Formally, we prove that any program without dup, or, \nless importantly, assignment to sw, is equivalent to a Kleene star-free program (again without the dup \nprimitive or assignments to sw). Lemma 9 (Star Elimination). If p . NetK AT -(dup,sw.), then there exists \np ' . NetK AT -(dup,sw.,*) where p = p ' . Proof. We show that p ' can be obtained from the normal form \nused in the completeness theorem. More speci.cally, let p '' be the policy obtained from p by the normalization \nconstruction of Lemma 7. By construction, dup can only appear in the normal form of an expression already \ncontaining dup, so p '' cannot contain dup. '' '' '' R(p ) . I and p does not contain dup, so R(p ) . \nAt \u00b7 P . Therefore, p '' does not contain Kleene star. Let us now prove that any assignment of the form \nsw . swi in p '' is preceded in the same term by the corresponding test sw = swi. Because p does not \ncontain any assignment of the form sw . swi, it commutes with any test of the form sw = swi. Therefore \np '' also commutes with any test of the form sw = swi. It follows that p '' can be written as a sum of \na \u00b7p for some atom a and complete assignment p. Suppose for a contradiction that term, a contains a test \nsw = swi, and p contains an assignment sw . swj , with swi = swj . Then a \u00b7 (sw = swi) \u00b7 p '' \u00b7 (sw = \nswj ) = a \u00b7 p = 0 a \u00b7 (sw = swj ) \u00b7 p '' \u00b7 (sw = swi) = 0 but those two terms are also equal, which is \na contradiction. Therefore any assignment of the form sw . swi in p '' is pre\u00adceded, in the same term, \nby the corresponding test sw = swi, and can be removed using axiom PA -FI LT E R -MO D to produce the \nde\u00adsired p '. Tests and assignments to other .elds than sw could appear in between, but we can use the \ncommutativity axioms PA-MO D -MO D -CO M M and PA-MO D -FI LT E R -CO M M to move the assignment sw . \nswi to just after the test sw = swi. Step 2: Switch specialization. Next, we show that every star-free \npolicy can be specialized for the switches in the network. This transformation allows us to remove nested \ntests of the sw .eld and put the policy into a form where it can easily be compiled into a .ow table \nfor each switch. Lemma 10 (Switch Specialization). If p . NetK AT -(dup,sw.,*), then for all switches \nswi, there exists p ' . NetKAT -(dup,sw.,*,sw) such that sw = swi \u00b7 p = sw = swi \u00b7 p ' . Proof. Let g \nbe the unique homomorphism of NetK AT de.ned on primitive programs by: g(sw = sw) (1 0 if sw = swi otherwise \ng(f . v) f . v g(dup) dup For every primitive program element x of NetKAT -(dup,sw.,*), we have both: \nsw = swi \u00b7 x = g(x) \u00b7 sw = swi g(x) \u00b7 sw = swi = sw = swi \u00b7 g(x)  (if dst = A then pt := 1 else 0) + \n(if src = B then pt := 2 else 0) = if dst = A \u00b7 src = B then pt := 1 + pt := 2 else if dst = A then pt \n:= 1 else if src = B then pt := 2 else 0 Figure 11. Compiling ONF policy union. (if typ = S S H then \nvlan := W else 1) \u00b7 (if dst = A then pt := 1 else if dst = B then pt := 2 else 0) = if dst = A \u00b7 typ \n= S S H then vlan := W \u00b7 pt := 1 else if dst = A then pt := 1 else if dst = B \u00b7 typ = S S H then vlan \n:= W \u00b7 pt := 2 else if dst = B then pt := 2 else 0 Figure 12. Compiling ONF policy sequence. Hence, applying \nKAT-CO M M U T E [2, Lemma 4.4] twice shows: sw = swi \u00b7 p = g(p) \u00b7 sw = swi g(p) \u00b7 sw = swi = sw = swi \n\u00b7 g(p) By the de.nition of g, any occurrence of sw = v in p is replaced by either 1 or 0 in g(p). Moreover, \nsince p . NetK AT -(dup,sw.,*), it follows that g(p) does not contain any occurrence of sw = v and since \np ' = g(p) . NetK AT -(dup,sw.,*,sw) we also have sw = swi \u00b7 p = sw = swi \u00b7 p ' Step 3: Converting to \nONF. The third step is to compile policies in NetK AT -(dup,sw.,*,sw) to ONF. This is a recursive procedure \nthat .rst compiles sub-policies to ONF. To calculate the union of two ONF policies, we take the cross\u00adproduct \nof the predicates and actions. This procedure is based on earlier work [23], but we present a purely \nsyntactic proof of cor\u00adrectness. Figure 11 shows an example of compiling policy union, which illustrates \nwhy the cross-product construction is necessary. Calculating the sequence of two ONF policies is more \ninvolved, since we have to commute the modi.cations in the .rst policy with the tests in the second policy \nto produce a single if-then\u00adelse cascade, as illustrated in .gure 12. As the NetK AT axiom PA-MO D -FI \nLT E R -CO M M shows, modi.cations and tests commute naively only if they affect distinct .elds. The \ncompiler has several transformations to ensure that various kinds of overlapping tests and modi.cations \ndo commute. Lemma 11 (Switch-local Compilation). If p . NetKAT -(dup,sw.,*,sw) then there exists a policy \np ' such that p = p ' and p ' . ONF. The proof goes by induction on the structure of p. Step 4: Combining \nresults. Lemmas 9, 10 and 11 suf.ce to prove any policy p in NetK AT -(dup,sw.) may be converted to OpenFlow \nnormal form. Theorem 7 (ONF). If pin . NetKAT -(dup,sw.) then there exists pout = pin such that pout \n. ONF. Optimizations. Naive compilation of network programs can pro\u00adduce .ow tables that are unmanageably \nlarge [23]. Hence, existing systems implement optimizations to generate smaller tables. For example, \nthe following lemma describes a common optimization called fall-through elimination, which removes unnecessary \nrules from the table. Lemma 12 (Fall-through Elimination). If b1 = b2 then if b1 then as else if b2 then \nas else e = if b2 then as else e We plan to study further optimizations in future work. 8. Related Work \nKleene algebra is named for its inventor, Stephen Cole Kleene. Much of the basic algebraic theory of \nK A was developed by John Horton Conway [4]. Kleene algebra with tests was introduced by Kozen [13, 14]. \nK A and K AT have been successfully applied in many practical veri.cation tasks, including veri.cation \nof compiler optimizations [16], pointer analysis [22], concurrency control [3], and device drivers [15]. \nThis is the .rst time KA has been used as a network programming language or applied to veri.cation of \nnetworks. The proof of the main result in this paper completeness of the equational axioms is based on \na novel model of KAT. While many other systems have been proposed for analyzing networks, we believe \nours is the .rst to provide a complete, high\u00adlevel algebra for reasoning about network programs as they \nare written. Systems such as Anteater [19], FlowChecker [1], Header Space Analysis [10], VeriFlow [11], \nand Formally Veri.able Net\u00adworking [33], encode information about network topology and for\u00adwarding policies \ninto SAT formulae (Anteater), graph-based rep\u00adresentations (VeriFlow, Header Space Analysis), or higher-order \nlogic (Formally Veri.able Networking). These systems then de.ne custom algorithms over these models to \ncheck speci.c properties such as reachability or packet loss. Such systems can check for vi\u00adolations \nof important network invariants, but do not provide sound and complete systems for reasoning directly \nabout programs. More\u00adover, although these systems have expressive languages for encod\u00ading properties, \nthey do not connect these encodings back to deno\u00adtational or operational models of the network. In contrast, \nin sec\u00adtion 5, we show how to encode a reachability property as a NetK AT equation and then prove that \nthe reachability equation is equivalent to a semantic de.nition of reachability. As a programming language, \nNetK AT is most similar to Net-Core [7, 23] and Pyretic [24], which both stemmed from earlier work on \nFrenetic [6]. NetCore de.ned the fragment of NetK AT with .lters, modi.cation and union, and Pyretic \nextended NetCore with sequential composition (although Pyretic has neither a formal se\u00admantics nor a \ncompiler). Neither language de.ned an equational theory for reasoning about programs, nor did they include \nKleene star unlike these previous languages, NetKAT programs can de\u00adscribe potentially in.nite behaviors. \nNDLog [18] is a logic programming language with an explicit notion of location and a distributed execution \nmodel. In contrast to NDLog, NetK AT and NetCore are designed for programming cen\u00adtralized (not distributed) \nSDN controllers. Because NDLog is based around Datalog (with general recursion and pragmatic extensions \nthat complicate its semantics), equivalence of NDLog programs is undecidable [29]. NetK AT s Kleene star \nis able to model network behavior, but has decidable (P S PAC E-complete) equivalence. 9. Conclusion \nThis paper presents NetKAT, a new language for S DN programming and reasoning that is based on a solid \nsemantic foundation Kleene algebra with tests. NetK AT s denotational semantics describes net\u00adwork programs \nas functions from packet histories to sets of pack\u00adets histories and its equational theory is sound and \ncomplete with respect to this model. The language enables programmers to create expressive, compositional \nnetwork programs and reason effectively about their semantics. We demonstrate the power of our framework \non a range of practical applications including reachability, traf.c isolation, access control, and compiler \ncorrectness.  Acknowledgments The authors wish to thank Timothy Grif.n, Shriram Krishnamurthi, Nick \nMcKeown, Jennifer Rexford, the members of the Cornell PLDG, and the POPL reviewers for helpful comments, \nas well as Alec Story and Stephen Gutz for work on a preliminary version of slices. This work is supported \nin part by the NSF under grants CNS-1111698, CNS-0931985, CNS-1111520, and SHF-1016937, the ONR under \naward N00014-12-1-0757, a Sloan Research Fellowship, and a Google Research Award. References [1] Ehab \nAl-Shaer and Saeed Al-Haj. FlowChecker: Con.guration anal\u00adysis and veri.cation of federated OpenFlow \ninfrastructures. In Safe-Con.g, 2010. [2] Allegra Angus and Dexter Kozen. Kleene algebra with tests and \nprogram schematology. Technical Report TR2001-1844, Computer Science Department, Cornell University, \nJuly 2001. [3] Ernie Cohen. Using Kleene algebra to reason about concurrency control. Technical report, \nTelcordia, Morristown, N.J., 1994. [4] John Horton Conway. Regular Algebra and Finite Machines. Chap\u00adman \nand Hall, London, 1971. [5] Andrew D. Ferguson, Arjun Guha, Chen Liang, Rodrigo Fonseca, and Shriram \nKrishnamurthi. Participatory networking: An API for application control of SDNs. In SIGCOMM, 2013. [6] \nNate Foster, Rob Harrison, Michael J. Freedman, Christopher Mon\u00adsanto, Jennifer Rexford, Alec Story, \nand David Walker. Frenetic: A network programming language. In ICFP, September 2011. [7] Arjun Guha, \nMark Reitblatt, and Nate Foster. Machine-veri.ed net\u00adwork controllers. In PLDI, June 2013. [8] Stephen \nGutz, Alec Story, Cole Schlesinger, and Nate Foster. Splen\u00addid isolation: A slice abstraction for software-de.ned \nnetworks. In HotSDN, 2012. [9] James Hamilton. Networking: The last bastion of mainframe comput\u00ading, \nDecember 2009. Available at http://tinyurl.com/y9uz64e. [10] Peyman Kazemian, George Varghese, and Nick \nMcKeown. Header space analysis: Static checking for networks. In NSDI, 2012. [11] Ahmed Khurshid, Xuan \nZou, Wenxuan Zhou, Matthew Caesar, and P. Brighten Godfrey. VeriFlow: Verifying network-wide invariants \nin real time. In NSDI, 2013. [12] Dexter Kozen. A completeness theorem for Kleene algebras and the algebra \nof regular events. I&#38;C, 110(2):366 390, May 1994. [13] Dexter Kozen. Kleene algebra with tests and \ncommutativity condi\u00adtions. In TACAS, pages 14 33, Passau, Germany, March 1996. [14] Dexter Kozen. Kleene \nalgebra with tests. Transactions on Program\u00adming Languages and Systems, 19(3):427 443, May 1997. [15] \nDexter Kozen. Kleene algebras with tests and the static analysis of programs. Technical Report TR2003-1915, \nComputer Science Department, Cornell University, November 2003. [16] Dexter Kozen and Maria-Cristina \nPatron. Certi.cation of compiler optimizations using Kleene algebra with tests. In CL, July 2000. [17] \nDexter Kozen and Frederick Smith. Kleene algebra with tests: Com\u00adpleteness and decidability. In CSL, \nSeptember 1996. [18] Boon Thau Loo, Joseph M. Hellerstein, Ion Stoica, and Raghu Ra\u00admakrishnan. Declarative \nrouting: Extensible routing with declarative queries. In SIGCOMM, 2005. [19] Haohui Mai, Ahmed Khurshid, \nRaghit Agarwal, Matthew Caesar, P. Brighten Godfrey, and Samuel Talmadge King. Debugging the data plane \nwith Anteater. In SIGCOMM, 2011. [20] James McCauley, Aurojit Panda, Martin Casado, Teemu Koponen, and \nScott Shenker. Extending SDN to large-scale networks. In ONS, 2013. [21] Nick McKeown, Tom Anderson, \nHari Balakrishnan, Guru Parulkar, Larry Peterson, Jennifer Rexford, Scott Shenker, and Jonathan Turner. \nOpenFlow: Enabling innovation in campus networks. SIGCOMM Computing Communications Review, 38(2):69 74, \n2008. [22] B. M \u00a8oller. Calculating with pointer structures. In Algorithmic Lan\u00adguages and Calculi. Proc. \nIFIP TC2/WG2.1 Working Conference, February 1997. [23] Christopher Monsanto, Nate Foster, Rob Harrison, \nand David Walker. A compiler and run-time system for network programming languages. In POPL, January \n2012. [24] Christopher Monsanto, Joshua Reich, Nate Foster, Jennifer Rexford, and David Walker. Composing \nsoftware-de.ned networks. In NSDI, April 2013. [25] Tim Nelson, Arjun Guha, Daniel J. Dougherty, Kathi \nFisler, and Shri\u00adram Krishnamurthi. A balance of power: Expressive, analyzable con\u00adtroller programming. \nIn HotSDN, 2013. [26] Mark Reitblatt, Nate Foster, Jennifer Rexford, Cole Schlesinger, and David Walker. \nAbstractions for network update. In SIGCOMM, 2012. [27] Andrei Sabelfeld and Andrew C. Myers. Language-based \ninformation\u00ad.ow security. IEEE Journal on Selected Areas in Communications, 21(1):5 19, 2003. [28] Gunther \nSchmidt. Relational Mathematics. Cambridge University Press, 2010. [29] O. Shmueli. Decidability and \nexpressiveness aspects of logic queries. In PODS, pages 237 249, 1987. [30] The Frenetic Project, 2013. \nSee http://frenetic-lang.org. [31] Andreas Voellmy and Paul Hudak. Nettle: Functional reactive pro\u00adgramming \nof OpenFlow networks. In PADL, 2011. [32] Andreas Voellmy, Junchang Wang, Y. Richard Yang, Bryan Ford, \nand Paul Hudak. Maple: Simplifying SDN programming using algorithmic policies. In SIGCOMM, 2013. [33] \nAnduo Wang, Limin Jia, Changbin Liu, Boon Thau Loo, Oleg Sokol\u00adsky, and Prithwish Basu. Formally veriable \nnetworking. In HotNets, 2009. [34] Minlan Yu, Jennifer Rexford, Xin Sun, Sanjay G. Rao, and Nick Feamster. \nA survey of virtual LAN usage in campus networks. IEEE Communications Magazine, 49(7):98 103, 2011. \n \n\t\t\t", "proc_id": "2535838", "abstract": "<p>Recent years have seen growing interest in high-level languages for programming networks. But the design of these languages has been largely ad hoc, driven more by the needs of applications and the capabilities of network hardware than by foundational principles. The lack of a semantic foundation has left language designers with little guidance in determining how to incorporate new features, and programmers without a means to reason precisely about their code.</p> <p>This paper presents NetKAT, a new network programming language that is based on a solid mathematical foundation and comes equipped with a sound and complete equational theory. We describe the design of NetKAT, including primitives for filtering, modifying, and transmitting packets; union and sequential composition operators; and a Kleene star operator that iterates programs. We show that NetKAT is an instance of a canonical and well-studied mathematical structure called a Kleene algebra with tests (KAT) and prove that its equational theory is sound and complete with respect to its denotational semantics. Finally, we present practical applications of the equational theory including syntactic techniques for checking reachability, proving non-interference properties that ensure isolation between programs, and establishing the correctness of compilation algorithms.</p>", "authors": [{"name": "Carolyn Jane Anderson", "author_profile_id": "86158733057", "affiliation": "Swarthmore College, Swarthmore, PA, USA", "person_id": "P4383762", "email_address": "canders1@swarthmore.edu", "orcid_id": ""}, {"name": "Nate Foster", "author_profile_id": "81444600818", "affiliation": "Cornell University, Ithaca, NY, USA", "person_id": "P4383763", "email_address": "jnfoster@cs.cornell.edu", "orcid_id": ""}, {"name": "Arjun Guha", "author_profile_id": "81331493565", "affiliation": "University of Massachusetts Amherst, Amherst, MA, USA", "person_id": "P4383764", "email_address": "arjun@cs.umass.edu", "orcid_id": ""}, {"name": "Jean-Baptiste Jeannin", "author_profile_id": "81490694319", "affiliation": "Carnegie Mellon University, Pittsburgh, PA, USA", "person_id": "P4383765", "email_address": "jeannin@cs.cornell.edu", "orcid_id": ""}, {"name": "Dexter Kozen", "author_profile_id": "81100623764", "affiliation": "Cornell University, Ithaca, NY, USA", "person_id": "P4383766", "email_address": "kozen@cs.cornell.edu", "orcid_id": ""}, {"name": "Cole Schlesinger", "author_profile_id": "81490647459", "affiliation": "Princeton University, Princeton, NJ, USA", "person_id": "P4383767", "email_address": "cschlesi@cs.princeton.edu", "orcid_id": ""}, {"name": "David Walker", "author_profile_id": "81100426485", "affiliation": "Princeton University, Princeton, NJ, USA", "person_id": "P4383768", "email_address": "dpw@cs.princeton.edu", "orcid_id": ""}], "doi_number": "10.1145/2535838.2535862", "year": "2014", "article_id": "2535862", "conference": "POPL", "title": "NetKAT: semantic foundations for networks", "url": "http://dl.acm.org/citation.cfm?id=2535862"}