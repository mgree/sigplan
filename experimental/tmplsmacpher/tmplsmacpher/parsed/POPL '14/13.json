{"article_publication_date": "01-08-2014", "fulltext": "\n Proofs That Count Azadeh Farzan Zachary Kincaid Andreas Podelski University of Toronto University of \nFreiburg Abstract Counting arguments are among the most basic proof methods in mathematics. Within the \n.eld of formal veri.cation, they are use\u00adful for reasoning about programs with in.nite control, such \nas pro\u00adgrams with an unbounded number of threads, or (concurrent) pro\u00adgrams with recursive procedures. \nWhile counting arguments are common in informal, hand-written proofs of such programs, there are no fully \nautomated techniques to construct counting arguments. The key questions involved in automating counting \narguments are: how to decide what should be counted?, and how to decide when a counting argument is valid? \nIn this paper, we present a technique for automatically constructing and checking counting arguments, \nwhich includes novel solutions to these questions. Categories and Subject Descriptors D.2.4 [Software/Program \nVeri.cation]: Correctness Proofs; F.3.1 [Logics and Meanings of Programs]: Specifying, Verifying and \nReasoning about Programs General Terms Languages, Veri.cation Keywords Concurrency, Veri.cation, Static \nAnalysis 1. Introduction A counting argument (in the context of formal methods) is a pro\u00adgram proof that \nmakes use of one or more counters, which are not part of the program itself, but which are useful for \nabstracting pro\u00adgram behaviour. For example it may be useful to refer to the num\u00adber of threads that \nhave requested access to a shared resource, or the number of times a recursive procedure has been called. \nDespite the usefulness of counting arguments in hand-written proofs, the prob\u00adlem of constructing such \narguments automatically is little explored. This paper presents one such approach. The main intellectual \nchallenge of constructing counting argu\u00adments automatically is that we must design an algorithm which \ncan choose what to count. This is a task that, when carried out by hu\u00admans, seems to require genuine \ncreativity. The question of whether machines are capable of simulating this type of creativity is a chal\u00adlenging \nproblem in formal veri.cation. It is also a fundamental one: counters may be viewed as a class of auxiliary \nvariables (a\u00b4la Owicki-Gries [41]), in the sense that they remember useful in\u00ad formation about the program \nhistory that can be used in a formal ar\u00adgument. The problem of choosing what to count can be viewed as \nPermission to make digital or hard copies of all or part of this work for personal or classroom use is \ngranted without fee provided that copies are not made or distributed for pro.t or commercial advantage \nand that copies bear this notice and the full citation on the .rst page. Copyrights for components of \nthis work owned by others than ACM must be honored. Abstracting with credit is permitted. To copy otherwise, \nor republish, to post on servers or to redistribute to lists, requires prior speci.c permission and/or \na fee. Request permissions from permissions@acm.org. POPL 14, January 22 24, 2014, San Diego, CA, USA. \nCopyright &#38;#169; 2014 ACM 978-1-4503-2544-8/14/01. . . $15.00. http://dx.doi.org/10.1145/2535838.2535885 \n one incarnation of the well-known (and yet under-explored) prob\u00adlem of auxiliary variable synthesis. \nThis paper presents a strategy for automatically constructing counting arguments for program veri.cation. \nThis strategy is out\u00adlined in Figure 1. The input to our algorithm is a program P and a pre/postcondition \nspeci.cation .pre /.post . The algorithm can be viewed as a kind of language inference algorithm. The \nprogram P is treated as a black box: we can sample traces from P, but we may not inspect its internal \nstructure (so effectively, we identify P with a language of traces). The goal of our algorithm is to \nlearn a count\u00ading proof (A, .) for P. A counting proof consists of a counting automaton A, which determines \na language of traces, and an anno\u00adtation ., which is a proof that all traces in the language of A satisfy \nthe speci.cation .pre /.post . If our algorithm can learn a counting proof (A, .) such that A recognizes \nall the traces from P, then P is correct with respect to the speci.cation .pre /.post . The algorithm \nin Figure 1 operates as follows. We start by (a) constructing a counting proof (A, .) for set of sample \ntraces Tr . We then (b) check if every program trace in P is recognized by the counting automaton A. \nIf the check succeeds, the algorithm has learned a counting proof for P. If it fails, it produces a counterex\u00adample \nt (a program trace that is not recognized by A). We then (c) check whether t satis.es the speci.cation \n.pre /.post . If not, we are done: t is a counterexample which shows that P is incorrect. If yes, then \n(d) we add t to the set of sample traces Tr , and repeat. Note that in the .rst iteration (since initially \nTr is empty) the language of A is empty, so t is any program trace. Figure 1. Counting proof inference. \n Before we explain counting proofs further, we remark on the important distinction between discovery \nand synthesis of auxiliary variables (and counters in particular). Counter discovery is essen\u00adtially \na white-box technique: the goal is to expose existing coun\u00adters in a program which are relevant for a \nproof (for example, dis\u00adcovery of relevant program counters for Owicki-Gries proofs, as in [23]). Counter \nsynthesis is a black-box technique: the goal is to discover new counters which are useful for a proof, \nwhich do not necessarily correspond to anything in the program. This pa\u00adper addresses the latter problem. \nThis is the motivation behind our language-theoretic model of program correctness: by treating the P \nas a language of traces, we are forced to synthesize counting ar\u00adguments from scratch. Our interest in \ncounter synthesis stems from the fact that the internal control structure of P may be very compli\u00adcated. \nCounter synthesis gives a strategy for constructing proofs for P that avoids reasoning about its control \nand data simultaneously. We will explain counting proofs and our proof inference algorithm by way of \nan example. Consider the program that consists of an arbitrary number of threads whose control .ow graph \nis pictured to the right. The (global) integer variables s and t are initially 0. The task is to auto\u00admatically \nconstruct a proof that the error location eerror is unreachable (i.e., the program satis.es the spec\u00adi.cation \ns = t = 0/false). The task is complicated by the fact that the seemingly simple program has a complex \ncontrol structure, since it must retain the control location for every thread (of which there are unboundedly \nmany). We begin by sampling an error trace from this program, say t = t++; t++; s++; assume(s >= t) A \ncorrectness proof for t is a sequence of intermediate asser\u00adtions, shown below in Figure 2(a). This proof \ncan be generalized to a proof for a whole language of program traces. This is done by constructing a \n.nite automaton annotated with a Floyd/Hoare proof (with one state for each distinct assertion) as pictured \nin Fig\u00adure 2(b). It is easy to see that any trace accepted by this automaton satis.es the given speci.cation. \n Figure 2. Proof for the sample trace t. Unfortunately, this automaton does not accept every trace of \nthe program. We could continue by sampling a new trace, for instance 1 t = t++; t++; t++; s++; assume(s \n>= t), but it is already clear that this strategy is doomed to fail. There is no regular language which \ncontains all the program traces and which does not contain incorrect traces. Our solution to this problem \nis pictured to the right. This counting proof consists of a counting automa\u00adton A (a kind of restricted \ncounter machine) paired with an annotation . mapping the states of A to asser\u00adtions. The counting automaton \nA is a .nite automaton equipped with a N-valued counter denoted k (initially 0). Each transition of \nthe automaton is equipped with an action for k, which may be inc (increment the counter), dec (decrement, \nbut block unless the counter is = 1), tst (block unless the counter is = 1), or nop (do nothing). The \nannotation . associates with each state of this automaton a formula over the program variables and the \ncounter variable k. This annotation is inductive in the sense that each transition is associated with \na valid Hoare triple: for example, {k = t - s} t++; k++ {k = t - s}{k = t - s} s++; k--{k = t - s}{k \n= t - s} assume(t<s); assume(k=1) {false} A trace is accepted by A if it labels a path from q0 (the \ninitial state) to q1 (the .nal state), and none of the counter actions block. Every trace which is accepted \nby A is associated with a sequence of intermediate assertions which prove its correctness. This sequence \nis obtained from the accepting run of A by taking, for each position in the run, the assertion at the \ncurrent state with k replaced by its current value. For example, the proof for the trace t above is as \nfollows: This counting proof works not only for the trace t , but for every trace of the program (that \nis, the proof is enough to show that eerror is unreachable). The key to this proof is the use of the \ncounter variable k, which intuitively counts the number of t++ statements in excess of s++ statements \nalong a trace. Using this auxiliary counter allows us to make a simple, succinct argument for the correctness \nof this program. There are two algorithmic problems associated with our proof inference strategy: (1) \nhow to construct a counting proof for a set of sample traces (Figure 1 (a)), and (2) how to prove that \na counting proof recognizes all program traces (Figure 1 (b)). The essential idea for our solution to \n(1) is to encode the proof construction problem as an SMT query. Our encoding requires us to specify \nthe size of the candidate proof to .nd (e.g., the number of states that may be used), and will always \nsucceed if a proof of that size exists. The main insight behind our proof construction procedure is that \nby looking for small proofs, we can force an SMT solver to synthesize nontrivial counting arguments. \nFor example, we can force an SMT solver to discover the need to count the number of t++ statements in \nexcess of s++ statements in the proof above completely automatically, simply by asking for a proof with \n2 states. Our solution to (2) is based on the observation that counting automata can be converted into \na kind of labelled Petri nets. To enable our language inclusion checking procedure we use control .ow \nnets as our program model. A control .ow net is a hybrid of a control .ow graph and a Petri net. As in \na control .ow graph, a transition is labelled with an imperative program statement (over in.nite data \ndomains). As in a Petri net, tokens can be used to model in.nite control, such as (parametrized) concurrency. \nOnce we have modelled a program with a control .ow net, problem (2) reduces to a Petri net language inclusion \nproblem which is known to be decidable. 2. Motivating Example We will formalize the veri.cation problem \nfor an industrially mo\u00adtivated example [46] through a control .ow net and then present a counting proof. \nFigure 3(a) presents a simpli.ed version of the bluetooth device driver code (similar to the one that \nappears in [46]). The program consists of an arbitrary number of work threads, which all exe\u00adcute Add, \nand one stop thread, which executes Stop. The global variables are the integer variable pendingIo (initially \n1), and the Boolean .ags stopped, stoppingEvent, and stoppingFlag, (initially false). We want to show \nthat the statement assert(!stopped) never fails, which means that no con.guration is reachable where \none of the work threads is still working after the stop thread has ex\u00adFigure 3. (a) Bluetooth device \ndriver code. (b) Control .ow net for Bluetooth. The initial marking is as shown (no token other than \non a0 and on s0). The .nal markings are those where at least a3 has at least one token. (c) Bluetooth \ncounting proof.  ecuted the statement stopped = true. The correctness relies on the atomicity of the \nthree statements Enter, Exit, and Close. The bug detected in the version from [46] has been .xed by making \nEnter atomic. Control Flow Net. The control .ow net in Figure 3(b) models that an arbitrary number of \nwork threads and one stop threads run in parallel. To model the fact that unboundedly many work threads \ncan be active simultaneously, the initial Add transition Enter puts a token back on a0, so that Enter \nremains enabled (just as if yet another work thread was spawned). The number of tokens on ai models the \nnumber of work threads in the corresponding control location (there is always one token in Stop half \nof the net, since there is only one stop thread). A .nal marking is any marking where there is at least \none token on the error location a3. Each sequence of transitions (a .ring sequence) of the net that reaches \nsuch a .nal marking corresponds to a thread interleaving that violates the assertion. The goal is to \nprove that the corresponding sequence of statements is infeasible (has the postcondition false). Counting \nProof. The counting automaton in Figure 3(c) is a .nite state automaton augmented with a counter k. Transitions \nare labelled by letters of the alphabet of program statements and corresponding counter actions (the \nsame letters are used to label the transitions in the control .ow net). The counting proof consists of \nthis automaton and the inductive annotation which maps the automaton states to assertions (blue terms \nin the .gure). Intuitively, at any moment while reading a trace t (i.e., a se\u00adquence of statements), \nthe value of the counter k records by how much the Enter transitions outnumber the Exit transitions (ini\u00adtially \nby 0). The automaton states q0, . . . , q3 records what statements of the stop thread have appeared so \nfar, in sequence: none (recorded by q0), stoppingFlag = true (transition from q0 into q1), Close (transition \nfrom q1 into q2), assume(stoppingEvent) (transition from q2 into q3). The automaton state q4 is reached \nif: (1) the statement assume(stopped) of the work thread has appeared, or (2) the statement Enter of \nthe work thread has appeared after the state\u00adment stoppingFlag = true of the stop thread has appeared. \n It is easy to see that the annotation is inductive. Initially, the .ags stopped, stoppingEvent, and \nstoppingFlag have the value false, pendingIo is 1, and k is 0, and thus, the assertion for the initial \nstate q0 is satis.ed. One can check that for every tran\u00adsition, the corresponding Hoare triple holds. \nThe check of the trace inclusion between a control .ow net and a counter automaton is decidable (as we \nwill show in Section 6). To obtain an intuition why the inclusion here holds, consider the (informal) \ninvariants: s0 = q0, s1 = q1, s2 = q2, s3 + s4 = q3, and a1 + a2 = k. The annotation of the .nal state \nq4 with the assertion false means that every trace accepted by the counter automaton has post\u00adcondition \nfalse. Since every trace of the control .ow net is accepted by the counter automaton, this means that \nthe execution of the statement assume(stopped) is never feasible, i.e., the statement assert(!stopped) \nnever fails, which is what we wanted to show. 3. Proofs That Count One of the key contributions of this \npaper is a new formalism for proving program correctness, which we call counting proofs. A counting proof \nconsists of a counting automaton and an inductive annotation. The automaton de.nes a set of traces and \ndetermines what to count (by associating counter actions to transitions in the automaton). The inductive \nannotation is a correctness proof for the counting automaton, which shows that every trace accepted by \nthe automaton satis.es a given speci.cation. Thus, we may prove the correctness of a program P by exhibiting \na counting proof such that all traces of P belong to the counting automaton associated with the proof. \nIn this section, we give a formal de.nition of our notion of counting proof. Preliminaries First, we \nde.ne some terminology for our program model. We .x a (possibly in.nite) set S of memory states (usually \nde.ned as val\u00aduations assigning values to a .nite set of global and local vari\u00adables), a set S of program \nstatements, and a semantic function [\u00b7] : S . 2S\u00d7S which interprets each program statement as a re\u00adlation \nbetween memory states. A trace is a sequence of statements (i.e., a word in S *). Intuitively, we will \nthink of a program as a set if d(q, (k1, k2, ..., kn)) = (q 1 , (a1, a2, ..., an))of traces; this allows \nus to abstract away from the control structure and each ki 1 is de.ned as of the program, which may \nbe complicated. We .x a set of program assertions, which is denoted F, as well ki - 1 if ai = dec . ki \n> 0 . . . . .. . . as an entailment relation |= . S \u00d7 F. For s . S and . . F, s |= . indicates that \nthe assertion . holds in state s. A (pre/post) ki 1 . ki if ai = nop ki if ai = tst . ki > 0 unde.ned \notherwise speci.cation for P consists of a pair .pre/.post . F indicating a precondition and postcondition. \nIn the following, it will frequently be convenient to consider program assertions over an extended vocabulary \nthat includes a fresh set of N-sorted variable symbols V (depending on the application at hand, such \na variable symbol may be interpreted as the values of some counter variables, or as the number of tokens \non a place of a Petri net (Section 7)). The set of such extended program assertions will be denoted FV \n. For a statement s . S and assertions ., .1 , we use the typical Hoare notation {.} s {.1} to denote \nthat for every s, s 1 such that s |= . and (s, s 1) . [s], we have s 1 |= .1 . We extend this notation \nto sequences of statements in the obvious way. Counting proofs We may now introduce the de.nition of \ncounting proofs. We start by de.ning counting automata, which are .nite automata aug\u00admented with zero \nor more counter variables which can be incre\u00admented, decremented, and tested. De.nition 3.1 (Counting \nautomaton) A (deterministic) counting automaton is a 6-tuple A = (Q, n, q0, k0, d, O) where Q is a .nite \nset of states, n . N is the dimension of the automaton (i.e., the number of counters used by the automaton), \nq0 . Q is 2Nn an initial state, k0 . Nn is an initial vector, O : Q . is a mapping that takes each state \nto an upwards closed1 set of .nal (accepting) vectors, and d : Q \u00d7 S -Q \u00d7 Actn is a partial function \nwhich maps (state, program statement) pairs to pairs consisting of a successor state and an action for \neach counter, where Act = {inc, dec, nop, tst}. Note that since d is partial, not every state is associated \nwith a transition for each program statement. . Remark 3.2 A special case of particular interest is when \nthe acceptance condition of a counting automaton A = (Q, n, q0, k0, d, O) is speci.ed by a set of .nal \nstates F . Q (rather than a mapping O from states to upwards-closed sets of .nal vectors). This case \nis accommodated by setting O(q) = Nn for every .nal state q . F and O(q 1) = \u00d8 for every non-.nal state \nq 1 ./F . This special case is used frequently in this paper, and in diagrams of counting automata we \nwill use double circles to denote .nal states. We also remark that nondeterministic .nite automata are \na spe\u00adcial case of counting automata, where the dimension of the count\u00ading automaton is 0. Note that \nN0 is a singleton set, and so for any state q, the only choices for O(q) are N0 and \u00d8 (i.e., 0-dimensional \ncounting automata always fall into the case described above, where the acceptance condition is determined \nby a set of .nal states). . We now introduce some additional terminology for counting au\u00adtomata. Let \nA = (Q, n, q0, k0, d, O) be a counting automaton. A con.guration of A consists of a pair (q, k), where \nq . Q is a state and k . Nn is a valuation for each counter. The initial con.gu\u00adration is (q0, k0), and \nany con.guration (q, k) where k . O(q) is a .nal con.guration. We lift d to a partial transition function \non con.gurations as follows: 111 1 d((q, (k1, k2, ..., kn)), c) . (q , (k1, k2, ..., kn)) 1 Recall that \na set of vectors V is upwards closed if for all v . V and all v1 such that v = v1 , we have v1 . V . \n We lift d to a partial transition function d * on statement se\u00adquences in the obvious way. A trace w \n. S * is accepted by A if d * ((q0, k0), w) is a .nal con.guration. The set of all traces ac\u00adcepted by \nA is denoted L(A). We may now move on to our de.nition of an inductive annota\u00adtion. In essence, an inductive \nannotation is a Floyd/Hoare proof. De.nition 3.3 (Annotation) Let A = (Q, n, q0, k0, d, O) be a counting \nautomaton. Let K = {k1, ..., kn} be a set of distinguished N-sorted variable symbols. An annotation is \na map . : Q . FK . We say . is inductive if for all q, q 1 . Q, s . S, and k, k1 . Nn such that d((q, \nk), s) = (q 1 , k1) the Hoare triple {.(q)[k]} s {.(q 1)[k1]} holds (where for an assertion . and vector \nk = (k1, ..., kn) . Nn , .[k] denotes the formula obtained by replacing each ki with the corresponding \nelement ki of the vector k). . Finally, we may de.ne a counting proof as a pair consisting of a counting \nautomaton and an inductive annotation for it. De.nition 3.4 (Counting proof) A counting proof is a pair \n(A, .)consisting of a counting automaton A = (Q, n, q0, k0, d, O) and an inductive annotation . for A. \nWe say that (A, .) satis.es a given speci.cation .pre/.post if the following two conditions hold: (i) \n.pre |= .(q0)[k0] (ii) For all q . Q and all kf . O(q), we have .(q)[kf ] |= .post. . We now justify \nusing counting proofs as proof objects. Recall that our use of counting proofs is the following (informal) \nproof rule: Suppose that P is a program, (A, .) is a counting proof which satis.es the speci.cation .pre/.post, \nand that every trace of P is accepted by A. Then P satis.es the speci.cation .pre/.post. For this proof \nrule to be sound, we must show that every trace in L(A) satis.es the speci.cation .pre/.post. With this \ngoal in mind, we .rst prove a lemma. Lemma 3.5 Let A = (Q, n, q0, k0, d, O) be a counting automa\u00adton, \nand let . be an inductive annotation for A. Let t . S * . If q, q 1 , k, k1 are such that d * ((q, k), \nt) = (q 1 , k1), then the follow\u00ading Hoare triple holds: {.(q)[k]} t {.(q 1)[k1]} . Proof. By induction \non t . The base case (t is empty) is trivial. The induction step follows from De.nition 3.3 and the sequential \ncomposition rule for Hoare logic. We may now state the main result of this section: a soundness theorem \nwhich justi.es our proof rule. Theorem 3.6 Let (A, .) be a counting proof with A = (Q, n, q0, k0, d, \nO), and let .pre and .post be assertions such that (A, .) satis.es .pre /.post . Then for any t . L(A), \nt satis.es the Hoare triple {.pre } t {.post }. . Proof. Follows from Lemma 3.5, De.nition 3.4, the \nde.nition of L(A), and the consequence rule of Hoare logic. 4. Constructing Counting Proofs We now consider \nthe problem of automatically synthesizing a counting proof which certi.es that a given (.nite) set of \ntraces Tr . S * is correct with respect to a given speci.cation .pre /.post . Our algorithm for constructing \ncounting proofs is divided into two parts. The .rst part is a decision procedure which determines whether \na counting proof of a given size exists for a given set of traces and speci.cation (here size should \nbe understood infor\u00admally). The second part is a search procedure, which repeatedly calls the decision \nprocedure on different candidate sizes until a proof is found, and attempts to .nd the smallest proof \npossible. We start by describing the decision procedure, and then discuss the search procedure. The idea \nbehind our proof construction procedure is to encode the proof construction problem as a formula . and \nuse an off-the\u00adshelf SMT solver to .nd a model for .. From any such model, we may extract a counting \nproof (A, .) which satis.es .pre /.post and such that Tr . L(A). Since the goal is to develop a decision \nprocedure for proof construction, we must limit the program statement language and the language of program \nassertions to a decidable logic. A convex linear real formula is a conjunction of a .nite number of linear \ninequalities over a set of real variables with real coef.cients. The number of inequalities appearing \nin a convex linear real formula . construction to arbitrary values of the parameters N, M, and K is straightforward. \nThe construction of the QF UFNRA formula follows. Automaton constraints Without loss of generality, \nwe may con\u00adstruct a counting proof with state space Q = {1, ..., Q}. Recall that the transition function \nof a 1-dimensional counting automaton over the state space Q is a partial function d : Q \u00d7 S -Q \u00d7 Act, \n where Act = {inc, dec, nop, tst} is a set of counter actions. For our encoding, we introduce for each \ns . S(t ) {s1, ..., s|t|} a pair of uninterpreted function symbols ds : Q . Q as : Q . Act We now encode \nthe constraint that the counting automaton accepts the trace t. We introduce a set of integer variables \nq0, ..., q|t|, k0, ..., k|t|; the interpretation of these variables is that, after reading the pre.x \ns1s2 \u00b7 \u00b7 \u00b7 si of the trace t , the state of the counter automaton is qi, and the value of the counter \nis ki (q0 and k0 represent the initial state and initial value of the counter). This interpretation is \nencoded by the following constraints: I|t| .d-state dsi (qi-1) = qi i=1 I|t| .d-counter k0 = 0 . ki = \nki-1 + incr(asi (qi-1)) i=1 will be called the size of ., and denoted |.|. where In this section we \n.x a set of traces Tr and a pre/post speci.\u00ad cation .pre /.post . We will assume that .pre and .post \nare convex linear real formulae, and that every program statement can be ex\u00ad pressed as a convex linear \nreal formula. For simplicity, we will also incr(a) . .. .. 1 if a = inc -1 if a = dec otherwise 0 assume \nthat Tr consists of a single trace t = s1\u00b7 \u00b7 \u00b7 s|t| (the gener\u00adalization to multiple traces is straightforward). \nLet (A, .) be a counting proof, with A = (Q, n, q0, k0, d, O). The size of (A, .) is determined by four \nnumbers: 1. The number of states, #States(A, .) |Q| 2. The dimension of A, dim(A, .) n  The preceding \nconstraints ensure that t labels a path through the counting automaton and that at each step along this \npath ki is updated appropriately. Another constraint is required for t to be accepted by the counting \nautomaton, which is that none of the transitions that label the accepting path may block (recall that \nthe dec and tst counter actions block when the counter is 0). This non\u00adblocking condition is enforced \nby the following constraint: 3. The size of the assertions used in the annotation ., I|t|  #Atoms(A, \n.) q.Q .d-block asi (qi-1) . {dec, tst} . ki-1 = 1 |.(q)| i=1 The last requirement to ensure that t \nis accepted by the counting 4. The number of minimal .nal vectors: automaton is that we must synthesize \nan upwards closed set of .nal #Min(A, .) q.Q 1 1 vectors for the state q|t|. For the case of 1-dimensional \ncounting |{v : .v . O(q).v < v}| automata, an upwards closed set is completely determined by a single \nnatural number, which is the lower bound on the set. Thus, we introduce an integer variable k.nal and \ncreate a constraint that Our decision procedure will take four additional parameters as the value of \nthe counter after reading t is greater than or equal to input Q, N , K , M . N, corresponding (in order) \nto the four com\u00ad ponents of counting proof size described above. The idea behind this algorithm is to \nconstruct a QF UFNRA2 formula which is sat\u00adis.able iff there exists a counting proof (A, .) such that \nA accepts t, A satis.es .pre /.post , #States(A, .) = Q, dim(A, .) = N, #Assert(A, .) = K, and #Min(A, \n.) = M. For presentation purposes, we assume that N = M = 1 and that we are searching for a proof with \nK = Q with one atom per state (but that Q is arbitrary). The generalization of the 2 Quanti.er-free non-linear \nreal arithmetic formulae with uninterpreted function symbols k.nal: .accept k.nal = k|t| Collecting \nthese constraints, we have .A .d-state . .d-counter . .d-block . .accept Models of .A correspond to \nQ-state, 1-dimensional counting automata which accepts the trace t. Annotation constraints We now consider \nthe constraints used to construct the inductive annotation of the counting automaton. We use a constraint-based \ntechnique to synthesize linear invariants, as described in [15]. Fix a set of program variables X = \n{x1, ..., x|X|}. For each program variable xi, we introduce an uninterpreted function sym\u00ad (ds(q)M , \nas(q)M) if .i.q = qi . s = si-1 d .(q, s). bol Cxi of sort Q . R. We also introduce two additional uninter\u00ad \npreted function symbols Ck, C1 of sort Q . R. For a given state q . Q, Cxi (q) will be the coef.cient \nof xi, Ck (q) will be the co\u00adef.cient of k, C1(q) will be the constant coef.cient in the linear inequality \nassigned to q. That is, for q . Q, the annotation at q will be: |X| inv(q) Cxi (q) \u00b7 xi + Ck (q) \u00b7 k \n+ C1(q) = 0 i=1 For any statement s . S, we use tf(s) to denote the transition formula of s, which is \na formula over the variables x1, ..., x|X|and their primed copies x1 1 , ..., x|1 X| that represents \nthe meaning of the statement s. For a counter machine action a . Act, we use tf(a) to denote the transition \nformula corresponding to a, de.ned below as: |X| M MM . .q. Cxi (q)\u00b7 xi + Ck (q)\u00b7 k + C1(q)= 0 i=1 The \nfollowing proposition states that our encoding is, in a sense, complete. Proposition 4.1 Let Tr be a \n.nite set of traces (such that each command is expressible as a convex linear real formula) and let .pre/.post \nbe a (convex linear real) speci.cation. Let N, Q, K, M . N. The problem of determining whether there \nexists a counting proof (A, .) that satis.es the speci.cation .pre/.post, such that Tr . L(A), and such \nthat #States(A, .) = Q, dim(A, .) = N, #Assert(A, .) = K, and #Min(A, .) = . M, is decidable. k1 = k \n+ 1 if a = inc 4.1 Searching for Small Counting Proofs k = 1 . k1 = k - 1 if a = dec . . .. . . tf(a) \nThe decision procedure presented in the preceding section suggests k = 1 . k1 if a = tst = k a simple \nalgorithm for constructing a counting proof. Suppose we k1 = k if a = nop are given a set of traces \nTr and a speci.cation .pre/.post. First, we check whether some t . Tr violates the speci.cation .pre/.post \n(this can be accomplished with an SMT query). If such a t exists, We may now de.ne the consecution constraints, \nwhich ensure that the annotation is inductive. We de.ne a consecution constraint for each i . {1, ..., \n|t|} as follows: 11 1 .i (.k, k, X, X )(inv(qi-1).tf(si).tf(asi (qi-1)) . inv(qi)) where inv(qi)1 denotes \nthe formula obtained from inv(qi) by re\u00adplacing each variable xi with its primed copy xi 1 and k with \nk1 . The last annotation constraints ensure that the counting proof satis.es the speci.cation .pre/.post: \n.init (.k, X)(.pre . inv(q0)) ..nal (.k, X)(inv(q|t|) . k = k.nal . .post) The annotation constraints \nde.ned in this section all feature uni\u00adversal quanti.cation. However, all the formulae de.ned in this \nsec\u00adtion belong to a class of formulae for which the universal quanti\u00ad.ers can be replaced by existential \nquanti.ers by applying Farkas lemma (see [15] for details). We will use .. i , .. and .. to init .nal \ndenote the corresponding transformed formulae. Finally, we collect the annotation constraints into a \nsingle for\u00admula ..: we are done: no proof exists. Otherwise, enumerate the space of parameters (N, Q, \nK, M) . N4 , applying the decision procedure described in the previous section until a counting proof \nis found. The termination of this simple algorithm relies on the following observation: Observation 4.2 \nLet Tr be a set of traces and let .pre/.post be a speci.cation such that for each t . Tr, {.pre} t {.post}. \nThen there is a counting proof (A, .) which satis.es .pre/.post and which accepts every trace in Tr. \n. The intuition behind this observation is that we can always .nd a counting proof where the counting \nautomaton is 0-dimensional (i.e., a counting automaton that does not use counters) and shaped like a \npre.x tree. The existence of an inductive annotation for such an automaton is a consequence of Farkas \nlemma. While this observation is enough to prove termination of our proof synthesis procedure, it is \nnot very satisfying: it says that in the worst case, we can always construct a counting proof that does \nnot, in fact, count. The key insight behind our counting proof synthesis procedure is that we can constrain \nthe parameters given to the decision problem to force an SMT solver to discover a non- I |t|.. . .. .init \n. ..nal . .i i=1 Counting proof extraction We conjoin the automaton and anno\u00adtation constraints to arrive \nat a formula . whose models correspond to counting proofs: . .A . .. Suppose that M is a model of .. \nFor a term term, we use termM to denote the interpretation of term in the model M. A counting proof can \nbe constructed as follows: Q {1, ..., Q} M q0 q 0 k0 k0 M  trivial counting argument. For example, consider \nthe sample trace t from Section 1. Setting Q = 2, K = 2, N = M = 1, we can force the SMT to synthesize \na non-trivial counter, simply because there is no 0-dimensional counting proof for these traces that \nonly uses 2 states (so, by virtue of the fact that our decision procedure will .nd a 2-state proof if \none exists, it must .nd a proof that uses a non-trivial counting argument). In the remainder of this \nsection, we present a re.nement on the simple algorithm discussed above, which .xes a particular way \nof enumerating the parameter space. The intuition behind this re.ne\u00adment is that we want to synthesize \na counting proof that minimizes the sum of the number of states (Q) and the number of assertions (K).3 \nOur aim in presenting this algorithm is not to present a practi\u00adcal proof construction procedure, but \nrather a theoretical algorithm capable of synthesizing proofs that are (in a sense) optimal. In prac\u00adtice, \none would expect a heuristic-based method for exploring the M {k : k = k.nal} if q = qn+1O .q.3 This \nalgorithm can be adapted to minimize any objective function which \u00d8 otherwise is strictly increasing \nin Q and K. parameter space (which cannot necessarily guarantee optimality) would be more effective. \nObservation 4.2 yields a coarse upper bound on the sum of the number of states and atoms used in a counting \nproof for a given a set of traces Tr of 2 \u00b7 |t |. Since we have an upper bound t.Tr on Q + K, the parameter \nspace Q, K . N \u00d7 N can be searched ef.ciently using binary search. The termination of this algorithm \nrelies on the following proposition: Proposition 4.3 Let Tr be a .nite set of traces, .pre /.post be \na speci.cation, and Z . N. The problem of determining whether there exists a counting proof (A, .) that \nsatis.es .pre /.post such that Tr . L(A), and such that #Atoms(A, .) + #States(A, .) = Z is decidable. \n. This proposition is not trivial, because even though .xing the size of #Atoms(A, .) + #States(A, .) \nimplies .nitely many choices for Q and K, the space for the remaining parameters N and M is in.nite and \ncannot be searched exhaustively. The following two lemmas imply that we may place a .nite upper bound \non N and M once Tr and Q are .xed. Lemma 4.4 Let A = (Q, n, q0, k0, d, O) be a counting automa\u00adton, and \nlet Tr be a .nite set of traces which are accepted by A. There exists a mapping O1 : Q . 2Nn such that \nthe counting proof (A1, .) with A1 = (Q, n, q0, k0, d, O1) satis.es #Min(A1, .) = |Tr | and Tr . L(A1). \n. Proof. Intuitively, we de.ne O1 to be the upwards closure of the set of con.gurations that result from \nreading the traces in Tr . Formally, for any q . Q, de.ne 11 1 O(q) {k. Nn : (.t . Tr, .k . Nn)(k = k. \nd * ((q0, k0), t ) = (q, k))} Lemma 4.5 Let (., A) be a counting proof, with A = (Q, n, q0, k0, d, O). \nThere exists a counting proof (.1, A1) such that A1 recognizes the same language as A, and A1 has dimension \nat most 3|dom(d)| (where |dom(d)| indicates the cardinality of the domain of the partial transition function \nd). . Proof. Suppose that n > 3|dom(d)|. By the pigeonhole principle, there exists distinct counters \ns, t . {1, ..., n} which agree on all their actions. That is, for any q . Q, s . S, if d(q, s) = (a1, \n..., an), then as = at. Without loss of generality, we can assume that s = 1 and t = 2. Letting (k1, \n..., kn) = k0, we de.ne . k1 -k2. Without loss of generality, we may assume that . = 0. We construct \nan (n-1)\u00addimensional counting automaton A1 = (Q, n - 1, q0, k0 1 , d1 , O1)and an inductive annotation \n.1 as follows: k1 0 (k2, ..., kn), where (k1, ..., kn) = k0  For any q, s such that d(q, s) = (q 1 \n, (a1, ..., an)), we de.ne  d1(q, s) (q 1 , (a2, ..., an)) For any q . Q, we de.ne O1(q) {(min{k1-., \nk2}, k3, ..., kn) : (k1, ..., kn) . O(q)} For any q . Q, we de.ne .1(q) (.k1)(k2 - . = k1 . .(q)) (the \nquanti.er (.k1) can be eliminated to yield a convex linear real formula). The proof of Proposition 4.3 \nfollows easily from the preceding two lemmata. We conclude this section with an algorithm summarizing \nthe search procedure described above. In this algorithm, we use con\u00adstraints(...) to denote the formula \nconstructed in the previous sec\u00adtion, and extract-proof)(.) to denote the counting proof extracted from \na model of a formula .. Input: Tr , .pre , .post such that for all t . Tr , {.pre } t {.post }Output: \nA counting proof (A, .) which satis.es .pre /.post and with Tr . L(A) min . 2; a max . 2 \u00b7 t.|Tr |t|; \nM = |Tr |; /* Binary search for minimal proof */ while max = min do mid . (max + min)/2; Q . mid - 1; \nK . 1;  N . 3|S(Tr)|\u00b7Q; // S(Tr) = {S(t ) : t . Tr }. . constraints(Tr, .pre , .post , N , Q, K , M \n); /* Search for proof of size Q + K */ while . is unsatis.able and Q = 1 do (K, Q) . (K + 1, Q - 1); \nN . 3|S(Tr)|\u00b7Q; . . constraints(Tr, .pre , .post , N, Q, K, M); end if . is satis.able then (A, .) . \nextract-proof(.); max . mid; end min . mid + 1; end return (A, .) Algorithm 1: Counting proof construction \n 5. Control Flow Nets In the preceding, we have considered the control structure of a program to be a \nblack box. In order to implement the algorithm outlined in Figure 1, we need an effective procedure for \nchecking whether a given counting automaton accepts all the traces of a given program. In this section, \nwe introduce control .ow nets, an expressive program model that features in.nite control, but for which \nthe inclusion check is decidable (Section 6). We begin by introducing some notions from Petri net theory, \nwhich form the basis of control .ow nets. De.nition 5.1 (Petri net structure) A Petri net structure is \na tuple N = (P, T , E ), where P is a .nite set of places, T is a .nite set of transitions, and E . (P \n\u00d7 T ) . (T \u00d7 P ) is an incidence relation connecting places to transitions and vice-versa. . We now recall \nsome standard de.nitions for Petri nets. Let N = (P, T , E ) be a Petri net structure. Given a transition \nt . T , we de.ne its pre-set, t, and post-set, t , as the set of places with incoming/outgoing arcs to \nt: t {p : (p, t) . E } t {p : (t, p) . E } A marking of N is a map m : P . N. Given a marking m and \na transition t . T , we say that t is enabled in m if for all p . t, t m(p) = 1. We write m . m 1 to \ndenote that t is enabled in m and that for all p, m 1(p) = m(p) - |{p} n t| + |{p} n t | For markings \nm, m 1 we write m : m 1 if for all p, m(p) = m 1(p). A set of markings M is upwards closed if for all \nm . M and all m 1 such that m : m 1, we have m 1 . M. Any upwards closed set of markings can be represented \nby its set of minimal elements, which is always .nite. We may now introduce our program model, control \n.ow nets. Control .ow nets are programs which have Petri nets as control structures. We may think of \nthem as an in.nite analogue of control .ow graphs: just as a control .ow graph is a .nite automaton la\u00adbelled \nby program statements, a control .ow net is a Petri net struc\u00adture with transitions labelled by program \nstatements. A slightly un\u00adusual feature (although not without precedent [25]) is that we also include \nacceptance conditions for control .ow nets this enables us to view control .ow nets as language recognition \ndevices. For\u00admally, De.nition 5.2 (Control .ow net) A control .ow net is a tuple P = (P, T , E, e, m0, \nF ), where (P, T , E ) is a Petri net structure, e : T . S is an injective map which labels transitions \nwith program statements, m0 is an initial marking and F is an upwards closed set of .nal markings. . \nControl .ow nets are a very expressive program model. For example, Figure 3(b) depicts a control .ow \nnet for a concurrent program with arbitrarily many threads. With their foundations on Petri nets, modelling \nconcurrency is a particularly strong suit for control .ow nets, but they can also be useful for representing \nother control features. For example, Figure 4 depicts a control .ow net where tokens are used to count \nthe number of stack frames in a recursive program. In view of our black-box strategy for counting proof \nsynthesis, we conclude this section with a de.nition of the traces and correct\u00adness of a control .ow \nnet. De.nition 5.3 (Correctness) A trace of a control .ow net P = (P, T , E, e, m0, F ) is a sequence \nof statements t = s1...sn . S * such that there exists transitions t1, ..., tn where e(t1) = s1, . . \n. , e(tn) = sn, and markings m1, ..., mn where mn . F such that t1t1tn m0 . m1 .\u00b7 \u00b7 \u00b7 . mn . The set \nof all traces of P is denoted L(P). Given a pre/postcon\u00addition pair .pre /.post , the control .ow net \nP is correct if all of its traces are correct, i.e., if the Hoare triple {.pre } t {.post } holds for \nall t . L(P). . This result still holds even if we relax the accepting sets for control .ow nets and/or \ncounting automata to be semi-linear rather than upwards closed. . Proof. The proof proceeds by reduction \nto an inclusion problem for Petri net languages, a problem known to be reducible to Petri net reachability. \nIt is suf.cient to show that for any counting au\u00adtomaton we may construct a control .ow net which recognizes \nthe same language, which is a deterministic Petri net (by construction). From the point of view of language \nrecognition, control .ow nets are equivalent to L-type labelled Petri nets.4 In [42] it is show that \ndeterministic L-type Petri net languages are closed under compli\u00adment, and in [26], it is shown that \nthe problem of checking the inclusion of an L-type Petri net language in a deterministic L-type Petri \nnet language is decidable. An example illustrating the construction of a control .ow net from a counting \nautomaton in the .gure below, which depicts the control .ow net associated with the counting automaton \nfor the example in Section 1. Note that in this picture, the transition labelled S represents three (parallel) \ntransitions, one for each letter in S = {t++, s++, assume(s >= t)}. In the rest of this proof, we make \nthe construction formal.  Let A = (Q, n, q0, k0, d, O) be a counting automaton. We de.ne a control .ow \nnet PA = (P, T , E, e, m0, F ) as follows. The places of PA are de.ned to be the disjoint union of the \nset of states of A and a set of n distinguished counter places p1, ..., pn: P = Q + {p1, ..., pn} The \ntransitions correspond to points in the domain of d: T = {(q, s) . Q \u00d7 S : d(q, s) is de.ned} We de.ne \nthe incidence relation E indirectly, by de.ning the pre-set and post-set of every transition. Let (q, \ns) . T and suppose that d(q, s) = (q 1 , (a1, ..., an)). Then we may de.ne: (q, s) = {q} . {pi : ai = \ndec . ai = tst} (q, s) = {q 1} . {pi : ai = inc . ai = tst}We de.ne a map . from con.gurations of A to \nmarkings of PA. 6. Proof Checking A counting proof (A, .) which satis.es a speci.cation .pre /.post \nrepresents a set of correct behaviours which are correct with respect to that speci.cation. If every \ntrace of a given program P is repre\u00adsented by A, this implies that P is correct. Thus, in order to check \na counting proof, we must check the inclusion of the language of traces of a control .ow net P inside \nthe language of a counting au\u00adtomaton. In this section, we prove that this check is decidable and give \na characterization of the computational complexity of proof checking. First, we state our decidability \nresult. The essence of the proof of this theorem is that counting proof checking can be reduced to Petri \nnet reachability, which is known to be decidable [35]. Theorem 6.1 Let P = (P, T , E, e, m0, F ) be a \ncontrol .ow net and let A = (Q, n, q0, k0, d, O) be a counting automaton. The problem of checking the \ninclusion L(P) . L(A) is decidable. .(q, (k1, ..., kn)) = .p. . .. .. For a given con.guration (q, (k1, \n..., kn)), we de.ne 1 if p = q ki if p = pi 0 otherwise We de.ne the initial marking m0 to be .(q0, \nk0) and we de.ne the (upwards closed) set of .nal markings F by taking the image of the accepting con.gurations \nof A under .. The labelling function e is de.ned by e(q, s) = s. It is easy to prove that this mapping \n. from con.gurations of A to markings of PA is an isomorphism when restricted to the reachable con.gurations \nof A and the reachable markings of PA. Lastly, it is clear to see that d(q, k) = (q 1 , k1) iff .(q, \nk) . 1 , k1 .(q ), which completes the proof of equivalence. 4 There is a slight technical difference: \nthe labelling function for labelled Petri nets is not required to be injective. We will, in fact, ignore \nthe injec\u00adtivity restriction in our construction. 6.1 Complexity of Proof Checking The decidability \nof this language inclusion problem is of fun\u00addamental importance, because it justi.es calling counting \nproofs proofs. A desirable result would be that checking proofs is not only decidable but ef.ciently \nso. Theorem 6.1 relies on a reduction to Petri net reachability. This problem is at least EXPSPACE-hard, \nbut the best known upper bound for its complexity is NONELE-MENTARY. So, a natural question is: can we \ndo better than reduc\u00ading to Petri net reachability? The following theorem states that we can not in general: \nPetri net reachability and counting proof check\u00ading are equivalent from the perspective of computational \ncomplex\u00adity. Theorem 6.2 The Petri net reachability problem is polytime inter\u00adreducible with the counting \nproof checking problem. . Proof. One direction of the proof is given in the proof of Theo\u00adrem 6.1 (it \nis easy to prove that the reduction to reachability is polytime). For the other direction, we give a \npolytime reduction from the single-place zero-reachability problem to proof checking. This implies the \nresult due to Lemma 4.1 in [24]. In fact, [24] states a slightly weaker result: that reachability is \nrecursively reducible to single-place zero-reachability. However, it is easy to see that the reduction \nfrom the proof of [24] is polytime. Consider a Petri net G = (P, T, E), a marking m of G, and a place \np . P . Given an initial marking m0, we say that a place p is zero-reachable if there exists a marking \nm 1 which is reachable from m0 and such that m 1(p) = 0. We reduce the problem of checking zero-reachability \nof p to counting proof checking by constructing a control .ow net P and a counting automaton A such that \nA accepts all the traces of P iff p is zero-reachable. We suppose that zr is a new transition which does \nnot belong to T . We take P = (P, T 1 , E, m0, e, F ), where T 1 = T . {zr}, e is an arbitrary injective \nlabelling, and F is the set of all markings (P , E, and m are as above). Intuitively, P is just G extended \nwith a do nothing transition zr, which can always .re. We de.ne a counting automaton A = ({q}, n, q, \nk0, d, O) from G as follows. De.ne n |P |, and let place : {1, ..., n} . P be a bijection. The initial \nvector is de.ned to be k0 (k1, ..., kn), where for each i, ki = m0(place(i)) The transition function \nis de.ned, for any c . S such that there is some t . T with e(t) = c, by d(q, c) (q, (a1, ..., ai)) where \nfor each i It is easy to see that the control .ow net P and the counting automaton A act exactly the \nsame, except at markings where P can .re zr, but A cannot. Such a marking is reachable from m (in P and \nA) iff p is zero reachable m (in G), thus completing the proof. While the decision problem for proof \nchecking has high com\u00adputational complexity, from the standpoint of certifying the correct\u00adness of a \nprogram we may be satis.ed with a faster semi-decision procedure. For example, acceleration has proved \nto be an effective technique in practice for Petri net reachability [7]. We also note a recent result \nby Leroux [35]: if a given marking of a Petri net is not reachable, there exists a Presburger-de.nable \ninductive invari\u00adant for the Petri net. This allows for the possibility of using well\u00adknown reachability \nalgorithms for (sequential) integer programs (e.g., [12, 39]) to be used for counting proof checking. \n7. Completeness We now show the (relative) completeness of our counting proof method, when programs are \nmodelled as control .ow nets. First, we observe that proving that a control .ow net P satis.es a given \nspeci.cation .pre/.post is equivalent to proving that a particular .attened program Pb satis.es .pre/.post. \nThe .attened program is a sequential program with extra natural-typed variables which are used to represent \na marking. We then show that any inductive assertion for Pb can be (trivially) transformed into a counting \nproof. The relative completeness of counting proofs thus follows from the relative completeness of the \ninductive assertion method. We now formalize this argument. Let P = (P, T, E, e, m0, F ) be a control \n.ow net. A con.g\u00aduration of P is a pair (m, s), where m is a marking and s . S is a memory state. The \n.attened program Pb is a transition sys\u00adtem where the state space is the set of con.gurations of P and \nthe transition relation is 1 1 t1 (m, s) . (m , s ) .. .t . T.m . m 1 and (s, s ) . [e(t)] A .attened \nassertion is a formula in FP (assertions over an extended vocabulary that includes an additional variable \nsymbol p of sort Nfor each place p . P ). A con.guration (m, s) of P can be viewed as a structure for \nthis vocabulary (in the model-theoretic sense) by interpreting each new variable symbol p as m(p). For \n.attened assertions ., .1 and a transition t . T , we write {.} t {.1} if for all con.gurations (m, \ns) and (m 1 , s 1) such that (m, s) |= . t and (m, s) . (m 1 1 , s 1), we have (m , s 1) |= .1 . ai \n= . .. . .. . tst if place(i) . t n t De.nition 7.1 Let P = (P, T, E, e, m0, F ) be a control .ow net \nand let .pre/.post be a speci.cation. A global inductive assertion dec if place(i) . t is a .attened \nassertion . for which the following hold: inc if place(i) . t nop otherwise .pre . .m0 |= . = .post We \nalso add another transition to d for the distinguished do noth\u00ad . . .F | For all t . T , {.} t {.} ing \ntransition zr, except that instead of doing nothing, we check that p is non-zero: with one exception: \nwe de.ne d(q, e(zr)) (q, (a1, ..., an)) ai = tst nop if place(i) = p otherwise Last, we de.ne O by O(q) \n{(k1, ..., kn) . Nn : .m . F..i.ki = m(place(i))}. We de.ne an annotation . for A that is trivially inductive \nby taking .(q) true. We have that (., A) is a counting proof. where .m0 is a formula de.ning the initial \nmarking m0 and .F is a formula de.ning the set of .nal markings F . . Theorem 7.2 Let P = (P, T, E, e, \nm0, F ) be a control .ow net and let .pre/.post be a speci.cation. If there exists a global inductive \nproof that P satis.es the speci.cation .pre/.post, then there exists a counting proof. . Proof. Let P \n= (P, T, E, e, m0, F ) be a control .ow net and let .pre/.post be a speci.cation. Suppose that . is a \nglobal induc\u00adtive assertion for Pb that proves that P satis.es the speci.cation .pre/.post. We construct \na counting automaton A that is equivalent to P as in the proof of Theorem 6.2. Consider the formula .1 \nobtained by replacing each place variable p with its associated counter variable ki. It is easy to check \nthat (A, .q..1) is a counting proof that proves that P satis.es the speci.cation .pre /.post . 8. Discussion \nThrough Examples In this section, we use examples to have a more in-depth discussion about a few points \nabout the counting proofs framework. These points include: Control .ow nets are a very general mechanism \nfor representing programs with in.nite control, no matter what the source of in.nity of the control may \nbe (Section 8.1).  The structure of counting proof is in some sense independent of the control .ow structure \nof the original program (Section 8.1).  Control .ow nets encode a veri.cation problem. That is, they \nrepresent an integration of the control .ow of the program and the correctness property. An adequate \nrepresentation of program and property by a control .ow net may not exist, and if it does, it may be \ndif.cult to build (Section 8.2).  8.1 Tree Traversal Example On the right is a recursive (pre\u00adorder) \ntree traversal routine. We will give two implementations of this program, one a sequential recursive \nprogram and the other a parallel re\u00adcursive program, to illustrate two important features of the counting \n proofs framework: .rst, control .ow nets are a very general mech\u00adanism for representing programs with \nin.nite control; and second, counting proofs are in some sense independent of the control .ow structure \nof the original program. We will use two different implementations of the generic traver\u00adsal template \nfrom above: (i) a sequential recursive implementation, and (ii) a parallel and recursive implementation, \nto demonstrate the generality of the control .ow nets, and the independence of count\u00ading proofs structure \nfrom that of the program. We diverge slightly from the presentation of counting proofs and control .ow \nnets from the preceding sections by using an acceptance condition based on linear arithmetic formulae \nrather than upwards closed sets (i.e., the set of accepting vectors of a counting proof and the set of \naccept\u00ading markings of a control .ow net can be described by a QF LRA formula rather than just an upwards \nclosed set). As noted in Sec\u00adtion 6, proof checking is decidable for this class (and in fact, the more \ngeneral class of semi-linear sets). It is easy to see that the proof synthesis procedure from Section \n4 can be adapted to this more general setting as well. Recursive Traverse We .rst look at a variation \nof the code above which is a sequential recursive program to demonstrate how recursive programs (which \nhave non-regular trace languages) can be modelled using control .ow nets. It is known that Petri net \nlanguages are incomparable with context free languages. However, they do properly include (and the inclusion \nis proper) the set of bounded context free lan\u00adguages, which is the most general class for which decidability \nre\u00adsults have been proved [21]. Figure 4 includes a simpli.ed implementation of Traverse which abstracts \naway the heap manipulation operations, but keeps the relevant control information. We introduce two global \ncounters to count the number of leaves and internal nodes that are visited by the Traverse() routine. \nIf nodes and leaves are initially Figure 4. Sequential Traverse code and control .ow net. The control \n.ow net accepts when a token is at p2 and there are no other tokens.  set to 0, then after Traverse \nis .nished, for any binary tree the property leaves = nodes + 1 is true. Figure 4 also illustrates the \ncontrol .ow net for this program. A call statement is modelled by two transitions: a call transition \nand a return from call transition. The call adds a token at the place p3 (the entry location of Traverse), \nto trigger another execution of the method body. However, the current execution is blocked from progressing \n(note the incoming edge from place p6 to the return from call statement) until a return token is provided \nthrough p6. The erroneous traces (and therefore those in the language of the control .ow net) are those \nthat put a token at place p2 (i.e. when the assertion is violated), and all other places contain zero \ntokens. The latter ensures that the all executions of all pending frames of Traverse are completed before \nthe property is checked to hold. The control .ow model allows several partial executions of different \nframes to co-exist, and the property does not hold until they all .nish. Proof of Correctness for Traverse \nThe proof of the correctness of the recursive Traverse ap\u00adpears on the right. It is a counting automaton \nwith an additional counter variable k, which counts the differ\u00ad  ence between nodes+1 and leaves. Note \nthat the initial value of this counter is 1 (rather than 0, as we have seen in previous examples). When \nTraverse returns to the Main procedure and we check the assertion condition count and proceed to error \nlocation (i.e., we execute assume(leaves != nodes + 1)), we move to the state q1 and stop reading additional \nstatements. The automaton accepts when the .nal value of the counter k is 0, which implies that 0 = k \n= nodes - leaves + 1, contradicting the assumption leaves = nodes + 1.  Figure 5. Parallel Traverse \ncode and control .ow net. The con\u00adtrol .ow net accepts when a token is at p2 and there are no other tokens. \nRecursive and Parallel Traverse Figure 5 presents a variation of the traverse implementation from Figure \n4 in which the two recursive calls to Traverse are executed in parallel by forking a new thread for one \nof them. This program is both concurrent and recursive with both unbounded recursion and unbounded parallelism, \nwhich puts it in a class of very dif.cult programs to verify. The control .ow net for the parallel version \nis also depicted in Figure 5. Note that the join statement expects a token provided after the completion \nof the execution of the forked thread to continue, as with return from call in the recursive case. A \nremarkable fact is that the proof of correctness of this version of Traverse is still the same proof \nthat was presented in the previous section for the recursive version (with the minor addition of the \njoin action to the set of actions call, return, return from that are labelling the self loop on q0). \nDespite the fact that the two programs have substantially different control .ow structure, the counting \narguments for the correctness of their set of traces are the same. This is due to the fact that the proof \nis constructed based on a set of program traces, and independent of the control structure. Basically, \nin both cases the same counting argument applies for the correctness of program traces. It is a rather \ninteresting feature to be able to reuse a proof of correctness when a program is changed, for example, \nfor performance reasons (as is the case when we parallelize Traverse).  8.2 Ticket Algorithm Our approach \nassumes that the alphabet of program statements is .nite. If an unbounded number of threads execute a \nprogram over local variables, we need an in.nite alphabet of statements (each program statement that \nmanipulates a local variable, must be copies for each thread). However, our approach may still be applicable \nby using a symmetry argument. This section gives an example of such an argument. We consider a well-known \nmutual exclusion protocol for an unbounded number of processes, namely the ticket algorithm. At each \ninstant, a ticket counter t contains the value for the next available ticket, and a service counter s \ncontains the number of already serviced clients. A client can acquire a ticket by setting its own local \nticket number m to the current value of the ticket counter t, after which t is incremented by 1 to re.ect \nthe available ticket for the next client (t++). When a local ticket number m is equal to or smaller than \nthe service number s, the client can enter the critical section (assume(m <= s)). When this customer \nexits the critical section, the service number s is incremented by 1 (s++). The Ticket program con\u00adsists \nof an arbitrary number of threads which each execute the same code, pictured to the right.  The variables \ns and t are global (initially, s = t = 0). The variable m is local to each thread. The mutual exclusion \nproperty is that at most one thread can be at crit, or equivalently, while some thread T1 is still at \ncrit, another thread T2 cannot enter crit. Interestingly, it does not seem possible to encode the veri.ca\u00adtion \nproblem for mutual exclusion by a control .ow net (even after using a symmetry argument). Instead of \nmutual exclusion, we will consider a stronger correctness property (i.e., a property that im\u00adplies mutual \nexclusion): if a thread T2 has requested a ticket after another thread T1, then T2 cannot enter crit \nwhile T1 is still at wait or crit. For brevity we refer to this property as FCFS, First Come First Serve. \nOur encoding of the FCFS property relies on the notion of minimal error traces. Consider an error trace \nt which violates FCFS. We call t minimal if no proper pre.x of t already violates FCFS. To prove correctness, \nit is suf.cient to show that every minimal error trace is infeasible. We can decompose every minimal \nerror trace as follows (we mark a statement by the thread that executes it): t ; [T1: m2=t++]; t 1; [T2: \nm1=t++]; t 11; [T2: assume(m1<=s)] where [T1: s++] does not occur in t , in t 1, or in t 11. That is, \nevery minimal error trace contains, in order, the request of T1, the request of T2, and, at the last \nposition, the enter of T2, and thread T1 may or may not enter after its request, but if it does, it cannot \nnot exit. In the setting above, the thread T2 is the bad thread. We now use a symmetry argument: without \nloss of generality, we may assume that the bad thread is thread 0. The reason that this is no loss of \ngenerality, is due to the symmetry of Ticket. For any minimal error trace where the bad thread is some \nthread other than thread 0, we may simply swap that thread and thread 0 and arrive at another minimal \nerror trace, one where the bad thread is thread 0. Thanks to this symmetry, it is suf.cient to show that \nall such 0-distinguished minimal error traces are infeasible. We .nitize the alphabet of program statements \nby forgetting the local variables of every environment thread (i.e., a thread other than thread 0). The \nstatement m = t++ of an environment thread becomes = t++ (which is semantically the same as t++), and \nlikewise assume(m <= s) becomes assume( <= s) (which is semantically the same as assume(true)). It is \nsuf.cient to show that every 0-distinguished minimal error trace over the .nite al\u00adphabet of program \nstatements is infeasible (since forgetting local variables can only make more traces feasible). The set \nof traces of the control .ow net in Figure 6(a) con\u00ad tains all 0-distinguished minimal error traces over \nthe .nite al\u00adphabet of program statements (incidentally, it contains also some non-minimal ones). The \ntransitions and places are arranged in three columns. The left most column corresponds to environment \nthreads that acquire their ticket before thread 0, the second col\u00adumn corresponds to the distinguished \nthread 0, and the last column corresponds to environment threads that acquire their ticket after thread \n0.  Figure 6. Ticket: (a) Control .ow net. The set of .nal markings is de.ned by p1 + p2 = 1 . p5 = \n1. (b) Counting proof. Counting Proof of Ticket The counting automaton shown in Fig\u00adure 6 has three states. \nThe initial state is q0, its only .nal state is q2. The initial value of the counter k is 0. While in \nstate q0, the automaton counts the request statements (positively) and the exit statements of environment \nthreads (negatively); it does not count enter statements. While in state q1, it counts the exit statements \nof environment threads (negatively); it counts neither request state\u00adments nor enter statements. The \nrequest statement of the distin\u00adguished thread leads from q0 to q1. The enter statement of the dis\u00adtinguished \nthread leads from q1 to q2 if the tst operation succeeds, i.e., if k = 1. Proof Checking We use this \nexam\u00adple to convey our intuition that prov\u00ading the inclusion of the language of a control .ow net in \nthe language of a counting automaton often involves a p1 + p2 = k p0 = q0 p4 = q1 p5 = q2 . k = 0 set \nof very simple invariants. The formula pictured to the right is a linear arithmetic formula which relates \ncon.gurations of the con\u00adtrol .ow net with con.gurations of the counting proof (two con\u00ad.gurations are \nrelated if they satisfy the formula to the right; the control .ow net con.guration is used to interpret \np variables and the counting automaton con.guration is used to interpret k and the q variables; the value \nof q is 1 or 0). One may check that this re\u00adlation is a kind of simulation: whenever the control .ow \nnet may take a step, the counting automaton may take a corresponding step or the control .ow net is in \na dead con.guration that cannot reach a .nal marking. Moreover, the initial and .nal con.gurations of \nthe control .ow net and counting automaton are related. Thus, this for\u00admula shows that the traces of \nthe control .ow net are accepted by the counting automaton. 9. Related Work Extensive research has been \ndone about veri.cation of parameter\u00adized systems. Apt and Kozen [4] argued that with little capabili\u00ad \nties granted to individual processes, the veri.cation problem be\u00adcomes undecidable. There has since been \na great deal of study of decidability/undecidability of subclasses of parameterized systems [32, 38]. \nThere is a good survey [49] that covers a lot of the exist\u00ad ing techniques for veri.cation of parameterized \nsystems. We em\u00adphasize here that our goal is not to verify parameterized distributed protocols, but programs; \nand therefore, we do not mention a lot of related work that is focused on the intricacies of verifying \nthese protocols. Deductive techniques We are aware of two proof systems that are applicable to parameterized \nsystems: (1) a parameterized Owicki-Gries type proof system [40], in which if the assertions (and the \nauxiliary variables) are provided by the user as annotations, then the proof checking is done mostly \nautomatically, and (2) The QED [17] system that is based on the Lipton s reduction by inferring atomic \nblocks, which works independently of how many threads are running in parallel. Both of these systems \nneed (partial or total) user-provided annotations to prove programs correct. Induction-based techniques \nThere are techniques based on in\u00adduction (on the number of processes) [33, 36], that rely on .nding an \nabstraction and approximation of network invariants [13, 14, 31]. The method of invisible invariants \n[5, 44] automatically gener\u00ad ates inductive assertions for the veri.cation of safety properties of parameterized \nsystems. First, the symmetry of parameterized sys\u00adtems is exploited to guess a universally quanti.ed \nassertion that over-approximate the set of reachable states. then, a small model theorem establishes \nwhen the assertions over parameterized sys\u00adtems can be model checked on small instantiations (whose size \nde\u00adpend on the system and the assertions) to derive the validity over any instantiation. This method \nis limited, however, to systems with .nite data, and the application of it in some contexts is far from \ntrivial. Regular model checking The idea, which was introduced in [48], is to represent the set of reachable \nstates of a parameterized system using a regular language. Processes are assumed to be .nite-state to \ngive rise to a .nite alphabet (alphabet letters correspond to pro\u00adcesses states). Transducers are used \nto approximate (through ac\u00adceleration) the transitive closure of transition relation, and hence compute \nall reachable con.gurations of the systems. A lot of re\u00adsearch has been done in improving the laborious \nproblem of com\u00adputing the meta transitions [1, 11, 36, 43] (including techniques based on acceleration, \ntransitive closure, and widening), and even going beyond regular languages in [20]. The restriction that \npro\u00ad cesses need to be .nite state persists in all these extensions. The fo\u00adcus of this line of research \nhas been on the veri.cation of protocols, and hence, they often have much richer input languages (than \nthe one we use in this paper) that are beyond our scope of parameter\u00adized programs; e.g. the use of existentially \nor universally quanti.ed guards, which is not normally found in software systems. Abstraction-based techniques \nIn [27], a system of N processes communicating through .nite-domain shared variables is ab\u00adstracted by \nmapping the state systems into tuples where each dimension (having the values, 0, 1, or many) corresponds \nto the number of processes at a given local state, and additional dimen\u00adsions are used to capture the \nvalue of global variables (.nitely many possibilities). The resulting .nite-state system was then veri.ed \nby model checking (.nite-state veri.cation). In this and other counter abstraction techniques, a concrete \nstate is counter abstracted by counting the number of processes in each local state [37, 45] limiting \nthe counter to at most 2. Counter abstraction is simple to apply and when applicable works well. Its \nshortcoming is that it is only applicable to systems where each process has a small number of individual \nlocal states. More recently, in [28] symbolic techniques are used to overcome this problem and allow \nveri.ca\u00adtion processes with larger number of local states. A new form of counter abstraction is discussed \nin [28] using parametric interval abstraction that facilitates veri.cation of fault-tolerant distributed \nalgorithms. There is a class of techniques that are not strictly counter abstraction in the above sense \n(since the resulting abstract sys\u00adtem is not .nite), but have a similar .avour since they use the same \ncounters, but untruncated. In [22], German and Sistla con\u00ad sider a parameterized system of processes \nthat communicate syn\u00adchronously, and show how to verify single-index properties. They achieve this by \nencoding the problem as a Petri net safety property and using Karp-Miller s coverability tree construction \n[30]. Simi\u00ad lar abstraction-based techniques have been applied to veri.cation of multi-threaded C [6], \nand Java [16] programs. In all these in\u00ad stances, processes are abstracted into .nite-state processes, \nand the only source of in.nity remains the existence of unboundedly many of these .nite-state processes. \nIn [2], a CEGAR algorithm for parameterized systems is pre\u00ad sented. The program model in this paper is \nvery similar to ours (although the technique proposed in [2] is focused on proving safety for Petri net \nprograms where the data variables are inte\u00adgers). The reachability algorithm employed by [2] is a fairly \nstan\u00ad dard backward coverability algorithm -the insight of this paper is that the well quasi-order used \nfor this algorithm can be re.ned us\u00ading counter examples. The authors do not approach the problem of \nautomatically synthesizing auxiliary variables. In [8], it is shown how to represent a parameterized \nsystem of .nite-state processes in the decidable logic WS1S, i.e. the current state of the system is \nmodelled as a .xed number of .nite subsets of natural numbers and the transitions of processes are described \nin WS1S formulae. Later, in [9], they extend the method, using a com\u00ad bination of theorem proving and \nthe algorithmic techniques from [8], so that each process can have an unbounded state space. The theorem \nproving side helps prove a simulation relation between the original system and a so-called doubly-parametric \nsystem which is restricted enough to be expressible and checkable within the origi\u00adnal framework from \n[8]. The problem of proving data structure invariants for programs with unboundedly many threads is attacked \nin [10] and [47]. [10] aims to exploit thread-modularity in their proofs, which restricts the ways in \nwhich thread-local variables may be correlated (for the practical gain of a faster analysis). Additional \ncorrelations can be captured using the technique of [47], in which a universally quanti\u00ad .ed environment \nassertion is used to keep track of relationships be\u00adtween a distinguished thread and all other threads. \n[18] is another technique that, like [10, 47], loses variable correlations in the in\u00ad terests of speed. \nUnlike [10] and [47], [18] is designed to compute numerical invariants rather than data structure invariants. \nThe conditions that need to be satis.ed by the abstraction are restrictive enough that, as an example, \nthe ticket example discussed here cannot be handled by the method. The technique of trace abstraction \nhas previously been dis\u00adcussed in [25] and in [19]. There, the sets of traces of sequential programs \nrespectively concurrent (non-parameterized) programs were abstracted by regular languages. The issue \nof auxiliary vari\u00adable synthesis was not investigated in that work, although it is potentially interesting \nalso for sequential and concurrent (non\u00adparameterized) programs. Cut-off detection There is a strong \nbelief (backed by empirical evidence) that parameterized systems often enjoy a small model property. \nThis belief has given rise to a collection of techniques for veri.cation of parameterized concurrent \nsystems [3, 29, 34]. More precisely, analyzing a small number of processes (the so-called cut\u00adoff points) \nand their interactions is suf.cient to determine the reach\u00adability of any bad states. In [29, 34], parameterized \nBoolean pro\u00ad grams (more speci.cally the result of predicate abstraction of de\u00advice drivers) are analyzed. \nThe technique in [29] is complete with respect to Boolean programs (note that this does not carry over \nto the original in.nite-state C programs), while the one in [34] is even incomplete for Boolean programs. \nMore recently, in [3], commu\u00ad nication protocols are the focus, and an abstraction scheme is used that \nattempts to detect the cut-off points dynamically during the veri.cation procedure to stop the search. \nHere, also, the processes are assumed to be .nite state. 10. Conclusion In this paper, we introduced \ncounting proofs, a new system for proving safety properties for programs with in.nite control. We believe \nthat counting proofs have independent interest, outside of the software veri.cation algorithm presented \nhere. For example, we believe it may have applications to analysis of black-box systems, where the proof \nchecking problem cannot be done, but we may be able to make other guarantees (e.g., testing coverage). \nAnother po\u00adtential direction for future work is application is white-box veri.\u00adcation where the proof \nchecking problem is undecidable in general, but an incomplete semi-test can be used for proof checking. \nThis paper shows that a particular class of auxiliary variables counters can be synthesized automatically. \nA natural question is to ask what other classes of auxiliary variables admit synthesis procedures. Another \nquestion is whether basic ideas introduced in this paper can be applied to auxiliary variable synthesis \nin other proof systems, such as Owicki-Gries [41]. The problem of auxiliary variable synthesis is largely \nunexplored, and this paper takes a step in the direction. References [1] P. A. Abdulla, A. Bouajjani, \nB. Jonsson, and M. Nilsson. Handling global conditions in parameterized system veri.cation. In CAV, pages \n134 145, 1999. [2] P. A. Abdulla, Y.-F. Chen, G. Delzanno, F. Haziza, C.-D. Hong, and A. Rezine. Constrained \nmonotonic abstraction: a cegar for parameter\u00adized veri.cation. In CONCUR, pages 86 101, 2010. [3] P. \nA. Abdulla, F. Haziza, and L. Hol\u00b4ik. All for the price of few. In VMCAI, pages 476 495, 2013. [4] K. \nR. Apt and D. Kozen. Limits for automatic veri.cation of .nite\u00adstate concurrent systems. Inf. Process. \nLett., 22(6):307 309, 1986. [5] T. Arons, A. Pnueli, S. Ruah, J. Xu, and L. D. Zuck. Parameterized veri.cation \nwith automatically computed inductive assertions. In CAV, pages 221 234, 2001. [6] T. Ball, S. Chaki, \nand S. K. Rajamani. Parameterized veri.cation of multithreaded software libraries. In TACAS, pages 158 \n173, 2001. [7] S. Bardin, A. Finkel, J. Leroux, and L. Petrucci. Fast: acceleration from theory to practice. \nInt. J. Softw. Tools Technol. Transf., 10(5): 401 424, Sept. 2008. [8] K. Baukus, S. Bensalem, Y. Lakhnech, \nand K. Stahl. Abstracting WS1S systems to verify parameterized networks. In TACAS, pages 188 203, 2000. \n[9] K. Baukus, K. Stahl, S. Bensalem, and Y. Lakhnech. Networks of pro\u00adcesses with parameterized state \nspace. Electr. Notes Theor. Comput. Sci., 50(4):386 400, 2001. [10] J. Berdine, T. Lev-Ami, R. Manevich, \nG. Ramalingam, and M. Sagiv. Thread quanti.cation for concurrent shape analysis. In CAV, pages 399 413, \n2008. [11] A. Bouajjani, B. Jonsson, M. Nilsson, and T. Touili. Regular model checking. In CAV, pages \n403 418, 2000. [12] A. R. Bradley. Sat-based model checking without unrolling. In VMCAI, pages 70 87, \n2011. [13] E. M. Clarke, O. Grumberg, and M. C. Browne. Reasoning about networks with many identical \n.nite-state processes. In PODC, pages 240 248, 1986. [14] E. M. Clarke, O. Grumberg, and S. Jha. Veryfying \nparameterized networks using abstraction and regular languages. In CONCUR, pages 395 407, 1995. [15] \nM. A. Col \u00b4on, S. Sankaranarayanan, and H. B. Sipma. Linear invariant generation using non-linear constraint \nsolving. In Computer Aided Veri.cation, pages 420 432, 2003. [16] G. Delzanno, J.-F. Raskin, and L. V. \nBegin. Towards the automated veri.cation of multithreaded java programs. In TACAS, pages 173 187, 2002. \n[17] T. Elmas, S. Qadeer, and S. Tasiran. A calculus of atomic actions. In POPL, pages 2 15, 2009. [18] \nA. Farzan and Z. Kincaid. Veri.cation of parameterized concurrent programs by modular reasoning about \ndata and control. In POPL, pages 297 308, 2012. [19] A. Farzan, Z. Kincaid, and A. Podelski. Inductive \ndata .ow graphs. In POPL, pages 129 142, 2013. [20] D. Fisman and A. Pnueli. Beyond regular model checking. \nIn FSTTCS, pages 156 170, 2001. [21] P. Ganty, R. Majumdar, and B. Monmege. Bounded underapproxima\u00adtions. \nFormal Methods in System Design, 40(2):206 231, 2012. [22] S. M. German and A. P. Sistla. Reasoning about \nsystems with many processes. J. ACM, 39(3):675 735, 1992. [23] A. Gupta, C. Popeea, and A. Rybalchenko. \nPredicate abstraction and re.nement for verifying multi-threaded programs. In POPL, pages 331 344, 2011. \n[24] M. Hack. Decidability questions for Petri nets. PhD thesis, MIT, June 1976. [25] M. Heizmann, J. \nHoenicke, and A. Podelski. Re.nement of trace abstraction. In SAS, pages 69 85, 2009. [26] L. E. Holloway, \nB. H. Krogh, and A. Giua. A survey of petri net methods for controlled discrete eventsystems. Discrete \nEvent Dynamic Systems, 7(2):151 190, Apr. 1997. [27] C. N. Ip and D. L. Dill. Verifying systems with \nreplicated components in mur.. Formal Methods in System Design, 14(3):273 310, 1999. [28] A. John, I. \nKonnov, U. Schmid, H. Veith, and J. Widder. Parameterized model checking of fault-tolerant distributed \nalgorithms by abstraction. In FMCAD, pages 201 209, 2013. [29] A. Kaiser, D. Kroening, and T. Wahl. Dynamic \ncutoff detection in parameterized concurrent programs. In CAV, pages 645 659, 2010. [30] R. M. Karp and \nR. E. Miller. Parallel program schemata. J. Comput. Syst. Sci., 3(2):147 195, 1969. [31] Y. Kesten, A. \nPnueli, E. Shahar, and L. D. Zuck. Network invariants in action. In CONCUR, pages 101 115, 2002. [32] \nS. R. Kosaraju. Decidability of reachability in vector addition systems (preliminary version). In STOC, \npages 267 281, 1982. [33] R. P. Kurshan and K. L. McMillan. A structural induction theorem for processes. \nInf. Comput., 117(1):1 11, 1995. [34] S. La Torre, P. Madhusudan, and G. Parlato. Model-checking param\u00adeterized \nconcurrent programs using linear interfaces. In CAV, pages 629 644, 2010. [35] J. Leroux. Vector addition \nsystem reachability problem: a short self\u00adcontained proof. In POPL, pages 307 316, 2011. [36] D. Lesens, \nN. Halbwachs, and P. Raymond. Automatic veri.cation of parameterized linear networks of processes. In \nPOPL, pages 346 357, 1997. [37] B. D. Lubachevsky. An approach to automating the veri.cation of compact \nparallel coordination programs i. Acta Inf., 21:125 169, 1984. [38] M. Maidl. A unifying model checking \napproach for safety properties of parameterized systems. In CAV, pages 311 323, 2001. [39] K. L. McMillan. \nLazy abstraction with interpolants. In CAV, pages 123 136, 2006. [40] L. P. Nieto. Completeness of the \nOwicki-Gries system for parameter\u00adized parallel programs. In IPDPS, page 150, 2001. [41] S. Owicki and \nD. Gries. Verifying properties of parallel programs: an axiomatic approach. Commun. ACM, 19:279 285, \nMay 1976. ISSN 0001-0782. [42] E. Pelz. Closure properties of deterministic petri nets. In STACS, pages \n371 382, 1987. [43] A. Pnueli and E. Shahar. Liveness and acceleration in parameterized veri.cation. \nIn CAV, pages 328 343, 2000. [44] A. Pnueli, S. Ruah, and L. D. Zuck. Automatic deductive veri.cation \nwith invisible invariants. In TACAS, pages 82 97, 2001. [45] A. Pnueli, J. Xu, and L. D. Zuck. Liveness \nwith (0, 1, 8)-counter abstraction. In CAV, pages 107 122, 2002. [46] S. Qadeer and D. Wu. Kiss: keep \nit simple and sequential. In PLDI, pages 14 24, 2004. [47] M. Segalov, T. Lev-Ami, R. Manevich, R. Ganesan, \nand M. Sagiv. Abstract transformers for thread correlation analysis. In APLAS, pages 30 46, 2009. [48] \nP. Wolper and B. Boigelot. Verifying systems with in.nite but regular state spaces. In CAV, pages 88 \n97, 1998. [49] L. Zuck and A. Pnueli. Model checking and abstraction to the aid of parameterized systems \n(a survey). Comput. Lang. Syst. Struct., 30 (3-4):139 169, Oct. 2004.   \n\t\t\t", "proc_id": "2535838", "abstract": "<p>Counting arguments are among the most basic proof methods in mathematics. Within the field of formal verification, they are useful for reasoning about programs with <i>infinite control</i>, such as programs with an unbounded number of threads, or (concurrent) programs with recursive procedures. While counting arguments are common in informal, hand-written proofs of such programs, there are no fully <i>automated</i> techniques to construct counting arguments. The key questions involved in automating counting arguments are: <i>how to decide what should be counted?</i>, and <i>how to decide when a counting argument is valid?</i> In this paper, we present a technique for automatically constructing and checking counting arguments, which includes novel solutions to these questions.</p>", "authors": [{"name": "Azadeh Farzan", "author_profile_id": "81350568899", "affiliation": "University of Toronto, Toronto, ON, Canada", "person_id": "P4383776", "email_address": "azadeh@cs.toronto.edu", "orcid_id": ""}, {"name": "Zachary Kincaid", "author_profile_id": "81472649374", "affiliation": "University of Toronto, Toronto, ON, Canada", "person_id": "P4383777", "email_address": "zkincaid@cs.toronto.edu", "orcid_id": ""}, {"name": "Andreas Podelski", "author_profile_id": "81100130920", "affiliation": "University of Freiburg, Freiburg, Germany", "person_id": "P4383778", "email_address": "podelski@informatik.uni-freiburg.de", "orcid_id": ""}], "doi_number": "10.1145/2535838.2535885", "year": "2014", "article_id": "2535885", "conference": "POPL", "title": "Proofs that count", "url": "http://dl.acm.org/citation.cfm?id=2535885"}