{"article_publication_date": "01-08-2014", "fulltext": "\n Probabilistic Relational Veri.cation for Cryptographic Implementations Gilles Barthe1 C\u00b4edric Fournet2 \nBenjamin Gr\u00b4egoire3 Pierre-Yves Strub1 Nikhil Swamy2 Santiago Zanella-B\u00b4eguelin2 IMDEA Software Institute1 \nMicrosoft Research2 INRIA3 {gilles.barthe,pierreyves.strub}@imdea.org, {fournet,nswamy,santiago}@microsoft.com, \nbenjamin.gregoire@sophia.inria.fr Abstract Relational program logics have been used for mechanizing for\u00admal \nproofs of various cryptographic constructions. With an eye to\u00adwards scaling these successes towards end-to-end \nsecurity proofs for implementations of distributed systems, we present RF*, a rela\u00adtional extension of \nF*, a general-purpose higher-order stateful pro\u00adgramming language with a veri.cation system based on \nre.nement types. The distinguishing feature of RF* is a relational Hoare logic for a higher-order, stateful, \nprobabilistic language. Through care\u00adful language design, we adapt the F* typechecker to generate both \nclassic and relational veri.cation conditions, and to automatically discharge their proofs using an SMT \nsolver. Thus, we are able to bene.t from the existing features of F*, including its abstraction facilities \nfor modular reasoning about program fragments. We eval\u00aduate RF* experimentally by programming a series \nof cryptographic constructions and protocols, and by verifying their security proper\u00adties, ranging from \ninformation .ow to unlinkability, integrity, and privacy. Moreover, we validate the design of RF* by \nformalizing in Coq a core probabilistic .-calculus and a relational re.nement type system and proving \nthe soundness of the latter against a deno\u00adtational semantics of the probabilistic .-calculus. Categories \nand Subject Descriptors D.3.1 [Programming Lan\u00adguages]: Formal De.nitions and Theory Semantics; D.2.4 \n[Soft\u00adware Engineering]: Software/Program Veri.cation. Keywords program logics; probabilistic programming \n1. Introduction Many fundamental notions of security go beyond what is express\u00adible as a property of \na single execution of a program. For example, non-interference [25 2525], the property underlying information-.ow \nse\u00adcurity, relates the observable behaviors of two program executions. Recognizing the importance to \ncomputer security of such hyper- This work has been partially supported by the Amarout European Program. \n Permission to make digital or hard copies of all or part of this work for personal or classroom use \nis granted without fee provided that copies are not made or distributed for pro.t or commercial advantage \nand that copies bear this notice and the full citation on the .rst page. Copyrights for components of \nthis work owned by others than the author(s) must be honored. Abstracting with credit is permitted. To \ncopy otherwise, or republish, to post on servers or to redistribute to lists, requires prior speci.c \npermission and/or a fee. Request permissions from permissions@acm.org. POPL 14, January 22 24, 2014, \nSan Diego, CA, USA. Copyright is held by the owner/author(s). Publication rights licensed to ACM. ACM \n978-1-4503-2544-8/14/01. . . $15.00. http://dx.doi.org/10.1145/2535838.2535847  properties [20 2020], \nresearchers have developed a range of program analyses and veri.cation tools for proving relations between \ntwo or more programs, or two or more executions of the same pro\u00adgram. For instance, Benton s relational \nHoare logic [11 1111] general\u00adizes Hoare logic to reason about properties of two programs. In addition, \nsecurity properties must often account for proba\u00adbilistic behaviors. For instance, in cryptography, simulation-and \nindistinguishability-based notions of security are speci.ed in terms of the probability that an adversary \nwins in some probabilistic ex\u00adperiment. Starting from Kozen s seminal work [30 3030], many logics for \nreasoning about probabilistic programs have been developed. Recently, these two lines of work have been \ncombined into a relational program logic called pRHL for reasoning about prob\u00adabilistic imperative programs \n[7 77]. This logic can justify common patterns of probabilistic reasoning about hyperproperties used \nin cryptographic proofs, including observational equivalence, equiv\u00adalence up to failure and reductionist \narguments. pRHL forms the backbone of EasyCrypt [8 88], a tool-assisted framework which has been used \nfor verifying the security of encryption and signature schemes, modes of operation for block-ciphers, \nand hash function designs in the computational model. These advances, among oth\u00aders, raise the prospect \nof a new class of veri.ably secure systems: those that are proven secure based on standard computational \nas\u00adsumptions (such as the existence of one-way functions) and whose veri.cation encompasses all aspects \nof the system implementation. RF*: end-to-end security of cryptographic implementations In an effort \nto scale logics like pRHL towards end-to-end security proofs of system implementations, this article \npresents a new lan\u00adguage called RF*, building on F* [45 4545], a dependently typed di\u00adalect of ML. F*, \nand its predecessor F7 [12 1212], make use of re.ne\u00adment types to verify implementations scaling to tens \nof thousands of lines of code, including the Transport Layer Security Internet standard (TLS) [13 1313], \nmulti-party sessions, web-browser extensions, zero-knowledge protocols, and the F* typechecker itself. \nRF* integrates within F* an expressive system of relational re.nements to support .ne-grained reasoning \nabout probabilistic computations. Through careful language design, we are able to use the relational \nfeatures of RF* in smooth conjunction with the exist\u00ading features of F*, allowing the large corpus of \nalready-veri.ed F* code to be reasoned about effectively when used in a relational con\u00adtext. As such, \nour work opens the door to semi-automated security veri.cation through relational re.nement types, instead \nof a some\u00adwhat in.exible combination of parametricity and type safety (as in F7), or through detailed \ntactic-based interactive proofs (as in Easy-Crypt), as a basis for certifying the security of critical \npieces of Internet infrastructure, such as a reference implementation of TLS. Technically, this paper \nmakes three broad contributions:  1. A relational logic for higher-order stateful probabilistic pro\u00adgrams: \nwe formalize in the Coq proof assistant .p, a lambda calculus with references, random sampling, and unbounded \nre\u00adcursion. We develop a relational re.nement type system for .p and prove it sound with respect to a \ndenotational interpretation of judgments as relations over pairs of store-passing probabilis\u00adtic functions. \nTo our best knowledge, .p is the .rst relational logic for higher-order stateful probabilistic programs. \n(\u00a73 33) 2. The design and implementation of RF* : .p forms the basis of the design of RF* , an extension \nof F* . We show how to encode relational re.nement types within a new relational state monad, RDST. We \nprovide a type inference algorithm for RDST, in the form of a weakest pre-condition calculus that computes \nrela\u00adtional veri.cation conditions. Proofs of these veri.cation con\u00additions can be discharged automatically \nby the RF* typechecker and the Z3 [21 2121] SMT solver. (\u00a74 44) 3. An experimental evaluation of RF* \n: we demonstrate the expres\u00adsiveness of RF* through a representative set of examples, start\u00ading from \nsimple (non-probabilistic) information .ow, and grad\u00adually moving towards more advanced cryptographic \nmodels and systems. To date, we have used RF* to automatically verify a to\u00adtal of around 1,400 lines \nof code for a variety of relational prop\u00aderties, ranging from termination-insensitive non-interference \nto various indistinguishability-based properties for encryption, be\u00adsides others. Several examples make \nessential use of higher\u00adorder and stateful features of RF* , emphasizing the utility of the .p logic \nfor practical security veri.cation. (\u00a72 22 and \u00a75 55)  The .p theory formalized in Coq, the RF* compiler, \nand all the example programs mentioned in this paper are available online from http://resear http://researhttp://research.microsoft.com/fstar \nch.microsoft.com/fstarch.microsoft.com/fstar. 2. Programming with relational re.nements We start by describing \nRF* informally through a series of examples, beginning with a brief introduction to F* itself, and then \nfocusing on the main new feature in RF* , i.e., relational re.nement types. 2.1 From classic to relational \nre.nements. F* is a call-by-value higher-order programming language with primitive state and ex\u00adceptions, \nsimilar to ML, but with a more expressive type system based on dependent re.nement types. Re.nement types \nare written x:t{f} where f is a logical formula. For instance, the code frag\u00adment below de.nes a re.ned \ntype for non-negative integers, then for integers modulo some number p: type nat = n:int { 0 = n } type \nmod p = n:nat { n < p } let p = 97 let n : mod p = 73 Typechecking F* programs involves logical proof \nobligations, which are delegated to the Z3 SMT solver. For instance, to check that n has type mod p, \nthe F* typechecker emits the proof obliga\u00adtion p = 97 =. 0 = 73 < p, which is easily discharged by Z3. \nType safety means that, whenever an expression e with type x:t{f} re\u00adduces to a value v, this value v \nsatis.es the formula f[x := v]. The type system provides structural subtyping. For instance, nat is a \nsubtype of int, and mod p is a subtype of mod q when p = q. These subtyping relations are automatically \nproved and applied by F* . Re.nements can be combined with dependent function types, written x:t . t \n, where the formal parameter x:t is in scope in the result type t . We also use dependent pairs, written \nx:t * t , where the variable x of the .rst component is in scope in the type t of the second component. \nFor instance, we may write and typecheck addition modulo as follows (where the re.nement braces bind \ntighter than the arrow): val add: p:nat . x:mod p . y:mod p . z:mod p { z = (x + y) % p }let add p x \ny = let s = x + y in if s < p then s else s - p F* also provides primitive support for programming with \nstate. For example, one may write let incr i = i := !i + 1. By combining re\u00ad.nements with references, \none can express invariants on the pro\u00adgram state, e.g., ref nat is the type of mutable locations that \ncontain non-negative integers. To describe more precise properties of ef\u00adfectful programs, F* provides \nmore advanced mechanisms, includ\u00ading a monadic mode [46 4646], where one can reason about programs using \nvariants of the Hoare state monad of Nanevski et al. [34 3434] together with McCarthy s select/update \ntheory for modeling the heap [32 3232]. For example, one can give incr a speci.cation of the form i:ref \nnat . ST (.h.True) unit (. h () h .h =Upd h i (1 + Sel h i)), where ST pre t post can be understood as \nthe state-passing func\u00adtion type h:heap{pre h} . (x:t * h :heap{post h x h }) although, in reality, F* \nprovides primitive support for state. That is, the type of incr states a trivial pre-condition on the \ninput heap h, and a post-condition indicating that the .nal heap h differs from h at the location i, \nwhich is incremented. F* provides type inference in the form of a higher-order weakest pre-condition \ncalculus to help ease the burden of writing such precise speci.cations [46 4646]. RF* extends F* with \nrelational re.nements: a type can (also) be decorated with a relational formula, placed within double \nbraces {|. . . |}, that speci.es a joint property on pairs of values. Relational formulas can independently \nrefer to the left and right values of ev\u00adery program variable in scope, using the projections L and R, \nre\u00adspectively; projections extend naturally to arbitrary formulas. Intu\u00aditively, for deterministic programs, \ntype safety means that, when\u00adever we obtain two results vL and vR by evaluating an expression e: x:t{|f|} \nin two contexts that provide well-typed substitutions for e s free variables, then the formula f[L x \n:= vL][R x := vR] is valid. More generally, instead of considering two executions of the same program \ne, RF* allows proving relations between the results of two programs, i.e., we relate e0 and e1 at a (relationally \nre.ned) type using e0 ~ e1 : t. We write e : t as a shorthand for e ~ e : t. We start with a few simple \nexamples. Take the expression e to be z - z; we can give e the type x:int{|L x = R x|}, mean\u00ading that \nfor any pair of substitutions sL and sR, evaluating sLe yields the same result as evaluating sRe. Similarly, \nwe have x + x ~ 2*x : z:int {| L x = R x =. L z = R z |}, stating a simple equivalence between two integer \nexpressions evaluated with the same value for x. Relational re.nements can also be used to describe proper\u00adties \nbeyond equivalence. For example, we can express the type of monotonic integer functions as x:int . y:int \n{| L x = R x =. L y = R y |} and the type of k-sensitive integer functions, for some metric dist, as \nx:int . y:int {| dist (L y) (R y) = k * dist (L x) (R x) |}. RF* can automatically check (by subtyping) \nthat a function such as fun x . k * x is both monotonic and k-sensitive for any k = 0. Relational re.nements \nare strictly more expressive than plain re.nements: one can encode any plain re.nement { f } as the re\u00adlational \nre.nement {| L f . R f |} that independently speci.es left and right properties. For instance, the type \nnat above is automat\u00adically desugared to n:int {| 0 = L n . 0 = R n |}. Pragmatically, this enables us \nto mix property re.nements and relational re.nements in our concrete syntax, and to import any re.nement-typed \nF* li\u00adbrary in relational mode by applying the encoding. When authoring programs with speci.c relational \nproperties in mind, one need is\u00adsue only a single compiler directive (aka a pragma) to switch the veri.er \nto relational mode. We contend that the resulting language, RF* , brings relational program veri.cation \nout of the domain of tools applied to small fragments of pseudocode with interactive proofs, to a practical \nprogramming language suitable for small-to medium-scale systems implementations. 2.2 Information .ow. \nRelational re.nements can be systemati\u00adcally used to give a semantic characterization of termination-insen\u00adsitive \nnon-interference [41 4141]. Whereas standard type-based informa\u00adtion .ow controls resort to security \nlabels and ad hoc syntactic mechanisms to conservatively determine when the observable out\u00adputs of a \nprogram may depend on its secret inputs, RF* can directly verify the corresponding equivalences, as illustrated \nbelow. Recall that non-interference means that public results do not depend on secrets. If an expression \ne with base type a that computes over some secret information can be given the type type eq a = x:a{|L \nx = R x|}, then its result can be safely published, since the execution of e reveals no information about \nthe secrets. Capturing the intuition from labelled information .ow type systems with high and low con.dentiality \nlevels, we use the type eq a (the type of values that are equal on both sides ) for low-con.dentiality \nvalues, also written low a. In contrast, we use the type a (the type of unrelated left and right values) \nfor high\u00adcon.dentiality values, writing hi a as an alias for a. As usual, low a is a subtype of hi a, \nmeaning that public values can be treated as secret, but not the converse. Using these type abbreviations, \nwe can write programs such as fun (x,y) . (x + y, y + 1) and give them information .ow types such as \nhi int * low int . hi int * low int. More interestingly, we can supplement these types with relational \nre.nements that capture more .exible information-.ow policies. For example, a plausible con.dentiality \npolicy for credit card numbers conceals all but their last four digits, as speci.ed and implemented below. \nval last4: n:hi int. s:string{|(L n%10000 = R n%10000)=. L s = R s|}let last4 n = \"********\" int2string \n(n % 10000) Tracking leaks via control dependencies (aka implicit .ows) is a characteristic feature of \ninformation .ow type systems. To il\u00adlustrate how RF* reasons about implicit .ows, consider the pro\u00ad ' \ngram fun b . if b then e else e. Assuming that b is secret, .ow\u00adinsensitive type systems would conservatively \ngive this program the type hi bool . hi a. To give this program the more precise type hi bool . low a, \nwe need to analyze four cases that arise from ap\u00adplying this function twice to arbitrary boolean arguments \nL b and R b, and prove that the results in all cases are the same. The four typechecking goals are e:low \na, assuming L b = R b = true;  e':low a, assuming L b = R b = false;  e ~ e':low a, assuming L b = \ntrue and R b = false; and  e' ~ e:low a, assuming L b = false and R b = true.  Anticipating on the \nnext section, our proof rules for relating two values v0 and v1 are relatively simple. Proving v0 ~ v1 \n: x:t{| f |}involves .rst proving v0 ~ v1 : t (which for base types involves simply showing that both \nv0 and v1 have type t), and then proving f[L x, R x := v0, v1]. So, RF* can easily prove, for instance, \n(fun b . if b then 0 else 0) : hi bool . low int and (fun x . if x=0 then x else 0) : hi int . low int \neven though, syntactically, those functions branch on con.dential values. For expressions, particularly \nthose that have side effects, the problem is more complex. Our strategy is to adapt the Hoare monad ST \npre t post provided by F* to a relational version called RST, where RST pre t post can be seen as the \ntype shown below: h:heap{| pre (L h) (R h) |} . (x:t * h :heap{| post (L h) (R h) (L x) (R x) (L h ) \n(R h )|}) This is the type of pairs of functions that, when run in a pair of input heaps L h and R h \nsatisfying the 2-place relational pre-condition predicate pre, may diverge, but if they both converge, \nyield results L x and R x and output heaps L h and R h that satisfy the 6-place relational post-condition \npredicate post. Using the RST monad and its associated weakest pre-condition calculus, we can type the \nfollowing program, which branches on a con.dential value and then performs matching public side-effects: \nval f: x:ref int . b:bool . RST (. . True) unit post where post h0 h1 h0 h1 = L x=R x . h0=h1=. h0 =h1 \nlet f x b = if b then x := 1 else x := 1 RF* infers a weakest pre-condition predicate transformer for \nthis program, then checks that it is consistent with any programmer supplied annotation (the annotation \nis optional for loop-free pro\u00adgrams). In our example, the pre-condition of f states that it can be run \nin any pair of heaps, while its post-condition ensures that, if f is applied twice to the same references \nin the same heaps, then regardless of its boolean argument, the resulting heaps are also the same, i.e., \nthe type reveals that f does not leak information despite having side-effects guarded by a secret boolean. \nMore complex programs, for example those that may leak infor\u00admation via side-effects based on aliasing, \ncan be veri.ed similarly: val g: x:ref int . y:ref int . b:bool . RST (. . True) unit post where post \nh0 h1 h0 h1 = L x =R y =L y . R x =. Sel h0 (L y)=Sel h1 (R y) let g x y b = if b then x := 1; y := 1 \nelse y := 1; x := 0 The type of g states that, if x and y are not aliased, then the .nal contents of \nthe reference y are the same. Thus, the expressiveness of RF* , combined with its ability to use Z3 to \ndischarge proof obligations, enables automated reasoning in the style of a relational Hoare logic for \nproving non-interference properties of higher-order stateful programs. 2.3 Sampling, chosen-plaintext \nsecurity, and one-time pads. We introduce probabilistic relational reasoning in RF* using sym\u00admetric \nencryption schemes. Our goal is to communicate encrypted messages between a sender and a receiver without \nleaking any in\u00adformation about their content. (From an information .ow view\u00adpoint, ciphertexts are public, \nwhereas plaintexts are secret.) For simplicity, we assume that messages range over byte arrays with a \n.xed size n (called blocks) and we do not consider active attack\u00aders. Padding and authentication against \nchosen-ciphertext attacks can be easily added, but would complicate our presentation (see \u00a75 55 for a \ndescription of our model for chosen-ciphertext security). We assume that the sender and the receiver \nshare a secret key k (also a block), sampled uniformly at random by calling the prim\u00aditive function sample. \nWe model this assumption by writing a sin\u00adgle program where both parties are within the scope of this \nkey. The simplest secure encryption scheme is the one-time pad, imple\u00admented, for instance, using bitwise \nXOR: to encrypt the message p, compute c = k . p; to decrypt c, compute p = k . c. type block = b:bytes \n{ Length b = n }let encrypt k p = xor k p let decrypt k c = xor k c Next, we explain how to specify and \nprove that an encryption scheme is secure. In cryptography, con.dentiality is usually stated as resistance \nagainst chosen-plaintext attacks (CPA) and encoded as a decisional game in which an adversary chooses \ntwo plaintexts, receives the encryption of one of them under a fresh key, and must guess which of the \ntwo plaintexts was encrypted. (Decryption plays no role in this simple game; still, we may typecheck \nthat it undoes encryption using classical re.nements and properties of XOR.) This game may be coded in \nRF* as follows: let cpa b p0 p1 = let p = if b then p0 else p1 in encrypt (sample n) p where b is private \nand p0, p1, and the result are public. We thus express (perfect) CPA security relationally with the following \ntype: val cpa: b:bool . eq block . eq block . eq block stating that the encryption of one of the two \nchosen-plaintext blocks p0 or p1 depending on b does not leak any information about b, hence does not \nhelp the adversary to win the game. In fact, viewing CPA security from an information .ow perspec\u00adtive, \na simpler formulation is possible. Instead of reasoning about two messages selected by b, we just need \nto show that the function let cpa p = encrypt (sample n) p has the type block . eq block. This is the \nbest type we can hope for encryption, treating the plaintext as private and the ciphertext as public. \nThis more compact typing property subsumes the .rst one. To prove secrecy for the one-time pad, some \nprobabilistic rea\u00adsoning is called for. Indeed, operationally, calling sample n twice does not usually \nreturn the same value. However, relying on our formal semantics, we show that it is permissible to give \nsample n a more speci.c relational type that allows us to complete the proof. In particular, as explained \nbelow, we can type the call to sample n in a way that depends on the plaintext p and give it the type \nm:block {| xor (L p) (L m) = xor (R p) (R m) |} From this type, RF* automatically proves cpa : block \n. eq block. Intuitively, this relational re.nement is sound inasmuch as the dis\u00adtribution of the resulting \nciphertext is independent of the plaintext. In programs that contain sample, the interpretation of assertions \nin the RST monad becomes probabilistic. We formalize this in \u00a73 33, but provide some intuition for their \nmeaning here. If we can give the type RST (. . True) t Q to e0 ~ e1, then our logic guarantees that if \nQ is an equivalence relation partitioning t in a set of equivalence classes S, and if running e0 in a \nheap h0 reduces to v0 and e1 in h1 reduces to v1, then for any S . S, the probability that v0 . S is \nequal to the probability that v1 . S. Similar conclusions can be drawn in general. For example, if Q \nh0 h1 x0 x1 h0 h1 implies P0 x0 =. P1 x1, then the validity of the above assertion implies that Pr[P0 \nv0] = Pr[P1 v1]. From this interpretation, one should be able to see that the re\u00adlational re.nement on \nthe result of sample in RF* is not speci.c to XOR. More generally, sample can be given a speci.cation \nto state that any two calls to it return a pair of values related by any given one-to-one function on \nits range. Intuitively, relational re.nements in RF* capture relations between the distribution over \nvalues gener\u00adated by probabilistic programs, rather than between values obtained in speci.c executions. \nThe relational typing of sample is valid since applying a one-to-one function to a value uniformly chosen \nfrom a discrete set does not change its distribution. To re.ect these general properties of uniform sampling, \nour library provides a polymorphic, typed variant of sample, that takes as additional ghost parameter \nF, a binary predicate on sampled values of type block, whose re.nement states that it must be an injective \nfunction (or, equivalently, a bijection). This parameter has kind block . block . E, where E is the kind \nof ghost re.nements in F* (types in E are erased at runtime). In the RF* standard library, sample is \ntyped as follows type Function F = .a.. b.F a b . .a b1 b2.F a b1 . F a b2 =. b1=b2 type Injective F \n= Function F . .a1 a2 b. F a1 b . F a2 b =. a1=a2 val sample: .F. len:nat{Injective F} . b:block len{| \nF (L b) (R b) |} In our one-time pad example, when calling sample n in cpa , we instantiate F to . b0 \nb1. xor (L p) b0 = xor (R p) b1, which is indeed injective. In \u00a75 55, we describe security proofs of \nmore realistic en\u00adcryption schemes based on variants of the above typing for sample. 2.4 Implicit .ows \nand passport linkability. Before justifying our typing rules, notably for sample, we present a concrete \npro\u00adtocol for RFID-equipped passports, implemented in RF* , and we discuss a linkability attack against \nthis protocol recently uncovered Passport Tag (physically sharing k) Reader sample nt decrypt verify \nMAC verify nt sample kt {nt I nr I kr}k {nr I nt I kt}k sample nr, kr decrypt verify MAC verify nr s \n= kt . kr exchange data s = kt . kr  Figure 1. Basic Access Control protocol for passports by Chothia \nand Smirnov [19 1919]. We refer to their work for a detailed discussion. This attack is representative \nof common weaknesses in cryptographic implementations due to implicit .ows in the han\u00addling of errors \nwhile processing decrypted data. Following the ICAO speci.cation for machine-readable travel documents, \nall recent European passports embed RFID tags featur\u00ading the Basic Access Control protocol, outlined \nin Fig. 1 11. The pro\u00adtocol has two roles, a passport tag and a reader, exchanging mes\u00adsages using short-distance \nwireless communications. The goal of the protocol is to establish a shared session key for accessing \nbio\u00admetric data on the passport. Each passport tag has a unique key k; the reader derives this key from \ninformation obtained by scanning the passport. (In reality, there is a negligible chance of two pass\u00adports \nhaving the same key, because the key is derived from a hash of this information.) The passport .rst samples \na 64-bit nonce nt and sends it as a challenge to the reader. The reader samples its own nonce nr and \nsome keying materials kr, then encrypts the concatenation of these three values using k. Concretely, \nthe protocol implements authen\u00adticated encryption as triple-DES encryption concatenated with a plaintext \nMessage Authentication Code (MAC). The passport de\u00adcrypts, recomputes and checks the MAC to ensure that \nthe message has not been tampered with, then compares the received nonce nt with the challenge, to con.rm \nthat the reader responded correctly. If both checks succeed, it generates its own keying materials kt, \nappends them to the concatenation of the two nonces (in a different order than before), and computes \nthe session key s = kt . kr. The reader then similarly decrypts the received ciphertext, checks the MAC, \nand computes s. The code the tag uses for handling the encrypted message of the reader is shown below; \nencrypt and decrypt provide authenticated encryption; concat and split convert between triples of 64-bit \nvalues and their concatenation. let tag1 k nt c = match decrypt k c with | Some p . let (nt ,nr,kr) = \nsplit p in if nt = nt then encrypt k (concat nr nt (sample kt())) else nonceError | None . decryptError \n The code either produces an encrypted message, or it returns an error code. As written, it enables the \nfollowing linkability attack: 1. The attacker eavesdrops any run of the protocol between a target passport \nand an honest reader, and records their second message. 2. Later, to test the local presence of this \npassport, the attacker runs the protocol (as the reader), replays the recorded message, and observes \nthe response: although the protocol always fails to establish a key, the tag returns a nonceError if \nthe two passports are the same, and a decryptError otherwise.  Experimentally, French passports reliably \nreturn different error messages, whereas other European passports return the same er\u00adror message, but \nwith measurably different timings. Although our approach does not directly catch timing attacks, those \nattacks can be conservatively analyzed by treating error codes produced at dif\u00adferent code locations \nas distinct. We interpret the above attack as an implicit .ow of information from the key used to decrypt \nto the error message. Indeed, if we type the key k as high con.dentiality and the nonce nt and the cipher \nc with eq re.nements (since they are exchanged on a public network), relational typechecking fails on \nthe body of tag1. The result of the decryption is (a priori) not the same on both sides, so the cross-cases \ninvolve proving, for instance that when decryption returns Some p on the left and None on the right, \nthe two resulting expressions are equal, which fails on the proof obligation nonceError = decryptError. \nBy ensuring that the same error messages are returned in both cases (i.e., by requiring that nonceError \n= decryptError) this case is prevented, but this alone is not suf.cient for verifying the code. Na\u00a8ively, \nthe cross-cases that arise when verifying the nested condi\u00adtionals require proving, under a suitable \nrelational path condition, that the encryption on the third line is indistinguishable from the er\u00adror \nmessages which is patently false. However, by re.ecting sev\u00aderal cryptographic assumptions into detailed \ntyping invariants in the protocol implementation, we can prove that such problematic cross-cases never \nactually arise (i.e., the path conditions guarding these cases are infeasible) and we can verify that \nthis code pre\u00adserves unlinkability. Speci.cally, we assume that the encryption is CPA, key-hiding, and \nCTXT (all speci.ed by typing) and that there are no nonce collisions (the probability of a collision \nis less than q 22-64 where q is the number of sessions observed by the adver\u00adsary). Arapinis et al. [5 \n55] also analyze the corrected protocol, using the applied p-calculus, essentially proving unlinkability \nin a more abstract, symbolic model of cryptography. Please refer to our online materials for a full listing \nand further discussion of the speci.cation and implementation of tag1. 3. Formal development We formalize \na core of RF* in the Coq proof assistant by devel\u00adoping .p, a minimal higher-order language with (statically \nallo\u00adcated) references, probabilistic assignments, and unbounded recur\u00adsion. The formalization is based \non the SSREFLECT extension [26 2626], and on the ALEA library for distributions [6 66]. Overall, the \nformal\u00adization comprises over 2,500 lines of code excluding the aforemen\u00adtioned libraries. The formalization \nis built in two steps. First, we consider a sim\u00adply typed system G fe e : T for .p. Simple types T are \nextended to relational re.nement types C where one can add relational pre\u00adand post-conditions to function \ntypes. This allows us to de.ne a relational type system G f e0 ~ e1 : C that relates a pair of ex\u00adpressions \ne0 and e1 in the type C under the relational context G. We then give a denotational semantics for well-typed \njudg\u00adments. Simple types are given a cpo interpretation [T] in the stan\u00addard way. Judgments G fe e : \nT are interpreted as the elements of the form .e.I , where I is any valuation for the context G. Taking \ninto account that .p is a language with references and probabilis\u00adtic assignments, the denotation .e.I \nof e is de.ned as a function from memories (equivalently, states or heaps) to distributions over pairs \ncomposed of a memory and an element of [T]; we denote by M([T]) this function space. Relational types \nC are interpreted as a binary relation .|C|I over M([T]), where T is the simple type de\u00adrived from C \nby erasing all re.nements. This allows us to interpret (Theorem 1 11) a valid judgment G f e0 ~ e1 : \nC by all the pairs of the form (.e.IL , .e.IR ) . .|C|I for any pair of valuations (IL, IR) for the erasure \nG of G. ' x : T . G t . {L, R} x : T . G G | G ' f xt : T G | G ' f x : T r : ref B t . {L, R} G | G \n' f vi : T G | G ' f rt : B G | G ' f v1 = v2  G | G ' , y : B f f G | G ' f .y : B. f Figure 2. Well-formed \nrelational formulas (excerpt) 3.1 .p: syntax. .p is a simply typed .-calculus with references and probabilistic \nassignments. For simplicity, we only consider two forms of probabilistic assignments: assigning a uniformly \nsampled boolean to a boolean variable (.ip), and assigning an integer value sampled uniformly in a non-empty \ninterval [i, j] to an integer vari\u00adable (pickj i ). Formally, the sets of types, contexts, values and \nex\u00adpressions are given by the following grammars: type T ::= B | T . T ctxt. G ::= [] | G, [x : T] value \nv, u ::= c | x | o(v1, . . . , vn) | fun x : T . e j expr. e ::= v | e v | !r | r := v | .ip | pick| \nlet x = e1 in e2 i | letrec f x = e1 in e2 | if v then e1 else e2 where x ranges over a set var of variables, \nr ranges over a set ref of references and o ranges over a set O of B-sorted operators, whose signature \nis of the form B1 \u00d7 \u00b7 \u00b7 \u00b7 \u00d7 Bn . B0. We assume that B contains the unit type (unit) along with the types \nof Booleans (bool) and integers (int). Their associated constructors are , true, false and n for n . \nN. We implicitly assume that each reference has an ambient base type, and write r : ref B to denote that \nr is a reference with base type B. The dynamic semantics is de.ned in the standard way as the compatible \nclosure (for a call-by-value convention) of the \u00df.\u00b5d-contraction. 3.2 .p: typing. As usual, a typing \ncontext is a sequence of bind\u00adings x : T such that the bound variables are pairwise distinct. The typing \nrules for deriving valid judgments G fv v : T and G fe e : T, in a simply typed setting, are standard \nand omitted. RELATIONAL REFINEMENT TYPES. Relational assertions are for\u00admulas over tagged variables xL \nor xR and tagged references rL or rR; informally, tags determine whether the interpretation of x or r \nwill be taken w.r.t. the left or right projection of a relational valuation. In order to interface with \nautomated .rst-order provers, relational assertions are .rst-order B-sorted formulas built from operators \nin O and predicates taken from a set of B-sorted predi\u00adcates that includes at least the equality predicates \nfor all the base types. Note that tagged variables always occur free in assertions, and only logical \nvariables can be bound. For instance, the relational assertion .y : int. xL = y . xR = y + rR is well-formed \nunder any context G such that x : int . G, assuming that r : ref int. Formally, relational assertions \nare de.ned using a .rst-order type system with judgments of the form G | G ' f F for formulas (resp. \nG | f v : T for values) where G (resp. G ') is a G ' context for relational variables (resp. for non-relational \nvariables introduced by quanti.ers). Figure 2 22 shows the typing rules for variables, references, equality, \nand universal quanti.cation. We say that an assertion F is well-formed in context G iff G | \u00d8 f F (written \nG f F). Re.nement types are either relational types (denoted by T , U, V), which will be used for relational \ntyping of values, or computation types (denoted by C), used for relational typing of expressions. They \nare de.ned by the following grammar: T , U, V := B | (x : T ) . C C := {F}x : T {.} where F and . are \nrelational assertions. By convention, x is bound in (x : T ) . C and {F}x : T {.}, and can be free in \nC or .. However, the type system enforces that x occurs in C and . only if T is a base type. In other \ncases, we write T . C and {F}T {.}. A relational context G is a sequence of bindings x : T such that \nthe bound variables are pairwise distinct. The re.nement type T is a re.nement of T under G, written \nG f T < T , if T is the result of erasing all pre-and post-conditions occurring in T and if any assertion \nF that appears in T is well-formed in G augmented by the local context of F in T . This relation is extended \nto relational contexts: G < G is the smallest relation such that [] < [] and if G < G and G f T < T then \nG, x : T < G, x : T . RELATIONAL TYPING. Figure 3 33 gives a signi.cant subset of the rules that de.ne \nthe relational typing judgments G f v1 ~ v2 : T for values and G f e1 ~ e2 : C for expressions. In the \n.gure, e[x := e0, e1] stands for e[xL := e0][xR := e1]. The full set of rules appear in the accompanying \nCoq formalization. A judgment of the form G f e1 ~ e2 : {F}x : T {.} is valid when, for any pair of valuations \nIL, IR for G and any pair of states m1, m2 satisfying the pre-condition F, the distributions over values \nand states obtained by executing e1 in IL, m1 and e2 in IR, m2 are related by the lifting of the post-condition \n. to distributions. The formal notion of lifting a relation to distributions is given below. We anticipate \nthat although assertions in relational re.ne\u00adments are .rst-order formulas that do not mention probabilities, \nthe de.nition of lifting is such that valid typing judgments can be used to prove relations between probability \nquantities. For instance, when . denotes an equivalence relation on T , [] F e1 ~ e2 : {true}x : T {.} \nimplies that Pr[e1 . S] = Pr[e2 . S], for any equivalence class S of .. Intuitively, observing to which \nequiva\u00adlence class the results belong does not help in distinguishing the two expressions. As sketched \nin \u00a72.3 2.32.3, we are not limited to sim\u00adply proving probabilistic equivalences; other kinds of probabilistic \nassertions (e.g., inequalities) can also be expressed. The rules come in two .avors: double-sided or \nsingle-sided. Double-sided rules allow us to relate programs with the same head symbol. For instance, \nrules [LET] and [APP] are double-sided. They work by relating sub-expressions pairwise, composing pre-and \npost-conditions using the implicit order of evaluation. Rule [LET] emphasizes this, with the post-condition \nof the let-bound expres\u00adsion being the pre-condition of the body. It is not always possible to progress \nusing double-sided rules. For instance, one may want to show that the two expressions (if b then v else \nv) and v are related by a suitable post-condition. The two expressions having different head symbol, \nno double-sided rule can apply. Single-sided rules allow us to overcome this limita\u00adtion. Rule [IF-LEFT], \nwhich permits to relate an if-expression to an arbitrary expression, is an example of a single-sided \nrule. All the single-sided rules come in pairs: one variant (tagged [*-LEFT]) where the progression is \ndone on the left expression, and one (tagged [*-RIGHT]) where the progression is on the right. Instead \nof showing both cases explicitly, we give a general rule [SYM] that transforms any [*-LEFT] rule into \nits [*-RIGHT] counterpart. Rules for reference assignment ([REF], [REF-LEFT]), which come in two .avors \ntoo, make use of the ability to write assertions about the resulting memory. For example, the two expressions \nr := v0 and r := v1 are related by a post-condition . when ., after replacing all occurrences of rL (resp. \nrR) with v0 (resp. v1), holds as a pre-condition. So far, we only considered rules for expressions headed \nby non\u00adprobabilistic constructions. Rules for random sampling ([FLIP] and [SAMPLE]) are double-sided \nand require the existence of a bijection f between the support of the two distributions, ensuring a one-to-one \ncorrespondence between related values. In the case of [FLIP], we explicitly give the only two existing \nbijections from bool to bool. 3.3 .p: denotational semantics. BACKGROUND. The denotational semantics \nof well-typed expres\u00adsions is based on the sub-probability monad over sets [6 66, 37 3737] and its generalization \nto complete partial orders (cpos); recall that a cpo is a partial order in which every ascending chain \nhas a supremum. The unit interval [0, 1] has a cpo structure w.r.t. the natural order on reals; moreover, \nevery set can be lifted to a .at cpo by adding a bottom element, and the set of functions A . B between \na set A and a cpo B can be given the structure of a cpo. A function between two cpos is monotonic if \nit is order-preserving, and it is continuous if it is monotonic and preserves suprema. Given two cpos \nA and B, mc we let A . B and A . B denote the set of monotonic and contin\u00aduous functions from A to B \nrespectively. By Kleene s .xed point theorem, every continuous function f on a cpo has a least .xed point \n.x f. A discrete sub-distribution over a set X is a continu\u00ad cc ous functional \u00b5 : (X . [0, 1]) . [0, \n1] that satis.es axioms of linearity, compatibility with inverse, and discreteness. In particular, the \nlatter axiom states that the support supp(\u00b5) of \u00b5, consisting of all elements x . X such that \u00b5 dx > \n0, is discrete where dx denotes the Dirac function for x: i.e., dx(x) = 1 and dx(y) = 0 if x = y. We \nlet D(X) be the set of discrete sub-distributions over X. D(X) has the structure of an .-complete partial \norder. Moreover, sub-distributions can be given the structure of a monad; the unit and composition operators \nare denoted by unit and bind respectively. The relational interpretation of types rests on an operator \n\u00b7that lifts relations over A \u00d7 B into relations over D(A) \u00d7 D(B); the operator is inspired from early \nworks on probabilistic bisim\u00adulations [28 2828], and is used in CertiCrypt [7 77] and EasyCrypt [9 99] \nto interpret relational judgments. Formally, let \u00b51 . D(A) and \u00b52 . D(B); then R. \u00b51 \u00b52 iff: .\u00b5 : D(A \n\u00d7 B). p1(\u00b5) = \u00b51 . p2(\u00b5) = \u00b52 . supp(\u00b5) . R where p1 and p2 are the projections for distributions over \npairs, i.e. p1(\u00b5) = bind \u00b5 (.(x, y). unit x) p2(\u00b5) = bind \u00b5 (.(x, y). unit y) A fundamental property \nof this lifting operator is that given cc f : A . [0, 1] and g : B . [0, 1] such that .a . A, b . B. \nR a b . f a = g b then R. \u00b51 \u00b52 implies that \u00b51 f = \u00b52 g, i.e., the expected values of f in \u00b51 and g \nin \u00b52 coincide. Note that events can be viewed as {0, 1}-valued functions, and in this case expectation \ncoincides with probability. INTERPRETATION. We .rst provide a non-relational interpretation of valid \njudgments. We assume each base type B is interpreted as a (.at) cpo [B], and that each constructor c \nbelonging to the base type B is given a denotation B(c) . [B]. We de.ne the set of  semantical values \nas B[B], and then the set M of states as the set of well-typed mappings from references to semantical \nvalues.  M = {m : ref . [B] | .r : ref B. m(r) . [B]} B Then we extend the interpretation to functional \ntypes by setting c [T1 . T2] = [T1] . M([T2]) 6 where M(X) = M . D(X \u00d7 M). A valuation I is a function \nthat maps every declaration x : T to a semantical value. A valuation I is well-formed for G, written \nI F G, if I maps every declaration x : T in G to an element of [T]. G fv v0 : B G fv v1 : B G < G G \n< G x . dom(G) [CONSTR] [VAR] G f v0 ~ v1 : B G f x ~ x : G(x) G, x : B f e0 ~ e1 : C G < G G, x : T \nf e0 ~ e1 : C G < G x /. C [FUN-BASE] [FUN] G f fun x : B . e0 ~ fun x : B . e1 : (x : B) . C G f fun \nx : T . e0 ~ fun x : T . e1 : T . C G f v0 ~ v1 : B G < G G, x:B f F G f v0 ~ v1 : T G < G G f F [BASE-VALUE] \n[VALUE] G f v0 ~ v1 : {F[x := v0, v1]}x : B{F} G f v0 ~ v1 : {F}T {F} r : ref B .G G <G G fv v : B r \n: ref B . G G f v0 ~ v1 : B G < G G, x:B f F G f e0 ~ e1 : C[xL := v] [REF] [REF-LEFT] G f r := v0 ~ \nr := v1 : {F[x := v0, v1]}unit{F[x := r]} G f r := v; e0 ~ e1 : C[xL := rL] G f e0 ~ e1 : (x : B) . C \nG f v0 ~ v1 : B G f e0 ~ e1 : T . C G f v0 ~ v1 : T [APP-BASE] [APP] G f e0 v0 ~ e1 v1 : C[x := v0, v1] \nG f e0 v0 ~ e1 v1 : C G f e0 ~ e1 : {F}x : T {.} G, x : T f e ' 0 ~ e ' 1 : {.}y : U{.} x /. FV(U, .) \n[LET] G f let x = e0 in e ' 0 ~ let x = e1 in e ' 1 : {F}y : U{.} G < G G f T < T G f e ~ e : T G, x \n: T f e0 ~ e1 : {F}y : U{.} x /. FV(U, e1, .) [LET-LEFT] G f let x = e in e0 ~ e1 : {F}y : U{.} f, x \n/. FV(V, .) G, f : (x : T ) . {F}U{F}, x : T f e0 ~ e1 : {F}U{F} G, f : (x : T ) . {F}U{F} f e0 ' ~ e1 \n' : {.}y : V{.} [LETREC] G f letrec f x = e0 in e ' 0 ~ letrec f x = e1 in e ' 1 : {.}y : V{.} G < G \nG fv v : bool G f e1 ~ e : {F1}x : T {.} G f e2 ~ e : {F2}x : T {.} [IF-LEFT] G f if v then e1 else \ne2 ~ e : {(vL . F1) . (\u00acvL . F2)}x : T {.} G < G G fv v : bool G f e1 ~ e ' 1 : {F1}x : T {.} G f e2 \n~ e ' 2 : {F2}x : T {.} [IF] G f if v then e1 else e2 ~ if v then e1 ' else e2 ' : {(vL .. vR) . (vL \n. F1) . (\u00acvL . F2)}x : T {.} G < G G, x:bool f F G < G G, x:int f F f = x . x or f = x . \u00acx f . N . N, \nbijective from [i..j] to [i..j] [SAMPLE][FLIP] G f .ip ~ .ip : {.y : bool. F[x := y, f(y)]}x : bool{F} \nj ij i G f pick~ pick : {F[x := y, f(y)]}x : int{F} G f e1 ~ e2 : C \u00df.\u00b5d e1 -. e2 G f e1 ~ e : C \u00b7 * \nis the operator swapping \u00b7L and \u00b7R [RED-LEFT] [SYM] G f e2 ~ e : C G * f e2 ~ e1 : C * Figure 3. Relational \ntyping rules Let I be a valuation and m be a memory. The interpretations v I context G, written I F G, \nif for any context G such that G < G, and of a value v and e m I of an expression e are de.ned in Figure \n4 44. If every variable x declared in G, I(x) . |G f G(x) < G(x)|II. v : T is derivable, Finally, we \nde.ne the semantic validity of judgments: we say I is a well-formed valuation for G, and G fv then . \n[T]. Likewise, if G fe e : T is derivable then that two values v1 and v2 are semantically related in \nT under G, . M([T]). We now turn to giving a relational interpretation of valid judg\u00adments. A well-formed \nrelational valuation I for G, written I F G, is a pair of well-formed valuations for G. If I v I written \nG F v1 ~ v2 : T , if G < G, and G f T < T , and m I .m. e .I F G, ( v1 p1(I), v2 p2(I)) . |G f T < T|II \n = (IL, IR), We say that two expressions e1 and e2 are semantically related in C under G, written G F \ne1 ~ e2 : C, if G < G, and G f T < T , andwe write p1(I) (resp. p2(I)) for IL (resp. IR), and I(x) for \n(IL(x), IR(x)). We assume given a relational interpretation for formulas, written |F|II, such that for \nany formula F well-formed under G, for any relation valuation I F G, |F|II is a binary rela\u00ad .I F G, \n(.m. m p m p 1(I) 2(I) The following theorem states that all judgments of the logic are , .m. ) . |G \nf C < T|II e1 e2 tion on M. This relation is de.ned as usual, using the left/right val\u00aduation (resp. \nleft/right memory argument) for interpreting variables on the left/right (resp. references on the left/right). \nFigure 5 55 de.nes the interpretation of relational types, written |G f T < T|II, and computation types, \nwritten |G f C < T|II, w.r.t. a relational val\u00aduation I. A relational valuation I is well-formed w.r.t \na relational sound w.r.t. their interpretation; it implies that typing can be used to verify probabilistic \nclaims, thanks to the properties of lifting. Theorem 1 (Soundness). If G f v1 ~ v2 : T , then G F v1 \n~ v2 : T ,  If G f e1 ~ e2 : C, then G F e1 ~ e2 : C.   c I = B(c) x I = I(x) fun x : T . e I = .d. \n.m. e m I[x:=d] v m I = unit ( v I , m) e v m I = bind e m I (.f. .m. f v I m) mm m II I[x:=d] let x \n= e1 in e2 = bind e1 (.d. .m. e2 ) letrec f x = e1 in e2 m I = bind (.x F ) (.d. .m. e2 m ) I[f:=d] m \n!r I = unit (m(r), m) m m r := e I = bind e I (.d. .m. ( , m[r := d])) m .ip I = bind UB (.b. (b, m)) \nm pickj i I = bind U[i,j] (.n. (n, m)) where F = .df . .dx. .m. M m I[f:=df ][x:=dx] Figure 4. Interpretation \nof values and expressions Technically, we prove the soundness of each rule as a lemma, directly from \nthe semantics. It allows us to fall back to the full gen\u00aderality of Coq whenever reasoning outside of \nthe logic is required. 4. Encoding .p in RF* We now discuss our language design and implementation. There \nare two key ideas behind our encoding of .p in RF* . First, as shown in \u00a72.3 2.32.3, we introduce probabilistic \ncomputations into F* axiomatically, by providing a sample primitive at the appropriate type. Programmers \ncan instantiate sample at runtime by providing a suitable source of randomness. Next, as discussed in \n\u00a72.2 2.22.2, we adapt the Hoare state monad ST to a monad RST for computations with relational pre-and \npost-conditions. We provide here more details about our encodings, in particular the style we adopt to \ncompute relational VCs for the RST monad, and the manner in which we reuse classical speci.cations. 4.1 \nRepresenting .p types. To implement .p, we begin with a translation of its types into F* augmented with \na relational state monad. To stay close to .p, our translation uses a monad RST0, which we then adapt \nto the monad RST of \u00a72 22. Like in .p, post\u00adconditions in RST0 only relate the output values and heaps, \nnot the initial heaps. Speci.cally, the type RST0 pre a post can be in\u00adterpreted in RF* as a store-passing \nfunction (over a primitive heap) with the signature shown below: RST0 pre a post = h:heap{|pre (L h) \n(R h)|} . (x:a * h :heap{| post (L x) (R x) (L h ) (R h ) |}) The type translation is homomorphic on \nmost of .p s typing constructs, with the interesting cases mainly on the computation types, where [ {F}y:T \n{.}] is RST0 [[F]] [ T ] (.y0y1.[[.]]). 4.2 A monad of predicate transformers for VC generation. Next, \nto provide type inference for RF* , rather than writing re\u00adlational Hoare triples in RST0, we write speci.cations \nusing predicate transformers. This style is adapted from the Dijkstra state monad, previously introduced \nfor inferring classical (non\u00adrelational) veri.cation conditions for stateful F* programs [46 4646]. In \nparticular, we introduce the relational Dijkstra state monad, RDST, and show its signature below. (We \nwrite polymorphic types implic\u00aditly assuming their free type variables are prenex quanti.ed.) type RDST \na wp = .p. RST0 (wp p) a p val return : x:a . RDST a (.p. p (L x) (R x)) val bind: RDST a wp1 . (x:a \n. RDST b (wp2 x)) . RDST b (.p..h0 h1. wp1 (.x0 x1 h0 h1 . (. x. L x=x0 . R x=x1 =. wp2 x p h0 h1 )) \nh0 h1) The type RDST t wp is an abbreviation for the RST0 monad that is polymorphic in its post-condition. \nSpeci.cally, RDST t wp is the type of computation which for any relational post-condition p on ts and \nheaps, the pre-condition on the input heaps is given by wp p. Unlike the Hoare-style RST0 monad, the \nRDST monad yields a weakest pre-condition calculus by construction. As indicated by the signature of \nbind, when composing computations in the RDST monad, we simply compute a pre-condition for the computation \nby composing the predicate transformers of each component. A slight complication arises from the need \nto constrain the formal parameter x:a of wp2 relationally. In general, wp2 will have free occurrences \nof L x and R x. We relate these to the result of the .rst computation using the guard L x=x0 and R x=x1, \nbefore composing wp1 and wp2. Additionally, by exploiting the post-condition parametricity of RDST, we \ncan recover the expressiveness of a 6-place post\u00adcondition relation in the RST monad that we use in our \nexamples. We show the de.nition of RST below. type RST pre a post = RDST a (.p..h0 h1. pre h0 h1 . .x0 \nx1 h0 h1 . post h0 h1 x0 x1 h0 h1 =. p x0 x1 h0 h1 ) 4.3 Lifting classical speci.cations. To promote \nreuse of existing veri.ed F* code in RF* , we provide combinators to lift speci.ca\u00adtions written with \nclassical predicate transformers into the RDST monad. To illustrate our approach, we show the RF* speci.cations \nof primitive operations on references the same combinators apply to arbitrary classically veri.ed code. \ntype lift wp0 wp1 p h0 h1 = wp0 (.x0 h0 . wp1 (.x1 h1 . p x0 x1 h0 h1 ) h1) h0 type Rd x p h = p (Sel \nh x) h val (!) : x:ref a . RDST a (lift (Rd (L x)) (Rd (R x))) type W x v p h = p () (Upd h x v) val \n(:=): x:ref a. v: a. RDST unit (lift (W (L x) (L v)) (W (R x) (R v))) The combinator lift takes two \nclassical predicate transformers wp0 and wp1 and composes them by, in effect, running them sep\u00adarately \non the heaps h0 and h1 and relating the results and heaps using the relational post-condition p. The \ntypes given to derefer\u00adence and assignment should be evident these are simply the rela\u00adtional liftings \nof the standard, classical weakest pre-condition rules for these constructs (Rd and W, respectively). \n4.4 Computing relational VCs. We repurpose the bulk of F* s type-checking algorithm to RF* . Although \nthe relational typing rules of Fig. 3 33 generally analyze a pair of programs e0 ~ e1, for the most part, \nwe are concerned with proving relational properties of multiple executions of a single program. Thus, \nin the special symmetric case where we are analyzing e ~ e, the two-sided rules of Fig. 3 33 degenerate \ninto the standard typing rules for monadic F* (which is parametric in the choice of monad, so con.guring \nit to use RDST is easy). The main subtlety in computing relational VCs arises when analyzing the cross-cases \nof conditional expressions for this we implement the single-sided rules in the judgment, and we attempt \nto revert to the symmetric case as soon as we detect that the program fragments are indeed the same. \nFor example, the rule [IF] allows us to relate if b then e else e ' ~ e, by generating subgoals for e \n~ e and e ' ~ e, where at least the former can be handled once again by the symmetric rules. The rules \n[RED-LEFT] and [RED-RIGHT] of Fig. 3 33 are impossi\u00adble to implement in full generality they permit reasoning \nabout stateful programs after arbitrary reductions of open terms. Instead, these rules are approximated \nby the RF* typechecker for terms that can be given classical predicate transformer speci.cations. In \npar\u00adticular, when trying to relate e0 ~ e1, if we can use the sym\u00admetric judgments and type e0 ~ e0 : \nRDST t (lift wp0 ), and e1 ~ e1 : RDST t (lift wp1), then we type e0 ~ e1 at type f1, f2 . [T] . M . \nD([U] \u00d7 M) .t1, t2 . |G f T < T|II. (f1 t1, f2 t2) . |G f C < U|II[x:=(t1,t2)] (f1, f2) . |G f (x : T \n) . C < T . U|II (d1, d2) . [B] 2 \u00b51, \u00b52 . M . D([U] \u00d7 M) .m1, m2 . M. |F|II(m1, m2) . P (\u00b51 m1) (\u00b52 \nm2) (d1, d2) . |G f B < B|II (\u00b51, \u00b52) . |G f {F}y : U{.} < U|II '' '' where P = .((u1, m1), (u2, m2)). \n(u1, u2) . |G f U < U|II . |.|II[y:=(u1,u2)](m1, m2) Figure 5. Interpretation of relational re.nement \ntypes RDST t (lift wp0 wp1). In effect, by making use of classical pred\u00adicate transformers on either \nside, we approximate the reduction re\u00adlation for stateful terms used by [RED-LEFT] and [RED-RIGHT]. All \nthese measures for handling the asymmetric cases are still incomplete. When trying to prove a relation \nbetween f v0 ~ g v1 in a context G with relational types for f and g that cannot be decom\u00adposed into \na pair of classical speci.cations, it becomes impossible to complete the derivation. In such cases, RF* \nemits False as the VC (guarded by a relational path condition). Nevertheless, it may still be possible \nto discharge the VC, if the path condition is infea\u00adsible. This is the case, for example, when trying \nto relate the result of encrypt with errorNonce in the passport example of \u00a72.4 2.42.4. 4.5 Proving VCs \nusing Z3. Once a VC has been computed, we ride on an existing encoding of VCs for the classic Dijkstra \nmonad within Z3. We rely on a theorem from Swamy et al. [46 4646] which guarantees that, despite the \nuse of higher-order logic when com\u00adputing VCs, once a predicate transformer is applied to a speci.c .rst-order \npost-condition, so long as there is no inherent use of higher-order axioms in the context, a .rst-order \nnormal form for the VC can always be computed. 5. Applications Table 5 55 summarizes our experimental \nevaluation of RF* . For each program, we give the Make.le target name in the F* distribu\u00adtion, the number \nof lines of code and type annotations (exclud\u00ading comments), and the typechecking time in seconds, which \nis mostly dominated by the time spent solving VCs in Z3. All exper\u00adiments were conducted on a 3GHz HP \nZ820 32-core workstation with 32GB of RAM (although the veri.er makes use of only one core). For lack \nof space, most of these examples are only brie.y de\u00adscribed, with a more detailed discussion of the last \ntwo programs, counter in \u00a75.1 5.15.1 (a cryptographic construction) and meter in \u00a75.2 5.25.2 (a privacy \nprotocol). INFORMATION FLOW. The .rst .ve programs provide many infor\u00admation .ow examples, such as those \nof \u00a72.2 2.22.2, and test cases for single-sided rules using several variations of the RDST monad con\u00adstruction \nof \u00a74 44. PASSPORT UNLINKABILITY. The sixth program, passport illus\u00adtrates the veri.cation of the Basic \nAccess Control protocol for RFID-equipped passports, presented in \u00a72.4 2.42.4. It establishes pass\u00adport \nunlinkability for the modi.ed protocol that returns the same error message in all failure cases. (As \ncan be expected, the original protocol yields a typechecking error.) Its veri.cation illustrates the \nuse of single-sided rules for nested tests (see tag1 in \u00a72.4 2.42.4) and also involves modelling key-hiding \nsymmetric encryption. RANDOM ORACLES. The program ro provides an idealized imple\u00admentation of a cryptographic \nhash function in the random oracle model. In this model, widely used in applied cryptography, the hash \nfunction is assumed to be indistinguishable from a uniformly ran\u00addom function. Thus, knowledge of the \nhash function values on a subset of its domain yields no a priori information about its values outside \nthis subset, and protocols that share the hash function with an adversary can treat those values as secret \nas long as they use disjoint subsets of its domain. The purpose of ro is to capture this reasoning pattern \nin a library that enables type-based veri.cation of protocols in the random oracle model. Our implementation \nlazily samples (and memoizes) the random function, using a mutable reference holding a table mapping \nhash queries made by both honest participants H and adversaries A. To verify the program, this table \ncarries several invariants, including that the tables grow monotonically; that in every pair of executions, \nthe tables agree on the fragments corresponding to queries made by A; and that on the fragments corresponding \nto queries by H, the sampled entries are related by an injective function that ensures they have indistinguishable \ndistributions. The interface of ro is de\u00adsigned to allow the full use of relational sample on the H fragment, \nand to account for failure events (e.g., returning a value to A that collides with one that was already \nprovided to H), allowing for its modular use in a context that must bound their probability. CCA2 ENCRYPTION. \nResistance to adaptive chosen-plaintext and chosen-ciphertext attacks (CCA2) is a standard cryptographic \nsecu\u00adrity assumption for public key encryption schemes. To verify proto\u00adcols relying on this assumption, \nwe program an ideal, stateful func\u00adtionality for CCA2 encryption that maintains a log of prior oracle \nencryptions, similar to those proposed by Fournet et al. [24 2424], but with a more convenient relational \ninterface. Using the F7 type sys\u00adtem with only classic re.nements, they require that all code that op\u00aderates \non secrets be placed in a separate module that exports plain\u00adtexts as an abstract type. Using instead \nrelational types for secrets, in the style of \u00a72.3 2.32.3, we lift this restriction, enabling us to verify \nprotocol code that uses encryption without restructuring. Our code is essentially higher-order; it simulates \nML functors using a depen\u00addently typed record of functions. NONCE-BASED AUTHENTICATION. Exploiting the \nmodularity of our CCA2 implementation, we program and verify simplenonce, a protocol that illustrates \na common authentication pattern based on fresh random values, or nonces, formalizing the intuition that, \nif A encrypts a fresh nonce using the public key of B, and later decrypts a response containing that \nnonce, then the whole response must have been sent by B. PRIVATE AUTHENTICATION. Further extending simplenonce, \nand relying on a key-hiding variant of CCA2, we implement a protocol for private authentication, proposed \nby Abadi and Fournet [1 11], that allows two parties to authenticate one another and to initiate private \ncommunications without disclosing their presence and identities to third parties. Although the protocol \nhas been studied symbolically in the applied pi calculus, to our knowledge we provide its .rst veri.cation \nin a computational model of cryptography. ELGAMAL ENCRYPTION. The chosen-plaintext security (CPA) of \nElGamal encryption by reduction to the decisional Dif.e-Hellman assumption is a classic example of cryptographic \nproof. We verify it in RF* , building on an axiomatic theory of cyclic groups. SECURITY UP TO BAD . The \nprogram uptobad illustrates a com\u00admon pattern to prove re.nement formulas of the form . . Bad where . \nis the property we are interested in and Bad captures con\u00additions that may cause the program to fail \n, usually with a small probability (e.g. when the adversary guesses a private key). To NAME LOC TC(S) \nDESCRIPTION arith 43 4.5 Information .ow with arithmetic pure1 35 1.7 Information .ow &#38; inference \npure2 33 1.7 Information .ow &#38; inference (variant) st 52 3.6 Information .ow with state singlesided \n111 14.2 Information .ow using single-sided rules passport 97 44.2 Unlinkability for RFID passport protocol \nro 73 21.2 Random-Oracle hash function cca2 88 6.5 Idealized CCA2 encryption simplenonce 108 42.5 Nonce-based \nAuthentication protocol privateauth 175 81.4 Private authentication protocol elg 217 124.5 ElGamal encryption \nuptobad 15 1.4 Up-to-failure reasoning counter 106 24.1 Counter mode encryptions using AES meter 182 \n79.8 Commitments &#38; smart meter protocol Total 1,378 451.3 Table 1. Summary of experiments avoid \npolluting all our speci.cations with this disjunction, we de\u00ad.ne an up-to-bad variant of the RDST monad, \nwhere all pre-and post-conditions, and all heap invariants, are enforced only as long as a distinguished \nboolean memory reference is false. Intuitively, this adds an implicit . Bad to every re.nement. Our encoding \nproceeds in two steps. First, we de.ne mref a p, the type of monotonic references r to an a-value whose \ncontents can be updated only when the update condition p holds. That is, when p is a re.exive transitive \nbinary a-predicate, given two heaps h and h , if h is a successor of h then p (Sel h r) (Sel h r) holds. \nWe give below the resulting speci.cation of mwrite, requiring the update condition p as a pre-condition. \nprivate type mref a (p:a . a . E ) = ref a val mwrite: a::* . p::a. a. E . r:mref a p . v: a . RST (.h0 \nh1. p (Sel h0 (L r)) (L v) . p (Sel h1 (R r)) (R v)) unit (.h0 h1 () () h0 h1 . h0 =Upd h0 (L r) (L v) \n. h1 =Upd h1 (R r) (R v)) Next, we de.ne UpTo bad requires a ensures as an alias for the RST monad, with \npre-condition requires, result type a, and post\u00adcondition ensures, unless the reference bad is set to \ntrue in the left or right heap, in which case both pre-and post-conditions are trivial: type Bad b h0 \nh1 = Sel h0 (L b)=true . Sel h1 (R b)=true type UpTo (bad:mref bool (.b b . b=true =. b =true)) (requires:heap \n. heap . E) (a::* ) (ensures::heap . heap . a . a . heap . heap . E) = RST (.h0 h1. requires h0 h1 . \nBad bad h0 h1) a (.h0 h1 x0 x1 h0 h1 . ensures h0 h1 x0 x1 h0 h1 . Bad bad h0 h1) Independently, we can \ncompute (or bound) the probability of bad being set to true; for passport, for instance, we set bad to \ntrue as we detect a collision between two sampled nonces, and bound its probability with q 2/264 where \nq is the number of sessions. 5.1 Pseudo-random functions and counter-mode. Resuming from the one-time \npad example (\u00a72.3 2.32.3), we implement a more use\u00adful symmetric encryption scheme based on a block cipher, \nsuch as triple-DES or AES. Blocks are just .xed-sized byte arrays, e.g. 16 bytes for AES. Block ciphers \ntake a key and a plaintext block, and produce a ciphertext block. A common cryptographic security assumption \nis that the block cipher is a pseudo-random function (PRF): for a .xed key, generated uniformly at random, \nand used only as input to the cipher, the cipher is computationally indis\u00adtinguishable from a uniformly \nrandom function from blocks to blocks. We .rst present our sample scheme, then formalize the pseudo-random \nassumption, and .nally explain how we verify it by relational typing. ENCRYPTING IN COUNTER MODE. The \npurpose of symmetric en\u00adcryption modes is to apply the block cipher keyed with a sin\u00adgle, short secret \nin order to encrypt many blocks of plaintexts. In counter mode, to encrypt a sequence of plaintext blocks \npi, we use a sequence of index blocks ii, obtained for instance by increment\u00ading a counter. We independently \napply the block cipher to each ii to obtain a mask mi; and compute the ciphertext block ci as pi . mi, \neffectively using the masks as one-time pads. A practical advantage of this construction is that both \nencryption and decryption are fully parallelizable, and that the sequence of masks can be pre-computed. \nThe blocks i need not be secret, but they must be pairwise-distinct. Otherwise, from the two ciphertexts \np . mi and p ' . mi, one triv\u00adially obtains p . p ' , which leaks a full block of information. For simplicity, \nwe keep the block cipher key implicit, writing f for the resulting pseudo-random function; we focus on \nthe func\u00adtions for processing individual plaintext blocks, rather than lists of blocks; and we attach \nthe (public) index to every ciphertext block. First, assume there is a single encryptor, that counts \nusing an inte\u00adger reference and uses toBytes to format the integer as a block. let n = ref 0; let encrypt \n(p:block) = let i = toBytes !n in n := !n + 1; (i, xor (f i) p) let decrypt i c = xor (f i) c To enable \nindependent encryptions of plaintext blocks, we can remove the global counter and instead sample a block \ni for each en\u00adcryption, as follows. This random block i is called the initialization vector (IV) for \nthe encryption. let encrypt (p:block) = let i = sample 16 in (i, xor (f i) p) Much as for the one-time \npad, we show that encrypt and encrypt can be typed as block . eq (block * block), the type of functions \nfrom (private) blocks to pairs of public blocks, under suitable cryp\u00adtographic assumptions. More general \ncombinations of sampling and incrementing can also be used for independent multi-block en\u00adcryptions; \nfor instance, the usual counter mode is programmed as: let encrypt counter mode (ps:list block) = let \niv = sample 16 in let i = ref iv in iv::List.map (fun p . incrBytes i; xor (f !i)) ps PSEUDO-RANDOM \nFUNCTIONS. To study the security of protocols using a block cipher, we program and type it as a random \nfunction from blocks to blocks. (To test our encryption, we also implement it concretely by just calling \nAES.) If we can prove the security of a protocol using this ideal random-function implementation, then \nthe same protocol using the concrete block cipher is also secure under the pseudo-random-function assumption \n(with a probability loss bounded by the probability of distinguishing between the two ciphers). We implement \nthe function f using lazy sampling: when called, f .rst looks up for a previously-sampled mask in its \nlog; otherwise, f samples a fresh mask. As for the one-time pad, we pass the plaintext block p as a ghost \nparameter, and take advantage of sampling to generate a mask with a relational re.nement to speci.cally \nhide p. Of course, this fails if the mask has already been sampled, so we type f for encryption with \na pre-condition that depends on the current log and requires that i does not occur in the log yet. (We \nuse the same code with a different type for decryption, requesting that i occurs in the log.) val f: \ni:index . p:block . iRST pre block post where pre h0 h1 = (* Requires: i not in the log yet *) not (In \n(L i) (Domain (Sel h0 (L log)))) . (L i = R i) . (Seqn (L i) < Sel h0 (L n)) and post h0 h1 m0 m1 h0 \nh1 = (* Ensures: log extended with (i,p,m) *) Mask (L p) (R p) m0 m1 (* and sampled m s related by injectivity \n*) . h0 = Upd h0 (L log) ((Entry (L i) (L p) m0)::Sel h0 (L log)) . h1 = Upd h1 (R log) ((Entry (R i) \n(R p) m1)::Sel h1 (R log)) let f p i = match assoc i !log with | Some( ,m) . m (* unreachable *) | None \n. let m = sample p in log := (Entry i p m)::!log; m  When using a single counter (function encrypt), \ntypechecking relies on a joint invariant on the counter n and the content of the log that states that \nall entries in the log have an index block i formatted from some n < n. It also involves excluding counter \nover.ows and assuming that toBytes is injective. This enables us to prove that our encryption is secure \nwith no loss in the reduction: the advantage of a CPA adversary against our code is the same as the advantage \nof some adversary against the PRF assumption. When using instead a fresh random block (function encrypt \n), the situation is more complex, as there is a non-null probability that two different encryptions sample \nthe same index i. Our construction is secure as long as no such collisions happen. We capture this event \nusing the up to bad approach presented above, for a Fresh module that silently detects collisions and \nsets the bad .ag accordingly. Concretely, the probability of having a collision when sampling q blocks \nof 16 bytes each is bounded by q 2/2128 . By typing, we prove that encryption, and any program that may \nuse it, leaks information only once bad is true. Thus, we prove the concrete security of encrypt with \na loss of q 2/2128 in the reduction to PRF. 5.2 Privacy-preserving smart metering &#38; billing. We .nally \nimplement and verify the fast billing protocol of Rial and Danezis [40 4040], which involves recursive \ndata structures and homomorphic commitments. The protocol has three roles: a certi.ed meter that issues \nprivate, signed, .ne-grained elec\u00adtricity readings (say one reading every 10 minutes);  a utility company \nthat issues public, signed rates (for the same time intervals, depending on some public policy); and \n a user, who receives both inputs at the end of the month to compute (and presumably pay) his electricity \nbill.  The two security goals of the protocol are to guarantee (1) integrity of the monthly fee paid \nto the utility company; and (2) privacy of the detailed readings, which otherwise leak much information \non the user s lifestyle. The protocol relies on Pedersen commitments [36 3636] and public-key signatures. \nNext, we explain how we prove per\u00adfect, information-theoretic privacy (entirely by relational typing) \nand computational integrity by reduction to the discrete log prob\u00adlem (by typing using up-to-bad ). HOMOMORPHIC \nPEDERSEN COMMITMENTS. We .rst implement typed commitments, parameterized by some multiplicative group \nof prime order p. We outline their interface and review their main security properties. type pparams \n= eq public param type opening (pp:pparams) (x:text) = o:opng {| Eq ((trap (L pp) * L x) + L o) ((trap \n(R pp) * R x) + R o) |} val sample: pp:pparams . x:text . opening pp x val commit: pp:pparams . x:text \n. r:opening pp x . c:eq elt { c = Commit pp x r }let commit pp x r = pp.g x * pp.h r let verify pp \nx r c = (c = pp.g x * pp.h r) The public parameters pp consist of the prime p and two distinct group \ngenerators g and h (possibly chosen by the utility). Texts and openings range over integers modulo p. \nA commitment to x with opening o is a group element c = g xho . Although assumed hard to compute, there \nexists a (known as the trapdoor for these pa\u00adrameters) such that g = ha . Accordingly, we use a = trap \npp for speci.cation purposes, in re.nement formulas but not in the pro\u00adtocol code. We use a in particular \nto specify an injective function for randomly sampling the opening o (modulo p) so that it per\u00adfectly \nhides x: the relational re.nement type opening in the post\u00adcondition of sample records that a*(L x) + \n(L o) = a*(R x) + (R o), LxhLo Rx which implies g = g hRo and enables us to type the result of commit \nas public (eq elt). Intuitively, every commitment can be opened to any x ' , for some hard-to-compute \no ' , so the commitment itself does not leak any information about x as long as o is ran\u00addomly sampled \nand kept secret. At the same time, given x and o, it is computationally hard to open the commitment to \nany x ' = x. 11 11 xxx+x Commitments can be multiplied: g ho * g ho= g ho+oand exponentiated: (g xho)p \n= gxphop to compute commitments to linear combinations of their exponents without necessarily know\u00ading \nthem. These operations are used below to compute the bill; their (omitted) types show that they preserve \neq and opening relational re.nements. Next, we show some typed code for each role of the protocol. METER. \nWe have abstract predicates Readings and Rates to specify authentic lists of readings and rates. We rely \non a signature scheme to sign a list of commitments to private readings; this scheme is assumed resistant \nagainst existential forgery attacks; as explained in [24 2424], we express this property using (non-relational) \nre.nements. For simplicity, we keep the signing and veri.cation keys implicit. type Signed (pp:pparams) \n(cs:list elt) = .xrs. Readings (fsts xrs) . cs = Commits pp xrs val sign: pp:pparams . cs:eq (list elt){Signed \npp cs} . eq dsig val verify meter signature: pp:pparams . cs:eq (list elt) . eq dsig . b:eq bool{ b=true \n=. Signed pp cs } The Signed predicate above states that the commitments have been computed from authentic \nreadings; it is a pre-condition for signing (at the meter) and a post-condition of signature veri.cation \n(at the utility). It uses a speci.cation function fsts that takes a list of pairs and returns the list \nof their .rst projections. Given authentic readings xs, the meter function below calls commits, a recursive \nfunction that maps sample and commit (speci\u00ad.ed above) to every element of xs and returns both a list \nof pairs of readings and openings xt, ot for the user and a public list of com\u00admitments ct for the utility. \nThese commitments are then signed, yielding a public signature. From their eq types, we can already conclude \nthat the data passed from the meter to the utility (that is, the list of commitments and its signature) \ndoes not convey any in\u00adformation about the readings. val meter: pp:pparams . xs:list int{ Readings xs \n} . xrs:(list (x:int * opening pp x)) { xs = fsts xrs } * cs:eq list elt * eq dsig{ Commits pp xrs = \ncs }let meter pp xs = let xrs,cs = commits pp xs in (xrs, cs, sign pp cs) USER. Given a list of pairs \nxt, ot from the meter and a list of rates pt from the utility, the user calls make payment to compute \ntwo u u scalar products: the fee t xtpt, and a fee opening t otpt, and pass them to the utility. val \nmake payment: pp:pparams . xrs: (list (x:text * opening pp x)) { Readings (fsts xrs) } . ps:eq (list \ntext){| Rates (L ps) . Rates (R ps) . SP (fsts (L xrs)) (L ps) = SP (fsts (R xrs)) (R ps) |}  . (eq \ntext * eq opng) let make payment pp xrs ps = let x,r = sums xrs ps in (x,r)  The relational pre-condition \non the 4th line (SP...) is a declassi.ca\u00adtion condition, capturing the user s intent to publish the fee, \ncom\u00adputed as the scalar product SP of the detailed readings and rates, by requiring that the left and \nright fees be equal. By typing the code of the double scalar product sums, we get the same equation for \nthe openings, showing that the fee opening is then also public. The re\u00adsult type of make payment tells \nus that those two scalars reveal no further information on any readings leading to the same fee. More \nexplicitly, we can use the types of the meter and the user to typecheck a privacy game whereby the adversary \nchooses a list of rates and two lists of readings leading to the same fee; obtains the list of commitments, \nits signature, the fee, and the fee opening computed by the meter and user code for one of the two readings \n(each selected at random with probability 1/2); and attempts to guess which of the two readings was used. \nTyping guarantees that the adversary guess does not depend on the random selection of readings, hence \nthat the guess is correct with probability 1/2. Interestingly, this privacy property is information-theoretic, \nand does not rely on any computational assumption. UTILITY. The utility veri.es the signature on the \ncommitments ct; uses the rates pt to compute the product of exponentials  ct pt =(g xt hot )pt =g xtpt \nhotpt = gt xtpt ht otpt tt t and compares it to the commitment g xho computed from the fee x and fee \nopening o presented by the user. Unless the user can open a commitment to several values x (which can \nbe further reduced to the discrete log problem), this con.rms that x is the correct payment. To type \nthe veri.er code, we write classic (but non-trivial) re.nements, using ghost scalar products to keep \ntrack of its computation. val verify payment: pp:pparams . ps:eq (list int){Rates ps} . cs:eq (list \nelt) . s:eq dsig (* from the meter *) . x:eq text . r:eq opng (* from the user *) . b:eq bool{ b=true \n=. .xs. Readings xs . x=SP xs ps }  let verify payment pp ps cs s x r = verify meter signature pp cs \ns . verify commit pp x r (scalarExp pp cs ps) 6. Related work and conclusions Our work spans semantics \nof higher-order probabilistic programs, relational program veri.cation, and cryptographic protocol veri.\u00adcation, \nenabling us to verify the security of protocol implementa\u00adtions under computational assumptions by relational \ntyping. REASONING ABOUT PROBABILISTIC PROGRAMS. The semantics of RF* is based on the monadic representation \nof probabilities used in [6 66, 37 3737]. Our semantics is con.ned to discrete sub-distributions; for \nsome applications, such as robotics and machine learning, it is however essential to support continuous \ndistributions. Higher-order programs over continuous distributions are considered in [15 1515, 35 3535]. \nAn alternative approach is to embed probabilistic programming in a general purpose language, as done \ne.g. by Kiselyov and Shan [29 2929]. Reif [38 3838], Kozen [30 3030], and Feldman and Harel [23 2323] \nwere among the .rst to develop logics for reasoning about probabilistic pro\u00adgrams. Similar logics were \nlater developed by McIver and Morgan [33 3333] and more recently by Chadha et al. [17 1717]. Hurd [27 \n2727] provides a formalization of the framework of McIv McIvMcIver erer and andand Mor MorMorg ggan anan \nin the HOL proof assistant. All these logics are non-relational, and do not allow directly proving relations \nbetween probabilities. RELATIONAL PROGRAM VERIFICATION. Relational Hoare Logic was .rst introduced for \na core imperative program to reason about the correctness of program optimizations and information .ow \nproperties [11 1111]. It was later extended to probabilistic procedural programs with adversarial code, \nand used to formally verify reduc\u00adtionist security proofs of cryptographic constructions [7 77] and dif\u00adferential \nprivacy of randomized algorithms [10 1010]. Relational Hoare Type Theory (RHTT) is an extension of Hoare \nType Theory, used to reason interactively about advanced information .ow policies of higher-order stateful \nprograms with real world data structures [42 4242]; RHTT does not consider probabilistic computations, \nwhich are es\u00adsential to reason about cryptographic protocols. RHTT is fully for\u00admalized as a shallow \nembedding in the Coq proof assistant. The formalization is restricted to programs with .rst-order store, \nbut in principle it could be extended to programs with higher-order store using an axiomatic extension \nof Coq [44 4444]. In contrast, we formalize in Coq a core fragment of RF* , and rest on the F* infrastructure \nto verify large programs. Our formalization is restricted to programs with .rst-order store; as we adopt \na deep embedding, our formal\u00adization could in principle be extended to higher-order store using recent \ndevelopments in step-indexed semantics [4 44]. Beyond RHTT and HTT, there have been many efforts to develop \nand sometimes machine-check program logics for higher-order stateful programs; see [39 3939] for an account \nof the .eld. Relational logics can also be used to reason about continu\u00adity [18 1818]. Naturally, numerous \nprogram analyses and specialized re\u00adlational logics enforce 2-properties of programs. COMPARISON WITH \nEasyCrypt. EasyCrypt [8 88] is a framework for proving the security of cryptographic constructions in \nthe com\u00adputational model. The core of EasyCrypt is a probabilistic Rela\u00adtional Hoare Logic (pRHL) that \nis able to capture common pat\u00adterns of reasoning in cryptographic proofs, including observational equivalence, \nequivalence up to failure, and reductionist arguments. The relational re.nement type system of RF* is \ninspired from pRHL, but it also incorporates concerns of compatibility with F* and automation. In contrast \nto EasyCrypt, RF* offers only lim\u00adited support to carry relational reasoning about structurally differ\u00adent \nprograms, and to reason about probabilities of postconditions the latter is achieved in EasyCrypt using \na probabilistic (but non\u00adrelational) Hoare Logic, which has no counterpart in RF* . As a consequence, \nsome cryptographic constructions whose formaliza\u00adtion in EasyCrypt requires interactive game-based proofs \nand com\u00adplex probabilistic arguments cannot be veri.ed in RF* ; on the other hand, veri.cation in RF* \nis fully automatic. Moreover, EasyCrypt is not primarily designed for building, verifying and deploying \nlarge systems. Recent work [3 33] explores how EasyCrypt can be used to verify C implementations of well\u00adknown \ncryptographic constructions, and through veri.ed compila\u00adtion derive guarantees about x86 executables. \nHowever, this ap\u00adproach does not scale to verifying detailed protocol implementa\u00adtions. In contrast, \nRF* allows programmers to combine relational and non-relational re.nements freely, so that relational \nreasoning steps can take advantage of program invariants embedded in non\u00adrelational re.nements. This \ndistinctive ability of RF* is essential to verify system implementations that rely on cryptography. PROTOCOL \nVERIFICATION. Blanchet s recent account of the .eld of protocol veri.cation provides a panorama of existing \ntools and major achievements [14 1414]. Most of the literature focuses on veri\u00adfying protocol speci.cations, \nor protocol implementations through model extractors [2 22]; alternatives include generating implementa\u00adtions \nfrom veri.ed models [16 1616]. Our work is most closely related to approaches that reason directly about \nimplementations in the sym\u00adbolic [12 1212, 22 2222] or computational models [13 1313, 24 2424, 31 3131]. \nMODULAR TYPE-BASED CRYPTOGRAPHIC VERIFICATION [2 224 44]. Type systems usefully apply to many notions \nof security. In the con\u00adtext of computational cryptography, F FFournet ournetournet et etet al. al.al. \nrely on F7 typed interfaces to encode classic game-based security de.nitions, such as CPA and CCA2, using \na combination of type re.nements for authenticity and type abstraction for integrity and con.dentiality. \nIn comparison, RF* enables both probabilistic and relational reasoning, letting us typecheck constructions \npreviously out of reach. In their reference implementation of TLS [13 1313], for exam\u00adple, the security \nof several intricate cryptographic constructions is speci.ed by typing, but justi.ed by handwritten proofs; \nthe corre\u00adsponding code is trusted, rather than typechecked. (This is the case, e.g. for the MAC-Encode-then-Encrypt \nconstruction in the record layer, somewhat similar to our counter mode encryption example in \u00a75.1 5.15.1.) \nWe intend to carry over their 7,000 lines of code to RF* , reusing their detailed, classic re.nements \nunchanged, and making use of relational typing to verify additional cryptographic libraries. CONCLUSIONS \nAND PROSPECTS. Our work on RF* represents a signi.cant .rst step towards our goal of building software \nwhose security has been veri.ed down to core cryptographic assumptions. On the theory side, we have shown \nhow to generalize prior prob\u00adabilistic relational logics to a higher-order language, which pro\u00advides \na formal basis for the use of high-level abstractions in system implementations. Practically, through \ncareful language design, our extension of F* towards RF* paves the way for carrying out proba\u00adbilistic \nrelational veri.cation in a semi-automated manner using re\u00ad.nement types and SMT solvers. Still, much \nremains to be done. As immediate next steps, we anticipate extending our theory to account for dynamic \nallocation and local state. Toward improving our tools, on the empirical side, we plan to port an existing \nreference imple\u00admentation of TLS [13 1313] to RF* . We expect that RF* s more .exi\u00adble idioms, better \nsupport for type inference, and its self-certi.ed kernel [43 4343] will ease veri.cation and allow us \nto push towards ob\u00adtaining a high-performance implementation of the Internet standard with certi.ed security. \n References [1] M. Abadi and C. Fournet. Private authentication. Theor. Comput. Sci., 322(3):427 476, \n2004. [2] M. Aizatulin, A. D. Gordon, and J. J\u00a8urjens. Computational veri.cation of C protocol implementations \nby symbolic execution. In CCS 2012, pages 712 723. ACM, 2012. [3] J. B. Almeida, M. Barbosa, G. Barthe, \nand F. Dupressoir. Certi.ed computer-aided cryptography: ef.cient provably secure machine code from high-level \nimplementations. In CCS 2013. ACM, 2013. Also appears as Cryptology ePrint Archive, Report 2013/316. \n[4] A. W. Appel and D. A. McAllester. An indexed model of recursive types for foundational proof-carrying \ncode. ACM Trans. Program. Lang. Syst., 23(5):657 683, 2001. [5] M. Arapinis, T. Chothia, E. Ritter, and \nM. Ryan. Analysing unlinkabil\u00adity and anonymity using the applied Pi calculus. In CSF 2010, pages 107 \n121. IEEE Computer Society, 2010. [6] P. Audebaud and C. Paulin-Mohring. Proofs of randomized algorithms \nin Coq. Sci. Comput. Program., 74(8):568 589, 2009. [7] G. Barthe, B. Gr\u00b4egoire, and S. Zanella-B\u00b4eguelin. \nFormal certi.cation of code-based cryptographic proofs. In POPL 2009, pages 90 101. ACM, 2009. [8] G. \nBarthe, B. Gr\u00b4egoire, S. Heraud, and S. Zanella-B\u00b4eguelin. Computer-aided security proofs for the working \ncryptographer. In CRYPTO 2011, volume 6841 of Lecture Notes in Computer Science, pages 71 90. Springer, \n2011. [9] G. Barthe, B. Gr\u00b4egoire, Y. Lakhnech, and S. Zanella-B\u00b4eguelin. Be\u00adyond provable security. \nVeri.able IND-CCA security of OAEP. In CT-RSA 2011, volume 6558 of Lecture Notes in Computer Science, \npages 180 196. Springer, 2011. [10] G. Barthe, B. K\u00a8opf, F. Olmedo, and S. Zanella-B\u00b4eguelin. Probabilistic \nrelational reasoning for differential privacy. In POPL 2012, pages 97 110. ACM, 2012. [11] N. Benton. \nSimple relational correctness proofs for static analyses and program transformations. In POPL 2004, pages \n14 25. ACM, 2004. [12] K. Bhargavan, C. Fournet, and A. D. Gordon. Modular veri.cation of security protocol \ncode by typing. In POPL 2010, pages 445 456. ACM, 2010. [13] K. Bhargavan, C. Fournet, M. Kohlweiss, \nA. Pironti, and P.-Y. Strub. Implementing TLS with veri.ed cryptographic security. In S&#38;P 2013, pages \n445 459. IEEE Computer Society, 2013. [14] B. Blanchet. Security protocol veri.cation: Symbolic and computa\u00adtional \nmodels. In POST 2012, volume 7215 of Lecture Notes in Com\u00adputer Science, pages 3 29. Springer, 2012. \n[15] J. Borgstr\u00a8om, A. D. Gordon, M. Greenberg, J. Margetson, and J. V. Gael. Measure transformer semantics \nfor bayesian machine learning. In ESOP 2011, volume 6602 of Lecture Notes in Computer Science, pages \n77 96. Springer, 2011. [16] D. Cad\u00b4e and B. Blanchet. From computationally-proved protocol speci.cations \nto implementations. In ARES 2012, pages 65 74. IEEE Computer Society, 2012. [17] R. Chadha, L. Cruz-Filipe, \nP. Mateus, and A. Sernadas. Reasoning about probabilistic sequential programs. Theor. Comput. Sci., 379(1\u00ad2):142 \n165, 2007. [18] S. Chaudhuri, S. Gulwani, and R. Lublinerman. Continuity and ro\u00adbustness of programs. \nCommun. ACM, 55(8):107 115, 2012. [19] T. Chothia and V. Smirnov. A traceability attack against e-passports. \nIn FC 2010, volume 6052 of Lecture Notes in Computer Science, pages 20 34. Springer, 2010. [20] M. R. \nClarkson and F. B. Schneider. Hyperproperties. J. of Comput. Sec., 18(6):1157 1210, 2010. [21] L. M. \nde Moura and N. Bj\u00f8rner. Z3: An ef.cient SMT solver. In TACAS 2008, volume 4963 of Lecture Notes in Computer \nScience, pages 337 340. Springer, 2008. [22] F. Dupressoir, A. D. Gordon, J. J\u00a8urjens, and D. A. Naumann. \nGuiding a general-purpose C veri.er to prove cryptographic protocols. In CSF 2011, pages 3 17. IEEE Computer \nSociety, 2011. [23] Y. A. Feldman and D. Harel. A probabilistic dynamic logic. J. Comput. Syst. Sci., \n28(2):193 215, 1984. [24] C. Fournet, M. Kohlweiss, and P.-Y. Strub. Modular code-based cryptographic \nveri.cation. In CCS 2011, pages 341 350. ACM, 2011. [25] J. A. Goguen and J. Meseguer. Security policies \nand security models. In S&#38;P 1982, pages 11 20. IEEE Computer Society, 1982. [26] G. Gonthier, A. \nMahboubi, and E. Tassi. A small scale re.ection extension for the Coq system. Technical Report RR-6455, \nINRIA, 2008. [27] J. Hurd, A. McIver, and C. Morgan. Probabilistic guarded commands mechanized in HOL. \nTheor. Comput. Sci., 346(1):96 112, 2005. [28] B. Jonsson, W. Yi, and K. G. Larsen. Probabilistic extensions \nof process algebras. In Handbook of Process Algebra, pages 685 710. Elsevier, 2001. [29] O. Kiselyov \nand C.-c. Shan. Embedded probabilistic programming. In DSL 2009, volume 5658 of Lecture Notes in Computer \nScience, pages 360 384. Springer, 2009. [30] D. Kozen. A probabilistic PDL. J. Comput. Syst. Sci., 30(2):162 \n178, 1985. [31] R. K\u00a8usters, T. Truderung, and J. Graf. A framework for the crypto\u00adgraphic veri.cation \nof Java-like programs. In CSF 2012, pages 198 212. IEEE Computer Society, 2012. [32] J. McCarthy. Towards \na mathematical science of computation. In IFIP Congress, pages 21 28, 1962. [33] A. McIver and C. Morgan. \nAbstraction, Re.nement, and Proof for Probabilistic Systems. Monographs in Computer Science. Springer, \n2005. [34] A. Nanevski, G. Morrisett, A. Shinnar, P. Govereau, and L. Birkedal. Ynot: dependent types \nfor imperative programs. In ICFP 2008, pages 229 240. ACM, 2008. [35] S. Park, F. Pfenning, and S. Thrun. \nA probabilistic language based upon sampling functions. In POPL 2005, pages 171 182. ACM, 2005. [36] \nT. P. Pedersen. Non-interactive and information-theoretic secure veri\u00ad.able secret sharing. In CRYPTO \n91, volume 576 of Lecture Notes in Computer Science, pages 129 140. Springer, 1991. [37] N. Ramsey and \nA. Pfeffer. Stochastic lambda calculus and monads of probability distributions. In POPL 2002, pages 154 \n165. ACM, 2002. [38] J. H. Reif. Logics for probabilistic programming (extended abstract). In STOC 1980, \npages 8 13. ACM, 1980. [39] B. Reus and N. Charlton. A guide to program logics for higher-order store, \n2012. Unpublished manuscript. [40] A. Rial and G. Danezis. Privacy-preserving smart metering. In WPES \n2011, pages 49 60. ACM, 2011. [41] A. Sabelfeld and A. C. Myers. Language-based information-.ow security. \nIEEE Journal on Selected Areas in Communications, 21(1): 5 19, 2003. [42] G. Stewart, A. Banerjee, and \nA. Nanevski. Dependent types for enforcement of information .ow and erasure policies in heterogeneous \ndata structures. In PPDP 2013, pages 145 156. ACM, 2013. [43] P.-Y. Strub, N. Swamy, C. Fournet, and \nJ. Chen. Self-certi.cation: Bootstrapping certi.ed typecheckers in F* with Coq. In POPL 2012, pages 571 \n584. ACM, 2012. [44] K. Svendsen, L. Birkedal, and A. Nanevski. Partiality, state and dependent types. \nIn TLCA 2011, pages 198 212. Springer, 2011. [45] N. Swamy, J. Chen, C. Fournet, P.-Y. Strub, K. Bhargavan, \nand J. Yang. Secure distributed programming with value-dependent types. In ICFP 2011, pages 266 278. \nACM, 2011. [46] N. Swamy, J. Weinberger, C. Schlesinger, J. Chen, and B. Livshits. Verifying higher-order \nprograms with the Dijkstra monad. In PLDI 2013, pages 387 398. ACM, 2013.   \n\t\t\t", "proc_id": "2535838", "abstract": "<p>Relational program logics have been used for mechanizing formal proofs of various cryptographic constructions. With an eye towards scaling these successes towards end-to-end security proofs for implementations of distributed systems, we present RF*, a relational extension of F*, a general-purpose higher-order stateful programming language with a verification system based on refinement types. The distinguishing feature of F* is a relational Hoare logic for a higher-order, stateful, probabilistic language. Through careful language design, we adapt the F* typechecker to generate both classic and relational verification conditions, and to automatically discharge their proofs using an SMT solver. Thus, we are able to benefit from the existing features of F*, including its abstraction facilities for modular reasoning about program fragments. We evaluate RF* experimentally by programming a series of cryptographic constructions and protocols, and by verifying their security properties, ranging from information flow to unlinkability, integrity, and privacy. Moreover, we validate the design of RF* by formalizing in Coq a core probabilistic &#955; calculus and a relational refinement type system and proving the soundness of the latter against a denotational semantics of the probabilistic lambda &#955; calculus.</p>", "authors": [{"name": "Gilles Barthe", "author_profile_id": "81100111668", "affiliation": "IMDEA Software Institute, Madrid, Spain", "person_id": "P4383793", "email_address": "gilles.barthe@imdea.org", "orcid_id": ""}, {"name": "C&#233;dric Fournet", "author_profile_id": "81100547450", "affiliation": "Microsoft Research, Cambridge, United Kingdom", "person_id": "P4383794", "email_address": "fournet@microsoft.com", "orcid_id": ""}, {"name": "Benjamin Gr&#233;goire", "author_profile_id": "81381590776", "affiliation": "Inria Sophia Antipolis - M&#233;diterran&#233;e, Sophia Antipolis, France", "person_id": "P4383795", "email_address": "benjamin.gregoire@sophia.inria.fr", "orcid_id": ""}, {"name": "Pierre-Yves Strub", "author_profile_id": "81488661455", "affiliation": "IMDEA Software Institute, Madrid, Spain", "person_id": "P4383796", "email_address": "pierreyves.strub@imdea.org", "orcid_id": ""}, {"name": "Nikhil Swamy", "author_profile_id": "81342513197", "affiliation": "Microsoft Research, Seattle, WA, USA", "person_id": "P4383797", "email_address": "nswamy@microsoft.com", "orcid_id": ""}, {"name": "Santiago Zanella-B&#233;guelin", "author_profile_id": "81418594739", "affiliation": "Microsoft Research, Cambridge, United Kingdom", "person_id": "P4383798", "email_address": "santiago@microsoft.com", "orcid_id": ""}], "doi_number": "10.1145/2535838.2535847", "year": "2014", "article_id": "2535847", "conference": "POPL", "title": "Probabilistic relational verification for cryptographic implementations", "url": "http://dl.acm.org/citation.cfm?id=2535847"}