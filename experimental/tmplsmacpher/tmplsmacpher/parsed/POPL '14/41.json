{"article_publication_date": "01-08-2014", "fulltext": "\n A Relationally Parametric Model of Dependent Type Theory Robert Atkey Neil Ghani Patricia Johann bob.atkey@gmail.com \nUniversity of Strathclyde Appalachian State University neil.ghani@strath.ac.uk johannp@appstate.edu \nAbstract Reynolds theory of relational parametricity captures the invariance of polymorphically typed \nprograms under change of data represen\u00adtation. Reynolds original work exploited the typing discipline \nof the polymorphically typed .-calculus System F, but there is now considerable interest in extending \nrelational parametricity to type systems that are richer and more expressive than that of System F. This \npaper constructs parametric models of predicative and im\u00adpredicative dependent type theory. The signi.cance \nof our models is twofold. Firstly, in the impredicative variant we are able to de\u00adduce the existence \nof initial algebras for all indexed functors. To our knowledge, ours is the .rst account of parametricity \nfor depen\u00addent types that is able to lift the useful deduction of the existence of initial algebras in \nparametric models of System F to the depen\u00addently typed setting. Secondly, our models offer conceptual \nclar\u00adity by uniformly expressing relational parametricity for dependent types in terms of re.exive graphs, \nwhich allows us to unify the in\u00adterpretations of types and kinds, instead of taking the relational in\u00adterpretation \nof types as a primitive notion. Expressing our model in terms of re.exive graphs ensures that it has \ncanonical choices for the interpretations of the standard type constructors of dependent type theory, \nexcept for the interpretation of the universe of small types, where we formulate a re.ned interpretation \ntailored for re\u00adlational parametricity. Moreover, our re.exive graph model opens the door to generalisations \nof relational parametricity, for example to higher-dimensional relational parametricity. Categories and \nSubject Descriptors D.3.1 [Programming Lan\u00adguages]: Formal De.nitions and Theory; D.1.1 [Programming \ntechniques]: Applicative (functional) programming General Terms Languages, Theory, Types Keywords relational \nparametricity, dependent type theory 1. Introduction Reynolds theory of relational parametricity captures \nthe invariance of polymorphically typed programs under change of data represen\u00adtation [28]. Relational \nparametricity has been shown to yield a wide range of useful and surprising consequences, including free \ntheo\u00adrems [35], data type representations [13], optimisation of recursive programs [18], and geometric \ninvariance properties [3]. Reynolds Permission to make digital or hard copies of all or part of this \nwork for personal or classroom use is granted without fee provided that copies are not made or distributed \nfor pro.t or commercial advantage and that copies bear this notice and the full citation on the .rst \npage. Copyrights for components of this work owned by others than the author(s) must be honored. Abstracting \nwith credit is permitted. To copy otherwise, or republish, to post on servers or to redistribute to lists, \nrequires prior speci.c permission and/or a fee. Request permissions from permissions@acm.org. POPL 14, \nJanuary 22 24, 2014, San Diego, CA, USA. Copyright is held by the owner/author(s). Publication rights \nlicensed to ACM. ACM 978-1-4503-2544-8/14/01. . . $15.00. http://dx.doi.org/10.1145/2535838.2535852 \noriginal work exploited the typing discipline of the polymorphi\u00adcally typed .-calculus System F, but \nthere is now considerable in\u00adterest in extending relational parametricity to type systems that are richer \nand more expressive than that of System F. Relational parametricity for systems with type-level computa\u00adtion \n of which System F. is the prototypical example has been studied by Vytiniotis and Weirich [33] and \nby Atkey [2]. The latter builds on earlier work by Hasegawa [14], who gives general requirements a model \nmust satisfy in order to interpret System F .. The extra expressive power of System F. allows for Church \nEn\u00adcodings of indexed types. For example, the standard example of a Generalised Algebraic Datatype (GADT) \n[7] for typed expressions containing constants and pairing can be represented by the follow\u00ading System \nF. type: 1 11 .t..a:*.*.(.s.s.a s).(.s, s.a s.a s.a(s\u00d7s)).a t Relational parametricity can be used to \nshow that this type enjoys an initiality property [2], showing that it is isomorphic to the normal GADT \nof typed expressions. By introducing a kind of natural numbers, it is also possible to encode in System \nF. interesting indexed types like length\u00adindexed vectors. However, due to the rigid separation of types \nand terms in System F., type-level and term-level naturals are not the same thing, which leads to duplication \nand loss of expressivity. Dependent type theories weaken the distinction between types and terms, allowing \nterms to appear in types. It is therefore natural to ask whether or not relational parametricity extends \nto systems with type dependency, and whether or not the consequences of relational parametricity (suitably \ngeneralised) carry over as well. In this paper, we answer both these questions in the af.rmative. We \nbuild a model of dependent type theory (in predicative and im\u00adpredicative variants) that naturally extends \nReynolds original rela\u00adtionally parametric model. We also show that, within the impred\u00adicative model, \nevery indexed functor F has an initial algebra, given by the dependently typed Church encoding: .x : \nX. .A : X . U. (.x : X.T(F Ax) . T(Ax)) . T(A x) (The symbol U stands for the universe of small types, \nand T trans\u00adforms a small type into a proper type; we de.ne the syntax of dependent types in Section \n3.) To our knowledge the model we present in this paper is the .rst parametric model, syntactic or se\u00admantic, \nof dependent type theory to establish this key theorem. The question of the existence of relationally \nparametric mod\u00adels of dependent type theory has already been established as rele\u00advant for applications: \nChlipala [8] assumes relational parametricity for representing higher-order abstract syntax, and Nanevski \net al. [23] assumes properties of type abstraction for enforcing security properties. In this paper we \ndemonstrate that relationally parametric models of dependent type theory do exist, though we leave ques\u00adtions \nabout potential applications to future work. Approaches to Understanding Relational Parametricity Since \nReynolds original model-theoretic formulation, relational para\u00admetricity has been studied in a number \nof settings. Reynolds origi\u00adnal model was elucidated by Bainbridge et al. [4], who also moved to a PER-based \ninterpretation of types to handle foundational set\u00adtheoretic problems, caused by impredicativity, with \nReynolds orig\u00adinal formulation. Robinson and Rosolini [30] studied Reynolds model from the point of view \nof internal categories, again to work around foundational problems with the semantics of impredica\u00adtivity. \nMore usefully for us, Robinson and Rosolini reformulated Reynolds original model in terms of re.exive \ngraphs. Re.exive graphs capture the essence of relationally parametric models: types are simultaneously \ninterpreted as sets and as relations between sets, with a distinguished re.exive relation, called the \nequality rela\u00adtion , from any set to itself, and open types are interpreted as mor\u00adphisms between re.exive \ngraphs. The model of dependent type the\u00adory that we construct in this paper is built on the category \nof re\u00ad.exive graphs and re.exive graph morphisms that Robinson and Rosolini used to interpret the types \nof System F. Re.exive graph models of parametricity have also appeared implicitly in the work of Hasegawa \n[13, 14], and explicitly in the work of Dunphy and Reddy [11], both in settings without type dependency. \n Other approaches to understanding parametricity include Pitts operational models of programming languages \nwith polymorphic types and recursion [24]; Plotkin and Abadi s logic for parametric\u00adity [26]; and Wadler \ns translation of System F into second-order predicate logic [34]. The study of relational parametricity \nfor systems with depen\u00addent types originates with Takeuti [31] and has recently been taken up by Bernardy \net al. [5] and Krishnaswami and Dreyer [19]. Both Takeuti and Bernardy et al. study relational parametricity \nfor de\u00adpendent types via syntactic translations from one type theory to another. Krishnaswami and Dreyer \nconstruct a realizability model of the Calculus of Constructions, using Quasi-PERs to simultane\u00adously \nde.ne the underlying and relational interpretations of types. They demonstrate the adequacy of the Church \nencoding of the non\u00adindexed initial algebra representing the natural numbers, but do not mention the \nChurch encodings of indexed initial algebras that we consider in this paper. The distinguishing feature \nof the parametric model of depen\u00addent types developed in this paper is that we follow Robinson and Rosolini \nin taking the interpretation of types as re.exive graphs as primitive, rather than explicitly seeking \na relational interpretation of dependent types, as was done in the work of Takeuti, Bernardy et al. and \nKrishnaswami and Dreyer. In order to capture relational parametricity, our model interprets the universe \nU of small types in terms of sets and relations, so that we recover a relational interpre\u00adtation of types \nwithin the setting of re.exive graphs (Section 4.3). By taking re.exive graphs as primitive, we can offer \nthe following two signi.cant contributions: At a results level, as we have mentioned above, we are able \nto show that the impredicative variant of our re.exive graph model contains initial algebras for all \nindexed functors (Section 5.4). The re.exive property of re.exive graphs plays a crucial role in the \nproof, being the appropriate generalisation of the key identity extension property of relationally parametric \nmodels of System F. Our models for both the predicative and impred\u00adicative variants also validate free \ntheorems about polymorphic terms (Section 5.1), in the style of Wadler [35].  At a conceptual level, \nre.exive graphs offer both canonical choices when building parametric models, and insight into the structure \nof relational parametricity. Robinson and Rosolini used re.exive graphs to bring clarity to relationally \nparametric models of System F, and here we use re.exive graphs to bring clarity to relationally parametric \nmodels of dependent type the\u00adory. Since re.exive graph models are presheaf models, we are  provided \nwith canonical choices of much of the structure of de\u00adpendent types: for example, there is a canonical \nchoice of inter\u00adpretation of .-types, up to isomorphism. For the interpretation of the universe of small \ntypes there is no canonical choice. The obvious choice is to capture a semantic notion of smallness, \nus\u00ading a construction due to Hofmann and Streicher. However, we demonstrate that smallness by itself \nis inadequate for relational parametricity, and we identify two further semantic properties, discreteness \nand proof-irrelevance, that must be captured by our interpretation of a universe of small types (Section \n4.3). Structure of the Paper In Section 2 we trace a path from the original relationally parametric \nmodel of Reynolds, with its explicit use of rela\u00adtions, through to the re.exive graph formulation of \nparametric\u00adity, originally due to Robinson and Rosolini and, separately, Hasegawa. Since most presentations \nof relational parametric\u00adity for System F are explicitly formulated in terms of relations (e.g., Wadler \ns Theorems for Free ), we carefully demonstrate that, at the level of System F, the relational and re.exive \ngraph formulations are equivalent. This gives us the necessary founda\u00adtion on which to build a parametric \nmodel of dependent types.  Section 3 recalls necessary syntactic and semantic background. We set out \nthe precise variants of Martin-L \u00a8of Type Theory (predicative and impredicative) that we will model. \nWe also re\u00adcall the de.nition of Categories with Families (CwFs), a sound and complete class of categorical \nmodels of dependent type the\u00adory.  We construct our parametric models of dependent types in Sec\u00adtion \n4 by showing that the category of re.exive graphs forms a CwF. The key feature of our models, apart from \nour use of re\u00ad.exive graphs, is in our interpretation of the universe U of small types. We examine the \nnecessary features that the interpretation of U must capture (namely smallness, discreteness, and proof\u00adirrelevance) \nand build them into the model.  With our parametric models in hand, we demonstrate several consequences \nof it in Section 5. We show that our model sup\u00adports simple free theorems, as well as the construction \nof initial algebras for arbitrary indexed functors.  Section 6 concludes and offers directions for future \nwork.  2. Relational Parametricity and Re.exive Graphs In this section we introduce the semantic structures \nused to con\u00adstruct our parametric model of dependent types. To this end, we .rst recall in Section 2.1 \nthe direct method for building relationally parametric models of System F, as originally proposed by \nReynolds [28] and elucidated by Bainbridge et al. [4]. We then show in Sec\u00adtion 2.2 how to reformulate \nthis model in terms of re.exive graphs, following Robinson and Rosolini [30]. Any model of System F, \nor any extension of it, must confront the issue of modelling impredicative type quanti.cation. Reynolds \nshowed that classical set-theoretic models of impredicative poly\u00admorphism cannot exist [27]. To overcome \nthis problem, we build our models of impredicative type theories in an impredicative meta\u00adtheory. Speci.cally, \nwe use the Calculus of Inductive Constructions with the predicative Type universe hierarchy, an impredicative \nuni\u00adverse Set, a (disjoint) impredicative universe Prop, and axioms for functional extensionality, and \nproof irrelevance and propositional extensionality in Prop. This theory is implemented in the Coq proof \nassistant [9] with the -impredicative-set option, and the three axioms postulated. We work informally \nwithin this meta-theory, us\u00ading set-theoretic notation. By taking this synthetic approach, we can dispense \nwith the technicalities of constructing a model within  (a : *) . G G f A : * G f B : * G, a : * f A \n: * G f a : * G f A . B : * G f .a:*. A : * Figure 1. Well-kinded Types in System F classical set theory \nusing PERs or internal categories. A fully for\u00admalised relationally parametric model of System F has \nbeen con\u00adstructed in this setting by Atkey [1]. 2.1 Relational Models of Parametricity for System F The \nwell-kinded types of System F are shown in Figure 1. By these rules, well-kinded types are either type \nvariables, function types, or universally quanti.ed types. Kinding contexts G are lists of type variable/kind \npairs a : * that do not contain duplicate type variable names. In System F, there is only the base kind \n* of types. Interpretation of Types In the model presented by Bainbridge et al. [4], each well-kinded \ntype G f A : * is assigned two interpretations: an underlying interpretation [G f A : *]o that interprets \na type as a function on the universe U of small sets, and a relational interpretation [G f A : *]r that \ninterprets a type as a transformer of relations between underlying interpretations. If, for any two sets \nX, Y . U , Rel(X, Y ) denotes the set of binary relations between X and Y , and if |G| stands for the \nnumber of members of G, then the underlying interpretation and the relational interpretation of G f A \n: * have the following meta-theoretic types: [G f A : *]o . U |G| . U [G f A : *]r . ..1, .2 . U |G|. \nRel|G|(.1, .2) . Rel([G f A : *]o.1, [G f A : *]o.2) The underlying interpretation and the relational \ninterpretation of G f A : * are explicitly linked by the appearance of the underlying interpretation \nin the type of the relational interpretation. The two interpretations are also linked by the identity \nextension property, which states that the relational interpretation of any type G f A : * preserves equality: \n.. . U |G|. [G f A : *]r . . Eq. = Eq[GiA:*lo. Here, EqX is the equality relation on the set X, and Eq. \nfor a tuple of sets . = (X1, ..., X|G|) is the tuple (EqX1 , ..., EqX|G| ). Identity extension is the \nkey property that makes a model re\u00adlationally parametric, rather than just logical relations over an \nex\u00adisting model. We can read it as saying that every element of the interpretation of a closed type is \nrelated to itself by the relational interpretation of that type. Therefore, identity extension is similar \nto the abstraction theorem (see Interpretation of Terms at the end of this subsection), except that it \napplies to all elements of the de\u00adnotation of a type, not just the denotations of terms. Consequently, \nwe are able to use the relational interpretation of types to reason about arbitrary elements of the denotations \nof those types, not just elements that are the interpretations of terms. As we shall see when we construct \nthe interpretation of the type\u00adtheoretic universe of small types in Section 4.3 below, our model of dependent \ntypes will satisfy the (suitably generalised) identity extension property for this universe. Identity \nextension is essential in our proof of the existence of initial algebras in Section 5.4. A consequence \nof requiring identity extension is that the under\u00adlying interpretation and the relational interpretation \nmust be de.ned simultaneously. This is due to the interpretation of types of the form G f .a: * .A : \n*. Indeed, if we do not cut down the underlying interpretations of universal types to include only the \nparametric elements, then we will be unable to prove the identity extension property. This cutting down \nis shown in Bainbridge et al. s de.ni\u00adtions of the underlying interpretations and relational interpretations \nfor universal types, here adapted to our setting: [G f .a: * .A : *]o. = {x : .X . U . [G, a : * f A \n: *]o(., X ) | .X, Y, R . Rel(X, Y ). (x X, x Y ) . [G, a : * f A : *]r(., X )(., Y )(Eq. , R)} [G f \n.a: * .A : *]r.1.2. = {(x, y) | .X, Y , R . Rel(X, Y ). (x X, y Y ) . [G, a : * f A : *]r(.1, X )(.2, \nY )(., R)} We will refer back to this de.nition when we construct the inter\u00adpretation of dependent products \n(.-types) in our relationally para\u00admetric model of dependent types in Section 4.4. Interpretation of \nTerms A well-typed term of System F is deter\u00admined by the typing judgement G; T f M : A where G is a \nkind\u00ading context, T is a typing context consisting of variable name/type pairs xi : Ai where each Ai \nis well-kinded with respect to G, and A is also well-kinded with respect to G. We write G f T to indicate \nwhen all the types in the typing context T are well-kinded with respect to the kinding context G. We \nomit the (entirely standard) typing rules that generate the judgement G; T f M : A. The interpretation \nof types that we sketched above is extended to an interpretation of typing contexts T by tupling together \nthe interpretations of the constituent types and using the standard log\u00adical relations interpretation \nof product types. Each well-typed term G; T f M : A is interpreted as a family [G; T f M : A]o of functions \nfrom the underlying interpretation of the typing context T to the underlying interpretation of the type \nA, indexed by the underlying interpretations of the free type variables: [G; T f M : A]o : .. . U |G|. \n[G f T]o. . [G f A : *]o. Because the underlying interpretations and relational interpreta\u00adtions of types \nare mutually de.ned, we must simultaneously de.ne [G; T f M : A]o and prove the following property, which \nstates that the relational interpretations of T and A are preserved: ..1, .2 . U |G|, . . Rel|G|(.1, \n.2), .1 . [G f T]o.1, .2 . [G f T]o.2. (.1, .2) . [G f T]r.1.2. . ([G; T f M : A]o .1 .1, [G; T f M : \nA]o .2 .2) . [G f A : *]r.1.2. This preservation of relations property has been variously called Reynolds \nAbstraction Theorem [28], the Fundamental Theorem of Logical Relations [25], and the Parametricity Theorem \n[21].  2.2 Re.exive Graph Models of Parametricity for System F The two-level approach of the Reynolds/Bainbridge \net al. model, in which types are assigned an underlying interpretation and a rela\u00adtional interpretation, \nworks well for the relatively simple setting of System F. However, it is dif.cult to see how to extend \nthis approach to allow for more complex features such as higher kinds, which al\u00adlow function kinds such \nas * . *, and type-level computation, as is found in dependent type theories. The primary dif.culty lies \nin ex\u00adtending the de.nition of the identity extension property. When we only considered the base kind \n*, interpreted as the collection of sets X . U , there was an obvious notion of equality relation . But \nit is not so obvious what equality relation should mean when inter\u00adpreting higher kinds. One complication \nis that, no matter what our notion of equality relation ends up being, an equality relation for a higher-kinded \ntype must actually be a relation transformer. This complication is further compounded when attempting \nto interpret a dependent type theory in which types may depend on terms as well as types. Fortunately, \nby using re.exive graphs, as introduced by Robinson and Rosolini [30], we can construct a parametric \nmodel of System F that naturally extends to dependent types.  De.nition 1. A re.exive graph is a 5-tuple \n(GO, GR, Gre. , Gsrc , Gtgt ) comprising a pair of sets GO and GR, together with three functions GO \n   Gtgt Gre. Gsrc  GR such that Gsrc .Gre. = idGO = Gtgt .Gre. . A morphism f between re.exive graphs \nG and . is a pair of functions (fo, fr) that makes every square the following diagram commute: fo _ - \nGO .O     Gtgt.src .tgtGre..re.Gsrc   fr _ - GR .R The set GO is called the set of objects, and \nGR is called the set of relations, of the re.exive graph. We use re.exive graphs for two purposes: to \nmodel collections of types, and to model speci.c types. The .rst use takes GO to be a set of sets and \nGR to be a set of relations over those sets. Each relation .r . GR is thus a relation between Gsrc (.r), \nand Gtgt (.r) and each set .o . GO has a distinguished relation Gre. (.o) relating .o to itself. This \nintuition underlies the following example. Example 1. If U is a universe of small sets, then the kind \n* of types can be interpreted as a re.exive graph (also called *) as follows: *O = U *R = {(X, Y, R) \n| X, Y . U , R . Rel(X, Y )} * re. (X) = (X, X, EqX ) * src (X, Y, R) = X * tgt (X, Y, R) = Y The objects \nof this re.exive graph are thus small sets from U, and its relations are ordinary binary relations between \nsuch sets. For each X . U , the function * re. takes the equality relation to be the distinguished binary \nrelation on X. For this choice of relation the identity extension property is a straightforward consequence \nof the de.nition of a re.exive graph morphism. Our second use of re.exive graphs takes GO to be a speci.c \nset and GR to be a re.exive relation on that set, represented as a (multi-)set of pairs of elements that \nare related. Then Gre. ensures that GR is re.exive, while Gsrc and Gtgt map each pair of related elements \nto the component elements that are so related. This intu\u00adition underlies the following example, which \nforms the basis of the interpretation of the natural number type we present in Section 4.4. Example 2. \nA re.exive graph can be built from the set of natural numbers as follows: natre. (n) = n natO = N natsrc \n(n) = n natR = N nattgt (n) = n The objects of this re.exive graph are just the natural numbers. For \nany n . natR, we have natsrc (n) = nattgt (n) = n, so two natural numbers are related if and only if \nthey are equal. Generalising the construction of nat, for any set X there is a re.exive graph (X, X, \nidX , idX , idX ) that has X as its set of objects and relates objects in X if and only if they are equal. \nIn particular, if 1 is a terminal object in the category of sets, then (1, 1, id1, id1, id1) is terminal \nin the category of re.exive graphs. Re.exive graphs can be equivalently de.ned as covariant f src presheaves \nover the category RG = - re. _- where src . tgt re. = id = tgt . re. . Morphisms between re.exive graphs \nare exactly natural transformations between presheaves in SetRG . Viewing re.exive graphs as presheaves \nensures that the following well-known properties of categories of presheaves hold for cate\u00adgories of \nre.exive graphs as well. Firstly, categories of presheaves are always cartesian, so we can use the .nite \nproduct structure to interpret kinding contexts. Secondly, categories of presheaves are always cartesian \nclosed, which allows for the interpretation of higher kinds [2]. Finally, presheaf categories always \nform a (non\u00adparametric) model of dependent type theory [15], a fact that will help us construct the parametric \nmodel we present in Section 4. Interpretation of Types A well-kinded type G f A : * is inter\u00adpreted as \na re.exive graph morphism from the |G|-fold product of the re.exive graph * from Example 1 to * itself. \nJust as we did in Example 1, we identify a context with its re.exive graph inter\u00adpretation and use the \nsame notation for both. Unfolding the de.ni\u00adtions shows that a re.exive graph morphism is nothing more \nthan a pair comprised of an underlying interpretation and a relational in\u00adterpretation satisfying the \nidentity extension property, exactly as in the two-level semantics in Section 2.1. For any re.exive graph \nG, we think of the homset SetRG (G, *) as providing interpretations of types over G. Interpretation of \nTerms Just as in Section 2.1, the interpretation of types can be extended to an interpretation of typing \ncontexts by tupling in the current setting. A well-kinded typing context G is therefore also interpreted \nas an object of SetRG (G, *). In the re.exive graph model, a well-typed term G; T f M : A is then interpreted, \nas before, as a morphism from the interpretation of the typing context T to the interpretation of the \ntype A, i.e., as a morphism in the category SetRG (G, *): De.nition 2. Let A, B . SetRG (G, *). A morphism \nfrom A to B is a function M : ..o . GO. Ao(.o) . Bo(.o) such that for all .r . GR, if Ar(.r) = (A1, A2, \nRA . A1 \u00d7 A2) and Br(.r) = (B1, B2, RB . B1 \u00d7 B2) then for all (a1, a2) . RA, (M (Gsrc (.r)) a1, M (Gtgt \n(.r)) a2) . RB. This de.nition makes each homset SetRG (G, *) into a category. Note that the fundamental \ntheorem of logical relations stated at the very end of Section 2.1 is identical to the condition in De.nition \n2, up to the reformulation of types as re.exive graph morphisms. 3. Martin-L\u00a8 of Type Theory with a Universe: \nSyntax and Categorical Semantics The re.exive graph model of parametricity we present in Section 4 is \nde.ned with respect to the speci.c formulation of dependent type theory that we set out in this section. \nThe type theory we consider is a standard variant of Martin-L \u00a8of type theory [22] with a natural number \ntype nat, dependent product types .x:A.B, and a Tarski\u00adstyle universe U closed under natural numbers \nand dependent prod\u00aducts. Our default assumption is that the universe U is predicative, but we will also \nconsider an impredicative universe in order to more closely relate our results with (impredicative) System \nF. Our type theory includes \u00df-and .-equality rules for dependent product types, as well as \u00df-equality \nrules for the natural numbers. Since our universe is Tarski-style, we have an explicit decoder type former \nT to take terms of type U to actual types. The type theories we present in this section are close to \nthe theo\u00adries underlying the Agda [6] and Coq [9] systems. Our predicative theory is close to Agda, except \nthat we only have one inductive type (the natural numbers), and we only have one universe, with an explicit \nuniverse decoder. The impredicative variant is close to the Calculus of Constructions (the theory underlying \nthe impred\u00adicative variant of Coq), except with a natural number type, and an explicit universe decoder. \nOur use of an explicit universe decoder Judgement  Intuitive meaning G ctxt G is a well-formed context \nG f A type A is a well-formed type in the context G G f M : A the term M has type A in the context G \nG f A = B type A and B are equal types in the context G G f M = N : A the terms M and N are equal at \nthe type A in the context G Figure 2. Judgement forms is a technical device that means we do not have \nto deal with co\u00adherence issues arising from multiple typing derivations of the same term. Moving to an \nimplicit universe decoder with our models does not present any problems that do not already arise when \nde.ning models of dependent types with a universe. 3.1 Syntax and Typing The raw contexts, types, and \nterms are de.ned as follows: G ::= < | G, x : A A, B, C ::= .x:A.B | Nat | U | T M M, N, P ::= x | .x.M \n| M N | ze | su M | Nrec(x.A, M z, x p.M s, N ) | nat | px:M.N We will write A . B for the type .x:A.B \nwhen x does not appear free in B, and similarly write M . N for the term px:M.N when x does not appear \nfree in N. Capture avoiding substitution of terms for variables in pre-syntax types (A[N/x]) and terms \n(M[N/x]) is de.ned in the usual way. In the term Nrec(x.A, M z, x p.M s, N ), the variable x is considered \nbound in A, and the variables x and p are considered bound in M s . The well-formed types and well-typed \nterms are de.ned using a collection of .ve mutually inductively de.ned judgements. The .ve different \njudgements and their intuitive meanings are given in Figure 2. The .rst three judgements de.ne subsets \nof the raw syntax that are to be considered well-formed under some assumptions. The remaining two judgements \nde.ne when two types or terms are considered as equal for the purposes of the theory. The rules generating \nthe judgements are given in Figure 3 and type rules for type equality judgements are given in Figure \n4. The rules for term equality judgements, that is \u00df-and .-equality for .-types and \u00df-equality for Nat \nare displayed in Figure 4. The type and term equality judgements are also understood to include the re.exivity, \nsymmetry, transitivity and congruence rules. Note that, due to the type former T, the congruence rules \nmake type equality depend on term equality. Further discussion about these rules, and close relatives \nof them, can be found in Hofmann s survey of the syntax and semantics of dependent type theories [15]. \nImpredicativity The additional rules for considering an impred\u00adicative universe are given in Figure 5. \nThese rules replace the rules U -p in Figure 3 and \u00df-U-p in Figure 4 describing the U-former px:M.N . \nImpredicativity allows the construction of types in U (i.e., of small types) by quanti.cation over some \nlarge type A, which may, in fact, be U itself. We can therefore construct a uni\u00adverse U for example, \nsuch that pa:U. a . a : U that is not permitted in the predicative theory. When U is impredicative, \nour type theory is equivalent to a variant of Coquand and Huet s Calculus of Constructions [10].  3.2 \nCategories with Families The syntax of Martin-L \u00a8of Type Theory is a complex system of mutually inductive \nde.nitions. The mutual dependencies between well-formed types, equality, and well-typed terms severely \ncompli\u00adcate directly de.ning and proving sound a semantics for type the\u00adory. We address this issue by \nformulating our re.exive graph model Context formation (G ctxt) G ctxt G f A type ( EM P ) (EX T ) < \nctxt G, x : A ctxt Type Formers (G f A type) G f A type G, x : A f B type (TY-.) G f .x:A. B type ( \nT Y-NAT ) ( TY-U) G f Nat type G f U type G f M : U ( T Y-T) G f TM type Typing Rules (G f M : A) G, \nx : A, G1 ctxt (VA R ) G, x : A, G1 f x : A G f M : A G f A = B type ( CO N V ) G f M : B G, x : A f \nM : B ( L A M ) G f .x:A.M : .x:A.B G f M : .x:A.B G f N : A (AP P ) G f M N : B[N/x] G f n : Nat (ZE) \n(SU) G f ze : Nat G f su n : Nat G, x : Nat f A type G f Mz : A[ze/x] G, n : Nat, p : A[n/x] f Ms : A[su \nn/x] G f n : Nat ( NR E C ) G f Nrec(x. A, M z, n p. M s , n) : A[n/x] (U -NAT ) G f nat : U G f M : \nU G, x : TM f N : U (U -p) G f px:M.N : U Figure 3. Typing Rules of Martin-L \u00a8of Type Theory with Universe \nG f A type G, x : A f M : U (U -p ) G f px:A.M : U G f A type G, x : A f M : U (\u00df-U -p ) G f T(px:A. \nM ) = .x:A. TM type Figure 5. Rules for Impredicative Quanti.cation  Type Equality Rules (G f A = B \ntype) G f M : U G, x : TM f N : U (\u00df-U -NAT ) (\u00df-U -p) G f T nat = Nat type G f T(px:M.N ) = .x:TM. TN \ntype elided: type equality is an equivalence relation and a congruence with respect to all type formers. \nTerm Equality Rules (G f M = N : A) G, x : A f M : B G f N : A G f M : .x:A.B (.-\u00df) (.-.) G f (.x:A. \nM )N = M [N/x] : B[N/x] G f (.x:A. M x) = M : .x:A.B G, x : Nat f A type G f Mz : A[ze/x] G, n : Nat, \np : A[n/x] f Ms : A[su n/x] (\u00df-ZE) G f Nrec(x.A, M z, n p.M s , ze) = Mz : A[ze/x] G, x : Nat f A type \nG f Mz : A[ze/x] G, n : Nat, p : A[n/x] f M s : A[su n/x] G f n : Nat (\u00df-SU) Nrec(x. A, M z, n p. M \ns , su n) G f : P [su n/x] = Ms[n/n, Nrec(x.A, M z, n p.M s , n)/p] elided: term equality is an equivalence \nrelation and a congruence with respect to all term formers. Figure 4. Type and Term Equality Judgements \nin terms of categories with families (CwFs), a notion originally due to Dybjer [12]. CwFs form a sound \nand complete class of categori\u00adcal models of many variants of dependent type theory, as explained by \nHofmann [15]. Therefore, by demonstrating that the category of re.exive graphs forms a CwF with the appropriate \nadditional struc\u00adture needed for the type formers we have chosen, we are guaranteed to have soundly modelled \nthe syntax of the type theory presented in the previous section. We present the de.nition of a CwF (De.nition \n3), and then present the extra structure required for dependent products (De.\u00adnition 4), a natural number \ntype (De.nition 5), and a universe of small types (De.nition 6). We loosely follow Hofmann s presenta\u00adtion \n[15], except that we specialise for our particular type theory. The Basic Structure CwFs provide enough \nstructure to interpret the contexts, types, and terms of a type theory, along with simulta\u00adneous substitutions \nand their action on types and terms. Judgemen\u00adtal equality on types and terms is modelled directly as \nequality in the model; in particular, there is no semantic structure correspond\u00ading to the rule CO N \nV. Here, we de.ne comprehension in terms of a bijection between sets of morphisms and semantic terms. \nThis is equivalent to Hofmann s de.nition of comprehension in terms of projections and weakening. We \ntreat projection and weakening as derived structure, as described after the following de.nition. De.nition \n3. A Category with Families (CwF) consists of: 1. A category C, whose objects are intended as the semantic \ninter\u00adpretations of contexts and whose morphisms are intended as the interpretations of simultaneous \nsubstitutions; 2. For each G . Ob(C), a collection Ty(G) of semantic types;  3. For each G . Ob(C) \nand semantic type A collection Tm(G, A) of semantic terms; 4. For every morphism f : G . . in C, a function \n. Ty(G), a -{f} : Ty(.) . Ty(G) interpreting type substitution, and for every A . Ty(.), a function \n-{f} : Tm(., A) . Tm(G, A{f}) interpreting term substitution, such that the following hold: A{idG} = \nA (1) A{f}{g} = A{f . g} (2) M{idG} = M (3) M{f}{g} = M{f . g} (4) Equations 3 and 4 are well-typed by \nvirtue of Equations 1 and 2, respectively. 5. A chosen terminal object 1 in C, interpreting the empty \ncontext; 6. For each G . Ob(C) and A . Ty(G) an object G.A . Ob(C) (called the comprehension of A) such \nthat there is a bijection  C(., G.A) ~= {(f, M ) | f : . . G, M . Tm(., A{f})} that is natural in .. \nAn alternative presentation of points (1) to (4) of De.nition 3 is as a functor Cop . Fam(SET), where \nSET is the category of large sets (which includes the category Set as an object). Given f : . . G and \nM . Tm(., A{f}), we write (f, M ) for the associated morphism . . G.A in C given by the iso\u00admorphism \nin point (6) of De.nition 3. Conversely, given a mor\u00adphism f : . . G.A in C, we write f #1 : . . G and \nf#2 . Tm(., A{f#1}) for the associated morphism and seman\u00adtic term. The following de.nitions derive projection \nand weakening structure from De.nition 3, and also de.ne the semantic counter\u00adpart of a simultaneous \nsubstitution of a term for a variable. 1. For any G . Ob(C) and A . Ty(G), the .rst projection G #1 morphism \npG A : G.A . G is de.ned as pA = idG.A. This is used to interpret weakening by discarding a single variable. \n2. For any G . Ob(C) and A . Ty(G), the second projection G G G #2 q. Tm(G.A, A{pA}) is de.ned as q = \nid. This is A A G.A used to interpret the rule VA R. 3. For any G, . . Ob(C), A . Ty(G) and morphism \nf : . . G, the weakening of f by A, wkAf : ..A{f} . G.A is . . de.ned as wkAf = (f . pA{f}, qA{f}). This \nis used to lift simultaneous substitutions to work in larger contexts. 4. For any G . Ob(C), A . Ty(G) \nand M . Tm(G, A), we de.ne the morphism M : G . G.A as M = (idG, M ). Mor\u00ad  phisms built from semantic \nterms are used to build simultane\u00adous substitutions that substitute (semantic) terms for variables. Dependent \nProducts Hofmann s presentation of the structure for interpreting dependent product types in a CwF admits \nthe possi\u00adbility of not supporting the .-rule. But since the type theory we consider in this paper does \ninclude the .-rule .-., we can use the following compact de.nition to describe the requirements ensuring \nthat a CwF supports dependent products. De.nition 4. A CwF C supports dependent products if for all semantic \ncontexts G . Ob(C) and semantic types A . Ty(G) and B . Ty(G.A) there exists a semantic type .AB . Ty(G), \nnatural in G, such that there is a bijection . : = Tm(G.A, B) ~Tm(G, .AB), natural in G. De.nition 4 \ngives a semantic counterpart of the abstraction rule LA M. We de.ne the following semantic counterpart \nof the application rule AP P. For G, A and B as in De.nition 4, and M . Tm(G, .AB) and N . Tm(G, A), \nwe de.ne AppG (M, N ) . A,B Tm(G, B{N}) by AppG = (.-1(M)){N}. A,B The Natural Number Type The structure \nrequired to model the type of natural numbers directly follows the syntactic structure we presented in \nSection 3, modulo the more explicit presentation of substitution inherent in the CwF formalism. The following \nde.ni\u00adtion gives semantic counterparts to the rules ZE, SU, and NR E C. De.nition 5. A CwF C supports \nnatural numbers if, for all G . Ob(C), there is a semantic type NatG . Ty(G) (we usually omit the superscript \nG), semantic terms zero . Tm(G, Nat) and succ . Tm(G.Nat, Nat), and, for each A . Ty(G.Nat), a function \non semantic terms Nrec A of type Tm(G, A{zero}) \u00d7 G G.Nat Tm(G.Nat.A, A{wkNat p.succ.p}) . Tm(G.Nat, \nA) Nat A such that Nat, zero , succ and Nrec are natural in G, and the following two equations hold: \nNrecA(Mz, M s){zero } = Mz (5) G NrecA(Mz, M s){wkNat pNat . succ} = Ms{NrecA(Mz, M s)} (6) Universe \nThe CwF interpretation of the universe U is just the translation of the syntactic structure into the \nCwF framework. The following de.nitions are semantic counterparts to U-NAT, U-p, and U -p . We treat \nthe predicative and impredicative cases separately. De.nition 6. A CwF C supports a predicative universe \nclosed un\u00adder natural numbers and dependent product if (a) for all G . Ob(C) there exist semantic types \nU . Ty(G) and T . Ty(G.U ), both natural in G; (b) there exists a semantic term nat . Tm(G, U ), natural \nin G such that T {nat} = Nat; and (c) for all M . Tm(G, U ) and N . Tm(G.T {M}, U ) there exists a semantic \nterm pMN . Tm(G, U ), natural in G; such that T {pM N } = .(T {M})(T{N}). De.nition 7. A CwF C supports \nan impredicative universe closed under natural numbers and dependent product if there are U , T , and \nnat as in De.nition 6, and for all A . Ty(G) and M . Tm(G.A, U ) there exists a semantic term pAM . Tm(G, \nU ), natural in G, such that: T {pAM } = .A(T {M}). 4. The Re.exive Graph Model of Type Theory Constructing \nour re.exive graph model of type theory is now a mat\u00adter of showing that the category of re.exive graphs \nfrom Section 2 has the structure of a category with families. The essential tasks are to (a) establish \nwhat a family of re.exive graphs over a re.exive graph is, in order to model types (Sections 4.1 and \n4.2); and (b) to determine the interpretation of the universe type U (Section 4.3). Once we have done \nthe former, the interpretations of .-types and the natural number type are determined up to isomorphism \n(Sec\u00adtion 4.4). As an intuitive guide for determining the correct de.ni\u00adtion of a family of re.exive \ngraphs, we use standard results about .brational models of dependent types. Knowledge of .brations is \nnot required to understand our .nal de.nitions. 4.1 Families of Re.exive Graphs A standard way to model \nthe dependency of types on terms is to use the families .bration p : Fam(Set) . Set, where the category \nFam(Set) has as objects pairs (X, P ), where X . Set and P : X . Set, and the functor p projects out \nthe .rst element. The basic idea of the families .bration is that a pair (X, P ) represents a context \nX and a collection P of types indexed by the elements of X. However, in a re.exive graph model of parametricity \nwe want to index not by sets, but by re.exive graphs in SetRG . Fortunately, there is a natural way to \ndo this. By standard results about .brations (see Exercise 1.8.8 in Jacobs [17]), the RG RG functor p \n: Fam(Set)RG . SetRG , de.ned as p (F ) = p . F , is also a .bration. This hints that objects of Fam(Set)RG \nare the natural interpretations of dependent types in a re.exive graph model of parametricity, and that \nthe functor p RG should send each such object to the re.exive graph interpreting the context over which \nthe type that object interprets is indexed. Unpacking the de.nition of Fam(Set)RG , we see that an object \nof Fam(Set)RG is equivalent to a pair (G, A) of a re.exive graph G, together with a family A of re.exive \ngraphs that is over G, in the following sense: De.nition 8. Let G be a re.exive graph. A family of re.ex\u00adive \ngraphs over G is a 5-tuple A = (AO, AR, Are. , Asrc , Atgt ), where: AO : GO . Set AR : GR . Set Are. \n: ..o . GO. AO(.o) . AR(Gre. (.o)) Asrc : ..r . GR. AR(.r) . AO(Gsrc (.r)) Atgt : ..r . GR. AR(.r) . \nAO(Gtgt (.r)) such that the following equations hold: ..o . GO. Asrc (Gre. (.o)) . Are. (.o) = id (7) \n..o . GO. Atgt (Gre. (.o)) . Are. (.o) = id (8) Morphisms between pairs of families of re.exive graphs \nover the same re.exive graph are derived from the morphisms of Fam(Set)RG . This yields the following \nde.nition: De.nition 9. Let G be a re.exive graph and let A and B be families of re.exive graphs over \nG. A morphism M from A to B consists of a pair of functions Mo : ..o . GO. AO(.o) . BO(.o) Mr : ..r . \nGR. AR(.r) . BR(.r) such that ..o . Go, ao . AO(.o). Bre. (.o)(Mo .o ao) = Mr (Gre. (.o)) (Are. (.o)(ao)) \n..r . GR, ar . AR(.r). Bsrc (.r)(Mr .r ar) = Mo (Gsrc (.r)) (Asrc (.r)(ar)) ..r . GR, ar . AR(.r). Btgt \n(.r)(Mr .r ar) = Mo (Gtgt (.r)) (Atgt (.r)(ar)) Families of re.exive graphs over a re.exive graph G and \nmor\u00adphisms between them form a category RG-Fam(G).  4.2 Re.exive Graphs as a Category with Families \nWe de.ne a CwF structure on the category of re.exive graphs as follows. For each re.exive graph G, we \nde.ne the collection of semantic types Ty(G) to be the collection of families of re.exive graphs over \nG as de.ned in De.nition 8. Given a re.exive graph G and a family A of re.exive graphs over G, we de.ne \nthe collection of semantic terms Tm(G, A) to be the collection of morphisms from the terminal family \n(..o . GO.*, ..r . GR.*, ..o . GO.id*, ..r . GR.id*, ..r . GR.id*) of re.exive graphs over G to A, as \nin De.nition 9. Spelling this de.nition out, suppressing the contribution of the terminal family, a semantic \nterm M . Tm(G, A) is de.ned as a pair of functions (Mo, Mr):  Mo : ..o . GO. AO(.o) Mr : ..r . GR. AR(.r) \nsuch that ..o . GO. Are. (.o)(Mo(.o)) = Mr(Gre. (.o)) (9) ..r . GR. Asrc (.r)(Mr(.r)) = Mo(Gsrc (.r)) \n(10) ..r . GR. Atgt (.r)(Mr(.r)) = Mo(Gtgt (.r)) (11) For each re.exive graph morphism f : . . G, substitution \nA{f}in semantic types A and substitution M{f} in semantic terms are both de.ned by pre-composition. Comprehension \nstructure is given by the following de.nition, which can be seen as the dependent version of the cartesian \nproduct of re.exive graphs used in Section 2.2 to interpret the non-dependent kinding and typing contexts \nof System F. De.nition 10. Let G be a re.exive graph, and let A . Ty(G) be a semantic type. De.ne the \ncomprehension G.A as the following re.exive graph: (G.A)O = {(.o, ao) | .o . GO, ao . AO(.o)} (G.A)R \n= {(.r, ar) | .r . GR, ar . AR(.r)} (G.A)re. (.o, ao) = (Gre. (.o), Are. (.o)(ao)) (G.A)src (.r, ar) \n= (Gsrc (.r), Asrc (.r)(ar)) (G.A)tgt (.r, ar) = (Gtgt (.r), Atgt (.r)(ar)) Given f : . . G and M . Tm(., \nA{f}), de.ne (f, M ) : . . G.A as follows: (f, M )o(do) = (fo(do), Mo(fo(do))) (f, M )r(dr) = (fr(dr), \nMr(fr(dr))) Given f : . . G.A, de.ne f#1 : . . G and f#2 . Tm(., A{f #1}) as follows: (f#1 )o(do) = let \n(.o, ao) = fo(do) in .o (f#1)r (dr) = let (.r, ar) = fr(dr) in .r (f#2 )o(do) = let (.o, ao) = fo(do) \nin ao (f#2 )r(dr) = let (.r, ar) = fr(dr) in ar The next proposition follows by mechanical checking of \nthe requirements in De.nition 3. Proposition 1. The category of re.exive graphs has the structure of \na CwF, where the collection of semantic types Ty(G) is the collection of families of re.exive graphs \nover G, and the collection of semantic terms Tm(G, A) is the collection of morphisms from the terminal \nfamily of re.exive graphs over G to A.  4.3 Interpreting the Universe of Small Types By De.nition 6, \nthe basic structure we require to interpret the type-theoretic universe comprises semantic types U . \nTy(G) and T . Ty(G.U). So T takes elements of U to semantic types. But which semantic types (i.e., families \nof re.exive graphs) ought to be elements of U? Unlike in the case of .-types and the natural number type, \nwhere we are constrained in our interpretation up to isomorphism by the equations of the calculus (Section \n4.4), we are free to select any collection of semantic types, as long as it contains the natural number \ntype and is closed under .-types. Since the re.exive graph model is a covariant presheaf model over the \nre.exive graph category RG (Section 2.2), a plausible choice would be to use Hofmann and Streicher s \ngeneral de.ni\u00adtion of the interpretation of a type-theoretic universe in presheaf models given some set-theoretic \nuniverse U [16]. Spelling out their construction in the setting of re.exive graphs yields: UHS O (.o) \n= the set of small re.exive graphs UHS(.r) = {(A, B, R . U , Rsrc : R . AO, Rtgt : R . BO) | R A, B are \nsmall re.exive graphs} Thus, the objects of UHS are small re.exive graphs, and the rela\u00adtions are spans \nbetween small re.exive graphs. As Hofmann and Streicher show, this de.nition exactly captures the small \nfamilies of re.exive graphs: families of re.exive graphs where the sets of objects and sets of relations \nare always taken from the universe U. Put mathematically, if we write RG-Fams(G) for the subcategory \nof small families of re.exive graphs over some re.exive graph G, then we have Tm(G, U HS) ~ = Ob(RG-Fams(G)). \nHowever, despite precisely capturing smallness, Hofmann and Streicher s universe is too big for our purposes. \nWe want to lift the consequences of relational parametricity from System F to the setting of dependent \ntypes. To do this, we need to accurately replicate the salient features of the kind * of System F types \nin our interpretation of the type-theoretic universe U. Recall the de.nition of the re.exive graph * \nrepresenting the System F kind of types from Example 1. This re.exive graph has the following three properties, \nonly the .rst of which is captured by the Hofmann-Streicher universe. Firstly, the sets of objects and \nrelations are small, in the sense of belonging to the universe U of small sets. Secondly, the re.exive \nstructure of * indicates that the equality relation is distinguished amongst all possible binary relations \non sets; this is the essential identity extension property. As we saw in Example 2, re.exive graphs in \nwhich only equal objects are related can be modelled by taking the sets of objects and relations to be \nequal. Thirdly, the relations between sets are proof\u00adirrelevant: since a relation R from X to Y is a \nsubset of X \u00d7 Y , and since each pair (x, y) is either in the subset or not, there is at most one way \nthat x and y can be related. Proof-irrelevance is essential for reasoning using a relationally parametric \nmodel: we use the relational level to reason about equality at the object level, but we have nothing \nto reason about the relational level with, so proof-irrelevance is needed to make sure that equality \nat this level is trivial. This insight is formalised in Lemma 2 below, and heavily used in Section 5. \nWe note in passing that thinking along these lines motivates the formulation of 8-re.exive graphs (a.k.a., \nre.exive globular sets), where there is always another level to reason about the one below. The three \nproperties just discussed motivate this de.nition: De.nition 11. Let G be a re.exive graph. A family \nA of re.exive graphs over G is: 1. small if, for all .o . GO, AO(.o) . U and for all .r . GR, AR(.r) \n. U ; 2. discrete if, for all .o . GO, the re.exive graph on the left of the following diagram is isomorphic \nto a re.exive graph generated by a set (on the right of the diagram): ~ _ - AO(.o) = X Asrc )) Are. (.o \n ) Atgt (Gre. (.o)) id id id(Gre. (.o ~ _ - AR(Gre. (.o)) = X 3. proof-irrelevant if, for all .r . GR, \n(Asrc (.r), Atgt (.r)) : AR(.r) . AO(Gsrc (.r)) \u00d7 AO(Gtgt (.r)) is injective. We write RG-Famsdpi(G) \nfor the full subcategory of RG-Fam(G) consisting of small, discrete, proof-irrelevant re.exive graphs. \n In parts (2) and (3) of this de.nition, we have chosen to enforce the conditions of discreteness and \nproof-irrelevance only up to isomorphism. This laxness will be important when showing that the interpretation \nof the type-theoretic universe of small types is closed under dependent products in Section 4.4. De.nition \n11 is justi.ed by the following representation result: Proposition 2. Let G be a re.exive graph. There \nis an equivalence of categories: SetRG (G, *) . RG-Famsdpi(G). Proposition 2 shows that the re.exive \ngraph model of depen\u00addent types can internally represent the semantic System F types and terms, up to \nisomorphism. This suggests that we can use the re.ex\u00adive graph * as the basis of our interpretation of \nU. However, the equivalence of categories in Proposition 2 is too weak to soundly model the type equalities \nwe required for the universe decoder type operator T in Figure 4 (speci.cally, the semantic counterparts \nof these equalities in De.nitions 6 and 7). We now remedy this by re.ning the de.nition of our re.exive \ngraph * to provide an inter\u00adpretation for U with the required properties. A Small, Discrete, Proof Irrelevant \nUniverse For any re.exive graph G we de.ne semantic types U . Ty(G) and T . Ty(G.U ): UO(.o) = the set \nof small discrete re.exive graphs UR(.r) = {(A, B, R . U , Rsrc : R . AO, Rtgt : R . BO | A, B are small \ndiscrete re.exive graphs, (Rsrc , Rtgt ) : R . AO \u00d7 BO is injective} Ure. (.o)(A) = (A, A, AR, Asrc , \nAtgt ) Usrc (.r)(A, B, R, Rsrc , Rtgt ) = A Utgt (.r)(A, B, R, Rsrc , Rtgt ) = B If A is a discrete re.exive \ngraph, then (Asrc , Atgt ) : AR . AO \u00d7 AO is necessarily injective, so the de.nition of Ure. makes sense. \nWe de.ne the semantic types T . Ty(G.U ) as follows: TO(.o, A) = AO TR(.r, (A, B, R, Rsrc , Rtgt )) = \nR Tre. (.o, A) = Are. Tsrc (.r, (A, B, R, Rsrc , Rtgt )) = Rsrc Ttgt (.r, (A, B, R, Rsrc , Rtgt )) = \nRtgt The de.nitions of U and T we have just presented ful.l part (a) of De.nition 6. The following lemma \nstates that we have successfully internalised the subcategories RG-Famsdpi(G). Lemma 1. For any M . Tm(G, \nU ), the family T{M} is small, discrete, and proof-irrelevant and this mapping forms a bijection of sets: \nT {-} : Tm(G, U ) ~ = Ob(RG-Famsdpi(G)), natural in G. The fact that this lemma gives us a bijection \nis useful because it means that to show that the universe U is closed under some semantic type former, \nwe need only show that the semantic type former is closed under the condition of being a small, discrete, \nand proof-irrelevant family of re.exive graphs. Below, we de.ne the small counterparts of dependent products \nand the natural number type parts (b) and (c) of De.nition 6 using the right-to-left direction of this \nbijection to obtain a representation in U of a small, discrete, proof-irrelevant family, which we write \nas repr : Ob(RG-Famsdpi(G)) . Tm(G, U ). We note the following crucial property of proof-irrelevant fam\u00adilies. \nBy proof-irrelevance, there is exactly one way that any two object-level elements can be related. Therefore, \nfor any two terms of proof-irrelevant type, if the object-level interpretations are equal then so are \nthe relation-level interpretations. This lemma plays an important role in showing that the interpretation \nof the type\u00adtheoretic universe we have de.ned is closed under dependent prod\u00aducts (Lemma 3, below), and \nalso in the applications of relational parametricity that we describe in Section 5. Lemma 2. Let G be \na re.exive graph and let A . Ty(G) be a proof-irrelevant family of re.exive graphs. For any pair of semantic \nterms M, N . Tm(G, A), Mo = No implies Mr = Nr. Proof. Since M and N are semantic terms, and Mo = No, \nwe have, for all .r . GR, Asrc (.r)(Mr(.r)) = Mo(Gsrc (.r)) = No(Gsrc (.r)) = Asrc (.r)(Nr(.r)). Similarly, \nwe have Atgt (.r)(Mr(.r)) = Atgt (.r)(Nr(.r)), for all .r . GR. By proof-irrelevance of A, the function \n(Asrc (.r), Atgt (.r)) formed by pairing is injective, hence Mr = Nr.  4.4 Interpreting Dependent Products \nand Natural Numbers To complete our re.exive graph model of type theory, it remains to provide the interpretations \nof .-types and the natural number type. Due to the \u00df.-rules we have chosen for .-types we actually have \nno choice, up to isomorphism, in how to interpret these types. We spell out the details here to demonstrate \nthe way that type constructors are interpreted in the re.exive graph model. Dependent Products The interpretation \nof .-types directly gen\u00aderalises the interpretation of System F .-types that we presented in Section \n2.1, the additional complication coming from the fact that we need to consider relation transformers \nrather than just re\u00adlation preservation (see also Atkey s relationally parametric model of System F. \n[2], which also deals with relation transformers). In the interpretation of .-types, the object level \nconsists of a pair of an object-level function and a relation-level function, connected by three coherence \naxioms, similar to the de.nition of semantic terms in Section 4.2. The relation level consists of a pair \nof object-level interpretations and a relation transformer relating them. Written out in full, the de.nition \nis a little daunting, remember that, up to iso\u00admorphism, we are essentially forced into this de.nition. \nDe.nition 12. Let G be a re.exive graph, and A . Ty(G) and B . Ty(G.A) be semantic types in the re.exive \ngraph CwF. De.ne the semantic type .AB . Ty(G) as follows: (.AB)O(.o) = { (fo, fr) | fo : .ao . AO(.o). \nBO(.o, ao), fr : .ar . AR(Gre. (.o)). BR(Gre. (.o), ar), .ar . AR(Gre. (.o)). Bsrc (Gre. (.o), ar)(fr \nar) =  fo(Asrc (Gre. (.o))(ar)), .ar . AR(Gre. (.o)). Btgt (Gre. (.o), ar)(fr ar) = fo(Atgt (Gre. (.o))(ar)), \n.ao . AO(.o). Bre. (.o, ao)(fo ao) = fr(Are. (.o)(ao)) } (.AB)R(.r) = { ((fsrc ), (f tgt o , f r src \no , f r tgt ), r) | (fsrc , f src o r ) . (.AB)O(Gsrc (.r)), (ftgt , f tgt ) . (.AB)O(Gtgt (.r)), o r \n r : .ar . AR(.r). BR(.r, ar), .ar . AR(.r). Bsrc (.r, ar)(r ar) = fo src (Asrc (.r)(ar)), .ar . AR(.r). \nBtgt (.r, ar)(r ar) = fo tgt (Atgt (.r)(ar)) } (.AB)re. (.o)(fo, fr) = ((fo, fr), (fo, fr), fr) (.AB)src \n(.r)(fsrc , f tgt , r) = fsrc )(f src , f tgt , r) = ftgt (.AB)tgt (.r Given a semantic term M . Tm(G.A, \nB), we de.ne (.M) . Tm(G, .AB) as follows: (.M)o(.o) = (.ao. Mo(.o, ao), .ar. Mr(Gre. (.o), ar)) (.M)r(.r) \n= ((.M)o(Gsrc (.r)), (.M)o(Gtgt (.r)), .ar. Mr(.r, ar))  and, conversely, given N . Tm(G, .AB) , we \nde.ne (.-1N) . Tm(G.A, B) as follows: (.-1N)o(.o, ao) = let (fo, fr) = No(.o) in fo(ao) (.-1N)r(.r, ar) \n= let (fsrc , f tgt , r) = Nr(.r) in r(ar) Proposition 3. The re.exive graph CwF supports dependent prod\u00aducts \n(De.nition 4), using the structure de.ned in De.nition 12. If the families A . Ty(G) and B . Ty(G.A) \nare small, then so is the family .AB . Ty(G). This is a consequence of assuming that the set-theoretic \nuniverse U is a universe of small sets, and so is closed under dependent products and tupling. It is \nstraightforward to check that for closure under discreteness and proof-irrelevance, only the family B \nneed be discrete and proof-irrelevant: Lemma 3. Let A . Ty(G) and B . Ty(G.A). If B is discrete and proof-irrelevant, \nthen so is .AB . Ty(G). Proposition 4. Part (c) of De.nition 6 is ful.lled by the de.nition pM N = repr \n(.(T {M})(T {N})). If we further assume that our collection of small sets U is closed under large products, \nthen we also have an interpretation of an impredicative type-theoretic universe. By Lemma 3, only the \ncodomain type B need be discrete and proof-irrelevant for .AB to be discrete and proof-irrelevant. Therefore, \nif U is closed under large products, then U is closed under impredicative quanti.cation. Proposition \n5. Under the assumption of an impredicative universe U, De.nition 7 is ful.lled by pAM = repr (.A(T {M})). \nThe Natural Number Type For each re.exive graph G, we de.ne a semantic type Nat . Ty(G) as follows, reusing \nthe de.nition of the re.exive graph of natural numbers from Example 2: Natre. (.o)(n) = nNatO(.o) = N \nNatsrc (.r)(n) = n NatR(.r) = N Nattgt (.r)(n) = n Since the family Nat does not actually depend on its \nargument, this de.nition is trivially natural in G. The zero and successor semantic terms zero . Tm(G, \nNat) and succ . Tm(G.Nat, Nat) are de.ned using the corresponding structure of the natural numbers: zero \no(.o) = 0 succo(.o, n) = n + 1 zero r(.r) = 0 succr(.r, n) = n + 1 It is almost immediate that these \nare well-de.ned semantic terms, given the trivial structure of the semantic type Nat. Likewise, naturality \nin G is trivial. The natural number recursor Nrec is given, for A . Ty(G.Nat), Mz G . Tm(G, A{zero }), \nand M s . Tm(G.Nat.A, A{wkNat p. Nat G.Nat succ . p}), by recursion on the natural number argument: A \n(NrecA(Mz, M s))o(.o, 0) = Mo z(.o) (NrecA(Mz, M s))r(.r, 0) = Mr z(.r) (NrecA(Mz, M s))o(.o, n + 1) \n= Mo s(.o, n, (NrecA(Mz, M s))o(.o, n)) (NrecA(Mz, M s))r(.r, n + 1) = Mr s(.r, n, (NrecA(Mz, M s))r(.r, \nn)) Equations (5) and (6) specifying the interaction between Nrec and zero and succ hold almost by de.nition. \nNaturality in G is proved by induction on the natural number argument. Proposition 6. The CwF formed \nfrom the category of re.exive graphs supports natural numbers (De.nition 5). Moreover, the fam\u00adilies \nNat . Ty(G) are small, discrete and proof irrelevant, so part (b) of De.nition 6 is ful.lled by nat = \nrepr (Nat).  4.5 Main Theorem By the results of the preceding subsections, we have shown that: Theorem \n1. The category of re.exive graphs can be given the structure of a CwF that supports dependent products \nand natural numbers. Assuming the existence of a universe U of small sets, the category of re.exive graphs \nsupports a predicative universe closed under natural numbers and dependent products, and if U is closed \nunder large products then the CwF supports an impredicative uni\u00adverse closed under natural numbers and \ndependent products. As we argued in the paragraph before De.nition 11, our inter\u00adpretation of the type-theoretic \nuniverse U supports the identity ex\u00adtension property we identi.ed in Section 2.1 as crucial for relation\u00adally \nparametric models. Thus, we are justi.ed in referring to the model we have constructed here as relationally \nparametric. 5. Consequences of Parametricity Having built our parametric model of dependent type theory, \nwe now investigate some of the consequences of our construction. Our careful construction of the interpretation \nof the type-theoretic uni\u00adverse U as capturing the small, discrete, and proof-irrelevant fam\u00adilies now \nbears fruit: we recover many of the interesting conse\u00adquences of relationally parametricity that have \nbeen observed in the non-dependently typed settings of System F and System F.. As a practical matter, \ncalculating directly within the model we have constructed in the previous section is complicated by the \nprojection-based presentation of relational interpretations forced by the re.exive graph formalism. We \ntherefore use the following notational shorthands when reasoning within the model: 1. If A . Ty(G) is \na proof-irrelevant family of re.exive graphs, we write (a, a 1) . AR(.r) if there exists ar . AR(.r) \nsuch that Asrc (.r)(ar) = a and Asrc (.r)(ar) = a 1. By proof\u00adirrelevance the pair (a, a 1) completely \ndetermines ar if it exists. 2. If f . (.AB)O(.o), we identify f with its .rst component, so we can treat \nit as a function .ao . AO(.o). BO(.o, ao). Sim\u00adilarly, if f . (.AB)R(.r) we identify f with its relation \ntrans\u00adformer component, which has type .ar . AR(.r). BR(.r, ar). 3. We will be liberal in confusing \nthe curried and uncurried ver\u00adsions of the semantic interpretations of inhabitants of dependent products. \nThis decreases the number of parentheses required.  We .rst prove a simple free theorem, in order to \ndemonstrate reasoning within the model, and the utility of the construction of our interpretation of \nthe type-theoretic universe as only containing proof-irrelevant families. We then go on to adapt Atkey \ns proof of the existence of higher-kinded initial algebras [2] to the impred\u00adicative dependently typed \nsetting. This proof also relies on proof\u00adirrelevance, and also makes essential use of the discreteness \nof members of U in Lemma 7. 5.1 A Free Theorem We begin by proving a simple free theorem in the style \nof Wadler [35]. This example shows that the ordinary consequences of rela\u00adtional parametricity are preserved \nwhen moving from polymorphic calculi to the richer world of dependent type theory with a universe. Theorem \n2. If G f M : .a : U. Ta . Ta then, for any G f X : U, G f Y : U, G f f : TX . TY , and G f x : TX, the \nequation G f f (M X x) = M Y (f x) : TY is sound when interpreted in the models constructed in Section \n4. Proof. Unwinding the de.nitions, we see that we must establish the following two equations, in which \nwe have reused the letters G, M, X, Y , f and x to stand for the semantic interpretations of the corresponding \nsyntactic objects, we have applied currying where convenient, and we have identi.ed the small types X \nand Y with their decodings via T:  ..o . GO. fo(.o, Mo(.o , Xo(.o), xo(.o))) = Mo(.o, Yo(.o), fo(.o, \nxo(.o))) ..r . GR. fr(.r, Mr(.r, Xr(.r), xr(.r))) = Mr(.r, Yr(.r), fr(.r, xr(.r))) The interpretation \nof the type TY is a proof-irrelevant family, so by Lemma 2 we only need to prove the .rst of the above \nequations, from which the second necessarily follows. For a given .o, we use the relational interpretation \nMr of M , instantiated at Gre. (.o): Mr(Gre. (.o), -, -) : .R . UR(Gre. (.o)). TR(Gre. (.o), R) . TR(Gre. \n(.o), R) Again unwinding the de.nitions, and using the fact that Mr is con\u00adnected to Mo via the equations \nfor sources and targets of relations in (10) and (11), we have the following property: .A, A1 . UO(.o), \nR . AO \u00d7 A1 1) . R. O, (a, a (Mo(.o, A, a), Mo(.o, A1 , a 1)) . R We instantiate A and A1 with the small \ndiscrete re.exive graphs X and Y , respectively, at .o. We take R = {(x, y) | fo(.o, x) = y}. Then (xo(.o), \nfo(.o, xo(.o))) . R, so (Mo(.o, XO(.o), xo(.o)), Mo(.o, YO(.o), fo(.o, xo(.o)))) . R, and the desired \nequation holds thus by de.nition of R.  5.2 Categories of Indexed Types and Indexed Functors We now \nstart on our proof that the relationally parametric model that we have constructed supports initial algebras \nfor all indexed functors. To this end, we .rst de.ne the appropriate category of indexed small types \nwhere the carriers of indexed initial algebras reside. The construction of our category of indexed small \ntypes is carried out with respect to some .xed context G. For each judge\u00adment G f X type, we de.ne the \ncategory of X-indexed small types to have as objects terms G f A : X . U, and de.ne morphisms between \nobjects G f A : X . U and G f B : X . U to be terms G f f : .x:X. T(A x) . T(B x). Identities and composition \nare de.ned in the obvious way. Composition is associative due to the .-rule for dependent products. We \nwrite A . B to stand for the type .x:X. T(A x) . T(B x). We will also use the type G, a : X . U, b : \nX . U f .x:X. T(a x) . T(b x) type, i.e., the type of mor\u00adphisms where the domain and codomain are abstracted \nas vari\u00adables. As a notational convenience, we write morph as short\u00adhand for this type, and similarly \nfor its semantic interpretation morph . Ty(G..X U..X U ). Morphisms in the category of X-indexed small \ntypes induce re\u00adlations between their domain and codomain objects, as given by the following de.nition. \nThis de.nition is the X-indexed generalisa\u00adtion of the functional relation from the free theorem in Section \n5.1. De.nition 13. Let G f A : X . U and G f B : X . U. Given a morphism G f f : A . B, we de.ne (f ), \ncalled the graph relation of f, to be the following element of (.X U )R: ..r . GR. (Ao(Gsrc (.r)), Bo(Gtgt \n(.r)), .xr . XR(.r). (Ao(Gsrc (.r))(Xsrc (.r)(xr)), Bo(Gtgt (.r))(Xtgt (.r)(xr)), {(a, b) | (fo(Gsrc \n(.r), Xsrc (.r)(xr), a), b) . Br(.r)(xr)})) The following lemma is a direct consequence of De.nition \n13. Lemma 4. Let G f A : X . U, G f B : X . U, and G f f : A . B. Then for all .o . GO, (fo(.o), id) \n. morphR(Gre. (.o), (f)(Gre. (.o)), Br(Gre. (.o))). Indexed Functors X-indexed initial algebras are de.ned \nin terms of X-indexed functors, which we now de.ne. An X-indexed func\u00adtor is a pair (F, Fmap) of terms \nG f F : (X . U) . (X . U) G f Fmap : .A, B:X . U. (A . B) . (F A . F B) where Fmap preserves the identities \nand composition of the cate\u00adgory of X-indexed small types when interpretated in the re.exive graph model. \nIndexed functors interact nicely with graph relations, as captured by the following Graph Lemma: Lemma \n5. Let G f f : A . B. For all .o . GO and xr . XR(Gre. (.o)), if (a, b) . Fr(Gre. (.o), (f)(Gre. (.o)))(xr) \nthen (a, b) . (Fmap A B f )(Gre. (.o))(xr).  5.3 The Category of F -algebras For an X-indexed functor \n(F, Fmap), initial F -algebras are initial objects in the category of F -algebras, which we now de.ne. \nFix an X-indexed functor (F, Fmap). The objects of the category of F -algebras are pairs of terms (A, \nkA) where G f A : X . U and G f kA : F A . A. Morphisms between (A, kA) and (B, kB) are terms G f h : \nA . B such that, if . is the composition of the category of X-indexed small types, then G f kB . Fmap \nA B h = h . kA : F A . B An initial F -algebra is an initial object in the category of F \u00adalgebras, i.e., \nan F -algebra (\u00b5F, in) such that there exists a term G f fold : .A : X . U. (F A . A) . (\u00b5F . A) such \nthat the following two equations hold. The .rst equation states that fold always yields F -algebra morphisms: \nG f A : X . U G f kA : F A . A G f x : X G f M : T(\u00b5F x) G f fold A kA x (in x M ) = kA x (Fmap \u00b5F A \n(fold A kA) x M : T(A x) The second equation states that the F -algebra morphisms generated by fold are \nunique, as required by initiality: G f A : X . U G f kA : F A . A G f h : \u00b5F . A h is an F -algebra morphism \n G f h = fold A kA : \u00b5F . A Morphisms between F -algebras have the following relational property in terms \nof their graph relations. This property will be useful when we prove that initial F -algebras always \nexist. Lemma 6. Let (A, kA) and (B, kB ) be F -algebras. If h is an F \u00adalgebra morphism from (A, kA) \nto (B, kB ), then for all .o . GO, (ko A(.o), ko B(.o)) . morphR(Gre. (.o), Fr(Gre. (.o), (h)(Gre. (.o))), \n(h)(Gre. (.o)))  5.4 Construction of Initial F -algebras Having de.ned all the necessary background, \nwe now show that, within the impredicative version of our relationally para\u00admetric model of dependent \ntypes, initial F -algebras exist for all X-indexed functors (F, Fmap). Given an X-indexed functor  (F, \nFmap), we make the following de.nitions: \u00b5F = .x : X. .A : X . U. (F A . A) . T(A x) fold = .A:X . U. \n.kA:(F A . A). .x:X. .e:T(\u00b5F x). e A kA in = .x : X. .e : T(F (\u00b5F )x). .A : X . U. .kA : (F A . A). kA \nx (Fmap \u00b5F A (fold A kA) x e) Note that, up to notational changes induced by our presentation of the \nuniverse U, and the more general setting, these de.nitions are identical to those given by Atkey [2] \nfor constructing higher-kinded initial algebras in a relationally parametric model of System F.. The \nproof that these de.nitions actually give an initial F \u00adalgebra follows from two applications of the \nfollowing lemma: Lemma 7. The following equation holds when interpreted in the re.exive graph model: \nG f A : X . U G f kA : F A . A G f B : X . U G f kB : F B . B G f h : A . B h is an F -algebra homomorphism \nG f x : X G f M : T(\u00b5F x) G f h x (M A kA) = M B kB : T(B x) Proof. By Lemma 2 we need only prove the \nobject-level part of the equation. Given .o . GO, we instantiate Mr with Gre. (.o), the graph relation \n(h)(Gre. (.o)), and the pair (ko A(.o), ko B(.o)), by Lemma 6, to obtain (Mo(.o, Ao(.o), ko A(.o)), Mo(.o, \nBo(.o), ko B (.o))) . (h)(Gre. (.o))(Xre. (.o)(xo(.o))) Unfolding the graph relation, this statement \nis equivalent to: (ho(.o, xo(.o), Mo(.o, Ao(.o), ko A(.o))), Mo(.o, Bo(.o), ko B(.o))) . Br(Gre. (.o), \nXre. (.o)(xo(.o))) Now, by the identity extension property that is built into the re.ex\u00adive graph model, \nthe relation Br(Gre. (.o), Xre. (.o)(xo(.o))) is equal to Ure. (.o, xo(.o))(Bo(.o, xo(.o))). By the discreteness \nof elements of the universe U, this relation is, up to isomorphism, the equality relation on the small \nset Bo(.o, xo(.o)). We thus have ho(.o, xo(.o), Mo(.o, Ao(.o), ko A(.o))) = Mo(.o, Bo(.o), ko B (.o)) \nWe can now state the following key property of our model. Theorem 3. Any X-indexed functor (F, Fmap) \nhas an initial F \u00ad algebra. Proof. We must verify that the two equations in Section 5.3 hold. The .rst \nequation, stating that fold always generates F -algebra morphisms, follows directly by using the \u00df-reduction \nrules of the type theory. The second equation requires relational parametric\u00adity. Expanding the de.nitions, \nwe see that we need to prove that h x M = M A kA. By Lemma 7, together with the fact that h is an F -algebra \nmorphism, we have that h x (M \u00b5F in) = M A kA . Using Lemma 7 again, this time with an arbitrary F -algebra \n(B, kB), and setting h = fold B kB yields M \u00b5F in B kB = M B kB . Extensionality therefore gives M \u00b5F \nin = M, and thus h x M = M AkA, as required. Despite the considerably more general setting, the above \nproof is almost identical to that given by Atkey for higher-kinded initial algebras in a relationally \nparametric model of System F.. The proofs of other results presented by Atkey e.g., the existence of \nan extensional equality type and existentials also translate to the impredicative dependently typed \nsetting with little change. 6. Conclusion and Directions for Future Work We have presented a parametric \nmodel of dependent types that has two signi.cant features. First, our model is based on re.exive graphs, \nwhich naturally generalise existing relationally parametric models of System F: just as the construction \nof a parametric model for System F can be seen as moving from a model based on Set to a model based on \nSetRG , so our parametric model of dependent types can be seen as moving from a .bration p : Fam(Set) \n. Set to a .bration p RG : Fam(Set)RG . SetRG . Second, our model supports the derivation of key results, \nsuch as the existence of initial algebras. We believe ours is the .rst parametric model, syntactic or \nsemantic, to establish the dependently-typed generalisation of this key property of relationally parametric \nmodels of System F. The most exciting avenue for future work is in comparing the re.exive graph model \nwe have presented here with the strikingly similar groupoid and 8-groupoid models of type theory [32]. \nRe\u00ad.exive graphs can be seen as categories without composition , whereas groupoids are categories with \ninverses. In light of the many useful results derivable from relational parametricity, further in\u00advestigation \nof the reduced amount of structure of re.exive graphs looks promising (Robinson has already investigated \nParametric\u00adity as Isomorphism : parametricity where types are interpreted as groupoids [29]). In particular, \nVoevodsky s univalence axiom states that isomorphic types are actually equal. But Reynolds relational \nparametricity reveals that often types need only be related, not iso\u00admorphic, for them to be indistinguishable \nto programs. Is there a Reynoldsian version of univalence waiting to be formulated? References [1] R. \nAtkey. A Deep Embedding of Parametric Polymorphism in Coq. Proc., Workshop on Mechanising Metatheory, \n2009. [2] R. Atkey. Relational Parametricity for Higher Kinds. Proc., Computer Science Logic, pp. 46 \n61, 2012. [3] R. Atkey, P. Johann, and A. Kennedy. Abstraction and Invariance for Algebraically Indexed \nTypes. Proc., Principles of Programming Languages, pp. 87 100, 2013. [4] E. S. Bainbridge, P. J. Freyd, \nA. Scedrov, and P. J. Scott. Functorial Polymorphism. Theoretical Computer Science 70(1), pp. 35 64, \n1990. [5] J.-P. Bernardy, P. Jansson, and R. Paterson. Proofs for Free -Para\u00admetricity for Dependent \nTypes. Journal of Functional Programming 22(2), pp. 107 152, 2012. [6] A. Bove, P. Dybjer, and U. Norell. \nA Brief Overview of Agda A Functional Language with Dependent Types. Proc., Theorem Proving in Higher \nOrder Logics, 2009. [7] J. Cheney and R. Hinze. A lightweight implementation of generics and dynamics. \nProc., Workshop on Haskell, pp. 90 104, 2002. [8] A. Chlipala. Parametric higher-order abstract syntax \nfor mechanized semantics. Proc., International Conference on Functional Program\u00adming, pp. 143 156, 2008. \n[9] The Coq Development Team. The Coq proof assistant reference man\u00adual. LogiCal Project, Version 8.0, \n2004. [10] T. Coquand and G. P. Huet. The Calculus of Constructions. Informa\u00adtion and Computation 76(2/3), \npp. 95 120, 1988. [11] B. Dunphy and U. S. Reddy. Parametric Limits. Proc., Logic in Com\u00adputer Science, \npp. 242 251, 2004. [12] P. Dybjer. Internal Type Theory. Proc., Types for Proofs and Programs, pp. 120 \n134, 1996. [13] R. Hasegawa. Categorical Data Types in Parametric Polymorphism. Mathematical Structures \nin Computer Science 4(1), pp. 71 109, 1994. [14] R. Hasegawa. Relational Limits in General Polymorphism. \nPublica\u00adtions of the Research Institute for Mathematical Sciences 30, pp. 535 576, 1994.  [15] M. Hofmann. \nSyntax and Semantics of Dependent Types. In Semantics and Logics of Computation, Cambridge University \nPress, pp. 79 130, 1997. [16] M. Hofmann and T. Streicher. Lifting Grothendieck Universes. Un\u00adpublished \nmanuscript. 199? [17] B. Jacobs. Categorical Logic and Type Theory. Elsevier, 1999. [18] P. Johann. Short \nCut Fusion: Proved and Improved. Proc., Semantics, Application, and Implementation of Program Generation, \npp. 47 71, 2001. [19] N. Krishnaswami and D. Dreyer. Internalizing Relational Parametric\u00adity in the Extensional \nCalculus of Constructions. Proc., Computer Sci\u00adence Logic, 2013. [20] S. Mac Lane. Categories for the \nWorking Mathematician, Second Edition. Springer-Verlag, 1998. [21] H. G. Mairson. Outline of a Proof \nTheory of Parametricity. Proc., Functional Programming Languages and Computer Architecture, pp. 313 327, \n1991. [22] P. Martin-L \u00a8 of. Intuitionistic Type Theory. Bibliopolis, 1984. [23] A. Nanevski, A. Banerjee, \nD. Garg. Dependent Type Theory for Veri\u00ad.cation of Information Flow and Access Control Policies. ACM \nTrans\u00adactions on Programming Languages and Systems 35(2), pp. 6:1 6:41, 2013. [24] A. M. Pitts. Parametric \nPolymorphism and Operational Equivalence. Mathematical Structures in Computer Science 10, pp. 321 359, \n2000. [25] G. D. Plotkin. Lambda De.nability and Logical Relations. Technical Report, University of Edinburgh, \n1973. [26] G. D. Plotkin and M. Abadi. A Logic for Parametric Polymorphism. Proc., Typed Lambda Calculi \nand Applications, pp. 361 375, 1993. [27] J. C. Reynolds. Polymorphism is Not Set-Theoretic. Proc., Semantics \nof Data Types, pp. 145 156, 1984. [28] J. C. Reynolds. Types, Abstraction and Parametric Polymorphism. \nInformation Processing 83, pp. 513 523, 1983. [29] E. Robinson. Parametricity as Isomorphism. Theoretical \nComputer Science 136, pp. 163 181, 1994. [30] E. Robinson and G. Rosolini. Re.exive Graphs and Parametric \nPoly\u00admorphism. Proc., Logic in Computer Science, pp. 364 371, 1994. [31] I. Takeuti. The Theory of Parametricity \nin the Lambda Cube. Technical Report 1217, Kyoto University, 2001. [32] The Univalent Foundations Program. \nHomotopy Type Theory. Institute for Advanced Study, 2013. [33] D. Vytiniotis and S. Weirich Parametricity, \nType Equality, and Higher-Order Polymorphism. Journal of Functional Programming 20(2), pp. 175 201, 2010. \n[34] P. Wadler. The Girard-Reynolds Isomorphism (second edition). Theo\u00adretical Computer Science 375(1-3), \npp. 201 226, 2007. [35] P. Wadler. Theorems for Free! Proc., Functional Programming Lan\u00adguages and Computer \nArchitecture, pp. 347 359, 1989.    \n\t\t\t", "proc_id": "2535838", "abstract": "<p>Reynolds' theory of relational parametricity captures the invariance of polymorphically typed programs under change of data representation. Reynolds' original work exploited the typing discipline of the polymorphically typed lambda-calculus System F, but there is now considerable interest in extending relational parametricity to type systems that are richer and more expressive than that of System F.</p> <p>This paper constructs parametric models of predicative and impredicative dependent type theory. The significance of our models is twofold. Firstly, in the impredicative variant we are able to deduce the existence of initial algebras for all <i>indexed=</i>functors. To our knowledge, ours is the first account of parametricity for dependent types that is able to lift the useful deduction of the existence of initial algebras in parametric models of System F to the dependently typed setting. Secondly, our models offer conceptual clarity by uniformly expressing relational parametricity for dependent types in terms of reflexive graphs, which allows us to unify the interpretations of types and kinds, instead of taking the relational interpretation of types as a primitive notion. Expressing our model in terms of reflexive graphs ensures that it has canonical choices for the interpretations of the standard type constructors of dependent type theory, except for the interpretation of the universe of small types, where we formulate a refined interpretation tailored for relational parametricity. Moreover, our reflexive graph model opens the door to generalisations of relational parametricity, for example to higher-dimensional relational parametricity.</p>", "authors": [{"name": "Robert Atkey", "author_profile_id": "81436601799", "affiliation": ", , United Kingdom", "person_id": "P4383890", "email_address": "bob.atkey@gmail.com", "orcid_id": ""}, {"name": "Neil Ghani", "author_profile_id": "81100427276", "affiliation": "University of Strathclyde, Glasgow, United Kingdom", "person_id": "P4383891", "email_address": "neil.ghani@strath.ac.uk", "orcid_id": ""}, {"name": "Patricia Johann", "author_profile_id": "81100058482", "affiliation": "Appalachian State University, Boone, NC, USA", "person_id": "P4383892", "email_address": "johannp@appstate.edu", "orcid_id": ""}], "doi_number": "10.1145/2535838.2535852", "year": "2014", "article_id": "2535852", "conference": "POPL", "title": "A relationally parametric model of dependent type theory", "url": "http://dl.acm.org/citation.cfm?id=2535852"}