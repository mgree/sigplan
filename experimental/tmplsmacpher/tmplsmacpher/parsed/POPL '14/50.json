{"article_publication_date": "01-08-2014", "fulltext": "\n Abstract E.ects and Proof-Relevant Logical Relations Nick Benton Martin Hofmann Vivek Nigam Microsoft \nResearch, Cambridge, UK LMU, Munich, Germany UFPB, Jo ao Pessoa, Brazil nick@microsoft.com hofmann@i..lmu.de \nvivek.nigam@gmail.com Abstract We give a denotational semantics for a region-based e.ect sys\u00adtem that \nsupports type abstraction in the sense that only externally visible e.ects need to be tracked: non-observable \ninternal modi.\u00adcations, such as the reorganisation of a search tree or lazy initial\u00adisation, can count \nas pure or read only . This .ctional purity allows clients of a module to validate soundly more e.ect-based \nprogram equivalences than would be possible with previous seman\u00adtics. Our semantics uses a novel variant \nof logical relations that maps types not merely to partial equivalence relations on values, as is commonly \ndone, but rather to a proof-relevant generalisation thereof, namely setoids. The objects of a setoid \nestablish that val\u00adues inhabit semantic types, whilst its morphisms are understood as proofs of semantic \nequivalence. The transition to proof-relevance solves two awkward problems caused by na\u00a8ive use of existential \nquanti.cation in Kripke logical relations, namely failure of admis\u00adsibility and spurious functional dependencies. \nCategories and Subject Descriptors D.3.3 [Programming Lan\u00adguages]: Language Constructs and Features \nDynamic storage management; F.3.2 [Logic and Meanings of Programs]: Seman\u00adtics of Programming Languages \n Denotational semantics, Pro\u00adgram analysis; F.3.2 [Logic and Meanings of Programs]: Studies of Program \nConstructs Type structure General Terms Languages, Theory Keywords Type and e.ect systems, region analysis, \nlogical rela\u00adtions, parametricity, program transformation 1. Introduction The last decade has witnessed \nsigni.cant progress in modelling and reasoning about the tricky combination of e.ects and higher\u00adorder \nlanguage features (.rst-class functions, modules, classes). The object of study may be ML-like, Java-like, \nor assembly-like, but the common source of trickiness is the way e.ectful opera\u00adtions may be partially \nencapsulated behind higher-order abstrac\u00adtions. Several closely-related problems have been addressed \nusing common techniques that include separation, Kripke logical rela\u00adtions and step-indexing. One is \nto devise models and reasoning principles for establishing contextual (in)equivalences [18, 36]. A second \nis to establish equivalence between high-level and low-level Permission to make digital or hard copies \nof all or part of this work for personal or classroom use is granted without fee provided that copies \nare not made or distributed for pro.t or commercial advantage and that copies bear this notice and the \nfull citation on the .rst page. Copyrights for components of this work owned by others than ACM must \nbe honored. Abstracting with credit is permitted. To copy otherwise, or republish, to post on servers \nor to redistribute to lists, requires prior speci.c permission and/or a fee. Request permissions from \npermissions@acm.org. POPL 14, January 22 24, 2014, San Diego, CA, USA. Copyright &#38;#169;c2014 ACM \n978-1-4503-2544-8/14/01. . . $15.00. http://dx.doi.org/10.1145/2535838.2535869 code fragments, e.g., \nfor compiler correctness [5, 23]. A third is to de.ne Hoare-style logics for showing programs satisfy \nassertions [38]. A fourth, which we address here, is to study type systems and analyses that can characterize \nparticular classes of behavior (such as purity) and be used to justify equivalences more generically. \nE.ect systems [22] re.ne conventional types by adding infor\u00ad mation capturing an upper bound on the e.ects \nexpressions may have. Several recent papers [3, 6, 7, 26, 41], have explored the semantics of e.ect systems, \nwith a focus not merely on showing correctness of analyses, but on providing a rigorous account of the \nconditions under which e.ect-dependent optimizations and refac\u00adtorings are sound. An example is the commutation \nof stateful com\u00adputations M and N, subject to the condition that the sets of storage locations potentially \nwritten by M and N are disjoint, and that nei\u00adther potentially reads a location that the other writes. \nWe seek interpretations of e.ect-re.ned types (over an unre\u00ad.ned model) that can justify such equivalences. \nIndeed, it is the interpretations, rather than rules for assigning such types to terms, that we regard \nas primary. Types provide a common interface lan\u00adguage that can be used by clients in modular reasoning \nabout rewrites; types can be assigned to particular terms by a mixture of more or less sophisticated \ninference systems, or by deeper semantic reasoning about particular implementations. A key notion in \nreasoning about encapsulated state is that of separation: invariants depending upon mutually disjoint \nparts of the store. Intuitively, if each function with direct access to a part preserves the corresponding \ninvariant, then all the invariants will be preserved by any composition of functions. Disjointness is \nna\u00a8ively understood in terms of sets of heap locations. A memory alloca\u00adtor, for example, guarantees \nthat its own private data structures, memory previously handed out to clients, and any freshly-allocated \nblock inhabit mutually disjoint sets of locations. Since the introduc\u00adtion of fractional permissions, \nwork on separation logic often goes beyond this simple model, introducing resources that are combined \nwith a separating conjunction, but which are not literally interpreted as predicates on disjoint locations. \nResearch on domain-speci.c [28], .ctional [17, 25], subjective [30], or super.cial [29] sep\u00ad aration \nlogics and type theories aims to allow custom notions of separable resource to be introduced and combined \nmodularly. This paper presents a semantics for e.ect systems supporting .ctional, or abstract , notions \nof both e.ects and separation. We have previously interpreted e.ect-re.ned types for stateful computations \nas binary relations, de.ned via preservation of par\u00adticular sets of store relations [7]. This already \nprovides some ab\u00ad straction. The semantics is extensional so, for example, a function that reads a reference \ncell but doesn t produce observably di.er\u00adent results depending on the value read can soundly be counted \nas pure (contrasting with, for example, models of permissions that instrument the concrete semantics). \nSuch a semantics can also in\u00adterpret the masking rule, allowing certain non-observable e.ects not to \nappear in annotations [6]. But here we go further, gener\u00ad alizing the interpretation of regions to, intuitively, \npartial equiva\u00adlence relations. This allows, for example, a lookup function for a set ADT to be assigned \na read-but-not-write e.ect, even though the concrete implementation may involve non-observable writes \nto rebalance an internal datastructure. Moving to PERs in this way requires us to revisit the notion \nof separation, allowing types to involve distinct regions whose concrete implementations overlap, albeit \nnon-observably, in memory. Earlier models of dynamic allocation [6] have used Kripke log\u00adical relations \nin which worlds are .nite partial bijections between locations, with region-colored links. Two computations \nc, c' : H . H \u00d7 V, where H, V are sets of (partial) heaps and values, respec\u00adtively, are in the computation \nrelation Te[A]w, for world w, e.ect e and result type A when .h, h', h1, h1'. h, h' |= w . .w1 = w. h1, \nh'|= w1. (h, h1, h', h'1, w, w1) . [e] . (v, v') . [A]w1 where 1 c h = (h1, v) and c' h' = (h1', v'). \nHere, [A]w1 is the (world\u00addependent) logical relation at the result type and [e] the interpreta\u00adtion \nof the e.ect, which can be given in various ways, e.g., in terms of binary relations on stores to be \npreserved. The notation h, h' |= w means that for each link (l, l') . w, l . dom(h), l' . dom(h'). However, \ngeneralizing such a logical relation from bijections to PERs is surprisingly di.cult. The problematic \npart is the existential quanti.cation over world extensions: .w1 = w. This says that c and c' are related \nat world w if there is some future world w1, allowing for the computations to perform allocations, at \nwhich the respective .nal states and values are related. This pattern of quanti.cation occurs in many \naccounts of generativity, but the dependence of w1 on both h and h' creates a di.culty when one generalizes \nfrom bijections to PERs and tries to prove equivalences. Roughly, one has to consider varying the initial \nheap in which one computation, say c', is started; the existential then supplies one with a di.erent \nextension that is not at all related, even on the side of c where the heap stays the same, to the one \nwith which one started. In the case of bijections, the fact that h1 depends only on h (not on h') allows \none to deduce su.cient information about the domain of w1 from the clause h1, h'|= w1, but this breaks \ndown in the more abstract 1 setting. To .x this problem, we will essentially replace the existential \nquanti.er in the logical relation by appropriate Skolem functions, explicitly enforcing the correct dependencies. \nIn the language of type theory, this amounts to replacing the existential with a S-type. A statement \nlike (c, c') . Te[A] is no longer just a proposition, but we rather have a set of proofs (p : c ~ c') \n. Te[A], and our constructions will explicitly maps proofs to proofs. We have previously shown [4] how \nthe formalism of setoids can be used to make such intuitions both rigorous and more general. That work, \ndealing with a version of Pitts and Stark s .-calculus, used proof-relevant setoids to solve another \nproblem associated with the use of existential quanti.cation: that it fails to preserve admissibility \nof predicates and relations and so interacts badly with general recursion. Here we show how that technology \nscales to a much richer language and type system. 2. Motivating Examples We will assign e.ect-re.ned \ntypes to terms in a fairly conven\u00adtional monadically-structured untyped metalanguage with higher\u00adorder \nfunctions and dynamically allocated references to .at data. The language is de.ned formally later on, \nbut the following ex\u00adamples of the kind of equivalences and typings we will be able to justify should \nbe comprehensible. Memoisation Let memo be the function . f.let x.ref(0) in let y.ref( f 0) in .a.if \na = !x then !y else let r . f a in x := a; y := r; r where t1; t2 = let . t1 in t2 is sequential composition \nand = is equality on storable values. So, memo returns a memoized version of its argument. Unlike previous \nmodels of e.ects, our \u00d8 \u00d8 \u00d8 model justi.es the typing memo : --- (int . int) . (int . int), saying \nthat if f is observationally pure, memo f , is too, and so can participate in any program equivalence \nrelying on purity. For example, a client can deduce the observational equivalence of the programs below \npurely on the basis of typing: .y.letg.memo (.x.x + 1)in e = letg.memo (.x.x + 1)in .y.e Overlapping \nreferences Let p,p-1 implement a bijection Z . Z\u00d7 Z, then vor := . .let r .ref(0) in (. .(p(!r)).1, . \n.(p(!r)).2, .n.let (x, y). p(!r) in r := p-1(n, y), .n.let (x, y). p(!r) in r := p-1(x, n))  which multiplexes \ntwo abstract integer references onto a single concrete one, can be given the type alr1,alr2rdr1rdr2 tor \n:= unit - ---. (unit --. int) \u00d7 (unit - . int) \u00d7 wrr1wrr2 (int - -. unit) \u00d7 (int - -. unit) expressing \nthat it allocates in two regions, r1 and r2, and returns a tuple of functions, each of which reads or \nwrites just one region. This typing justi.es, for example, permuting writes to the two abstract references. \nSet factory A more realistic example, for which we do not give concrete code, is a function setfactory \nthat generates mutable in\u00adteger sets. Calling setfactory allocates a new reference cell point\u00ading to \na linked list of integers (initially empty) and returns a triple of functions (mem, add, rem) for testing \nmembership of the repre\u00adsented set, adding a new integer to the set and removing an integer from the \nset. The implementation of mem searches for its integer argument in the linked list, but at the same \ntime mutates the list by removing duplicates and, just for fun, potentially relocating some of the nodes. \nThe other operations can potentially perform similar optimizations. We can justify the following semantic \ntyping for setfactory: alrrdrrdr,wrrrdr,wrr setfactory : .r.unit - . (int - . bool)\u00d7(int ----. unit)\u00d7(int \n----. unit) which expresses that setfactory allocates in some (possibly fresh) region r and returns operations \nthat, observably, only read r (the .rst one) and/or write in r (the second and third one) even though, \nphysically, all three functions may read, write, and allocate concrete locations. Thus, these functions \ncan participate in corresponding e.ect\u00addependent program equivalences. For example, mem operations may \nbe swapped and duplicated. Lazy Initialization The following de.nitions illustrate an allocate\u00adon-write \nform of lazy initialization: make = . .ref(0) getx = .p.if !p = 0 then 0 else !(!p.1) gety = .p.if !p \n= 0 then 0 else !(!p.2) setx = .p..n.if !p = 0 then p := (ref(n), ref(0)) else !p.1 := n sety = .p..n.if \n!p = 0 then p := (ref(0), ref(n)) else !p.2 := n We can introduce a new abstract type pointr1,r2 for \nwhich the fol\u00adlowing typings can be semantically justi.ed: alr2 make : unit - . pointr1,r2 rdr1rdr2 \n getx : pointr1,r2 --. int gety : pointr1,r2 --. int \u00d8 wrr1\u00d8 wrr2 setx : pointr1,r2 -- -setx : pointr1,r2 \n. int . unit . int . unit -- - Observe that the allocation e.ects are .agged in the make function, even \nthough the physical allocations happen on demand, in the set functions. Note also that semantic reasoning \nis necessary to justify that these de.nitions are well-typed at all, as a point holds di.erent kinds \nof value at di.erent times. 3. Syntax and Semantics In this section we de.ne the syntax and denotational \nsemantics of our untyped metalanguage for stateful computations. We also give an e.ect-re.ned type system \nfor this language that is parame\u00adterized by semantically-justi.ed axioms. We omit the standard de\u00adtails \nof interpreting CBV languages via the metalanguage and of adequacy, relating the operationally induced \nobservational equiva\u00adlence to equality in the model. Denotational Model A predomain is an .-cpo, i.e., \na partial order with suprema of ascending chains. A domain is a predomain with a least element, .. Recall \nthat f : A . A' is continuous if it is monotone x = y . f (x) = f (y) and preserves suprema of chains, \ni.e., f (supi xi) = supi f (xi). Any set is a predomain with the discrete order. If X is a set and A \na predomain then any f : X . A is continuous. A subset U of a predomain A is admissible if whenever (ai)i \nis an ascending chain in A such that ai . U for all i, then supi ai . U, too. If f : X \u00d7 A . A is continuous \nand A is a domain then one de.nes f (x) = supi fx i(.) with fx(a) = f (x, a). One has, f (x, f (x)) = \nf (x) and if U . A is admissible and f : X \u00d7 U . U then f : X . U, too. We denote a partial (continuous) \nfunction from set (predomain) A to set (predomain) B by f : A B. We assume two sets Land Vb modelling \nconcrete locations, and the R-values that can be stored in locations. We assume that R\u00advalues include \nintegers, written int(n) for some n . Z, booleans, written bool(b) for b . B, locations loc(l) for some \nl . L, and tuples of R-values, written (v1, . . . , vn). We assume that it is possible to tell whether \na value is of that form and in this case to retrieve the components. Heaps h . H are .nite maps from \nL . Vb. The domain of a heap h is dom(h) . L. We write \u00d8 . H for the empty heap. If v . Vb, l . dom(h) \nthen h[lh.v] is the heap that updates l to contain v; new(h, v) yields a pair (l, h') where l . L and \nh' . H. The following properties hold: dom(\u00d8) = \u00d8, dom(h[lh.v]) = dom(h), (h[lh.v])(l') = if l = l' then \nv else h(l'), and if new(h, v) = (l, h') then dom(h') = dom(h) . {l} and l r dom(h) and h'(l) = v. Note \nthat heaps and R-values are discrete predomains; we do not here model higher-order store (storing objects \nwith nontrivial order, such as functions). Our stores are .at , like those of object\u00adoriented languages. \nWe de.ne the predomain of values V and the domain of com\u00adputations C simultaneously as follows: C = H \nH \u00d7 V are par\u00adtial continuous functions from H to H\u00d7 V, the bottom element be\u00ading the everywhere unde.ned \nfunction. Values are de.ned as either R-values, tuples of values or continuous functions from values \nto computations: V \" Vb + fun(V . C) + V* . Such domain equations can be solved by standard methods. \nSyntax The syntax of untyped values and computations is: v ::= x | () | c | (v1, v2) | v.1 | v.2 | rec \nf x = t t ::= v | let x.t1 in t2 | v1 v2 | if v then t1 else t2 !v | v1 := v2 | ref(v) Here, x ranges \nover variables and constants c over constant sym\u00adbols, each of which has an associated interpretation \n.c. . V; these include numerals n with .n. = int(n), booleans, arithmetic opera\u00adtions, test functions \nto tell whether a value is an integer, a function, a pair, or a reference, equality test for R-values, \netc. rec f x = t de.nes a recursive function with body e and recursive calls made via f ; we use .x.t \nas syntactic sugar in the case when f r f v(t). Finally, !v (reading) returns the contents of location \nv, v1 := v2 (writing) updates location v1 with value v2, and ref(v) (allocating) returns a fresh location \ninitialized with v. The metatheory is sim\u00adpli.ed by using let-normal form , in which the only elimination \nfor computations is let, though we sometimes nest computations as shorthand for let-expanded versions \nin examples. The untyped denotational semantics of values .v. . V . V and terms .t. . V . C is de.ned \nin usual way by inductive clauses, which we omit here. Types are given by the grammar e t ::= unit | \nint | bool | A | t1 \u00d7 t2 | t1 . t2 - where A ranges over user-speci.ed abstract types. They will typi\u00adcally \ninclude region-indexed reference types such as intrefr and also types like lists, sets, and even objects, \nagain possibly re.ned by regions. The metavariable e represents an e.ect, that is a subset of some .xed \nset of elementary e.ects about which we say more later. The core typing rules for values and computations \nare shown in Figure 1. The side condition on rule Dead requires us to ascertain that t1 terminates for \nall inputs and heaps satisfying the contracts speci.ed in G, e. We assume an ambient set of typing axioms \neach having the form (v, t) where v is a value in the metalanguage and t is a type meaning that v is \nclaimed to be of type t and that this will be proved manually using the semantics rather than using the \ntyping rules. We also assume an ambient set of equality axioms each having the form (v, v ' , t) and \nasserting semantic equality of v and v ' at type t, again to be justi.ed manually . We assume that whenever \n(v, v ' , t) is an axiom so are (v, t) and (v ' , t). The equational theory can be classi.ed in three \ndi.erent cate\u00adgories: basic, congruence and e.ect-dependent. An extract of the basic and congruence equations \nare depicted in Figure 2. The the\u00ad ory also includes all the usual beta and eta laws and commuting conversions \nfor conditionals as well as for let. We will give a se\u00admantic interpretation of typed equality judgments \nwhich is sound for observational equivalence. As with typings, further equations involving e.ectful computa\u00adtions \nmay be justi.ed semantically in a particular model and added to the theory. In particular, we can justify \nthe soundness of four e.ect-based equations, namely, dead, duplicated and commuting computation, and \npure lambda hoist also shown in Figure 2. The core theory then allows one to deduce new semantic equalities \nfrom already proven ones. 4. Abstract Locations We now de.ne the concept of an abstract location which \ngener\u00adalizes physical locations in that it models a portion of the store that can be read from and updated. \nSuch portion may comprise a .xed set of physical locations or a varying such set (as in the case of a \nlinked list with some given root). It may also reside in just a part of a physical location, e.g., comprise \nthe two low order bits of an integer value stored in a physical location. Furthermore, the equal\u00adity \non such abstract location may be coarser than physical equality, e.g., two linked lists might be considered \nequal when they hold the same set of elements, and there may be an invariant, e.g., the linked list should \ncontain integer entries and be neither circular nor aliased with other parts of the heap. This then prompts \nus to model an ab\u00adstract location as a partial equivalence relation (PER) on heaps to\u00adgether with two \nmore components that describe how modi.cations of the abstract location interact with the heap as a whole. \nThus, next to a PER, an abstract location also contains a re.exive transitive re\u00adlation ( guarantee ) \nmodelling its evolution by way of modifying actions. We will de.ne a notion of when abstract locations \nare indepen\u00addent, generalizing the traditional notion of separation. However, there is some extra complexity \ndue to the fact that whatever cus\u00adtom notions of equality and separation we introduce, we would like \nthem all to interact well with the underlying built-in allocator. A G f v : int G f e1 : t &#38; e G \nf e2 : t &#38; e G f e1 : t1 &#38; e G, x:t1 f e2 : t2 &#38; e G f t : t &#38; e r r regs(G) . regs(t) \n (v, t) a type axiom G f v : t G f true : bool G f false : bool G f n : int G f v : t G, x : t f x : \nt G f v : t &#38; \u00d8 G f v : t1 \u00d7 t2 G f v1 : t1 G f v2 : t2 G f v1 : t1 e -. t2 G f v2 : t1 G, f :t1 \ne -. t2, x:t1 f e : t2 &#38; e G f e : t &#38; e1 e1 . e2 G f v.i : ti G f (v1, v2) : t1 \u00d7 t2 G f v1 \nv2 : t2 &#38; e G f rec f x = e : t1 e -. t2 G f e : t &#38; e2 Masking G f if v then e1 else e2 : \nt &#38; e G f let x.e1 in e2 : t2 &#38; e G f t : t &#38; e \\ {rdr, wrr, alr} Figure 1. Core rules for \ne.ect typing Basic Equations (Extract) t ' t ' t '' v ' G f t : t &#38; e G f t = : t &#38; e G f t \n= : t &#38; e G f t ' = : t &#38; e G f v = : t G, f v : t1 \u00d7 t2 t '' G f t = t : t &#38; e G f t ' \n= t : t &#38; e G f t = : t &#38; e G f v = v ' : t &#38; \u00d8 G f v = (v.1, v.2) : t1 \u00d7 t2 . t2, x:t1 f \nt = e G, f : t1 -e t ' : t2 &#38; e G f v1 : t1 G f v2 : t2 G, f : t1 -G f v : t1 . t2, x:t1 f t : t2 \n&#38; e e G f (v1, v2).i = vi : ti G f (rec f x = t) = (rec f x = t ') : t1 . t2 G f (rec f x = t) v \n= t[v/x, (rec f x = t)/ f ] : t2 &#38; e - G f v : t1 &#38; e G, x : t1 f t : t2 &#38; e G f t1 : t1 \n&#38; e G f t2 : t2 &#38; e G, x : t2, y : t1 f t3 : t3 &#38; e (v, v ' , t) an equality axiom G f let \nx .v in t = t[v/x] : t2 &#38; e G f let x .(let y .t1 in t2) in t3 = let y .t1 in let x.t2 in t3 : t3 \n&#38; e G f v = v ' : t Congruence Equations (Extract) G f v = v ' : t1 \u00d7 t2 G f v = v ' : bool &#38; \n\u00d8 G f t1 = t1 ' : t &#38; e G f t1 = t1 ' : t &#38; e G f v.i = v ' .i : ti G f if v then t1 else t2 \n= if v ' then t1 ' else t2 ' : t &#38; e Effect Based Equations G f t1 : t1 &#38; e1 G f t : t &#38; \ne wrs(e1) = \u00d8 Dead, provided t1 terminates G f (let x .t1 in t) = t : t &#38; e G f t1 : t1 &#38; \u00d8 G, \nx : X, y : t1 f t : t &#38; e e Pure Lambda Hoist G f (.x.let y .t1 in t) = (let y.t1 in .x.t) : (X . \nt) &#38; \u00d8 - G f t1 : t1 &#38; e1 G, x : t1, y : t1 f t : t &#38; e wrs(e1) n rds(e1) = als(e1) = \u00d8 \nDuplicated G f (let x.t1 in let y .t1 in t) = (let x.t1 in t) : t &#38; e . e1 G f t1 : t1 &#38; e1 G \nf t2 : t2 &#38; e2 G, x : t1, y : t2 f t : t &#38; e rds(e1) n wrs(e2) = rds(e2) n wrs(e1) = wrs(e1) \nn wrs(e2) = \u00d8 Commuting G f (let x.t1 in let y .t2 in t) = (let y.t2 in let x .t1 in t) : t &#38; e1 \n. e2 . e Figure 2. Basic, congruence, and e.ect based equational theory p \u00b7 l = p(l) p \u00b7 (a1, a2) = (p \n\u00b7 a1, p \u00b7 a2) p \u00b7 (L . L) = {p(l) | l . L} dom(p \u00b7 h) = p \u00b7 (dom(h)) (p \u00b7 h)(l) = p \u00b7 (h(p-1(l))) p \u00b7 \nR = {h | p-1 \u00b7 h . R}p \u00b7 (h1, . . . , hn) = (p \u00b7 h1, . . . , p \u00b7 hn) Figure 3. Action of permutations \nfreshly allocated concrete cell should be independent of any exist\u00ading abstract locations, for example, \nand abstract locations should not be sensitive to the behaviour of the underlying allocator. Were we \nworking in a lower-level language (in which the allocator is just another piece of code to be veri.ed), \nwe would hope that concrete locations could be treated as a special case of abstract ones, but this seems \nto require a notion of when one notion of location is an abstraction of another (Jensen and Birkedal \nhave taken some steps along such a path [25]). Instead, we here bake in compatibility with the underlying \nallocator using nominal ideas Following Gabbay and Pitts [21], we write perm(L) for the group of permutations \nof L and de.ne an action p \u00b7 - of permu\u00adtations p . perm(L) for values, stores, sets of locations, and \nre\u00adlation on stores. Table 3 contains the most important cases: Note that permutations act di.erently \non sets of locations and on sets / relations on heaps. In the sequel we call object anything that the \n permutations act on, i.e. locations, values, stores, etc. For example, a list of heaps h is in the relation \np \u00b7 R i. the list of heaps obtained by undoing the permutation (p-1 \u00b7 h ) is in the relation R. We de.ne \nthe set of .xpoints of a permutation p as .x(p) = {l | p(l) = l}. For an object x, a support of x is \na set of locations L such that .x(p) . L . p \u00b7 x = x. Gabbay and Pitts show [21] that if an object has \na .nite support then it has a (unique) least support, which we write supp(x). It is clear that stores, \nvalues, and .nite sets of locations always have a .nite support. A store relation having a .nite support \nis called .nitely supported. For example, the predicate P on stores asserting that there is a linked \nlist starting at location X has support {X}. Note that although a linked list in h witnessing that h \n. P may have a large footprint , the support still is just {X} because the internal nodes of such a linked \nlist will be consistently renamed by the permutation action. De.nition 4.1 (Abstract Location). An abstract \nlocation l (on the chosen set H) consists of the following data: a non-empty, .nitely supported, partial \nequivalence relation (PER) lR on H modelling the semantic equality on the bits of the store that l uses \n(a rely-condition );  a .nitely supported transitive relation lG modelling what bits of the store writes \nto l leave intact (a guarantee condition ).  That is, if (h, h1) . lG then h1 might arise by writing \nto l in h and all possible writes are speci.ed by lG; subject to the conditions, where p is a permutation \nand h : lR is shorthand for (h, h) . lR: 1. if .x(p) . supp(lR) then h : lR . (h, p \u00b7 h) . lR . 2. if \nh : lR then (h, h) . lG; 3. if (h, h1) . lG then h : lR and h1 : lR; 4. lR; lG . lG ; lR , that is, \nif (h, h') . lR and (h, h1) . lG , then there exists h' such that (h' , h' ) . lG and (h1, h' ) . lR \n.  11 1 5. if h : lR and h1 . h then (h1, h) . lR thus lR looks no further than the currently allocated \nportion of the heap. 6. if h : lR and (h1h' , h' 1) . lG , then .h1.(h, h1) . lG .h' 1 = h1 1h' .  \nCondition 1 asserts that semantic equality is closed under relo\u00ad for the separated heaps requirement: \nPset = {h | .h1, h2.(h = h1 1 h2) . setXsetY ([X h. nil] - -. h1) . ([Y h. nil] - -. h2)}. This set \ncontains the disjoint unions of any evolution of the linked lists pointed by the concrete locations X \nand Y. The following lemma will be helpful for relocating abstract locations and asserting independence. \nLemma 4.5. If supp(l1) n supp(l2) = \u00d8, then l1.l2. Proof Let h1 : l1 and h2 : l2. Let L1 = dom(h1) and \nL2 = dom(h2). Choose permutations p1 and p2 such that p1\u00b7L1np2\u00b7L2 = \u00d8 and .x(pi) . supp(lR i ). De.ne \nthe pasted heap h1 . h2 by cation. It rules out relations that stipulate equality of internal point\u00ad \ners (not to .xed ones which would enlarge the support, but between h and h'). Conditions 5 and 6 ensure \nthat relies and guarantees in\u00ad(h1 . h2)(l) = . . . . . (p1 \u00b7 h1)(l), if l . p1 \u00b7 L1 (p2 \u00b7 h2)(l), if \nl . p2 \u00b7 L2 unde.ned otherwise teract well with future extensions of the heap, preserving and being independent \nof fresh locations. We write h ~lh' to denote (h, h') . lR; h . l h1 to denote (h, h1) . - lG . We also \nuse the notation supp(l) for supp(lR) . supp(lG ). If p is a permutation we de.ne p \u00b7 l = (p \u00b7 lR , p \n\u00b7 lG ); it is easy to see that p \u00b7 l is an abstract location and .x(p) . supp(l) . p \u00b7 l = l. Furthermore, \nfor any p and p ' such that p|supp(l) = p ' |supp(l), one has p \u00b7 l = p ' \u00b7 l. This makes the following \nde.nition possible: De.nition 4.2 (relocation of abstract locations). Let l be an ab\u00adstract location \nand u : supp(l) . Lbe injective. Then u\u00b7l is de.ned as p \u00b7 l for some p extending u. We have supp(u \u00b7 \nl) = u(supp(l)). For an example, consider the following abstract location setX , with support {X}, implementing \nthe set example introduced above: setR = {(h, h') | If h and h' contain a linked list starting from \nX X and these lists contain the same set of integers.} setG X = {(h, h1) | h : lR X , h1 : lR and .l.l \n. dom(h) \\ F(h, X) . h(l) = h1(l)} X where F(h, X) is the set of the locations in h reached by the linked \nlist starting from X. The rely set, setR X , speci.es that two heaps are equivalent when linked lists \ndenote the same set of integers. The guarantee, setG X , speci.es that a write to this abstract location \nmay not change concrete locations not in the linked list. Note, in particular, how this example validates \ncondition Def\u00adinition 4.1(1): We can relocate one of the two linked lists without compromising relatedness \nin setR X provided we leave the entry point X .xed. If one tried to modify our abstract location to relate \nlinked lists with the exact same footprint, then property 1 would fail. De.nition 4.3 (Separated Heap). \nLet l1, l2, . . . , ln be abstract lo\u00adcations. A heap h is separated with respect to l1, l2, . . . , \nln, written sep(h, {l1, l2, . . . , ln}), if for all 1 = i = n. h : lR and for all j * i and i lil j \nfor any heap h1 such that h -~ h1 and, coinduc\u00ad . h1, we have h tively, sep(h1, {l1, l2, . . . , ln}). \n De.nition 4.4 (Independence). Abstract locations l1, l2, . . . , ln are independent, written .({l1, \nl2, . . . , ln}), if h1 : l1, . . . , hn : ln, then there exists h, where sep(h, {l1, l2, . . . , ln}) \nand h ~lihi for 1 = i = n. The de.nition of independence implies that quotienting by the intersection \nof the PERs yields a product of the individual quo\u00adtients. As the separated heap h as de.ned above is \nunique up to ~ (with respect to l1, . . . , ln), we use the notation h1 . h2 . \u00b7 \u00b7 \u00b7 . hn to denote a \ncanonical separated heap. Returning to the setfactory example, consider two sets setX and setY , where \nX and Y are the concrete locations where the linked lists implementing, respectively, setX and setY start. \nIf X and Y are di.erent, we use coinduction to show setX and setY are independent, using the following \nset as the witnessing co-inductive hypothesis Thus, in particular, dom(h1 . h2) = p1 \u00b7 L1 1 p2 \u00b7 L2. \n From Def. 4.1(1) we know (h1, p1 \u00b7 h1) . l1 R . We also have (h1, p-1 1 \u00b7 (h1 . h2)) . lR 1 by Def. \n4.1(5), thus (p1 \u00b7 h1, h1 . h2) . l1 R so we can conclude by transitivity. The remaining properties are \nleft to the reader. o De.nition 4.6. If l1, l2 are independent, we form a joint location l1 . l2 speci.ed \nas follows: (l1 . l2)R = {(h, h') | (h, h') . lR n l2 R and sep(h, {l1, l2}) and 1 sep(h' , {l1, l2})} \n (l1 . l2)G = (lG 1 . lG 2 )* restricted to (l1 . l2)R; Lemma 4.7. If l1 and l2 are independent abstract \nlocations, then the joint location l1 . l2 is an abstract location. Lemma 4.8. Let l1 and l2 be independent \nabstract locations. Then (l1 . l2)G . lG 1 ; lG ; (l1 . l2)R 2 . Lemma 4.9. .({l1, l2, l3}) if and only \nif l2.l3 and l1.(l2 . l3). De.nition 4.10. Let 1 be the abstract location as follows, 1R = H\u00d7Hand (h, \nh') . 1G if and only if h = h' . Notice that supp(1) = \u00d8. Lemma 4.11. l1.l2 if and only if and l2.l1. \nMoreover, 1 . l = l. Remark 4.12. Motivated by the axioms of separation algebras [13] one might conjecture \nthat . is cancellative, i.e. that l1 .l = l2.l implies l1 = l2. However, for the above de.nitions, this \ndoes not generally hold. 4.1 Examples of Abstract Locations Besides abstraction locations for sets of \nintegers used above, we illustrate other instances of abstract locations: Single Integer For our simplest \nexample, consider an abstract location lX , parametric with respect to X as follows: n ' intR X = {(h, \nh') | h(X) = n . h'(X) = . int(n) = int(n ')} intG = {(h, h1) | h : intR X , h1 : intR X and .l . L.l \n* X . h(l) = h1(l)} X Two heaps are in its rely relation if the values stored in X are the same; and \nits guarantee is to leave all other concrete locations alone. It is also the case that intX and intY \nare independent, i.e., intX .intY . This is witnessed by the following co-inductive hypoth\u00adesis to show \nthe separateness condition of heaps with respect to these locations, similar to the one used before for \nthe showing the independence of setX and setY intXintY Pint = {h | .h1, h2.(h = h11h2).([X h. 0] - -. \nh1).([Y h. 0] --. h2)}. Overlapping references Recall the overlapping references exam\u00adple introduced \nearlier. Let X be the concrete location encoding a pair of values. We de.ne abstract locations fstX and \nsndX by: R (a ' a ' X 2 fst= {(h, h') | h(X) = (a1, a2) . h'(X) = 1, a ' ) . a1 = 1} sndR = {(h, h') \n| h(X) = (a1, a2) . h'(X) = (a1 ' , a ' ) . a2 = a2 ' } X 2 G RR fst= {(h, h1) | h : fstX , h1 : fstX \nand X .l . L.l * X . h(X) = (a1, a2) . h1(X) = (a1 ' , a ' 2) . h(l) = h1(l) . a2 = 2} a ' sndG = {(h, \nh1) | h : sndR X , h1 : sndR X and X .l . L.l * X . h(X) = (a1, a2) . h1(X) = (a ' 1, a ' 2) . h(l) = \nh1(l) . a1 = a ' 1} The rely of fstX (respectively, sndX ) speci.es that two heaps h and h' are equivalent \nwhenever they both store a pair of values in X and the .rst projections (respectively, second projection) \nof these pairs are the same. The guarantee of fstX (respectively, sndX ) speci.es that it keeps all other \nlocations alone and does not change the second projection (respectively, .rst projection) of the pair \nstored at location X. By using a coinduction hypothesis for separated heaps similar to the ones used \nabove, it is straightforward to verify that fstX and sndX are independent, although they share the concrete \nlocation X. Lazy Initialization Recall the Lazy Initialization example intro\u00adduced earlier. Let X be \nthe concrete location used to store the data that is initialized. We de.ne the following abstract location \npara\u00admetric on i . {1, 2}: lazy(i)R = {(h, h') | h(X) = 0 . initial(h' , X) and X h'(X) = 0 . initial(h, \nX) and h(X) = (a1, a2) . h'(X) = (a ' 1, a ' ) . h(ai) = h'(ai ')} 2 lazy(i)G = {(h, h1) | h : lR X , \nh1 : lR X and h1(X) = 0 . h(X) = 0 and X h(X) = (a1, a2) . h1(X) = (a ' 1, a ' 2) . .l.l r {X, ai, a \n' i } . h(l) = h1(l)} where initial(h, X) is the predicate h(X) = 0 . (h(X) = (a1, a2) . h(a1) = 0 = \nh(a2)). The rely speci.es that two heaps are equivalent when either X is in the initial, uninitialized, \nstate in both of them, as speci.ed by the predicate initial, or X in both heaps points to a pair of references, \nthe i-th of which also contain the same values. The guarantee condition speci.es that X in an updated \nheap is 0 only if it was so before, and moreover all locations not used in the rely are left unchanged. \n5. Setoids Abstract locations capture the invariants that we will use to build our model. The big picture \nis that types are modelled as functors from a category of worlds into a category of setoids, with terms \nbeing interpreted as natural transformations. Worlds will comprise independent abstract locations, whilst \nsetoids are predomains augmented with a proof-relevant notion of equality. In this section, we de.ne \nthe category of setoids more precisely. Section 6 then explains the structure of the category of worlds \nand setoid-valued functors. While we assume that the reader is familiar with some notions of category \ntheory, such as functor, natural transformation, and cartesian closure [31], we review some basic concepts \nand notation here. We compose morphisms in the usual applicative order, thus, if f : A . B and g : B \n. C then g f : A . C. A morphism u in a category C is a monomorphism if ux = ux ' implies x = x ' for \nall morphisms x, x ' . A commuting square xu = x ' u ' of morphisms is a pullback if '' ' whenever xv \n= x v there is unique t such that v = ut and v = u ' t. A pair of morphisms u, u ' with common domain \nis a span, a pair of morphisms x, x ' with common codomain is a co-span. A category has pullbacks if \nevery co-span can be completed to a pullback square. We de.ne the category of setoids as the exact completion \nof the category of predomains, see [10, 14]. We recall here the elementary description using the language \nof dependent types given in an earlier paper et al. [4]. De.nition 5.1. A setoid A consists of a predomain \n|A| and for any two x, y . |A| a set A(x, y) of proofs (that x and y are equal). The set of triples {(x, \ny, p) | p . A(x, y)} must itself be a predomain and the .rst and second projections must be continuous. \nFurthermore, there are continuous functions rA : .x . |A|.A(x, x) and sA : .x, y . |A|.A(x, y) . A(y, \nx) and tA : .x, y, z.A(x, y) \u00d7 A(y, z) . A(x, z), witnessing re.exivity, symmetry and transitivity; note \nthat no equations between these are imposed. In the above de.nition, continuity of a dependent function \nsuch as t(-, -) means the following: If (xi)i and (yi)i and (zi)i are as\u00adcending chains in A with suprema \nx, y, z, and pi . A(xi, yi) and qi . A(yi, zi) are proofs such that (xi, yi, pi)i and (yi, zi, qi)i are \nalso ascending chains, with suprema (x, y, p) and (y, z, q), then (xi, zi, t(pi, qi)) is an ascending \nchain of proofs (by monotonicity of t(-, -)) and its supremum is (x, z, t(p, q)). If p . A(x, y) we may \nwrite p : x ~ y or simply x ~ y. We also omit | - | wherever appropriate. Setoids based on types rather \nthan predomains have been used to provide extensional equality in intuitionistic type theory [2]. De.nition \n5.2. A morphism from setoid A to setoid B is an equiv\u00adalence class of pairs f = ( f0, f1) of continuous \nfunctions where f0 : |A| . |B| and f1 : .x, y . |A|.A(x, y) . B( f0(x), f0(y)). Two such pairs f , g \n: A . B are identi.ed if there exists a continuous function \u00b5 : .a . |A|.B( f (a), g(a)). Morphisms are \ncomposed in the obvious way to form the cate\u00adgory of setoids. In the sequel we tend to omit | - | and \n0, 1-subscripts where appropriate, thus writing x(a) for x0(a) or a . A or even a : A for a . |A| etc. \nWe remark that one could also choose not to identify ~-equal morphisms. We decided to make the identi.cation \nbecause standard category-theoretic concepts like cartesian closure, pullbacks, etc. then apply directly, \nrather than only holding up to ~. The following is folklore, see also [10]. Proposition 5.3. The category \nof setoids is cartesian-closed. The cartesian product A \u00d7 B of setoids A, B has components |A \u00d7 B| = \n|A|\u00d7|B| and (A\u00d7B)((a, b), (a ' , b')) = A(a, a ')\u00d7B(b, b'). The ordering is given component-wise. The \nunderlying predomain of the function space of A . B of setoids A, B is given by the set of representatives \n( f0, f1) of morphisms from A to B ordered component-and point-wise. Given two such elements f = ( f0, \nf1) and g = (g0, g1) a proof \u00b5 : f ~ g in A . B is a continuous function establishing equality of f and \ng qua morphisms from A to B as in De.nition 5.2. Proof The veri.cation of the cartesian product is straightfor\u00adward. \nThe application morphism ap from (A . B) \u00d7 A to B has components given by ap0(( f0, f1), a) = f0(a) and \nap1(\u00b5, p) = f1(p); \u00b5(a ') where \u00b5 : f ~ g and p : a ~ a '. Note that we have f1(p) : f0(a) ~ f0(a ') \nand \u00b5(a ') : f0(a ') ~ g0(a '). Conversely, if h : C \u00d7 A . B is a morphism represented by (h0, h1) we \nde.ne .(h) : C . A . B by (.h)0(c) = ( f0, f1) where f0(a) = h0(c, a) and f1(p) = h1(rC (c), p). We also \nput (.h)1(p : c ~ c ')(a) = h1(p, rA(a)). If (h' 0, h' 1) is another representative of h witnessed by \na proof \u00b5 then .c..a.\u00b5(c, a) witnesses equality of the so constructed abstraction. The remaining veri.cations \nare direct. o Proposition 5.4. The category of setoids has pullbacks. Proof To construct a pullback of \nx : A . B and x ' : A' . B pick representatives (x0, x1) and (x0 ' , x ' 1) and take the low  point \nof the pullback U to be given by |U| = {(a, a ' , p) | a . A, a ' . A' , p . B(x(a), x '(a '))} and then \nU((a, a ' , p), (a1, a ' 1, p1)) = A(a, a1)\u00d7A(a ' , a ' 1). The ordering is component wise. The morphism \nu : U . A is de.ned by u0(a, a ' , q) = a and u1(p, p ') = p. The remaining de.nitions and veri.cations \nare straightforward. Note, however, that when proving the uniqueness of .ll-ins to establish the pullback \nproperty we make use of the fact that pointwise ~\u00adequal morphisms are identi.ed. o De.nition 5.5. A setoid \nD has a least element if |D| has a least element . and there is also a least proof . . D(., .). Proposition \n5.6. For each D with least element there is a mor\u00adphism YD : (D . D) . D such that the following hold: \n YD = ap(idD.D, YD> (so YD( f ) is a .xpoint of f ).  Suppose that both D, D' have least elements and \nu : D . D' satisfy u0(.) = .. Let D.D .g X .g ' D' .D' be the pullback of u(-) : D.D . D.D' and u(-) \n: D' .D' . D.D' . So, intuitively, X contains pairs ( f, f ') with f : D . D, f ' : D' . D' and u f = \nf 'u. Then uYDg = YD' g '. Intuitively, this means that if u f = f 'u and u(.) = . then u(YD( f )) = \nYD' ( f ').  Proof Given f . D . D construct the least .xpoint of f0 as supi f0 i(.). The passage from \nf to the least .xpoint being continu\u00adous this de.nes the .rst part of YD, i.e., (YD)0( f ) = supi f0 \ni(.). As for the proof component assume that p : f ~ f '. By repeatedly in\u00advoking p we then get a family \nof proofs pi : f0 i(.) ~ f0 'i(.). Using the fact that r(.) is the least proof we can then show by induction \non i that this family of proofs is increasing and its supremum sat\u00adis.es supi pi : YD( f ) ~ YD( f '). \nThus, we put (YD)1(p) = supi pi which again is continuous. It is obvious from the construction as a least \n.xpoint that the required .xpoint equation is indeed satis.ed. As for the second one pick u : D . D'and \nassume f : D . D and f ' : D' . D' and a proof p : u f ~ f ' u. Now, by repeatedly invoking p we get \nan increasing family of proofs pi : u f i(.) ~ f '(u(.)) = f '(.) whose supremum witnesses u(YD( f )) \n~ YD' ( f '). This establishes the claim. o 6. Worlds and Setoid-Valued Functors We now organize abstract \nlocations into a category that will in\u00addex the meanings of types and terms in a functor category seman\u00adtics \n[33, 39]. Our category is morally similar to that of .nite sets and injections, which has been used in \nother work [6, 39]. The dif\u00ad ference is that objects are now sets of mutually independent abstract locations \nand morphisms are slightly more complicated in that they allow relocation of abstract locations. Furthermore, \nlocations are grouped into regions allowing one to approximate them statically. x We begin with some \nmore notational preliminaries. Write u x(u ' ' x w ' (') or wx(' (when w= dom(x('))) for a pullback square \nwith u u ' morphisms x, u, x ' , u '. We call the common codomain of x and x ' the apex of the pullback \nwritten w, while the common domain of u, u ', the low point of the square, is written w. A pair of morphisms \nu, u ' with common domain is a span, a pair of morphisms x, x ' with common codomain is a co-span. A \ncategory has pullbacks if every co-span can be completed to a pullback square. A pullback x square wx(' \nw ' with apex w is minimal if whenever there is another u u ' pullback w x1 u(u x1 ' ' w ' over the same \nspan and with apex w1, then there is a unique morphism t : w . w1 such that x1 = t x and x ' 1 = t x \n' . Lemma 6.1. If a category C has pullbacks and wx(x ' w ' with apex u u ' w is a minimal pullback then \nthe morphisms x and x' are jointly epic, that is, if f x = gx and f x' = gx ' then f = g. For illustration \npurposes, we notice that the category of .\u00adnite sets and injections has pullbacks and in it every span \ncan be completed to a minimal pullback. Indeed, if u : U . A and u ' : U . A' then the apex of the minimal \npullback can be cho\u00adsen as A \\ Img(u) + A' with + denoting disjoint union. De.nition 6.2 (Category of \nworlds). Assume given an in.nite set Regs of region names. The category of worlds W is de.ned as follows: \n An object (written w and called a world) comprises a .nite set of mutually independent abstract locations \nwritten dom(w) and a function tagging each abstract location in w with a region from Regs; we write w(r) \nfor the set of abstract locations in w tagged with r. We de.ne su p p(w) = l.dom(w) su p p(l).  Let \nw and w ' be two worlds. A morphism from w to w ' is given by an injective function u : su p p(w) . su \np p(w ') such that for each l . dom(w) we have u \u00b7 l . dom(w ') (cf. Def. 4.2) and moreover, if l . w(r) \nthen u \u00b7 l . w '(r).  We write I(w, w ') for the set of morphisms u : w . w ' that are set-theoretic \ninclusions. Note that u \u00b7 l = l in this case.  The empty world is denoted \u00d8, i.e. dom(\u00d8) = \u00d8.  For \nexample, a morphism between {intX } . {intY , setZ } (region tags omitted) is given by the injective \nfunction that simply maps the concrete location X to the concrete location Y. The abstract locations \ngrouped together in one region represent all the stateful components, be they physical locations or more \ncomplex updatable data structures, that belong to that region. Static e.ect annotations amalgamate possible \nside e.ects on any of those components as e.ects on the region. The notion of morphism presented here \nis the simplest possible one that allows us to justify interesting e.ect-dependent equiva\u00adlences. There \nare more general notions of morphism that allow one to justify equivalences relying on representation \nindependence, e.g. ones resulting from replacing intX by sndY in a program. It is also possible to de.ne \nthe category of worlds di.erently by combining all the abstract locations contained in a given region \nusing the .-operation. A world then becomes a function assigning to each region a single large abstract \nlocation, possibly the trivial one. The presence of a morphism from one world to another then has to \nimply that the abstract locations attached to a region grow properly, i.e., go from l to an abstract \nregion isomorphic to l . l ' , which can be elegantly captured by adapting Oles s [33] idea of morphisms \nbetween store shapes, which has later been popularized as lenses in the context of bidirectional synchronization \n[20]. We reluctantly decided, for reasons of space and simplicity, against using these more general notions \nof worlds and morphisms here, but plan to discuss them in an extended version of the paper. The following \nis proved just as in the case of .nite sets and injections. Proposition 6.3. In the category W all morphisms \nare monomor\u00adphisms; W has pullbacks and all spans in W can be completed to minimal pullbacks. Moreover, \nthese pullbacks and minimal pullbacks can be chosen in such a way that if one of the two given maps is \nan inclusion then the one parallel to it is also an inclusion. If u : w . w1 and x : w1 . w2 then we \ncan .nd w ' 1 w ' w ' x(' w ' x and u' : w . and x' : . w2 so that w1 is a 1 1 u u ' 1 minimal pullback \nand if one of u, x is an inclusion then the opposite morphism can be chosen as an inclusion as well. \nThe world w ' 1 in the last clause comprises the locations in w and those in w2 that are not in w1. Intuitively, \nif w = A, w1 = A + B, w2 = A + B + C then w ' 1 = A + C. 6.1 Setoid-valued functors A functor A from \na category of worlds W to the category of setoids comprises as usual for each w . W a setoid Aw and for \neach u : w . w ' a morphism of setoids Au : Aw . Aw ' preserving identities and composition. If u : w \n. w ' and a . Aw we may write u.a or even ua for Au(a) and likewise for proofs in Aw. Note that (uv).a \n= u.(v.a). De.nition 6.4. We call a functor A pullback-preserving (p.p.f.) if x for every pullback square \nwx(' w ' with apex w and low point w the u u ' diagram below is a pullback in the category of setoids. \nAw  AwAw '  Aw Given our characterization of pullbacks in the category of se\u00adtoids (Prop. 5.4), this \ncondition is equivalent to the existence of a continuous function of type .a . Aw..a ' . Aw ' .Aw(x.a, \nx ' .a ') . Sa . Aw.Aw(u.a, a) \u00d7 Aw '(u ' .a, a ') which amounts to saying that if two values a . Aw \nand a ' . Aw ' are equal in a common world w, then this can only be the case because there is a value \nin the intersection world w from which both a and a ' arise. The witness a is unique up to ~. More importantly, \neven, two values cannot suddenly become equal just because we move to another world. Even though pullback \npreservation is not formally needed in the proofs of any of the subsequent results it simpli.es the intuition \nconsiderably. Lemma 6.5. If A is a p.p.f. and u : w . w ' and a, a ' . Aw then there is a continuous \nfunction Aw '(u.a, u.a ') . Aw(a, a '). (There is also a continuous function in the other direction just \nby functoriality.) Note that the ordering on worlds and world morphisms is dis\u00adcrete so that continuity \nonly refers to the Aw '(u.a, u.a ') argument. De.nition 6.6 (Morphism of functors). If A, B are p.p.fs., \na mor\u00adphism from A to B is a natural transformation from A to B. Thus, concretely, a morphism is an equivalence \nclass of pairs e = (e0, e1) of continuous functions where e0 : .w.Aw . Bw and '' '' e1 : .w..w ..x: w \n. w ..a . Aw..a . Aw . Aw '(x.a, a ') . Bw '(x.e0(a), e0(a ')). Two such morphisms e, e ' are equal if \nthere exists a continuous function \u00b5 : .w..a . Aw.Bw(e(a), e '(a)). These morphisms compose in the obvious \nway and so the p.p.f.s and morphisms between them form a category. Theorem 6.7. The category of p.p.f.s \nis cartesian-closed and has pullbacks. If A, B are p.p.f. then (A \u00d7 B)w = Aw \u00d7 Bw and |(A . B)w| contains \npairs ( f0, f1) as follows: f0(u) . |Aw1 . Bw1| for each w1 and u : w . w1. If u : w . w1 and v : w1 \n. w2 then f1(u, v) . (Aw1 . Bw2)([Av . Bw2] f0(vu), [Aw1 . Bv] f0(u)) where [Av . Bw2] : (Aw2 . Bw2) \n. (Aw1 . Bw2) [Aw1 . Bv] : (Aw1 . Bw1) . (Aw1 . Bw2) are the obvious composition morphisms. A proof in \n(A . B)w(( f0, f1), ( f0 ' , f1 ')) is a function g that for each u : w . w1 yields a proof g(u) . (Aw1 \n. Bw1)( f0(u), f0 '(u)). The order on objects and proofs is pointwise as usual. Moreover, if D is a p.p.f. \nwith the property that Dw has a least element .w for each w and whenever u : w . w1 then u..w = .w1 then \nthere is a morphism YD : (D . D) . D satisfying the same properties as those asserted in Prop. 5.6. Proof \nThis is a special case of the construction of a functor category with respect to an internal category \n(here the category of worlds viewed as discrete setoids, thus internal to the category of setoids). One \nmimics the standard constructions for set-valued functors taking care to keep representatives of morphisms \ndistinct as we did in the construction of the function space of setoids. The existence of the .xpoint \noperator does not seem to be known but follows by applying the same method. The rather .ne\u00adgrained speci.cation \nof the .xpoint operator on the level of setoids is needed here so that we can assure naturality of YD \nand YD( f ). o Heaps as a setoid We will now equip heaps with a world\u00addependent setoid structure singling \nout the separated ones (for a particular world) and setting equality to be induced by the ambient rely \nrelations. De.nition 6.8. If w is a world then the setoid Sw is de.ned by |Sw| = {h . H | .l . w.h : \nlR . sep(h, dom(w))} and Sw(h, h') = {*} .. .l . w.h ~lh' and Sw(h, h') = \u00d8 otherwise, where sep(h, dom(w)) \nis the separated heap with respect to the locations in dom(w) (see De.nition 4.3). If u : w . w ' and \nh . Sw ', then we de.ne h.u . Sw to be p-1 \u00b7 h for some p extending u. This is well-de.ned up to ~. In \nthis way, S becomes a contravariant functor from the cate\u00adgory of worlds to the category of setoids. \nx Lemma 6.9 (Pasting Lemma). Let w u x(u ' ' w ' be a minimal pullback with apex w. Let h . Sw and h' \n. Sw ' such that h.u ~ h' .u '. Then there exists a heap h1 . Sw, unique up to ~, such that h1.x ~ h \nand h1.x ' ~ h' . Corollary 6.10. Let u : w . w ' be a morphism and h . Sw and h' . Sw '. There exists \nh1 unique up to ~ such that h1.u ~ h and h1.u ' ~ h' .u ' where wu(0 w1 is a minimal pullback with low \npoint 0 u ' \u00d8, the empty world. Intuitively, h1 is obtained by overwriting the w-part of h' ac\u00adcording \nto h. Heap Relations De.nition 6.11. A relation R on S consists of a subset Rw . Sw \u00d7 Sw for each w, \nsuch that if (h, h') . Rw and u : w0 . w then (h.u, h' .u) . Rw0, and if p : h ~ h1 and p' : h' ~ h1 \n' then (h1, h' 1) . Rw, as well. The elementary e.ects track reading, writing, and allocating at the \nlevel of regions and are as follows: wrr (writing within region r), rdr (reading from within region r), \nand alr (allocating within region r). Each elementary e.ect E is associated with a set R(E) of relations \non S as follows: R . R(rdr) .. l(h, h') . Rw . .l . w(r).h ~ h' R . R(wrr) .. (h, h') . Rw . .l . w(r)..h1, \nh' 1.h1 l~ h' 1 . R . R(alr) .. h l -. h1 . h' l -. h' 1 . (h1, h' 1) . Rw (h, h') . Rw . .w1..u . I(w, \nw1).(w1 \\ w) . w1(r) . .h1, h' 1 . Sw1.[h1.u ~ h . h' 1.u ~ h' . (h1, h' 1) . l.w1\\w lR] . (h1, h' 1) \n. Rw1 Thus, R(rdr) is the set of relations R for which R-related heaps contain equal (in the sense of \nlR) values for all abstract locations in region r; a relation R . R(wrr) is oblivious to (preserved by) \nequal writes to any abstract location in r; and a relation R . R(alr) is oblivious to extensions of the \ncurrent world provided that they only add abstract locations in region r, that the initial contents of \nthese newly allocated locations are equal in the sense of (-)R , and that nothing else is changed. Finally, \nR(e) for a set of e.ects e is de.ned as follows: R(e) =R(E). E.e  As in our earlier work [7], the key \nidea is that computations with e.ect e will preserve all the heap relations that are preserved by all \nthe operations allowed by e. The larger the set of operations, the fewer relations need be preserved. \nDe.nition 6.12 (Monad). Let A be a p.p.f. and e an e.ect. A p.p.f. Te A is de.ned as follows: (Objects) \nElements of (Te A)w are pairs (c0, c1) of partial func\u00adtions where c0 : Sw Sw1.I(w, w1) \u00d7 Sw1 \u00d7 Aw1 and \nc1 is as follows. If R . R(e) and (h, h') . Rw then c1(R, h, h') either is unde.ned and c0(h) and c0(h') \nare both unde.ned or else c1(R, h, h') is de.ned and then c0(h) and c0 ' (h') are both de.ned, say c0(h) \n= (w1, u, h1, a) and c0(h') = (w1 ' , u ' , h1 ' , a '). In this x x case, c1(R, h, h') returns a pair \n(x(v ' ' , p) where w1 x(v ' ' w ' such v v 1 that xu = x ' u ' . Furthermore, p . Aw(x.a, x ' .a ') \nand, .nally, x (h1.v, h' 1.v ') . Rw where w and w are low point and apex of xv(v ' ' . (Proofs) Proofs \nonly look at the (-)0 components. Let c = (c0, ) . Te Aw and c ' = (c ' 0, ) . Te Aw, then a proof in \n(Te A)w(c, c ') is a partial (continuous) function \u00b5, such that for a given h . Sw: 1. if \u00b5(h) is unde.ned, \nthen c0(h) and c ' 0(h) are both unde.ned; 2. if \u00b5(h) is de.ned, then c0(h) = (w1, u, h1, a) and c0 \n' (h) = (w1 ' , u ' , h1 ' , a ') are both de.ned. In this case, \u00b5(h) returns a  x tuple (xv(v ' ' , \nq) satisfying xu = x ' u ' , q . Aw(x.a, x ' .a ') and x h1.v ~ h1.v ' in Sw, with w and w apex and low \npoint of xv(v ' ' . (Order) The order between computations is given point-wise: (c0, c1) = (c ' 0, c \n' 1) if and only if for any h . Sw we have c0(h) = c ' 0(h), which is de.ned as follows: for all h . \nSw if c0(h) is de.ned so is c ' 0(h). Moreover, if both c0(h) and c ' 0(h) are de.ned as c0(h) = (w1, \nu1, h1, a1) and c ' (h) = (w ' 1, u1 ' , h' 1, a ' ), then w1 = w1 ' , 0 1 u1 = u ' 1, h1 = h' and a1 \n= a ' . Finally, if c1(R, h, h') and c ' (R, h, h') 11 1 '' '' x1 x x2 x x1 x x2 x 12 12 are de.ned returning \n( ( ' , q) and ( ( ' , q '), then ( ' = ( ' v1 v v2 v v1 v v2 v 12 12 and q = q ' . 1 (Morphism part) \nLet x : w . w ' be a morphism and c = (c0, c1) . Te Aw. We are going to describe the .rst component of \n(c ' 0, ) = Te Ax(c). Given h . Sw ' write c0(h.x) = (w1, u, h1, a). Should this application be unde.ned \nso is c ' 0(h). Now, using Propo\u00ad u sition 6.3, complete u, x to a minimal pullback square x u ' (x ' \nwith u ' : w ' . w1 ' where w1 ' is the apex of this pullback. Now, obtain h' . Sw ' from h by overwriting \nwith h1.u using Corollary 6.10. Then paste h1 and h' (note that h1.u ~ h' .u by construction) using Lemma \n6.9 to yield the desired heap h' 1 . Sw ' 1. We then put c0(h) = (w1 ' , u ' , h1 ' , x ' .a). We omit \nthe remaining components and veri.cations. The proof of the following is tedious but straightforward \nand will be given in an extended version of this paper. Theorem 6.13. Te is the functor part of an e.ect-indexed \nstrong monad [8, 43]. This theorem means in particular, that each Te is a monad on the category of p.p.f. \ni.e., for each A there are natural transformation .A : A . Te A and \u00b5A : TeTe A . Te A subject to the \nusual laws and whenever e1 . e2 then there is a morphism Te1 A . Te2 A which interacts with the monad \ndata in the expected sense. Illustration Assume an initial heap h, where h(X) h. [1, 2, 3] and h(Y) h. \n[3, 2, 1], that is, h points to the lists [1, 2, 3] and [3, 2, 1] from concrete locations X and Y, respectively. \nMoreover, let c(h) = (w1, u, h1, (3, Y)) and c '(h) = (w ' 1, u ' , h' 1, (3, Z)), where ' 1 Strictly \nspeaking, q = q needs to be a tuple with the objects they are proving the equality of. h1(X) h. [1, \n2, 3, 4]; h1(Y) h. [3, 2, 1, 0]; and h1(Z) = [4, 2], while h' (X) h. [4, 3, 2, 1]; h' (Z) h. [3, 2, 1, \n3, 2, 1, 0]; and h' (W) = [0, 0]. 11 1 We can show that c and c ' are equal when given h. The proof is \nillustrated by the diagram below, where an arrow labeled with . denotes an inclusion and an arrow labeled \nwith a mapping, e.g., Z h. Y, denotes the corresponding renaming. w = u w = Zh.Y  w1 = {setX , setY \n, setZ } . {setX , setY } ' u {setX , setZ } . w ' = {setX , setZ , setW } 1 Zh.Y w = {setX , setY , \nsetZ , setW } Here, it is easy to check that h1 and h' 1 are equal when taken to the world w, as the \nconcrete locations X in h1 and h' 1 and Y in h1 and Z in h' 1 point to lists containing the same set \nof elements: {1, 2, 3, 4}and {0, 1, 2, 3}, respectively. Notice that the abstract locations setZ . w1 \nand setW . w1 ' are not taken into account. Moreover, the value (3, Y) is also equivalent to (3, Z) when \ntaken to the world w, as the morphism w ' 1 . w renames Z to Y, while the morphism w1 . w is an inclusion. \nWe see here that the use of setoids rather than plain sets or predomains is crucial. The proofs in Te \nA are clearly relevant as they explain in what way the abstract locations correspond to each other. Likewise, \nthe elements of |Te A| contain more information that the mere computation, i.e., the evolution of the \nheap. Namely, the world extension w1 will typically contain new abstract locations with new contracts \nthat can be arbitrarily complicated. Thus, it would not be possible to replace Te A with a simple logical \npredicate on actual computations. 7. Proof-relevant Logical Relations The structure identi.ed so far \nallows us to interpret our e.ect type system and the equational theory in the category of p.p.f. De.nition \n7.1 (type interpretation). A type interpretation consists of an assignment of a p.p.f. [A] to each basic \ntype A. Given a type interpretation we can then assign a p.p.f. [t] to each type the essential clause \nbeing [t1 -e [t1] . Tet2. We . t2] = also interpret a typing context G as the cartesian product over \nits y bindings: [G] = x.dom(G)[G(x)]. Lemma 7.2 (masking). Let r be a region. For world w de.ne w-r \nby removing all locations in r. If type t does not contain r then for each world w the morphism u.(-) \n: [t]w-r . [t]w where u : w-r . w is the obvious inclusion is an isomorphism. De.nition 7.3 (axiom interpretation). \nAn axiom interpretation consists of an element x(v,t) . |[t]\u00d8| (empty world) for each type axiom (v, \nt) and of an element p(v,v ' ,t) . [t]\u00d8(x(v,t), x(v ' ,t)) for each equality axiom (v, v ' , t). Given \nan axiom interpretation (and a type interpretation) and a well-typed term G f e : t &#38; e we de.ne \na morphism [G f e : t &#38; e] : [G] . Te[t] using the fact that all the typing rules are re.ected in \nthe seman\u00adtics: cartesian closure takes care of application and abstraction and variable management. \nThe .xpoint morphism YD takes care of re\u00adcursive de.nitions; the indexed monadicity of Te takes care \nof the rules associated with let and e.ect propagation. Lemma 7.2, .\u00ad nally, takes care of the masking \nrule. If G f v : t because of the ax\u00ad iom (v, t) then we put [G f v : t](.) = x(v,t) (constant morphism). \nE.ects Given a set of e.ects e, we write rds(e) = {r | rdr . e}, wrs(e) = {r | wrr . e}, als(e) = {r \n| alr . e} and regs(e) = rds(e).wrs(e).als(e). Moreover, the set nwrs(e) = regs(e)\\wrs(e). We also introduce \nthe following piece of notation for h, h' . Sw: h ~rds(e,w) h' .. .l . w(rds(e)).h ~lh' h ~nwrs(e,w) \nh' .. .l . w(nwrs(e)).h ~lh' which speci.es that the heaps h and h' are equivalent on all the abstract \nlocations l in regions associated to read e.ects in e and on the not write locations, respectively. \nx Lemma 7.4. Let G f e : t &#38; e. Let wxv(v ' ' w ' be a pullback square, . . [G]w, . ' . [G]w ' be \ncontexts, such that \u00b5. : x.. ~ x.. and c = [G f e : t &#38; e]w(.) . Te Aw and c ' = [G f e : t &#38; \ne]w '(. ') . Te Aw ' be computations, such that \u00b5 : x.c ~ x ' .c ' . Let h . Sw, h' . Sw ' be heaps, \nsuch that h.v ~rds(e,w) h' .v ' . Then c(h) and c '(h') co\u00adterminate. Moreover, if they do terminate \nand c(h) = (w1, u1, h1, a1) and c '(h') = (w ' 1, u ' 1, h1 ' , a ' 1), then the following diagram exists, \nin particular, the dashed arrows, where the following is satis.ed u1 . w w1    . x1 vx w  v1 .. \nw w1 w1 ' v ' 1 x v ' x . ' ' w ' . w1 1' u 1 1. x1.a ~ x ' 1.a ' , w = w . q, w ' = w . q ' , w1 = \nw . q . q1, w ' 1 = w . q ' . q ' 1, for some q1 and q ' 1;  2. for all l . w, we have either: h.v ~lh1.u1.v \nand h' .v ' ~lh1 ' .u1 ' .v ' ' '  (remain equivalent) or h1.u1.v1 ~lh1 ' .u1.v (equally modi.ed); \n3. if l . w(nwrs(e)), then h.v ~lh1.u1.v and h' .v ' ~lh' 1.u1 ' .v ' . 4. if als(e) = \u00d8, then there \nexists a morphism c* . [G] . Te[t], such that c* ~ c and if c*(w)(.)h = (w*, u*, h*, a*) then w* = w \n(no world extension is needed);  5. www1w1 and ww ' w1w ' 1 are pullbacks.  Proof The proof that the \nvalues are equal in w1 follows directly from the de.nition of computations and e.ects. For the item 2, \nwe use the following relation R de.ned as follows for all worlds w1, such that u : w . w1:  {(h1, h' \n) | h1.u ~rds(e,w) h1 ' .u . .l . w.(h1.u ~lh . h1 ' .u ~lh') . h1.u ~lh1 ' .u} 1 Otherwise, for the \nworlds w2 not reachable from w, the relation Rw2 is the trivial set. Notice that R . R(e) and it is contravariant. \nThe claim then follows directly by using the morphism from w . w1. The proof of item 3 follows in a \nsimilar fashion, but we use the following relation: {(h1, h' ) | h1.u ~rds(e,w) h' 1.u . h1.u ~nwrs(e,w) \nh} 1 And we use a similar relation for showing that h' and h' 1.u ' agree on the not written locations \nw(nwrs(e)). For item 4, .rst, we show that w(r) and w(r) are equal up to renaming for all regions r r \nals(r) by using the following relation Rq for some world q: {(h1, h' ) | h1 ~ h1 ' . .r r als(e).#r(q) \n= #r(w)} 1 where #r denotes the number of abstract locations colored with r. Clearly, R . R(e) as e does \nnot contain any allocation e.ects. Thus, the number of locations in w* is the same as the locations in \nw, by x using the pullback w1 1v(1w*. This gives us one direction, while the other direction is obtained \nby the universal property of pullbacks. Given this property, one can easily construct the function c*. \no  Theorem 7.5 (Equational soundness). Assume an ambient inter\u00adpretation of types and axioms. If G f \ne = e ' : t &#38; e then the mor\u00adphisms [G f e : t &#38; e] and [G f e ' : t &#38; e] are equal morphisms. \nProof By induction on derivations. The core rules are direct from the category-theoretic structure identi.ed \nso far. The e.ect-speci.c rules are nontrivial; however given Lemma 7.4, their proofs follow essentially \nthe same reasoning as in existing literature [6, 41]. As for the axiom rule we argue as follows. If G \nf v = v ' : t using the axiom (v, v ' , t) then we have [G f v : t](.) = x(v,t) and [G f v ' : t](.) \n= x(v ' ,t) and the constant function ...p(v,v ' ,t) is continuous and thus establishes the desired equality. \no 8. Observational equivalence We will now relate semantic equality to observational equiva\u00adlence. So \nfar, a trivial model that identi.es everything could also have been used to justify our rules. Doing \nthis, however, requires a loose relationship between the setoid interpretation and the com\u00adputational \nmeanings of raw terms which will be given by a realiz\u00adability relation. De.nition 8.1. For each type \nt, e.ect e, and world w we de.ne admissible relations It . C\u00d7 |Te[t]W| as W. V\u00d7 |[t]W| and It&#38;e W \n follows: If c . C then c Itw &#38;e (c0, c1) means that for each h . Sw one has c(h) de.ned i. c0(h) \nde.ned and if c(h) = (h1, a) then c0(h) = (w1, u, h1, a) (same h1) and h1 . Sw1 and a It a. w1 .t2 If \nfun( f ) . V and ( f0, f1) . |[t1 -e -e( f0, f1) . t2]w| then f It1 i. whenever u : w . w1 is an inclusion \nand a w Itw1 1 x then f (a) It2&#38;e f0(x). w1 . IG w . .. .(x) IGw (x) .(x) for all x . dom(G). Lemma \n8.2. The I relations are indeed admissible and are stable under inclusion; that is whenever v Iw X x \nand u : w . w ' is an inclusion then v IwX 1 u.x holds. The following soundness property of I is proved \nby straightfor\u00adward induction on typing derivations. Theorem 8.3 (Fundamental Lemma). Assume that the \ninterpreta\u00adtion of types and axioms is chosen such that for all type axioms (v, t) one has v It x(v,t). \nWhenever G f e : t &#38; e and . IG w . then [e]. Itw &#38;e [G f e : \u00d8 t]w(.). De.nition 8.4 (Observational \nequivalence). Two value expressions v, v ' where f v : t and f v ' : t are observationally equivalent \nat type t if for all f such that f f : t -e . unit ( observations ) it is the case that [f v]\u00d8 is de.ned \ni. [f v' ]\u00d8 is de.ned. (\u00d8 stands for empty heap and environment). It is easy to extend this de.nition \nto open terms and computation expressions by closing up with lambda abstractions. Intuitively, observationally \nequivalent expressions, can be replaced by one another in any context without compromising observable \nbehavior. To see this, one can build observations f from such a context by .rst .-abstracting its hole \nand then adding at the end a wrapper function that tests for some observable feature of the end result \nsignaling failure of the test by nontermination. Theorem 8.5 (main result). If f v = v ' : t then v and \nv' are observationally equivalent. Proof If f is an observation then by the congruence rules we get f \nf v = f v ' : t so, by Theorem 7.5 we .nd [f f v] = [f f v' ], thus in particular [f f v]\u00d8\u00d8 (empty world, \nempty heap) is de.ned i. [f f v' ]\u00d8\u00d8 is de.ned. Now, if [f v]\u00d8 is de.ned then by Theorem 8.3 and the \nde.nition of I we can conclude that [f f v]\u00d8\u00d8 is de.ned so, using Theorem 8.3 again we get that [ f v' \n]\u00d8 is de.ned. o 9. Applications In this section we give some concrete instantiations of our framework \nin the form of axioms and their semantic justi.cations. We do so in more detail for the Overlapping References \nexample shown in Section 2, and in less detail for the other examples. Overlapping References Recall \nvalue vor and type tor from Sec\u00adtion 2 (two overlapping references). In order to justify the axiom (vor \n, tor ) we have to construct a semantic object xor . [tor] such Itor that vor \u00d8 xor which we will now \ndo. Given world w we put xor (w)(*) = (c0, c1), where c0 and c1 are de.ned as follows (* . [unit]w): \nc0(h) = (u : w . w1, h1, (g1, g2, s1, s2)) where new(h, 0) = (X, h1), that is, h1 is obtained from h \nby allocat\u00ading a concrete location X; w1 is the world obtained by extending w with the abstract locations \nfstX and sndX de.ned in Section 4.1, where the former is marked with region r1 and the latter with re\u00adgion \nr2; .nally, (g1, g2, s1, s2) are the corresponding semantic ob\u00adjects that get and set values to the projections \nof pairs stored in X, rdr1 e.g., g1 . [(unit --. int)]w1 is the semantic counter part of the function \ngetting the .rst projection of the pair stored in X, de.ned in a similar way as we do for xor . Itor \nNote that vor \u00d8 xor in particular requires that the new heap returned by c0 agrees with the one returned \nby vor and, more generally, we are forced to follow the computational behavior of vor in xor. We are \nfree, though to choose the semantic components such as world extensions and, later, pullbacks. The object \nc1, now, is de.ned as follows: Assume that R . R({alr1, alr2}) is a heap relation and two heaps h, h' \n. Sw that are related, i.e., (h, h') . R. Moreover, assume that c0(h) = (u : w . w . fstX . sndX , h1, \n(g1, g2, s1, s2)) and c0(h') = (u : w . w . fstX' . sndX' , h' 1, (g1 ' , g ' 2, s1 ' , s ' 2)), where \nthe former allocates X, while the latter allocates X'. Note that everything terminates in this Xh.X ' \n1 example. Now c1(R, h, h') returns the pullback w1 ( 1, 1 Xh.X' w ' where X is mapped to X' . It is \neasy to check that h1 and h' 1 are related in R when taken to the pullback s low point and that (g1, \ng2, s1, s2) and (g ' 1, g2 ' , s ' 1, s ' 2) are equal in its apex. Note that once this typing has been \njusti.ed all equations deriv\u00adable from it are automatically sound for observational equivalence. Thus, \nin particular, writes to the two overlapping reference com\u00admute. Set factory Let w be a world and h . \nSw. Suppose that h1 arises from h by allocating a fresh set data structure, e.g., a linked list, with \nentry point X. Let setX be the abstract location describing this fresh data structure. Now for any chosen \nregion r we can add setX to r to yield a new world w1. The function setfactory0(w)(h) then returns w1 \nand a tuple of semantic functions for reading, membership, removal of which we only sketch reading here: \nIf u : w1 . w2 and h1 . Sw1 and i . Z then the reading function looks up i in the data structure starting \nat the entry points X in h1 (note that h1 . Sw asserts that this data structure exists and is well-formed. \nThe returned (abstract) store h2 might not be the same as h because internal reorganizations, e.g., removal \nof duplicates, might have occurred, but no world extension is needed and h1 ~ h2 holds. This together \nwith the fact that the outcome only depends on the setR X equivalence class (in the proof-relevant sense) \njusti.es a read-only typing for reading. Memoization For the simple memo functional from Section 2 we \nproduce just as in the previous example a fresh abstract location l whose speci.cation looks only at \nthe two newly allocated concrete locations, say lx, ly, where the .rst stores the argument value i and \nthe second the integer value f (i) where f is the pure function to be memoised. The location s l rely \nspeci.es that two heaps are equivalent when the values stored in lx and ly are the same: (h, h') . lR \n.. h(lx), h'(lx) . h(ly), h'(ly). We see in Lemma 7.4 that if a function is semantically pure (empty \ne.ect) then there is a world-and heap-independent function describing its action. Thus the memo functional \nmay be considered pure. 9.1 State Dependent Abstract Data Types Although our focus is on e.ect-dependent \nequivalences that can be derived from re.ned typings using our equational rules, we are able to justify \nsome of the well-known tricky examples from the literature on proving equivalences in ML-like languages \nwithout e.ect annotations. Our guarantee conditions here act like the transition system components of \nthe worlds used by Ahmed et al. [1, 19]. Awkward Example The .rst example is the classic awkward example \n[34]. Consider the following two programs: e1 = let x .ref(0)in . f.x := 1; f (); !x and e2 = . f. f \n(); 1. Intuitively, e1 and e2 are equivalent as they both return the value 1, although e1 uses a fresh \nlocation to do so. We can formally prove the equivalence as follows: Assign the region where x is allocated \nas r. If f has the type unit -e . unit with e.ects e, then e rdr ,wrr e1 has type (unit -----. int &#38; \ne, alr . unit) , while e2 has type (unit -e . unit) . int &#38; e. Notice that e may contain rdr or \nwrr or both. Moreover, assume that an abstract location in region r looks at a single concrete location \nl:  lR = {(h, h') | h(l) = h'(l)} lG = {(h, h1) | h1(l) = 1 . .l' * l.h(l') = h1(l')}Notice that it \nis correct to assign e1 a write e.ect in region r, as it writes the value 1 to the location assigned \nto x. For proving the equivalence of e1 and e2, assume a world w and a heap h. Let [e1]wh = (w 1w1 1wr, \nu1, h1, a1) and [e2]wh = (w 1 w1, u1, h2, a2). We construct a pullback square w 1 w1 1wr (w 1 w1 such \nthat the values a1 and a2 are equal in its apex and h1 and h2 are equal in its low point. Since wrr is \nin the e.ects of e1, we have that a1 = 1. We also have a2 = 1 trivially. Hence a1 and a2 are equal in \nthe apex of the pullback square w 1 w1 1 wr (w 1 w1. Similarly, h1 when taken to the low point of the \nsquare, that is, where the locations in wr are forgotten, the resulting heap is equivalent to h2. Modi.ed \nAwkward Example Consider now the following variant [1, 19] of the awkward example: e1 = let x .ref(0) \nin . f.x := 0; f (); x := 1; f (); !x e2 = . f. f (); f (); 1. The di.erence is that in the .rst program \nx is .rst assigned 0 and the call-back function is used twice. Interestingly, however, our solution for \nthe Awkward example still works just .ne. We can prove semantically that the type of the program e1 has \nthe same type as before in the Awkward example, where the only writes allowed on the abstract location \nassigned for x is to write the concrete location to one. Then the reasoning follows in a similar way. \nCallback with Lock Example We prove the equivalence of the following programs [1, 19]: e1 = let b.ref(true) \nin let x.ref(0) in (. f.if !b then (b := false; f (); x :=!x + 1; b := true) else (), . .!x> e2 = let \nb.ref(true) in let x.ref(0) in (. f.if !b then (b := false; let n.!x in f (); x := n + 1; b := true) \nelse (), . .!x>. Both programs produce a pair of functions, one that increments the value stored in x \nand the second that returns the value stored in x. They use the boolean reference b as lock in the incrementing \nfunction. In particular, once this function is called the value in b is set to false and only after the \ncall-back is called and the value in x is incremented is b set again to true. However, the implementation \nof the increment function is di.erent. While e1 invokes the call\u00adback f () and then increments the value \nin x, e2 remembers (in n) the value of x before the call-back and then uses n to update the value stored \nin x. Assume that x and b are allocated in the same location (l) in the region r. We show that these \nprograms are equivalent in the type e e,wrr,rdrrdr ((unit -- ----- . unit) &#38; alr, where e . unit) \n. unit) \u00d7 (unit may contain the e.ects wrr, rdr. In particular, the location l looks at two concrete \nlocations lb and lx (storing x and b): lR = {(h, h') | h(lb) = h'(lb) . h(lx) = h'(lx)} lG = {(h, h1) \n| h(lb) = false . h1 = h and (h(lb) = true . h1(lx) = i . h1(lx) = j) . [(h1(lb) = true) . ( j = i) . \n(.l' r {lx, lb}.h(l') = h1(l'))]}First, notice that indeed the two programs above have the e.ect wrr. \nThe increment of x is allowed by lG , as b is initially true. To show that the two programs above are \nequivalent, we show that the value stored in x before and after the call back is called remains the same. \nThis is the case, as even if the callback function has a write e.ect in the region r, i.e., wrr . e, \nit cannot change the value of x. This is because when the function is called, the value stored in b is \nfalse, meaning that the heap remains the same. Despite the above, the model as presented here does not \ndirectly justify equivalences involving representation independence, e.g., that our overlapping references \nvor are observationally equivalent to an implementation that really allocates two integer references. \nGeneralizing world morphisms as discussed after Def. 6.2 does allow many such equivalences to be proved, \nthough a parametric variant, along the lines of that described by Stark [39], would be more powerful \nstill. 10. Related and Future Work We have shown Proof-Relevant Logical Relations, introduced in our \nprevious work [4], can be used to justify nontrivial e.ect\u00addependent program equivalences. For the .rst \ntime it was possible to combine e.ect-dependent program equivalences with hidden in\u00advariants allowing \nsilent modi.cations that do not count towards the ascription of an e.ect. Earlier accounts of e.ect-dependent \npro\u00adgram equivalences [3, 6, 7, 26, 41] do not provide such possibilities. Bisimulation An alternative \napproach to proving di.cult con\u00adtextual equivalences is to use techniques based on bisimulation [27]. \nWhile bisimulation has been applied to typed calculi [24, 40] the strength of the method lies in being \nable to deal with fancy computation rules and fairly simple types and contracts rather than well-understood \ncomputation rules (call-by-value lambda calculus in our case) and fancy types and contracts. Indeed, \nwe believe that something like our abstract locations and the proof-relevant world extensions would also \nsuggest itself in a bisimulation-based ap\u00adproach to the equivalences studied here. Model Variables Proof-relevant \nlogical relations or rather the sets |Aw| where A is a semantic type bear a vague relationship with the \nmodel variables [15] from design by contract [32] and more generally data re.nement [16]. The commonality \nis that we track the semantic behavior of a program part with abstract functions on some abstracted set \nof data that may contain additional information (the model ). The di.erence is that we do not focus on \nparticu\u00adlar proof methods or speci.cation formalisms but that we provide a general, sound semantic model \nfor observational equivalence and program transformation and not merely for functional correctness. This \nis possible by the additional, also proof-relevant part of the semantic equality proofs between the elements \nof the models. We also note that our account rigorously supports higher-order func\u00adtions, recursion, \nand dynamic allocation. Separation Logic Our abstract locations draw upon several ideas from separation \nlogic [37], in particular the conditions on rely/guarantee assumptions from [42]. Intriguingly, we did \nnot need something resembling the frame rule although perhaps the .-quanti.cation over larger worlds \nin function spaces plays its role. Our use of pullback-preserving functors is motivated by FM\u00adsets [21] \nor rather the Schanuel topos to which they are equivalent. Pitts s [35] gives a comprehensive account. \nThe way in which we work with both permutation actions and functors has some precedent [9], but does \nfeel slightly awkward: it really ought to be possible to combine the two structures into one. We would \nlike to de.ne a stylized format that allows one to discharge semantic proof obligations in some cases \nwithout having to go down to the low-level semantic de.nitions. We noted that private transitions [1] \nserve a similar purpose and might perhaps suggest a possible approach in our case, too. We would also \nlike to be able to store values with proof-relevant equality, which would allow a strati.ed form of higher-order \nstore [12]. Unrestricted higher-order store requires circular de.nitions of worlds, which has previously \nbeen addressed using, for example, metric spaces [11]. Acknowledgments We thank Lennart Beringer and \nAndrew Kennedy for fruitful discussions. Nigam was supported by CAPES / CNPq and DAAD. References [1] \nA. Ahmed, D. Dreyer, and A. Rossberg. State-dependent representa\u00adtion independence. In POPL, 2009. [2] \nG. Barthe, V. Capretta, and O. Pons. Setoids in type theory. J. Funct. Program., 13(2):261 293, 2003. \n[3] N. Benton, L. Beringer, M. Hofmann, and A. Kennedy. Relational se\u00admantics for e.ect-based program \ntransformations: higher-order store. In PPDP, 2009. [4] N. Benton, M. Hofmann, and V. Nigam. Proof-relevant \nlogical rela\u00adtions for name generation. In TLCA, 2013. [5] N. Benton and C.-K. Hur. Biorthogonality, \nstep-indexing and compiler correctness. In ICFP, 2009. [6] N. Benton, A. Kennedy, L. Beringer, and M. \nHofmann. Relational semantics for e.ect-based program transformations with dynamic al\u00adlocation. In PPDP, \n2007. [7] N. Benton, A. Kennedy, M. Hofmann, and L. Beringer. Reading, writing and relations. In APLAS, \nvolume 4279 of LNCS, 2006. [8] N. Benton, A. Kennedy, and G. Russell. Compiling Standard ML to Java bytecodes. \nIn ICFP, 1998. [9] N. Benton and B. Leperchey. Relational reasoning in a nominal semantics for storage. \nIn TLCA, volume 3461 of LNCS, 2005. [10] L. Birkedal, A. Carboni, G. Rosolini, and D. S. Scott. Type \ntheory via exact categories. In LICS, 1998. [11] L. Birkedal, K. Stovring, and J. Thamsborg. The category-theoretic \nsolution of recursive metric-space equations. Theor. Comp. Sci., 411:4102 4122, 2010. [12] G. Boudol. \nTyping termination in a higher-order concurrent imperative language. Inf. Comput., 208(6), 2010. [13] \nC. Calcagno, P. W. O Hearn, and H. Yang. Local action and abstract separation logic. In LICS, pages 366 \n378, 2007. [14] A. Carboni, P. J. Freyd, and A. Scedrov. A categorical approach to realizability and \npolymorphic types. In MFPS, LNCS 298, 1987. [15] Y. Cheon, G. T. Leavens, M. Sitaraman, and S. H. Edwards. \nModel variables: cleanly supporting abstraction in design by contract. Softw., Pract. Exper., 35(6):583 \n599, 2005. [16] W. P. de Roever and K. Engelhardt. Data Re.nement: Model-oriented Proof Theories and \ntheir Comparison. Cambridge University Press, 1998. [17] T. Dinsdale-Young, P. Gardner, and M. J. Wheelhouse. \nAbstraction and re.nement for local reasoning. In VSTTE, volume 6217 of LNCS, 2010. [18] D. Dreyer, A. \nAhmed, and L. Birkedal. Logical step-indexed logical relations. Logical Methods in Computer Science, \n7(2), 2011. [19] D. Dreyer, G. Neis, and L. Birkedal. The impact of higher-order state and control e.ects \non local relational reasoning. In Proc. ICFP, ACM, pages 143 156, 2010. [20] J. N. Foster, M. B. Greenwald, \nJ. T. Moore, B. C. Pierce, and A. Schmitt. Combinators for bi-directional tree transformations: a lin\u00adguistic \napproach to the view update problem. In POPL, pages 233 246, 2005. [21] M. Gabbay and A. M. Pitts. A \nnew approach to abstract syntax with variable binding. Formal Asp. Comput., 13(3-5):341 363, 2002. [22] \nD. K. Gi.ord and J. M. Lucassen. Integrating functional and impera\u00adtive programming. In LISP and Functional \nProgramming, 1986. [23] C.-K. Hur and D. Dreyer. A Kripke logical relation between ML and assembly. In \nPOPL, 2011. [24] C.-K. Hur, D. Dreyer, G. Neis, and V. Vafeiadis. The marriage of bisimulations and kripke \nlogical relations. In J. Field and M. Hicks, editors, POPL, pages 59 72. ACM, 2012. [25] J. B. Jensen \nand L. Birkedal. Fictional separation logic. In ESOP, volume 7211 of LNCS, 2012. [26] O. Kammar and G. \nD. Plotkin. Algebraic foundations for e.ect\u00addependent optimisations. In POPL, 2012. [27] V. Koutavas \nand M. Wand. Small bisimulations for reasoning about higher-order imperative programs. In POPL, 2006. \n[28] N. Krishnaswami, L. Birkedal, and J. Aldrich. Verifying event-driven programs using rami.ed frame \nproperties. In TLDI, 2010. [29] N. Krishnaswami, A. Turon, D. Dreyer, and D. Garg. Super.cially substructural \ntypes. In ICFP, 2012. [30] R. Ley-Wild and A. Nanevski. Subjective auxiliary state for coarse\u00adgrained \nconcurrency. In POPL, 2013. [31] S. Mac Lane. Categories for the Working Mathematician. Graduate Texts \nin Mathematics. Springer, 2nd edition, Sept. 1998. [32] B. Meyer. Applying design by contract . IEEE \nComputer, 25(10):40 51, 1992. [33] F. Oles. A Category-Theoretic Approach to the Semantics of Program\u00adming \nLanguages. PhD thesis, CMU, 1982. [34] A. Pitts and I. Stark. Operational reasoning for functions with \nlocal state. In Higher order operational techniques in semantics, pages 227 273. Cambridge University \nPress, 1998. [35] A. M. Pitts. Nominal Sets: Names and Symmetry in Computer Science, volume 57 of Cambridge \nTracts in Theoretical Computer Science. Cambridge University Press, 2013. [36] A. M. Pitts and I. D. \nB. Stark. Observable properties of higher-order functions that dynamically create local names, or what \ns new? In MFCS, volume 711 of LNCS, 1993. [37] J. C. Reynolds. Separation logic: A logic for shared mutable \ndata structures. In LICS, 2002. [38] J. Schwinghammer, L. Birkedal, B. Reus, and H. Yang. Nested Hoare \ntriples and frame rules for higher-order store. Logical Methods in Computer Science, 7(3), 2011. [39] \nI. Stark. Names and Higher-Order Functions. PhD thesis, U. Cam\u00adbridge, 1994. [40] E. Sumii and B. C. \nPierce. A bisimulation for type abstraction and recursion. In POPL, 2005. [41] J. Thamsborg and L. Birkedal. \nA Kripke logical relation for e.ect\u00adbased program transformations. In ICFP, 2011. [42] V. Vafeiadis and \nM. J. Parkinson. A marriage of rely/guarantee and separation logic. In CONCUR, volume 4703 of LNCS, 2007. \n[43] P. Wadler and P. Thiemann. The marriage of e.ects and monads. ACM Trans. Comput. Log., 4(1):1 32, \n2003.   \n\t\t\t", "proc_id": "2535838", "abstract": "<p>We give a denotational semantics for a region-based effect system that supports type abstraction in the sense that only externally visible effects need to be tracked: non-observable internal modifications, such as the reorganisation of a search tree or lazy initialisation, can count as 'pure' or 'read only'. This 'fictional purity' allows clients of a module to validate soundly more effect-based program equivalences than would be possible with previous semantics. Our semantics uses a novel variant of logical relations that maps types not merely to partial equivalence relations on values, as is commonly done, but rather to a proof-relevant generalisation thereof, namely setoids. The objects of a setoid establish that values inhabit semantic types, whilst its morphisms are understood as proofs of semantic equivalence. The transition to proof-relevance solves twoawkward problems caused by na&#239;ve use of existential quantification in Kripke logical relations, namely failure of admissibility and spurious functional dependencies.</p>", "authors": [{"name": "Nick Benton", "author_profile_id": "81100165244", "affiliation": "Microsoft Research, Cambridge, United Kingdom", "person_id": "P4383919", "email_address": "nick@microsoft.com", "orcid_id": ""}, {"name": "Martin Hofmann", "author_profile_id": "81452607849", "affiliation": "LMU, Munich, Germany", "person_id": "P4383920", "email_address": "hofmann@ifi.lmu.de", "orcid_id": ""}, {"name": "Vivek Nigam", "author_profile_id": "81350578292", "affiliation": "UFPB, Jo&#227;o Pessoa, Brazil", "person_id": "P4383921", "email_address": "vivek.nigam@gmail.com", "orcid_id": ""}], "doi_number": "10.1145/2535838.2535869", "year": "2014", "article_id": "2535869", "conference": "POPL", "title": "Abstract effects and proof-relevant logical relations", "url": "http://dl.acm.org/citation.cfm?id=2535869"}