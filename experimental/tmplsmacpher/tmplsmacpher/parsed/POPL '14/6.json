{"article_publication_date": "01-08-2014", "fulltext": "\n A Type-Directed Abstraction Re.nement Approach to Higher-Order Model Checking Steven J. Ramsay Robin \nP. Neatherway C.-H. Luke Ong University of Oxford University of Oxford University of Oxford steven.ramsay@cs.ox.ac.uk \nrobin.neatherway@cs.ox.ac.uk luke.ong@cs.ox.ac.uk Abstract The trivial-automaton model checking problem \nfor higher-order re\u00adcursion schemes has become a widely studied object in connection with the automatic \nveri.cation of higher-order programs. The prob\u00adlem is formidably hard1: despite considerable progress \nin recent years, no decision procedures have been demonstrated to scale ro\u00adbustly beyond recursion schemes \nthat comprise more than a few hundred rewrite rules. We present a new, .xed-parameter polyno\u00admial time \nalgorithm, based on a novel, type directed form of ab\u00adstraction re.nement in which behaviours of a scheme \nare distin\u00adguished by the abstraction according to the intersection types that they inhabit (the properties \nthat they satisfy). Unlike other intersec\u00adtion type approaches, our algorithm reasons both about acceptance \nby the property automaton and acceptance by its dual, simultane\u00adously, in order to minimize the amount \nof work done by converging on the solution to a problem instance from both sides. We have con\u00adstructed \nPREFAC E, a prototype implementation of the algorithm, and assembled an extensive body of evidence to \ndemonstrate em\u00adpirically that the algorithm readily scales to recursion schemes of several thousand rules, \nwell beyond the capabilities of current state\u00adof-the-art higher-order model checkers. Categories and \nSubject Descriptors F [3]: 1; D [2]: 4 Keywords higher-order model checking; intersection types; ab\u00adstraction \nre.nement 1. Introduction Higher-order model checking, or the model checking problem for trees generated \nby higher-order recursion schemes (HORS), is a widely studied decision problem in connection with the \ntheory and practice of the veri.cation of higher-order programs. Since HORS are simultaneously very expressive \n[21], algorithmically well-behaved [20], and able to accurately model higher-order con\u00ad trol .ow [8], \nthey are an appealing target for algorithmic veri.ca\u00ad tion procedures for functional programs [12, 16, \n17, 22, 26]. In\u00ad deed, in a precise sense, HORS are the higher-order analogue of Boolean programs, which \nhave played a very successful r ole in the veri.cation of .rst order, imperative programs [1]. Permission \nto make digital or hard copies of all or part of this work for personal or classroom use is granted without \nfee provided that copies are not made or distributed for pro.t or commercial advantage and that copies \nbear this notice and the full citation on the .rst page. Copyrights for components of this work owned \nby others than the author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, \nor republish, to post on servers or to redistribute to lists, requires prior speci.c permission and/or \na fee. Request permissions from permissions@acm.org. POPL 14, January 22 24, 2014, San Diego, CA, USA. \nCopyright is held by the owner/author(s). Publication rights licensed to ACM. It is for these reasons, \nand despite the severe worst-case com\u00adplexity of the problem1, that several ingenious algorithms [3, \n4, 12, 13, 19] have recently been developed with the aim of solving the higher-order model checking problem \nfor many practical in\u00adstances. However, the state of this effort is summarised well by the authors of \n[3]: The state-of-the-art model checker TRE CS [12] can han\u00ad dle a few hundred lines of HORS generated \nfrom various program veri.cation problems. It is, however, not scalable enough to support automated veri.cation \nof thousands or millions of lines of code. Thus, obtaining a better higher\u00adorder model checker is a grand \nchallenge in the .eld... Our main contribution is a new algorithm for higher-order model checking and \na large body of evidence to show empirically that it scales well to HORS consisting of several thousand \nrules. In contrast, the largest instances considered in the literature to date are of the order of several \nhundred rules. By way of an example, the order-2 benchmark G2,10000 of Kobayashi [12], which consists \nof 10006 rules, can be processed by our prototype implementation in less than one minute. Our algorithm, \nwhich decides the HORS model checking prob\u00adlem with respect to alternating trivial tree automata, has \nbeen de\u00adsigned to be scalable. Since the inherent worst-case complexity of HORS model checking is extreme, \nto have any chance at all of solv\u00ading non-trivial instances, one has to work in the belief that those \ninstances that are met in practice are not pathological. Hence, it is essential to ensure that only work \nthat is relevant to deciding the particular instance at hand is actually computed. To help achieve this \ngoal, our algorithm is designed in the abstraction re.nement paradigm [6]. Initially a relatively cheap \nbut coarse-grained ap\u00ad proximation to the problem is processed and, as much as possible, detail is only \nadded by successive iterations where the problem in\u00adstance necessitates it. Moreover, it can be shown \nthat our algorithm is .xed-parameter polynomial time in the size of the scheme; the parameters that are \n.xed are the order and arity of the scheme, and the size of the tree automaton. Our algorithm exploits \nthe characterisation of higher-order model checking as an intersection type inference problem [11, 14], \nrepresenting the state of knowledge about the behaviours of the recursion scheme as a pair of type environments, \ncalled the con\u00adtext, which assigns intersection types to the non-terminals of the scheme. As the algorithm \nprogresses, the number of types (and hence state of knowledge) in the environments increases, until after \nsome .nite number of iterations there will be enough type informa\u00adtion to decide the property one way \nor the other. Furthermore, this limit context will form a certi.cate of the decision that is indepen\u00addently \nveri.able by intersection type checking. ACM 978-1-4503-2544-8/14/01. . . $15.00. http://dx.doi.org/10.1145/2535838.2535873 \nn-EXPTIME complete for recursion schemes of order n [15, 20] In order to gain more information and thus \npopulate the context, each iteration consists of constructing a sound abstraction of the con.guration \ngraph [12] of the scheme. Since recursion schemes have no facility to inspect the data that they operate \nover, the be\u00adhaviours of the scheme arise from the complex interactions be\u00adtween higher-order functions. \nHence, we have designed this ab\u00adstraction around a traditional CFA [10], but with an important twist: \nin our abstraction, parameters to function calls are distinguished ac\u00adcording to the intersection types \nthat they inhabit, in other words, according to the properties that they satisfy. This is, in turn, a \nfunc\u00adtion of the context and hence, as the algorithm progresses and the size of the context increases, \nso the abstractions become more pre\u00adcise, as they are able to distinguish more instances of function \ncalls. Such an abstract con.guration graph is a concise but approxi\u00admate representation of all the possible \nreduction sequences of the scheme. Through its analysis, the algorithm can classify certain be\u00adhaviours \nthat can be seen to generate trees that are accepted by the property automaton and certain other behaviours \nthat can be seen to generate trees that are rejected by the property automaton. From the former it is \nable to extract new acceptance types and from the latter new rejection types and both are added to the \ncontext ready to proceed with the next iteration. Indeed, a key feature of the algorithm, and a novelty \namong intersection type based deci\u00adsion procedures, is that it uses types to reason both about property \nautomaton acceptance and rejection, simultaneously. We have implemented the algorithm in a tool, PR EFAC \nE, and evaluated its performance over the several hundred problem in\u00adstances that are now either recorded \nin the literature or which have resulted from veri.cation tools for higher-order programs. These instances \nrange from a few tens of rules to several thousands and from .rst order schemes up to .fth order, and \na few beyond. The results show very clearly that, whilst PREFAC E is sometimes a lit\u00adtle slower than \nother model checkers on examples up to around one hundred rules, its great strength is in solving examples \nof many hundreds of rules, where it performs consistently better than other model checkers, and several \nthousands of rules, which are typically instances that it alone can solve. Outline The rest of the article \nis structured as follows. In section 2 we .x notation and preliminary de.nitions. In section 3 we give \nan informal outline of the algorithm by means of an example. In section 4 the algorithm is de.ned formally. \nIn section 5 we discuss our prototype implementation and present a digest of the empirical evaluation \nand associated analysis. In section 6 we discuss related work. All proofs of claims in the text are relegated \nto the appendix of the long version of this work [24], which also includes a guided run of the algorithm \non a second example instance and a full transcript of the empirical evaluation. 2. Preliminaries We assume \nthroughout a denumerable set (F, G, H .) F of function symbols and a disjoint, denumerable set (x, y, \nz .) V of variables. Labelled trees Let A be a set without restriction. An A-labelled tree is a partial \nfunction T : N* . A whose domain is pre.x closed. In case the set A is ranked, that is, each symbol a \n. A has a speci.ed arity arity(a) . N, then the tree T can be said to be well-ranked just if, whenever \nT (w) = a and arity(a) = n then: w \u00b7 i . dom(T ) iff i . [1..n]. Simple kinds. The simple kinds2 over \nthe kind of trees o, denoted (. .) S, are formed by the grammar . ::= o | .1 . .2. As 2 These are nothing \nmore than the simple types over the base type o, but we prefer to use the word kind to avoid con.ict \nwith intersection type later. usual, we use parentheses to disambiguate the structure of such expressions, \nobserving that the arrow associates to the right. The arity and order of a simple kind are natural numbers \nde.ned as usual. If a simple kind has order 0 (and hence has arity 0) we say that it is ground. Raw terms. \nLet (a, b, c .) S be a set of atomic constants. The set of raw terms over S, denoted (s, t, u, v .) TS(F, \nV), is de.ned by the grammar: s, t ::= x | F | c | s t The free variables of a term t, denoted FV(t), \nis just the set of variables that occur in t. A term t with FV(t) empty is called closed and the set \nof all closed terms is denoted TS(F). We denote the set of closed terms which, moreover, contain no occurrences \nof function symbols by TS. In case the atomic constants are said to be kinded we assert that there is \nan associated kinding function kind which maps each constant c . S to a .rst-order kind in S. Kinded \nterms. A kind environment ., is a .nite, partial function from V . F to S. A kind judgement is an expression \nof the form . f t : .. We omit the standard de.nition of kind assignment to terms, i.e. simple type assignment. \nRecursion Schemes. A higher-order recursion scheme (HORS) G is a tuple (S, N , R, S ) in which: The \nalphabet of terminal symbols (a, b, c .) S is a .nite set of .rst-order, kinded constants.  The alphabet \nof non-terminal symbols, (F, G, H .) N , is a .nite set of kinded function symbols, disjoint from S. \nWe will sometimes view N as a kind environment mapping non\u00adterminals F . N to their kinds kind(F ). \n The rewrite rules, R, comprise a function mapping each non\u00adterminal symbol F of kind .1 . \u00b7 \u00b7 \u00b7 . .n \n. o to an expres\u00adsion .x1 \u00b7 \u00b7 \u00b7 xn . t, such that:  x1 : .1, \u00b7 \u00b7 \u00b7 , xn : .n f t : o is a provable assignment \nof kinds to terms. We will often write (F, .x1 , . . . , xn . t) . R as an equation F = .x1 , . . . , \nxn . t. The start symbol, S . N , is a non-terminal symbol of kind o. Each recursion scheme is assigned \nan order which is given by the maximum order of (the kind of) its non-terminal symbols. Recursion schemes \nhave a simple notion of reduction, which is de.ned as the contextual closure of the following rule: R(F \n) = .x1 \u00b7 \u00b7 \u00b7 xn . t F s1 \u00b7 \u00b7 \u00b7 sn . t[s1/x1, . . . , sn/xn] For the purposes of model checking, we are \ninterested in the trees generated by the scheme. The value tree of a scheme G, denoted Tree(G) is the \n(possibly in.nite) term tree obtained by reducing the start symbol ad in.nitum. To account for the possibility \nof in.nite, unproductive recursion, the value tree is de.ned as follows. First, introduce a new symbol \nof zero arity, ., into S and consider the least preordering of S that asserts . = a for all a . S. Next, \nfor each closed term t of ground type, de.ne t. recursively by: (i) (F s1 \u00b7 \u00b7 \u00b7 sn ). = . and (ii) (a \ns1 \u00b7 \u00b7 \u00b7 sn ). = a s 1 . \u00b7 \u00b7 \u00b7 sn . . This mapping sends each term to well-ranked tree in the complete \npartial order of S . .-labelled trees, which are ordered by letting T1 . T2 just if, for all p . dom(T1), \nT1(p) = T2(p). Finally, we . set Tree(G) = {t. | S . * t}. Example 1. Consider the .rst-order scheme \nover terminal symbols a : o . o . o, b : o . o and c : o in which the non-terminal symbols S : o and \nF : o . o are de.ned by the equations:  S = F c a F = .x. a x (F (b x )) c a  By reducing ad in.nitum, \nthe start symbol S generates an in\u00ad a .nite a, b and c-labelled tree, a b pre.x of which is depicted \non c .the right. This tree has no .-b . .labelled nodes since every redex b contraction produces a new \nter\u00adminal symbol in head position. c Positive Boolean formulae. Given a .nite set X, the positive Boolean \nformulas over X, denoted (f .) B+(X), are de.ned by the grammar f ::= t | f | x | f1 . f2 | f1 . f2. \nGiven a positive Boolean formula f, an assignment is a .nite subset S of X. An assignment S is said to \nbe a satisfying assignment for f, written S |= f, when assigning t to elements of S and f to elements \nof X \\ S makes f true. Alternating (co-)trivial tree automata. An alternating (co-)trivial tree automaton \n(ATT) A is a tuple (S, Q, d, q0, F ) in which S, is a .nite set of ranked constants, (q .) Q, is a .nite \nset of states, the transition function, d, is a function in .(q,a).Q\u00d7S \u00b7 B+([1..arity(a)] \u00d7Q), the initial \nstate is q0 . Q and the accepting states, F , are either all of Q or empty. In case F = Q, we say that \nthe ATT has a trivial acceptance condition, otherwise F = \u00d8 and we say that it has a co-trivial acceptance \ncondition. More often than not we will simply introduce a given automaton as a trivial or a co-trivial \nautomaton and omit the .nal component. Furthermore, when specifying particular automata, we will elide \nclauses of the transition function whose image is f. Given a S-ranked and labelled tree T , a run tree \nof A on T is a (dom(T ) \u00d7 Q)-labelled, unranked tree R satisfying: (APT-1) R(E) = (E, q0) ' (APT-2) For \nall w . N*, if R(w) = (w, q) then there is some set ' S that satis.es d(q, T (w)) and, for all (i, q') \n. S, there ' exists some j . Nsuch that R(w \u00b7 j) = (w\u00b7 i, q'). We say that a run tree R is accepting \njust if, on every in.nite branch of R, there is some state q . F which occurs in.nitely often. The language \nof an ATT A, L(A), is the set of S-ranked and labelled trees T for which there exists an accepting run-tree \non T . We de.ne the complement of A, denoted Ac, by the standard de Morgan dual construction, which ensures \nthat L(A)c = L(Ac) [18]. Note, the dual of an ATT with a trivial acceptance condition is an ATT with \na co-trivial acceptance condition. Example 2. Consider the ATT over the states q0, q1, q2 and q3, in \nwhich the transition function is de.ned by the following clauses: d(q0, a) = ((1, q1) . (2, q0)) . (2, \nq2) d(q1, b) = (1, q3) d(q1, c) = t ( , q0) d(q2, a) = (1, q1) . (2, q0) d(q3, b) = (1, q1) (1, q1) \n(2, q0) This ATT accepts those trees that have an in.nite a-labelled spine and of every two consecutive \n(22, q2) branches off the spine, at least one is required to be labelled by (221, q1) . an even number \nof b nodes termi-. . nated by a c. A pre.x of the run tree over the tree generated by the (2211, q3) \nscheme in Example 1 is depicted to the right. (22111, q1) Higher-order model checking. We de.ne A. as \nthe ATT A augmented with extra transitions so as to accept the symbol . from every state. The ATT-model \nchecking problem for HORS is, given a HORS G and an ATT A, to determine the truth of the assertion Tree(G) \n. L(A.). Intersection types. In what follows .x an ATT A. We consider in\u00adtersection types [7]. As is \nusual in the higher-order model checking literature, we make a distinction between strict types and intersec\u00adtion \ntypes (borrowing the terminology from van Bakel [27]). The intersection types over A, denoted IA, are \nde.ned simultaneously with the strict types over A by the following grammar: (S T R I C T TY P E S ) \nt ::= q | s . t q n (I N T E R S E C T I O N TY P E S ) s ::= i=1 ti in which q . Q and n = 0. We will \nuse t and s to denote strict and intersection types respectively. When we are agnostic about whether \na particular expression is either a strict type or an intersec\u00adtion type we will say it is simply a type \nand denote it by .. When no confusion can arise, we will typically write T for the empty in\u00adtersection, \nan intersection containing two elements in.x as t1 . t2 and an intersection of the singleton set containing \nt simply as t . q n Given an intersection s = i=1 ti we will often identify s with its set of conjuncts \n{t1, . . . , tn}, writing assertions such as t . s and s1 . s2 with the obvious interpretation. Finally, \nwe shall have no qualms about constructing the intersection of intersection types, since this can be \ngiven naturally as the intersection of the union over their respective strict conjuncts. Intersection \nsubtyping. There is a natural subtype preorder on intersection types, which was .rst explicitly considered \nby Baren\u00addregt, Coppo and Dezani-Ciancaglini in [2]. We shall use the fol\u00ad lowing variant, de.ned inductively \nby the following clauses. (Q-BA S ) q = q (Q-A R R ) if s2 = s1 and t1 = t2 then s1 . t1 = s2 . t2 q \nn (Q-PR J ) for all i . [1..n], j=1 tj = ti q n (Q-GL B ) if, for all i . [1..n], s = ti, then s = j=1 \ntj (Q-TR S ) if .1 = .2 and .2 = .3 then .1 = .3 Intersection type environment. An intersection type \nenvironment G is a .nite, partial function from F . V to IA. We will often view type environments as \ntotal functions assigning G(F ) = T whenever F ./dom(G). We will write G1 l G2 for the operation sometimes \ncalled type environment multiplication, which is just the pointwise combination of environments de.ned \nby: (G1 l G2)(F ) = G1(F ) . G2(F ) and write G1 . G2 just if there is some G' and G1 l G' = G2. We will \nwrite G I X for the restriction of G to only those typings whose subject lies in X. Finally, we also \nextend the subtype relation to environments pointwise, writing G1 = G2 just if, dom(G2) . dom(G1) and, \nfor all . . dom(G2), G1(.) = G2(.). Intersection type assignment. An intersection type judgement is an \nexpression of the form G f t : t (with t a strict type) whose derivations are de.ned inductively by the \nsystem in Figure 1. Note that in that system, we use the notation S|i to denote the set {q | (i, q) . \nS}. Given a type environment G and a term t, we de.ne the set of all strict types assignable to t under \nG by: T(G)(t) = {t | G f t : t }  q( T-VA R ) n G, x : i=1 ti f x : ti q( T-FU N ) n G, F : i=1 ti f \nF : ti S |= d(q, c) qq(T-C S T ) G f c : (S|1) . \u00b7 \u00b7 \u00b7 . (S|n) . q G f s : s . t G f t : t ' [.t ' . \ns '] s ' = s (T-AP P ) G f s t : t Figure 1. Assignment of types to terms. reduction) trees that are \naccepted by the automaton from state q. An intersection such as q1 . q2, is the type of all terms that \ngenerate trees that are accepted both from state q1 and from state q2. Finally, an arrow such as q1 . \nq2 . q is the type of those terms which, when applied to a term that generates a tree accepted from q1 \nand q2, will, as an application, generate a tree accepted from state q. In this work we will be concerned \nboth with type assignment in the intersection type system induced by property automaton A and type assignment \nin the intersection type system induced by the dual of this automaton Ac. Hence, whenever needed we will \ntry to disambiguate which notion of type assignment we are referring to by annotating the notation with \nA or Ac . Intersection re.nement types. The intersection re.nement types over Q are those types . for \nwhich there is some kind . such that . :: ., pronounced s re.nes . , is provable in the system of kind \nassignment below. The strict re.nement types over Q are de.ned as the obvious restriction of this system. \nWe lift the re.nement relation to environments by writing G :: . just if, for all F : s . G, there is \na typing F : . . . and s :: .. Type environment consistency. We say that an intersection type environment \nG is (G,A)-consistent just if, for each typing F : s . G such that F . dom(N ), there is a possibly in.nite \nwitness, rooted at G C F : s, and built according to the following system: R(F ) = .x1 . . . xn . t G1 \nG G1 C F : t1 G, x1 : s1, . . . , x1 : sn f t : q \u00b7 \u00b7 \u00b7 G C G : s (.G : s . G) Gn G G1 C F : tn q n G \nC F : s1 . \u00b7 \u00b7 \u00b7 . sn . q G C F : i=1 ti Similarly, we say that an intersection type environment G is \n(G,A)\u00adco-consistent just if, for each typing F : s . G there is a strictly .nite witness built from the \nabove system. The next theorem fol\u00adlows from Kobayashi and Ong [14]. Theorem 1. Fix a scheme G and ATT \nA. (i) Tree(G) . L(A.) iff there exists (G, A)-consistent G :: N and q0 . G(S). (ii) Tree(G) . L((A.)c) \niff there exists (G, Ac)-co-consistent G :: N and q0 . G(S).  3. Type directed abstraction re.nement \nThe starting point for the algorithm is the characterisation of the trivial automaton model checking \nproblem for recursion schemes given in Theorem 1. Our algorithm tries to prove (a) Tree(G) . (K-BA S \n) q :: o s :: .1 t :: .2 ( K -A R R ) s . t :: .1 . .2 ti :: . (i . [1..n]) q(K-IN T ) n ti :: . i=1 \nFigure 2. Assignment of kinds to types. )c L(A.) and (b) Tree(G) . L((A. ) simultaneously, by itera\u00ad \ntively constructing two type environments G. and G. which are possible witnesses to (a) and (b) respectively. \nSince an invariant of the algorithm is that G. is always (G, A)-consistent and G. is al\u00adways (G, Ac)-co-consistent, \nit follows that at most one of the two environments can prove the type assignment S : q0; in fact, upon \ntermination, exactly one of the two will do so. Since the two type systems A and Ac share the same underlying \nset of types, let us call an intersection type an acceptance type when we regard it as part of the system \nA and let us call it a rejection type when we regard it as part of the system Ac . The algorithm starts \nwith G0 . = G. 0 = \u00d8, which is trivially (co-)consistent. On each iteration, new type assignments are \nin\u00adferred which will be added to one or the other of the environments. The way that these new types are \ninferred is by, on each iteration, constructing and interrogating an auxiliary structure, called the \nab\u00adstract con.guration graph. As its name suggests, this graph is an abstraction and the precision of \nthe abstraction is a function of the size of the type environments G. and G.. The more precise the abstraction \nthe more useful the type information that can be de\u00adduced by interrogating it. Hence, starting from the \nempty context, C0 = (G0 ., G. 0 ), the abstraction re.nement cycle continues as fol\u00adlows. In iteration \ni + 1 with context Ci = (Gi ., G. i ), the abstract con.guration graph is constructed. Two subgraphs \nare then carved out called the accepting and rejecting regions. These regions are the parts of the graph \nfrom which it is possible to obtain consistent ac\u00adceptance typings and co-consistent rejection typings \nrespectively. Types are then extracted from the regions and added to context Ci (Gi+1 , Gi+1 to form \na strictly larger context Ci+1 = . . ). If one of these two environments can already type S : q0 then \nthe algorithm terminates. Otherwise the cycle repeats and, since Ci+1 is strictly larger, the abstract \ncon.guration graph constructed in iteration i+ 2 will be strictly more precise, and new type information \nwill be de\u00adduced. Since there are only .nitely many intersection re.nement types associated with a given \nscheme one of the environments will be eventually become saturated and thus witness the corresponding \nassertion (a) or (b). The con.guration graph of a model checking problem instance was introduced by Kobayashi \nand Ong in [12, 14]. It is a kind of product construction, pairing up the reduction relation of the scheme \nand the transition function of the property automaton and it takes the shape of a rooted, directed graph. \nSince we are solving the alternating trivial automaton model checking problem for recur\u00adsion schemes, \nthe con.guration graphs that we are interested in are something in between the simple ones of [12], which \nare appropri\u00ad ate to deterministic trivial automaton properties, and the much more complicated ones of \n[14], which are appropriate to alternating par\u00ad ity automaton properties. Moreover, we shall not be interested \nin the con.guration graphs themselves, which are in general in.nite, but rather in .nite abstractions. \n Bindings: y0 . D y0 . B y0 y1 . d  step that we take is to record the acceptance type and rejection \ntype of the new variable y0. The acceptance type (respectively rejection type) of y0 is just the intersection \nof types assignable to the term that it has been introduced to represent, in other words, qq = = (G0 \n.)(D) of such variables will later determine when new variables should be created in order to represent \nactual parameters, as y0 was here, or if variables created previously should be reused. The frontier \nof our construction so far consists of a terminal TA headed con.guration. The successors of a con.guration \nof the form (a s1 \u00b7 \u00b7 \u00b7 sn , q) depend upon the satisfying assignments to d(q, a). For each satisfying \nassignment S there is one succes\u00adsor, which is the set of con.gurations {(si, q ' ) | (i, q ' ) . S}. \nIn this case, d(q, a) is satis.ed just if the .rst argument of a is accepted from q0, the second argument \nis accepted from TA T (respectively T). The types c (G0 .)(D) {(y0, q0), (B d , q0), (F (B y0 ), q0)} \nq0 and the third argument is accepted from q0. Consequently, the set is {(y0, q0), (B d , q0), (F (B \ny0 ), q0)}. Such a set {(t1, q1), . . . , (tn, qn)} should be read as there is some i such that fGt. \niA : qi is not provable . The successors of the set are Figure 3. An abstract con.guration graph. Consider \nthe following model checking instance, consisting of state trivial automaton A: recursion scheme over \nthe terminal symbols and and a two-G da d(, d)S F D tq== 1 d() (1)F .(B d ) (F (B x )) q, a= , q= x a \nx 0 0. B .B z .(2)= z , q. 0 D d .(3)= , q0 As described above, the algorithm begins with the initial \ncontext C0 . . new type assignments it constructs the abstract con.guration graph , which is given in \nfull in Figure 3The construction ACG(C).0 of the graph starts at the root, which is a vertex labelled \n(S, q).0 A = (G0 ., G. 0 ) consisting of G0 = \u00d8 and G0 = \u00d8. In order to infer Every vertex of the graph \nis either labelled by a pair (t, q) of a ground kind term and a state, called a con.guration, or by a \n.nite set of such con.gurations. If there is a vertex (t, q) in a graph ACG((G., G.)), then it should \nbe read as neither G. ft : q nor those con.gurations (t, q) in the set which are not provable in either \nG. or G.. So let us now consider the frontier con.guration (F (B y0 ), q0). Since it is a non-terminal \nheaded con.guration, if it has a successor then the successor abstractly represents the contraction in \nthe same way as before. However, since the actual parameter B y0 has the same acceptance type and rejection \ntype as the previous one that we considered, D (and is the same kind), we will not create a new variable \nto represent B y0 , but we will reuse the variable y0 that we used to represent actual parameter D. So \nthe abstract contraction is the term a y0 (B d ) (F (B y0 )) and we form a loop in the graph. To ensure \nthe abstraction remains sound we note that another possible instantiation of y0 is B y0 , but observe \nthat this merging of vertices resulting from reusing y0 has caused some loss of information. Now the \nterm a y0 (B d )(F (B y0 )) represents many different concrete instances, including some that are not \npossible in the original problem, such as a D (B d ) (F (B (B D ))) which results from rewriting the \nleftmost occurrence of y0 to D and the rightmost occurrence to B D . The actual parameters D and B y0 \nhave become confused because, according to the current context t : q is provable . Hence, the starting \npoint for the graph f ACG(C0) is the fact that S : q0 is not provable in \u00d8. A G. C0, they have the same \nacceptance and rejection types. In this way, c types direct the abstraction and re.nement will occur \nbecause type The shape of the successors of a vertex, if it has any, depend information in the context \nincreases. upon whether the vertex is a con.guration or a set and in case By contrast, the vertex (B \nd , q0) has an actual parameter of the former, the syntactic class of which its head symbol is a whose \nacceptance and rejection types are non-trivial. The termi\u00ad q member. In this case the root of the graph \nis a con.guration and (G0 .)(d) nal d has acceptance type TA c (G0 .)(d) = q0. We have not yet created \na new variable with and rejection type = q1 its head symbol is S which is a non-terminal. Hence the term \npart of this con.guration is a redex. In such cases, the vertex has at TA q those types, so we do so \nnow, assigning the new variable y1 themost one successor and that successor represents the contraction \nacceptance type q1 and the rejection type q0. We record that d isof the redex. The contraction of the \nredex S is F D and, because a possible instantiation of y1 and label the successor (B y1 , q0). Following \nthe same method, this new vertex has itself as successor. neither G0 . F D : q0 nor G0 . F D : q0 is \nprovable, it has ffA A a successor, which is labelled by (F D , q0). Since this vertex is of c Of.cially \nwe ought to note that y1 is a possible instance of y1, but such trivial circularities will make no difference \nto the outcome so we will omit it for brevity. Let us now consider the frontier vertex (y0, q0), which \nis vari\u00ad able headed. At variable headed con.gurations the consequences of the abstraction are felt. \nA vertex of the form (y s1 \u00b7 \u00b7 \u00b7 sn , q) has a successor (t s1 \u00b7 \u00b7 \u00b7 sn , q) for each binding y . t. \nFor reasons the same form, it also has a single successor which represents the contraction of the redex, \nhowever the situation is more complicated because this redex involves parameters. It is along such edges \nthat the abstraction happens: rather than substituting actual parameters for formals in the successor, \nformals are substituted by special variables which are used by the abstraction to represent sets of terms. \nSo we create a new variable y0 and make a note y0 . D that we have already discussed, its child (B y0 \n, q0) has itself as a that one of the possible instantiations of y0 is D. In this way, we are successor. \nIts other child is the vertex (D, q0) whose contraction always able to recover the real contraction a \nD (B d ) (F (B D )) from the abstract one a y0 (B d )(F (B y0 )) by rewriting occurrences is (d, q0), \nhowever, because G0 . d : q0 we do not add vertex A f (d, q0) to the graph and so (D, q0) has no successors. \nWe say that c of the variables y0 using the bindings y0 . D. This ensures we are building a sound abstraction, \nin the sense of incorporating all the behaviours of the original. This kind of abstraction is, in essence, \na traditional control .ow analysis [10], but here we go one step further, which is critical in order \nto obtain completeness. The extra (D, q0) is a rejecting leaf. This completes the construction of the \nabstract con.guration graph.  ing type assignment F s1 \u00b7 \u00b7 \u00b7 sn : q is not provable in either G. nor \nG., yet the type assignment associated with the contraction is prov\u00adable in G.. This points directly \nto a weakness in the context. In our example, G0 . fAc d : q0 is provable, so d is a tree rejected by \nA. and D reduces to d in one step, yet G. fAc D : q0 is not prov\u00adable! The rejection environment G. ought \nto type D : q0, since D generates a tree that is rejected by A., but it doesn t. Hence, we have discovered \na new rejection type assignment. The vertices that we classify as representing typing assignments that \nought to have been provable under the rejecting environment are collectively called the rejecting region \nand from this region new rejection types are extracted. Where the rejecting region is, roughly speaking, \nall the vertices that de.nitely can reach rejecting leaves, the accept\u00ading region is all the vertices \nthat de.nitely cannot reach rejecting leaves. New acceptance types are extracted from the accepting re\u00adgion. \nIn this case, the rejecting region is the single vertex (D, q0) and the accepting region is all the B \nheaded con.gurations. Type extraction from the regions follows a similar approach to that de.ned in [14]. \nBrie.y, a type is assigned to each pre.x s of the term component of each vertex (s t1 \u00b7 \u00b7 \u00b7 tn , q) in \nthe accepting re\u00adgion. The type assigned to s is constructed by recursively comput\u00ading the type s assigned \nto t1 by considering all the ways in which t1 is used within the region (the vertices where t1 is itself \na pre.x), recursively computing the type t assigned to the pre.x s t1 and then forging the arrow s . \nt . The base case is where the entire term component of the pair, considered as a trivial pre.x of itself, \nis as\u00adsigned the type q. The rejecting region is handled similarly, but care must be taken to only consider \nuses of t1 in vertices that are strictly closer to the leaves so that a well founded co-consistency argument \ncan be given in the end. The type assignments to pre.xes that are themselves non-terminal symbols are \nextracted and added to the appropriate environments. In this case, there is only one vertex in the rejecting \nregion, so its only pre.x is assigned the type D : q0. There are three vertices in the accepting region, \nof which the pre\u00ad.x B of (B d , q0) is assigned acceptance type q1 . q0 since d is known to have type \nq0, pre.x B of (B y0 ) is assigned type T . q0 since there are no uses of y0 in the region and, for the \nsame reason, pre.x B of (B y1 ) is assigned the type T . q0. The new context is therefore C1 = ({B : \n(T . q0) . (q1 . q0)}, {D : q0}). Since the new context neither types S : q0 as accepting nor as rejecting, \nthe process repeats, but this time with more type infor\u00admation, so more of the parameters to calls will \nbe distinguished. In the second iteration the rejecting region is the entire graph. Conse\u00adquently, S \n: q0 is added to the rejecting environment and the algo\u00adrithm terminates, correctly deducing that the \ninput is a no-instance. 4. An abstraction re.nement algorithm We now present the algorithm formally. \nWe .rst give the de.nition of the key construction, the abstract con.guration graph. We then describe \nhow from the graph one can carve out the accepting and rejecting regions and the notion of type extraction \nappropriate to each. Finally we show how graph construction, regioning and type extraction come together \nto form a single iteration and we present the algorithm as the repetition of this process. Assumption. \nFor the rest of this section, assume a recursion scheme G = (S, N , R, S) and an alternating trivial \nautoma\u00adton A = (S, Q, d, q0). By an abuse, we will refer to the type system induced by A simply as A \nand the type system induced by Ac simply as Ac . 4.1 Construction of abstraction The abstraction is \nbased on a traditional CFA [10], in the sense of over-approximating reduction using an abstract environment. \nAn important twist on the usual formulation is that here every variable in the environment is associated \nwith a kind and a pair of intersection types. Typed variables. The main mechanism for abstraction will \nbe a set of typed variables. By means of an abstract environment (to be described shortly) each variable \nrepresents the set of terms that can be obtained from it by repeated substitution. Each variable has \nthree pieces of associated type information: an acceptance type, a rejection type and a kind. An essential \npart of the algorithm is in ensuring that type information is invariant across the abstraction, i.e. \nif a variable abstracts a set of terms, then every term in the set shares the same acceptance type, rejection \ntype and kind as the variable (according to the current context). De.nition 1. Let us say that a kind \n. is an argument kind just if there is some binding F : .1 . \u00b7 \u00b7 \u00b7 . .n . o . N and some i such that \n. = .i. Let var be a bijection, mapping the .nite set of all triples of the form (sA, sR, .) consisting \nof kinded types sA :: . and sR :: . ,where . is an argument kind, to a .nite set of term variables Y \n. V . Given such a variable y . Y , we will write A(y) for the .rst component of var -1(y), R(y) for \nthe second and K(y) for the third. Type context. The algorithm is ultimately concerned with con\u00adstructing \na pair of type environments (G., G.) such that G. is (G,A)-consistent and G. (G,Ac)-co-consistent. We \nwill speak of G. as the acceptance type environment and G. as the rejection type environment. Furthermore, \nwe stipulate that every such pair of environments, which we shall call a type context, understands the \nbasic assumptions we have made about the typed variables, i.e. the type information contained in A and \nR (as de.ned in De.nition 1, but viewed as type environments for the typed variables) is also contained \nin G. and G. respectively. De.nition 2. A type context C = (G., G.) is a pair of intersection type environments \nfor which the following conditions hold: (i) G. :: N . K (ii) G. :: N . K  (iii) For all y . Y , G.(y) \n= A(y) and G.(y) = R(y) Abstract con.gurations. As mentioned in the previous section, the abstraction \nitself is a .nite representation of the possibly in.\u00adnite con.guration graph, as de.ned by [14]. In this \nconcrete con\u00ad.guration graph, the con.gurations are pairs of a closed term (a reduct of the start symbol \nof the scheme) and a state of the automa\u00adton, and the edges that connect them must respect the constraints \nof both the reduction relation of the scheme and of the transition function of the automaton. A con.guration \n(t, q) can be read as an assertion: the tree generated by t is accepted by A. from state q. In the abstract \ncon.guration graph, de.ned shortly, con.gurations are still pairs of term and state, but now the term \nis abstract, which in our setting means that it can contain free occurrences of typed variables. De.nition \n3. An abstract con.guration is a pair (t, q) in which N . {y : K(y) | y . FV(t)} f t : o is a term and \nq . Q is a state. We say that a term s is a pre.x of a term t just if t has the form s t1 \u00b7 \u00b7 \u00b7 tn for \nsome n . N. A con.guration pre.x is a pair (c, s) in which c is a con.guration of shape (t, q) and s \nis a pre.x of t. Abstract typability. The central idea of the algorithm is that the type bindings contained \nin the context constitute a concise sum\u00admary of all the information that has been gathered about the \nscheme and its reducts, as far as acceptance by the property automaton is concerned. We will use the \ntype context to judge whether the as\u00adsertions represented by con.gurations are true or not, based on \nthe following simple notion of typability.  De.nition 4. Let C = (G., G.) be a type context and let \n(t, q) be an abstract con.guration. We say that (t, q) is C-accepted just c t : q. We say that (t, q) \nis C-unknown just if it is neither C-accepted nor C-rejected. Until the very last iteration of the algorithm, \nthe con.guration (S, q0), which is the root of the abstract con.guration graph, will be C-unknown to \nall the associated contexts C, but after the last iteration enough type information will have been contributed \nto the .nal context C ' in order that (S, q0) will be seen to be either C ' \u00adaccepting or C '-rejecting. \nAbstract con.guration graph. The vertices of the abstract con\u00ad.guration graph are either abstract con.gurations \nor .nite sets of abstract con.gurations. Viewed as an assertion, a vertex which is a .nite set of con.gurations \n{(s1, q1), . . . , (sn, qn)} should be interpreted conjunctively, i.e. as requiring that for each i . \n[1..n], si generates a tree that is accepted from state qi. De.nition 5. An abstract con.guration graph \nA is a tuple (V , E, B)in which (V, E) is a directed graph and B is a set of mappings from variables \ny . Y to terms t . TS(Y, N ). Each vertex v . V is if . We say that is rejected just if ffG() C Gt : \nt, q-q. .Aeither (i) an abstract con.guration or (ii) a .nite set of abstract con.gurations; and edges \nare unlabelled. Given a .E V V\u00d7 typing context , the abstract con.guration graph of , denoted C C , is \nthe abstract con.guration graph de-()ACG(C)V, E, BC C C .ned inductively by the system in Figure 4. The \nset of bindings acts as the abstract environment for the B purposes of de.ning the abstraction. We consider \nmotivation of each of the rules of the inductive de.nition in turn. First, the rule (G1) de.nes the root \nof the graph. The premise ensures that, if we already know that generates a tree that is either accepted \nS from or rejected from then we need not do any state space qq0 0 exploration. This kind of premise is \ncommon to many of the rules to ensure that work is not done unnecessarily. In fact, one can state an \ninvariant about the abstract typability of the vertices in any abstract con.guration graph: Lemma 1. \nLet C be a context. For each con.guration c . VC , c is C-unknown. In case (S, q0) were C-accepting or \nC-rejecting, the graph would be empty and the sequence of contexts will stabilise. Rule (G2) simulates \nthe contraction of a redex, but it does so in an abstract way. To apply the rule requires that a con.gura\u00adtion \n(F s1 \u00b7 \u00b7 \u00b7 sn , q) containing a redex occurs in the graph. The consequence is that an abstraction of \nthe contraction of that redex is added as a new con.guration. However, it is abstract because, rather \nthan substituting actual parameters for formals, typed vari\u00adables are substituted for the formals. These \ntyped variables must be appropriate for the actuals that they abstract, hence there is the constraint \nthat, if yi abstracts actual parameter si, then it had bet- A (G1) Whenever all the following are true: \n(i) (S, q0) is C-unknown then all the following are also true: (S, q0) . VC TA (G2) Whenever all the \nfollowing are true: (i) (F s1 \u00b7 \u00b7 \u00b7 sn , q) . VC (ii) R(F ) = .x1 \u00b7 \u00b7 \u00b7 xn . t TA (iii) N (F ) = .1 . \n\u00b7 \u00b7 \u00b7 . .n . o (iv) (t[y1/x1, \u00b7 \u00b7 \u00b7 , yn/xn], q) is C-unknown (v) for each i . [1..n],  qq yi = var((G.)(si), \nc (G.)(si), .i) then all the following are also true: (t[y1/x1, \u00b7 \u00b7 \u00b7 , yn/xn], q) . VC  ((F s1 \u00b7 \u00b7 \n\u00b7 sn , q), (t[y1/x1, \u00b7 \u00b7 \u00b7 , yn/xn], q)) . EC  for each i . [1..n]: yi . si . BC (G3) Whenever all the \nfollowing are true: (i) (a s1 \u00b7 \u00b7 \u00b7 sn , q) . VC (ii) S |= d(q, a) (iii) for all (i, q ' ) . S, (si, \nq ' ) is not C-rejected then all the following are also true: {(si, q ' ) | (i, q ' ) . S} . VC  ((a \ns1 \u00b7 \u00b7 \u00b7 sn , q), {(si, q ' ) | (i, q ' ) . S}) . EC .  (G4) Whenever all the following are true: (i) \n{(s1, q1), . . . , (sn, qn)} . VC (ii) i . [1..n] (iii) (si, qi) is not C-accepted then all the following \nare also true:  (si, qi) . VC  ({(s1, q1), . . . , (sn, qn)}, (si, qi)) . EC  (G5) Whenever all the \nfollowing are true: (i) (y s1 \u00b7 \u00b7 \u00b7 sn , q) . VC (ii) y . t . BC then all the following are also true: \n (t s1 \u00b7 \u00b7 \u00b7 sn , q) . VC  ((y s1 \u00b7 \u00b7 \u00b7 sn , q), (t s1 \u00b7 \u00b7 \u00b7 sn , q)) . EC  TA TATATA qq c (G.)(si), \nK(si)). This ensures that type information is invariant across the abstraction, in the following sense: \n Proposition 1. Let C = (G., G.) be a type context. For all Figure 4. Abstract con.guration graph construction. \nqqq = (G.)(t) and c (G.)(y) = c (G.)(t). ter be that yi TA var( (G.)(si), = y . t . BC , TA (G.)(y) \nsets of con.gurations. Recalling that each vertex that is a set of q To properly de.ne the abstraction \nin terms of the new variable yi, a binding is added to BC with the effect that yi . si. Consequently, \nwe may think that si is in the set of terms abstracted by yi. Rule (G3) simulates a transition of the \nautomaton on reading a terminal symbol: if there is a terminal symbol-headed con.g\u00aduration (a s1 \u00b7 \u00b7 \n\u00b7 sn , q) in the graph, then its children comprise all of the possible satisfying assignments to d(q, \na) expressed as con.gurations should be thought of conjunctively, the children of (a s1 \u00b7 \u00b7 \u00b7 sn , q), \ntaken as a whole, should be thought of disjunc\u00adtively a s1 \u00b7 \u00b7 \u00b7 sn generates a tree accepted from state \nq just if all the con.gurations contained in some child (satisfying assignment) are shown to be accepted. \nRule (G4) simply decomposes set ver\u00adtices into their constituent con.gurations. Therefore, the children \nof a set vertex should be thought of conjunctively.  Finally, rule (G5) ties the knot on the abstraction \nby considering the case when a typed variable is in head position in a con.guration. In this case, the \nbinding set is consulted and a node is added for each binding to the appropriate variable. We will think \nof the children of such a vertex conjunctively: for y s1 \u00b7 \u00b7 \u00b7 sn to generate a tree accepted from state \nq, it had better be that every term that it abstracts generates a tree accepted from state q. Due to \nthe abstraction at the point of contraction in (G2) and the limited substitution (only in head position) \nin (G5), ACG(C) is necessarily a .nite construction. In fact, we can go further: Lemma 2. Let C be a \ntype context. Then the size of VC is bounded by a polynomial function of the size of the scheme. Classi.cation \nof leaves. Let us consider for a moment the leaves of ACG(C) for some type context C. It follows from \nthe de.nition that the leaves all have a particular form. Every leaf is a con.g\u00aduration headed by a non-terminal \nsymbol, i.e. a redex. Moreover, each such redex, if contracted using rule (G2), would yield a new con.guration \nwhich is already known to be either C-accepting or C-rejecting. It is for this reason that such con.gurations \nare leaves: (G2) does not apply because the fourth premise would be violated. De.nition 6. Given a type \ncontext C = (G., G.), the leaves (i.e. those vertices that have no children) of ACG(C) can be classi.ed \ninto two sets: (AC C E P T I N G L E AV E S ) These leaves are con.gurations of the form (F s1 \u00b7 \u00b7 \u00b7 \nsn , q) where R(F ) = .x1 . . . xn . t, for each i . [1..n], there is a typed variable yi such that A(yi) \n= are necessarily rejecting. The collection of all such is called the rejecting region. De.nition 7. \nGiven a context C, we de.ne a subset RR(C) . VC of the vertices of ACG(C), called the rejecting region, \ninductively: (R1) If c is a rejecting leaf then c . RR(C). (R2) If {(s1, q1), . . . , (sn, qn)} . VC \nand there exists j . [1..n] and (sj , qj ) . RR(C) then {(s1, q1), . . ., (sn, qn)} . RR(C). (R3) If \n((F s1 \u00b7 \u00b7 \u00b7 sn , q), (t, q)) . EC and (t, q) . RR(C) then (F s1 \u00b7 \u00b7 \u00b7 sn , q) . RR(C). (R4) If (a s1 \n\u00b7 \u00b7 \u00b7 sn , q) . VC and, for every v, ((a s1 \u00b7 \u00b7 \u00b7 sn , q), v) . EC implies v . RR(C), then (a s1 \u00b7 \u00b7 \n\u00b7 sn , q) . RR(C). (R5) If (y s1 \u00b7 \u00b7 \u00b7 sn , q) . VC and, for all y . t . BC , (t s1 \u00b7 \u00b7 \u00b7 sn , q) . RR(C) \nthen (y s1 \u00b7 \u00b7 \u00b7 sn , q) . RR(C). Unless it is the .nal iteration of the algorithm, the rejecting region \nwill always be non-empty. The fact that an absence of rejecting leaves is an absence of counterexamples \nin the abstraction is formalised later, in Lemma 6. Rejection type extraction. The vertices in the rejecting \nregion are those con.gurations, that we have identi.ed by constructing ACG(C), which should be classi.ed \nby the context as rejecting, but are not each is necessarily C-unknown, since it belongs to the graph. \nSo the rejecting region represents a weakness in the context. To remedy it, from the region we will extract \nnew type information to be added to the context ready for the next iteration. De.nition 8. Let C = (G., \nG.) be a typing context and v . RR(C). A witness to the membership of v in RR(C) is a proof tree q (R \nE J E C T I N G L E AV E S ) These leaves are con.gurations of the form and f(G)() Gs. i .A (G. l M(T \n))(s1) . (G. l M(T ))(sn) . q TA t[y1 /x1 , . . . , yn /xn ] : q. T rooted at the statement v . RR(C) \nand constructed according to the rules (R1) (R5). We describe an assignment of type envi\u00ad(F s1 \u00b7 \u00b7 \u00b7 \nsn , q) where R(F ) = .x1 . . . xn . t, for each ronments M(T ) to proof trees T , inductively on the \nshape of the i . [1..n], there is a typed variable yi such that R(yi) = proof. q Note that a rejecting \nleaf is not itself C-rejecting, by Lemma 1 since and f(G)() Gs. i .c A TA c t[y1 /x1 , . . . , yn /xn \n] : q. (M1) If the proof is by (R1) then v is a con.guration of the form (F s1 \u00b7 \u00b7 \u00b7 sn , q), and we \nset M(T ) to be the single binding: it is in the graph it is necessarily C-unknown, but its contractum \n T(G.)(s1) . \u00b7 \u00b7 \u00b7 .T(G.)(sn) . q is C-rejecting. Similarly accepting leaves are not themselves C- F \n: accepting, but the contractum of an accepting leaf is C-accepting. Lemma 3. Let C be a context. Every \nleaf in ACG(C) is accepting or rejecting.  4.2 The rejecting region Region of rejection. The construction \nof an ACG from a given type context C is a method for analysing the type context. By constructing the \ngraph it is possible to see where the information (M2) If the proof is by (R2) then v is a set {(s1, \nq1), . . . , (sn, qn)}and for some j . [1..n] there is an immediate sub-proof T ' of (sj , qj ). We set \nM(T ) = M(T ' ). (M3) If the proof is by (R3) then v is a con.guration of the form (F s1 \u00b7 \u00b7 \u00b7 sn , q) \nand, necessarily, there is an immediate sub-proof T ' of (t, q). We take for M(T ) the environment M(T \n' ) augmented by the binding: ' ' F : T \u00b7 \u00b7 \u00b7 T . in the type context is de.cient, and the main tools \nfor identify\u00ading and correcting de.ciencies are the regions and region type (M4) If the proof is by (R4) \nthen v is of the form (a s1 \u00b7 \u00b7 \u00b7 sn , q) extraction respectively. Consider a rejecting leaf v of the \nform with a set W of children. For each w . W , there is a sub\u00ad (F s1 \u00b7 \u00b7 \u00b7 sn , q). By de.nition, the \ncontraction of this con.guration proof Tw. We set M(T ) = {M(Tw) | w . W }. using (G2) would yield a \ncon.guration (t[y1/x1, . . . , yn/xn], q) (M5) If the proof is by (R5) then v is a con.guration of the \nform which is already C-rejecting. In other words, the tree gener\u00ad (y s1 \u00b7 \u00b7 \u00b7 sn , q) and, necessarily, \nfor each y . t . BC ated by any term of the form t[t1/y1, . . . , tn/yn] such that there is an immediate \nsub-proof Tt of (t s1 \u00b7 \u00b7 \u00b7 sn , q). Let us A TA TA qq c (G.)(ti) = c (G.)(yi) for each i is sure to \nbe rejected from state q. Assuming that G. is co-consistent, this follows be\u00ad f write M(Ty) simply as \nnotation for the environment given by {M(Tt) | y . t . BC }. We take for M(T ) the environment: cause \nnecessarily G. Recalling t[t1/y1, ..., tn/yn] : q. c Proposition 1, one such sequence of ti are the actual \nparameters  T (G. l M(Ty))(s1) . \u00b7 \u00b7 \u00b7 T . (G. l M(Ty))(sn) . q of the term component of the rejecting \nleaf we started with: v. y : Hence, because we know that the contractum of the term part of v generates \na tree that is rejected from state q0, necessarily the term part of v itself generates a tree that is \nrejected from state q0. So we have identi.ed that v should be classi.ed as C-rejecting (but is not currently). \nThrough analogous reasoning (and remembering the conjunctive and disjunctive interpretations of the child \nrelation in the graph), it is possible to identify other such vertices which Finally, we de.ne a type \nenvironment, envR(C), whose domain is a subset of dom(N ) and which is extracted from RR(C) by: envR(C)(F \n) ={M(T )(F ) | . c . RR(C) with witness T } So the types are extracted in an inductive fashion, starting \nfrom the leaves of each witness with the environment G. and working back\u00adwards, adding new types along \nwith way. It is this well-foundedness that ensures that the types that are extracted are all correct \n:  Lemma 4. Let C = (G., G.) be a type context. If G. is G-co\u00adconsistent in Ac then G. l envR(C) is \nG-co-consistent in Ac . Furthermore, whenever the rejecting region is non-empty, then genuinely new type \ninformation will be extracted. Taken together with Lemma 6, the following result is the key measure of \nprogress in the algorithm. Lemma 5. Let C = (G., G.) be a type context and ACG(C) have some rejecting \nleaf. Then envR(C) \\ G. = \u00d8.  4.3 The accepting region Region of acceptance. In a similar way, the accepting \nregion serves to identify those con.gurations that should be classi.ed as accepting by the type context, \nbut which are not. The rules by which vertices can be inferred to be accepting are all complimentary \nto those that de.ne the rejecting region (except for the case of variable-headed nodes, which are conjunctive \nin both regions) and, indeed, the construction is coinductive. De.nition 9. Given a typing context C, \nwe de.ne a subset RA(C) . VC of the vertices of ACG(C), called the accepting re\u00adgion, coinductively by: \n(A1) If (F s1 \u00b7 \u00b7 \u00b7 sn , q) . RA(C) with successor (t, q) . VC , then (t, q) . RA(C). (A2) If (a s1 \u00b7 \n\u00b7 \u00b7 sn , q) . RA(C), then there is some S such that S |= d(q, a) and {(si, q ' ) | (i, q ' ) . S} . RA(C). \n(A3) If {(s1, q1), . . . , (sm, qm)} . RA(C) then, for all i . [1..m], (sm, qm) . RA(C). (A4) If (y s1 \n\u00b7 \u00b7 \u00b7 sn , q) . RA(C) then, for all y . t . BC , (t s1 \u00b7 \u00b7 \u00b7 sn , q) . RA(C). (A5) If c . RA(C) is a \nleaf in VC then c is an accepting leaf. However, unlike the case for rejecting region there is no similar \nguarantee of non-emptiness on non-.nal iterations. It is perfectly possible that on any given iteration, \nthe accepting region may be empty. In contrast, the absence of rejecting leaves, and hence emptiness \nof the rejecting region, leads to termination. Lemma 6. Let C be a type context and ACG(C) have no rejecting \nleaves. Then ACG(C) = RA(C). Thus, in particular, RA(C) will contain the root and so S : q0 will be added \nto the accepting environment, signalling termination. Acceptance type extraction. To extract new type \ninformation from the accepting region we follow the approach of Kobayashi and Ong [12, 14], in which \ntypes are assigned to pre.xes of con\u00ad .gurations recursively based on the kind of the pre.x. De.nition \n10. Let C = (G., G.) be a type context. To each pre.x (c, s) of each con.guration c . RA(C), we assign \na strict type extr(c, s), which is de.ned inductively over the structure of the kind of s. (i) If s is \nof base kind, necessarily c is of the form (s, q) and set extr(c, s) = q. (ii) If s is of arrow kind, \nnecessarily c is of the form (s t1 \u00b7 \u00b7 \u00b7 tn , q). Let W be the set of accepting region con.gurations \nwith pre.x t1. Set:  extr(c, s) = TA(G.)(t1) . extr(c ' , t1) . extr(c, s t1 ) c1.W We de.ne a type \nenvironment, envA(C), whose domain is a subset of dom(N ) and which is extracted from RA(C) by: envA(C)(F \n) = {t | . c . RA(C) \u00b7 extr(c, F ) = t } The acceptance types extracted in this way are all correct : \nLemma 7. Let C = (G., G.) be a context. If G. is (G,A)\u00adconsistent then also G. l envA(C) is (G,A)-consistent. \n 4.4 Fixed point construction Abstraction re.nement. Finally, we are in a position to describe the overall \nabstraction re.nement loop. Starting from a context C0 that contains only the type assumptions on typed \nvariables used by the abstraction, on each iteration the algorithm analyses the given context, say Ci, \nby constructing ACG(Ci); it then identi.es de.ciencies in Ci by constructing regions and attempts to \nrepair those de.ciencies by extracting new environments. Eventually, the type S : q0 will be extracted \nfrom one of the regions and the algorithm will terminate. De.nition 11. Recall A and R in De.nition 1. \nThe algorithm con\u00adsists of constructing an eventually stable sequence of type contexts (Ci)i.N as follows: \nC0 = (G. 0 , G. 0 ) = (A, R) (Gk+1 , Gk+1 Ck+1 = . ) = (Gk . l envA(Ck), G. k l envR(Ck)) . with limit, \nsay C = (G., G.). Then if q0 . G.(S) answer YES and otherwise answer NO. Since the initial environments \nG0 and G0 are trivially G\u00ad . . consistent in A and G-co-consistent in Ac respectively and since every \nextension of these environments by envA and envR preserves this property, it follows that the limit of \nthe sequence also enjoys the property and hence can be relied upon to decide the model checking problem. \nFurthermore, since progress is guaranteed by Lemma 6 and Lemma 5, and the size of rejecting environment \nG. is bounded by the number of well-kinded types, we can state the following correctness theorem: Theorem \n2. For any G, A, the algorithm terminates and: Answer Y ES implies Tree(G) . L(A.).  Answer N O implies \nTree(G) /).  . L(A. Furthermore, since each ACG is, in the worst case, polynomial in the size of the \nscheme (but in general, hyper-exponential in the order of the scheme) and the amount of work involved \nin computing the ACG, the regions and type extraction is polynomial in the size of the scheme, it follows \nthat each iteration of the algorithm takes, in the worst case, an amount of time polynomial in the size \nof the scheme. Since the number of iterations is bounded by the number of well-kinded types, which is \nalso polynomial in the size of the scheme, it follows that the algorithm as a whole is polynomial in \nthe size of the scheme, assuming its order and arity and the size of the automaton are taken to be .xed. \n5. Implementation and evaluation We have implemented the algorithm in a prototype tool, called PR E FACE, \nwhich is written in F# and available to download from http://mjolnir.cs.ox.ac.uk/web/preface. 5.1 Implementation \nTo ensure ef.ciency we have taken a number of decisions about how to code speci.c aspects of the algorithm \nwhich deviate from the presentation. Rather than constructing them as part of initiali\u00adsation, we build \nthe maps A and R lazily, adding bindings as they are needed by applications of rule (G 2). Further, the \nimplementa\u00adtion uses a .ow analysis with increased accuracy, distinguishing be\u00adtween instances of arguments \nusing not just the triple of acceptance type, rejection type and kind, but additionally the formal parameter \n Benchmark Rules Ord Dec PRE FAC E HO RSAT HO R SAT T C-SHORE GTREC S2 TRAV MC TRE CS cfa-psdes 237 \n7 A 0.51 0.28 1.81 3.44 cfa-matrix-1 383 8 A 0.61 0.73 6.30 18.58 cfa-life2 898 14 A 1.46 5.94 Table \n2. Benchmarks of category 2. Benchmark Rules Ord Dec PREFAC E HO RSAT HOR SAT T C-SHORE GTREC S2 TRAV \nMC TRE CS exp2-1600 1606 2 A 8.39   10.47 exp2-3200 3206 2 A 17.51   59.13 exp2-6400 6406 2 A 39.58 \nexp2-12800 12806 2 A 92.19 exp4-400 408 4 A 14.12  106.53 exp4-800 808 4 A 30.55 exp4-1600 1608 4 A \n71.06 exp4-3200 3208 4 A Table 3. Benchmarks of category 3. Benchmark Rules Ord Dec PR EFAC E TRE C \nS map .lter-e 64 5 R 0.53 0.01 fold left 65 4 A 0.39 0.03 fold right 65 4 A 0.39 0.03 forall eq pair \n66 4 A 0.39 0.03 forall leq 66 4 A 0.39 0.03 a-cppr 74 3 R 0.38 0.01 search-e 96 5 R 0.90 0.01 search \n119 4 A 0.46 1.04 map .lter 143 5 A 0.51 0.13 risers 148 5 A 0.44 0.33 r-.le 156 2 A 0.82 1.50 fold fun \nlist 197 6 A 0.44 0.89 zip 210 3 A 0.58 15.10 Table 1. Benchmarks of category 1. and the state component \nof the calling con.guration. Since inter\u00adsection type checking is frequently invoked as part of the decision \nprocedure, we aim to ensure it is done as ef.ciently as possible. Hence, we omit subtype checking3 and \nhash cons the intersection types. Finally, rather than compute all possible witnessing trees for any \ngiven vertex v . RR(C), we take one representative, which is a function of the construction of the region. \n 5.2 Evaluation We have evaluated the tool on the large collection of recursion scheme model checking \ninstances found online and in the related literature. The full listing of results is available in the \nappendix of the long version of this paper, here we aim to present a very small representative sample \nin order to describe the general trends. We have picked a number of benchmarks from three categories, \nwhich are displayed in Tables 1, 2 and 3 respectively. The bench\u00admarks were run on an Intel Xeon machine \nwith 12GB of RAM and 4 cores running at 2.4GHz, limiting the run-time of each tool on each benchmark \nto 2 minutes. In all cases the columns are, respec\u00adtively, the name of the benchmark, the number of rules \n(equations), the order of the scheme, whether the tree is accepted (A) or re\u00adjected (R) by the property \nautomaton. The remaining columns list the time taken by each tool from start to .nish, which is either \ngiven in seconds, or marked  in case the tool ran out of resources. 3 Note that this does not affect \nthe soundness or completeness of the deci\u00adsion procedure. Category 1. The .rst category consists of model \nchecking in\u00adstances that have arisen from OCaml veri.cation problems via the predicate abstraction tool \nMoCHi [25]. Although MoCHi can solve many complex examples, the scalability of a full blown predicate \nabstraction tool for higher-order programs is still an open topic of research. Consequently the problem \ninstances derived from this tool are exclusively quite small and mostly less than 100 rules. MoCHi generates \na mild extension of recursion schemes called RSFD [16], which are currently only supported by PR EFAC \nE and TRE CS. Our tool PREFAC E can typically solve each of these in\u00adstances in less than 0.5 seconds, \nbut this is already roughly an order of magnitude slower than TREC S. However, the overhead incurred \nby JIT compilation on Mono is a major factor; when compiled ahead of time on Windows, the time taken \nby PR E FAC E to solve these instances is typically less than 0.05 seconds, although usu\u00adally still slower \nthan TRE CS. As the benchmarks become slightly larger, towards the bottom of the table, the time taken \nby TREC S starts to lag behind the time taken by PR EFAC E, which is the start of a general trend in \nthe data to follow. Category 2. The second category consists of instances arising from a tool for performing \nexact .ow analysis [26]. These examples are signi.cantly larger than those of Category 1 and, indeed, \nform some of the largest instances on which HORS model checkers have been evaluated in the literature \nas of the time of writing. Although they have fewer than 1000 rules each, due to the nature of the veri.cation \nalgorithm that produces them, they have high order and very high maximum arity, with cfa-life2 being \norder 14 with arity 29 functions. Consequently, many of the tools have dif.culty, but among those that \nare able to solve these instances, the trend observed in the Category 1 examples can be seen to continue. \nCategory 3. The .nal category consists of instances of a family of schemes due to Kobayashi [13]. This \nfamily of instances was de\u00ad signed to be deliberately dif.cult for bounded model checking style algorithms \nsuch as the hybrid algorithm of TREC S, whilst simul\u00adtaneously being a good indicator of the scalability \nof Kobayashi s linear time algorithm as implemented in GTRE CS. Although these schemes are not real in \nthe sense of arising from program analysis problems they seem a good measure of scalability since they \ngen\u00aderate hyper-exponentially sized trees (and hence use the full power of higher-order schemes), their \ncerti.cates are proportional to the number of rules and they can push the model checkers much fur\u00adther \nsince the family contains much larger schemes than can be produced by current veri.cation tools. The \n.rst half of the table shows instances which are generated with order-2 schemes and the second half shows \ninstances with order-4 schemes. The size of the schemes roughly doubles within each half by row. As expected, \nGTRE CS does a good job at solving even relatively large examples at order-2, though it has some dif.culty \nat higher-orders. PRE FACE does even better and, in contrast to the other tools, can be seen to solve \nthese examples in time which is roughly linear in the number of rules.  5.3 Analysis The good performance \nof our algorithm at scale must be attributed to the abstraction re.nement approach that we have adopted. \nSince recursion schemes cannot destruct the trees that they create, their interesting behaviours are \nexclusively due to control .ow arising from complex uses of higher-order functions. Hence, a CFA-style \nabstraction in combination with a property directed re.nement works well, since this abstraction is particularly \nwell suited to emphasising some of the essential structure of higher-order control .ow and the re.nement \nensures that particular limitations of the CFA with respect to speci.c problem instances can be compensated \nfor. A good example of this is in the Category 3 examples, whose very regular structure is determined \nby the analysis quickly and hence all are solved in exactly 3 iterations (independent of the number of \nrules or the order of the scheme). However, although the re.nement will eventually compensate for these \nparticular limitations of the CFA, it is possible to con\u00adstruct instances in which the number of iterations \nrequired is un\u00adacceptably large with respect to the characteristics of the instance. Although such examples \ndo not seem to occur in the corpus of in\u00adstances drawn from the higher-order model checking literature \nand associated veri.cation tools, we have been able to construct very small and simple schemes which \nexhibit this bad behaviour. The examples in Table 4 are based on a family of Boolean programs de.ned \nin [1]. Each of these instances is .rst order and consists of a few hundred rules, but the property automaton \nis strictly alter\u00adnating. We record the number of iterations (Rnds) and the time (in seconds) taken by \nPRE FACE and an extension, PR E FAC E+, in the remaining columns. Benchmark Rules PR E FACE PR E FAC \nE+ Rnds Time Rnds Time t100 t200 t400 t800 t1600 104 204 404 804 1604 202 402 802 1602 3202 45.38 178.81 \n732.40 3074.03 13561.26 8 8 8 9 9 2.17 3.99 7.97 18.50 41.02 Table 4. Bad behaviour. Each example tn \nconsists of roughly n functions, which make exponentially many calls to each other in sequence, so that \nfunc\u00adtion F 1 calls function F 2 twice, function F 2 calls function F 3 twice and so on. However, what \nmakes the examples expose bad behaviour in PR E FACE is not the number of calls (which is hyper-exponentially \nsmaller than the number of calls made by the expn-m examples in Category 3), but the fact that each call \nis made once with a term that will eventually evaluate to true and once with a term that will eventually \nevaluate to false and that refutation of the property depends upon distinguishing between the two. On \niteration 2i+ 2, the .ow analysis is only able to distinguish between the true and false variants of \nthe calls made to functions F j for j = n - i. Every 2 iterations, enough new information has been discovered \nin order to distinguish one more level of function calls, and hence each tn is solved after roughly 2n \niterations. This analysis suggests that not enough type information is being recovered from the ACG at \neach iteration and, indeed, by extending our implementation with heuristics for extracting more types, \nwe have solved these examples more quickly. Our extension, labelled PRE FACE+ in the table, exploits \nthe incremental nature of the algorithm. By this we mean the following characteristics: (i) The algorithm \nmakes progress on each iteration, in the sense of extracting new types (even if the number of types extracted \nis perhaps smaller than one would like). (ii) On each iteration, the provenance of the context is not \nim\u00adportant, only the fact that it comprises environments that are consistent and co-consistent respectively. \n (iii) The larger the context for a given iteration, the more accurate the analysis of that iteration. \nOur extension consists of, in a separate thread running in parallel with the main algorithm, taking the \nACG that has most recently been computed and, based on the relationships between the ver\u00adtices, making \ninformed guesses at possible new types. In general the guesses may be incorrect, in the sense of leading \nto the creation of an environment which is unjusti.able, so the new environments are .rst type-checked \naccording to the rules of (co-)consistency. If they type-check, the new types are then added into the \ncontext at the earliest opportunity and the guessing process can be repeated. This extension appears \nto work well to solve the examples in Table 4, cutting the time taken to process t1600 down from almost \n3 hours to under one minute! However, it seems unlikely to scale well to higher-orders, where the possible \nnumber of types from which to guess is much larger. Consequently, we do not consider this a satisfactory \nsolution and leave to future work a proper treatment of this problem and that of the closely related \narea of how best to extract counter-example traces. 6. Related work Higher-order model checking algorithms. \nExempli.ed by the tool TRE C S [11], the .rst practical algorithms model check HORS with respect to trivial \nautomata, using intersection types as a .nite representation of an in.nite transition system. They start \nfrom the assignment of the automaton initial state to the start non-terminal S, and compute the post-image \nin the form of type informa\u00adtion required to deduce unreachability of the error con.gurations. In TREC \nS, the types of non-terminals are .rst extracted from a .nitely reachable part of the (in.nite) con.guration \ngraph; the re\u00adsultant type environment is then expanded and used as an over\u00adapproximation of a greatest \n.xpoint (of shrink [12]). PRE FAC E is similar to TREC S in that it implements a forward algorithm based \non intersection types. However, in contrast, PREFAC E extracts types from a .nite, 0CFA-like abstraction \nof the con.guration graph. An\u00adother major difference is that each iteration of PR EFAC E re.nes two type \nenvironments, one is potentially a certi.cate of automaton ac\u00adceptance, and the other of automaton rejection. \nVery fast for HORS of up to a few hundred rules, the runtime of TRE CS is nonetheless hyper-exponential \nin the size of the input HORS. The .rst .xed-parameter polytime (in the size of HORS) algorithm is GTREC \nS [13] which consists simply of two .xpoint constructions. The key innovation is a game-semantic reading \nof the intersection types qua a pair of expansion relations, modelling the legals moves of the two players \nof an arena game. The tool TR AVMC [19] is also based on game semantics. The algorithm harvests variable \npro.les, but represented as intersection types, from the traversals [20] over the HORS being analysed. \nRecently Broadbent et al. [4] have introduced an algorithm based on collapsible pushdown automata (CPDA) \n[8] which are equi-expressive with HORS and implemented in the tool C-SHORe [5]. Given an input co-trivial \ntree automaton, the algorithm uses a generalisation of the saturation algorithm for pushdown automata \nto compute the pre-image of the .nal error con.gu\u00adrations, and checks if it includes the start state. \nThus information is propagated in the backward direction. Closely related are algo\u00adrithms HO R SAT and \nHO R SATT [3]. Though based on saturation (of HORS rather than CPDA), they may be viewed as .xpoint com\u00adputation \nof a function over type environments. To accelerate the pre-image computation, these algorithms bene.t \nfrom a forward .ow analysis, which excludes some irrelevant type bindings.  Abstraction re.nement. Counterexample-guided \nabstraction re\u00ad.nement (CEGAR) was introduced by Clarke et al. [6] for symbolic model checking. The CEGAR \nloop was .rst applied to higher-order model checking by Ong and Ramsay [22] and by Kobayashi et al. [17]. \nThe former addresses the undecidable problem of verifying safety properties of pattern-matching recursion \nschemes, using pat\u00adterns to abstract properties. The latter is used in conjunction with predicate abstraction \nto verify simply-typed functional programs generated from in.nite data domains such as integers. In contrast, \nPR E FACE builds successively more accurate .nite abstractions of the con.guration graph of the HORS \nbeing analysed, from which potential certi.cates of acceptance and of rejection are derived. Type-based \n.ow analysis. Flow analyses were .rst applied to un\u00adtyped languages. Jagannathan et al. [9] introduced \na type-directed, polyvariant .ow analysis for the predicative subset of System F, which can leverage \ntypes to analyse programs more precisely. Our algorithm uses an intersection type system for describing \nautoma\u00adton de.nable properties and necessarily works in a situation in which not all type information \nis known; in contrast theirs uses more standard typing (System F) and starts from a situation in which \nall types are known. Thus their analysis is comparable to a single iteration of our algorithm where the \nassociated context al\u00adready contains all the possible correct type information. The prop\u00aderty of respecting \ntypes, which is put forward by the authors as a measure of the appropriateness of a CFA for a typed language \nis, for us, actually an essential technical requirement in order to extract new, valid type information. \nPlevyak and Chien [23] considered a constraint-based type in\u00ad ference for object-oriented programs. Like \nour algorithm, not all type information is known at the start, and they compute types iter\u00adatively based \non a .ow analysis. However, within a single iteration they do not distinguish based on type information, \ninstead they dis\u00adtinguish based on clashes discovered in the previous iteration. A problem with their \napproach of distinguishing calls uncondition\u00adally is that there may be in.nitely many counterexamples \nwhich are being distinguished one at a time. Because of possible non\u00adtermination, their method cannot \nhandle recursion in general. Acknowledgments We are grateful to Naoki Kobayashi, Hiroshi Unno, Ryosuke \nSato, Matthew Hague and Christopher Broadbent for providing their tools and contributing a large number \nof examples for benchmark\u00ading in Section 5. The .rst author was generously supported in this work by \na graduate research grant from Merton College, Oxford. References [1] T. Ball and S. K. Rajamani. Bebop: \nA symbolic model checker for boolean programs. In SPIN 00, volume 1885 of LNCS, pages 113 130. Springer, \n2000. [2] H. Barendregt, M. Coppo, and M. Dezani-Ciancaglini. A .lter lambda model and the completeness \nof type assignment. Journal of Symbolic Logic, 48(4):931 940, 1983. [3] C. H. Broadbent and N. Kobayashi. \nSaturation-based model checking of higher-order recursion schemes. In CSL 13, volume 23 of LIPIcs, pages \n129 148. Schloss Dagstuhl, 2013. [4] C. H. Broadbent, A. Carayol, M. Hague, and O. Serre. A saturation \nmethod for collapsible pushdown systems. In ICALP 12, volume 7392 of Lecture Notes in Computer Science, \npages 165 176. Springer, 2012. [5] C. H. Broadbent, A. Carayol, M. Hague, and O. Serre. C-SHORe: a collapsible \napproach to verifying higher-order programs. In ICFP 13, pages 13 24. ACM, 2013. [6] E. M. Clarke, O. \nGrumberg, S. Jha, Y. Lu, and H. Veith. Counterexample-guided abstraction re.nement. In CAV 00, pages \n154 169. Springer-Verlag, 2000. [7] M. Coppo and M. Dezani. An extension of the basic functionality theory \nfor the lambda-calculus. Notre Dame Journal of Formal Logic, 21(4):685 693, 1980. [8] M. Hague, A. S. \nMurawski, C.-H. L. Ong, and O. Serre. Collapsible pushdown automata and recursion schemes. In LICS 08, \npages 452 461. IEEE Computer Society, 2008. [9] S. Jagannathan, S. Weeks, and A. K. Wright. Type-directed \n.ow analysis for typed intermediate languages. In SAS 97, volume 1302 of Lecture Notes in Computer Science, \npages 232 249. Springer, 1997. [10] N. D. Jones. Flow analysis of lambda expressions. In ICALP 81, volume \n115 of LNCS, pages 114 128. Springer, 1981. [11] N. Kobayashi. Types and higher-order recursion schemes \nfor veri.\u00adcation of higher-order programs. In POPL 09, pages 416 428. ACM, 2009. [12] N. Kobayashi. Model-checking \nhigher-order functions. In PPDP 09, pages 25 36. ACM, 2009. [13] N. Kobayashi. A practical linear time \nalgorithm for trivial automata model checking of higher-order recursion schemes. In FOSSACS 2011, volume \n6604 of Lecture Notes in Computer Science, pages 260 274. Springer, 2011. [14] N. Kobayashi and C.-H. \nL. Ong. A type system equivalent to the modal mu-calculus model checking of higher-order recursion schemes. \nIn LICS 2009, pages 179 188. IEEE Computer Society, 2009. [15] N. Kobayashi and C.-H. L. Ong. Complexity \nof model checking recursion schemes for fragments of the modal mu-calculus. Logical Methods in Computer \nScience, 7(4), 2011. [16] N. Kobayashi, N. Tabuchi, and H. Unno. Higher-order multi\u00adparameter tree transducers \nand recursion schemes for program veri\u00ad.cation. In POPL 10, pages 495 508, 2010. [17] N. Kobayashi, R. \nSato, and H. Unno. Predicate abstraction and CE-GAR for higher-order model checking. In PLDI 11, pages \n222 233. ACM, 2011. [18] D. E. Muller and P. E. Schupp. Alternating automata on in.nite trees. Theoretical \nCompututer Science, 54(2 3):267 276, 1987. [19] R. P. Neatherway, C.-H. L. Ong, and S. J. Ramsay. A traversal-based \nalgorithm for higher-order model checking. In ICFP 12, pages 353 364. ACM, 2012. [20] C.-H. L. Ong. On \nmodel-checking trees generated by higher-order recursion schemes. In LICS 06, pages 81 90. IEEE Comp. \nSoc., 2006. [21] C.-H. L. Ong. Models of higher-order computation: Recursion schemes and collapsible \npushdown automata. In LLRS 10, pages 263 299. 2010. [22] C.-H. L. Ong and S. J. Ramsay. Verifying higher-order \nfunctional programs with pattern-matching algebraic data types. In POPL 11, pages 587 598. ACM, 2011. \n[23] J. Plevyak and A. A. Chien. Precise concrete type inference for object\u00adoriented languages. In OOPSLA \n94, pages 324 340. ACM, 1994. [24] S. J. Ramsay, R. P. Neatherway, and C.-H. L. Ong. A type-directed \nab\u00adstraction re.nement approach to higher-order model checking. Long version: http://mjolnir.cs.ox.ac.uk/papers/preface.pdf. \n[25] R. Sato, H. Unno, and N. Kobayashi. Towards a scalable software model checker for higher-order programs. \nIn PEPM 13, pages 53 62. ACM, 2013. [26] Y. Tobita, T. Tsukada, and N. Kobayashi. Exact .ow analysis \nby higher-order model checking. In FLOPS 12, volume 7294 of LNCS, pages 275 289. Springer, 2012. [27] \nS. van Bakel. Strict intersection types for the lambda calculus. ACM Computing Surveys, 43(3):20, 2011. \n  \n\t\t\t", "proc_id": "2535838", "abstract": "<p>The trivial-automaton model checking problem for higher-order recursion schemes has become a widely studied object in connection with the automatic verification of higher-order programs. The problem is formidably hard: despite considerable progress in recent years, no decision procedures have been demonstrated to scale robustly beyond recursion schemes that comprise more than a few hundred rewrite rules. We present a new, fixed-parameter polynomial time algorithm, based on a novel, type directed form of abstraction refinement in which behaviours of a scheme are distinguished by the abstraction according to the intersection types that they inhabit (the properties that they satisfy). Unlike other intersection type approaches, our algorithm reasons both about acceptance by the property automaton and acceptance by its dual, simultaneously, in order to minimize the amount of work done by converging on the solution to a problem instance from both sides. We have constructed Preface, a prototype implementation of the algorithm, and assembled an extensive body of evidence to demonstrate empirically that the algorithm readily scales to recursion schemes of several thousand rules, well beyond the capabilities of current state-of-the-art higher-order model checkers.</p>", "authors": [{"name": "Steven J. Ramsay", "author_profile_id": "81548018878", "affiliation": "University of Oxford, Oxford, United Kingdom", "person_id": "P4383747", "email_address": "steven.ramsay@cs.ox.ac.uk", "orcid_id": ""}, {"name": "Robin P. Neatherway", "author_profile_id": "86159111957", "affiliation": "University of Oxford, Oxford, United Kingdom", "person_id": "P4383748", "email_address": "robin.neatherway@cs.ox.ac.uk", "orcid_id": ""}, {"name": "C.-H. Luke Ong", "author_profile_id": "81548018879", "affiliation": "University of Oxford, Oxford, United Kingdom", "person_id": "P4383749", "email_address": "luke.ong@cs.ox.ac.uk", "orcid_id": ""}], "doi_number": "10.1145/2535838.2535873", "year": "2014", "article_id": "2535873", "conference": "POPL", "title": "A type-directed abstraction refinement approach to higher-order model checking", "url": "http://dl.acm.org/citation.cfm?id=2535873"}