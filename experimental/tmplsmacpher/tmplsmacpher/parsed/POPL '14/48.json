{"article_publication_date": "01-08-2014", "fulltext": "\n Battery Transition Systems * Udi Boker Thomas A. Henzinger Arjun Radhakrishna The Interdisciplinary \nCenter, Herzliya, IST Austria, Klosterneuburg, Austria IST Austria, Klosterneuburg, Austria Israel Abstract \nThe analysis of the energy consumption of software is an impor\u00adtant goal for quantitative formal methods. \nCurrent methods, us\u00ading weighted transition systems or energy games, model the en\u00adergy source as an ideal \nresource whose status is characterized by one number, namely the amount of remaining energy. Real batter\u00adies, \nhowever, exhibit behaviors that can deviate substantially from an ideal energy resource. Based on a discretization \nof a standard continuous battery model, we introduce battery transition systems. In this model, a battery \nis viewed as consisting of two parts the available-charge tank and the bound-charge tank. Any charge \nor discharge is applied to the available-charge tank. Over time, the energy from each tank diffuses to \nthe other tank. Battery transition systems are in.nite state systems that, being not well-structured, \nfall into no decidable class that is known to us. Nonetheless, we are able to prove that the .-regular \nmodel\u00adchecking problem is decidable for battery transition systems. We also present a case study on the \nveri.cation of control programs for energy-constrained semi-autonomous robots. Categories and Subject \nDescriptors Theory of computation [Logic]: Veri.cation by model checking General Terms Theory, Veri.cation \nKeywords Battery, Transition systems, energy, model checking 1. Introduction Systems with limited energy \nresources, such as mobile devices or electric cars, have become ubiquitous in everyday life. In accor\u00addance, \nthere is a growing attention to the formal modeling of such systems and the analysis of their behavior. \nThese systems are com\u00admonly modeled as weighted transition systems, where the states of the transition \nsystem represent the system con.gurations, the tran\u00adsitions represent the possible operations, and the \nweights on the transitions correspond to the energy consumed (negative value) or added (positive value) \nduring the operation. In recent literature (for * This work was supported in part by the Austrian Science \nFund NFN RiSE (Rigorous Systems Engineering), and by the ERC Advanced Grant QUAREM (Quantitative Reactive \nModeling). Permission to make digital or hard copies of all or part of this work for personal or classroom \nuse is granted without fee provided that copies are not made or distributed for pro.t or commercial advantage \nand that copies bear this notice and the full citation on the .rst page. Copyrights for components of \nthis work owned by others than ACM must be honored. Abstracting with credit is permitted. To copy otherwise, \nor republish, to post on servers or to redistribute to lists, requires prior speci.c permission and/or \na fee. Request permissions from permissions@acm.org. POPL 14 , January 22 24, 2014, San Diego, CA, USA. \nCopyright c &#38;#169; 2014 ACM 978-1-4503-2544-8/14/01. . . $15.00. http://dx.doi.org/10.1145/2535838.2535875 \nexample, [7, 8, 19]), weighted transition systems have been ana\u00adlyzed with respect to various problems, \nsuch as .nite-automaton emptiness problem (starting from a given initial energy, can a spe\u00adci.c con.guration \nbe reached while keeping the energy positive in all intermediate steps?), and B \u00a8uchi emptiness problem \n(can a spe\u00adci.c con.guration be visited repeatedly, while keeping the energy positive?). In all these \nworks, the energy-resource is idealized. In partic\u00adular, it is assumed that its status can be completely \ncharacterized by one number, namely the amount of remaining energy. However, physical systems with energy \nrestrictions often use batteries, which are far from an ideal-energy source. One such non-ideal behavior \nof a battery behavior is the recovery effect , where the available en\u00adergy at certain times is smaller \nthan the sum of energies consumed and charged. Intuitively, the recovery effect is a result of the fact \nthat energy is consumed from the edge of the battery, while the total charge is spread across the entire \nbattery. When the consumption is high, additional time may be required until the charge diffuses from \nthe inside of the battery to its edge, during which period there is no available energy, possibly failing \nthe required operation. The recovery effect is often noticed in our daily usage of battery-powered systems, \nfor example mobile phones a phone might shutdown due to an out of power condition, but then be\u00adcome \nlive again after an idle period. We aim to formally model such energy systems with non-ideal resources. \nWe de.ne a battery transition system (BTS), where the system is viewed as a weighted transition system, \nas is stan\u00addard. However, the semantics of its possible traces is speci.ed dif\u00adferently, to capture non-ideal \nbehaviors. The semantics we specify for BTSs correspond to a discretization of a well-known battery model \n the kinetic battery model (KiBaM) [20]. There are various battery models in the literature, admitting \nvarious accuracies and complexities, among which the KiBaM model is a good choice for the purpose of \nproperly analyzing systems with the recovery effect [17]. We elaborate, in Section 2, on various battery \nmodels, and explain the derivation of BTS semantics from the KiBaM model. Semantics. The status of the \nbattery in a BTS is a pair (x, y), where x represents the available charge (available for immediate usage) \nand y the bound charge (internal charge in a battery that is not immediately available). During each \ntransition, some amount of charge diffuses between x and y. The weight of the transition (say w) affects \nonly x in the current step. The diffusion rate depends on the difference between x and y, and on two \nconstants of the battery: a width constant c . R with 0 < c < 1, and a diffusion constant k . R with \n0 < k < c(1 - c). Formally, making a transition of weight w from a battery status (x, y), results in \nthe '' ' y battery status (x, y), where x= x - k \u00b7 ( x c - 1-c ) + w and ' y y y= y + k \u00b7 ( x - ). The \nvalue k \u00b7 ( x - ) represents the c 1-c c 1-c amount of charge diffused between x and y. The above transition \nis legal if the available charge x remains positive after the transition.  Figure 1. In the battery \nsystem B1, a trace reaching the state s1 must make a cycle with total negative energy. In B2, an illegal \ntrace must make different choices at different visits in s0. The mathematical properties of a BTS are \nshown to be inher\u00adently different from those of a simple-energy transition system (where only the value \nof x+y is considered), as illustrated in Fig. 1: Considering the system B1 as a simple-energy system, \nwhere only the total energy should remain positive, s1 is directly reachable from s0, and the cycle s0 \n. s2 . s3 . s0 is completely useless. On the other hand, viewing B1 as a BTS, in order to go from state \ns0 to s1, counterintuitively, a legal trace must .rst take the cycle through s2 and s3. Though decreasing \nthe total energy, the cycle temporarily increases the available energy, allowing the transition to s1. \nFurthermore, it is known that a simple-energy system (even with multi-dimension energies) admits an illegal \ntrace if and only if it admits a memoryless illegal trace (always making the same choice at each state) \n[8]. However, an illegal trace in the system B2 of Fig. 1 must make different choices at different visits \nin state s0 (Theorem 3). Model checking. We consider the .nite-automaton, B \u00a8uchi, and Streett emptiness \nproblems for a BTS; these problems are central to the model checking of systems with no fairness constraints, \nweak fairness constraints, and strong fairness constraints, respectively. As BTSs are in.nite-state systems, \nit is natural to ask if they fall into a known, tractable, class of in.nite state systems. For exam\u00adple, \nstandard model-checking algorithms exist for well-structured transition systems (e.g., lossy channel \nsystems, timed automata [2], etc), where a well-quasi ordering can be de.ned on the states of the in.nite \nsystems, and this ordering is compatible with the transition relation of the system. However, for BTSs, \nwe can show that the ), ( 11 ), ( 43 , 1 21 in.nite sequence (1, 1), ( 3 , 1 1 , 1 5 ), . . . of bat\u00ad \n4 4 16 16 64 64 tery statuses is monotonically decreasing with respect to any or\u00addering that is compatible \nwith transitions. Intuitively, this sequence contains battery statuses that have equal total charge, \nbut strictly decreasing available charge. This implies that model-checking al\u00adgorithms from the domain \nof well-structured transitions systems do not apply directly to BTS. We solve the .nite-automaton emptiness \nproblem by building a forward reachability tree, along the lines of the Karp-Miller tree for Petri nets \n[11]. There, using the well-structured properties of Petri\u00adnets, the Karp-Miller tree is shown to be \na .nite summarization of all reachable states, despite there being in.nitely-many reachable states. A \nBTS is not well-structured, yet we are able to generate a .nite summary tree , having all the reachability \ndata, by proving the following key observations: 1. Once the total energy in a bat\u00adtery status is high-enough, \nthe problem can be reduced to simple\u00adenergy reachability; 2. Considering some characteristic properties \nof battery statuses allows to de.ne a simulation-compatible total ordering between statuses having the \nsame total energy; and 3. Re\u00adpeating a cycle whose total energy sums to 0 makes the battery status converge \nmonotonically to a limit value independent of the initial status. Despite the fact that the above ordering \nis not well\u00adfounded, i.e., there may be in.nite chains, the last observation lets us take limits of in.nite \nchains while constructing the reachability tree. In simple-energy systems, extending the .nite automaton \nempti\u00adness algorithm to a B \u00a8 uchi emptiness algorithm is straightforward checking whether there is \na reachable B \u00a8 uchi state that has a cycle back to itself, such that the sum of weights on the cycle \nis non\u00adnegative. In a BTS, such a simple solution does not work a cycle that does not decrease the total \nenergy might still fail the process after .nitely many iterations, as the available charge can slightly \ndecreases on every iteration. A simple modi.cation, seeking cycles that do not decrease both the total \nand the available energies is too restrictive, as the available charge may still converge to a positive \nvalue. We solve the B \u00a8 uchi emptiness problem by showing that if there exists an accepted trace, there \nalso exists a lasso-shaped ac\u00adcepted trace having one of two special forms. These forms concern the way \nthat the available charge changes along the cycle. By a del\u00adicate analysis of the reachability tree, \nwe then solve the question of whether the transition system allows for a trace in one of these special \nforms. The Streett emptiness problem is solved similarly, by using a small extension of the B \u00a8uchi emptiness \nalgorithm. We show that our algorithms for the .nite-automaton, B \u00a8uchi, and Streett emptiness problems \nare in PSPACE with respect to the number of states in the transition system and a unary representation \nof the weights. If weights are represented in binary, or if the battery constants are arbitrarily small \nand represented in binary, the space complexity grows exponentially. Case study: Robot control. We examine \na semi-autonomous robot control in an energy-constrained environment. We present a small programming \nlanguage for robot-controllers and de.ne quantitative battery-based semantics for controllers written \nin that language. We solve the .-regular model-checking problem for programs written in this language, \nusing our results on battery transition systems. We demonstrate the inadequacy of standard quantitative \nveri.cation techniques, where the battery is viewed as an ideal energy resource they might af.rm, for \nexample, that the robot can reach some target locations, while taking into account the non-ideal behavior \nof its battery, it cannot. Related work. Batteries are involved devices, exhibiting various different \nphenomena. Accordingly, there are many different works considering these aspects, for example scheduling \nthe load among several batteries [4, 9, 16, 18], optimizing the lifetime of a battery with respect to \nthe cycle aging effect [1], analyzing the thermal effects, and more. To the best of our knowledge, this \nis the .rst work to formally analyze an energy system with a non-ideal energy source. Previous work has \neither considered ideal energy sources (for example, [8]) or provides approximations for the battery \nlife-time with respect to various discharge scenarios (for example, [16, 17]). Our .nite-automaton emptiness \nalgorithm follows the approach taken in the Karp-Miller tree [11] which can be used in general for well-structured \ntransition systems [12]. However, our systems are not well-structured and a naive application of this \ntechnique does not entail termination of algorithms. We use ideas from .attable systems [3] and additional \nanalysis of BTSs to produce a terminat\u00ading version of these algorithms. In particular, we also use an \nintri\u00adcate analysis of BTSs to get an algorithm for deciding B \u00a8 uchi and Streett properties. This kind \nof analysis is not possible for general .attable systems.  2. Battery Models We provide a short description \nof how batteries are modeled in the literature, and explain how we derive our formal model of a battery. \nA battery consists of one or more electrochemical cells, each of which contain a negative electrode (anode), \na positive electrode (cathode), and a separator between them. During discharge and recharge, electrons \nmove through the external circuit, while chem\u00adical reaction produces or consumes chemical energy inside \nthe bat\u00adtery. For example, during discharge in lithium-ion (Li-ion) batter\u00adies, positive lithium ions \nmove from the anode to the cathode, while the reverse occurs during recharge (see Fig. 2). Figure 2. \nSchematic of a lithium-ion (Li-ion) battery. Figure 3. Concentration of electroactive species along \nthe battery, following a discharge and a recovery phase. Batteries of all types have a recovery effect \n, meaning that the chemical reaction inside the battery does not keep up with the rate of the external \nactivity. Internally, in Li-ion batteries, the con\u00adcentration of the electroactive species near the electrodes \nbecomes smaller than their concentration in the interior of the battery. When the battery has low load \nfor some time, the ions have enough time to diffuse to the electrodes, and charge recovery takes place \n(see Fig. 3). The well-known symptom of this is that a battery might be empty after some usage, but then \nbecomes charged after an idle period. There are many battery models modeling various aspects of a real \nbattery. The most accurate ones model the electrochemical re\u00adactions in detail [5, 10, 13, 21]. Though \nhighly accurate, they re\u00adquire con.guration of many (usually around 50) parameters, mak\u00ading them dif.cult \nto analyze. Another approach taken is to model the electrical properties of the battery using voltage \nsources, resis\u00adtors, and other elements [14, 15]. These approximate battery volt\u00adage behavior well, but \ntheir modeling of the available battery ca\u00adpacity is inaccurate. A third class consists of the analytical \nmodels that describe the battery at a high abstraction level, modeling only its major properties by means \nof a few equations. The dominant models of this class are the kinetic battery model [20], and the dif\u00adfusion \nmodel [22]. A detailed description of the various models can be found in [16, 17]. The possibly simplest, \nyet useful, model that handles the recov\u00adery effect is the kinetic battery model (KiBaM) [20]. While \nbeing originally developed for Lead-Acid batteries to model both battery capacity and battery voltage, \nits capacity modeling was found to be a good approximation even for more modern batteries such as the \nLi-ion battery. In [16, 17], it was theoretically shown that KiBaM hy Figure 4. Kinetic battery model \n(KiBaM). is a .rst order approximation of the diffusion model, which was designed for Li-ion batteries. \nIn addition, their experimental results show that it has up to 7 percent deviation from the accurate \nelectro\u00adchemical models. We concentrate on a battery s available capacity, and hence, adopt the KiBaM \nmodel. In this model, the battery charge is dis\u00adtributed over two tanks: the available-charge tank, denoted \nx, of width c . (0, 1), and the bound-charge tank, denoted y, of width 1 - c (see Fig. 4). The external \ncurrent gets electrons only from the available-charge tank, whereas electrons from the bound-charge tank \n.ow to the available-charge tank. When recharging, the re\u00adverse process occurs, electrons are added directly \nto the available\u00adcharge tank, from there they .ows to the bound-charge tank. The charge .ows between \nthe tanks through a valve with a .xed con\u00adductance p. The parameter p has the dimension 1/time and in\u00ad.uences \nthe rate at which the charge can .ow between the two tanks. This rate is also proportional to the height \ndifference be\u00adtween the two tanks. If the heights are given by hx = x/c and hy = y/(1 - c), and the current \nload by w(t), the charge in the tank over time behaves according to the following system of differ\u00adential \nequations [20]: dx dy = -w(t) - p(hx - hy); = p(hx - hy) (1) dt dt with initial conditions x(0) = c \u00b7 \nC and y(0) = (1 - c) \u00b7 C, where C is the total battery capacity. The battery cannot supply charge when \nthere is no charge left in the available-charge tank. We are interested in calculating the battery status \nalong a discrete-time transition system, thus consider the equations (1) for .xed time steps. We get \nthe following equations: xi+1 = xi-wi-k(hxi -hyi ); yi+1 = yi+k(hxi -hyi ) (2) where xi and yi are the \nvalues of x and y before the time step i, respectively, wi is the total load on the battery at time step \ni, and k = p \u00d7 (length of a time step). The smaller the time steps are, the smaller k is, and the more \naccurate the discretization is. We further need to ensure that the discretization does not intro\u00adduce \nundesirable behaviours. In Eq. 1 if hx > hy and w(t) is 0, the relation hx > hy keeps holding. We should \nensure this in the discrete model, i.e., if hxi > hyi and wi = 0, then it cannot be that . hxi+1 = hyi+1 \nFormalizing the above requirement, we have xi+1 xi - 0 - k(hxi - hyi ) k(hxi - hyi ) == = hxi - ; hxi+1 \nc c yi+1 yi + k(hxi - hyi ) k(hxi - hyi ) == = hyi + . hyi+1 1 - c 1 - c 1 - c Hence, hxi+1 - hyi+1 = \n(hxi - hyi )(1 - k( 1 )). c(1 - c) Therefore, the parameter k is acceptable if k( 1 ) < 1, c(1-c) leading \nto the conclusion that k < c(1 - c) (3)  3. Battery Transition Systems We incorporate the discrete battery \nmodel from Equation 2 into a weighted transition system. The system consists of .nitely many control-states \nand weighted transitions between them, where the weights denote the amount of energy recharged/consumed \nat each operation. 3.1 Weighted Transition Systems and Battery Semantics A transition system is a tuple \n(S, ., s.) where S is a (possibly in.nite) set of control states, s. . S is the initial control state, \nand . . S \u00d7 S is a set of transitions. A weighted transition system (WTS) is a tuple S = (S, ., s., . \n) where (S, ., s.) is a transition system, and . : . . Z is a weight function labeling transitions with \ninteger weights1 . A battery transition system (BTS or battery system, for short) is a tuple B = ((S, \n., s., . ), c, k) where (S, ., s., . ) is a WTS with a .nite number of control states (i.e., |S| < 8), \nc . R is a width constant with 0 < c < 1, and k . R is a diffusion constant with 0 < k < c(1 - c). Semantics. \nGiven a BTS B = (S, c, k), a battery status (x, y) . R2 >0 represents the current con.guration of the \nbattery. Intuitively, the values x and y represent the charge in the available-charge tank and the bound-charge \ntank of the battery, respectively (see Figure 4). If the current battery status is (x, y), on a transition \nof weight w, we de.ne the change in the battery status using a function Post : R2 \u00d7 Z . R2, letting the \nbattery status after the transi\u00adtion (x ' , y ' ) = Post((x, y), w). Here, we follow the standard con\u00advention \nof energy transition systems and consider a positive (resp. negative) weight as adding (resp. drawing) \na charge to (resp. from) the battery. In matrix notation, we have the following. T T x w Post((x, y), \nw) =AB \u00b7+, where y0 1 - k k c 1-c AB = k 1 - k c 1-c The matrix AB is called the diffusion matrix. Note \nthat the Post function indeed follows Equation 2 except for the change in the sign of w. The values k \n\u00b7 x and k \u00b7 y denote the heights c 1-c hx and hy of the two tanks, and hence, we get that x ' = x - k \n\u00b7 (hx - hy) + w and y ' = y + k \u00b7 (hx - hy). We abuse notation by de.ning Post(t, w1w2 . . . wm) inductively \nas Post(Post(t, w1), w2 . . . wm) where each wi . Z. Given an initial battery status t. . R>2 0, the \nsemantics of a BTS B = ((S, ., s., . ), c, k) is given by a (possibly in.nite) transition system (E, \n., e.) where E = S \u00d7 R2 is the set of >0 states, .. E \u00d7 E is the transition relation, and e. = (s., t.) \nis the initial state. We call each (s, t) . E an extended state with s . S being its control state, \nand t . R2 . >0 being its battery status 2  We have ((s, t), (s ' , t ' )) .. if and only if Post(t, \nw) = t ' and (s, s ' ) . . . .((s, s ' )) = w. We write (s, t) . (s ' , t ' ) instead of ((s, t), (s \n' , t ' )) ... A weight w (and by extension, a transition with weight w)  is feasible from battery status \nt if Post(t, w) . R>2 0, namely if Post(t, w) is a valid battery status. Similarly, a sequence of 1 The \nweights in a weighted transition system are often rational numbers rather than integers. All of our results \nequally hold for rational weights, by simply multiplying all weights by the product of all denominators. \n2 All of our results equally hold for the case that the element values should be non-negative, rather \nthan strictly positive, but the proofs are marginally simpler in the strictly positive case. weights \nw0w1 . . . wn is feasible from t iff w0 is feasible from t and each wi is feasible from Post(t, w0 . \n. . wi-1). Extending the nomenclature, we call every t . R2 \\ R2 >0 infeasible. The traces of a BTS B, \ndenoted .(B), are given by (in.nite or .nite) paths of the form p = (s0, t0)(s1, t1) . . . where s0 = \ns. and t0 = t. and for every i = 1, we have (si-1, ti-1) . (si, ti). The corresponding control trace \nis given by . = control(p) = s0s1 . . ., and the set of control traces by T(B) = {control(p) |p . .(B)}. \nWe say that a (.nite or in.nite) sequence of control states s0s1 . . . is feasible from a battery status \nt iff the weight sequence w0w1 . . . is feasible from t, where (si, si+1) . . . .((si, si+1)) = wi. Energy \nfeasibility. We de.ne an alternate set of semantics corre\u00adsponding to the classical notion of ideal-energy \nsystems. We say that (x, y) . R2 is energy-feasible if x + y > 0. As for the term feasible , we further \nextend the notion of energy-feasible as follows: 1. A sequence of weights w0 . . . wn is energy-feasible \nfrom (x, y) iff Post((x, y), w0 . . . wi) is energy-feasible for all 0 = i = n; and 2. A sequence of \ncontrol states s0s1 . . . is energy-feasible from (x, y) iff w0w1 . . . is energy-feasible from (x, y) \nwhere wi = .(si, si+1). Characteristic functions. For mathematical simplicity, we follow the approach \ntaken in [20] and use an alternate representation for battery statuses. We represent (x, y) using two \nother numbers, denoting it [e; d], where e and d are de.ned by the following energy and deviation functions. \n e = energy((x, y)) = x + y; and  d = deviation((x, y)) = x - y \u00b7 .  c 1 - c Intuitively, e is the \ntotal energy in the battery and d is the difference between the heights of the two tanks multiplied by \nthe factor c. The mathematical simplicity in using energy and deviation stems from the fact that they \ncorrespond to the eigenvectors of the diffusion matrix. Given e = energy(t) and d = deviation(t), the \nbattery status t = (x, y) is uniquely determined: x = ce + (1 - c)d and y = e - x. Hence, we use the \nnotations [e; d] and (x, y) interchangeably. Proposition 1. For any battery status [e; d] and w . N, \nwe have k - k that Post([e; d], w) = [e + w; . \u00b7 d + w] where . = 1 - . 1-c c The above proposition is \na translation of the Post function to the [e; d] notation. Intuitively, the energy is increased by the \nweight w as expected, while the difference in the tank heights is .rst reduced by a constant factor of \n. and then increased due to the charge w added to the .rst column. The factor . turns out to be the central \nparameter of the battery, playing a key role in how BTSs behaves. The following lemma formalizes the \nintuition that the bound-charge tank (y) cannot get empty before the available\u00adcharge tank (x) does. \nLemma 2. Suppose battery status (x, y) is feasible, and let '' ''' Post((x, y), w) = (x , y ). We have \n[e ; d ' ] = (x , y ) is feasi\u00adble iff x ' > 0, and, equivalently, if and only if ce ' + (1 - c)d ' > \n0. Proof. The only if implication is obvious. As for the if, we have ' k k ' k k x = (1 - )x + y + w \nand y = x + (1 - )y. c 1-c c 1-c Assuming x > 0 and y > 0, it easily follows that y ' > 0. Hence, (x \n' , y ' ) is infeasible if and only if x ' = 0 or equivalently, if x ' = ce ' + (1 - c)d ' = 0 Model \nchecking. The problems we consider ask for the existence of a control trace . in the semantics of a BTS \nB with control states S given an initial battery status t, such that . . F for some given objective set \nF . S * . S.. Speci.cally, we consider the following objective sets F:  Finite-automaton emptiness. \nAsking if there exists a feasible trace to a set of target control states. Formally, given target control \nstates T . S, we have F = Reach(T ) = {s0s1 . . . |.i : si . T }, i.e., F is the set of control traces \nwhich visit T at least once.  B\u00a8  uchi emptiness. Asking if there exists a feasible trace which visits \na set of target B \u00a8 uchi states in.nitely often. Formally, given Buchi control states \u00a8L . S, we have \nF = B\u00a8uchi(L) = {s0s1 . . . | .j.i > j : si . L}. Streett emptiness. The objective is speci.ed by a set \nof request-grant pairs (Ri, Gi) (where each pair consists of a set Ri . S of request control states and \na set Gi of grant control states). The objective asks if there exists a feasible trace in the system \nsuch that for every request\u00adgrant pair, either Gi is visited in.nitely often or Ri is vis\u00adited .nitely \noften. Formally, given a set of Streett pairs P = {(R0, G0), (R1, G1), . . . , (Rm, Gm)}, we have F = \nStreett(P ) = {s0s1 . . . | .0 = i = m : [(.p.q > p : sq . Gi) . (.p.q > p : sq . Ri)]}. We call the \ntraces which satisfy the .nite-automaton, B \u00a8 uchi, and Streett conditions, accepting, B \u00a8 uchi, and \nStreett traces, respec\u00adtively.  3.2 (Battery VS. Ideal-Energy) Transition Systems Due to the recovery \neffect, BTSs behave qualitatively differently from a simple-energy transition systems. Nevertheless, \nin the do\u00admain where the energy in the battery is high, they do behave simi\u00adlarly. This lets us solve \nproblems related to unlimited initial credit (referred to as unknown initial credit ) by reducing them \nto the simple-energy system problems. Different Behavior. The BTS B1 of Fig. 1 demonstrates a key difference \nfrom a simple-energy system the total energy in the initial state is 32, while a transition of weight \n(-17) cannot be taken, since the available energy is only 16. Yet, taking the cycle through states s2 \nand s3 reduces the total energy, but allows the (-17)-transition. After the cycle, the battery status \nis (19 3 4 , 11 1 4 ), which becomes ( 5 8 , 13 3 8 ) following a (-17)-transition. We formalize the \ndifference in the theorem below. It is known that if an ideal-energy system contains an infeasible trace, \nit con\u00adtains a memoryless infeasible trace [8]. A memoryless trace is one where a control state is always \nfollowed by the same control state. However, an infeasible trace in the system B2 of Fig. 1 must make \ndifferent choices at different visits in state s0. Theorem 3. A battery transition system may have feasible \n(resp. infeasible) traces without having any memoryless feasible (resp. infeasible) traces. Proof. Consider \nthe BTS B1 in Figure 1. There is a trace for reach\u00ading s1, as well as an in.nite trace, however both \ntraces make non\u00aduniform choices at different visits in s0. Analogously, an infeasible trace in the system \nB2 of Figure 1 must make different choices at s0. We prove below the claim for B2. Analogous arguments \nand calculations can be made with respect to B1. The only nondeterminism in B2 is in state s0, allowing \ntran\u00adsitions to states s1 and s2. A trace that .rst chooses s1 is legal, since the (-15)-transition is \nfeasible from the initial status, after which there are only positive-weight transitions. The other mem\u00adoryless \noption, of always choosing s2, is also legal: Let (x, y) be the battery status when .rst reaching s2. \nIt can be shown that the .rst few cycles s2 . s3 . s0 . s2 are feasible, after which the '' '' battery \nstatus will be (x , y ), such that x > x and y > y. By the monotonicity of the Post function, it follows \nthat the cycle can be repeated forever. On the other hand, .rst choosing s2 and then choosing s1 makes \nan illegal trace: The battery status when returning to s0 is (12 3 , 20 1 ), which changes to (- 5 , \n18 3 ) after the (-15)\u00ad 44 88 transition. High energy domain and unknown initial credit problems. In \nenergy systems, one often considers unknown-initial-credit prob\u00adlems , asking if there is some initial \nenergy that allows accomplish\u00ading a task. It is clear that every control state of a battery system can \nbe reached, at least once, if there is a path leading to it and enough initial energy to start with. \nThis is formalized in the follow\u00ading lemma (which will also serve us in Theorem 5 and in Section 4). \nLemma 4. Consider a BTS B = ((S, ., s., . ), k, c). There exist constants HighEnergyConstant(B, i) for \nevery i . N such that for every feasible extended state (s0, [e; d]) with e > HighEnergyConstant(B, i), \nevery weight sequence w0w1 . . . wi-1 of length i is feasible from (s0, [e; d]). Proof. We de.ne the \nconstants inductively as follows: (a) HighEnergyConstant(B, 0) = 0 if i = 0; and (b) HighEnergyConstant(B, \ni) =  h max HighEnergyConstant(B, i - 1) + W, W other\u00ad c(1-.) wise. Here, W = max(s,si).. |.((s, s ' \n))|. We prove the theorem by induction. When i = 0, the weight sequence is empty and there is nothing \nto prove. For the induction case, assume that we have shown the result up to i - 1. Let Post([e; d], \nw) = [e ' ; d ' ]. From Proposition 1, we get that e ' = e + w and d ' = .d + w. If [e ' ; d ' ] is feasible \nand e ' = HighEnergyConstant(B, i -1), we can apply the induction hypothesis on the weight sequence w1 \n. . . wi-1 to prove the result. We show these facts below. We have e ' = e + w > HighEnergyConstant(B, \ni) + w = HighEnergyConstant(B, i - 1) + W + w. As w = -W , we have that e ' > HighEnergyConstant(B, i \n- 1) = 0.  Further, we have that ce ' + (1 - c)d ' = ce + cw + (1 -c).d + (1 - c)w or, equivalently, \nce ' + (1 - c)d ' = (1 - .)ce + w + .(ce+(1-c)d). As [e; d] is feasible, by Proposition 1, ce+(1- c)d \n> 0. Further, e > HighEnergyConstant(B, i) = W .  c(1-.) Using these, we get ce ' + (1 - c)d ' > -W \n+ w = 0. By Lemma 2, [e ' ; d ' ] is feasible, completing the proof. The following theorem states that \nthe emptiness problems for battery systems reduce to the corresponding problems for energy systems if \nthe initial energy is large enough. Theorem 5. Let B = ((S, ., s., .), k, c) be a BTS, W = max(s,si).. \n|.((s, s ' ))|, and T , L and {(R0, G0), . . . , (Rn, Gn)} be a set of target states, a set of B \u00a8uchi \nstates, and a set of Streett pairs, respectively. There exist constants MR = HighEnergyConstant(B, |S|) \n, MB = HighEnergyConstant(B, 3|S| + 2W |S|2), and MS = HighEnergyConstant(B, |S| + |S|2 + W |S|2 + W \n|S|3) such that for any extended state (s, [e; d]): if e > MR (resp. e > MB and e > MS), a feasible accepting \n(resp. B \u00a8uchi and Streett) trace starting from (s, [e; d]) exists iff an energy-feasible accepting (resp. \nB \u00a8uchi and Streett) trace exists. Proof of theorem 5. In all three parts, the existence of an energy \nfeasible trace is directly implied by the existence of a feasible trace. Therefore, we only deal with \nshowing that the existence of an energy feasible trace implies the existence of a feasible trace. The \n.rst part (.nite-automaton emptiness) follows directly from Lemma 4. If there exists a path from s to \nthe target set T , there exists a path of length at most |S|. Taking MR = HighEnergyConstant(B, |S|) \nis suf.cient to give us the result.  For the second part (B \u00a8uchi emptiness), the existence of an energy \nfeasible trace implies that there exists a reachable cycle which visits a B \u00a8 uchi state and has non-negative \ntotal weight. It can be shown that the length of such a cycle can be bounded by 2|S| + 2W |S|2. Now, \nif e > HighEnergyConstant(B, |S| + 2|S| + 2W |S|2), we can show, using Lemma 4, that there is a '' ' \nfeasible path from (s, [e; d]) to some (s , [e ; d ' ]) where s is on the cycle and e ' > HighEnergyConstant(B, \n2|S| + 2W |S|2). ' ' ; d ' Now, the cycle is feasible from (s , [e ]) and further, on return\u00ading to s \n', the energy is at least e ' (as the total weight of the cycle is non-negative). Using such reasoning, \nit is easy to see that the cycle is repeatedly feasible from (s ' , [e ' ; d ' ]). Hence, a value of \nMB = HighEnergyConstant(B, |S| + 2|S| + 2W |S|2) is suf.\u00adcient. The proof for the third part is very \nsimilar to the proof of the second part except for the bound on the length of the cycle. A straightforward \nconsequence of the above theorem is that the unknown initial credit problems for BTSs are decidable. \nFurther\u00admore, using the above theorem, it is easy to show that these BTS problems are equivalent to the \ncorresponding energy-systems prob\u00adlems, which can be solved in polynomial time [6]. Corollary 6. Given \na BTS B and a .nite-automaton, B \u00a8 uchi, or Streett condition, the problem of whether there is an initial \nbattery status [e; d], such that there exists a feasible trace in B satisfying the condition is decidable \nin polynomial time. 4. The Bounded-Energy Reachability Tree Our algorithms for solving the emptiness \nproblems are based on representing the in.nite tree of all the possible traces in the BTS in a .nite \ntree that summarizes all required information. The con\u00adstruction of the tree uses a high-energy constant \n exploration from states whose energy is above the constant is stopped, as they can be further handled \nby a reduction to a simple-energy system us\u00ading Theorem 5. Hence, the tree summarizes bounded-energy \nreach\u00adability, and we denote it BERT. As in Theorem 5, the value of the high-energy constant depends \non the problem to be solved. We de\u00adscribe how we construct the tree, taking the high-energy constant \nas a parameter. We start with some basic lemmata about a total or\u00adder among battery statuses of equal \nenergy. Then, we present the 0-cycle saturation lemma, which helps summarize unbounded iter\u00adations of \ncycles in a .nite manner. Feasibility order for battery statuses. The following lemma shows that there \nexists a total order on the set of battery statuses with the same energy such that every weight sequence \nfeasible from a lower battery status is also feasible from a higher battery status. Lemma 7. Given two \nbattery statuses [e; d] and [e; d ' ] with d > d ' , every weight sequence w0w1 . . . wn-1 feasible from \n[e; d ' ] is also feasible from [e; d]. Furthermore, if Post([e; d], w0 . . . wn-1) = '' ; d '' '' ; \nd ''' [e ] and Post([e; d ' ], w0 . . . wn-1) = [e ], we have d '' > d ''' . Proof. We prove the result \nby induction. For the base case, we let the weight sequence be of length 1, i.e., w0. From Proposi\u00adtion \n1, we know that Post([e, d], w0) = [e + w0, .d + w0] and Post([e, d ' ], w0) = [e + w0, .d ' + w0]. Hence, \nd '' = .d + w0 and d ''' = .d ' + w0. As d > d ', we get that .d + w0 > .d ' + w0 > d ''' and d '' . \nNow, assume that [e + w0; .d ' + w0] is feasible. By Lemma 2, we get that c(e +w0) + (1 -c)(.d ' +w0) \n> 0. As d > d ', we have c(e +w0) + (1 -c)(.d +w0) > 0 and c(e +w0) + (1 -c)d '' > 0. This gives us that \n[e + w0; d '' ] is feasible, hence completing the proof for the base case. Now, assume that the required \nresult holds for every weight sequence of length n - 1. Applying the induction hypothesis on the battery \nstatuses [e + w0; .d + w0] and [e + w0; .d ' + w0] and the weight sequence w1 . . . wn-1 gives us the \nrequired result. Guided by Lemma 7 above, we de.ne a partial order on the set of battery statuses as \nfollows: [e ' ; d ' ] . [e; d] if e = e ' and d ' ' = d, in which case we say that [e; d] subsumes [e \n; d ' ]. We extend the partial order . to extended states (with both control ' ' ; d ' states and battery \nstatuses) by letting (s , [e ]) . (s, [e; d]) if ' ' ; d ' s = s and [e ] . [e; d]. Lemma 7 can now be \nrestated as ' ' ; d ' follows: If (s , [e ]) . (s, [e; d]), every control path feasible ' ' ; d ' from \n(s , [e ]) is also feasible from (s, [e; d]). Zero-cycle saturation. We formalize below the key observation \nthat 0-energy cycles can be .nitely summarized: an in.nite run along such a cycle monotonically converges \nto a .xed battery status. Moreover, the deviation in the limit is independent of the initial status. \nLemma 8 (Zero-cycle saturation). Let w0 . . . wn-1 be a sequence n-1 of weights such thati=0 wi = 0 and \nlet t0, t1, . . . be a sequence of tuples in R2, such that ti+1 = Post(ti, w0 . . . wn-1). We have the \nfollowing: 1. The sequence t0, t1, . . . converges (say to t * = [e * ; d * ]). In other words, .E = \n0..m . N : |t * - tm|1 = E where |.|1 denotes the maximum absolute component in a vector.  2. We have \n.i . N : t * . ti . t0 or .i . N : t0 . ti . t *. In the latter case, if w0 . . . wn-1 is feasible from \nt0 it is feasible from each ti.  Proof. Let ti = [ei; di]. Obviously, .i.ei = e *. By repeated ap\u00adplication \nof Proposition 1 on the weights w0w1 . . . wn-1, start\u00ad .n-1-p ing with ti, we have di+1 = di \u00b7 .n +n-1 \nwp \u00b7 . i-p1 =0 Hence, for all i . N, di = d0 \u00b7 .i\u00b7n +q=0 L \u00b7 .n\u00b7q, where n-1 L =wp \u00b7 .n-1-p. From this, \nit follows that the sequence p=0 8 L \u00b7 .q\u00b7n 1 di converges to d * == L \u00b7 . Further, q=0 1-.n i i\u00b7n+n \n.n\u00b7q d(i+1) = d0 \u00b7 .+ L \u00b7 q=0 i-1  i\u00b7n .n\u00b7q i\u00b7n+n i\u00b7n i\u00b7n = d0 \u00b7 .+ L \u00b7 + d0 \u00b7 [.- .] + L \u00b7 . q=0 i\u00b7n+n \ni\u00b7n i\u00b7n = di + d0 \u00b7 [.- .] + L \u00b7 . = di + .i\u00b7n(1 - .n) \u00b7 [ L - d0] 1 - .n i\u00b7n * = di + .(1 - .n) \u00b7 [d \n- d0] Since .i..i\u00b7n(1 - .n) is positive, it follows that di+1 is bigger, or not, than di based on whether \nd * < d0 or not. If d * < d0, we get d0 > d1 > . . . > d *, or, equivalently, t0 ; t1 ; . . . ; t * . \nSimilarly, if d * = d0, we get d0 = d1 = . . . = d *, or, equivalently, t0 . t1 . . . . . t *. The feasibility \nof w0 . . . wn from each ti follows from Lemma 7 and ti ; t0. d * We denote the limit deviation as Saturate(w0w1 \n. . . wn-1), i.e., Saturate(w0w1 . . . wn-1) = h 1 n-1 \u00b7 .n-1-p \u00b7 wp . Note that this deviation 1-.n \np=0 does not depend on the initial battery status t0. Accord\u00adingly, we extend the de.nition of the function \nSaturate to battery statuses as Saturate([e; d], w0w1 . . . wn-1) = [e; Saturate(w0w1 . . . wn)].  Constructing \nthe tree. For generating a .nite tree with all the rel\u00adevant bounded energy reachability information, \nwe explore the fea\u00adsible states and transitions starting from the initial state. However, 1. Extended \nstates with high-enough energies are not explored further, and 2. If an extended state q that has an \nancestor q ' with the same control state and the same energy (but possibly a different deviation) is \nreached, we check the feasibility order, i.e., if  ' ' ' q q or q q. If q q we stop exploration from \nq; otherwise, we saturate this 0-energy cycle from q ' to q, i.e., calculate the .xed battery status \nt * to which an in.nite run on that cycle will monotonically converge to (see Lemma 8). Then, we replace \nthe battery status in q ' with the maximum between battery status in q and t * . The procedure ComputeBERT \n(Algorithm 1) computes the bounded-energy reachability tree BERT, given a BTM B, an initial battery \nstatus t, and an energy bound M. It is a rooted tree where each node is labelled with an extended state. \nDuring the procedure s execution, each node in the tree is either open (in OpenNodes) or closed, and \nexploration will only continue from open nodes. In ad\u00addition, each node contains a Boolean .eld star, \nmarking whether its label is a result of saturation. Initially, the root of BERT is la\u00adbelled with the \ninitial extended state (s., t) and the root node is added to the set of OpenNodes. In each step, one \nopen node (currNode) is picked and removed from the set of OpenNodes. Let currNode.label = (s, [e; d]). \nBy default, we append to currNode children labelled by all feasible successors of (s, [e; d]) (we call \nthis an exploration step). If one of the following holds, we do not perform the exploration step. In \ncase the energy (i.e., e) of currNode is greater than the given bound M, we stop exploration from it. \n In case an ancestor ancestor (with label (s, [e; d ' ])) of  currNode has the same control state and \nenergy as currNode: If [e; d] [e; d ' ] we stop exploration from currNode. If [e; d ' ] c [e; d] we i) \ndelete all the descendants of ancestor; and ii) replace the battery status in the label of ancestor with \nthe c-maximum between [e; d] and the zero-cycle saturation of [e; d ' ], where d ' is the 0-cycle saturation \nof the the weight sequence from ancestor to currNode. Note that if the weight sequence from ancestor \nto currNode is infeasible from [e; d ' ] (which can happen if there is a saturation of another cycle \nbetween the ancestor and currNode), we replace [e; d ' ] by [e; d] and not the max\u00adimum. When no open \nnodes are left, the procedure stops and returns BERT. We prove in a series of lemmata the properties \nof the procedure ComputeBERT and of the returned tree. Termination. We prove that Algorithm 1 terminates \nfor every input, by showing a bound on both the number of possible nodes in BERT and the number of node \ndeletions in an execution. The latter bound follows from (i) every deletion event strictly increases \na deviation value; and (ii) the number of possible values that a deviation can get in a deletion event \nis bounded. Note that this is in contradiction to the unbounded number of deviations that may occur in \na trace of the BTS B. Lemma 9. Algorithm 1 terminates on all inputs. Proof. Termination follows from \na bound on both the number of possible nodes in BERT and the number of node deletions in an execution. \nThe number of nodes in a tree depends on the fanout of the nodes and the length of the branches. The \nfanout of every node in Algorithm 1 ComputeBERT: Computing the bounded-energy reachability tree Require: \nBattery system B = ((S, ., s., . ), k, c), initial battery status t, energy bound M 1: BERT . EmptyTree \n2: BERT.root.label . (s., t); BERT.root.star . false 3: OpenNodes . {BERT.root} 4: while OpenNodes = \n\u00d8 do 5: Pick and remove currNode from OpenNodes 6: (s0, [e; d]) . currNode.label 7: // If we found a \ngood cycle, saturate that cycle 8: if currNode has an ancestor ancestor with label (s0, [e; d ' ]) then \n9: if d > d ' then 10: s0 . . . sns0 . control state sequence in node labels from ancestor to currNode \n11: w0 . . . wn . .((s0, s1)).((s1, s2)) . . . . ((sn, s0)) 12: if w0w1 . . . wn is feasible from [e; \nd ' ] and Saturate(w0 . . . wn) > d then 13: ancestor.label .(s0, [e; Saturate(w0 . . . wn)]); 14: ancestor.star \n. true 15: else {There was another cycle saturation between ancestor and currNode} 16: ancestor.label \n. [e; d] 17: BERT.delete(all descendants of ancestor) 18: OpenNodes . OpenNodes . {ancestor} \\ all descendants \nof ancestor 19: continue; // If d < d ' there is no further exploration from the current node 20: else \n{Explore one step further} 21: for all (s0, s ' ) . . do 22: if Post([e; d], . (s0, s ' )) is feasible \nthen 23: newNode . new child of currNode 24: newNode.label . (s ' , Post([e; d], . (s0, s ' ))); 25: \nnewNode.star . false 26: if energy(Post([e; d], .(s0, s ' ))) = M then 27: OpenNodes . OpenNodes . newNode \n28: return BERT BERT is bounded by the number of states in the BTS B. As for the branches, the control \nstate and energy of each node in a path is unique, except for the leaf, giving a bound of |S| \u00d7 M + 1 \nto the length of a path. The bound on the number of deletions follows from (i) every deletion event strictly \nincreases a deviation value; and (ii) the num\u00adber of possible values that a deviation can get in a deletion \nevent is bounded. Note that this is in contradiction to the unbounded num\u00adber of deviations that may \noccur in a trace of the BTS B. Consider a node-deletion event in the execution of Algorithm 1, and a \nnew deviation value set to ancestor.label. (i) The new value is either Saturate(w0 . . . wn) or d, set \nin Line 14 or Line 16, which are in the scope of if Saturate(w0 . . . wn) > d > d ' or if d > d ' , respectively, \nwhile the old value is d ' . (ii) The new value is uniquely determined by the following:  The value \nof Saturate(w0 . . . wn), where w0 . . . wn is the sequence of weights from ancestor to currNode; or \n The label of the last saturated (i.e., starred) node be\u00adtween ancestor and currNode, and the suf.x \nwi . . . wn of w0 . . . wn corresponding to the segment from the last starred node to currNode, otherwise. \n In the .rst case, resulting from Line 14, the new value only depends on w0 . . . wn, which in turn \nis determined by s0s1 . . . sns0. In the (i); d(i) second case, resulting from Line 16, let (si, [e]) \nbe the label  (i); d(i) of the last starred node. By Lemma 8, [e] only depends on the sequence of weights \nin a simple cycle of the BTS B, thus may take a bounded number of possible values. The new value is then \ncalculated by Post([e(i); d(i)], wi . . . wn), which only depends on [e(i); d(i)] and the sequence wi \n. . . wn. Correctness. We now prove that BERT is a summarization of all extended states reachable through \nstates of low-energy. Let Reach(M) be the set of extended states reachable from the initial state of \nthe BTS B through paths containing only extended states of energy less than M. In the lemmata below, \nwe prove the following: Soundness. For every node node in BERT and for all E > 0, there is an extended \nstate q . Reach(M) such that q node.label and the difference between the deviations of q and node.label \nis smaller than E.  Completeness. For every extended state q . Reach(M), there exists a node node in \nBERT such that q node.label.  Lemma 10 (Soundness). For every node node with label (s, [e; d]) encountered \nin an execution of Algorithm 1 and E > 0, there exists an extended state (s, [e; d - d]) reachable from \n(s., t) with 0 = d < E. Proof. The claim can be proved by looking at all the points in the algorithm \nwhere a new label is created (lines 10, 14, and 25). The claim is trivially true for the initial label \nof the root. Assume as induction hypothesis that the claim holds for every label encountered upto the \ncurrent point of the execution. Fix E = 0. Saturation. Let the new label be created during a deletion \nevent, in line 10 or line 14. In the case the label of currNode is copied to the label of ancestor, the \nproof follows immediately as we are just copying an existing label. Otherwise, we are taking the Saturate \nvalue, and the proof is based on Lemma 8. By iterating the path from ancestor to currNode a suf.cient \nnumber of times, we can get as close as necessary (i.e., within E) to the limit of the zero\u00adweight cycle \nsaturation. Lemma 8 also gives us that every iteration is feasible. Exploration. Let (s ' , [e ' ; d \n' ]) be a new node label created in line 25. Choosing E ' < min( f, ce ' + (1 - c)d ' ), by the induction \nhypoth\u00ad . esis, there is a feasible path from (s., t) to (s, [e; d - d ' ]) with 0 = d ' < E ' . ' ; \nd ' Now, we have [e ] = Post([e; d], w) = [e + w; .d + w] and Post([e; d - d ' ], w) = [e ' ; d ' - . \n\u00b7 d ' ]. Letting d = .d ' , we get 0 = d = .d ' < .E ' = E. If we prove that [e ' ; d ' - d] is feasible, \nwe are done as we have shown that the path from (s., t) to (s, [e; d -d ' ]) followed by the feasible \ntransition from (s, [e; d - '' '' d ' ]) to (s , [e ; d ' - d]) is a path from (s., t) to (s , [e ; d \n' - d]). As [e ' ; d ' ] is feasible, we get that ce ' + (1 - c)d ' > 0. As we chose that E ' < ce ' \n+ (1 - c)d ', we get that ce ' + (1 - c)d ' - d = ' ' ' ce + (1 - c)d ' - .d ' > ce + (1 - c)d ' - .E \n' > ce + (1 - c)d ' - .(ce ' + d ' ) > (1 - .)(ce ' + (1 - c)d ' ) > 0. This completes the proof for \nthis case. Lemma 11 (Completeness). Let (s, [e; d]) be an extended state with e < M that is reachable \nfrom (s., t) through extended states with energy less than M. Then, there exists a node with label (s, \n[e; d ' ]) in BERT with d ' = d. Proof. We prove the lemma by induction on the length of the path from \n(s., t) to (s, [e; d]). For paths of length 0, it is trivial as (s., t) is the initial label of the root. \nSuppose we have proven the claim for paths upto the length n - 1. It is easy to induct to length n. Suppose \nthe path of length n - 1 ending with (s, [e; d]) is extended to length n by adding (s, [e; d]). The proof \nhas two cases: If the node labelled with (s, [e; d ' ]) is a non-leaf node, then it . ..i .i has a successor \nlabelled (s, [e; d]), with d> d., which is the required node. This follows from lines 21 27 of Algo. \n1. If the BERT node labelled with (s, [e; d ' ]) is a leaf node, it will have an ancestor labelled (s, \n[e; d '' ]) with d '' = d. This follows from line 19 of Algorithm 1. Since the latter node is not a leaf, \nwe comply with the previous case, and we are done. 5. Model Checking We are now ready to tackle the .nite-automaton, \nB \u00a8uchi, and Streett emptiness problems for BTSs. We show that the problems are decidable and give suitable \nalgorithms. The algorithms are based on Theorem 5 and analysis of the bounded-energy reachability tree, \nas constructed in Section 4. 5.1 Finite-Automaton Emptiness Combining the results from the previous \nsection on bounded en\u00adergy reachability tree and Theorem 5, we can obtain a complete algorithm for the \n.nite-automaton emptiness problem in a battery system. Given a BTS B with states S, an initial battery \nstatus t, the algorithm works as follows: Build a bounded-energy reachability tree BERT = ComputeBERT(B, \n(s., t), M ), where M = HighEnergyConstant(B, |S|));  If there is a node label (s, [e; d]) in BERT \nwhere s is in the target set T , return true;  If there is a node label (s, [e; d]) in BERT where e \n> M , and some node in the target set is reachable from (s, [e; d]) through an energy-feasible path, \nreturn true;  Otherwise, return false. The correctness proof of the algorithm follows from Lemma 4 and \nthe soundness and completeness of the bounded-energy reachabil\u00adity tree (Lemmas 10 11). The following \ntheorem states that this algorithm can be implemented in polynomial space in the inputs.  Theorem 12. \nThe .nite-automaton emptiness problem for BTSs is decidable in polynomial space with respect to the number \nof control states in the BTS and a unary encoding of weights. Proof. The major part of the algorithm \nis the construction of the bounded-energy reachability tree. For a given energy bound M, this tree can \ncontain an exponential number of nodes in M. However, using standard on-the-.y techniques, we can reduce \nthe space com\u00adplexity, only storing the current branch of the tree being explored. The corresponding \nspace is the product of the number of nodes in each branch and the bits required for storing a node s \nlabel. By the proof of Lemma 9, the length of each branch in the tree is bounded by |S| \u00d7 M + 1, where \nS are the states of the given BTS B. For the .nite-automaton emptiness algorithm, we use M = HighEnergyConstant(B, \n|S|) and by the proof of Lemma 4, we have M = |S|W + W , where W is the maximal c(1-.) negative weight \nin the BTS. With a unary encoding of the constants, M is polynomial in the size of the input. To complete \nthe proof, we need to show that all the labels created in BERT can be represented in polynomial space \nin the energy bound M. A label contains a control state, an energy, and a deviation. There are |S| < \nM control states and up to M different energies. As for the deviations, they are generated by a sequence \nof operations, involving two functions: Post (de.ned in Section 3) and Saturate (de.ned in Lemma 8). \nBy Lemma 8, the value of Saturate is independent of the deviation value before saturation. Hence, the \ndeviation at each node in BERT is a result of the last Saturate operation in the branch of BERT leading \nto the node, followed by some Post operations. By the proof of Lemma 9, the length of each branch in \nthe tree is polynomial in M, implying up to M applications of Post. Hence, it is left to show that the \nSaturate function generates a deviation that can be stored in space polynomial in M, and that each application \nof the Post function adds up to b bits, where b is polynomial in M.  By Lemma 8, given a sequence w0w1 \n. . . wn-1 of weights, h 1 n-1 \u00b7 .n-1-p Saturate(w0w1 . . . wn-1) = \u00b7 wp . The 1-.n p=0 space required \nto store this value is polynomial in the constant . and n, where n = |S| < M . In each application of \nPost on a battery status [e; d] and weight w, we have, by Proposition 1, that Post([e; d], w) = [e ' \n; d ' ], with d ' = . \u00b7 d + w. Hence, storing d ' requires up to b bits more than storing d, where b \nis polynomial in the constant . and |w| < M .  5.2 B\u00a8uchi and Streett Emptiness Suppose we are given \na BTS B = ((S, ., s., . ), k, c) and a B \u00a8uchi condition given by a set of B \u00a8uchi states B . S. Our \napproach to B \u00a8uchi emptiness consists of two major parts. If there exists a B \u00a8uchi trace containing \nan extended state with energy more than MB = 3|S| + 2W |S|2, the problem can be reduced to the B \u00a8uchi \nproblem for simple-energy systems (Theorem 5). Therefore, we concentrate on the case where the energy \nof states is bounded by MB . Here, the key idea is that if the energies of the extended states are bounded, \nthen a BTS has a B \u00a8uchi trace if and only if it has a B \u00a8uchi trace of a special form. First, we de.ne \nthe notion of an energy-unique path: we call a control trace s0s1 . . . sn energy-unique if we have p \n.((si, si+1)) = q .((si, si+1)) . sp = sq for p = q. i=0 i=0 Intuitively, s0s1 . . . sn is energy-unique \nif no trace whose corre\u00adsponding control trace is s0 . . . sn has two extended states with the same control \nstate and equal energy. Similarly, s0s1 . . . sn is an energy-unique 0-energy cycle if s0s1 . . . sn \nis energy-unique and n-1 i=0 .((si, si+1)) + .((sn, s0)) = 0. The following theorem intuitively states \nthat if there exists a bounded-energy B \u00a8uchi trace in B, then there exists a lasso-shaped bounded-energy \nB \u00a8uchi trace where the .rst state of the cycle in the lasso is a B \u00a8uchi state and the cycle in the \nlasso has one of the two following forms: l ll the cycle is an energy-unique 0-energy cycle s0 . . . \ns ns0, l lll l such that the sequence s0s1 . . . s ns0 is feasible from s0 with the battery status Saturate(w0w1 \n. . . wn), where wi = ll ll .((si, s i+1)) for i < n and wn = .((sn, s 0)); or the cycle is an energy-unique \n0-energy cycle composed of an alternating sequence of energy-unique paths and energy-unique 0-energy \ncycles. Here, every energy-unique 0-energy cycle in the sequence is unique. Theorem 13. Suppose a BTS \nB has a B \u00a8uchi trace such that every extended state has energy less than some constant M. Then, B has \na B \u00a8uchi trace p such that the corresponding control trace . has one of the following two forms: lll \nl Form 1 . = .h(s0s1 . . . s n). where s0 is a B \u00a8uchi state, and ll ll s0s1 . . . s ns0 is an energy-unique \n0-energy cycle. Form 2 . = .h(.l). , where .h, .l . S * and .l = 0 0 nn n+1 n+1 (s0 . . . s )(.l0)r0 \n. . . (s0 . . . s ) . . . (.ln)rn (s . . . s kn+1 ) k0 k1 0 and (a) each .li is a distinct energy-unique \n0-energy cycle; (b) each s0 i . . . s ki i is a energy-unique path; (c) .l is a 0-energy cycle; and (d) \ns0 0 is a B \u00a8uchi state. We omit the proof of Theorem 13 due to lack of space. The proof proceeds by \ntaking a witness B \u00a8 uchi trace and reducing it to one of the two forms by deleting parts of the trace \nwhere the initial and .nal energies and control states are the same, while the .nal deviation is less \nthan the initial deviation. The algorithm. The B \u00a8uchi-emptiness algorithm intuitively con\u00adsists of two \nseparate parts: (a) searching for high energy B \u00a8uchi traces (where some extended state has energy more \nthan MB = HighEnergyConstant(B, 3|S| + 2W |S|2)); and (b) searching for low energy fair traces (where \nevery extended state has en\u00adergy less than MB ). The algorithm .rst constructs BERT = ComputeBERT(B, \n(s., t), MB). High energy. For every node label (s, [e; d]) in the BERT where e > MB , we check (using \ntechniques of [6]) whether there exists an energy-feasible fair trace from it. Form 1 low energy. For \nevery node label (s, [e; d]) in BERT with e = MB and s . B, we check if there exists a fair trace of \nForm 1 starting from (s, [e; d]). Performing this check entails constructing energy-unique 0-energy cycles \n.l starting from s and examining if .l is feasible from Saturate((s, [e; d]), .l). Form 2 low energy. \nFor every s . B and e < MB , we run Algorithm 2 with initial state s and initial battery status [e; d] \nto check if there exists a fair trace of Form 2. Here, d is the maximum deviation of a node label which \nhas control state s and energy e. Algorithm 2 Finding form 2 low energy fair traces Require: Battery \nsystem B = ((S, ., s., . ), k, c), Energy bound M . N, Control state s, Initial battery status [e; d] \n1: d * . d 2: while true do 3: BERT . ComputeBERT(((S, ., s, . ), k, c), [e; d * ], M ) 4: P . {leaf.label \n| BERT leaf leaf has label (s, [e; d ' ]) . leaf has a starred ancestor } 5: if P = \u00d8 then 6: return \nfalse 7: else if d * = max{d ' | (s, [e; d ' ]) . P } then 8: return true 9: else d * 10: . max{d ' | \n(s, [e; d ' ]) . P } Lemma 14. Algorithm 2 returns true if B contains a B \u00a8 uchi trace of Form 2, and \nfalse otherwise. Intuitively, Algorithm 2 works by .nding some deviation d * such that (s, [e; d * ]) \nis feasibly reachable from itself through some number of 0-energy cycle saturations (represented by starred \nnodes). In every iteration of the while-loop, it decreases the pos\u00adsible value for d * to the largest \ndeviation for control-state s and energy e reachable from the previous value of d * through some starred \nnodes. If d * becomes so low that we are not able to saturate any 0-energy cycle starting from (s, [e; \nd * ]), then we return false. Theorem 15. B \u00a8uchi emptiness for battery transition systems is decidable \nin polynomial space with respect to the number of states and a unary encoding of weights and constants. \nEquipped with Theorem 13, the proof of Theorem 15 follows in a similar fashion as in Theorem 12. Using \nsimilar techniques, we can construct an algorithm for Streett emptiness. In this case, also keeping track \nof the set of states visited along each branch of the reachability tree. Theorem 16. Street emptiness \nfor battery transition systems is decidable in polynomial space with respect to the number of states \nand a unary encoding of weights and constants.  5.3 .-Regular Model Checking Equipped with a procedure \nfor checking B \u00a8 uchi emptiness (Theo\u00adrem 15), one can check whether a given BTS B satis.es any .\u00adregular \nconstraint . that is de.ned with respect to B s states. Such a constraint can be formalized, for example, \nby a linear temporal logic (LTL) formula, whose atomic propositions are the names of the states in B. \nIndeed, any .-regular constraint . can be translated to a B \u00a8  uchi automaton A, such that A s language \nis equivalent to the language of . (or to the language of its negation, as is the common practice in \nthe case of an LTL formula) [24]. Now, one can take the product of A and B, de.ned in the usual way, \ngetting a BTS C with a B \u00a8 uchi emptiness problem. As Streett emptiness is a special case of .-regular \nmodel check\u00ading, one may wonder why we bothered to have Theorem 16. The reason lies in the complexity \n In Theorem 16, we show that Streett emptiness can be solved in the same complexity class as the one \nfor B\u00a8uchi uchi emptiness, while translating a Streett automaton into a B \u00a8automaton might involve an \nexponential state blowup [23]. 6. Case Study We conclude this paper with a case study relating to controlling \nan energy-constrained robot. We .rst de.ne a toy language for pro\u00adgramming the robot controller, inspired \nby various real languages for programming robots, and de.ne how the different constructs interact with \nthe environment. The setting. We model a semi-autonomous robot that operates in an arena DL where each \nl . DL is a possible location of the robot. For example, a location can be an (x, y) vector, providing \nthe position of the robot in a plane of 1, 000 \u00d7 1, 000 squares. We model the environment of the robot \nas a function that gives attributes to each location in the arena. Formally, the environment is E : DL \n. (DE1 , DE2 , . . . , DEm ) where each DEi is a .nite domain of some property. For example, the environment \nmay de.ne the terrain of each location and whether it lies in the sun or in the shade, in which case \nE(3, 5) = ( smooth terrain , sun ) means that the location (3, 5) is a sunny place with a smooth terrain. \nNote that, in this case study, the environment is time invariant. The actions of the robot are governed \nby its control program. In each time step, denoted by a tick , the control program computes output actions \nbased on some external inputs, sensor values, and the values of the robot s internal variables. The external \ninput is given by input variables (I1, . . . , Ik), each over a .nite domain DIi , and it comes from \nan external independent agent. The sensor values, given by sensor variables (S1, . . . , Sr), over the \n.nite domains DS1 , . . . , DSr , are computed automatically based on the environment of the robot and \nits cur\u00adrent location. Formally, for each sensor variable Si there is a func\u00adtion .i : E \u00d7 DL . DSi . \nThe robot also has some internal variables, (N1, . . . , Ng), over the .nite domains DN1 , . . . , DNg \n, used for putting a logic in its behavior. The output actions are given by output variables (A1, . . \n. , Al), over the .nite domains DA1 , . . . , DAl . Upon performing the actions, the current loca\u00adtion, \ngiven in the variable L, is automatically computed based on the previous location and the actions; formally, \nby a function . : DL \u00d7 DA1 \u00d7 . . . \u00d7 DAl . DL. The state of the robot, V, encapsulates the values of \nall the above variables. There is a cost function Energy which gives the energy gain (positive) or consumption \n(negative) of actions in the given environment, i.e., Energy is of type DE1 \u00d7 . . . \u00d7 DEm \u00d7 DA1 \u00d7 . . \n. \u00d7 DAl . Z. For the functions ., .i, and Energy, we use the short-hand of applying the function to the \nwhole state instead of the relevant variables. For example, instead of writing .i(l) = v and value of \nL in state s is l , we write .i(s) = v . The controller language. The language of the robot-control pro\u00adgram \nis de.ned by the syntax shown in Figure 5. Most of the con\u00adstructs in this language are standard, and \nwill not be explained program := statements statements := statement | statement; statements statement \n:= (label : tick) | action_var = expr | internal_var = expr | skip | if (expr == 0) statements else statements \n| while (expr == 0) statements expr := sensor_var | input_var | internal_var | expr + expr | constant \n| expr * expr | (expr == 0) ? expr : expr Figure 5. Syntax of the robot-control language in detail. Note \nthat the program cannot directly write to the loca\u00adtion variables and sensor variables, but can only \nwrite to the inter\u00adnal variables and action variables. The most interesting construct in the syntax is \nthe tick statement. Intuitively, the tick state\u00adment performs the actions described by the output variables \n(i.e., changes the location using the . function) and reads new values into the sensor variables (based \non the environment and the cur\u00adrent state, using the .i functions) and into the input variables (non\u00addeterministically). \nThe formal semantics of the tick statement is described in the next paragraph. We provide in Example \n17 a simple setting of an environment, a control program, and the .nite domains of the various variables. \nExample 17. The environment (arena). x.y 1 2 3 4 1 - - \u00d7 - 2 \u00d7 / \u00d7 - 3 - / / / 4 - \u00d7 / / Legends. : \nSun ; : Shade -: hard ; / : soft ; \u00d7: obstacle The robot variables. Location. DL = {(1, 1), (1, 2), \n. . . , (4, 4)} Inputs. DI1 = {Move, None} DI2 = {Front , Back, Left , Right } Sensors. DS1 = {InTheSun, \nInTheShade} DS2 = {SunOnFront , NoSunOnFront } . . . Sensors for sun and obstacles all around DS9 = \n{ObstacleOnRight , NoObstacleOnRight }Actions. DA1 = {Move, None}DA2 = {Front , Back, Left , Right } \nInternal. DN1 = {InTheSun, InTheShade}DN2 = {WasInTheSun, WasInTheShade}DN3 = {Was2 InTheSun, Was2 InTheShade} \nThe cost function. (The direction does not matter.) Energy(Sun, Hard /Soft, None) = +12 Energy(Sun, Hard \n, Move) = +1 Energy(Sun, Soft, Move) = -1 Energy(Shade, Hard /Soft, None) = -5 Energy(Shade, Hard , Move) \n= -12 Energy(Shade, Soft, Move) = -15 The robot-control program. The program, intuitively, de.nes the \nfollowing behavior.  Obey the external input, whenever it is legal. Otherwise, do nothing, if legal, \nor else check for a legal action.  The constraints for a legal action: Do not go into an obstacle. (A \nlocation out of the arena is considered as an obstacle.)   Do not stay in the sun for more than two \nconsecutive steps. Whenever staying for two consecutive steps in the sun, avoid the sun for at least \ntwo consecutive steps. The code is straightforward; we give below some of its fragments. while(1) { // \nCheck if the input is legal // Moving into an obstacle? if (I1 = Move &#38;&#38; ( I2 = Front &#38;&#38; \nS6 = ObstacleOnFront || I2 = Back &#38;&#38; S7 = ObstacleOnBack || I2 = Left &#38;&#38; S8 = ObstacleOnLeft \n|| I2 = Right &#38;&#38; S9 = ObstacleOnRight ) ) A1 := None // Too much in the sun? if (N2 = WasInTheSun \n &#38;&#38; (N1 = InTheSun || N3 = Was2InTheSun) &#38;&#38; ... ) // Choose a legal action if (N1 = InTheShadow) \nA1 := None else if (S2=NoSunOnFront &#38;&#38; S6=NoObstacleOnFront) A1 := Move; A2 := Front ... label1 \n: tick; N3 := (N2=WasInTheSun)? Was2InTheSun:Was2InTheShade N2 := (N1=InTheSun)? WasInTheSun : WasInTheShade \n N1 := S1 } Semantics. Consider a robot-control program P , and .x diffu\u00adsion constant k and a width \nconstant c for a battery. We de.ne the semantics of P in the standard small-step operational style. We \nsummarize the state of the program as (s, t) where s is a val\u00aduation of the variables, and t is a battery \nstatus. Therefore, the small-step semantics is given by a relation . where intuitively, (P, (s, t)) . \n(P ' , (s ' , t ' )) holds if executing the .rst step from the program fragment P at state (s, t) leads \nto (s ' , t ' ) and the re\u00admaining program fragment is P ' . We assume that all the constructs except \ntick are executed instantaneously, and without any consumption of power; hence, the only construct that \nupdates the battery status in the summary is the tick. Therefore, for all the other constructs, we do \nnot explicitly present the semantics, but point out that the semantics are similar to a standard while-language. \nFor the tick construct, we de.ne the semantics using the proof rules from Figure 6. Intuitively, on executing \na tick, the effects of the output actions are performed, the sensor variables are updated based on the \nnew location and environment, the next valuation of the input variables is given, and then the battery \nstatus is updated based on the cost of the actions in the current environment. Problem statement. We \nconsider model-checking problems; that is, asking whether a given model satis.es a given speci.cation. \nThe model, in our case, is a robot and its environment; namely, a robot-control program, battery constants, \nan initial battery status, an environment with locations DL, and an initial location. The speci.cation \nis a regular or .-regular language over the (.nite or in.nite) sequences of locations in DL. The model-checking \nproblem is af.rmatively answered if the robot has a path, in the given setting, such that the sequence \nof locations along the path belongs to the language of the speci.cation. Consider, for example, the setting \nof Example 17 together with an initial location (1, 1), a battery width constant 1 2 , a battery dif\u00adfusion \nconstant 1 8 , and an initial battery status (16, 16). A regular speci.cation can ask, for instance, \nwhether the robot has a .nite path reaching the location (3, 2). An .-regular speci.cation can ask, say, \nwhether the robot has an in.nite path visiting the loca\u00adtion (1, 4) in.nitely often, while avoiding the \nlocations (3, 1) and (4, 4). Model-checking algorithm. Given a control-program P , an en\u00advironment E, \na battery width constant c, a battery diffusion con\u00adstant k, an initial battery status t., and an initial \nvariable val\u00aduation s., we de.ne the equivalent battery transition system BTS[P, E, c, k, t., s.] = ((S, \n., s., . ), c, k) as follows. Let L be the set of labels of the tick statements in the program. A state \nin the BTS is a pair (l, s) where l . L is a label, and s is a valuation of all the variables in the \nprogram.  There exists a transition from (l1, s1) to (l2, s2) on weight w  if for some program fragments \nP1 and P2: there exist battery statuses t1 and t2 and a proof that ((l1 : tick);P1, (t1, s1)) . ((l2 \n: tick);P2, (t2, s2)) where the T ick rule is applied exactly once; and there exist battery statuses \nt1 and t2, such that there is a proof (P, (s., t1)) . ((l1 : tick);P1, (s1, t2)). The cost of a transition \nfrom (l, s) is w if applying the cost function on the valuation of the environment and action vari\u00adables \nin s is w.  The initial state s. is given by (l, s) such that there exists a program fragment P1 and \na battery status t such that there is a proof of (P, (s., t)) . (((l : tick);P1), (s, t)) containing \nno applications of the T ick rule. Due to the determinism of our language, it is guaranteed that there \nexists only one such (l, s). A part of the BTS corresponding to Example 17 is given in  Figure 7. 1 \n1 The battery diffusion constant k = and its width constant c = . 8 2 -5 (16, 16) (1, 1) (2, 2) (3, 2) \n-15 Sun ... Shade Sun WasShade WasShade WasShade Was2Shade Was2Shade Was2Shade +12 +1 (1, 1) (1, 2) -12 \nWasSun WasSun -15 Was2Shade Was2Shade Sun Shade -12-12 -5 (1, 2) (2, 2) ... Shade Shade WasShade WasShade \n +1 ... Was2Sun Was2Sun -5 -12 (1, 2) Shade WasSun Was2Sun Figure 7. A part of the BTS that corresponds \nto the robot and its environment, as described in Example 17. The best path to location (3, 2) appears \nin boldface blue. This path is infeasible by the BTS semantics, while feasible by models that are based \non an ideal\u00adenergy resource. We have the following theorem. Theorem 18. Consider a robot model-checking \nproblem consisting of a control-program P , an environment E with locations DL, a battery width constant \nc, a battery diffusion constant k, an initial  Tick (label : tick, (s, t)) . (effects; sensors; inputs; \nbattery, (s, t)) cost(s) = w Post(t, w) = t ' v1 . DI1 . . . vl . DIl Battery Inputs (battery, (s, t)) \n. (skip, (s, t ' )) (inputs, (s, t)) . (skip, (s[.k : Ik := vk], t ' )) v1 = .1(s) . . . vr = .r(s) v \n= .(s) Sensors Effects (sensors, (s, t)) . (skip, (s[.k : Sk := vk], t ' )) (effects, (s, t)) . (skip, \n(s[.k : L := v], t ' )) Figure 6. Semantics of tick battery status t., an initial variable valuation \ns., and a regular or .-regular language f over the sequences of locations in DL. Let B = BTS[P, E, c, \nk, t., s.]. For a control state b . B, let Location(b) be the valuation of the robot location variable \nin b. Let f ' be a regular or .-regular language over sequences of control locations in B, such that \na sequence b0, b1, . . . . F ' iff Location(b0), Location(b1), . . . . F. Then, the robot model-checking \nproblem is equivalent to the BTS model-checking of B and f ' . Battery vs. ideal energy. Model-checking \nthe robot behavior, tak\u00ading into account the non-ideal aspects of the energy resource, is in\u00adherently \ndifferent from considering the battery as an ideal energy resource, as demonstrated in Example 17. There, \nthe robot cannot go with an initial battery status of (16, 16) from location (1, 1) to (3, 2) (cf., Theorem \n3.) On the other hand, it is possible to go from location (4, 4) to (3, 4), starting with the same initial \nbattery status. Note that such a situation is impossible with a model that is based on an ideal-energy \nresource, as the energy loss going from location (4, 4) to (3, 4) is 15, while from location (1, 1) to \n(3, 2) it is only 14! (The reason, as elaborated on in Sections 2 3, lies in the in.u\u00adence of the energy \nchanges along the path on the available charge of the battery.) 7. Conclusions and Future Work We presented \nthe .rst discrete formal model of battery systems and showed that the standard automaton emptiness problems \nfor this model are decidable. Further, these battery transition systems do not fall into the large class \nof well-structured transition systems. In terms of future work, a natural direction is to explore stan\u00addard \nprogram analysis and program synthesis questions for systems that use batteries. For example, to begin \nwith, one could de.ne an extension to standard imperative languages to allow programs to branch based \non the status of the battery. For programs written in such a language, one could attempt to compute invariants \nabout the combined program-and battery-state through abstract interpreta\u00adtion. Also, one could attempt \nbattery-aware partial-program syn\u00adthesis for such a language. This would be a generalization of the battery-aware \nscheduling problem studied in [18]. Another direc\u00adtion to explore is the possibility of solving two-player \ngames for battery transition system, leading to battery-aware algorithms for synthesis of reactive systems. \nReferences [1] R. Adany and T. Tamir. Online algorithm for battery utilization in electric vehicles. \nIn FedCSIS, pages 349 356, 2012. [2] R. Alur, C. Courcoubetis, and D. L. Dill. Model-checking for real-time \nsystems. In LICS, pages 414 425, 1990. [3] S. Bardin, A. Finkel, J. Leroux, and P. Schnoebelen. Flat \nacceleration in symbolic model checking. In ATVA, volume 3707 of LNCS, pages 474 488, 2005. [4] L. Benini, \nG. Castelli, A. Macii, E. Macii, M. Poncino, and R. Scarsi. Extending lifetime of portable systems by \nbattery scheduling. In DATE, pages 197 203, 2001. [5] G. G. Botte, V. R. Subramanian, and R. White. Mathematical \nmodel\u00ading of secondary lithium batteries. Electrochimica Acta, 45(15):2595 2609, 2000. [6] A. Chakrabarti, \nL. de Alfaro, T. Henzinger, and M. Stoelinga. Re\u00adsource interfaces. In EMSOFT, volume 2855 of LNCS, pages \n117 133, 2003. [7] K. Chatterjee and L. Doyen. Energy parity games. Theor. Comput. Sci., 458:49 60, 2012. \n[8] K. Chatterjee, L. Doyen, T. A. Henzinger, and J. F. Raskin. General\u00adized mean-payoff and energy games. \nIn FSTTCS, volume 8 of LIPIcs, pages 505 516, 2010. [9] C. Chiasserini and R. Rao. Energy ef.cient battery \nmanagement. J. on Selected Areas in Communications, 19(7):1235 1245, 2001. [10] M. Doyle, T. F. Fuller, \nand J. Newman. Modeling of galvanostatic charge and discharge of the lithium/polymer/insertion cell. \nJ. of the Electrochemical Society, 140(6):1993, 1526 1533. [11] A. Finkel and P. Schnoebelen. Parallel \nprogram schemata. J. of Computer and System Sciences, 3(2):147 195, 1969. [12] A. Finkel and P. Schnoebelen. \nWell-structured transition systems everywhere! Theor. Comput. Sci., 256(1 2):63 92, 2001. [13] T. F. \nFuller, M. Doyle, and J. Newman. Relaxation phenomena in lithiumion-insertion cells. J. of the Electrochemical \nSociety, 141(4): 982 990, 1994. [14] S. Gold. A PSPICE macromodel for lithium-ion batteries. In Annual \nBattery Conference on Applications and Advances, pages 215 222, 1997. [15] S. C. Hageman. Simple PSPICE \nmodels let you simulate common battery types. Electronic Design News, 38(22):117 129, 1993. [16] M. R. \nJongerden. Model-based energy analysis of battery powered systems. PhD thesis, University of Twente, \n2010. [17] M. R. Jongerden and B. R. Haverkort. Which battery model to use? IET Software, 3(6):445 457, \n2009. [18] M. R. Jongerden, A. Mereacre, H. C. Bohnenkamp, B. R. Haverkort, and J.-P. Katoen. Computing \noptimal schedules for battery usage in embedded systems. IEEE Trans. Industrial Informatics, 6(3):276 \n286, 2010. [19] K. G. Larsen, S. Laursen, and J. Srba. Action investment energy games. In MEMICS, volume \n7721 of LNCS, pages 155 167, 2012. [20] J. Manwell and J. McGowan. Lead acid battery storage model for \nhybrid energy systems. Solar Energy, 50(5):399 405, 1993. [21] E. Podlaha and H. Cheh. Modeling of cylindrical \nalkaline cells. J. of the Electrochemical Society, 14(1):15 27, 1994. [22] D. Rakhmatov and S. Vrudhula. \nAn analytical high-level battery model for use in energy management of portable electronic systems. In \nInternational Conference on Computer Aided Design (ICCAD), pages 488 493, 2001. [23] S. Safra and M. \nVardi. On .-automata and temporal logic. In STOC, pages 127 137, 1989. [24] M. Vardi. An automata-theoretic \napproach to linear temporal logic. In Logics for Concurrency: Structure versus Automata, volume 1043 \nof LNCS, pages 238 266, 1996.   \n\t\t\t", "proc_id": "2535838", "abstract": "<p>The analysis of the energy consumption of software is an important goal for quantitative formal methods. Current methods, using weighted transition systems or energy games, model the energy source as an ideal resource whose status is characterized by one number, namely the amount of remaining energy. Real batteries, however, exhibit behaviors that can deviate substantially from an ideal energy resource. Based on a discretization of a standard continuous battery model, we introduce {\\em battery transition systems}. In this model, a battery is viewed as consisting of two parts -- the available-charge tank and the bound-charge tank. Any charge or discharge is applied to the available-charge tank. Over time, the energy from each tank diffuses to the other tank.</p> <p>Battery transition systems are infinite state systems that, being not well-structured, fall into no decidable class that is known to us. Nonetheless, we are able to prove that the $\\omega$-regular model-checking problem is decidable for battery transition systems. We also present a case study on the verification of control programs for energy-constrained semi-autonomous robots.</p>", "authors": [{"name": "Udi Boker", "author_profile_id": "81442614582", "affiliation": "The Interdisciplinary Center, Herzliya, Herzliya, Israel", "person_id": "P4383910", "email_address": "udiboker@gmail.com", "orcid_id": ""}, {"name": "Thomas A. Henzinger", "author_profile_id": "81100034124", "affiliation": "IST Austria, Klosterneuburg, Austria", "person_id": "P4383911", "email_address": "tah@ist.ac.at", "orcid_id": ""}, {"name": "Arjun Radhakrishna", "author_profile_id": "81472655351", "affiliation": "IST Austria, Klosterneuburg, Austria", "person_id": "P4383912", "email_address": "aradha@ist.ac.at", "orcid_id": ""}], "doi_number": "10.1145/2535838.2535875", "year": "2014", "article_id": "2535875", "conference": "POPL", "title": "Battery transition systems", "url": "http://dl.acm.org/citation.cfm?id=2535875"}