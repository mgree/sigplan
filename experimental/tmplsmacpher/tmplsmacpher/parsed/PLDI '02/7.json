{"article_publication_date": "05-17-2002", "fulltext": "\n Deriving Specialized Program Analyses for Certifying Component-Client Conformance G. Ramalingam Alex \nWarshavsky John Field IBM T.J. Watson Research Center IBM Haifa Research Laboratory and IBM T.J. Watson \nResearch Center rama@watson.ibm.com Tel-Aviv University j.eld@watson.ibm.com warshavskyalex@hotmail.com \nDeepak Goyal Mooly Sagiv IBM T.J. Watson Research Center Tel-Aviv University dgoyal@watson.ibm.com sagiv@math.tau.ac.il \nABSTRACT We are concerned with the problem of statically certifying (verify\u00ading) whether the client of \na software component conforms to the component s constraints for correct usage. We show how confor\u00admance \ncerti.cation can be ef.ciently carried out in a staged fashion for certain classes of .rst-order safety \n(FOS) speci.cations, which can express relationship requirements among potentially unbounded collections \nof runtime objects. In the .rst stage of the certi.ca\u00adtion process, we systematically derive an abstraction \nthat is used to model the component state during analysis of arbitrary clients. In general, the derived \nabstraction will utilize .rst-order predicates, rather than the propositions often used by model checkers. \nIn the second stage, the generated abstraction is incorporated into a static analysis engine to produce \na certi.er. In the .nal stage, the resulting certi.er is applied to a client to conservatively determine \nwhether the client violates the component s constraints. Unlike veri.cation approaches that analyze a \nspeci.cation and client code together, our technique can take advantage of computationally-intensive \nsym\u00adbolic techniques during the abstraction generation phase, without affecting the performance of client \nanalysis. Using as a running ex\u00adample the Concurrent Modi.cation Problem (CMP), which arises when certain \nclasses de.ned by the Java Collections Framework are misused, we describe several different classes of \ncerti.ers with vary\u00ading time/space/precision tradeoffs. Of particular note are precise, polynomial-time, \n.ow-and context-sensitive certi.ers for certain classes of FOS speci.cations and client programs. Finally, \nwe eval\u00aduate a prototype implementation of a certi.er for CMP on a variety of test programs. The results \nof the evaluation show that our ap\u00adproach, though conservative, yields very few false alarms, with acceptable \nperformance. Categories and Subject Descriptors F.3.1 [Logics and Meanings of Programs]: Specifying \nand Veri\u00adfying and Reasoning about Programs; F.3.2 [Logics and Meanings Permission to make digital or \nhard copies of all or part of this work for personal or classroom use is granted without fee provided \nthat copies are not made or distributed for pro.t or commercial advantage and that copies bear this notice \nand the full citation on the .rst page. To copy otherwise, to republish, to post on servers or to redistribute \nto lists, requires prior speci.c permission and/or a fee. PLDI 02, June 17-19, 2002, Berlin, Germany. \nCopyright 2002 ACM 1-58113-463-0/02/0006 ...$5.00. of Programs]: Semantics of Programming Languages \nprogram analysis General Terms Veri.cation, Algorithms, Theory, Experimentation, Languages Keywords \nAbstract interpretation, model checking, software components, pred\u00adicate abstraction, static analysis \n1. INTRODUCTION A fundamental impediment to effective use of software compo\u00adnents or libraries is ensuring \nthat client code satis.es the constraints that the component imposes as a prerequisite to correct usage. \nThe Canvas1 project at IBM Research and Tel-Aviv University [4] aims to ease the use of software components \nby Allowing the component designer to specify component con\u00adformance constraints, which describe correct \ncomponent us\u00adage by a client program in a natural (yet still formal) way.  Providing the client code \ndeveloper with automated software certi.cation tools to determine whether the client satis.es the component \ns conformance constraints.  For the purposes of this paper, we consider a component to be any object-oriented \nsoftware library, and focus on components written in Java. 1.1 The Concurrent Modi.cation Problem The \nConcurrent Modi.cation Problem (CMP), which arises in the context of the Java Collections Framework (JCF) \n[5], is a typ\u00adical conformance constraint problem that we will use as a running example in the sequel. \nJCF Iterators are used to iterate over the contents of an underlying collection (e.g., a HashSet, which \nimplements the Set interface). A fundamental constraint on the use of iterators is that once an iterator \nobject oi is created for a collection oc, it may be used only as long as the collection oc is not modi.ed, \nnot counting modi.cations made via oi. This restric\u00adtion ensures that the internal state invariants of \noi are not corrupted by another iterator, or by direct update to the collection. JCF col\u00adlections detect \nviolations of this constraint dynamically, and throw 1Component ANnotation, Veri.cation, And Stuff class \nMake { private Worklist worklist; public static void main (String[] args) { Make m = new Make(); \nm.initializeWorklist(args); m.processWorklist(); } void initializeWorklist(String[] args) { ...; worklist \n= new Worklist(); ... } void processWorklist() { HashSet s = worklist.unprocessedItems(); for (Iterator \ni = s.iterator(); i.hasNext()){ Object item = i.next(); // CME may occur here if (...) processItem(item); \n }} void processItem(Object i) { ...; doSubproblem(...); } void doSubproblem(...) { ... worklist.addItem(newitem); \n... } } public class Worklist { HashSet s; public Worklist(){s=new HashSet(); ... } public void addItem(Object \nitem) { s.add(item); } public HashSet unprocessedItems() { return s; } } Figure 1: An erroneous Java \nprogram fragment throwing CME. ConcurrentModificationException(or CME) when it oc\u00adcurs (note that the \nname of the exception is misleading, since it often occurs in single-threaded programs). We will use \nCMP to refer to the problem of statically determining whether a JCF client may cause CMEto be thrown. \nConsider the Java code fragment in Fig. 1. Here, an iterator is cre\u00adated on a worklist, which is implemented \nusing a HashSet,a JCF collection class. The iterator is then used to process each item on the worklist \nin succession. We observe that CMEcan be thrown dur\u00ading item processing, since the nested call to doSubproblem(...) \ncauses worklist.addItem(newitem) to be called, which will in turn update the underlying HashSet while \nthe iterator is still active. On the next iteration, the call to i.next() would cause CMEto be thrown. \n 1.2 First Order Safety Constraints In Section 2, we will see that CMP is an instance of a class of \nconformance constraint problems where the component s dynamic state can be characterized (for speci.cation \npurposes) by a .rst\u00adorder structure. A .rst-order structure consists of a .nite collection of predicates \nranging over a potentially unbounded universe of indi\u00adviduals. Using .rst-order structures to model component \nstate per\u00admits, e.g., dynamic memory allocation or dynamic thread creation in the component to be modeled \nin a natural way [34, 40]. State up\u00addates in the component are modelled by updates to predicate values; \nin addition, the universe of individuals may also evolve expand and contract as a consequence of dynamic \nresource allocation or deletion in the component. In the sequel, we will develop static certi.cation \ntechniques for certain classes of .rst-order safety (FOS) constraints. In its most general form, an FOS \nconstraint is simply a .rst-order logical for\u00admula .over the set of predicates characterizing the component \nstate. A client is said to satisfy .if, for any input to the client, every com\u00adponent state encountered \nduring the client s execution satis.es .. Note that FOS constraints can be trivially used to specify \n.nite state properties of a component, as well as constraints involving dynamically-allocated resources. \n In Section 2, we will show how CMP and other FOS constraints can be formally, yet naturally, speci.ed \nas an abstract program in a language called Easl2. 1.3 Staged Certi.cation Our approach to static component \ncerti.cation is based on ab\u00adstract interpretation [11] of the client program and is conservative, which \nensures that every potential violation of the component s con\u00adformance constraints is detected. However, \na potential drawback of a conservative approach is the possibility of false alarms : spuri\u00adous reporting \nof conformance violations that do not actually occur. For an abstract interpretation to yield acceptable \nresults, it is critical to use a static abstraction of the runtime state that is precise enough to avoid \nexcessive false alarms, without yielding an analysis that is computationally intractable. In this paper, \nwe address this issue by systematically generating component-speci.c abstractions from a formal speci.cation \nof a component s conformance constraints in the following staged manner: 1. First, the component designer \nor implementer writes a spec\u00adi.cation describing both the component s conformance con\u00adstraints and those \naspects of the component s behavior that are pertinent to the component state referred to by the constraints. \n 2. The component s conformance speci.cation is used to sys\u00adtematically derive a component-speci.c state \nabstraction. This abstraction utilizes instrumentation predicates de.ned by .rst\u00adorder logical formulae \nover the .rst-order structure underly\u00ading the component speci.cation. We refer to such an abstrac\u00adtion \nas a .rst-order predicate abstraction, since it generalizes the nullary predicate abstractions (i.e., \nproposition) tradition\u00adally used in model checking. 3. The generated abstraction is combined with a \nstatic analysis engine to yield a certi.er speci.c to the component s con\u00adformance speci.cation. By choosing \nbetween different anal\u00adysis engines, it is possible to obtain certi.ers with various time/space/precision \ntradeoffs. 4. The certi.er is used to analyze the client to conservatively determine whether possible \nviolations of the conformance constraints can occur.  The separation of component-speci.c abstraction \nderivation from client analysis is a distinguishing feature of our approach. Since the abstraction derivation \nprocess is carried out only at certi.er genera\u00adtion time, resource-intensive symbolic analysis may be \nused during the abstraction derivation phase without affecting the ef.ciency of client analysis. 1.4 \nOverview In the remainder of the paper, we present the following results: In Section 2, we show by example \nhow FOS properties such as CMP can be naturally speci.ed as abstract programs in Easl. In Section 3, \nwe show how a simple form of conformance certi\u00ad.cation can be carried out by applying classical abstract \ninterpreta\u00adtion or data.ow analysis to a composite program formed by inlining the component s behavior \nspeci.cation at every component method call site in the client. For CMP, this certi.cation approach can \nbe viewed as an application of generic heap analysis. However, we show through examples that generic \nheap analysis (or similar generic program analysis) applied to a composite program tend to be imprecise \nand/or expensive, since the abstractions used by the 2Executable Abstraction Speci.cation Language generic \nanalysis are oblivious to the details of the constraint speci\u00ad.cation. In Section 4, we show how to remedy \nthe imprecision of the generic certi.cation technique using the staged approach outlined in Section 1.3. \nThis process is illustrated for a single CMP client method in which references to collections and iterators \nare stored only in local or static variables (rather than in object .elds). We will refer to this restricted \nversion of CMP as SCMP ( shallow CMP). We show that this approach yields a simple polynomial\u00adtime certi.er \nfor SCMP that is precise: i.e., the certi.er computes the precise meet-over-all-paths solution, and any \nimprecision in the certi.er arises solely from the imprecision in the abstraction used for the client \ns state. Section 5 shows how to handle unrestricted clients of CMP by using a more general version of \nthe abstraction generation process described in Section 4. Section 6 shows that the staged certi.cation \nprocess generates precise certi.ers for any member of a class of mutation-restricted constraint speci.cations \nIn Section 7, we measure the precision and running times of a pro\u00adtotype implementation of our algorithm \nfor the unrestricted CMP problem on a suite of test cases, including both real-world pro\u00adgrams that use \nJCF and contrived test cases representing dif.cult instances of CMP. We discuss several con.guration \noptions for the core TVLA analysis engine that yield different time/space/precision tradeoffs for CMP \nanalysis. The resulting analysis produces mini\u00admal false alarms on the test cases, with reasonable speed. \nSection 8 shows how the intraprocedural analysis for SCMP pre\u00adsented in Section 4 can be extended to \nyield a precise, context\u00adsensitive, polynomial-time interprocedural analysis for SCMP. Finally, a detailed \ncomparison to related work is given in Sec\u00adtion 9.  2. ABSTRACTPROGRAMSASSPECIFICA-TIONS Easl speci.cations \ntake the form of abstract Java programs (sim\u00adilar facilities are found in JML [24]), which serve both \nto describe critical aspects of the component s behavior, and to indicate con\u00adstraints that must be satis.ed \nby any well-behaved client. Easl combines a restricted subset of Java statements (assignments, con\u00additionals, \nloops, and heap allocation), a restricted set of primitive types (booleans and object references), built-in \nset and map types, and a requires statement (which describes a constraint that must be satis.ed at a \nparticular point in the component s execution). These constructs are suf.cient to simulate conventional \npre-and post\u00adconditions, as well as various forms of .nite state speci.cations. Most importantly, Easl \nallows a natural expression of component behaviors that determine the relationships among potentially \nun\u00adbounded numbers of component objects. 2.1 Specifying CMP Fig. 2 contains an Easl speci.cation of \nCMP. In this speci.ca\u00adtion, every modi.cation of a collection creates a distinct version of that collection, \nidenti.ed by a unique Versionobject. Every iter\u00adator records which version of which collection it is \nassociated with. Every use of an iterator is checked for correctness by comparing the version of the \niterator with the version of the underlying collection. Note that an update to a collection through an \niterator updates both the collection s and the iterator s version, thus ensuring that that particular \niterator may continue to be used safely. class Version { /* represents distinct versions of a Set */ \n} class Set { Version ver; Set() { ver = new Version(); } boolean add(Object o) { ver = new Version(); \n}  Iterator iterator() { return new Iterator(this); } } class Iterator { Set set; Version defVer; \n Iterator (Set s){ defVer = s.ver; set = s; } void remove() { requires (defVer == set.ver); set.ver \n= new Version(); defVer = set.ver; }  Object next() { requires (defVer == set.ver); } } Figure 2: \nAn Easl speci.cation of CMP. The dynamic check for CMP implemented in JCF uses integer\u00adtyped versions, \nrather than heap-allocated version objects, but is otherwise similar to the Easl speci.cation. We will \nuse the Java code fragment in Fig. 3 as a running example of a CMP client. As explained by the comments \nin the .gure, CME may be thrown during the execution of lines 6or 9, but not during the execution of \nline 7. An analysis that misses the errors in lines 6 or 9is unsound, while a report of a possible error \nin line 7constitutes a false alarm. 2.2 Other FOS Conformance Problems The following conformance constraint \nproblems are similar to CMP in that they can be naturally modelled by FOS speci.ca\u00adtions constraining \nthe relationship among instances of dynamically\u00adallocated component objects. All of these problems are \nmembers of the class of mutation-restricted conformance constraint problems described in Section 6, and \nadmit precise analysis using our staged certi.cation techniques. Grabbed Resource Problem (GRP): Consider \na graph library that provides graph traversal utilities. An implementation of graph traversals where \nstate is stored in vertices (e.g., to record if the vertex has been already visited) does not allow for \nmultiple simultaneous traversals of a graph. Initiating a new traversal of a graph invalidates prior \ntraversals of the same graph, which may not later be resumed. This is an instance of a general resource-sharing \nprotocol where a resource may be preemptively acquired, which places the constraint that the prior holder \nmay no longer use the resource. Implementation Mismatch Problem (IMP): Interfaces of mod\u00adules consisting \nof multiple interacting types often utilize methods with multiple arguments, with an implicit requirement \nthat the ac\u00adtual arguments all belong to the same module implementation. This is the case with the well-known \nFactory design pattern [16]. Alien Object Problem (AOP):A compound object (e.g., a graph) may have a \nmethod (e.g., to add an edge) with a restriction that the actual parameters (e.g., of type vertex) belong \nto the graph. Passing a vertex of one graph as an argument to another graph s method could have unintended \nconsequences.  3. GENERIC CERTIFICATION Since the Easl speci.cation of CMP in Fig. 2 models the compo\u00adnent \nbehavior via manipulation of an abstract heap, it is natural to consider whether certi.cation of this \nor similar problems could be carried out using generic heap analysis. Indeed, this is the case. In general, \none approach to carrying out certi.cation would be as fol\u00adlows: (a) Create a composite program by combining \nthe client code /*0*/ Setv=newSet(); /* 1 */ Iterator i1 = v.iterator(); /* 2 */ Iterator i2 = v.iterator(); \n/* 3 */ Iterator i3 = i1; /* 4 */ i1.next(); // The following update via i1 invalidates the // iterator \nreferred to by i2. /* 5 */ i1.remove(); /* 6 */ if (...) { i2.next(); /* CME thrown */ } // i3 refers \nto the same, valid, iterator as i1 /* 7 */ if (...) { i3.next(); /* CME not thrown */ } // The following \ninvalidates all iterators over v /* 8 */ v.add(\"...\"); /* 9 */ if (...) { i1.next(); /* CME thrown */ \n} Figure 3: A Java program fragment illustrating CMP. and the component speci.cation, treating the speci.cation \nas the component implementation. This is particularly simple to do with Easl speci.cations, since they \ntake the form of abstract programs. (b) Apply a suitable analysis algorithm to the resulting composite \nprogram and verify that whenever any requires clause in the speci.cation is executed, the expression \nin the clause will evaluate to true. In the case of CMP, we could carry out Step (b) using any existing \nalgorithm for must-alias analysis, since the requires clauses of the CMP speci.cation all entail equality \ncomparisons of two pointer-valued expressions. (This approach can be generalized to arbitrary Easl speci.cations \nusing a generic analysis engine. See [29] for details.) Let us now consider how well certi.cation based \non generic alias analysis works for CMP. Consider, for example, an allocation-site based analysis [6] \nwhich does not distinguish between different ob\u00adjects allocated at the same program point. Set s = new \nHashSet(); while (...) { s.add(...); for (Iterator i = s.iterator(); i.hasNext(); ) { Object o = i.next(); \n} } An allocation-site based alias analysis will be unable to certify that this fragment is free of \nCMP errors, because the analysis will be unable to distinguish between the different versions of set \nsinside the loop. Similar problems occur when other generic heap analyses are applied to CMP; e.g., see \nSection 4.4. We note that SCMP (CMP restricted to client programs in which references to collections \nand iterators are stored only in static or local variables) can be seen as a must-alias problem with \n3-level pointers a problem for which precise analysis is in general PSPACE\u00adhard in the intraprocedural \nand EXPTIME-hard in the interproce\u00addural case [27]. This is one reason to suspect that even SCMP is likely \nto be resistant to most generic heap analysis algorithms, and that any generic heap analysis algorithm \nof suf.cient accuracy to be useful for SCMP would likely be quite inef.cient.  4. STAGED CERTIFICATION \nThe problem with using any generic analysis engine for certi.ca\u00adtion is that such an engine must use \nabstractions based on program properties unrelated to the component conformance constraints of interest. \nIn this section, we show how to remedy this problem by using a component s conformance constraint speci.cation \nto derive a specialized abstraction of the components state. This abstraction technique will yield more \nprecise and ef.cient certi.ers than the generic abstractions used in Section 3. We illustrate the staged \nabstraction process using CMP. We will restrict our attention in this section to CMP clients in which \nrefer\u00adences to collections and iterators are stored only in local or static variables (rather than in \nobject .elds). We will refer to this spe\u00adcial case of CMP as SCMP. We will also assume in this section \nthat the client contains no calls to other client methods (i.e., that the client analysis is intraprocedural). \nWe will show that the gener\u00adated abstraction yields a polynomial time certi.er that computes the precise \nmeet-over-all-paths solution for (intraprocedural) SCMP. This section is intended to convey the essential \nideas of our ap\u00adproach without excessive formalism. Section 5 .lls in most of the formal details, and \nextends the results to arbitrary client programs by describing how component references in the client \nheap are han\u00addled, and how constructs such as client method calls are treated. In addition, Section 8 \ndescribes a precise, polynomial-time interpro\u00adcedural certi.er for the special case of SCMP. Our component \nabstraction process will consist of: (a) compo\u00adnent state abstraction, which characterizes those aspects \nof the com\u00adponent state (more precisely, the state of all component object in\u00adstances) that are relevant \nto the certi.cation process, and (b) compo\u00adnent method abstraction, which identi.es how the component \nstate abstraction is updated as a result of a component method call. 4.1 Deriving Component State Abstraction \nWe will represent the relevant state of a component using instru\u00admentation predicates [34], which can \nbe viewed as re.ning the com\u00adponent s state with derived information speci.c to the certi.cation problem. \nGiven the SCMP restriction, the abstraction derivation process yields a nullary predicate abstraction, \ni.e., a collection of nullary predicates (or propositions, or boolean variables). In Sec\u00adtion 5, we will \ndescribe a more general abstraction derivation process that can yield predicates of arbitrary arity (a \n.rst-order predicate ab\u00adstraction). For the sake of simplicity, we will assume that the com\u00adponent speci.cation \ncontains requires clauses only at method entry. Component speci.cations that contain requires clauses \nat points other than at method entry may be handled by suitably generalizing the approach below. We identify \ninstrumentation predicates by iteratively performing a symbolic, backward weakest-precondition [14] computation \nover every possible sequence of component method calls, using the fol\u00adlowing rules: 1. If any component \nmethod has a requires . clause at method entry, then \u00ac. is a candidate instrumentation for\u00admula. 2. \nIf .1 ......k is a candidate instrumentation formula (where none of the .i is a disjunct of the form \na. \u00df), then each .i is a candidate instrumentation predicate. 3. If . is a candidate instrumentation \npredicate, and S is the body of a component method, then the weakest precondition of .with respect to \nS, WP(S,.),is a candidate instrumen\u00adtation formula.(WP(S,.) is a formula that holds before the execution \nof Siff .holds after the execution of S.)  The motivation for rules 1 and 3 should be clear. The motivation \nfor rule 2 is slightly more complex. The speci.c form of rule 2 is intended to enable the use of an ef.cient \nindependent attribute [28, p. 247] analysis without losing the precision of relational analysis [28, \np. 248]. If .1 ..2 is a candidate instrumentation formula, tracking the values of .1 and .2 separately \ndoes not lead to a loss of precision. Predicate Meaning (in Easl) stalei i.defVer != i.set.ver iterof \ni,v i.set == v mutxi,j (i.set == j.set) &#38;&#38; (i!= j) samev,w v==w Figure 4: The instrumentation \npredicates used for component state abstraction in CMP. In contrast, if .1 ..2 is a candidate instrumentation \nformula, then we create a single instrumentation predicate .1 ..2 since tracking the values of .1 and \n.2 separately may lead to imprecision when used with an independent attribute analysis. This is related \nto the notion of disjunctive completion [10, 17] and distributivity in static analysis. Component State \nAbstraction for CMP We now illustrate the process above by applying it to the speci.ca\u00adtion of CMP. Step \n1: We are interested in determining at every call-site to methods Iterator::next()and Iterator::remove()), \nsay, on an Iteratorvariable i, if the precondition of the methods may fail, that is, if i.defVer != i.set.vermay \nbe true. We therefore introduce a new predicate stalei to represent the formula i.defVer != i.set.ver. \nStep 2: Next, we consider how the execution of different Set and Iteratormethods affect the value of \npredicate stalei. Con\u00adsider the execution of a method call v.add(), where vis of type Set. stalei is \ntrue after the execution of v.add() iff the con\u00addition (stalei || (i.set == v)) is true before the execution \nof the statement. This suggests maintaining the value of the expres\u00adsion i.set == vin order to precisely \nupdate the value of stalei. Hence, we introduce a second instrumentation predicate iterof i,v, representing \nthe condition i.set == v. Step 3: Consider the effect of executing j.remove() (where j is an iterator \nvariable) on predicate stalei. It can be veri.ed that stalei is true after execution of j.remove() iff \nthe condi\u00adtion (stalei || ((i.set == j.set) &#38;&#38; (i != j))) is true before the execution of the \nstatement. We introduce the instrumen\u00adtation predicate mutxi,j, representing the condition (i.set == \nj.set) &#38;&#38; (i != j). Step 4: It can be veri.ed that iterof i,v is true after the execution of \ni = w.iterator()iff v==wbefore the execution of the statement. We introduce the instrumentation predicate \nsamev,w, representing the condition v==w. We have now reached a .xed point: applying the rules for iden\u00adtifying \ninstrumentation predicates will not produce any more pred\u00adicates. Fig. 4 presents the de.nitions of the \ninstrumentation predi\u00adcates identi.ed. Predicate Families Our earlier description of the rules for identifying \ninstrumentation predicates omitted certain details for the sake of clarity. An expres\u00adsion identi.ed \nas a candidate instrumentation predicate by these rules will, in general, contain free variables. As \nan example, the ex\u00adpression i.defVer != i.set.ver identi.ed as being a can\u00addidate instrumentation predicate \ncontains a free variable i. Such an expression really identi.es a family of instrumentation predi\u00adcates \nfor a given client program which contains one predicate for every variable in the client program whose \ntype is the same as that of the free variable (here, Iterator). Speci.cally, let I and V denote respectively \nthe set of Iterator variables and the set of Setvariables in an SCMP client. The set of predicates we \nuse for analysis of the client is {stalei |i .I }.{iterof i,v |i .I ,v .V }. {mutxi,j |i,j .I }.{samev,w \n|v,w .V }.  4.2 Deriving Component Method Abstraction Having described how to derive a component state \nabstraction, we must now identify the corresponding abstraction of the component s collection of methods. \nEach abstracted method will de.ne how a call to that method affects the values of instrumentation predicates \ncomprising the state abstraction. The iterative rules of Section 4.1 for deriving a component s state \nabstraction can also be seen to generate the method abstractions, as follows: Let .0 be a candidate instrumentation \npredicate, and let the weakest precondition of .with respect to component method M be .1 ......k. Each \ncandidate .i is represented in the abstraction by a corresponding (boolean-valued) Easl variable pi. \nWe de.ne the update formula for p0 for method Mto be p0 := p1 .....pk . The abstraction of method Mconsists \nof an update formula for every instrumentation predicate, as well as the precondition of the method (expressed \nas a requiresclause). The method abstractions obtained from the CMP speci.cation are shown in Fig. 5. \n(These abstractions have been optimized by elim\u00adinating update formulae of the form p0 := p0, which correspond \nto instrumentation predicates whose values are not affected by the method call.) The method abstractions \nhave been presented in a form that re.ects the intended use of these abstractions during certi\u00ad.cation \nof a given client. In particular, during certi.cation, calls to component methods in the client code \n(the left column of the table) will be replaced by the corresponding method abstraction (the right column \nof the table). The same table also presents abstractions of copy assignments of component references, \nwhich serve the same purpose as the method abstractions. The table in Fig. 5 is parametrized by I and \nV, which denote respectively the set of Iterator variables and the set of Set variables in a client program. \nThe method abstractions utilize a macro mechanism, indicated by the .quanti.er. In particular, a macro-based \nupdate of the form lhs(z) := rhs(z) . z . S represents a whole set of updates, one for each z.S. 4.3 \nSpecialized Certi.cation Let us now see how the component and method abstractions are used in certi.cation \nof a client program. The .rst step in the certi\u00ad.cation process is to transform the client program by \n(a) replacing variables in the program that are references to the component by boolean variables corresponding \nto the identi.ed instrumentation predicates, and (b) replacing calls to component methods by a cor\u00adresponding \ninstantiation of the identi.ed method abstraction. (The part of the transformed client program that relates \nto the component resembles a boolean program [2].) To determine whether the inlined component method \nprecondi\u00adtions will always be satis.ed, we use standard program analysis techniques. We note that the \ntransformed program has a very special form: each assignment statement is of the form p0 := p1 .....pk \nor p := 0 or p := 1. As a result, any .xed point computation for a set of distributive equations over \nvalues in the set of subsets of {0,1}(e.g., .nite distributive subset (FDS) analysis [30]) can be used \nto compute the possible values of each variable at every program point in the transformed program. Statement \nSpecialized Abstraction v = new Set() samev,v := 1 samev,z := 0 .z. V-{v}samez,v := 0 .z. V-{v}iterof \nk,v := 0 .k. I v.add() stalek := stalek . iterof k,v .k. I i = v.iterator() iterof i,z := samev,z .z. \nV mutxi,i := 0 mutxi,k := iterof k,v .k. I-{i}mutxk,i := iterof k,v .k. I-{i}stalei := 0 i.remove() requires \n\u00ac stalei stalej := stalej . mutxj,i .j. I i.next() requires \u00ac stalei v=w samev,z := samew,z .z. V-{v}samez,v \n:= samez,w .z. V-{v}iterof k,v := iterof k,w .k. I i=j iterof i,z := iterof j,z .z. V mutxi,k := mutxj,k \n.k. I-{i}mutxk,i := mutxk,j .k. I-{i}stalei := stalej Figure 5: The component method abstraction for \nCMP. Here, i, j, and kdenote variables of type Iterator, while v, w, and zdenote variables of type Set. \nSince every requiresclause in the transformed program takes the special form requires \u00acv , this information \nis suf.cient to perform the certi.cation. We now illustrate this process for SCMP. The code fragment \nin Fig. 6 illustrates how selected statements of the CMP example of Fig. 3 are transformed. Note that \nthe declarations of the Iterator and Setvariables are replaced by the declaration of corresponding sets \nof boolean variables representing the nullary predicate abstrac\u00adtion derived in Section 4.1. The transformation \nof Statement 5 of the example is particularly notable. Here, we see that the condition in the speci.cation \ns requiresclause, which checks the validity of iterator i1, is satis.ed. However, as a result of executing \nstate\u00adment, the value of variable stalei2 becomes 1, which will prevent the requiresclause corresponding \nto the use of i2in Statement 6 (translation omitted) from being satis.ed. The next step is to analyze \nthis transformed program to deter\u00admine the possible values of the boolean variables mentioned in the \nrequiresclauses in the transformed program. In the intraproce\u00addural case, the precise (meet-over-all-paths) \nsolution to this problem can be computed in time O(EB2) time using FDS analysis [30], where B denotes \nthe number of iterator and collection variables in the original program and E denotes the number of edges \nin the control-.ow graph of the program. We address the interprocedural version of the problem in Section \n8 and show how the meet-over\u00adall-valid-paths solution can also be computed in polynomial time.  4.4 \nSpecialized vs. Generic Abstraction Fig. 7(a) and Fig. 7(b) depict the concrete state of the program \nof Fig. 3 before and after execution of Statement 5. Fig. 8 depicts the abstract states computed by the \nstaged certi.er that correspond to those concrete states. It is interesting to compare the abstract state \nused by our spe\u00adcialized certifer with that computed by a sophisticated heap analy\u00adsis based on storage \nshape graphs [37, 33]. These analyses merge // variables representing values of nullary predicate abstraction \n// used for certi.cation boolean stalei1,stalei2,stalei3; boolean iterof i1,v,iterof i2,v,iterof i3,v; \nboolean mutxi1,i1,mutxi1,i2,mutxi1,i3,mutxi2,i1,mutxi2,i2; boolean mutxi2,i3,mutxi3,i1,mutxi3,i2,mutxi3,i3; \nboolean samev,v; ... // 0: Set v = new Set(); samev,v := 1; iterof i1,v := 0; iterof i2,v := 0; iterof \ni3,v := 0; // 1: Iterator i1 = v.iterator(); iterof i1,v := samev,v; mutxi1,i1 := 0; mutxi1,i3 := iterof \ni3,v; mutxi3,i1 := iterof i3,v; mutxi1,i2 := iterof i2,v; mutxi2,i1 := iterof i2,v; stalei1 := 0; // \n2: Iterator i2 = v.iterator(); iterof i2,v := samev,v; mutxi2,i2 := 0; mutxi2,i1 := iterof i1,v; mutxi1,i2 \n:= iterof i1,v; mutxi2,i3 := iterof i3,v; mutxi3,i2 := iterof i3,v; stalei2 := 0; ... // 5: i1.remove(); \nrequires \u00acstalei1; // requiresstatement is satis.ed stalei1 := stalei1 . mutxi1,i1; stalei2 := stalei2 \n. mutxi2,i1; // stalei2 becomes 1 stalei3 := stalei3 . mutxi3,i1; ... Figure 6: A fragment of the transformed \nclient program of Fig. 3 nodes in a storage shape graph together if and only if they are pointed to by \nthe same set of variables. Let us see what happens at State\u00adment 5 of Fig. 3 when we apply the analysis \nbased on shape graphs. The two concrete nodes for the two version objects o4 and o5 are merged together \nbecause there are no pointer variables that point to either object. As a result of merging together o4 \nand o5,we have lost information: in the abstract state, we will have to conservatively assume that each \nof i1, i2, and i3may be either valid or invalid. Hence, the analysis will produce a false alarm at statement \n7. Note that the state representation in Fig. 8 is much more com\u00adpact, yet more precise, than the state \nrepresentation in Fig. 7(c). In particular, it enables the staged certi.er to determine that iterator \ni3 is valid after statement 5 and avoid producing a false alarm at statement 7. 4.5 The Derivation Process: \nDetails We have seen that the derivation procedure for identifying instru\u00admentation predicates converges \nquickly for CMP. In Section 6, we show that the process converges with a .nite set of instrumenta\u00adtion \npredicates for a class of Easl speci.cations called mutation\u00adrestricted speci.cations. The corresponding \nabstraction produced for the components is a .nite but precise abstraction: i.e., any im\u00adprecision in \na certi.er that uses the derived component abstraction is solely due to the imprecision in the abstraction \nused for the client s state. In the general case, however, there is no guarantee that the derivation \nprocedure will terminate. In other words, for some exam\u00adples, there may be no .nite bound on the number \nof instrumentation predicates generated by this procedure. However, in the general case, heuristics may \nbe used to stop the generation of new instru\u00admentation predicates at some point during the derivation \nprocess. This will, in turn, require introducing approximate but conserva\u00adtive method abstractions (since \nsome of precise update formulae required for a method abstraction may not be expressible in terms (a) \nConcrete and abstract state before execution (b) Concrete state after execution of statement (c) Abstract \nstate after execution of statement 5. of statement 5. 5. Figure 7: (a) and (b) are storage shape graphs \nrepresenting the concrete state before and after execution of line 5. (c) is a storage shape graph that \nabstracts the concrete state depicted by (b). A solid edge denotes a must point-to relation and a dotted \nedge denotes a may point-to relation. of the generated instrumentation predicates). Identifying suitable \nheuristics to ensure termination of the derivation procedure is be\u00adyond the scope of this paper. The \nabstraction derivation process entails checking whether a newly generated instrumentation predicate is \nequivalent to any of the instrumentation predicates already generated. While simple conser\u00advative equality \nchecks (such as converting the predicates to a normal form, e.g. disjunctive normal form, and comparing \nthem for syn\u00adtactic equality) are suf.cient to ensure termination of the derivation procedure in examples \nsuch as CMP, more powerful decision pro\u00adcedures can be used to make the derivation procedure more effective \nand to reduce the number of generated instrumentation predicates. While the use of alternative decision \nprocedures for equality has an impact on the set of generated instrumentation predicates, it does not \naffect the correctness of the approach.  4.6 Relation to Predicate Abstraction The approach described \nin this section is closely related to the no\u00adtion of predicate abstraction [18]. The term predicate abstraction \nhas been used in the literature to denote both the approximation of a program s state by a collection \nof boolean variables (nullary pred\u00adicates), as well as the approximation of a program s statements by \nstatements that refer only to these boolean variables. Recent work on counterexample-driven abstraction \nre.nement focuses on im\u00adproving predicate abstraction based veri.cation by discovering predicates that \nare relevant to the particular veri.cation problem instance [1, 35, 7]. While our goals are similar, \nour approach is or\u00adthogonal to previous approaches. Our predicate discovery algorithm is applied only \nto a component/library speci.cation, to determine a suitable abstraction of the component. This allows \nus to stage the whole process, as the component speci.cation can be analyzed before any client program \nis available, and the results (re)used for checking any possible client program. This can serve as the \nbasis for a more modular and scalable predicate discovery based veri.\u00adcation, and avoid or reduce the \nneed for expensive symbolic anal\u00adysis during analysis of the client program. In contrast, predicate discovery \nin prior work is done lazily, during the analysis of a com\u00adplete program/system, over a single execution \npath. This, however, has the advantage that it can produce better abstractions. The two approaches are \ncomplementary and can be employed together to improve ef.ciency, while retaining .exibility. A second \ndifference between our approach and prior work based on predicate abstraction is in how the abstracted \nprogram is sub\u00adsequently analyzed. While prior work relies on model checking techniques whose complexity \nis exponential (they correspond to relational analysis), our approach is not restricted to using an ex- \nState before the execution of statement 5. stalei1 =0 stalei2 =0 stalei3 =0 iterof i1,v =1 iterof i2,v \n=1 iterof i3,v =1 mutxi1,i2 =1 mutxi1,i3 =0 mutxi2,i3 =1 State after the execution of statement 5. stalei1 \n=0 stalei2 =1 stalei3 =0 iterof i1,v =1 iterof i2,v =1 iterof i3,v =1 mutxi1,i2 =1 mutxi1,i3 =0 mutxi2,i3 \n=1  Figure 8: An illustration of the abstract state maintained by our specialized certi.er for SCMP. \nNote that the state repre\u00adsentation has been simpli.ed using the facts that for all x,y samex,x =1, mutxx,x \n=0, and mutxx,y =mutxy,x. ponential relational analysis. In fact, our predicate discovery is intended \nto enable the use of more ef.cient independent attribute analysis without losing the precision of relational \nanalysis. This is what enables our technique to produce a polynomial time SCMP certi.er that computes \nthe precise meet-over-all-paths solution. A third difference between our approach and prior work is the \nsubject of the next section.  5. FIRST ORDER PREDICATE ABSTRAC-TION In Section 4, we saw how a component \nspeci.cation can be used to derive a specialized abstraction which can in turn serve as the basis for \nmore precise certi.cation. For SCMP, the relevant com\u00adponent state was described by a nullary predicate \nabstraction.In the general case, we will utilize .rst-order predicate abstraction, where both nullary \nand non-nullary predicates may be used to de\u00adscribe the relevant program state. The component abstraction \npro\u00adcess for SCMP was described in terms of operations on Java-style statements and predicates. However, \nto describe the .rst-order ab\u00adstraction derivation process for arbitrary client programs, we will require \na more expressive intermediate language. We will use the TVP [26] intermediate language for this purpose. \nIn the remainder of this section, we give an overview of the TVP language, show how client programs may \nbe translated into TVP, and generalize the component abstraction process of Section 4 to clients where \ncomponent references may be stored in the heap. As before, we describe the abstraction process by example \nusing CMP. Finally, we present a brief overview of the TVLA system [26], a con.gurable abstract interpreter \nfor TVP. We use TVLA as a cer\u00adti.cation engine for TVP programs formed by combining the TVP translation \nof a client program with the .rst-order abstractions gen\u00aderated for the component. 5.1 An Overview of \nTVP TVP is an imperative programming language built around an ex\u00adpression sub-language based on .rst-order \nlogic. The only type of variables allowed in TVP are predicate variables. Program states are represented \nin TVP by 2-valued logical structures.A 2-valued structure over a set of predicate variables P is a pair \n(U,.), where U is a set referred to as the universe, and .is a function that maps predicate variables \nto their values: for every predicate p . P of arity k, .(p):Uk .{0,1}. A TVP program is a control-.ow \ngraph, each edge annotated with an action, consisting of: (a) An optional precondition (a .rst-order \nlogic formula), which is used to model conditional branches. (b) Zero or more allocation bindings of \nthe form let id = new() in , which adds a new element to the universe. The newly\u00adadded element may be \nreferred to as idin the following assignment; the value of any predicate p(v1,... ,vk), where at least \none of the vi represents a newly-added element, is de.ned to be false. (c) Zero or more predicate updates \nof the form p(v1,... ,vm):= .(v1,... ,vm,n1,... ,nk), where each ni is a variable bound by an allocation \nbinding, which assigns a new value to predicate vari\u00adable p. We use the notation guard c lhs :=rhsas \nshorthand for lhs:=(guard.rhs).(\u00acguard.lhs) .   5.2 Standard Translation of Client Programs We now \npresent a standard way of modelling the state of an arbi\u00adtrary Java program using a 2-valued structure: \n Every heap-allocated object is modelled by an element of the universe.  Every (static) reference variable \nvaris represented by a unary predicate ptvar; the value of ptvar(o)is true iff varrefers to ( points \nto ) the object o.  Every .eld fldof a reference type is represented by a binary predicate rvfld; the \nvalue of rvfld(o1,o2)is true iff the .eld fldof object o1 refers to object o2.  TVP provides no explicit \nsupport for procedures. Procedures are modelled [31] by explicitly modelling a stack of activation records. \nIn particular, an activation record is modelled by an element of the universe, and local variables of \nprocedures are modelled just like .elds: the value of rvlv(o1,o2)is true iff the variable lvof activation \nrecord o1 refers to object o2.  Fig. 9 illustrates how typical Java heap manipulation statements will \nbe translated into TVP actions under the above model. (Note that the translation for x = new C()models \nonly allocation; ini\u00adtialization of the object by the constructor is modelled separately.) Generic certi.cation \n(see Section 3) is done by translating both the client program and the component speci.cation into a \ncomposite TVP program in this fashion, and by applying abstract interpreta\u00adtion to this composite program. \n(We will soon explain the speci.c abstract interpretations we use for TVP.) Code manipulating primi\u00adtive \n(non-reference) types is abstracted away (i.e., is not modelled) by the translation. The above approach, \neffectively, analyzes the composite program using the heap analysis algorithm described in [37, 33]. \nSimple vari\u00adations on the scheme described above for translating Java programs into TVP can be used to \nutilize several other well known heap anal\u00adysis techniques for certi.cation (see ([34]). Java Statement \nTVP Translation x = new C() let n= new() in ptx(o):=(o=n) x=y ptx(o):=pty(o) x = y.fld ptx(o):=.o1 :pty(o1).rvfld(o1,o) \nx.fld = y ptx(o1)c rvfld(o1,o2):=pty(o2) Figure 9: Translating the pointer manipulation statements of \nJava into TVP. 5.3 Specialized Component Abstraction As explained in Section 4, our approach is to derive \na special\u00adized abstraction from the component speci.cation, which serves as the basis for more precise \ncerti.cation. This specialized abstraction takes the form of a set of instrumentation predicates. An \ninstrumen\u00adtation predicate [34] is de.ned by a formulae over the predicates of the standard abstraction. \nThe derivation procedure described in Section 4 produces an ab\u00adstraction consisting of a set of instrumentation \npredicate families, parametrized over references to the relevant components. (E.g., stale is a predicate \nfamily parametrized over Iterator refer\u00adences.) The actual set of instrumentation predicates used for \ncerti\u00ad.cation of a given client is obtained by instantiating these families for the given client. We \nsaw in Section 4 how this instantiation is done for a simple case, namely client programs where component \nreferences are stored only in static variables (rather than in object .elds). We now show how the abstraction \nis instantiated and used in the general case. Consider an instrumentation predicate f(x1,\u00b7\u00b7\u00b7 ,xk)with \nfree variables x1 through xk of type C, derived from a speci.cation for component C. Let CFdenote the \nset of object .elds of type C in a given client program. The family of fpredicates used for analysis \nof this client consists of a k-ary predicate ff1,\u00b7\u00b7\u00b7 ,fk for every k-tuple (f1,\u00b7\u00b7\u00b7 ,fk)in CFk . The value \nof ff1,\u00b7\u00b7\u00b7 ,fk (o1,\u00b7\u00b7\u00b7 ,ok)is true iff the k component instances pointed to by .eld f1 of object o1, \nthrough .eld fk of object ok, satisfy the property f. (This scheme can also be used to deal with local \nvariables of type C by treating a local variable to be a .eld of an activation record object .) As an \nexample, consider the stale family of predicates used for CMP, which is de.ned by the formula i.defVer \n!= i.set.ver with one free variable i. For certi.cation of a CMP client, we will use a unary predicate \nstalef(o)for every iterator .eld fin the client program to track whether the iterator referenced by the \nf.eld of the object ois in an invalid state. (In contrast, the SCMP analysis uses a nullary predicate \nstalex for every iterator variable xto track whether the iterator referenced by variable x is invalid.) \nFig. 10 illustrates the set of instrumentation predicates used for CMP certi.cation, as well as the de.nition \nof these predicates in TVP. (The de.ning TVP formulae can be obtained from the corresponding Easl formulae \npresented in Fig. 4 using the standard translation from Java to TVP described earlier in this section.) \nNext, we consider component method abstraction. Each method abstraction takes the form of a collection \nof TVP actions. Fig. 11 presents the method abstractions for some of the Setand Iterator methods for \nCMP. These are obtained by generalizing the simpler method abstractions presented in Fig. 5 for SCMP. \nAbstractions for the remaining methods can be obtained similarly. 5.4 SpecializedTranslationofClientPrograms \nThe specialized component abstraction is used in the translation of a client program into TVP. In particular, \ncomponent method calls in the client program are translated using the corresponding method Predicate \nDe.ning TVP formula stalei(e) .o,s,v :rvi(e,o).rvset(o,s).rvdefVer(o,v)..rvver(s,v) iterof i,v(e1,e2) \n.o1,o2 :rvi(e1,o1).rvv(e2,o2).rvset(o1,o2) mutxi,j(e1,e2) .o1,o2,o:rvi(e1,o1).rvj(e2,o2).o1 .=o2 .rvset(o1,o).rvset(o2,o) \nsamev,w(e1,e2) .s:rvv(e1,s).rvw(e2,s) Figure 10: The modi.ed instrumentation predicates used for HCMP. \nNote that i, j, v, and wnow range over .elds of type Iterator or Setas appropriate. Method Call TVP Translation \nx.v = new Set() ptx(e1).pty(e2)c samev,v(e1,e2):=(e1 =e2) ptx(e1)c samev,z(e1,e2):=0 ptx(e2)c samez,v(e1,e2):=0 \nptx(e2)c iterof z,v(e1,e2):=0 .z .VF -{v}.z .VF -{v}.z .I x.v.add() (.e2 :ptx(e2).iterof i,v(e1,e2))c \nstalei(e1):=1 .i .IF x.i.remove() (.e2 :ptx(e2).mutxj,i(e1,e2))c stalej(e1):=1 .j .IF Figure 11: Update \nformulae for the instrumentation predicates of HCMP shown in Fig. 10.  abstractions. Statements in the \nclient program that do not invoke component methods or manipulate component references are, how\u00adever, \ntranslated using a suitable standard abstraction, such as the one in Fig. 9. As explained earlier, the \nchoice of the standard abstrac\u00adtion depends on the kind of heap analysis desired for analyzing the client \ns heap. Thus, the specialized component abstraction leads to a certi.ca\u00adtion algorithm that is parametric \nwith respect to the heap analysis used for the client s heap. We refer to the parametric certi.cation \nalgorithm obtained for CMP as HCMP.  5.5 Abstract Interpretations For TVP We now present a brief overview \nof how the generated TVP pro\u00adgram is analyzed using TVLA. TVLA is an abstract interpretation system for \nTVP based on 3-valued logic, which extends boolean logic by introducing a third value 1/2denoting values \nwhich may be 1or 0.A 3-valued structure over a set of predicate variables P is a pair (U,.)where U is \nthe universe, and .is a function mapping predicate variables to their values: for every predicate p . \nP of arity k, .(p):Uk .{0,1/2,1}. 3-valued structures (as well as 2-valued structures, which are just \nspecial cases of 3-valued structures) can be abstracted into smaller 3-valued structures by merging multiple \nindividuals into one, and by approximating the predicate values appropriately. TVLA users can control \nthis abstraction process by identifying a subset A of unary predicates to be the abstraction predicates. \nTVLA s abstraction mechanism merges all individuals having the same value for all abstraction predicates \ninto one individual. The maximum size of the universe in a structure produced by abstraction is 3|A|. \nTVLA implements a standard iterative algorithm to compute the set of all abstract structures that can \narise at every program point (a relational analysis). TVLA also implements a corresponding independent \nattribute analysis that computes a single structure at every program point, which approximates all structures \nthat may arise at that point. While this distinction was irrelevant for SCMP, it does in principle have \na bearing on the precision of the analysis for CMP, since it affects the accuracy of the generic analysis \nof the client heap. Somewhat surprisingly, our empirical results (see Section 7) showed that the relational \nversion of the TVLA certi.cation engine had no precision advantage over the independent attribute version \nfor the benchmark clients we studied. This seems to provide further evidence of the role that specialized \ncomponent abstractions play in yielding precise results. We refer the reader to [26] for more details. \n  6. MUTATION-RESTRICTED SPECIFICA-TIONS We now show that for the class of mutation-restricted speci.ca\u00adtions, \nour derivation procedure terminates, producing a .nite, pre\u00adcise abstraction for the component. This \nclass includes all the exam\u00adples presented in Section 2.2. Our result also implies that the results in \nSection 4 and Section 5 for CMP also apply to all problems in this class. Thus, for problems in this \nclass, precise meet-over-all-paths certi.cation can be done in polynomial time for client programs that \ndo not use heap-based component-references. The results estab\u00adlished in this section also imply that \nthe precise meet-over-all-paths solution for certain restricted classes of alias analysis problems is \ncomputable in polynomial time, a result that is interesting in its own right. Proofs have been omitted \ndue to space constraints. Note that our abstraction derivation approach can produce .nite precise abstractions \neven for speci.cations that are not mutation\u00adrestricted. A prominent example is CMP. Finding a better \ncharac\u00adterization of the class of speci.cations for which the approach is guaranteed to yield .nite precise \nabstractions is an open problem. We .rst introduce some terminology. A component speci.cation is said \nto be alias-based if all its preconditions are alias conditions (i.e., of the form requiresa=\u00df ). A component \n.eld fis said to be immutable if the .eld f of a component is assigned a value only when the component \nis constructed; otherwise, it is said to be a mutable .eld. A component speci.cation is mutation-free \nif all components in the speci.cation have only immutable .elds. (Note that these de.nitions are with \nrespect to the Easl speci.cation of the component, not any underlying implementation, which may freely \nuse mutable .elds.) Let TG denote a set of component types. Assume that TG is closed: i.e., if type T1 \nin TG has a .eld of type (pointer to) T2, then T2 is also assumed to be in TG. We de.ne the type graph \nof TG to be the graph consisting of a node for each type in TG, and an edge T1 . T2 labelled f for every \n.eld f in type T1 of type pointer to T2. Let ||TG||denote the number of different paths in the type graph \nof TG. Theorem 1. For any mutation-free, alias-based, straight-line component speci.cation over TG, the \ncomponent abstraction al\u00adgorithm will produce a disjunctive abstraction consisting of at most ||TG||2 \npredicate families. We note that the above theorem applies to problems IMP and AOP described in Section \n2.2. We now consider a class of compo\u00adnent speci.cations that utilize a restricted form of destructive \nheap update. Destructive heap update statements are statements of the form a.f := rhs . A speci.cation \nis said to have the restricted heap update property if the right-hand side of every destructive heap \nupdate statement in the speci.cation is a newly constructed object (or a tree of newly constructed objects, \nwhere each object has pointers only to other newly constructed objects). A speci.cation with restricted \nheap update is said to have mutation depth k if there are at most k mutable .elds in any path in the \ntype graph of the speci.cation. Theorem 2. For any alias-based, straight-line component spec\u00adi.cation \nover TG of mutation depth 1, the component abstraction algorithm will produce a disjunctive abstraction \nconsisting of at most ||TG||4 predicate families. We note that the above theorem applies to problem GRP \ndescribed in Section 2.2. The above results focus on the component abstraction problem. However, these \nresults also imply the following upper bounds for certain alias analysis problems, if the concept of \nmutation depth is generalized to whole programs in the obvious way. These re\u00adsults qualify the well known \nresults that alias queries of depth 2 are hard [23, 27]. Theorem 3. (a) Must-alias and may-alias queries \nof mutation depth 0 can be precisely answered in polynomial time (treating the type graph size as .xed). \n(b) Must-alias queries of mutation depth 1 can be precisely answered in polynomial time for programs \nwith restricted heap update (treating the type graph size as .xed). We now present some lower bounds. \nThese are adaptations of well-known intractability results of alias analysis [27] that focus on the restricted \nclasses of alias analysis problems that can be expressed in terms of mutation depth and restricted heap \nupdate and can be proved using a simple adaptation of the proofs in [27]. Theorem 4. (a) May-alias and \nmust-alias queries of mutation depth 1 are PSPACE-hard. (b) May-alias queries of mutation depth 1 is \nPSPACE-hard even for programs with restricted heap update. (c) Must-alias queries of mutation depth 2 \nis PSPACE-hard even for programs with restricted heap update.  7. EMPIRICAL RESULTS We have prototyped \nseveral variants of the HCMP algorithm using Soot [36] and TVLA [26]. We wished both to evaluate the \nprecision of the algorithm (i.e., the number of false alarms produced), and to understand the cost/precision \ntradeoffs in the analysis design space. The implementation is still at an early stage, and currently \ndoes not address multithreading or recursion (since our benchmark pro\u00adgrams did not require it). However, \nboth can be handled in TVLA using existing techniques [40, 31]. 7.1 Engineering Aspects Our Soot-based \ntranslator from Java to TVP uses liveness infor\u00admation to reduce the number of predicates required for \nthe analysis and to restrict their scope. We take advantage of Soot s implemen\u00adtation of Class Hierarchy \nAnalysis [12] to conservatively construct a method call graph. In addition, Soot treats exceptions by \ncon\u00adstructing a control .ow edge from each statement that may throw an exception to all potential corresponding \nhandlers.  7.2 Analysis Design Tradeoffs We experimented with eight variants of HCMP, obtained by con\u00adsidering \nall possible points in the following design space for client code analysis: (i) Using a relational versus \nindependent attribute approach for modelling TVLA structures at every program point. (ii) Context-sensitive \nversus context-insensitive treatment of client method calls.  (iii) Using allocation sites versus variables \nnames to distinguish client heap cells. The variable names approach [37, 33] merges two heap nodes if \nthe set of variables and .elds pointed to them are the same. The allocation site approach merges two \nnodes if they are allocated at the same allocation site in the client program [6, 21]. Our empirical \nobservations were as follows: (i) The independent attribute approach yielded an implementation that \nwas as precise as the relational one, and faster. We believe that the precision of the independent attribute \napproach is due to the disjunctive abstractions we use as instrumentation predicates. (ii) The context-sensitive \nalgorithms performed better than the corresponding context-insensitive ones with respect to both ef.\u00adciency \nand precision.  (iii) The variables names approach yielded more precise results than the allocation \nsite approach. In the interest of space, we give benchmark results only for the context-sensitive, variables-names \nbased, independent attribute variant of the algorithm. 7.3 Results Our experimental results indicate \nthat our analysis is quite fast and precise, producing only one false alarm over the test suite. (The \nfalse alarm was produced by a conservative modelling of calls to Java li\u00adbraries outside the scope of \nthe analysis.) Fig. 12 displays the results of the experiments. The test programs, which use JCF intensively, \nare available at [38]. The KernelSuite, designed to \"stress test\" the analysis, includes numerous examples \nillustrating various dif\u00ad.cult aspects of CMP. MapTest is from [22]. IteratorTest and MapDemoare examples \nfrom [39]. JFEis our own implemen\u00adtation s front-end. The experiments were performed on a machine with \na 1 Ghz Pentium 4 processor, 1 Gb of memory, running JDK 1.3 Standard Edition on Windows 2000. (Note \nthat the actual memory used by the algorithm ranged from 1 Mb to 50 Mb.) 7.4 Future Enhancements We \nare currently improving our implementation to allow analysis of signi.cantly larger programs. The improvements \nfrom which we expect to derive the most bene.ts are (i) slicing away portions of the program irrelevant \nto the component, and (ii) improving the representation of .rst-order structures.  8. INTERPROCEDURAL \nSCMP The class of certi.ers described in Section 4 yields precise meet\u00adover-all-paths solutions for single-method \nclients in polynomial time. The class of TVLA-based certi.ers described in Section 5 handles interprocedural \nCMP clients, (i.e., which contain calls among mul\u00adtiple client methods); however, the resulting solution \nwill not be precise in general. In this section, we show that the SCMP certi.er of Section 4 can be extended \nto compute the precise interprocedural Benchmark # Classes # Methods # Lines # CFG # Errors # False Analysis \nAnalysis # TVLA of Code Nodes Reported Alarms Time (s) Space (Mb) Structures KernelSuite 5 27 683 2150 \n15 0 60.09 18.66 4363 MapTest 2 9 335 424 1 0 61.20 19.87 4937 IteratorTest 3 10 126 154 0 0 0.23 4.18 \n208 MapDemo 1 3 33 32 0 0 0.01 1.13 26 JFE 1 45 2396 2896 1 1 236.34 49.10 9878 Figure 12: An empirical \nevaluation of HCMP. meet-over-all-valid-paths solution for multi-method SCMP clients in polynomial time. \nUnlike the techniques described in Sections 4 and 5, the methods in this section pertain only to SCMP; \nderiving precise interprocedural analyses for more general classes of com\u00adponent speci.cations is an \nopen problem. In the absence of recursive procedures with local variables, pre\u00advious techniques [30] \ncan be used to solve interprocedural SCMP. Recursive procedures with local variables, however, complicate \nis\u00adsues as illustrated by the following example: /* */voidP(SetS){ /* 1 */ Iterator i = S.iterator(); \n/*2*/ if(...){ /* 3 */ P(S); /* 4 */ i.next(); // will throw CME /* */ }else{ /* 5 */ i.next(); // will \nnot throw CME /* 6 */ i.remove(); /* 7 */ i.next(); // will not throw CME /* */ }} Consider the execution \npath 1, 2, 3, 1, 2, 5, 6, 7, 4, where j denotes the execution of line j in a recursive invocation of \nP. The modi.ca\u00adtion of the collection in line 6 does not make the iterator created in line 1 invalid, \nbut it does make the iterator created in line 1 (i.e., in the earlier invocation of procedure P) invalid. \nConsequently, the execution of line 7 will not throw CME, but when the recursive invo\u00adcation terminates, \nthe execution of line 4 in the original invocation will throw CME. The example illustrates two points: \n(a) The analysis has to distin\u00adguish between instrumentation predicates corresponding to different recursive \ninstances of the same local variable to avoid imprecision, and (b) The analysis of a procedure cannot \nignore instrumentation predicates corresponding to local variable instances of procedures up the call \nchain, even if hidden by subsequent recursive invo\u00adcations, because the values of these instrumentation \npredicates can change during the execution of the procedure (even though the val\u00adues of the hidden local \nvariables themselves can not change). This complicates matters since the number of instances of local \nvariables of recursive procedures is unbounded. We now show how we can handle these issues. We assume, \nfor now, that no global variables are used. For any procedure Q, let Formals(Q) denote the set of formal \nparameters of procedure Q of type Set or Iterator. De.ne MayMod(Q) to be the subset of F ormals(Q) such \nthat: a collection variable S is in MayMod(Q) iff the execution of Q may modify the collection S and \nan iterator variable Iis in MayMod(Q) iff the execution of Qmay modify the collection underlying the \niterator Ivia iterator I, assuming that there are no aliases between any of the formal parameters. The \ninforma\u00adtion MayMod(Q) is very similar to the quantity DMOD de.ned by Banning [3] and can be computed \nvery ef.ciently [8]. The intraprocedural SCMP algorithm can now be extended to analyze a procedure P, \nutilizing only the summary information for any procedure that Pcalls. In particular, assume that MayMod(Q)is \n{FC1, \u00b7\u00b7\u00b7 , FCi, FI1, \u00b7\u00b7\u00b7 , FIj }, where every FCx is of type Setand every FIx is of type Iterator. In \neffect, any call to a procedure Q in procedure P may be replaced by the following code, where ACx and \nAIy denote the actual parameters corresponding to formal parameters FCx and FIy respectively: if (...) \nAC1.add(\"\"); ... ; if (...) ACi.add(\"\"); if (...) AI1.remove(); ... ; if (...) AIj.remove();  Standard \ntechniques can be used to analyze the whole program using the above method for analyzing a single procedure. \nWe refer the reader to [29] for more details. Interaction between local and global variables: In the \npresence of both local and global variables, the information MayMod(Q)is not suf.cient to handle calls \nto procedure Q. The problem is that a procedure call may modify the value of a global variable, say g. \nThis can have the effect of changing the value of an instrumentation predicate such as mutxg,l, where \nlis a local variable of the calling procedure. Modelling a procedure call to account for such effects \nrequires summary information similar to that required for precise interprocedural slicing, which can \nbe computed ef.ciently [30]. We refer the reader to [29] for more details. 9. RELATED WORK In addition \nto the veri.cation techniques based on predicate ab\u00adstraction discussed in Section 4.5, several other \nresearch efforts have goals that are similar, to varying degrees, to ours. Abstraction without predicate \ndiscovery Bandera [9] differs from our work in that it does not use predicate discovery. Instead, it \nrelies on program slicing and user-provided abstractions to abstract programs into .nite state models. \nVeri.cation without abstraction ESC-Java [25] relies on theorem\u00adproving and program invariants to do \nveri.cation. Traditionally, users provided the invariants, but recent work has focused on auto\u00admatically \ndiscovering invariants [15] by generating candidate in\u00advariants heuristically, then eliminating those \nthat are not irrefutable. However, ESC-Java s overall approach to veri.cation is quite dif\u00adferent from \nour approach. Also, unlike ESC-Java, our approach is conservative. Interprocedural ShapeAnalysis Noam \nRinetzky [32] proposes im\u00adproving the ef.ciency of interprocedural shape analysis of programs manipulating \nabstract data types by de.ning a special, hand-crafted semantics for a linked-list abstract data type. \nType Checking Other approaches to improved static checking in\u00adcludes languages with advanced type systems \n(e.g., [13]). We are not aware of any type system that can check for the kind of properties we have looked \nat in this paper. Incomplete Concrete State-Space Exploration Jackson and Fekete [19] address the Concurrent \nModi.cation Problem by partially exploring the concrete state space of the program [20]. While this approach \nnever produces false alarms, it is inherently incomplete. We refer the reader to [29] for more discussion \non related work. Acknowledgments We thank Sean McDirmid for introducing us to the Concurrent Modi.cation \nProblem, the SOOT team and Roman Manevich for the assistance they provided with the implementation, and \nRobert O Callahan, Nurit Dor, Ran Shaham, Carlos Varela, Reinhard Wil\u00adhelm, and Eran Yahav for their \nhelpful feedback on the paper. 10. REFERENCES [1] T. Ball, R. Majumdar, T. Millstein, and S. Rajamani. \nAutomatic predicate abstraction of C programs. In Proc. ACM SIGPLAN Conf. on Programming Language Design \nand Implementation, pages 203 213, June 2001. [2] T. Ball and S. K. Rajamani. Automatically validating \ntemporal safety properties of interfaces. In SPIN 2001: SPIN Workshop, LNCS 2057, pages 103 122, 2001. \n[3] J. Banning. An ef.cient way to .nd the side effects of procedure calls and the aliases of variables. \nIn Proc. ACM Symp. on Principles of Programming Languages, pages 29 41, New York, NY, 1979. ACM Press. \n[4] Canvas project. http://www.research.ibm.com/menage/canvas/. [5] P. Chan, R. Lee, and D. Kramer. The \nJavaTM Class Libraries, Second Edition, Vol. 1, Supplement for the JavaTM 2 Platform Standard Edition, \nv1.2, pages 296 325. Addison-Wesley, 1999. [6] D. Chase, M. Wegman, and F. Zadeck. Analysis of pointers \nand structures. In Proc. ACM SIGPLAN Conf. on Programming Language Design and Implementation, pages 296 \n310, New York, NY, 1990. ACM Press. [7] E. M. Clarke, O. Grumberg, S. Jha, Y. Lu, and H. Veith. Counterexample-guided \nabstraction re.nement. In Proc. Computer Aided Veri.cation, pages 154 169, 2000. [8] K. D. Cooper and \nK. Kennedy. Interprocedural side-effect analysis in linear time. In Proc. ACM SIGPLAN Conf. on Programming \nLanguage Design and Implementation, pages 57 66, New York, NY, 1988. ACM Press. [9] J. Corbett, M. Dwyer, \nJ. Hatcliff, C. Pasareanu, Robby, S. Laubach, and H. Zheng. Bandera : Extracting .nite-state models from \nJava source code. In Proc. 22nd Intl. Conf. on Software Engineering, pages 439 448, June 2000. [10] P. \nCousot and R. Cousot. Systematic design of program analysis frameworks. In Proc. ACM Symp. on Principles \nof Programming Languages, pages 269 282, New York, NY, 1979. ACM Press. [11] P. Cousot. Semantic foundations \nof program analysis. In S. Muchnick and N. Jones, editors, Program Flow Analysis: Theory and Applications, \nchapter 10, pages 303 342. Prentice-Hall, Englewood Cliffs, NJ, 1981. [12] J. Dean, D. Grove, and C. \nChambers. Optimization of object-oriented programs using static class hierarchy analysis. Technical Report \nTR 94-12-01, Washington University, 1994. Also published in ECOOP 95 conference proceedings. [13] R. \nDeLine and M. F\u00e4hndrich. Enforcing high-level protocols in low-level software. In Proc. ACM SIGPLAN Conf. \non Programming Language Design and Implementation, pages 59 69, June 2001. [14] E. W. Dijkstra. A Discipline \nof programing. Prentice-Hall, 1976. [15] C. Flanagan and K. R. M. Leino. Houdini, an annotation assistant \nfor ESC/Java. Technical Report 2000-003, Compaq Systems Research Center, 2000. [16] E. Gamma, R. Helm, \nR. Johnson, and J. Vlissides. Design Patterns. Addison-Wesley, Reading, MA, 1995. [17] R. Giacobazzi, \nF. Ranzato, and F. Scozzari. Making abstract interpretations complete. J. ACM, 47(2):361 416, Mar. 2000. \n[18] S. Graf and H. Saidi. Construction of abstract state graphs with PVS. In In Proceedings of the 9th \nConference on Computer-Aided Veri.cation (CAV 97), pages 72 83, Haifa, Israel, June 1997. [19] D. Jackson \nand A. Fekete. Lightweight analysis of object interactions. In Proc. Intl. Symp. on Theoretical Aspects \nof Computer Software, Sendai, Japan, October 2001. [20] D. Jackson and M. Vaziri. Finding bugs with a \nconstraint solver. In Proc. Intl. Symp. on Software Testing and Analysis, Portland, OR, August 2000. \n[21] N. Jones and S. Muchnick. A .exible approach to interprocedural data .ow analysis and programs with \nrecursive data structures. In Proc. ACM Symp. on Principles of Programming Languages, pages 66 74, New \nYork, NY, 1982. ACM Press. [22] Kaffe. http://rpm.nd.net/tools/Kaffe, 2001. [23] W. Landi and B. G. Ryder. \nPointer-induced aliasing: A problem classi.cation. In Proc. ACM Symp. on Principles of Programming Languages, \npages 93 103, New York, NY, 1991. ACM Press. [24] G. T. Leavens. The Java Modeling language (JML). http://www.cs.iastate.edu/~ \nleavens/JML.html. [25] K. R. M. Leino, G. Nelson, and J. B. Saxe. ESC/Java user s manual. Technical Note \n2000-002, Compaq Systems Research Center, October 2000. [26] T. Lev-Ami and M. Sagiv. TVLA: A framework \nfor Kleene based static analysis. In J. Palsberg, editor, Proc. Static Analysis Symp., volume 1824 of \nLecture Notes in Computer Science, pages 280 301. Springer-Verlag, 2000. [27] R. Muth and S. Debray. \nOn the complexity of .ow-sensitive data.ow analyses. In Proc. ACM Symp. on Principles of Programming \nLanguages, pages 67 80, New York, NY, 2000. ACM Press. [28] F. Nielson, H. R. Nielson, and C. Hankin. \nPrinciples of Program Analysis. Springer-Verlag, 2001. [29] G. Ramalingam, A. Warshavsky, J. Field, and \nM. Sagiv. Deriving specialized heap analyses for verifying component-client conformance. Technical Report \nRC22145, IBM T.J. Watson Research Center, 2001. [30] T. Reps, S. Horwitz, and M. Sagiv. Precise interprocedural \ndata.ow analysis via graph reachability. In Proc. ACM Symp. on Principles of Programming Languages, pages \n49 61, 1995. [31] N. Rinetskey and M. Sagiv. Interprocedural shape analysis for recursive programs. In \nR. Wilhelm, editor, Proc. Intl. Conf. on Compiler Construction, volume 2027 of LNCS, pages 133 149. Springer-Verlag, \n2001. [32] N. Rinetzky. Interprocedural shape analysis. Master s thesis, Technion-Israel Institute of \nTechnology, Haifa, Israel, Dec. 2000. [33] M. Sagiv, T. Reps, and R. Wilhelm. Solving shape-analysis \nproblems in languages with destructive updating. ACM Trans. Prog. Lang. Syst., 20(1):1 50, Jan. 1998. \n[34] M. Sagiv, T. Reps, and R. Wilhelm. Parametric shape analysis via 3-valued logic. In Proc. ACM Symp. \non Principles of Programming Languages, pages 105 118, 1999. [35] H. Sa\u00efdi. Model checking guided abstraction \nand analysis. In J. Palsberg, editor, Proc. Static Analysis Symp., volume 1824 of Lecture Notes in Computer \nScience, pages 377 389. Springer-Verlag, 2000. [36] R. Vall\u00e9e-Rai, E. Gagnon, L.Hendren, P. Lam, P.Pominville, \nand V. Sundaresan. Optimizing Java bytecode using the Soot framework: Is it feasible? In Proc. Intl. \nConf. on Compiler Construction, pages 18 34, Mar. 2000. [37] E. Y.-B. Wang. Analysis of Recursive Types \nin an Imperative Language. PhD thesis, Univ. of Calif., Berkeley, CA, 1994. [38] A. Warshavsky. http://www.math.tau.ac.il/~walex, \n2001. [39] M. A. Weiss. Data Structures and Problem Solving Using Java. Addison-Wesley, second edition, \n2001. [40] E. Yahav. Verifying safety properties of concurrent Java programs using 3-valued logic. In \nProc. ACM Symp. on Principles of Programming Languages, pages 27 40, 2001.   \n\t\t\t", "proc_id": "512529", "abstract": "We are concerned with the problem of statically <i>certifying</i> (verifying) whether the client of a software component conforms to the component's constraints for correct usage. We show how conformance certification can be efficiently carried out in a <i>staged</i> fashion for certain classes of <i>first-order safety</i> (FOS) specifications, which can express relationship requirements among potentially unbounded collections of runtime objects. In the first stage of the certification process, we systematically derive an abstraction that is used to model the component state during analysis of arbitrary clients. In general, the derived abstraction will utilize first-order <i>predicates</i>, rather than the propositions often used by model checkers. In the second stage, the generated abstraction is incorporated into a static analysis engine to produce a <i>certifier</i>. In the final stage, the resulting certifier is applied to a client to conservatively determine whether the client violates the component's constraints. Unlike verification approaches that analyze a specification and client code together, our technique can take advantage of computationally-intensive symbolic techniques during the abstraction generation phase, without affecting the performance of client analysis. Using as a running example the <i>Concurrent Modification Problem</i> (CMP), which arises when certain classes defined by the Java Collections Framework are misused, we describe several different classes of certifiers with varying time/space/precision tradeoffs. Of particular note are precise, polynomial-time, flow- and context-sensitive certifiers for certain classes of FOS specifications and client programs. Finally, we evaluate a prototype implementation of a certifier for CMP on a variety of test programs. The results of the evaluation show that our approach, though conservative, yields very few \"false alarms,\" with acceptable performance.", "authors": [{"name": "G. Ramalingam", "author_profile_id": "81100519054", "affiliation": "IBM T.J. Watson Research Center, Yorktown Heights, NY", "person_id": "PP31045870", "email_address": "", "orcid_id": ""}, {"name": "Alex Warshavsky", "author_profile_id": "81100383936", "affiliation": "IBM Haifa Research Laboratory and Tel-Aviv University, Tel-Aviv, 69978 Israel", "person_id": "P348254", "email_address": "", "orcid_id": ""}, {"name": "John Field", "author_profile_id": "81100419562", "affiliation": "IBM T.J. Watson Research Center, Yorktown Heights, NY", "person_id": "PP43119729", "email_address": "", "orcid_id": ""}, {"name": "Deepak Goyal", "author_profile_id": "81100173656", "affiliation": "IBM T.J. Watson Research Center, Yorktown Heights, NY", "person_id": "P65230", "email_address": "", "orcid_id": ""}, {"name": "Mooly Sagiv", "author_profile_id": "81100150928", "affiliation": "Tel-Aviv University", "person_id": "PP39029858", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/512529.512540", "year": "2002", "article_id": "512540", "conference": "PLDI", "title": "Deriving specialized program analyses for certifying component-client conformance", "url": "http://dl.acm.org/citation.cfm?id=512540"}