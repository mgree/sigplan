{"article_publication_date": "05-17-2002", "fulltext": "\n Adoption and Focus: Practical Linear Types for Imperative Programming Manuel F\u00a8Robert DeLine ahndrich \nMicrosoft Research One Microsoft Way Redmond, WA 98052-6399 {maf,rdeline}@microsoft.com ABSTRACT A type \nsystem with linearity is useful for checking soft\u00adware protocols and resource management at compile time. \nLinearity provides powerful reasoning about state changes, but at the price of restrictions on aliasing. \nThe hard division between linear and nonlinear types forces the programmer to make a trade-o. between \nchecking a protocol on an object and aliasing the object. Most onerous is the restriction that any type \nwith a linear component must itself be linear. Because of this, check\u00ading a protocol on an object imposes \naliasing restrictions on any data structure that directly or indirectly points to the object. We propose \na new type system that re\u00adduces these restrictions with the adoption and focus con\u00adstructs. Adoption \nsafely allows a programmer to alias objects on which she is checking protocols, and focus allows the \nreverse. A programmer can alias data struc\u00adtures that point to linear objects and use focus for safe \naccess to those objects. We discuss how we implemented these ideas in the Vault programming language. \nCategories and Subject Descriptors D.3.3 [Programming Languages]: Language Con\u00adstructs and Features; \nF.3.3 [Logics and Meaning of Programs]: Studies of Program Constructs Type struc\u00adture; F.3.1 [Logics \nand Meaning of Programs]: Spec\u00adifying and Verifying and Reasoning about Programs Pre-and post-conditions, \nSpeci.cation techniques; D.3.4 [Programming Languages]: Processors Memory man\u00adagement General Terms \nDesign, Languages, Reliability, Veri.cation Permission to make digital or hard copies of all or part \nof this work for personal or classroom use is granted without fee provided that copies are not made or \ndistributed for pro.t or commercial advantage and that copies bear this notice and the full citation \non the .rst page. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires \nprior speci.c permission and/or a fee. PLDI 02, June 17-19, 2002, Berlin, Germany. Copyright 2002 ACM \n1-58113-463-0/02/0006 ..$5.00.  Keywords Linear types, heap aliasing, region-based memory man\u00adagement \n1. INTRODUCTION Successful use of a software component often requires more than just familiarity with \nthe types of the func\u00adtions and data in the component s interface. Rules gov\u00aderning proper interaction \nwith that interface must be gleaned from the component s documentation or, as is often the case, learned \nfrom local folklore. These rules, which we call the interface protocol, govern the order in which the \ninterface s functions may be called and its data accessed [14]. As a familiar example, a .le system s \ninterface protocol typically has the following rules: a .le must be opened before it is read or written; \na .le may be read or written until it is closed; and every .le that is opened must eventually be closed. \nIn the context of the Vault programming language, we studied a type system that tracks the lifetime and \nsymbolic state of objects. To enforceour .lesystemprotocol in Vault,wegivethe .le type the states open \nand closed and specify that the read and write functions expect an open .le and that the close function \nchanges a .le from state open to closed. Checking the states associated with objects requires the ability \nto tell di.erent objects apart. For instance, the code sequence close(a);read(b) obeys our inter\u00adface \nprotocol if a and b refer to di.erent .les, but is incorrect if these variables alias the same .le. To \nsolve this problem, Vault s type system splits the program s values into two groups: those on which we \ncan check protocols, but to which aliasing restrictions apply (val\u00adues of linear type); and those on \nwhich we cannot check protocols, but which are free of aliasing restrictions (val\u00adues of nonlinear type). \nAlthough this distinction is nec\u00adessary for tractability, the trade-o. between protocol checking and \naliasing is an annoyance to programmers. The division between linear and nonlinear types pre\u00adsents one \nfurther annoyance. A linear type system typ\u00adically restricts how a programmer must design her data structures \nby forbidding a nonlinear type from having linear components. For instance, if a and b were nonlin\u00adear \nrecords whose f .elds refer to linear .les, then the code sequence close(a.f);read(b.f) could be unsafe, \nsince a and b could be aliases due to their nonlinear types. To prevent such safety violations, a linear \ntype system restricts aliasing not only to those objects on which we check protocols, but also to any \nobject which directly or indirectly refers to them. Because of these restrictions, checking protocols \non more than a few types of objects in a large program is impractical. The aliasing restrictions quickly \nspread to all of the program s data structures, including those, like graphs and caches, which inherently \ninvolve aliasing. To make protocol checking more practical, this paper presents a new type system that \nremoves these restric\u00adtions. Our contributions are: 1) We allow linear com\u00adponents in nonlinear containers, \nbut control access to ensure safety. 2) We introduce the adoption construct, which safely allows aliasing \nof objects on which we check protocols and those that refer to them. 3) We introduce the focus operator, \nwhich provides a temporary scope in which we can check a protocol on an aliased object. Together, these \nfeatures allow us to check Vault code like the following1 : struct fileptr { tracked(@open) file f; }; \nvoid reset_logs($G:fileptr msgs, $G:fileptr errs) { tracked fileptr log = msgs; close(log.f); log.f = \nopen(MSG_LOG_FILENAME); log = errs; close(log.f); log.f = open(ERR_LOG_FILENAME); } Previous linear type \nsystems would reject both the dec\u00adlaration of the nonlinear type fileptr due to its linear (tracked).eld \nf and the code in reset logs due to the potential aliasing between msgs and errs.Our type system s acceptance \nof this code demonstrates the focus operation. We automatically infer one focus operation around the \n.rst three statements and a second focus op\u00aderation around the last three statements. The .rst focus \ntemporarily gives log, an alias for msgs, a linear type so that its .eld f may be updated. For safety, \nin the scope of this focus, access to any potential alias of msgs (namely errs) is illegal. The potential \naliases are known due to the presence of guards on nonlinear types. The same guard $G means errs and \nmsgs could be aliases. Through the use of guards, focus prevents access to po\u00adtential aliases. The second \nfocus works similarly. The adoption operation (not shown) allows a fileptr object to be allocated at \na linear type (to initialize its .eld), then given a nonlinear type to allow it to be aliased. 2. OVERVIEW \nWe present the details of our techniques in Sections 3 and 4 through a small expression language and \na type system. Section 6 discusses extensions and Section 7 de\u00ad 1In Vault, structs are reference types, \ni.e., pointers. scribes how the presented ideas are realized and applied in Vault. Section 8 discusses \nrelated work. This section introduces the four concepts we use to relax the boundary between linear and \nnonlinear types, provides an overview of our techniques, and an example used throughout the paper. A \nuni.ed view of object allocation and deallocation. In contrast to previous work in which heap objects \nare either linear or nonlinear, all objects in our model are allocated at linear type and deallocated \nat linear type. This model is intuitive, since at object creation, there cannot be aliases for the object. \nSimilarly, when an object is freed, all aliases to the object must be dead, if we are to avoid accesses \nthrough dangling references. Adoption. Since all objects start out with linear type and since it is impractical \nto program without aliasing, we need a way to obtain aliases (of nonlinear type) to existing objects. \nWe propose the adoption construct, adopt e1 by e2, which takes an adoptee o1 (the result of e1) and an \nadopter o2 (the result of e2), both of lin\u00adear type. The construct consumes the linear reference to o1 \nby creating an internal reference from o2 to o1. Therefore, each adoptee has exactly one adopter. The \nresult of the adoption expression is a reference at non\u00adlinear type to the adoptee. This adoptee s nonlinear \ntype is its previous linear type with only the top-level type constructor changed from linear to nonlinear. \nThe nonlinear reference to the adoptee is valid for the lifetime of the adopter, since we disallow access \nto o1 through the internal reference of the adopter. Any lin\u00adear components of object o1 cannot be directly \naccessed through the nonlinear reference. To do so would lead to uncontrolled shared access to objects \nof linear type. The linear components of o1 may however be accessed in the scope of a focus operation \n(discussed below). When the adopter is freed, all nonlinear references to the adopted object become inaccessible, \nusing the mech\u00adanism described next. The adopter returns its internal linear reference to the adoptee, \nthereby reinstating the adoptee s linear type. Through multiple adoption ex\u00adpressions, an adopter object \ncan adopt any number of other objects. Access control for nonlinear references. Because our adoption \nconstruct allows temporary aliases to a linear object, our type system must ensure that these aliases \nbecome invalid when the object recovers its linear type when it is unadopted. Otherwise, aliases could \nunsafely witness changes to the object made through the linear type. In our adoption approach, an adoptee \nrecovers its linear type when its adopter is freed. Hence, our approach to invalidating aliases is to \ntie the lifetime of the aliases to the lifetime of the adopter. Our solution builds on techniques developed \nby Crary et al. to deal with explicit region deallocation in the Capability Calculus [2], as well as \nthe work on alias types by Walker et al. [18]. In this paper, we use a superscripted dot to denote linear \ntypes and the absence of a dot to denote nonlinear types. Since our desired lifetime correlation is on \na per-object basis, we .rst give static names to objects of linear type t so that we can tell them apart. \nIn our type system, an object of linear type is given the singleton type tr(.) for some static name .. \nWe call the static names keys and the singleton types tracked types. At each point in the program, our \ntype system maintains the keys of those tracked objects that are allocated before the given program point \nand deallocated after that point. We call this set of keys the capabilities.Each entry {. . t} in the \ncapabilities means that the object tracked by key .has type t and is alive at the given program point. \nIn short, a tracked object s allocation lifetime is the set of program points for which its key is in \nthe capabilities. To correlate a nonlinear reference to an allocation life\u00adtime we use a guarded type \nof the form .rt.An object of guarded type may be used in an expression requiring a value of type t at \nany program point where key .is in the capabilities. Guarded types are nonlinear and can be shared freely. \nWhen an object of type tr(.) adopts an object with linear type t , the result of the adoption has guarded \ntype .rt. When the adopter is freed, the key . is removed from the capabilities, and thereafter all references \nof type .rt are invalid. Focus. The .nal and most important novel concept is a construct we call focus, \nwhich temporarily provides a linear view on an object of nonlinear type. The insight is that we can violate \nany type invariant of a nonlinear object (including its very existence), as long as no alias for the \nobject can witness the violation. The focus construct, let x= focus e1 in e2,requires e1 to evaluate \nto an object of a guarded type .1 rt. This object is called the focused object. We change the context \nin which e2 is type-checked in two ways. First, we bind x to the focused object, but we give x atracked \ntype tr(.) for some fresh key . and add {.. t} to the capabilities. Because of x s tracked type, expression \ne2 can change the underlying type associated with ., can remove .from the capabilities, and can access \nand replace linear components of t. Second, to ensure that no aliases can witness these changes, within \nthe context of e2, we remove the original guarding key .1 from the capabilities. By temporarily revoking \nthis key, we are guaranteed that no aliases of the focused object are accessible during e2. Finally, \nat the end of e2, the capabilities must contain {. i.e., . is live and the .nal type t matches . t}, \nthe initial type of the focus. This guarantees that no alias can witness e.ects on the focused object \noutside the scope of the focus. We end the focus by revoking the temporary key .and granting .1, thereby \nallowing renewed access to all objects guarded by .1. 2.1 Motivating Example To illustrate the bene.ts \nof our type system, we intro\u00adduce a simple example here and discuss it throughout the paper. As we showed \nin previous work [3], check\u00ading state-based protocols, like our .le example, requires the same typing \nmachinery as checking memory safety. Namely, we use the same type system to check that an object is not \nreferenced after deletion and all objects are eventually deleted. To keep our example simple, we use \nmemory safety as our protocol. fun dict_lookup(phone:int, ssn:int, d:dictionary) { ... let c = newCell(d) \nin ... } fun add_amount(cell:ref<int[]>, elem:int) { ... resize(cell, newsize) ... } fun add_entry(d:dictionary, \nphone:int, ssn:int, amount:int) { let cell = dict_lookup(phone, ssn, d) in add_amount(cell, amount) } \nFigure 1: Pseudo code for our motivating exam\u00adple. Our example s central data structure is a resizable \narray. Consider a program that builds a dictionary to hold sequences of monetary amounts, which can be \nin\u00addexed by a person s Social Security Number and phone number, as sketched in Figure 1. The program \nuses the function add entry to add a new amount to a person s entry in the dictionary. The program stores \neach per\u00adson s data in a resizable array, which grows when it is full. The dictionary contains two references \nto each ar\u00adray, one indexed by the Social Security Number and the other by the phone number. The natural \nrepresentation for a resizable array is a mutable cell containing the array (ref<int[]>). Since we want \nto be able to free the array during resize op\u00aderations, the array should have linear type, but the cell \nitself is shared and thus should have nonlinear type. In our pseudo code, we assume that the function \ndict lookup allocates a fresh, but sharable entry via a call to newCell, if the entry is not found. Similarly, \nthe function add amount calls resize when the array is full. We will show later in detail how the implementation \nof newCell and resize are type checked. The example is ill suited to previous type systems with linearity. \nIn a traditional linear type system, each cell would need to be given the nonlinear type ref(int[]) in \norder to be shared in the dictionary. To support the destructive resize operation, we want the array \nto have a linear type. However, since a linear type cannot be a component of a nonlinear type, we must \nalso give the cell a linear type: ref(int[] ) . Wecannotassign thecells the incompatible types ref(int[]) \nand ref(int[] ) . In his seminal paper on linear types [17], Wadler be\u00adgan to soften the boundary between \nlinear and nonlin\u00adear types. He used a let! construct to give a tempo\u00adrary nonlinear type to a linear \nobject. The construct let! (x) y= e1 in e2 recursively changes the variable x s linear type to nonlinear \nform for the scope of the expression e1, then returns it to its linear type for the scope of expression \ne2. Wadler used a syntactic restric\u00adtion on the type of e1 to prevent the escape of nonlinear references[17]. \nOdersky later proposed observer types to prevent this escape [9]. Could we give our cell the linear type \nref(int[] ) and then use Wadler s let! to obtain a reference of nonlinear type to the cell? Unfortunately, \nthere are two issues that make let! unsuitable in this case. First, while let! is sound in its original \nsetting of a functional language, it is unsound if applied to types of mutable storage. As a case in \npoint, applying let! to view a cell of linear type ref(int[] ) at nonlinear type ref(int[]), allows us \nto unsafely update the cell with a shared array, as shown in the following example: fun crash (a:int[], \nr:ref(int[] ) ){ let! (r) _= (r := a) in free(r); return sub(a,0); } Here, let! gives r the type ref(int[]) \nfor the scope of the assignment r := a. The assignment overwrites the unique array pointer stored in \nthe cell, thus creating a leak. Furthermore, the subsequent free of the cell also frees the array a, \nwhich causes the index operation sub(a,0) to access freed memory. The second problem with let! is its \nreliance on a lexical scope, which does not allow the implementation of newCell, where a fresh, but sharable \nobject is created and returned to the context under a nonlinear type. In short, let! does not allow us \nto represent our dictionary. The new type system presented in this paper removes the restriction that \nnonlinear types may not contain lin\u00adear types as components and provides adoption as an alternative to \nlet!. Adoption handles mutable types and does not rely on lexical scoping. For our example, we track \nthe dictionary under key .d and adopt the cells to the dictionary. This gives the cells the type .d rref(int[] \n) which allows the cells to be shared (because they are nonlinear) and the arrays to support deallocation \nduring resize (because they are linear). Whenever the contained linear array needs to be ac\u00adcessed, a \nfocus operation on the cell will temporarily revoke .d, but provide a fresh key . for the focused cell. \nIt is then possible to access the contained linear array and to replace it in the resize operation. During \nthe fo\u00adcus, no possible alias of the cell is accessible, since such access would require key .d.  3. \nTYPES AND EXPRESSIONS To illustrate how adopt and focus allow programs like our dictionary example to \ntype check, this section presents a small type and expression language. Section 4 presents the typing \nrules. 3.1 Types We use the type language in Figure 2 to formalize the ideas discussed in the previous \nsections. The type lan\u00adguage distinguishes several kinds of types. Heap types h represent mutable tuples \nand arrays that are stored in the heap. Objects of these types are adoptable and focusable. We represent \nthe type ref(int[]) from the introduction as a 1-tuple of the form (int[]). heap type h ::= (s1..sn)| \nt[] type t ::= int | tr(.) | Grh |.[.].(C1,s1) . (C2,s2) linear type s ::= .[.|{.. h}].tr(.) | t guard \nG ::= . capability C ::= \u00b7|{.. h}.C | E.C type context . ::= \u00b7| .,. | E,. Figure 2: Type language Ordinary \ntypes t include integers, tracked types tr(.), and guarded types Grh. Tracked types are singleton types \ntr(.), where the key . is a static name for the address of the object being tracked. Hence, two objects \nwith the same key . are stored at the same address in the heap and are hence aliases for the same memory \nblock. The contents of the memory at . is of heap type, which is given separately by a capability of \nthe form {. . h}. Note that guarded types always refer to a heap type. In this type system, we separate \nthe handle to a linear object, tr(.), from the capability to access that object, {.. h}. A traditional \nlinear type system couples these two in the linear type h . To express such a linear type s, the handle \nand its capability are combined in an ex\u00adistential package [18]: h = .[.|{.. h}].tr(.) When storing a \nlinear object in a data structure, the object s particular address is not important, so long as we have \nthe capability to access the object at that ad\u00address. This use of an existential type binds the address \nto its capability and makes the address anonymous. Whereas the universal quanti.cation for function types \ncaptures the intuition that functions operate uniformly over objects at di.erent addresses, the existential \nquan\u00adti.cation for linear types captures the intuition that a data structure is stored some particular \nway in the heap, although exactly how is irrelevant. To convert from a linear type h to an ordinary tracked \ntype tr(.), the capability is unpacked and added to the capabilities at the current program point. Similarly, \nto convert from a tracked type tr(.) to a linear type h ,we extract the capability {. . h} from the current \ncapa\u00adbilities. These conversions are captured by the relation C1; s1 f C2; s2 shown in the Appendix. \nThe spatial conjunction of capabilities is formed via C1.C2, expressing that keys in C1 are disjoint \nfrom keys in C2. Function types have the form .[.].(C1,s1) . (C2,s2), where s1 is the argument type, \nand s2 the result type. C1 is the before capability needed to call the function, and C2 is the after \ncapability provided at return. A function that operates only on a heap object stored at a particular \naddress . would not be very useful. To avoid this problem, we make functions reusable with paramet\u00adric \npolymorphism. The type context . allows a function to abstract over names for keys and capabilities. \ne ::= x |i |e.i |e.i := e |e(e) |e[c] | new(i)|free e |adopt e:h by e | let x = e in e | let x = focus \ne in e | fun f[.](x : s): s pre C post C {e} c ::= . |C |G Figure 3: Expressions 3.2 Expressions Figure \n3 presents a small call-by-value expression lan\u00adguage for manipulating integers i, updatable tuples, \nand functions. Expression e.i is used to obtain the ith com\u00adponent of a tuple, e1.i := e2 updates the \nith component of e1 to e2. Function application of e1 to e2 is written e1(e2). A tuple with i components \nis allocated by ex\u00adpression new(i)and freed by expression free e. Adop\u00adtion of e1 by e2 is written adopt \ne1:h by e2,where the type constraint h allows the programmer to specify the form of the adopted type \nin order to pack particular .elds to linear types. The expression let x = e1 in e2 provides name binding \nwith the usual lexical scoping rules. In our examples, we use the expression e1; e2 as sugar for let \n= e1 in e2. The focus expression let x = focus e1 in e2 focuses on e1 during e2.At the end of e2,the \nfocus islost. Expression fun f[.](x:s1):s2 pre Cb post Ca {e}de\u00ad.nes a recursive function f,where x is \nthe formal pa\u00adrameter of type s1,and e is the body of type s2. Cb and Ca are respectively the before \nand after capabilities, and . contains the universally quanti.ed variables. Expres\u00adsion e[c] is used \nto instantiate polymorphic functions to particular type arguments c (capabilities or keys). In our examples, \nwe will use multi-argument functions without formalizing this trivial extension. To reduce the size of \nour language, we do not provide primitive expressions for creating, reading and updating arrays, but \nrather rely on prede.ned functions. Our ex\u00adamples only use newarray(n) which allocates a tracked array \nof size n. 3.3 Semantics The operational semantics of the language is relatively straight-forward. Expressions \nof the form e[c]are oper\u00adationally equivalent to e, ie., the type instantiation has no runtime e.ect. \nSimilarly, a let-focus expression is operationally equivalent to an ordinary let-expression. The only \nnon-standard construct is adoption. A sim\u00adple implementation uses two special .elds per object: adoptees,and \nnext.The adoptees .eld of an object o is used to hold the list of objects adopted by o,which are chained \nvia their next .elds. Adoption of o1 by o2 operationally corresponds to o1.next = o2.adoptees; o2.adoptees \n= o1; The typing rules guarantee that the structures formed through the next and adoptees .elds are unshared \ntrees. To simplify the language and types, we assume that free recursively frees all linear components \nand all ob\u00adject reachable via next and adoptees .elds. In Sec\u00adtion 4.3 we discuss alternative semantics \nto recover adop\u00adtees when adopters are freed.  4. TYPING RULES We are now ready to show the details \nof how our typ\u00ading discipline treats adoption and focus. Typing judge\u00adments have the form .; G; C1 f \ne : t ; C2 and express that in type context . and type environment G (map\u00adping program variables to types \nt ) and given initial ca\u00adpabilities C1, expression e evaluates to a value of type t and .nal capabilities \nC2. The capabilities are threaded throughout the expression evaluation and track the state (heap type) \nand liveness of all tracked objects. Unlike in standard linear type systems, type environ\u00adments G map \nprogram variables to nonlinear types t only. Linearity is enforced via the capabilities, not via environment \nsplitting. Similarly, the type of an expres\u00adsion is always nonlinear. The full set of typing rules is \ngiven in the Appendix. Here, we highlight the most interesting rules by illus\u00adtrating them on our example \nfrom the introduction. 4.1 Adoption Ideally, we would use tracked types for all objects in our program. \nHowever, because tracked types allow no sharing, we use nonlinear guarded types where needed. Objects \nof guarded type are obtained via adoption.An adoption involves an adoptee o1 and an adopter oa. Both \nobjects have to be tracked at the moment of the adoption2.Let .1 be the key of the adoptee and .a the \nkey of the adopter. The type rule for adoption is .; G; C fe1 : tr(.1); C1 .; G; C1 fe2 : tr(.a); {.1 \n.h}.C2 . fC2 ={.a} [adopt] .; G; C fadopt e1:h by e2 : .a rh; C2 After typing e1, the adopted object \nand e2, the adopter, we must have capability {.1 . h}.C2,which makes sure that the to be adopted object \nis live and has type h. We also check that the adopter is accessible, i.e., .a is live by the judgement \n. f C2 ={.a}.The result of the adoption has type .a rh, where the guard .a re.ects the key of the adopter \nand h is the heap type of the adopted object. The .nal capability is C2, re.ecting that we have given \nup the key .1 of the adopted object. Operationally, adoption adds a pointer from the adopter oa to o1, \nthereby guaranteeing that we do not loose all references to o1. The invariant that o1 is accessible only \nvia the guarded type .a rh is enforced because, the key .1 for tracked access is consumed, and is not \nrecovered until we free the adopter o2. For the same reason, an object can be adopted by only one adopter \nat any given time. Thus the pointers from adopters to adoptees form a linear (unshared) tree. Adoption \nallows a collection of tracked objects o1..on to be adopted by a single object oa, and thus viewed 2We \nrelax this requirement for the adopter later. under a common type .a rh. References of that type can \nrefer to any of the adopted objects, thus allowing arbitrary aliasing. As an example of adoption, below \nis the code used by the dictionary to allocate a fresh, but sharable cell. fun newCell(dct : tr(.d)): \n.d r (int[] ) pre {.d . dictionary} post {.d . dictionary}{ let cell : tr(.) = new<1> in cell.1 := newarray(10); \nadopt cell:.d r (int[] ) by dct } The function takes the dictionary as an argument, allo\u00adcates a fresh \ncell, initializes its contents to a fresh array of size 10, and .nally has the cell adopted by the dic\u00adtionary. \nAfter the evaluation of new, we have capability {.d . dictionary}.{. .(int)},where . is the key of the \nfreshly allocated 1-tuple with initial contents 0 (thus type int). Next, the call to newarray returns \na new tracked array of type tr(.2)for some fresh .2,along with a new capability {.2 . int[]}.At this \npoint we use the tuple update rule [t-update] from the Appendix: .; G; C f e1 : tr(.); C1 .; G; C1 f \ne2 : t ; {. . h}.C2 h = (s1..si-1,ti,si+1..sn) h. = (s1..si-1,t,si+1..sn) [t-update] .; G; C f e1.i := \ne2 : t ; {. . h}.C2 We instantiate the update rule above with t = tr(.2) C2 = {.d . dictionary}.{.2 . \nint[]} h = (int) h. = (tr(.2)) After the update, the capabilities are {.d . dictionary}.{. .(tr(.2))}.{.2 \n. int[]}, i.e., we changed the contents of . to refer to the new array of type tr(.2). Note that this \nis a strong update at the type level, since the content of the cell changed type from int to tr(.2). \nAt the point of adoption, we require the adopted cell to have type h = (int[] ) as stated in the adopt \nexpres\u00adsion. The current type associated with tr(.) however is (tr(.2)). To form the desired linear type, \nwe package the capability {.2 . int[]} together with the reference tr(.2) by applying rule [cap-transform] \nfrom the Ap\u00adpendix with judgement {. .(tr(.2))}.{.2 . int[]}f{. .(int[] )} The current capability is \nnow {.d . dictionary}.{. . (int[] )}. The adopt rule then consumes key . and leaves us with the new cell \nwith guarded type .dr(int[] ), which matches the expected return type of newCell. 4.2 Focus Allowing \nnonlinear types with linear components would not be useful without the focus operation, since the linear \ncomponents cannot be accessed from the nonlin\u00adear container. Focusing on an object with guarded type \nGrh allows temporary access to the linear components of h. We illustrate focus through our running exam\u00adple, \nby implementing the resize function of resizable ar\u00adrays. The function takes parameter cell of guarded \ntype .d r (int[] ) containing the old array, and param\u00adeter size for the new array size. The function \nexpects a capability on entry that includes .d,the key for the dictionary guarding our cell. fun resize[.d](cell:.d \nr (int[] ), size:int): int pre {.d . dictionary} post {.d . dictionary} { let newa = newarray(size) in \nlet fcell = focus cell in let olda = fcell.1 in copy(olda,newa); fcell.1 := newa; free olda } First, \nwe allocate the new array and bind the result to newa. Assuming that newarray returns a tracked integer \narray, we assign newa the type tr(.1)for a fresh key .1. Our current capability is {.d . dictionary}.{.1 \n. int[]}. Next, we apply focus to cell andbindthe fo\u00adcused reference to fcell. The typing rule for focus \nis .; G; C f e1 : Grh; C1.C2 . f C1 = G . fresh .; G[x : tr(.)]; C2.{. . h}f e2 : t2; C3.{. . h} .; G; \nC f let x = focus e1 in e2 : t2; C1.C3 We instantiate the rule with G = .d h = (int[] ) C1 = {.d . dictionary} \nC2 = {.1 . int[]} We split the current capability into C1.C2,where C1 is su.cient to prove the guard \nG,and C2 is everything that is not needed to prove the guard. In our case, the dictionary key .d is needed, \nbut the key .1 for the new array is not needed. We proceed in the body of focus with capability {. .(int[] \n)}.{.1 . int[]} where . is the fresh key giving us linear access to the fo\u00adcused cell. Notice that we \nno longer have the dictionary key .d, because it was used for the focus. This prevents focusing again \non an alias to cell during the body of the focus. Next, we type the selection fcell.1. The appropriate \ntype rule for indexing from the Appendix is .; G; C f e : tr(.); {. . h}.C2 h = (s1..si-1,ti,si+1..sn) \n[t-index] .; G; C f e.i : ti; {. . h}.C2 The rule requires that the type ti of the ith compo\u00adnent that \nis selected is non-linear (not s)in order to satisfy our type judgement invariant that expressions evaluate \nto non-linear types. Thus in our example, the heap type associated with fcell (.) .rst needs to be transformed \nby unpacking the linear array type in our cell, via the following judgement (rule [cap-transform] in \nthe Appendix) {. .(int[] )} f {. .(tr(.2))}.{.2 . int[]} This unpacking step simply names the hidden \nkey within int[] ,picking a fresh key name .2, and changes the cell type to refer to tr(.2), while adding \nthe capability {.2 . int[]} to the current capability. Now we can instantiate the [t-index] rule with \nh = (tr(.2)), and thus bind olda to tr(.2). The capabilities at this point are {. .(tr(.2))}.{.2 . int[]}.{.1 \n. int[]}. Next, we copy the contents of the old array to the new one, assuming that copy takes two tracked \narrays and does not change the capabilities. Next, we update the cell via fcell.1:=newa,thereby applying \nrule [t-update] as shown in the previous sec\u00adtion. The capabilities after this step are {. .(tr(.1))}.{.1 \n. int[]}.{.2 . int[]}, re.ecting that fcell now contains a pointer to the new array .1. Next, we free \nolda, thereby consuming key .2,leaving us with capability {. .(tr(.1))}.{.1 . int[]}.At this point, the \nscope of our focus ends. To apply the remainder of the focus rule, we need to apply a packing step to \nour cell .: {. .(tr(.1))}.{.1 . int[]}f{. .(int[] )} We instantiate the remaining part of the focus rule \nwith C3 = \u00b7 (the empty capability). Our focus key . maps correctly to h = (int[] ), therefore, we can \nend the focus scope, since all aliases to the focused cell now again see the correct type h. Ending the \nfocus consumes the focus key . and reinstates the capabil\u00adity C1 = {.d . dictionary} that was temporarily \nrevoked, leaving us with {.d . dictionary},which matches the .nal capability of resize. 4.3 Recovering \nadoptees on free To simplify the type systems, we have assumed that freeing an adopter will recursively \nfree all adoptees. This is only one possible way to deal with adoptees. In this section, we brie.y contrast \nthree di.erent semantics for free. Recursive free. Possibly the simplest semantics of free recursively \nfrees all adoptees. This semantics raises a practical issue: to avoid leaks the operation must also free \ncomponents of linear types of any object en\u00adcountered. In order to traverse objects recursively, the \ngeneric deallocator needs to understand the layout of all objects in memory, much as a garbage collector \nwould. This requirement goes against the desire to apply the presented techniques in a low level system \nlanguage, where explicit data layout control is important. A slightly more restrictive scenario however \ndoes not rely on a generic memory traversal and is used widely. The region abstraction for memory allocation \nallows in\u00addividual objects to be allocated from a given region. Objects are freed not individually, but \ncollectively by freeing the entire region. This model can be viewed as a special case of adoption, where \nobjects are co\u00adallocated from a common block of memory and imme\u00addiately adopted by the region (thus no \nreference of lin\u00adear type is ever accessible to the new block). If data allocated in regions is restricted \nto nonlinear compo\u00adnents, there is no need to traverse blocks recursively to free components. Thus freeing \nremains a constant time operation as is expected from most region implementa\u00adtions [15]. Callback semantics. \nAnother possibility to avoid the generic object traversal at free is to register a call\u00adback function \nwith each adoptee at the time of adop\u00adtion. When the adopter is freed each callback is called with the \ncorresponding adoptee (now of linear type), thereby returning the adoptee to the context. Only the particular \ncallback function of an adoptee needs to un\u00adderstand the layout of the adoptee. This semantics has been \napplied in the region implementation by Gay and Aiken [4]. Linear list of adoptees. The third semantics \nwe .nd use\u00adful requires free to return all adoptees via a linear list. The context in which free is applied \ncan then choose to deal with the adoptee objects in whatever way is appro\u00adpriate. This semantics however \nhas the restriction over the previous two proposals that it requires all adoptees to have the same type. \nWe express this by having a special adopter type of the form adopter(h) re.ecting the type h of the adoptees. \nIn our experience all three semantics are useful in some programming scenarios. A realistic programming \nlanguage can provide all three through libraries.  5. ALGORITHMICS The main detail we glossed over in \nthe technical presen\u00adtation is the treatment of control .ow merge points. In our prototype compiler, \nwe insist on obtaining a single capability description (modulo key renaming) per pro\u00adgram point. Thus, \nthe capabilities along two control .ow edges with the same target have to be compatible. This requirement \nrestricts the set of programs that can be typed, but the techniques described in our earlier paper [3] \nfor encoding correlations between values and capabilities can be used to program around this limita\u00adtion \nin many cases. Given this restriction, the complexity of type checking is O(ekt), where e is the number \nof edges in the control .ow graph of a function, k is the maximal number of keys at any program point, \nand t is the maximal size of a type expression. In practice, k is relatively small (less than the number \nof local variables), for only few references refer to tracked objects. 6. EXTENSIONS This section discusses \na number of extensions that are important in practice, but would have obscured the pre\u00advious development \nunnecessarily. Multi guards. The guards G we discussed so far con\u00adsist only of the single key name of \nthe adopter. It is straight forward to extend guards to conjunctions of keys G ::= \u00b7| ..G. Such guards \ncan be introduced via a guard strengthening subtyping step: given an ex\u00adpression e with type Grh, we \ncan also give e the type (G..) rh, for any .. Strengthening the guard makes it harder to access the object, \nsince more keys must be held at the time of access. Guard strengthening is useful to view objects adopted \nby di.erent adopters under a common type. For instance, given objects of types .1 rh and .2 rh, we may \nwant to hold a reference to either of these objects. Since their types are incompatible, this is not \npossible without weakening each object s type to (.1 ..2) rh. Abstract guards. Our de.nition of resize \nhas the un\u00adfortunate property that it mentions in the pre and post capability the fact that the key .d \nguarding the cell is the key of a dictionary object. The nature of the guard is irrelevant for the code \nat hand. To solve this prob\u00adlem, we extend guards with abstract guard variables ., so that guards have \nthe form G ::= ... | . .G.Us\u00ading an abstract guard . in place of the explicit guard {.d}, along with \nan abstract capability E instead of the explicit capability {.d .dictionary} makes the type of resize \napplicable in more contexts. The only extra piece of information needed is that capability E implies \nthe guard .. This is recorded in the type context . with E=.. The more abstract type of resize is then \n.[.,E =.].(E,.r(int[] ),int) .(E,int) and is applicable to guarded cells no matter what the guard is. \nThe idea of using bounded quanti.cation on capabilities has been proposed by Crary et.al. to allow region \naliasing in particular contexts [2]. Similarly, ab\u00adstract guards and bounded capabilities give control \nover the aliasing granularity of guarded types. Consider the type context .= .1,.2,.3,E1 =(.1 ..2),E3 \n=.3 with capability E1.E3, and three objects of respective types .1 rh, .2 rh,and .3 rh. The capability \nbounds imply that guard .1 and .2 may overlap. Thus during afocus on .1 rh,guard .2 is not satis.able, \nbut guard .3 is, because the capabilities used to prove .1 and .3 are disjoint. Tracked vs. linear functions. \nSo far he have treated function types as ordinary types t, not heap types h, thereby ignoring the space \nrequirement of an associated closure record. If we want programmer control over clo\u00adsure allocation and \ndeallocation, we can treat function types as heap types. Closures then need to be allocated via new and \nresult in a tracked type, and they can be explicitly freed at a later point via free. Tracked func\u00adtions \ncan be called any number of times, until the point of deallocation. In contrast, linear functions as \nproposed by Wadler in [17] have the property that they can be called only once (so-called once functions). \nOnce functions arise naturally in linear type systems if function closures can capture objects of linear \ntype. Note that in our for\u00admalism, this is not possible, since the type environment contains no linear \ntypes s. If a function requires access to a key, the key must be explicitly mentioned in the pre capability. \nInterestingly, once functions are easily modeled in our formalism as tracked functions, where the function \nitself deallocates its own closure record. The type of such a function is tr(.c), where the heap type \nh associated with .c has the form: h = .[E,.c]({.c .h}.E,s1) .(E,s2) The pre capability contains {.c \n.h}, thereby requir\u00ading the key for the closure, but the post capability does not contain .c, thereby \nexpressing that the func\u00adtion consumes its own closure record. Once functions would be allowed to capture \nobjects of linear type in their closure. It is also interesting to note here that Wadler s let! cannot \nbe applied to linear function types for which it is unsound. Interestingly, adoption is sound for tracked \nand once functions. As long as the function does not require its own closure record in the pre capability \nit can be called after adoption. If it does, then the guarded function type will be uncallable, since \nthe key of the closure is not available. Autofocus. We have described focus as an explicit con\u00adstruct, \nwhere the extent of the focus is a lexical scope. Requiring a full lexical scope for a focus is often \nimprac\u00adtical, i.e., the focus should be released before the end of the scope3 . From a static typing \nperspective, the action occurring at the end of a focus scope is that the tem\u00adporary key . has to be \nrevoked after checking that the associated heap type h is the same as at the beginning of the scope, \nand to reinstate the revoked capability C1 used to prove the focus guard. To do away with the lexical \nscope, we simply have to record this information in the capability state for later perusal when the focus \nshould end. We propose therefore to extend capabilities with a linear implication C ::= ... |{. .h}.C \nalong with the focus elimination rule {..h}.{..h}.C f C Now focus can be a simple expression with the \nfollowing typing rule: .; G; C fe: Grh; C1.C2 . fC1 =G. fresh C3 = C2 .{..h}.{..h}.C1 [focus(e)] .; G; \nC ffocus e: tr(.); C3 Applying the above rule establishes focus on the result of expression e, until \nthe focus elimination rule is ap\u00adplied. A step further is to infer focus expressions au\u00adtomatically whenever \na tracked type is expected and a guarded type is provided, thereby providing autofocus. Self-adoption. \nWadler s let! has the advantage over adoption that there is no runtime operation involved, whereas adoption \nestablishes an adoption pointer. There 3This issue is similar to the one of early deallocation in region \nbased memory management. are two ways to provide a similar noop behavior in the adoption model. The lifetime \nrelationship estab\u00adlished by adoption states that the adoptee will outlive the adopter. This is a re.exive \nrelation (it is okay, if both lifetimes end simultaneously). Thus we can view an adopter as its own adopter. \nA simple, but unsound approach of doing so would be to view a reference of tracked type tr(.) with current \ncapability {. . h} as .rh. The approach is unsound because, through the handle of type tr(.), it is possible \nto change the heap cell from type h to h. via a strong update and then to view the cell through the guarded \ntype under h.There are two ways to solve this problem: 1) Provide a vir\u00adtual adopter .. and revoke capability \n., thereby making it impossible to change the type h (except temporar\u00adily under focus). To release the \nadoptee, we use linear implication and the focus elimination rule introduced above, as expressed by the \nfollowing typing rule .; G; C f e: tr(.); {.. h}.C2 .. fresh C3 = C2 . .. . h. .{.. . h}.{.. h} [self(1)] \n.; G; C f e: .. rh; C3 Here, .. serves as the virtual adopter with h. being an arbitrary type, since \nthere is no actual reference avail\u00adable to .. . The linear implication {.. . h}.{.. h}allows the adoption \nto be undone by eliminating the virtual adopter. A second solution is to strengthen the guard to in\u00adclude \nthe heap type under which the alias is estab\u00adlished. Given tracked type tr(.) with current capability \n{.. h} we provide an alias with guarded type .:hrh. The guard .:h is satis.ed by a capability C only \nif C contains {.. h}. This solution allows an object to be viewed under a tracked type tr(.) and simultaneously \nunder a guarded type .:hrh. If strong updates via the tracked type change h to h, the guarded reference \nbecomes inaccessible. Transitive adoption. The adoption relationship is tran\u00adsitive, i.e., if object \no1 is adopted by o2, which in turn is adopted by o3,then o1 is e.ectively adopted by o3.This observation \ncan be exploited in two ways: First, when object o2 with key .2 is adopted by o3 with key .3,any object \nearlier adopted by o2 thereby having type .2 rh1 can be viewed under the new guard .3 rh1. Second, there \nis no reason that o2 cannot adopt further objects after having been itself adopted by o3. Given a refer\u00adence \nto o2 with guarded type .3 rh2, it can adopt any object tr(.4) with underlying type h4 which can then \nbe viewed under type .3 rh4.  7. VALIDATION We have incorporated the ideas of adoption and focus into \nthe Vault programming language [3]. We brie.y describe how Vault makes these features available more \nconveniently than this paper s mini language and show a real world example. 7.1 Implementation in Vault \nWe implemented adoption and focus in the Vault pro\u00adgramming language, including the extensions of multi\u00adguards, \nabstract guards, tracked functions, autofocus, and self-adoption. In Vault s surface syntax, the tracked \ntype tr(.) is written tracked($R), and the guarded type .1 . .... .n rt is written {$R1,...,$Rn}:t or \nas $G:t for an abstract guard. For protocol checking, a programmer may attach a state token to a key, \nfor exam\u00adple $FILE@open. Our function syntax combines the pre\u00adand postconditions into a change speci.cation, \nwhich states the di.erence between the before and after capa\u00adbilities. The constituents of a change speci.cation \nare the following: Syntax Precondition Postcondition new $K@s +$K@s -$K@s $K@s $K@s1->s2 C C C.{$K@s}C.{$K@s}C.{$K@s1} \nC.{$K@s} (fresh $K) C.{$K@s}C C.{$K@s}C.{$K@s2} The @s su.x may be omitted for those protocols that \ntrack object lifetime but not state. The change speci.\u00adcation is both more terse than separate pre-and \npost\u00adconditions and also hides the universally quanti.ed con\u00adtext capability C. Besides self-adoption, \nVault provides general adop\u00adtion in the three forms described in Section 4.3. Re\u00adgion allocation is provided \nthrough primitives in the language, while the callback and linear list approaches are provided through \ntwo library interfaces. These in\u00adterfaces have functions to create an adopter, to adopt objects, and \nto delete the adopter and relinquish the adoptees.  7.2 Example: Direct3D vertex buffers Microsoft s \nDirect3D graphics library provides an exam\u00adple of a realistic interface protocol. The library supports \na vertex bu.er abstraction for rendering images to a screen. To render an image, the programmer must \ncre\u00adate a bu.er, clear it, draw primitives to it, and then present it. Further, calls to drawing primitives \nmust be directly enclosed by calls to the functions BeginScene and EndScene. Figure 4 shows a Vault speci.cation \nof this protocol. The right side of the .gure illustrates the interface as a state machine. To draw a \nsingle frame of an animation, a program loops through the cycle in this protocol, taking the bu.er through \nthe states raw, clear, rendering, ready,and back to raw. Within this larger cycle, the program will typically \ncall DrawPrimitive many times to draw a com\u00adplex scene. (Indeed, the function DrawPrimitive here is a \nsurrogate for a collection of drawing functions.) For Direct3D graphics programs, vertex bu.ers tend \nto be the program s central objects, referenced from many data structures. The need to alias vertex bu.ers \nand the cyclic nature of the protocol lend themselves well to adoption and focus. A graphics program \ncan create vertex bu.ers and adopt them in the raw state. The adopted vertex bu.ers can then be referenced \nfrom many data structures and no static knowledge of their aliasing relations is available. When the \nprogram wants to render an animation frame, interface VERTEX_BUFFER { type buffer; tracked($B) buffer \nCreateVertexBuffer () [new $B@raw]; Present Clear void Clear (tracked($B) buffer) [$B@raw->clear]; \nvoid BeginScene (tracked($B) buffer) [$B@clear->rendering]; void DrawPrimitive ($B:buffer, ...) [$B@rendering]; \nvoid EndScene (tracked($B) buffer) [$B@rendering->ready]; BeginScene void Present (tracked($B) buffer) \n[$B@ready->raw]; } DrawPrimitive Figure 4: The interface to vertex bu.er objects in the Direct3D library. \nit focuses on a particular vertex bu.er in order to call the interface s state-changing operations. By \nthe end of the focus, the bu.er is back in the raw state, leaving any alias of the bu.er unaware of the \nintermediate states. This example illustrates how adoption and focus al\u00adlow an object to switch back \nand forth from supporting aliasing to supporting protocol checking over the course of its lifetime. \n 8. RELATED WORK We brie.y review the related work on reasoning about state changes in programs with \ndynamically allocated memory. Region-based memory management. Tofte and Talpin present an inference system \nfor classifying all allocated data of a program into regions and deducing a safe lifetime for each region \n[16], which enables provably memory-safe implementations of ML-like languages with\u00adout a garbage collector. \nCrary et al. s Capability Cal\u00adculus extends this work by allowing explicit region al\u00adlocation and deletes, \nwhile making sure that all data accesses to a region happen during its lifetime [2]. Sim\u00adilarly, Niss \nand Henglein study an explicit region calcu\u00adlus, albeit for .rst order programs [5]. The commonality \nof these systems is that only re\u00adgions are treated linearly; all other objects are allocated within regions \nand have types akin to guarded types. Regions are not .rst-class values and cannot be stored in data \nstructures. Linear type systems. Starting with Wadler [17], linear types systems have been used in purely \nfunctional lan\u00adguages to enforce single threading on the state of the world or to implement operations \nlike array updating without the cost of a full copy [12]. Linear type sys\u00adtems enable resource management \nat the granularity of a single object. Every use of an object of linear type consumes the object, leading \nto a programming style where linear objects are threaded through the compu\u00adtation. Wadler s let! construct, \nor its variations [9], can be used to give a temporary nonlinear type to a object of linear type. Walker \nand Watkins [19] study a type system with three kinds of objects: linear, ref\u00aderence counted, and region \nallocated. The kind of an object is .xed at allocation without a means to change kind. They provide let! \nonly for regions. Alias type systems. Originally developed to track incre\u00admental initialization in TAL, \nalias types provide compile time names for unshared objects [13]. Walker extends this approach with existentially \nbound capabilities to support recursive data structures [18], bringing back the full expressibility of \nlinear types and its .ne grained re\u00adsource management. The advantage of alias types over linear types \nis that uses are not destructive and local aliasing can be handled. This leads to a more natural imperative \nprogramming style, since the threading of values in linear type systems is done at the type level. Walker \ndoes not examine ways to switch between linear and nonlinear views of objects. Object-oriented analyses. \nThe problem of representa\u00adtion exposure, namely uncontrolled sharing of the in\u00adternals of an abstraction, \nis most problematic in ob\u00adject oriented systems, where sharing and destructive updates are common. A \nnumber of di.erent approaches to declaring and checking representation invariants have been proposed, \nall with incomparable expressivity and enforceability. For example, the pivots used in ESC correspond \nto a linear component of a possibly shared container, but the formalism developed by Leino et al., does \nnot allow pivots to be reused [8]. Roles [7] enable the description of precise heap structures, since \nthey al\u00adlow more than a single reference to tracked objects, as long as all references are known. However, \nif an ob\u00adject s role is the equivalent of a guarded type, i.e., with an unknown number of references, \nthe object s role is frozen (no more type changes), and it can only be freed by a garbage collector. \nThe alias burying system pre\u00adsented by Boyland also allows unique pointers in shared data structures, \nbut access control is exercised through read e.ects, rather than the possible aliasing we express via \nguards [1]. Furthermore, the alias burying approach does not provide lifetime control. Heap logic. The \nLogic of Bunched Implications (BI) [6] is a formalism that allows one to reason about heap allocated \nstructures and their sharing properties. At its core, BI uses spatial conjunction to reason about disjoint \nparts of the heap. We are not aware of any automatic reasoning systems based on BI. Shape analysis based \non 3-valued logic (TVLA) [11] is another formalims for reasoning about heap structures. TVLA is promising \nin that there exists an e.ective algo\u00adrithm for inferring rather precise heap properties, albeit with \nhigh worst case complextiy. 9. FUTURE WORK The current paper does not address the problem of shar\u00ading \nobjects between multiple threads. Whereas exclu\u00adsive object access is easily modeled with keys, actually \nsharing data between threads is not. Adoption does not provide a solution here, since the adopter s key \nwould still be available only to one thread at a time. We are investigating mechanisms for sharing keys. \nIn shared key scenarios, the focus operation on shared keys would have to become an explicit locking \noperation. 10. CONCLUSION Enforcing interface protocols, data structure invariants, and proper memory \nmanagement at compile time greatly improves the quality of imperative resource-handling software. Our \nwork aims to develop techniques and lan\u00adguage features to make such static enforcement practi\u00adcal and \nmainstream. This paper provides a large step in that direction by enabling property checking and data \nstructure invariants for a much larger class of program\u00adming idioms. Still, there are data structure \nscenarios that our type system cannot handle. For instance, once an object is adopted, it cannot be recovered \nindepen\u00addently of all other adoptees of the same adopter. Fur\u00adthermore, the present techniques do not \naddress issues related to concurrency.   REFERENCES [1] J. Boyland. Alias burying: Unique variables \nwithout destructive reads. Software Practice and Experience, 31(6):533 553, May 2001. [2] K. Crary, D. \nWalker, and G. Morrisett. Typed memory management in a calculus of capabilities. In POPL 99 [10]. [3] \nR. DeLine and M. F\u00a8ahndrich. Enforcing high-level protocols in low-level software. In Proceedings of \nthe 2001 ACM SIGPLAN Conference on Programming Language Design and Implementation, June 2001. [4] D. \nGay and A. Aiken. Memory management with explicit regions. In Proceedings of the 1998 ACM SIGPLAN Conference \non Programming Language Design and Implementation, number 33:5 in SIGPLAN notices, pages 313 323, June \n1998. [5] F. Henglein, H. Makholm, and H. Niss. A direct approach to control-.ow sensitive region-based \nmemory management. In ACM Conference on Principles and Practice of Declarative Programming, Sept. 2001. \n [6] S. S.Ishtiaq and P. W.O Hearn.BI asan assertion language for mutable data structures. In Conference \nRecord of the 28th Annual ACM Symposium on Principles of Programming Languages, pages 14 26. ACMPress, \nJan. 2001. [7] V.Kuncak, P.Lam,and M. C.Rinard. Role analysis. In Conference Record of the 29th Annual \nACM Symposium on Principles of Programming Languages, Jan. 2002. [8] K.R.M.Leino andG. Nelson. Data abstraction \nand information hiding. Technical Report 160, Compaq SRC, nov 2000. [9] M. Odersky. Observers for linear \ntypes. In B. Krieg-Br\u00a8uckner, editor, ESOP 92: 4th European Symposium on Programming, Rennes, France, \nProceedings, pages 390 407, New York, 1992. Springer-Verlag. [10] Conference Record of the 26th Annual \nACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages. ACMPress, Jan. 1999. [11] M. Sagiv, \nT. Reps, and R. Wilhelm. Parametric shape analysis via 3-valued logic. In POPL 99 [10], pages 105 118. \n[12] S. Smetsers, E. Barendsen, M. v. Eekelen, and R. Plasmeijer. Guaranteeing safe destructive updates \nthrough a type system with uniqueness information for graphs. Lecture Notes in Computer Science, 776:358 \n379, 1994. [13] F. Smith, D. Walker, and J. G. Morrisett. Alias types. In European Symposium on Programming, \npages 366 381, 2000. [14] R. E. Strom and S. Yemini. Typestate: A programming language concept for enhancing \nsoftware reliability. tose, SE-12(1):157 171, Jan. 1986. [15] M. Tofte, L. Birkedal, M. Elsman, N. Hallenberg, \nT. H. Olesen, P. Sestoft, and P. Bertelsen. Programming with regions in the ml kit (for version 3). Technical \nReport 98/25, Department of Computer Science, University of Copenhagen, 1998. [16] M. Tofte and J.-P. \nTalpin. Implementation of the typed call-by-value .-calculus using a stack of regions. In Conference \nRecord of the 21st Annual ACM SSymposium on Principles of Programming Languages, pages 188 201, Jan. \n1994. [17] P. Wadler. Linear types can change the world! In M. Broy and C. Jones, editors, Programming \nConcepts and Methods. Apr. 1990. IFIP TC 2 Working Conference. [18] D. Walker and G. Morrisett. Alias \ntypes for recursive data structures. In Proceedings of the 4th Workshop on Types in Compilation, Sept. \n2000. [19] D. Walker and K. Watkins. On linear types and regions. In Proceedings of the International \nConference on Functional Programming (ICFP 01), Sept. 2001.  APPENDIX .; G; C f e : t ; C G(x)= t [var] \n.; G; C f x : t ; C .; G; C f e : tr(.); {. . h}.C2 h = (s1..si-1,ti,si+1..sn) [t-index] .; G; C f e.i \n: ti; {. . h}.C2 .; G; C f e1 : tr(.); C1 .; G; C1 f e2 : t ; {. . h}.C2 h = (s1..si-1,ti,si+1..sn) \nh. = (s1..si-1,t,si+1..sn) [t-update] .; G; C f e1.i := e2 : t ; {. . h}.C2 tf = .[.1](Cb,s1) . (Ca,s2) \nCb; s1 f C1; t1 ., .1;G[f : tf ][x : t1]; C1 f e : t2; C2 C2; t2 f Ca; s2 [fun] fun f[.1](x : s1): s2 \n.; G; C f : tf ; C pre Cb post Ca {e} .; G; C f e : .[.. , .].tf ; C1 [key] .; G; C f e[.]: .[.].(tf \n[./.]); C1 .; G; C f e : .[E = G, .].tf ; C1 . f C0 = G [cap] .; G; C f e[C0]: .[.].(tf [C0/E]); C1 . \nh = (int ..int ) . fresh n [new] .; G; C f new(n) : int; {. . h}.C .; G; C f e1 : tr(.1); C1 .; G; C1 \nf e2 : tr(.2); {.1 . h}.C2 . f C2 ={.2} [adopt] .; G; C f adopt e1:h by e2 : .2 rh; C2 .; G; C f e : \nt ; C1 C1 f C2 [cap-transform] .; G; C f e : t ; C2 C f C C1 f C2 {. . h}.C1 f{. . h}.C2 C1; si f C2; \nsi . {. .(s1..sn)}.C1 f{. .(s1..s..sn)}.C2 i C; s f C; s [int] .; G; C f i : int; C .; G; C f e : Grh; \nC2 . f C2 = G h = (s1..si-1,ti,si+1..sn) [g-index] .; G; C f e.i : ti; C2 .; G; C f e1 : Grh; C1 h = \n(s1..si-1,ti,si+1..sn) .; G; C1 f e2 : ti; C2 . f C2 = G [g-update] .; G; C f e1.i := e2 : ti; C2 .; \nG; C f e1 : .[].(Cb,s1) . (Ca,s2); C1 .; G; C1 f e2 : t2; C2 C2; t2 f Cb; s1 Ca; s2 f C3; t3 [app] .; \nG; C f e1(e2): t3; C3 .; G; C f e : .[., .].tf ; C1 [guard] .; G; C f e[G]: .[.].(tf [G/.]); C1 .; G; \nC f e1 : t1; C1 .; G[x : t1]; C1 f e2 : t2; C2 [let] .; G; C f let x = e1 in e2 : t2; C2 .; G; C f e \n: tr(.); {. . h}.C1 [free] .; G; C f free e : int; C1 .; G; C f e1 : Grh; C1.C2 . f C1 = G . fresh .; \nG[x : tr(.)]; C2.{. . h}f e2 : t2; C3.{. . h} [focus] .; G; C f let x = focus e1 in e2 : t2; C1.C3 . \nf C = G . f C = G1 . f C = G2 . f C =\u00b7 . f C = G1 . G2 . f C1 = G . f C2 = G . f C1.C2 = G . f C1.C2 \n= G C; s f C; s . f{. . h}={.} .,E = G1 . G2 f E = G1 [unpack] C1; .[.|{. . h}]. tr(.) f C1.{. . h}; \ntr(.) [pack] C1.{. . h}; tr(.) f C1; .[.|{. . h}]. tr(.)  \n\t\t\t", "proc_id": "512529", "abstract": "A type system with linearity is useful for checking software protocols andresource management at compile time. Linearity provides powerful reasoning about state changes, but at the price of restrictions on aliasing. The hard division between linear and nonlinear types forces the programmer to make a trade-off between checking a protocol on an object and aliasing the object. Most onerous is the restriction that any type with a linear component must itself be linear. Because of this, checking a protocol on an object imposes aliasing restrictions on any data structure that directly or indirectly points to the object. We propose a new type system that reduces these restrictions with the adoption and focus constructs. Adoption safely allows a programmer to alias objects on which she is checking protocols, and focus allows the reverse. A programmer can alias data structures that point to linear objects and use focus for safe access to those objects. We discuss how we implemented these ideas in the Vault programming language.", "authors": [{"name": "Manuel Fahndrich", "author_profile_id": "81100288438", "affiliation": "Microsoft Research, Redmond, WA", "person_id": "P348268", "email_address": "", "orcid_id": ""}, {"name": "Robert DeLine", "author_profile_id": "81350602833", "affiliation": "Microsoft Research, Redmond, WA", "person_id": "PP14215505", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/512529.512532", "year": "2002", "article_id": "512532", "conference": "PLDI", "title": "Adoption and focus: practical linear types for imperative programming", "url": "http://dl.acm.org/citation.cfm?id=512532"}