{"article_publication_date": "05-17-2002", "fulltext": "\n Using Data Groups to Specify and Check Side Effects * K. Rustan M. Leino Arnd Poetzsch-Heffter Yunhong \nZhou Compaq SRC FernUniversit\u00a8at Hagen Compaq SRC ABSTRACT Reasoning precisely about the side e.ects \nof procedure calls is important to many program analyses. This paper intro\u00adduces a technique for specifying \nand statically checking the side e.ects of methods in an object-oriented language. The technique uses \ndata groups, which abstract over variables that are not in scope, and limits program behavior by two \nalias-con.ning restrictions, pivot uniqueness and owner ex\u00adclusion. The technique is shown to achieve \nmodular sound\u00adness and is simpler than previous attempts at solving this problem. Categories and Subject \nDescriptors D.1.5 [Programming Techniques]: Object-oriented Pro\u00adgramming; D.2.1 [Software Engineering]: \nRequirements/ Speci.cations; D.2.4 [Software Engineering]: Software/ Program Veri.cation; D.3.3 [Programming \nLanguages]: Language Constructs and Features General Terms Documentation, Languages, Veri.cation  Keywords \nSide e.ects, modi.es lists, frame conditions, data groups, veri.cation, modular soundness, alias con.nement, \npivot uniqueness, owner exclusion * The author s current address is Microsoft Research, One Microsoft \nWay, Redmond, WA 98052, USA. Email: leino@microsoft.com. This work was done when Poetzsch-He.ter spent \na sab\u00adbatical at Compaq SRC, summer 2001. The author s current address is Fachbereich Informatik, Postfach \n3049, D-67653 Kaiserslautern, Germany. Email: poetzsch@informatik.uni-kl.de. The author s address is \nCompaq SRC, 130 Lytton Ave., Palo Alto, CA 94301, USA. Email: yunhong.zhou@compaq.com. Permission to \nmake digital or hard copies of all or part of this work for personal or classroom use is granted without \nfee provided that copies are not made or distributed for pro.t or commercial advantage and that copies \nbear this notice and the full citation on the .rst page. To copy otherwise, to republish, to post on \nservers or to redistribute to lists, requires prior speci.c permission and/or a fee. PLDI 02, June 17-19, \n2002, Berlin, Germany. Copyright 2002 ACM 1-58113-463-0/02/0006 ...$5.00. 0. INTRODUCTION Many static \nprogram analyses that support procedural ab\u00adstraction need to know what variables a procedure call may \nmodify. For example, an optimizing compiler can leave the value of a variable x in a register for the \nduration of a pro\u00adcedure call if it knows that the procedure will not modify the value of x . As another \nexample, a program analyzer that searches for programming errors can reason more precisely about a procedure \ncall if it knows on which variables the call may have side e.ects. In this paper, we present a tech\u00adnique \nfor specifying and statically checking the side e.ects of methods in an object-oriented programming language. \nIn many practical situations, a program analyzer does not have access to all the source code of a program. \nTherefore, we are interested in modular analyses, that is, the piecewise checking (or compilation, etc.) \nof a program. Consequently, we will not assume that the program analyzer knows the implementation that \nwill execute as a result of a call, nor that it knows all variables in the program. We are also interested \nin modular soundness [19], that is, we don t want our analyses to go awry on account of doing modular \nchecking (or on account of anything else, for that matter). Modular soundness can be stated as the property \nof scope monotonicity [19]: with more modules of a program available, reasoning about a program should \nlead to more precise information about possible program behaviors. Since we cannot rely on having the \nimplementation of a called procedure, we instead incorporate into the declaration of the procedure a \ndescription (a speci.cation)of which vari\u00adables may be modi.ed by the procedure. The speci.cation consists \nof a modi.es list [20]: the declaration proc p(t) modi.es m introduces a procedure p with formal parameter \nt ,and speci.es that the implementation of p only modi.es vari\u00adables in the list m . Modi.es lists have \nbeen incorporated into many program formalisms, speci.cation languages, and program checkers: Morgan \ns speci.cation statement [22], Z [29], Larch [10], JML [14], and ESC [5, 8], to mention but a few. The \nmod\u00adi.es list has also been shown to be the part of a proce\u00addure speci.cation that is most useful to \nan optimizing com\u00adpiler [32]. But there s a problem: how can one declare all the variables that a procedure \nmay modify if many of these vari\u00adables are not available (visible, in scope) where the proce\u00addure is \ndeclared? For example, in object-oriented languages, where subclasses can add instance variables and \nmethod im\u00adplementations, instance variables are often not visible at the declarations of the methods \nwhose implementations modify the variables. The answer is to use some form of abstraction mechanism with \nwhich one can refer to the unavailable variables without directly mentioning their names. In this paper, \nwe will use data groups [16] as that abstraction mechanism. A data group represents a set of variables \nand other (nested) data groups. In particular, a data group can represent variables that are not in scope. \nBy mentioning a data group in the modi.es list of a procedure declaration, the procedure gets the license \nto modify any variables that are included in the group (or in a nested group). Data groups can be seen \nas a restricted form of abstract variables and abstraction dependencies [15, 19]. The treat\u00adment of data \ngroups changes character depending on what the groups are allowed to include. In this paper, we study \ntwo kinds of data group inclusions, corresponding to static dependencies and dynamic dependencies, which \nseem to be the most fundamental kinds of abstraction dependencies [19]. These inclusions, which will \nbe de.ned in Section 2, are suf\u00ad.cient to specify many interesting programs. So far, the picture we ve \npainted looks pretty rosy. But achieving modular soundness for a program checker for real\u00adistic programs \nis not easy. Leino and Nelson have achieved sound modular checking for static dependencies [15, 19], \nbut not for dynamic dependencies [19, 4]. In his PhDthesis, Pe\u00adter M\u00a8uller has used a di.erent formal \nencoding (the logic by M\u00a8uller and Poetzsch-He.ter [24]) and has achieved modular soundness for any abstraction \ndependencies [23], provided universe types [25] are used to con.ne sharing of objects (usually called \naliasing of objects). In this paper, we present a simpler system for specify\u00ading and statically checking \nthe side e.ects in object-oriented programs. We restrict programs in two ways, by pivot unique\u00adness and \nby owner exclusion, both de.ned later. These restrictions con.ne sharing. They don t seem to severely \nlimit writing interesting and useful programs. We show a language and formal system, oolong, that enforces \nthe two restrictions and checks that procedure implementations ad\u00adhere to their speci.ed side e.ects. \nWe have implemented our formal system in a static checker for oolong, based on Simplify, the automatic \ntheorem prover that powers the program checkers ESC/Modula-3 [5] and ESC/Java [8]. Our checker takes \noolong programs as in\u00adput and automatically checks them, reporting any errors it .nds. Our formal system \nsatis.es modular soundness, as we show in this paper, and so far appears to be adequate for checking \ninteresting programs, based on empirical evidence of running the checker on a number of small but nontrivial \nexamples. The rest of the paper is organized as follows. In the next section, we continue to motivate \nspecifying and checking side e.ects, and compare some features of our work with previous work. Section \n2 describes the oolong language. Section 3 de\u00ad.nes the pivot uniqueness and owner exclusion restrictions. \nIn Section 4, we formalize the checking of oolong programs, and in Section 5, we go through some examples \nin more detail. We conclude the paper in Section 6. 1. RELATED WORK Greenhouse and Boyland have developed \na system based on abstract regions to specify and reason about e.ects [9]. Their regions are much like \ndata groups but don t allow a .eld to be included in more than one region, which we view as a severe \nlimitation (see [16] for programs that would be forbidden under the limitation). The Aspect system also \nprovides an abstraction mecha\u00adnism like data groups called aspects [11]. The system does not de.ne a \nstatically checkable discipline for avoiding the problems we describe in Section 3. Much work has been \ndevoted to various techniques for alias con.nement in object-oriented languages, but many of these techniques \ndo not avoid the problems described in Section 3. Among those that come the closest are extended local \nstores [31] and alias burying [1], and also the system of universe types [25] which has been proved to \nsolve the problems [23], though with a system that is not as simple as ours. It is interesting that an \nalias con.nement technique like alias burying needs reads lists (which specify which variables a procedure \nmay read), and that a treatment of reads lists seems to need alias con.nement [2]. Our technique does \nnot require reads lists, nor do we need a special notion of read-only like the one in [25]. However, \nour technique for checking side e.ects does entail alias con.nement. Others have also identi.ed the need \nfor alias con.nement in achiev\u00ading abstraction and modular reasoning [0]. To reduce the overhead of specifying \nside e.ects, tech\u00adniques have been developed to automatically infer informa\u00adtion about side e.ects [13, \n30]. Such inference tends to re\u00adquire large parts or all of a program, whereas an explicit abstraction \nmechanism like data groups caters to more mod\u00adular checking. A grander vision of which the speci.cation \nand checking of side e.ects is a part, is the goal of strengthening the in\u00advariants that a programming \nlanguage guarantees (cf. [18, 17]). A language under development in this area is Vault [3], which aims \nat improving resource management in programs. Other work along these lines includes LCLint [7], which \ngoes beyond the (admittedly weak) type system of C to .nd various common programming errors; extended \nstatic check\u00ading [5, 8], which provides a .exible and powerful system for specifying and checking programmer \ndesign decisions; and re.nement-types (e.g., [33]), which also go beyond the con\u00adventional type systems \nof today s popular languages. It is interesting that most work on re.nement-types has been played out \nin the context of functional programming languages, quite likely because the situation gets harder when \nthe program invariants implied by re.nement-types do not hold at every program point (cf. [18]). Indeed, \nthere is a feeling that functional languages are easier to reason about because one knows what their \nside e.ects are, namely none [27]. By using a technique like ours, one can both allow side e.ects and \nknow what they are. 2. THE OOLONG LANGUAGE In this section, we de.ne oolong, a primitive object-ori\u00adented \nlanguage. It is intended to model real languages at an appropriate level of detail with respect to the \nfeatures rele\u00advant for this presentation. An oolong program consists of a set of declarations. A declaration \nintroduces a data group, object .eld, procedure (method), or procedure implementa\u00adtion (see Figure 0). \nWe assume all names of declared entities to be unique. The language is untyped; ostensibly, every object \npossesses every .eld, but a program can refrain from using all of these .elds for all objects in a way \nthat cor\u00ad Decl ::= group Id [in IdList] | .eld Id [in IdList](maps Id into IdList) * | proc Id ( IdList \n) [modi.es ExprList] | impl Id ( IdList ) { Cmd } Figure 0: The grammar of the language oolong. responds \nto typed object-oriented languages where a given type possesses only some of the .elds. The declaration \ngroup g in h,k,... introduces a data group named g and declares it to be in\u00adcluded in groups h,k,... \n. These inclusions are not allowed to form a cycle. Similarly, the declaration .eld f in h,k,... introduces \nan object .eld (instance variable) named f and declares it to be included in groups h,k,... .An attribute \nis either a group or a .eld. For any object-valued expres\u00adsion e and attribute x ,we write e.x , called \na designator expression, to denote attribute x of the object denoted by e . The declaration proc p(t,u,...) \nmodi.es E,F ,... introduces a procedure named p with formal parameters t,u,... and grants p the license \nto modify the object .elds designated by the designator expressions E,F ,... . For any object t and group \ng , the license to modify t.g implies the license to modify t.x for any attribute x included in g . For \nexample, a part of a rational-number library may de\u00adclare group value proc normalize(r) modi.es r.value \nin its public interface. These declarations state that proce\u00addure normalize may change the rational value \nrepresented by object r , but do not state how rational numbers are represented. Thus, this example shows \ndata groups as an abstraction mechanism that can be used in the context of information hiding. The private \nimplementation of the li\u00adbrary may declare further attributes: .eld num in value .eld den in value which \nreveal some or all of the representation of the more abstract notion of value . Given these declarations, \npro\u00adcedure normalize has been granted the license to modify r.num and r.den . Note the direction of inclusion \ndeclarations: whether or not an attribute x is included in a group g is determined as part of x s declaration; \nit is not the case that the enclosing group g declares what attributes it includes. This direction is \nimportant for modular soundness; in fact, it su.ces to achieve modular soundness0 [16]. The direction \nalso makes sense from a methodological standpoint, because enclosing groups will be visible more widely \nthan the attributes they include. 0 provided the formal encoding takes into account possible inclusions \ninvolving .elds that are not in scope The inclusions that arise from in clauses are called local inclusions, \nbecause they say that an attribute of one object is included in a group of the same object.1 Alocal inclu\u00ad \nsion is useful when the data group plays the role of hiding a .eld in the object s implementation. Often, \nhowever, one object is implemented in terms of other objects. For ex\u00ad ample, a stack object may be implemented \nin terms of a vector object. Then, each stack has a .eld that points to the underlying vector object. \nSuch object .elds play such a prominent role in our methodology that we give them a name: pivot .elds \n[19]. Whether a .eld is a pivot .eld or not is made manifest by its declaration (see below). Attributes \nof an object referenced by a pivot .eld can be construed as attributes of the enclosing object, but instead \nof being local to the enclosing object, they distance them\u00adselves through an indirection of the pivot \n.eld.2 To specify how the attributes of the underlying objects are used in the enclosing object, oolong \nfeatures a maps into clause: the declaration .eld f maps x into g introduces a .eld f and declares group \ng to include f .x , where x is an attribute. Consequently, for any object t , the license to modify t.g \nimplies the license to modify t.f .x . A .eld is a pivot .eld if and only if its declaration contains \na maps into clause. For example, if contents is a data group of stack objects and elems is a data group \nof vector objects, then proc push(s,o) modi.es s.contents .eld vec maps elems into contents introduces \npivot .eld vec and speci.es that push has li\u00adcense to modify s.vec.elems . A.elddeclaration canhave bothan \nin clause and any number of maps into clauses. The inclusions that arise from maps into clauses are called \nrep inclusions, because they say that (some attribute of) one object is part of the representation of \n(a data group of) another object.3 Rep inclusions are conspicuously more di.cult to handle soundly than \nlocal inclusions, because rep inclusions seem to require restrictions on what can be done with the values \nof pivot .elds. Our next section will address this point, but .rst we will describe procedure implementa\u00adtions \nin oolong. The declaration impl p(t,u,...) { C } introduces command C as an implementation for procedure \np . For simplicity, we require the list of parameters t,u,... to be the same as in the declaration of \np . There is no limit on the number of implementations that can be given for one procedure; a call is \narbitrarily dispatched to any one of the implementations. This is our way of encoding dynamically dispatched \nmethods in our untyped language. 1 Local inclusions correspond to static dependencies [19]. 2 The fact \nthat the attributes of the underlying object are not inlined into the representation of the enclosing \nobject o.ers considerable .exibility to programmers. For example, it means that the particular subtype \nof the underlying ob\u00ad ject (e.g., one of several possible vector subtypes) can be determined as late \nas at runtime. But the indirection also has a price, which we try to get under control in this paper. \n3 Rep inclusions correspond to dynamic dependencies [19]. Cmd ::= assert Expr | assume Expr | var Id \nin Cmd end | Expr := Expr | Expr := new ( ) | Cmd ; Cmd | Cmd Cmd | Id ( ExprList ) Expr ::= Const | \nId | Expr . Id | Expr Op Expr Const ::= null | false | true | 0 | 1 | 2 | ... Figure 1: The grammar of \noolong commands and expressions. The grammars for commands and expressions are given in Figure 1. Data \ngroups are not allowed in commands; they are provided only for the purpose of specifying side e.ects. \nThe assert and assume commands terminate normally if the expression evaluates to true . Otherwise, the \nassert command causes the computation to go wrong, a condition that is undesirable, and the assume command \ncauses the computation to block, a condition that will never lead to anything undesirable (see, e.g., \n[26]). The var command introduces a new local variable, with an arbitrary initial value, for use within \nthe given sub-com\u00admand. Thenexttwo commands in Figure 1 updatethe valueof a local variable (if the left \noperand is an Id ) or an object .eld (if the left operand is a designator expression). No other left\u00adhand \nsides are allowed (not even formal parameters, which for simplicity we treat as unchangeable once they \nve been bound as part of a call). In the second assignment command, the value assigned is a newly allocated \nvalue. The command C ; D executes C and then, if C ter\u00adminates normally, executes D . The command C \nD arbi\u00adtrarily chooses either C or D to execute. Finally, the procedure call evaluates the actual parameters \nand then gives rise to the execution of an implementation, chosen arbitrarily, for the named procedure. \nExpressions are constants, local variables or formal pa\u00adrameters, designator expressions, or pre-de.ned \noperations (like equality and arithmetic minus). The grammar in Fig\u00adure 1 shows only binary operators, \nbut we can allow other operators, too, like negation. In our primitive language, the conventional if \nstatement if B then C else D end is encoded as (assume \u00acB ; D)(assume B ; C ) Iteration is performed \nby recursion. Our language does not provide special constructs for writing pre-and postcondi\u00adtions, but \nthese can be achieved for any procedure p by the following disciplined use of our language: for a precondition \nP , precede every call to p with the command assert P and start every implementation of p with assume \nP ;for a postcondition Q , end every implementation of p with the command assert Q and follow each call \nto p with assume Q (at call sites, one also needs to substitute the actual parameters for the formals \nin P and Q ). Our primitive language does not include explicit features for information hiding, like \nbeing able to declare interface modules and implementation modules. In oolong, a module is just a set \nof declarations. Note then, that the declarations available in the public interface of a module form \na subset of the declarations available in the private implementation of the module, and also forms a \n(di.erent) subset of the declarations available to a client of the interface. So far, we have mostly \ndescribed the syntax of oolong. In the next section, we describe some further restrictions in the language. \nThese restrictions will be important in achieving sound modular checking of modi.es lists in the presence \nof rep inclusions. 3. PROGRAMMING METHODOLOGY So what s so di.cult in producing a sound, practical, \nmodular, and statically-checkable methodology for program\u00adming with rep inclusions? Let s consider two \nproblems and go through the restrictions we impose to overcome the prob\u00adlems. 3.0 Pivot Uniqueness Suppose \na program contains the following declarations: group contents .eld cnt Think of contents as being declared \nin the public interface of a stack module and of cnt as being declared in the public interface of a vector \nmodule. Suppose also that the stack interface contains the following declarations: proc push(st,o) modi.es \nst.contents proc m(st,r) modi.es r.obj where obj is a.eldthatis usedasa vehicle for return\u00ading an object \nfrom a procedure (primitive as it is, oolong lacks a more direct way to return a value from a procedure). \nConsider the following implementation of a procedure q : impl q() { var st in var result in var v in \nvar n in st := new() ; result := new() ; m(st,result); v := result.obj ; n := v.cnt ; push(st,3) ; assert \nn = v.cnt end end end end } Since push(st,3) modi.es st.contents and the declarations given do not reveal \nany inclusion relation between contents and cnt , should a modular static checker be able to in\u00adfer that \nthe assertion will not go wrong, that is, infer that push(st,3) has no e.ect on the value of v.cnt ? \nNo runs the risk of producing an impractical checker, for what could such a checker infer at all! But \nyes runs the risk of producing an unsound checker, for consider the situation where stacks are represented \nin terms of vectors and m is implemented to return the vector that underlies a stack: .eld vec maps cnt \ninto contents impl m(st,r) {r.obj := st.vec } This example reveals a violation of modular soundness, \nbe\u00adcause the addition of the declaration of vec would cause the assertion above no longer to pass the \nchecker. Stated di.er\u00adently, under the yes alternative, we have shown that addi\u00adtional program information \n(the declaration of vec )leads to less precise information about the possible behavior of the call push(st, \n3) , which is a violation of scope monotonicity. So how do we get out of our dilemma? Further scrutiny \nof the example has led us (the authors) to the conclusion that the vector underlying the stack st should \nbe available only as st.vec , not as the value of the local variable v .More precisely, in a scope where \nthe rep inclusion via a pivot .eld is not known, unsound reasoning can arise if the value of the pivot \n.eld is available (cf. [19]). As long as the value of the pivot .eld is accessed directly from the .eld \nitself, then the pivot .eld will be available, thus the rep inclusion will be known, and hence modular \nsoundness is achieved. To prevent the problematic situation from arising, we im\u00adpose drastic restrictions \non what can be done with the values of pivot .elds; these restrictions will go under the rubric of pivot \nuniqueness restrictions . First, the pivot uniqueness restriction limits what values can be assigned \nto a pivot .eld. If the left operand of an assignment command has the form e.f where f is a pivot .eld, \nthen the right operand must be either new() or null . Second, the pivot uniqueness restriction limits \nthe right operand of assignments, to prevent the value of a pivot .eld from .owing into a local variable \nor other .eld. If the right operand has the form e.f ,then f may not be a pivot .eld. And if the right \noperand is an operator expression, then the operator may not return an object. Third, what about passing \nthe value of a pivot .eld as a parameter? It would be too strict to outlaw this case, be\u00adcause, for example, \nit would mean that the push method of a stack could not call any method on the underlying vector object. \nInstead, the pivot uniqueness restriction limits the use of formal parameters. We said already in the \nprevious section that assignments to formal parameters are not al\u00adlowed. The remaining case is that if \nthe right operand of an assignment command is an identi.er t ,then t may not be a formal parameter (that \nis, it must be a local variable). The pivot uniqueness restriction ensures that values in pivot .elds \nare either null or are unique, except possibly for copies stored in formal parameters on the call stack. \nPivot uniqueness allows us to avoid the problem we showed in procedure q above, because the fact that \nv is not a formal parameter implies v =.st.vec . Therefore, a static checker will not complain about \nthe assertion in procedure q ,re\u00adgardless of whether the declaration of vec is available to the checker. \nThe pivot uniqueness restriction con.nes sharing of ob\u00adjects that are referenced by pivot .elds. Note, \nhowever, that it does not restrict sharing via non-pivot .elds. 3.1 Owner Exclusion Now that our methodology \nkeeps close tabs on the values of pivot .elds, one might think we d be done. But a prob\u00adlem still remains. \nConsider a procedure w ,declared and implemented as follows: proc w(st, v) modi.es st.contents impl w(st, \nv) {var n in n := v.cnt ; push(st, 3) ; assert n = v.cnt end } As for procedure q in the previous subsection, \nwe argue that any practical static checker will pass this implementation of w in a scope where the declaration \nof the pivot .eld vec is not available (which is the case if the implementation of w is declared in some \nmodule other than the private stack implementation). However, if the pivot .eld vec is in scope, then \nthe implementation of w will not pass, because of the possibility that v = st.vec . Hence modular soundness, \nthat is, scope monotonicity, is violated. Notice that the pivot uniqueness restriction does not help, \nsince v is a formal parameter in this example. Indeed, so far our methodology would allow a call w(st, \nst.vec) from within the private implementation of the stack module, which would cause the assertion in \nw s implementation to fail at runtime. The problem we ve described violates modular soundness because \nof an unexpected side e.ect between the contents group of a stack and the cnt .eld of the stack s underlying \nvector object. The side e.ect is unexpected only if a piece of code uses the values of both st and st.vec \nin a scope where the rep inclusion is not known. Further scrutiny of the example has led us to the conclu\u00adsion \nthat the problem occurs only under the combination of three conditions. First, the problem occurs only \nwhen the value of a pivot .eld, like st.vec , is passed as a parameter (in other cases, pivot uniqueness \ntakes e.ect). Second, the problem occurs only when the owner of the pivot value, that is, st in the case \nof the pivot value st.vec , is accessible to the callee. In the call to w above, st is passed directly \nas a parameter, but there are other ways in which the stack could be accessed from the implementation \nof w , for exam\u00adple if w took a parameter s where s.x.y.z = st .Third, the problem occurs only if st.contents \nis modi.ed. From these three conditions, we suggest a restriction to avoid the problem: the owner exclusion \nrestriction. Owner exclusion takes e.ect at call sites, and states that the value of a pivot .eld can \nbe passed as a parameter only if the callee does not have license to modify the group with the rep inclusion. \nMore precisely, suppose f is a pivot .eld declared to map x into g . Then, for any object t and any procedure \np ,if p has the license to modify t.g ,then none of p s parameters is allowed to equal t.f .In our ex\u00adample, \nprocedure w has the license to modify st.contents , so owner exclusion prohibits the value st.vec from \nbeing passed as a parameter. A static checker enforces owner exclusion as a precondition check at every \ncall. This pre\u00adcondition can then also be assumed on entry to procedure implementations, which gives \nthe checker enough informa\u00adtion not to warn about the assertion in the implementation of w . A .nal note. \nIn this exposition, we have used the prop\u00aderty that a procedure implementation modi.es only what it is \nallowed to. If this were checked only at the end of a proce\u00addure implementation, the condition would \nnot be checked for implementations that do not terminate (for example by al\u00adways blocking), since then \nthere would be no execution path leading to the exit of the procedure. For owner exclusion to have the \ndesired e.ect, modi.cations must be checked as they occur, not at the end of procedure implementations.4 \n4 The issue described is not a problem with modular sound\u00ad  4. VERIFICATION CONDITION GENERA-TION In \nthis section, we formalize what it means in our tech\u00adnique for a program to be side-e.ect correct. In \nparticular, for every method implementation C of a method with a de\u00adclared modi.es list w , we prescribe \na veri.cation condition, a logical formula that is valid if and only if every execution of C modi.es \nonly what is allowed by w and no execution of C goes wrong. The prescription of the veri.cation condition \nis a function of a set of program declarations. Since we are doing modu\u00adlar checking, we do not assume \nthat the given declarations make up the entire, eventual program. Instead, the given set of declarations \nprovides a sub-program context that we will refer to as a scope. We require a scope to satisfy the rule \nof self-contained names: every attribute and method referred to in the scope is also declared in the \nscope. In other words, a scope is a set of declarations that will not give rise to an undeclared attribute/method \nerror. In a language with explicit features for information hiding, like interface modules and implementation \nmodules, the scope of an implementation module M would typically be the set of declarations in M and \nin the interface modules that M transitively imports. We don t want to be penalized by the absence of \nentire\u00adprogram information; that is, we don t want the absence of entire-program information to cause \nour modular analysis to miss program errors. More precisely, for any implementa\u00adtion C of a method m \nin a module M , if the veri.cation condition prescribed for C in the scope of M is valid, then we want \nthe veri.cation condition prescribed for C in the scope of the entire program to be valid too. In fact, \nsince the eventual program may be any extension of the scope of M , we want the validity of VCD (m, C \n) to entail the validity of VCE (m, C ), where VC is the function that prescribes the veri.cation condition, \nD is the scope of module M (or, more generally, any scope containing the implementation C ), and E is \nany extension of D . We identify this prop\u00aderty of scope monotonicity with modular soundness [19]. We \nuse the formalization technique developed by Poetzsch-He.ter [28] to achieve modular soundness: The properties \nof ascope D are formalized by a set of axioms AxD such that AxD . AxE for scopes E larger than D . Following \nthis technique, the veri.cation condition for an implementation C in a scope D has the shape: RD . wlp(C \n, true) (0) where function wlp gives the semantics of commands and RD formalizes the properties of scope \nD (de.ned below). The important point is that only the antecedent, RD ,ofthis formula depends on the \nscope. To achieve modular sound\u00adness, we therefore just need to ensure RE . RD for any extension E of \nscope D . 5 Let s add more detail. For any method m declared with ness, but a problem with the soundness \nof the axiomatic semantics with respect to an underlying operational seman\u00ad tics. 5 The property of \nscope independence in the right-hand side of (0) is simple, but stronger than necessary. To apply the \n described formalization technique, it su.ces for the right\u00ad hand side of (0) to be extension insensitive.That \nis, the technique applies as long as extensions of D don t change the right-hand side of (0). modi.es \nlist w and any implementation C of m in a scope D , we de.ne VCD (m, C )to be: UBP . BPD . Init(m) . \nwlpw,$0 (C , true) (1) The function wlp is a version of Dijkstra s weakest liberal precondition [6], \nwhich gives the semantics of command C . We will describe this application of wlp in Section 4.1, wherewealso \nde.ne wlp . Our de.nition of wlp uses some function and predicate symbols. These symbols get their meaning \nfrom a number of so-called background axioms that are conjoined to make up UBP ,the universal background \npredicate,and BPD ,the scope-dependent background pred\u00adicate for scope D . The predicate Init(m) describes \nthe state on entry to m . Note, as alluded to before, that in formula (1), only BPD depends on the scope \nD . Hence, we are able to achieve modular soundness simply by producing more background axioms in larger \nscopes. In the next subsection, we describe our semantic model for oolong, introducing the functions \nand predicates that it uses. The subsequent two subsections de.ne the semantics of commands and some \nfurther background axioms, respec\u00adtively. 4.0 The semantic model The central data structure in our semantic \nmodel is the object store,or store for short. A store keeps track of the values of object attributes \nand the set of objects that have been allocated. Objects and attributes are values in our semantic model. \nThe declared attribute names are modeled as distinct constants. An object X and attribute A determine \na unique loca\u00adtion in the store, denoted X . A .A store S functionally maps locations to values, so we \nwrite: S(X . A) (2) to denote the value of attribute A of object X in S . 6 For any value V ,and any \nX , A, S as above, the expres\u00adsion S(X . A := V ) (3) denotes the store that is like S ,except that X \n. A returns the value V . Store selection (2) and store update (3) satisfy the following familiar axioms \n[21]: {V if X = Y and A = B S(X . A := V )(Y . B)= S(Y . B)otherwise for all S, X , Y , A, B, V . These \naxioms are part of the uni\u00adversal background predicate. The predicate alive(S, X ) asserts that object \nX has been allocated in store S (it may or may not be reachable from the program). For any stores S and \nT , we de.ne S \u00ab T as: ( . X , A :: alive(S, X ) . alive(T , X ) . S(X . A)= T (X . A)) 6 Our model includes \nlocations for groups, too, and a store de.nes values for these locations. However, there is no com\u00admand \nthat assigns to a group (nor is there any expression that reads the value of a group). Therefore, the \nvalues of group locations remain constant, and so need not be repre\u00adsented at runtime. which says that \nT may have more allocated objects than S ,and that S and T agree on the values of attributes for their \ncommonly allocated objects. We associate with every store S the next object to be allocated, denoted \nnew(S) ; the store that results by allo\u00adcating this object is written S+ [28]. Thus, for any S ,we have \nthe following properties: \u00acalive(S, new(S)) . S \u00ab S+ . alive(S+, new(S)) which are included as part of \nthe universal background pred\u00adicate. Next, we describe the formalization of inclusions, for which we \nwill use three relations. We follow the strategy of M\u00a8uller and Poetzsch-He.ter [24] by letting the relations \ndenote what is true in the entire, eventual program. In the given veri.cation scope, the relations will \nthen necessarily be left underspeci.ed, so that the only properties one can infer from them are properties \nthat hold in any extension of the given scope. The .rst two relations are relations on attributes. For \nany attributes a and b ,relation a b .1 corresponds to local inclusions and asserts that the program \ndeclares a .eld b with a clause in a . As it turns out, it will be more convenient to work in terms \nof the re.exive, transitive clo\u00adsure of a . b .In fact, .1 , which we will write simply as will not be \npart of the formalization and we will men\u00ad .1 f tion it no more. For any attributes a, f , b ,relation \na . b corresponds to rep inclusions and asserts that the program declares a .eld f with a clause maps \nb into a . Note f that a . b holds only if f is a pivot .eld. From these relations, we de.ne a relation \non locations: for any X , Y , A, B, S ,the main inclusion relation S X . A . Y . B asserts that location \nX . A includes location Y . B in store S . For example, in terms of the running example in Section 3, \nwe have S st . contents . S(st . vec) . cnt for any store S . The connection between the three relations \nis captured by the following background axiom, for all X , Y , A, B, S : S X . A . Y . B = (4) (X = Y \n. A . B) . (X .:: Y = S(ZF ) . = Y . ( . Z , H , F , K . SF X . A . Z . H . H . K . K . B )) This axiom \nsays that if X and Y are equal, then the main inclusion relation boils down to the local inclusion relation; \nif X and Y are di.erent objects, then the main inclusion relation is a composition of inclusions going \nthrough at least one pivot .eld, F . We also add the background axiom: S . is transitive to the universal \nbackground predicate. The universal background predicate also contains other axioms about the three inclusion \nrelations, and the scope\u00addependent background predicate contains axioms that con\u00adnect the .rst two relations \nto the attribute declarations in the program. These background axioms are described in Section 4.2. Next, \nwe ll focus on the semantics of commands. wlpw,S (assert E, Q)= tr(E) . Q wlpw,S (assume E, Q)= tr(E) \n. Q wlpw,S (var x in C end, Q)=( . x :: wlpw,S (C , Q)) provided x does not occur free in Q wlpw,S (C0 \n; C1, Q)= wlpw,S (C0, wlpw,S (C1, Q)) wlpw,S (C0  C1, Q)= wlpw,S (C0, Q) . wlpw,S (C1, Q) wlpw,S (x \n:= E, Q)= Q[x := tr(E)] wlpw,S (x := new(), Q)= Q[x := new($)][$ := $+] wlpw,S (E0.f := E1, Q)= mod(tr(E0) \n. f , w, S) . Q[$ := $(tr(E0) . f := tr(E1))] wlpw,S (E.f := new(), Q)= mod(tr(E) . f , w, S) . Q[$ \n:= $(tr(E) . f := new($))][$ := $+] tr(c)= c tr(x)= x tr(E.f )=$(tr(E) . f ) tr(E0 Op E1)= tr(E0) Op \ntr(E1) Figure 2: The semantics of commands and ex\u00adpressions are given by the functions wlp and tr . \n(Method call is de.ned in Figure 3.) 4.1 The semantics of commands The function wlp is a version of \nDijkstra s weakest liberal precondition [6] for a command C . For any modi.es list w ,object store S \n, command C , and postcondition Q , the predicate wlpw,S (C , Q) denotes those program states from which: \n every terminating execution of C terminates in a state satisfying Q ,  every execution of C modi.es \nonly what is allowed by w evaluated in S ,and  no execution of C goes wrong.  Note that the second \nof these bullets mentions w evalu\u00adated in S . The reason for this is that the meaning of a modi.es list \ndepends on the values of pivot .elds, which are de.ned by an object store. In our de.nition and application \nof wlp , we take the point of view that what is allowed to be modi.ed by a method is determined by the \nmethod s de\u00adclared modi.es list evaluated using the values of pivot .elds on entry to the method. The \nveri.cation condition (1) only checks that C is side\u00ade.ect correct. Therefore, it applies wlp with the \npostcon\u00addition true (which has the e.ect of trivially satisfying the .rst of the bullets above). The \nside e.ects that C in (1) is allowed are those speci.ed by m s modi.es list evaluated in the initial \nstate of m . Therefore, (1) applies wlp with the subscripted arguments w, $0 ,where $0 denotes the object \nstore on entry to m , as de.ned by Init(m)below. The wlp of a command C is de.ned over the structure \nof C , using the cases in oolong s grammar in Figure 1. The de.nition is found in Figures 2 and 3. Except \nfor method call, the commands have a fairly standard de.nition, but several remarks are still in order. \nThe translation of oolong expressions into formulas is done using function tr , de.ned in Figure 2. It \nturns object deref\u00aderences into expressions that pick out the value from the current store, which we \ndenote by the special variable $ . For brevity, we have left out the conditions that stipulate For method \nq declared as: proc q(t1,...,tn ) modi.es wt, wlpw,S (q(E1,...,En ),Q)= ( .s1,...,sn :: s1 = tr(E1) . \n\u00b7\u00b7\u00b7 . sn = tr(En ) .  ( .E,f E.f .ws :: mod(tr(E) . f ,w,S)) . ownExcl(s1,ws,$) . \u00b7\u00b7\u00b7 . ownExcl(sn ,ws,$) \n. ( .$' :: ( .X :: alive($,X ) . alive($',X )) . ( .X ,F :: $(X . F )=$'(X . F ) . mod(X . F ,ws,$) ) \n . Q[$ := $'])) where the si s and $' are fresh variables, and ws denotes wt with each ti replaced by \nthe corresponding si . Figure 3: The semantics of method call. expression evaluation to be well de.ned \n(for example, that no null dereferences or division-by-zero errors occur). For commands that can change \nthe value of a variable v (including the special variable $ ), the semantics uses an expression of the \nform E0[v := E1] , which denotes the ex\u00adpression E0 with all free occurrences of v replaced by ex\u00adpression \nE1 . The allocation commands have the e.ect of setting their targets to the next object to be allocated, \nnew($) , and then updating the store accordingly, to $+ . The .eld update commands require that their \ntargets be assignable according to the modi.es list w evaluatedinthe store S . This is spelled out by \nfunction mod ,which is de.ned below. The semantics of method call, shown in Figure 3, is more complicated. \nFirst, it identi.es the actual parameters with formal-parameter counterparts. Second, it requires that \nev\u00aderything listed in the modi.es list of the callee be assignable according to w evaluated in S . Weuse \nthenotation:  ( .E,f E.f .ws :: R(E,f )) to denote the conjunction of all predicates R(E,f )where E \nand f range over the terms E.f in ws .Third, it requires that the owner exclusion restriction be observed, \nwhere ownExcl is de.ned below. Finally, it updates $ to take into consideration the side e.ects that \nthe callee is per\u00admitted.7 We now de.ne what it means for a location X . A to be assignable according \nto a modi.es list w evaluatedina store S , written mod(X . A,w,S). For all X ,A,w,S : mod(X . A,w,S) \n=\u00acalive(S,X ) . incl(X . A,w,S) 7 The wlp of method call actually needs the scope in order to look up \nthe modi.es list wt of the called method q . Formally, this would require adding a scope parameter to \nwlp , but, for brevity, we have left that parameter implicit. The scope parameter, whether explicit or \nimplicit, means that the right-hand side of (1) is in fact dependent on the scope, which jeopardizes \nthe application of the formalization technique for modular soundness. Note, however, that a modi.es list \nis given at the declaration of a method and is not changed by any subsequent program extension. Since \nscopes satisfy the rule of self-contained names, any scope D that contains an implementation C also contains \nthe declarations of the methods called from C . Therefore, the wlp of C is extension insensitive, and \nthe formalization technique can be applied, see footnote 5. where incl is de.ned as follows, for all \nX ,A,w,S : incl(X . A,w,S) = S ( .E,f E.f .w :: tr(E) . f .X . A ) In words, modi.es list w evaluated \nin store S allows lo\u00adcation X . A to be assigned if and only if object X is not allocated in S or there \nis a term E.f in w such that lo\u00adcation tr(E) . f includes X . A . Next, we formalize the owner exclusion \nrestriction. For any method m with modi.es list w ,any variable t (cor\u00adresponding to a formal parameter \nof m ), and store S (at the time of entry to m ), we de.ne ownExcl as follows: ownExcl(t,w,S) = ( .X \n,A,F ,B :: F= S(XF ) . t = null A .B . t . . .\u00acincl(X . A,w,S)) The property says that the non-null value \nof a pivot .eld F for an object X can be passed as the parameter t only if m does not have the license \nto modify the A attribute of X . In terms of our example from Section 3.1, this owner exclusion restriction \nsays that the pivot .eld vec for an object st canbe passedas a parameter to a method m only if m does \nnot have the license to modify st.contents . Because it is checked at every call site, owner exclusion \nwill hold on entry to every method implementation. This fact is often useful to the veri.cation of a \nmethod implemen\u00adtation. Therefore, for any method m declared with modi.es list w , we de.ne Init(m) to \ncontain the conjuncts ownExcl(t,w,$0) . alive(t,$0) (5) for every formal parameter t of m . Additionally, \nInit(m) contains the conjunct: $=$0 which identi.es $0 with the current store on entry to the method. \n 4.2 Properties of inclusions In this section, we describe additional background axioms. The universal \nbackground predicate contains three more axioms, which canbe provedtoholdinevery oolong pro\u00adgram execution. \nThe .rst axiom states that non-null pivot .elds in the store have unique values, which is a consequence \nof the pivot uniqueness restriction: G F... F )= null .A . (X = Y . F = B) . S(X . (6) F )= S(Y . S(X \n. .. B) Here and in the next two axioms, all free variables are uni\u00adversally quanti.ed. Note how the \naxiom uses the rep inclu\u00adsion relation G Fis a pivot .eld . The second .A to say F axiom states that \nthe main inclusion relation is insensitive to changes of non-pivot .elds: ( .Z ,F ,G,H :: G F. S(Z . \nF )= T (Z . F )) .H ST . (X . A .Y . B = X . A .Y . B) The third axiom states that if F is a pivot .eld \nthat maps into G ,then X . G is not included in any group of X .F : G F= S(XF ) . Y =.null .A . Y . S(7) \n.\u00acY . B .X . G In other words, this axiom states that there are no cycles among the inclusions of locations. \nSo far, all of the background axioms we have presented are part of the universal background predicate, \nbecause they ap\u00adply to all oolong programs. Next, we present the background axioms that are generated \nfrom the attribute declarations in a given scope. For a given scope D , these axioms make up the scope-dependent \nbackground predicate BPD . When performing a veri.cation of a method implemen\u00adtation, one frequently \nneeds to discharge proof obligations of the form mod(X . A,w,$0) , to prove that the implemen\u00adtation \nhas the appropriate license to modify the value at a location X . A . Such license comes from the method \ns mod\u00adi.es list evaluated on entry to the method, and so the proof of having such license involves establishing \nproperties of the $0 form Y . G .X . A . This, in turn, is done via the inclusion connection (4) by showing \nthe presence of various \u00b7.\u00b7 and \u00b7 \u00b7.\u00b7 relations. Verifying a method implementation also involves discharg\u00ading \nthe conditions given in assert commands, to prove that no execution goes wrong. The proof of such a condition \nmay involve showing that some method call does not have a side e.ect on some particular object .eld (as \nwas the case with push and v.cnt in the examples in Section 3). To show that S requires establishing \nproperties of the form \u00acY . G .X . A , which in turn is done using the owner exclusion property (5) assumed \non entry, using axiom (7), or via the inclusion con\u00adnection (4) by showing the absence of various \u00b7.\u00b7 \nand \u00b7 \u00b7.\u00b7 relations. It may not be clear how one can show the absence of cer\u00adtain inclusions in a modular \nsetting, since a program exten\u00adsion can always declare more inclusions. However, inclusions are only \ndeclared with in and maps into clauses, which are part of particular attribute declarations. Thus, the \npres\u00adence or absence of certain in and maps into clauses on a particular attribute a gives us perfect \ninformation about certain inclusions involving a .We now describe exactly what this information is. For \nany attribute a declared in a scope D , all groups that include a , directly or indirectly, are also \ndeclared in D .This is because the in clause of the declaration of a states which groups directly include \na ; and, since scopes satisfy the rule of self-contained names, these groups are also declared in D ;and \nthe in clauses of the declarations of these groups state which other groups directly include these groups; \nand so on. Let g1,... ,gn be the set of groups that directly or indirectly include attribute a . Then \nthe following background axiom is part of BPD : ( .G :: G .a = G = a .G = g1 . \u00b7\u00b7\u00b7G = gn ) Note that \nin the special case where a has no in clause, the right-hand side is simply G = a . Note also that this \naxiom enables us to derive either g .a or \u00acg .a ,for any attribute g whatsoever. Since, as we have just \nargued above, the set of enclosing groups of a are all declared in D , this set of groups, and the axiom, \nare the same in every extension of D . Similarly, for rep inclusions, the maps into clauses of the declaration \nof an attribute f in a scope D allows us to f determine all pairs of attributes a and b such that a .b \n. Let b1,... ,bn be the attributes mapped by f ; that is, sup\u00adpose the maps into clauses of f are maps \nb1 into ... , ... , maps bn into ... . Then, the following background axiom is part of BPD : f ( .A,B \n:: A .B . B = b1 .\u00b7\u00b7\u00b7 .B = bn ) (8) This axiom says that the possible right-hand arguments of f \u00b7.\u00b7 are \nb1,... ,bn . Note that in the special case where f has no maps into clauses, the right-hand side is the \nempty disjunction, false . Furthermore, for any attribute f declared with a clause maps b into ... , \nlet a1,... ,an be the groups that f maps b into; that is, suppose that the maps b into ... clauses \nof f are maps b into a1 , ... , maps b into an . Then, the following background axiom is part of BPD \n: f ( .A :: A .b = A = a1 . \u00b7\u00b7\u00b7 .A = an ) (9) This axiom says that the possible (left-hand) arguments \nof f \u00b7.b are exactly a1,... ,an . Note that, for any attribute f declared in D , axioms (8) ff and (9) \nenable us to derive either a .b or \u00aca .b ,for any attributes a and b whatsoever. And note that these \naxioms will be the same for any scope that contains this declaration of f , in particular the axioms \nwill be the same in every extension of D . We have now described all the axioms of the background predicate, \nand have thus described the entire prescription of veri.cation conditions in oolong.  5. EXAMPLES Our \ngoal is to produce a sound, practical, modular checker. The formalization technique we used in the previous \nsection achieves modular soundness. It requires that the wlp can be expressed in a scope-independent \nway. This, in turn, was facilitated by the object store and inclusion relations, which assert properties \nof the entire, eventual program. So then, if that is all that is required for modular soundness, then \nwhat happened to the pivot uniqueness and owner exclu\u00adsion restrictions? In our system, they are key \ningredients to making veri.cation go through, as required for the prac\u00adticality of the checking technique. \nNote for example that pivot uniqueness is needed to verify the implementation of method q in Section \n3.0; background axiom (6) implies that the value of result.obj is not the value of any pivot .eld, and \nthus st.vec .= v . Also, owner exclusion is needed to verify the implementation of method w in section \n3.1; the initial condition (5) implies that st.vec =.v .In this section, we give three examples involving \nsmall programs of the sort we have used in testing our checker implementation. These examples show how \nthe two programming restrictions enable the veri.cations. First example. Let s consider in some detail \nthe veri.\u00adcation of the following program: .eld c .eld d .eld f group g proc p(t) modi.es t.c.d.g proc \nq(u) modi.es u.g impl p(t) { assume t . = null ; var y in y := t.f ; q(t.c.d); assert y = t.f end } The \nveri.cation condition for the implementation of p is: UBP .BP .ownExcl(t,t.c.d.g,$0) .alive($0,t) . $=$0 \n.t =.null . ( .y :: ( .u :: u =$($(t . c) . d) . mod(u . g,t.c.d.g,$0) .ownExcl(u,u.g,$) . ( .:: $ ' \n( .X :: alive($,X ) .alive($ ' ,X )) . ( .X ,F :: $(X . F )=$ ' (X . F ) .mod(X . F ,u.g,$) ) .$(t . \nf )=$ ' (t . f ) ))) For brevity, we didn t expand mod and ownExcl in this formula. There are three proof \nobligations, two for the call and one for the assert. The .rst proof obligation checks that the caller \nhas the license to modify the targets of the callee. It expands to: The essence of the veri.cation condition \nfor the implemen\u00adtation of twice is: $=$0 .t0= t . mod(t0 . g,t.g,$0) .ownExcl(t0,t0.g,$) . ( .:: ... \n.t1= t . $ ' mod(t1 . g,t.g,$0) .ownExcl(t1,t1.g,$ ' ) . $ '' ( .:: ... .true )) The two mod expressions \nfollow from .eldwise re.exivity, and the ownExcl expressions follow from (11). This example was used \nby Leino and Nelson to motivate their swinging pivots restriction [19]. A consequence of our way of enforcing \nthe pivot uniqueness restriction is that pro\u00adgrams always satisfy the swinging pivots restriction, and \nour proof system makes programs such as the one above easy to prove. Third example. This .nal example \nconsiders linked lists $ g .u . g 0 \u00ac alive($0,u) .$($(t . c) . d) . and follows from u =$($(t . c) . \nd) and .eldwise re.exiv\u00adity : the scope-speci.c background axiom g .g and the inclusion connection (4). \nThe second proof obligation checks the owner exclusion restriction at the call site. It expands to: F \n( .X ,A,F ,B :: A .B .u =$(X . F ) .u .= null (10) $ .\u00acu . g .X . A ) and follows directly from axiom \n(7). In fact, for any method with a parameter u and a modi.es list u.g , the following useful property \nholds, for all S : (7) .ownExcl(u,u.g,S) (11) There is an alternative way of proving (10): the pivot \nuniqueness axiom (6) and $($(t . c) . d)=$(X . F )imply that d = F , but d is not a pivot .eld, so the \nantecedent of (10) is false . The third proof obligation comes from the assert state\u00adment, which sees \nthe e.ects of the call. It is discharged by proving \u00acmod(t . f ,u.g,$) and using the antecedent about \n$ ' . This negated mod expression expands to: $ \u00ac(\u00acalive($,t) .u . g .t . f ) To prove the negation of \nthe second disjunct, we .rst de\u00adcompose it using the inclusion connection (4), and get: \u00ac((u = t .g .f \n) . (u .Z ,H ,F ' :: . F ' = t .( .,Kt =$0(Z ) . and an operation on such lists: group g .eld value \nin g .eld next maps g into g proc updateAll(t) modi.es t.g impl updateAll(t) { assume t . = null ; t.value \n:= t.value +1; ( assume t.value = null assume t.value .= null ; updateAll(t.next) ) } Recall that the \nconstruction with assume and is really just an if statement. Note the cyclic rep inclusion in this example: \nt.g includes t.next.g . We call it cyclic because g occurs on both sides of the main inclusion relation, \nnot because of any cycle through pivot .elds in the object store (which pivot uniqueness prevents, anyhow). \nThe essence of the veri.cation condition for the imple\u00admentation of updateAll is: t . = null . mod(t \n. value,t.g,$) . ($ ' =$(t . value := ...).$ ' (t . next) .= null . t0=$ ' (t . next) . mod(t0 . g,t.g,$ \n' ) .ownExcl(t0,t0.g,$ ' ) . $ '' ( .:: ... .true )) wherewehaveintroduced the name $ ' for the store \nafter the H .H F. .K .K .f ))) $ 0 u . g .Z . update of t.value .The mod expressions follow straightfor\u00ad \n 0 The.rstdisjunctis false , because the scope-speci.c back\u00adground predicate implies \u00acg .f . The negation \nof the second disjunct is a perfect match for the owner exclusion property assumed on entry, which expands \nto: F. ( .Z ,H ,F ' ,K :: H .K .t =$0(Z . F ' ) .t =.null $ wardly from the background axioms about inclusions, \nand the ownExcl expression holds on account of (11). We .nd this proof delightfully simple. Unfortunately, \nthe simplicity of this hand proof is not re.ected in our checker implementation. The theorem prover we \nre using (Simplify) uses some matching heuristics to guide its in\u00adstantiation of quanti.ed expressions. \nThese heuristics show .Z This concludes the veri.cation of our .rst example program. Second example. \nWe proceed using less detail than in the .rst example. Consider the following program: group g proc once(t) \nmodi.es t.g proc twice(t) modi.es t.g impl twice(t) { once(t); once(t) } .\u00ac$($(t . c) . d) g . . H ) \nsigns of fragility when cyclic inclusions are involved, caus\u00ad ing the prover to loop irrevocably, and \nso we have not had complete success in mechanically verifying simple programs with cyclic inclusions \nlike the one above. This is similar to Joshi and Leino s attempt to mechanize the analogous cyclic dependencies \n[12], but our hand proofs are consider\u00adably simpler, which makes us more optimistic about .nding a way \nto prevent the divergent behavior in our mechanical implementation.  6. CONCLUSION In summary, we have \nintroduced a technique for speci\u00adfying and statically checking the side e.ects of methods in an object-oriented \nlanguage. The technique works in the presence of information hiding and features data groups as a mechanism \nto represent variables that a method s imple\u00admentations can modify but that are not available in the \nscope where the method is declared and speci.ed. In this paper, we have allowed data groups to include \n.elds of the same object and .elds of underlying representation objects, which seem to be the two inclusions \nmost useful in prac\u00adtice. To achieve modular soundness and make our technique practical, we have proposed \ntwo alias-con.ning restrictions, pivot uniqueness and owner exclusion. These restrictions also account \nfor the simplicity of our technique. Achieving modular soundness in a formal system has taken considerable \ne.ort. Essentially, there are two di.erent ap\u00adproaches to formally handle modular soundness. Here, we \nused one variable to represent the entire store, including object .elds whose names are not known in \nthe veri.cation scope, and one relation to model inclusions [23]. An alterna\u00adtive approach is to encode \nobject .elds as di.erent variables and dealing with the inclusion relation as a preprocessing step rather \nthan explicitly in the logic [19]. Our conclusion is that the former approach o.ers a much quicker road \nto soundness than latter. We have implemented our formal system in an automatic checker for a primitive \nobject-oriented language. We have gained con.dence in our technique by running small but nontrivial examples \nthrough this checker, but would like to try the technique in the setting of a real language and real \nprograms. Our formal system produces veri.cation conditions, logi\u00adcal formulas that in our checker are \nanalyzed by a mechani\u00adcal theorem prover. The experience with ESC [5, 8] suggests that using a theorem \nprover as part of a program analysis en\u00adgine is feasible. Nevertheless, it is entirely possible that \nour technique of data groups and the two restrictions can also be checked, albeit more conservatively, \nusing more primitive techniques (cf. [11]). We are also interested in the extension of our work to other \nkinds of inclusions. At the top of our list is the kind of inclusion that arises when an object is implemented \nin terms of an array of underlying objects (an inclusion that corresponds to array dependencies [19]). \nSince the overhead for specifying data groups, inclusions, and modi.es lists does not seem overwhelming, \nwe hope to see a technique like ours included as part of a programming language. By allowing design decisions \nabout side e.ects to be written down by programmers and checked automati\u00adcally by the compiler, such \na language could both eliminate programming errors and enable further program analyses. 7. ACKNOWLEDGMENTS \nWe are grateful to Raymie Stata for helping design the .rst owner exclusion restriction in a more complicated \nset\u00adting, which inspired this simpler one; to John Boyland for some of the notation we ve used; and to \nRoy Levin for sug\u00adgesting oolong as the name of an object-oriented language it combines two popular features \nof such names: double-o and ca.einated beverage. We d also like to thank the refer\u00adees for their detailed \ncomments. 8. REFERENCES [0] A. Banerjee and D. A. Naumann. Representation independence, con.nement and \naccess control [extended abstract]. In Proc. 29th POPL, pages 166 177, Jan. 2002. [1] J. Boyland. Alias \nburying: Unique variables without destructive reads. SP&#38;E, 31(1):533 553, Jan. 2001. [2] J. Boyland. \nThe interdependence of e.ects and uniqueness. In 3rd workshop on Formal Techniques for Java Programs, \n2001. [3] R. DeLine and M. F\u00a8ahndrich. Enforcing high-level protocols in low-level software. In Proc. \nPLDI 01, volume 36 of SIGPLAN Notices 36(5), pages 59 69. ACM, May 2001. [4] D.L. Detlefs, K.R. M. Leino,and \nG. Nelson. Wrestling with rep exposure. Research Report 156, Digital Equipment Corporation Systems Research \nCenter, July 1998. [5] D.L. Detlefs, K.R. M. Leino,G.Nelson, andJ.B. Saxe. Extended static checking. \nResearch Report 159, Compaq SRC, Dec. 1998. [6] E.W.Dijkstra. A Discipline of Programming. Prentice Hall, \nEnglewood Cli.s, NJ, 1976. [7] D.Evans,J. V.Guttag, J. J. Horning, and Y.M.Tan. LCLint: A tool for using \nspeci.cations to check code. In D. S. Wile, editor, Proc. 2nd SIGSOFT,ACM SIGSOFT Software Eng. Notes \n19(5), pages 87 96, Dec. 1994. [8] C. Flanagan, K. R. M. Leino, M. Lillibridge, G. Nelson,J. B.Saxe, \nandR.Stata.Extended static checking for Java. In Proc. PLDI 02, 2002. [9] A. Greenhouse and J. Boyland. \nAn object-oriented e.ects system. In Proc. 13th ECOOP, number 1628 in LNCS, pages 205 229. Springer, \nJune 1999. [10] J. V. Guttag and J. J. Horning, editors. Larch: Languages and Tools for Formal Speci.cation.Texts \nand Monographs in Computer Science. Springer-Verlag, 1993. With S. J. Garland, K. D. Jones, A. Modet, \nand J. M. Wing. [11] D. Jackson. Aspect: Detecting bugs with abstract dependences. ACM Trans. Software \nEng. and Methodology, 4(2):109 145, Apr. 1995. [12] R. Joshi. Extended static checking of programs with \ncyclic dependencies. In J. Mason, editor, 1997 SRC Summer Intern Projects, Technical Note 1997-028. DEC \nSRC, 1997. [13] P. Jouvelot and D. K. Gi.ord. Algebraic reconstruction of types and e.ects. In Proc. \n18th POPL, pages 303 310, Jan. 1991. [14] G. T. Leavens, A. L. Baker, and C. Ruby. Preliminary design \nof JML: A behavioral interface speci.cation language for Java. Technical Report 98-06f, Iowa State University, \nDepartment of Computer Science, July 1999. [15] K. R. M. Leino. Toward Reliable Modular Programs. PhDthesis, \nCaltech, 1995. Technical Report Caltech-CS-TR-95-03. [16] K. R. M. Leino. Data groups: Specifying the \nmodi.cation of extended state. In Proc. OOPSLA 98, pages 144 153. ACM, 1998. [17] K. R. M. Leino. Applications \nof extended static checking. In P. Cousot, editor, Static Analysis: 8th International Symposium, SAS \n2001, volume 2126 of LNCS, pages 185 193. Springer, July 2001. [18] K. R. M. Leino. Extended static checking: \nA ten-year perspective. In R. Wilhelm, editor, Informatics 10 Years Back, 10 Years Ahead, volume 2000 \nof LNCS, pages 157 175. Springer, Jan. 2001. [19] K. R. M. Leino and G. Nelson. Data abstraction and \ninformation hiding. Research Report 160, Compaq SRC, Nov. 2000. To appear in TOPLAS. [20] B. Liskov and \nJ. Guttag. Abstraction and Speci.cation in Program Development. MIT Electrical Engineering and Computer \nScience Series. MIT Press, 1986. [21] J. McCarthy and J. Painter. Correctness of a compiler for arithmetic \nexpressions. In J.-T. Schwartz, editor, Proc. Symposia in Applied Mathematics.American Mathematical Society, \n1967. [22] C. Morgan. The speci.cation statement. ACM Trans. Prog. Lang. Syst., 10(3):403 419, July 1988. \n[23] P. M\u00a8uller. Modular Speci.cation and Veri.cation of Object-Oriented Programs, volume 2262 of LNCS. \nSpringer-Verlag, 2002. The author s PhDthesis, FernUniversit\u00a8at Hagen. [24] P. M\u00a8uller and A. Poetzsch-He.ter. \nModular speci.cation and veri.cation techniques for object-oriented software components. In G. T. Leavens \nand M. Sitaraman, editors, Foundations of Component-Based Systems, chapter 7, pages 137 159. Cambridge \nUniversity Press, 2000. [25] P. M\u00a8uller and A. Poetzsch-He.ter. Universes: A type system for alias and \ndependency control. Technical Report 279, FernUniversit\u00a8at Hagen, 2001. [26] G. Nelson. A generalization \nof Dijkstra s calculus. ACM Trans. Prog. Lang. Syst., 11(4):517 561, 1989. [27] R. Page. Functional programming, \nand where you can put it. ACM SIGPLAN Notices, 36(9):19 24, Sept. 2001. [28] A. Poetzsch-He.ter. Speci.cation \nand veri.cation of object-oriented programs. Habilitationsschrift, Technische Universit\u00a8at M\u00a8unchen, \n1997. [29] J. M. Spivey. The Z Notation: A Reference Manual. Prentice Hall International, 2nd edition \nedition, 1992. [30] J.-P. Talpin and P. Jouvelot. Polymorphic type, region and e.ect inference. Journal \nof Functional Programming, 2(3):245 271, July 1992. [31] M. Utting. Reasoning about aliasing. In Proc. \n4th Australasian Re.nement Workshop, pages 195 211. School of Comp. Sci. and Eng., The Univ. of New South \nWales, Apr. 1995. [32] M. T. Vandevoorde. Exploiting Speci.cations to Improve Program Performance.PhDthesis, \nMassachusetts Institute of Technology, Feb. 1994. Available as Technical Report MIT/LCS/TR-598. [33] \nH. Xi and F. Pfenning. Dependent types in practical programming. In Proc. 26th POPL, pages 214 227, Jan. \n1999.  \n\t\t\t", "proc_id": "512529", "abstract": "Reasoning precisely about the side effects of procedure calls is important to many program analyses. This paper introduces a technique for specifying and statically checking the side effects of methods in an object-oriented language. The technique uses <i>data groups</i>, which abstract over variables that are not in scope, and limits program behavior by two alias-confining restrictions, <i>pivot uniqueness</i> and <i>owner exclusion</i>. The technique is shown to achieve modular soundness and is simpler than previous attempts at solving this problem.", "authors": [{"name": "K. Rustan M. Leino", "author_profile_id": "81100225265", "affiliation": "Microsoft Research, Redmond, WA", "person_id": "PP42050498", "email_address": "", "orcid_id": ""}, {"name": "Arnd Poetzsch-Heffter", "author_profile_id": "81100511023", "affiliation": "Fachbereich Informatik, D-67653 Kaiserslautern, Germany", "person_id": "PP40028072", "email_address": "", "orcid_id": ""}, {"name": "Yunhong Zhou", "author_profile_id": "81542287756", "affiliation": "Compaq SRC, Palo Alto, CA", "person_id": "PP14100923", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/512529.512559", "year": "2002", "article_id": "512559", "conference": "PLDI", "title": "Using data groups to specify and check side effects", "url": "http://dl.acm.org/citation.cfm?id=512559"}